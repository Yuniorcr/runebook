<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="cdfcc78500cdaa84a66edd629ca6a9d6469e030b" translate="yes" xml:space="preserve">
          <source>It returns two strings: the first one, &lt;code&gt;$processed&lt;/code&gt; , is a part before the last starter, and the second one, &lt;code&gt;$unprocessed&lt;/code&gt; is another part after the first part. A starter is a character having a combining class of zero (see UAX #15).</source>
          <target state="translated">첫 번째 문자열 인 &lt;code&gt;$processed&lt;/code&gt; 는 마지막 시작 전 부분이고 두 번째 문자열 인 &lt;code&gt;$unprocessed&lt;/code&gt; 는 첫 번째 부분 다음의 또 다른 부분입니다. 스타터는 결합 클래스가 0 인 문자입니다 (UAX # 15 참조).</target>
        </trans-unit>
        <trans-unit id="e7d95a08ad814a7f6c58669c1b1316d305c90d5a" translate="yes" xml:space="preserve">
          <source>It sets up a class &lt;code&gt;Name&lt;/code&gt; that is a mirror of one of the implementation classes &lt;code&gt;Name_hash&lt;/code&gt; , &lt;code&gt;Name_id&lt;/code&gt; , ..., &lt;code&gt;Name_fieldhash&lt;/code&gt; . That determines which implementation is run.</source>
          <target state="translated">구현 클래스 &lt;code&gt;Name_hash&lt;/code&gt; , &lt;code&gt;Name_id&lt;/code&gt; , ..., &lt;code&gt;Name_fieldhash&lt;/code&gt; 중 하나의 미러 인 클래스 &lt;code&gt;Name&lt;/code&gt; 을 설정합니다 . 실행되는 구현을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="cb3f907f4536c2412455577e73bc09c598212b95" translate="yes" xml:space="preserve">
          <source>It should be noted that because of the double indirection in a &lt;code&gt;PerlIO *&lt;/code&gt; , a &lt;code&gt;&amp;amp;(perlio-&amp;gt;next)&lt;/code&gt; &quot;is&quot; a &lt;code&gt;PerlIO *&lt;/code&gt; , and so to some degree at least one layer can use the &quot;standard&quot; API on the next layer down.</source>
          <target state="translated">&lt;code&gt;PerlIO *&lt;/code&gt; 의 이중 간접적 때문에 , &lt;code&gt;&amp;amp;(perlio-&amp;gt;next)&lt;/code&gt; &quot;는&quot; &lt;code&gt;PerlIO *&lt;/code&gt; 이므로 어느 정도는 최소한 하나의 레이어가 다음 레이어에서 &quot;표준&quot;API를 사용할 수 있습니다. 하위.</target>
        </trans-unit>
        <trans-unit id="b14a8d613d8259f6f9199d94a881c7c7dcdcf9aa" translate="yes" xml:space="preserve">
          <source>It should be noted that the</source>
          <target state="translated">유의해야합니다</target>
        </trans-unit>
        <trans-unit id="a59ebc15941a0d3262901c5719fbfc123fcebf0b" translate="yes" xml:space="preserve">
          <source>It splits the task of generating the Makefile into several subroutines that can be individually overridden. Each subroutine returns the text it wishes to have written to the Makefile.</source>
          <target state="translated">Makefile 생성 작업을 개별적으로 재정의 할 수있는 여러 서브 루틴으로 분할합니다. 각 서브 루틴은 Makefile에 쓰려고하는 텍스트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="82c9f4b13f690f80567f90ba2a27e3429f909ad9" translate="yes" xml:space="preserve">
          <source>It starts like a perl module with a package declaration and a $VERSION variable. After that the pod section looks like any other pod with the only difference being that</source>
          <target state="translated">패키지 선언과 $ VERSION 변수가있는 perl 모듈처럼 시작합니다. 그 후 포드 섹션은 다른 포드와 비슷하지만 유일한 차이점은</target>
        </trans-unit>
        <trans-unit id="20eae6f6b825ab7ac7ea22eebe86fa7977d3df1a" translate="yes" xml:space="preserve">
          <source>It supports the following options, which are explained in &lt;a href=&quot;../text&quot;&gt;Pod::Text&lt;/a&gt;: alt, indent, loose, quotes, sentence, width</source>
          <target state="translated">&lt;a href=&quot;../text&quot;&gt;Pod :: Text에&lt;/a&gt; 설명되어있는 다음 옵션을 지원합니다 . alt, indent, loose, quotes, 문장, 너비</target>
        </trans-unit>
        <trans-unit id="41aba7727d2b065747551c63f609a3ed9ed9ee45" translate="yes" xml:space="preserve">
          <source>It suppresses duplicates in the column &lt;code&gt;in CPAN file&lt;/code&gt; such that distributions with many upgradeable modules are listed only once.</source>
          <target state="translated">&lt;code&gt;in CPAN file&lt;/code&gt; 의 열 에서 중복을 억제하여 업그레이드 가능한 모듈이 많은 분배가 한 번만 나열되도록합니다.</target>
        </trans-unit>
        <trans-unit id="65a26945a658df9dae641582923dd3754dc6d274" translate="yes" xml:space="preserve">
          <source>It takes a hash reference as an argument with two optional keys:</source>
          <target state="translated">두 개의 선택적 키가있는 인수로 해시 참조가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="8e1dcd4bfabeba9ef57034858eb07de6c007a236" translate="yes" xml:space="preserve">
          <source>It takes three arguments:</source>
          <target state="translated">세 가지 인수가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a46a1b8abd0b80e91377ad517ddde11f2ad6f67d" translate="yes" xml:space="preserve">
          <source>It tells where the old configuration file was found (if found).</source>
          <target state="translated">이전 구성 파일을 찾은 위치 (있는 경우)를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="316a78b3112e7d60b8f4b8e53c96f0951d499e19" translate="yes" xml:space="preserve">
          <source>It turns out that you can actually do this also:</source>
          <target state="translated">실제로이 작업을 수행 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="143c187acc40c6e4dc672359c95beead999d8959" translate="yes" xml:space="preserve">
          <source>It uses these values to set the extended timestamp field (ID is &quot;UT&quot;) in the local zip header using the three values, $atime, $mtime, $ctime. In addition it sets the extended timestamp field in the central zip header using &lt;code&gt;$mtime&lt;/code&gt; .</source>
          <target state="translated">이 값을 사용하여 $ atime, $ mtime, $ ctime의 세 값을 사용하여 로컬 zip 헤더에서 확장 된 타임 스탬프 필드 (ID는 &quot;UT&quot;)를 설정합니다. 또한 &lt;code&gt;$mtime&lt;/code&gt; 사용하여 중앙 zip 헤더의 확장 타임 스탬프 필드를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="f6d084cee81998d6ff3982adc3ae633d6de17437" translate="yes" xml:space="preserve">
          <source>It was easy to write by having it call the Unix cat(1) command, but it would probably be more portable to open the file manually (and somewhat more efficient). Of course, because dot files are a Unixy concept, we're not that concerned.</source>
          <target state="translated">Unix cat (1) 명령을 호출하면 작성하기 쉬웠지만 파일을 수동으로 (보다 다소 효율적으로) 여는 것이 더 이식성이 좋을 것입니다. 물론, 도트 파일은 Unixy 개념이므로 그다지 걱정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c142dca333e2894efe138704aae3906df8914b33" translate="yes" xml:space="preserve">
          <source>It was extracted to dual-life on CPAN at version 1.95 by Paul Evans &amp;lt;leonerd@leonerd.org.uk&amp;gt;</source>
          <target state="translated">Paul Evans &amp;lt;leonerd@leonerd.org.uk&amp;gt;에 의해 버전 1.95의 CPAN에서 이중 수명으로 추출되었습니다.</target>
        </trans-unit>
        <trans-unit id="d62846658b7b31f9fc5efa8815011f4172e2d224" translate="yes" xml:space="preserve">
          <source>It was introduced to avoid the potential problems with the other form, available in all Perls. That form consists of a backslash followed by three octal digits. One problem with this form is that it can look exactly like an old-style backreference (see &lt;a href=&quot;#Disambiguation-rules-between-old-style-octal-escapes-and-backreferences&quot;&gt;Disambiguation rules between old-style octal escapes and backreferences&lt;/a&gt; below.) You can avoid this by making the first of the three digits always a zero, but that makes \077 the largest code point specifiable.</source>
          <target state="translated">모든 Perls에서 사용 가능한 다른 형식의 잠재적 문제를 피하기 위해 도입되었습니다. 이 형식은 백 슬래시와 3 개의 8 진수로 구성됩니다. 이 형식의 한 가지 문제점은 이전 스타일의 역 참조와 똑같이 보일 수 있다는 것입니다 (아래의 &lt;a href=&quot;#Disambiguation-rules-between-old-style-octal-escapes-and-backreferences&quot;&gt;이전 스타일 8 진 이스케이프와 역 참조 간의 명확성 규칙 참조&lt;/a&gt; ). 세 자리 중 첫 번째 숫자를 항상 0으로 설정하면이를 피할 수 있습니다. \ 077을 가장 큰 코드 포인트로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3ee2a6714e3e6adf556faba68422a058c942c27" translate="yes" xml:space="preserve">
          <source>It will also use a default typemap installed as &lt;code&gt;ExtUtils::typemap&lt;/code&gt; .</source>
          <target state="translated">또한 &lt;code&gt;ExtUtils::typemap&lt;/code&gt; 설치된 기본 유형 맵을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="49ab6ec702b4749c563dad7126fbebc3ad5a9050" translate="yes" xml:space="preserve">
          <source>It will also use the &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Locale&quot;&gt;Win32::Locale&lt;/a&gt; module, if it's installed.</source>
          <target state="translated">설치된 경우 &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Locale&quot;&gt;Win32 :: Locale&lt;/a&gt; 모듈 도 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="eebcb44cc4b0d0bb319df0e9deccc15987032c7b" translate="yes" xml:space="preserve">
          <source>It will always have at least one parameter automatically passed by Perl - this corresponds to the name of the package. In the example above it will be &lt;code&gt;&quot;MyFilter&quot;&lt;/code&gt; .</source>
          <target state="translated">항상 Perl에 의해 자동으로 전달되는 하나 이상의 매개 변수가 있습니다. 이것은 패키지 이름에 해당합니다. 위의 예에서는 &lt;code&gt;&quot;MyFilter&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9b05bb9d8d6cf0031940a72fb71a5bc98935f18a" translate="yes" xml:space="preserve">
          <source>It will default to the global setting of &lt;code&gt;$IPC::Cmd::VERBOSE&lt;/code&gt; , which by default is 0.</source>
          <target state="translated">&lt;code&gt;$IPC::Cmd::VERBOSE&lt;/code&gt; 의 전역 설정이 기본값이며 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="5c5106e7131ba864011023c16e2d910c408243d8" translate="yes" xml:space="preserve">
          <source>It will exit with 255.</source>
          <target state="translated">255로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="cd3560715bcdcdb5a5493a3c2aa8a0baf196fb75" translate="yes" xml:space="preserve">
          <source>It will look in the environment for a</source>
          <target state="translated">그것은 환경에서 볼 것입니다</target>
        </trans-unit>
        <trans-unit id="11ba08d3329959d8ccf0a41d4bc0caadee83aee8" translate="yes" xml:space="preserve">
          <source>It will not do what you think, e.g. making a copy of $x. Instead it just makes a second reference to the &lt;b&gt;same&lt;/b&gt; object and stores it in $y. Thus anything that modifies $x (except overloaded operators) will modify $y, and vice versa. Or in other words, &lt;code&gt;=&lt;/code&gt; is only safe if you modify your BigInts only via overloaded math. As soon as you use a method call it breaks:</source>
          <target state="translated">예를 들어 $ x의 사본을 만드는 등의 생각은하지 않습니다. 대신 &lt;b&gt;동일한&lt;/b&gt; 객체에 대한 두 번째 참조를 만들고 $ y에 저장합니다. 따라서 $ x를 수정하는 것은 오버로드 된 연산자를 제외하고 $ y를 수정하고 그 반대도 마찬가지입니다. 즉, &lt;code&gt;=&lt;/code&gt; 는 오버로드 된 수학을 통해서만 BigInts를 수정하는 경우에만 안전합니다. 메소드 호출을 사용하자마자 깨집니다.</target>
        </trans-unit>
        <trans-unit id="4ef09ffb235f52f01cd3d25c0c384cab0806a14c" translate="yes" xml:space="preserve">
          <source>It will not do what you think, e.g. making a copy of $x. Instead it just makes a second reference to the &lt;b&gt;same&lt;/b&gt; object and stores it in $y. Thus anything that modifies $x will modify $y (except overloaded math operators), and vice versa. See &lt;a href=&quot;bigint&quot;&gt;Math::BigInt&lt;/a&gt; for details and how to avoid that.</source>
          <target state="translated">예를 들어 $ x의 사본을 만드는 등의 생각은하지 않습니다. 대신 &lt;b&gt;동일한&lt;/b&gt; 객체에 대한 두 번째 참조를 만들고 $ y에 저장합니다. 따라서 $ x를 수정하는 것은 $ y를 수정하고 (과도한 수학 연산자는 제외) 그 반대도 마찬가지입니다. 자세한 내용과이를 피하는 방법 은 &lt;a href=&quot;bigint&quot;&gt;Math :: BigInt&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dd48a6ec2ae8cb512d05f750d53684c09ff6166d" translate="yes" xml:space="preserve">
          <source>It will print 'A' and then terminate, as it considers the match to be zero-width, and thus will not match at the same position twice in a row.</source>
          <target state="translated">'A'를 인쇄 한 다음 일치하는 너비를 0으로 간주하여 종료되므로 동일한 위치에서 두 번 연속 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="478635e0153852c95d172e95b14a9c73a7376ef9" translate="yes" xml:space="preserve">
          <source>It will produce output like this:</source>
          <target state="translated">다음과 같은 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="033bdc255180f8b012ecc3dd8743f6cfc3998050" translate="yes" xml:space="preserve">
          <source>It will return undef if it was not able to find where the module was installed, or a hash reference with the following keys if it was able to find the file:</source>
          <target state="translated">모듈이 설치된 위치를 찾을 수 없으면 undef를 반환하거나 파일을 찾을 수 있으면 다음 키를 사용하는 해시 참조를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8fd1f4b13738ec21f8b65433f2c797f00d69b112" translate="yes" xml:space="preserve">
          <source>It won't work across a sequence of &lt;code&gt;store&lt;/code&gt; and &lt;code&gt;retrieve&lt;/code&gt; operations, however, because the addresses in the retrieved objects, which are part of the stringified references, will probably differ from the original addresses. The topology of your structure is preserved, but not hidden semantics like those.</source>
          <target state="translated">그러나 문자열 참조의 일부인 검색된 객체의 주소가 원래 주소와 다를 수 있기 때문에 일련의 &lt;code&gt;store&lt;/code&gt; 및 &lt;code&gt;retrieve&lt;/code&gt; 작업에서는 작동하지 않습니다 . 구조의 토폴로지는 유지되지만 숨겨진 의미론은 유지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d829aa608b7d822354368e8bc717a7f78948e864" translate="yes" xml:space="preserve">
          <source>It works on references, too:</source>
          <target state="translated">참조에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="063657847573da8f9a48b2f56cfac7e5ef0c0bcc" translate="yes" xml:space="preserve">
          <source>It works this way as of Perl 5.18. Historically, it was inconsistent, and you would have to write</source>
          <target state="translated">Perl 5.18부터이 방식으로 작동합니다. 역사적으로 일관성이 없었으므로 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="4c5e6eff5a06238d171586dbb35b0a88b0b974e6" translate="yes" xml:space="preserve">
          <source>It would be even more readable to write that this way:</source>
          <target state="translated">이런 식으로 쓰는 것이 훨씬 더 읽기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="bb356348d0e8eb250c8d665196d735d29e867b02" translate="yes" xml:space="preserve">
          <source>It would be much better if you could ignore the NULL terminations issue in the main application code and have a mechanism that automatically added the terminating NULL to all keys and values whenever you write to the database and have them removed when you read from the database. As I'm sure you have already guessed, this is a problem that DBM Filters can fix very easily.</source>
          <target state="translated">기본 응용 프로그램 코드에서 NULL 종료 문제를 무시하고 데이터베이스에 쓸 때마다 모든 키와 값에 종료 NULL을 자동으로 추가하고 데이터베이스에서 읽을 때 제거하는 메커니즘을 갖는 것이 훨씬 좋습니다. 이미 짐작했듯이 DBM 필터가 매우 쉽게 해결할 수있는 문제입니다.</target>
        </trans-unit>
        <trans-unit id="664879d0a9a8a0187a85ff4778c8dc4aba203972" translate="yes" xml:space="preserve">
          <source>It would be much safer if the &lt;code&gt;upcase_in()&lt;/code&gt; function were written to return a copy of its parameters instead of changing them in place:</source>
          <target state="translated">&lt;code&gt;upcase_in()&lt;/code&gt; 함수를 사용하여 매개 변수를 변경하는 대신 매개 변수의 사본을 리턴하도록 작성하는 것이 훨씬 안전합니다 .</target>
        </trans-unit>
        <trans-unit id="e4a501eefab1e263f175f9fb282fe6f38bf8d7a7" translate="yes" xml:space="preserve">
          <source>It would be nice if one could leave off the commas around the constants entirely and just say:</source>
          <target state="translated">상수 주위에 쉼표를 완전히 남기고 다음과 같이 말하면 좋을 것입니다.</target>
        </trans-unit>
        <trans-unit id="7a5b5ee29fb341a3488cf2301ee04c0c66aa8f82" translate="yes" xml:space="preserve">
          <source>It would be nice if we could do this in one fell swoop: unpack a short, back up a little, and then unpack 2 bytes. Since Perl</source>
          <target state="translated">한 번에이 작업을 수행 할 수 있다면 좋을 것입니다. 짧은 압축을 풀고 약간 백업 한 다음 2 바이트를 압축 해제하십시오. 펄 이후</target>
        </trans-unit>
        <trans-unit id="dcfbbfc45bc8f20d112951dc582ad08e297b4815" translate="yes" xml:space="preserve">
          <source>It would be nice to support encoding to non-UTF8, such as =?ISO-2022-JP? and =?ISO-8859-1?= but that makes the implementation too complicated. These days major mail agents all support =?UTF-8? so I think it is just good enough.</source>
          <target state="translated">=? ISO-2022-JP?와 같은 비 UTF8 로의 인코딩을 지원하는 것이 좋을 것입니다. 그리고 =? ISO-8859-1? = 그러나 그것은 구현을 너무 복잡하게 만듭니다. 요즘 주요 메일 에이전트는 모두 =? UTF-8? 충분하다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="33c0be04ddea1d5a74e0dccb69b13ad0c437b131" translate="yes" xml:space="preserve">
          <source>It would put the generated files into needed locations. Manually put</source>
          <target state="translated">생성 된 파일을 필요한 위치에 넣습니다. 수동으로 넣어</target>
        </trans-unit>
        <trans-unit id="79d53b44344312c7f974c895e0fb0eb2bd88118d" translate="yes" xml:space="preserve">
          <source>It's a Perl 4 style file defining values for system networking constants. Sometimes it is built using &lt;a href=&quot;h2ph&quot;&gt;h2ph&lt;/a&gt; when Perl is installed, but other times it is not. Modern programs should use &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Socket;&lt;/code&gt; instead.</source>
          <target state="translated">시스템 네트워킹 상수 값을 정의하는 Perl 4 스타일 파일입니다. 때로는 Perl을 설치할 때 &lt;a href=&quot;h2ph&quot;&gt;h2ph를&lt;/a&gt; 사용하여 빌드 되지만 그렇지 않은 경우도 있습니다. 최신 프로그램은 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Socket;&lt;/code&gt; 사용해야 &lt;a href=&quot;functions/use&quot;&gt;합니다&lt;/a&gt; . 대신에.</target>
        </trans-unit>
        <trans-unit id="4113134dec0bea10f51321538387f13a1da8743a" translate="yes" xml:space="preserve">
          <source>It's a cardinal sin to break existing Perl programs. New warnings can be contentious--some say that a program that emits warnings is not broken, while others say it is. Adding keywords has the potential to break programs, changing the meaning of existing token sequences or functions might break programs.</source>
          <target state="translated">기존 Perl 프로그램을 중단하는 것은 기본적인 죄입니다. 새로운 경고는 논쟁의 여지가 있습니다. 어떤 사람들은 경고를내는 프로그램이 깨지지 않았고 다른 사람들은 그렇게 말합니다. 키워드를 추가하면 프로그램이 중단 될 가능성이 있으며 기존 토큰 시퀀스 또는 함수의 의미를 변경하면 프로그램이 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3443bb54ef3fac59b8ef057b86f52fe4980fafa5" translate="yes" xml:space="preserve">
          <source>It's a little tricker with c2ph because you have to get the includes right. I can't know this for your system, but it's not usually too terribly difficult.</source>
          <target state="translated">포함을 올바르게 가져와야하기 때문에 c2ph에는 약간의 속임수가 있습니다. 나는 당신의 시스템에 대해 이것을 알 수 없지만 일반적으로 너무 어렵지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="110a6a21060fbfe67381c1323cb9f71073b9732c" translate="yes" xml:space="preserve">
          <source>It's also possible to get into trouble with other operations that don't care whether they use tainted values. Make judicious use of the file tests in dealing with any user-supplied filenames. When possible, do opens and such &lt;b&gt;after&lt;/b&gt; properly dropping any special user (or group!) privileges. Perl doesn't prevent you from opening tainted filenames for reading, so be careful what you print out. The tainting mechanism is intended to prevent stupid mistakes, not to remove the need for thought.</source>
          <target state="translated">오염 된 값을 사용하는지 여부를 신경 쓰지 않는 다른 작업에 어려움을 겪을 수도 있습니다. 사용자 제공 파일 이름을 처리 할 때 파일 테스트를 신중하게 사용하십시오. 가능하면 특수 사용자 (또는 그룹!) 권한 &lt;b&gt;을&lt;/b&gt; 올바르게 삭제 &lt;b&gt;한 후&lt;/b&gt; 열어야합니다. Perl은 오염 된 파일 이름을 열지 못하도록 막지 않으므로 인쇄 할 때는주의하십시오. 오염 메커니즘은 어리석은 실수를 방지하고 사고의 필요성을 제거하기위한 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="66317ba5ef9718c34fadba6cc4766d4c890f748d" translate="yes" xml:space="preserve">
          <source>It's also the source of a useful idiom for executing a function or performing an operation in list context and then counting the number of return values, by assigning to an empty list and then using that assignment in scalar context. For example, this code:</source>
          <target state="translated">또한 함수를 실행하거나 목록 컨텍스트에서 연산을 수행 한 다음 빈 목록에 할당 한 다음 스칼라 컨텍스트에서 해당 할당을 사용하여 반환 값 수를 계산하는 데 유용한 관용구의 소스이기도합니다. 예를 들어이 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fb0964e5585557a9c666044136d7fe7eaf45d2a2" translate="yes" xml:space="preserve">
          <source>It's also too slow (despite caching).</source>
          <target state="translated">또한 너무 느립니다 (캐싱에도 불구하고).</target>
        </trans-unit>
        <trans-unit id="bfb78b8d261485bbdd288bb61ac4516df58d28f5" translate="yes" xml:space="preserve">
          <source>It's also useful in those cases where you are comparing numbers and &lt;code&gt;is()&lt;/code&gt; 's use of &lt;code&gt;eq&lt;/code&gt; will interfere:</source>
          <target state="translated">또한 숫자를 비교하고 &lt;code&gt;is()&lt;/code&gt; 의 &lt;code&gt;eq&lt;/code&gt; 사용 이 방해 하는 경우에도 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="8752339d213c2f85078fabecb615c362db1828df" translate="yes" xml:space="preserve">
          <source>It's also worth taking a moment to explain what happens when you &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ize a member of a composite type (i.e. an array or hash element). In this case, the element is &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ized</source>
          <target state="translated">또한 복합 유형의 멤버 (예 : 배열 또는 해시 요소) 를 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 화할 때 발생하는 상황을 설명하는 데 시간이 걸립니다 . 이 경우 요소는 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 화됩니다</target>
        </trans-unit>
        <trans-unit id="bd541e8b6a88392365f934744a878ca9f6a497b7" translate="yes" xml:space="preserve">
          <source>It's better to have numerous simple routines than a few monolithic ones. If your routine changes its behaviour significantly based on its arguments, it's a sign that you should have two (or more) separate routines.</source>
          <target state="translated">모 놀리 식 몇 가지보다 많은 간단한 루틴을 갖는 것이 좋습니다. 루틴이 인수를 기반으로 동작을 크게 변경하는 경우 두 개 이상의 별도 루틴이 있어야한다는 신호입니다.</target>
        </trans-unit>
        <trans-unit id="f3b2de78648bbd7090bfe684b2c6827590ea2a26" translate="yes" xml:space="preserve">
          <source>It's designed to be used as a handy command line utility:</source>
          <target state="translated">편리한 명령 줄 유틸리티로 사용하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="96439b3081e445faf2fae88934bbc314011a0c32" translate="yes" xml:space="preserve">
          <source>It's easy to notice the problem in such a short example, but in more complicated code you are looking for trouble if you don't localize changes to the special variables.</source>
          <target state="translated">짧은 예제에서 문제를 쉽게 알 수 있지만 더 복잡한 코드에서는 특수 변수의 변경 사항을 현지화하지 않으면 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="dde0b49167dc00c194116739ebbe7f23d5e20372" translate="yes" xml:space="preserve">
          <source>It's egg-eating all over again: Some think that as a bit string this should be written &quot;10001100&quot; i.e. beginning with the most significant bit, others insist on &quot;00110001&quot;. Well, Perl isn't biased, so that's why we have two bit string codes:</source>
          <target state="translated">그것은 다시 한번 계란을 먹는 것입니다. 어떤 사람들은 이것을 비트 문자열로 &quot;10001100&quot;으로 기록해야한다고 생각합니다. 즉, 가장 중요한 비트로 시작하고 다른 사람들은 &quot;00110001&quot;을 고집합니다. 글쎄, Perl은 편향되어 있지 않기 때문에 두 개의 비트 문자열 코드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f24807b6184833a23a70254e8f0aebceeb147f40" translate="yes" xml:space="preserve">
          <source>It's especially useful when comparing greater-than or smaller-than relation between values:</source>
          <target state="translated">값 사이의 관계를 비교할 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1e3a1b4314f9d6c52bc40629c2fb29defff528f6" translate="yes" xml:space="preserve">
          <source>It's essential to run any timing measurements a sufficient number of times so the numbers settle on a numerical average, otherwise each run will naturally fluctuate due to variations in the environment, to reduce the effect of contention for &lt;code&gt;CPU&lt;/code&gt; resources and network bandwidth for instance. Running the above code for one million iterations, we can take a look at the report output by the &lt;code&gt;Benchmark&lt;/code&gt; module, to see which approach is the most effective.</source>
          <target state="translated">숫자 측정 값이 숫자 평균으로 설정되도록 타이밍 측정을 충분한 횟수로 실행해야합니다. 그렇지 않으면 환경의 변화로 인해 각 실행이 자연스럽게 변동되어 &lt;code&gt;CPU&lt;/code&gt; 리소스 및 네트워크 대역폭에 대한 경합의 영향을 줄 입니다. 백만 번 반복하여 위의 코드를 실행하면 &lt;code&gt;Benchmark&lt;/code&gt; 모듈 의 보고서 출력 을보고 어떤 접근 방식이 가장 효과적인지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7514b40c5333fb03e3aac77ea8c92f752cf5dd0e" translate="yes" xml:space="preserve">
          <source>It's for</source>
          <target state="translated">그것은</target>
        </trans-unit>
        <trans-unit id="b4b810adc86730679601de6a1493c2a23c259247" translate="yes" xml:space="preserve">
          <source>It's good idea to post an announcement of the availability of your module (or the module itself if small) to the comp.lang.perl.announce Usenet newsgroup. This will at least ensure very wide once-off distribution.</source>
          <target state="translated">comp.lang.perl.announce 유즈넷 뉴스 그룹에 모듈 (또는 작은 경우 모듈 자체)의 가용성에 대한 알림을 게시하는 것이 좋습니다. 이것은 최소한 매우 광범위한 일회용 배포를 보장합니다.</target>
        </trans-unit>
        <trans-unit id="90af562410b60653a0aa18fd2da97246062921f5" translate="yes" xml:space="preserve">
          <source>It's good that you lost track, because you shouldn't depend on the internal format being any specific encoding. But since you asked: by default, the internal format is either ISO-8859-1 (latin-1), or utf8, depending on the history of the string. On EBCDIC platforms, this may be different even.</source>
          <target state="translated">특정 인코딩 인 내부 형식에 의존해서는 안되므로 트랙을 잃어 버리는 것이 좋습니다. 그러나 요청한 이후 : 기본적으로 내부 형식은 문자열 기록에 따라 ISO-8859-1 (라틴 -1) 또는 utf8입니다. EBCDIC 플랫폼에서는이 기능이 다를 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9d2e12c0d08cbda4c9a91e7d799364ca6410b91" translate="yes" xml:space="preserve">
          <source>It's important that $how_many accurately reflects the number of tests in the SKIP block so the # of tests run will match up with your plan. If your plan is &lt;code&gt;no_plan&lt;/code&gt; $how_many is optional and will default to 1.</source>
          <target state="translated">$ how_many가 SKIP 블록의 테스트 수를 정확하게 반영하는 것이 중요하므로 실행 된 테스트 수가 계획과 일치해야합니다. 계획이 &lt;code&gt;no_plan&lt;/code&gt; 인 경우 $ how_many는 선택 사항이며 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="1e8b6f334f8979bc29ccd072552302ba947b27dc" translate="yes" xml:space="preserve">
          <source>It's important to know what custom operators won't do for you. They won't let you add new syntax to Perl, directly. They won't even let you add new keywords, directly. In fact, they won't change the way Perl compiles a program at all. You have to do those changes yourself, after Perl has compiled the program. You do this either by manipulating the op tree using a &lt;code&gt;CHECK&lt;/code&gt; block and the &lt;code&gt;B::Generate&lt;/code&gt; module, or by adding a custom peephole optimizer with the &lt;code&gt;optimize&lt;/code&gt; module.</source>
          <target state="translated">사용자 지정 연산자가 무엇을하지 않는지 아는 것이 중요합니다. Perl에 새로운 구문을 직접 추가 할 수는 없습니다. 새 키워드를 직접 추가 할 수도 없습니다. 사실, 그들은 Perl이 프로그램을 컴파일하는 방식을 전혀 바꾸지 않을 것입니다. Perl이 프로그램을 컴파일 한 후에는 이러한 변경을 직접 수행해야합니다. &lt;code&gt;CHECK&lt;/code&gt; 블록과 &lt;code&gt;B::Generate&lt;/code&gt; 모듈을 사용하여 op 트리를 조작 하거나 &lt;code&gt;optimize&lt;/code&gt; 모듈 과 함께 맞춤 구멍 최적화기를 추가 하여이 작업을 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="885ff1b611d651161375b8dbd778f67a1c287d62" translate="yes" xml:space="preserve">
          <source>It's important to note that locks don't prevent access to the variable in question, only lock attempts. This is in keeping with Perl's longstanding tradition of courteous programming, and the advisory file locking that &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock()&lt;/a&gt;&lt;/code&gt; gives you.</source>
          <target state="translated">잠금은 문제의 변수에 대한 액세스를 방해하지 않으며 잠금 시도 만한다는 점에 유의해야합니다. 이것은 Perl의 오랜 전통적 프로그래밍의 전통과 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock()&lt;/a&gt;&lt;/code&gt; 제공 하는 권고 파일 잠금을 유지하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b0ddbbe7b1b79fc3086fea949fd8823cad9c01f9" translate="yes" xml:space="preserve">
          <source>It's important to note that the resulting string does &lt;b&gt;not&lt;/b&gt; contain the padding characters typical of Base64 encodings. This omission is deliberate, and is done to maintain compatibility with the family of CPAN Digest modules. See &lt;a href=&quot;#PADDING-OF-BASE64-DIGESTS&quot;&gt;PADDING OF BASE64 DIGESTS&lt;/a&gt; for details.</source>
          <target state="translated">결과 문자열에는 Base64 인코딩의 일반적인 패딩 문자가 포함 되지 &lt;b&gt;않습니다&lt;/b&gt; . 이 생략은 의도적이며 CPAN 다이제스트 모듈 제품군과의 호환성을 유지하기 위해 수행됩니다. 자세한 내용은 &lt;a href=&quot;#PADDING-OF-BASE64-DIGESTS&quot;&gt;BASE64 수치의 패딩&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ebc53949ff6cd0c67b2204f9d9fce4d627aed693" translate="yes" xml:space="preserve">
          <source>It's important to realize that there are no bytes in a text string. Of course, Perl has its internal encoding to store the string in memory, but ignore that. If you have to do anything with the number of bytes, it's probably best to move that part to step 3, just after you've encoded the string. Then you know exactly how many bytes it will be in the destination string.</source>
          <target state="translated">텍스트 문자열에 바이트가 없다는 것을 인식하는 것이 중요합니다. 물론 Perl은 문자열을 메모리에 저장하기위한 내부 인코딩을 가지고 있지만 무시합니다. 바이트 수로 무언가를 해야하는 경우 문자열을 인코딩 한 직후에 해당 부분을 3 단계로 이동하는 것이 가장 좋습니다. 그런 다음 대상 문자열에 얼마나 많은 바이트가 있는지 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="968be3dc629433b16258b1052384042ab95062a2" translate="yes" xml:space="preserve">
          <source>It's important to set a few things straight first. This is the most important part of this tutorial. This view may conflict with other information that you may have found on the web, but that's mostly because many sources are wrong.</source>
          <target state="translated">몇 가지를 먼저 설정하는 것이 중요합니다. 이것은이 튜토리얼에서 가장 중요한 부분입니다. 이보기는 웹에서 찾은 다른 정보와 충돌 할 수 있지만 대부분의 출처가 잘못 되었기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="6903f2d3d35327d3bebb7683e89ad822d6bff850" translate="yes" xml:space="preserve">
          <source>It's important to understand that we are specifically</source>
          <target state="translated">우리가 구체적으로 있다는 것을 이해하는 것이 중요합니다</target>
        </trans-unit>
        <trans-unit id="f9b3935d15d2be2d5136d58cf490c65310c19874" translate="yes" xml:space="preserve">
          <source>It's important you make sure to use the &lt;code&gt;[ ]&lt;/code&gt; array reference constructor. That's because this wouldn't work:</source>
          <target state="translated">반드시 &lt;code&gt;[ ]&lt;/code&gt; 배열 참조 생성자 를 사용해야합니다 . 이것이 작동하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="134dc1d9bd724d0238c1c1d4c4831e9e7f0b91b6" translate="yes" xml:space="preserve">
          <source>It's likely you'll have to add new data types later.</source>
          <target state="translated">나중에 새 데이터 유형을 추가해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4696eb464dfb95137de621144fb7f593ad6ebd66" translate="yes" xml:space="preserve">
          <source>It's not (not!) the boundary between whitespace and non-whitespace, and it's not the stuff between words we use to create sentences.</source>
          <target state="translated">공백과 공백이 아닌 경계가 아니며 문장을 만드는 데 사용하는 단어 사이의 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6bef3566d208cec3b519ea92214ab4883f383173" translate="yes" xml:space="preserve">
          <source>It's not a good idea to split a construct in the middle like this, and it doesn't work here. Instead use the solution above.</source>
          <target state="translated">이와 같이 중간에 구문을 분할하는 것은 좋지 않으며 여기서는 작동하지 않습니다. 대신 위의 솔루션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ec66dac5bae6d199b4bd16298b91f74283fac7f8" translate="yes" xml:space="preserve">
          <source>It's not as easy a problem as it looks. How many words do you think are in there? Wait for it... wait for it.... If you answered 5 you're right. Perl words are groups of &lt;code&gt;\w+&lt;/code&gt; , but that's not what you want to capitalize. How is Perl supposed to know not to capitalize that &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; after the apostrophe? You could try a regular expression:</source>
          <target state="translated">보이는 것처럼 쉬운 문제는 아닙니다. 거기에 얼마나 많은 단어가 있다고 생각하십니까? 기다려 봐 ... 기다려 봐 .... 5라고 대답하면 맞아. 펄 단어는 &lt;code&gt;\w+&lt;/code&gt; 그룹 이지만 대문자로 표시하려는 것은 아닙니다. 어떻게 펄은 투자하지 알고 가정된다 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 아포스트로피 후? 정규식을 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f3fa5386c065511869ec9dc4289bdbe2b8248c4" translate="yes" xml:space="preserve">
          <source>It's not enough to say: &quot;that will make it run faster&quot;, you have to check it. Rerun the code under control of the benchmarking or profiling modules, from the first step above, and check that the new code executed the &lt;b&gt;same task&lt;/b&gt; in</source>
          <target state="translated">&quot;더 빨리 실행되게 할 것&quot;이라고 말하면 충분하지 않으므로 확인해야합니다. 위의 첫 번째 단계에서 벤치마킹 또는 프로파일 링 모듈을 제어하여 코드를 다시 실행하고 새 코드가 &lt;b&gt;동일한 작업&lt;/b&gt; 을 실행했는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="ac2ff02b85c831d3f4a6ab13ec2cd187eee43782" translate="yes" xml:space="preserve">
          <source>It's not possible to individually showcase all the performance related code for Perl here, naturally, but here's a short list of modules from the CPAN which deserve further attention.</source>
          <target state="translated">Perl에 대한 모든 성능 관련 코드를 개별적으로 보여줄 수는 없지만 CPAN의 간단한 모듈 목록이 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd227a742cbf3f4b2811cdbf8769ec886d4ea747" translate="yes" xml:space="preserve">
          <source>It's not possible to use this module to embed formatting and color attributes using Perl formats. They replace the escape character with a space (as documented in</source>
          <target state="translated">이 모듈을 사용하여 Perl 형식을 사용하여 형식 및 색상 속성을 포함 할 수 없습니다. 이스케이프 문자를 공백으로 바꿉니다 (</target>
        </trans-unit>
        <trans-unit id="8cf7485885d18503520503d1c1deed4967629127" translate="yes" xml:space="preserve">
          <source>It's not really a barrel of laughs, is it? In fact, it's worse than it may seem; the eagle-eyed may notice that the first field should only be 10 characters wide, and the error has propagated right through the other numbers - which we've had to count by hand. So it's error-prone as well as horribly unfriendly.</source>
          <target state="translated">그것은 실제로 웃음의 배럴이 아닙니다. 실제로, 그것은 보이는 것보다 더 나쁩니다. 독수리 눈은 첫 번째 필드의 너비가 10 자 여야하며 오류는 다른 숫자를 통해 바로 전파되었음을 알 수 있습니다.이 숫자는 우리가 직접 계산해야했습니다. 따라서 오류가 발생하기 쉽고 비우호적입니다.</target>
        </trans-unit>
        <trans-unit id="a9d4e78b20b4ec5c47ad5e65cf852abb8251388b" translate="yes" xml:space="preserve">
          <source>It's ok for your test to change where STDOUT and STDERR point to, Test::Builder's default output settings will not be affected.</source>
          <target state="translated">STDOUT 및 STDERR이 Test :: Builder의 기본 출력 설정에 영향을 미치지 않는 위치를 테스트에서 변경해도됩니다.</target>
        </trans-unit>
        <trans-unit id="e6c4906faf9dc43631913b5936b5f4e02175738c" translate="yes" xml:space="preserve">
          <source>It's only intended as a rough tool. You may need to dicker with the files produced.</source>
          <target state="translated">거친 도구로만 사용됩니다. 생성 된 파일을 잘 살펴 봐야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ad5389b057242e5f2754208243d1e536ed13fdf" translate="yes" xml:space="preserve">
          <source>It's only written as a helper module for both CPAN.pm and CPANPLUS.pm.</source>
          <target state="translated">CPAN.pm 및 CPANPLUS.pm 모두에 대한 도우미 모듈로만 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="ce38cb5abf7b4d320a0e699a61e26594815c5fdf" translate="yes" xml:space="preserve">
          <source>It's perfectly safe to nest SKIP blocks. Each SKIP block must have the label &lt;code&gt;SKIP&lt;/code&gt; , or Test::More can't work its magic.</source>
          <target state="translated">SKIP 블록을 중첩하는 것이 안전합니다. 각 SKIP 블록은 라벨이 있어야합니다 &lt;code&gt;SKIP&lt;/code&gt; 을 , 또는 테스트 :: 자세히 마법을 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23089c9252263a75014f4ca3ca447b38592d18ae" translate="yes" xml:space="preserve">
          <source>It's possible that not all modules listed below are installed on your system. For example, the GDBM_File module will not be installed if you don't have the gdbm library.</source>
          <target state="translated">아래 나열된 모든 모듈이 시스템에 설치되어 있지 않을 수 있습니다. 예를 들어, gdbm 라이브러리가 없으면 GDBM_File 모듈이 설치되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d7827a4cab49cd207c98c793d3174f1c8aaeda1" translate="yes" xml:space="preserve">
          <source>It's possible to change the MRO of a given class either by using &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
mro&lt;/code&gt; as shown in the synopsis, or by using the &lt;a href=&quot;#mro%3a%3aset_mro&quot;&gt;mro::set_mro&lt;/a&gt; function below.</source>
          <target state="translated">개요에 표시된대로 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; mro&lt;/code&gt; 를 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하거나 아래 의 &lt;a href=&quot;#mro%3a%3aset_mro&quot;&gt;mro :: set_mro&lt;/a&gt; 함수 를 사용 하여 지정된 클래스의 MRO를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8141ee35a9c20672528ff17c177b18bb4b35dc61" translate="yes" xml:space="preserve">
          <source>It's possible to have a class that does not expose any publicly settable attributes. Not every class has attributes and methods.</source>
          <target state="translated">공개적으로 설정 가능한 속성을 노출시키지 않는 클래스를 가질 수 있습니다. 모든 클래스에 속성과 메소드가있는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="fdf6b6ef2b9e4a59b56ec7ba91fcecae99b94163" translate="yes" xml:space="preserve">
          <source>It's possible to load multiple features together, using a</source>
          <target state="translated">를 사용하여 여러 기능을 함께로드 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="66c778a3281518c9b26558498194320e4725fef9" translate="yes" xml:space="preserve">
          <source>It's possible to take the previous idea a little further, by using a compile time &lt;code&gt;DEBUG&lt;/code&gt; constant.</source>
          <target state="translated">컴파일 타임 &lt;code&gt;DEBUG&lt;/code&gt; 상수를 사용하여 이전 아이디어를 조금 더 진행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="30a0b506f4d59de09c1852a82f659060edd73925" translate="yes" xml:space="preserve">
          <source>It's possible to use simple addition and subtraction of objects:</source>
          <target state="translated">객체의 간단한 덧셈과 뺄셈을 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="b2798edf93af2bc08dca21c6c73367266b229901" translate="yes" xml:space="preserve">
          <source>It's probably best to copy one of the existing runops functions and change it to suit your needs. Then, in the BOOT section of your XS file, add the line:</source>
          <target state="translated">기존 runops 함수 중 하나를 복사하여 필요에 맞게 변경하는 것이 가장 좋습니다. 그런 다음 XS 파일의 BOOT 섹션에서 다음 행을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="b340d427890b7b2748a883b3fba121b10e7d2921" translate="yes" xml:space="preserve">
          <source>It's probably best to prototype new functions, not retrofit prototyping into older ones. That's because you must be especially careful about silent impositions of differing list versus scalar contexts. For example, if you decide that a function should take just one parameter, like this:</source>
          <target state="translated">프로토 타입을 구형으로 개조하지 않고 새로운 기능을 프로토 타입하는 것이 가장 좋습니다. 리스트와 스칼라 컨텍스트가 다른 자동 임 포징에 특히주의해야하기 때문입니다. 예를 들어, 함수가 다음과 같이 하나의 매개 변수 만 가져야한다고 결정한 경우 :</target>
        </trans-unit>
        <trans-unit id="91ff9edf126b862a4aaa943668bacea81314c045" translate="yes" xml:space="preserve">
          <source>It's probably better to always use commas after constant names in order to force the next error.</source>
          <target state="translated">다음 오류를 강제하기 위해 항상 상수 이름 뒤에 쉼표를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="16dbf025d239b7a2bc2c7033417d6a18d06e2afb" translate="yes" xml:space="preserve">
          <source>It's probably worth mentioning that if you're going to filetest the return values out of a readdir, you'd better prepend the directory in question. Otherwise, because we didn't chdir() there, it would have been testing the wrong file.</source>
          <target state="translated">readdir에서 리턴 값을 파일 테스트 할 경우 문제의 디렉토리를 앞에 추가하는 것이 좋습니다. 그렇지 않으면 거기에 chdir ()이 없기 때문에 잘못된 파일을 테스트했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="e6c512535456a00f2d66365aceea1ac2fa50945d" translate="yes" xml:space="preserve">
          <source>It's quite possible that the target system doesn't have a readily available /tmp, so it's generall safer to do something like this:</source>
          <target state="translated">대상 시스템에 쉽게 사용할 수있는 / tmp가 없을 수 있으므로 다음과 같이하는 것이 일반적으로 더 안전합니다.</target>
        </trans-unit>
        <trans-unit id="8748833136242804cdf06e42df13a982b1789766" translate="yes" xml:space="preserve">
          <source>It's recommended that you run &lt;code&gt;use_ok()&lt;/code&gt; inside a BEGIN block so its functions are exported at compile-time and prototypes are properly honored.</source>
          <target state="translated">BEGIN 블록 내에서 &lt;code&gt;use_ok()&lt;/code&gt; 를 실행 하여 해당 함수가 컴파일 타임에 내보내지고 프로토 타입이 올바르게 표시되도록하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="fbc60c6d884b88a267926002dcaceb4adc822c67" translate="yes" xml:space="preserve">
          <source>It's safe, however, to P- or p-pack a string literal, because Perl simply allocates an anonymous variable.</source>
          <target state="translated">그러나 Perl은 단순히 익명 변수를 할당하기 때문에 문자열 리터럴을 P- 또는 p- 패킹하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="18b132707c62c569a28f6b436602a7bfbd864dfd" translate="yes" xml:space="preserve">
          <source>It's still not quite so clear as prose, but it is very useful for describing the meaning of each part of the pattern.</source>
          <target state="translated">여전히 산문만큼 명확하지는 않지만 패턴의 각 부분의 의미를 설명하는 데 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="08057143a2d44a0a378f9cd365b42fe324a68a97" translate="yes" xml:space="preserve">
          <source>It's still up to you to seek out the actual changes, and there might not actually be any. Perhaps all of the changes since you last checked cancelled each other out and left the package in the state it was in before.</source>
          <target state="translated">실제 변경 사항을 찾는 것은 여전히 ​​귀하의 몫이며 실제로는 없을 수도 있습니다. 마지막으로 확인한 이후의 모든 변경 사항이 서로를 취소하고 패키지를 이전 상태로 유지했을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6aa1b5e370d6ab122fa013735d3b648f88f35f20" translate="yes" xml:space="preserve">
          <source>It's the double quotes, not the &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, doing this. Whenever you interpolate an array in a double quote context, Perl joins the elements with spaces (or whatever is in &lt;code&gt;$&quot;&lt;/code&gt; , which is a space by default):</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 이 아닌 큰 따옴표 입니다. 큰 따옴표 컨텍스트에서 배열을 보간 할 때마다 Perl은 공백으로 요소를 조인합니다 (또는 &lt;code&gt;$&quot;&lt;/code&gt; 에있는 것은 기본적으로 공백입니다).</target>
        </trans-unit>
        <trans-unit id="faab5a6ebe5c2e1ecdb8d0e0f9a387f835a3623a" translate="yes" xml:space="preserve">
          <source>It's useful if you want to print out the name of a variable. If you restrict yourself to globs which exist at compile-time then the result ought to be unambiguous, because code like &lt;code&gt;${&quot;^G&quot;} = 1&lt;/code&gt; is compiled as two ops - a constant string and a dereference (rv2gv) - so that the glob is created at runtime.</source>
          <target state="translated">변수 이름을 인쇄하려는 경우에 유용합니다. 컴파일 타임에 존재하는 glob로 자신을 제한하면 &lt;code&gt;${&quot;^G&quot;} = 1&lt;/code&gt; 과 같은 코드 가 상수 문자열과 역 참조 (rv2gv)와 같이 두 개의 op로 컴파일되므로 결과는 분명해야합니다. 글로브는 런타임에 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="57045aa0891a8e6164538ff7cbd090571f866c1f" translate="yes" xml:space="preserve">
          <source>It's well known that software developers usually fully document the software they write. If, however, the world is in urgent need of your software and there is not enough time to write the full documentation please at least provide a README file containing:</source>
          <target state="translated">소프트웨어 개발자는 일반적으로 자신이 작성하는 소프트웨어를 완전히 문서화하는 것으로 잘 알려져 있습니다. 그러나 전 세계에 소프트웨어가 긴급하게 필요하고 전체 문서를 작성할 시간이 충분하지 않은 경우 최소한 다음을 포함하는 README 파일을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="4198106b088c5bcb9774e212538d8c15169f58dc" translate="yes" xml:space="preserve">
          <source>Italic version of the fixed-width font (actually, something of a misnomer, since most fixed-width fonts only have an oblique version, not an italic version). Defaults to &lt;code&gt;CI&lt;/code&gt; . Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="translated">고정 폭 글꼴의 기울임 꼴 버전 (실제로 대부분의 고정 폭 글꼴은 기울임 꼴 버전이 아닌 기울임 버전 만 있으므로 잘못된 이름 임). 기본값은 &lt;code&gt;CI&lt;/code&gt; 입니다. &lt;b&gt;troff&lt;/b&gt; 출력 에만 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="583cdcdfd2a75305b35fba58a53f31af16e8fada" translate="yes" xml:space="preserve">
          <source>Italic version of the fixed-width font (actually, something of a misnomer, since most fixed-width fonts only have an oblique version, not an italic version). Defaults to &lt;code&gt;CI&lt;/code&gt; . Only matters for troff(1) output.</source>
          <target state="translated">고정 폭 글꼴의 기울임 꼴 버전 (실제로 대부분의 고정 폭 글꼴은 기울임 꼴 버전이 아닌 기울임 버전 만 있으므로 잘못된 이름 임). 기본값은 &lt;code&gt;CI&lt;/code&gt; 입니다. troff (1) 출력에만 중요합니다.</target>
        </trans-unit>
        <trans-unit id="b15ebe35e9c7b71db4b6f242bc6c861b7b404110" translate="yes" xml:space="preserve">
          <source>Itanium Processor Family (IPF) and HP-UX</source>
          <target state="translated">아이테니엄 프로세서 제품군 (IPF) 및 HP-UX</target>
        </trans-unit>
        <trans-unit id="e54d4abd34db02334ef2ceaf6dadfd1a53f1ce9b" translate="yes" xml:space="preserve">
          <source>Itanium, Itanium 2 &amp;amp; Madison 6</source>
          <target state="translated">아이테니엄, 아이테니엄 2 &amp;amp; 매디슨 6</target>
        </trans-unit>
        <trans-unit id="e359180eb8ab875848335db708d277f8c6f86293" translate="yes" xml:space="preserve">
          <source>Item, over, and back require a little more explanation: &quot;=over&quot; starts a region specifically for the generation of a list using &quot;=item&quot; commands, or for indenting (groups of) normal paragraphs. At the end of your list, use &quot;=back&quot; to end it. The</source>
          <target state="translated">항목, 끝 및 뒤로는 약간 더 자세한 설명이 필요합니다. &quot;= over&quot;는 &quot;= item&quot;명령을 사용하여 목록을 생성하거나 일반 단락을 들여 쓰기 (indenting)하기 위해 영역을 시작합니다. 목록 끝에서 &quot;= back&quot;을 사용하여 목록을 종료하십시오. 그만큼</target>
        </trans-unit>
        <trans-unit id="bca788485b73309b9f1f94d8376ab88aa565b95b" translate="yes" xml:space="preserve">
          <source>Iterate raw input without applying any fixes for quirky input syntax.</source>
          <target state="translated">기발한 입력 구문에 대한 수정 사항을 적용하지 않고 원시 입력을 반복합니다.</target>
        </trans-unit>
        <trans-unit id="880d0fdfaa731611203ad90b727f9ad0e4c9d1d5" translate="yes" xml:space="preserve">
          <source>Iterate through it, of course.</source>
          <target state="translated">물론 그것을 통해 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="0c168efad25dad6474931abc9c9d01ef4bb67924" translate="yes" xml:space="preserve">
          <source>Iterate through the process output, of course.</source>
          <target state="translated">물론 프로세스 출력을 반복합니다.</target>
        </trans-unit>
        <trans-unit id="e92d8ec2d181e1d01333d9fb58638b2b85aed8c4" translate="yes" xml:space="preserve">
          <source>Iterating over the PADNAMELIST iterates over all possible pad items. Pad slots for targets (SVs_PADTMP) and GVs end up having &amp;amp;PL_padname_undef &quot;names&quot;, while slots for constants have &amp;amp;PL_padname_const &quot;names&quot; (see pad_alloc()). That &amp;amp;PL_padname_undef and &amp;amp;PL_padname_const are used is an implementation detail subject to change. To test for them, use &lt;code&gt;!PadnamePV(name)&lt;/code&gt; and &lt;code&gt;PadnamePV(name)
&amp;amp;&amp;amp; !PadnameLEN(name)&lt;/code&gt; , respectively.</source>
          <target state="translated">PADNAMELIST를 반복하면 가능한 모든 패드 항목을 반복합니다. 대상의 패드 슬롯 (SVs_PADTMP) 및 GV에는 &amp;amp; PL_padname_undef &quot;이름&quot;이 있고 상수의 슬롯에는 &amp;amp; PL_padname_const &quot;이름&quot;이 있습니다 (pad_alloc () 참조). &amp;amp; PL_padname_undef 및 &amp;amp; PL_padname_const가 사용됨은 구현 세부 사항이 변경 될 수 있습니다. 테스트하려면 &lt;code&gt;!PadnamePV(name)&lt;/code&gt; 및 &lt;code&gt;PadnamePV(name) &amp;amp;&amp;amp; !PadnameLEN(name)&lt;/code&gt; 을 각각 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ca668574626a9549ef81113edbe0269d243a6e70" translate="yes" xml:space="preserve">
          <source>Iterator for array-based TAP sources</source>
          <target state="translated">배열 기반 TAP 소스의 반복자</target>
        </trans-unit>
        <trans-unit id="e365acec52938bb4821137a9d3698525ef64c0e6" translate="yes" xml:space="preserve">
          <source>Iterator for filehandle-based TAP sources</source>
          <target state="translated">파일 핸들 기반 TAP 소스의 반복자</target>
        </trans-unit>
        <trans-unit id="608949e6615edc46b7788d7e5f71e396c783a95e" translate="yes" xml:space="preserve">
          <source>Iterator for process-based TAP sources</source>
          <target state="translated">프로세스 기반 TAP 소스의 반복자</target>
        </trans-unit>
        <trans-unit id="1fdccc2b2140fc0f61c8fa7efaf9cf9309d438ee" translate="yes" xml:space="preserve">
          <source>IteratorFactory</source>
          <target state="translated">IteratorFactory</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="e11cc17e61cacb91ddb22ab15b88e065056ee12e" translate="yes" xml:space="preserve">
          <source>Ithreads work by cloning the data tree so that no data is shared between different threads. These threads can be used by using the &lt;code&gt;threads&lt;/code&gt; module or by doing fork() on win32 (fake fork() support). When a thread is cloned all Perl data is cloned, however non-Perl data cannot be cloned automatically. Perl after 5.8.0 has support for the &lt;code&gt;CLONE&lt;/code&gt; special subroutine. In &lt;code&gt;CLONE&lt;/code&gt; you can do whatever you need to do, like for example handle the cloning of non-Perl data, if necessary. &lt;code&gt;CLONE&lt;/code&gt; will be called once as a class method for every package that has it defined (or inherits it). It will be called in the context of the new thread, so all modifications are made in the new area. Currently CLONE is called with no parameters other than the invocant package name, but code should not assume that this will remain unchanged, as it is likely that in future extra parameters will be passed in to give more information about the state of cloning.</source>
          <target state="translated">Ithread는 다른 스레드간에 데이터가 공유되지 않도록 데이터 트리를 복제하여 작동합니다. 이러한 스레드는 &lt;code&gt;threads&lt;/code&gt; 모듈을 사용하거나 win32 (fake fork () 지원)에서 fork ()를 수행 하여 사용할 수 있습니다 . 스레드가 복제되면 모든 Perl 데이터가 복제되지만 비 Perl 데이터는 자동으로 복제 할 수 없습니다. 5.8.0 이후의 Perl은 &lt;code&gt;CLONE&lt;/code&gt; 특수 서브 루틴을 지원합니다 . &lt;code&gt;CLONE&lt;/code&gt; 에서는 필요한 경우 비 Perl 데이터의 복제 처리와 같이 필요한 모든 작업을 수행 할 수 있습니다. &lt;code&gt;CLONE&lt;/code&gt; 정의 된 (또는 상속 된) 모든 패키지에 대해 클래스 메소드로 한 번 호출됩니다. 새 스레드의 컨텍스트에서 호출되므로 모든 수정이 새 영역에서 수행됩니다. 현재 CLONE은 호출자 패키지 이름 이외의 매개 변수없이 호출되지만, 코드는 복제 상태에 대한 추가 정보를 제공하기 위해 향후 추가 매개 변수가 전달 될 가능성이 있으므로 변경되지 않은 것으로 가정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="1fc560e7e4efb5d974d128bd00c3dd33446589b6" translate="yes" xml:space="preserve">
          <source>Its &lt;code&gt;pprivate&lt;/code&gt; and &lt;code&gt;intflags&lt;/code&gt; fields contain data specific to each engine.</source>
          <target state="translated">그 &lt;code&gt;pprivate&lt;/code&gt; 및 &lt;code&gt;intflags&lt;/code&gt; 필드는 각 엔진에 대한 데이터 특정 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="16c6982b7d6141952759d09a7076ec5f4dab57ab" translate="yes" xml:space="preserve">
          <source>Its address can be used whenever an &lt;code&gt;SV*&lt;/code&gt; is needed. Make sure that you don't try to compare a random sv with &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; . For example when interfacing Perl code, it'll work correctly for:</source>
          <target state="translated">&lt;code&gt;SV*&lt;/code&gt; 가 필요할 때마다 해당 주소를 사용할 수 있습니다 . 임의의 sv와 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; 를 비교하지 마십시오 . 예를 들어 Perl 코드를 인터페이스 할 때 다음과 같이 작동합니다</target>
        </trans-unit>
        <trans-unit id="0881b1abd4c8c0f2683196629616b2be066ab1e5" translate="yes" xml:space="preserve">
          <source>Its advantage over &lt;code&gt;ok()&lt;/code&gt; is when the test fails you'll know what $got and $expected were:</source>
          <target state="translated">&lt;code&gt;ok()&lt;/code&gt; 의 장점 은 테스트가 실패했을 때 $ got 및 $ expected가 무엇인지 알 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="004b859afb711a2b891500dcf0aac6a8c2d2a9a8" translate="yes" xml:space="preserve">
          <source>Its advantages over &lt;code&gt;ok()&lt;/code&gt; are similar to that of &lt;code&gt;is()&lt;/code&gt; and &lt;code&gt;isnt()&lt;/code&gt; . Better diagnostics on failure.</source>
          <target state="translated">&lt;code&gt;ok()&lt;/code&gt; 대한 장점 은 &lt;code&gt;is()&lt;/code&gt; 및 &lt;code&gt;isnt()&lt;/code&gt; 의 장점 과 유사합니다 . 고장 진단 기능이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="b47f30ae9fc0af2d5174d1161686c5cb48a52d13" translate="yes" xml:space="preserve">
          <source>Its behaviour is identical to using an &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; type in XS with T_IV.</source>
          <target state="translated">동작은 XS에서 T_IV와 함께 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 유형 을 사용하는 것과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="fae697da5b215cc5fb762242f2f9d970cf1a4185" translate="yes" xml:space="preserve">
          <source>Its currently very simple and may be expanded sometime in the figure to include more flexible code and switches.</source>
          <target state="translated">현재 매우 간단하며,보다 유연한 코드 및 스위치를 포함하도록 그림에서 언젠가 확장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="270729f2364ce03a3daacf9b717d32c8a85378b7" translate="yes" xml:space="preserve">
          <source>Its format is not guaranteed not to change over time.</source>
          <target state="translated">형식이 시간이 지남에 따라 변경되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="41db9b49c066a3eed741a13ffe63dcafc0bc1631" translate="yes" xml:space="preserve">
          <source>Its name comes from the observation that this operation combined with the alternation operator (&lt;code&gt;|&lt;/code&gt;) can be used to create what is essentially a pattern-based if/then/else block:</source>
          <target state="translated">그 이름은 대체 연산자 ( &lt;code&gt;|&lt;/code&gt; ) 와 결합 된이 조작을 사용하여 본질적으로 패턴 기반 if / then / else 블록을 작성하는 데 사용될 수 있다는 관찰에서 비롯됩니다 .</target>
        </trans-unit>
        <trans-unit id="c1a5e19377208f27c49b06cb17d4ed4cd4b998dc" translate="yes" xml:space="preserve">
          <source>Its use of \x1b (escape) is also very questionable.</source>
          <target state="translated">\ x1b (탈출) 사용도 매우 의문입니다.</target>
        </trans-unit>
        <trans-unit id="c1782b37a47b28cba886190c0e7c9425d4b8409e" translate="yes" xml:space="preserve">
          <source>Its wrapping is done by &lt;a href=&quot;../../text/wrap&quot;&gt;Text::Wrap&lt;/a&gt;, so you can change &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; as you like.</source>
          <target state="translated">줄 바꿈은 &lt;a href=&quot;../../text/wrap&quot;&gt;Text :: Wrap에&lt;/a&gt; 의해 수행 되므로 &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; 를 원하는대로 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="58668e7669fd564d99db5d581fcdb6a5618440b5" translate="yes" xml:space="preserve">
          <source>J</source>
          <target state="translated">J</target>
        </trans-unit>
        <trans-unit id="d7060e173c0374cb8eae482e18306d094b4a274a" translate="yes" xml:space="preserve">
          <source>JAPH stands for &quot;Just another Perl hacker,&quot;, which Randal Schwartz used to sign email and usenet messages starting in the late 1980s. He previously used the phrase with many subjects (&quot;Just another x hacker,&quot;), so to distinguish his JAPH, he started to write them as Perl programs:</source>
          <target state="translated">JAPH는 Randal Schwartz가 1980 년대 후반부터 이메일과 유즈넷 메시지에 서명하는 데 사용했던 &quot;다른 Perl 해커&quot;의 약자입니다. 그는 이전에 많은 주제 ( &quot;또 다른 x 해커&quot;)와 함께이 문구를 사용하여 JAPH를 구별하기 위해 Perl 프로그램으로 작성하기 시작했습니다.</target>
        </trans-unit>
        <trans-unit id="dced2aceecfe6edc6c5082affb4adef03ec116d9" translate="yes" xml:space="preserve">
          <source>JSON::XS compatible pure-Perl module.</source>
          <target state="translated">JSON :: XS 호환 pure-Perl 모듈.</target>
        </trans-unit>
        <trans-unit id="cc167be5863c0fa54ff8e14b6cf90200815632fb" translate="yes" xml:space="preserve">
          <source>James E. Keenan</source>
          <target state="translated">제임스이 키넌</target>
        </trans-unit>
        <trans-unit id="57cf1bbb2770fa0d885d542ddaca96bfea96011e" translate="yes" xml:space="preserve">
          <source>James Keenan, &amp;lt;jkeenan@cpan.org&amp;gt;</source>
          <target state="translated">제임스 키넌, &amp;lt;jkeenan@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6ce48d285e726d9be92e6bf68e171d9553e0896e" translate="yes" xml:space="preserve">
          <source>Japanese Encodings</source>
          <target state="translated">일본어 인코딩</target>
        </trans-unit>
        <trans-unit id="ff7b561acfebbb2aad1864ab89f7d4e5285c6e22" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi</source>
          <target state="translated">자르 코 히에 타니 에미</target>
        </trans-unit>
        <trans-unit id="a9a4e186a4a793bc3fef06e8162fa8ae0f705095" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi &amp;lt;</source>
          <target state="translated">자르 코 히에 타니 에미 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="13ce73395e162a5533c6ace927e40c80d2cab8fd" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi &amp;lt;jhi@iki.fi&amp;gt;</source>
          <target state="translated">Jarkko Hietaniemi &amp;lt;jhi@iki.fi&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7adef0fede1e52584837e3b9fe09cbb854d77894" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi &amp;lt;jhi@iki.fi&amp;gt; Bryan Logan &amp;lt;bryanlog@us.ibm.com&amp;gt; David Larson &amp;lt;larson1@us.ibm.com&amp;gt;</source>
          <target state="translated">Jarkko Hietaniemi &amp;lt;jhi@iki.fi&amp;gt; Bryan Logan &amp;lt;bryanlog@us.ibm.com&amp;gt; David Larson &amp;lt;larson1@us.ibm.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="276f92ff10492dd51e70f45871039bf3b88b6a4b" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi's original</source>
          <target state="translated">Jarkko Hietaniemi의 오리지널</target>
        </trans-unit>
        <trans-unit id="04cfea13773f0ae1b7ac40ccd517f43dc7dcdad4" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi, &amp;lt;jhi@hut.fi&amp;gt;</source>
          <target state="translated">Jarkko Hietaniemi, &amp;lt;jhi@hut.fi&amp;gt;</target>
        </trans-unit>
        <trans-unit id="0bc2a5e3ff31736b8a57665e048886c573a122f3" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi, conversion into libnetcfg for inclusion into Perl 5.8.</source>
          <target state="translated">Jarkko Hietaniemi, Perl 5.8에 포함시키기 위해 libnetcfg로 변환.</target>
        </trans-unit>
        <trans-unit id="692b885ac0ff146816113cee07c7dfe2ef0ba0a4" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi. Now maintained by perl5 porters.</source>
          <target state="translated">Jarkko Hietaniemi. 이제 perl5 포터가 유지 보수합니다.</target>
        </trans-unit>
        <trans-unit id="f0bc884e41c8e0399ef072f3aad2d67eaa7fd5aa" translate="yes" xml:space="preserve">
          <source>JavaScript Traps</source>
          <target state="translated">자바 스크립트 트랩</target>
        </trans-unit>
        <trans-unit id="f2ef0f46c9cd103d2be6f2673d4379b347904df1" translate="yes" xml:space="preserve">
          <source>Jean Delvare provided the following table of different common terminal emulators and their support for the various attributes and others have helped me flesh it out:</source>
          <target state="translated">Jean Delvare는 다음과 같은 다양한 공통 터미널 에뮬레이터 표를 제공했으며 다양한 속성 및 기타 속성에 대한 지원을 통해이를 육체적으로 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="b63c65e75871d5c7820e4ea10cfd70f390f74d22" translate="yes" xml:space="preserve">
          <source>Jeff Okamoto &amp;lt;</source>
          <target state="translated">제프 오카모토 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="7ec7c5d4610b8dd06ad086eed7d40f5d2aaef1a6" translate="yes" xml:space="preserve">
          <source>Jeff Okamoto, Tim Bunce, Nick Gianniotis, Steve Kelem, Gurusamy Sarathy and Larry Wall.</source>
          <target state="translated">Jeff Okamoto, Tim Bunce, Nick Gianniotis, Steve Kelem, Gurusamy Sarathy 및 Larry Wall.</target>
        </trans-unit>
        <trans-unit id="b3a656e0d05c4ded5764e8eee0b16063f85446f7" translate="yes" xml:space="preserve">
          <source>Jerry D. Hedden and Reini Urban provided greatly appreciated help to debug and polish &lt;code&gt;Sys::Syslog&lt;/code&gt; under Cygwin.</source>
          <target state="translated">Jerry D. Hedden과 Reini Urban 은 Cygwin에서 &lt;code&gt;Sys::Syslog&lt;/code&gt; 를 디버그하고 연마하는 데 크게 도움이되었습니다 .</target>
        </trans-unit>
        <trans-unit id="1a3cecc43a5465fa758b4f88b43cd646e6623b8f" translate="yes" xml:space="preserve">
          <source>Jerry D. Hedden, &amp;lt;jdhedden AT cpan DOT org&amp;gt;</source>
          <target state="translated">Jerry D. Hedden, &amp;lt;jdhedden AT cpan DOT org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ef645dbc725c293373ed9661992798b416e9b9b4" translate="yes" xml:space="preserve">
          <source>Joe Smith &amp;lt;Joe.Smith@inwap.com&amp;gt;, using the framework created by Russ Allbery &amp;lt;rra@stanford.edu&amp;gt;.</source>
          <target state="translated">Joe Smith &amp;lt;Joe.Smith@inwap.com&amp;gt;, Russ Allbery &amp;lt;rra@stanford.edu&amp;gt;에서 만든 프레임 워크를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c865a479b23a538482933eec4ec96a06755b572a" translate="yes" xml:space="preserve">
          <source>Johan Vromans &amp;lt;jvromans@squirrel.nl&amp;gt;</source>
          <target state="translated">요한 브로 만 스 &amp;lt;jvromans@squirrel.nl&amp;gt;</target>
        </trans-unit>
        <trans-unit id="bdfcbe7345fa5c91aff66147710f3cfd01971e09" translate="yes" xml:space="preserve">
          <source>Joins the separate strings of LIST into a single string with fields separated by the value of EXPR, and returns that new string. Example:</source>
          <target state="translated">EXPR 값으로 구분 된 필드를 사용하여 LIST의 별도 문자열을 단일 문자열로 결합하고 새 문자열을 반환합니다. 예:</target>
        </trans-unit>
        <trans-unit id="8701a18a17d809f2f5e1d9461286d81392c749a1" translate="yes" xml:space="preserve">
          <source>Jon Orwant</source>
          <target state="translated">존 오완 트</target>
        </trans-unit>
        <trans-unit id="9535723b8f84ea59122230a47649084f0880997b" translate="yes" xml:space="preserve">
          <source>Jon Orwant &amp;lt;</source>
          <target state="translated">존 오완 트 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="ddc19f76e720fe5e2b005501ad08de9eb7175b61" translate="yes" xml:space="preserve">
          <source>Joshua Chamas's Tie::Cache module may be useful as an expiration manager. (If you try this, let me know how it works out.)</source>
          <target state="translated">Joshua Chamas의 Tie :: Cache 모듈은 만료 관리자로 유용 할 수 있습니다. (이 방법을 시도하면 작동 방식을 알려주십시오.)</target>
        </trans-unit>
        <trans-unit id="272f944afb073e466e447521f217853887659759" translate="yes" xml:space="preserve">
          <source>Joshua ben Jore &amp;lt;jjore@cpan.org&amp;gt;</source>
          <target state="translated">조슈아 벤 조어 &amp;lt;jjore@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f8f06875505d336c6444e4ca735af60cc7f95b69" translate="yes" xml:space="preserve">
          <source>Judicious JavaScript programmers should take note of the following:</source>
          <target state="translated">신중한 JavaScript 프로그래머는 다음 사항에 유의해야합니다.</target>
        </trans-unit>
        <trans-unit id="829558e61eb4ee30d56d5ca3997b5726751317c0" translate="yes" xml:space="preserve">
          <source>Juerd Waalboer &amp;lt;#####@juerd.nl&amp;gt;</source>
          <target state="translated">Juerd Waalboer &amp;lt;##### @ juerd.nl&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d89d24d0ba5d206a7a244711764b4287f3aa5c8f" translate="yes" xml:space="preserve">
          <source>Juerd Waalboer &amp;lt;#####@juerd.nl&amp;gt;, with the help of many Perl Monks.</source>
          <target state="translated">많은 Perl 수도사의 도움으로 Juerd Waalboer &amp;lt;##### @ juerd.nl&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="5f3e3f9c72e3b6a4486ec8a37b16219f4828a4df" translate="yes" xml:space="preserve">
          <source>Just a quick hint here for all those CGI programmers who can't figure out how on earth to get past that 'waiting for input' prompt, when running their CGI script from the command-line, try something like this:</source>
          <target state="translated">명령 행에서 CGI 스크립트를 실행할 때 '입력 대기 중'프롬프트를 벗어나는 방법을 알 수없는 모든 CGI 프로그래머에게 간단한 힌트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="33892714232f2855fd91a542cad5d54aa9bb7133" translate="yes" xml:space="preserve">
          <source>Just as P5P collectively maintains the codebase, we collectively maintain the documentation. Writing a particular bit of documentation doesn't give an author control of the future of that documentation. At the same time, just as source code changes should match the style of their surrounding blocks, so should documentation changes.</source>
          <target state="translated">P5P가 공동으로 코드베이스를 유지 관리하는 것처럼 문서를 유지 관리합니다. 특정 문서를 작성한다고해서 해당 문서의 미래를 제어 할 수있는 것은 아닙니다. 동시에, 소스 코드 변경이 주변 블록의 스타일과 일치해야하는 것처럼 문서 변경도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="0aaf4ef0c9b344d1374053d108e2052e07431e98" translate="yes" xml:space="preserve">
          <source>Just as PERL_IMPLICIT_CONTEXT provides a way to bundle up everything that the interpreter knows about itself and pass it around, so too are there plans to allow the interpreter to bundle up everything it knows about the environment it's running on. This is enabled with the PERL_IMPLICIT_SYS macro. Currently it only works with USE_ITHREADS on Windows.</source>
          <target state="translated">PERL_IMPLICIT_CONTEXT가 인터프리터가 알고있는 모든 것을 묶고 전달할 수있는 방법을 제공하는 것처럼 인터프리터가 실행중인 환경에 대해 알고있는 모든 것을 번들로 묶을 계획도 있습니다. PERL_IMPLICIT_SYS 매크로를 사용하여 활성화됩니다. 현재는 Windows의 USE_ITHREADS에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="62e8906be80151cd95246c62df9e4761d5bc2332" translate="yes" xml:space="preserve">
          <source>Just as above, but maps from characters (like &quot;\xE9&quot;, lowercase e-acute) to characters (like &quot;e&quot;).</source>
          <target state="translated">위와 마찬가지로 문자 (예 : &quot;\ xE9&quot;, 소문자 e-acute)에서 문자 (예 : &quot;e&quot;)로 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="07b1550eae10318438b9e4b01a4b0de0c550fc87" translate="yes" xml:space="preserve">
          <source>Just as in all regular expressions, the pattern can be built up by including variables that are interpolated at regex compilation time. Care must be taken to ensure that you are getting what you expect. For example:</source>
          <target state="translated">모든 정규식과 마찬가지로 정규식 컴파일 타임에 보간되는 변수를 포함시켜 패턴을 만들 수 있습니다. 기대하는 바를 얻도록주의를 기울여야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fe8a855ccb8465e6e734bba6c85f798237a3ef83" translate="yes" xml:space="preserve">
          <source>Just as in the previous regexp, the first quantifier &lt;code&gt;.??&lt;/code&gt; can match earliest at position &lt;code&gt;'a'&lt;/code&gt; , so it does. The second quantifier is greedy, so it matches &lt;code&gt;mm&lt;/code&gt; , and the third matches the rest of the string.</source>
          <target state="translated">이전 정규 표현식에서와 마찬가지로 첫 번째 수량자는 &lt;code&gt;.??&lt;/code&gt; &lt;code&gt;'a'&lt;/code&gt; 위치에서 가장 빨리 일치 할 수 있습니다 . 두 번째 수량자는 욕심이 많으므로 &lt;code&gt;mm&lt;/code&gt; 과 일치하고 세 번째 수량자는 나머지 문자열과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="54aa745852ee956f0149292237b30dcf7a75e890" translate="yes" xml:space="preserve">
          <source>Just as in the shell, a backslashed bareword following the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; means the same thing as a single-quoted string does:</source>
          <target state="translated">쉘에서와 같이 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 뒤에 오는 백 슬래시 베어 워드 는 작은 따옴표로 묶인 문자열과 동일한 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="faebd7db1f892818770103ce78accf7713eb730f" translate="yes" xml:space="preserve">
          <source>Just as numeric comparisons can be autogenerated from the method for &lt;code&gt;'&amp;lt;=&amp;gt;'&lt;/code&gt; , string comparisons can be autogenerated from that for &lt;code&gt;'cmp'&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;'&amp;lt;=&amp;gt;'&lt;/code&gt; 의 메소드에서 숫자 비교를 자동 생성 할 수있는 것처럼 &lt;code&gt;'cmp'&lt;/code&gt; 의 문자열 비교를 자동으로 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8df19f323bb6b48a43ad85680dc0529bf785f1c3" translate="yes" xml:space="preserve">
          <source>Just as with &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt;, no shell escapes happen when you &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; a list. Further examples of this can be found in &lt;a href=&quot;perlipc#Safe-Pipe-Opens&quot;&gt;Safe Pipe Opens in perlipc&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 과 마찬가지로 목록 을 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; 할 때 쉘 이스케이프가 발생하지 않습니다 . 이에 대한 추가 예는 &lt;a href=&quot;perlipc#Safe-Pipe-Opens&quot;&gt;perlipc의 Safe Pipe Opens에서&lt;/a&gt; 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e255de21718ad7422221bd6f42f8ec7acc85a6f3" translate="yes" xml:space="preserve">
          <source>Just as with any Perl subroutine, all of the arguments passed in &lt;code&gt;@_&lt;/code&gt; are aliases to the original argument. This includes the object itself. If you assign directly to &lt;code&gt;$_[0]&lt;/code&gt; you will change the contents of the variable that holds the reference to the object. We recommend that you don't do this unless you know exactly what you're doing.</source>
          <target state="translated">Perl 서브 루틴과 마찬가지로, &lt;code&gt;@_&lt;/code&gt; 에 전달 된 모든 인수 는 원래 인수의 별명입니다. 여기에는 객체 자체가 포함됩니다. &lt;code&gt;$_[0]&lt;/code&gt; 에 직접 할당 하면 객체에 대한 참조를 보유한 변수의 내용이 변경됩니다. 수행중인 작업을 정확히 알지 않는 한이 작업을 수행하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fccd05d91f9ee0d9fbbfbf38723d03e8a7c74f00" translate="yes" xml:space="preserve">
          <source>Just as with any signal, you can use &lt;code&gt;sigaction($rtsig, &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;, $oa)&lt;/code&gt; to retrieve the installed signal handler (or, rather, the signal action).</source>
          <target state="translated">모든 신호와 마찬가지로 &lt;code&gt;sigaction($rtsig, &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;, $oa)&lt;/code&gt; 을 사용하여 설치된 신호 처리기 (또는 신호 동작)를 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1dc08a9e71893fc4c8e0aca93a96bf0beab842b5" translate="yes" xml:space="preserve">
          <source>Just because a lexical variable is lexically (also called statically) scoped to its enclosing block, &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; FILE, this doesn't mean that within a function it works like a C static. It normally works more like a C auto, but with implicit garbage collection.</source>
          <target state="translated">어휘 변수가 둘러싸는 블록, &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; FILE에 대해 어휘 적으로 (정적으로 호출 됨) 범위를 지정 한다고해서 함수 내에서 C 정적처럼 작동한다는 의미는 아닙니다. 일반적으로 C auto와 비슷하지만 암시 적 가비지 콜렉션과 함께 작동합니다.</target>
        </trans-unit>
        <trans-unit id="90c499a655f030c92a71b95e9b2689970ea91b8a" translate="yes" xml:space="preserve">
          <source>Just because you</source>
          <target state="translated">당신 때문에</target>
        </trans-unit>
        <trans-unit id="109e6f9598b8183bb06ce69968e5c56fc8392a6f" translate="yes" xml:space="preserve">
          <source>Just before HP took over Compaq, some systems were renamed. the link that contained the explanation is dead, so here's a short summary:</source>
          <target state="translated">HP가 Compaq을 인수하기 직전에 일부 시스템의 이름이 변경되었습니다. 설명이 포함 된 링크가 죽었으므로 여기에 간단한 요약이 있습니다.</target>
        </trans-unit>
        <trans-unit id="75a3cd456f36493a47889dab1eae3ee74e772ac3" translate="yes" xml:space="preserve">
          <source>Just before removing a directory (after having successfully removed everything it contained), &lt;code&gt;remove_tree&lt;/code&gt; attempted to set the permissions on the directory to ensure it could be removed and failed. Program execution continues, but the directory may possibly not be deleted.</source>
          <target state="translated">디렉토리를 제거하기 직전에 (포함 된 모든 것을 성공적으로 제거한 후) &lt;code&gt;remove_tree&lt;/code&gt; 는 디렉토리에 대한 권한을 설정하여 디렉토리가 제거되고 실패 할 수 있도록 시도했습니다. 프로그램 실행은 계속되지만 디렉토리가 삭제되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9cff4cf2ef85b7a7babbfc6ed8ae94ad00cf8c95" translate="yes" xml:space="preserve">
          <source>Just don't forget that you have to put a semicolon on the end to finish the statement, as Perl doesn't know you're not going to try to do this:</source>
          <target state="translated">Perl은 당신이 이것을 시도하지 않을 것이라는 것을 알지 못하기 때문에 문장을 완성하기 위해 세미콜론을 끝내야한다는 것을 잊지 마십시오.</target>
        </trans-unit>
        <trans-unit id="de3dbf5e42e97a50f069394cda4a6442ac1d1765" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, but implicitly appends a newline. &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt; LIST&lt;/code&gt; is simply an abbreviation for &lt;code&gt;{ &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $\ = &quot;\n&quot;; &lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; LIST }&lt;/code&gt; . To use FILEHANDLE without a LIST to print the contents of &lt;code&gt;$_&lt;/code&gt; to it, you must use a real filehandle like &lt;code&gt;FH&lt;/code&gt; , not an indirect one like &lt;code&gt;$fh&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 처럼 , 암묵적으로 줄 바꿈을 추가합니다. &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt; LIST&lt;/code&gt; 단순히의 약어입니다 &lt;code&gt;{ &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $\ = &quot;\n&quot;; &lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; LIST }&lt;/code&gt; . LIST없이 FILEHANDLE을 사용하여 &lt;code&gt;$_&lt;/code&gt; 의 내용을 인쇄하려면 &lt;code&gt;$fh&lt;/code&gt; 와 같은 간접 파일이 아니라 &lt;code&gt;FH&lt;/code&gt; 와 같은 실제 파일 핸들을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="602502b6c9a3a727e615412b86a9aecefaaebcdb" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, but implicitly appends a newline. &lt;code&gt;&lt;a href=&quot;say&quot;&gt;say&lt;/a&gt; LIST&lt;/code&gt; is simply an abbreviation for &lt;code&gt;{ &lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; $\ = &quot;\n&quot;; &lt;a href=&quot;print&quot;&gt;print&lt;/a&gt; LIST }&lt;/code&gt; . To use FILEHANDLE without a LIST to print the contents of &lt;code&gt;$_&lt;/code&gt; to it, you must use a real filehandle like &lt;code&gt;FH&lt;/code&gt; , not an indirect one like &lt;code&gt;$fh&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 처럼 , 암묵적으로 줄 바꿈을 추가합니다. &lt;code&gt;&lt;a href=&quot;say&quot;&gt;say&lt;/a&gt; LIST&lt;/code&gt; 단순히의 약어입니다 &lt;code&gt;{ &lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; $\ = &quot;\n&quot;; &lt;a href=&quot;print&quot;&gt;print&lt;/a&gt; LIST }&lt;/code&gt; . LIST없이 FILEHANDLE을 사용하여 &lt;code&gt;$_&lt;/code&gt; 의 내용을 인쇄하려면 &lt;code&gt;$fh&lt;/code&gt; 와 같은 간접 파일이 아니라 &lt;code&gt;FH&lt;/code&gt; 와 같은 실제 파일 핸들을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="841a87198bd8d5b2b617ad09071d079bbef63265" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;SAVEFREESV&lt;/code&gt; , but mortalizes &lt;code&gt;sv&lt;/code&gt; at the end of the current scope instead of decrementing its reference count. This usually has the effect of keeping &lt;code&gt;sv&lt;/code&gt; alive until the statement that called the currently live scope has finished executing.</source>
          <target state="translated">&lt;code&gt;SAVEFREESV&lt;/code&gt; 와 마찬가지로 참조 수를 줄이지 않고 현재 범위의 끝에서 &lt;code&gt;sv&lt;/code&gt; 을 필사 화 합니다. 이는 일반적으로 현재 라이브 범위라고하는 명령문이 실행을 완료 할 때까지 &lt;code&gt;sv&lt;/code&gt; 를 활성 상태로 유지하는 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdee811de63331b1e390b9478886674b8221df6d" translate="yes" xml:space="preserve">
          <source>Just like alternation, quantifiers are also susceptible to backtracking. Here is a step-by-step analysis of the example</source>
          <target state="translated">교대와 마찬가지로 정량자는 역 추적에 취약합니다. 다음은 예제의 단계별 분석입니다.</target>
        </trans-unit>
        <trans-unit id="24cfeb3771fb43ef585a2f529448474ab41a12a3" translate="yes" xml:space="preserve">
          <source>Just like capa, but only uses a cache from the last time we asked the server, so as to avoid asking more than once.</source>
          <target state="translated">capa와 마찬가지로 서버에 마지막으로 요청한 시간부터 캐시를 사용하므로 두 번 이상 묻지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c07daab474d2a24a41bbf91648b44cb45c039da4" translate="yes" xml:space="preserve">
          <source>Just like have_compiler but for C++ instead of C.</source>
          <target state="translated">have_compiler와 마찬가지로 C 대신 C ++ 용</target>
        </trans-unit>
        <trans-unit id="1ed1a130170978e2a4e7086c7c7306a25c8e7b33" translate="yes" xml:space="preserve">
          <source>Just like special scalars and arrays, there are also special hashes. The most well known of these is &lt;code&gt;%ENV&lt;/code&gt; which contains environment variables. Read all about it (and other special variables) in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;.</source>
          <target state="translated">특수 스칼라 및 배열과 마찬가지로 특수 해시도 있습니다. 이들 중 가장 잘 알려진 것은 환경 변수를 포함하는 &lt;code&gt;%ENV&lt;/code&gt; 입니다. &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; 에서 그것에 대해 (및 다른 특수 변수)를 모두 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="19b37fcf66fa778fbd1b5d5fc50d7060df9d05e7" translate="yes" xml:space="preserve">
          <source>Just like the &quot;strict&quot; pragma any of these categories can be combined</source>
          <target state="translated">&quot;엄격한&quot;pragma와 마찬가지로 이러한 범주 중 하나를 결합 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="82e865fa7feb693e6080cbf3d25a874d28e9c584" translate="yes" xml:space="preserve">
          <source>Just pressing Enter will do the most recent operation again - it's a blessing when stepping through miles of source code.</source>
          <target state="translated">Enter 키를 누르면 가장 최근의 작업이 다시 수행됩니다. 수 마일의 소스 코드를 단계별로 실행할 때 축복입니다.</target>
        </trans-unit>
        <trans-unit id="fe244a50fe6aded057e3eae12f0a93027edb2381" translate="yes" xml:space="preserve">
          <source>Just say:</source>
          <target state="translated">그냥 말해:</target>
        </trans-unit>
        <trans-unit id="d8c1011fd0f056428d5a8834a2c765887dde0f8b" translate="yes" xml:space="preserve">
          <source>Just set the integer value of the top stack entry to its negation.</source>
          <target state="translated">최상위 스택 항목의 정수 값을 부정으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="c7727ca967ac9b4f317d7c673ab3882351fa9d9d" translate="yes" xml:space="preserve">
          <source>Just simple slots for storing information about the line and the file the link was encountered in. Has to be filled in manually.</source>
          <target state="translated">링크 및 링크가 발생한 파일에 대한 정보를 저장하기위한 간단한 슬롯. 수동으로 채워야합니다.</target>
        </trans-unit>
        <trans-unit id="6b1d3328e0f08111bb8c2f1b7ffdbdee9651e208" translate="yes" xml:space="preserve">
          <source>Just to show that C programmers can write C in any programming language, if you prefer a more C-like solution, the following script makes the substitution have the same case, letter by letter, as the original. (It also happens to run about 240% slower than the Perlish solution runs.) If the substitution has more characters than the string being substituted, the case of the last character is used for the rest of the substitution.</source>
          <target state="translated">C 프로그래머가 모든 프로그래밍 언어로 C를 작성할 수 있음을 보여주기 위해 C와 같은 솔루션을 선호하는 경우 다음 스크립트는 대소 문자를 대소 문자로 대치합니다. (또한 Perlish 솔루션이 실행하는 것보다 약 240 % 느리게 실행됩니다.) 대체에 대체되는 문자열보다 많은 문자가있는 경우 마지막 대체 문자는 마지막 대체 문자에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4a091e09bfa339a10150c33a9aaadd4282459277" translate="yes" xml:space="preserve">
          <source>Just what it says, you're missing that file. MakeMaker uses it to determine if perl has been rebuilt since the Makefile was made. It's a bit of a bug that it halts installation.</source>
          <target state="translated">그 내용대로 파일이 없습니다. MakeMaker는이를 사용하여 Makefile이 작성된 이후에 perl이 재 빌드되었는지 판별합니다. 설치를 중단시키는 것은 약간의 버그입니다.</target>
        </trans-unit>
        <trans-unit id="a7ee38bb7be4fc44198cb2685d9601dcf2b9f569" translate="yes" xml:space="preserve">
          <source>K</source>
          <target state="translated">K</target>
        </trans-unit>
        <trans-unit id="66d19ca0f4158063f6e062dbc4b43cb2360ddc04" translate="yes" xml:space="preserve">
          <source>KEY/VALUE PAIR LIST FUNCTIONS</source>
          <target state="translated">키 / 값 쌍 목록 기능</target>
        </trans-unit>
        <trans-unit id="d873371555253b7c518cf82fe5be999156ffe1fc" translate="yes" xml:space="preserve">
          <source>KNOWN BUGS</source>
          <target state="translated">알려진 버그</target>
        </trans-unit>
        <trans-unit id="d7d37390d4b0162eaa199e8a40421a0fd151d9d4" translate="yes" xml:space="preserve">
          <source>KNOWN ISSUES</source>
          <target state="translated">알려진 문제</target>
        </trans-unit>
        <trans-unit id="49f7d6b044c08905cf6f12f8a90c2d7d80dd7870" translate="yes" xml:space="preserve">
          <source>KNOWN PROBLEMS</source>
          <target state="translated">알려진 문제</target>
        </trans-unit>
        <trans-unit id="ff0775fcc23b465723521876b29263b74199fe74" translate="yes" xml:space="preserve">
          <source>Karen Etheridge</source>
          <target state="translated">카렌에 터리 지</target>
        </trans-unit>
        <trans-unit id="6587b068c21cd74b421d84d8dd8d104ffb717b74" translate="yes" xml:space="preserve">
          <source>Kawai,Takanori provides a Japanese translation of a very old version of this manpage at &lt;a href=&quot;http://homepage3.nifty.com/hippo2000/perltips/CPAN.htm&quot;&gt;http://homepage3.nifty.com/hippo2000/perltips/CPAN.htm&lt;/a&gt;</source>
          <target state="translated">Kawai, Takanori는 &lt;a href=&quot;http://homepage3.nifty.com/hippo2000/perltips/CPAN.htm&quot;&gt;http://homepage3.nifty.com/hippo2000/perltips/CPAN.htm&lt;/a&gt; 에서이 맨 페이지의 매우 오래된 버전의 일본어 번역을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="dcff63b147198a52939742818ee2ef592a205e7e" translate="yes" xml:space="preserve">
          <source>Keep features/concepts as orthogonal as possible.</source>
          <target state="translated">기능 / 개념을 가능한 한 직교하게 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="8e7b10c1d652b6b04a656b434f5b39616ccf1a50" translate="yes" xml:space="preserve">
          <source>Keep hacking until the tests pass.</source>
          <target state="translated">테스트가 통과 될 때까지 해킹을 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="af7d72158e7608d9c4b48305b5171ef45c75b0c8" translate="yes" xml:space="preserve">
          <source>Keep in mind that</source>
          <target state="translated">명심하십시오</target>
        </trans-unit>
        <trans-unit id="ed0120a6a4cb952cfa71da323a4afdbfcf12e27d" translate="yes" xml:space="preserve">
          <source>Keep in mind that even if you think your code is not locale-aware, it may call a C library function that is. Hopefully the man page for such a function will indicate that dependency, but the documentation is imperfect.</source>
          <target state="translated">코드가 로캘을 인식하지 않는다고 생각하더라도 C 라이브러리 함수를 호출 할 수 있습니다. 바라건대 그러한 기능에 대한 매뉴얼 페이지가 의존성을 나타내지 만 문서는 불완전합니다.</target>
        </trans-unit>
        <trans-unit id="86f6615f078bb4d01730cb8fac56589317fa9a58" translate="yes" xml:space="preserve">
          <source>Keep in mind that only the first several &quot;odd-numbered&quot; buckets are used, so the information on size of the &quot;odd-numbered&quot; buckets which are not used is probably meaningless.</source>
          <target state="translated">처음 몇 개의 &quot;홀수 번호&quot;버킷 만 사용되므로 사용하지 않은 &quot;홀수 번호&quot;버킷의 크기에 대한 정보는 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4ef95230ae4c52baacdb1c4884acabd7049d178c" translate="yes" xml:space="preserve">
          <source>Keep in mind that these compiler and linker settings will also be used when building CPAN modules. For XS modules to be compiled as a universal binary, any libraries it links to must also be universal binaries. The system libraries that Apple includes with the 10.4u SDK are all universal, but user-installed libraries may need to be re-installed as universal binaries.</source>
          <target state="translated">CPAN 모듈을 빌드 할 때 이러한 컴파일러 및 링커 설정도 사용됩니다. XS 모듈을 범용 바이너리로 컴파일하려면 링크 된 모든 라이브러리도 범용 바이너리 여야합니다. Apple에 10.4u SDK에 포함 된 시스템 라이브러리는 모두 범용이지만 사용자 설치 라이브러리는 범용 바이너리로 다시 설치해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9eeeda7b97916fa01cabcb38bff49279f0e6a0bb" translate="yes" xml:space="preserve">
          <source>Keep in mind that you can always supply</source>
          <target state="translated">당신은 항상 공급할 수 있다는 것을 명심하십시오</target>
        </trans-unit>
        <trans-unit id="64a46910748217f86efd6627ba753bed01e58a81" translate="yes" xml:space="preserve">
          <source>Keep info about source lines on which a subroutine is defined.</source>
          <target state="translated">서브 루틴이 정의 된 소스 라인에 대한 정보를 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="f47e40b91fc5362642fcbe01770e5ce787e6ccdc" translate="yes" xml:space="preserve">
          <source>Keep it fast, simple, and useful.</source>
          <target state="translated">빠르고 간단하며 유용하게 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="a180636219ad9f73429c85412c6186e17a5910d6" translate="yes" xml:space="preserve">
          <source>Keep it open and exciting to use/patch/advocate Perl everywhere.</source>
          <target state="translated">어디서나 Perl을 사용 / 패치 / 옹호 할 수 있도록 개방적이고 흥미 진진합니다.</target>
        </trans-unit>
        <trans-unit id="c51474355aad094e34cfbd22e2141d08f6d33f4f" translate="yes" xml:space="preserve">
          <source>Keep more files open than the system permits</source>
          <target state="translated">시스템이 허용하는 것보다 많은 파일을 열어 둡니다</target>
        </trans-unit>
        <trans-unit id="14b49f2a3e5ec0e1cdb997e3d03cb485633984fa" translate="yes" xml:space="preserve">
          <source>Keep sets of symbol names palatable to the VMS linker</source>
          <target state="translated">심볼 이름 세트를 VMS 링커에 표시 가능하게 유지</target>
        </trans-unit>
        <trans-unit id="b3a15ca125f2b3af86ad1584e6c4e2aafb908eae" translate="yes" xml:space="preserve">
          <source>Keep your documentation near the code it documents (&quot;inline&quot; documentation). Include POD for a given method right above that method's subroutine. This makes it easier to keep the documentation up to date, and avoids having to document each piece of code twice (once in POD and once in comments).</source>
          <target state="translated">문서를 코드와 가까운 곳에 보관하십시오 ( &quot;인라인&quot;문서). 해당 메소드의 서브 루틴 바로 위에 제공된 메소드에 대한 POD를 포함하십시오. 이를 통해 문서를보다 쉽게 ​​최신 상태로 유지할 수 있으며 각 코드 조각을 두 번 (POD에 한 번, 주석에 한 번) 문서화하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="76d3b7f70d495b2b8a3270d608b55e23f648e0ce" translate="yes" xml:space="preserve">
          <source>Keeping track of the highest cached record. This would allow reads-in-a-row to skip the cache lookup faster (if reading from 1..N with empty cache at start, the last cached value will be always N-1).</source>
          <target state="translated">가장 높은 캐시 된 레코드를 추적합니다. 이렇게하면 행 읽기가 캐시 조회를 더 빨리 건너 뛸 수 있습니다 (시작시 빈 캐시가있는 1..N에서 읽는 경우 마지막 캐시 된 값은 항상 N-1 임).</target>
        </trans-unit>
        <trans-unit id="4c7c7465de1db7f41ca1d8bdef4219bff0d7c120" translate="yes" xml:space="preserve">
          <source>Ken Williams &amp;lt;ken@mathforum.org&amp;gt;</source>
          <target state="translated">켄 윌리엄스 &amp;lt;ken@mathforum.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="abd59a29e35516d1b9c3ad5018ade24ad931f61e" translate="yes" xml:space="preserve">
          <source>Ken Williams, &amp;lt;ken@mathforum.org&amp;gt;</source>
          <target state="translated">켄 윌리엄스, &amp;lt;ken@mathforum.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="0d1222a0218c97e36123b63438f7b4e4edcb6a3e" translate="yes" xml:space="preserve">
          <source>Ken Williams, kwilliams@cpan.org</source>
          <target state="translated">켄 윌리엄스, kwilliams@cpan.org</target>
        </trans-unit>
        <trans-unit id="ee0c77223410ec7a299fe0a1261f164a0c42279d" translate="yes" xml:space="preserve">
          <source>Kenneth Albanowski (&amp;lt;kjahds@kjahds.com&amp;gt;), subsequently</source>
          <target state="translated">케네스 알바 노프 스키 (Kenneth Albanowski) (&amp;lt;kjahds@kjahds.com&amp;gt;)</target>
        </trans-unit>
        <trans-unit id="348f36b3e5bbe51567b4fb414536380d7187542b" translate="yes" xml:space="preserve">
          <source>Kernel threads are the next step in thread evolution. The OS knows about kernel threads, and makes allowances for them. The main difference between a kernel thread and a user-mode thread is blocking. With kernel threads, things that block a single thread don't block other threads. This is not the case with user-mode threads, where the kernel blocks at the process level and not the thread level.</source>
          <target state="translated">커널 스레드는 스레드 진화의 다음 단계입니다. OS는 커널 스레드를 알고 있으며이를 허용합니다. 커널 스레드와 사용자 모드 스레드의 주요 차이점은 차단입니다. 커널 스레드에서 단일 스레드를 차단하는 것은 다른 스레드를 차단하지 않습니다. 커널이 스레드 수준이 아닌 프로세스 수준에서 차단되는 사용자 모드 스레드의 경우에는 해당되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="259173b7d729d8dc6a66caf8b3aace35a75e8f99" translate="yes" xml:space="preserve">
          <source>Kevin Ryde</source>
          <target state="translated">케빈 라이드</target>
        </trans-unit>
        <trans-unit id="a297e34f70da8957366c0d560c60295f4ab16d2a" translate="yes" xml:space="preserve">
          <source>Key feature milestones include:</source>
          <target state="translated">주요 기능 이정표는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bc06e1d8824d5b7cbd20d018550616dba1eeb7a3" translate="yes" xml:space="preserve">
          <source>Key naming</source>
          <target state="translated">키 명명</target>
        </trans-unit>
        <trans-unit id="0c71372d5d9156fb958ad05c3a06f64214fe7926" translate="yes" xml:space="preserve">
          <source>Key/Value Hash Slices</source>
          <target state="translated">키 / 값 해시 슬라이스</target>
        </trans-unit>
        <trans-unit id="0a8746998a05aa11ad9c2dab8f6c1868e6458dab" translate="yes" xml:space="preserve">
          <source>Key/value pairs are extra information about the module. Fields include:</source>
          <target state="translated">키 / 값 쌍은 모듈에 대한 추가 정보입니다. 필드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="26057b24ccfdf1266160f8baf076207f8248b2c2" translate="yes" xml:space="preserve">
          <source>Keyed on perl version this contains ISO formatted versions of the release dates, as gleaned from &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlhist.html&quot;&gt;perlhist&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlhist.html&quot;&gt;perlist&lt;/a&gt; 에서 얻은이 버전에는 perlist 에서 얻은 ISO 형식의 릴리스 날짜가 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ac519cac59842ef7ce692b39ea336e75df75601a" translate="yes" xml:space="preserve">
          <source>Killing the parent process</source>
          <target state="translated">부모 프로세스 종료</target>
        </trans-unit>
        <trans-unit id="76e63bc788196f0fc365bdd0b40b720b363e2116" translate="yes" xml:space="preserve">
          <source>Kirrily &quot;Skud&quot; Robert &amp;lt;skud@cpan.org&amp;gt;</source>
          <target state="translated">Kirrily &quot;Skud&quot;Robert &amp;lt;skud@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="132f84c02455b94d400579a7b40a518ce274e293" translate="yes" xml:space="preserve">
          <source>Know what you're testing. Read the docs, and the source.</source>
          <target state="translated">무엇을 테스트하고 있는지 알고 있습니다. 문서와 소스를 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="90303445974fa3fe293cc60d64eaeca6bb4d14c9" translate="yes" xml:space="preserve">
          <source>Known Problems</source>
          <target state="translated">알려진 문제</target>
        </trans-unit>
        <trans-unit id="eb6d28effd6acc1d20ab0115a46d456361c67007" translate="yes" xml:space="preserve">
          <source>Known Problems with Perl on Hurd</source>
          <target state="translated">Perl on Hurd의 알려진 문제점</target>
        </trans-unit>
        <trans-unit id="b35d4f63dc3fe926a9db173d1f73bb17b3726246" translate="yes" xml:space="preserve">
          <source>Known problems</source>
          <target state="translated">알려진 문제</target>
        </trans-unit>
        <trans-unit id="773f5eaba0582fa827eb62a803e54c124b33061b" translate="yes" xml:space="preserve">
          <source>Known to be broken for 5.8.0 (but 5.6.1 and 5.7.2 can be used):</source>
          <target state="translated">5.8.0에서 깨지는 것으로 알려져 있지만 5.6.1 및 5.7.2를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf8178f760b75a0d75931dde9fe9ac37025b060d" translate="yes" xml:space="preserve">
          <source>Korean Encodings</source>
          <target state="translated">한국어 인코딩</target>
        </trans-unit>
        <trans-unit id="d160e0986aca4714714a16f29ec605af90be704d" translate="yes" xml:space="preserve">
          <source>L</source>
          <target state="translated">L</target>
        </trans-unit>
        <trans-unit id="a5009766b33ae437bdfad28ba25b247aa809447e" translate="yes" xml:space="preserve">
          <source>LANGUAGE CLASS HIERARCHIES</source>
          <target state="translated">언어 클래스 계층 구조</target>
        </trans-unit>
        <trans-unit id="306bdaf58d73ea39af3b1402b65b299e6a4795ee" translate="yes" xml:space="preserve">
          <source>LAST UPDATE</source>
          <target state="translated">마지막 업데이트</target>
        </trans-unit>
        <trans-unit id="823feb18075201a2009bf899a2b4bee49397d8df" translate="yes" xml:space="preserve">
          <source>LC_TIME</source>
          <target state="translated">LC_TIME</target>
        </trans-unit>
        <trans-unit id="7c53807c1836659b4436f686a99f72b3f7ea4a20" translate="yes" xml:space="preserve">
          <source>LDLOADLIBS and EXTRALIBS are always identical under Win32, and BSLOADLIBS and LD_RUN_PATH are always empty (this may change in future).</source>
          <target state="translated">LDLOADLIBS와 EXTRALIBS는 Win32에서 항상 동일하며 BSLOADLIBS와 LD_RUN_PATH는 항상 비어 있습니다 (향후 변경 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="27d827eb4792696500b4c73ad4ddf3c959ae3870" translate="yes" xml:space="preserve">
          <source>LDLOADLIBS and LD_RUN_PATH</source>
          <target state="translated">LDLOADLIBS 및 LD_RUN_PATH</target>
        </trans-unit>
        <trans-unit id="1635e0d5ca894812009c83cf6cdbe20b68728252" translate="yes" xml:space="preserve">
          <source>LDLOADLIBS contains both the libraries found based on &lt;code&gt;$potential_libs&lt;/code&gt; and the CRTLs, if any, specified in Config.pm. EXTRALIBS contains just those libraries found based on &lt;code&gt;$potential_libs&lt;/code&gt; . BSLOADLIBS and LD_RUN_PATH are always empty.</source>
          <target state="translated">LDLOADLIBS에는 &lt;code&gt;$potential_libs&lt;/code&gt; 기반으로 찾은 라이브러리 와 Config.pm에 지정된 CRTL이 포함되어 있습니다 . EXTRALIBS는 &lt;code&gt;$potential_libs&lt;/code&gt; 기반으로 찾은 라이브러리 만 포함 합니다. BSLOADLIBS 및 LD_RUN_PATH는 항상 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="256f68025172870d1f3c1210b89212eca54d2c93" translate="yes" xml:space="preserve">
          <source>LDLOADLIBS's default is changed to $Config{libs}.</source>
          <target state="translated">LDLOADLIBS의 기본값은 $ Config {libs}로 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="31a999d2e445df6d94c2d10d2f899c4b7a408247" translate="yes" xml:space="preserve">
          <source>LD_LIBRARY_PATH</source>
          <target state="translated">LD_LIBRARY_PATH</target>
        </trans-unit>
        <trans-unit id="9492fe99bfc78ed50462f6bcf892cde2a90aadb5" translate="yes" xml:space="preserve">
          <source>LEAVE_SRC</source>
          <target state="translated">LEAVE_SRC</target>
        </trans-unit>
        <trans-unit id="8753fd6c3b8da3cc6d317b80329ed3b40b2aa912" translate="yes" xml:space="preserve">
          <source>LETTERS</source>
          <target state="translated">LETTERS</target>
        </trans-unit>
        <trans-unit id="f481cc60f17adbd0734ec4396c3eec7ff4f97ae1" translate="yes" xml:space="preserve">
          <source>LEVEL</source>
          <target state="translated">LEVEL</target>
        </trans-unit>
        <trans-unit id="8ebe6b4ea1f79cdf5a0cfe5997e4373110b1513a" translate="yes" xml:space="preserve">
          <source>LIB should only be set at &lt;code&gt;perl Makefile.PL&lt;/code&gt; time but is allowed as a MakeMaker argument. It has the effect of setting both INSTALLPRIVLIB and INSTALLSITELIB to that value regardless any explicit setting of those arguments (or of PREFIX). INSTALLARCHLIB and INSTALLSITEARCH are set to the corresponding architecture subdirectory.</source>
          <target state="translated">LIB는 &lt;code&gt;perl Makefile.PL&lt;/code&gt; 시간 에만 설정해야 하지만 MakeMaker 인수로 허용됩니다. 인수 (또는 PREFIX)의 명시적인 설정에 관계없이 INSTALLPRIVLIB 및 INSTALLSITELIB를 모두 해당 값으로 설정하는 효과가 있습니다. INSTALLARCHLIB 및 INSTALLSITEARCH는 해당 아키텍처 서브 디렉토리로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="00484abc2f0a64aaebb7808382f0c80f8b800d94" translate="yes" xml:space="preserve">
          <source>LIBPTH, BASE_IMPORT, NLM_VERSION, MPKTOOL, TOOLPATH, BOOT_SYMBOL, NLM_SHORT_NAME, INCLUDE, PATH, MM_NW5_REVISION</source>
          <target state="translated">LIBPTH, BASE_IMPORT, NLM_VERSION, MPKTOOL, TOOLPATH, BOOT_SYMBOL, NLM_SHORT_NAME, INCLUDE, PATH, MM_NW5_REVISION</target>
        </trans-unit>
        <trans-unit id="6e0ad2b047414107e8ce2f294fa40d216b5b68f9" translate="yes" xml:space="preserve">
          <source>LICENCE</source>
          <target state="translated">LICENCE</target>
        </trans-unit>
        <trans-unit id="0417c3cd20e5957970bf6e0315ba11993f41a4ef" translate="yes" xml:space="preserve">
          <source>LICENCE AND COPYRIGHT</source>
          <target state="translated">라이센스 및 저작권</target>
        </trans-unit>
        <trans-unit id="0398ccd0f49298b10a3d76a47800d2ebecd49859" translate="yes" xml:space="preserve">
          <source>LICENSE</source>
          <target state="translated">LICENSE</target>
        </trans-unit>
        <trans-unit id="00e15f5838907cd7e1d4b00639d57748e292cb00" translate="yes" xml:space="preserve">
          <source>LIGHTWEIGHT CALLBACKS</source>
          <target state="translated">경량 콜백</target>
        </trans-unit>
        <trans-unit id="929a3a64284b80f705b148843a13caea7da8d500" translate="yes" xml:space="preserve">
          <source>LIMITATIONS</source>
          <target state="translated">LIMITATIONS</target>
        </trans-unit>
        <trans-unit id="e0e14c87e0e2d089b660f73f34d498e64b436810" translate="yes" xml:space="preserve">
          <source>LIMITATIONS of *-x*</source>
          <target state="translated">* -x *의 한계</target>
        </trans-unit>
        <trans-unit id="582303292e0d9bb459bbce59d367e726e77b22ef" translate="yes" xml:space="preserve">
          <source>LIMITATIONS of &lt;b&gt;-x&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;-x의&lt;/b&gt; 한계&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="83fa9b97f00ca753b1e5690c43dd3d3361c9665b" translate="yes" xml:space="preserve">
          <source>LIMITS</source>
          <target state="translated">LIMITS</target>
        </trans-unit>
        <trans-unit id="735cf1665d0fd36f4865e4bc7439abe369572e04" translate="yes" xml:space="preserve">
          <source>LIST</source>
          <target state="translated">LIST</target>
        </trans-unit>
        <trans-unit id="c717fe4bbb26a57f5091a39f5ae5c04c8ba67f80" translate="yes" xml:space="preserve">
          <source>LIST OF LANGUAGES</source>
          <target state="translated">언어 목록</target>
        </trans-unit>
        <trans-unit id="7de1e2b32d16e9fef7b2a9299320e7f3351fbed7" translate="yes" xml:space="preserve">
          <source>LIST OF UTILITIES</source>
          <target state="translated">유틸리티 목록</target>
        </trans-unit>
        <trans-unit id="567a6688f397cbb26479212b5e88b04513465d6e" translate="yes" xml:space="preserve">
          <source>LIST-REDUCTION FUNCTIONS</source>
          <target state="translated">목록 감소 기능</target>
        </trans-unit>
        <trans-unit id="79350be1daad6ac703bf5442efacc2b70bd2d6d8" translate="yes" xml:space="preserve">
          <source>LISTs do automatic interpolation of sublists. That is, when a LIST is evaluated, each element of the list is evaluated in list context, and the resulting list value is interpolated into LIST just as if each individual element were a member of LIST. Thus arrays and hashes lose their identity in a LIST--the list</source>
          <target state="translated">LIST는 서브리스트의 자동 보간을 수행합니다. 즉, LIST가 평가 될 때,리스트의 각 요소는리스트 컨텍스트에서 평가되고, 결과적인리스트 값은 각각의 개별 요소가 LIST의 멤버 인 것처럼 LIST에 보간됩니다. 따라서 배열과 해시는 LIST (목록)에서 ID를 잃습니다.</target>
        </trans-unit>
        <trans-unit id="755d87179ae52e75a5bb95a78c2b37c1c06b5cfe" translate="yes" xml:space="preserve">
          <source>LNM$FILE_DEV</source>
          <target state="translated">LNM$FILE_DEV</target>
        </trans-unit>
        <trans-unit id="1b95b1479e9e1e6747637c53ec6e7b5b14710300" translate="yes" xml:space="preserve">
          <source>LOCALE</source>
          <target state="translated">LOCALE</target>
        </trans-unit>
        <trans-unit id="ff495344ff0fb9c5d5d9ca658b1dad0e61447a28" translate="yes" xml:space="preserve">
          <source>LOCALE CATEGORIES</source>
          <target state="translated">지역 카테고리</target>
        </trans-unit>
        <trans-unit id="169a463b713e3988d9c565945a1d24d03d787111" translate="yes" xml:space="preserve">
          <source>LOCALE PROBLEMS</source>
          <target state="translated">지역 문제</target>
        </trans-unit>
        <trans-unit id="39f15a969419d44e933dbe07a4c0bebe3f003b8b" translate="yes" xml:space="preserve">
          <source>LOGGING</source>
          <target state="translated">LOGGING</target>
        </trans-unit>
        <trans-unit id="95b6b6c48c6cb1e24e041085cc38cb73e88d737e" translate="yes" xml:space="preserve">
          <source>LOOSE MATCHES</source>
          <target state="translated">느슨한 경기</target>
        </trans-unit>
        <trans-unit id="18cd8d5a0349b94405db9dec7298507ccea49b05" translate="yes" xml:space="preserve">
          <source>LaTeX docs</source>
          <target state="translated">LaTeX 문서</target>
        </trans-unit>
        <trans-unit id="89b86ab0e66f527166d98df92ddbcf5416ed58f6" translate="yes" xml:space="preserve">
          <source>Language</source>
          <target state="translated">Language</target>
        </trans-unit>
        <trans-unit id="f70518aa15c2b8187c80ac13806c15fba56111e6" translate="yes" xml:space="preserve">
          <source>Language Classes</source>
          <target state="translated">언어 수업</target>
        </trans-unit>
        <trans-unit id="cfb711d350591217fd017e0b7ddd59e362322862" translate="yes" xml:space="preserve">
          <source>Language Extensions and Documentation Tools</source>
          <target state="translated">언어 확장 및 설명서 도구</target>
        </trans-unit>
        <trans-unit id="6bd54d34369f11dcd172dcc70f872fcab4fd9483" translate="yes" xml:space="preserve">
          <source>Language Handle Attributes and Internals</source>
          <target state="translated">언어 핸들 속성 및 내부</target>
        </trans-unit>
        <trans-unit id="c91e4f4c0ce2f8eae1ea5e261c4add9fa7392039" translate="yes" xml:space="preserve">
          <source>Language Specs</source>
          <target state="translated">언어 사양</target>
        </trans-unit>
        <trans-unit id="f9d8878de4ae46e5debd26f638420ea68be31544" translate="yes" xml:space="preserve">
          <source>Language classes are what YourProjClass-&amp;gt;get_handle will try to load. It will look for them by taking each language-tag (&lt;b&gt;skipping&lt;/b&gt; it if it doesn't look like a language-tag or locale-tag!), turning it to all lowercase, turning dashes to underscores, and appending it to YourProjClass . &quot;::&quot;. So this:</source>
          <target state="translated">언어 클래스는 YourProjClass-&amp;gt; get_handle이로드하려고하는 것입니다. 각 언어 태그를 가져 와서 ( 언어 태그 나 로케일 태그처럼 보이지 않으면 &lt;b&gt;생략&lt;/b&gt; ), 모든 소문자로 바꾸고 대시를 밑줄로 바꾸고 YourProjClass에 추가하여 찾습니다. &quot;::&quot;. 그래서 이거:</target>
        </trans-unit>
        <trans-unit id="747c3b7de1d3c3e77b9c7320590e8b1ede8c25e3" translate="yes" xml:space="preserve">
          <source>Language classes may derive from other language classes (although they should have &quot;use</source>
          <target state="translated">언어 수업은 다른 언어 수업에서 파생 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1e10c58f87505ae028c597e6cc528cbbe1058b2" translate="yes" xml:space="preserve">
          <source>Language tags are a formalism, described in RFC 3066 (obsoleting 1766), for declaring what language form (language and possibly dialect) a given chunk of information is in.</source>
          <target state="translated">언어 태그는 RFC 3066 (구식 1766)에 설명 된 형식으로, 주어진 정보 덩어리에 어떤 언어 형식 (언어 및 가능한 방언)을 선언하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="97e909840ec23e6aa4c68a221630c55bfbbb900a" translate="yes" xml:space="preserve">
          <source>Language tags are not case-sensitive. en-US, en-us, En-Us, etc., are all the same tag, and denote the same language.</source>
          <target state="translated">언어 태그는 대소 문자를 구분하지 않습니다. en-US, en-us, En-Us 등은 모두 동일한 태그이며 동일한 언어를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2041c3756bf5afe1a1cc3301a6ebbbd4f47a0037" translate="yes" xml:space="preserve">
          <source>Language tags are not country codes. In fact, they are often distinct codes, as with language tag ja for Japanese, and ISO 3166 country code &lt;code&gt;.jp&lt;/code&gt; for Japan.</source>
          <target state="translated">언어 태그는 국가 코드가 아닙니다. 실제로는 일본어의 경우 언어 태그 ja 및 일본의 경우 ISO 3166 국가 코드 &lt;code&gt;.jp&lt;/code&gt; 와 같이 종종 고유 코드 입니다.</target>
        </trans-unit>
        <trans-unit id="6108174a71e0210309b5a122717007cd6591f45e" translate="yes" xml:space="preserve">
          <source>Language tags are not for computer languages.</source>
          <target state="translated">언어 태그는 컴퓨터 언어를위한 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6368278c82dd6595f994cb8b61fde8b578ee7f10" translate="yes" xml:space="preserve">
          <source>Language tags are not locale IDs. A locale ID is written with a &quot;_&quot; instead of a &quot;-&quot;, (almost?) always matches &lt;code&gt;&lt;a href=&quot;../../functions/m&quot;&gt;m/^\w\w_\w\w\b/&lt;/a&gt;&lt;/code&gt;, and</source>
          <target state="translated">언어 태그는 로캘 ID가 아닙니다. 로케일 ID가 작성되는 &quot;_&quot;대신에 &quot;-&quot;(? 거의) 항상 일치하는 &lt;code&gt;&lt;a href=&quot;../../functions/m&quot;&gt;m/^\w\w_\w\w\b/&lt;/a&gt;&lt;/code&gt; 및</target>
        </trans-unit>
        <trans-unit id="8edaa0c28ca3e32511fbcd5b5f49058ccc534792" translate="yes" xml:space="preserve">
          <source>Language-Specific</source>
          <target state="translated">Language-Specific</target>
        </trans-unit>
        <trans-unit id="21162f096b26204df6588bb5dc28d2f51868c501" translate="yes" xml:space="preserve">
          <source>Large File Support</source>
          <target state="translated">대용량 파일 지원</target>
        </trans-unit>
        <trans-unit id="cfd4c46c9150c3e9cafc48d2cf89b769398b7ba2" translate="yes" xml:space="preserve">
          <source>Large language group.</source>
          <target state="translated">큰 언어 그룹.</target>
        </trans-unit>
        <trans-unit id="68cb5c276851e088e954a75127561094108d7ebb" translate="yes" xml:space="preserve">
          <source>Large numbers of other programmers will be using your code modules.</source>
          <target state="translated">많은 다른 프로그래머들이 코드 모듈을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="aed9d519447abe0e1e87e2be7e3184966a86c56b" translate="yes" xml:space="preserve">
          <source>Larger increments or decrements are handy in those cases where a thread needs to check out or return a number of resources at once.</source>
          <target state="translated">스레드가 한 번에 많은 자원을 체크 아웃하거나 리턴해야하는 경우 더 큰 증가 또는 감소가 편리합니다.</target>
        </trans-unit>
        <trans-unit id="fd62837b713bdee00d46e7ce620e1a597b3acf56" translate="yes" xml:space="preserve">
          <source>Larry Wall</source>
          <target state="translated">래리 벽</target>
        </trans-unit>
        <trans-unit id="9800616a976bc743bc49de05b3ff6a81a8fed2bf" translate="yes" xml:space="preserve">
          <source>Larry Wall &amp;lt;larry@wall.org&amp;gt;, with the help of oodles of other folks.</source>
          <target state="translated">래리 월 &amp;lt;larry@wall.org&amp;gt;, 다른 사람들의 국수의 도움으로.</target>
        </trans-unit>
        <trans-unit id="50431f0b84e94e89d59726aa67764d4b5cb64130" translate="yes" xml:space="preserve">
          <source>Larry Wall and others</source>
          <target state="translated">래리 벽 및 기타</target>
        </trans-unit>
        <trans-unit id="0fb4b4d75483396b0cb6c4053090cf1353b0f053" translate="yes" xml:space="preserve">
          <source>Larry Wall designed the elegant inherited bootstrap mechanism and implemented the first Perl 5 dynamic loader using it.</source>
          <target state="translated">Larry Wall은 우아한 상속 부트 스트랩 메커니즘을 설계하고이를 사용하여 최초의 Perl 5 동적 로더를 구현했습니다.</target>
        </trans-unit>
        <trans-unit id="49cef125f502490a3eaa452e5063337afd4e5415" translate="yes" xml:space="preserve">
          <source>Larry Wall, Sean M. Burke</source>
          <target state="translated">래리 월, 숀 엠 버크</target>
        </trans-unit>
        <trans-unit id="cad8518108cca44400e2368862a0f1a16bff95c7" translate="yes" xml:space="preserve">
          <source>Larry has his reasons for each of these things, but he doesn't claim that everyone else's mind works the same as his does.</source>
          <target state="translated">래리는 이런 것들에 대한 이유가 있지만 다른 사람의 마음이 자신의 생각과 동일하게 작동한다고 주장하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="3e11f8268af6857ace69f95b629b0d80778d0d6d" translate="yes" xml:space="preserve">
          <source>Larry is allowed to change his mind about any matter at a later date, regardless of whether he previously invoked Rule 1.</source>
          <target state="translated">Larry는 이전에 규칙 1을 호출했는지 여부에 관계없이 나중에 모든 사안에 대해 마음을 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3d699c187f5eebff127e90268deebe55f0277f7" translate="yes" xml:space="preserve">
          <source>Larry is always by definition right about how Perl should behave. This means he has final veto power on the core functionality.</source>
          <target state="translated">래리는 펄이 어떻게 행동해야하는지에 대해 정의상 항상 권리입니다. 이것은 그가 핵심 기능에 대한 최종 거부권을 가지고 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="91247cb31b4e3f24a173a3ed4edb3fbe905e9dfa" translate="yes" xml:space="preserve">
          <source>Larry said &quot;Although the Perl Slogan is</source>
          <target state="translated">래리는 &quot;펄 슬로건은</target>
        </trans-unit>
        <trans-unit id="8840809999231d8845f9dcc8eb994457fd02a531" translate="yes" xml:space="preserve">
          <source>Larry sees Perl development along the lines of the US government: there's the Legislature (the porters), the Executive branch (the -pumpking), and the Supreme Court (Larry). The legislature can discuss and submit patches to the executive branch all they like, but the executive branch is free to veto them. Rarely, the Supreme Court will side with the executive branch over the legislature, or the legislature over the executive branch. Mostly, however, the legislature and the executive branch are supposed to get along and work out their differences without impeachment or court cases.</source>
          <target state="translated">Larry는 미국 정부에 따라 Perl의 발전을 봅니다. 입법부 (포터), 행정부 (펌핑) 및 대법원 (래리)이 있습니다. 입법부는 원하는대로 행정부와 논의하고 패치를 제출할 수 있지만 행정부는 자유롭게 거부 할 수 있습니다. 드물게 대법원은 입법부 상무부 또는 입법부 상원과 나란히있을 것입니다. 그러나 대부분 입법부와 행정부는 탄핵이나 법정 사건없이 그 차이를 해결하고 해결해야합니다.</target>
        </trans-unit>
        <trans-unit id="86c4e4485ad3dbbdb5b5dd2e9dedc2315a7311d5" translate="yes" xml:space="preserve">
          <source>Last Changed</source>
          <target state="translated">마지막 변경</target>
        </trans-unit>
        <trans-unit id="1210639f474f0d343df95007771fdc202b411de7" translate="yes" xml:space="preserve">
          <source>Last In, First Out. See also &lt;b&gt;FIFO&lt;/b&gt;. A LIFO is usually called a &lt;b&gt;stack&lt;/b&gt;.</source>
          <target state="translated">후입 선출법. &lt;b&gt;FIFO&lt;/b&gt; 도 참조하십시오 . LIFO는 일반적으로 &lt;b&gt;스택&lt;/b&gt; 이라고합니다 .</target>
        </trans-unit>
        <trans-unit id="40830c73142a53064766f6ffa38ec5fccd97ec73" translate="yes" xml:space="preserve">
          <source>Last Updated: Fri, 29 Oct 1999 22:50:30 +0200</source>
          <target state="translated">최종 업데이트 : 1999 년 10 월 29 일 금요일 22:50:30 +0200</target>
        </trans-unit>
        <trans-unit id="f1e5fc7462efd81797093d9980b1aa8171197971" translate="yes" xml:space="preserve">
          <source>Last but not least, here are various tips for safer coding. See also &lt;a href=&quot;perlclib&quot;&gt;perlclib&lt;/a&gt; for libc/stdio replacements one should use.</source>
          <target state="translated">마지막으로 안전한 코딩을위한 다양한 팁이 있습니다. &lt;a href=&quot;perlclib&quot;&gt;사용해야&lt;/a&gt; 하는 libc / stdio 대체에 대해서는 perlclib 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dceffa1b326ba5ef1523c69acacd202e09a06fa6" translate="yes" xml:space="preserve">
          <source>Last modified 2013-04-29.</source>
          <target state="translated">마지막 수정 2013-04-29.</target>
        </trans-unit>
        <trans-unit id="5c3f1c04106319751d7e999882c029924d60d858" translate="yes" xml:space="preserve">
          <source>Last revised 14-Feb-1996, for Perl 5.002.</source>
          <target state="translated">Perl 5.002를 위해 1996 년 2 월 14 일 최종 개정.</target>
        </trans-unit>
        <trans-unit id="c838bd278b91a142d60ea0e71aa5a59ad40e1552" translate="yes" xml:space="preserve">
          <source>Last update: 2008-10-29</source>
          <target state="translated">최종 업데이트 : 2008-10-29</target>
        </trans-unit>
        <trans-unit id="fc7ec2c58f8d11214b25d3966287144f54470cfe" translate="yes" xml:space="preserve">
          <source>Last update: Tue Apr 26 18:30:55 MDT 2011</source>
          <target state="translated">마지막 업데이트 : 4 월 26 일 화요일 18:30:55 MDT 2011</target>
        </trans-unit>
        <trans-unit id="d25a330cf94331e783b24031686ddd1e4f1da4ff" translate="yes" xml:space="preserve">
          <source>Last updated: 07 October 2014</source>
          <target state="translated">최종 업데이트 : 2014 년 10 월 7 일</target>
        </trans-unit>
        <trans-unit id="e1651fd9e16da0fb6683f8baa5303f215ef932af" translate="yes" xml:space="preserve">
          <source>Last updated: 2012-02-08</source>
          <target state="translated">최종 업데이트 : 2012-02-08</target>
        </trans-unit>
        <trans-unit id="152779e4c8b9d8d930bb573d8f364d8d186f33dd" translate="yes" xml:space="preserve">
          <source>Lastly, the</source>
          <target state="translated">마지막으로</target>
        </trans-unit>
        <trans-unit id="4d407485e169287b1c2aa3f4a4b85bc45bed7a87" translate="yes" xml:space="preserve">
          <source>Lastly, there is a special method for working under &lt;b&gt;-T&lt;/b&gt; and setuid/gid scripts:</source>
          <target state="translated">마지막으로 &lt;b&gt;-T&lt;/b&gt; 및 setuid / gid 스크립트 에서 작업하기위한 특별한 방법이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="202e6182477b0bfd7c1ee15e20cf42a59755cdd1" translate="yes" xml:space="preserve">
          <source>Laszlo Molnar,</source>
          <target state="translated">라즐로 몰 나르,</target>
        </trans-unit>
        <trans-unit id="526c6b8794fab24bec118be16f23def6a69bab1c" translate="yes" xml:space="preserve">
          <source>Lately, ignoring or actively opposing compatibility with earlier versions of Perl has come into vogue. Sometimes, a change is proposed which wants to usurp syntax which previously had another meaning. Sometimes, a change wants to improve previously-crazy semantics.</source>
          <target state="translated">최근에는 이전 버전의 Perl과의 호환성을 무시하거나 적극적으로 반대하고 있습니다. 때로는 이전에 다른 의미를 가진 구문을 빼내려는 변경이 제안되기도합니다. 때때로, 변화는 이전에 미친 의미론을 개선하기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="36e7725e6d39280db73b49ece64538b8d66586a2" translate="yes" xml:space="preserve">
          <source>Later in the life of the object the methods may be queries with get() method and set() method (which accept multiple arguments).</source>
          <target state="translated">나중에 객체의 수명에서 메소드는 get () 메소드 및 set () 메소드를 사용하는 쿼리 일 수 있습니다 (여러 인수를 허용 함).</target>
        </trans-unit>
        <trans-unit id="6e71bb4c4e3671df8bee4472c56c5267f4268f7f" translate="yes" xml:space="preserve">
          <source>Later invocations of coloralias() with the same ALIAS will override earlier aliases. There is no way to remove an alias.</source>
          <target state="translated">동일한 ALIAS를 사용한 coloralias ()의 이후 호출은 이전 별명을 대체합니다. 별명을 제거 할 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="c58245493d9e35fde84415d863d1963037986377" translate="yes" xml:space="preserve">
          <source>Later on, we'll pass this to Configure through -Dtargetenv</source>
          <target state="translated">나중에 -Dtargetenv를 통해 구성으로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="f8e3805b10e4c4f4b08c327d5a5b182642f7a406" translate="yes" xml:space="preserve">
          <source>Latest version of &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; on CPAN: &lt;a href=&quot;http://search.cpan.org/search?module=threads&quot;&gt;http://search.cpan.org/search?module=threads&lt;/a&gt;</source>
          <target state="translated">CPAN 의 최신 &lt;a href=&quot;threads&quot;&gt;스레드&lt;/a&gt; 버전 : &lt;a href=&quot;http://search.cpan.org/search?module=threads&quot;&gt;http://search.cpan.org/search?module=threads&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="55dfbb7924a9e791a0e250e51336f5378e1751eb" translate="yes" xml:space="preserve">
          <source>Latest version of &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt; on CPAN: &lt;a href=&quot;http://search.cpan.org/search?module=threads%3A%3Ashared&quot;&gt;http://search.cpan.org/search?module=threads%3A%3Ashared&lt;/a&gt;</source>
          <target state="translated">최신 버전의 &lt;a href=&quot;threads/shared&quot;&gt;스레드 :: 공유&lt;/a&gt; CPAN : &lt;a href=&quot;http://search.cpan.org/search?module=threads%3A%3Ashared&quot;&gt;http://search.cpan.org/search?module=threads%3A%3Ashared&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="57e8cec14c4a568ca92f36bd23fabb426a1d8b2d" translate="yes" xml:space="preserve">
          <source>Latin 1 (ISO 8859-1)</source>
          <target state="translated">라틴어 1 (ISO 8859-1)</target>
        </trans-unit>
        <trans-unit id="35bde1b1448a3634844f710f6f0c19bb97cc5c1e" translate="yes" xml:space="preserve">
          <source>Laundering and Detecting Tainted Data</source>
          <target state="translated">오염 된 데이터의 세탁 및 탐지</target>
        </trans-unit>
        <trans-unit id="467f628abddb4dcd106efd4dcaeb617681eb8f7d" translate="yes" xml:space="preserve">
          <source>Layer allows buffer snooping.</source>
          <target state="translated">레이어는 버퍼 스누핑을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="cb8d6c688037b3d7cd03ae365bbe000a64676df9" translate="yes" xml:space="preserve">
          <source>Layer can translate between &quot;\n&quot; and CRLF line ends.</source>
          <target state="translated">레이어는 &quot;\ n&quot;과 CRLF 줄 끝 사이를 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b12b05c07cab44e1c8dc0e859b671ac3d7cccd05" translate="yes" xml:space="preserve">
          <source>Layer is line buffered. Write data should be passed to next layer down whenever a &quot;\n&quot; is seen. Any data beyond the &quot;\n&quot; should then be processed.</source>
          <target state="translated">레이어가 라인 버퍼링됩니다. &quot;\ n&quot;이 표시 될 때마다 쓰기 데이터가 다음 계층으로 전달되어야합니다. 그런 다음 &quot;\ n&quot;이외의 모든 데이터를 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="63a50a8c52a6d0d048f4fa59a33a9d88e95e80ac" translate="yes" xml:space="preserve">
          <source>Layer is performing Win32-like &quot;\n&quot; mapped to CR,LF for output and CR,LF mapped to &quot;\n&quot; for input. Normally the provided &quot;crlf&quot; layer is the only layer that need bother about this. &lt;code&gt;PerlIO_binmode()&lt;/code&gt; will mess with this flag rather than add/remove layers if the &lt;code&gt;PERLIO_K_CANCRLF&lt;/code&gt; bit is set for the layers class.</source>
          <target state="translated">레이어가 출력에 대해서는 CR, LF에 매핑 된 Win32와 유사한 &quot;\ n&quot;을 수행하고 입력에 대해서는 &quot;\ n&quot;에 매핑 된 CR, LF를 수행합니다. 일반적으로 제공된 &quot;crlf&quot;레이어는 이에 대해 신경 쓰는 유일한 레이어입니다. &lt;code&gt;PerlIO_binmode()&lt;/code&gt; 비트가 레이어 클래스에 대해 설정된 경우 PerlIO_binmode () 는 레이어를 추가 / 제거하지 않고이 플래그를 엉망으로 &lt;code&gt;PERLIO_K_CANCRLF&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb03ef93aa3ad216c22ac53a17958f564d0c42cd" translate="yes" xml:space="preserve">
          <source>Layer is unbuffered - i.e. write to next layer down should occur for each write to this layer.</source>
          <target state="translated">레이어는 버퍼링되지 않습니다. 즉,이 레이어에 쓸 때마다 다음 레이어에 쓰기가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9f3401294ca5c3ec99fdd44fd405f62db10c762f" translate="yes" xml:space="preserve">
          <source>Layer which calls &lt;code&gt;fread&lt;/code&gt; , &lt;code&gt;fwrite&lt;/code&gt; and &lt;code&gt;fseek&lt;/code&gt; /&lt;code&gt;ftell&lt;/code&gt; etc. Note that as this is &quot;real&quot; stdio it will ignore any layers beneath it and go straight to the operating system via the C library as usual.</source>
          <target state="translated">&lt;code&gt;fread&lt;/code&gt; , &lt;code&gt;fwrite&lt;/code&gt; 및 &lt;code&gt;fseek&lt;/code&gt; / &lt;code&gt;ftell&lt;/code&gt; 등 을 호출하는 레이어. 이것은 &quot;실제&quot;stdio이므로 그 아래의 모든 레이어를 무시하고 평소와 같이 C 라이브러리를 통해 운영 체제로 바로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="9ff9f300fa7d1bbc3f849481cc645ec702a3625b" translate="yes" xml:space="preserve">
          <source>Layers can be made available by extension modules. When an unknown layer is encountered the PerlIO code will perform the equivalent of :</source>
          <target state="translated">확장 모듈로 레이어를 사용할 수 있습니다. 알 수없는 레이어가 발견되면 PerlIO 코드는 다음과 같은 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="0e3178f7991d7264f18bf3f06ccf8bf03e08f4f6" translate="yes" xml:space="preserve">
          <source>Layers in action.</source>
          <target state="translated">실제 레이어.</target>
        </trans-unit>
        <trans-unit id="90a85751546d30690f93cf14e09e26b8d8de391b" translate="yes" xml:space="preserve">
          <source>Layers it makes sense to include in the PERLIO environment variable are briefly summarized below. For more details see &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;.</source>
          <target state="translated">PERLIO 환경 변수에 포함하는 것이 적합한 계층은 아래에 간략하게 요약되어 있습니다. 자세한 내용은 &lt;a href=&quot;perlio&quot;&gt;PerlIO를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="69114be10292080f3d4afeef56cf245603257cc6" translate="yes" xml:space="preserve">
          <source>Layers vs Disciplines</source>
          <target state="translated">레이어 대 분야</target>
        </trans-unit>
        <trans-unit id="a41c1d3ed9255c2fe23288b7c102a2dc110d982d" translate="yes" xml:space="preserve">
          <source>Lazy people and beginners may now stop reading the manual.</source>
          <target state="translated">게으른 사람들과 초보자는 이제 매뉴얼 읽기를 중단 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9f359f1580c6817c9a64d72d3882cfe9dcbaef9" translate="yes" xml:space="preserve">
          <source>Le Sergent, T. and B. Berthomieu. &quot;Incremental MultiThreaded Garbage Collection on Virtually Shared Memory Architectures&quot; in Memory Management: Proc. of the International Workshop IWMM 92, St. Malo, France, September 1992, Yves Bekkers and Jacques Cohen, eds. Springer, 1992, ISBN 3540-55940-X (real-life thread applications).</source>
          <target state="translated">Le Sergent, T. 및 B. Berthomieu. 메모리 관리 : Proc. &quot;가상 공유 메모리 아키텍처의 증분 다중 스레드 가비지 콜렉션&quot; 국제 워크숍 IWMM 92, 1992 년 9 월, 프랑스 생 말로, 이브 베 커스 및 자크 코헨, eds. Springer, 1992, ISBN 3540-55940-X (실제 스레드 응용 프로그램).</target>
        </trans-unit>
        <trans-unit id="bd162d2f93cdcba4f68be85d18fd26ee09a12efb" translate="yes" xml:space="preserve">
          <source>Leading and trailing colons can be used together if you need positional parameter values without the names. Note that in the case below, the &lt;code&gt;PERL_API&lt;/code&gt; params are returned in alphabetical order.</source>
          <target state="translated">이름없이 위치 매개 변수 값이 필요한 경우 선행 및 후행 콜론을 함께 사용할 수 있습니다. 아래의 경우 &lt;code&gt;PERL_API&lt;/code&gt; 매개 변수는 알파벳 순서로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a19eb901d0541a10b461432e6635be906ecd8d19" translate="yes" xml:space="preserve">
          <source>Leading white space is ignored without warning, as too are any trailing non-digits, such as a decimal point (&lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt; only handles non-negative integers, not negative integers or floating point).</source>
          <target state="translated">선행 공백은 소수점과 같이 뒤에 오는 숫자가 아니기 때문에 경고없이 무시됩니다. &lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt; 는 음이 아닌 정수 또는 부동 소수점이 아닌 음이 아닌 정수만 처리합니다.</target>
        </trans-unit>
        <trans-unit id="fb2634197a046f8fbd1bb749b3d21bb890485f5f" translate="yes" xml:space="preserve">
          <source>Leading white space is ignored without warning, as too are any trailing non-digits, such as a decimal point (&lt;code&gt;&lt;a href=&quot;oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt; only handles non-negative integers, not negative integers or floating point).</source>
          <target state="translated">선행 공백은 소수점과 같이 뒤에 오는 숫자가 아니기 때문에 경고없이 무시됩니다. &lt;code&gt;&lt;a href=&quot;oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt; 는 음이 아닌 정수 또는 부동 소수점이 아닌 음이 아닌 정수만 처리합니다.</target>
        </trans-unit>
        <trans-unit id="ba3f4ebacb603a1ffae736f19b872df26ac931b0" translate="yes" xml:space="preserve">
          <source>Learn Perl and rewrite it. Seriously, there's no simple converter. Things that are awkward to do in the shell are easy to do in Perl, and this very awkwardness is what would make a shell-&amp;gt;perl converter nigh-on impossible to write. By rewriting it, you'll think about what you're really trying to do, and hopefully will escape the shell's pipeline datastream paradigm, which while convenient for some matters, causes many inefficiencies.</source>
          <target state="translated">Perl을 배우고 다시 작성하십시오. 정말로 간단한 변환기는 없습니다. 쉘에서 어색한 것들이 Perl에서하기 쉽다. 그리고이 매우 어색한 것은 쉘-&amp;gt; 펄 변환기를 거의 쓸 수 없게 만드는 것이다. 다시 작성하면 실제로 수행하려는 작업에 대해 생각하고 일부 문제에 편리하지만 많은 비 효율성을 유발하는 셸의 파이프 라인 데이터 스트림 패러다임을 피할 수 있기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="4dd0a48cec0f53000c96d709bef9efb450bae6d8" translate="yes" xml:space="preserve">
          <source>Leaving out the Notify option usually defaults an SMTP service to its default behavior equivalent to ['FAILURE'] notifications only, but again this may be dependent upon your site's SMTP configuration.</source>
          <target state="translated">알림 옵션을 제외하면 일반적으로 SMTP 서비스는 기본적으로 [ 'FAILURE'] 알림과 동등한 기본 동작으로 기본 설정되지만 사이트의 SMTP 구성에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4c7551b205677232e62bc969aaaea5621b25584" translate="yes" xml:space="preserve">
          <source>Lee Johnson &amp;lt;notfadeaway at btinternet dot com&amp;gt;</source>
          <target state="translated">이 존슨 &amp;lt;btinternet 닷 컴에서 사라지지 않음&amp;gt;</target>
        </trans-unit>
        <trans-unit id="b6a5edc3102ea975638e0ce2bb8f6982f95bead8" translate="yes" xml:space="preserve">
          <source>Left and right padding with any character, creating a new string:</source>
          <target state="translated">임의의 문자로 왼쪽 및 오른쪽 패딩, 새 문자열 생성 :</target>
        </trans-unit>
        <trans-unit id="7f1c7df67c81bb16bff18c751738160fab5ff982" translate="yes" xml:space="preserve">
          <source>Left and right padding with any character, modifying &lt;code&gt;$text&lt;/code&gt; directly:</source>
          <target state="translated">&lt;code&gt;$text&lt;/code&gt; 직접 수정하여 모든 문자로 왼쪽 및 오른쪽 패딩 :</target>
        </trans-unit>
        <trans-unit id="af98dcfaae79ce4ac9aa9fbbe9635687fe2fe178" translate="yes" xml:space="preserve">
          <source>Left offset from pos() to start match at.</source>
          <target state="translated">일치를 시작할 pos ()에서 왼쪽 오프셋.</target>
        </trans-unit>
        <trans-unit id="32ff2067f2a9f0deffe08043bfbad0999ed3babf" translate="yes" xml:space="preserve">
          <source>LeftString</source>
          <target state="translated">LeftString</target>
        </trans-unit>
        <trans-unit id="fb74bcaf76999b5ef8dae81b1022d842c093fe10" translate="yes" xml:space="preserve">
          <source>Legacy</source>
          <target state="translated">Legacy</target>
        </trans-unit>
        <trans-unit id="177a7c67030b56d701d66da14735a0847871d1fb" translate="yes" xml:space="preserve">
          <source>Legacy Character Sets</source>
          <target state="translated">레거시 문자 세트</target>
        </trans-unit>
        <trans-unit id="45890076a74f7ba49cb141341bf0a665659f9168" translate="yes" xml:space="preserve">
          <source>Legacy Encodings</source>
          <target state="translated">레거시 인코딩</target>
        </trans-unit>
        <trans-unit id="ca20c7f742784eaf8c9542c65094bd868679305e" translate="yes" xml:space="preserve">
          <source>Legacy multi byte EBCDIC code pages XXX.</source>
          <target state="translated">레거시 멀티 바이트 EBCDIC 코드 페이지 XXX.</target>
        </trans-unit>
        <trans-unit id="b14ba2ec2e45438ad3facc4d4b02bd06eedc0c59" translate="yes" xml:space="preserve">
          <source>Legacy, fixed-width encodings defined by the ISO 10646 standard. UCS-2 is a 16-bit encoding. Unlike UTF-16, UCS-2 is not extensible beyond &lt;code&gt;U+FFFF&lt;/code&gt; , because it does not use surrogates. UCS-4 is a 32-bit encoding, functionally identical to UTF-32 (the difference being that UCS-4 forbids neither surrogates nor code points larger than &lt;code&gt;0x10_FFFF&lt;/code&gt; ).</source>
          <target state="translated">ISO 10646 표준에 의해 정의 된 레거시 고정 너비 인코딩 UCS-2는 16 비트 인코딩입니다. UTF-16과 달리 UCS-2는 대리자를 사용하지 않기 때문에 &lt;code&gt;U+FFFF&lt;/code&gt; 이상으로 확장 할 수 없습니다. UCS-4는 기능적으로 UTF-32와 동일한 32 비트 인코딩입니다 (UCS-4가 &lt;code&gt;0x10_FFFF&lt;/code&gt; 보다 큰 대리 나 코드 포인트를 금지하지 않는다는 차이점 ).</target>
        </trans-unit>
        <trans-unit id="00a83ae1dc6e4e324ce120afa5a8e7b91193b805" translate="yes" xml:space="preserve">
          <source>Legal &lt;code&gt;\p{}&lt;/code&gt; and &lt;code&gt;\P{}&lt;/code&gt; constructs that match no characters</source>
          <target state="translated">문자와 일치하지 않는 유효한 &lt;code&gt;\p{}&lt;/code&gt; 및 &lt;code&gt;\P{}&lt;/code&gt; 구문</target>
        </trans-unit>
        <trans-unit id="b01926f0986a11c72cf140417a7b70c5868b0797" translate="yes" xml:space="preserve">
          <source>Legal \p{} and \P{} constructs that match no characters</source>
          <target state="translated">문자와 일치하지 않는 유효한 \ p {} 및 \ P {} 구문</target>
        </trans-unit>
        <trans-unit id="97f35de278fd2499acf694739f13d5aa76297107" translate="yes" xml:space="preserve">
          <source>Leif Eriksen &amp;lt;leif dot eriksen at bigpond dot com&amp;gt;</source>
          <target state="translated">Leif Eriksen &amp;lt;빅폰 닷 컴의 Leif Dot eriksen&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6115881c5ecab4a82072aab1fbcafeaf5ae5a302" translate="yes" xml:space="preserve">
          <source>Length of the name.</source>
          <target state="translated">이름의 길이입니다.</target>
        </trans-unit>
        <trans-unit id="1deb1eed10d40a0d45e6e2d30e54152b66733959" translate="yes" xml:space="preserve">
          <source>Length to truncate the argument list when the &lt;code&gt;frame&lt;/code&gt; option's bit 4 is set.</source>
          <target state="translated">&lt;code&gt;frame&lt;/code&gt; 옵션의 비트 4가 설정된 경우 인수 목록을자를 길이 입니다.</target>
        </trans-unit>
        <trans-unit id="1d1a91bdc1315d2ef3c37c514f4e0b41950b2992" translate="yes" xml:space="preserve">
          <source>Lengths and Widths</source>
          <target state="translated">길이와 폭</target>
        </trans-unit>
        <trans-unit id="c763c85942db32f81cf9ff36bb94bec3c42bb459" translate="yes" xml:space="preserve">
          <source>Let Perldoc check Pod for errors</source>
          <target state="translated">Perldoc에서 포드에 오류가 있는지 확인</target>
        </trans-unit>
        <trans-unit id="236e4f11c45d6dc4aeeb3e3ee19570b2cee88f0e" translate="yes" xml:space="preserve">
          <source>Let Perldoc convert Pod to nroff</source>
          <target state="translated">Perldoc가 포드를 nroff로 변환하게하십시오</target>
        </trans-unit>
        <trans-unit id="974a4ac3dfc20423e93f62bd6d7257d2efff060e" translate="yes" xml:space="preserve">
          <source>Let Perldoc render Pod as ... Pod!</source>
          <target state="translated">Perldoc가 포드를 ... 포드로 렌더링하도록하십시오!</target>
        </trans-unit>
        <trans-unit id="89789b71272a03c7a7d2242762bf736542d90944" translate="yes" xml:space="preserve">
          <source>Let Perldoc render Pod as RTF</source>
          <target state="translated">Perldoc가 포드를 RTF로 렌더링하도록하십시오</target>
        </trans-unit>
        <trans-unit id="a09176a65c16f1ea87e512ddbd1ebf583706c4be" translate="yes" xml:space="preserve">
          <source>Let Perldoc render Pod as XML</source>
          <target state="translated">Perldoc가 포드를 XML로 렌더링하도록 허용</target>
        </trans-unit>
        <trans-unit id="9dd1bef5afa3543070a44bc3e67a86b4a5626d33" translate="yes" xml:space="preserve">
          <source>Let Perldoc render Pod as man pages</source>
          <target state="translated">Perldoc가 포드를 맨 페이지로 렌더링하도록 허용</target>
        </trans-unit>
        <trans-unit id="cb573ad7df52482623e8e613fdbfbc5f59abce18" translate="yes" xml:space="preserve">
          <source>Let Perldoc render Pod as plaintext</source>
          <target state="translated">Perldoc가 포드를 일반 텍스트로 렌더링하도록 허용</target>
        </trans-unit>
        <trans-unit id="d279d6ba36fcd7e038b9dea67ba4516a9df60977" translate="yes" xml:space="preserve">
          <source>Let Perldoc use Tk::Pod to render Pod</source>
          <target state="translated">Perldoc이 Tk :: Pod를 사용하여 포드를 렌더링하게하십시오.</target>
        </trans-unit>
        <trans-unit id="757e98b6ce9386f0fb646f3598168b1185dc8359" translate="yes" xml:space="preserve">
          <source>Let it be noted that the flakiness of indirect filehandles is not related to whether they're strings, typeglobs, objects, or anything else. It's the syntax of the fundamental operators. Playing the object game doesn't help you at all here.</source>
          <target state="translated">간접 파일 핸들의 단점은 문자열, 타입 글로브, 객체 또는 다른 것과 관련이 없습니다. 기본 연산자의 구문입니다. 객체 게임을하는 것이 전혀 도움이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1fe958b2a6ee1393677c318cb2bd2d9b92f2cd48" translate="yes" xml:space="preserve">
          <source>Let it be stressed that</source>
          <target state="translated">그것을 강조하자</target>
        </trans-unit>
        <trans-unit id="b48514691c5b46e8297541220211ccc8b070316c" translate="yes" xml:space="preserve">
          <source>Let the index expire after how many days?</source>
          <target state="translated">며칠 후에 색인이 만료되도록 하시겠습니까?</target>
        </trans-unit>
        <trans-unit id="6104cb2c1f6570ab357e214a9780db2e76a15675" translate="yes" xml:space="preserve">
          <source>Let us now discuss Unicode character classes, most usually called &quot;character properties&quot;. These are represented by the &lt;code&gt;\p{name}&lt;/code&gt; escape sequence. Closely associated is the &lt;code&gt;\P{name}&lt;/code&gt; property, which is the negation of the &lt;code&gt;\p{name}&lt;/code&gt; one. For example, to match lower and uppercase characters,</source>
          <target state="translated">이제 가장 일반적으로 &quot;문자 속성&quot;이라고하는 유니 코드 문자 클래스에 대해 설명하겠습니다. 이는 &lt;code&gt;\p{name}&lt;/code&gt; 이스케이프 시퀀스로 표시됩니다. 밀접하게 연관되어 &lt;code&gt;\P{name}&lt;/code&gt; 의 부정 인 속성 &lt;code&gt;\p{name}&lt;/code&gt; 하나. 예를 들어 소문자와 대문자를 일치 시키려면</target>
        </trans-unit>
        <trans-unit id="d5b865b005185fbf91c141118661a5d11906d96e" translate="yes" xml:space="preserve">
          <source>Let's also fix the MANIFEST file so that it accurately reflects the contents of our extension. The single line that says &quot;mylib&quot; should be replaced by the following three lines:</source>
          <target state="translated">MANIFEST 파일을 수정하여 확장 내용을 정확하게 반영 해 봅시다. &quot;mylib&quot;라고 표시된 한 줄은 다음 세 줄로 바꿔야합니다.</target>
        </trans-unit>
        <trans-unit id="f577dbeceee6187e31fa08c5d2d55b7b25ccea26" translate="yes" xml:space="preserve">
          <source>Let's assume that we have a package &lt;code&gt;Cool::Foo&lt;/code&gt; , which includes &lt;code&gt;Cool::Foo&lt;/code&gt; and &lt;code&gt;Cool::Bar&lt;/code&gt; modules each having a separate XS file. First we use the following</source>
          <target state="translated">하자 우리가 패키지가 있다고 가정 &lt;code&gt;Cool::Foo&lt;/code&gt; 포함 &lt;code&gt;Cool::Foo&lt;/code&gt; 와 &lt;code&gt;Cool::Bar&lt;/code&gt; 각각 별도의 XS 파일을 가진 모듈. 먼저 우리는 다음을 사용합니다</target>
        </trans-unit>
        <trans-unit id="5b0ca95dec9c2d9636bc8d5032b2d5f394a81699" translate="yes" xml:space="preserve">
          <source>Let's begin by looking a simple scalar which is holding a string.</source>
          <target state="translated">문자열을 보유하고있는 간단한 스칼라를 살펴 보는 것으로 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="bf0b81e7623e4177f0bbf011b090062ef49e50b2" translate="yes" xml:space="preserve">
          <source>Let's consider how different regexps would match &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; :</source>
          <target state="translated">다른 정규 표현식이 &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; 와 어떻게 일치하는지 고려해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="df805a589a3384de86f5cf73ad97a197cc80b2b6" translate="yes" xml:space="preserve">
          <source>Let's consider what happens when the filtered code includes another module with use:</source>
          <target state="translated">필터링 된 코드에 사용중인 다른 모듈이 포함 된 경우 어떻게되는지 생각해 봅시다.</target>
        </trans-unit>
        <trans-unit id="c5bb45ed6a20ca29516eecb8c27b4f1a78faa8d9" translate="yes" xml:space="preserve">
          <source>Let's edit the .xs file by adding this to the end of the file:</source>
          <target state="translated">파일 끝에 이것을 추가하여 .xs 파일을 편집 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="f7e0018c031b17ac0ce35fd9db664c3f00e8a38b" translate="yes" xml:space="preserve">
          <source>Let's examine the cogs of this byte mill, one by one. There's the &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; call, creating the items we intend to stuff into the &lt;code&gt;$env&lt;/code&gt; buffer: to each key (in &lt;code&gt;$_&lt;/code&gt; ) it adds the &lt;code&gt;=&lt;/code&gt; separator and the hash entry value. Each triplet is packed with the template code sequence &lt;code&gt;A*A*Z*&lt;/code&gt; that is repeated according to the number of keys. (Yes, that's what the &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; function returns in scalar context.) To get the very last null byte, we add a &lt;code&gt;0&lt;/code&gt; at the end of the &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; list, to be packed with &lt;code&gt;C&lt;/code&gt; . (Attentive readers may have noticed that we could have omitted the 0.)</source>
          <target state="translated">이 바이트 밀의 톱니를 하나씩 살펴 보겠습니다. &lt;code&gt;$env&lt;/code&gt; 버퍼에 넣을 항목을 만드는 &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 호출 이 있습니다 . &lt;code&gt;$_&lt;/code&gt; 있는 각 키 에 &lt;code&gt;=&lt;/code&gt; 구분 기호와 해시 항목 값을 추가합니다 . 각 삼중 항 에는 키 수에 따라 반복되는 템플릿 코드 시퀀스 &lt;code&gt;A*A*Z*&lt;/code&gt; 가 포함되어 있습니다. (예, 이것이 스칼라 컨텍스트에서 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 함수가 반환하는 것입니다.) 마지막 null 바이트를 얻으려면 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 목록 끝에 &lt;code&gt;0&lt;/code&gt; 을 추가하여 &lt;code&gt;C&lt;/code&gt; 로 압축 합니다. (주의를 기울이는 독자는 우리가 0을 생략했을 수 있음을 알았을 것입니다.)</target>
        </trans-unit>
        <trans-unit id="9e554ae494be1d13390f7359c0d05574c54b38a5" translate="yes" xml:space="preserve">
          <source>Let's examine the whole implementation, for practice:</source>
          <target state="translated">실습을 위해 전체 구현을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="cb0a55a99d6403d9b27402fcdfbf4d6ed2e005f9" translate="yes" xml:space="preserve">
          <source>Let's explore this feature a little more. We'll begin with the equivalent of</source>
          <target state="translated">이 기능을 조금 더 살펴 보겠습니다. 우리는</target>
        </trans-unit>
        <trans-unit id="ebfb13b002928ab00b844746320f412762e65aa3" translate="yes" xml:space="preserve">
          <source>Let's give it a try:</source>
          <target state="translated">시도해 보자.</target>
        </trans-unit>
        <trans-unit id="4e14ae2cc2c4249d7ae1307778537f0e17717e46" translate="yes" xml:space="preserve">
          <source>Let's have a look at how Perl sees &lt;code&gt;$a = $b + $c&lt;/code&gt; :</source>
          <target state="translated">Perl이 &lt;code&gt;$a = $b + $c&lt;/code&gt; 보는 방법을 살펴 보자 .</target>
        </trans-unit>
        <trans-unit id="e928f3f516e4f40543bf011e7476bdaffeba6904" translate="yes" xml:space="preserve">
          <source>Let's look at another TCP client. This one connects to the TCP &quot;time&quot; service on a number of different machines and shows how far their clocks differ from the system on which it's being run:</source>
          <target state="translated">다른 TCP 클라이언트를 봅시다. 이것은 여러 다른 머신의 TCP &quot;시간&quot;서비스에 연결되며 클럭이 실행되는 시스템과 얼마나 다른지 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="0bfde5091a0fdc4b1dcc0dd94b94093ffcfd6f13" translate="yes" xml:space="preserve">
          <source>Let's look at each in turn, using as an example a tie class for scalars that allows the user to do something like:</source>
          <target state="translated">사용자가 다음과 같은 작업을 수행 할 수있는 스칼라의 타이 클래스를 예로 사용하여 각각을 차례로 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="8c38883dc5f76f55aab6aa025aff159c68fa3911" translate="yes" xml:space="preserve">
          <source>Let's look at each of these possible constructs in detail. There are separate sections on each of the following:</source>
          <target state="translated">가능한 각 구성을 자세히 살펴 보겠습니다. 다음 각각에 별도의 섹션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad30ae9725c85002b6831ea9730f9076d479a5c8" translate="yes" xml:space="preserve">
          <source>Let's look at each of these principles in depth.</source>
          <target state="translated">이러한 각 원칙을 자세히 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="176db7a51355c5004c1f239aa8667a05811318e4" translate="yes" xml:space="preserve">
          <source>Let's look at the example above, but with minimal quantifiers:</source>
          <target state="translated">위의 예를 살펴 보지만 최소한의 수량 자만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="44d6bf690bfe89fee660e282315649dfc02c909f" translate="yes" xml:space="preserve">
          <source>Let's make a quick object and x-plode it, first we'll start the debugger: it wants some form of input from STDIN, so we give it something non-committal, a zero:</source>
          <target state="translated">빠른 객체를 만들고 x-plode 해봅시다. 먼저 디버거를 시작하겠습니다 : STDIN에서 어떤 형태의 입력을 원하므로 커밋되지 않은 0을 부여합니다 :</target>
        </trans-unit>
        <trans-unit id="2af4365a6067ebec1d91261e67cfd455affae6b4" translate="yes" xml:space="preserve">
          <source>Let's say your application is a server that will occasionally run Perl code from some arbitrary file. Your server has no way of knowing what code it's going to run. Very dangerous.</source>
          <target state="translated">응용 프로그램이 임의의 파일에서 때때로 Perl 코드를 실행하는 서버라고 가정 해 봅시다. 서버는 어떤 코드를 실행할지 알 수 없습니다. 매우 위험한.</target>
        </trans-unit>
        <trans-unit id="4d890463be6280c78f6b7f6a985632f09c2fa90e" translate="yes" xml:space="preserve">
          <source>Let's see a quick example of how all this is useful.</source>
          <target state="translated">이 모든 것이 어떻게 유용한 지에 대한 간단한 예를 보자.</target>
        </trans-unit>
        <trans-unit id="e32a2ed9f3b04c47c03460e3d9853725a7d0f999" translate="yes" xml:space="preserve">
          <source>Let's see what &lt;code&gt;Benchmark&lt;/code&gt; makes of this:</source>
          <target state="translated">&lt;code&gt;Benchmark&lt;/code&gt; 가 무엇을하는지 보자 :</target>
        </trans-unit>
        <trans-unit id="405776f1b44151a8af53d3cf919e2d8b537db4ed" translate="yes" xml:space="preserve">
          <source>Let's start in the middle, at line 4. This is a BINOP, a binary operator, which is at location &lt;code&gt;0x8179828&lt;/code&gt; . The specific operator in question is &lt;code&gt;sassign&lt;/code&gt; - scalar assignment - and you can find the code which implements it in the function &lt;code&gt;pp_sassign&lt;/code&gt; in</source>
          <target state="translated">4 행에서 중간에서 시작합시다. 이것은 0x8179828 위치에있는 이진 연산자 인 &lt;code&gt;0x8179828&lt;/code&gt; 입니다. 해당 특정 연산자는 &lt;code&gt;sassign&lt;/code&gt; - 스칼라 할당 &lt;code&gt;pp_sassign&lt;/code&gt; in 함수에서이를 구현하는 코드를 찾을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="fc1d4b156d0cb946936473b6a08e0d57dc7fd23f" translate="yes" xml:space="preserve">
          <source>Let's start with the second line. It says that the uppercase of code point 97 is 65; or &lt;code&gt;&lt;a href=&quot;../functions/uc&quot;&gt;uc(&quot;a&quot;)&lt;/a&gt;&lt;/code&gt; == &quot;A&quot;. But the line is for the entire range of code points 97 through 122. To get the mapping for any code point in this range, you take the offset it has from the beginning code point of the range, and add that to the mapping for that first code point. So, the mapping for 122 (&quot;z&quot;) is derived by taking the offset of 122 from 97 (=25) and adding that to 65, yielding 90 (&quot;z&quot;). Likewise for everything in between.</source>
          <target state="translated">두 번째 줄부터 시작하겠습니다. 코드 포인트 97의 대문자는 65라고 말합니다. 또는 &lt;code&gt;&lt;a href=&quot;../functions/uc&quot;&gt;uc(&quot;a&quot;)&lt;/a&gt;&lt;/code&gt; == &quot;A&quot;. 그러나이 줄은 코드 범위 97에서 122까지의 전체 범위에 해당합니다.이 범위의 코드 포인트에 대한 매핑을 가져 오려면 범위의 시작 코드 포인트에서 오프셋을 가져 와서 해당 매핑에 매핑에 추가합니다. 첫 번째 코드 포인트. 따라서 122 ( &quot;z&quot;)에 대한 매핑은 97 (= 25)에서 122의 오프셋을 가져 와서 65에 추가하여 90 ( &quot;z&quot;)을 생성하여 파생됩니다. 그 사이의 모든 것에 대해서도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="0880854fa8770ea11a4efe4579463972aa5ae537" translate="yes" xml:space="preserve">
          <source>Let's suppose you have some weird Martian encoding where pairs of ASCII uppercase letters encode single Martian letters (i.e. the two bytes &quot;CV&quot; make a single Martian letter, as do the two bytes &quot;SG&quot;, &quot;VS&quot;, &quot;XX&quot;, etc.). Other bytes represent single characters, just like ASCII.</source>
          <target state="translated">ASCII 대문자 쌍이 단일 Martian 문자를 인코딩하는 이상한 Martian 인코딩이 있다고 가정합니다 (예 : 2 바이트 &quot;CV&quot;는 2 바이트 &quot;SG&quot;, &quot;VS&quot;, &quot;XX&quot;등의 단일 Martian 문자를 만듭니다) ). 다른 바이트는 ASCII처럼 단일 문자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8f09fe13c85ec276cd87ab04a04d40aac9612c6e" translate="yes" xml:space="preserve">
          <source>Let's suppose you've got to read in a data file like this:</source>
          <target state="translated">다음과 같은 데이터 파일을 읽어야한다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="2f7c544be1b70356d2951611060b9932dadf6ea2" translate="yes" xml:space="preserve">
          <source>Let's take a look at a portion of the .c file created for our extension. The file name is Mytest.c:</source>
          <target state="translated">확장을 위해 생성 된 .c 파일의 일부를 살펴 보겠습니다. 파일 이름은 Mytest.c입니다.</target>
        </trans-unit>
        <trans-unit id="ce5f83676281dd1446f1a5a503aee374bc369bcc" translate="yes" xml:space="preserve">
          <source>Let's take a look at the same program using a different profiler: &lt;code&gt;Devel::Profiler&lt;/code&gt; , a drop-in Perl-only replacement for &lt;code&gt;Devel::DProf&lt;/code&gt; . The usage is very slightly different in that instead of using the special &lt;code&gt;-d:&lt;/code&gt; flag, you pull &lt;code&gt;Devel::Profiler&lt;/code&gt; in directly as a module using &lt;code&gt;-M&lt;/code&gt; .</source>
          <target state="translated">다른 프로파일 러 &lt;code&gt;Devel::Profiler&lt;/code&gt; 사용하여 동일한 프로그램을 살펴 보자 : &lt;code&gt;Devel::DProf&lt;/code&gt; 펄 전용 드롭 인 . 특수한 &lt;code&gt;-d:&lt;/code&gt; 플래그 를 사용하는 대신 &lt;code&gt;-M&lt;/code&gt; 을 사용하여 &lt;code&gt;Devel::Profiler&lt;/code&gt; 를 모듈로 직접 가져 오는 사용법이 약간 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="230698ed5211b94950bbc39ebf4a2cd8603f3243" translate="yes" xml:space="preserve">
          <source>Let's take a simple patch from start to finish.</source>
          <target state="translated">처음부터 끝까지 간단한 패치를 보자.</target>
        </trans-unit>
        <trans-unit id="2b003d41c47da4c513944208b256541b446c8a71" translate="yes" xml:space="preserve">
          <source>Let's take an example of manipulating a PV, from &lt;code&gt;sv_catpvn&lt;/code&gt; , in</source>
          <target state="translated">&lt;code&gt;sv_catpvn&lt;/code&gt; 에서 PV를 조작하는 예제를 보자 .</target>
        </trans-unit>
        <trans-unit id="7c3c67f07cd4da0245ca6a99400a337a71fe4ec4" translate="yes" xml:space="preserve">
          <source>Let's take an example. Suppose you're reading in data from a local format into a hash-of-hashes in Perl, turning that into a tree, walking the tree and then piping each node to an Acme Transmogrifier Server.</source>
          <target state="translated">예를 들어 봅시다. 로컬 형식에서 Perl의 해시 해시로 데이터를 읽고이를 트리로 바꾸고 나무를 걷은 다음 각 노드를 Acme Transmogrifier Server에 파이프한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="f39fd63d744cf93b2616319a85e2d2154efb3e45" translate="yes" xml:space="preserve">
          <source>Let's you write:</source>
          <target state="translated">작성해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="2f17a5ca119319a7ec877e7a949710676dc887eb" translate="yes" xml:space="preserve">
          <source>Level 1 - Basic Unicode Support</source>
          <target state="translated">레벨 1-기본 유니 코드 지원</target>
        </trans-unit>
        <trans-unit id="0de802e5c110593513199ad6be14e0d3e4934cee" translate="yes" xml:space="preserve">
          <source>Level 2 - Extended Unicode Support</source>
          <target state="translated">레벨 2-확장 유니 코드 지원</target>
        </trans-unit>
        <trans-unit id="bddac528f4922054293682b3a34528809353679b" translate="yes" xml:space="preserve">
          <source>Level 3 - Tailored Support</source>
          <target state="translated">레벨 3-맞춤형 지원</target>
        </trans-unit>
        <trans-unit id="27b7cf7750bfaac558f7db0f6b00074662dc6814" translate="yes" xml:space="preserve">
          <source>Level of verbosity. By default, the debugger leaves your exceptions and warnings alone, because altering them can break correctly running programs. It will attempt to print a message when uncaught INT, BUS, or SEGV signals arrive. (But see the mention of signals in &lt;a href=&quot;#BUGS&quot;&gt;BUGS&lt;/a&gt; below.)</source>
          <target state="translated">자세한 수준. 기본적으로 디버거는 예외 및 경고를 변경하면 올바르게 실행중인 프로그램이 중단 될 수 있으므로 예외 및 경고 만 남겨 둡니다. 포착되지 않은 INT, BUS 또는 SEGV 신호가 도착하면 메시지 인쇄를 시도합니다. (하지만 아래 &lt;a href=&quot;#BUGS&quot;&gt;버그에&lt;/a&gt; 대한 신호 언급을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="ed47f098118b3a4908065115144a054c9afe75d6" translate="yes" xml:space="preserve">
          <source>Levels</source>
          <target state="translated">Levels</target>
        </trans-unit>
        <trans-unit id="dd4d01b82f363523e943497a1acd58ad122c1d74" translate="yes" xml:space="preserve">
          <source>Lewis, Bill, and Daniel J. Berg. Multithreaded Programming with Pthreads. Prentice Hall, 1997, ISBN 0-13-443698-9 (a well-written introduction to threads).</source>
          <target state="translated">Lewis, Bill 및 Daniel J. Berg. Pthread를 이용한 멀티 스레드 프로그래밍. 1997 년 Prentice Hall, ISBN 0-13-443698-9 (잘 작성된 쓰레드 소개).</target>
        </trans-unit>
        <trans-unit id="0130807d4961ca028150a643b43fa9d3af268eec" translate="yes" xml:space="preserve">
          <source>Lexer interface</source>
          <target state="translated">Lexer 인터페이스</target>
        </trans-unit>
        <trans-unit id="7c46e8b2c6a1b67615cc4a28b1803b6611e259c0" translate="yes" xml:space="preserve">
          <source>Lexical (my) variables declared in scopes external to a subroutine appear in code2ref output text as package variables. This is a tricky problem, as perl has no native facility for referring to a lexical variable defined within a different scope, although &lt;a href=&quot;http://search.cpan.org/perldoc/PadWalker&quot;&gt;PadWalker&lt;/a&gt; is a good start.</source>
          <target state="translated">서브 루틴 외부의 범위에서 선언 된 어휘 (my) 변수는 code2ref 출력 텍스트에 패키지 변수로 나타납니다. 펄에는 다른 범위 내에서 정의 된 어휘 변수를 참조 할 기본 기능이 없기 때문에 까다로운 문제이지만 &lt;a href=&quot;http://search.cpan.org/perldoc/PadWalker&quot;&gt;PadWalker&lt;/a&gt; 가 좋은 출발입니다.</target>
        </trans-unit>
        <trans-unit id="21795cace48f4382f41c503a0895c632d1557532" translate="yes" xml:space="preserve">
          <source>Lexical Subroutines</source>
          <target state="translated">어휘 서브 루틴</target>
        </trans-unit>
        <trans-unit id="91090443b78c24e5208fa0b7749049adce1d8581" translate="yes" xml:space="preserve">
          <source>Lexical effect</source>
          <target state="translated">어휘 효과</target>
        </trans-unit>
        <trans-unit id="10e46358434f33f5da4b481844bfbc427a1eaf46" translate="yes" xml:space="preserve">
          <source>Lexical scopes of control structures are not bounded precisely by the braces that delimit their controlled blocks; control expressions are part of that scope, too. Thus in the loop</source>
          <target state="translated">제어 구조의 어휘 범위는 제어 블록을 구분하는 괄호로 정확하게 구속되지 않습니다. 제어 표현식도 해당 범위의 일부입니다. 따라서 루프에서</target>
        </trans-unit>
        <trans-unit id="c32019b3ed41f9870148e7d8a8bcc91664cf5db8" translate="yes" xml:space="preserve">
          <source>Lexical subroutines are only available under the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature
'lexical_subs'&lt;/code&gt; pragma, which produces a warning unless the &quot;experimental::lexical_subs&quot; warnings category is disabled.</source>
          <target state="translated">어휘 서브 루틴은 &quot;experimental :: lexical_subs&quot;경고 범주를 사용하지 않으면 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'lexical_subs'&lt;/code&gt; 에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="63259d01172ac59370a7ece5661c26923725e28e" translate="yes" xml:space="preserve">
          <source>Lexical variable introduced (declared with my()) for the first time.</source>
          <target state="translated">처음으로 소개 된 어휘 변수 (my ()로 선언)</target>
        </trans-unit>
        <trans-unit id="6bec4b7b4f94bd2a84719ee4041560ade2de4cd8" translate="yes" xml:space="preserve">
          <source>Lexical variables (declared with &quot;my&quot;) are not visible within a format unless the format is declared within the scope of the lexical variable.</source>
          <target state="translated">형식이 어휘 변수의 범위 내에서 선언되지 않으면 어휘 변수 ( &quot;my&quot;로 선언 됨)는 형식 내에 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="56e8fa65a6460263a21b0d0b067830070ec69c2a" translate="yes" xml:space="preserve">
          <source>Lexical warnings get around these limitations by allowing finer control over where warnings can or can't be tripped.</source>
          <target state="translated">어휘 경고는 경고가 넘어 질 수있는 곳과 그렇지 못한 곳을보다 세밀하게 제어 할 수있게함으로써 이러한 한계를 극복합니다.</target>
        </trans-unit>
        <trans-unit id="dfa37e8913139b1f0a81171648bb039460ba6c8c" translate="yes" xml:space="preserve">
          <source>Lexically control overloading</source>
          <target state="translated">사전에 과부하 제어</target>
        </trans-unit>
        <trans-unit id="d23a9b3c648b4ba0282c9679b9e53d7ed27aaf5d" translate="yes" xml:space="preserve">
          <source>Lexing code (whether in the Perl core or not) moves this pointer past the characters that it consumes. It is also expected to perform some bookkeeping whenever a newline character is consumed. This movement can be more conveniently performed by the function &lt;a href=&quot;#lex_read_to&quot;&gt;lex_read_to&lt;/a&gt;, which handles newlines appropriately.</source>
          <target state="translated">렉싱 코드 (Perl 코어의 유무에 관계없이)는이 포인터를 소비하는 문자를 지나서 이동시킵니다. 또한 개행 문자가 사용될 때마다 약간의 부기를 수행해야합니다. 이 이동은 개행을 적절히 처리하는 &lt;a href=&quot;#lex_read_to&quot;&gt;lex_read_to&lt;/a&gt; 함수로보다 편리하게 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dbdf2fc886297cee27c73397601ff4f39103c78d" translate="yes" xml:space="preserve">
          <source>Libnet Frequently Asked Questions</source>
          <target state="translated">Libnet 자주 묻는 질문</target>
        </trans-unit>
        <trans-unit id="e99e9a5a6c267649059fa8147d50e8a56d55d8c3" translate="yes" xml:space="preserve">
          <source>Libraries using &lt;a href=&quot;#FUNCTIONS&quot;&gt;warnings::warn&lt;/a&gt; for custom warning categories generally don't expect &lt;a href=&quot;#FUNCTIONS&quot;&gt;warnings::warn&lt;/a&gt; to be fatal and can wind up in an unexpected state as a result. For XS modules issuing categorized warnings, such unanticipated exceptions could also expose memory leak bugs.</source>
          <target state="translated">사용자 정의 경고 범주에 &lt;a href=&quot;#FUNCTIONS&quot;&gt;대해 warnings :: warn&lt;/a&gt; 을 사용하는 라이브러리는 일반적으로 &lt;a href=&quot;#FUNCTIONS&quot;&gt;warnings :: warn&lt;/a&gt; 이 치명적일 것으로 예상하지 않으며 결과적으로 예기치 않은 상태가 될 수 있습니다. 분류 된 경고를 발행하는 XS 모듈의 경우 예상치 못한 예외로 인해 메모리 누수 버그가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbfd43d16e8972c230e7e22188720b2bf73e76c5" translate="yes" xml:space="preserve">
          <source>Library ... not found</source>
          <target state="translated">라이브러리 ... 찾을 수 없음</target>
        </trans-unit>
        <trans-unit id="51ac812d4d63215ce6bab6ff80843a9768d50aa3" translate="yes" xml:space="preserve">
          <source>Library modules should not in general export built-in names like &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; as part of their default &lt;code&gt;@EXPORT&lt;/code&gt; list, because these may sneak into someone else's namespace and change the semantics unexpectedly. Instead, if the module adds that name to &lt;code&gt;@EXPORT_OK&lt;/code&gt; , then it's possible for a user to import the name explicitly, but not implicitly. That is, they could say</source>
          <target state="translated">라이브러리 모듈은 일반적으로 기본 &lt;code&gt;@EXPORT&lt;/code&gt; 목록의 일부로 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 과 같은 내장 이름을 내 보내면 안됩니다. 다른 사람의 네임 스페이스로 몰래 들어가 의미가 예기치 않게 변경 될 수 있기 때문입니다. 대신 모듈이 해당 이름을 &lt;code&gt;@EXPORT_OK&lt;/code&gt; 에 추가 하면 사용자가 이름을 명시 적으로 가져올 수 있지만 내재적으로 가져올 수는 없습니다. 즉, 그들은 말할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="a8774f0e51de54365d13b10f234f9f0ab4b4c7b6" translate="yes" xml:space="preserve">
          <source>License is also granted to make and use derivative works provided that such works are identified as &quot;derived from the RSA Data Security, Inc. MD5 Message-Digest Algorithm&quot; in all material mentioning or referencing the derived work.</source>
          <target state="translated">파생 된 저작물을 언급하거나 언급하는 모든 자료에서 그러한 저작물이 &quot;RSA Data Security, Inc. MD5 Message-Digest Algorithm에서 파생 된&quot;것으로 식별되는 경우 파생 저작물을 만들고 사용할 수있는 라이센스도 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="8fb9dc902cb98efd9bae2b4a142dce7fcd9e3bb0" translate="yes" xml:space="preserve">
          <source>License to copy and use this software is granted provided that it is identified as the &quot;RSA Data Security, Inc. MD5 Message-Digest Algorithm&quot; in all material mentioning or referencing this software or this function.</source>
          <target state="translated">이 소프트웨어 또는이 기능을 언급하거나 언급하는 모든 자료에서 &quot;RSA Data Security, Inc. MD5 메시지 다이제스트 알고리즘&quot;으로 식별되는 경우이 소프트웨어를 복사하고 사용할 수있는 라이센스가 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="5924fd52bf49a8494e3d053dc865b25bbec5c6e6" translate="yes" xml:space="preserve">
          <source>Licensed under the GNU General Public License version 1 or later, or the Artistic License.</source>
          <target state="translated">GNU General Public License 버전 1 이상 또는 Artistic License에 따라 라이센스가 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="aa636d64869928622347b0ebd93665113e78146c" translate="yes" xml:space="preserve">
          <source>Licensing</source>
          <target state="translated">Licensing</target>
        </trans-unit>
        <trans-unit id="d5b616805cf9bfc9158dfb054c59875ea327a760" translate="yes" xml:space="preserve">
          <source>Life is not quite so transparent, however, when working with legacy encodings, I/O, and certain special cases:</source>
          <target state="translated">그러나 레거시 인코딩, I / O 및 특정 특수한 경우로 작업 할 때 인생은 그리 투명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ab3a00d7b8ef92b4d6db8938fdc867c976af1617" translate="yes" xml:space="preserve">
          <source>Lifetime of the parent process and pseudo-processes</source>
          <target state="translated">부모 프로세스 및 의사 프로세스의 수명</target>
        </trans-unit>
        <trans-unit id="cb79da38fbc832bc4294ccc8e4bcfcc8a2555134" translate="yes" xml:space="preserve">
          <source>Lightweight and lvalue version of &lt;code&gt;PAD_SV&lt;/code&gt; . Get or set the value at offset &lt;code&gt;po&lt;/code&gt; in the current pad. Unlike &lt;code&gt;PAD_SV&lt;/code&gt; , does not print diagnostics with -DX. For internal use only.</source>
          <target state="translated">&lt;code&gt;PAD_SV&lt;/code&gt; 의 경량 및 lvalue 버전 . 현재 패드 에서 오프셋 &lt;code&gt;po&lt;/code&gt; 의 값을 가져 오거나 설정합니다 . &lt;code&gt;PAD_SV&lt;/code&gt; 와 달리 -DX로 진단을 인쇄하지 않습니다. 내부 전용.</target>
        </trans-unit>
        <trans-unit id="c7e02c95fe85052fcadf9745a5f1d0358088d936" translate="yes" xml:space="preserve">
          <source>Like</source>
          <target state="translated">Like</target>
        </trans-unit>
        <trans-unit id="c9df7c5b0e2428587b12f5f968c72b403b65e631" translate="yes" xml:space="preserve">
          <source>Like &quot;@*&quot;, this is a variable-width field. The value supplied must be a scalar variable. Perl puts the first line (up to the first &quot;\n&quot;) of the text into the field, and then chops off the front of the string so that the next time the variable is referenced, more of the text can be printed. The variable will</source>
          <target state="translated">&quot;@ *&quot;와 마찬가지로이 필드는 가변 너비 필드입니다. 제공된 값은 스칼라 변수 여야합니다. Perl은 텍스트의 첫 번째 줄 (첫 번째 &quot;\ n&quot;까지)을 필드에 넣은 후 다음에 변수를 참조 할 때 더 많은 텍스트를 인쇄 할 수 있도록 문자열 앞을 잘라냅니다. 변수는</target>
        </trans-unit>
        <trans-unit id="c138d511965d3d204a9ae2bc98753a226047b504" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#charinfo()&quot;&gt;charinfo()&lt;/a&gt;, the result may be an intermediate decomposition whose components are also decomposable. Use &lt;a href=&quot;normalize&quot;&gt;Unicode::Normalize&lt;/a&gt; to get the final decomposition in one step.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#charinfo()&quot;&gt;charinfo ()&lt;/a&gt; , 그 결과는 그 요소도 분해되어 중간 분해 될 수있다. 한 번에 최종 분해를 얻으려면 &lt;a href=&quot;normalize&quot;&gt;Unicode :: Normalize&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3de5fd7897751225569f609d59202b32bba6024a" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cop_hints_fetch_pvn&quot;&gt;cop_hints_fetch_pvn&lt;/a&gt;, but takes a Perl scalar instead of a string/length pair.</source>
          <target state="translated">&lt;a href=&quot;#cop_hints_fetch_pvn&quot;&gt;cop_hints_fetch_pvn&lt;/a&gt; 과 비슷 하지만 문자열 / 길이 쌍 대신 Perl 스칼라를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9e492b6f65de514837e38acf884d2920be6c9c8e" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cop_hints_fetch_pvn&quot;&gt;cop_hints_fetch_pvn&lt;/a&gt;, but takes a literal string instead of a string/length pair, and no precomputed hash.</source>
          <target state="translated">&lt;a href=&quot;#cop_hints_fetch_pvn&quot;&gt;cop_hints_fetch_pvn&lt;/a&gt; 과 유사 하지만 문자열 / 길이 쌍 대신 리터럴 문자열을 사용하며 사전 계산 된 해시가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2de1e66c1756b6fab3c6fdb05cde4f4f25568233" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cop_hints_fetch_pvn&quot;&gt;cop_hints_fetch_pvn&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">&lt;a href=&quot;#cop_hints_fetch_pvn&quot;&gt;cop_hints_fetch_pvn&lt;/a&gt; 과 비슷 하지만 문자열 / 길이 쌍 대신 널 종료 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="de93912de0e72db38bde2b8e898d77fc9dc7395b" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cophh_delete_pvn&quot;&gt;cophh_delete_pvn&lt;/a&gt;, but takes a Perl scalar instead of a string/length pair.</source>
          <target state="translated">&lt;a href=&quot;#cophh_delete_pvn&quot;&gt;cophh_delete_pvn&lt;/a&gt; 과 비슷 하지만 문자열 / 길이 쌍 대신 Perl 스칼라를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5f93afb3b500f705910109bc574d7e2b47ae58fd" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cophh_delete_pvn&quot;&gt;cophh_delete_pvn&lt;/a&gt;, but takes a literal string instead of a string/length pair, and no precomputed hash.</source>
          <target state="translated">&lt;a href=&quot;#cophh_delete_pvn&quot;&gt;cophh_delete_pvn&lt;/a&gt; 과 유사 하지만 문자열 / 길이 쌍 대신 리터럴 문자열을 사용하며 사전 계산 된 해시가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7bc8a6b9daffa5d612ad332627c80e1cbcfc7c28" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cophh_delete_pvn&quot;&gt;cophh_delete_pvn&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">&lt;a href=&quot;#cophh_delete_pvn&quot;&gt;cophh_delete_pvn&lt;/a&gt; 과 비슷 하지만 문자열 / 길이 쌍 대신 널 종료 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="eaf7282f7430d0c1f55fb04bc9095993eb65be76" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cophh_fetch_pvn&quot;&gt;cophh_fetch_pvn&lt;/a&gt;, but takes a Perl scalar instead of a string/length pair.</source>
          <target state="translated">&lt;a href=&quot;#cophh_fetch_pvn&quot;&gt;cophh_fetch_pvn&lt;/a&gt; 과 비슷 하지만 문자열 / 길이 쌍 대신 Perl 스칼라를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b5ef552d2079e488edcf076c50da8cfc2edf287e" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cophh_fetch_pvn&quot;&gt;cophh_fetch_pvn&lt;/a&gt;, but takes a literal string instead of a string/length pair, and no precomputed hash.</source>
          <target state="translated">&lt;a href=&quot;#cophh_fetch_pvn&quot;&gt;cophh_fetch_pvn&lt;/a&gt; 과 유사 하지만 문자열 / 길이 쌍 대신 리터럴 문자열을 사용하며 사전 계산 된 해시가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1d820027a36b428c792671f4c8e4ee5300a7823f" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cophh_fetch_pvn&quot;&gt;cophh_fetch_pvn&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">&lt;a href=&quot;#cophh_fetch_pvn&quot;&gt;cophh_fetch_pvn&lt;/a&gt; 과 비슷 하지만 문자열 / 길이 쌍 대신 널 종료 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="73c1cef4e16a8379b39bb25b20396ecc27808f0b" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cophh_store_pvn&quot;&gt;cophh_store_pvn&lt;/a&gt;, but takes a Perl scalar instead of a string/length pair.</source>
          <target state="translated">&lt;a href=&quot;#cophh_store_pvn&quot;&gt;cophh_store_pvn&lt;/a&gt; 과 비슷 하지만 문자열 / 길이 쌍 대신 Perl 스칼라를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f8b72f1ae998c27a3bc7952f2e79a7833ed58822" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cophh_store_pvn&quot;&gt;cophh_store_pvn&lt;/a&gt;, but takes a literal string instead of a string/length pair, and no precomputed hash.</source>
          <target state="translated">&lt;a href=&quot;#cophh_store_pvn&quot;&gt;cophh_store_pvn&lt;/a&gt; 과 유사 하지만 문자열 / 길이 쌍 대신 리터럴 문자열을 사용하며 사전 계산 된 해시가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3d6eb33ec672f221ab14ac8aaae5ee9923295a95" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#cophh_store_pvn&quot;&gt;cophh_store_pvn&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">&lt;a href=&quot;#cophh_store_pvn&quot;&gt;cophh_store_pvn&lt;/a&gt; 과 유사 하지만 문자열 / 길이 쌍 대신 널 종료 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="54abf6089eca44394b7d1690bb3d38c0b82d3b35" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#gv_fetchmeth_pvn&quot;&gt;gv_fetchmeth_pvn&lt;/a&gt;, but lacks a flags parameter.</source>
          <target state="translated">&lt;a href=&quot;#gv_fetchmeth_pvn&quot;&gt;gv_fetchmeth_pvn&lt;/a&gt; 과 유사 하지만 플래그 매개 변수가 없습니다.</target>
        </trans-unit>
        <trans-unit id="9d0651cf67afe661baee2be32bf57a134f79be82" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#is_utf8_string&quot;&gt;is_utf8_string&lt;/a&gt; but stores the location of the failure (in the case of &quot;utf8ness failure&quot;) or the location &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;+&lt;code&gt;len&lt;/code&gt; (in the case of &quot;utf8ness success&quot;) in the &lt;code&gt;ep&lt;/code&gt; .</source>
          <target state="translated">추천 &lt;a href=&quot;#is_utf8_string&quot;&gt;is_utf8_string&lt;/a&gt; 또는 ( &quot;utf8ness 실패&quot;의 경우) 장애의 위치를 저장하지만 위치 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;len&lt;/code&gt; 에서 ( &quot;utf8ness 성공&quot;의 경우) &lt;code&gt;ep&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4826c3546aa34ea2d0524b77459a729065bbf15b" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#is_utf8_string&quot;&gt;is_utf8_string&lt;/a&gt;() but stores the location of the failure (in the case of &quot;utf8ness failure&quot;) or the location &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;+&lt;code&gt;len&lt;/code&gt; (in the case of &quot;utf8ness success&quot;) in the &lt;code&gt;ep&lt;/code&gt; , and the number of UTF-8 encoded characters in the &lt;code&gt;el&lt;/code&gt; .</source>
          <target state="translated">추천 &lt;a href=&quot;#is_utf8_string&quot;&gt;is_utf8_string&lt;/a&gt; ()하지만 저장 ( &quot;utf8ness 실패&quot;의 경우) 실패의 위치 또는 위치 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;len&lt;/code&gt; 에서 ( &quot;utf8ness 성공&quot;의 경우) &lt;code&gt;ep&lt;/code&gt; 및 UTF-8 인코딩 된 문자의 개수 에서 &lt;code&gt;el&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3df9351141888ffdcb4847144fedfdb9527ae3f1" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#lex_stuff_pvn&quot;&gt;lex_stuff_pvn&lt;/a&gt;, but takes a literal string instead of a string/length pair.</source>
          <target state="translated">&lt;a href=&quot;#lex_stuff_pvn&quot;&gt;lex_stuff_pvn&lt;/a&gt; 과 비슷 하지만 문자열 / 길이 쌍 대신 리터럴 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="855a9fc9268cf7c56dbfa870587e398be59edc5f" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#nextafter&quot;&gt;nextafter&lt;/a&gt;, but potentially more accurate.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#nextafter&quot;&gt;nextafter&lt;/a&gt; 하지만 잠재적으로 더 정확한.</target>
        </trans-unit>
        <trans-unit id="c3abb505c749731ad1d3986f391df84d9a744972" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#nexttoward&quot;&gt;nexttoward&lt;/a&gt;, but potentially less accurate.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#nexttoward&quot;&gt;nexttoward&lt;/a&gt; 하지만, 잠재적으로 덜 정확.</target>
        </trans-unit>
        <trans-unit id="724b06f3c6974466e0dcb566dbe47f6fad84aa5a" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#refcounted_he_fetch_pvn&quot;&gt;refcounted_he_fetch_pvn&lt;/a&gt;, but takes a Perl scalar instead of a string/length pair.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#refcounted_he_fetch_pvn&quot;&gt;refcounted_he_fetch_pvn&lt;/a&gt; 하지만, 문자열 / 길이 쌍 대신 펄 스칼라 걸립니다.</target>
        </trans-unit>
        <trans-unit id="23a489d2aec93a2d851cb278177881615d6f059f" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#refcounted_he_fetch_pvn&quot;&gt;refcounted_he_fetch_pvn&lt;/a&gt;, but takes a literal string instead of a string/length pair, and no precomputed hash.</source>
          <target state="translated">처럼 &lt;a href=&quot;#refcounted_he_fetch_pvn&quot;&gt;refcounted_he_fetch_pvn&lt;/a&gt; 하지만 문자열 / 길이 쌍 대신 리터럴 문자열을 사용하며 사전 계산 된 해시가 없습니다.</target>
        </trans-unit>
        <trans-unit id="401a90792585ceca6e1448d38f3a439e9e9ccb83" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#refcounted_he_fetch_pvn&quot;&gt;refcounted_he_fetch_pvn&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">처럼 &lt;a href=&quot;#refcounted_he_fetch_pvn&quot;&gt;refcounted_he_fetch_pvn&lt;/a&gt; 하지만 문자열 / 길이 쌍 대신 널 종료 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="046451b0d57dcef450722c52bfda2597acd52bb7" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#refcounted_he_new_pvn&quot;&gt;refcounted_he_new_pvn&lt;/a&gt;, but takes a Perl scalar instead of a string/length pair.</source>
          <target state="translated">처럼 &lt;a href=&quot;#refcounted_he_new_pvn&quot;&gt; refcounted_he_new_pvn&lt;/a&gt; 하지만, 문자열 / 길이 쌍 대신 펄 스칼라 걸립니다.</target>
        </trans-unit>
        <trans-unit id="6a998ebee49893ba076a8800f452b0183aae9a49" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#refcounted_he_new_pvn&quot;&gt;refcounted_he_new_pvn&lt;/a&gt;, but takes a literal string instead of a string/length pair, and no precomputed hash.</source>
          <target state="translated">처럼 &lt;a href=&quot;#refcounted_he_new_pvn&quot;&gt;refcounted_he_new_pvn&lt;/a&gt; 하지만 문자열 / 길이 쌍 대신 리터럴 문자열을 사용하며 사전 계산 된 해시가 없습니다.</target>
        </trans-unit>
        <trans-unit id="65d696e7d641f983cc3e14984e6670f40737f36e" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#refcounted_he_new_pvn&quot;&gt;refcounted_he_new_pvn&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">처럼 &lt;a href=&quot;#refcounted_he_new_pvn&quot;&gt; refcounted_he_new_pvn&lt;/a&gt; 하지만, 문자열 / 길이 쌍 대신 NUL 종료 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a963885aaf0f61482fbaede4f9fc78877a13624a" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#remainder&quot;&gt;remainder&lt;/a&gt; but also returns the low-order bits of the quotient (n) [C99]</source>
          <target state="translated">&lt;a href=&quot;#remainder&quot;&gt;나머지&lt;/a&gt; 처럼 하지만 몫 (n)의 하위 비트도 반환합니다 [C99]</target>
        </trans-unit>
        <trans-unit id="b5282dab906515d5042c87772d3d7af38dc7d497" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#round&quot;&gt;round&lt;/a&gt;, but as integer, as opposed to floating point [C99].</source>
          <target state="translated">&lt;a href=&quot;#round&quot;&gt;라운드&lt;/a&gt; 처럼 ,하지만 정수로 부동 소수점 [C99]에 반대했다.</target>
        </trans-unit>
        <trans-unit id="a05cbd07aa430b94f88ef1127d9cc3feb4a35b92" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#strtod&quot;&gt;strtod&lt;/a&gt; but for long doubles. Defined only if the system supports long doubles.</source>
          <target state="translated">&lt;a href=&quot;#strtod&quot;&gt;strtod&lt;/a&gt; 처럼 하지만 긴 복식. 시스템이 긴 복식을 지원하는 경우에만 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="07f5fd00ec8eac8e99d9f1474911e3920a009bb9" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#sv_does_pv&quot;&gt;sv_does_pv&lt;/a&gt;, but doesn't take a &lt;code&gt;flags&lt;/code&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;#sv_does_pv&quot;&gt;sv_does_pv&lt;/a&gt; 와 비슷 하지만 &lt;code&gt;flags&lt;/code&gt; 하지 않습니다 매개 변수를 사용 .</target>
        </trans-unit>
        <trans-unit id="ad65fa317ddd80710d2963974312eb533dd0432b" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#sv_does_sv&quot;&gt;sv_does_sv&lt;/a&gt;, but takes a nul-terminated string instead of an SV.</source>
          <target state="translated">&lt;a href=&quot;#sv_does_sv&quot;&gt;sv_does_sv&lt;/a&gt; 처럼 하지만 SV 대신 종료 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="aa34ede2432b39dab6d8a29f4520f696d8b17636" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#sv_does_sv&quot;&gt;sv_does_sv&lt;/a&gt;, but takes a string/length pair instead of an SV.</source>
          <target state="translated">&lt;a href=&quot;#sv_does_sv&quot;&gt;sv_does_sv&lt;/a&gt; 처럼 하지만 SV 대신 문자열 / 길이 쌍을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0270db3e4b83c7917acde896050328f249d7140a" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;more&quot;&gt;Test::More&lt;/a&gt;'s &lt;code&gt;isnt()&lt;/code&gt; . Checks if &lt;code&gt;$got ne $dont_expect&lt;/code&gt; . This is the numeric version.</source>
          <target state="translated">&lt;a href=&quot;more&quot;&gt;Test :: More&lt;/a&gt; 의 &lt;code&gt;isnt()&lt;/code&gt; 처럼 . 경우 확인 &lt;code&gt;$got ne $dont_expect&lt;/code&gt; . 이것은 숫자 버전입니다.</target>
        </trans-unit>
        <trans-unit id="a5f74c54ee73f3446f105290901ca9cf61ea643a" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;more&quot;&gt;Test::More&lt;/a&gt;'s &lt;code&gt;isnt()&lt;/code&gt; . Checks if &lt;code&gt;$got ne $dont_expect&lt;/code&gt; . This is the string version.</source>
          <target state="translated">&lt;a href=&quot;more&quot;&gt;Test :: More&lt;/a&gt; 의 &lt;code&gt;isnt()&lt;/code&gt; 처럼 . &lt;code&gt;$got ne $dont_expect&lt;/code&gt; 인지 확인합니다 . 이것은 문자열 버전입니다.</target>
        </trans-unit>
        <trans-unit id="9693737cd3c58d515bd81ab55ef59b90671ceaba" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;more&quot;&gt;Test::More&lt;/a&gt;'s &lt;code&gt;like()&lt;/code&gt; . Checks if $thing matches the given &lt;code&gt;$regex&lt;/code&gt; .</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;more&quot;&gt;테스트 :: 자세히&lt;/a&gt; 의 &lt;code&gt;like()&lt;/code&gt; . $ thing이 주어진 &lt;code&gt;$regex&lt;/code&gt; 와 일치하는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="348be5230ca4cb8628d5a3ede0642c968809d567" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;more&quot;&gt;Test::More&lt;/a&gt;'s &lt;code&gt;unlike()&lt;/code&gt; . Checks if $thing &lt;b&gt;does not match&lt;/b&gt; the given &lt;code&gt;$regex&lt;/code&gt; .</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;more&quot;&gt;테스트 :: 자세히&lt;/a&gt; 의 &lt;code&gt;unlike()&lt;/code&gt; . $ thing &lt;b&gt;이&lt;/b&gt; 주어진 &lt;code&gt;$regex&lt;/code&gt; &lt;b&gt;와 일치하지 않는지&lt;/b&gt; 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="75959408f273f7b39d4c26886da9ddb8ba9ee269" translate="yes" xml:space="preserve">
          <source>Like &lt;b&gt;-T&lt;/b&gt;, but taint checks will issue warnings rather than fatal errors. These warnings can now be controlled normally with &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings
qw(taint)&lt;/code&gt; .</source>
          <target state="translated">마찬가지로 &lt;b&gt;-T&lt;/b&gt; ,하지만 더러운 검사 경고보다는 치명적인 오류를 발행합니다. 이러한 경고는 이제 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings qw(taint)&lt;/code&gt; &lt;a href=&quot;functions/no&quot;&gt;없이&lt;/a&gt; 정상적으로 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="19d3972f6bfa689ac944e15f05e77cbb13096271" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&quot;extract_delimited&quot;&lt;/code&gt; , the &lt;code&gt;extract_bracketed&lt;/code&gt; function takes up to three optional scalar arguments: a string to extract from, a delimiter specifier, and a prefix pattern. As before, a missing prefix defaults to optional whitespace and a missing text defaults to &lt;code&gt;$_&lt;/code&gt; . However, a missing delimiter specifier defaults to &lt;code&gt;'{}()[]&amp;lt;&amp;gt;'&lt;/code&gt; (see below).</source>
          <target state="translated">마찬가지로 &lt;code&gt;&quot;extract_delimited&quot;&lt;/code&gt; 는 &lt;code&gt;extract_bracketed&lt;/code&gt; 문자열 구분 기호 지정자에서 추출하고, 접두사 패턴 : 함수는 세 개의 선택적 스칼라 인수를 차지한다. 이전과 같이 누락 된 접두어의 기본값은 선택적인 공백이며 누락 된 텍스트의 기본값은 &lt;code&gt;$_&lt;/code&gt; 입니다. 그러나 구분 기호 지정자가 없으면 기본값은 &lt;code&gt;'{}()[]&amp;lt;&amp;gt;'&lt;/code&gt; 입니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="a8638e9c741c1e67ac1a4fb8957038d6a39847eb" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;:i&lt;/code&gt; , but if the value is omitted, the</source>
          <target state="translated">추천 &lt;code&gt;:i&lt;/code&gt; , 값이 생략되면,</target>
        </trans-unit>
        <trans-unit id="6c3eb9fc5ff253146a577da27d5894ba1dc92861" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;:i&lt;/code&gt; , but if the value is omitted, the current value for the option will be incremented.</source>
          <target state="translated">&lt;code&gt;:i&lt;/code&gt; 와 유사 하지만 값을 생략하면 옵션의 현재 값이 증가합니다.</target>
        </trans-unit>
        <trans-unit id="a8ec6b1469cf896b7423c3e7e32f92d207da0b8f" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; allows you to lie to a program about its name if you use the &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; PROGRAM LIST&lt;/code&gt; syntax. Again, see &lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 사용자가 사용하는 경우 그 이름에 대한 프로그램에게 거짓말을 할 수 있도록 &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; PROGRAM LIST&lt;/code&gt; 구문을. 다시 한 번 &lt;a href=&quot;exec&quot;&gt;exec를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="53ce9db24e9d8151cb0d5ad673fbb551695d8498" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; allows you to lie to a program about its name if you use the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; PROGRAM LIST&lt;/code&gt; syntax. Again, see &lt;a href=&quot;#exec&quot;&gt;exec&lt;/a&gt;.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 사용자가 사용하는 경우 그 이름에 대한 프로그램에게 거짓말을 할 수 있도록 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; PROGRAM LIST&lt;/code&gt; 구문을. 다시 한 번 &lt;a href=&quot;#exec&quot;&gt;exec를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c07f470d836169d71198d296d47952ad2947c4f8" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt; $variable&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt; &lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; creates a lexical alias to the package subroutine of the same name.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt; $variable&lt;/code&gt; 처럼 , &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt; &lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 는 같은 이름의 패키지 서브 루틴에 어휘 별명을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e8bfeaa61a4310c58029cc704a58399ca890239c" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;=&lt;/code&gt; , but designates the argument as optional. If omitted, an empty string will be assigned to string values options, and the value zero to numeric options.</source>
          <target state="translated">마찬가지로 &lt;code&gt;=&lt;/code&gt; 하지만 옵션으로 인수를 지정합니다. 생략하면 빈 문자열이 문자열 값 옵션에 지정되고 값 0은 숫자 옵션에 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="9a58c5a4f4c388955ace0d1b2c081730bec782ab" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;ARRAY&lt;/code&gt; , but takes an index as an argument to get only one element, rather than a list of all of them.</source>
          <target state="translated">&lt;code&gt;ARRAY&lt;/code&gt; 와 유사 하지만 색인을 인수로 사용하여 모든 요소 목록이 아닌 하나의 요소 만 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="904d0219765a58ae524cd174247fe80e59898174" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;CLONE&lt;/code&gt; , &lt;code&gt;CLONE_SKIP&lt;/code&gt; is currently called with no parameters other than the invocant package name, although that may change. Similarly, to allow for future expansion, the return value should be a single &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt; value.</source>
          <target state="translated">마찬가지로 &lt;code&gt;CLONE&lt;/code&gt; , &lt;code&gt;CLONE_SKIP&lt;/code&gt; 는 그 변경 될 수 있지만 현재 invocant 패키지 이름이 아닌 매개 변수없이 호출된다. 마찬가지로 향후 확장을 위해 반환 값은 단일 &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;1&lt;/code&gt; 값 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="400aa1515ac06a94cb93b93ac9f5493878616d4c" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;Copy&lt;/code&gt; but returns dest. Useful for encouraging compilers to tail-call optimise.</source>
          <target state="translated">마찬가지로 &lt;code&gt;Copy&lt;/code&gt; 하지만 반환의 최종 도착합니다. 컴파일러가 테일 콜 최적화를 장려하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="14537197538893226d82efeb48b7a358e65846d7" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;Moose&lt;/code&gt; , &lt;code&gt;Class::Accessor&lt;/code&gt; generates accessor methods and a constructor for your class.</source>
          <target state="translated">마찬가지로 &lt;code&gt;Moose&lt;/code&gt; , &lt;code&gt;Class::Accessor&lt;/code&gt; 접근 방법과 클래스의 생성자를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="5dc10814cde731762cb07a8de6fded71423754dc" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;Move&lt;/code&gt; but returns dest. Useful for encouraging compilers to tail-call optimise.</source>
          <target state="translated">마찬가지로 &lt;code&gt;Move&lt;/code&gt; 하지만 반환의 최종 도착합니다. 컴파일러가 테일 콜 최적화를 장려하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="63bea6acc9be28a6d3cb950aea732759df8ac57d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvIV&lt;/code&gt; but doesn't process magic.</source>
          <target state="translated">&lt;code&gt;SvIV&lt;/code&gt; 와 비슷 하지만 마술을 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8f72df42d4357277ebaaa7626ab2ec8434c74b44" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvNV&lt;/code&gt; but doesn't process magic.</source>
          <target state="translated">마찬가지로 &lt;code&gt;SvNV&lt;/code&gt; 하지만 마법을 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f987f68efd96052a6b0a92226467d6e95b9160b3" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV&lt;/code&gt; , but converts sv to byte representation first if necessary.</source>
          <target state="translated">&lt;code&gt;SvPV&lt;/code&gt; 와 비슷 하지만 필요한 경우 sv를 먼저 바이트 표현으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="d5b21bddc458bd8cbfcd7db407bfa101b7f02dfa" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV&lt;/code&gt; , but converts sv to byte representation first if necessary. Guarantees to evaluate sv only once; use the more efficient &lt;code&gt;SvPVbyte&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;SvPV&lt;/code&gt; 와 비슷 하지만 필요한 경우 sv를 먼저 바이트 표현으로 변환합니다. sv를 한 번만 평가하도록 보장합니다. 그렇지 않으면 보다 효율적인 &lt;code&gt;SvPVbyte&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="020487c29dd87ab0c92e767efba3c8f41b9bfcc7" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV&lt;/code&gt; , but converts sv to utf8 first if necessary.</source>
          <target state="translated">&lt;code&gt;SvPV&lt;/code&gt; 와 비슷 하지만 필요한 경우 sv를 utf8로 먼저 변환합니다.</target>
        </trans-unit>
        <trans-unit id="a5a0c092212799a2ed1d29176de9f03d368894bf" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV&lt;/code&gt; , but converts sv to utf8 first if necessary. Guarantees to evaluate sv only once; use the more efficient &lt;code&gt;SvPVutf8&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;SvPV&lt;/code&gt; 와 비슷 하지만 필요한 경우 sv를 utf8로 먼저 변환합니다. sv를 한 번만 평가하도록 보장합니다. 그렇지 않으면 보다 효율적인 &lt;code&gt;SvPVutf8&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="728e33d136e3d988de2e0baba97a509be6c9c1b3" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV&lt;/code&gt; but doesn't process magic.</source>
          <target state="translated">&lt;code&gt;SvPV&lt;/code&gt; 와 비슷 하지만 마술을 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9f644bfac194a0b755578b81e47d7586566e4504" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV&lt;/code&gt; but doesn't set a length variable.</source>
          <target state="translated">&lt;code&gt;SvPV&lt;/code&gt; 와 같지만 길이 변수를 설정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="153041f77422ab93c76bcbcf6550af4c15800fa0" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV&lt;/code&gt; but will force the SV into containing a string (&lt;code&gt;SvPOK&lt;/code&gt; ), and only a string (&lt;code&gt;SvPOK_only&lt;/code&gt; ), by hook or by crook. You need force if you are going to update the &lt;code&gt;SvPVX&lt;/code&gt; directly. Processes get magic.</source>
          <target state="translated">추천 &lt;code&gt;SvPV&lt;/code&gt; 있지만 문자열 (SV 함유으로 강제 &lt;code&gt;SvPOK&lt;/code&gt; 를 )에서만 문자열 ( &lt;code&gt;SvPOK_only&lt;/code&gt; ) 수단을 써서. &lt;code&gt;SvPVX&lt;/code&gt; 를 직접 업데이트하려면 힘이 필요 합니다. 프로세스는 마법을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="d303190c56047f26fce52e3043032426e788042e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV_force&lt;/code&gt; , but converts sv to byte representation first if necessary.</source>
          <target state="translated">&lt;code&gt;SvPV_force&lt;/code&gt; 와 유사 하지만 필요한 경우 sv를 먼저 바이트 표현으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="e339b69da0fc6099ae5122846dd6d16329909d09" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV_force&lt;/code&gt; , but converts sv to byte representation first if necessary. Guarantees to evaluate sv only once; use the more efficient &lt;code&gt;SvPVbyte_force&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;SvPV_force&lt;/code&gt; 와 유사 하지만 필요한 경우 sv를 먼저 바이트 표현으로 변환합니다. sv를 한 번만 평가하도록 보장합니다. 그렇지 않으면 보다 효율적인 &lt;code&gt;SvPVbyte_force&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="33e41cb5a5972955c89d4da04933a8a79726a21b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV_force&lt;/code&gt; , but converts sv to utf8 first if necessary.</source>
          <target state="translated">&lt;code&gt;SvPV_force&lt;/code&gt; 와 비슷 하지만 필요한 경우 sv를 utf8로 먼저 변환합니다.</target>
        </trans-unit>
        <trans-unit id="85dee70f70d9f59dd1fd504ab0aa00e6dc082a6e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV_force&lt;/code&gt; , but converts sv to utf8 first if necessary. Guarantees to evaluate sv only once; use the more efficient &lt;code&gt;SvPVutf8_force&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;SvPV_force&lt;/code&gt; 와 비슷 하지만 필요한 경우 sv를 utf8로 먼저 변환합니다. sv를 한 번만 평가하도록 보장합니다. 그렇지 않으면 보다 효율적인 &lt;code&gt;SvPVutf8_force&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ed49f80c2155ad585761ac04bf59edd4a6a0831" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV_force&lt;/code&gt; , but doesn't process get magic.</source>
          <target state="translated">&lt;code&gt;SvPV_force&lt;/code&gt; 와 비슷 하지만 처리하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="dd41cfed5f0aafc487ed8b935e2fe00690512ae4" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV_nolen&lt;/code&gt; , but converts sv to byte representation first if necessary.</source>
          <target state="translated">마찬가지로 &lt;code&gt;SvPV_nolen&lt;/code&gt; 하지만 개종자 먼저 필요한 경우 바이트 표현으로 SV.</target>
        </trans-unit>
        <trans-unit id="569d8ee3b9025e7d46c4e22dc014e9293f09b9cf" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV_nolen&lt;/code&gt; , but converts sv to utf8 first if necessary.</source>
          <target state="translated">&lt;code&gt;SvPV_nolen&lt;/code&gt; 과 비슷 하지만 필요한 경우 sv를 utf8로 먼저 변환합니다.</target>
        </trans-unit>
        <trans-unit id="c6ed04996a1df68aa8ad7cc1586c48a5135a6669" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvPV_nolen&lt;/code&gt; but doesn't process magic.</source>
          <target state="translated">&lt;code&gt;SvPV_nolen&lt;/code&gt; 과 같지만 마술을 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ab106c9006a177a2bcf08f263e2472e6c9b25246" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvSetSV&lt;/code&gt; , but does any set magic required afterwards.</source>
          <target state="translated">&lt;code&gt;SvSetSV&lt;/code&gt; 와 비슷 하지만 나중에 필요한 마술을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="388de52bdbcc28141b225f26cb9f3fe2e05660c9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvSetSV_nosteal&lt;/code&gt; , but does any set magic required afterwards.</source>
          <target state="translated">&lt;code&gt;SvSetSV_nosteal&lt;/code&gt; 과 비슷 하지만 나중에 필요한 마술을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="3a27275be863ed7ef192a76ef76e83185d113390" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SvUV&lt;/code&gt; but doesn't process magic.</source>
          <target state="translated">&lt;code&gt;SvUV&lt;/code&gt; 와 비슷 하지만 마술을 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c145fe31e7a9856cfd103483b939c0b69292c062" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;Zero&lt;/code&gt; but returns dest. Useful for encouraging compilers to tail-call optimise.</source>
          <target state="translated">마찬가지로 &lt;code&gt;Zero&lt;/code&gt; 그러나 반환의 최종 도착합니다. 컴파일러가 테일 콜 최적화를 장려하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7a30913145132e032417d97e9d5716e5d07e3a09" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;article&lt;/code&gt; but only fetches the body of the article.</source>
          <target state="translated">&lt;code&gt;article&lt;/code&gt; 와 유사 하지만 기사 본문 만 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="dbf2edb5cf6acda874d56c0ec8d6a027b38ecd7b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;article&lt;/code&gt; but only fetches the headers for the article.</source>
          <target state="translated">&lt;code&gt;article&lt;/code&gt; 와 유사 하지만 기사 의 헤더 만 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="698d6282638ff97d91804a4f1cf2ced815c09a43" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;cond_wait&lt;/code&gt; , this function may take a shared, &lt;b&gt;locked&lt;/b&gt; variable as an additional parameter; in this case the first parameter is an &lt;b&gt;unlocked&lt;/b&gt; condition variable protected by a distinct lock variable.</source>
          <target state="translated">&lt;code&gt;cond_wait&lt;/code&gt; 와 마찬가지로이 함수는 공유 &lt;b&gt;잠금&lt;/b&gt; 변수를 추가 매개 변수로 사용할 수 있습니다 . 이 경우 첫 번째 매개 변수는 고유 한 잠금 변수로 보호되는 &lt;b&gt;잠금 해제&lt;/b&gt; 조건 변수입니다.</target>
        </trans-unit>
        <trans-unit id="c58a5c550c804eb437e5a9f29a412c2a917db541" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;copy&lt;/code&gt; , &lt;code&gt;rmscopy&lt;/code&gt; returns 1 on success. If an error occurs, it sets &lt;code&gt;$!&lt;/code&gt; , deletes the output file, and returns 0.</source>
          <target state="translated">마찬가지로 &lt;code&gt;copy&lt;/code&gt; , &lt;code&gt;rmscopy&lt;/code&gt; 성공 수익률 1. 에러가 발생하면 &lt;code&gt;$!&lt;/code&gt; 출력 파일을 삭제하고 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="62662a2fcd9593969fecb7744ceb2295a389997a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;diag()&lt;/code&gt; , but it prints to the &lt;code&gt;output()&lt;/code&gt; handle so it will not normally be seen by the user except in verbose mode.</source>
          <target state="translated">마찬가지로 &lt;code&gt;diag()&lt;/code&gt; , 그러나로 인쇄 &lt;code&gt;output()&lt;/code&gt; 가 통상 모드의 상세를 제외하고는 사용자가 볼 수없는 있도록 손잡이.</target>
        </trans-unit>
        <trans-unit id="983d206f2bed9edbbc722e7d5cdb62e2a06346c5" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;diag()&lt;/code&gt; , except the message will not be seen when the test is run in a harness. It will only be visible in the verbose TAP stream.</source>
          <target state="translated">&lt;code&gt;diag()&lt;/code&gt; 와 같이 테스트가 하네스에서 실행될 때 메시지가 표시되지 않는 것을 제외하고. 자세한 TAP 스트림에서만 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ca575f5cd45b0a03fd8f03890b4f05a0793bc86" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;gv_stashpvn&lt;/code&gt; , but takes a literal string instead of a string/length pair.</source>
          <target state="translated">&lt;code&gt;gv_stashpvn&lt;/code&gt; 과 유사 하지만 문자열 / 길이 쌍 대신 리터럴 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9a99146718e4827b551f9b9e65221a90a0c6896f" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;hv_fetch&lt;/code&gt; , but takes a literal string instead of a string/length pair.</source>
          <target state="translated">&lt;code&gt;hv_fetch&lt;/code&gt; 와 비슷 하지만 문자열 / 길이 쌍 대신 리터럴 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1b54ec87ed43945667a5780ba1140342cbc85083" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;hv_store&lt;/code&gt; , but takes a literal string instead of a string/length pair and omits the hash parameter.</source>
          <target state="translated">&lt;code&gt;hv_store&lt;/code&gt; 와 유사 하지만 문자열 / 길이 쌍 대신 리터럴 문자열을 사용하고 해시 매개 변수를 생략합니다.</target>
        </trans-unit>
        <trans-unit id="87cafedf7339223e94c98617ca5452de6e823831" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;is_regexp&lt;/code&gt; this function will not be confused by overloading or blessing of the object.</source>
          <target state="translated">&lt;code&gt;is_regexp&lt;/code&gt; 와 마찬가지로이 함수는 객체의 과부 하나 축복으로 인해 혼동되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ec33eb3b85c09c1867b94d4c5d38b36ea16437ca" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;newSVpvn&lt;/code&gt; , but takes a literal &lt;code&gt;NUL&lt;/code&gt; -terminated string instead of a string/length pair.</source>
          <target state="translated">&lt;code&gt;newSVpvn&lt;/code&gt; 과 비슷 하지만 리터럴이 필요합니다 &lt;code&gt;NUL&lt;/code&gt; 문자열 / 길이 쌍 대신 NUL 종료 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6def24d08af466796e4eeead658a36b729d71197" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;newSVpvn_flags&lt;/code&gt; , but takes a literal &lt;code&gt;NUL&lt;/code&gt; -terminated string instead of a string/length pair.</source>
          <target state="translated">&lt;code&gt;newSVpvn_flags&lt;/code&gt; 와 비슷 하지만 리터럴 &lt;code&gt;NUL&lt;/code&gt; 을 사용합니다. 문자열 / 길이 쌍 대신 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="df1c507c68363b1af9c5557f4eef915d6b55b26a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;newSVpvn_share&lt;/code&gt; , but takes a &lt;code&gt;NUL&lt;/code&gt; -terminated string instead of a string/length pair.</source>
          <target state="translated">마찬가지로 &lt;code&gt;newSVpvn_share&lt;/code&gt; 하지만이 소요 &lt;code&gt;NUL&lt;/code&gt; 을 문자열 / 길이 쌍 대신 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3dd80874ef095a04d51bc5aa179476376e4130b1" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;newSVpvn_share&lt;/code&gt; , but takes a literal &lt;code&gt;NUL&lt;/code&gt; -terminated string instead of a string/length pair and omits the hash parameter.</source>
          <target state="translated">&lt;code&gt;newSVpvn_share&lt;/code&gt; 와 비슷 하지만 리터럴 &lt;code&gt;NUL&lt;/code&gt; 을 사용합니다. 문자열 / 길이 쌍 대신 문자열을 사용하고 해시 매개 변수를 생략합니다.</target>
        </trans-unit>
        <trans-unit id="aa6a38afce596ffe8e2f194c11ba3be9d30f3333" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;pasv_xfer&lt;/code&gt; but the file is stored on the remote server using the STOU command.</source>
          <target state="translated">&lt;code&gt;pasv_xfer&lt;/code&gt; 처럼 하지만 파일은 STOU 명령을 사용하여 원격 서버에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="7fdced39cfee983640cff74a2b9f6b6a909daee3" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;require_ok&lt;/code&gt; , but it will &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; the $module in question and only loads modules, not files.</source>
          <target state="translated">&lt;code&gt;require_ok&lt;/code&gt; 와 유사 하지만 문제의 $ module을 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 하고 파일이 아닌 모듈 만로드합니다.</target>
        </trans-unit>
        <trans-unit id="d85e64ea446b94b53e6b0a98b79acffa9e65509e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;savepvn&lt;/code&gt; , but takes a literal &lt;code&gt;NUL&lt;/code&gt; -terminated string instead of a string/length pair.</source>
          <target state="translated">&lt;code&gt;savepvn&lt;/code&gt; 과 비슷 하지만 문자열 / 길이 쌍 대신 리터럴 &lt;code&gt;NUL&lt;/code&gt; 종료 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c6f07f68a2d9761eca21ebc3401a1a91fade1e35" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;skip()&lt;/code&gt; , only it will declare the test as failing and TODO. Similar to</source>
          <target state="translated">&lt;code&gt;skip()&lt;/code&gt; 과 같이 테스트 만 실패하고 TODO로 선언합니다. 비슷하다</target>
        </trans-unit>
        <trans-unit id="ffb9b95fcba79da2d66d4cd56bc634f774dac146" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;summary()&lt;/code&gt; , but with a lot more detail.</source>
          <target state="translated">마찬가지로 &lt;code&gt;summary()&lt;/code&gt; 하지만, 더 많은 세부 사항.</target>
        </trans-unit>
        <trans-unit id="8bc85a8c4d9155e4879660bb0fb6db949fdb86fb" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_2pv()&lt;/code&gt; , but doesn't return the length too. You should usually use the macro wrapper &lt;code&gt;SvPV_nolen(sv)&lt;/code&gt; instead.</source>
          <target state="translated">마찬가지로 &lt;code&gt;sv_2pv()&lt;/code&gt; ,하지만 너무 길이를 반환하지 않습니다. 일반적으로 매크로 래퍼 &lt;code&gt;SvPV_nolen(sv)&lt;/code&gt; 대신 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e28ad4ddf0b006c6eedf3f81dcaf16c9a74e085e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_catpv&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">&lt;code&gt;sv_catpv&lt;/code&gt; 와 마찬가지로 'set'마술도 처리합니다.</target>
        </trans-unit>
        <trans-unit id="74ec50e9ddcc0b0b4bd0d08a497824bb0da8c599" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_catpv&lt;/code&gt; but doesn't process magic.</source>
          <target state="translated">&lt;code&gt;sv_catpv&lt;/code&gt; 와 비슷 하지만 마술을 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="96301ae15c375b77c0b44d75ba25e64a78136a72" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_catpvf&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">&lt;code&gt;sv_catpvf&lt;/code&gt; 와 마찬가지로 'set'마술도 처리합니다.</target>
        </trans-unit>
        <trans-unit id="8dbd5c1c6aa34bdcc67b11a771b5ad797b082fb9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_catpvn&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">&lt;code&gt;sv_catpvn&lt;/code&gt; 과 마찬가지로 'set'마술도 처리합니다.</target>
        </trans-unit>
        <trans-unit id="52a1bc2daa3eca49de27291192d60d01346616bc" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_catpvn&lt;/code&gt; , but takes a literal string instead of a string/length pair.</source>
          <target state="translated">&lt;code&gt;sv_catpvn&lt;/code&gt; 과 비슷 하지만 문자열 / 길이 쌍 대신 리터럴 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1e9ddae012626cb7e4439d9980907c822af4371b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_catpvn&lt;/code&gt; but doesn't process magic.</source>
          <target state="translated">&lt;code&gt;sv_catpvn&lt;/code&gt; 과 비슷 하지만 마술을 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="56485c39e91b575f9eb207ecfc300725f3983593" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_catpvn_flags&lt;/code&gt; , but takes a literal &lt;code&gt;NUL&lt;/code&gt; -terminated string instead of a string/length pair.</source>
          <target state="translated">&lt;code&gt;sv_catpvn_flags&lt;/code&gt; 와 유사 하지만 문자열 / 길이 쌍 대신 리터럴 &lt;code&gt;NUL&lt;/code&gt; 종료 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7f05c96d8dfa46b087685cde4a872c91ee4af9a0" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_catpvn_mg&lt;/code&gt; , but takes a literal string instead of a string/length pair.</source>
          <target state="translated">&lt;code&gt;sv_catpvn_mg&lt;/code&gt; 와 비슷 하지만 문자열 / 길이 쌍 대신 리터럴 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="58d239fc60878c8dca9fcf1e90342df6ee45eef1" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_catpvn_nomg&lt;/code&gt; , but takes a literal string instead of a string/length pair.</source>
          <target state="translated">&lt;code&gt;sv_catpvn_nomg&lt;/code&gt; 와 비슷 하지만 문자열 / 길이 쌍 대신 리터럴 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8fccee46cd5a2dbdef0b3ef34ed13318240c0cba" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_catsv&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">&lt;code&gt;sv_catsv&lt;/code&gt; 와 마찬가지로 'set'마술도 처리합니다.</target>
        </trans-unit>
        <trans-unit id="4126df4d71505019e5bb56c7d0ec65e860e57dbf" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_catsv&lt;/code&gt; but doesn't process magic.</source>
          <target state="translated">&lt;code&gt;sv_catsv&lt;/code&gt; 와 비슷 하지만 마술을 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5d38cbaa11df45cfca68f415fbd38548adbd2370" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setiv&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">&lt;code&gt;sv_setiv&lt;/code&gt; 와 마찬가지로 'set'마술도 처리합니다.</target>
        </trans-unit>
        <trans-unit id="fb5a47bbf6d640fdec1cfafd760bfcac50991da5" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setnv&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">&lt;code&gt;sv_setnv&lt;/code&gt; 처럼 'set'마술도 처리합니다.</target>
        </trans-unit>
        <trans-unit id="5d50840cdec742cb9632278831faf80f40688dc0" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setpv&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">&lt;code&gt;sv_setpv&lt;/code&gt; 와 마찬가지로 'set'마술도 처리합니다.</target>
        </trans-unit>
        <trans-unit id="b56d7c6489caae9851ec3dcbcf0456ce3751a5c3" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setpvf&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">&lt;code&gt;sv_setpvf&lt;/code&gt; 와 마찬가지로 'set'마술도 처리합니다.</target>
        </trans-unit>
        <trans-unit id="cc0fa3335ee153a3cf62cbff610e08349e8ad4b2" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setpviv&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">&lt;code&gt;sv_setpviv&lt;/code&gt; 와 마찬가지로 'set'마술도 처리합니다.</target>
        </trans-unit>
        <trans-unit id="60536ff4b89cb5040f19feec4be6721d10632d63" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setpvn&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">&lt;code&gt;sv_setpvn&lt;/code&gt; 과 마찬가지로 'set'마술도 처리합니다.</target>
        </trans-unit>
        <trans-unit id="550ac76e7931e655b1382b031643a9cb5f52950b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setpvn&lt;/code&gt; , but takes a literal string instead of a string/length pair.</source>
          <target state="translated">&lt;code&gt;sv_setpvn&lt;/code&gt; 과 비슷 하지만 문자열 / 길이 쌍 대신 리터럴 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4532add555cdc643bf47f76523943ddddd111761" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setpvn_mg&lt;/code&gt; , but takes a literal string instead of a string/length pair.</source>
          <target state="translated">&lt;code&gt;sv_setpvn_mg&lt;/code&gt; 와 비슷 하지만 문자열 / 길이 쌍 대신 리터럴 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="87ab2d21a73ed79e392dc24ffd68bc21b0539241" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setref_pvn&lt;/code&gt; , but takes a literal string instead of a string/length pair.</source>
          <target state="translated">&lt;code&gt;sv_setref_pvn&lt;/code&gt; 과 유사 하지만 문자열 / 길이 쌍 대신 리터럴 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ab2af716b65ba49b4f611a8f9a63df24afbfd34e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setsv&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">&lt;code&gt;sv_setsv&lt;/code&gt; 와 마찬가지로 'set'마술도 처리합니다.</target>
        </trans-unit>
        <trans-unit id="029cf42c4714d829664184f54a69a5ea13d859b0" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setsv&lt;/code&gt; but doesn't process magic.</source>
          <target state="translated">&lt;code&gt;sv_setsv&lt;/code&gt; 처럼 하지만 마술을 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bae58ef52e0fd2638f20a33b2c2ee3d70d45b7c9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_setuv&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">&lt;code&gt;sv_setuv&lt;/code&gt; 와 마찬가지로 'set'마법도 처리합니다.</target>
        </trans-unit>
        <trans-unit id="edc41b001c50d7d45a00cf8022d9c1f06a67020a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_usepvn&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">&lt;code&gt;sv_usepvn&lt;/code&gt; 과 마찬가지로 'set'마술도 처리합니다.</target>
        </trans-unit>
        <trans-unit id="4287363f537b02349404ef50aa3650a2da519053" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_vcatpvf&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">&lt;code&gt;sv_vcatpvf&lt;/code&gt; 와 마찬가지로 'set'마술도 처리합니다.</target>
        </trans-unit>
        <trans-unit id="14adf015575fe99f6c00f91da82a21970e20b8bd" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sv_vsetpvf&lt;/code&gt; , but also handles 'set' magic.</source>
          <target state="translated">&lt;code&gt;sv_vsetpvf&lt;/code&gt; 와 마찬가지로 'set'마술도 처리합니다.</target>
        </trans-unit>
        <trans-unit id="d4ce5b4a9c5792e4e3d807965bc2f0706dc489a6" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;todo()&lt;/code&gt; but only returns the value of &lt;code&gt;$TODO&lt;/code&gt; ignoring &lt;code&gt;todo_start()&lt;/code&gt; .</source>
          <target state="translated">마찬가지로 &lt;code&gt;todo()&lt;/code&gt; 만 값 반환 &lt;code&gt;$TODO&lt;/code&gt; 무시 &lt;code&gt;todo_start()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="824220de4c99cc183f3e468cfbca9236675ff6fd" translate="yes" xml:space="preserve">
          <source>Like C, Perl does a certain amount of expression evaluation at compile time whenever it determines that all arguments to an operator are static and have no side effects. In particular, string concatenation happens at compile time between literals that don't do variable substitution. Backslash interpolation also happens at compile time. You can say</source>
          <target state="translated">C와 마찬가지로 Perl은 연산자에 대한 모든 인수가 정적이며 부작용이없는 것으로 판별 될 때마다 컴파일시 특정 양의 표현식 평가를 수행합니다. 특히 문자열 연결은 변수 대체를 수행하지 않는 리터럴 사이에서 컴파일 타임에 발생합니다. 백 슬래시 보간도 컴파일 타임에 발생합니다. 당신은 말할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="13593327ac22cf57826e7691f4f7f418be9cc890" translate="yes" xml:space="preserve">
          <source>Like CPAN::Bundle::inst_file, but returns the $VERSION</source>
          <target state="translated">CPAN :: Bundle :: inst_file과 유사하지만 $ VERSION을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="180b470a6637521531543b80ac419cbc37898af4" translate="yes" xml:space="preserve">
          <source>Like Open3 but without STDERR capture.</source>
          <target state="translated">STDERR 캡처는 없지만 Open3과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="2a63fd6efd31d5a247539ef7d4f8ae9b22c58256" translate="yes" xml:space="preserve">
          <source>Like PERLPREFIX, but only for the site install locations.</source>
          <target state="translated">PERLPREFIX와 유사하지만 사이트 설치 위치에만 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="991d27f54f9be6d1ccfe86b4d87c281614bb46a9" translate="yes" xml:space="preserve">
          <source>Like PERLPREFIX, but only for the vendor install locations.</source>
          <target state="translated">PERLPREFIX와 유사하지만 공급 업체 설치 위치에만 해당합니다.</target>
        </trans-unit>
        <trans-unit id="3763cf6a811e93d689892e612d95e5287de00f17" translate="yes" xml:space="preserve">
          <source>Like PERLRUN, except it uses FULLPERL.</source>
          <target state="translated">FULLPERL을 사용한다는 점을 제외하고 PERLRUN과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8dff3350726fa7fbd1b6410bcef4d0a73c7217e0" translate="yes" xml:space="preserve">
          <source>Like PERLRUNINST, except it uses FULLPERL.</source>
          <target state="translated">PERLRUNINST와 마찬가지로 FULLPERL을 사용한다는 점만 다릅니다.</target>
        </trans-unit>
        <trans-unit id="5841126e64b3c89df76665c26ca814c87d8e1ffb" translate="yes" xml:space="preserve">
          <source>Like PREFIX, it sets several INSTALL* attributes at once. Unlike PREFIX it is easy to predict where the module will end up. The installation pattern looks like this:</source>
          <target state="translated">PREFIX와 마찬가지로 여러 INSTALL * 속성을 한 번에 설정합니다. PREFIX와 달리 모듈의 위치를 ​​쉽게 예측할 수 있습니다. 설치 패턴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3eac640353c06a496dbb32cf64186b352fd16578" translate="yes" xml:space="preserve">
          <source>Like T_REFREF, except it does strict type checking (inheritance is not supported).</source>
          <target state="translated">T_REFREF와 마찬가지로 엄격한 유형 검사를 수행합니다 (상속은 지원되지 않음).</target>
        </trans-unit>
        <trans-unit id="b94e5c472f080d505351ce0495c57a8957e2a984" translate="yes" xml:space="preserve">
          <source>Like Test::More's &lt;code&gt;is()&lt;/code&gt; . Checks if &lt;code&gt;$got == $expected&lt;/code&gt; . This is the numeric version.</source>
          <target state="translated">Test :: More 's &lt;code&gt;is()&lt;/code&gt; 처럼 . &lt;code&gt;$got == $expected&lt;/code&gt; 인지 확인합니다 . 이것은 숫자 버전입니다.</target>
        </trans-unit>
        <trans-unit id="cc96ef3fc2347f9c271af1895e169a768a31a74a" translate="yes" xml:space="preserve">
          <source>Like Test::More's &lt;code&gt;is()&lt;/code&gt; . Checks if &lt;code&gt;$got eq $expected&lt;/code&gt; . This is the string version.</source>
          <target state="translated">Test :: More 's &lt;code&gt;is()&lt;/code&gt; 처럼 . &lt;code&gt;$got eq $expected&lt;/code&gt; 인지 확인합니다 . 이것은 문자열 버전입니다.</target>
        </trans-unit>
        <trans-unit id="f7f7c9b4de7f16b968c9df459ba87fa3286f45be" translate="yes" xml:space="preserve">
          <source>Like UTF-8, UTF-16 is a variable-width encoding, but where UTF-8 uses 8-bit code units, UTF-16 uses 16-bit code units. All code points occupy either 2 or 4 bytes in UTF-16: code points &lt;code&gt;U+0000..U+FFFF&lt;/code&gt; are stored in a single 16-bit unit, and code points &lt;code&gt;U+10000..U+10FFFF&lt;/code&gt; in two 16-bit units. The latter case is using</source>
          <target state="translated">UTF-8과 마찬가지로 UTF-16은 가변 너비 인코딩이지만 UTF-8이 8 비트 코드 단위를 사용하는 경우 UTF-16은 16 비트 코드 단위를 사용합니다. 모든 코드 포인트는 UTF-16에서 2 또는 4 바이트를 차지합니다. 코드 포인트 &lt;code&gt;U+0000..U+FFFF&lt;/code&gt; 는 단일 16 비트 단위로 저장되고 코드 포인트 &lt;code&gt;U+10000..U+10FFFF&lt;/code&gt; 는 2 개의 16 비트로 저장됩니다. 단위. 후자의 경우는</target>
        </trans-unit>
        <trans-unit id="8dbb04c45e23e298185620fabadd06b7455bdd6a" translate="yes" xml:space="preserve">
          <source>Like UTF-8, but EBCDIC-safe, in the way that UTF-8 is ASCII-safe. This means that all the basic characters (which includes all those that have ASCII equivalents (like &lt;code&gt;&quot;A&quot;&lt;/code&gt; , &lt;code&gt;&quot;0&quot;&lt;/code&gt; , &lt;code&gt;&quot;%&quot;&lt;/code&gt; ,</source>
          <target state="translated">UTF-8과 마찬가지로 EBCDIC 안전하지만 UTF-8은 ASCII 안전 방식입니다. 이는 모든 기본 문자 (예 : &lt;code&gt;&quot;A&quot;&lt;/code&gt; , &lt;code&gt;&quot;0&quot;&lt;/code&gt; , &lt;code&gt;&quot;%&quot;&lt;/code&gt; 와 같은 ASCII 문자를 가진 모든 문자를 포함 함 ,</target>
        </trans-unit>
        <trans-unit id="6834a3fade58397a1a46bf4fd2e951ded5a49d5e" translate="yes" xml:space="preserve">
          <source>Like a forked process, but without &lt;b&gt;fork&lt;/b&gt;&amp;rsquo;s inherent memory protection. A thread is lighter weight than a full process, in that a process could have multiple threads running around in it, all fighting over the same process&amp;rsquo;s memory space unless steps are taken to protect threads from one another.</source>
          <target state="translated">포크 프로세스와 같지만 &lt;b&gt;포크&lt;/b&gt; 의 고유 메모리 보호 기능은 없습니다. 스레드는 전체 프로세스보다 가볍습니다. 프로세스에서 여러 스레드가 실행될 수 있기 때문에 스레드를 서로 보호하기위한 단계가 수행되지 않는 한 모든 프로세스가 동일한 프로세스의 메모리 공간에서 싸우게됩니다.</target>
        </trans-unit>
        <trans-unit id="5e2266dcab58f5b4cb8dc0bb09fd899c041599a2" translate="yes" xml:space="preserve">
          <source>Like all Perl character operations, length() normally deals in logical characters, not physical bytes. For how many bytes a string encoded as UTF-8 would take up, use &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length(Encode::encode_utf8(EXPR))&lt;/a&gt;&lt;/code&gt; (you'll have to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Encode&lt;/code&gt; first). See &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; and &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;.</source>
          <target state="translated">모든 Perl 문자 연산과 마찬가지로 length ()는 일반적으로 물리 바이트가 아닌 논리 문자를 처리합니다. UTF-8로 인코딩 된 문자열이 차지하는 바이트 수는 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length(Encode::encode_utf8(EXPR))&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Encode&lt;/code&gt; 먼저 사용해야 함 ). &lt;a href=&quot;encode&quot;&gt;인코딩&lt;/a&gt; 및 &lt;a href=&quot;perlunicode&quot;&gt;perlunicode를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="78626057c138b9f0db027cda4d5b95c4d7adde63" translate="yes" xml:space="preserve">
          <source>Like all Perl character operations, length() normally deals in logical characters, not physical bytes. For how many bytes a string encoded as UTF-8 would take up, use &lt;code&gt;&lt;a href=&quot;length&quot;&gt;length(Encode::encode_utf8(EXPR))&lt;/a&gt;&lt;/code&gt; (you'll have to &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; Encode&lt;/code&gt; first). See &lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt; and &lt;a href=&quot;../perlunicode&quot;&gt;perlunicode&lt;/a&gt;.</source>
          <target state="translated">모든 Perl 문자 연산과 마찬가지로 length ()는 일반적으로 물리 바이트가 아닌 논리 문자를 처리합니다. UTF-8로 인코딩 된 문자열이 차지하는 바이트 수는 &lt;code&gt;&lt;a href=&quot;length&quot;&gt;length(Encode::encode_utf8(EXPR))&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; Encode&lt;/code&gt; 먼저 사용해야 함 ). &lt;a href=&quot;../encode&quot;&gt;인코딩&lt;/a&gt; 및 &lt;a href=&quot;../perlunicode&quot;&gt;perlunicode를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b262f2d7a83664abc258a4d3c715339214f8a1b0" translate="yes" xml:space="preserve">
          <source>Like chapters in many books, all top-level Perl source files (along with a few others here and there) begin with an epigrammatic inscription that alludes, indirectly and metaphorically, to the material you're about to read.</source>
          <target state="translated">많은 서적의 장들처럼, 모든 최상위 레벨 Perl 소스 파일 (여기서 나 다른 것들과 함께)은 읽고 자하는 자료를 간접적으로 그리고 은유 적으로 암시하는 비유적인 비문으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="c0d2dcb20ae20f18b840f20ba286a29e5869333a" translate="yes" xml:space="preserve">
          <source>Like config_sh() but returns, as a list, only the config entries who's names match the $regex.</source>
          <target state="translated">config_sh ()와 비슷하지만 이름을 가진 구성 항목 만 $ regex와 일치하는 목록으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f227f0321acaa416e145c904a4d8ec45847b8d64" translate="yes" xml:space="preserve">
          <source>Like expand, but returns objects of the appropriate type, i.e. CPAN::Bundle objects for bundles, CPAN::Module objects for modules, and CPAN::Distribution objects for distributions. Note: it does not expand to CPAN::Author objects.</source>
          <target state="translated">확장과 유사하지만 적절한 유형의 오브젝트 (예 : 번들의 경우 CPAN :: Bundle 오브젝트, 모듈의 경우 CPAN :: Module 오브젝트 및 분배의 CPAN :: Distribution 오브젝트)를 리턴합니다. 참고 : CPAN :: Author 오브젝트로 확장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f385d834d0c261050be5f51ac316a9238769d175" translate="yes" xml:space="preserve">
          <source>Like many languages, Perl provides for user-defined subroutines. These may be located anywhere in the main program, loaded in from other files via the &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; keywords, or generated on the fly using &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; or anonymous subroutines. You can even call a function indirectly using a variable containing its name or a CODE reference.</source>
          <target state="translated">많은 언어와 마찬가지로 Perl은 사용자 정의 서브 루틴을 제공합니다. 이것들은 메인 프로그램의 어느 위치 에나 있거나 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 키워드 를 통해 다른 파일에서로드 되거나 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 또는 anonymous 서브 루틴을 사용하여 즉시 생성 될 수 있습니다 . 이름이나 CODE 참조를 포함하는 변수를 사용하여 함수를 간접적으로 호출 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3bb042c0a5ea5166342c8b0ad6d2f8a2141fbc4" translate="yes" xml:space="preserve">
          <source>Like octal escapes, there are two forms of hexadecimal escapes, but both start with the sequence &lt;code&gt;\x&lt;/code&gt; . This is followed by either exactly two hexadecimal digits forming a number, or a hexadecimal number of arbitrary length surrounded by curly braces. The hexadecimal number is the code point of the character you want to express.</source>
          <target state="translated">8 진 이스케이프와 같이 16 진 이스케이프에는 두 가지 형태가 있지만 모두 &lt;code&gt;\x&lt;/code&gt; 시퀀스로 시작합니다 . 그 뒤에 숫자를 형성하는 정확히 두 개의 16 진 숫자 또는 중괄호로 둘러싸인 16 진수의 임의 길이가옵니다. 16 진수는 표현하려는 문자의 코드 포인트입니다.</target>
        </trans-unit>
        <trans-unit id="ea93e43cdaa94011eb7f20af4624fc89df3b75e2" translate="yes" xml:space="preserve">
          <source>Like other pragmas (&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; , for example), features have a lexical effect. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature qw(foo)&lt;/code&gt; will only make the feature &quot;foo&quot; available from that point to the end of the enclosing block.</source>
          <target state="translated">다른 pragma와 마찬가지로 ( 예 : &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; ) 피처는 어휘 효과가 있습니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature qw(foo)&lt;/code&gt; 만을 포함하는 블록의 끝까지를 가리키는에서 사용할 수있는 기능 &quot;foo는&quot;을 만들 것입니다.</target>
        </trans-unit>
        <trans-unit id="f84dcad78456fba45a7cd86383d5b5d51df6ab7d" translate="yes" xml:space="preserve">
          <source>Like property names, there is typically at least a short name for each such property-value, and a long name. If you know any name of the property-value (which you can get by &lt;a href=&quot;#prop_values()&quot;&gt;prop_values()&lt;/a&gt;, you can use &lt;code&gt;prop_value_aliases&lt;/code&gt; () to get the long name (when called in scalar context), or a list of all the names, with the short name in the 0th element, the long name in the next element, and any other synonyms in the remaining elements, in no particular order, except that any all-numeric synonyms will be last.</source>
          <target state="translated">속성 이름과 마찬가지로 일반적으로 이러한 각 속성 값의 짧은 이름과 긴 이름이 있습니다. &lt;a href=&quot;#prop_values()&quot;&gt;prop_values ​​()로&lt;/a&gt; 얻을 수있는 특성 값의 이름을 알고 있으면 &lt;code&gt;prop_value_aliases&lt;/code&gt; ()를 사용 하여 긴 이름 (스칼라 컨텍스트에서 호출 될 때) 또는 짧은 이름을 가진 모든 이름 목록을 가져올 수 있습니다. 모든 숫자의 동의어가 마지막이라는 것을 제외하고는 0 번째 요소의 이름, 다음 요소의 긴 이름 및 나머지 요소의 다른 동의어는 특별한 순서가 없습니다.</target>
        </trans-unit>
        <trans-unit id="199b34f10e1b7c8e7aa443166b2eaa7617b87f12" translate="yes" xml:space="preserve">
          <source>Like sv_copypv, but doesn't invoke get magic first.</source>
          <target state="translated">sv_copypv와 비슷하지만 먼저 마법을 얻지 마십시오.</target>
        </trans-unit>
        <trans-unit id="fa3c089315a35ab69068f31035a53de1242b1f4a" translate="yes" xml:space="preserve">
          <source>Like sv_utf8_upgrade, but doesn't do magic on &lt;code&gt;sv&lt;/code&gt; .</source>
          <target state="translated">sv_utf8_upgrade와 비슷하지만 &lt;code&gt;sv&lt;/code&gt; 에서는 마술을 사용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="491235f5863c419144ac401911f4034bbb235829" translate="yes" xml:space="preserve">
          <source>Like sv_utf8_upgrade_flags, but has an additional parameter &lt;code&gt;extra&lt;/code&gt; , which is the number of unused bytes the string of 'sv' is guaranteed to have free after it upon return. This allows the caller to reserve extra space that it intends to fill, to avoid extra grows.</source>
          <target state="translated">sv_utf8_upgrade_flags와 유사하지만 추가 매개 변수 &lt;code&gt;extra&lt;/code&gt; 가 있습니다 .이 매개 변수 는 사용되지 않은 바이트 수이며 'sv'문자열은 반환 후 여유 공간을 갖습니다. 이를 통해 발신자는 추가 증가를 피하기 위해 채울 추가 공간을 확보 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b473e807de38ef5585564f3999d8d88c0c2f9ac9" translate="yes" xml:space="preserve">
          <source>Like the</source>
          <target state="translated">처럼</target>
        </trans-unit>
        <trans-unit id="8e09e117230303a3e7e1540483add81bffa29662" translate="yes" xml:space="preserve">
          <source>Like the &lt;a href=&quot;#Unicode-Properties&quot;&gt;Unicode properties&lt;/a&gt;, most of the POSIX properties match the same regardless of whether case-insensitive (&lt;code&gt;/i&lt;/code&gt;) matching is in effect or not. The two exceptions are &lt;code&gt;[:upper:]&lt;/code&gt; and &lt;code&gt;[:lower:]&lt;/code&gt;. Under &lt;code&gt;/i&lt;/code&gt;, they each match the union of &lt;code&gt;[:upper:]&lt;/code&gt; and &lt;code&gt;[:lower:]&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Unicode-Properties&quot;&gt;유니 코드 속성&lt;/a&gt; 과 마찬가지로 대부분의 POSIX 속성 은 대 &lt;code&gt;/i&lt;/code&gt; 소문자를 구분하지 않는 ( / i ) 일치 여부에 관계없이 동일하게 일치합니다 . 두 가지 예외는 &lt;code&gt;[:upper:]&lt;/code&gt; 및 &lt;code&gt;[:lower:]&lt;/code&gt; 입니다. 아래에서 &lt;code&gt;/i&lt;/code&gt; 의, 그들은 각각의 일치 노조 &lt;code&gt;[:upper:]&lt;/code&gt; 와 &lt;code&gt;[:lower:]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2bf3175a68d636ecf9925b34e6ff6a44a156b660" translate="yes" xml:space="preserve">
          <source>Like the existing DBM Filter functionality, this module arranges for the &lt;code&gt;$_&lt;/code&gt; variable to be populated with the key or value that a filter will check. This usually means that most DBM filters tend to be very short.</source>
          <target state="translated">기존 DBM 필터 기능과 마찬가지로이 모듈은 &lt;code&gt;$_&lt;/code&gt; 변수가 필터에서 확인할 키 또는 값으로 채워지도록 정렬합니다 . 이것은 대개 대부분의 DBM 필터가 매우 짧은 경향이 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f3cce6c08fa97ca0be477f0721fb283a52d10b11" translate="yes" xml:space="preserve">
          <source>Like the flattened incoming parameter list, the return list is also flattened on return. So all you have managed to do here is stored everything in &lt;code&gt;@a&lt;/code&gt; and made &lt;code&gt;@b&lt;/code&gt; empty. See &lt;a href=&quot;#Pass-by-Reference&quot;&gt;Pass by Reference&lt;/a&gt; for alternatives.</source>
          <target state="translated">병합 된 수신 매개 변수 목록과 마찬가지로 반환 목록도 반환시 병합됩니다. 따라서 여기에서 관리 한 모든 것은 &lt;code&gt;@a&lt;/code&gt; 에 모든 것을 저장 하고 &lt;code&gt;@b&lt;/code&gt; 를 비워 두었 습니다. 대안 &lt;a href=&quot;#Pass-by-Reference&quot;&gt;은 참조로 전달&lt;/a&gt; 을 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="afd075e21a0c597db0ab2821856e88ceb5961fd6" translate="yes" xml:space="preserve">
          <source>Like the normal &lt;code&gt;&lt;a href=&quot;../functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt;, except it reports according to your &lt;code&gt;level()&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;level()&lt;/code&gt; 에 따라보고하는 것을 제외하고 는 일반 &lt;code&gt;&lt;a href=&quot;../functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="200195811a3c205ce0d87247b5aab2a0a4c65d8e" translate="yes" xml:space="preserve">
          <source>Like their AV counterparts, &lt;code&gt;hv_clear&lt;/code&gt; deletes all the entries in the hash table but does not actually delete the hash table. The &lt;code&gt;hv_undef&lt;/code&gt; deletes both the entries and the hash table itself.</source>
          <target state="translated">AV 대응 물과 마찬가지로 &lt;code&gt;hv_clear&lt;/code&gt; 는 해시 테이블의 모든 항목을 삭제하지만 실제로 해시 테이블은 삭제하지 않습니다. &lt;code&gt;hv_undef&lt;/code&gt; 는 항목 및 해시 테이블 자체를 모두 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="e82abff5c6c10139b1928c82bbe909480a69e24a" translate="yes" xml:space="preserve">
          <source>Likely to occur for a perl binary that was not properly installed. Correct by conducting a proper installation.</source>
          <target state="translated">제대로 설치되지 않은 펄 바이너리에 대해 발생했을 가능성이 있습니다. 올바르게 설치하여 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="5195e8e0970c4f356d29e2dc5df49c188d971cda" translate="yes" xml:space="preserve">
          <source>Likely to occur for a perl library tree that was not properly installed. Correct by conducting a proper installation.</source>
          <target state="translated">제대로 설치되지 않은 펄 라이브러리 트리에서 발생할 수 있습니다. 올바르게 설치하여 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="5a2da7a5f3225b97435c319fa8a430eb74f8dc5d" translate="yes" xml:space="preserve">
          <source>Likely to occur for a perl that was not properly installed. Correct by conducting a proper installation.</source>
          <target state="translated">제대로 설치되지 않은 펄이 발생할 가능성이 높습니다. 올바르게 설치하여 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="d87358f4e2ddd3816d7f56b79a06ec5e87b2b467" translate="yes" xml:space="preserve">
          <source>Likely, you should use this only for debugging anyway.</source>
          <target state="translated">어쨌든 디버깅을 위해서만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="5e2ad79894aa707c67ca50ba4a61384758d0873a" translate="yes" xml:space="preserve">
          <source>Likewise on all other OS levels. Then execute the following command, and fill in its choices</source>
          <target state="translated">다른 모든 OS 수준에서도 마찬가지입니다. 그런 다음 다음 명령을 실행하고 선택을 채우십시오.</target>
        </trans-unit>
        <trans-unit id="907735ad554b354d50508dedc314aa895182b86c" translate="yes" xml:space="preserve">
          <source>Likewise the call in:</source>
          <target state="translated">마찬가지로 전화 :</target>
        </trans-unit>
        <trans-unit id="65ed6c9aec28bb7eb33858993a0680b4d9a0419f" translate="yes" xml:space="preserve">
          <source>Likewise,</source>
          <target state="translated">Likewise,</target>
        </trans-unit>
        <trans-unit id="c02c1537f9374adb04ab89c0867bc362683b8992" translate="yes" xml:space="preserve">
          <source>Likewise, &lt;code&gt;o conf KEY &lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt; LIST&lt;/code&gt; passes the LIST to the corresponding splice command.</source>
          <target state="translated">마찬가지로, &lt;code&gt;o conf KEY &lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt; LIST&lt;/code&gt; 는 해당 splice 명령에 LIST를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="886e8885f96bc8b4a5e209980f534b6f61eacaf4" translate="yes" xml:space="preserve">
          <source>Likewise, Filter::Simple is also smart enough to Do The Right Thing if you use Exporter:</source>
          <target state="translated">마찬가지로 Filter :: Simple은 Exporter를 사용하는 경우 올바른 일을 할만 큼 똑똑합니다.</target>
        </trans-unit>
        <trans-unit id="160bda2110bdb1f3a950ddf5accf544eb0786069" translate="yes" xml:space="preserve">
          <source>Likewise, declaring any variables with the &lt;code&gt;:Loud&lt;/code&gt; attribute within the package:</source>
          <target state="translated">마찬가지로 패키지 내에서 &lt;code&gt;:Loud&lt;/code&gt; 속성을 사용하여 변수를 선언 합니다.</target>
        </trans-unit>
        <trans-unit id="d6adecc01f3598897c4c9f089b3d20664151e435" translate="yes" xml:space="preserve">
          <source>Likewise, the &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; formats pack a string that's that many bits long. Each such format generates 1 bit of the result. These are typically followed by a repeat count like &lt;code&gt;B8&lt;/code&gt; or &lt;code&gt;B64&lt;/code&gt; .</source>
          <target state="translated">마찬가지로, &lt;code&gt;b&lt;/code&gt; 및 &lt;code&gt;B&lt;/code&gt; 형식은 많은 비트 길이의 문자열을 묶습니다. 이러한 각 형식은 1 비트의 결과를 생성합니다. 이들은 일반적으로 &lt;code&gt;B8&lt;/code&gt; 또는 &lt;code&gt;B64&lt;/code&gt; 와 같은 반복 횟수를 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="b0cbdf24c8a85f92cd82aa3a094249d6de02bf8f" translate="yes" xml:space="preserve">
          <source>Likewise, to create a class hierarchy in which every initializer inherited by a new object is invoked:</source>
          <target state="translated">마찬가지로, 새 객체에 의해 상속 된 모든 이니셜 라이저가 호출되는 클래스 계층 구조를 작성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="70bd46189954c3a64d496328cd96089f6f4f9542" translate="yes" xml:space="preserve">
          <source>Likewise, when using the &lt;code&gt;AutoSplit&lt;/code&gt; module, try to keep your functions to 8.3 naming and case-insensitive conventions; or, at the least, make it so the resulting files have a unique (case-insensitively) first 8 characters.</source>
          <target state="translated">마찬가지로, &lt;code&gt;AutoSplit&lt;/code&gt; 모듈을 사용할 때는 함수의 이름을 8.3 이름과 대소 문자를 구분하지 않는 규칙으로 유지하십시오. 또는 결과 파일에 고유 한 (대소 문자를 구분하지 않는) 처음 8자를 갖도록하십시오.</target>
        </trans-unit>
        <trans-unit id="a73edeb8158f532278a32208dcd47fe3a3d7f86f" translate="yes" xml:space="preserve">
          <source>Limit recursion depth to N levels when dumping structures. Negative values are interpreted as infinity. Default: infinity.</source>
          <target state="translated">구조물을 덤프 할 때 재귀 깊이를 N 수준으로 제한하십시오. 음수 값은 무한대로 해석됩니다. 기본값 : 무한대.</target>
        </trans-unit>
        <trans-unit id="2d1726e76688b7950a8162233fc1e17657b1edf0" translate="yes" xml:space="preserve">
          <source>Limitation with regard to &lt;code&gt;_&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;_&lt;/code&gt; 에 대한 제한</target>
        </trans-unit>
        <trans-unit id="55330d97525455296ae0e4b51ff25bb7abdac5c6" translate="yes" xml:space="preserve">
          <source>Limitation with regard to _</source>
          <target state="translated">_에 대한 제한</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="72e092ad529e2081e851e343be794f7609f24237" translate="yes" xml:space="preserve">
          <source>Limits of time_t</source>
          <target state="translated">time_t의 한계</target>
        </trans-unit>
        <trans-unit id="6234e2f414d2b26733b9fd769dba962a7fcc3692" translate="yes" xml:space="preserve">
          <source>Limits on Numbers of Open Files on Solaris.</source>
          <target state="translated">Solaris에서 열린 파일 수에 대한 제한.</target>
        </trans-unit>
        <trans-unit id="a139366c419ef510c76cf49f4a191349fd578640" translate="yes" xml:space="preserve">
          <source>Line 1 is a macro, and its definition is dependent on your operating system. Line 3 references &lt;code&gt;PL_do_undump&lt;/code&gt; , a global variable - all global variables in Perl start with &lt;code&gt;PL_&lt;/code&gt; . This tells you whether the current running program was created with the &lt;code&gt;-u&lt;/code&gt; flag to perl and then</source>
          <target state="translated">1 행은 매크로이며 그 정의는 운영 체제에 따라 다릅니다. 3 행 은 전역 변수 인 &lt;code&gt;PL_do_undump&lt;/code&gt; 를 참조 합니다. Perl의 모든 전역 변수는 &lt;code&gt;PL_&lt;/code&gt; 로 시작 합니다. 이것은 현재 실행중인 프로그램이 &lt;code&gt;-u&lt;/code&gt; 플래그를 사용하여 perl 로 작성된 후 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="34d4d7a9a244a3d12dfe7fb244172b4a39165816" translate="yes" xml:space="preserve">
          <source>Line 1 tells us we're looking at an SV which lives at &lt;code&gt;0xa04ecbc&lt;/code&gt; in memory. SVs themselves are very simple structures, but they contain a pointer to a more complex structure. In this case, it's a PV, a structure which holds a string value, at location &lt;code&gt;0xa041450&lt;/code&gt; . Line 2 is the reference count; there are no other references to this data, so it's 1.</source>
          <target state="translated">1 행 은 메모리 에 &lt;code&gt;0xa04ecbc&lt;/code&gt; 에 있는 SV를보고 있다고 알려줍니다 . SV 자체는 매우 간단한 구조이지만 더 복잡한 구조에 대한 포인터를 포함합니다. 이 경우, 위치 &lt;code&gt;0xa041450&lt;/code&gt; 에서 문자열 값을 보유하는 구조 인 PV 입니다. 2 행은 참조 횟수입니다. 이 데이터에 대한 다른 참조는 없으므로 1입니다.</target>
        </trans-unit>
        <trans-unit id="852a5525bd0666646b8baf89f18138582eb7fb29" translate="yes" xml:space="preserve">
          <source>Line 1, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Filter::cpp&lt;/code&gt; , includes and installs the &lt;code&gt;cpp&lt;/code&gt; filter module. All source filters work this way. The use statement is compiled and executed at compile time, before any more of the file is read, and it attaches the cpp filter to the source stream behind the scenes. Now the data flow looks like this:</source>
          <target state="translated">1 행 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Filter::cpp&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하고 &lt;code&gt;cpp&lt;/code&gt; 필터 모듈을 포함하고 설치합니다 . 모든 소스 필터는이 방식으로 작동합니다. use 문은 더 많은 파일을 읽기 전에 컴파일 타임에 컴파일 및 실행되며 cpp 필터를 장면 뒤의 소스 스트림에 첨부합니다. 이제 데이터 흐름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7fe884af42f04d28c78e5fe62707a6228b47c52d" translate="yes" xml:space="preserve">
          <source>Line 10 does the actual catenation: the &lt;code&gt;Move&lt;/code&gt; macro moves a chunk of memory around: we move the string &lt;code&gt;ptr&lt;/code&gt; to the end of the PV - that's the start of the PV plus its current length. We're moving &lt;code&gt;len&lt;/code&gt; bytes of type &lt;code&gt;char&lt;/code&gt; . After doing so, we need to tell Perl we've extended the string, by altering &lt;code&gt;CUR&lt;/code&gt; to reflect the new length. &lt;code&gt;SvEND&lt;/code&gt; is a macro which gives us the end of the string, so that needs to be a &lt;code&gt;&quot;\0&quot;&lt;/code&gt; .</source>
          <target state="translated">10 행은 실제 연결을 수행합니다. &lt;code&gt;Move&lt;/code&gt; 매크로는 메모리를 움직입니다. 문자열 &lt;code&gt;ptr&lt;/code&gt; 을 PV의 끝으로 이동합니다. 즉 PV의 시작에 현재 길이를 더한 값입니다. &lt;code&gt;char&lt;/code&gt; 유형의 &lt;code&gt;len&lt;/code&gt; 바이트를 이동 합니다. 그렇게 한 후 , 새로운 길이를 반영하도록 &lt;code&gt;CUR&lt;/code&gt; 을 변경하여 Perl에게 문자열을 확장했다고 알려야 합니다. &lt;code&gt;SvEND&lt;/code&gt; 는 문자열의 끝을 알려주는 매크로이므로 &lt;code&gt;&quot;\0&quot;&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="0d7912d365642f9e0b2b596d940dc9036620ccc8" translate="yes" xml:space="preserve">
          <source>Line 10 is the null op: this does exactly nothing. What is that doing there? If you see the null op, it's a sign that something has been optimized away after parsing. As we mentioned in &lt;a href=&quot;#Optimization&quot;&gt;Optimization&lt;/a&gt;, the optimization stage sometimes converts two operations into one, for example when fetching a scalar variable. When this happens, instead of rewriting the op tree and cleaning up the dangling pointers, it's easier just to replace the redundant operation with the null op. Originally, the tree would have looked like this:</source>
          <target state="translated">라인 10은 널 연산입니다. 정확히 아무것도하지 않습니다. 저기서 뭐하는거야? null op가 표시되면 구문 분석 후 무언가가 최적화되었다는 신호입니다. 우리가 언급했듯이&lt;a href=&quot;#Optimization&quot;&gt; Optimization&lt;/a&gt; 에서 최적화 단계는 때로는 두 개의 연산을 하나의 스칼라 변수를 가져올 때 하나로 변환합니다. 이 경우 op 트리를 다시 작성하고 매달려있는 포인터를 정리하는 대신 중복 작업을 null op로 바꾸는 것이 더 쉽습니다. 원래 나무는 다음과 같았습니다.</target>
        </trans-unit>
        <trans-unit id="264f13994058273b1e958110b35aba9f84b7d3f9" translate="yes" xml:space="preserve">
          <source>Line 13 manipulates the flags; since we've changed the PV, any IV or NV values will no longer be valid: if we have &lt;code&gt;$a=10; $a.=&quot;6&quot;;&lt;/code&gt; we don't want to use the old IV of 10. &lt;code&gt;SvPOK_only_utf8&lt;/code&gt; is a special UTF-8-aware version of &lt;code&gt;SvPOK_only&lt;/code&gt; , a macro which turns off the IOK and NOK flags and turns on POK. The final &lt;code&gt;SvTAINT&lt;/code&gt; is a macro which launders tainted data if taint mode is turned on.</source>
          <target state="translated">13 행은 플래그를 조작합니다. PV를 변경 했으므로 IV 또는 NV 값은 더 이상 유효하지 않습니다. &lt;code&gt;$a=10; $a.=&quot;6&quot;;&lt;/code&gt; 이전 IV IV 10을 사용하고 싶지 않습니다. &lt;code&gt;SvPOK_only_utf8&lt;/code&gt; 은 특수 UTF-8 인식 버전의 &lt;code&gt;SvPOK_only&lt;/code&gt; 버전으로 , IOK 및 NOK 플래그를 끄고 POK를 켜는 매크로입니다. 마지막 &lt;code&gt;SvTAINT&lt;/code&gt; 는 오염 모드가 켜져있는 경우 오염 된 데이터를 세탁 하는 매크로입니다.</target>
        </trans-unit>
        <trans-unit id="755dd87e19fd3ba2af902fab337428ef967e0ea8" translate="yes" xml:space="preserve">
          <source>Line 3 are the flags for this SV - it's OK to use it as a PV, it's a read-only SV (because it's a constant) and the data is a PV internally. Next we've got the contents of the string, starting at location &lt;code&gt;0xa0484e0&lt;/code&gt; .</source>
          <target state="translated">3 번 라인은이 SV의 플래그입니다. PV로 사용하는 것이 좋습니다. 상수이기 때문에 읽기 전용 SV이며 데이터는 내부적으로 PV입니다. 다음으로 위치에서 시작하여 문자열의 내용을 얻었습니다. &lt;code&gt;0xa0484e0&lt;/code&gt; 습니다 .</target>
        </trans-unit>
        <trans-unit id="40714861418609c0c173cdb387c1235ef584feb6" translate="yes" xml:space="preserve">
          <source>Line 4 calls a function in</source>
          <target state="translated">라인 4는 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="fce643cab9a4e3c9a722892a06301bcddec99baf" translate="yes" xml:space="preserve">
          <source>Line 5 gives us the current length of the string - note that this does &lt;b&gt;not&lt;/b&gt; include the null terminator. Line 6 is not the length of the string, but the length of the currently allocated buffer; as the string grows, Perl automatically extends the available storage via a routine called &lt;code&gt;SvGROW&lt;/code&gt; .</source>
          <target state="translated">5 행은 현재 문자열 길이를 나타 냅니다. 여기에는 null 종결자가 포함 되지 &lt;b&gt;않습니다&lt;/b&gt; . 6 행은 문자열의 길이가 아니라 현재 할당 된 버퍼의 길이입니다. 문자열이 커지면 Perl은 &lt;code&gt;SvGROW&lt;/code&gt; 라는 루틴을 통해 사용 가능한 스토리지를 자동으로 확장합니다 .</target>
        </trans-unit>
        <trans-unit id="e801a645ef8652f9762283242a90486b96636e4b" translate="yes" xml:space="preserve">
          <source>Line 5 is another variable declaration - all variable declarations start with &lt;code&gt;d&lt;/code&gt; - which pops from the top of the argument stack two NVs (hence &lt;code&gt;nn&lt;/code&gt; ) and puts them into the variables &lt;code&gt;right&lt;/code&gt; and &lt;code&gt;left&lt;/code&gt; , hence the &lt;code&gt;rl&lt;/code&gt; . These are the two operands to the addition operator. Next, we call &lt;code&gt;SETn&lt;/code&gt; to set the NV of the return value to the result of adding the two values. This done, we return - the &lt;code&gt;RETURN&lt;/code&gt; macro makes sure that our return value is properly handled, and we pass the next operator to run back to the main run loop.</source>
          <target state="translated">5 번째 줄은 또 다른 변수 선언입니다. 모든 변수 선언은 &lt;code&gt;d&lt;/code&gt; 로 시작 합니다. 인수의 상단에서 두 개의 NV (따라서 &lt;code&gt;nn&lt;/code&gt; ) 가 튀어 나와서 &lt;code&gt;right&lt;/code&gt; 과 &lt;code&gt;left&lt;/code&gt; 의 변수에 들어가 므로 &lt;code&gt;rl&lt;/code&gt; 입니다. 이들은 더하기 연산자에 대한 두 피연산자입니다. 다음으로 &lt;code&gt;SETn&lt;/code&gt; 을 호출 하여 반환 값의 NV를 두 값을 더한 결과로 설정합니다. 이 완료, 우리는 반환- &lt;code&gt;RETURN&lt;/code&gt; 매크로는 우리의 반환 값이 제대로 처리되었는지 확인합니다, 우리는 다시 메인 실행 루프 실행 다음 연산자를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="9ab0a06fa26dc1e693bbb46194cc19123ec14b86" translate="yes" xml:space="preserve">
          <source>Line 6 installs the city name into the appropriate array. &lt;code&gt;$table{$country}&lt;/code&gt; now holds a reference to the array of cities seen in that country so far. Line 6 is exactly like</source>
          <target state="translated">6 행은 도시 이름을 적절한 배열에 설치합니다. &lt;code&gt;$table{$country}&lt;/code&gt; 지금까지 해당 국가에서 본 여러 도시에 대한 참조를 보유합니다. 6 호선은 정확히</target>
        </trans-unit>
        <trans-unit id="62686b06fae48d96cf870eba5c52faaa0c94ec93" translate="yes" xml:space="preserve">
          <source>Line number that will be executed next.</source>
          <target state="translated">다음에 실행될 라인 번호.</target>
        </trans-unit>
        <trans-unit id="4c2e43f7c549f47cf9031361a83c442a60f08003" translate="yes" xml:space="preserve">
          <source>Line up corresponding items vertically.</source>
          <target state="translated">해당 항목을 세로로 정렬하십시오.</target>
        </trans-unit>
        <trans-unit id="90a0a22c457fd80684a0398fb72051a69780b70d" translate="yes" xml:space="preserve">
          <source>Line up corresponding things vertically, especially if it'd be too long to fit on one line anyway.</source>
          <target state="translated">특히 어쨌든 한 줄에 맞추기에는 너무 길면 해당하는 것을 세로로 정렬하십시오.</target>
        </trans-unit>
        <trans-unit id="fddad56552c576f0323dae03070effe7302ccb5f" translate="yes" xml:space="preserve">
          <source>Line up your transliterations when it makes sense:</source>
          <target state="translated">음역이 의미가있는 경우 음역을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="4dd6f945e5b458504f42d21fe69947944476c20f" translate="yes" xml:space="preserve">
          <source>Line wrapping to form simple paragraphs</source>
          <target state="translated">간단한 단락을 형성하는 줄 바꿈</target>
        </trans-unit>
        <trans-unit id="3c31b396df21c211f23a01f3c792334d1e4f696c" translate="yes" xml:space="preserve">
          <source>Line-by-line debugging. Causes &lt;code&gt;DB::DB()&lt;/code&gt; subroutine to be called for each statement executed. Also causes saving source code lines (like 0x400).</source>
          <target state="translated">라인 별 디버깅. 원인 &lt;code&gt;DB::DB()&lt;/code&gt; 서브 루틴이 실행 각 문이라고합니다. 또한 0x400과 같은 소스 코드 행을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="6544069544ff400a2f96a13aacecf88aefcebba3" translate="yes" xml:space="preserve">
          <source>Lines 2-4 acquire a city and country name. Line 5 looks to see if the country is already present as a key in the hash. If it's not, the program uses the &lt;code&gt;[]&lt;/code&gt; notation (&lt;b&gt;Make Rule 2&lt;/b&gt;) to manufacture a new, empty anonymous array of cities, and installs a reference to it into the hash under the appropriate key.</source>
          <target state="translated">2-4 행은 도시와 국가 이름을 얻습니다. 5 행은 국가가 이미 해시의 키로 존재하는지 확인합니다. 그렇지 않은 경우 프로그램은 &lt;code&gt;[]&lt;/code&gt; 표기법을 사용합니다 ( &lt;b&gt;규칙 2 작성).&lt;/b&gt; )을 비어있는 새 익명의 도시 배열을 작성하고 해당 키 아래의 해시에 참조를 설치합니다.</target>
        </trans-unit>
        <trans-unit id="f9204249863f9ef26ff51a8eb193e8408a39e90b" translate="yes" xml:space="preserve">
          <source>Lines 2-7 are responsible for building the structure in the first place. Here they are again:</source>
          <target state="translated">2-7 행은 처음에 구조를 짓는 책임이 있습니다. 여기 다시 있습니다 :</target>
        </trans-unit>
        <trans-unit id="de6cda1578fd7d9e7a9658f2b0c6b2f1938e7d0c" translate="yes" xml:space="preserve">
          <source>Lines are wrapped at &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; columns (default value: 76). &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; should be set to the full width of your output device. In fact, every resulting line will have length of no more than &lt;code&gt;$columns - 1&lt;/code&gt; .</source>
          <target state="translated">줄은 &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; 열에 래핑됩니다 (기본값 : 76). &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; 는 출력 장치의 전체 너비로 설정해야합니다. 실제로 모든 결과 행의 길이는 &lt;code&gt;$columns - 1&lt;/code&gt; 이하 여야 합니다.</target>
        </trans-unit>
        <trans-unit id="6b80c81ac338346fa6d5a46950a43da0e9261d9f" translate="yes" xml:space="preserve">
          <source>Linguistic tailoring for DUCET via Unicode::Collate</source>
          <target state="translated">Unicode :: Collate를 통한 DUCET의 언어 조정</target>
        </trans-unit>
        <trans-unit id="911361fa28ffec535144574ef716816f8b8cd069" translate="yes" xml:space="preserve">
          <source>Link count not updated because hard links are not quite that hard (They are sort of half-way between hard and soft links). (AmigaOS)</source>
          <target state="translated">하드 링크는 그렇게 어렵지 않기 때문에 링크 수는 업데이트되지 않습니다 (하드 링크와 소프트 링크 사이의 중간 정도입니다). (AmigaOS)</target>
        </trans-unit>
        <trans-unit id="1bd9f440f54676f1bb94923dc077847ab746b4ad" translate="yes" xml:space="preserve">
          <source>Link dynamic extensions with AddressSanitizer. You must manually specify &lt;code&gt;-shared&lt;/code&gt; because using &lt;code&gt;-Alddlflags=-shared&lt;/code&gt; will prevent Configure from setting a default value for &lt;code&gt;lddlflags&lt;/code&gt; , which usually contains &lt;code&gt;-shared&lt;/code&gt; (at least on Linux).</source>
          <target state="translated">동적 확장을 AddressSanitizer와 연결하십시오. &lt;code&gt;-Alddlflags=-shared&lt;/code&gt; 를 사용하면 Configure에서 &lt;code&gt;lddlflags&lt;/code&gt; 의 기본값을 설정하지 못하게 되므로 수동으로 &lt;code&gt;-shared&lt;/code&gt; 를 지정해야합니다. 일반적으로 &lt;code&gt;-shared&lt;/code&gt; 를 포함합니다 (적어도 Linux에서는).</target>
        </trans-unit>
        <trans-unit id="14f974c23cae7ac7ab09ab4582a91560c7102a2b" translate="yes" xml:space="preserve">
          <source>Link the perl executable with AddressSanitizer.</source>
          <target state="translated">Perl 실행 파일을 AddressSanitizer와 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="41c90512ffda6347e72f72d0a6f190da9ca1b80a" translate="yes" xml:space="preserve">
          <source>Link this text to that manual page. E.g., &lt;code&gt;L&amp;lt;Perl Error Messages|perldiag&amp;gt;&lt;/code&gt;</source>
          <target state="translated">이 텍스트를 해당 매뉴얼 페이지에 연결하십시오. 예를 들어 &lt;code&gt;L&amp;lt;Perl Error Messages|perldiag&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="da1dd85543ffc6fef88aec54ac7001cdb21f6577" translate="yes" xml:space="preserve">
          <source>Link this text to that section in that manual page. E.g., &lt;code&gt;L&amp;lt;postfix &quot;if&quot;|perlsyn/&quot;Statement Modifiers&quot;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">이 텍스트를 해당 매뉴얼 페이지의 해당 섹션에 연결하십시오. 예를 들어 &lt;code&gt;L&amp;lt;postfix &quot;if&quot;|perlsyn/&quot;Statement Modifiers&quot;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0a893b38edbd5af20fcd220578252e31f67b32a6" translate="yes" xml:space="preserve">
          <source>Link this text to that section in this manual page. E.g., &lt;code&gt;L&amp;lt;the various attributes|/&quot;Member Data&quot;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">이 텍스트를이 매뉴얼 페이지의 해당 섹션에 연결하십시오. 예 : &lt;code&gt;L&amp;lt;the various attributes|/&quot;Member Data&quot;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a75b0dcbc63f378ca4b7ba049d880c48c223d9a" translate="yes" xml:space="preserve">
          <source>Link to a Perl manual page (e.g., &lt;code&gt;L&amp;lt;Net::Ping&amp;gt;&lt;/code&gt; ). Note that &lt;code&gt;name&lt;/code&gt; should not contain spaces. This syntax is also occasionally used for references to Unix man pages, as in &lt;code&gt;L&amp;lt;crontab(5)&amp;gt;&lt;/code&gt; .</source>
          <target state="translated">Perl 매뉴얼 페이지에 링크하십시오 (예 : &lt;code&gt;L&amp;lt;Net::Ping&amp;gt;&lt;/code&gt; ). 주의 &lt;code&gt;name&lt;/code&gt; 에 공백이 포함되지 않아야합니다. 이 구문은 &lt;code&gt;L&amp;lt;crontab(5)&amp;gt;&lt;/code&gt; 에서처럼 Unix 매뉴얼 페이지에 대한 참조에도 종종 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="5ebcbb26d8410e15ec0a3bf942439d1fa6f0dc0e" translate="yes" xml:space="preserve">
          <source>Link to a section in other manual page. E.g., &lt;code&gt;L&amp;lt;perlsyn/&quot;For Loops&quot;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">다른 매뉴얼 페이지의 섹션으로 연결하십시오. 예를 들어 &lt;code&gt;L&amp;lt;perlsyn/&quot;For Loops&quot;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4a4be78347858c96ca4af009ad12e83b583efec3" translate="yes" xml:space="preserve">
          <source>Link to a section in this manual page. E.g., &lt;code&gt;L&amp;lt;/&quot;Object Methods&quot;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">이 매뉴얼 페이지의 섹션으로 연결하십시오. 예를 들어 &lt;code&gt;L&amp;lt;/&quot;Object Methods&quot;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c060793b58b5034337a483732320e10661d5f930" translate="yes" xml:space="preserve">
          <source>Linker Problems in Irix</source>
          <target state="translated">Irix의 링커 문제</target>
        </trans-unit>
        <trans-unit id="632c0116497fe7ec21df3b6015a06dceee2c2e46" translate="yes" xml:space="preserve">
          <source>Links to an absolute URL. For example, &lt;code&gt;L&amp;lt;&lt;a href=&quot;http://www.perl.org/&quot;&gt;http://www.perl.org/&lt;/a&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;L&amp;lt;The Perl Home Page|&lt;a href=&quot;http://www.perl.org/&quot;&gt;http://www.perl.org/&lt;/a&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">절대 URL에 연결합니다. 예를 들어 &lt;code&gt;L&amp;lt;&lt;a href=&quot;http://www.perl.org/&quot;&gt;http://www.perl.org/&lt;/a&gt;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;L&amp;lt;The Perl Home Page|&lt;a href=&quot;http://www.perl.org/&quot;&gt;http://www.perl.org/&lt;/a&gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ec4f23be8f3036b01885e23831c9d8422f8e25f" translate="yes" xml:space="preserve">
          <source>Linux Magazine</source>
          <target state="translated">리눅스 매거진</target>
        </trans-unit>
        <trans-unit id="2187306118c639d0411d3a1f0eea679c435e121f" translate="yes" xml:space="preserve">
          <source>Linux-specific shortcuts to specify the &lt;code&gt;O_NONBLOCK&lt;/code&gt; and &lt;code&gt;FD_CLOEXEC&lt;/code&gt; flags during a &lt;code&gt;&lt;a href=&quot;functions/socket&quot;&gt;socket(2)&lt;/a&gt;&lt;/code&gt; call.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/socket&quot;&gt;socket(2)&lt;/a&gt;&lt;/code&gt; 호출 중에 &lt;code&gt;O_NONBLOCK&lt;/code&gt; 및 &lt;code&gt;FD_CLOEXEC&lt;/code&gt; 플래그 를 지정하기위한 Linux 특정 단축키 .</target>
        </trans-unit>
        <trans-unit id="7aaedd94529deff9e35130dfc5ae5796d73c29a7" translate="yes" xml:space="preserve">
          <source>LinuxThreads is now obsolete on Linux, and caching &lt;code&gt;getpid()&lt;/code&gt; like this made embedding perl unnecessarily complex (since you'd have to manually update the value of $$), so now &lt;code&gt;$$&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/getppid&quot;&gt;getppid()&lt;/a&gt;&lt;/code&gt; will always return the same values as the underlying C library.</source>
          <target state="translated">LinuxThreads는 이제 Linux에서 더 이상 사용되지 않으며, 이와 같이 &lt;code&gt;getpid()&lt;/code&gt; 캐싱 하면 perl을 불필요하게 복잡하게 만들 수 있습니다 ($ $$의 값을 수동으로 업데이트해야하기 때문에) 이제 &lt;code&gt;$$&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;functions/getppid&quot;&gt;getppid()&lt;/a&gt;&lt;/code&gt; 는 항상 같은 값을 반환합니다 기본 C 라이브러리</target>
        </trans-unit>
        <trans-unit id="29c9d470de128561132f93d1517a546cc93f2ef7" translate="yes" xml:space="preserve">
          <source>List (default all) actions, breakpoints and watch expressions</source>
          <target state="translated">작업, 중단 점 및 감시 식 나열 (기본 전체)</target>
        </trans-unit>
        <trans-unit id="4f52dc39b8b924455cea92e15110632fa2352d9b" translate="yes" xml:space="preserve">
          <source>List &lt;code&gt;incr+1&lt;/code&gt; lines starting at &lt;code&gt;min&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;min&lt;/code&gt; 에서 시작하는 &lt;code&gt;incr+1&lt;/code&gt; 줄을 나열합니다 .</target>
        </trans-unit>
        <trans-unit id="605938e2092b0e1418a4f6b86421f6d6aadd1b04" translate="yes" xml:space="preserve">
          <source>List Operators (Rightward)</source>
          <target state="translated">연산자 목록 (오른쪽)</target>
        </trans-unit>
        <trans-unit id="ea9c7040ec8c47c48d227dc0186264691d25d357" translate="yes" xml:space="preserve">
          <source>List a single line.</source>
          <target state="translated">한 줄을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="43aa9239459d3ee11976e9110444e7fe09843446" translate="yes" xml:space="preserve">
          <source>List all build directories of distributions that have been tested successfully but have not yet been installed. See also &lt;code&gt;install_tested&lt;/code&gt; .</source>
          <target state="translated">성공적으로 테스트되었지만 아직 설치되지 않은 배포판의 모든 빌드 디렉토리를 나열하십시오. &lt;code&gt;install_tested&lt;/code&gt; 도 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="370cf490cd3daa93894252ec5158b9c077c837f2" translate="yes" xml:space="preserve">
          <source>List assignment in scalar context returns the number of elements produced by the expression on the right side of the assignment:</source>
          <target state="translated">스칼라 컨텍스트의 목록 할당은 할당의 오른쪽에있는 표현식으로 생성 된 요소 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="45a5a84ab7f0560a41223626f7533a814734e050" translate="yes" xml:space="preserve">
          <source>List constants</source>
          <target state="translated">상수 목록</target>
        </trans-unit>
        <trans-unit id="55d8dbd99ddbc695154ff187f15da85365e9e00f" translate="yes" xml:space="preserve">
          <source>List constants are lists, not arrays. To index or slice them, they must be placed in parentheses.</source>
          <target state="translated">리스트 상수는 배열이 아니라리스트입니다. 색인을 작성하거나 슬라이스하려면 괄호 안에 넣어야합니다.</target>
        </trans-unit>
        <trans-unit id="c9230863aaf9811a194bc857bc0390c6326f13d9" translate="yes" xml:space="preserve">
          <source>List constants are not inlined unless you are using Perl v5.20 or higher. In v5.20 or higher, they are still not read-only, but that may change in future versions.</source>
          <target state="translated">Perl v5.20 이상을 사용하지 않으면 목록 상수가 인라인되지 않습니다. v5.20 이상에서는 여전히 읽기 전용이 아니지만 향후 버전에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d9c4f2773006f355714dc08c4a64f23012ee969" translate="yes" xml:space="preserve">
          <source>List directories as they are searched</source>
          <target state="translated">검색된 디렉토리 나열</target>
        </trans-unit>
        <trans-unit id="0865484d5c94ce11961bf51a22181df567484e88" translate="yes" xml:space="preserve">
          <source>List first window of lines from subroutine.</source>
          <target state="translated">서브 루틴의 첫 번째 라인 창을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="19ff7a57a5555c3820cb313b589ff3e43f5801b3" translate="yes" xml:space="preserve">
          <source>List lines &lt;code&gt;min&lt;/code&gt; through &lt;code&gt;max&lt;/code&gt; . &lt;code&gt;l -&lt;/code&gt; is synonymous to &lt;code&gt;-&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;min&lt;/code&gt; 행 부터 &lt;code&gt;max&lt;/code&gt; 행 까지 나열하십시오 . &lt;code&gt;l -&lt;/code&gt; 에 동의어이다 &lt;code&gt;-&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b2f29a334d30972bc8a9045f68baae0dc3ec6d8" translate="yes" xml:space="preserve">
          <source>List next window of lines.</source>
          <target state="translated">다음 줄 창을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="5359c0166343c48f9f035c401a1a6fd47a5d3c30" translate="yes" xml:space="preserve">
          <source>List of</source>
          <target state="translated">의 목록</target>
        </trans-unit>
        <trans-unit id="c7b2bf307cdc3add3b560b3cf9c6d9638160226a" translate="yes" xml:space="preserve">
          <source>List of _CHECK_ values</source>
          <target state="translated">_CHECK_ 값 목록</target>
        </trans-unit>
        <trans-unit id="42e3128876d62127f71da94d3596564663a283a7" translate="yes" xml:space="preserve">
          <source>List of handlers that have been registered.</source>
          <target state="translated">등록 된 핸들러 목록입니다.</target>
        </trans-unit>
        <trans-unit id="942be8ea6b09c5850208d901ada25608760abbb7" translate="yes" xml:space="preserve">
          <source>List of libraries that need to be linked with when linking a perl binary which includes this extension. Only those libraries that actually exist are included. These are written to a file and used when linking perl.</source>
          <target state="translated">이 확장을 포함하는 perl 바이너리를 링크 할 때 링크되어야하는 라이브러리 목록. 실제로 존재하는 라이브러리 만 포함됩니다. 이것들은 파일에 쓰여지고 perl을 연결할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="25c88a0a5acb1948d9832032688b4c20061ebe55" translate="yes" xml:space="preserve">
          <source>List of lines in currently loaded file.</source>
          <target state="translated">현재로드 된 파일의 행 목록</target>
        </trans-unit>
        <trans-unit id="e2c751f0916c7f646852ece1bcfc81eae8d05b8f" translate="yes" xml:space="preserve">
          <source>List of object files, defaults to '$(BASEEXT)$(OBJ_EXT)', but can be a long string or an array containing all object files, e.g. &quot;tkpBind.o tkpButton.o tkpCanvas.o&quot; or [&quot;tkpBind.o&quot;, &quot;tkpButton.o&quot;, &quot;tkpCanvas.o&quot;]</source>
          <target state="translated">객체 파일 목록의 기본값은 '$ (BASEEXT) $ (OBJ_EXT)'이지만 긴 문자열이거나 모든 객체 파일을 포함하는 배열 일 수 있습니다 (예 : &quot;tkpBind.o tkpButton.o tkpCanvas.o&quot;또는 [ &quot;tkpBind.o) &quot;,&quot;tkpButton.o &quot;,&quot;tkpCanvas.o &quot;]</target>
        </trans-unit>
        <trans-unit id="5c1db3ac864f059bce7875da034cf8c723ca64e1" translate="yes" xml:space="preserve">
          <source>List of those libraries that are needed but can be linked in dynamically at run time on this platform. SunOS/Solaris does not need this because ld records the information (from LDLOADLIBS) into the object file. This list is used to create a .bs (bootstrap) file.</source>
          <target state="translated">이 플랫폼에서 필요하지만 런타임에 동적으로 링크 될 수있는 라이브러리 목록. ld는 LDLOADLIBS의 정보를 객체 파일에 기록하므로 SunOS / Solaris는이를 필요로하지 않습니다. 이 목록은 .bs (부트 스트랩) 파일을 만드는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5a0cf49d555f62d3d4e052b6541ec31f30e51960" translate="yes" xml:space="preserve">
          <source>List of those libraries which can or must be linked into the shared library when created using ld. These may be static or dynamic libraries. LD_RUN_PATH is a colon separated list of the directories in LDLOADLIBS. It is passed as an environment variable to the process that links the shared library.</source>
          <target state="translated">ld를 사용하여 작성 될 때 공유 라이브러리에 링크 될 수 있거나 링크되어야하는 라이브러리 목록. 이들은 정적 또는 동적 라이브러리 일 수 있습니다. LD_RUN_PATH는 LDLOADLIBS에있는 콜론으로 구분 된 디렉토리 목록입니다. 공유 라이브러리를 링크하는 프로세스에 환경 변수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="2868b38546ebc5d5d8fcc48449cbafe99e0ffc2a" translate="yes" xml:space="preserve">
          <source>List out all pre-prompt Perl command actions.</source>
          <target state="translated">모든 사전 프롬프트 Perl 명령 조치를 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="b2fda16ba9c5deaf514c003911417714fab1f6a2" translate="yes" xml:space="preserve">
          <source>List out post-prompt Perl command actions.</source>
          <target state="translated">프롬프트 후 Perl 명령 조치를 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="b85c9a7b9160438294dae5b78f69ab7f0a89edb4" translate="yes" xml:space="preserve">
          <source>List out pre-prompt debugger commands.</source>
          <target state="translated">사전 프롬프트 디버거 명령을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="c433826fb0a01d3298adbd1cec75ac79e366fe70" translate="yes" xml:space="preserve">
          <source>List previous window of lines.</source>
          <target state="translated">이전 줄 창을 나열합니다.</target>
        </trans-unit>
        <trans-unit id="6828bea1ce4a116f7cab52f1ff715d22eb63c991" translate="yes" xml:space="preserve">
          <source>List subroutine names [not] matching the regex.</source>
          <target state="translated">정규식과 일치하지 않는 서브 루틴 이름을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="07d9bedea128205ac0ccf6ba46b2275b7e0355dc" translate="yes" xml:space="preserve">
          <source>List value constructors</source>
          <target state="translated">값 생성자</target>
        </trans-unit>
        <trans-unit id="3b83ab8a9c9e9daa0f3c240465a14ac3cfec98b6" translate="yes" xml:space="preserve">
          <source>List values are denoted by separating individual values by commas (and enclosing the list in parentheses where precedence requires it):</source>
          <target state="translated">목록 값은 개별 값을 쉼표로 구분하여 표시합니다 (우선 순위가 필요한 경우 목록을 괄호로 묶음).</target>
        </trans-unit>
        <trans-unit id="9c332d7d437db4bb1a089aef08dedde1d03aa848" translate="yes" xml:space="preserve">
          <source>List values in scalar context</source>
          <target state="translated">스칼라 컨텍스트에서 값 나열</target>
        </trans-unit>
        <trans-unit id="3e21f245885fcb8d2afb9ad390e31a12b2893368" translate="yes" xml:space="preserve">
          <source>List which methods may be called on the result of the evaluated expression. The expression may evaluated to a reference to a blessed object, or to a package name.</source>
          <target state="translated">평가 된 표현식의 결과에서 호출 할 수있는 메소드를 나열하십시오. 이 표현은 복된 대상 또는 패키지 이름에 대한 참조로 평가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8403bab2922ebc2678fad6cf5cb327231181154" translate="yes" xml:space="preserve">
          <source>List::Util</source>
          <target state="translated">List::Util</target>
        </trans-unit>
        <trans-unit id="0553bce08d5ad663737a32d66e461a6fde4d42cc" translate="yes" xml:space="preserve">
          <source>List::Util - A selection of general-utility list subroutines</source>
          <target state="translated">List :: Util-일반 유틸리티 목록 서브 루틴 선택</target>
        </trans-unit>
        <trans-unit id="e6ae9327a79eb9d0433ed0271e4debca709ad198" translate="yes" xml:space="preserve">
          <source>List::Util::XS</source>
          <target state="translated">List::Util::XS</target>
        </trans-unit>
        <trans-unit id="6a577f2f652a9865e261b6b1b9108f10eb35a6b7" translate="yes" xml:space="preserve">
          <source>List::Util::XS - Indicate if List::Util was compiled with a C compiler</source>
          <target state="translated">List :: Util :: XS-List :: Util이 C 컴파일러로 컴파일되었는지 표시</target>
        </trans-unit>
        <trans-unit id="577f684095ccbc8608cf104c7d53ed608fc27e62" translate="yes" xml:space="preserve">
          <source>Listed below are functions that are either completely unimplemented or else have been implemented differently on various platforms. Following each description will be, in parentheses, a list of platforms that the description applies to.</source>
          <target state="translated">아래에는 완전히 구현되지 않았거나 다양한 플랫폼에서 다르게 구현 된 기능이 나열되어 있습니다. 각 설명 다음에는 설명이 적용되는 플랫폼 목록이 괄호 안에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c2100cb1ce0771ebf5c66d34af2b3109940abd61" translate="yes" xml:space="preserve">
          <source>Listing available encodings</source>
          <target state="translated">사용 가능한 인코딩 나열</target>
        </trans-unit>
        <trans-unit id="dd09e23888b88d8b373ca4d91ed87f3200a2d3a8" translate="yes" xml:space="preserve">
          <source>Lists all available encodings, one per line, in case-insensitive order. Note that only the canonical names are listed; many aliases exist. For example, the names are case-insensitive, and many standard and common aliases work, such as &quot;latin1&quot; for &quot;ISO-8859-1&quot;, or &quot;ibm850&quot; instead of &quot;cp850&quot;, or &quot;winlatin1&quot; for &quot;cp1252&quot;. See &lt;a href=&quot;encode/supported&quot;&gt;Encode::Supported&lt;/a&gt; for a full discussion.</source>
          <target state="translated">대 / 소문자를 구분하지 않고 사용 가능한 모든 인코딩을 한 줄에 하나씩 나열합니다. 표준 이름 만 나열됩니다. 많은 별칭이 존재합니다. 예를 들어, 이름은 대소 문자를 구분하지 않으며 &quot;ISO-8859-1&quot;의 경우 &quot;latin1&quot;또는 &quot;cp850&quot;대신 &quot;ibm850&quot;또는 &quot;cp1252&quot;의 &quot;winlatin1&quot;과 같은 많은 표준 및 공통 별명이 작동합니다. . 자세한 내용은 &lt;a href=&quot;encode/supported&quot;&gt;Encode :: Supported&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e4e9b933aa47588e5dca2e5d37752f783428eced" translate="yes" xml:space="preserve">
          <source>Lists known issues and incompatibilities; &lt;code&gt;&lt;a href=&quot;http://gd.tuwien.ac.at/utils/archivers/star/README.otherbugs&quot;&gt;http://gd.tuwien.ac.at/utils/archivers/star/README.otherbugs&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">알려진 문제와 비 호환성을 나열합니다. &lt;code&gt;&lt;a href=&quot;http://gd.tuwien.ac.at/utils/archivers/star/README.otherbugs&quot;&gt;http://gd.tuwien.ac.at/utils/archivers/star/README.otherbugs&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="14b97602e24bdf80cc94582bec0e02d773290ecc" translate="yes" xml:space="preserve">
          <source>Lists may be assigned to only when each element of the list is itself legal to assign to:</source>
          <target state="translated">목록의 각 요소가 다음과 같이 합법적 인 경우에만 목록을 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91575e88330ca0a393b09df24c2f9572b830580f" translate="yes" xml:space="preserve">
          <source>Ll</source>
          <target state="translated">Ll</target>
        </trans-unit>
        <trans-unit id="ddcb77ff769ea54ca622848f6bedd4004fa4f4fa" translate="yes" xml:space="preserve">
          <source>Load</source>
          <target state="translated">Load</target>
        </trans-unit>
        <trans-unit id="dfb2a396182dae27999fc6c1e32de77266a8eaa5" translate="yes" xml:space="preserve">
          <source>Load a different math lib, see &lt;a href=&quot;#MATH-LIBRARY&quot;&gt;MATH LIBRARY&lt;/a&gt;.</source>
          <target state="translated">다른 수학 라이브러리를로드하십시오 ( &lt;a href=&quot;#MATH-LIBRARY&quot;&gt;MATH LIBRARY&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="44a359a67f4a6d92b34e91186041854ab36b846b" translate="yes" xml:space="preserve">
          <source>Load a different math lib, see &lt;a href=&quot;#Math-Library&quot;&gt;Math Library&lt;/a&gt;.</source>
          <target state="translated">다른 math 라이브러리를로드하십시오 ( &lt;a href=&quot;#Math-Library&quot;&gt;Math Library&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="26c9c83eb2148dde20d87505b058099c18e18cdd" translate="yes" xml:space="preserve">
          <source>Load a harness replacement class.</source>
          <target state="translated">하네스 교체 등급을로드하십시오.</target>
        </trans-unit>
        <trans-unit id="3ab8a70aafed206e446c89069a6d6fa487286375" translate="yes" xml:space="preserve">
          <source>Load functions only on demand</source>
          <target state="translated">요청시에만 기능로드</target>
        </trans-unit>
        <trans-unit id="1a6bf14720b01e30066247880d6ebc3b8752469c" translate="yes" xml:space="preserve">
          <source>Load subroutines only on demand</source>
          <target state="translated">요청시에만 서브 루틴로드</target>
        </trans-unit>
        <trans-unit id="d792f29bac65ac823df5b7bb2984ae1cc96bc863" translate="yes" xml:space="preserve">
          <source>Load the C Fcntl.h defines</source>
          <target state="translated">C Fcntl.h 정의로드</target>
        </trans-unit>
        <trans-unit id="240fa313380982dac95b53cefb0c75077c026845" translate="yes" xml:space="preserve">
          <source>Load the state from a file</source>
          <target state="translated">파일에서 상태로드</target>
        </trans-unit>
        <trans-unit id="15cac79f7c6e29d135cac8ed345f5ee74ad107b9" translate="yes" xml:space="preserve">
          <source>Load various IO modules</source>
          <target state="translated">다양한 IO 모듈로드</target>
        </trans-unit>
        <trans-unit id="59ee7110b16f2ee9279e975045a71b3b2753da6e" translate="yes" xml:space="preserve">
          <source>LoadFile</source>
          <target state="translated">LoadFile</target>
        </trans-unit>
        <trans-unit id="478aa4ede7f109d8fe9ce74fc47e542819bd58d3" translate="yes" xml:space="preserve">
          <source>Loads Perl library from &lt;code&gt;$exedir/../dll/lib/&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$exedir/../dll/lib/&lt;/code&gt; 에서 Perl 라이브러리를로드 합니다.</target>
        </trans-unit>
        <trans-unit id="3c5210c4cd9f4652e7e267673947f320fe973e2f" translate="yes" xml:space="preserve">
          <source>Loads a specified module and imports the default functions to the specified package.</source>
          <target state="translated">지정된 모듈을로드하고 기본 기능을 지정된 패키지로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="27e6bb733433394f480bba5733da627a3f3f2045" translate="yes" xml:space="preserve">
          <source>Loads a specified module and imports the default functions.</source>
          <target state="translated">지정된 모듈을로드하고 기본 기능을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="0912e26f46f2862f9bc8f741f795bbefe5ccdd67" translate="yes" xml:space="preserve">
          <source>Loads a specified module to the specified package.</source>
          <target state="translated">지정된 모듈을 지정된 패키지로로드합니다.</target>
        </trans-unit>
        <trans-unit id="6ec299bdf7d010c1eee08526d7bd0161603d96f6" translate="yes" xml:space="preserve">
          <source>Loads a specified module.</source>
          <target state="translated">지정된 모듈을로드합니다.</target>
        </trans-unit>
        <trans-unit id="4a312f5b131e98b974541ced8733bc202310a2a5" translate="yes" xml:space="preserve">
          <source>Loads the handler classes defined in &lt;a href=&quot;#config&quot;&gt;config&lt;/a&gt;. For example, given a config:</source>
          <target state="translated">&lt;a href=&quot;#config&quot;&gt;config에&lt;/a&gt; 정의 된 핸들러 클래스를로드합니다 . 예를 들어, 구성이 주어지면 :</target>
        </trans-unit>
        <trans-unit id="ec6dda1ab28094112405a17ad65b1a4c1c089d63" translate="yes" xml:space="preserve">
          <source>Loads the module whose name is pointed to by the string part of name. Note that the actual module name, not its filename, should be given. Eg, &quot;Foo::Bar&quot; instead of &quot;Foo/Bar.pm&quot;. flags can be any of PERL_LOADMOD_DENY, PERL_LOADMOD_NOIMPORT, or PERL_LOADMOD_IMPORT_OPS (or 0 for no flags). ver, if specified and not NULL, provides version semantics similar to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Foo::Bar VERSION&lt;/code&gt; . The optional trailing SV* arguments can be used to specify arguments to the module's import() method, similar to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Foo::Bar VERSION LIST&lt;/code&gt; . They must be terminated with a final NULL pointer. Note that this list can only be omitted when the PERL_LOADMOD_NOIMPORT flag has been used. Otherwise at least a single NULL pointer to designate the default import list is required.</source>
          <target state="translated">name의 문자열 부분에서 이름이 가리키는 모듈을로드합니다. 파일 이름이 아닌 실제 모듈 이름을 지정해야합니다. 예 : &quot;Foo / Bar.pm&quot;대신 &quot;Foo :: Bar&quot; 플래그는 PERL_LOADMOD_DENY, PERL_LOADMOD_NOIMPORT 또는 PERL_LOADMOD_IMPORT_OPS (또는 플래그가없는 경우 0) 중 하나 일 수 있습니다. ver은 NULL이 아닌 지정되면 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Foo::Bar VERSION&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 과 유사한 버전 의미를 제공합니다 . 선택적 후행 SV * 인수는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Foo::Bar VERSION LIST&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 과 유사하게 모듈의 import () 메소드에 인수를 지정하는 데 사용할 수 있습니다 . 최종 NULL 포인터로 종료해야합니다. PERL_LOADMOD_NOIMPORT 플래그가 사용 된 경우에만이 목록을 생략 할 수 있습니다. 그렇지 않으면 기본 가져 오기 목록을 지정하기 위해 최소한 하나의 NULL 포인터가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="9af5b63a9cb9853b15da20ea4f2739623dc82021" translate="yes" xml:space="preserve">
          <source>Loc.U</source>
          <target state="translated">Loc.U</target>
        </trans-unit>
        <trans-unit id="2c161b9d2652a245b17c473e85af35d98c964e27" translate="yes" xml:space="preserve">
          <source>Loc_ar.U</source>
          <target state="translated">Loc_ar.U</target>
        </trans-unit>
        <trans-unit id="40cd835b717a79093cb71f794169679d3511a012" translate="yes" xml:space="preserve">
          <source>Loc_sed.U</source>
          <target state="translated">Loc_sed.U</target>
        </trans-unit>
        <trans-unit id="b62225661a9783f7a6a2c6e6f754c699e4dfbc8e" translate="yes" xml:space="preserve">
          <source>Local Locales</source>
          <target state="translated">지역 로케일</target>
        </trans-unit>
        <trans-unit id="00b7d8ac28ed6d0a7686172cc54cac83dde1640a" translate="yes" xml:space="preserve">
          <source>Local configuration data for libnet</source>
          <target state="translated">libnet의 로컬 구성 데이터</target>
        </trans-unit>
        <trans-unit id="2073176912b2b8b08756b78673e90f32f9412f5a" translate="yes" xml:space="preserve">
          <source>Local hosts should normally respond to pings within milliseconds. However, on a very congested network it may take up to 3 seconds or longer to receive an echo packet from the remote host. If the timeout is set too low under these conditions, it will appear that the remote host is not reachable (which is almost the truth).</source>
          <target state="translated">로컬 호스트는 일반적으로 밀리 초 내에 핑에 응답해야합니다. 그러나 매우 혼잡 한 네트워크에서는 원격 호스트에서 에코 패킷을 수신하는 데 최대 3 초 이상 걸릴 수 있습니다. 이러한 조건에서 시간 초과가 너무 낮게 설정되면 원격 호스트에 도달 할 수없는 것 같습니다 (거의 사실임).</target>
        </trans-unit>
        <trans-unit id="29d6a411ea768d6e339737cbc631007347c4656b" translate="yes" xml:space="preserve">
          <source>Locale is not completely independent. The</source>
          <target state="translated">로케일은 완전히 독립적이지 않습니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="944d1183f1e4f233c0975643c2ef4f71a04349e2" translate="yes" xml:space="preserve">
          <source>Locale-related functions and macros</source>
          <target state="translated">로케일 관련 기능 및 매크로</target>
        </trans-unit>
        <trans-unit id="1f8d3cc6a62e48187b6914a4e521248e770e765b" translate="yes" xml:space="preserve">
          <source>Locale::Country</source>
          <target state="translated">Locale::Country</target>
        </trans-unit>
        <trans-unit id="711ea7f4d30a8250ee3539542d2d19015e5ecdec" translate="yes" xml:space="preserve">
          <source>Locale::Country - standard codes for country identification</source>
          <target state="translated">로캘 :: 국가-국가 식별을위한 표준 코드</target>
        </trans-unit>
        <trans-unit id="745a3f2e63c8527b20fd7a0effbd2a4f6ce52b10" translate="yes" xml:space="preserve">
          <source>Locale::Currency</source>
          <target state="translated">Locale::Currency</target>
        </trans-unit>
        <trans-unit id="c9d7708330810bdeae6d8e6f009ab34981fb3578" translate="yes" xml:space="preserve">
          <source>Locale::Currency - standard codes for currency identification</source>
          <target state="translated">로캘 :: 통화-통화 식별을위한 표준 코드</target>
        </trans-unit>
        <trans-unit id="a2f93f9cc8bf81f232cf25c9d6170a176bd3c8f2" translate="yes" xml:space="preserve">
          <source>Locale::Language</source>
          <target state="translated">Locale::Language</target>
        </trans-unit>
        <trans-unit id="cbd3f9670295ab004a97a8799e46f114e838f7c9" translate="yes" xml:space="preserve">
          <source>Locale::Language - standard codes for language identification</source>
          <target state="translated">로캘 :: 언어-언어 식별을위한 표준 코드</target>
        </trans-unit>
        <trans-unit id="a9d8403dd9e14d9c4a74e42c449f4f4083d77a9b" translate="yes" xml:space="preserve">
          <source>Locale::Maketext</source>
          <target state="translated">Locale::Maketext</target>
        </trans-unit>
        <trans-unit id="58f6640492c0aec7031aee510f4ce0bcac4b2a22" translate="yes" xml:space="preserve">
          <source>Locale::Maketext - framework for localization</source>
          <target state="translated">Locale :: Maketext-현지화를위한 프레임 워크</target>
        </trans-unit>
        <trans-unit id="4ffc03bfc5c484b62d9372e1420bdf253f5b3f52" translate="yes" xml:space="preserve">
          <source>Locale::Maketext offers a variety of methods, which fall into three categories:</source>
          <target state="translated">Locale :: Maketext는 다음과 같은 세 가지 범주로 분류되는 다양한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a5723d6c0c42ee05086667e38fd4249fe7082e8c" translate="yes" xml:space="preserve">
          <source>Locale::Maketext::Guts</source>
          <target state="translated">Locale::Maketext::Guts</target>
        </trans-unit>
        <trans-unit id="63bea57dac9566b0aa40481ae087dc206e13e8ee" translate="yes" xml:space="preserve">
          <source>Locale::Maketext::Guts - Deprecated module to load Locale::Maketext utf8 code</source>
          <target state="translated">Locale :: Maketext :: Guts-로케일 :: Maketext utf8 코드를로드하기 위해 사용되지 않는 모듈</target>
        </trans-unit>
        <trans-unit id="b14392dcdae7ce47ee917b41b3e73f1a3b72f5e1" translate="yes" xml:space="preserve">
          <source>Locale::Maketext::GutsLoader</source>
          <target state="translated">Locale::Maketext::GutsLoader</target>
        </trans-unit>
        <trans-unit id="9810a1053985ebcf2f9b5544107826a653c00a65" translate="yes" xml:space="preserve">
          <source>Locale::Maketext::GutsLoader - Deprecated module to load Locale::Maketext utf8 code</source>
          <target state="translated">Locale :: Maketext :: GutsLoader-더 이상 사용되지 않는 로케일 :: Maketext utf8 코드로드 모듈</target>
        </trans-unit>
        <trans-unit id="a239b132192c48779d9a0ee403ad81c93ab75902" translate="yes" xml:space="preserve">
          <source>Locale::Maketext::Simple</source>
          <target state="translated">Locale::Maketext::Simple</target>
        </trans-unit>
        <trans-unit id="a942c8cd15bd2125fe42db2a486e9feebf1cfa35" translate="yes" xml:space="preserve">
          <source>Locale::Maketext::Simple - Simple interface to Locale::Maketext::Lexicon</source>
          <target state="translated">Locale :: Maketext :: Simple-Locale :: Maketext :: Lexicon에 대한 간단한 인터페이스</target>
        </trans-unit>
        <trans-unit id="1ee43c469c3726bd84652212d4ca88cc335a5967" translate="yes" xml:space="preserve">
          <source>Locale::Script</source>
          <target state="translated">Locale::Script</target>
        </trans-unit>
        <trans-unit id="8f438e3df7fafcc383b453fd3213f4653605e9c0" translate="yes" xml:space="preserve">
          <source>Locale::Script - standard codes for script identification</source>
          <target state="translated">로케일 :: 스크립트-스크립트 식별을위한 표준 코드</target>
        </trans-unit>
        <trans-unit id="a222060e32289bf6910ac4a07a10733be500bd99" translate="yes" xml:space="preserve">
          <source>Locales</source>
          <target state="translated">Locales</target>
        </trans-unit>
        <trans-unit id="f8764300ec3ae038b44ac23ce898f50ceb30676b" translate="yes" xml:space="preserve">
          <source>Locales are supported. There may be glitches when a locale is another EBCDIC code page which has some of the &lt;a href=&quot;#The-13-variant-characters&quot;&gt;code-page variant characters&lt;/a&gt; in other positions.</source>
          <target state="translated">로케일이 지원됩니다. 로케일이 다른 위치에 일부 &lt;a href=&quot;#The-13-variant-characters&quot;&gt;코드 페이지 변형 문자&lt;/a&gt; 가있는 다른 EBCDIC 코드 페이지 인 경우 결함이있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="32f83a14354ab144fa1eeefe381bdddf7ef6a4b6" translate="yes" xml:space="preserve">
          <source>Localization of elements of composite types</source>
          <target state="translated">복합 유형 요소의 현지화</target>
        </trans-unit>
        <trans-unit id="87574e6a695fdc9051fd38476db62bcaa8e7cafd" translate="yes" xml:space="preserve">
          <source>Localization of globs</source>
          <target state="translated">글로브의 현지화</target>
        </trans-unit>
        <trans-unit id="f2f69b5bf206324f99fe659a46e5c54c241d441a" translate="yes" xml:space="preserve">
          <source>Localization of special variables</source>
          <target state="translated">특수 변수의 지역화</target>
        </trans-unit>
        <trans-unit id="56adc662b2ff25957a5294f0112a3c7b0d263e47" translate="yes" xml:space="preserve">
          <source>Localized deletion of elements of composite types</source>
          <target state="translated">복합 유형 요소의 현지화 된 삭제</target>
        </trans-unit>
        <trans-unit id="e60da19033e636198e96d7e490201c9c1369d134" translate="yes" xml:space="preserve">
          <source>Localizing &lt;code&gt;$.&lt;/code&gt; will not localize the filehandle's line count</source>
          <target state="translated">지역화 &lt;code&gt;$.&lt;/code&gt; 파일 핸들의 행 수를 현지화하지 않습니다</target>
        </trans-unit>
        <trans-unit id="8364e7e87819604234599a1511218996199f997e" translate="yes" xml:space="preserve">
          <source>Localizing changes</source>
          <target state="translated">현지화 변경</target>
        </trans-unit>
        <trans-unit id="f408eed5847840b83469388030b3326ba3bf4885" translate="yes" xml:space="preserve">
          <source>Localizing tied arrays or hashes does not work. After exiting the scope the arrays or the hashes are not restored.</source>
          <target state="translated">연결된 배열 또는 해시 지역화가 작동하지 않습니다. 범위를 종료하면 배열 또는 해시가 복원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="00e0ebc3f4b2567f4695fa9503d51f87733e190d" translate="yes" xml:space="preserve">
          <source>Locate directory of original perl script</source>
          <target state="translated">원래 펄 스크립트의 디렉토리를 찾으십시오</target>
        </trans-unit>
        <trans-unit id="cffe84cd97aaf675f786b03919bbd1aad3c3fe1d" translate="yes" xml:space="preserve">
          <source>Locate the CV corresponding to the currently executing sub or eval. If db_seqp is non_null, skip CVs that are in the DB package and populate *db_seqp with the cop sequence number at the point that the DB:: code was entered. (This allows debuggers to eval in the scope of the breakpoint rather than in the scope of the debugger itself.)</source>
          <target state="translated">현재 실행중인 하위 또는 평가에 해당하는 CV를 찾으십시오. db_seqp가 널이 아닌 경우 DB 패키지에있는 CV를 건너 뛰고 DB :: 코드가 입력 된 시점에서 * db_seqp를 경찰 순번으로 채우십시오. 이렇게하면 디버거가 디버거 자체의 범위가 아닌 중단 점 범위에서 평가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5cb0ec5fe28860a73ac5e9c7f201c2864475a69" translate="yes" xml:space="preserve">
          <source>Locates the full path to the script bin directory to allow the use of paths relative to the bin directory.</source>
          <target state="translated">bin 디렉토리에 상대적인 경로를 사용할 수 있도록 스크립트 bin 디렉토리의 전체 경로를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="90f656c2cec82492063f2f19f63b0344475a8752" translate="yes" xml:space="preserve">
          <source>Location of Perl</source>
          <target state="translated">Perl의 위치</target>
        </trans-unit>
        <trans-unit id="e526b099baebb5894aa471d61a7294aea38b4fdb" translate="yes" xml:space="preserve">
          <source>Lock the database with fd &amp;amp; flock.</source>
          <target state="translated">fd &amp;amp; flock으로 데이터베이스를 잠그십시오.</target>
        </trans-unit>
        <trans-unit id="877d08a97c129fe96b732f20ebe8f52e02d93eca" translate="yes" xml:space="preserve">
          <source>Locking and error checking are left as an exercise for the reader. Don't forget them or you'll be quite sorry.</source>
          <target state="translated">잠금 및 오류 검사는 독자의 연습으로 남아 있습니다. 그들을 잊지 마십시오 또는 당신은 매우 죄송합니다.</target>
        </trans-unit>
        <trans-unit id="66cac3a963a1045fd348fae956e2fc8becb2159a" translate="yes" xml:space="preserve">
          <source>Locking: The Trouble with fd</source>
          <target state="translated">잠금 : fd의 문제점</target>
        </trans-unit>
        <trans-unit id="a0ee9e59f4952196e4f063486823a5e6655ed2ab" translate="yes" xml:space="preserve">
          <source>Locks and unlocks the value for an individual key of a hash. The value of a locked key cannot be changed.</source>
          <target state="translated">해시의 개별 키에 대한 값을 잠 그거나 잠금 해제합니다. 잠긴 키의 값은 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="409c237554d2d89fa246a166165492e5479e6006" translate="yes" xml:space="preserve">
          <source>Locks are a handy tool to synchronize access to data, and using them properly is the key to safe shared data. Unfortunately, locks aren't without their dangers, especially when multiple locks are involved. Consider the following code:</source>
          <target state="translated">잠금은 데이터에 대한 액세스를 동기화하는 편리한 도구이며이를 안전하게 사용하는 것이 안전한 공유 데이터의 핵심입니다. 불행히도, 특히 여러 개의 잠금 장치가 관련된 잠금 장치에는 위험이 없습니다. 다음 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="d77ca7a462f2ee37cd5eeb13d2720840dd8f730e" translate="yes" xml:space="preserve">
          <source>Locks are recursive, which means it's okay for a thread to lock a variable more than once. The lock will last until the outermost &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; on the variable goes out of scope. For example:</source>
          <target state="translated">잠금은 재귀 적이므로 스레드가 변수를 두 번 이상 잠글 수 있습니다. 변수 의 가장 바깥 쪽 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; 이 범위를 벗어날 때까지 잠금이 지속 됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fc0486b135937b6c03b868507a94d272ff8ac6f4" translate="yes" xml:space="preserve">
          <source>Locks on variables only affect &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; calls--they do</source>
          <target state="translated">변수에 대한 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; 은 잠금 호출 에만 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="2494e49f95e86d62c9e1df9443b971b1071d1eb2" translate="yes" xml:space="preserve">
          <source>Log all messages up to debug:</source>
          <target state="translated">모든 메시지를 디버그하여 디버그하십시오.</target>
        </trans-unit>
        <trans-unit id="ac20548f5a2664c1934f84717b314a50501d6ebb" translate="yes" xml:space="preserve">
          <source>Log an error that can't be ignored.</source>
          <target state="translated">무시할 수없는 오류를 기록하십시오.</target>
        </trans-unit>
        <trans-unit id="9f24d2b09c179c98a526a557d74f3d2be5514fb4" translate="yes" xml:space="preserve">
          <source>Log an error unless &lt;code&gt;$parser-&amp;gt;no_whining( TRUE );&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$parser-&amp;gt;no_whining( TRUE );&lt;/code&gt; 가 아니면 오류를 기록하십시오 . .</target>
        </trans-unit>
        <trans-unit id="598cba7875d82844d0ea4fd50137d27e20e9822b" translate="yes" xml:space="preserve">
          <source>Log critical messages, errors and warnings:</source>
          <target state="translated">중요한 메시지, 오류 및 경고를 기록하십시오.</target>
        </trans-unit>
        <trans-unit id="2a127fbcd6604ca1cf80302b78e02d5ba87eed29" translate="yes" xml:space="preserve">
          <source>Log everything except informational messages:</source>
          <target state="translated">정보 메시지를 제외한 모든 것을 기록하십시오.</target>
        </trans-unit>
        <trans-unit id="346e7edbc99f3e01ce84957ff3c99842429de19b" translate="yes" xml:space="preserve">
          <source>Log into the remote FTP server with the given login information. If no arguments are given then the &lt;code&gt;Net::FTP&lt;/code&gt; uses the &lt;code&gt;Net::Netrc&lt;/code&gt; package to lookup the login information for the connected host. If no information is found then a login of</source>
          <target state="translated">주어진 로그인 정보를 사용하여 원격 FTP 서버에 로그인하십시오. 인수가 제공되지 않으면 &lt;code&gt;Net::FTP&lt;/code&gt; 는 &lt;code&gt;Net::Netrc&lt;/code&gt; 패키지를 사용 하여 연결된 호스트의 로그인 정보를 찾습니다 . 정보가 없으면 다음의 로그인</target>
        </trans-unit>
        <trans-unit id="38711dd5aba31d74455f59112be713add52892b6" translate="yes" xml:space="preserve">
          <source>Log to UDP port on &lt;code&gt;$remotehost&lt;/code&gt; instead of logging locally:</source>
          <target state="translated">로컬로 로깅하는 대신 &lt;code&gt;$remotehost&lt;/code&gt; 에서 UDP 포트에 로그하십시오 .</target>
        </trans-unit>
        <trans-unit id="ef88b916547cdcd540b35fe969c4a4a3e3015dad" translate="yes" xml:space="preserve">
          <source>Logarithm base two [C99].</source>
          <target state="translated">로그베이스 2 [C99].</target>
        </trans-unit>
        <trans-unit id="126a3068c345063640bada367b1b3170b97166a9" translate="yes" xml:space="preserve">
          <source>Logging if DEBUG (constant)</source>
          <target state="translated">DEBUG (일정) 인 경우 로깅</target>
        </trans-unit>
        <trans-unit id="786908e4097f50192db248aa36b5528e31277867" translate="yes" xml:space="preserve">
          <source>Logical And</source>
          <target state="translated">논리 및</target>
        </trans-unit>
        <trans-unit id="4f0fe5e6156db1c8f396f9ada6968d19b442623d" translate="yes" xml:space="preserve">
          <source>Logical Defined-Or</source>
          <target state="translated">논리적 정의 또는</target>
        </trans-unit>
        <trans-unit id="27999dc9087d157951951d7c5ab5c57a64718d42" translate="yes" xml:space="preserve">
          <source>Logical Not</source>
          <target state="translated">논리적 아님</target>
        </trans-unit>
        <trans-unit id="c27af685856a54b17004644154867c40474db6e5" translate="yes" xml:space="preserve">
          <source>Logical or and Exclusive Or</source>
          <target state="translated">논리 또는 독점 또는</target>
        </trans-unit>
        <trans-unit id="eaac42db96179506f42bd718fb8ac139cdc3650b" translate="yes" xml:space="preserve">
          <source>Logical paths specified by system variables containing comma-separated search lists are also allowed; hence &lt;code&gt;System:Modules&lt;/code&gt; is a valid filename, and the filesystem will prefix &lt;code&gt;Modules&lt;/code&gt; with each section of &lt;code&gt;System$Path&lt;/code&gt; until a name is made that points to an object on disk. Writing to a new file &lt;code&gt;System:Modules&lt;/code&gt; would be allowed only if &lt;code&gt;System$Path&lt;/code&gt; contains a single item list. The filesystem will also expand system variables in filenames if enclosed in angle brackets, so &lt;code&gt;&amp;lt;System$Dir&amp;gt;.Modules&lt;/code&gt; would look for the file &lt;code&gt;$ENV{'System$Dir'} . 'Modules'&lt;/code&gt; . The obvious implication of this is that &lt;b&gt;fully qualified filenames can start with &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; &lt;/b&gt; and should be protected when &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; is used for input.</source>
          <target state="translated">쉼표로 구분 된 검색 목록을 포함하는 시스템 변수로 지정된 논리 경로도 허용됩니다. 따라서 &lt;code&gt;System:Modules&lt;/code&gt; 는 유효한 파일 이름이며 파일 시스템은 디스크의 객체를 가리키는 이름이 만들어 질 때까지 &lt;code&gt;System$Path&lt;/code&gt; 의 각 섹션으로 &lt;code&gt;Modules&lt;/code&gt; 을 접두어 로 사용합니다. 새 파일에 쓰기 &lt;code&gt;System:Modules&lt;/code&gt; 은 &lt;code&gt;System$Path&lt;/code&gt; 에 단일 항목 목록이 포함 된 경우에만 허용됩니다 . 파일 시스템은 꺾쇠 괄호로 묶인 경우 파일 이름의 시스템 변수도 확장하므로 &lt;code&gt;&amp;lt;System$Dir&amp;gt;.Modules&lt;/code&gt; 은 &lt;code&gt;$ENV{'System$Dir'} . 'Modules'&lt;/code&gt; 파일을 찾습니다 . '모듈' . 이것의 명백한 의미는 &lt;b&gt;정규화 된 파일 이름이 &lt;/b&gt;&lt;b&gt; &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 로&lt;/b&gt;&lt;b&gt; 시작할 수&lt;/b&gt; 있다는 것입니다.&lt;b&gt; &lt;/b&gt;입력에 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 이 사용될 때 보호되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="79852f7a308fa757ef46ef50b492fb84497039eb" translate="yes" xml:space="preserve">
          <source>Logically joins the arguments into a single string, and returns its SHA-1/224/256/384/512 digest encoded as a Base64 string.</source>
          <target state="translated">인수를 단일 문자열로 논리적으로 결합하고 Base64 문자열로 인코딩 된 SHA-1 / 224 / 256 / 384 / 512 다이제스트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="efb5f37aee3b9a117751bc32852449eef4e74e78" translate="yes" xml:space="preserve">
          <source>Logically joins the arguments into a single string, and returns its SHA-1/224/256/384/512 digest encoded as a binary string.</source>
          <target state="translated">인수를 단일 문자열로 논리적으로 결합하고 이진 문자열로 인코딩 된 SHA-1 / 224 / 256 / 384 / 512 다이제스트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a5c5c8e8c0f54246b1b313dd050b036a30efb0a2" translate="yes" xml:space="preserve">
          <source>Logically joins the arguments into a single string, and returns its SHA-1/224/256/384/512 digest encoded as a hexadecimal string.</source>
          <target state="translated">인수를 단일 문자열로 논리적으로 결합하고 16 진수 문자열로 인코딩 된 SHA-1 / 224 / 256 / 384 / 512 다이제스트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="04b474494be5436c1b0b4486d175dd6df25d94bc" translate="yes" xml:space="preserve">
          <source>Logically joins the arguments into a single string, and uses it to update the current digest state. In other words, the following statements have the same effect:</source>
          <target state="translated">인수를 단일 문자열로 논리적으로 결합하고이를 사용하여 현재 다이제스트 상태를 업데이트합니다. 다시 말해, 다음 문장은 동일한 효과를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="aaef8ae01439927f0a6ee227f2d792c666fabc4e" translate="yes" xml:space="preserve">
          <source>Login name of the person who ran the Configure script and answered the questions. This is used to tag both</source>
          <target state="translated">Configure 스크립트를 실행하고 질문에 답변 한 사람의 로그인 이름입니다. 둘 다 태그하는 데 사용됩니다</target>
        </trans-unit>
        <trans-unit id="30c490b4b408ece1deda10e7b62b5b4cba9be12b" translate="yes" xml:space="preserve">
          <source>Logs will go on as long as they have to.</source>
          <target state="translated">로그는 필요한 한 계속 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="463552e32614f1099d813cd725ccdec3ad1aa628" translate="yes" xml:space="preserve">
          <source>Long Doubles on Tru64</source>
          <target state="translated">Tru64의 롱 복식</target>
        </trans-unit>
        <trans-unit id="943010215619f82aa64612ba50a6ccaed4ede293" translate="yes" xml:space="preserve">
          <source>Long Doubles.</source>
          <target state="translated">롱 복식.</target>
        </trans-unit>
        <trans-unit id="4d248c964e944a2e6c6cbd3e67c194423372f025" translate="yes" xml:space="preserve">
          <source>Long doubles</source>
          <target state="translated">롱 복식</target>
        </trans-unit>
        <trans-unit id="a209ad07aac520c10047b0552ae5c1c4441aaadc" translate="yes" xml:space="preserve">
          <source>Long integers. This is equivalent to T_IV but explicitly casts the return to type &lt;code&gt;long&lt;/code&gt; . The default typemap for &lt;code&gt;long&lt;/code&gt; is T_IV.</source>
          <target state="translated">긴 정수 이것은 T_IV와 동일하지만 리턴 값을 &lt;code&gt;long&lt;/code&gt; 유형으로 명시 적으로 캐스트합니다 . &lt;code&gt;long&lt;/code&gt; 의 기본 유형 맵 은 T_IV입니다.</target>
        </trans-unit>
        <trans-unit id="210129fcaec84064f201e7b1b9a66e1a7acd7738" translate="yes" xml:space="preserve">
          <source>Long lines broken after an operator (except &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; ).</source>
          <target state="translated">연산자 다음에 긴 줄이 끊어졌습니다 ( &lt;code&gt;and&lt;/code&gt; 및 &lt;code&gt;or&lt;/code&gt; 제외 ).</target>
        </trans-unit>
        <trans-unit id="106ccce59a41316ca39a9a555b12f40ffd8ebb31" translate="yes" xml:space="preserve">
          <source>Long plaguing users of MakeMaker based modules has been the problem of getting basic information about the module out of the sources</source>
          <target state="translated">MakeMaker 기반 모듈의 오랜 골치 아픈 사용자는 소스에서 모듈에 대한 기본 정보를 얻는 데 문제가있었습니다.</target>
        </trans-unit>
        <trans-unit id="d680241590e9a19c54d2635978661f5bb8739734" translate="yes" xml:space="preserve">
          <source>Long regexps like this may impress your friends, but can be hard to decipher. In complex situations like this, the &lt;code&gt;//x&lt;/code&gt; modifier for a match is invaluable. It allows one to put nearly arbitrary whitespace and comments into a regexp without affecting their meaning. Using it, we can rewrite our 'extended' regexp in the more pleasing form</source>
          <target state="translated">이와 같은 긴 정규 표현식은 친구에게 깊은 인상을 줄 수 있지만 해독하기는 어려울 수 있습니다. 이와 같은 복잡한 상황 에서 일치 하는 &lt;code&gt;//x&lt;/code&gt; 수정자는 매우 중요합니다. 거의 임의의 공백과 주석을 의미에 영향을 미치지 않고 정규 표현식에 넣을 수 있습니다. 이를 사용하여 '확장 된'정규 표현식을 더 즐거운 형태로 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f9e2648c307f1adbbaa0fd205252907f8be6f2a" translate="yes" xml:space="preserve">
          <source>Long sequences of elsifs will turn into nested ternary operators, which B::Deparse doesn't know how to indent nicely.</source>
          <target state="translated">긴 Elsif 시퀀스는 중첩 된 삼항 연산자로 바뀌며 B :: Deparse는 잘 들여 쓰는 방법을 모릅니다.</target>
        </trans-unit>
        <trans-unit id="cf4ff04cfe182e8bc5dadb069506e27cabf50333" translate="yes" xml:space="preserve">
          <source>Look - search for key in dictionary file</source>
          <target state="translated">찾기-사전 파일에서 키 검색</target>
        </trans-unit>
        <trans-unit id="2505a112819d0c19797962a0a34b656ddfcb7762" translate="yes" xml:space="preserve">
          <source>Look at &lt;a href=&quot;http://www.perl.org/&quot;&gt;http://www.perl.org/&lt;/a&gt; to find out. If you are not using the latest released version, please try to replicate your bug on the latest stable release.</source>
          <target state="translated">에서 봐 &lt;a href=&quot;http://www.perl.org/&quot;&gt;http://www.perl.org/은&lt;/a&gt; 밖으로 찾을 수 있습니다. 최신 릴리스 버전을 사용하지 않는 경우 최신 안정 릴리스에서 버그를 복제하십시오.</target>
        </trans-unit>
        <trans-unit id="1788237e2a2e0b7dbd5185705c7d994a905e8de0" translate="yes" xml:space="preserve">
          <source>Look for a POD document named &lt;code&gt;$name&lt;/code&gt; in the cache. Returns the reference to the corresponding Pod::Cache::Item object or undef if not found.</source>
          <target state="translated">캐시에서 &lt;code&gt;$name&lt;/code&gt; 이라는 POD 문서를 찾으십시오 . 해당 Pod :: Cache :: Item 객체에 대한 참조를 반환하거나 찾지 못한 경우 undef를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fbd0681ce0f07813305ee76bbda2b9bf4d9e94bf" translate="yes" xml:space="preserve">
          <source>Look for a node or index entry named &lt;code&gt;$name&lt;/code&gt; in the object. Returns the unique id of the node (i.e. the second element of the array stored in the node array) or undef if not found.</source>
          <target state="translated">오브젝트에서 이름이 &lt;code&gt;$name&lt;/code&gt; 노드 또는 색인 항목을 찾으십시오 . 노드의 고유 ID (즉, 노드 배열에 저장된 배열의 두 번째 요소)를 반환하거나 찾을 수없는 경우 undef를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="123c1cf1f88ba14e6964d416656f6e7d8fd3e930" translate="yes" xml:space="preserve">
          <source>Look in &lt;a href=&quot;more&quot;&gt;Test::More&lt;/a&gt;'s SEE ALSO for more testing modules.</source>
          <target state="translated">에서 봐 &lt;a href=&quot;more&quot;&gt;테스트 :: 더&lt;/a&gt; 의 더 테스트 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0f1649ed1326706b3a529a44e1b35a34e5184e5a" translate="yes" xml:space="preserve">
          <source>Look up Perl documentation in Pod format.</source>
          <target state="translated">포드 형식의 Perl 설명서를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="c69ec9ef84491acf135ee455e26c4726d6d3736b" translate="yes" xml:space="preserve">
          <source>Look up the entry in the cop hints hash</source>
          <target state="translated">경찰 힌트 해시에서 항목을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="67f3f361744fabd99e65f601642d504f07f990e2" translate="yes" xml:space="preserve">
          <source>Look up the hint entry in the cop</source>
          <target state="translated">경찰에서 힌트 항목을 찾아</target>
        </trans-unit>
        <trans-unit id="f10edb39dcb279e59fbd91c8271e8ebb8f360ce1" translate="yes" xml:space="preserve">
          <source>Look-around assertions are zero-width patterns which match a specific pattern without including it in &lt;code&gt;$&amp;amp;&lt;/code&gt; . Positive assertions match when their subpattern matches, negative assertions match when their subpattern fails. Look-behind matches text up to the current match position, look-ahead matches text following the current match position.</source>
          <target state="translated">둘러보기 어설 션은 &lt;code&gt;$&amp;amp;&lt;/code&gt; 포함하지 않고 특정 패턴과 일치하는 폭이 0 인 패턴입니다 . 하위 패턴이 일치하면 포지티브 어설 션이 일치하고 하위 패턴이 실패하면 포지티브 어설 션이 일치합니다. Look-behind는 현재 일치 위치까지 텍스트를 일치시키고, Look-ahead는 현재 일치 위치를 따르는 텍스트와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="724a065c84668bb1516bf7e41f33f4d7062d0ec4" translate="yes" xml:space="preserve">
          <source>Looking ahead and looking behind</source>
          <target state="translated">앞서보고 뒤를 보면서</target>
        </trans-unit>
        <trans-unit id="ddd7aa41b84e676f5291b91d7146d3d34c4b037d" translate="yes" xml:space="preserve">
          <source>Looking at data and -w and v</source>
          <target state="translated">데이터와 -w 및 v 살펴보기</target>
        </trans-unit>
        <trans-unit id="afd51bda07c9e5b3e347f595bec67763e831628e" translate="yes" xml:space="preserve">
          <source>Looking at it another way, writing portable code is usually about willfully limiting your available choices. Naturally, it takes discipline and sacrifice to do that. The product of portability and convenience may be a constant. You have been warned.</source>
          <target state="translated">다른 방법으로 살펴보면 휴대용 코드 작성은 일반적으로 사용 가능한 선택 사항을 의도적으로 제한하는 것입니다. 당연히 그렇게하려면 훈련과 희생이 필요합니다. 휴대 성과 편의성의 제품은 일정 할 수 있습니다. 경고를 받았습니다.</target>
        </trans-unit>
        <trans-unit id="e8e461609613edac0a408d3ea9b1090c941ca168" translate="yes" xml:space="preserve">
          <source>Looking at your</source>
          <target state="translated">당신을보고</target>
        </trans-unit>
        <trans-unit id="b9aa086b4410a1e5dda5b6bd9fecaa602b967f8c" translate="yes" xml:space="preserve">
          <source>Looking in to &lt;a href=&quot;http://search.cpan.org/perldoc/Plack&quot;&gt;Plack&lt;/a&gt; and modern Perl web frameworks is highly recommended, though; web programming in Perl has evolved a long way from the old days of simple CGI scripts.</source>
          <target state="translated">그러나 &lt;a href=&quot;http://search.cpan.org/perldoc/Plack&quot;&gt;Plack&lt;/a&gt; 과 최신 Perl 웹 프레임 워크 를 살펴 보는 것이 좋습니다. Perl의 웹 프로그래밍은 예전의 단순한 CGI 스크립트와는 거리가 멀었습니다.</target>
        </trans-unit>
        <trans-unit id="24076d6129adc62ded56328acb2536c0df4e3f06" translate="yes" xml:space="preserve">
          <source>Looking up every message is not the easiest way, so let perl to do it for you. Use the diagnostics pragma with turns perl's normal messages into longer discussions on the topic.</source>
          <target state="translated">모든 메시지를 찾는 것이 가장 쉬운 방법은 아니므로 펄에게 맡기십시오. Perl의 일반 메시지를 주제에 대한 더 긴 토론으로 바꾸면서 진단 pragma를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0cda5c2d87b5464569d98d6b83dc0ced023afb49" translate="yes" xml:space="preserve">
          <source>Looking up module information / loading at runtime</source>
          <target state="translated">런타임에 모듈 정보 조회 /로드</target>
        </trans-unit>
        <trans-unit id="747df9a5145420389182a3a0e2f8fb4f1afad4e4" translate="yes" xml:space="preserve">
          <source>Looks OK, after it's been through the syntax check (perl -c scriptname), we run it and all we get is a blank line again! Hmmmm.</source>
          <target state="translated">구문 검사 (perl -c scriptname)를 거친 후에는 확인하고 실행하면 빈 줄이 다시 나타납니다! 흠.</target>
        </trans-unit>
        <trans-unit id="9e1ff3f5f8cd27194462e5af7c79ade692faba9a" translate="yes" xml:space="preserve">
          <source>Looks ahead one (Unicode) character in the text currently being lexed. Returns the codepoint (unsigned integer value) of the next character, or -1 if lexing has reached the end of the input text. To consume the peeked character, use &lt;a href=&quot;#lex_read_unichar&quot;&gt;lex_read_unichar&lt;/a&gt;.</source>
          <target state="translated">현재 어휘 화되고있는 텍스트에서 하나의 (유니 코드) 문자를 찾습니다. 다음 문자의 부호 포인트 (부호없는 정수 값)를 반환하거나, 어휘가 입력 텍스트의 끝에 도달하면 -1을 반환합니다. &lt;a href=&quot;#lex_read_unichar&quot;&gt;엿봄&lt;/a&gt; 문자를 소비하려면 lex_read_unichar를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="56a09e0b7dcffea4a7ed21e9b73140689a5030bc" translate="yes" xml:space="preserve">
          <source>Looks for MakeMaker-like</source>
          <target state="translated">MakeMaker와 같은 제품을 찾습니다</target>
        </trans-unit>
        <trans-unit id="f560b4b8c550fee26628fb62462e2a0f00ebfb7f" translate="yes" xml:space="preserve">
          <source>Looks for Perl DLL in the directory &lt;code&gt;$exedir/../dll&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;$exedir/../dll&lt;/code&gt; 디렉토리에서 Perl DLL을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="0e20c33c03f2909dd222479a34a94e62a5aa2710" translate="yes" xml:space="preserve">
          <source>Looks good, let's just continue off the end of the script:</source>
          <target state="translated">좋아 보인다, 스크립트의 끝에서 계속하자 :</target>
        </trans-unit>
        <trans-unit id="27da418dc7160824d1f1cea0c0a27285c46f89f4" translate="yes" xml:space="preserve">
          <source>Looks like this:</source>
          <target state="translated">다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="150d86722bc6a43c75ceadbe33863f7ae1a8f8cf" translate="yes" xml:space="preserve">
          <source>Looks up the type of the lexical variable at position</source>
          <target state="translated">위치에서 어휘 변수의 유형을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="7dba7dbb2ccc77afc11256e6171420abb3f68326" translate="yes" xml:space="preserve">
          <source>Lookup and return a reference to the entry for &lt;code&gt;MACHINE&lt;/code&gt; . If &lt;code&gt;LOGIN&lt;/code&gt; is given then the entry returned will have the given login. If &lt;code&gt;LOGIN&lt;/code&gt; is not given then the first entry in the .netrc file for &lt;code&gt;MACHINE&lt;/code&gt; will be returned.</source>
          <target state="translated">&lt;code&gt;MACHINE&lt;/code&gt; 항목에 대한 참조를 조회하고 리턴하십시오 . &lt;code&gt;LOGIN&lt;/code&gt; 이 제공 되면 리턴 된 항목에 지정된 로그인이 있습니다. 경우 &lt;code&gt;LOGIN&lt;/code&gt; 후 이용하실 수 있습니다에 대한하면 .netrc 파일의 첫 번째 항목 &lt;code&gt;MACHINE&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e27af5395111fe3fb113c2e3d566816c9450bb06" translate="yes" xml:space="preserve">
          <source>Lookup for connect()</source>
          <target state="translated">connect () 찾기</target>
        </trans-unit>
        <trans-unit id="cfef537fd2855cc3dbc568fc189f69bf8fa670d8" translate="yes" xml:space="preserve">
          <source>Loop Control</source>
          <target state="translated">루프 제어</target>
        </trans-unit>
        <trans-unit id="4394b7785cf8e6687ab901e849d752a278fd046b" translate="yes" xml:space="preserve">
          <source>Loop control statements don't work in an &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;unless&lt;/code&gt; , since they aren't loops. You can double the braces to make them such, though.</source>
          <target state="translated">루프 제어 문은 작동하지 않는 &lt;code&gt;if&lt;/code&gt; 또는 &lt;code&gt;unless&lt;/code&gt; 그들이 루프를하지 않기 때문에. 그래도 중괄호를 두 배로 늘릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee5406a6fab87283992041afaf3d98b63358ce87" translate="yes" xml:space="preserve">
          <source>Losing Overloading</source>
          <target state="translated">과부하 상실</target>
        </trans-unit>
        <trans-unit id="255b929d8a79cd2d34f3195e7105f962e8ff4cfe" translate="yes" xml:space="preserve">
          <source>Loss of information</source>
          <target state="translated">정보 손실</target>
        </trans-unit>
        <trans-unit id="cfc0d37079134dcffb425a52ede17bc5bc48e470" translate="yes" xml:space="preserve">
          <source>Lots of junk will go past as gdb reads in the relevant source files and libraries, and then:</source>
          <target state="translated">gdb가 관련 소스 파일 및 라이브러리에서 읽을 때 많은 정크가지나갑니다.</target>
        </trans-unit>
        <trans-unit id="085dc9408c5b1c58693c372e333c4354a4cec51f" translate="yes" xml:space="preserve">
          <source>Lots of this documentation is duplicated from &lt;a href=&quot;pod/man&quot;&gt;Pod::Man&lt;/a&gt;.</source>
          <target state="translated">이 설명서의 많은 부분이 &lt;a href=&quot;pod/man&quot;&gt;Pod :: Man과&lt;/a&gt; 중복됩니다 .</target>
        </trans-unit>
        <trans-unit id="ab1f1ddd535328223bedffdfeaa44f30147b00a6" translate="yes" xml:space="preserve">
          <source>Lots. See</source>
          <target state="translated">많이. 보다</target>
        </trans-unit>
        <trans-unit id="05699eeb34507ef8b7729483cad54f68e5da82dd" translate="yes" xml:space="preserve">
          <source>Low-Level Interface to bzip2 compression library</source>
          <target state="translated">bzip2 압축 라이브러리에 대한 저수준 인터페이스</target>
        </trans-unit>
        <trans-unit id="daa6640df64c8d3fd04d48a86e9c6104202745fc" translate="yes" xml:space="preserve">
          <source>Low-Level Interface to zlib compression library</source>
          <target state="translated">zlib 압축 라이브러리에 대한 저수준 인터페이스</target>
        </trans-unit>
        <trans-unit id="a0c4ed2cdac85f3556324d12104692afb5867488" translate="yes" xml:space="preserve">
          <source>Low-level File Opens via sysopen</source>
          <target state="translated">sysopen을 통해 저수준 파일 열기</target>
        </trans-unit>
        <trans-unit id="bbbd1cb27a00deeb8c66f6ae061bb29e0862f1bd" translate="yes" xml:space="preserve">
          <source>Low-level access to Win32 system API calls for files/dirs.</source>
          <target state="translated">파일 / 디렉토리에 대한 Win32 시스템 API 호출에 대한 저수준 액세스.</target>
        </trans-unit>
        <trans-unit id="e8c85a684a62b80d06983e6e12e35335310bc09b" translate="yes" xml:space="preserve">
          <source>Low-level layer that calls &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;lseek&lt;/code&gt; , etc.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;lseek&lt;/code&gt; 등 을 호출하는 저수준 계층</target>
        </trans-unit>
        <trans-unit id="abf8ce4a5f4a2b06b346bb8ef9b168681a52fab2" translate="yes" xml:space="preserve">
          <source>Lowercase_Letter</source>
          <target state="translated">Lowercase_Letter</target>
        </trans-unit>
        <trans-unit id="a99d83c11e02cb19d312201ee35e6930d1ab9ee1" translate="yes" xml:space="preserve">
          <source>Lowers the reference count of the pad name list.</source>
          <target state="translated">패드 이름 목록의 참조 횟수를 줄입니다.</target>
        </trans-unit>
        <trans-unit id="1b905a464c50eff889d1fabd4387275f0c86db4f" translate="yes" xml:space="preserve">
          <source>Lowers the reference count of the pad name.</source>
          <target state="translated">패드 이름의 참조 횟수를 줄입니다.</target>
        </trans-unit>
        <trans-unit id="64d41b1df2cdae534f1fdacc800338a809f214c6" translate="yes" xml:space="preserve">
          <source>Lowest level layer which provides basic PerlIO operations in terms of UNIX/POSIX numeric file descriptor calls (open(), read(), write(), lseek(), close()).</source>
          <target state="translated">UNIX / POSIX 숫자 파일 디스크립터 호출 (open (), read (), write (), lseek (), close ()) 측면에서 기본적인 PerlIO 조작을 제공하는 최하위 레벨 계층.</target>
        </trans-unit>
        <trans-unit id="16b73d35c25cb2d87aaa9bb21b4aedfa85686027" translate="yes" xml:space="preserve">
          <source>Luther Huffman, lutherh@stratcom.com, Strategic Computer Solutions, Inc.</source>
          <target state="translated">Luther Huffman, lutherh@stratcom.com, Strategic Computer Solutions, Inc.</target>
        </trans-unit>
        <trans-unit id="992354f36023a64134d9045affe474e73e18db31" translate="yes" xml:space="preserve">
          <source>Luvverly! and to fix this we declare all variables explicitly and now our script looks like this:</source>
          <target state="translated">Luvverly! 이 문제를 해결하기 위해 모든 변수를 명시 적으로 선언하면 스크립트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dc6aa5975bc24ec633f5fcc8f9ccf2766d7ad7e9" translate="yes" xml:space="preserve">
          <source>Lvalue casts</source>
          <target state="translated">Lvalue 캐스트</target>
        </trans-unit>
        <trans-unit id="c819825aaf49d2c99e8f8f2add24599bfbddb1a0" translate="yes" xml:space="preserve">
          <source>Lvalue subroutines</source>
          <target state="translated">Lvalue 서브 루틴</target>
        </trans-unit>
        <trans-unit id="a77fcba977d5eb923b72725f6d5dc4fe49dee064" translate="yes" xml:space="preserve">
          <source>Lvalue subroutines are convenient, but you have to keep in mind that, when used with objects, they may violate encapsulation. A normal mutator can check the supplied argument before setting the attribute it is protecting, an lvalue subroutine cannot. If you require any special processing when storing and retrieving the values, consider using the CPAN module Sentinel or something similar.</source>
          <target state="translated">Lvalue 서브 루틴은 편리하지만 객체와 함께 사용하면 캡슐화를 위반할 수 있음을 명심해야합니다. 일반 뮤 테이터는 보호하고있는 속성을 설정하기 전에 제공된 인수를 확인할 수 있습니다. lvalue 서브 루틴은 불가능합니다. 값을 저장하고 검색 할 때 특수 처리가 필요한 경우 CPAN 모듈 Sentinel 또는 이와 유사한 것을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="15c8cbe6eb1479a64e132c9d7a73db9ce6a8aab3" translate="yes" xml:space="preserve">
          <source>MAILING LIST</source>
          <target state="translated">메일 링리스트</target>
        </trans-unit>
        <trans-unit id="f672ec1a25cdbb81af49b4e2e09eb665a197b037" translate="yes" xml:space="preserve">
          <source>MAIN METHODS</source>
          <target state="translated">주요 방법</target>
        </trans-unit>
        <trans-unit id="7bee61cc4b2ff6ceaa5bf2c847f0465ac92786f6" translate="yes" xml:space="preserve">
          <source>MAIN SEARCH METHODS</source>
          <target state="translated">주요 검색 방법</target>
        </trans-unit>
        <trans-unit id="b2bcf80339bb8c2f5b627482d7224ef03323abc9" translate="yes" xml:space="preserve">
          <source>MAINTAINER</source>
          <target state="translated">MAINTAINER</target>
        </trans-unit>
        <trans-unit id="572378cf179c50ade4591b0f42a539fe3de5c4ba" translate="yes" xml:space="preserve">
          <source>MAINTAINERS</source>
          <target state="translated">MAINTAINERS</target>
        </trans-unit>
        <trans-unit id="a573378dd124c5aff03b74a9a4dee3c0207dd14a" translate="yes" xml:space="preserve">
          <source>MAINTENANCE AND SUPPORT</source>
          <target state="translated">유지 관리 및 지원</target>
        </trans-unit>
        <trans-unit id="381f8b8847a78b52a5c355f7a396ec94cdfb3fe2" translate="yes" xml:space="preserve">
          <source>MAINTENANCE BRANCHES</source>
          <target state="translated">유지 보수 지점</target>
        </trans-unit>
        <trans-unit id="c8c08604e5e552ec9e9c63c71fc8f4ef53453d1a" translate="yes" xml:space="preserve">
          <source>MAKE ON CYGWIN</source>
          <target state="translated">싸이 윈 만들기</target>
        </trans-unit>
        <trans-unit id="1f0292102c8114ed4accdb4b3187dd3355fe606e" translate="yes" xml:space="preserve">
          <source>MAKE PROBLEMS.</source>
          <target state="translated">문제를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="606cfc5f8f22b0f666e90c16494ce8cfe5172b45" translate="yes" xml:space="preserve">
          <source>MAKE TEST</source>
          <target state="translated">테스트하기</target>
        </trans-unit>
        <trans-unit id="d33b61e914eef018d44c2af2392dd8a8bb3f0814" translate="yes" xml:space="preserve">
          <source>MAKEMAKER: path to the MakeMaker module.</source>
          <target state="translated">MAKEMAKER : MakeMaker 모듈의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="fba0fd0dd60434c9d108881cdd60c2cfbd09f893" translate="yes" xml:space="preserve">
          <source>MAN PAGES</source>
          <target state="translated">맨 페이지</target>
        </trans-unit>
        <trans-unit id="9ae61f13c66eb261147f9d4b1d89a27b5c697890" translate="yes" xml:space="preserve">
          <source>MANIFEST</source>
          <target state="translated">MANIFEST</target>
        </trans-unit>
        <trans-unit id="ee43e9094077d72c1da72a9a91b89d3593977bf3" translate="yes" xml:space="preserve">
          <source>MANIFEST ON CYGWIN</source>
          <target state="translated">CYGWIN의 매니페스트</target>
        </trans-unit>
        <trans-unit id="99aec53b52aee7fd41e057b43112a2b07b20b1fa" translate="yes" xml:space="preserve">
          <source>MANIFEST.SKIP</source>
          <target state="translated">MANIFEST.SKIP</target>
        </trans-unit>
        <trans-unit id="93ba9a2acb7ece879d6eae4b3780b55ff65e53c6" translate="yes" xml:space="preserve">
          <source>MANIFEST.bak</source>
          <target state="translated">MANIFEST.bak</target>
        </trans-unit>
        <trans-unit id="b315cd523ae2ef826dbad53529ba6c9c2ad21ff1" translate="yes" xml:space="preserve">
          <source>MAPPING</source>
          <target state="translated">MAPPING</target>
        </trans-unit>
        <trans-unit id="34a4dfce34585d297b90edd353506556851a5017" translate="yes" xml:space="preserve">
          <source>MATH</source>
          <target state="translated">MATH</target>
        </trans-unit>
        <trans-unit id="72a965b84fe5d8bf2c44aadc341ef716b1bb9f90" translate="yes" xml:space="preserve">
          <source>MATH LIBRARY</source>
          <target state="translated">수학 라이브러리</target>
        </trans-unit>
        <trans-unit id="f4b1c471ce1efbe25d7232b293140a21b7fea826" translate="yes" xml:space="preserve">
          <source>MEMORY</source>
          <target state="translated">MEMORY</target>
        </trans-unit>
        <trans-unit id="cdf5b879eba064baae0d94237dbf7820fdcbb018" translate="yes" xml:space="preserve">
          <source>MEMORY DEBUGGERS</source>
          <target state="translated">메모리 디버거</target>
        </trans-unit>
        <trans-unit id="e31b925235cc3be7fd5e0670fdc195273a9cff6f" translate="yes" xml:space="preserve">
          <source>MEMORY STORE</source>
          <target state="translated">메모리 저장</target>
        </trans-unit>
        <trans-unit id="c459b150dd079f2662d2dc95f57ad127cc7aa8df" translate="yes" xml:space="preserve">
          <source>META CHARACTERS</source>
          <target state="translated">메타 문자</target>
        </trans-unit>
        <trans-unit id="4a6da301633ce81aa21cac64ffb95d87c6894995" translate="yes" xml:space="preserve">
          <source>META.json</source>
          <target state="translated">META.json</target>
        </trans-unit>
        <trans-unit id="3b7f8f92275828b66b32cb6c6aeb61e73c1d7587" translate="yes" xml:space="preserve">
          <source>META.yml</source>
          <target state="translated">META.yml</target>
        </trans-unit>
        <trans-unit id="296be0aba5c6db10945a86505a9c35adbc0a5da7" translate="yes" xml:space="preserve">
          <source>METHOD CALLING</source>
          <target state="translated">메서드 호출</target>
        </trans-unit>
        <trans-unit id="7541f2ddbea83515621139a06393c2c41632b2df" translate="yes" xml:space="preserve">
          <source>METHODS</source>
          <target state="translated">METHODS</target>
        </trans-unit>
        <trans-unit id="3cb215be859943e6d7b15dec190189887d7849cd" translate="yes" xml:space="preserve">
          <source>METHODS FOR PARSING AND PROCESSING</source>
          <target state="translated">껍질을 벗기고 처리하는 방법</target>
        </trans-unit>
        <trans-unit id="bac1668d54ba3469d07436c3cb4d6c63921e8439" translate="yes" xml:space="preserve">
          <source>MILLIONS OF MACROS</source>
          <target state="translated">수백만의 매크로</target>
        </trans-unit>
        <trans-unit id="8c54fa1663ec8e58feaa0f76d0ad16806f96497d" translate="yes" xml:space="preserve">
          <source>MIME 'B' and 'Q' header encoding</source>
          <target state="translated">MIME 'B'및 'Q'헤더 인코딩</target>
        </trans-unit>
        <trans-unit id="f0186eb413ae0fe1b04a58826d46062c8207cd98" translate="yes" xml:space="preserve">
          <source>MIME (Multipurpose Internet Mail Extensions)</source>
          <target state="translated">MIME (다목적 인터넷 메일 확장)</target>
        </trans-unit>
        <trans-unit id="ced61424802296ffb38430fa8f0fab4da3883207" translate="yes" xml:space="preserve">
          <source>MIME::Base64</source>
          <target state="translated">MIME::Base64</target>
        </trans-unit>
        <trans-unit id="7fe3ea65bc04a88102c03df5c340d4e7c1520d18" translate="yes" xml:space="preserve">
          <source>MIME::Base64 - Encoding and decoding of base64 strings</source>
          <target state="translated">MIME :: Base64-base64 문자열의 인코딩 및 디코딩</target>
        </trans-unit>
        <trans-unit id="7ffae17f904a8de9b8c01b15e74d1504ffbc2043" translate="yes" xml:space="preserve">
          <source>MIME::QuotedPrint</source>
          <target state="translated">MIME::QuotedPrint</target>
        </trans-unit>
        <trans-unit id="65095920906e9bf0fe024eb72fdfbbe098341dd5" translate="yes" xml:space="preserve">
          <source>MIME::QuotedPrint - Encoding and decoding of quoted-printable strings</source>
          <target state="translated">MIME :: QuotedPrint-인용 인쇄 가능한 문자열의 인코딩 및 디코딩</target>
        </trans-unit>
        <trans-unit id="fbc28147d7dae55d07ef20379522673d2cd4aff7" translate="yes" xml:space="preserve">
          <source>MISCELLANEOUS</source>
          <target state="translated">MISCELLANEOUS</target>
        </trans-unit>
        <trans-unit id="0e2957d871def6ecf380e593a975af27f56d18ea" translate="yes" xml:space="preserve">
          <source>MISCELLANEOUS TRICKS</source>
          <target state="translated">기타 트릭</target>
        </trans-unit>
        <trans-unit id="8727bad0374de5d99b1e6473dee31baa8ae41493" translate="yes" xml:space="preserve">
          <source>MKTEMP FUNCTIONS</source>
          <target state="translated">MKTEMP 기능</target>
        </trans-unit>
        <trans-unit id="38de91e68bd653a65240e9601577373f8b2878b4" translate="yes" xml:space="preserve">
          <source>MM_REVISION: ExtUtils::MakeMaker version control revision (for backwards compat)</source>
          <target state="translated">MM_REVISION : ExtUtils :: MakeMaker 버전 관리 개정판 (후방 호환)</target>
        </trans-unit>
        <trans-unit id="065dc1eef187bb989bef804cda0869075be856b3" translate="yes" xml:space="preserve">
          <source>MM_VERSION: ExtUtils::MakeMaker Version</source>
          <target state="translated">MM_VERSION : ExtUtils :: MakeMaker 버전</target>
        </trans-unit>
        <trans-unit id="b630876e2ee4a66e53ca42c0024ca639bccd9170" translate="yes" xml:space="preserve">
          <source>MM_VMS_REVISION is for backwards compatibility before MM_VMS had a $VERSION.</source>
          <target state="translated">MM_VMS_REVISION은 MM_VMS가 $ VERSION을 갖기 전에 이전 버전과의 호환성을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="5a5019b6901ec4e0159788b99019a468b1278f03" translate="yes" xml:space="preserve">
          <source>MODE</source>
          <target state="translated">MODE</target>
        </trans-unit>
        <trans-unit id="11d727b07a2ef2f226c24b7b3ca7ffbcc8a440f3" translate="yes" xml:space="preserve">
          <source>MODIFICATION HISTORY</source>
          <target state="translated">수정 이력</target>
        </trans-unit>
        <trans-unit id="66bffe2295ae671e5d45439c77216938c792414b" translate="yes" xml:space="preserve">
          <source>MODULE</source>
          <target state="translated">MODULE</target>
        </trans-unit>
        <trans-unit id="a3e25a142bc9338d99e21ddb92754631acdb233f" translate="yes" xml:space="preserve">
          <source>MODULENAME is the Perl module name, e.g. Devel::SelfStubber, NOT 'Devel/SelfStubber' or 'Devel/SelfStubber.pm'.</source>
          <target state="translated">MODULENAME은 Perl 모듈 이름입니다 (예 : Devel :: SelfStubber, NOT 'Devel / SelfStubber'또는 'Devel / SelfStubber.pm').</target>
        </trans-unit>
        <trans-unit id="479396de59be987e42108d35e44f4b59dc1b4a9e" translate="yes" xml:space="preserve">
          <source>MODULES</source>
          <target state="translated">MODULES</target>
        </trans-unit>
        <trans-unit id="630e8cd715da84adcb106243940c860db346e2eb" translate="yes" xml:space="preserve">
          <source>MODULES USED</source>
          <target state="translated">사용되는 모듈</target>
        </trans-unit>
        <trans-unit id="c47b9589ffc380689e211aa66dac2ba8473cc24a" translate="yes" xml:space="preserve">
          <source>MONO CASE then sort data (for non-digits, non-underscore)</source>
          <target state="translated">MONO CASE 그런 다음 데이터를 정렬합니다 (숫자가 아닌 경우, 밑줄이 아닌 경우)</target>
        </trans-unit>
        <trans-unit id="b537891a9c0b5c8f4e6ee16a9ec71caca75f6730" translate="yes" xml:space="preserve">
          <source>MORAL</source>
          <target state="translated">MORAL</target>
        </trans-unit>
        <trans-unit id="bc4fc594140fde77e059ad4498ad554e3cbee3e9" translate="yes" xml:space="preserve">
          <source>MORE ELABORATE RECORDS</source>
          <target state="translated">더 우아한 기록</target>
        </trans-unit>
        <trans-unit id="64bf6c143dc817670181bbd264688b3acbcd5d5a" translate="yes" xml:space="preserve">
          <source>MORE EXAMPLES</source>
          <target state="translated">더 많은 예</target>
        </trans-unit>
        <trans-unit id="9ad9881a7f17afaec8c4ae609d85b1187596ee5b" translate="yes" xml:space="preserve">
          <source>MORE INFORMATION</source>
          <target state="translated">추가 정보</target>
        </trans-unit>
        <trans-unit id="76991e71012a76451fe2a0cc0849f44f697181ec" translate="yes" xml:space="preserve">
          <source>MORE READING FOR GUTS HACKERS</source>
          <target state="translated">건트 해커를위한 더 많은 독서</target>
        </trans-unit>
        <trans-unit id="abdd28bdcd2ff588ed4391e2849b71273a64ab04" translate="yes" xml:space="preserve">
          <source>MRO Functions</source>
          <target state="translated">MRO 기능</target>
        </trans-unit>
        <trans-unit id="304ff724cf80bd1102c4a52a83e37a5a11d51edf" translate="yes" xml:space="preserve">
          <source>MSG_BCAST, MSG_OOB, MSG_TRUNC, ...</source>
          <target state="translated">MSG_BCAST, MSG_OOB, MSG_TRUNC, ...</target>
        </trans-unit>
        <trans-unit id="95ed316aead6f0a90227220b98ed2c6a72173129" translate="yes" xml:space="preserve">
          <source>MSWin32 case-tolerance depends on GetVolumeInformation() $ouFsFlags == FS_CASE_SENSITIVE, indicating the case significance when comparing file specifications. Since XP FS_CASE_SENSITIVE is effectively disabled for the NT subsubsystem. See &lt;a href=&quot;http://cygwin.com/ml/cygwin/2007-07/msg00891.html&quot;&gt;http://cygwin.com/ml/cygwin/2007-07/msg00891.html&lt;/a&gt; Default: 1</source>
          <target state="translated">MSWin32 대 / 소문자 허용 여부는 GetVolumeInformation () $ ouFsFlags == FS_CASE_SENSITIVE에 따라 달라지며 파일 사양을 비교할 때 대소 문자의 중요성을 나타냅니다. XP FS_CASE_SENSITIVE는 NT 서브 시스템에 대해 효과적으로 사용 불가능하기 때문에. &lt;a href=&quot;http://cygwin.com/ml/cygwin/2007-07/msg00891.html&quot;&gt;http://cygwin.com/ml/cygwin/2007-07/msg00891.html을&lt;/a&gt; 참조하십시오 . 기본값 : 1</target>
        </trans-unit>
        <trans-unit id="46b420891abbe816108b89b151663fa05cb3b237" translate="yes" xml:space="preserve">
          <source>MULTI-OCTET CHARACTER SETS</source>
          <target state="translated">멀티 옥셋 캐릭터 세트</target>
        </trans-unit>
        <trans-unit id="112f1bc5464cbf86ad8abc28805d58542d252dc7" translate="yes" xml:space="preserve">
          <source>MUST decode</source>
          <target state="translated">반드시 디코딩해야합니다</target>
        </trans-unit>
        <trans-unit id="f3f97d4e65bbf8e05b9d2003dabed48039672a9b" translate="yes" xml:space="preserve">
          <source>MUST return the octet sequence representing</source>
          <target state="translated">다음을 나타내는 8 진수 시퀀스를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="f37495c410f3672ad3b7e5f75ff69fe1801eda14" translate="yes" xml:space="preserve">
          <source>MUST return the string representing the IANA charset name of the encoding.</source>
          <target state="translated">인코딩의 IANA 문자셋 이름을 나타내는 문자열을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="df44e8bf9f5bb85b1c861873578524b02eaca16a" translate="yes" xml:space="preserve">
          <source>MUST return the string representing the canonical name of the encoding.</source>
          <target state="translated">인코딩의 표준 이름을 나타내는 문자열을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="4a6d2a5fac9fc009e8ef2c66dccfa9c0e7765210" translate="yes" xml:space="preserve">
          <source>MUST return the string that</source>
          <target state="translated">그 문자열을 반환해야합니다</target>
        </trans-unit>
        <trans-unit id="8a1a4fa060cab0b9420887b26bf1330d0275e0dd" translate="yes" xml:space="preserve">
          <source>MYMETA.json</source>
          <target state="translated">MYMETA.json</target>
        </trans-unit>
        <trans-unit id="2f5e6a42d1d484cbbde0efe806d130305e765ea2" translate="yes" xml:space="preserve">
          <source>MYMETA.yml</source>
          <target state="translated">MYMETA.yml</target>
        </trans-unit>
        <trans-unit id="c92b11ff7ab5a4c5fd081db7883c7b3a71c6ef70" translate="yes" xml:space="preserve">
          <source>MY_CXT REFERENCE</source>
          <target state="translated">MY_CXT 참조</target>
        </trans-unit>
        <trans-unit id="61ad4287cd41e2e97ad96a7d5cba5a661af2c472" translate="yes" xml:space="preserve">
          <source>MY_LIB_DIR defaults to '.' if not present.</source>
          <target state="translated">MY_LIB_DIR의 기본값은 '.'입니다. 존재하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="9790a85a1a9e58a2ddd68bd085adb9c931b1b046" translate="yes" xml:space="preserve">
          <source>Mac OS 9 and earlier used &lt;code&gt;:&lt;/code&gt; as a path separator instead of &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="translated">맥 OS 9 및 앞서 사용 &lt;code&gt;:&lt;/code&gt; 대신 경로 구분자 &lt;code&gt;/&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9208982d7e71273ee9421bf88e0b53b6ad837f35" translate="yes" xml:space="preserve">
          <source>Mac OS X 10.5 &quot;Leopard&quot; and above do not require the 'u' variant.</source>
          <target state="translated">Mac OS X 10.5 &quot;Leopard&quot;이상에는 'u'변형이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="27e0400e4107eec8c9b3ecfab19987f0725198d4" translate="yes" xml:space="preserve">
          <source>Mac OS X documentation on syslog, &lt;a href=&quot;http://developer.apple.com/documentation/Darwin/Reference/ManPages/man3/syslog.3.html&quot;&gt;http://developer.apple.com/documentation/Darwin/Reference/ManPages/man3/syslog.3.html&lt;/a&gt;</source>
          <target state="translated">syslog에 대한 Mac OS X 설명서, &lt;a href=&quot;http://developer.apple.com/documentation/Darwin/Reference/ManPages/man3/syslog.3.html&quot;&gt;http://developer.apple.com/documentation/Darwin/Reference/ManPages/man3/syslog.3.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a4c0bf3f7dab7b087f55de5614ca5cbaddeea9b9" translate="yes" xml:space="preserve">
          <source>Mac OS X ships with a dynamically-loaded libperl, but the default for this release is to compile a static libperl. The reason for this is pre-binding. Dynamic libraries can be pre-bound to a specific address in memory in order to decrease load time. To do this, one needs to be aware of the location and size of all previously-loaded libraries. Apple collects this information as part of their overall OS build process, and thus has easy access to it when building Perl, but ordinary users would need to go to a great deal of effort to obtain the information needed for pre-binding.</source>
          <target state="translated">Mac OS X은 동적으로로드 된 libperl과 함께 제공되지만이 릴리스의 기본값은 정적 libperl을 컴파일하는 것입니다. 그 이유는 사전 바인딩입니다. 로드 시간을 줄이기 위해 메모리의 특정 주소에 동적 라이브러리를 사전 바인딩 할 수 있습니다. 이를 위해서는 이전에로드 된 모든 라이브러리의 위치와 크기를 알고 있어야합니다. Apple은 전체 OS 빌드 프로세스의 일부로이 정보를 수집하므로 Perl을 빌드 할 때 쉽게 액세스 할 수 있지만 일반 사용자는 사전 바인딩에 필요한 정보를 얻기 위해 많은 노력을 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="0343b2a40016db738fa670b19df9f47fc227d16f" translate="yes" xml:space="preserve">
          <source>Mac OS X.</source>
          <target state="translated">맥 OS X.</target>
        </trans-unit>
        <trans-unit id="e813bad999ce5a75f4490c8ed14ec07ab9d63a2d" translate="yes" xml:space="preserve">
          <source>Macro to declare an XSUB and its C parameter list explicitly exporting the symbols.</source>
          <target state="translated">XSUB 및 해당 C 매개 변수 목록을 선언하여 심볼을 명시 적으로 내보내는 매크로</target>
        </trans-unit>
        <trans-unit id="3f0040307b52caa52d747905fa724ed6b830cee4" translate="yes" xml:space="preserve">
          <source>Macro to declare an XSUB and its C parameter list without exporting the symbols. This is handled by &lt;code&gt;xsubpp&lt;/code&gt; and generally preferable over exporting the XSUB symbols unnecessarily.</source>
          <target state="translated">심볼을 내 보내지 않고 XSUB 및 해당 C 매개 변수 목록을 선언하는 매크로 이것은 &lt;code&gt;xsubpp&lt;/code&gt; 에 의해 처리되며 일반적으로 XSUB 심볼을 불필요하게 내보내는 것보다 바람직합니다.</target>
        </trans-unit>
        <trans-unit id="1376083aeef8a0b2b3a5461de74e71c6974c467b" translate="yes" xml:space="preserve">
          <source>Macro to declare an XSUB and its C parameter list. This is handled by &lt;code&gt;xsubpp&lt;/code&gt; . It is the same as using the more explicit XS_EXTERNAL macro.</source>
          <target state="translated">XSUB 및 해당 C 매개 변수 목록을 선언하는 매크로 이것은 &lt;code&gt;xsubpp&lt;/code&gt; 에 의해 처리됩니다 . 보다 명확한 XS_EXTERNAL 매크로를 사용하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7aea32d1102862e7b6b0c8089588079d1bf46bd9" translate="yes" xml:space="preserve">
          <source>Macro to verify that a PM module's $VERSION variable matches the XS module's &lt;code&gt;XS_VERSION&lt;/code&gt; variable. This is usually handled automatically by &lt;code&gt;xsubpp&lt;/code&gt; . See &lt;a href=&quot;perlxs#The-VERSIONCHECK%3a-Keyword&quot;&gt;The VERSIONCHECK: Keyword in perlxs&lt;/a&gt;.</source>
          <target state="translated">PM 모듈의 $ VERSION 변수가 XS 모듈의 &lt;code&gt;XS_VERSION&lt;/code&gt; 변수 와 일치하는지 확인하기위한 매크로 이것은 일반적으로 &lt;code&gt;xsubpp&lt;/code&gt; 에 의해 자동으로 처리됩니다 . &lt;a href=&quot;perlxs#The-VERSIONCHECK%3a-Keyword&quot;&gt;VERSIONCHECK : perlxs의 키워드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="66fb64fe6d247cc13c8ba2ecc02f6b2d75c4b93f" translate="yes" xml:space="preserve">
          <source>Macro to verify that the perl api version an XS module has been compiled against matches the api version of the perl interpreter it's being loaded into.</source>
          <target state="translated">XS 모듈이 컴파일 된 perl api 버전이로드되는 perl 인터프리터의 api 버전과 일치하는지 확인하는 매크로입니다.</target>
        </trans-unit>
        <trans-unit id="8f66f4521e615face2c94f9f782a4b88e0deefae" translate="yes" xml:space="preserve">
          <source>Macros that have string constants and their arguments as substrings of the string constants</source>
          <target state="translated">문자열 상수와 해당 인수가 문자열 상수의 하위 문자열 인 매크로</target>
        </trans-unit>
        <trans-unit id="696a489ce86f443d3bd7f260f57fe68b0f5e0740" translate="yes" xml:space="preserve">
          <source>Magic Autogeneration</source>
          <target state="translated">마술 자동 생성</target>
        </trans-unit>
        <trans-unit id="5b951438b2b5824d83645ebbc34942743d54e18e" translate="yes" xml:space="preserve">
          <source>Magic Variables</source>
          <target state="translated">마법 변수</target>
        </trans-unit>
        <trans-unit id="88fd65fe2e12d0229bfa9aa8c0f337c8c7a34525" translate="yes" xml:space="preserve">
          <source>Magic Virtual Tables</source>
          <target state="translated">매직 가상 테이블</target>
        </trans-unit>
        <trans-unit id="2de64b7079eac3534ed35bf9a982a56cf8fb08a0" translate="yes" xml:space="preserve">
          <source>Magic autogeneration increases the potential for inadvertently creating self-referential structures. Currently Perl will not free self-referential structures until cycles are explicitly broken. For example,</source>
          <target state="translated">매직 자동 생성 기능은 실수로 자기 참조 구조를 생성 할 가능성을 높입니다. 현재 Perl은주기가 명시 적으로 중단 될 때까지 자체 참조 구조를 해제하지 않습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="2e0ebd98fa5e6d797bebdd2c2d2dbacb085a7bcb" translate="yes" xml:space="preserve">
          <source>Magic constants</source>
          <target state="translated">마법 상수</target>
        </trans-unit>
        <trans-unit id="9331d05bb9a05caf542c2c62dec84da956dc266b" translate="yes" xml:space="preserve">
          <source>Magical Functions</source>
          <target state="translated">마법의 기능</target>
        </trans-unit>
        <trans-unit id="4bc605047ccd6740cec0a34132f6861a236ee5db" translate="yes" xml:space="preserve">
          <source>Magical values and references can be made into constants at compile time, allowing for way cool stuff like this. (These error numbers aren't totally portable, alas.)</source>
          <target state="translated">컴파일 할 때 마법의 값과 참조를 상수로 만들 수 있으므로 이와 같은 멋진 기능을 사용할 수 있습니다. (이러한 오류 번호는 완전히 이식 가능하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="df66650e348a506121860cd76f075780d1c6aedd" translate="yes" xml:space="preserve">
          <source>Mail and Usenet News</source>
          <target state="translated">메일 및 유즈넷 뉴스</target>
        </trans-unit>
        <trans-unit id="c9124b10840a3572bd767d51874576c37a45a513" translate="yes" xml:space="preserve">
          <source>MailList.U</source>
          <target state="translated">MailList.U</target>
        </trans-unit>
        <trans-unit id="56482927c5fda76aa41942ba11941327d4620c99" translate="yes" xml:space="preserve">
          <source>Mailing Lists and Newsgroups</source>
          <target state="translated">메일 링리스트 및 뉴스 그룹</target>
        </trans-unit>
        <trans-unit id="d2a1123e6461654a07e49c2ea0e3f5b116e7bf06" translate="yes" xml:space="preserve">
          <source>Mailing list</source>
          <target state="translated">메일 링리스트</target>
        </trans-unit>
        <trans-unit id="d50c2a333e418a4af64720c969c0846d34975a97" translate="yes" xml:space="preserve">
          <source>Mailing list for Perl on OS/390</source>
          <target state="translated">OS / 390의 Perl 메일 링리스트</target>
        </trans-unit>
        <trans-unit id="8422598c648ad701facadb193807fe8a68e5374e" translate="yes" xml:space="preserve">
          <source>Mailing list: cpan-testers-discuss@perl.org</source>
          <target state="translated">메일 링리스트 : cpan-testers-discuss@perl.org</target>
        </trans-unit>
        <trans-unit id="e42a6ff891c095b97c9c8d1876b99ab388267a2b" translate="yes" xml:space="preserve">
          <source>Mainly listed here to shut up the pitiful screams of the pod coverage tests. They keep me awake at night.</source>
          <target state="translated">포드 커버리지 테스트의 불쾌한 비명을 없애기 위해 주로 여기에 나열됩니다. 그들은 밤에 깨어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a025894cae9180557ea2537add4f6943dbc4f8b" translate="yes" xml:space="preserve">
          <source>Mainly used to exclude version control administrative directories from installation.</source>
          <target state="translated">버전 제어 관리 디렉토리를 설치에서 제외하는 데 주로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="af2040fc4cdf263d0853758e669e36927b733e94" translate="yes" xml:space="preserve">
          <source>Maintain Round Trip Integrity</source>
          <target state="translated">왕복 무결성 유지</target>
        </trans-unit>
        <trans-unit id="6cc92c03b00f2d20d0dd8de351bcdf848cd97ae9" translate="yes" xml:space="preserve">
          <source>Maintained by Ken Williams &amp;lt;KWILLIAMS@cpan.org&amp;gt;</source>
          <target state="translated">Ken Williams가 관리함 &amp;lt;KWILLIAMS@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="809e72cee268c819612dba25360f847662fc4877" translate="yes" xml:space="preserve">
          <source>Maintained by Michael G Schwern</source>
          <target state="translated">Michael G Schwern이 관리</target>
        </trans-unit>
        <trans-unit id="3d8d67b0bc713d08e1431289fef2c4da24e0a6d9" translate="yes" xml:space="preserve">
          <source>Maintained by Michael G Schwern &lt;code&gt;schwern@pobox.com&lt;/code&gt; within the ExtUtils-MakeMaker package and, as a separate CPAN package, by Randy Kobes &lt;code&gt;r.kobes@uwinnipeg.ca&lt;/code&gt; .</source>
          <target state="translated">ExtUtils-MakeMaker 패키지 내에서 Michael G Schwern &lt;code&gt;schwern@pobox.com&lt;/code&gt; 및 별도의 CPAN 패키지로 Randy Kobes &lt;code&gt;r.kobes@uwinnipeg.ca&lt;/code&gt; 에서 관리 합니다.</target>
        </trans-unit>
        <trans-unit id="66e8214c4bf741c76a84a61b0611d2148c0182fd" translate="yes" xml:space="preserve">
          <source>Maintained by:</source>
          <target state="translated">유지 관리 :</target>
        </trans-unit>
        <trans-unit id="0fb7ae643e6e22eda1f0c20766a595198d76696b" translate="yes" xml:space="preserve">
          <source>Maintained since 1996 by The Perl Porters &amp;lt;</source>
          <target state="translated">1996 년부터 Perl Porters가 유지 보수 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="643bbd5f57059016b08fdfc7624d83297d263211" translate="yes" xml:space="preserve">
          <source>Maintainer note:</source>
          <target state="translated">관리자 참고 사항 :</target>
        </trans-unit>
        <trans-unit id="8a3300746df857e116a8c0e1c6dce416561209ca" translate="yes" xml:space="preserve">
          <source>Maintainer of the CPAN release is Steffen Mueller &amp;lt;smueller@cpan.org&amp;gt;. Contact him with technical difficulties with respect to the packaging of the CPAN module.</source>
          <target state="translated">CPAN 릴리스의 관리자는 Steffen Mueller &amp;lt;smueller@cpan.org&amp;gt;입니다. CPAN 모듈의 포장과 관련하여 기술적 인 어려움이있는 경우에는 해당 담당자에게 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="430b90ac2c360a8a68d16871970bc138c6d2cbdd" translate="yes" xml:space="preserve">
          <source>Maintainer of the CPAN release is Steffen Mueller (smueller@cpan.org). Contact him with technical difficulties with respect to the packaging of the CPAN module.</source>
          <target state="translated">CPAN 릴리스의 관리자는 Steffen Mueller (smueller@cpan.org)입니다. CPAN 모듈의 포장과 관련하여 기술적 인 어려움이있는 경우에는 해당 담당자에게 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="b4afb7f985f5bfec03da261851d526768b0a7bd1" translate="yes" xml:space="preserve">
          <source>Maintainer of the CPAN release: Steffen Mueller &amp;lt;smueller@cpan.org&amp;gt;</source>
          <target state="translated">CPAN 릴리스 관리자 : Steffen Mueller &amp;lt;smueller@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="53ca95cbad19caeb958b071a4ed842e8b82f2816" translate="yes" xml:space="preserve">
          <source>Maintainer: Alexandr Ciornii &amp;lt;alexchornyATgmail.com&amp;gt;.</source>
          <target state="translated">관리자 : Alexandr Ciornii &amp;lt;alexchornyATgmail.com&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="619bd6770e2cd62e7bc43b49020d0710c816e356" translate="yes" xml:space="preserve">
          <source>Maintainer: The Perl5-Porters &amp;lt;perl5-porters@perl.org&amp;gt;</source>
          <target state="translated">관리자 : Perl5-Porters &amp;lt;perl5-porters@perl.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9c61980ffa7774c0d3835c4f170771e00a8354d6" translate="yes" xml:space="preserve">
          <source>Maintaining a bundle definition file means keeping track of two things: dependencies and interactivity. CPAN.pm sometimes fails on calculating dependencies because not all modules define all MakeMaker attributes correctly, so a bundle definition file should specify prerequisites as early as possible. On the other hand, it's annoying that so many distributions need some interactive configuring. So what you can try to accomplish in your private bundle file is to have the packages that need to be configured early in the file and the gentle ones later, so you can go out for coffee after a few minutes and leave CPAN.pm to churn away unattended.</source>
          <target state="translated">번들 정의 파일을 유지 관리한다는 것은 종속성과 상호 작용이라는 두 가지 사항을 추적하는 것을 의미합니다. 모든 모듈이 모든 MakeMaker 속성을 올바르게 정의하지는 않기 때문에 CPAN.pm이 종속성 계산에 실패하는 경우가 있으므로 번들 정의 파일은 사전 요구 사항을 가능한 빨리 지정해야합니다. 반면에, 많은 배포판에 대화식 구성이 필요한 것은 성가신 일입니다. 따라서 개인 번들 파일에서 달성하려고 할 수있는 것은 파일의 초기에 구성해야하는 패키지와 나중에 부드러운 패키지를 갖는 것입니다. 따라서 몇 분 후에 커피를 마시고 CPAN.pm을 이탈 할 수 있습니다. 무인 상태로.</target>
        </trans-unit>
        <trans-unit id="683b0250521f89ab5a7d8609ffca71e78293a058" translate="yes" xml:space="preserve">
          <source>Maintaining a persistent interpreter</source>
          <target state="translated">지속적인 통역사 유지</target>
        </trans-unit>
        <trans-unit id="e88a9990f5d2ac06c40799dcdbc0bd3efadf5b36" translate="yes" xml:space="preserve">
          <source>Maintaining multiple interpreter instances</source>
          <target state="translated">여러 개의 인터프리터 인스턴스 유지</target>
        </trans-unit>
        <trans-unit id="b029f6d7dda6875610cf345a0d379a80456960cd" translate="yes" xml:space="preserve">
          <source>Maintaining the urllist parameter</source>
          <target state="translated">urllist 매개 변수 유지 보수</target>
        </trans-unit>
        <trans-unit id="ecb8b463e1c71f307f7fc72628792a15f4e1bd31" translate="yes" xml:space="preserve">
          <source>Maintenance is now done by the perl5-porters</source>
          <target state="translated">perl5 포터가 유지 보수를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="a94431ee22f05f141107f9355ed3127d0f0c4d5a" translate="yes" xml:space="preserve">
          <source>Make</source>
          <target state="translated">Make</target>
        </trans-unit>
        <trans-unit id="04eff5d74d7ffc64b3c7d9b1b09aff266f1e0a57" translate="yes" xml:space="preserve">
          <source>Make a bootstrap file for use by DynaLoader</source>
          <target state="translated">DynaLoader에서 사용할 부트 스트랩 파일 만들기</target>
        </trans-unit>
        <trans-unit id="5a9fad7783334940c292ba0169f35e46fcaae627" translate="yes" xml:space="preserve">
          <source>Make a lightweight callback. See &lt;a href=&quot;perlcall#LIGHTWEIGHT-CALLBACKS&quot;&gt;LIGHTWEIGHT CALLBACKS in perlcall&lt;/a&gt;.</source>
          <target state="translated">가벼운 콜백을 만드십시오. &lt;a href=&quot;perlcall#LIGHTWEIGHT-CALLBACKS&quot;&gt;perlcall의 LIGHTWEIGHT CALLBACKS를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2b212bd484216f27062e119a0984e12eb2f1ca4b" translate="yes" xml:space="preserve">
          <source>Make a new &lt;a href=&quot;parser/grammar&quot;&gt;TAP::Parser::Grammar&lt;/a&gt; object and return it. Passes through any arguments given.</source>
          <target state="translated">새로운 &lt;a href=&quot;parser/grammar&quot;&gt;TAP :: Parser :: Grammar&lt;/a&gt; 객체를 만들어 반환합니다. 주어진 인수를 모두 통과합니다.</target>
        </trans-unit>
        <trans-unit id="d5ad132f57df20c380d03727edf6efc89d530812" translate="yes" xml:space="preserve">
          <source>Make a new &lt;a href=&quot;parser/iteratorfactory&quot;&gt;TAP::Parser::IteratorFactory&lt;/a&gt; object and return it. Passes through any arguments given.</source>
          <target state="translated">새로운 &lt;a href=&quot;parser/iteratorfactory&quot;&gt;TAP :: Parser :: IteratorFactory&lt;/a&gt; 객체를 만들어 반환합니다. 주어진 인수를 모두 통과합니다.</target>
        </trans-unit>
        <trans-unit id="fa28fa8c90cb86c9b3f8c83899652b5dd29ba4e0" translate="yes" xml:space="preserve">
          <source>Make a new &lt;a href=&quot;parser/result&quot;&gt;TAP::Parser::Result&lt;/a&gt; object using the parser's &lt;a href=&quot;parser/resultfactory&quot;&gt;TAP::Parser::ResultFactory&lt;/a&gt;, and return it. Passes through any arguments given.</source>
          <target state="translated">파서의 &lt;a href=&quot;parser/resultfactory&quot;&gt;TAP :: Parser :: ResultFactory를&lt;/a&gt; 사용하여 새로운 &lt;a href=&quot;parser/result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; 객체를 만들어 반환합니다. 주어진 인수를 모두 통과합니다.</target>
        </trans-unit>
        <trans-unit id="3a0cb5edb690cd6db709e001b8158abfba90d3f9" translate="yes" xml:space="preserve">
          <source>Make a new parser and display formatter session. Typically used and/or overridden in subclasses.</source>
          <target state="translated">새로운 파서 및 디스플레이 포맷터 세션을 만듭니다. 일반적으로 서브 클래스에서 사용 및 / 또는 재정의됩니다.</target>
        </trans-unit>
        <trans-unit id="f4f6bf31d70d3b5261f262791889974009fba962" translate="yes" xml:space="preserve">
          <source>Make and return a complete copy of the cop hints hash</source>
          <target state="translated">경찰 힌트 해시의 전체 사본을 만들어 반환</target>
        </trans-unit>
        <trans-unit id="5b886b01d91d82d72977b5c37dc6c5f47e7167a8" translate="yes" xml:space="preserve">
          <source>Make bsd_glob() return an error (GLOB_NOSPACE) when the pattern expands to a size bigger than the system constant &lt;code&gt;ARG_MAX&lt;/code&gt; (usually found in limits.h). If your system does not define this constant, bsd_glob() uses &lt;code&gt;sysconf(_SC_ARG_MAX)&lt;/code&gt; or &lt;code&gt;_POSIX_ARG_MAX&lt;/code&gt; where available (in that order). You can inspect these values using the standard &lt;code&gt;POSIX&lt;/code&gt; extension.</source>
          <target state="translated">패턴이 시스템 상수 &lt;code&gt;ARG_MAX&lt;/code&gt; (보통 limits.h에 있음) 보다 큰 크기로 확장 될 때 bsd_glob ()가 오류 (GLOB_NOSPACE)를 리턴하게하십시오 . 시스템이이 상수를 정의하지 않으면 bsd_glob ()는 사용 가능한 경우 (순서대로) &lt;code&gt;sysconf(_SC_ARG_MAX)&lt;/code&gt; 또는 &lt;code&gt;_POSIX_ARG_MAX&lt;/code&gt; 를 사용합니다. 표준 &lt;code&gt;POSIX&lt;/code&gt; 확장을 사용하여이 값을 검사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="08523af5b76fef9eaed2b77615eb4a213597d67b" translate="yes" xml:space="preserve">
          <source>Make functions faster by trading space for time</source>
          <target state="translated">시간을위한 공간을 거래하여 더 빠른 기능</target>
        </trans-unit>
        <trans-unit id="4b434c4028abbf501b87f9ee8429bc6772c12c60" translate="yes" xml:space="preserve">
          <source>Make perl executable and create a symlink for libperl:</source>
          <target state="translated">perl을 실행 가능하게하고 libperl에 대한 symlink를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="631c39697ec2fc47f9fdac3b73868b5eac8535e4" translate="yes" xml:space="preserve">
          <source>Make sure &lt;code&gt;&lt;a href=&quot;functions/gethostbyname&quot;&gt;gethostbyname()&lt;/a&gt;&lt;/code&gt; is called in SCALAR context and that its return value is checked for definedness.</source>
          <target state="translated">확인 &lt;code&gt;&lt;a href=&quot;functions/gethostbyname&quot;&gt;gethostbyname()&lt;/a&gt;&lt;/code&gt; 스칼라 문맥에서 그 리턴 값이 definedness을 위해 선택되어 있는지이라고합니다.</target>
        </trans-unit>
        <trans-unit id="1af92bfd9067c908f166333d8740f6095af6a588" translate="yes" xml:space="preserve">
          <source>Make sure &lt;code&gt;&lt;a href=&quot;gethostbyname&quot;&gt;gethostbyname()&lt;/a&gt;&lt;/code&gt; is called in SCALAR context and that its return value is checked for definedness.</source>
          <target state="translated">확인 &lt;code&gt;&lt;a href=&quot;gethostbyname&quot;&gt;gethostbyname()&lt;/a&gt;&lt;/code&gt; 스칼라 문맥에서 그 리턴 값이 definedness을 위해 선택되어 있는지이라고합니다.</target>
        </trans-unit>
        <trans-unit id="9aee806c3df793514446c4364ffe009cca7c0176" translate="yes" xml:space="preserve">
          <source>Make sure that &lt;code&gt;CPAN.pm&lt;/code&gt; can download files from CPAN. If not, you may need to manually install &lt;code&gt;Net::FTP&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;CPAN.pm&lt;/code&gt; 이 CPAN에서 파일을 다운로드 할 수 있는지 확인하십시오 . 그렇지 않은 경우 &lt;code&gt;Net::FTP&lt;/code&gt; 를 수동으로 설치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d90bf5e032808a1790937eefc282a0216577eb91" translate="yes" xml:space="preserve">
          <source>Make sure that the directory &lt;b&gt;above&lt;/b&gt; the directory with manpages is on our &lt;code&gt;MANPATH&lt;/code&gt; , like this</source>
          <target state="translated">디렉토리에 있는지 확인하십시오 &lt;b&gt;위의&lt;/b&gt; 맨 페이지와 디렉토리가 우리에 &lt;code&gt;MANPATH&lt;/code&gt; 같이,</target>
        </trans-unit>
        <trans-unit id="6d62a68cc52f846e8b7cd7e34bad20513f656424" translate="yes" xml:space="preserve">
          <source>Make sure that the installed modules are actually installed in the location of the new Perl, and are not inherited from entries of @INC given for inheritance from the older versions of Perl: set &lt;code&gt;PERLLIB_582_PREFIX&lt;/code&gt; to redirect the new version of Perl to a new location, and copy the installed files to this new location. Redo the tests to make sure that the versions of modules inherited from older versions of Perl are not needed.</source>
          <target state="translated">설치된 모듈이 실제로 새 Perl의 위치에 설치되어 있고 이전 버전의 Perl에서 상속하도록 제공된 @INC 항목에서 상속되지 않았는지 확인하십시오. Perl 의 새 버전을 새 위치로 경로 재 지정하려면 &lt;code&gt;PERLLIB_582_PREFIX&lt;/code&gt; 를 설정 하십시오 . 설치된 파일을이 새 위치로 복사하십시오. 테스트를 다시 실행하여 이전 버전의 Perl에서 상속 된 모듈 버전이 필요하지 않은지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="8e40ae3a79feffa50f9360f35cfc29b12c2563ad" translate="yes" xml:space="preserve">
          <source>Make sure that you &lt;code&gt;make realclean&lt;/code&gt; in your copy of Perl to remove any build artifacts, or you may get a confusing result.</source>
          <target state="translated">빌드 아티팩트를 제거하기 위해 Perl 사본을 실제로 &lt;code&gt;make realclean&lt;/code&gt; 하십시오 . 그렇지 않으면 혼란스러운 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c48620eee0813f53db06b1d13fb05c7d0b30ec92" translate="yes" xml:space="preserve">
          <source>Make sure that your module has a license, and that the full text of it is included in the distribution (unless it's a common one and the terms of the license don't require you to include it).</source>
          <target state="translated">모듈에 라이센스가 있는지 확인하고 배포에 포함 된 전체 텍스트가 배포에 포함되어 있는지 확인하십시오 (일반적인 라이센스 조건에 포함하지 않아도 됨).</target>
        </trans-unit>
        <trans-unit id="b4b22689c7f11757036113b227d7cdc8128156e0" translate="yes" xml:space="preserve">
          <source>Make sure the commit message describes your change in a single sentence. For example, &quot;Fixed spelling errors in perlhack.pod&quot;.</source>
          <target state="translated">커밋 메시지가 한 문장으로 변경 사항을 설명하는지 확인하십시오. 예를 들어 &quot;perlhack.pod의 맞춤법 오류가 수정되었습니다.&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="31c004e759b68f9d5539083901242f08c624a89b" translate="yes" xml:space="preserve">
          <source>Make sure the newlines for the modules are in Mac format, not Unix format. If they are not then you might have decompressed them incorrectly. Check your decompression and unpacking utilities settings to make sure they are translating text files properly.</source>
          <target state="translated">모듈의 줄 바꿈이 Unix 형식이 아닌 Mac 형식인지 확인하십시오. 그렇지 않은 경우 압축이 제대로 풀리지 않았을 수 있습니다. 압축 해제 및 포장 풀기 유틸리티 설정이 텍스트 파일을 올바르게 번역하고 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="0da095bfcf60a5da0d5078d4fb200d212838fa47" translate="yes" xml:space="preserve">
          <source>Make sure the patch is not reversed (the first argument to diff is typically the original file, the second argument your changed file). Make sure you test your patch by applying it with &lt;code&gt;git am&lt;/code&gt; or the &lt;code&gt;patch&lt;/code&gt; program before you send it on its way. Try to follow the same style as the code you are trying to patch. Make sure your patch really does work (&lt;code&gt;make test&lt;/code&gt; , if the thing you're patching is covered by Perl's test suite).</source>
          <target state="translated">패치가 반전되지 않았는지 확인하십시오 (diff의 첫 번째 인수는 일반적으로 원본 파일이고 두 번째 인수는 변경된 파일입니다). 패치를 적용하여 패치를 테스트하십시오 &lt;code&gt;git am&lt;/code&gt; 또는 &lt;code&gt;patch&lt;/code&gt; 프로그램 하여 패치 를 보내기 전에 . 패치하려는 코드와 동일한 스타일을 따르십시오. 반드시 여러분의 패치 진짜로 일 (확인 &lt;code&gt;make test&lt;/code&gt; , 것은 당신이있는 거 패치가 펄의 테스트 스위트에 포함되어있는 경우)를.</target>
        </trans-unit>
        <trans-unit id="6fe3ef49c50e09399f8e7e0ae50f650120ed9ba3" translate="yes" xml:space="preserve">
          <source>Make sure the path to the build directory does not contain spaces. The build usually works in this circumstance, but some tests will fail.</source>
          <target state="translated">빌드 디렉토리 경로에 공백이 없는지 확인하십시오. 빌드는 일반적으로이 상황에서 작동하지만 일부 테스트는 실패합니다.</target>
        </trans-unit>
        <trans-unit id="b25e9d6769a32bda0cb16adea51fc9a9577bd44e" translate="yes" xml:space="preserve">
          <source>Make sure to read about creating modules in &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; and the perils of indirect objects in &lt;a href=&quot;perlobj#Method-Invocation&quot;&gt;Method Invocation in perlobj&lt;/a&gt;.</source>
          <target state="translated">에 모듈 만들기에 대해 읽어보십시오 &lt;a href=&quot;perlmod&quot;&gt;&lt;/a&gt;&lt;a href=&quot;perlobj#Method-Invocation&quot;&gt;perlobj의 메소드 호출에서 &lt;/a&gt;perlmod 및 간접 오브젝트의 위험에 .</target>
        </trans-unit>
        <trans-unit id="c9bbcc12fd16263e19bc5318e960269249316b2e" translate="yes" xml:space="preserve">
          <source>Make sure you are in the &quot;win32&quot; subdirectory under the perl toplevel. This directory contains a &quot;Makefile&quot; that will work with versions of nmake that come with Visual C++ or the Windows SDK, and a dmake &quot;makefile.mk&quot; that will work for all supported compilers. The defaults in the dmake makefile are setup to build using MinGW/gcc.</source>
          <target state="translated">perl 최상위 레벨의 &quot;win32&quot;서브 디렉토리에 있는지 확인하십시오. 이 디렉토리에는 Visual C ++ 또는 Windows SDK와 함께 제공되는 nmake 버전과 작동하는 &quot;Makefile&quot;및 지원되는 모든 컴파일러에서 작동하는 dmake &quot;makefile.mk&quot;가 포함되어 있습니다. dmake makefile의 기본값은 MinGW / gcc를 사용하여 빌드하도록 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b578a0bba566a5e009cf7a1e8f93afb16265f4fa" translate="yes" xml:space="preserve">
          <source>Make sure you choose an appropriate name for your module early on. This will help people find and remember your module, and make programming with your module more intuitive.</source>
          <target state="translated">초기에 모듈에 적절한 이름을 선택하십시오. 이를 통해 사람들은 모듈을 찾고 기억하며 모듈을 사용하여 프로그래밍을보다 직관적으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8dca7eb87954059e67d6baf9d117854dccfc284" translate="yes" xml:space="preserve">
          <source>Make sure you have MMS (from Digital) or the freeware MMK ( available from MadGoat at &lt;a href=&quot;http://www.madgoat.com&quot;&gt;http://www.madgoat.com&lt;/a&gt; ). Then type this to create the DESCRIP.MMS for the module:</source>
          <target state="translated">MMS (디지털) 또는 프리웨어 MMK (MadGoat ( &lt;a href=&quot;http://www.madgoat.com&quot;&gt;http://www.madgoat.com)&lt;/a&gt; 에서 제공)가 있는지 확인하십시오 . ) . 그런 다음 이것을 입력하여 모듈에 대한 DESCRIP.MMS를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="45bcb550cc19143c5e8dd91291c0c6d1da90642e" translate="yes" xml:space="preserve">
          <source>Make sure you have the appropriate permissions to install the module in your Perl 5 library directory. Often, you'll need to be root.</source>
          <target state="translated">Perl 5 라이브러리 디렉토리에 모듈을 설치할 수있는 적절한 권한이 있는지 확인하십시오. 종종 루트가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="8c6288609b67d4900e3a7acdb0708c647b7ddea0" translate="yes" xml:space="preserve">
          <source>Make sure you use a tab and not spaces on the lines beginning with &quot;$(AR)&quot; and &quot;$(RANLIB)&quot;. Make will not function properly if you use spaces. It has also been reported that the &quot;cr&quot; argument to $(AR) is unnecessary on Win32 systems.</source>
          <target state="translated">&quot;$ (AR)&quot;및 &quot;$ (RANLIB)&quot;로 시작하는 줄에는 공백이 아닌 탭을 사용해야합니다. 공백을 사용하면 Make가 제대로 작동하지 않습니다. 또한 Win32 시스템에서 $ (AR)에 대한 &quot;cr&quot;인수가 필요하지 않다고보고되었습니다.</target>
        </trans-unit>
        <trans-unit id="6aa0752b0b4c6627413012df0488bf1ad6b435f3" translate="yes" xml:space="preserve">
          <source>Make sure your PATH includes the compiler (/opt/SUNWspro/bin/ if you're using Sun's compiler) as well as /usr/ccs/bin/ to pick up the other development tools (such as make, ar, as, and ld). Make sure your path either doesn't include /usr/ucb or that it includes it after the compiler and compiler tools and other standard Solaris directories. You definitely don't want /usr/ucb/cc.</source>
          <target state="translated">PATH에 다른 개발 도구 (예 : make, ar, as 및 ld). 경로에 / usr / ucb가 포함되어 있지 않거나 컴파일러 및 컴파일러 도구 및 기타 표준 Solaris 디렉토리 다음에 경로가 포함되어 있는지 확인하십시오. / usr / ucb / cc를 원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="da98ff8151fcc7f9259493c3bc630b4f6abd18b6" translate="yes" xml:space="preserve">
          <source>Make sure your gcc is good for &lt;code&gt;-Zomf&lt;/code&gt; linking: run &lt;code&gt;omflibs&lt;/code&gt; script in</source>
          <target state="translated">gcc가 &lt;code&gt;-Zomf&lt;/code&gt; 연결에 적합한 지 확인 : &lt;code&gt;omflibs&lt;/code&gt; 실행 스크립트에</target>
        </trans-unit>
        <trans-unit id="a248163580a9e29ef4a7312495856815f271337b" translate="yes" xml:space="preserve">
          <source>Make the first argument a copy of the second, then delete the original. The target SV physically takes over ownership of the body of the source SV and inherits its flags; however, the target keeps any magic it owns, and any magic in the source is discarded. Note that this is a rather specialist SV copying operation; most of the time you'll want to use &lt;code&gt;sv_setsv&lt;/code&gt; or one of its many macro front-ends.</source>
          <target state="translated">첫 번째 인수를 두 번째 인수로 복사 한 다음 원본을 삭제하십시오. 대상 SV는 물리적으로 소스 SV 본문의 소유권을 인수하고 해당 플래그를 상속합니다. 그러나 대상은 자신이 소유 한 마법을 유지하고 소스의 마법은 버립니다. 이것은 다소 전문적인 SV 복사 작업입니다. 대부분의 경우 &lt;code&gt;sv_setsv&lt;/code&gt; 또는 많은 매크로 프론트 엔드 중 하나 를 사용하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="f4bb5d8584647cb5cbfe371da2ee93cc6742e08f" translate="yes" xml:space="preserve">
          <source>Make the most of the opportunity.</source>
          <target state="translated">기회를 최대한 활용하십시오.</target>
        </trans-unit>
        <trans-unit id="87a3a748935c5363a3cfdc69fbfc39c4592f4900" translate="yes" xml:space="preserve">
          <source>Make the string $content be the content for the file named $file.</source>
          <target state="translated">문자열 $ content를 $ file이라는 파일의 내용으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="b14a5a45500c708bfc2adecf45938f8ddfc95c0a" translate="yes" xml:space="preserve">
          <source>Make updating the '1..42' string unnecessary. Or make sure that you update it.</source>
          <target state="translated">'1..42'문자열을 업데이트하지 않아도됩니다. 또는 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="951e86d639f2ed613d02f1c077ce05396f017abb" translate="yes" xml:space="preserve">
          <source>MakeMaker (as of 6.31) and Module::Build (as of 0.28) both can install to the same locations using the &quot;install_base&quot; concept. See &lt;a href=&quot;../makemaker#INSTALL_BASE&quot;&gt;INSTALL_BASE in ExtUtils::MakeMaker&lt;/a&gt; for details. To get MM and MB to install to the same location simply set INSTALL_BASE in MM and &lt;code&gt;--install_base&lt;/code&gt; in MB to the same location.</source>
          <target state="translated">MakeMaker (6.31 현재) 및 Module :: Build (0.28 현재)는 &quot;install_base&quot;개념을 사용하여 동일한 위치에 설치할 수 있습니다. 자세한 내용 &lt;a href=&quot;../makemaker#INSTALL_BASE&quot;&gt;은 ExtUtils :: MakeMaker의 INSTALL_BASE를&lt;/a&gt; 참조 하십시오. MM과 MB를 같은 위치에 설치하려면 MM의 INSTALL_BASE와 MB의 &lt;code&gt;--install_base&lt;/code&gt; 를 같은 위치로 설정 하면됩니다.</target>
        </trans-unit>
        <trans-unit id="f57976a42f4d4f108960d3047b05d9b0bd7410ad" translate="yes" xml:space="preserve">
          <source>MakeMaker also checks for any files matching glob(&quot;t/*.t&quot;). It will execute all matching files in alphabetical order via the &lt;a href=&quot;../test/harness&quot;&gt;Test::Harness&lt;/a&gt; module with the &lt;code&gt;-I&lt;/code&gt; switches set correctly.</source>
          <target state="translated">MakeMaker는 glob ( &quot;t / *. t&quot;)와 일치하는 파일도 확인합니다. &lt;code&gt;-I&lt;/code&gt; 스위치가 올바르게 설정된 &lt;a href=&quot;../test/harness&quot;&gt;Test :: Harness&lt;/a&gt; 모듈을 통해 일치하는 모든 파일을 알파벳 순서로 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="ea4d9ecb21fe83e2ef44aa02cc6eba3ee3c63cf7" translate="yes" xml:space="preserve">
          <source>MakeMaker also honors the MAKE environment variable. This parameter takes precedence.</source>
          <target state="translated">MakeMaker는 또한 MAKE 환경 변수를 존중합니다. 이 매개 변수가 우선합니다.</target>
        </trans-unit>
        <trans-unit id="6ce95146fa946e6764eac19b0f7702edb2af3abd" translate="yes" xml:space="preserve">
          <source>MakeMaker can run programs to generate files for you at build time. By default any file named *.PL (except Makefile.PL and Build.PL) in the top level directory will be assumed to be a Perl program and run passing its own basename in as an argument. For example...</source>
          <target state="translated">MakeMaker는 빌드시 프로그램을 실행하여 파일을 생성 할 수 있습니다. 기본적으로 최상위 레벨 디렉토리에 * .PL이라는 이름의 파일 (Makefile.PL 및 Build.PL 제외)은 Perl 프로그램으로 간주되며 자체 기본 이름을 인수로 전달하여 실행됩니다. 예를 들어 ...</target>
        </trans-unit>
        <trans-unit id="f4a59e2381035838e81553acd07a6dbd71a643d2" translate="yes" xml:space="preserve">
          <source>MakeMaker checks for the existence of a file named</source>
          <target state="translated">MakeMaker는 이름이 지정된 파일이 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="7e46986c8cad84d029006573feccd2e12b58af53" translate="yes" xml:space="preserve">
          <source>MakeMaker comes with a default MANIFEST.SKIP to avoid things like version control directories and backup files. Specifying your own will override this default.</source>
          <target state="translated">버전 관리 디렉토리 및 백업 파일과 같은 것을 피하기 위해 MakeMaker에는 기본 MANIFEST.SKIP가 제공됩니다. 자신을 지정하면이 기본값이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="9177c899e90b4ecb1a9e016234bba13b638eedd6" translate="yes" xml:space="preserve">
          <source>MakeMaker gives you much more freedom than needed to configure internal variables and get different results. It is worth mentioning that make(1) also lets you configure most of the variables that are used in the Makefile. But in the majority of situations this will not be necessary, and should only be done if the author of a package recommends it (or you know what you're doing).</source>
          <target state="translated">MakeMaker는 내부 변수를 구성하고 다른 결과를 얻는 데 필요한 것보다 훨씬 많은 자유를 제공합니다. make (1)을 사용하면 Makefile에 사용되는 대부분의 변수를 구성 할 수 있습니다. 그러나 대부분의 상황에서 이것은 필요하지 않으며 패키지 작성자가 권장하는 경우에만 수행해야합니다 (또는 사용자가 수행중인 작업을 알고 있음).</target>
        </trans-unit>
        <trans-unit id="666dfa9a2df2803aca52ee89b75129726d38981a" translate="yes" xml:space="preserve">
          <source>MakeMaker modules are installed using this simple mantra</source>
          <target state="translated">이 간단한 만트라를 사용하여 MakeMaker 모듈이 설치됩니다</target>
        </trans-unit>
        <trans-unit id="6eebe1cd37eee2ec321b36b14411ecc5f97674e6" translate="yes" xml:space="preserve">
          <source>MakeMaker needs to know, or to guess, where certain things are located. Especially INST_LIB and INST_ARCHLIB (where to put the files during the make(1) run), PERL_LIB and PERL_ARCHLIB (where to read existing modules from), and PERL_INC (header files and &lt;code&gt;libperl*.*&lt;/code&gt;).</source>
          <target state="translated">MakeMaker는 특정 물건의 위치를 ​​알고 있거나 추측해야합니다. 특히 INST_LIB 및 INST_ARCHLIB (make (1) 실행 중에 파일을 넣을 위치), PERL_LIB 및 PERL_ARCHLIB (기존 모듈을 읽을 위치) 및 PERL_INC (헤더 파일 및 &lt;code&gt;libperl*.*&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="955e1b765c6718c7db11e68ac1240b76cf36838e" translate="yes" xml:space="preserve">
          <source>MakeMaker will figure out if an extension contains linkable code anywhere down the directory tree, and will set this variable accordingly, but you can speed it up a very little bit if you define this boolean variable yourself.</source>
          <target state="translated">MakeMaker는 디렉토리 트리 아래에 링크 가능한 코드가 확장에 포함되어 있는지 확인하고 그에 따라이 변수를 설정하지만이 부울 변수를 직접 정의하면 속도를 약간 높일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bbacb6ac277a541e0abc4615218907895ae391a" translate="yes" xml:space="preserve">
          <source>MakeMaker will turn it into an array with one element.</source>
          <target state="translated">MakeMaker는 하나의 요소를 가진 배열로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e6de50a7c31889077966d7620ec5db61a68c67cc" translate="yes" xml:space="preserve">
          <source>MakeMaker.pm uses the architecture-specific information from Config.pm. In addition it evaluates architecture specific hints files in a &lt;code&gt;hints/&lt;/code&gt; directory. The hints files are expected to be named like their counterparts in &lt;code&gt;PERL_SRC/hints&lt;/code&gt; , but with an &lt;code&gt;.pl&lt;/code&gt; file name extension (eg. &lt;code&gt;next_3_2.pl&lt;/code&gt; ). They are simply &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed by MakeMaker within the WriteMakefile() subroutine, and can be used to execute commands as well as to include special variables. The rules which hintsfile is chosen are the same as in Configure.</source>
          <target state="translated">MakeMaker.pm은 Config.pm의 아키텍처 별 정보를 사용합니다. 또한 &lt;code&gt;hints/&lt;/code&gt; 디렉토리 에서 아키텍처 별 힌트 파일을 평가 합니다. 힌트 파일은 &lt;code&gt;PERL_SRC/hints&lt;/code&gt; 의 해당 파일 과 비슷하지만 파일 이름 확장자 는 &lt;code&gt;.pl&lt;/code&gt; (예 : &lt;code&gt;next_3_2.pl&lt;/code&gt; )입니다. MakeMaker는 WriteMakefile () 서브 루틴 내에서 간단하게 &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 되며 특수 변수를 포함 할뿐 아니라 명령을 실행하는 데 사용될 수 있습니다. 힌트 파일을 선택하는 규칙은 구성에서와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="836efb6e25a091dcb4ff8e1dbb2f0be6a5cbf14c" translate="yes" xml:space="preserve">
          <source>Makefile</source>
          <target state="translated">Makefile</target>
        </trans-unit>
        <trans-unit id="a6a4139b0f32af1594c237ebe008acaf8217f505" translate="yes" xml:space="preserve">
          <source>Makefile.PL</source>
          <target state="translated">Makefile.PL</target>
        </trans-unit>
        <trans-unit id="7b63f64a9d58c97e157e981bc21fc3592f84d63a" translate="yes" xml:space="preserve">
          <source>Makefile.SH</source>
          <target state="translated">Makefile.SH</target>
        </trans-unit>
        <trans-unit id="7703506e8273da38efd2a8cfe539dd5151c3f507" translate="yes" xml:space="preserve">
          <source>Makefile.aperl</source>
          <target state="translated">Makefile.aperl</target>
        </trans-unit>
        <trans-unit id="c9fdff62ddc7b582d9333af8bb3618798e22507b" translate="yes" xml:space="preserve">
          <source>Makefile.ce</source>
          <target state="translated">Makefile.ce</target>
        </trans-unit>
        <trans-unit id="f59062c8b44c1bb393273cea0b6483c724adc359" translate="yes" xml:space="preserve">
          <source>Makes LZMA compression a lot slower, but a small compression gain.</source>
          <target state="translated">LZMA 압축 속도는 느리지 만 압축 게인은 작습니다.</target>
        </trans-unit>
        <trans-unit id="42141d0e6f7cf55bf1aa53a30a2f72e384ff774e" translate="yes" xml:space="preserve">
          <source>Makes a deep copy of the object.</source>
          <target state="translated">개체의 깊은 복사본을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="1ff909c4c06b83ac514fd30202e92170c2be88e6" translate="yes" xml:space="preserve">
          <source>Makes a distdir first, and runs a &lt;code&gt;perl Makefile.PL&lt;/code&gt; , a make, and a make test in that directory.</source>
          <target state="translated">distdir을 먼저 만들고 해당 디렉토리에서 &lt;code&gt;perl Makefile.PL&lt;/code&gt; , make 및 make 테스트를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="0126aa7337111c40fd3d8ee768267099e88c4e18" translate="yes" xml:space="preserve">
          <source>Makes an idhash from the argument, which must be a hash.</source>
          <target state="translated">인수에서 idhash를 작성합니다. 이는 해시 여야합니다.</target>
        </trans-unit>
        <trans-unit id="0c2559af9d3a61aae60ee275b6a01f1105ed29e6" translate="yes" xml:space="preserve">
          <source>Makes files exist, with current timestamp</source>
          <target state="translated">현재 타임 스탬프와 함께 파일을 존재하게합니다.</target>
        </trans-unit>
        <trans-unit id="277c90e53937992c5799a554ef17ea6240ac0378" translate="yes" xml:space="preserve">
          <source>Makes sure at run time that the object file (derived from the &lt;code&gt;.xs&lt;/code&gt; file) and the &lt;code&gt;.pm&lt;/code&gt; files have the same version number. Default is true.</source>
          <target state="translated">런타임시 오브젝트 파일 ( &lt;code&gt;.xs&lt;/code&gt; 파일 에서 파생 됨 )과 &lt;code&gt;.pm&lt;/code&gt; 파일의 버전 번호가 동일해야합니다. 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="53d81221f3002a7a58139dee2348d32bcaf0b4e5" translate="yes" xml:space="preserve">
          <source>Makes the entry in the table completely ignorable; i.e. as if the weights were zero at all level.</source>
          <target state="translated">테이블의 항목을 완전히 무시할 수있게합니다. 즉, 모든 수준에서 가중치가 0 인 것처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="6ce592c7c5a83ac8509be2294340cdf6b4e97842" translate="yes" xml:space="preserve">
          <source>Makes the thread unjoinable, and causes any eventual return value to be discarded. When the program exits, any detached threads that are still running are silently terminated.</source>
          <target state="translated">스레드를 결합 할 수 없게 만들고 최종 리턴 값을 버립니다. 프로그램이 종료되면 여전히 실행중인 분리 된 스레드가 자동으로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="f1346f72588900d324cb2f158adbed7a88d53077" translate="yes" xml:space="preserve">
          <source>Making</source>
          <target state="translated">Making</target>
        </trans-unit>
        <trans-unit id="c20d8b723d9ceaa1b7e38a56a86d1d8e27a837d5" translate="yes" xml:space="preserve">
          <source>Making Perl on AmigaOS</source>
          <target state="translated">AmigaOS에서 펄 만들기</target>
        </trans-unit>
        <trans-unit id="4fbad71d4049f75dae54b6a49e4082e7c3867bbe" translate="yes" xml:space="preserve">
          <source>Making References</source>
          <target state="translated">참조하기</target>
        </trans-unit>
        <trans-unit id="b3d460b24ff971356f57aa8043b7e5b49b73273b" translate="yes" xml:space="preserve">
          <source>Making a human-readable string out of an address</source>
          <target state="translated">주소에서 사람이 읽을 수있는 문자열 만들기</target>
        </trans-unit>
        <trans-unit id="ec8a39930df65d8d70bb72152bc2ebfcb5ef6f12" translate="yes" xml:space="preserve">
          <source>Making a system call for each byte you want to read is not very efficient (to put it mildly) but is the simplest to explain and works reasonably well.</source>
          <target state="translated">읽고 자하는 각 바이트에 대해 시스템 호출을하는 것은 그리 효율적이지 않지만 (가벼워서) 설명하기가 가장 쉽고 합리적으로 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6bc23e8c3bea5e39366cc40e690baa6e822bc4b0" translate="yes" xml:space="preserve">
          <source>Making executables with a custom collection of statically loaded extensions</source>
          <target state="translated">정적으로로드 된 확장 프로그램의 사용자 정의 모음으로 실행 파일 만들기</target>
        </trans-unit>
        <trans-unit id="cebf6e10212157e6416340db92e3bf9d920a30bf" translate="yes" xml:space="preserve">
          <source>Making executables with a custom search-paths</source>
          <target state="translated">사용자 정의 검색 경로로 실행 파일 만들기</target>
        </trans-unit>
        <trans-unit id="a0f26bb1828a797c6495fc430a1532f4f3524259" translate="yes" xml:space="preserve">
          <source>Making things worse is that UTF-8 support was a later addition to the regex engine (as it was to perl) and this necessarily made things a lot more complicated. Obviously it is easier to design a regex engine with Unicode support in mind from the beginning than it is to retrofit it to one that wasn't.</source>
          <target state="translated">설상가상으로 UTF-8 지원은 나중에 정규식 엔진에 추가되었으므로 (펄과 마찬가지로) 훨씬 더 복잡해졌습니다. 분명히 유니 코드 지원을 염두에두고 정규식 엔진을 그렇지 않은 엔진에 맞게 개조하는 것보다 처음부터 염두에 두는 것이 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="bf00c544b1ffc6b4c5073f7dd35eacd07c2aa8d1" translate="yes" xml:space="preserve">
          <source>Making your module threadsafe</source>
          <target state="translated">모듈을 스레드로부터 안전하게 만들기</target>
        </trans-unit>
        <trans-unit id="24e9d209d23730e356bf6cdf6439fa711205639d" translate="yes" xml:space="preserve">
          <source>Malcolm Beattie, &lt;code&gt;mbeattie@sable.ox.ac.uk&lt;/code&gt;</source>
          <target state="translated">말콤 비티, &lt;code&gt;mbeattie@sable.ox.ac.uk&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9b41df4a623efa0a4562a894886ab9c56b063a3e" translate="yes" xml:space="preserve">
          <source>Malcolm Beattie, &lt;code&gt;mbeattie@sable.ox.ac.uk&lt;/code&gt; Reini Urban &lt;code&gt;rurban@cpan.org&lt;/code&gt;</source>
          <target state="translated">Malcolm Beattie, &lt;code&gt;mbeattie@sable.ox.ac.uk&lt;/code&gt; Reini Urban &lt;code&gt;rurban@cpan.org&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="19631f035a3084a6fe635dc5c4bba7828f7afbd3" translate="yes" xml:space="preserve">
          <source>Malcolm Beattie, mbeattie@sable.ox.ac.uk.</source>
          <target state="translated">말콤 비티, mbeattie@sable.ox.ac.uk.</target>
        </trans-unit>
        <trans-unit id="76d7492febbbbb102be4a6084b9574c6324cf62a" translate="yes" xml:space="preserve">
          <source>Malformed UTF-8</source>
          <target state="translated">잘못된 UTF-8</target>
        </trans-unit>
        <trans-unit id="1c0e8bc778fcc6e629304edc324bee00f7f54935" translate="yes" xml:space="preserve">
          <source>Malloc Issues with perl on Solaris.</source>
          <target state="translated">Solaris에서 perl과 관련된 Malloc 문제</target>
        </trans-unit>
        <trans-unit id="118d45651d8f268c43f0d79ab0bbae66d29235b4" translate="yes" xml:space="preserve">
          <source>Malloc in Irix</source>
          <target state="translated">Irix의 Malloc</target>
        </trans-unit>
        <trans-unit id="25b61228c020a688cfd6c5a06fa24fca08bfdf7b" translate="yes" xml:space="preserve">
          <source>Manage .packlist files</source>
          <target state="translated">.packlist 파일 관리</target>
        </trans-unit>
        <trans-unit id="35931f68fb7263b16c5ab46a487b802fec9cd2f9" translate="yes" xml:space="preserve">
          <source>Managing Unknown Symbols</source>
          <target state="translated">알 수없는 기호 관리</target>
        </trans-unit>
        <trans-unit id="04f195c5450e541e2f347f3f01dadb29f21cee9c" translate="yes" xml:space="preserve">
          <source>Mandatory section; should be a comma-separated list of programs or functions documented by this POD page, such as:</source>
          <target state="translated">필수 섹션; 다음과 같이이 POD 페이지에서 문서화 한 쉼표로 구분 된 프로그램 또는 기능 목록이어야합니다.</target>
        </trans-unit>
        <trans-unit id="95b5420abf959d7eeb8c5172873e22e522cf809a" translate="yes" xml:space="preserve">
          <source>Manipulate @INC at compile time</source>
          <target state="translated">컴파일 타임에 @INC 조작</target>
        </trans-unit>
        <trans-unit id="95363fed4c5c92c85bfefb937ad574a5059a5ae7" translate="yes" xml:space="preserve">
          <source>Manipulate Perl symbols and their names</source>
          <target state="translated">Perl 기호 및 이름 조작</target>
        </trans-unit>
        <trans-unit id="a8c36443cbda2a6067ad5c937b50ce063c2df504" translate="yes" xml:space="preserve">
          <source>Manipulate threads in Perl (for old code only)</source>
          <target state="translated">Perl에서 스레드 조작 (이전 코드에만 해당)</target>
        </trans-unit>
        <trans-unit id="8a33f921aa98603ac2e48c7701dc159e3e29d6c1" translate="yes" xml:space="preserve">
          <source>Manipulating Opsets</source>
          <target state="translated">옵셋 조작</target>
        </trans-unit>
        <trans-unit id="2b13545245f98ef36404c536b49d9995e39a33e1" translate="yes" xml:space="preserve">
          <source>Manpages</source>
          <target state="translated">Manpages</target>
        </trans-unit>
        <trans-unit id="2c5bfd7444f7b80d647fb722cd55c67b0650aba4" translate="yes" xml:space="preserve">
          <source>Manpages for Perl on AmigaOS</source>
          <target state="translated">AmigaOS의 Perl 맨 페이지</target>
        </trans-unit>
        <trans-unit id="d013bfb63d4447b01e40780ba1cecae093576e1b" translate="yes" xml:space="preserve">
          <source>Manual Pages</source>
          <target state="translated">매뉴얼 페이지</target>
        </trans-unit>
        <trans-unit id="9cec485eab07667ef580f14404756c7cdf469fd8" translate="yes" xml:space="preserve">
          <source>Manual binary installation</source>
          <target state="translated">수동 바이너리 설치</target>
        </trans-unit>
        <trans-unit id="572276926686cc7cc3f5283d7ffd30b0fe5dbb1a" translate="yes" xml:space="preserve">
          <source>Manual page indexers are often extremely picky about the format of this section, so don't put anything in it except this line. Every program or function documented by this POD page should be listed, separated by a comma and a space. For a Perl module, just give the module name. A single dash, and only a single dash, should separate the list of programs or functions from the description. Do not use any markup such as C&amp;lt;&amp;gt; or B&amp;lt;&amp;gt; anywhere in this line. Functions should not be qualified with &lt;code&gt;()&lt;/code&gt; or the like. The description should ideally fit on a single line, even if a man program replaces the dash with a few tabs.</source>
          <target state="translated">매뉴얼 페이지 인덱서는 종종이 섹션의 형식에 대해 매우 까다롭기 때문에이 행을 제외하고는 아무것도 넣지 마십시오. 이 POD 페이지에 기록 된 모든 프로그램 또는 기능은 쉼표와 공백으로 구분하여 나열해야합니다. Perl 모듈의 경우 모듈 이름 만 지정하십시오. 단일 대시와 단일 대시 만 프로그램 또는 기능 목록을 설명과 분리해야합니다. 이 줄에서 C &amp;lt;&amp;gt; 또는 B &amp;lt;&amp;gt;와 같은 마크 업을 사용하지 마십시오. 함수는 &lt;code&gt;()&lt;/code&gt; 등 으로 한정되어서는 안됩니다 . man 프로그램이 대시를 몇 개의 탭으로 대체하더라도 설명은 단일 행에 이상적으로 적합해야합니다.</target>
        </trans-unit>
        <trans-unit id="00b4c0e2070e1a2565707d57c993afbbae4c0c2e" translate="yes" xml:space="preserve">
          <source>Manual: FAQs</source>
          <target state="translated">매뉴얼 : FAQ</target>
        </trans-unit>
        <trans-unit id="db75f57bcc4f9ed3d56d92896abd677a771bded6" translate="yes" xml:space="preserve">
          <source>Manual: Overview</source>
          <target state="translated">매뉴얼 : 개요</target>
        </trans-unit>
        <trans-unit id="950d94e419183f62360b7a18d309980db9dca27b" translate="yes" xml:space="preserve">
          <source>Manual: Tutorials</source>
          <target state="translated">매뉴얼 : 튜토리얼</target>
        </trans-unit>
        <trans-unit id="ac0e5ddc596dea92cba4c0e2c3555f39d4f7c5f0" translate="yes" xml:space="preserve">
          <source>Manually put</source>
          <target state="translated">수동으로 넣어</target>
        </trans-unit>
        <trans-unit id="c84207b4c45d8ef84a1d774f5c8bf8efd5fcd50a" translate="yes" xml:space="preserve">
          <source>Many &lt;code&gt;AUTOLOAD&lt;/code&gt; routines load in a definition for the requested subroutine using eval(), then execute that subroutine using a special form of goto() that erases the stack frame of the &lt;code&gt;AUTOLOAD&lt;/code&gt; routine without a trace. (See the source to the standard module documented in &lt;a href=&quot;autoloader&quot;&gt;AutoLoader&lt;/a&gt;, for example.) But an &lt;code&gt;AUTOLOAD&lt;/code&gt; routine can also just emulate the routine and never define it. For example, let's pretend that a function that wasn't defined should just invoke &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; with those arguments. All you'd do is:</source>
          <target state="translated">많은 &lt;code&gt;AUTOLOAD&lt;/code&gt; 루틴은 eval ()을 사용하여 요청 된 서브 루틴에 대한 정의에로드 한 다음 추적없이 &lt;code&gt;AUTOLOAD&lt;/code&gt; 루틴 의 스택 프레임을 지우는 특수 형식의 goto ()를 사용하여 해당 서브 루틴을 실행합니다 . ( 예를 들어 &lt;a href=&quot;autoloader&quot;&gt;AutoLoader에&lt;/a&gt; 문서화 된 표준 모듈의 소스를 참조하십시오 .) 그러나 &lt;code&gt;AUTOLOAD&lt;/code&gt; 루틴은 루틴을 에뮬레이트하고 정의 할 수 없습니다. 예를 들어, 정의되지 않은 함수는 이러한 인수로 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 을 호출해야한다고 가정 해 봅시다 . 당신이 할 일은 :</target>
        </trans-unit>
        <trans-unit id="077443aca86ab6f4e2738e61b48baa6af4d5929a" translate="yes" xml:space="preserve">
          <source>Many &lt;code&gt;TAP::*&lt;/code&gt; classes have a</source>
          <target state="translated">많은 &lt;code&gt;TAP::*&lt;/code&gt; 클래스에는</target>
        </trans-unit>
        <trans-unit id="d7a6d0011c1051ce0333abc0265080896a481453" translate="yes" xml:space="preserve">
          <source>Many Unicode properties have more than one name (or alias). &lt;code&gt;prop_invmap&lt;/code&gt; understands all of these, including Perl extensions to them. Ambiguities are resolved as described above for &lt;a href=&quot;#prop_aliases()&quot;&gt;prop_aliases()&lt;/a&gt;. The Perl internal property &quot;Perl_Decimal_Digit, described below, is also accepted. An empty list is returned if the property name is unknown. See &lt;a href=&quot;../perluniprops#Properties-accessible-through-Unicode%3a%3aUCD&quot;&gt;Properties accessible through Unicode::UCD in perluniprops&lt;/a&gt; for the properties acceptable as inputs to this function.</source>
          <target state="translated">많은 유니 코드 속성에는 둘 이상의 이름 (또는 별칭)이 있습니다. &lt;code&gt;prop_invmap&lt;/code&gt; 은 Perl 확장을 포함 하여이 모든 것을 이해합니다. &lt;a href=&quot;#prop_aliases()&quot;&gt;prop_aliases ()에&lt;/a&gt; 대해 위에서 설명한대로 모호성이 해결됩니다 . 아래에 설명 된 Perl 내부 특성 &quot;Perl_Decimal_Digit&quot;도 승인됩니다. 특성 이름을 알 수 없으면 빈 목록이 리턴됩니다. 이 함수에 대한 입력으로 허용 가능한 특성 &lt;a href=&quot;../perluniprops#Properties-accessible-through-Unicode%3a%3aUCD&quot;&gt;은 perluniprops에서 Unicode :: UCD를 통해 액세스 가능한 특성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="33c4abda8cada5094d54134f3094015df454f077" translate="yes" xml:space="preserve">
          <source>Many applications contain some Perl code that could be reused.</source>
          <target state="translated">많은 응용 프로그램에는 재사용 할 수있는 일부 Perl 코드가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="48c7aff02ac4959c101106add7455533fff396df" translate="yes" xml:space="preserve">
          <source>Many built-in functions may be overridden, though this should be tried only occasionally and for good reason. Typically this might be done by a package attempting to emulate missing built-in functionality on a non-Unix system.</source>
          <target state="translated">많은 내장 함수가 재정의 될 수 있지만, 가끔 그리고 합당한 이유로 시도해야합니다. 일반적으로 이는 비 유닉스 시스템에서 누락 된 내장 기능을 에뮬레이트하려는 패키지에 의해 수행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="294c60617a28cb2d00c28e138e9bdc873720df06" translate="yes" xml:space="preserve">
          <source>Many cases of using &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; in a conditional can be written using &lt;code&gt;any&lt;/code&gt; instead, as it can short-circuit after the first true result.</source>
          <target state="translated">사용 많은 경우 &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 조건으로 사용하여 기록 될 수 &lt;code&gt;any&lt;/code&gt; 대로 제 진정한 결과 후의 단락 수 대신.</target>
        </trans-unit>
        <trans-unit id="c53c00d79c1b4a5caf2dbf3b1b3871ad968ba47e" translate="yes" xml:space="preserve">
          <source>Many cities around the world have local Perl Mongers chapters. A Perl Mongers chapter is a local user group which typically holds regular in-person meetings, both social and technical; helps organize local conferences, workshops, and hackathons; and provides a mailing list or other continual contact method for its members to keep in touch.</source>
          <target state="translated">전 세계 많은 도시에는 현지 Perl Mongers 장이 있습니다. Perl Mongers 챕터는 일반적으로 사회 및 기술적으로 정기적 인 대면 회의를 개최하는 로컬 사용자 그룹입니다. 지역 회의, 워크샵 및 해커 톤을 조직하는 데 도움이됩니다. 회원들이 연락 할 수있는 메일 링리스트 또는 기타 지속적인 연락 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1333a5caee67ed3743b1573e310fc69a41dedbcf" translate="yes" xml:space="preserve">
          <source>Many forms are mutually un-intelligible in spoken media. Notable forms: {ar-ae} UAE Arabic; {ar-bh} Bahrain Arabic; {ar-dz} Algerian Arabic; {ar-eg} Egyptian Arabic; {ar-iq} Iraqi Arabic; {ar-jo} Jordanian Arabic; {ar-kw} Kuwait Arabic; {ar-lb} Lebanese Arabic; {ar-ly} Libyan Arabic; {ar-ma} Moroccan Arabic; {ar-om} Omani Arabic; {ar-qa} Qatari Arabic; {ar-sa} Sauda Arabic; {ar-sy} Syrian Arabic; {ar-tn} Tunisian Arabic; {ar-ye} Yemen Arabic.</source>
          <target state="translated">구어체 매체에서는 많은 형태를 서로 이해하기 어렵습니다. 주목할만한 형태 : {ar-ae} UAE Arabic; {ar-bh} 바레인 아랍어; {ar-dz} 알제리 아랍어; {ar-eg} 이집트 아랍어; {ar-iq} 이라크 아랍어; {ar-jo} 요르단 아랍어; {ar-kw} 쿠웨이트 아랍어; {ar-lb} 레바논 아랍어; {arlyly} 리비아 아랍어; {ar-ma} 모로코 아랍어; {ar-om} 오만 아랍어; {ar-qa} 카타르 아랍어; {ar-sa} 소다 아랍어; {ar-sy} 시리아 아랍어; {ar-tn} 튀니지 아랍어; {ar-ye} 예멘 아랍어.</target>
        </trans-unit>
        <trans-unit id="22b65de1b1ff16b769feb6a461c534e2b3b49857" translate="yes" xml:space="preserve">
          <source>Many forms are mutually un-intelligible in spoken media. Notable forms: {zh-Hans} Chinese, in simplified script; {zh-Hant} Chinese, in traditional script; {zh-tw} Taiwan Chinese; {zh-cn} PRC Chinese; {zh-sg} Singapore Chinese; {zh-mo} Macau Chinese; {zh-hk} Hong Kong Chinese; {zh-guoyu} Mandarin [Putonghua/Guoyu]; {zh-hakka} Hakka [formerly &quot;i-hakka&quot;]; {zh-min} Hokkien; {zh-min-nan} Southern Hokkien; {zh-wuu} Shanghaiese; {zh-xiang} Hunanese; {zh-gan} Gan; {zh-yue} Cantonese.</source>
          <target state="translated">구어체 매체에서는 많은 형태를 서로 이해하기 어렵습니다. 주목할만한 형태 : {zh-Hans} 중국어, 간체 스크립트; {zh-Hant} 중국어 (번체); {zh-tw} 대만 중국어; {zh-cn} PRC 중국어; {zh-sg} 싱가포르 중국인; {zh-mo} 마카오 중국어; {zh-hk} 홍콩 중국어; {zh-guoyu} 만다린 [푸 통화 / 구 오유]; {zh-hakka} Hakka [이전의 &quot;i-hakka&quot;]; {zh-min} 호키엔; {zh-min-nan} 남부 호키엔; {zh-wuu} 상하이; {zh-xiang} 호남 족; {zh-gan} 간; {zh-yue} 광동어.</target>
        </trans-unit>
        <trans-unit id="ce036cf5b80f30684cc79c208c3479e5b4b012ed" translate="yes" xml:space="preserve">
          <source>Many good books have been written about Perl--see the section later in &lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2&lt;/a&gt; for more details.</source>
          <target state="translated">Perl에 관한 많은 훌륭한 책들이 저술되어 있습니다. 자세한 내용 은 &lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2의 뒷부분&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="daec66bc8e44bcc2464b1a0d6c4a9145c9a7595a" translate="yes" xml:space="preserve">
          <source>Many members of the community have a Perl-related blog on this site. If you'd like to join them, you can sign up for free.</source>
          <target state="translated">이 커뮤니티에는 많은 커뮤니티 회원이 Perl 관련 블로그를 가지고 있습니다. 가입하려면 무료로 가입하십시오.</target>
        </trans-unit>
        <trans-unit id="a71a9a58452bd2f82710c97492e2e55820847a42" translate="yes" xml:space="preserve">
          <source>Many modules are included in the Perl distribution. These are described below, and all end in</source>
          <target state="translated">많은 모듈이 Perl 분배에 포함되어 있습니다. 이것들은 아래에 설명되어 있으며 모두 끝납니다.</target>
        </trans-unit>
        <trans-unit id="1f04b4ad6b9470f5a4263506a665427c873dff64" translate="yes" xml:space="preserve">
          <source>Many modules make use of &lt;code&gt;AUTOLOAD&lt;/code&gt; ing for constant subroutines to avoid having to compile and waste memory on rarely used values (see &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt; for details on constant subroutines). Calls to such constant subroutines are not optimized away at compile time because they can't be checked at compile time for constancy.</source>
          <target state="translated">많은 모듈 은 거의 사용되지 않는 값에서 메모리를 컴파일하고 낭비하지 않도록 상수 서브 루틴 에 &lt;code&gt;AUTOLOAD&lt;/code&gt; 를 사용합니다 ( 상수 서브 루틴에 대한 자세한 내용 은 &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt; 참조 ). 이러한 상수 서브 루틴에 대한 호출은 컴파일 시간에 일관성을 검사 할 수 없으므로 컴파일 시간에 최적화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bd64827a8fe9cbce8371a7bcfdacc99021bfba74" translate="yes" xml:space="preserve">
          <source>Many of Perl's syntactic elements are &lt;b&gt;optional&lt;/b&gt;. Rather than requiring you to put parentheses around every function call and declare every variable, you can often leave such explicit elements off and Perl will figure out what you meant. This is known as &lt;b&gt;Do What I Mean&lt;/b&gt;, abbreviated &lt;b&gt;DWIM&lt;/b&gt;. It allows programmers to be &lt;b&gt;lazy&lt;/b&gt; and to code in a style with which they are comfortable.</source>
          <target state="translated">Perl의 많은 구문 요소는 &lt;b&gt;선택 사항&lt;/b&gt; 입니다. 모든 함수 호출을 괄호로 묶고 모든 변수를 선언하도록 요구하는 대신 이러한 명시 적 요소를 끄고 Perl이 의미를 파악할 수 있습니다. 이것을 &lt;b&gt;DWIM으로&lt;/b&gt; 약칭하는 &lt;b&gt;것을 의미&lt;/b&gt; 합니다. 프로그래머가 &lt;b&gt;게으르고&lt;/b&gt; 편안한 스타일로 코딩 할 수 있습니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a80a79f26d84c2cb761d54166d1d73c391965f8f" translate="yes" xml:space="preserve">
          <source>Many of the comments in the existing code ignore the possibility of EBCDIC, and may be wrong therefore, even if the code works. This is actually a tribute to the successful transparent insertion of being able to handle EBCDIC without having to change pre-existing code.</source>
          <target state="translated">기존 코드의 많은 주석은 EBCDIC의 가능성을 무시하므로 코드가 작동하더라도 잘못 될 수 있습니다. 실제로 기존 코드를 변경하지 않고도 EBCDIC를 처리 할 수있는 투명한 삽입에 성공한 것입니다.</target>
        </trans-unit>
        <trans-unit id="9898a42f1ac737909964257112ee94f7d9cf02b3" translate="yes" xml:space="preserve">
          <source>Many of the examples which follow will concentrate on creating an interface between Perl and the ONC+ RPC bind library functions. The rpcb_gettime() function is used to demonstrate many features of the XS language. This function has two parameters; the first is an input parameter and the second is an output parameter. The function also returns a status value.</source>
          <target state="translated">다음에 나오는 많은 예제는 Perl과 ONC + RPC 바인드 라이브러리 함수 간의 인터페이스 작성에 중점을 둘 것입니다. rpcb_gettime () 함수는 XS 언어의 많은 기능을 보여주기 위해 사용됩니다. 이 기능에는 두 가지 매개 변수가 있습니다. 첫 번째는 입력 매개 변수이고 두 번째는 출력 매개 변수입니다. 이 함수는 상태 값도 반환합니다.</target>
        </trans-unit>
        <trans-unit id="921520a4912c2671d68673bde14f85005a75001d" translate="yes" xml:space="preserve">
          <source>Many of the functions and methods listed below take a list of operators as parameters. Most operator lists can be made up of several types of element. Each element can be one of</source>
          <target state="translated">아래에 나열된 많은 기능과 방법은 연산자 목록을 매개 변수로 사용합니다. 대부분의 운영자 목록은 여러 유형의 요소로 구성 될 수 있습니다. 각 요소는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ce44f55ac189a65855572d397cff0134d70bf83" translate="yes" xml:space="preserve">
          <source>Many of the functions in this module return a Benchmark object, or in the case of &lt;code&gt;timethese()&lt;/code&gt; , a reference to a hash, the values of which are Benchmark objects. This is useful if you want to store or further process results from Benchmark functions.</source>
          <target state="translated">이 모듈의 많은 함수는 Benchmark 객체 또는 &lt;code&gt;timethese()&lt;/code&gt; 의 경우 해시에 대한 참조를 반환하며 그 값은 Benchmark 객체입니다. 벤치 마크 기능의 결과를 저장하거나 추가로 처리하려는 경우에 유용합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
