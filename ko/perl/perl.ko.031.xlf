<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="f7fa695823c4cf174fe101c150852b83035705c8" translate="yes" xml:space="preserve">
          <source>Many of these fit entirely into 8 bits, using ASCII as 0-127, while specifying what 128-255 mean, and not using anything above 255. Thus, these are single-byte (or octet if you prefer) character sets. One important one (since Unicode is a superset of it) is the ISO 8859-1 character set.</source>
          <target state="translated">이들 중 대부분은 ASCII를 0-127로 사용하여 128-255의 의미를 지정하고 255보다 큰 것을 사용하지 않는 8 비트에 완전히 맞습니다. 따라서 이들은 1 바이트 (또는 선호하는 경우 8 진수) 문자 세트입니다. 하나의 중요한 것 (유니 코드는 그것의 수퍼 세트이므로)은 ISO 8859-1 문자 세트입니다.</target>
        </trans-unit>
        <trans-unit id="05f3b55f18e683ceb0e20e5811ee8daf9fe6a35d" translate="yes" xml:space="preserve">
          <source>Many older Pod parsers did not accept a line consisting of spaces/tabs and then a newline as a blank line. The only lines they considered blank were lines consisting of</source>
          <target state="translated">많은 오래된 포드 파서는 공백 / 탭으로 구성된 줄을 받아들이지 않고 줄 바꿈을 빈 줄로 받아들이지 않았습니다. 그들이 공백으로 간주 한 유일한 줄은</target>
        </trans-unit>
        <trans-unit id="77b79be2ba71305e951ed06673ece959275013dd" translate="yes" xml:space="preserve">
          <source>Many older Pod translators require the lines before every Pod command and after every Pod command (including &quot;=cut&quot;!) to be a blank line. Having something like this:</source>
          <target state="translated">많은 이전 포드 번역가는 모든 포드 명령 앞과 모든 포드 명령 ( &quot;= cut&quot;! 포함) 뒤에 빈 줄이 필요합니다. 이와 같은 것을 갖는 것 :</target>
        </trans-unit>
        <trans-unit id="a404450a4f0d183d7e5d43b166d410dc6203e579" translate="yes" xml:space="preserve">
          <source>Many operations return &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; to indicate failure, end of file, system error, uninitialized variable, and other exceptional conditions. This function allows you to distinguish &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; from other values. (A simple Boolean test will not distinguish among &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, zero, the empty string, and &lt;code&gt;&quot;0&quot;&lt;/code&gt; , which are all equally false.) Note that since &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is a valid scalar, its presence doesn't</source>
          <target state="translated">많은 작업이 실패, 파일 끝, 시스템 오류, 초기화되지 않은 변수 및 기타 예외적 인 조건을 나타 내기 위해 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환 합니다. 이 기능을 사용하면 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 다른 값 과 구별 할 수 있습니다 . (간단한 부울 테스트는 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , 0, 빈 문자열 및 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 을 모두 동일하게 거짓으로 구분 하지 않습니다 .) &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 유효한 스칼라이므로 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="98e1178b6db9a17ccdf3a94478a8066c1df5bc3a" translate="yes" xml:space="preserve">
          <source>Many operations return &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; to indicate failure, end of file, system error, uninitialized variable, and other exceptional conditions. This function allows you to distinguish &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; from other values. (A simple Boolean test will not distinguish among &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, zero, the empty string, and &lt;code&gt;&quot;0&quot;&lt;/code&gt; , which are all equally false.) Note that since &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is a valid scalar, its presence doesn't</source>
          <target state="translated">많은 작업이 실패, 파일 끝, 시스템 오류, 초기화되지 않은 변수 및 기타 예외적 인 조건을 나타 내기 위해 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환 합니다. 이 기능을 사용하면 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 다른 값 과 구별 할 수 있습니다 . (간단한 부울 테스트는 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , 0, 빈 문자열 및 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 을 모두 동일하게 거짓으로 구분 하지 않습니다 .) &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 유효한 스칼라이므로 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2dfa8b77d5259786f771a6e4ace0bfcdbd85aa18" translate="yes" xml:space="preserve">
          <source>Many operators can be combined with a &lt;code&gt;=&lt;/code&gt; as follows:</source>
          <target state="translated">많은 연산자 를 다음과 같이 &lt;code&gt;=&lt;/code&gt; 와 결합 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a7edb2d97b3af3ae2394d677e142e5033e9352fd" translate="yes" xml:space="preserve">
          <source>Many operators can be overloaded for objects. See &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt;.</source>
          <target state="translated">객체에 대해 많은 연산자가 오버로드 될 수 있습니다. &lt;a href=&quot;overload&quot;&gt;과부하를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a0786026e69f66286ea639842ce2404d2adc40ac" translate="yes" xml:space="preserve">
          <source>Many people contributed in one or more ways to the final beast, see the file CREDITS for an (incomplete) list. If you miss your name, please drop me a mail. Thank you!</source>
          <target state="translated">많은 사람들이 마지막 짐승에게 하나 이상의 방법으로 기여했습니다. (불완전한) 목록은 CREDITS 파일을 참조하십시오. 당신이 당신의 이름을 그리워하는 경우, 나에게 메일을 드롭하시기 바랍니다. 감사합니다!</target>
        </trans-unit>
        <trans-unit id="3cd694c993c7766c158f0bde0cae8406dd835121" translate="yes" xml:space="preserve">
          <source>Many people enter the CPAN shell by running the &lt;a href=&quot;cpan&quot;&gt;cpan&lt;/a&gt; utility program which is installed in the same directory as perl itself. So if you have this directory in your PATH variable (or some equivalent in your operating system) then typing &lt;code&gt;cpan&lt;/code&gt; in a console window will work for you as well. Above that the utility provides several commandline shortcuts.</source>
          <target state="translated">많은 사람들 이 perl 자체와 동일한 디렉토리에 설치된 &lt;a href=&quot;cpan&quot;&gt;cpan&lt;/a&gt; 유틸리티 프로그램을 실행하여 CPAN 쉘에 들어갑니다 . 따라서 PATH 변수에이 디렉토리가 있거나 운영 체제에 해당하는 디렉토리가 있으면 콘솔 창에 &lt;code&gt;cpan&lt;/code&gt; 을 입력 해도 효과가 있습니다. 이 유틸리티는 여러 명령 줄 바로 가기를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="cf066e941decde490ba46743ad80acc7ad0c1d13" translate="yes" xml:space="preserve">
          <source>Many platforms, quite rightly so, will give you a core dump instead of a pony if the p happens not to be correctly aligned.</source>
          <target state="translated">p가 올바르게 정렬되지 않으면 많은 플랫폼이 올바르게 조랑말 대신 코어 덤프를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ad441fa89d95482888ef0338d65a9d30f90b64d7" translate="yes" xml:space="preserve">
          <source>Many popular C extension modules do not come bundled (at least, not completely) due to their sizes, volatility, or simply lack of time for adequate testing and configuration across the multitude of platforms on which Perl was beta-tested. You are encouraged to look for them on CPAN (described below), or using web search engines like Alta Vista or Google.</source>
          <target state="translated">널리 사용되는 많은 C 확장 모듈은 크기, 휘발성 또는 Perl 베타 테스트를 거친 여러 플랫폼에서 적절한 테스트 및 구성을위한 시간 부족으로 번들로 제공되지 않습니다 (적어도 완벽하지는 않습니다). CPAN (아래 설명 참조) 또는 Alta Vista 또는 Google과 같은 웹 검색 엔진을 사용하여 검색하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="bdd710785412d1136d5d2fe923caa1de40582889" translate="yes" xml:space="preserve">
          <source>Many porters are also active on the &lt;a href=&quot;irc://irc.perl.org/#p5p&quot;&gt;irc://irc.perl.org/#p5p&lt;/a&gt; channel. Feel free to join the channel and ask questions about hacking on the Perl core.</source>
          <target state="translated">많은 포터도 &lt;a href=&quot;irc://irc.perl.org/#p5p&quot;&gt;irc : //irc.perl.org/#p5p&lt;/a&gt; 채널 에서 활성화됩니다 . 채널에 참여하여 Perl 코어의 해킹에 대해 질문하십시오.</target>
        </trans-unit>
        <trans-unit id="1b93f4b5b9979ea7052f6313958e026f6e2ea4a2" translate="yes" xml:space="preserve">
          <source>Many regular expression constructs don't work on EBCDIC platforms.</source>
          <target state="translated">많은 정규 표현식 구성은 EBCDIC 플랫폼에서 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c09ff3401dc02f5920da9178fc87b7ee9d234ec" translate="yes" xml:space="preserve">
          <source>Many system or library calls set &lt;code&gt;errno&lt;/code&gt; if they fail, to indicate the cause of failure. They usually do &lt;b&gt;not&lt;/b&gt; set &lt;code&gt;errno&lt;/code&gt; to zero if they succeed. This means &lt;code&gt;errno&lt;/code&gt; , hence &lt;code&gt;$!&lt;/code&gt; , is meaningful only</source>
          <target state="translated">많은 시스템 또는 라이브러리 호출이 실패한 경우 실패 원인을 나타 내기 위해 &lt;code&gt;errno&lt;/code&gt; 를 설정 합니다. 성공하면 일반적으로 &lt;code&gt;errno&lt;/code&gt; 를 0으로 설정 하지 &lt;b&gt;않습니다&lt;/b&gt; . 이것은 &lt;code&gt;errno&lt;/code&gt; 를 의미 하므로 &lt;code&gt;$!&lt;/code&gt; 의미가 있습니다</target>
        </trans-unit>
        <trans-unit id="c790c1897e3e898f761b95151fd508249c16664d" translate="yes" xml:space="preserve">
          <source>Many systems (DOS, VMS ODS-2) cannot have more than one &lt;code&gt;.&lt;/code&gt; in their filenames.</source>
          <target state="translated">많은 시스템 (DOS, VMS ODS-2)은 둘 이상을 가질 수 없습니다 &lt;code&gt;.&lt;/code&gt; 파일 이름으로.</target>
        </trans-unit>
        <trans-unit id="7efce1a3865da7dfdc9c988fdb8235136031c9dd" translate="yes" xml:space="preserve">
          <source>Many thanks to Florian Ragwitz for administration and packaging assistance, to John Tromp for bug reports, to Jonathan Roy for bug reports and suggestions, to Michael Schwern for other bug reports and patches, to Mike Cariaso for helping me to figure out the Right Thing to Do About Expiration, to Joshua Gerth, Joshua Chamas, Jonathan Roy (again), Mark D. Anderson, and Andrew Johnson for more suggestions about expiration, to Brent Powers for the Memoize::ExpireLRU module, to Ariel Scolnicov for delightful messages about the Fibonacci function, to Dion Almaer for thought-provoking suggestions about the default normalizer, to Walt Mankowski and Kurt Starsinic for much help investigating problems under threaded Perl, to Alex Dudkevich for reporting the bug in prototyped functions and for checking my patch, to Tony Bass for many helpful suggestions, to Jonathan Roy (again) for finding a use for &lt;code&gt;unmemoize()&lt;/code&gt; , to Philippe Verdret for enlightening discussion of &lt;code&gt;Hook::PrePostCall&lt;/code&gt; , to Nat Torkington for advice I ignored, to Chris Nandor for portability advice, to Randal Schwartz for suggesting the '&lt;code&gt;flush_cache&lt;/code&gt; function, and to Jenda Krynicky for being a light in the world.</source>
          <target state="translated">관리 및 패키징 지원에 대한 Florian Ragwitz, 버그 보고서의 경우 John Tromp, 버그 보고서 및 제안의 경우 Jonathan Roy, 기타 버그 보고서 및 패치의 경우 Michael Schwern, Mike Cariaso에게 올바른 정보를 찾는 데 도움을 주신 감사합니다. 만료에 대해, Joshua Gerth, Joshua Chamas, Jonathan Roy (다시), Mark D. Anderson 및 Andrew Johnson에게 만료에 대한 추가 제안은 Metize :: ExpireLRU 모듈, Ariel Scolnicov, Ariel Scolnicov에게 피보나치 함수, 기본 노멀 라이저에 대한 생각을 불러 일으키는 제안을 위해 Dion Almaer, Walt Mankowski 및 Kurt Starsinic, 스레드 Perl에서 문제를 조사하는 데 도움이되는 Alex Dudkevich, 프로토 타입 함수의 버그를보고하고 패치를 확인하기 위해 Tony Bass에게 많은 유용한 제안을 위해에 대 한 사용을 찾기 위해 Jonathan Roy (다시) &lt;code&gt;unmemoize()&lt;/code&gt; , Philippe Verdret, &lt;code&gt;Hook::PrePostCall&lt;/code&gt; , 토론을 위한 Nat Torkington, 이식성 조언을위한 Chris Nandor, ' &lt;code&gt;flush_cache&lt;/code&gt; 함수 제안을위한 Randal Schwartz,' flush_cache 함수 제안 및 Jenda Krynicky에게 세계.</target>
        </trans-unit>
        <trans-unit id="6cd0cefd9b93740b2ce288b59bbfa2506b7603b6" translate="yes" xml:space="preserve">
          <source>Map Perl operating system names to generic types</source>
          <target state="translated">Perl 운영 체제 이름을 일반 유형에 맵핑</target>
        </trans-unit>
        <trans-unit id="7d32a75bc17a4709e9d1141d1ebfa60b6cd43879" translate="yes" xml:space="preserve">
          <source>Map always returns a list, which can be assigned to a hash such that the elements become key/value pairs. See &lt;a href=&quot;../perldata&quot;&gt;perldata&lt;/a&gt; for more details.</source>
          <target state="translated">맵은 항상 목록을 반환하며,이 목록은 요소가 키 / 값 쌍이되도록 해시에 할당 될 수 있습니다. 자세한 내용은 &lt;a href=&quot;../perldata&quot;&gt;perldata&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b5dd04ccd71f6dc1b0c4b39870ec7fbae4d0141a" translate="yes" xml:space="preserve">
          <source>Map always returns a list, which can be assigned to a hash such that the elements become key/value pairs. See &lt;a href=&quot;perldata&quot;&gt;perldata&lt;/a&gt; for more details.</source>
          <target state="translated">맵은 항상 목록을 반환하며,이 목록은 요소가 키 / 값 쌍이되도록 해시에 할당 될 수 있습니다. 자세한 내용은 &lt;a href=&quot;perldata&quot;&gt;perldata&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d4fa0aeb10d9944cd20c23c3471632b3053b6c36" translate="yes" xml:space="preserve">
          <source>Mapping \x00 to '@' causes too much pain everywhere.</source>
          <target state="translated">\ x00을 '@'에 매핑하면 모든 곳에서 너무 많은 고통이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b05d51e1bee28ea12c20512307467a2c4ee871f8" translate="yes" xml:space="preserve">
          <source>Maps certain Unicode code points to their legacy Japanese cell-phone values</source>
          <target state="translated">특정 유니 코드 코드 포인트를 기존 일본 휴대폰 값으로 매핑</target>
        </trans-unit>
        <trans-unit id="67c10042685d0de63983cda038f2ff8c2785c051" translate="yes" xml:space="preserve">
          <source>Maps from names (as in &lt;code&gt;E&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;&lt;/code&gt;) like &quot;eacute&quot; or &quot;sol&quot; to the Unicode value that each stands for. For example, &lt;code&gt;$Name2character_number{'eacute'}&lt;/code&gt; is 201, and &lt;code&gt;$Name2character_number{'eacute'}&lt;/code&gt; is 8364. You get the correct Unicode value, regardless of the version of Perl you're using -- which differs from &lt;code&gt;%Name2character&lt;/code&gt; 's behavior under pre-5.7 Perls.</source>
          <target state="translated">&quot;eacute&quot;또는 &quot;sol&quot;과 같은 이름 ( &lt;code&gt;E&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;&lt;/code&gt; )을 각각이 나타내는 유니 코드 값으로 매핑합니다. 예를 들어, &lt;code&gt;$Name2character_number{'eacute'}&lt;/code&gt; (201)이며, &lt;code&gt;$Name2character_number{'eacute'}&lt;/code&gt; 당신은 당신이 사용하고 펄의 버전에 관계없이 올바른 유니 코드 값을 얻을 8364.이다 -에서 어떤 다르다 &lt;code&gt;%Name2character&lt;/code&gt; 의 5.7 이전 Perls에서의 동작</target>
        </trans-unit>
        <trans-unit id="6d2553254721ed355ac347e903abc341219f5deb" translate="yes" xml:space="preserve">
          <source>Maps from names (as in &lt;code&gt;E&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;&lt;/code&gt;) like &quot;eacute&quot; or &quot;sol&quot; to the string that each stands for. Note that this does not include numerics (like &quot;64&quot; or &quot;x981c&quot;). Under old Perl versions (before 5.7) you get a &quot;?&quot; in place of characters whose Unicode value is over 255.</source>
          <target state="translated">&quot;eacute&quot;또는 &quot;sol&quot;과 같은 이름 ( &lt;code&gt;E&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;&lt;/code&gt; )을 각각이 나타내는 문자열로 매핑합니다. 여기에는 &quot;64&quot;또는 &quot;x981c&quot;와 같은 숫자가 포함되지 않습니다. 이전 Perl 버전 (5.7 이전)에서는 &quot;?&quot; 유니 코드 값이 255보다 큰 문자 대신</target>
        </trans-unit>
        <trans-unit id="a1b78ee004c9a2fbd85f8f626a722e3fe6da6945" translate="yes" xml:space="preserve">
          <source>Maps the kRSUnicode property values to corresponding code points</source>
          <target state="translated">kRSUnicode 특성 값을 해당 코드 포인트에 맵핑합니다.</target>
        </trans-unit>
        <trans-unit id="7b909fc95f2b4e5f8d9967846d9866d42fccc70f" translate="yes" xml:space="preserve">
          <source>Marc Green, &amp;lt;marcgreen@cpan.org&amp;gt;.</source>
          <target state="translated">마크 그린, &amp;lt;marcgreen@cpan.org&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="6188237b0da82f2fd62e1940dd4c6b739e5e4019" translate="yes" xml:space="preserve">
          <source>March 28th, 1997; by Hugo van der Sanden: added support for code references and the already documented 'debug' method; revamped documentation.</source>
          <target state="translated">1997 년 3 월 28 일; Hugo van der Sanden : 코드 참조 및 이미 문서화 된 '디버그'방법에 대한 지원 추가; 개정 된 문서.</target>
        </trans-unit>
        <trans-unit id="719b2885e137f36b196d43363c080ddacf1c5a2e" translate="yes" xml:space="preserve">
          <source>Marcus Holland-Moritz &amp;lt;mhx@cpan.org&amp;gt;</source>
          <target state="translated">마커스 홀랜드-모리츠 &amp;lt;mhx@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1dfd6571ab219bad3b1cec579d53f1dfc162bfba" translate="yes" xml:space="preserve">
          <source>Marek Rouchal &amp;lt;marekr@cpan.org&amp;gt;</source>
          <target state="translated">마렉 루찰 &amp;lt;marekr@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="264476e951a0a1cdd02faca9ecf02d9d3dd7bcf9" translate="yes" xml:space="preserve">
          <source>Marek Rouchal &amp;lt;marekr@cpan.org&amp;gt;, borrowing a lot of things from &lt;a href=&quot;../pod2man&quot;&gt;pod2man&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/pod2roff&quot;&gt;pod2roff&lt;/a&gt; as well as other POD processing tools by Tom Christiansen, Brad Appleton and Russ Allbery.</source>
          <target state="translated">Marek Rouchal &amp;lt;marekr@cpan.org&amp;gt; : Tom Christiansen, Brad Appleton 및 Russ Allbery의 다른 POD 처리 도구뿐만 아니라 &lt;a href=&quot;../pod2man&quot;&gt;pod2man&lt;/a&gt; 및 &lt;a href=&quot;http://search.cpan.org/perldoc/pod2roff&quot;&gt;pod2roff&lt;/a&gt; 에서 많은 것을 빌 렸습니다.</target>
        </trans-unit>
        <trans-unit id="c079bae77060ca37ba3c2926c71f4d4859c75bac" translate="yes" xml:space="preserve">
          <source>Marek Rouchal &amp;lt;marekr@cpan.org&amp;gt;, heavily borrowing code from Nick Ing-Simmons' PodToHtml.</source>
          <target state="translated">Nick Ing-Simmons의 PodToHtml에서 코드를 많이 빌린 Marek Rouchal &amp;lt;marekr@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="c83f3f033b2fc96f5fc9ad533bd899a9d4b6ecc0" translate="yes" xml:space="preserve">
          <source>Mark Biggar said, when asked about to drop the '+' altogether, or make only &lt;code&gt;cmp&lt;/code&gt; work:</source>
          <target state="translated">Mark Biggar는 '+'를 모두 떨어 뜨리거나 &lt;code&gt;cmp&lt;/code&gt; 만 작동 하도록 요청하면 다음과 같이 말했습니다 .</target>
        </trans-unit>
        <trans-unit id="377509d88d53597d4ff4d33c6f13c1974a06e69d" translate="yes" xml:space="preserve">
          <source>Mark Biggar, overloaded interface by Ilya Zakharevich. Completely rewritten by Tels &lt;a href=&quot;http://bloodgate.com&quot;&gt;http://bloodgate.com&lt;/a&gt; in 2001 - 2006, and still at it in 2007.</source>
          <target state="translated">Ilya Zakharevich의 오버로드 된 인터페이스 인 Mark Biggar. Tels &lt;a href=&quot;http://bloodgate.com&quot;&gt;http://bloodgate.com&lt;/a&gt; 은 2001 년부터 2006 년 까지 완전히 재 작성 했으며 2007 년에도 그대로 재 작성했습니다 .</target>
        </trans-unit>
        <trans-unit id="d300b7701521ff8a33f7b33d0188a117c431b382" translate="yes" xml:space="preserve">
          <source>Mark Jason Dominus</source>
          <target state="translated">마크 제이슨 도미 누스</target>
        </trans-unit>
        <trans-unit id="450f27b0693fb0a8da6251b3b74d437c26be547d" translate="yes" xml:space="preserve">
          <source>Mark Kettenis &amp;lt;kettenis@gnu.org&amp;gt;</source>
          <target state="translated">마크 케 테니스 &amp;lt;kettenis@gnu.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="81bc652b2afe581a8637a9ead94c1a383e00b3d9" translate="yes" xml:space="preserve">
          <source>Mark Reed and Roland Giersig -- Klingon translators.</source>
          <target state="translated">Mark Reed와 Roland Giersig-Klingon 번역가.</target>
        </trans-unit>
        <trans-unit id="e5f44ec87511dcf9977a4ec17e09815c5d4e4d80" translate="yes" xml:space="preserve">
          <source>Mark all the current temporaries for reuse</source>
          <target state="translated">재사용 할 수 있도록 모든 현재 임시 표시</target>
        </trans-unit>
        <trans-unit id="434c6b3d12f78673c6f025dc43bd2b5e87746cf6" translate="yes" xml:space="preserve">
          <source>Mark message &lt;code&gt;MSGNUM&lt;/code&gt; to be deleted from the remote mailbox. All messages that are marked to be deleted will be removed from the remote mailbox when the server connection closed.</source>
          <target state="translated">원격 사서함에서 삭제할 &lt;code&gt;MSGNUM&lt;/code&gt; 메시지를 표시 하십시오. 서버 연결이 닫히면 삭제 표시된 모든 메시지가 원격 사서함에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="3fc451fa99eddaf84abe45f817ed60d28d73925f" translate="yes" xml:space="preserve">
          <source>Mark modules as loaded or unloaded</source>
          <target state="translated">모듈을로드 또는 언로드로 표시</target>
        </trans-unit>
        <trans-unit id="0952995ce715e0fcf16177cb607a92712143f22b" translate="yes" xml:space="preserve">
          <source>Mark places that need to be revisited with XXX (and revisit often!)</source>
          <target state="translated">XXX로 다시 방문해야하는 장소를 표시하고 자주 방문하십시오.</target>
        </trans-unit>
        <trans-unit id="f890cc48bd62c292c1b2117bad32ccde46514a4e" translate="yes" xml:space="preserve">
          <source>Mark stack</source>
          <target state="translated">마크 스택</target>
        </trans-unit>
        <trans-unit id="757fbf6071a2b2fed849d8ec18f9f6866d396b4c" translate="yes" xml:space="preserve">
          <source>Mark the stream as line buffered. &lt;code&gt;PerlIOBase_setlinebuf()&lt;/code&gt; sets the PERLIO_F_LINEBUF flag and is normally sufficient.</source>
          <target state="translated">스트림을 라인 버퍼링 된 것으로 표시하십시오. &lt;code&gt;PerlIOBase_setlinebuf()&lt;/code&gt; 는 PERLIO_F_LINEBUF 플래그를 설정하며 일반적으로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="0da58592dac4b83b59b8524c503019ad8f94d0df" translate="yes" xml:space="preserve">
          <source>Mark-Jason Dominus (&lt;code&gt;mjd-perl-memoize+@plover.com&lt;/code&gt; ), Plover Systems co.</source>
          <target state="translated">Mark-Jason Dominus ( &lt;code&gt;mjd-perl-memoize+@plover.com&lt;/code&gt; ), Plover Systems 사</target>
        </trans-unit>
        <trans-unit id="46fb530910c2bcc92b57abfd9b169a4f2b074dec" translate="yes" xml:space="preserve">
          <source>Mark-Jason Dominus (mjd-perl-memoize+@plover.com)</source>
          <target state="translated">Mark-Jason Dominus (mjd-perl-memoize+@plover.com)</target>
        </trans-unit>
        <trans-unit id="98f68109ba2dde58a98de8a29bc502b61b464f61" translate="yes" xml:space="preserve">
          <source>Marks an SV as tainted if tainting is enabled.</source>
          <target state="translated">오염이 활성화 된 경우 SV를 오염 된 것으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="2db65aa42a74dc9034cc35ce6c1faf364427ed3b" translate="yes" xml:space="preserve">
          <source>Marks an existing SV as mortal. The SV will be destroyed &quot;soon&quot;, either by an explicit call to FREETMPS, or by an implicit call at places such as statement boundaries. SvTEMP() is turned on which means that the SV's string buffer can be &quot;stolen&quot; if this SV is copied. See also &lt;code&gt;sv_newmortal&lt;/code&gt; and &lt;code&gt;sv_mortalcopy&lt;/code&gt; .</source>
          <target state="translated">기존 SV를 필사자로 표시합니다. SV는 FREETMPS를 명시 적으로 호출하거나 명령문 경계와 같은 위치에서 암시 적 호출을 통해 &quot;곧&quot;파괴됩니다. SvTEMP ()가 켜져 있으면이 SV를 복사하면 SV의 문자열 버퍼를 &quot;도난 당&quot;할 수 있습니다. &lt;code&gt;sv_newmortal&lt;/code&gt; 및 &lt;code&gt;sv_mortalcopy&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff643d8dde56f37f877ff7ade1da6aae5c6540db" translate="yes" xml:space="preserve">
          <source>Marks o as having no further siblings. On &lt;code&gt;PERL_OP_PARENT&lt;/code&gt; builds, marks o as having the specified parent. See also &lt;code&gt;OpMORESIB_set&lt;/code&gt; and &lt;code&gt;OpMAYBESIB_set&lt;/code&gt; . For a higher-level interface, see &lt;code&gt;op_sibling_splice&lt;/code&gt; .</source>
          <target state="translated">더 이상 형제가없는 것으로 o를 표시합니다. 일 &lt;code&gt;PERL_OP_PARENT&lt;/code&gt; 이 빌드 O 지정된 부모를 가지는 것으로 표시. &lt;code&gt;OpMORESIB_set&lt;/code&gt; 및 &lt;code&gt;OpMAYBESIB_set&lt;/code&gt; 도 참조하십시오 . 고급 인터페이스는 &lt;code&gt;op_sibling_splice&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f648546860128e7a1516008b618e091f14b60522" translate="yes" xml:space="preserve">
          <source>Marks the object as taint-clean, and as such data read from it will also be considered taint-clean. Note that this is a very trusting action to take, and appropriate consideration for the data source and potential vulnerability should be kept in mind. Returns 0 on success, -1 if setting the taint-clean flag failed. (eg invalid handle)</source>
          <target state="translated">객체를 얼룩 제거로 표시하고, 읽은 데이터도 얼룩 제거로 간주됩니다. 이 작업은 매우 신뢰할 수있는 조치이므로 데이터 소스 및 잠재적 취약점에 대한 적절한 고려 사항을 염두에 두어야합니다. 오염 제거 플래그 설정에 실패하면 성공하면 0을, -1을 반환합니다. (예 : 잘못된 핸들)</target>
        </trans-unit>
        <trans-unit id="4a22faf92173de5f56b8198d2fcad5f9500ee814" translate="yes" xml:space="preserve">
          <source>Marks the package as loaded to perl. &lt;code&gt;PACKAGE&lt;/code&gt; can be a bareword or string.</source>
          <target state="translated">패키지를 perl에로드 된 것으로 표시합니다. &lt;code&gt;PACKAGE&lt;/code&gt; 는 베어 워드 또는 문자열 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04902927b1471c77962c6cabf557af3a4b22b23b" translate="yes" xml:space="preserve">
          <source>Marks the package as unloaded to perl, which is the exact opposite of &lt;code&gt;mark_as_loaded&lt;/code&gt; . &lt;code&gt;PACKAGE&lt;/code&gt; can be a bareword or string.</source>
          <target state="translated">패키지를 perl에 언로드 된 것으로 표시합니다. 이는 &lt;code&gt;mark_as_loaded&lt;/code&gt; 와 정확히 반대입니다 . &lt;code&gt;PACKAGE&lt;/code&gt; 는 베어 워드 또는 문자열 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c1f770624b796cd596d3a67943a0c4353130d2c" translate="yes" xml:space="preserve">
          <source>Marks the variable as multiply defined, thus preventing the:</source>
          <target state="translated">변수를 곱셈으로 표시하여 다음을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="37e5fcb1ae2486eac4310780e954d1d2153d08b1" translate="yes" xml:space="preserve">
          <source>Mastering Perl</source>
          <target state="translated">마스터 링 펄</target>
        </trans-unit>
        <trans-unit id="ea351e672a82e1244cd8779022e09f0034f5a7e1" translate="yes" xml:space="preserve">
          <source>Mastering Regular Expressions</source>
          <target state="translated">정규 표현식 마스터하기</target>
        </trans-unit>
        <trans-unit id="22d4d02d8da4f8d133bb080e8bf0a53687196993" translate="yes" xml:space="preserve">
          <source>Match 'a' followed by 'b' followed by 'c'. We are on a roll and have satisfied the first group. Set $1 to 'abc'.</source>
          <target state="translated">'a'와 'b', 'c'가 일치합니다. 우리는 롤에 올라 첫 그룹을 만족 시켰습니다. $ 1을 'abc'로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="11c4d0b2479d50705f90c54d0532f70025aab256" translate="yes" xml:space="preserve">
          <source>Match 'a' followed by 'b'. So far so good.</source>
          <target state="translated">'a'다음에 'b'를 찾습니다. 여태까지는 그런대로 잘됐다.</target>
        </trans-unit>
        <trans-unit id="2d4b771841aed044053e2a7426782a75fac41932" translate="yes" xml:space="preserve">
          <source>Match all subsections of &lt;code&gt;DESCRIPTION&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;DESCRIPTION&lt;/code&gt; 의 모든 하위 섹션과 일치</target>
        </trans-unit>
        <trans-unit id="0b37627cd568766a8a2fde5b6baa2adc0dd0c782" translate="yes" xml:space="preserve">
          <source>Match all top level sections but none of their subsections:</source>
          <target state="translated">모든 최상위 섹션과 일치하지만 하위 섹션은 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d0596c8f0742f8f130e5e576d30972fa9f4302b5" translate="yes" xml:space="preserve">
          <source>Match only the &lt;code&gt;Question&lt;/code&gt; and &lt;code&gt;Answer&lt;/code&gt; subsections of the &lt;code&gt;DESCRIPTION&lt;/code&gt; section:</source>
          <target state="translated">&lt;code&gt;DESCRIPTION&lt;/code&gt; 섹션 의 &lt;code&gt;Question&lt;/code&gt; 과 &lt;code&gt;Answer&lt;/code&gt; 하위 섹션 만 일치시킵니다 .</target>
        </trans-unit>
        <trans-unit id="c0e7fa8eb9c5a3355dde0bfcb14e87f4ae52937c" translate="yes" xml:space="preserve">
          <source>Match the 'd'.</source>
          <target state="translated">'d'와 일치하십시오.</target>
        </trans-unit>
        <trans-unit id="be1f5f366bde2e61ff344fc7793ee6e0a4508408" translate="yes" xml:space="preserve">
          <source>Match the &lt;code&gt;Comments&lt;/code&gt; subsection of</source>
          <target state="translated">의 &lt;code&gt;Comments&lt;/code&gt; 하위 섹션과 일치</target>
        </trans-unit>
        <trans-unit id="e025337ed7c230f237c28a1acfe5d3575399196a" translate="yes" xml:space="preserve">
          <source>Match the &lt;code&gt;DESCRIPTION&lt;/code&gt; section but do</source>
          <target state="translated">&lt;code&gt;DESCRIPTION&lt;/code&gt; 섹션과 일치 하지만</target>
        </trans-unit>
        <trans-unit id="809b44171d8c193bc9b4db448d041eca1d612988" translate="yes" xml:space="preserve">
          <source>Match the &lt;code&gt;NAME&lt;/code&gt; and &lt;code&gt;SYNOPSIS&lt;/code&gt; sections and all of their subsections:</source>
          <target state="translated">&lt;code&gt;NAME&lt;/code&gt; 및 &lt;code&gt;SYNOPSIS&lt;/code&gt; 섹션과 모든 하위 섹션을 일치 시키십시오 .</target>
        </trans-unit>
        <trans-unit id="d89688e77597d0f0b5bc24a196b8aa4f24d28f78" translate="yes" xml:space="preserve">
          <source>Matches a character that has a non-canonical decomposition.</source>
          <target state="translated">비정규 분해 된 문자를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="a6f252d85159e471dcc7245d171fafb38fcd2b97" translate="yes" xml:space="preserve">
          <source>Matches a literal '.'. Equivalent to the Perl regular expression</source>
          <target state="translated">리터럴 '.'와 일치합니다. Perl 정규식과 동일</target>
        </trans-unit>
        <trans-unit id="93575811859840b893fbf3a9e80a1bb8c50a691a" translate="yes" xml:space="preserve">
          <source>Matches any character that is graphic. Theoretically, this means a character that on a printer would cause ink to be used.</source>
          <target state="translated">그래픽 인 모든 문자와 일치합니다. 이론적으로 이것은 프린터에서 잉크를 사용하게하는 문자를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d54b8cec84523d2bbc940d4158b99d956e15f640" translate="yes" xml:space="preserve">
          <source>Matches as &lt;code&gt;SSS...S&lt;/code&gt; (repeated as many times as necessary).</source>
          <target state="translated">&lt;code&gt;SSS...S&lt;/code&gt; 와 일치합니다 (필요한 횟수만큼 반복).</target>
        </trans-unit>
        <trans-unit id="c4ff6981c871c3a904b9e8169f3626531b5fd219" translate="yes" xml:space="preserve">
          <source>Matches as &lt;code&gt;S{max}|S{max-1}|...|S{min+1}|S{min}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;S{max}|S{max-1}|...|S{min+1}|S{min}&lt;/code&gt; 과 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="bd5e1550fb89dce10a89ca6b24a5232964ff2f7b" translate="yes" xml:space="preserve">
          <source>Matches as &lt;code&gt;S{min}|S{min+1}|...|S{max-1}|S{max}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;S{min}|S{min+1}|...|S{max-1}|S{max}&lt;/code&gt; 와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="5723f68cdd1b82a0a16aaa3d449fb53afe9be816" translate="yes" xml:space="preserve">
          <source>Matches in the Block property have shortcuts that begin with &quot;In_&quot;. For example, &lt;code&gt;\p{Block=Latin1}&lt;/code&gt; can be written as &lt;code&gt;\p{In_Latin1}&lt;/code&gt; . For backward compatibility, if there is no conflict with another shortcut, these may also be written as &lt;code&gt;\p{Latin1}&lt;/code&gt; or &lt;code&gt;\p{Is_Latin1}&lt;/code&gt; . But, N.B., there are numerous such conflicting shortcuts. Use of these forms for Block is discouraged, and are flagged as such, not only because of the potential confusion as to what is meant, but also because a later release of Unicode may preempt the shortcut, and your program would no longer be correct. Use the &quot;In_&quot; form instead to avoid this, or even more clearly, use the compound form, e.g., &lt;code&gt;\p{blk:latin1}&lt;/code&gt; . See &lt;a href=&quot;perlunicode#Blocks&quot;&gt;Blocks in perlunicode&lt;/a&gt; for more information about this.</source>
          <target state="translated">블록 속성의 일치 항목에는 &quot;In_&quot;로 시작하는 바로 가기가 있습니다. 예를 들어, &lt;code&gt;\p{Block=Latin1}&lt;/code&gt; 은 &lt;code&gt;\p{In_Latin1}&lt;/code&gt; 로 쓸 수 있습니다 . 이전 버전과의 호환성을 위해 다른 바로 가기와 충돌이없는 경우 &lt;code&gt;\p{Latin1}&lt;/code&gt; 또는 &lt;code&gt;\p{Is_Latin1}&lt;/code&gt; 로 작성 될 수도 있습니다 . 그러나 NB에는 그러한 상충되는 단축키가 많이 있습니다. 이러한 형식의 블록 사용은 권장되지 않으며 의미에 대한 혼동 가능성뿐만 아니라 이후의 유니 코드 릴리스가 바로 가기를 선점 할 수 있으며 프로그램이 더 이상 정확하지 않기 때문에 플래그가 지정됩니다. 이를 피하기 위해 대신 &quot;In_&quot;양식을 사용하거나보다 명확하게는 복합 양식을 사용하십시오 (예 : &lt;code&gt;\p{blk:latin1}&lt;/code&gt; . 보다&lt;a href=&quot;perlunicode#Blocks&quot;&gt;이에&lt;/a&gt; 대한 자세한 정보 는 perlunicode의 블록입니다 .</target>
        </trans-unit>
        <trans-unit id="80d7f5dbe400c6fc8812e001032594152a2faa28" translate="yes" xml:space="preserve">
          <source>Matches the best match for &lt;code&gt;S&lt;/code&gt; and only that.</source>
          <target state="translated">&lt;code&gt;S&lt;/code&gt; 와 가장 일치하는 항목 만 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="099232daa21ff3b64c97abd1d81e14f11a613969" translate="yes" xml:space="preserve">
          <source>Matches zero or more characters, except '/'. Equivalent to the Perl regular expression</source>
          <target state="translated">'/'를 제외하고 0 개 이상의 문자와 일치합니다. Perl 정규식과 동일</target>
        </trans-unit>
        <trans-unit id="6a1984e70dd40a8e14356e78cd264d97a21884d9" translate="yes" xml:space="preserve">
          <source>Matches zero or one character, except '/'. Equivalent to the Perl regular expression</source>
          <target state="translated">'/'를 제외하고 0 개 또는 1 개의 문자와 일치합니다. Perl 정규식과 동일</target>
        </trans-unit>
        <trans-unit id="68a934788aa891939224fba053b378c53192480e" translate="yes" xml:space="preserve">
          <source>Matching Partial Keys</source>
          <target state="translated">일치하는 부분 키</target>
        </trans-unit>
        <trans-unit id="3b17040c55a83f3f4f7b152219e6e526f7ca9a2a" translate="yes" xml:space="preserve">
          <source>Matching any of several properties in regular expressions.</source>
          <target state="translated">정규식의 여러 속성 중 하나와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="6220591a5ccdb9123634e1caf4ce8dc3384cfc2e" translate="yes" xml:space="preserve">
          <source>Matching operations can have various modifiers. Modifiers that relate to the interpretation of the regular expression inside are listed below. Modifiers that alter the way a regular expression is used by Perl are detailed in &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt; and &lt;a href=&quot;perlop#Gory-details-of-parsing-quoted-constructs&quot;&gt;Gory details of parsing quoted constructs in perlop&lt;/a&gt;.</source>
          <target state="translated">일치하는 조작에는 다양한 수정자가있을 수 있습니다. 정규 표현식 내부의 해석과 관련된 수정자는 다음과 같습니다. 정규 표현식은 펄에 의해 사용되는 방식을 변경 수정 자에 자세히 설명되어 있습니다 &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;perlop에서 정규 표현식 견적 같은 연산자&lt;/a&gt; 와 &lt;a href=&quot;perlop#Gory-details-of-parsing-quoted-constructs&quot;&gt;perlop에서 인용 구조를 구문 분석의 피투성이 세부 사항&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fc4353fa78241930d31f3d814bb73f45e31af0a6" translate="yes" xml:space="preserve">
          <source>Matching repetitions</source>
          <target state="translated">일치하는 반복</target>
        </trans-unit>
        <trans-unit id="292a005613f8b511eb0b5b4a734aa7ff4e96c83f" translate="yes" xml:space="preserve">
          <source>Matching this or that</source>
          <target state="translated">이것 또는 저것과 일치</target>
        </trans-unit>
        <trans-unit id="7bedce9e99b3de1dadd0cc8345ab455769b51642" translate="yes" xml:space="preserve">
          <source>Math Library</source>
          <target state="translated">수학 라이브러리</target>
        </trans-unit>
        <trans-unit id="dbc9077ff7ea4f194a50599f69ee6ce9e49343a0" translate="yes" xml:space="preserve">
          <source>Math library</source>
          <target state="translated">수학 라이브러리</target>
        </trans-unit>
        <trans-unit id="5dde5a34dad7754b1821ed0116c07f6b3c7c4405" translate="yes" xml:space="preserve">
          <source>Math with the numbers is done (by default) by a module called</source>
          <target state="translated">숫자가있는 수학은 기본적으로 모듈이라고합니다.</target>
        </trans-unit>
        <trans-unit id="65a2121388185141d7f0caa9707912405aa48f4e" translate="yes" xml:space="preserve">
          <source>Math with the numbers is done (by default) by a module called &lt;code&gt;Math::BigInt::Calc&lt;/code&gt; . This is equivalent to saying:</source>
          <target state="translated">숫자가있는 수학은 기본적으로 &lt;code&gt;Math::BigInt::Calc&lt;/code&gt; 모듈에 의해 수행됩니다 . 이것은 말하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="51f99b48efcd60261390302dfaa9e7f1788ebcc0" translate="yes" xml:space="preserve">
          <source>Math with the numbers is done (by default) by a module called Math::BigInt::Calc. This is equivalent to saying:</source>
          <target state="translated">숫자가있는 수학은 기본적으로 Math :: BigInt :: Calc라는 모듈에 의해 수행됩니다. 이것은 말하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a07cdeda4567e42eb8f69d272a000e41f1b29c0e" translate="yes" xml:space="preserve">
          <source>Math::BigFloat</source>
          <target state="translated">Math::BigFloat</target>
        </trans-unit>
        <trans-unit id="fe59e6f09a28dc58e14251546f9c9f1708a1bf4c" translate="yes" xml:space="preserve">
          <source>Math::BigFloat - Arbitrary size floating point math package</source>
          <target state="translated">Math :: BigFloat-임의의 크기 부동 소수점 수학 패키지</target>
        </trans-unit>
        <trans-unit id="8e8c8a53ad2ae8063e325c75dd2f5dac801b81e3" translate="yes" xml:space="preserve">
          <source>Math::BigFloat supports all methods that Math::BigInt supports, except it calculates non-integer results when possible. Please see &lt;a href=&quot;bigint&quot;&gt;Math::BigInt&lt;/a&gt; for a full description of each method. Below are just the most important differences:</source>
          <target state="translated">Math :: BigFloat는 가능하면 정수가 아닌 결과를 계산하는 것을 제외하고 Math :: BigInt가 지원하는 모든 메소드를 지원합니다. 각 방법에 대한 자세한 설명 은 &lt;a href=&quot;bigint&quot;&gt;Math :: BigInt&lt;/a&gt; 를 참조하십시오 . 다음은 가장 중요한 차이점입니다.</target>
        </trans-unit>
        <trans-unit id="780bc62d9e1c2da0b867ab07361ad578cdc89952" translate="yes" xml:space="preserve">
          <source>Math::BigFloat supports both precision (rounding to a certain place before or after the dot) and accuracy (rounding to a certain number of digits). For a full documentation, examples and tips on these topics please see the large section about rounding in &lt;a href=&quot;bigint&quot;&gt;Math::BigInt&lt;/a&gt;.</source>
          <target state="translated">Math :: BigFloat는 정밀도 (점 앞뒤의 특정 위치로 반올림)와 정확도 (특정 자릿수로 반올림)를 모두 지원합니다. 이러한 주제에 대한 전체 문서, 예제 및 팁은 &lt;a href=&quot;bigint&quot;&gt;Math :: BigInt&lt;/a&gt; 에서 반올림에 대한 큰 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b2789f47b2fa742bffb303cb5ea1d3e3348e9f0" translate="yes" xml:space="preserve">
          <source>Math::BigInt</source>
          <target state="translated">Math::BigInt</target>
        </trans-unit>
        <trans-unit id="5c0b5ec1b926593506155ef502257108ea19865c" translate="yes" xml:space="preserve">
          <source>Math::BigInt - Arbitrary size integer/float math package</source>
          <target state="translated">Math :: BigInt-임의 크기 정수 / 부동 수학 패키지</target>
        </trans-unit>
        <trans-unit id="d6c99c78464ade46f8079c42dd339841ba07d8ba" translate="yes" xml:space="preserve">
          <source>Math::BigInt::Calc</source>
          <target state="translated">Math::BigInt::Calc</target>
        </trans-unit>
        <trans-unit id="fb8a4bd98ced9e335bf9d9e0731551b00eb92084" translate="yes" xml:space="preserve">
          <source>Math::BigInt::Calc - Pure Perl module to support Math::BigInt</source>
          <target state="translated">Math :: BigInt :: Calc-Math :: BigInt를 지원하는 Pure Perl 모듈</target>
        </trans-unit>
        <trans-unit id="83eed48c0cfaa744405df7e64a828e97c7dc018c" translate="yes" xml:space="preserve">
          <source>Math::BigInt::Calc with some XS for more speed</source>
          <target state="translated">더 빠른 속도를 위해 일부 XS를 사용하여 Math :: BigInt :: Calc</target>
        </trans-unit>
        <trans-unit id="37cc8c4470bd2dc063bf4602791a5a2898c073f2" translate="yes" xml:space="preserve">
          <source>Math::BigInt::CalcEmu</source>
          <target state="translated">Math::BigInt::CalcEmu</target>
        </trans-unit>
        <trans-unit id="bd9adb285778e576dd3a1c8d47e1303fcd5d2e82" translate="yes" xml:space="preserve">
          <source>Math::BigInt::CalcEmu - Emulate low-level math with BigInt code</source>
          <target state="translated">Math :: BigInt :: CalcEmu-BigInt 코드로 저수준 수학 에뮬레이션</target>
        </trans-unit>
        <trans-unit id="a6065b7a8854e3e8b505e0d8a52c5366a086da7a" translate="yes" xml:space="preserve">
          <source>Math::BigInt::FastCalc</source>
          <target state="translated">Math::BigInt::FastCalc</target>
        </trans-unit>
        <trans-unit id="07a7add3262d9f2bcc6e971e59caaf7ebde004ed" translate="yes" xml:space="preserve">
          <source>Math::BigInt::FastCalc - Math::BigInt::Calc with some XS for more speed</source>
          <target state="translated">Math :: BigInt :: FastCalc-Math :: BigInt :: 더 빠른 속도를 위해 일부 XS를 사용한 계산기</target>
        </trans-unit>
        <trans-unit id="4b2aca3f9cc0a116b76f8d86d32d03b2be17c352" translate="yes" xml:space="preserve">
          <source>Math::BigRat</source>
          <target state="translated">Math::BigRat</target>
        </trans-unit>
        <trans-unit id="ac918a8052350ca0ef4432d06915fcf97fe7f4ff" translate="yes" xml:space="preserve">
          <source>Math::BigRat - Arbitrary big rational numbers</source>
          <target state="translated">Math :: BigRat-임의의 큰 유리수</target>
        </trans-unit>
        <trans-unit id="5a51ed6183023c12205f7010c9031e0ea41bd8ab" translate="yes" xml:space="preserve">
          <source>Math::BigRat complements Math::BigInt and Math::BigFloat by providing support for arbitrary big rational numbers.</source>
          <target state="translated">Math :: BigRat은 임의의 큰 유리수를 지원하여 Math :: BigInt 및 Math :: BigFloat를 보완합니다.</target>
        </trans-unit>
        <trans-unit id="c80a28032631e0b53fe6cfb473619c4706043d3a" translate="yes" xml:space="preserve">
          <source>Math::Complex</source>
          <target state="translated">Math::Complex</target>
        </trans-unit>
        <trans-unit id="33bb8bb129e5a0d683c736bb8619d7d51a89c445" translate="yes" xml:space="preserve">
          <source>Math::Complex - complex numbers and associated mathematical functions</source>
          <target state="translated">Math :: Complex-복소수 및 관련 수학 함수</target>
        </trans-unit>
        <trans-unit id="1e616d3d033099b786d6a5348898f4e4eaaef6c6" translate="yes" xml:space="preserve">
          <source>Math::Trig</source>
          <target state="translated">Math::Trig</target>
        </trans-unit>
        <trans-unit id="c69768dcbf705d5dd806188830336370c242165f" translate="yes" xml:space="preserve">
          <source>Math::Trig - trigonometric functions</source>
          <target state="translated">Math :: Trig-삼각 함수</target>
        </trans-unit>
        <trans-unit id="1c3decdb38e1f19ad133e95ff4746595003c9925" translate="yes" xml:space="preserve">
          <source>Mathemagic, Mutators, and Copy Constructors</source>
          <target state="translated">Mathemagic, 뮤 테이터 및 복사 생성자</target>
        </trans-unit>
        <trans-unit id="8edc9ac7baa876487a18001d1e0613039a5fb80e" translate="yes" xml:space="preserve">
          <source>Mathematical functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="418773dca64d526cfea9242d86f08af7459acfc2" translate="yes" xml:space="preserve">
          <source>Mathematical jargon for a list of &lt;b&gt;scalar values&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;스칼라 값&lt;/b&gt; 목록에 대한 수학 용어 .</target>
        </trans-unit>
        <trans-unit id="aa8961350eea449561e0373a262893039189bac1" translate="yes" xml:space="preserve">
          <source>Mathematically, a mapping of each of a set of input values to a particular output value. In computers, refers to a &lt;b&gt;subroutine&lt;/b&gt; or &lt;b&gt;operator&lt;/b&gt; that returns a &lt;b&gt;value&lt;/b&gt;. It may or may not have input values (called &lt;b&gt;arguments&lt;/b&gt;).</source>
          <target state="translated">수학적으로 입력 값 집합 각각을 특정 출력 값에 매핑합니다. 컴퓨터에서 &lt;b&gt;값&lt;/b&gt; 을 반환하는 &lt;b&gt;서브 루틴&lt;/b&gt; 또는 &lt;b&gt;연산자&lt;/b&gt; 를 나타냅니다 . 입력 값이 있거나 없을 수 있습니다 ( &lt;b&gt;arguments&lt;/b&gt; 라고 함 ).&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="08452ede2be309e7d15ec8e7c08c3981bd4285e0" translate="yes" xml:space="preserve">
          <source>Matt Sergeant, matt@sergeant.org</source>
          <target state="translated">매트 상사, matt@sergeant.org</target>
        </trans-unit>
        <trans-unit id="667478bd6904915672e26b2134308dabeb1c00d5" translate="yes" xml:space="preserve">
          <source>Matt Sergeant, matt@sergeant.org Jarkko Hietaniemi, jhi@iki.fi (while creating Time::Piece for core perl)</source>
          <target state="translated">Matt Sergeant, matt@sergeant.org Jarkko Hietaniemi, jhi@iki.fi (핵심 Perl의 Time :: Piece 작성 중)</target>
        </trans-unit>
        <trans-unit id="a5b0f4aadc0e2c80f215b9e66188372b0c8b6032" translate="yes" xml:space="preserve">
          <source>Max Maischein &lt;code&gt; corion@cpan.org &lt;/code&gt;</source>
          <target state="translated">막스 마이 &lt;code&gt; corion@cpan.org &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2bc823b3979073e6178e0296c0aebc017c151728" translate="yes" xml:space="preserve">
          <source>Maximum of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt;, except when either is &lt;code&gt;NaN&lt;/code&gt; , returns the other [C99].</source>
          <target state="translated">&lt;code&gt;NaN&lt;/code&gt; 일 때를 제외하고 최대 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; 는 다른 [C99]를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="afc54fe3511cd56aa93944ccd6c2072e2ca51d94" translate="yes" xml:space="preserve">
          <source>May also be called as a</source>
          <target state="translated">로도 불릴 수 있습니다</target>
        </trans-unit>
        <trans-unit id="76be650e3300b2492c54955a124602e50e04fd33" translate="yes" xml:space="preserve">
          <source>May be called as a class method</source>
          <target state="translated">클래스 메소드로 호출 가능</target>
        </trans-unit>
        <trans-unit id="373dacfb6afd2988bb2976a418753e29f34aa9dd" translate="yes" xml:space="preserve">
          <source>May be interrupted if the process receives a signal such as &lt;code&gt;SIGALRM&lt;/code&gt; .</source>
          <target state="translated">프로세스가 &lt;code&gt;SIGALRM&lt;/code&gt; 과 같은 신호를 수신하면 중단 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2230ed94de04068bc4c024644ecc248cb32a6f12" translate="yes" xml:space="preserve">
          <source>May be set to &lt;code&gt;-protoypes&lt;/code&gt; , &lt;code&gt;-noprototypes&lt;/code&gt; or the empty string. The empty string is equivalent to the xsubpp default, or &lt;code&gt;-noprototypes&lt;/code&gt; . See the xsubpp documentation for details. MakeMaker defaults to the empty string.</source>
          <target state="translated">&lt;code&gt;-protoypes&lt;/code&gt; , &lt;code&gt;-noprototypes&lt;/code&gt; 또는 빈 문자열 로 설정 될 수 있습니다 . 빈 문자열은 xsubpp 기본값 또는 &lt;code&gt;-noprototypes&lt;/code&gt; 와 같습니다 . 자세한 내용은 xsubpp 설명서를 참조하십시오. MakeMaker의 기본값은 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="f8aed58dc1a5779f9d540d01df5f9836265ac5aa" translate="yes" xml:space="preserve">
          <source>May not be available if library or source was not provided when building perl. (Win32)</source>
          <target state="translated">perl을 빌드 할 때 라이브러리 또는 소스가 제공되지 않은 경우 사용할 수 없습니다. (Win32)</target>
        </trans-unit>
        <trans-unit id="21d4e632642238bf57dcc94af3549a614c826f30" translate="yes" xml:space="preserve">
          <source>May not behave as expected. Behavior depends on the C runtime library's implementation of &lt;code&gt;&lt;a href=&quot;functions/utime&quot;&gt;utime()&lt;/a&gt;&lt;/code&gt;, and the filesystem being used. The FAT filesystem typically does not support an &quot;access time&quot; field, and it may limit timestamps to a granularity of two seconds. (Win32)</source>
          <target state="translated">예상대로 작동하지 않을 수 있습니다. 동작은 C 런타임 라이브러리의 &lt;code&gt;&lt;a href=&quot;functions/utime&quot;&gt;utime()&lt;/a&gt;&lt;/code&gt; 구현 및 사용중인 파일 시스템에 따라 다릅니다 . FAT 파일 시스템은 일반적으로 &quot;액세스 시간&quot;필드를 지원하지 않으며 타임 스탬프를 2 초 단위로 제한 할 수 있습니다. (Win32)</target>
        </trans-unit>
        <trans-unit id="55f01979402408f498d72bc9013d9ad19e4f0e16" translate="yes" xml:space="preserve">
          <source>May take extra time to study SCALAR (&lt;code&gt;$_&lt;/code&gt; if unspecified) in anticipation of doing many pattern matches on the string before it is next modified. This may or may not save time, depending on the nature and number of patterns you are searching and the distribution of character frequencies in the string to be searched; you probably want to compare run times with and without it to see which is faster. Those loops that scan for many short constant strings (including the constant parts of more complex patterns) will benefit most.</source>
          <target state="translated">다음에 문자열을 수정하기 전에 문자열에 대해 많은 패턴 일치를 예상하여 SCALAR ( 지정되지 않은 경우 &lt;code&gt;$_&lt;/code&gt; 를 연구하는 데 추가 시간이 걸릴 수 있습니다 . 검색하는 패턴의 성격과 수 및 검색 할 문자열의 문자 빈도 분포에 따라 시간을 절약하거나 절약 할 수 있습니다. 실행 시간과 실행 시간을 비교하여 어느 것이 더 빠른지 확인하고 싶을 것입니다. 많은 짧은 상수 문자열 (더 복잡한 패턴의 상수 부분 포함)을 스캔하는 루프가 가장 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5740917ad4ecd92dc69b592bee2c126f65bf64cc" translate="yes" xml:space="preserve">
          <source>Maybe an autolocking mode?</source>
          <target state="translated">자동 잠금 모드일까요?</target>
        </trans-unit>
        <trans-unit id="17baa904576f5c89cb04e825ade31958aeaa5cd3" translate="yes" xml:space="preserve">
          <source>Maybe simply that your function did not need to be exported in the first place. Perl has a long and not so glorious history of exporting functions that it should not have.</source>
          <target state="translated">아마도 단순히 함수를 먼저 내보낼 필요가 없었을 것입니다. Perl은 오랫동안 가져 오지 말아야 할 함수 내보내기의 길고 영광스럽지 않은 역사를 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e936eae5362c54e4c8af6287c324b783d9e5c3e" translate="yes" xml:space="preserve">
          <source>McAfee Guardian</source>
          <target state="translated">McAfee Guardian</target>
        </trans-unit>
        <trans-unit id="cde7070dd55ab5fad4aecced0aebd3d04e8674c3" translate="yes" xml:space="preserve">
          <source>Meaningless. (RISC OS)</source>
          <target state="translated">무의미한. (RISC OS)</target>
        </trans-unit>
        <trans-unit id="64570578bb629125c651aed9b004e56379071150" translate="yes" xml:space="preserve">
          <source>Means that the optimizer information is all that the regular expression contains, and thus one does not need to enter the regex engine at all.</source>
          <target state="translated">옵티 마이저 정보가 정규 표현식에 포함 된 모든 것이므로 정규식 엔진에 전혀 들어 가지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="5c65173ed0ec89e479fa09fd6c0c7e73dddb4a5c" translate="yes" xml:space="preserve">
          <source>Means you can still run your old program because we didn&amp;rsquo;t break any of the features or bugs it was relying on.</source>
          <target state="translated">우리가 의존했던 기능이나 버그를 깨뜨리지 않았으므로 이전 프로그램을 계속 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c883ddc8815110562192710c7cee3da6f78c83a" translate="yes" xml:space="preserve">
          <source>Means you don&amp;rsquo;t have to pay money to get it, but the copyright on it may still belong to someone else (like Larry).</source>
          <target state="translated">당신이 그것을 얻기 위해 돈을 지불 할 필요는 없지만 그것에 대한 저작권은 여전히 ​​Larry와 같은 다른 사람의 것일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbf0f10f278f2fd9b8fbb27cda2cf259516fe6e6" translate="yes" xml:space="preserve">
          <source>Means you&amp;rsquo;re not in legal trouble if you give a bootleg copy of it to your friends and we find out about it. In fact, we&amp;rsquo;d rather you gave a copy to all your friends.</source>
          <target state="translated">부트 레그 사본을 친구에게주고 우리가 그 사실을 알게된다면 법적인 문제가 없다는 것을 의미합니다. 사실, 모든 친구에게 사본을 주셨습니다.</target>
        </trans-unit>
        <trans-unit id="b4f338c26fdb57033fabc6dbb73636186214a368" translate="yes" xml:space="preserve">
          <source>Meanwhile in script.pl:</source>
          <target state="translated">한편 script.pl에서 :</target>
        </trans-unit>
        <trans-unit id="e31c01e90d9e8d19ca2313d7b406547f59ae64e3" translate="yes" xml:space="preserve">
          <source>Meanwhile, back in the main thread, we first create a queue (line 33) and queue up all the numbers from 3 to 1000 for checking, plus a termination notice. Then all we have to do to get the ball rolling is pass the queue and the first prime to the &lt;code&gt;check_num()&lt;/code&gt; subroutine (line 34).</source>
          <target state="translated">한편 메인 스레드로 돌아가서 먼저 대기열 (33 줄)을 만들고 확인을 위해 3에서 1000까지의 모든 숫자와 종료 통지를 대기열에 넣습니다. 그런 다음 볼 롤링을 얻기 위해 대기열과 첫 번째 프라임을 &lt;code&gt;check_num()&lt;/code&gt; 서브 루틴 (라인 34)으로 전달하기 만하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="8aa7bb99b5f3a119fade7cc10eb9fede5a084e8b" translate="yes" xml:space="preserve">
          <source>Meanwhile, special identifiers don't follow the above rules; For the most part, all of the identifiers in this category have a special meaning given by Perl. Because they have special parsing rules, these generally can't be fully-qualified. They come in four forms:</source>
          <target state="translated">한편 특수 식별자는 위의 규칙을 따르지 않습니다. 대부분이 카테고리의 모든 식별자는 Perl에 의해 주어진 특별한 의미를 갖습니다. 특별한 구문 분석 규칙이 있기 때문에 일반적으로 정규화 할 수 없습니다. 그들은 네 가지 형태로옵니다 :</target>
        </trans-unit>
        <trans-unit id="83a5148d83732e363f572eb9f62ae4a34ffe78f8" translate="yes" xml:space="preserve">
          <source>Mechanisms are available to help modules writers split their modules into autoloadable files. See the standard AutoLoader module described in &lt;a href=&quot;autoloader&quot;&gt;AutoLoader&lt;/a&gt; and in &lt;a href=&quot;autosplit&quot;&gt;AutoSplit&lt;/a&gt;, the standard SelfLoader modules in &lt;a href=&quot;selfloader&quot;&gt;SelfLoader&lt;/a&gt;, and the document on adding C functions to Perl code in &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;.</source>
          <target state="translated">모듈 작성자가 모듈을 자동로드 가능한 파일로 분할하는 데 도움이되는 메커니즘을 사용할 수 있습니다. 에 기재된 표준 자동로드 모듈 참조 &lt;a href=&quot;autoloader&quot;&gt;자동로드&lt;/a&gt; 와의 &lt;a href=&quot;autosplit&quot;&gt;자동 구분&lt;/a&gt; 에서 표준 SelfLoader 모듈 &lt;a href=&quot;selfloader&quot;&gt;SelfLoader&lt;/a&gt; 및 펄에 코드 C의 기능을 추가하는 문서 &lt;a href=&quot;perlxs&quot;&gt;perlxs를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f8b192f4447d1edc034616ab7c4aca49390dec0c" translate="yes" xml:space="preserve">
          <source>Memoization is not a cure-all:</source>
          <target state="translated">메모 화는 완전한 치료법이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e35c7de9275e303103a9cca4277120ada2fcee2d" translate="yes" xml:space="preserve">
          <source>Memoization is not magical.</source>
          <target state="translated">메모 화는 마법이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6f890b039269df17d39e9aef284c419ab8ca6d7a" translate="yes" xml:space="preserve">
          <source>Memoize</source>
          <target state="translated">Memoize</target>
        </trans-unit>
        <trans-unit id="5f81d99ecb62730206abe574a7c1d1cbed900a6f" translate="yes" xml:space="preserve">
          <source>Memoize - Make functions faster by trading space for time</source>
          <target state="translated">메모-시간을 절약 할 수있는 공간을 확보하여 기능을 더 빠르게</target>
        </trans-unit>
        <trans-unit id="843238e6a586f32a34512ff5be6c4efe5893f4d3" translate="yes" xml:space="preserve">
          <source>Memoize would then call &lt;code&gt;function&lt;/code&gt; whenever a cached value was entirely absent or was older than ten seconds.</source>
          <target state="translated">그런 다음 캐시 된 값이 완전히 없거나 10 초보다 오래된 경우 Memoize는 &lt;code&gt;function&lt;/code&gt; 를 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="029c7227d55a1555d4ad9945591262ad934bfa62" translate="yes" xml:space="preserve">
          <source>Memoize::AnyDBM_File</source>
          <target state="translated">Memoize::AnyDBM_File</target>
        </trans-unit>
        <trans-unit id="f7222db52a03e50045b47cd151cf03999d99b842" translate="yes" xml:space="preserve">
          <source>Memoize::AnyDBM_File - glue to provide EXISTS for AnyDBM_File for Storable use</source>
          <target state="translated">Memoize :: AnyDBM_File-저장 가능한 AnyDBM_File에 EXISTS를 제공하기위한 접착제</target>
        </trans-unit>
        <trans-unit id="ab0d35e554a3be52fed5431a1db1dc0af18b1554" translate="yes" xml:space="preserve">
          <source>Memoize::Expire</source>
          <target state="translated">Memoize::Expire</target>
        </trans-unit>
        <trans-unit id="68da8c7a0efad73320d46b4b430e0877571aa887" translate="yes" xml:space="preserve">
          <source>Memoize::Expire - Plug-in module for automatic expiration of memoized values</source>
          <target state="translated">Memoize :: Expire-메모 된 값의 자동 만료를위한 플러그인 모듈</target>
        </trans-unit>
        <trans-unit id="0361cce2dcbb0a8d3953fc3f935563867ef2d797" translate="yes" xml:space="preserve">
          <source>Memoize::Expire is a layer of software that you can insert in between Memoize itself and whatever underlying package implements the cache. The layer presents a hash variable whose values expire whenever they get too old, have been used too often, or both. You tell &lt;code&gt;Memoize&lt;/code&gt; to use this forgetful hash as its cache instead of the default, which is an ordinary hash.</source>
          <target state="translated">Memoize :: Expire는 Memoize 자체와 기본 패키지가 캐시를 구현하는 모든 항목 사이에 삽입 할 수있는 소프트웨어 계층입니다. 계층은 값이 너무 오래되거나 너무 자주 사용되거나 둘 다가 될 때마다 값이 만료되는 해시 변수를 나타냅니다. 당신은 말할 &lt;code&gt;Memoize&lt;/code&gt; 를 일반 해시 대신 기본의 캐시로이 건망증이 해시를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5ce5e44b5b097a389f35898a0295eae63ccf4c6e" translate="yes" xml:space="preserve">
          <source>Memoize::Expire is a plug-in module for Memoize. It allows the cached values for memoized functions to expire automatically. This manual assumes you are already familiar with the Memoize module. If not, you should study that manual carefully first, paying particular attention to the HASH feature.</source>
          <target state="translated">Memoize :: Expire는 Memoize 용 플러그인 모듈입니다. 메모 함수의 캐시 된 값이 자동으로 만료되도록합니다. 이 매뉴얼은 사용자가 이미 Memoize 모듈에 익숙하다고 가정합니다. 그렇지 않은 경우 해시 기능에 특히주의하면서 해당 매뉴얼을주의 깊게 연구해야합니다.</target>
        </trans-unit>
        <trans-unit id="058ef175eeea79174423065d5def30710bbd9b3d" translate="yes" xml:space="preserve">
          <source>Memoize::Expire uses a real hash internally to store the cached data. You can use the &lt;code&gt;HASH&lt;/code&gt; option to Memoize::Expire to supply a tied hash in place of the ordinary hash that Memoize::Expire will normally use. You can use this feature to add Memoize::Expire as a layer in between a persistent disk hash and Memoize. If you do this, you get a persistent disk cache whose entries expire automatically. For example:</source>
          <target state="translated">Memoize :: Expire는 실제 해시를 사용하여 캐시 된 데이터를 저장합니다. &lt;code&gt;HASH&lt;/code&gt; 옵션을 Memoize :: Expire에 사용하여 Memoize :: Expire가 일반적으로 사용하는 일반 해시 대신 묶인 해시를 제공 할 수 있습니다. 이 기능을 사용하여 영구 디스크 해시와 Memoize 사이에 Memoize :: Expire를 계층으로 추가 할 수 있습니다. 이렇게하면 항목이 자동으로 만료되는 영구 디스크 캐시가 제공됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d269b32ccc7d9c3a39d79c1bc38b7d11bdeedce9" translate="yes" xml:space="preserve">
          <source>Memoize::ExpireFile</source>
          <target state="translated">Memoize::ExpireFile</target>
        </trans-unit>
        <trans-unit id="832a8b2c800fc41add4efb073f8dd0755c8d611b" translate="yes" xml:space="preserve">
          <source>Memoize::ExpireFile - test for Memoize expiration semantics</source>
          <target state="translated">Memoize :: ExpireFile-만기 시맨틱을 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="cfe63b7749d0c4b0ed459ed8a03537e27ee0964b" translate="yes" xml:space="preserve">
          <source>Memoize::ExpireTest</source>
          <target state="translated">Memoize::ExpireTest</target>
        </trans-unit>
        <trans-unit id="39f28a417ca2b739bec2a2c936fff15da4323299" translate="yes" xml:space="preserve">
          <source>Memoize::ExpireTest - test for Memoize expiration semantics</source>
          <target state="translated">Memoize :: ExpireTest-만기 시맨틱을위한 테스트</target>
        </trans-unit>
        <trans-unit id="76efc803a2cb3f46d2d6c0879436aa10ce1458f5" translate="yes" xml:space="preserve">
          <source>Memoize::NDBM_File</source>
          <target state="translated">Memoize::NDBM_File</target>
        </trans-unit>
        <trans-unit id="746b4220ae70f33c450a28158673789c9a546fde" translate="yes" xml:space="preserve">
          <source>Memoize::NDBM_File - glue to provide EXISTS for NDBM_File for Storable use</source>
          <target state="translated">Memoize :: NDBM_File-저장 가능 사용을 위해 NDBM_File에 EXISTS를 제공하기위한 접착제</target>
        </trans-unit>
        <trans-unit id="fd4bdbba9a5e54216d1795015c434a21a9711f86" translate="yes" xml:space="preserve">
          <source>Memoize::SDBM_File</source>
          <target state="translated">Memoize::SDBM_File</target>
        </trans-unit>
        <trans-unit id="da914c13c14b27bc717bfbef4040f10310d95a2d" translate="yes" xml:space="preserve">
          <source>Memoize::SDBM_File - glue to provide EXISTS for SDBM_File for Storable use</source>
          <target state="translated">Memoize :: SDBM_File-SDBM_File에 EXISTS를 제공하여 저장 가능</target>
        </trans-unit>
        <trans-unit id="21eebbc5fdb9d06943ca49fe99d3577c31994277" translate="yes" xml:space="preserve">
          <source>Memoize::Storable</source>
          <target state="translated">Memoize::Storable</target>
        </trans-unit>
        <trans-unit id="38149e962712243ad8d3efeb22a8323aef23996c" translate="yes" xml:space="preserve">
          <source>Memoize::Storable - store Memoized data in Storable database</source>
          <target state="translated">Memoize :: Storable-저장 가능한 데이터베이스에 메모 된 데이터 저장</target>
        </trans-unit>
        <trans-unit id="38b88ba291aedc801f0cf1ace141ae388b9947cc" translate="yes" xml:space="preserve">
          <source>Memory Allocation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0efdce50032a40b3a3914e5fc8bfa6cd4288bb5" translate="yes" xml:space="preserve">
          <source>Memory Management</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08cfd5338de5adae5d3a77de3eba507e6e489994" translate="yes" xml:space="preserve">
          <source>Memory Management and String Handling</source>
          <target state="translated">메모리 관리 및 문자열 처리</target>
        </trans-unit>
        <trans-unit id="c9a7ab7f07e403c0ae91c30f84e4c67c80a6e037" translate="yes" xml:space="preserve">
          <source>Memory allocated by external libraries is not counted.</source>
          <target state="translated">외부 라이브러리에 의해 할당 된 메모리는 계산되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b61b70edbe3a97caa2ecb5ac100b7aca209a1cba" translate="yes" xml:space="preserve">
          <source>Memory allocation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14ff314163f3b5b04d3fe92dafa744f973c3e836" translate="yes" xml:space="preserve">
          <source>Memory footprint debugging</source>
          <target state="translated">메모리 풋 프린트 디버깅</target>
        </trans-unit>
        <trans-unit id="f7c5b8ee1bf3d6c206de6c158ee1895b1a26d8cc" translate="yes" xml:space="preserve">
          <source>Memory logging is somewhat similar to &lt;code&gt;-Dm&lt;/code&gt; but is independent of &lt;code&gt;-DDEBUGGING&lt;/code&gt; , and at a higher level; all uses of Newx(), Renew(), and Safefree() are logged with the caller's source code file and line number (and C function name, if supported by the C compiler). In contrast, &lt;code&gt;-Dm&lt;/code&gt; is directly at the point of &lt;code&gt;malloc()&lt;/code&gt; . SV logging is similar.</source>
          <target state="translated">메모리 로깅은 &lt;code&gt;-Dm&lt;/code&gt; 과 다소 유사 하지만 &lt;code&gt;-DDEBUGGING&lt;/code&gt; 과 독립적이며 상위 레벨입니다. Newx (), Renew () 및 Safefree ()의 모든 사용은 호출자의 소스 코드 파일 및 행 번호 (및 C 컴파일러에서 지원하는 경우 C 함수 이름)와 함께 기록됩니다. 대조적으로, &lt;code&gt;-Dm&lt;/code&gt; 은 &lt;code&gt;malloc()&lt;/code&gt; 지점에 직접 있습니다 . SV 로깅은 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="4c2c814c19b69f35d9db7c2c6ebf3d08f352fd38" translate="yes" xml:space="preserve">
          <source>Memory mapped IO</source>
          <target state="translated">메모리 매핑 된 IO</target>
        </trans-unit>
        <trans-unit id="26466bc4a0a5892915da9639400d4d78c9148962" translate="yes" xml:space="preserve">
          <source>Memory obtained by this should &lt;b&gt;ONLY&lt;/b&gt; be freed with &lt;a href=&quot;#Safefree&quot;&gt;Safefree&lt;/a&gt;.</source>
          <target state="translated">이것으로 얻은 메모리 는 &lt;a href=&quot;#Safefree&quot;&gt;Safefree &lt;/a&gt;&lt;b&gt;로만&lt;/b&gt; 해제 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8b83c2b2bc6eb3815752c6b70aceb628db5830bb" translate="yes" xml:space="preserve">
          <source>Merged disk caches</source>
          <target state="translated">병합 된 디스크 캐시</target>
        </trans-unit>
        <trans-unit id="139306e2016e825bc98a4c26d30108bdfa5d60f7" translate="yes" xml:space="preserve">
          <source>Merging CPAN Meta fragments</source>
          <target state="translated">CPAN 메타 단편 병합</target>
        </trans-unit>
        <trans-unit id="e83dc47ddb09693487317e8066e16ecf7ac94e51" translate="yes" xml:space="preserve">
          <source>Message flag constants for send() and recv().</source>
          <target state="translated">send () 및 recv ()에 대한 메시지 플래그 상수.</target>
        </trans-unit>
        <trans-unit id="bc36800e17eaf7f803d98c577d91569b6c7f036b" translate="yes" xml:space="preserve">
          <source>Messing with Perl's Internals</source>
          <target state="translated">펄의 내부를 어지럽히 다</target>
        </trans-unit>
        <trans-unit id="d754d67910f4c2642d4f88945d3605a6a4025a42" translate="yes" xml:space="preserve">
          <source>Metacharacters</source>
          <target state="translated">Metacharacters</target>
        </trans-unit>
        <trans-unit id="44522bc3b457b440444e21774a3b6c8607931812" translate="yes" xml:space="preserve">
          <source>Metaphoric Quotations</source>
          <target state="translated">은유 적 인용</target>
        </trans-unit>
        <trans-unit id="8c86ca70f3e85fdec1d74a21fb3963c31fdcdd7f" translate="yes" xml:space="preserve">
          <source>Method Call Variations</source>
          <target state="translated">메서드 호출 변형</target>
        </trans-unit>
        <trans-unit id="d8949e17ae84d7a06765768cb82b20ae6019661d" translate="yes" xml:space="preserve">
          <source>Method Calls on Filehandles</source>
          <target state="translated">파일 핸들에 대한 메소드 호출</target>
        </trans-unit>
        <trans-unit id="6fd706a5558ebea104b27041341cb1ea5fac0c06" translate="yes" xml:space="preserve">
          <source>Method Invocation</source>
          <target state="translated">메소드 호출</target>
        </trans-unit>
        <trans-unit id="4f453985833ca25c15ccb8b4ce0b4ada21b9adb4" translate="yes" xml:space="preserve">
          <source>Method Names as Strings</source>
          <target state="translated">문자열로서의 메소드 명</target>
        </trans-unit>
        <trans-unit id="149bc56a4796369142e80bb8e93236ae91c74251" translate="yes" xml:space="preserve">
          <source>Method Resolution Caching</source>
          <target state="translated">분석법 캐싱</target>
        </trans-unit>
        <trans-unit id="0c84198ff44a95ef84e9c8366e0d425cc63a174e" translate="yes" xml:space="preserve">
          <source>Method Resolution Order</source>
          <target state="translated">분석법 해결 순서</target>
        </trans-unit>
        <trans-unit id="aa23ba323c11de2437b737ae399da090864345e1" translate="yes" xml:space="preserve">
          <source>Method calls</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcdf1b1bb254fccb870b04cffc381c4e506b716b" translate="yes" xml:space="preserve">
          <source>Method calls are not influenced by prototypes either, because the function to be called is indeterminate at compile time, since the exact code called depends on inheritance.</source>
          <target state="translated">호출되는 정확한 코드는 상속에 의존하기 때문에 호출 할 함수는 컴파일 타임에 결정되지 않기 때문에 메소드 호출도 프로토 타입의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8bf68fe4a9ba9d42e80a08fe93064afd994243cb" translate="yes" xml:space="preserve">
          <source>Method resolution order only matters in the case of multiple inheritance. In the case of single inheritance, Perl simply looks up the inheritance chain to find a method:</source>
          <target state="translated">메소드 해석 순서는 다중 상속의 경우에만 중요합니다. 단일 상속의 경우 Perl은 단순히 상속 체인을 찾아 메소드를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="34cec11dfde693ed2754d2e489ae4f0bbc9cc853" translate="yes" xml:space="preserve">
          <source>Method that protects Makefile single-value constants (mainly filenames), so that make will still treat them as single values even if they inconveniently have spaces in. If the make program being used cannot achieve such protection and the given text would need it, throws an exception.</source>
          <target state="translated">Makefile 단일 값 상수 (주로 파일 이름)를 보호하는 방법으로, make는 불편한 공간이 있어도이를 단일 값으로 취급합니다. 예외.</target>
        </trans-unit>
        <trans-unit id="b801c10b1ac5aa2b998ab1658d5c860e220086a7" translate="yes" xml:space="preserve">
          <source>Method to customize MakeMaker for Win9X</source>
          <target state="translated">Win9X 용 MakeMaker를 사용자 정의하는 방법</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="c9952f904ebdacb612e4e6f4d7de0226ec975738" translate="yes" xml:space="preserve">
          <source>Methods I can't really figure out where they should go yet.</source>
          <target state="translated">나는 그들이 어디로 가야하는지 실제로 알 수 없다.</target>
        </trans-unit>
        <trans-unit id="40af0f1172251b1f0d2a538bd0e00ae001b2fcaf" translate="yes" xml:space="preserve">
          <source>Methods always loaded</source>
          <target state="translated">항상로드 된 메소드</target>
        </trans-unit>
        <trans-unit id="3492e94289b56d2304db645e851cbd229618f6f3" translate="yes" xml:space="preserve">
          <source>Methods for Collation</source>
          <target state="translated">데이터 정렬 방법</target>
        </trans-unit>
        <trans-unit id="dffdf0d2cd8722a265661b1c3c208de439bb95a7" translate="yes" xml:space="preserve">
          <source>Methods for Cygwin file specs</source>
          <target state="translated">Cygwin 파일 스펙을위한 방법</target>
        </trans-unit>
        <trans-unit id="82ca12b02f71920ae1348327f9c5bc0dd81da215" translate="yes" xml:space="preserve">
          <source>Methods for Epoc file specs</source>
          <target state="translated">Epoc 파일 스펙을위한 방법</target>
        </trans-unit>
        <trans-unit id="68812b66a62e2047690bf9da1c3c46de5cc3d232" translate="yes" xml:space="preserve">
          <source>Methods for OS/2 file specs</source>
          <target state="translated">OS / 2 파일 스펙 방법</target>
        </trans-unit>
        <trans-unit id="4d421ef7bd512b00bbdb44912712ec892bca2014" translate="yes" xml:space="preserve">
          <source>Methods for Searching</source>
          <target state="translated">검색 방법</target>
        </trans-unit>
        <trans-unit id="27e99810c06b72d2d33936fc288406b84f55b203" translate="yes" xml:space="preserve">
          <source>Methods for VMS file specs</source>
          <target state="translated">VMS 파일 사양에 대한 방법</target>
        </trans-unit>
        <trans-unit id="b9b3a715e48f22629289b2063628d2443ae0ab52" translate="yes" xml:space="preserve">
          <source>Methods for Win32 file specs</source>
          <target state="translated">Win32 파일 사양 방법</target>
        </trans-unit>
        <trans-unit id="5d7bf3463f69bf3ade9275de1811133bd2e8b4a6" translate="yes" xml:space="preserve">
          <source>Methods for manipulating file specifications.</source>
          <target state="translated">파일 사양을 조작하는 방법.</target>
        </trans-unit>
        <trans-unit id="ebbba6a759fd4eaa9d94e1633b1a4e4abe7f7a45" translate="yes" xml:space="preserve">
          <source>Methods for manipulating file specifications. Other File::Spec modules, such as File::Spec::Mac, inherit from File::Spec::Unix and override specific methods.</source>
          <target state="translated">파일 사양을 조작하는 방법. File :: Spec :: Mac과 같은 다른 File :: Spec 모듈은 File :: Spec :: Unix에서 상속하고 특정 메소드를 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="7481ef085e93898eccd2d4291e104c0ca1eaac16" translate="yes" xml:space="preserve">
          <source>Methods for the adventurous</source>
          <target state="translated">모험을위한 방법</target>
        </trans-unit>
        <trans-unit id="8b4c41334b1f0849f43409490279c73ebfa5df79" translate="yes" xml:space="preserve">
          <source>Methods in Detail</source>
          <target state="translated">세부적인 방법</target>
        </trans-unit>
        <trans-unit id="e068233ba30d5c340de8033909e63f34a39f8d3e" translate="yes" xml:space="preserve">
          <source>Methods in the other Classes</source>
          <target state="translated">다른 클래스의 메소드</target>
        </trans-unit>
        <trans-unit id="6e829311e4b065fb2f2e0f38edceb6d95375c55c" translate="yes" xml:space="preserve">
          <source>Methods that you may find it handy to use, from routines of yours that you put in %Lexicon entries.</source>
          <target state="translated">% Lexicon 항목에 넣은 루틴에서 사용하기 편리한 방법.</target>
        </trans-unit>
        <trans-unit id="52c4361c86c7fd471a806b4c8215e5369dfc731b" translate="yes" xml:space="preserve">
          <source>Methods to do with constructing language handles.</source>
          <target state="translated">언어 핸들 구성과 관련된 방법입니다.</target>
        </trans-unit>
        <trans-unit id="b6f9f2fbd170ec9c9489d0e901a7e3b7214949c3" translate="yes" xml:space="preserve">
          <source>Methods to override UN*X behaviour in ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils :: MakeMaker에서 UN * X 동작을 재정의하는 방법</target>
        </trans-unit>
        <trans-unit id="ab3b6636bc321fcd9f46d8689a767ed7e52e65e7" translate="yes" xml:space="preserve">
          <source>Methods used by ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils :: MakeMaker에서 사용하는 방법</target>
        </trans-unit>
        <trans-unit id="7f996e6a1460bfdcd35f19090247cb216f784336" translate="yes" xml:space="preserve">
          <source>Methods which help initialize the MakeMaker object and macros.</source>
          <target state="translated">MakeMaker 객체 및 매크로를 초기화하는 데 도움이되는 메소드.</target>
        </trans-unit>
        <trans-unit id="3e6fda3ab5c8fa6834ff71aef9c511f877f6c23d" translate="yes" xml:space="preserve">
          <source>Methods you should implement</source>
          <target state="translated">구현해야하는 방법</target>
        </trans-unit>
        <trans-unit id="bd97b56132ac0bfc7557be46520b5fd83aff153a" translate="yes" xml:space="preserve">
          <source>Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt; and the denizens of makemaker@perl.org with code from ExtUtils::MM_Unix and ExtUtils::MM_Win32.</source>
          <target state="translated">Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;과 ExtUtils :: MM_Unix 및 ExtUtils :: MM_Win32의 코드를 사용하는 makemaker@perl.org의 이재민.</target>
        </trans-unit>
        <trans-unit id="88af124e71f22819d4d398414f274e80611dc1ac" translate="yes" xml:space="preserve">
          <source>Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt; on top of code by Nick Ing-Simmons and Jeffrey Friedl.</source>
          <target state="translated">Nick Ing-Simmons와 Jeffrey Friedl의 코드 위에 Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="609a8e114c05509c720089b4066abb697390e6b3" translate="yes" xml:space="preserve">
          <source>Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt; with code from ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils :: MM_Unix의 코드가있는 Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="976aacead2152d3736e5ca6c6514a1e5684482c5" translate="yes" xml:space="preserve">
          <source>Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt; with much inspiration from Joshua Pritikin's Test module and lots of help from Barrie Slaymaker, Tony Bowden, blackstar.co.uk, chromatic, Fergal Daly and the perl-qa gang.</source>
          <target state="translated">Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;은 Joshua Pritikin의 테스트 모듈에서 많은 영감을 얻었으며 Barrie Slaymaker, Tony Bowden, blackstar.co.uk, 반음계, Fergal Daly 및 perl-qa 갱의 많은 도움을 받았습니다.</target>
        </trans-unit>
        <trans-unit id="b7e8898e084b205078364468d25648e9b0ec170d" translate="yes" xml:space="preserve">
          <source>Michael Peters &amp;lt;mpeters at plusthree dot com&amp;gt;</source>
          <target state="translated">마이클 피터스</target>
        </trans-unit>
        <trans-unit id="3d917d6d7fad51d62d22d6b5c32840fa7d5b5e8e" translate="yes" xml:space="preserve">
          <source>Migration from &lt;code&gt;DynaLoader&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;DynaLoader&lt;/code&gt; 에서 마이그레이션</target>
        </trans-unit>
        <trans-unit id="2ceffec12b40d21f869eb5b84598130f16f111e6" translate="yes" xml:space="preserve">
          <source>Migration from DynaLoader</source>
          <target state="translated">DynaLoader에서 마이그레이션</target>
        </trans-unit>
        <trans-unit id="12654a571e20ea45eaec45ab50ad734768e09847" translate="yes" xml:space="preserve">
          <source>Mike Cariaso provided valuable insight into the best way to solve this problem.</source>
          <target state="translated">Mike Cariaso는이 문제를 해결하는 가장 좋은 방법에 대한 귀중한 통찰력을 제공했습니다.</target>
        </trans-unit>
        <trans-unit id="326f115f454ad964c4545e76abb586c5dfa4774e" translate="yes" xml:space="preserve">
          <source>Mind, that any element of the array contains a complete set of arguments for the ld command. So do not specify</source>
          <target state="translated">배열의 모든 요소에는 ld 명령에 대한 완전한 인수 세트가 포함되어 있습니다. 따라서 지정하지 마십시오</target>
        </trans-unit>
        <trans-unit id="e509f9fc49b801b1d3cb79b36c8621b4642edef8" translate="yes" xml:space="preserve">
          <source>Minimal Set of Overloaded Operations</source>
          <target state="translated">과부하 작업의 최소 세트</target>
        </trans-unit>
        <trans-unit id="447f6cc3c1201528e85c548d7378d0bbb259ea5f" translate="yes" xml:space="preserve">
          <source>Minimal code</source>
          <target state="translated">최소 코드</target>
        </trans-unit>
        <trans-unit id="b9bbc06fd8287f4f714cc43f7b852676d2d7a603" translate="yes" xml:space="preserve">
          <source>Minimal patches that fix platform-specific test failures.</source>
          <target state="translated">플랫폼 별 테스트 실패를 해결하는 최소 패치.</target>
        </trans-unit>
        <trans-unit id="9add73fb8f3d0c44a5715a5d41747422c62c935b" translate="yes" xml:space="preserve">
          <source>Minimal set of supported functions</source>
          <target state="translated">지원되는 최소 기능 세트</target>
        </trans-unit>
        <trans-unit id="390af1977edf4e133548c8556281c14e4c310537" translate="yes" xml:space="preserve">
          <source>Minimal setup (looks for</source>
          <target state="translated">최소 설정 (</target>
        </trans-unit>
        <trans-unit id="906ea91bd1c9c6378b061a822858462af43e979d" translate="yes" xml:space="preserve">
          <source>Minimum length of string (measured in bytes from &lt;code&gt;stringarg&lt;/code&gt; ) that must match; if the engine reaches the end of the match but hasn't reached this position in the string, it should fail.</source>
          <target state="translated">일치해야하는 문자열의 최소 길이 ( &lt;code&gt;stringarg&lt;/code&gt; 에서 바이트 단위로 측정 ) 엔진이 일치하는 끝에 도달했지만 문자열에서이 위치에 도달하지 않으면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="5343fd4802dbdf5cd1789ee30e8d69ca6cabadc2" translate="yes" xml:space="preserve">
          <source>Minimum of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt;, except when either is &lt;code&gt;NaN&lt;/code&gt; , returns the other [C99].</source>
          <target state="translated">&lt;code&gt;NaN&lt;/code&gt; 인 경우를 제외하고 최소 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; 는 다른 [C99]를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2a013cdfce3e9c596d4b9cb32825ab89339bddcd" translate="yes" xml:space="preserve">
          <source>Miniperl.Exe</source>
          <target state="translated">Miniperl.Exe</target>
        </trans-unit>
        <trans-unit id="0a893ece8e469a3ca3d935c49f41d08d04b75ecc" translate="yes" xml:space="preserve">
          <source>Misc</source>
          <target state="translated">Misc</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="319c19b9e813f94557eb26c26b7b4388bfdc0145" translate="yes" xml:space="preserve">
          <source>Miscellaneous Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9886ca0fdacee4b74dfbeeffc975d27efbdeb6b" translate="yes" xml:space="preserve">
          <source>Miscellaneous Modules</source>
          <target state="translated">기타 모듈</target>
        </trans-unit>
        <trans-unit id="99463edffe28d703da1b6e42d1ae7b9d31c1b070" translate="yes" xml:space="preserve">
          <source>Miscellaneous Things</source>
          <target state="translated">기타 것들</target>
        </trans-unit>
        <trans-unit id="7549a52ededf0abbc51eaa6563f958964d60ea6e" translate="yes" xml:space="preserve">
          <source>Miscellaneous Utility Functions</source>
          <target state="translated">기타 유틸리티 기능</target>
        </trans-unit>
        <trans-unit id="b1c2f1326539aaa7427ad9b1469de4ff74f87ee5" translate="yes" xml:space="preserve">
          <source>Miscellaneous commentary.</source>
          <target state="translated">기타 논평.</target>
        </trans-unit>
        <trans-unit id="314bb4fc83d55b365225efaa4fc333e95057e960" translate="yes" xml:space="preserve">
          <source>Miscellaneous functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9da774369baa717644789be36b08da5ef92ca224" translate="yes" xml:space="preserve">
          <source>Misfeatures</source>
          <target state="translated">Misfeatures</target>
        </trans-unit>
        <trans-unit id="e6560a728cc75a6b103e706dc673d7ef4bcf29de" translate="yes" xml:space="preserve">
          <source>Mixing #define and #ifdef</source>
          <target state="translated">#define과 #ifdef 혼합</target>
        </trans-unit>
        <trans-unit id="29c40186eed76e6033a40498c6fe7f4e2e466bc7" translate="yes" xml:space="preserve">
          <source>Mixing UTF-8 and non-UTF-8 strings is tricky. Use &lt;code&gt;bytes_to_utf8&lt;/code&gt; to get a new string which is UTF-8 encoded, and then combine them.</source>
          <target state="translated">UTF-8과 비 UTF-8 문자열을 혼합하는 것은 까다 롭습니다. &lt;code&gt;bytes_to_utf8&lt;/code&gt; 을 사용 하여 UTF-8로 인코딩 된 새 문자열을 가져온 다음 결합하십시오.</target>
        </trans-unit>
        <trans-unit id="66bca4e0f37fde6f6d5033a86915673ed0b48f44" translate="yes" xml:space="preserve">
          <source>Mixing command line option with other arguments</source>
          <target state="translated">명령 줄 옵션을 다른 인수와 혼합</target>
        </trans-unit>
        <trans-unit id="c85d9a78c1b4d78ca553de634935cfea419df54e" translate="yes" xml:space="preserve">
          <source>Mixing declarations and code</source>
          <target state="translated">선언과 코드 혼합</target>
        </trans-unit>
        <trans-unit id="9355f7a3087594f002f5e9c67bfdb7357b2d09c8" translate="yes" xml:space="preserve">
          <source>Mixing signed char pointers with unsigned char pointers</source>
          <target state="translated">부호있는 문자 포인터와 부호없는 문자 포인터 혼합</target>
        </trans-unit>
        <trans-unit id="c8ded3624005b356d9a738f8bbff4c65caab09bc" translate="yes" xml:space="preserve">
          <source>MkTemp family:</source>
          <target state="translated">MKTemp 제품군 :</target>
        </trans-unit>
        <trans-unit id="89e86a83d22490472fadfccc84db9971217f00e2" translate="yes" xml:space="preserve">
          <source>Mkbootstrap typically gets called from an extension Makefile.</source>
          <target state="translated">Mkbootstrap은 일반적으로 확장 Makefile에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="bf642b0445fa1b197a3f404144c575c97857e845" translate="yes" xml:space="preserve">
          <source>Mnemonic for &lt;code&gt;(?^...)&lt;/code&gt; : A fresh beginning since the usual use of a caret is to match at the beginning.</source>
          <target state="translated">니모닉 &lt;code&gt;(?^...)&lt;/code&gt; : 캐럿을 일상적으로 사용하기 때문에 처음 시작하면 처음부터 일치하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a58694480088720e80e9150ab4b17e65401d3e57" translate="yes" xml:space="preserve">
          <source>Mnemonic:</source>
          <target state="translated">Mnemonic:</target>
        </trans-unit>
        <trans-unit id="a4609f4e9d1567a8be9be3013a68cb5f9077d509" translate="yes" xml:space="preserve">
          <source>Mnemonic: / delimits line boundaries when quoting poetry.</source>
          <target state="translated">니모닉 : /시를 인용 할 때 줄 경계를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="a17c263d1e94a797a2f907b413a2e6937babe3bd" translate="yes" xml:space="preserve">
          <source>Mnemonic: &lt;code&gt;%&lt;/code&gt; is page number in &lt;b&gt;nroff&lt;/b&gt;.</source>
          <target state="translated">니모닉 : &lt;code&gt;%&lt;/code&gt; 는 &lt;b&gt;nroff의&lt;/b&gt; 페이지 번호입니다 .</target>
        </trans-unit>
        <trans-unit id="ff8f7e9ef271156c4cf38cda15862d7d90c4cb37" translate="yes" xml:space="preserve">
          <source>Mnemonic: &lt;code&gt;'&lt;/code&gt; often follows a quoted string.</source>
          <target state="translated">니모닉 : &lt;code&gt;'&lt;/code&gt; 는 종종 인용 된 문자열을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="03462936fc4d222008baee163c91bca679bcf610" translate="yes" xml:space="preserve">
          <source>Mnemonic: &lt;code&gt;`&lt;/code&gt; often precedes a quoted string.</source>
          <target state="translated">니모닉 : &lt;code&gt;`&lt;/code&gt; 는 종종 따옴표 붙은 문자열 앞에옵니다.</target>
        </trans-unit>
        <trans-unit id="6d89fd4acfd6e65581a03c1bccc5077a0683b53d" translate="yes" xml:space="preserve">
          <source>Mnemonic: = has horizontal lines.</source>
          <target state="translated">니모닉 : = 수평선이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4fee04f913df1ce7e585c0d4cb5cf688bad64b1" translate="yes" xml:space="preserve">
          <source>Mnemonic: Complement of</source>
          <target state="translated">니모닉 : 보완</target>
        </trans-unit>
        <trans-unit id="00d81532eead6e059ec9226bf31a1d7bc4d3c648" translate="yes" xml:space="preserve">
          <source>Mnemonic: Extra error explanation.</source>
          <target state="translated">니모닉 : 추가 오류 설명.</target>
        </trans-unit>
        <trans-unit id="f3adb972eb89279dcbf38ffdb2b34cb01ac80557" translate="yes" xml:space="preserve">
          <source>Mnemonic: Is this version of perl in the right bracket?</source>
          <target state="translated">니모닉 :이 버전의 펄은 오른쪽 괄호 안에 있습니까?</target>
        </trans-unit>
        <trans-unit id="c83fc5eabe67c53a88a66531db063afe5a8798fe" translate="yes" xml:space="preserve">
          <source>Mnemonic: Perl's (original) space</source>
          <target state="translated">니모닉 : Perl (원래) 공간</target>
        </trans-unit>
        <trans-unit id="de5973eb3bd2f2951a919587c5a581d934fb917e" translate="yes" xml:space="preserve">
          <source>Mnemonic: Perl's (original) word.</source>
          <target state="translated">니모닉 : Perl (원래) 단어.</target>
        </trans-unit>
        <trans-unit id="e3688e90b8ece4a626d04ff3f6b6b3e5cd816fdf" translate="yes" xml:space="preserve">
          <source>Mnemonic: Space, as modified by Perl. (It doesn't include the vertical tab until v5.18, which both the Posix standard and Unicode consider white space.)</source>
          <target state="translated">니모닉 : Perl에 의해 수정 된 공간. (Posix 표준과 유니 코드 모두 공백을 고려하는 v5.18까지 수직 탭은 포함되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="e034d1e8207da0718183c9081637de75a93ba2ae" translate="yes" xml:space="preserve">
          <source>Mnemonic: What just went bang?</source>
          <target state="translated">니모닉 : 방금 무슨 일이 있었나요?</target>
        </trans-unit>
        <trans-unit id="c2d59c20bf5fe5e92f4fce8a028d68d9472173f0" translate="yes" xml:space="preserve">
          <source>Mnemonic: Where was the syntax error &quot;at&quot;?</source>
          <target state="translated">니모닉 : &quot;at&quot;구문 오류는 어디에 있었습니까?</target>
        </trans-unit>
        <trans-unit id="13036ce2395db627a394493e09b57d820655a6e3" translate="yes" xml:space="preserve">
          <source>Mnemonic: [ begins subscripts.</source>
          <target state="translated">니모닉 : [아래 첨자를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="6478e17d9b14a75686fa2aeaa0fda7fc477e3a6c" translate="yes" xml:space="preserve">
          <source>Mnemonic: a &quot;colon&quot; in poetry is a part of a line.</source>
          <target state="translated">니모닉 :시의 &quot;콜론&quot;은 한 줄의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="06be15525bc8ff40fc0fd75c1aede3dd3e6eca7f" translate="yes" xml:space="preserve">
          <source>Mnemonic: be positive and forward looking.</source>
          <target state="translated">니모닉 : 긍정적이고 미래 지향적이어야합니다.</target>
        </trans-unit>
        <trans-unit id="45c1dcc3d237500077fd6705954bc10a0da68241" translate="yes" xml:space="preserve">
          <source>Mnemonic: brother to &lt;code&gt;$^&lt;/code&gt; .</source>
          <target state="translated">니모닉 : &lt;code&gt;$^&lt;/code&gt; 형제 .</target>
        </trans-unit>
        <trans-unit id="8bfbe3b8dd831a42303599b72a7a29a0dbbce16e" translate="yes" xml:space="preserve">
          <source>Mnemonic: comma (the syntactic subscript separator) is a semi-semicolon.</source>
          <target state="translated">니모닉 : 쉼표 (구문 아래 첨자 구분자)는 세미-세미콜론입니다.</target>
        </trans-unit>
        <trans-unit id="a5e54620ad7fc3dd7f83e5824baaa97ef210abf7" translate="yes" xml:space="preserve">
          <source>Mnemonic: e</source>
          <target state="translated">니모닉 : e</target>
        </trans-unit>
        <trans-unit id="fb1dad35694a1d1c6e8b249b4963e948af75d628" translate="yes" xml:space="preserve">
          <source>Mnemonic: he</source>
          <target state="translated">니모닉 : 그는</target>
        </trans-unit>
        <trans-unit id="4f25fdfd275a765786269fb643e1c55e1a9c1820" translate="yes" xml:space="preserve">
          <source>Mnemonic: it's the uid you came</source>
          <target state="translated">니모닉 : 그것은 당신이 온 uid입니다</target>
        </trans-unit>
        <trans-unit id="f53200593eb86ae8dd4c325941dd8eb32bcbba07" translate="yes" xml:space="preserve">
          <source>Mnemonic: it's the uid you went</source>
          <target state="translated">니모닉 : 네가 간 uid</target>
        </trans-unit>
        <trans-unit id="c2560fee0f5b656addb6e58657f827dd080975cc" translate="yes" xml:space="preserve">
          <source>Mnemonic: like &lt;code&gt;&amp;amp;&lt;/code&gt; in some editors.</source>
          <target state="translated">니모닉 : 일부 편집기에서 &lt;code&gt;&amp;amp;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0bf53d6e2ef8b1852f6e6460d639d8a6d511e87d" translate="yes" xml:space="preserve">
          <source>Mnemonic: like \digits.</source>
          <target state="translated">니모닉 : 같은 \ digits.</target>
        </trans-unit>
        <trans-unit id="29345f5f1506a434b700483b03581bba2252ef83" translate="yes" xml:space="preserve">
          <source>Mnemonic: lines_on_page - lines_printed.</source>
          <target state="translated">니모닉 : lines_on_page-lines_printed.</target>
        </trans-unit>
        <trans-unit id="a3b3edfce1b2a7630b3d4258477c440ecb3338e9" translate="yes" xml:space="preserve">
          <source>Mnemonic: many programs use &quot;.&quot; to mean the current line number.</source>
          <target state="translated">니모닉 : 많은 프로그램에서 &quot;.&quot; 현재 줄 번호를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="de8f32b4ce704e3d490515551c6116db336ffdaf" translate="yes" xml:space="preserve">
          <source>Mnemonic: none really. &lt;code&gt;\R&lt;/code&gt; was picked because PCRE already uses &lt;code&gt;\R&lt;/code&gt; , and more importantly because Unicode recommends such a regular expression metacharacter, and suggests &lt;code&gt;\R&lt;/code&gt; as its notation.</source>
          <target state="translated">니모닉 : 실제로는 없습니다. &lt;code&gt;\R&lt;/code&gt; RE는 PCRE가 이미 &lt;code&gt;\R&lt;/code&gt; 사용하기 때문에 선택되었으며 , 더 중요한 것은 유니 코드가 정규 표현식 메타 문자를 권장하고 &lt;code&gt;\R&lt;/code&gt; 을 표기법으로 제안하기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="17515742cc5afa87aeabc73678286fa741ba5388" translate="yes" xml:space="preserve">
          <source>Mnemonic: o</source>
          <target state="translated">니모닉 : o</target>
        </trans-unit>
        <trans-unit id="5c7eacbc6cb333f80ee9f35aec3e8dd35063c97b" translate="yes" xml:space="preserve">
          <source>Mnemonic: parentheses are used to</source>
          <target state="translated">니모닉 : 괄호는</target>
        </trans-unit>
        <trans-unit id="145851845d42b7c2837eb05551e2eb9b2cae8660" translate="yes" xml:space="preserve">
          <source>Mnemonic: points to top of page.</source>
          <target state="translated">니모닉 : 페이지 상단을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="18d03cec8eedf712bc3cc92498d0bd974ac29168" translate="yes" xml:space="preserve">
          <source>Mnemonic: related to the &lt;b&gt;-w&lt;/b&gt; switch.</source>
          <target state="translated">니모닉 : &lt;b&gt;-w&lt;/b&gt; 스위치 와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ff59e0f3c29d42ff6b4f1943a0cb62f85b10dbe" translate="yes" xml:space="preserve">
          <source>Mnemonic: same as &lt;b&gt;sh&lt;/b&gt; and &lt;b&gt;ksh&lt;/b&gt;.</source>
          <target state="translated">니모닉 : 동일 &lt;b&gt;쉬&lt;/b&gt; 와 &lt;b&gt;KSH&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="3b46ac9389c1562addebeca3277c06599213ca1b" translate="yes" xml:space="preserve">
          <source>Mnemonic: same as shells.</source>
          <target state="translated">니모닉 : 껍질과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="9c5494af227b04c5edebf85d05b3fe69b8e73df2" translate="yes" xml:space="preserve">
          <source>Mnemonic: similar to &lt;b&gt;sh&lt;/b&gt; and &lt;b&gt;ksh&lt;/b&gt;.</source>
          <target state="translated">니모닉 : &lt;b&gt;sh&lt;/b&gt; 및 &lt;b&gt;ksh&lt;/b&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="894f0484590bcbb3b693d6aab805d5dfd400684a" translate="yes" xml:space="preserve">
          <source>Mnemonic: the (possibly) Nested parenthesis that most recently closed.</source>
          <target state="translated">니모닉 : 가장 최근에 닫은 중첩 괄호.</target>
        </trans-unit>
        <trans-unit id="2bc5f6f15e84df55129e74766d50c6d3ec861d52" translate="yes" xml:space="preserve">
          <source>Mnemonic: underline is understood in certain operations.</source>
          <target state="translated">니모닉 : 밑줄은 특정 작업에서 이해됩니다.</target>
        </trans-unit>
        <trans-unit id="4a9ec9ee0bfa06bee48fc042c23120f429cc4720" translate="yes" xml:space="preserve">
          <source>Mnemonic: use ^V for a version object.</source>
          <target state="translated">니모닉 : 버전 객체에 ^ V를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="06e3f9eef28e584212eb3b651afb663309c25b17" translate="yes" xml:space="preserve">
          <source>Mnemonic: value of &lt;b&gt;-D&lt;/b&gt; switch.</source>
          <target state="translated">니모닉 : &lt;b&gt;-D&lt;/b&gt; 스위치의 값 .</target>
        </trans-unit>
        <trans-unit id="8b8a29220f27a6ded73512e3ded3085fc6e23796" translate="yes" xml:space="preserve">
          <source>Mnemonic: value of &lt;b&gt;-i&lt;/b&gt; switch.</source>
          <target state="translated">니모닉 : &lt;b&gt;-i&lt;/b&gt; 스위치의 값 .</target>
        </trans-unit>
        <trans-unit id="d86dda32bcccc36b30321a061a593c0839054c6b" translate="yes" xml:space="preserve">
          <source>Mnemonic: what is printed when there is a &quot;,&quot; in your print statement.</source>
          <target state="translated">니모닉 : 인쇄 명세서에 &quot;,&quot;가있을 때 인쇄되는 내용.</target>
        </trans-unit>
        <trans-unit id="a2e0668e848f30f9c617ffa35513e900bc8c74ef" translate="yes" xml:space="preserve">
          <source>Mnemonic: when you want your pipes to be piping hot.</source>
          <target state="translated">니모닉 : 파이프가 뜨거워 지길 원할 때.</target>
        </trans-unit>
        <trans-unit id="83f42ef2607c96d6744ccfc26dd35c90a66a4662" translate="yes" xml:space="preserve">
          <source>Mnemonic: works in double-quoted context.</source>
          <target state="translated">니모닉 : 큰 따옴표로 묶은 문맥에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c5df1d9e3c7f07b6813c1d51005b98006207f133" translate="yes" xml:space="preserve">
          <source>Mnemonic: you set &lt;code&gt;$\&lt;/code&gt; instead of adding &quot;\n&quot; at the end of the print. Also, it's just like &lt;code&gt;$/&lt;/code&gt; , but it's what you get &quot;back&quot; from Perl.</source>
          <target state="translated">니모닉 : 인쇄 끝에 &quot;\ n&quot;을 추가하는 대신 &lt;code&gt;$\&lt;/code&gt; 를 설정 합니다. 또한 &lt;code&gt;$/&lt;/code&gt; 와 비슷하지만 Perl에서 &quot;돌아 오는&quot;것입니다.</target>
        </trans-unit>
        <trans-unit id="774459fcd854849578678b44d17052997274c5ac" translate="yes" xml:space="preserve">
          <source>Mnemonics:</source>
          <target state="translated">Mnemonics:</target>
        </trans-unit>
        <trans-unit id="bfe5ea1c0f4c46a2237b24e5b3f2887e00aa6466" translate="yes" xml:space="preserve">
          <source>Modification of a read-only value attempted</source>
          <target state="translated">읽기 전용 값 수정 시도</target>
        </trans-unit>
        <trans-unit id="54e708f372bd6f49e75185b1eedbc1c5b10e7365" translate="yes" xml:space="preserve">
          <source>Modification time. Adjusted to mac-time on MacOS if required</source>
          <target state="translated">수정 시간. 필요한 경우 MacOS에서 mac-time으로 조정</target>
        </trans-unit>
        <trans-unit id="405f45092d843a1d3838d8a5b8852228db0dfbb7" translate="yes" xml:space="preserve">
          <source>Modifications</source>
          <target state="translated">Modifications</target>
        </trans-unit>
        <trans-unit id="d15d3e35d08a4f905aca29a53f32a6a9324f7e00" translate="yes" xml:space="preserve">
          <source>Modified - 13 July 2001</source>
          <target state="translated">수정 됨-2001 년 7 월 13 일</target>
        </trans-unit>
        <trans-unit id="c28e2457b8697ed01bbb5ecba237019fd1dcb3c9" translate="yes" xml:space="preserve">
          <source>Modified - 25 June 2001</source>
          <target state="translated">수정 됨-2001 년 6 월 25 일</target>
        </trans-unit>
        <trans-unit id="d8e50120460706cd8f55da079850b9b27d5d7356" translate="yes" xml:space="preserve">
          <source>Modified - 28 May 2002</source>
          <target state="translated">수정-2002 년 5 월 28 일</target>
        </trans-unit>
        <trans-unit id="32979a38ecc2f0753d6d680873cd17c8a6ba6155" translate="yes" xml:space="preserve">
          <source>Modified by Casey West, 2000-11-08, v0.59.</source>
          <target state="translated">Casey West, 2000-11-08, v0.59에 의해 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="e5f3cf35626877ebe81f40ef6a55ba3d9279e043" translate="yes" xml:space="preserve">
          <source>Modified by Damian Conway, 1999-03-05, v0.58.</source>
          <target state="translated">Damian Conway, 1999-03-05, v0.58에 의해 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="94d5fe9080184121ea2c9a038a3632538b976fe0" translate="yes" xml:space="preserve">
          <source>Modified by Damian Conway, 2001-09-10, v0.62.</source>
          <target state="translated">Damian Conway, 2001-09-10, v0.62에 의해 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="9877a0e2ec14746d54f44a96609db5de1a2c19ac" translate="yes" xml:space="preserve">
          <source>Modified in Perl 5.10.1, 5.12.0</source>
          <target state="translated">Perl 5.10.1, 5.12.0에서 수정 됨</target>
        </trans-unit>
        <trans-unit id="3a7ea294bf33134dce4b142b8b7182de29b978b2" translate="yes" xml:space="preserve">
          <source>Modifiers</source>
          <target state="translated">Modifiers</target>
        </trans-unit>
        <trans-unit id="e880a783bbd37d3dea3114db13bc60aa06662623" translate="yes" xml:space="preserve">
          <source>Modifies and queries the program's underlying locale. Users of this function should read &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;, whch provides a comprehensive discussion of Perl locale handling, knowledge of which is necessary to properly use this function. It contains &lt;a href=&quot;perllocale#The-setlocale-function&quot;&gt;a section devoted to this function&lt;/a&gt;. The discussion here is merely a summary reference for &lt;code&gt;setlocale()&lt;/code&gt; . Note that Perl itself is almost entirely unaffected by the locale except within the scope of &lt;code&gt;&quot;use locale&quot;&lt;/code&gt; . (Exceptions are listed in &lt;a href=&quot;perllocale#Not-within-the-scope-of-%22use-locale%22&quot;&gt;Not within the scope of use locale in perllocale&lt;/a&gt;.)</source>
          <target state="translated">프로그램의 기본 로캘을 수정하고 쿼리합니다. 이 함수의 사용자는 &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; 을 읽어야 하며, whch는 Perl 로케일 처리에 대한 포괄적 인 토론을 제공 하며이 함수 를 올바르게 사용하려면 지식이 필요합니다. 여기에는 &lt;a href=&quot;perllocale#The-setlocale-function&quot;&gt;이 기능에 관한 섹션&lt;/a&gt; 이 포함되어 있습니다 . 여기서 논의는 &lt;code&gt;setlocale()&lt;/code&gt; 대한 요약 참조 일뿐 입니다. Perl 자체는 &lt;code&gt;&quot;use locale&quot;&lt;/code&gt; 범위를 제외하고는 로케일의 영향을 거의받지 않습니다 . &lt;a href=&quot;perllocale#Not-within-the-scope-of-%22use-locale%22&quot;&gt;perllocale의 사용 범위 내에 있지 않음에&lt;/a&gt; 예외가 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9b51ea52a3a827c7ad9340f3c3175b008c79459" translate="yes" xml:space="preserve">
          <source>Modifies the list of places temp directory information is looked for.</source>
          <target state="translated">임시 디렉토리 정보를 찾은 장소 목록을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="b2d78ea62126eeb6ac9e086c6864dab2d0e3c3a1" translate="yes" xml:space="preserve">
          <source>Module Installation</source>
          <target state="translated">모듈 설치</target>
        </trans-unit>
        <trans-unit id="5e8ed13e4781f62782d5aa23493e665d1640aba0" translate="yes" xml:space="preserve">
          <source>Module Meta-Data (META and MYMETA)</source>
          <target state="translated">모듈 메타 데이터 (META 및 MYMETA)</target>
        </trans-unit>
        <trans-unit id="1454ab039736e265b3314e2865bba939a5971c09" translate="yes" xml:space="preserve">
          <source>Module Version Checking</source>
          <target state="translated">모듈 버전 확인</target>
        </trans-unit>
        <trans-unit id="d108ead0085bbd00f6a4bbc9931939d7eccf7683" translate="yes" xml:space="preserve">
          <source>Module Writing</source>
          <target state="translated">모듈 작성</target>
        </trans-unit>
        <trans-unit id="516af6a787a862724252123e2bd3b762619e9ffe" translate="yes" xml:space="preserve">
          <source>Module authors should carefully consider whether to rely on other modules, and which modules to rely on.</source>
          <target state="translated">모듈 작성자는 다른 모듈에 의존할지 여부와 의존 할 모듈을 신중하게 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="8471831f64e1887291d945952d1e1daa28722f62" translate="yes" xml:space="preserve">
          <source>Module for manipulations of tar archives</source>
          <target state="translated">tar 아카이브 조작을위한 모듈</target>
        </trans-unit>
        <trans-unit id="e65640d58920cc799b38907083a95415ef4b8a66" translate="yes" xml:space="preserve">
          <source>Module installation tools have ways of resolving unmet dependencies but to do that they need a</source>
          <target state="translated">모듈 설치 도구에는 충족되지 않은 종속성을 해결하는 방법이 있지만이를 수행하려면</target>
        </trans-unit>
        <trans-unit id="8b521a1c525dc29431bbdbd97b08d7337321f5f4" translate="yes" xml:space="preserve">
          <source>Module tests</source>
          <target state="translated">모듈 테스트</target>
        </trans-unit>
        <trans-unit id="09c1308ed6b0c63e3397790cc4f67693af0f82c7" translate="yes" xml:space="preserve">
          <source>Module to convert pod files to HTML</source>
          <target state="translated">포드 파일을 HTML로 변환하는 모듈</target>
        </trans-unit>
        <trans-unit id="15ecde6b9e55280e32d99a40c501f4e2e8c2ff44" translate="yes" xml:space="preserve">
          <source>Module to test the XS typemaps distributed with perl</source>
          <target state="translated">perl과 함께 배포 된 XS 유형 맵을 테스트하는 모듈</target>
        </trans-unit>
        <trans-unit id="b97c2d8aa7bcb68996cb4a6d31701bee24ce1615" translate="yes" xml:space="preserve">
          <source>Module use may give one of the following errors during import.</source>
          <target state="translated">가져 오기 중에 모듈을 사용하면 다음 오류 중 하나가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3674e804d761cb13678499f67d99449dc4f27a48" translate="yes" xml:space="preserve">
          <source>Module.pm</source>
          <target state="translated">Module.pm</target>
        </trans-unit>
        <trans-unit id="ab9ab41c22948665a29f42a31b28aeddb3d8a91e" translate="yes" xml:space="preserve">
          <source>Module.pod</source>
          <target state="translated">Module.pod</target>
        </trans-unit>
        <trans-unit id="ae8d8ff480dfbba731116e004a9d3f57c4bd6cdb" translate="yes" xml:space="preserve">
          <source>Module::Build</source>
          <target state="translated">Module::Build</target>
        </trans-unit>
        <trans-unit id="62fb86405abcf275344b08fc9af2288d90dc6412" translate="yes" xml:space="preserve">
          <source>Module::Build 0.28 added support for &lt;code&gt;--prefix&lt;/code&gt; which works like MakeMaker's PREFIX.</source>
          <target state="translated">Module :: Build 0.28에는 MakeMaker의 PREFIX처럼 작동 하는 &lt;code&gt;--prefix&lt;/code&gt; 에 대한 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="91d488d471a8bc496d78b2b13e521d55c3f0cdef" translate="yes" xml:space="preserve">
          <source>Module::Build is a project by Ken Williams to supplant MakeMaker. Its primary advantages are:</source>
          <target state="translated">Module :: Build는 MakeMaker를 대체하기위한 Ken Williams의 프로젝트입니다. 주요 장점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6b1f0f8f3e8bc54c1732e312db2a7505d466061a" translate="yes" xml:space="preserve">
          <source>Module::Build was long the official heir apparent to MakeMaker. The rate of both its development and adoption has slowed in recent years, though, and it is unclear what the future holds for it. That said, Module::Build set the stage for</source>
          <target state="translated">Module :: Build는 오랫동안 MakeMaker의 공식 상속인이었습니다. 그러나 최근 몇 년 동안 개발 및 채택 속도가 느려졌으며 미래가 무엇을 유지할지 불분명합니다. 즉, Module :: Build는</target>
        </trans-unit>
        <trans-unit id="8def62b03ff3b40aeadb216948bd496a8840b87f" translate="yes" xml:space="preserve">
          <source>Module::Build, as of 0.28, supports two ways to install to the same location as MakeMaker.</source>
          <target state="translated">Module :: Build는 0.28부터 MakeMaker와 같은 위치에 설치하는 두 가지 방법을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="a1edaf280214fd94706296d20c3b0f2bfdf9eb59" translate="yes" xml:space="preserve">
          <source>Module::CoreList</source>
          <target state="translated">Module::CoreList</target>
        </trans-unit>
        <trans-unit id="c1eab53f65667256b290f34243d94d7ecdff687e" translate="yes" xml:space="preserve">
          <source>Module::CoreList - what modules shipped with versions of perl</source>
          <target state="translated">Module :: CoreList-Perl 버전과 함께 제공된 모듈</target>
        </trans-unit>
        <trans-unit id="cf24a0df2a2fe48d90f4a8337763728341cb900f" translate="yes" xml:space="preserve">
          <source>Module::CoreList currently covers the 5.000, 5.001, 5.002, 5.003_07, 5.004, 5.004_05, 5.005, 5.005_03, 5.005_04 and 5.7.3 releases of perl.</source>
          <target state="translated">Module :: CoreList는 현재 5.000, 5.001, 5.002, 5.003_07, 5.004, 5.004_05, 5.005, 5.005_03, 5.005_04 및 5.7.3 릴리스의 perl을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="b23a69ee7bbcaf5f395d8275dba4f3efac0eee37" translate="yes" xml:space="preserve">
          <source>Module::CoreList provides information on which core and dual-life modules shipped with each version of &lt;a href=&quot;../perl&quot;&gt;perl&lt;/a&gt;.</source>
          <target state="translated">Module :: CoreList는 각 버전의 &lt;a href=&quot;../perl&quot;&gt;perl&lt;/a&gt; 과 함께 제공되는 코어 및 이중 수명 모듈에 대한 정보를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="79bce9e07f8b204000334e6031e7ea0b0960701f" translate="yes" xml:space="preserve">
          <source>Module::Load</source>
          <target state="translated">Module::Load</target>
        </trans-unit>
        <trans-unit id="e3d85e08676b05b2e538b0685147bf01f13faa38" translate="yes" xml:space="preserve">
          <source>Module::Load - runtime require of both modules and files</source>
          <target state="translated">Module :: Load-모듈과 파일 모두의 런타임 요구</target>
        </trans-unit>
        <trans-unit id="6e16ca7f251db467f65f169ccb90bd1775b9be31" translate="yes" xml:space="preserve">
          <source>Module::Load::Conditional</source>
          <target state="translated">Module::Load::Conditional</target>
        </trans-unit>
        <trans-unit id="0333daac2dc5711d6aa41b0b76a07a8abee4d3b5" translate="yes" xml:space="preserve">
          <source>Module::Load::Conditional - Looking up module information / loading at runtime</source>
          <target state="translated">Module :: Load :: Conditional-런타임에 모듈 정보 조회 /로드</target>
        </trans-unit>
        <trans-unit id="c96b8d051cb4352b076673e1abc0268f29fa107f" translate="yes" xml:space="preserve">
          <source>Module::Load::Conditional provides simple ways to query and possibly load any of the modules you have installed on your system during runtime.</source>
          <target state="translated">Module :: Load :: Conditional은 런타임 중에 시스템에 설치 한 모듈을 쿼리하고로드하는 간단한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fffd2566f2af4b448df67c2c105f5e1f1b680583" translate="yes" xml:space="preserve">
          <source>Module::Loaded</source>
          <target state="translated">Module::Loaded</target>
        </trans-unit>
        <trans-unit id="ce11901e21f211fb61728e8347b6913869d01fec" translate="yes" xml:space="preserve">
          <source>Module::Loaded - mark modules as loaded or unloaded</source>
          <target state="translated">Module :: Loaded-모듈을로드 또는 언로드로 표시</target>
        </trans-unit>
        <trans-unit id="02e77c62a7e1cc7db95a64ce9a1c2d0f806647c6" translate="yes" xml:space="preserve">
          <source>Module::bootstrap()</source>
          <target state="translated">Module::bootstrap()</target>
        </trans-unit>
        <trans-unit id="801dc9760f104617b6ed8b09b3bc552754857caf" translate="yes" xml:space="preserve">
          <source>Modules Used</source>
          <target state="translated">사용 된 모듈</target>
        </trans-unit>
        <trans-unit id="ba45166087559a8d4da3018515bba6d0e5511862" translate="yes" xml:space="preserve">
          <source>Modules and Extensions for Perl on OS/390</source>
          <target state="translated">OS / 390의 Perl 용 모듈 및 확장</target>
        </trans-unit>
        <trans-unit id="cfe4151bcba7eda23509b603930bf7ee0bf81221" translate="yes" xml:space="preserve">
          <source>Modules are installed on a case-by-case basis (as provided by the methods described in the previous section), and in the operating system. All of these paths are stored in @INC, which you can display with the one-liner</source>
          <target state="translated">모듈은 사례별로 (이전 섹션에서 설명한 방법으로 제공) 운영 체제에 설치됩니다. 이 모든 경로는 @INC에 저장되며, 하나의 라이너로 표시 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="2c98c46b9ec45777efe9604a1088b3e507328331" translate="yes" xml:space="preserve">
          <source>Modules in the</source>
          <target state="translated">의 모듈</target>
        </trans-unit>
        <trans-unit id="387c58c36e26384b5c37e68bd7e39af265275a1f" translate="yes" xml:space="preserve">
          <source>Modules know their associated Distribution objects. They always refer to the most recent official release. Developers may mark their releases as unstable development versions (by inserting an underscore into the module version number which will also be reflected in the distribution name when you run 'make dist'), so the really hottest and newest distribution is not always the default. If a module Foo circulates on CPAN in both version 1.23 and 1.23_90, CPAN.pm offers a convenient way to install version 1.23 by saying</source>
          <target state="translated">모듈은 관련된 배포 객체를 알고 있습니다. 항상 최신 공식 릴리스를 참조합니다. 개발자는 릴리스를 불안정한 개발 버전으로 표시 할 수 있습니다 ( 'make dist'를 실행할 때 배포 이름에 밑줄을 추가하여 모듈 버전 번호에 밑줄을 삽입하여). 가장 인기있는 최신 배포가 항상 기본값이 아닙니다. 모듈 Foo가 버전 1.23 및 1.23_90에서 CPAN을 순환하는 경우 CPAN.pm은 다음과 같이 말하여 버전 1.23을 설치하는 편리한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5f3d6f058f458ef7f23d8ca7c1fa07e5fdffa37c" translate="yes" xml:space="preserve">
          <source>Modules not available from CPAN</source>
          <target state="translated">CPAN에서 사용할 수없는 모듈</target>
        </trans-unit>
        <trans-unit id="8de09ade33dff4d30d378d32e3f399e05899232c" translate="yes" xml:space="preserve">
          <source>Modules shipped as part of the Perl core live in four subdirectories. Two of these directories contain modules that live in the core, and two contain modules that can also be released separately on CPAN. Modules which can be released on cpan are known as &quot;dual-life&quot; modules.</source>
          <target state="translated">Perl 코어의 일부로 제공되는 모듈은 4 개의 하위 디렉토리에 있습니다. 이 디렉토리 중 2 개에는 코어에있는 모듈이 있고 2 개에는 CPAN에서 별도로 릴리스 할 수있는 모듈이 있습니다. cpan에서 해제 할 수있는 모듈을 &quot;이중 수명&quot;모듈이라고합니다.</target>
        </trans-unit>
        <trans-unit id="e0e8aed9f80a1dc002e318b7643af4d7677ed672" translate="yes" xml:space="preserve">
          <source>Modules should be packaged using one of the standard packaging tools. Currently you have the choice between ExtUtils::MakeMaker and the more platform independent Module::Build, allowing modules to be installed in a consistent manner. When using ExtUtils::MakeMaker, you can use &quot;make dist&quot; to create your package. Tools exist to help you to build your module in a MakeMaker-friendly style. These include ExtUtils::ModuleMaker and h2xs. See also &lt;a href=&quot;perlnewmod&quot;&gt;perlnewmod&lt;/a&gt;.</source>
          <target state="translated">모듈은 표준 패키징 도구 중 하나를 사용하여 패키징해야합니다. 현재 ExtUtils :: MakeMaker와 플랫폼 독립적 인 Module :: Build 중에서 선택하여 모듈을 일관된 방식으로 설치할 수 있습니다. ExtUtils :: MakeMaker를 사용할 때 &quot;make dist&quot;를 사용하여 패키지를 만들 수 있습니다. MakeMaker 친화적 인 스타일로 모듈을 빌드하는 데 도움이되는 도구가 있습니다. 여기에는 ExtUtils :: ModuleMaker 및 h2xs가 포함됩니다. &lt;a href=&quot;perlnewmod&quot;&gt;perlnewmod&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eba7daa98709598366c3537d2ec9862d20e4985a" translate="yes" xml:space="preserve">
          <source>Modules such as &lt;a href=&quot;http://search.cpan.org/perldoc/Path::Tiny&quot;&gt;Path::Tiny&lt;/a&gt; and &lt;a href=&quot;tie/file&quot;&gt;Tie::File&lt;/a&gt; can help with that too. If you can, however, avoid reading the entire file at once. Perl won't give that memory back to the operating system until the process finishes.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Path::Tiny&quot;&gt;Path :: Tiny&lt;/a&gt; 및 &lt;a href=&quot;tie/file&quot;&gt;Tie :: File&lt;/a&gt; 과 같은 모듈 도 도움이 될 수 있습니다. 그러나 가능하면 전체 파일을 한 번에 읽지 마십시오. Perl은 프로세스가 완료 될 때까지 해당 메모리를 운영 체제에 다시 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e39293c10b487ab181c13d36712d552c93decf5" translate="yes" xml:space="preserve">
          <source>Modules that calculate message digests</source>
          <target state="translated">메시지 요약을 계산하는 모듈</target>
        </trans-unit>
        <trans-unit id="7e640dc8698a54c30ce2b25e1b3caa6b2de29019" translate="yes" xml:space="preserve">
          <source>Modules uploaded to CPAN are tested by a variety of volunteers on different platforms. These CPAN testers are notified by mail of each new upload, and reply to the list with PASS, FAIL, NA (not applicable to this platform), or UNKNOWN (unknown), along with any relevant notations.</source>
          <target state="translated">CPAN에 업로드 된 모듈은 다양한 플랫폼에서 다양한 자원 봉사자가 테스트합니다. 이 CPAN 테스터는 각각의 새로운 업로드에 대해 우편으로 통지하고 관련 표기법과 함께 PASS, FAIL, NA (이 플랫폼에는 해당되지 않음) 또는 UNKNOWN (알 수 없음)으로 목록에 회신합니다.</target>
        </trans-unit>
        <trans-unit id="9c1cf1fbeb1d4ad27fd965e462b1a6f05eea74e9" translate="yes" xml:space="preserve">
          <source>Modules which are &quot;stable&quot; should not break backwards compatibility without at least a long transition phase and a major change in version number.</source>
          <target state="translated">&quot;안정된&quot;모듈은 최소한 긴 전환 단계와 버전 번호의 주요 변경없이 하위 호환성을 손상시키지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="d737814ec2d252aed0d9553090a83af593402cf6" translate="yes" xml:space="preserve">
          <source>Modules: Creation, Use, and Abuse</source>
          <target state="translated">모듈 : 생성, 사용 및 남용</target>
        </trans-unit>
        <trans-unit id="1946c31aeef030db495b0e13ad1403e9cb0aa7a2" translate="yes" xml:space="preserve">
          <source>Moo</source>
          <target state="translated">Moo</target>
        </trans-unit>
        <trans-unit id="9fdbf7859aefc5d1a01b970f830cbc34f4ef18a9" translate="yes" xml:space="preserve">
          <source>Moose</source>
          <target state="translated">Moose</target>
        </trans-unit>
        <trans-unit id="82e29b39da9785f5a818efe5d3fe3de6e587d533" translate="yes" xml:space="preserve">
          <source>More Problems</source>
          <target state="translated">더 많은 문제</target>
        </trans-unit>
        <trans-unit id="53057b4dfd56a329af03f74d8aab9d36470ceecf" translate="yes" xml:space="preserve">
          <source>More about XSUB arguments</source>
          <target state="translated">XSUB 인수에 대한 추가 정보</target>
        </trans-unit>
        <trans-unit id="108f2973ee0fc68f8bd1c87f7945bdef10ce9b19" translate="yes" xml:space="preserve">
          <source>More advanced specifications for parallel vs sequence run rules</source>
          <target state="translated">병렬 및 시퀀스 실행 규칙에 대한 고급 사양</target>
        </trans-unit>
        <trans-unit id="13a55c80ed5c83f1c889c62320fc4a034a2333c3" translate="yes" xml:space="preserve">
          <source>More complex cases will require to write a parser, probably using a parsing module from CPAN, like &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Grammars&quot;&gt;Regexp::Grammars&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Parse::RecDescent&quot;&gt;Parse::RecDescent&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Parse::Yapp&quot;&gt;Parse::Yapp&lt;/a&gt;, &lt;a href=&quot;text/balanced&quot;&gt;Text::Balanced&lt;/a&gt;, or &lt;a href=&quot;http://search.cpan.org/perldoc/Marpa::R2&quot;&gt;Marpa::R2&lt;/a&gt;.</source>
          <target state="translated">보다 복잡한 경우에는 &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Grammars&quot;&gt;Regexp :: Grammars&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Parse::RecDescent&quot;&gt;Parse :: RecDescent&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Parse::Yapp&quot;&gt;Parse :: Yapp&lt;/a&gt; , &lt;a href=&quot;text/balanced&quot;&gt;Text :: Balanced&lt;/a&gt; 또는 &lt;a href=&quot;http://search.cpan.org/perldoc/Marpa::R2&quot;&gt;Marpa :: R2&lt;/a&gt; 와 같은 CPAN의 구문 분석 모듈을 사용하여 구문 분석기를 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b11b4dd1cd41cf4f86d96c0b775f01a4fba8ea41" translate="yes" xml:space="preserve">
          <source>More complex data types can be constructed using references, which allow you to build lists and hashes within lists and hashes.</source>
          <target state="translated">참조를 사용하여 더 복잡한 데이터 유형을 구성 할 수 있으므로 목록과 해시 내에 목록과 해시를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22de1dce99fa44a08c2393686bc2b8372b954725" translate="yes" xml:space="preserve">
          <source>More complex sub-classes may have to replicate more of the logic internal of Math::BigInt if they need to change more basic behaviors. A subclass that needs to merely change the output only needs to overload &lt;code&gt;bstr()&lt;/code&gt; .</source>
          <target state="translated">더 복잡한 하위 클래스가 더 많은 기본 동작을 변경해야하는 경우 Math :: BigInt의 내부 논리를 더 많이 복제해야 할 수 있습니다. 단순히 출력을 변경해야하는 서브 클래스는 &lt;code&gt;bstr()&lt;/code&gt; 오버로드 만하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="2fbe3042a0cc3a612b8a82908d39dc629d888d5d" translate="yes" xml:space="preserve">
          <source>More complicated XSUBs may contain many other sections. Each section of an XSUB starts with the corresponding keyword, such as INIT: or CLEANUP:. However, the first two lines of an XSUB always contain the same data: descriptions of the return type and the names of the function and its parameters. Whatever immediately follows these is considered to be an INPUT: section unless explicitly marked with another keyword. (See &lt;a href=&quot;#The-INPUT%3a-Keyword&quot;&gt;The INPUT: Keyword&lt;/a&gt;.)</source>
          <target state="translated">더 복잡한 XSUB에는 다른 많은 섹션이 포함될 수 있습니다. XSUB의 각 섹션은 INIT : 또는 CLEANUP :과 같은 해당 키워드로 시작합니다. 그러나 XSUB의 처음 두 행에는 항상 동일한 데이터가 포함됩니다. 리턴 유형 설명 및 함수 이름 및 매개 변수 이름. 바로 뒤에 나오는 것은 다른 키워드로 명시 적으로 표시되지 않는 한 INPUT : 섹션으로 간주됩니다. ( &lt;a href=&quot;#The-INPUT%3a-Keyword&quot;&gt;입력 : 키워드&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="d66d0268f9a384b521bc030afaac1581d909de98" translate="yes" xml:space="preserve">
          <source>More confusing options than you can shake a big stick at! It's not as bad as it looks and it's very useful to know more about all of it, and fun too!</source>
          <target state="translated">당신이 큰 막대기를 흔들 수있는 것보다 더 혼란스러운 옵션! 외형만큼 나쁘지는 않으며 모든 것에 대해 더 많이 알고 재미있게 사용하는 것이 매우 유용합니다!</target>
        </trans-unit>
        <trans-unit id="526d1ff4132ac0e34dbd3812351d44fc0c1c9026" translate="yes" xml:space="preserve">
          <source>More detail on each of the modifiers follows. Most likely you don't need to know this detail for &lt;code&gt;/l&lt;/code&gt; , &lt;code&gt;/u&lt;/code&gt; , and &lt;code&gt;/d&lt;/code&gt;, and can skip ahead to &lt;a href=&quot;#%2fa-(and-%2faa)&quot;&gt;/a&lt;/a&gt;.</source>
          <target state="translated">각 수정 자에 대한 자세한 내용은 다음과 같습니다. 대부분의 경우이 세부 사항에 대한 알 필요가 없습니다 &lt;code&gt;/l&lt;/code&gt; , &lt;code&gt;/u&lt;/code&gt; , 및 &lt;code&gt;/d&lt;/code&gt; 하고 건너 뛰고 수 &lt;a href=&quot;#%2fa-(and-%2faa)&quot;&gt;/ A&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d5d17cbfc12e087be467835457f4aeb7c6f18f60" translate="yes" xml:space="preserve">
          <source>More detailed example</source>
          <target state="translated">더 자세한 예</target>
        </trans-unit>
        <trans-unit id="f2fe550e6e93ebe700899518f39fbee8a6928544" translate="yes" xml:space="preserve">
          <source>More detailed information about Perl syntax can be found in &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt;.</source>
          <target state="translated">Perl 구문에 대한 자세한 내용은 &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d4d020339877fe2163d2f4652ee795295ae937b6" translate="yes" xml:space="preserve">
          <source>More details on hacking the Perl core. This document focuses on lower level details such as how to write tests, compilation issues, portability, debugging, etc.</source>
          <target state="translated">Perl 코어 해킹에 대한 자세한 내용 이 문서는 테스트 작성 방법, 컴파일 문제, 이식성, 디버깅 등과 같은 하위 수준의 세부 사항에 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="e8bbc3f15f8c3d6fccfab2c6f797ecddb3a71815" translate="yes" xml:space="preserve">
          <source>More details on the categories used by Perl are given below in &lt;a href=&quot;#LOCALE-CATEGORIES&quot;&gt;LOCALE CATEGORIES&lt;/a&gt;.</source>
          <target state="translated">Perl이 사용하는 카테고리에 대한 자세한 내용은 아래의 &lt;a href=&quot;#LOCALE-CATEGORIES&quot;&gt;LOCALE CATEGORIES&lt;/a&gt; 에서 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="abe7c3d7dc58312e0a715568eb7fe1648b80945e" translate="yes" xml:space="preserve">
          <source>More formally, &lt;code&gt;\p{Uppercase}&lt;/code&gt; matches any single character whose Unicode &lt;code&gt;Uppercase&lt;/code&gt; property value is &lt;code&gt;True&lt;/code&gt; , and &lt;code&gt;\P{Uppercase}&lt;/code&gt; matches any character whose &lt;code&gt;Uppercase&lt;/code&gt; property value is &lt;code&gt;False&lt;/code&gt; , and they could have been written as &lt;code&gt;\p{Uppercase=True}&lt;/code&gt; and &lt;code&gt;\p{Uppercase=False}&lt;/code&gt; , respectively.</source>
          <target state="translated">보다 공식적으로 &lt;code&gt;\p{Uppercase}&lt;/code&gt; 는 유니 코드 &lt;code&gt;Uppercase&lt;/code&gt; 속성 값이 &lt;code&gt;True&lt;/code&gt; 인 단일 문자와 일치 하고 &lt;code&gt;\P{Uppercase}&lt;/code&gt; 는 &lt;code&gt;Uppercase&lt;/code&gt; 속성 값이 &lt;code&gt;False&lt;/code&gt; 인 모든 문자와 일치 하며 &lt;code&gt;\p{Uppercase=True}&lt;/code&gt; 로 쓸 수 있습니다 및 &lt;code&gt;\p{Uppercase=False}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="27451c770878f49944a4e46db9a7b7a2c5c07101" translate="yes" xml:space="preserve">
          <source>More formally, it will be false if anything has happened which makes it impossible for the test suite to pass. True otherwise.</source>
          <target state="translated">더 공식적으로, 테스트 스위트가 통과 할 수없는 일이 발생하면 거짓이됩니다. 그렇지 않으면 맞습니다.</target>
        </trans-unit>
        <trans-unit id="e4f15e11fdfe41914601fd2b52ca88c4e0b2db11" translate="yes" xml:space="preserve">
          <source>More fun with &lt;code&gt;?{}&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;?{}&lt;/code&gt; 더 재미있게 :</target>
        </trans-unit>
        <trans-unit id="4da98cf1b684d1edc72215ded0f14b15a6f1b445" translate="yes" xml:space="preserve">
          <source>More important (and less obvious) is the necessity of garbage collection. When a normal object dies, anything stored in the object body is garbage-collected by perl. With inside-out objects, Perl knows nothing about the data stored in field hashes by a class, but these must be deleted when the object goes out of scope. Thus the class must provide a &lt;code&gt;DESTROY&lt;/code&gt; method to take care of that.</source>
          <target state="translated">더 중요하고 덜 분명한 것은 가비지 수집의 필요성입니다. 일반 객체가 죽으면 객체 본문에 저장된 모든 항목이 perl에 의해 가비지 수집됩니다. 인사이드 아웃 오브젝트를 사용하면 Perl은 클래스에 의해 필드 해시에 저장된 데이터에 대해 아무것도 알지 못하지만 오브젝트가 범위를 벗어날 때 삭제해야합니다. 따라서 클래스는이를 처리하기 위해 &lt;code&gt;DESTROY&lt;/code&gt; 메소드를 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4232744f447684a298c82dce2791eb6cf2ae4bde" translate="yes" xml:space="preserve">
          <source>More importantly, you assume</source>
          <target state="translated">더 중요한 것은</target>
        </trans-unit>
        <trans-unit id="dbb4a7aa9653e873e873e3d4f83808761932aa49" translate="yes" xml:space="preserve">
          <source>More information on the terminal capabilities will be found in the termcap manpage on most Unix-like systems.</source>
          <target state="translated">터미널 기능에 대한 자세한 내용은 대부분의 Unix 계열 시스템의 termcap 맨 페이지에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa9cc3109d4e7c580c76561d1b8bded0209caf69" translate="yes" xml:space="preserve">
          <source>More layers than just the encoding can be specified here. For example, the incantation &lt;code&gt;&quot;:raw :encoding(UTF-16LE) :crlf&quot;&lt;/code&gt; includes implicit CRLF handling.</source>
          <target state="translated">여기서는 인코딩보다 더 많은 레이어를 지정할 수 있습니다. 예를 들어, &lt;code&gt;&quot;:raw :encoding(UTF-16LE) :crlf&quot;&lt;/code&gt; 는 암시적인 CRLF 처리를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="c7d270a53a536b611473a25cb95f7037520a02f0" translate="yes" xml:space="preserve">
          <source>More matching</source>
          <target state="translated">더 일치</target>
        </trans-unit>
        <trans-unit id="b707ad370452316dedfbb6479f84b90feffeb14b" translate="yes" xml:space="preserve">
          <source>More on characters, strings, and character classes</source>
          <target state="translated">문자, 문자열 및 문자 클래스에 대한 추가 정보</target>
        </trans-unit>
        <trans-unit id="0e20dff8fe6d2b34d7e4d4cac19464fdb760259e" translate="yes" xml:space="preserve">
          <source>More sophisticated example:</source>
          <target state="translated">보다 정교한 예 :</target>
        </trans-unit>
        <trans-unit id="58cc9a8a265ceaaf00e7a02c5fa1c3956c64ee64" translate="yes" xml:space="preserve">
          <source>More testing functions! Once you outgrow Test::Simple, look at &lt;a href=&quot;more&quot;&gt;Test::More&lt;/a&gt;. Test::Simple is 100% forward compatible with &lt;a href=&quot;more&quot;&gt;Test::More&lt;/a&gt; (i.e. you can just use &lt;a href=&quot;more&quot;&gt;Test::More&lt;/a&gt; instead of Test::Simple in your programs and things will still work).</source>
          <target state="translated">더 많은 테스트 기능! Test :: Simple을 벗어나면 &lt;a href=&quot;more&quot;&gt;Test :: More를보십시오&lt;/a&gt; . Test :: Simple은 &lt;a href=&quot;more&quot;&gt;Test :: More&lt;/a&gt; 와 100 % 호환됩니다 (즉 , 프로그램에서 Test :: Simple 대신 &lt;a href=&quot;more&quot;&gt;Test :: More&lt;/a&gt; 를 사용할 수 있으며 여전히 작동합니다).</target>
        </trans-unit>
        <trans-unit id="dca60a28cf5bfac5c3931dc141dffe59abb6ab5a" translate="yes" xml:space="preserve">
          <source>More tests.</source>
          <target state="translated">더 많은 테스트.</target>
        </trans-unit>
        <trans-unit id="280bbf061032f32980db94b9cf615b5506c7b962" translate="yes" xml:space="preserve">
          <source>More tests. (Stuff I didn't think of yet.)</source>
          <target state="translated">더 많은 테스트. (아직도 생각하지 못했습니다.)</target>
        </trans-unit>
        <trans-unit id="371109ba4b8859f3e3185200282a3a250ce94866" translate="yes" xml:space="preserve">
          <source>Moreover, inside &lt;code&gt;(?{BLOCK})&lt;/code&gt;, &lt;code&gt;(?# comment )&lt;/code&gt;, and a &lt;code&gt;#&lt;/code&gt; -comment in a &lt;code&gt;/x&lt;/code&gt;-regular expression, no processing is performed whatsoever. This is the first step at which the presence of the &lt;code&gt;/x&lt;/code&gt; modifier is relevant.</source>
          <target state="translated">또한, 내부 &lt;code&gt;(?{BLOCK})&lt;/code&gt; , &lt;code&gt;(?# comment )&lt;/code&gt; 및 &lt;code&gt;#&lt;/code&gt; -comment에 &lt;code&gt;/x&lt;/code&gt; - 정규 표현식은 어떠한 처리를 전혀 수행되지 않는다. 이것은 &lt;code&gt;/x&lt;/code&gt; 수정 자의 존재와 관련된 첫 번째 단계 입니다.</target>
        </trans-unit>
        <trans-unit id="766af651754c70019b0147c9aabb389875f6513e" translate="yes" xml:space="preserve">
          <source>Moreover, the Perl interpreter itself has had serious bugs involving fatalized warnings. For a summary of resolved and unresolved problems as of January 2015, please see &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.nntp.perl.org%2fgroup%2fperl.perl5.porters%2f2015%2f01%2fmsg225235.html&quot;&gt;this perl5-porters post&lt;/a&gt;.</source>
          <target state="translated">또한 Perl 인터프리터 자체에는 치명적인 경고와 관련된 심각한 버그가 있습니다. 2015 년 1 월 기준으로 해결되고 해결되지 않은 문제에 대한 요약은 &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.nntp.perl.org%2fgroup%2fperl.perl5.porters%2f2015%2f01%2fmsg225235.html&quot;&gt;이 perl5-porters post&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="71781bd1796397c70432d8ed26a8fe5878ffc4aa" translate="yes" xml:space="preserve">
          <source>Moreover, users may expect this:</source>
          <target state="translated">또한 사용자는 다음을 기대할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd0ec74af25710eb89dcb326b64083f39f30db7a" translate="yes" xml:space="preserve">
          <source>Most &lt;code&gt;&lt;a href=&quot;functions/socket&quot;&gt;socket()&lt;/a&gt;&lt;/code&gt; related calls are supported, but they may not behave as on Unix platforms. See &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for the full list.</source>
          <target state="translated">대부분의 &lt;code&gt;&lt;a href=&quot;functions/socket&quot;&gt;socket()&lt;/a&gt;&lt;/code&gt; 관련 호출이 지원되지만 Unix 플랫폼에서는 작동하지 않을 수 있습니다. 전체 목록 은 &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8bd7ca1c6bc950dfa343636c44e8a991660d9872" translate="yes" xml:space="preserve">
          <source>Most &lt;code&gt;Config&lt;/code&gt; variables are determined by the &lt;code&gt;Configure&lt;/code&gt; script on platforms supported by it (which is most UNIX platforms). Some platforms have custom-made &lt;code&gt;Config&lt;/code&gt; variables, and may thus not have some of the variables described below, or may have extraneous variables specific to that particular port. See the port specific documentation in such cases.</source>
          <target state="translated">대부분의 &lt;code&gt;Config&lt;/code&gt; 변수는 지원되는 플랫폼 (대부분의 UNIX 플랫폼) 에서 &lt;code&gt;Configure&lt;/code&gt; 스크립트에 의해 결정됩니다 . 일부 플랫폼에는 맞춤형 &lt;code&gt;Config&lt;/code&gt; 변수가 있으므로 아래에 설명 된 변수 중 일부가 없거나 특정 포트와 관련된 외부 변수가있을 수 있습니다. 이러한 경우 포트 별 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3cb850eec5c7ca91283476032e5d18060f62e376" translate="yes" xml:space="preserve">
          <source>Most OS have a maximum command length they can execute at once. Large modules can easily generate commands well past that limit. Its necessary to split long commands up into a series of shorter commands.</source>
          <target state="translated">대부분의 OS는 한 번에 실행할 수있는 최대 명령 길이를 갖습니다. 대형 모듈은 해당 한계를 훨씬 초과하는 명령을 쉽게 생성 할 수 있습니다. 긴 명령을 일련의 짧은 명령으로 분할해야합니다.</target>
        </trans-unit>
        <trans-unit id="87aec58e27c477535ee7ea89c7549f2b78b3f922" translate="yes" xml:space="preserve">
          <source>Most POSIX character classes have two Unicode-style &lt;code&gt;\p&lt;/code&gt; property counterparts. (They are not official Unicode properties, but Perl extensions derived from official Unicode properties.) The table below shows the relation between POSIX character classes and these counterparts.</source>
          <target state="translated">대부분의 POSIX 문자 클래스에는 두 개의 유니 코드 스타일 &lt;code&gt;\p&lt;/code&gt; 속성 대응 문자가 있습니다 . (공식 유니 코드 속성은 아니지만 공식 유니 코드 속성에서 파생 된 Perl 확장입니다.) 아래 표는 POSIX 문자 클래스와 이러한 대응 항목 간의 관계를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="dc62d968e4cf48df873bc6b26766e14aed8bb9a1" translate="yes" xml:space="preserve">
          <source>Most Perl Web Frameworks will have a mechanism for doing this, using the &lt;a href=&quot;http://search.cpan.org/perldoc/Catalyst&quot;&gt;Catalyst&lt;/a&gt; framework it would be:</source>
          <target state="translated">대부분의 Perl 웹 프레임 워크는 &lt;a href=&quot;http://search.cpan.org/perldoc/Catalyst&quot;&gt;Catalyst&lt;/a&gt; 프레임 워크를 사용하여이를 수행하는 메커니즘을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="536328dda2b64b33176fd10e64fdf2366a37e10b" translate="yes" xml:space="preserve">
          <source>Most Perl features behave in a natural way within pseudo-processes.</source>
          <target state="translated">대부분의 Perl 기능은 의사 프로세스 내에서 자연스럽게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="cc5eff88f8f7c24acf735b42756c6ec6877ad919" translate="yes" xml:space="preserve">
          <source>Most Perl-related projects set up mailing lists for both users and contributors. If you don't see a certain project listed at &lt;a href=&quot;http://lists.perl.org&quot;&gt;http://lists.perl.org&lt;/a&gt;, check the particular website for that project. Most mailing lists are archived at &lt;a href=&quot;http://nntp.perl.org/&quot;&gt;http://nntp.perl.org/&lt;/a&gt;.</source>
          <target state="translated">대부분의 Perl 관련 프로젝트는 사용자와 기고자 모두를위한 메일 링리스트를 설정합니다. &lt;a href=&quot;http://lists.perl.org&quot;&gt;http://lists.perl.org에&lt;/a&gt; 특정 프로젝트가 표시되지 않으면 해당 프로젝트의 특정 웹 사이트를 확인하십시오. 대부분의 메일 링리스트는 &lt;a href=&quot;http://nntp.perl.org/&quot;&gt;http://nntp.perl.org/에&lt;/a&gt; 보관되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b0a52de9bf06827eb244cce4b2303069fe873df" translate="yes" xml:space="preserve">
          <source>Most Unicode character properties have at least two synonyms (or aliases if you prefer): a short one that is easier to type and a longer one that is more descriptive and hence easier to understand. Thus the &lt;code&gt;&quot;L&quot;&lt;/code&gt; and &lt;code&gt;&quot;Letter&quot;&lt;/code&gt; properties above are equivalent and can be used interchangeably. Likewise, &lt;code&gt;&quot;Upper&quot;&lt;/code&gt; is a synonym for &lt;code&gt;&quot;Uppercase&quot;&lt;/code&gt; , and we could have written &lt;code&gt;\p{Uppercase}&lt;/code&gt; equivalently as &lt;code&gt;\p{Upper}&lt;/code&gt; . Also, there are typically various synonyms for the values the property can be. For binary properties, &lt;code&gt;&quot;True&quot;&lt;/code&gt; has 3 synonyms: &lt;code&gt;&quot;T&quot;&lt;/code&gt; , &lt;code&gt;&quot;Yes&quot;&lt;/code&gt; , and &lt;code&gt;&quot;Y&quot;&lt;/code&gt; ; and &lt;code&gt;&quot;False&quot;&lt;/code&gt; has correspondingly &lt;code&gt;&quot;F&quot;&lt;/code&gt; , &lt;code&gt;&quot;No&quot;&lt;/code&gt; , and &lt;code&gt;&quot;N&quot;&lt;/code&gt; . But be careful. A short form of a value for one property may not mean the same thing as the same short form for another. Thus, for the &lt;code&gt;&lt;a href=&quot;#General_Category&quot;&gt;General_Category&lt;/a&gt;&lt;/code&gt; property, &lt;code&gt;&quot;L&quot;&lt;/code&gt; means &lt;code&gt;&quot;Letter&quot;&lt;/code&gt; , but for the &lt;a href=&quot;#Bidirectional-Character-Types&quot;&gt;Bidi_Class &lt;/a&gt; property, &lt;code&gt;&quot;L&quot;&lt;/code&gt; means &lt;code&gt;&quot;Left&quot;&lt;/code&gt; . A complete list of properties and synonyms is in &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;.</source>
          <target state="translated">대부분의 유니 코드 문자 속성에는 두 개 이상의 동의어 (또는 원하는 경우 별칭)가 있습니다. 짧게 입력하기 쉽고 짧고 설명하기 쉽고 이해하기 쉽습니다. 따라서 위의 &lt;code&gt;&quot;L&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;Letter&quot;&lt;/code&gt; 속성은 동일하며 상호 교환 적으로 사용될 수 있습니다. 마찬가지로 &lt;code&gt;&quot;Upper&quot;&lt;/code&gt; 는 &lt;code&gt;&quot;Uppercase&quot;&lt;/code&gt; 와 동의어이며 &lt;code&gt;\p{Uppercase}&lt;/code&gt; 를 &lt;code&gt;\p{Upper}&lt;/code&gt; 와 동일하게 작성할 수 있습니다 . 또한 일반적으로 속성의 값에 대한 다양한 동의어가 있습니다. 이진 속성의 경우 &lt;code&gt;&quot;True&quot;&lt;/code&gt; 에는 &lt;code&gt;&quot;T&quot;&lt;/code&gt; , &lt;code&gt;&quot;Yes&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;Y&quot;&lt;/code&gt; 의 3 개의 동의어가 있습니다.; 그리고 &lt;code&gt;&quot;False&quot;&lt;/code&gt; 대응이 &lt;code&gt;&quot;F&quot;&lt;/code&gt; , &lt;code&gt;&quot;No&quot;&lt;/code&gt; , 및 &lt;code&gt;&quot;N&quot;&lt;/code&gt; 를 . 그러나 조심하십시오. 한 속성에 대한 짧은 형식의 값은 다른 속성에 대한 동일한 짧은 형식과 동일한 것을 의미하지 않을 수 있습니다. 따라서 &lt;code&gt;&lt;a href=&quot;#General_Category&quot;&gt;General_Category&lt;/a&gt;&lt;/code&gt; 속성의 경우 &lt;code&gt;&quot;L&quot;&lt;/code&gt; 은 &lt;code&gt;&quot;Letter&quot;&lt;/code&gt; 를 의미 하지만 &lt;a href=&quot;#Bidirectional-Character-Types&quot;&gt;Bidi_Class&lt;/a&gt; 속성의 경우 &lt;code&gt;&quot;L&quot;&lt;/code&gt; 은 &lt;code&gt;&quot;Left&quot;&lt;/code&gt; 를 의미 합니다. 속성과 동의어의 전체 목록은 &lt;a href=&quot;perluniprops&quot;&gt;perluniprops에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="c33601ec8592d8b99971745f555ad60f8af01ae0" translate="yes" xml:space="preserve">
          <source>Most Unicode properties have several synonymous names. Typically, there is at least a short name, convenient to type, and a long name that more fully describes the property, and hence is more easily understood.</source>
          <target state="translated">대부분의 유니 코드 속성에는 여러 동의어 이름이 있습니다. 일반적으로 속성을보다 완전하게 설명하는 짧은 이름, 입력하기 편리한 이름 및 긴 이름이 있으므로 이해하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="c27a5f71254b1b3c6a849e7bef1eacb3f778bdb9" translate="yes" xml:space="preserve">
          <source>Most algorithms are only defined for strings of bytes and this method might therefore croak if the provided arguments contain chars with ordinal number above 255.</source>
          <target state="translated">대부분의 알고리즘은 바이트 문자열에 대해서만 정의되므로 제공된 인수에 서 수가 255보다 큰 문자가 포함 된 경우이 메소드가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b83511857d278656d99d572ed9af8349be0ed8d8" translate="yes" xml:space="preserve">
          <source>Most characters that are meta characters in regular expressions (that is, characters that carry a special meaning like &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; , or &lt;code&gt;(&lt;/code&gt;) lose their special meaning and can be used inside a character class without the need to escape them. For instance, &lt;code&gt;[()]&lt;/code&gt; matches either an opening parenthesis, or a closing parenthesis, and the parens inside the character class don't group or capture.</source>
          <target state="translated">이다 정규 표현식에서 메타 문자 (대부분의 문자와 같은 특별한 의미를 가지고 문자 &lt;code&gt;.&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , 또는 &lt;code&gt;(&lt;/code&gt; ) 자신의 특별한 의미를 잃고 그들을 탈출 할 필요없이 문자 클래스 내에서 사용될 수있다. 예를 들어, &lt;code&gt;[()]&lt;/code&gt; 는 여는 괄호 또는 닫는 괄호와 일치하며 문자 클래스 내부의 Parens는 그룹화하거나 캡처하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0df73814a9b3dab0955308c1ef467807cec3d266" translate="yes" xml:space="preserve">
          <source>Most compiler backends use the following conventions: OPTIONS consists of a comma-separated list of words (no white-space). The &lt;code&gt;-v&lt;/code&gt; option usually puts the backend into verbose mode. The &lt;code&gt;-ofile&lt;/code&gt; option generates output to &lt;b&gt;file&lt;/b&gt; instead of stdout. The &lt;code&gt;-D&lt;/code&gt; option followed by various letters turns on various internal debugging flags. See the documentation for the desired backend (named &lt;code&gt;B::Backend&lt;/code&gt; for the example above) to find out about that backend.</source>
          <target state="translated">대부분의 컴파일러 백엔드는 다음 규칙을 사용합니다. OPTIONS는 쉼표로 구분 된 단어 목록 (공백 없음)으로 구성됩니다. &lt;code&gt;-v&lt;/code&gt; 옵션은 일반적으로 상세 모드로 백엔드를 넣습니다. &lt;code&gt;-ofile&lt;/code&gt; 옵션은 출력을 생성하는 &lt;b&gt;파일&lt;/b&gt; 대신에 표준 출력. &lt;code&gt;-D&lt;/code&gt; 옵션은 다양한 내부 디버깅 플래그에 다양한 문자 회전 하였다. 해당 백엔드에 대한 정보는 원하는 백엔드 설명서 ( 위 예제의 경우 &lt;code&gt;B::Backend&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2ceb62989a1effad36bd037ec531f4c70cb866db" translate="yes" xml:space="preserve">
          <source>Most digest algorithms are byte based and for these it is not possible to add bits that are not a multiple of 8, and the add_bits() method will croak if you try.</source>
          <target state="translated">대부분의 다이제스트 알고리즘은 바이트 기반이므로 8의 배수가 아닌 비트를 추가 할 수 없으며 시도하면 add_bits () 메서드가 손상됩니다.</target>
        </trans-unit>
        <trans-unit id="e8e0432f156912c28405beeb7541e8a07073675c" translate="yes" xml:space="preserve">
          <source>Most extensions (whether they require a C compiler or not) can be built, tested and installed with the standard mantra:</source>
          <target state="translated">대부분의 확장 (C 컴파일러가 필요한지 여부에 관계없이)은 표준 형식으로 빌드, 테스트 및 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2f7deae35b5b32265a212cc23f97fad9e01f8ca" translate="yes" xml:space="preserve">
          <source>Most functions in package CPAN are exported by default. The reason for this is that the primary use is intended for the cpan shell or for one-liners.</source>
          <target state="translated">CPAN 패키지의 대부분의 기능은 기본적으로 내보내집니다. 그 이유는 주요 용도가 cpan 쉘 또는 1 개의 라이너를위한 것이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="5781421ac333dfdfd58bada47c5083697a175449" translate="yes" xml:space="preserve">
          <source>Most implementations of &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; take an integer and will silently truncate decimal numbers. This means &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand(42)&lt;/a&gt;&lt;/code&gt; will usually produce the same results as &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand(42.1)&lt;/a&gt;&lt;/code&gt;. To be safe, always pass &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; an integer.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; 의 대부분의 구현은 정수를 사용하며 10 진수를 자동으로 자릅니다. 이는 &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand(42)&lt;/a&gt;&lt;/code&gt; 가 일반적으로 &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand(42.1)&lt;/a&gt;&lt;/code&gt; 과 동일한 결과를 생성 함을 의미 합니다. 안전을 위해 항상 정수에 &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; 를 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="405bded6ca944a37e6c3b479ff1de785ad3f9801" translate="yes" xml:space="preserve">
          <source>Most implementations of &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; take an integer and will silently truncate decimal numbers. This means &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand(42)&lt;/a&gt;&lt;/code&gt; will usually produce the same results as &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand(42.1)&lt;/a&gt;&lt;/code&gt;. To be safe, always pass &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; an integer.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; 의 대부분의 구현은 정수를 사용하며 10 진수를 자동으로 자릅니다. 이는 &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand(42)&lt;/a&gt;&lt;/code&gt; 가 일반적으로 &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand(42.1)&lt;/a&gt;&lt;/code&gt; 과 동일한 결과를 생성 함을 의미 합니다. 안전을 위해 항상 정수에 &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; 를 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="5d6b5dfca3c0039899dcb7cae60483d04f370ee8" translate="yes" xml:space="preserve">
          <source>Most importantly, CPAN includes around a thousand unbundled modules, some of which require a C compiler to build. Major categories of modules are:</source>
          <target state="translated">가장 중요한 점은 CPAN에 번들로 제공되지 않는 약 1,000 개의 모듈이 포함되어 있으며,이 중 일부는 C 컴파일러가 필요합니다. 주요 모듈 범주는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="acf589d2649f04394cc8c6cda103470ec97cfc12" translate="yes" xml:space="preserve">
          <source>Most importantly, choose modules which are as stable as possible. In order of preference:</source>
          <target state="translated">가장 중요한 것은 가능한 한 안정적인 모듈을 선택하십시오. 선호도 순서대로 :</target>
        </trans-unit>
        <trans-unit id="2a11d2785522a93f5420fa16470f086a6da1b3ea" translate="yes" xml:space="preserve">
          <source>Most mentioned distributions are depots. H.Merijn Brand has made prebuilt gcc binaries available on &lt;a href=&quot;http://mirrors.develooper.com/hpux/&quot;&gt;http://mirrors.develooper.com/hpux/&lt;/a&gt; and/or &lt;a href=&quot;http://www.cmve.net/~merijn/&quot;&gt;http://www.cmve.net/~merijn/&lt;/a&gt; for HP-UX 10.20 (only 32bit), HP-UX 11.00, HP-UX 11.11 (HP-UX 11i v1), and HP-UX 11.23 (HP-UX 11i v2 PA-RISC) in both 32- and 64-bit versions. For HP-UX 11.23 IPF and HP-UX 11.31 IPF depots are available too. The IPF versions do not need two versions of GNU gcc.</source>
          <target state="translated">가장 많이 언급 된 배포판은 저장소입니다. H.Merijn Brand는 HP-UX 10.20 (32 비트 전용), HP의 경우 &lt;a href=&quot;http://mirrors.develooper.com/hpux/&quot;&gt;http://mirrors.develooper.com/hpux/&lt;/a&gt; 및 / 또는 &lt;a href=&quot;http://www.cmve.net/~merijn/&quot;&gt;http://www.cmve.net/~merijn/&lt;/a&gt; 에서 사전 빌드 된 gcc 바이너리를 제공합니다 . 32 비트 및 64 비트 버전의 -UX 11.00, HP-UX 11.11 (HP-UX 11i v1) 및 HP-UX 11.23 (HP-UX 11i v2 PA-RISC). HP-UX 11.23 IPF 및 HP-UX 11.31 IPF 저장소도 사용할 수 있습니다. IPF 버전에는 두 가지 버전의 GNU gcc가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="236aab386cc9ca4c5e8adffaa67e969c764a4805" translate="yes" xml:space="preserve">
          <source>Most methods you write will expect to operate on objects:</source>
          <target state="translated">작성하는 대부분의 방법은 객체에서 작동 할 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="e42995ec64ef087af8c046e70f5daf6eb0079f02" translate="yes" xml:space="preserve">
          <source>Most modern X terminal emulators support 256 colors. Known to not support those colors are aterm, rxvt, Terminal.app, and TTY/VC.</source>
          <target state="translated">대부분의 최신 X 터미널 에뮬레이터는 256 색을 지원합니다. 해당 색상을 지원하지 않는 것으로 알려진 것은 aterm, rxvt, Terminal.app 및 TTY / VC입니다.</target>
        </trans-unit>
        <trans-unit id="09fdc7d65b76d3e363653e14537a18e5aea28f56" translate="yes" xml:space="preserve">
          <source>Most modern operating systems support preemptive multitasking nowadays.</source>
          <target state="translated">오늘날 대부분의 최신 운영 체제는 선점 형 멀티 태스킹을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="1d45edd059b4e41b42c3589d6e9743f7467d5f99" translate="yes" xml:space="preserve">
          <source>Most modifiers, such as &lt;code&gt;//i&lt;/code&gt; , &lt;code&gt;//m&lt;/code&gt; , &lt;code&gt;//s&lt;/code&gt; and &lt;code&gt;//x&lt;/code&gt; (or any combination thereof) can also be embedded in a regexp using &lt;code&gt;(?i)&lt;/code&gt;, &lt;code&gt;(?m)&lt;/code&gt;, &lt;code&gt;(?s)&lt;/code&gt;, and &lt;code&gt;(?x)&lt;/code&gt;. For instance,</source>
          <target state="translated">&lt;code&gt;//i&lt;/code&gt; , &lt;code&gt;//m&lt;/code&gt; , &lt;code&gt;//s&lt;/code&gt; 및 &lt;code&gt;//x&lt;/code&gt; (또는 이들의 조합) 와 같은 대부분의 수정자는 &lt;code&gt;(?i)&lt;/code&gt; , &lt;code&gt;(?m)&lt;/code&gt; , &lt;code&gt;(?s)&lt;/code&gt; 및 &lt;code&gt;(?x)&lt;/code&gt; . 예를 들어</target>
        </trans-unit>
        <trans-unit id="7aac5f91bfd266adf35f3c08ec6bb8cde72e4223" translate="yes" xml:space="preserve">
          <source>Most multi-user platforms provide basic levels of security, usually implemented at the filesystem level. Some, however, unfortunately do not. Thus the notion of user id, or &quot;home&quot; directory, or even the state of being logged-in, may be unrecognizable on many platforms. If you write programs that are security-conscious, it is usually best to know what type of system you will be running under so that you can write code explicitly for that platform (or class of platforms).</source>
          <target state="translated">대부분의 다중 사용자 플랫폼은 일반적으로 파일 시스템 수준에서 구현되는 기본 수준의 보안을 제공합니다. 그러나 불행히도 일부는 그렇지 않습니다. 따라서 많은 플랫폼에서 사용자 ID 또는 &quot;홈&quot;디렉토리 또는 로그인 상태 개념을 인식하지 못할 수 있습니다. 보안을 염두에 둔 프로그램을 작성하는 경우 일반적으로 해당 플랫폼 (또는 플랫폼 클래스)에 대한 코드를 명시 적으로 작성할 수 있도록 어떤 유형의 시스템을 실행할 것인지를 아는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4f6011591757af844f16df1e5c9352c7848a6ec4" translate="yes" xml:space="preserve">
          <source>Most non-EBCDIC character sets are supersets of ASCII. That is the integers 0-127 mean what ASCII says they mean. But integers 128 and above are specific to the character set.</source>
          <target state="translated">대부분의 비 EBCDIC 문자 세트는 ASCII의 상위 세트입니다. 즉, 정수 0-127은 ASCII가 의미하는 바를 의미합니다. 그러나 정수 128 이상은 문자 집합에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="51ca37247d6a69603fb3b1446157e03d96bfa6df" translate="yes" xml:space="preserve">
          <source>Most notable problems:</source>
          <target state="translated">가장 주목할만한 문제 :</target>
        </trans-unit>
        <trans-unit id="f57027e07ab6e59e959c6b528e3378204e633471" translate="yes" xml:space="preserve">
          <source>Most object systems share a number of common concepts. You've probably heard terms like &quot;class&quot;, &quot;object, &quot;method&quot;, and &quot;attribute&quot; before. Understanding the concepts will make it much easier to read and write object-oriented code. If you're already familiar with these terms, you should still skim this section, since it explains each concept in terms of Perl's OO implementation.</source>
          <target state="translated">대부분의 객체 시스템은 많은 공통 개념을 공유합니다. &quot;클래스&quot;, &quot;객체,&quot;방법 &quot;및&quot;속성 &quot;과 같은 용어를 들어 보셨을 것입니다. 개념을 이해하면 객체 지향 코드를보다 쉽게 ​​읽고 쓸 수 있습니다. 이 섹션은 Perl의 OO 구현 측면에서 각 개념을 설명하기 때문에 여전히이 섹션을 생략해야합니다.</target>
        </trans-unit>
        <trans-unit id="fe5befa620ff0477f0ac6ba4b4534580f30f2e1e" translate="yes" xml:space="preserve">
          <source>Most obviously, there is the necessity of retrieving the reference address of an object for each data access. It's a minor inconvenience, but it does clutter the code.</source>
          <target state="translated">가장 분명하게는, 각 데이터 액세스에 대해 객체의 참조 주소를 검색해야 할 필요성이 있습니다. 사소한 불편이지만 코드가 복잡해집니다.</target>
        </trans-unit>
        <trans-unit id="8966ee4f610a8f12b38c297e5e0e0d5c4c1631d5" translate="yes" xml:space="preserve">
          <source>Most of Params::Check's power comes from its template, which we'll discuss below:</source>
          <target state="translated">Params :: Check의 대부분은 템플릿에서 나옵니다. 아래에서 설명하겠습니다.</target>
        </trans-unit>
        <trans-unit id="8c05844436a81cb2d0dbddab3388c8acb9552fbf" translate="yes" xml:space="preserve">
          <source>Most of the code here was written by Randy W. Sims &amp;lt;RandyS@ThePierianSpring.org&amp;gt;.</source>
          <target state="translated">이 코드의 대부분은 Randy W. Sims &amp;lt;RandyS@ThePierianSpring.org&amp;gt;에 의해 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="47b295d947239a228d57f7cff4fa724418821ca3" translate="yes" xml:space="preserve">
          <source>Most of the complete Perl resides in the shareable image</source>
          <target state="translated">완전한 Perl의 대부분은 공유 가능한 이미지에 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e836cc0136a0b6a1e328a42911e15475ce7f8a0" translate="yes" xml:space="preserve">
          <source>Most of the complexity of the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; function lies in the many possible values that the</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 함수 의 복잡성 대부분은 가능한 많은 값에 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a21567ca84f5f746c9675299dce59640ed18c1d" translate="yes" xml:space="preserve">
          <source>Most of the keywords are self-explanatory.</source>
          <target state="translated">대부분의 키워드는 자명하다.</target>
        </trans-unit>
        <trans-unit id="98e872c4c8b4e46b1a126dccfdf045e22c43bfe9" translate="yes" xml:space="preserve">
          <source>Most of the other Opcode functions call verify_opset automatically and will croak if given an invalid opset.</source>
          <target state="translated">다른 Opcode 함수의 대부분은 verify_opset을 자동으로 호출하며 유효하지 않은 opset이 제공되면 삐걱 거립니다.</target>
        </trans-unit>
        <trans-unit id="7be58e4167c6f6d21daa45117bbd585a46416c25" translate="yes" xml:space="preserve">
          <source>Most of the overloadable operators map one-to-one to these keys. Exceptions, including additional overloadable operations not apparent from this hash, are included in the notes which follow. This list is subject to growth over time.</source>
          <target state="translated">오버로드 가능한 대부분의 연산자는 이러한 키에 일대일로 매핑됩니다. 이 해시에서 명백하지 않은 추가 과부하 작업을 포함한 예외는 다음 참고에 포함되어 있습니다. 이 목록은 시간이 지남에 따라 증가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cede88fd0fdf454c10d7b4cebb77c726e122f53" translate="yes" xml:space="preserve">
          <source>Most of the power comes from the implicit smartmatching that can sometimes apply. Most of the time, &lt;code&gt;when(EXPR)&lt;/code&gt; is treated as an implicit smartmatch of &lt;code&gt;$_&lt;/code&gt; , that is, &lt;code&gt;$_ ~~ EXPR&lt;/code&gt; . (See &lt;a href=&quot;perlop#Smartmatch-Operator&quot;&gt;Smartmatch Operator in perlop&lt;/a&gt; for more information on smartmatching.) But when</source>
          <target state="translated">대부분의 힘은 때때로 적용 할 수있는 암시 적 스마트 매칭에서 비롯됩니다. 대부분의 경우, &lt;code&gt;when(EXPR)&lt;/code&gt; 은 &lt;code&gt;$_&lt;/code&gt; 의 암시 적 스마트 매치 , 즉 &lt;code&gt;$_ ~~ EXPR&lt;/code&gt; 됩니다. &lt;a href=&quot;perlop#Smartmatch-Operator&quot;&gt;스마트&lt;/a&gt; 매칭에 대한 자세한 내용 은 perlop의 Smartmatch Operator를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="00a01cac94bf76dedfa60add1a18fb4b2e641b31" translate="yes" xml:space="preserve">
          <source>Most of the routines take an optional additional argument which specifies the code set to use. If not specified, the default ISO 15924 four-letter codes will be used.</source>
          <target state="translated">대부분의 루틴은 사용할 코드 세트를 지정하는 선택적 추가 인수를 사용합니다. 지정하지 않으면 기본 ISO 15924 4 자리 코드가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1e2964ea3d337ce474ce4e845493df4592e50a50" translate="yes" xml:space="preserve">
          <source>Most of the routines take an optional additional argument which specifies the code set to use. If not specified, the default ISO 3166-1 two-letter codes will be used.</source>
          <target state="translated">대부분의 루틴은 사용할 코드 세트를 지정하는 선택적 추가 인수를 사용합니다. 지정하지 않으면 기본 ISO 3166-1 2 문자 코드가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c51fe921a01a7d85e172a82dee63cf013d880282" translate="yes" xml:space="preserve">
          <source>Most of the routines take an optional additional argument which specifies the code set to use. If not specified, the default ISO 4217 three-letter codes will be used.</source>
          <target state="translated">대부분의 루틴은 사용할 코드 세트를 지정하는 선택적 추가 인수를 사용합니다. 지정하지 않으면 기본 ISO 4217 3 자리 코드가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ad65d964877735755761a49062026c5cbfd01a4c" translate="yes" xml:space="preserve">
          <source>Most of the routines take an optional additional argument which specifies the code set to use. If not specified, the default ISO 639 two-letter codes will be used.</source>
          <target state="translated">대부분의 루틴은 사용할 코드 세트를 지정하는 선택적 추가 인수를 사용합니다. 지정하지 않으면 기본 ISO 639 2 문자 코드가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ecfd9a8718bf7f9a8bea5531a84bc0b93eebafb4" translate="yes" xml:space="preserve">
          <source>Most of the special variables related to regular expressions are side effects. Perl sets these variables when it has a successful match, so you should check the match result before using them. For instance:</source>
          <target state="translated">정규식과 관련된 대부분의 특수 변수는 부작용입니다. Perl은 성공적으로 일치 할 때 이러한 변수를 설정하므로 사용하기 전에 일치 결과를 확인해야합니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="dd8324ae92ad5052d02cf97e850674cb89e9ea59" translate="yes" xml:space="preserve">
          <source>Most of the time the &lt;code&gt;POP*&lt;/code&gt; macros should be adequate; the main problem with them is that they force you to process the returned values in sequence. This may not be the most suitable way to process the values in some cases. What we want is to be able to access the stack in a random order. The &lt;code&gt;ST&lt;/code&gt; macro as used when coding an XSUB is ideal for this purpose.</source>
          <target state="translated">대부분의 경우 &lt;code&gt;POP*&lt;/code&gt; 매크로가 적합해야합니다. 그것들의 주요 문제는 반환 된 값을 순서대로 처리해야한다는 것입니다. 경우에 따라 값을 처리하기에 가장 적합한 방법이 아닐 수도 있습니다. 우리가 원하는 것은 무작위 순서로 스택에 액세스 할 수있는 것입니다. &lt;code&gt;ST&lt;/code&gt; 의 XSUB 부호화 할 때 사용되는 바와 같이, 매크로는이 목적에 적합하다.</target>
        </trans-unit>
        <trans-unit id="2df244eb4bef5a0bc68e79be4405c972c5f0e791" translate="yes" xml:space="preserve">
          <source>Most of the time you should not need to do this as your web framework, or if you are making a request, the &lt;a href=&quot;http://search.cpan.org/perldoc/LWP&quot;&gt;LWP&lt;/a&gt; or other module would handle it for you.</source>
          <target state="translated">대부분의 경우 웹 프레임 워크로이 작업을 수행 할 필요가 없거나 요청하는 경우 &lt;a href=&quot;http://search.cpan.org/perldoc/LWP&quot;&gt;LWP&lt;/a&gt; 또는 다른 모듈이이를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="7e6eb8148850007d8fa7e26443b2a04c22c7a11f" translate="yes" xml:space="preserve">
          <source>Most of the time, all this moving forward and backtracking happens quickly and searching is fast. There are some pathological regexps, however, whose execution time exponentially grows with the size of the string. A typical structure that blows up in your face is of the form</source>
          <target state="translated">대부분의 경우,이 모든 앞뒤 추적은 빠르게 수행되며 검색이 빠릅니다. 그러나 문자열의 크기에 따라 실행 시간이 기하 급수적으로 증가하는 병리학 적 정규 표현식이 있습니다. 당신의 얼굴에 날리는 전형적인 구조는</target>
        </trans-unit>
        <trans-unit id="e77fec64b4c635ea20e1b59e3b7d5f77ce28d8e0" translate="yes" xml:space="preserve">
          <source>Most of the time, output from the C routine can be handled through use of the RETVAL and OUTPUT directives. However, there are some cases where the argument stack is not already long enough to handle all the return values. An example is the POSIX tzname() call, which takes no arguments, but returns two, the local time zone's standard and summer time abbreviations.</source>
          <target state="translated">대부분의 경우 C 루틴의 출력은 RETVAL 및 OUTPUT 지시문을 사용하여 처리 할 수 ​​있습니다. 그러나 인수 스택이 이미 모든 반환 값을 처리하기에 충분히 길지 않은 경우가 있습니다. 예를 들어 POSIX tzname () 호출은 인수를 사용하지 않지만 현지 시간대의 표준 및 서머 타임 약어 인 두 개를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4cf605ff0085f7cdb0263cf668764df45a3b6647" translate="yes" xml:space="preserve">
          <source>Most of the time, the default behavior is what is wanted, but &lt;code&gt;//s&lt;/code&gt; and &lt;code&gt;//m&lt;/code&gt; are occasionally very useful. If &lt;code&gt;//m&lt;/code&gt; is being used, the start of the string can still be matched with &lt;code&gt;\A&lt;/code&gt; and the end of the string can still be matched with the anchors &lt;code&gt;\Z&lt;/code&gt; (matches both the end and the newline before, like &lt;code&gt;$&lt;/code&gt; ), and &lt;code&gt;\z&lt;/code&gt; (matches only the end):</source>
          <target state="translated">대부분의 경우 기본 동작은 원하는 것이지만 &lt;code&gt;//s&lt;/code&gt; 및 &lt;code&gt;//m&lt;/code&gt; 은 종종 매우 유용합니다. 경우 &lt;code&gt;//m&lt;/code&gt; 을 사용하고, 문자열의 시작은 여전히 일치 될 수있다 &lt;code&gt;\A&lt;/code&gt; 와 문자열의 끝은 여전히 앵커와 일치 할 수있다 &lt;code&gt;\Z&lt;/code&gt; (경기 끝에 모두와 같은 전에 줄 바꿈, &lt;code&gt;$&lt;/code&gt; ), 및 &lt;code&gt;\z&lt;/code&gt; (끝과 만 일치) :</target>
        </trans-unit>
        <trans-unit id="12fd6c425f6aad23df3156037ea683dfee498467" translate="yes" xml:space="preserve">
          <source>Most of the time, the longest possible text that does not include spaces between components and which contains matching braces or brackets. because the outcome may be determined by voting based on heuristic estimators, the result is not strictly predictable. Fortunately, it's usually correct for ambiguous cases.</source>
          <target state="translated">대부분의 경우 구성 요소 사이에 공백이없고 일치하는 중괄호 또는 대괄호가 포함 된 가장 긴 텍스트입니다. 휴리스틱 추정기를 기반으로 한 투표로 결과를 결정할 수 있기 때문에 결과를 정확하게 예측할 수있는 것은 아닙니다. 다행히도 모호한 경우에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="faff5fae267b68e66a542eebf06c3a2fb20f6315" translate="yes" xml:space="preserve">
          <source>Most of the time, though, you'll want to be dealing with SVs internally instead of raw &lt;code&gt;char *&lt;/code&gt; strings:</source>
          <target state="translated">그러나 대부분의 경우 원시 &lt;code&gt;char *&lt;/code&gt; 문자열 대신 내부적으로 SV를 처리하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="e3da35f6fb8f67dff58b56670aaa5e754c6ece5e" translate="yes" xml:space="preserve">
          <source>Most of the time, you shouldn't care what package an object is blessed into, however, as long as it claims to inherit from that class:</source>
          <target state="translated">대부분의 경우 객체가 클래스에서 상속되었다고 주장하는 한 객체가 어떤 패키지에 축복되는지는 신경 쓰지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="70ed3f1e9ec3872fc596a127d78b3433084d76ac" translate="yes" xml:space="preserve">
          <source>Most of the time, you will need only a single set of angle brackets to delimit the beginning and end of formatting codes. However, sometimes you will want to put a real right angle bracket (a greater-than sign, '&amp;gt;') inside of a formatting code. This is particularly common when using a formatting code to provide a different font-type for a snippet of code. As with all things in Perl, there is more than one way to do it. One way is to simply escape the closing bracket using an &lt;code&gt;E&lt;/code&gt; code:</source>
          <target state="translated">대부분의 경우 서식 코드의 시작과 끝을 구분하기 위해 단일 꺾쇠 괄호 세트 만 있으면됩니다. 그러나 때로는 서식 코드 안에 실제 직각 괄호 ( '&amp;gt;'보다 큰 부호)를 넣고 싶을 수도 있습니다. 서식 코드를 사용하여 코드 스 니펫에 다른 글꼴 유형을 제공 할 때 특히 일반적입니다. Perl의 모든 작업과 마찬가지로 여러 가지 방법이 있습니다. 한 가지 방법은 &lt;code&gt;E&lt;/code&gt; 코드를 사용하여 닫는 대괄호를 간단히 이스케이프하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="724a76b549a2e76bc9ab35aacf508ff92c207228" translate="yes" xml:space="preserve">
          <source>Most of these are self-explanatory, but &lt;code&gt;*foo{IO}&lt;/code&gt; deserves special attention. It returns the IO handle, used for file handles (&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;), sockets (&lt;a href=&quot;functions/socket&quot;&gt;socket&lt;/a&gt; and &lt;a href=&quot;functions/socketpair&quot;&gt;socketpair&lt;/a&gt;), and directory handles (&lt;a href=&quot;functions/opendir&quot;&gt;opendir&lt;/a&gt;). For compatibility with previous versions of Perl, &lt;code&gt;*foo{FILEHANDLE}&lt;/code&gt; is a synonym for &lt;code&gt;*foo{IO}&lt;/code&gt; , though it is deprecated as of 5.8.0. If deprecation warnings are in effect, it will warn of its use.</source>
          <target state="translated">이들 중 대부분은 설명이 필요하지만 &lt;code&gt;*foo{IO}&lt;/code&gt; 특별한주의가 필요합니다. 파일 핸들 ( &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; ), 소켓 ( &lt;a href=&quot;functions/socket&quot;&gt;socket&lt;/a&gt; 및 &lt;a href=&quot;functions/socketpair&quot;&gt;socketpair&lt;/a&gt; ) 및 디렉토리 핸들 ( &lt;a href=&quot;functions/opendir&quot;&gt;opendir&lt;/a&gt; )에 사용되는 IO 핸들을 리턴합니다 . 이전 버전의 Perl과의 호환성을 위해 &lt;code&gt;*foo{FILEHANDLE}&lt;/code&gt; 은 &lt;code&gt;*foo{IO}&lt;/code&gt; 와 동의어 이지만 5.8.0부터 사용되지 않습니다. 사용 중단 경고가 유효하면 사용 경고를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="869a6315acbbfb1f37efec8298474bbe72ca1495" translate="yes" xml:space="preserve">
          <source>Most of these books are available online through Safari Books Online ( &lt;a href=&quot;http://safaribooksonline.com/&quot;&gt;http://safaribooksonline.com/&lt;/a&gt; ).</source>
          <target state="translated">이 책들은 대부분 Safari Books Online ( &lt;a href=&quot;http://safaribooksonline.com/&quot;&gt;http://safaribooksonline.com/&lt;/a&gt; )을 통해 온라인으로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="6b1e0ab2dbc899b58b14484449b9fa1ef61ed05b" translate="yes" xml:space="preserve">
          <source>Most of these examples taken from the current edition of the &amp;ldquo;Camel Book&amp;rdquo;; that is, from the 4ᵗʰ Edition of</source>
          <target state="translated">이 예제의 대부분은 최신판&amp;ldquo;Camel Book&amp;rdquo;에서 발췌 한 것입니다. 즉, 4ᵗʰ Edition의</target>
        </trans-unit>
        <trans-unit id="d786698e017d5ef7ad504f1d9efc84667a246c11" translate="yes" xml:space="preserve">
          <source>Most of these macros are explained in &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;, and some of the more important ones are explained in &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; as well. Pay special attention to &lt;a href=&quot;perlguts#Background-and-PERL_IMPLICIT_CONTEXT&quot;&gt;Background and PERL_IMPLICIT_CONTEXT in perlguts&lt;/a&gt; for information on the &lt;code&gt;[pad]THX_?&lt;/code&gt; macros.</source>
          <target state="translated">이 매크로의 대부분은에 설명되어 있습니다 &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; , 그리고 더 중요한 것들 중 일부에 설명되어 있습니다 &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; 뿐만 아니라. &lt;code&gt;[pad]THX_?&lt;/code&gt; 에 대한 정보 &lt;a href=&quot;perlguts#Background-and-PERL_IMPLICIT_CONTEXT&quot;&gt;는 perlguts의 Background 및 PERL_IMPLICIT_CONTEXT에&lt;/a&gt; 특별한주의를 기울이시겠습니까? 매크로.</target>
        </trans-unit>
        <trans-unit id="f6321c8bc65f6128425ae15e80b31cb962b1699f" translate="yes" xml:space="preserve">
          <source>Most of these make up for limitations in the Win9x/nmake command shell. Mostly its lack of &amp;amp;&amp;amp;.</source>
          <target state="translated">이들 대부분은 Win9x / nmake 명령 셸에서 제한 사항을 보완합니다. 주로 &amp;amp;&amp;amp;의 부족.</target>
        </trans-unit>
        <trans-unit id="30b8e48b7b6d88d36a47fc7a0d1827819d55e75f" translate="yes" xml:space="preserve">
          <source>Most of these routines quietly but politely return &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when they fail instead of causing your program to die right then and there due to an uncaught exception. (Actually, some of the new</source>
          <target state="translated">이러한 루틴의 대부분은 조용하지만 공손하게 예외가 발생하지 않아 프로그램이 바로 죽는 대신 실패 할 경우 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환 합니다. (사실, 새로운</target>
        </trans-unit>
        <trans-unit id="4759d0bf1837078279cedaffe79b3b9844ef0d71" translate="yes" xml:space="preserve">
          <source>Most often, the real question is how you can delete the last N lines without making more than one pass over the file, or how to do it without a lot of copying. The easy concept is the hard reality when you might have millions of lines in your file.</source>
          <target state="translated">실제 질문은 파일을 두 번 이상 통과하지 않고 마지막 N 줄을 삭제하는 방법 또는 많은 복사없이 수행하는 방법입니다. 쉬운 개념은 파일에 수백만 줄이있을 때 어려운 현실입니다.</target>
        </trans-unit>
        <trans-unit id="c39bff964e11a5bf3472bbb0b25d07ba29893372" translate="yes" xml:space="preserve">
          <source>Most paragraphs in your documentation will be ordinary blocks of text, like this one. You can simply type in your text without any markup whatsoever, and with just a blank line before and after. When it gets formatted, it will undergo minimal formatting, like being rewrapped, probably put into a proportionally spaced font, and maybe even justified.</source>
          <target state="translated">문서의 대부분의 단락은 이와 같은 일반적인 텍스트 블록입니다. 마크 업없이 텍스트를 입력하거나 앞뒤로 빈 줄만 입력하면됩니다. 형식이 변경되면 다시 줄 바꿈하거나 비례 간격 글꼴에 넣거나 정당화 할 수있는 것처럼 최소한의 서식이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="758d5aaffea254b4a108f5a7e332dc97c651824c" translate="yes" xml:space="preserve">
          <source>Most people mean that greedy regexes match as much as they can. Technically speaking, it's actually the quantifiers (&lt;code&gt;?&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;{}&lt;/code&gt; ) that are greedy rather than the whole pattern; Perl prefers local greed and immediate gratification to overall greed. To get non-greedy versions of the same quantifiers, use (&lt;code&gt;??&lt;/code&gt; , &lt;code&gt;*?&lt;/code&gt; , &lt;code&gt;+?&lt;/code&gt;, &lt;code&gt;{}?&lt;/code&gt;).</source>
          <target state="translated">대부분의 사람들은 탐욕스러운 정규 표현식이 최대한 일치한다는 것을 의미합니다. 기술적으로 말하면 실제로 전체 패턴이 아닌 욕심 많은 수량 자 ( &lt;code&gt;?&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;{}&lt;/code&gt; )입니다. Perl은 현지 탐욕과 전체 탐욕에 대한 즉각적인 만족을 선호합니다. 같은 한정사, 사용의 비 욕심 버전을 얻으려면 ( &lt;code&gt;??&lt;/code&gt; , &lt;code&gt;*?&lt;/code&gt; , &lt;code&gt;+?&lt;/code&gt; , &lt;code&gt;{}?&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d247005e28d9890e433308bb61b16e11eb364199" translate="yes" xml:space="preserve">
          <source>Most people try to use the time rather than the calendar to figure out dates, but that assumes that days are twenty-four hours each. For most people, there are two days a year when they aren't: the switch to and from summer time throws this off. For example, the rest of the suggestions will be wrong sometimes:</source>
          <target state="translated">대부분의 사람들은 날짜를 알아 내기 위해 달력이 아닌 시간을 사용하려고하지만 날짜는 각각 24 시간이라고 가정합니다. 대부분의 사람들에게는 1 년에 2 일이 있습니다. 여름철로의 전환과 여름철의 전환으로 인해이 문제가 발생합니다. 예를 들어, 나머지 제안은 때때로 잘못된 것입니다.</target>
        </trans-unit>
        <trans-unit id="07b59a28d545dc68a00653586a9af9908a625c7c" translate="yes" xml:space="preserve">
          <source>Most platforms these days structure files in a hierarchical fashion. So, it is reasonably safe to assume that all platforms support the notion of a &quot;path&quot; to uniquely identify a file on the system. How that path is really written, though, differs considerably.</source>
          <target state="translated">요즘 대부분의 플랫폼은 파일을 계층 적으로 구성합니다. 따라서 모든 플랫폼이 시스템에서 파일을 고유하게 식별하기 위해 &quot;경로&quot;개념을 지원한다고 가정하는 것이 합리적입니다. 그러나 그 경로가 실제로 어떻게 쓰여지는가는 상당히 다릅니다.</target>
        </trans-unit>
        <trans-unit id="f5162bd3aaf5f209ead52eacd74062b771e3c04c" translate="yes" xml:space="preserve">
          <source>Most probably the most convenient form. Under OS/2 view it as</source>
          <target state="translated">아마도 가장 편리한 형태 일 것입니다. OS / 2에서</target>
        </trans-unit>
        <trans-unit id="b3219374aa50766aeb504023a6090322d39aaeb1" translate="yes" xml:space="preserve">
          <source>Most problems with &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt; arise because the programmer thinks they have a number but really it's a string or vice versa. To avoid this, stringify the arguments explicitly (using &lt;code&gt;&quot;&quot;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq()&lt;/a&gt;&lt;/code&gt;) or convert them to numbers explicitly (using &lt;code&gt;0+$arg&lt;/code&gt; ). The rest arise because the programmer says:</source>
          <target state="translated">&lt;code&gt;&amp;amp;&lt;/code&gt; 와 대부분의 문제 &lt;code&gt;|&lt;/code&gt; 프로그래머가 숫자가 있다고 생각하기 때문에 발생하지만 실제로는 문자열이거나 그 반대입니다. 이를 피하려면 인수를 명시 적 으로 문자열 화하거나 &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&quot;&quot;&lt;/code&gt; 또는 qq () 사용) 인수를 명시 적 으로 숫자로 변환하십시오 ( &lt;code&gt;0+$arg&lt;/code&gt; ). 나머지는 프로그래머가 말하기 때문에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="97498d9b162518efa835ea3e4a21ab0beffd2067" translate="yes" xml:space="preserve">
          <source>Most programming languages don't shelter the memory where variables are stored. In C, for instance, you can take the address of some variable, and the &lt;code&gt;sizeof&lt;/code&gt; operator tells you how many bytes are allocated to the variable. Using the address and the size, you may access the storage to your heart's content.</source>
          <target state="translated">대부분의 프로그래밍 언어는 변수가 저장된 메모리를 보호하지 않습니다. 예를 들어 C에서는 일부 변수의 주소를 사용할 수 있으며 &lt;code&gt;sizeof&lt;/code&gt; 연산자는 변수에 할당 된 바이트 수를 알려줍니다. 주소와 크기를 사용하여 마음의 내용물을 보관할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="098186d7a29b8f65f8c838a2e5b2830d1de6af62" translate="yes" xml:space="preserve">
          <source>Most properties match the same code points regardless of whether &lt;code&gt;&quot;/i&quot;&lt;/code&gt; case-insensitive matching is specified or not. But a few properties are affected. These are shown with the notation &lt;code&gt;(/i= &lt;i&gt;other_property&lt;/i&gt;)&lt;/code&gt; in the second column. Under case-insensitive matching they match the same code pode points as the property</source>
          <target state="translated">대 &lt;code&gt;&quot;/i&quot;&lt;/code&gt; 소문자를 구분하지 않는 &quot;/ i&quot; 일치 여부에 관계없이 대부분의 속성은 동일한 코드 포인트와 일치합니다. 그러나 몇 가지 속성이 영향을받습니다. 이들은 두 번째 열에 표기법 &lt;code&gt;(/i= &lt;i&gt;other_property&lt;/i&gt;)&lt;/code&gt; 과 함께 표시 됩니다. 대소 문자를 구분하지 않는 일치 하에서 속성과 동일한 코드 포드 포인트와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="7ea7b30461e5f88919bb6524b261e1fbc23c8866" translate="yes" xml:space="preserve">
          <source>Most scripts should print some type of usage message to &lt;code&gt;STDERR&lt;/code&gt; when a command line syntax error is detected. They should also provide an option (usually &lt;code&gt;-H&lt;/code&gt; or &lt;code&gt;-help&lt;/code&gt; ) to print a (possibly more verbose) usage message to &lt;code&gt;STDOUT&lt;/code&gt; . Some scripts may even wish to go so far as to provide a means of printing their complete documentation to &lt;code&gt;STDOUT&lt;/code&gt; (perhaps by allowing a &lt;code&gt;-man&lt;/code&gt; option). The following complete example uses &lt;b&gt;Pod::Usage&lt;/b&gt; in combination with &lt;b&gt;Getopt::Long&lt;/b&gt; to do all of these things:</source>
          <target state="translated">대부분의 스크립트는 명령 행 구문 오류가 감지 될 때 일부 유형의 사용 메시지를 &lt;code&gt;STDERR&lt;/code&gt; 에 인쇄해야합니다 . 또한 사용 메시지를 &lt;code&gt;STDOUT&lt;/code&gt; 에 인쇄 하는 옵션 (보통 &lt;code&gt;-H&lt;/code&gt; 또는 &lt;code&gt;-help&lt;/code&gt; )을 제공해야합니다 . 일부 스크립트는 완전한 문서를 &lt;code&gt;STDOUT&lt;/code&gt; 에 인쇄 할 수있는 수단을 제공 할 수도 있습니다 (아마도 &lt;code&gt;-man&lt;/code&gt; 옵션 허용 ). 다음 예제에서는 &lt;b&gt;Pod :: Usage&lt;/b&gt; 를 &lt;b&gt;Getopt :: Long&lt;/b&gt; 과 함께 &lt;b&gt;사용&lt;/b&gt; 하여 이러한 모든 작업을 수행합니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2986b3da9e25c6ac2c76862bdb207bac32623aca" translate="yes" xml:space="preserve">
          <source>Most sequences are described in detail in different documents; the primary purpose of this document is to have a quick reference guide describing all backslash and escape sequences.</source>
          <target state="translated">대부분의 시퀀스는 다른 문서에 자세히 설명되어 있습니다. 이 문서의 주요 목적은 모든 백 슬래시 및 이스케이프 시퀀스를 설명하는 빠른 참조 안내서를 보유하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6cf7387c1ea7a96beacd0b59cccd9572dbbcde67" translate="yes" xml:space="preserve">
          <source>Most sites usually disable this feature in their SMTP service configuration. Use &quot;Debug =&amp;gt; 1&quot; option under new() to see if disabled.</source>
          <target state="translated">대부분의 사이트는 일반적으로 SMTP 서비스 구성에서이 기능을 비활성화합니다. new ()에서 &quot;Debug =&amp;gt; 1&quot;옵션을 사용하여 비활성화되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="805a1b088f4235fc8495203b21cfd64c3f92735f" translate="yes" xml:space="preserve">
          <source>Most socket programming assumes ASCII character encodings in network byte order. Exceptions can include CGI script writing under a host web server where the server may take care of translation for you. Most host web servers convert EBCDIC data to ISO-8859-1 or Unicode on output.</source>
          <target state="translated">대부분의 소켓 프로그래밍은 ASCII 문자 인코딩을 네트워크 바이트 순서로 가정합니다. 서버가 번역을 담당 할 수있는 호스트 웹 서버에서 CGI 스크립트 작성이 예외 일 수 있습니다. 대부분의 호스트 웹 서버는 EBCDIC 데이터를 ISO-8859-1 또는 출력시 유니 코드로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="29ff99325371b7f580464c1d1eca725c963c97f2" translate="yes" xml:space="preserve">
          <source>Most software projects begin each file with a literal description of each file's purpose. Perl instead begins each with a literary allusion to that file's purpose.</source>
          <target state="translated">대부분의 소프트웨어 프로젝트는 각 파일의 목적에 대한 문자 설명으로 각 파일을 시작합니다. 펄은 대신 그 파일의 목적에 대한 문학적 암시로 시작한다.</target>
        </trans-unit>
        <trans-unit id="db6c865df11697d9eda20f45a2680b42a8a01010" translate="yes" xml:space="preserve">
          <source>Most source code ceases to be grammatically correct when it is broken up into the pieces between string literals and regexes. So the &lt;code&gt;'code'&lt;/code&gt; and &lt;code&gt;'code_no_comments'&lt;/code&gt; component filter behave slightly differently from the other partial filters described in the previous section.</source>
          <target state="translated">대부분의 소스 코드는 문자열 리터럴과 정규 표현식 사이의 조각으로 나눌 때 문법적으로 정확하지 않습니다. 따라서 &lt;code&gt;'code'&lt;/code&gt; 및 &lt;code&gt;'code_no_comments'&lt;/code&gt; 구성 요소 필터는 이전 섹션에서 설명한 다른 부분 필터와 약간 다르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="335be1d7a3acfa7558b1ff815c489a483910fb62" translate="yes" xml:space="preserve">
          <source>Most subroutines documented in this module have equivalent versions that operate on references to hashes instead of native hashes. The following is a list of these subs. They are identical except in name and in that instead of taking a %hash they take a $hashref, and additionally are not prototyped.</source>
          <target state="translated">이 모듈에 문서화 된 대부분의 서브 루틴에는 기본 해시 대신 해시에 대한 참조에서 작동하는 동등한 버전이 있습니다. 다음은 이러한 하위 목록입니다. 그것들은 이름을 제외하고 동일하며 % hash 대신 $ hashref를 취하고 추가적으로 프로토 타입이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="673b355050421a0f250c2913c779df1badafbdd4" translate="yes" xml:space="preserve">
          <source>Most systems do not bother to return anything useful in $timeleft, so calling select() in scalar context just returns $nfound.</source>
          <target state="translated">대부분의 시스템은 $ timeleft에 유용한 것을 반환하지 않으므로 스칼라 컨텍스트에서 select ()를 호출하면 $ nfound 만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f4be0e0cacadb003a014aeecaa66260a81fb37a7" translate="yes" xml:space="preserve">
          <source>Most tasks only require a small subset of the Perl language. One of the guiding mottos for Perl development is &quot;there's more than one way to do it&quot; (TMTOWTDI, sometimes pronounced &quot;tim toady&quot;). Perl's learning curve is therefore shallow (easy to learn) and long (there's a whole lot you can do if you really want).</source>
          <target state="translated">대부분의 작업에는 작은 Perl 언어 하위 집합 만 필요합니다. Perl 개발을위한 모토 중 하나는 &quot;한 가지 이상의 방법이있다&quot;(TMTOWTDI, 때로는 &quot;tim toady&quot;라고 발음 함)이다. 따라서 Perl의 학습 곡선은 얕고 (배우기 쉬움) 길다 (실제로 원한다면 할 수있는 것이 많이있다).</target>
        </trans-unit>
        <trans-unit id="bb6ff5de9e8fc03a10f36de6d162848c70fb3768" translate="yes" xml:space="preserve">
          <source>Most useful when you can't depend on the test output order, such as when threads or forking is involved.</source>
          <target state="translated">스레드 또는 포킹과 같은 테스트 출력 순서에 의존 할 수 없을 때 가장 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d352875a4c7ac21070cf3a1cd4743c30a9c2d0b1" translate="yes" xml:space="preserve">
          <source>Mount a different file system structure without changing login or accounting information.</source>
          <target state="translated">로그인 또는 계정 정보를 변경하지 않고 다른 파일 시스템 구조를 마운트하십시오.</target>
        </trans-unit>
        <trans-unit id="b9c654f6de08d2f23a43dc1905efaf207281f877" translate="yes" xml:space="preserve">
          <source>Move on to the second group and pick the first alternative 'df'.</source>
          <target state="translated">두 번째 그룹으로 이동하여 첫 번째 대체 'df'를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="656251711514e69bd101328e64271cab684cd5f2" translate="yes" xml:space="preserve">
          <source>Move on to the third element '.*'. Since we are at the end of the string and '.*' can match 0 times, assign it the empty string.</source>
          <target state="translated">세 번째 요소 '. *'로 이동하십시오. 문자열의 끝에 있고 '. *'는 0 번 일치 할 수 있으므로 빈 문자열을 할당하십시오.</target>
        </trans-unit>
        <trans-unit id="a05a5599f4ff1f6f057b4c325aeb15095e59f574" translate="yes" xml:space="preserve">
          <source>Move the file's read/write position. This uses file descriptors such as those obtained by calling &lt;code&gt;POSIX::open&lt;/code&gt; .</source>
          <target state="translated">파일의 읽기 / 쓰기 위치를 이동하십시오. &lt;code&gt;POSIX::open&lt;/code&gt; 을 호출하여 얻은 것과 같은 파일 디스크립터를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="e2278daf64913fd58204056d82689681803a8cd5" translate="yes" xml:space="preserve">
          <source>Moved from Perl 5.10.1 to CPAN</source>
          <target state="translated">Perl 5.10.1에서 CPAN으로 이동</target>
        </trans-unit>
        <trans-unit id="99a21ee175eac25359a901bcbda82fe551ce8663" translate="yes" xml:space="preserve">
          <source>Moved from Perl 5.9.0 to CPAN</source>
          <target state="translated">Perl 5.9.0에서 CPAN으로 이동</target>
        </trans-unit>
        <trans-unit id="5de42d916e82311c864672d75f077c9b2068801a" translate="yes" xml:space="preserve">
          <source>Moved out of &lt;a href=&quot;../parser&quot;&gt;TAP::Parser&lt;/a&gt; &amp;amp; converted to a factory class to support extensible TAP source detective work by Steve Purkis.</source>
          <target state="translated">Steve Purkis 의 &lt;a href=&quot;../parser&quot;&gt;TAP :: Parser에서&lt;/a&gt; 벗어나 TAP 소스 탐사 작업을 지원하기 위해 팩토리 클래스로 변환했습니다.</target>
        </trans-unit>
        <trans-unit id="06473ac4424aa3537730dc5fa59fd056a6719bfb" translate="yes" xml:space="preserve">
          <source>Moved to Changes file.</source>
          <target state="translated">변경 파일로 이동했습니다.</target>
        </trans-unit>
        <trans-unit id="a36390af19221c7ada243c00a81cdf9c9fd9cb46" translate="yes" xml:space="preserve">
          <source>Moved to the Changes file.</source>
          <target state="translated">변경 파일로 이동했습니다.</target>
        </trans-unit>
        <trans-unit id="04735508f82cd9b0551e1cf6d2f2c73c1c36e575" translate="yes" xml:space="preserve">
          <source>Moves source to destination. Multiple sources are allowed if destination is an existing directory.</source>
          <target state="translated">소스를 대상으로 이동합니다. 대상이 기존 디렉토리 인 경우 여러 소스가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="65cd4dd8114610f7bacc1f81bb9dd01a137f162f" translate="yes" xml:space="preserve">
          <source>Moving</source>
          <target state="translated">Moving</target>
        </trans-unit>
        <trans-unit id="b43ac9463df3e2d50948534cdbda94703301864a" translate="yes" xml:space="preserve">
          <source>Much better!</source>
          <target state="translated">훨씬 낫다!</target>
        </trans-unit>
        <trans-unit id="baae2905164a527d46c5511d6f6cde4ac79fa8cd" translate="yes" xml:space="preserve">
          <source>Multi-argument form of &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; allows an additional numeric argument. The meaning of this argument is described in &lt;a href=&quot;http://search.cpan.org/perldoc/OS2::Process&quot;&gt;OS2::Process&lt;/a&gt;.</source>
          <target state="translated">다중 인수 형식의 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 은 추가 숫자 인수를 허용합니다. 이 인수의 의미는 &lt;a href=&quot;http://search.cpan.org/perldoc/OS2::Process&quot;&gt;OS2 :: Process에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9857028e641dc5456ee948176f4473c16db09596" translate="yes" xml:space="preserve">
          <source>Multi-dimensional array emulation</source>
          <target state="translated">다차원 배열 에뮬레이션</target>
        </trans-unit>
        <trans-unit id="8f531e0d77ec76c8767bb9e4fb3934a040894292" translate="yes" xml:space="preserve">
          <source>Multicall Functions</source>
          <target state="translated">다중 호출 기능</target>
        </trans-unit>
        <trans-unit id="e0f46258b912e10d35fd5082f358a2c20442fe00" translate="yes" xml:space="preserve">
          <source>Multidimensional arrays may be emulated by subscripting a hash with a list. The elements of the list are joined with the subscript separator (see &lt;a href=&quot;perlvar#%24%3b&quot;&gt;$; in perlvar&lt;/a&gt;).</source>
          <target state="translated">다차원 배열은 목록으로 해시를 첨자 화하여 에뮬레이션 할 수 있습니다. 목록의 요소는 첨자 구분 기호와 결합됩니다 ( &lt;a href=&quot;perlvar#%24%3b&quot;&gt;$; perlvar&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="66f96f856d2f7161b69ace4cbe667d2f05f5d119" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declarations with the same name in the same lexical scope are allowed if they are in different packages. If they happen to be in the same package, Perl will emit warnings if you have asked for them, just like multiple &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; declarations. Unlike a second &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; declaration, which will bind the name to a fresh variable, a second &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration in the same package, in the same scope, is merely redundant.</source>
          <target state="translated">여러 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 서로 다른 패키지에있는 경우 같은 어휘 범위에서 같은 이름의 선언이 허용됩니다. 그들은 같은 패키지에 될 일 경우, 펄은 당신이 그들을 요구 한 경우, 경고를 방출 단지 복수와 같은 것입니다 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 선언. 두 번째는 달리 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; , 새로운 변수에 두 번째 이름을 바인딩 선언, &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 같은 패키지에 선언을, 같은 범위에서, 단순히 중복입니다.</target>
        </trans-unit>
        <trans-unit id="9985bd0ec5a4c016728a57fca407ec3ba9776cda" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declarations with the same name in the same lexical scope are allowed if they are in different packages. If they happen to be in the same package, Perl will emit warnings if you have asked for them, just like multiple &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; declarations. Unlike a second &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; declaration, which will bind the name to a fresh variable, a second &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration in the same package, in the same scope, is merely redundant.</source>
          <target state="translated">여러 &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 서로 다른 패키지에있는 경우 같은 어휘 범위에서 같은 이름의 선언이 허용됩니다. 그들은 같은 패키지에 될 일 경우, 펄은 당신이 그들을 요구 한 경우, 경고를 방출 단지 복수와 같은 것입니다 &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 선언. 두 번째는 달리 &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; , 새로운 변수에 두 번째 이름을 바인딩 선언, &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 같은 패키지에 선언을, 같은 범위에서, 단순히 중복입니다.</target>
        </trans-unit>
        <trans-unit id="48353bd1f51bb6eec720b26a40670dcc8efa9d3b" translate="yes" xml:space="preserve">
          <source>Multiple Inheritance</source>
          <target state="translated">다중 상속</target>
        </trans-unit>
        <trans-unit id="cbb8ace32d78b2ae6f01fe57c603e73837a4bd68" translate="yes" xml:space="preserve">
          <source>Multiple alternate names are possible.</source>
          <target state="translated">여러 개의 대체 이름이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="3b26a054b05093a88178030f5a8b1997575b74ff" translate="yes" xml:space="preserve">
          <source>Multiple constant declarations at once added by Casey West, &amp;lt;</source>
          <target state="translated">Casey West에 의해 한 번에 여러 개의 상수 선언이 추가됨, &amp;lt;</target>
        </trans-unit>
        <trans-unit id="285ddce39862d8fe5e23d4388af8d0a347056a9c" translate="yes" xml:space="preserve">
          <source>Multiple inheritance often indicates a design problem, but Perl always gives you enough rope to hang yourself with if you ask for it.</source>
          <target state="translated">다중 상속은 종종 디자인 문제를 나타내지 만 Perl은 요청하면 항상 매달릴 수있는 충분한 로프를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0d9f2a08980cf6a269a8484f3b1b84e9a908ab93" translate="yes" xml:space="preserve">
          <source>Multiple options may be separated by colons:</source>
          <target state="translated">콜론으로 여러 옵션을 구분할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="711c51a111027364db7380ccd9acdaec1492d123" translate="yes" xml:space="preserve">
          <source>Multiple packages</source>
          <target state="translated">여러 패키지</target>
        </trans-unit>
        <trans-unit id="e5cb4101d607c5394d01741bac5f7456e4908d11" translate="yes" xml:space="preserve">
          <source>Multiple packages and fully qualified subroutine names</source>
          <target state="translated">여러 패키지 및 완전한 서브 루틴 이름</target>
        </trans-unit>
        <trans-unit id="f6459b694c217e7d6e4f4403e095b344a4a592d8" translate="yes" xml:space="preserve">
          <source>Multiplex multiple TAP::Parsers</source>
          <target state="translated">다중 다중 TAP :: 파서</target>
        </trans-unit>
        <trans-unit id="150be49d038f614e193602a7005597f5ff875ec0" translate="yes" xml:space="preserve">
          <source>Multiplicative Operators</source>
          <target state="translated">곱하기 연산자</target>
        </trans-unit>
        <trans-unit id="f231b68e224950ab7816fb6e20b4d2a930d3893b" translate="yes" xml:space="preserve">
          <source>Multiplicity is required when embedding Perl in a C program and using more than one interpreter instance. This is only required when you build a not-threaded perl with &lt;code&gt;-Uuseithreads&lt;/code&gt; .</source>
          <target state="translated">C 프로그램에 Perl을 임베드하고 둘 이상의 인터프리터 인스턴스를 사용하는 경우 다중성이 필요합니다. 이것은 &lt;code&gt;-Uuseithreads&lt;/code&gt; 로 스레드되지 않은 펄을 빌드 할 때만 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="c164249090c5dcf176539a56868115da2c726290" translate="yes" xml:space="preserve">
          <source>Multiply $x by $y, and then add $z to the result,</source>
          <target state="translated">$ x에 $ y를 곱한 다음 결과에 $ z를 더하십시오.</target>
        </trans-unit>
        <trans-unit id="ccb1f5d6ba5d2943ea716c8d09ca6acbfac04509" translate="yes" xml:space="preserve">
          <source>Multiply $x by $y, and then add $z to the result.</source>
          <target state="translated">$ x에 $ y를 곱한 다음 결과에 $ z를 더하십시오.</target>
        </trans-unit>
        <trans-unit id="ee25591d06b217f4358e8b341dce8e1906aeef44" translate="yes" xml:space="preserve">
          <source>Multiprocessor kernel threads are the final step in thread support. With multiprocessor kernel threads on a machine with multiple CPUs, the OS may schedule two or more threads to run simultaneously on different CPUs.</source>
          <target state="translated">멀티 프로세서 커널 스레드는 스레드 지원의 마지막 단계입니다. 여러 개의 CPU가있는 머신에서 다중 프로세서 커널 스레드를 사용하면 OS가 두 개 이상의 스레드가 다른 CPU에서 동시에 실행되도록 예약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aafd5d404242155cb8650eca5e234b7aeedd750b" translate="yes" xml:space="preserve">
          <source>Must be passed an array reference.</source>
          <target state="translated">배열 참조를 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="d8387835af5df8bfeb3d9299ef8165454a3d981d" translate="yes" xml:space="preserve">
          <source>Mustn't forget to change the number of tests which appears at the top, or else the automated tester will get confused. This will either look like this:</source>
          <target state="translated">맨 위에 표시되는 테스트 수를 변경해야합니다. 그렇지 않으면 자동화 된 테스터가 혼동됩니다. 이것은 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="4fdcdee602cc75b045989a2d406d8d4ffd6c037c" translate="yes" xml:space="preserve">
          <source>My personal recommendation, out of respect for Larry, Perl, and the Perl community at large is to state something simply like:</source>
          <target state="translated">Larry, Perl 및 Perl 커뮤니티에 대한 저의 개인적인 추천은 다음과 같이 간단하게 진술하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="748a895bf6724a550c8c67860c94e7094d972f64" translate="yes" xml:space="preserve">
          <source>My subclasses: &lt;a href=&quot;pullparserstarttoken&quot;&gt;Pod::Simple::PullParserStartToken&lt;/a&gt;, &lt;a href=&quot;pullparsertexttoken&quot;&gt;Pod::Simple::PullParserTextToken&lt;/a&gt;, and &lt;a href=&quot;pullparserendtoken&quot;&gt;Pod::Simple::PullParserEndToken&lt;/a&gt;.</source>
          <target state="translated">내 하위 클래스 : &lt;a href=&quot;pullparserstarttoken&quot;&gt;Pod :: Simple :: PullParserStartToken&lt;/a&gt; , &lt;a href=&quot;pullparsertexttoken&quot;&gt;Pod :: Simple :: PullParserTextToken&lt;/a&gt; 및 &lt;a href=&quot;pullparserendtoken&quot;&gt;Pod :: Simple :: PullParserEndToken&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2dc204f1e0858a7337033f5946b1dc262a92ffcd" translate="yes" xml:space="preserve">
          <source>MyModule</source>
          <target state="translated">MyModule</target>
        </trans-unit>
        <trans-unit id="97ad397eea0be3e1f89ac813a16d43595116bd1c" translate="yes" xml:space="preserve">
          <source>Myclass::Subclass</source>
          <target state="translated">Myclass::Subclass</target>
        </trans-unit>
        <trans-unit id="c6940a4c07e595b424fa7842373c9f33f87cd575" translate="yes" xml:space="preserve">
          <source>Myinit.U</source>
          <target state="translated">Myinit.U</target>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">N</target>
        </trans-unit>
        <trans-unit id="9a47348ab82eb6d6bab23d474edae2c5c05217c3" translate="yes" xml:space="preserve">
          <source>N scalars leaked</source>
          <target state="translated">N 스칼라 유출</target>
        </trans-unit>
        <trans-unit id="5a5f7af20c8e39658565746ad27f9a6866756694" translate="yes" xml:space="preserve">
          <source>N. B.</source>
          <target state="translated">NB</target>
        </trans-unit>
        <trans-unit id="a1288af793f71d98bd1d7968a0996780aa30d8e3" translate="yes" xml:space="preserve">
          <source>N.B. Setting &lt;code&gt;DECC$FILENAME_UNIX_REPORT&lt;/code&gt; implicitly enables &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; .</source>
          <target state="translated">NB &lt;code&gt;DECC$FILENAME_UNIX_REPORT&lt;/code&gt; 설정 하면 &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; 가 내재적으로 활성화 됩니다 .</target>
        </trans-unit>
        <trans-unit id="a9d371451b6909ac85117130b9153a96499a362c" translate="yes" xml:space="preserve">
          <source>NAME</source>
          <target state="translated">NAME</target>
        </trans-unit>
        <trans-unit id="4c53abfad1785f59a4ee14505ad91b4508658ce7" translate="yes" xml:space="preserve">
          <source>NAME is the top-level namespace of your module. VERSION_FROM is the file which contains the $VERSION variable for the entire distribution. Typically this is the same as your top-level module.</source>
          <target state="translated">NAME은 모듈의 최상위 네임 스페이스입니다. VERSION_FROM은 전체 배포에 대한 $ VERSION 변수를 포함하는 파일입니다. 일반적으로 이것은 최상위 모듈과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="d81d8c4e29195f73ad2566e9351c6a67f3f09071" translate="yes" xml:space="preserve">
          <source>NAME needn't be the name of a subroutine; it can be a scalar variable containing a code reference or a block that evaluates to a code reference.</source>
          <target state="translated">NAME은 서브 루틴의 이름 일 필요는 없습니다. 코드 참조를 포함하는 스칼라 변수 또는 코드 참조로 평가되는 블록 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1261b44b9791565719eece908fc8aabec59c02c" translate="yes" xml:space="preserve">
          <source>NAMELEN</source>
          <target state="translated">NAMELEN</target>
        </trans-unit>
        <trans-unit id="1cb5d20286de76cb8688a83e567257746c132849" translate="yes" xml:space="preserve">
          <source>NB. (more info on these and others would be appreciated).</source>
          <target state="translated">NB. (이들과 다른 사람들에 대한 자세한 정보는 높이 평가 될 것입니다).</target>
        </trans-unit>
        <trans-unit id="5f010024527e42fccba4ce2404e18f5c69eb9822" translate="yes" xml:space="preserve">
          <source>NB: Extensions that have nothing but *.pm files had to say</source>
          <target state="translated">NB : * .pm 파일 이외의 확장자는</target>
        </trans-unit>
        <trans-unit id="1f7de72c9876d092d89ca69c43c95f07a23bc665" translate="yes" xml:space="preserve">
          <source>NB: This variable must be in the package's symbol table, thus:</source>
          <target state="translated">주의 :이 변수는 패키지의 심볼 테이블에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="7297e43fd27e251c1624e34ebd5bf6e99f4c09b7" translate="yes" xml:space="preserve">
          <source>NBSP</source>
          <target state="translated">NBSP</target>
        </trans-unit>
        <trans-unit id="12f6598371d9f16419b7754d6868d5184ea681b6" translate="yes" xml:space="preserve">
          <source>NDBM_File</source>
          <target state="translated">NDBM_File</target>
        </trans-unit>
        <trans-unit id="d90fc6a608918a70294d6b999fb9f1f64ecfd606" translate="yes" xml:space="preserve">
          <source>NDBM_File - Tied access to ndbm files</source>
          <target state="translated">NDBM_File-ndbm 파일에 대한 액세스 권한</target>
        </trans-unit>
        <trans-unit id="5aae06f9c3e77d522c379b6951fa1408e2490531" translate="yes" xml:space="preserve">
          <source>NDBM_File and ODBM_File do not work on FAT filesystems</source>
          <target state="translated">FAT 파일 시스템에서 NDBM_File 및 ODBM_File이 작동하지 않습니다</target>
        </trans-unit>
        <trans-unit id="a798c3d94cb982cba534a63f36ccc06041d89ff0" translate="yes" xml:space="preserve">
          <source>NDBM_File, DB_File, GDBM_File, SDBM_File, ODBM_File - various DBM implementations</source>
          <target state="translated">NDBM_File, DB_File, GDBM_File, SDBM_File, ODBM_File-다양한 DBM 구현</target>
        </trans-unit>
        <trans-unit id="ac95b5a9cf67180becca6d7616cbe8c2dbd055da" translate="yes" xml:space="preserve">
          <source>NEW to 3.18</source>
          <target state="translated">3.18에 처음</target>
        </trans-unit>
        <trans-unit id="6d7b1945b703be410af2f234b62894cdfab399db" translate="yes" xml:space="preserve">
          <source>NEW to 3.22</source>
          <target state="translated">3.22에 처음</target>
        </trans-unit>
        <trans-unit id="1bd0055e213031c1eb32db565ffd38acb782ca87" translate="yes" xml:space="preserve">
          <source>NEWNAME</source>
          <target state="translated">NEWNAME</target>
        </trans-unit>
        <trans-unit id="1992d5e8d57e780981c364d844480c004ead1bc2" translate="yes" xml:space="preserve">
          <source>NEXT</source>
          <target state="translated">NEXT</target>
        </trans-unit>
        <trans-unit id="b264d41dd1016991ce0cb432539e94a460600e52" translate="yes" xml:space="preserve">
          <source>NEXT LINE and NO-BREAK SPACE may or may not match &lt;code&gt;\s&lt;/code&gt; depending on the rules in effect. See &lt;a href=&quot;#Whitespace&quot;&gt;the beginning of this section&lt;/a&gt;.</source>
          <target state="translated">NEXT LINE 및 NO-BREAK SPACE는 적용되는 규칙에 따라 &lt;code&gt;\s&lt;/code&gt; 와 일치하거나 일치하지 않을 수 있습니다 . &lt;a href=&quot;#Whitespace&quot;&gt;이 섹션의 시작 부분을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="113018ee92aaf6966a4feae636745a050ed016d4" translate="yes" xml:space="preserve">
          <source>NEXT.pm - Provide a pseudo-class NEXT (et al) that allows method redispatch</source>
          <target state="translated">NEXT.pm-메소드 재발 포를 허용하는 의사 클래스 NEXT (et al) 제공</target>
        </trans-unit>
        <trans-unit id="2f9fcb4031e8bf2abe384c4ced588f3eb413318c" translate="yes" xml:space="preserve">
          <source>NEXT.pm adds a pseudoclass named &lt;code&gt;NEXT&lt;/code&gt; to any program that uses it. If a method &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; calls &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt; , the call to &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; is redispatched as if the calling method had not originally been found.</source>
          <target state="translated">NEXT.pm은 &lt;code&gt;NEXT&lt;/code&gt; 라는 의사 클래스 를 사용하는 모든 프로그램에 NEXT 라는 의사 클래스를 추가 합니다. 메소드 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt; 호출하면, 호출 메소드가 원래 발견되지 않은 것처럼 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 에 대한 호출 이 재발신됩니다.</target>
        </trans-unit>
        <trans-unit id="90f3c73aafb4df691799fd406377dadc9780d033" translate="yes" xml:space="preserve">
          <source>NFS filesystems and utime(2) on HP-UX</source>
          <target state="translated">HP-UX의 NFS 파일 시스템 및 utime (2)</target>
        </trans-unit>
        <trans-unit id="33955091f178d2e0b6833a44b9c41c2530abaaef" translate="yes" xml:space="preserve">
          <source>NIST STATEMENT ON SHA-1</source>
          <target state="translated">SHA-1에 대한 NIST 진술</target>
        </trans-unit>
        <trans-unit id="8a32963006e5a121b9fe9a8458d70540a03114d8" translate="yes" xml:space="preserve">
          <source>NIST acknowledges that the work of Prof. Xiaoyun Wang constitutes a practical collision attack on SHA-1. Therefore, NIST encourages the rapid adoption of the SHA-2 hash functions (e.g. SHA-256) for applications requiring strong collision resistance, such as digital signatures.</source>
          <target state="translated">NIST는 Xiaoyun Wang 교수의 연구가 SHA-1에 대한 실질적인 충돌 공격임을 인정합니다. 따라서 NIST는 디지털 서명과 같이 강력한 충돌 저항이 필요한 응용 프로그램에 SHA-2 해시 기능 (예 : SHA-256)을 빠르게 채택 할 것을 권장합니다.</target>
        </trans-unit>
        <trans-unit id="aa7b193ecb5f5e8127c45d86d672c669b4ad311a" translate="yes" xml:space="preserve">
          <source>NNN</source>
          <target state="translated">NNN</target>
        </trans-unit>
        <trans-unit id="259e7beda3cad46f62a7095d7eeef91dfa1452ff" translate="yes" xml:space="preserve">
          <source>NNTP Client class</source>
          <target state="translated">NNTP 클라이언트 클래스</target>
        </trans-unit>
        <trans-unit id="0e091603e3f994d50c190a2d5fd3e5c41973500d" translate="yes" xml:space="preserve">
          <source>NONPERLIO FUNCTIONALITY</source>
          <target state="translated">비 페로 리오 기능</target>
        </trans-unit>
        <trans-unit id="a89019f3be9c018c42adb350f614090da4dc3c7c" translate="yes" xml:space="preserve">
          <source>NORMALIZER</source>
          <target state="translated">NORMALIZER</target>
        </trans-unit>
        <trans-unit id="969e7d8dee132181523a501a068fec75bded3005" translate="yes" xml:space="preserve">
          <source>NOT</source>
          <target state="translated">NOT</target>
        </trans-unit>
        <trans-unit id="c4670e378e0ef3deb0f4049eccb697b77c441ecf" translate="yes" xml:space="preserve">
          <source>NOT Algonquin!</source>
          <target state="translated">알곤 퀸이 아님!</target>
        </trans-unit>
        <trans-unit id="f8e9babf78c2e719cd84e72dad7681487647bef9" translate="yes" xml:space="preserve">
          <source>NOT Amharic! NOT Samaritan Aramaic!</source>
          <target state="translated">암하라 어가 아닙니다! 사마리아 아람이 아닙니다!</target>
        </trans-unit>
        <trans-unit id="753ae89bc9aefd4bc4c59d18e8756509c836fa15" translate="yes" xml:space="preserve">
          <source>NOT Aramaic!</source>
          <target state="translated">아람어 아님!</target>
        </trans-unit>
        <trans-unit id="133f3813e3d37b50fe3b4bc3090b8a682ecfc808" translate="yes" xml:space="preserve">
          <source>NOT Cree!</source>
          <target state="translated">울지마!</target>
        </trans-unit>
        <trans-unit id="4ae987be84fecb4729307de204915c9a99c39e5b" translate="yes" xml:space="preserve">
          <source>NOT Creek! (Formerly &quot;cre&quot;.)</source>
          <target state="translated">크릭이 아닙니다! (이전의 &quot;cre&quot;)</target>
        </trans-unit>
        <trans-unit id="9aa8553630af3827a1d2df27f4500615b8d003a9" translate="yes" xml:space="preserve">
          <source>NOT Dogri!</source>
          <target state="translated">Dogri가 아닙니다!</target>
        </trans-unit>
        <trans-unit id="1a5a67d55f9ca3936956ef4502ba89ff2b34b328" translate="yes" xml:space="preserve">
          <source>NOT Dogrib!</source>
          <target state="translated">도그 립이 아닙니다!</target>
        </trans-unit>
        <trans-unit id="68c49025492a4631abe9ece2f0cd79b5a465f4d6" translate="yes" xml:space="preserve">
          <source>NOT Lahnda!</source>
          <target state="translated">Lahnda가 아닙니다!</target>
        </trans-unit>
        <trans-unit id="3e4ff7d40fd5253a99d44731fd85dd7a075a8d8c" translate="yes" xml:space="preserve">
          <source>NOT Lamba!</source>
          <target state="translated">람바!</target>
        </trans-unit>
        <trans-unit id="bbf0ff26137d6eeee6a5487552177165fd9cd76f" translate="yes" xml:space="preserve">
          <source>NOT Malay!</source>
          <target state="translated">말레이어 아님!</target>
        </trans-unit>
        <trans-unit id="ba94ae989804baff400b9b606493ab5274d7a721" translate="yes" xml:space="preserve">
          <source>NOT Malayalam!</source>
          <target state="translated">말라 얄람 어가 아닙니다!</target>
        </trans-unit>
        <trans-unit id="84b3ff998bfbcb82e2509048721a02e46fb1bbb0" translate="yes" xml:space="preserve">
          <source>NOT Mandarin!</source>
          <target state="translated">만다린이 아닙니다!</target>
        </trans-unit>
        <trans-unit id="1befb6835c1562cd0baa23c9fea5413fe9068e2e" translate="yes" xml:space="preserve">
          <source>NOT Maori!</source>
          <target state="translated">마오리가 아닙니다!</target>
        </trans-unit>
        <trans-unit id="3996b78a86c029adf66ba0fba4afc3b0b738285a" translate="yes" xml:space="preserve">
          <source>NOT Mari!</source>
          <target state="translated">마리가 아니야!</target>
        </trans-unit>
        <trans-unit id="fd25af715e82d2a1e52a76f6042a96a0b97ee0df" translate="yes" xml:space="preserve">
          <source>NOT Pompeiian!</source>
          <target state="translated">폼페이 아님!</target>
        </trans-unit>
        <trans-unit id="401d021df78de2f61ec2f834d14cc4a3deb3d7f8" translate="yes" xml:space="preserve">
          <source>NOT Romanian! NOT Romany! NOT Romansh!</source>
          <target state="translated">루마니아어 아님! 로마 니 아님! Romansh가 아닙니다!</target>
        </trans-unit>
        <trans-unit id="e7bebe37efc0e0896e678888788c0119a46ec810" translate="yes" xml:space="preserve">
          <source>NOT Scots Gaelic!</source>
          <target state="translated">게 일어를 막지 마라!</target>
        </trans-unit>
        <trans-unit id="5cb51efbf1da343aa35bb0cd1503a285538b7130" translate="yes" xml:space="preserve">
          <source>NOT Scots!</source>
          <target state="translated">Scots하지 마십시오!</target>
        </trans-unit>
        <trans-unit id="406bca1dda1a92a194b3f06540dac98edfe02f9c" translate="yes" xml:space="preserve">
          <source>NOT Tai!</source>
          <target state="translated">타이가 아닙니다!</target>
        </trans-unit>
        <trans-unit id="f4263bbd2a696d31694b9b4dfaddde3fd2e9242a" translate="yes" xml:space="preserve">
          <source>NOT Thai!</source>
          <target state="translated">태국어가 아닙니다!</target>
        </trans-unit>
        <trans-unit id="381ade097816523a950f9c68fe73f8bdd2483e08" translate="yes" xml:space="preserve">
          <source>NOT Tonga!</source>
          <target state="translated">통가 아님!</target>
        </trans-unit>
        <trans-unit id="43e2eb938fbfde6d76b6fc73f130bf7c34e96d8a" translate="yes" xml:space="preserve">
          <source>NOT Tsonga!</source>
          <target state="translated">Tsonga가 아닙니다!</target>
        </trans-unit>
        <trans-unit id="7bb4f6673a55f3ef4e9a72ddaea2a35397daeb1b" translate="yes" xml:space="preserve">
          <source>NOT Ugric!</source>
          <target state="translated">우 그릭이 아닙니다!</target>
        </trans-unit>
        <trans-unit id="ac75bf1bb4152325d5d23d198732d52ff6533a71" translate="yes" xml:space="preserve">
          <source>NOT Wendish! NOT Wend! NOT Avestan! (Formerly &quot;ven&quot;.)</source>
          <target state="translated">Wendish가 아닙니다! 구부리지 마십시오! Avestan이 아닙니다! (이전의 &quot;ven&quot;)</target>
        </trans-unit>
        <trans-unit id="8ccbd83d9bd35a8139be881200b96ebe4bf4f8ba" translate="yes" xml:space="preserve">
          <source>NOT White Russian! NOT Rusyn!</source>
          <target state="translated">백인 러시아어가 아닙니다! Rusyn이 아닙니다!</target>
        </trans-unit>
        <trans-unit id="9a3ad696e905452a166a11feac1b5ce24fc7f64e" translate="yes" xml:space="preserve">
          <source>NOT YET</source>
          <target state="translated">아직</target>
        </trans-unit>
        <trans-unit id="c775454cbbf850c1e44e01c2124ec3b439b5a154" translate="yes" xml:space="preserve">
          <source>NOT Zend.</source>
          <target state="translated">젠드하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a8ad860c15810cce0e7beac1c91da3ab2cb22c47" translate="yes" xml:space="preserve">
          <source>NOTE</source>
          <target state="translated">NOTE</target>
        </trans-unit>
        <trans-unit id="618dd0810d8f0328d5c844bf5776ec75fdee5055" translate="yes" xml:space="preserve">
          <source>NOTE: As of version 3.27, the FIPS code set is no longer supported. See the Locale::Codes::Changes document for details.</source>
          <target state="translated">참고 : 버전 3.27부터는 FIPS 코드 세트가 더 이상 지원되지 않습니다. 자세한 내용은 Locale :: Codes :: Changes 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f153ba173fef9b5aa6938b0a0ee92d9e101e6d02" translate="yes" xml:space="preserve">
          <source>NOTE: Before version 5.004_65, &lt;code&gt;hv_iterinit&lt;/code&gt; used to return the number of hash buckets that happen to be in use. If you still need that esoteric value, you can get it through the macro &lt;code&gt;HvFILL(hv)&lt;/code&gt; .</source>
          <target state="translated">참고 : 버전 5.004_65 이전에는 &lt;code&gt;hv_iterinit&lt;/code&gt; 를 사용하여 사용중인 해시 버킷 수를 반환했습니다. 여전히 난해한 가치가 필요한 경우 매크로 &lt;code&gt;HvFILL(hv)&lt;/code&gt; 통해 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="649360d37b390feb3a2b0b394e1546f8221a9d4a" translate="yes" xml:space="preserve">
          <source>NOTE: Due to the nature of make, it is important that you put the trailing slash on your DESTDIR.</source>
          <target state="translated">참고 : make의 특성상 DESTDIR에 슬래시를 추가하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="be33fdad677decf9bf49440b259d731f4baa5cc9" translate="yes" xml:space="preserve">
          <source>NOTE: For use with variables in the current package for a single scope, the functionality provided by this pragma has been superseded by &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declarations, available in Perl v5.6.0 or later, and use of this pragma is discouraged. See &lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;.</source>
          <target state="translated">참고 : 하나의 범위에 대한 현재 패키지의 변수와 함께 사용할 경우,이 프라그에서 제공하는 기능에 의해 대체되었습니다 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 펄 v5.6.0 이상 및이 pragma의 사용은 권장하지 않습니다에서 사용할 선언. &lt;a href=&quot;functions/our&quot;&gt;우리를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c0b263360f03c5b7669d257ce01c55faecf28c63" translate="yes" xml:space="preserve">
          <source>NOTE: If &lt;code&gt;STDERR&lt;/code&gt; is redirected &lt;code&gt;make install&lt;/code&gt; will &lt;b&gt;not&lt;/b&gt; prompt you to install</source>
          <target state="translated">참고 : &lt;code&gt;STDERR&lt;/code&gt; 이 리디렉션 되면 &lt;code&gt;make install&lt;/code&gt; 하라는 메시지 가 표시 &lt;b&gt;되지 않습니다&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6a15713e4ca482b00669bde833a2ad067bed418a" translate="yes" xml:space="preserve">
          <source>NOTE: If the</source>
          <target state="translated">참고 :</target>
        </trans-unit>
        <trans-unit id="3fbf142c302988d361f32c92573c404f0d821571" translate="yes" xml:space="preserve">
          <source>NOTE: If you're using a 32-bit compiler to build perl on a 64-bit Windows operating system, then you should set the WIN64 environment variable to &quot;undef&quot;. Also, the trimmed down compiler only passes tests when USE_ITHREADS *= define (as opposed to undef) and when the CFG *= Debug line is commented out.</source>
          <target state="translated">참고 : 64 비트 Windows 운영 체제에서 perl을 빌드하기 위해 32 비트 컴파일러를 사용하는 경우 WIN64 환경 변수를 &quot;undef&quot;로 설정해야합니다. 또한 트림 된 컴파일러는 USE_ITHREADS * = 정의 (undef와 반대) 및 CFG * = 디버그 행이 주석 처리 된 경우에만 테스트를 통과합니다.</target>
        </trans-unit>
        <trans-unit id="d8f20f131ce04b8a1fb6640adea5e575bdb22bbd" translate="yes" xml:space="preserve">
          <source>NOTE: In the example above, the thread returns a list, thus necessitating that the thread creation call be made in list context (i.e., &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; ($thr)&lt;/code&gt; ). See &lt;a href=&quot;threads#%24thr-%3ejoin()&quot;&gt;$thr-&amp;gt;join() in threads&lt;/a&gt; and &lt;a href=&quot;threads#THREAD-CONTEXT&quot;&gt;THREAD CONTEXT in threads&lt;/a&gt; for more details on thread context and return values.</source>
          <target state="translated">참고 : 위 예제에서 스레드는 목록을 반환하므로 목록 컨텍스트 (예 : &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; ($thr)&lt;/code&gt; ) 에서 스레드 작성 호출이 필요합니다 . 참조 &lt;a href=&quot;threads#%24thr-%3ejoin()&quot;&gt;스레드 ()에서 가입&amp;gt; $ thr-를&lt;/a&gt; 하고 &lt;a href=&quot;threads#THREAD-CONTEXT&quot;&gt;스레드에서 스레드 컨텍스트&lt;/a&gt; 스레드 컨텍스트 및 반환 값에 대한 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="8cd640e426e455b329ccdbe19f860f26de435861" translate="yes" xml:space="preserve">
          <source>NOTE: The BerkeleyDB library only completely works on NTFS partitions.</source>
          <target state="translated">참고 : BerkeleyDB 라이브러리는 NTFS 파티션에서만 완벽하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a883d5970a29c1610a3c0fa8d3c7281403c56317" translate="yes" xml:space="preserve">
          <source>NOTE: The GDBM library only works on NTFS partitions.</source>
          <target state="translated">참고 : GDBM 라이브러리는 NTFS 파티션에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="9b01e20bea3deec5ba5197be5f2861b1f24a1902" translate="yes" xml:space="preserve">
          <source>NOTE: The USE_64_BIT_INT build option is not supported with the 32-bit Visual C++ 6.0 compiler.</source>
          <target state="translated">참고 : USE_64_BIT_INT 빌드 옵션은 32 비트 Visual C ++ 6.0 컴파일러에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="92679b71ee8b46e8b7e0ced5d18384810d027930" translate="yes" xml:space="preserve">
          <source>NOTE: The current implementation keeps the declared fields in the %FIELDS hash of the calling package, but this may change in future versions. Do &lt;b&gt;not&lt;/b&gt; update the %FIELDS hash directly, because it must be created at compile-time for it to be fully useful, as is done by this pragma.</source>
          <target state="translated">참고 : 현재 구현에서는 선언 된 필드를 호출 패키지의 % FIELDS 해시에 유지하지만 이후 버전에서는 변경 될 수 있습니다. 마십시오 &lt;b&gt;하지&lt;/b&gt; 완전히 유용하는 것이이 컴파일시에 작성해야하기 때문에, 직접 % FIELDS 해시를 업데이트 등이 pragma에 의해 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="bffb349a25186b416bb90a95e353abe4799c593a" translate="yes" xml:space="preserve">
          <source>NOTE: The main Perl thread (thread 0) is in a</source>
          <target state="translated">참고 : 주 Perl 스레드 (스레드 0)는</target>
        </trans-unit>
        <trans-unit id="4b2d780df8a865a0c1e4241c863cc63ef39b82f8" translate="yes" xml:space="preserve">
          <source>NOTE: This class is now a front-end to the IO::* classes.</source>
          <target state="translated">참고 :이 클래스는 이제 IO :: * 클래스의 프런트 엔드입니다.</target>
        </trans-unit>
        <trans-unit id="3c0adaeecd5969cd29892262a1fafa36ba011ebd" translate="yes" xml:space="preserve">
          <source>NOTE: This has &lt;b&gt;not&lt;/b&gt; been extensively tested. In particular, &lt;code&gt;d_semctl_semun&lt;/code&gt; is undefined because it fails a Configure test and on Win9x the</source>
          <target state="translated">참고 : 이것은 광범위하게 테스트 &lt;b&gt;되지&lt;/b&gt; 않았습니다. 특히 &lt;code&gt;d_semctl_semun&lt;/code&gt; 은 구성 테스트에 실패하고 Win9x에서</target>
        </trans-unit>
        <trans-unit id="93561b423a89d40f27ddedd870c2c3c213cd0ca9" translate="yes" xml:space="preserve">
          <source>NOTE: This is the canonical version of the method. The version in File::Spec::VMS is deprecated.</source>
          <target state="translated">참고 :이 방법은 정식 버전입니다. File :: Spec :: VMS의 버전은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3bfe8cfad2c7f08a016e53df968cd93d3ee1a3d3" translate="yes" xml:space="preserve">
          <source>NOTE: This section presents an abstract approximation of regular expression behavior. For a more rigorous (and complicated) view of the rules involved in selecting a match among possible alternatives, see &lt;a href=&quot;#Combining-RE-Pieces&quot;&gt;Combining RE Pieces&lt;/a&gt;.</source>
          <target state="translated">참고 :이 섹션에서는 정규 표현식 동작에 대한 추상적 인 근사값을 제공합니다. 가능한 대안 중에서 일치 항목을 선택하는 데 관련된 규칙을보다 엄격하고 복잡하게 보려면 &lt;a href=&quot;#Combining-RE-Pieces&quot;&gt;RE 조각 결합을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f97ff6e3100b23f28f9a60da39c11eb47af9c9a6" translate="yes" xml:space="preserve">
          <source>NOTE: This warning detects package symbols that have been used only once. This means lexical variables will never trigger this warning. It also means that all of the package variables $c, @c, %c, as well as *c, &amp;amp;c, sub c{}, c(), and c (the filehandle or format) are considered the same; if a program uses $c only once but also uses any of the others it will not trigger this warning. Symbols beginning with an underscore and symbols using special identifiers (q.v. &lt;a href=&quot;perldata&quot;&gt;perldata&lt;/a&gt;) are exempt from this warning.</source>
          <target state="translated">참고 :이 경고는 한 번만 사용 된 패키지 기호를 감지합니다. 이는 어휘 변수가이 경고를 트리거하지 않음을 의미합니다. 또한 모든 패키지 변수 $ c, @c, % c 및 * c, &amp;amp; c, sub c {}, c () 및 c (파일 핸들 또는 형식)는 동일하게 간주됩니다. 프로그램이 $ c를 한 번만 사용하고 다른 프로그램도 사용하는 경우이 경고가 발생하지 않습니다. 밑줄로 시작하는 기호 및 특수 식별자 (qv &lt;a href=&quot;perldata&quot;&gt;perldata&lt;/a&gt; )를 사용하는 기호 는이 경고에서 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="5871f00a4b47482fbc58aebc0cc4ba62002b52da" translate="yes" xml:space="preserve">
          <source>NOTE: This was fixed in perl 5.20. Mentioning these three variables no longer makes a speed difference. This section still applies if your code is to run on perl 5.18 or earlier.</source>
          <target state="translated">참고 : 이것은 perl 5.20에서 수정되었습니다. 이 세 가지 변수를 언급해도 더 이상 속도 차이가 발생하지 않습니다. 이 섹션은 코드가 perl 5.18 이전 버전에서 실행되는 경우에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="e360e636f982b17adc20c8e88ac33bf0ddfb0d5f" translate="yes" xml:space="preserve">
          <source>NOTE: When using this option to alter the extension of a module's loadable object, it is also necessary that the module's pm file specifies the same change:</source>
          <target state="translated">참고 :이 옵션을 사용하여 모듈의로드 가능한 객체의 확장자를 변경하는 경우 모듈의 pm 파일도 동일한 변경 사항을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="376fb7bcf600539ba82d51a66a1efcb849c8327e" translate="yes" xml:space="preserve">
          <source>NOTE: during a build there could be created a number (or one) of</source>
          <target state="translated">참고 : 빌드하는 동안 숫자 (또는 하나)를 만들 수 있습니다</target>
        </trans-unit>
        <trans-unit id="adeb89f1a65c1db4fe7065e44b17a7dc45e0c343" translate="yes" xml:space="preserve">
          <source>NOTE: the perl_ form of this function is deprecated.</source>
          <target state="translated">참고 :이 함수의 perl_ 형식은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="259672a245b4c95b8c72c4ad7549e5e6b6f26678" translate="yes" xml:space="preserve">
          <source>NOTE: this function is experimental and may change or be removed without notice.</source>
          <target state="translated">참고 :이 기능은 실험용이며 예고없이 변경되거나 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f3d58bf1438c4c6241c66bb37ecbdb244a70618" translate="yes" xml:space="preserve">
          <source>NOTE: this function must be explicitly called as Perl_blockhook_register with an aTHX_ parameter.</source>
          <target state="translated">참고 :이 함수는 aTHX_ 매개 변수를 사용하여 Perl_blockhook_register로 명시 적으로 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="d7b1f0204d1784d6985d1beacf1a3919bed1aa91" translate="yes" xml:space="preserve">
          <source>NOTE: this function must be explicitly called as Perl_custom_op_register with an aTHX_ parameter.</source>
          <target state="translated">참고 :이 함수는 aTHX_ 매개 변수를 사용하여 Perl_custom_op_register로 명시 적으로 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="6babb9cf8fb6ef67053f45016008ddba04aec872" translate="yes" xml:space="preserve">
          <source>NOTE: this function must be explicitly called as Perl_custom_op_xop with an aTHX_ parameter.</source>
          <target state="translated">참고 :이 함수는 aTHX_ 매개 변수를 사용하여 Perl_custom_op_xop으로 명시 적으로 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="fb98ccf0885ad4b3b865d59fcf8b08abb3ba7533" translate="yes" xml:space="preserve">
          <source>NOTE: unless your Perl has been compiled with debug info (often &lt;b&gt;-g&lt;/b&gt;), the stack trace is likely to be somewhat hard to use because it will most probably contain only the function names and not their arguments. If possible, recompile your Perl with debug info and reproduce the crash and the stack trace.</source>
          <target state="translated">참고 : Perl이 디버그 정보 (종종 &lt;b&gt;-g&lt;/b&gt; ) 로 컴파일되지 않은 경우 스택 추적은 함수 이름 만 포함하고 인수는 포함하지 않으므로 사용하기가 다소 어려울 수 있습니다. 가능하면 디버그 정보를 사용하여 Perl을 다시 컴파일하고 충돌 및 스택 추적을 재현하십시오.</target>
        </trans-unit>
        <trans-unit id="d1560e71dccb0898373285ee4f50b724b2b71c7d" translate="yes" xml:space="preserve">
          <source>NOTE: you can pass either the object directly or the SV contained within the RV.</source>
          <target state="translated">참고 : 객체를 직접 전달하거나 RV에 포함 된 SV를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e69fc18a69727f31dc484cc6cc5d98f4552fffd6" translate="yes" xml:space="preserve">
          <source>NOTES</source>
          <target state="translated">NOTES</target>
        </trans-unit>
        <trans-unit id="6fc8974be5d154b1084db932a691a405a4c97b92" translate="yes" xml:space="preserve">
          <source>NOTES ON CUSTOMIZATION</source>
          <target state="translated">맞춤화에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="fe71871083ca490e6bc0da33fb48ce231f820a94" translate="yes" xml:space="preserve">
          <source>NOTICE</source>
          <target state="translated">NOTICE</target>
        </trans-unit>
        <trans-unit id="0caa59b644c0cefac70de91f3a56d8b895dc8638" translate="yes" xml:space="preserve">
          <source>NUL terminated string, length will be determined with &lt;code&gt;strlen&lt;/code&gt;</source>
          <target state="translated">NUL 종료 문자열, 길이는 &lt;code&gt;strlen&lt;/code&gt; 으로 결정됩니다</target>
        </trans-unit>
        <trans-unit id="fb2fb40b4decc623e7e7104506804374fa2e9c3b" translate="yes" xml:space="preserve">
          <source>NULL will be returned if a REGEXP* is not found.</source>
          <target state="translated">REGEXP *를 찾을 수 없으면 NULL이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="6c2496a022b02739f43ed430676315b0c3b34a08" translate="yes" xml:space="preserve">
          <source>NUMBER</source>
          <target state="translated">NUMBER</target>
        </trans-unit>
        <trans-unit id="9a969c7ad3b1a0b9595b8188b657f82438b62232" translate="yes" xml:space="preserve">
          <source>NV</source>
          <target state="translated">NV</target>
        </trans-unit>
        <trans-unit id="aa5a7c30af283c6875cea008a552e7d7c9264007" translate="yes" xml:space="preserve">
          <source>Name of current executing subroutine.</source>
          <target state="translated">현재 실행중인 서브 루틴의 이름</target>
        </trans-unit>
        <trans-unit id="5d6475ea1ed77582899f2ede3c078b5d7ca7f2d5" translate="yes" xml:space="preserve">
          <source>Name of the MRO, either in ISO-8859-1 or UTF-8.</source>
          <target state="translated">ISO-8859-1 또는 UTF-8의 MRO 이름입니다.</target>
        </trans-unit>
        <trans-unit id="f311c3300c6ca77afd17b4650f40819e62321f9f" translate="yes" xml:space="preserve">
          <source>Name of the executable used to run &lt;code&gt;PPM_INSTALL_SCRIPT&lt;/code&gt; below. (e.g. perl)</source>
          <target state="translated">아래 &lt;code&gt;PPM_INSTALL_SCRIPT&lt;/code&gt; 를 실행하는 데 사용되는 실행 파일의 이름입니다 . (예 : 펄)</target>
        </trans-unit>
        <trans-unit id="e843afb94a5b81c10884290c28f3a8b15754d088" translate="yes" xml:space="preserve">
          <source>Name of the executable used to run &lt;code&gt;PPM_UNINSTALL_SCRIPT&lt;/code&gt; below. (e.g. perl)</source>
          <target state="translated">아래 &lt;code&gt;PPM_UNINSTALL_SCRIPT&lt;/code&gt; 를 실행하는 데 사용되는 실행 파일 이름입니다 . (예 : 펄)</target>
        </trans-unit>
        <trans-unit id="8624fc8eceebc0b51b2143689f1f48b7ecc08665" translate="yes" xml:space="preserve">
          <source>Name of the file that contains the package description. MakeMaker looks for a line in the POD matching /^($package\s-\s)(.*)/. This is typically the first line in the &quot;=head1 NAME&quot; section. $2 becomes the abstract.</source>
          <target state="translated">패키지 설명이 포함 된 파일의 이름입니다. MakeMaker는 POD에서 /^($package\s-\s)(.*)/와 일치하는 행을 찾습니다. 이것은 일반적으로 &quot;= head1 NAME&quot;섹션의 첫 번째 줄입니다. $ 2는 초록이됩니다.</target>
        </trans-unit>
        <trans-unit id="8c3cf8734b2c68bc08b2cd79d4d6ccc0136f6aa2" translate="yes" xml:space="preserve">
          <source>Name of the module. This must be specified</source>
          <target state="translated">모듈 이름. 반드시 지정해야합니다</target>
        </trans-unit>
        <trans-unit id="7868a8b47d3d92cc64ccf808862aaae2ad267aa5" translate="yes" xml:space="preserve">
          <source>Name of the script that gets executed by the Perl Package Manager after the installation of a package.</source>
          <target state="translated">패키지 설치 후 Perl Package Manager가 실행하는 스크립트의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c0c5023ea38126581b7ad8749f0a6eeac640c079" translate="yes" xml:space="preserve">
          <source>Name of the script that gets executed by the Perl Package Manager before the removal of a package.</source>
          <target state="translated">패키지를 제거하기 전에 Perl 패키지 관리자가 실행하는 스크립트의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="68785b7e9b3c03448ca8a837701cc8c707a8e260" translate="yes" xml:space="preserve">
          <source>Named Pipes</source>
          <target state="translated">명명 된 파이프</target>
        </trans-unit>
        <trans-unit id="38f9681437d9ef50ce0be66a608e2a42a4859202" translate="yes" xml:space="preserve">
          <source>Named Unary Operators</source>
          <target state="translated">명명 된 단항 연산자</target>
        </trans-unit>
        <trans-unit id="363027e7f4ba04f6c37400d54c44141712c1efe2" translate="yes" xml:space="preserve">
          <source>Named Unicode properties, scripts, and block ranges may be used (like bracketed character classes) by using the &lt;code&gt;\p{}&lt;/code&gt; &quot;matches property&quot; construct and the &lt;code&gt;\P{}&lt;/code&gt; negation, &quot;doesn't match property&quot;.</source>
          <target state="translated">명명 된 유니 코드 속성, 스크립트 및 블록 범위는 &lt;code&gt;\p{}&lt;/code&gt; &quot;matches property&quot;구성과 &lt;code&gt;\P{}&lt;/code&gt; 부정, &quot;properties와 일치하지 않음&quot; 을 사용하여 괄호 문자 클래스와 같이 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f7f3bf2783d20b66cecd2489a0534cdb07661abf" translate="yes" xml:space="preserve">
          <source>Named backreference. Similar to numeric backreferences, except that the group is designated by name and not number. If multiple groups have the same name then it refers to the leftmost defined group in the current match.</source>
          <target state="translated">역 참조라는 이름. 그룹이 숫자가 아닌 이름으로 지정된다는 점을 제외하고 숫자 역 참조와 유사합니다. 여러 그룹의 이름이 같은 경우 현재 일치에서 가장 왼쪽에 정의 된 그룹을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8dc1cc0c73966f67aab3d39f6cd441d18321c8ff" translate="yes" xml:space="preserve">
          <source>Named backreferences</source>
          <target state="translated">명명 된 역 참조</target>
        </trans-unit>
        <trans-unit id="16f988a61667e6887152ee06c28af4c95a899d43" translate="yes" xml:space="preserve">
          <source>Named capture callbacks</source>
          <target state="translated">명명 된 캡처 콜백</target>
        </trans-unit>
        <trans-unit id="a3c4ad7c429d9290102e7a6d5ae4db5c22f03f6f" translate="yes" xml:space="preserve">
          <source>Named or numbered characters and character sequences</source>
          <target state="translated">명명 된 또는 번호가 매겨진 문자 및 문자 순서</target>
        </trans-unit>
        <trans-unit id="65c4b696d78a27092b9642bc7761e57eb905bc44" translate="yes" xml:space="preserve">
          <source>Named parameters control how the processing is done. The following parameters are accepted:</source>
          <target state="translated">명명 된 매개 변수는 처리 방법을 제어합니다. 다음과 같은 매개 변수가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="8f1d236b5d1295b7af7be948d212edc9fb3b966e" translate="yes" xml:space="preserve">
          <source>Named referencing</source>
          <target state="translated">명명 된 참조</target>
        </trans-unit>
        <trans-unit id="50a6776c3f86da85ce1ec46afa315f3a40ef3305" translate="yes" xml:space="preserve">
          <source>Named regexp capture buffers</source>
          <target state="translated">명명 된 정규식 캡처 버퍼</target>
        </trans-unit>
        <trans-unit id="5bc55622970622d1a946affa392f121998a96cf2" translate="yes" xml:space="preserve">
          <source>Named sequences proposed for inclusion in a later version of the Unicode Standard; if you need them now, you can append this file to</source>
          <target state="translated">이후 버전의 유니 코드 표준에 포함되도록 제안 된 명명 된 시퀀스; 지금 필요한 경우이 파일을 추가 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="5c3780cc2079e280219cd2c73d0c31b04ec16680" translate="yes" xml:space="preserve">
          <source>NamedSequences.txt</source>
          <target state="translated">NamedSequences.txt</target>
        </trans-unit>
        <trans-unit id="baefd92d48050a7240199d96c1a36a56b359c89c" translate="yes" xml:space="preserve">
          <source>Names can be specified in a variety of platform independent forms. Any names in the form &lt;b&gt;-lname&lt;/b&gt; are converted into</source>
          <target state="translated">이름은 다양한 플랫폼 독립적 형태로 지정할 수 있습니다. 형태의 모든 이름 &lt;b&gt;-lName가&lt;/b&gt; 로 변환</target>
        </trans-unit>
        <trans-unit id="6b7a2802d0082d79ff8976f3240ee6e3da8a9ceb" translate="yes" xml:space="preserve">
          <source>Names can include package names, which are relative to the specified PACKAGE. So these two calls have the same effect:</source>
          <target state="translated">이름에는 지정된 패키지와 관련된 패키지 이름이 포함될 수 있습니다. 따라서이 두 호출은 동일한 효과를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="821821513dd7967a6e00087d901b1371b2e3ad09" translate="yes" xml:space="preserve">
          <source>Names in EXPORT_TAGS must also appear in @EXPORT or @EXPORT_OK.</source>
          <target state="translated">EXPORT_TAGS의 이름은 @EXPORT 또는 @EXPORT_OK에도 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c41eeb7fb1662a7738050a541890eb91cb128a6c" translate="yes" xml:space="preserve">
          <source>Names that start with a digit may contain only more digits. Names that do not start with a letter, underscore, digit or a caret (i.e. a control character) are limited to one character, e.g., &lt;code&gt;$%&lt;/code&gt; or &lt;code&gt;$$&lt;/code&gt; . (Most of these one character names have a predefined significance to Perl. For instance, &lt;code&gt;$$&lt;/code&gt; is the current process id.)</source>
          <target state="translated">숫자로 시작하는 이름에는 더 많은 숫자 만 포함될 수 있습니다. 문자, 밑줄, 숫자 또는 캐럿 (예 : 제어 문자)으로 시작하지 않는 이름은 한 문자 (예 : &lt;code&gt;$%&lt;/code&gt; 또는 &lt;code&gt;$$&lt;/code&gt; )로 제한됩니다 . (이 중 하나의 문자 이름은 대부분 Perl에 사전 정의 된 의미를 갖습니다. 예를 들어 &lt;code&gt;$$&lt;/code&gt; 는 현재 프로세스 ID입니다.)</target>
        </trans-unit>
        <trans-unit id="f61c957a0ea0313872e704f1b4fb7ca6add44160" translate="yes" xml:space="preserve">
          <source>Names which are unknown are output as &lt;code&gt;name='UNKNOWN';&lt;/code&gt; . See also &lt;code&gt;-V:name&lt;/code&gt; in &lt;a href=&quot;perlrun#Command-Switches&quot;&gt;Command Switches in perlrun&lt;/a&gt;.</source>
          <target state="translated">알려지지 않은 &lt;code&gt;name='UNKNOWN';&lt;/code&gt; 은 name = 'UNKNOWN' 으로 출력됩니다 . . 참조 &lt;code&gt;-V:name&lt;/code&gt; 의 &lt;a href=&quot;perlrun#Command-Switches&quot;&gt;명령 perlrun에서 전환합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="98ccbf4f5c0c9d25ab257fc9d0e7b0d41bb961f3" translate="yes" xml:space="preserve">
          <source>NamesList.txt</source>
          <target state="translated">NamesList.txt</target>
        </trans-unit>
        <trans-unit id="286ecdc947944985bf973a72fa95a40f4b1c4f17" translate="yes" xml:space="preserve">
          <source>Namespace for Perl's core routines</source>
          <target state="translated">Perl의 핵심 루틴을위한 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="3056e2bd0eee723080eaab7641ee4953af255c2b" translate="yes" xml:space="preserve">
          <source>Nathan Torkington &amp;lt;gnat@frii.com&amp;gt; - for some input on the documentation.</source>
          <target state="translated">Nathan Torkington &amp;lt;gnat@frii.com&amp;gt;-문서에 대한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4fc6e7f740abb8af896ebedebf941a3f8d7076b5" translate="yes" xml:space="preserve">
          <source>Native</source>
          <target state="translated">Native</target>
        </trans-unit>
        <trans-unit id="4ab012d77f1bfa1be662b51a80ae510c6cc5e59a" translate="yes" xml:space="preserve">
          <source>Native filenames are of the form</source>
          <target state="translated">기본 파일 이름은 형식입니다</target>
        </trans-unit>
        <trans-unit id="9026c8c56fc624332cd74cb5876316288c820bc7" translate="yes" xml:space="preserve">
          <source>Naturally, &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord()&lt;/a&gt;&lt;/code&gt; will do the reverse: it turns a character into a code point.</source>
          <target state="translated">당연히 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord()&lt;/a&gt;&lt;/code&gt; 는 역을 수행합니다. 문자를 코드 포인트로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="7a140f3939f57780fd27a1d0165e3f2dc71e5686" translate="yes" xml:space="preserve">
          <source>Nearly all regops that involve looking at the input string have two cases, one for UTF-8, and one not. In fact, it's often more complex than that, as the pattern may be UTF-8 as well.</source>
          <target state="translated">입력 문자열을 보는 거의 모든 regop에는 UTF-8의 경우와 그렇지 않은 경우의 두 가지 경우가 있습니다. 실제로 패턴이 UTF-8 일 수도 있기 때문에 종종 그보다 더 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="2e3f8a85f04426583b54b3312fffad6ba80924a3" translate="yes" xml:space="preserve">
          <source>Needed source files can be downloaded at &lt;a href=&quot;http://perlce.sourceforge.net&quot;&gt;http://perlce.sourceforge.net&lt;/a&gt;</source>
          <target state="translated">필요한 소스 파일은 &lt;a href=&quot;http://perlce.sourceforge.net&quot;&gt;http://perlce.sourceforge.net&lt;/a&gt; 에서 다운로드 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="b4c6bdc96d2ca3d241efb74d4a188d630f77bcd7" translate="yes" xml:space="preserve">
          <source>Negate the number, e.g. change the sign between '+' and '-', or between '+inf' and '-inf', respectively. Does nothing for NaN or zero.</source>
          <target state="translated">숫자를 무효화하십시오 (예 : '+'와 '-'사이 또는 '+ inf'와 '-inf'사이의 부호 변경). NaN 또는 0에 대해서는 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="24048c04eba343a323fecac37d642445c66f6c28" translate="yes" xml:space="preserve">
          <source>Negation</source>
          <target state="translated">Negation</target>
        </trans-unit>
        <trans-unit id="7eeb67f2368c6c772835291295311889c092fbbd" translate="yes" xml:space="preserve">
          <source>Negation of POSIX character classes</source>
          <target state="translated">POSIX 문자 클래스의 부정</target>
        </trans-unit>
        <trans-unit id="838604a201964cc68e7ef736a20025e0b5fec649" translate="yes" xml:space="preserve">
          <source>Negative Epoch Values</source>
          <target state="translated">네거티브 에포크 값</target>
        </trans-unit>
        <trans-unit id="19f49d5d6ade2549965db79a7030897c2f5f4f62" translate="yes" xml:space="preserve">
          <source>Negative index positions are supported. Specifying a negative index position greater than the number of items in the queue may return items from the head of the queue (similar to &lt;code&gt;dequeue_nb&lt;/code&gt; ) if the count overlaps the head of the queue from the specified position (i.e. if queue size + index + count is greater than zero):</source>
          <target state="translated">음의 인덱스 위치가 지원됩니다. 큐의 항목 수보다 큰 음수 인덱스 위치를 지정 하면 지정된 위치에서 큐 수가 헤드의 위치와 겹치는 경우 (예 : 큐 크기 + 인덱스 + 개수) 큐의 헤드에서 항목을 반환 할 수 있습니다 ( &lt;code&gt;dequeue_nb&lt;/code&gt; 와 유사 ). 0보다 큼) :</target>
        </trans-unit>
        <trans-unit id="63a43ac9c627d0de9e56d6cc12c6dfda0e520af0" translate="yes" xml:space="preserve">
          <source>Negative index positions are supported:</source>
          <target state="translated">음의 색인 위치가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="ea5e4636dc65fd0c83bdadbdf91aa1d35d1fb840" translate="yes" xml:space="preserve">
          <source>Negative indexes are treated the same as with FETCH.</source>
          <target state="translated">음수 인덱스는 FETCH와 동일하게 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="05ec1ebfabb890ebda597976839aada64bc04b63" translate="yes" xml:space="preserve">
          <source>Negative values give the Unicode replacement character (chr(0xfffd)), except under the &lt;a href=&quot;../bytes&quot;&gt;bytes&lt;/a&gt; pragma, where the low eight bits of the value (truncated to an integer) are used.</source>
          <target state="translated">음수 값은 &lt;a href=&quot;../bytes&quot;&gt;바이트&lt;/a&gt; pragma 아래를 제외하고 유니 코드 대체 문자 (chr (0xfffd))를 제공합니다 . 여기에서는 값의 하위 8 비트 (정수로 잘림)가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1c329b07c62265cbfacaf020c4fd1ffae1eec60d" translate="yes" xml:space="preserve">
          <source>Negative values give the Unicode replacement character (chr(0xfffd)), except under the &lt;a href=&quot;bytes&quot;&gt;bytes&lt;/a&gt; pragma, where the low eight bits of the value (truncated to an integer) are used.</source>
          <target state="translated">음수 값은 &lt;a href=&quot;bytes&quot;&gt;바이트&lt;/a&gt; pragma 아래를 제외하고 유니 코드 대체 문자 (chr (0xfffd))를 제공합니다 . 여기에서는 값의 하위 8 비트 (정수로 잘림)가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1f8e2d0b246c79d6b8bec7311afcd29fb2d3ca36" translate="yes" xml:space="preserve">
          <source>Neil Bowers &amp;lt;neil@bowers.com&amp;gt;</source>
          <target state="translated">닐 바우어 &amp;lt;neil@bowers.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6d2dec944babf88ec6f3aa5e208e251180845055" translate="yes" xml:space="preserve">
          <source>Neither IPC::Run nor IPC::Open3 can interleave STDOUT and STDERR. For short bursts of output from a program, e.g. this sample,</source>
          <target state="translated">IPC :: Run 또는 IPC :: Open3은 STDOUT 및 STDERR을 인터리브 할 수 없습니다. 이 샘플과 같은 프로그램의 짧은 출력 버스트의 경우</target>
        </trans-unit>
        <trans-unit id="77ec836d28f250f8bd76b8042a3917b08e1cacac" translate="yes" xml:space="preserve">
          <source>Neither using offsets nor adding &lt;code&gt;x&lt;/code&gt; 's to bridge the gaps is satisfactory. (Just imagine what happens if the structure changes.) What we really need is a way of saying &quot;skip as many bytes as required to the next multiple of N&quot;. In fluent Templatese, you say this with &lt;code&gt;x!N&lt;/code&gt; where N is replaced by the appropriate value. Here's the next version of our struct packaging:</source>
          <target state="translated">간격을 메우기 위해 오프셋을 사용하거나 &lt;code&gt;x&lt;/code&gt; 를 추가하는 것은 만족스럽지 않습니다. (구조가 바뀌면 어떻게 될지 상상해보십시오.) 실제로 필요한 것은 &quot;다음 N의 배수에 필요한만큼의 바이트를 건너 뛰십시오&quot;라고 말하는 방법입니다. 유창한 템플릿에서는 &lt;code&gt;x!N&lt;/code&gt; 으로 N을 적절한 값으로 바꿉니다. 구조체 패키징의 다음 버전은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f07a42044209eb0a8555ca6ade59268b7094a144" translate="yes" xml:space="preserve">
          <source>Nelson, Greg (editor). Systems Programming with Modula-3. Prentice Hall, 1991, ISBN 0-13-590464-1.</source>
          <target state="translated">넬슨, 그렉 (편집자). Modula-3을 사용한 시스템 프로그래밍. 1991 년 Prentice Hall, ISBN 0-13-590464-1.</target>
        </trans-unit>
        <trans-unit id="4eb9236f898d35e46f6533b663fb0cc39ac3281b" translate="yes" xml:space="preserve">
          <source>Net::Cmd</source>
          <target state="translated">Net::Cmd</target>
        </trans-unit>
        <trans-unit id="9b649db7310bc211d9f1ac99e1a4786a84597204" translate="yes" xml:space="preserve">
          <source>Net::Cmd - Network Command class (as used by FTP, SMTP etc)</source>
          <target state="translated">Net :: Cmd-네트워크 명령 클래스 (FTP, SMTP 등에서 사용)</target>
        </trans-unit>
        <trans-unit id="1294c92fcf04499d6b81523ccdaa5539dece0dcd" translate="yes" xml:space="preserve">
          <source>Net::Config</source>
          <target state="translated">Net::Config</target>
        </trans-unit>
        <trans-unit id="90625b9f0d5c16a32efbdc040ebbf3d89a17fb98" translate="yes" xml:space="preserve">
          <source>Net::Config - Local configuration data for libnet</source>
          <target state="translated">Net :: Config-libnet의 로컬 구성 데이터</target>
        </trans-unit>
        <trans-unit id="d2609cd7d34a9ef70d66b656d20f6d7141373166" translate="yes" xml:space="preserve">
          <source>Net::Domain</source>
          <target state="translated">Net::Domain</target>
        </trans-unit>
        <trans-unit id="79d06eb32b3346cf8bd3d603f70534bd0b81c26c" translate="yes" xml:space="preserve">
          <source>Net::Domain - Attempt to evaluate the current host's internet name and domain</source>
          <target state="translated">Net :: Domain-현재 호스트의 인터넷 이름 및 도메인을 평가하려고합니다.</target>
        </trans-unit>
        <trans-unit id="e600d59f8d5cea62e2e7232d04583ce46bcf0e54" translate="yes" xml:space="preserve">
          <source>Net::FTP</source>
          <target state="translated">Net::FTP</target>
        </trans-unit>
        <trans-unit id="760713d42087f7dca8f19249d8ef722a9fcee544" translate="yes" xml:space="preserve">
          <source>Net::FTP - FTP Client class</source>
          <target state="translated">Net :: FTP-FTP 클라이언트 클래스</target>
        </trans-unit>
        <trans-unit id="59946fef31b50a99653b28a153ac63abae9315d1" translate="yes" xml:space="preserve">
          <source>Net::FTP::dataconn</source>
          <target state="translated">Net::FTP::dataconn</target>
        </trans-unit>
        <trans-unit id="68e99886fb9e7eeead8137e48281b0ac46381c53" translate="yes" xml:space="preserve">
          <source>Net::FTP::dataconn - FTP Client data connection class</source>
          <target state="translated">Net :: FTP :: dataconn-FTP 클라이언트 데이터 연결 클래스</target>
        </trans-unit>
        <trans-unit id="2ba79303d7df37b27bccb82e4aaeb8383769338b" translate="yes" xml:space="preserve">
          <source>Net::NNTP</source>
          <target state="translated">Net::NNTP</target>
        </trans-unit>
        <trans-unit id="1f88f3dc9b54f8f1f3117b189d2bcc352702751e" translate="yes" xml:space="preserve">
          <source>Net::NNTP - NNTP Client class</source>
          <target state="translated">Net :: NNTP-NNTP 클라이언트 클래스</target>
        </trans-unit>
        <trans-unit id="634fa163a1bb55220f43fe3d8f658acf7bf2e805" translate="yes" xml:space="preserve">
          <source>Net::Netrc</source>
          <target state="translated">Net::Netrc</target>
        </trans-unit>
        <trans-unit id="e565165304b4cd87ebc082d3d778254a21d1e828" translate="yes" xml:space="preserve">
          <source>Net::Netrc - OO interface to users netrc file</source>
          <target state="translated">Net :: Netrc-사용자 netrc 파일에 대한 OO 인터페이스</target>
        </trans-unit>
        <trans-unit id="07d7d837c6ee6980c7dd03a4fc9e0f56e0b48e2f" translate="yes" xml:space="preserve">
          <source>Net::POP3</source>
          <target state="translated">Net::POP3</target>
        </trans-unit>
        <trans-unit id="c035763415c5e31a5fb091c5e1210e8a45507f17" translate="yes" xml:space="preserve">
          <source>Net::POP3 - Post Office Protocol 3 Client class (RFC1939)</source>
          <target state="translated">Net :: POP3-우체국 프로토콜 3 클라이언트 클래스 (RFC1939)</target>
        </trans-unit>
        <trans-unit id="aa89e2215ec797bac7f32905762d8dcb7883a796" translate="yes" xml:space="preserve">
          <source>Net::Ping</source>
          <target state="translated">Net::Ping</target>
        </trans-unit>
        <trans-unit id="797696af258d1ca33ead432810454bbe7f86b9d9" translate="yes" xml:space="preserve">
          <source>Net::Ping - check a remote host for reachability</source>
          <target state="translated">Net :: Ping-연결 가능성에 대한 원격 호스트 확인</target>
        </trans-unit>
        <trans-unit id="7892c063104435dff8c4fb6f81f8e0633b34593b" translate="yes" xml:space="preserve">
          <source>Net::SMTP</source>
          <target state="translated">Net::SMTP</target>
        </trans-unit>
        <trans-unit id="3f4b2bd689e539d2c249ffa70c859d6d28efdef2" translate="yes" xml:space="preserve">
          <source>Net::SMTP - Simple Mail Transfer Protocol Client</source>
          <target state="translated">Net :: SMTP-단순 메일 전송 프로토콜 클라이언트</target>
        </trans-unit>
        <trans-unit id="c8dd7ce8a5f6c30dbe592557d703bdc3c58ebeb5" translate="yes" xml:space="preserve">
          <source>Net::SMTP attempts to DWIM with addresses that are passed. For example an application might extract The From: line from an email and pass that to mail(). While this may work, it is not recommended. The application should really use a module like &lt;a href=&quot;http://search.cpan.org/perldoc/Mail::Address&quot;&gt;Mail::Address&lt;/a&gt; to extract the mail address and pass that.</source>
          <target state="translated">Net :: SMTP는 전달 된 주소로 DWIM을 시도합니다. 예를 들어 응용 프로그램은 전자 메일에서 From : 행을 추출하여 mail ()로 전달할 수 있습니다. 이것이 작동 할 수는 있지만 권장되지는 않습니다. 응용 프로그램은 실제로 &lt;a href=&quot;http://search.cpan.org/perldoc/Mail::Address&quot;&gt;Mail :: Address&lt;/a&gt; 와 같은 모듈을 사용하여 메일 주소 를 추출하고 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="64018d825c9dce97cd967ab565ae5bde0e71a33f" translate="yes" xml:space="preserve">
          <source>Net::SSLeay on Solaris</source>
          <target state="translated">Solaris의 Net :: SSLeay</target>
        </trans-unit>
        <trans-unit id="8e0508a806d7681b9f57b4f0dafc12dd8ed03cac" translate="yes" xml:space="preserve">
          <source>Net::SSLeay requires a /dev/urandom to be present. This device is available from Solaris 9 onwards. For earlier Solaris versions you can either get the package SUNWski (packaged with several Sun software products, for example the Sun WebServer, which is part of the Solaris Server Intranet Extension, or the Sun Directory Services, part of Solaris for ISPs) or download the ANDIrand package from &lt;a href=&quot;http://www.cosy.sbg.ac.at/~andi/&quot;&gt;http://www.cosy.sbg.ac.at/~andi/&lt;/a&gt;. If you use SUNWski, make a symbolic link /dev/urandom pointing to /dev/random. For more details, see Document ID27606 entitled &quot;Differing /dev/random support requirements within Solaris[TM] Operating Environments&quot;, available at &lt;a href=&quot;http://sunsolve.sun.com&quot;&gt;http://sunsolve.sun.com&lt;/a&gt; .</source>
          <target state="translated">Net :: SSLeay에는 / dev / urandom이 있어야합니다. 이 장치는 Solaris 9부터 사용할 수 있습니다. 이전 Solaris 버전의 경우 SUNWski 패키지 (Solaris 서버 인트라넷 확장의 일부인 Sun WebServer 또는 ISP for Solaris의 일부인 Sun Directory Services와 같은 여러 Sun 소프트웨어 제품과 함께 패키지로 제공됨)를 다운로드하거나 ANDIrand에서 패키지 &lt;a href=&quot;http://www.cosy.sbg.ac.at/~andi/&quot;&gt;http://www.cosy.sbg.ac.at/~andi/&lt;/a&gt; . SUNWski를 사용하는 경우 / dev / random을 가리키는 심볼릭 링크 / dev / urandom을 만드십시오. 자세한 내용은 &lt;a href=&quot;http://sunsolve.sun.com&quot;&gt;http://sunsolve.sun.com에있는&lt;/a&gt; &quot;Solaris [TM] 운영 환경의 다른 / dev / random 지원 요구 사항&quot;이라는 제목의 문서 ID27606을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="102b884f179ead18ed0a96b3577140ffb3aa57c6" translate="yes" xml:space="preserve">
          <source>Net::Time</source>
          <target state="translated">Net::Time</target>
        </trans-unit>
        <trans-unit id="d4f2b1be39e8c9f5b26b24988447cbc89c5fc6f8" translate="yes" xml:space="preserve">
          <source>Net::Time - time and daytime network client interface</source>
          <target state="translated">Net :: 시간-시간 및 주간 네트워크 클라이언트 인터페이스</target>
        </trans-unit>
        <trans-unit id="a529af9268e6c0617479c607894ba89216a5cc4f" translate="yes" xml:space="preserve">
          <source>Net::hostent</source>
          <target state="translated">Net::hostent</target>
        </trans-unit>
        <trans-unit id="98b632aa79485958bf201436fd61cedb7d0ac34a" translate="yes" xml:space="preserve">
          <source>Net::hostent - by-name interface to Perl's built-in gethost*() functions</source>
          <target state="translated">Net :: hostent-Perl의 내장 gethost * () 함수에 대한 이름 별 인터페이스</target>
        </trans-unit>
        <trans-unit id="04ad5a37dedb3b744b15bac4ca7302257a051aef" translate="yes" xml:space="preserve">
          <source>Net::netent</source>
          <target state="translated">Net::netent</target>
        </trans-unit>
        <trans-unit id="1fbeb7dc05a497d734af7f7775d02430de2ab805" translate="yes" xml:space="preserve">
          <source>Net::netent - by-name interface to Perl's built-in getnet*() functions</source>
          <target state="translated">Net :: netent-Perl의 내장 getnet * () 함수에 대한 이름 별 인터페이스</target>
        </trans-unit>
        <trans-unit id="7f1cdba311d5959633cf045aa60bf446ccf54af8" translate="yes" xml:space="preserve">
          <source>Net::protoent</source>
          <target state="translated">Net::protoent</target>
        </trans-unit>
        <trans-unit id="078ad82faa206681ea192cb93b449ee403fbdf7a" translate="yes" xml:space="preserve">
          <source>Net::protoent - by-name interface to Perl's built-in getproto*() functions</source>
          <target state="translated">Net :: protoent-Perl의 내장 getproto * () 함수에 대한 이름 별 인터페이스</target>
        </trans-unit>
        <trans-unit id="c5f4c3e0d467febed569e1767ca88a110ec104d8" translate="yes" xml:space="preserve">
          <source>Net::servent</source>
          <target state="translated">Net::servent</target>
        </trans-unit>
        <trans-unit id="7e6a54f9191b9c026dff4416eca28d52185f8a20" translate="yes" xml:space="preserve">
          <source>Net::servent - by-name interface to Perl's built-in getserv*() functions</source>
          <target state="translated">Net :: servent-Perl의 내장 getserv * () 함수에 대한 이름 별 인터페이스</target>
        </trans-unit>
        <trans-unit id="c5264f1d295bd0d284bab240b5d586bcd3e69efe" translate="yes" xml:space="preserve">
          <source>NetConfig VALUES</source>
          <target state="translated">NetConfig 값</target>
        </trans-unit>
        <trans-unit id="e17b1a34870d3dc76ed5ed6dddba8f1f23174d27" translate="yes" xml:space="preserve">
          <source>Network Command class (as used by FTP, SMTP etc)</source>
          <target state="translated">네트워크 명령 클래스 (FTP, SMTP 등에서 사용)</target>
        </trans-unit>
        <trans-unit id="c1cb4106aaf9e962404483234251f265e659ef77" translate="yes" xml:space="preserve">
          <source>Network File System, which allows you to mount a remote filesystem as if it were local.</source>
          <target state="translated">원격 파일 시스템을 마치 로컬 인 것처럼 마운트 할 수있는 네트워크 파일 시스템.</target>
        </trans-unit>
        <trans-unit id="1e91748557010f07119a40ac844fcae91cc2e7a3" translate="yes" xml:space="preserve">
          <source>Networking</source>
          <target state="translated">Networking</target>
        </trans-unit>
        <trans-unit id="1732a8d9a671f491b3444f4dd135a29f1c8db726" translate="yes" xml:space="preserve">
          <source>Networking constants and support functions</source>
          <target state="translated">네트워킹 상수 및 지원 기능</target>
        </trans-unit>
        <trans-unit id="3efe51707d515bbc55ed5e7a197cc135de39695b" translate="yes" xml:space="preserve">
          <source>Networking, Device Control (modems) and InterProcess Communication</source>
          <target state="translated">네트워킹, 장치 제어 (모뎀) 및 프로세스 간 통신</target>
        </trans-unit>
        <trans-unit id="f7865ee5f52b156bb53526c08f3154f5493c0e67" translate="yes" xml:space="preserve">
          <source>Neutralizes an op when it is no longer needed, but is still linked to from other ops.</source>
          <target state="translated">더 이상 필요하지 않은 op를 중립화하지만 여전히 다른 ops와 연결되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d9cdfd72ef200657927c8b92328d8203f7e523d" translate="yes" xml:space="preserve">
          <source>Never add a comma after &lt;code&gt;pTHX&lt;/code&gt; yourself--always use the form of the macro with the underscore for functions that take explicit arguments, or the form without the argument for functions with no explicit arguments.</source>
          <target state="translated">&lt;code&gt;pTHX&lt;/code&gt; 뒤에 쉼표를 추가하지 마십시오. 항상 명시적인 인수를 취하는 함수의 경우 밑줄과 함께 매크로 형식을 사용하거나 명시적인 인수가없는 함수의 경우 인수가없는 형식을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5435ce11aa44af4272570c0064637abeeb8634e2" translate="yes" xml:space="preserve">
          <source>Never forget that the &lt;code&gt;SVf_UTF8&lt;/code&gt; flag is separate from the PV value; you need to be sure you don't accidentally knock it off while you're manipulating SVs. More specifically, you cannot expect to do this:</source>
          <target state="translated">것을 잊지 마십시오 &lt;code&gt;SVf_UTF8&lt;/code&gt; 의 플래그는 PV 값 별개입니다; SV를 조작하는 동안 실수로 눌리지 않도록해야합니다. 더 구체적으로, 당신은 이것을 기대할 수 없습니다 :</target>
        </trans-unit>
        <trans-unit id="8b5cf307b4ec3e0ecc76a7852a46b24101becfd1" translate="yes" xml:space="preserve">
          <source>Never release anything (even a one-word documentation patch) without incrementing the number. Even a one-word documentation patch should result in a change in version at the sub-minor level.</source>
          <target state="translated">숫자를 늘리지 않고는 아무 것도 (한 단어로 된 문서 패치도) 해제하지 마십시오. 한 단어로 된 문서 패치라도 하위 수준에서 버전이 변경되어야합니다.</target>
        </trans-unit>
        <trans-unit id="6df5b2ef307f6a160a509c29570eb50079d5b0f1" translate="yes" xml:space="preserve">
          <source>New Things in this Example</source>
          <target state="translated">이 예의 새로운 것</target>
        </trans-unit>
        <trans-unit id="44dbbca1c816cd191c8bd8984ca3248c86453e2c" translate="yes" xml:space="preserve">
          <source>New digest implementations should consider subclassing from &lt;a href=&quot;digest/base&quot;&gt;Digest::base&lt;/a&gt;.</source>
          <target state="translated">새로운 다이제스트 구현에서는 &lt;a href=&quot;digest/base&quot;&gt;Digest :: base의&lt;/a&gt; 서브 클래 싱을 고려해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="8b1da49e0f3f02f18a191c8fcb01275608dfe945" translate="yes" xml:space="preserve">
          <source>New features and extensions to the language can be contentious. There is no specific set of criteria which determine what features get added, but here are some questions to consider when developing a patch:</source>
          <target state="translated">언어에 대한 새로운 기능과 확장은 논쟁의 여지가 있습니다. 추가 할 기능을 결정하는 특정 기준은 없지만 패치를 개발할 때 고려해야 할 몇 가지 질문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9da95c014dd8883747091781d4d6ca60e675421a" translate="yes" xml:space="preserve">
          <source>New form, no specials, outside O framework:</source>
          <target state="translated">O 프레임 워크 외부의 새로운 형태, 특별한 사항 없음 :</target>
        </trans-unit>
        <trans-unit id="be71b0b9cb949acf4db96e41224f4fef5adee91f" translate="yes" xml:space="preserve">
          <source>New in v5.22, &lt;a href=&quot;re#'strict'-mode&quot;&gt;use re 'strict' &lt;/a&gt; applies stricter rules than otherwise when compiling regular expression patterns. It can find things that, while legal, may not be what you intended.</source>
          <target state="translated">v5.22의 새로운 기능인 &lt;a href=&quot;re#'strict'-mode&quot;&gt;re 'strict'를 사용&lt;/a&gt; 하면 정규 표현식 패턴을 컴파일 할 때보 다 엄격한 규칙이 적용됩니다. 합법적이지만 의도하지 않은 것을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="395e14e59421d33f95e93938d8513a500819f2e7" translate="yes" xml:space="preserve">
          <source>New in v5.22, this applies stricter rules than otherwise when compiling regular expression patterns. It can find things that, while legal, may not be what you intended.</source>
          <target state="translated">v5.22의 새로운 기능으로, 정규 표현식 패턴을 컴파일 할 때보 다 규칙이 더 엄격합니다. 합법적이지만 의도하지 않은 것을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6ba249fed1974d4b07df4d7258092eb5b6e28d9" translate="yes" xml:space="preserve">
          <source>New releases of maintenance branches should only contain changes that fall into one of the &quot;acceptable&quot; categories set out below, but must not contain any changes that fall into one of the &quot;unacceptable&quot; categories. (For example, a fix for a crashing bug must not be included if it breaks binary compatibility.)</source>
          <target state="translated">유지 보수 지점의 새 릴리스에는 아래에 설명 된 &quot;허용 가능한&quot;범주 중 하나에 해당하는 변경 사항 만 포함해야하지만 &quot;허용 할 수없는&quot;범주 중 하나에 해당하는 변경 사항은 포함해서는 안됩니다. 예를 들어, 이진 호환성을 깨 뜨리면 충돌하는 버그에 대한 수정 프로그램이 포함되어서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="795ece357da263bd94bd3808d4fa48fca182a70d" translate="yes" xml:space="preserve">
          <source>New syntax and semantics which don't break existing language constructs and syntax have a much lower bar. They merely need to prove themselves to be useful, elegant, well designed, and well tested. In most cases, these additions will be marked as</source>
          <target state="translated">기존 언어 구성과 구문을 깨뜨리지 않는 새로운 구문과 의미는 훨씬 더 낮습니다. 그들은 유용하고, 우아하고, 잘 설계되고, 잘 테스트되었다는 것을 증명하기 만하면됩니다. 대부분의 경우 이러한 추가 사항은</target>
        </trans-unit>
        <trans-unit id="4fb820941ba4424da4c1818abae06d75b8cd8521" translate="yes" xml:space="preserve">
          <source>New versions of dual-life modules should NOT be imported into maint. Those belong in the next stable series.</source>
          <target state="translated">새 버전의 이중 수명 모듈을 메인으로 가져 와서는 안됩니다. 그것들은 다음 안정적인 시리즈에 속합니다.</target>
        </trans-unit>
        <trans-unit id="231604734d2d979c77600cba2319f1623c551b25" translate="yes" xml:space="preserve">
          <source>New() and Copy() are unfortunately used by both Symbian and Perl code so you'll have to play cpp games if you need them. PerlBase.h undefines the Perl definitions and redefines them as PerlNew() and PerlCopy().</source>
          <target state="translated">안타깝게도 New () 및 Copy ()는 Symbian 및 Perl 코드에서 모두 사용되므로 필요할 경우 cpp 게임을해야합니다. PerlBase.h는 Perl 정의를 정의 해제하고이를 PerlNew () 및 PerlCopy ()로 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="81e452125a72a6fe6ff7abcdeebcf00242e0de29" translate="yes" xml:space="preserve">
          <source>New, in 1.96, a hash that clusters known perl releases by their major versions.</source>
          <target state="translated">1.96의 새로운 기능으로 알려진 펄 릴리스를 주요 버전으로 클러스터링합니다.</target>
        </trans-unit>
        <trans-unit id="972a5d24a8408b783c69c2ea8d49e34b9b7c8c94" translate="yes" xml:space="preserve">
          <source>New-style form:</source>
          <target state="translated">새로운 스타일 :</target>
        </trans-unit>
        <trans-unit id="bc90c268bb4cb375e6b7a75ff03116a6ae0e5fb9" translate="yes" xml:space="preserve">
          <source>Newer releases of VOS (OpenVOS Release 17.0 or later) support a feature known as extended names. On these releases, file names can contain up to 255 characters, are prohibited from starting with a &lt;code&gt;-&lt;/code&gt; character, and the set of prohibited characters is reduced to any character matching &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/#%*&amp;lt;&amp;gt;?//&lt;/a&gt;&lt;/code&gt;. There are restrictions involving spaces and apostrophes: these characters must not begin or end a name, nor can they immediately precede or follow a period. Additionally, a space must not immediately precede another space or hyphen. Specifically, the following character combinations are prohibited: space-space, space-hyphen, period-space, space-period, period-apostrophe, apostrophe-period, leading or trailing space, and leading or trailing apostrophe. Although an extended file name is limited to 255 characters, a path name is still limited to 256 characters.</source>
          <target state="translated">VOS의 최신 릴리스 (OpenVOS 릴리스 17.0 이상)는 확장 이름이라는 기능을 지원합니다. 이 릴리스에서 파일 이름은 최대 255자를 포함 할 수 있으며 &lt;code&gt;-&lt;/code&gt; 문자로 시작할 수 없으며 금지 문자 세트는 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/#%*&amp;lt;&amp;gt;?//&lt;/a&gt;&lt;/code&gt; 일치하는 문자로 줄어 듭니다.. 공백과 아포스트로피와 관련된 제한 사항이 있습니다.이 문자는 이름을 시작하거나 종료해서는 안되며 마침표 바로 앞이나 뒤에 올 수 없습니다. 또한 공백이 다른 공백이나 하이픈 바로 앞에 오지 않아야합니다. 특히 공백, 공백 하이픈, 기간 공백, 공백 기간, 아포스트로피, 아포스트로피 기간, 선행 또는 후행 공백 및 선행 또는 후행 아포스트로피와 같은 문자 조합이 금지됩니다. 확장 파일 이름은 255 자로 제한되지만 경로 이름은 여전히 ​​256 자로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="048adf5652fc133a2fe5a581a0402744d96b2a3a" translate="yes" xml:space="preserve">
          <source>Newline (&lt;code&gt;\n&lt;/code&gt; ) is translated as &lt;code&gt;\015\012&lt;/code&gt; by STDIO when reading from and writing to files (see &lt;a href=&quot;#Newlines&quot;&gt;Newlines&lt;/a&gt;). &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode(FILEHANDLE)&lt;/a&gt;&lt;/code&gt; will keep &lt;code&gt;\n&lt;/code&gt; translated as &lt;code&gt;\012&lt;/code&gt; for that filehandle. Since it is a no-op on other systems, &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; should be used for cross-platform code that deals with binary data. That's assuming you realize in advance that your data is in binary. General-purpose programs should often assume nothing about their data.</source>
          <target state="translated">줄 바꿈 ( &lt;code&gt;\n&lt;/code&gt; )로 번역 &lt;code&gt;\015\012&lt;/code&gt; 에서 읽기 및 파일 (참조에 기록 할 때 STDIO으로 &lt;a href=&quot;#Newlines&quot;&gt;줄 바꿈&lt;/a&gt; ). &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode(FILEHANDLE)&lt;/a&gt;&lt;/code&gt; 는 해당 파일 핸들에 대해 &lt;code&gt;\n&lt;/code&gt; 을 &lt;code&gt;\012&lt;/code&gt; 로 번역 된 상태로 유지 합니다. 다른 시스템에서는 no-op이므로 바이너리 모드를 처리하는 크로스 플랫폼 코드 에는 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 를 사용해야합니다. 데이터가 이진 파일임을 미리 알고 있다고 가정합니다. 범용 프로그램은 종종 데이터에 대해 아무 것도 가정하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="7903c1910fd26e6355fca4a3a2873689173f8fa4" translate="yes" xml:space="preserve">
          <source>Newlines</source>
          <target state="translated">Newlines</target>
        </trans-unit>
        <trans-unit id="627f688311b36f3c91aca584369635de1f066e06" translate="yes" xml:space="preserve">
          <source>News sites</source>
          <target state="translated">뉴스 사이트</target>
        </trans-unit>
        <trans-unit id="3ad9cf64efb1ec1fd62f31a781211fbbae056b26" translate="yes" xml:space="preserve">
          <source>Next the fileglob &lt;code&gt;*.tar.gz&lt;/code&gt; is transformed behind the scenes into a full Perl regular expression, with the additional step of wrapping each transformed wildcard metacharacter sequence in parenthesis.</source>
          <target state="translated">그런 다음 fileglob &lt;code&gt;*.tar.gz&lt;/code&gt; 는 장면 뒤에서 전체 Perl 정규식으로 변환되며 변환 된 각 와일드 카드 메타 문자 시퀀스를 괄호로 묶는 추가 단계가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1dd107a1441fbf81bd2a151e1d1ce3a7c6dd7ff9" translate="yes" xml:space="preserve">
          <source>Next we tell Perl to update the global stack pointer from our internal variable: &lt;code&gt;dSP&lt;/code&gt; only gave us a local copy, not a reference to the global.</source>
          <target state="translated">다음으로 Perl에게 내부 변수에서 전역 스택 포인터를 업데이트하라고 지시합니다. &lt;code&gt;dSP&lt;/code&gt; 는 전역에 대한 참조가 아닌 로컬 사본 만 제공했습니다.</target>
        </trans-unit>
        <trans-unit id="783f6fb233a2d3b4a2bd0d885d732e1060c3e708" translate="yes" xml:space="preserve">
          <source>Next, both &lt;code&gt;filter_read&lt;/code&gt; and &lt;code&gt;filter_read_exact&lt;/code&gt; will append any source data that is read to the end of &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">다음으로 &lt;code&gt;filter_read&lt;/code&gt; 와 &lt;code&gt;filter_read_exact&lt;/code&gt; 는 &lt;code&gt;$_&lt;/code&gt; 의 끝에 읽히는 모든 소스 데이터를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="398d2fa0903d1a4262e38cb8eb6340d631516bf9" translate="yes" xml:space="preserve">
          <source>Next, having examined the program for</source>
          <target state="translated">다음으로, 프로그램을 검토 한 후</target>
        </trans-unit>
        <trans-unit id="552813864fdd734e7d3907009afd77e400d86761" translate="yes" xml:space="preserve">
          <source>Next, in line 7, we construct the interpreter using perl_construct, also in</source>
          <target state="translated">다음으로 7 행에서 perl_construct를 사용하여 인터프리터를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="fa8efbc1a7cdd184e2054cd4a6e7618c9a7c54c2" translate="yes" xml:space="preserve">
          <source>Next, we come to XPUSHs. This is where the parameters actually get pushed onto the stack. In this case we are pushing a string and an integer.</source>
          <target state="translated">다음으로 XPUSH에 왔습니다. 여기서 매개 변수가 실제로 스택으로 푸시됩니다. 이 경우 문자열과 정수를 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="3a3933ffb575f6d148ec34824fe349c3e318f912" translate="yes" xml:space="preserve">
          <source>Next, we create the filter object and associate it with the source stream by defining the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; function. If you know Perl well enough, you know that &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; is called automatically every time a module is included with a use statement. This makes &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; the ideal place to both create and install a filter object.</source>
          <target state="translated">다음으로 필터 객체를 작성하고 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 기능 을 정의하여 소스 스트림과 연관 시킵니다. Perl을 충분히 알고 있으면 모듈이 use 문에 포함될 때마다 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 가 자동으로 호출됩니다. 따라서 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 통해 필터 개체를 만들고 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e79dac3470efd6c09749fb5bc8d5df733f8598af" translate="yes" xml:space="preserve">
          <source>Next. Executes over subroutine calls, until the beginning of the next statement. If an expression is supplied that includes function calls, those functions will be executed with stops before each statement.</source>
          <target state="translated">다음. 다음 명령문이 시작될 때까지 서브 루틴 호출을 통해 실행합니다. 함수 호출을 포함하는 표현식이 제공되면 해당 함수는 각 명령문 전에 중지와 함께 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="0f90871213344aaacc3e3fb157cf776edfa434b0" translate="yes" xml:space="preserve">
          <source>Nicholas Clark &amp;lt;nick@ccl4.org&amp;gt;</source>
          <target state="translated">니콜라스 클라크 &amp;lt;nick@ccl4.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="3593afcaf4055fb7e2ec7f9aa19266c706c63d66" translate="yes" xml:space="preserve">
          <source>Nicholas Clark &amp;lt;nick@ccl4.org&amp;gt; based on the code in &lt;code&gt;h2xs&lt;/code&gt; by Larry Wall and others</source>
          <target state="translated">Larry Wall 등의 &lt;code&gt;h2xs&lt;/code&gt; 코드에 기반한 Nicholas Clark &amp;lt;nick@ccl4.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="a9782aaa85e48d0ee97008381a9233aaf9ea098e" translate="yes" xml:space="preserve">
          <source>Nicholas Clark &amp;lt;nick@ccl4.org&amp;gt;, collating wisdom supplied by Slaven Rezic and Tim Bunce.</source>
          <target state="translated">Slaven Rezic과 Tim Bunce가 제공 한 지혜를 조합 한 Nicholas Clark &amp;lt;nick@ccl4.org&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="cb93bd4a857943c414e6a9f67769487dd9d1e793" translate="yes" xml:space="preserve">
          <source>Nichols, Bradford, Dick Buttlar, and Jacqueline Proulx Farrell. Pthreads Programming. O'Reilly &amp;amp; Associates, 1996, ISBN 156592-115-1 (covers POSIX threads).</source>
          <target state="translated">Nichols, Bradford, Dick Buttlar 및 Jacqueline Proulx Farrell. Pthreads 프로그래밍. O'Reilly &amp;amp; Associates, 1996, ISBN 156592-115-1 (POSIX 스레드 포함).</target>
        </trans-unit>
        <trans-unit id="dc9a977deb5f6413937851a1c224335497c37077" translate="yes" xml:space="preserve">
          <source>Nick Ing-Simmons &amp;lt;nick@ing-simmons.net&amp;gt;</source>
          <target state="translated">Nick Ing-Simmons &amp;lt;nick@ing-simmons.net&amp;gt;</target>
        </trans-unit>
        <trans-unit id="67fa933da77de5810dcb7a6bcbb7b43316cb56e6" translate="yes" xml:space="preserve">
          <source>Nick Ing-Simmons &amp;lt;nik@tiuk.ti.com&amp;gt;</source>
          <target state="translated">닉 잉 시몬스 &amp;lt;nik@tiuk.ti.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="eec2116258d414025ff37d21592a6d975d4f492d" translate="yes" xml:space="preserve">
          <source>Nick Ing-Simmons &lt;code&gt;ni-s@cpan.org&lt;/code&gt;</source>
          <target state="translated">Nick Ing-Simmons &lt;code&gt;ni-s@cpan.org&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f536379f776769e044b6352a1f333a7395148608" translate="yes" xml:space="preserve">
          <source>Nick Ing-Simmons nik@tiuk.ti.com</source>
          <target state="translated">Nick Ing-Simmons nik@tiuk.ti.com</target>
        </trans-unit>
        <trans-unit id="709b6991a1fe1d878c07948361b2e8f12dee5b31" translate="yes" xml:space="preserve">
          <source>Nick.Williams (at) morganstanley.com</source>
          <target state="translated">Nick.Williams (at) morganstanley.com</target>
        </trans-unit>
        <trans-unit id="99442825b1535fca48dbbe1edab7783b86c33c79" translate="yes" xml:space="preserve">
          <source>Nifty, eh?</source>
          <target state="translated">괜찮아?</target>
        </trans-unit>
        <trans-unit id="8f28e5786c054d1cc29342757d2fd0556c7c2dc7" translate="yes" xml:space="preserve">
          <source>No &quot;=over&quot; ... &quot;=back&quot; region can contain headings. Processors may treat such a heading as an error.</source>
          <target state="translated">&quot;= over&quot;... &quot;= back&quot;영역은 제목을 포함 할 수 없습니다. 프로세서는 이러한 제목을 오류로 취급 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="773b9688face4b5d00611d86533f2b8de906c9b4" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;syslog&lt;/code&gt; before &lt;code&gt;openlog&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;openlog&lt;/code&gt; 전에 &lt;code&gt;syslog&lt;/code&gt; 가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="8c40a7affe9719b4eddb6cf9132e5c95c3be4c0e" translate="yes" xml:space="preserve">
          <source>No C++ style (//) comments</source>
          <target state="translated">C ++ 스타일 (//) 주석이 없습니다.</target>
        </trans-unit>
        <trans-unit id="c2fcbc48a21b7232a53284d0488360e346f1c2a5" translate="yes" xml:space="preserve">
          <source>No Parameters, Nothing Returned</source>
          <target state="translated">매개 변수 없음, 반환 된 내용 없음</target>
        </trans-unit>
        <trans-unit id="daaba0fb2bb1fc76d3a62f4fc39307ed0a310b2d" translate="yes" xml:space="preserve">
          <source>No adjustments are needed to entries that are references to arrays; each such entry will have exactly one element in its range, so the offset is always 0.</source>
          <target state="translated">배열을 참조하는 항목은 조정할 필요가 없습니다. 이러한 각 항목의 범위에는 정확히 하나의 요소가 있으므로 오프셋은 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="87c881d12dc16380a72b9169dc66bd4762923e70" translate="yes" xml:space="preserve">
          <source>No arbitrary limits (platforms, data sizes, cultures).</source>
          <target state="translated">임의의 제한 (플랫폼, 데이터 크기, 문화)이 없습니다.</target>
        </trans-unit>
        <trans-unit id="2ef060e66ed128ce859a264cbcabcc9e8b4d72cd" translate="yes" xml:space="preserve">
          <source>No attempt is made to resolve formatting codes. This must be done after calling parselink() (since E&amp;lt;&amp;gt; formatting codes can be used to escape characters that would otherwise be significant to the parser and resolving them before parsing would result in an incorrect parse of a formatting code like:</source>
          <target state="translated">형식화 코드를 해결하려고 시도하지 않습니다. 이는 parselink ()를 호출 한 후에 수행해야합니다. E &amp;lt;&amp;gt; 형식화 코드는 구문 분석기에 중요한 문자를 이스케이프하고 구문 분석하기 전에이를 해결하여 형식화 코드를 올바르지 않게 구문 분석 할 수 있기 때문에 사용할 수 있으므로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d91a990deb28c435bf7686103fcfb9b19073f56f" translate="yes" xml:space="preserve">
          <source>No attempt to call methods on a child after &lt;code&gt;finalize&lt;/code&gt; is called is guaranteed to succeed.</source>
          <target state="translated">&lt;code&gt;finalize&lt;/code&gt; 가 호출 된 후 자식에 대한 메소드 호출 시도 는 성공할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="25bf937dadf1f1511dd27eb2964f699a6c2252b1" translate="yes" xml:space="preserve">
          <source>No checks against the filesystem are made, so the result may not be correct if &lt;code&gt;$base&lt;/code&gt; contains symbolic links. (Apply &lt;a href=&quot;../../cwd#abs_path&quot;&gt;Cwd::abs_path()&lt;/a&gt; beforehand if that is a concern.) On VMS, there is interaction with the working environment, as logicals and macros are expanded.</source>
          <target state="translated">파일 시스템을 검사하지 않으므로 &lt;code&gt;$base&lt;/code&gt; 에 기호 링크가 있으면 결과가 정확하지 않을 수 있습니다. ( 관심이 있다면 &lt;a href=&quot;../../cwd#abs_path&quot;&gt;Cwd :: abs_path ()를&lt;/a&gt; 미리 적용하십시오 .) VMS에서는 논리 및 매크로가 확장됨에 따라 작업 환경과 상호 작용합니다.</target>
        </trans-unit>
        <trans-unit id="e4449b82a66db373f8a7a36f371aa0993e46c55c" translate="yes" xml:space="preserve">
          <source>No checks against the filesystem are made. On VMS, there is interaction with the working environment, as logicals and macros are expanded.</source>
          <target state="translated">파일 시스템을 검사하지 않습니다. VMS에서는 논리 및 매크로가 확장됨에 따라 작업 환경과 상호 작용합니다.</target>
        </trans-unit>
        <trans-unit id="784c301abbb8b0d6d45cf7e9b60c5e854fd2a0b2" translate="yes" xml:space="preserve">
          <source>No distinction is made between prefix and postfix forms of the increment and decrement operators: these differ only in the point at which Perl calls the associated subroutine when evaluating an expression.</source>
          <target state="translated">증분 및 감소 연산자의 접두사와 접미사 형식은 구별되지 않습니다. 이는 표현식을 평가할 때 Perl이 연관된 서브 루틴을 호출하는 지점에서만 다릅니다.</target>
        </trans-unit>
        <trans-unit id="6a6edce8008bb98711417eae932baa49a0c5e02c" translate="yes" xml:space="preserve">
          <source>No environment variables are used.</source>
          <target state="translated">환경 변수가 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2f86db3043e1779cce556c8cbf2a9d92caf05f24" translate="yes" xml:space="preserve">
          <source>No error is given if the unlink fails.</source>
          <target state="translated">연결 해제에 실패하면 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3f69a0eca515ffc8689bce47b2e5c1980b8dcb25" translate="yes" xml:space="preserve">
          <source>No exception will be thrown if the load fails.</source>
          <target state="translated">로드에 실패하면 예외가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ec5c0c5034b1d315d5f20a472cd293a01e6c64e1" translate="yes" xml:space="preserve">
          <source>No filename, no open.</source>
          <target state="translated">파일 이름이없고 열려 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="516bbd1a4dbc145932d17998cd4fb493e8a92e9f" translate="yes" xml:space="preserve">
          <source>No flags are currently defined for this method.</source>
          <target state="translated">이 메소드에는 현재 플래그가 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7bcf29927f72d2beb73b0553554252e7ba739e8a" translate="yes" xml:space="preserve">
          <source>No fork(), pipe(), popen() etc.</source>
          <target state="translated">포크 (), 파이프 (), 포펜 () 등 없음</target>
        </trans-unit>
        <trans-unit id="54075ccfb2214779b34385a718da12658fca1c0e" translate="yes" xml:space="preserve">
          <source>No interpolation is performed at this stage. Any backslashed sequences including &lt;code&gt;\\&lt;/code&gt; are treated at the stage to &lt;a href=&quot;#parsing-regular-expressions&quot;&gt;parsing regular expressions&lt;/a&gt;.</source>
          <target state="translated">이 단계에서는 보간이 수행되지 않습니다. &lt;code&gt;\\&lt;/code&gt; 를 포함한 모든 백 슬래시 시퀀스 는 스테이지에서 &lt;a href=&quot;#parsing-regular-expressions&quot;&gt;정규 표현식&lt;/a&gt; 을 구문 분석 하는 것으로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="cbb5249e03fe539ae8e45d7b163fcee5fc3ee51d" translate="yes" xml:space="preserve">
          <source>No interpolation is performed. Note that the combination &lt;code&gt;\\&lt;/code&gt; is left intact, since escaped delimiters are not available for here-docs.</source>
          <target state="translated">보간이 수행되지 않습니다. 이스케이프 구분 기호는 here-docs에서 사용할 수 없으므로 &lt;code&gt;\\&lt;/code&gt; 조합 은 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="5f4729e4c84e612c4062db3d2ec599e7d12e2ffa" translate="yes" xml:space="preserve">
          <source>No longer used. &lt;b&gt;pod2man&lt;/b&gt; used to check its input for validity as a manual page, but this should now be done by</source>
          <target state="translated">더 이상 사용되지 않습니다. &lt;b&gt;pod2man&lt;/b&gt; 은 입력이 매뉴얼 페이지인지 유효성을 검사하는 데 사용되었지만 이제는</target>
        </trans-unit>
        <trans-unit id="0629e5133982636c8b13ba7650a2f7adde66d5d2" translate="yes" xml:space="preserve">
          <source>No matter how many @methods you check, a single &lt;code&gt;can_ok()&lt;/code&gt; call counts as one test. If you desire otherwise, use:</source>
          <target state="translated">몇 개의 @ 메소드를 확인하더라도 단일 &lt;code&gt;can_ok()&lt;/code&gt; 호출은 하나의 테스트로 계산됩니다. 다른 방법을 원한다면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bfe1ac6dceccca23c12f88b98cb2baa17573ef5f" translate="yes" xml:space="preserve">
          <source>No matter how you look at it, Unicode support is going to be a pain in a regex engine. Tricks that might be fine when you have 256 possible characters often won't scale to handle the size of the UTF-8 character set. Things you can take for granted with ASCII may not be true with Unicode. For instance, in ASCII, it is safe to assume that &lt;code&gt;sizeof(char1) == sizeof(char2)&lt;/code&gt; , but in UTF-8 it isn't. Unicode case folding is vastly more complex than the simple rules of ASCII, and even when not using Unicode but only localised single byte encodings, things can get tricky (for example, &lt;b&gt;LATIN SMALL LETTER SHARP S&lt;/b&gt; (U+00DF, &amp;szlig;) should match 'SS' in localised case-insensitive matching).</source>
          <target state="translated">어떻게 보더라도 유니 코드 지원은 정규식 엔진에서 어려움이 될 것입니다. 256 개의 가능한 문자가있을 때 좋은 트릭은 종종 UTF-8 문자 세트의 크기를 처리하도록 확장되지 않습니다. ASCII로 당연한 것으로 받아 들일 수있는 것은 유니 코드에서는 사실이 아닐 수 있습니다. 예를 들어, ASCII에서는 &lt;code&gt;sizeof(char1) == sizeof(char2)&lt;/code&gt; 라고 가정하는 것이 안전 하지만 UTF-8에서는 그렇지 않습니다. 유니 코드 케이스 폴딩은 단순한 ASCII 규칙보다 훨씬 더 복잡하며 유니 코드를 사용하지 않고 지역화 된 단일 바이트 인코딩 만 사용하는 경우에도 까다로울 수 있습니다 (예 : &lt;b&gt;LATIN SMALL LETTER SHARP S&lt;/b&gt; (U + 00DF, &amp;szlig;)는 ' 지역화 된 대소 문자를 구분하지 않는 SS ').</target>
        </trans-unit>
        <trans-unit id="3134867d7de86de77f76195077742723406df400" translate="yes" xml:space="preserve">
          <source>No matter which locale you are in, the alphabetic characters are the characters in \w without the digits and the underscore. As a regex, that looks like &lt;code&gt;/[^\W\d_]/&lt;/code&gt; . Its complement, the non-alphabetics, is then everything in \W along with the digits and the underscore, or &lt;code&gt;/[\W\d_]/&lt;/code&gt; .</source>
          <target state="translated">어떤 로케일에 있든지 알파벳 문자는 숫자와 밑줄이없는 \ w의 문자입니다. 정규식으로서 &lt;code&gt;/[^\W\d_]/&lt;/code&gt; . 알파벳이 아닌 그 보완은 \ W의 모든 숫자와 밑줄 또는 &lt;code&gt;/[\W\d_]/&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ae36c800cf26b17c9be8f946b97ab972ec2e9993" translate="yes" xml:space="preserve">
          <source>No message is printed if there is a &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; handler installed. It is the handler's responsibility to deal with the message as it sees fit (like, for instance, converting it into a &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;). Most handlers must therefore arrange to actually display the warnings that they are not prepared to deal with, by calling &lt;code&gt;&lt;a href=&quot;warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; again in the handler. Note that this is quite safe and will not produce an endless loop, since &lt;code&gt;__WARN__&lt;/code&gt; hooks are not called from inside one.</source>
          <target state="translated">&lt;code&gt;$SIG{__WARN__}&lt;/code&gt; 핸들러가 설치되어 있으면 메시지가 인쇄되지 않습니다 . 메시지가 적합하다고 판단되면 (예를 들어, 메시지를 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 로 변환하는) 처리기의 책임 입니다. 따라서 대부분의 처리기는 처리기에서 다시 &lt;code&gt;&lt;a href=&quot;warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; 를 호출하여 처리 할 준비가되지 않은 경고를 실제로 표시하도록 정렬해야 합니다. &lt;code&gt;__WARN__&lt;/code&gt; 후크는 내부에서 호출되지 않기 때문에 이것은 매우 안전하며 무한 루프를 생성 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9b68ebf47dc665b9110abca7286c7dd8e3c6d25d" translate="yes" xml:space="preserve">
          <source>No message is printed if there is a &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; handler installed. It is the handler's responsibility to deal with the message as it sees fit (like, for instance, converting it into a &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;). Most handlers must therefore arrange to actually display the warnings that they are not prepared to deal with, by calling &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; again in the handler. Note that this is quite safe and will not produce an endless loop, since &lt;code&gt;__WARN__&lt;/code&gt; hooks are not called from inside one.</source>
          <target state="translated">&lt;code&gt;$SIG{__WARN__}&lt;/code&gt; 핸들러가 설치되어 있으면 메시지가 인쇄되지 않습니다 . 메시지가 적합하다고 판단되면 (예를 들어, 메시지를 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 로 변환하는) 처리기의 책임 입니다. 따라서 대부분의 처리기는 처리기에서 다시 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; 를 호출하여 처리 할 준비가되지 않은 경고를 실제로 표시하도록 정렬해야 합니다. &lt;code&gt;__WARN__&lt;/code&gt; 후크는 내부에서 호출되지 않기 때문에 이것은 매우 안전하며 무한 루프를 생성 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e88b0403f1df2a8394109aa2ba7bcbd6c0d574ec" translate="yes" xml:space="preserve">
          <source>No method will be exported.</source>
          <target state="translated">메소드가 내보내지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1b3f29207dc255b3e7e3b93af35cd32bc4da582b" translate="yes" xml:space="preserve">
          <source>No nested {}</source>
          <target state="translated">중첩 된 {} 없음</target>
        </trans-unit>
        <trans-unit id="108ebc6ec894325dc5e51ade6db8ba3a4fcfc3e6" translate="yes" xml:space="preserve">
          <source>No one is actively supporting Perl 4. Ten years ago it was a dead camel carcass (according to this document). Now it's barely a skeleton as its whitewashed bones have fractured or eroded.</source>
          <target state="translated">아무도 Perl 4를 적극적으로지지하고 있지 않습니다. 10 년 전 (이 문서에 따르면) 죽은 낙타 시체였습니다. 이제는 씻은 뼈가 골절되거나 침식되면서 골격이 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="d9c3fd86cbf458846a9ad5dbc11cfba132cabd89" translate="yes" xml:space="preserve">
          <source>No parentheses are permitted. This feature is particularly useful for arrays-of-arrays, or arrays-of-hashes:</source>
          <target state="translated">괄호는 허용되지 않습니다. 이 기능은 배열 배열 또는 해시 배열에 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="469f8dede736caee70cee54e55a8464dbb9835e1" translate="yes" xml:space="preserve">
          <source>No physical check on the filesystem, but a logical cleanup of a path.</source>
          <target state="translated">파일 시스템을 물리적으로 검사하지 않고 경로를 논리적으로 정리합니다.</target>
        </trans-unit>
        <trans-unit id="3f4690d39fc8f180a0deea49e5cf7ef07d678475" translate="yes" xml:space="preserve">
          <source>No physical check on the filesystem, but a logical cleanup of a path. On UNIX eliminated successive slashes and successive &quot;/.&quot;.</source>
          <target state="translated">파일 시스템을 물리적으로 검사하지 않고 경로를 논리적으로 정리합니다. UNIX에서는 연속적인 슬래시와 &quot;/.&quot;를 제거했습니다.</target>
        </trans-unit>
        <trans-unit id="3f5d3240e92f64678ad0b020e9e7b82b4f021ec1" translate="yes" xml:space="preserve">
          <source>No physical check on the filesystem, but a logical cleanup of a path. On UNIX eliminated successive slashes and successive &quot;/.&quot;. On Win32 makes</source>
          <target state="translated">파일 시스템을 물리적으로 검사하지 않고 경로를 논리적으로 정리합니다. UNIX에서는 연속적인 슬래시와 &quot;/.&quot;를 제거했습니다. Win32에서</target>
        </trans-unit>
        <trans-unit id="3ec2594a24cace2c7fc57252c4edc36c0995f1d6" translate="yes" xml:space="preserve">
          <source>No physical check on the filesystem, but a logical cleanup of a path. On UNIX eliminates successive slashes and successive &quot;/.&quot;.</source>
          <target state="translated">파일 시스템을 물리적으로 검사하지 않고 경로를 논리적으로 정리합니다. UNIX에서는 연속적인 슬래시와 연속적인 &quot;/&quot;를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="05e49343d906c08823451bc90b39a76fd921c7fa" translate="yes" xml:space="preserve">
          <source>No separator between a directory path and a filename on VMS.</source>
          <target state="translated">VMS에서 디렉토리 경로와 파일 이름 사이에 구분 기호가 없습니다.</target>
        </trans-unit>
        <trans-unit id="752ae710f92402615f714f07f2df83c92aef3774" translate="yes" xml:space="preserve">
          <source>No space before the semicolon.</source>
          <target state="translated">세미콜론 앞에 공백이 없습니다.</target>
        </trans-unit>
        <trans-unit id="a57f317b57b3c0adf52cf25451dee19e20c69fd1" translate="yes" xml:space="preserve">
          <source>No space between function name and its opening parenthesis.</source>
          <target state="translated">함수 이름과 여는 괄호 사이에 공백이 없습니다.</target>
        </trans-unit>
        <trans-unit id="1a6856f52acb86fb9730291ce342f9738b29e5d3" translate="yes" xml:space="preserve">
          <source>No such build tool exists. Even make itself has wildly different dialects. So we have to build our own.</source>
          <target state="translated">이러한 빌드 도구가 없습니다. 심지어는 그 자체가 사투리를 크게 다르게 만듭니다. 그래서 우리는 우리 자신을 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="983c1355341f06fa836a2941ebb4e0c8331361de" translate="yes" xml:space="preserve">
          <source>No such thing. Just use a &lt;b&gt;lexical variable&lt;/b&gt; in a scope larger than your &lt;b&gt;subroutine&lt;/b&gt;, or declare it with &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; instead of with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그런 것은 없습니다. &lt;b&gt;서브 루틴&lt;/b&gt; 보다 큰 범위에서 &lt;b&gt;어휘 변수&lt;/b&gt; 를 사용 하거나 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 로 선언하십시오 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="dfee1d82923df34ecbc3757eed0d1a71f22fdeb9" translate="yes" xml:space="preserve">
          <source>No such thing. See &lt;b&gt;class method&lt;/b&gt;.</source>
          <target state="translated">그런 것은 없습니다. &lt;b&gt;class method를&lt;/b&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="24ad36b7a10baca2137d3e182796c8fa973e83aa" translate="yes" xml:space="preserve">
          <source>No such thing. See &lt;b&gt;lexical scoping&lt;/b&gt;.</source>
          <target state="translated">그런 것은 없습니다. &lt;b&gt;어휘 범위 지정을&lt;/b&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3f5436248a66b44ec28a7a07c44cb765383f5e61" translate="yes" xml:space="preserve">
          <source>No suspects left</source>
          <target state="translated">남은 용의자 없음</target>
        </trans-unit>
        <trans-unit id="0b0e3c47f8113fc69c5db2a844ca423a0b0e626d" translate="yes" xml:space="preserve">
          <source>No symbolic constants are required by this IO::Compress::Bzip2 at present.</source>
          <target state="translated">현재이 IO :: Compress :: Bzip2에는 기호 상수가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="295b36facbdc6f1e39ae12ab91f921909acbf35a" translate="yes" xml:space="preserve">
          <source>No symbolic constants are required by this IO::Uncompress::AnyInflate at present.</source>
          <target state="translated">현재이 IO :: Uncompress :: AnyInflate에는 기호 상수가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ee09f98ed165e0824d6ef187752ca356d22dda0" translate="yes" xml:space="preserve">
          <source>No symbolic constants are required by this IO::Uncompress::AnyUncompress at present.</source>
          <target state="translated">현재이 IO :: Uncompress :: AnyUncompress에는 기호 상수가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="df24583254943b025a824682df0b1dfe399beb9d" translate="yes" xml:space="preserve">
          <source>No symbolic constants are required by this IO::Uncompress::Bunzip2 at present.</source>
          <target state="translated">현재이 IO :: Uncompress :: Bunzip2에는 기호 상수가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a69b3bd42bb22135230da30e5fa338a580834d5c" translate="yes" xml:space="preserve">
          <source>No symbolic constants are required by this IO::Uncompress::Gunzip at present.</source>
          <target state="translated">현재이 IO :: Uncompress :: Gunzip에는 기호 상수가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="035acb0d322011913fd5d41a102d38ed488eeb8f" translate="yes" xml:space="preserve">
          <source>No symbolic constants are required by this IO::Uncompress::Inflate at present.</source>
          <target state="translated">현재이 IO :: Uncompress :: Inflate에는 기호 상수가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b9be5deb4e19e7df3ae4108a6bf22723539a2cce" translate="yes" xml:space="preserve">
          <source>No symbolic constants are required by this IO::Uncompress::RawInflate at present.</source>
          <target state="translated">현재이 IO :: Uncompress :: RawInflate에는 기호 상수가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3c18d218923a1c749b134fb8b13b00be7f7f924f" translate="yes" xml:space="preserve">
          <source>No symbolic constants are required by this IO::Uncompress::Unzip at present.</source>
          <target state="translated">현재이 IO :: Uncompress :: Unzip에는 기호 상수가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c1bdd65afd19146fdce8e8b2d5e32c005beea617" translate="yes" xml:space="preserve">
          <source>No user-serviceable parts inside.</source>
          <target state="translated">내부에는 사용자가 수리 할 수있는 부품이 없습니다.</target>
        </trans-unit>
        <trans-unit id="67d5beb85edfab150b561584afd043236d2bdfa9" translate="yes" xml:space="preserve">
          <source>No variable interpolation occurs. String modifying combinations for case and quoting such as &lt;code&gt;\Q&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; , and &lt;code&gt;\E&lt;/code&gt; are not recognized. The other escape sequences such as &lt;code&gt;\200&lt;/code&gt; and &lt;code&gt;\t&lt;/code&gt; and backslashed characters such as &lt;code&gt;\\&lt;/code&gt; and &lt;code&gt;\-&lt;/code&gt; are converted to appropriate literals. The character &lt;code&gt;&quot;-&quot;&lt;/code&gt; is treated specially and therefore &lt;code&gt;\-&lt;/code&gt; is treated as a literal &lt;code&gt;&quot;-&quot;&lt;/code&gt; .</source>
          <target state="translated">변수 보간이 발생하지 않습니다. &lt;code&gt;\Q&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; 및 &lt;code&gt;\E&lt;/code&gt; 와 같이 대소 문자 및 따옴표에 대한 문자열 수정 조합 은 인식되지 않습니다. &lt;code&gt;\200&lt;/code&gt; 및 &lt;code&gt;\t&lt;/code&gt; 와 같은 다른 이스케이프 시퀀스와 &lt;code&gt;\\&lt;/code&gt; 및 &lt;code&gt;\-&lt;/code&gt; 와 같은 백 슬래시 문자 는 적절한 리터럴로 변환됩니다. 문자 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 는 특별하게 취급되므로 &lt;code&gt;\-&lt;/code&gt; 는 리터럴 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 로 취급됩니다 .</target>
        </trans-unit>
        <trans-unit id="344119823e9aa0a1230bde24e92b97b7e8c49b30" translate="yes" xml:space="preserve">
          <source>No, Data::Dumper's Unicode abilities are as they should be. There have been some complaints that it should restore the UTF8 flag when the data is read again with &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;. However, you should really not look at the flag, and nothing indicates that Data::Dumper should break this rule.</source>
          <target state="translated">아니요, Data :: Dumper의 유니 코드 기능은 그대로입니다. &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 을 사용 하여 데이터를 다시 읽을 때 UTF8 플래그를 복원해야한다는 불만이있었습니다 . 그러나 플래그를 실제로 보지 않아야하며 Data :: Dumper가이 규칙을 위반해야한다는 것을 나타내는 것은 없습니다.</target>
        </trans-unit>
        <trans-unit id="3a38c27dd7fd1fed994a63f940f365b3621c19f1" translate="yes" xml:space="preserve">
          <source>No, Perl is easy to start &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2flearn.perl.org%2f&quot;&gt;learning&lt;/a&gt; --and easy to keep learning. It looks like most programming languages you're likely to have experience with, so if you've ever written a C program, an awk script, a shell script, or even a BASIC program, you're already partway there.</source>
          <target state="translated">아니요, Perl은 &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2flearn.perl.org%2f&quot;&gt;배우기&lt;/a&gt; 쉽고 배우기 쉽습니다. 대부분의 프로그래밍 언어에 익숙한 것처럼 보이므로 C 프로그램, awk 스크립트, 쉘 스크립트 또는 BASIC 프로그램을 작성한 적이 있다면 이미 진행 중입니다.</target>
        </trans-unit>
        <trans-unit id="88ee7d9b8720b881699420ad9ccfc4e5c84c1947" translate="yes" xml:space="preserve">
          <source>No, and this isn't really a Unicode FAQ.</source>
          <target state="translated">아니요, 이것은 실제로 유니 코드 FAQ가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="15815b309727bddc8a8cd4e554a2b5a8e3e42f09" translate="yes" xml:space="preserve">
          <source>No-ops</source>
          <target state="translated">No-ops</target>
        </trans-unit>
        <trans-unit id="e12405068610495a8442e94ec628add88b178c22" translate="yes" xml:space="preserve">
          <source>Nobody else on the planet is going to talk your local data format, so we can ignore that. But what about the thing in the middle? Building tree structures from Perl variables and then traversing them is a nice, general problem, and if nobody's already written a module that does that, you might want to modularise that code too.</source>
          <target state="translated">지구상의 어느 누구도 귀하의 로컬 데이터 형식을 이야기하지 않으므로 무시할 수 있습니다. 그러나 중간에있는 것은 어떻습니까? Perl 변수에서 트리 구조를 작성하고 순회하는 것은 좋은 일반적인 문제이며, 아무도 그렇게하지 않는 모듈을 작성하지 않았다면 해당 코드도 모듈화해야합니다.</target>
        </trans-unit>
        <trans-unit id="7a1a9fd7bbb71ea26aa1056d5954e10f58509d69" translate="yes" xml:space="preserve">
          <source>Nokia is a registered trademark of Nokia Corporation. Nokia's product names are trademarks or registered trademarks of Nokia. Other product and company names mentioned herein may be trademarks or trade names of their respective owners.</source>
          <target state="translated">Nokia는 Nokia Corporation의 등록 상표입니다. Nokia의 제품 이름은 Nokia의 상표 또는 등록 상표입니다. 여기에 언급 된 기타 제품 및 회사 이름은 해당 소유자의 상표 또는 상표 이름 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce6966adb468edf0cb8841781f043cf41939dccf" translate="yes" xml:space="preserve">
          <source>Non-Existent Local Times (DST)</source>
          <target state="translated">존재하지 않는 현지 시간 (DST)</target>
        </trans-unit>
        <trans-unit id="c8c499b19de2058088ccd7be966c0ac655b7adf3" translate="yes" xml:space="preserve">
          <source>Non-Hash Objects</source>
          <target state="translated">비해시 객체</target>
        </trans-unit>
        <trans-unit id="78a4443d65a9907e689a96dad2b964b32204f4cf" translate="yes" xml:space="preserve">
          <source>Non-Unix users should check their &lt;code&gt;&lt;i&gt;Your_OS&lt;/i&gt;::Process&lt;/code&gt; module for other possible solutions.</source>
          <target state="translated">Unix 이외의 사용자는 &lt;code&gt;&lt;i&gt;Your_OS&lt;/i&gt;::Process&lt;/code&gt; 모듈에서 다른 가능한 솔루션을 확인해야 합니다.</target>
        </trans-unit>
        <trans-unit id="8955048c10f602a8fbda2fd5207694abb568decd" translate="yes" xml:space="preserve">
          <source>Non-bracketing delimiters use the same character fore and aft, but the four sorts of ASCII brackets (round, angle, square, curly) all nest, which means that</source>
          <target state="translated">대괄호가 아닌 구분 기호는 앞뒤에 동일한 문자를 사용하지만 네 가지 종류의 ASCII 괄호 (둥근, 각, 사각형, 중괄호)는 모두 중첩됩니다. 즉,</target>
        </trans-unit>
        <trans-unit id="d5ef8c3ef4f33bed9ce030f3cbfb6a9e3e9cf03b" translate="yes" xml:space="preserve">
          <source>Non-capturing groupings</source>
          <target state="translated">비 캡처 그룹화</target>
        </trans-unit>
        <trans-unit id="0b0affcbcf3b94afc7fed13853a23ba9ca1bafd7" translate="yes" xml:space="preserve">
          <source>Non-capturing groupings are also useful for removing nuisance elements gathered from a split operation where parentheses are required for some reason:</source>
          <target state="translated">캡처하지 않은 그룹화는 어떤 이유로 괄호가 필요한 분할 작업에서 수집 된 불필요한 요소를 제거하는 데에도 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e7e8c733eeb11ebeb19aea8f0c24bafd0dcd3b78" translate="yes" xml:space="preserve">
          <source>Non-function Keywords by Cross-reference</source>
          <target state="translated">상호 참조 별 기능이없는 키워드</target>
        </trans-unit>
        <trans-unit id="f81f5fe242ea0b94d3fcd14bf1f47ecae7e89c34" translate="yes" xml:space="preserve">
          <source>Non-interpretive attribute handlers</source>
          <target state="translated">해석 할 수없는 속성 핸들러</target>
        </trans-unit>
        <trans-unit id="e94d3362f237ca4afac6040875234c6b9fba0037" translate="yes" xml:space="preserve">
          <source>Non-lexical variables are quite difficult to track through a program. Sometimes the type of a non-lexical variable's use is impossible to determine. Introductions of non-lexical non-scalars don't seem to be reported properly.</source>
          <target state="translated">비 어휘 변수는 프로그램을 추적하기가 매우 어렵습니다. 어휘 적이 지 않은 변수의 유형을 결정하기 어려운 경우가 있습니다. 비-음수의 비-스칼라 소개는 제대로보고되지 않은 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="f6f78bf86e7669259f75fa7cb97ef1591cd4d731" translate="yes" xml:space="preserve">
          <source>Non-printable ASCII characters are represented by &lt;b&gt;escape sequences&lt;/b&gt;. Common examples are &lt;code&gt;\t&lt;/code&gt; for a tab, &lt;code&gt;\n&lt;/code&gt; for a newline, and &lt;code&gt;\r&lt;/code&gt; for a carriage return. Arbitrary bytes are represented by octal escape sequences, e.g., &lt;code&gt;\033&lt;/code&gt; , or hexadecimal escape sequences, e.g., &lt;code&gt;\x1B&lt;/code&gt; :</source>
          <target state="translated">인쇄 할 수없는 ASCII 문자는 &lt;b&gt;이스케이프 시퀀스&lt;/b&gt; 로 표시됩니다 . 일반적인 예는 탭의 경우 &lt;code&gt;\t&lt;/code&gt; , 줄 바꾸기의 경우 &lt;code&gt;\n&lt;/code&gt; , 캐리지 리턴의 경우 &lt;code&gt;\r&lt;/code&gt; 입니다. 임의의 바이트는 8 진 이스케이프 시퀀스 (예 : &lt;code&gt;\033&lt;/code&gt; ) 또는 16 진 이스케이프 시퀀스 (예 : &lt;code&gt;\x1B&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49b7c71547427b5d091f6bdffa36d87329e206a0" translate="yes" xml:space="preserve">
          <source>Noncharacter code points</source>
          <target state="translated">문자가 아닌 코드 포인트</target>
        </trans-unit>
        <trans-unit id="6eef6648406c333a4035cd5e60d0bf2ecf2606d7" translate="yes" xml:space="preserve">
          <source>None</source>
          <target state="translated">None</target>
        </trans-unit>
        <trans-unit id="d6c380a4b3a4edf398e410e1086f1f7a11f8a811" translate="yes" xml:space="preserve">
          <source>None by default.</source>
          <target state="translated">기본적으로 없음</target>
        </trans-unit>
        <trans-unit id="6aa4e4ea6e7911634748f65dccefc73c860296f0" translate="yes" xml:space="preserve">
          <source>None by default. &lt;code&gt;process_file()&lt;/code&gt; and/or &lt;code&gt;report_error_count()&lt;/code&gt; may be exported upon request. Using the functional interface is discouraged.</source>
          <target state="translated">기본적으로 없음 &lt;code&gt;process_file()&lt;/code&gt; 및 / 또는 &lt;code&gt;report_error_count()&lt;/code&gt; 내보낼 수 있습니다. 기능적 인터페이스를 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4d5cef6753554f631841c949a6101aca86cbd5e5" translate="yes" xml:space="preserve">
          <source>None known (guess what must have been used to report them?)</source>
          <target state="translated">알려진 바 없음 (보고하기 위해 무엇이 사용 되었는가?)</target>
        </trans-unit>
        <trans-unit id="56d59b0c28271db96f51f420982722cd9cd2649b" translate="yes" xml:space="preserve">
          <source>None of the make types being checked for is viable on VMS, plus our $self-&amp;gt;{MAKE} is an unexpanded (and unexpandable) macro whose value is known only to the make utility itself.</source>
          <target state="translated">확인 된 make 유형 중 어느 것도 VMS에서 실행 가능하지 않으며 $ self-&amp;gt; {MAKE}는 make 유틸리티 자체에만 알려진 값의 확장되지 않은 (및 확장 불가능한) 매크로입니다.</target>
        </trans-unit>
        <trans-unit id="1e04720e675e287c291e140902461ae4e502fb52" translate="yes" xml:space="preserve">
          <source>None of these bugs exist when using block eval</source>
          <target state="translated">블록 평가를 사용할 때 이러한 버그가 없습니다.</target>
        </trans-unit>
        <trans-unit id="9a9707be07da6862114abd49d2570046d4810ca5" translate="yes" xml:space="preserve">
          <source>None.</source>
          <target state="translated">None.</target>
        </trans-unit>
        <trans-unit id="66a6496ffa4e9b51040364dbe3fe4269ea990e40" translate="yes" xml:space="preserve">
          <source>Nonetheless, Storable deserializing documents from untrusted sources is expected to have other, yet undiscovered, security concerns such as allowing an attacker to cause the deserializer to crash hard.</source>
          <target state="translated">그럼에도 불구하고 신뢰할 수없는 출처의 저장 가능한 역 직렬화 문서에는 공격자가 역 직렬화기를 강제로 종료시키는 것과 같은 다른 보안 문제가있을 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="839bc88d91700ba09e378d5076a26e3c444a4e70" translate="yes" xml:space="preserve">
          <source>Norbert Pueschel, pueschel@imsdd.meb.uni-bonn.de Jan-Erik Karlsson, trg@privat.utfors.se</source>
          <target state="translated">Norbert Pueschel, pueschel@imsdd.meb.uni-bonn.de Jan-Erik Karlsson, trg@privat.utfors.se</target>
        </trans-unit>
        <trans-unit id="398931fe08778e56fac4c793097af9f4ad258767" translate="yes" xml:space="preserve">
          <source>Normal errors are reported by having store() or retrieve() return &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. Such errors are usually I/O errors (or truncated stream errors at retrieval).</source>
          <target state="translated">store () 또는 retrieve ()가 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 리턴하면 정상 오류가보고됩니다 . 이러한 오류는 일반적으로 I / O 오류 (또는 검색시 잘린 스트림 오류)입니다.</target>
        </trans-unit>
        <trans-unit id="6fe142dfc22c18bbee0c7f0e054d1e4fe9b2118c" translate="yes" xml:space="preserve">
          <source>Normal object destructor method.</source>
          <target state="translated">일반적인 객체 소멸자 방법.</target>
        </trans-unit>
        <trans-unit id="857c285210fd011f006ff55811d0ad93b45d7b73" translate="yes" xml:space="preserve">
          <source>Normal users of Perl should never care how Perl encodes any particular Unicode string (because the normal ways to get at the contents of a string with Unicode--via input and output--should always be via explicitly-defined I/O layers). But if you must, there are two ways of looking behind the scenes.</source>
          <target state="translated">일반적인 Perl 사용자는 Perl이 특정 유니 코드 문자열을 인코딩하는 방법에 신경 쓰지 않아야합니다 (입력 및 출력을 통해 유니 코드로 문자열의 내용을 얻는 일반적인 방법은 항상 명시 적으로 정의 된 I / O 레이어를 통해 이루어져야 함). 그러나 당신이 해야하는 경우, 장면을 뒤에서 보는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f5151d9a184cfb6f6a7bdc53123078ee18e8e1e" translate="yes" xml:space="preserve">
          <source>Normalization Corrections</source>
          <target state="translated">정규화 수정</target>
        </trans-unit>
        <trans-unit id="3fc17160b371a2dd2ce5f321ad17046bc51f04ec" translate="yes" xml:space="preserve">
          <source>Normalization Form Composed</source>
          <target state="translated">정규화 양식 작성</target>
        </trans-unit>
        <trans-unit id="8b530c9dcdf01b0cc0b4fd91277cae625646ab23" translate="yes" xml:space="preserve">
          <source>Normalization Form Decomposed</source>
          <target state="translated">정규화 형식 분해</target>
        </trans-unit>
        <trans-unit id="d6a84c0a7366c74d8b600470740fa32f23cb1e8c" translate="yes" xml:space="preserve">
          <source>Normalization Forms</source>
          <target state="translated">정규화 양식</target>
        </trans-unit>
        <trans-unit id="857696fa6055a6a9182e520ffef5e8982e055460" translate="yes" xml:space="preserve">
          <source>NormalizationCorrections.txt</source>
          <target state="translated">NormalizationCorrections.txt</target>
        </trans-unit>
        <trans-unit id="25d1f6918ee145ecbeeb0b9fc5d04c8edf9a3980" translate="yes" xml:space="preserve">
          <source>Normalize all arguments for consistency of comparison.</source>
          <target state="translated">비교의 일관성을 위해 모든 인수를 정규화하십시오.</target>
        </trans-unit>
        <trans-unit id="9cf527795f304857fa2e9475a64463f107fbdc96" translate="yes" xml:space="preserve">
          <source>Normally (by default) &lt;b&gt;Pod::Parser&lt;/b&gt; handles the &lt;code&gt;=cut&lt;/code&gt; POD directive by itself and does not pass it on to the caller for processing. Setting this option to a non-empty, non-zero value will cause &lt;b&gt;Pod::Parser&lt;/b&gt; to pass the &lt;code&gt;=cut&lt;/code&gt; directive to the caller just like any other POD command (and hence it may be processed by the &lt;b&gt;command()&lt;/b&gt; method).</source>
          <target state="translated">일반적으로 (기본적으로) &lt;b&gt;Pod :: Parser&lt;/b&gt; 는 &lt;code&gt;=cut&lt;/code&gt; POD 지시문 자체를 처리하고 처리를 위해 호출자에게 전달하지 않습니다. 이 옵션을 0이 아닌 0이 아닌 값으로 설정하면 &lt;b&gt;Pod :: Parser&lt;/b&gt; 가 다른 POD 명령과 마찬가지로 &lt;code&gt;=cut&lt;/code&gt; 지시문을 호출자 에게 전달 하므로 &lt;b&gt;command ()&lt;/b&gt; 메서드 로 처리 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e5bacef8258b5f77e0e8d77b6f8e1d3a5079db51" translate="yes" xml:space="preserve">
          <source>Normally (by default) &lt;b&gt;Pod::Parser&lt;/b&gt; recognizes a bare minimum of pod syntax errors and warnings and issues diagnostic messages for errors, but not for warnings. (Use &lt;b&gt;Pod::Checker&lt;/b&gt; to do more thorough checking of POD syntax.) Setting this option to a non-empty, non-zero value will cause &lt;b&gt;Pod::Parser&lt;/b&gt; to issue diagnostics for the few warnings it recognizes as well as the errors.</source>
          <target state="translated">일반적으로 (기본적으로) &lt;b&gt;Pod :: Parser&lt;/b&gt; 는 최소한의 포드 구문 오류와 경고를 인식하고 오류에 대해서는 진단 메시지를 표시하지만 경고에 대해서는 표시하지 않습니다. ( &lt;b&gt;Pod :: Checker&lt;/b&gt; 를 사용 하여 POD 구문을보다 철저하게 확인하십시오.)이 옵션을 0이 아닌 값이 아닌 값으로 설정하면 &lt;b&gt;Pod :: Parser&lt;/b&gt; 가 인식하는 몇 가지 경고 및 오류에 대한 진단을 발행합니다.</target>
        </trans-unit>
        <trans-unit id="f96de2f4de546b0b105bd31abd1df6be57d08d9b" translate="yes" xml:space="preserve">
          <source>Normally (by default) &lt;b&gt;Pod::Parser&lt;/b&gt; will only provide access to the POD sections of the input. Input paragraphs that are not part of the POD-format documentation are not made available to the caller (not even using &lt;b&gt;preprocess_paragraph()&lt;/b&gt;). Setting this option to a non-empty, non-zero value will allow &lt;b&gt;preprocess_paragraph()&lt;/b&gt; to see non-POD sections of the input as well as POD sections. The &lt;b&gt;cutting()&lt;/b&gt; method can be used to determine if the corresponding paragraph is a POD paragraph, or some other input paragraph.</source>
          <target state="translated">일반적으로 (기본적으로) &lt;b&gt;Pod :: Parser&lt;/b&gt; 는 입력의 POD 섹션에만 액세스 할 수 있습니다. POD 형식 문서에 포함되지 않은 입력 단락은 호출자가 사용할 수 없습니다 &lt;b&gt;(preprocess_paragraph ()&lt;/b&gt; 사용하지 않음 ). 이 옵션을 0이 아닌 값이 아닌 값으로 설정하면 &lt;b&gt;preprocess_paragraph ()&lt;/b&gt; 가 입력의 비 POD 섹션과 POD 섹션을 볼 수 있습니다. &lt;b&gt;절단 ()&lt;/b&gt; 메소드는 해당 단락이 POD 단락, 또는 다른 입력 단락 여부를 결정하기 위해 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="6752118c5629900bd2493b9fc622cf5fe1da59a3" translate="yes" xml:space="preserve">
          <source>Normally =head1 will become &amp;lt;h1&amp;gt;, =head2 will become &amp;lt;h2&amp;gt; etc. Using the html_h_level method will change these levels setting the h level of =head1 tags:</source>
          <target state="translated">일반적으로 = head1은 &amp;lt;h1&amp;gt;이되고 = head2는 &amp;lt;h2&amp;gt;가됩니다. html_h_level 메소드를 사용하면 이러한 레벨이 = head1 태그의 h 레벨을 설정하여 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="eb704595ff03db8550411015b5fd6f6b6a0da573" translate="yes" xml:space="preserve">
          <source>Normally CPAN.pm keeps config variables in memory and changes need to be saved in a separate 'o conf commit' command to make them permanent between sessions. If you set the 'auto_commit' option to true, changes to a config variable are always automatically committed to disk.</source>
          <target state="translated">일반적으로 CPAN.pm은 구성 변수를 메모리에 유지하며 변경 사항은 세션간에 영구적으로 유지되도록 별도의 'o conf commit'명령에 저장해야합니다. 'auto_commit'옵션을 true로 설정하면 구성 변수의 변경 사항은 항상 자동으로 디스크에 커밋됩니다.</target>
        </trans-unit>
        <trans-unit id="ffed2ba849f40bdabd5438b067027bdbe4e7e420" translate="yes" xml:space="preserve">
          <source>Normally File::Basename will assume a file path type native to your current operating system (ie. /foo/bar style on Unix, \foo\bar on Windows, etc...). With this function you can override that assumption.</source>
          <target state="translated">일반적으로 File :: Basename은 현재 운영 체제에 고유 한 파일 경로 유형을 가정합니다 (예 : Unix의 경우 / foo / bar 스타일, Windows의 경우 \ foo \ bar 등). 이 기능을 사용하면 해당 가정을 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6487841dbf7b431d256b64c2c684343b1b3e420" translate="yes" xml:space="preserve">
          <source>Normally equivalent to inet_aton('0.0.0.0'), inet_aton('255.255.255.255'), inet_aton('localhost') and inet_aton('255.255.255.255') respectively.</source>
          <target state="translated">일반적으로 inet_aton ( '0.0.0.0'), inet_aton ( '255.255.255.255'), inet_aton ( 'localhost') 및 inet_aton ( '255.255.255.255')에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="655db30b7d1bcb685e05fd4286f5335ffc8fceaf" translate="yes" xml:space="preserve">
          <source>Normally equivalent to inet_pton(AF_INET6, &quot;::&quot;) and inet_pton(AF_INET6, &quot;::1&quot;) respectively.</source>
          <target state="translated">일반적으로 inet_pton (AF_INET6, &quot;::&quot;) 및 inet_pton (AF_INET6, &quot;:: 1&quot;)과 각각 같습니다.</target>
        </trans-unit>
        <trans-unit id="d7299c892c667dfb149d16517a44252ec066ea3a" translate="yes" xml:space="preserve">
          <source>Normally it is an error to attempt to run the same test twice. Aliases allow you to overcome this limitation by giving each run of the test a unique name.</source>
          <target state="translated">일반적으로 동일한 테스트를 두 번 실행하는 것은 오류입니다. 별명을 사용하면 각 테스트 실행에 고유 한 이름을 부여하여이 제한을 극복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3b5278ad328e1d6dfb18e8dbc85851ab51d1e67" translate="yes" xml:space="preserve">
          <source>Normally it is not necessarily to do this directly, because it suffices to use the implicit discarding behaviour of &lt;a href=&quot;#lex_next_chunk&quot;&gt;lex_next_chunk&lt;/a&gt; and things based on it. However, if a token stretches across multiple lines, and the lexing code has kept multiple lines of text in the buffer for that purpose, then after completion of the token it would be wise to explicitly discard the now-unneeded earlier lines, to avoid future multi-line tokens growing the buffer without bound.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;#lex_next_chunk&quot;&gt;lex_next_chunk&lt;/a&gt; 의 암시 적 폐기 동작과 그에 기반한 것들을 사용하기에 충분하기 때문에 반드시 직접 수행 할 필요는 없습니다 . 그러나 토큰이 여러 줄로 확장되고 어휘 코드가 해당 목적을 위해 버퍼에 여러 줄의 텍스트를 유지 한 경우 토큰이 완료된 후 미래를 피하기 위해 필요하지 않은 이전 줄을 명시 적으로 삭제하는 것이 좋습니다 바인딩없이 버퍼를 확장하는 여러 줄 토큰.</target>
        </trans-unit>
        <trans-unit id="dff81aba4927ad5db88d6aff8ddca6455f943273" translate="yes" xml:space="preserve">
          <source>Normally just returns an empty string.</source>
          <target state="translated">일반적으로 빈 문자열 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="97bb2716ea7192ed8237324e0bfeb22c949fe5dd" translate="yes" xml:space="preserve">
          <source>Normally the SV will be cleared before the escaped string is prepared, but when PERL_PV_ESCAPE_NOCLEAR is set this will not occur.</source>
          <target state="translated">일반적으로 SV는 이스케이프 된 문자열이 준비되기 전에 지워지지 만 PERL_PV_ESCAPE_NOCLEAR이 설정되면 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f5e27e79537ab43ff1cac36249dfeaf81b443e2f" translate="yes" xml:space="preserve">
          <source>Normally the values returned by &lt;code&gt;message()&lt;/code&gt; and &lt;code&gt;code()&lt;/code&gt; are obtained from the remote server, but in a few circumstances, as detailed below, &lt;code&gt;Net::Cmd&lt;/code&gt; will return values that it sets. You can alter this behavior by overriding DEF_REPLY_CODE() to specify a different default reply code, or overriding one of the specific error handling methods below.</source>
          <target state="translated">일반적으로 &lt;code&gt;message()&lt;/code&gt; 및 &lt;code&gt;code()&lt;/code&gt; 의해 반환 된 값 은 원격 서버에서 가져 오지만 아래에 설명 된대로 일부 상황에서는 &lt;code&gt;Net::Cmd&lt;/code&gt; 가 설정 한 값을 반환합니다. DEF_REPLY_CODE ()를 재정 의하여 다른 기본 응답 코드를 지정하거나 아래의 특정 오류 처리 방법 중 하나를 재정 의하여이 동작을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5c29faef0eb7b590f52263e442441419daf42a3" translate="yes" xml:space="preserve">
          <source>Normally when a Perl program is run in taint mode the contents of the &lt;code&gt;PERL5LIB&lt;/code&gt; environment variable do not appear in &lt;code&gt;@INC&lt;/code&gt; .</source>
          <target state="translated">일반적으로 Perl 프로그램이 오염 모드에서 실행될 때 &lt;code&gt;PERL5LIB&lt;/code&gt; 환경 변수 의 내용은 &lt;code&gt;@INC&lt;/code&gt; 에 나타나지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="59a7a995939729b0dabf635451424cb7aa8edddc" translate="yes" xml:space="preserve">
          <source>Normally when a quantified subpattern does not allow the rest of the overall pattern to match, Perl will backtrack. However, this behaviour is sometimes undesirable. Thus Perl provides the &quot;possessive&quot; quantifier form as well.</source>
          <target state="translated">일반적으로 정량화 된 하위 패턴으로 나머지 전체 패턴이 일치하지 않으면 Perl이 역 추적합니다. 그러나이 동작은 때때로 바람직하지 않습니다. 따라서 Perl은 &quot;possessive&quot;정량 자 양식도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c8104915beebb2ef8d901739c62a7755b75d714f" translate="yes" xml:space="preserve">
          <source>Normally you can just pass a list of Perl tests and the harness will know how to execute them. However, if your tests are not written in Perl or if you want all tests invoked exactly the same way, use the &lt;code&gt;-e&lt;/code&gt; , or &lt;code&gt;--&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; switch:</source>
          <target state="translated">일반적으로 Perl 테스트 목록을 전달하면 하네스가이를 실행하는 방법을 알게됩니다. 당신의 검사 결과가 Perl로 작성하거나 원하는 경우 모든 테스트가 정확히 같은 방식으로 호출하지 않는 경우, 사용 &lt;code&gt;-e&lt;/code&gt; 또는 &lt;code&gt;--&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 스위치 :</target>
        </trans-unit>
        <trans-unit id="f2e0d0fdb3d7e700b9e570e982fb103b1928fe84" translate="yes" xml:space="preserve">
          <source>Normally you don't need to know about the &lt;code&gt;dir_prefix&lt;/code&gt; option, but I include it in case it might prove useful for someone somewhere.</source>
          <target state="translated">일반적으로 &lt;code&gt;dir_prefix&lt;/code&gt; 옵션 에 대해 알 필요는 없지만 다른 사람에게 유용 할 수있는 경우를 대비하여 포함시킵니다.</target>
        </trans-unit>
        <trans-unit id="3126672cdab51b1480bf681d3edd48007efd3666" translate="yes" xml:space="preserve">
          <source>Normally you don't need to know about the &lt;code&gt;progress&lt;/code&gt; option, but I include it in case it might prove useful for someone somewhere.</source>
          <target state="translated">일반적으로 &lt;code&gt;progress&lt;/code&gt; 옵션 에 대해 알 필요는 없지만 다른 사람에게 유용 할 수있는 경우에 대비하여 포함합니다.</target>
        </trans-unit>
        <trans-unit id="1572aaee7e8d3c88cefd57a173a8439b4c3cbe72" translate="yes" xml:space="preserve">
          <source>Normally you only need to edit</source>
          <target state="translated">일반적으로 편집 만하면됩니다</target>
        </trans-unit>
        <trans-unit id="c187e13441ab45730dcb9496c0aa29fc4a5d1bb8" translate="yes" xml:space="preserve">
          <source>Normally you would use a sequence of fields in a vertical stack associated with the same scalar variable to print out a block of text. You might wish to end the final field with the text &quot;...&quot;, which will appear in the output if the text was too long to appear in its entirety.</source>
          <target state="translated">일반적으로 동일한 스칼라 변수와 연관된 수직 스택에서 일련의 필드를 사용하여 텍스트 블록을 인쇄합니다. 텍스트 &quot;...&quot;로 최종 필드를 끝내고 싶을 수 있습니다. 텍스트가 너무 길어서 전체가 표시되지 않을 경우 출력에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="df7e48b2a8e18321d834351ce5ec861595531f41" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;Memoize&lt;/code&gt; caches your function's return values into an ordinary Perl hash variable. However, you might like to have the values cached on the disk, so that they persist from one run of your program to the next, or you might like to associate some other interesting semantics with the cached values.</source>
          <target state="translated">일반적으로 &lt;code&gt;Memoize&lt;/code&gt; 는 함수의 반환 값을 일반 Perl 해시 변수에 캐시합니다. 그러나 값을 디스크에 캐시하여 프로그램의 한 실행에서 다음 실행까지 지속 시키거나 다른 흥미로운 의미를 캐시 된 값과 연관시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="156e8ed9e5335713b0637af915d308c508bc5496" translate="yes" xml:space="preserve">
          <source>Normally, B::Deparse deparses the main code of a program, and all the subs defined in the same file. To include subs defined in other files, pass the &lt;b&gt;-f&lt;/b&gt; option with the filename. You can pass the &lt;b&gt;-f&lt;/b&gt; option several times, to include more than one secondary file. (Most of the time you don't want to use it at all.) You can also use this option to include subs which are defined in the scope of a &lt;b&gt;#line&lt;/b&gt; directive with two parameters.</source>
          <target state="translated">일반적으로 B :: Deparse는 프로그램의 기본 코드와 동일한 파일에 정의 된 모든 하위 코드를 분리합니다. 다른 파일에 정의 된 서브를 포함 시키려면 파일 이름과 함께 &lt;b&gt;-f&lt;/b&gt; 옵션을 전달하십시오 . &lt;b&gt;-f&lt;/b&gt; 옵션을 여러 번 전달하여 둘 이상의 보조 파일을 포함시킬 수 있습니다. (대부분 사용하지 않으려는 경우도 있습니다.) 또한이 옵션을 사용 하여 두 개의 매개 변수 로 &lt;b&gt;#line&lt;/b&gt; 지시문 의 범위에 정의 된 하위를 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d23245f6b2deb15ea54d8fbc52298acca654091b" translate="yes" xml:space="preserve">
          <source>Normally, CPAN.pm continues processing the full list of targets and dependencies, even if one of them fails. However, you can specify that CPAN should halt after the first failure. (Note that optional recommended or suggested modules that fail will not cause a halt.)</source>
          <target state="translated">일반적으로 CPAN.pm은 대상 및 종속성 중 하나가 실패하더라도 전체 목록과 대상을 계속 처리합니다. 그러나 첫 번째 실패 후 CPAN이 중지되도록 지정할 수 있습니다. (선택 사양 인 권장 또는 권장 모듈이 실패해도 중단되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="3d5ac60a26c28e14f1c99420243a6e5d21eaa6ab" translate="yes" xml:space="preserve">
          <source>Normally, L&amp;lt;&amp;gt; formatting codes with a URL but anchor text are formatted to show both the anchor text and the URL. In other words:</source>
          <target state="translated">일반적으로 URL이 있지만 앵커 텍스트가있는 L &amp;lt;&amp;gt; 형식 코드는 앵커 텍스트와 URL을 모두 표시하도록 형식이 지정됩니다. 다시 말해:</target>
        </trans-unit>
        <trans-unit id="28696b8342bf721c125649c0d32db8869e990e70" translate="yes" xml:space="preserve">
          <source>Normally, Storable stores elements of hashes in the order they are stored internally by Perl, i.e. pseudo-randomly. If you set &lt;code&gt;$Storable::canonical&lt;/code&gt; to some &lt;code&gt;TRUE&lt;/code&gt; value, Storable will store hashes with the elements sorted by their key. This allows you to compare data structures by comparing their frozen representations (or even the compressed frozen representations), which can be useful for creating lookup tables for complicated queries.</source>
          <target state="translated">일반적으로 Storable은 해시 요소를 Perl에 의해 내부적으로 저장된 순서대로, 즉 의사 랜덤으로 저장합니다. 를 설정하면 &lt;code&gt;$Storable::canonical&lt;/code&gt; 일부 &lt;code&gt;TRUE&lt;/code&gt; 값 요소가 핵심으로 분류하여, 보관 가능한이 해시를 저장합니다. 이를 통해 고정 된 표현 (또는 압축 된 고정 된 표현)을 비교하여 데이터 구조를 비교할 수 있습니다. 이는 복잡한 쿼리에 대한 조회 테이블을 만드는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcf4331af4df94d60c4a0096eabf2c84288a8ec7" translate="yes" xml:space="preserve">
          <source>Normally, Test::Builder does some extra diagnostics when the test ends. It also changes the exit code as described below.</source>
          <target state="translated">일반적으로 Test :: Builder는 테스트가 끝나면 추가 진단을 수행합니다. 또한 아래 설명 된대로 종료 코드를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="ce50c77261a5de00b7baaa95374b0bdfea3eac1d" translate="yes" xml:space="preserve">
          <source>Normally, a bareword doesn't need to be quoted, but in most cases probably should be (and must be under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; ). But a hash key consisting of a simple word and the left-hand operand to the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator both count as though they were quoted:</source>
          <target state="translated">일반적으로, bareword는 인용 할 필요는 없지만 대부분의 경우 아마해야한다 (그리고 아래에 있어야합니다 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; ). 그러나 간단한 단어와 &lt;code&gt;=&amp;gt;&lt;/code&gt; 연산자 의 왼쪽 피연산자로 구성된 해시 키는 모두 인용 된 것처럼 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="5564f90094b9860ce4353ac60db255b073b15ab0" translate="yes" xml:space="preserve">
          <source>Normally, a lone dash &lt;code&gt;-&lt;/code&gt; on the command line will not be considered an option. Option processing will terminate (unless &quot;permute&quot; is configured) and the dash will be left in &lt;code&gt;@ARGV&lt;/code&gt; .</source>
          <target state="translated">일반적으로, 고독한 대시 &lt;code&gt;-&lt;/code&gt; 명령 행에서이 옵션으로 간주되지 않습니다. 옵션 처리는 종료되고 ( &quot;permute&quot;가 구성되지 않은 경우) 대시는 &lt;code&gt;@ARGV&lt;/code&gt; 에 남아 있습니다 .</target>
        </trans-unit>
        <trans-unit id="654422bdd7e927225f8155b32c99633ae1593b5f" translate="yes" xml:space="preserve">
          <source>Normally, accessing a hash key's value for a nonexistent key will</source>
          <target state="translated">일반적으로 존재하지 않는 키의 해시 키 값에 액세스하면</target>
        </trans-unit>
        <trans-unit id="8652ae91a77d4cb6b6ff7525f46e31e0b15fc723" translate="yes" xml:space="preserve">
          <source>Normally, array elements have the record separator removed, so that if the file contains the text</source>
          <target state="translated">일반적으로 배열 요소에는 레코드 구분 기호가 제거되어 파일에 텍스트가 포함 된 경우</target>
        </trans-unit>
        <trans-unit id="534654aa79245de47a873277e56a6292c36afdc7" translate="yes" xml:space="preserve">
          <source>Normally, colored() just puts attribute codes at the beginning and end of the string, but if you set $Term::ANSIColor::EACHLINE to some string, that string will be considered the line delimiter and the attribute will be set at the beginning of each line of the passed string and reset at the end of each line. This is often desirable if the output contains newlines and you're using background colors, since a background color that persists across a newline is often interpreted by the terminal as providing the default background color for the next line. Programs like pagers can also be confused by attributes that span lines. Normally you'll want to set $Term::ANSIColor::EACHLINE to &lt;code&gt;&quot;\n&quot;&lt;/code&gt; to use this feature.</source>
          <target state="translated">일반적으로 colored ()는 문자열의 시작과 끝에 속성 코드를 넣지 만 $ Term :: ANSIColor :: EACHLINE을 일부 문자열로 설정하면 해당 문자열은 줄 구분 기호로 간주되고 속성은 전달 된 문자열의 각 줄의 시작과 각 줄의 끝에서 재설정합니다. 출력에 줄 바꿈이 포함되어 있고 배경색을 사용하는 경우 종종 바람직합니다. 줄 바꿈에 걸쳐 지속되는 배경색은 종종 터미널에서 다음 줄의 기본 배경색을 제공하는 것으로 해석되기 때문입니다. 호출기와 같은 프로그램은 여러 줄에 걸쳐있는 속성으로 인해 혼동 될 수도 있습니다. 일반적 으로이 기능을 사용하려면 $ Term :: ANSIColor :: EACHLINE을 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="47497939420b5b367cb1b2b4d46709150e929869" translate="yes" xml:space="preserve">
          <source>Normally, it uses the &lt;code&gt;failure_output()&lt;/code&gt; handle, but if this is for a TODO test, the &lt;code&gt;todo_output()&lt;/code&gt; handle is used.</source>
          <target state="translated">일반적으로 &lt;code&gt;failure_output()&lt;/code&gt; 핸들을 사용하지만 이것이 TODO 테스트 인 경우 &lt;code&gt;todo_output()&lt;/code&gt; 핸들이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="843f99e9f61b3167a92df62277ad684239edbee8" translate="yes" xml:space="preserve">
          <source>Normally, modifying a &lt;code&gt;Tie::File&lt;/code&gt; array writes to the underlying file immediately. Every assignment like &lt;code&gt;$a[3] = ...&lt;/code&gt; rewrites as much of the file as is necessary; typically, everything from line 3 through the end will need to be rewritten. This is the simplest and most transparent behavior. Performance even for large files is reasonably good.</source>
          <target state="translated">일반적으로 &lt;code&gt;Tie::File&lt;/code&gt; 배열을 수정 하면 기본 파일에 즉시 씁니다. &lt;code&gt;$a[3] = ...&lt;/code&gt; 와 같은 모든 할당 은 필요한만큼 파일을 다시 씁니다. 일반적으로 3 행부터 끝까지 모든 내용을 다시 작성해야합니다. 가장 단순하고 투명한 동작입니다. 큰 파일의 성능도 상당히 좋습니다.</target>
        </trans-unit>
        <trans-unit id="bf97b0167156ea895f7910e3f3f52f1229f7b5f7" translate="yes" xml:space="preserve">
          <source>Normally, regexps are a part of Perl expressions.</source>
          <target state="translated">일반적으로 정규 표현식은 Perl 표현식의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="808fe9fa0be0d04a656a7ac7cd5c2d9d3734bad0" translate="yes" xml:space="preserve">
          <source>Normally, sprintf() takes the next unused argument as the value to format for each format specification. If the format specification uses &lt;code&gt;*&lt;/code&gt; to require additional arguments, these are consumed from the argument list in the order they appear in the format specification</source>
          <target state="translated">일반적으로 sprintf ()는 사용되지 않은 다음 인수를 각 형식 스펙에 대해 형식화 할 값으로 사용합니다. 형식 스펙에서 &lt;code&gt;*&lt;/code&gt; 를 사용 하여 추가 인수가 필요한 경우 인수 스펙에서 형식 스펙에 나타나는 순서대로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2826cc3c3bfda4c3b98bd6c44f0b50d829979efc" translate="yes" xml:space="preserve">
          <source>Normally, the following code will result in two calls to &lt;code&gt;complicated&lt;/code&gt; , even if &lt;code&gt;complicated&lt;/code&gt; is memoized:</source>
          <target state="translated">에 일반적으로, 다음 코드는 두 개의 통화가 발생합니다 &lt;code&gt;complicated&lt;/code&gt; 하더라도, &lt;code&gt;complicated&lt;/code&gt; memoized한다 :</target>
        </trans-unit>
        <trans-unit id="7283cc850a65d4273ec3f9787a8b552a33654732" translate="yes" xml:space="preserve">
          <source>Normally, the parse-tree returned by &lt;b&gt;parse_text()&lt;/b&gt; will contain a text-string for each contiguous sequence of characters outside of an interior-sequence. Specifying &lt;b&gt;-expand_text&lt;/b&gt; tells &lt;b&gt;parse_text()&lt;/b&gt; to &quot;preprocess&quot; every such text-string it sees by invoking the referenced function (or named method of the parser object) and using the return value as the preprocessed (or &quot;expanded&quot;) result. [Note that if the result is an interior-sequence, then it will</source>
          <target state="translated">일반적으로 &lt;b&gt;parse_text ()에&lt;/b&gt; 의해 반환 된 구문 분석 트리는 내부 시퀀스 외부의 연속 된 각 문자 시퀀스에 대한 텍스트 문자열을 포함합니다. &lt;b&gt;-expand_text를&lt;/b&gt; 지정 하면 참조 된 함수 (또는 구문 분석기 오브젝트의 이름 지정된 메소드)를 호출하고 리턴 값을 사전 처리 된 (또는 &quot;확장 된&quot;) 결과로 사용하여 표시되는 모든 텍스트 문자열을 &quot;전처리&quot;하도록 &lt;b&gt;parse_text ()&lt;/b&gt; 에 지시 합니다. [결과가 내부 순서이면 결과는</target>
        </trans-unit>
        <trans-unit id="4c74045d12862bbf5896977df13a2e8f10f61ef7" translate="yes" xml:space="preserve">
          <source>Normally, the parse-tree returned by &lt;b&gt;parse_text()&lt;/b&gt; will contain an unexpanded &lt;code&gt;Pod::InteriorSequence&lt;/code&gt; object for each interior-sequence encountered. Specifying &lt;b&gt;-expand_seq&lt;/b&gt; tells &lt;b&gt;parse_text()&lt;/b&gt; to &quot;expand&quot; every interior-sequence it sees by invoking the referenced function (or named method of the parser object) and using the return value as the expanded result.</source>
          <target state="translated">일반적으로 &lt;b&gt;parse_text ()에&lt;/b&gt; 의해 반환 된 구문 분석 트리 에는 발생한 각 내부 시퀀스에 대해 확장되지 않은 &lt;code&gt;Pod::InteriorSequence&lt;/code&gt; 개체 가 포함 됩니다. &lt;b&gt;-expand_seq를&lt;/b&gt; 지정 하면 참조 된 함수 (또는 구문 분석기 오브젝트의 이름 지정된 메소드)를 호출하고 리턴 값을 확장 된 결과로 사용하여 표시되는 모든 내부 순서를 &lt;b&gt;parse_text ()&lt;/b&gt; 에 &quot;확장&quot;하도록 지시 합니다.</target>
        </trans-unit>
        <trans-unit id="16267da81502b322cffa728aa842c57f0b24ab0c" translate="yes" xml:space="preserve">
          <source>Normally, the resulting message is returned in a new mortal SV. During global destruction a single SV may be shared between uses of this function.</source>
          <target state="translated">일반적으로 결과 메시지는 새로운 필사자 SV로 반환됩니다. 전역 파괴 동안이 기능의 사용간에 단일 SV가 공유 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50ae485979ade17656e2e8127cce3420dca94e97" translate="yes" xml:space="preserve">
          <source>Normally, the resulting message is returned in a new mortal SV. During global destruction a single SV may be shared between uses of this function. If &lt;code&gt;consume&lt;/code&gt; is true, then the function is permitted (but not required) to modify and return &lt;code&gt;basemsg&lt;/code&gt; instead of allocating a new SV.</source>
          <target state="translated">일반적으로 결과 메시지는 새로운 필사자 SV로 반환됩니다. 전역 파괴 동안이 기능의 사용간에 단일 SV가 공유 될 수 있습니다. 경우 &lt;code&gt;consume&lt;/code&gt; 사실, 다음 함수는 수정 및 반환하도록 허용 (필수 사항은 아님)입니다 &lt;code&gt;basemsg&lt;/code&gt; 새로운 SV를 할당하는 대신.</target>
        </trans-unit>
        <trans-unit id="3699203fc3e3f9cdc9d573bca3286eccade605ca" translate="yes" xml:space="preserve">
          <source>Normally, the specified file will be opened for read and write access, and will be created if it does not exist. (That is, the flags &lt;code&gt;O_RDWR | O_CREAT&lt;/code&gt; are supplied in the &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; call.) If you want to change this, you may supply alternative flags in the &lt;code&gt;mode&lt;/code&gt; option. See &lt;a href=&quot;../fcntl&quot;&gt;Fcntl&lt;/a&gt; for a listing of available flags. For example:</source>
          <target state="translated">일반적으로 지정된 파일은 읽기 및 쓰기 액세스를 위해 열리 며 존재하지 않는 경우 만들어집니다. 즉, &lt;code&gt;O_RDWR | O_CREAT&lt;/code&gt; 플래그 는 &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 호출 에서 제공됩니다 .이를 변경하려면 &lt;code&gt;mode&lt;/code&gt; 옵션 에서 대체 플래그를 제공 할 수 있습니다. 사용 가능한 플래그 목록은 &lt;a href=&quot;../fcntl&quot;&gt;Fcntl&lt;/a&gt; 을 참조하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="39f12084738c458e8b7000b7b9525558b4cfff47" translate="yes" xml:space="preserve">
          <source>Normally, writing out Unicode data</source>
          <target state="translated">일반적으로 유니 코드 데이터 작성</target>
        </trans-unit>
        <trans-unit id="247ce5d5d9158a1021672cfbc50ce69d843f7d14" translate="yes" xml:space="preserve">
          <source>North America</source>
          <target state="translated">북아메리카</target>
        </trans-unit>
        <trans-unit id="9e9226334f9ce44ad0f10ee80520f849c5fe4619" translate="yes" xml:space="preserve">
          <source>Norton AntiVirus interferes with the build process, particularly if set to &quot;AutoProtect, All Files, when Opened&quot;. Unlike large applications the perl build process opens and modifies a lot of files. Having the the AntiVirus scan each and every one slows build the process significantly. Worse, with PERLIO=stdio the build process fails with peculiar messages as the virus checker interacts badly with miniperl.exe writing configure files (it seems to either catch file part written and treat it as suspicious, or virus checker may have it &quot;locked&quot; in a way which inhibits miniperl updating it). The build does complete with</source>
          <target state="translated">Norton AntiVirus는 특히 &quot;열 때 모든 파일을 자동 보호&quot;로 설정 한 경우 빌드 프로세스를 방해합니다. 큰 응용 프로그램과 달리 perl 빌드 프로세스는 많은 파일을 열고 수정합니다. 안티 바이러스가 각각 검사 할 때마다 프로세스 속도가 크게 느려집니다. 더 나쁜 것은 PERLIO = stdio를 사용하면 바이러스 검사기가 구성 파일을 작성하는 miniperl.exe와 잘못 상호 작용하기 때문에 특이한 메시지로 빌드 프로세스가 실패합니다. miniperl 업데이트를 방해하는 방식으로). 빌드가 완료됩니다</target>
        </trans-unit>
        <trans-unit id="a416dbee324bb6347c195257a3461c9b547b428f" translate="yes" xml:space="preserve">
          <source>Norton T. Allen (allen@huarp.harvard.edu)</source>
          <target state="translated">Norton T. Allen (allen@huarp.harvard.edu)</target>
        </trans-unit>
        <trans-unit id="370767717b5bd720890c41261b1cdb6e02957025" translate="yes" xml:space="preserve">
          <source>Not Using AutoLoader</source>
          <target state="translated">오토로더를 사용하지 않음</target>
        </trans-unit>
        <trans-unit id="ea7c30886465e53cc15fb2f369c9a20de63a93cc" translate="yes" xml:space="preserve">
          <source>Not a number. The value Perl uses for certain invalid or inexpressible floating-point operations.</source>
          <target state="translated">숫자가 아닙니다. Perl 값은 유효하지 않거나 표현할 수없는 특정 부동 소수점 연산에 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9ce5f175f6ed52d752c1dc214624e2c550cee7d4" translate="yes" xml:space="preserve">
          <source>Not a stellar system with three stars, but an &lt;b&gt;operator&lt;/b&gt; taking three &lt;b&gt;operands&lt;/b&gt;. Sometimes pronounced &lt;b&gt;ternary&lt;/b&gt;.</source>
          <target state="translated">별 3 개가있는 별 시스템은 아니지만 &lt;b&gt;연산자&lt;/b&gt; 3 개 &lt;b&gt;피연산자를 사용&lt;/b&gt; 합니다. 때로는 &lt;b&gt;삼원&lt;/b&gt; 발음 .</target>
        </trans-unit>
        <trans-unit id="c34a61da084e0aa67824715ad65e41d6be635c1c" translate="yes" xml:space="preserve">
          <source>Not a tag for normal use.</source>
          <target state="translated">정상적인 사용을위한 태그가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6628bb792927eb17f7227a3d024523ff7f4ef26a" translate="yes" xml:space="preserve">
          <source>Not all &lt;code&gt;(key,value)&lt;/code&gt; s are allowed to be changed. See also &lt;code&gt;@Unicode::Collate::ChangeOK&lt;/code&gt; and &lt;code&gt;@Unicode::Collate::ChangeNG&lt;/code&gt; .</source>
          <target state="translated">모든 &lt;code&gt;(key,value)&lt;/code&gt; 를 변경할 수있는 것은 아닙니다 . &lt;code&gt;@Unicode::Collate::ChangeOK&lt;/code&gt; 및 &lt;code&gt;@Unicode::Collate::ChangeNG&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="45ec939fa988aaea06d8cccbd3dfe26e8b7deec4" translate="yes" xml:space="preserve">
          <source>Not all Perl data types can be cloned (e.g., globs, code refs). By default, &lt;code&gt;shared_clone&lt;/code&gt; will &lt;a href=&quot;../carp&quot;&gt;croak&lt;/a&gt; if it encounters such items. To change this behaviour to a warning, then set the following:</source>
          <target state="translated">모든 Perl 데이터 유형을 복제 할 수있는 것은 아닙니다 (예 : globs, code refs). 기본적으로 &lt;code&gt;shared_clone&lt;/code&gt; 는 것이다 &lt;a href=&quot;../carp&quot;&gt;까악 까악&lt;/a&gt; 이 같은 항목을 발견합니다. 이 동작을 경고로 변경하려면 다음을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="ea270638e7bd76128d29c8152d0f28cca0f0cb30" translate="yes" xml:space="preserve">
          <source>Not all architectures (PA = PA-RISC, IPF = Itanium Processor Family) support all versions of HP-UX, here is a short list</source>
          <target state="translated">모든 아키텍처 (PA = PA-RISC, IPF = Itanium 프로세서 제품군)가 모든 버전의 HP-UX를 지원하는 것은 아닙니다. 여기에 간단한 목록이 있습니다.</target>
        </trans-unit>
        <trans-unit id="40c8890c57c81094971e9efbe9c79a62c905fdfd" translate="yes" xml:space="preserve">
          <source>Not all characters can be used 'as is' in a match. Some characters, called &lt;b&gt;metacharacters&lt;/b&gt;, are reserved for use in regex notation. The metacharacters are</source>
          <target state="translated">일치하는 모든 문자를 '있는 그대로'사용할 수있는 것은 아닙니다. &lt;b&gt;metacharacters&lt;/b&gt; 라는 일부 문자 는 정규식 표기법에 사용하도록 예약되어 있습니다. 메타 문자는</target>
        </trans-unit>
        <trans-unit id="6c499fcc39ea462750d346f8328fb611fa8eafb9" translate="yes" xml:space="preserve">
          <source>Not all extensions available from CPAN may build or work properly in the Windows environment. See &lt;a href=&quot;#Building-Extensions&quot;&gt;Building Extensions&lt;/a&gt;.</source>
          <target state="translated">CPAN에서 사용 가능한 모든 확장이 Windows 환경에서 올바르게 빌드되거나 작동하지 않을 수 있습니다. &lt;a href=&quot;#Building-Extensions&quot;&gt;확장 기능 빌드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e06068c24945da55baa1c3c0c5d1c56745baf201" translate="yes" xml:space="preserve">
          <source>Not all fields are supported on all filesystem types. Here are the meanings of the fields:</source>
          <target state="translated">모든 파일 시스템 유형에서 모든 필드가 지원되는 것은 아닙니다. 필드의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3d09a604d6ae3b0ff8d7d0a63321f6b716b05129" translate="yes" xml:space="preserve">
          <source>Not all methods indicated above need be implemented. See &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;, &lt;a href=&quot;../tie/hash&quot;&gt;Tie::Hash&lt;/a&gt;, &lt;a href=&quot;../tie/array&quot;&gt;Tie::Array&lt;/a&gt;, &lt;a href=&quot;../tie/scalar&quot;&gt;Tie::Scalar&lt;/a&gt;, and &lt;a href=&quot;../tie/handle&quot;&gt;Tie::Handle&lt;/a&gt;.</source>
          <target state="translated">위에 표시된 모든 방법을 구현할 필요는 없습니다. 참조 &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; , &lt;a href=&quot;../tie/hash&quot;&gt;타이 :: 해시&lt;/a&gt; , &lt;a href=&quot;../tie/array&quot;&gt;타이 :: 배열&lt;/a&gt; , &lt;a href=&quot;../tie/scalar&quot;&gt;타이 :: 스칼라&lt;/a&gt; , 그리고 &lt;a href=&quot;../tie/handle&quot;&gt;타이 :: 핸들&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a5f9e8c5a0eef6b261c9851c73bf90d947557e17" translate="yes" xml:space="preserve">
          <source>Not all methods indicated above need be implemented. See &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt;, &lt;a href=&quot;tie/hash&quot;&gt;Tie::Hash&lt;/a&gt;, &lt;a href=&quot;tie/array&quot;&gt;Tie::Array&lt;/a&gt;, &lt;a href=&quot;tie/scalar&quot;&gt;Tie::Scalar&lt;/a&gt;, and &lt;a href=&quot;tie/handle&quot;&gt;Tie::Handle&lt;/a&gt;.</source>
          <target state="translated">위에 표시된 모든 방법을 구현할 필요는 없습니다. 참조 &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt; , &lt;a href=&quot;tie/hash&quot;&gt;타이 :: 해시&lt;/a&gt; , &lt;a href=&quot;tie/array&quot;&gt;타이 :: 배열&lt;/a&gt; , &lt;a href=&quot;tie/scalar&quot;&gt;타이 :: 스칼라&lt;/a&gt; , 그리고 &lt;a href=&quot;tie/handle&quot;&gt;타이 :: 핸들&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b2a6c0e385364fab2b337951897446173ad031c2" translate="yes" xml:space="preserve">
          <source>Not all modules that you might use are thread-safe, and you should always assume a module is unsafe unless the documentation says otherwise. This includes modules that are distributed as part of the core. Threads are a relatively new feature, and even some of the standard modules aren't thread-safe.</source>
          <target state="translated">사용할 수있는 모든 모듈이 스레드로부터 안전하지는 않으며 설명서에서 달리 명시하지 않는 한 항상 모듈이 안전하지 않은 것으로 가정해야합니다. 여기에는 코어의 일부로 배포 된 모듈이 포함됩니다. 스레드는 비교적 새로운 기능이며 일부 표준 모듈조차 스레드로부터 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dc116f0ff5686f14831a54addc98cc9a05b72b09" translate="yes" xml:space="preserve">
          <source>Not all of the methods below are overridable in a Makefile.PL. Overridable methods are marked as (o). All methods are overridable by a platform specific MM_*.pm file.</source>
          <target state="translated">아래의 모든 메소드가 Makefile.PL에서 대체 가능한 것은 아닙니다. 재정의 가능한 메서드는 (o)로 표시됩니다. 모든 메소드는 플랫폼 별 MM _ *. pm 파일로 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdf47163ed1a6a398998e1921423263683e08485" translate="yes" xml:space="preserve">
          <source>Not all of the options currently have any useful effect. See &lt;a href=&quot;#BUGS&quot;&gt;BUGS&lt;/a&gt; for more details.</source>
          <target state="translated">현재 모든 옵션이 유용한 영향을주는 것은 아닙니다. 자세한 내용은 &lt;a href=&quot;#BUGS&quot;&gt;버그&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b1a2bb2e7a36d3508362112d31fd091b4c7b1d74" translate="yes" xml:space="preserve">
          <source>Not all platforms provide a command line. These are usually platforms that rely primarily on a Graphical User Interface (GUI) for user interaction. A program requiring a command line interface might not work everywhere. This is probably for the user of the program to deal with, so don't stay up late worrying about it.</source>
          <target state="translated">모든 플랫폼이 명령 행을 제공하는 것은 아닙니다. 이들은 일반적으로 사용자 상호 작용을 위해 GUI (Graphical User Interface)를 주로 사용하는 플랫폼입니다. 명령 행 인터페이스가 필요한 프로그램은 모든 곳에서 작동하지 않을 수 있습니다. 이것은 아마도 프로그램 사용자가 다룰 것이므로 늦게 걱정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="0377a3bed66f53a36c6cc0f471dce14458aee134" translate="yes" xml:space="preserve">
          <source>Not all platforms support passing va_list to further varargs (stdarg) functions. The right thing to do is to copy the va_list using the Perl_va_copy() if the NEED_VA_COPY is defined.</source>
          <target state="translated">모든 플랫폼이 va_list를 추가 varargs (stdarg) 함수로 전달하는 것을 지원하지는 않습니다. NEED_VA_COPY가 정의 된 경우 Perl_va_copy ()를 사용하여 va_list를 복사하는 것이 올바른 방법입니다.</target>
        </trans-unit>
        <trans-unit id="3114af1185f39ddb11892070ce221fe5a6a78ef2" translate="yes" xml:space="preserve">
          <source>Not all shells will allow multiple &lt;code&gt;-e&lt;/code&gt; string arguments to perl to be concatenated together properly as recipes in this document 0, 2, 4, 5, and 6 might seem to imply.</source>
          <target state="translated">이 문서에서 레시피 0, 2, 4, 5, 6에서 알 수 있듯이 여러 쉘이 여러 개의 &lt;code&gt;-e&lt;/code&gt; 문자열 인수를 펄로 올바르게 연결할 수있는 것은 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="2037b538368e39fec0d7f178aa255c4c901e6b71" translate="yes" xml:space="preserve">
          <source>Not being able to say &quot;no diagnostics&quot; is annoying, but may not be insurmountable.</source>
          <target state="translated">&quot;진단 없음&quot;이라고 말할 수없는 것은 성가 시지만 극복 할 수없는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0995003c36ab734a65b058b853402db6930f592e" translate="yes" xml:space="preserve">
          <source>Not compiling with -DDEBUGGING</source>
          <target state="translated">-DDEBUGGING으로 컴파일하지 않음</target>
        </trans-unit>
        <trans-unit id="ca400cb81537a6d172c2a30c8bb57fcb36d92286" translate="yes" xml:space="preserve">
          <source>Not compiling with threading</source>
          <target state="translated">스레딩으로 컴파일하지 않음</target>
        </trans-unit>
        <trans-unit id="350370904b27cc0af7789a292a507adc1a7bdacd" translate="yes" xml:space="preserve">
          <source>Not doing so may lead to surprises:</source>
          <target state="translated">그렇게하지 않으면 놀라움으로 이어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aba394cd9d79ffbbc16d2bd64cd6fb94c4285df0" translate="yes" xml:space="preserve">
          <source>Not every event or Perl Mongers group is on that calendar, so don't lose heart if you don't see yours posted. To have your event or group listed, contact brian d foy (brian@theperlreview.com).</source>
          <target state="translated">모든 이벤트 또는 Perl Mongers 그룹이 해당 캘린더에있는 것은 아니므로 게시 된 내용이 보이지 않으면 마음을 잃지 마십시오. 이벤트 또는 그룹을 나열하려면 brian d foy (brian@theperlreview.com)에 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="0a7f13c13fb3f26bce123ed94d7ecfbbffb8eb0c" translate="yes" xml:space="preserve">
          <source>Not every language tag really refers to a single language. Some language tags refer to conditions: i-default (system-message text in English plus maybe other languages), und (undetermined language). Others (notably lots of the three-letter codes) are bibliographic tags that classify whole groups of languages, as with cus &quot;Cushitic (Other)&quot; (i.e., a language that has been classed as Cushtic, but which has no more specific code) or the even less linguistically coherent sai for &quot;South American Indian (Other)&quot;. Though useful in bibliography, &lt;b&gt;SUCH TAGS ARE NOT FOR GENERAL USE&lt;/b&gt;. For further guidance, email me.</source>
          <target state="translated">모든 언어 태그가 실제로 단일 언어를 나타내는 것은 아닙니다. 일부 언어 태그는 i-default (영어로 된 시스템 메시지 텍스트와 다른 언어로) 및 und (확인되지 ​​않은 언어)와 같은 조건을 나타냅니다. 다른 것 (특히 많은 3 글자 코드)은 &quot;Cushitic (기타)&quot;(예 : Cushtic으로 분류되었지만 더 구체적인 코드는없는 언어)와 같이 전체 언어 그룹을 분류하는 서지 태그입니다. 또는 &quot;남아메리카 인디언 (기타)&quot;에 대해 언어 적으로 일관성이없는 sai. 참고 문헌에 유용하지만 &lt;b&gt;이러한 태그는 일반적인 용도로 사용되지 않습니다&lt;/b&gt; . 추가 지침이 필요하면 이메일을 보내주십시오.</target>
        </trans-unit>
        <trans-unit id="3ea748e41042fae4b5e481a0f49f8953b1ba289f" translate="yes" xml:space="preserve">
          <source>Not every program has to go through each of the possible phases, but transition from one phase to another can only happen in the order described in the above list.</source>
          <target state="translated">모든 프로그램이 가능한 각 단계를 거쳐야하는 것은 아니지만 한 단계에서 다른 단계로의 전환은 위 목록에 설명 된 순서 대로만 수행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c816e7c42988c3d11d87bf96a910ccb79c57f32" translate="yes" xml:space="preserve">
          <source>Not everything is a simple eq check or regex. There are times you need to see if two data structures are equivalent. For these instances Test::More provides a handful of useful functions.</source>
          <target state="translated">모든 것이 단순한 EQ 체크 또는 정규식은 아닙니다. 두 데이터 구조가 동일한 지 확인해야 할 경우가 있습니다. 이러한 경우 Test :: More는 유용한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b40e711f20f038555af473ee4ac108274fa7f9c8" translate="yes" xml:space="preserve">
          <source>Not everything is documented yet.</source>
          <target state="translated">모든 것이 아직 문서화되어 있지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="09e28ddb404a0041a3b2d909163038f64bb4a64a" translate="yes" xml:space="preserve">
          <source>Not exported by default.</source>
          <target state="translated">기본적으로 내 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3d70d5556752165324a9545f2bca3001c5928ecb" translate="yes" xml:space="preserve">
          <source>Not exporting your new function</source>
          <target state="translated">새 기능을 내 보내지 않음</target>
        </trans-unit>
        <trans-unit id="3de6216a588bc2f1646686041b64658486a740c8" translate="yes" xml:space="preserve">
          <source>Not for normal use.</source>
          <target state="translated">정상적인 사용에는 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8cb64bcbbd5a35d8290b9d42e26918a747698537" translate="yes" xml:space="preserve">
          <source>Not implemented (VMS, RISC OS, VOS).</source>
          <target state="translated">구현되지 않았습니다 (VMS, RISC OS, VOS).</target>
        </trans-unit>
        <trans-unit id="0e3254417362748be2bc014d24fafb5e5786cfb8" translate="yes" xml:space="preserve">
          <source>Not implemented, hence not useful for taint checking. (RISC OS)</source>
          <target state="translated">구현되지 않았으므로 오염 검사에 유용하지 않습니다. (RISC OS)</target>
        </trans-unit>
        <trans-unit id="3f95882d534087a6046525a2df4e776680013e1a" translate="yes" xml:space="preserve">
          <source>Not implemented. (AmigaOS, RISC OS, VMS)</source>
          <target state="translated">구현되지 않았습니다. (AmigaOS, RISC OS, VMS)</target>
        </trans-unit>
        <trans-unit id="9be2651d8f1db0033658f4a09b41f2967b03b1a2" translate="yes" xml:space="preserve">
          <source>Not implemented. (Android)</source>
          <target state="translated">구현되지 않았습니다. (기계적 인조 인간)</target>
        </trans-unit>
        <trans-unit id="8764e205d719987502ecc5a1d14954350c06e36a" translate="yes" xml:space="preserve">
          <source>Not implemented. (Android, RISC OS, VMS, Win32)</source>
          <target state="translated">구현되지 않았습니다. (안드로이드, RISC OS, VMS, Win32)</target>
        </trans-unit>
        <trans-unit id="9b09c5fded531e5c65a40df94ba58b539af31cb9" translate="yes" xml:space="preserve">
          <source>Not implemented. (Android, VMS, Win32, RISC OS)</source>
          <target state="translated">구현되지 않았습니다. (Android, VMS, Win32, RISC OS)</target>
        </trans-unit>
        <trans-unit id="db2cbf01d3edd364260719b49f0552da06074b32" translate="yes" xml:space="preserve">
          <source>Not implemented. (Android, Win32)</source>
          <target state="translated">구현되지 않았습니다. (Android, Win32)</target>
        </trans-unit>
        <trans-unit id="cfd9c1a9a91b792892f2a5fea52723a1f2e69940" translate="yes" xml:space="preserve">
          <source>Not implemented. (Android, Win32, Plan 9)</source>
          <target state="translated">구현되지 않았습니다. (안드로이드, Win32, 계획 9)</target>
        </trans-unit>
        <trans-unit id="b43f99dedb804d88539fc88ab6db0d0787e31419" translate="yes" xml:space="preserve">
          <source>Not implemented. (Android, Win32, Plan 9, RISC OS)</source>
          <target state="translated">구현되지 않았습니다. (Android, Win32, 계획 9, RISC OS)</target>
        </trans-unit>
        <trans-unit id="0be4e159794a607b410794f39b0e3b8aaf22c83b" translate="yes" xml:space="preserve">
          <source>Not implemented. (Android, Win32, RISC OS)</source>
          <target state="translated">구현되지 않았습니다. (Android, Win32, RISC OS)</target>
        </trans-unit>
        <trans-unit id="0d98f25d5507c35e363bc1c7b15a438bc954c58f" translate="yes" xml:space="preserve">
          <source>Not implemented. (Android, Win32, VMS)</source>
          <target state="translated">구현되지 않았습니다. (안드로이드, Win32, VMS)</target>
        </trans-unit>
        <trans-unit id="7bc41074b764485b1508c998d3f3f1b06873a949" translate="yes" xml:space="preserve">
          <source>Not implemented. (Android, Win32, VMS, Plan 9, RISC OS, VOS)</source>
          <target state="translated">구현되지 않았습니다. (Android, Win32, VMS, Plan 9, RISC OS, VOS)</target>
        </trans-unit>
        <trans-unit id="dd10c5ee6bfcd93657131a710727b05972d81d34" translate="yes" xml:space="preserve">
          <source>Not implemented. (Android, Win32, VMS, RISC OS)</source>
          <target state="translated">구현되지 않았습니다. (Android, Win32, VMS, RISC OS)</target>
        </trans-unit>
        <trans-unit id="27455a44f0877f0471812763650eca083a756dc3" translate="yes" xml:space="preserve">
          <source>Not implemented. (For computing dividends of long integers.) &lt;code&gt;ldiv()&lt;/code&gt; is C-specific, use &lt;code&gt;/&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. (긴 정수의 배당을 계산하려면) &lt;code&gt;ldiv()&lt;/code&gt; 는 C에 따라 다르며 대신 &lt;code&gt;/&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f35c350e45ece5778366ababe31d410a0f9c7643" translate="yes" xml:space="preserve">
          <source>Not implemented. (For returning absolute values of long integers.) &lt;code&gt;labs()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/abs&quot;&gt;abs&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. (정수의 절대 값을 반환하는 경우) &lt;code&gt;labs()&lt;/code&gt; 는 C에 따라 다릅니다 . 대신 &lt;a href=&quot;functions/abs&quot;&gt;abs&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0defed26024da4d1fed917bb2bf5601feb0b111c" translate="yes" xml:space="preserve">
          <source>Not implemented. (Older versions of VMS)</source>
          <target state="translated">구현되지 않았습니다. (이전 버전의 VMS)</target>
        </trans-unit>
        <trans-unit id="44ca2b069b718c2e4157a5f59d1c825f895901fe" translate="yes" xml:space="preserve">
          <source>Not implemented. (Plan 9)</source>
          <target state="translated">구현되지 않았습니다. (계획 9)</target>
        </trans-unit>
        <trans-unit id="1687754bd82bb4141221093b9e0016e67a352bef" translate="yes" xml:space="preserve">
          <source>Not implemented. (Plan 9, Win32)</source>
          <target state="translated">구현되지 않았습니다. (계획 9, Win32)</target>
        </trans-unit>
        <trans-unit id="a0c06eb1c0ea0d5c9ba352666d371d2a0ee60d0c" translate="yes" xml:space="preserve">
          <source>Not implemented. (Plan 9, Win32, RISC OS)</source>
          <target state="translated">구현되지 않았습니다. (계획 9, Win32, RISC OS)</target>
        </trans-unit>
        <trans-unit id="ccbe418811577573c94ecd1f3f6fa886c5efa0c1" translate="yes" xml:space="preserve">
          <source>Not implemented. (RISC OS)</source>
          <target state="translated">구현되지 않았습니다. (RISC OS)</target>
        </trans-unit>
        <trans-unit id="913cb5f5472a95b0b4bb5b0094468f9bd4a064d5" translate="yes" xml:space="preserve">
          <source>Not implemented. (RISC OS, VOS)</source>
          <target state="translated">구현되지 않았습니다. (RISC OS, VOS)</target>
        </trans-unit>
        <trans-unit id="c7eb7af11eb0f7e9fd28bfd3a491ea52eea2602b" translate="yes" xml:space="preserve">
          <source>Not implemented. (VMS)</source>
          <target state="translated">구현되지 않았습니다. (VMS)</target>
        </trans-unit>
        <trans-unit id="8b09ce4b149875b133df47459bb650cb679175f6" translate="yes" xml:space="preserve">
          <source>Not implemented. (VMS, Plan 9, VOS)</source>
          <target state="translated">구현되지 않았습니다. (VMS, 플랜 9, VOS)</target>
        </trans-unit>
        <trans-unit id="0e4b18141256d3047c7405c5aca0f45f42b63f27" translate="yes" xml:space="preserve">
          <source>Not implemented. (Win32)</source>
          <target state="translated">구현되지 않았습니다. (Win32)</target>
        </trans-unit>
        <trans-unit id="1e142d21e64d53e23fa456f8c1dabbf0855e18ca" translate="yes" xml:space="preserve">
          <source>Not implemented. (Win32, Plan 9)</source>
          <target state="translated">구현되지 않았습니다. (Win32, 계획 9)</target>
        </trans-unit>
        <trans-unit id="4df1791d2450fc70228c9ee024b8242b13ea6b2f" translate="yes" xml:space="preserve">
          <source>Not implemented. (Win32, Plan 9, RISC OS)</source>
          <target state="translated">구현되지 않았습니다. (Win32, 계획 9, RISC OS)</target>
        </trans-unit>
        <trans-unit id="5e4a1a38936d3686e162500ce6f897394cef05d7" translate="yes" xml:space="preserve">
          <source>Not implemented. (Win32, RISC OS)</source>
          <target state="translated">구현되지 않았습니다. (Win32, RISC OS)</target>
        </trans-unit>
        <trans-unit id="3be05ea3d75bc165c7f982935b70e66d5a771e41" translate="yes" xml:space="preserve">
          <source>Not implemented. (Win32, VMS, Plan 9, RISC OS, VOS)</source>
          <target state="translated">구현되지 않았습니다. (Win32, VMS, Plan 9, RISC OS, VOS)</target>
        </trans-unit>
        <trans-unit id="a54f984df38f433357bf0966c3cbdd1b95a80f1c" translate="yes" xml:space="preserve">
          <source>Not implemented. (Win32, VMS, RISC OS)</source>
          <target state="translated">구현되지 않았습니다. (Win32, VMS, RISC OS)</target>
        </trans-unit>
        <trans-unit id="22e05018b6fdced9bdff0b7d0cfb5c24bf0dbae4" translate="yes" xml:space="preserve">
          <source>Not implemented. (Win32, VMS, RISC OS, VOS)</source>
          <target state="translated">구현되지 않았습니다. (Win32, VMS, RISC OS, VOS)</target>
        </trans-unit>
        <trans-unit id="df3ebac574a0d503f84cea64df9995482f545b78" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; is non-portable, see &lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; 는 이식성이 없으며 대신 &lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1d13a3e012a93a772c4609ee06162adf5d3f5482" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;atexit()&lt;/code&gt; is C-specific: use &lt;code&gt;END {}&lt;/code&gt; instead, see &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;atexit()&lt;/code&gt; 은 C에 따라 다릅니다. 대신 &lt;code&gt;END {}&lt;/code&gt; 를 사용하십시오 ( &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="09f4af676353b27d015a55030f640e13fe428c8a" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;atof()&lt;/code&gt; is C-specific. Perl converts strings to numbers transparently. If you need to force a scalar to a number, add a zero to it.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;atof()&lt;/code&gt; 는 C 특정입니다. 펄은 문자열을 투명하게 숫자로 변환합니다. 스칼라를 숫자로 강제해야하는 경우 0을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="78bd80efc5684aaa0a6d2c976cfd9415957a93a7" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;atoi()&lt;/code&gt; is C-specific. Perl converts strings to numbers transparently. If you need to force a scalar to a number, add a zero to it. If you need to have just the integer part, see &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;atoi()&lt;/code&gt; 는 C에 따라 다릅니다. 펄은 문자열을 투명하게 숫자로 변환합니다. 스칼라를 숫자로 강제해야하는 경우 0을 추가하십시오. 정수 부분 만 필요한 경우 &lt;a href=&quot;functions/int&quot;&gt;int를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4c185269174fefc8864fa2f033cc63f05493972d" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;atol()&lt;/code&gt; is C-specific. Perl converts strings to numbers transparently. If you need to force a scalar to a number, add a zero to it. If you need to have just the integer part, see &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;atol()&lt;/code&gt; 은 C에 따라 다릅니다. 펄은 문자열을 투명하게 숫자로 변환합니다. 스칼라를 숫자로 강제해야하는 경우 0을 추가하십시오. 정수 부분 만 필요한 경우 &lt;a href=&quot;functions/int&quot;&gt;int를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="92f186e9062bbcbeafdbb5188df478220b8fd34d" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;calloc()&lt;/code&gt; is C-specific. Perl does memory management transparently.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;calloc()&lt;/code&gt; 은 C에 따라 다릅니다. Perl은 메모리 관리를 투명하게 수행합니다.</target>
        </trans-unit>
        <trans-unit id="ff7eec59e29a378eef5b91c7e47dc4704c6ae3ed" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;div()&lt;/code&gt; is C-specific, use &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; on the usual &lt;code&gt;/&lt;/code&gt; division and the modulus &lt;code&gt;%&lt;/code&gt; .</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;div()&lt;/code&gt; 는 C 에 따라 다르며, 보통 &lt;code&gt;/&lt;/code&gt; 나누기와 모듈러스 &lt;code&gt;%&lt;/code&gt; 에서 &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="1feba813e22b3e1ba2371da2a841ea2764df6b0c" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;execl()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;execl()&lt;/code&gt; 은 C에 따라 다릅니다 ( &lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="2ff7e7175b118c1234a7bdfd30d4510edaf63eb8" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;execle()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;execle()&lt;/code&gt; 은 C에 고유합니다 ( &lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="c55ec83b5578209872a8b8cd8fcb058c67f6c46a" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;execlp()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;execlp()&lt;/code&gt; 는 C에 따라 다릅니다 ( &lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="f28abb99b1ca88a6e43303b5eacb4722165a49a2" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;execv()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;execv()&lt;/code&gt; 는 C에 따라 다릅니다 ( &lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="5186c9f0054529cba073f427607f1822da899bdc" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;execve()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;execve()&lt;/code&gt; 는 C에 고유합니다 ( &lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="7a36265f790509d75a62c2c319a843a4a40d7fd1" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;execvp()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;execvp()&lt;/code&gt; 는 C에 따라 다릅니다 ( &lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="1d29c901ed53c6f9353f56b5387ce804863d40b2" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;fprintf()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;fprintf()&lt;/code&gt; 는 C에 따라 다릅니다 . 대신 &lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="050fa3a8f5bd9b39de78e5fc9715f0e8bc48d1f5" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;fputc()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;fputc()&lt;/code&gt; 는 C에 따라 다릅니다 . 대신 &lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6604c90e368654e682d80594f438dfbd8e6b3c87" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;fputs()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;fputs()&lt;/code&gt; 는 C에 따라 다릅니다 . 대신 &lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe419a5536eab5825dd89321d048538aa71f3581" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;fread()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;fread()&lt;/code&gt; 는 C에 따라 다릅니다 . 대신 &lt;a href=&quot;functions/read&quot;&gt;읽기&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bc646b919b78b9528c2ca2fc3f6d528b7f17e528" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;free()&lt;/code&gt; is C-specific. Perl does memory management transparently.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;free()&lt;/code&gt; 는 C에 따라 다릅니다. Perl은 메모리 관리를 투명하게 수행합니다.</target>
        </trans-unit>
        <trans-unit id="f31c768b4ce793b6920a2fbc67aa875a3bad3ce7" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;freopen()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;freopen()&lt;/code&gt; 은 C에 따라 다릅니다 . 대신 &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9e6dd63a418b84ae3412075ba1a715748c59e650" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;fscanf()&lt;/code&gt; is C-specific, use &amp;lt;&amp;gt; and regular expressions instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;fscanf()&lt;/code&gt; 는 C에 따라 다르며 대신 &amp;lt;&amp;gt; 및 정규 표현식을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="803e59e7256268e04789245ab7cdd5f3b1b8ccea" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;fwrite()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;fwrite()&lt;/code&gt; 는 C에 따라 다릅니다 . 대신 &lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="009be5a018756df717aa5d027ee88dc34faf4f1e" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;longjmp()&lt;/code&gt; is C-specific: use &lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;longjmp()&lt;/code&gt; 는 C에 따라 다릅니다. 대신 &lt;a href=&quot;functions/die&quot;&gt;die를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fef9c813c13bfbed594dcbc5cb78558fb58b324e" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;malloc()&lt;/code&gt; is C-specific. Perl does memory management transparently.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;malloc()&lt;/code&gt; 은 C에 따라 다릅니다. Perl은 메모리 관리를 투명하게 수행합니다.</target>
        </trans-unit>
        <trans-unit id="05a9fcc8dff8c195fa86d7e73fdbb1a70a26f9f6" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;memchr()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/index&quot;&gt;index&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;memchr()&lt;/code&gt; 은 C에 따라 다릅니다 . 대신 &lt;a href=&quot;functions/index&quot;&gt;index&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="77441742665123afa83b78530ce3a0ab326aeb65" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;memcmp()&lt;/code&gt; is C-specific, use &lt;code&gt;eq&lt;/code&gt; instead, see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;memcmp()&lt;/code&gt; 는 C에 따라 다릅니다 . 대신 &lt;code&gt;eq&lt;/code&gt; 를 사용 하십시오 ( &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="ef2d9a9129c1e4edee370c88c30737709c4b4ca5" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;memcpy()&lt;/code&gt; is C-specific, use &lt;code&gt;=&lt;/code&gt; , see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;, or see &lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;memcpy()&lt;/code&gt; C-특정 용도이다 &lt;code&gt;=&lt;/code&gt; 참조 &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 또는 참조 &lt;a href=&quot;functions/substr&quot;&gt;SUBSTR를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="df825da230687d219686874fba9a3cde9128b6b2" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;memmove()&lt;/code&gt; is C-specific, use &lt;code&gt;=&lt;/code&gt; , see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;, or see &lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;memmove()&lt;/code&gt; C-특정 용도이다 &lt;code&gt;=&lt;/code&gt; 참조 &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 또는 참조 &lt;a href=&quot;functions/substr&quot;&gt;SUBSTR를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f209e2a77b56cbe0e8dab09f4f69003460ef5165" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;memset()&lt;/code&gt; is C-specific, use &lt;code&gt;x&lt;/code&gt; instead, see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;memset()&lt;/code&gt; 은 C에 따라 다릅니다 . 대신 &lt;code&gt;x&lt;/code&gt; 를 사용 하십시오 ( &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="bb4ed6eef37f29c3a5ed63baa8372d65c75a7bd4" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;offsetof()&lt;/code&gt; is C-specific, you probably want to see &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;offsetof()&lt;/code&gt; 는 C에 따라 다르므로 아마도 &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; 을보고 싶을 것입니다.</target>
        </trans-unit>
        <trans-unit id="c5a56537761ef29ac46b64e624815032acfe09d5" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;putc()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;putc()&lt;/code&gt; 는 C에 따라 다릅니다 . 대신 &lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d3f78712fd0d6ef941365735d2d77cc01cb91842" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;putchar()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;putchar()&lt;/code&gt; 는 C에 따라 다릅니다 . 대신 &lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a4f9ab6e5a505c059b02d4f1e39653281c84079" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;puts()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;puts()&lt;/code&gt; 는 C에 따라 다릅니다 . 대신 &lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e2f67ad74b3ec17c9d41e3b1afab51f5f541355a" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;qsort()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;qsort()&lt;/code&gt; 는 C에 따라 다릅니다 . 대신 &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="80417a7f52d6bce06bdc09d12e04679309282530" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;realloc()&lt;/code&gt; is C-specific. Perl does memory management transparently.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;realloc()&lt;/code&gt; 은 C에 따라 다릅니다. Perl은 메모리 관리를 투명하게 수행합니다.</target>
        </trans-unit>
        <trans-unit id="b854623b0099f120c1f261738fcfb3b0e3dc6c43" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;scanf()&lt;/code&gt; is C-specific, use &amp;lt;&amp;gt; and regular expressions instead, see &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;scanf()&lt;/code&gt; 는 C에 따라 &lt;a href=&quot;perlre&quot;&gt;다르며&lt;/a&gt; 대신 &amp;lt;&amp;gt; 및 정규 표현식을 사용하십시오 ( perlre 참조) .</target>
        </trans-unit>
        <trans-unit id="86b82e3463dd9eb13ab0f20876acdf2afce2a004" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;setjmp()&lt;/code&gt; is C-specific: use &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; instead, see &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;setjmp()&lt;/code&gt; 는 C에 따라 다릅니다. 대신 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; 을 사용하십시오 ( &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="9fa206dd3a3d7cd667dd32f0c3afaf7a818af84a" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;siglongjmp()&lt;/code&gt; is C-specific: use &lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;siglongjmp()&lt;/code&gt; 는 C에 따라 다릅니다. 대신 &lt;a href=&quot;functions/die&quot;&gt;die를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ccdcc330b8531baca8e2545556f293d068fb1ea6" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;sigsetjmp()&lt;/code&gt; is C-specific: use &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; instead, see &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;sigsetjmp()&lt;/code&gt; 는 C에 따라 다릅니다. 대신 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; 을 사용하십시오 ( &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="57c268319591fc9206f5120b56c9b7a829b89f16" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;sscanf()&lt;/code&gt; is C-specific, use regular expressions instead, see &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;sscanf()&lt;/code&gt; 는 C에 특정 합니다. 대신 정규 표현식을 사용하십시오 ( &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="15a4e6249a6616df5c7fdb6def3ca7df12c8a726" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;strcat()&lt;/code&gt; is C-specific, use &lt;code&gt;.=&lt;/code&gt; instead, see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;strcat()&lt;/code&gt; 은 C에 따라 다릅니다 &lt;code&gt;.=&lt;/code&gt; 대신 . =을 사용하십시오 ( &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="4812ccf99744fab9351e2abe32d45f098e817477" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;strchr()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/index&quot;&gt;index&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;strchr()&lt;/code&gt; 은 C에 따라 다릅니다 . 대신 &lt;a href=&quot;functions/index&quot;&gt;index&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c97d0b60e52aa06d90e7b2e823428ad7860f8e8a" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;strcmp()&lt;/code&gt; is C-specific, use &lt;code&gt;eq&lt;/code&gt; or &lt;code&gt;cmp&lt;/code&gt; instead, see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;strcmp()&lt;/code&gt; 는 C에 따라 다릅니다 . 대신 &lt;code&gt;eq&lt;/code&gt; 또는 &lt;code&gt;cmp&lt;/code&gt; 를 사용하십시오 ( &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="e88b009350740b83bff03725c96d491249d6cc12" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;strcpy()&lt;/code&gt; is C-specific, use &lt;code&gt;=&lt;/code&gt; instead, see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;strcpy()&lt;/code&gt; C-특정이 사용이다 &lt;code&gt;=&lt;/code&gt; 대신 참조 &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3a946232e34c698b1c18404aaa65fdcbbc90586e" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;strcspn()&lt;/code&gt; is C-specific, use regular expressions instead, see &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;strcspn()&lt;/code&gt; 은 C에 따라 &lt;a href=&quot;perlre&quot;&gt;다르며&lt;/a&gt; 대신 정규 표현식을 사용하십시오 ( perlre 참조) .</target>
        </trans-unit>
        <trans-unit id="ac1ea236189e44b7d18fc790ee5b8256e3811b01" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;strlen()&lt;/code&gt; is C-specific, use &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; instead, see &lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;strlen()&lt;/code&gt; 은 C에 따라 다릅니다 . 대신 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; 사용하십시오 . &lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bec098c49b2779aed7a7218ddc97a53cf81b8121" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;strncat()&lt;/code&gt; is C-specific, use &lt;code&gt;.=&lt;/code&gt; instead, see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;strncat()&lt;/code&gt; 은 C에 따라 다릅니다 &lt;code&gt;.=&lt;/code&gt; 대신 . =를 사용하십시오 ( &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="4679b5013101131fbb1f77170dbb3261921e3ac9" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;strncmp()&lt;/code&gt; is C-specific, use &lt;code&gt;eq&lt;/code&gt; instead, see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;strncmp()&lt;/code&gt; 는 C에 따라 다릅니다 . 대신 &lt;code&gt;eq&lt;/code&gt; 를 사용 하십시오 ( &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="68b43540c2aaa3f23562e63d21cbb3d1f37d032d" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;strncpy()&lt;/code&gt; is C-specific, use &lt;code&gt;=&lt;/code&gt; instead, see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;strncpy()&lt;/code&gt; 는 C에 따라 다릅니다 . 대신 &lt;code&gt;=&lt;/code&gt; 를 사용 하십시오 . &lt;a href=&quot;perlop&quot;&gt;perlop을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e613eff42bbb352539ebe134a02f9df651ee1788" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;strpbrk()&lt;/code&gt; is C-specific, use regular expressions instead, see &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;strpbrk()&lt;/code&gt; 는 C에 따라 다르며 대신 정규 표현식을 사용하십시오 ( &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="6ec8b4e827e4723ad758e333ead45fa4a152ab56" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;strrchr()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/rindex&quot;&gt;rindex&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;strrchr()&lt;/code&gt; 은 C에 따라 다릅니다 . 대신 &lt;a href=&quot;functions/rindex&quot;&gt;rindex&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cc182b6d01cd132d49498bf46d317d05a13d5d37" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;strspn()&lt;/code&gt; is C-specific, use regular expressions instead, see &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;strspn()&lt;/code&gt; 은 C에 따라 &lt;a href=&quot;perlre&quot;&gt;다르며&lt;/a&gt; , 대신 정규 표현식을 사용하십시오 ( perlre 참조) .</target>
        </trans-unit>
        <trans-unit id="d5614594f22eb6178c164a089713817c648981e5" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;strtok()&lt;/code&gt; is C-specific, use regular expressions instead, see &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;, or &lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;strtok()&lt;/code&gt; 은 C에 따라 &lt;a href=&quot;perlre&quot;&gt;다르며&lt;/a&gt; 대신 정규 표현식을 사용하십시오. perlre 또는 &lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="80fdcacb3f3247028947287ced6c21eda7e4321b" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;vfprintf()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;vfprintf()&lt;/code&gt; 는 C에 따라 다릅니다 . 대신 &lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c90b40527e74f3653d4dd6b14250c134ce59f330" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;vprintf()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;vprintf()&lt;/code&gt; 는 C에 따라 다릅니다 . 대신 &lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="08604cd1d6dad28e54ed2c86d8e61348b23d108b" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;vsprintf()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;vsprintf()&lt;/code&gt; 는 C에 따라 다릅니다 . 대신 &lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f1c9bc78a8aeb50498c091744a0a072e8663077c" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::File::new_tmpfile()&lt;/code&gt; instead, or see &lt;a href=&quot;file/temp&quot;&gt;File::Temp&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;IO::File::new_tmpfile()&lt;/code&gt; 메소드를 대신 사용하거나 &lt;a href=&quot;file/temp&quot;&gt;File :: Temp를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fb9ea04652178e89f71d95b0e26c4da58a6e3d57" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::File::open()&lt;/code&gt; instead, or see &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;IO::File::open()&lt;/code&gt; 메소드를 대신 사용하거나 &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="133851d7093855036c645528e4109a7be1a3e820" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::Handle::close()&lt;/code&gt; instead, or see &lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;IO::Handle::close()&lt;/code&gt; 메소드를 대신 사용하거나 &lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5ba46f1c447a0143660b5cddf9fb1d25553fffb" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::Handle::eof()&lt;/code&gt; instead, or see &lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. 대신 메소드 &lt;code&gt;IO::Handle::eof()&lt;/code&gt; 사용하거나 &lt;a href=&quot;functions/eof&quot;&gt;eof를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c8adccccd63977fb3c0fcacade58414e48926172" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::Handle::error()&lt;/code&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. 대신 &lt;code&gt;IO::Handle::error()&lt;/code&gt; 메소드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e1cf1a56225275921aede7048ae283bdae3ce190" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::Handle::fileno()&lt;/code&gt; instead, or see &lt;a href=&quot;functions/fileno&quot;&gt;fileno&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;IO::Handle::fileno()&lt;/code&gt; 메소드를 대신 사용하거나 &lt;a href=&quot;functions/fileno&quot;&gt;fileno&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bea09c7543753e43f0874eca405e18dbb7c8fbe5" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::Handle::flush()&lt;/code&gt; instead. See also &lt;code&gt;&lt;a href=&quot;perlvar#%24OUTPUT_AUTOFLUSH&quot;&gt;$OUTPUT_AUTOFLUSH in perlvar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">구현되지 않았습니다. 대신 &lt;code&gt;IO::Handle::flush()&lt;/code&gt; 메소드를 사용하십시오 . &lt;code&gt;&lt;a href=&quot;perlvar#%24OUTPUT_AUTOFLUSH&quot;&gt;$OUTPUT_AUTOFLUSH in perlvar&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b6a85a170f35c7a103834e7c9ab729375c61940" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::Handle::getc()&lt;/code&gt; instead, or see &lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;IO::Handle::getc()&lt;/code&gt; 메소드를 대신 사용하거나 &lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="58770e0b79629739d1eacc20133618f4648e46ac" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::Handle::gets()&lt;/code&gt; instead. Similar to &amp;lt;&amp;gt;, also known as &lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. 대신 &lt;code&gt;IO::Handle::gets()&lt;/code&gt; 메소드를 사용하십시오 . &amp;lt;&amp;gt;와 유사하며 &lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt; 라고도합니다 .</target>
        </trans-unit>
        <trans-unit id="fb3907a6c5c4412de4df54dbbf1b97cc9ee0b41c" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::Handle::new_from_fd()&lt;/code&gt; instead, or see &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;IO::Handle::new_from_fd()&lt;/code&gt; 메소드를 대신 사용하거나 &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b34ae8702317852fa502a0298b0533b2d7a4471a" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::Handle::sync()&lt;/code&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. 대신 &lt;code&gt;IO::Handle::sync()&lt;/code&gt; 메소드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f9baea21503c08e99440dc4cb43bcdef6e777150" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::Handle::ungetc()&lt;/code&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. 대신 &lt;code&gt;IO::Handle::ungetc()&lt;/code&gt; 메소드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="211713d31d2112ee0f26a6608edadadbf58f4c80" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::Seekable::getpos()&lt;/code&gt; instead, or see &lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;IO::Seekable::getpos()&lt;/code&gt; 메소드를 대신 사용하거나 &lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e49c926515a4700f695726ea107a0a6611a896eb" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::Seekable::seek()&lt;/code&gt; instead, or see &lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;IO::Seekable::seek()&lt;/code&gt; 메소드를 대신 사용하거나 &lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="05e6ae0bbba38efd7d70699a4892e9d6f993a6ca" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::Seekable::setpos()&lt;/code&gt; instead, or seek &lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;IO::Seekable::setpos()&lt;/code&gt; 메소드를 대신 사용하거나 seek을 &lt;a href=&quot;functions/seek&quot;&gt;찾으십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1c3d78054e07679018c7eb8a6898e917690c20bb" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::Seekable::tell()&lt;/code&gt; instead, or see &lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. 대신 &lt;code&gt;IO::Seekable::tell()&lt;/code&gt; 메소드를 사용 하거나 &lt;a href=&quot;functions/tell&quot;&gt;tell을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="137c25f432a636a5b4fbe697952402c8c467df96" translate="yes" xml:space="preserve">
          <source>Not implemented. Use the method &lt;code&gt;IO::Handle::clearerr()&lt;/code&gt; instead, to reset the error state (if any) and EOF state (if any) of the given stream.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;IO::Handle::clearerr()&lt;/code&gt; 메소드를 대신 사용하여 지정된 스트림의 오류 상태 (있는 경우) 및 EOF 상태 (있는 경우)를 재설정하십시오.</target>
        </trans-unit>
        <trans-unit id="58f06a0bbcce20a76f9bb983793e3d731cc5b4e7" translate="yes" xml:space="preserve">
          <source>Not import any functions (&lt;code&gt;load&lt;/code&gt; and &lt;code&gt;autoload&lt;/code&gt; are not imported).</source>
          <target state="translated">어떤 함수도 가져 오지 않습니다 ( &lt;code&gt;load&lt;/code&gt; 및 &lt;code&gt;autoload&lt;/code&gt; 는 가져 오지 않습니다).</target>
        </trans-unit>
        <trans-unit id="c48d80935038d565f7b6bee1373f0f551a681530" translate="yes" xml:space="preserve">
          <source>Not meaning the same thing everywhere. A global variable in Perl can be localized inside a &lt;b&gt;dynamic scope&lt;/b&gt; via the &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">모든 곳에서 같은 것을 의미하지는 않습니다. Perl의 전역 변수 는 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 연산자 를 통해 &lt;b&gt;동적 범위&lt;/b&gt; 내에서 지역화 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b939fb6a3591b14266d8d57a8e48e4faf1d2cee" translate="yes" xml:space="preserve">
          <source>Not much in there, lets have a look at our hash:</source>
          <target state="translated">그다지 중요하지는 않지만 해시를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="4a9a725cbef013a6dd198484972ad2c467befeee" translate="yes" xml:space="preserve">
          <source>Not only does the &lt;code&gt;&amp;amp;&lt;/code&gt; form make the argument list optional, it also disables any prototype checking on arguments you do provide. This is partly for historical reasons, and partly for having a convenient way to cheat if you know what you're doing. See &lt;a href=&quot;#Prototypes&quot;&gt;Prototypes&lt;/a&gt; below.</source>
          <target state="translated">&lt;code&gt;&amp;amp;&lt;/code&gt; 형식은 인수 목록을 옵션으로 만들 뿐만 아니라 제공 한 인수에 대한 프로토 타입 검사도 비활성화합니다. 이것은 부분적으로 역사적인 이유이며, 무엇을하고 있는지 아는 경우 편리한 속임수를 쓰는 것입니다. 아래의 &lt;a href=&quot;#Prototypes&quot;&gt;프로토 타입을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a811cf50f735b2384cdcc3d6c15773eea2339670" translate="yes" xml:space="preserve">
          <source>Not really a function. Returns the value of the last command in the sequence of commands indicated by BLOCK. When modified by the &lt;code&gt;while&lt;/code&gt; or &lt;code&gt;until&lt;/code&gt; loop modifier, executes the BLOCK once before testing the loop condition. (On other statements the loop modifiers test the conditional first.)</source>
          <target state="translated">실제로는 기능이 아닙니다. BLOCK으로 표시되는 명령 순서에서 마지막 명령의 값을 리턴합니다. &lt;code&gt;while&lt;/code&gt; 또는 &lt;code&gt;until&lt;/code&gt; 루프 수정 자에 의해 수정되면 루프 조건을 테스트하기 전에 BLOCK을 한 번 실행합니다. 다른 문장에서는 루프 수정자가 조건부를 먼저 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="7730f6df594c6de3b4d8613cf47cdce98b6f0a22" translate="yes" xml:space="preserve">
          <source>Not really needed since Perl can do this transparently, see &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="translated">Perl이 투명하게 할 수 있기 때문에 실제로는 필요하지 않습니다 . &lt;a href=&quot;perllocale&quot;&gt;perllocale을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b9d7a49b40d40ab0a0f9c9a3b98021fa838b1713" translate="yes" xml:space="preserve">
          <source>Not really. Just remember these things:</source>
          <target state="translated">실제로는 아닙니다. 다음 사항 만 기억하십시오.</target>
        </trans-unit>
        <trans-unit id="564d2f25f68052a8b0d8264d398e1a270012d6dd" translate="yes" xml:space="preserve">
          <source>Not supported. (Cygwin, Win32)</source>
          <target state="translated">지원되지 않습니다. (Cygwin, Win32)</target>
        </trans-unit>
        <trans-unit id="44f0aabb090ea7bda69b4ec7e7feada441e65ecd" translate="yes" xml:space="preserve">
          <source>Not supported. (Symbian OS)</source>
          <target state="translated">지원되지 않습니다. (Symbian OS)</target>
        </trans-unit>
        <trans-unit id="09d97c142afe584c0633a63005929ca08c9b4ee3" translate="yes" xml:space="preserve">
          <source>Not surprisingly &lt;code&gt;POPi&lt;/code&gt; is used twice this time because we were retrieving 2 values from the stack. The important thing to note is that when using the &lt;code&gt;POP*&lt;/code&gt; macros they come off the stack in</source>
          <target state="translated">당연히 &lt;code&gt;POPi&lt;/code&gt; 우리가 스택에서 두 값을 검색하고 있었기 때문에 두 번이 시간을 사용한다. 중요한 점은 &lt;code&gt;POP*&lt;/code&gt; 매크로 를 사용할 때 스택에서 벗어납니다.</target>
        </trans-unit>
        <trans-unit id="390165cd3f335a354cf23fafc424a48aba836996" translate="yes" xml:space="preserve">
          <source>Not useful. (RISC OS)</source>
          <target state="translated">유용하지 않다. (RISC OS)</target>
        </trans-unit>
        <trans-unit id="a2b7936ab62eebf457dc2154c2400025b89c2f6e" translate="yes" xml:space="preserve">
          <source>Not very consistent! We'll set a breakpoint in the code manually and run it under the debugger to see what's going on. A breakpoint is a flag, to which the debugger will run without interruption, when it reaches the breakpoint, it will stop execution and offer a prompt for further interaction. In normal use, these debugger commands are completely ignored, and they are safe - if a little messy, to leave in production code.</source>
          <target state="translated">매우 일관성이 없습니다! 코드에 수동으로 중단 점을 설정하고 디버거에서 실행하여 진행 상황을 확인합니다. 중단 점은 디버거가 중단없이 실행되는 플래그이며 중단 점에 도달하면 실행을 중지하고 추가 상호 작용을위한 프롬프트를 제공합니다. 일반적으로 이러한 디버거 명령은 완전히 무시되며 약간 혼란 스러울 경우 프로덕션 코드에 그대로 두는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="9789ac6a8ac0f9e48e0dab47af13503fe088d2fd" translate="yes" xml:space="preserve">
          <source>Not yet implemented things (but with correct description) are marked with '!', things that need to be answered are marked with '?'.</source>
          <target state="translated">아직 구현되지 않은 것 (그러나 정확한 설명으로)은 '!'로 표시되고, 답변이 필요한 것은 '?'로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a9a291a507a7fbe91670ac808a7268af277204d4" translate="yes" xml:space="preserve">
          <source>Not-so-symbolic references</source>
          <target state="translated">기호가 아닌 참조</target>
        </trans-unit>
        <trans-unit id="8c5f0dacad99093710a8cf34c11579156a106382" translate="yes" xml:space="preserve">
          <source>Notable forms: {az-Arab} Azerbaijani in Arabic script; {az-Cyrl} Azerbaijani in Cyrillic script; {az-Latn} Azerbaijani in Latin script.</source>
          <target state="translated">주목할만한 형태 : 아랍어로 된 {az-Arab} 아제르바이잔 어; 키릴 문자 {az-Cyrl} 아제르바이잔 어; 라틴어 스크립트 {az-Latn} 아제르바이잔 어.</target>
        </trans-unit>
        <trans-unit id="a21e204d71bcc963ab9acff0b78bac05301d8085" translate="yes" xml:space="preserve">
          <source>Notable forms: {cel-gaulish} Gaulish (Historical)</source>
          <target state="translated">주목할만한 형태 : {cel-gaulish} Gaulish (기록)</target>
        </trans-unit>
        <trans-unit id="81bb796e9401d7e29001c83b4296a2b3487ce033" translate="yes" xml:space="preserve">
          <source>Notable forms: {de-at} Austrian German; {de-be} Belgian German; {de-ch} Swiss German; {de-de} Germany German; {de-li} Liechtenstein German; {de-lu} Luxembourg German.</source>
          <target state="translated">주목할만한 형태 : {de-at} 오스트리아 독일어; {de-be} 벨기에 독일어; {de-ch} 스위스 독일어; {de-de} 독일 독일어; {de-li} 리히텐슈타인 독일어; {de-lu} 룩셈부르크 독일어.</target>
        </trans-unit>
        <trans-unit id="e6b6ae9f7027c22a91fb186261e25769dc159ea0" translate="yes" xml:space="preserve">
          <source>Notable forms: {en-au} Australian English; {en-bz} Belize English; {en-ca} Canadian English; {en-gb} UK English; {en-ie} Irish English; {en-jm} Jamaican English; {en-nz} New Zealand English; {en-ph} Philippine English; {en-tt} Trinidad English; {en-us} US English; {en-za} South African English; {en-zw} Zimbabwe English.</source>
          <target state="translated">주목할만한 형태 : {en-au} 호주 영어; {en-bz} 벨리즈 영어; {en-ca} 캐나다 영어; {en-gb} 영국 영어; {en-ie} 아일랜드 영어; {en-jm} 자메이카 영어; {en-nz} 뉴질랜드 영어; {en-ph} 필리핀 영어; {en-tt} 트리니다드 영어; {en-us} 미국 영어; {en-za} 남아프리카 영어; {en-zw} 짐바브웨 영어.</target>
        </trans-unit>
        <trans-unit id="2fdbbad9de5ba367ca84465b4854964747407c75" translate="yes" xml:space="preserve">
          <source>Notable forms: {es-ar} Argentine Spanish; {es-bo} Bolivian Spanish; {es-cl} Chilean Spanish; {es-co} Colombian Spanish; {es-do} Dominican Spanish; {es-ec} Ecuadorian Spanish; {es-es} Spain Spanish; {es-gt} Guatemalan Spanish; {es-hn} Honduran Spanish; {es-mx} Mexican Spanish; {es-pa} Panamanian Spanish; {es-pe} Peruvian Spanish; {es-pr} Puerto Rican Spanish; {es-py} Paraguay Spanish; {es-sv} Salvadoran Spanish; {es-us} US Spanish; {es-uy} Uruguayan Spanish; {es-ve} Venezuelan Spanish.</source>
          <target state="translated">주목할만한 형태 : {es-ar} 아르헨티나 스페인어; {es-bo} 볼리비아 스페인어; {es-cl} 칠레 스페인어; {es-co} 콜롬비아 스페인어; {es-do} 도미니카 스페인어; {es-ec} 에콰도르 스페인어; {es-es} 스페인 스페인어; {es-gt} 과테말라 스페인어; {es-hn} 온두라스 스페인어; {es-mx} 멕시코 스페인어; {es-pa} 파나마 스페인어; {es-pe} 페루 스페인어; {es-pr} 푸에르토 리코 스페인어; {es-py} 파라과이 스페인어; {es-sv} 살바도르 스페인어; {es-us} 미국 스페인어; {es-uy} 우루과이 스페인어; {es-ve} 베네수엘라 스페인어.</target>
        </trans-unit>
        <trans-unit id="4e12474051e941f83342ef3b43136d735d5afa0d" translate="yes" xml:space="preserve">
          <source>Notable forms: {fr-fr} France French; {fr-be} Belgian French; {fr-ca} Canadian French; {fr-ch} Swiss French; {fr-lu} Luxembourg French; {fr-mc} Monaco French.</source>
          <target state="translated">주목할만한 형태 : {fr-fr} France French; {fr-be} 벨기에 프랑스어; {fr-ca} 캐나다 프랑스어; {fr-ch} 스위스 프랑스어; {fr-lu} 룩셈부르크 프랑스어; {fr-mc} 모나코 프랑스어.</target>
        </trans-unit>
        <trans-unit id="1e7e0fa3b703bb74658f81aeaba2a665c1f48d5b" translate="yes" xml:space="preserve">
          <source>Notable forms: {it-it} Italy Italian; {it-ch} Swiss Italian.</source>
          <target state="translated">주목할만한 형태 : {it-it} 이탈리아 이탈리아어; {it-ch} 스위스 이탈리아어.</target>
        </trans-unit>
        <trans-unit id="1c5cef64e650e567672b7408d2454fe4584f664d" translate="yes" xml:space="preserve">
          <source>Notable forms: {sr-Cyrl} : Serbian in Cyrillic script; {sr-Latn} : Serbian in Latin script.</source>
          <target state="translated">주목할만한 형태 : {sr-Cyrl} : 키릴 문자로 된 세르비아어; {sr-Latn} : 라틴어 스크립트의 세르비아어.</target>
        </trans-unit>
        <trans-unit id="b08476354345271b609310a79c55d75e3d5fa7ed" translate="yes" xml:space="preserve">
          <source>Notable forms: {sv-se} Sweden Swedish; {sv-fi} Finland Swedish.</source>
          <target state="translated">주목할만한 형태 : {sv-se} 스웨덴 스웨덴어; {sv-fi} 핀란드 스웨덴어.</target>
        </trans-unit>
        <trans-unit id="e612fd18c10ae296220917b18468a0bab3558ba5" translate="yes" xml:space="preserve">
          <source>Notable forms: {uz-Cyrl} Uzbek in Cyrillic script; {uz-Latn} Uzbek in Latin script.</source>
          <target state="translated">주목할만한 형태 : 키릴 문자로 된 {uz-Cyrl} 우즈베크 어; 라틴어 스크립트로 {uz-Latn} 우즈베크 어.</target>
        </trans-unit>
        <trans-unit id="ccdcbff00a8c92eb11dc1da19032f524f994ea4d" translate="yes" xml:space="preserve">
          <source>Notable forms: {yi-latn} Yiddish in Latin script</source>
          <target state="translated">주목할만한 형태 : {yi-latn} 라틴어 이디시어</target>
        </trans-unit>
        <trans-unit id="ce063fbcb3861605804d4088b9e6f420c033d1af" translate="yes" xml:space="preserve">
          <source>Notably, when I say &quot;the parser should do Y&quot;, the parser may fail to do Y, if the calling application explicitly requests that the parser</source>
          <target state="translated">특히, &quot;파서가 Y를 수행해야한다&quot;라고 말하면 호출 응용 프로그램이 파서에 명시 적으로 요청하면 파서는 Y를 수행하지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="dc28f0d8c7871400478b567d7beb2004cf42a815" translate="yes" xml:space="preserve">
          <source>Note - The UID &amp;amp; GID are stored as 16-bit integers in the &quot;Ux&quot; field. Use &lt;code&gt;exUnixN&lt;/code&gt; if your UID or GID are 32-bit.</source>
          <target state="translated">참고-UID 및 GID는 &quot;Ux&quot;필드에 16 비트 정수로 저장됩니다. UID 또는 GID가 32 비트 인 경우 &lt;code&gt;exUnixN&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5f25c29f636a35a4c90bd02e8d836521729b1940" translate="yes" xml:space="preserve">
          <source>Note For File::Spec::Win32 Maintainers</source>
          <target state="translated">File :: Spec :: Win32 관리자의 경우</target>
        </trans-unit>
        <trans-unit id="d61819593fe5205b29d4ef1cfda4d5a9bf3fa4b5" translate="yes" xml:space="preserve">
          <source>Note also that &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; will refuse to overwrite part of a substitution that has already been replaced; so for example this will stop after the first iteration, rather than iterating its way backwards through the string:</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 는 이미 교체 된 교체의 일부를 덮어 쓰지 않습니다. 예를 들어 문자열을 거꾸로 반복하는 대신 첫 번째 반복 후에 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="51303d3d7fafd34353273486b77b3443cc1441d4" translate="yes" xml:space="preserve">
          <source>Note also that executable files on OS/2 can have an arbitrary extension, but</source>
          <target state="translated">또한 OS / 2의 실행 파일은 임의의 확장자를 가질 수 있지만</target>
        </trans-unit>
        <trans-unit id="1ef8e44dd4ec6271a5e9810987c5e736596eec8b" translate="yes" xml:space="preserve">
          <source>Note also that some interactions with the platform's operating system never use Unicode rules.</source>
          <target state="translated">또한 플랫폼 운영 체제와의 일부 상호 작용에는 유니 코드 규칙이 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c4edd6fd44da89a951836e2357c62c606b0748a9" translate="yes" xml:space="preserve">
          <source>Note also that some versions of &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; cannot lock things over the network; you would need to use the more system-specific &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; for that. If you like you can force Perl to ignore your system's flock(2) function, and so provide its own fcntl(2)-based emulation, by passing the switch &lt;code&gt;-Ud_flock&lt;/code&gt; to the</source>
          <target state="translated">또한 일부 버전의 &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 는 네트워크를 통해 물건을 잠글 수 없습니다. 이를 위해 더 많은 시스템 별 &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; 을 사용해야합니다. 원하는 경우 Perl이 시스템의 flock (2) 함수를 무시하도록 강제 할 수 있으므로 스위치 &lt;code&gt;-Ud_flock&lt;/code&gt; 을 시스템 에 전달하여 자체 fcntl (2) 기반 에뮬레이션 을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="9506516245f2a27d70f794e303e94668077d4724" translate="yes" xml:space="preserve">
          <source>Note also that some versions of &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; cannot lock things over the network; you would need to use the more system-specific &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; for that. If you like you can force Perl to ignore your system's flock(2) function, and so provide its own fcntl(2)-based emulation, by passing the switch &lt;code&gt;-Ud_flock&lt;/code&gt; to the</source>
          <target state="translated">또한 일부 버전의 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 는 네트워크를 통해 물건을 잠글 수 없습니다. 이를 위해 더 많은 시스템 별 &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; 을 사용해야합니다. 원하는 경우 Perl이 시스템의 flock (2) 함수를 무시하도록 강제 할 수 있으므로 스위치 &lt;code&gt;-Ud_flock&lt;/code&gt; 을 시스템 에 전달하여 자체 fcntl (2) 기반 에뮬레이션 을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="31429c82fc67ac62603cde51ce1f5c6cd992a1a1" translate="yes" xml:space="preserve">
          <source>Note also that the</source>
          <target state="translated">또한</target>
        </trans-unit>
        <trans-unit id="0c84d355b563eeba64d66feb2a9301f9ac3044ba" translate="yes" xml:space="preserve">
          <source>Note also that the &lt;code&gt;p&lt;/code&gt; modifier is special in that its presence anywhere in a pattern has a global effect.</source>
          <target state="translated">참고 또한 것을 &lt;code&gt;p&lt;/code&gt; 수정은 패턴의 존재 어디서나 글로벌 효과를 갖는 것을 특별하다.</target>
        </trans-unit>
        <trans-unit id="44f63e7551b1c1b479c5f1d972a1f2245b31f7f2" translate="yes" xml:space="preserve">
          <source>Note also that the command &lt;code&gt;perldoc perllocal&lt;/code&gt; gives you a (possibly incomplete) list of the modules that have been further installed on your system. (The perllocal.pod file is updated by the standard MakeMaker install process.)</source>
          <target state="translated">또한 &lt;code&gt;perldoc perllocal&lt;/code&gt; 명령 은 시스템에 추가로 설치된 모듈의 목록 (불완전한 목록)을 제공합니다. perllocal.pod 파일은 표준 MakeMaker 설치 프로세스에 의해 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="974ae7d8c658ab7fcbda1dde2814ab3d89d6f088" translate="yes" xml:space="preserve">
          <source>Note also that the copy constructor (key &lt;code&gt;'='&lt;/code&gt; ) may be autogenerated, but only for objects based on scalars. See &lt;a href=&quot;#Copy-Constructor&quot;&gt;Copy Constructor&lt;/a&gt;.</source>
          <target state="translated">또한 복사 생성자 (키 &lt;code&gt;'='&lt;/code&gt; )는 자동 생성 될 수 있지만 스칼라를 기반으로하는 오브젝트에 대해서만 가능합니다. &lt;a href=&quot;#Copy-Constructor&quot;&gt;복사 생성자를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="33d1b08cb96b172739c41421853e346d699284ca" translate="yes" xml:space="preserve">
          <source>Note also that the differences between PM and VIO executables are only in the</source>
          <target state="translated">PM과 VIO 실행 파일의 차이점은</target>
        </trans-unit>
        <trans-unit id="8a0b196123450466a3bd0e991b94e36c4a2d4091" translate="yes" xml:space="preserve">
          <source>Note also that the interpolation code needs to make a decision on where the interpolated scalar ends. For instance, whether &lt;code&gt;&quot;a $x -&amp;gt; {c}&quot;&lt;/code&gt; really means:</source>
          <target state="translated">보간 코드는 보간 된 스칼라가 끝나는 위치를 결정해야합니다. 예를 들어 &lt;code&gt;&quot;a $x -&amp;gt; {c}&quot;&lt;/code&gt; 실제로 다음을 의미 하는지 여부 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="461724a83047bdefd7b18b66a849277d50c6ddf4" translate="yes" xml:space="preserve">
          <source>Note also that the perl command-line utilities (e.g. perldoc) and any that are added by modules that you install will be under /usr/perl5/bin, so that directory should be added to your PATH.</source>
          <target state="translated">또한 perl 명령 행 유틸리티 (예 : perldoc) 및 설치 한 모듈에 의해 추가 된 유틸리티는 / usr / perl5 / bin 아래에 있으므로 디렉토리가 PATH에 추가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="b1c8981415e4845f7fa3c8120b6871be02377a53" translate="yes" xml:space="preserve">
          <source>Note also that the variable is not visible until the following</source>
          <target state="translated">또한 변수는 다음까지 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="da9eb4f7f742f4aab3f9b8b74e916fc9f5d30c44" translate="yes" xml:space="preserve">
          <source>Note also that the whole range idea is rather unportable between character sets, except for four situations that Perl handles specially. Any subset of the ranges &lt;code&gt;[A-Z]&lt;/code&gt; , &lt;code&gt;[a-z]&lt;/code&gt; , and &lt;code&gt;[0-9]&lt;/code&gt; are guaranteed to match the expected subset of ASCII characters, no matter what character set the platform is running. The fourth portable way to specify ranges is to use the &lt;code&gt;\N{...}&lt;/code&gt; syntax to specify either end point of the range. For example, &lt;code&gt;[\N{U+04}-\N{U+07}]&lt;/code&gt; means to match the Unicode code points &lt;code&gt;\N{U+04}&lt;/code&gt; , &lt;code&gt;\N{U+05}&lt;/code&gt; , &lt;code&gt;\N{U+06}&lt;/code&gt; , and &lt;code&gt;\N{U+07}&lt;/code&gt; , whatever their native values may be on the platform. Under &lt;a href=&quot;re#'strict'-mode&quot;&gt;use re 'strict'&lt;/a&gt; or within a &lt;a href=&quot;#(%3f%5b-%5d)&quot;&gt;(?[ ])&lt;/a&gt;, a warning is raised, if enabled, and the other end point of a range which has a &lt;code&gt;\N{...}&lt;/code&gt; endpoint is not portably specified. For example,</source>
          <target state="translated">또한 Perl이 특별히 처리하는 네 가지 상황을 제외하고 전체 범위 아이디어는 문자 세트간에 이식하기가 쉽지 않습니다. &lt;code&gt;[A-Z]&lt;/code&gt; , &lt;code&gt;[a-z]&lt;/code&gt; 및 &lt;code&gt;[0-9]&lt;/code&gt; 범위의 모든 하위 세트는 플랫폼이 실행중인 문자 세트에 상관없이 ASCII 문자의 예상 하위 세트와 일치하도록 보장됩니다. 범위를 지정하는 네 번째 이식 가능한 방법은 &lt;code&gt;\N{...}&lt;/code&gt; 구문을 사용하여 범위의 끝점을 지정하는 것입니다. 예를 들어, &lt;code&gt;[\N{U+04}-\N{U+07}]&lt;/code&gt; 은 유니 코드 코드 포인트 &lt;code&gt;\N{U+04}&lt;/code&gt; , &lt;code&gt;\N{U+05}&lt;/code&gt; , &lt;code&gt;\N{U+06}&lt;/code&gt; 과 일치 함을 의미합니다. , 및 &lt;code&gt;\N{U+07}&lt;/code&gt; , 플랫폼에서 기본 값이 무엇이든간에. 아래에&lt;a href=&quot;re#'strict'-mode&quot;&gt;re 'strict'&lt;/a&gt; 또는 &lt;a href=&quot;#(%3f%5b-%5d)&quot;&gt;(? []) 내&lt;/a&gt; 에서 사용하면 경고가 발생하고 사용 가능한 경우 &lt;code&gt;\N{...}&lt;/code&gt; 엔드 포인트가 있는 범위의 다른 엔드 포인트를 지정할 수 없습니다. 예를 들어</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
