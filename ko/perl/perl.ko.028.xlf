<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="700d8f92e3038752feec96509274cbd7256d79dc" translate="yes" xml:space="preserve">
          <source>If you can't configure &lt;code&gt;TAP::Harness&lt;/code&gt; to do what you want, and you can't find an existing plugin, consider writing one.</source>
          <target state="translated">원하는 것을 수행 하도록 &lt;code&gt;TAP::Harness&lt;/code&gt; 를 구성 할 수없고 기존 플러그인을 찾을 수없는 경우 작성해보십시오.</target>
        </trans-unit>
        <trans-unit id="edcd365c3753fb0814dbbf4b5f1da5978fabe2e0" translate="yes" xml:space="preserve">
          <source>If you can't use &lt;a href=&quot;file/copy&quot;&gt;File::Copy&lt;/a&gt;, you'll have to do the work yourself: open the original file, open the destination file, then print to the destination file as you read the original. You also have to remember to copy the permissions, owner, and group to the new file.</source>
          <target state="translated">&lt;a href=&quot;file/copy&quot;&gt;File :: Copy를&lt;/a&gt; 사용할 수없는 경우 직접 작업해야합니다. 원본 파일을 열고 대상 파일을 연 다음 원본을 읽을 때 대상 파일로 인쇄하십시오. 또한 권한, 소유자 및 그룹을 새 파일로 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="2431416836e7be159e91db05fdcbf62b13f365c1" translate="yes" xml:space="preserve">
          <source>If you cannot achieve the desired Makefile behaviour by specifying attributes you may define private subroutines in the Makefile.PL. Each subroutine returns the text it wishes to have written to the Makefile. To override a section of the Makefile you can either say:</source>
          <target state="translated">속성을 지정하여 원하는 Makefile 동작을 수행 할 수없는 경우 Makefile.PL에 개인 서브 루틴을 정의 할 수 있습니다. 각 서브 루틴은 Makefile에 쓰려고하는 텍스트를 반환합니다. Makefile의 섹션을 재정의하려면 다음과 같이 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="069db45c3cccee54b16dacbbc26ce2a59fc37a49" translate="yes" xml:space="preserve">
          <source>If you cannot upgrade your Perl to 5.8.0 or later, you can still do some Unicode processing by using the modules &lt;code&gt;Unicode::String&lt;/code&gt; , &lt;code&gt;Unicode::Map8&lt;/code&gt; , and &lt;code&gt;Unicode::Map&lt;/code&gt; , available from CPAN. If you have the GNU recode installed, you can also use the Perl front-end &lt;code&gt;Convert::Recode&lt;/code&gt; for character conversions.</source>
          <target state="translated">Perl을 5.8.0 이상으로 업그레이드 할 수없는 경우 CPAN에서 사용 가능한 &lt;code&gt;Unicode::String&lt;/code&gt; , &lt;code&gt;Unicode::Map8&lt;/code&gt; 및 &lt;code&gt;Unicode::Map&lt;/code&gt; 모듈을 사용하여 일부 유니 코드 처리를 계속할 수 있습니다. GNU 레코딩이 설치되어 있으면 문자 변환에 Perl 프론트 엔드 &lt;code&gt;Convert::Recode&lt;/code&gt; 를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f06f83624114fcf502e132fac57a686e4d7a4ee" translate="yes" xml:space="preserve">
          <source>If you cannot use &lt;a href=&quot;list/util&quot;&gt;List::Util&lt;/a&gt;, you can make your own loop to do the same thing. Once you find the element, you stop the loop with last.</source>
          <target state="translated">&lt;a href=&quot;list/util&quot;&gt;List :: Util을&lt;/a&gt; 사용할 수없는 경우 동일한 작업을 수행하도록 자체 루프를 만들 수 있습니다. 요소를 찾으면 마지막으로 루프를 중지합니다.</target>
        </trans-unit>
        <trans-unit id="83e89259781d3b7bf972995b7c8dc74ef7aacff4" translate="yes" xml:space="preserve">
          <source>If you cannot use the git protocol for firewall reasons, you can also clone via http, though this is much slower:</source>
          <target state="translated">방화벽 이유로 git 프로토콜을 사용할 수없는 경우 http를 통해 복제 할 수도 있지만 속도는 훨씬 느립니다.</target>
        </trans-unit>
        <trans-unit id="794395d65809aff375720f1da63fe61351840429" translate="yes" xml:space="preserve">
          <source>If you change &lt;code&gt;$pattern&lt;/code&gt; after the first substitution happens, Perl will ignore it. If you don't want any substitutions at all, use the special delimiter &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m''&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">첫 번째 대체가 발생한 후 &lt;code&gt;$pattern&lt;/code&gt; 을 변경하면 Perl은이를 무시합니다. 당신이 전혀 대체를 원하지 않는 경우, 특별한 구분 기호 사용 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m''&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bca560012b71cc8dce8e6a03ec54196daca3d350" translate="yes" xml:space="preserve">
          <source>If you check &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;, you'll see that several of the ways to call open() should do the trick. For example:</source>
          <target state="translated">&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; 을 확인 하면 open ()을 호출하는 몇 가지 방법이 트릭을 수행해야 함을 알 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e4dedfaceb9670f08b0798c739b80203032d536c" translate="yes" xml:space="preserve">
          <source>If you chomp a list, each element is chomped, and the total number of characters removed is returned.</source>
          <target state="translated">목록을 숨기면 각 요소가 잘리고 제거 된 총 문자 수가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="716512a060dd3d5999bac2b4045e2b9123dc9b1b" translate="yes" xml:space="preserve">
          <source>If you choose XL C/C++ V11 you need the April 2010 PTF (or newer) installed otherwise you will not get a working Perl version.</source>
          <target state="translated">XL C / C ++ V11을 선택하면 2010 년 4 월 PTF (또는 그 이상)가 설치되어 있어야합니다. 그렇지 않으면 작동하는 Perl 버전이 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c10052f207d29ada4465d2d73fcdfabf3621a0b6" translate="yes" xml:space="preserve">
          <source>If you choose XL C/C++ V9 you need APAR IZ35785 installed otherwise the integrated SDBM_File do not compile correctly due to an optimization bug. You can circumvent this problem by adding -qipa to the optimization flags (-Doptimize='-O -qipa'). The PTF for APAR IZ35785 which solves this problem is available from IBM (April 2009 PTF for XL C/C++ Enterprise Edition for AIX, V9.0).</source>
          <target state="translated">XL C / C ++ V9를 선택하면 APAR IZ35785를 설치해야합니다. 그렇지 않으면 최적화 버그로 인해 통합 SDBM_File이 올바르게 컴파일되지 않습니다. 최적화 플래그에 -qipa를 추가하여이 문제를 피할 수 있습니다 (-Doptimize = '-O -qipa'). 이 문제점을 해결하는 APAR IZ35785의 PTF는 IBM에서 사용할 수 있습니다 (AIX, V9.0 용 XL C / C ++ Enterprise Edition의 2009 년 4 월 PTF).</target>
        </trans-unit>
        <trans-unit id="fb54bcde599a5f03b31c1ac1b1fac745b31dc5b8" translate="yes" xml:space="preserve">
          <source>If you choose for the PTH package, use swinstall to install pth in the default location (/opt/pth), and then make symbolic links to the libraries from /usr/lib</source>
          <target state="translated">PTH 패키지를 선택한 경우 swinstall을 사용하여 기본 위치 (/ opt / pth)에 pth를 설치 한 다음 / usr / lib에서 라이브러리에 대한 심볼릭 링크를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="5ca7b309ef65dd317303754f8c4a5fd3689e4197" translate="yes" xml:space="preserve">
          <source>If you choose gcc to compile 64-bit Perl then you need to add the following option:</source>
          <target state="translated">64 비트 Perl을 컴파일하기 위해 gcc를 선택하면 다음 옵션을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="875c1fe2de9773e7e9366d0703f2a602deb9c197" translate="yes" xml:space="preserve">
          <source>If you chop a list, each element is chopped. Only the value of the last &lt;code&gt;&lt;a href=&quot;chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">목록을 자르면 각 요소가 잘립니다. 마지막 &lt;code&gt;&lt;a href=&quot;chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; 값만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="03160d33f05c1b78628995f8692e16c5933ebe05" translate="yes" xml:space="preserve">
          <source>If you chop a list, each element is chopped. Only the value of the last &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">목록을 자르면 각 요소가 잘립니다. 마지막 &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; 값만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="caf1e734b10683713e7d496bb52630f5b34525d0" translate="yes" xml:space="preserve">
          <source>If you compile and run</source>
          <target state="translated">컴파일하고 실행하면</target>
        </trans-unit>
        <trans-unit id="4359b9f0177138527f6b61e374c639bb3caf7642" translate="yes" xml:space="preserve">
          <source>If you completely hide the short forms of the Perl public API, add -DPERL_NO_SHORT_NAMES to the compilation flags. This means that for example instead of writing</source>
          <target state="translated">짧은 형식의 Perl 공용 API를 완전히 숨기면 컴파일 플래그에 -DPERL_NO_SHORT_NAMES를 추가하십시오. 이것은 예를 들어 쓰는 대신</target>
        </trans-unit>
        <trans-unit id="7e117fe20aeb505e6fb3bd26d20ee9983d45c623" translate="yes" xml:space="preserve">
          <source>If you consult &lt;code&gt;perldoc -f &lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; you will see that &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; will behave differently when given a bareword or a string.</source>
          <target state="translated">당신이 상담하는 경우 &lt;code&gt;perldoc -f &lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 당신이 볼 &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; bareword는 나 문자열을 투여했을 때 다르게 동작합니다.</target>
        </trans-unit>
        <trans-unit id="e933e27b4b6affb17bacc2be8545945df23e47f1" translate="yes" xml:space="preserve">
          <source>If you create interpreters in one thread and then proceed to call them in another, you need to make sure perl's own Thread Local Storage (TLS) slot is initialized correctly in each of those threads.</source>
          <target state="translated">한 스레드에서 인터프리터를 작성하고 다른 스레드에서 인터프리터를 호출하는 경우 perl의 자체 스레드 로컬 스토리지 (TLS) 슬롯이 각 스레드에서 올바르게 초기화되었는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="4e50c2bd9e835a3a7f1961b7856f6dac61424cbe" translate="yes" xml:space="preserve">
          <source>If you decide to ignore this advice and use the GNU versions anyway, then be sure that they are relatively recent. Versions newer than 2.7 are apparently new enough. Older versions may have trouble with dynamic loading.</source>
          <target state="translated">이 조언을 무시하고 어쨌든 GNU 버전을 사용하기로 결정했다면 비교적 최신 버전인지 확인하십시오. 2.7보다 새로운 버전은 충분히 새로운 버전입니다. 이전 버전은 동적 로딩에 문제가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff55c7f7dfadd85537843d3b167612c0ffcaee31" translate="yes" xml:space="preserve">
          <source>If you decide to use a different version of the zlib library, you need to be aware of the following issues</source>
          <target state="translated">다른 버전의 zlib 라이브러리를 사용하기로 결정한 경우 다음 문제를 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="dea32ebc2834b73dcbf2cbd2fdecffa9453ead2d" translate="yes" xml:space="preserve">
          <source>If you decide to use gcc, make sure your installation is recent and complete, and be sure to read the Perl INSTALL file for more gcc-specific details.</source>
          <target state="translated">gcc를 사용하기로 결정한 경우, 설치가 최신이고 완전한지 확인하고 더 자세한 gcc 특정 세부 사항은 Perl INSTALL 파일을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="275ebe9364d1067d763d9e8ee83a9ef9cef15d89" translate="yes" xml:space="preserve">
          <source>If you decide to use gcc, make sure your installation is recent and complete, and be sure to read the Perl INSTALL file for more gcc-specific details. Please report any hoops you had to jump through to the development team.</source>
          <target state="translated">gcc를 사용하기로 결정한 경우, 설치가 최신이고 완전한지 확인하고 더 자세한 gcc 특정 세부 사항은 Perl INSTALL 파일을 읽으십시오. 개발 팀에 뛰어 넘어야 할 농구대를보고하십시오.</target>
        </trans-unit>
        <trans-unit id="129ecc12b1557dd3798539452dbf9b9ea8476c0d" translate="yes" xml:space="preserve">
          <source>If you define an &lt;code&gt;AUTOLOAD&lt;/code&gt; in your class, then Perl will call your &lt;code&gt;AUTOLOAD&lt;/code&gt; to handle the &lt;code&gt;DESTROY&lt;/code&gt; method. You can prevent this by defining an empty &lt;code&gt;DESTROY&lt;/code&gt; , like we did in the autoloading example. You can also check the value of &lt;code&gt;$AUTOLOAD&lt;/code&gt; and return without doing anything when called to handle &lt;code&gt;DESTROY&lt;/code&gt; .</source>
          <target state="translated">클래스에서 &lt;code&gt;AUTOLOAD&lt;/code&gt; 를 정의하면 Perl은 &lt;code&gt;AUTOLOAD&lt;/code&gt; 를 호출하여 &lt;code&gt;DESTROY&lt;/code&gt; 메소드 를 처리합니다 . 자동로드 예제에서와 같이 빈 &lt;code&gt;DESTROY&lt;/code&gt; 를 정의하여이를 방지 할 수 있습니다 . &lt;code&gt;DESTROY&lt;/code&gt; 처리를 위해 호출 될 때 아무 작업도하지 않고 &lt;code&gt;$AUTOLOAD&lt;/code&gt; 값을 확인 하고 반환 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="94eb8ac68c4fb558c46d1ee64b3833ca570000ed" translate="yes" xml:space="preserve">
          <source>If you define more than one name for the code point, it is indeterminate which one will be returned.</source>
          <target state="translated">코드 포인트에 대해 둘 이상의 이름을 정의하면 어떤 이름이 리턴 될지 결정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="04b2ed76508ea6501a561cd368f25fd856dfc7e2" translate="yes" xml:space="preserve">
          <source>If you develop any useful expiration managers that you think should be distributed with Memoize, please let me know.</source>
          <target state="translated">Memoize와 함께 배포해야한다고 생각되는 유용한 만료 관리자를 개발하는 경우 알려주십시오.</target>
        </trans-unit>
        <trans-unit id="0cf4a8657eebfe97ba9c4e743bd983d09e5edaa6" translate="yes" xml:space="preserve">
          <source>If you didn't use &lt;code&gt;openlog()&lt;/code&gt; before using &lt;code&gt;syslog()&lt;/code&gt; , &lt;code&gt;syslog()&lt;/code&gt; will try to guess the &lt;code&gt;$ident&lt;/code&gt; by extracting the shortest prefix of &lt;code&gt;$format&lt;/code&gt; that ends in a &lt;code&gt;&quot;:&quot;&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;syslog()&lt;/code&gt; &lt;code&gt;openlog()&lt;/code&gt; 를 사용하기 전에 openlog () 를 사용 하지 않은 경우 , &lt;code&gt;syslog()&lt;/code&gt; 는 &lt;code&gt;&quot;:&quot;&lt;/code&gt; 로 끝나는 &lt;code&gt;$format&lt;/code&gt; 의 가장 짧은 접두사를 추출하여 &lt;code&gt;$ident&lt;/code&gt; 를 추측하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="06ed1961687b0abd10e165d61c48cda9ac3ae785" translate="yes" xml:space="preserve">
          <source>If you discover some glitches, move directories of problematic modules to a different location; if these modules are non-XS modules, you may just ignore them - they are already installed; the remaining, XS, modules you need to install manually one by one.</source>
          <target state="translated">결함이 발견되면 문제가있는 모듈의 디렉토리를 다른 위치로 이동하십시오. 이러한 모듈이 비 XS 모듈 인 경우 무시해도됩니다. 이미 설치되어 있습니다. 나머지 XS 모듈은 하나씩 수동으로 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="43d56dedc7192e637755e1fdcd48fbf68cbff70a" translate="yes" xml:space="preserve">
          <source>If you do</source>
          <target state="translated">당신이 할 경우</target>
        </trans-unit>
        <trans-unit id="87ef7e6c621828b29eab79e96b5fb6269cd00a77" translate="yes" xml:space="preserve">
          <source>If you do not enter the shell, shell commands are available both as methods (&lt;code&gt;CPAN::Shell-&amp;gt;install(...)&lt;/code&gt; ) and as functions in the calling package (&lt;code&gt;install(...)&lt;/code&gt; ). Before calling low-level commands, it makes sense to initialize components of CPAN you need, e.g.:</source>
          <target state="translated">쉘을 입력하지 않으면 쉘 명령은 메소드 ( &lt;code&gt;CPAN::Shell-&amp;gt;install(...)&lt;/code&gt; )와 호출 패키지 ( &lt;code&gt;install(...)&lt;/code&gt; )의 함수로 사용할 수 있습니다. 저수준 명령을 호출하기 전에 필요한 CPAN의 구성 요소를 초기화하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="bc816a9fd08d7a00464780adbf72cc89737d7fde" translate="yes" xml:space="preserve">
          <source>If you do not have</source>
          <target state="translated">당신이없는 경우</target>
        </trans-unit>
        <trans-unit id="69ced298dbf1c87fefd1662253cccc2e7a8bde7d" translate="yes" xml:space="preserve">
          <source>If you do not have a copy of the GNU General Public License write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</source>
          <target state="translated">GNU 일반 공중 사용 허가서 사본이없는 경우, 미국 MA 02139, 케임브리지 소재 675 Mass Ave, Free Software Foundation, Inc.에 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="f9c124bac0783d0b5dcccc34a0dbf3566f426f11" translate="yes" xml:space="preserve">
          <source>If you do not have that module, you can do the same thing with &lt;a href=&quot;file/find&quot;&gt;File::Find&lt;/a&gt; which is part of the standard library:</source>
          <target state="translated">해당 모듈이없는 경우 표준 라이브러리의 일부인 &lt;a href=&quot;file/find&quot;&gt;File :: Find&lt;/a&gt; 를 사용하여 동일한 작업을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bd07d5a5c26be6eca98f51764342db5783f35fa8" translate="yes" xml:space="preserve">
          <source>If you do not know what shell you have, consult your local helpdesk or the equivalent.</source>
          <target state="translated">어떤 쉘을 가지고 있는지 모르는 경우, 해당 지역의 헬프 데스크 또는 이와 동등한 것을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1de6e3279f2bd155e7f8bf6759e637927cce20be" translate="yes" xml:space="preserve">
          <source>If you do not set this flag then it is</source>
          <target state="translated">이 플래그를 설정하지 않으면</target>
        </trans-unit>
        <trans-unit id="926a166805dd3b0aef3dd1d472d192955fb1ec52" translate="yes" xml:space="preserve">
          <source>If you do not specify a package name, the variable is created in the current package.</source>
          <target state="translated">패키지 이름을 지정하지 않으면 변수가 현재 패키지에 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="3b6ac2382b8b465b26d1901487c44646a3e50e04" translate="yes" xml:space="preserve">
          <source>If you do not want to call the package's &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method (for instance, to stop your namespace from being altered), explicitly supply the empty list:</source>
          <target state="translated">패키지의 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 메소드 를 호출하지 않으려면 (예 : 네임 스페이스 변경을 중지하기 위해) 빈 목록을 명시 적으로 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="ea10c1ff3a243c28f284c149e22c1d185c65b318" translate="yes" xml:space="preserve">
          <source>If you do not want to call the package's &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method (for instance, to stop your namespace from being altered), explicitly supply the empty list:</source>
          <target state="translated">패키지의 &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 메소드 를 호출하지 않으려면 (예 : 네임 스페이스 변경을 중지하기 위해) 빈 목록을 명시 적으로 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="8470234c0d68b289fd8da0f074a387fae1ae490f" translate="yes" xml:space="preserve">
          <source>If you do not want to use these defaults they can be overridden by explicitly setting the &lt;code&gt;Name&lt;/code&gt; , &lt;code&gt;Time&lt;/code&gt; , &lt;code&gt;TextFlag&lt;/code&gt; , &lt;code&gt;ExtAttr&lt;/code&gt; , &lt;code&gt;exUnixN&lt;/code&gt; and &lt;code&gt;exTime&lt;/code&gt; options or by setting the &lt;code&gt;Minimal&lt;/code&gt; parameter.</source>
          <target state="translated">이러한 기본값을 사용하지 않으려면 &lt;code&gt;Name&lt;/code&gt; , &lt;code&gt;Time&lt;/code&gt; , &lt;code&gt;TextFlag&lt;/code&gt; , &lt;code&gt;ExtAttr&lt;/code&gt; , &lt;code&gt;exUnixN&lt;/code&gt; 및 &lt;code&gt;exTime&lt;/code&gt; 옵션 을 명시 적으로 설정 하거나 &lt;code&gt;Minimal&lt;/code&gt; 매개 변수 를 설정하여 이를 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f15a287c32e6f66173e359fbddfbe362d18b693a" translate="yes" xml:space="preserve">
          <source>If you do not want to use these defaults they can be overridden by explicitly setting the &lt;code&gt;Name&lt;/code&gt; and &lt;code&gt;Time&lt;/code&gt; options or by setting the &lt;code&gt;Minimal&lt;/code&gt; parameter.</source>
          <target state="translated">이러한 기본값을 사용하지 않으려면 &lt;code&gt;Name&lt;/code&gt; 및 &lt;code&gt;Time&lt;/code&gt; 옵션 을 명시 적으로 설정 하거나 &lt;code&gt;Minimal&lt;/code&gt; 매개 변수 를 설정하여 이를 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c647e4788bb29e5dcf3d258b1e0dc34c9ef54f62" translate="yes" xml:space="preserve">
          <source>If you do not wish this to happen, you should provide an array reference, where all parts of your command are already separated out. Note however, if there are extra or spurious whitespaces in these parts, the parser or underlying code may not interpret it correctly, and cause an error.</source>
          <target state="translated">이런 일이 일어나지 않게하려면 명령의 모든 부분이 이미 분리되어있는 배열 참조를 제공해야합니다. 그러나 이러한 부분에 추가 공백이나 허위 공백이 있으면 구문 분석기 또는 기본 코드가이를 올바르게 해석하지 못하여 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f09ee5e6b9af0c82c4326addc62e789f8443f5c" translate="yes" xml:space="preserve">
          <source>If you do not wish to install the &lt;a href=&quot;http://search.cpan.org/perldoc/Module::Starter&quot;&gt;Module::Starter&lt;/a&gt; package from CPAN,</source>
          <target state="translated">CPAN에서 &lt;a href=&quot;http://search.cpan.org/perldoc/Module::Starter&quot;&gt;Module :: Starter&lt;/a&gt; 패키지 를 설치하지 않으려면</target>
        </trans-unit>
        <trans-unit id="0549310bae0dd74950be604da632c91876f7d8c0" translate="yes" xml:space="preserve">
          <source>If you do set &lt;code&gt;$File::Find::dont_use_nlink&lt;/code&gt; to 1, you will notice slow-downs.</source>
          <target state="translated">당신이 설정하는 경우 &lt;code&gt;$File::Find::dont_use_nlink&lt;/code&gt; 1로, 당신은 속도 저하를 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="feef0b7ae2868ad2a4e1f83d30c63fb0d93e6be4" translate="yes" xml:space="preserve">
          <source>If you do this in a binary operator, you will actually change one of the strings that came into the operator, and, while it shouldn't be noticeable by the end user, it can cause problems in deficient code.</source>
          <target state="translated">이진 연산자로이 작업을 수행하면 실제로 연산자에 들어온 문자열 중 하나를 변경하게되며 최종 사용자가 눈에 띄지 않아야하지만 코드 부족 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32f0578310d415019b09f619288e373d3b705f8d" translate="yes" xml:space="preserve">
          <source>If you do want this subroutine to be a closure that reflects future changes to the variable that it closes over, add an explicit &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">이 서브 루틴이 닫히는 변수의 향후 변경 사항을 반영하는 클로저가되도록하려면 명시적인 &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="7553259d39face4afb80ca316b04630713e25671" translate="yes" xml:space="preserve">
          <source>If you do want to work with large integers like under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; , try &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint;&lt;/code&gt; :</source>
          <target state="translated">under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; 와 같은 큰 정수로 작업 하려면 ; 시도 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a338314884729930813df6e4dec44b70118fce2d" translate="yes" xml:space="preserve">
          <source>If you don't ask for any feature, you get the list of features that the user requested you to be nice to. This has the nice side effect that if you don't respect anything in particular then you can just ask for it and use it like a boolean.</source>
          <target state="translated">기능을 요청하지 않으면 사용자가 친절하게 요청한 기능 목록이 표시됩니다. 이것은 당신이 특히 아무것도 존중하지 않으면 그것을 요구하고 그것을 부울처럼 사용할 수 있다는 좋은 부작용이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5b6d156d7cf6f2a797778536a48c223724f9360" translate="yes" xml:space="preserve">
          <source>If you don't care about the order of the elements, you could just create the hash then extract the keys. It's not important how you create that hash: just that you use &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; to get the unique elements.</source>
          <target state="translated">요소의 순서에 신경 쓰지 않으면 해시를 만든 다음 키를 추출하면됩니다. 해시를 만드는 방법은 중요하지 않습니다. &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 를 사용 하여 고유 한 요소를 얻는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e21625178e6b6545fac5abe6f5027d91ef293d91" translate="yes" xml:space="preserve">
          <source>If you don't care about where digits and underscore sort to, you can do something like this</source>
          <target state="translated">숫자와 밑줄이 정렬되는 위치에 신경 쓰지 않으면 다음과 같이 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="f92e493c5048826b06ef70fc4669cac080dfe915" translate="yes" xml:space="preserve">
          <source>If you don't care that one hash overwrites keys and values from the other, you could just use a hash slice to add one hash to another. In this case, values from &lt;code&gt;%hash2&lt;/code&gt; replace values from &lt;code&gt;%hash1&lt;/code&gt; when they have keys in common:</source>
          <target state="translated">한 해시가 다른 해시의 키와 값을 덮어 쓰는 것을 신경 쓰지 않으면 해시 슬라이스를 사용하여 하나의 해시를 다른 해시에 추가 할 수 있습니다. 이 경우 &lt;code&gt;%hash2&lt;/code&gt; 값은 공통 키가있을 때 &lt;code&gt;%hash1&lt;/code&gt; 값을 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="c43d001ee345c63043409156142b64f915867634" translate="yes" xml:space="preserve">
          <source>If you don't get a paragraph or two of expanded discussion, it might not be perl's message.</source>
          <target state="translated">확장 된 토론의 한두 단락을 얻지 못하면 펄의 메시지가 아닐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a12cb113cb2e2457200764dfd73d419fb8973d7" translate="yes" xml:space="preserve">
          <source>If you don't have File::Stream, you have to do a little more work.</source>
          <target state="translated">File :: Stream이 없으면 조금 더 많은 작업을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="ea4a8fbdbdee9b250414a6cc40a6c3e590cef92d" translate="yes" xml:space="preserve">
          <source>If you don't have data written with specific configuration of perl described above, then you do not and should not do anything. Don't set the flag - not only will Storable on an identically configured perl refuse to load them, but Storable a differently configured perl will load them believing them to be correct for it, and then may well fail or crash part way through reading them.</source>
          <target state="translated">위에서 설명한 perl의 특정 구성으로 작성된 데이터가 없으면 아무 것도 수행하지 않아야합니다. 플래그를 설정하지 마십시오-동일하게 구성된 펄의 Storable은로드를 거부 할뿐만 아니라, 다르게 구성된 펄은로드가 올바른 것으로 믿고로드 한 후 읽거나 실패 할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="36289d77701a121889713d6277f544f12a871bb4" translate="yes" xml:space="preserve">
          <source>If you don't have write access to the DBM file, you can only read hash variables, not set them. If you want to test whether you can write, either use file tests or try setting a dummy hash entry inside an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; to trap the error.</source>
          <target state="translated">DBM 파일에 대한 쓰기 액세스 권한이없는 경우 해시 변수 만 읽을 수 있으며 설정하지 않아도됩니다. 쓰기 가능 여부를 테스트하려면 파일 테스트를 사용하거나 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 내에 더미 해시 항목을 설정 하여 오류를 잡으십시오.</target>
        </trans-unit>
        <trans-unit id="bdbbd37031df2f33535ed6549b499d32ea9aa9e5" translate="yes" xml:space="preserve">
          <source>If you don't have write access to the DBM file, you can only read hash variables, not set them. If you want to test whether you can write, either use file tests or try setting a dummy hash entry inside an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; to trap the error.</source>
          <target state="translated">DBM 파일에 대한 쓰기 액세스 권한이없는 경우 해시 변수 만 읽을 수 있으며 설정하지 않아도됩니다. 쓰기 가능 여부를 테스트하려면 파일 테스트를 사용하거나 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 내에 더미 해시 항목을 설정 하여 오류를 잡으십시오.</target>
        </trans-unit>
        <trans-unit id="8f4b767528b9f98c2858aad05fc8520eae2c1d33" translate="yes" xml:space="preserve">
          <source>If you don't import any of these functions, assume a &lt;code&gt;&amp;amp;I18N::LangTags::&lt;/code&gt; in front of all the function names in the following examples.</source>
          <target state="translated">이러한 함수를 가져 오지 않으면 다음 예제에서 모든 함수 이름 앞에 &lt;code&gt;&amp;amp;I18N::LangTags::&lt;/code&gt; 를 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="107952179f7076da25aad77d14c209ced7df48df" translate="yes" xml:space="preserve">
          <source>If you don't know how many tests you're going to run, you can issue the plan when you're done running tests.</source>
          <target state="translated">실행할 테스트 수를 모를 경우 테스트 실행이 완료되면 계획을 발행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="209c65929fc8bcea028a0c96cf1f684c89334602" translate="yes" xml:space="preserve">
          <source>If you don't know what license to use, dual licensing under the GPL and Artistic licenses (the same as Perl itself) is a good idea. See &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlgpl.html&quot;&gt;perlgpl&lt;/a&gt; and &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlartistic.html&quot;&gt;perlartistic&lt;/a&gt;.</source>
          <target state="translated">어떤 라이센스를 사용해야하는지 모르는 경우 GPL 및 Artistic 라이센스 (Perl과 동일)에 따른 이중 라이센스를 사용하는 것이 좋습니다. &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlgpl.html&quot;&gt;perlgpl&lt;/a&gt; 및 &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlartistic.html&quot;&gt;perlartistic을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0afa056a783c1ff17e6396cee6d067cb1e22c33a" translate="yes" xml:space="preserve">
          <source>If you don't know whether a string contains YAML or JSON data, this method will use some heuristics and guess. If it can't tell, it assumes YAML.</source>
          <target state="translated">문자열에 YAML 또는 JSON 데이터가 포함되어 있는지 알 수없는 경우이 방법은 일부 추론 및 추측을 사용합니다. 말할 수 없으면 YAML이라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="d34593d2a30bd46dc846ad60717c333d071ef181" translate="yes" xml:space="preserve">
          <source>If you don't mind shelling out, the &lt;code&gt;wc&lt;/code&gt; command is usually the fastest, even with the extra interprocess overhead. Ensure that you have an untainted filename though:</source>
          <target state="translated">쉘링을 신경 쓰지 않으면 &lt;code&gt;wc&lt;/code&gt; 명령이 추가 프로세스 간 오버 헤드가 있어도 가장 빠릅니다. 그래도 감염되지 않은 파일 이름이 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="ab42639abd5abd9367c12d1d0ad1d1482fb0d4b6" translate="yes" xml:space="preserve">
          <source>If you don't need the existing content of the SV, you can avoid some copying with:</source>
          <target state="translated">SV의 기존 컨텐츠가 필요하지 않은 경우 다음을 사용하여 일부 복사를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd9e10a2452b68c075fcb32cabd703d0209267ed" translate="yes" xml:space="preserve">
          <source>If you don't need to know the name of the file, you can use &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in place of the file name. In Perl 5.8 or later, the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; function creates an anonymous temporary file:</source>
          <target state="translated">파일 이름을 알 필요가 없으면 파일 이름 대신 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 와 함께 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 을 사용할 수 있습니다 . Perl 5.8 이상에서 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 함수는 익명 임시 파일을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="b260604ab4c441d85ae092e22c063810eb4d30c0" translate="yes" xml:space="preserve">
          <source>If you don't provide an exact inverse transformation, you will find that code like this will not behave as you expect.</source>
          <target state="translated">정확한 역변환을 제공하지 않으면 이와 같은 코드가 예상대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="da9f240e2e4669201b3520ed7f3f5a0edd014292" translate="yes" xml:space="preserve">
          <source>If you don't really want to execute the first argument, but want to lie to the program you are executing about its own name, you can specify the program you actually want to run as an &quot;indirect object&quot; (without a comma) in front of the LIST, as in &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; . (This always forces interpretation of the LIST as a multivalued list, even if there is only a single scalar in the list.) Example:</source>
          <target state="translated">실제로 첫 번째 인수를 실행하고 싶지는 않지만 자신의 이름에 대해 실행중인 프로그램에 거짓말을하려면 실제로 &quot;간접 객체&quot;(쉼표없이)로 실행하려는 프로그램을 지정할 수 있습니다. &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; 에서와 같이 LIST 앞 . (목록에 단일 스칼라 만있는 경우에도 항상 LIST를 다중 값 목록으로 해석해야합니다.) 예 :</target>
        </trans-unit>
        <trans-unit id="90475a6e4998e8131a7d71a411d5204a133b0a81" translate="yes" xml:space="preserve">
          <source>If you don't really want to execute the first argument, but want to lie to the program you are executing about its own name, you can specify the program you actually want to run as an &quot;indirect object&quot; (without a comma) in front of the LIST, as in &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; . (This always forces interpretation of the LIST as a multivalued list, even if there is only a single scalar in the list.) Example:</source>
          <target state="translated">실제로 첫 번째 인수를 실행하고 싶지는 않지만 자신의 이름에 대해 실행중인 프로그램에 거짓말을하려면 실제로 &quot;간접 객체&quot;(쉼표없이)로 실행하려는 프로그램을 지정할 수 있습니다. &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; 에서와 같이 LIST 앞 . (목록에 단일 스칼라 만있는 경우에도 항상 LIST를 다중 값 목록으로 해석해야합니다.) 예 :</target>
        </trans-unit>
        <trans-unit id="1d09c87ff03423122d55e0fe04c7fdafafae320f" translate="yes" xml:space="preserve">
          <source>If you don't see an error message, you have the module. (If you do see an error message, it's still possible you have the module, but that it's not in your path, which you can display with &lt;code&gt;perl -e
&quot;print qq(@INC)&quot;&lt;/code&gt; .) For the remainder of this document, we'll assume that you really honestly truly lack an installed module, but have found it on the CPAN.</source>
          <target state="translated">오류 메시지가 표시되지 않으면 모듈이있는 것입니다. (오류 메시지가 표시되면 여전히 모듈이있을 수 있지만 경로에없는 것입니다. &lt;code&gt;perl -e &quot;print qq(@INC)&quot;&lt;/code&gt; 표시 할 수 있습니다 .이 문서의 나머지 부분에서, 우리는 당신에게 솔직히 설치된 모듈이 실제로 없다고 가정하지만 CPAN에서 발견했습니다.</target>
        </trans-unit>
        <trans-unit id="22a71969f2b2e317963f5563c127a63079459334" translate="yes" xml:space="preserve">
          <source>If you don't specify a &lt;code&gt;dw_size&lt;/code&gt; , it defaults to the entire memory limit.</source>
          <target state="translated">&lt;code&gt;dw_size&lt;/code&gt; 를 지정하지 않으면 기본적으로 전체 메모리 제한이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="d559d6056536d78595c17d437dfe78484f93f47a" translate="yes" xml:space="preserve">
          <source>If you don't understand this question, just press ENTER.</source>
          <target state="translated">이 질문을 이해하지 못하면 ENTER를 누르십시오.</target>
        </trans-unit>
        <trans-unit id="e1a9da1b5f8c61c5b3d264532c0386f7656b5414" translate="yes" xml:space="preserve">
          <source>If you don't want &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; to change your original variable you can use the non-destructive substitute modifier, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt;. This changes the behavior so that &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; returns the final substituted string (instead of the number of substitutions):</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 가 원래 변수를 변경 하지 않게 하려면 비파괴 대체 수정 자 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; 사용할 수 있습니다 . 이는 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; 이 대체 수 대신 최종 대체 문자열을 반환 하도록 동작을 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="b63f96d379f7a46f61c3872f0a57972ef07d6947" translate="yes" xml:space="preserve">
          <source>If you don't want any output should all modules be up to date, parse the output of above command for the regular expression &lt;code&gt;/modules are up to date/&lt;/code&gt; and decide to mail the output only if it doesn't match.</source>
          <target state="translated">모든 모듈을 최신 상태로 유지하려는 출력을 원하지 않으면 정규식 &lt;code&gt;/modules are up to date/&lt;/code&gt; 인지에 대한 위 명령의 출력을 구문 분석하고 출력이 일치하지 않는 경우에만 메일을 보내도록 결정하십시오.</target>
        </trans-unit>
        <trans-unit id="717adb67f10193acb40c16a22305c4dc8ba0e791" translate="yes" xml:space="preserve">
          <source>If you don't want to create a new hash, you can still use this looping technique; just change the &lt;code&gt;%new_hash&lt;/code&gt; to &lt;code&gt;%hash1&lt;/code&gt; .</source>
          <target state="translated">새로운 해시를 생성하지 않으려면이 루핑 기법을 계속 사용할 수 있습니다. &lt;code&gt;%new_hash&lt;/code&gt; 를 &lt;code&gt;%hash1&lt;/code&gt; 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="5861b9dcca59001a7ac94c68a3d243558acaf640" translate="yes" xml:space="preserve">
          <source>If you don't want to install the compiled Perl in AIX into /QOpenSys (for packaging it before copying it to PASE), you can use a Configure parameter: -Dinstallprefix=/tmp/QOpenSys/perl. This will cause the &quot;make install&quot; to install everything into that directory, while the installed files still think they are (will be) in /QOpenSys/perl.</source>
          <target state="translated">AIX에서 컴파일 된 Perl을 / QOpenSys에 설치하지 않으려면 (PASE로 복사하기 전에 패키징하기 위해) Configure 매개 변수 -Dinstallprefix = / tmp / QOpenSys / perl을 사용할 수 있습니다. 이렇게하면 &quot;make install&quot;이 해당 디렉토리에 모든 것을 설치하지만 설치된 파일은 여전히 ​​/ QOpenSys / perl에 있다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="ebe8a5460a3cd2a89a4ca3fccf1f4c546c9647e5" translate="yes" xml:space="preserve">
          <source>If you don't want to keep the defaults for the INSTALL* macros, MakeMaker helps you to minimize the typing needed: the usual relationship between INSTALLPRIVLIB and INSTALLARCHLIB is determined by Configure at perl compilation time. MakeMaker supports the user who sets INSTALLPRIVLIB. If INSTALLPRIVLIB is set, but INSTALLARCHLIB not, then MakeMaker defaults the latter to be the same subdirectory of INSTALLPRIVLIB as Configure decided for the counterparts in %Config, otherwise it defaults to INSTALLPRIVLIB. The same relationship holds for INSTALLSITELIB and INSTALLSITEARCH.</source>
          <target state="translated">INSTALL * 매크로의 기본값을 유지하지 않으려면 MakeMaker를 사용하여 필요한 입력을 최소화 할 수 있습니다. INSTALLPRIVLIB와 INSTALLARCHLIB의 일반적인 관계는 perl 컴파일시 구성에 의해 결정됩니다. MakeMaker는 INSTALLPRIVLIB를 설정하는 사용자를 지원합니다. INSTALLPRIVLIB가 설정되었지만 INSTALLARCHLIB가 설정되지 않은 경우 MakeMaker는 후자가 기본적으로 % Config의 상대방에 대해 Configure가 결정한 것과 동일한 INSTALLPRIVLIB의 서브 디렉토리가되도록 기본 설정합니다. 그렇지 않으면 기본값은 INSTALLPRIVLIB입니다. INSTALLSITELIB 및 INSTALLSITEARCH에 대해 동일한 관계가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="5f0e1c4bb41a9dbee49413981e4f4536890ac2a6" translate="yes" xml:space="preserve">
          <source>If you don't want to modify your source code, but still have on-the-fly warnings, do this:</source>
          <target state="translated">소스 코드를 수정하지 않고 여전히 경고가있는 경우 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="883af52a64cbec821f8f52f9cf06fce4facdd6ad" translate="yes" xml:space="preserve">
          <source>If you don't want to use the objects, you may import the &lt;code&gt;-&amp;gt;cando&lt;/code&gt; method into your namespace as a regular function called &lt;code&gt;stat_cando&lt;/code&gt; . This takes an arrayref containing the return values of &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; as its first argument, and interprets it for you.</source>
          <target state="translated">객체를 사용하지 않으려면 &lt;code&gt;-&amp;gt;cando&lt;/code&gt; 메소드를 &lt;code&gt;stat_cando&lt;/code&gt; 라는 일반 함수로 네임 스페이스에 가져올 수 있습니다 . 이것은 &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; 의 반환 값을 첫 번째 인수로 포함하는 arrayref를 가져 와서 해석합니다.</target>
        </trans-unit>
        <trans-unit id="8ca8817e625d3ffbecabec4b725646c93f6f8e36" translate="yes" xml:space="preserve">
          <source>If you don't wish to do this, set this variable to &lt;code&gt;false&lt;/code&gt; . Understand then that version comparisons are not possible, and Module::Load::Conditional can not tell you what module version you have installed. This may be desirable from a security or performance point of view. Note that &lt;code&gt;$FIND_VERSION&lt;/code&gt; code runs safely under &lt;code&gt;taint mode&lt;/code&gt; .</source>
          <target state="translated">이 작업을 원하지 않으면이 변수를 &lt;code&gt;false&lt;/code&gt; 로 설정하십시오 . 그러면 버전 비교가 불가능하다는 것을 이해하고 Module :: Load :: Conditional은 설치 한 모듈 버전을 알려줄 수 없습니다. 이것은 보안 또는 성능 관점에서 바람직 할 수 있습니다. 참고 &lt;code&gt;$FIND_VERSION&lt;/code&gt; 코드에서 안전하게 실행 &lt;code&gt;taint mode&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1341f2f78549b1827b1d11fb4b0cc0463ec09d6c" translate="yes" xml:space="preserve">
          <source>If you don't, you may experience strange build errors.</source>
          <target state="translated">그렇지 않으면 이상한 빌드 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dae8c74471266a8218d010f2ece1eeec7e339df7" translate="yes" xml:space="preserve">
          <source>If you edit</source>
          <target state="translated">편집하면</target>
        </trans-unit>
        <trans-unit id="2fb01cc36906ab2ae202731906c27291970214ff" translate="yes" xml:space="preserve">
          <source>If you either have Perl 5.8.0 or later installed, or if you have Scalar-List-Utils 1.03 or later installed, you can say:</source>
          <target state="translated">Perl 5.8.0 이상을 설치했거나 Scalar-List-Utils 1.03 이상을 설치 한 경우 다음과 같이 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b892a658ce0764f4b064036e5d8f58bd78f5e370" translate="yes" xml:space="preserve">
          <source>If you evaluate a hash in scalar context, it returns false if the hash is empty. If there are any key/value pairs, it returns true; more precisely, the value returned is a string consisting of the number of used buckets and the number of allocated buckets, separated by a slash. This is pretty much useful only to find out whether Perl's internal hashing algorithm is performing poorly on your data set. For example, you stick 10,000 things in a hash, but evaluating %HASH in scalar context reveals &lt;code&gt;&quot;1/16&quot;&lt;/code&gt; , which means only one out of sixteen buckets has been touched, and presumably contains all 10,000 of your items. This isn't supposed to happen. If a tied hash is evaluated in scalar context, the &lt;code&gt;SCALAR&lt;/code&gt; method is called (with a fallback to &lt;code&gt;FIRSTKEY&lt;/code&gt; ).</source>
          <target state="translated">스칼라 컨텍스트에서 해시를 평가하면 해시가 비어 있으면 false를 반환합니다. 키 / 값 쌍이 있으면 true를 반환합니다. 보다 정확하게 반환 된 값은 사용 된 버킷 수와 할당 된 버킷 수로 구성되는 문자열이며 슬래시로 구분됩니다. 이것은 Perl의 내부 해싱 알고리즘이 데이터 세트에서 제대로 수행되지 않는지 확인하는 데만 유용합니다. 예를 들어, 해시에 10,000 개의 항목을 집어 넣지 만 스칼라 컨텍스트에서 % HASH를 평가하면 &lt;code&gt;&quot;1/16&quot;&lt;/code&gt; 이 표시됩니다 . 이는 16 개의 버킷 중 하나만 건드리고 10,000 개의 항목을 모두 포함하고 있음을 의미합니다. 이것은 일어나지 않아야합니다. 스칼라 컨텍스트에서 연결된 해시가 평가되면 &lt;code&gt;SCALAR&lt;/code&gt; 메소드가 호출됩니다 ( &lt;code&gt;FIRSTKEY&lt;/code&gt; 로 대체 됨 ).</target>
        </trans-unit>
        <trans-unit id="8b7212a78497ddedc16438e486691b2144fe7186" translate="yes" xml:space="preserve">
          <source>If you evaluate an array in scalar context, it returns the length of the array. (Note that this is not true of lists, which return the last value, like the C comma operator, nor of built-in functions, which return whatever they feel like returning.) The following is always true:</source>
          <target state="translated">스칼라 컨텍스트에서 배열을 평가하면 배열의 길이가 반환됩니다. C 쉼표 연산자와 같이 마지막 값을 반환하는 목록이나 반환하려는 느낌을 반환하는 내장 함수는 목록에 해당되지 않습니다. 다음은 항상 사실입니다.</target>
        </trans-unit>
        <trans-unit id="ae75f4b9e5f451131a1e22cec2a555eb5370ed40" translate="yes" xml:space="preserve">
          <source>If you ever see a string that looks like this, you'll know you printed out a reference by mistake.</source>
          <target state="translated">이와 같은 문자열이 표시되면 실수로 참조를 인쇄 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="d2eae54bf1fbe9ae68c160098f500a78269b550c" translate="yes" xml:space="preserve">
          <source>If you execute the &lt;code&gt;T&lt;/code&gt; command from inside an active &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement, the backtrace will contain both a &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; frame and an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; frame.</source>
          <target state="translated">활성 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 문 에서 &lt;code&gt;T&lt;/code&gt; 명령 을 실행하면 역 추적에 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 프레임과 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 프레임이 모두 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="e5fd5107f38bc928d4af20adedacdcf1cb44e019" translate="yes" xml:space="preserve">
          <source>If you expect characters to get to your device when you &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; them, you'll want to autoflush that filehandle. You can use &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; and the &lt;code&gt;$|&lt;/code&gt; variable to control autoflushing (see</source>
          <target state="translated">문자를 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; 할 때 장치에 문자가 표시 될 것으로 예상되는 경우 해당 파일 핸들을 자동 플러시하고 싶을 것입니다. &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;$|&lt;/code&gt; 사용할 수 있습니다 자동 세척을 제어하는 ​​변수 (참조</target>
        </trans-unit>
        <trans-unit id="b65a4bc3927cbd6d7618d76eb545351eb5d8a945" translate="yes" xml:space="preserve">
          <source>If you expect to use both read and write operations on the device, you'll have to open it for update (see &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; for details). You may wish to open it without running the risk of blocking by using &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;O_RDWR|O_NDELAY|O_NOCTTY&lt;/code&gt; from the &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; module (part of the standard perl distribution). See &lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt; for more on this approach.</source>
          <target state="translated">장치에서 읽기 및 쓰기 작업을 모두 사용하려면 업데이트를 위해 장치를 열어야합니다 (자세한 내용은 &lt;a href=&quot;functions/open&quot;&gt;열기&lt;/a&gt; 참조). &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; 모듈 (표준 perl 배포의 일부 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;O_RDWR|O_NDELAY|O_NOCTTY&lt;/code&gt; 를 사용하여 차단 위험을 감수하지 않고 열 수 있습니다 . 이 방법에 대한 자세한 내용은 &lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="086943bc39b9078514791bccbde5ea2eddf63045" translate="yes" xml:space="preserve">
          <source>If you fail more than 254 tests, it will be reported as 254.</source>
          <target state="translated">254 개가 넘는 테스트에 실패하면 254로보고됩니다.</target>
        </trans-unit>
        <trans-unit id="cba05a1f1e542bc35030ada7de3e6bf8ced79b98" translate="yes" xml:space="preserve">
          <source>If you feel strongly about disabling it, set this variable to &lt;code&gt;false&lt;/code&gt; . Note that you will then need &lt;code&gt;IO::String&lt;/code&gt; installed to support writing stringified archives.</source>
          <target state="translated">비활성화 할 것을 강하게 느끼면이 변수를 &lt;code&gt;false&lt;/code&gt; 로 설정하십시오 . 그런 다음 &lt;code&gt;IO::String&lt;/code&gt; 화 된 아카이브 작성을 지원 하려면 IO :: String이 설치되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="0eb03812b9a06455d8a297e6d6e18c05b28becbc" translate="yes" xml:space="preserve">
          <source>If you feel strongly about disabling it, set this variable to &lt;code&gt;false&lt;/code&gt; . Note that you will then need &lt;code&gt;perlio&lt;/code&gt; support from your perl to be able to write stringified archives.</source>
          <target state="translated">비활성화 할 것을 강하게 느끼면이 변수를 &lt;code&gt;false&lt;/code&gt; 로 설정하십시오 . 그런 다음 &lt;code&gt;perlio&lt;/code&gt; 아카이브를 작성하려면 perl의 perlio 지원이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="8b50f7e3c982f4c5e423c530952e3d4ee9e5c5f1" translate="yes" xml:space="preserve">
          <source>If you feel the urge to write Perl modules, &lt;a href=&quot;perlnewmod&quot;&gt;perlnewmod&lt;/a&gt; will give you good advice.</source>
          <target state="translated">Perl 모듈을 작성하고 싶은 충동을 느끼면 &lt;a href=&quot;perlnewmod&quot;&gt;perlnewmod&lt;/a&gt; 가 좋은 조언을 제공 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="1ab4e553b43f57ec6c364e3642fd9276b76ed300" translate="yes" xml:space="preserve">
          <source>If you fill comfortable with</source>
          <target state="translated">당신이 편안하게 채우면</target>
        </trans-unit>
        <trans-unit id="d37bfff208b4893c857f8a0e5567752243d86aa9" translate="yes" xml:space="preserve">
          <source>If you find any bugs, &lt;code&gt;Devel::PPPort&lt;/code&gt; doesn't seem to build on your system, or any of its tests fail, please file an issue here: &lt;a href=&quot;https://github.com/mhx/Devel-PPPort/issues/&quot;&gt;https://github.com/mhx/Devel-PPPort/issues/&lt;/a&gt;</source>
          <target state="translated">버그가 발견되면 &lt;code&gt;Devel::PPPort&lt;/code&gt; 가 시스템에서 빌드되지 않거나 테스트에 실패한 경우 여기에 문제를 제기하십시오. &lt;a href=&quot;https://github.com/mhx/Devel-PPPort/issues/&quot;&gt;https://github.com/mhx/Devel-PPPort/issues/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b5ef4696f943b05c3aef9d5f207bfe62cada2927" translate="yes" xml:space="preserve">
          <source>If you find bugs in perl, you can run &lt;code&gt;perlbug&lt;/code&gt; to create a bug report (you may have to send it manually if &lt;code&gt;perlbug&lt;/code&gt; cannot find a mailer on your system).</source>
          <target state="translated">당신이 펄에서 버그를 발견하면, 당신은 실행할 수 있습니다 &lt;code&gt;perlbug&lt;/code&gt; 버그 리포트를 만들 수를 (당신이 경우 수동으로 전송 할 수 있습니다 &lt;code&gt;perlbug&lt;/code&gt; 이 시스템에 우편물을 찾을 수 없습니다).</target>
        </trans-unit>
        <trans-unit id="549be5a33ff1eaf5b330339ea140d5f50a8a508b" translate="yes" xml:space="preserve">
          <source>If you find bugs or if it does not work at all on your device, send mail to the address below. Please report the details of your device (processor, ceversion, devicetype (hpc/palm/pocket)) and the date of the downloaded files.</source>
          <target state="translated">버그가 있거나 장치에서 전혀 작동하지 않으면 아래 주소로 메일을 보내십시오. 장치의 세부 정보 (프로세서, ceversion, 장치 유형 (hpc / palm / pocket)) 및 다운로드 한 파일의 날짜를보고하십시오.</target>
        </trans-unit>
        <trans-unit id="ce181ab3a1836691a411c40b59cfd6c2a33af266" translate="yes" xml:space="preserve">
          <source>If you find instances of this in the Perl distribution itself, please let us know, so we can try to work around them.</source>
          <target state="translated">Perl 배포판에서이 인스턴스를 찾으면 알려 주시면 해결해 드리겠습니다.</target>
        </trans-unit>
        <trans-unit id="a35b038d2558b01a66b6ce215ee08874b540cf15" translate="yes" xml:space="preserve">
          <source>If you find that you do need to update the system Perl, one issue worth keeping in mind is the question of static vs. dynamic libraries. If you upgrade using the default static libperl, you will find that the dynamic libperl supplied by Apple will not be deleted. If both libraries are present when an application that links against libperl is built, ld will link against the dynamic library by default. So, if you need to replace Apple's dynamic libperl with a static libperl, you need to be sure to delete the older dynamic library after you've installed the update.</source>
          <target state="translated">시스템 Perl을 업데이트해야 할 경우 정적 라이브러리와 동적 라이브러리의 문제를 염두에 두어야합니다. 기본 정적 libperl을 사용하여 업그레이드하면 Apple에서 제공 한 동적 libperl이 삭제되지 않습니다. libperl과 링크되는 응용 프로그램이 빌드 될 때 두 라이브러리가 모두 존재하면 ld는 기본적으로 동적 라이브러리와 링크됩니다. 따라서 Apple의 동적 libperl을 정적 libperl로 교체해야하는 경우 업데이트를 설치 한 후 이전 동적 라이브러리를 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="8facfef28f917f827b51a8dc9cc5203934df7f46" translate="yes" xml:space="preserve">
          <source>If you find that you need to speed up a specific part of a Perl application (not something you often need) you may want to use C, but you can access this from your Perl code with &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;.</source>
          <target state="translated">Perl 애플리케이션의 특정 부분 (자주 필요한 것은 아님)의 속도를 높여야하는 경우 C를 사용할 수 있지만 &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; 를 사용하여 Perl 코드에서이 부분에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6d6f2d3762fd66cb49c45a26180601ab0ecbaf26" translate="yes" xml:space="preserve">
          <source>If you find the Calc module to slow, try to install any of the replacement modules and see if they help you.</source>
          <target state="translated">Calc 모듈이 느리게 작동하면 교체 모듈을 설치하고 도움이되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="9507dd44f0fdbd974fde8543eaceef56a9bf59da" translate="yes" xml:space="preserve">
          <source>If you find the implementation document unclear or not sufficient, look at the existing PerlIO layer implementations, which include:</source>
          <target state="translated">구현 문서가 명확하지 않거나 충분하지 않은 경우 다음을 포함하여 기존 PerlIO 계층 구현을 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="bb1a29c843961bd016421afc69613b486ab41b5a" translate="yes" xml:space="preserve">
          <source>If you find this module useful, please consider rating it on the CPAN Ratings service at &lt;a href=&quot;http://cpanratings.perl.org/rate?distribution=autodie&quot;&gt;http://cpanratings.perl.org/rate?distribution=autodie&lt;/a&gt; .</source>
          <target state="translated">이 모듈이 유용하다고 생각되면 CPAN 등급 서비스 ( &lt;a href=&quot;http://cpanratings.perl.org/rate?distribution=autodie&quot;&gt;http://cpanratings.perl.org/rate?distribution=autodie)&lt;/a&gt; 에서 등급을 고려 하십시오 .</target>
        </trans-unit>
        <trans-unit id="5afed98244534d5e7bd9f07d6f953a138ea4f8e9" translate="yes" xml:space="preserve">
          <source>If you find you need to provide custom functionality (as you would have using &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::Straps&quot;&gt;Test::Harness::Straps&lt;/a&gt;), you're in luck: &lt;code&gt;TAP::Parser&lt;/code&gt; and friends are designed to be easily plugged-into and/or subclassed.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::Straps&quot;&gt;Test :: Harness :: Straps를&lt;/a&gt; 사용하는 것처럼 사용자 정의 기능을 제공해야하는 경우 운이 좋을 것입니다 . &lt;code&gt;TAP::Parser&lt;/code&gt; 및 friends는 쉽게 플러그인 및 / 또는 서브 클래스되도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="7eaae25128643ba9a8e9cd9fd035b84dc1c8a6c4" translate="yes" xml:space="preserve">
          <source>If you find you really need to use your own iterator factory you can still do so without sub-classing &lt;code&gt;TAP::Parser&lt;/code&gt; by setting &lt;a href=&quot;#iterator_factory_class&quot;&gt;iterator_factory_class&lt;/a&gt;.</source>
          <target state="translated">당신이 찾아내는 경우에 당신은 정말 당신이 여전히 하위 클래스라는없이 그렇게 할 수 있습니다 자신의 반복자 공장을 사용할 필요가 &lt;code&gt;TAP::Parser&lt;/code&gt; 설정하여 &lt;a href=&quot;#iterator_factory_class&quot;&gt;iterator_factory_class을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ef253d4b5355af7bdf0e5249c9becef0fb63f08e" translate="yes" xml:space="preserve">
          <source>If you for some reason (such as binary backward compatibility) really need to use perl's malloc, you can rebuild perl from the sources and Configure the build with</source>
          <target state="translated">어떤 이유로 (이진 역 호환성과 같은) 실제로 perl의 malloc을 사용해야하는 경우 소스에서 perl을 다시 빌드하고 다음으로 빌드를 구성 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="a38ea3094c2349d48a8464c8b2ede590e7cc8393" translate="yes" xml:space="preserve">
          <source>If you forget &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; , high bytes will be misunderstood as separate characters, and nothing will work right.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 을 잊어 버린 경우 높은 바이트는 별도의 문자로 오해되며 아무것도 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c73cb5a6222b98080e0788ac4c8f896039ff111" translate="yes" xml:space="preserve">
          <source>If you forget to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; , you'll miss out entirely on the helpful diagnostic message:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 을 잊어 버린 경우 유용한 진단 메시지를 완전히 놓치게됩니다.</target>
        </trans-unit>
        <trans-unit id="4e4db242421a858aa14b9bcaa4e5f3862b8a23c5" translate="yes" xml:space="preserve">
          <source>If you get a core dump (or equivalent), you may use a debugger (&lt;b&gt;dbx&lt;/b&gt;, &lt;b&gt;gdb&lt;/b&gt;, etc) to produce a stack trace to include in the bug report.</source>
          <target state="translated">코어 덤프 (또는 이와 동등한)를 얻는 경우 디버거 ( &lt;b&gt;dbx&lt;/b&gt; , &lt;b&gt;gdb&lt;/b&gt; 등)를 사용하여 버그 보고서에 포함 할 스택 추적을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="722060cb13bfb62427a93bad15761822b6a7686d" translate="yes" xml:space="preserve">
          <source>If you get a message like &quot;perl: command not found&quot;, perl is not in your PATH, which might also mean that the location of perl is not where you expect it so you need to adjust your shebang line.</source>
          <target state="translated">&quot;perl : command not found&quot;와 같은 메시지가 표시되면 perl이 PATH에없는 것입니다. 이는 perl의 위치가 원하는 위치가 아니므로 shebang 라인을 조정해야합니다.</target>
        </trans-unit>
        <trans-unit id="6bc5836fc16b720e6dc1a4fbf9bbeb14813f0dae" translate="yes" xml:space="preserve">
          <source>If you get an error like</source>
          <target state="translated">다음과 같은 오류가 발생하면</target>
        </trans-unit>
        <trans-unit id="e71cc5ed2d43a688912302c22a7a0e3e08b5d7b1" translate="yes" xml:space="preserve">
          <source>If you get an error message</source>
          <target state="translated">오류 메시지가 나타나면</target>
        </trans-unit>
        <trans-unit id="8b6135f8eeab8f4ac6ffe0b88df52abad52ae3b4" translate="yes" xml:space="preserve">
          <source>If you get complaints about so_locations then search in the file hints/irix_6.sh for &quot;lddflags&quot; and do the suggested adjustments. (David Billinghurst &amp;lt;David.Billinghurst@riotinto.com.au&amp;gt;)</source>
          <target state="translated">so_locations에 대한 불만이 있으면 hints / irix_6.sh 파일에서 &quot;lddflags&quot;를 검색하고 제안 된 조정을 수행하십시오. (David Billinghurst &amp;lt;David.Billinghurst@riotinto.com.au&amp;gt;)</target>
        </trans-unit>
        <trans-unit id="0d74278837310505aa97f12b787c58f0bb90e74c" translate="yes" xml:space="preserve">
          <source>If you get lots of errors of the form</source>
          <target state="translated">양식에 많은 오류가 발생하면</target>
        </trans-unit>
        <trans-unit id="0e2cd49639ef6344568879d541e1a269a34ede3d" translate="yes" xml:space="preserve">
          <source>If you get the error</source>
          <target state="translated">오류가 발생하면</target>
        </trans-unit>
        <trans-unit id="91993b40c91822c3454671d4c8a24b32c3e646ba" translate="yes" xml:space="preserve">
          <source>If you get this message on SunOS or Solaris, and you're using gcc, it's probably the GNU as or GNU ld problem in the previous item &lt;a href=&quot;#GNU-as-and-GNU-ld&quot;&gt;GNU as and GNU ld&lt;/a&gt;.</source>
          <target state="translated">SunOS 또는 Solaris에서이 메시지가 표시되고 gcc를 사용중인 경우 이전 항목 &lt;a href=&quot;#GNU-as-and-GNU-ld&quot;&gt;GNU as 및 GNU ld&lt;/a&gt; 의 GNU as 또는 GNU ld 문제 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36f4dbd793640e550ca076d30024d627de795ab8" translate="yes" xml:space="preserve">
          <source>If you get tired of being subject to your platform's native integers, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint&lt;/code&gt; pragma neatly sidesteps the issue altogether:</source>
          <target state="translated">플랫폼의 고유 정수에 노출되는 데 지치면 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint&lt;/code&gt; pragma를 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하면 문제를 완전히 회피 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a28e8a38182dc716f4c7bb3a2e2a63a098694e97" translate="yes" xml:space="preserve">
          <source>If you get tired of constantly saying &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt; $lh-&amp;gt;maketext&lt;/code&gt; , consider making a functional wrapper for it, like so:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt; $lh-&amp;gt;maketext&lt;/code&gt; 라고 지속적으로 말하기에 지치면 다음과 같이 기능적 래퍼를 만드는 것을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="693c393f75e992e3003bea94747936126a6b0327" translate="yes" xml:space="preserve">
          <source>If you get tired of remembering which element of the return list contains which return value, by-name interfaces are provided in standard modules: &lt;code&gt;File::stat&lt;/code&gt; , &lt;code&gt;Net::hostent&lt;/code&gt; , &lt;code&gt;Net::netent&lt;/code&gt; , &lt;code&gt;Net::protoent&lt;/code&gt; , &lt;code&gt;Net::servent&lt;/code&gt; , &lt;code&gt;Time::gmtime&lt;/code&gt; , &lt;code&gt;Time::localtime&lt;/code&gt; , and &lt;code&gt;User::grent&lt;/code&gt; . These override the normal built-ins, supplying versions that return objects with the appropriate names for each field. For example:</source>
          <target state="translated">리턴리스트의 어떤 요소가 어떤 리턴 값을 포함하는지 기억하는 데 지치면 표준 모듈에 이름 별 인터페이스가 제공됩니다. &lt;code&gt;File::stat&lt;/code&gt; , &lt;code&gt;Net::hostent&lt;/code&gt; , &lt;code&gt;Net::netent&lt;/code&gt; , &lt;code&gt;Net::protoent&lt;/code&gt; , &lt;code&gt;Net::servent&lt;/code&gt; , &lt;code&gt;Time::gmtime&lt;/code&gt; , &lt;code&gt;Time::localtime&lt;/code&gt; 및 &lt;code&gt;User::grent&lt;/code&gt; 입니다. 이들은 기본 제공되는 기본 제공을 대체하여 각 필드에 적절한 이름을 가진 오브젝트를 리턴하는 버전을 제공합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b8e0fc194ad5e5c2cd16a3f242684fe425f3428b" translate="yes" xml:space="preserve">
          <source>If you get used to writing odd things like these:</source>
          <target state="translated">다음과 같이 이상한 것을 쓰는 데 익숙하다면 :</target>
        </trans-unit>
        <trans-unit id="0cd15dd92a142244892a9be7434b98670ff15dc6" translate="yes" xml:space="preserve">
          <source>If you had &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %Foo::Bar::QUUX&lt;/code&gt; to check whether such a package variable exists then that's never really been reliable, and isn't a good way to enquire about the features of a package, or whether it's loaded, etc.</source>
          <target state="translated">그러한 패키지 변수가 존재하는지 여부를 확인하기 위해 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %Foo::Bar::QUUX&lt;/code&gt; 를 &lt;a href=&quot;functions/defined&quot;&gt;정의한&lt;/a&gt; 경우 실제로는 신뢰할 수 없으며 패키지의 기능 또는로드 여부 등을 문의하는 좋은 방법이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="4ef8417488b5df9f33f3d1b38e3847657756981c" translate="yes" xml:space="preserve">
          <source>If you had to get a variable through, you could do this:</source>
          <target state="translated">변수를 가져와야한다면 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="67b4946ef744afdd9a1b21f685b5b8e140afa4b4" translate="yes" xml:space="preserve">
          <source>If you have</source>
          <target state="translated">당신이 가지고 있다면</target>
        </trans-unit>
        <trans-unit id="8ebbe151437cc5de6b126287c5035e996e85c741" translate="yes" xml:space="preserve">
          <source>If you have &lt;a href=&quot;http://search.cpan.org/perldoc/File::Stream&quot;&gt;File::Stream&lt;/a&gt;, this is easy.</source>
          <target state="translated">당신이있는 경우 &lt;a href=&quot;http://search.cpan.org/perldoc/File::Stream&quot;&gt;파일 :: 스트림&lt;/a&gt; 이 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="8477c0614e083a37a8e560c57638a0b5f36ef52b" translate="yes" xml:space="preserve">
          <source>If you have &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module installed from CPAN, you can use it to fetch the width and height in characters and in pixels:</source>
          <target state="translated">당신이있는 경우 &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;기간 :: ReadKey&lt;/a&gt; CPAN에서 설치 모듈을, 당신은 문자와 폭과 높이를 픽셀 단위로 가져 오는 데 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="240e14e2dd47b4fb473147b6d297b2d7726b59cc" translate="yes" xml:space="preserve">
          <source>If you have &lt;code&gt;IPC::Run&lt;/code&gt; installed, and the variable &lt;code&gt;$IPC::Cmd::USE_IPC_RUN&lt;/code&gt; is set to true (See the &lt;a href=&quot;#Global-Variables&quot;&gt;Global Variables&lt;/a&gt; section) use that to execute the command. You will have the full output available in buffers, interactive commands are sure to work and you are guaranteed to have your verbosity settings honored cleanly.</source>
          <target state="translated">당신이있는 경우 &lt;code&gt;IPC::Run&lt;/code&gt; 설치, 변수 &lt;code&gt;$IPC::Cmd::USE_IPC_RUN&lt;/code&gt; 합니다 (참조 true로 설정되어있는 &lt;a href=&quot;#Global-Variables&quot;&gt;글로벌 변수&lt;/a&gt; 명령을 실행하는 것을 사용 절). 버퍼에서 전체 출력을 사용할 수 있으며 대화식 명령이 작동하며 자세한 설정을 깨끗하게 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8acd2601ad065393113859c8a7e3855297ce5ac" translate="yes" xml:space="preserve">
          <source>If you have &lt;code&gt;man&lt;/code&gt; installed on your system, and you installed perl manpages, use something like this:</source>
          <target state="translated">당신이있는 경우 &lt;code&gt;man&lt;/code&gt; 시스템에 설치되어, 당신은 펄 맨이 같이 사용 무언가를 설치 :</target>
        </trans-unit>
        <trans-unit id="d6036be6bd4d2a23f70dfe8c9f989a5911198ccc" translate="yes" xml:space="preserve">
          <source>If you have Perl 5.10 or later, and you just want to store a value against the reference for lookup later, you can use the core Hash::Util::Fieldhash module. This will also handle renaming the keys if you use multiple threads (which causes all variables to be reallocated at new addresses, changing their stringification), and garbage-collecting the entries when the referenced variable goes out of scope.</source>
          <target state="translated">Perl 5.10 이상이 있고 나중에 조회를 위해 참조에 대한 값을 저장하려는 경우 핵심 Hash :: Util :: Fieldhash 모듈을 사용할 수 있습니다. 또한 여러 스레드를 사용하는 경우 (모든 주소가 새 주소에 재 할당되고 문자열이 변경됨) 참조 된 변수가 범위를 벗어날 때 항목을 가비지 수집하는 경우 키 이름 바꾸기를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="1ff5e330b4023d9ffe19df36972bfcc73814fd9b" translate="yes" xml:space="preserve">
          <source>If you have Perl 5.10 or later, this is almost trivial. You just smart match against an array of regular expression objects:</source>
          <target state="translated">Perl 5.10 이상이 있으면 거의 사소합니다. 당신은 정규 표현식 객체의 배열과 똑똑하게 일치합니다.</target>
        </trans-unit>
        <trans-unit id="2fe696e9056ea562cb89c9b2f102390c60db24f0" translate="yes" xml:space="preserve">
          <source>If you have Perl v5.16, the problems mentioned above go away if you use the &lt;code&gt;:not_characters&lt;/code&gt; parameter to the locale pragma (except for vendor bugs in the non-character portions). If you don't have v5.16, and you</source>
          <target state="translated">Perl v5.16을 사용하는 경우 &lt;code&gt;:not_characters&lt;/code&gt; 매개 변수를 로케일 pragma에 사용하면 위에서 언급 한 문제점이 사라집니다 (문자 이외의 부분에서 벤더 버그 제외). v5.16이없고</target>
        </trans-unit>
        <trans-unit id="6642f62c4bfdebf5e62452d5d72c26f1bd89b8ec" translate="yes" xml:space="preserve">
          <source>If you have YAML.pm (or some other YAML module configured in &lt;code&gt;yaml_module&lt;/code&gt; ) installed, CPAN.pm collects a few statistical data about recent downloads. You can view the statistics with the &lt;code&gt;hosts&lt;/code&gt; command or inspect them directly by looking into the &lt;code&gt;FTPstats.yml&lt;/code&gt; file in your &lt;code&gt;cpan_home&lt;/code&gt; directory.</source>
          <target state="translated">당신이 YAML.pm (또는 구성 다른 YAML 모듈이있는 경우 &lt;code&gt;yaml_module&lt;/code&gt; ) 설치, CPAN.pm 최근 다운로드에 대한 몇 가지 통계 데이터를 수집합니다. &lt;code&gt;hosts&lt;/code&gt; 명령으로 통계를 보거나 &lt;code&gt;cpan_home&lt;/code&gt; 디렉토리 의 &lt;code&gt;FTPstats.yml&lt;/code&gt; 파일을 찾아서 직접 검사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="225c354ad980b0b7bb691380c5b2f0d3c2643a5a" translate="yes" xml:space="preserve">
          <source>If you have a ReadLine module installed, you can hit TAB at any point of the commandline and &lt;code&gt;o conf&lt;/code&gt; will offer you completion for the built-in subcommands and/or config variable names.</source>
          <target state="translated">당신이의 readline 모듈이 설치되어있는 경우, 당신은 명령 줄의 어느 지점에서 TAB을 칠 수와 &lt;code&gt;o conf&lt;/code&gt; 당신에 대한 완료를 제공 할 것입니다 내장 하위 명령 및 / 또는 설정 변수의 이름.</target>
        </trans-unit>
        <trans-unit id="86d2e902132f610059a158729cf105aa2e1d4e91" translate="yes" xml:space="preserve">
          <source>If you have a buffer allocated with Newx() and want to set that as the SV's value, you can use sv_usepvn_flags(). That has some requirements if you want to avoid perl re-allocating the buffer to fit the trailing NUL:</source>
          <target state="translated">Newx ()로 할당 된 버퍼가 있고이를 SV 값으로 설정하려면 sv_usepvn_flags ()를 사용할 수 있습니다. 펄이 후행 NUL에 맞게 버퍼를 다시 할당하는 것을 피하려면 몇 가지 요구 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="28b93e0d6dcdb9743374e046e2c50f7ec24b530d" translate="yes" xml:space="preserve">
          <source>If you have a burning desire to tell the world about your release, post an announcement to the moderated &lt;code&gt;comp.lang.perl.announce&lt;/code&gt; newsgroup.</source>
          <target state="translated">발표에 대해 전 세계에 알리고 싶은 마음이 있다면 중재 된 &lt;code&gt;comp.lang.perl.announce&lt;/code&gt; 뉴스 그룹에 공지 사항을 게시하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ed22a427a030ed732816620f86f5c52ec466566" translate="yes" xml:space="preserve">
          <source>If you have a command-line program that does the job, you can call it in backticks to capture whatever it outputs so you can use it later:</source>
          <target state="translated">작업을 수행하는 명령 줄 프로그램이있는 경우 출력을 캡처하기 위해 백틱으로 호출하여 나중에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aabc7446c5d3e0c2ebc9233bf601a7899d673f9d" translate="yes" xml:space="preserve">
          <source>If you have a commit bit, please see &lt;a href=&quot;perlgit&quot;&gt;perlgit&lt;/a&gt; for more details on using git.</source>
          <target state="translated">커밋 비트가있는 경우 git 사용에 대한 자세한 내용 은 &lt;a href=&quot;perlgit&quot;&gt;perlgit&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="392daf22cd236f28ba9ceee336856176b759059d" translate="yes" xml:space="preserve">
          <source>If you have a complicated function needed to pull out the part you want to sort on, then don't do it inside the sort function. Pull it out first, because the sort BLOCK can be called many times for the same element. Here's an example of how to pull out the first word after the first number on each item, and then sort those words case-insensitively.</source>
          <target state="translated">정렬하려는 부분을 꺼내기 위해 복잡한 기능이 필요한 경우 정렬 기능 내에서 수행하지 마십시오. 동일한 요소에 대해 정렬 BLOCK을 여러 번 호출 할 수 있으므로 먼저 빼냅니다. 다음은 각 항목에서 첫 번째 숫자 다음에 첫 번째 단어를 가져온 다음 대소 문자를 구분하지 않고 정렬하는 방법에 대한 예입니다.</target>
        </trans-unit>
        <trans-unit id="b0e6b3bda8c96c33f56e6b729af6c8286cbfdc17" translate="yes" xml:space="preserve">
          <source>If you have a legacy encoding, you can use the &lt;code&gt;:encoding(...)&lt;/code&gt; tag.</source>
          <target state="translated">레거시 인코딩이있는 경우 &lt;code&gt;:encoding(...)&lt;/code&gt; 태그를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="01656c2b4f7ea5f69bae8d5caaac9ea48410bb3e" translate="yes" xml:space="preserve">
          <source>If you have a library that provides an API, you can make any component of it available as just another Perl function or variable using a Perl extension written in C or C++ and dynamically linked into your main perl interpreter. You can also go the other direction, and write your main program in C or C++, and then link in some Perl code on the fly, to create a powerful application. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">API를 제공하는 라이브러리가있는 경우 C 또는 C ++로 작성되고 기본 Perl 인터프리터에 동적으로 링크 된 Perl 확장을 사용하여 해당 컴포넌트의 컴포넌트를 다른 Perl 함수 또는 변수로 사용할 수 있습니다. 다른 방향으로 가고 C 또는 C ++로 기본 프로그램을 작성한 다음 즉시 Perl 코드로 링크하여 강력한 응용 프로그램을 만들 수 있습니다. &lt;a href=&quot;perlembed&quot;&gt;perlembed를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="51f9e3f6122598346b767c490154d73f3d45b4f6" translate="yes" xml:space="preserve">
          <source>If you have a list of tests (or URLs, or anything else you want to test) in a file, you can add them to your tests by using a '-':</source>
          <target state="translated">파일에 테스트 목록 (또는 URL 또는 테스트하려는 다른 것)이있는 경우 '-'를 사용하여 테스트에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1add680b7e930dc8542127166a2c6922328bade" translate="yes" xml:space="preserve">
          <source>If you have a local mirror of CPAN and can access all files with &quot;file:&quot; URLs, then you only need a perl later than perl5.003 to run this module. Otherwise Net::FTP is strongly recommended. LWP may be required for non-UNIX systems, or if your nearest CPAN site is associated with a URL that is not &lt;code&gt;ftp:&lt;/code&gt; .</source>
          <target state="translated">CPAN의 로컬 미러가 있고 &quot;file :&quot;URL을 사용하여 모든 파일에 액세스 할 수있는 경우이 모듈을 실행하려면 perl5.003 이후의 perl 만 있으면됩니다. 그렇지 않으면 Net :: FTP를 적극 권장합니다. UNIX 이외의 시스템 또는 가장 가까운 CPAN 사이트가 &lt;code&gt;ftp:&lt;/code&gt; 가 아닌 URL과 연관된 경우 LWP가 필요할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3c6b091f1c2f3916b6f982ec5d76127aba417742" translate="yes" xml:space="preserve">
          <source>If you have a question you'd like to see added to the FAQ (whether or not you have the answer) please send it to makemaker@perl.org.</source>
          <target state="translated">궁금한 사항이 있으시면 FAQ에 추가하고 싶을 경우 (답이 있는지 없는지) makemaker@perl.org로 보내주십시오.</target>
        </trans-unit>
        <trans-unit id="883ef441e28a9d839f80a61f11348168ebf17cd9" translate="yes" xml:space="preserve">
          <source>If you have a raw sequence of bytes that you know should be interpreted via a particular encoding, you can use &lt;code&gt;Encode&lt;/code&gt; :</source>
          <target state="translated">특정 인코딩을 통해 해석해야하는 원시 바이트 시퀀스가있는 경우 &lt;code&gt;Encode&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4977b6a1b7796edc98abe66364bdbf5af8c6caa8" translate="yes" xml:space="preserve">
          <source>If you have a really hairy regular expression, use the &lt;code&gt;/x&lt;/code&gt; modifier and put in some whitespace to make it look a little less like line noise. Don't use slash as a delimiter when your regexp has slashes or backslashes.</source>
          <target state="translated">정말 털이 많은 정규 표현식이있는 경우 &lt;code&gt;/x&lt;/code&gt; 수정자를 사용하고 공백을 넣어 줄 노이즈와 비슷하게 만듭니다. 정규 표현식에 슬래시 또는 백 슬래시가 있으면 슬래시를 구분 기호로 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="c4670adaa2657eda2badbded5180916956105a77" translate="yes" xml:space="preserve">
          <source>If you have a sequence of bytes you &lt;b&gt;know&lt;/b&gt; is valid UTF-8, but Perl doesn't know it yet, you can make Perl a believer, too:</source>
          <target state="translated">&lt;b&gt;알고&lt;/b&gt; 있는 바이트 시퀀스 가 유효한 UTF-8이지만 Perl이 아직 알지 못하는 경우 Perl도 신자로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9756e7acda84539ead2e5f85f560f283b75aed93" translate="yes" xml:space="preserve">
          <source>If you have a single string that you want to check for &quot;equality in locale&quot; against several others, you might think you could gain a little efficiency by using &lt;code&gt;POSIX::strxfrm()&lt;/code&gt; in conjunction with &lt;code&gt;eq&lt;/code&gt; :</source>
          <target state="translated">여러 문자열에 대해 &quot;equal in locale&quot;을 확인하려는 단일 문자열이있는 경우 &lt;code&gt;eq&lt;/code&gt; 와 함께 &lt;code&gt;POSIX::strxfrm()&lt;/code&gt; 을 사용하면 약간의 효율성을 얻을 수 있다고 생각할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f645dc4bb8034c3799b831d6996356797ca7be48" translate="yes" xml:space="preserve">
          <source>If you have a small patch to submit, please submit it via perlbug. You can also send email directly to perlbug@perl.org. Please note that messages sent to perlbug may be held in a moderation queue, so you won't receive a response immediately.</source>
          <target state="translated">제출할 작은 패치가있는 경우 perlbug를 통해 제출하십시오. perlbug@perl.org로 직접 이메일을 보낼 수도 있습니다. perlbug로 전송 된 메시지는 중재 대기열에 보관 될 수 있으므로 즉시 응답을받지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42845d8c8c875f89de9dd2d1b7586e0d3ad16bc8" translate="yes" xml:space="preserve">
          <source>If you have a specific romanization scheme in mind, use the specific module:</source>
          <target state="translated">특정 로마자 표기법을 염두에두고 있으면 특정 모듈을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fb355db0f3f4b40524a1c3ff445d923be623d546" translate="yes" xml:space="preserve">
          <source>If you have a working &lt;code&gt;DynaLoader&lt;/code&gt; then there is rarely any need to statically link in any other extensions.</source>
          <target state="translated">작동하는 &lt;code&gt;DynaLoader&lt;/code&gt; 가있는 경우 다른 확장에서 정적으로 링크 할 필요가 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="fd5f81af8a4a7363d6132316fb90657fc9d4e232" translate="yes" xml:space="preserve">
          <source>If you have a zip file that contains multiple members and want to read a specific member from the file, say &lt;code&gt;&quot;data1&quot;&lt;/code&gt; , use the &lt;code&gt;Name&lt;/code&gt; option</source>
          <target state="translated">여러 멤버를 포함하는 zip 파일이 있고 파일에서 특정 멤버를 읽으려면 &lt;code&gt;&quot;data1&quot;&lt;/code&gt; 과 같이 &lt;code&gt;Name&lt;/code&gt; 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e8e60773a7086adcadd9997f1e4e60bf13f42c27" translate="yes" xml:space="preserve">
          <source>If you have an FTP proxy firewall (&lt;b&gt;NOT&lt;/b&gt; an HTTP or SOCKS firewall) then this value should be set to the firewall hostname. If your firewall does not listen to port 21, then this value should be set to &lt;code&gt;&quot;hostname:port&quot;&lt;/code&gt; (eg &lt;code&gt;&quot;hostname:99&quot;&lt;/code&gt; )</source>
          <target state="translated">당신은 FTP 프록시 방화벽 (있는 경우 &lt;b&gt;NOT&lt;/b&gt; HTTP 또는 SOCKS 방화벽)이 값은 방화벽 호스트 이름으로 설정해야합니다. 방화벽이 포트 21을 수신하지 않으면이 값을 &lt;code&gt;&quot;hostname:port&quot;&lt;/code&gt; 로 설정해야합니다 (예 : &lt;code&gt;&quot;hostname:99&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="3a37d9c6262b12c7aa2b49bfbcebb4a375757d2e" translate="yes" xml:space="preserve">
          <source>If you have an SV and want to know what kind of data Perl thinks is stored in it, you can use the following macros to check the type of SV you have.</source>
          <target state="translated">SV가 있고 Perl에 어떤 종류의 데이터가 저장되어 있다고 생각되는지 알고 싶다면 다음 매크로를 사용하여 SV 유형을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bc4f67186bf30ca57f017f1cea8612b943dd146" translate="yes" xml:space="preserve">
          <source>If you have an array of &lt;code&gt;@string&lt;/code&gt; that should be concatenated and then normalized, you can do like this:</source>
          <target state="translated">연결하고 정규화 해야하는 &lt;code&gt;@string&lt;/code&gt; 배열이 있으면 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="403ab04dd713d2cfe6f16d5487fb0193f691f18c" translate="yes" xml:space="preserve">
          <source>If you have an empty directory, you can use Perl's built-in &lt;code&gt;&lt;a href=&quot;functions/rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt;. If the directory is not empty (so, no files or subdirectories), you either have to empty it yourself (a lot of work) or use a module to help you.</source>
          <target state="translated">빈 디렉토리가 있으면 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; 을 사용할 수 있습니다 . 디렉토리가 비어 있지 않은 경우 (파일 또는 하위 디렉토리가없는 경우) 직접 비우거나 (많은 작업) 모듈을 사용하여 도움을 받아야합니다.</target>
        </trans-unit>
        <trans-unit id="6898ea8c69aa4a0ff2b81092a3457a58f7bdc010" translate="yes" xml:space="preserve">
          <source>If you have an existing inside-out class, simply making all hashes field hashes with no other change should make no difference. Through the calls to &lt;code&gt;refaddr&lt;/code&gt; or equivalent, the field hashes never get to see a reference and work like normal hashes. Your DESTROY (and CLONE) methods are still needed.</source>
          <target state="translated">기존 인사이드 아웃 클래스가있는 경우 다른 변경없이 모든 해시 필드 해시를 만들면 아무런 차이가 없습니다. &lt;code&gt;refaddr&lt;/code&gt; 또는 동등한 항목에 대한 호출을 통해 필드 해시는 절대 참조를 보지 않고 일반 해시처럼 작동합니다. DESTROY (및 CLONE) 방법이 여전히 필요합니다.</target>
        </trans-unit>
        <trans-unit id="03fcf475306c60d974596613b76c03a9f344e66a" translate="yes" xml:space="preserve">
          <source>If you have an older version of Perl, the &lt;code&gt;$^W&lt;/code&gt; variable (documented in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;) controls runtime warnings for a block:</source>
          <target state="translated">이전 버전의 Perl이있는 경우 &lt;code&gt;$^W&lt;/code&gt; 변수 ( &lt;a href=&quot;perlvar&quot;&gt;perlvar에&lt;/a&gt; 문서화 됨 )는 블록에 대한 런타임 경고를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="55ec04844d40449455953b5a185c6050647bf370" translate="yes" xml:space="preserve">
          <source>If you have any other characters you need to escape, please install the &lt;code&gt;URI::Escape&lt;/code&gt; module from CPAN, and pre-encode your URI before passing it to &lt;code&gt;File::Fetch&lt;/code&gt; . You can read about the details of URIs and URI encoding here:</source>
          <target state="translated">이스케이프해야 할 다른 문자가 있으면 CPAN에서 &lt;code&gt;URI::Escape&lt;/code&gt; 모듈을 설치하고 URI 를 &lt;code&gt;File::Fetch&lt;/code&gt; 전달하기 전에 미리 인코딩하십시오 . URI 및 URI 인코딩에 대한 자세한 내용은 여기를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="59ef038a12de814aa0cdf806e88e5a326fdaf2d5" translate="yes" xml:space="preserve">
          <source>If you have any suggested changes for this page, let me know. Please don't send me mail asking for help on how to install your modules. There are too many modules, and too few Orwants, for me to be able to answer or even acknowledge all your questions. Contact the module author instead, or post to comp.lang.perl.modules, or ask someone familiar with Perl on your operating system.</source>
          <target state="translated">이 페이지에 대한 제안 된 변경 사항이 있으면 알려주십시오. 모듈 설치 방법에 대한 도움을 요청하는 메일을 보내지 마십시오. 모든 질문에 대답하거나 인정할 수있는 너무 많은 모듈과 너무 적은 Orwants가 있습니다. 대신 모듈 작성자에게 문의하거나 comp.lang.perl.modules에 게시하거나 운영 체제에서 Perl에 익숙한 사람에게 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="e2545920681caa56966e901dca47f4688bdb95ac" translate="yes" xml:space="preserve">
          <source>If you have built this module with zlib &amp;gt;= 1.2.0, the &lt;code&gt;$eof&lt;/code&gt; parameter is ignored. You can still set it if you want, but it won't be used behind the scenes.</source>
          <target state="translated">zlib&amp;gt; = 1.2.0으로이 모듈을 빌드 한 경우 &lt;code&gt;$eof&lt;/code&gt; 매개 변수는 무시됩니다. 원하는 경우 계속 설정할 수 있지만 장면 뒤에서는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bd7c754383786ab750ba8d8b8b5b2710b62cfc9e" translate="yes" xml:space="preserve">
          <source>If you have built this module with zlib 1.2.3 or better, two more CRC-related functions are available.</source>
          <target state="translated">zlib 1.2.3 이상으로이 모듈을 빌드 한 경우 두 개의 CRC 관련 기능을 더 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b49d178439aabd6902535000d809a8c4d8c6c0d0" translate="yes" xml:space="preserve">
          <source>If you have compile-time executable statements (such as code within BEGIN, UNITCHECK and CHECK blocks or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statements), these will</source>
          <target state="translated">컴파일 타임 실행 문이있는 경우 (예 : BEGIN, UNITCHECK 및 CHECK 블록 내의 코드 또는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 명령문)</target>
        </trans-unit>
        <trans-unit id="4a053828197d3de496e658e2f64e31f462c0e7ce" translate="yes" xml:space="preserve">
          <source>If you have experience with other thread implementations, you might find that things aren't quite what you expect. It's very important to remember when dealing with Perl threads that</source>
          <target state="translated">다른 스레드 구현 경험이 있다면 예상 한 것과 다른 것이 발견 될 수 있습니다. Perl 스레드를 다룰 때 기억하는 것이 매우 중요합니다.</target>
        </trans-unit>
        <trans-unit id="0ffa35b58c4462159f2ea02872365ed984d54889" translate="yes" xml:space="preserve">
          <source>If you have found a bug with a non-standard port (one that was not part of the</source>
          <target state="translated">비표준 포트에 버그가 발견 된 경우</target>
        </trans-unit>
        <trans-unit id="0e1af930aa8bf951949bff6fef33b900fd538735" translate="yes" xml:space="preserve">
          <source>If you have generated such a statically-linked executable by choice, then instead of saying &quot;&lt;code&gt;make test&lt;/code&gt; &quot;, you should say &quot;&lt;code&gt;make test_static&lt;/code&gt; &quot;. On systems that cannot build dynamically-loadable libraries at all, simply saying &quot;&lt;code&gt;make test&lt;/code&gt; &quot; is sufficient.</source>
          <target state="translated">&lt;code&gt;make test_static&lt;/code&gt; 으로 이러한 정적으로 링크 된 실행 파일을 생성 한 경우 &quot; &lt;code&gt;make test&lt;/code&gt; &quot; 라고 말하지 않고 &quot; make test_static &quot; 이라고 말해야 합니다. 동적으로로드 가능한 라이브러리를 전혀 구축 할 수없는 시스템에서는 단순히 &quot; &lt;code&gt;make test&lt;/code&gt; &quot; 라고 말하는 것으로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="ea57a23a75f969a9e5ed037d598a374a300583a4" translate="yes" xml:space="preserve">
          <source>If you have gotten this far into the tutorial, you can probably guess what the different parts of the debugging output tell you. The first part</source>
          <target state="translated">이 과정을 통해 튜토리얼을 살펴 보았다면 디버깅 출력의 다른 부분이 무엇을 말해 줄지 추측 할 수 있습니다. 첫 번째 부분</target>
        </trans-unit>
        <trans-unit id="9d264a66a026ef716495bcfe67d5b82c2fd75d79" translate="yes" xml:space="preserve">
          <source>If you have installed a signal handler for &lt;code&gt;SIGCHLD&lt;/code&gt; , the value of &lt;code&gt;$?&lt;/code&gt; will usually be wrong outside that handler.</source>
          <target state="translated">당신을위한 신호 처리기를 설치 한 경우 &lt;code&gt;SIGCHLD&lt;/code&gt; 의 가치 &lt;code&gt;$?&lt;/code&gt; 일반적으로 해당 핸들러 외부에서 잘못됩니다.</target>
        </trans-unit>
        <trans-unit id="d59e8efecc586326d2ab32c89e976a471be555e8" translate="yes" xml:space="preserve">
          <source>If you have installed extra libraries such as GDBM through Fink (in other words, you have libraries under</source>
          <target state="translated">Fink를 통해 GDBM과 같은 추가 라이브러리를 설치 한 경우 (즉,</target>
        </trans-unit>
        <trans-unit id="adf0535478f796f8c19ba9c98c90186d9fd4978f" translate="yes" xml:space="preserve">
          <source>If you have more than two files, this is the place where you should boot extra XS files from.</source>
          <target state="translated">파일이 두 개 이상인 경우 여분의 XS 파일을 부팅해야합니다.</target>
        </trans-unit>
        <trans-unit id="47f402ce95a3894708d131d4f57afb65a8408c3a" translate="yes" xml:space="preserve">
          <source>If you have neither Net::FTP nor LWP, there is a fallback mechanism implemented for an external ftp command or for an external lynx command.</source>
          <target state="translated">Net :: FTP 또는 LWP가없는 경우 외부 ftp 명령 또는 외부 lynx 명령에 대해 대체 메커니즘이 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="24c715fba81da2278914f96579f9af2c125fe732" translate="yes" xml:space="preserve">
          <source>If you have never been to a hackathon, here are a few basic things you need to know before attending: have a working laptop and know how to use it; check out the involved projects beforehand; have the necessary version control client; and bring backup equipment (an extra LAN cable, additional power strips, etc.) because someone will forget.</source>
          <target state="translated">해커 톤에 가본 적이 없다면, 참석하기 전에 알아야 할 몇 가지 기본 사항은 다음과 같습니다. 랩탑이 작동하고 사용 방법을 알고 있어야합니다. 관련 프로젝트를 미리 확인하십시오. 필요한 버전 관리 클라이언트가 있어야합니다. 다른 사람이 잊어 버릴 수 있으므로 백업 장비 (추가 LAN 케이블, 추가 전원 스트립 등)를 준비하십시오.</target>
        </trans-unit>
        <trans-unit id="1eb2a3bd6bb2269e089bc5caced075f60ca01d0a" translate="yes" xml:space="preserve">
          <source>If you have never defined your own &lt;code&gt;urllist&lt;/code&gt; in your configuration then &lt;code&gt;CPAN.pm&lt;/code&gt; will be hesitant to use the built in default sites for downloading. It will ask you once per session if a connection to the internet is OK and only if you say yes, it will try to connect. But to avoid this question, you can choose your favorite download sites once and get away with it. Or, if you have no favorite download sites answer yes to the following question.</source>
          <target state="translated">구성에서 고유 한 &lt;code&gt;urllist&lt;/code&gt; 를 정의하지 않은 경우 &lt;code&gt;CPAN.pm&lt;/code&gt; 은 기본 제공 기본 사이트를 사용하여 다운로드하는 것을 주저합니다. 인터넷 연결이 정상인지 세션 당 한 번 묻고 예라고 대답하는 경우에만 연결을 시도합니다. 그러나이 질문을 피하기 위해 즐겨 찾는 다운로드 사이트를 한 번 선택하여 벗어날 수 있습니다. 또는 즐겨 찾는 다운로드 사이트가없는 경우 다음 질문에 예라고 대답하십시오.</target>
        </trans-unit>
        <trans-unit id="7a84d97dce110800ef0a7f4d11d992d7a0415274" translate="yes" xml:space="preserve">
          <source>If you have never uploaded a module to CPAN before (and even if you have), you are strongly encouraged to get feedback on &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fprepan.org&quot;&gt;PrePAN&lt;/a&gt;. PrePAN is a site dedicated to discussing ideas for CPAN modules with other Perl developers and is a great resource for new (and experienced) Perl developers.</source>
          <target state="translated">CPAN에 모듈을 업로드 한 적이없는 경우 (있는 경우에도), &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fprepan.org&quot;&gt;PrePAN&lt;/a&gt; 에 대한 피드백을받는 것이 좋습니다 . PrePAN은 다른 Perl 개발자와 CPAN 모듈에 대한 아이디어를 논의하기위한 사이트이며 새로운 Perl 개발자를위한 훌륭한 리소스입니다.</target>
        </trans-unit>
        <trans-unit id="eb6ae544b0243a12b93b26e3f0b3956b5515717f" translate="yes" xml:space="preserve">
          <source>If you have one of the readline packages (Term::ReadLine::Perl, Term::ReadLine::Gnu, possibly others) installed, the interactive CPAN shell will have history support. The next two questions deal with the filename of the history file and with its size. If you do not want to set this variable, please hit SPACE ENTER to the following question.</source>
          <target state="translated">readline 패키지 중 하나 (Term :: ReadLine :: Perl, Term :: ReadLine :: Gnu 등)가 설치되어 있으면 대화식 CPAN 쉘은 히스토리를 지원합니다. 다음 두 질문은 기록 파일의 파일 이름과 크기를 처리합니다. 이 변수를 설정하지 않으려면 다음 질문에 SPACE ENTER를 누르십시오.</target>
        </trans-unit>
        <trans-unit id="bb7b55bdb52c9b6a39041d0271244a521cb3ff47" translate="yes" xml:space="preserve">
          <source>If you have perl documentation in the source form, perl utilities installed, and GNU groff installed, you may use</source>
          <target state="translated">소스 형식의 perl 문서, perl 유틸리티 및 GNU groff가 설치된 경우 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="841004095d25b3d59f531a821f770d0871403ca9" translate="yes" xml:space="preserve">
          <source>If you have previously used &lt;code&gt;Compress::Zlib&lt;/code&gt; 1.x, the following enhancements/changes have been made to the &lt;code&gt;gzopen&lt;/code&gt; interface:</source>
          <target state="translated">이전에 &lt;code&gt;Compress::Zlib&lt;/code&gt; 1.x를 사용한 경우 &lt;code&gt;gzopen&lt;/code&gt; 인터페이스 가 다음과 같이 개선 / 변경되었습니다 .</target>
        </trans-unit>
        <trans-unit id="d2a37b8d2199c6cd81ec323e698311d35b1e6c13" translate="yes" xml:space="preserve">
          <source>If you have problems with dynamic loading using gcc on SunOS or Solaris, and you are using GNU as and GNU ld, see the section &lt;a href=&quot;#GNU-as-and-GNU-ld&quot;&gt;GNU as and GNU ld&lt;/a&gt; above.</source>
          <target state="translated">SunOS 또는 Solaris에서 gcc를 사용한 동적 로딩에 문제가 있고 &lt;a href=&quot;#GNU-as-and-GNU-ld&quot;&gt;GNU as 및 GNU ld를 사용하는 경우&lt;/a&gt; 위의 GNU as 및 GNU ld 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ea5710225473b92c4d4337a393fa28ea045d7828" translate="yes" xml:space="preserve">
          <source>If you have questions about DJGPP, try posting to the DJGPP newsgroup: comp.os.msdos.djgpp, or use the email gateway djgpp@delorie.com.</source>
          <target state="translated">DJGPP에 대한 질문이있는 경우 DJGPP 뉴스 그룹 (comp.os.msdos.djgpp)에 게시하거나 이메일 게이트웨이 djgpp@delorie.com을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fe0f8d11e3dbd4746ff7b4eeb245a0d52d534f6e" translate="yes" xml:space="preserve">
          <source>If you have questions, I will be happy to answer them if you send them to mjd-perl-memoize+@plover.com.</source>
          <target state="translated">질문이 있으시면 mjd-perl-memoize+@plover.com으로 보내 주시면 기꺼이 답변 해 드리겠습니다.</target>
        </trans-unit>
        <trans-unit id="f26f03ce6e7bfe1cbb7f3ba37413ced07d1e0917" translate="yes" xml:space="preserve">
          <source>If you have read this far, congratulations! You now have all the basic tools needed to use regular expressions to solve a wide range of text processing problems. If this is your first time through the tutorial, why not stop here and play around with regexps a while.... Part 2 concerns the more esoteric aspects of regular expressions and those concepts certainly aren't needed right at the start.</source>
          <target state="translated">이 글을 읽었다면 축하합니다! 이제 광범위한 텍스트 처리 문제를 해결하기 위해 정규식을 사용하는 데 필요한 모든 기본 도구가 있습니다. 이 튜토리얼을 처음 접하는 분이라면 여기에서 멈추고 정규 표현식으로 잠시 놀아보십시오. 2 부에서는 정규 표현식의 좀 더 난해한 측면에 대해 다루고 있으며 이러한 개념은 시작시 바로 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="75f3eda9f9b422ec46068b583597695f9e1e075d" translate="yes" xml:space="preserve">
          <source>If you have some WWW browser available, installed the Perl documentation in the source form, and Perl utilities, you can build HTML docs. Cd to directory with</source>
          <target state="translated">사용 가능한 WWW 브라우저가 있고 소스 양식으로 Perl 문서 및 Perl 유틸리티를 설치 한 경우 HTML 문서를 빌드 할 수 있습니다. 디렉토리에 CD</target>
        </trans-unit>
        <trans-unit id="15919d939102f998b0d1a3071b0bdc4ec9361810" translate="yes" xml:space="preserve">
          <source>If you have some WWW browser available, you can build &lt;b&gt;HTML&lt;/b&gt; docs. Cd to directory with</source>
          <target state="translated">사용 가능한 WWW 브라우저가 있으면 &lt;b&gt;HTML&lt;/b&gt; 문서를 작성할 수 있습니다 . 디렉토리에 CD</target>
        </trans-unit>
        <trans-unit id="760a427c6aacab9e74e50c0e342e67f06ea0a89d" translate="yes" xml:space="preserve">
          <source>If you have some working code for &lt;code&gt;OS2::Cmd&lt;/code&gt; , please send it to me, I will include it into distribution. I have no need for such a module, so cannot test it.</source>
          <target state="translated">&lt;code&gt;OS2::Cmd&lt;/code&gt; 대한 작업 코드가 있으면 나에게 보내주십시오. 배포에 포함시킬 것입니다. 그러한 모듈이 필요하지 않으므로 테스트 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c766c1d4e406f5a8fab49e64104f5bd544a7e67b" translate="yes" xml:space="preserve">
          <source>If you have test cases that fail, check for the existence of spool files. The test case may be trying to use a syscall that is not implemented in PASE. To avoid the SIGILL, try setting the PASE_SYSCALL_NOSIGILL environment variable or have a handler for the SIGILL. If you can compile programs for PASE, run the config script and edit config.sh when it gives you the option. If you want to remove fchdir(), which isn't implement in V5R1, simply change the line that says:</source>
          <target state="translated">실패한 테스트 케이스가있는 경우 스풀 파일이 있는지 확인하십시오. 테스트 케이스가 PASE에서 구현되지 않은 syscall을 사용하려고 시도했을 수 있습니다. SIGILL을 피하려면 PASE_SYSCALL_NOSIGILL 환경 변수를 설정하거나 SIGILL에 대한 핸들러를 사용하십시오. PASE 용 프로그램을 컴파일 할 수 있으면 config 스크립트를 실행하고 옵션이 제공 될 때 config.sh를 편집하십시오. V5R1에서 구현되지 않은 fchdir ()을 제거하려면 다음과 같은 행을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="c895956df28d2a0d520a665ed39e5054b694f69f" translate="yes" xml:space="preserve">
          <source>If you have the &lt;code&gt;Kwalify&lt;/code&gt; module installed (which is part of the Bundle::CPANxxl), then all your distroprefs files are checked for syntactic correctness.</source>
          <target state="translated">당신이있는 경우 &lt;code&gt;Kwalify&lt;/code&gt; 의 (번들 :: CPANxxl의 일부입니다) 모듈을 설치 한 후 모든 distroprefs 파일을 구문 정확성을 위해 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="310e2cf6fe93a96344e5f48617c55b650052b357" translate="yes" xml:space="preserve">
          <source>If you have the &lt;code&gt;uncompress&lt;/code&gt; program available, you can use this to read compressed files</source>
          <target state="translated">당신이있는 경우 &lt;code&gt;uncompress&lt;/code&gt; 프로그램을 사용할 수, 당신은 압축 된 파일을 읽을 이것을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="a48f13710ced892050924fc9519945fba0fac1d0" translate="yes" xml:space="preserve">
          <source>If you have the GNU's version of &lt;b&gt;emacs&lt;/b&gt; installed on your system, it can interact with the Perl debugger to provide an integrated software development environment reminiscent of its interactions with C debuggers.</source>
          <target state="translated">시스템에 GNU &lt;b&gt;emacs&lt;/b&gt; 버전이 설치되어 있으면 Perl 디버거와 상호 작용하여 C 디버거와의 상호 작용을 연상시키는 통합 소프트웨어 개발 환경을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="831bd1aa0f0b4a83cdb4f8d8c798aaee5e24ba5d" translate="yes" xml:space="preserve">
          <source>If you have the LD_LIBRARY_PATH environment variable set, be sure that it does NOT include /lib or /usr/lib. If you will be building extensions that call third-party shared libraries (e.g. Berkeley DB) then make sure that your LD_LIBRARY_PATH environment variable includes the directory with that library (e.g. /usr/local/lib).</source>
          <target state="translated">LD_LIBRARY_PATH 환경 변수가 설정되어 있으면 / lib 또는 / usr / lib를 포함하지 않아야합니다. 타사 공유 라이브러리 (예 : Berkeley DB)를 호출하는 확장을 빌드하는 경우 LD_LIBRARY_PATH 환경 변수에 해당 라이브러리가있는 디렉토리 (예 : / usr / local / lib)가 포함되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="7b99419c67def721d2695cd48d34dc88cb8c781c" translate="yes" xml:space="preserve">
          <source>If you have to deal with a lot of C structures, and don't want to hack all your template strings manually, you'll probably want to have a look at the CPAN module &lt;code&gt;Convert::Binary::C&lt;/code&gt; . Not only can it parse your C source directly, but it also has built-in support for all the odds and ends described further on in this section.</source>
          <target state="translated">많은 C 구조를 처리하고 모든 템플릿 문자열을 수동으로 해킹하고 싶지 않은 경우 CPAN 모듈 &lt;code&gt;Convert::Binary::C&lt;/code&gt; 살펴보고 싶을 것입니다 . C 소스를 직접 구문 분석 할 수있을뿐만 아니라이 섹션에서 더 자세히 설명 된 모든 확률과 끝을 기본적으로 지원합니다.</target>
        </trans-unit>
        <trans-unit id="fedff50b6bdfc3eaf8ccc29c03df5c84e0ff6a06" translate="yes" xml:space="preserve">
          <source>If you have trouble compiling the scripts in this documentation, you're not alone. The cardinal rule: COMPILE THE PROGRAMS IN EXACTLY THE SAME WAY THAT YOUR PERL WAS COMPILED. (Sorry for yelling.)</source>
          <target state="translated">이 문서에서 스크립트를 컴파일하는 데 문제가 있다면 혼자가 아닙니다. 기본 규칙 : 정확한 PERL 프로그램과 동일한 방식으로 프로그램을 완료하십시오. (죄송합니다.)</target>
        </trans-unit>
        <trans-unit id="899489485e48eb6acab0142eabbf325712e8b44a" translate="yes" xml:space="preserve">
          <source>If you have updated your Solaris version, you may also have to update your gcc. For example, if you are running Solaris 2.6 and your gcc is installed under /usr/local, check in /usr/local/lib/gcc-lib and make sure you have the appropriate directory, sparc-sun-solaris2.6/ or i386-pc-solaris2.6/. If gcc's directory is for a different version of Solaris than you are running, then you will need to rebuild gcc for your new version of Solaris.</source>
          <target state="translated">Solaris 버전을 업데이트 한 경우 gcc를 업데이트해야 할 수도 있습니다. 예를 들어, Solaris 2.6을 실행 중이고 gcc가 / ​​usr / local에 설치된 경우 / usr / local / lib / gcc-lib를 확인하여 적절한 디렉토리 sparc-sun-solaris2.6 /이 있는지 확인하십시오. i386-pc-solaris2.6 /. gcc의 디렉토리가 실행중인 것과 다른 버전의 Solaris 용인 경우 새 버전의 Solaris 용으로 gcc를 재 구축해야합니다.</target>
        </trans-unit>
        <trans-unit id="d44abb6ca108f95533f7bd86193633f514940a80" translate="yes" xml:space="preserve">
          <source>If you have your perl compiled for debugging (usually done with &lt;code&gt;-DDEBUGGING&lt;/code&gt; on the &lt;code&gt;Configure&lt;/code&gt; command line), you may examine the compiled tree by specifying &lt;code&gt;-Dx&lt;/code&gt; on the Perl command line. The output takes several lines per node, and for &lt;code&gt;$b+$c&lt;/code&gt; it looks like this:</source>
          <target state="translated">디버깅을 위해 perl을 컴파일 한 경우 (일반적으로 &lt;code&gt;Configure&lt;/code&gt; 명령 행 에서 &lt;code&gt;-DDEBUGGING&lt;/code&gt; 으로 수행됨 ) Perl 명령 행에서 &lt;code&gt;-Dx&lt;/code&gt; 를 지정하여 컴파일 된 트리를 검사 할 수 있습니다 . 출력은 노드 당 여러 줄을 취하며 &lt;code&gt;$b+$c&lt;/code&gt; 경우 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4be3c9c74002e27258a38e4f113b05f31396c7de" translate="yes" xml:space="preserve">
          <source>If you haven't already guessed, the location string is stored with a terminating NULL. This means you need to be careful when accessing the database.</source>
          <target state="translated">아직 추측하지 않은 경우 위치 문자열은 종료 NULL로 저장됩니다. 즉, 데이터베이스에 액세스 할 때주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="f0a36e2858858b02958d2f9bb2e7a02778b6e7c8" translate="yes" xml:space="preserve">
          <source>If you haven't already, before reading this document, you should become familiar with both &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; and &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;.</source>
          <target state="translated">이 문서를 읽기 전에 &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; 및 &lt;a href=&quot;perluniintro&quot;&gt;perluniintro에&lt;/a&gt; 대해 잘 알고 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="4f5cd5895b74e660a355a89bb89cfe0d64a65e68" translate="yes" xml:space="preserve">
          <source>If you haven't read &lt;a href=&quot;perlhack&quot;&gt;perlhack&lt;/a&gt; and &lt;a href=&quot;perlhacktut&quot;&gt;perlhacktut&lt;/a&gt; yet, you might want to do that first.</source>
          <target state="translated">&lt;a href=&quot;perlhack&quot;&gt;perlhack&lt;/a&gt; 과 &lt;a href=&quot;perlhacktut&quot;&gt;perlhacktut를&lt;/a&gt; 아직 읽지 않았다면 먼저 해보고 싶을 것입니다.</target>
        </trans-unit>
        <trans-unit id="9d18cc6d1bb045c22ff75a5143e7edc7882d3f36" translate="yes" xml:space="preserve">
          <source>If you haven't read &lt;a href=&quot;perlhack&quot;&gt;perlhack&lt;/a&gt; yet, go do that first! You might also want to read through &lt;a href=&quot;perlsource&quot;&gt;perlsource&lt;/a&gt; too.</source>
          <target state="translated">&lt;a href=&quot;perlhack&quot;&gt;perlhack을&lt;/a&gt; 아직 읽지 않았다면 먼저 해보 십시오 ! 또한 &lt;a href=&quot;perlsource&quot;&gt;perlsource를&lt;/a&gt; 통해 읽을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0c78c6e524a1994f83a33a6fe7a18f30be9a7fce" translate="yes" xml:space="preserve">
          <source>If you haven't used regular expressions before, a quick-start introduction is available in &lt;a href=&quot;perlrequick&quot;&gt;perlrequick&lt;/a&gt;, and a longer tutorial introduction is available in &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt;.</source>
          <target state="translated">이전에 정규 표현식을 사용하지 않은 경우 &lt;a href=&quot;perlrequick&quot;&gt;perlrequick&lt;/a&gt; 에서 빠른 시작 소개를 사용할 수 있고 &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt; 에서 더 긴 학습서 소개를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3a7a1d83ca677617a38c3a7af6a10c7ed341f9e8" translate="yes" xml:space="preserve">
          <source>If you haven't yet moved &lt;code&gt;perl*.dll&lt;/code&gt; onto LIBPATH, do it now.</source>
          <target state="translated">&lt;code&gt;perl*.dll&lt;/code&gt; 을 ( 를) LIBPATH 로 아직 이동하지 않은 경우 지금 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="83593b846f63af31e001bdf82839b9a46da47025" translate="yes" xml:space="preserve">
          <source>If you ignore all the error checking that most of the code does, the essence of the filter is as follows:</source>
          <target state="translated">대부분의 코드가 수행하는 모든 오류 검사를 무시하면 필터의 본질은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4660b183b00b39c6b2b92484fb7503359beb8635" translate="yes" xml:space="preserve">
          <source>If you import &lt;code&gt;:constants256&lt;/code&gt; , you can use the following constants directly:</source>
          <target state="translated">&lt;code&gt;:constants256&lt;/code&gt; 을 가져 오는 경우 다음 상수를 직접 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f87b608eeb1cdc6eb4d8977d4b889a03e6d083dd" translate="yes" xml:space="preserve">
          <source>If you intend making use of the object returned from either tie() or tied(), and if the tie's target class defines a destructor, there is a subtle gotcha you</source>
          <target state="translated">tie () 또는 tied ()에서 반환 된 객체를 사용하려는 경우, tie의 대상 클래스가 소멸자를 정의하는 경우 미묘한 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bc6f9a7f0a4b90e4946e190029eff70ef889753" translate="yes" xml:space="preserve">
          <source>If you intend to manipulate the Zip64 zip files created with this module using an external zip/unzip, make sure that it supports Zip64.</source>
          <target state="translated">외부 zip / unzip을 사용하여이 모듈로 작성된 Zip64 zip 파일을 조작하려는 경우 Zip64를 지원하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="fd3a1f6a190142b4a94b8f1071ccacb0e45694c8" translate="yes" xml:space="preserve">
          <source>If you intend to run only on FAT (or if using AnyDBM_File on FAT), run Configure with the -Ui_ndbm and -Ui_dbm options to prevent NDBM_File and ODBM_File being built.</source>
          <target state="translated">FAT에서만 실행하려는 경우 (또는 FAT에서 AnyDBM_File을 사용하는 경우) NDBM_File 및 ODBM_File이 빌드되지 않도록 -Ui_ndbm 및 -Ui_dbm 옵션으로 Configure를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="3f04b70c5edf0d8a2ff6b52a2e5a3c4237fee493" translate="yes" xml:space="preserve">
          <source>If you intend using the Filter::Call functionality, I would strongly recommend that you check out Damian Conway's excellent Filter::Simple module. Damian's module provides a much cleaner interface than Filter::Util::Call. Although it doesn't allow the fine control that Filter::Util::Call does, it should be adequate for the majority of applications. It's available at</source>
          <target state="translated">Filter :: Call 기능을 사용하려면 Damian Conway의 탁월한 Filter :: Simple 모듈을 확인하는 것이 좋습니다. Damian의 모듈은 Filter :: Util :: Call보다 훨씬 깨끗한 인터페이스를 제공합니다. Filter :: Util :: Call이 수행하는 정밀한 제어는 허용하지 않지만 대부분의 응용 프로그램에 적합해야합니다. 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="e2cffac6976f9820e2e90021e812ad7d58d0f5b4" translate="yes" xml:space="preserve">
          <source>If you intended for the subroutine to be eligible for inlining, then make sure the variable is not referenced elsewhere, possibly by copying it:</source>
          <target state="translated">서브 루틴이 인라인에 적합하도록하려면 변수를 복사하여 다른 곳에서 참조되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="9dab4bde5120fee3a0a7f6db844ef859c18d4c68" translate="yes" xml:space="preserve">
          <source>If you invoke Concise more than once in a program, you should know that the options are 'sticky'. This means that the options you provide in the first call will be remembered for the 2nd call, unless you re-specify or change them.</source>
          <target state="translated">프로그램에서 Concise를 두 번 이상 호출하면 옵션이 'sticky'라는 것을 알아야합니다. 다시 지정하거나 변경하지 않으면 첫 번째 통화에서 제공하는 옵션이 두 번째 통화에 대해 기억됩니다.</target>
        </trans-unit>
        <trans-unit id="50093622d9b6b20299be5b789440addca54eb16b" translate="yes" xml:space="preserve">
          <source>If you invoke Perl with the &lt;b&gt;-d&lt;/b&gt; switch, your script runs under the Perl source debugger. This works like an interactive Perl environment, prompting for debugger commands that let you examine source code, set breakpoints, get stack backtraces, change the values of variables, etc. This is so convenient that you often fire up the debugger all by itself just to test out Perl constructs interactively to see what they do. For example:</source>
          <target state="translated">&lt;b&gt;-d&lt;/b&gt; 스위치 를 사용하여 Perl을 호출하면 스크립트가 Perl 소스 디버거에서 실행됩니다. 이것은 대화식 Perl 환경처럼 작동하여 소스 코드를 검사하고, 중단 점을 설정하고, 역 추적을 얻고, 변수 값을 변경하는 등의 디버거 명령을 요구합니다.이 방법은 종종 디버거 자체를 Perl 구성을 대화식으로 테스트하여 그들이하는 일을 확인하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5f165a45e66d1014a54e531d87cac35b6f25f848" translate="yes" xml:space="preserve">
          <source>If you iterate through the hash with each(), you can delete the key most recently returned without worrying about it. If you delete or add other keys, the iterator may skip or double up on them since perl may rearrange the hash table. See the entry for &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt; in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;.</source>
          <target state="translated">each ()로 해시를 반복하면 가장 최근에 반환 된 키를 걱정하지 않고 삭제할 수 있습니다. 다른 키를 삭제하거나 추가하면 perl이 해시 테이블을 재 배열 할 수 있으므로 반복자가 해당 키를 건너 뛰거나 두 배로 늘릴 수 있습니다. &lt;a href=&quot;perlfunc&quot;&gt;perlfunc의 &lt;/a&gt; &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt; 에 대한 항목을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="96bb290aa78bc388524149987ffa684a6cd88006" translate="yes" xml:space="preserve">
          <source>If you just need to customize the objects on creation, subclass &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt; and override &lt;a href=&quot;#make_iterator_factory&quot;&gt;make_iterator_factory&lt;/a&gt;.</source>
          <target state="translated">작성시 오브젝트를 사용자 정의해야하는 경우 서브 클래스 &lt;a href=&quot;parser&quot;&gt;TAP :: Parser&lt;/a&gt; 를 작성 하고 &lt;a href=&quot;#make_iterator_factory&quot;&gt;make_iterator_factory를&lt;/a&gt; 대체 하십시오 .</target>
        </trans-unit>
        <trans-unit id="1eae7a7eb8bcc1fc11d062386801944953ed61fe" translate="yes" xml:space="preserve">
          <source>If you just want to extract, use the &lt;code&gt;extract_archive&lt;/code&gt; class method instead. It will optimize and write to disk immediately.</source>
          <target state="translated">추출하려는 경우 &lt;code&gt;extract_archive&lt;/code&gt; 클래스 메소드를 대신 사용하십시오 . 디스크를 즉시 최적화하고 기록합니다.</target>
        </trans-unit>
        <trans-unit id="205b6c9376bdc41030a3ba0411b3c133175a1cfb" translate="yes" xml:space="preserve">
          <source>If you just want to know how to use the utilities described here,</source>
          <target state="translated">여기에 설명 된 유틸리티를 사용하는 방법 만 알고 싶다면</target>
        </trans-unit>
        <trans-unit id="5ca84053d1241bb168ed3733abf9fe5fef328612" translate="yes" xml:space="preserve">
          <source>If you just want to load a module in a test, we recommend simply using &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; directly. It will cause the test to stop.</source>
          <target state="translated">테스트에 모듈을로드 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 직접 사용 하는 것이 좋습니다 . 테스트가 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="58d9e2fc3089c3ee91bde03c8a168aabda14adca" translate="yes" xml:space="preserve">
          <source>If you just want to submit a single small patch like a pod fix, a test for a bug, comment fixes, etc., it's easy! Here's how:</source>
          <target state="translated">포드 수정, 버그 테스트, 주석 수정 등과 같은 하나의 작은 패치를 제출하려는 경우 간단합니다! 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a3962095233ae6bded8cb1555c84a52ea4fc9a0c" translate="yes" xml:space="preserve">
          <source>If you just want to test a module can be loaded, use &lt;code&gt;require_ok&lt;/code&gt; .</source>
          <target state="translated">모듈 만로드 할 수 있는지 테스트하려면 &lt;code&gt;require_ok&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="42e3b970aadb68ea3a8923d019f70d26e7a5a350" translate="yes" xml:space="preserve">
          <source>If you know</source>
          <target state="translated">알고 있다면</target>
        </trans-unit>
        <trans-unit id="9c14b8eb60486ad1003f5f292ba8d0aaf7f2284e" translate="yes" xml:space="preserve">
          <source>If you know one name for a Unicode property, you can use &lt;code&gt;prop_aliases&lt;/code&gt; to find either the long name (when called in scalar context), or a list of all of the names, somewhat ordered so that the short name is in the 0th element, the long name in the next element, and any other synonyms are in the remaining elements, in no particular order.</source>
          <target state="translated">유니 코드 속성의 이름 중 하나를 알고있는 경우 &lt;code&gt;prop_aliases&lt;/code&gt; 를 사용 하여 긴 이름 (스칼라 컨텍스트에서 호출 될 때) 또는 짧은 이름이 0 번째 요소에 있도록 다소 정렬 된 모든 이름 목록을 찾을 수 있습니다. 다음 요소의 긴 이름과 다른 동의어는 나머지 요소에 특별한 순서가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4a59a33095f0058eebdfd05ced2318493337053a" translate="yes" xml:space="preserve">
          <source>If you know the columns that contain the data, you can use &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;&lt;/code&gt; to extract a single column.</source>
          <target state="translated">데이터가 포함 된 열을 알고 있으면 &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;&lt;/code&gt; 을 사용하여 단일 열을 추출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9eb4c97e122131b8720d6a259fed14fb554c1b02" translate="yes" xml:space="preserve">
          <source>If you know the directory already, you can add it to &lt;code&gt;@INC&lt;/code&gt; as you would for any other directory. You might &amp;lt;use lib&amp;gt; if you know the directory at compile time:</source>
          <target state="translated">디렉토리를 이미 알고 있다면 다른 디렉토리와 마찬가지로 &lt;code&gt;@INC&lt;/code&gt; 에 추가 할 수 있습니다 . 컴파일 타임에 디렉토리를 알고 있다면 &amp;lt;lib 사용&amp;gt; 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e98e61c08f8371d445ada91d42b0a6e31509fa7c" translate="yes" xml:space="preserve">
          <source>If you know the exact length in bits, it can be used in place of the &lt;code&gt;*&lt;/code&gt; .</source>
          <target state="translated">비트 단위의 정확한 길이를 알고 있으면 &lt;code&gt;*&lt;/code&gt; 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="927bf5e4096ddfb3b14c96fc89123708e7ddad90" translate="yes" xml:space="preserve">
          <source>If you know the length of the compressed data stream before you start uncompressing, you can avoid having to use &lt;code&gt;trailingData&lt;/code&gt; by setting the &lt;code&gt;InputLength&lt;/code&gt; option in the constructor.</source>
          <target state="translated">압축 해제를 시작하기 전에 압축 된 데이터 스트림의 길이를 알고 있으면 생성자에서 &lt;code&gt;InputLength&lt;/code&gt; 옵션 을 설정하여 &lt;code&gt;trailingData&lt;/code&gt; 를 사용하지 않아도됩니다 .</target>
        </trans-unit>
        <trans-unit id="f21638ec12744a0da920d55488938e9726007614" translate="yes" xml:space="preserve">
          <source>If you know the length of the compressed data stream before you start uncompressing, you can avoid having to use &lt;code&gt;trailingData&lt;/code&gt; by setting the &lt;code&gt;InputLength&lt;/code&gt; option.</source>
          <target state="translated">압축 해제를 시작하기 전에 압축 된 데이터 스트림의 길이를 알고 있으면 &lt;code&gt;InputLength&lt;/code&gt; 옵션 을 설정하여 &lt;code&gt;trailingData&lt;/code&gt; 를 사용하지 않아도됩니다 .</target>
        </trans-unit>
        <trans-unit id="d2ae57604fb0c858677a8a7bba0d622df68f1d53" translate="yes" xml:space="preserve">
          <source>If you know the name of a hash variable, you can get a pointer to its HV by using the following:</source>
          <target state="translated">해시 변수의 이름을 알고 있으면 다음을 사용하여 HV에 대한 포인터를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb63e6aa11dc04fb3c005505a5dc56980b836dee" translate="yes" xml:space="preserve">
          <source>If you know the name of a scalar variable, you can get a pointer to its SV by using the following:</source>
          <target state="translated">스칼라 변수의 이름을 알고 있으면 다음을 사용하여 SV에 대한 포인터를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71cc5e317d663fb79a1bf1ed454222ec34ef184d" translate="yes" xml:space="preserve">
          <source>If you know the name of an array variable, you can get a pointer to its AV by using the following:</source>
          <target state="translated">배열 변수의 이름을 알고 있으면 다음을 사용하여 AV에 대한 포인터를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd318c8126ae3cf5cfc9e3d9345bc2d0fc779cdb" translate="yes" xml:space="preserve">
          <source>If you know what you are doing you can turn off this warning by &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'non_unicode';&lt;/code&gt; .</source>
          <target state="translated">당신은 당신이에 의해이 경고를 해제 할 수 있습니다 무엇을하고 있는지 알고 있다면 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'non_unicode';&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b884b7f1740fc7317e54fef08f2f9cd3cb14f5e3" translate="yes" xml:space="preserve">
          <source>If you know what you are doing you can turn off this warning by &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'surrogate';&lt;/code&gt; .</source>
          <target state="translated">당신은 당신이에 의해이 경고를 해제 할 수 있습니다 무엇을하고 있는지 알고 있다면 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'surrogate';&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e7e8e09f3e73c52948b41c1fa2c3d1d138db3f3" translate="yes" xml:space="preserve">
          <source>If you know you are only going to use a system that does correctly implement appending (i.e. not Win32) then you can omit the &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; from the code in the previous answer.</source>
          <target state="translated">추가를 올바르게 구현하는 시스템 만 사용한다는 것을 알고 있다면 (즉, Win32는 아님) 이전 답변의 코드에서 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 를 생략 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1148f14b2fe4053075a5db927cd2f992ce530c8c" translate="yes" xml:space="preserve">
          <source>If you know you are only writing code to run on an OS and filesystem that does implement append mode correctly (a local filesystem on a modern Unix for example), and you keep the file in block-buffered mode and you write less than one buffer-full of output between each manual flushing of the buffer then each bufferload is almost guaranteed to be written to the end of the file in one chunk without getting intermingled with anyone else's output. You can also use the &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; function which is simply a wrapper around your system's &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write(2)&lt;/a&gt;&lt;/code&gt; system call.</source>
          <target state="translated">추가 모드를 올바르게 구현하는 OS 및 파일 시스템 (예 : 최신 Unix의 로컬 파일 시스템)에서만 실행되도록 코드를 작성하고 파일을 블록 버퍼 모드로 유지하고 하나보다 적은 버퍼를 작성하는 경우 -버퍼의 각 수동 플러싱 사이에 출력이 가득 차면 각 버퍼로드가 다른 사람의 출력과 섞이지 않고 한 청크로 파일 끝에 기록되도록 거의 보장됩니다. 시스템의 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write(2)&lt;/a&gt;&lt;/code&gt; 시스템 호출을 감싸는 래퍼 인 &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; 함수를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="01c8e667e3ed1b51f8f2d44670f827394972704b" translate="yes" xml:space="preserve">
          <source>If you know your package, you can just mention it explicitly, as in $Some_Pack::var. Note that the notation $::var is &lt;b&gt;not&lt;/b&gt; the dynamic $var in the current package, but rather the one in the &quot;main&quot; package, as though you had written $main::var.</source>
          <target state="translated">패키지를 알고 있다면 $ Some_Pack :: var에서와 같이 명시 적으로 언급 할 수 있습니다. 표기법 $ :: var에 유의 &lt;b&gt;하지&lt;/b&gt; 당신이 $ 주 : VAR을 쓴 것처럼, 현재 패키지의 동적 $ var에, 오히려 &quot;기본&quot;패키지의 하나.</target>
        </trans-unit>
        <trans-unit id="283a4b9fbff3cde02d8b49d7e007e0e9915125fc" translate="yes" xml:space="preserve">
          <source>If you like a more web-like approach, a good start point can be &lt;a href=&quot;http://www14.software.ibm.com/webapp/download/downloadaz.jsp&quot;&gt;http://www14.software.ibm.com/webapp/download/downloadaz.jsp&lt;/a&gt; and click &quot;C for AIX&quot;, and follow the instructions.</source>
          <target state="translated">보다 웹과 유사한 접근 방식을 선호하는 경우 &lt;a href=&quot;http://www14.software.ibm.com/webapp/download/downloadaz.jsp&quot;&gt;http://www14.software.ibm.com/webapp/download/downloadaz.jsp로&lt;/a&gt; 시작하여 &quot;C for AIX&quot;를 클릭하고 지시 사항을 따르십시오.</target>
        </trans-unit>
        <trans-unit id="b95d71103315a260f526ee0388cdf401d8ff3b71" translate="yes" xml:space="preserve">
          <source>If you like the &lt;code&gt;prove&lt;/code&gt; utility and &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt; but you want your own harness, all you need to do is write one and provide &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;runtests&lt;/code&gt; methods. Then you can use the &lt;code&gt;prove&lt;/code&gt; utility like so:</source>
          <target state="translated">(가)와 같은 당신이 경우 &lt;code&gt;prove&lt;/code&gt; 유틸리티와 &lt;a href=&quot;parser&quot;&gt;TAP을 :: 파서&lt;/a&gt; 하지만 당신은 당신의 자신의 하네스를 원하는, 당신이 할 필요가 쓰기 하나 제공하는 것입니다 &lt;code&gt;new&lt;/code&gt; 와 &lt;code&gt;runtests&lt;/code&gt; 방법. 그런 다음 &lt;code&gt;prove&lt;/code&gt; 유틸리티를 다음과 같이 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fbd3ba27ff3a08207feb966e075b2fa08e7cf809" translate="yes" xml:space="preserve">
          <source>If you like, you can store these filehandles in an array or a hash. If you access them directly, they aren't simple scalars and you need to give &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; a little help by placing the filehandle reference in braces. Perl can only figure it out on its own when the filehandle reference is a simple scalar.</source>
          <target state="translated">원하는 경우 이러한 파일 핸들을 배열 또는 해시에 저장할 수 있습니다. 당신이 직접 액세스하는 경우, 그들은 간단한 스칼라하지 않습니다 그리고 당신은 줄 필요가 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 괄호에있는 파일 핸들 참조를 배치하여 약간의 도움이. 펄은 파일 핸들 참조가 단순한 스칼라 일 때만 스스로 알아낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d730d69794a1a0d8df4bc0eb2edfe8040f78af15" translate="yes" xml:space="preserve">
          <source>If you localize a special variable, you'll be giving a new value to it, but its magic won't go away. That means that all side-effects related to this magic still work with the localized value.</source>
          <target state="translated">특수 변수를 지역화하면 새로운 가치를 부여하지만 마법은 사라지지 않습니다. 즉,이 마법과 관련된 모든 부작용은 여전히 ​​현지화 된 가치와 함께 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c90f343f24019c1da72c48d70c317941a7498b61" translate="yes" xml:space="preserve">
          <source>If you localize an exported variable in a module, its exported value will not change. The local name becomes an alias to a new value but the external name is still an alias for the original.</source>
          <target state="translated">모듈에서 내 보낸 변수를 현지화하면 내 보낸 값이 변경되지 않습니다. 로컬 이름은 새 값의 별칭이되지만 외부 이름은 여전히 ​​원본의 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="dafcf35a82f601b489cfb5dd0eef86e45cb1372b" translate="yes" xml:space="preserve">
          <source>If you look at its source, you'll see that open2() uses low-level primitives like the pipe() and exec() syscalls to create all the connections. Although it might have been more efficient by using socketpair(), this would have been even less portable than it already is. The open2() and open3() functions are unlikely to work anywhere except on a Unix system, or at least one purporting POSIX compliance.</source>
          <target state="translated">소스를 살펴보면 open2 ()가 pipe () 및 exec () syscalls와 같은 저수준 프리미티브를 사용하여 모든 연결을 생성한다는 것을 알 수 있습니다. socketpair ()를 사용하는 것이 더 효율적이었을 수도 있지만, 이것은 이전보다 훨씬 이식성이 떨어졌을 것입니다. open2 () 및 open3 () 함수는 Unix 시스템 또는 POSIX 호환을 적어도 하나 이상 제외하고는 어느 곳에서도 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dba57ac6d2e87e59b7cd30bc2efe7662859d4f78" translate="yes" xml:space="preserve">
          <source>If you look at the contents of a database file created by DB_File, there can sometimes be part of a Perl script included in it.</source>
          <target state="translated">DB_File에 의해 작성된 데이터베이스 파일의 내용을 보면 때때로 Perl 스크립트의 일부가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e077c0b0a12316fa45027aa958a68eefe5eb38b" translate="yes" xml:space="preserve">
          <source>If you make use of the Berkeley DB API, it is</source>
          <target state="translated">Berkeley DB API를 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="044615c04770ac7a0002f5e8d4d8dd2908b76278" translate="yes" xml:space="preserve">
          <source>If you may assume POSIX (a rather large assumption), you may read more about the POSIX locale system from &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;. The locale system at least attempts to make things a little bit more portable, or at least more convenient and native-friendly for non-English users. The system affects character sets and encoding, and date and time formatting--amongst other things.</source>
          <target state="translated">POSIX를 가정 할 경우 (대략 큰 가정) &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; 에서 POSIX 로케일 시스템에 대한 자세한 정보를 읽을 수 있습니다 . 로케일 시스템은 적어도 영어를 사용하지 않는 사용자를 위해 물건을 좀 더 이식 가능하거나 최소한 더 편리하고 친숙하게 만들려고 시도합니다. 이 시스템은 문자 집합 및 인코딩, 날짜 및 시간 형식에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="a25944da5356d5910252ea9238bbb196b425ee18" translate="yes" xml:space="preserve">
          <source>If you memoize &lt;code&gt;getusers&lt;/code&gt; here, it will work right exactly once. The reference to the users list will be stored in the memo table. &lt;code&gt;main&lt;/code&gt; will discard the first element from the referenced list. The next time you invoke &lt;code&gt;main&lt;/code&gt; , &lt;code&gt;Memoize&lt;/code&gt; will not call &lt;code&gt;getusers&lt;/code&gt; ; it will just return the same reference to the same list it got last time. But this time the list has already had its head removed; &lt;code&gt;main&lt;/code&gt; will erroneously remove another element from it. The list will get shorter and shorter every time you call &lt;code&gt;main&lt;/code&gt; .</source>
          <target state="translated">여기서 &lt;code&gt;getusers&lt;/code&gt; 를 메모하면 정확히 한 번만 작동합니다. 사용자 목록에 대한 참조는 메모 테이블에 저장됩니다. &lt;code&gt;main&lt;/code&gt; 은 참조 된 목록에서 첫 번째 요소를 버립니다. 다음에 &lt;code&gt;main&lt;/code&gt; 을 호출 하면 &lt;code&gt;Memoize&lt;/code&gt; 는 &lt;code&gt;getusers&lt;/code&gt; 를 호출하지 않습니다 . 마지막으로 얻은 동일한 목록에 대한 동일한 참조를 반환합니다. 그러나 이번에는 목록이 이미 제거되었습니다. &lt;code&gt;main&lt;/code&gt; 은 다른 요소를 잘못 제거합니다. &lt;code&gt;main&lt;/code&gt; 을 호출 할 때마다 목록이 짧아지고 짧아집니다 .</target>
        </trans-unit>
        <trans-unit id="babf77ebcd09b5b6b24f3181921a88c6ea58626a" translate="yes" xml:space="preserve">
          <source>If you need a copy of the string, see &lt;a href=&quot;#bytes_from_utf8&quot;&gt;bytes_from_utf8&lt;/a&gt;.</source>
          <target state="translated">문자열의 사본이 필요한 경우 &lt;a href=&quot;#bytes_from_utf8&quot;&gt;bytes_from_utf8을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e5f94b7a22fe122cef06ac242e6fea05a7455fe1" translate="yes" xml:space="preserve">
          <source>If you need a notation that's that powerful, use normal Perl:</source>
          <target state="translated">강력한 표기법이 필요한 경우 일반 Perl을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d3c247b2226d86ce39340fe5128412de0478e397" translate="yes" xml:space="preserve">
          <source>If you need an empty attribute list, for example in a code generator, add a space before the &lt;code&gt;=&lt;/code&gt; .</source>
          <target state="translated">예를 들어 코드 생성기에서 빈 속성 목록이 필요한 경우 &lt;code&gt;=&lt;/code&gt; 앞에 공백을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="82f75e54b3d41cd48a9f47dcdc6a65f36e63ccd0" translate="yes" xml:space="preserve">
          <source>If you need more advanced management of what runs in parallel vs in sequence, see the associated 'rules' documentation in &lt;a href=&quot;tap/harness&quot;&gt;TAP::Harness&lt;/a&gt; and &lt;a href=&quot;tap/parser/scheduler&quot;&gt;TAP::Parser::Scheduler&lt;/a&gt;. If what's possible directly through &lt;code&gt;prove&lt;/code&gt; is not sufficient, you can write your own harness to access these features directly.</source>
          <target state="translated">병렬 및 순차적으로 실행되는 것에 대한 고급 관리가 필요한 경우 &lt;a href=&quot;tap/harness&quot;&gt;TAP :: Harness&lt;/a&gt; 및 &lt;a href=&quot;tap/parser/scheduler&quot;&gt;TAP :: Parser :: Scheduler&lt;/a&gt; 의 관련 '규칙'문서를 참조하십시오 . &lt;code&gt;prove&lt;/code&gt; 통해 직접 가능한 것이 충분하지 않은 경우 이러한 기능에 직접 액세스 할 수있는 고유 한 하네스를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcc2262a79a5dbdf9359e3765fbc56f15e34b33f" translate="yes" xml:space="preserve">
          <source>If you need more fine-grained control over shared variable access, see &lt;a href=&quot;../thread/semaphore&quot;&gt;Thread::Semaphore&lt;/a&gt;.</source>
          <target state="translated">공유 변수 액세스에 대한보다 세밀한 제어가 필요한 경우 &lt;a href=&quot;../thread/semaphore&quot;&gt;Thread :: Semaphore를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="06a1402305f2d5c348929119dfbe7d1b16bea038" translate="yes" xml:space="preserve">
          <source>If you need more memory (larger data segment) for your Perl programs you can set:</source>
          <target state="translated">Perl 프로그램에 더 많은 메모리 (더 큰 데이터 세그먼트)가 필요한 경우 다음을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a733f66f7ebcddfc5bced382948b822560f8102b" translate="yes" xml:space="preserve">
          <source>If you need non-ASCII characters in your source code, make it a UTF-8 encoded file and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; .</source>
          <target state="translated">소스 코드에 ASCII가 아닌 문자가 필요한 경우 UTF-8로 인코딩 된 파일로 만들고 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="de2791275bc33103874a494cba3668a34d497a88" translate="yes" xml:space="preserve">
          <source>If you need not it (say, in the case when you need not handle any combining characters), assign &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; explicitly.</source>
          <target state="translated">필요하지 않은 경우 (예 : 결합 문자를 처리 할 필요가없는 경우 &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; 명시 적으로 (normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt; )를 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="4d24eea4a069716d3cfb8ce322b04914e0b52151" translate="yes" xml:space="preserve">
          <source>If you need something like this functionality, you should use the &lt;a href=&quot;encoding&quot;&gt;encoding&lt;/a&gt; pragma, which is also deprecated, but has fewer nasty side effects.</source>
          <target state="translated">이 기능과 같은 기능이 필요하면 더 이상 사용되지 않지만 불쾌한 부작용이 적은 &lt;a href=&quot;encoding&quot;&gt;인코딩&lt;/a&gt; pragma를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="74399fe1ce7a1f4f506a06b60ded39ec27cea334" translate="yes" xml:space="preserve">
          <source>If you need something much more sophisticated and controllable, Leon Brocard's &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::ebug&quot;&gt;Devel::ebug&lt;/a&gt; (which you can call with the &lt;code&gt;-D&lt;/code&gt; switch as &lt;code&gt;-Debug&lt;/code&gt; ) gives you the programmatic hooks into everything you need to write your own (without too much pain and suffering).</source>
          <target state="translated">훨씬 더 정교하고 제어 가능한 것이 필요한 경우 Leon &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::ebug&quot;&gt;Brocard&lt;/a&gt; 의 Devel :: ebug ( &lt;code&gt;-D&lt;/code&gt; 스위치를 &lt;code&gt;-Debug&lt;/code&gt; 로 호출 할 수 있음 )는 너무 많은 고통과 고통없이 자신이 직접 작성해야하는 모든 것에 프로그래밍 방식의 고리를 제공합니다. ).</target>
        </trans-unit>
        <trans-unit id="77f3f2631a368e380813c177575d4bf78bb0f7fd" translate="yes" xml:space="preserve">
          <source>If you need the string representation of a character that doesn't have a mnemonic name in C, you should add it to the list in</source>
          <target state="translated">C에서 니모닉 이름이없는 문자의 문자열 표현이 필요한 경우, 해당 문자를 목록에 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="c2b8ba636abce4657c8c0f922660904cfc7228c1" translate="yes" xml:space="preserve">
          <source>If you need to be able to read a block which has an exact size, you can use the function &lt;code&gt;filter_read_exact&lt;/code&gt; . It works identically to &lt;code&gt;filter_read&lt;/code&gt; in block mode, except it will try to read a block which is exactly &lt;code&gt;$size&lt;/code&gt; bytes in length. The only circumstances when it will not return a block which is &lt;code&gt;$size&lt;/code&gt; bytes long is on EOF or error.</source>
          <target state="translated">정확한 크기의 블록을 읽을 수 있어야하는 경우 &lt;code&gt;filter_read_exact&lt;/code&gt; 함수를 사용할 수 있습니다 . 정확히 &lt;code&gt;$size&lt;/code&gt; 바이트 길이 의 블록을 읽으려고한다는 점을 제외하고는 블록 모드에서 &lt;code&gt;filter_read&lt;/code&gt; 와 동일하게 작동합니다 . 길이가 &lt;code&gt;$size&lt;/code&gt; 바이트 인 블록을 리턴하지 않는 유일한 환경 은 EOF 또는 오류입니다.</target>
        </trans-unit>
        <trans-unit id="18a6ebad8222234ffca6c9871e53dc4619a2ca40" translate="yes" xml:space="preserve">
          <source>If you need to bless or re-bless an object you can use the following function:</source>
          <target state="translated">대상을 축복하거나 다시 축복해야하는 경우 다음 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d70c6e2df233bb6ffd0181bcff94f18d3b389825" translate="yes" xml:space="preserve">
          <source>If you need to customize the objects on creation, subclass &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt; and override &lt;a href=&quot;#make_grammar&quot;&gt;make_grammar&lt;/a&gt;</source>
          <target state="translated">작성시 오브젝트를 사용자 정의해야하는 경우 서브 클래스 &lt;a href=&quot;parser&quot;&gt;TAP :: Parser&lt;/a&gt; 및 &lt;a href=&quot;#make_grammar&quot;&gt;make_grammar를&lt;/a&gt; 대체 하십시오.</target>
        </trans-unit>
        <trans-unit id="28d9937fb82713ba1f2c783a5af6bd5ed96f1469" translate="yes" xml:space="preserve">
          <source>If you need to customize the objects on creation, subclass &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt; and override &lt;a href=&quot;#make_result&quot;&gt;make_result&lt;/a&gt;.</source>
          <target state="translated">작성시 오브젝트를 사용자 정의해야하는 경우 서브 클래스 &lt;a href=&quot;parser&quot;&gt;TAP :: Parser&lt;/a&gt; 를 작성 하고 &lt;a href=&quot;#make_result&quot;&gt;make_result를&lt;/a&gt; 대체 하십시오 .</target>
        </trans-unit>
        <trans-unit id="9bf36336c456165d1f557c63d917cf367e24c8a2" translate="yes" xml:space="preserve">
          <source>If you need to distinguish between endian architectures you could use either of the variables set like so:</source>
          <target state="translated">엔디안 아키텍처를 구별 해야하는 경우 다음과 같이 설정된 변수 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6c8b4493aa37d00a1808e45469530aac89fd5c8" translate="yes" xml:space="preserve">
          <source>If you need to do something more complicated, you can use &lt;a href=&quot;http://search.cpan.org/perldoc/LWP::UserAgent&quot;&gt;LWP::UserAgent&lt;/a&gt; module to create your own user-agent (e.g. browser) to get the job done. If you want to simulate an interactive web browser, you can use the &lt;a href=&quot;http://search.cpan.org/perldoc/WWW::Mechanize&quot;&gt;WWW::Mechanize&lt;/a&gt; module.</source>
          <target state="translated">좀 더 복잡한 작업을 수행해야하는 경우 &lt;a href=&quot;http://search.cpan.org/perldoc/LWP::UserAgent&quot;&gt;LWP :: UserAgent&lt;/a&gt; 모듈을 사용하여 작업을 수행하기 위해 고유 한 사용자 에이전트 (예 : 브라우저)를 만들 수 있습니다. 대화식 웹 브라우저를 시뮬레이트하려면 &lt;a href=&quot;http://search.cpan.org/perldoc/WWW::Mechanize&quot;&gt;WWW :: Mechanize&lt;/a&gt; 모듈을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a7852e983dc45b1c4fb37cf3f05367219e6ca843" translate="yes" xml:space="preserve">
          <source>If you need to do this check often, define your own macro like this:</source>
          <target state="translated">이 점검을 자주 수행해야하는 경우 다음과 같이 고유 한 매크로를 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="6466ffd2aaaebc3946b351828c459bde58bed891" translate="yes" xml:space="preserve">
          <source>If you need to include C code or C library interfaces use h2xs. h2xs will create the module distribution structure and the initial interface files. &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; and &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; explain the details.</source>
          <target state="translated">C 코드 또는 C 라이브러리 인터페이스를 포함해야하는 경우 h2x를 사용하십시오. h2xs는 모듈 배포 구조와 초기 인터페이스 파일을 만듭니다. &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; 및 &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; 가 세부 사항을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="132d01927536564513220be940287f0a7e0711cd" translate="yes" xml:space="preserve">
          <source>If you need to make sure your diagnostics are displayed in the correct order relative to test results you can use the &lt;code&gt;--merge&lt;/code&gt; option to merge the test scripts' STDERR into their STDOUT.</source>
          <target state="translated">진단 결과를 테스트 결과와 관련하여 올바른 순서로 표시해야하는 경우 &lt;code&gt;--merge&lt;/code&gt; 옵션을 사용하여 테스트 스크립트의 STDERR을 STDOUT에 병합 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f121bbe2a75e4529feda5970b07f0e59291a1000" translate="yes" xml:space="preserve">
          <source>If you need to pad with a character other than blank or zero you can use one of the following methods. They all generate a pad string with the &lt;code&gt;x&lt;/code&gt; operator and combine that with &lt;code&gt;$text&lt;/code&gt; . These methods do not truncate &lt;code&gt;$text&lt;/code&gt; .</source>
          <target state="translated">공백이나 0 이외의 문자로 채워야하는 경우 다음 방법 중 하나를 사용할 수 있습니다. 모두 &lt;code&gt;x&lt;/code&gt; 연산자 로 패드 문자열을 생성하고 &lt;code&gt;$text&lt;/code&gt; 와 결합 합니다 . 이 메소드는 &lt;code&gt;$text&lt;/code&gt; 자르지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5db19b81a16545df9a2691c134fe238aff01db6b" translate="yes" xml:space="preserve">
          <source>If you need to pass the handle to something that expects a filename then on a unix system you can use C for arbitrary programs. Perl code that uses the 2-argument version of C&amp;lt;&amp;lt; open &amp;gt;&amp;gt; can be passed C&amp;lt;&amp;lt; &quot;+&amp;lt;=&amp;amp;&quot; . fileno($fh) &amp;gt;&amp;gt;. Otherwise you will need to pass the filename. You will have to clear the close-on-exec bit on that file descriptor before passing it to another process.</source>
          <target state="translated">파일 이름이 필요한 것으로 핸들을 전달 해야하는 경우 유닉스 시스템에서 임의의 프로그램에 C를 사용할 수 있습니다. C &amp;lt;&amp;lt; open &amp;gt;&amp;gt;의 2 인수 버전을 사용하는 Perl 코드는 C &amp;lt;&amp;lt; &quot;+ &amp;lt;= &amp;amp;&quot;로 전달 될 수 있습니다. fileno ($ fh) &amp;gt;&amp;gt;. 그렇지 않으면 파일 이름을 전달해야합니다. 해당 파일 디스크립터에서 close-on-exec 비트를 지우고 다른 프로세스로 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="a1479a86a7c4f92b2a893038ca84d0e7634155ed" translate="yes" xml:space="preserve">
          <source>If you need to perform any preprocessing of input before it is parsed you may want to override one or more of &lt;b&gt;preprocess_line()&lt;/b&gt; and/or &lt;b&gt;preprocess_paragraph()&lt;/b&gt;.</source>
          <target state="translated">입력을 구문 분석하기 전에 사전 처리를 수행해야하는 경우 하나 이상의 &lt;b&gt;preprocess_line ()&lt;/b&gt; 및 / 또는 &lt;b&gt;preprocess_paragraph ()&lt;/b&gt; 를 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6fb6f27c51e4262718886f54bfa50ac616a6eb28" translate="yes" xml:space="preserve">
          <source>If you need to push multiple different values then you should either use the &lt;code&gt;(X)PUSHs&lt;/code&gt; macros, or else use the new &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m(X)PUSH[iunp]&lt;/a&gt;&lt;/code&gt; macros, none of which make use of &lt;code&gt;TARG&lt;/code&gt; . The &lt;code&gt;(X)PUSHs&lt;/code&gt; macros simply push an SV* on the stack, which, as noted under &lt;a href=&quot;#XSUBs-and-the-Argument-Stack&quot;&gt;XSUBs and the Argument Stack&lt;/a&gt;, will often need to be &quot;mortal&quot;. The new &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m(X)PUSH[iunp]&lt;/a&gt;&lt;/code&gt; macros make this a little easier to achieve by creating a new mortal for you (via &lt;code&gt;(X)PUSHmortal&lt;/code&gt;), pushing that onto the stack (extending it if necessary in the case of the &lt;code&gt;mXPUSH[iunp]&lt;/code&gt; macros), and then setting its value. Thus, instead of writing this to &quot;fix&quot; the example above:</source>
          <target state="translated">여러 다른 값을 밀어해야하는 경우 다음 중 하나를 사용한다 &lt;code&gt;(X)PUSHs&lt;/code&gt; 의 새로운 사용하는 다른 매크로를, 또는 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m(X)PUSH[iunp]&lt;/a&gt;&lt;/code&gt; 사용할 수 있도록 매크로, 어느 것도 &lt;code&gt;TARG&lt;/code&gt; 를 . &lt;code&gt;(X)PUSHs&lt;/code&gt; 매크로 단순히 밀어 SV에 *에서 언급 한 바와 같이, 스택에 &lt;a href=&quot;#XSUBs-and-the-Argument-Stack&quot;&gt;있는 XSUB 인수 스택&lt;/a&gt; , 종종 &quot;인간&quot;이 될 필요가있을 것이다. 새로운 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m(X)PUSH[iunp]&lt;/a&gt;&lt;/code&gt; 매크로를 사용하면 &lt;code&gt;(X)PUSHmortal&lt;/code&gt; 을 통해 새로운 필멸자를 만들어 스택으로 밀고 ( mXPUSH의 경우 필요에 따라 확장 &lt;code&gt;mXPUSH[iunp]&lt;/code&gt; macros)를 입력 한 다음 값을 설정하십시오. 따라서 위의 예제를 &quot;수정&quot;하기 위해 이것을 쓰는 대신 :</target>
        </trans-unit>
        <trans-unit id="b45e0c901cd619f7527093c4d9dc59b922de91c4" translate="yes" xml:space="preserve">
          <source>If you need to run code under taint mode, updating to the latest L&amp;lt;:spec&amp;gt; is highly recommended.</source>
          <target state="translated">테 인트 모드에서 코드를 실행해야하는 경우 최신 L &amp;lt;: spec&amp;gt;으로 업데이트하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0a26debdab35f4d9006770f7ff9dd97352bd60fc" translate="yes" xml:space="preserve">
          <source>If you need to set the encoding for STDIN, STDOUT, and STDERR, for example based on the user's locale, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; .</source>
          <target state="translated">예를 들어 사용자 로케일을 기반으로 STDIN, STDOUT 및 STDERR에 대한 인코딩을 설정해야하는 경우 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a6d6ae28c61f9ab4be958ec28b43ea876d12f0ac" translate="yes" xml:space="preserve">
          <source>If you need to sort on several fields, the following paradigm is useful.</source>
          <target state="translated">여러 필드를 정렬해야하는 경우 다음 패러다임이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="bcb30e833a46ba05085b508093073afbb52be3c6" translate="yes" xml:space="preserve">
          <source>If you need to use</source>
          <target state="translated">사용해야 할 경우</target>
        </trans-unit>
        <trans-unit id="dd52c7b44ac55aa77cc0e377ad21781b36b65218" translate="yes" xml:space="preserve">
          <source>If you need to use Perl in the ILE environment, you may want to consider using Qp2RunPase() to call the PASE version of Perl.</source>
          <target state="translated">ILE 환경에서 Perl을 사용해야하는 경우 Qp2RunPase ()를 사용하여 PASE 버전의 Perl을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4808d5e77c37aaf035853f43eef1fd731c05497" translate="yes" xml:space="preserve">
          <source>If you need to, your program can pass parameters to the subroutine as part of the thread startup. Just include the list of parameters as part of the &lt;code&gt;threads-&amp;gt;create()&lt;/code&gt; call, like this:</source>
          <target state="translated">필요한 경우 프로그램은 스레드 시작의 일부로 매개 변수를 서브 루틴에 전달할 수 있습니다. 다음과 같이 &lt;code&gt;threads-&amp;gt;create()&lt;/code&gt; 호출의 일부로 매개 변수 목록을 포함하십시오 .</target>
        </trans-unit>
        <trans-unit id="1710a33b911c663eb696834835df2f1e23df21c3" translate="yes" xml:space="preserve">
          <source>If you needed to know the length of the string in bytes, now's the perfect time for that. Because &lt;code&gt;$body&lt;/code&gt; is now a byte string, &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; will report the number of bytes, instead of the number of characters. The number of characters is no longer known, because characters only exist in text strings.</source>
          <target state="translated">문자열의 길이를 바이트 단위로 알아야 할 경우 이제는 완벽한 시간입니다. 때문에 &lt;code&gt;$body&lt;/code&gt; 바이트 문자열 지금, &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 대신 문자의 수, 바이트 수를보고합니다. 문자는 텍스트 문자열에만 존재하므로 문자 수는 더 이상 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="be13b7e49abdf9671c1c203318c86c5b390da880" translate="yes" xml:space="preserve">
          <source>If you now say</source>
          <target state="translated">지금 말하면</target>
        </trans-unit>
        <trans-unit id="4e07afe42e8e4906b74c8de7f97562b41c673c72" translate="yes" xml:space="preserve">
          <source>If you only have to do this once, you can print individually to each filehandle.</source>
          <target state="translated">이 작업을 한 번만 수행하면 각 파일 핸들에 개별적으로 인쇄 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef4f1155d60201a5a642377c105def023a28c8a3" translate="yes" xml:space="preserve">
          <source>If you open a pipe on the command &lt;code&gt;-&lt;/code&gt; (that is, specify either &lt;code&gt;|-&lt;/code&gt; or &lt;code&gt;-|&lt;/code&gt; with the one- or two-argument forms of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;), an implicit &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; is done, so &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; returns twice: in the parent process it returns the pid of the child process, and in the child process it returns (a defined) &lt;code&gt;0&lt;/code&gt; . Use &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined($pid)&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;//&lt;/code&gt; to determine whether the open was successful.</source>
          <target state="translated">명령에 파이프를 열 경우 &lt;code&gt;-&lt;/code&gt; (즉, 하나 지정 &lt;code&gt;|-&lt;/code&gt; 나 &lt;code&gt;-|&lt;/code&gt; 의 1 또는 2 인자 형태의 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; ) 암시, &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 완료, 그래서 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 두 번 반환 : 부모 프로세스에 반환 자식 프로세스의 pid, 자식 프로세스에서 (정의 된) &lt;code&gt;0&lt;/code&gt; 을 반환합니다 . 사용은 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined($pid)&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;//&lt;/code&gt; 오픈의 성공 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="3ae4797a620c0cf454989f9d7b82f21950740479" translate="yes" xml:space="preserve">
          <source>If you open a pipe on the command &lt;code&gt;-&lt;/code&gt; (that is, specify either &lt;code&gt;|-&lt;/code&gt; or &lt;code&gt;-|&lt;/code&gt; with the one- or two-argument forms of &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;), an implicit &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; is done, so &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; returns twice: in the parent process it returns the pid of the child process, and in the child process it returns (a defined) &lt;code&gt;0&lt;/code&gt; . Use &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined($pid)&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;//&lt;/code&gt; to determine whether the open was successful.</source>
          <target state="translated">명령에 파이프를 열 경우 &lt;code&gt;-&lt;/code&gt; (즉, 하나 지정 &lt;code&gt;|-&lt;/code&gt; 나 &lt;code&gt;-|&lt;/code&gt; 의 1 또는 2 인자 형태의 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; ) 암시, &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 완료, 그래서 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 두 번 반환 : 부모 프로세스에 반환 자식 프로세스의 pid, 자식 프로세스에서 (정의 된) &lt;code&gt;0&lt;/code&gt; 을 반환합니다 . 사용은 &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined($pid)&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;//&lt;/code&gt; 오픈의 성공 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="b60263df2e1568250aacc0155390b54bbc574b26" translate="yes" xml:space="preserve">
          <source>If you opted to uncomment &lt;code&gt;INST_VER&lt;/code&gt; and &lt;code&gt;INST_ARCH&lt;/code&gt; in the makefile then the installation structure is a little more complicated and you will need to add two new PATH components instead: &lt;code&gt;$INST_TOP\$INST_VER\bin&lt;/code&gt; and &lt;code&gt;$INST_TOP\$INST_VER\bin\$ARCHNAME&lt;/code&gt; , e.g.</source>
          <target state="translated">makefile에서 &lt;code&gt;INST_VER&lt;/code&gt; 및 &lt;code&gt;INST_ARCH&lt;/code&gt; 의 주석 처리 를 해제 한 경우 설치 구조가 약간 더 복잡하므로 대신 &lt;code&gt;$INST_TOP\$INST_VER\bin&lt;/code&gt; 및 &lt;code&gt;$INST_TOP\$INST_VER\bin\$ARCHNAME&lt;/code&gt; 두 가지 새 PATH 구성 요소를 추가해야합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="3281995d9866c6fc2125672694920f44e26bcb98" translate="yes" xml:space="preserve">
          <source>If you override this method, it should never throw an exception.</source>
          <target state="translated">이 메소드를 대체하면 예외가 발생하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="a202baf38183d44995c2fcf3449035cd37813ae8" translate="yes" xml:space="preserve">
          <source>If you pass a perl version you get the release date for that version only.</source>
          <target state="translated">펄 버전을 통과하면 해당 버전의 출시 날짜 만 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1538bf7a76ecb948f65bf6e3cd597e0fef6beddd" translate="yes" xml:space="preserve">
          <source>If you pass a version argument (value of &lt;code&gt;$]&lt;/code&gt; , like &lt;code&gt;5.00503&lt;/code&gt; or &lt;code&gt;5.008008&lt;/code&gt; ), you get a list of all the modules and their respective versions. (If you have the &lt;code&gt;version&lt;/code&gt; module, you can also use new-style version numbers, like &lt;code&gt;5.8.8&lt;/code&gt; .)</source>
          <target state="translated">&lt;code&gt;5.00503&lt;/code&gt; 또는 &lt;code&gt;5.008008&lt;/code&gt; 과 같은 버전 인수 ( &lt;code&gt;$]&lt;/code&gt; )를 전달하면 모든 모듈 및 해당 버전의 목록이 표시됩니다. ( &lt;code&gt;version&lt;/code&gt; 모듈 이있는 경우 &lt;code&gt;5.8.8&lt;/code&gt; 과 같은 새 스타일 버전 번호를 사용할 수도 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="93bac64f7444e2412e1719cee4ee931ff2c82b7b" translate="yes" xml:space="preserve">
          <source>If you pass the &lt;code&gt;-q&lt;/code&gt; option to the module, then the STDOUT filehandle will be redirected into the variable &lt;code&gt;$O::BEGIN_output&lt;/code&gt; during compilation. This has the effect that any output printed to STDOUT by BEGIN blocks or use'd modules will be stored in this variable rather than printed. It's useful with those backends which produce output themselves (&lt;code&gt;Deparse&lt;/code&gt; , &lt;code&gt;Concise&lt;/code&gt; etc), so that their output is not confused with that generated by the code being compiled.</source>
          <target state="translated">&lt;code&gt;-q&lt;/code&gt; 옵션을 모듈에 전달하면 STDOUT 파일 핸들이 컴파일 중 변수 &lt;code&gt;$O::BEGIN_output&lt;/code&gt; 재 지정됩니다 . 이는 BEGIN 블록 또는 사용 된 모듈에 의해 STDOUT에 인쇄 된 출력이 인쇄되지 않고이 변수에 저장됩니다. 출력 자체를 생성하는 백엔드 ( &lt;code&gt;Deparse&lt;/code&gt; , &lt;code&gt;Concise&lt;/code&gt; 등)에 유용 하므로 출력이 컴파일되는 코드에 의해 생성 된 출력과 혼동되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eb6ebb2e5d7084d0bbbc51b71dbc71d3b131a896" translate="yes" xml:space="preserve">
          <source>If you perform a new installation, then (a newer) Perl will be installed automatically. Pre-installed HP-UX systems now have more recent versions of Perl and the updated modules.</source>
          <target state="translated">새로 설치하면 (최신) Perl이 자동으로 설치됩니다. 사전 설치된 HP-UX 시스템에는 이제 최신 버전의 Perl 및 업데이트 된 모듈이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e9cb6c101da46aadecf5f8c5c109de4412a1005" translate="yes" xml:space="preserve">
          <source>If you pick the right test function, you'll usually get a good idea of what went wrong when it failed. But sometimes it doesn't work out that way. So here we have ways for you to write your own diagnostic messages which are safer than just &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt; STDERR&lt;/code&gt; .</source>
          <target state="translated">올바른 테스트 기능을 선택하면 일반적으로 실패했을 때 무엇이 ​​잘못되었는지 잘 알 수 있습니다. 그러나 때로는 그런 식으로 작동하지 않습니다. 따라서 여기에 &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt; STDERR&lt;/code&gt; &lt;a href=&quot;../functions/print&quot;&gt;인쇄&lt;/a&gt; 보다 안전한 자체 진단 메시지를 작성할 수있는 방법이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e1f8c3042df990d0caf7e15fec6410a8229928ec" translate="yes" xml:space="preserve">
          <source>If you plan on doing serious C hacking, make sure to read this.</source>
          <target state="translated">심각한 C 해킹을 계획하고 있다면 이것을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="ea674be45f6eda0998926e34d1adb1941baadfc8" translate="yes" xml:space="preserve">
          <source>If you plan to link Perl to any module that requires thread-support, like DBD::Oracle, it is better to use the _r version of the compiler. This will not build a threaded Perl, but a thread-enabled Perl. See also &lt;a href=&quot;#Threaded-Perl&quot;&gt;Threaded Perl&lt;/a&gt; later on.</source>
          <target state="translated">Perl을 DBD :: Oracle과 같이 스레드 지원이 필요한 모든 모듈에 링크하려는 경우 컴파일러의 _r 버전을 사용하는 것이 좋습니다. 이것은 스레드 된 Perl이 아니라 스레드 가능 Perl을 빌드합니다. 나중에 &lt;a href=&quot;#Threaded-Perl&quot;&gt;Threaded Perl&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a59862b4b635be40786928d6e580b97f5fccb229" translate="yes" xml:space="preserve">
          <source>If you prefer 'regex' over 'regexp' in this tutorial, you could use the following program to replace it:</source>
          <target state="translated">이 학습서에서 'regexp'보다 'regex'를 선호하는 경우 다음 프로그램을 사용하여이를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e975a86edf7cf3f2a85267ea19c5e7fb97348443" translate="yes" xml:space="preserve">
          <source>If you prefer &lt;code&gt;CPANPLUS&lt;/code&gt; , it's just as easy:</source>
          <target state="translated">&lt;code&gt;CPANPLUS&lt;/code&gt; 를 선호한다면 다음 과 같이 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="88b2286238e8c1ea0536c07d5d33ab84bc86bbaa" translate="yes" xml:space="preserve">
          <source>If you prefer not to import these routines into your namespace, you can call them as:</source>
          <target state="translated">이러한 루틴을 네임 스페이스로 가져 오지 않으려면 다음과 같이 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02b429d0fbb0524681e65be7d6f8ab7830a0723a" translate="yes" xml:space="preserve">
          <source>If you prefer something more legible, use the File::stat module (part of the standard distribution in version 5.004 and later):</source>
          <target state="translated">보다 읽기 쉬운 것을 선호하는 경우 File :: stat 모듈 (버전 5.004 이상의 표준 배포의 일부)을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f0813e4f27c28bf6e883076eecebd37913fd5b51" translate="yes" xml:space="preserve">
          <source>If you prefer to do it more in a programmerish style in one single process, something like this may better suit you:</source>
          <target state="translated">하나의 단일 프로세스에서 프로그래밍 방식으로 더 많은 작업을 수행하려는 경우 다음과 같은 것이 더 적합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec90d5c6994006bb5fd89f190c78b5cdc340ee30" translate="yes" xml:space="preserve">
          <source>If you prefer to run your program first and look at its problem afterwards, do this:</source>
          <target state="translated">프로그램을 먼저 실행하고 나중에 문제를 확인하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="3870b14accf24c65cf812dc3594ebf250f4f78e6" translate="yes" xml:space="preserve">
          <source>If you properly encode your strings for output, none of this is of your concern, and you can just &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; dumped data as always.</source>
          <target state="translated">출력을 위해 문자열을 올바르게 인코딩하면 걱정할 것이 없으며 항상 덤프 된 데이터를 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="065fd2bf37d0cb46e6971e495f8f9b0d94012ccb" translate="yes" xml:space="preserve">
          <source>If you provide a $name, that will be printed along with the &quot;ok/not ok&quot; to make it easier to find your test when if fails (just search for the name). It also makes it easier for the next guy to understand what your test is for. It's highly recommended you use test names.</source>
          <target state="translated">$ name을 제공하면 &quot;ok / not ok&quot;와 함께 인쇄되어 실패시 테스트를 쉽게 찾을 수 있습니다 (이름 만 검색). 또한 다음 사람이 테스트의 내용을 더 쉽게 이해할 수 있습니다. 테스트 이름을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b7880cf2049cee53a05bb2b9ece1c4d6f2c66f65" translate="yes" xml:space="preserve">
          <source>If you put a &lt;code&gt;\&lt;/code&gt; in front of a variable, you get a reference to that variable.</source>
          <target state="translated">변수 앞에 &lt;code&gt;\&lt;/code&gt; 를 넣으면 해당 변수에 대한 참조가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="34b57973357474bb06b6216c6a1396c52f47b8be" translate="yes" xml:space="preserve">
          <source>If you put extensions in unusual places, you can set PERL5LIB to a list of paths separated by semicolons where you want perl to look for libraries. Look for descriptions of other environment variables you can set in &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="translated">비정상적인 위치에 확장을 넣으면 PERL5LIB를 세미콜론으로 구분 된 경로 목록으로 설정하여 펄이 라이브러리를 찾도록 할 수 있습니다. &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; 에서 설정할 수있는 다른 환경 변수에 대한 설명을 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="4498166e1dac5738a547d2b9e86da7f11d00c4e8" translate="yes" xml:space="preserve">
          <source>If you put two contiguous tilde characters &quot;~~&quot; anywhere into a line, the line will be repeated until all the fields on the line are exhausted, i.e. undefined. For special (caret) text fields this will occur sooner or later, but if you use a text field of the at variety, the expression you supply had better not give the same value every time forever! (&lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift(@f)&lt;/a&gt;&lt;/code&gt; is a simple example that would work.) Don't use a regular (at) numeric field in such lines, because it will never go blank.</source>
          <target state="translated">두 줄의 연속 된 물결표 문자 &quot;~~&quot;를 줄의 아무 곳에 나 넣으면 줄의 모든 필드가 모두 소진 될 때까지 줄이 반복됩니다 (예 : 정의되지 않음). 특수 (캐럿) 텍스트 필드의 경우 조만간 발생하지만, 다양한 텍스트 필드를 사용하는 경우 제공하는 표현식이 매번 같은 값을 제공하지 않는 것이 좋습니다! ( &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift(@f)&lt;/a&gt;&lt;/code&gt; 는 작동하는 간단한 예입니다.) 이러한 행에 일반 (at) 숫자 필드를 사용하지 마십시오. 절대 공백이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a6608312c76270dd048459022213c207db61db43" translate="yes" xml:space="preserve">
          <source>If you really do mean it, explicitly numify your reference, like so: &lt;code&gt;$array[0+$ref]&lt;/code&gt; . This warning is not given for overloaded objects, however, because you can overload the numification and stringification operators and then you presumably know what you are doing.</source>
          <target state="translated">당신이 정말로 그것을 의미한다면, &lt;code&gt;$array[0+$ref]&lt;/code&gt; 처럼 당신의 참조를 명시 적으로 수치화하십시오 . 그러나 숫자 화 및 문자열 화 연산자를 오버로드 할 수 있고 현재 수행중인 작업을 알고 있기 때문에 오버로드 된 오브젝트에는이 경고가 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2e6ee3c0e5f77f2901d0e16f7c2a62b5dc496ad9" translate="yes" xml:space="preserve">
          <source>If you really need to see whether the change has been accepted simply examine the return value of C</source>
          <target state="translated">변경 사항이 수락되었는지 실제로 확인 해야하는 경우 C의 반환 값을 검사하십시오.</target>
        </trans-unit>
        <trans-unit id="dd150284dfc14b1b33a794d882418a56b32b28b6" translate="yes" xml:space="preserve">
          <source>If you really want a subroutine with a &lt;code&gt;()&lt;/code&gt; prototype that returns a lexical variable you can easily force it to not be inlined by adding an explicit &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">어휘 변수를 리턴 하는 &lt;code&gt;()&lt;/code&gt; 프로토 타입을 가진 서브 루틴을 실제로 원한다면 명시적인 &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 을 추가하여 쉽게 인라인되지 않도록 강제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f0166a5725d2770573e3a305750b9dd3edf5c05f" translate="yes" xml:space="preserve">
          <source>If you really want comments, build your list the old-fashioned way, with quotes and commas:</source>
          <target state="translated">의견을 정말로 원한다면 따옴표와 쉼표로 구식 방식으로 목록을 만드십시오.</target>
        </trans-unit>
        <trans-unit id="eb99b666d9e169ba81737784680da343f375dd69" translate="yes" xml:space="preserve">
          <source>If you really want just plain byte strings, use my_snprintf() and my_vsnprintf() instead, which will try to use snprintf() and vsnprintf() if those safer APIs are available. If you want something fancier than a plain byte string, use &lt;a href=&quot;perlapi#form&quot;&gt;Perl_form ()&lt;/a&gt; or SVs and &lt;a href=&quot;perlapi#sv_catpvf&quot;&gt;Perl_sv_catpvf() &lt;/a&gt;.</source>
          <target state="translated">실제로 일반 바이트 문자열 만 원한다면 my_snprintf () 및 my_vsnprintf ()를 대신 사용하십시오. 안전한 API를 사용할 수 있으면 snprintf () 및 vsnprintf ()를 사용하려고합니다. 일반 바이트 문자열보다 더 멋진 것을 원한다면 &lt;a href=&quot;perlapi#form&quot;&gt;Perl_form ()&lt;/a&gt; 또는 SV 및 &lt;a href=&quot;perlapi#sv_catpvf&quot;&gt;Perl_sv_catpvf ()를 사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1c2d9e52e0617d90849665511b4fb2b333643750" translate="yes" xml:space="preserve">
          <source>If you really want to be international, you should consider Unicode. See &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt; and &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; for more information.</source>
          <target state="translated">실제로 국제적이기를 원한다면 유니 코드를 고려해야합니다. 자세한 정보는 &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt; 및 &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7a1586770541996a5a05c7da504fe6b4a6bdef4c" translate="yes" xml:space="preserve">
          <source>If you really want to do this, you can use &lt;code&gt;ExtUtils::Manifest::manifind()&lt;/code&gt; to read the MANIFEST and File::Find to delete the files. But you have to be careful. Here's a script to do that. Use at your own risk. Have fun blowing holes in your foot.</source>
          <target state="translated">&lt;code&gt;ExtUtils::Manifest::manifind()&lt;/code&gt; 작업을 수행하려면 ExtUtils :: Manifest :: manifind () 를 사용하여 MANIFEST 및 File :: Find를 읽고 파일을 삭제하십시오. 그러나 조심해야합니다. 이를 수행하는 스크립트는 다음과 같습니다. 자신의 책임하에 사용하십시오. 발에 구멍을 뚫는 재미를 즐기십시오.</target>
        </trans-unit>
        <trans-unit id="bd0128791efed65e3bbb8d082044be49dfce046e" translate="yes" xml:space="preserve">
          <source>If you really want to, you can use the standard open2() from the &lt;code&gt;IPC::Open2&lt;/code&gt; module to catch both ends. There's also an open3() in &lt;code&gt;IPC::Open3&lt;/code&gt; for tridirectional I/O so you can also catch your child's STDERR, but doing so would then require an awkward select() loop and wouldn't allow you to use normal Perl input operations.</source>
          <target state="translated">정말로 원한다면 &lt;code&gt;IPC::Open2&lt;/code&gt; 모듈 의 표준 open2 ()를 사용하여 양쪽 끝을 잡을 수 있습니다. &lt;code&gt;IPC::Open3&lt;/code&gt; 에는 3 방향 I / O를위한 open3 () 도 있으므로 자녀의 STDERR을 잡을 수도 있지만 어색한 select () 루프가 필요하며 일반적인 Perl 입력 작업을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="53be29d9aa606768bcbe9e3309afe9ba5b57da03" translate="yes" xml:space="preserve">
          <source>If you recognized the quote about the Road above, you're in luck.</source>
          <target state="translated">위의 도로에 대한 인용문을 알고 있다면 운이 좋을 것입니다.</target>
        </trans-unit>
        <trans-unit id="39a2ad311b79ed3072c37af199bf41f9f9aebf15" translate="yes" xml:space="preserve">
          <source>If you redefine a subroutine that was eligible for inlining, you'll get a warning by default. You can use this warning to tell whether or not a particular subroutine is considered inlinable, since it's different than the warning for overriding non-inlined subroutines:</source>
          <target state="translated">인라인 할 수있는 서브 루틴을 재정의하면 기본적으로 경고가 표시됩니다. 이 경고를 사용하여 특정 서브 루틴이 인라인 불가능한 것으로 간주되는지 여부를 알 수 있습니다. 인라인되지 않은 서브 루틴을 재정의하는 경고와 다르기 때문에 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="432e76406abd8db96136b5a2df1a568bbdde9d3f" translate="yes" xml:space="preserve">
          <source>If you resize the array with deferred writing enabled, the file will be resized immediately, but deferred records will not be written. This has a surprising consequence: &lt;code&gt;@a = (...)&lt;/code&gt; erases the file immediately, but the writing of the actual data is deferred. This might be a bug. If it is a bug, it will be fixed in a future version.</source>
          <target state="translated">지연 쓰기가 활성화 된 상태에서 배열의 크기를 조정하면 파일 크기가 즉시 조정되지만 지연된 레코드는 기록되지 않습니다. : 이것은 놀라운 결과가 &lt;code&gt;@a = (...)&lt;/code&gt; 즉시 파일을 삭제하고 있지만 실제 데이터의 쓰기 지연됩니다. 이것은 버그 일 수 있습니다. 버그 인 경우 향후 버전에서 수정 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="b95da308b81d0840cacd6821e3c3f91e04b82e8a" translate="yes" xml:space="preserve">
          <source>If you run Perl with the &lt;b&gt;-w&lt;/b&gt; switch it can warn you about this. For example, the third line above produces:</source>
          <target state="translated">&lt;b&gt;-w&lt;/b&gt; 스위치 와 함께 Perl을 실행 하면 이에 대해 경고 할 수 있습니다. 예를 들어 위의 세 번째 줄은 다음을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="1983e4f73a942cb1a7c7741631cd3c3e344c8e03" translate="yes" xml:space="preserve">
          <source>If you run the script with the &lt;code&gt;-w&lt;/code&gt; flag the error message becomes:</source>
          <target state="translated">&lt;code&gt;-w&lt;/code&gt; 플래그 와 함께 스크립트를 실행하면 오류 메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="a9ad6a9bb0a2be45f4030cad900647a4bc2c1db1" translate="yes" xml:space="preserve">
          <source>If you run this code twice, the contents of the</source>
          <target state="translated">이 코드를 두 번 실행하면</target>
        </trans-unit>
        <trans-unit id="80dfce6f2a878c8f488ddf11e051d8fa78b7f75e" translate="yes" xml:space="preserve">
          <source>If you run your program with the &lt;code&gt;-w&lt;/code&gt; switch, or if you use the &lt;code&gt;warnings&lt;/code&gt; pragma, File::Find will report warnings for several weird situations. You can disable these warnings by putting the statement</source>
          <target state="translated">&lt;code&gt;-w&lt;/code&gt; 스위치를 사용 하여 프로그램을 실행 하거나 &lt;code&gt;warnings&lt;/code&gt; pragma 를 사용하면 File :: Find가 몇 가지 이상한 상황에 대한 경고를보고합니다. 당신은 진술을 넣어 이러한 경고를 비활성화 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="84e83e7869cb30f17fc9ab2b3dafef8f917abf86" translate="yes" xml:space="preserve">
          <source>If you say yes to the following question, CPAN will try to store enough information about the build process so that it can pick up in future sessions at the same state of affairs as it left a previous session.</source>
          <target state="translated">다음 질문에 예라고 대답하면 CPAN은 빌드 프로세스에 대한 충분한 정보를 저장하여 이전 세션을 종료 한 것과 동일한 상태의 미래 세션에서 픽업 할 수 있도록 시도합니다.</target>
        </trans-unit>
        <trans-unit id="3a116108872049154f6c27d6353e551d6d6917b4" translate="yes" xml:space="preserve">
          <source>If you see &quot;bad interpreter - no such file or directory&quot;, the first line in your perl script (the &quot;shebang&quot; line) does not contain the right path to perl (or any other program capable of running scripts). Sometimes this happens when you move the script from one machine to another and each machine has a different path to perl--/usr/bin/perl versus /usr/local/bin/perl for instance. It may also indicate that the source machine has CRLF line terminators and the destination machine has LF only: the shell tries to find /usr/bin/perl&amp;lt;CR&amp;gt;, but can't.</source>
          <target state="translated">&quot;잘못된 인터프리터-해당 파일이나 디렉토리가 없음&quot;이 표시되면 perl 스크립트의 첫 번째 행 ( &quot;shebang&quot;행)에 perl의 올바른 경로 (또는 스크립트를 실행할 수있는 다른 프로그램)가 포함되어 있지 않습니다. 한 시스템에서 다른 시스템으로 스크립트를 이동하고 각 시스템마다 perl-/ usr / bin / perl 대 / usr / local / bin / perl에 대한 다른 경로가있는 경우 이러한 상황이 발생합니다. 또한 소스 시스템에 CRLF 회선 종결자가 있고 대상 시스템에 LF 만 있음을 나타낼 수도 있습니다. 쉘은 / usr / bin / perl &amp;lt;CR&amp;gt;을 찾으려고하지만 실패합니다.</target>
        </trans-unit>
        <trans-unit id="2f85a9726440183decd897c1fff5988cce63ccf9" translate="yes" xml:space="preserve">
          <source>If you see &quot;bad interpreter: Permission denied&quot;, you need to make your script executable.</source>
          <target state="translated">&quot;잘못된 인터프리터 : 권한 거부&quot;가 표시되면 스크립트를 실행 가능하게 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="8de6b12e8e3d869536fad39850a1db08fd9bac7f" translate="yes" xml:space="preserve">
          <source>If you see in a debugger a memory area mysteriously full of 0xABABABAB or 0xEFEFEFEF, you may be seeing the effect of the Poison() macros, see &lt;a href=&quot;perlclib&quot;&gt;perlclib&lt;/a&gt;.</source>
          <target state="translated">디버거에서 메모리 영역에 신비하게 0xABABABAB 또는 0xEFEFEFEF가 가득 찬 경우 Poison () 매크로의 효과를 볼 수 있습니다 ( &lt;a href=&quot;perlclib&quot;&gt;perlclib&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="8d3df616229a0ebfcb7922d24bec233001d332f4" translate="yes" xml:space="preserve">
          <source>If you see right after &quot;make&quot; this</source>
          <target state="translated">&quot;만들기&quot;직후에 보이면</target>
        </trans-unit>
        <trans-unit id="d8e7a131ddc6c256b7162ac7f1766e22fd038d65" translate="yes" xml:space="preserve">
          <source>If you see that you're leaking memory at runtime, but neither valgrind nor &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt; will find anything, you're probably leaking SVs that are still reachable and will be properly cleaned up during destruction of the interpreter. In such cases, using the &lt;code&gt;-Dm&lt;/code&gt; switch can point you to the source of the leak. If the executable was built with &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt; , &lt;code&gt;-Dm&lt;/code&gt; will output SV allocations in addition to memory allocations. Each SV allocation has a distinct serial number that will be written on creation and destruction of the SV. So if you're executing the leaking code in a loop, you need to look for SVs that are created, but never destroyed between each cycle. If such an SV is found, set a conditional breakpoint within &lt;code&gt;new_SV()&lt;/code&gt; and make it break only when &lt;code&gt;PL_sv_serial&lt;/code&gt; is equal to the serial number of the leaking SV. Then you will catch the interpreter in exactly the state where the leaking SV is allocated, which is sufficient in many cases to find the source of the leak.</source>
          <target state="translated">런타임에 메모리 누수가 발생하지만 &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt; 나 -DDEBUG_LEAKING_SCALARS 가 아무것도 찾지 못하는 경우, 여전히 도달 할 수 있고 인터프리터가 파괴되는 동안 올바르게 정리 된 SV가 누출 될 수 있습니다. 이러한 경우 &lt;code&gt;-Dm&lt;/code&gt; 스위치를 사용 하면 누출의 원인을 가리킬 수 있습니다. 실행 파일이 내장되어있는 경우 &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt; , &lt;code&gt;-Dm&lt;/code&gt; 메모리 할당 외에도 SV 할당을 출력합니다. 각 SV 할당에는 SV 생성 및 삭제시 기록 될 고유 한 일련 번호가 있습니다. 따라서 누수 코드를 루프에서 실행하는 경우 생성되었지만 각주기 사이에 절대로 파괴되지 않는 SV를 찾아야합니다. 이러한 SV가 발견되면 &lt;code&gt;new_SV()&lt;/code&gt; 내에 조건부 중단 점을 설정하고 &lt;code&gt;PL_sv_serial&lt;/code&gt; 이 누출하는 SV의 일련 번호와 동일한 경우에만 중단 하십시오. 그런 다음 누출 SV가 할당 된 상태에서 통역사를 정확하게 파악할 수 있습니다. 이는 누출의 원인을 찾기에 충분합니다.</target>
        </trans-unit>
        <trans-unit id="2bbf4110deb94dbc624ccee947cca19c596a9010" translate="yes" xml:space="preserve">
          <source>If you see this</source>
          <target state="translated">이걸 보면</target>
        </trans-unit>
        <trans-unit id="4203dc6863ea2ff3c77a2428ddc46eaf1f7849d3" translate="yes" xml:space="preserve">
          <source>If you set &lt;code&gt;$DB::single&lt;/code&gt; to 2, it's equivalent to having just typed the &lt;code&gt;n&lt;/code&gt; command, whereas a value of 1 means the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; command. The &lt;code&gt;$DB::trace&lt;/code&gt; variable should be set to 1 to simulate having typed the &lt;code&gt;t&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;$DB::single&lt;/code&gt; 을 2로 설정 하면 &lt;code&gt;n&lt;/code&gt; 명령을 입력 한 것과 동일 하지만 값 1은 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 명령을 의미합니다 . &lt;code&gt;$DB::trace&lt;/code&gt; 변수는 입력 한 시뮬레이션 1로 설정해야합니다 &lt;code&gt;t&lt;/code&gt; 의 명령을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a5d30ba8967fd6c8924240ee40d5a140a986b280" translate="yes" xml:space="preserve">
          <source>If you set a value for this attribute, the value is expected to be an object (probably of a class that you define) that has a &lt;code&gt;reach&lt;/code&gt; method and a &lt;code&gt;done&lt;/code&gt; method. This is meant for reporting progress during the search, if you don't want to use a simple callback.</source>
          <target state="translated">이 속성에 대한 값을 설정하면 값은 &lt;code&gt;reach&lt;/code&gt; 메소드와 &lt;code&gt;done&lt;/code&gt; 메소드 가있는 오브젝트 (아마도 정의한 클래스) 일 것으로 예상됩니다 . 간단한 콜백을 사용하지 않으려는 경우 검색 중 진행률을보고하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="bcde195e379d8e8445763e6616418aa0a7c91d66" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;parse_characters&lt;/code&gt; option to a true value the parser will expect characters rather than octets; will ignore any &lt;code&gt;=encoding&lt;/code&gt; ; and will make no attempt to decode the input.</source>
          <target state="translated">당신은 설정하면 &lt;code&gt;parse_characters&lt;/code&gt; 의 파서가 문자가 아닌 옥텟 이상을 기대하는 진정한 가치에 대한 옵션을; &lt;code&gt;=encoding&lt;/code&gt; 을 무시합니다 . 입력을 해독하려고 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="24318749936760c8c43beac827cb9d11fbd59672" translate="yes" xml:space="preserve">
          <source>If you set this attribute to a true value, it will send reports of parsing errors to STDERR. By default, this attribute's value is false, meaning that no output is sent to STDERR.</source>
          <target state="translated">이 속성을 true로 설정하면 구문 분석 오류 보고서가 STDERR로 전송됩니다. 기본적으로이 속성 값은 false이며 STDERR로 출력이 전송되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b5b8252659bce51d0b80d2e62f37a533a1cac341" translate="yes" xml:space="preserve">
          <source>If you set this attribute to a true value, you will stop the parser from generating a &quot;POD ERRORS&quot; section at the end of the document. By default, this attribute's value is false, meaning that an errata section will be generated, as necessary.</source>
          <target state="translated">이 속성을 true로 설정하면 구문 분석기가 문서 끝에 &quot;POD ERRORS&quot;섹션을 생성하지 못하게됩니다. 기본적으로이 속성의 값은 false이며, 필요에 따라 에라타 섹션이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="551f3a0a87736ea2dc54ed40fd31f1fb500e9541" translate="yes" xml:space="preserve">
          <source>If you set this attribute to a true value, you will suppress the parser's complaints about irregularities in the Pod coding. By default, this attribute's value is false, meaning that irregularities will be reported.</source>
          <target state="translated">이 속성을 true 값으로 설정하면 포드 코딩의 불규칙성에 대한 파서의 불만이 억제됩니다. 기본적으로이 속성 값은 false이므로 불규칙성이보고됩니다.</target>
        </trans-unit>
        <trans-unit id="e0f5cb1c277b98516d80bdfac1209f73af95fdc5" translate="yes" xml:space="preserve">
          <source>If you set this flag, all keys passed in the following manner:</source>
          <target state="translated">이 플래그를 설정하면 모든 키가 다음 방식으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="90adec0aabd8555567c00e54faf42cc1c5fd95da" translate="yes" xml:space="preserve">
          <source>If you set this flag, unknown options will still be present in the return value, rather than filtered out. This is useful if your subroutine is only interested in a few arguments, and wants to pass the rest on blindly to perhaps another subroutine.</source>
          <target state="translated">이 플래그를 설정하면 알 수없는 옵션이 필터링되지 않고 리턴 값에 계속 존재합니다. 서브 루틴이 몇 가지 인수에만 관심이 있고 나머지 서브 루틴에 맹목적으로 전달하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="71c1c224b5079dff6437c4c296c3882a0dbe0842" translate="yes" xml:space="preserve">
          <source>If you set this value to 0, these processes will wait forever. This is the default and recommended setting.</source>
          <target state="translated">이 값을 0으로 설정하면 이러한 프로세스는 영원히 대기합니다. 이것이 기본 및 권장 설정입니다.</target>
        </trans-unit>
        <trans-unit id="57bb7a66b14f683a002bf6e9ed419bdbfaba4540" translate="yes" xml:space="preserve">
          <source>If you simply need to check quickly to see if a module is available, you can check for its documentation. If you can read the documentation the module is most likely installed. If you cannot read the documentation, the module might not have any (in rare cases):</source>
          <target state="translated">사용 가능한 모듈이 있는지 신속하게 확인해야하는 경우 해당 설명서를 확인할 수 있습니다. 설명서를 읽을 수 있으면 모듈이 설치되었을 가능성이 큽니다. 설명서를 읽을 수없는 경우 모듈에 다음이없는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8217a1604a7e6dedea6a0a5e3eee8fea23c61b15" translate="yes" xml:space="preserve">
          <source>If you simply want &lt;code&gt;TAP::Parser&lt;/code&gt; to handle a new source of TAP you probably don't need to subclass &lt;code&gt;TAP::Parser&lt;/code&gt; itself. Rather, you'll need to create a new &lt;a href=&quot;parser/sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt; class, and just plug it into the parser using the</source>
          <target state="translated">당신은 단순히 원하는 경우 &lt;code&gt;TAP::Parser&lt;/code&gt; TAP의 새로운 소스를 처리하기 위해 당신은 아마 서브 클래스에 필요하지 않습니다 &lt;code&gt;TAP::Parser&lt;/code&gt; 그 자체. 오히려 새로운 &lt;a href=&quot;parser/sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt; 클래스 를 생성하고 이를 사용하여 파서에 꽂기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="bccc23097030849c37e4990da975ad564b128d6e" translate="yes" xml:space="preserve">
          <source>If you simply want to check that a variable contains an object reference, we recommend that you use &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; blessed($object)&lt;/code&gt; , since &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; returns true values for all references, not just objects.</source>
          <target state="translated">변수에 객체 참조가 포함되어 있는지 확인하려는 경우 &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 는 객체뿐만 아니라 모든 참조에 대해 true 값을 반환 하므로 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; blessed($object)&lt;/code&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="538504cf71c29fca71496cb30f3e2c1293640623" translate="yes" xml:space="preserve">
          <source>If you simply want to do a little tweaking of how the tests behave, you can access the underlying &lt;a href=&quot;builder&quot;&gt;Test::Builder&lt;/a&gt; object like so:</source>
          <target state="translated">테스트의 작동 방식을 약간 조정하려는 경우 기본 &lt;a href=&quot;builder&quot;&gt;Test :: Builder&lt;/a&gt; 객체에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e8d0959c4e3749a28ef9e062bf2ea64f531c9a4d" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;'&amp;lt;&amp;amp;=X'&lt;/code&gt; , where &lt;code&gt;X&lt;/code&gt; is a file descriptor number or a filehandle, then Perl will do an equivalent of C's &lt;code&gt;fdopen&lt;/code&gt; of that file descriptor (and not call &lt;code&gt;dup(2)&lt;/code&gt; ); this is more parsimonious of file descriptors. For example:</source>
          <target state="translated">&lt;code&gt;'&amp;lt;&amp;amp;=X'&lt;/code&gt; 를 지정하면 ( 여기서 &lt;code&gt;X&lt;/code&gt; 는 파일 디스크립터 번호 또는 파일 핸들 인 경우) Perl은 해당 파일 디스크립터 의 C의 &lt;code&gt;fdopen&lt;/code&gt; 과 동등한 작업을 수행합니다 ( &lt;code&gt;dup(2)&lt;/code&gt; 호출하지 않음 ). 이것은 파일 디스크립터에 대해 더 냉담합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="180f2fd51c0d498482504f1f96654a60c731b6ff" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;NUM_USES&lt;/code&gt; with an argument of</source>
          <target state="translated">인수가 &lt;code&gt;NUM_USES&lt;/code&gt; 인 경우</target>
        </trans-unit>
        <trans-unit id="8d4306b9666c2a3ba16744fba22e147888a1f901" translate="yes" xml:space="preserve">
          <source>If you specify COMPRESS, then SUFFIX should also be altered, as it is needed to tell make the target file of the compression. Setting DIST_CP to ln can be useful, if you need to preserve the timestamps on your files. DIST_CP can take the values 'cp', which copies the file, 'ln', which links the file, and 'best' which copies symbolic links and links the rest. Default is 'best'.</source>
          <target state="translated">COMPRESS를 지정하면 압축 대상 파일을 작성하는 데 필요하므로 SUFFIX도 변경해야합니다. 파일의 타임 스탬프를 유지해야하는 경우 DIST_CP를 ln으로 설정하면 유용 할 수 있습니다. DIST_CP는 파일을 복사하는 'cp', 파일을 링크하는 'ln'및 기호 링크를 복사하고 나머지를 링크하는 'best'값을 사용할 수 있습니다. 기본값은 '최고'입니다.</target>
        </trans-unit>
        <trans-unit id="fc451ad5db1446b8366614b6922be5421ce289a8" translate="yes" xml:space="preserve">
          <source>If you specify LIB or any INSTALL* variables they will not be affected by the PREFIX.</source>
          <target state="translated">LIB 또는 INSTALL * 변수를 지정하면 PREFIX의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9241abdeaef157dc233bd737d1c5964fbf4c453e" translate="yes" xml:space="preserve">
          <source>If you specify both arguments, data will be discarded from the cache when either expiration condition holds.</source>
          <target state="translated">두 인수를 모두 지정하면 만기 조건이 유지 될 때 캐시에서 데이터가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="ec224c3d56f48a286860fa26eb84c5ac4d399f4c" translate="yes" xml:space="preserve">
          <source>If you start with bullets or numbers, stick with them, as formatters use the first &quot;=item&quot; type to decide how to format the list.</source>
          <target state="translated">글 머리 기호 또는 숫자로 시작하는 경우 포맷터가 첫 번째 &quot;= item&quot;유형을 사용하여 목록의 형식을 지정하는 방식을 따르십시오.</target>
        </trans-unit>
        <trans-unit id="583108dc3c7ca5413e3c465d6f2c5b41f57d07b1" translate="yes" xml:space="preserve">
          <source>If you still need a different solution, try to develop another subroutine that fits your needs and submit the diffs to &lt;code&gt;makemaker@perl.org&lt;/code&gt;</source>
          <target state="translated">여전히 다른 솔루션이 필요한 경우 필요에 맞는 다른 서브 루틴을 개발하고 diff를 &lt;code&gt;makemaker@perl.org&lt;/code&gt; 에 제출하십시오.</target>
        </trans-unit>
        <trans-unit id="a47b80b17f146bdd2f697c181154024073445f0f" translate="yes" xml:space="preserve">
          <source>If you still need commercial support &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.activestate.com%2factiveperl&quot;&gt;ActiveState&lt;/a&gt; offers this.</source>
          <target state="translated">여전히 상업적 지원 이 필요한 경우 &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.activestate.com%2factiveperl&quot;&gt;ActiveState가&lt;/a&gt; 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5b1b0c04cf56825c214a1e0c17a804ce5039d636" translate="yes" xml:space="preserve">
          <source>If you supply a code reference the subroutine will be called once for each line of output with the line as its only argument. Passed lines will have no trailing newline.</source>
          <target state="translated">코드 참조를 제공하면 서브 루틴은 각 출력 라인에 대해 한 번만 호출되며 라인을 유일한 인수로 사용합니다. 통과 한 줄에는 줄 바꿈이 없습니다.</target>
        </trans-unit>
        <trans-unit id="9c870447a33109e08d6ac4807e8b39152cd8060a" translate="yes" xml:space="preserve">
          <source>If you supply a function name with &lt;code&gt;INSTALL&lt;/code&gt; , memoize will install the new, memoized version of the function under the name you give. For example,</source>
          <target state="translated">&lt;code&gt;INSTALL&lt;/code&gt; 으로 함수 이름을 제공하면 , memoize는 사용자가 지정한 이름으로 새 버전의 함수를 설치합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="f6165205f1f599d384067c9f25ff1f7dd1d17430" translate="yes" xml:space="preserve">
          <source>If you supply data which is not valid (month 27, second 1,000) the results will be unpredictable (so don't do that).</source>
          <target state="translated">유효하지 않은 데이터를 제공하면 (27, 둘째 1,000) 결과를 예측할 수 없습니다 (그렇게하지 마십시오).</target>
        </trans-unit>
        <trans-unit id="f2f171e34560b51f24a2295b658a384f71202d5b" translate="yes" xml:space="preserve">
          <source>If you think geographically the</source>
          <target state="translated">지리적으로 생각하면</target>
        </trans-unit>
        <trans-unit id="50a6625675c788b39661b9a604d74414a739f593" translate="yes" xml:space="preserve">
          <source>If you think that you want to add a new command to Pod (like, say, a &quot;=biblio&quot; command), consider whether you could get the same effect with a for or begin/end sequence: &quot;=for biblio ...&quot; or &quot;=begin biblio&quot; ... &quot;=end biblio&quot;. Pod processors that don't understand &quot;=for biblio&quot;, etc, will simply ignore it, whereas they may complain loudly if they see &quot;=biblio&quot;.</source>
          <target state="translated">Pod에 새 명령 (예 : &quot;= biblio&quot;명령)을 추가하려는 경우 for 또는 begin / end 시퀀스를 사용하여 동일한 효과를 얻을 수 있는지 고려하십시오. &quot;= biblio ... &quot;또는&quot;= biblio 시작 &quot;...&quot;= biblio 종료 &quot;. &quot;= biblio&quot;등을 이해하지 못하는 포드 프로세서는 간단히 무시하지만 &quot;= biblio&quot;가 표시되면 크게 불평 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0dc7def89e2edc18a212cddb050ecfe26b36c107" translate="yes" xml:space="preserve">
          <source>If you trust the archive, or have other reasons to allow the archive to write files outside your current working directory, set this variable to &lt;code&gt;true&lt;/code&gt; .</source>
          <target state="translated">아카이브를 신뢰하거나 아카이브가 현재 작업 디렉토리 외부에 파일을 쓸 수있는 다른 이유가있는 경우이 변수를 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="c6aec72dc70a1ee4a43ad060e5bdfa6e98825b4f" translate="yes" xml:space="preserve">
          <source>If you try &lt;code&gt;Moose&lt;/code&gt; and find that one of these issues is preventing you from using &lt;code&gt;Moose&lt;/code&gt; , we encourage you to consider &lt;a href=&quot;http://search.cpan.org/perldoc/Moo&quot;&gt;Moo&lt;/a&gt; next. &lt;code&gt;Moo&lt;/code&gt; implements a subset of &lt;code&gt;Moose&lt;/code&gt; 's functionality in a simpler package. For most features that it does implement, the end-user API is</source>
          <target state="translated">&lt;code&gt;Moose&lt;/code&gt; 를 시도 하고 이러한 문제 중 하나가 &lt;code&gt;Moose&lt;/code&gt; 사용을 방해하는 것으로 판명 되면 다음에 &lt;a href=&quot;http://search.cpan.org/perldoc/Moo&quot;&gt;Moo&lt;/a&gt; 를 고려하는 것이 좋습니다 . &lt;code&gt;Moo&lt;/code&gt; 는 간단한 패키지 로 &lt;code&gt;Moose&lt;/code&gt; 기능 의 하위 세트를 구현 합니다. 구현하는 대부분의 기능에서 최종 사용자 API는</target>
        </trans-unit>
        <trans-unit id="ce64d2eb6b26fca2ba64557ff812899e21e2cf8b" translate="yes" xml:space="preserve">
          <source>If you try to add a file to @INC as follows:</source>
          <target state="translated">다음과 같이 @INC에 파일을 추가하려고하면 :</target>
        </trans-unit>
        <trans-unit id="e1047e2245ed732ddd158d44ef63171c1040f4d7" translate="yes" xml:space="preserve">
          <source>If you try to dereference the key, it won't do a hard dereference, and you won't accomplish what you're attempting. You might want to do something more like</source>
          <target state="translated">키를 역 참조하려고하면 강제 역 참조를 수행하지 않으며 시도중인 작업을 수행하지 못합니다. 더 비슷한 것을하고 싶을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b64e549b9d0f70c710cd7ee8a843df08eb7e123c" translate="yes" xml:space="preserve">
          <source>If you try to do something insecure, you will get a fatal error saying something like &quot;Insecure dependency&quot; or &quot;Insecure $ENV{PATH}&quot;.</source>
          <target state="translated">안전하지 않은 작업을 시도하면 &quot;안전하지 않은 종속성&quot;또는 &quot;안전하지 않은 $ ENV {PATH}&quot;와 같은 치명적인 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="baaf467929bddd8fa5b7aa6c26404c219da0153b" translate="yes" xml:space="preserve">
          <source>If you try to do the same thing with what you think is a list, you get a quite different result. Although it looks like you have a list on the righthand side, Perl actually sees a bunch of scalars separated by a comma:</source>
          <target state="translated">당신이 목록이라고 생각하는 것과 똑같은 일을하려고한다면, 상당히 다른 결과를 얻게됩니다. 오른쪽에 목록이있는 것처럼 보이지만 Perl은 실제로 쉼표로 구분 된 스칼라 무리를 봅니다.</target>
        </trans-unit>
        <trans-unit id="e39b81693bb33881d5354ed40ab1aa5e5e421f38" translate="yes" xml:space="preserve">
          <source>If you try to import an unimplemented function in the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement it will fail at compile time.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 문 에서 구현되지 않은 함수를 가져 오려고하면 컴파일시 실패합니다.</target>
        </trans-unit>
        <trans-unit id="ce84b9139b9e943d624385f2da9d34f42bd6117a" translate="yes" xml:space="preserve">
          <source>If you try to read from the child's stdout writer and their stderr writer, you'll have problems with blocking, which means you'll want to use select() or the IO::Select, which means you'd best use sysread() instead of readline() for normal stuff.</source>
          <target state="translated">자식의 stdout writer와 stderr writer에서 읽으려고하면 차단에 문제가 생겨 select () 또는 IO :: Select를 사용해야합니다. 이는 sysread ( 일반 항목의 경우 readline () 대신).</target>
        </trans-unit>
        <trans-unit id="8629095d12898edeef813ea5adb0d8466406ccc7" translate="yes" xml:space="preserve">
          <source>If you try to use a reference like a string, you get strings like</source>
          <target state="translated">문자열과 같은 참조를 사용하려고하면 다음과 같은 문자열이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="39dd9c9407d1478c40154f713c3d3db1f745db97" translate="yes" xml:space="preserve">
          <source>If you try to use an alphanumeric sequence in a prototype you will generate an optional warning - &quot;Illegal character in prototype...&quot;. Unfortunately earlier versions of Perl allowed the prototype to be used as long as its prefix was a valid prototype. The warning may be upgraded to a fatal error in a future version of Perl once the majority of offending code is fixed.</source>
          <target state="translated">프로토 타입에서 영숫자 시퀀스를 사용하려고하면 &quot;프로토 타입의 잘못된 문자 ...&quot;라는 선택적 경고가 생성됩니다. 불행히도 이전 버전의 Perl에서는 접두사가 유효한 프로토 타입 인 경우 프로토 타입을 사용할 수있었습니다. 문제가되는 코드의 대부분이 수정되면 이후 버전의 Perl에서 경고가 치명적인 오류로 업그레이드 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe9a752d3dfb5ae4ddbce9b50462b1f6d85d68b3" translate="yes" xml:space="preserve">
          <source>If you try to use code expressions where the code text is contained within an interpolated variable, rather than appearing literally in the pattern, Perl may surprise you:</source>
          <target state="translated">코드 텍스트가 패턴에 문자 그대로 표시되지 않고 보간 된 변수 내에 포함 된 코드 표현식을 사용하려고하면 Perl은 다음과 같이 놀라게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b74ccad2ea9ca8d857dc7afb6d54fa03395dd0f9" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; in your handler for $SIG{CHLD}, it may accidentally wait for the child created by qx() or system(). See &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for details.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; $ SIG {CHLD}에 대한 핸들러에서, 그것은 실수로 QX 만든 아이 () 또는 시스템 대기 할 수있다 (). 자세한 내용은 &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5f489bb10b3438e3010da06cd3b95ce427029dc2" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; in your handler for $SIG{CHLD}, it may accidentally wait for the child created by qx() or system(). See &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt; for details.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; $ SIG {CHLD}에 대한 핸들러에서, 그것은 실수로 QX 만든 아이 () 또는 시스템 대기 할 수있다 (). 자세한 내용은 &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="46bb44efb62948225ccf4e92dee64ae61f103a13" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;FilterName&lt;/code&gt; to modify the filename, it is your responsibility to keep the filename in Unix format.</source>
          <target state="translated">&lt;code&gt;FilterName&lt;/code&gt; 을 사용 하여 파일 이름을 수정하는 경우 파일 이름을 Unix 형식으로 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="16f11d3777f6f8b6ecfda56c2150f1df3c1a440a" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;harness&lt;/code&gt; for testing, you have several command line options available to you. The arguments are as follows, and are in the order that they must appear if used together.</source>
          <target state="translated">테스트에 &lt;code&gt;harness&lt;/code&gt; 를 사용하는 경우 몇 가지 명령 줄 옵션을 사용할 수 있습니다. 인수는 다음과 같으며 함께 사용되는 경우 순서대로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5dace6a8fabe0f3fff4268587985038c8aa60a8e" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;man&lt;/code&gt; , either move the installed</source>
          <target state="translated">&lt;code&gt;man&lt;/code&gt; 을 사용 하는 경우 설치된 것을 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="f77d31c25362c9be9687e6ee59543d3904970c3a" translate="yes" xml:space="preserve">
          <source>If you use Sun's C compiler, make sure the correct directory (usually /opt/SUNWspro/bin/) is in your PATH (before /usr/ucb/).</source>
          <target state="translated">Sun의 C 컴파일러를 사용하는 경우 올바른 디렉토리 (일반적으로 / opt / SUNWspro / bin /)가 PATH (/ usr / ucb / 이전)에 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="694a362a82c6e3cfa50f1318ad85b6fb37d17685" translate="yes" xml:space="preserve">
          <source>If you use a Unicode editor to edit your program, Unicode characters may occur directly within the literal strings in UTF-8 encoding, or UTF-16. (The former requires a &lt;code&gt;BOM&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; , the latter requires a &lt;code&gt;BOM&lt;/code&gt; .)</source>
          <target state="translated">유니 코드 편집기를 사용하여 프로그램을 편집하는 경우 유니 코드 문자는 UTF-8 인코딩 또는 UTF-16의 리터럴 문자열 내에서 직접 발생할 수 있습니다. 전자는 &lt;code&gt;BOM&lt;/code&gt; 이 필요 하거나 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하고 후자는 &lt;code&gt;BOM&lt;/code&gt; 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="87cf615c227432610de49accfafc5d497f5d3f61" translate="yes" xml:space="preserve">
          <source>If you use a deprecated feature or module and believe that its removal from the Perl core would be a mistake, please contact the perl5-porters mailinglist and plead your case. We don't deprecate things without a good reason, but sometimes there's a counterargument we haven't considered. Historically, we did not distinguish between &quot;deprecated&quot; and &quot;discouraged&quot; features.</source>
          <target state="translated">더 이상 사용되지 않는 기능 또는 모듈을 사용하고 Perl 코어에서 제거하는 것이 실수라고 생각되면 perl5-porters 메일 링리스트에 문의하여 사례를 요청하십시오. 우리는 정당한 이유없이 물건을 폐기하지 않지만 때로는 고려하지 않은 반론이 있습니다. 역사적으로 우리는 &quot;더 이상 사용되지 않는&quot;기능과 &quot;감지 된&quot;기능을 구분하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="5dd282c0cc211cebd60be34d73466e199fdff472" translate="yes" xml:space="preserve">
          <source>If you use a here-doc within a delimited construct, such as in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///eg&lt;/a&gt;&lt;/code&gt;, the quoted material must still come on the line following the &lt;code&gt;&amp;lt;&amp;lt;FOO&lt;/code&gt; marker, which means it may be inside the delimited construct:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///eg&lt;/a&gt;&lt;/code&gt; 와 같이 구분 된 구문 내에서 here-doc을 사용하는 경우 인용 된 자료는 여전히 &lt;code&gt;&amp;lt;&amp;lt;FOO&lt;/code&gt; 마커 다음 줄에 와야합니다. 즉, 구분 된 구문 안에있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ae0c0867250fd5a479e543aea928a9a77d11b83" translate="yes" xml:space="preserve">
          <source>If you use deferred writing (See &lt;a href=&quot;#Deferred-Writing&quot;&gt;Deferred Writing&lt;/a&gt;, below) then data you write into the array will not be written directly to the file; instead, it will be saved in the</source>
          <target state="translated">지연 쓰기를 사용하는 경우 (아래의 &lt;a href=&quot;#Deferred-Writing&quot;&gt;지연 쓰기&lt;/a&gt; 참조) 배열에 쓰는 데이터는 파일에 직접 쓰여지지 않습니다. 대신에</target>
        </trans-unit>
        <trans-unit id="4f2793be84e03f881815cfd6cbd437f560ace728" translate="yes" xml:space="preserve">
          <source>If you use either the R_IAFTER or R_IBEFORE flags, the &lt;code&gt;$key&lt;/code&gt; parameter will have the record number of the inserted key/value pair set.</source>
          <target state="translated">R_IAFTER 또는 R_IBEFORE 플래그를 사용하는 경우 &lt;code&gt;$key&lt;/code&gt; 매개 변수는 삽입 된 키 / 값 쌍 세트의 레코드 번호를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="7804e89f419dfb4afe57d175e577f649678035a8" translate="yes" xml:space="preserve">
          <source>If you use gcc, make sure your installation is recent and complete. perl versions since 5.6.0 build fine with gcc &amp;gt; 2.8.1 on Solaris &amp;gt;= 2.6.</source>
          <target state="translated">gcc를 사용하는 경우 설치가 최신이고 완전한지 확인하십시오. 5.6.0 이후의 perl 버전은 Solaris&amp;gt; = 2.6에서 gcc&amp;gt; 2.8.1로 올바르게 빌드됩니다.</target>
        </trans-unit>
        <trans-unit id="c133e612772c5c91ca38653bb618cdde5ecf7eea" translate="yes" xml:space="preserve">
          <source>If you use one of the undocumented functions below, you may wish to consider creating and submitting documentation for it. If your patch is accepted, this will indicate that the interface is stable (unless it is explicitly marked otherwise).</source>
          <target state="translated">아래의 문서화되지 않은 기능 중 하나를 사용하는 경우 해당 문서를 작성하여 제출하는 것이 좋습니다. 패치가 승인되면 인터페이스가 안정적으로 표시됩니다 (달리 명시 적으로 표시되지 않은 경우).</target>
        </trans-unit>
        <trans-unit id="97a1d75ada82bbf9f654420e7c70ad3899b98121" translate="yes" xml:space="preserve">
          <source>If you use preprocessor directives to choose one of two versions of a function, use</source>
          <target state="translated">전 처리기 지시문을 사용하여 두 버전의 함수 중 하나를 선택하는 경우</target>
        </trans-unit>
        <trans-unit id="32e7fdaa4b2e816b8b9a792f2d7c56bbe0d52ad7" translate="yes" xml:space="preserve">
          <source>If you use the 4DOS/NT or similar command shell, note that &quot;pl2bat&quot; uses the &quot;%*&quot; variable in the generated batch file to refer to all the command line arguments, so you may need to make sure that construct works in batch files. As of this writing, 4DOS/NT users will need a &quot;ParameterChar = *&quot; statement in their 4NT.INI file or will need to execute &quot;setdos /p*&quot; in the 4DOS/NT startup file to enable this to work.</source>
          <target state="translated">4DOS / NT 또는 유사한 명령 쉘을 사용하는 경우, &quot;pl2bat&quot;는 생성 된 배치 파일에서 &quot;% *&quot;변수를 사용하여 모든 명령 행 인수를 참조하므로 구성이 배치에서 작동하는지 확인해야합니다. 파일. 이 글을 쓰는 시점에서 4DOS / NT 사용자는 4NT.INI 파일에 &quot;ParameterChar = *&quot;문이 필요하거나 4DOS / NT 시작 파일에서 &quot;setdos / p *&quot;를 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="91300f437c633a42a75ef31ebaae0d2065c281bd" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; PerlIO layer for input, invalid byte sequences are handled gracefully, but if you use &lt;code&gt;:utf8&lt;/code&gt; , the flag is set without validating the data, possibly resulting in this error message.</source>
          <target state="translated">입력에 &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; PerlIO 레이어를 사용하면 유효하지 않은 바이트 시퀀스가 ​​정상적으로 처리되지만 &lt;code&gt;:utf8&lt;/code&gt; 을 사용 하면 데이터를 검증하지 않고 플래그가 설정 되어이 오류 메시지가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3eecf6412d7114c8844a3dfb8554c44c0eb8598c" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;SA_SIGINFO&lt;/code&gt; flag, the signal handler will in addition to the first argument, the signal name, also receive a second argument, a hash reference, inside which are the following keys with the following semantics, as defined by POSIX/SUSv3:</source>
          <target state="translated">&lt;code&gt;SA_SIGINFO&lt;/code&gt; 플래그 를 사용하는 경우 신호 핸들러는 첫 번째 인수 인 신호 이름 외에 두 번째 인수 인 해시 참조를 수신합니다. 내부에는 POSIX / SUSv3에 의해 정의 된 다음 의미를 가진 다음 키가 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc06c253841f15b9de0c355618356ed5550da10d" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;\G&lt;/code&gt; anchor, you force the match after &lt;code&gt;22&lt;/code&gt; to start with the &lt;code&gt;a&lt;/code&gt; . The regular expression cannot match there since it does not find a digit, so the next match fails and the match operator returns the pairs it already found.</source>
          <target state="translated">&lt;code&gt;\G&lt;/code&gt; 앵커 를 사용하는 경우 &lt;code&gt;22&lt;/code&gt; 이후의 일치 가 &lt;code&gt;a&lt;/code&gt; 로 시작 하도록 강제합니다 . 정규식은 숫자를 찾을 수 없으므로 일치하지 않으므로 다음 일치는 실패하고 일치 연산자는 이미 찾은 쌍을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="fbb20a66ed661494874fa5e98a73f246a9cc34cc" translate="yes" xml:space="preserve">
          <source>If you use the English module, you can even read the variable names:</source>
          <target state="translated">영어 모듈을 사용하면 변수 이름을 읽을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="abbbac8010fcf4e1f8177dc8b18103356d7c1579" translate="yes" xml:space="preserve">
          <source>If you use the form &lt;code&gt;\N{&lt;i&gt;character name&lt;/i&gt;}&lt;/code&gt;, the &lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt; module gets automatically loaded. This may not be suitable for the test level you are doing.</source>
          <target state="translated">양식 사용하는 경우 &lt;code&gt;\N{&lt;i&gt;character name&lt;/i&gt;}&lt;/code&gt; 는 &lt;a href=&quot;charnames&quot;&gt;charnames의&lt;/a&gt; 모듈이 자동으로로드됩니다. 이것은 수행중인 테스트 수준에 적합하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6639f5cfc711b71b35423e81c784a209aabfc93" translate="yes" xml:space="preserve">
          <source>If you use the hash syntax, you have no control over the order in which the ExtraSubFields are stored, plus you cannot have SubFields with duplicate ID.</source>
          <target state="translated">해시 구문을 사용하는 경우 ExtraSubField가 저장된 순서를 제어 할 수 없으며 ID가 중복 된 SubField를 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cf9048b3298377c86c20ad5d8b5d02655bc3f8b6" translate="yes" xml:space="preserve">
          <source>If you use the raw format, and the &lt;code&gt;Strict&lt;/code&gt; option is enabled, &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; will check that &lt;code&gt;$rawdata&lt;/code&gt; consists of zero or more conformant sub-fields. When &lt;code&gt;Strict&lt;/code&gt; is disabled, &lt;code&gt;$rawdata&lt;/code&gt; can consist of any arbitrary byte stream.</source>
          <target state="translated">원시 형식을 사용하고 &lt;code&gt;Strict&lt;/code&gt; 옵션이 활성화 된 경우 &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; 은 &lt;code&gt;$rawdata&lt;/code&gt; 가 0 개 이상의 해당 하위 필드로 구성되어 있는지 확인 합니다. 때 &lt;code&gt;Strict&lt;/code&gt; 비활성화되어, &lt;code&gt;$rawdata&lt;/code&gt; 임의의 바이트 스트림으로 구성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c067123fb137430de0f256b297d516b2001d264a" translate="yes" xml:space="preserve">
          <source>If you use utf8 or other non-ASCII characters with Test::More you might get a &quot;Wide character in print&quot; warning. Using &lt;code&gt;&lt;a href=&quot;../functions/binmode&quot;&gt;binmode&lt;/a&gt; STDOUT, &quot;:utf8&quot;&lt;/code&gt; will not fix it. &lt;a href=&quot;builder&quot;&gt;Test::Builder&lt;/a&gt; (which powers Test::More) duplicates STDOUT and STDERR. So any changes to them, including changing their output disciplines, will not be seem by Test::More.</source>
          <target state="translated">Test :: More와 함께 utf8 또는 기타 비 ASCII 문자를 사용하는 경우 &quot;넓은 문자가 인쇄됩니다&quot;경고가 표시 될 수 있습니다. &lt;code&gt;&lt;a href=&quot;../functions/binmode&quot;&gt;binmode&lt;/a&gt; STDOUT, &quot;:utf8&quot;&lt;/code&gt; 사용하면 &quot;: utf8&quot; 이이를 수정하지 않습니다. &lt;a href=&quot;builder&quot;&gt;Test :: Builder&lt;/a&gt; (Test :: More에 전원을 공급)는 STDOUT 및 STDERR을 복제합니다. 따라서 출력 규칙 변경을 포함하여 변경 사항은 Test :: More에서 보이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="630840ae944c06429550447e9540c0ca707dbc1a" translate="yes" xml:space="preserve">
          <source>If you used WinZip, this was already done for you.</source>
          <target state="translated">WinZip을 사용한 경우 이미 완료된 것입니다.</target>
        </trans-unit>
        <trans-unit id="8c53b3ef6362ad03c7dbea52d0c4786e608f8e77" translate="yes" xml:space="preserve">
          <source>If you used git to check out the Perl source, then using &lt;code&gt;git
format-patch&lt;/code&gt; will produce a patch in a style suitable for Perl. The &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format-patch&lt;/a&gt;&lt;/code&gt; command produces one patch file for each commit you made. If you prefer to send a single patch for all commits, you can use &lt;code&gt;git diff&lt;/code&gt; .</source>
          <target state="translated">git을 사용하여 Perl 소스를 체크 아웃 한 경우 &lt;code&gt;git format-patch&lt;/code&gt; 를 사용하면 Perl에 적합한 스타일의 패치 가 생성됩니다. &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format-patch&lt;/a&gt;&lt;/code&gt; 명령은 각 당신이 만든 커밋에 대한 하나 개의 패치 파일을 생성합니다. 모든 커밋에 단일 패치를 보내려면 &lt;code&gt;git diff&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2bc21e512fb418bd39c6e536f3bdd95478cb7d3c" translate="yes" xml:space="preserve">
          <source>If you want $x to have a certain sign, use one of the following methods:</source>
          <target state="translated">$ x가 특정 부호를 가지도록하려면 다음 방법 중 하나를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1553678828e2328fa0aa14746ccfdd7229ce26f6" translate="yes" xml:space="preserve">
          <source>If you want *.ucm installed together with the modules, do as follows;</source>
          <target state="translated">* .ucm을 모듈과 함께 설치하려면 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="791324333537699862b9ce903fa1af5980ed496f" translate="yes" xml:space="preserve">
          <source>If you want a &quot;real&quot; C &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; (see</source>
          <target state="translated">&quot;실제&quot;C &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 를 원할 경우 (참조</target>
        </trans-unit>
        <trans-unit id="c13df57b95397c5f1d723459f0b855e899e41a8a" translate="yes" xml:space="preserve">
          <source>If you want a &quot;real&quot; C &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; (see</source>
          <target state="translated">&quot;실제&quot;C &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 를 원할 경우 (참조</target>
        </trans-unit>
        <trans-unit id="cb1d7bd468d379f255df6d0a8a45090fecae8882" translate="yes" xml:space="preserve">
          <source>If you want a Perl application to process and present your data according to a particular locale, the application code should include the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; pragma (see &lt;a href=&quot;#The-%22use-locale%22-pragma&quot;&gt;The use locale pragma&lt;/a&gt;) where appropriate, and &lt;b&gt;at least one&lt;/b&gt; of the following must be true:</source>
          <target state="translated">당신이 프로세스에 펄 응용 프로그램을 원하는 특정 지역에 맞는 데이터를 제시하는 경우, 응용 프로그램 코드가 포함되어야 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 프라 그마 (참조 &lt;a href=&quot;#The-%22use-locale%22-pragma&quot;&gt;사용 로케일 프라그를&lt;/a&gt; ) 적절하고, &lt;b&gt;적어도 하나에서&lt;/b&gt; 다음의 충족되어야합니다 :</target>
        </trans-unit>
        <trans-unit id="dc8f1faa6c36903ecd5d1abeecfdbd92380ab3a3" translate="yes" xml:space="preserve">
          <source>If you want a better approximation of the square root, then use:</source>
          <target state="translated">제곱근을 더 근사하게하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="409579e935815d3f9b1b191e4808eba939430e40" translate="yes" xml:space="preserve">
          <source>If you want a completely new Test::Builder object different from the singleton, use &lt;code&gt;create&lt;/code&gt; .</source>
          <target state="translated">싱글 톤과 완전히 다른 완전히 새로운 Test :: Builder 객체를 원한다면 &lt;code&gt;create&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="364287807494857e0923c716161b8323aaaa85ad" translate="yes" xml:space="preserve">
          <source>If you want a list of all of the Perl module filenames, you can use &lt;a href=&quot;http://search.cpan.org/perldoc/File::Find::Rule&quot;&gt;File::Find::Rule&lt;/a&gt;:</source>
          <target state="translated">모든 Perl 모듈 파일 이름 목록을 원하면 &lt;a href=&quot;http://search.cpan.org/perldoc/File::Find::Rule&quot;&gt;File :: Find :: Rule을&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="20d03f9f8d59c035c39fd85e8955d33568507a9f" translate="yes" xml:space="preserve">
          <source>If you want a real Perl scalar, use &lt;code&gt;numify()&lt;/code&gt; :</source>
          <target state="translated">실제 Perl 스칼라를 &lt;code&gt;numify()&lt;/code&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="9309fd012fc6beaef72da428ac578230d08f400e" translate="yes" xml:space="preserve">
          <source>If you want a supported version of perl for OpenVOS, purchase the OpenVOS GNU Tools product from Stratus Technologies, along with a support contract (or from anyone else who will sell you support).</source>
          <target state="translated">지원되는 OpenVOS 버전의 perl을 원하는 경우 Stratus Technologies 및 지원 계약 (또는 지원을 판매 할 다른 사람)의 OpenVOS GNU Tools 제품을 구입하십시오.</target>
        </trans-unit>
        <trans-unit id="6584c0a384e584f13abe302cec979af6b67c1d61" translate="yes" xml:space="preserve">
          <source>If you want a true copy of $x, use:</source>
          <target state="translated">$ x의 실제 사본을 원하면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2bd3ed425ef919c14360d525b51cc98be9af477c" translate="yes" xml:space="preserve">
          <source>If you want access to threads, you must &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; before you &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; threads::shared&lt;/code&gt; . &lt;a href=&quot;../threads&quot;&gt;threads&lt;/a&gt; will emit a warning if you use it after &lt;a href=&quot;shared&quot;&gt;threads::shared&lt;/a&gt;.</source>
          <target state="translated">당신이 스레드에 액세스하려면 다음을 수행해야합니다 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; 당신이 전에 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; threads::shared&lt;/code&gt; . &lt;a href=&quot;../threads&quot;&gt;threads &lt;/a&gt;&lt;a href=&quot;shared&quot;&gt;:: shared&lt;/a&gt; 다음에 사용하면 스레드 가 경고를 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="2ffb4d0fb6b209221b80f1da704496ad8ce1ebe0" translate="yes" xml:space="preserve">
          <source>If you want an IDE, check the following (in alphabetical order, not order of preference):</source>
          <target state="translated">IDE를 원하는 경우 다음을 확인하십시오 (기본 설정 순서가 아닌 알파벳 순서로).</target>
        </trans-unit>
        <trans-unit id="fe93301108d8dca54392bf8f900a5e24a5258416" translate="yes" xml:space="preserve">
          <source>If you want anything fancier, consider overriding this with something that uses &lt;a href=&quot;http://search.cpan.org/perldoc/Number::Format&quot;&gt;Number::Format&lt;/a&gt;, or does something else entirely.</source>
          <target state="translated">더 멋진 것을 원한다면 &lt;a href=&quot;http://search.cpan.org/perldoc/Number::Format&quot;&gt;Number :: Format&lt;/a&gt; 을 사용 하거나 완전히 다른 것을 사용하여 이것을 재정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="03e2f095ee9c1b96484a23c04f5e5dfef232e04c" translate="yes" xml:space="preserve">
          <source>If you want build some core extensions statically into perl's dll, specify them in the STATIC_EXT macro.</source>
          <target state="translated">펄의 dll에 일부 핵심 확장을 정적으로 빌드하려면 STATIC_EXT 매크로에 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="18b0e9b36c2f4eaca25552fa7c7631a4398f6336" translate="yes" xml:space="preserve">
          <source>If you want finer granularity than the 1 second that the &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep()&lt;/a&gt;&lt;/code&gt; function provides, the easiest way is to use the &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; function as documented in &lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;. Try the &lt;a href=&quot;time/hires&quot;&gt;Time::HiRes&lt;/a&gt; and the &lt;a href=&quot;http://search.cpan.org/perldoc/BSD::Itimer&quot;&gt;BSD::Itimer&lt;/a&gt; modules (available from CPAN, and starting from Perl 5.8 &lt;a href=&quot;time/hires&quot;&gt;Time::HiRes&lt;/a&gt; is part of the standard distribution).</source>
          <target state="translated">당신은 그 일초보다 더 치밀하게하려면 &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep()&lt;/a&gt;&lt;/code&gt; 함수를 제공합니다, 가장 쉬운 방법은 사용하는 것입니다 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; 에 설명 된대로 기능을 &lt;a href=&quot;functions/select&quot;&gt;선택합니다&lt;/a&gt; . &lt;a href=&quot;time/hires&quot;&gt;Time :: HiRes&lt;/a&gt; 및 &lt;a href=&quot;http://search.cpan.org/perldoc/BSD::Itimer&quot;&gt;BSD :: Itimer&lt;/a&gt; 모듈을 사용해보십시오 (CPAN에서 사용 가능하며 Perl 5.8부터 &lt;a href=&quot;time/hires&quot;&gt;Time :: HiRes&lt;/a&gt; 는 표준 배포의 일부 임).</target>
        </trans-unit>
        <trans-unit id="e14afa459a95e2ee1097bdb5d465fc670f04bf72" translate="yes" xml:space="preserve">
          <source>If you want it to be a Unicode string (because you want character semantics with operations like regular expression matching), you need to decode the UTF8-encoded content and have Perl convert it into a Unicode string:</source>
          <target state="translated">정규식 일치와 같은 연산으로 문자 의미를 원하기 때문에 유니 코드 문자열이 되려면 UTF8로 인코딩 된 내용을 디코딩하고 Perl에서이를 유니 코드 문자열로 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="b68288a6982fc2b55a1d1fa4ad5b3ecc68be5d47" translate="yes" xml:space="preserve">
          <source>If you want more flexibility, you need to configure your CPAN client for your particular situation.</source>
          <target state="translated">유연성을 높이려면 특정 상황에 맞게 CPAN 클라이언트를 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="212545de9d894bed7fa89be5bf884693fe7c603b" translate="yes" xml:space="preserve">
          <source>If you want no headers or footers output in the HTML, set these options to the empty string.</source>
          <target state="translated">HTML에서 머리글이나 바닥 글을 출력하지 않으려면이 옵션을 빈 문자열로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="2be3f922578397a2f9698c9c71abc2a55e6ed43d" translate="yes" xml:space="preserve">
          <source>If you want perl to use globbing that emulates the quirks of DOS filename conventions, you might want to consider using File::DosGlob to override the internal glob() implementation. See &lt;a href=&quot;file/dosglob&quot;&gt;File::DosGlob&lt;/a&gt; for details.</source>
          <target state="translated">DOS 파일 이름 규칙의 단점을 모방하는 펄링을 perl에서 사용하려면 File :: DosGlob을 사용하여 내부 glob () 구현을 재정의하는 것이 좋습니다. 자세한 내용은 &lt;a href=&quot;file/dosglob&quot;&gt;File :: DosGlob&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="08c46a24da2bb06c6e1c6ef38a1abe76f47d9a13" translate="yes" xml:space="preserve">
          <source>If you want read lines, you must read in list context.</source>
          <target state="translated">행을 읽으려면 목록 컨텍스트를 읽어야합니다.</target>
        </trans-unit>
        <trans-unit id="9bfb8a43a2ce5fcca125d20e873c4c7b11aed7e7" translate="yes" xml:space="preserve">
          <source>If you want the &lt;code&gt;atexit()&lt;/code&gt; syntax (and an &lt;code&gt;rmexit()&lt;/code&gt; as well), try the &lt;code&gt;AtExit&lt;/code&gt; module available from CPAN.</source>
          <target state="translated">&lt;code&gt;atexit()&lt;/code&gt; 구문 및 &lt;code&gt;rmexit()&lt;/code&gt; 도 원하는 경우 CPAN에서 사용 가능한 &lt;code&gt;AtExit&lt;/code&gt; 모듈을 사용해보십시오 .</target>
        </trans-unit>
        <trans-unit id="124ea0ab66186e4216274d303cbf33e4b47044f9" translate="yes" xml:space="preserve">
          <source>If you want the array index, use the &lt;code&gt;firstidx()&lt;/code&gt; function from &lt;code&gt;List::MoreUtils&lt;/code&gt; :</source>
          <target state="translated">배열 인덱스를 원하면 &lt;code&gt;List::MoreUtils&lt;/code&gt; 의 &lt;code&gt;firstidx()&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7615fa2a66b55733775cb5d887a00d84846653ee" translate="yes" xml:space="preserve">
          <source>If you want the code to die instead of falling back, use &lt;code&gt;only&lt;/code&gt; instead:</source>
          <target state="translated">코드가 돌아 가지 않고 죽게하려면 대신 다음 코드 &lt;code&gt;only&lt;/code&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5f643e51c29ad1dcf8382df154f107e9e891d49b" translate="yes" xml:space="preserve">
          <source>If you want the code to die instead, replace &quot;try&quot; with &quot;only&quot;:</source>
          <target state="translated">코드를 대신 죽게하려면 &quot;try&quot;를 &quot;only&quot;로 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="444d833c4fe34c4ebf55ce0643031f3aa4615d34" translate="yes" xml:space="preserve">
          <source>If you want the equivalent of &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Foo ()&lt;/code&gt; , use a module but not import anything, use &lt;code&gt;require_ok&lt;/code&gt; .</source>
          <target state="translated">당신이에 해당합니다 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Foo ()&lt;/code&gt; , 모듈하지만 수입 아무것도 사용 사용 &lt;code&gt;require_ok&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="0ebff181122cf920b540aa12f6f2468119acea8d" translate="yes" xml:space="preserve">
          <source>If you want the old signal behavior back despite possible memory corruption, set the environment variable &lt;code&gt;PERL_SIGNALS&lt;/code&gt; to &lt;code&gt;&quot;unsafe&quot;&lt;/code&gt; . This feature first appeared in Perl 5.8.1.</source>
          <target state="translated">가능한 메모리 손상에도 불구하고 이전 신호 동작을 되돌리려면 환경 변수 &lt;code&gt;PERL_SIGNALS&lt;/code&gt; 를 &lt;code&gt;&quot;unsafe&quot;&lt;/code&gt; 로 설정하십시오 . 이 기능은 Perl 5.8.1에서 처음 등장했습니다.</target>
        </trans-unit>
        <trans-unit id="35e2e89a1af9e4f4ab883e1fb265f28d997edb48" translate="yes" xml:space="preserve">
          <source>If you want these output in a sorted order, see &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt;: &quot;How do I sort a hash (optionally by value instead of key)?&quot;.</source>
          <target state="translated">이러한 출력을 정렬 된 순서로 원하면 &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt; : &quot;해시를 어떻게 정렬합니까 (선택적으로 키 대신 값으로)?&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1340d84f704d5f6a74163cc5fe06ae9be150fb8b" translate="yes" xml:space="preserve">
          <source>If you want to &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; into a string, you just have to &amp;lt;open&amp;gt; a filehandle to a string, which Perl has been able to do since Perl 5.6:</source>
          <target state="translated">문자열 에 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 려면 Perl 5.6부터 Perl이 할 수있는 문자열에 파일 핸들을 &amp;lt;열기&amp;gt; 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="7953e238f104e2cdb7abf22e43568bf172380a8b" translate="yes" xml:space="preserve">
          <source>If you want to CLONE all objects you will need to keep track of them per package. This is simply done using a hash and Scalar::Util::weaken().</source>
          <target state="translated">모든 객체를 청소하려면 패키지 당 객체를 추적해야합니다. 이것은 단순히 해시와 Scalar :: Util :: weaken ()을 사용하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="8a750f90ba1cfc2d81f044342057667c6ac1726e" translate="yes" xml:space="preserve">
          <source>If you want to actually extract the matching elements, simply use grep in list context.</source>
          <target state="translated">실제로 일치하는 요소를 추출하려면 목록 컨텍스트에서 grep을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d026b5d2f0b8d0ebf6352db336c8a293bea0fac9" translate="yes" xml:space="preserve">
          <source>If you want to add your encoding to Encode's demand-loading list (so you don't have to &quot;use Encode::YourEncoding&quot;), run</source>
          <target state="translated">Encode의 요청로드 목록에 인코딩을 추가하려면 ( &quot;Encode :: YourEncoding&quot;을 사용할 필요가 없음) 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="3ceac82578bb19fb50532d7256faa44ce8c265df" translate="yes" xml:space="preserve">
          <source>If you want to append something to the end of string stored in an &lt;code&gt;SV*&lt;/code&gt; , you can use the following functions:</source>
          <target state="translated">&lt;code&gt;SV*&lt;/code&gt; 저장된 문자열 끝에 무언가를 추가 하려면 다음 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fbae8e9319ec5948bcc63aa24cae46d2c786676" translate="yes" xml:space="preserve">
          <source>If you want to be sure that you're calling &lt;code&gt;isa&lt;/code&gt; as a method, not a class, check the invocand with &lt;code&gt;blessed&lt;/code&gt; from &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt; first:</source>
          <target state="translated">클래스가 아닌 메소드로 &lt;code&gt;isa&lt;/code&gt; 를 호출 하고 있는지 확인하려면 &lt;a href=&quot;scalar/util&quot;&gt;Scalar :: Util의 &lt;/a&gt; &lt;code&gt;blessed&lt;/code&gt; 을 받은 사람과 먼저 청구자를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="363081145dde14f7c8fd4e2bf011a936ad34c73a" translate="yes" xml:space="preserve">
          <source>If you want to break apart an entire line of fixed columns, you can use &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; with the A (ASCII) format. By using a number after the format specifier, you can denote the column width. See the &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; entries in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for more details.</source>
          <target state="translated">고정 열의 전체 행을 분리 하려면 A (ASCII) 형식의 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 를 사용할 수 있습니다 . 형식 지정자 뒤에 숫자를 사용하면 열 너비를 나타낼 수 있습니다. 자세한 내용은 &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; 의 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 항목 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="10e8c447f2a79196fb827a87399f6352fddeb35d" translate="yes" xml:space="preserve">
          <source>If you want to build the docs yourself, and have</source>
          <target state="translated">문서를 직접 만들고 싶다면</target>
        </trans-unit>
        <trans-unit id="3016ac8f3431196221d3334c73f10b4a58c7afce" translate="yes" xml:space="preserve">
          <source>If you want to call C from Perl, start with &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt;, moving on to &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;, &lt;a href=&quot;xsubpp&quot;&gt;xsubpp&lt;/a&gt;, and &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;. If you want to call Perl from C, then read &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;, &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;, and &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;. Don't forget that you can learn a lot from looking at how the authors of existing extension modules wrote their code and solved their problems.</source>
          <target state="translated">펄에서 C를 호출 할 경우, 시작 &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; 로 이동, &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; , &lt;a href=&quot;xsubpp&quot;&gt;xsubpp를&lt;/a&gt; , 그리고 &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; . C에서 Perl을 호출하려면 &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt; , &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; 및 &lt;a href=&quot;perlguts&quot;&gt;perlguts를 읽으십시오&lt;/a&gt; . 기존 확장 모듈의 작성자가 코드를 작성하고 문제를 해결 한 방법을 살펴보면 많은 것을 배울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="548a69c6108c24555301c111e716c92968ea1230" translate="yes" xml:space="preserve">
          <source>If you want to check exactly, compare the string with its NFC/NFKC/FCC.</source>
          <target state="translated">정확하게 확인하려면 문자열을 NFC / NFKC / FCC와 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="59c2fb7af17b706fe9c70e8baa09126e5a3d250b" translate="yes" xml:space="preserve">
          <source>If you want to compress all</source>
          <target state="translated">모두 압축하려면</target>
        </trans-unit>
        <trans-unit id="6bcfdbb5379f221cca1d97f7787d1bc312424003" translate="yes" xml:space="preserve">
          <source>If you want to control warnings on the fly, do something like this. Make sure you do the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; first, or you won't be able to get at the enable() or disable() methods.</source>
          <target state="translated">즉시 경고를 제어하려면 다음과 같이하십시오. 먼저 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 하십시오. 그렇지 않으면 enable () 또는 disable () 메소드를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a42c1db2cee198b239c3cde06a946cab4e064353" translate="yes" xml:space="preserve">
          <source>If you want to control what functions Test::More will export, you have to use the 'import' option. For example, to import everything but 'fail', you'd do:</source>
          <target state="translated">Test :: More가 내보낼 기능을 제어하려면 'import'옵션을 사용해야합니다. 예를 들어, '실패'를 제외한 모든 것을 가져 오려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="be1e5234b80eb1f923a376bc3491ec3ca6b109b2" translate="yes" xml:space="preserve">
          <source>If you want to convert the returned map to entirely scalar numbers, you can use something like this:</source>
          <target state="translated">반환 된 맵을 스칼라 숫자로 완전히 변환하려면 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ba04eeea7231f6480afed51584cd45a160a944a" translate="yes" xml:space="preserve">
          <source>If you want to convert to UTF-8 from encodings other than the native (Latin1 or EBCDIC), see &lt;a href=&quot;#sv_recode_to_utf8&quot;&gt;sv_recode_to_utf8&lt;/a&gt;().</source>
          <target state="translated">네이티브 (Latin1 또는 EBCDIC) 이외의 인코딩에서 UTF-8로 변환하려면 &lt;a href=&quot;#sv_recode_to_utf8&quot;&gt;sv_recode_to_utf8&lt;/a&gt; ()을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="53c24008e3ed2beeee61bb3c00b23e9cec000bd1" translate="yes" xml:space="preserve">
          <source>If you want to create many anonymous handles, you should check out the Symbol or IO::Handle modules.</source>
          <target state="translated">많은 익명 핸들을 만들려면 Symbol 또는 IO :: Handle 모듈을 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="d3f92af00462a48927ab51881cd3156c2dfab08a" translate="yes" xml:space="preserve">
          <source>If you want to create the file if it does not already exist then bitwise-OR (&lt;code&gt;|&lt;/code&gt;) &lt;code&gt;O_CREAT&lt;/code&gt; too. If you omit &lt;code&gt;O_CREAT&lt;/code&gt; and the database does not already exist then the &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call will fail.</source>
          <target state="translated">파일이없는 경우 파일을 작성하려면 비트 OR ( &lt;code&gt;|&lt;/code&gt; ) &lt;code&gt;O_CREAT&lt;/code&gt; 도 작성하십시오. &lt;code&gt;O_CREAT&lt;/code&gt; 를 생략 하고 데이터베이스가 아직 없으면 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 호출이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="a116b633c8c619c49052dbd9a5c72113a8975d85" translate="yes" xml:space="preserve">
          <source>If you want to create the file if it does not exist, add &lt;code&gt;O_CREAT&lt;/code&gt; to any of these, as in the example. If you omit &lt;code&gt;O_CREAT&lt;/code&gt; and the file does not already exist, the &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call will fail.</source>
          <target state="translated">파일이 존재하지 않는 경우 파일을 작성 하려면 예제와 같이 &lt;code&gt;O_CREAT&lt;/code&gt; 를 이들 중 하나에 추가하십시오 . &lt;code&gt;O_CREAT&lt;/code&gt; 를 생략 하고 파일이 존재하지 않으면 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 호출이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="0e3b712f48285cffa7900ceeb1af82270cd7a609" translate="yes" xml:space="preserve">
          <source>If you want to cycle through an array endlessly, you can increment the index modulo the number of elements in the array:</source>
          <target state="translated">배열을 끝없이 순환하려면 배열의 요소 수를 인덱스 모듈로 늘릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cfb6d26bc5df670c402213d4036f3bf58558df4" translate="yes" xml:space="preserve">
          <source>If you want to debug some other testfile, set the &lt;code&gt;TEST_FILE&lt;/code&gt; variable thusly:</source>
          <target state="translated">다른 &lt;code&gt;TEST_FILE&lt;/code&gt; 을 디버그하려면 TEST_FILE 변수를 다음과 같이 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="b931492f8ba265d923d9e6b394913c2adf2d8e1f" translate="yes" xml:space="preserve">
          <source>If you want to disallow any rearrangement, pass &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;[]&lt;/code&gt; (a reference to empty list) as the value for this key.</source>
          <target state="translated">재 배열을 허용하지 않으려면 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;[]&lt;/code&gt; (빈 목록에 대한 참조)를이 키의 값으로 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="e399c3f8eff9b2e3be1dfd1cb3c6e184f3c80005" translate="yes" xml:space="preserve">
          <source>If you want to do something when the object is destroyed, you can define a &lt;code&gt;DESTROY&lt;/code&gt; method in your class. This method will always be called by Perl at the appropriate time, unless the method is empty.</source>
          <target state="translated">객체가 파괴되었을 때 무언가를하고 싶다면 클래스에서 &lt;code&gt;DESTROY&lt;/code&gt; 메소드를 정의하면 됩니다. 이 메소드는 메소드가 비어 있지 않으면 항상 적절한 시간에 Perl에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="028499023abecf52141490b3dc52996a2e6540e8" translate="yes" xml:space="preserve">
          <source>If you want to do something with the REGEXP* later use SvRX instead and check for NULL.</source>
          <target state="translated">나중에 REGEXP *로 무언가를 수행하려면 대신 SvRX를 사용하고 NULL을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="5bec0b0d71b7e3b535fad4f2a98d0fdea0b5611d" translate="yes" xml:space="preserve">
          <source>If you want to do the same thing to modify the values of the hash, you can use the &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; function. As of Perl 5.6 the values are not copied, so if you modify $orbit (in this case), you modify the value.</source>
          <target state="translated">해시 값을 수정하기 위해 동일한 작업을 수행하려는 경우 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 함수를 사용할 수 있습니다 . Perl 5.6부터는 값이 복사되지 않으므로 $ orbit (이 경우)를 수정하면 값이 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="1befe6f0c8cce90a523721cdcb6a3e759a8bf613" translate="yes" xml:space="preserve">
          <source>If you want to downgrade a warning that has been escalated into a fatal error back to a normal warning, you can use the &quot;NONFATAL&quot; keyword. For example, the code below will promote all warnings into fatal errors, except for those in the &quot;syntax&quot; category.</source>
          <target state="translated">치명적 오류로 에스컬레이션 된 경고를 일반 경고로 다시 다운 그레이드하려면 &quot;NONFATAL&quot;키워드를 사용할 수 있습니다. 예를 들어 아래 코드는 &quot;구문&quot;범주의 경고를 제외한 모든 경고를 치명적인 오류로 승격시킵니다.</target>
        </trans-unit>
        <trans-unit id="aaac7464ef1e41e8e3656bb3c9f1373b9810c3d2" translate="yes" xml:space="preserve">
          <source>If you want to encode a large file, you should encode it in chunks that are a multiple of 57 bytes. This ensures that the base64 lines line up and that you do not end up with padding in the middle. 57 bytes of data fills one complete base64 line (76 == 57*4/3):</source>
          <target state="translated">큰 파일을 인코딩하려면 57 바이트의 배수 인 청크로 인코딩해야합니다. 이렇게하면 base64 줄이 정렬되고 중간에 패딩이 생기지 않습니다. 57 바이트의 데이터는 하나의 완전한 base64 라인을 채 웁니다 (76 == 57 * 4 / 3).</target>
        </trans-unit>
        <trans-unit id="526764856cb11f1625c51adabbc0827d170cf65b" translate="yes" xml:space="preserve">
          <source>If you want to enter a multi-line command, such as a subroutine definition with several statements or a format, escape the newline that would normally end the debugger command with a backslash. Here's an example:</source>
          <target state="translated">여러 명령문이있는 서브 루틴 정의 또는 형식과 같은 여러 줄 명령을 입력하려면 일반적으로 백 슬래시로 디버거 명령을 종료하는 줄 바꿈을 이스케이프하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1c27e6ce335738d835ec3fdd82f6c0809ffefc5e" translate="yes" xml:space="preserve">
          <source>If you want to find out how many characters are waiting, there's also the FIONREAD ioctl call to be looked at. The</source>
          <target state="translated">대기중인 문자 수를 확인하려면 FIONREAD ioctl 호출도 있습니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="1da1084e18df9224120de5015e0f47b55cae04d1" translate="yes" xml:space="preserve">
          <source>If you want to find out how many entries have a defined value, that's a bit different. You have to check each value. A &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; is handy:</source>
          <target state="translated">정의 된 값을 가진 항목 수를 찾으려면 약간 다릅니다. 각 값을 확인해야합니다. &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 편리합니다 :</target>
        </trans-unit>
        <trans-unit id="308cd4ff0bf951ae1c4968d0825997ff4ae0e702" translate="yes" xml:space="preserve">
          <source>If you want to find the package calling your code, perhaps to give better diagnostics as &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; does, use the &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; built-in:</source>
          <target state="translated">코드를 호출하는 패키지를 찾고, 아마도 &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; 처럼 더 나은 진단을 제공 하려면 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; 내장 기능을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e1f109680f15bd3886268c0dd93d91471450a599" translate="yes" xml:space="preserve">
          <source>If you want to get at a slice (part of a row) in a multidimensional array, you're going to have to do some fancy subscripting. That's because while we have a nice synonym for single elements via the pointer arrow for dereferencing, no such convenience exists for slices.</source>
          <target state="translated">다차원 배열에서 슬라이스 (행의 일부)를 얻으려면 멋진 첨자를해야합니다. 역 참조를 위해 포인터 화살표를 통해 단일 요소에 대한 동의어가 있지만 슬라이스에 대한 편의는 존재하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="ac8d06c0714514adee4900ccc907acf01c17734d" translate="yes" xml:space="preserve">
          <source>If you want to get warned when the fallback occurs, replace &quot;try&quot; with &quot;lib&quot;:</source>
          <target state="translated">폴 백이 발생할 때 경고를 받으려면 &quot;try&quot;를 &quot;lib&quot;로 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="c34f1861cd969edfd158d72b53e2b8bf861c0838" translate="yes" xml:space="preserve">
          <source>If you want to have arrays of constant strings, note carefully the right combination of &lt;code&gt;const&lt;/code&gt; s:</source>
          <target state="translated">상수 문자열의 배열을 원한다면 &lt;code&gt;const&lt;/code&gt; 의 올바른 조합에주의하십시오 .</target>
        </trans-unit>
        <trans-unit id="cc85c01bbb2e5546a912901548bde68e7f312959" translate="yes" xml:space="preserve">
          <source>If you want to have static strings, make them constant:</source>
          <target state="translated">정적 문자열을 원한다면 상수 문자열로 만드십시오.</target>
        </trans-unit>
        <trans-unit id="5f28aad16a41ad668dc6d2a20ee81e5f9b0af321" translate="yes" xml:space="preserve">
          <source>If you want to have your cake and eat it too, you need a more complicated boilerplate.</source>
          <target state="translated">케이크를 먹고 먹고 싶다면 더 복잡한 상용구가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="732754bf3b16a13d947b836156896a3b2cedc031" translate="yes" xml:space="preserve">
          <source>If you want to indent the text in the here document, you can do this:</source>
          <target state="translated">here 문서의 텍스트를 들여 쓰려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d6b9e98bf75fad13fa324d37df3fb0822a303c98" translate="yes" xml:space="preserve">
          <source>If you want to influence compilation of calls to a specific subroutine, then use &lt;a href=&quot;#cv_set_call_checker&quot;&gt;cv_set_call_checker&lt;/a&gt; rather than hooking checking of all &lt;code&gt;entersub&lt;/code&gt; ops.</source>
          <target state="translated">특정 서브 루틴에 대한 호출 컴파일에 영향을 미치려면 모든 &lt;code&gt;entersub&lt;/code&gt; op의 확인을 후크하는 대신 &lt;a href=&quot;#cv_set_call_checker&quot;&gt;cv_set_call_checker&lt;/a&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="168d6eb05b72021bb2cefd5586f5642721fb25b0" translate="yes" xml:space="preserve">
          <source>If you want to install a distribution from the current directory, you can tell &lt;code&gt;CPAN.pm&lt;/code&gt; to install &lt;code&gt;.&lt;/code&gt; (the full stop):</source>
          <target state="translated">현재 디렉토리에서 분배 를 설치하려면 &lt;code&gt;CPAN.pm&lt;/code&gt; 에 install을 지시 할 수 있습니다 &lt;code&gt;.&lt;/code&gt; (정지) :</target>
        </trans-unit>
        <trans-unit id="33e2d2f8b434b4a1cc7c6346d405264c8380bf51" translate="yes" xml:space="preserve">
          <source>If you want to install modules for your own use, the easiest way might be &lt;a href=&quot;http://search.cpan.org/perldoc/local::lib&quot;&gt;local::lib&lt;/a&gt;, which you can download from CPAN. It sets various installation settings for you, and uses those same settings within your programs.</source>
          <target state="translated">직접 사용하기 위해 모듈을 설치하려는 경우 가장 쉬운 방법은 &lt;a href=&quot;http://search.cpan.org/perldoc/local::lib&quot;&gt;local :: lib&lt;/a&gt; 일 수 있으며 CPAN에서 다운로드 할 수 있습니다. 다양한 설치 설정을 지정하고 프로그램 내에서 동일한 설정을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="58d2dc539671f427bbae58845aceababd0159c6c" translate="yes" xml:space="preserve">
          <source>If you want to know as little about Perl as possible but need to add a new encoding, just read this chapter and forget the rest.</source>
          <target state="translated">가능한 한 Perl에 대해 조금만 알고 싶지만 새로운 인코딩을 추가하려면이 장을 읽고 나머지 부분은 잊어 버리십시오.</target>
        </trans-unit>
        <trans-unit id="56e1fbcaca6130206229f6c3c8cb0c2d52fb54b7" translate="yes" xml:space="preserve">
          <source>If you want to know how Perl OO works under the hood, the &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; document explains the nitty gritty details.</source>
          <target state="translated">Perl OO가 어떻게 작동하는지 알고 싶다면 &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; 문서 에서 중요한 세부 사항을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="9f23a106d53e80c8c0f8d1f2b0c84d08d1054140" translate="yes" xml:space="preserve">
          <source>If you want to know how to handle automated testing for your distribution, you can check the environment. The CPAN Testers, for instance, set the value of &lt;code&gt;AUTOMATED_TESTING&lt;/code&gt; :</source>
          <target state="translated">배포에 대한 자동 테스트를 처리하는 방법을 알고 싶다면 환경을 확인할 수 있습니다. 예를 들어 CPAN 테스터는 &lt;code&gt;AUTOMATED_TESTING&lt;/code&gt; 값을 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="1a57ed6abdc67a27c928054414c38fcc1c565d58" translate="yes" xml:space="preserve">
          <source>If you want to know if the scalar value is TRUE, you can use:</source>
          <target state="translated">스칼라 값이 참인지 알고 싶다면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0f2be398a4f429a704b8881af39ff31858188bb" translate="yes" xml:space="preserve">
          <source>If you want to know if this variable (or any other SV) is actually &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt;, you can call:</source>
          <target state="translated">이 변수 (또는 다른 SV)가 실제로 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 되어 있는지 알고 싶다면 다음을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4282549729bb35373ef94d2e2b64ea8af51a5d06" translate="yes" xml:space="preserve">
          <source>If you want to know whether a particular scalar refers to an object, you can use the &lt;code&gt;blessed&lt;/code&gt; function exported by &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt;, which is shipped with the Perl core.</source>
          <target state="translated">특정 스칼라가 객체를 참조하는지 여부를 알고 싶다면 &lt;a href=&quot;scalar/util&quot;&gt;Percal&lt;/a&gt; 코어와 함께 제공 되는 Scalar :: Util 에서 내 보낸 &lt;code&gt;blessed&lt;/code&gt; 함수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="056d8ddf16a11d708261878d4f200cc28e75de75" translate="yes" xml:space="preserve">
          <source>If you want to learn more about Perl 6, or have a desire to help in the crusade to make Perl a better place then read the Perl 6 developers page at &lt;a href=&quot;http://www.perl6.org/&quot;&gt;http://www.perl6.org/&lt;/a&gt; and get involved.</source>
          <target state="translated">Perl 6에 대해 더 배우고 싶거나 Perl을 더 나은 곳으로 만들기 위해 성전을 돕고 싶다면 &lt;a href=&quot;http://www.perl6.org/&quot;&gt;http://www.perl6.org/&lt;/a&gt; 의 Perl 6 개발자 페이지를 읽고 참여하십시오.</target>
        </trans-unit>
        <trans-unit id="00255f60e5cd77d55f44acd05aa25f0d59366611" translate="yes" xml:space="preserve">
          <source>If you want to learn the basics of Perl, you might start with the Llama book, which assumes that you already know a little about programming:</source>
          <target state="translated">Perl의 기본 사항을 배우고 싶다면 Llama 책으로 시작할 수 있습니다. Llama 서적은 이미 프로그래밍에 대해 약간 알고 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="859f839c744c136d7bdf5037e58bd0e9887e2618" translate="yes" xml:space="preserve">
          <source>If you want to load a subclass from a file that &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; would not consider an eligible filename (that is, it does not end in either &lt;code&gt;.pm&lt;/code&gt; or &lt;code&gt;.pmc&lt;/code&gt;), use the following code:</source>
          <target state="translated">적합한 파일 이름을 고려하지 않는 파일에서 서브 클래스를로드 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; (즉, &lt;code&gt;.pm&lt;/code&gt; 또는 &lt;code&gt;.pmc&lt;/code&gt; 로 끝나지 않음 ) 다음 코드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="63bacba7c0db3c9f406fbf3ba9dec50a07c74303" translate="yes" xml:space="preserve">
          <source>If you want to load the entire file, you can use the &lt;a href=&quot;http://search.cpan.org/perldoc/Path::Tiny&quot;&gt;Path::Tiny&lt;/a&gt; module to do it in one simple and efficient step:</source>
          <target state="translated">전체 파일을로드하려는 경우 &lt;a href=&quot;http://search.cpan.org/perldoc/Path::Tiny&quot;&gt;Path :: Tiny&lt;/a&gt; 모듈을 사용하여 간단하고 효율적인 단계로 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b17927939e60f1cedd222b2461104e02f72f02d9" translate="yes" xml:space="preserve">
          <source>If you want to make a real copy, use the following:</source>
          <target state="translated">실제 사본을 만들려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="011cab076badf929a664e79819f2251ac21c5335" translate="yes" xml:space="preserve">
          <source>If you want to make the SV drop its string buffer, use &lt;code&gt;sv_force_normal_flags(sv, SV_COW_DROP_PV)&lt;/code&gt; or simply &lt;code&gt;sv_setsv(sv, NULL)&lt;/code&gt; .</source>
          <target state="translated">SV가 문자열 버퍼를 삭제하도록하려면 &lt;code&gt;sv_force_normal_flags(sv, SV_COW_DROP_PV)&lt;/code&gt; 또는 간단히 &lt;code&gt;sv_setsv(sv, NULL)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b7523637fc2645186f899696d73931e051d6c52" translate="yes" xml:space="preserve">
          <source>If you want to make use of the new features available in Berkeley DB 2.x or greater, use the Perl module &lt;b&gt;BerkeleyDB&lt;/b&gt; instead.</source>
          <target state="translated">Berkeley DB 2.x 이상에서 사용 가능한 새로운 기능을 사용하려면 대신 Perl 모듈 &lt;b&gt;BerkeleyDB를&lt;/b&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="610bb38fb99d325c8e7fefe0a23a02b343634382" translate="yes" xml:space="preserve">
          <source>If you want to modify the debugger, copy</source>
          <target state="translated">디버거를 수정하려면 복사</target>
        </trans-unit>
        <trans-unit id="68a89277cf24a3194f901f3f723f1840c4c2f27b" translate="yes" xml:space="preserve">
          <source>If you want to open either STDIN or STDOUT with &lt;code&gt;gzopen&lt;/code&gt; , you can now optionally use the special filename &quot;&lt;code&gt;-&lt;/code&gt; &quot; as a synonym for &lt;code&gt;\*STDIN&lt;/code&gt; and &lt;code&gt;\*STDOUT&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;gzopen&lt;/code&gt; 과 함께 STDIN 또는 STDOUT을 열려면 선택적으로 특수 파일 이름 &quot; &lt;code&gt;-&lt;/code&gt; &quot;를 &lt;code&gt;\*STDIN&lt;/code&gt; 및 &lt;code&gt;\*STDOUT&lt;/code&gt; 의 동의어로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e41fd5af244837759f6e880c0fa8c36bc7f07f26" translate="yes" xml:space="preserve">
          <source>If you want to overload a Perl operator, such as &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;**&lt;/code&gt; , then you'll want to use the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; pragma, documented in &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt;.</source>
          <target state="translated">Perl 연산자 (예 : &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;**&lt;/code&gt; )를 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; 하려는 &lt;a href=&quot;functions/use&quot;&gt;경우&lt;/a&gt; overload 문서화되어있는 &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt; pragma 사용을 원할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="945aa8bcea0076aea35d4a81e4ba840ff11ec82e" translate="yes" xml:space="preserve">
          <source>If you want to override a predefined function, such as open(), then you'll have to import the new definition from a different module. See &lt;a href=&quot;perlsub#Overriding-Built-in-Functions&quot;&gt;Overriding Built-in Functions in perlsub&lt;/a&gt;.</source>
          <target state="translated">open ()과 같은 미리 정의 된 함수를 재정의하려면 다른 모듈에서 새 정의를 가져와야합니다. &lt;a href=&quot;perlsub#Overriding-Built-in-Functions&quot;&gt;perlsub에서 내장 함수 대체를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fa48921f25a631295f915526fc8a70c73af7fbf8" translate="yes" xml:space="preserve">
          <source>If you want to override the mapping of Hangul syllables, NFD and NFKD are not appropriate, since NFD and NFKD will decompose Hangul syllables before overriding. FCD may decompose Hangul syllables as the case may be.</source>
          <target state="translated">한글 음절 매핑을 재정의하려면 NFD 및 NFKD가 적합하지 않습니다. NFD와 NFKD는 재정의하기 전에 한글 음절을 분해하기 때문입니다. FCD는 경우에 따라 한글 음절을 분해 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c827c3a5508b73a4c675d093f91220233b7dc11" translate="yes" xml:space="preserve">
          <source>If you want to pass arguments to the Perl subroutine, you can add strings to the &lt;code&gt;NULL&lt;/code&gt; -terminated &lt;code&gt;args&lt;/code&gt; list passed to</source>
          <target state="translated">당신은 펄 서브 루틴에 인수를 전달하려는 경우에 문자열을 추가 할 수 있습니다 &lt;code&gt;NULL&lt;/code&gt; 로 끝나는 &lt;code&gt;args&lt;/code&gt; 전달리스트를 이용하여</target>
        </trans-unit>
        <trans-unit id="5c0b08e235edf0d26d308eb349b59ea3ef72cb9d" translate="yes" xml:space="preserve">
          <source>If you want to pass more than one array or hash into a function--or return them from it--and have them maintain their integrity, then you're going to have to use an explicit pass-by-reference. Before you do that, you need to understand references as detailed in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;. This section may not make much sense to you otherwise.</source>
          <target state="translated">둘 이상의 배열이나 해시를 함수에 전달하거나 함수에서 반환하고 무결성을 유지하려면 명시 적 참조 기준을 사용해야합니다. 이를 수행하기 전에 &lt;a href=&quot;perlref&quot;&gt;perlref에&lt;/a&gt; 자세히 설명 된 참조를 이해해야 합니다. 그렇지 않으면이 섹션이 의미가 없을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8a70766df71ba2d4b4ce04954ec69dff30a7c0f" translate="yes" xml:space="preserve">
          <source>If you want to pass switches into your script, you can use one of the &lt;code&gt;Getopts&lt;/code&gt; modules or put a loop on the front like this:</source>
          <target state="translated">스위치를 스크립트에 전달하려면 &lt;code&gt;Getopts&lt;/code&gt; 모듈 중 하나를 사용 하거나 다음과 같이 루프를 앞에 놓을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f4bd2c5192aedd065d255be14f3583448bb4e171" translate="yes" xml:space="preserve">
          <source>If you want to port your own favourite c-lib for big numbers to the Math::BigInt interface, you can take any of the already existing modules as a rough guideline. You should really wrap up the latest BigInt and BigFloat testsuites with your module, and replace in them any of the following:</source>
          <target state="translated">큰 숫자에 대해 좋아하는 c-lib를 Math :: BigInt 인터페이스에 이식하려면 이미 존재하는 모든 모듈을 대략적인 지침으로 사용할 수 있습니다. 최신 BigInt 및 BigFloat 테스트 슈트를 모듈로 마무리하고 다음 중 하나를 교체해야합니다.</target>
        </trans-unit>
        <trans-unit id="376b22a241cce9ba252fd1c8a6df064f6b6eac08" translate="yes" xml:space="preserve">
          <source>If you want to position the file for &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt;, don't use &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, because buffering makes its effect on the file's read-write position unpredictable and non-portable. Use &lt;code&gt;&lt;a href=&quot;functions/sysseek&quot;&gt;sysseek&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; 에 파일을 배치하려면 버퍼링이 파일의 읽기 / 쓰기 위치에 영향을 미치므로 이식 할 수 없으므로 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 를 사용하지 마십시오 . 대신 &lt;code&gt;&lt;a href=&quot;functions/sysseek&quot;&gt;sysseek&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ab53baa73269bc54f793e2d56860c5115ebd11f4" translate="yes" xml:space="preserve">
          <source>If you want to position the file for &lt;code&gt;&lt;a href=&quot;sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt;, don't use &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, because buffering makes its effect on the file's read-write position unpredictable and non-portable. Use &lt;code&gt;&lt;a href=&quot;sysseek&quot;&gt;sysseek&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; 에 파일을 배치하려면 버퍼링이 파일의 읽기 / 쓰기 위치에 영향을 미치므로 이식 할 수 없으므로 &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 를 사용하지 마십시오 . 대신 &lt;code&gt;&lt;a href=&quot;sysseek&quot;&gt;sysseek&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a0c3e6b22044730d55d9a0c06443157660dba6ef" translate="yes" xml:space="preserve">
          <source>If you want to preserve any existing contents, then you want to open the file in append mode. As in the shell, in Perl you use &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; to open an existing file in append mode. &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; creates the file if it does not already exist.</source>
          <target state="translated">기존 내용을 유지하려면 추가 모드에서 파일을 열려고합니다. 쉘에서와 같이 Perl에서 &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; 를 사용하여 추가 모드에서 기존 파일을 엽니 다. &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; 는 파일이 없으면 작성합니다.</target>
        </trans-unit>
        <trans-unit id="17bd731415d5d66dc3d1ddceae18e6e16a628145" translate="yes" xml:space="preserve">
          <source>If you want to preserve the original hashes, copy one hash (&lt;code&gt;%hash1&lt;/code&gt; ) to a new hash (&lt;code&gt;%new_hash&lt;/code&gt; ), then add the keys from the other hash (&lt;code&gt;%hash2&lt;/code&gt; to the new hash. Checking that the key already exists in &lt;code&gt;%new_hash&lt;/code&gt; gives you a chance to decide what to do with the duplicates:</source>
          <target state="translated">원래 해시를 유지하려면, 하나의 해시 (복사 &lt;code&gt;%hash1&lt;/code&gt; 새로운 해시 (에) &lt;code&gt;%new_hash&lt;/code&gt; ), 다음 (다른 해시에서 키를 추가 &lt;code&gt;%hash2&lt;/code&gt; 새로운 해시. 키가 이미 존재한다는 것을 확인 &lt;code&gt;%new_hash&lt;/code&gt; 복제본으로 수행 할 작업을 결정할 수있는 기회를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="50f7b3c025841bfcdb1aab514c8e2d8e36fbc766" translate="yes" xml:space="preserve">
          <source>If you want to print the whole thing, though, you can't say</source>
          <target state="translated">모든 것을 인쇄하고 싶다면 말할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="93f1e3a9ebfe45627e0241306de345142f514db8" translate="yes" xml:space="preserve">
          <source>If you want to provide config to the source you can use:</source>
          <target state="translated">소스에 구성을 제공하려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f3a66952ab51429c329502faae26a704977a338" translate="yes" xml:space="preserve">
          <source>If you want to read a gzip file a line at a time and have it respect the &lt;code&gt;$/&lt;/code&gt; variable (or &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; , or &lt;code&gt;$RS&lt;/code&gt; when &lt;code&gt;English&lt;/code&gt; is in use) see &lt;a href=&quot;../io/uncompress/gunzip&quot;&gt;IO::Uncompress::Gunzip&lt;/a&gt;.</source>
          <target state="translated">gzip 파일을 한 번에 한 줄씩 읽고 &lt;code&gt;$/&lt;/code&gt; 변수 (또는 &lt;code&gt;English&lt;/code&gt; 를 사용하는 경우 &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; 또는 &lt;code&gt;$RS&lt;/code&gt; )를 고려하려면 &lt;a href=&quot;../io/uncompress/gunzip&quot;&gt;IO :: Uncompress :: Gunzip을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7d31f53859a4168c72e90a2128210958319d4f50" translate="yes" xml:space="preserve">
          <source>If you want to read from a text file, first open it in read-only mode like this:</source>
          <target state="translated">텍스트 파일에서 읽으려면 먼저 다음과 같이 읽기 전용 모드로 엽니 다.</target>
        </trans-unit>
        <trans-unit id="d4ab6b15624972e8c18a42d8d83c1cd6a30cfb30" translate="yes" xml:space="preserve">
          <source>If you want to release a 'beta' or 'alpha' version of a module but don't want CPAN.pm to list it as most recent use an '_' after the regular version number followed by at least 2 digits, eg. 1.20_01. If you do this, the following idiom is recommended:</source>
          <target state="translated">모듈의 '베타'또는 '알파'버전을 릴리스하고 싶지만 CPAN.pm이 가장 최신 버전으로 나열하지 않게하려면 정규 버전 번호 뒤에 '_'를 사용하고 그 뒤에 최소 2 자리를 두십시오. 1.20_01. 이렇게하면 다음 관용구가 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="aec7d886a6e5c93bd394402ec290052fc195c585" translate="yes" xml:space="preserve">
          <source>If you want to remove the line terminator from your here-docs, use &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">here-doc에서 줄 종결자를 제거하려면 &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="db615c188722d8560c52e776e317416a34e011c1" translate="yes" xml:space="preserve">
          <source>If you want to report a bug in Perl, you must use the</source>
          <target state="translated">Perl에서 버그를보고하려면</target>
        </trans-unit>
        <trans-unit id="f2154f64aff6e9940c9fb796b1289c8d854d7ca5" translate="yes" xml:space="preserve">
          <source>If you want to represent quotation marks inside a quotation-mark-delimited field, escape them with backslashes (eg, &lt;code&gt;&quot;like \&quot;this\&quot;&quot;&lt;/code&gt; .</source>
          <target state="translated">따옴표로 구분 된 필드 안에 따옴표를 표시하려면 백 슬래시 (예 : &lt;code&gt;&quot;like \&quot;this\&quot;&quot;&lt;/code&gt; 로 따옴표를 이스케이프하십시오 .</target>
        </trans-unit>
        <trans-unit id="824f7654e0ed811f4acc48396871cdac5a94cdda" translate="yes" xml:space="preserve">
          <source>If you want to retain the UTF-x code points then in script form you might want to write:</source>
          <target state="translated">UTF-x 코드 포인트를 유지하려면 스크립트 형식으로 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="2c2c9c1a65a810709ccd4ab8e9bc83e0091df0bc" translate="yes" xml:space="preserve">
          <source>If you want to retrieve the time at which the file was last read, written, or had its meta-data (owner, etc) changed, you use the &lt;b&gt;-A&lt;/b&gt;, &lt;b&gt;-M&lt;/b&gt;, or &lt;b&gt;-C&lt;/b&gt; file test operations as documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;. These retrieve the age of the file (measured against the start-time of your program) in days as a floating point number. Some platforms may not have all of these times. See &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for details. To retrieve the &quot;raw&quot; time in seconds since the epoch, you would call the stat function, then use &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;POSIX::strftime()&lt;/code&gt; to convert this into human-readable form.</source>
          <target state="translated">파일을 마지막으로 읽거나 쓴 시간 또는 메타 데이터 (소유자 등)가 변경된 시간을 검색하려면 &lt;a href=&quot;perlfunc&quot;&gt;perlfunc에&lt;/a&gt; 설명 된대로 &lt;b&gt;-A&lt;/b&gt; , &lt;b&gt;-M&lt;/b&gt; 또는 &lt;b&gt;-C&lt;/b&gt; 파일 테스트 작업 을 사용하십시오 . 이들은 파일의 나이 (프로그램 시작 시간에 대해 측정)를 부동 소수점 숫자로 일 단위로 검색합니다. 일부 플랫폼에는 이러한 시간이 모두 없을 수 있습니다. 자세한 내용은 &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; 를 참조하십시오. 신기원부터 &quot;원시&quot;시간을 초 단위로 검색하려면 stat 함수를 호출 한 다음 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;POSIX::strftime()&lt;/code&gt; 을 사용하여 사람이 읽을 수있는 형식으로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="ea86bc2e0842c32d086b82e0b936c78284136301" translate="yes" xml:space="preserve">
          <source>If you want to run an external command and still keep your Perl process going, look at a piped &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">외부 명령을 실행하고 Perl 프로세스를 계속 진행하려면 파이프 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ec243e8883915ce98e61a2fb629a6bec35df46c" translate="yes" xml:space="preserve">
          <source>If you want to run any of the tests yourself manually using e.g. valgrind, please note that by default perl &lt;b&gt;does not&lt;/b&gt; explicitly cleanup all the memory it has allocated (such as global memory arenas) but instead lets the exit() of the whole program &quot;take care&quot; of such allocations, also known as &quot;global destruction of objects&quot;.</source>
          <target state="translated">예를 들어 valgrind를 사용하여 수동으로 테스트를 실행하려면 기본적으로 perl 이 할당 한 모든 메모리 (예 : 전역 메모리 아레나)를 명시 적으로 정리 &lt;b&gt;하지 않고&lt;/b&gt; 대신 전체 프로그램의 exit ()를 허용합니다. &quot;글로벌 오브젝트 파괴&quot;라고도하는 이러한 할당을 관리하십시오.</target>
        </trans-unit>
        <trans-unit id="c579d4f4691b7da6dbe69f3dde05c84842ed87a2" translate="yes" xml:space="preserve">
          <source>If you want to run particular test files, set the &lt;code&gt;TEST_FILES&lt;/code&gt; variable. It is possible to use globbing with this mechanism.</source>
          <target state="translated">특정 테스트 파일을 실행하려면 &lt;code&gt;TEST_FILES&lt;/code&gt; 변수를 설정하십시오 . 이 메커니즘으로 globbing을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cab446873fde6bc4766b7caa4c1c83cdf5ad957d" translate="yes" xml:space="preserve">
          <source>If you want to see the command History, type an '&lt;b&gt;H&lt;/b&gt;':</source>
          <target state="translated">히스토리 명령을 보려면 ' &lt;b&gt;H&lt;/b&gt; '를 입력하십시오 .</target>
        </trans-unit>
        <trans-unit id="852c71f5265989b791fcb0bad50a31c13ad56ee6" translate="yes" xml:space="preserve">
          <source>If you want to see what perl is doing when parsing/lexing your code, you can use &lt;code&gt;BEGIN {}&lt;/code&gt; :</source>
          <target state="translated">코드를 파싱 / 렉싱 할 때 펄이 무엇을하는지 보려면 &lt;code&gt;BEGIN {}&lt;/code&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3175d2c86530c83d13669e65994d9eb74402053d" translate="yes" xml:space="preserve">
          <source>If you want to see what the parser/lexer is doing inside of &lt;code&gt;if&lt;/code&gt; blocks and the like you need to be a little trickier:</source>
          <target state="translated">파서 / 어휘 분석기가 &lt;code&gt;if&lt;/code&gt; 블록 등에서 수행하는 작업을 보려면 약간 까다로워 야합니다.</target>
        </trans-unit>
        <trans-unit id="8bca41d076fff99126cd66f621ea4770f98d22fe" translate="yes" xml:space="preserve">
          <source>If you want to select on many filehandles, you may wish to write a subroutine like this:</source>
          <target state="translated">많은 파일 핸들을 선택하려면 다음과 같은 서브 루틴을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="933790916a521b582a0514fa93b65b7620fb02f6" translate="yes" xml:space="preserve">
          <source>If you want to separate your lines with something other than &lt;code&gt;\n&lt;/code&gt; then set &lt;code&gt;$Text::Wrap::separator&lt;/code&gt; to your preference. This replaces all newlines with &lt;code&gt;$Text::Wrap::separator&lt;/code&gt; . If you just want to preserve existing newlines but add new breaks with something else, set &lt;code&gt;$Text::Wrap::separator2&lt;/code&gt; instead.</source>
          <target state="translated">당신은 이외로 라인을 구분합니다 &lt;code&gt;\n&lt;/code&gt; 다음 세트 &lt;code&gt;$Text::Wrap::separator&lt;/code&gt; 선호합니다. 모든 줄 바꿈이 &lt;code&gt;$Text::Wrap::separator&lt;/code&gt; 바뀝니다 . 기존 줄 바꿈을 유지하고 다른 줄 바꿈을 추가하려면 대신 &lt;code&gt;$Text::Wrap::separator2&lt;/code&gt; 를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="f22c0f1a9c1e2e9b3f3593f17d9d5d341e79a144" translate="yes" xml:space="preserve">
          <source>If you want to set &lt;code&gt;@ARGV&lt;/code&gt; to your own list of files, go right ahead. This sets &lt;code&gt;@ARGV&lt;/code&gt; to all plain text files if no &lt;code&gt;@ARGV&lt;/code&gt; was given:</source>
          <target state="translated">&lt;code&gt;@ARGV&lt;/code&gt; 를 자신의 파일 목록 으로 설정 하려면 바로 진행하십시오. &lt;code&gt;@ARGV&lt;/code&gt; 를 지정 하지 않은 경우 &lt;code&gt;@ARGV&lt;/code&gt; 를 모든 일반 텍스트 파일로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="c597fab938b142e9f257da003c8529a2b550cc0b" translate="yes" xml:space="preserve">
          <source>If you want to set your encoding layers based on your locale environment variables, you can use the &lt;code&gt;:locale&lt;/code&gt; tag. For example:</source>
          <target state="translated">로캘 환경 변수를 기반으로 인코딩 레이어를 설정하려는 경우 &lt;code&gt;:locale&lt;/code&gt; 태그를 사용할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f93a5a664c0fedc0848a47a9e0bdfdba8a57c6b9" translate="yes" xml:space="preserve">
          <source>If you want to specify perl options &lt;code&gt;-my_opts&lt;/code&gt; to the perl itself (as opposed to your program), use</source>
          <target state="translated">펄 옵션 &lt;code&gt;-my_opts&lt;/code&gt; 를 펄 자체 에 지정 하려면 (프로그램과 반대)</target>
        </trans-unit>
        <trans-unit id="16a2b27e854284e5624b52325615871e56858329" translate="yes" xml:space="preserve">
          <source>If you want to specify the version of Perl, but don't care about the version of the module, pass &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for the module version:</source>
          <target state="translated">Perl의 버전을 지정하고 싶지만 모듈의 버전은 신경 쓰지 않으 려면 모듈 버전에 대해 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 전달 하십시오.</target>
        </trans-unit>
        <trans-unit id="4170c2908419d9f1f4a325cd881e413a4558b490" translate="yes" xml:space="preserve">
          <source>If you want to suppress man page installation for all modules you have to reconfigure Perl and tell it 'none' when it asks where to install man pages.</source>
          <target state="translated">모든 모듈에 대한 매뉴얼 페이지 설치를 억제하려면 Perl을 재구성하고 매뉴얼 페이지를 설치할 위치를 물을 때 '없음'으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="73be2d5223229972e63c46363d25a8b4ecd5d388" translate="yes" xml:space="preserve">
          <source>If you want to take advantage of this new implicit dereferencing behavior, go right ahead: it makes code easier on the eye and wrist. Just understand that older releases will choke on it during compilation. Whenever you make use of something that works only in some given release of Perl and later, but not earlier, you should place a prominent</source>
          <target state="translated">이 새로운 암시 적 역 참조 동작을 활용하려면 눈과 손목에 코드를 더 쉽게 만듭니다. 이전 릴리스는 컴파일하는 동안 질식한다는 것을 이해하십시오. 주어진 Perl 이후 버전에서만 작동하지만 이전 버전에서는 작동하지 않는 것을 사용할 때마다 눈에 잘 띄는 부분을 배치해야합니다.</target>
        </trans-unit>
        <trans-unit id="e1677e0d939fbca31e3c5c86eaef838b1e761cee" translate="yes" xml:space="preserve">
          <source>If you want to take into account the &lt;a href=&quot;bytes&quot;&gt;bytes&lt;/a&gt; pragma, use &lt;code&gt;&lt;a href=&quot;#DO_UTF8&quot;&gt;DO_UTF8&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">&lt;a href=&quot;bytes&quot;&gt;바이트&lt;/a&gt; pragma 를 고려하려면 대신 &lt;code&gt;&lt;a href=&quot;#DO_UTF8&quot;&gt;DO_UTF8&lt;/a&gt;&lt;/code&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="be8af06e2253191bf1cfa1761503b16d4281bf21" translate="yes" xml:space="preserve">
          <source>If you want to trap errors when loading an XS module, some problems with the binary interface (such as Perl version skew) may be fatal even with &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; unless &lt;code&gt;$ENV{PERL_DL_NONLAZY}&lt;/code&gt; is set. See &lt;a href=&quot;../perlrun&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="translated">XS 모듈을로드 할 때 오류를 &lt;code&gt;$ENV{PERL_DL_NONLAZY}&lt;/code&gt; 를 설정 하지 않으면 이진 인터페이스의 일부 문제 (예 : Perl 버전 스큐)가 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 에서도 치명적일 수 있습니다 . &lt;a href=&quot;../perlrun&quot;&gt;perlrun을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7dc2a0aef2f5b8c2b438b365b49a4c2f0d40f6ac" translate="yes" xml:space="preserve">
          <source>If you want to trap errors when loading an XS module, some problems with the binary interface (such as Perl version skew) may be fatal even with &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; unless &lt;code&gt;$ENV{PERL_DL_NONLAZY}&lt;/code&gt; is set. See &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="translated">XS 모듈을로드 할 때 오류를 &lt;code&gt;$ENV{PERL_DL_NONLAZY}&lt;/code&gt; 를 설정 하지 않으면 이진 인터페이스의 일부 문제 (예 : Perl 버전 스큐)가 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 에서도 치명적일 수 있습니다 . &lt;a href=&quot;perlrun&quot;&gt;perlrun을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b6ffd07b12749a1692d47d579873dc74d6c4dfaf" translate="yes" xml:space="preserve">
          <source>If you want to try to install a distribution by yourself, resolving all dependencies on your own, you follow one of two possible build paths.</source>
          <target state="translated">직접 배포를 설치하고 모든 종속성을 스스로 해결하려는 경우 가능한 두 가지 빌드 경로 중 하나를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="fbe14747549d8ad4516b4e89ba086fe45d5bc952" translate="yes" xml:space="preserve">
          <source>If you want to use &lt;code&gt;$.&lt;/code&gt; , you can reduce it to a simple one-liner, like one of these:</source>
          <target state="translated">&lt;code&gt;$.&lt;/code&gt; 를 사용하려면 , 다음 중 하나와 같이 간단한 단일 라이너로 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="638caf8fdb384503ed24e0af4c2fa1fdaedcfe89" translate="yes" xml:space="preserve">
          <source>If you want to use &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; to time out a system call you need to use an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; pair. You can't rely on the alarm causing the system call to fail with &lt;code&gt;$!&lt;/code&gt; set to &lt;code&gt;EINTR&lt;/code&gt; because Perl sets up signal handlers to restart system calls on some systems. Using &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; always works, modulo the caveats given in &lt;a href=&quot;../perlipc#Signals&quot;&gt;Signals in perlipc&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 을 사용 하여 시스템 호출 시간을 초과하려면 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 쌍 을 사용해야합니다 . 시스템 호출이 &lt;code&gt;$!&lt;/code&gt; 로 실패하게하는 경보에 의존 할 수 없습니다 . 로 설정 &lt;code&gt;EINTR&lt;/code&gt; 는 펄은 일부 시스템 재시작 시스템 호출에 신호 핸들러를 설정하기 때문이다. &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 를 사용하면 항상 작동 &lt;a href=&quot;../perlipc#Signals&quot;&gt;하며 perlipc의 신호에&lt;/a&gt; 주어진주의 사항 을 모듈화 합니다.</target>
        </trans-unit>
        <trans-unit id="47fc081d4f98f1098211a1c78312dbb51873804c" translate="yes" xml:space="preserve">
          <source>If you want to use &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; to time out a system call you need to use an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; pair. You can't rely on the alarm causing the system call to fail with &lt;code&gt;$!&lt;/code&gt; set to &lt;code&gt;EINTR&lt;/code&gt; because Perl sets up signal handlers to restart system calls on some systems. Using &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; always works, modulo the caveats given in &lt;a href=&quot;perlipc#Signals&quot;&gt;Signals in perlipc&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 을 사용 하여 시스템 호출 시간을 초과하려면 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 쌍 을 사용해야합니다 . 시스템 호출이 &lt;code&gt;$!&lt;/code&gt; 로 실패하게하는 경보에 의존 할 수 없습니다 . 로 설정 &lt;code&gt;EINTR&lt;/code&gt; 는 펄은 일부 시스템 재시작 시스템 호출에 신호 핸들러를 설정하기 때문이다. &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 를 사용하면 항상 작동 &lt;a href=&quot;perlipc#Signals&quot;&gt;하며 perlipc의 신호에&lt;/a&gt; 주어진주의 사항 을 모듈화 합니다.</target>
        </trans-unit>
        <trans-unit id="95a0ee4afc73cc3c28bb4ee34fc5e5c78c608e7d" translate="yes" xml:space="preserve">
          <source>If you want to use Perl on a non-z/OS EBCDIC machine, please let us know by sending mail to perlbug@perl.org</source>
          <target state="translated">비 z / OS EBCDIC 시스템에서 Perl을 사용하려는 경우 perlbug@perl.org로 메일을 보내 알려주십시오.</target>
        </trans-unit>
        <trans-unit id="e5b580ca1f65ec0f5a604fbeb668e8741070d520" translate="yes" xml:space="preserve">
          <source>If you want to use Perl on the Hurd, I recommend using the Debian GNU/Hurd distribution ( see &lt;a href=&quot;http://www.debian.org/&quot;&gt;http://www.debian.org/&lt;/a&gt; ), even if an official, stable release has not yet been made. The old &quot;gnu-0.2&quot; binary distribution will most certainly have additional problems.</source>
          <target state="translated">Hurd에서 Perl을 사용 하려면 공식적이고 안정적인 릴리스가 아직 이루어지지 않았더라도 데비안 GNU / Hurd 배포판 ( &lt;a href=&quot;http://www.debian.org/&quot;&gt;http://www.debian.org/ 참조&lt;/a&gt; )을 사용하는 것이 좋습니다 . 구 &quot;gnu-0.2&quot;바이너리 배포판에는 추가 문제가있을 것입니다.</target>
        </trans-unit>
        <trans-unit id="7687d514ed5fdcc15efde5d3bf9ba63b53f53add" translate="yes" xml:space="preserve">
          <source>If you want to use a module, try the &lt;code&gt;uniq&lt;/code&gt; function from &lt;a href=&quot;http://search.cpan.org/perldoc/List::MoreUtils&quot;&gt;List::MoreUtils&lt;/a&gt;. In list context it returns the unique elements, preserving their order in the list. In scalar context, it returns the number of unique elements.</source>
          <target state="translated">모듈을 사용하려면 &lt;a href=&quot;http://search.cpan.org/perldoc/List::MoreUtils&quot;&gt;List :: MoreUtils&lt;/a&gt; 에서 &lt;code&gt;uniq&lt;/code&gt; 기능을 사용해보십시오 . 목록 컨텍스트에서 목록에서 순서를 유지하면서 고유 한 요소를 반환합니다. 스칼라 컨텍스트에서 고유 한 요소 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="655bd3463f5ce3b5ada699426719c6ddc69d4f2a" translate="yes" xml:space="preserve">
          <source>If you want to use multiple patterns, e.g. &lt;code&gt;bsd_glob(&quot;a* b*&quot;)&lt;/code&gt; , you should probably throw them in a set as in &lt;code&gt;bsd_glob(&quot;{a*,b*}&quot;)&lt;/code&gt; . This is because the argument to bsd_glob() isn't subjected to parsing by the C shell. Remember that you can use a backslash to escape things.</source>
          <target state="translated">&lt;code&gt;bsd_glob(&quot;a* b*&quot;)&lt;/code&gt; 와 같은 여러 패턴을 사용하려면 &lt;code&gt;bsd_glob(&quot;{a*,b*}&quot;)&lt;/code&gt; 와 같이 세트로 던져야합니다 . bsd_glob ()에 대한 인수는 C 쉘에 의해 구문 분석되지 않기 때문입니다. 백 슬래시를 사용하여 사물을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="daaf83327da114b41b8c24aa71d08a4f5617620d" translate="yes" xml:space="preserve">
          <source>If you want to use non-ASCII bytes (outside the bytes 0x00..0x7f) in the &quot;source code&quot; of your code, to be portable you have to be explicit about what bytes they are. Someone might for example be using your code under a UTF-8 locale, in which case random native bytes might be illegal (&quot;Malformed UTF-8 ...&quot;) This means that for example embedding ISO 8859-1 bytes beyond 0x7f into your strings might cause trouble later. If the bytes are native 8-bit bytes, you can use the &lt;code&gt;bytes&lt;/code&gt; pragma. If the bytes are in a string (regular expressions being curious strings), you can often also use the &lt;code&gt;\xHH&lt;/code&gt; or more portably, the &lt;code&gt;\N{U+HH}&lt;/code&gt; notations instead of embedding the bytes as-is. If you want to write your code in UTF-8, you can use &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt;.</source>
          <target state="translated">코드의 &quot;소스 코드&quot;에서 비 ASCII 바이트 (바이트 0x00..0x7f 외부)를 사용하려면 이식성을 유지하기 위해 어떤 바이트인지 명시해야합니다. 예를 들어 누군가 UTF-8 로캘에서 코드를 사용하는 경우 임의의 원시 바이트가 유효하지 않을 수 있습니다 ( &quot;잘못된 UTF-8 ...&quot;). 예를 들어 ISO 8859-1 바이트를 0x7f를 넘어서 문자열은 나중에 문제를 일으킬 수 있습니다. 바이트가 기본 8 비트 바이트 인 경우 &lt;code&gt;bytes&lt;/code&gt; pragma를 사용할 수 있습니다 . 바이트가 문자열 (호기심 문자열 인 정규식)에있는 경우 , 바이트를 그대로 임베드하는 대신 &lt;code&gt;\xHH&lt;/code&gt; 이상을 사용 하여 &lt;code&gt;\N{U+HH}&lt;/code&gt; 표기법을 사용할 수도 있습니다 . UTF-8로 코드를 작성하려면 &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bfe339f2912f8f17fbf2b42472a9d509e3a576bf" translate="yes" xml:space="preserve">
          <source>If you want to use the same literal digits (644) in Perl, you have to tell Perl to treat them as octal numbers either by prefixing the digits with a &lt;code&gt;0&lt;/code&gt; or using &lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Perl에서 동일한 리터럴 숫자 (644)를 사용하려면 Perl에게 숫자 앞에 &lt;code&gt;0&lt;/code&gt; 을 &lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt; 거나 oct를 사용하여 8 진수로 처리하도록 지시해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ee36968e514e749df3ac1a70b3903aee1ab0ec1b" translate="yes" xml:space="preserve">
          <source>If you want to use threads, you should primarily use the Perl 5.8.0 threads model by running Configure with -Duseithreads.</source>
          <target state="translated">스레드를 사용하려면 주로 -Duseithreads로 구성을 실행하여 Perl 5.8.0 스레드 모델을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f0b79aac4ab0e44b3e5cf20ea8795f9b26be612e" translate="yes" xml:space="preserve">
          <source>If you want to work with comma-separated values, don't do this since that format is a bit more complicated. Use one of the modules that handle that format, such as &lt;a href=&quot;http://search.cpan.org/perldoc/Text::CSV&quot;&gt;Text::CSV&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Text::CSV_XS&quot;&gt;Text::CSV_XS&lt;/a&gt;, or &lt;a href=&quot;http://search.cpan.org/perldoc/Text::CSV_PP&quot;&gt;Text::CSV_PP&lt;/a&gt;.</source>
          <target state="translated">쉼표로 구분 된 값으로 작업하려면 해당 형식이 조금 더 복잡하므로이 작업을 수행하지 마십시오. 해당 형식을 처리하는 모듈 중 하나 (예 : &lt;a href=&quot;http://search.cpan.org/perldoc/Text::CSV&quot;&gt;Text :: CSV&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Text::CSV_XS&quot;&gt;Text :: CSV_XS&lt;/a&gt; 또는 &lt;a href=&quot;http://search.cpan.org/perldoc/Text::CSV_PP&quot;&gt;Text :: CSV_PP)를 사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="37acc7e93925635a2960bac98f19ec762c55738f" translate="yes" xml:space="preserve">
          <source>If you want to work with formatted dates, the &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Manip&quot;&gt;Date::Manip&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;Date::Calc&lt;/a&gt;, or &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; modules can help you.</source>
          <target state="translated">형식이 지정된 날짜로 작업하려는 경우 &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Manip&quot;&gt;Date :: Manip&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;Date :: Calc&lt;/a&gt; 또는 &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; 모듈이 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c337db840462e094257c46f34c19710018f93799" translate="yes" xml:space="preserve">
          <source>If you want to write to an existing SV's buffer and set its value to a string, use SvPV_force() or one of its variants to force the SV to be a PV. This will remove any of various types of non-stringness from the SV while preserving the content of the SV in the PV. This can be used, for example, to append data from an API function to a buffer without extra copying:</source>
          <target state="translated">기존 SV의 버퍼에 쓰고 값을 문자열로 설정하려면 SvPV_force () 또는 변형 중 하나를 사용하여 SV를 PV로 만듭니다. 이렇게하면 PV에서 SV의 내용을 유지하면서 SV에서 다양한 유형의 비 스트링 성을 제거합니다. 예를 들어, 추가 복사없이 API 함수의 데이터를 버퍼에 추가하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17fab6cd5cfc4d3a8699ee4d492a9132990d5dbf" translate="yes" xml:space="preserve">
          <source>If you want to zap all predefined aliases, you can use</source>
          <target state="translated">사전 정의 된 모든 별칭을 zap하려는 경우</target>
        </trans-unit>
        <trans-unit id="6dad17422598919d77ad32018e1ee73ac029ac1c" translate="yes" xml:space="preserve">
          <source>If you want your code to be portable, your format (&lt;code&gt;fmt&lt;/code&gt; ) argument should use only the conversion specifiers defined by the ANSI C standard (C89, to play safe). These are &lt;code&gt;aAbBcdHIjmMpSUwWxXyYZ%&lt;/code&gt; . But even then, the &lt;b&gt;results&lt;/b&gt; of some of the conversion specifiers are non-portable. For example, the specifiers &lt;code&gt;aAbBcpZ&lt;/code&gt; change according to the locale settings of the user, and both how to set locales (the locale names) and what output to expect are non-standard. The specifier &lt;code&gt;c&lt;/code&gt; changes according to the timezone settings of the user and the timezone computation rules of the operating system. The &lt;code&gt;Z&lt;/code&gt; specifier is notoriously unportable since the names of timezones are non-standard. Sticking to the numeric specifiers is the safest route.</source>
          <target state="translated">코드를 이식 가능하게하려면 형식 ( &lt;code&gt;fmt&lt;/code&gt; ) 인수는 ANSI C 표준 (C89, 안전 재생)으로 정의 된 변환 지정자 만 사용해야합니다. 이들은 &lt;code&gt;aAbBcdHIjmMpSUwWxXyYZ%&lt;/code&gt; 입니다. 그러나 그럼에도 불구하고 일부 변환 지정자 의 &lt;b&gt;결과&lt;/b&gt; 는 이식성이 없습니다. 예를 들어, 지정자 &lt;code&gt;aAbBcpZ&lt;/code&gt; 는 사용자의 로케일 설정 및 로케일 설정 방법 (로케일 이름)과 예상되는 출력이 비표준 인 경우에 따라 변경됩니다. 지정자 &lt;code&gt;c&lt;/code&gt; 는 사용자의 시간대 설정 및 운영 체제의 시간대 계산 규칙에 따라 변경됩니다. &lt;code&gt;Z&lt;/code&gt; 시간대 이름이 표준이 아니기 때문에 지정자는 이식성이 떨어집니다. 숫자 지정자를 고수하는 것이 가장 안전한 경로입니다.</target>
        </trans-unit>
        <trans-unit id="b8922cb8873f110b4ceb1333b3f31e99ca5b2eb1" translate="yes" xml:space="preserve">
          <source>If you want your encoding to work with &lt;a href=&quot;../encoding&quot;&gt;encoding&lt;/a&gt; pragma, you should also implement the method below.</source>
          <target state="translated">인코딩이 &lt;a href=&quot;../encoding&quot;&gt;인코딩&lt;/a&gt; pragma 와 작동하도록 하려면 아래 방법도 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="e7210c4e7ce82b46e9e62a14e14a71ab868752cc" translate="yes" xml:space="preserve">
          <source>If you want your here-docs to be indented with the rest of the code, you'll need to remove leading whitespace from each line manually:</source>
          <target state="translated">here-docs가 나머지 코드와 함께 들여 쓰려면 각 줄에서 선행 공백을 수동으로 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="eb763454ad4db2bd6193f7e99d444faca44a82eb" translate="yes" xml:space="preserve">
          <source>If you want your program to be compatible with versions of Perl before 5.20, you must use &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings FATAL =&amp;gt; 'all';&lt;/code&gt; instead. (In previous versions of Perl, the behavior of the statements &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'FATAL';&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'NONFATAL';&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'FATAL';&lt;/code&gt; was unspecified; they did not behave as if they included the &lt;code&gt;=&amp;gt; 'all'&lt;/code&gt; portion. As of 5.20, they do.)</source>
          <target state="translated">프로그램이 5.20 이전의 Perl 버전과 호환되도록하려면 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings FATAL =&amp;gt; 'all';&lt;/code&gt; 를 사용해야합니다. FATAL =&amp;gt; 'all'; 대신에. (펄의 이전 버전에서는 문장의 동작은 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'FATAL';&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'NONFATAL';&lt;/code&gt; 그리고 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'FATAL';&lt;/code&gt; 지정되지 않았다, 그들은 포함 된 것처럼 그들이 행동하지 않았다 &lt;code&gt;=&amp;gt; 'all'&lt;/code&gt; 부분을 5.20부터는 가능합니다.)</target>
        </trans-unit>
        <trans-unit id="3d68917c192fee56b1141df74b8f16f9fa5100fe" translate="yes" xml:space="preserve">
          <source>If you want, you may make low-level pipe() and fork() syscalls to stitch this together by hand. This example only talks to itself, but you could reopen the appropriate handles to STDIN and STDOUT and call other processes. (The following example lacks proper error checking.)</source>
          <target state="translated">원하는 경우 하위 수준의 pipe () 및 fork () syscall을 만들어이를 함께 손으로 연결할 수 있습니다. 이 예제는 그 자체 만 설명하지만 STDIN 및 STDOUT에 대한 적절한 핸들을 다시 열고 다른 프로세스를 호출 할 수 있습니다. (다음 예에는 적절한 오류 검사가 없습니다.)</target>
        </trans-unit>
        <trans-unit id="9a78398c052f882736bece8b1553a1b8e0dc056b" translate="yes" xml:space="preserve">
          <source>If you wanted just to append to a row, you'd have to do something a bit funnier looking:</source>
          <target state="translated">행에 추가하기를 원한다면 조금 더 재미있는 것을해야합니다.</target>
        </trans-unit>
        <trans-unit id="2260da4124856b0020df29775382e24cb7c28087" translate="yes" xml:space="preserve">
          <source>If you wanted text and not lines, you would use</source>
          <target state="translated">줄이 아닌 텍스트를 원한다면</target>
        </trans-unit>
        <trans-unit id="b649b444ce3825b2b868566f3609222a2cd25baa" translate="yes" xml:space="preserve">
          <source>If you wanted the commas preserved as separate fields (i.e. like split does if your split pattern has capturing parentheses), you would just make the last parameter undefined (or remove it).</source>
          <target state="translated">쉼표를 별도의 필드로 유지하려면 (예 : 분할 패턴에 괄호가있는 경우 분할과 같이) 마지막 매개 변수를 정의하지 않거나 제거하면됩니다.</target>
        </trans-unit>
        <trans-unit id="5fba67ea1fbf1509f7d61f0bae5321559a412330" translate="yes" xml:space="preserve">
          <source>If you wanted to do the same thing for lines, you wouldn't need a regular expression:</source>
          <target state="translated">라인에 대해 동일한 작업을 수행하려는 경우 정규 표현식이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ed640c7d7a4ae2cd65ac815fdaa4ce3af7479470" translate="yes" xml:space="preserve">
          <source>If you wanted to have a $ref_to_AoA variable as a reference to an array, you'd have to do something like this:</source>
          <target state="translated">배열에 대한 참조로 $ ref_to_AoA 변수를 사용하려면 다음과 같이해야합니다.</target>
        </trans-unit>
        <trans-unit id="fed8c5d580fcbca1e699420a58d9ad3cd67321fd" translate="yes" xml:space="preserve">
          <source>If you wanted to keep track of subscripts, you might do this:</source>
          <target state="translated">아래 첨자를 추적하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="fbf69379e2b3dc67cd59111850ee63e9c65dd9db" translate="yes" xml:space="preserve">
          <source>If you wanted to see the inverse tables, you would first have to sort on the desired numbers column as in recipes 4, 5 or 6, then take the output of the first numbers column.</source>
          <target state="translated">역 테이블을 보려면 레시피 4, 5 또는 6에서와 같이 원하는 숫자 열을 먼저 정렬 한 다음 첫 번째 숫자 열의 출력을 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="1d598a9db20ad75da95def7772f5c1aab9645a1d" translate="yes" xml:space="preserve">
          <source>If you were into Schwartzian Transforms, you would probably have selected map for that</source>
          <target state="translated">Schwartzian Transforms에 있다면 아마도 그에 대한 맵을 선택했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="ad840be29267c1ff305e523c8e88cf5317d35dc5" translate="yes" xml:space="preserve">
          <source>If you were to set &lt;code&gt;$b[3] = 4&lt;/code&gt; , then instead of reporting that &quot;a and b are deep copies of each other&quot;, it now reports that &lt;code&gt;&quot;b smartmatches in a&quot;&lt;/code&gt; . That's because the corresponding position in &lt;code&gt;@a&lt;/code&gt; contains an array that (eventually) has a 4 in it.</source>
          <target state="translated">&lt;code&gt;$b[3] = 4&lt;/code&gt; 로 설정 한 경우 &quot;a와 b는 서로의 깊은 사본입니다&quot;라고보고하는 대신 &lt;code&gt;&quot;b smartmatches in a&quot;&lt;/code&gt; 보고합니다 . &lt;code&gt;@a&lt;/code&gt; 의 해당 위치에 (최종적으로) 4가있는 배열이 포함되어 있기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="25e66b6a4d3408c5b81e396702004bd84b8fbf9d" translate="yes" xml:space="preserve">
          <source>If you wish to compile with the Socket extension, you need to have the TCP/IP toolkit, and you need to make sure that -lsocket locates the correct copy of socket3r.lib. Beware that the Watcom compiler ships with a stub version of socket3r.lib which has very little functionality. Also beware the order in which wlink searches directories for libraries. You may have /usr/lib/socket3r.lib pointing to the correct library, but wlink may pick up /usr/watcom/10.6/usr/lib/socket3r.lib instead. Make sure they both point to the correct library, that is, /usr/tcptk/current/usr/lib/socket3r.lib.</source>
          <target state="translated">소켓 확장으로 컴파일하려면 TCP / IP 툴킷이 있어야하며 -lsocket이 올바른 socket3r.lib 사본을 찾도록해야합니다. Watcom 컴파일러는 기능이 거의없는 스텁 버전의 socket3r.lib와 함께 제공됩니다. 또한 wlink가 디렉토리에서 라이브러리를 검색하는 순서를주의하십시오. 올바른 라이브러리를 가리키는 /usr/lib/socket3r.lib가있을 수 있지만 wlink는 대신 /usr/watcom/10.6/usr/lib/socket3r.lib를 선택할 수 있습니다. 둘 다 올바른 라이브러리, 즉 /usr/tcptk/current/usr/lib/socket3r.lib를 가리키는 지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="743a9842bd7eb1c587a8ceb73e47cc40eff3e0ec" translate="yes" xml:space="preserve">
          <source>If you wish to install perl versions for all architectures (68020, mips, sparc and 386) run:</source>
          <target state="translated">모든 아키텍처 (68020, mips, sparc 및 386)에 perl 버전을 설치하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="fe0f0e4408b545cb1ecebca491d9be266bb67e8f" translate="yes" xml:space="preserve">
          <source>If you wish to supply an alternative debugger for Perl to run, invoke your script with a colon and a package argument given to the &lt;b&gt;-d&lt;/b&gt; flag. Perl's alternative debuggers include a Perl profiler, &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::NYTProf&quot;&gt;Devel::NYTProf&lt;/a&gt;, which is available separately as a CPAN distribution. To profile your Perl program in the file</source>
          <target state="translated">Perl이 실행할 대체 디버거를 제공하려면, &lt;b&gt;-d&lt;/b&gt; 플래그에 지정된 콜론과 패키지 인수를 사용하여 스크립트를 호출하십시오 . Perl의 대체 디버거에는 Perl 프로파일 러 인 &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::NYTProf&quot;&gt;Devel :: NYTProf&lt;/a&gt; 가 포함되며 CPAN 배포판으로 별도로 제공됩니다. 파일에서 Perl 프로그램을 프로파일 링하려면</target>
        </trans-unit>
        <trans-unit id="b105ef1f647cb2687215fb2803b65285f6c51529" translate="yes" xml:space="preserve">
          <source>If you wish to turn an entire POD document into a parse-tree, that process is fairly straightforward. The &lt;b&gt;parse_text()&lt;/b&gt; method is the key to doing this successfully. Every paragraph-callback (i.e. the polymorphic methods for &lt;b&gt;command()&lt;/b&gt;, &lt;b&gt;verbatim()&lt;/b&gt;, and &lt;b&gt;textblock()&lt;/b&gt; paragraphs) takes a &lt;b&gt;Pod::Paragraph&lt;/b&gt; object as an argument. Each paragraph object has a &lt;b&gt;parse_tree()&lt;/b&gt; method that can be used to get or set a corresponding parse-tree. So for each of those paragraph-callback methods, simply call &lt;b&gt;parse_text()&lt;/b&gt; with the options you desire, and then use the returned parse-tree to assign to the given paragraph object.</source>
          <target state="translated">전체 POD 문서를 구문 분석 트리로 바꾸려면 해당 프로세스가 매우 간단합니다. &lt;b&gt;parse_text ()&lt;/b&gt; 메소드는 성공적으로이 일의 핵심입니다. 모든 단락 콜백 (즉, &lt;b&gt;command ()&lt;/b&gt; , &lt;b&gt;verbatim ()&lt;/b&gt; 및 &lt;b&gt;textblock ()&lt;/b&gt; 단락 의 다형성 메서드 )은 &lt;b&gt;Pod :: Paragraph&lt;/b&gt; 객체를 인수로 사용합니다. 각 단락 객체에는 해당 구문 분석 트리를 가져 오거나 설정하는 데 사용할 수 있는 &lt;b&gt;parse_tree ()&lt;/b&gt; 메서드가 있습니다. 따라서 각 단락 콜백 메소드에 대해 원하는 옵션으로 &lt;b&gt;parse_text ()&lt;/b&gt; 를 호출 한 다음 반환 된 구문 분석 트리를 사용하여 주어진 단락 객체에 할당하십시오.</target>
        </trans-unit>
        <trans-unit id="77c82d86f4fb285fcd145d9c870b966041509421" translate="yes" xml:space="preserve">
          <source>If you wish to use GNU ld, then you need to pass it the -Wl,-E flag. The hints/solaris_2.sh file tries to do this automatically by setting the following Configure variables:</source>
          <target state="translated">GNU ld를 사용하려면 -Wl, -E 플래그를 전달해야합니다. hints / solaris_2.sh 파일은 다음 구성 변수를 설정하여 자동으로이를 시도합니다.</target>
        </trans-unit>
        <trans-unit id="5c10ef4b4d7cf77ba9367b0a5ba13535a2314b3d" translate="yes" xml:space="preserve">
          <source>If you wish to use gcc to build add-on modules for use with the perl shipped with Solaris, you should use the Solaris::PerlGcc module which is available from CPAN. The perl shipped with Solaris is configured and built with the Sun compilers, and the compiler configuration information stored in Config.pm is therefore only relevant to the Sun compilers. The Solaris:PerlGcc module contains a replacement Config.pm that is correct for gcc - see the module for details.</source>
          <target state="translated">gcc를 사용하여 Solaris와 함께 제공된 perl과 함께 사용할 애드온 모듈을 구축하려면 CPAN에서 제공하는 Solaris :: PerlGcc 모듈을 사용해야합니다. Solaris와 함께 제공된 perl은 Sun 컴파일러와 함께 구성 및 빌드되므로 Config.pm에 저장된 컴파일러 구성 정보는 Sun 컴파일러와 만 관련이 있습니다. Solaris : PerlGcc 모듈에는 gcc에 맞는 교체 용 Config.pm이 포함되어 있습니다. 자세한 내용은 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="461c22560c9b4e2d096c9a209fc41fbc9b8e1805" translate="yes" xml:space="preserve">
          <source>If you wonder what complex numbers are, they were invented to be able to solve the following equation:</source>
          <target state="translated">복잡한 숫자가 무엇인지 궁금하다면 다음 방정식을 풀 수 있도록 발명되었습니다.</target>
        </trans-unit>
        <trans-unit id="58f2be2cb41014bdf8c7d1f6da3d5ed7b3a57878" translate="yes" xml:space="preserve">
          <source>If you wonder why defaults for conversion are different for str() and num(), note how easy it was to write the symbolic calculator. This simplicity is due to an appropriate choice of defaults. One extra note: due to the explicit recursion num() is more fragile than sym(): we need to explicitly check for the type of $a and $b. If components $a and $b happen to be of some related type, this may lead to problems.</source>
          <target state="translated">str () 및 num ()의 변환 기본값이 다른 이유가 궁금하다면 기호 계산기를 작성하는 것이 얼마나 쉬운 지 참고하십시오. 이 단순성은 적절한 기본값 선택으로 인한 것입니다. 한 가지 추가 참고 사항 : 명시 적 재귀로 인해 num ()은 sym ()보다 취약합니다. $ a 및 $ b의 유형을 명시 적으로 확인해야합니다. 구성 요소 $ a 및 $ b가 관련된 유형 인 경우 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f88d82472c17285676b32563ec0b930b79f27b19" translate="yes" xml:space="preserve">
          <source>If you would like to know about a version dependency before you start running the program, put something like this at its top:</source>
          <target state="translated">프로그램 실행을 시작하기 전에 버전 종속성에 대해 알고 싶다면 맨 위에 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="c3bc63e78a724b45aa4c8fcf7d5d3a90c3663440" translate="yes" xml:space="preserve">
          <source>If you would like to print out a lot of man page continuously, you probably want to set the C and D registers to set contiguous page numbering and even/odd paging, at least on some versions of man(7).</source>
          <target state="translated">많은 매뉴얼 페이지를 지속적으로 인쇄하려면 적어도 일부 버전의 man (7)에서 연속적인 페이지 번호 매기기 및 짝수 / 홀수 페이징을 설정하도록 C 및 D 레지스터를 설정하려고합니다.</target>
        </trans-unit>
        <trans-unit id="4e270feabb28d65fb97bce6b5a62077129b3eed4" translate="yes" xml:space="preserve">
          <source>If you would rather see it in CCSID 1047 order then change the number 34 in the last line to 39, like this:</source>
          <target state="translated">CCSID 1047 순서로 표시하려면 마지막 행에서 34를 다음과 같이 39로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="7ab3cc4dd9f42b386f286d85d40432c48d4dbc0d" translate="yes" xml:space="preserve">
          <source>If you would rather see it in POSIX-BC order then change the number 34 in the last line to 44, like this:</source>
          <target state="translated">POSIX-BC 순서로 보려는 경우 마지막 줄의 숫자 34를 다음과 같이 44로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="4685079e88ddb435b412b9c5b1c049410dc612d3" translate="yes" xml:space="preserve">
          <source>If you would rather see the above table in CCSID 0037 order rather than ASCII + Latin-1 order then run the table through:</source>
          <target state="translated">ASCII + Latin-1 순서가 아닌 CCSID 0037 순서로 위의 표를 보려면 다음을 통해 표를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="32ccbee06ab47d2346ade36365b388768fa75f8c" translate="yes" xml:space="preserve">
          <source>If you would rather see this table listing hexadecimal values then run the table through:</source>
          <target state="translated">16 진 값을 나열하는이 테이블을 보려면 다음을 통해 테이블을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="ee951a76c16a66932dc3802ba31a24c5d5d45366" translate="yes" xml:space="preserve">
          <source>If you write just &lt;code&gt;[]&lt;/code&gt; , you get a new, empty anonymous array. If you write just &lt;code&gt;{}&lt;/code&gt; , you get a new, empty anonymous hash.</source>
          <target state="translated">&lt;code&gt;[]&lt;/code&gt; 만 쓰면 비어있는 새 익명 배열이 생깁니다. &lt;code&gt;{}&lt;/code&gt; 만 쓰면 비어있는 새 익명 해시가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="6e5ce930a64c177374e0a87543a2b84b1ca0633d" translate="yes" xml:space="preserve">
          <source>If you write your own test, use the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2ftestanything.org&quot;&gt;Test Anything Protocol&lt;/a&gt;.</source>
          <target state="translated">자체 테스트를 작성하는 경우 &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2ftestanything.org&quot;&gt;Test Anything Protocol을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b4b7f29b396f8216559006548d8b8987bccc01b5" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re a C or C++ programmer, you might be looking for Perl&amp;rsquo;s &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; keyword.</source>
          <target state="translated">C 또는 C ++ 프로그래머라면 Perl의 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 키워드를 찾고있을 것 입니다.</target>
        </trans-unit>
        <trans-unit id="65480a92112439353360a0f2410e7e3031db6948" translate="yes" xml:space="preserve">
          <source>If you'd like a graphical user interface and you have &lt;a href=&quot;http://search.cpan.org/perldoc/Tk&quot;&gt;Tk&lt;/a&gt;, you can use &lt;code&gt;ptkdb&lt;/code&gt; . It's on CPAN and available for free.</source>
          <target state="translated">그래픽 사용자 인터페이스가 필요하고 &lt;a href=&quot;http://search.cpan.org/perldoc/Tk&quot;&gt;Tk가&lt;/a&gt; 있는 경우 &lt;code&gt;ptkdb&lt;/code&gt; 를 사용할 수 있습니다 . CPAN에 있으며 무료로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="c82ff6955ec720dbffdb6e597947e26e8c52b3d3" translate="yes" xml:space="preserve">
          <source>If you'd like to disable the use of one or more of these utilities and/or modules, see the &lt;code&gt;$BLACKLIST&lt;/code&gt; variable further down.</source>
          <target state="translated">이러한 유틸리티 및 / 또는 모듈 중 하나 이상을 사용하지 않으려면 &lt;code&gt;$BLACKLIST&lt;/code&gt; 변수를 자세히 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="52486225415552ac3d601c87ba41d238a14d5679" translate="yes" xml:space="preserve">
          <source>If you'd like to make &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; (and many other bits of Perl) die on error, have a look at the &lt;a href=&quot;autodie&quot;&gt;autodie&lt;/a&gt; pragma.</source>
          <target state="translated">당신이 만드는하려는 경우 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; (펄의 많은 다른 비트), 오류에 죽을 번 봐 가지고 &lt;a href=&quot;autodie&quot;&gt;autodie&lt;/a&gt; 프라그 마를.</target>
        </trans-unit>
        <trans-unit id="1efbce8f9e88ed4ba8cc94bb84af468b14e5c10a" translate="yes" xml:space="preserve">
          <source>If you'd like to make &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; (and many other bits of Perl) die on error, have a look at the &lt;a href=&quot;../autodie&quot;&gt;autodie&lt;/a&gt; pragma.</source>
          <target state="translated">당신이 만드는하려는 경우 &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; (펄의 많은 다른 비트), 오류에 죽을 번 봐 가지고 &lt;a href=&quot;../autodie&quot;&gt;autodie&lt;/a&gt; 프라그 마를.</target>
        </trans-unit>
        <trans-unit id="73a95e0734804b8dcc4d934eb0b4ac64271a89fa" translate="yes" xml:space="preserve">
          <source>If you'd like to manually inspect &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;'s failure, you can check all possible failure modes by inspecting &lt;code&gt;$?&lt;/code&gt; like this:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 장애 를 수동으로 검사 하려면 &lt;code&gt;$?&lt;/code&gt; 를 검사하여 가능한 모든 장애 모드를 확인할 수 있습니다 . 이처럼 :</target>
        </trans-unit>
        <trans-unit id="c50262b9b752d6c3a022a1f95bc5efa143b999d6" translate="yes" xml:space="preserve">
          <source>If you'd like to manually inspect &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;'s failure, you can check all possible failure modes by inspecting &lt;code&gt;$?&lt;/code&gt; like this:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 장애 를 수동으로 검사 하려면 &lt;code&gt;$?&lt;/code&gt; 를 검사하여 가능한 모든 장애 모드를 확인할 수 있습니다 . 이처럼 :</target>
        </trans-unit>
        <trans-unit id="b7d0d2c6ab654703248e935ebd07682399b01f80" translate="yes" xml:space="preserve">
          <source>If you'd like to see the raw output of your tests, set the &lt;code&gt;TEST_VERBOSE&lt;/code&gt; variable to true.</source>
          <target state="translated">테스트의 원시 출력을 보려면 &lt;code&gt;TEST_VERBOSE&lt;/code&gt; 변수를 true로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="15cb39149b7ad3616c39f88b2becd39a6aed03b0" translate="yes" xml:space="preserve">
          <source>If you'd rather treat each line individually, you can do that, too, by just transforming them in-place in the code reference and returning &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. Say that you don't want</source>
          <target state="translated">각 줄을 개별적으로 처리하려면 코드 참조에서 제자리로 변환하고 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환하면 됩니다. 원하지 않는다고 말해</target>
        </trans-unit>
        <trans-unit id="ffd95bdd9903099e5f9ecacdcf9a08a9aec1e1ad" translate="yes" xml:space="preserve">
          <source>If you're a plugin author, you'll be interested in how to &lt;a href=&quot;#register_handler&quot;&gt;register_handler&lt;/a&gt;s, how &lt;a href=&quot;#detect_source&quot;&gt;detect_source&lt;/a&gt; works.</source>
          <target state="translated">플러그인 작성자 인 경우 &lt;a href=&quot;#register_handler&quot;&gt;register_handler 등록&lt;/a&gt; 방법, &lt;a href=&quot;#detect_source&quot;&gt;detect_source&lt;/a&gt; 작동 방식에 관심이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ec02db45e6d3a34d0a303395b0efb8490d821d7c" translate="yes" xml:space="preserve">
          <source>If you're committed to creating a temporary file by hand, use the process ID and/or the current time-value. If you need to have many temporary files in one process, use a counter:</source>
          <target state="translated">수동으로 임시 파일을 작성하려는 경우 프로세스 ID 및 / 또는 현재 시간 값을 사용하십시오. 한 프로세스에 많은 임시 파일이 필요하면 카운터를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6a57c8d5168852184b3e7f9eacd5e84a511755f4" translate="yes" xml:space="preserve">
          <source>If you're concerned about 8-bit textual data then see &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;. If you want to deal with multibyte characters, however, there are some gotchas. See the section on Regular Expressions.</source>
          <target state="translated">8 비트 텍스트 데이터가 걱정된다면 &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; 을 참조하십시오 . 그러나 멀티 바이트 문자를 다루려면 몇 가지 문제가 있습니다. 정규식 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a4a17aeb59ac658e17124a0d2eb0b805c011e3c8" translate="yes" xml:space="preserve">
          <source>If you're concerned about people profiting from your code, then the bottom line is that nothing but a restrictive license will give you legal security. License your software and pepper it with threatening statements like &quot;This is unpublished proprietary software of XYZ Corp. Your access to it does not give you permission to use it blah blah blah.&quot; We are not lawyers, of course, so you should see a lawyer if you want to be sure your license's wording will stand up in court.</source>
          <target state="translated">코드에서 이익을 얻는 사람들이 걱정된다면 결론은 제한적인 라이센스만으로도 법적 보안을 제공한다는 것입니다. &quot;이 소프트웨어는 XYZ Corp의 공개되지 않은 독점 소프트웨어입니다. 소프트웨어에 대한 액세스 권한이 귀하에게 해당 소프트웨어를 사용할 수있는 권한을 부여하지 않습니다.&quot; 우리는 물론 변호사가 아니므로 면허증의 문구가 법정에 서도록하려면 변호사를 만나야합니다.</target>
        </trans-unit>
        <trans-unit id="20f5afeb7883b43b071ad0d90c989471842051d6" translate="yes" xml:space="preserve">
          <source>If you're concerned about people profiting from your code, then the bottom line is that nothing but a restrictive license will give you legal security. License your software and pepper it with threatening statements like &quot;This is unpublished proprietary software of XYZ Corp. Your access to it does not give you permission to use it blah blah blah.&quot; You should see a lawyer to be sure your license's wording will stand up in court.</source>
          <target state="translated">코드에서 이익을 얻는 사람들이 걱정된다면 결론은 제한적인 라이센스만으로도 법적 보안을 제공한다는 것입니다. &quot;이 소프트웨어는 XYZ Corp의 공개되지 않은 독점 소프트웨어입니다. 소프트웨어에 대한 액세스 권한이 귀하에게 해당 소프트웨어를 사용할 수있는 권한을 부여하지 않습니다.&quot; 면허증의 문구가 법정에 서도록 변호사를 만나야합니다.</target>
        </trans-unit>
        <trans-unit id="28d412e72884dbac279b68cd8636bc53150a9095" translate="yes" xml:space="preserve">
          <source>If you're confused about why you use an '@' there on a hash slice instead of a '%', think of it like this. The type of bracket (square or curly) governs whether it's an array or a hash being looked at. On the other hand, the leading symbol ('$' or '@') on the array or hash indicates whether you are getting back a singular value (a scalar) or a plural one (a list).</source>
          <target state="translated">'%'대신 해시 슬라이스에 '@'을 사용하는 이유에 대해 혼란 스러우면 다음과 같이 생각하십시오. 대괄호 유형 (정사각형 또는 중괄호)은 배열인지 또는 해시인지 여부를 결정합니다. 반면, 배열 또는 해시의 선행 기호 ( '$'또는 '@')는 단일 값 (스칼라) 또는 복수 값 (목록)을 다시 가져 오는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2fdaeb94f7920871da7274b75b49a557aeabaf4a" translate="yes" xml:space="preserve">
          <source>If you're creating a completely new result</source>
          <target state="translated">완전히 새로운 결과를 만들고 있다면</target>
        </trans-unit>
        <trans-unit id="6e2a7b543e2f454e92700f7b1967ab94c4b894e7" translate="yes" xml:space="preserve">
          <source>If you're currently linking your perl executable to a shared</source>
          <target state="translated">현재 perl 실행 파일을 공유에 연결하는 경우</target>
        </trans-unit>
        <trans-unit id="5ae9e7742fc3a996e99839cc61f7b8352d875d18" translate="yes" xml:space="preserve">
          <source>If you're debugging a script that uses #!, and normally relies on the shell's $PATH search, the -S option causes perl to do that search, so you don't have to type the path or &lt;code&gt;`which $scriptname`&lt;/code&gt; .</source>
          <target state="translated">#!를 사용하고 일반적으로 쉘의 $ PATH 검색에 의존하는 스크립트를 디버깅하는 경우 -S 옵션을 사용하면 perl이 해당 검색을 수행하므로 경로를 입력하거나 &lt;code&gt;`which $scriptname`&lt;/code&gt; 을 입력 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c253632d224aa0744dad2b2922eca154c4278dec" translate="yes" xml:space="preserve">
          <source>If you're deprecating a feature with the intent of later simplifying another bit of code, say so. If you're fixing a performance problem or adding a new feature to support some other bit of the core, mention that.</source>
          <target state="translated">나중에 다른 코드를 단순화하려는 의도로 기능을 더 이상 사용하지 않으려면 그렇게 말하십시오. 성능 문제를 해결하거나 코어의 다른 비트를 지원하는 새로운 기능을 추가하는 경우 언급하십시오.</target>
        </trans-unit>
        <trans-unit id="b41a3856c0dbc6e888db5696272009c4533b95af" translate="yes" xml:space="preserve">
          <source>If you're developing a CPAN distribution using XS, you may add your own file called</source>
          <target state="translated">XS를 사용하여 CPAN 배포를 개발하는 경우, 자신의 파일을 추가 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="897c140e9db65d769b3515a8af2bf69889950440" translate="yes" xml:space="preserve">
          <source>If you're getting this error from a here-document, you may have included unseen whitespace before or after your closing tag or there may not be a linebreak after it. A good programmer's editor will have a way to help you find these characters (or lack of characters). See &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; for the full details on here-documents.</source>
          <target state="translated">here-document 에서이 오류가 발생하면 닫는 태그 앞이나 뒤에 보이지 않는 공백이 포함되었거나 줄 바꿈이 없을 수 있습니다. 좋은 프로그래머의 편집자는 이러한 문자 (또는 문자가 없음)를 찾는 데 도움이 될 것입니다. 여기 문서에 대한 자세한 내용은 &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a4fd5cbfd79a1c891c020d447f65eef0d65886a8" translate="yes" xml:space="preserve">
          <source>If you're going to put your Pod at the end of the file, and you're using an &lt;code&gt;__END__&lt;/code&gt; or &lt;code&gt;__DATA__&lt;/code&gt; cut mark, make sure to put an empty line there before the first Pod command.</source>
          <target state="translated">파일의 끝에 포드를 넣고 &lt;code&gt;__END__&lt;/code&gt; 또는 &lt;code&gt;__DATA__&lt;/code&gt; 컷 마크를 사용하는 경우 첫 번째 포드 명령 앞에 빈 줄을 두십시오.</target>
        </trans-unit>
        <trans-unit id="0fef8c8a09918fb182d2a0653d091964fe4d5654" translate="yes" xml:space="preserve">
          <source>If you're in a slow syscall (like &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt;ing, &lt;code&gt;&lt;a href=&quot;functions/accept&quot;&gt;accept&lt;/a&gt;&lt;/code&gt;ing, or &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;ing from your keyboard or a socket) and haven't set up your own &lt;code&gt;$SIG{INT}&lt;/code&gt; handler, then you won't be able to CTRL-C your way back to the debugger, because the debugger's own &lt;code&gt;$SIG{INT}&lt;/code&gt; handler doesn't understand that it needs to raise an exception to longjmp(3) out of slow syscalls.</source>
          <target state="translated">시스템 호출이 느리거나 (예 : &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/accept&quot;&gt;accept&lt;/a&gt;&lt;/code&gt; 또는 키보드 또는 소켓에서 &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; ) &lt;code&gt;$SIG{INT}&lt;/code&gt; 핸들러를 설정하지 않은 경우 CTRL을 사용할 수 없습니다. 디버거 자체 &lt;code&gt;$SIG{INT}&lt;/code&gt; 핸들러는 느린 syscall에서 longjmp (3)에 예외를 발생시켜야한다는 것을 이해하지 못 하므로 디버거로 돌아가십시오 .</target>
        </trans-unit>
        <trans-unit id="14f4284650d0a24b2d57ce770464abe6b8363cfa" translate="yes" xml:space="preserve">
          <source>If you're just trying to get a print out of each line of Perl code as it executes, the way that &lt;code&gt;sh -x&lt;/code&gt; provides for shell scripts, you can't use Perl's &lt;b&gt;-D&lt;/b&gt; switch. Instead do this</source>
          <target state="translated">&lt;code&gt;sh -x&lt;/code&gt; 가 쉘 스크립트를 제공 하는 방식으로 Perl 코드의 각 행에서 인쇄를 시도하는 경우 Perl의 &lt;b&gt;-D&lt;/b&gt; 스위치를 사용할 수 없습니다 . 대신 이것을하십시오</target>
        </trans-unit>
        <trans-unit id="e1d724a87dfd2f97b8c95cc8c3b05426d4d76542" translate="yes" xml:space="preserve">
          <source>If you're just trying to patch a binary, in many cases something as simple as this works:</source>
          <target state="translated">바이너리를 패치하려고한다면, 많은 경우에 이것이 작동하는 것처럼 간단합니다 :</target>
        </trans-unit>
        <trans-unit id="beae682a73c10931e4ab41819afea65e05d531cf" translate="yes" xml:space="preserve">
          <source>If you're looking for an EBNF grammar, see &lt;a href=&quot;parser/grammar&quot;&gt;TAP::Parser::Grammar&lt;/a&gt;.</source>
          <target state="translated">EBNF 문법을 찾고 있다면 &lt;a href=&quot;parser/grammar&quot;&gt;TAP :: Parser :: Grammar를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="55c4ac9978b7084a6172dad11c1733f741ff1455" translate="yes" xml:space="preserve">
          <source>If you're looking for something a bit more rigorous, try &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;.</source>
          <target state="translated">좀 더 엄격한 것을 찾고 있다면 &lt;a href=&quot;perlootut&quot;&gt;perlootut을&lt;/a&gt; 사용해보십시오 .</target>
        </trans-unit>
        <trans-unit id="7091178e821abb2a7bce9c92cae74d109146a9a0" translate="yes" xml:space="preserve">
          <source>If you're looking for the information on how to use here-documents, which used to be here, that's been moved to &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;Quote and Quote-like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">여기에 사용되었던 here-documents를 사용하는 방법에 대한 정보를 찾고 있다면 &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;perlop의 Quote and Quote-like 연산자&lt;/a&gt; 로 옮겨졌습니다 .</target>
        </trans-unit>
        <trans-unit id="889cd4ec91070da4d939fc8ed6a3a8c2e2067138" translate="yes" xml:space="preserve">
          <source>If you're looking to write your own object system, or you need to maintain code which implements objects from scratch then this document will help you understand exactly how Perl does object orientation.</source>
          <target state="translated">자신 만의 객체 시스템을 작성하려고하거나 객체를 처음부터 구현하는 코드를 유지해야하는 경우이 문서는 Perl의 객체 방향을 정확히 이해하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="ddf0bc3794c8ee98c81f65ada98d73c84a0b3b0d" translate="yes" xml:space="preserve">
          <source>If you're lucky enough to be using a system that supports non-blocking reads (most Unixish systems do), you need only to use the &lt;code&gt;O_NDELAY&lt;/code&gt; or &lt;code&gt;O_NONBLOCK&lt;/code&gt; flag from the &lt;code&gt;Fcntl&lt;/code&gt; module in conjunction with &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen()&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">비 차단 읽기를 지원하는 시스템 (대부분의 유닉스 시스템)을 사용하기에 운이 좋으면 &lt;code&gt;Fcntl&lt;/code&gt; 모듈 의 &lt;code&gt;O_NDELAY&lt;/code&gt; 또는 &lt;code&gt;O_NONBLOCK&lt;/code&gt; 플래그를 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen()&lt;/a&gt;&lt;/code&gt; 과 함께 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1442d0654a360821d205030d12b7c46d2249369f" translate="yes" xml:space="preserve">
          <source>If you're lucky you should see &quot;All tests successful&quot;. But there can be a few failed subtests (less than 5 hopefully) depending on some external conditions (e.g. some subtests fail under linux/dosemu or plain dos with short filenames only).</source>
          <target state="translated">운이 좋으면 &quot;모든 테스트 성공&quot;이 표시됩니다. 그러나 일부 외부 조건에 따라 실패한 하위 테스트가 5 개 미만일 수 있습니다 (예 : 일부 하위 테스트는 linux / dosemu 또는 짧은 파일 이름으로 일반 작업에서 실패).</target>
        </trans-unit>
        <trans-unit id="81d8181270fe0a221e4cfe0273d672eeca038de7" translate="yes" xml:space="preserve">
          <source>If you're matching against &lt;code&gt;$_&lt;/code&gt; , the &lt;code&gt;$_ =~&lt;/code&gt; part can be omitted:</source>
          <target state="translated">&lt;code&gt;$_&lt;/code&gt; 와 일치하는 경우 &lt;code&gt;$_ =~&lt;/code&gt; 부분을 ​​생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8dff24fd1b5ec5a9dffa27b27da41b1f996870a7" translate="yes" xml:space="preserve">
          <source>If you're matching against the special default variable &lt;code&gt;$_&lt;/code&gt; , the &lt;code&gt;$_ =~&lt;/code&gt; part can be omitted:</source>
          <target state="translated">당신은 특별한 기본 변수에있는 거 일치하는 경우 &lt;code&gt;$_&lt;/code&gt; 는 &lt;code&gt;$_ =~&lt;/code&gt; 부분은 생략 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="426f58876b20aa644c87cac6d34c02796b1541e8" translate="yes" xml:space="preserve">
          <source>If you're mixing UTF-8 and non-UTF-8 strings, it is necessary to upgrade the non-UTF-8 strings to UTF-8. If you've got an SV, the easiest way to do this is:</source>
          <target state="translated">UTF-8과 비 UTF-8 문자열을 혼합하는 경우 비 UTF-8 문자열을 UTF-8로 업그레이드해야합니다. SV가 있다면 가장 쉬운 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0b4dc2534030724a7fd2a22ed631de91b923d0d4" translate="yes" xml:space="preserve">
          <source>If you're more familiar with writing in HTML than with writing in Pod, you can try your hand at writing documentation in simple HTML, and converting it to Pod with the experimental &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::HTML2Pod&quot;&gt;Pod::HTML2Pod&lt;/a&gt; module, (available in CPAN), and looking at the resulting code. The experimental &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod::PXML&lt;/a&gt; module in CPAN might also be useful.</source>
          <target state="translated">Pod로 작성하는 것보다 HTML로 작성하는 데 더 익숙하다면 간단한 HTML로 문서를 작성하고 실험적인 &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::HTML2Pod&quot;&gt;Pod :: HTML2Pod&lt;/a&gt; 모듈 (CPAN에서 사용 가능)을 사용 하여 Pod로 변환하여 직접 사용해보십시오. 결과 코드에서. CPAN 의 실험적인 &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod :: PXML&lt;/a&gt; 모듈도 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="661a15733b02e1bde18a48ee6f26023806e52abe" translate="yes" xml:space="preserve">
          <source>If you're more from the object-oriented camp, you can inherit from Storable and directly store your objects by invoking &lt;code&gt;store&lt;/code&gt; as a method. The fact that the root of the to-be-stored tree is a blessed reference (i.e. an object) is special-cased so that the retrieve does not provide a reference to that object but rather the blessed object reference itself. (Otherwise, you'd get a reference to that blessed object).</source>
          <target state="translated">객체 지향 캠프에서 더 많은 경우 Storable에서 상속 하고 메소드 를 &lt;code&gt;store&lt;/code&gt; 로 호출하여 객체를 직접 저장할 수 있습니다 . 저장 될 트리의 루트가 축복 된 참조 (즉, 객체)라는 사실은 검색이 해당 객체에 대한 참조를 제공하지 않고 오히려 축복 된 객체 참조 자체를 제공하도록 특수한 경우입니다. (그렇지 않으면 그 축복받은 물건에 대한 언급을 얻게 될 것입니다).</target>
        </trans-unit>
        <trans-unit id="90c11316b76d508e073f9fc77a3e623b3eada282" translate="yes" xml:space="preserve">
          <source>If you're new to Perl, you should start by running &lt;code&gt;perldoc perlintro&lt;/code&gt; , which is a general intro for beginners and provides some background to help you navigate the rest of Perl's extensive documentation. Run &lt;code&gt;perldoc
perldoc&lt;/code&gt; to learn more things you can do with</source>
          <target state="translated">Perl을 처음 사용하는 경우 초보자를위한 일반적인 소개 인 &lt;code&gt;perldoc perlintro&lt;/code&gt; 를 실행하여 시작해야 하며 Perl의 광범위한 문서를 탐색하는 데 도움이되는 배경 지식을 제공합니다. &lt;code&gt;perldoc perldoc&lt;/code&gt; 을 실행 하여 더 많은 것을 할 수있는 것을 배우십시오</target>
        </trans-unit>
        <trans-unit id="744942d070c981ce6cf7077125a9b1fdb8807cc7" translate="yes" xml:space="preserve">
          <source>If you're new to the Perl debugger, you may prefer to read &lt;a href=&quot;perldebtut&quot;&gt;perldebtut&lt;/a&gt;, which is a tutorial introduction to the debugger.</source>
          <target state="translated">Perl 디버거를 처음 사용하는 경우 디버거에 대한 자습서 소개 인 &lt;a href=&quot;perldebtut&quot;&gt;perldebtut&lt;/a&gt; 를 읽는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="c2727aad3001460d90c1014c2e79041ef3c0a256" translate="yes" xml:space="preserve">
          <source>If you're not running VMS, this module does nothing.</source>
          <target state="translated">VMS를 실행하지 않는 경우이 모듈은 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="57b30f05d7f8cbe152533a07743b1d8313aa4f82" translate="yes" xml:space="preserve">
          <source>If you're not sure what you have (the &lt;code&gt;VAL&lt;/code&gt; case), wrap the method call in an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; block to catch the exception if &lt;code&gt;VAL&lt;/code&gt; is undefined.</source>
          <target state="translated">당신이 무엇을 가지고 있는지 확실하지 않은 경우 ( &lt;code&gt;VAL&lt;/code&gt; 경우) &lt;code&gt;VAL&lt;/code&gt; 이 정의되지 않은 경우 예외를 잡기 위해 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 블록 에서 메소드 호출을 래핑하십시오 .</target>
        </trans-unit>
        <trans-unit id="92ef540b5bff7fa8b60e3b8701e23d84d3552eb5" translate="yes" xml:space="preserve">
          <source>If you're not the Perl administrator you probably don't have permission to install a module to its default location. Then you should install it for your own use into your home directory like so:</source>
          <target state="translated">Perl 관리자가 아닌 경우 기본 위치에 모듈을 설치할 수있는 권한이 없을 수 있습니다. 그런 다음 자신의 용도로 홈 디렉토리에 다음과 같이 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="9feed406758bc42352583f962fb6765533ea27d0" translate="yes" xml:space="preserve">
          <source>If you're not used to reading BNF grammars, this is how it works: You're fed certain things by the tokeniser, which generally end up in upper case. Here, &lt;code&gt;ADDOP&lt;/code&gt; , is provided when the tokeniser sees &lt;code&gt;+&lt;/code&gt; in your code. &lt;code&gt;ASSIGNOP&lt;/code&gt; is provided when &lt;code&gt;=&lt;/code&gt; is used for assigning. These are &quot;terminal symbols&quot;, because you can't get any simpler than them.</source>
          <target state="translated">BNF 문법을 읽는 데 익숙하지 않은 경우 이것이 작동하는 방식입니다. 토큰 화기는 특정 항목을 일반적으로 대문자로 표시합니다. 여기에서 &lt;code&gt;ADDOP&lt;/code&gt; 은 토큰이 코드에서 &lt;code&gt;+&lt;/code&gt; 를 볼 때 제공됩니다 . &lt;code&gt;=&lt;/code&gt; 가 할당에 사용될 때 &lt;code&gt;ASSIGNOP&lt;/code&gt; 가 제공됩니다 . 이것들은 &quot;단말기 기호&quot;인데, 그 이유는 그것들보다 더 간단하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="d41cee3341b958945c48519633ed1e0a770e7261" translate="yes" xml:space="preserve">
          <source>If you're not writing a server/client for an existing protocol like NNTP or SMTP, you should give some thought to how your server will know when the client has finished talking, and vice-versa. Most protocols are based on one-line messages and responses (so one party knows the other has finished when a &quot;\n&quot; is received) or multi-line messages and responses that end with a period on an empty line (&quot;\n.\n&quot; terminates a message/response).</source>
          <target state="translated">NNTP 또는 SMTP와 같은 기존 프로토콜에 대해 서버 / 클라이언트를 작성하지 않는 경우, 클라이언트가 대화를 마친 시점을 서버가 어떻게 알 수 있는지에 대해 생각해야합니다. 대부분의 프로토콜은 한 줄 메시지 및 응답 (한 당사자가 상대방이 &quot;\ n&quot;을 수신하면 완료되었음을 알고 있음) 또는 빈 줄의 마침표 ( &quot;\ n)로 끝나는 여러 줄 메시지 및 응답을 기반으로합니다. \ n &quot;은 메시지 / 응답을 종료합니다).</target>
        </trans-unit>
        <trans-unit id="1904985e3da30cf5eb915cfb278068985854bae1" translate="yes" xml:space="preserve">
          <source>If you're not writing such a tool, then whether you accept noncharacters as input is up to you (though the Standard recommends that you not). If you do strict input stream checking with Perl, these code points continue to be forbidden. This is to maintain backward compatibility (otherwise potential security holes could open up, as an unsuspecting application that was written assuming the noncharacters would be filtered out before getting to it, could now, without warning, start getting them). To do strict checking, you can use the layer &lt;code&gt;:encoding('UTF-8')&lt;/code&gt; .</source>
          <target state="translated">이러한 도구를 작성하지 않는 경우 문자가 아닌 문자를 입력으로 허용할지 여부는 사용자에게 달려 있습니다 (표준에서는 권장하지 않음). Perl을 사용하여 엄격한 입력 스트림 검사를 수행하는 경우 이러한 코드 포인트는 계속 금지됩니다. 이는 이전 버전과의 호환성을 유지하기위한 것입니다 (그렇지 않으면 문자가 아닌 문자를 가져 오기 전에 필터링되어 이제는 경고없이 가져올 수 있음을 가정하여 작성된 의심없는 응용 프로그램으로 인해 잠재적 인 보안 허점이 열릴 수 있습니다). 엄격한 확인을 위해 &lt;code&gt;:encoding('UTF-8')&lt;/code&gt; 레이어를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6e740be7e86f98ca86a316e7e6f108d26ec4db83" translate="yes" xml:space="preserve">
          <source>If you're on Unix, you already have an IDE--Unix itself. The Unix philosophy is the philosophy of several small tools that each do one thing and do it well. It's like a carpenter's toolbox.</source>
          <target state="translated">유닉스를 사용하고 있다면 이미 IDE-Unix 자체가 있습니다. 유닉스 철학은 각각 하나의 일을하고 잘 수행하는 몇 가지 작은 도구의 철학입니다. 목수의 도구 상자와 같습니다.</target>
        </trans-unit>
        <trans-unit id="27b6c4407588281e5e7fdb718dd9826644dbabc0" translate="yes" xml:space="preserve">
          <source>If you're on a POSIX system, Perl supports the &lt;code&gt;POSIX::strtod&lt;/code&gt; function for converting strings to doubles (and also &lt;code&gt;POSIX::strtol&lt;/code&gt; for longs). Its semantics are somewhat cumbersome, so here's a &lt;code&gt;getnum&lt;/code&gt; wrapper function for more convenient access. This function takes a string and returns the number it found, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for input that isn't a C float. The &lt;code&gt;is_numeric&lt;/code&gt; function is a front end to &lt;code&gt;getnum&lt;/code&gt; if you just want to say, &quot;Is this a float?&quot;</source>
          <target state="translated">POSIX 시스템을 사용하는 경우 Perl은 문자열을 두 배로 변환 하는 &lt;code&gt;POSIX::strtod&lt;/code&gt; 함수를 지원합니다 (또한 &lt;code&gt;POSIX::strtol&lt;/code&gt; 도 long). 그 의미는 다소 번거롭기 때문에 여기 에 더 편리한 액세스를위한 &lt;code&gt;getnum&lt;/code&gt; 래퍼 함수가 있습니다. 이 함수는 문자열을 가져 와서 찾은 숫자를 반환하거나 C float가 아닌 입력에 대해 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환합니다 . &lt;code&gt;is_numeric&lt;/code&gt; 기능을하는 프론트 엔드입니다 &lt;code&gt;getnum&lt;/code&gt; 그냥 말하고 싶은 경우에, &quot;이 부동인가?&quot;</target>
        </trans-unit>
        <trans-unit id="fe652d8671f9747b2b27fba3ba0a6953bf5a58ab" translate="yes" xml:space="preserve">
          <source>If you're only a C programmer, than this is the end of the message for you. You can quit right now, and if you care to, save off the source and run it when you feel like it. Or not.</source>
          <target state="translated">당신이 C 프로그래머라면, 이것이 당신을위한 메시지의 끝입니다. 지금 종료 할 수 있으며, 관심이 있다면 소스를 저장하고 느낌이들 때 실행하십시오. 아님</target>
        </trans-unit>
        <trans-unit id="5f443393381ebb2ba3b4781af2f167f994444b4f" translate="yes" xml:space="preserve">
          <source>If you're passing a filehandle to a function, you can write the function in two ways:</source>
          <target state="translated">파일 핸들을 함수에 전달하는 경우 두 가지 방법으로 함수를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3681c9d29e3cea8b052a12522cde089c668422cf" translate="yes" xml:space="preserve">
          <source>If you're passing around filehandles, you could usually just use the bare typeglob, like &lt;code&gt;*STDOUT&lt;/code&gt; , but typeglobs references work, too. For example:</source>
          <target state="translated">파일 핸들을 전달하는 경우 일반적으로 &lt;code&gt;*STDOUT&lt;/code&gt; 과 같은 베어 타입 글로브를 사용할 수 있지만 타입 글로브 참조도 작동합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8f816f45cbfc0eef6f9ae6c1011d3c4a6ca61924" translate="yes" xml:space="preserve">
          <source>If you're planning on generating new filehandles, you could do this. Notice to pass back just the bare *FH, not its reference.</source>
          <target state="translated">새로운 파일 핸들을 생성 할 계획이라면이 작업을 수행 할 수 있습니다. 참조가 아닌 베어 * FH 만 다시 전달합니다.</target>
        </trans-unit>
        <trans-unit id="e8bfd94e153d8978fbc196c7118de9fb39d2dab3" translate="yes" xml:space="preserve">
          <source>If you're planning to do more extensive work than a single small fix, we encourage you to read the documentation below. This will help you focus your work and make your patches easier to incorporate into the Perl source.</source>
          <target state="translated">하나의 작은 수정보다 더 광범위한 작업을 수행하려는 경우 아래 설명서를 읽으십시오. 이를 통해 작업에 집중하고 패치를 Perl 소스에 쉽게 통합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="304b9d32f29eb0f2f218ff94e8f5f53580345dcb" translate="yes" xml:space="preserve">
          <source>If you're planning to filetest the return values out of a &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt;, you'd better prepend the directory in question. Otherwise, because we didn't &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; there, it would have been testing the wrong file.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; 외부에서 리턴 값을 파일 테스트하려는 경우 해당 디렉토리 앞에 추가하는 것이 좋습니다. 그렇지 않으면 거기에 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 이 없기 때문에 잘못된 파일을 테스트했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="f907870b50e1902094cd7a51307296876f77264b" translate="yes" xml:space="preserve">
          <source>If you're planning to filetest the return values out of a &lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt;, you'd better prepend the directory in question. Otherwise, because we didn't &lt;code&gt;&lt;a href=&quot;chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; there, it would have been testing the wrong file.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; 외부에서 리턴 값을 파일 테스트하려는 경우 해당 디렉토리 앞에 추가하는 것이 좋습니다. 그렇지 않으면 거기에 &lt;code&gt;&lt;a href=&quot;chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 이 없기 때문에 잘못된 파일을 테스트했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="fcece448e0aa8ee8873fb9b13cee8077eaed1e18" translate="yes" xml:space="preserve">
          <source>If you're reading this document because you want to write a formatter subclass, continue reading it and then read &lt;a href=&quot;simple/subclassing&quot;&gt;Pod::Simple::Subclassing&lt;/a&gt;, and then possibly even read &lt;a href=&quot;../perlpodspec&quot;&gt;perlpodspec&lt;/a&gt; (some of which is for parser-writers, but much of which is notes to formatter-writers).</source>
          <target state="translated">포맷터 서브 클래스를 작성하고 싶기 때문에이 문서를 읽는 &lt;a href=&quot;../perlpodspec&quot;&gt;중이&lt;/a&gt; 라면 계속 읽고 나서 &lt;a href=&quot;simple/subclassing&quot;&gt;Pod :: Simple :: Subclassing을&lt;/a&gt; 읽은 다음 perlpodspec (일부는 파서 작성 기용이지만 대부분은 포매터 작가에게 노트입니다).</target>
        </trans-unit>
        <trans-unit id="3eca1cf4cac957f4047c12a2cccf4d8bf7c0618e" translate="yes" xml:space="preserve">
          <source>If you're reading this document just because you have a Pod-processing subclass that you want to use, this document (plus the documentation for the subclass) is probably all you need to read.</source>
          <target state="translated">사용하려는 포드 프로세싱 서브 클래스가 있다고해서이 문서를 읽는다면이 문서 (및 서브 클래스에 대한 문서) 만 읽으면됩니다.</target>
        </trans-unit>
        <trans-unit id="b7d2d7b7f7d3b1824419996342901896caf3e1ec" translate="yes" xml:space="preserve">
          <source>If you're running Perl on a system that distinguishes between text files and binary files, then you should check out &lt;a href=&quot;#binmode&quot;&gt;binmode&lt;/a&gt; for tips for dealing with this. The key distinction between systems that need &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; and those that don't is their text file formats. Systems like Unix, Mac OS, and Plan 9, that end lines with a single character and encode that character in C as &lt;code&gt;&quot;\n&quot;&lt;/code&gt; do not need &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt;. The rest need it.</source>
          <target state="translated">텍스트 파일과 이진 파일을 구분하는 시스템에서 Perl을 실행하는 경우 이를 처리하기위한 팁은 &lt;a href=&quot;#binmode&quot;&gt;binmode&lt;/a&gt; 를 확인해야 합니다. &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 가 필요한 시스템 과 그렇지 않은 시스템의 주요 차이점은 텍스트 파일 형식입니다. 단일 문자로 줄을 끝내고 C에서 해당 문자를 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 으로 인코딩하는 Unix, Mac OS 및 Plan 9와 같은 시스템에는 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 가 필요하지 않습니다 . 나머지는 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ffabd87b995f6de8b55fa057fefd0560b9ffddaf" translate="yes" xml:space="preserve">
          <source>If you're running Perl on a system that distinguishes between text files and binary files, then you should check out &lt;a href=&quot;binmode&quot;&gt;binmode&lt;/a&gt; for tips for dealing with this. The key distinction between systems that need &lt;code&gt;&lt;a href=&quot;binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; and those that don't is their text file formats. Systems like Unix, Mac OS, and Plan 9, that end lines with a single character and encode that character in C as &lt;code&gt;&quot;\n&quot;&lt;/code&gt; do not need &lt;code&gt;&lt;a href=&quot;binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt;. The rest need it.</source>
          <target state="translated">텍스트 파일과 이진 파일을 구분하는 시스템에서 Perl을 실행하는 경우 이를 처리하기위한 팁은 &lt;a href=&quot;binmode&quot;&gt;binmode&lt;/a&gt; 를 확인해야 합니다. &lt;code&gt;&lt;a href=&quot;binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 가 필요한 시스템 과 그렇지 않은 시스템의 주요 차이점은 텍스트 파일 형식입니다. 단일 문자로 줄을 끝내고 C에서 해당 문자를 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 으로 인코딩하는 Unix, Mac OS 및 Plan 9와 같은 시스템에는 &lt;code&gt;&lt;a href=&quot;binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 가 필요하지 않습니다 . 나머지는 필요합니다.</target>
        </trans-unit>
        <trans-unit id="39c1b50b544a3df322b75f65dc11d5ac4c69a35f" translate="yes" xml:space="preserve">
          <source>If you're storing handles in an array or hash, or in general whenever you're using any expression more complex than a bareword handle or a plain, unsubscripted scalar variable to retrieve it, you will have to use a block returning the filehandle value instead, in which case the LIST may not be omitted:</source>
          <target state="translated">배열 또는 해시에 핸들을 저장하거나 일반적으로 베어 워드 핸들 또는 일반 첨자 스칼라 변수보다 복잡한 표현식을 검색 할 때마다 파일 핸들 값을 리턴하는 블록을 사용해야합니다 대신이 경우 LIST를 생략 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1ed2a4901ca871ef8cee85b2ad371ae78f316632" translate="yes" xml:space="preserve">
          <source>If you're submitting values using the GET method, create a URL and encode the form using the &lt;code&gt;query_form&lt;/code&gt; method:</source>
          <target state="translated">GET 메소드를 사용하여 값을 제출하는 경우 URL을 작성하고 &lt;code&gt;query_form&lt;/code&gt; 메소드를 사용하여 양식을 인코딩하십시오 .</target>
        </trans-unit>
        <trans-unit id="d5f5ca288d27f19393728db02ea58b007b723ea8" translate="yes" xml:space="preserve">
          <source>If you're talking about obscuring method calls in parent classes, see &lt;a href=&quot;perlootut#Overriding-methods-and-method-resolution&quot;&gt;Overriding methods and method resolution in perlootut&lt;/a&gt;.</source>
          <target state="translated">부모 클래스에서 메소드 호출을 가리는 것에 대해 이야기하는 경우 &lt;a href=&quot;perlootut#Overriding-methods-and-method-resolution&quot;&gt;perlootut에서 메소드 및 메소드 분석 대체를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f9fb0313a494e266734d606dab0fb4c3f5c1638a" translate="yes" xml:space="preserve">
          <source>If you're trying to do variable interpolation, it's definitely better to use the &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob()&lt;/a&gt;&lt;/code&gt; function, because the older notation can cause people to become confused with the indirect filehandle notation.</source>
          <target state="translated">변수 보간을 수행하려는 경우 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob()&lt;/a&gt;&lt;/code&gt; 함수 를 사용하는 것이 좋습니다 . 이전 표기법으로 인해 사람들이 간접 파일 핸들 표기법과 혼동 될 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="b2f801c8c750d6402e7dad5eddfca92a856a8093" translate="yes" xml:space="preserve">
          <source>If you're unsure of the meaning of an error message you've run across, &lt;b&gt;perldoc&lt;/b&gt;&lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt; for an explanation. If the message isn't in perldiag, it probably isn't generated by Perl. You may have luck consulting your operating system documentation instead.</source>
          <target state="translated">실행 한 오류 메시지의 의미를 잘 모르는 경우 &lt;b&gt;perldoc &lt;/b&gt;&lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt; 를 통해 설명하십시오. 메시지가 perldiag에 없으면 아마도 Perl에 의해 생성되지 않았을 것입니다. 대신 운영 체제 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4b93133a107f3dc1672015bebe523f72dafb6b9f" translate="yes" xml:space="preserve">
          <source>If you're uploading to CPAN, the automated gremlins will extract the README file and place that in your CPAN directory. It'll also appear in the main</source>
          <target state="translated">CPAN에 업로드하는 경우 자동 gremlins가 README 파일을 추출하여 CPAN 디렉토리에 배치합니다. 그것은 또한 메인에 나타납니다</target>
        </trans-unit>
        <trans-unit id="3ad89e38e60f381b4a7eacce6c02e2db727251db" translate="yes" xml:space="preserve">
          <source>If you're using &lt;code&gt;Archive::Tar&lt;/code&gt; 's &lt;code&gt;extract()&lt;/code&gt; method, &lt;code&gt;setcwd()&lt;/code&gt; will be called for you.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;Archive::Tar&lt;/code&gt; 의 &lt;code&gt;extract()&lt;/code&gt; 메소드 &lt;code&gt;setcwd()&lt;/code&gt; 당신을 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0cc14a892bad71218591bbe7bbef35b81fe36647" translate="yes" xml:space="preserve">
          <source>If you're using VMStar:</source>
          <target state="translated">VMStar를 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="76511f6d042eedee604ffae23aa88974c6f04729" translate="yes" xml:space="preserve">
          <source>If you're using a module that's not thread-safe for some reason, you can protect yourself by using it from one, and only one thread at all. If you need multiple threads to access such a module, you can use semaphores and lots of programming discipline to control access to it. Semaphores are covered in &lt;a href=&quot;#Basic-semaphores&quot;&gt;Basic semaphores&lt;/a&gt;.</source>
          <target state="translated">어떤 이유로 스레드로부터 안전하지 않은 모듈을 사용하는 경우 하나의 스레드 만 사용하여 자신을 보호 할 수 있습니다. 이러한 모듈에 액세스하기 위해 여러 스레드가 필요한 경우 세마포어 및 많은 프로그래밍 규칙을 사용하여 액세스를 제어 할 수 있습니다. 세마포어는 &lt;a href=&quot;#Basic-semaphores&quot;&gt;기본 세마포어&lt;/a&gt; 에서 다룹니다 .</target>
        </trans-unit>
        <trans-unit id="9aa1259aa5ab1edcbb7c8ec755fbb7d9933607e8" translate="yes" xml:space="preserve">
          <source>If you're using a version of Perl before 5.004, you must call &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; once at the start of your program to seed the random number generator.</source>
          <target state="translated">5.004 이전의 Perl 버전을 사용하는 경우 전화해야합니다. &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; 프로그램 시작시 srand를 한 번하여 난수 생성기를 시드해야합니다.</target>
        </trans-unit>
        <trans-unit id="9ff91ee4a99e5bbc7fa9f896e9934c1f57633ce3" translate="yes" xml:space="preserve">
          <source>If you're using localization in an application that keeps a configuration file, you might consider something like this in your project class:</source>
          <target state="translated">구성 파일을 유지하는 응용 프로그램에서 지역화를 사용하는 경우 프로젝트 클래스에서 다음과 같은 것을 고려할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e98919158b85262f93e6e1cca66f69e28561af51" translate="yes" xml:space="preserve">
          <source>If you're using references as keys within your hash tables, you're bound to be disappointed when retrieving your data. Indeed, Perl stringifies references used as hash table keys. If you later wish to access the items via another reference stringification (i.e. using the same reference that was used for the key originally to record the value into the hash table), it will work because both references stringify to the same string.</source>
          <target state="translated">해시 테이블 내에서 참조를 키로 사용하는 경우 데이터를 검색 할 때 실망해야합니다. 실제로 Perl은 해시 테이블 키로 사용되는 참조를 문자열 화합니다. 나중에 다른 참조 문자열 화를 통해 항목에 액세스하려는 경우 (즉, 원래 키에 사용 된 동일한 참조를 사용하여 해시 테이블에 값을 기록하는 경우) 두 참조가 동일한 문자열로 문자열 화되므로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="cda64e05edf4afefc7befad6697f98377f63d5c2" translate="yes" xml:space="preserve">
          <source>If you're using strict, you</source>
          <target state="translated">엄격하게 사용한다면</target>
        </trans-unit>
        <trans-unit id="5149a95571d7bad870cf9d14644f05c40d4e4c11" translate="yes" xml:space="preserve">
          <source>If you're using the POST method, create your own user agent and encode the content appropriately.</source>
          <target state="translated">POST 방법을 사용하는 경우 고유 한 사용자 에이전트를 작성하고 컨텐츠를 적절하게 인코딩하십시오.</target>
        </trans-unit>
        <trans-unit id="94dea5f329a320df5b1676d594bbe7ddb6af4d25" translate="yes" xml:space="preserve">
          <source>If you're using untarzipme or StuffIt, the archive should be extracted now. &lt;b&gt;Or&lt;/b&gt;, you can use the freeware &lt;b&gt;suntar&lt;/b&gt; or</source>
          <target state="translated">untarzipme 또는 StuffIt을 사용하는 경우 지금 아카이브를 추출해야합니다. &lt;b&gt;또는&lt;/b&gt; 프리웨어 &lt;b&gt;선 타르를 사용&lt;/b&gt; 하거나</target>
        </trans-unit>
        <trans-unit id="03aaa8fe5a352318fc187dc162360b47448bfe8d" translate="yes" xml:space="preserve">
          <source>If you're working with globs at runtime, and need to disambiguate *^G from *{&quot;^G&quot;}, then you should use the raw NAME method.</source>
          <target state="translated">런타임에 glob를 사용하고 있고 * ^ G를 * { &quot;^ G&quot;}에서 명확하게해야하는 경우에는 원시 NAME 메소드를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="86326ce985c6268f6aa266be33a273db0ac99980" translate="yes" xml:space="preserve">
          <source>If you're worried about users selecting bad passwords, you should proactively check when they try to change their password (by modifying</source>
          <target state="translated">사용자가 잘못된 비밀번호를 선택하는 것에 대해 걱정이되는 경우, 비밀번호를 변경하려고 할 때 사전 수정해야합니다 (수정을 통해).</target>
        </trans-unit>
        <trans-unit id="c631e014f0d55506d4df289cf9b8b44d3544afb4" translate="yes" xml:space="preserve">
          <source>If you're writing code, such as an editor, that is supposed to be able to handle any Unicode text data, then you shouldn't be using these code points yourself, and instead allow them in the input. If you need sentinels, they should instead be something that isn't legal Unicode. For UTF-8 data, you can use the bytes 0xC1 and 0xC2 as sentinels, as they never appear in well-formed UTF-8. (There are equivalents for UTF-EBCDIC). You can also store your Unicode code points in integer variables and use negative values as sentinels.</source>
          <target state="translated">유니 코드 텍스트 데이터를 처리 할 수있는 편집기와 같은 코드를 작성하는 경우 이러한 코드 포인트를 직접 사용하지 말고 대신 입력에 허용해야합니다. 센티넬이 필요한 경우 대신 유효한 유니 코드가 아닌 것이어야합니다. UTF-8 데이터의 경우 0xC1 및 0xC2 바이트를 센티넬로 사용할 수 있습니다. 제대로 구성된 UTF-8에는 나타나지 않습니다. (UTF-EBCDIC와 동등한 항목이 있습니다). 유니 코드 코드 포인트를 정수 변수에 저장하고 음수 값을 센티넬로 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a276dfc7f44e7268960d2975b30664b78a301f5a" translate="yes" xml:space="preserve">
          <source>If you're writing your own &lt;a href=&quot;parser/sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;, you may need to create your own iterators too. If so you'll need to subclass &lt;a href=&quot;parser/iterator&quot;&gt;TAP::Parser::Iterator&lt;/a&gt;.</source>
          <target state="translated">자체 &lt;a href=&quot;parser/sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt; 를 작성하는 경우 자체 반복자를 작성해야 할 수도 있습니다. 그렇다면 &lt;a href=&quot;parser/iterator&quot;&gt;TAP :: Parser :: Iterator&lt;/a&gt; 를 서브 클래 싱해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6d3ca82cb6d85e36f098b04f831321b68f9f28ab" translate="yes" xml:space="preserve">
          <source>If you're writing your own documentation in POD, the</source>
          <target state="translated">POD로 자신의 문서를 작성하는 경우</target>
        </trans-unit>
        <trans-unit id="609941eec97975f4a0354cdbfbac32c60f31f261" translate="yes" xml:space="preserve">
          <source>If you've already got some other kind of email object, consider passing it to &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Abstract&quot;&gt;Email::Abstract&lt;/a&gt; and then using its cast method to get an &lt;a href=&quot;http://search.cpan.org/perldoc/Email::MIME&quot;&gt;Email::MIME&lt;/a&gt; object:</source>
          <target state="translated">다른 종류의 전자 메일 객체가 이미있는 경우 &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Abstract&quot;&gt;Email :: Abstract로&lt;/a&gt; 전달한 다음 cast 메서드를 사용하여 &lt;a href=&quot;http://search.cpan.org/perldoc/Email::MIME&quot;&gt;Email :: MIME&lt;/a&gt; 을 가져 오는 것이 좋습니다. 객체 .</target>
        </trans-unit>
        <trans-unit id="49b89fe4b531fe550fa8cdc2584e0b4d10940e84" translate="yes" xml:space="preserve">
          <source>If you've been around Perl a while, all this talk of escape sequences may seem familiar. Similar escape sequences are used in double-quoted strings and in fact the regexps in Perl are mostly treated as double-quoted strings. This means that variables can be used in regexps as well. Just like double-quoted strings, the values of the variables in the regexp will be substituted in before the regexp is evaluated for matching purposes. So we have:</source>
          <target state="translated">만약 당신이 Perl 주위에 있었다면,이 모든 이스케이프 시퀀스 이야기는 익숙해 보일 것입니다. 비슷한 이스케이프 시퀀스가 ​​큰 따옴표로 묶인 문자열에 사용되며 실제로 Perl의 정규 표현식은 대부분 큰 따옴표로 묶인 문자열로 처리됩니다. 이것은 변수를 정규 표현식에서도 사용할 수 있음을 의미합니다. 큰 따옴표로 묶인 문자열과 마찬가지로 정규 표현식이 일치하는 목적으로 평가되기 전에 정규 표현식의 변수 값이 대체됩니다. 그래서 우리는 :</target>
        </trans-unit>
        <trans-unit id="3fd6cd86298d336909fb8326200590d5396e0f52" translate="yes" xml:space="preserve">
          <source>If you've chosen to use vac 4, be sure to run 4.4.0.3. Older versions will turn up nasty later on. For vac 5 be sure to run at least 5.0.1.0, but vac 5.0.2.6 or up is highly recommended. Note that since IBM has removed vac 5.0.2.1 through 5.0.2.5 from the software depot, these versions should be considered obsolete.</source>
          <target state="translated">vac 4를 사용하기로 선택한 경우 4.4.0.3을 실행해야합니다. 이전 버전은 나중에 불쾌하게 나타납니다. vac 5의 경우 5.0.1.0 이상을 실행해야하지만 vac 5.0.2.6 이상을 권장합니다. IBM이 소프트웨어 저장소에서 vac 5.0.2.1에서 5.0.2.5를 제거 했으므로이 버전은 더 이상 사용되지 않는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="7f36de392e6562a98fef168bd0f4fd2b6d55a056" translate="yes" xml:space="preserve">
          <source>If you've found a bug with the perl interpreter or one of the modules in the standard library (those that come with Perl), you can use the &lt;a href=&quot;perlbug&quot;&gt;perlbug&lt;/a&gt; utility that comes with Perl (&amp;gt;= 5.004). It collects information about your installation to include with your message, then sends the message to the right place.</source>
          <target state="translated">Perl 인터프리터 또는 표준 라이브러리의 모듈 중 하나 (Perl과 함께 제공되는 버그)를 발견 한 경우 Perl 과 함께 제공 되는 &lt;a href=&quot;perlbug&quot;&gt;perlbug&lt;/a&gt; 유틸리티를 사용할 수 있습니다 (&amp;gt; = 5.004). 메시지에 포함 할 설치 정보를 수집 한 다음 메시지를 올바른 위치로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="b588af6702d40920fe6ce77142ddd4be23c82335" translate="yes" xml:space="preserve">
          <source>If you've just implemented a new feature, complete with doc, tests and well-commented code, a brief commit message will often suffice. If, however, you've just changed a single character deep in the parser or lexer, you might need to write a small novel to ensure that future readers understand what you did and why you did it.</source>
          <target state="translated">방금 새 기능을 구현하고 문서, 테스트 및 잘 작성된 코드로 완성 된 경우 간단한 커밋 메시지로 충분합니다. 그러나 파서 나 어휘 분석기에서 한 문자 만 깊게 변경 한 경우, 미래 독자가 자신이 한 일과 왜 그 일을 이해하도록 작은 소설을 작성해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8a6a3763262120fa20c3dbe30b8abff9d5efbc9" translate="yes" xml:space="preserve">
          <source>If you've played with the examples above and tried to embed a script that</source>
          <target state="translated">위의 예제를 사용하여 스크립트를 삽입하려고 시도한 경우</target>
        </trans-unit>
        <trans-unit id="b894c5ed183f4f7ceceb8937af0c436c24867f7d" translate="yes" xml:space="preserve">
          <source>If you've read all the documentation in the document and the ones listed above, you're more than ready to hack on Perl.</source>
          <target state="translated">문서의 모든 문서와 위에 나열된 문서를 모두 읽었다면 Perl을 해킹 할 준비가 된 것 이상입니다.</target>
        </trans-unit>
        <trans-unit id="f7a6adb80f0b785d2ca1e30e58d59926760d3865" translate="yes" xml:space="preserve">
          <source>If you've read this far in the docs, you've seen this:</source>
          <target state="translated">문서에서 이것을 멀리 읽었다면 다음을 보았습니다.</target>
        </trans-unit>
        <trans-unit id="a5397b1b280e497ccfa7136829a3dcfe46903bd5" translate="yes" xml:space="preserve">
          <source>If you've selected VMS syntax, and the file specification you pass to one of these routines contains a &quot;/&quot;, they assume you are using Unix emulation and apply the Unix syntax rules instead, for that function call only.</source>
          <target state="translated">VMS 구문을 선택하고 이러한 루틴 중 하나에 전달하는 파일 스펙에 &quot;/&quot;가 포함되어 있으면 해당 함수 호출에 대해서만 Unix 에뮬레이션을 사용하고 대신 Unix 구문 규칙을 적용한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="33caaa832315103fc3c31014628789c923502260" translate="yes" xml:space="preserve">
          <source>If you, as a user, do not need explicit access to the &quot;seen&quot; hash, then you can set the &lt;code&gt;Sparseseen&lt;/code&gt; option to allow Data::Dumper to eschew building the &quot;seen&quot; hash for scalars that are known not to possess more than one reference. This speeds up serialization considerably if you use the XS implementation.</source>
          <target state="translated">사용자로서 &quot;본&quot;해시에 대한 명시적인 액세스가 필요하지 않은 경우 &lt;code&gt;Sparseseen&lt;/code&gt; 을 설정할 수 있습니다 옵션을 Data :: Dumper가 다음을 소유하지 않는 스칼라에 대한 &quot;본&quot;해시 작성을 하나의 참조. XS 구현을 사용하면 직렬화 속도가 상당히 빨라집니다.</target>
        </trans-unit>
        <trans-unit id="5641fffcc326bff3bce0a7d7f55bb29dc536ec90" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;DESTROY&lt;/code&gt; method issues a warning during global destruction, the Perl interpreter will append the string &quot; during global destruction&quot; to the warning.</source>
          <target state="translated">당신이 경우 &lt;code&gt;DESTROY&lt;/code&gt; 방법 문제를 글로벌 파괴하는 동안 경고를, 펄 인터프리터는 경고에 &quot;글로벌 파괴하는 동안&quot;문자열을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="e35bc3de6478c74b3aa05b11b90d2c08a9c1eb35" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;DESTROY&lt;/code&gt; method throws an error, this error will be ignored. It will not be sent to &lt;code&gt;STDERR&lt;/code&gt; and it will not cause the program to die. However, if your destructor is running inside an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; block, then the error will change the value of &lt;code&gt;$@&lt;/code&gt; .</source>
          <target state="translated">귀하의 경우 &lt;code&gt;DESTROY&lt;/code&gt; 방법에서 오류가 발생,이 오류는 무시됩니다. &lt;code&gt;STDERR&lt;/code&gt; 로 전송 되지 않으며 프로그램이 종료되지 않습니다. 그러나 소멸자가 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; 블록 내에서 실행중인 경우 오류로 인해 &lt;code&gt;$@&lt;/code&gt; 값이 변경됩니다 .</target>
        </trans-unit>
        <trans-unit id="bd8f1a46e80e1b05c149003c578cc17ee1529e3e" translate="yes" xml:space="preserve">
          <source>If your AIX is installed with 64-bit support, you can expect 64-bit configurations to work. In combination with threads some tests might still fail.</source>
          <target state="translated">AIX가 64 비트 지원으로 설치된 경우 64 비트 구성이 작동 할 것으로 예상 할 수 있습니다. 스레드와 함께 일부 테스트는 여전히 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91cec945ceabbd679cf0509d145b2a724547b098" translate="yes" xml:space="preserve">
          <source>If your AIX system is installed with 64-bit support, you can expect 64-bit configurations to work. If you want to use 64-bit Perl on AIX 6.1 you need an APAR for a libc.a bug which affects (n)dbm_XXX functions. The APAR number for this problem is IZ39077.</source>
          <target state="translated">AIX 시스템이 64 비트 지원으로 설치된 경우 64 비트 구성이 작동 할 것으로 예상 할 수 있습니다. AIX 6.1에서 64 비트 Perl을 사용하려면 (n) dbm_XXX 함수에 영향을주는 libc.a 버그에 대한 APAR이 필요합니다. 이 문제점의 APAR 번호는 IZ39077입니다.</target>
        </trans-unit>
        <trans-unit id="70f3f72afc2e138648aa89e71840c2969a866fbe" translate="yes" xml:space="preserve">
          <source>If your EXISTS function returns true, Memoize will try to fetch the cached value by invoking &lt;code&gt;C-&amp;gt;FETCH(key)&lt;/code&gt; . MyExpirePolicy::FETCH should return the cached value. Otherwise, Memoize will call the memoized function to compute the appropriate value, and will store it into the cache by calling &lt;code&gt;C-&amp;gt;STORE(key, value)&lt;/code&gt; .</source>
          <target state="translated">EXISTS 함수가 true를 반환하면 Memoize는 &lt;code&gt;C-&amp;gt;FETCH(key)&lt;/code&gt; 호출하여 캐시 된 값을 가져 오려고 시도합니다 . MyExpirePolicy :: FETCH는 캐시 된 값을 반환해야합니다. 그렇지 않으면 Memoize는 메모 된 함수를 호출하여 적절한 값을 계산하고 &lt;code&gt;C-&amp;gt;STORE(key, value)&lt;/code&gt; 를 호출하여이를 캐시에 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="0e28af787c875d4ef84c9b0c4d899259d2721791" translate="yes" xml:space="preserve">
          <source>If your PO and MO files are under a path elsewhere than &lt;code&gt;auto/&lt;/code&gt; , you may specify it using the &lt;code&gt;Path&lt;/code&gt; option.</source>
          <target state="translated">PO 및 MO 파일이 &lt;code&gt;auto/&lt;/code&gt; 이외 의 &lt;code&gt;Path&lt;/code&gt; 있는 경우 경로 옵션을 사용하여 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58c89e96cd32d30e30553bcd6fbdd11d2690ecc7" translate="yes" xml:space="preserve">
          <source>If your Perl book isn't listed and you think it should be, let us know.</source>
          <target state="translated">Perl 책이 나열되어 있지 않다고 생각되면 알려주십시오.</target>
        </trans-unit>
        <trans-unit id="6d6e9b58c49da08447f00e52e9068c5bb7576426" translate="yes" xml:space="preserve">
          <source>If your Perl script is itself encoded in &lt;a href=&quot;#Unicode-Encodings&quot;&gt;UTF-8&lt;/a&gt;, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; pragma must be explicitly included to enable recognition of that (in string or regular expression literals, or in identifier names). &lt;b&gt;This is the only time when an explicit &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
utf8&lt;/code&gt; is needed.&lt;/b&gt; (See &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt;).</source>
          <target state="translated">펄 스크립트는 그 자체로 인코딩 된 경우 &lt;a href=&quot;#Unicode-Encodings&quot;&gt;UTF-8&lt;/a&gt; 의 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 프라그를 명시 적으로 (문자열이나 정규 표현식 리터럴에서, 또는 식별자 이름에) 그 인식을 가능하게 포함되어야합니다. &lt;b&gt; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; &lt;/b&gt;&lt;b&gt; 명시 적으로 &lt;a href=&quot;functions/use&quot;&gt;사용해야&lt;/a&gt; 하는 경우입니다. &lt;/b&gt;( &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="1456eed38b989e671412e5dabebc6b17a35fdee8" translate="yes" xml:space="preserve">
          <source>If your Perl success stories and testimonials may be of help to others who wish to advocate the use of Perl in their applications, or if you wish to simply express your gratitude to Larry and the Perl developers, please write to perl-thanks@perl.org .</source>
          <target state="translated">Perl 성공 사례 및 회원 평가가 Perl의 응용 프로그램 사용을 옹호하고자하는 다른 사람들에게 도움이 될 수 있거나 Larry 및 Perl 개발자에게 감사의 말을 전하고 싶다면 perl-thanks @ perl에게 문의하십시오. org.</target>
        </trans-unit>
        <trans-unit id="bb4511b53500ce7e796c6be816fd150d579ce6bd" translate="yes" xml:space="preserve">
          <source>If your Perl was configured with &lt;b&gt;-Accflags=-DPERL_MEM_LOG&lt;/b&gt;, setting the environment variable &lt;code&gt;PERL_MEM_LOG&lt;/code&gt; enables logging debug messages. The value has the form &lt;code&gt;&amp;lt;&lt;i&gt;number&lt;/i&gt;&amp;gt;[m][s][t]&lt;/code&gt;, where &lt;code&gt;&lt;i&gt;number&lt;/i&gt;&lt;/code&gt; is the file descriptor number you want to write to (2 is default), and the combination of letters specifies that you want information about (m)emory and/or (s)v, optionally with (t)imestamps. For example, &lt;code&gt;PERL_MEM_LOG=1mst&lt;/code&gt; logs all information to stdout. You can write to other opened file descriptors in a variety of ways:</source>
          <target state="translated">Perl이 &lt;b&gt;-Accflags = -DPERL_MEM_LOG&lt;/b&gt; 로 구성된 경우 환경 변수 &lt;code&gt;PERL_MEM_LOG&lt;/code&gt; 를 설정하면 디버그 메시지 로깅이 가능합니다. 값의 형식은 &lt;code&gt;&amp;lt;&lt;i&gt;number&lt;/i&gt;&amp;gt;[m][s][t]&lt;/code&gt; 입니다. 이며, 여기서 &lt;code&gt;&lt;i&gt;number&lt;/i&gt;&lt;/code&gt; 는 쓰려는 파일 설명자 번호 (기본값은 2)이며 문자 조합은 (m)에 대한 정보를 원한다고 지정합니다. 에 모리 및 / 또는 (s) v, 선택적으로 (t) imestamps. 예를 들어 &lt;code&gt;PERL_MEM_LOG=1mst&lt;/code&gt; 는 모든 정보를 stdout에 기록합니다. 다양한 방법으로 열린 다른 파일 설명자에 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="283276e9d183ad9eef7a4c2f27ba79df3995c5ec" translate="yes" xml:space="preserve">
          <source>If your algorithm requires that &lt;code&gt;reduce&lt;/code&gt; produce an identity value, then make sure that you always pass that identity value as the first argument to prevent &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; being returned</source>
          <target state="translated">알고리즘에 필요한 경우 &lt;code&gt;reduce&lt;/code&gt; 에서 ID 값 줄여야 하는 경우 항상 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 리턴 되지 않도록 첫 번째 인수로 해당 ID 값을 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="826651d97de1fb76050036181700ee31a9d7cf34" translate="yes" xml:space="preserve">
          <source>If your application requires accepting data from untrusted sources, you are best off with a less powerful and more-likely safe serialization format and implementation. If your data is sufficiently simple, JSON is a good choice and offers maximum interoperability.</source>
          <target state="translated">응용 프로그램에서 신뢰할 수없는 출처의 데이터를 수락해야하는 경우 덜 강력하고 안전한 직렬화 형식 및 구현을 사용하는 것이 가장 좋습니다. 데이터가 충분히 단순하면 JSON을 선택하는 것이 좋으며 최대의 상호 운용성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6fedf0cadcf133b09c8efb7dc310cff7b7302cdf" translate="yes" xml:space="preserve">
          <source>If your changes are in a single git commit, run the following commands to generate the patch file and attach it to your bug report:</source>
          <target state="translated">변경 사항이 단일 git commit에있는 경우 다음 명령을 실행하여 패치 파일을 생성하여 버그 보고서에 첨부하십시오.</target>
        </trans-unit>
        <trans-unit id="db2c1fd426ed9f2c60db2929723c4b3e4c8b99fa" translate="yes" xml:space="preserve">
          <source>If your changes are in multiple commits, generate a patch file for each one and provide them to perlbug's &lt;code&gt;-p&lt;/code&gt; option separated by commas:</source>
          <target state="translated">변경 사항이 여러 커밋에있는 경우 각각에 대해 패치 파일을 생성하고 쉼표로 구분 된 perlbug의 &lt;code&gt;-p&lt;/code&gt; 옵션 을 제공하십시오 .</target>
        </trans-unit>
        <trans-unit id="e23115cc45aeaf527b25ea3227a4ca58a4bbcf8b" translate="yes" xml:space="preserve">
          <source>If your class does have an &lt;code&gt;AUTOLOAD&lt;/code&gt; method, we strongly recommend that you override &lt;code&gt;can&lt;/code&gt; in your class as well. Your overridden &lt;code&gt;can&lt;/code&gt; method should return a subroutine reference for any method that your &lt;code&gt;AUTOLOAD&lt;/code&gt; responds to.</source>
          <target state="translated">클래스에 &lt;code&gt;AUTOLOAD&lt;/code&gt; 메소드 가있는 경우 클래스 에서 &lt;code&gt;can&lt;/code&gt; 을 재정의하는 것이 좋습니다 . 재정의 된 &lt;code&gt;can&lt;/code&gt; 메소드는 &lt;code&gt;AUTOLOAD&lt;/code&gt; 가 응답 하는 메소드에 대한 서브 루틴 참조를 리턴해야 합니다.</target>
        </trans-unit>
        <trans-unit id="ce7692bb0712bd055e295162eb35d771d86fcad6" translate="yes" xml:space="preserve">
          <source>If your class responds to method calls via &lt;code&gt;AUTOLOAD&lt;/code&gt; , you may want to overload &lt;code&gt;can&lt;/code&gt; to return a subroutine reference for methods which your &lt;code&gt;AUTOLOAD&lt;/code&gt; method handles.</source>
          <target state="translated">클래스가 &lt;code&gt;AUTOLOAD&lt;/code&gt; 를 통해 메소드 호출에 응답하는 경우 &lt;code&gt;AUTOLOAD&lt;/code&gt; 메소드가 처리 하는 메소드에 대한 서브 루틴 참조를 리턴 하도록 오버로드 &lt;code&gt;can&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d51ef4c74c99126a798f834a23d66ffbb341d516" translate="yes" xml:space="preserve">
          <source>If your code is destined for systems with severely constrained (or missing!) virtual memory systems then you want to be</source>
          <target state="translated">가상 메모리 시스템이 심각하게 제약 된 (또는 누락 된) 시스템으로 코드가 예정된 경우</target>
        </trans-unit>
        <trans-unit id="b8ec960b62faa8f2d9e01172beeee1747d962ecd" translate="yes" xml:space="preserve">
          <source>If your code is to run on Perl versions earlier than 5.20, it is worthwhile to note that using &lt;code&gt;$`&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt; slows down regexp matching quite a bit, while &lt;code&gt;$&amp;amp;&lt;/code&gt; slows it down to a lesser extent, because if they are used in one regexp in a program, they are generated for</source>
          <target state="translated">코드가 5.20 이전의 Perl 버전에서 실행되는 경우 &lt;code&gt;$`&lt;/code&gt; 및 &lt;code&gt;$'&lt;/code&gt; 을 사용 하면 정규 표현식 일치 속도가 약간 느려지고 &lt;code&gt;$&amp;amp;&lt;/code&gt; 는 코드를 조금만 느리게합니다. 프로그램에서 하나의 정규 표현식으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="f35b1b808d1504007b3ea085214451b1ee61358c" translate="yes" xml:space="preserve">
          <source>If your code just uses the 52 letters A-Z and a-z, plus SPACE, the digits 0-9, and the punctuation characters that Perl uses, plus a few controls that are denoted by escape sequences like &lt;code&gt;\n&lt;/code&gt; and &lt;code&gt;\t&lt;/code&gt; , then there's nothing special about using Perl, and your code may very well work on an ASCII machine without change.</source>
          <target state="translated">코드에서 52 문자 AZ와 az, SPACE, 숫자 0-9 및 Perl이 사용하는 문장 부호 문자 및 &lt;code&gt;\t&lt;/code&gt; &lt;code&gt;\n&lt;/code&gt; 및 \ t 와 같은 이스케이프 시퀀스로 표시되는 몇 가지 컨트롤을 사용하는 경우 특별한 것은 없습니다. Perl 사용에 대한 정보는 코드가 ASCII 시스템에서 잘 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e9b4a996206aa3ecbfc36df229dca4fb6c7a7b5" translate="yes" xml:space="preserve">
          <source>If your code still needs to run on older versions, stick to &lt;code&gt;foreach&lt;/code&gt; for your topicalizer and you will be less unhappy.</source>
          <target state="translated">코드가 여전히 이전 버전에서 실행 되어야한다면, 당신의 토탈 라이저 를 위해 &lt;code&gt;foreach&lt;/code&gt; 를 고수하면 덜 불행해질 것입니다.</target>
        </trans-unit>
        <trans-unit id="dcc0823ff9797cfd85918a8c234e7eca9a51dc4f" translate="yes" xml:space="preserve">
          <source>If your command contains &lt;b&gt;special characters&lt;/b&gt; (&amp;lt; &amp;gt; | &amp;amp;), it will be internally stringified before executing the command, to avoid that these special characters are escaped and passed as arguments instead of retaining their special meaning.</source>
          <target state="translated">명령에 &lt;b&gt;특수 문자&lt;/b&gt; (&amp;lt;&amp;gt; | &amp;amp;)가 포함 된 경우 명령을 실행하기 전에 내부적으로 문자열 화되어 특수 문자가 특수 의미를 유지하는 대신 이스케이프되어 인수로 전달되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="cf42d5b15f10438a9ce2c86e1004158d46b18003" translate="yes" xml:space="preserve">
          <source>If your copy of Perl is recent enough to contain this documentation (version 5.002 or later), then the perl library (and</source>
          <target state="translated">Perl 사본이이 문서 (버전 5.002 이상)를 포함 할 수있을 정도로 최근 인 경우, Perl 라이브러리 (및</target>
        </trans-unit>
        <trans-unit id="2fc9b0cc9eec68d672ffff71ad1ff12aed25c2cc" translate="yes" xml:space="preserve">
          <source>If your encoding can work with PerlIO but needs line buffering, you MUST define this method so it returns true. 7bit ISO-2022 encodings are one example that needs this. When this method is missing, false is assumed.</source>
          <target state="translated">인코딩이 PerlIO와 작동하지만 라인 버퍼링이 필요한 경우이 메소드를 정의하여 true를 리턴해야합니다. 7 비트 ISO-2022 인코딩이 필요한 예입니다. 이 방법이 없으면 거짓으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="d924438284770c83006ec82d036605b95adc1613" translate="yes" xml:space="preserve">
          <source>If your encoding does not support PerlIO for some reasons, just;</source>
          <target state="translated">어떤 이유로 인코딩이 PerlIO를 지원하지 않는 경우;</target>
        </trans-unit>
        <trans-unit id="1bb14712099b199ef0cd902ac0e502361e5d3ab8" translate="yes" xml:space="preserve">
          <source>If your executables start with something like #!perl or #!/usr/bin/perl MakeMaker will change this to the path of the perl 'Makefile.PL' was invoked with so the programs will be sure to run properly even if perl is not in /usr/bin/perl.</source>
          <target state="translated">실행 파일이 #! perl 또는 #! / usr / bin / perl과 같은 것으로 시작하면 MakeMaker는 이것을 perl 'Makefile.PL'이 호출 된 경로로 변경하므로 perl이 / usr / bin / perl에는 없습니다.</target>
        </trans-unit>
        <trans-unit id="0c644837e9e9bd2635823c6fa674e7d01fcd0f60" translate="yes" xml:space="preserve">
          <source>If your extension uses some features of Perl which are not available on older releases of Perl, your users would appreciate an early meaningful warning. You would probably put this information into the</source>
          <target state="translated">확장 프로그램이 이전 버전의 Perl에서 사용할 수없는 Perl의 일부 기능을 사용하는 경우, 사용자는 조기에 의미있는 경고에 감사 할 것입니다. 이 정보를</target>
        </trans-unit>
        <trans-unit id="adbe147193e70e68bb2371038fd445f29bb86c7b" translate="yes" xml:space="preserve">
          <source>If your function already returns a reference, you don't need to create the reference yourself.</source>
          <target state="translated">함수가 이미 참조를 반환하면 직접 참조를 만들 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8e3814e00e4bd2f311a16402f4ba979bbd48ac96" translate="yes" xml:space="preserve">
          <source>If your gcc is configured to use GNU as and ld but you want to use the Solaris ones instead to build perl, then you'll need to add -B/usr/ccs/bin/ to the gcc command line. One convenient way to do that is with</source>
          <target state="translated">gcc가 GNU as 및 ld를 사용하도록 구성되어 있지만 Solaris를 사용하여 perl을 빌드하려는 경우 gcc 명령 행에 -B / usr / ccs / bin /을 추가해야합니다. 이를 수행하는 한 가지 편리한 방법은</target>
        </trans-unit>
        <trans-unit id="5872fc905315842d011082a682a6367cfb7ca9e6" translate="yes" xml:space="preserve">
          <source>If your hash could have repeated values, the methods above will only find one of the associated keys. This may or may not worry you. If it does worry you, you can always reverse the hash into a hash of arrays instead:</source>
          <target state="translated">해시가 반복되는 값을 가질 수 있다면 위의 방법은 관련 키 중 하나만 찾습니다. 걱정할 수도 있고 걱정하지 않을 수도 있습니다. 걱정되는 경우 해시를 항상 해시 배열로 되돌릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7de42f17abf69fc8056c809db5d175a47bd9c23" translate="yes" xml:space="preserve">
          <source>If your input is binary, and is supposed to remain binary, you shouldn't decode it to a text string, of course. But in all other cases, you should decode it.</source>
          <target state="translated">입력이 이진이고 이진으로 유지되어야하는 경우 물론 텍스트 문자열로 디코딩해서는 안됩니다. 그러나 다른 모든 경우에는 디코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="d2667a072564b25eaaca13a334f7f9d262c4dc4d" translate="yes" xml:space="preserve">
          <source>If your lexicon is a tied hash the simple act of caching the compiled value can be fatal.</source>
          <target state="translated">어휘집이 묶인 해시라면 컴파일 된 값을 캐싱하는 간단한 작업이 치명적일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84a874bfb13cfbdc7a992429f47c0892596ec6c2" translate="yes" xml:space="preserve">
          <source>If your locale environment variables (&lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_CTYPE&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; ) contain the strings 'UTF-8' or 'UTF8' (case-insensitive matching), the default encoding of your &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; , and &lt;code&gt;STDERR&lt;/code&gt; , and of &lt;b&gt;any subsequent file open&lt;/b&gt;, is UTF-8.</source>
          <target state="translated">로케일 환경 변수 (경우 &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_CTYPE&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; 가 ) 문자열 'UTF8'또는 'UTF8'(대소 문자 구분 일치)를 포함, 기본 당신의 인코딩 &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; , 및 &lt;code&gt;STDERR&lt;/code&gt; , 그리고 &lt;b&gt;이후의 파일 열기&lt;/b&gt; , UTF-8입니다.</target>
        </trans-unit>
        <trans-unit id="6549b9662c9333f9038a43e101cb863214588ba8" translate="yes" xml:space="preserve">
          <source>If your locale is a UTF-8 locale, starting in Perl v5.20, Perl works well for all categories except &lt;code&gt;LC_COLLATE&lt;/code&gt; dealing with sorting and the &lt;code&gt;cmp&lt;/code&gt; operator.</source>
          <target state="translated">로케일이 Perl v5.20에서 시작하는 UTF-8 로케일 인 경우 Perl은 정렬 및 &lt;code&gt;cmp&lt;/code&gt; 연산자를 처리하는 &lt;code&gt;LC_COLLATE&lt;/code&gt; 를 제외한 모든 카테고리에서 잘 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="b3b150d3cc1b32cbef03e749b88c3f5c90012ceb" translate="yes" xml:space="preserve">
          <source>If your newly minted styles refer to any new #variables, you'll need to define a callback subroutine that will populate (or modify) those variables. They are then available for use in the style you've chosen.</source>
          <target state="translated">새로 작성된 스타일이 새로운 # 변수를 참조하는 경우 해당 변수를 채우거나 수정할 콜백 서브 루틴을 정의해야합니다. 그런 다음 선택한 스타일로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db09b35e2a7d627ad25d25e5e66ae789bbe364b8" translate="yes" xml:space="preserve">
          <source>If your operating system supports a proper mv(1) utility or its functional equivalent, this works:</source>
          <target state="translated">운영 체제가 적절한 mv (1) 유틸리티 또는 이와 동등한 기능을 지원하는 경우 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b728e9092f3f9368f8a8be6c5ce7886b0a62de25" translate="yes" xml:space="preserve">
          <source>If your patch changes code (rather than just changing documentation), you should also include one or more test cases which illustrate the bug you're fixing or validate the new functionality you're adding. In general, you should update an existing test file rather than create a new one.</source>
          <target state="translated">패치가 문서를 변경하는 대신 코드를 변경하는 경우 수정중인 버그를 설명하거나 추가중인 새 기능의 유효성을 검사하는 테스트 사례를 하나 이상 포함해야합니다. 일반적으로 새 테스트 파일을 작성하지 않고 기존 테스트 파일을 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="78a3de11301e669e248cee7c9e70b2562ff6e9f5" translate="yes" xml:space="preserve">
          <source>If your perl does not support times larger than &lt;code&gt;2^31&lt;/code&gt; seconds then this module is likely to fail at processing dates beyond the year 2038. There are moves afoot to fix that in perl. Alternatively use 64 bit perl. Or if none of those are options, use the &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; module which has support for years well into the future and past.</source>
          <target state="translated">펄이 &lt;code&gt;2^31&lt;/code&gt; 초 보다 큰 시간을 지원하지 않으면 이 모듈은 2038 년이 지난 날짜를 처리 할 때 실패 할 가능성이 높습니다. 또는 64 비트 perl을 사용하십시오. 또는 옵션이없는 경우 미래와 과거를 잘 지원 하는 &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; 모듈을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b5f6d77f27ea6c645390efe18bf989b76fa95e9b" translate="yes" xml:space="preserve">
          <source>If your perl is compiled with &lt;code&gt;-DDEBUGGING&lt;/code&gt; , you may use the &lt;b&gt;-Dr&lt;/b&gt; flag on the command line.</source>
          <target state="translated">당신의 펄이 컴파일되면 &lt;code&gt;-DDEBUGGING&lt;/code&gt; , 당신은 사용할 수 있습니다 &lt;b&gt;윈터 톤의&lt;/b&gt; 명령 행에 플래그.</target>
        </trans-unit>
        <trans-unit id="6fb3bbcc486c0ac676b28f725bda572e8ce7d210" translate="yes" xml:space="preserve">
          <source>If your perl is using Perl's malloc() and was compiled with the necessary switches (this is the default), then it will print memory usage statistics after compiling your code when &lt;code&gt;$ENV{PERL_DEBUG_MSTATS}
&amp;gt; 1&lt;/code&gt; , and before termination of the program when &lt;code&gt;$ENV{PERL_DEBUG_MSTATS} &amp;gt;= 1&lt;/code&gt; . The report format is similar to the following example:</source>
          <target state="translated">perl이 Perl의 malloc ()을 사용하고 필요한 스위치로 컴파일 된 경우 (이것이 기본값 임) &lt;code&gt;$ENV{PERL_DEBUG_MSTATS} &amp;gt; 1&lt;/code&gt; 일 때 코드를 컴파일 한 후 프로그램 종료 전에 메모리 사용 통계를 인쇄합니다. &lt;code&gt;$ENV{PERL_DEBUG_MSTATS} &amp;gt;= 1&lt;/code&gt; . 보고서 형식은 다음 예제와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="a0ec21abacef113106404f37c8ffeaf0991584f3" translate="yes" xml:space="preserve">
          <source>If your perl supports &lt;code&gt;PerlIO&lt;/code&gt; (which is the default), you can use a &lt;code&gt;PerlIO&lt;/code&gt; layer to decode and encode directly via a filehandle. The following two examples are fully identical in functionality:</source>
          <target state="translated">perl이 &lt;code&gt;PerlIO&lt;/code&gt; (기본값)를 지원 하는 경우 &lt;code&gt;PerlIO&lt;/code&gt; 레이어를 사용 하여 파일 핸들을 통해 직접 디코딩하고 인코딩 할 수 있습니다 . 다음 두 예는 기능면에서 완전히 동일합니다.</target>
        </trans-unit>
        <trans-unit id="091f7db96070043c9514e8ee2a91acbe99a23b27" translate="yes" xml:space="preserve">
          <source>If your rc file contains:</source>
          <target state="translated">rc 파일에 다음이 포함 된 경우 :</target>
        </trans-unit>
        <trans-unit id="1cc732c143d69a605c4a486fe1919dbc8511b3b7" translate="yes" xml:space="preserve">
          <source>If your routine iterates through some kind of list (such as a list of files, or records in a database) you may consider providing a callback so that users can manipulate each element of the list in turn. File::Find provides an example of this with its &lt;code&gt;find(\&amp;amp;wanted, $dir)&lt;/code&gt; syntax.</source>
          <target state="translated">루틴이 일종의 목록 (예 : 파일 목록 또는 데이터베이스의 레코드 등)을 반복하는 경우 사용자가 목록의 각 요소를 차례로 조작 할 수 있도록 콜백을 제공하는 것을 고려할 수 있습니다. File :: Find는 &lt;code&gt;find(\&amp;amp;wanted, $dir)&lt;/code&gt; 구문 과 함께 이에 대한 예를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="20d69711a4dff3eb5c2c54e4925f7a2d49b42d0e" translate="yes" xml:space="preserve">
          <source>If your script works with huge numbers and Calc is too slow for them, you can also for the loading of one of these libraries and if none of them can be used, the code will die:</source>
          <target state="translated">스크립트가 큰 숫자로 작동하고 Calc가 너무 느리면 이러한 라이브러리 중 하나를로드 할 수 있으며 사용할 수 없으면 코드가 죽습니다.</target>
        </trans-unit>
        <trans-unit id="686d70af0d50a3bff3e29e104e2f82c37c794acd" translate="yes" xml:space="preserve">
          <source>If your stdio requires a seek or eof between reads and writes on a particular stream, so does Perl. (This doesn't apply to sysread() and syswrite().)</source>
          <target state="translated">stdio가 특정 스트림에서 읽기와 쓰기 사이에 탐색 또는 eof를 요구하는 경우 Perl도 마찬가지입니다. (sysread () 및 syswrite ()에는 적용되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="34ff0a2e68bd649cc4624def7ce4b58902e2e24e" translate="yes" xml:space="preserve">
          <source>If your subsecond sleeping is implemented with &lt;code&gt;nanosleep()&lt;/code&gt; instead of &lt;code&gt;usleep()&lt;/code&gt; , you can mix subsecond sleeping with signals since &lt;code&gt;nanosleep()&lt;/code&gt; does not use signals. This, however, is not portable, and you should first check for the truth value of &lt;code&gt;&amp;amp;Time::HiRes::d_nanosleep&lt;/code&gt; to see whether you have nanosleep, and then carefully read your &lt;code&gt;nanosleep()&lt;/code&gt; C API documentation for any peculiarities.</source>
          <target state="translated">Subsleep 수면이 &lt;code&gt;usleep()&lt;/code&gt; &lt;code&gt;nanosleep()&lt;/code&gt; 대신 nanosleep ()으로 구현 된 경우 &lt;code&gt;nanosleep()&lt;/code&gt; 은 신호를 사용하지 않으므로 1 초 미만의 수면을 신호와 혼합 할 수 있습니다 . 그러나 이것은 이식성이 없으며 먼저 &lt;code&gt;&amp;amp;Time::HiRes::d_nanosleep&lt;/code&gt; 값을 확인하여 나노 슬립 이 있는지 확인한 다음, 특이성에 대한 &lt;code&gt;nanosleep()&lt;/code&gt; C API 설명서를 주의해서 읽어야합니다 .</target>
        </trans-unit>
        <trans-unit id="7033933f15e134ae512f052ac986d8b0ac72a9af" translate="yes" xml:space="preserve">
          <source>If your system doesn't support dynamic loading, you still probably ought to use &lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt;. See &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; and &lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; for more information (in brief, just use &lt;b&gt;make perl&lt;/b&gt; instead of a plain &lt;b&gt;make&lt;/b&gt; to rebuild perl with a new static extension).</source>
          <target state="translated">시스템이 동적 로딩을 지원하지 않으면 여전히 &lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt; 를 사용해야 합니다. 자세한 내용은 &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; 및 &lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils :: MakeMaker&lt;/a&gt; 를 참조하십시오 (간단히, 새로운 정적 확장을 사용 &lt;b&gt;하여 perl&lt;/b&gt; 을 다시 빌드하려면 일반 &lt;b&gt;make&lt;/b&gt; 대신 &lt;b&gt;make perl을&lt;/b&gt; 사용하십시오 ).</target>
        </trans-unit>
        <trans-unit id="976a5d23704d8a7827f274e64a1b65ab7ed369e5" translate="yes" xml:space="preserve">
          <source>If your system has a strange pointer size--meaning a pointer is neither as big as an int nor as big as a long--it may not be possible to pack or unpack pointers in big- or little-endian byte order. Attempting to do so raises an exception.</source>
          <target state="translated">시스템에 이상한 포인터 크기가있는 경우 (포인터가 int만큼 크거나 길지 않다는 것을 의미) 포인터를 빅 엔디안 또는 리틀 엔디안 바이트 순서로 패키징하거나 언 패킹하지 못할 수 있습니다. 그렇게하려고하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c8f634435d2540d4ac325a2965a4ae17a54489a6" translate="yes" xml:space="preserve">
          <source>If your system has the &lt;code&gt;sigaction()&lt;/code&gt; function then signal handlers are installed using it. This means you get reliable signal handling.</source>
          <target state="translated">시스템에 &lt;code&gt;sigaction()&lt;/code&gt; 함수가있는 경우이를 사용하여 신호 핸들러가 설치됩니다. 따라서 안정적인 신호 처리가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="fd4695d7aa352602cd4c4febe7f1355134b6280c" translate="yes" xml:space="preserve">
          <source>If your system lacks &lt;code&gt;gettimeofday()&lt;/code&gt; or an emulation of it you don't get &lt;code&gt;gettimeofday()&lt;/code&gt; or the one-argument form of &lt;code&gt;tv_interval()&lt;/code&gt; . If your system lacks all of &lt;code&gt;nanosleep()&lt;/code&gt; , &lt;code&gt;usleep()&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;poll&lt;/code&gt; , you don't get &lt;code&gt;Time::HiRes::usleep()&lt;/code&gt; , &lt;code&gt;Time::HiRes::nanosleep()&lt;/code&gt; , or &lt;code&gt;Time::HiRes::sleep()&lt;/code&gt; . If your system lacks both &lt;code&gt;ualarm()&lt;/code&gt; and &lt;code&gt;setitimer()&lt;/code&gt; you don't get &lt;code&gt;Time::HiRes::ualarm()&lt;/code&gt; or &lt;code&gt;Time::HiRes::alarm()&lt;/code&gt; .</source>
          <target state="translated">시스템에 &lt;code&gt;gettimeofday()&lt;/code&gt; 또는 에뮬레이션이없는 경우 &lt;code&gt;gettimeofday()&lt;/code&gt; 또는 1 인수의 인수를 얻지 못합니다. &lt;code&gt;tv_interval()&lt;/code&gt; . 시스템에 &lt;code&gt;nanosleep()&lt;/code&gt; , &lt;code&gt;usleep()&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;poll&lt;/code&gt; 이 모두 없으면 &lt;code&gt;Time::HiRes::usleep()&lt;/code&gt; , &lt;code&gt;Time::HiRes::nanosleep()&lt;/code&gt; 또는 &lt;code&gt;Time::HiRes::sleep()&lt;/code&gt; 얻지 못합니다. HiRes :: sleep () . 시스템이 모두 부족하면 &lt;code&gt;ualarm()&lt;/code&gt; 과 &lt;code&gt;setitimer()&lt;/code&gt; 당신이 얻을하지 않는 &lt;code&gt;Time::HiRes::ualarm()&lt;/code&gt; 또는 &lt;code&gt;Time::HiRes::alarm()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3404e2a55faf84740517a5a0e24d39c3bdace4c" translate="yes" xml:space="preserve">
          <source>If your system supports dynamic loading, for reasons of portability and sanity you probably ought to use &lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt; (also part of the standard perl distribution). This tool converts C header files to Perl extensions. See &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; for how to get started with &lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt;.</source>
          <target state="translated">시스템이 동적 로딩을 지원하는 경우 이식성과 안정성으로 인해 &lt;a href=&quot;h2xs&quot;&gt;h2x&lt;/a&gt; (표준 perl 배포의 일부) 를 사용해야 합니다. 이 도구는 C 헤더 파일을 Perl 확장자로 변환합니다. &lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt; 시작 방법 은 &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c32ad1b9a818a02634ef64d7fbd9495e5b9eebf0" translate="yes" xml:space="preserve">
          <source>If your system supports the portable operating system programming interface (POSIX), you can use the following code, which you'll note turns off echo processing as well.</source>
          <target state="translated">시스템이 휴대용 운영 체제 프로그래밍 인터페이스 (POSIX)를 지원하는 경우 다음 코드를 사용할 수 있습니다.이 코드는 에코 처리 기능도 해제합니다.</target>
        </trans-unit>
        <trans-unit id="cf51a5f9f685e20ec9fa41065bc4bbf9f512757f" translate="yes" xml:space="preserve">
          <source>If z is a pure real number (i.e. &lt;code&gt;b == 0&lt;/code&gt; ), then the above yields:</source>
          <target state="translated">z가 순수한 실수 (예 : &lt;code&gt;b == 0&lt;/code&gt; )이면 위와 같이됩니다.</target>
        </trans-unit>
        <trans-unit id="866f3e73958b23adbe3e41bd3c02c8704cd81475" translate="yes" xml:space="preserve">
          <source>If, and only if, a token is a bailout token, you can get an &quot;explanation&quot; via this method. The explanation is the text after the mystical &quot;Bail out!&quot; words which appear in the tap output.</source>
          <target state="translated">토큰이 구제 금융 토큰 인 경우에만이 방법을 통해 &quot;설명&quot;을 얻을 수 있습니다. 설명은 신비한 &quot;Bail out!&quot;이후의 텍스트입니다. 탭 출력에 나타나는 단어.</target>
        </trans-unit>
        <trans-unit id="4f07d749cb3d9f280003a3874694f44dd0f9a196" translate="yes" xml:space="preserve">
          <source>If, at the end of a run you get the message</source>
          <target state="translated">실행이 끝나면 메시지가 표시되면</target>
        </trans-unit>
        <trans-unit id="748ad1a2344142dff26b49b0321a5e20db97e62e" translate="yes" xml:space="preserve">
          <source>If, for a given file, Perl is unable to create the backup file as specified in the extension then it will skip that file and continue on with the next one (if it exists).</source>
          <target state="translated">주어진 파일에 대해 Perl이 확장자에 지정된대로 백업 파일을 작성할 수 없으면 해당 파일을 건너 뛰고 다음 파일 (있는 경우)로 계속 진행합니다.</target>
        </trans-unit>
        <trans-unit id="3190be8312e8fef021a8d99a686331f02896c645" translate="yes" xml:space="preserve">
          <source>If, for some odd reason, you really want to see the whole file at once rather than processing line-by-line, you can slurp it in (as long as you can fit the whole thing in memory!):</source>
          <target state="translated">이상한 이유 때문에 한 줄씩 처리하지 않고 전체 파일을 한 번에 보려면 실제로 메모리에 모든 내용을 넣을 수있는 한 파일 전체를 살펴볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8294d55294098cd1496efb3523c86ff173cf45ca" translate="yes" xml:space="preserve">
          <source>If, for some reason, you have a file descriptor instead of a filehandle (perhaps you used &lt;code&gt;POSIX::open&lt;/code&gt; ), you can use the &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; function from the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module:</source>
          <target state="translated">어떤 이유로 파일 핸들 대신 파일 디스크립터가있는 경우 ( &lt;code&gt;POSIX::open&lt;/code&gt; 을 사용한 경우) &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; 모듈 에서 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; 함수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e7db8cc8d76b7ab2eda9890eb0170658ba11e9d0" translate="yes" xml:space="preserve">
          <source>If, surprisingly, the implementor of a Pod formatter can't find a satisfactory pre-existing table mapping from Unicode characters to escapes in the target format (e.g., a decent table of Unicode characters to *roff escapes), it will be necessary to build such a table. If you are in this circumstance, you should begin with the characters in the range 0x00A0 - 0x00FF, which is mostly the heavily used accented characters. Then proceed (as patience permits and fastidiousness compels) through the characters that the (X)HTML standards groups judged important enough to merit mnemonics for. These are declared in the (X)HTML specifications at the www.W3.org site. At time of writing (September 2001), the most recent entity declaration files are:</source>
          <target state="translated">놀랍게도, 포드 포맷터의 구현자가 유니 코드 문자들로부터 목표 포맷으로 이스케이프하기위한 만족스러운 기존 테이블 매핑을 찾을 수 없다면 (예를 들어, 유니 코드 문자들의 적절한 테이블이 * roff 이스케이프), 그런 테이블을 만드십시오. 이 상황에있는 경우 0x00A0-0x00FF 범위의 문자로 시작해야합니다.이 문자는 주로 많이 사용되는 악센트 문자입니다. 그런 다음 (X) HTML 표준 그룹이 니모닉을 수행하기에 충분히 중요하다고 판단한 캐릭터를 통해 인내가 허락하고 까다 로움을 강요하는 것처럼 진행하십시오. 이 내용은 www.W3.org 사이트의 (X) HTML 사양에 명시되어 있습니다. 작성 당시 (2001 년 9 월) 가장 최근의 엔티티 선언 파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3906f56da4298c4e536de3ebef7105b8dabd75e9" translate="yes" xml:space="preserve">
          <source>Ignore &lt;code&gt;dSP&lt;/code&gt; and &lt;code&gt;PUSHMARK(SP)&lt;/code&gt; for now. They will be discussed in the next example.</source>
          <target state="translated">지금은 &lt;code&gt;dSP&lt;/code&gt; 와 &lt;code&gt;PUSHMARK(SP)&lt;/code&gt; 를 무시하십시오 . 다음 예에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="51be86b7131a2f6dd784631a551ad5a124bca532" translate="yes" xml:space="preserve">
          <source>Ignore ASCII vs. EBCDIC sort differences.</source>
          <target state="translated">ASCII 대 EBCDIC 정렬 차이를 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="be1854061543f14642d8f6508b59d601baedc0d4" translate="yes" xml:space="preserve">
          <source>Ignore case.</source>
          <target state="translated">대소 문자를 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="2e352eadd6b1808d1d1be87c9129c2b0edb3ffba" translate="yes" xml:space="preserve">
          <source>Ignore the message about missing &lt;code&gt;ln&lt;/code&gt; , and about &lt;code&gt;-c&lt;/code&gt; option to tr</source>
          <target state="translated">&lt;code&gt;ln&lt;/code&gt; 누락에 대한 메시지 와 tr에 대한 &lt;code&gt;-c&lt;/code&gt; 옵션에 대한 메시지를 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="28a9d1669608fdb03cba836ec390fdcfb1aebfee" translate="yes" xml:space="preserve">
          <source>Ignore the warning.</source>
          <target state="translated">경고를 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="2789be88625c10d2c36088f497ee1c896ef071b5" translate="yes" xml:space="preserve">
          <source>Ignore them: in IRIX 5.3 there is no way to quieten ld about this.</source>
          <target state="translated">무시하십시오 : IRIX 5.3에서는 이것에 대해 ld를 조용히 할 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="2b4603ab54eaf129f7b585f0908e9724e9831b25" translate="yes" xml:space="preserve">
          <source>Ignores any arguments and returns a new &lt;code&gt;TAP::Parser::Scheduler::Spinner&lt;/code&gt; object.</source>
          <target state="translated">인수를 무시하고 새로운 &lt;code&gt;TAP::Parser::Scheduler::Spinner&lt;/code&gt; 객체를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="870e1aa14cd979f7f1df9488b978998300179625" translate="yes" xml:space="preserve">
          <source>Ignoring A Thread</source>
          <target state="translated">스레드 무시</target>
        </trans-unit>
        <trans-unit id="817c7ffeee7200e3277cebf23a0b3dcda06d9829" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich &amp;lt;</source>
          <target state="translated">일리아 자 카레 비치 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="91b2e058cf65f0cabffee0e92051934b87d3bc3b" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich (ilya@math.ohio-state.edu)</source>
          <target state="translated">Ilya Zakharevich (ilya@math.ohio-state.edu)</target>
        </trans-unit>
        <trans-unit id="031c817d16973027b8790762eb4b0c35cafca1e9" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich &lt;a href=&quot;mailto:ilyaz@cpan.org&quot;&gt;mailto:ilyaz@cpan.org&lt;/a&gt;.</source>
          <target state="translated">Ilya Zakharevich &lt;a href=&quot;mailto:ilyaz@cpan.org&quot;&gt;mailto : ilyaz@cpan.org&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="afff5ba88102f80e4aa07d73498f8952aca29188" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich &lt;a href=&quot;mailto:perl-module-hash-memoize@ilyaz.org&quot;&gt;mailto:perl-module-hash-memoize@ilyaz.org&lt;/a&gt;.</source>
          <target state="translated">Ilya Zakharevich &lt;a href=&quot;mailto:perl-module-hash-memoize@ilyaz.org&quot;&gt;mailto : perl-module-hash-memoize@ilyaz.org&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4248a84d563fa7da7c5bae89f2669c77f908cab3" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich &lt;code&gt;ilya@math.ohio-state.edu&lt;/code&gt;</source>
          <target state="translated">일리아 자 카레 비치 &lt;code&gt;ilya@math.ohio-state.edu&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="33d5a3e7b454b4e36eb89767df3980ae73e9890b" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich ilya@math.ohio-state.edu</source>
          <target state="translated">일리아 자 카레 비치 ilya@math.ohio-state.edu</target>
        </trans-unit>
        <trans-unit id="0182df78996d3eb0a76431c398a0f49f0059b1f4" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich originally extracted &lt;code&gt;XSLoader&lt;/code&gt; from &lt;code&gt;DynaLoader&lt;/code&gt; .</source>
          <target state="translated">Ilya Zakharevich는 원래 &lt;code&gt;XSLoader&lt;/code&gt; 에서 &lt;code&gt;DynaLoader&lt;/code&gt; 추출 했습니다. .</target>
        </trans-unit>
        <trans-unit id="7b5ae6dbba6c0391c239461a326224f80e808d8a" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich, cpan@ilyaz.org</source>
          <target state="translated">일리아 자 카레 비치, cpan@ilyaz.org</target>
        </trans-unit>
        <trans-unit id="f84c916319b1f129948f110816b58ce5079819de" translate="yes" xml:space="preserve">
          <source>Images, Pixmap and Bitmap Manipulation, Drawing, and Graphing</source>
          <target state="translated">이미지, Pixmap 및 비트 맵 조작, 그리기 및 그래프</target>
        </trans-unit>
        <trans-unit id="6a42b9040934c9280685a56f5dc127e9e6ee5b8d" translate="yes" xml:space="preserve">
          <source>Imagine that the here-doc end marker is at the beginning of the line. Now you can use &lt;code&gt;\p{InKana}&lt;/code&gt; and &lt;code&gt;\P{InKana}&lt;/code&gt; .</source>
          <target state="translated">here-doc 끝 마커가 줄의 시작 부분에 있다고 상상해보십시오. 이제 &lt;code&gt;\p{InKana}&lt;/code&gt; 및 &lt;code&gt;\P{InKana}&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6fae6fb5571f38013c7696bd62a49c387d5a5d68" translate="yes" xml:space="preserve">
          <source>Immediate Filters</source>
          <target state="translated">즉각적인 필터</target>
        </trans-unit>
        <trans-unit id="8a696df97fa48af3310dcba0d55250b2371b7422" translate="yes" xml:space="preserve">
          <source>Immediate filters are useful for one-off situations. For more generic problems it can be useful to package the filter up in its own module.</source>
          <target state="translated">즉각적인 필터는 일회성 상황에 유용합니다. 보다 일반적인 문제의 경우 자체 모듈에 필터를 패키징하는 것이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42b04d9e2ede4faefd5e97013f894508883e5ac4" translate="yes" xml:space="preserve">
          <source>Immediately after the check routine is called the returned node is checked for being compile-time executable. If it is (the value is judged to be constant) it is immediately executed, and a</source>
          <target state="translated">점검 루틴이 호출 된 직후에 리턴 된 노드는 컴파일 타임 실행 가능 여부를 점검합니다. 그것이 (값이 일정하다고 판단되면) 즉시 실행되고 a</target>
        </trans-unit>
        <trans-unit id="5d2ecc7281cc6015d762f885a1871742572e70d2" translate="yes" xml:space="preserve">
          <source>Immediately after the filter has been applied to the source, Filter::Simple will pass control to Exporter, so it can do its magic too.</source>
          <target state="translated">필터가 소스에 적용된 직후, Filter :: Simple은 컨트롤을 Exporter로 전달하므로 마법도 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10353737d8f43f937641dff0028a206109a7686a" translate="yes" xml:space="preserve">
          <source>Implementation can adjust its idea of number of bytes in the buffer. Do not use this - use PerlIO_fast_gets.</source>
          <target state="translated">구현은 버퍼의 바이트 수에 대한 아이디어를 조정할 수 있습니다. 이것을 사용하지 마십시오-PerlIO_fast_gets를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2c98a52672a4f466f688e44c536060b9826553e9" translate="yes" xml:space="preserve">
          <source>Implementation can return pointer to current position in the &quot;buffer&quot; and a count of bytes available in the buffer. Do not use this - use PerlIO_fast_gets.</source>
          <target state="translated">구현시 &quot;버퍼&quot;의 현재 위치 및 버퍼에서 사용 가능한 바이트 수에 대한 포인터를 반환 할 수 있습니다. 이것을 사용하지 마십시오-PerlIO_fast_gets를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">구현 세부 사항</target>
        </trans-unit>
        <trans-unit id="867f93d010e1413848b9511b5f08d11efe452a94" translate="yes" xml:space="preserve">
          <source>Implementation of sv_copypv and sv_copypv_nomg. Calls get magic iff flags include SV_GMAGIC.</source>
          <target state="translated">sv_copypv 및 sv_copypv_nomg의 구현. SV_GMAGIC이 포함 된 매직 iff 플래그를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="93a44ec01f30940976c8468009fd696e0d07c0cd" translate="yes" xml:space="preserve">
          <source>Implementations of mktemp(), tmpnam(), and tempnam() are provided, but should be used with caution since they return only a filename that was valid when function was called, so cannot guarantee that the file will not exist by the time the caller opens the filename.</source>
          <target state="translated">mktemp (), tmpnam () 및 tempnam ()의 구현이 제공되지만, 함수가 호출 될 때 유효한 파일 이름 만 리턴하므로주의해서 사용해야합니다. 호출자가 파일 이름을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="472357ef916af9461389e46cdf6fcf7419adc52b" translate="yes" xml:space="preserve">
          <source>Implementations should detect the error as soon as it occurs in any of the other functions and save the corresponding message for later retrieval. This will avoid problems on some platforms (such as SunOS) where the error message is very temporary (e.g., dlerror()).</source>
          <target state="translated">구현은 다른 기능에서 발생하는 즉시 오류를 감지하고 나중에 검색 할 수 있도록 해당 메시지를 저장해야합니다. 이렇게하면 오류 메시지가 매우 일시적인 일부 플랫폼 (예 : dlerror ())에서 문제가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7772f795eb98ffae1df16f5f22b8f9f0482251d7" translate="yes" xml:space="preserve">
          <source>Implemented on 64 bit VMS 8.3. VMS requires the symbolic link to be in Unix syntax if it is intended to resolve to a valid path.</source>
          <target state="translated">64 비트 VMS 8.3에서 구현되었습니다. VMS를 사용하려면 올바른 경로로 확인하려는 경우 심볼릭 링크가 Unix 구문에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="5c327b5ffaa641fc9ab42ad686d92c062f812101" translate="yes" xml:space="preserve">
          <source>Implementing PerlIO Layers</source>
          <target state="translated">PerlIO 레이어 구현</target>
        </trans-unit>
        <trans-unit id="d1d235ff6e6c8fe294165e40ee8fb7af96b238c6" translate="yes" xml:space="preserve">
          <source>Implements a customized option parser used for &lt;a href=&quot;../perldoc&quot;&gt;Pod::Perldoc&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../perldoc&quot;&gt;Pod :: Perldoc에&lt;/a&gt; 사용되는 사용자 정의 옵션 파서를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="4b6d8e1ab41db2682597810f350ac0e642396e48" translate="yes" xml:space="preserve">
          <source>Implements default import method for modules</source>
          <target state="translated">모듈에 대한 기본 가져 오기 방법을 구현합니다</target>
        </trans-unit>
        <trans-unit id="600b4d0a91fb59ceef4048c760197d5c6d1f4db1" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;prove&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;prove&lt;/code&gt; 명령을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="500351adb27caa795501b65867b0b58aab9da04f" translate="yes" xml:space="preserve">
          <source>Implements the fcntl(2) function. You'll probably have to say</source>
          <target state="translated">fcntl (2) 함수를 구현합니다. 아마 말해야 할 것입니다</target>
        </trans-unit>
        <trans-unit id="345a4b053fd3ba6ba91b9b4a311d01970f38b745" translate="yes" xml:space="preserve">
          <source>Implements the ioctl(2) function. You'll probably first have to say</source>
          <target state="translated">ioctl (2) 함수를 구현합니다. 아마 먼저 말해야 할 것입니다</target>
        </trans-unit>
        <trans-unit id="a755dd53c48e0431df0fb3c83a53268941625f80" translate="yes" xml:space="preserve">
          <source>Implicit context</source>
          <target state="translated">암시 적 컨텍스트</target>
        </trans-unit>
        <trans-unit id="690e1538d5a86cb3fc7e71c1d7249c0d6e3e0181" translate="yes" xml:space="preserve">
          <source>Import all symbolic constants. Same as doing this</source>
          <target state="translated">모든 기호 상수를 가져옵니다. 이 작업과 동일</target>
        </trans-unit>
        <trans-unit id="f641b0147eed755158e9f661a30e441db68a2b9a" translate="yes" xml:space="preserve">
          <source>Important Caveats</source>
          <target state="translated">중요한주의 사항</target>
        </trans-unit>
        <trans-unit id="49b3bb070775e7c46535f7d9ea2b7446b904f0e4" translate="yes" xml:space="preserve">
          <source>Important platform-specific changes</source>
          <target state="translated">중요한 플랫폼 별 변경</target>
        </trans-unit>
        <trans-unit id="90ab5ed3bb3e27748d586ad9b9b11e2ab9efaaf8" translate="yes" xml:space="preserve">
          <source>Importing</source>
          <target state="translated">Importing</target>
        </trans-unit>
        <trans-unit id="a56aac727c58f5874136fceda15607b87290a37d" translate="yes" xml:space="preserve">
          <source>Importing a particular constant may not be very portable, because the import will fail on platforms that do not have that constant. A more portable way to set &lt;code&gt;$!&lt;/code&gt; to a valid value is to use:</source>
          <target state="translated">상수가없는 플랫폼에서는 가져 오기가 실패하기 때문에 특정 상수를 가져 오는 것은 이식성이 떨어질 수 있습니다. &lt;code&gt;$!&lt;/code&gt; 를 설정하는 더 편리한 방법 ! 유효한 값은 다음을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d4eab83913c9890e5e3e1ea6b76a702ac39df78f" translate="yes" xml:space="preserve">
          <source>Importing this module causes the subroutine color in Test::Builder::Tester to be called with a true value causing colour highlighting to be turned on in debug output.</source>
          <target state="translated">이 모듈을 가져 오면 Test :: Builder :: Tester의 서브 루틴 색상이 true 값으로 호출되어 디버그 출력에서 ​​색상 강조 표시가 켜집니다.</target>
        </trans-unit>
        <trans-unit id="b94be8f7a2bde6a23ee55b54ee8fc9eb76bd786e" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;anyinflate&lt;/code&gt; and &lt;code&gt;$AnyInflateError&lt;/code&gt; . Same as doing this</source>
          <target state="translated">&lt;code&gt;anyinflate&lt;/code&gt; 및 &lt;code&gt;$AnyInflateError&lt;/code&gt; 가져 옵니다 . 이 작업과 동일</target>
        </trans-unit>
        <trans-unit id="a47d4827ba5d67c837818053a8d62f3b22e590b8" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;anyuncompress&lt;/code&gt; and &lt;code&gt;$AnyUncompressError&lt;/code&gt; . Same as doing this</source>
          <target state="translated">&lt;code&gt;anyuncompress&lt;/code&gt; 및 &lt;code&gt;$AnyUncompressError&lt;/code&gt; 가져 옵니다 . 이 작업과 동일</target>
        </trans-unit>
        <trans-unit id="95b77142aa14b6211216f5a16e3e213d0c392505" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;bunzip2&lt;/code&gt; and &lt;code&gt;$Bunzip2Error&lt;/code&gt; . Same as doing this</source>
          <target state="translated">&lt;code&gt;bunzip2&lt;/code&gt; 및 &lt;code&gt;$Bunzip2Error&lt;/code&gt; 가져 옵니다 . 이 작업과 동일</target>
        </trans-unit>
        <trans-unit id="611c05e07552b8091c699fb7c8b34e627de5035f" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;bzip2&lt;/code&gt; and &lt;code&gt;$Bzip2Error&lt;/code&gt; . Same as doing this</source>
          <target state="translated">&lt;code&gt;bzip2&lt;/code&gt; 및 &lt;code&gt;$Bzip2Error&lt;/code&gt; 가져 옵니다. . 이 작업과 동일</target>
        </trans-unit>
        <trans-unit id="0f1d5114934adc139dbbd5be66e7aa4d256c7031" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;deflate&lt;/code&gt; , &lt;code&gt;$DeflateError&lt;/code&gt; and all symbolic constants that can be used by &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; . Same as doing this</source>
          <target state="translated">&lt;code&gt;deflate&lt;/code&gt; , &lt;code&gt;$DeflateError&lt;/code&gt; 및 &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; 사용할 수있는 모든 기호 상수를 가져 옵니다 . 이 작업과 동일</target>
        </trans-unit>
        <trans-unit id="c0b3cbf51bdd7f4f367077b86b68d9bc7e23e42e" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;gunzip&lt;/code&gt; and &lt;code&gt;$GunzipError&lt;/code&gt; . Same as doing this</source>
          <target state="translated">&lt;code&gt;gunzip&lt;/code&gt; 및 &lt;code&gt;$GunzipError&lt;/code&gt; 가져 옵니다 . 이 작업과 동일</target>
        </trans-unit>
        <trans-unit id="d34135d0717f9ce2e7a0257450b1f62fae7932dc" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;gzip&lt;/code&gt; , &lt;code&gt;$GzipError&lt;/code&gt; and all symbolic constants that can be used by &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; . Same as doing this</source>
          <target state="translated">&lt;code&gt;IO::Compress::Gzip&lt;/code&gt; 사용할 수있는 &lt;code&gt;gzip&lt;/code&gt; , &lt;code&gt;$GzipError&lt;/code&gt; 및 모든 기호 상수를 가져 옵니다 . 이 작업과 동일</target>
        </trans-unit>
        <trans-unit id="115a4b04735017c59cebd861430122e98ed196f8" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;inflate&lt;/code&gt; and &lt;code&gt;$InflateError&lt;/code&gt; . Same as doing this</source>
          <target state="translated">&lt;code&gt;inflate&lt;/code&gt; 및 &lt;code&gt;$InflateError&lt;/code&gt; 가져 옵니다 . 이 작업과 동일</target>
        </trans-unit>
        <trans-unit id="1ee8ff5937f6a57c492292c874195f1b43a7fe78" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;rawdeflate&lt;/code&gt; , &lt;code&gt;$RawDeflateError&lt;/code&gt; and all symbolic constants that can be used by &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; . Same as doing this</source>
          <target state="translated">수입 &lt;code&gt;rawdeflate&lt;/code&gt; , &lt;code&gt;$RawDeflateError&lt;/code&gt; 에서 사용할 수있는 모든 기호 상수 &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; . 이 작업과 동일</target>
        </trans-unit>
        <trans-unit id="e767570633f5f871775c917a3828a5e9681f4ffd" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;rawinflate&lt;/code&gt; and &lt;code&gt;$RawInflateError&lt;/code&gt; . Same as doing this</source>
          <target state="translated">수입 &lt;code&gt;rawinflate&lt;/code&gt; 및 &lt;code&gt;$RawInflateError&lt;/code&gt; 옵니다 . 이 작업과 동일</target>
        </trans-unit>
        <trans-unit id="fce5310acfbe49b368b9871554a40ed6e277e8c4" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;unzip&lt;/code&gt; and &lt;code&gt;$UnzipError&lt;/code&gt; . Same as doing this</source>
          <target state="translated">수입 &lt;code&gt;unzip&lt;/code&gt; 및 &lt;code&gt;$UnzipError&lt;/code&gt; . 이 작업과 동일</target>
        </trans-unit>
        <trans-unit id="1c2f9178eea45bfd7d471760d92c394f1bace450" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;zip&lt;/code&gt; , &lt;code&gt;$ZipError&lt;/code&gt; and all symbolic constants that can be used by &lt;code&gt;IO::Compress::Zip&lt;/code&gt; . Same as doing this</source>
          <target state="translated">수입 &lt;code&gt;zip&lt;/code&gt; , &lt;code&gt;$ZipError&lt;/code&gt; 및 &lt;code&gt;IO::Compress::Zip&lt;/code&gt; 사용할 수있는 모든 기호 상수를 옵니다 . 이 작업과 동일</target>
        </trans-unit>
        <trans-unit id="2699b28db29be60d4c03ef4c15f7b6c27c20980d" translate="yes" xml:space="preserve">
          <source>Imports all the functions.</source>
          <target state="translated">모든 기능을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="4e34e9af4ba46ea0c9c8bc6002dd0b4972427661" translate="yes" xml:space="preserve">
          <source>Imports some semantics into the current package from the named module, generally by aliasing certain subroutine or variable names into your package. It is exactly equivalent to</source>
          <target state="translated">일반적으로 특정 서브 루틴 또는 변수 이름의 별명을 패키지에 지정하여 명명 된 모듈에서 일부 의미를 현재 패키지로 가져옵니다. 정확히</target>
        </trans-unit>
        <trans-unit id="3c2be47729bab4d065b481df08ff204f1f40d914" translate="yes" xml:space="preserve">
          <source>Imports the selected functions.</source>
          <target state="translated">선택한 기능을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="aef36502d67b0520654deb764dd055a7e905cfdd" translate="yes" xml:space="preserve">
          <source>In</source>
          <target state="translated">In</target>
        </trans-unit>
        <trans-unit id="e283b44852c55b8cc7c5d3c10f2fb1158a34c408" translate="yes" xml:space="preserve">
          <source>In 5.000 to 5.003 perls, trigonometry was done in the &lt;a href=&quot;math/complex&quot;&gt;Math::Complex&lt;/a&gt; module. With 5.004, the &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt; module (part of the standard Perl distribution) implements the trigonometric functions. Internally it uses the &lt;a href=&quot;math/complex&quot;&gt;Math::Complex&lt;/a&gt; module and some functions can break out from the real axis into the complex plane, for example the inverse sine of 2.</source>
          <target state="translated">5.000 ~ 5.003 perls에서 &lt;a href=&quot;math/complex&quot;&gt;Math :: Complex&lt;/a&gt; 모듈 에서 삼각법이 수행되었습니다 . 5.004에서는 &lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt; 모듈 (표준 Perl 분포의 일부)이 삼각 함수를 구현합니다. 내부적으로 &lt;a href=&quot;math/complex&quot;&gt;Math :: Complex&lt;/a&gt; 모듈을 사용하며 일부 함수는 실제 축에서 복잡한 평면으로 나눌 수 있습니다 (예 : 역 사인 2).</target>
        </trans-unit>
        <trans-unit id="608cccc0c9bbe325204a599a0810ba75fef50b66" translate="yes" xml:space="preserve">
          <source>In 5.9.3, Newx() and friends replace the older New() API, and drops the first parameter,</source>
          <target state="translated">5.9.3에서 Newx () 및 friends는 이전 New () API를 대체하고 첫 번째 매개 변수를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="05edeadfa5f882c58e75733f9ca5c3ffa7b75300" translate="yes" xml:space="preserve">
          <source>In 5.9.3, newSV() replaces the older NEWSV() API, and drops the first parameter,</source>
          <target state="translated">5.9.3에서 newSV ()는 이전 NEWSV () API를 대체하고 첫 번째 매개 변수를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="a0bd3ec2d46f47a7c53bb5eb7fb75ed665e3e0d8" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;#EXAMPLE-4&quot;&gt;EXAMPLE 4&lt;/a&gt; the second part of .xs file contained the following description of an XSUB:</source>
          <target state="translated">에서는 &lt;a href=&quot;#EXAMPLE-4&quot;&gt;예 4&lt;/a&gt; .xs 파일의 두 번째 부분은 XSUB의 설명을 포함 :</target>
        </trans-unit>
        <trans-unit id="f10507678ddeb0946365b72294700c17d41e824f" translate="yes" xml:space="preserve">
          <source>In &lt;b&gt;Use Rule 1&lt;/b&gt;, you can omit the curly brackets whenever the thing inside them is an atomic scalar variable like &lt;code&gt;$aref&lt;/code&gt; . For example, &lt;code&gt;@$aref&lt;/code&gt; is the same as &lt;code&gt;@{$aref}&lt;/code&gt; , and &lt;code&gt;$$aref[1]&lt;/code&gt; is the same as &lt;code&gt;${$aref}[1]&lt;/code&gt; . If you're just starting out, you may want to adopt the habit of always including the curly brackets.</source>
          <target state="translated">에서 &lt;b&gt;사용 규칙 1&lt;/b&gt; 그들 내부의 일이 같은 원자 스칼라 변수 때마다, 당신은 중괄호를 생략 할 수 있습니다 &lt;code&gt;$aref&lt;/code&gt; . 예를 들어, &lt;code&gt;@$aref&lt;/code&gt; 는 &lt;code&gt;@{$aref}&lt;/code&gt; 와 동일 하고 &lt;code&gt;$$aref[1]&lt;/code&gt; 은 &lt;code&gt;${$aref}[1]&lt;/code&gt; 합니다. 방금 시작하는 경우 항상 중괄호를 포함하는 습관을 원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="557547e0e5d90bb8da914cf09cde8cf85870da5a" translate="yes" xml:space="preserve">
          <source>In &lt;b&gt;shell&lt;/b&gt; programming, the syntactic combination of a program name and its arguments. More loosely, anything you type to a shell (a command interpreter) that starts it doing something. Even more loosely, a Perl &lt;b&gt;statement&lt;/b&gt;, which might start with a &lt;b&gt;label&lt;/b&gt; and typically ends with a semicolon.</source>
          <target state="translated">에서 &lt;b&gt;쉘&lt;/b&gt; 프로그래밍, 프로그램 이름과 인수의 구문 조합. 더 느슨하게, 당신이 무언가를 시작하는 쉘 (명령 해석기)에 입력하는 모든 것. 더 느슨하게도 Perl &lt;b&gt;문&lt;/b&gt; 은 &lt;b&gt;레이블로&lt;/b&gt; 시작 하고 일반적으로 세미콜론으로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="893925583fca341ee58483bd99d5162198b9d0c6" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;(?...)&lt;/code&gt; both absolute and relative backreferences may be used. The entire pattern can be reinserted with &lt;code&gt;(?R)&lt;/code&gt; or &lt;code&gt;(?0)&lt;/code&gt;. If you prefer to name your groups, you can use &lt;code&gt;(?&amp;amp;name)&lt;/code&gt; to recurse into that group.</source>
          <target state="translated">에서는 &lt;code&gt;(?...)&lt;/code&gt; 모두 절대 및 상대 역 참조가 사용될 수있다. &lt;code&gt;(?R)&lt;/code&gt; 또는 &lt;code&gt;(?0)&lt;/code&gt; 하여 전체 패턴을 다시 삽입 할 수 있습니다 . 그룹 이름을 지정하려면 &lt;code&gt;(?&amp;amp;name)&lt;/code&gt; 을 사용하여 해당 그룹으로 재귀를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="38fa69a28fd92dcbb1d20c664855898c29a90ccb" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;&lt;/code&gt; or its inline equivalent &lt;code&gt;\Q&lt;/code&gt; .</source>
          <target state="translated">에서는 &lt;code&gt;&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;&lt;/code&gt; 또는 인라인 등가 &lt;code&gt;\Q&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d1fe5fe4877107e3688ff937058cd386854f2587" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Compress::Zlib&lt;/code&gt; version 1.x, &lt;code&gt;gzopen&lt;/code&gt; used the zlib library to open the underlying file. This made things especially tricky when a Perl filehandle was passed to &lt;code&gt;gzopen&lt;/code&gt; . Behind the scenes the numeric C file descriptor had to be extracted from the Perl filehandle and this passed to the zlib library.</source>
          <target state="translated">에서 &lt;code&gt;Compress::Zlib&lt;/code&gt; 버전 1.x, &lt;code&gt;gzopen&lt;/code&gt; 으로 기본 파일을 엽니 다 ZLIB 라이브러리를 사용했다. 이것은 Perl 파일 핸들이 &lt;code&gt;gzopen&lt;/code&gt; 으로 전달 될 때 특히 까다로 웠습니다 . 씬 뒤에서 숫자 C 파일 디스크립터는 Perl 파일 핸들에서 추출해야했으며 이는 zlib 라이브러리로 전달되었습니다.</target>
        </trans-unit>
        <trans-unit id="bccc4f78696454721af791a75896e8b3d0106582" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Compress::Zlib&lt;/code&gt; version 2.x, the &lt;code&gt;gzopen&lt;/code&gt; interface has been completely rewritten to use the &lt;a href=&quot;../io/compress/gzip&quot;&gt;IO::Compress::Gzip&lt;/a&gt; for writing gzip files and &lt;a href=&quot;../io/uncompress/gunzip&quot;&gt;IO::Uncompress::Gunzip&lt;/a&gt; for reading gzip files. None of the limitations mentioned above apply.</source>
          <target state="translated">에서 &lt;code&gt;Compress::Zlib&lt;/code&gt; 버전 2.x의 &lt;code&gt;gzopen&lt;/code&gt; 인터페이스는 완전히 사용하기 위해 다시 작성되었습니다 &lt;a href=&quot;../io/compress/gzip&quot;&gt;IO :: 압축 : Gzip으로를&lt;/a&gt; GZIP 파일과 작성하기위한 &lt;a href=&quot;../io/uncompress/gunzip&quot;&gt;IO :: 압축 풀기 :: 풀어서&lt;/a&gt; 은 gzip 파일을 읽기 위해. 위에서 언급 한 제한은 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e00aec70e3db954ff900ae2d1de9b4a90ac0844b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Encode&lt;/code&gt; 2.10 or later, &lt;code&gt;LEAVE_SRC&lt;/code&gt; is also implied.</source>
          <target state="translated">에서는 &lt;code&gt;Encode&lt;/code&gt; 2.10 이상 &lt;code&gt;LEAVE_SRC&lt;/code&gt; 는 또한 암시한다.</target>
        </trans-unit>
        <trans-unit id="51676bb8ef9795bee4bcbafed10516b2d6301ddf" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;native floating point --&amp;gt; native integer&lt;/code&gt; conversions the magnitude of the result is less than or equal to the magnitude of the source. (</source>
          <target state="translated">에서 &lt;code&gt;native floating point --&amp;gt; native integer&lt;/code&gt; 결과의 변환 크기는 소스의 크기에 동일 작거나입니다. (</target>
        </trans-unit>
        <trans-unit id="67145b5258ab605d487808bb8f38203833e35128" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;simple_replace&lt;/code&gt; we used the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; modifier to replace all occurrences of the regexp on each line. (Even though the regular expression appears in a loop, Perl is smart enough to compile it only once.) As with &lt;code&gt;simple_grep&lt;/code&gt; , both the &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; and the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s/$regexp/$replacement/g&lt;/a&gt;&lt;/code&gt; use &lt;code&gt;$_&lt;/code&gt; implicitly.</source>
          <target state="translated">에서 &lt;code&gt;simple_replace&lt;/code&gt; 우리는 사용 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; 수정 각 라인에 정규 표현식의 모든 항목을 대체합니다. (정규 표현식은 루프에 표시하더라도, 펄은 한 번만 컴파일 스마트 정도입니다.)와 마찬가지로 &lt;code&gt;simple_grep&lt;/code&gt; 는 모두 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s/$regexp/$replacement/g&lt;/a&gt;&lt;/code&gt; 사용 &lt;code&gt;$_&lt;/code&gt; 암시.</target>
        </trans-unit>
        <trans-unit id="d077e5ff0102748fbe2d5e45a0e1e202f0802167" translate="yes" xml:space="preserve">
          <source>In AIX 4.2 Perl extensions that use C++ functions that use statics may have problems in that the statics are not getting initialized. In newer AIX releases this has been solved by linking Perl with the libC_r library, but unfortunately in AIX 4.2 the said library has an obscure bug where the various functions related to time (such as time() and gettimeofday()) return broken values, and therefore in AIX 4.2 Perl is not linked against the libC_r.</source>
          <target state="translated">스태틱을 사용하는 C ++ 함수를 사용하는 AIX 4.2 Perl 확장에서는 스태틱이 초기화되지 않는 문제가있을 수 있습니다. 최신 AIX 릴리스에서는 Perl을 libC_r 라이브러리와 연결하여이 문제를 해결했지만 불행히도 AIX 4.2에서는 해당 라이브러리에 시간과 관련된 다양한 기능 (예 : time () 및 gettimeofday ())이 깨진 값을 반환하는 모호한 버그가 있습니다. 따라서 AIX 4.2 Perl은 libC_r에 링크되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c64677f24dcacb245231383a983d4852fe14280" translate="yes" xml:space="preserve">
          <source>In BigInt, all numbers except &lt;code&gt;NaN&lt;/code&gt; , &lt;code&gt;+inf&lt;/code&gt; and &lt;code&gt;-inf&lt;/code&gt; are integers.</source>
          <target state="translated">BigInt에서 &lt;code&gt;NaN&lt;/code&gt; , &lt;code&gt;+inf&lt;/code&gt; 및 &lt;code&gt;-inf&lt;/code&gt; 를 제외한 모든 숫자 는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="f83bdc44eedb56878bfa30e1ea8c050d2167ca73" translate="yes" xml:space="preserve">
          <source>In BigInt, unless upgrading is in effect, the result is truncated to an integer.</source>
          <target state="translated">BigInt에서 업그레이드가 적용되지 않으면 결과가 정수로 잘립니다.</target>
        </trans-unit>
        <trans-unit id="a6200922eb25a34272b79346b2b9f5be87e701ac" translate="yes" xml:space="preserve">
          <source>In CVS and RCS version 1.9 is followed by 1.10. Since CPAN compares version numbers numerically we use a sprintf() to convert 1.9 to 1.009 and 1.10 to 1.010 which compare properly.</source>
          <target state="translated">CVS 및 RCS 버전 1.9 뒤에 1.10이 있습니다. CPAN은 버전 번호를 숫자로 비교하므로 sprintf ()를 사용하여 1.9를 1.009로, 1.10을 1.010으로 적절히 비교합니다.</target>
        </trans-unit>
        <trans-unit id="e6d98db49c1b068959bb3c31358e246a1630b67a" translate="yes" xml:space="preserve">
          <source>In CVS, RCS and SVN you use $Revision$ (see the documentation of your version control system for details). Every time the file is checked in the $Revision$ will be updated, updating your $VERSION.</source>
          <target state="translated">CVS, RCS 및 SVN에서는 $ Revision $을 사용합니다 (자세한 내용은 버전 관리 시스템 설명서 참조). $ Revision $에서 파일을 확인할 때마다 $ VERSION이 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="562c80499b9073a3905b98e95f6a9c71ca119547" translate="yes" xml:space="preserve">
          <source>In Cray UNICOS there is some strange numerical instability that results in root(), cos(), sin(), cosh(), sinh(), losing accuracy fast. Beware. The bug may be in UNICOS math libs, in UNICOS C compiler, in Math::Complex. Whatever it is, it does not manifest itself anywhere else where Perl runs.</source>
          <target state="translated">Cray UNICOS에는 root (), cos (), sin (), cosh (), sinh ()가 발생하여 정확도가 빠르게 떨어지는 이상한 수치 적 불안정성이 있습니다. 조심하십시오. 버그는 UNICOS 수학 라이브러리, UNICOS C 컴파일러, Math :: Complex에있을 수 있습니다. 그것이 무엇이든간에 그것은 Perl이 실행되는 다른 곳에서는 나타나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c2148313df160c8d66540765266d0deaea355ab2" translate="yes" xml:space="preserve">
          <source>In DUCET v4.0.0, primary weight of &lt;code&gt;C&lt;/code&gt; is &lt;code&gt;0E60&lt;/code&gt; and that of &lt;code&gt;D&lt;/code&gt; is &lt;code&gt;0E6D&lt;/code&gt; . So setting primary weight of &lt;code&gt;CH&lt;/code&gt; to &lt;code&gt;0E6A&lt;/code&gt; (as a value between &lt;code&gt;0E60&lt;/code&gt; and &lt;code&gt;0E6D&lt;/code&gt; ) makes ordering as &lt;code&gt;C &amp;lt; CH &amp;lt; D&lt;/code&gt; . Exactly speaking DUCET already has some characters between &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt; : &lt;code&gt;small capital C&lt;/code&gt; (&lt;code&gt;U+1D04&lt;/code&gt;) with primary weight &lt;code&gt;0E64&lt;/code&gt; , &lt;code&gt;c-hook/C-hook&lt;/code&gt; (&lt;code&gt;U+0188/U+0187&lt;/code&gt;) with &lt;code&gt;0E65&lt;/code&gt; , and &lt;code&gt;c-curl&lt;/code&gt; (&lt;code&gt;U+0255&lt;/code&gt; ) with &lt;code&gt;0E69&lt;/code&gt; . Then primary weight &lt;code&gt;0E6A&lt;/code&gt; for &lt;code&gt;CH&lt;/code&gt; makes &lt;code&gt;CH&lt;/code&gt; ordered between &lt;code&gt;c-curl&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt; .</source>
          <target state="translated">DUCET v4.0.0에서 &lt;code&gt;C&lt;/code&gt; 의 기본 가중치 는 &lt;code&gt;0E60&lt;/code&gt; 이고 &lt;code&gt;D&lt;/code&gt; 의 &lt;code&gt;0E6D&lt;/code&gt; 는 0E6D 입니다. 따라서 &lt;code&gt;CH&lt;/code&gt; 의 기본 가중치 를 &lt;code&gt;0E6A&lt;/code&gt; 로 설정 하면 ( &lt;code&gt;0E60&lt;/code&gt; 과 &lt;code&gt;0E6D&lt;/code&gt; 사이의 값 으로) &lt;code&gt;C &amp;lt; CH &amp;lt; D&lt;/code&gt; 로 정렬됩니다 . 정확히 말하면 DUCET 이미 사이에 문자가 &lt;code&gt;C&lt;/code&gt; 및 &lt;code&gt;D&lt;/code&gt; : &lt;code&gt;small capital C&lt;/code&gt; ( &lt;code&gt;U+1D04&lt;/code&gt; 차 무게) &lt;code&gt;0E64&lt;/code&gt; 를 , &lt;code&gt;c-hook/C-hook&lt;/code&gt; ( &lt;code&gt;U+0188/U+0187&lt;/code&gt; )와 &lt;code&gt;0E65&lt;/code&gt; 및 &lt;code&gt;c-curl&lt;/code&gt; ( &lt;code&gt;U+0255&lt;/code&gt; ) 와 &lt;code&gt;0E69&lt;/code&gt; . 그런 다음 &lt;code&gt;CH&lt;/code&gt; 에 대한 1 차 가중치 &lt;code&gt;0E6A&lt;/code&gt; 는 &lt;code&gt;CH&lt;/code&gt; 를 &lt;code&gt;c-curl&lt;/code&gt; 과 &lt;code&gt;D&lt;/code&gt; 사이에 정렬 합니다.</target>
        </trans-unit>
        <trans-unit id="3cbd5bc5a38769b2182dd3a8ac3c64a575d3f230" translate="yes" xml:space="preserve">
          <source>In English grammar, a short noun phrase between a verb and its direct object indicating the beneficiary or recipient of the action. In Perl, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; STDOUT &quot;$foo\n&quot;;&lt;/code&gt; can be understood as &amp;ldquo;verb indirect-object object&amp;rdquo;, where &lt;code&gt;STDOUT&lt;/code&gt; is the recipient of the &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; action, and &lt;code&gt;&quot;$foo&quot;&lt;/code&gt; is the object being printed. Similarly, when invoking a &lt;b&gt;method&lt;/b&gt;, you might place the invocant in the dative slot between the method and its arguments:</source>
          <target state="translated">영어 문법에서 동사와 그 직접적인 대상 사이의 짧은 명사구는 행동의 수혜자 또는 수령인을 나타냅니다. Perl에서 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; STDOUT &quot;$foo\n&quot;;&lt;/code&gt; &lt;a href=&quot;functions/print&quot;&gt;인쇄하십시오&lt;/a&gt; . &lt;code&gt;STDOUT&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 조치 의 수신자 이고 &lt;code&gt;&quot;$foo&quot;&lt;/code&gt; 는 인쇄중인 오브젝트입니다. &quot;verb indirect-object object&quot;로 이해 될 수 있습니다 . 마찬가지로, &lt;b&gt;메소드&lt;/b&gt; 를 호출 할 때 메소드와 해당 인수 사이의 기본 슬롯에 호출자를 배치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="217cde63e66af3805baaae8b61bf234934e3a17f" translate="yes" xml:space="preserve">
          <source>In IRIX 5.3 and with Perl 5.8.1 (Perl 5.8.0 didn't compile in IRIX 5.3) the following failures are known.</source>
          <target state="translated">IRIX 5.3 및 Perl 5.8.1에서 (Perl 5.8.0은 IRIX 5.3에서 컴파일되지 않음) 다음과 같은 오류가 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae875351a921c55e10385097f1ce568f0cc36c5c" translate="yes" xml:space="preserve">
          <source>In MakeMaker-based installations,</source>
          <target state="translated">MakeMaker 기반 설치에서</target>
        </trans-unit>
        <trans-unit id="a8ca889adcc661187e58d592f4912a7f93ee302a" translate="yes" xml:space="preserve">
          <source>In Math::BigInt, passing a negative number precision has no effect since no numbers have digits after the dot. In &lt;a href=&quot;bigfloat&quot;&gt;Math::BigFloat&lt;/a&gt;, it will round all results to P digits after the dot.</source>
          <target state="translated">Math :: BigInt에서 점 뒤에 숫자가없는 숫자이므로 음수 정밀도를 전달해도 아무런 효과가 없습니다. 에서 &lt;a href=&quot;bigfloat&quot;&gt;수학 :: BigFloat&lt;/a&gt; ,이 점 후 P 자리에 모든 결과를 반올림합니다.</target>
        </trans-unit>
        <trans-unit id="846e78092ad74f765fcf7c9c94ce51c84e742d1b" translate="yes" xml:space="preserve">
          <source>In Memory Databases</source>
          <target state="translated">메모리 데이터베이스에서</target>
        </trans-unit>
        <trans-unit id="3f860bffab3d111dbe427091c4d724eab7972b48" translate="yes" xml:space="preserve">
          <source>In Part 1 we mentioned that Perl compiles a regexp into a compact sequence of opcodes. Thus, a compiled regexp is a data structure that can be stored once and used again and again. The regexp quote &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; does exactly that: &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/string/&lt;/a&gt;&lt;/code&gt; compiles the &lt;code&gt;string&lt;/code&gt; as a regexp and transforms the result into a form that can be assigned to a variable:</source>
          <target state="translated">Part 1에서 우리는 Perl이 정규식을 간단한 opcode 시퀀스로 컴파일한다고 언급했다. 따라서 컴파일 된 regexp는 한 번만 저장하고 다시 사용할 수있는 데이터 구조입니다. 정규 표현식 따옴표 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 는 정확히 다음을 수행합니다. &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/string/&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;string&lt;/code&gt; 을 정규 표현식으로 컴파일 하고 결과를 변수에 할당 할 수있는 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="b8e23998d4d31cf53431494db737762f35860793" translate="yes" xml:space="preserve">
          <source>In Perl 5.005, the thread model was that all data is implicitly shared, and shared access to data has to be explicitly synchronized. This model is called</source>
          <target state="translated">Perl 5.005에서 스레드 모델은 모든 데이터가 암시 적으로 공유되고 데이터에 대한 공유 액세스가 명시 적으로 동기화되어야한다는 것입니다. 이 모델을</target>
        </trans-unit>
        <trans-unit id="0ef40fb67bd5325ef3bc9871c79bffa2a2f9def8" translate="yes" xml:space="preserve">
          <source>In Perl 5.10, declare the variable with &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; declaration creates the lexical variable that persists between calls to the subroutine:</source>
          <target state="translated">Perl 5.10에서 변수를 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 로 선언하십시오 . &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 선언 어휘 변수를 생성하는 서브 루틴을 호출간에 지속되면</target>
        </trans-unit>
        <trans-unit id="fcad1e403285c6c0597be1e44d89e383fc28fe4e" translate="yes" xml:space="preserve">
          <source>In Perl 5.10, the</source>
          <target state="translated">Perl 5.10에서</target>
        </trans-unit>
        <trans-unit id="3754647e31be439690cdc120d0f37bbfc1ee49d5" translate="yes" xml:space="preserve">
          <source>In Perl 5.10, use the &lt;code&gt;given-when&lt;/code&gt; construct described in &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt;:</source>
          <target state="translated">Perl 5.10 에서 &lt;a href=&quot;perlsyn&quot;&gt;perlsyn에&lt;/a&gt; 설명 된 &lt;code&gt;given-when&lt;/code&gt; 구문을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ef6f20b95a614e3c70a519351a658bbdee2e34af" translate="yes" xml:space="preserve">
          <source>In Perl 5.10.0 the &lt;code&gt;/p&lt;/code&gt; match operator flag and the &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; , and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; variables were introduced, that allowed you to suffer the penalties only on patterns marked with &lt;code&gt;/p&lt;/code&gt;.</source>
          <target state="translated">Perl 5.10.0에는 &lt;code&gt;/p&lt;/code&gt; 일치 연산자 플래그와 &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; 및 &lt;code&gt;${^POSTMATCH}&lt;/code&gt; 변수가 도입되어 &lt;code&gt;/p&lt;/code&gt; 로 표시된 패턴에 대해서만 처벌을받을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bfdfceeeffa73fd56622a7e4fbcd615a7de619f1" translate="yes" xml:space="preserve">
          <source>In Perl 5.16 and earlier, copy-on-write (see the next section) shared a flag bit with read-only scalars. So the only way to test whether &lt;code&gt;sv_setsv&lt;/code&gt; , etc., will raise a &quot;Modification of a read-only value&quot; error in those versions is:</source>
          <target state="translated">Perl 5.16 및 이전 버전에서는 기록 중 복사 (다음 섹션 참조)가 읽기 전용 스칼라와 플래그 비트를 공유했습니다. 따라서 해당 버전에서 &lt;code&gt;sv_setsv&lt;/code&gt; 등이 &quot;읽기 전용 값 수정&quot;오류를 발생시키는 지 여부를 테스트하는 유일한 방법 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9c29d499be725da440aa9799fa65cef604b0abdb" translate="yes" xml:space="preserve">
          <source>In Perl 5.18.0 onwards, perl started noting the presence of each of the three variables separately, and only copied that part of the string required; so in</source>
          <target state="translated">Perl 5.18.0 이상에서 perl은 세 변수 각각의 존재를 개별적으로 인식하기 시작했으며 필요한 문자열 부분 만 복사했습니다. 그래서</target>
        </trans-unit>
        <trans-unit id="ac74f29244f42c123f550a223146503cf87cca65" translate="yes" xml:space="preserve">
          <source>In Perl 5.20 and earlier, the only pragmas to be completely supported are: &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; . (&lt;code&gt;$[&lt;/code&gt; , which behaves like a pragma, is also supported.)</source>
          <target state="translated">펄 5.20 및 이전 버전에서, 유일한 프라그 마를 완전히 지원하는 위치 : &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; . ( pragma처럼 동작하는 &lt;code&gt;$[&lt;/code&gt; 도 지원됩니다.)</target>
        </trans-unit>
        <trans-unit id="a99daea546c9fc521d28b295e0227c75c1c77163" translate="yes" xml:space="preserve">
          <source>In Perl 5.20 and higher this is ignored. Due to a new copy-on-write mechanism, ${^PREMATCH}, ${^MATCH}, and ${^POSTMATCH} will be available after the match regardless of the modifier.</source>
          <target state="translated">Perl 5.20 이상에서는 무시됩니다. 새로운 COW (Copy-On-Write) 메커니즘으로 인해 수정 자에 관계없이 $ {^ PREMATCH}, $ {^ MATCH} 및 $ {^ POSTMATCH}를 일치 후에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5dd87335d7944293ee760ce3fce6d463be42dedd" translate="yes" xml:space="preserve">
          <source>In Perl 5.20.0 a new copy-on-write system was enabled by default, which finally fixes all performance issues with these three variables, and makes them safe to use anywhere.</source>
          <target state="translated">Perl 5.20.0에서는 새로운 COW (Copy-On-Write) 시스템이 기본적으로 활성화되어이 세 가지 변수의 모든 성능 문제를 해결하고 어디서나 안전하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3bfdc8baf280a72c47cbbea941ae21c16b028e7" translate="yes" xml:space="preserve">
          <source>In Perl 5.20.0 this was changed so that it would be &lt;b&gt;exactly&lt;/b&gt; the same as setting &lt;code&gt;$/&lt;/code&gt; to undef, with the exception that this warning would be thrown.</source>
          <target state="translated">Perl 5.20.0에서는 이 경고가 발생되는 것을 제외하고 &lt;code&gt;$/&lt;/code&gt; 를 undef 로 설정하는 것과 &lt;b&gt;정확히&lt;/b&gt; 동일 하게 변경되었습니다 .</target>
        </trans-unit>
        <trans-unit id="b9a5cb481a025f6680fe2e560f757bef411f0354" translate="yes" xml:space="preserve">
          <source>In Perl 5.22 and later, all groups within a regexp can be set to non-capturing by using the new &lt;code&gt;/n&lt;/code&gt; flag:</source>
          <target state="translated">Perl 5.22 이상에서 새로운 &lt;code&gt;/n&lt;/code&gt; 플래그를 사용하여 정규 표현식 내의 모든 그룹을 캡처하지 않도록 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="829f62b5d0005de3966076a8745c273476071683" translate="yes" xml:space="preserve">
          <source>In Perl 5.6 and some books the &lt;code&gt;:raw&lt;/code&gt; layer (previously sometimes also referred to as a &quot;discipline&quot;) is documented as the inverse of the &lt;code&gt;:crlf&lt;/code&gt; layer. That is no longer the case - other layers which would alter the binary nature of the stream are also disabled. If you want UNIX line endings on a platform that normally does CRLF translation, but still want UTF-8 or encoding defaults, the appropriate thing to do is to add &lt;code&gt;:perlio&lt;/code&gt; to the PERLIO environment variable.</source>
          <target state="translated">Perl 5.6 및 일부 책에서 &lt;code&gt;:raw&lt;/code&gt; 레이어 (이전에는 &quot;징계&quot;라고도 함)는 &lt;code&gt;:crlf&lt;/code&gt; 레이어 의 역으로 ​​문서화됩니다 . 스트림의 이진 특성을 변경하는 다른 레이어도 비활성화됩니다. 일반적으로 CRLF 변환을 수행하지만 UTF-8 또는 인코딩 기본값을 원하는 플랫폼에서 UNIX 행 끝을 원할 경우 PERLIO 환경 변수에 &lt;code&gt;:perlio&lt;/code&gt; 를 추가 하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8fac8c7e82a994285a91ea520c95723e026d4360" translate="yes" xml:space="preserve">
          <source>In Perl 5.6, a new model was introduced in which all is was thread local and shared access to data has to be explicitly declared. This model is called</source>
          <target state="translated">Perl 5.6에서는 모든 모델이 스레드 로컬이며 데이터에 대한 공유 액세스를 명시 적으로 선언해야하는 새로운 모델이 도입되었습니다. 이 모델을</target>
        </trans-unit>
        <trans-unit id="c2abdf6c9d513612683e10abfef7f22af8c5271f" translate="yes" xml:space="preserve">
          <source>In Perl 5.6, the</source>
          <target state="translated">Perl 5.6에서</target>
        </trans-unit>
        <trans-unit id="26c0c53508feac78fbf5a2c99792e045ffa03c8a" translate="yes" xml:space="preserve">
          <source>In Perl 5.6.0 the &lt;code&gt;@-&lt;/code&gt; and &lt;code&gt;@+&lt;/code&gt; dynamic arrays were introduced that supply the indices of successful matches. So you could for example do this:</source>
          <target state="translated">Perl 5.6.0에서는 성공적인 일치의 색인을 제공 하는 &lt;code&gt;@-&lt;/code&gt; 및 &lt;code&gt;@+&lt;/code&gt; 동적 배열이 도입되었습니다. 예를 들어 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="523c10b75565b9e0e195e0700fdbbd2ed237ae32" translate="yes" xml:space="preserve">
          <source>In Perl 5.8, the</source>
          <target state="translated">Perl 5.8에서</target>
        </trans-unit>
        <trans-unit id="a58322d6122d01dd67612b6444328927a4d69bfc" translate="yes" xml:space="preserve">
          <source>In Perl 5.8.0 the slowness was often quite spectacular; in Perl 5.8.1 a caching scheme was introduced which improved the situation. In general, operations with UTF-8 encoded strings are still slower. As an example, the Unicode properties (character classes) like &lt;code&gt;\p{Nd}&lt;/code&gt; are known to be quite a bit slower (5-20 times) than their simpler counterparts like &lt;code&gt;[0-9]&lt;/code&gt; (then again, there are hundreds of Unicode characters matching &lt;code&gt;Nd&lt;/code&gt; compared with the 10 ASCII characters matching &lt;code&gt;[0-9]&lt;/code&gt; ).</source>
          <target state="translated">Perl 5.8.0에서는 속도가 느려질 때가 종종있었습니다. Perl 5.8.1에서는 상황을 개선 한 캐싱 체계가 도입되었습니다. 일반적으로 UTF-8로 인코딩 된 문자열을 사용한 작업은 여전히 ​​느립니다. 예를 들어, &lt;code&gt;\p{Nd}&lt;/code&gt; 와 같은 유니 코드 속성 (캐릭터 클래스) 은 &lt;code&gt;[0-9]&lt;/code&gt; 와 같은 단순한 것보다 약간 느리게 (5-20 배) 알려져 있습니다 (다시 말해서, 수백 개의 유니 코드가 있습니다) &lt;code&gt;Nd&lt;/code&gt; 와 일치하는 문자는 &lt;code&gt;[0-9]&lt;/code&gt; 와 일치 하는 10 개의 ASCII 문자와 비교됩니다 .</target>
        </trans-unit>
        <trans-unit id="0c85305fdff4b0749bfcf24c2c7a107269854de9" translate="yes" xml:space="preserve">
          <source>In Perl 6, &lt;code&gt;when()&lt;/code&gt; will always do an implicit smartmatch with its argument, while in Perl 5 it is convenient (albeit potentially confusing) to suppress this implicit smartmatch in various rather loosely-defined situations, as roughly outlined above. (The difference is largely because Perl 5 does not have, even internally, a boolean type.)</source>
          <target state="translated">Perl 6에서 &lt;code&gt;when()&lt;/code&gt; 는 항상 인수와 함께 암시 적 스마트 매치를 수행하지만 Perl 5에서는 위에서 간략하게 설명 된 것처럼 느슨하게 정의 된 다양한 상황에서이 암시 적 스마트 매치를 억제하는 것이 편리합니다 (잠재적으로 혼동 될 수 있음). (Perl 5에는 내부적으로 부울 유형이 없기 때문에 차이점이 있습니다.)</target>
        </trans-unit>
        <trans-unit id="ca97d510355543881848d3f320ae7ab2b8841db0" translate="yes" xml:space="preserve">
          <source>In Perl most objects are hashes, but the OO systems we recommend keep you from having to worry about this. In practice, it's best to consider an object's internal data structure opaque.</source>
          <target state="translated">Perl에서 대부분의 객체는 해시이지만 OO 시스템은 이에 대해 걱정할 필요가 없습니다. 실제로는 객체의 내부 데이터 구조를 불투명하게 고려하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="243bad753f535e22807612697dcecab4311e323e" translate="yes" xml:space="preserve">
          <source>In Perl regular expressions, most regexp elements 'eat up' a certain amount of string when they match. For instance, the regexp element &lt;code&gt;[abc}]&lt;/code&gt; eats up one character of the string when it matches, in the sense that Perl moves to the next character position in the string after the match. There are some elements, however, that don't eat up characters (advance the character position) if they match. The examples we have seen so far are the anchors. The anchor &lt;code&gt;^&lt;/code&gt; matches the beginning of the line, but doesn't eat any characters. Similarly, the word boundary anchor &lt;code&gt;\b&lt;/code&gt; matches wherever a character matching &lt;code&gt;\w&lt;/code&gt; is next to a character that doesn't, but it doesn't eat up any characters itself. Anchors are examples of</source>
          <target state="translated">Perl 정규식에서 대부분의 정규 표현식 요소는 일치 할 때 특정 양의 문자열을 '먹습니다'. 예를 들어, 정규 표현식 요소 &lt;code&gt;[abc}]&lt;/code&gt; 는 Perl이 일치 후 문자열에서 다음 문자 위치로 이동한다는 의미에서 일치 할 때 문자열의 한 문자를 사용합니다. 그러나 일치하는 경우 캐릭터를 먹지 않는 (캐릭터 위치를 전진시키는) 일부 요소가 있습니다. 지금까지 본 예는 앵커입니다. 앵커 &lt;code&gt;^&lt;/code&gt; 는 줄의 시작과 일치하지만 문자를 먹지 않습니다. 마찬가지로, 단어 경계 앵커 &lt;code&gt;\b&lt;/code&gt; 문자 일치하는 곳 일치 &lt;code&gt;\w&lt;/code&gt; 하지 않는 문자 옆에하지만 모든 문자 자체를 먹지 않습니다. 앵커는 예입니다</target>
        </trans-unit>
        <trans-unit id="905e1c7e56de580fc4af4b17e4c486804586d33e" translate="yes" xml:space="preserve">
          <source>In Perl terms this means that supplying the usual Perl numbers (also known as scalars, please see &lt;a href=&quot;../perldata&quot;&gt;perldata&lt;/a&gt;) as input for the trigonometric functions might produce as output results that no more are simple real numbers: instead they are complex numbers.</source>
          <target state="translated">펄 측면에서 일반적인 펄 번호를 공급하는 것은 것을이 수단 (또한 스칼라로 알려진, 볼하시기 바랍니다 &lt;a href=&quot;../perldata&quot;&gt;perldata을&lt;/a&gt; 대신 그들은 복잡한 숫자는 다음과 같습니다 : 더 더 단순 실수임을 출력 결과로 생성 할 수있는 삼각 함수에 대한 입력으로).</target>
        </trans-unit>
        <trans-unit id="7f326f4fd32f12380a2d175a436e985d3f4c2edf" translate="yes" xml:space="preserve">
          <source>In Perl v5.14, all non-ASCII characters are quoted in non-UTF-8-encoded strings, but not quoted in UTF-8 strings.</source>
          <target state="translated">Perl v5.14에서 모든 비 ASCII 문자는 UTF-8로 인코딩되지 않은 문자열로 인용되지만 UTF-8 문자열에서는 인용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ffdb19ef413239753228d33908dad38e29d542e" translate="yes" xml:space="preserve">
          <source>In Perl v5.18 and earlier, it is only guaranteed to return a defined value when the pattern was compiled or executed with the &lt;code&gt;/p&lt;/code&gt; modifier. In Perl v5.20, the &lt;code&gt;/p&lt;/code&gt; modifier does nothing, so &lt;code&gt;${^MATCH}&lt;/code&gt; does the same thing as &lt;code&gt;$MATCH&lt;/code&gt; .</source>
          <target state="translated">Perl v5.18 및 이전 버전에서는 &lt;code&gt;/p&lt;/code&gt; 수정자를 사용하여 패턴을 컴파일하거나 실행할 때 정의 된 값만 리턴합니다 . Perl v5.20에서 &lt;code&gt;/p&lt;/code&gt; 수정자는 아무 것도 수행하지 않으므로 &lt;code&gt;${^MATCH}&lt;/code&gt; 는 &lt;code&gt;$MATCH&lt;/code&gt; 와 동일한 기능을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="b4dbbc56c5f11021be8e37601f6986f49dc8e148" translate="yes" xml:space="preserve">
          <source>In Perl v5.18 and earlier, it is only guaranteed to return a defined value when the pattern was compiled or executed with the &lt;code&gt;/p&lt;/code&gt; modifier. In Perl v5.20, the &lt;code&gt;/p&lt;/code&gt; modifier does nothing, so &lt;code&gt;${^POSTMATCH}&lt;/code&gt; does the same thing as &lt;code&gt;$POSTMATCH&lt;/code&gt; .</source>
          <target state="translated">Perl v5.18 및 이전 버전에서는 &lt;code&gt;/p&lt;/code&gt; 수정자를 사용하여 패턴을 컴파일하거나 실행할 때 정의 된 값만 리턴합니다 . Perl v5.20에서 &lt;code&gt;/p&lt;/code&gt; 수정자는 아무 것도 수행하지 않으므로 &lt;code&gt;${^POSTMATCH}&lt;/code&gt; 는 &lt;code&gt;$POSTMATCH&lt;/code&gt; 와 동일한 기능을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="05c22186f7acbb5a1c00ca1269cc907a18af05f8" translate="yes" xml:space="preserve">
          <source>In Perl v5.18 and earlier, it is only guaranteed to return a defined value when the pattern was compiled or executed with the &lt;code&gt;/p&lt;/code&gt; modifier. In Perl v5.20, the &lt;code&gt;/p&lt;/code&gt; modifier does nothing, so &lt;code&gt;${^PREMATCH}&lt;/code&gt; does the same thing as &lt;code&gt;$PREMATCH&lt;/code&gt; .</source>
          <target state="translated">Perl v5.18 및 이전 버전에서는 &lt;code&gt;/p&lt;/code&gt; 수정자를 사용하여 패턴을 컴파일하거나 실행할 때 정의 된 값만 리턴합니다 . Perl v5.20에서 &lt;code&gt;/p&lt;/code&gt; 수정자는 아무 것도 수행하지 않으므로 &lt;code&gt;${^PREMATCH}&lt;/code&gt; 는 &lt;code&gt;$PREMATCH&lt;/code&gt; 와 동일한 기능을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="5432c77569fd0514eaa8844532d6c5cc637bdaa6" translate="yes" xml:space="preserve">
          <source>In Perl versions 5.6 and earlier the quicksort algorithm was used to implement &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt;, but in Perl 5.8 a mergesort algorithm was also made available, mainly to guarantee worst case O(N log N) behaviour: the worst case of quicksort is O(N**2). In Perl 5.8 and later, quicksort defends against quadratic behaviour by shuffling large arrays before sorting.</source>
          <target state="translated">Perl 5.6 이전 버전에서는 quicksort 알고리즘을 사용하여 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; 를 구현 했지만 Perl 5.8에서는 주로 최악의 경우 O (N log N) 동작을 보장하기 위해 mergesort 알고리즘도 사용할 수있었습니다. N ** 2). Perl 5.8 이상에서 quicksort는 정렬하기 전에 큰 배열을 섞어서 2 차 동작을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="8b481016607f0afb6a75f448e44a95f87a802232" translate="yes" xml:space="preserve">
          <source>In Perl you will get a floating point value if you do one of the following:</source>
          <target state="translated">Perl에서는 다음 중 하나를 수행하면 부동 소수점 값이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7d663b5a48798d90608073d23eaf6d6597db1534" translate="yes" xml:space="preserve">
          <source>In Perl, &lt;code&gt;else if&lt;/code&gt; is spelled &lt;code&gt;elsif&lt;/code&gt; .</source>
          <target state="translated">Perl에서는 &lt;code&gt;else if&lt;/code&gt; &lt;code&gt;elsif&lt;/code&gt; 철자가 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="49774beef30ebf83ad6beb68cfd55f59cc0e76e3" translate="yes" xml:space="preserve">
          <source>In Perl, a class is just a package, and methods are just subroutines. Perl doesn't get more formal than that and lets you set up the package just the way that you like it (that is, it doesn't set up anything for you).</source>
          <target state="translated">Perl에서 클래스는 패키지 일 뿐이며 메소드는 서브 루틴 일뿐입니다. Perl은 그보다 더 공식적이지 않으며 원하는 방식으로 패키지를 설정할 수 있습니다 (즉, 아무것도 설정하지 않습니다).</target>
        </trans-unit>
        <trans-unit id="983e915935b5fb68c2f1bb82bb4cf04272a6754a" translate="yes" xml:space="preserve">
          <source>In Perl, a sequence of statements that defines a scope is called a block. Sometimes a block is delimited by the file containing it (in the case of a required file, or the program as a whole), and sometimes a block is delimited by the extent of a string (in the case of an eval).</source>
          <target state="translated">Perl에서 범위를 정의하는 일련의 명령문을 블록이라고합니다. 블록은 블록을 포함하는 파일 (필수 파일 또는 전체 프로그램의 경우)로 구분되며 때로는 블록의 범위 (eval의 경우)로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="476c5432e1fcd1b2c55042740329df48b50efcfd" translate="yes" xml:space="preserve">
          <source>In Perl, an object is a blessed reference. The standard way of associating data with an object is to store the data inside the object's body, that is, the piece of data pointed to by the reference.</source>
          <target state="translated">Perl에서 객체는 축복 된 참조입니다. 데이터를 개체와 연결하는 표준 방법은 데이터를 개체의 본문, 즉 참조가 가리키는 데이터 부분에 저장하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6459245c83006474d0636721805e8f89399cea54" translate="yes" xml:space="preserve">
          <source>In Perl, any package can be a class. The difference between a package which is a class and one which isn't is based on how the package is used. Here's our &quot;class declaration&quot; for the &lt;code&gt;File&lt;/code&gt; class:</source>
          <target state="translated">Perl에서 모든 패키지는 클래스가 될 수 있습니다. 클래스 인 패키지와 그렇지 않은 패키지의 차이점은 패키지 사용 방법에 따라 다릅니다. &lt;code&gt;File&lt;/code&gt; 클래스에 대한 &quot;클래스 선언&quot;은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="935b815c5b098d8ca1c1e87b1e728cb47b24fb51" translate="yes" xml:space="preserve">
          <source>In Perl, any value that would look like &lt;code&gt;&quot;&quot;&lt;/code&gt; or &lt;code&gt;&quot;0&quot;&lt;/code&gt; if evaluated in a string context. Since undefined values evaluate to &lt;code&gt;&quot;&quot;&lt;/code&gt; , all undefined values are false, but not all false values are undefined.</source>
          <target state="translated">Perl 에서 문자열 컨텍스트에서 평가되는 경우 &lt;code&gt;&quot;&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 과 같은 값입니다 . 정의되지 않은 값은 &lt;code&gt;&quot;&quot;&lt;/code&gt; 로 평가되므로 정의되지 않은 모든 값은 false이지만 모든 false 값이 정의되지는 않았습니다.</target>
        </trans-unit>
        <trans-unit id="56beb88cb62afd75b5b76cfb0ba20b6ebe456c89" translate="yes" xml:space="preserve">
          <source>In Perl, binary &lt;code&gt;+&lt;/code&gt; is always addition. &lt;code&gt;$string1 + $string2&lt;/code&gt; converts both strings to numbers and then adds them. To concatenate two strings, use the &lt;code&gt;.&lt;/code&gt; operator.</source>
          <target state="translated">Perl에서 바이너리 &lt;code&gt;+&lt;/code&gt; 는 항상 더해집니다. &lt;code&gt;$string1 + $string2&lt;/code&gt; 는 두 문자열을 숫자로 변환 한 다음 추가합니다. 두 개의 문자열을 연결하려면을 사용하십시오 &lt;code&gt;.&lt;/code&gt; 운영자.</target>
        </trans-unit>
        <trans-unit id="a33a4933eab4c192832e758c7f44c0a0303ba50a" translate="yes" xml:space="preserve">
          <source>In Perl, methods are simply subroutines that live in a class's package. Methods are always written to receive the object as their first argument:</source>
          <target state="translated">Perl에서 메소드는 단순히 클래스 패키지에있는 서브 루틴입니다. 메소드는 항상 첫 번째 인수로 오브젝트를 수신하도록 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="ea72a9a423acf3df90a345514eea4421a19ceb17" translate="yes" xml:space="preserve">
          <source>In Perl, the debugger is not a separate program the way it usually is in the typical compiled environment. Instead, the &lt;b&gt;-d&lt;/b&gt; flag tells the compiler to insert source information into the parse trees it's about to hand off to the interpreter. That means your code must first compile correctly for the debugger to work on it. Then when the interpreter starts up, it preloads a special Perl library file containing the debugger.</source>
          <target state="translated">Perl에서 디버거는 일반적으로 일반적인 컴파일 환경과 같은 방식으로 별도의 프로그램이 아닙니다. 대신 &lt;b&gt;-d&lt;/b&gt; 플래그는 컴파일러에게 소스 정보를 해석기에게 전달할 구문 분석 트리에 삽입하도록 지시합니다. 즉, 디버거가 작동하려면 먼저 코드를 올바르게 컴파일해야합니다. 그런 다음 인터프리터가 시작되면 디버거가 포함 된 특수 Perl 라이브러리 파일을 미리로드합니다.</target>
        </trans-unit>
        <trans-unit id="3c642476c3d73c23016f66bc533c3f6f2db6cded" translate="yes" xml:space="preserve">
          <source>In Perl, the operator determines what operation is performed, independent of the type of the operands. For example &lt;code&gt;$x + $y&lt;/code&gt; is always a numeric addition, and if &lt;code&gt;$x&lt;/code&gt; or &lt;code&gt;$y&lt;/code&gt; do not contain numbers, an attempt is made to convert them to numbers first.</source>
          <target state="translated">Perl에서 연산자는 피연산자의 유형에 관계없이 수행 할 작업을 결정합니다. 예를 들어 &lt;code&gt;$x + $y&lt;/code&gt; 는 항상 숫자로 추가되며 &lt;code&gt;$x&lt;/code&gt; 또는 &lt;code&gt;$y&lt;/code&gt; 숫자가 포함되지 않은 경우 먼저 숫자로 변환하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="05577297c46ae0d2cd55a130e9e49792d0bf233a" translate="yes" xml:space="preserve">
          <source>In Perl, there is no special keyword for constructing an object. However, most OO modules on CPAN use a method named &lt;code&gt;new()&lt;/code&gt; to construct a new object:</source>
          <target state="translated">Perl에는 객체를 구성하기위한 특별한 키워드가 없습니다. 그러나 CPAN의 대부분의 OO 모듈은 &lt;code&gt;new()&lt;/code&gt; 라는 메소드를 사용 하여 새 오브젝트를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="e4aecd76031e1346a21238102ea29667311ebe2a" translate="yes" xml:space="preserve">
          <source>In Perl, you just can't access memory at random, but the structural and representational conversion provided by &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; is an excellent alternative. The &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; function converts values to a byte sequence containing representations according to a given specification, the so-called &quot;template&quot; argument. &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; is the reverse process, deriving some values from the contents of a string of bytes. (Be cautioned, however, that not all that has been packed together can be neatly unpacked - a very common experience as seasoned travellers are likely to confirm.)</source>
          <target state="translated">Perl에서는 메모리에 무작위로 액세스 할 수 없지만 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 에서 제공하는 구조 및 표현 변환 은 훌륭한 대안입니다. &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 소정 규격에 따라 표현이 포함 된 바이트 서열 변환 함수 값은 &quot;템플릿&quot;인수 소위. &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 은 바이트 문자열의 내용에서 일부 값을 가져 오는 역 프로세스입니다. 그러나 함께 포장 된 모든 제품이 깔끔하게 포장을 풀지는 못할 수 있습니다. 노련한 여행자가 확인하는 매우 일반적인 경험입니다.</target>
        </trans-unit>
        <trans-unit id="3a69ee0657acfe60fc783ea37121861ef3e8b2c7" translate="yes" xml:space="preserve">
          <source>In Practice</source>
          <target state="translated">실제로</target>
        </trans-unit>
        <trans-unit id="9c9de61f162399b6dd1501b64047f173f7ebabe0" translate="yes" xml:space="preserve">
          <source>In SVN, $Revision$ should be the same for every file in the project so they would all have the same $VERSION. CVS and RCS have a different $Revision$ per file so each file will have a different $VERSION. Distributed version control systems, such as SVK, may have a different $Revision$ based on who checks out the file, leading to a different $VERSION on each machine! Finally, some distributed version control systems, such as darcs, have no concept of revision number at all.</source>
          <target state="translated">SVN에서 $ Revision $은 프로젝트의 모든 파일에 대해 동일해야하므로 모두 $ VERSION이됩니다. CVS와 RCS는 파일마다 $ Revision $이 다르므로 각 파일마다 $ VERSION이 다릅니다. SVK와 같은 분산 버전 제어 시스템은 파일을 체크 아웃하는 사람에 따라 $ Revision $이 다를 수 있으며 각 머신마다 $ VERSION이 다릅니다! 마지막으로 darcs와 같은 일부 분산 버전 제어 시스템에는 개정 번호 개념이 전혀 없습니다.</target>
        </trans-unit>
        <trans-unit id="35c376db5dd46f66500036f6b8bff5133701d987" translate="yes" xml:space="preserve">
          <source>In SunOS 4.x you most probably want to use the SunOS ld, /usr/bin/ld, since the more recent versions of GNU ld (like 2.13) do not seem to work for building Perl anymore. When linking the extensions, the GNU ld gets very unhappy and spews a lot of errors like this</source>
          <target state="translated">SunOS 4.x에서는 최신 버전의 GNU ld (2.13과 같은)가 Perl을 빌드하는 데 더 이상 작동하지 않기 때문에 SunOS ld / usr / bin / ld를 사용하려고합니다. 확장 기능을 연결할 때 GNU ld는 매우 불행 해져 이와 같은 많은 오류를 뿜어냅니다.</target>
        </trans-unit>
        <trans-unit id="ef1e3aace4bede70eba3cee6d6eb0864ab35df15" translate="yes" xml:space="preserve">
          <source>In Tru64 Perl is automatically able to use large files, that is, files larger than 2 gigabytes, there is no need to use the Configure -Duselargefiles option as described in INSTALL (though using the option is harmless).</source>
          <target state="translated">Tru64 Perl에서는 큰 파일, 즉 2 기가 바이트보다 큰 파일을 자동으로 사용할 수 있으므로 INSTALL에 설명 된대로 Configure -Duselargefiles 옵션을 사용할 필요가 없습니다 (옵션을 사용하는 것은 무해합니다).</target>
        </trans-unit>
        <trans-unit id="cc19255447bc355361ae2f45799e7311a851742c" translate="yes" xml:space="preserve">
          <source>In Tru64 Perl's integers are automatically 64-bit wide, there is no need to use the Configure -Duse64bitint option as described in INSTALL. Similarly, there is no need for -Duse64bitall since pointers are automatically 64-bit wide.</source>
          <target state="translated">Tru64 Perl의 정수는 자동으로 64 비트 너비이므로 INSTALL에 설명 된대로 Configure -Duse64bitint 옵션을 사용할 필요가 없습니다. 마찬가지로 포인터가 자동으로 64 비트 폭이기 때문에 -Duse64bitall이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="92e8004abe586abe7845a841b1a5b8acbf9b5035" translate="yes" xml:space="preserve">
          <source>In Tru64 V5 (at least V5.1A, V5.1B) you cannot build threaded Perl with gcc because the system header &amp;lt;pthread.h&amp;gt; explicitly checks for supported C compilers, gcc (at least 3.2.2) not being one of them. But the system C compiler should work just fine.</source>
          <target state="translated">Tru64 V5 (적어도 V5.1A, V5.1B)에서는 시스템 헤더 &amp;lt;pthread.h&amp;gt;가 지원되는 C 컴파일러를 명시 적으로 검사하므로 gcc (적어도 3.2.2)는 gcc로 스레드 Perl을 빌드 할 수 없습니다. . 그러나 시스템 C 컴파일러는 정상적으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6303bf4cf60f3cd73bbb5bee3d92ebf1b27db248" translate="yes" xml:space="preserve">
          <source>In UTF-8 mode, it is not guaranteed that the lexer buffer actually contains valid UTF-8. Lexing code must be robust in the face of invalid encoding.</source>
          <target state="translated">UTF-8 모드에서는 렉서 버퍼에 실제로 유효한 UTF-8이 포함되어 있다고 보장되지 않습니다. 유효하지 않은 인코딩에 대해서는 렉싱 코드가 강력해야합니다.</target>
        </trans-unit>
        <trans-unit id="5587dff620034120288215aaa5eec31db833ac28" translate="yes" xml:space="preserve">
          <source>In Unicode 4.1.0, the definition D2 of canonical composition (which affects NFC and NFKC) has been changed (see Public Review Issue #29 and recent UAX #15). This module has used the newer definition since the version 0.07 (Oct 31, 2001). This module will not support the normalization according to the older definition, even if the Unicode version implemented by perl is lower than 4.1.0.</source>
          <target state="translated">유니 코드 4.1.0에서는 정식 컴포지션의 정의 D2 (NFC 및 NFKC에 영향을 미침)가 변경되었습니다 (공개 검토 문제 # 29 및 최근 UAX # 15 참조). 이 모듈은 버전 0.07 (2001 년 10 월 31 일) 이후로 새로운 정의를 사용했습니다. 이 모듈은 perl로 구현 된 유니 코드 버전이 4.1.0보다 낮더라도 이전 정의에 따른 정규화를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4add5639cbd0356c9e63afa54113a4c2eb6433cf" translate="yes" xml:space="preserve">
          <source>In Unicode terminology a</source>
          <target state="translated">유니 코드 용어에서</target>
        </trans-unit>
        <trans-unit id="f8ecaf55c52d72cac38172d4d214a7acd326645e" translate="yes" xml:space="preserve">
          <source>In Unicode, not just characters with the General Category of Lowercase Letter, but any character with the Lowercase property, including Modifier Letters, Letter Numbers, some Other Symbols, and one Combining Mark.</source>
          <target state="translated">유니 코드에서 소문자의 일반 범주가있는 문자뿐만 아니라 수정 자 문자, 문자 번호, 일부 다른 기호 및 하나의 결합 표시를 포함하여 소문자 속성이있는 문자</target>
        </trans-unit>
        <trans-unit id="6d6e7c6b62a7207f53debc7941773b1adb72b5b5" translate="yes" xml:space="preserve">
          <source>In Unicode, not just characters with the General Category of Uppercase Letter, but any character with the Uppercase property, including some Letter Numbers and Symbols. Not to be confused with &lt;b&gt;titlecase&lt;/b&gt;.</source>
          <target state="translated">유니 코드에서는 대문자의 일반 범주가있는 문자뿐만 아니라 일부 문자 번호 및 기호를 포함하여 대문자 속성이있는 문자가 있습니다. &lt;b&gt;titlecase&lt;/b&gt; 와 혼동하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="b113bf75921160dcb55ede1f720912618b376337" translate="yes" xml:space="preserve">
          <source>In Unix, a sequence of zero or more nonnewline characters terminated with a &lt;b&gt;newline&lt;/b&gt; character. On non-Unix machines, this is emulated by the C library even if the underlying &lt;b&gt;operating system&lt;/b&gt; has different ideas.</source>
          <target state="translated">Unix에서 0 개 이상의 비 &lt;b&gt;개행&lt;/b&gt; 문자 시퀀스는 &lt;b&gt;개행&lt;/b&gt; 문자로 종료됩니다 . Unix 이외의 &lt;b&gt;시스템&lt;/b&gt; 에서는 기본 &lt;b&gt;운영 체제의&lt;/b&gt; 아이디어가 다른 경우에도 C 라이브러리가이를 에뮬레이트합니다 .</target>
        </trans-unit>
        <trans-unit id="1bf9694eb8cd962c6afbe1434566f7218f970b1f" translate="yes" xml:space="preserve">
          <source>In Windows platforms, &lt;code&gt;$^O&lt;/code&gt; is not very helpful: since it is always &lt;code&gt;MSWin32&lt;/code&gt; , it doesn't tell the difference between 95/98/ME/NT/2000/XP/CE/.NET. Use &lt;code&gt;Win32::GetOSName()&lt;/code&gt; or Win32::GetOSVersion() (see &lt;a href=&quot;http://search.cpan.org/perldoc/Win32&quot;&gt;Win32&lt;/a&gt; and &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;) to distinguish between the variants.</source>
          <target state="translated">Windows 플랫폼에서 &lt;code&gt;$^O&lt;/code&gt; 는 그다지 도움이되지 않습니다. &lt;code&gt;MSWin32&lt;/code&gt; 이므로 95 / 98 / ME / NT / 2000 / XP / CE / .NET의 차이점을 알려주지 않습니다. 변형을 구별 하려면 &lt;code&gt;Win32::GetOSName()&lt;/code&gt; 또는 Win32 :: GetOSVersion () ( &lt;a href=&quot;http://search.cpan.org/perldoc/Win32&quot;&gt;Win32&lt;/a&gt; 및 &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; 참조 )을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="d8d2f9cdc2abce1c37c00210e5a99994671e5e54" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;L&amp;lt;text|...&amp;gt;&lt;/code&gt; code, text may contain formatting codes for formatting or for E&amp;lt;...&amp;gt; escapes, as in:</source>
          <target state="translated">A의 &lt;code&gt;L&amp;lt;text|...&amp;gt;&lt;/code&gt; 코드, 텍스트 서식 또는 E에 대한 코드의 서식을 포함 할 수있다 &amp;lt;...&amp;gt; 이스케이프, 같이 :</target>
        </trans-unit>
        <trans-unit id="01e19714f7b922e3746b1633bf7eecd4c7104aed" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;while (&amp;lt;&amp;gt;)&lt;/code&gt; loop, &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof(ARGV)&lt;/a&gt;&lt;/code&gt; can be used to detect the end of each file, whereas &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; will detect the end of the very last file only. Examples:</source>
          <target state="translated">(A)에 &lt;code&gt;while (&amp;lt;&amp;gt;)&lt;/code&gt; 루프 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof(ARGV)&lt;/a&gt;&lt;/code&gt; 반면에, 각 파일의 끝을 검출하는데 사용될 수 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; 단지 아주 최근 파일의 끝을 검출한다. 예 :</target>
        </trans-unit>
        <trans-unit id="41690d136fbd264eb140c8b8c6cc615177c5eb14" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;while (&amp;lt;&amp;gt;)&lt;/code&gt; loop, &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(ARGV)&lt;/a&gt;&lt;/code&gt; can be used to detect the end of each file, whereas &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; will detect the end of the very last file only. Examples:</source>
          <target state="translated">(A)에 &lt;code&gt;while (&amp;lt;&amp;gt;)&lt;/code&gt; 루프 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(ARGV)&lt;/a&gt;&lt;/code&gt; 반면에, 각 파일의 끝을 검출하는데 사용될 수 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; 단지 아주 최근 파일의 끝을 검출한다. 예 :</target>
        </trans-unit>
        <trans-unit id="bc099e33e27d3f3cccb59648c75894207f5a15fa" translate="yes" xml:space="preserve">
          <source>In a Perl built for debugging, some buckets may have negative usable size. This means that these buckets cannot (and will not) be used. For larger buckets, the memory footprint may be one page greater than a power of 2. If so, the corresponding power of two is printed in the &lt;code&gt;APPROX&lt;/code&gt; field above.</source>
          <target state="translated">디버깅 용으로 구축 된 Perl에서 일부 버킷의 사용 가능한 크기는 음수 일 수 있습니다. 이는 이러한 버킷을 사용할 수없고 사용할 수 없음을 의미합니다. 더 큰 버킷의 경우 메모리 풋 프린트는 2의 제곱보다 1 페이지 더 클 수 있습니다. 그렇다면, 2의 해당 제곱이 위 의 &lt;code&gt;APPROX&lt;/code&gt; 필드에 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="9d530f843344f7a394d5586d561f13c274faa0f4" translate="yes" xml:space="preserve">
          <source>In a Perl version number such as 5.6.2, this is the 2. Values greater than 50 represent potentially unstable development subversions. This value is manually set in</source>
          <target state="translated">5.6.2와 같은 Perl 버전 번호는 2입니다. 50보다 큰 값은 잠재적으로 불안정한 개발 서브 버전을 나타냅니다. 이 값은 수동으로 설정됩니다</target>
        </trans-unit>
        <trans-unit id="0f808181882ea1893d708887496cf67865ae159d" translate="yes" xml:space="preserve">
          <source>In a Perl version number such as 5.6.2, this is the 5. This value is manually set in</source>
          <target state="translated">5.6.2와 같은 Perl 버전 번호는 5입니다.이 값은</target>
        </trans-unit>
        <trans-unit id="9adb69905ef42f7e50e2708e20623f57aec71e19" translate="yes" xml:space="preserve">
          <source>In a Perl version number such as 5.6.2, this is the 6. This value is manually set in</source>
          <target state="translated">5.6.2와 같은 Perl 버전 번호는 6입니다.이 값은</target>
        </trans-unit>
        <trans-unit id="00e75241de38f496d3e98c78e65b223be163fce0" translate="yes" xml:space="preserve">
          <source>In a UTF-8 locale in v5.20 and later, the only visible difference between locale and non-locale in regular expressions should be tainting (see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;).</source>
          <target state="translated">v5.20 이상의 UTF-8 로케일에서 정규식에서 로케일과 로케일이 아닌 유일한 차이는 오염이어야합니다 ( &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; 참조) . ).</target>
        </trans-unit>
        <trans-unit id="684ae84268e30b89f35130d6bd4027aeb36b7294" translate="yes" xml:space="preserve">
          <source>In a bracketed character class in a regular expression pattern, you had a range which has exactly one end of it specified using &lt;code&gt;\N{}&lt;/code&gt; , and the other end is specified using a non-portable mechanism. Perl treats the range as a Unicode range, that is, all the characters in it are considered to be the Unicode characters, and which may be different code points on some platforms Perl runs on. For example, &lt;code&gt;[\N{U+06}-\x08]&lt;/code&gt; is treated as if you had instead said &lt;code&gt;[\N{U+06}-\N{U+08}]&lt;/code&gt; , that is it matches the characters whose code points in Unicode are 6, 7, and 8. But that &lt;code&gt;\x08&lt;/code&gt; might indicate that you meant something different, so the warning gets raised.</source>
          <target state="translated">정규 표현식 패턴의 대괄호로 묶은 문자 클래스에서 &lt;code&gt;\N{}&lt;/code&gt; 사용하여 정확히 한 쪽 끝이 지정되고 다른 쪽 끝은 이식 불가능한 메커니즘을 사용하여 지정됩니다. Perl은 범위를 유니 코드 범위로 취급합니다. 즉, 범위 내의 모든 문자는 유니 코드 문자로 간주되며 Perl이 실행되는 일부 플랫폼에서 다른 코드 포인트 일 수 있습니다. 예를 들어, &lt;code&gt;[\N{U+06}-\x08]&lt;/code&gt; 은 &lt;code&gt;[\N{U+06}-\N{U+08}]&lt;/code&gt; 이라고 말한 것처럼 취급됩니다. 즉 , 코드 포인트가있는 문자와 일치합니다 유니 코드의 6, 7, 8입니다. 그러나 &lt;code&gt;\x08&lt;/code&gt; 은 다른 의미를 나타낼 수 있으므로 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1004ce202059ee590c51b52b194413677ea17ca4" translate="yes" xml:space="preserve">
          <source>In a context not requiring a list value, the value of what appears to be a list literal is simply the value of the final element, as with the C comma operator. For example,</source>
          <target state="translated">리스트 값을 요구하지 않는 문맥에서리스트 리터럴로 보이는 것의 값은 단순히 C 쉼표 연산자와 마찬가지로 최종 요소의 값입니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="4c9fb939bd1697123252f0ff4192d8603d7b42ba" translate="yes" xml:space="preserve">
          <source>In a future version of Storable, we intend to provide options to disable loading modules for classes and to disable deserializing objects altogether.</source>
          <target state="translated">이후 버전의 Storable에서는 클래스에 대한 모듈로드를 비활성화하고 객체를 직렬화 해제하는 옵션을 제공 할 예정입니다.</target>
        </trans-unit>
        <trans-unit id="7f48268e7084e302cd8de3636cf3c45d91f67d83" translate="yes" xml:space="preserve">
          <source>In a list context it returns a list of all the operator names. (Not yet implemented, use @names = opset_to_ops(full_opset).)</source>
          <target state="translated">목록 컨텍스트에서 모든 연산자 이름의 목록을 반환합니다. (아직 구현되지 않은 경우 @names = opset_to_ops (full_opset)을 사용하십시오.)</target>
        </trans-unit>
        <trans-unit id="b5d9986ae8bd12e0cac8222f9f5aeaf66d07a75b" translate="yes" xml:space="preserve">
          <source>In a list context it returns the inflation object, &lt;code&gt;$i&lt;/code&gt; , and the</source>
          <target state="translated">목록 컨텍스트에서 인플레이션 객체 &lt;code&gt;$i&lt;/code&gt; 및</target>
        </trans-unit>
        <trans-unit id="145c4668502bd10d7409835c5418f6cbabe20a25" translate="yes" xml:space="preserve">
          <source>In a list context it returns the inflation stream, &lt;code&gt;$i&lt;/code&gt; , and the</source>
          <target state="translated">목록 컨텍스트에서 인플레이션 스트림 &lt;code&gt;$i&lt;/code&gt; 및</target>
        </trans-unit>
        <trans-unit id="1cf4f84fa82dd8ae218d529ba322249a8b367063" translate="yes" xml:space="preserve">
          <source>In a list context, &lt;code&gt;extract_quotelike&lt;/code&gt; would return the list</source>
          <target state="translated">목록 컨텍스트에서 &lt;code&gt;extract_quotelike&lt;/code&gt; 는 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7602890513e241f884402d4ec0723dbc5ab2f461" translate="yes" xml:space="preserve">
          <source>In a list context, all the functions return &lt;code&gt;(&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;,$original_text)&lt;/code&gt; on failure. In a scalar context, failure is indicated by returning &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (in this case the input text is not modified in any way).</source>
          <target state="translated">목록 컨텍스트에서 모든 함수 는 실패시 &lt;code&gt;(&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;,$original_text)&lt;/code&gt; 를 반환 합니다. 스칼라 컨텍스트에서 실패는 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환하여 표시됩니다. (이 경우 입력 텍스트는 어떤 식 으로든 수정되지 않습니다).</target>
        </trans-unit>
        <trans-unit id="9a94ef45d6203b10b750123aea4390fcb5b00e20" translate="yes" xml:space="preserve">
          <source>In a list context, all the subroutines return a list, the first three elements of which are always:</source>
          <target state="translated">리스트 컨텍스트에서 모든 서브 루틴은리스트를 리턴하며 처음 세 요소는 항상 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f3d0f0be64532af27f8e2b721243720c0db92d9a" translate="yes" xml:space="preserve">
          <source>In a list context, an array of 11 elements is returned. The elements are:</source>
          <target state="translated">목록 컨텍스트에서 11 개의 요소 배열이 리턴됩니다. 요소는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8d3d6cbfb7caf07ade67b0cd6e1a9dc2096892c7" translate="yes" xml:space="preserve">
          <source>In a pinch, if you cannot wait for Configure to be educated, or if you have a good hunch of where quux() might be available, you can temporarily try the following:</source>
          <target state="translated">핀치에서 Configure가 교육 될 때까지 기다릴 수 없거나 quux ()를 사용할 수있는 곳을 잘 알고 있다면 일시적으로 다음을 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8692c1987c2bd18d4696b2de38e79ce9a490834f" translate="yes" xml:space="preserve">
          <source>In a real situation, care should be taken that all threads are finished executing before the program exits. That care has &lt;b&gt;not&lt;/b&gt; been taken in these examples in the interest of simplicity. Running these examples</source>
          <target state="translated">실제 상황에서는 프로그램이 종료되기 전에 모든 스레드 실행이 완료되도록주의해야합니다. 이 예제에서는 단순성을 위해 주의를 기울이지 &lt;b&gt;않았습니다&lt;/b&gt; . 이 예제를 실행</target>
        </trans-unit>
        <trans-unit id="81c10dc0ae0ebb18c61b259ddfe6843d666964b7" translate="yes" xml:space="preserve">
          <source>In a reciprocal fashion, an operation provides either a scalar or a list context to each of its arguments. For example, if you say</source>
          <target state="translated">역수 방식으로 연산은 스칼라 또는 목록 컨텍스트를 각 인수에 제공합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="c78cf6df929776e529a74a77e45234f404202f1c" translate="yes" xml:space="preserve">
          <source>In a regular expression, the backslash can perform one of two tasks: it either takes away the special meaning of the character following it (for instance, &lt;code&gt;\|&lt;/code&gt; matches a vertical bar, it's not an alternation), or it is the start of a backslash or escape sequence.</source>
          <target state="translated">정규식에서 백 슬래시는 다음 두 가지 작업 중 하나를 수행 할 수 있습니다. 예를 들어, &lt;code&gt;\|&lt;/code&gt; 는 세로 막대와 일치하거나 대체가 아닙니다. 백 슬래시 또는 이스케이프 시퀀스</target>
        </trans-unit>
        <trans-unit id="81b5d9cd571e9943815277ab89c7fe545d260e8a" translate="yes" xml:space="preserve">
          <source>In a scalar context &lt;code&gt;deflate&lt;/code&gt; will return &lt;code&gt;$out&lt;/code&gt; only.</source>
          <target state="translated">스칼라 컨텍스트에서 &lt;code&gt;deflate&lt;/code&gt; 는 &lt;code&gt;$out&lt;/code&gt; 만 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="d751225aea131e8c18607565afa032c5caedabd6" translate="yes" xml:space="preserve">
          <source>In a scalar context &lt;code&gt;flush&lt;/code&gt; will return &lt;code&gt;$out&lt;/code&gt; only.</source>
          <target state="translated">스칼라 컨텍스트에서 &lt;code&gt;flush&lt;/code&gt; 는 &lt;code&gt;$out&lt;/code&gt; 만 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="24a49c87bdb8b460c4017296f34ddb336c87c832" translate="yes" xml:space="preserve">
          <source>In a scalar context it returns the group name.</source>
          <target state="translated">스칼라 컨텍스트에서 그룹 이름을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="32d6c6f3bf39438d4047ce657137dce5d3577d7c" translate="yes" xml:space="preserve">
          <source>In a scalar context opcodes returns the number of opcodes in this version of perl (around 350 for perl-5.7.0).</source>
          <target state="translated">스칼라 컨텍스트에서 opcodes는이 버전의 perl에서 opcode 수를 리턴합니다 (perl-5.7.0의 경우 약 350).</target>
        </trans-unit>
        <trans-unit id="208f6e20787f24b907ff451f1741888a45d23759" translate="yes" xml:space="preserve">
          <source>In a scalar context the method returns the number of values associated with the key, &lt;code&gt;$key&lt;/code&gt; .</source>
          <target state="translated">스칼라 컨텍스트에서이 메소드는 키 &lt;code&gt;$key&lt;/code&gt; 와 연관된 값의 수를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="cec0bad3cd5e75ede69094662ac02e11b4300440" translate="yes" xml:space="preserve">
          <source>In a scalar context the new socket is returned, or undef upon failure. In a list context a two-element array is returned containing the new socket and the peer address; the list will be empty upon failure.</source>
          <target state="translated">스칼라 컨텍스트에서 새 소켓이 리턴되거나 실패시 정의되지 않습니다. 리스트 문맥에서, 새로운 소켓과 피어 주소를 포함하는 2 요소 배열이 반환됩니다. 실패하면 목록이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="92d1e3370613f74b8985a6b3b39b4a2c46223d16" translate="yes" xml:space="preserve">
          <source>In a scalar context, &lt;code&gt;extract_quotelike&lt;/code&gt; returns just the complete substring that matched a quotelike operation (or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on failure). In a scalar or void context, the input text has the same substring (and any specified prefix) removed.</source>
          <target state="translated">스칼라 컨텍스트에서 &lt;code&gt;extract_quotelike&lt;/code&gt; 는 따옴표와 같은 연산 (또는 실패시 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ) 과 일치하는 완전한 하위 문자열 만 반환합니다 . 스칼라 또는 공백 컨텍스트에서 입력 텍스트는 동일한 서브 스트링 (및 지정된 접 두부)이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="b5b8dc86dc00a1f2952c9a2e48c451d832e4c066" translate="yes" xml:space="preserve">
          <source>In a scalar context, &lt;code&gt;extract_tagged&lt;/code&gt; returns just the complete substring that matched a tagged text (including the start and end tags). &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned on failure. In addition, the original input text has the returned substring (and any prefix) removed from it.</source>
          <target state="translated">스칼라 컨텍스트에서 &lt;code&gt;extract_tagged&lt;/code&gt; 는 태그 지정된 텍스트 (시작 및 종료 태그 포함)와 일치하는 완전한 하위 문자열 만 리턴합니다. &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 는 실패시 리턴됩니다. 또한 원래 입력 텍스트에는 반환 된 하위 문자열 (및 모든 접두사)이 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="f9900a2af209760381e75d8f7a14615b5a9bdbec" translate="yes" xml:space="preserve">
          <source>In a scalar context, &lt;code&gt;extract_variable&lt;/code&gt; returns just the complete substring that matched a variablish expression. &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned on failure. In addition, the original input text has the returned substring (and any prefix) removed from it.</source>
          <target state="translated">스칼라 컨텍스트에서 &lt;code&gt;extract_variable&lt;/code&gt; 은 변수 표현식과 일치하는 완전한 하위 문자열 만 리턴합니다. &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 는 실패시 리턴됩니다. 또한 원래 입력 텍스트에는 반환 된 하위 문자열 (및 모든 접두사)이 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="945278245cb407350f6bc45cb3b502fc5ad85d58" translate="yes" xml:space="preserve">
          <source>In a scalar context, just the extracted substring is returned. In a void context, the extracted substring (and any prefix) are simply removed from the beginning of the first argument.</source>
          <target state="translated">스칼라 컨텍스트에서는 추출 된 하위 문자열 만 리턴됩니다. 빈 공간에서 추출 된 부분 문자열 (및 모든 접두사)은 단순히 첫 번째 인수의 시작 부분에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="7e3e24a2a724494140e588e3803a95e574330808" translate="yes" xml:space="preserve">
          <source>In a scalar context, the extracted string is returned, having first been removed from the input text. Thus, the following code also processes each quote-like operation, but actually removes them from $text:</source>
          <target state="translated">스칼라 컨텍스트에서 추출 된 문자열이 입력 텍스트에서 먼저 제거 된 상태로 리턴됩니다. 따라서 다음 코드는 각 따옴표와 같은 연산을 처리하지만 실제로 $ text에서 제거합니다.</target>
        </trans-unit>
        <trans-unit id="0d5544cfc850136e8726fbbd9c72234c9b7ae747" translate="yes" xml:space="preserve">
          <source>In a sense, perl (the C program) is a good example of embedding Perl (the language), so I'll demonstrate embedding with</source>
          <target state="translated">어떤 의미에서 perl (C 프로그램)은 Perl (언어)을 포함시키는 좋은 예입니다.</target>
        </trans-unit>
        <trans-unit id="ff595beb69ecf8f38b6337a9d03b24a9b262246c" translate="yes" xml:space="preserve">
          <source>In a similar fashion, overriding the &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; function also overrides the equivalent I/O operator &lt;code&gt;&amp;lt;FILEHANDLE&amp;gt;&lt;/code&gt; . Also, overriding &lt;code&gt;&lt;a href=&quot;functions/readpipe&quot;&gt;readpipe&lt;/a&gt;&lt;/code&gt; also overrides the operators &lt;code&gt;``&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">비슷한 방식으로 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 함수를 재정의하면 동등한 I / O 연산자 &lt;code&gt;&amp;lt;FILEHANDLE&amp;gt;&lt;/code&gt; 도 재정의 됩니다. 또한 &lt;code&gt;&lt;a href=&quot;functions/readpipe&quot;&gt;readpipe&lt;/a&gt;&lt;/code&gt; 를 재정의하면 연산자 &lt;code&gt;``&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt; 재정의 됩니다.</target>
        </trans-unit>
        <trans-unit id="2d250c896d3f5eb11d7a648b3bc78f5925e2fcce" translate="yes" xml:space="preserve">
          <source>In a void context the behaviour of the extraction subroutines is exactly the same as in a scalar context, except (of course) that the extracted substring is not returned.</source>
          <target state="translated">공백 컨텍스트에서 추출 서브 루틴의 동작은 스칼라 컨텍스트와 정확히 동일하지만 추출 된 서브 스트링이 리턴되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="164ac7c993944f12e7319a81a34bfbc9042d71d4" translate="yes" xml:space="preserve">
          <source>In a void context, the input text just has the matched substring (and any specified prefix) removed.</source>
          <target state="translated">빈 공간에서 입력 텍스트는 일치하는 부분 문자열 (및 지정된 접두사) 만 제거합니다.</target>
        </trans-unit>
        <trans-unit id="a9b13f420194df675e5068f5af3ab2ba48ac53e8" translate="yes" xml:space="preserve">
          <source>In a word - don't, at least not without a *very* good reason. Your scripts can just as easily begin with &quot;#!/usr/local/bin/perl&quot; as with &quot;#!/usr/bin/perl&quot;. Scripts supplied by Apple and other third parties as part of installation packages and such have generally only been tested with the /usr/bin/perl that's installed by Apple.</source>
          <target state="translated">한마디로, * 아주 * 좋은 이유 없이는하지 마십시오. 스크립트는 &quot;#! / usr / bin / perl&quot;과 마찬가지로 &quot;#! / usr / local / bin / perl&quot;로 쉽게 시작할 수 있습니다. 설치 패키지의 일부로 Apple 및 기타 제 3자가 제공 한 스크립트는 일반적으로 Apple에서 설치 한 / usr / bin / perl에서만 테스트되었습니다.</target>
        </trans-unit>
        <trans-unit id="fcf1ea0b348743b5d23b285ecea8c108896961cc" translate="yes" xml:space="preserve">
          <source>In academia, a curriculum vit&amp;aelig;, a fancy kind of r&amp;eacute;sum&amp;eacute;. In Perl, an internal &amp;ldquo;code value&amp;rdquo; typedef holding a &lt;b&gt;subroutine&lt;/b&gt;. The &lt;code&gt;CV&lt;/code&gt; type is a subclass of &lt;b&gt;SV&lt;/b&gt;.</source>
          <target state="translated">학계에서는 커리큘럼 vit&amp;aelig;, 멋진 이력서입니다. Perl에서 &lt;b&gt;서브 루틴을&lt;/b&gt; 보유하는 내부 &quot;코드 값&quot;typedef . &lt;code&gt;CV&lt;/code&gt; 의 유형의 서브 클래스입니다 &lt;b&gt;SV&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="b2f52867b2f837c43cc5640194de947dbf1e2090" translate="yes" xml:space="preserve">
          <source>In actuality, the period and &lt;code&gt;\d\s\w\D\S\W&lt;/code&gt; abbreviations are themselves types of character classes, so the ones surrounded by brackets are just one type of character class. When we need to make a distinction, we refer to them as &quot;bracketed character classes.&quot;</source>
          <target state="translated">실제로 마침표와 &lt;code&gt;\d\s\w\D\S\W&lt;/code&gt; 약어는 그 자체가 문자 클래스 유형이므로 대괄호로 묶인 문자는 문자 클래스 유형 중 하나 일뿐입니다. 구별해야 할 때는 &quot;브래킷 문자 클래스&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="46e3a38016d86ba7214b26757c2cfc95f05dd8d8" translate="yes" xml:space="preserve">
          <source>In addition</source>
          <target state="translated">게다가</target>
        </trans-unit>
        <trans-unit id="7e82af699df6da7e07e9ea8a98307994127655f1" translate="yes" xml:space="preserve">
          <source>In addition EXTEND will be called when perl would have pre-extended allocation in a real array.</source>
          <target state="translated">또한 EXTEND는 perl이 실제 배열에서 사전 확장 된 할당을 가질 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="ed2d1a9f24dc62aaee4efacb9df22dbcc5333d73" translate="yes" xml:space="preserve">
          <source>In addition it contains two fields that are intended for the private use of the regex engine that compiled the pattern. These are the &lt;code&gt;intflags&lt;/code&gt; and &lt;code&gt;pprivate&lt;/code&gt; members. &lt;code&gt;pprivate&lt;/code&gt; is a void pointer to an arbitrary structure, whose use and management is the responsibility of the compiling engine. Perl will never modify either of these values.</source>
          <target state="translated">또한 패턴을 컴파일 한 정규식 엔진을 개인적으로 사용하기위한 두 개의 필드가 포함되어 있습니다. 이들은 &lt;code&gt;intflags&lt;/code&gt; 및 &lt;code&gt;pprivate&lt;/code&gt; 멤버입니다. &lt;code&gt;pprivate&lt;/code&gt; 는 임의의 구조에 대한 무효 포인터이며, 사용 및 관리는 컴파일 엔진의 책임입니다. Perl은 이러한 값 중 어느 것도 수정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7aa9ca3525844fd7a1f1f038ab777e0241661c46" translate="yes" xml:space="preserve">
          <source>In addition it contains two fields that are intended for the private use of the regex engine that compiled the pattern. These are the &lt;code&gt;intflags&lt;/code&gt; and pprivate members. The &lt;code&gt;pprivate&lt;/code&gt; is a void pointer to an arbitrary structure whose use and management is the responsibility of the compiling engine. perl will never modify either of these values.</source>
          <target state="translated">또한 패턴을 컴파일 한 정규식 엔진을 개인적으로 사용하기위한 두 개의 필드가 포함되어 있습니다. 이들은 &lt;code&gt;intflags&lt;/code&gt; 및 개인 멤버입니다. &lt;code&gt;pprivate&lt;/code&gt; 는 사용 및 관리 컴파일 엔진의 책임이다 임의의 구조에 대한 무효 포인터입니다. perl은 이러한 값 중 어느 것도 수정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="152b5f495da9efbec00e14f0ef1bc85e80c4a061" translate="yes" xml:space="preserve">
          <source>In addition to &lt;b&gt;scripts&lt;/b&gt;, Unicode also defines &lt;b&gt;blocks&lt;/b&gt; of characters. The difference between scripts and blocks is that the concept of scripts is closer to natural languages, while the concept of blocks is more of an artificial grouping based on groups of Unicode characters with consecutive ordinal values. For example, the &lt;code&gt;&quot;Basic Latin&quot;&lt;/code&gt; block is all the characters whose ordinals are between 0 and 127, inclusive; in other words, the ASCII characters. The &lt;code&gt;&quot;Latin&quot;&lt;/code&gt; script contains some letters from this as well as several other blocks, like &lt;code&gt;&quot;Latin-1 Supplement&quot;&lt;/code&gt; , &lt;code&gt;&quot;Latin Extended-A&quot;&lt;/code&gt; ,</source>
          <target state="translated">유니 코드는 &lt;b&gt;스크립트&lt;/b&gt; 외에도 문자 &lt;b&gt;블록&lt;/b&gt; 을 정의 합니다. 스크립트와 블록의 차이점은 스크립트 개념은 자연어에 더 가깝고 블록 개념은 연속 서수 값을 갖는 유니 코드 문자 그룹을 기반으로 한 인공 그룹화에 가깝다는 것입니다. 예를 들어, &lt;code&gt;&quot;Basic Latin&quot;&lt;/code&gt; 블록은 서 수가 0에서 127 사이의 모든 문자입니다. 다시 말해 ASCII 문자입니다. &lt;code&gt;&quot;Latin&quot;&lt;/code&gt; 스크립트처럼,이뿐만 아니라 여러 다른 블록에서 일부 문자가 들어 있습니다 &lt;code&gt;&quot;Latin-1 Supplement&quot;&lt;/code&gt; , &lt;code&gt;&quot;Latin Extended-A&quot;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="f86a4eaf10c727caafeb64d3a643f53ff65e9454" translate="yes" xml:space="preserve">
          <source>In addition to adding seconds, there are two APIs for adding months and years:</source>
          <target state="translated">초를 추가하는 것 외에도 몇 달과 몇 년을 추가하는 두 가지 API가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2fd5a60f4cdde51801210d2d64a0096f9f11eee" translate="yes" xml:space="preserve">
          <source>In addition to an editor/IDE you might be interested in a more powerful shell environment for Win32. Your options include</source>
          <target state="translated">편집기 / IDE 외에도 Win32를위한보다 강력한 쉘 환경에 관심이있을 수 있습니다. 귀하의 옵션은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="1749590c161975b92597e609a16d593c1ab667da" translate="yes" xml:space="preserve">
          <source>In addition to being Unix, we're U/WIN.</source>
          <target state="translated">유닉스 일뿐 아니라 우리는 U / WIN입니다.</target>
        </trans-unit>
        <trans-unit id="59ad52f794c0c2f95e95db00a5db4b0758359fc7" translate="yes" xml:space="preserve">
          <source>In addition to computing what you expected, the last example also does &lt;b&gt;not&lt;/b&gt; &quot;taint&quot; the result with an accuracy or precision setting, which would influence any further operation.</source>
          <target state="translated">마지막 예제는 예상 한 것을 계산하는 것 외에도 정확도 나 정밀 설정으로 결과를 &quot;보관&quot; 하지 &lt;b&gt;않으므로&lt;/b&gt; 이후 작업에 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="ae2d9c47551f30ac79ac4fb8a4a7835684b54313" translate="yes" xml:space="preserve">
          <source>In addition to fields allowed in pack(), you may prefix a field with a %&amp;lt;number&amp;gt; to indicate that you want a &amp;lt;number&amp;gt;-bit checksum of the items instead of the items themselves. Default is a 16-bit checksum. Checksum is calculated by summing numeric values of expanded values (for string fields the sum of &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord($char)&lt;/a&gt;&lt;/code&gt; is taken; for bit fields the sum of zeroes and ones).</source>
          <target state="translated">pack ()에서 허용되는 필드 외에도 항목 앞에 &amp;lt;숫자&amp;gt; 비트 체크섬을 원한다는 것을 나타 내기 위해 % &amp;lt;숫자&amp;gt;를 필드 앞에 붙일 수 있습니다. 기본값은 16 비트 체크섬입니다. 체크섬은 확장 값의 숫자 값을 합산하여 계산됩니다 (문자열 필드의 경우 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord($char)&lt;/a&gt;&lt;/code&gt; 의 합이 취해지고 비트 필드의 경우 0과 1의 합).</target>
        </trans-unit>
        <trans-unit id="8fab1ee4cfb63b6e2e7d76c7cfd5888f6ab2e679" translate="yes" xml:space="preserve">
          <source>In addition to fields allowed in pack(), you may prefix a field with a %&amp;lt;number&amp;gt; to indicate that you want a &amp;lt;number&amp;gt;-bit checksum of the items instead of the items themselves. Default is a 16-bit checksum. Checksum is calculated by summing numeric values of expanded values (for string fields the sum of &lt;code&gt;&lt;a href=&quot;ord&quot;&gt;ord($char)&lt;/a&gt;&lt;/code&gt; is taken; for bit fields the sum of zeroes and ones).</source>
          <target state="translated">pack ()에서 허용되는 필드 외에도 항목 앞에 &amp;lt;숫자&amp;gt; 비트 체크섬을 원한다는 것을 나타 내기 위해 % &amp;lt;숫자&amp;gt;를 필드 앞에 붙일 수 있습니다. 기본값은 16 비트 체크섬입니다. 체크섬은 확장 값의 숫자 값을 합산하여 계산됩니다 (문자열 필드의 경우 &lt;code&gt;&lt;a href=&quot;ord&quot;&gt;ord($char)&lt;/a&gt;&lt;/code&gt; 의 합이 취해지고 비트 필드의 경우 0과 1의 합).</target>
        </trans-unit>
        <trans-unit id="40ec63aed202427c78ae99bf79365c2b0344aea9" translate="yes" xml:space="preserve">
          <source>In addition to interacting with the &lt;code&gt;(*SKIP)&lt;/code&gt; pattern, &lt;code&gt;(*MARK:NAME)&lt;/code&gt; can be used to &quot;label&quot; a pattern branch, so that after matching, the program can determine which branches of the pattern were involved in the match.</source>
          <target state="translated">&lt;code&gt;(*SKIP)&lt;/code&gt; 패턴 과 상호 작용하는 것 외에도 &lt;code&gt;(*MARK:NAME)&lt;/code&gt; 을 사용하여 패턴 분기를 &quot;라벨&quot;할 수 있으므로, 일치 후 프로그램이 패턴의 어느 분기가 일치 하는지를 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cea68ca5519ffc8129501826ad0bb9062eef1e64" translate="yes" xml:space="preserve">
          <source>In addition to possible bugs and an inability to follow changes to the translation policy with off/on switches of TERMIO translation, this introduces a serious incompatible change: before sysread() on text-mode filehandles would go through the translation layer, now it would not.</source>
          <target state="translated">가능한 버그 및 TERMIO 변환 스위치를 켜고 끄는 변환 정책 변경 사항을 수행 할 수 없다는 점 외에도 텍스트 모드 파일 핸들의 sysread ()가 변환 계층을 통과하기 전에 호환되지 않는 심각한 변경이 발생합니다. 아니.</target>
        </trans-unit>
        <trans-unit id="d4d69cf9bd1e25a37f285dc63efc29fb797f0fe0" translate="yes" xml:space="preserve">
          <source>In addition to standard-like API defined so far above there is an &quot;implementation&quot; interface which allows perl to get at internals of PerlIO. The following calls correspond to the various FILE_xxx macros determined by Configure - or their equivalent in other implementations. This section is really of interest to only those concerned with detailed perl-core behaviour, implementing a PerlIO mapping or writing code which can make use of the &quot;read ahead&quot; that has been done by the IO system in the same way perl does. Note that any code that uses these interfaces must be prepared to do things the traditional way if a handle does not support them.</source>
          <target state="translated">지금까지 정의 된 표준 유사 API 외에도 perlIO가 PerlIO 내부에 액세스 할 수있는 &quot;구현&quot;인터페이스가 있습니다. 다음 호출은 Configure에 의해 결정된 다양한 FILE_xxx 매크로 또는 다른 구현에서 동등한 FILE_xxx 매크로에 해당합니다. 이 섹션은 perl과 동일한 방식으로 IO 시스템에 의해 수행 된 &quot;미리 읽기&quot;를 사용할 수있는 PerlIO 매핑 또는 코드 작성을 구현하는 자세한 perl-core 동작에 관심이있는 사용자에게만 관심이 있습니다. 이러한 인터페이스를 사용하는 코드는 핸들이 지원하지 않는 경우 전통적인 방식으로 작업 할 수 있도록 준비해야합니다.</target>
        </trans-unit>
        <trans-unit id="17eaea3931a67cb37ce8cb0cb3c4e8d09398b8c0" translate="yes" xml:space="preserve">
          <source>In addition to the MEDIUM security checks, also check for the possibility of ``chown() giveaway'' using the L</source>
          <target state="translated">MEDIUM 보안 검사 외에도 L을 사용하여``chown () 공짜 ''가능성을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="89182cb06f6668d208e0619e4cbe15cde7591879" translate="yes" xml:space="preserve">
          <source>In addition to the OVERLOAD keyword, if you need to control how Perl autogenerates missing overloaded operators, you can set the FALLBACK keyword in the module header section, like this:</source>
          <target state="translated">OVERLOAD 키워드 외에도 Perl이 누락 된 오버로드 된 연산자를 자동 생성하는 방법을 제어해야하는 경우 다음과 같이 모듈 헤더 섹션에서 FALLBACK 키워드를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf43e38422f03f19f7c8bc12dfe3cf7238322b4f" translate="yes" xml:space="preserve">
          <source>In addition to the STANDARD security, the output directory is checked to make sure that it is owned either by root or the user running the program. If the directory is writable by group or by other, it is then checked to make sure that the sticky bit is set.</source>
          <target state="translated">STANDARD 보안 외에도 출력 디렉토리가 루트 또는 프로그램을 실행중인 사용자가 소유하고 있는지 확인합니다. 디렉토리가 그룹 또는 다른 디렉토리에 의해 쓰기 가능한 경우, 고정 비트가 설정되어 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="a6827bb11452b38549da194a0e9f946e676fb6ab" translate="yes" xml:space="preserve">
          <source>In addition to the compiler flags used to select the SDK, also add the flags for creating a universal binary:</source>
          <target state="translated">SDK를 선택하는 데 사용되는 컴파일러 플래그 외에도 범용 바이너리를 생성하기위한 플래그를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="73c76010fe3f7536529c60cd357cfa7c8e4a0b21" translate="yes" xml:space="preserve">
          <source>In addition to the different levels of OS involvement in threads, different OSes (and different thread implementations for a particular OS) allocate CPU cycles to threads in different ways.</source>
          <target state="translated">스레드에 다양한 수준의 OS 관련 외에도 다른 OS (및 특정 OS에 대한 다른 스레드 구현)는 다른 방식으로 스레드에 CPU주기를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="79a96fb0aa6c1ca892c14d42638abd6240d03e9c" translate="yes" xml:space="preserve">
          <source>In addition to the file and subroutine-related variables mentioned above, the debugger also maintains various magical internal variables.</source>
          <target state="translated">위에서 언급 한 파일 및 서브 루틴 관련 변수 외에도 디버거는 다양한 마법의 내부 변수를 유지 관리합니다.</target>
        </trans-unit>
        <trans-unit id="bab0de29db31c89ae8ab9839888cf6f1bf406c03" translate="yes" xml:space="preserve">
          <source>In addition to the key-value pairs accepted by &lt;a href=&quot;../socket&quot;&gt;IO::Socket&lt;/a&gt;, &lt;code&gt;IO::Socket::INET&lt;/code&gt; provides.</source>
          <target state="translated">&lt;a href=&quot;../socket&quot;&gt;IO :: Socket&lt;/a&gt; 에서 허용되는 키-값 쌍 외에도 &lt;code&gt;IO::Socket::INET&lt;/code&gt; 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7a72b31c557cda8bc1b722b2e6a26c2c901af09d" translate="yes" xml:space="preserve">
          <source>In addition to the key-value pairs accepted by &lt;a href=&quot;../socket&quot;&gt;IO::Socket&lt;/a&gt;, &lt;code&gt;IO::Socket::UNIX&lt;/code&gt; provides.</source>
          <target state="translated">에서 허용하는 키 - 값 쌍 외에도 &lt;a href=&quot;../socket&quot;&gt;IO :: 소켓&lt;/a&gt; , &lt;code&gt;IO::Socket::UNIX&lt;/code&gt; 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7c45e877ad35106ffbe7de68a1cdc70a047e523f" translate="yes" xml:space="preserve">
          <source>In addition to the metacharacters, there are some ASCII characters which don't have printable character equivalents and are instead represented by</source>
          <target state="translated">메타 문자 외에도 인쇄 가능한 문자가없는 ASCII 문자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="08676326b07558d72976a15d2e5ea67b5354d4ab" translate="yes" xml:space="preserve">
          <source>In addition to the perl API described above, a C API is available for extension writers. The following C functions are available in the modglobal hash:</source>
          <target state="translated">위에서 설명한 perl API 외에도 확장 작성기에 C API를 사용할 수 있습니다. modglobal 해시에서 다음 C 함수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef88c015cd90a62555639afdea15aa945900339f" translate="yes" xml:space="preserve">
          <source>In addition to the quote delimiters &lt;code&gt;'&lt;/code&gt;, &lt;code&gt;&quot;&lt;/code&gt;, and &lt;code&gt;`&lt;/code&gt;, full Perl quote-like quoting (i.e. q{string}, qq{string}, etc) can be specified by including the letter 'q' as a delimiter. Hence:</source>
          <target state="translated">따옴표 구분자 &lt;code&gt;'&lt;/code&gt; , &lt;code&gt;&quot;&lt;/code&gt; 및 &lt;code&gt;`&lt;/code&gt; 외에도, 문자'q '를 구분 기호로 포함하여 전체 Perl 따옴표와 같은 인용 (예 : q {string}, qq {string} 등)을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ee26c7c2937194436d9d08c9a82ea42e06abcd1" translate="yes" xml:space="preserve">
          <source>In addition to the six exported functions there exists one function that can only be accessed with a fully qualified function call.</source>
          <target state="translated">6 개의 내 보낸 함수 외에도 정규화 된 함수 호출로만 액세스 할 수있는 하나의 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fd0fd0dfb0a01af1b34dd0a74cf43897f0a81ea" translate="yes" xml:space="preserve">
          <source>In addition to the tie() interface, it is also possible to access most of the functions provided in the Berkeley DB API directly. See &lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;THE API INTERFACE&lt;/a&gt;.</source>
          <target state="translated">tie () 인터페이스 외에도 Berkeley DB API에서 제공하는 대부분의 기능에 직접 액세스 할 수도 있습니다. &lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;API 인터페이스를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="53b1ffa79f559c5952d0b2eca922c0eb1fe018a7" translate="yes" xml:space="preserve">
          <source>In addition to the traditional Perl default MRO (depth first search, called &lt;code&gt;DFS&lt;/code&gt; here), Perl now offers the C3 MRO as well. Perl's support for C3 is based on the work done in Stevan Little's module &lt;a href=&quot;http://search.cpan.org/perldoc/Class::C3&quot;&gt;Class::C3&lt;/a&gt;, and most of the C3-related documentation here is ripped directly from there.</source>
          <target state="translated">기존 Perl 기본 MRO ( 여기서는 &lt;code&gt;DFS&lt;/code&gt; 라고하는 깊이있는 첫 번째 검색 ) 외에도 이제 C3 MRO도 제공합니다. C3에 대한 Perl의 지원은 Stevan Little의 모듈 &lt;a href=&quot;http://search.cpan.org/perldoc/Class::C3&quot;&gt;Class :: C3&lt;/a&gt; 에서 수행 된 작업을 기반으로하며 여기에서 대부분의 C3 관련 문서는 직접 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="8eca212407dc344e58d9927ac55df67e502679ba" translate="yes" xml:space="preserve">
          <source>In addition to the two arrays that form the inversion map, &lt;code&gt;prop_invmap&lt;/code&gt; returns two other values; one is a scalar that gives some details as to the format of the entries of the map array; the other is a default value, useful in maps whose format name begins with the letter &lt;code&gt;&quot;a&quot;&lt;/code&gt; , as described &lt;a href=&quot;#a&quot;&gt;below in its subsection&lt;/a&gt;; and for specialized purposes, such as converting to another data structure, described at the end of this main section.</source>
          <target state="translated">반전 맵을 구성하는 두 배열 외에도 &lt;code&gt;prop_invmap&lt;/code&gt; 은 다른 두 값을 반환합니다. 하나는 맵 배열의 항목 형식에 대한 세부 사항을 제공하는 스칼라입니다. 다른 하나는 기본 값으로, &lt;a href=&quot;#a&quot;&gt;아래 하위 섹션에서&lt;/a&gt; 설명하는 것처럼 형식 이름이 문자 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 로 시작하는 맵에 유용합니다 . 이 주요 섹션의 끝에 설명 된 다른 데이터 구조로 변환하는 것과 같은 특수한 목적을 위해.</target>
        </trans-unit>
        <trans-unit id="dab2897e25695e7867181ff90ba23794c8c60c0d" translate="yes" xml:space="preserve">
          <source>In addition to using the &lt;code&gt;\p{Blk=...}&lt;/code&gt; and &lt;code&gt;\P{Blk=...}&lt;/code&gt; constructs, you can also test whether a code point is in the</source>
          <target state="translated">&lt;code&gt;\p{Blk=...}&lt;/code&gt; 및 &lt;code&gt;\P{Blk=...}&lt;/code&gt; 구문 을 사용하는 것 외에도 코드 포인트가</target>
        </trans-unit>
        <trans-unit id="dac7bc321eb3333dc44a14f1d9acf1fbd74fd29b" translate="yes" xml:space="preserve">
          <source>In addition to what was matched, Perl also provides the positions of what was matched as contents of the &lt;code&gt;@-&lt;/code&gt; and &lt;code&gt;@+&lt;/code&gt; arrays. &lt;code&gt;$-[0]&lt;/code&gt; is the position of the start of the entire match and &lt;code&gt;$+[0]&lt;/code&gt; is the position of the end. Similarly, &lt;code&gt;$-[n]&lt;/code&gt; is the position of the start of the &lt;code&gt;$n&lt;/code&gt; match and &lt;code&gt;$+[n]&lt;/code&gt; is the position of the end. If &lt;code&gt;$n&lt;/code&gt; is undefined, so are &lt;code&gt;$-[n]&lt;/code&gt; and &lt;code&gt;$+[n]&lt;/code&gt; . Then this code</source>
          <target state="translated">일치하는 것 외에도 Perl은 &lt;code&gt;@-&lt;/code&gt; 및 &lt;code&gt;@+&lt;/code&gt; 배열의 내용으로 일치 된 위치를 제공합니다 . &lt;code&gt;$-[0]&lt;/code&gt; 은 전체 경기의 시작 위치이고 &lt;code&gt;$+[0]&lt;/code&gt; 은 끝의 위치입니다. 마찬가지로 &lt;code&gt;$-[n]&lt;/code&gt; 은 &lt;code&gt;$n&lt;/code&gt; 일치 의 시작 위치 이고 &lt;code&gt;$+[n]&lt;/code&gt; 은 끝의 위치입니다. &lt;code&gt;$n&lt;/code&gt; 이 정의되지 않은 경우 $ &lt;code&gt;$-[n]&lt;/code&gt; 및 &lt;code&gt;$+[n]&lt;/code&gt; 도 정의 됩니다. 그런 다음이 코드</target>
        </trans-unit>
        <trans-unit id="340df59f8245bd9d352756a2f3fe84ca2ba2b14a" translate="yes" xml:space="preserve">
          <source>In addition, Perl defines the following:</source>
          <target state="translated">또한 Perl은 다음을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="7b18dfd70f7fb70cb969c8b7231702490b8ef572" translate="yes" xml:space="preserve">
          <source>In addition, Perl permits the following widely-supported conversions:</source>
          <target state="translated">또한 Perl은 다음과 같이 광범위하게 지원되는 변환을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="58a30b45039ea55ccfbff7c03b534706dd5f4a4e" translate="yes" xml:space="preserve">
          <source>In addition, a second package variable (&lt;code&gt;@Filter::Simple::components&lt;/code&gt; ) contains a list of the various pieces of &lt;code&gt;$_&lt;/code&gt; , as they were originally split up to allow placeholders to be inserted.</source>
          <target state="translated">또한 두 번째 패키지 변수 ( &lt;code&gt;@Filter::Simple::components&lt;/code&gt; )에는 원래 &lt;code&gt;$_&lt;/code&gt; 자리 표시자를 삽입하기 위해 분할 된 다양한 $ _ 조각 목록이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b824cddab0454f6fa746f5f5efb2df055e6a062" translate="yes" xml:space="preserve">
          <source>In addition, an attempt is made to recognize several common Unix library names, and filter them out or convert them to their VMS equivalents, as appropriate.</source>
          <target state="translated">또한 여러 공통 Unix 라이브러리 이름을 인식하고이를 필터링하거나 해당하는 VMS로 변환하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="20f0764c130ac7b7bb4ff76a14f2a6cf3a71b811" translate="yes" xml:space="preserve">
          <source>In addition, if &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a simple filename, the default values for the &lt;code&gt;Name&lt;/code&gt; , &lt;code&gt;Time&lt;/code&gt; , &lt;code&gt;TextFlag&lt;/code&gt; , &lt;code&gt;ExtAttr&lt;/code&gt; , &lt;code&gt;exUnixN&lt;/code&gt; and &lt;code&gt;exTime&lt;/code&gt; options will be sourced from that file.</source>
          <target state="translated">또한 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 가 간단한 파일 이름 인 경우 &lt;code&gt;Name&lt;/code&gt; , &lt;code&gt;Time&lt;/code&gt; , &lt;code&gt;TextFlag&lt;/code&gt; , &lt;code&gt;ExtAttr&lt;/code&gt; , &lt;code&gt;exUnixN&lt;/code&gt; 및 &lt;code&gt;exTime&lt;/code&gt; 옵션의 기본값 이 해당 파일에서 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="bdc3e8410e98f27c3f135fcd34c0e133beddff18" translate="yes" xml:space="preserve">
          <source>In addition, if &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a simple filename, the default values for the &lt;code&gt;Name&lt;/code&gt; and &lt;code&gt;Time&lt;/code&gt; options will be sourced from that file.</source>
          <target state="translated">또한 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 가 간단한 파일 이름 인 경우 &lt;code&gt;Name&lt;/code&gt; 및 &lt;code&gt;Time&lt;/code&gt; 옵션 의 기본값 이 해당 파일에서 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="91ed0a2f179c5ac2d45e1e913820f71e61b32911" translate="yes" xml:space="preserve">
          <source>In addition, if the input file/buffer does contain compressed data and there is non-compressed data immediately following it, setting this option will make this module treat the whole file/buffer as a single data stream.</source>
          <target state="translated">또한 입력 파일 / 버퍼에 압축 된 데이터가 있고 그 뒤에 바로 압축되지 않은 데이터가있는 경우이 옵션을 설정하면이 모듈이 전체 파일 / 버퍼를 단일 데이터 스트림으로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="a03250cf8d36596835773013a7ed159131abe9f9" translate="yes" xml:space="preserve">
          <source>In addition, on failure in</source>
          <target state="translated">또한 고장시</target>
        </trans-unit>
        <trans-unit id="289227a7d3ba6bcbce57645ed49463f1d7e46764" translate="yes" xml:space="preserve">
          <source>In addition, other &lt;a href=&quot;getopt/long&quot;&gt;Getopt::Long&lt;/a&gt; error messages may result from invalid command-line options.</source>
          <target state="translated">또한 다른 &lt;a href=&quot;getopt/long&quot;&gt;Getopt :: Long&lt;/a&gt; 오류 메시지는 잘못된 명령 줄 옵션으로 인해 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="147a39b11e58c10277c6a279d8224a769b9bb498" translate="yes" xml:space="preserve">
          <source>In addition, output may be piped to a subprocess, using the character '|'. Anything after this character on the command line is passed to a subprocess for execution; the subprocess takes the output of Perl as its input.</source>
          <target state="translated">또한 문자 '|'를 사용하여 출력을 하위 프로세스로 파이프 할 수 있습니다. 명령 행에서이 문자 다음에 나오는 것은 실행을 위해 서브 프로세스로 전달됩니다. 서브 프로세스는 Perl의 출력을 입력으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="99121fa175239d30527a66db54352aec9e7f4845" translate="yes" xml:space="preserve">
          <source>In addition, plenty of code in the wild does all of its OO &quot;by hand&quot;, using just the Perl built-in OO features. If you need to maintain such code, you should read &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; to understand exactly how Perl's built-in OO works.</source>
          <target state="translated">또한, Perl에 내장 된 OO 기능 만 사용하여 모든 OO를 &quot;수동으로&quot;수행하는 코드가 많이 있습니다. 이러한 코드를 유지 관리해야하는 경우 &lt;a href=&quot;perlobj&quot;&gt;Perlobj&lt;/a&gt; 를 읽고 Perl의 기본 제공 OO 작동 방식을 정확하게 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="df2c5f9f6d74347865f1b7d8c718b9166dce24c6" translate="yes" xml:space="preserve">
          <source>In addition, subroutines are named with an initial '&amp;amp;', though this is optional when unambiguous, just as the word &quot;do&quot; is often redundant in English. Symbol table entries can be named with an initial '*', but you don't really care about that yet (if ever :-).</source>
          <target state="translated">또한 서브 루틴은 초기 '&amp;amp;'로 이름이 지정되지만 &quot;do&quot;라는 단어가 영어로 중복되는 경우와 같이 모호하지 않은 경우에는 선택 사항입니다. 심볼 테이블 항목은 초기 '*'로 이름을 지정할 수 있지만 실제로는 신경 쓰지 않습니다 (언제나 :-).</target>
        </trans-unit>
        <trans-unit id="e4639b7e9ac66cd60ee8c3525c4580bbed98b234" translate="yes" xml:space="preserve">
          <source>In addition, the generated &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine passes its own argument list to the filtering subroutine, so the BANG.pm filter could easily be made parametric:</source>
          <target state="translated">또한 생성 된 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 서브 루틴은 자체 인수 목록을 필터링 서브 루틴으로 전달하므로 BANG.pm 필터를 쉽게 매개 변수화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e36eb4b4d16be01e13411f12c4f853328d8d124" translate="yes" xml:space="preserve">
          <source>In addition, the returned value will be unique within the context of the Pod::Simple::XHTML object unless a second argument is passed a true value. ID attributes should always be unique within a single XHTML document, but pass the true value if you are creating not an ID but a URL hash to point to an ID (i.e., if you need to put the &quot;#foo&quot; in &lt;code&gt;&amp;lt;a href=&quot;#foo&quot;&amp;gt;foo&amp;lt;/a&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">또한 두 번째 인수에 true 값이 전달되지 않으면 반환 된 값은 Pod :: Simple :: XHTML 객체의 컨텍스트 내에서 고유합니다. ID 속성은 항상 단일 XHTML 문서 내에서 고유해야하지만 ID가 아닌 ID를 가리키는 URL 해시를 만드는 경우 (예 : &lt;code&gt;&amp;lt;a href=&quot;#foo&quot;&amp;gt;foo&amp;lt;/a&amp;gt;&lt;/code&gt; 에 &quot;#foo&quot;를 넣어야하는 경우) true 값을 전달하십시오. = &quot;# foo&quot;&amp;gt; foo &amp;lt;/a&amp;gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="de0edea48e0434c59597ceff4d726d410f442fce" translate="yes" xml:space="preserve">
          <source>In addition, when ldopts is called with parameters, it will return the argument string rather than print it to STDOUT.</source>
          <target state="translated">또한 ldopts가 매개 변수와 함께 호출되면 인수 문자열을 STDOUT에 인쇄하지 않고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0fe8a6e2911b84e5bf182d375e70d71ebf4dcde5" translate="yes" xml:space="preserve">
          <source>In all Perl versions you can use &lt;code&gt;as_number()&lt;/code&gt; or &lt;code&gt;as_int&lt;/code&gt; for the same effect:</source>
          <target state="translated">모든 Perl 버전 에서 동일한 효과를 위해 &lt;code&gt;as_number()&lt;/code&gt; 또는 &lt;code&gt;as_int&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9a826c545f2fecb5bd50e173dbd7f3d696f12f03" translate="yes" xml:space="preserve">
          <source>In all Perl versions, &lt;code&gt;\s&lt;/code&gt; matches the 5 characters [\t\n\f\r ]; that is, the horizontal tab, the newline, the form feed, the carriage return, and the space. Starting in Perl v5.18, it also matches the vertical tab, &lt;code&gt;\cK&lt;/code&gt; . See note &lt;code&gt;[1]&lt;/code&gt; below for a discussion of this.</source>
          <target state="translated">모든 Perl 버전에서 &lt;code&gt;\s&lt;/code&gt; 는 5 개의 문자 [\ t \ n \ f \ r]와 일치합니다. 즉, 가로 탭, 줄 바꿈, 용지 공급, 캐리지 리턴 및 공백입니다. Perl v5.18부터는 세로 탭 &lt;code&gt;\cK&lt;/code&gt; 와도 일치합니다 . 이에 대한 설명은 아래의 참고 &lt;code&gt;[1]&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="781b45f1e32e901ab32d784bb9ee31c8ef4d8da4" translate="yes" xml:space="preserve">
          <source>In all but the most memory-paranoid configurations (ex: PURIFY), heads and bodies are allocated out of arenas, which by default are approximately 4K chunks of memory parcelled up into N heads or bodies. Sv-bodies are allocated by their sv-type, guaranteeing size consistency needed to allocate safely from arrays.</source>
          <target state="translated">가장 많은 메모리-파라노이드 구성 (예 : PURIFY)을 제외한 모든 헤드와 바디는 경기장에서 할당되며 기본적으로 N 헤드 또는 바디로 소포 된 약 4K의 메모리 청크입니다. Sv-body는 sv 유형으로 할당되므로 배열에서 안전하게 할당하는 데 필요한 크기 일관성을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="82cf0166b1026f5214dc5e9dee6752fb9c70f2f9" translate="yes" xml:space="preserve">
          <source>In all cases shown above, the line indentation shows the call tree. If bit 2 of &lt;code&gt;frame&lt;/code&gt; is set, a line is printed on exit from a subroutine as well. If bit 4 is set, the arguments are printed along with the caller info. If bit 8 is set, the arguments are printed even if they are tied or references. If bit 16 is set, the return value is printed, too.</source>
          <target state="translated">위에 표시된 모든 경우에 줄 들여 쓰기는 호출 트리를 보여줍니다. &lt;code&gt;frame&lt;/code&gt; 비트 2 가 설정되면 서브 루틴에서 나올 때에도 라인이 인쇄됩니다. 비트 4가 설정되면 인수가 호출자 정보와 함께 인쇄됩니다. 비트 8이 설정되면 인수가 묶여 있거나 참조 되더라도 인수가 인쇄됩니다. 비트 16이 설정되면 반환 값도 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="6061ee2ae8dec0f2b671e0d3e14bae7a6b818d83" translate="yes" xml:space="preserve">
          <source>In all cases where the very common phenomenon of quantification (saying &quot;</source>
          <target state="translated">매우 일반적인 정량화 현상 ( &quot;</target>
        </trans-unit>
        <trans-unit id="e3c2c7f74b86dde15a7c489ee7be1789b4697e9f" translate="yes" xml:space="preserve">
          <source>In all dealings with contributed modules, everyone maintaining Perl should keep in mind that the code belongs to the original author, that they may not be on perl5-porters at any given time, and that a patch is not official unless it has been integrated into the author's copy of the module. To aid with this, and with points #1, #2, and #3 above, contact information for the authors of all contributed modules should be kept with the Perl distribution.</source>
          <target state="translated">기여한 모듈을 다룰 때마다 Perl을 유지 관리하는 모든 사람은 코드가 원래 작성자에 속하며 주어진 시간에 perl5 포터에 있지 않을 수 있으며 패치가 통합되지 않은 한 공식적이지 않다는 점을 명심해야합니다. 작성자의 모듈 사본. 이를 지원하고 위의 # 1, # 2 및 # 3 지점을 사용하려면 모든 기여 모듈의 작성자에 대한 연락처 정보를 Perl 배포와 함께 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="9f633a9cd1f1e79fef8f8eaa0a6cfd15cedc67ef" translate="yes" xml:space="preserve">
          <source>In all of the above cases, option values may be inserted in the bundle. For example:</source>
          <target state="translated">위의 모든 경우에 옵션 값이 번들에 삽입 될 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2383a8bd7489fcdd2f83ac67cbbc873796c97eb5" translate="yes" xml:space="preserve">
          <source>In all operations on %ENV, the key string is treated as if it were entirely uppercase, regardless of the case actually specified in the Perl expression.</source>
          <target state="translated">% ENV에 대한 모든 연산에서 키 문자열은 실제로 Perl 표현식에 지정된 대소 문자에 관계없이 완전히 대문자 인 것처럼 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="95b3792cd6f5e2af35835ac883e0e6a53f125114" translate="yes" xml:space="preserve">
          <source>In all the above examples, &lt;code&gt;minus()&lt;/code&gt; is required only to return the result of the subtraction: Perl takes care of the assignment to $x. In fact, such methods should</source>
          <target state="translated">위의 모든 예제에서 &lt;code&gt;minus()&lt;/code&gt; 결과 만 반환하려면 빼기 () 가 필요합니다. Perl은 할당을 $ x로 처리합니다. 실제로 이러한 방법은</target>
        </trans-unit>
        <trans-unit id="97f2c173d7ed4e9aee1d1f9fb64f4d9f9b0ea2fe" translate="yes" xml:space="preserve">
          <source>In all the previous examples I have 'hard-wired' the name of the Perl subroutine to be called from C. Most of the time though, it is more convenient to be able to specify the name of the Perl subroutine from within the Perl script.</source>
          <target state="translated">이전의 모든 예에서 C에서 호출 할 Perl 서브 루틴의 이름을 '하드 와이어드'했습니다. 그러나 대부분 Perl 스크립트 내에서 Perl 서브 루틴의 이름을 지정하는 것이 더 편리합니다. .</target>
        </trans-unit>
        <trans-unit id="aaae17ed6f36eac3220705015e0ea930013f7c8e" translate="yes" xml:space="preserve">
          <source>In all these cases, the user can override this stubborn behaviour by prepending the command with the word force, for example:</source>
          <target state="translated">이 모든 경우에 사용자는 명령에 단어 force를 추가하여이 완고한 동작을 무시할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4cbe02d68ddbd502acef7d9e9916746fae4beca6" translate="yes" xml:space="preserve">
          <source>In almost all cases like this, it's usually a far, far better idea to use the structured control flow mechanisms of &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; instead of resorting to a &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;. For certain applications, the catch and throw pair of &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; and die() for exception processing can also be a prudent approach.</source>
          <target state="translated">이와 같은 거의 모든 경우 에 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 대신에 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; 의 구조적 제어 흐름 메커니즘을 사용하는 것이 일반적으로 훨씬 더 나은 아이디어 입니다. 특정 애플리케이션의 경우 예외 처리를위한 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; 및 die () 의 catch 및 throw 쌍 도 신중한 접근 방법이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cf0558a3828c482ff92b5a9786f51b397db3041" translate="yes" xml:space="preserve">
          <source>In an array context &lt;code&gt;extract_multiple&lt;/code&gt; returns an array of substrings of the original string, as extracted by the specified extractors. In a scalar context, &lt;code&gt;extract_multiple&lt;/code&gt; returns the first substring successfully extracted from the original string. In both scalar and void contexts the original string has the first successfully extracted substring removed from it. In all contexts &lt;code&gt;extract_multiple&lt;/code&gt; starts at the current &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; of the string, and sets that &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; appropriately after it matches.</source>
          <target state="translated">배열 컨텍스트에서 &lt;code&gt;extract_multiple&lt;/code&gt; 은 지정된 추출기에 의해 추출 된 원래 문자열의 하위 문자열 배열을 반환합니다. 스칼라 컨텍스트에서 &lt;code&gt;extract_multiple&lt;/code&gt; 은 원래 문자열에서 성공적으로 추출 된 첫 번째 하위 문자열을 리턴합니다. 스칼라 및 공백 컨텍스트 모두에서 원래 문자열에는 성공적으로 추출 된 첫 번째 부분 문자열이 제거됩니다. 모든 컨텍스트에서 &lt;code&gt;extract_multiple&lt;/code&gt; 은 문자열 의 현재 &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 에서 시작하여 일치 하는 &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 적절하게 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="0bf045366670deb82562441b69ea96760a43c736" translate="yes" xml:space="preserve">
          <source>In an array context the return value is a list containing, the number of articles in the group, the number of the first article, the number of the last article and the group name.</source>
          <target state="translated">배열 컨텍스트에서 반환 값은 그룹의 기사 수, 첫 번째 기사 수, 마지막 기사 수 및 그룹 이름을 포함하는 목록입니다.</target>
        </trans-unit>
        <trans-unit id="5a5982cddd4d8975197c2744da1608d9e4548d41" translate="yes" xml:space="preserve">
          <source>In an array context, returns a list of lines returned from the server. In a scalar context, returns a reference to a list.</source>
          <target state="translated">배열 컨텍스트에서 서버에서 반환 된 행 목록을 반환합니다. 스칼라 컨텍스트에서 목록에 대한 참조를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c41a798a42099e75be11d7d0369af1bc79b214a4" translate="yes" xml:space="preserve">
          <source>In an interpolated literal, whether a double-quoted string or a regex, you may specify a character by its number using the &lt;code&gt;\x{&lt;i&gt;HHHHHH&lt;/i&gt;}&lt;/code&gt; escape.</source>
          <target state="translated">큰 따옴표로 묶은 문자열이든 정규 표현식이든 보간 된 리터럴에서 &lt;code&gt;\x{&lt;i&gt;HHHHHH&lt;/i&gt;}&lt;/code&gt; 이스케이프를 사용하여 숫자로 문자를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4918ab5fdbd686e859250551837a7ee9a52207eb" translate="yes" xml:space="preserve">
          <source>In ancient times, Unix was also used to refer to some code that a couple of people at Bell Labs wrote to make use of a PDP-7 computer that wasn&amp;rsquo;t doing much of anything else at the time.</source>
          <target state="translated">고대에 유닉스는 Bell Labs의 두 사람이 당시에 다른 일을 많이하지 않는 PDP-7 컴퓨터를 사용하기 위해 작성한 일부 코드를 가리키는 데 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="d17b1ed4f6399a33863173b63d7cf4eeef9ce1db" translate="yes" xml:space="preserve">
          <source>In any case do not expect nanosecond resolution, or even a microsecond resolution. Also note that the modify/access timestamps might have different resolutions, and that they need not be synchronized, e.g. if the operations are</source>
          <target state="translated">어쨌든 나노초 해상도 또는 마이크로 초 해상도를 기대하지 마십시오. 또한 수정 / 액세스 타임 스탬프의 해상도가 다를 수 있으며 동기화 할 필요가 없습니다 (예 : 작업이</target>
        </trans-unit>
        <trans-unit id="a2ea48b73fadf70f92647ed4cbbc7d19e3016b8b" translate="yes" xml:space="preserve">
          <source>In any case you will be prompted with the correct invocation of the &lt;code&gt;inst_perl&lt;/code&gt; target that installs the new binary into INSTALLBIN.</source>
          <target state="translated">&lt;code&gt;inst_perl&lt;/code&gt; 새 바이너리를 INSTALLBIN에 설치하는 inst_perl 대상을 올바르게 호출하라는 메시지가 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="416ebb085a2d5e940040c711d2f8d1e17ddebb19" translate="yes" xml:space="preserve">
          <source>In any way, if you're seeing failures beyond those mentioned in this document, please consider upgrading to the latest Hurd before reporting the failure as a bug.</source>
          <target state="translated">어떤 식 으로든이 문서에서 언급 된 것 이외의 오류가 발생하면 오류로보고하기 전에 최신 Hurd로 업그레이드하십시오.</target>
        </trans-unit>
        <trans-unit id="86069d4fc266f927b18d767a1cba7026af51c3e5" translate="yes" xml:space="preserve">
          <source>In array context returns a two-element array with the seconds and microseconds since the epoch. In scalar context returns floating seconds like &lt;code&gt;Time::HiRes::time()&lt;/code&gt; (see below).</source>
          <target state="translated">배열 컨텍스트에서 에포크 (epoch) 이후 초와 마이크로 초를 갖는 2 요소 배열을 리턴합니다. 스칼라 컨텍스트에서 &lt;code&gt;Time::HiRes::time()&lt;/code&gt; 과 같은 부동 초를 반환합니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="16582d55b272e81d53e1e61c0aba11a653333faf" translate="yes" xml:space="preserve">
          <source>In between two &lt;b&gt;subscripts&lt;/b&gt;, the arrow is optional.</source>
          <target state="translated">두 &lt;b&gt;첨자&lt;/b&gt; 사이 에서 화살표는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="e15bc0bc69692882714387f5e16ad85b014d51b1" translate="yes" xml:space="preserve">
          <source>In block mode, &lt;code&gt;filter_read&lt;/code&gt; will append a block of data which is &amp;lt;= &lt;code&gt;$size&lt;/code&gt; to the end of the &lt;code&gt;$_&lt;/code&gt; scalar. It is important to emphasise the that &lt;code&gt;filter_read&lt;/code&gt; will not necessarily read a block which is</source>
          <target state="translated">블록 모드에서 &lt;code&gt;filter_read&lt;/code&gt; 는 &lt;code&gt;$_&lt;/code&gt; 스칼라 끝에 &amp;lt;= &lt;code&gt;$size&lt;/code&gt; 인 데이터 블록을 추가합니다 . &lt;code&gt;filter_read&lt;/code&gt; 가 반드시 블록을 읽을 필요는 없다는 것을 강조하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="86311b9447535cd22a0807e557574828944f0087" translate="yes" xml:space="preserve">
          <source>In bootstrapping situations it is usually sufficient to translate only a few YAML files to Data::Dumper for crucial modules like &lt;code&gt;YAML::Syck&lt;/code&gt; , &lt;code&gt;YAML.pm&lt;/code&gt; and &lt;code&gt;Expect.pm&lt;/code&gt; . If you prefer Storable over Data::Dumper, remember to pull out a Storable version that writes an older format than all the other Storable versions that will need to read them.</source>
          <target state="translated">부트 스트랩 상황에서는 일반적으로 &lt;code&gt;YAML::Syck&lt;/code&gt; , &lt;code&gt;YAML.pm&lt;/code&gt; 및 &lt;code&gt;Expect.pm&lt;/code&gt; 과 같은 중요한 모듈의 경우 일부 YAML 파일 만 Data :: Dumper로 변환하면 충분합니다 . Data :: Dumper보다 Storable을 선호하는 경우이를 읽어야하는 다른 모든 Storable 버전보다 오래된 형식을 작성하는 Storable 버전을 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="7d32bdf3cfc0bcbd8616099443aea4c2f02bae5f" translate="yes" xml:space="preserve">
          <source>In both cases this should only be considered to be a temporary measure - you should upgrade to the later version of perl as soon as is practicable.</source>
          <target state="translated">두 경우 모두 이는 일시적인 조치로만 간주되어야합니다. 가능한 한 빨리 최신 버전의 perl로 업그레이드해야합니다.</target>
        </trans-unit>
        <trans-unit id="d2a841147fc72cc4482e0a7e84067a22e8db15fe" translate="yes" xml:space="preserve">
          <source>In both cases, if you want access to the original, unaltered routine, use the &lt;code&gt;CORE::&lt;/code&gt; prefix:</source>
          <target state="translated">두 경우 모두 변경되지 않은 원래 루틴에 액세스하려면 &lt;code&gt;CORE::&lt;/code&gt; 접 두부를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3b49d045d120cddc991a05308fecf5d02438bfd9" translate="yes" xml:space="preserve">
          <source>In both cases, it is strongly recommended that you use these flags when you run Configure. If you do not use do this, but later answer the questions about 64-bit numbers when Configure asks you, you may get a configuration that cannot be compiled, or that does not function as expected.</source>
          <target state="translated">두 경우 모두 Configure를 실행할 때이 플래그를 사용하는 것이 좋습니다. 사용하지 않지만 나중에 Configure에서 요청할 때 64 비트 숫자에 대한 질문에 대답하면 컴파일 할 수 없거나 예상대로 작동하지 않는 구성이 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28f5f411ebc893dbf219e8f06f5338fdd368072e" translate="yes" xml:space="preserve">
          <source>In both forms, the value returned is the value of the last expression evaluated inside the mini-program; a return statement may be also used, just as with subroutines. The expression providing the return value is evaluated in void, scalar, or list context, depending on the context of the &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; itself. See &lt;a href=&quot;wantarray&quot;&gt;wantarray&lt;/a&gt; for more on how the evaluation context can be determined.</source>
          <target state="translated">두 형식 모두에서 반환 된 값은 미니 프로그램 내에서 평가 된 마지막 식의 값입니다. 서브 루틴과 마찬가지로 리턴 문도 사용할 수 있습니다. 반환 값을 제공하는 식은 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 자체 의 컨텍스트에 따라 void, 스칼라 또는 목록 컨텍스트에서 평가 됩니다. 평가 컨텍스트를 결정하는 방법에 대한 자세한 내용은 &lt;a href=&quot;wantarray&quot;&gt;wantarray&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4a7857febf47f6d9d7d4d6147004e7ae7af4e0b5" translate="yes" xml:space="preserve">
          <source>In both forms, the value returned is the value of the last expression evaluated inside the mini-program; a return statement may be also used, just as with subroutines. The expression providing the return value is evaluated in void, scalar, or list context, depending on the context of the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; itself. See &lt;a href=&quot;#wantarray&quot;&gt;wantarray&lt;/a&gt; for more on how the evaluation context can be determined.</source>
          <target state="translated">두 형식 모두에서 반환 된 값은 미니 프로그램 내에서 평가 된 마지막 식의 값입니다. 서브 루틴과 마찬가지로 리턴 문도 사용할 수 있습니다. 반환 값을 제공하는 식은 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 자체 의 컨텍스트에 따라 void, 스칼라 또는 목록 컨텍스트에서 평가 됩니다. 평가 컨텍스트를 결정하는 방법에 대한 자세한 내용은 &lt;a href=&quot;#wantarray&quot;&gt;wantarray&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c9f62f445147592772dba8cf7d0b7f085f6d5d1f" translate="yes" xml:space="preserve">
          <source>In both last cases, the last expression is evaluated in the context that was applied to the &lt;code&gt;given&lt;/code&gt; block.</source>
          <target state="translated">마지막 두 경우 모두 마지막 블록 은 &lt;code&gt;given&lt;/code&gt; 블록 에 적용된 컨텍스트에서 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="faca50452b363bafe8294bb759677cc9d971a027" translate="yes" xml:space="preserve">
          <source>In both the case of unquoted command line arguments or in calls to &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob()&lt;/a&gt;&lt;/code&gt; VMS wildcard expansion is performed. (csh-style wildcard expansion is available if you use &lt;code&gt;File::Glob::glob&lt;/code&gt; .) If the wildcard filespec contains a device or directory specification, then the resultant filespecs will also contain a device and directory; otherwise, device and directory information are removed. VMS-style resultant filespecs will contain a full device and directory, while Unix-style resultant filespecs will contain only as much of a directory path as was present in the input filespec. For example, if your default directory is Perl_Root:[000000], the expansion of &lt;code&gt;[.t]*.*&lt;/code&gt; will yield filespecs like &quot;perl_root:[t]base.dir&quot;, while the expansion of &lt;code&gt;t/*/*&lt;/code&gt; will yield filespecs like &quot;t/base.dir&quot;. (This is done to match the behavior of glob expansion performed by Unix shells.)</source>
          <target state="translated">인용되지 않은 명령 행 인수의 경우 또는 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob()&lt;/a&gt;&lt;/code&gt; VMS 와일드 카드 확장의 경우 모두 수행됩니다. ( &lt;code&gt;File::Glob::glob&lt;/code&gt; 를 사용하는 경우 csh 스타일 와일드 카드 확장을 사용할 수 있습니다 .) 와일드 카드 파일 스펙에 디바이스 또는 디렉토리 스펙이 포함 된 경우 결과 파일 스펙에도 디바이스 및 디렉토리가 포함됩니다. 그렇지 않으면 장치 및 디렉토리 정보가 제거됩니다. VMS 스타일 결과 파일 사양에는 전체 장치 및 디렉토리가 포함되지만 Unix 스타일 결과 파일 사양에는 입력 파일 사양에 존재했던만큼의 디렉토리 경로 만 포함됩니다. 예를 들어, 기본 디렉토리가 Perl_Root : [000000] 인 경우 &lt;code&gt;[.t]*.*&lt;/code&gt; 의 확장은 &quot;perl_root : [t] base.dir&quot;과 같은 파일 스펙을 생성하지만 &lt;code&gt;t/*/*&lt;/code&gt; 의 확장은&quot;t / base.dir&quot;과 같은 파일 스펙을 생성합니다. (이것은 Unix 쉘이 수행하는 glob 확장의 동작과 일치시키기 위해 수행됩니다.)</target>
        </trans-unit>
        <trans-unit id="7acbdc4bab7e93326f2e293e78aa137135b956f7" translate="yes" xml:space="preserve">
          <source>In both these examples, the character being matched is non-Unicode, so Unicode doesn't define how it should match. It clearly isn't an ASCII hex digit, so the first example clearly should fail, and so it does, with no warning. But it is arguable that the second example should have an undefined, hence &lt;code&gt;FALSE&lt;/code&gt; , result. So a warning is raised for it.</source>
          <target state="translated">이 두 예제에서 일치하는 문자는 유니 코드가 아니므로 유니 코드는 일치하는 방법을 정의하지 않습니다. 분명히 ASCII 16 진수가 아니므로 첫 번째 예는 경고없이 실패해야합니다. 그러나 두 번째 예제는 정의되지 않은 &lt;code&gt;FALSE&lt;/code&gt; 결과 를 가져야한다는 것은 논쟁의 여지가 있습니다. 따라서 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9f0223354df20f59a567232c3197191e5bff5d52" translate="yes" xml:space="preserve">
          <source>In both usages of the autosplitter, only subroutines defined following the perl</source>
          <target state="translated">자동 스플리터의 두 가지 용도 모두에서 perl 다음에 정의 된 서브 루틴 만</target>
        </trans-unit>
        <trans-unit id="e541d9732ad7ef01278201444dc42735718b9c21" translate="yes" xml:space="preserve">
          <source>In case of L&amp;lt;...&amp;gt; codes with no &quot;text|&quot; part in them, older formatters have exhibited great variation in actually displaying the link or cross reference. For example, L&amp;lt;crontab(5)&amp;gt; would render as &quot;the &lt;code&gt;crontab(5)&lt;/code&gt; manpage&quot;, or &quot;in the &lt;code&gt;crontab(5)&lt;/code&gt; manpage&quot; or just &quot;&lt;code&gt;crontab(5)&lt;/code&gt; &quot;.</source>
          <target state="translated">&quot;text |&quot;가없는 L &amp;lt;...&amp;gt; 코드의 경우 그들 중 일부에서, 오래된 포매터는 실제로 링크 또는 상호 참조를 표시하는 데 큰 변화를 보였다. 예를 들어, L &amp;lt;crontab (5)&amp;gt;는 &quot; &lt;code&gt;crontab(5)&lt;/code&gt; 맨 페이지&quot;또는 &quot; &lt;code&gt;crontab(5)&lt;/code&gt; 맨 페이지&quot;또는 &quot; &lt;code&gt;crontab(5)&lt;/code&gt; &quot; 로 렌더링됩니다 .</target>
        </trans-unit>
        <trans-unit id="365d296ccf4014f926ba35dfa5ea9a2c360d66e7" translate="yes" xml:space="preserve">
          <source>In case of doubt, insert the following statement in front of your Perl program:</source>
          <target state="translated">의심스러운 경우 Perl 프로그램 앞에 다음 명령문을 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="dfdb2521cd21a1ef333094706d67bdf22192a8cc" translate="yes" xml:space="preserve">
          <source>In case the advice in this guide has been updated recently, read the latest version directly from the perl source:</source>
          <target state="translated">이 안내서의 권고 사항이 최근에 업데이트 된 경우, perl 소스에서 직접 최신 버전을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="23c62db8a34f2416b1d1b03ee56f5f1471c6e5f5" translate="yes" xml:space="preserve">
          <source>In case the result of one operation has more digits than specified, it is rounded. The rounding mode taken is either the default mode, or the one supplied to the operation after the</source>
          <target state="translated">하나의 연산 결과에 지정된 것보다 많은 숫자가있는 경우 반올림됩니다. 반올림 모드는 기본 모드이거나 이후에 작업에 제공된 모드입니다.</target>
        </trans-unit>
        <trans-unit id="4ff81268a14bba4a99da29ff2559bdaaf817ec79" translate="yes" xml:space="preserve">
          <source>In case you can choose between running a Makefile.PL or a Build.PL, which installer would you prefer (EUMM or MB or RAND)?</source>
          <target state="translated">Makefile.PL 또는 Build.PL 실행 중에서 선택할 수있는 경우 어떤 설치 프로그램을 선호합니까 (EUMM 또는 MB 또는 RAND)?</target>
        </trans-unit>
        <trans-unit id="4bcc550b219bf3be3a6806897874d6bb2e99f2b2" translate="yes" xml:space="preserve">
          <source>In case you're not familiar with the &quot;regular&quot; Version 8 regex routines, here are the pattern-matching rules not described above.</source>
          <target state="translated">&quot;일반&quot;버전 8 정규식 루틴에 익숙하지 않은 경우 위에서 설명하지 않은 패턴 일치 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="62dab9a7c702990dbb833dc9d9dafc87377a09a8" translate="yes" xml:space="preserve">
          <source>In cases of exceptionally aberrant documents, Pod parsers may abort the parse. Even then, using &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;ing/&lt;code&gt;croak&lt;/code&gt; ing is to be avoided; where possible, the parser library may simply close the input file and add text like &quot;*** Formatting Aborted ***&quot; to the end of the (partial) in-memory document.</source>
          <target state="translated">예외적으로 비정상적인 문서의 경우 포드 파서는 파싱을 중단 할 수 있습니다. 그렇다하더라도, 사용 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; ING / &lt;code&gt;croak&lt;/code&gt; ING 피해야한다; 가능한 경우 파서 라이브러리는 입력 파일을 닫고 (부분적인) 메모리 내 문서의 끝에 &quot;*** Formatting Aborted ***&quot;와 같은 텍스트를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59b86d710288939d8eb974b61f2bbf30d7a131a6" translate="yes" xml:space="preserve">
          <source>In cases where get_title can't find the title, it will return empty-string (&quot;&quot;).</source>
          <target state="translated">get_title이 제목을 찾을 수없는 경우 빈 문자열 ( &quot;&quot;)을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8bf9664b1f4d1fbea5b6e435c9a6c227eff0e2f3" translate="yes" xml:space="preserve">
          <source>In certain cases, the OS-level handles created by the pipe(), socket(), and accept() operators are apparently not duplicated accurately in pseudo-processes. This only happens in some situations, but where it does happen, it may result in deadlocks between the read and write ends of pipe handles, or inability to send or receive data across socket handles.</source>
          <target state="translated">경우에 따라 pipe (), socket () 및 accept () 연산자로 작성된 OS 레벨 핸들은 의사 프로세스에서 정확하게 복제되지 않습니다. 이는 일부 상황에서만 발생하지만 발생하는 경우 파이프 핸들의 읽기 및 쓰기 끝 사이에 교착 상태가 발생하거나 소켓 핸들을 통해 데이터를 보내거나받을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f0057891cced8b178aba4808a03218c5201e0280" translate="yes" xml:space="preserve">
          <source>In certain systems, the operating system's locale support is broken and cannot be fixed or used by Perl. Such deficiencies can and will result in mysterious hangs and/or Perl core dumps when &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect. When confronted with such a system, please report in excruciating detail to &amp;lt;</source>
          <target state="translated">특정 시스템에서 운영 체제의 로케일 지원이 중단되어 Perl에서 수정하거나 사용할 수 없습니다. 이러한 결함은 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용시&lt;/a&gt; 신비한 정지 및 / 또는 Perl 코어 덤프 를 초래할 수 있습니다. 이러한 시스템에 직면 한 경우 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="60c7a29f6dd0bd0c499c2a79f889945240814e67" translate="yes" xml:space="preserve">
          <source>In code that currently says &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader; @ISA = qw(AutoLoader);&lt;/code&gt; you should remove AutoLoader from @ISA and change &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader 'AUTOLOAD';&lt;/code&gt; .</source>
          <target state="translated">현재 코드에서 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader; @ISA = qw(AutoLoader);&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용하십시오&lt;/a&gt; . @ISA = qw (오토로더); @ISA에서 AutoLoader를 제거하고 AutoLoader &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader;&lt;/code&gt; 변경해야합니다 . &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader 'AUTOLOAD';&lt;/code&gt; 를 &lt;a href=&quot;functions/use&quot;&gt;사용하려면&lt;/a&gt; ; .</target>
        </trans-unit>
        <trans-unit id="b746a74a7b045be066091fe7c51bf38b893c45a1" translate="yes" xml:space="preserve">
          <source>In comparison to the standard implementation where the object is a hash and the fields correspond to hash keys, here the fields correspond to hashes, and the object determines the hash key. Thus the hashes appear to be turned</source>
          <target state="translated">객체가 해시이고 필드가 해시 키에 해당하는 표준 구현과 비교할 때 여기서 필드는 해시에 해당하며 객체는 해시 키를 결정합니다. 따라서 해시는 뒤집힌 것처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="402b2ae815c1f3f49820717ee0f679511f29fbf5" translate="yes" xml:space="preserve">
          <source>In connection with &lt;code&gt;b&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; simply adds bits, and this can be put to good use to count set bits efficiently:</source>
          <target state="translated">관련하여 &lt;code&gt;b&lt;/code&gt; 또는 &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; 는 단순히 비트를 추가하고,이 효율적 비트 세트를 계산하는 어법 될 수있다 :</target>
        </trans-unit>
        <trans-unit id="ed09b7a66d2eaa93bbb9724cd18388dac9e53c52" translate="yes" xml:space="preserve">
          <source>In consequence, if two or more classes want to access an object they</source>
          <target state="translated">결과적으로 둘 이상의 클래스가 객체에 액세스하려는 경우</target>
        </trans-unit>
        <trans-unit id="f69c1a7795cd05f1f7a1c806e629e11c671e5598" translate="yes" xml:space="preserve">
          <source>In contrast, &lt;code&gt;\b{...}&lt;/code&gt; and &lt;code&gt;\B{...}&lt;/code&gt; may or may not match at the beginning and end of the line, depending on the boundary type. These implement the Unicode default boundaries, specified in &lt;a href=&quot;http://www.unicode.org/reports/tr29/&quot;&gt;http://www.unicode.org/reports/tr29/&lt;/a&gt;. The boundary types currently available are:</source>
          <target state="translated">반대로 &lt;code&gt;\b{...}&lt;/code&gt; 및 &lt;code&gt;\B{...}&lt;/code&gt; 는 경계 유형에 따라 줄의 시작과 끝에서 일치하거나 일치하지 않을 수 있습니다. 이들은 &lt;a href=&quot;http://www.unicode.org/reports/tr29/&quot;&gt;http://www.unicode.org/reports/tr29/에&lt;/a&gt; 지정된 유니 코드 기본 경계를 구현합니다 . 현재 사용 가능한 경계 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="01521aaa27588449bcad287436418e3fa90af89f" translate="yes" xml:space="preserve">
          <source>In contrast, INSTALL_BASE has predictable, easy to explain installation locations. Now that Module::Build and MakeMaker both have INSTALL_BASE there is little reason to use PREFIX other than to preserve your existing installation locations. If you are starting a fresh Perl installation we encourage you to use INSTALL_BASE. If you have an existing installation installed via PREFIX, consider moving it to an installation structure matching INSTALL_BASE and using that instead.</source>
          <target state="translated">반대로 INSTALL_BASE에는 예측 가능하고 설명이 쉬운 설치 위치가 있습니다. 이제 Module :: Build 및 MakeMaker에 INSTALL_BASE가 있으므로 기존 설치 위치를 유지하는 것 외에 PREFIX를 사용해야 할 이유가 거의 없습니다. 새로 Perl 설치를 시작하는 경우 INSTALL_BASE를 사용하는 것이 좋습니다. PREFIX를 통해 기존 설치가 설치된 경우 INSTALL_BASE와 일치하는 설치 구조로 이동하고 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b83a5099aeab352d7a9903a13c782e0d912d2e78" translate="yes" xml:space="preserve">
          <source>In contrast, hard references are more like hard links in a Unix file system: They are used to access an underlying object without concern for what its (other) name is. When the word &quot;reference&quot; is used without an adjective, as in the following paragraph, it is usually talking about a hard reference.</source>
          <target state="translated">반대로 하드 참조는 유닉스 파일 시스템의 하드 링크와 비슷합니다. 다른 참조 이름에 관계없이 기본 개체에 액세스하는 데 사용됩니다. 다음 단락과 같이 형용사없이 &quot;참조&quot;라는 단어를 사용하는 경우 일반적으로 어려운 참조에 대해 이야기합니다.</target>
        </trans-unit>
        <trans-unit id="4fefb1775bf2d6d801dc0e18387b980f80b2a1f8" translate="yes" xml:space="preserve">
          <source>In contrast, modules in the</source>
          <target state="translated">대조적으로</target>
        </trans-unit>
        <trans-unit id="d9d8046b6af82f0d0498eb1133f08ab96606ff69" translate="yes" xml:space="preserve">
          <source>In corporate life, to grant official approval to a thing, as in, &amp;ldquo;The VP of Engineering has blessed our WebCruncher project.&amp;rdquo; Similarly, in Perl, to grant official approval to a &lt;b&gt;referent&lt;/b&gt; so that it can function as an &lt;b&gt;object&lt;/b&gt;, such as a WebCruncher object. See the &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo;.</source>
          <target state="translated">기업 생활에서&amp;ldquo;엔지니어링 부사장이 WebCruncher 프로젝트를 축복했습니다. 이와 유사하게, Perl로하는 공식적인 승인을 부여하는 &lt;b&gt;지시 대상을&lt;/b&gt; 그것이로 작동 할 수 있도록 &lt;b&gt;객체&lt;/b&gt; 와 같은 WebCruncher 개체로. 낙타 27 장 &quot;기능&quot; 의 &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 기능을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d9b2433b690bbfb6a8d4a6c1783fb717c5f969db" translate="yes" xml:space="preserve">
          <source>In deep binding, lexical variables mentioned in anonymous subroutines are the same ones that were in scope when the subroutine was created. In shallow binding, they are whichever variables with the same names happen to be in scope when the subroutine is called. Perl always uses deep binding of lexical variables (i.e., those created with my()). However, dynamic variables (aka global, local, or package variables) are effectively shallowly bound. Consider this just one more reason not to use them. See the answer to &lt;a href=&quot;#What's-a-closure%3f&quot;&gt;What's a closure?&lt;/a&gt;.</source>
          <target state="translated">깊은 바인딩에서 익명 서브 루틴에 언급 된 어휘 변수는 서브 루틴이 작성 될 때 범위에 있던 것과 동일합니다. 얕은 바인딩에서는 서브 루틴이 호출 될 때 동일한 이름을 가진 변수가 범위 내에있는 것입니다. Perl은 항상 어휘 변수 (즉, my ()로 작성된 변수)의 딥 바인딩을 사용합니다. 그러나 동적 변수 (일명 글로벌, 로컬 또는 패키지 변수)는 사실상 얕은 범위에 속합니다. 이것을 사용하지 않는 또 하나의 이유를 고려하십시오. &lt;a href=&quot;#What's-a-closure%3f&quot;&gt;폐쇄 란 무엇입니까?에&lt;/a&gt; 대한 답변을 참조하십시오 . .</target>
        </trans-unit>
        <trans-unit id="20fadc3ec5ca97e1da30f076e8b9de4f5b9c66b4" translate="yes" xml:space="preserve">
          <source>In directories where either &lt;code&gt;Makefile.PL&lt;/code&gt; or &lt;code&gt;Build.PL&lt;/code&gt; exist, &lt;code&gt;perldoc&lt;/code&gt; will add &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;lib&lt;/code&gt; first to its search path, and as long as you're not the superuser will add &lt;code&gt;blib&lt;/code&gt; too. This is really helpful if you're working inside of a build directory and want to read through the docs even if you have a version of a module previously installed.</source>
          <target state="translated">&lt;code&gt;Makefile.PL&lt;/code&gt; 또는 &lt;code&gt;Build.PL&lt;/code&gt; 이 존재하는 디렉토리에 &lt;code&gt;perldoc&lt;/code&gt; 이 추가 &lt;code&gt;.&lt;/code&gt; 그리고 &lt;code&gt;lib&lt;/code&gt; 는 검색 경로로 먼저 가고, 수퍼 유저가 아닌 한 &lt;code&gt;blib&lt;/code&gt; 도 추가 합니다. 이것은 빌드 디렉토리 내부에서 작업 중이고 이전에 설치된 모듈 버전이 있어도 문서를 읽고 싶을 때 정말 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b98ec9678a77351791b177991b84c25fc1205921" translate="yes" xml:space="preserve">
          <source>In each of the following groups, there may be many more constants provided than just the ones given as examples in the section heading. If the heading ends &lt;code&gt;...&lt;/code&gt; then this means there are likely more; the exact constants provided will depend on the OS and headers found at compile-time.</source>
          <target state="translated">다음의 각 그룹에는 섹션 제목의 예제로 제공된 것보다 더 많은 상수가 제공 될 수 있습니다. 제목이 끝나면 &lt;code&gt;...&lt;/code&gt; 더 많은 것이 있음을 의미합니다. 제공되는 정확한 상수는 컴파일 타임에 찾은 OS 및 헤더에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="6cd886bd81b2389456301c1edaca970f0fd117a3" translate="yes" xml:space="preserve">
          <source>In earlier versions, when byte and character data were concatenated, the new string was sometimes created by decoding the byte strings as</source>
          <target state="translated">이전 버전에서 바이트 및 문자 데이터가 연결되면 바이트 문자열을 다음과 같이 디코딩하여 새 문자열이 생성되는 경우가있었습니다.</target>
        </trans-unit>
        <trans-unit id="7dc7a0656f22946eb4e770e46a3f69e5d6f40e31" translate="yes" xml:space="preserve">
          <source>In effect, your search prefix is ignored and $Config{vms_prefix} is used instead.</source>
          <target state="translated">실제로 검색 접두사는 무시되고 대신 $ Config {vms_prefix}가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4c62ad53bb4b783795294732eef580256b60e336" translate="yes" xml:space="preserve">
          <source>In either case, you should still be able to run the scripts with perl explicitly:</source>
          <target state="translated">두 경우 모두 perl을 사용하여 스크립트를 명시 적으로 실행할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="fb41a30683f07ad432fb7627b6f4d0b50b059664" translate="yes" xml:space="preserve">
          <source>In extreme cases, &lt;b&gt;perlbug&lt;/b&gt; may not work well enough on your system to guide you through composing a bug report. In those cases, you may be able to use &lt;b&gt;perlbug -d&lt;/b&gt; to get system configuration information to include in a manually composed bug report to &lt;b&gt;perlbug@perl.org&lt;/b&gt;.</source>
          <target state="translated">극단적 인 경우 시스템에서 버그 보고서 작성을 안내하기에 &lt;b&gt;perlbug&lt;/b&gt; 가 제대로 작동하지 않을 수 있습니다. 이러한 경우 &lt;b&gt;perlbug -d&lt;/b&gt; 를 사용 하여 수동으로 구성된 버그 보고서에 &lt;b&gt;perlbug@perl.org&lt;/b&gt; 에 포함시킬 시스템 구성 정보를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="abe9c1f86e0ce32785f02f8f2556f43d9ccd3599" translate="yes" xml:space="preserve">
          <source>In fact it is not 100% true that a compiled unit contains a pointer to the scratchpad AV. In fact it contains a pointer to an AV of (initially) one element, and this element is the scratchpad AV. Why do we need an extra level of indirection?</source>
          <target state="translated">실제로 컴파일 된 장치에 스크래치 패드 AV에 대한 포인터가 포함되어 있다는 것은 100 % 사실이 아닙니다. 실제로 여기에는 한 요소의 AV에 대한 포인터가 포함되어 있으며이 요소는 스크래치 패드 AV입니다. 왜 간접적 인 수준의 간접 성이 필요한가?</target>
        </trans-unit>
        <trans-unit id="e844204f376cced819af429b122503a8c0eba54a" translate="yes" xml:space="preserve">
          <source>In fact mangling of</source>
          <target state="translated">실제로 맹 글링</target>
        </trans-unit>
        <trans-unit id="3370e0fda40977698cd4fccd53b4e05e504a7a69" translate="yes" xml:space="preserve">
          <source>In fact numbers stored in the native integer format may be stored either in the signed native form, or in the unsigned native form. Thus the limits for Perl numbers stored as native integers would typically be -2**31..2**32-1, with appropriate modifications in the case of 64-bit integers. Again, this does not mean that Perl can do operations only over integers in this range: it is possible to store many more integers in floating point format.</source>
          <target state="translated">사실, 고유 정수 형식으로 저장된 숫자는 부호있는 고유 형식 또는 부호없는 고유 형식으로 저장 될 수 있습니다. 따라서 원시 정수로 저장된 Perl 수의 한계는 일반적으로 -2 ** 31..2 ** 32-1이며 64 비트 정수의 경우 적절하게 수정됩니다. 다시 말해 이것은 Perl이이 범위의 정수에 대해서만 연산을 수행 할 수 있다는 것을 의미하지는 않습니다. 더 많은 정수를 부동 소수점 형식으로 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58c12119d45a0a6b7a7d70173ad8a47276ea5e91" translate="yes" xml:space="preserve">
          <source>In fact, a dynamic variable (also known as package or global variables) are still accessible using the fully qualified &lt;code&gt;::&lt;/code&gt; notation even while a lexical of the same name is also visible:</source>
          <target state="translated">사실, 동적 인 변수 (패키지 또는 전역 변수라고도 함)는 동일한 이름의 어휘가 보이는 경우에도 정규화 된 &lt;code&gt;::&lt;/code&gt; 표기법을 사용하여 여전히 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43fe617e28edf5522d6d7a7c2fe5c4bc3af16527" translate="yes" xml:space="preserve">
          <source>In fact, a simple identifier within such curlies is forced to be a string, and likewise within a hash subscript. Neither need quoting. Our earlier example, &lt;code&gt;$days{'Feb'}&lt;/code&gt; can be written as &lt;code&gt;$days{Feb}&lt;/code&gt; and the quotes will be assumed automatically. But anything more complicated in the subscript will be interpreted as an expression. This means for example that &lt;code&gt;$version{2.0}++&lt;/code&gt; is equivalent to &lt;code&gt;$version{2}++&lt;/code&gt; , not to &lt;code&gt;$version{'2.0'}++&lt;/code&gt; .</source>
          <target state="translated">실제로, 그러한 curly 내의 간단한 식별자는 문자열이되어야하고 마찬가지로 해시 첨자 내에 있어야합니다. 인용도 필요 없습니다. 이전 예인 &lt;code&gt;$days{'Feb'}&lt;/code&gt; 는 &lt;code&gt;$days{Feb}&lt;/code&gt; 로 작성 될 수 있으며 따옴표는 자동으로 가정됩니다. 그러나 아래 첨자에서 더 복잡한 것은 표현식으로 해석됩니다. 예를 들어 &lt;code&gt;$version{2.0}++&lt;/code&gt; 는 &lt;code&gt;$version{'2.0'}++&lt;/code&gt; 아니라 &lt;code&gt;$version{2}++&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="721f4b0102ec5d45627b4acee4d7283205201fd1" translate="yes" xml:space="preserve">
          <source>In fact, if you predeclare functions you want to call that way, you don't even need parentheses:</source>
          <target state="translated">실제로, 그런 식으로 호출하려는 함수를 미리 선언하면 괄호가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="84798f732a21afa219bddab775dec767e752c195" translate="yes" xml:space="preserve">
          <source>In fact, one can put this check into a POSTCALL: section as well. Together with PREINIT: simplifications, this leads to:</source>
          <target state="translated">실제로이 검사를 POSTCALL : 섹션에도 넣을 수 있습니다. PREINIT : 단순화와 함께 이로 인해 다음이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ebdfc7c600521f2938c49c5c2856e2e2b5dd3018" translate="yes" xml:space="preserve">
          <source>In fact, the above is a specific instance of a more general problem: we can't guarantee to produce BEGIN blocks or &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; declarations in exactly the right place. So if you use a module which affects compilation (such as by over-riding keywords, overloading constants or whatever) then the output code might not work as intended.</source>
          <target state="translated">사실 위의 내용은보다 일반적인 문제의 구체적인 예입니다. BEGIN 블록을 생성하거나 정확한 장소에서 선언을 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 한다고 보장 할 수 없습니다 . 따라서 컴파일에 영향을 미치는 모듈 (예 : 키워드 오버라이드, 상수 오버로드 등)을 사용하면 출력 코드가 의도 한대로 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee7429eb30ff20d649952850c91750d9f7b5208e" translate="yes" xml:space="preserve">
          <source>In fact, the skeleton modules shown above are fully functional</source>
          <target state="translated">사실, 위에 표시된 골격 모듈은 완벽하게 작동합니다</target>
        </trans-unit>
        <trans-unit id="c08ff00d22228fb68d08d8dbc97cd530161909a6" translate="yes" xml:space="preserve">
          <source>In fact, what can happen is that the Perl subroutine you have called can access the &lt;code&gt;@_&lt;/code&gt; array from a previous Perl subroutine. This will occur when the code that is executing the</source>
          <target state="translated">실제로, 호출 한 Perl 서브 루틴이 이전 Perl 서브 루틴에서 &lt;code&gt;@_&lt;/code&gt; 배열에 액세스 할 수 있습니다 . 실행중인 코드가</target>
        </trans-unit>
        <trans-unit id="5159536cbfaf213ba408ca2109f0a550ad3339ea" translate="yes" xml:space="preserve">
          <source>In fact, you can use as many repeated angle-brackets as you like so long as you have the same number of them in the opening and closing delimiters, and make sure that whitespace immediately follows the last '&amp;lt;' of the opening delimiter, and immediately precedes the first '&amp;gt;' of the closing delimiter. (The whitespace is ignored.) So the following will also work:</source>
          <target state="translated">실제로, 여는 구분 기호와 닫는 구분 기호에 같은 수의 숫자가 있으면 원하는만큼 반복 된 꺾쇠 괄호를 사용할 수 있고 공백이 여는 구분 기호의 마지막 '&amp;lt;'바로 뒤에 오도록해야합니다. 닫는 구분 기호의 첫 번째 '&amp;gt;'바로 앞에옵니다. (공백은 무시됩니다.) 따라서 다음도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="eeef4cfd76862c3bdd64f8624b59be39f324bbb5" translate="yes" xml:space="preserve">
          <source>In former versions of FindBin there was no &lt;code&gt;again&lt;/code&gt; function. The workaround was to force the &lt;code&gt;BEGIN&lt;/code&gt; block to be executed again:</source>
          <target state="translated">이전 버전의 FindBin에서는 &lt;code&gt;again&lt;/code&gt; 기능 이 없었 습니다 . 해결 방법은 &lt;code&gt;BEGIN&lt;/code&gt; 블록 을 강제로 다시 실행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="81bdf0d224677096b960b752cf09cb19f280de31" translate="yes" xml:space="preserve">
          <source>In function definitions, name starts in column 0 (return value-type is on previous line)</source>
          <target state="translated">함수 정의에서 이름은 열 0에서 시작합니다 (반환 값 유형은 이전 행에 있음)</target>
        </trans-unit>
        <trans-unit id="bd418e3b4eaab23d82d37560db5e07798de430bc" translate="yes" xml:space="preserve">
          <source>In general the flags should be preserved in &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; after compilation, although the regex engine might want to add or delete some of them to invoke or disable some special behavior in Perl. The flags along with any special behavior they cause are documented below:</source>
          <target state="translated">정규식 엔진은 Perl에서 일부 특수 동작을 호출하거나 비활성화하기 위해 일부를 추가 또는 삭제하려고 할 수 있지만 일반적으로 컴파일 후 &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; 에 플래그를 유지해야합니다 . 특수한 동작과 함께 플래그가 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf0fc22fd30f9556953173964854405f4701bcb8" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Module ()&lt;/code&gt; is recommended over &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; Module&lt;/code&gt; , because it determines module availability at compile time, not in the middle of your program's execution. An exception would be if two modules each tried to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; each other, and each also called a function from that other module. In that case, it's easy to use &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">일반적으로, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Module ()&lt;/code&gt; 통해 추천 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; Module&lt;/code&gt; 이 아닌 프로그램의 실행의 중간에, 컴파일시에 모듈 가용성을 결정하기 때문에. 두 모듈이 서로를 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 하려고 시도 하고 각 모듈이 다른 모듈에서 함수를 호출 한 경우는 예외입니다 . 이 경우 대신 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 를 사용 하는 것이 쉽습니다 .</target>
        </trans-unit>
        <trans-unit id="f587f957aa9f0d170955c8740a69ee20fd8f9433" translate="yes" xml:space="preserve">
          <source>In general, a value of 256MB (or &quot;256*1024*1024&quot;) is sufficient for Perl to compile at maximum optimization.</source>
          <target state="translated">일반적으로 Perl이 최대 최적화에서 컴파일하려면 256MB (또는 &quot;256 * 1024 * 1024&quot;)의 값으로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="131ff1b059b6e02af211bb33de067db4f34cad70" translate="yes" xml:space="preserve">
          <source>In general, any generated Makefile checks for the current version of MakeMaker and the version the Makefile was built under. If NO_VC is set, the version check is neglected. Do not write this into your Makefile.PL, use it interactively instead.</source>
          <target state="translated">일반적으로 생성 된 모든 Makefile은 현재 버전의 MakeMaker와 Makefile이 작성된 버전을 확인합니다. NO_VC를 설정하면 버전 확인이 무시됩니다. 이것을 Makefile.PL에 쓰지 말고 대신 대화식으로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ed1c758f94f821404f1b8e30ece4cfe61ee49211" translate="yes" xml:space="preserve">
          <source>In general, binmode() should be called after open() but before any I/O is done on the filehandle. Calling binmode() normally flushes any pending buffered output data (and perhaps pending input data) on the handle. An exception to this is the &lt;code&gt;:encoding&lt;/code&gt; layer that changes the default character encoding of the handle; see &lt;a href=&quot;#open&quot;&gt;open&lt;/a&gt;. The &lt;code&gt;:encoding&lt;/code&gt; layer sometimes needs to be called in mid-stream, and it doesn't flush the stream. The &lt;code&gt;:encoding&lt;/code&gt; also implicitly pushes on top of itself the &lt;code&gt;:utf8&lt;/code&gt; layer because internally Perl operates on UTF8-encoded Unicode characters.</source>
          <target state="translated">일반적으로 binmode ()는 open () 이후에 또는 파일 핸들에서 I / O가 수행되기 전에 호출되어야합니다. binmode ()를 호출하면 일반적으로 핸들에서 보류중인 버퍼링 된 출력 데이터 (및 보류중인 입력 데이터)를 플러시합니다. 이에 대한 예외 는 핸들의 기본 문자 인코딩을 변경하는 &lt;code&gt;:encoding&lt;/code&gt; 레이어입니다. &lt;a href=&quot;#open&quot;&gt;open을&lt;/a&gt; 참조하십시오 . &lt;code&gt;:encoding&lt;/code&gt; 층 때로는 중반 스트림에서 호출 할 필요가, 그리고 스트림을 플러시하지 않습니다. 는 &lt;code&gt;:encoding&lt;/code&gt; 암시 또한 그 자체의 위에 가압 &lt;code&gt;:utf8&lt;/code&gt; 내부적 펄 UTF8 인코딩 유니 코드 문자 동작하기 때문에 층.</target>
        </trans-unit>
        <trans-unit id="fcb23e7c19f51e6c8ab203413d609cc6c59591a8" translate="yes" xml:space="preserve">
          <source>In general, binmode() should be called after open() but before any I/O is done on the filehandle. Calling binmode() normally flushes any pending buffered output data (and perhaps pending input data) on the handle. An exception to this is the &lt;code&gt;:encoding&lt;/code&gt; layer that changes the default character encoding of the handle; see &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;. The &lt;code&gt;:encoding&lt;/code&gt; layer sometimes needs to be called in mid-stream, and it doesn't flush the stream. The &lt;code&gt;:encoding&lt;/code&gt; also implicitly pushes on top of itself the &lt;code&gt;:utf8&lt;/code&gt; layer because internally Perl operates on UTF8-encoded Unicode characters.</source>
          <target state="translated">일반적으로 binmode ()는 open () 이후에 또는 파일 핸들에서 I / O가 수행되기 전에 호출되어야합니다. binmode ()를 호출하면 일반적으로 핸들에서 보류중인 버퍼링 된 출력 데이터 (및 보류중인 입력 데이터)를 플러시합니다. 이에 대한 예외 는 핸들의 기본 문자 인코딩을 변경하는 &lt;code&gt;:encoding&lt;/code&gt; 레이어입니다. &lt;a href=&quot;open&quot;&gt;open을&lt;/a&gt; 참조하십시오 . &lt;code&gt;:encoding&lt;/code&gt; 층 때로는 중반 스트림에서 호출 할 필요가, 그리고 스트림을 플러시하지 않습니다. 는 &lt;code&gt;:encoding&lt;/code&gt; 암시 또한 그 자체의 위에 가압 &lt;code&gt;:utf8&lt;/code&gt; 내부적 펄 UTF8 인코딩 유니 코드 문자 동작하기 때문에 층.</target>
        </trans-unit>
        <trans-unit id="9112f219636184c8537b2886b966af1ac78ce610" translate="yes" xml:space="preserve">
          <source>In general, documentation should describe what Perl does &quot;now&quot; rather than what it used to do. It's perfectly reasonable to include notes in documentation about how behaviour has changed from previous releases, but, with very few exceptions, documentation isn't &quot;dual-life&quot; -- it doesn't need to fully describe how all old versions used to work.</source>
          <target state="translated">일반적으로, 문서는 Perl이 이전에 수행했던 것보다 &quot;현재&quot;하는 것을 설명해야합니다. 동작이 이전 릴리스에서 변경된 방식에 대한 메모를 문서에 포함하는 것이 합리적이지만 예외는 거의 없지만 문서가 &quot;이중 수명&quot;이 아니므로 모든 이전 버전의 작동 방식을 완전히 설명 할 필요는 없습니다. .</target>
        </trans-unit>
        <trans-unit id="c3bded401bb84dc2978238aa4ca8d1e409847f99" translate="yes" xml:space="preserve">
          <source>In general, don't directly access the system in code meant to be portable. That means, no &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;``&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; with a &lt;code&gt;|&lt;/code&gt;, nor any of the other things that makes being a Perl hacker worth being.</source>
          <target state="translated">일반적으로 이식성이 뛰어난 코드로 시스템에 직접 액세스하지 마십시오. 수단, 아니 그 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;``&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; A를 &lt;code&gt;|&lt;/code&gt; 그리고 Perl 해커가 될만한 다른 것들도 가치가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4812a1f34a0b31a652cad991bba82f8957d788f2" translate="yes" xml:space="preserve">
          <source>In general, functions in Perl that serve as wrappers for system calls (&quot;syscalls&quot;) of the same name (like chown(2), fork(2), closedir(2), etc.) return true when they succeed and &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; otherwise, as is usually mentioned in the descriptions below. This is different from the C interfaces, which return &lt;code&gt;-1&lt;/code&gt; on failure. Exceptions to this rule include &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt;. System calls also set the special &lt;code&gt;$!&lt;/code&gt; variable on failure. Other functions do not, except accidentally.</source>
          <target state="translated">일반적으로 같은 이름의 시스템 호출 ( &quot;syscalls&quot;)에 대한 래퍼 역할을하는 Perl의 함수 (예 : chown (2), fork (2), closedir (2) 등)는 성공하면 true를 반환하고 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 아래 설명에서 일반적으로 언급 한대로 이는 실패시 &lt;code&gt;-1&lt;/code&gt; 을 반환하는 C 인터페이스와 다릅니다 . 이 규칙의 예외에는 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 이 포함 됩니다. 시스템 호출은 또한 특별한 &lt;code&gt;$!&lt;/code&gt; 실패시 변수. 실수로 제외하고 다른 기능은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2d920741739edbfdbddc6a5906e0b7d1f697b74b" translate="yes" xml:space="preserve">
          <source>In general, if something strange has gone wrong with your program and you're not sure where you should look for help, try making your code comply with &lt;b&gt;use strict&lt;/b&gt; and &lt;b&gt;use warnings&lt;/b&gt;. These will often point out exactly where the trouble is.</source>
          <target state="translated">일반적으로, 뭔가 이상한 프로그램과 함께 사라지다 잘못이 있고 확실하지 않은 도움을 찾아야한다 곳에, 코드를 준수하고 시도하는 경우에 &lt;b&gt;사용 엄격한&lt;/b&gt; 및 &lt;b&gt;사용 경고&lt;/b&gt; . 이것들은 종종 문제가있는 곳을 정확히 지적합니다.</target>
        </trans-unit>
        <trans-unit id="4f338449d4134d94449e7a10434356d790a883d8" translate="yes" xml:space="preserve">
          <source>In general, it is better to create directories with a permissive MASK and let the user modify that with their &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; than it is to supply a restrictive MASK and give the user no way to be more permissive. The exceptions to this rule are when the file or directory should be kept private (mail files, for instance). The perlfunc(1) entry on &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; discusses the choice of MASK in more detail.</source>
          <target state="translated">일반적으로 허용 MASK를 사용하여 디렉토리를 작성하고 사용자 가 제한 MASK를 제공하는 것보다 &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 를 사용하여 해당 파일을 수정하도록 하는 것이 더 사용자에게 더 허용적인 방법을 제공하지 않는 것이 좋습니다. 이 규칙의 예외는 파일 또는 디렉토리를 개인용으로 유지해야하는 경우입니다 (예 : 메일 파일). &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 의 perlfunc (1) 항목 은 MASK의 선택에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="859fd0676cfab168da7696f014146535cbe0534d" translate="yes" xml:space="preserve">
          <source>In general, it is better to create directories with a permissive MASK and let the user modify that with their &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; than it is to supply a restrictive MASK and give the user no way to be more permissive. The exceptions to this rule are when the file or directory should be kept private (mail files, for instance). The perlfunc(1) entry on &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; discusses the choice of MASK in more detail.</source>
          <target state="translated">일반적으로 허용 MASK를 사용하여 디렉토리를 작성하고 사용자 가 제한 MASK를 제공하는 것보다 &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 를 사용하여 해당 파일을 수정하도록 하는 것이 더 사용자에게 더 허용적인 방법을 제공하지 않는 것이 좋습니다. 이 규칙의 예외는 파일 또는 디렉토리를 개인용으로 유지해야하는 경우입니다 (예 : 메일 파일). &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 의 perlfunc (1) 항목 은 MASK의 선택에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="cad59e50fb94fade64091c926ff1356d37dc6324" translate="yes" xml:space="preserve">
          <source>In general, it's not a good idea to write extensions that modify their input parameters, as in Example 3. Instead, you should probably return multiple values in an array and let the caller handle them (we'll do this in a later example). However, in order to better accommodate calling pre-existing C routines, which often do modify their input parameters, this behavior is tolerated.</source>
          <target state="translated">일반적으로 예 3에서와 같이 입력 매개 변수를 수정하는 확장을 작성하는 것은 좋지 않습니다. 대신 배열에서 여러 값을 반환하고 호출자가 처리하도록 할 수 있습니다 (나중의 예에서 수행) . 그러나 종종 입력 매개 변수를 수정하는 기존 C 루틴 호출을 더 잘 수용하기 위해이 동작은 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="183640340bc430e8d749b47027dff4d3c19e6dde" translate="yes" xml:space="preserve">
          <source>In general, memory allocation and de-allocation isn't something you can or should be worrying about much in Perl.</source>
          <target state="translated">일반적으로 메모리 할당 및 할당 해제는 Perl에서 많이 걱정할 수있는 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="694bbd0c5ca4e3fe0dcb487e904ca0b8ccaba6cd" translate="yes" xml:space="preserve">
          <source>In general, please follow the particular style of the code you are patching.</source>
          <target state="translated">일반적으로 패치하려는 코드의 특정 스타일을 따르십시오.</target>
        </trans-unit>
        <trans-unit id="76448cd179f9ee3d08189e3b4f4ab1ba0deb68f0" translate="yes" xml:space="preserve">
          <source>In general, production code should not have file paths hardcoded. Making them user-supplied or read from a configuration file is better, keeping in mind that file path syntax varies on different machines.</source>
          <target state="translated">일반적으로 프로덕션 코드에는 파일 경로가 하드 코드되어 있지 않아야합니다. 파일 경로 구문은 시스템마다 다르므로 사용자가 제공하거나 구성 파일에서 읽도록하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="15ebd5f7d0f38eb2ba1e333ec5e5f7197b5f77f7" translate="yes" xml:space="preserve">
          <source>In general, the VMS version of ext() should properly handle input from extensions originally designed for a Unix or VMS environment. If you encounter problems, or discover cases where the search could be improved, please let us know.</source>
          <target state="translated">일반적으로 ext ()의 VMS 버전은 원래 Unix 또는 VMS 환경 용으로 설계된 확장의 입력을 올바르게 처리해야합니다. 문제가 발생하거나 검색이 개선 될 수있는 사례를 발견 한 경우 알려주십시오.</target>
        </trans-unit>
        <trans-unit id="6fd9faf570da706152bccbfe022ff5b9665bb3b0" translate="yes" xml:space="preserve">
          <source>In general, the benefit of a language is closely related to the skill of the people using that language. If you or your team can be faster, better, and stronger through Perl, you'll deliver more value. Remember, people often respond better to what they get out of it. If you run into resistance, figure out what those people get out of the other choice and how Perl might satisfy that requirement.</source>
          <target state="translated">일반적으로 언어의 이점은 해당 언어를 사용하는 사람들의 기술과 밀접한 관련이 있습니다. Perl을 통해 귀하 또는 귀하의 팀이 더 빠르고 우수하며 강해지면 더 많은 가치를 제공 할 수 있습니다. 사람들은 종종 자신이 얻는 것에 더 잘 반응한다는 것을 기억하십시오. 저항에 부딪 치면, 사람들이 다른 선택에서 무엇을 얻는 지, 그리고 Perl이 어떻게 그 요구 사항을 충족시킬 수 있는지 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="c1872d2ad517d8a6c01a447283eab0112566170f" translate="yes" xml:space="preserve">
          <source>In general, the distributed kit for a Perl extension includes a file named Makefile.PL, which is a Perl program which is used to create a</source>
          <target state="translated">일반적으로 Perl 확장 용 배포 키트에는 Makefile.PL이라는 파일이 포함되어 있습니다.이 파일은 Perl 프로그램을 만드는 데 사용되는 Perl 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="3997a59e30d7c4c978daa07218b367eb8d7c9173" translate="yes" xml:space="preserve">
          <source>In general, the easiest path to portability is always to specify filenames in Unix format unless they will need to be processed by native commands or utilities. Because of this latter consideration, the File::Spec module by default returns native format specifications regardless of input format. This default may be reversed so that filenames are always reported in Unix format by specifying the &lt;code&gt;DECC$FILENAME_UNIX_REPORT&lt;/code&gt; feature logical in the environment.</source>
          <target state="translated">일반적으로 이식성에 대한 가장 쉬운 경로는 기본 명령이나 유틸리티로 처리 할 필요가없는 한 항상 파일 이름을 Unix 형식으로 지정하는 것입니다. 후자의 고려 사항으로 인해 File :: Spec 모듈은 기본적으로 입력 형식에 관계없이 기본 형식 사양을 반환합니다. 환경에서 논리적으로 &lt;code&gt;DECC$FILENAME_UNIX_REPORT&lt;/code&gt; 기능 을 지정하여 파일 이름이 항상 Unix 형식으로보고되도록이 기본값을 되돌릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="28770c3025c0aede638f676bb8209a09acd6f0b6" translate="yes" xml:space="preserve">
          <source>In general, the perl interpreter views itself as the center of the universe as far as the Perl program goes. XS code is viewed as a help-mate, to accomplish things that perl doesn't do, or doesn't do fast enough, but always subservient to perl. The closer XS code adheres to this model, the less likely conflicts will occur.</source>
          <target state="translated">일반적으로 펄 통역사는 펄 프로그램이 진행되는 한 자신을 우주의 중심으로 본다. XS 코드는 펄이하지 않거나 충분히 빠르지 않지만 항상 펄에 종속적 인 일을 수행하기위한 도우미로 간주됩니다. XS 코드가이 모델에 가까울수록 충돌 가능성이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="a1d0e4d941599d8b8058171587801ee612197c61" translate="yes" xml:space="preserve">
          <source>In general, the standard modules work across platforms. Notable exceptions are the &lt;code&gt;CPAN&lt;/code&gt; module (which currently makes connections to external programs that may not be available), platform-specific modules (like &lt;code&gt;ExtUtils::MM_VMS&lt;/code&gt; ), and DBM modules.</source>
          <target state="translated">일반적으로 표준 모듈은 여러 플랫폼에서 작동합니다. 주목할만한 예외가 있습니다 &lt;code&gt;CPAN&lt;/code&gt; 의 (현재는 사용하지 못할 수 있습니다 외부 프로그램에 대한 연결을 만드는) 모듈, (같은 플랫폼 별 모듈을 &lt;code&gt;ExtUtils::MM_VMS&lt;/code&gt; 및 DBM 모듈).</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
