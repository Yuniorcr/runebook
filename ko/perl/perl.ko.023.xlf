<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="df751a148221e657237a264ca9bfcbc240163953" translate="yes" xml:space="preserve">
          <source>Defined if we're dealing with the &lt;code&gt;GNU&lt;/code&gt; C Library.</source>
          <target state="translated">&lt;code&gt;GNU&lt;/code&gt; C 라이브러리를 다루는 경우 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="487af9998b90c5fd5fb9d7386051e0f2dc3d4e56" translate="yes" xml:space="preserve">
          <source>Defined in RFC 2277, this is for tagging text (which must include English text, and might/should include text in other appropriate languages) that is emitted in a context where language-negotiation wasn't possible -- in SMTP mail failure messages, for example.</source>
          <target state="translated">RFC 2277에 정의되어 있으며 SMTP 메일 오류 메시지에서 언어 협상이 불가능한 상황에서 생성되는 텍스트 (영어 텍스트를 포함해야하며 다른 적절한 언어로 텍스트를 포함해야 함)에 태그를 지정하기위한 것입니다. 예를 들어.</target>
        </trans-unit>
        <trans-unit id="d0094836cd417237e53e36d38b6bb157c23bb8dd" translate="yes" xml:space="preserve">
          <source>Defines EXTRALIBS, LDLOADLIBS, BSLOADLIBS, LD_RUN_PATH. See &lt;a href=&quot;liblist&quot;&gt;ExtUtils::Liblist&lt;/a&gt; for details.</source>
          <target state="translated">EXTRALIBS, LDLOADLIBS, BSLOADLIBS, LD_RUN_PATH를 정의합니다. 자세한 내용은 &lt;a href=&quot;liblist&quot;&gt;ExtUtils :: Liblist&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="54d5e1ace8616b0824e4e69deda9fb5d35c9ab98" translate="yes" xml:space="preserve">
          <source>Defines a check in target for RCS.</source>
          <target state="translated">RCS의 체크인 대상을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="fe64ed45d43654228ab2f263b3250cb6d237ffdb" translate="yes" xml:space="preserve">
          <source>Defines a couple of constants in the Makefile that are imported from %Config.</source>
          <target state="translated">% Config에서 가져온 Makefile에 몇 가지 상수를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="45640d4e061562862c8b269f9919db4c555b95a5" translate="yes" xml:space="preserve">
          <source>Defines a lot of macros for distribution support.</source>
          <target state="translated">배포 지원을위한 많은 매크로를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="8f2c384608aa9da85fcd183aa27b7be131f7d130" translate="yes" xml:space="preserve">
          <source>Defines a simple perl call that runs autosplit. May be deprecated by pm_to_blib soon.</source>
          <target state="translated">자동 분할을 실행하는 간단한 perl 호출을 정의합니다. pm_to_blib에서 곧 폐기 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f1b350e0e67e0413f358f35911f68c6865314e4" translate="yes" xml:space="preserve">
          <source>Defines a target that produces the distribution in the scratch directory, and runs 'perl Makefile.PL; make ;make test' in that subdirectory.</source>
          <target state="translated">스크래치 디렉토리에서 분배를 생성하고 'perl Makefile.PL; 그 하위 디렉토리에 make make make.</target>
        </trans-unit>
        <trans-unit id="302537770d292c74e66370b599a3b03ffe01a51a" translate="yes" xml:space="preserve">
          <source>Defines at least these macros.</source>
          <target state="translated">최소한 이러한 매크로를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="6b99cfd58fae6b3dae8c7123af0773072b8fe5e5" translate="yes" xml:space="preserve">
          <source>Defines how to produce the *.a (or equivalent) files.</source>
          <target state="translated">* .a (또는 동등한 파일)를 생성하는 방법을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="dc26efd3c32adf7d1de84003c339188a38e358f8" translate="yes" xml:space="preserve">
          <source>Defines how to produce the *.so (or equivalent) files.</source>
          <target state="translated">* .so (또는 동등한 파일)를 생성하는 방법을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="8695ac2968551bde31876b3d67b9ced4a12a9549" translate="yes" xml:space="preserve">
          <source>Defines how to rewrite the Makefile.</source>
          <target state="translated">Makefile을 다시 쓰는 방법을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="22c6065d98e3206f28470f013ce533e0e15ea743" translate="yes" xml:space="preserve">
          <source>Defines suffix rules to go from XS to object files directly. This is only intended for broken make implementations.</source>
          <target state="translated">XS에서 객체 파일로 직접 이동할 접미사 규칙을 정의합니다. 이것은 깨진 make 구현만을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="b3b41acc6b49a6388409ba10f2258e522cda4bba" translate="yes" xml:space="preserve">
          <source>Defines target that copies all files in the hash PM to their destination and autosplits them. See &lt;a href=&quot;install#DESCRIPTION&quot;&gt;DESCRIPTION in ExtUtils::Install&lt;/a&gt;</source>
          <target state="translated">해시 PM의 모든 파일을 대상으로 복사하고 자동 분할하는 대상을 정의합니다. &lt;a href=&quot;install#DESCRIPTION&quot;&gt;ExtUtils :: Install의 DESCRIPTION을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4adac1897b3589686f6012b335a376dba9440a99" translate="yes" xml:space="preserve">
          <source>Defines target that creates a PPD (Perl Package Description) file for a binary distribution.</source>
          <target state="translated">이진 배포를위한 PPD (Perl Package Description) 파일을 생성하는 대상을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="81215a51ffc47aa71de599db8f3ad3d93520e3be" translate="yes" xml:space="preserve">
          <source>Defines targets and routines to translate the pods into manpages and put them into the INST_* directories.</source>
          <target state="translated">포드를 맨 페이지로 변환하고 INST_ * 디렉토리에 넣을 대상과 루틴을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="a27612024b8b930142c07dfc2a483eb40f35b6c8" translate="yes" xml:space="preserve">
          <source>Defines targets for bootstrap files.</source>
          <target state="translated">부트 스트랩 파일의 대상을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="d67b6bc334f7365a22e55924832c3099c1799069" translate="yes" xml:space="preserve">
          <source>Defines targets to make and to install EXE_FILES.</source>
          <target state="translated">EXE_FILES를 만들고 설치할 대상을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="a39e083fd927c6ae8fb97333fcad3f2b452cafcb" translate="yes" xml:space="preserve">
          <source>Defines targets to process subdirectories.</source>
          <target state="translated">하위 디렉토리를 처리 할 대상을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="4b99ef7da9945c228db1380016cfa3962ddce9f3" translate="yes" xml:space="preserve">
          <source>Defines targets to run *.PL files.</source>
          <target state="translated">* .PL 파일을 실행할 대상을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="d9ad31fa070099a4fc5216a15ac2552cb8720903" translate="yes" xml:space="preserve">
          <source>Defines the DESTDIR and DEST* variables paralleling the INSTALL*.</source>
          <target state="translated">INSTALL *와 평행 한 DESTDIR 및 DEST * 변수를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="ba94224c3086851c054895958309c5f4d0716300" translate="yes" xml:space="preserve">
          <source>Defines the PERLDLL symbol if we are configured for static building since all code destined for the perl5xx.dll must be compiled with the PERLDLL symbol defined.</source>
          <target state="translated">perl5xx.dll로 향하는 모든 코드가 정의 된 PERLDLL 기호로 컴파일되어야하므로 정적 빌드 용으로 구성된 경우 PERLDLL 기호를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="e8fef87bd74d9d4f90d787908362dc30b0d77629" translate="yes" xml:space="preserve">
          <source>Defines the clean target.</source>
          <target state="translated">정리 대상을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="44c298f8aa784474d919a3c44fea66470e8f2e7f" translate="yes" xml:space="preserve">
          <source>Defines the compression level used by zlib. The value should either be a number between 0 and 9 (0 means no compression and 9 is maximum compression), or one of the symbolic constants defined below.</source>
          <target state="translated">zlib에서 사용하는 압축 수준을 정의합니다. 값은 0과 9 사이의 숫자 (0은 압축이 없음을 의미하고 9는 최대 압축을 의미 함) 또는 아래에 정의 된 기호 상수 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="f42bdaa318d7d2b3aed95081e60d514ae57c0a40" translate="yes" xml:space="preserve">
          <source>Defines the compression level. Valid values are 0 through 9, &lt;code&gt;Z_NO_COMPRESSION&lt;/code&gt; , &lt;code&gt;Z_BEST_SPEED&lt;/code&gt; , &lt;code&gt;Z_BEST_COMPRESSION&lt;/code&gt; , and &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; .</source>
          <target state="translated">압축 수준을 정의합니다. 유효한 값은 0-9, &lt;code&gt;Z_NO_COMPRESSION&lt;/code&gt; , &lt;code&gt;Z_BEST_SPEED&lt;/code&gt; , &lt;code&gt;Z_BEST_COMPRESSION&lt;/code&gt; 및 &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="40143f5226bb902295ca1dda0de7dc4d4309dfae" translate="yes" xml:space="preserve">
          <source>Defines the compression method. The only valid value at present (and the default) is &lt;code&gt;Z_DEFLATED&lt;/code&gt; .</source>
          <target state="translated">압축 방법을 정의합니다. 현재 유일하게 유효한 값 (및 기본값)은 &lt;code&gt;Z_DEFLATED&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="deaa8bcc66f1718ba796d4871baf848aff3c710f" translate="yes" xml:space="preserve">
          <source>Defines the compression method. The only valid value at present (and the default) is Z_DEFLATED.</source>
          <target state="translated">압축 방법을 정의합니다. 현재 유일하게 유효한 값 (및 기본값)은 Z_DEFLATED입니다.</target>
        </trans-unit>
        <trans-unit id="e5f8cd0a2961419147b82d106eae039801beefea" translate="yes" xml:space="preserve">
          <source>Defines the dependency from all *.h files that come with the perl distribution.</source>
          <target state="translated">perl 분배와 함께 제공되는 모든 * .h 파일의 종속성을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="740df2004d6262227a64962e7679f8e429418ecc" translate="yes" xml:space="preserve">
          <source>Defines the dynamic target.</source>
          <target state="translated">동적 대상을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="5f6aea77294d02ec6fd46c657ab20cc6e5da28ce" translate="yes" xml:space="preserve">
          <source>Defines the install target.</source>
          <target state="translated">설치 대상을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="476771d611b7ad6cde3ad6c65766d9fa62c6985b" translate="yes" xml:space="preserve">
          <source>Defines the linkext target which in turn defines the LINKTYPE.</source>
          <target state="translated">LINKTYPE을 정의하는 linkext 대상을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="28bca9ceee2fa0c0c2202b5cce5e6315839954c5" translate="yes" xml:space="preserve">
          <source>Defines the realclean target.</source>
          <target state="translated">realclean 대상을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="187b77c07dcdb58c6c97c87717ccce9d654bf4c9" translate="yes" xml:space="preserve">
          <source>Defines the scratch directory target that will hold the distribution before tar-ing (or shar-ing).</source>
          <target state="translated">taring (또는 공유) 전에 분배를 보유 할 스크래치 디렉토리 대상을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="7111ead71f2d3431a6510a936ce620bc4b1e5ad4" translate="yes" xml:space="preserve">
          <source>Defines the static target.</source>
          <target state="translated">정적 대상을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="c63068c7e0232b8f723215365b2896a0e197617e" translate="yes" xml:space="preserve">
          <source>Defines the strategy used to tune the compression. The valid values are &lt;code&gt;Z_DEFAULT_STRATEGY&lt;/code&gt; , &lt;code&gt;Z_FILTERED&lt;/code&gt; , &lt;code&gt;Z_RLE&lt;/code&gt; , &lt;code&gt;Z_FIXED&lt;/code&gt; and &lt;code&gt;Z_HUFFMAN_ONLY&lt;/code&gt; .</source>
          <target state="translated">압축을 조정하는 데 사용되는 전략을 정의합니다. 유효한 값은 &lt;code&gt;Z_DEFAULT_STRATEGY&lt;/code&gt; , &lt;code&gt;Z_FILTERED&lt;/code&gt; , &lt;code&gt;Z_RLE&lt;/code&gt; , &lt;code&gt;Z_FIXED&lt;/code&gt; 및 &lt;code&gt;Z_HUFFMAN_ONLY&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6f3b8848d647f32e943342a5efdd76d9b487a63a" translate="yes" xml:space="preserve">
          <source>Defines the strategy used to tune the compression. The valid values are &lt;code&gt;Z_DEFAULT_STRATEGY&lt;/code&gt; , &lt;code&gt;Z_FILTERED&lt;/code&gt; and &lt;code&gt;Z_HUFFMAN_ONLY&lt;/code&gt; .</source>
          <target state="translated">압축을 조정하는 데 사용되는 전략을 정의합니다. 유효한 값은 &lt;code&gt;Z_DEFAULT_STRATEGY&lt;/code&gt; , &lt;code&gt;Z_FILTERED&lt;/code&gt; 및 &lt;code&gt;Z_HUFFMAN_ONLY&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3eee1848a08d0972c7c4402500e5de73ab130c5a" translate="yes" xml:space="preserve">
          <source>Defines the strategy used to tune the compression. Use one of the symbolic constants defined below.</source>
          <target state="translated">압축을 조정하는 데 사용되는 전략을 정의합니다. 아래에 정의 된 기호 상수 중 하나를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0140c569a167a40b758a74ad75bbfa4a322932c6" translate="yes" xml:space="preserve">
          <source>Defines the string that is passed to recursive make calls in subdirectories.</source>
          <target state="translated">서브 디렉토리에서 재귀 적 호출에 전달되는 문자열을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="3da735f442360be74e54c58a85701764b3e96022" translate="yes" xml:space="preserve">
          <source>Defines the suffix rules to compile XS files to C++.</source>
          <target state="translated">XS 파일을 C ++로 컴파일하는 접미사 규칙을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="74b9893fa91b825a1d680e0f69f616b612a76cb5" translate="yes" xml:space="preserve">
          <source>Defines the suffix rules to compile XS files to C.</source>
          <target state="translated">XS 파일을 C로 컴파일하기위한 접미사 규칙을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="e0d8ee251994cc513f249a8caeb41a2880a20ae6" translate="yes" xml:space="preserve">
          <source>Defines the suffix rules to compile different flavors of C files to object files.</source>
          <target state="translated">다양한 종류의 C 파일을 객체 파일로 컴파일하는 접미사 규칙을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="32546d4aee39d7ecd97ee598cccfec080ea2b2fa" translate="yes" xml:space="preserve">
          <source>Defines the targets all, subdirs, config, and O_FILES</source>
          <target state="translated">대상 all, subdirs, config 및 O_FILES를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="8d94db57a25050ea2e12e70aa07a67bf9e408e8b" translate="yes" xml:space="preserve">
          <source>Defines the targets distclean, distcheck, skipcheck, manifest, veryclean.</source>
          <target state="translated">대상 distclean, distcheck, skipcheck, manifest, veryclean을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="195a11e1aaa7fa1de51a9767e72b1109922bd69b" translate="yes" xml:space="preserve">
          <source>Defines the test targets.</source>
          <target state="translated">테스트 대상을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="e470b7139fcd28a3e03c5dc98122c30f121e0ce7" translate="yes" xml:space="preserve">
          <source>Defining Aliases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6a4f129ca4af3f95655180a4ab4518f538d8368" translate="yes" xml:space="preserve">
          <source>Defining Encodings</source>
          <target state="translated">인코딩 정의</target>
        </trans-unit>
        <trans-unit id="8953e978a34af3aa771b28b8a0aeb5a5a9299394" translate="yes" xml:space="preserve">
          <source>Defining multiple constants at once</source>
          <target state="translated">한 번에 여러 상수 정의</target>
        </trans-unit>
        <trans-unit id="0b4d4a2cad4c2c9d7a21a4f7eee774dd37c837d6" translate="yes" xml:space="preserve">
          <source>Defining named patterns</source>
          <target state="translated">명명 된 패턴 정의</target>
        </trans-unit>
        <trans-unit id="15225baac48fc3d689cb2b0f74b936eff4339ff7" translate="yes" xml:space="preserve">
          <source>Definitions</source>
          <target state="translated">Definitions</target>
        </trans-unit>
        <trans-unit id="dc49f81973bcb0957f67dbcb79a0c07904072495" translate="yes" xml:space="preserve">
          <source>Deflate Interface</source>
          <target state="translated">인터페이스 Deflate</target>
        </trans-unit>
        <trans-unit id="261df28b51f1e3a727f3a451d8b97dc502d494f7" translate="yes" xml:space="preserve">
          <source>Deflates the contents of &lt;code&gt;$buffer&lt;/code&gt; . The buffer can either be a scalar or a scalar reference. When finished, &lt;code&gt;$buffer&lt;/code&gt; will be completely processed (assuming there were no errors). If the deflation was successful it returns the deflated output, &lt;code&gt;$out&lt;/code&gt; , and a status value, &lt;code&gt;$status&lt;/code&gt; , of &lt;code&gt;Z_OK&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$buffer&lt;/code&gt; 의 내용을 줄입니다 . 버퍼는 스칼라 또는 스칼라 참조 일 수 있습니다. 완료되면 &lt;code&gt;$buffer&lt;/code&gt; 가 완전히 처리됩니다 (오류가 없다고 가정). 수축이 성공하면 수축 된 출력 &lt;code&gt;$out&lt;/code&gt; 및 상태 값 &lt;code&gt;$status&lt;/code&gt; 를 &lt;code&gt;Z_OK&lt;/code&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="88ca554d5d7745bfb195b4e7b44d607bd478a74b" translate="yes" xml:space="preserve">
          <source>Deflates the contents of &lt;code&gt;$input&lt;/code&gt; and writes the compressed data to &lt;code&gt;$output&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$input&lt;/code&gt; 의 내용을 수축시키고 압축 된 데이터를 &lt;code&gt;$output&lt;/code&gt; 씁니다 .</target>
        </trans-unit>
        <trans-unit id="d3ea81ef7609f7aa5b727599becc6a143ff111a6" translate="yes" xml:space="preserve">
          <source>Delete a breakpoint from the specified</source>
          <target state="translated">지정된 지점에서 중단 점 삭제</target>
        </trans-unit>
        <trans-unit id="5a0073b863c5340c8970662e0be69970f5dfeba8" translate="yes" xml:space="preserve">
          <source>Delete a key and its associated value from the cop hints hash</source>
          <target state="translated">경찰 힌트 해시에서 키와 관련 값을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="b15c91a025daa3148a7fab7d1733f7a172457b7b" translate="yes" xml:space="preserve">
          <source>Delete all installed actions.</source>
          <target state="translated">설치된 모든 조치를 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="bb17fd76f6f5ca7598134cd78f73beaa67a2e6d2" translate="yes" xml:space="preserve">
          <source>Delete all installed breakpoints.</source>
          <target state="translated">설치된 모든 중단 점을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="beaf4b4da8da8ff385c29b6d645eaa115a38d395" translate="yes" xml:space="preserve">
          <source>Delete all post-prompt Perl command actions.</source>
          <target state="translated">프롬프트 후 Perl 명령 조치를 모두 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="e03ec6135ed6958ecae2c1ff175c05d512e28238" translate="yes" xml:space="preserve">
          <source>Delete all pre-prompt Perl command actions.</source>
          <target state="translated">사전 프롬프트 된 모든 Perl 명령 조치를 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="73a7816e302077539cac697491b47392c1d85bee" translate="yes" xml:space="preserve">
          <source>Delete all pre-prompt debugger commands.</source>
          <target state="translated">사전 프롬프트 디버거 명령을 모두 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="2dad01021d565585d1f2142d895d1f8890c02ab1" translate="yes" xml:space="preserve">
          <source>Delete all watch-expressions.</source>
          <target state="translated">모든 시계 표현을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="b6f7cb935ade65e12cb5c25c937b996479fb8adb" translate="yes" xml:space="preserve">
          <source>Delete an action from the specified line.</source>
          <target state="translated">지정된 행에서 조치를 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="1226b496f4d499ec434c444cfe660a3f53b36ae9" translate="yes" xml:space="preserve">
          <source>Delete and return the spool.</source>
          <target state="translated">스풀을 삭제하고 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="ec90a00fac0b965cebb8d69254af765943de97b7" translate="yes" xml:space="preserve">
          <source>Delete it. :-) Seriously, there are a number of (mostly unsatisfactory) solutions with varying levels of &quot;security&quot;.</source>
          <target state="translated">삭제하십시오. :-) 진지하게, 다양한 &quot;보안&quot;수준을 가진 많은 (주로 불만족스러운) 솔루션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b819cf6faf3c2dff6669793abe1aba00c76a28d9" translate="yes" xml:space="preserve">
          <source>Delete the element at index</source>
          <target state="translated">색인에서 요소 삭제</target>
        </trans-unit>
        <trans-unit id="c0d51f2b9680b0830421d95140e113f970d690d9" translate="yes" xml:space="preserve">
          <source>Delete the key</source>
          <target state="translated">키 삭제</target>
        </trans-unit>
        <trans-unit id="91cc99f3a5b10598f0cfe04276ac8b00d48c8cb4" translate="yes" xml:space="preserve">
          <source>Delete watch-expression</source>
          <target state="translated">시계 표현 삭제</target>
        </trans-unit>
        <trans-unit id="9ca1c676523afd3f5ee253a9b6c4f5e0ad74e44b" translate="yes" xml:space="preserve">
          <source>Deletes a key/value pair in the hash. The value SV is removed from the hash, made mortal, and returned to the caller. The &lt;code&gt;flags&lt;/code&gt; value will normally be zero; if set to G_DISCARD then NULL will be returned. NULL will also be returned if the key is not found. &lt;code&gt;hash&lt;/code&gt; can be a valid precomputed hash value, or 0 to ask for it to be computed.</source>
          <target state="translated">해시에서 키 / 값 쌍을 삭제합니다. 값 SV는 해시에서 제거되어 치명적이며 호출자에게 반환됩니다. &lt;code&gt;flags&lt;/code&gt; 값은 보통 0이됩니다; G_DISCARD로 설정하면 NULL이 반환됩니다. 키를 찾지 못하면 NULL도 반환됩니다. &lt;code&gt;hash&lt;/code&gt; 는 유효한 사전 계산 된 해시 값이거나 계산을 요청하는 0입니다.</target>
        </trans-unit>
        <trans-unit id="f3c1663e85e551a1c50322e1c209520d893a7af7" translate="yes" xml:space="preserve">
          <source>Deletes a key/value pair in the hash. The value's SV is removed from the hash, made mortal, and returned to the caller. The absolute value of &lt;code&gt;klen&lt;/code&gt; is the length of the key. If &lt;code&gt;klen&lt;/code&gt; is negative the key is assumed to be in UTF-8-encoded Unicode. The &lt;code&gt;flags&lt;/code&gt; value will normally be zero; if set to G_DISCARD then NULL will be returned. NULL will also be returned if the key is not found.</source>
          <target state="translated">해시에서 키 / 값 쌍을 삭제합니다. 값의 SV는 해시에서 제거되어 치명적이며 호출자에게 반환됩니다. &lt;code&gt;klen&lt;/code&gt; 의 절대 값은 키의 길이입니다. 경우 &lt;code&gt;klen&lt;/code&gt; 키에 있다고 가정 부정 유니 UTF-8 인코딩. &lt;code&gt;flags&lt;/code&gt; 값은 보통 0이됩니다; G_DISCARD로 설정하면 NULL이 반환됩니다. 키를 찾지 못하면 NULL도 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b5dd5212aa7a8bc97116e79a014cced26a493225" translate="yes" xml:space="preserve">
          <source>Deletes a list of files. On success, it returns the number of files it successfully deleted. On failure, it returns false and sets &lt;code&gt;$!&lt;/code&gt; (errno):</source>
          <target state="translated">파일 목록을 삭제합니다. 성공하면 성공적으로 삭제 한 파일 수를 반환합니다. 실패하면 false를 반환하고 &lt;code&gt;$!&lt;/code&gt; 를 설정합니다 . (errno) :</target>
        </trans-unit>
        <trans-unit id="4e992fa1a5f580cdba4aa3e9584f6ceab958d933" translate="yes" xml:space="preserve">
          <source>Deletes the directory specified by FILENAME if that directory is empty. If it succeeds it returns true; otherwise it returns false and sets &lt;code&gt;$!&lt;/code&gt; (errno). If FILENAME is omitted, uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">해당 디렉토리가 비어 있으면 FILENAME으로 지정된 디렉토리를 삭제합니다. 성공하면 true를 반환합니다. 그렇지 않으면 false를 반환하고 &lt;code&gt;$!&lt;/code&gt; 설정합니다 ! (errno). FILENAME이 생략되면 &lt;code&gt;$_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ab8b05f803f178aa62996ab1540a40bcd2f3aad" translate="yes" xml:space="preserve">
          <source>Deletes the element indexed by &lt;code&gt;key&lt;/code&gt; from the array, makes the element mortal, and returns it. If &lt;code&gt;flags&lt;/code&gt; equals &lt;code&gt;G_DISCARD&lt;/code&gt; , the element is freed and null is returned. Perl equivalent: &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $elem = &lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;($myarray[$idx]);&lt;/code&gt; for the non-&lt;code&gt;G_DISCARD&lt;/code&gt; version and a void-context &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete($myarray[$idx]);&lt;/a&gt;&lt;/code&gt; for the &lt;code&gt;G_DISCARD&lt;/code&gt; version.</source>
          <target state="translated">배열에서 &lt;code&gt;key&lt;/code&gt; 색인 된 요소를 삭제하고 , 요소를 치명적으로 만들고 리턴합니다. 경우 &lt;code&gt;flags&lt;/code&gt; 와 동일 &lt;code&gt;G_DISCARD&lt;/code&gt; 를 , 요소가 해제되고 null가 돌려 주어집니다. 펄 동등 : &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $elem = &lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;($myarray[$idx]);&lt;/code&gt; 비 &lt;code&gt;G_DISCARD&lt;/code&gt; 버전 및 void-context &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete($myarray[$idx]);&lt;/a&gt;&lt;/code&gt; 에 대한 &lt;code&gt;G_DISCARD&lt;/code&gt; 의 버전.</target>
        </trans-unit>
        <trans-unit id="eb406e5c9566f12490e972a4db2c13a7645fccc7" translate="yes" xml:space="preserve">
          <source>Deleting directories from @INC</source>
          <target state="translated">@INC에서 디렉토리 삭제</target>
        </trans-unit>
        <trans-unit id="59739df4503a81fc7a23e026605cac8564b8e7df" translate="yes" xml:space="preserve">
          <source>Deleting from &lt;code&gt;%ENV&lt;/code&gt; modifies the environment. Deleting from a hash tied to a DBM file deletes the entry from the DBM file. Deleting from a &lt;code&gt;&lt;a href=&quot;functions/tied&quot;&gt;tied&lt;/a&gt;&lt;/code&gt; hash or array may not necessarily return anything; it depends on the implementation of the &lt;code&gt;&lt;a href=&quot;functions/tied&quot;&gt;tied&lt;/a&gt;&lt;/code&gt; package's DELETE method, which may do whatever it pleases.</source>
          <target state="translated">&lt;code&gt;%ENV&lt;/code&gt; 에서 삭제 하면 환경이 수정됩니다. DBM 파일에 연결된 해시에서 삭제하면 DBM 파일에서 항목이 삭제됩니다. &lt;code&gt;&lt;a href=&quot;functions/tied&quot;&gt;tied&lt;/a&gt;&lt;/code&gt; 해시 또는 배열 에서 삭제하면 반드시 아무것도 반환하지 않을 수 있습니다. 그것은 &lt;code&gt;&lt;a href=&quot;functions/tied&quot;&gt;tied&lt;/a&gt;&lt;/code&gt; 패키지의 DELETE 메소드의 구현에 달려 있으며, 원하는대로 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2e4bc535959687d920ab6af5070c36f9ba7c865" translate="yes" xml:space="preserve">
          <source>Deleting from &lt;code&gt;%ENV&lt;/code&gt; modifies the environment. Deleting from a hash tied to a DBM file deletes the entry from the DBM file. Deleting from a &lt;code&gt;&lt;a href=&quot;tied&quot;&gt;tied&lt;/a&gt;&lt;/code&gt; hash or array may not necessarily return anything; it depends on the implementation of the &lt;code&gt;&lt;a href=&quot;tied&quot;&gt;tied&lt;/a&gt;&lt;/code&gt; package's DELETE method, which may do whatever it pleases.</source>
          <target state="translated">&lt;code&gt;%ENV&lt;/code&gt; 에서 삭제 하면 환경이 수정됩니다. DBM 파일에 연결된 해시에서 삭제하면 DBM 파일에서 항목이 삭제됩니다. &lt;code&gt;&lt;a href=&quot;tied&quot;&gt;tied&lt;/a&gt;&lt;/code&gt; 해시 또는 배열 에서 삭제하면 반드시 아무것도 반환하지 않을 수 있습니다. 그것은 &lt;code&gt;&lt;a href=&quot;tied&quot;&gt;tied&lt;/a&gt;&lt;/code&gt; 패키지의 DELETE 메소드의 구현에 달려 있으며, 원하는대로 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a29354be8f01aa714635d9e114de856834c56b93" translate="yes" xml:space="preserve">
          <source>Delivers gcc toolchain targeting 32-bit Windows platform.</source>
          <target state="translated">32 비트 Windows 플랫폼을 대상으로 gcc 툴체인을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0b514393b132ed57d195ef9cf7c8664bedd5ba2f" translate="yes" xml:space="preserve">
          <source>Delivers gcc toolchain targeting both 64-bit Windows and 32-bit Windows platforms (despite the project name &quot;mingw-w64&quot; they are not only 64-bit oriented). They deliver the native gcc compilers and cross-compilers that are also supported by perl's makefile.</source>
          <target state="translated">64 비트 Windows 및 32 비트 Windows 플랫폼을 모두 대상으로하는 gcc 툴체인을 제공합니다 (프로젝트 이름은 &quot;mingw-w64&quot;이지만 64 비트 전용이 아님). 이들은 펄의 메이크 파일에서 지원되는 네이티브 gcc 컴파일러와 크로스 컴파일러를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="84cba83c5edbd4207cb47e793a734e0fe0e36673" translate="yes" xml:space="preserve">
          <source>Demands a version of Perl specified by VERSION, or demands some semantics specified by EXPR or by &lt;code&gt;$_&lt;/code&gt; if EXPR is not supplied.</source>
          <target state="translated">VERSION에 의해 ​​지정된 Perl의 버전을 요구하거나 EXPR이 제공되지 않은 경우 EXPR 또는 &lt;code&gt;$_&lt;/code&gt; 의해 지정된 일부 의미론을 요구합니다 .</target>
        </trans-unit>
        <trans-unit id="562e8903063ed8770f6527d563bca3ab2868b0d9" translate="yes" xml:space="preserve">
          <source>Denial of Service</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53577bb5df0ee9b6376e87f4896b6957a25d7a43" translate="yes" xml:space="preserve">
          <source>Deny</source>
          <target state="translated">Deny</target>
        </trans-unit>
        <trans-unit id="2e10904ffd9eaf7871845f0b81c542592ff1e8bd" translate="yes" xml:space="preserve">
          <source>Deny the listed operators from being used when compiling code in the compartment (other operators may still be permitted).</source>
          <target state="translated">구획에서 코드를 컴파일 할 때 나열된 연산자가 사용되지 않도록하십시오 (다른 연산자는 여전히 허용 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="f3c0cd1438a845e8a503457cb11b112c6a17abfb" translate="yes" xml:space="preserve">
          <source>Dependency on</source>
          <target state="translated">의존성</target>
        </trans-unit>
        <trans-unit id="77dc35303fc487108331e0e6d31fd83790816ff8" translate="yes" xml:space="preserve">
          <source>Dependent libraries can be linked in one of three ways:</source>
          <target state="translated">종속 라이브러리는 다음 세 가지 방법 중 하나로 연결될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b591a22d82312f2906d4cd0cd73a4a0cc311c02d" translate="yes" xml:space="preserve">
          <source>Depending on how you built/installed perl you may have (otherwise identical) Perl documentation in the following formats:</source>
          <target state="translated">Perl을 빌드 / 설치 한 방법에 따라 다음 형식으로 된 Perl 문서가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e46450a9c23e87326a0c62cc3a40e3b23e08ee53" translate="yes" xml:space="preserve">
          <source>Depending on implementation &lt;code&gt;errno&lt;/code&gt; may be &lt;code&gt;EINTR&lt;/code&gt; if operation was interrupted by a signal.</source>
          <target state="translated">구현에 따라 신호에 의해 작동이 중단 된 경우 &lt;code&gt;errno&lt;/code&gt; 는 &lt;code&gt;EINTR&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b0be77db14ba94fc033fd30c3cfe8822eacafb87" translate="yes" xml:space="preserve">
          <source>Depending on the current floating point rounding mode, rounds the argument either toward nearest (like &lt;a href=&quot;#round&quot;&gt;round&lt;/a&gt;), toward zero (like &lt;a href=&quot;#trunc&quot;&gt;trunc&lt;/a&gt;), downward (toward negative infinity), or upward (toward positive infinity) [C99].</source>
          <target state="translated">현재 부동 소수점 반올림 모드에 따라 인수를 가장 가까운 ( &lt;a href=&quot;#round&quot;&gt;round&lt;/a&gt; 와 같은 ), 0 ( &lt;a href=&quot;#trunc&quot;&gt;trunc&lt;/a&gt; 와 같은 ), 아래쪽 (음의 무한대쪽으로) 또는 위쪽 (양의 무한대쪽으로)으로 반올림합니다 [C99].</target>
        </trans-unit>
        <trans-unit id="5294c397495f76892ffea877bf2a43e2c328f0cb" translate="yes" xml:space="preserve">
          <source>Depending on the host operating system, the value of &lt;code&gt;$^X&lt;/code&gt; may be a relative or absolute pathname of the perl program file, or may be the string used to invoke perl but not the pathname of the perl program file. Also, most operating systems permit invoking programs that are not in the PATH environment variable, so there is no guarantee that the value of &lt;code&gt;$^X&lt;/code&gt; is in PATH. For VMS, the value may or may not include a version number.</source>
          <target state="translated">호스트 운영 체제에 따라 &lt;code&gt;$^X&lt;/code&gt; 값은 perl 프로그램 파일의 상대 또는 절대 경로 이름이거나 perl을 호출하는 데 사용되지만 perl 프로그램 파일의 경로 이름이 아닌 문자열 일 수 있습니다. 또한 대부분의 운영 체제는 PATH 환경 변수에없는 프로그램 호출을 허용하므로 &lt;code&gt;$^X&lt;/code&gt; 값이 PATH에 있다고 보장 할 수 없습니다 . VMS의 경우 값에 버전 번호가 포함되거나 포함되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08084da944037c3c23ff2e2b90762c637e7da38d" translate="yes" xml:space="preserve">
          <source>Depending on the transformation, you will find that one or more of the following will happen</source>
          <target state="translated">변환에 따라 다음 중 하나 이상이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="085d0b5e01dcc02f48f2fd13a4f2ed9ebb9054cb" translate="yes" xml:space="preserve">
          <source>Depending on your platform there are various ways of profiling Perl.</source>
          <target state="translated">플랫폼에 따라 Perl을 프로파일 링하는 다양한 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3431b52e6f55419aab8d54a55029192f48ff550" translate="yes" xml:space="preserve">
          <source>Deprecated and removed variables</source>
          <target state="translated">더 이상 사용되지 않고 제거 된 변수</target>
        </trans-unit>
        <trans-unit id="300ce95b61785c757e93c6783917abef0bc4ae26" translate="yes" xml:space="preserve">
          <source>Deprecated by Unicode. These are characters that expand to more than one character in the specified normalization form, but whether they actually take up more bytes or not depends on the encoding being used. For example, a UTF-8 encoded character may expand to a different number of bytes than a UTF-32 encoded character.</source>
          <target state="translated">유니 코드에서 사용되지 않습니다. 지정된 정규화 형식에서 둘 이상의 문자로 확장되는 문자이지만 실제로 더 많은 바이트를 차지하는지 여부는 사용중인 인코딩에 따라 다릅니다. 예를 들어, UTF-8 인코딩 문자는 UTF-32 인코딩 문자와 다른 바이트 수로 확장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09e9afac06c928ecd4bc9dc03a49132c263cf3c1" translate="yes" xml:space="preserve">
          <source>Deprecated by Unicode: Duplicates ccc=vr (Canonical_Combining_Class=Virama)</source>
          <target state="translated">더 이상 사용되지 않는 Unicode : ccc = vr 복제 (Canonical_Combining_Class = Virama)</target>
        </trans-unit>
        <trans-unit id="2c6d79954aa926c28b34d07c6c1b52cea0a4f179" translate="yes" xml:space="preserve">
          <source>Deprecated function whose use raises a warning, and which is slated to be removed in a future Perl version. It is very similar to matching against &lt;code&gt;qr/ ^ [[:alnum:]]+ $ /x&lt;/code&gt; , which you should convert to use instead. The function is deprecated because 1) it doesn't handle UTF-8 encoded strings properly; and 2) it returns &lt;code&gt;TRUE&lt;/code&gt; even if the input is the empty string. The function return is always based on the current locale, whereas using locale rules is optional with the regular expression, based on pragmas in effect and pattern modifiers (see &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;Character set modifiers in perlre&lt;/a&gt; and &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect? in perlre&lt;/a&gt;).</source>
          <target state="translated">더 이상 사용되지 않는 기능으로 경고가 발생하며 향후 Perl 버전에서 제거 될 예정입니다. &lt;code&gt;qr/ ^ [[:alnum:]]+ $ /x&lt;/code&gt; 에 대한 일치와 매우 유사하며 대신 사용하도록 변환해야합니다. 이 함수는 1) UTF-8 인코딩 문자열을 올바르게 처리하지 않기 때문에 사용되지 않습니다. 2) 입력이 빈 문자열 인 경우에도 &lt;code&gt;TRUE&lt;/code&gt; 를 반환 합니다 . 함수 리턴은 항상 현재 로케일을 기반으로하는 반면, 로케일 규칙을 사용하는 것은 효과의 pragma 및 패턴 수정자를 기반으로 정규식에서 선택 사항입니다 ( &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;perlre의 &lt;/a&gt;&lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;문자 세트 수정 자&lt;/a&gt; 및 어떤 문자 세트 수정자가 영향을 미칩니 까? perlre에서 ).</target>
        </trans-unit>
        <trans-unit id="56ed58a2ae79c6af374b506410f3fa9662b418b6" translate="yes" xml:space="preserve">
          <source>Deprecated function whose use raises a warning, and which is slated to be removed in a future Perl version. It is very similar to matching against &lt;code&gt;qr/ ^ [[:alpha:]]+ $ /x&lt;/code&gt; , which you should convert to use instead. The function is deprecated because 1) it doesn't handle UTF-8 encoded strings properly; and 2) it returns &lt;code&gt;TRUE&lt;/code&gt; even if the input is the empty string. The function return is always based on the current locale, whereas using locale rules is optional with the regular expression, based on pragmas in effect and pattern modifiers (see &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;Character set modifiers in perlre&lt;/a&gt; and &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect? in perlre&lt;/a&gt;).</source>
          <target state="translated">더 이상 사용되지 않는 기능으로 경고가 발생하며 향후 Perl 버전에서 제거 될 예정입니다. &lt;code&gt;qr/ ^ [[:alpha:]]+ $ /x&lt;/code&gt; 에 대한 일치와 매우 유사하며 대신 사용하도록 변환해야합니다. 이 함수는 1) UTF-8 인코딩 문자열을 올바르게 처리하지 않기 때문에 사용되지 않습니다. 2) 입력이 빈 문자열 인 경우에도 &lt;code&gt;TRUE&lt;/code&gt; 를 반환 합니다 . 함수 리턴은 항상 현재 로케일을 기반으로하는 반면, 로케일 규칙을 사용하는 것은 효과의 pragma 및 패턴 수정자를 기반으로 정규식에서 선택 사항입니다 ( &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;perlre의 &lt;/a&gt;&lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;문자 세트 수정 자&lt;/a&gt; 및 어떤 문자 세트 수정자가 영향을 미칩니 까? perlre에서 ).</target>
        </trans-unit>
        <trans-unit id="48807b7130a48604da6050bef16bf05c1f34509f" translate="yes" xml:space="preserve">
          <source>Deprecated function whose use raises a warning, and which is slated to be removed in a future Perl version. It is very similar to matching against &lt;code&gt;qr/ ^ [[:cntrl:]]+ $ /x&lt;/code&gt; , which you should convert to use instead. The function is deprecated because 1) it doesn't handle UTF-8 encoded strings properly; and 2) it returns &lt;code&gt;TRUE&lt;/code&gt; even if the input is the empty string. The function return is always based on the current locale, whereas using locale rules is optional with the regular expression, based on pragmas in effect and pattern modifiers (see &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;Character set modifiers in perlre&lt;/a&gt; and &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect? in perlre&lt;/a&gt;).</source>
          <target state="translated">더 이상 사용되지 않는 기능으로 경고가 발생하며 향후 Perl 버전에서 제거 될 예정입니다. &lt;code&gt;qr/ ^ [[:cntrl:]]+ $ /x&lt;/code&gt; 에 대한 일치와 매우 유사하며 대신 사용하도록 변환해야합니다. 이 함수는 1) UTF-8 인코딩 문자열을 올바르게 처리하지 않기 때문에 사용되지 않습니다. 2) 입력이 빈 문자열 인 경우에도 &lt;code&gt;TRUE&lt;/code&gt; 를 반환 합니다 . 함수 리턴은 항상 현재 로케일을 기반으로하는 반면, 로케일 규칙을 사용하는 것은 효과의 pragma 및 패턴 수정자를 기반으로 정규식에서 선택 사항입니다 ( &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;perlre의 &lt;/a&gt;&lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;문자 세트 수정 자&lt;/a&gt; 및 어떤 문자 세트 수정자가 영향을 미칩니 까? perlre에서 ).</target>
        </trans-unit>
        <trans-unit id="e30506988830cd213720be74f34746c5a398ce09" translate="yes" xml:space="preserve">
          <source>Deprecated function whose use raises a warning, and which is slated to be removed in a future Perl version. It is very similar to matching against &lt;code&gt;qr/ ^ [[:digit:]]+ $ /x&lt;/code&gt; , which you should convert to use instead. The function is deprecated because 1) it doesn't handle UTF-8 encoded strings properly; and 2) it returns &lt;code&gt;TRUE&lt;/code&gt; even if the input is the empty string. The function return is always based on the current locale, whereas using locale rules is optional with the regular expression, based on pragmas in effect and pattern modifiers (see &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;Character set modifiers in perlre&lt;/a&gt; and &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect? in perlre&lt;/a&gt;).</source>
          <target state="translated">더 이상 사용되지 않는 기능으로 경고가 발생하며 향후 Perl 버전에서 제거 될 예정입니다. &lt;code&gt;qr/ ^ [[:digit:]]+ $ /x&lt;/code&gt; 에 대한 일치와 매우 유사하며 대신 사용하도록 변환해야합니다. 이 함수는 1) UTF-8 인코딩 문자열을 올바르게 처리하지 않기 때문에 사용되지 않습니다. 2) 입력이 빈 문자열 인 경우에도 &lt;code&gt;TRUE&lt;/code&gt; 를 반환 합니다 . 함수 리턴은 항상 현재 로케일을 기반으로하는 반면, 로케일 규칙을 사용하는 것은 효과의 pragma 및 패턴 수정자를 기반으로 정규식에서 선택 사항입니다 ( &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;perlre의 &lt;/a&gt;&lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;문자 세트 수정 자&lt;/a&gt; 및 어떤 문자 세트 수정자가 영향을 미칩니 까? perlre에서 ).</target>
        </trans-unit>
        <trans-unit id="869432009229b46aa164c28a7cd2745d9ba962ec" translate="yes" xml:space="preserve">
          <source>Deprecated function whose use raises a warning, and which is slated to be removed in a future Perl version. It is very similar to matching against &lt;code&gt;qr/ ^ [[:graph:]]+ $ /x&lt;/code&gt; , which you should convert to use instead. The function is deprecated because 1) it doesn't handle UTF-8 encoded strings properly; and 2) it returns &lt;code&gt;TRUE&lt;/code&gt; even if the input is the empty string. The function return is always based on the current locale, whereas using locale rules is optional with the regular expression, based on pragmas in effect and pattern modifiers (see &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;Character set modifiers in perlre&lt;/a&gt; and &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect? in perlre&lt;/a&gt;).</source>
          <target state="translated">더 이상 사용되지 않는 기능으로 경고가 발생하며 향후 Perl 버전에서 제거 될 예정입니다. &lt;code&gt;qr/ ^ [[:graph:]]+ $ /x&lt;/code&gt; 에 대한 일치와 매우 유사합니다 . 대신 사용하도록 변환해야합니다. 이 함수는 1) UTF-8 인코딩 문자열을 올바르게 처리하지 않기 때문에 사용되지 않습니다. 2) 입력이 빈 문자열 인 경우에도 &lt;code&gt;TRUE&lt;/code&gt; 를 반환 합니다 . 함수 리턴은 항상 현재 로케일을 기반으로하는 반면, 로케일 규칙을 사용하는 것은 효과의 pragma 및 패턴 수정자를 기반으로 정규식에서 선택 사항입니다 ( &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;perlre의 &lt;/a&gt;&lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;문자 세트 수정 자&lt;/a&gt; 및 어떤 문자 세트 수정자가 영향을 미칩니 까? perlre에서 ).</target>
        </trans-unit>
        <trans-unit id="cdc2b565b6e1d8ec1258567850985d57eddc8117" translate="yes" xml:space="preserve">
          <source>Deprecated function whose use raises a warning, and which is slated to be removed in a future Perl version. It is very similar to matching against &lt;code&gt;qr/ ^ [[:lower:]]+ $ /x&lt;/code&gt; , which you should convert to use instead. The function is deprecated because 1) it doesn't handle UTF-8 encoded strings properly; and 2) it returns &lt;code&gt;TRUE&lt;/code&gt; even if the input is the empty string. The function return is always based on the current locale, whereas using locale rules is optional with the regular expression, based on pragmas in effect and pattern modifiers (see &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;Character set modifiers in perlre&lt;/a&gt; and &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect? in perlre&lt;/a&gt;).</source>
          <target state="translated">더 이상 사용되지 않는 기능으로 경고가 발생하며 향후 Perl 버전에서 제거 될 예정입니다. &lt;code&gt;qr/ ^ [[:lower:]]+ $ /x&lt;/code&gt; 에 대한 일치와 매우 유사하며 대신 사용하도록 변환해야합니다. 이 함수는 1) UTF-8 인코딩 문자열을 올바르게 처리하지 않기 때문에 사용되지 않습니다. 2) 입력이 빈 문자열 인 경우에도 &lt;code&gt;TRUE&lt;/code&gt; 를 반환 합니다 . 함수 리턴은 항상 현재 로케일을 기반으로하는 반면, 로케일 규칙을 사용하는 것은 효과의 pragma 및 패턴 수정자를 기반으로 정규식에서 선택 사항입니다 ( &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;perlre의 &lt;/a&gt;&lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;문자 세트 수정 자&lt;/a&gt; 및 어떤 문자 세트 수정자가 영향을 미칩니 까? perlre에서 ).</target>
        </trans-unit>
        <trans-unit id="5b86512fb27d707d0e0edc2d4faed1f32e8d3ffd" translate="yes" xml:space="preserve">
          <source>Deprecated function whose use raises a warning, and which is slated to be removed in a future Perl version. It is very similar to matching against &lt;code&gt;qr/ ^ [[:print:]]+ $ /x&lt;/code&gt; , which you should convert to use instead. The function is deprecated because 1) it doesn't handle UTF-8 encoded strings properly; and 2) it returns &lt;code&gt;TRUE&lt;/code&gt; even if the input is the empty string. The function return is always based on the current locale, whereas using locale rules is optional with the regular expression, based on pragmas in effect and pattern modifiers (see &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;Character set modifiers in perlre&lt;/a&gt; and &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect? in perlre&lt;/a&gt;).</source>
          <target state="translated">더 이상 사용되지 않는 기능으로 경고가 발생하며 향후 Perl 버전에서 제거 될 예정입니다. &lt;code&gt;qr/ ^ [[:print:]]+ $ /x&lt;/code&gt; 에 대한 일치와 매우 유사하며 대신 사용하도록 변환해야합니다. 이 함수는 1) UTF-8 인코딩 문자열을 올바르게 처리하지 않기 때문에 사용되지 않습니다. 2) 입력이 빈 문자열 인 경우에도 &lt;code&gt;TRUE&lt;/code&gt; 를 반환 합니다 . 함수 리턴은 항상 현재 로케일을 기반으로하는 반면, 로케일 규칙을 사용하는 것은 효과의 pragma 및 패턴 수정자를 기반으로 정규식에서 선택 사항입니다 ( &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;perlre의 &lt;/a&gt;&lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;문자 세트 수정 자&lt;/a&gt; 및 어떤 문자 세트 수정자가 영향을 미칩니 까? perlre에서 ).</target>
        </trans-unit>
        <trans-unit id="9b872da650d016a5781f8333cf85bdb130b7bcc7" translate="yes" xml:space="preserve">
          <source>Deprecated function whose use raises a warning, and which is slated to be removed in a future Perl version. It is very similar to matching against &lt;code&gt;qr/ ^ [[:punct:]]+ $ /x&lt;/code&gt; , which you should convert to use instead. The function is deprecated because 1) it doesn't handle UTF-8 encoded strings properly; and 2) it returns &lt;code&gt;TRUE&lt;/code&gt; even if the input is the empty string. The function return is always based on the current locale, whereas using locale rules is optional with the regular expression, based on pragmas in effect and pattern modifiers (see &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;Character set modifiers in perlre&lt;/a&gt; and &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect? in perlre&lt;/a&gt;).</source>
          <target state="translated">더 이상 사용되지 않는 기능으로 경고가 발생하며 향후 Perl 버전에서 제거 될 예정입니다. &lt;code&gt;qr/ ^ [[:punct:]]+ $ /x&lt;/code&gt; 에 대한 일치와 매우 유사합니다 . 대신 사용하도록 변환해야합니다. 이 함수는 1) UTF-8 인코딩 문자열을 올바르게 처리하지 않기 때문에 사용되지 않습니다. 2) 입력이 빈 문자열 인 경우에도 &lt;code&gt;TRUE&lt;/code&gt; 를 반환 합니다 . 함수 리턴은 항상 현재 로케일을 기반으로하는 반면, 로케일 규칙을 사용하는 것은 효과의 pragma 및 패턴 수정자를 기반으로 정규식에서 선택 사항입니다 ( &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;perlre의 &lt;/a&gt;&lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;문자 세트 수정 자&lt;/a&gt; 및 어떤 문자 세트 수정자가 영향을 미칩니 까? perlre에서 ).</target>
        </trans-unit>
        <trans-unit id="4dfc61b4c0045c69830c72d4c8a9f14a2de7cb42" translate="yes" xml:space="preserve">
          <source>Deprecated function whose use raises a warning, and which is slated to be removed in a future Perl version. It is very similar to matching against &lt;code&gt;qr/ ^ [[:space:]]+ $ /x&lt;/code&gt; , which you should convert to use instead. The function is deprecated because 1) it doesn't handle UTF-8 encoded strings properly; and 2) it returns &lt;code&gt;TRUE&lt;/code&gt; even if the input is the empty string. The function return is always based on the current locale, whereas using locale rules is optional with the regular expression, based on pragmas in effect and pattern modifiers (see &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;Character set modifiers in perlre&lt;/a&gt; and &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect? in perlre&lt;/a&gt;).</source>
          <target state="translated">더 이상 사용되지 않는 기능으로 경고가 발생하며 향후 Perl 버전에서 제거 될 예정입니다. &lt;code&gt;qr/ ^ [[:space:]]+ $ /x&lt;/code&gt; 에 대한 일치와 매우 유사하며 대신 사용하도록 변환해야합니다. 이 함수는 1) UTF-8 인코딩 문자열을 올바르게 처리하지 않기 때문에 사용되지 않습니다. 2) 입력이 빈 문자열 인 경우에도 &lt;code&gt;TRUE&lt;/code&gt; 를 반환 합니다 . 함수 리턴은 항상 현재 로케일을 기반으로하는 반면, 로케일 규칙을 사용하는 것은 효과의 pragma 및 패턴 수정자를 기반으로 정규식에서 선택 사항입니다 ( &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;perlre의 &lt;/a&gt;&lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;문자 세트 수정 자&lt;/a&gt; 및 어떤 문자 세트 수정자가 영향을 미칩니 까? perlre에서 ).</target>
        </trans-unit>
        <trans-unit id="9eae66c65e71bd3522a0efba8a80f39c5e45c530" translate="yes" xml:space="preserve">
          <source>Deprecated function whose use raises a warning, and which is slated to be removed in a future Perl version. It is very similar to matching against &lt;code&gt;qr/ ^ [[:upper:]]+ $ /x&lt;/code&gt; , which you should convert to use instead. The function is deprecated because 1) it doesn't handle UTF-8 encoded strings properly; and 2) it returns &lt;code&gt;TRUE&lt;/code&gt; even if the input is the empty string. The function return is always based on the current locale, whereas using locale rules is optional with the regular expression, based on pragmas in effect and pattern modifiers (see &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;Character set modifiers in perlre&lt;/a&gt; and &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect? in perlre&lt;/a&gt;).</source>
          <target state="translated">더 이상 사용되지 않는 기능으로 경고가 발생하며 향후 Perl 버전에서 제거 될 예정입니다. &lt;code&gt;qr/ ^ [[:upper:]]+ $ /x&lt;/code&gt; 에 대한 일치와 매우 유사하며 대신 사용하도록 변환해야합니다. 이 함수는 1) UTF-8 인코딩 문자열을 올바르게 처리하지 않기 때문에 사용되지 않습니다. 2) 입력이 빈 문자열 인 경우에도 &lt;code&gt;TRUE&lt;/code&gt; 를 반환 합니다 . 함수 리턴은 항상 현재 로케일을 기반으로하는 반면, 로케일 규칙을 사용하는 것은 효과의 pragma 및 패턴 수정자를 기반으로 정규식에서 선택 사항입니다 ( &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;perlre의 &lt;/a&gt;&lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;문자 세트 수정 자&lt;/a&gt; 및 어떤 문자 세트 수정자가 영향을 미칩니 까? perlre에서 ).</target>
        </trans-unit>
        <trans-unit id="d712a49c6b2099faded0c3c79a409ab8379a0967" translate="yes" xml:space="preserve">
          <source>Deprecated function whose use raises a warning, and which is slated to be removed in a future Perl version. It is very similar to matching against &lt;code&gt;qr/ ^ [[:xdigit:]]+ $ /x&lt;/code&gt; , which you should convert to use instead. The function is deprecated because 1) it doesn't handle UTF-8 encoded strings properly; and 2) it returns &lt;code&gt;TRUE&lt;/code&gt; even if the input is the empty string. The function return is always based on the current locale, whereas using locale rules is optional with the regular expression, based on pragmas in effect and pattern modifiers (see &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;Character set modifiers in perlre&lt;/a&gt; and &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect? in perlre&lt;/a&gt;).</source>
          <target state="translated">더 이상 사용되지 않는 기능으로 경고가 발생하며 향후 Perl 버전에서 제거 될 예정입니다. &lt;code&gt;qr/ ^ [[:xdigit:]]+ $ /x&lt;/code&gt; 에 대한 일치와 매우 유사하며 대신 사용하도록 변환해야합니다. 이 함수는 1) UTF-8 인코딩 문자열을 올바르게 처리하지 않기 때문에 사용되지 않습니다. 2) 입력이 빈 문자열 인 경우에도 &lt;code&gt;TRUE&lt;/code&gt; 를 반환 합니다 . 함수 리턴은 항상 현재 로케일을 기반으로하는 반면, 로케일 규칙을 사용하는 것은 효과의 pragma 및 패턴 수정자를 기반으로 정규식에서 선택 사항입니다 ( &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;perlre의 &lt;/a&gt;&lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;문자 세트 수정 자&lt;/a&gt; 및 어떤 문자 세트 수정자가 영향을 미칩니 까 perlre에서 ).</target>
        </trans-unit>
        <trans-unit id="77e5e77915f87f5eba641b256db1ec0d6448e365" translate="yes" xml:space="preserve">
          <source>Deprecated in Perl 5.</source>
          <target state="translated">Perl 5에서 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0447c363038e418e07f3246f8ca43e5cfd53e211" translate="yes" xml:space="preserve">
          <source>Deprecated in Perl 5.10.0</source>
          <target state="translated">Perl 5.10.0에서 사용되지 않음</target>
        </trans-unit>
        <trans-unit id="42f0ac3a73aa4ea8f831dc4a897f203beaf75865" translate="yes" xml:space="preserve">
          <source>Deprecated in Perl v5.12.0.</source>
          <target state="translated">Perl v5.12.0에서 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c719d3d031098df68eeee6d64494f02905ae30e2" translate="yes" xml:space="preserve">
          <source>Deprecated method, but does the same as service_check() method.</source>
          <target state="translated">더 이상 사용되지 않는 메소드이지만 service_check () 메소드와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="f82cf002f6b4c932fb0a62e044c473c42a57f99c" translate="yes" xml:space="preserve">
          <source>Deprecated method. Use libscan instead.</source>
          <target state="translated">더 이상 사용되지 않는 방법. 대신 libscan을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="296aaa10f5a1032a3fc94ecfb0996dab5a0c7b1f" translate="yes" xml:space="preserve">
          <source>Deprecated module to load Locale::Maketext utf8 code</source>
          <target state="translated">Locale :: Maketext utf8 코드를로드하기 위해 사용되지 않는 모듈</target>
        </trans-unit>
        <trans-unit id="b5972c72225aadd112c116405b2c9a8c61f8be67" translate="yes" xml:space="preserve">
          <source>Deprecated. Please use &lt;code&gt;is_actual_ok&lt;/code&gt; instead.</source>
          <target state="translated">더 이상 사용되지 않습니다. 사용하십시오 &lt;code&gt;is_actual_ok&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="f480918eabb96e1b569421fef2e3056b6e5a48a3" translate="yes" xml:space="preserve">
          <source>Deprecated. Please use &lt;code&gt;is_ok&lt;/code&gt; instead.</source>
          <target state="translated">더 이상 사용되지 않습니다. 사용하십시오 &lt;code&gt;is_ok&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="8bab31dacd225be342dc45946fc045df33a2d1c4" translate="yes" xml:space="preserve">
          <source>Deprecated. Use &lt;code&gt;is_good_plan&lt;/code&gt; instead.</source>
          <target state="translated">더 이상 사용되지 않습니다. 대신 &lt;code&gt;is_good_plan&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4880df7da732b64649d73fa94f900ec9f18233e3" translate="yes" xml:space="preserve">
          <source>Deprecating a variable announces the intent of the perl maintainers to eventually remove the variable from the language. It may still be available despite its status. Using a deprecated variable triggers a warning.</source>
          <target state="translated">변수를 사용하지 않으면 펄 관리자가 언어에서 변수를 제거하려는 의도를 알 수 있습니다. 상태에도 불구하고 여전히 사용 가능할 수 있습니다. 더 이상 사용되지 않는 변수를 사용하면 경고가 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="be163eb89f0ec6f8bfe369849331f8a896683818" translate="yes" xml:space="preserve">
          <source>Dereference-address operator. (Perl's prefix dereferencing operators are typed: &lt;code&gt;$&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; , and &lt;code&gt;&amp;amp;&lt;/code&gt; .)</source>
          <target state="translated">역 참조 주소 연산자. Perl의 접두사 역 참조 연산자는 &lt;code&gt;$&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; 및 &lt;code&gt;&amp;amp;&lt;/code&gt; 형식 입니다.</target>
        </trans-unit>
        <trans-unit id="a13dba076abe09205f4d6530500f95233f3d8b89" translate="yes" xml:space="preserve">
          <source>Dereferences an RV to return the SV.</source>
          <target state="translated">SV를 반환하기 위해 RV를 역 참조합니다.</target>
        </trans-unit>
        <trans-unit id="1482ff3cb39b2ab2879a6e8a1d98292788d82730" translate="yes" xml:space="preserve">
          <source>Deregistration is done in this case by calling event_loop with &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; as its parameter:</source>
          <target state="translated">이 경우 등록 취소는 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 매개 변수로 사용하여 event_loop를 호출하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="0ece715d7bfa3a1e4b4b7c2716133b08b5012fe3" translate="yes" xml:space="preserve">
          <source>Derived Normalization Properties</source>
          <target state="translated">파생 정규화 속성</target>
        </trans-unit>
        <trans-unit id="46565153346c49e93798bd916a2902e7376b3a49" translate="yes" xml:space="preserve">
          <source>Derived from FileHandle.pm by Graham Barr &amp;lt;</source>
          <target state="translated">Graham Barr가 FileHandle.pm에서 파생 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="bc5d76c2188dda3e644ef5539acfe2ee659fc494" translate="yes" xml:space="preserve">
          <source>Derived from FileHandle.pm by Graham Barr &amp;lt;gbarr@pobox.com&amp;gt;</source>
          <target state="translated">Graham Barr &amp;lt;gbarr@pobox.com&amp;gt;이 FileHandle.pm에서 파생 함</target>
        </trans-unit>
        <trans-unit id="6f61cc4cb53719b61daa460c7f629eaad048da52" translate="yes" xml:space="preserve">
          <source>Derived from many sources. Some would say</source>
          <target state="translated">많은 출처에서 파생되었습니다. 어떤 사람들은</target>
        </trans-unit>
        <trans-unit id="f27ae512bfe1f4a041a1bece8dc33e39ce992aa0" translate="yes" xml:space="preserve">
          <source>DerivedNormalizationProps.txt</source>
          <target state="translated">DerivedNormalizationProps.txt</target>
        </trans-unit>
        <trans-unit id="c4477abcc61a8e8691692bd5b2f94edfbc46fd9d" translate="yes" xml:space="preserve">
          <source>Describe what you're doing and how you're doing it, using normal Perl comments.</source>
          <target state="translated">일반적인 Perl 주석을 사용하여 수행중인 작업과 수행 방식을 설명하십시오.</target>
        </trans-unit>
        <trans-unit id="34b3e166e1301e0606954d6a55611015e6cbfc1c" translate="yes" xml:space="preserve">
          <source>Describes the format and contents of</source>
          <target state="translated">형식과 내용을 설명합니다</target>
        </trans-unit>
        <trans-unit id="96a98270561c02f5c77d9be37f677cf453421b77" translate="yes" xml:space="preserve">
          <source>Descrip.MMS</source>
          <target state="translated">Descrip.MMS</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="19d71724ac39d6a9fdd91c9d7584648481c9ba90" translate="yes" xml:space="preserve">
          <source>Descriptive editing term&amp;mdash;short for &amp;ldquo;awkward&amp;rdquo;. Also coincidentally refers to a venerable text-processing language from which Perl derived some of its high-level ideas.</source>
          <target state="translated">설명적인 편집 용어 &amp;mdash;&amp;ldquo;어색한 것&amp;rdquo;의 줄임말입니다. 또한 우연히도 Perl이 고급 아이디어를 도출 한 훌륭한 텍스트 처리 언어를 말합니다.</target>
        </trans-unit>
        <trans-unit id="092d175f31c309d86e54ac4890791b68f8011efb" translate="yes" xml:space="preserve">
          <source>Designed to be a method call, and to be overridden by a derived class (i.e. a class which has DynaLoader in its @ISA). The definition in DynaLoader itself returns 0, which produces standard behavior from dl_load_file().</source>
          <target state="translated">메서드 호출이되도록 설계되었으며 파생 클래스 (예 : @ISA에 DynaLoader가있는 클래스)로 재정의됩니다. DynaLoader 자체의 정의는 0을 반환하여 dl_load_file ()에서 표준 동작을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="59aac4a2c7e327e45b17c4aed3092d9662863e7d" translate="yes" xml:space="preserve">
          <source>Designing your API</source>
          <target state="translated">API 디자인</target>
        </trans-unit>
        <trans-unit id="2304f50cca1805cd55f5d31750b7fa633b66fe80" translate="yes" xml:space="preserve">
          <source>Desired permission for directories. Defaults to &lt;code&gt;755&lt;/code&gt; .</source>
          <target state="translated">디렉토리에 대한 원하는 권한. 기본값은 &lt;code&gt;755&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="533cafeb3aa07a126f4d3b8498ce1b5a7bd7a9da" translate="yes" xml:space="preserve">
          <source>Desired permission for executable files. Defaults to &lt;code&gt;755&lt;/code&gt; .</source>
          <target state="translated">실행 파일에 대한 원하는 권한 기본값은 &lt;code&gt;755&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7a3e68ecf77d35df71a723c0bb9b9d6b0bcf091b" translate="yes" xml:space="preserve">
          <source>Desired permission for read/writable files. Defaults to &lt;code&gt;644&lt;/code&gt; .</source>
          <target state="translated">읽기 / 쓰기 가능 파일에 대한 원하는 권한. 기본값은 &lt;code&gt;644&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="369c7a7ce11a967333493247a17fefcaf8782924" translate="yes" xml:space="preserve">
          <source>Despite its name, this calls your system's default documentation viewer on the given page, or on the viewer itself if</source>
          <target state="translated">이름에도 불구하고 지정된 페이지 또는 시스템 자체의 경우 뷰어의 시스템 기본 문서 뷰어를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="c89708df88c5d908f88da0373b3c5448a6138264" translate="yes" xml:space="preserve">
          <source>Despite the existence of &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, there are still three places where the &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; operator still shines. In fact, in these three places, you</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 존재에도 불구하고, 여전히 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 운영자가 빛나는 세 곳 이 있습니다. 사실이 세 곳에서</target>
        </trans-unit>
        <trans-unit id="5907dde0a5903ebac0baff736f53c485d9ebcc11" translate="yes" xml:space="preserve">
          <source>Despite the name of the &lt;code&gt;finddepth()&lt;/code&gt; function, both &lt;code&gt;find()&lt;/code&gt; and &lt;code&gt;finddepth()&lt;/code&gt; perform a depth-first search of the directory hierarchy.</source>
          <target state="translated">&lt;code&gt;finddepth()&lt;/code&gt; 함수 의 이름에도 불구하고 &lt;code&gt;find()&lt;/code&gt; 및 &lt;code&gt;finddepth()&lt;/code&gt; 는 디렉토리 계층 구조의 깊이 우선 검색을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="2a5924278d8b7657f3aeb8649ead9475eab91d8f" translate="yes" xml:space="preserve">
          <source>Despite their suggestions in earlier versions of this document the macros &lt;code&gt;(X)PUSH[iunp]&lt;/code&gt; are</source>
          <target state="translated">이 문서의 이전 버전에서의 제안에도 불구하고 매크로 &lt;code&gt;(X)PUSH[iunp]&lt;/code&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bcf6c17f9da73e467a073ac5e6e487e5bdc36429" translate="yes" xml:space="preserve">
          <source>Destructors</source>
          <target state="translated">Destructors</target>
        </trans-unit>
        <trans-unit id="78fbdf14ab60724c2e9f95d677204576dc399f05" translate="yes" xml:space="preserve">
          <source>Destructors may not be called on objects if those objects still exist at global destruction time. If the destructors must be called, make sure there are no circular references and that nothing is referencing the objects, before the program ends.</source>
          <target state="translated">오브젝트가 여전히 전역 파괴 시간에 존재하는 경우 오브젝트에서 소멸자가 호출되지 않을 수 있습니다. 소멸자를 호출해야하는 경우 프로그램이 종료되기 전에 순환 참조가없고 오브젝트를 참조하는 것이 없는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="7f13a5e8324201e8439f86f9e267530c519b5fa1" translate="yes" xml:space="preserve">
          <source>Detach from the shared memory segment that previously has been attached to. Returns true if successful, or false on error. See &lt;a href=&quot;http://search.cpan.org/perldoc/shmdt&quot;&gt;shmdt&lt;/a&gt;.</source>
          <target state="translated">이전에 연결된 공유 메모리 세그먼트에서 분리하십시오. 성공하면 true를, 오류이면 false를 반환합니다. &lt;a href=&quot;http://search.cpan.org/perldoc/shmdt&quot;&gt;shmdt를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f6d104f83eda0e6841179588c742c21e25fb6240" translate="yes" xml:space="preserve">
          <source>Detach the shared memory segment located at the address specified by ADDR from the address space of the calling process. See &lt;a href=&quot;http://search.cpan.org/perldoc/shmdt&quot;&gt;shmdt&lt;/a&gt;.</source>
          <target state="translated">호출 프로세스의 주소 공간에서 ADDR에 의해 지정된 주소에있는 공유 메모리 세그먼트를 분리하십시오. &lt;a href=&quot;http://search.cpan.org/perldoc/shmdt&quot;&gt;shmdt를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="524606f1e7f47ed54a2dc7c2ed309c5733e4790f" translate="yes" xml:space="preserve">
          <source>Detailed description of each of the command-line options taken by the program. This should be separate from the description for the use of parsers like &lt;a href=&quot;pod/usage&quot;&gt;Pod::Usage&lt;/a&gt;. This is normally presented as a list, with each option as a separate &lt;code&gt;=item&lt;/code&gt; . The specific option string should be enclosed in B&amp;lt;&amp;gt;. Any values that the option takes should be enclosed in I&amp;lt;&amp;gt;. For example, the section for the option &lt;b&gt;--section&lt;/b&gt;=</source>
          <target state="translated">프로그램이 취하는 각 명령 행 옵션에 대한 자세한 설명. 이것은 &lt;a href=&quot;pod/usage&quot;&gt;Pod :: Usage&lt;/a&gt; 와 같은 구문 분석기 사용에 대한 설명과 분리되어야합니다 . 이것은 일반적으로 목록으로 표시되며 각 옵션은 별도의 &lt;code&gt;=item&lt;/code&gt; 입니다. 특정 옵션 문자열은 B &amp;lt;&amp;gt;로 묶어야합니다. 옵션이 취하는 모든 값은 I &amp;lt;&amp;gt;로 묶어야합니다. 예를 들어 &lt;b&gt;--section&lt;/b&gt; = 옵션에 대한 섹션</target>
        </trans-unit>
        <trans-unit id="fe13e56081ddb095d18e9d96165e4c91a787dd78" translate="yes" xml:space="preserve">
          <source>Detailed documentation about modules can be found at: &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;, &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt;, &lt;a href=&quot;perlmodstyle&quot;&gt;perlmodstyle&lt;/a&gt;.</source>
          <target state="translated">: 모듈에 대한 자세한 문서에서 찾을 수 있습니다 &lt;a href=&quot;perlmod&quot;&gt;perlmod를&lt;/a&gt; , &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; , &lt;a href=&quot;perlmodstyle&quot;&gt;perlmodstyle&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="48efd59016764ae34dbd4dd35254250b9ade50c2" translate="yes" xml:space="preserve">
          <source>Detailed info about trie compilation.</source>
          <target state="translated">트라이 컴파일에 대한 자세한 정보.</target>
        </trans-unit>
        <trans-unit id="48a5bf693bd8174668fcec90fe1c7747773cff6b" translate="yes" xml:space="preserve">
          <source>Detailed instructions on how to build and install perl extension modules, including XS-type modules, is included. See 'BUILDING AND INSTALLING MODULES'.</source>
          <target state="translated">XS 유형 모듈을 포함하여 perl 확장 모듈을 빌드하고 설치하는 방법에 대한 자세한 지침이 포함되어 있습니다. '모듈 구축 및 설치'를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="971ecb47b81b9e3ebb8421ed26268b0335343299" translate="yes" xml:space="preserve">
          <source>Detailed signal management. This uses &lt;code&gt;POSIX::SigAction&lt;/code&gt; objects for the &lt;code&gt;action&lt;/code&gt; and &lt;code&gt;oldaction&lt;/code&gt; arguments (the oldaction can also be just a hash reference). Consult your system's &lt;code&gt;sigaction&lt;/code&gt; manpage for details, see also &lt;code&gt;POSIX::SigRt&lt;/code&gt; .</source>
          <target state="translated">자세한 신호 관리. 이것은 &lt;code&gt;action&lt;/code&gt; 및 &lt;code&gt;oldaction&lt;/code&gt; 인수에 &lt;code&gt;POSIX::SigAction&lt;/code&gt; 오브젝트를 사용합니다 (oldaction은 해시 참조 일 수도 있습니다). 자세한 내용은 시스템의 &lt;code&gt;sigaction&lt;/code&gt; 맨 페이지를 참조하십시오 . &lt;code&gt;POSIX::SigRt&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0c9fa89519b1cc82f7ef4510c084ac4535cbb9b1" translate="yes" xml:space="preserve">
          <source>Details are in &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;Quote and Quote-like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;perlop의 Quote 및 Quote-like Operators에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ba741c6d40d9b34740b66e9f99ec546651895d0" translate="yes" xml:space="preserve">
          <source>Details changes to Locale::Codes</source>
          <target state="translated">로케일 :: 코드 세부 사항 변경</target>
        </trans-unit>
        <trans-unit id="79ba379e83c3a5e1a2d0279f940c57dc6c7027f0" translate="yes" xml:space="preserve">
          <source>Detect the user's language preferences</source>
          <target state="translated">사용자의 언어 기본 설정 감지</target>
        </trans-unit>
        <trans-unit id="4e04b164f775f2394cd7b257c789eeab3703bf40" translate="yes" xml:space="preserve">
          <source>Determination of Perl Library and Installation Locations</source>
          <target state="translated">Perl 라이브러리 및 설치 위치 결정</target>
        </trans-unit>
        <trans-unit id="428b80cb8395cadc1a038a4e4bdb2355d7bb3c54" translate="yes" xml:space="preserve">
          <source>Determination of whether $BSD_STYLE should be set is left as an exercise to the reader.</source>
          <target state="translated">$ BSD_STYLE 설정 여부 결정은 독자에게 연습으로 남습니다.</target>
        </trans-unit>
        <trans-unit id="25d8f9f38f16f8b5a3c700d3bd4a5cd28a740860" translate="yes" xml:space="preserve">
          <source>Determine if the server supports the specified feature. The return value is a list of lines the server responded with to describe the options that it supports for the given feature. If the feature is unsupported then the empty list is returned.</source>
          <target state="translated">서버가 지정된 기능을 지원하는지 확인하십시오. 리턴 값은 주어진 기능에 대해 지원하는 옵션을 설명하기 위해 서버가 응답 한 행 목록입니다. 기능이 지원되지 않으면 빈 목록이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="46c27646774eae185d5079b386367766995dfee9" translate="yes" xml:space="preserve">
          <source>Determine libraries to use and how to use them</source>
          <target state="translated">사용할 라이브러리 및 사용 방법 결정</target>
        </trans-unit>
        <trans-unit id="bfbb294be56602dd8d5e0f86c6b7c3dc8fd0ef0f" translate="yes" xml:space="preserve">
          <source>Determine the full paths (including file suffix) of one or more loadable files given their generic names and optionally one or more directories. Searches directories in @dl_library_path by default and returns an empty list if no files were found.</source>
          <target state="translated">일반 이름과 선택적으로 하나 이상의 디렉토리가 제공된 하나 이상의로드 가능한 파일의 전체 경로 (파일 접미사 포함)를 결정하십시오. 기본적으로 @dl_library_path에서 디렉토리를 검색하고 파일이 없으면 빈 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c47d159fd2f7d84a2dc5b895afa17d3e1c470e9d" translate="yes" xml:space="preserve">
          <source>Determine whether a file is native to Cygwin by checking whether it resides inside the Cygwin installation (using Windows paths). If so, use &lt;code&gt;ExtUtils::MM_Unix&lt;/code&gt; to determine if it may be a command. Otherwise use the tests from &lt;code&gt;ExtUtils::MM_Win32&lt;/code&gt; .</source>
          <target state="translated">파일이 Cygwin 설치 내에 있는지 (Windows 경로 사용) 여부를 확인하여 파일이 Cygwin에 고유한지 여부를 판별하십시오. 그렇다면 &lt;code&gt;ExtUtils::MM_Unix&lt;/code&gt; 를 사용 하여 명령인지 확인하십시오. 그렇지 않으면 &lt;code&gt;ExtUtils::MM_Win32&lt;/code&gt; 의 테스트를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a35731d2a8f0fd508c5b03e1f3c340b65af8b100" translate="yes" xml:space="preserve">
          <source>Determines if man pages should be generated and initializes MAN1PODS and MAN3PODS as appropriate.</source>
          <target state="translated">매뉴얼 페이지를 생성해야하는지 결정하고 MAN1PODS 및 MAN3PODS를 적절히 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="32b2b5cefa4d496f2ffa711bf6d062b35a6183bc" translate="yes" xml:space="preserve">
          <source>Determines if the given &lt;code&gt;$thing&lt;/code&gt; can be used as a filehandle.</source>
          <target state="translated">주어진 &lt;code&gt;$thing&lt;/code&gt; 을 파일 핸들로 사용할 수 있는지 여부를 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="81c97d633f09f436c3551fc2f985b2dd31ceb89b" translate="yes" xml:space="preserve">
          <source>Determines if the two hashes contain the same keys and values. This is a deep check.</source>
          <target state="translated">두 해시에 동일한 키와 값이 포함되어 있는지 확인합니다. 이것은 철저한 점검입니다.</target>
        </trans-unit>
        <trans-unit id="02bc22cbed7ebf5c21902f1d116056eb9bbd8381" translate="yes" xml:space="preserve">
          <source>Determines the &lt;a href=&quot;../term/ansicolor&quot;&gt;Term::ANSIColor&lt;/a&gt; for the failure in case it is successful. This color defaults to &lt;code&gt;'red'&lt;/code&gt; .</source>
          <target state="translated">실패한 경우에 대한 &lt;a href=&quot;../term/ansicolor&quot;&gt;Term :: ANSIColor&lt;/a&gt; 를 판별합니다 . 이 색상의 기본값은 &lt;code&gt;'red'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="46421b429d7fbec4c32a7efe5539900fa9227686" translate="yes" xml:space="preserve">
          <source>Determines the &lt;a href=&quot;../term/ansicolor&quot;&gt;Term::ANSIColor&lt;/a&gt; for the summary in case it is successful. This color defaults to &lt;code&gt;'green'&lt;/code&gt; .</source>
          <target state="translated">성공적인 경우 요약 &lt;a href=&quot;../term/ansicolor&quot;&gt;: Term :: ANSIColor&lt;/a&gt; 를 결정합니다 . 이 색상의 기본값은 &lt;code&gt;'green'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="99525db85549ac64cdd5cb889d480f43dfc76de6" translate="yes" xml:space="preserve">
          <source>Determines the accessibility of a file.</source>
          <target state="translated">파일의 접근성을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="0ac6e93aa78866241a9a1ea97a746deee7e73a8e" translate="yes" xml:space="preserve">
          <source>Determines typemaps, xsubpp version, prototype behaviour.</source>
          <target state="translated">타입 맵, xsubpp 버전, 프로토 타입 동작을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="f07a1f637abae6218e8a7802badc87cffd6df457" translate="yes" xml:space="preserve">
          <source>Determines whether you do the left &lt;b&gt;operator&lt;/b&gt; first or the right &lt;b&gt;operator&lt;/b&gt; first when you have &amp;ldquo;A &lt;b&gt;operator&lt;/b&gt; B &lt;b&gt;operator&lt;/b&gt; C&amp;rdquo;, and the two operators are of the same precedence. Operators like &lt;code&gt;+&lt;/code&gt; are left associative, while operators like &lt;code&gt;**&lt;/code&gt; are right associative. See Camel chapter 3, &amp;ldquo;Unary and Binary Operators&amp;rdquo; for a list of operators and their associativity.</source>
          <target state="translated">&amp;ldquo;A &lt;b&gt;연산자&lt;/b&gt; B &lt;b&gt;연산자&lt;/b&gt; C&amp;rdquo;가 있고 두 연산자의 우선 순위가 동일한 경우 왼쪽 &lt;b&gt;연산자를&lt;/b&gt; 먼저 수행할지 오른쪽 &lt;b&gt;연산자를&lt;/b&gt; 먼저 수행할지 결정합니다 . &lt;code&gt;+&lt;/code&gt; 와 같은 연산자 는 연관되어 있고 &lt;code&gt;**&lt;/code&gt; 와 같은 연산자 는 오른쪽 연관입니다. 연산자와 그 연관성에 대해서는 Camel 3 장, &quot;단항 및 이항 연산자&quot;를 참조하십시오.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d1c8bafa598045542a6e12bdae08698fa56ba1b8" translate="yes" xml:space="preserve">
          <source>Determines which of the sets of installation directories to choose: perl, site or vendor. Defaults to site.</source>
          <target state="translated">선택할 설치 디렉토리 세트 (perl, site 또는 vendor)를 결정합니다. 기본값은 사이트입니다.</target>
        </trans-unit>
        <trans-unit id="bba5b2e65a661d27394fb8c061d3d51455420899" translate="yes" xml:space="preserve">
          <source>Determining the Context</source>
          <target state="translated">상황 결정</target>
        </trans-unit>
        <trans-unit id="3ecab9eb72cc6dfc1bcb8e4baecb3e17d8edcf33" translate="yes" xml:space="preserve">
          <source>Devel.U</source>
          <target state="translated">Devel.U</target>
        </trans-unit>
        <trans-unit id="d8c39aea2543b8523b0f33dbb117b8a3d9253fb8" translate="yes" xml:space="preserve">
          <source>Devel::DProf</source>
          <target state="translated">Devel::DProf</target>
        </trans-unit>
        <trans-unit id="ccde7e8b696b5ea06bba6178d203f16332d8acef" translate="yes" xml:space="preserve">
          <source>Devel::FastProf</source>
          <target state="translated">Devel::FastProf</target>
        </trans-unit>
        <trans-unit id="11215cfa0c659675e0e4ea40e3abc5e714feee1f" translate="yes" xml:space="preserve">
          <source>Devel::NYTProf</source>
          <target state="translated">Devel::NYTProf</target>
        </trans-unit>
        <trans-unit id="93fefc93ea4e5ce72e46483e30bdcdb72752bc35" translate="yes" xml:space="preserve">
          <source>Devel::PPPort</source>
          <target state="translated">Devel::PPPort</target>
        </trans-unit>
        <trans-unit id="7ffae19dcafff8088943ef185c49a680d59a15ac" translate="yes" xml:space="preserve">
          <source>Devel::PPPort - Perl/Pollution/Portability</source>
          <target state="translated">개발 :: PPPort-펄 / 오염 / 이동성</target>
        </trans-unit>
        <trans-unit id="3921057b50b0060084d8d65b7996993cf1ed9750" translate="yes" xml:space="preserve">
          <source>Devel::Peek</source>
          <target state="translated">Devel::Peek</target>
        </trans-unit>
        <trans-unit id="e14a96c568c781af1b5e318bd4b44427491f52d9" translate="yes" xml:space="preserve">
          <source>Devel::Peek - A data debugging tool for the XS programmer</source>
          <target state="translated">Devel :: Peek-XS 프로그래머를위한 데이터 디버깅 도구</target>
        </trans-unit>
        <trans-unit id="591a540c3f692dc8379dc38f7e57b50c1e10292e" translate="yes" xml:space="preserve">
          <source>Devel::Peek contains functions which allows raw Perl datatypes to be manipulated from a Perl script. This is used by those who do XS programming to check that the data they are sending from C to Perl looks as they think it should look. The trick, then, is to know what the raw datatype is supposed to look like when it gets to Perl. This document offers some tips and hints to describe good and bad raw data.</source>
          <target state="translated">Devel :: Peek에는 원시 Perl 데이터 유형을 Perl 스크립트에서 조작 할 수있는 기능이 있습니다. 이것은 XS 프로그래밍을 수행하는 사람들이 C에서 Perl로 보내는 데이터가 보이는 것처럼 보이는지 확인하는 데 사용됩니다. 따라서 트릭은 원시 데이터 유형이 Perl에 도달했을 때 어떤 모양이되어야하는지 아는 것입니다. 이 문서는 좋은 원시 데이터와 나쁜 원시 데이터를 설명하는 몇 가지 팁과 힌트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="db1f06d5f74de3011e9cc4bc49d43cef041da2cf" translate="yes" xml:space="preserve">
          <source>Devel::Peek supplies a &lt;code&gt;Dump()&lt;/code&gt; function which can dump a raw Perl datatype, and &lt;code&gt;mstat(&quot;marker&quot;)&lt;/code&gt; function to report on memory usage (if perl is compiled with corresponding option). The function DeadCode() provides statistics on the data &quot;frozen&quot; into inactive &lt;code&gt;CV&lt;/code&gt; . Devel::Peek also supplies &lt;code&gt;SvREFCNT()&lt;/code&gt; which can query reference counts on SVs. This document will take a passive, and safe, approach to data debugging and for that it will describe only the &lt;code&gt;Dump()&lt;/code&gt; function.</source>
          <target state="translated">Devel :: Peek 는 원시 Perl 데이터 유형을 덤프 할 수 있는 &lt;code&gt;Dump()&lt;/code&gt; 함수와 &lt;code&gt;mstat(&quot;marker&quot;)&lt;/code&gt; 함수를 제공하여 메모리 사용을보고합니다 (perl이 해당 옵션으로 컴파일 된 경우). DeadCode () 함수는 &quot;동결 된&quot;데이터에 대한 통계를 비활성 &lt;code&gt;CV&lt;/code&gt; 로 제공 합니다. Devel :: Peek는 SV의 참조 카운트를 쿼리 할 수있는 &lt;code&gt;SvREFCNT()&lt;/code&gt; 도 제공 합니다. 이 문서는 데이터 디버깅에 대해 수동적이고 안전한 수동 접근 방식을 취하므로 &lt;code&gt;Dump()&lt;/code&gt; 함수 만 설명 합니다.</target>
        </trans-unit>
        <trans-unit id="dd06cacef5c6992e80eae6f0b88092dd28458a5a" translate="yes" xml:space="preserve">
          <source>Devel::Profiler</source>
          <target state="translated">Devel::Profiler</target>
        </trans-unit>
        <trans-unit id="4b6535e01c52786d4e3f3ca2b00ca3272e9f6d30" translate="yes" xml:space="preserve">
          <source>Devel::SelfStubber</source>
          <target state="translated">Devel::SelfStubber</target>
        </trans-unit>
        <trans-unit id="b5469167c418142a031a1a19dcd7b0ac06472cae" translate="yes" xml:space="preserve">
          <source>Devel::SelfStubber - generate stubs for a SelfLoading module</source>
          <target state="translated">Devel :: SelfStubber-자체로드 모듈에 대한 스텁 생성</target>
        </trans-unit>
        <trans-unit id="c12151c156a6bb57f46bf2cfabec163c1bfc0f60" translate="yes" xml:space="preserve">
          <source>Devel::SelfStubber prints the stubs you need to put in the module before the __DATA__ token (or you can get it to print the entire module with stubs correctly placed). The stubs ensure that if a method is called, it will get loaded. They are needed specifically for inherited autoloaded methods.</source>
          <target state="translated">Devel :: SelfStubber는 __DATA__ 토큰 이전에 모듈에 넣어야하는 스텁을 인쇄합니다 (또는 스텁이 올바르게 배치 된 전체 모듈을 인쇄하도록 할 수 있음). 스텁은 메소드가 호출되면로드되도록합니다. 상속 된 자동로드 된 메소드에 특별히 필요합니다.</target>
        </trans-unit>
        <trans-unit id="842dcd37ebf74b06348dc557d220529763bf8eb5" translate="yes" xml:space="preserve">
          <source>Devel::SmallProf</source>
          <target state="translated">Devel::SmallProf</target>
        </trans-unit>
        <trans-unit id="4c17aadf5117487aab7bc50cbf056caf3977cc31" translate="yes" xml:space="preserve">
          <source>Development</source>
          <target state="translated">Development</target>
        </trans-unit>
        <trans-unit id="d9ffe88162ace37c72e458ee67a70fb3d18d4395" translate="yes" xml:space="preserve">
          <source>Development Support</source>
          <target state="translated">개발 지원</target>
        </trans-unit>
        <trans-unit id="f0c7babf29efe97f8e794e98c4e99a03a18a4c41" translate="yes" xml:space="preserve">
          <source>Device major number in case of a special file</source>
          <target state="translated">특수 파일의 경우 장치 주 번호</target>
        </trans-unit>
        <trans-unit id="2c941665c705f296265e4a2b31a60000a96baced" translate="yes" xml:space="preserve">
          <source>Device minor number in case of a special file</source>
          <target state="translated">특수 파일의 경우 장치 부 번호</target>
        </trans-unit>
        <trans-unit id="ee7b51236ed970aee0667e1f1fe4a778ffb14074" translate="yes" xml:space="preserve">
          <source>Diagnostic messages derive from the</source>
          <target state="translated">진단 메시지는</target>
        </trans-unit>
        <trans-unit id="3af2279f9e306acd0a4644e2b0f2f48a1e06d8d9" translate="yes" xml:space="preserve">
          <source>Diagnostics</source>
          <target state="translated">Diagnostics</target>
        </trans-unit>
        <trans-unit id="e12e989f1fa699061a1906fb84c40da51f94d183" translate="yes" xml:space="preserve">
          <source>Diagnostics: - &quot;Illegal state option: %s&quot;</source>
          <target state="translated">진단 :- &quot;잘못된 상태 옵션 : % s&quot;</target>
        </trans-unit>
        <trans-unit id="24aeba6cea55e3491e6f6e028d622f79e9da9608" translate="yes" xml:space="preserve">
          <source>Did we mention that you should definitely consider using the &lt;b&gt;use warnings&lt;/b&gt; pragma?</source>
          <target state="translated">&lt;b&gt;사용 경고&lt;/b&gt; pragma &lt;b&gt;사용을&lt;/b&gt; 반드시 고려해야한다고 언급 했습니까 ?</target>
        </trans-unit>
        <trans-unit id="9b6cbb2dd2135deb31b16770182a2ec8c70c6f29" translate="yes" xml:space="preserve">
          <source>Did you really want to know? :-) For more gory details on getting regular expressions to work, have a look at &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;, &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt;, and to decode the mysterious labels (BOL and CURLYN, etc. above), see &lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt;.</source>
          <target state="translated">정말로 알고 싶었습니까? :-) 정규 표현식을 작동시키는 방법에 대한 자세한 내용은 &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; , &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt; 및 신비한 레이블 (위의 BOL 및 CURLYN 등)을 확인하십시오 . &lt;a href=&quot;perldebguts&quot;&gt;perldebguts를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c365b19f02fa9700446bb2dfae00cddef737c1ed" translate="yes" xml:space="preserve">
          <source>Did you run your programs with &lt;code&gt;-w&lt;/code&gt; switch? See &lt;a href=&quot;http://search.cpan.org/perldoc/Starting%20OS#2-(and-DOS)-programs-under-Perl&quot;&gt;2 (and DOS) programs under Perl in Starting OS&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;-w&lt;/code&gt; 스위치를 사용 하여 프로그램을 실행 했습니까 ? &lt;a href=&quot;http://search.cpan.org/perldoc/Starting%20OS#2-(and-DOS)-programs-under-Perl&quot;&gt;OS 시작의 Perl 아래 2 (및 DOS) 프로그램을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c44a0b6cfa2e8e8711c5a9b4665955570db35afc" translate="yes" xml:space="preserve">
          <source>Didn't anyone ever tell you web-page hit counters were useless? They don't count number of hits, they're a waste of time, and they serve only to stroke the writer's vanity. It's better to pick a random number; they're more realistic.</source>
          <target state="translated">웹 페이지 조회수 카운터가 쓸모 없다고 말한 사람이 없습니까? 그들은 적중 횟수를 세지 않고 시간 낭비이며 작가의 허영심을 쓰러 뜨리는 역할 만합니다. 난수를 선택하는 것이 좋습니다. 그들은 더 현실적입니다.</target>
        </trans-unit>
        <trans-unit id="de35dca213966232628ded8b499a88baf25eec19" translate="yes" xml:space="preserve">
          <source>Die on HUP, INT, PIPE or TERM, except don't change the behavior for signals which are already trapped or ignored:</source>
          <target state="translated">이미 갇히거나 무시 된 신호의 동작을 변경하지 않는 것을 제외하고 HUP, INT, PIPE 또는 TERM에서 죽습니다.</target>
        </trans-unit>
        <trans-unit id="0b65dd725b89443cd082d2b1fbb5c871c07b811a" translate="yes" xml:space="preserve">
          <source>Die on HUP, INT, PIPE or TERM:</source>
          <target state="translated">HUP, INT, PIPE 또는 TERM에서 다이 :</target>
        </trans-unit>
        <trans-unit id="7370d007d2f0750cfcb06f3ae1a311fa8ce10185" translate="yes" xml:space="preserve">
          <source>Die on INT or QUIT:</source>
          <target state="translated">INT 또는 QUIT에서 죽습니다 :</target>
        </trans-unit>
        <trans-unit id="de3e3f090fef16d61db17c82fcb979d37ca68a0d" translate="yes" xml:space="preserve">
          <source>Die on receipt one of an of the &lt;b&gt;normal-signals&lt;/b&gt; which is currently &lt;b&gt;untrapped&lt;/b&gt;, provide a stack trace on receipt of &lt;b&gt;any&lt;/b&gt; of the &lt;b&gt;error-signals&lt;/b&gt;:</source>
          <target state="translated">의 수신 된 하나의 다이에 &lt;b&gt;정상 신호를&lt;/b&gt; 현재 &lt;b&gt;포착되지 않은&lt;/b&gt; , 수신시 스택 트레이스를 제공하는 &lt;b&gt;임의&lt;/b&gt; 의 &lt;b&gt;에러 신호&lt;/b&gt; :</target>
        </trans-unit>
        <trans-unit id="ba441dab8e607c94b508525a17abee026d45b519" translate="yes" xml:space="preserve">
          <source>Dies if something fails. Does not return anything useful.</source>
          <target state="translated">무언가 실패하면 죽는다. 유용한 것을 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f81677da87b912ca4cbc2adcd260fa40bc3569e4" translate="yes" xml:space="preserve">
          <source>Dies on invalid arguments.</source>
          <target state="translated">유효하지 않은 인수로 사망합니다.</target>
        </trans-unit>
        <trans-unit id="ff49095a95255fd00fd15d75e6567dd8a12a4746" translate="yes" xml:space="preserve">
          <source>Dies with &quot;QUITing...&quot; if WM_QUIT message is obtained.</source>
          <target state="translated">WM_QUIT 메시지가 표시되면 &quot;QUITing ...&quot;으로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="4df44d1ca612254d8b6146ed208bbeb09ddfe82a" translate="yes" xml:space="preserve">
          <source>Dies with &lt;code&gt;@message&lt;/code&gt; but the message will appear to come from the point where the original test function was called (&lt;code&gt;$tb-&amp;gt;caller&lt;/code&gt; ).</source>
          <target state="translated">&lt;code&gt;@message&lt;/code&gt; 로 죽지 만 원래 테스트 함수가 호출 된 시점 ( &lt;code&gt;$tb-&amp;gt;caller&lt;/code&gt; ) 에서 메시지가 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="eb0b600e20a7af68665f367d76b7faa7b80ba746" translate="yes" xml:space="preserve">
          <source>Difference between &lt;code&gt;load&lt;/code&gt; and &lt;code&gt;autoload&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;load&lt;/code&gt; 와 &lt;code&gt;autoload&lt;/code&gt; 로드의 차이점</target>
        </trans-unit>
        <trans-unit id="1f4478706dbd396a43de3090b3f058233138f6af" translate="yes" xml:space="preserve">
          <source>Difference between load and autoload</source>
          <target state="translated">로드와 오토로드의 차이점</target>
        </trans-unit>
        <trans-unit id="af858e1241391fd569b50d644bb00507f74f4034" translate="yes" xml:space="preserve">
          <source>Differences</source>
          <target state="translated">Differences</target>
        </trans-unit>
        <trans-unit id="38024e12015fb8cbceae437a2c486569781a63ed" translate="yes" xml:space="preserve">
          <source>Differences from Perl 6</source>
          <target state="translated">Perl 6과의 차이점</target>
        </trans-unit>
        <trans-unit id="331cb030b664a4d11f924279069f94d488d3faa3" translate="yes" xml:space="preserve">
          <source>Different CPUs store integers and floating point numbers in different orders (called</source>
          <target state="translated">다른 CPU는 정수와 부동 소수점 숫자를 다른 순서로 저장합니다 (</target>
        </trans-unit>
        <trans-unit id="2bda7000c880740a37cbf94090331ac6cabf1bab" translate="yes" xml:space="preserve">
          <source>Different definitions of Perl are given in &lt;a href=&quot;perl&quot;&gt;perl&lt;/a&gt;, &lt;a href=&quot;perlfaq1&quot;&gt;perlfaq1&lt;/a&gt; and no doubt other places. From this we can determine that Perl is different things to different people, but that lots of people think it's at least worth writing about.</source>
          <target state="translated">Perl의 다른 정의는 &lt;a href=&quot;perl&quot;&gt;perl&lt;/a&gt; , &lt;a href=&quot;perlfaq1&quot;&gt;perlfaq1&lt;/a&gt; 및 다른 장소에서 제공됩니다. 이것으로부터 우리는 Perl이 다른 사람들과는 다른 것들이라고 결정할 수 있지만, 많은 사람들은 그것이 적어도 쓸만한 가치가 있다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="7dccaaf84bf4def2fd87e2d3e385599fbd55f83d" translate="yes" xml:space="preserve">
          <source>Different escape characters can be specified for different delimiters. For example, to specify that '/' is the escape for single quotes and '%' is the escape for double quotes:</source>
          <target state="translated">다른 분리 문자에 대해 다른 이스케이프 문자를 지정할 수 있습니다. 예를 들어, '/'가 작은 따옴표의 이스케이프이고 '%'는 큰 따옴표의 이스케이프임을 지정하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="f9a49cb812bf417ffcc0cc6f39c98fe84fa2ebdf" translate="yes" xml:space="preserve">
          <source>Different handles can have different buffering schemes. The &quot;top&quot; layer could be the &quot;mmap&quot; layer if reading disk files was quicker using &lt;code&gt;mmap&lt;/code&gt; than &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;. An &quot;unbuffered&quot; stream can be implemented simply by not having a buffer layer.</source>
          <target state="translated">핸들마다 버퍼링 방식이 다를 수 있습니다. 디스크 파일을 읽는 것이 &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 보다 &lt;code&gt;mmap&lt;/code&gt; 을 사용하는 것이 더 빠르면 &quot;top&quot;레이어는 &quot;mmap&quot;레이어가 될 수 있습니다 . 버퍼링되지 않은 &quot;버퍼링되지 않은&quot;스트림은 단순히 버퍼 레이어를 갖지 않고 구현 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee681ba258c7b2da3e8972edb7ba868618d14b60" translate="yes" xml:space="preserve">
          <source>Different implementations of threads</source>
          <target state="translated">스레드의 다른 구현</target>
        </trans-unit>
        <trans-unit id="e3379dfb99801372d7cddbcebddb248079f56470" translate="yes" xml:space="preserve">
          <source>Different low-level libraries use different formats to store the numbers. However, you should &lt;b&gt;NOT&lt;/b&gt; depend on the number having a specific format internally.</source>
          <target state="translated">다른 저수준 라이브러리는 다른 형식을 사용하여 숫자를 저장합니다. 그러나, 당신은해야 &lt;b&gt;하지&lt;/b&gt; 내부적으로 특정 형식을 갖는 수에 따라 달라집니다.</target>
        </trans-unit>
        <trans-unit id="968ef79ccdd769ce74761479fe855c0adf257d6a" translate="yes" xml:space="preserve">
          <source>Different packages may implement different levels of debug but a non-zero value results in copies of all commands and responses also being sent to STDERR.</source>
          <target state="translated">다른 패키지는 다른 수준의 디버그를 구현할 수 있지만 값이 0이 아닌 경우 모든 명령 및 응답의 사본이 STDERR로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="8f55cf4436cb1eaf5bfcf390f661558255ea8243" translate="yes" xml:space="preserve">
          <source>Differing widths can cause truncation even between platforms of equal endianness. The platform of shorter width loses the upper parts of the number. There is no good solution for this problem except to avoid transferring or storing raw binary numbers.</source>
          <target state="translated">너비가 다르면 엔디안이 동일한 플랫폼 간에도 잘림이 발생할 수 있습니다. 폭이 짧은 플랫폼은 숫자의 상단 부분을 잃습니다. 원시 이진 숫자를 전송하거나 저장하지 않는 것 외에는이 문제에 대한 좋은 해결책이 없습니다.</target>
        </trans-unit>
        <trans-unit id="248216e8bd5493fa776c21a71aab73557a333ad5" translate="yes" xml:space="preserve">
          <source>Dig into a bunch of modules to see how they're written. I'd suggest starting with &lt;a href=&quot;text/tabs&quot;&gt;Text::Tabs&lt;/a&gt;, since it's in the standard library and is nice and simple, and then looking at something a little more complex like &lt;a href=&quot;file/copy&quot;&gt;File::Copy&lt;/a&gt;. For object oriented code, &lt;code&gt;WWW::Mechanize&lt;/code&gt; or the &lt;code&gt;Email::*&lt;/code&gt; modules provide some good examples.</source>
          <target state="translated">작성 방법을 보려면 여러 모듈을 파헤쳐보십시오. 표준 라이브러리에 있고 멋지고 단순하기 때문에 &lt;a href=&quot;text/tabs&quot;&gt;Text :: Tabs로&lt;/a&gt; 시작하는 것이 좋습니다. 그런 다음 &lt;a href=&quot;file/copy&quot;&gt;File :: Copy&lt;/a&gt; 와 같은 좀 더 복잡한 것을 찾으십시오 . 객체 지향 코드의 경우 &lt;code&gt;WWW::Mechanize&lt;/code&gt; 또는 &lt;code&gt;Email::*&lt;/code&gt; 모듈이 좋은 예입니다.</target>
        </trans-unit>
        <trans-unit id="47fdd58bee4dc86df2b978107102a22b9c44345b" translate="yes" xml:space="preserve">
          <source>Digest</source>
          <target state="translated">Digest</target>
        </trans-unit>
        <trans-unit id="3bd067b7b9ba0e3842954b342b6e04b9508a77ac" translate="yes" xml:space="preserve">
          <source>Digest - Modules that calculate message digests</source>
          <target state="translated">다이제스트-메시지 다이제스트를 계산하는 모듈</target>
        </trans-unit>
        <trans-unit id="4c9cbdb7c115f81acd2c0edba69fb8ccce5eb45e" translate="yes" xml:space="preserve">
          <source>Digest base class</source>
          <target state="translated">다이제스트 기본 클래스</target>
        </trans-unit>
        <trans-unit id="3cd23511cf79299d4bb6923e10fe169a355c096e" translate="yes" xml:space="preserve">
          <source>Digest implementations might want to inherit from this class to get this implementations of the alternative</source>
          <target state="translated">다이제스트 구현은이 클래스에서 상속하여 대안의 구현을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2dd6f444a52ab6eb8232c6d9cf3d9b6b63eeb3b" translate="yes" xml:space="preserve">
          <source>Digest speed</source>
          <target state="translated">다이제스트 속도</target>
        </trans-unit>
        <trans-unit id="3263622a2f40559c02778432d6fee146399b6225" translate="yes" xml:space="preserve">
          <source>Digest::MD5</source>
          <target state="translated">Digest::MD5</target>
        </trans-unit>
        <trans-unit id="cc981cf57197ab4f6949f081dbfc7ac803760c7a" translate="yes" xml:space="preserve">
          <source>Digest::MD5 - Perl interface to the MD5 Algorithm</source>
          <target state="translated">Digest :: MD5-MD5 알고리즘에 대한 Perl 인터페이스</target>
        </trans-unit>
        <trans-unit id="10a5bb250c6cf1bbf42816d48c87400d9e093658" translate="yes" xml:space="preserve">
          <source>Digest::SHA</source>
          <target state="translated">Digest::SHA</target>
        </trans-unit>
        <trans-unit id="b4c92820a2ed37105ded93f12e77864cbec95f5b" translate="yes" xml:space="preserve">
          <source>Digest::SHA - Perl extension for SHA-1/224/256/384/512</source>
          <target state="translated">다이제스트 :: SHA-SHA-1 / 224 / 256 / 384 / 512 용 Perl 확장</target>
        </trans-unit>
        <trans-unit id="af0465342315c6f4795df27a00078fb3582cb96c" translate="yes" xml:space="preserve">
          <source>Digest::SHA is a complete implementation of the NIST Secure Hash Standard. It gives Perl programmers a convenient way to calculate SHA-1, SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, and SHA-512/256 message digests. The module can handle all types of input, including partial-byte data.</source>
          <target state="translated">Digest :: SHA는 NIST Secure Hash Standard를 완벽하게 구현 한 것입니다. Perl 프로그래머는 SHA-1, SHA-224, SHA-256, SHA-384, SHA-512, SHA-512 / 224 및 SHA-512 / 256 메시지 요약을 편리하게 계산할 수 있습니다. 모듈은 부분 바이트 데이터를 포함하여 모든 유형의 입력을 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="bac9dbc726cb5a61beb1d19b4dd6e34bff1be212" translate="yes" xml:space="preserve">
          <source>Digest::SHA is written in C for speed. If your platform lacks a C compiler, you can install the functionally equivalent (but much slower) &lt;a href=&quot;http://search.cpan.org/perldoc/Digest::SHA::PurePerl&quot;&gt;Digest::SHA::PurePerl&lt;/a&gt; module.</source>
          <target state="translated">Digest :: SHA는 속도를 위해 C로 작성됩니다. 플랫폼에 C 컴파일러가없는 경우 기능적으로 동등한 (그러나 훨씬 더 느린) &lt;a href=&quot;http://search.cpan.org/perldoc/Digest::SHA::PurePerl&quot;&gt;Digest :: SHA :: PurePerl&lt;/a&gt; 모듈을 설치할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cfe5335cdbe39b8c32cfd3452cb43174a1ee9bb2" translate="yes" xml:space="preserve">
          <source>Digest::base</source>
          <target state="translated">Digest::base</target>
        </trans-unit>
        <trans-unit id="4bbbfedd2eb308dc398c540fc645898c082db6ea" translate="yes" xml:space="preserve">
          <source>Digest::base - Digest base class</source>
          <target state="translated">다이제스트 :: base-다이제스트 기본 클래스</target>
        </trans-unit>
        <trans-unit id="e1e35cd383e349a46e8ddfc8d07b7e38dc9e4a97" translate="yes" xml:space="preserve">
          <source>Digest::file</source>
          <target state="translated">Digest::file</target>
        </trans-unit>
        <trans-unit id="b818bfd43f1dc832b02e92b31d19ae9f904b4bd8" translate="yes" xml:space="preserve">
          <source>Digest::file - Calculate digests of files</source>
          <target state="translated">다이제스트 :: file-파일 다이제스트 계산</target>
        </trans-unit>
        <trans-unit id="2260ce49306460c8a2ef501939f29ad6ddd4e934" translate="yes" xml:space="preserve">
          <source>Digits</source>
          <target state="translated">Digits</target>
        </trans-unit>
        <trans-unit id="392f94d8c0ee92db7ab40a881f035b7ef8b3746d" translate="yes" xml:space="preserve">
          <source>DirHandle</source>
          <target state="translated">DirHandle</target>
        </trans-unit>
        <trans-unit id="aef108ac2030e9cea15c6f1ceb48f01986539dc6" translate="yes" xml:space="preserve">
          <source>DirHandle - supply object methods for directory handles</source>
          <target state="translated">DirHandle-디렉토리 핸들을위한 객체 메소드 제공</target>
        </trans-unit>
        <trans-unit id="a91d0156df1ec1e83f412872b05e19d16ad2c59a" translate="yes" xml:space="preserve">
          <source>Direct pointer to the end of the chunk of text currently being lexed, the end of the lexer buffer. This is equal to &lt;code&gt;SvPVX(PL_parser-&amp;gt;linestr)
+ SvCUR(PL_parser-&amp;gt;linestr)&lt;/code&gt; . A &lt;code&gt;NUL&lt;/code&gt; character (zero octet) is always located at the end of the buffer, and does not count as part of the buffer's contents.</source>
          <target state="translated">현재 어휘 분석중인 텍스트 청크의 끝, 어휘 분석기 버퍼의 끝을 가리키는 직접 포인터. 이것은 &lt;code&gt;SvPVX(PL_parser-&amp;gt;linestr) + SvCUR(PL_parser-&amp;gt;linestr)&lt;/code&gt; . &lt;code&gt;NUL&lt;/code&gt; 의 문자 (제로 옥텟)은 항상 버퍼의 끝에 위치하며, 버퍼의 내용의 한 부분으로 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e2d9e8785d5c2cebf71e5748cc2d6f34072adbf8" translate="yes" xml:space="preserve">
          <source>Direct questions, comments, and the unlikely bug report (ahem) direct comments toward:</source>
          <target state="translated">직접적인 질문, 의견 및 혹시 버그 보고서 (ahem)는 다음에 대한 의견을 말합니다 :</target>
        </trans-unit>
        <trans-unit id="8a2fa68d6fded8ba99af776dc79ad66973228a51" translate="yes" xml:space="preserve">
          <source>Direction constants for shutdown().</source>
          <target state="translated">shutdown ()의 방향 상수.</target>
        </trans-unit>
        <trans-unit id="ffa4d14a55fc893b2ab2feb24f1bb9f16a27d9ef" translate="yes" xml:space="preserve">
          <source>Directions for building and installing Perl 5 can be found in the file</source>
          <target state="translated">Perl 5 빌드 및 설치에 대한 지시 사항은 파일에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51f9bdfd8404ef77fb1c128863bdee0a96774dbf" translate="yes" xml:space="preserve">
          <source>Directories are ignored, an appropriate warning message is printed.</source>
          <target state="translated">디렉토리가 무시되고 적절한 경고 메시지가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="d9839139cdba0a7db66d992a8c07d9dc5203a709" translate="yes" xml:space="preserve">
          <source>Directories specified by &lt;b&gt;-I&lt;/b&gt; are prepended to the search path for modules (&lt;code&gt;@INC&lt;/code&gt; ).</source>
          <target state="translated">&lt;b&gt;-I&lt;/b&gt; 로 지정된 디렉토리 는 모듈 검색 경로 앞에 추가됩니다 ( &lt;code&gt;@INC&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="695ad0d98ef4334944f61b185dd4cedab03431f6" translate="yes" xml:space="preserve">
          <source>Directory containing the Perl library to use.</source>
          <target state="translated">사용할 Perl 라이브러리를 포함하는 디렉토리.</target>
        </trans-unit>
        <trans-unit id="95a5114dd29380dd2a8b633c45e0a67842ace3e1" translate="yes" xml:space="preserve">
          <source>Directory containing the Perl source code (use of this should be avoided, it may be undefined)</source>
          <target state="translated">Perl 소스 코드를 포함하는 디렉토리 (이를 사용하지 않아야하며 정의되지 않았을 수 있음)</target>
        </trans-unit>
        <trans-unit id="49814c07ff871d1c05234bf7b576b8bfa6483482" translate="yes" xml:space="preserve">
          <source>Directory handles may also support PerlIO layers in the future.</source>
          <target state="translated">디렉토리 핸들은 향후 PerlIO 계층도 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09979766f57286773702fe196a375f672c98b714" translate="yes" xml:space="preserve">
          <source>Directory must be removed by the caller.</source>
          <target state="translated">발신자가 디렉토리를 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="e9f3ae68dab67380725d57ac9230f0a6c7e277d2" translate="yes" xml:space="preserve">
          <source>Directory removal</source>
          <target state="translated">디렉토리 제거</target>
        </trans-unit>
        <trans-unit id="446909c0385bc8ceaa4d872dd39cb651160d24b1" translate="yes" xml:space="preserve">
          <source>Directory to hold the man pages at 'make' time</source>
          <target state="translated">'make'시간에 매뉴얼 페이지를 보유 할 디렉토리</target>
        </trans-unit>
        <trans-unit id="6951835d54be6094b23c719fecd95aa744851441" translate="yes" xml:space="preserve">
          <source>Directory to install binary files (e.g. tkperl) into if INSTALLDIRS=perl.</source>
          <target state="translated">INSTALLDIRS = perl 인 경우 바이너리 파일 (예 : tkperl)을 설치할 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="f55462ba8ed88c62d4efa472f0b3d16ca9cba3f9" translate="yes" xml:space="preserve">
          <source>Directory to put real binary files during 'make'. These will be copied to INSTALLBIN during 'make install'</source>
          <target state="translated">'make'동안 실제 바이너리 파일을 넣을 디렉토리. 이들은 'make install'중에 INSTALLBIN에 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="071097b28577ccaebcb95a281a66ed180c8224bf" translate="yes" xml:space="preserve">
          <source>Directory under which core modules are to be installed.</source>
          <target state="translated">핵심 모듈을 설치할 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="a1829f4e2522a379a57e6dfeb7e4bf98545786dd" translate="yes" xml:space="preserve">
          <source>Directory where executable files should be installed during 'make'. Defaults to &quot;./blib/script&quot;, just to have a dummy location during testing. make install will copy the files in INST_SCRIPT to INSTALLSCRIPT.</source>
          <target state="translated">'make'동안 실행 파일을 설치해야하는 디렉토리입니다. 기본적으로 &quot;./blib/script&quot;로 설정되며 테스트하는 동안 더미 위치를 갖습니다. make install은 INST_SCRIPT의 파일을 INSTALLSCRIPT로 복사합니다.</target>
        </trans-unit>
        <trans-unit id="2bd8b42725452a5bb1746b479050ce94dd36efe4" translate="yes" xml:space="preserve">
          <source>Directory where the build process takes place?</source>
          <target state="translated">빌드 프로세스가 진행되는 디렉토리?</target>
        </trans-unit>
        <trans-unit id="78138bb545451a59f614c602f7ae3ba02571d724" translate="yes" xml:space="preserve">
          <source>Directory where to store default options/environment/dialogs for building modules that need some customization?</source>
          <target state="translated">사용자 정의가 필요한 모듈을 빌드하기위한 기본 옵션 / 환경 / 대화 상자를 저장할 디렉토리?</target>
        </trans-unit>
        <trans-unit id="71663d8624a61b44d95ba8a53379fea18cf31f0c" translate="yes" xml:space="preserve">
          <source>Directory where we put library files of this extension while building it.</source>
          <target state="translated">이 확장의 라이브러리 파일을 빌드하는 동안 넣는 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="008aa84379adaa3dd9f1114985629c6f39ced51e" translate="yes" xml:space="preserve">
          <source>Directory, or more exact the &lt;code&gt;@INC&lt;/code&gt; entry, where the module was loaded from.</source>
          <target state="translated">모듈이로드 된 디렉토리 또는 더 정확한 &lt;code&gt;@INC&lt;/code&gt; 항목</target>
        </trans-unit>
        <trans-unit id="5969fa73eaa43f73a5289188c026ff6a45c76d37" translate="yes" xml:space="preserve">
          <source>Directory.</source>
          <target state="translated">Directory.</target>
        </trans-unit>
        <trans-unit id="7b77fba35f95b8f8ec9c281444e53fe94ce4da2b" translate="yes" xml:space="preserve">
          <source>Directs output to &lt;code&gt;FILENAME&lt;/code&gt; instead of standard output.</source>
          <target state="translated">표준 출력 대신 &lt;code&gt;FILENAME&lt;/code&gt; 으로 출력을 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="f9e08e65dda5f2824f9fa498ff452471e29c1363" translate="yes" xml:space="preserve">
          <source>Disable &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;\b&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt;, &lt;code&gt;\d&lt;/code&gt; , and the POSIX classes from working correctly on Unicode either in this scope, or in just one regex.</source>
          <target state="translated">이 범위 또는 하나의 정규식에서 &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;\b&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt; , &lt;code&gt;\d&lt;/code&gt; 및 POSIX 클래스가 유니 코드에서 올바르게 작동 하지 않도록 설정 하십시오.</target>
        </trans-unit>
        <trans-unit id="817740799f0d65e523f96e31146ff1b9a88ee16c" translate="yes" xml:space="preserve">
          <source>Disable caching of timings for the null loop. This will force Benchmark to recalculate these timings for each new piece of code timed.</source>
          <target state="translated">null 루프에 대한 타이밍 캐싱을 비활성화합니다. 이로 인해 Benchmark는 새로운 각 코드 조각에 대해 이러한 타이밍을 다시 계산해야합니다.</target>
        </trans-unit>
        <trans-unit id="c0a292f0da006ba870af4c1d4b16af058ca27ce9" translate="yes" xml:space="preserve">
          <source>Disable executing</source>
          <target state="translated">실행 비활성화</target>
        </trans-unit>
        <trans-unit id="0f85246ff2faf69d64165e4047fc800c58a2cc74" translate="yes" xml:space="preserve">
          <source>Disable named opcodes when compiling perl code</source>
          <target state="translated">펄 코드를 컴파일 할 때 명명 된 opcode를 비활성화</target>
        </trans-unit>
        <trans-unit id="97739e76ec287fa7ebbb95b29230f3316099f8ec" translate="yes" xml:space="preserve">
          <source>Disable prototype checking. With this option, all function calls are deparsed as if no prototype was defined for them. In other words,</source>
          <target state="translated">프로토 타입 검사를 비활성화합니다. 이 옵션을 사용하면 프로토 타입이 정의되지 않은 것처럼 모든 함수 호출이 구문 분석됩니다. 다시 말해,</target>
        </trans-unit>
        <trans-unit id="0756161fd02ffa6bd8c4dec248d5a916201550e6" translate="yes" xml:space="preserve">
          <source>Disable recognition of &lt;code&gt;IN&lt;/code&gt; , &lt;code&gt;OUT_LIST&lt;/code&gt; and &lt;code&gt;INOUT_LIST&lt;/code&gt; declarations.</source>
          <target state="translated">&lt;code&gt;IN&lt;/code&gt; , &lt;code&gt;OUT_LIST&lt;/code&gt; 및 &lt;code&gt;INOUT_LIST&lt;/code&gt; 선언 인식을 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="ac791b2af5b20a7fb1078462c2f338c31498cb30" translate="yes" xml:space="preserve">
          <source>Disable recognition of ANSI-like descriptions of function signature.</source>
          <target state="translated">함수 서명에 대한 ANSI 유사 설명의 인식을 사용 불가능하게하십시오.</target>
        </trans-unit>
        <trans-unit id="bbc86eb1194adefaf0a1a0eedb3b0d823e6663f7" translate="yes" xml:space="preserve">
          <source>Disable the breakpoint so it won't stop the execution of the program. Breakpoints are enabled by default and can be re-enabled using the &lt;code&gt;enable&lt;/code&gt; command.</source>
          <target state="translated">프로그램 실행을 중지하지 않도록 중단 점을 비활성화하십시오. 중단 점은 기본적으로 활성화되어 있으며 &lt;code&gt;enable&lt;/code&gt; 명령을 사용하여 다시 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="18ee854e40ed47f3fd86995a561be7f6fe2416aa" translate="yes" xml:space="preserve">
          <source>Disables all warnings regardless of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; or &lt;code&gt;$^W&lt;/code&gt; . See &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 또는 &lt;code&gt;$^W&lt;/code&gt; 관계없이 모든 경고를 비활성화합니다 . &lt;a href=&quot;warnings&quot;&gt;경고를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a78ebbaecc11dc8858ab9929654aabcca4fd0610" translate="yes" xml:space="preserve">
          <source>Disables certain optimizations. The only optimization that is currently affected is the use of</source>
          <target state="translated">특정 최적화를 비활성화합니다. 현재 영향을받는 유일한 최적화 방법은</target>
        </trans-unit>
        <trans-unit id="3eddfd0331ebc78a06dd4671eddadcbb2519e22b" translate="yes" xml:space="preserve">
          <source>Disables only specific overloads in the current lexical scope.</source>
          <target state="translated">현재 어휘 범위에서 특정 과부하 만 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="27215af8e0aec9a7df486127f2e81d5c3743979c" translate="yes" xml:space="preserve">
          <source>Disables overloading entirely in the current lexical scope.</source>
          <target state="translated">현재 어휘 범위에서 오버로드를 완전히 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="0596b396338d526562980a39b883df16ed14f799" translate="yes" xml:space="preserve">
          <source>Disables the run time test that determines if the object file (derived from the &lt;code&gt;.xs&lt;/code&gt; file) and the &lt;code&gt;.pm&lt;/code&gt; files have the same version number.</source>
          <target state="translated">개체 파일 ( &lt;code&gt;.xs&lt;/code&gt; 파일 에서 파생 )과 &lt;code&gt;.pm&lt;/code&gt; 파일의 버전 번호가 같은지 확인하는 런타임 테스트를 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="0445bc1eebafe74da8f782bf383cb56524959c04" translate="yes" xml:space="preserve">
          <source>Disabling an extension</source>
          <target state="translated">확장 비활성화</target>
        </trans-unit>
        <trans-unit id="3b823ca5f6c5e18ee6590dd73a0071ccec8a63ba" translate="yes" xml:space="preserve">
          <source>Disabling or changing &amp;lt;no&amp;gt; behaviour</source>
          <target state="translated">&amp;lt;아니오&amp;gt; 동작 비활성화 또는 변경</target>
        </trans-unit>
        <trans-unit id="5aad62ff519a93497721c0514d33f638c9796188" translate="yes" xml:space="preserve">
          <source>Disabling or changing &lt;no&gt; behaviour&lt;/no&gt;</source>
          <target state="translated">비활성화 또는 변경 &lt;no&gt; 행동&lt;/no&gt;</target>
        </trans-unit>
        <trans-unit id="ec79b0e24c53783c0d5b0048b7cc030c1e7e99b1" translate="yes" xml:space="preserve">
          <source>Disabling these ops is a</source>
          <target state="translated">이러한 운영 중지는</target>
        </trans-unit>
        <trans-unit id="c32542195526d9e4b30393cfd896527d786a1f51" translate="yes" xml:space="preserve">
          <source>Disambiguation rules between old-style octal escapes and backreferences</source>
          <target state="translated">구식 8 진 탈출과 역 참조 간의 명확성 규칙</target>
        </trans-unit>
        <trans-unit id="51495d55ca3fbe873cb079ee818ab001144b1050" translate="yes" xml:space="preserve">
          <source>Discard the cop hints hash</source>
          <target state="translated">경찰 힌트 해시 폐기</target>
        </trans-unit>
        <trans-unit id="1ce92351c84d19187a09db0e7cf0340daa95578b" translate="yes" xml:space="preserve">
          <source>Discards text about to be lexed, from &lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;PL_parser-&amp;gt;bufptr&lt;/a&gt; up to</source>
          <target state="translated">, lexed에서 수하는 방법에 대한 버리고 텍스트 &lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;PL_parser-는&amp;gt; bufptr&lt;/a&gt; 까지</target>
        </trans-unit>
        <trans-unit id="d6266f69af30213e087e1c977c0114fa6d50dbc1" translate="yes" xml:space="preserve">
          <source>Discards the buffering of the standard output and standard errors for return by run_forked(). With this option you have to use the std*_handlers to read what the command outputs. Useful for commands that send a lot of output.</source>
          <target state="translated">run_forked ()에 의해 리턴되는 표준 출력 및 표준 오류의 버퍼링을 폐기합니다. 이 옵션을 사용하면 std * _handlers를 사용하여 명령 출력 내용을 읽어야합니다. 많은 출력을 보내는 명령에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a0327deb8b4ad4a89521ac79b1906db45d49787c" translate="yes" xml:space="preserve">
          <source>Discards the first part of the &lt;a href=&quot;#PL_parser-%3elinestr&quot;&gt;PL_parser-&amp;gt;linestr&lt;/a&gt; buffer, up to</source>
          <target state="translated">&lt;a href=&quot;#PL_parser-%3elinestr&quot;&gt;PL_parser-&amp;gt; linestr&lt;/a&gt; 버퍼 의 첫 번째 부분을 버립니다.</target>
        </trans-unit>
        <trans-unit id="06279c3d633238719d4311a1e19a71a158169a40" translate="yes" xml:space="preserve">
          <source>Discouraged comparison functions</source>
          <target state="translated">낙심 한 비교 기능</target>
        </trans-unit>
        <trans-unit id="a1e132aa8b84b9d862e794881468080b3307770a" translate="yes" xml:space="preserve">
          <source>Discovering the usefulness of the &quot;command.com&quot; shell on Windows 9x is left as an exercise to the reader :)</source>
          <target state="translated">Windows 9x에서 &quot;command.com&quot;쉘의 유용성을 발견하는 것은 독자에게 연습으로 남겨두고 있습니다. :)</target>
        </trans-unit>
        <trans-unit id="5e5164803920ddcf3cce5890834f1bdb27f23ebc" translate="yes" xml:space="preserve">
          <source>Discussed briefly in &lt;a href=&quot;perlpod#Formatting-Codes&quot;&gt;Formatting Codes in perlpod&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;perlpod#Formatting-Codes&quot;&gt;perlpod의 형식화 코드에서&lt;/a&gt; 간단히 논의 하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b63dec48ea2c8f9c76b3edf144110430c933947" translate="yes" xml:space="preserve">
          <source>Display all (or some) lexical variables (mnemonic: &lt;code&gt;mY&lt;/code&gt; variables) in the current scope or</source>
          <target state="translated">현재 범위에서 모든 (또는 일부) 어휘 변수 (니모닉 : &lt;code&gt;mY&lt;/code&gt; 변수)를 표시하거나</target>
        </trans-unit>
        <trans-unit id="4d6a8893695a223720d1351409d3d6fa85617a70" translate="yes" xml:space="preserve">
          <source>Display all (or some) variables in package (defaulting to &lt;code&gt;main&lt;/code&gt; ) using a data pretty-printer (hashes show their keys and values so you see what's what, control characters are made printable, etc.). Make sure you don't put the type specifier (like &lt;code&gt;$&lt;/code&gt; ) there, just the symbol names, like this:</source>
          <target state="translated">data pretty-printer를 사용하여 패키지의 모든 (또는 일부) 변수를 표시합니다 (기본값은 &lt;code&gt;main&lt;/code&gt; ) (해시는 키와 값을 보여주기 때문에 무엇이 무엇인지, 제어 문자가 인쇄 가능하게되는지 등). 다음과 같이 유형 지정자 (예 &lt;code&gt;$&lt;/code&gt; )를 기호 이름 만 넣지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="b044b119358695832cdfad98824f0069cebfc548" translate="yes" xml:space="preserve">
          <source>Display all loaded modules and their versions.</source>
          <target state="translated">로드 된 모든 모듈과 해당 버전을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="be430952d1c69c4ef4bad908fd0595a0f079554c" translate="yes" xml:space="preserve">
          <source>Display all options.</source>
          <target state="translated">모든 옵션을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="27dde643a5c3a4ac6eac908a83f780f2958f01e6" translate="yes" xml:space="preserve">
          <source>Display and Dump functions</source>
          <target state="translated">디스플레이 및 덤프 기능</target>
        </trans-unit>
        <trans-unit id="b1f4cfc5d23e7e9d95f619a69bc6c81069e91cc2" translate="yes" xml:space="preserve">
          <source>Display docs using plain &lt;b&gt;t&lt;/b&gt;ext converter, instead of nroff. This may be faster, but it probably won't look as nice.</source>
          <target state="translated">일반 사용하여 문서 표시 &lt;b&gt;t의&lt;/b&gt; 대신 NROFF의, 내선 변환기. 이것은 더 빠를 지 모르지만 아마도 멋지지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="1261f72eada707fc4383acb7f8be5b3e61a1c948" translate="yes" xml:space="preserve">
          <source>Display last n commands. Only commands longer than one character are listed. If</source>
          <target state="translated">마지막 n 명령을 표시합니다. 한 문자보다 긴 명령 만 나열됩니다. 만약</target>
        </trans-unit>
        <trans-unit id="f40755e392f1a9eb6ccdf55b73455fd0fd00a49a" translate="yes" xml:space="preserve">
          <source>Display mostly harmless warning messages (default behaviour). But this is not the same as &quot;verbose&quot; mode.</source>
          <target state="translated">대부분 무해한 경고 메시지를 표시합니다 (기본 동작). 그러나 이것은 &quot;verbose&quot;모드와 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7c1e20933a7ba1da896199ecdf785fc25a2b5f9c" translate="yes" xml:space="preserve">
          <source>Display on&lt;b&gt;l&lt;/b&gt;y the file name of the module found.</source>
          <target state="translated">찾은 모듈의 파일 이름 을 &lt;b&gt;l&lt;/b&gt; y 에 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="93569833439ae0502fb8e64a1c4e865ec5d04cb7" translate="yes" xml:space="preserve">
          <source>Display only the given routine and its descendants in the profile.</source>
          <target state="translated">지정된 루틴과 해당 하위 항목 만 프로파일에 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="cb765f562c6dc517c9adc9d4c794809e94e26d02" translate="yes" xml:space="preserve">
          <source>Display progress messages.</source>
          <target state="translated">진행 메시지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="465a2527c50c93058895db46b538af503815f183" translate="yes" xml:space="preserve">
          <source>Display progress messages. By default, they won't be displayed.</source>
          <target state="translated">진행 메시지를 표시합니다. 기본적으로 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d2e6e56a1e2419c84dc382818c82354f4cd202e5" translate="yes" xml:space="preserve">
          <source>Display routines that have zero usage.</source>
          <target state="translated">사용법이없는 루틴을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="a772b3b9f6d01bc9a870a18de9715b85da4f33c7" translate="yes" xml:space="preserve">
          <source>Display the entire module: both code and unformatted pod documentation. This may be useful if the docs don't explain a function in the detail you need, and you'd like to inspect the code directly; perldoc will find the file for you and simply hand it off for display.</source>
          <target state="translated">코드와 형식화되지 않은 포드 설명서 모두 모듈 전체를 표시합니다. 문서에서 필요한 세부 사항에 대해 기능을 설명하지 않고 코드를 직접 검사하려는 경우에 유용 할 수 있습니다. perldoc이 파일을 찾아서 표시하기 위해 전달합니다.</target>
        </trans-unit>
        <trans-unit id="d3972efaa9a06280feba956085fc524f4b645f44" translate="yes" xml:space="preserve">
          <source>Display the version numbers of the loaded &lt;a href=&quot;../tap/harness&quot;&gt;TAP::Harness&lt;/a&gt; and the current Perl.</source>
          <target state="translated">로드 된 &lt;a href=&quot;../tap/harness&quot;&gt;TAP :: Harness&lt;/a&gt; 및 현재 Perl 의 버전 번호를 표시하십시오 .</target>
        </trans-unit>
        <trans-unit id="3b39d5abe0218469782f16f6cb4d35f226bb7201" translate="yes" xml:space="preserve">
          <source>Displaying Unicode As Text</source>
          <target state="translated">유니 코드를 텍스트로 표시</target>
        </trans-unit>
        <trans-unit id="a65d13adc77fe56d8d077ba085d484794c846340" translate="yes" xml:space="preserve">
          <source>Displays a short help</source>
          <target state="translated">짧은 도움말을 표시합니다</target>
        </trans-unit>
        <trans-unit id="6782149c8f0e6f7b18c7f34e52e8afce81669558" translate="yes" xml:space="preserve">
          <source>Displays a warning that an old packlist file was found. Reads the filename from @ARGV.</source>
          <target state="translated">이전 팩리스트 파일을 찾았다는 경고를 표시합니다. @ARGV에서 파일 이름을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="d1f928489a20ced31a182ea00abdcc0e1f7a238c" translate="yes" xml:space="preserve">
          <source>Displays the current value(s) for this config variable. Without KEY, displays all subcommands and config variables.</source>
          <target state="translated">이 구성 변수의 현재 값을 표시합니다. KEY가 없으면 모든 부속 명령 및 구성 변수가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0bcd71b641eec7cadbed7fed072672f0582b39a0" translate="yes" xml:space="preserve">
          <source>Displays the usage message.</source>
          <target state="translated">사용법 메시지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="5298b75576f02dfd7e64f80d327144afcfdb191f" translate="yes" xml:space="preserve">
          <source>Displays the version of perldoc you're running.</source>
          <target state="translated">실행중인 perldoc의 버전을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="dcdc8e69179a75bcf860bec40f205ba043a0369b" translate="yes" xml:space="preserve">
          <source>Distantly based on LWP::Base64 written by Martijn Koster &amp;lt;m.koster@nexor.co.uk&amp;gt; and Joerg Reichelt &amp;lt;j.reichelt@nexor.co.uk&amp;gt; and code posted to comp.lang.perl &amp;lt;3pd2lp$6gf@wsinti07.win.tue.nl&amp;gt; by Hans Mulder &amp;lt;hansm@wsinti07.win.tue.nl&amp;gt;</source>
          <target state="translated">Martijn Koster &amp;lt;m.koster@nexor.co.uk&amp;gt; 및 Joerg Reichelt &amp;lt;j.reichelt@nexor.co.uk&amp;gt;가 작성하고 comp.lang.perl &amp;lt;3pd2lp $ 6gf @에 게시 된 코드는 LWP :: Base64를 기반으로합니다. Hans Mulder의 &amp;lt;sinm07.win.tue.nl&amp;gt; &amp;lt;hansm@wsinti07.win.tue.nl&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9483453ac3c647a5e6dee71efaa493b08294daa7" translate="yes" xml:space="preserve">
          <source>Distribution Conditions</source>
          <target state="translated">배포 조건</target>
        </trans-unit>
        <trans-unit id="955afbb21394efe51b98a6970c7c1927cbe40fd4" translate="yes" xml:space="preserve">
          <source>Distribution Support</source>
          <target state="translated">유통 지원</target>
        </trans-unit>
        <trans-unit id="41c838f5416206dabaa8d6ac86a72e962e587d49" translate="yes" xml:space="preserve">
          <source>Distribution objects are normally distributions from the CPAN, but there is a slightly degenerate case for Distribution objects, too, of projects held on the local disk. These distribution objects have the same name as the local directory and end with a dot. A dot by itself is also allowed for the current directory at the time CPAN.pm was used. All actions such as &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;test&lt;/code&gt; , and &lt;code&gt;install&lt;/code&gt; are applied directly to that directory. This gives the command &lt;code&gt;cpan .&lt;/code&gt; an interesting touch: while the normal mantra of installing a CPAN module without CPAN.pm is one of</source>
          <target state="translated">분배 오브젝트는 일반적으로 CPAN의 분배이지만 로컬 디스크에 보유 된 프로젝트의 분배 오브젝트도 약간 저하됩니다. 이 배포 개체는 로컬 디렉터리와 이름이 같고 점으로 끝납니다. CPAN.pm이 사용될 때 현재 디렉토리에 점 자체도 허용됩니다. &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;test&lt;/code&gt; 및 &lt;code&gt;install&lt;/code&gt; 과 같은 모든 조치 는 해당 디렉토리에 직접 적용됩니다. 이것은 &lt;code&gt;cpan .&lt;/code&gt; 명령을 제공합니다 . 흥미로운 점 : CPAN.pm없이 CPAN 모듈을 설치하는 일반적인 방법은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="381764d96f9c586b529fc1b74bf3dd86052ae745" translate="yes" xml:space="preserve">
          <source>Distributions on CPAN usually behave according to what we call the CPAN mantra. Or since the advent of Module::Build we should talk about two mantras:</source>
          <target state="translated">CPAN 배포는 일반적으로 CPAN 만트라라고하는 방식에 따라 작동합니다. 또는 Module :: Build가 등장한 이후 두 가지 진언에 대해 이야기해야합니다.</target>
        </trans-unit>
        <trans-unit id="c58180206bebfb6ee0df954b757a9830a178426b" translate="yes" xml:space="preserve">
          <source>Distroprefs</source>
          <target state="translated">Distroprefs</target>
        </trans-unit>
        <trans-unit id="7f01fb80f7dde34a76219740c5d0000d7751aa19" translate="yes" xml:space="preserve">
          <source>Ditto for stringifying large arrays:</source>
          <target state="translated">큰 배열을 문자열 화하기위한 Ditto :</target>
        </trans-unit>
        <trans-unit id="8cd08c454640891385c7eeea6dddbb915e9a2b00" translate="yes" xml:space="preserve">
          <source>Ditto:</source>
          <target state="translated">Ditto:</target>
        </trans-unit>
        <trans-unit id="f2faddc4fbc208e1d7b96a4fcac1f5f9f8a3944b" translate="yes" xml:space="preserve">
          <source>Do &lt;b&gt;not&lt;/b&gt; call &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; (i.e., without an argument) more than once per process. The internal state of the random number generator should contain more entropy than can be provided by any seed, so calling &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; again actually</source>
          <target state="translated">마십시오 &lt;b&gt;하지&lt;/b&gt; 전화 &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; (즉, 인수가없는) 이상의 프로세스 당 한 번 이상. 난수 생성기의 내부 상태에는 시드에서 제공 할 수있는 것보다 많은 엔트로피가 포함되어야하므로 실제로 &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; 다시 호출</target>
        </trans-unit>
        <trans-unit id="b6baf1cd7e0ea413825fb96a05b09305653a8842" translate="yes" xml:space="preserve">
          <source>Do &lt;b&gt;not&lt;/b&gt; call &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; (i.e., without an argument) more than once per process. The internal state of the random number generator should contain more entropy than can be provided by any seed, so calling &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; again actually</source>
          <target state="translated">마십시오 &lt;b&gt;하지&lt;/b&gt; 전화 &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; (즉, 인수가없는) 이상의 프로세스 당 한 번 이상. 난수 생성기의 내부 상태에는 시드에서 제공 할 수있는 것보다 많은 엔트로피가 포함되어야하므로 실제로 &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; 다시 호출</target>
        </trans-unit>
        <trans-unit id="8508e09e1cab910629d8f92dab302c9bc18cac38" translate="yes" xml:space="preserve">
          <source>Do &lt;b&gt;not&lt;/b&gt; export anything else by default without a good reason!</source>
          <target state="translated">정당한 이유없이 기본적으로 다른 &lt;b&gt;것을&lt;/b&gt; 내 보내지 마십시오 !</target>
        </trans-unit>
        <trans-unit id="2a361ce7ad694ec0575786e4a58744501e47d3dd" translate="yes" xml:space="preserve">
          <source>Do &lt;b&gt;not&lt;/b&gt; export method names!</source>
          <target state="translated">마 &lt;b&gt;되지&lt;/b&gt; 메소드 이름을 내보내!</target>
        </trans-unit>
        <trans-unit id="825725dbe42c2936cefeada5723d97075e056f4d" translate="yes" xml:space="preserve">
          <source>Do &lt;b&gt;not&lt;/b&gt; use &lt;code&gt;/[A-Z]/&lt;/code&gt; unless you don't care about the current locale.</source>
          <target state="translated">마십시오 &lt;b&gt;하지&lt;/b&gt; 사용 &lt;code&gt;/[A-Z]/&lt;/code&gt; 당신은 현재 로케일에 대해 걱정하지 않는 한.</target>
        </trans-unit>
        <trans-unit id="18fe50d08f696cfe6f092de82e112424369b684e" translate="yes" xml:space="preserve">
          <source>Do &lt;b&gt;not&lt;/b&gt; use &lt;code&gt;/[a-z]/&lt;/code&gt; unless you don't care about the current locale.</source>
          <target state="translated">마십시오 &lt;b&gt;하지&lt;/b&gt; 사용 &lt;code&gt;/[a-z]/&lt;/code&gt; 현재 로케일에 대해 걱정하지 않는 한.</target>
        </trans-unit>
        <trans-unit id="4ce4e2d8b8b0faeef7d3ea74accd64d2ba130eb9" translate="yes" xml:space="preserve">
          <source>Do I always/never have to quote my strings or use semicolons and commas?</source>
          <target state="translated">항상 문자열을 인용하거나 세미콜론과 쉼표를 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="07601d161d4355e711962a451be3c55fe86fbe5c" translate="yes" xml:space="preserve">
          <source>Do I need to recompile XS modules when there is a change in the C library?</source>
          <target state="translated">C 라이브러리에 변경이있을 때 XS 모듈을 다시 컴파일해야합니까?</target>
        </trans-unit>
        <trans-unit id="8546c498c3dd38d7f1d8d67ef0863373cb431c32" translate="yes" xml:space="preserve">
          <source>Do NOT export anything else by default without a good reason!</source>
          <target state="translated">정당한 이유없이 기본적으로 다른 것을 내 보내지 마십시오!</target>
        </trans-unit>
        <trans-unit id="88b10d4e2bda0943ded9669f6a8c9aebc17a12e8" translate="yes" xml:space="preserve">
          <source>Do NOT export method names!</source>
          <target state="translated">메소드 이름을 내 보내지 마십시오!</target>
        </trans-unit>
        <trans-unit id="ed2715ba8e6286e3dce7c7be35eeaefa5a5cc3c5" translate="yes" xml:space="preserve">
          <source>Do case-insensitive pattern matching.</source>
          <target state="translated">대소 문자를 구분하지 않는 패턴 일치를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="8d3df5a42cb6127acc1472a5755378b0af34defd" translate="yes" xml:space="preserve">
          <source>Do magic after a value is assigned to the SV. See &lt;code&gt;sv_magic&lt;/code&gt; .</source>
          <target state="translated">값이 SV에 할당 된 후 마술을 수행하십시오. &lt;code&gt;sv_magic&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cee9756153198a0ee3de2adeb5f31d39d574306f" translate="yes" xml:space="preserve">
          <source>Do magic before a value is retrieved from the SV. The type of SV must be &amp;gt;= SVt_PVMG. See &lt;code&gt;sv_magic&lt;/code&gt; .</source>
          <target state="translated">SV에서 값을 검색하기 전에 마술을하십시오. SV 유형은&amp;gt; = SVt_PVMG 여야합니다. &lt;code&gt;sv_magic&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fef68e8141e36a039846619d70d364b0a422b18f" translate="yes" xml:space="preserve">
          <source>Do not assume an operating system indicates a certain compiler.</source>
          <target state="translated">운영 체제가 특정 컴파일러를 나타내는 것으로 가정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="4b3370a4321afc9f66c3f426894b720b8a225d1f" translate="yes" xml:space="preserve">
          <source>Do not assume anything about the ordering of the characters. The lowercase letters may come before or after the uppercase letters; the lowercase and uppercase may be interlaced so that both &quot;a&quot; and &quot;A&quot; come before &quot;b&quot;; the accented and other international characters may be interlaced so that &amp;auml; comes before &quot;b&quot;. &lt;a href=&quot;unicode/collate&quot;&gt;Unicode::Collate&lt;/a&gt; can be used to sort this all out.</source>
          <target state="translated">문자 순서에 대해 아무 것도 가정하지 마십시오. 소문자는 대문자 앞이나 뒤에 올 수 있습니다. &quot;a&quot;와 &quot;A&quot;가 &quot;b&quot;앞에 오도록 소문자와 대문자가 인터레이스 될 수 있으며; 억양 및 기타 국제 문자는 &quot;b&quot;앞에 오도록 인터레이스 될 수 있습니다. &lt;a href=&quot;unicode/collate&quot;&gt;Unicode :: Collate&lt;/a&gt; 를 사용하여이 모든 것을 정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dac7429f341d431a762410206ac5527a2c13dd2f" translate="yes" xml:space="preserve">
          <source>Do not assume that the alphabetic characters are encoded contiguously (in the numeric sense). There may be gaps. Special coding in Perl, however, guarantees that all subsets of &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/[A-Z]/&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/[a-z]/&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/[0-9]/&lt;/a&gt;&lt;/code&gt; behave as expected. &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; behaves the same for these ranges. In patterns, any ranges specified with end points using the &lt;code&gt;\N{...}&lt;/code&gt; notations ensures character set portability, but it is a bug in Perl v5.22, that this isn't true of &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">알파벳 문자가 연속적으로 (숫자 의미로) 인코딩되었다고 가정하지 마십시오. 차이가있을 수 있습니다. 그러나 Perl의 특수 코딩은 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/[A-Z]/&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/[a-z]/&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/[0-9]/&lt;/a&gt;&lt;/code&gt; 의 모든 서브 세트가 예상대로 작동하도록 보장합니다 . &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 는이 범위에서 동일하게 동작합니다. 패턴에서 &lt;code&gt;\N{...}&lt;/code&gt; 표기법을 사용하여 엔드 포인트로 지정된 범위 는 문자 세트 이식성을 보장하지만 Perl v5.22의 버그는 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="1f01c64ee23b1bfc4362dd512948a4c4fa009da9" translate="yes" xml:space="preserve">
          <source>Do not attempt navigation using these formulas.</source>
          <target state="translated">이 공식을 사용하여 탐색을 시도하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="ffd84d731582ea7d72196f877c4d6066a632e557" translate="yes" xml:space="preserve">
          <source>Do not attempt to use this class directly. It won't make sense. It's mainly here to ensure that we will be able to have pluggable grammars when TAP is expanded at some future date (plus, this stuff was really cluttering the parser).</source>
          <target state="translated">이 클래스를 직접 사용하지 마십시오. 말이되지 않습니다. TAP가 미래에 확장 될 때 플러그 가능한 문법을 ​​가질 수 있도록하기 위해 주로 있습니다 (이것은 실제로 파서를 혼란스럽게했습니다).</target>
        </trans-unit>
        <trans-unit id="a6238adeeaec74412446adc0c315e47aa64f6eff" translate="yes" xml:space="preserve">
          <source>Do not be fooled into thinking that &lt;code&gt;(SV *) 0&lt;/code&gt; is the same as &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; . Take this code:</source>
          <target state="translated">&lt;code&gt;(SV *) 0&lt;/code&gt; 이 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; 생각에 속지 마십시오 . 이 코드를 보자 :</target>
        </trans-unit>
        <trans-unit id="97a265c0f5840a121cb5af7015adcf66dbf43685" translate="yes" xml:space="preserve">
          <source>Do not consider &lt;code&gt;&lt;a href=&quot;functions/getlogin&quot;&gt;getlogin&lt;/a&gt;&lt;/code&gt; for authentication: it is not as secure as &lt;code&gt;&lt;a href=&quot;functions/getpwuid&quot;&gt;getpwuid&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">인증을 위해 &lt;code&gt;&lt;a href=&quot;functions/getlogin&quot;&gt;getlogin&lt;/a&gt;&lt;/code&gt; 을 고려하지 마십시오 . &lt;code&gt;&lt;a href=&quot;functions/getpwuid&quot;&gt;getpwuid&lt;/a&gt;&lt;/code&gt; 만큼 안전하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="954cdfa947d07289fc8fa65c61c967074b46849c" translate="yes" xml:space="preserve">
          <source>Do not consider &lt;code&gt;&lt;a href=&quot;getlogin&quot;&gt;getlogin&lt;/a&gt;&lt;/code&gt; for authentication: it is not as secure as &lt;code&gt;&lt;a href=&quot;getpwuid&quot;&gt;getpwuid&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">인증을 위해 &lt;code&gt;&lt;a href=&quot;getlogin&quot;&gt;getlogin&lt;/a&gt;&lt;/code&gt; 을 고려하지 마십시오 . &lt;code&gt;&lt;a href=&quot;getpwuid&quot;&gt;getpwuid&lt;/a&gt;&lt;/code&gt; 만큼 안전하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2ed5342da7dbe2644918b11220f17d8dfd65b045" translate="yes" xml:space="preserve">
          <source>Do not create header and footer blocks containing the text of the &quot;NAME&quot; section (default behaviour).</source>
          <target state="translated">&quot;NAME&quot;섹션의 텍스트를 포함하는 머리글 및 바닥 글 블록을 만들지 마십시오 (기본 동작).</target>
        </trans-unit>
        <trans-unit id="de14526162a79000113ce8e06bb2051044d9251f" translate="yes" xml:space="preserve">
          <source>Do not declare variables using &quot;register&quot;. It may be counterproductive with modern compilers, and is deprecated in C++, under which the Perl source is regularly compiled.</source>
          <target state="translated">&quot;register&quot;를 사용하여 변수를 선언하지 마십시오. 최신 컴파일러에서는 비생산적 일 수 있으며 Perl 소스가 정기적으로 컴파일되는 C ++에서는 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ba5b70f1f2a742c5a3d1b2680eb5b21ac617899b" translate="yes" xml:space="preserve">
          <source>Do not display progress messages (default behaviour).</source>
          <target state="translated">진행 메시지를 표시하지 마십시오 (기본 동작).</target>
        </trans-unit>
        <trans-unit id="1d7af785bc11d859051058972cf4b5ed10f4c0f8" translate="yes" xml:space="preserve">
          <source>Do not expect clock_nanosleep() to be exact down to one nanosecond. Getting even accuracy of one thousand nanoseconds is good.</source>
          <target state="translated">clock_nanosleep ()이 1 나노초까지 정확하지는 않습니다. 천 나노초의 정확도를 얻는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="80ec845571b8ce066af485fa387b9e2c22cdbd4a" translate="yes" xml:space="preserve">
          <source>Do not expect nanosleep() to be exact down to one nanosecond. Getting even accuracy of one thousand nanoseconds is good.</source>
          <target state="translated">nanosleep ()이 1 나노초까지 정확하게 될 것으로 기대하지 마십시오. 천 나노초의 정확도를 얻는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="338f71d7cfd94a546bf46d57c343edb97e29ec06" translate="yes" xml:space="preserve">
          <source>Do not expect usleep() to be exact down to one microsecond.</source>
          <target state="translated">usleep ()이 정확히 1 마이크로 초가 될 것으로 기대하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="44e00d89042b21b82ae04db4fd6686e52864a5db" translate="yes" xml:space="preserve">
          <source>Do not forget the space before the trailing quote.</source>
          <target state="translated">후행 따옴표 앞의 공백을 잊지 마십시오.</target>
        </trans-unit>
        <trans-unit id="9d53664ee8f6d26a9c8d6d37ac533d0c8503e6c4" translate="yes" xml:space="preserve">
          <source>Do not forget to edit the documentation in the generated</source>
          <target state="translated">생성 된 문서를 편집하는 것을 잊지 마십시오</target>
        </trans-unit>
        <trans-unit id="b67a0bd0d26a82b3f8dae502cde36d9a68951db6" translate="yes" xml:space="preserve">
          <source>Do not generate an index at the top of the HTML file.</source>
          <target state="translated">HTML 파일 맨 위에 색인을 생성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="38ca653276acaef35211b0a7de47674e374897b5" translate="yes" xml:space="preserve">
          <source>Do not have two files or directories of the same name with different case, like</source>
          <target state="translated">대소 문자가 다른 동일한 이름을 가진 두 개의 파일 또는 디렉토리가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4798c1787e0a45ddf70984856d2f84815abcefdc" translate="yes" xml:space="preserve">
          <source>Do not include a &quot;POD ERRORS&quot; section in the outfile if there were any POD errors in the infile.</source>
          <target state="translated">파일에 POD 오류가 있으면 출력 파일에 &quot;POD ERRORS&quot;섹션을 포함시키지 마십시오.</target>
        </trans-unit>
        <trans-unit id="6ca27b97c73fed9f5b2e6cce84e318595e25670f" translate="yes" xml:space="preserve">
          <source>Do not introduce any modifiable globals, truly global or file static. They are bad form and complicate multithreading and other forms of concurrency. The right way is to introduce them as new interpreter variables, see</source>
          <target state="translated">수정 가능한 전역, 진정으로 전역 또는 파일 정적을 도입하지 마십시오. 그것들은 나쁜 형태이며 멀티 스레딩과 다른 형태의 동시성을 복잡하게 만듭니다. 올바른 방법은 새로운 인터프리터 변수로 도입하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="54f5276ef8bc6c0a7b535c715233a2e4ff4dd5a6" translate="yes" xml:space="preserve">
          <source>Do not memoize a function that returns a data structure that is modified by its caller.</source>
          <target state="translated">호출자가 수정 한 데이터 구조를 리턴하는 함수를 메모하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="e822f96782fa84026c016723c451c6a59923a48c" translate="yes" xml:space="preserve">
          <source>Do not memoize a function whose behavior depends on program state other than its own arguments, such as global variables, the time of day, or file input. These functions will not produce correct results when memoized. For a particularly easy example:</source>
          <target state="translated">전역 변수, 시간 또는 파일 입력과 같이 자체 인수 이외의 프로그램 상태에 따라 동작이 달라지는 함수는 기억하지 마십시오. 이 기능은 메모 할 때 올바른 결과를 생성하지 않습니다. 특히 쉬운 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cccff3ab93f1bd49939696cce81af2a0a2097134" translate="yes" xml:space="preserve">
          <source>Do not memoize a function with side effects.</source>
          <target state="translated">부작용이있는 기능을 메모하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="6f726dd9ddd72becc842f9b1d89ed1bf585b4d7a" translate="yes" xml:space="preserve">
          <source>Do not memoize a very simple function.</source>
          <target state="translated">매우 간단한 기능을 기억하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="fd85d472df120b1759d38d84f5ed138af9b0de90" translate="yes" xml:space="preserve">
          <source>Do not mix national standard encodings and the corresponding vendor encodings.</source>
          <target state="translated">국가 표준 인코딩과 해당 공급 업체 인코딩을 혼합하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="f1f5b43293b4ad26b77bf89ae0381b7ae81019b9" translate="yes" xml:space="preserve">
          <source>Do not pass both this and --htmldir to pod2html; they are mutually exclusive.</source>
          <target state="translated">this와 --htmldir을 모두 pod2html로 전달하지 마십시오. 그들은 상호 배타적입니다.</target>
        </trans-unit>
        <trans-unit id="b60ea56f9acc75f558cf56cbb9626f5aa57e337f" translate="yes" xml:space="preserve">
          <source>Do not read more than &lt;code&gt;limit&lt;/code&gt; files. This is useful if you have very big archives, and are only interested in the first few files.</source>
          <target state="translated">&lt;code&gt;limit&lt;/code&gt; 이상의 파일을 읽지 마십시오 . 아카이브가 매우 크며 처음 몇 개의 파일에만 관심이있는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8baaf0ce4e3be10a125ad22cfd7dc50cf9094c82" translate="yes" xml:space="preserve">
          <source>Do not recurse into subdirectories specified in podpath.</source>
          <target state="translated">podpath에 지정된 서브 디렉토리로 재귀하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="63bb032139528a610599b19949f74327a9b3d07c" translate="yes" xml:space="preserve">
          <source>Do not suspend the calling process until a child process changes state but instead return immediately.</source>
          <target state="translated">하위 프로세스가 상태를 변경할 때까지 호출 프로세스를 일시 중단하지 말고 즉시 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="a0d9cf144653df2138cfdb4728cb23fd840b488d" translate="yes" xml:space="preserve">
          <source>Do not try to be clever to insert some operations in between switching libraries:</source>
          <target state="translated">스위칭 라이브러리 사이에 일부 작업을 삽입하려고 영리하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="f892507590fee4ad20d4412e6f8474b573affb0c" translate="yes" xml:space="preserve">
          <source>Do not try to use Perl's malloc, this will lead into very mysterious errors (especially with -Duse64bitall).</source>
          <target state="translated">Perl의 malloc을 사용하지 마십시오. 이것은 매우 신비한 오류 (특히 -Duse64bitall의 경우)로 이어질 것입니다.</target>
        </trans-unit>
        <trans-unit id="481206675cc8f49efb63fbf5922ecb2459573ace" translate="yes" xml:space="preserve">
          <source>Do not turn =head1 directives into links pointing to the top of the HTML file (default behaviour).</source>
          <target state="translated">= head1 지시문을 HTML 파일의 상단을 가리키는 링크로 설정하지 마십시오 (기본 동작).</target>
        </trans-unit>
        <trans-unit id="baca6e9f8deaa5a05e4ab2ba4c839ab683b10546" translate="yes" xml:space="preserve">
          <source>Do not turn on the compiler optimization flag &quot;-O&quot;. There is a bug in either the optimizer or perl that causes perl to not work correctly when the optimizer is on.</source>
          <target state="translated">컴파일러 최적화 플래그 &quot;-O&quot;를 켜지 마십시오. 옵티 마이저 또는 perl에 옵티마이 저가 켜져있을 때 perl이 올바르게 작동하지 않는 버그가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee94e7e413fa452436aa9dabe06f090ccc39d625" translate="yes" xml:space="preserve">
          <source>Do not use &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;p&lt;/code&gt; or &lt;code&gt;P&lt;/code&gt; to obtain the address of variable that's bound to go out of scope (and thereby freeing its memory) before you are done with using the memory at that address.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 또는 &lt;code&gt;P&lt;/code&gt; 와 함께 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 을 사용하여 해당 주소에서 메모리 사용을 완료하기 전에 범위를 벗어나기 위해 바인드 된 변수의 주소를 가져 와서 메모리를 비우지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="04f9b0d0e8adfb1713c31734eee9cfdb17586771" translate="yes" xml:space="preserve">
          <source>Do not use &lt;code&gt;Devel::PPPort&lt;/code&gt; : no portability to older version.</source>
          <target state="translated">&lt;code&gt;Devel::PPPort&lt;/code&gt; 사용하지 마십시오 : 이전 버전으로 이식 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="498daddca0a46e6c4fa2a6956b5ad47910b93411" translate="yes" xml:space="preserve">
          <source>Do not use &lt;code&gt;Exporter&lt;/code&gt; and/or export any symbol.</source>
          <target state="translated">&lt;code&gt;Exporter&lt;/code&gt; 사용 하거나 심볼을 내 보내지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="ed6a2111bf29f957b88dbf31031d37b896f3ce10" translate="yes" xml:space="preserve">
          <source>Do not use &lt;code&gt;SvGROW&lt;/code&gt; or &lt;code&gt;sv_grow&lt;/code&gt; directly on &lt;code&gt;PL_parser-&amp;gt;linestr&lt;/code&gt; ; this function updates all of the lexer's variables that point directly into the buffer.</source>
          <target state="translated">사용하지 마십시오 &lt;code&gt;SvGROW&lt;/code&gt; 을 하거나 &lt;code&gt;sv_grow&lt;/code&gt; 에 직접 &lt;code&gt;PL_parser-&amp;gt;linestr&lt;/code&gt; ; 이 함수는 버퍼를 직접 가리키는 모든 렉서 변수를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="e1a5c62a2aaf2f678ca9cf51949611595cacf102" translate="yes" xml:space="preserve">
          <source>Do not use NDBM_File or ODBM_File on FAT filesystem. They can be built on a FAT filesystem, but many tests will fail:</source>
          <target state="translated">FAT 파일 시스템에서 NDBM_File 또는 ODBM_File을 사용하지 마십시오. FAT 파일 시스템에서 빌드 할 수 있지만 많은 테스트가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="ae38cf9dd649500630593bae7198d4a9f398f12d" translate="yes" xml:space="preserve">
          <source>Do not use atoi()</source>
          <target state="translated">atoi ()를 사용하지 마십시오</target>
        </trans-unit>
        <trans-unit id="753e9d05d3a5b0152e6076319f72132b8b3a599b" translate="yes" xml:space="preserve">
          <source>Do not use either the bare result of &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;N&quot;, 10, 20, 30, 40)&lt;/code&gt; or bare v-strings (such as &lt;code&gt;v10.20.30.40&lt;/code&gt; ) to represent IPv4 addresses: both forms just pack the four bytes into network order. That this would be equal to the C language &lt;code&gt;in_addr&lt;/code&gt; struct (which is what the socket code internally uses) is not guaranteed. To be portable use the routines of the &lt;code&gt;Socket&lt;/code&gt; extension, such as &lt;code&gt;inet_aton()&lt;/code&gt; , &lt;code&gt;inet_ntoa()&lt;/code&gt; , and &lt;code&gt;sockaddr_in()&lt;/code&gt; .</source>
          <target state="translated">IPv4 주소를 나타내는 데 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;N&quot;, 10, 20, 30, 40)&lt;/code&gt; 의 베어 결과 ( &quot;N&quot;, 10, 20, 30, 40) 또는 베어 v 문자열 (예 : &lt;code&gt;v10.20.30.40&lt;/code&gt; )을 사용하지 마십시오 . 두 형식 모두 4 바이트를 네트워크에 패킹합니다. 주문. 이것은 C 언어 &lt;code&gt;in_addr&lt;/code&gt; 구조체와 같을 것입니다 (소켓 코드가 내부적으로 사용하는 것)는 보장되지 않습니다. 이식 가능하게하려면 &lt;code&gt;inet_aton()&lt;/code&gt; , &lt;code&gt;inet_ntoa()&lt;/code&gt; 및 &lt;code&gt;sockaddr_in()&lt;/code&gt; 과 같은 &lt;code&gt;Socket&lt;/code&gt; 확장 루틴을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="88c49bf9327996053a0622ba64f5585438822ebb" translate="yes" xml:space="preserve">
          <source>Do not use gets()</source>
          <target state="translated">gets ()를 사용하지 마십시오</target>
        </trans-unit>
        <trans-unit id="e05df4e656db7dd388d518939d40279c56ee1258" translate="yes" xml:space="preserve">
          <source>Do not use regexes. Use a module and forget about the regular expressions. The &lt;a href=&quot;http://search.cpan.org/perldoc/XML::LibXML&quot;&gt;XML::LibXML&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/HTML::TokeParser&quot;&gt;HTML::TokeParser&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/HTML::TreeBuilder&quot;&gt;HTML::TreeBuilder&lt;/a&gt; modules are good starts, although each namespace has other parsing modules specialized for certain tasks and different ways of doing it. Start at CPAN Search ( &lt;a href=&quot;http://metacpan.org/&quot;&gt;http://metacpan.org/&lt;/a&gt; ) and wonder at all the work people have done for you already! :)</source>
          <target state="translated">정규식을 사용하지 마십시오. 모듈을 사용하고 정규식을 잊어 버리십시오. &lt;a href=&quot;http://search.cpan.org/perldoc/XML::LibXML&quot;&gt;XML :: LibXML&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/HTML::TokeParser&quot;&gt;HTML :: TokeParser&lt;/a&gt; 및 &lt;a href=&quot;http://search.cpan.org/perldoc/HTML::TreeBuilder&quot;&gt;HTML은 : TreeBuilder의&lt;/a&gt; 각 네임 스페이스가 특정 작업과 그 일을 다른 방법을 전문 다른 구문 분석 모듈을 가지고 있지만 모듈은 좋은 시작이다. CPAN 검색 ( &lt;a href=&quot;http://metacpan.org/&quot;&gt;http://metacpan.org/&lt;/a&gt; ) 에서 시작하여 사람들이 이미 당신을 위해 한 모든 일을 궁금해 하십시오 ! :)</target>
        </trans-unit>
        <trans-unit id="cce861955ad84aadd4244ab8f88800ca7035ea2a" translate="yes" xml:space="preserve">
          <source>Do not use something like &lt;code&gt;\b=head\d\b&lt;/code&gt; and expect it to match the beginning of a line. It can't, because for there to be a boundary before the non-word &quot;=&quot;, there must be a word character immediately previous. All plain &lt;code&gt;\b&lt;/code&gt; and &lt;code&gt;\B&lt;/code&gt; boundary determinations look for word characters alone, not for non-word characters nor for string ends. It may help to understand how &amp;lt;\b&amp;gt; and &amp;lt;\B&amp;gt; work by equating them as follows:</source>
          <target state="translated">&lt;code&gt;\b=head\d\b&lt;/code&gt; 와 같은 것을 사용하지 말고 줄의 시작과 일치 할 것으로 예상하십시오. 단어 &quot;=&quot;가 아닌 단어 앞에 경계가 있기 때문에 바로 앞에 단어 문자가 있어야합니다. 모든 일반 &lt;code&gt;\b&lt;/code&gt; 및 &lt;code&gt;\B&lt;/code&gt; 경계 결정은 단어가 아닌 문자 나 문자열 끝이 아닌 단어 문자 만 찾습니다. &amp;lt;\ b&amp;gt;와 &amp;lt;\ B&amp;gt;의 작동 방식을 다음과 같이 동일하게 이해하면 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1a735190dab11e5d0be16372e2f20beebf57de6" translate="yes" xml:space="preserve">
          <source>Do not use sprintf() or vsprintf()</source>
          <target state="translated">sprintf () 또는 vsprintf ()를 사용하지 마십시오</target>
        </trans-unit>
        <trans-unit id="bd8826a15f100149be24539f62f1590d0529bde4" translate="yes" xml:space="preserve">
          <source>Do not use strcpy() or strcat() or strncpy() or strncat()</source>
          <target state="translated">strcpy () 또는 strcat () 또는 strncpy () 또는 strncat ()을 사용하지 마십시오</target>
        </trans-unit>
        <trans-unit id="e845e1c460c616232a9c91d7dbd84468956485b4" translate="yes" xml:space="preserve">
          <source>Do not use strtol() or strtoul()</source>
          <target state="translated">strtol () 또는 strtoul ()을 사용하지 마십시오</target>
        </trans-unit>
        <trans-unit id="0c29194c83ffb8c5f50d4977f6ee065d347bf4fe" translate="yes" xml:space="preserve">
          <source>Do not use tell() (or other buffered I/O operations) on a filehandle that has been manipulated by sysread(), syswrite(), or sysseek(). Those functions ignore the buffering, while tell() does not.</source>
          <target state="translated">sysread (), syswrite () 또는 sysseek ()에 의해 조작 된 파일 핸들에서 tell () (또는 다른 버퍼 된 I / O 작업)을 사용하지 마십시오. 이러한 함수는 버퍼링을 무시하지만 tell ()은 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3950da255e2df8ad19b4abdbb628393b5e27d661" translate="yes" xml:space="preserve">
          <source>Do not use the module &lt;code&gt;AutoLoader&lt;/code&gt; ; but keep the constant() function and &lt;code&gt;sub AUTOLOAD&lt;/code&gt; for constants.</source>
          <target state="translated">모듈 &lt;code&gt;AutoLoader&lt;/code&gt; 를 사용하지 마십시오 . 상수에 대해서는 constant () 함수와 &lt;code&gt;sub AUTOLOAD&lt;/code&gt; 를 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="f50e07201ab25152f3dfb27ad57d827f044d1f3b" translate="yes" xml:space="preserve">
          <source>Do not use the pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; with &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; enabled, as they are at times requesting conflicting actions and the consequence of ignoring this advice will be undefined to allow future improvements in the POSIX exit handling.</source>
          <target state="translated">&lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; 가 활성화 된 pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; 를 사용 하지 마십시오. 충돌 조치를 요청하는 경우가 많으므로이 조언을 무시하면 POSIX 종료 처리에서 향후 개선이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="a4b31e073c7486c8b49c926ffd1a1a8bd9366cae" translate="yes" xml:space="preserve">
          <source>Do not use the pragma &lt;code&gt;strict&lt;/code&gt; .</source>
          <target state="translated">pragma &lt;code&gt;strict&lt;/code&gt; 를 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="d6facf91ee978da40dfe9d3ea865ab1579d25d93" translate="yes" xml:space="preserve">
          <source>Do not use the pragma &lt;code&gt;warnings&lt;/code&gt; .</source>
          <target state="translated">pragma &lt;code&gt;warnings&lt;/code&gt; 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="dee89e95287669bbd88a11a6aea3e7aa1e7bbfb6" translate="yes" xml:space="preserve">
          <source>Do not use this and --htmlroot in the same call to pod2html; they are mutually exclusive.</source>
          <target state="translated">pod2html을 호출 할 때 this와 --htmlroot를 사용하지 마십시오. 그들은 상호 배타적입니다.</target>
        </trans-unit>
        <trans-unit id="3250376779b0f67e8134deb8086f1402809e9bc8" translate="yes" xml:space="preserve">
          <source>Do not use this as a separator between directories. Some operating systems use different separators between subdirectories as between directories and filenames (for example: VOLUME:[dir1.dir2]file on VMS).</source>
          <target state="translated">디렉토리 사이의 분리 자로 이것을 사용하지 마십시오. 일부 운영 체제는 디렉토리와 파일 이름 (예 : VMS의 VOLUME : [dir1.dir2] 파일)과 같이 서브 디렉토리간에 다른 구분 기호를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="164086a0ac238b7870e606cc1d29ce266a3011d7" translate="yes" xml:space="preserve">
          <source>Do not use this if relative links are desired: use --htmldir instead.</source>
          <target state="translated">상대 링크가 필요한 경우이를 사용하지 마십시오. 대신 --htmldir을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3c5af5b31b181ed54cc1fca5572f9386a6984c19" translate="yes" xml:space="preserve">
          <source>Do not use this to run perl: &lt;code&gt;INCLUDE: perl |&lt;/code&gt; will run the perl that happens to be the first in your path and not necessarily the same perl that is used to run &lt;code&gt;xsubpp&lt;/code&gt; . See &lt;a href=&quot;#The-INCLUDE_COMMAND%3a-Keyword&quot;&gt;The INCLUDE_COMMAND: Keyword&lt;/a&gt;.</source>
          <target state="translated">이것을 사용하여 perl을 실행하지 마십시오. &lt;code&gt;INCLUDE: perl |&lt;/code&gt; 경로에서 첫 번째로 발생하는 펄을 실행하며 반드시 &lt;code&gt;xsubpp&lt;/code&gt; 를 실행하는 데 사용되는 것과 동일한 펄은 아닙니다 . &lt;a href=&quot;#The-INCLUDE_COMMAND%3a-Keyword&quot;&gt;INCLUDE_COMMAND : 키워드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="89f8b5ad3c1702cca1a4d40affd9cb729f0e90f7" translate="yes" xml:space="preserve">
          <source>Do not use this.</source>
          <target state="translated">이것을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="82165a1e97cf695c1ce626d1d090403bda43151a" translate="yes" xml:space="preserve">
          <source>Do not use tmpfile()</source>
          <target state="translated">tmpfile ()을 사용하지 마십시오</target>
        </trans-unit>
        <trans-unit id="67066fdeeb8477f689c49a4d9d531e1c38c3d6bc" translate="yes" xml:space="preserve">
          <source>Do not use with other Perl types such as HV, AV, SV, CV, because those objects will become corrupted by the pointer copy process.</source>
          <target state="translated">HV, AV, SV, CV와 같은 다른 Perl 유형과 함께 사용하지 마십시오. 이러한 객체는 포인터 복사 프로세스에 의해 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97d251c82a0422b70eb970d71730acc97d0587dc" translate="yes" xml:space="preserve">
          <source>Do not, however, be tempted to do this:</source>
          <target state="translated">그러나 이렇게하려는 유혹을받지 마십시오.</target>
        </trans-unit>
        <trans-unit id="89c4560a90f4c8640ca9769656650496ad022a1f" translate="yes" xml:space="preserve">
          <source>Do note that a switch like &lt;b&gt;--help&lt;/b&gt; creates the variable &lt;code&gt;${-help}&lt;/code&gt; , which is not compliant with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict &quot;refs&quot;&lt;/code&gt; . Also, when using this option on a script with warnings enabled you may get a lot of spurious &quot;used only once&quot; warnings.</source>
          <target state="translated">&lt;b&gt;--help&lt;/b&gt; 와 같은 스위치 는 변수 &lt;code&gt;${-help}&lt;/code&gt; &lt;b&gt;-help &lt;/b&gt;}를 생성 하는데 , 이는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict &quot;refs&quot;&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 과 호환되지 않습니다 . 또한 경고가 활성화 된 스크립트에서이 옵션을 사용하면 &quot;한 번만 사용 된&quot;경고가 많이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c739ef2c73416de977da1e1813d572016c0b1d06" translate="yes" xml:space="preserve">
          <source>Do note that the examples have been written by many different authors over a period of several decades. Styles and techniques will therefore differ, although some effort has been made to not vary styles too widely in the same sections. Do not consider one style to be better than others - &quot;There's More Than One Way To Do It&quot; is one of Perl's mottos. After all, in your journey as a programmer, you are likely to encounter different styles.</source>
          <target state="translated">이 예제는 수십 년에 걸쳐 많은 다른 저자들에 의해 작성되었습니다. 따라서 동일한 섹션에서 스타일을 너무 광범위하게 변경하지 않으려는 노력이 있었지만 스타일과 기법은 다를 수 있습니다. 한 스타일이 다른 스타일보다 나을 것이라고 생각하지 마십시오. &quot;한 가지 이상의 방법이 있습니다&quot;는 Perl의 모토 중 하나입니다. 결국 프로그래머로서의 여정에서 다른 스타일을 경험하게 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="540dbdd2eced4389045109a5d86db714850717db" translate="yes" xml:space="preserve">
          <source>Do one thing and do it well</source>
          <target state="translated">한 가지 일을 잘하십시오</target>
        </trans-unit>
        <trans-unit id="2495a1047a7ca571d906f155a7f581ed5618c76e" translate="yes" xml:space="preserve">
          <source>Do read the README associated with your operating system, e.g. README.aix on the IBM AIX OS. Don't hesitate to supply patches to that README if you find anything missing or changed over a new OS release.</source>
          <target state="translated">운영 체제와 관련된 README를 읽으십시오 (예 : IBM AIX OS에서 README.aix). 새로운 OS 릴리스에서 누락되거나 변경된 것이 있으면 언제든지 해당 README에 패치를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="f6c0054711126ec773d898b58f49cbb4c949cab9" translate="yes" xml:space="preserve">
          <source>Do similar modules already exist in some form?</source>
          <target state="translated">유사한 모듈이 이미 어떤 형태로 존재합니까?</target>
        </trans-unit>
        <trans-unit id="4d86fca77a17d198920e265fa1fed63a01551109" translate="yes" xml:space="preserve">
          <source>Do take care with &lt;code&gt;$ ASSIGN/nolog/user SYS$COMMAND: SYS$INPUT&lt;/code&gt; if your Perl-in-DCL script expects to do things like &lt;code&gt;$read = &amp;lt;STDIN&amp;gt;;&lt;/code&gt; .</source>
          <target state="translated">함께 돌봐를 수행 &lt;code&gt;$ ASSIGN/nolog/user SYS$COMMAND: SYS$INPUT&lt;/code&gt; 펄 -에 - DCL 스크립트 예상하는이 같은 것을 할 경우 &lt;code&gt;$read = &amp;lt;STDIN&amp;gt;;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed37eb991a7adeef41e4c420e9ad43ac12f4d7d2" translate="yes" xml:space="preserve">
          <source>Do the basic security measures to ensure the directory exists and is writable, that temporary files are opened only if they do not already exist, and that possible race conditions are avoided. Finally the L</source>
          <target state="translated">디렉토리가 존재하고 쓰기 가능한지, 임시 파일이없는 경우에만 열리고 가능한 경쟁 조건을 피할 수 있도록 기본 보안 조치를 수행하십시오. 마지막으로 L</target>
        </trans-unit>
        <trans-unit id="a62956f5b6df99e5d8fc6b8cabce7cc42f269d70" translate="yes" xml:space="preserve">
          <source>Do the same sort of thing to delete a particular line by using &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; to skip the lines you don't want to show up in the output. This example skips every fifth line:</source>
          <target state="translated">출력에 표시하지 않으려는 행을 건너 뛰려면 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 를 사용하여 특정 행을 삭제하는 것과 동일한 종류의 작업을 수행하십시오. 이 예제는 다섯 번째 줄마다 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="6bee90ebbffd3a020ccb7068ab9d7842e861b7da" translate="yes" xml:space="preserve">
          <source>Do whatever you can to find out, and if you have to: guess. (Don't forget to document your guess with a comment.)</source>
          <target state="translated">알아낼 수있는 모든 것을하고, 필요한 경우 : 추측하십시오. (견해와 함께 추측을 문서화하는 것을 잊지 마십시오.)</target>
        </trans-unit>
        <trans-unit id="1287ea9cdb3e32730cc921890c861ccf51d63478" translate="yes" xml:space="preserve">
          <source>Do you try to run</source>
          <target state="translated">당신은 실행하려고합니까</target>
        </trans-unit>
        <trans-unit id="d659723a2b8c8d2ce99667e3ef2aba7ca933d74a" translate="yes" xml:space="preserve">
          <source>Do you want the command number in the prompt (yes/no)?</source>
          <target state="translated">프롬프트에서 명령 번호를 원하십니까 (예 / 아니요)?</target>
        </trans-unit>
        <trans-unit id="d7a7627a867e6bbe22a2b970c115376b82f0139b" translate="yes" xml:space="preserve">
          <source>Do you want to enable code deserialisation (yes/no)?</source>
          <target state="translated">코드 역 직렬화를 사용 하시겠습니까 (예 / 아니요)?</target>
        </trans-unit>
        <trans-unit id="cbd235cb0bbd92aee8e53ccbbbbc3dabc72798c9" translate="yes" xml:space="preserve">
          <source>Do you want to halt on failure (yes/no)?</source>
          <target state="translated">실패시 중단 하시겠습니까 (예 / 아니요)?</target>
        </trans-unit>
        <trans-unit id="373cd2197f990d8762c7c66b4869ae4717a2e44c" translate="yes" xml:space="preserve">
          <source>Do you want to rely on the test report history (yes/no)?</source>
          <target state="translated">테스트 보고서 기록에 의존 하시겠습니까 (예 / 아니요)?</target>
        </trans-unit>
        <trans-unit id="8a279f6363761148fb8c2b71535a1b4a155b67db" translate="yes" xml:space="preserve">
          <source>Do you want to turn on colored output?</source>
          <target state="translated">컬러 출력을 켜시겠습니까?</target>
        </trans-unit>
        <trans-unit id="87a207a61ec9d6801b880d322288293793a12268" translate="yes" xml:space="preserve">
          <source>Do you want to turn ornaments on?</source>
          <target state="translated">장식품을 켜시겠습니까?</target>
        </trans-unit>
        <trans-unit id="99b869f7fe84b2b6d6d37879f90b1ce5f182c64b" translate="yes" xml:space="preserve">
          <source>Do you want to turn this message off?</source>
          <target state="translated">이 메시지를 끄시겠습니까?</target>
        </trans-unit>
        <trans-unit id="8bf8fea239cbb1f5a4fdb80eb2b8949a38de2f2e" translate="yes" xml:space="preserve">
          <source>Do you want to use a different command for './Build install'? Sudo users will probably prefer:</source>
          <target state="translated">'./Build install'에 다른 명령을 사용 하시겠습니까? Sudo 사용자는 아마도 다음을 선호 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="cc8ccb8accaee9d0eecc936c06f10fdc9aba0e2f" translate="yes" xml:space="preserve">
          <source>Do you want to use a different make command for 'make install'? Cautious people will probably prefer:</source>
          <target state="translated">'make install'에 다른 make 명령을 사용 하시겠습니까? 신중한 사람들은 아마도 다음을 선호 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="4f330885ef3a3b61025e1e796b402fcd50c7b4e7" translate="yes" xml:space="preserve">
          <source>Do you want to use prompt defaults (yes/no)?</source>
          <target state="translated">프롬프트 기본값을 사용 하시겠습니까 (예 / 아니요)?</target>
        </trans-unit>
        <trans-unit id="918ceb56671dd67483da1f39299f85748b336c0e" translate="yes" xml:space="preserve">
          <source>Do you want to:</source>
          <target state="translated">다음을 원하십니까 :</target>
        </trans-unit>
        <trans-unit id="b91e32e96ba9f37078ffe29f1ee1859d0140ecfd" translate="yes" xml:space="preserve">
          <source>Document each publically accessible method or subroutine, including params and return values</source>
          <target state="translated">매개 변수 및 리턴 값을 포함하여 공개적으로 액세스 가능한 각 메소드 또는 서브 루틴을 문서화하십시오.</target>
        </trans-unit>
        <trans-unit id="6e00d0928abd84bf71ed2ace7f696bcbc6aee9e8" translate="yes" xml:space="preserve">
          <source>Document purpose, scope and target applications</source>
          <target state="translated">문서 목적, 범위 및 대상 응용 프로그램</target>
        </trans-unit>
        <trans-unit id="9e9cf3221a30246219863f1d2366e36cb580debc" translate="yes" xml:space="preserve">
          <source>Documentation</source>
          <target state="translated">Documentation</target>
        </trans-unit>
        <trans-unit id="0d4f3597552829486c9c7978225dcdc88217781f" translate="yes" xml:space="preserve">
          <source>Documentation and help texts</source>
          <target state="translated">설명서 및 도움말 텍스트</target>
        </trans-unit>
        <trans-unit id="1d66c2dca46aca62759ec44a5b9071376128798a" translate="yes" xml:space="preserve">
          <source>Documentation borrowed from the old Thread.pm.</source>
          <target state="translated">이전 Thread.pm에서 빌린 문서.</target>
        </trans-unit>
        <trans-unit id="8b5ab45b761259017419114ca3e9a62382663d77" translate="yes" xml:space="preserve">
          <source>Documentation has been contributed by:</source>
          <target state="translated">문서는 다음에 의해 제공되었습니다.</target>
        </trans-unit>
        <trans-unit id="4730bb4bd3211681615071a5ac81bbb7a0d87081" translate="yes" xml:space="preserve">
          <source>Documentation mostly rewritten by Ilmari Karonen, &amp;lt;</source>
          <target state="translated">Ilmari Karonen이 대부분 재 작성한 문서, &amp;lt;</target>
        </trans-unit>
        <trans-unit id="5c1fa297f5d4c566fd5588f14f34ea9f8ecedf5a" translate="yes" xml:space="preserve">
          <source>Documentation of corrections already incorporated into the Unicode data base</source>
          <target state="translated">이미 유니 코드 데이터베이스에 통합 된 수정 사항에 대한 문서</target>
        </trans-unit>
        <trans-unit id="cac7df688d4ef7dcaa6e39b6e0d4e8f277b2acfd" translate="yes" xml:space="preserve">
          <source>Documentation of object-oriented libraries or modules may want to use CONSTRUCTORS and METHODS sections, or CLASS METHODS and INSTANCE METHODS sections, for detailed documentation of the parts of the library and save the DESCRIPTION section for an overview. Large modules with a function interface may want to use FUNCTIONS for similar reasons. Some people use OVERVIEW to summarize the description if it's quite long.</source>
          <target state="translated">객체 지향 라이브러리 또는 모듈에 대한 문서는 라이브러리 부분에 대한 자세한 문서화를 위해 CONSTRUCTORS 및 METHODS 섹션 또는 CLASS METHODS 및 INSTANCE METHODS 섹션을 사용하고 개요를 위해 DESCRIPTION 섹션을 저장할 수 있습니다. 기능 인터페이스가있는 대형 모듈은 비슷한 이유로 FUNCTIONS를 사용할 수 있습니다. 설명이 너무 길면 개요를 사용하여 설명을 요약하는 사람들이 있습니다.</target>
        </trans-unit>
        <trans-unit id="49018199d13814134468f853612e00393c5c7fd7" translate="yes" xml:space="preserve">
          <source>Documentation of status and cross reference of proposals for encoding by Unicode of Unihan characters</source>
          <target state="translated">Unihan 문자의 유니 코드로 인코딩하기위한 제안서의 상태 및 상호 참조 문서</target>
        </trans-unit>
        <trans-unit id="eb488db5f5b4fb936ed78cb59ddbbcefd6c8b7f6" translate="yes" xml:space="preserve">
          <source>Documentation of validation tests</source>
          <target state="translated">검증 테스트 문서화</target>
        </trans-unit>
        <trans-unit id="b139845ddb6a01b9b23ddc81ca29bb8e6b63e194" translate="yes" xml:space="preserve">
          <source>Documentation updates that correct factual errors, explain significant bugs or deficiencies in the current implementation, or fix broken markup.</source>
          <target state="translated">실제 오류를 수정하고, 현재 구현에서 중대한 버그 또는 결함을 설명하거나, 손상된 마크 업을 수정하는 문서 업데이트.</target>
        </trans-unit>
        <trans-unit id="23cea710c088ecfa1ae744391fe173bfdf5d1acb" translate="yes" xml:space="preserve">
          <source>Documenting the patch</source>
          <target state="translated">패치 문서화</target>
        </trans-unit>
        <trans-unit id="a20866ae52f8e35eaed59a179f7c48ea2d19b8fa" translate="yes" xml:space="preserve">
          <source>Documenting your Extension</source>
          <target state="translated">확장 문서화</target>
        </trans-unit>
        <trans-unit id="2080696be6c4c31d4c892420cc245128864bdfe0" translate="yes" xml:space="preserve">
          <source>Does Perl have a Year 2000 or 2038 problem? Is Perl Y2K compliant?</source>
          <target state="translated">Perl에 2000 년 또는 2038 년 문제가 있습니까? Perl Y2K는 호환됩니까?</target>
        </trans-unit>
        <trans-unit id="0d6d8d711a3a4cca710ca22dbfe40093bf45d857" translate="yes" xml:space="preserve">
          <source>Does Perl have a round() function? What about ceil() and floor()? Trig functions?</source>
          <target state="translated">Perl에 round () 함수가 있습니까? ceil ()과 floor ()는 어떻습니까? 삼각 함수?</target>
        </trans-unit>
        <trans-unit id="347f03cef55a503c9fa350dbe1691433852f2738" translate="yes" xml:space="preserve">
          <source>Does a $(CI) and a $(RCS_LABEL) on all files in the MANIFEST file.</source>
          <target state="translated">MANIFEST 파일의 모든 파일에서 $ (CI) 및 $ (RCS_LABEL)을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="6ace7d9d419573301ff609d787f134b02b26193b" translate="yes" xml:space="preserve">
          <source>Does a fork(2) system call to create a new process running the same program at the same point. It returns the child pid to the parent process, &lt;code&gt;0&lt;/code&gt; to the child process, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if the fork is unsuccessful. File descriptors (and sometimes locks on those descriptors) are shared, while everything else is copied. On most systems supporting fork(), great care has gone into making it extremely efficient (for example, using copy-on-write technology on data pages), making it the dominant paradigm for multitasking over the last few decades.</source>
          <target state="translated">fork (2) 시스템 호출을 수행하여 동일한 지점에서 동일한 프로그램을 실행하는 새 프로세스를 작성합니다. 하위 pid를 상위 프로세스로 리턴하고 &lt;code&gt;0&lt;/code&gt; 을 하위 프로세스로 리턴 하거나 포크가 실패하면 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 리턴합니다 . 파일 디스크립터 (및 때때로 해당 디스크립터에 대한 잠금)는 공유되고 다른 모든 디스크는 복사됩니다. fork ()를 지원하는 대부분의 시스템에서 데이터 페이지에 COW (Copy-On-Write) 기술을 사용하는 등 매우 효율적으로 처리함으로써 지난 수십 년 동안 멀티 태스킹의 주요 패러다임이되었습니다.</target>
        </trans-unit>
        <trans-unit id="94b3dcb831cc7f4b2c1f2db661fceb8975ccf8c1" translate="yes" xml:space="preserve">
          <source>Does a fork(2) system call to create a new process running the same program at the same point. It returns the child pid to the parent process, &lt;code&gt;0&lt;/code&gt; to the child process, or &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if the fork is unsuccessful. File descriptors (and sometimes locks on those descriptors) are shared, while everything else is copied. On most systems supporting fork(), great care has gone into making it extremely efficient (for example, using copy-on-write technology on data pages), making it the dominant paradigm for multitasking over the last few decades.</source>
          <target state="translated">fork (2) 시스템 호출을 수행하여 동일한 지점에서 동일한 프로그램을 실행하는 새 프로세스를 작성합니다. 하위 pid를 상위 프로세스로 리턴하고 &lt;code&gt;0&lt;/code&gt; 을 하위 프로세스로 리턴 하거나 포크가 실패하면 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 리턴합니다 . 파일 디스크립터 (및 때때로 해당 디스크립터에 대한 잠금)는 공유되고 다른 모든 디스크는 복사됩니다. fork ()를 지원하는 대부분의 시스템에서 데이터 페이지에 COW (Copy-On-Write) 기술을 사용하는 등 매우 효율적으로 처리함으로써 지난 수십 년 동안 멀티 태스킹의 주요 패러다임이되었습니다.</target>
        </trans-unit>
        <trans-unit id="6e7a8e9cc842e50405245756a0a1bacedfbe9c22" translate="yes" xml:space="preserve">
          <source>Does a tree-walk of the syntax tree based at OP and calls METHOD on each op it visits. Each node is visited before its children. If &lt;code&gt;walkoptree_debug&lt;/code&gt; (see below) has been called to turn debugging on then the method &lt;code&gt;walkoptree_debug&lt;/code&gt; is called on each op before METHOD is called.</source>
          <target state="translated">OP를 기반으로 구문 트리의 트리 워크를 수행하고 방문 할 때마다 METHOD를 호출합니다. 각 노드는 자식보다 먼저 방문합니다. 경우 &lt;code&gt;walkoptree_debug&lt;/code&gt; 는 (아래 참조)의 디버깅 차례 호출 한 후 상기 방법 &lt;code&gt;walkoptree_debug&lt;/code&gt; 이 메소드가 호출되기 전에 각 연산에 호출된다.</target>
        </trans-unit>
        <trans-unit id="de4556ee919b8c9e716ff91fff53e57dd9fa041d" translate="yes" xml:space="preserve">
          <source>Does exactly the same thing as &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; LIST&lt;/code&gt; , except that a fork is done first and the parent process waits for the child process to exit. Note that argument processing varies depending on the number of arguments. If there is more than one argument in LIST, or if LIST is an array with more than one value, starts the program given by the first element of the list with arguments given by the rest of the list. If there is only one scalar argument, the argument is checked for shell metacharacters, and if there are any, the entire argument is passed to the system's command shell for parsing (this is &lt;code&gt;/bin/sh -c&lt;/code&gt; on Unix platforms, but varies on other platforms). If there are no shell metacharacters in the argument, it is split into words and passed directly to &lt;code&gt;execvp&lt;/code&gt; , which is more efficient. On Windows, only the &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; PROGRAM LIST&lt;/code&gt; syntax will reliably avoid using the shell; &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; LIST&lt;/code&gt; , even with more than one element, will fall back to the shell if the first spawn fails.</source>
          <target state="translated">포크가 먼저 수행되고 상위 프로세스가 하위 프로세스가 종료 될 때까지 대기한다는 점을 제외하고는 &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; LIST&lt;/code&gt; 와 정확히 동일한 작업을 수행합니다. 인수 처리는 인수 수에 따라 다릅니다. LIST에 둘 이상의 인수가 있거나 LIST가 하나 이상의 값을 가진 배열 인 경우,리스트의 첫 번째 요소가 제공하는 프로그램을 나머지리스트가 제공하는 인수로 시작하십시오. 스칼라 인수가 하나만있는 경우, 인수는 쉘 메타 문자를 검사하고, 존재하는 경우 전체 인수는 구문 분석을 위해 시스템의 명령 쉘로 전달됩니다 ( 유닉스 플랫폼에서는 &lt;code&gt;/bin/sh -c&lt;/code&gt; 이지만 다른 플랫폼). 인수에 쉘 메타 문자가 없으면 단어로 분리되어 &lt;code&gt;execvp&lt;/code&gt; 로 직접 전달됩니다.보다 효율적입니다. Windows에서는 &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; PROGRAM LIST&lt;/code&gt; 구문 만 쉘 사용을 확실하게 피할 수 있습니다. &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; LIST&lt;/code&gt; 는 둘 이상의 요소가 있더라도 첫 번째 생성이 실패하면 쉘로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="971d377ca0b94eef511ce7a5cf1fbc7ca9fc4308" translate="yes" xml:space="preserve">
          <source>Does exactly the same thing as &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; LIST&lt;/code&gt; , except that a fork is done first and the parent process waits for the child process to exit. Note that argument processing varies depending on the number of arguments. If there is more than one argument in LIST, or if LIST is an array with more than one value, starts the program given by the first element of the list with arguments given by the rest of the list. If there is only one scalar argument, the argument is checked for shell metacharacters, and if there are any, the entire argument is passed to the system's command shell for parsing (this is &lt;code&gt;/bin/sh -c&lt;/code&gt; on Unix platforms, but varies on other platforms). If there are no shell metacharacters in the argument, it is split into words and passed directly to &lt;code&gt;execvp&lt;/code&gt; , which is more efficient. On Windows, only the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; PROGRAM LIST&lt;/code&gt; syntax will reliably avoid using the shell; &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; LIST&lt;/code&gt; , even with more than one element, will fall back to the shell if the first spawn fails.</source>
          <target state="translated">포크가 먼저 수행되고 상위 프로세스가 하위 프로세스가 종료 될 때까지 대기한다는 점을 제외하고는 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; LIST&lt;/code&gt; 와 정확히 동일한 작업을 수행합니다. 인수 처리는 인수 수에 따라 다릅니다. LIST에 둘 이상의 인수가 있거나 LIST가 하나 이상의 값을 가진 배열 인 경우,리스트의 첫 번째 요소가 제공하는 프로그램을 나머지리스트가 제공하는 인수로 시작하십시오. 스칼라 인수가 하나만있는 경우, 인수는 쉘 메타 문자를 검사하고, 존재하는 경우 전체 인수는 구문 분석을 위해 시스템의 명령 쉘로 전달됩니다 ( 유닉스 플랫폼에서는 &lt;code&gt;/bin/sh -c&lt;/code&gt; 이지만 다른 플랫폼). 인수에 쉘 메타 문자가 없으면 단어로 분리되어 &lt;code&gt;execvp&lt;/code&gt; 로 직접 전달됩니다.보다 효율적입니다. Windows에서는 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; PROGRAM LIST&lt;/code&gt; 구문 만 쉘 사용을 확실하게 피할 수 있습니다. &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; LIST&lt;/code&gt; 는 둘 이상의 요소가 있더라도 첫 번째 생성이 실패하면 쉘로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="7ae98d71c785265ddcfeeeb07989cf58a75f2684" translate="yes" xml:space="preserve">
          <source>Does it create too much work?</source>
          <target state="translated">너무 많은 일을합니까?</target>
        </trans-unit>
        <trans-unit id="76c48f534cf5b51a41a2a7ce76b162535214df0a" translate="yes" xml:space="preserve">
          <source>Does it potentially introduce new bugs?</source>
          <target state="translated">잠재적으로 새로운 버그가 발생합니까?</target>
        </trans-unit>
        <trans-unit id="163b23e27c4c841d1d0111848b85d7359f51c15f" translate="yes" xml:space="preserve">
          <source>Does it preclude other desirable features?</source>
          <target state="translated">다른 바람직한 기능을 배제합니까?</target>
        </trans-unit>
        <trans-unit id="19da346c64719e8350a8cf9aeb2a31add00b3079" translate="yes" xml:space="preserve">
          <source>Does not &lt;code&gt;&lt;a href=&quot;../functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; to each directory as it recurses. The &lt;code&gt;wanted()&lt;/code&gt; function will need to be aware of this, of course. In this case, &lt;code&gt;$_&lt;/code&gt; will be the same as &lt;code&gt;$File::Find::name&lt;/code&gt; .</source>
          <target state="translated">반복 될 때 각 디렉토리에 &lt;code&gt;&lt;a href=&quot;../functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; 하지 않습니다 . &lt;code&gt;wanted()&lt;/code&gt; 기능은 물론,이 인식해야합니다. 이 경우 &lt;code&gt;$_&lt;/code&gt; 는 &lt;code&gt;$File::Find::name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af44a91c9e39ab0c7463bac15a45ab231dcc0a7d" translate="yes" xml:space="preserve">
          <source>Does not alter the passed in ver SV. See &quot;upg_version&quot; if you want to upgrade the SV.</source>
          <target state="translated">전달 된 ver SV를 변경하지 않습니다. SV를 업그레이드하려면 &quot;upg_version&quot;을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7520223aa1c22fe71da2f2fd9fbb194fccf8f278" translate="yes" xml:space="preserve">
          <source>Does not automatically flush output handles on some platforms. (SunOS, Solaris, HP-UX)</source>
          <target state="translated">일부 플랫폼에서 출력 핸들을 자동으로 플러시하지 않습니다. (SunOS, Solaris, HP-UX)</target>
        </trans-unit>
        <trans-unit id="1d965ffd27f165cd1bb4e614ffc070019e6e4581" translate="yes" xml:space="preserve">
          <source>Does not support &lt;code&gt;&lt;a href=&quot;../functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; on arrays. Does not support explicitly changing array lengths via $#array -- use &lt;code&gt;&lt;a href=&quot;../functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">배열에서 &lt;code&gt;&lt;a href=&quot;../functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; 를 지원하지 않습니다 . $ # array를 통해 명시 적으로 배열 길이 변경을 지원하지 않습니다 . 대신 &lt;code&gt;&lt;a href=&quot;../functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d6e1e02c4c151b139fab2fca754d38a684aec2de" translate="yes" xml:space="preserve">
          <source>Does not work as</source>
          <target state="translated">작동하지 않습니다</target>
        </trans-unit>
        <trans-unit id="a0eab3410cab5a6dc3b7523e73bfbe22cc007192" translate="yes" xml:space="preserve">
          <source>Does nothing, but won't fail. (Win32)</source>
          <target state="translated">아무것도하지 않지만 실패하지는 않습니다. (Win32)</target>
        </trans-unit>
        <trans-unit id="ab6714990b2e9014158db7ba9506c2e3f1eef1e8" translate="yes" xml:space="preserve">
          <source>Does the concept match the general goals of Perl?</source>
          <target state="translated">이 개념이 Perl의 일반적인 목표와 일치합니까?</target>
        </trans-unit>
        <trans-unit id="dbd3ca43bd95ec8bd28a3afc7d9eb6159f4931f6" translate="yes" xml:space="preserve">
          <source>Does the equivalent of the &lt;code&gt;-c&lt;/code&gt; command-line option. Obviously, this is only useful in a BEGIN block or else the flag is set too late.</source>
          <target state="translated">&lt;code&gt;-c&lt;/code&gt; 명령 행 옵션 과 동일합니다 . 분명히 이것은 BEGIN 블록에서만 유용하거나 그렇지 않으면 플래그가 너무 늦게 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="5d2b8e3e1d6fb7e3c6489d878105273a9ab06c85" translate="yes" xml:space="preserve">
          <source>Does the exact opposite to the &lt;b&gt;-W&lt;/b&gt; flag, i.e. it disables all warnings.</source>
          <target state="translated">&lt;b&gt;-W&lt;/b&gt; 플래그와 정반대 입니다. 즉, 모든 경고를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="4f6fc9d8f5b45abfab918dce456df590c87db452" translate="yes" xml:space="preserve">
          <source>Does the module require compilation (i.e. does it have files that end in .xs, .c, .h, .y, .cc, .cxx, or .C)? If it does, life is now officially tough for you, because you have to compile the module yourself (no easy feat on Windows). You'll need a compiler such as Visual C++. Alternatively, you can download a pre-built PPM package from ActiveState. &lt;a href=&quot;http://aspn.activestate.com/ASPN/Downloads/ActivePerl/PPM/&quot;&gt;http://aspn.activestate.com/ASPN/Downloads/ActivePerl/PPM/&lt;/a&gt;</source>
          <target state="translated">모듈에 컴파일이 필요합니까 (즉, .xs, .c, .h, .y, .cc, .cxx 또는 .C로 끝나는 파일이 있습니까)? 그렇다면 모듈을 직접 컴파일해야하기 때문에 인생은 공식적으로 힘든 일입니다 (Windows에서는 쉽게 할 수 없음). Visual C ++와 같은 컴파일러가 필요합니다. 또는 ActiveState에서 사전 구축 된 PPM 패키지를 다운로드 할 수 있습니다. &lt;a href=&quot;http://aspn.activestate.com/ASPN/Downloads/ActivePerl/PPM/&quot;&gt;http://aspn.activestate.com/ASPN/Downloads/ActivePerl/PPM/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1e8b1afa4f266e283c1e89777c89973f57e94a2c" translate="yes" xml:space="preserve">
          <source>Does the opposite of a &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;. Or the opposite of a &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt;, depending on how you look at it. Prepends list to the front of the array and returns the new number of elements in the array.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 의 반대입니다 . 또는 보는 방식에 따라 &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; 의 반대입니다 . 배열 앞에 배열을 추가하고 배열에있는 새로운 요소 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="15ca4b87c1dd7484db0ece50d3e128013e8468d9" translate="yes" xml:space="preserve">
          <source>Does the opposite of a &lt;code&gt;&lt;a href=&quot;shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;. Or the opposite of a &lt;code&gt;&lt;a href=&quot;push&quot;&gt;push&lt;/a&gt;&lt;/code&gt;, depending on how you look at it. Prepends list to the front of the array and returns the new number of elements in the array.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 의 반대입니다 . 또는 보는 방식에 따라 &lt;code&gt;&lt;a href=&quot;push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; 의 반대입니다 . 배열 앞에 배열을 추가하고 배열에있는 새로운 요소 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a4a01d3bbed716e476e014f93f4ca067ce1b42d2" translate="yes" xml:space="preserve">
          <source>Does the same thing as the &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; function (including setting the special &lt;code&gt;_&lt;/code&gt; filehandle) but stats a symbolic link instead of the file the symbolic link points to. If symbolic links are unimplemented on your system, a normal &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; is done. For much more detailed information, please see the documentation for &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 함수 (특수 &lt;code&gt;_&lt;/code&gt; filehandle 설정 포함) 와 동일 하지만 심볼릭 링크가 가리키는 파일 대신 심볼릭 링크를 통계합니다. 시스템에서 심볼릭 링크가 구현되지 않은 경우 일반 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 가 수행됩니다. 보다 자세한 내용은 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2440cc46fc6eb9876beb8fbe0150b6c618c74179" translate="yes" xml:space="preserve">
          <source>Does the same thing as the &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; function (including setting the special &lt;code&gt;_&lt;/code&gt; filehandle) but stats a symbolic link instead of the file the symbolic link points to. If symbolic links are unimplemented on your system, a normal &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; is done. For much more detailed information, please see the documentation for &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 함수 (특수 &lt;code&gt;_&lt;/code&gt; filehandle 설정 포함) 와 동일 하지만 심볼릭 링크가 가리키는 파일 대신 심볼릭 링크를 통계합니다. 시스템에서 심볼릭 링크가 구현되지 않은 경우 일반 &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 가 수행됩니다. 보다 자세한 내용은 &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c26f7b80fe6be59ff00dfaaf3a9f27764a36e9e8" translate="yes" xml:space="preserve">
          <source>Does the same thing that the listen(2) system call does. Returns true if it succeeded, false otherwise. See the example in &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">listen (2) 시스템 호출과 동일한 기능을 수행합니다. 성공하면 true를, 그렇지 않으면 false를 반환합니다. &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;소켓 : perlipc의 클라이언트 / 서버 통신&lt;/a&gt; 의 예제를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="22db9588c396aba67c7aad2d451295dbb36db3d9" translate="yes" xml:space="preserve">
          <source>Does the same thing that the listen(2) system call does. Returns true if it succeeded, false otherwise. See the example in &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">listen (2) 시스템 호출과 동일한 기능을 수행합니다. 성공하면 true를, 그렇지 않으면 false를 반환합니다. &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;소켓 : perlipc의 클라이언트 / 서버 통신&lt;/a&gt; 의 예제를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="22374adba20ced760e98d0c0d73bbc827cae9cc0" translate="yes" xml:space="preserve">
          <source>Does this module need linking? Looks into subdirectory objects (see also has_link_code())</source>
          <target state="translated">이 모듈을 연결해야합니까? 서브 디렉토리 오브젝트를 찾습니다 (has_link_code () 참조).</target>
        </trans-unit>
        <trans-unit id="ec5a93789136319c08b5e5d76ea18d252f60bd6c" translate="yes" xml:space="preserve">
          <source>Does very much the same as the cflags script in the perl distribution. It doesn't return the whole compiler command line, but initializes all of its parts. The const_cccmd method then actually returns the definition of the CCCMD macro which uses these parts.</source>
          <target state="translated">펄 배포판의 cflags 스크립트와 거의 동일합니다. 전체 컴파일러 명령 줄을 반환하지 않지만 모든 부분을 초기화합니다. const_cccmd 메소드는 실제로 이러한 파트를 사용하는 CCCMD 매크로의 정의를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6d014ad0641a64b3a2fca948ec89b499199cfda8" translate="yes" xml:space="preserve">
          <source>Does your module pass the 'empty subclass' test? If you say &lt;code&gt;@SUBCLASS::ISA = qw(YOURCLASS);&lt;/code&gt; your applications should be able to use SUBCLASS in exactly the same way as YOURCLASS. For example, does your application still work if you change: &lt;code&gt;$obj = YOURCLASS-&amp;gt;new();&lt;/code&gt; into: &lt;code&gt;$obj = SUBCLASS-&amp;gt;new();&lt;/code&gt; ?</source>
          <target state="translated">모듈이 '빈 서브 클래스'테스트를 통과합니까? 당신이 말한다면 &lt;code&gt;@SUBCLASS::ISA = qw(YOURCLASS);&lt;/code&gt; 응용 프로그램은 YOURCLASS와 정확히 동일한 방식으로 SUBCLASS를 사용할 수 있어야합니다. 예를 들어, 변경해도 응용 프로그램이 계속 작동 &lt;code&gt;$obj = YOURCLASS-&amp;gt;new();&lt;/code&gt; : &lt;code&gt;$obj = SUBCLASS-&amp;gt;new();&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="bdcea9fc3bdee92b160e5b96d81fb3d19af3fd30" translate="yes" xml:space="preserve">
          <source>Doesn't construct the %sizeof array for you.</source>
          <target state="translated">% sizeof 배열을 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd3640eea37fa02af99e7bd48394bfa2af60bf4c" translate="yes" xml:space="preserve">
          <source>Doesn't handle complicated expressions built piecemeal, a la:</source>
          <target state="translated">복잡한 식으로 구성된 복잡한 식을 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5787ba7fa720ea9e3316d963760e6faa3df102b3" translate="yes" xml:space="preserve">
          <source>Doesn't necessarily locate all of your C compiler's internally-defined symbols.</source>
          <target state="translated">C 컴파일러의 내부 정의 기호를 모두 찾을 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="9f3f7c7d9e43e8918099efac1f5805d8811f35df" translate="yes" xml:space="preserve">
          <source>Doing Sums</source>
          <target state="translated">합계</target>
        </trans-unit>
        <trans-unit id="c0d111463257cf715e280f2b7d3c19b013c19ffb" translate="yes" xml:space="preserve">
          <source>Doing something repeatedly.</source>
          <target state="translated">반복해서 무언가를하는 것.</target>
        </trans-unit>
        <trans-unit id="2151e066a0ffe448d6aae7739b4f7382726846a0" translate="yes" xml:space="preserve">
          <source>Doing these checks by hand can quickly become tedious. Writing a bunch of accessors by hand is also incredibly tedious. There are a lot of modules on CPAN that can help you write safer and more concise code, including the modules we recommend in &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;.</source>
          <target state="translated">이러한 검사를 직접 수행하면 지루해질 수 있습니다. 손으로 많은 접근자를 작성하는 것도 매우 지루합니다. CPAN에는 &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; 에서 권장하는 모듈을 포함하여보다 안전하고 간결한 코드를 작성하는 데 도움이되는 많은 모듈이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e1639673d423ca711b3596783b5c0a4171be6aec" translate="yes" xml:space="preserve">
          <source>Doing this:</source>
          <target state="translated">이것을하는 것 :</target>
        </trans-unit>
        <trans-unit id="c70ec1bd923ff14caf24abddbe98bbe566095521" translate="yes" xml:space="preserve">
          <source>Don't assume &lt;code&gt;&amp;gt;&lt;/code&gt; won't be the first character of a filename. Always use &lt;code&gt;&amp;lt;&lt;/code&gt; explicitly to open a file for reading, or even better, use the three-arg version of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;, unless you want the user to be able to specify a pipe open.</source>
          <target state="translated">&lt;code&gt;&amp;gt;&lt;/code&gt; 가 파일 이름의 첫 번째 문자가 아니라고 가정하지 마십시오 . 사용자가 파이프 열림을 지정할 수 있도록하려는 경우를 제외하고 항상 &lt;code&gt;&amp;lt;&lt;/code&gt; 명시 적으로 파일을 읽기 위해 열거 나 3 개 버전의 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="51fadcebe3461dfde168100ac06626ef32c5c3c4" translate="yes" xml:space="preserve">
          <source>Don't assume Unix filesystem access semantics: that read, write, and execute are all the permissions there are, and even if they exist, that their semantics (for example what do &lt;code&gt;&quot;r&quot;&lt;/code&gt; , &lt;code&gt;&quot;w&quot;&lt;/code&gt; , and &lt;code&gt;&quot;x&quot;&lt;/code&gt; mean on a directory) are the Unix ones. The various Unix/POSIX compatibility layers usually try to make interfaces like &lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod()&lt;/a&gt;&lt;/code&gt; work, but sometimes there simply is no good mapping.</source>
          <target state="translated">Unix 파일 시스템 액세스 의미론을 가정하지 마십시오. 읽기, 쓰기 및 실행은 모든 권한이 있으며 해당 권한이있는 경우 해당 의미론 (예 : &lt;code&gt;&quot;r&quot;&lt;/code&gt; , &lt;code&gt;&quot;w&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;x&quot;&lt;/code&gt; 는 무엇을 의미하는지) 디렉토리에)) 유닉스 것들입니다. 다양한 유닉스 / POSIX 호환성 계층은 일반적으로 &lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod()&lt;/a&gt;&lt;/code&gt; 와 같은 인터페이스를 작동 시키려고 하지만 때로는 좋은 매핑이없는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a45b9025bbd946f66021bb7d900991eb240c421" translate="yes" xml:space="preserve">
          <source>Don't assume a particular network device name.</source>
          <target state="translated">특정 네트워크 장치 이름을 가정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="46d416e1f318922467e8a69618050fe453e3d906" translate="yes" xml:space="preserve">
          <source>Don't assume a particular set of &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl()&lt;/a&gt;&lt;/code&gt;s will work.</source>
          <target state="translated">특정 &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl()&lt;/a&gt;&lt;/code&gt; 세트 가 작동 한다고 가정하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="f77b1e37f7f7fe660c8641daee5c495d72fc56f7" translate="yes" xml:space="preserve">
          <source>Don't assume a text file will end with a newline. They should, but people forget.</source>
          <target state="translated">텍스트 파일이 줄 바꿈으로 끝날 것이라고 가정하지 마십시오. 그들은해야하지만 사람들은 잊어 버립니다.</target>
        </trans-unit>
        <trans-unit id="98161964580f6c72edaf8ce914f3e1d98ec3ce2f" translate="yes" xml:space="preserve">
          <source>Don't assume set-uid and set-gid semantics. (And even if you do, think twice: set-uid and set-gid are a known can of security worms.)</source>
          <target state="translated">set-uid 및 set-gid 의미론을 가정하지 마십시오. (그렇더라도 두 번 생각하십시오. set-uid 및 set-gid는 알려진 보안 웜 캔입니다.)</target>
        </trans-unit>
        <trans-unit id="904c69ae9ffdcafece3576aedd570251fa8bd53f" translate="yes" xml:space="preserve">
          <source>Don't assume that &lt;code&gt;Sys::Hostname&lt;/code&gt; (or any other API or command) returns either a fully qualified hostname or a non-qualified hostname: it all depends on how the system had been configured. Also remember that for things such as DHCP and NAT, the hostname you get back might not be very useful.</source>
          <target state="translated">&lt;code&gt;Sys::Hostname&lt;/code&gt; (또는 다른 API 또는 명령)이 완전한 호스트 이름 또는 규정되지 않은 호스트 이름을 리턴 한다고 가정하지 마십시오 . 시스템 구성 방법에 따라 다릅니다. 또한 DHCP 및 NAT와 같은 경우 다시 얻는 호스트 이름이 그다지 유용하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cce6dd3c9e2a99e556dd9e7e5f6487f0ac7f77b2" translate="yes" xml:space="preserve">
          <source>Don't assume that a single &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; completely gets rid of the file: some filesystems (most notably the ones in VMS) have versioned filesystems, and &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink()&lt;/a&gt;&lt;/code&gt; removes only the most recent one (it doesn't remove all the versions because by default the native tools on those platforms remove just the most recent version, too). The portable idiom to remove all the versions of a file is</source>
          <target state="translated">단일 링크 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 가 파일을 완전히 제거 한다고 가정하지 마십시오 . 일부 파일 시스템 (주로 VMS의 파일 시스템)은 버전이 지정된 파일 시스템을 가지고 있으며 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink()&lt;/a&gt;&lt;/code&gt; 는 가장 최신 파일 시스템 만 제거합니다 (모든 파일을 제거하지는 않습니다. 해당 플랫폼의 기본 도구는 최신 버전 만 제거합니다). 파일의 모든 버전을 제거하는 휴대용 관용구는</target>
        </trans-unit>
        <trans-unit id="45827beb2b333818dc1ab476c3c49bc561007b4d" translate="yes" xml:space="preserve">
          <source>Don't assume that any particular port (service) will respond.</source>
          <target state="translated">특정 포트 (서비스)가 응답한다고 가정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="6999e83ecac7276661229b08d824b9951f96931a" translate="yes" xml:space="preserve">
          <source>Don't assume that in pathnames you can collapse two leading slashes &lt;code&gt;//&lt;/code&gt; into one: some networking and clustering filesystems have special semantics for that. Let the operating system sort it out.</source>
          <target state="translated">경로 이름에서 두 개의 슬래시 를 하나로 축소 할 수 있다고 가정하지 마십시오. &lt;code&gt;//&lt;/code&gt; 일부 네트워킹 및 클러스터링 파일 시스템에는 특별한 의미가 있습니다. 운영 체제에서이를 정리하십시오.</target>
        </trans-unit>
        <trans-unit id="98d90ea04fc1672840d09560112d2b5f38aad8d8" translate="yes" xml:space="preserve">
          <source>Don't assume that the epoch starts at 00:00:00, January 1, 1970, because that is OS- and implementation-specific. It is better to store a date in an unambiguous representation. The ISO 8601 standard defines YYYY-MM-DD as the date format, or YYYY-MM-DDTHH:MM:SS (that's a literal &quot;T&quot; separating the date from the time). Please do use the ISO 8601 instead of making us guess what date 02/03/04 might be. ISO 8601 even sorts nicely as-is. A text representation (like &quot;1987-12-18&quot;) can be easily converted into an OS-specific value using a module like &lt;code&gt;Date::Parse&lt;/code&gt; . An array of values, such as those returned by &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt;, can be converted to an OS-specific representation using &lt;code&gt;Time::Local&lt;/code&gt; .</source>
          <target state="translated">시대는 1970 년 1 월 1 일 00:00:00에 시작한다고 가정하지 마십시오. OS 및 구현에 따라 다릅니다. 명확한 표현으로 날짜를 저장하는 것이 좋습니다. ISO 8601 표준은 YYYY-MM-DD를 날짜 형식으로 정의하거나 YYYY-MM-DDTHH : MM : SS (날짜와 시간을 구분하는 문자 &quot;T&quot;)로 정의합니다. 02/03/04의 날짜를 추측하게하는 대신 ISO 8601을 사용하십시오. ISO 8601은 그대로 멋지게 정렬합니다. &lt;code&gt;Date::Parse&lt;/code&gt; 와 같은 모듈을 사용하여 텍스트 표현 (예 : &quot;1987-12-18&quot;)을 OS 특정 값으로 쉽게 변환 할 수 있습니다 . &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 에 의해 반환 된 것과 같은 값의 배열은 &lt;code&gt;Time::Local&lt;/code&gt; 사용하여 OS 특정 표현으로 변환 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ae81459ffe886d165ec19458ee6907edce3977cd" translate="yes" xml:space="preserve">
          <source>Don't assume that the host has only one network card, or that it can't bind to many virtual IP addresses.</source>
          <target state="translated">호스트에 네트워크 카드가 하나만 있거나 많은 가상 IP 주소에 바인딩 할 수 없다고 가정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="762d289b8f69911c48e30355fa8f2ef9119426cc" translate="yes" xml:space="preserve">
          <source>Don't assume that the name used to invoke a command or program with &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; can also be used to test for the existence of the file that holds the executable code for that command or program. First, many systems have &quot;internal&quot; commands that are built-in to the shell or OS and while these commands can be invoked, there is no corresponding file. Second, some operating systems (e.g., Cygwin, DJGPP, OS/2, and VOS) have required suffixes for executable files; these suffixes are generally permitted on the command name but are not required. Thus, a command like</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 를 사용하여 명령 또는 프로그램을 호출하는 데 사용 된 이름을 사용하여 해당 명령 또는 프로그램 의 실행 가능 코드를 보유한 파일의 존재를 테스트 할 수도 있다고 가정하지 마십시오 . 첫째, 많은 시스템에는 셸 또는 OS에 내장 된 &quot;내부&quot;명령이 있으며 이러한 명령을 호출 할 수는 있지만 해당 파일이 없습니다. 둘째, 일부 운영 체제 (예 : Cygwin, DJGPP, OS / 2 및 VOS)는 실행 파일에 대한 접미사가 필요합니다. 이러한 접미사는 일반적으로 명령 이름에서 허용되지만 필수는 아닙니다. 따라서 다음과 같은 명령</target>
        </trans-unit>
        <trans-unit id="1514a854a4b008c5fba8916a7962921e2b8b3a4a" translate="yes" xml:space="preserve">
          <source>Don't assume that there is only one way to get through firewalls to the public Internet.</source>
          <target state="translated">방화벽을 통과하여 공용 인터넷에 도달 할 수있는 유일한 방법이 있다고 가정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="c6a1267eacc3c912d76fd037d987680a5762ee68" translate="yes" xml:space="preserve">
          <source>Don't assume that write/modify permission on a directory gives the right to add or delete files/directories in that directory. That is filesystem specific: in some filesystems you need write/modify permission also (or even just) in the file/directory itself. In some filesystems (AFS, DFS) the permission to add/delete directory entries is a completely separate permission.</source>
          <target state="translated">디렉토리에 대한 쓰기 / 수정 권한이 해당 디렉토리에서 파일 / 디렉토리를 추가하거나 삭제할 수있는 권한을 제공한다고 가정하지 마십시오. 이는 파일 시스템에 따라 다릅니다. 일부 파일 시스템에서는 파일 / 디렉토리 자체에서도 쓰기 / 수정 권한이 필요합니다. 일부 파일 시스템 (AFS, DFS)에서 디렉토리 항목 추가 / 삭제 권한은 완전히 별개의 권한입니다.</target>
        </trans-unit>
        <trans-unit id="445d23235b8dff3b578e3bb5bf0fc30d1a0490ac" translate="yes" xml:space="preserve">
          <source>Don't assume that you can ping hosts and get replies.</source>
          <target state="translated">호스트를 핑하고 응답을받을 수 있다고 가정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="b1edc420b94bcf10bf4d8c3ee5b511b8b1bd17fb" translate="yes" xml:space="preserve">
          <source>Don't assume that you can reach outside world through any other port than 80, or some web proxy. ftp is blocked by many firewalls.</source>
          <target state="translated">80 이외의 포트 나 웹 프록시를 통해 외부에 도달 할 수 있다고 가정하지 마십시오. ftp는 많은 방화벽에 의해 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="c31864fe8f7fd5417d78f831be7f49971ddfa830" translate="yes" xml:space="preserve">
          <source>Don't assume that you can reach the public Internet.</source>
          <target state="translated">공용 인터넷에 연결할 수 있다고 가정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="e3635e84ac318882496643a11d43ff013c114f31" translate="yes" xml:space="preserve">
          <source>Don't assume that you can reach yourself or any node by the name 'localhost'. The same goes for '127.0.0.1'. You will have to try both.</source>
          <target state="translated">'localhost'라는 이름으로 자신이나 다른 노드에 연결할 수 있다고 가정하지 마십시오. '127.0.0.1'도 마찬가지입니다. 둘 다 시도해야합니다.</target>
        </trans-unit>
        <trans-unit id="94e84b069d17212c205601cb91a4bdb912d4357e" translate="yes" xml:space="preserve">
          <source>Don't assume that you can send email by connecting to the local SMTP port.</source>
          <target state="translated">로컬 SMTP 포트에 연결하여 이메일을 보낼 수 있다고 가정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="93ae10616af2ea19ea7f8a1f9e13d6eb9fc81add" translate="yes" xml:space="preserve">
          <source>Don't assume the Unix filesystem access semantics: the operating system or the filesystem may be using some ACL systems, which are richer languages than the usual &lt;code&gt;rwx&lt;/code&gt; . Even if the &lt;code&gt;rwx&lt;/code&gt; exist, their semantics might be different.</source>
          <target state="translated">Unix 파일 시스템 액세스 시맨틱을 가정하지 마십시오. 운영 체제 또는 파일 시스템은 일반적인 &lt;code&gt;rwx&lt;/code&gt; 보다 풍부한 언어 인 일부 ACL 시스템을 사용 중일 수 있습니다 . &lt;code&gt;rwx&lt;/code&gt; 가 존재 하더라도 의미가 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f793b546a43c7fdfddcd37819e15f770633a875c" translate="yes" xml:space="preserve">
          <source>Don't assume the Unix user and group semantics: especially, don't expect &lt;code&gt;$&amp;lt;&lt;/code&gt; and &lt;code&gt;$&amp;gt;&lt;/code&gt; (or &lt;code&gt;$(&lt;/code&gt; and &lt;code&gt;$)&lt;/code&gt; ) to work for switching identities (or memberships).</source>
          <target state="translated">Unix 사용자 및 그룹 의미를 가정하지 마십시오. 특히 &lt;code&gt;$&amp;lt;&lt;/code&gt; 및 &lt;code&gt;$&amp;gt;&lt;/code&gt; (또는 &lt;code&gt;$(&lt;/code&gt; 및 &lt;code&gt;$)&lt;/code&gt; )가 ID (또는 멤버쉽)를 전환 하는 데 사용할 것으로 기대하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="de83ff9adf0f76046a05e27193105138389e30d8" translate="yes" xml:space="preserve">
          <source>Don't be afraid to use loop labels--they're there to enhance readability as well as to allow multilevel loop breaks. See the previous example.</source>
          <target state="translated">루프 레이블을 사용하는 것을 두려워하지 마십시오. 가독성을 높이고 다중 레벨 루프 나누기를 허용합니다. 이전 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="789665e74c277d58dbd4bc3f085faf66c237708c" translate="yes" xml:space="preserve">
          <source>Don't be fooled into thinking that it is hard to create portable Perl code. It isn't. Perl tries its level-best to bridge the gaps between what's available on different platforms, and all the means available to use those features. Thus almost all Perl code runs on any machine without modification. But there are some significant issues in writing portable code, and this document is entirely about those issues.</source>
          <target state="translated">휴대용 Perl 코드를 작성하기가 어렵다고 생각하지 마십시오. 그렇지 않습니다. Perl은 다른 플랫폼에서 사용 가능한 기능과 해당 기능을 사용할 수있는 모든 수단 사이의 격차를 해소하기 위해 최선을 다합니다. 따라서 거의 모든 Perl 코드가 수정없이 모든 컴퓨터에서 실행됩니다. 그러나 이식 가능한 코드를 작성하는 데 중요한 문제가 있으며이 문서는 전적으로 이러한 문제에 관한 것입니다.</target>
        </trans-unit>
        <trans-unit id="e9382c68d62f11f58c0e0116d77660fc6a3b3ba4" translate="yes" xml:space="preserve">
          <source>Don't blame Perl. It's the same as in C. IEEE says we have to do this. Perl numbers whose absolute values are integers under 2**31 (on 32-bit machines) will work pretty much like mathematical integers. Other numbers are not guaranteed.</source>
          <target state="translated">Perl을 비난하지 마십시오. IEEE와 마찬가지로 C도 마찬가지다. 절대 값이 2 ** 31 (32 비트 시스템) 미만의 정수인 Perl 숫자는 수학 정수와 매우 유사합니다. 다른 번호는 보장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="774b4dd48a669835b4126c2772387c78ce9c98be" translate="yes" xml:space="preserve">
          <source>Don't bother using &lt;code&gt;trailingData&lt;/code&gt; if the input is a filename.</source>
          <target state="translated">입력이 파일 이름 인 경우 &lt;code&gt;trailingData&lt;/code&gt; 를 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="e2b0a9f3aafe7e01341dfe674e6e343efc8bbb76" translate="yes" xml:space="preserve">
          <source>Don't change this variable unless you &lt;b&gt;really&lt;/b&gt; know what you're doing.</source>
          <target state="translated">&lt;b&gt;실제로&lt;/b&gt; 수행중인 작업을 모르면 이 변수를 변경하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="bf3d8d6437b2fb83642a1fd7abe5420705d405dd" translate="yes" xml:space="preserve">
          <source>Don't count on a specific environment variable existing in &lt;code&gt;%ENV&lt;/code&gt; . Don't count on &lt;code&gt;%ENV&lt;/code&gt; entries being case-sensitive, or even case-preserving. Don't try to clear &lt;code&gt;%ENV&lt;/code&gt; by saying &lt;code&gt;%ENV = ();&lt;/code&gt; , or, if you really have to, make it conditional on &lt;code&gt;$^O ne 'VMS'&lt;/code&gt; since in VMS the &lt;code&gt;%ENV&lt;/code&gt; table is much more than a per-process key-value string table.</source>
          <target state="translated">&lt;code&gt;%ENV&lt;/code&gt; 존재하는 특정 환경 변수에 의존하지 마십시오 . 대소 문자를 구분하거나 대소 문자를 유지하는 &lt;code&gt;%ENV&lt;/code&gt; 항목을 사용 하지 마십시오 . &lt;code&gt;%ENV = ();&lt;/code&gt; 라고 말하여 &lt;code&gt;%ENV&lt;/code&gt; 를 지우려고하지 마십시오 . 또는 VMS에서 &lt;code&gt;%ENV&lt;/code&gt; 테이블은 프로세스 당 키-값 문자열 테이블보다 훨씬 크기 때문에 &lt;code&gt;$^O ne 'VMS'&lt;/code&gt; 에 대해 조건부로 만들어야 합니다.</target>
        </trans-unit>
        <trans-unit id="037f7905f794172b9aa798cbaa7cfb0372b5498b" translate="yes" xml:space="preserve">
          <source>Don't count on filename globbing. Use &lt;code&gt;&lt;a href=&quot;functions/opendir&quot;&gt;opendir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/closedir&quot;&gt;closedir&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">파일 이름 globbing에 의존하지 마십시오. 대신 &lt;code&gt;&lt;a href=&quot;functions/opendir&quot;&gt;opendir&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/closedir&quot;&gt;closedir&lt;/a&gt;&lt;/code&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e8d15e2d76caf019a3701f78e8198d57683e81f9" translate="yes" xml:space="preserve">
          <source>Don't count on per-program environment variables, or per-program current directories.</source>
          <target state="translated">프로그램 별 환경 변수 또는 프로그램 별 현재 디렉토리를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="660cbdd54752be68a4dc2ccd79e3477dc980f960" translate="yes" xml:space="preserve">
          <source>Don't count on signals or &lt;code&gt;%SIG&lt;/code&gt; for anything.</source>
          <target state="translated">신호 나 &lt;code&gt;%SIG&lt;/code&gt; 를 계산하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="2504f73349f543cd4ab97266d28a299e9f5178ef" translate="yes" xml:space="preserve">
          <source>Don't count on specific values of &lt;code&gt;$!&lt;/code&gt; , neither numeric nor especially the string values. Users may switch their locales causing error messages to be translated into their languages. If you can trust a POSIXish environment, you can portably use the symbols defined by the &lt;code&gt;Errno&lt;/code&gt; module, like &lt;code&gt;ENOENT&lt;/code&gt; . And don't trust on the values of &lt;code&gt;$!&lt;/code&gt; at all except immediately after a failed system call.</source>
          <target state="translated">&lt;code&gt;$!&lt;/code&gt; 특정 값에 의존하지 마십시오 ! 숫자 나 문자열 값이 아닙니다. 사용자가 로케일을 전환하여 오류 메시지가 해당 언어로 번역 될 수 있습니다. POSIXish 환경을 신뢰할 수있는 경우 &lt;code&gt;ENOENT&lt;/code&gt; 와 같이 &lt;code&gt;Errno&lt;/code&gt; 모듈에 의해 정의 된 기호를 이식 가능하게 사용할 수 있습니다 . 그리고 &lt;code&gt;$!&lt;/code&gt; 의 가치를 믿지 마십시오 ! 시스템 호출이 실패한 직후를 제외하고는</target>
        </trans-unit>
        <trans-unit id="d29e3f7d07b96795819a57e76db3864389865c2f" translate="yes" xml:space="preserve">
          <source>Don't direct the users of your module to download &lt;code&gt;Devel::PPPort&lt;/code&gt; . They are most probably no XS writers. Also, don't make</source>
          <target state="translated">모듈 사용자에게 &lt;code&gt;Devel::PPPort&lt;/code&gt; 를 다운로드하도록 지시하지 마십시오 . 그들은 아마도 XS 작가가 아닐 것입니다. 또한 만들지 마십시오</target>
        </trans-unit>
        <trans-unit id="4c8b6f86bbfc2b6c173c74faf597f3f3d4ca2dc7" translate="yes" xml:space="preserve">
          <source>Don't display</source>
          <target state="translated">표시하지 않음</target>
        </trans-unit>
        <trans-unit id="c1e22de2ba66c0889226c5735ba53c5285571154" translate="yes" xml:space="preserve">
          <source>Don't display mostly harmless warning messages.</source>
          <target state="translated">대부분 무해한 경고 메시지를 표시하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="1547fa551c603cca7def3259e5b1fd45d8dbc6f8" translate="yes" xml:space="preserve">
          <source>Don't fall into the trap of using a &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; when a simple &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; would do. The &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; is more efficient and less error prone.</source>
          <target state="translated">간단한 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 할 때 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 를 사용하는 함정에 빠지지 마십시오 . &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 보다 효율적이고 덜 오류 경향이있다.</target>
        </trans-unit>
        <trans-unit id="29cf7dc4de80fc368eaed82cbb02b8b6d7166fa2" translate="yes" xml:space="preserve">
          <source>Don't fall into the trap of using a &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; when a simple &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; would do. The &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; is more efficient and less error prone.</source>
          <target state="translated">간단한 &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 할 때 &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 를 사용하는 함정에 빠지지 마십시오 . &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 보다 효율적이고 덜 오류 경향이있다.</target>
        </trans-unit>
        <trans-unit id="2de68b400b15f729bfc2845f7ab8c8768fb9196d" translate="yes" xml:space="preserve">
          <source>Don't fall into the trap of writing for the wrong audience. Your primary audience is a reasonably experienced developer with at least a moderate understanding of your module's application domain, who's just downloaded your module and wants to start using it as quickly as possible.</source>
          <target state="translated">잘못된 청중을 위해 글쓰기의 함정에 빠지지 마십시오. 주요 대상은 모듈을 다운로드 한 후 가능한 빨리 모듈을 사용하기를 원하는 모듈의 응용 프로그램 도메인에 대해 최소한의 지식을 갖춘 합리적인 경험을 갖춘 개발자입니다.</target>
        </trans-unit>
        <trans-unit id="f7e449fde074df52d869952df1fc18793a8a93fc" translate="yes" xml:space="preserve">
          <source>Don't forget the exceptional, pathological cases.</source>
          <target state="translated">예외적 인 병리학 적 사례를 잊지 마십시오.</target>
        </trans-unit>
        <trans-unit id="b1e51289079b4f632343c894dc7cce8050066f98" translate="yes" xml:space="preserve">
          <source>Don't forget to</source>
          <target state="translated">잊지 마세요</target>
        </trans-unit>
        <trans-unit id="3e6739c8879bd9d08b76ade5df931676453f506a" translate="yes" xml:space="preserve">
          <source>Don't go through silly contortions to exit a loop at the top or the bottom, when Perl provides the &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; operator so you can exit in the middle. Just &quot;outdent&quot; it a little to make it more visible:</source>
          <target state="translated">Perl이 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 연산자를 제공 하여 중간에서 빠져 나올 때 상단 또는 하단의 루프를 종료하기 위해 바보 같은 왜곡을 겪지 마십시오 . 좀 더 눈에 잘 띄게하기 위해 조금만 &quot;들여 쓰기&quot;하십시오.</target>
        </trans-unit>
        <trans-unit id="f24938e6209641248330c946317ddd16f85839df" translate="yes" xml:space="preserve">
          <source>Don't just present an example without explaining what it does. Adding a short paragraph saying what the example will do can increase the value of the example immensely.</source>
          <target state="translated">그것이 무엇을 설명하지 않고 단지 예를 제시하지 마십시오. 예제가 무엇을하는지 짧은 단락을 추가하면 예제의 가치가 엄청나게 증가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af2f3b7627d5c9318a43fdf0c7ed8eb29f6f63df" translate="yes" xml:space="preserve">
          <source>Don't mix filtered &amp;amp; non-filtered data in the same database file.</source>
          <target state="translated">필터링 된 데이터와 필터링되지 않은 데이터를 동일한 데이터베이스 파일에 혼합하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="9bfaee9208ed0b4080e76b49f7092be9da21317d" translate="yes" xml:space="preserve">
          <source>Don't open the same file more than once at a time for writing, as some operating systems put mandatory locks on such files.</source>
          <target state="translated">일부 운영 체제는 이러한 파일에 강제 잠금을 설정하므로 쓰기 위해 같은 파일을 한 번에 두 번 이상 열지 마십시오.</target>
        </trans-unit>
        <trans-unit id="13d0e6ad295f2f5fa4a0e1c2294ab660c2ff68f2" translate="yes" xml:space="preserve">
          <source>Don't output the &quot;(definitions)&quot; sections.</source>
          <target state="translated">&quot;(정의)&quot;섹션을 출력하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="8760a0137fe661818eb2724e50d3c58a224e6f3d" translate="yes" xml:space="preserve">
          <source>Don't put &quot;=head</source>
          <target state="translated">&quot;= 머리를 넣지 마십시오</target>
        </trans-unit>
        <trans-unit id="ad5ea38ded2263705342205dafdb4799d4e0a15b" translate="yes" xml:space="preserve">
          <source>Don't quote large strings unless absolutely necessary:</source>
          <target state="translated">꼭 필요한 경우가 아니면 큰 문자열을 인용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="f5cf2886b363988134aefd1d621d74fc94b6b465" translate="yes" xml:space="preserve">
          <source>Don't re-invent the wheel</source>
          <target state="translated">바퀴를 다시 발명하지 마십시오</target>
        </trans-unit>
        <trans-unit id="81177c27776c8009338c295142a35e130e198399" translate="yes" xml:space="preserve">
          <source>Don't read an entire file into memory if you can process it line by line. Or more concretely, use a loop like this:</source>
          <target state="translated">한 줄씩 처리 할 수 ​​있다면 전체 파일을 메모리로 읽지 마십시오. 또는 더 구체적으로 다음과 같은 루프를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a35797b1a1b72b9841ad51955b9000b5a1529ffb" translate="yes" xml:space="preserve">
          <source>Don't require every module user to jump through the same hoops to achieve a simple result. You can always include optional parameters or routines for more complex or non-standard behaviour. If most of your users have to type a few almost identical lines of code when they start using your module, it's a sign that you should have made that behaviour a default. Another good indicator that you should use defaults is if most of your users call your routines with the same arguments.</source>
          <target state="translated">간단한 결과를 얻기 위해 모든 모듈 사용자가 동일한 후프를 뛰어 넘을 필요는 없습니다. 더 복잡하거나 비표준적인 동작을 위해 선택적 매개 변수 또는 루틴을 항상 포함 할 수 있습니다. 대부분의 사용자가 모듈을 사용할 때 거의 동일한 코드 줄을 입력해야하는 경우 해당 동작을 기본값으로 설정해야합니다. 기본값을 사용해야한다는 또 다른 좋은 지표는 대부분의 사용자가 동일한 인수로 루틴을 호출하는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="c723f7c592b67ddf269e14e867541435896967e5" translate="yes" xml:space="preserve">
          <source>Don't scan for the found substrings.</source>
          <target state="translated">찾은 하위 문자열을 스캔하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="d6fcbb0953d0c44b0d3d4321526cee5c66bebf52" translate="yes" xml:space="preserve">
          <source>Don't send a bug received acknowledgement to the reply address. Generally it is only a sensible to use this option if you are a perl maintainer actively watching perl porters for your message to arrive.</source>
          <target state="translated">회신 주소로 버그 수신 확인을 보내지 마십시오. 일반적으로 Perl 관리자가 펄 포터를 적극적으로보고 메시지가 도착하는 경우이 옵션을 사용하는 것이 합리적입니다.</target>
        </trans-unit>
        <trans-unit id="22920608692f0a3432e5ce4c9717be87d806f116" translate="yes" xml:space="preserve">
          <source>Don't send copy to administrator.</source>
          <target state="translated">관리자에게 사본을 보내지 마십시오.</target>
        </trans-unit>
        <trans-unit id="4bc7424f428b4c2b286895e2bee1c1badf45b0f9" translate="yes" xml:space="preserve">
          <source>Don't think about it too much.</source>
          <target state="translated">그것에 대해 너무 많이 생각하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="e145223fc51004b2dae0ceec37468cb3be4a2528" translate="yes" xml:space="preserve">
          <source>Don't think that you can get the address of a Perl variable when it is stored as an integer or double number! &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;('P', $x)&lt;/code&gt; will force the variable's internal representation to string, just as if you had written something like &lt;code&gt;$x .= ''&lt;/code&gt; .</source>
          <target state="translated">정수 또는 이중 숫자로 저장된 Perl 변수의 주소를 얻을 수 있다고 생각하지 마십시오! &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;('P', $x)&lt;/code&gt; 는 &lt;code&gt;$x .= ''&lt;/code&gt; 와 같은 것을 쓴 것처럼 변수의 내부 표현을 문자열로 강제합니다 .</target>
        </trans-unit>
        <trans-unit id="5c0c8af6f9c4025d7dc7e616e0715698cd40e403" translate="yes" xml:space="preserve">
          <source>Don't try to clear &lt;code&gt;%ENV&lt;/code&gt; by saying &lt;code&gt;%ENV = ();&lt;/code&gt; , it will throw a fatal error. This is equivalent to doing the following from DCL:</source>
          <target state="translated">&lt;code&gt;%ENV = ();&lt;/code&gt; 라고 말하여 &lt;code&gt;%ENV&lt;/code&gt; 를 지우려고하지 마십시오 . 치명적인 오류가 발생합니다. 이것은 DCL에서 다음을 수행하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ed025c55f145c736fa2b816ded97f2454d7a958f" translate="yes" xml:space="preserve">
          <source>Don't try to do this:</source>
          <target state="translated">이것을 시도하지 마십시오 :</target>
        </trans-unit>
        <trans-unit id="6dcb6f3c6b552350b94a3e90424b7771b163de66" translate="yes" xml:space="preserve">
          <source>Don't use &quot;=item&quot;s outside of an &quot;=over&quot; ... &quot;=back&quot; region.</source>
          <target state="translated">&quot;= over&quot;... &quot;= back&quot;영역 외부에서 &quot;= item&quot;을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="a7de6cdfcbff257732efdc95079781ff79434e7b" translate="yes" xml:space="preserve">
          <source>Don't use &lt;code&gt;:&lt;/code&gt; as a part of a filename since many systems use that for their own semantics (Mac OS Classic for separating pathname components, many networking schemes and utilities for separating the nodename and the pathname, and so on). For the same reasons, avoid &lt;code&gt;@&lt;/code&gt; , &lt;code&gt;;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="translated">사용하지 마십시오 &lt;code&gt;:&lt;/code&gt; 파일 이름의 일환으로 많은 시스템이 (등등 노드 이름 및 경로 이름을 분리하는 경로 이름 구성 요소, 많은 네트워킹 체계 및 유틸리티를 분리 맥 OS 클래식 등) 자신의 의미에 대한 것을 사용하기 때문이다. 같은 이유로, 피할 &lt;code&gt;@&lt;/code&gt; , &lt;code&gt;;&lt;/code&gt; 와 &lt;code&gt;|&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd80fb1475bf587607bf23dcb48492b2994f3826" translate="yes" xml:space="preserve">
          <source>Don't use &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; to abort a subroutine if there's any chance that someone might want to trap whatever error happened. Use &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; instead, which can be trapped by an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">누군가 어떤 오류가 발생했는지 파악하려는 경우 &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; 를 사용 하여 서브 루틴을 중단 하지 마십시오 . 대신 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 에 갇힐 수있는 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4ae3e40c5aafd256eca74b7ca54a5e5fe01a8a09" translate="yes" xml:space="preserve">
          <source>Don't use &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; to abort a subroutine if there's any chance that someone might want to trap whatever error happened. Use &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; instead, which can be trapped by an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">누군가 어떤 오류가 발생했는지 파악하려는 경우 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; 를 사용 하여 서브 루틴을 중단 하지 마십시오 . 대신 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 에 갇힐 수있는 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4cae11462d2674103d0d8e77ff3c2d3bb81f328e" translate="yes" xml:space="preserve">
          <source>Don't use it. It makes no sense to deal with bytes in a text string, and it makes no sense to deal with characters in a byte string. Do the proper conversions (by decoding/encoding), and things will work out well: you get character counts for decoded data, and byte counts for encoded data.</source>
          <target state="translated">사용하지 마십시오. 텍스트 문자열에서 바이트를 처리하는 것은 의미가 없으며 바이트 문자열의 문자를 처리하는 것은 의미가 없습니다. 디코딩 / 인코딩을 통해 적절한 변환을 수행하면 제대로 작동합니다. 디코딩 된 데이터의 문자 수와 인코딩 된 데이터의 바이트 수를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="31a008400a1239308283e11c2496113f4c495814" translate="yes" xml:space="preserve">
          <source>Don't use it. Unfortunately, it assumes that the programmer's environment and that of the user will use the same encoding. It will use the same encoding for the source code and for STDIN and STDOUT. When a program is copied to another machine, the source code does not change, but the STDIO environment might.</source>
          <target state="translated">사용하지 마십시오. 불행히도 프로그래머 환경과 사용자 환경이 동일한 인코딩을 사용한다고 가정합니다. 소스 코드와 STDIN 및 STDOUT에 동일한 인코딩을 사용합니다. 프로그램이 다른 머신으로 복사 될 때 소스 코드는 변경되지 않지만 STDIO 환경은 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9b01c21ad5ce16a7981e3294ccf4cf41b5fef04" translate="yes" xml:space="preserve">
          <source>Don't use this module directly.</source>
          <target state="translated">이 모듈을 직접 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="71ee42da50b79ae9e6a47caf180fc6688aabc5ce" translate="yes" xml:space="preserve">
          <source>Don't use this.</source>
          <target state="translated">이것을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="d8022c54cffc7dadfd83dedf1e4a2dbf6ad467e8" translate="yes" xml:space="preserve">
          <source>Don't worry about posting if you can't say when the module will be ready - just say so in the message. It might be worth inviting others to help you, they may be able to complete it for you!</source>
          <target state="translated">언제 모듈이 준비 될 지 말할 수 없다면 게시에 대해 걱정하지 마십시오. 메시지에서 그렇게 말하십시오. 다른 사람들을 초대하여 도움을받을만한 가치가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="327df9e94148631e3c9a41cfa753d9d2769d418a" translate="yes" xml:space="preserve">
          <source>Don't worry if it says Math::BigInt::Lite, bignum and friends will use Lite if it is installed since it is faster for some operations. It will be automatically upgraded to BigInt whenever necessary:</source>
          <target state="translated">Math :: BigInt :: Lite, bignum 및 friends가 일부 작업에 더 빠르기 때문에 Lite가 설치된 경우 Lite를 사용한다고 걱정하지 마십시오. 필요할 때마다 BigInt로 자동 업그레이드됩니다.</target>
        </trans-unit>
        <trans-unit id="83fe6a1f79295f6f6329274881574682cc33b843" translate="yes" xml:space="preserve">
          <source>Done by Archive::Tar internally when reading the tar file: validate the header against the checksum to ensure integer tar file.</source>
          <target state="translated">tar 파일을 읽을 때 내부적으로 Archive :: Tar로 수행 : 정수 tar 파일을 보장하기 위해 체크섬에 대해 헤더의 유효성을 검사하십시오.</target>
        </trans-unit>
        <trans-unit id="9b0acdbd029a7828ca595b0d9f7618bd97d3679c" translate="yes" xml:space="preserve">
          <source>Dotfiles.pm</source>
          <target state="translated">Dotfiles.pm</target>
        </trans-unit>
        <trans-unit id="b17ae50dd8754e17c2584e6a5426d3fcdb608cdb" translate="yes" xml:space="preserve">
          <source>Double quotes indicate that the text will be interpolated using exactly the same rules as normal double quoted strings.</source>
          <target state="translated">큰 따옴표는 텍스트가 일반적인 큰 따옴표로 묶인 문자열과 정확히 동일한 규칙을 사용하여 보간됨을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d8bdee99b293542316fa229d2907bcacda4feae8" translate="yes" xml:space="preserve">
          <source>Double quotes or single quotes may be used around literal strings:</source>
          <target state="translated">리터럴 문자열에는 큰 따옴표 또는 작은 따옴표를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c45e85fa2adbda8304a1994b69613855b231b88d" translate="yes" xml:space="preserve">
          <source>Double-Typed SVs</source>
          <target state="translated">더블 타입 SV</target>
        </trans-unit>
        <trans-unit id="bc0859619112e37c2df7dc4b11b4c4a86c663786" translate="yes" xml:space="preserve">
          <source>Doug MacEachern &amp;lt;&lt;code&gt;dougm@osf.org&lt;/code&gt; &amp;gt;</source>
          <target state="translated">Doug MacEachern &amp;lt; &lt;code&gt;dougm@osf.org&lt;/code&gt; &amp;gt;</target>
        </trans-unit>
        <trans-unit id="ebd84c7c0c73cf64e66299d99641345c7d6ec4c9" translate="yes" xml:space="preserve">
          <source>Doug MacEachern has an article on embedding in Volume 1, Issue 4 of The Perl Journal ( &lt;a href=&quot;http://www.tpj.com/&quot;&gt;http://www.tpj.com/&lt;/a&gt; ). Doug is also the developer of the most widely-used Perl embedding: the mod_perl system (perl.apache.org), which embeds Perl in the Apache web server. Oracle, Binary Evolution, ActiveState, and Ben Sugars's nsapi_perl have used this model for Oracle, Netscape and Internet Information Server Perl plugins.</source>
          <target state="translated">Doug MacEachern은 The Perl Journal ( &lt;a href=&quot;http://www.tpj.com/&quot;&gt;http://www.tpj.com/&lt;/a&gt; ) 1 권 4 호에 임베드하는 기사를 가지고 있습니다. Doug는 가장 널리 사용되는 Perl 임베딩 개발자 인 mod_perl 시스템 (perl.apache.org)이며 Perl을 Apache 웹 서버에 임베드합니다. Oracle, Binary Evolution, ActiveState 및 Ben Sugars의 nsapi_perl은 Oracle, Netscape 및 Internet Information Server Perl 플러그인에이 모델을 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="efd9fe42018c0e9681fed6f906ad1da72ef74937" translate="yes" xml:space="preserve">
          <source>Down this road lies madness.</source>
          <target state="translated">이 길 아래에는 광기가 있습니다.</target>
        </trans-unit>
        <trans-unit id="711e55a0520f6b8eb41cd3adf5cf2f6dfb3f33d2" translate="yes" xml:space="preserve">
          <source>Downgrade existing SSL connection back to plain. This is needed to work with some FTP helpers at firewalls, which need to see the PORT and PASV commands and responses to dynamically open the necessary ports. In this case &lt;code&gt;starttls&lt;/code&gt; is usually only done to protect the authorization.</source>
          <target state="translated">기존 SSL 연결을 일반으로 다시 다운 그레이드하십시오. 방화벽에서 일부 FTP 헬퍼와 작업하려면 필요한 포트를 동적으로 열려면 PORT 및 PASV 명령과 응답을 확인해야합니다. 이 경우 &lt;code&gt;starttls&lt;/code&gt; 는 일반적으로 권한을 보호하기 위해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="6863ad3882079de8bb32abea0819f1a0f48ff477" translate="yes" xml:space="preserve">
          <source>Download and install the Filter::Simple module. (If you have Perl 5.7.1 or later, this is already done for you.)</source>
          <target state="translated">Filter :: Simple 모듈을 다운로드하여 설치하십시오. (Perl 5.7.1 이상을 사용하는 경우 이미 완료된 것입니다.)</target>
        </trans-unit>
        <trans-unit id="026541fe8b438be29a9f47a4ab1e22dcb6dbc643" translate="yes" xml:space="preserve">
          <source>Download target directory?</source>
          <target state="translated">대상 디렉토리를 다운로드 하시겠습니까?</target>
        </trans-unit>
        <trans-unit id="824b6b54054ef1a9091856d053b0662e9a165ca3" translate="yes" xml:space="preserve">
          <source>Download the ExtUtils::Embed kit from CPAN and run `make test'. If the tests pass, read the pods again and again and again. If they fail, see &lt;a href=&quot;perlbug&quot;&gt;perlbug&lt;/a&gt; and send a bug report with the output of &lt;code&gt;make test TEST_VERBOSE=1&lt;/code&gt; along with &lt;code&gt;perl -V&lt;/code&gt; .</source>
          <target state="translated">CPAN에서 ExtUtils :: Embed 키트를 다운로드하고`make test '를 실행하십시오. 테스트에 통과하면 포드를 계속해서 반복해서 읽으십시오. 실패하면 &lt;a href=&quot;perlbug&quot;&gt;perlbug를&lt;/a&gt; 참조 하고 &lt;code&gt;perl -V&lt;/code&gt; 와 함께 &lt;code&gt;make test TEST_VERBOSE=1&lt;/code&gt; 출력으로 버그 보고서를 보내십시오 .</target>
        </trans-unit>
        <trans-unit id="3467811ada73635cf68082c7cc090eea63c880e2" translate="yes" xml:space="preserve">
          <source>Download the files in the desired version of Unicode from the Unicode web site &lt;a href=&quot;http://www.unicode.org&quot;&gt;http://www.unicode.org&lt;/a&gt;). These should replace the existing files in</source>
          <target state="translated">유니 코드 웹 사이트 ( &lt;a href=&quot;http://www.unicode.org&quot;&gt;http://www.unicode.org&lt;/a&gt; ) 에서 원하는 유니 코드 버전으로 파일을 다운로드하십시오 . 이것들은 기존 파일을 대체해야합니다.</target>
        </trans-unit>
        <trans-unit id="c1b64de29b8a9bf6464d6b725c2720abd75c3426" translate="yes" xml:space="preserve">
          <source>Download the pmd-bin-X.Y.zip () from the SourceForge site, extract the pmd-X.Y.jar from it, and then run that on source code thusly:</source>
          <target state="translated">SourceForge 사이트에서 pmd-bin-XYzip ()을 다운로드하여 pmd-XYjar을 추출한 다음 소스 코드에서 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="e49fb030ab1aaee57147e5e7a7127ea439db8792" translate="yes" xml:space="preserve">
          <source>Download, build, and install the Filter::Util::Call module. (If you have Perl 5.7.1 or later, this is already done for you.)</source>
          <target state="translated">Filter :: Util :: Call 모듈을 다운로드, 빌드 및 설치하십시오. (Perl 5.7.1 이상을 사용하는 경우 이미 완료된 것입니다.)</target>
        </trans-unit>
        <trans-unit id="08f4aa0358a86ec0353cf2d2ed049201bf17031c" translate="yes" xml:space="preserve">
          <source>Downloads report data for this distribution from www.cpantesters.org and displays a subset of them.</source>
          <target state="translated">이 배포판에 대한 보고서 데이터는 www.cpantesters.org에서 다운로드하여 해당 하위 세트를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="366a5eddbaecc6160b117d778c095e50de4e854c" translate="yes" xml:space="preserve">
          <source>Downloads the README file associated with a distribution and runs it through the pager specified in &lt;code&gt;$CPAN::Config-&amp;gt;{pager}&lt;/code&gt; .</source>
          <target state="translated">분배와 연관된 README 파일을 다운로드하여 &lt;code&gt;$CPAN::Config-&amp;gt;{pager}&lt;/code&gt; 지정된 호출기를 통해 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d9c288326280b540c25926e9df585a7d06577d9" translate="yes" xml:space="preserve">
          <source>Downloads the distribution from CPAN and unpacks it. Does nothing if the distribution has already been downloaded and unpacked within the current session.</source>
          <target state="translated">CPAN에서 배포를 다운로드하여 압축을 풉니 다. 현재 세션 내에서 배포가 이미 다운로드 및 압축 해제 된 경우 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8b9ffede701ef3f70bd821cb754750834e2eee96" translate="yes" xml:space="preserve">
          <source>Downloads the pod documentation of the file associated with a distribution (in HTML format) and runs it through the external command</source>
          <target state="translated">배포와 관련된 파일의 포드 문서 (HTML 형식)를 다운로드하고 외부 명령을 통해 실행합니다.</target>
        </trans-unit>
        <trans-unit id="47d8215ef4fc8a530cd9137d652dba538ecf4224" translate="yes" xml:space="preserve">
          <source>Draw the tree with standard ASCII characters like &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;. These don't look as clean as the VT100 characters, but they'll work with almost any terminal (or the horizontal scrolling mode of less(1)) and are suitable for text documentation or email. This is the default.</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 및 &lt;code&gt;|&lt;/code&gt; 와 같은 표준 ASCII 문자로 트리를 그립니다. . VT100 문자만큼 깔끔하지는 않지만 거의 모든 터미널 (또는 가로 스크롤 모드 (1))에서 작동하며 텍스트 문서 나 전자 메일에 적합합니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="435321dd1c82c18e50a09e89a625d44c2cad992d" translate="yes" xml:space="preserve">
          <source>Due to a bug in Perl, &lt;code&gt;autodie&lt;/code&gt; may &quot;lose&quot; any format which has the same name as an autodying built-in or function.</source>
          <target state="translated">Perl의 버그로 인해 &lt;code&gt;autodie&lt;/code&gt; 는 autodying 내장 또는 기능과 동일한 이름을 가진 형식을 &quot;손실&quot;할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f8b083c9efdbb98335cadbb85143fc7af77ce11" translate="yes" xml:space="preserve">
          <source>Due to a popular demand the perl external program calling has been changed wrt Andreas Kaiser's port.</source>
          <target state="translated">대중적인 요구로 인해 펄 외부 프로그램 호출은 Andreas Kaiser의 포트로 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="2fa72b6c00f9a2dd66e6782d6e7396b6679249ff" translate="yes" xml:space="preserve">
          <source>Due to an implementation glitch, the &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; hook is called even inside an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;. Do not use this to rewrite a pending exception in &lt;code&gt;$@&lt;/code&gt; , or as a bizarre substitute for overriding &lt;code&gt;CORE::GLOBAL::die()&lt;/code&gt; . This strange action at a distance may be fixed in a future release so that &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; is only called if your program is about to exit, as was the original intent. Any other use is deprecated.</source>
          <target state="translated">구현 결함으로 인해 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 후크는 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 내부에서도 호출 됩니다. &lt;code&gt;$@&lt;/code&gt; 의 보류중인 예외를 다시 작성 하거나 &lt;code&gt;CORE::GLOBAL::die()&lt;/code&gt; 를 대체하는 기괴한 대체물로 이를 사용하지 마십시오 . 원거리에서이 이상한 동작은 향후 릴리스에서 수정 될 수 있으므로 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 은 원래 의도와 마찬가지로 프로그램을 종료하려고 할 때만 호출됩니다. 다른 사용은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c65e636e9846e4e76451103ccccbb36e90580ce5" translate="yes" xml:space="preserve">
          <source>Due to an unfortunate bug in how &lt;code&gt;given&lt;/code&gt; was implemented between Perl 5.10 and 5.16, under those implementations the version of &lt;code&gt;$_&lt;/code&gt; governed by &lt;code&gt;given&lt;/code&gt; is merely a lexically scoped copy of the original, not a dynamically scoped alias to the original, as it would be if it were a &lt;code&gt;foreach&lt;/code&gt; or under both the original and the current Perl 6 language specification. This bug was fixed in Perl 5.18. If you really want a lexical &lt;code&gt;$_&lt;/code&gt; , specify that explicitly, but note that &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; is now deprecated and will warn unless warnings have been disabled:</source>
          <target state="translated">때문에 방법에 불행한 버그 &lt;code&gt;given&lt;/code&gt; 의 그 구현에서 버전, 펄 5.10와 5.16 사이에 구현 된 &lt;code&gt;$_&lt;/code&gt; 에 의해 지배 &lt;code&gt;given&lt;/code&gt; 가 될 것 같은 원래의 어휘 범위 사본이 아닌 원본 동적 범위 별명은, 단지입니다 &lt;code&gt;foreach&lt;/code&gt; 이거나 원래 및 현재 Perl 6 언어 스펙 둘 다에 해당 하는 경우 이 버그는 Perl 5.18에서 수정되었습니다. 어휘 &lt;code&gt;$_&lt;/code&gt; 를 정말로 원한다면 명시 적으로 지정하지만 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; 은 더 이상 사용되지 않으며 경고가 비활성화되지 않으면 경고합니다.</target>
        </trans-unit>
        <trans-unit id="a5aff89951fd9e95c733a40d7b1bb49174fdbcb8" translate="yes" xml:space="preserve">
          <source>Due to backwards compatibility, all filehandles resemble objects of class &lt;code&gt;IO::Handle&lt;/code&gt; , or actually classes derived from that class. They actually aren't. Which means you can't derive your own class from &lt;code&gt;IO::Handle&lt;/code&gt; and inherit those methods.</source>
          <target state="translated">이전 버전과의 호환성으로 인해 모든 파일 핸들은 클래스 &lt;code&gt;IO::Handle&lt;/code&gt; 객체 또는 실제로 해당 클래스에서 파생 된 클래스와 유사합니다 . 그들은 실제로 그렇지 않습니다. 즉, &lt;code&gt;IO::Handle&lt;/code&gt; 에서 자신의 클래스를 파생 시키고 해당 메소드를 상속 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="46599dc97579c3a9d5b0ac13818c4864629c3a1b" translate="yes" xml:space="preserve">
          <source>Due to how subtests work, you may omit a plan if you desire. This adds an implicit &lt;code&gt;done_testing()&lt;/code&gt; to the end of your subtest. The following two subtests are equivalent:</source>
          <target state="translated">하위 테스트의 작동 방식으로 인해 원하는 경우 계획을 생략 할 수 있습니다. 하위 테스트 끝에 암시 적 &lt;code&gt;done_testing()&lt;/code&gt; 이 추가 됩니다. 다음 두 가지 하위 테스트는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="bfabb840ac564314e7376483141ead0d401f2f7b" translate="yes" xml:space="preserve">
          <source>Due to issues with various CPUs, math libraries, compilers, and standards, results for &lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2()&lt;/a&gt;&lt;/code&gt; may vary depending on any combination of the above. Perl attempts to conform to the Open Group/IEEE standards for the results returned from &lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2()&lt;/a&gt;&lt;/code&gt;, but cannot force the issue if the system Perl is run on does not allow it. (Tru64, HP-UX 10.20)</source>
          <target state="translated">다양한 CPU, 수학 라이브러리, 컴파일러 및 표준의 문제로 인해 &lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2()&lt;/a&gt;&lt;/code&gt; 결과 는 위의 조합에 따라 달라질 수 있습니다. Perl은 &lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2()&lt;/a&gt;&lt;/code&gt; 에서 리턴 된 결과에 대해 Open Group / IEEE 표준을 준수하려고 시도 하지만 시스템 Perl이 실행되는 경우이를 허용하지 않으면 문제를 강제 할 수 없습니다. (Tru64, HP-UX 10.20)</target>
        </trans-unit>
        <trans-unit id="68391d1e9af605eed85ca89bb210a2cba148458c" translate="yes" xml:space="preserve">
          <source>Due to limitations of Perl subroutine call semantics, you cannot pass an array or hash. Prepend it with a &lt;code&gt;\&lt;/code&gt; to pass its reference instead. This will be remedied in time, now that Perl has subroutine prototypes. For now, you need to use the extended usage form, and prepend the name with a &lt;code&gt;*&lt;/code&gt; to output it as a hash or array.</source>
          <target state="translated">Perl 서브 루틴 호출 의미의 한계로 인해 배열 또는 해시를 전달할 수 없습니다. 대신 참조를 전달하려면 &lt;code&gt;\&lt;/code&gt; 를 추가하십시오 . 이제 Perl에 서브 루틴 프로토 타입이 생겼으므로 시간이 지나면 해결됩니다. 지금은 확장 사용 양식을 사용하고 이름 앞에 &lt;code&gt;*&lt;/code&gt; 를 붙여 해시 또는 배열로 출력해야합니다.</target>
        </trans-unit>
        <trans-unit id="b463757edb0c11231cc7018f0eaae187fe6e4840" translate="yes" xml:space="preserve">
          <source>Due to popular demand, 'MIME-Header-ISO_2022_JP' was introduced by Makamaka. Thre are still too many MUAs especially cellular phone handsets which does not grok UTF-8.</source>
          <target state="translated">대중적인 수요로 인해 'MIME-Header-ISO_2022_JP'가 Makamaka에 의해 소개되었습니다. UTF-8을 사용하지 않는 MUA, 특히 휴대 전화 핸드셋이 여전히 너무 많습니다.</target>
        </trans-unit>
        <trans-unit id="3bd045cac184874cb4ad7bcc8e71c09d97d5cddc" translate="yes" xml:space="preserve">
          <source>Due to size concerns, &lt;code&gt;EUC-TW&lt;/code&gt; (Extended Unix Character), &lt;code&gt;CCCII&lt;/code&gt; (Chinese Character Code for Information Interchange), &lt;code&gt;BIG5PLUS&lt;/code&gt; (CMEX's Big5+) and &lt;code&gt;BIG5EXT&lt;/code&gt; (CMEX's Big5e) are distributed separately on CPAN, under the name &lt;a href=&quot;http://search.cpan.org/perldoc/Encode::HanExtra&quot;&gt;Encode::HanExtra&lt;/a&gt;. That module also contains extra China-based encodings.</source>
          <target state="translated">크기 문제로 인해 &lt;code&gt;EUC-TW&lt;/code&gt; (Extended Unix Character), &lt;code&gt;CCCII&lt;/code&gt; (Chinese Character Code for Information Interchange), &lt;code&gt;BIG5PLUS&lt;/code&gt; (CMEX 's Big5 +) 및 &lt;code&gt;BIG5EXT&lt;/code&gt; (CMEX 's Big5e)는 이름이 &lt;a href=&quot;http://search.cpan.org/perldoc/Encode::HanExtra&quot;&gt;Encode :: HanExtra 인&lt;/a&gt; CPAN에 별도로 배포됩니다 . 이 모듈에는 추가 중국 기반 인코딩도 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e606dfe28df13df23c0793d29104abe515f70ff" translate="yes" xml:space="preserve">
          <source>Due to size concerns, &lt;code&gt;GB 18030&lt;/code&gt; (an extension to &lt;code&gt;GBK&lt;/code&gt; ) is distributed separately on CPAN, under the name &lt;a href=&quot;http://search.cpan.org/perldoc/Encode::HanExtra&quot;&gt;Encode::HanExtra&lt;/a&gt;. That module also contains extra Taiwan-based encodings.</source>
          <target state="translated">크기 문제로 인해 &lt;code&gt;GB 18030&lt;/code&gt; ( &lt;code&gt;GBK&lt;/code&gt; 확장 )은 CPAN에서 &lt;a href=&quot;http://search.cpan.org/perldoc/Encode::HanExtra&quot;&gt;Encode :: HanExtra&lt;/a&gt; 라는 이름으로 별도로 배포됩니다 . 이 모듈에는 추가 대만 기반 인코딩도 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d825b88c92a7854e8e07b5fbd910a2348c547422" translate="yes" xml:space="preserve">
          <source>Due to the current implementation of &lt;code&gt;autodie&lt;/code&gt; , unexpected results may be seen when used near or with the string version of eval.</source>
          <target state="translated">현재 &lt;code&gt;autodie&lt;/code&gt; 구현으로 인해 eval의 문자열 버전 근처 또는 그와 함께 사용하면 예기치 않은 결과가 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3912f30ffb4a7edcdecb55dbe256ab47781b419" translate="yes" xml:space="preserve">
          <source>Due to the fact that AIX 4.3.3 reached end-of-service in December 31, 2003 this information is provided as is. The Perl versions prior to Perl 5.8.9 could be compiled on AIX up to 4.3.3 with the following settings (your mileage may vary):</source>
          <target state="translated">2003 년 12 월 31 일에 AIX 4.3.3이 서비스 종료에 도달 했으므로이 정보는있는 그대로 제공됩니다. Perl 5.8.9 이전의 Perl 버전은 다음 설정으로 최대 4.3.3까지 AIX에서 컴파일 할 수 있습니다 (마일리지는 다를 수 있음).</target>
        </trans-unit>
        <trans-unit id="0cc8eb8ed52c08d74c71e528310f912e564ee1bb" translate="yes" xml:space="preserve">
          <source>Due to the interaction between runtime and compiletime issues, and because it's probably not a very good idea anyway, you may not use &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; diagnostics&lt;/code&gt; to turn them off at compiletime. However, you may control their behaviour at runtime using the disable() and enable() methods to turn them off and on respectively.</source>
          <target state="translated">런타임과 컴파일 타임 문제 사이의 상호 작용으로 인해 어쨌든 그다지 좋은 아이디어는 아니기 때문에 컴파일 타임에 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; diagnostics&lt;/code&gt; 을 사용 &lt;a href=&quot;functions/no&quot;&gt;하지&lt;/a&gt; 않도록 설정할 수 있습니다 . 그러나 disable () 및 enable () 메서드를 사용하여 런타임에 동작을 각각 제어하여 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5dba6a65e991b31774fba10843a79cd147209260" translate="yes" xml:space="preserve">
          <source>Due to the limitations of the implementation, you must use base</source>
          <target state="translated">구현의 한계로 인해 base를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="eb744fcb352ecd1572a7e400ccb774b86e7f5bb7" translate="yes" xml:space="preserve">
          <source>Due to the restriction of the quotes, this is a fairly complex problem. Thankfully, we have Jeffrey Friedl, author of</source>
          <target state="translated">따옴표의 제한으로 인해 이것은 상당히 복잡한 문제입니다. 고맙게도 저자 인 Jeffrey Friedl이</target>
        </trans-unit>
        <trans-unit id="e3d6d3e302ca0b687c4f0b65161fa70175b1c871" translate="yes" xml:space="preserve">
          <source>Due to the rules and rigors of ANSI C, on some systems you have to do a seek whenever you switch between reading and writing. Amongst other things, this may have the effect of calling stdio's clearerr(3). A WHENCE of &lt;code&gt;1&lt;/code&gt; (&lt;code&gt;SEEK_CUR&lt;/code&gt; ) is useful for not moving the file position:</source>
          <target state="translated">ANSI C의 규칙과 엄격함으로 인해 일부 시스템에서는 읽기와 쓰기를 전환 할 때마다 탐색을 수행해야합니다. 무엇보다도 stdio의 clearerr (3)를 호출하는 효과가있을 수 있습니다. 의 WHENCE &lt;code&gt;1&lt;/code&gt; ( &lt;code&gt;SEEK_CUR&lt;/code&gt; 는 ) 파일의 위치를 이동하지 않는 유용</target>
        </trans-unit>
        <trans-unit id="791e734fb8c106991b00acd93d1da356b7e03d9b" translate="yes" xml:space="preserve">
          <source>Due to the very cryptic nature of these options, another style was developed that used long names. So instead of a cryptic &lt;code&gt;-l&lt;/code&gt; one could use the more descriptive &lt;code&gt;--long&lt;/code&gt; . To distinguish between a bundle of single-character options and a long one, two dashes are used to precede the option name. Early implementations of long options used a plus &lt;code&gt;+&lt;/code&gt; instead. Also, option values could be specified either like</source>
          <target state="translated">이러한 옵션의 매우 비밀스러운 특성으로 인해 긴 이름을 사용하는 다른 스타일이 개발되었습니다. 따라서 cryptic &lt;code&gt;-l&lt;/code&gt; 대신 더 설명적인 &lt;code&gt;--long&lt;/code&gt; 을 사용할 수 있습니다 . 단일 문자 옵션 번들과 긴 옵션을 구별하기 위해 옵션 이름 앞에 두 개의 대시가 사용됩니다. 긴 옵션의 초기 구현에는 플러스 &lt;code&gt;+&lt;/code&gt; 가 사용되었습니다. 또한 옵션 값은 다음과 같이 지정할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="c0e24e606681dc5af1b9b3cb9795462cb06198f7" translate="yes" xml:space="preserve">
          <source>Due to the way that Perl parses things, your parentheses and brackets may need to be balanced, even including comments. If you run into any examples, please send them to &lt;code&gt;perlbug@perl.org&lt;/code&gt; , so that we can have a concrete example for this man page.</source>
          <target state="translated">Perl이 구문 분석하는 방식으로 인해 주석을 포함하여 괄호와 대괄호의 균형이 필요할 수 있습니다. 예제가 나오면 &lt;code&gt;perlbug@perl.org&lt;/code&gt; 로 보내주십시오 .이 매뉴얼 페이지에 대한 구체적인 예제를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc3fa3b419b8695e1ca79a869f79ee2bcd448351" translate="yes" xml:space="preserve">
          <source>Due to their nature, not all Unicode character properties are suitable for regular expression matches, nor &lt;code&gt;prop_invlist()&lt;/code&gt; . The remaining non-provisional, non-internal ones are accessible via &lt;a href=&quot;unicode/ucd#prop_invmap()&quot;&gt;prop_invmap() in Unicode::UCD&lt;/a&gt; (except for those that this Perl installation hasn't included; see &lt;a href=&quot;#Unicode-character-properties-that-are-NOT-accepted-by-Perl&quot;&gt;below for which those are&lt;/a&gt;).</source>
          <target state="translated">특성상 모든 유니 코드 문자 속성이 정규 표현식 일치 나 &lt;code&gt;prop_invlist()&lt;/code&gt; 적합한 것은 아닙니다 . 나머지 비 내부 비 내부 항목은 &lt;a href=&quot;unicode/ucd#prop_invmap()&quot;&gt;Unicode :: UCD의 prop_invmap ()을&lt;/a&gt; 통해 액세스 할 수 있습니다 ( 이 Perl 설치에 포함되지 않은 것을 제외하고 &lt;a href=&quot;#Unicode-character-properties-that-are-NOT-accepted-by-Perl&quot;&gt;아래&lt;/a&gt; 내용 참조 ).</target>
        </trans-unit>
        <trans-unit id="1caad945fadff253ca62db9c999f67f3c76a14fd" translate="yes" xml:space="preserve">
          <source>Dummy module providing JSON::PP::Boolean</source>
          <target state="translated">JSON :: PP :: Boolean을 제공하는 더미 모듈</target>
        </trans-unit>
        <trans-unit id="fc825db9b75c6b805dc48232f9aa43bb74e273e4" translate="yes" xml:space="preserve">
          <source>Dummy routine which &quot;locks&quot; an SV when there is no locking module present. Exists to avoid test for a NULL function pointer and because it could potentially warn under some level of strict-ness.</source>
          <target state="translated">잠금 모듈이 없을 때 SV를 &quot;잠그는&quot;더미 루틴. NULL 함수 포인터에 대한 테스트를 피하고 일부 엄격도에서 잠재적으로 경고 할 수 있기 때문에 존재합니다.</target>
        </trans-unit>
        <trans-unit id="bf0c1d486931f3f325ed075b19809ade73db7a85" translate="yes" xml:space="preserve">
          <source>Dummy routine which &quot;shares&quot; an SV when there is no sharing module present. Or &quot;locks&quot; it. Or &quot;unlocks&quot; it. In other words, ignores its single SV argument. Exists to avoid test for a NULL function pointer and because it could potentially warn under some level of strict-ness.</source>
          <target state="translated">공유 모듈이 없을 때 SV를 &quot;공유&quot;하는 더미 루틴. 또는 &quot;잠그십시오&quot;. 또는 &quot;잠금 해제&quot;합니다. 즉, 단일 SV 인수를 무시합니다. NULL 함수 포인터에 대한 테스트를 피하고 일부 엄격도에서 잠재적으로 경고 할 수 있기 때문에 존재합니다.</target>
        </trans-unit>
        <trans-unit id="176b35c46c4ecb91ea04e78d1a42469728759765" translate="yes" xml:space="preserve">
          <source>Dummy routine which &quot;unlocks&quot; an SV when there is no locking module present. Exists to avoid test for a NULL function pointer and because it could potentially warn under some level of strict-ness.</source>
          <target state="translated">잠금 모듈이 없을 때 SV를 &quot;잠금 해제&quot;하는 더미 루틴. NULL 함수 포인터에 대한 테스트를 피하고 일부 엄격도에서 잠재적으로 경고 할 수 있기 때문에 존재합니다.</target>
        </trans-unit>
        <trans-unit id="37582a718d2cb7f89d1fea284988f5efcf14f0a7" translate="yes" xml:space="preserve">
          <source>Dummy routine which reports that object can be destroyed when there is no sharing module present. It ignores its single SV argument, and returns 'true'. Exists to avoid test for a NULL function pointer and because it could potentially warn under some level of strict-ness.</source>
          <target state="translated">공유 모듈이 없을 때 객체가 파괴 될 수 있다고보고하는 더미 루틴. 단일 SV 인수를 무시하고 'true'를 반환합니다. NULL 함수 포인터에 대한 테스트를 피하고 일부 엄격도에서 잠재적으로 경고 할 수 있기 때문에 존재합니다.</target>
        </trans-unit>
        <trans-unit id="1a71039f50cfa3d68327859e6e1ee38df19b6603" translate="yes" xml:space="preserve">
          <source>Dump Pod-parsing events as text</source>
          <target state="translated">포드 파싱 이벤트를 텍스트로 덤프</target>
        </trans-unit>
        <trans-unit id="f2e8d87285df2d5dabb9e7d33d3a5ccc1734224b" translate="yes" xml:space="preserve">
          <source>Dump arrays holding contents of debugged files.</source>
          <target state="translated">디버깅 된 파일의 내용을 보유한 덤프 배열.</target>
        </trans-unit>
        <trans-unit id="c3ebe589cb305dd68a2940605b6daaa7020bacf2" translate="yes" xml:space="preserve">
          <source>Dump arrays holding debugged files.</source>
          <target state="translated">디버깅 된 파일을 보유한 덤프 배열.</target>
        </trans-unit>
        <trans-unit id="226b4cf975bc516395af9737531a129bdd39ab93" translate="yes" xml:space="preserve">
          <source>Dump contents of &quot;reused&quot; addresses.</source>
          <target state="translated">&quot;재사용 된&quot;주소의 내용을 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="259f2ccf29b6875ba051810947cb2d0facc44c4f" translate="yes" xml:space="preserve">
          <source>Dump offset information. This can be used to see how regops correlate to the pattern. Output format is</source>
          <target state="translated">덤프 오프셋 정보. 이것은 regops가 패턴과 어떻게 관련되는지를 보는 데 사용할 수 있습니다. 출력 형식은</target>
        </trans-unit>
        <trans-unit id="0c76297cc9be5e641298778b62c24d2cf18dcd23" translate="yes" xml:space="preserve">
          <source>Dump symbol tables of packages.</source>
          <target state="translated">패키지의 심볼 테이블을 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="4b8420d45b35aac310c6f6a8a752e4db117364a2" translate="yes" xml:space="preserve">
          <source>Dump the contents of a padlist</source>
          <target state="translated">padlist의 내용을 덤프</target>
        </trans-unit>
        <trans-unit id="aa55ac5b7f095f269a678e79910c4c37b3152a49" translate="yes" xml:space="preserve">
          <source>Dump the contents of all SVs not yet freed (debugging aid).</source>
          <target state="translated">아직 해제되지 않은 모든 SV의 컨텐츠를 덤프하십시오 (디버깅 보조).</target>
        </trans-unit>
        <trans-unit id="d6a50535ad9de82c4339f219e99b9b784c2acae9" translate="yes" xml:space="preserve">
          <source>Dump the final program out after it is compiled and optimised.</source>
          <target state="translated">컴파일 및 최적화 된 최종 프로그램을 덤프하십시오.</target>
        </trans-unit>
        <trans-unit id="918c0daf95540cecfd55fc2c00499f5882b52cfa" translate="yes" xml:space="preserve">
          <source>Dump the flags associated with the program</source>
          <target state="translated">프로그램과 관련된 플래그를 덤프</target>
        </trans-unit>
        <trans-unit id="5e107609c2d58489d78c64df77c07976e804b91e" translate="yes" xml:space="preserve">
          <source>Dumping Perl Data Structures</source>
          <target state="translated">Perl 데이터 구조 덤프</target>
        </trans-unit>
        <trans-unit id="44d1680eb49a12854ee630cd3f07447c8ef725fa" translate="yes" xml:space="preserve">
          <source>Dumping a large array or hash</source>
          <target state="translated">큰 배열 또는 해시 덤프</target>
        </trans-unit>
        <trans-unit id="416f4f5ac3093ab1714cc7418abe095efaa50a64" translate="yes" xml:space="preserve">
          <source>Dumps the C backtrace to the given fp.</source>
          <target state="translated">C 역 추적을 주어진 fp로 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="1a8a79003d6e119f87dd05fb34533dde374be690" translate="yes" xml:space="preserve">
          <source>Dumps the contents of an SV to the &lt;code&gt;STDERR&lt;/code&gt; filehandle.</source>
          <target state="translated">SV의 내용을 &lt;code&gt;STDERR&lt;/code&gt; 파일 핸들로 덤프합니다 .</target>
        </trans-unit>
        <trans-unit id="ec8f218a06cd2ecbe02c8bf7842f6c0f5d02c9c5" translate="yes" xml:space="preserve">
          <source>Dumps the entire optree of the current program starting at &lt;code&gt;PL_main_root&lt;/code&gt; to &lt;code&gt;STDERR&lt;/code&gt; . Also dumps the optrees for all visible subroutines in &lt;code&gt;PL_defstash&lt;/code&gt; .</source>
          <target state="translated">PL_main_root에서 시작하여 현재 프로그램의 전체 &lt;code&gt;PL_main_root&lt;/code&gt; 를 &lt;code&gt;STDERR&lt;/code&gt; 로 덤프합니다 . 또한 모든 보이는 서브 루틴에 대한 optrees 덤프 &lt;code&gt;PL_defstash&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="46f7f7e922a3e5c53d29eb7033810ca1c5ff1e45" translate="yes" xml:space="preserve">
          <source>Dumps the optree starting at OP &lt;code&gt;o&lt;/code&gt; to &lt;code&gt;STDERR&lt;/code&gt; .</source>
          <target state="translated">OP &lt;code&gt;o&lt;/code&gt; 에서 시작하는 optree 를 &lt;code&gt;STDERR&lt;/code&gt; 로 덤프합니다 .</target>
        </trans-unit>
        <trans-unit id="e83684d55af04a9978210506a5f3da39f6330394" translate="yes" xml:space="preserve">
          <source>Dumps the optrees for all visible subroutines in &lt;code&gt;stash&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;stash&lt;/code&gt; 의 모든 보이는 서브 루틴에 대한 optree를 덤프합니다 .</target>
        </trans-unit>
        <trans-unit id="55b069d1baf075aa441953fab4c10d5fb0c55b03" translate="yes" xml:space="preserve">
          <source>Dumps to STDOUT a two column list of op names and op descriptions. If an optional pattern is given then only lines which match the (case insensitive) pattern will be output.</source>
          <target state="translated">op 이름과 op 설명의 두 열 목록을 STDOUT에 덤프합니다. 선택적 패턴이 제공되면 (대소 문자 구분) 패턴과 일치하는 행만 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="0bb1bbfb4b82018f68b759747efb8b836bc13b23" translate="yes" xml:space="preserve">
          <source>Dumpvalue</source>
          <target state="translated">Dumpvalue</target>
        </trans-unit>
        <trans-unit id="29282979e5caf58379ebe9349836f426355bbd81" translate="yes" xml:space="preserve">
          <source>Dumpvalue - provides screen dump of Perl data.</source>
          <target state="translated">Dumpvalue-Perl 데이터의 화면 덤프를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5194887c5341c823d0b499a2bddca4cdca4574a6" translate="yes" xml:space="preserve">
          <source>Duplicate keys are entirely defined by the comparison function. In the case-insensitive example above, the keys: 'KEY' and 'key' would be considered duplicates, and assigning to the second one would overwrite the first. If duplicates are allowed for (with the R_DUP flag discussed below), only a single copy of duplicate keys is stored in the database --- so (again with example above) assigning three values to the keys: 'KEY', 'Key', and 'key' would leave just the first key: 'KEY' in the database with three values. For some situations this results in information loss, so care should be taken to provide fully qualified comparison functions when necessary. For example, the above comparison routine could be modified to additionally compare case-sensitively if two keys are equal in the case insensitive comparison:</source>
          <target state="translated">중복 키는 전적으로 비교 기능으로 정의됩니다. 위의 대소 문자를 구분하지 않는 예에서 'KEY'와 'key'키는 중복으로 간주되며 두 번째 키에 할당하면 첫 번째 키를 덮어 씁니다. 중복이 허용되면 (아래에 설명 된 R_DUP 플래그 사용) 단일 중복 키 사본 만 데이터베이스에 저장되므로 위의 예와 같이 키에 세 개의 값을 지정하십시오 : 'KEY', 'Key' , 'key'는 데이터베이스에 세 개의 값이있는 'KEY'라는 첫 번째 키만 남습니다. 경우에 따라 정보가 손실되므로 필요한 경우 정규화 된 비교 기능을 제공하도록주의를 기울여야합니다. 예를 들어대소 문자를 구분하지 않는 비교에서 두 키가 동일한 경우 위의 비교 루틴을 수정하여 대소 문자를 구분하여 추가로 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="231270fe32be376e1ff61953994a1d9555ba5c57" translate="yes" xml:space="preserve">
          <source>Duplicates a pad name list.</source>
          <target state="translated">패드 이름 목록을 복제합니다.</target>
        </trans-unit>
        <trans-unit id="9900c4228b05d518bce49d6e43830390656bb380" translate="yes" xml:space="preserve">
          <source>Duplicates a pad name.</source>
          <target state="translated">패드 이름을 복제합니다.</target>
        </trans-unit>
        <trans-unit id="9c150a6a5de518050ee469f156c0d8c9991e7d83" translate="yes" xml:space="preserve">
          <source>Duplicates a pad.</source>
          <target state="translated">패드를 복제합니다.</target>
        </trans-unit>
        <trans-unit id="34a249fd97af29be13a351a7a3b7c31857c28f36" translate="yes" xml:space="preserve">
          <source>Duplicates the current value of &lt;code&gt;SV&lt;/code&gt; , on the exit from the current &lt;code&gt;ENTER&lt;/code&gt; /&lt;code&gt;LEAVE&lt;/code&gt;</source>
          <target state="translated">현재 &lt;code&gt;ENTER&lt;/code&gt; / &lt;code&gt;LEAVE&lt;/code&gt; 종료시 &lt;code&gt;SV&lt;/code&gt; 의 현재 값을 복제합니다</target>
        </trans-unit>
        <trans-unit id="327c7809967b34dba21cd1b07757c86e4f680971" translate="yes" xml:space="preserve">
          <source>During &quot;make test&quot; the &lt;code&gt;comp/cpp&lt;/code&gt; will be skipped because on Tru64 it cannot be tested before Perl has been installed. The test refers to the use of the &lt;code&gt;-P&lt;/code&gt; option of Perl.</source>
          <target state="translated">&quot;테스트 테스트&quot;중에는 Tru64에서 Perl을 설치하기 전에 테스트 할 수 없기 때문에 &lt;code&gt;comp/cpp&lt;/code&gt; 를 건너 뜁니다. 테스트는 Perl 의 &lt;code&gt;-P&lt;/code&gt; 옵션 사용을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="82a46924bba9ec42c3fc1e7dbc6523da9c5a0d98" translate="yes" xml:space="preserve">
          <source>During compilation you will see this warning from toke.c:</source>
          <target state="translated">컴파일하는 동안 toke.c에서 다음 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1b78be5f5982368a285609a938bd717c952f6438" translate="yes" xml:space="preserve">
          <source>During compilation, this points to the array containing the names part of the pad for the currently-compiling code.</source>
          <target state="translated">컴파일하는 동안 현재 컴파일중인 코드의 패드 이름 부분이 포함 된 배열을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="8fc3623ed774bb34e7810f090f0b1728d1403063" translate="yes" xml:space="preserve">
          <source>During compilation, this points to the array containing the values part of the pad for the currently-compiling code. (At runtime a CV may have many such value arrays; at compile time just one is constructed.) At runtime, this points to the array containing the currently-relevant values for the pad for the currently-executing code.</source>
          <target state="translated">컴파일하는 동안 현재 컴파일중인 코드의 패드 값 부분이 포함 된 배열을 가리 킵니다. (런타임에서 CV는 많은 값 배열을 가질 수 있습니다; 컴파일 타임에는 단 하나만 구성됩니다.) 런타임에서, 이것은 현재 실행중인 코드의 패드에 대한 현재 관련 값을 포함하는 배열을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="688fb3463c876328fa68fbb00f834fb161bf77e9" translate="yes" xml:space="preserve">
          <source>During extensions build phase, a script</source>
          <target state="translated">확장 빌드 단계에서 스크립트</target>
        </trans-unit>
        <trans-unit id="3a8cb198eac07a20f06df8ba7dc5ed5cb604d226" translate="yes" xml:space="preserve">
          <source>During global destruction, Perl will always garbage collect objects before unblessed references. See &lt;a href=&quot;perlhacktips#PERL_DESTRUCT_LEVEL&quot;&gt;PERL_DESTRUCT_LEVEL in perlhacktips&lt;/a&gt; for more information about global destruction.</source>
          <target state="translated">전역 파괴 중에 Perl은 항상 축복되지 않은 참조 전에 객체를 가비지 수집합니다. 참조 &lt;a href=&quot;perlhacktips#PERL_DESTRUCT_LEVEL&quot;&gt;perlhacktips에 PERL_DESTRUCT_LEVEL을&lt;/a&gt; 지구 멸망에 대한 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="63b2774e342436fdc21964665d44a1dd453eb511" translate="yes" xml:space="preserve">
          <source>During installation &lt;code&gt;$List::Util::XS::VERSION&lt;/code&gt; will be set to &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if the XS was not compiled.</source>
          <target state="translated">설치 중 &lt;code&gt;$List::Util::XS::VERSION&lt;/code&gt; 은 XS가 컴파일되지 않은 경우 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="365d0173e5c9fab16585ed58b7aee60ff977956d" translate="yes" xml:space="preserve">
          <source>During recent history, data is moved around a computer in 8-bit chunks, often called &quot;bytes&quot; but also known as &quot;octets&quot; in standards documents. Perl is widely used to manipulate data of many types: not only strings of characters representing human or computer languages, but also &quot;binary&quot; data, being the machine's representation of numbers, pixels in an image, or just about anything.</source>
          <target state="translated">최근 기록 동안, 데이터는 종종 &quot;바이트&quot;라고도하지만 표준 문서에서는 &quot;옥텟&quot;이라고도하는 8 비트 청크로 컴퓨터에서 이동합니다. Perl은 인간 또는 컴퓨터 언어를 나타내는 문자열뿐만 아니라 숫자, 이미지의 픽셀 또는 거의 모든 것을 나타내는 이진 데이터와 같은 여러 유형의 데이터를 조작하는 데 널리 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c00b220a28d96bc682b1b18fd920cedf0efda896" translate="yes" xml:space="preserve">
          <source>During the 'r' command CPAN.pm finds modules with a version number of zero. When the command finishes, it prints a report about this. If you want this report to be very verbose, say yes to the following variable.</source>
          <target state="translated">'r'명령 동안 CPAN.pm은 버전 번호가 0 인 모듈을 찾습니다. 명령이 완료되면 이에 대한 보고서가 인쇄됩니다. 이 보고서를 매우 장황하게하려면 다음 변수에 대해 yes라고 말하십시오.</target>
        </trans-unit>
        <trans-unit id="1e8d8123a94cf9a48937762f3c4d82a2ae9cfc9c" translate="yes" xml:space="preserve">
          <source>During the 'r' command CPAN.pm finds modules without version number. When the command finishes, it prints a report about this. If you want this report to be very verbose, say yes to the following variable.</source>
          <target state="translated">'r'명령 동안 CPAN.pm은 버전 번호가없는 모듈을 찾습니다. 명령이 완료되면 이에 대한 보고서가 인쇄됩니다. 이 보고서를 매우 장황하게하려면 다음 변수에 대해 yes라고 말하십시오.</target>
        </trans-unit>
        <trans-unit id="00bf1cb155480acd23b923e4a6c03a2b23cd1d39" translate="yes" xml:space="preserve">
          <source>During the build process, three Perl images are produced.</source>
          <target state="translated">빌드 프로세스 중에 3 개의 Perl 이미지가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="4695645d68d6dbb11815010844432810a8cc5ce6" translate="yes" xml:space="preserve">
          <source>During the matching of this sub-pattern, it has its own set of captures which are valid during the sub-match, but are discarded once control returns to the main pattern. For example, the following matches, with the inner pattern capturing &quot;B&quot; and matching &quot;BB&quot;, while the outer pattern captures &quot;A&quot;;</source>
          <target state="translated">이 하위 패턴을 일치시키는 동안 하위 일치 중에 유효한 자체 캡처 세트가 있지만 제어가 기본 패턴으로 돌아 오면 삭제됩니다. 예를 들어, 내부 패턴은 &quot;B&quot;를 캡처하고 &quot;BB&quot;는 일치하는 반면 다음 패턴은 &quot;A&quot;를 캡처합니다.</target>
        </trans-unit>
        <trans-unit id="e6ec7eb737062f01f212178148567a03e6c845e4" translate="yes" xml:space="preserve">
          <source>During the normal course of events, the parent process and every pseudo-process started by it will wait for their respective pseudo-children to complete before they exit. This means that the parent and every pseudo-child created by it that is also a pseudo-parent will only exit after their pseudo-children have exited.</source>
          <target state="translated">정상적인 이벤트 과정에서 상위 프로세스와 프로세스에 의해 시작된 모든 의사 프로세스는 종료되기 전에 해당 의사 자식이 완료 될 때까지 기다립니다. 이는 부모와 의사 부모 인 부모가 생성 한 모든 의사 자식이 의사 자식이 종료 된 후에 만 ​​종료됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="26974b2880875e58f9a65545ea413592199b96d1" translate="yes" xml:space="preserve">
          <source>During the rest of this document, the shortcuts A (for accuracy), P (for precision), F (fallback) and R (rounding mode) will be used.</source>
          <target state="translated">이 문서의 나머지 부분에서는 바로 가기 A (정확도), P (정밀도), F (대체) 및 R (반올림 모드)이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f8d90cb30467e2a4d157edb90535bc578beea09a" translate="yes" xml:space="preserve">
          <source>During this search no attention is paid to the semantics of the construct. Thus:</source>
          <target state="translated">이 검색 동안 구문의 의미에주의를 기울이지 않습니다. 그러므로:</target>
        </trans-unit>
        <trans-unit id="601d1570400ebbc8e652fb389057e665c3716c4a" translate="yes" xml:space="preserve">
          <source>DynaLoader</source>
          <target state="translated">DynaLoader</target>
        </trans-unit>
        <trans-unit id="9d69ce3ced252503b953a83d970f6811f3f613e6" translate="yes" xml:space="preserve">
          <source>DynaLoader - Dynamically load C libraries into Perl code</source>
          <target state="translated">DynaLoader-C 라이브러리를 Perl 코드에 동적으로로드</target>
        </trans-unit>
        <trans-unit id="b801b82847d571219ed7e9cb40b5911d8c6fd1ce" translate="yes" xml:space="preserve">
          <source>DynaLoader Interface Summary</source>
          <target state="translated">DynaLoader 인터페이스 요약</target>
        </trans-unit>
        <trans-unit id="44c249a4a70f6f5d86041728f18f2c1b944c09ee" translate="yes" xml:space="preserve">
          <source>DynaLoader.pm</source>
          <target state="translated">DynaLoader.pm</target>
        </trans-unit>
        <trans-unit id="7bf55f093a98122c15a38c4d1e0e12b14eb5e676" translate="yes" xml:space="preserve">
          <source>DynaLoader_pm.PL</source>
          <target state="translated">DynaLoader_pm.PL</target>
        </trans-unit>
        <trans-unit id="eafe90e80018d592f31306075f13c6355bb554de" translate="yes" xml:space="preserve">
          <source>Dynamic Loading versus Static Loading</source>
          <target state="translated">동적 로딩 대 정적 로딩</target>
        </trans-unit>
        <trans-unit id="e6e2a2c7c1603246902c42979e7716a6a53a2226" translate="yes" xml:space="preserve">
          <source>Dynamic Templates</source>
          <target state="translated">동적 템플릿</target>
        </trans-unit>
        <trans-unit id="376a2d3fdb39cd734db8f5317d570d379d27e726" translate="yes" xml:space="preserve">
          <source>Dynamic scoping works over a &lt;b&gt;dynamic scope&lt;/b&gt;, making variables visible throughout the rest of the &lt;b&gt;block&lt;/b&gt; in which they are first used and in any &lt;b&gt;subroutines&lt;/b&gt; that are called by the rest of the block. Dynamically scoped variables can have their values temporarily changed (and implicitly restored later) by a &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; operator. (Compare &lt;b&gt;lexical scoping&lt;/b&gt;.) Used more loosely to mean how a subroutine that is in the middle of calling another subroutine &amp;ldquo;contains&amp;rdquo; that subroutine at &lt;b&gt;runtime&lt;/b&gt;.</source>
          <target state="translated">동적 이상 작동 범위 지정 &lt;b&gt;동적 범위&lt;/b&gt; 의 나머지 부분 표시 변수 만드는 &lt;b&gt;블록&lt;/b&gt; 들이 먼저 사용되는 임의의 &lt;b&gt;서브 루틴&lt;/b&gt; 블록의 나머지 부분에 의해 호출된다. 동적 범위 변수는 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 연산자에 의해 값이 일시적으로 변경되고 나중에 암시 적으로 복원 될 수 있습니다 . &lt;b&gt;어휘 범위 지정을&lt;/b&gt; 비교하십시오 . 다른 서브 루틴을 호출하는 중에있는 서브 루틴이 &lt;b&gt;런타임시&lt;/b&gt; 해당 서브 루틴을 포함하는 방법을 의미하기 위해 더 느슨하게 사용 &lt;b&gt;됩니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="fb638018434277b4fc82279e676431d053924a22" translate="yes" xml:space="preserve">
          <source>Dynamically load $filename, which must be the path to a shared object or library. An opaque 'library reference' is returned as a handle for the loaded object. Returns undef on error.</source>
          <target state="translated">공유 객체 또는 라이브러리의 경로 여야하는 $ filename을 동적으로로드합니다. 로드 된 객체의 핸들로 불투명 한 '라이브러리 참조'가 반환됩니다. 오류시 undef를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="86d6546533b1f34d2c75903edbf95c52c4a6e87e" translate="yes" xml:space="preserve">
          <source>Dynamically load C libraries into Perl code</source>
          <target state="translated">C 라이브러리를 Perl 코드에 동적으로로드</target>
        </trans-unit>
        <trans-unit id="549c414661c7e2cd66ebf276140209d3a293c3ec" translate="yes" xml:space="preserve">
          <source>Dynamically unload $libref, which must be an opaque 'library reference' as returned from dl_load_file. Returns one on success and zero on failure. This function is optional and may not necessarily be provided on all platforms.</source>
          <target state="translated">dl_load_file에서 반환되는 불투명 한 '라이브러리 참조'여야하는 $ libref를 동적으로 언로드합니다. 성공하면 1, 실패하면 0을 반환합니다. 이 기능은 선택 사항이며 모든 플랫폼에서 제공되지 않을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0184adedf913b076626646d3f52c3b49c39ad6d" translate="yes" xml:space="preserve">
          <source>E</source>
          <target state="translated">E</target>
        </trans-unit>
        <trans-unit id="fa9bdf01ece32bc99b1e14c6937aab7757e65d12" translate="yes" xml:space="preserve">
          <source>E&amp;lt;...&amp;gt; codes are resolved.</source>
          <target state="translated">E &amp;lt;...&amp;gt; 코드가 해결되었습니다.</target>
        </trans-unit>
        <trans-unit id="8ba6f1546de2a6de38d5975288d79871e380398d" translate="yes" xml:space="preserve">
          <source>E&amp;lt;...&amp;gt; may freely appear in any formatting code (other than in another E&amp;lt;...&amp;gt; or in an Z&amp;lt;&amp;gt;). That is, &quot;X&amp;lt;The E&amp;lt;euro&amp;gt;1,000,000 Solution&amp;gt;&quot; is valid, as is &quot;L&amp;lt;The E&amp;lt;euro&amp;gt;1,000,000 Solution|Million::Euros&amp;gt;&quot;.</source>
          <target state="translated">E &amp;lt;...&amp;gt;는 다른 서식 코드 (다른 E &amp;lt;...&amp;gt; 또는 Z &amp;lt;&amp;gt; 제외)에 자유롭게 나타날 수 있습니다. 즉, &quot;L &amp;lt;Euro&amp;gt; 1,000,000 Solution | Million :: Euros&amp;gt;&quot;와 마찬가지로, &quot;X &amp;lt;Euro&amp;gt; 1,000,000 Solution&amp;gt;&quot;이 유효하다.</target>
        </trans-unit>
        <trans-unit id="fa4a7a170f7075560c98a976572cae386b13a240" translate="yes" xml:space="preserve">
          <source>E.g.</source>
          <target state="translated">E.g.</target>
        </trans-unit>
        <trans-unit id="10c56e2f6bd010417c5d9ae6293f4b104ad1b293" translate="yes" xml:space="preserve">
          <source>E.g. when 'a' and 'e' are ignorable, 'element' is equal to 'lament' (or 'lmnt').</source>
          <target state="translated">예를 들어 'a'와 'e'를 무시할 수있는 경우 'element'는 'lament'(또는 'lmnt')와 같습니다.</target>
        </trans-unit>
        <trans-unit id="54752205cb5bf21cf1543c1d8786b50bfa512554" translate="yes" xml:space="preserve">
          <source>E.g. when searching in</source>
          <target state="translated">예를 들어 검색 할 때</target>
        </trans-unit>
        <trans-unit id="c9faf7260b3872bd0cc8c1b2903b97df4d17534d" translate="yes" xml:space="preserve">
          <source>E.g., &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; 'foo', 'bar', 'baz'&lt;/code&gt; may lead Perl to finding</source>
          <target state="translated">예를 들어, &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; 'foo', 'bar', 'baz'&lt;/code&gt; 는 Perl이</target>
        </trans-unit>
        <trans-unit id="14202089b63db480cc56897191e80ea08ccae522" translate="yes" xml:space="preserve">
          <source>E.g., when searching in</source>
          <target state="translated">예를 들어 검색 할 때</target>
        </trans-unit>
        <trans-unit id="cf18d56706e6a161ea7a892c730e7fc94aa42849" translate="yes" xml:space="preserve">
          <source>EBCDIC</source>
          <target state="translated">EBCDIC</target>
        </trans-unit>
        <trans-unit id="db39ab5da5fc359d74ab7f80a9662d49c8256b60" translate="yes" xml:space="preserve">
          <source>EBCDIC Encodings</source>
          <target state="translated">EBCDIC 인코딩</target>
        </trans-unit>
        <trans-unit id="acf1dc4914532273e100530a9ab5c863dba82d84" translate="yes" xml:space="preserve">
          <source>EBCDIC Examples:</source>
          <target state="translated">EBCDIC 예 :</target>
        </trans-unit>
        <trans-unit id="332c2be33ecb50e660de8a6bec931a2002f3ce8c" translate="yes" xml:space="preserve">
          <source>EBCDIC Platforms</source>
          <target state="translated">EBCDIC 플랫폼</target>
        </trans-unit>
        <trans-unit id="d5e0cb1a52c6c43ea7491f03d8cf20e2863b3020" translate="yes" xml:space="preserve">
          <source>EBCDIC checksums will differ for the same file translated into ASCII and vice versa.</source>
          <target state="translated">EBCDIC 체크섬은 ASCII로 변환 된 동일한 파일과 그 반대로 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4a1a6bb8b2ba023d8e2ace21595c7370a5af29a" translate="yes" xml:space="preserve">
          <source>EBCDIC code sets recognized by Perl</source>
          <target state="translated">Perl에 의해 인식되는 EBCDIC 코드 세트</target>
        </trans-unit>
        <trans-unit id="8917832f80dc1f23f4ce37b35b7094bce451b8d6" translate="yes" xml:space="preserve">
          <source>EBCDIC sort results may differ from ASCII sort results especially for mixed case strings. This is discussed in more detail &lt;a href=&quot;#SORTING&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">EBCDIC 정렬 결과는 특히 대소 문자 혼합 문자열의 ASCII 정렬 결과와 다를 수 있습니다. 이에 대해서는 &lt;a href=&quot;#SORTING&quot;&gt;아래&lt;/a&gt; 에서 더 자세히 설명 합니다 .</target>
        </trans-unit>
        <trans-unit id="0161b12e1086c489bcc4c4218bf647b2c2e7af38" translate="yes" xml:space="preserve">
          <source>ECMA-048 is available on-line (at least at the time of this writing) at &lt;a href=&quot;http://www.ecma-international.org/publications/standards/Ecma-048.htm&quot;&gt;http://www.ecma-international.org/publications/standards/Ecma-048.htm&lt;/a&gt;.</source>
          <target state="translated">ECMA-048은 http://www.ecma-international.org/publications/standards/Ecma-048.htm에서 온라인으로 (적어도이 글을 쓰는 시점에) 이용할 &lt;a href=&quot;http://www.ecma-international.org/publications/standards/Ecma-048.htm&quot;&gt;수&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="0216d6b25a22e0b782349678c3b9d439ab040aa1" translate="yes" xml:space="preserve">
          <source>EFFECTIVE</source>
          <target state="translated">EFFECTIVE</target>
        </trans-unit>
        <trans-unit id="cbc724c9910501b7f3260e0af4b0be278ac0c6a0" translate="yes" xml:space="preserve">
          <source>ELEMENTS OF THE INTERPRETER</source>
          <target state="translated">통역사 요소</target>
        </trans-unit>
        <trans-unit id="775eda021e49d1db0c56510d89f1a3a5b0d3533c" translate="yes" xml:space="preserve">
          <source>ELEMENT_LIST</source>
          <target state="translated">ELEMENT_LIST</target>
        </trans-unit>
        <trans-unit id="274c18c04f053750184eb461592a3aeba38deb84" translate="yes" xml:space="preserve">
          <source>EMX runtime is required (may be substituted by RSX). Note that it is possible to make</source>
          <target state="translated">EMX 런타임이 필요합니다 (RSX로 대체 될 수 있음). 만들 수 있습니다</target>
        </trans-unit>
        <trans-unit id="ee406c89e6d96da9d9c9078da02dd1085c757041" translate="yes" xml:space="preserve">
          <source>ENCNAME</source>
          <target state="translated">ENCNAME</target>
        </trans-unit>
        <trans-unit id="09d70e3cb3e8ca25c8e1c040798016341acb9d34" translate="yes" xml:space="preserve">
          <source>ENCODED WORD</source>
          <target state="translated">인코딩 된 단어</target>
        </trans-unit>
        <trans-unit id="1e306f9d0fec9dc9a627cd5c3b6dd9bb1770a21e" translate="yes" xml:space="preserve">
          <source>ENCODING</source>
          <target state="translated">ENCODING</target>
        </trans-unit>
        <trans-unit id="d205abee3d2a71688a6b66568be289a94050031c" translate="yes" xml:space="preserve">
          <source>END</source>
          <target state="translated">END</target>
        </trans-unit>
        <trans-unit id="6d3c353157df1302b4606a2c3c31edf9ce433536" translate="yes" xml:space="preserve">
          <source>ENTRIES IN EACH LEXICON</source>
          <target state="translated">각 LEXICON의 엔트리</target>
        </trans-unit>
        <trans-unit id="15d54da16fed3cc2ae89bbdaf9ad9e1b0ec1df2c" translate="yes" xml:space="preserve">
          <source>ENVIRONMENT</source>
          <target state="translated">ENVIRONMENT</target>
        </trans-unit>
        <trans-unit id="cb8f8d1fdc31a300a149531a3ee67854b7226f82" translate="yes" xml:space="preserve">
          <source>ENVIRONMENT VARIABLES THAT AFFECT TEST::HARNESS</source>
          <target state="translated">테스트에 영향을 미치는 환경 변수 :: HARNESS</target>
        </trans-unit>
        <trans-unit id="ca7f3972a83e913d649e11c108df24283c3bc376" translate="yes" xml:space="preserve">
          <source>ENVIRONMENT VARIABLES THAT TAP::HARNESS::COMPATIBLE SETS</source>
          <target state="translated">TAP :: HARNESS :: 호환 가능한 환경 변수</target>
        </trans-unit>
        <trans-unit id="f7084ac12cca76d68cdd87fe9d782e1ae84dd265" translate="yes" xml:space="preserve">
          <source>EOF.</source>
          <target state="translated">EOF.</target>
        </trans-unit>
        <trans-unit id="bc8e77d510181b5522d113b8d79cd4cb3e49542e" translate="yes" xml:space="preserve">
          <source>EOL Platforms</source>
          <target state="translated">EOL 플랫폼</target>
        </trans-unit>
        <trans-unit id="7d063d313be8f22d60adcb2e5150c0209bf36674" translate="yes" xml:space="preserve">
          <source>ERRNO</source>
          <target state="translated">ERRNO</target>
        </trans-unit>
        <trans-unit id="ebe21523a5dccd37a9fcf7ea0fd32b1eca292ad0" translate="yes" xml:space="preserve">
          <source>ERROR HANDLING</source>
          <target state="translated">오류 처리</target>
        </trans-unit>
        <trans-unit id="161833a14be7adad1a6eb962fc3f24b1791debe8" translate="yes" xml:space="preserve">
          <source>ERROR REPORTING</source>
          <target state="translated">오류 신고</target>
        </trans-unit>
        <trans-unit id="fb558b481c7703cb01a866167aa87ba7ffeeb0ce" translate="yes" xml:space="preserve">
          <source>ERRORS</source>
          <target state="translated">ERRORS</target>
        </trans-unit>
        <trans-unit id="2ef444354ee97e4dd743f7f63b3e4d0c239b4132" translate="yes" xml:space="preserve">
          <source>ERRORS DUE TO DIVISION BY ZERO</source>
          <target state="translated">ZERO로 나눈 오류</target>
        </trans-unit>
        <trans-unit id="6a22654ad1bd17a1b7f8a33ebc606c6dd0499218" translate="yes" xml:space="preserve">
          <source>ERRORS DUE TO DIVISION BY ZERO OR LOGARITHM OF ZERO</source>
          <target state="translated">제로 또는 로그의 제곱으로 인한 오류</target>
        </trans-unit>
        <trans-unit id="c79b986f6448f6bcfe4c395367179ab049f8d63e" translate="yes" xml:space="preserve">
          <source>ERRORS DUE TO INDIGESTIBLE ARGUMENTS</source>
          <target state="translated">식별 할 수없는 인수로 인한 오류</target>
        </trans-unit>
        <trans-unit id="6f1d7e623d1be2e3224550fb5ed680f08aba75ed" translate="yes" xml:space="preserve">
          <source>ESCAPE SEQUENCES</source>
          <target state="translated">이스케이프 시퀀스</target>
        </trans-unit>
        <trans-unit id="c68e9c8ffafea2d41e94c29ec6ef311a4fc01058" translate="yes" xml:space="preserve">
          <source>ESTI GSM 03.38 Encoding</source>
          <target state="translated">ESTI GSM 03.38 인코딩</target>
        </trans-unit>
        <trans-unit id="330d938044782725e081a62faa873e5784320980" translate="yes" xml:space="preserve">
          <source>ESTI GSM 03.38 Encoding itself.</source>
          <target state="translated">ESTI GSM 03.38 자체 인코딩.</target>
        </trans-unit>
        <trans-unit id="e9199febdaab27118bac1b42feacb4f953051759" translate="yes" xml:space="preserve">
          <source>EXAMPLE</source>
          <target state="translated">EXAMPLE</target>
        </trans-unit>
        <trans-unit id="79e0bba4d7ab03dd3a43d89e18dc509cf2803c4f" translate="yes" xml:space="preserve">
          <source>EXAMPLE - Greekperl</source>
          <target state="translated">예-그리스어</target>
        </trans-unit>
        <trans-unit id="c1459caada695329b2e0c6704825c3b8e7a13c88" translate="yes" xml:space="preserve">
          <source>EXAMPLE 1</source>
          <target state="translated">실시 예 1</target>
        </trans-unit>
        <trans-unit id="1358d71098fb89610fe1aac79c61d72cd99d3282" translate="yes" xml:space="preserve">
          <source>EXAMPLE 2</source>
          <target state="translated">실시 예 2</target>
        </trans-unit>
        <trans-unit id="bf337e44a3f58c52533729fe2435927aca3951e1" translate="yes" xml:space="preserve">
          <source>EXAMPLE 3</source>
          <target state="translated">실시 예 3</target>
        </trans-unit>
        <trans-unit id="6c373f3759a7e7f5ea3aa6485c89916c7bfcefb6" translate="yes" xml:space="preserve">
          <source>EXAMPLE 4</source>
          <target state="translated">실시 예 4</target>
        </trans-unit>
        <trans-unit id="c0fcde52500282f83cc647053ccb330dab650466" translate="yes" xml:space="preserve">
          <source>EXAMPLE 5</source>
          <target state="translated">실시 예 5</target>
        </trans-unit>
        <trans-unit id="45b9b19b0fbae586929496cd8750455d351de3e8" translate="yes" xml:space="preserve">
          <source>EXAMPLE 6</source>
          <target state="translated">실시 예 6</target>
        </trans-unit>
        <trans-unit id="c45a24f213f8694012485c12afa309d47467f3fd" translate="yes" xml:space="preserve">
          <source>EXAMPLE 7 (Coming Soon)</source>
          <target state="translated">실시 예 7 (출시 예정)</target>
        </trans-unit>
        <trans-unit id="efa7b38bfff5f32b2321e835dcdafd3692ef4121" translate="yes" xml:space="preserve">
          <source>EXAMPLE 8 (Coming Soon)</source>
          <target state="translated">실시 예 8 (출시 예정)</target>
        </trans-unit>
        <trans-unit id="62774320706bd47493c114307c201f9b0569a380" translate="yes" xml:space="preserve">
          <source>EXAMPLE 9 Passing open files to XSes</source>
          <target state="translated">예 9 열린 파일을 XSes에 전달</target>
        </trans-unit>
        <trans-unit id="5620a0ea3c2afd67a246637da41377405c24e6fb" translate="yes" xml:space="preserve">
          <source>EXAMPLE OF A SIMPLE PATCH</source>
          <target state="translated">간단한 패치의 예</target>
        </trans-unit>
        <trans-unit id="a8099c29efbd0420188d4a7efe08cb02085720f0" translate="yes" xml:space="preserve">
          <source>EXAMPLE: $ perl -e&quot;exit 44;&quot; Non-hushed error exit %SYSTEM-F-ABORT, abort DCL message $ show sym $STATUS $STATUS == &quot;%X0000002C&quot;</source>
          <target state="translated">예 : $ perl -e &quot;종료 44;&quot; 중단되지 않은 오류 종료 % SYSTEM-F-ABORT, 중단 DCL 메시지 $ show sym $ STATUS $ STATUS == &quot;% X0000002C&quot;</target>
        </trans-unit>
        <trans-unit id="a06e781ed035862478fdb8e74e8410d0fb77a7e0" translate="yes" xml:space="preserve">
          <source>EXAMPLE: if ($quiet_exit) { vmsish::hushed(1); } print &quot;Sssshhhh...I'm hushed...\n&quot; if vmsish::hushed(); exit 44;</source>
          <target state="translated">예 : if ($ quiet_exit) {vmsish :: hushed (1); } vmsish :: hushed () 인 경우 &quot;Sssshhhh ... 허쉬되었습니다 ... \ n&quot;으로 인쇄합니다. 출구 44;</target>
        </trans-unit>
        <trans-unit id="c8296cf24395c1237ea3d8bd4a47331705d59199" translate="yes" xml:space="preserve">
          <source>EXAMPLE: use vmsish 'hushed'; # turn on hushed flag use Carp; # Carp compiled hushed exit 44; # will be hushed croak('I die'); # will be hushed no vmsish 'hushed'; # turn off hushed flag exit 44; # will not be hushed croak('I die2'): # WILL be hushed, croak was compiled hushed</source>
          <target state="translated">예 : vmsish 'hushed'를 사용하십시오. # 허쉬 깃발 사용 잉어를 켜십시오; # 잉어는 44 번 출구를 compiled 다; # 으깬다 ( 'I die'); #는 '숨겨진'vmsish가 아닙니다. # hushed flag exit 44를 끄십시오. # 으르렁 거리지 않을 것입니다 ( 'I die2') : # 으르 릴 것입니다.</target>
        </trans-unit>
        <trans-unit id="9659699670b30983eb4e3c22454887e3c9c6ce39" translate="yes" xml:space="preserve">
          <source>EXAMPLES</source>
          <target state="translated">EXAMPLES</target>
        </trans-unit>
        <trans-unit id="80b0ebd5e30f42e63544199d92ca94554dccc4b9" translate="yes" xml:space="preserve">
          <source>EXCEPTIONS</source>
          <target state="translated">EXCEPTIONS</target>
        </trans-unit>
        <trans-unit id="b7510c8c453004eea60fefa1e03b9543d11c009d" translate="yes" xml:space="preserve">
          <source>EXIT CODES</source>
          <target state="translated">출구 코드</target>
        </trans-unit>
        <trans-unit id="3a06c7d53de8e4207bc5b59139ccca4aa8a85a6b" translate="yes" xml:space="preserve">
          <source>EXIT STATUS</source>
          <target state="translated">종료 상태</target>
        </trans-unit>
        <trans-unit id="49e2ee12a2cb5c774bfad575cb3bcba82617b335" translate="yes" xml:space="preserve">
          <source>EXITING A THREAD</source>
          <target state="translated">실을 잡기</target>
        </trans-unit>
        <trans-unit id="e4f2a2341e0d9e2dcbb8ca9ce37431a945288e22" translate="yes" xml:space="preserve">
          <source>EXPECTED METHODS</source>
          <target state="translated">예상 방법</target>
        </trans-unit>
        <trans-unit id="ecfb7a5ad5fc1b4f5cc510ab16d0961139e316c5" translate="yes" xml:space="preserve">
          <source>EXPIRATION SUPPORT</source>
          <target state="translated">만료 지원</target>
        </trans-unit>
        <trans-unit id="c0b9641f510bdc263b1b4f8cdf15c1c068ad9fea" translate="yes" xml:space="preserve">
          <source>EXPORT</source>
          <target state="translated">EXPORT</target>
        </trans-unit>
        <trans-unit id="77df0281a5c47be5d00ae61a57ff00e23d9d5e5b" translate="yes" xml:space="preserve">
          <source>EXPORTABLE FUNCTIONS</source>
          <target state="translated">수출 가능한 기능</target>
        </trans-unit>
        <trans-unit id="22d0596dab83a0920d66ad899d3e61f47464b88e" translate="yes" xml:space="preserve">
          <source>EXPORTABLE VARIABLES</source>
          <target state="translated">수출 가능한 변수</target>
        </trans-unit>
        <trans-unit id="43aade251566381046f1d9dd6f51422fde3c0fbd" translate="yes" xml:space="preserve">
          <source>EXPORTED FUNCTIONS</source>
          <target state="translated">수출 된 기능</target>
        </trans-unit>
        <trans-unit id="8b30e3050a39fae8e0c617ff76ab8d47b5f0b044" translate="yes" xml:space="preserve">
          <source>EXPORTED SYMBOLS</source>
          <target state="translated">수출 된 상징</target>
        </trans-unit>
        <trans-unit id="e9e012170f2df7cb18fa26019e2b46cbf4a91319" translate="yes" xml:space="preserve">
          <source>EXPORTS</source>
          <target state="translated">EXPORTS</target>
        </trans-unit>
        <trans-unit id="7b479848a0ec11ad7c3ba1025f3ac20068015bb9" translate="yes" xml:space="preserve">
          <source>EXPORTS (by request only)</source>
          <target state="translated">수출 (요청에 의해서만)</target>
        </trans-unit>
        <trans-unit id="6b6562ec1f5d1b67f0bbd288b913382cd128ba1e" translate="yes" xml:space="preserve">
          <source>EXPORT_LIST: name of a file that is passed to linker to define symbols to be exported.</source>
          <target state="translated">EXPORT_LIST : 내보낼 심볼을 정의하기 위해 링커로 전달되는 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="a6fc3ffe71e48b679d9c5609def42ab3c69aa49f" translate="yes" xml:space="preserve">
          <source>EXPORT_OK</source>
          <target state="translated">EXPORT_OK</target>
        </trans-unit>
        <trans-unit id="f817892a6b7b040f6bf499b1ab6645711184a4f1" translate="yes" xml:space="preserve">
          <source>EXPR</source>
          <target state="translated">EXPR</target>
        </trans-unit>
        <trans-unit id="3499643610f3dd44dae6eb02d7fed2d648b428d9" translate="yes" xml:space="preserve">
          <source>EXPR is executed as a system command. The collected standard output of the command is returned. In scalar context, it comes back as a single (potentially multi-line) string. In list context, returns a list of lines (however you've defined lines with &lt;code&gt;$/&lt;/code&gt; or &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; ). This is the internal function implementing the &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx/EXPR/&lt;/a&gt;&lt;/code&gt; operator, but you can use it directly. The &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx/EXPR/&lt;/a&gt;&lt;/code&gt; operator is discussed in more detail in &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;. If EXPR is omitted, uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">EXPR은 시스템 명령으로 실행됩니다. 명령의 수집 된 표준 출력이 리턴됩니다. 스칼라 컨텍스트에서는 단일 (잠재적으로 여러 줄) 문자열로 돌아옵니다. 목록 컨텍스트에서 행 목록을 리턴합니다 (그러나 &lt;code&gt;$/&lt;/code&gt; 또는 &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; 행을 정의 했습니다 ). 이것은 &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx/EXPR/&lt;/a&gt;&lt;/code&gt; 연산자를 구현하는 내부 함수 이지만 직접 사용할 수 있습니다. &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx/EXPR/&lt;/a&gt;&lt;/code&gt; 오퍼레이터에 자세히 설명되어 &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;perlop에서 I / O 연산자&lt;/a&gt; . EXPR이 생략되면 &lt;code&gt;$_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f586c420e6eaf4cfbda37e4566d4c88b6984ca54" translate="yes" xml:space="preserve">
          <source>EXPR is executed as a system command. The collected standard output of the command is returned. In scalar context, it comes back as a single (potentially multi-line) string. In list context, returns a list of lines (however you've defined lines with &lt;code&gt;$/&lt;/code&gt; or &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; ). This is the internal function implementing the &lt;code&gt;&lt;a href=&quot;qx&quot;&gt;qx/EXPR/&lt;/a&gt;&lt;/code&gt; operator, but you can use it directly. The &lt;code&gt;&lt;a href=&quot;qx&quot;&gt;qx/EXPR/&lt;/a&gt;&lt;/code&gt; operator is discussed in more detail in &lt;a href=&quot;../perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;. If EXPR is omitted, uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">EXPR은 시스템 명령으로 실행됩니다. 명령의 수집 된 표준 출력이 리턴됩니다. 스칼라 컨텍스트에서는 단일 (잠재적으로 여러 줄) 문자열로 돌아옵니다. 목록 컨텍스트에서 행 목록을 리턴합니다 (그러나 &lt;code&gt;$/&lt;/code&gt; 또는 &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; 행을 정의 했습니다 ). 이것은 &lt;code&gt;&lt;a href=&quot;qx&quot;&gt;qx/EXPR/&lt;/a&gt;&lt;/code&gt; 연산자를 구현하는 내부 함수 이지만 직접 사용할 수 있습니다. &lt;code&gt;&lt;a href=&quot;qx&quot;&gt;qx/EXPR/&lt;/a&gt;&lt;/code&gt; 오퍼레이터에 자세히 설명되어 &lt;a href=&quot;../perlop#I%2fO-Operators&quot;&gt;perlop에서 I / O 연산자&lt;/a&gt; . EXPR이 생략되면 &lt;code&gt;$_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4a4d24b33941bccd86ff7ba0c19dc15933e36a4" translate="yes" xml:space="preserve">
          <source>EXTENDED CONSTRUCTS</source>
          <target state="translated">확장 된 구조</target>
        </trans-unit>
        <trans-unit id="b070e356144357fb71137b31e2e89f09d2f73b53" translate="yes" xml:space="preserve">
          <source>EXTERN.h</source>
          <target state="translated">EXTERN.h</target>
        </trans-unit>
        <trans-unit id="13ae0f4e98553c4041bca1bd5b70b21a5aa6d865" translate="yes" xml:space="preserve">
          <source>EXTRALIBS</source>
          <target state="translated">EXTRALIBS</target>
        </trans-unit>
        <trans-unit id="3633746b067241666bc462dcfe7a24ff23a8db68" translate="yes" xml:space="preserve">
          <source>Each</source>
          <target state="translated">Each</target>
        </trans-unit>
        <trans-unit id="64713135c29a168f621e3cd6c59750f2ec3360d2" translate="yes" xml:space="preserve">
          <source>Each &quot;=over&quot; ... &quot;=back&quot; region should be one of the following:</source>
          <target state="translated">각 &quot;= over&quot;... &quot;= back&quot;영역은 다음 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="8573b03d1dbd851733546c18897b586541b26327" translate="yes" xml:space="preserve">
          <source>Each &lt;b&gt;File&lt;/b&gt; section reports on a single file. Each &lt;b&gt;Subroutine&lt;/b&gt; section reports on a single subroutine apart from the special cases &quot;(definitions)&quot; and &quot;(main)&quot;. These report, respectively, on subroutine definitions found by the initial symbol table walk and on the main part of the program or module external to all subroutines.</source>
          <target state="translated">각 &lt;b&gt;파일&lt;/b&gt; 섹션은 단일 파일에 대해보고합니다. 각 &lt;b&gt;서브 루틴&lt;/b&gt; 섹션은 특수한 경우 &quot;(definitions)&quot;및 &quot;(main)&quot;을 제외하고 단일 서브 루틴에 대해보고합니다. 이 보고서는 각각 초기 기호 테이블에서 찾은 서브 루틴 정의와 모든 서브 루틴 외부의 프로그램 또는 모듈의 주요 부분에 대한 보고서입니다.</target>
        </trans-unit>
        <trans-unit id="c3f67868071b09e484f931abe029f1f8f7b5dc16" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;--$source-option&lt;/code&gt; option must specify a key/value pair separated by an &lt;code&gt;=&lt;/code&gt; . If an option can take multiple values, just specify it multiple times, as with the &lt;code&gt;extensions=&lt;/code&gt; examples above. If the option should be a hash reference, specify the value as a second pair separated by a &lt;code&gt;=&lt;/code&gt; , as in the &lt;code&gt;pset=&lt;/code&gt; examples above (escape &lt;code&gt;=&lt;/code&gt; with a backslash).</source>
          <target state="translated">각 &lt;code&gt;--$source-option&lt;/code&gt; 옵션은 키 / 값 쌍을 &lt;code&gt;=&lt;/code&gt; 로 구분하여 지정해야합니다 . 옵션이 여러 값을 가질 수있는 경우 위 의 &lt;code&gt;extensions=&lt;/code&gt; 예제 와 같이 옵션을 여러 번 지정하십시오 . 옵션이 해시 참조 여야하는 경우 위 의 &lt;code&gt;pset=&lt;/code&gt; 예제와 같이 두 번째 쌍으로 값을 a &lt;code&gt;=&lt;/code&gt; 로 구분하여 지정하십시오 (이스케이프 &lt;code&gt;=&lt;/code&gt; 백 슬래시 포함).</target>
        </trans-unit>
        <trans-unit id="114f01b386e99faf35799463e66245b3c628986d" translate="yes" xml:space="preserve">
          <source>Each C type is represented by an entry in the typemap file that is responsible for converting perl variables (SV, AV, HV, CV, etc.) to and from that type. The following sections list all XS types that come with perl by default.</source>
          <target state="translated">각 C 유형은 유형 맵 파일에서 perl 변수 (SV, AV, HV, CV 등)를 해당 유형으로 변환하는 역할을합니다. 다음 섹션에는 기본적으로 perl과 함께 제공되는 모든 XS 유형이 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="45fe11f5c5ad8666badf6e1b74648061569fd2e9" translate="yes" xml:space="preserve">
          <source>Each CV has a pointer, &lt;code&gt;CvOUTSIDE()&lt;/code&gt; , to its lexically enclosing CV (if any). Because pointers to anonymous sub prototypes are stored in &lt;code&gt;&amp;amp;&lt;/code&gt; pad slots, it is a possible to get a circular reference, with the parent pointing to the child and vice-versa. To avoid the ensuing memory leak, we do not increment the reference count of the CV pointed to by &lt;code&gt;CvOUTSIDE&lt;/code&gt; in the</source>
          <target state="translated">각 CV에는 &lt;code&gt;CvOUTSIDE()&lt;/code&gt; 포인터 가 어휘 적으로 둘러싸인 CV (있는 경우 )에 대한 포인터가 있습니다. 익명의 하위 프로토 타입에 대한 포인터는 &lt;code&gt;&amp;amp;&lt;/code&gt; 패드 슬롯에 저장 되므로 부모가 자식을 가리키고 그 반대도 순환 참조를 얻을 수 있습니다. 계속되는 메모리 누수를 피하기 위해 &lt;code&gt;CvOUTSIDE&lt;/code&gt; 가 가리키는 CV의 참조 카운트를 증가시키지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="877f690dc448228c6c71438f034057615156195d" translate="yes" xml:space="preserve">
          <source>Each INPUT or OUTPUT typemap entry is a double-quoted Perl string that will be evaluated in the presence of certain variables to get the final C code for mapping a certain C type.</source>
          <target state="translated">각 INPUT 또는 OUTPUT 유형 맵 항목은 특정 C 유형을 맵핑하기위한 최종 C 코드를 얻기 위해 특정 변수가있을 때 평가되는 큰 따옴표로 묶인 Perl 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="fb013f151204036ffe28cd6f1b7420c85313acfd" translate="yes" xml:space="preserve">
          <source>Each NAME is assumed to be in the calling package. See share_from for an alternative method (which &lt;code&gt;share&lt;/code&gt; uses).</source>
          <target state="translated">각 NAME은 호출 패키지에 있다고 가정합니다. 대체 방법 ( &lt;code&gt;share&lt;/code&gt; 사용)에 대해서는 share_from을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5c9985ee57f0e8b2c8e51c7278e3d4c3d9b47d87" translate="yes" xml:space="preserve">
          <source>Each NAME must be the &lt;b&gt;name&lt;/b&gt; of a non-lexical variable, typically with the leading type identifier included. A bareword is treated as a function name.</source>
          <target state="translated">각 NAME은 일반적으로 선행 유형 식별자가 포함 된 비-어휘 변수 의 &lt;b&gt;이름&lt;/b&gt; 이어야합니다 . 베어 워드는 함수 이름으로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="2d1afe9f64b8afc5ff5d1587bde457161df361bb" translate="yes" xml:space="preserve">
          <source>Each array &lt;code&gt;@{&quot;_&amp;lt;$filename&quot;}&lt;/code&gt; holds the lines of $filename for a file compiled by Perl. The same is also true for &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed strings that contain subroutines, or which are currently being executed. The $filename for &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed strings looks like &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; .</source>
          <target state="translated">각 배열 &lt;code&gt;@{&quot;_&amp;lt;$filename&quot;}&lt;/code&gt; 은 Perl에 의해 컴파일 된 파일에 대한 $ filename 행을 보유합니다. 서브 루틴을 포함하거나 현재 실행중인 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 문자열 도 마찬가지입니다 . &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 문자열 의 $ filename은 다음과 같습니다 &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83f0c2f3d8605c13877f68e54dd82f6341b8fae0" translate="yes" xml:space="preserve">
          <source>Each class can define its &lt;b&gt;attributes&lt;/b&gt;. When we instantiate an object, we assign values to those attributes. For example, every &lt;code&gt;File&lt;/code&gt; object has a path. Attributes are sometimes called &lt;b&gt;properties&lt;/b&gt;.</source>
          <target state="translated">각 클래스는 &lt;b&gt;속성을&lt;/b&gt; 정의 할 수 있습니다 . 객체를 인스턴스화 할 때 해당 속성에 값을 할당합니다. 예를 들어, 모든 &lt;code&gt;File&lt;/code&gt; 객체에는 경로가 있습니다. 속성을 속성이라고도 &lt;b&gt;합니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="64bf8b278b40ceb1457596f928446c91560cdf44" translate="yes" xml:space="preserve">
          <source>Each compartment has an associated &quot;operator mask&quot;. Recall that perl code is compiled into an internal format before execution. Evaluating perl code (e.g. via &quot;eval&quot; or &quot;do 'file'&quot;) causes the code to be compiled into an internal format and then, provided there was no error in the compilation, executed. Code evaluated in a compartment compiles subject to the compartment's operator mask. Attempting to evaluate code in a compartment which contains a masked operator will cause the compilation to fail with an error. The code will not be executed.</source>
          <target state="translated">각 구획에는 관련 &quot;오퍼레이터 마스크&quot;가 있습니다. 펄 코드는 실행 전에 내부 형식으로 컴파일된다는 것을 기억하십시오. Perl 코드를 평가하면 (예 : &quot;eval&quot;또는 &quot;do 'file'&quot;을 통해) 코드가 내부 형식으로 컴파일 된 다음 컴파일에 오류가없는 경우 실행됩니다. 구획에서 평가 된 코드는 구획의 운영자 마스크에 따라 컴파일됩니다. 마스크 처리 된 연산자가 포함 된 구획에서 코드를 평가하려고하면 컴파일 오류가 발생합니다. 코드가 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="035a2860cc641f9a6aba917e368a923359692185" translate="yes" xml:space="preserve">
          <source>Each element in the struct data has an accessor method, which is used to assign to the element and to fetch its value. The default accessor can be overridden by declaring a &lt;code&gt;&lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; of the same name in the package. (See Example 2.)</source>
          <target state="translated">구조체 데이터의 각 요소에는 요소에 할당하고 해당 값을 가져 오는 데 사용되는 접근 자 메서드가 있습니다. 패키지에서 같은 이름 의 &lt;code&gt;&lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 를 선언하여 기본 접근자를 재정의 할 수 있습니다 . (실시 예 2 참조)</target>
        </trans-unit>
        <trans-unit id="fd1373d9ec88c46f95e3a35afb96af5418baf7f3" translate="yes" xml:space="preserve">
          <source>Each element of &lt;code&gt;%!&lt;/code&gt; has a true value only if &lt;code&gt;$!&lt;/code&gt; is set to that value. For example, &lt;code&gt;$!{ENOENT}&lt;/code&gt; is true if and only if the current value of &lt;code&gt;$!&lt;/code&gt; is &lt;code&gt;ENOENT&lt;/code&gt; ; that is, if the most recent error was &quot;No such file or directory&quot; (or its moral equivalent: not all operating systems give that exact error, and certainly not all languages). To check if a particular key is meaningful on your system, use &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;
$!{the_key}&lt;/code&gt; ; for a list of legal keys, use &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; %!&lt;/code&gt; . See &lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt; for more information, and also see &lt;a href=&quot;#%24!&quot;&gt;$!&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;%!&lt;/code&gt; 각 요소 ! true 값 만이 &lt;code&gt;$!&lt;/code&gt; 해당 값으로 설정되어 있습니다. 예를 들어 &lt;code&gt;$!{ENOENT}&lt;/code&gt; 는 현재 값이 &lt;code&gt;$!&lt;/code&gt; 인 경우에만 true입니다 . 이다 &lt;code&gt;ENOENT&lt;/code&gt; 는 ; 즉, 가장 최근의 오류가 &quot;No such file or directory&quot;(또는 그러한 파일이나 디렉토리가 없음) 인 경우 (또는 그와 동등한 도덕적 : 모든 운영 체제가 정확한 오류를 제공하는 것은 아니며 모든 언어가 아님). 특정 키가 시스템에 의미가 있는지 확인하려면, 사용은 &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt; $!{the_key}&lt;/code&gt; ; 유효한 키 목록을 보려면 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; %!&lt;/code&gt; 사용하십시오 ! . 자세한 내용은 &lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt; 를 참조하고 &lt;a href=&quot;#%24!&quot;&gt;$&lt;/a&gt; 도 참조하십시오 ! .</target>
        </trans-unit>
        <trans-unit id="06a2d451f571f682ca87c1d143e9cc5d9cc9752a" translate="yes" xml:space="preserve">
          <source>Each element of the &lt;code&gt;@tests&lt;/code&gt; array is either:</source>
          <target state="translated">&lt;code&gt;@tests&lt;/code&gt; 배열 의 각 요소는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="d55ab66461652be4398995f0bc7395b92cdadc85" translate="yes" xml:space="preserve">
          <source>Each element on the right-hand side must be a reference to a datum of the right type. Parentheses immediately surrounding an array (and possibly also &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;) will make each element of the array an alias to the corresponding scalar referenced on the right-hand side:</source>
          <target state="translated">오른쪽의 각 요소는 올바른 유형의 데이텀에 대한 참조 여야합니다. 배열을 둘러싼 괄호 (및 아마도 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; )는 배열의 각 요소를 오른쪽에서 참조되는 해당 스칼라의 별칭으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="4684b159123c6d2eb2be5f3fb5fb6b32cbd2c836" translate="yes" xml:space="preserve">
          <source>Each element's type can be scalar, array, hash, or class.</source>
          <target state="translated">각 요소의 유형은 스칼라, 배열, 해시 또는 클래스 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a18db593068986b02fcc2822d10b93bd6ae4e04" translate="yes" xml:space="preserve">
          <source>Each engine is supposed to provide access to a constant structure of the following format:</source>
          <target state="translated">각 엔진은 다음 형식의 일정한 구조에 대한 액세스를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="df21f7171545bb80d42912cbb46608328ace6052" translate="yes" xml:space="preserve">
          <source>Each field in a picture line starts with either &quot;@&quot; (at) or &quot;^&quot; (caret), indicating what we'll call, respectively, a &quot;regular&quot; or &quot;special&quot; field. The choice of pad characters determines whether a field is textual or numeric. The tilde operators are not part of a field. Let's look at the various possibilities in detail.</source>
          <target state="translated">그림 라인의 각 필드는 &quot;@&quot;(at) 또는 &quot;^&quot;(캐럿)으로 시작하며 각각 &quot;일반&quot;또는 &quot;특별&quot;필드라고 부릅니다. 패드 문자 선택은 필드가 텍스트인지 숫자인지를 결정합니다. 물결표 연산자는 필드의 일부가 아닙니다. 다양한 가능성을 자세하게 살펴 보자.</target>
        </trans-unit>
        <trans-unit id="e86751063b4744e62f491d3c6500569d32c72d11" translate="yes" xml:space="preserve">
          <source>Each filehandle in Perl counts the number of lines that have been read from it. (Depending on the value of &lt;code&gt;$/&lt;/code&gt; , Perl's idea of what constitutes a line may not match yours.) When a line is read from a filehandle (via &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ), or when &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek()&lt;/a&gt;&lt;/code&gt; is called on it, &lt;code&gt;$.&lt;/code&gt; becomes an alias to the line counter for that filehandle.</source>
          <target state="translated">Perl의 각 파일 핸들은 읽은 행 수를 계산합니다. ( &lt;code&gt;$/&lt;/code&gt; 의 값에 따라 라인을 구성하는 것에 대한 Perl의 아이디어는 귀하의 라인과 일치하지 않을 수 있습니다.) 파일 핸들에서 라인을 읽을 때 ( &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ), &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek()&lt;/a&gt;&lt;/code&gt; 가 그것에 불렀다, &lt;code&gt;$.&lt;/code&gt; 해당 파일 핸들의 행 카운터에 대한 별명이됩니다.</target>
        </trans-unit>
        <trans-unit id="31a9624b1b717a0ce3347c2a7723ee1a1d25abab" translate="yes" xml:space="preserve">
          <source>Each handle can be an &lt;code&gt;IO::Handle&lt;/code&gt; object, an integer or an array reference where the first element is an &lt;code&gt;IO::Handle&lt;/code&gt; or an integer.</source>
          <target state="translated">각 핸들은 &lt;code&gt;IO::Handle&lt;/code&gt; 객체, 정수 또는 첫 번째 요소가 &lt;code&gt;IO::Handle&lt;/code&gt; 또는 정수인 배열 참조 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1d7462289e4cec1a7aa1fe4c855d903202ec597" translate="yes" xml:space="preserve">
          <source>Each hash &lt;code&gt;%{&quot;_&amp;lt;$filename&quot;}&lt;/code&gt; contains breakpoints and actions keyed by line number. Individual entries (as opposed to the whole hash) are settable. Perl only cares about Boolean true here, although the values used by</source>
          <target state="translated">각 해시 &lt;code&gt;%{&quot;_&amp;lt;$filename&quot;}&lt;/code&gt; 에는 줄 번호를 기준으로 중단 점과 작업이 포함되어 있습니다. 전체 항목과 달리 개별 항목을 설정할 수 있습니다. Perl은 여기에서 사용되는 값에도 불구하고 Boolean true 만 고려합니다.</target>
        </trans-unit>
        <trans-unit id="62cc45eed91752b51404de9ea925a035fb43cbad" translate="yes" xml:space="preserve">
          <source>Each id must be unique within the document.</source>
          <target state="translated">각 ID는 문서 내에서 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="667975ad4758db6be064d162ec07e954e503457b" translate="yes" xml:space="preserve">
          <source>Each individual compressed data stream is read until the logical end-of-file is reached. Then &lt;code&gt;nextStream&lt;/code&gt; is called. This will skip to the start of the next compressed data stream and clear the end-of-file flag.</source>
          <target state="translated">논리적 개별 파일 끝에 도달 할 때까지 각 개별 압축 데이터 스트림을 읽습니다. 그런 다음 &lt;code&gt;nextStream&lt;/code&gt; 이 호출됩니다. 이것은 다음 압축 데이터 스트림의 시작으로 건너 뛰고 파일 끝 플래그를 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="18f2cec26478e04f9b7de7d10fcbddee95e58d2c" translate="yes" xml:space="preserve">
          <source>Each initializer is a pair of values:</source>
          <target state="translated">각 이니셜 라이저는 한 쌍의 값입니다.</target>
        </trans-unit>
        <trans-unit id="16164820a467e235638c757ccfe00052f4c79b5f" translate="yes" xml:space="preserve">
          <source>Each is a reference to an array of hostnames (in order of preference), which should be used for the given protocol</source>
          <target state="translated">각각은 주어진 프로토콜에 사용해야하는 호스트 이름의 배열에 대한 참조입니다 (기본 설정 순서대로).</target>
        </trans-unit>
        <trans-unit id="c7c5e455da6b08e4d8e8bc9f42db356fdab7233a" translate="yes" xml:space="preserve">
          <source>Each key is the property name in its longest, most descriptive form. The values are what &lt;a href=&quot;#charprop()&quot;&gt;charprop()&lt;/a&gt; would return.</source>
          <target state="translated">각 키는 가장 길고 가장 설명적인 형식의 속성 이름입니다. 값은 무엇입니까 &lt;a href=&quot;#charprop()&quot;&gt;charprop ()&lt;/a&gt; 반환합니다.</target>
        </trans-unit>
        <trans-unit id="47492265b46ae806bb067e9b524f132422627a4f" translate="yes" xml:space="preserve">
          <source>Each letter may optionally be followed by a number indicating the repeat count. A numeric repeat count may optionally be enclosed in brackets, as in &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;C[80]&quot;, @arr)&lt;/code&gt; . The repeat count gobbles that many values from the LIST when used with all format types other than &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;Z&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;h&lt;/code&gt; , &lt;code&gt;H&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; , &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; , and &lt;code&gt;P&lt;/code&gt; , where it means something else, described below. Supplying a &lt;code&gt;*&lt;/code&gt; for the repeat count instead of a number means to use however many items are left, except for:</source>
          <target state="translated">각 문자 다음에는 반복 횟수를 나타내는 숫자가 선택적으로 올 수 있습니다. &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;C[80]&quot;, @arr)&lt;/code&gt; 에서와 같이 숫자 반복 횟수는 선택적으로 대괄호로 묶을 수 있습니다 . 반복 횟수는 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;Z&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;h&lt;/code&gt; , &lt;code&gt;H&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; , 이외 의 모든 형식 유형과 함께 사용될 때 LIST에서 많은 값을 가져옵니다 &lt;code&gt;.&lt;/code&gt; , &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; , &lt;code&gt;P&lt;/code&gt; 는 아래에 설명 된 다른 것을 의미합니다. 공급 &lt;code&gt;*&lt;/code&gt; 숫자 대신 반복 횟수는 다음을 제외하고 많은 항목이 남아 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f1b93edbbeb731023c3dcd7b867f87661f785306" translate="yes" xml:space="preserve">
          <source>Each letter may optionally be followed by a number indicating the repeat count. A numeric repeat count may optionally be enclosed in brackets, as in &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;(&quot;C[80]&quot;, @arr)&lt;/code&gt; . The repeat count gobbles that many values from the LIST when used with all format types other than &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;Z&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;h&lt;/code&gt; , &lt;code&gt;H&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; , &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; , and &lt;code&gt;P&lt;/code&gt; , where it means something else, described below. Supplying a &lt;code&gt;*&lt;/code&gt; for the repeat count instead of a number means to use however many items are left, except for:</source>
          <target state="translated">각 문자 다음에는 반복 횟수를 나타내는 숫자가 선택적으로 올 수 있습니다. &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;(&quot;C[80]&quot;, @arr)&lt;/code&gt; 에서와 같이 숫자 반복 횟수는 선택적으로 대괄호로 묶을 수 있습니다 . 반복 횟수는 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;Z&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;h&lt;/code&gt; , &lt;code&gt;H&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; , 이외 의 모든 형식 유형과 함께 사용될 때 LIST에서 많은 값을 가져옵니다 &lt;code&gt;.&lt;/code&gt; , &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; , &lt;code&gt;P&lt;/code&gt; 는 아래에 설명 된 다른 것을 의미합니다. 공급 &lt;code&gt;*&lt;/code&gt; 숫자 대신 반복 횟수는 다음을 제외하고 많은 항목이 남아 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0ca2b686ea513abcdcd81b004dc80b72da247c37" translate="yes" xml:space="preserve">
          <source>Each locale key is a reference to a hash that has the form above, and gives the casing rules for that particular locale, which take precedence over the locale-independent ones when in that locale.</source>
          <target state="translated">각 로케일 키는 위 형식의 해시에 대한 참조이며 해당 로케일에있을 때 로케일 독립적 인 키보다 우선하는 특정 로케일에 대한 케이싱 규칙을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b81c66f6a67c62b4046a77844c9acd84b539087f" translate="yes" xml:space="preserve">
          <source>Each method returns the old value of the &lt;code&gt;IO::Handle&lt;/code&gt; attribute. The methods each take an optional EXPR, which, if supplied, specifies the new value for the &lt;code&gt;IO::Handle&lt;/code&gt; attribute in question. If not supplied, most methods do nothing to the current value--except for &lt;code&gt;autoflush()&lt;/code&gt; , which will assume a 1 for you, just to be different.</source>
          <target state="translated">각 메소드는 &lt;code&gt;IO::Handle&lt;/code&gt; 속성 의 이전 값을 리턴 합니다. 메소드는 각각 옵션 인 EXPR을 사용하며, 제공되는 경우 해당 &lt;code&gt;IO::Handle&lt;/code&gt; 속성 의 새 값을 지정합니다 . 제공되지 않으면 대부분의 메소드는 현재 값에 아무런 영향을 미치지 않습니다. &lt;code&gt;autoflush()&lt;/code&gt; 제외하고 1을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="0a408a79f13c6ec4a0cd81e57c787564393f289b" translate="yes" xml:space="preserve">
          <source>Each name-type pair declares one element of the struct. Each element name will be defined as an accessor method unless a method by that name is explicitly defined; in the latter case, a warning is issued if the warning flag (&lt;b&gt;-w&lt;/b&gt;) is set.</source>
          <target state="translated">각 이름 유형 쌍은 구조체의 한 요소를 선언합니다. 각 요소 이름은 해당 이름의 메소드가 명시 적으로 정의되지 않은 한 접근 자 메소드로 정의됩니다. 후자의 경우 경고 플래그 ( &lt;b&gt;-w&lt;/b&gt; )가 설정 되면 경고가 발행됩니다 .</target>
        </trans-unit>
        <trans-unit id="bea2fa8177204a00acbe330d65cd373309740d46" translate="yes" xml:space="preserve">
          <source>Each of the &lt;code&gt;$section_spec&lt;/code&gt; arguments should be a section specification as described in &lt;a href=&quot;#SECTION-SPECIFICATIONS&quot;&gt;SECTION SPECIFICATIONS&lt;/a&gt;. The section specifications are parsed by this method and the resulting regular expressions are stored in the invoking object.</source>
          <target state="translated">각 &lt;code&gt;$section_spec&lt;/code&gt; 인수는 &lt;a href=&quot;#SECTION-SPECIFICATIONS&quot;&gt;SECTION SPECIFICATIONS에&lt;/a&gt; 설명 된대로 섹션 스펙이어야합니다 . 섹션 스펙은이 메소드에 의해 구문 분석되며 결과 정규식은 호출 오브젝트에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="9af6792ba1f44d7cb824f7440960f3ef5c01b6ba" translate="yes" xml:space="preserve">
          <source>Each of the POSIX classes matches exactly the same as their ASCII-range counterparts.</source>
          <target state="translated">각 POSIX 클래스는 ASCII 범위의 클래스와 정확히 일치합니다.</target>
        </trans-unit>
        <trans-unit id="be167c32ebe292b1abf425a82a9d67c142fdc9a5" translate="yes" xml:space="preserve">
          <source>Each of the argument lists above comes out of the &lt;code&gt;normalize_f&lt;/code&gt; function looking exactly the same, like this:</source>
          <target state="translated">위의 각 인수 목록은 다음과 같이 정확하게 동일한 &lt;code&gt;normalize_f&lt;/code&gt; 함수 에서 나옵니다 .</target>
        </trans-unit>
        <trans-unit id="93679dc7d627c4c7a6a3897712645c4450ba1379" translate="yes" xml:space="preserve">
          <source>Each of the commands that produce listings of modules (&lt;code&gt;r&lt;/code&gt; , &lt;code&gt;autobundle&lt;/code&gt; , &lt;code&gt;u&lt;/code&gt; ) also return a list of the IDs of all modules within the list.</source>
          <target state="translated">모듈 목록 ( &lt;code&gt;r&lt;/code&gt; , &lt;code&gt;autobundle&lt;/code&gt; , &lt;code&gt;u&lt;/code&gt; ) 을 생성하는 각 명령 은 목록에있는 모든 모듈의 ID 목록도 반환합니다.</target>
        </trans-unit>
        <trans-unit id="36a145ce6b55d2eacd4e152e8b778cb0812f1b4c" translate="yes" xml:space="preserve">
          <source>Each of the elementary pieces of regular expressions which were described before (such as &lt;code&gt;ab&lt;/code&gt; or &lt;code&gt;\Z&lt;/code&gt; ) could match at most one substring at the given position of the input string. However, in a typical regular expression these elementary pieces are combined into more complicated patterns using combining operators &lt;code&gt;ST&lt;/code&gt; , &lt;code&gt;S|T&lt;/code&gt; , &lt;code&gt;S*&lt;/code&gt; etc. (in these examples &lt;code&gt;S&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; are regular subexpressions).</source>
          <target state="translated">이전에 설명한 정규 표현식의 각 기본 조각 (예 : &lt;code&gt;ab&lt;/code&gt; 또는 &lt;code&gt;\Z&lt;/code&gt; )은 입력 문자열의 지정된 위치에서 최대 하나의 하위 문자열과 일치 할 수 있습니다. 그러나, 전형적인 정규식에서, 이러한 기본 조각들은 결합 연산자 &lt;code&gt;ST&lt;/code&gt; , &lt;code&gt;S|T&lt;/code&gt; , &lt;code&gt;S*&lt;/code&gt; 등을 사용하여보다 복잡한 패턴으로 결합된다 (이 예에서 &lt;code&gt;S&lt;/code&gt; 및 &lt;code&gt;T&lt;/code&gt; 는 규칙적인 하위 표현이다).</target>
        </trans-unit>
        <trans-unit id="bf85de30bb2350d06139ae6bc58a79af96a26e97" translate="yes" xml:space="preserve">
          <source>Each of the following invocations of &lt;code&gt;pod2usage()&lt;/code&gt; will print a message of &quot;Syntax error.&quot; (followed by a newline) to &lt;code&gt;STDERR&lt;/code&gt; , immediately followed by just the &quot;SYNOPSIS&quot; section (also printed to &lt;code&gt;STDERR&lt;/code&gt; ) and will exit with a status of 2:</source>
          <target state="translated">다음의 &lt;code&gt;pod2usage()&lt;/code&gt; 호출 은 &quot;구문 오류&quot;메시지를 인쇄합니다. (개행 문자 다음에) &lt;code&gt;STDERR&lt;/code&gt; 에 바로 다음에 &quot;SYNOPSIS&quot;섹션 ( &lt;code&gt;STDERR&lt;/code&gt; 에 인쇄 됨 ) 바로 다음에 상태 2로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="da247936c8bb95b82240dfbb57e8459e5c728eb2" translate="yes" xml:space="preserve">
          <source>Each of the following invocations of &lt;code&gt;pod2usage()&lt;/code&gt; will print just the &quot;SYNOPSIS&quot; section to &lt;code&gt;STDERR&lt;/code&gt; and will exit with a status of 2:</source>
          <target state="translated">다음의 &lt;code&gt;pod2usage()&lt;/code&gt; 호출은 각각 &quot;SYNOPSIS&quot;섹션 만 &lt;code&gt;STDERR&lt;/code&gt; 로 인쇄 하고 상태가 2로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="c3bf15a510b108560bc55f9dc642118c67f04409" translate="yes" xml:space="preserve">
          <source>Each of the following invocations of &lt;code&gt;pod2usage()&lt;/code&gt; will print the &quot;SYNOPSIS&quot; section and any &quot;OPTIONS&quot; and/or &quot;ARGUMENTS&quot; sections to &lt;code&gt;STDOUT&lt;/code&gt; and will exit with a status of 1:</source>
          <target state="translated">다음의 &lt;code&gt;pod2usage()&lt;/code&gt; 호출은 각각 &quot;SYNOPSIS&quot;섹션 및 &quot;OPTIONS&quot;및 / 또는 &quot;ARGUMENTS&quot;섹션을 &lt;code&gt;STDOUT&lt;/code&gt; 에 인쇄 하고 상태가 1로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="8a8549150e98bb7d0199412efeddf54defc2c85f" translate="yes" xml:space="preserve">
          <source>Each of the following invocations of &lt;code&gt;pod2usage()&lt;/code&gt; will print the entire manual page to &lt;code&gt;STDOUT&lt;/code&gt; and will exit with a status of 1:</source>
          <target state="translated">다음의 &lt;code&gt;pod2usage()&lt;/code&gt; 호출은 전체 매뉴얼 페이지를 &lt;code&gt;STDOUT&lt;/code&gt; 으로 인쇄하고 상태 1로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="159291495d574283955b7dd83a0159a4cbe57ab7" translate="yes" xml:space="preserve">
          <source>Each of the following methods will return the total number of corresponding tests if called in scalar context. If called in list context, returns the descriptions of the parsers which contain the corresponding tests (see &lt;code&gt;add&lt;/code&gt; for an explanation of description.</source>
          <target state="translated">다음 각 메소드는 스칼라 컨텍스트에서 호출 된 경우 해당 테스트의 총 수를 리턴합니다. 목록 컨텍스트에서 호출되면 해당 테스트가 포함 된 구문 분석기의 설명을 리턴합니다 (설명에 대한 설명은 &lt;code&gt;add&lt;/code&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="b4805d0a6e23a882a6f379f5e1aaffac33d67fcd" translate="yes" xml:space="preserve">
          <source>Each of the functions will now be discussed in turn.</source>
          <target state="translated">각 기능에 대해 차례로 설명합니다.</target>
        </trans-unit>
        <trans-unit id="cf8ee854b23795d139b708dbd25340dc64f25e5b" translate="yes" xml:space="preserve">
          <source>Each of the functions will return</source>
          <target state="translated">각 함수는</target>
        </trans-unit>
        <trans-unit id="67d949b14cef9bc96632c4a26c1317dd5c052479" translate="yes" xml:space="preserve">
          <source>Each of the integer pack codes &lt;code&gt;sSlLqQ&lt;/code&gt; results in a fixed number of bytes, no matter where you execute your program. This may be useful for some applications, but it does not provide for a portable way to pass data structures between Perl and C programs (bound to happen when you call XS extensions or the Perl function &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt;), or when you read or write binary files. What you'll need in this case are template codes that depend on what your local C compiler compiles when you code &lt;code&gt;short&lt;/code&gt; or &lt;code&gt;unsigned long&lt;/code&gt; , for instance. These codes and their corresponding byte lengths are shown in the table below. Since the C standard leaves much leeway with respect to the relative sizes of these data types, actual values may vary, and that's why the values are given as expressions in C and Perl. (If you'd like to use values from &lt;code&gt;%Config&lt;/code&gt; in your program you have to import it with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Config&lt;/code&gt; .)</source>
          <target state="translated">정수 팩 코드 &lt;code&gt;sSlLqQ&lt;/code&gt; 는 프로그램 실행 위치에 관계없이 고정 된 바이트 수를 생성합니다. 이것은 일부 응용 프로그램에는 유용 ​​할 수 있지만 Perl과 C 프로그램간에 데이터 구조를 전달하는 이식 가능한 방법 (XS 확장 또는 Perl 함수 &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 을 호출 할 때 발생 함 ) 또는 이진 파일을 읽거나 쓸 때 제공되지 않습니다. . 이 경우에 필요한 것은 &lt;code&gt;short&lt;/code&gt; 거나 &lt;code&gt;unsigned long&lt;/code&gt; 을 코딩 할 때 로컬 C 컴파일러가 컴파일하는 것에 의존하는 템플릿 코드입니다.예를 들어. 이러한 코드와 해당 바이트 길이는 아래 표에 나와 있습니다. C 표준은 이러한 데이터 유형의 상대적 크기와 관련하여 많은 여유를 가지기 때문에 실제 값은 다를 수 있으므로 값이 C 및 Perl의 표현식으로 제공됩니다. ( 프로그램 에서 &lt;code&gt;%Config&lt;/code&gt; 값을 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Config&lt;/code&gt; 를 사용 하여 가져와야합니다 .)</target>
        </trans-unit>
        <trans-unit id="35d0d0049982558d7e176e2f3ab3ea596bc6e428" translate="yes" xml:space="preserve">
          <source>Each of the methods below (except config(), accuracy() and precision()) accepts three additional parameters. These arguments &lt;code&gt;$A&lt;/code&gt; , &lt;code&gt;$P&lt;/code&gt; and &lt;code&gt;$R&lt;/code&gt; are &lt;code&gt;accuracy&lt;/code&gt; , &lt;code&gt;precision&lt;/code&gt; and &lt;code&gt;round_mode&lt;/code&gt; . Please see the section about &lt;a href=&quot;#ACCURACY-and-PRECISION&quot;&gt;ACCURACY and PRECISION&lt;/a&gt; for more information.</source>
          <target state="translated">아래의 각 메소드 (config (), precision () 및 precision () 제외)는 세 개의 추가 매개 변수를 허용합니다. 이러한 인수 &lt;code&gt;$A&lt;/code&gt; , &lt;code&gt;$P&lt;/code&gt; 및 &lt;code&gt;$R&lt;/code&gt; 은 &lt;code&gt;accuracy&lt;/code&gt; , &lt;code&gt;precision&lt;/code&gt; 및 &lt;code&gt;round_mode&lt;/code&gt; 입니다. 자세한 내용은 &lt;a href=&quot;#ACCURACY-and-PRECISION&quot;&gt;정확성 및 정밀성&lt;/a&gt; 섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="69bb55af40d1c4ccf668c4ee509cae7b3650aeb0" translate="yes" xml:space="preserve">
          <source>Each of the methods works identically, and is used to install (or uninstall) a single DBM Filter. The only difference between them is the place that the filter is installed.</source>
          <target state="translated">각 방법은 동일하게 작동하며 단일 DBM 필터를 설치 (또는 설치 제거)하는 데 사용됩니다. 그들 사이의 유일한 차이점은 필터가 설치된 장소입니다.</target>
        </trans-unit>
        <trans-unit id="deb52f34c0e7c886d38c077a6693f8fac31c72b2" translate="yes" xml:space="preserve">
          <source>Each of the targets is created only once (but see &lt;a href=&quot;#Scratchpads-and-recursion&quot;&gt;Scratchpads and recursion&lt;/a&gt; below), and when an opcode needs to put an integer, a double, or a string on stack, it just sets the corresponding parts of its</source>
          <target state="translated">각 대상은 한 번만 생성되지만 (아래의 &lt;a href=&quot;#Scratchpads-and-recursion&quot;&gt;스크래치 패드 및 재귀&lt;/a&gt; 참조) opcode가 정수, 이중 또는 문자열을 스택에 배치해야하는 경우 해당 대상의 해당 부분 만 설정합니다.</target>
        </trans-unit>
        <trans-unit id="61645526a5f8cc5b5b38c365e573e3b9ce2a363a" translate="yes" xml:space="preserve">
          <source>Each of these areas will be discussed in the following sections.</source>
          <target state="translated">이러한 각 영역에 대해서는 다음 섹션에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="4a7e0927366cb3008e3cb582f1225e023afb76ec" translate="yes" xml:space="preserve">
          <source>Each of these functions are called without arguments and return the absolute path of the current working directory.</source>
          <target state="translated">이러한 각 함수는 인수없이 호출되며 현재 작업 디렉토리의 절대 경로를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="fb6c26bfd690fb609fa0a362b968489c94f785d7" translate="yes" xml:space="preserve">
          <source>Each of these input objects are described in further detail in the sections which follow.</source>
          <target state="translated">이러한 입력 개체 각각에 대해서는 다음 섹션에서 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="cd0ac943df3c5c0919c257e9e2ba53e934e28e43" translate="yes" xml:space="preserve">
          <source>Each of these methods may modify the first input argument, except</source>
          <target state="translated">이러한 각 메소드는 첫 번째 입력 인수를 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94636e821462a702e9dcf821156451ce10166f58" translate="yes" xml:space="preserve">
          <source>Each of these methods may modify the first input argument.</source>
          <target state="translated">이러한 각 메소드는 첫 번째 입력 인수를 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fd6321d309f67bf764c8af9cff581fae0812fa5" translate="yes" xml:space="preserve">
          <source>Each of these nodes represents an op, a fundamental operation inside the Perl core. The code which implements each operation can be found in the</source>
          <target state="translated">이러한 각 노드는 Perl 코어 내부의 기본 작업 인 op를 나타냅니다. 각 작업을 구현하는 코드는</target>
        </trans-unit>
        <trans-unit id="33d6b2a3cedc47a8c8496247740303b046f066c7" translate="yes" xml:space="preserve">
          <source>Each of these options is optional; you can include some, all, or none of them.</source>
          <target state="translated">이러한 각 옵션은 선택 사항입니다. 일부를 포함하거나 전혀 포함하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1f0b67ca5c809a794efbf846b5f11a39a783c34" translate="yes" xml:space="preserve">
          <source>Each operand is considered in a modified scalar context, the modification being that array and hash variables are passed by reference to the operator, which implicitly dereferences them. Both elements of each pair are the same:</source>
          <target state="translated">각 피연산자는 수정 된 스칼라 컨텍스트에서 고려되며, 수정은 배열 및 해시 변수가 연산자에 대한 참조로 전달되므로 암시 적으로 역 참조됩니다. 각 쌍의 두 요소는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="76254c26642feac52117b7e65ad2b643499a9d47" translate="yes" xml:space="preserve">
          <source>Each operator has both a terse name (its opname) and a more verbose or recognisable descriptive name. The opdesc function can be used to return a list of descriptions for a list of operators.</source>
          <target state="translated">각 연산자에는 간결한 이름 (opname)과 더 자세하거나 알기 쉬운 설명 이름이 있습니다. opdesc 함수는 연산자 목록에 대한 설명 목록을 리턴하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ffccbf8d7d785427858064bfe414c9a343b8478" translate="yes" xml:space="preserve">
          <source>Each option specifier consists of two parts: the name specification and the argument specification.</source>
          <target state="translated">각 옵션 지정자는 이름 스펙과 인수 스펙의 두 부분으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="49dbe9df44df46422e8ed79c89a972f7e0a049b6" translate="yes" xml:space="preserve">
          <source>Each package contains a special array called &lt;code&gt;@ISA&lt;/code&gt; . The &lt;code&gt;@ISA&lt;/code&gt; array contains a list of that class's parent classes, if any. This array is examined when Perl does method resolution, which we will cover later.</source>
          <target state="translated">각 패키지에는 &lt;code&gt;@ISA&lt;/code&gt; 라는 특수 배열이 포함되어 있습니다 . &lt;code&gt;@ISA&lt;/code&gt; 에 있는 경우 배열은, 그 클래스의 부모 클래스의 목록이 포함되어 있습니다. 이 배열은 Perl이 메소드 분석을 수행 할 때 검토되며, 나중에 다루겠습니다.</target>
        </trans-unit>
        <trans-unit id="fd56746947dceb1b1ebf83666e64df3d893f0573" translate="yes" xml:space="preserve">
          <source>Each pair is an array reference with two elements - namely the</source>
          <target state="translated">각 쌍은 두 가지 요소가있는 배열 참조입니다.</target>
        </trans-unit>
        <trans-unit id="79339b4554cd8ab3b93700df12bacff7c6d9a530" translate="yes" xml:space="preserve">
          <source>Each pathname that is a directory that matches the pattern has a slash appended.</source>
          <target state="translated">패턴과 일치하는 디렉토리 인 각 경로 이름에는 슬래시가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="20b56d27482026f6b453dfe18f7f652ebd744ed0" translate="yes" xml:space="preserve">
          <source>Each plugin should register itself by providing the following structure</source>
          <target state="translated">각 플러그인은 다음 구조를 제공하여 자체적으로 등록해야합니다.</target>
        </trans-unit>
        <trans-unit id="4bc675eeb53212d68aff2215974b513fa9d0ff3e" translate="yes" xml:space="preserve">
          <source>Each programmer will, of course, have his or her own preferences in regards to formatting, but there are some general guidelines that will make your programs easier to read, understand, and maintain.</source>
          <target state="translated">물론 각 프로그래머는 형식과 관련하여 자신의 취향을 갖지만 프로그램을보다 쉽게 ​​읽고 이해하고 유지하는 데 도움이되는 일반적인 지침이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2d7e5e3cbcd85e0f15e433073f3c09c16649807" translate="yes" xml:space="preserve">
          <source>Each pseudo-process maintains its own virtual environment. Modifications to %ENV affect the virtual environment, and are only visible within that pseudo-process, and in any processes (or pseudo-processes) launched from it.</source>
          <target state="translated">각 의사 프로세스는 자체 가상 환경을 유지 관리합니다. % ENV에 대한 수정 사항은 가상 환경에 영향을 미치며 해당 의사 프로세스 및 해당 프로세스에서 시작된 프로세스 (또는 의사 프로세스)에서만 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25a97b930031adadf111787667688ded94505539" translate="yes" xml:space="preserve">
          <source>Each pseudo-process maintains its own virtual idea of the current directory. Modifications to the current directory using chdir() are only visible within that pseudo-process, and in any processes (or pseudo-processes) launched from it. All file and directory accesses from the pseudo-process will correctly map the virtual working directory to the real working directory appropriately.</source>
          <target state="translated">각 의사 프로세스는 현재 디렉토리에 대한 자체 가상 아이디어를 유지합니다. chdir ()을 사용하여 현재 디렉토리에 대한 수정은 해당 의사 프로세스와 해당 프로세스에서 시작된 프로세스 (또는 의사 프로세스)에서만 볼 수 있습니다. 의사 프로세스에서 모든 파일 및 디렉토리 액세스는 가상 작업 디렉토리를 실제 작업 디렉토리에 올바르게 맵핑합니다.</target>
        </trans-unit>
        <trans-unit id="8f4f1268e7fb63f76b0f62897f0f8014b138b792" translate="yes" xml:space="preserve">
          <source>Each result bit is based on the least-significant bit of the corresponding input character, i.e., on &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord($char)%2&lt;/a&gt;&lt;/code&gt;. In particular, characters &lt;code&gt;&quot;0&quot;&lt;/code&gt; and &lt;code&gt;&quot;1&quot;&lt;/code&gt; generate bits 0 and 1, as do characters &lt;code&gt;&quot;\000&quot;&lt;/code&gt; and &lt;code&gt;&quot;\001&quot;&lt;/code&gt; .</source>
          <target state="translated">각 결과 비트는 해당 입력 문자의 최하위 비트, 즉 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord($char)%2&lt;/a&gt;&lt;/code&gt; 합니다. 특히 문자 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;1&quot;&lt;/code&gt; 은 문자 &lt;code&gt;&quot;\000&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;\001&quot;&lt;/code&gt; 과 마찬가지로 비트 0과 1을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="abf39ff7c44d3c8c17f0be2056a001c031f6f08e" translate="yes" xml:space="preserve">
          <source>Each result bit is based on the least-significant bit of the corresponding input character, i.e., on &lt;code&gt;&lt;a href=&quot;ord&quot;&gt;ord($char)%2&lt;/a&gt;&lt;/code&gt;. In particular, characters &lt;code&gt;&quot;0&quot;&lt;/code&gt; and &lt;code&gt;&quot;1&quot;&lt;/code&gt; generate bits 0 and 1, as do characters &lt;code&gt;&quot;\000&quot;&lt;/code&gt; and &lt;code&gt;&quot;\001&quot;&lt;/code&gt; .</source>
          <target state="translated">각 결과 비트는 해당 입력 문자의 최하위 비트, 즉 &lt;code&gt;&lt;a href=&quot;ord&quot;&gt;ord($char)%2&lt;/a&gt;&lt;/code&gt; 합니다. 특히 문자 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;1&quot;&lt;/code&gt; 은 문자 &lt;code&gt;&quot;\000&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;\001&quot;&lt;/code&gt; 과 마찬가지로 비트 0과 1을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="1801d81c7323468b4de78bc480016b6092b96d8e" translate="yes" xml:space="preserve">
          <source>Each result fetched is a result object of a different type. There are common methods to each result object and different types may have methods unique to their type. Sometimes a type method may be overridden in a subclass, but its use is guaranteed to be identical.</source>
          <target state="translated">가져온 각 결과는 다른 유형의 결과 개체입니다. 각 결과 개체에 공통적 인 방법이 있으며 다른 유형에는 해당 유형에 고유 한 방법이있을 수 있습니다. 때때로 서브 클래스에서 타입 메소드가 오버라이드 될 수 있지만 그 사용은 동일하게 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="fca0f4c2c0d0f6d5b588e090e9018c1d20041904" translate="yes" xml:space="preserve">
          <source>Each result returned is a &lt;a href=&quot;parser/result&quot;&gt;TAP::Parser::Result&lt;/a&gt; subclass, referred to as</source>
          <target state="translated">리턴 된 각 결과는 &lt;a href=&quot;parser/result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; 서브 클래스이며</target>
        </trans-unit>
        <trans-unit id="d0a1f92895a8d5d3bca2a476a0ec322b95e7589a" translate="yes" xml:space="preserve">
          <source>Each result returned is a subclass of &lt;a href=&quot;parser/result&quot;&gt;TAP::Parser::Result&lt;/a&gt;. See that module and related classes for more information on how to use them.</source>
          <target state="translated">리턴 된 각 결과는 &lt;a href=&quot;parser/result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; 의 서브 클래스입니다 . 사용 방법에 대한 자세한 내용은 해당 모듈 및 관련 클래스를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8f5ef808a290d77bcb78c1a52baf58c7827e311b" translate="yes" xml:space="preserve">
          <source>Each scalar &lt;code&gt;${&quot;_&amp;lt;$filename&quot;}&lt;/code&gt; contains &lt;code&gt;&quot;_&amp;lt;$filename&quot;&lt;/code&gt; . This is also the case for evaluated strings that contain subroutines, or which are currently being executed. The $filename for &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed strings looks like &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; .</source>
          <target state="translated">각 스칼라 &lt;code&gt;${&quot;_&amp;lt;$filename&quot;}&lt;/code&gt; 에는 &lt;code&gt;&quot;_&amp;lt;$filename&quot;&lt;/code&gt; 있습니다. 서브 루틴을 포함하거나 현재 실행중인 평가 된 문자열의 경우에도 마찬가지입니다. &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 문자열 의 $ filename은 다음과 같습니다 &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b759249474717644d66332dcc04eba32c6b818f" translate="yes" xml:space="preserve">
          <source>Each semaphore has a counter attached to it. By default, semaphores are created with the counter set to one, &lt;code&gt;down()&lt;/code&gt; decrements the counter by one, and &lt;code&gt;up()&lt;/code&gt; increments by one. However, we can override any or all of these defaults simply by passing in different values:</source>
          <target state="translated">각 세마포어에는 카운터가 부착되어 있습니다. 기본적으로 세마포어는 카운터를 1로 설정하여 만들어지며 &lt;code&gt;down()&lt;/code&gt; 은 카운터를 1 씩 줄이고 &lt;code&gt;up()&lt;/code&gt; 은 1 씩 증가합니다. 그러나 단순히 다른 값을 전달하여 이러한 기본값 중 일부 또는 전부를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e3598640cb6381c253bcf070a1e62dc7e9d0823" translate="yes" xml:space="preserve">
          <source>Each step is of the form &lt;code&gt;n &amp;lt;x&amp;gt; &amp;lt;y&amp;gt;&lt;/code&gt;, with &lt;code&gt;&amp;lt;x&amp;gt;&lt;/code&gt; the part of the string matched and &lt;code&gt;&amp;lt;y&amp;gt;&lt;/code&gt; the part not yet matched. The &lt;code&gt;|  1:  STAR&lt;/code&gt; says that Perl is at line number 1 in the compilation list above. See &lt;a href=&quot;perldebguts#Debugging-Regular-Expressions&quot;&gt;Debugging Regular Expressions in perldebguts&lt;/a&gt; for much more detail.</source>
          <target state="translated">각 단계는 &lt;code&gt;n &amp;lt;x&amp;gt; &amp;lt;y&amp;gt;&lt;/code&gt; 이며 &lt;code&gt;&amp;lt;x&amp;gt;&lt;/code&gt; 는 문자열 부분이 일치하고 &lt;code&gt;&amp;lt;y&amp;gt;&lt;/code&gt; 부분은 아직 일치하지 않습니다. &lt;code&gt;| 1: STAR&lt;/code&gt; 는 Perl이 위의 컴파일 목록에서 1 번 라인에 있다고 말합니다. 자세한 내용 &lt;a href=&quot;perldebguts#Debugging-Regular-Expressions&quot;&gt;은 perldebguts에서 정규 표현식 디버깅을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e3defe21495aad5ab5041830fd4fe29198a67142" translate="yes" xml:space="preserve">
          <source>Each time &lt;code&gt;$finder-&amp;gt;next&lt;/code&gt; is called, the iterator returns one of two possible values:</source>
          <target state="translated">&lt;code&gt;$finder-&amp;gt;next&lt;/code&gt; 가 호출 될 때마다 반복자는 두 가지 가능한 값 중 하나를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="54bbe29b947a5618329ec98194ec80f8aabe46b6" translate="yes" xml:space="preserve">
          <source>Each type of section can appear an arbitrary number of times and does not have to appear at all. For example, a typemap may commonly lack &lt;code&gt;INPUT&lt;/code&gt; and &lt;code&gt;OUTPUT&lt;/code&gt; sections if all it needs to do is associate additional C types with core XS types like T_PTROBJ. Lines that start with a hash &lt;code&gt;#&lt;/code&gt; are considered comments and ignored in the &lt;code&gt;TYPEMAP&lt;/code&gt; section, but are considered significant in &lt;code&gt;INPUT&lt;/code&gt; and &lt;code&gt;OUTPUT&lt;/code&gt; . Blank lines are generally ignored.</source>
          <target state="translated">각 섹션 유형은 임의의 횟수로 나타날 수 있으며 전혀 나타나지 않아도됩니다. 예를 들어 타입 맵에 추가 C 유형을 T_PTROBJ와 같은 핵심 XS 유형과 연결하기 만하면 &lt;code&gt;INPUT&lt;/code&gt; 및 &lt;code&gt;OUTPUT&lt;/code&gt; 섹션이 부족할 수 있습니다 . 해시 &lt;code&gt;#&lt;/code&gt; 로 시작하는 행 은 주석으로 간주되고 &lt;code&gt;TYPEMAP&lt;/code&gt; 섹션 에서 무시 되지만 &lt;code&gt;INPUT&lt;/code&gt; 및 &lt;code&gt;OUTPUT&lt;/code&gt; 에서 중요한 것으로 간주됩니다 . 빈 줄은 일반적으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c99826defe1aa3e0e7dfa632ce9b50c12211fd46" translate="yes" xml:space="preserve">
          <source>Each typedef has specific routines that manipulate the various data types.</source>
          <target state="translated">각 typedef에는 다양한 데이터 유형을 조작하는 특정 루틴이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a786e808038f24779f10721b5785e1d471731d02" translate="yes" xml:space="preserve">
          <source>Each value in the results list will be a hash reference containing the following fields:</source>
          <target state="translated">결과 목록의 각 값은 다음 필드를 포함하는 해시 참조입니다.</target>
        </trans-unit>
        <trans-unit id="d6fa3b1f2df46de4d0da0473d7f7df5be8fdd538" translate="yes" xml:space="preserve">
          <source>Each version of Perl comes with the documentation that was current at the time of release. This poses a problem for content such as book lists. There are probably very nice books published after this list was included in your Perl release, and you can check the latest released version at &lt;a href=&quot;http://perldoc.perl.org/perlbook.html&quot;&gt;http://perldoc.perl.org/perlbook.html&lt;/a&gt; .</source>
          <target state="translated">Perl의 각 버전은 출시 당시의 최신 설명서와 함께 제공됩니다. 이것은 책 목록과 같은 내용에 문제가됩니다. 이 목록이 Perl 릴리스에 포함 된 후에 게시 된 훌륭한 책이있을 수 있으며 &lt;a href=&quot;http://perldoc.perl.org/perlbook.html&quot;&gt;http://perldoc.perl.org/perlbook.html&lt;/a&gt; 에서 최신 릴리스 버전을 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a017204ca793ea63195213655418d18b5e46cf36" translate="yes" xml:space="preserve">
          <source>Earlier Mac OS X releases (10.2 &quot;Jaguar&quot; and older) did not include a completely thread-safe libc, so threading is not fully supported. Also, earlier releases included a buggy libdb, so some of the DB_File tests are known to fail on those releases.</source>
          <target state="translated">이전 Mac OS X 릴리스 (10.2 &quot;Jaguar&quot;및 이전 버전)에는 완전히 스레드 안전 libc가 포함되어 있지 않으므로 스레딩이 완전히 지원되지 않습니다. 또한 이전 릴리스에는 버그가있는 libdb가 포함되었으므로 일부 DB_File 테스트는 해당 릴리스에서 실패하는 것으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="a252186ae05a758597f2268019d7fe33e7216333" translate="yes" xml:space="preserve">
          <source>Earlier releases caveats</source>
          <target state="translated">초기 릴리스주의</target>
        </trans-unit>
        <trans-unit id="8144bf937e246b0c3995f39e74e8340a0ff57aa1" translate="yes" xml:space="preserve">
          <source>Earlier than Perl 5.10, you have a bit of work to do. You want to avoid compiling a regular expression every time you want to match it. In this example, perl must recompile the regular expression for every iteration of the &lt;code&gt;foreach&lt;/code&gt; loop since it has no way to know what &lt;code&gt;$pattern&lt;/code&gt; will be:</source>
          <target state="translated">Perl 5.10 이전에는 약간의 작업이 필요합니다. 일치시킬 때마다 정규 표현식을 컴파일하지 않으려 고합니다. 이 예제에서 perl은 &lt;code&gt;$pattern&lt;/code&gt; 이 무엇인지 알 수있는 방법이 없으므로 &lt;code&gt;foreach&lt;/code&gt; 루프 의 모든 반복에 대해 정규식을 다시 컴파일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2412eca1a81df7ff0f1d8fd57bf151a2e60cb6ee" translate="yes" xml:space="preserve">
          <source>Earlier versions of Perl accepted almost all the 6.1 names. These were most extensively documented in the v5.14 version of this pod: &lt;a href=&quot;http://perldoc.perl.org/5.14.0/charnames.html#ALIASES&quot;&gt;http://perldoc.perl.org/5.14.0/charnames.html#ALIASES&lt;/a&gt;.</source>
          <target state="translated">이전 버전의 Perl은 거의 모든 6.1 이름을 허용했습니다. :이 가장 광범위하게이 포드의 v5.14 버전에 설명 된 &lt;a href=&quot;http://perldoc.perl.org/5.14.0/charnames.html#ALIASES&quot;&gt;http://perldoc.perl.org/5.14.0/charnames.html#ALIASES&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="041f750894a2130f024fa1d40c0e0cb8140d53b7" translate="yes" xml:space="preserve">
          <source>Earlier versions of Storable would immediately croak if they encountered a file with a higher internal version number than the reading Storable knew about. Internal version numbers are increased each time new data types (such as restricted hashes) are added to the vocabulary of the file format. This meant that a newer Storable module had no way of writing a file readable by an older Storable, even if the writer didn't store newer data types.</source>
          <target state="translated">Storable이 알고있는 것보다 내부 버전 번호가 높은 파일을 발견 한 경우 Storable의 이전 버전은 즉시 사라집니다. 새로운 데이터 유형 (예 : 제한된 해시)이 파일 형식의 어휘에 추가 될 때마다 내부 버전 번호가 증가합니다. 이것은 새로운 Storable 모듈이 작성기가 새로운 데이터 유형을 저장하지 않더라도 이전 Storable이 읽을 수있는 파일을 작성할 수있는 방법이 없음을 의미했습니다.</target>
        </trans-unit>
        <trans-unit id="641edf650debd12f3350ba77247f6ae399c9cef3" translate="yes" xml:space="preserve">
          <source>Earlier, we mentioned that the &lt;code&gt;File&lt;/code&gt; class's &lt;code&gt;last_mod_time&lt;/code&gt; accessor could return a &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; object. This is a perfect example of composition. We could go even further, and make the &lt;code&gt;path&lt;/code&gt; and &lt;code&gt;content&lt;/code&gt; accessors return objects as well. The &lt;code&gt;File&lt;/code&gt; class would then be &lt;b&gt;composed&lt;/b&gt; of several other objects.</source>
          <target state="translated">앞서 &lt;code&gt;File&lt;/code&gt; 클래스의 &lt;code&gt;last_mod_time&lt;/code&gt; 접근자가 &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; 객체를 반환 할 수 있다고 언급했습니다 . 이것은 구성의 완벽한 예입니다. 더 나아가서 &lt;code&gt;path&lt;/code&gt; 와 &lt;code&gt;content&lt;/code&gt; 접근자가 객체를 반환하도록 할 수 있습니다. &lt;code&gt;File&lt;/code&gt; 클래스는 다음 될 &lt;b&gt;구성&lt;/b&gt; 여러 가지 다른 개체로.</target>
        </trans-unit>
        <trans-unit id="1e2d95ddabd105e29656829184c35d2859c555dc" translate="yes" xml:space="preserve">
          <source>Early Perl versions worked on some EBCDIC machines, but the last known version that ran on EBCDIC was v5.8.7, until v5.22, when the Perl core again works on z/OS. Theoretically, it could work on OS/400 or Siemens' BS2000 (or their successors), but this is untested. In v5.22, not all the modules found on CPAN but shipped with core Perl work on z/OS.</source>
          <target state="translated">초기 Perl 버전은 일부 EBCDIC 시스템에서 작동했지만 EBCDIC에서 실행 된 마지막으로 알려진 버전은 Perl 코어가 z / OS에서 다시 작동 할 때 v5.22까지 v5.8.7입니다. 이론적으로 OS / 400 또는 Siemens의 BS2000 (또는 그 후속 제품)에서 작동 할 수 있지만 이것은 테스트되지 않았습니다. v5.22에서 CPAN에있는 모든 모듈은 아니지만 z / OS에서 핵심 Perl과 함께 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="59b164194e7edb2e85034e9b78794d560a716b37" translate="yes" xml:space="preserve">
          <source>Ease testing test modules built with Test::Builder</source>
          <target state="translated">Test :: Builder로 빌드 한 테스트 테스트 모듈 용이성</target>
        </trans-unit>
        <trans-unit id="7a188f6f02161d17a281a3ef192ea2346304b188" translate="yes" xml:space="preserve">
          <source>Easily interact with CPAN from the command line</source>
          <target state="translated">명령 줄에서 CPAN과 쉽게 상호 작용</target>
        </trans-unit>
        <trans-unit id="995f14f2d2d8a63a7a9da7579e9e95a2acf52319" translate="yes" xml:space="preserve">
          <source>Ed Avis</source>
          <target state="translated">에드 에비스</target>
        </trans-unit>
        <trans-unit id="528c45b93e145146f93473cbaa4675f9b54b16c1" translate="yes" xml:space="preserve">
          <source>Edgar &quot;Trizor&quot; Bering &amp;lt;trizor@gmail.com&amp;gt;</source>
          <target state="translated">Edgar &quot;Trizor&quot;Bering &amp;lt;trizor@gmail.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e76b3763dae70623eb55885995406de6279fdb6e" translate="yes" xml:space="preserve">
          <source>Edit the Makefile.PL file so that the corresponding line looks like this:</source>
          <target state="translated">해당 줄이 다음과 같이되도록 Makefile.PL 파일을 편집하십시오.</target>
        </trans-unit>
        <trans-unit id="f7940347fff54108cd46081728a5cf85408a717b" translate="yes" xml:space="preserve">
          <source>Edit the files generated. You don't have to if you have no time AND no intention to give it to someone else. But it is a good idea to edit the pod and to add more tests.</source>
          <target state="translated">생성 된 파일을 편집하십시오. 시간이없고 다른 사람에게 줄 의사가 없다면 할 필요가 없습니다. 그러나 포드를 편집하고 더 많은 테스트를 추가하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="954ea018e0a987091c4440d55ba64f48e0cccfe8" translate="yes" xml:space="preserve">
          <source>Edit the makefile.mk (or Makefile, if you're using nmake) and change the values of INST_DRV and INST_TOP. You can also enable various build flags. These are explained in the makefiles.</source>
          <target state="translated">makefile.mk (또는 nmake를 사용하는 경우 Makefile)를 편집하고 INST_DRV 및 INST_TOP의 값을 변경하십시오. 다양한 빌드 플래그를 활성화 할 수도 있습니다. 이것들은 makefile에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b93bb818c85552f3fcd19e172c258ef9c6aad22d" translate="yes" xml:space="preserve">
          <source>Editor Support for Debugging</source>
          <target state="translated">디버깅을위한 에디터 지원</target>
        </trans-unit>
        <trans-unit id="68575b9eb0c3bb98d30a72178c5ff21f9fae81f0" translate="yes" xml:space="preserve">
          <source>Editor to use.</source>
          <target state="translated">사용할 편집기.</target>
        </trans-unit>
        <trans-unit id="77cd7c3d29d911531fb7afe572b99c8c5ba4e8b7" translate="yes" xml:space="preserve">
          <source>Editorial adjustments by Gurusamy Sarathy &amp;lt;gsar@ActiveState.com&amp;gt;</source>
          <target state="translated">Gurusamy Sarathy &amp;lt;gsar@ActiveState.com&amp;gt;의 편집 조정</target>
        </trans-unit>
        <trans-unit id="73be54c86084c8c273a09c1c9821e5a9131296dd" translate="yes" xml:space="preserve">
          <source>Effect:</source>
          <target state="translated">Effect:</target>
        </trans-unit>
        <trans-unit id="8b7ac9002bbe557a0e89e8f9ac76410e740b68c3" translate="yes" xml:space="preserve">
          <source>Efficient removal of characters from the beginning of the string buffer. SvPOK(sv), or at least SvPOKp(sv), must be true and the &lt;code&gt;ptr&lt;/code&gt; must be a pointer to somewhere inside the string buffer. The &lt;code&gt;ptr&lt;/code&gt; becomes the first character of the adjusted string. Uses the &quot;OOK hack&quot;. On return, only SvPOK(sv) and SvPOKp(sv) among the OK flags will be true.</source>
          <target state="translated">문자열 버퍼의 시작 부분에서 문자를 효율적으로 제거합니다. SvPOK (sv) 또는 최소한 SvPOKp (sv)는 true 여야하며 &lt;code&gt;ptr&lt;/code&gt; 은 문자열 버퍼 내부의 포인터 여야합니다. &lt;code&gt;ptr&lt;/code&gt; 조정 된 문자열의 첫 번째 문자가됩니다. &quot;OOK 핵&quot;을 사용합니다. 돌아 왔을 때, OK 플래그 중 SvPOK (sv) 및 SvPOKp (sv)만이 참이됩니다.</target>
        </trans-unit>
        <trans-unit id="f18b25f084ce81b950168aedca18f94cb1425062" translate="yes" xml:space="preserve">
          <source>Efficiently compute time from local and GMT time</source>
          <target state="translated">로컬 및 GMT 시간에서 시간을 효율적으로 계산</target>
        </trans-unit>
        <trans-unit id="654f6a3bdd1d9e4bdcf155781a2de9b4ed80c132" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;IO::String&lt;/code&gt; or &lt;code&gt;perlio&lt;/code&gt; support is needed to support writing stringified archives. Currently, &lt;code&gt;perlio&lt;/code&gt; is the preferred method, if available.</source>
          <target state="translated">어느 &lt;code&gt;IO::String&lt;/code&gt; 또는 &lt;code&gt;perlio&lt;/code&gt; 지원도 캐릭터 라인 아카이브를 작성 지원하기 위해 필요합니다. 현재 가능한 경우 &lt;code&gt;perlio&lt;/code&gt; 가 선호되는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="85dba161f5ca6a960a7dc8fa1039724a8c09cad4" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;\g&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; (starting in Perl 5.10.0), or &lt;code&gt;\&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; (old-style) where</source>
          <target state="translated">어느 &lt;code&gt;\g&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; , 또는 (펄 5.10.0부터) &lt;code&gt;\&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; (구식)</target>
        </trans-unit>
        <trans-unit id="cb02a27773229541ab59b1944bd46b1d5a6ebed2" translate="yes" xml:space="preserve">
          <source>Either a regular &lt;b&gt;assignment&lt;/b&gt; or a compound &lt;b&gt;operator&lt;/b&gt; composed of an ordinary assignment and some other operator, that changes the value of a variable in place; that is, relative to its old value. For example, &lt;code&gt;$a += 2&lt;/code&gt; adds &lt;code&gt;2&lt;/code&gt; to &lt;code&gt;$a&lt;/code&gt; .</source>
          <target state="translated">정규 &lt;b&gt;할당&lt;/b&gt; 또는 일반 할당과 일부 다른 연산자로 구성된 복합 &lt;b&gt;연산자&lt;/b&gt; 로 변수의 값을 적절하게 변경합니다. 즉, 이전 값과 관련이 있습니다. 예를 들어 &lt;code&gt;$a += 2&lt;/code&gt; 는 &lt;code&gt;2&lt;/code&gt; 를 &lt;code&gt;$a&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="281cd0fa078fd4c1ba948d728426cec878f64c16" translate="yes" xml:space="preserve">
          <source>Either assimilate new technologies, or build bridges to them.</source>
          <target state="translated">새로운 기술을 동화 시키거나 그들과의 가교를 구축하십시오.</target>
        </trans-unit>
        <trans-unit id="66b1d548fa9375ac8cee4b6bb3288cae52feda67" translate="yes" xml:space="preserve">
          <source>Either not implemented or a no-op. (Android)</source>
          <target state="translated">구현되지 않았거나 작동하지 않습니다. (기계적 인조 인간)</target>
        </trans-unit>
        <trans-unit id="c47f17b2cb7b7674bb2cbd89473a3cd6f362bf48" translate="yes" xml:space="preserve">
          <source>Either of the following will work instead:</source>
          <target state="translated">대신 다음 중 하나가 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e5a6a14049fff21a602c284699a2c9fbe3ca6693" translate="yes" xml:space="preserve">
          <source>Either single-quote your strings, or (preferably) use forward slashes. Since all DOS and Windows versions since something like MS-DOS 2.0 or so have treated &lt;code&gt;/&lt;/code&gt; and &lt;code&gt;\&lt;/code&gt; the same in a path, you might as well use the one that doesn't clash with Perl--or the POSIX shell, ANSI C and C++, awk, Tcl, Java, or Python, just to mention a few. POSIX paths are more portable, too.</source>
          <target state="translated">문자열을 작은 따옴표로 묶거나 슬래시를 사용하십시오. 모든 DOS 및 Windows 버전은 MS-DOS 2.0과 같이 경로에서 &lt;code&gt;/&lt;/code&gt; 및 &lt;code&gt;\&lt;/code&gt; 를 동일하게 취급하므로 Perl과 충돌하지 않는 버전 또는 POSIX 셸, ANSI C 및 C ++, awk, Tcl, Java 또는 Python 중 일부만 언급하면됩니다. POSIX 경로도 이식성이 뛰어납니다.</target>
        </trans-unit>
        <trans-unit id="a48425d47cea1024da1aa0b5eb56b9a2e8f4b87c" translate="yes" xml:space="preserve">
          <source>Either stringify the structure yourself (no fun), or else get the MLDBM (which uses Data::Dumper) module from CPAN and layer it on top of either DB_File or GDBM_File. You might also try DBM::Deep, but it can be a bit slow.</source>
          <target state="translated">구조를 직접 문자열로 지정하거나 (재미 없음) CPAN에서 MLDBM (Data :: Dumper를 사용하는) 모듈을 가져 와서 DB_File 또는 GDBM_File 위에 계층화하십시오. DBM :: Deep을 사용해 볼 수도 있지만 약간 느릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f91179ba5041e3cd11279b2a09e8c8dafe42d600" translate="yes" xml:space="preserve">
          <source>Either the 5.006001 or the 5.6.1 format is acceptable.</source>
          <target state="translated">5.006001 또는 5.6.1 형식 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3046bc2658fc9703b653ff4f645f1c7f4b09d3a" translate="yes" xml:space="preserve">
          <source>Either the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; flag will warn you when you use an array slice with a single index.</source>
          <target state="translated">중 하나를 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 프라그 또는 &lt;b&gt;-w&lt;/b&gt; 단일 인덱스 배열 슬라이스를 사용할 때 플래그는 경고합니다.</target>
        </trans-unit>
        <trans-unit id="906b6fd14fb2f43afa53be4e9384438767144648" translate="yes" xml:space="preserve">
          <source>Either the &lt;code&gt;warnings::warn&lt;/code&gt; or &lt;code&gt;warnings::warnif&lt;/code&gt; function should be used to actually display the warnings message. This is because they can make use of the feature that allows warnings to be escalated into fatal errors. So in this case</source>
          <target state="translated">중 하나를 &lt;code&gt;warnings::warn&lt;/code&gt; 또는 &lt;code&gt;warnings::warnif&lt;/code&gt; 기능은 실제로 경고 메시지를 표시하는 데 사용되어야한다. 경고를 치명적인 오류로 에스컬레이션 할 수있는 기능을 사용할 수 있기 때문입니다. 따라서이 경우</target>
        </trans-unit>
        <trans-unit id="0780376e7962816fa4ff7b6a652f65ef6eadb7db" translate="yes" xml:space="preserve">
          <source>Either use parentheses or the high-precedence variant of the operator.</source>
          <target state="translated">괄호 나 우선 순위가 높은 연산자를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a6479b4a431808cf309ed8137f781bb957df27d9" translate="yes" xml:space="preserve">
          <source>Either you don't have more than one line in the string you're looking at (probably), or else you aren't using the correct modifier(s) on your pattern (possibly).</source>
          <target state="translated">찾고있는 문자열에 둘 이상의 줄이 없거나 (아마도) 패턴에 올바른 수정자를 사용하고 있지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e45775ed8dae80c63b3497b4ea826a44ca2dea3f" translate="yes" xml:space="preserve">
          <source>Elapsed returns a &lt;a href=&quot;../../benchmark&quot;&gt;Benchmark&lt;/a&gt; object that represents the running time of the aggregated tests. In order for &lt;code&gt;elapsed&lt;/code&gt; to be valid you must call &lt;code&gt;start&lt;/code&gt; before running the tests and &lt;code&gt;stop&lt;/code&gt; immediately afterwards.</source>
          <target state="translated">경과는 집계 된 테스트의 실행 시간을 나타내는 &lt;a href=&quot;../../benchmark&quot;&gt;벤치 마크&lt;/a&gt; 객체를 반환합니다 . 위해에 대한 &lt;code&gt;elapsed&lt;/code&gt; 하면 호출해야 유효한 것으로 &lt;code&gt;start&lt;/code&gt; 테스트를 실행하기 전에 및 &lt;code&gt;stop&lt;/code&gt; 후 즉시.</target>
        </trans-unit>
        <trans-unit id="685684a16f4001786549b1ab800e18b9d9c7dce4" translate="yes" xml:space="preserve">
          <source>Electronic mail address of the perl5 administrator.</source>
          <target state="translated">perl5 관리자의 전자 우편 주소</target>
        </trans-unit>
        <trans-unit id="0206d29187ee24de18ffe8c7060208c783959fc1" translate="yes" xml:space="preserve">
          <source>Electronic mail address of the person who ran Configure. This can be used by units that require the user's e-mail, like</source>
          <target state="translated">Configure를 실행 한 사람의 전자 메일 주소입니다. 이것은 사용자의 이메일을 요구하는 장치에서 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb92ce1ec6eee388978bf1476ef4da0f49ddc2f4" translate="yes" xml:space="preserve">
          <source>Element Types and Accessor Methods</source>
          <target state="translated">요소 유형 및 접근 자 방법</target>
        </trans-unit>
        <trans-unit id="56be9d95047d3837a8e260ecf6fab5aa5091179f" translate="yes" xml:space="preserve">
          <source>Eliminate the macros in the output to the MMS/MMK file.</source>
          <target state="translated">출력에서 매크로를 MMS / MMK 파일로 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="372fe5af53dfb10b96df623d9727deb1110a3dd2" translate="yes" xml:space="preserve">
          <source>Email any corrections or questions to me.</source>
          <target state="translated">수정 사항이나 질문이 있으면 나에게 이메일을 보내십시오.</target>
        </trans-unit>
        <trans-unit id="a5bcdc422fa0c0f86b08b10ed2c448b54076951e" translate="yes" xml:space="preserve">
          <source>Embedded Code Execution Frequency</source>
          <target state="translated">임베디드 코드 실행 빈도</target>
        </trans-unit>
        <trans-unit id="1c0d431f261d9feabca2f4bf0f5d2be5226959da" translate="yes" xml:space="preserve">
          <source>Embedded Ctrl-As (octal 001) in the input will be mapped to spaces on output, due to an internal implementation detail.</source>
          <target state="translated">입력에 내장 된 Ctrl-A (8 진수 001)는 내부 구현 세부 사항으로 인해 출력의 공백에 맵핑됩니다.</target>
        </trans-unit>
        <trans-unit id="036d707633278129886b9180244ca67da739555e" translate="yes" xml:space="preserve">
          <source>Embedded modifiers can also turn off any modifiers already present by using, e.g., &lt;code&gt;(?-i)&lt;/code&gt;. Modifiers can also be combined into a single expression, e.g., &lt;code&gt;(?s-i)&lt;/code&gt; turns on single line mode and turns off case insensitivity.</source>
          <target state="translated">임베디드 수정자는 또한 예를 들어 &lt;code&gt;(?-i)&lt;/code&gt; 를 사용하여 이미 존재하는 수정자를 끌 수 있습니다 . 수정자를 단일 표현으로 결합 할 수도 있습니다. 예를 들어 &lt;code&gt;(?s-i)&lt;/code&gt; 는 단일 회선 모드를 켜고 대소 문자 구분을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="7b8b1388248a7771ad7a19db052c3e57cdc37002" translate="yes" xml:space="preserve">
          <source>Embedded modifiers can have two important advantages over the usual modifiers. Embedded modifiers allow a custom set of modifiers to</source>
          <target state="translated">임베디드 수정자는 일반적인 수정 자보다 두 가지 중요한 장점을 가질 수 있습니다. 내장 된 수정자는 사용자 정의 수정 자 세트를</target>
        </trans-unit>
        <trans-unit id="77fff13bcd07ad216d2d3e4a9dc81f2e17688911" translate="yes" xml:space="preserve">
          <source>Embedded modifiers may also be added to a non-capturing grouping. &lt;code&gt;(?i-m:regexp)&lt;/code&gt; is a non-capturing grouping that matches &lt;code&gt;regexp&lt;/code&gt; case insensitively and turns off multi-line mode.</source>
          <target state="translated">임베디드 수정자는 캡처하지 않는 그룹화에 추가 될 수도 있습니다. &lt;code&gt;(?i-m:regexp)&lt;/code&gt; 는 &lt;code&gt;regexp&lt;/code&gt; / 소문자를 구분하지 않고 캡처하는 다중 캡처 그룹으로, 다중 회선 모드를 끕니다.</target>
        </trans-unit>
        <trans-unit id="b92d8665944f4979bd50de8585ed3b0fd45dfa5f" translate="yes" xml:space="preserve">
          <source>Embedding Functions</source>
          <target state="translated">임베드 기능</target>
        </trans-unit>
        <trans-unit id="dfab320700daa38157038d3e70e9093fcfa26c1f" translate="yes" xml:space="preserve">
          <source>Embedding Perl inside a 64-bit application.</source>
          <target state="translated">64 비트 응용 프로그램에 Perl을 포함시킵니다.</target>
        </trans-unit>
        <trans-unit id="0694b8bb0407da0c117f25cc81dd5d48908ff82d" translate="yes" xml:space="preserve">
          <source>Embedding Perl under Win32</source>
          <target state="translated">Win32 아래에 Perl 임베딩</target>
        </trans-unit>
        <trans-unit id="9cbcae97b606ebda37a4c9c0051aab393c7f7d13" translate="yes" xml:space="preserve">
          <source>Embedding Pods in Perl Modules</source>
          <target state="translated">Perl 모듈에 포드 내장</target>
        </trans-unit>
        <trans-unit id="3332088412158a65b80fc73f2172f27d8031dce4" translate="yes" xml:space="preserve">
          <source>Embedding comments and modifiers in a regular expression</source>
          <target state="translated">정규 표현식에 주석 및 수정 자 임베드</target>
        </trans-unit>
        <trans-unit id="abbe29d0eda029ba0d774099d16a176aaf760777" translate="yes" xml:space="preserve">
          <source>Empty parts of the file/buffer will have NULL (0x00) bytes written to them.</source>
          <target state="translated">파일 / 버퍼의 빈 부분에는 NULL (0x00) 바이트가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="bd4ef1b6c1ef24f987c292a748ebade1052ce4dc" translate="yes" xml:space="preserve">
          <source>Empty strings as well as other illegal numbers results in 'NaN'.</source>
          <target state="translated">빈 문자열과 기타 잘못된 숫자는 'NaN'이됩니다.</target>
        </trans-unit>
        <trans-unit id="b78fcf2b7184ff747f91ac2d4e85304d73a66a8f" translate="yes" xml:space="preserve">
          <source>Emptying a file of existing contents, either automatically when opening a file for writing or explicitly via the &lt;code&gt;&lt;a href=&quot;functions/truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">쓰기 위해 파일을 열 때 자동으로 또는 &lt;code&gt;&lt;a href=&quot;functions/truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt; 기능을 통해 명시 적으로 기존 내용의 파일 비우기 .</target>
        </trans-unit>
        <trans-unit id="a3810839f51735c2952e4638769a72e1f188779e" translate="yes" xml:space="preserve">
          <source>Emulate low-level math with BigInt code</source>
          <target state="translated">BigInt 코드로 저수준 수학 에뮬레이션</target>
        </trans-unit>
        <trans-unit id="eaff5ce9fb66a8294a29b4afda7fa93b8fb7b74b" translate="yes" xml:space="preserve">
          <source>Emulated using multiple interpreters. See &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt;. (Win32)</source>
          <target state="translated">여러 통역사를 사용하여 에뮬레이트합니다. &lt;a href=&quot;perlfork&quot;&gt;perlfork를&lt;/a&gt; 참조하십시오 . (Win32)</target>
        </trans-unit>
        <trans-unit id="a7b07a2e86e21bbe02318bb5339e9e3819d02d9c" translate="yes" xml:space="preserve">
          <source>Emulated using synchronization functions such that it can be interrupted by &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt;, and limited to a maximum of 4294967 seconds, approximately 49 days. (Win32)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; 의해 중단 될 수 있고 대략 42 일로 최대 4294967 초로 제한 될 수 있도록 동기화 함수를 사용하여 에뮬레이트 됩니다. (Win32)</target>
        </trans-unit>
        <trans-unit id="2fab2548b326a0aed3bd44319bab854e6c0cf455" translate="yes" xml:space="preserve">
          <source>Emulated using timers that must be explicitly polled whenever Perl wants to dispatch &quot;safe signals&quot; and therefore cannot interrupt blocking system calls. (Win32)</source>
          <target state="translated">Perl이 &quot;안전한 신호&quot;를 보내려고 할 때마다 명시 적으로 폴링해야하는 타이머를 사용하여 에뮬레이트되므로 시스템 호출 차단을 방해 할 수 없습니다. (Win32)</target>
        </trans-unit>
        <trans-unit id="9b1e45abf8f6f88976507fbf984db8d99aa517be" translate="yes" xml:space="preserve">
          <source>Emulates Unix &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; (which considers &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt; 1&lt;/code&gt; to indicate an error) by mapping the &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;SS$_ABORT&lt;/code&gt; (&lt;code&gt;44&lt;/code&gt; ). This behavior may be overridden with the pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'exit'&lt;/code&gt; . As with the CRTL's &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; function, &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt; 0&lt;/code&gt; is also mapped to an exit status of &lt;code&gt;SS$_NORMAL&lt;/code&gt; (&lt;code&gt;1&lt;/code&gt; ); this mapping cannot be overridden. Any other argument to &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; is used directly as Perl's exit status. On VMS, unless the future POSIX_EXIT mode is enabled, the exit code should always be a valid VMS exit code and not a generic number. When the POSIX_EXIT mode is enabled, a generic number will be encoded in a method compatible with the C library _POSIX_EXIT macro so that it can be decoded by other programs, particularly ones written in C, like the GNV package. (VMS)</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; 을 &lt;code&gt;SS$_ABORT&lt;/code&gt; ( &lt;code&gt;44&lt;/code&gt; ) 에 매핑하여 Unix &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 에뮬레이트합니다 ( &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt; 1&lt;/code&gt; 을 고려 하여 오류를 나타냄 ). 이 동작은 pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'exit'&lt;/code&gt; vmsish 'exit' 로 재정의 될 수 있습니다 . CRTL의 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 함수 와 마찬가지로 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt; 0&lt;/code&gt; 0 도 종료 상태 &lt;code&gt;SS$_NORMAL&lt;/code&gt; ( &lt;code&gt;1&lt;/code&gt; )에 매핑됩니다 . 이 매핑은 재정의 할 수 없습니다. &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 다른 인수Perl의 종료 상태로 직접 사용됩니다. VMS에서 향후 POSIX_EXIT 모드를 사용하지 않으면 종료 코드는 항상 일반 번호가 아닌 유효한 VMS 종료 코드 여야합니다. POSIX_EXIT 모드가 활성화되면 일반 번호는 C 라이브러리 _POSIX_EXIT 매크로와 호환되는 방법으로 인코딩되어 다른 프로그램, 특히 GNV 패키지와 같이 C로 작성된 프로그램에서 디코딩 될 수 있습니다. (VMS)</target>
        </trans-unit>
        <trans-unit id="a8694061aed01e45167cf3a5722aa921d3e6ee71" translate="yes" xml:space="preserve">
          <source>Emulation is provided for &lt;code&gt;runtests&lt;/code&gt; and &lt;code&gt;execute_tests&lt;/code&gt; but the pluggable 'Straps' interface that previous versions of &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; supported is not reproduced here. Straps is now available as a stand alone module: &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::Straps&quot;&gt;Test::Harness::Straps&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;runtests&lt;/code&gt; 및 &lt;code&gt;execute_tests&lt;/code&gt; 에뮬레이션이 제공 되지만 이전 버전의 &lt;a href=&quot;harness&quot;&gt;Test :: Harness가&lt;/a&gt; 지원 하는 플러그 가능 '스트랩'인터페이스 는 여기에서 재현되지 않습니다. 스트랩은 이제 독립형 모듈로 제공됩니다 : &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::Straps&quot;&gt;Test :: Harness :: Straps&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0c3201c23058080f5cca7ba534770368c083d322" translate="yes" xml:space="preserve">
          <source>Enable DUMP and all execute options. Equivalent to:</source>
          <target state="translated">DUMP 및 모든 실행 옵션을 활성화하십시오. 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7bb7295d3b950c4331c9fe377d6496cd34ea08ee" translate="yes" xml:space="preserve">
          <source>Enable all options at once except OFFSETS, OFFSETSDBG and BUFFERS. (To get every single option without exception, use both ALL and EXTRA.)</source>
          <target state="translated">OFFSETS, OFFSETSDBG 및 BUFFERS를 제외한 모든 옵션을 한 번에 활성화하십시오. (예외없이 모든 단일 옵션을 얻으려면 ALL과 EXTRA를 모두 사용하십시오.)</target>
        </trans-unit>
        <trans-unit id="7c54f50dbe8b1d2b9d4279a847b1af1e242ac5db" translate="yes" xml:space="preserve">
          <source>Enable caching of timings for the null loop. The time taken for COUNT rounds of the null loop will be calculated only once for each different COUNT used.</source>
          <target state="translated">널 루프에 대한 타이밍 캐싱을 사용 가능하게하십시오. null 루프의 COUNT 라운드에 걸리는 시간은 사용 된 다른 COUNT마다 한 번 씩만 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="af34a92294247e0324cf9cb4ab7591c0157d3cc4" translate="yes" xml:space="preserve">
          <source>Enable debugging of offsets information. This emits copious amounts of trace information and doesn't mesh well with other debug options.</source>
          <target state="translated">오프셋 정보의 디버깅을 활성화합니다. 이것은 많은 양의 추적 정보를 방출하며 다른 디버그 옵션과 잘 맞지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b22eafe66ff9363c232181834545b3e27fc24dda" translate="yes" xml:space="preserve">
          <source>Enable debugging of start-point optimisations.</source>
          <target state="translated">시작점 최적화 디버깅을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="b1ed4094a3f33fb70b77d3ab5d3985c70cad2408" translate="yes" xml:space="preserve">
          <source>Enable debugging of states in the engine.</source>
          <target state="translated">엔진에서 상태 디버깅을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="6cc2f783a9f51a88860f66f38bb6654412ccd3b7" translate="yes" xml:space="preserve">
          <source>Enable debugging of the \G modifier.</source>
          <target state="translated">\ G 수정 자의 디버깅을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="8b1fc985774fbcf866da54c3c69b513cb35f440c" translate="yes" xml:space="preserve">
          <source>Enable debugging of the recursion stack in the engine. Enabling or disabling this option automatically does the same for debugging states as well. This output from this can be quite large.</source>
          <target state="translated">엔진에서 재귀 스택의 디버깅을 활성화합니다. 이 옵션을 활성화하거나 비활성화하면 디버깅 상태에서도 자동으로 동일하게 수행됩니다. 이 결과는 상당히 클 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed7bfb6f5b63e62332ddfc6bbbaf1f7a2a0d576b" translate="yes" xml:space="preserve">
          <source>Enable debugging output.</source>
          <target state="translated">디버깅 출력을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="139048524bc56f6e0f7692e0183c038f5bfd94d8" translate="yes" xml:space="preserve">
          <source>Enable debugging the capture group storage during match. Warning, this can potentially produce extremely large output.</source>
          <target state="translated">일치하는 동안 캡처 그룹 스토리지 디버깅을 사용하십시오. 경고, 이것은 잠재적으로 매우 큰 출력을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d009cb1e8dd02879690564369c53161c26ba761e" translate="yes" xml:space="preserve">
          <source>Enable enhanced TRIE debugging. Enhances both TRIEE and TRIEC.</source>
          <target state="translated">향상된 TRIE 디버깅을 활성화하십시오. TRIEE와 TRIEC을 모두 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="ef5eb4e7b2447bf19044b39ea2e195cd6618fd76" translate="yes" xml:space="preserve">
          <source>Enable enhanced optimisation debugging and start-point optimisations. Probably not useful except when debugging the regexp engine itself.</source>
          <target state="translated">향상된 최적화 디버깅 및 시작점 최적화를 가능하게합니다. 정규식 엔진 자체를 디버깅하는 경우를 제외하고는 유용하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07e248f2e2b8869e02ee4bbd9a3b445fa1e02104" translate="yes" xml:space="preserve">
          <source>Enable new features</source>
          <target state="translated">새로운 기능 사용</target>
        </trans-unit>
        <trans-unit id="82441ac52d9ab4a30896d0bdffedf2a9be220d10" translate="yes" xml:space="preserve">
          <source>Enable recognition of &lt;code&gt;IN&lt;/code&gt; , &lt;code&gt;OUT_LIST&lt;/code&gt; and &lt;code&gt;INOUT_LIST&lt;/code&gt; declarations. Default is true.</source>
          <target state="translated">&lt;code&gt;IN&lt;/code&gt; , &lt;code&gt;OUT_LIST&lt;/code&gt; 및 &lt;code&gt;INOUT_LIST&lt;/code&gt; 선언을 인식 할 수 있습니다. 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="a04f3ebaeb9867e3812b1e018ab387d5924f7ef6" translate="yes" xml:space="preserve">
          <source>Enable recognition of ANSI-like descriptions of function signature. Default is true.</source>
          <target state="translated">함수 서명에 대한 ANSI와 같은 설명을 인식 할 수 있습니다. 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="8fa85b7034e330ca755a5c73c63b76397e087c71" translate="yes" xml:space="preserve">
          <source>Enable simple signal handling</source>
          <target state="translated">간단한 신호 처리 가능</target>
        </trans-unit>
        <trans-unit id="3c3a9e686f47a71d2d2bd49c91054de061662284" translate="yes" xml:space="preserve">
          <source>Enable the breakpoint so it will stop the execution of the program.</source>
          <target state="translated">중단 점을 활성화하여 프로그램 실행을 중지하십시오.</target>
        </trans-unit>
        <trans-unit id="dcd4f88c7522d41d4cd111539c1b1db699d331e1" translate="yes" xml:space="preserve">
          <source>Enable the options enabled by &quot;All&quot;, plus STATE, TRIEC, and TRIEM.</source>
          <target state="translated">&quot;모두&quot;와 STATE, TRIEC 및 TRIEM으로 활성화 된 옵션을 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="6607ef3ad5faa3d582896ad07ab9785dae90ca8e" translate="yes" xml:space="preserve">
          <source>Enable this option if you wish all spawned processes to be killed if the initially spawned process (the parent) is killed or dies without waiting for child processes.</source>
          <target state="translated">처음 생성 된 프로세스 (부모)가 자식 프로세스를 기다리지 않고 종료되거나 종료 된 경우 생성 된 모든 프로세스를 종료하려면이 옵션을 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="b7b7c90b9b4e4815dd4d9b7ad285d70eda8ebb7d" translate="yes" xml:space="preserve">
          <source>Enable/disable UTF-8 (or UTF-EBCDIC) in source code</source>
          <target state="translated">소스 코드에서 UTF-8 (또는 UTF-EBCDIC) 활성화 / 비활성화</target>
        </trans-unit>
        <trans-unit id="80acee2f67ff4da70c6002b5a0e094b4d2f31c43" translate="yes" xml:space="preserve">
          <source>Enables all warnings regardless of &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings&lt;/code&gt; or &lt;code&gt;$^W&lt;/code&gt; . See &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">에 관계없이 모든 경고 가능 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings&lt;/code&gt; 또는 &lt;code&gt;$^W&lt;/code&gt; . &lt;a href=&quot;warnings&quot;&gt;경고를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1089d1ea88536805f57559da91fba3d7a2761ecb" translate="yes" xml:space="preserve">
          <source>Enables certain optimizations. The only optimization that is currently affected is the use of</source>
          <target state="translated">특정 최적화를 가능하게합니다. 현재 영향을받는 유일한 최적화 방법은</target>
        </trans-unit>
        <trans-unit id="c2846984fdcc8df09665bcc109bb5474af315f7d" translate="yes" xml:space="preserve">
          <source>Enables or disable debugging by setting the &lt;code&gt;$Benchmark::Debug&lt;/code&gt; flag:</source>
          <target state="translated">&lt;code&gt;$Benchmark::Debug&lt;/code&gt; 플래그 를 설정하여 디버깅을 활성화하거나 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="9d480a633ce9bb7aa941c3d98a4cbb4d5ac2bf6a" translate="yes" xml:space="preserve">
          <source>Enables output related to the optimisation phase of compilation.</source>
          <target state="translated">컴파일의 최적화 단계와 관련된 출력을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="e55c00ee236233e66b2d47bad2c1ced81c03c99b" translate="yes" xml:space="preserve">
          <source>Enabling &lt;code&gt;bundling_values&lt;/code&gt; will disable the other two styles of bundling.</source>
          <target state="translated">사용 &lt;code&gt;bundling_values&lt;/code&gt; 는 번들의 다른 두 가지 스타일을 사용할 수 없게됩니다.</target>
        </trans-unit>
        <trans-unit id="b18f32d5490f57e3f4e0f875c588a069b00f5590" translate="yes" xml:space="preserve">
          <source>Enabling the &lt;code&gt;utf8&lt;/code&gt; pragma has the following effect:</source>
          <target state="translated">&lt;code&gt;utf8&lt;/code&gt; pragma를 활성화하면 다음과 같은 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fe2071dd005ed63dfae111e383f15806253aa16" translate="yes" xml:space="preserve">
          <source>Enabling this option will allow single-character options to be bundled. To distinguish bundles from long option names, long options</source>
          <target state="translated">이 옵션을 활성화하면 단일 문자 옵션을 묶을 수 있습니다. 긴 옵션 이름, 긴 옵션과 번들을 구별하려면</target>
        </trans-unit>
        <trans-unit id="867d7c3018e88764391a8a8cad25d71d6020f155" translate="yes" xml:space="preserve">
          <source>Encapsulation</source>
          <target state="translated">Encapsulation</target>
        </trans-unit>
        <trans-unit id="2059232562a427f990749c23a8c8ebdde1b9014d" translate="yes" xml:space="preserve">
          <source>Encapsulation is important for several reasons. First, it allows you to separate the public API from the private implementation. This means you can change that implementation without breaking the API.</source>
          <target state="translated">캡슐화는 여러 가지 이유로 중요합니다. 먼저 공개 API를 개인 구현과 분리 할 수 ​​있습니다. 즉, API를 중단하지 않고 해당 구현을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="782e817cf07d938d62f7f0517e130f19ec6b4cf1" translate="yes" xml:space="preserve">
          <source>Encode</source>
          <target state="translated">Encode</target>
        </trans-unit>
        <trans-unit id="e276943b90499b3ae3cf8000afe6554906eb7f6a" translate="yes" xml:space="preserve">
          <source>Encode - character encodings in Perl</source>
          <target state="translated">인코딩-Perl의 문자 인코딩</target>
        </trans-unit>
        <trans-unit id="3c5a64c26d9e551da565d681ba9a9c2bc735a49c" translate="yes" xml:space="preserve">
          <source>Encode Implementation Base Class</source>
          <target state="translated">구현 기본 클래스 인코딩</target>
        </trans-unit>
        <trans-unit id="39e91613c24a80edc94f024f6bfb3382d7e896d8" translate="yes" xml:space="preserve">
          <source>Encode a scalar, hash reference or array reference as YAML.</source>
          <target state="translated">스칼라, 해시 참조 또는 배열 참조를 YAML로 인코딩하십시오.</target>
        </trans-unit>
        <trans-unit id="53b3896738d8cf6b15e5278f1369de611febee2e" translate="yes" xml:space="preserve">
          <source>Encode and decode according to the base64 scheme for &quot;URL applications&quot; [1]. This is a variant of the base64 encoding which does not use padding, does not break the string into multiple lines and use the characters &quot;-&quot; and &quot;_&quot; instead of &quot;+&quot; and &quot;/&quot; to avoid using reserved URL characters.</source>
          <target state="translated">&quot;URL 응용 프로그램&quot;에 대한 base64 체계에 따라 인코딩 및 디코딩합니다 [1]. 이것은 패딩을 사용하지 않고 문자열을 여러 줄로 나누지 않고 예약 된 URL 문자 사용을 피하기 위해 &quot;+&quot;및 &quot;/&quot;대신 &quot;-&quot;및 &quot;_&quot;문자를 사용하는 base64 인코딩의 변형입니다.</target>
        </trans-unit>
        <trans-unit id="3d01d8346257820c445f334ba81d16daa9f20915" translate="yes" xml:space="preserve">
          <source>Encode consists of a collection of modules whose details are too extensive to fit in one document. This one itself explains the top-level APIs and general topics at a glance. For other topics and more details, see the documentation for these modules:</source>
          <target state="translated">인코딩은 세부 사항이 너무 광범위하여 하나의 문서에 맞지 않는 모듈 콜렉션으로 구성됩니다. 이것 자체가 최상위 API 및 일반 주제를 한 눈에 설명합니다. 다른 주제와 자세한 내용은 다음 모듈의 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5888dafc03b9c4595a9ef704f5d312540bc3c184" translate="yes" xml:space="preserve">
          <source>Encode data by calling the encode_base64() function. The first argument is the byte string to encode. The second argument is the line-ending sequence to use. It is optional and defaults to &quot;\n&quot;. The returned encoded string is broken into lines of no more than 76 characters each and it will end with $eol unless it is empty. Pass an empty string as second argument if you do not want the encoded string to be broken into lines.</source>
          <target state="translated">encode_base64 () 함수를 호출하여 데이터를 인코딩하십시오. 첫 번째 인수는 인코딩 할 바이트 문자열입니다. 두 번째 인수는 사용할 행 끝 순서입니다. 선택 사항이며 기본값은 &quot;\ n&quot;입니다. 반환 된 인코딩 된 문자열은 각각 76 자 이하의 줄로 분리되며 비어 있지 않으면 $ eol로 끝납니다. 인코딩 된 문자열을 줄로 나누지 않으려면 빈 문자열을 두 번째 인수로 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="ceff1e1e1923f02a7939b507f33300e3a696eaa2" translate="yes" xml:space="preserve">
          <source>Encode up to 1.86 internally used &quot;local $_&quot; to implement this older form. But consider the code below;</source>
          <target state="translated">내부적으로 사용 된 &quot;local $ _&quot;를 1.86까지 인코딩하여이 이전 양식을 구현하십시오. 그러나 아래 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="dec95d5717280ac4e0be7dcb9e6fc7bc4a47ecee" translate="yes" xml:space="preserve">
          <source>Encode uses the Unicode Character Map (UCM) format for source character mappings. This format is used by IBM's ICU package and was adopted by Nick Ing-Simmons for use with the Encode module. Since UCM is more flexible than Tcl's Encoding Map and far more user-friendly, this is the recommended format for Encode now.</source>
          <target state="translated">인코딩은 소스 문자 매핑에 UCM (Unicode Character Map) 형식을 사용합니다. 이 형식은 IBM의 ICU 패키지에서 사용되며 Nick Ing-Simmons에서 Encode 모듈과 함께 사용하도록 채택되었습니다. UCM은 Tcl의 인코딩 맵보다 훨씬 유연하고 사용자에게 훨씬 친숙하기 때문에 현재 인코딩에 권장되는 형식입니다.</target>
        </trans-unit>
        <trans-unit id="5d2cad9401edfbef92e75be01cb40c4e9ecc4cf6" translate="yes" xml:space="preserve">
          <source>Encode::Alias</source>
          <target state="translated">Encode::Alias</target>
        </trans-unit>
        <trans-unit id="552324ae1eb023be362415291b1291f3f52556a7" translate="yes" xml:space="preserve">
          <source>Encode::Alias - alias definitions to encodings</source>
          <target state="translated">Encode :: Alias-인코딩에 대한 별명 정의</target>
        </trans-unit>
        <trans-unit id="cc91ef6d8b4186209599d785324e380db05af545" translate="yes" xml:space="preserve">
          <source>Encode::Byte</source>
          <target state="translated">Encode::Byte</target>
        </trans-unit>
        <trans-unit id="d4b97f8bcca673137fe3a8c4311fa29b1376a129" translate="yes" xml:space="preserve">
          <source>Encode::Byte - Single Byte Encodings</source>
          <target state="translated">인코딩 :: 바이트-단일 바이트 인코딩</target>
        </trans-unit>
        <trans-unit id="8da29f26c3e55351d546a404e8b09b53f82affc8" translate="yes" xml:space="preserve">
          <source>Encode::CJKConstants</source>
          <target state="translated">Encode::CJKConstants</target>
        </trans-unit>
        <trans-unit id="97376755cadc9b08ac2bdcffa80b5c4759e6f7df" translate="yes" xml:space="preserve">
          <source>Encode::CJKConstants.pm -- Internally used by Encode::??::ISO_2022_*</source>
          <target state="translated">Encode :: CJKConstants.pm-Encode :: ?? :: ISO_2022_ *에서 내부적으로 사용</target>
        </trans-unit>
        <trans-unit id="44fea5bddc6721fb4b956554b9d88900826d60c7" translate="yes" xml:space="preserve">
          <source>Encode::CN</source>
          <target state="translated">Encode::CN</target>
        </trans-unit>
        <trans-unit id="40f3392265131b672490757c292c084a525d4184" translate="yes" xml:space="preserve">
          <source>Encode::CN - China-based Chinese Encodings</source>
          <target state="translated">Encode :: CN-중국 기반 중국어 인코딩</target>
        </trans-unit>
        <trans-unit id="207660f321fc12762f2e79b28e35fbb26736a3e7" translate="yes" xml:space="preserve">
          <source>Encode::CN::HZ</source>
          <target state="translated">Encode::CN::HZ</target>
        </trans-unit>
        <trans-unit id="622d7b0a21ca0c1a08d6dda20da0057e0358570c" translate="yes" xml:space="preserve">
          <source>Encode::CN::HZ -- internally used by Encode::CN</source>
          <target state="translated">Encode :: CN :: HZ-Encode :: CN에서 내부적으로 사용</target>
        </trans-unit>
        <trans-unit id="b24bb381f68ba02b49c4c2cd2767f183910da09e" translate="yes" xml:space="preserve">
          <source>Encode::Config</source>
          <target state="translated">Encode::Config</target>
        </trans-unit>
        <trans-unit id="0b7c024127a98fc8be2586eade5f76bc22701aab" translate="yes" xml:space="preserve">
          <source>Encode::Config -- internally used by Encode</source>
          <target state="translated">Encode :: Config-Encode에서 내부적으로 사용</target>
        </trans-unit>
        <trans-unit id="2a8ba6ae9bd0735a827d283930aa3dc28cd2cae3" translate="yes" xml:space="preserve">
          <source>Encode::EBCDIC</source>
          <target state="translated">Encode::EBCDIC</target>
        </trans-unit>
        <trans-unit id="3b31a7154f7c03e9be274aacce1e4dc5a66d5ec6" translate="yes" xml:space="preserve">
          <source>Encode::EBCDIC - EBCDIC Encodings</source>
          <target state="translated">인코딩 :: EBCDIC-EBCDIC 인코딩</target>
        </trans-unit>
        <trans-unit id="a0fb1479e2e68a75a05e36aff16d787758a1778e" translate="yes" xml:space="preserve">
          <source>Encode::Encoder</source>
          <target state="translated">Encode::Encoder</target>
        </trans-unit>
        <trans-unit id="3bfd37620385e094ff5d1811f8a5aaf8e5a7a125" translate="yes" xml:space="preserve">
          <source>Encode::Encoder -- Object Oriented Encoder</source>
          <target state="translated">Encode :: Encoder-객체 지향 인코더</target>
        </trans-unit>
        <trans-unit id="4551a7e4c9181d379ae1288237c1ebecccd59bb8" translate="yes" xml:space="preserve">
          <source>Encode::Encoding</source>
          <target state="translated">Encode::Encoding</target>
        </trans-unit>
        <trans-unit id="932dfcdaef25e880e85283d712d29f239746970b" translate="yes" xml:space="preserve">
          <source>Encode::Encoding - Encode Implementation Base Class</source>
          <target state="translated">Encode :: Encoding-인코딩 구현 기본 클래스</target>
        </trans-unit>
        <trans-unit id="77662ad703615bf25ca69905bb6db23d72296bb9" translate="yes" xml:space="preserve">
          <source>Encode::GSM0338</source>
          <target state="translated">Encode::GSM0338</target>
        </trans-unit>
        <trans-unit id="ede01420f58b4c2565b3da82244d84c95da5b4af" translate="yes" xml:space="preserve">
          <source>Encode::GSM0338 -- ESTI GSM 03.38 Encoding</source>
          <target state="translated">인코딩 :: GSM0338-ESTI GSM 03.38 인코딩</target>
        </trans-unit>
        <trans-unit id="e93ed447e10d95864f0386c026ec121cd47c60ab" translate="yes" xml:space="preserve">
          <source>Encode::Guess</source>
          <target state="translated">Encode::Guess</target>
        </trans-unit>
        <trans-unit id="8b1b151431a67a55222cbbcf0270cd834cbd2d46" translate="yes" xml:space="preserve">
          <source>Encode::Guess -- Guesses encoding from data</source>
          <target state="translated">Encode :: Guess-데이터 인코딩을 추측합니다</target>
        </trans-unit>
        <trans-unit id="f460e270f104cac10b54ab28764ae1739d32a63f" translate="yes" xml:space="preserve">
          <source>Encode::Guess does not work on EBCDIC platforms.</source>
          <target state="translated">EBCDIC 플랫폼에서는 Encode :: Guess가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8030a57667933f97cc9c39195dbf244e622a18a0" translate="yes" xml:space="preserve">
          <source>Encode::Guess enables you to guess in what encoding a given data is encoded, or at least tries to.</source>
          <target state="translated">Encode :: Guess를 사용하면 주어진 데이터가 어떤 인코딩으로 인코딩되었는지 또는 최소한 시도하는지 추측 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e37ee0e2e550bc3634d116c838f3ba94375b8c47" translate="yes" xml:space="preserve">
          <source>Encode::JP</source>
          <target state="translated">Encode::JP</target>
        </trans-unit>
        <trans-unit id="341afac777ffb0b1e52b3a6aa26c1fcd31687ea1" translate="yes" xml:space="preserve">
          <source>Encode::JP - Japanese Encodings</source>
          <target state="translated">인코딩 :: JP-일본어 인코딩</target>
        </trans-unit>
        <trans-unit id="1e6a27be2a727bdf7e4a113a80bef5ed7da8c32a" translate="yes" xml:space="preserve">
          <source>Encode::JP::H2Z</source>
          <target state="translated">Encode::JP::H2Z</target>
        </trans-unit>
        <trans-unit id="61c842d29f655e9a02cc88f2dfe176c79b0a7ccb" translate="yes" xml:space="preserve">
          <source>Encode::JP::H2Z -- internally used by Encode::JP::2022_JP*</source>
          <target state="translated">Encode :: JP :: H2Z-Encode :: JP :: 2022_JP *에서 내부적으로 사용</target>
        </trans-unit>
        <trans-unit id="57d3b7cea6d80534a4eab96981ae8b12e91a572d" translate="yes" xml:space="preserve">
          <source>Encode::JP::JIS7</source>
          <target state="translated">Encode::JP::JIS7</target>
        </trans-unit>
        <trans-unit id="728d78512ef0e5fd10db6af9228f9f55491f142e" translate="yes" xml:space="preserve">
          <source>Encode::JP::JIS7 -- internally used by Encode::JP</source>
          <target state="translated">Encode :: JP :: JIS7-Encode :: JP에서 내부적으로 사용</target>
        </trans-unit>
        <trans-unit id="9292d6d6d6c3d612ab88b4d0a9b44cce420ff5ea" translate="yes" xml:space="preserve">
          <source>Encode::KR</source>
          <target state="translated">Encode::KR</target>
        </trans-unit>
        <trans-unit id="32eef4f01d06c098fb548d1006c901f52a812e7e" translate="yes" xml:space="preserve">
          <source>Encode::KR - Korean Encodings</source>
          <target state="translated">Encode :: KR-한국어 인코딩</target>
        </trans-unit>
        <trans-unit id="adea371ce7b9ff3c3566f35ac1420ac2e2ede009" translate="yes" xml:space="preserve">
          <source>Encode::KR::2022_KR</source>
          <target state="translated">Encode::KR::2022_KR</target>
        </trans-unit>
        <trans-unit id="3976fa623737771006bbaafdf23430529728651d" translate="yes" xml:space="preserve">
          <source>Encode::KR::2022_KR -- internally used by Encode::KR</source>
          <target state="translated">Encode :: KR :: 2022_KR-Encode :: KR에서 내부적으로 사용</target>
        </trans-unit>
        <trans-unit id="e9d431857fb2daca858cf0e24708414e6076d14b" translate="yes" xml:space="preserve">
          <source>Encode::MIME::Header</source>
          <target state="translated">Encode::MIME::Header</target>
        </trans-unit>
        <trans-unit id="f2030bc40a6a13ab85bce58de044a451e0f2022a" translate="yes" xml:space="preserve">
          <source>Encode::MIME::Header -- MIME 'B' and 'Q' header encoding</source>
          <target state="translated">인코딩 :: MIME :: 헤더-MIME 'B'및 'Q'헤더 인코딩</target>
        </trans-unit>
        <trans-unit id="660e24530b4b214dbcf404910cce6c40e5661246" translate="yes" xml:space="preserve">
          <source>Encode::MIME::NAME -- internally used by Encode</source>
          <target state="translated">Encode :: MIME :: NAME-Encode에서 내부적으로 사용</target>
        </trans-unit>
        <trans-unit id="5f4e8291cc2cc181fac6cfb29c5aaebe19ffe8d7" translate="yes" xml:space="preserve">
          <source>Encode::MIME::Name</source>
          <target state="translated">Encode::MIME::Name</target>
        </trans-unit>
        <trans-unit id="617dc5e07f69ab0016776f02fcae4aa5417d4cf3" translate="yes" xml:space="preserve">
          <source>Encode::Symbol</source>
          <target state="translated">Encode::Symbol</target>
        </trans-unit>
        <trans-unit id="305d6a4ecfbcb83575125920205199ebfad9ecbc" translate="yes" xml:space="preserve">
          <source>Encode::Symbol - Symbol Encodings</source>
          <target state="translated">인코딩 :: 기호-기호 인코딩</target>
        </trans-unit>
        <trans-unit id="7353083e24fd78826faff9ec9dd3ca1f0abfeb68" translate="yes" xml:space="preserve">
          <source>Encode::TW</source>
          <target state="translated">Encode::TW</target>
        </trans-unit>
        <trans-unit id="169a69c17f2e47c33a2090f250bc6f54465bac9c" translate="yes" xml:space="preserve">
          <source>Encode::TW - Taiwan-based Chinese Encodings</source>
          <target state="translated">Encode :: TW-대만 기반 중국어 인코딩</target>
        </trans-unit>
        <trans-unit id="f419db0e193bdb95ad1bf1d32e4308acad0add9f" translate="yes" xml:space="preserve">
          <source>Encode::Unicode</source>
          <target state="translated">Encode::Unicode</target>
        </trans-unit>
        <trans-unit id="2ba2c8325c871771b84294002113cdbbccea72d4" translate="yes" xml:space="preserve">
          <source>Encode::Unicode -- Various Unicode Transformation Formats</source>
          <target state="translated">Encode :: Unicode-다양한 유니 코드 변환 형식</target>
        </trans-unit>
        <trans-unit id="24e91aa87151df83dcd6a084acf2bef4fbe28cca" translate="yes" xml:space="preserve">
          <source>Encode::Unicode::UTF7</source>
          <target state="translated">Encode::Unicode::UTF7</target>
        </trans-unit>
        <trans-unit id="46189c892fa791248c9e1697ba2bd11d7d60c2a5" translate="yes" xml:space="preserve">
          <source>Encode::Unicode::UTF7 -- UTF-7 encoding</source>
          <target state="translated">인코딩 :: 유니 코드 :: UTF7-UTF-7 인코딩</target>
        </trans-unit>
        <trans-unit id="0ca2ce49b12c2ee816a410523ba091dc693a60d6" translate="yes" xml:space="preserve">
          <source>Encodes a scalar, hash reference or array reference as YAMLish.</source>
          <target state="translated">스칼라, 해시 참조 또는 배열 참조를 YAMLish로 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="f4c840f47e19e39ed11ebf36e763d836813b7799" translate="yes" xml:space="preserve">
          <source>Encodes the scalar value</source>
          <target state="translated">스칼라 값을 인코딩합니다</target>
        </trans-unit>
        <trans-unit id="5821fec7ee87050117e2081a31b307f34868a8ad" translate="yes" xml:space="preserve">
          <source>Encoding</source>
          <target state="translated">Encoding</target>
        </trans-unit>
        <trans-unit id="e649a0b553388aa0aefbd82d8b0f0d1a27873465" translate="yes" xml:space="preserve">
          <source>Encoding and decoding of base64 strings</source>
          <target state="translated">base64 문자열의 인코딩 및 디코딩</target>
        </trans-unit>
        <trans-unit id="6b77915998634f10773a65ebf127633caa0903b3" translate="yes" xml:space="preserve">
          <source>Encoding and decoding of quoted-printable strings</source>
          <target state="translated">인용 인쇄 가능한 문자열의 인코딩 및 디코딩</target>
        </trans-unit>
        <trans-unit id="a998510992fa4d69263beacea1ddcc7415077441" translate="yes" xml:space="preserve">
          <source>Encoding handling assumes that PerlIO is available and does not work properly if it isn't. The &lt;code&gt;utf8&lt;/code&gt; option is therefore not supported unless Perl is built with PerlIO support.</source>
          <target state="translated">인코딩 처리는 PerlIO가 사용 가능하고 사용 가능하지 않으면 제대로 작동하지 않는다고 가정합니다. &lt;code&gt;utf8&lt;/code&gt; 펄이은 PerlIO 지원을 내장하지 않는 옵션 때문에 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="04cfa3e7800a4d240dc7f677c9407b294c248bcf" translate="yes" xml:space="preserve">
          <source>Encoding layer</source>
          <target state="translated">인코딩 레이어</target>
        </trans-unit>
        <trans-unit id="01cbaf646f7cdfb7eb0fbb21f815c71c722e02c1" translate="yes" xml:space="preserve">
          <source>Encoding via PerlIO</source>
          <target state="translated">PerlIO를 통한 인코딩</target>
        </trans-unit>
        <trans-unit id="bcc5b05d5a707cb27dff01159bcf1a3ca6a46e7c" translate="yes" xml:space="preserve">
          <source>Encodings supported by Encode</source>
          <target state="translated">인코딩이 지원하는 인코딩</target>
        </trans-unit>
        <trans-unit id="2c4ae224ac38c50705eb255694dceb50337fe4c9" translate="yes" xml:space="preserve">
          <source>End of File. Sometimes used metaphorically as the terminating string of a &lt;b&gt;here document&lt;/b&gt;.</source>
          <target state="translated">파일 끝. &lt;b&gt;here 문서&lt;/b&gt; 의 종료 문자열로 은유 적으로 사용되기도 &lt;b&gt;합니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="e61fae84390da1a34c4b2fbd657622d5073292c7" translate="yes" xml:space="preserve">
          <source>End of file.</source>
          <target state="translated">파일 끝.</target>
        </trans-unit>
        <trans-unit id="d1e4562e3c175d8468bb1a01a7952bd0d3b259e1" translate="yes" xml:space="preserve">
          <source>End the sending of data to the remote server. This is done by ensuring that the data already sent ends with CRLF then sending '.CRLF' to end the transmission. Once this data has been sent &lt;code&gt;dataend&lt;/code&gt; calls &lt;code&gt;response&lt;/code&gt; and returns true if &lt;code&gt;response&lt;/code&gt; returns CMD_OK.</source>
          <target state="translated">원격 서버로의 데이터 전송을 종료하십시오. 이것은 이미 전송 된 데이터가 CRLF로 끝난 다음 '.CRLF'를 전송하여 전송을 종료함으로써 이루어집니다. 이 데이터가 전송되면 &lt;code&gt;dataend&lt;/code&gt; 는 &lt;code&gt;response&lt;/code&gt; 를 호출 하고 &lt;code&gt;response&lt;/code&gt; 가 CMD_OK를 반환 하면 true를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="5b395d065aa5966c6da16e4b8c501ca68c3ecd37" translate="yes" xml:space="preserve">
          <source>End-tokens from Pod::Simple::PullParser</source>
          <target state="translated">Pod :: Simple :: PullParser의 엔드 토큰</target>
        </trans-unit>
        <trans-unit id="8676dbbd19637e0c1604c4bcd69f9208a03cfa1a" translate="yes" xml:space="preserve">
          <source>End.U</source>
          <target state="translated">End.U</target>
        </trans-unit>
        <trans-unit id="f4d04612cae76dda50e81f179859b4b712ba14ff" translate="yes" xml:space="preserve">
          <source>Ends a try block. See &lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;Exception Handling in perlguts&lt;/a&gt;.</source>
          <target state="translated">try 블록을 종료합니다. &lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;perlguts의 예외 처리를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5ea2083617805ed93273c46ed0c4792fa3da7a0b" translate="yes" xml:space="preserve">
          <source>Enforce type integrity if required</source>
          <target state="translated">필요한 경우 형식 무결성 시행</target>
        </trans-unit>
        <trans-unit id="286ca1647ce3f25ee107c4a9d50837ecd6b2a964" translate="yes" xml:space="preserve">
          <source>Enforcing redispatch</source>
          <target state="translated">재발급 시행</target>
        </trans-unit>
        <trans-unit id="649df08a448ee3fa90f3746baaf6b0907df42c91" translate="yes" xml:space="preserve">
          <source>English</source>
          <target state="translated">English</target>
        </trans-unit>
        <trans-unit id="256aa1d5dab6cf2100434b619aada1a930ae7c7d" translate="yes" xml:space="preserve">
          <source>English ('en') is</source>
          <target state="translated">영어 ( 'en')는</target>
        </trans-unit>
        <trans-unit id="7aa949020d6b22aac250e3885290aa830dd72a15" translate="yes" xml:space="preserve">
          <source>English - use nice English (or awk) names for ugly punctuation variables</source>
          <target state="translated">영어-못생긴 구두점 변수에 멋진 영어 (또는 awk) 이름 사용</target>
        </trans-unit>
        <trans-unit id="34afa6db1cf569bd02a3ffe4f7e6036f1798a631" translate="yes" xml:space="preserve">
          <source>English.pm</source>
          <target state="translated">English.pm</target>
        </trans-unit>
        <trans-unit id="99343727bceed607c32f483621540aee48471580" translate="yes" xml:space="preserve">
          <source>Enough of the definition talk! Let's have a few examples.</source>
          <target state="translated">충분한 정의 이야기! 몇 가지 예를 들어 봅시다.</target>
        </trans-unit>
        <trans-unit id="8988a13726c59d935ea79d755d1455be0fc83772" translate="yes" xml:space="preserve">
          <source>Ensure that you know what \b really does: it's the boundary between a word character, \w, and something that isn't a word character. That thing that isn't a word character might be \W, but it can also be the start or end of the string.</source>
          <target state="translated">\ b가 실제로 무엇을하는지 확인하십시오 : 단어 문자 \ w와 단어 문자가 아닌 것 사이의 경계입니다. 단어 문자가 아닌 것은 \ W 일 수도 있지만 문자열의 시작 또는 끝일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="21287dbbbfc03a6ee27ae105b87e32fa291261eb" translate="yes" xml:space="preserve">
          <source>Ensure your module works under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; and &lt;code&gt;-w&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; 하고 &lt;code&gt;-w&lt;/code&gt; 를&lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하여 모듈이 작동하는지 확인</target>
        </trans-unit>
        <trans-unit id="1279af9b58018ff33488efc0656bb62fda8db44f" translate="yes" xml:space="preserve">
          <source>Enter interactive mode by running</source>
          <target state="translated">다음을 실행하여 대화식 모드로 들어갑니다.</target>
        </trans-unit>
        <trans-unit id="74eb99da3b9ba3df5f4be61ae4522068a9b27d10" translate="yes" xml:space="preserve">
          <source>Entire arrays (and slices of arrays and hashes) are denoted by '@', which works much as the word &quot;these&quot; or &quot;those&quot; does in English, in that it indicates multiple values are expected.</source>
          <target state="translated">전체 배열 (및 배열 및 해시 조각)은 '@'로 표시되는데, 이는 &quot;these&quot;또는 &quot;those&quot;라는 단어가 영어로하는 것처럼 작동하며 여러 값이 예상됨을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d245bbc8252b0b71ede0a2f949fc5b29d829fd5d" translate="yes" xml:space="preserve">
          <source>Entire hashes are denoted by '%':</source>
          <target state="translated">전체 해시는 '%'로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="4f918189cf78ab84f6519ba2dcb57f2ae316f72b" translate="yes" xml:space="preserve">
          <source>Entries cannot be plain object files, as many Win32 compilers will not handle object files in the place of libraries.</source>
          <target state="translated">많은 Win32 컴파일러가 라이브러리 대신 객체 파일을 처리하지 않으므로 항목은 일반 객체 파일이 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="673fba8e1fb3916663891e031f77ca1343408944" translate="yes" xml:space="preserve">
          <source>Entries in &lt;code&gt;$potential_libs&lt;/code&gt; beginning with a colon and followed by alphanumeric characters are treated as flags. Unknown flags will be ignored.</source>
          <target state="translated">콜론 &lt;code&gt;$potential_libs&lt;/code&gt; 시작하고 그 뒤에 영숫자 문자가 오는 $ potential_libs의 항목은 플래그로 처리됩니다. 알 수없는 플래그는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a95d99085680ef5c64c2fe5754604ba2f596d896" translate="yes" xml:space="preserve">
          <source>Entries such as:</source>
          <target state="translated">다음과 같은 항목 :</target>
        </trans-unit>
        <trans-unit id="8d07f7a288d3779719c1509961105704b61f4cef" translate="yes" xml:space="preserve">
          <source>Entry in the INPUT section of a typemap</source>
          <target state="translated">타입 맵의 INPUT 섹션에있는 항목</target>
        </trans-unit>
        <trans-unit id="237fc607826e845da2eb03390fed5a45c866b715" translate="yes" xml:space="preserve">
          <source>Entry in the OUTPUT section of a typemap</source>
          <target state="translated">타입 맵의 OUTPUT 섹션에있는 항목</target>
        </trans-unit>
        <trans-unit id="81a846de6d38920893fe50bf678fb10abc3847e2" translate="yes" xml:space="preserve">
          <source>Entry in the TYPEMAP section of a typemap</source>
          <target state="translated">타입 맵의 TYPEMAP 섹션에있는 항목</target>
        </trans-unit>
        <trans-unit id="a2562690818adae41c773c584b6f6c09ebb4d39c" translate="yes" xml:space="preserve">
          <source>Env</source>
          <target state="translated">Env</target>
        </trans-unit>
        <trans-unit id="fbbe5fa808eea7f4c74b5ba16db47dab460bc3b9" translate="yes" xml:space="preserve">
          <source>Env - perl module that imports environment variables as scalars or arrays</source>
          <target state="translated">환경 변수를 스칼라 또는 배열로 가져 오는 펄 모듈</target>
        </trans-unit>
        <trans-unit id="ec072bba7befaa68af710fe3549eb0491d7badd1" translate="yes" xml:space="preserve">
          <source>Environment Variables</source>
          <target state="translated">환경 변수</target>
        </trans-unit>
        <trans-unit id="e19f8816c6f7ccbb7d40a44b81def1ffb731d4e0" translate="yes" xml:space="preserve">
          <source>Environment for Compiling perl on Solaris</source>
          <target state="translated">Solaris에서 perl을 컴파일하기위한 환경</target>
        </trans-unit>
        <trans-unit id="c7e160747cc9ac3da385ca9f9c1cb6f2e6810dff" translate="yes" xml:space="preserve">
          <source>Environment variables that the program cares about, normally presented as a list using &lt;code&gt;=over&lt;/code&gt; , &lt;code&gt;=item&lt;/code&gt; , and &lt;code&gt;=back&lt;/code&gt; . For example:</source>
          <target state="translated">프로그램이 관심을 갖는 환경 변수는 일반적으로 &lt;code&gt;=over&lt;/code&gt; , &lt;code&gt;=item&lt;/code&gt; 및 &lt;code&gt;=back&lt;/code&gt; 을 사용하여 목록으로 표시됩니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="59ed6121898e672a267f0f15674f039aebf49694" translate="yes" xml:space="preserve">
          <source>Environment variables to be set during the command</source>
          <target state="translated">명령 중에 설정 될 환경 변수</target>
        </trans-unit>
        <trans-unit id="7264243f4aeaaab7fbb98bd7afd5e953b5900f7b" translate="yes" xml:space="preserve">
          <source>Equality Operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cfd756767e68de5473421aba90c9077344def28" translate="yes" xml:space="preserve">
          <source>Equivalent examples:</source>
          <target state="translated">동등한 예 :</target>
        </trans-unit>
        <trans-unit id="c61e2265d123d76133484971263eb3576ac59dd9" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;$octets = encode(&quot;utf8&quot;, $string)&lt;/code&gt; . The characters in $string are encoded in Perl's internal format, and the result is returned as a sequence of octets. Because all possible characters in Perl have a (loose, not strict) UTF-8 representation, this function cannot fail.</source>
          <target state="translated">상당 &lt;code&gt;$octets = encode(&quot;utf8&quot;, $string)&lt;/code&gt; . $ string의 문자는 Perl의 내부 형식으로 인코딩되며 결과는 일련의 8 진수로 반환됩니다. Perl에서 가능한 모든 문자는 (느슨하고 엄격하지 않은) UTF-8 표현을 가지므로이 기능은 실패 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a263a53c5879a617814d231b90b810689cbeec78" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;$string = decode(&quot;utf8&quot;, $octets [, CHECK])&lt;/code&gt; . The sequence of octets represented by $octets is decoded from UTF-8 into a sequence of logical characters. Because not all sequences of octets are valid UTF-8, it is quite possible for this function to fail. For CHECK, see &lt;a href=&quot;#Handling-Malformed-Data&quot;&gt;Handling Malformed Data&lt;/a&gt;.</source>
          <target state="translated">동등 &lt;code&gt;$string = decode(&quot;utf8&quot;, $octets [, CHECK])&lt;/code&gt; . $ octets로 표시되는 8 진수 시퀀스는 UTF-8에서 논리 문자 시퀀스로 디코딩됩니다. 모든 8 진수 시퀀스가 ​​유효한 UTF-8이 아니기 때문에이 함수가 실패 할 수 있습니다. 점검은 &lt;a href=&quot;#Handling-Malformed-Data&quot;&gt;조작 된 데이터 처리를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="032e60eb7c99d19d4d7f40467e50e02c1b3b3e31" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;functions/exp&quot;&gt;exp&lt;/a&gt;(x) - 1&lt;/code&gt; , but more precise for small argument values [C99].</source>
          <target state="translated">등가 &lt;code&gt;&lt;a href=&quot;functions/exp&quot;&gt;exp&lt;/a&gt;(x) - 1&lt;/code&gt; 하지만 작은 인수 값 [C99]의보다 정확한.</target>
        </trans-unit>
        <trans-unit id="48506d548803ae745c6c6681b3b6b358f76d6d1f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;functions/log&quot;&gt;log&lt;/a&gt;(1 + x)&lt;/code&gt; , but more stable results for small argument values [C99].</source>
          <target state="translated">등가 &lt;code&gt;&lt;a href=&quot;functions/log&quot;&gt;log&lt;/a&gt;(1 + x)&lt;/code&gt; 작은 인수 값 [C99]의, 그러나 더 안정적인 결과.</target>
        </trans-unit>
        <trans-unit id="22c30bad53a9801aa2549ef28438b22b8be2db3e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; FILEHANDLE &lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;(FORMAT, LIST)&lt;/code&gt; , except that &lt;code&gt;$\&lt;/code&gt; (the output record separator) is not appended. The FORMAT and the LIST are actually parsed as a single list. The first argument of the list will be interpreted as the &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; format. This means that &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf(@_)&lt;/a&gt;&lt;/code&gt; will use &lt;code&gt;$_[0]&lt;/code&gt; as the format. See &lt;a href=&quot;#sprintf-FORMAT%2c-LIST&quot;&gt;sprintf&lt;/a&gt; for an explanation of the format argument. If &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; for &lt;code&gt;LC_NUMERIC&lt;/code&gt; Look for this throught pod is in effect and POSIX::setlocale() has been called, the character used for the decimal separator in formatted floating-point numbers is affected by the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale setting. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;$\&lt;/code&gt; (출력 레코드 구분 기호)가 추가되지 않은 것을 제외하고 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; FILEHANDLE &lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;(FORMAT, LIST)&lt;/code&gt; &lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt; (FORMAT, LIST) &lt;a href=&quot;functions/print&quot;&gt;인쇄&lt;/a&gt; 와 동일합니다 . FORMAT과 LIST는 실제로 단일 목록으로 구문 분석됩니다. 목록의 첫 번째 인수는 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 형식 으로 해석됩니다 . 이것은 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf(@_)&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;$_[0]&lt;/code&gt; 을 형식으로 사용 한다는 것을 의미 합니다. format 인수에 대한 설명은 &lt;a href=&quot;#sprintf-FORMAT%2c-LIST&quot;&gt;sprintf&lt;/a&gt; 를 참조하십시오 . 경우 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 로케일 에 대한 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 이 축복하는 포드를 찾아 적용 및 POSIX ::은 setlocale ()가 호출 된에, 형식의 부동 소수점 숫자의 소수 구분에 사용되는 문자는에 의해 영향을 받는다 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 로캘 설정 &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; 및 &lt;a href=&quot;posix&quot;&gt;POSIX를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="200de086c8cd5535e67b47001e5f819da8109f8f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;functions/sqrt&quot;&gt;sqrt&lt;/a&gt;(x * x + y * y)&lt;/code&gt; except more stable on very large or very small arguments [C99].</source>
          <target state="translated">상당 &lt;code&gt;&lt;a href=&quot;functions/sqrt&quot;&gt;sqrt&lt;/a&gt;(x * x + y * y)&lt;/code&gt; 매우 크거나 매우 작은 인수에보다 안정적인 제외 [C99].</target>
        </trans-unit>
        <trans-unit id="0f1d23c2683b2580eee5762a2646e2cfdbd51243" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt; FILEHANDLE &lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;(FORMAT, LIST)&lt;/code&gt; , except that &lt;code&gt;$\&lt;/code&gt; (the output record separator) is not appended. The FORMAT and the LIST are actually parsed as a single list. The first argument of the list will be interpreted as the &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; format. This means that &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf(@_)&lt;/a&gt;&lt;/code&gt; will use &lt;code&gt;$_[0]&lt;/code&gt; as the format. See &lt;a href=&quot;#sprintf-FORMAT%2c-LIST&quot;&gt;sprintf&lt;/a&gt; for an explanation of the format argument. If &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; for &lt;code&gt;LC_NUMERIC&lt;/code&gt; Look for this throught pod is in effect and POSIX::setlocale() has been called, the character used for the decimal separator in formatted floating-point numbers is affected by the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale setting. See &lt;a href=&quot;../perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;../posix&quot;&gt;POSIX&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;$\&lt;/code&gt; (출력 레코드 구분 기호)가 추가되지 않은 것을 제외하고 &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt; FILEHANDLE &lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;(FORMAT, LIST)&lt;/code&gt; &lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt; (FORMAT, LIST) &lt;a href=&quot;print&quot;&gt;인쇄&lt;/a&gt; 와 동일합니다 . FORMAT과 LIST는 실제로 단일 목록으로 구문 분석됩니다. 목록의 첫 번째 인수는 &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 형식 으로 해석됩니다 . 이것은 &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf(@_)&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;$_[0]&lt;/code&gt; 을 형식으로 사용 한다는 것을 의미 합니다. format 인수에 대한 설명은 &lt;a href=&quot;#sprintf-FORMAT%2c-LIST&quot;&gt;sprintf&lt;/a&gt; 를 참조하십시오 . 경우 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 로케일 에 대한 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 이 축복하는 포드를 찾아 적용 및 POSIX ::은 setlocale ()가 호출 된에, 형식의 부동 소수점 숫자의 소수 구분에 사용되는 문자는에 의해 영향을 받는다 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 로캘 설정 &lt;a href=&quot;../perllocale&quot;&gt;perllocale&lt;/a&gt; 및 &lt;a href=&quot;../posix&quot;&gt;POSIX를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d4e0dc744110e721ecf88197993cbcc2b45d001" translate="yes" xml:space="preserve">
          <source>Equivalent to Perl code &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $gv&lt;/code&gt; .</source>
          <target state="translated">Perl 코드 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $gv&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="876fc7d247587a71d98917cb3c3453fd65fea359" translate="yes" xml:space="preserve">
          <source>Equivalent to running mktemp() with $dir/$prefixXXXXXXXX (using unix file convention as an example)</source>
          <target state="translated">$ dir / $ prefixXXXXXXXX로 mktemp ()를 실행하는 것과 같습니다 (예를 들어 유닉스 파일 규칙 사용).</target>
        </trans-unit>
        <trans-unit id="4dba35bcd4ac839e52783da10b5058566f3e3b91" translate="yes" xml:space="preserve">
          <source>Equivalent to specifying a DIR of &quot;File::Spec-&amp;gt;tmpdir&quot;, writing the file into the same temporary directory as would be used if no template was specified at all.</source>
          <target state="translated">&quot;File :: Spec-&amp;gt; tmpdir&quot;의 DIR을 지정하는 것과 동일하며, 템플리트가 전혀 지정되지 않은 경우 사용되는 것과 동일한 임시 디렉토리에 파일을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="a667e4f94596d8444896d0c578ec8dad154ae9ae" translate="yes" xml:space="preserve">
          <source>Equivalent to the &lt;b&gt;-C&lt;/b&gt; command-line switch. Note that this is not a boolean variable. Setting this to &lt;code&gt;&quot;1&quot;&lt;/code&gt; is not the right way to &quot;enable Unicode&quot; (whatever that would mean). You can use &lt;code&gt;&quot;0&quot;&lt;/code&gt; to &quot;disable Unicode&quot;, though (or alternatively unset PERL_UNICODE in your shell before starting Perl). See the description of the &lt;b&gt;-C&lt;/b&gt; switch for more information.</source>
          <target state="translated">&lt;b&gt;-C&lt;/b&gt; 명령 행 스위치 와 동일합니다 . 이것은 부울 변수가 아닙니다. 이것을 &lt;code&gt;&quot;1&quot;&lt;/code&gt; 로 설정하는 것이 &quot; 유니 코드&quot;를 가능하게하는 올바른 방법이 아닙니다 (무엇이든). &lt;code&gt;&quot;0&quot;&lt;/code&gt; 을 사용하여 &quot;유니 코드&quot;를 비활성화 할 수 있습니다 (또는 Perl을 시작하기 전에 쉘에서 PERL_UNICODE를 설정 해제 할 수도 있음). 자세한 정보 는 &lt;b&gt;-C&lt;/b&gt; 스위치에 대한 설명 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d371f28bfea1e852f448381bb4f0bdfccaa7149e" translate="yes" xml:space="preserve">
          <source>Equivalent to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cc25c4fa96172ec73030c6c0f3dc9c51687c491" translate="yes" xml:space="preserve">
          <source>Equivalents of</source>
          <target state="translated">등가물</target>
        </trans-unit>
        <trans-unit id="0256add701298dc7a17e42cc9eb936d630438581" translate="yes" xml:space="preserve">
          <source>Erases one character. Defined by</source>
          <target state="translated">한 문자를 지 웁니다. 에 의해 정의</target>
        </trans-unit>
        <trans-unit id="7c24401b7c6f89af67334e697241400ad5298e5f" translate="yes" xml:space="preserve">
          <source>Erases the current input. Defined by</source>
          <target state="translated">현재 입력을 지 웁니다. 에 의해 정의</target>
        </trans-unit>
        <trans-unit id="a3053d2e8a81cd1d9716eddc9ced731b4c51383d" translate="yes" xml:space="preserve">
          <source>Eric Wilhelm @ &amp;lt;ewilhelm at cpan dot org&amp;gt;</source>
          <target state="translated">에릭 빌헬름 @ &amp;lt;팬 팟 조직에서의 ewilhelm&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d8bf3fea74cb51ac9ebccafa9b5bfc9e28b1c902" translate="yes" xml:space="preserve">
          <source>Errno</source>
          <target state="translated">Errno</target>
        </trans-unit>
        <trans-unit id="76cf9c662cbb85bc782a4c519361391afd6f8281" translate="yes" xml:space="preserve">
          <source>Errno - System errno constants</source>
          <target state="translated">Errno-시스템 오류 상수</target>
        </trans-unit>
        <trans-unit id="6cc16f28f695995f841e32ad9be43613256395fe" translate="yes" xml:space="preserve">
          <source>Error Checking</source>
          <target state="translated">오류 확인</target>
        </trans-unit>
        <trans-unit id="ecbd14ea4e6e17d8a2dc17467fb021874d4a82c9" translate="yes" xml:space="preserve">
          <source>Error Variables</source>
          <target state="translated">오류 변수</target>
        </trans-unit>
        <trans-unit id="cfb1de7f5665b658bcddfda7619c881aef88520a" translate="yes" xml:space="preserve">
          <source>Error checking is, as usual, left as an exercise for the reader.</source>
          <target state="translated">오류 점검은 평소와 같이 독자의 연습으로 남습니다.</target>
        </trans-unit>
        <trans-unit id="da4e40dd69c1ef29292868ee52af685e14566b19" translate="yes" xml:space="preserve">
          <source>Error checking, as always, has been left as an exercise for the reader.</source>
          <target state="translated">항상 그렇듯이 오류 점검은 독자에게 연습으로 남았습니다.</target>
        </trans-unit>
        <trans-unit id="3e1fae3d7127b124ae1e94579e5dd51376530e7b" translate="yes" xml:space="preserve">
          <source>Error handling and messages</source>
          <target state="translated">오류 처리 및 메시지</target>
        </trans-unit>
        <trans-unit id="8bb7b0a0be7d85a55ee74f50c125415c68cb8808" translate="yes" xml:space="preserve">
          <source>Error information specific to the current operating system. At the moment, this differs from &lt;code&gt;$!&lt;/code&gt; under only VMS, OS/2, and Win32 (and for MacPerl). On all other platforms, &lt;code&gt;$^E&lt;/code&gt; is always just the same as &lt;code&gt;$!&lt;/code&gt; .</source>
          <target state="translated">현재 운영 체제에 특정한 오류 정보. 현재 이것은 &lt;code&gt;$!&lt;/code&gt; 와 다릅니다 ! VMS, OS / 2 및 Win32 (및 MacPerl)에서만. 다른 모든 플랫폼에서 &lt;code&gt;$^E&lt;/code&gt; 는 항상 &lt;code&gt;$!&lt;/code&gt; 와 동일합니다 ! .</target>
        </trans-unit>
        <trans-unit id="36186555ca5a85354d834f18239bd5446de015bb" translate="yes" xml:space="preserve">
          <source>Error message text from the last failed DynaLoader function. Note that, similar to errno in unix, a successful function call does not reset this message.</source>
          <target state="translated">마지막으로 실패한 DynaLoader 기능의 오류 메시지 텍스트. 유닉스에서의 errno와 마찬가지로 성공적인 함수 호출은이 메시지를 재설정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="50134ffbfcda43f0c3168aa2876061d57b69c6ae" translate="yes" xml:space="preserve">
          <source>Error results (warning and fatal) contain:</source>
          <target state="translated">오류 결과 (경고 및 치명적)에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="805e86a8cbf628e38e4c45612c005a504009e79a" translate="yes" xml:space="preserve">
          <source>Errors</source>
          <target state="translated">Errors</target>
        </trans-unit>
        <trans-unit id="e722317f0272c736783202d0439c1a84302bd3c9" translate="yes" xml:space="preserve">
          <source>Errors in rendering (non-existent function-name, non-existent coderef) are written to the STDOUT, or wherever you've set it via walk_output().</source>
          <target state="translated">존재하지 않는 function-name, 존재하지 않는 coderef의 렌더링 오류는 STDOUT에 작성되거나 walk_output ()을 통해 설정 한 모든 위치에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="0934c88916cf6f7537fb99e4833669f3818f9855" translate="yes" xml:space="preserve">
          <source>Errors using the various *style* calls, and bad args to walk_output(), result in die(). Use an eval if you wish to catch these errors and continue processing.</source>
          <target state="translated">다양한 * style * 호출을 사용하는 오류와 walk_output ()에 대한 잘못된 인수로 인해 die ()가 발생합니다. 이러한 오류를 포착하고 처리를 계속하려면 eval을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="aa094bf265d4ea86b5f894d7a380cedfb2baed9e" translate="yes" xml:space="preserve">
          <source>Escape sequences</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afa6da9272c9b7871ca718b60455b77d2d266044" translate="yes" xml:space="preserve">
          <source>Escapes all &lt;code&gt;$&lt;/code&gt; so they are not interpreted as make variables.</source>
          <target state="translated">모든 &lt;code&gt;$&lt;/code&gt; 를 이스케이프 하여 make 변수로 해석되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d630054693cd8886f832682006b6bb07e97c811d" translate="yes" xml:space="preserve">
          <source>Escapes at most the first &quot;count&quot; chars of pv and puts the results into dsv such that the size of the escaped string will not exceed &quot;max&quot; chars and will not contain any incomplete escape sequences. The number of bytes escaped will be returned in the STRLEN *escaped parameter if it is not null. When the dsv parameter is null no escaping actually occurs, but the number of bytes that would be escaped were it not null will be calculated.</source>
          <target state="translated">pv의 최대 &quot;count&quot;문자를 이스케이프하고 이스케이프 된 문자열의 크기가 &quot;max&quot;문자를 초과하지 않고 불완전한 이스케이프 시퀀스를 포함하지 않도록 결과를 dsv에 넣습니다. 이스케이프 된 바이트 수는 널이 아닌 경우 STRLEN * escaped 매개 변수에 리턴됩니다. dsv 매개 변수가 널이면 이스케이프가 실제로 발생하지 않지만 이스케이프 될 바이트 수는 널이 아닌 경우 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="b73daf05e61c2f4ceabfe0f8dc9e8bd0fe087922" translate="yes" xml:space="preserve">
          <source>Escapes stray &lt;code&gt;$&lt;/code&gt; so they are not interpreted as make variables.</source>
          <target state="translated">이스케이프는 &lt;code&gt;$&lt;/code&gt; 를 길러서 make 변수로 해석되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="92b417d4a5ce0ac686aeee5640af004624297a4e" translate="yes" xml:space="preserve">
          <source>Especially &lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt;.</source>
          <target state="translated">특히 &lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="51e6f8fb1216de07279b7184fe32486c4afcbbd5" translate="yes" xml:space="preserve">
          <source>Especially &lt;a href=&quot;bigrat&quot;&gt;bigrat&lt;/a&gt; as in &lt;code&gt;perl -Mbigrat -le 'print 1/3+1/4'&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;perl -Mbigrat -le 'print 1/3+1/4'&lt;/code&gt; 에서와 같이 특히 &lt;a href=&quot;bigrat&quot;&gt;bigrat&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bcd99d9147aed607626e5d2c3fbf27fa8eaba872" translate="yes" xml:space="preserve">
          <source>Especially &lt;a href=&quot;bigrat&quot;&gt;bigrat&lt;/a&gt; as in &lt;code&gt;perl -Mbigrat -le 'print 1/3+1/4'&lt;/code&gt; and &lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt; as in &lt;code&gt;perl -Mbignum -le 'print sqrt(2)'&lt;/code&gt; .</source>
          <target state="translated">특히 &lt;a href=&quot;bigrat&quot;&gt;bigrat&lt;/a&gt; 같이 &lt;code&gt;perl -Mbigrat -le 'print 1/3+1/4'&lt;/code&gt; 과 &lt;a href=&quot;bignum&quot;&gt;의 bignum를&lt;/a&gt; 같이 &lt;code&gt;perl -Mbignum -le 'print sqrt(2)'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5485ef59e2abd6d9fec5641c427b8c1a89ee861e" translate="yes" xml:space="preserve">
          <source>Essentially this is the same as the &lt;code&gt;__LINE__&lt;/code&gt; macro, but the &lt;code&gt;line_num(+3)&lt;/code&gt; idiom is arguably nicer.</source>
          <target state="translated">본질적으로 이것은 &lt;code&gt;__LINE__&lt;/code&gt; 매크로 와 동일 하지만 &lt;code&gt;line_num(+3)&lt;/code&gt; 관용구가 더 좋을 것입니다.</target>
        </trans-unit>
        <trans-unit id="0c6dff48b0f039b109420e87e1e42abbab8710f8" translate="yes" xml:space="preserve">
          <source>Establish an ISA relationship with base classes at compile time</source>
          <target state="translated">컴파일 타임에 기본 클래스와 ISA 관계 설정</target>
        </trans-unit>
        <trans-unit id="576347ec826f38428d8c8a6f8ec4acb2bceab911" translate="yes" xml:space="preserve">
          <source>Europe</source>
          <target state="translated">Europe</target>
        </trans-unit>
        <trans-unit id="15622021802352824cd00f0a03614ec0fdf9d50b" translate="yes" xml:space="preserve">
          <source>Evaluates EXPR and exits immediately with that value. Example:</source>
          <target state="translated">EXPR을 평가하고 해당 값으로 즉시 종료합니다. 예:</target>
        </trans-unit>
        <trans-unit id="c44b93a0add3946a941d2db7675bb524bcd7719a" translate="yes" xml:space="preserve">
          <source>Evaluates its expression in list context and dumps out the result in a pretty-printed fashion. Nested data structures are printed out recursively, unlike the real &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; function in Perl. When dumping hashes, you'll probably prefer 'x \%h' rather than 'x %h'. See &lt;a href=&quot;dumpvalue&quot;&gt;Dumpvalue&lt;/a&gt; if you'd like to do this yourself.</source>
          <target state="translated">목록 컨텍스트에서 표현식을 평가하고 결과를 예쁘게 인쇄합니다. 중첩 된 데이터 구조는 Perl 의 실제 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 기능 과 달리 재귀 적으로 인쇄됩니다 . 해시를 덤프 할 때 아마도 'x % h'보다는 'x \ % h'를 선호 할 것입니다. 직접 수행하려면 &lt;a href=&quot;dumpvalue&quot;&gt;Dumpvalue를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9eee27e1be9e7d28580a29bfa24323cac2b1efa9" translate="yes" xml:space="preserve">
          <source>Evaluates the BLOCK or EXPR for each element of LIST (locally setting &lt;code&gt;$_&lt;/code&gt; to each element) and returns the list value composed of the results of each such evaluation. In scalar context, returns the total number of elements so generated. Evaluates BLOCK or EXPR in list context, so each element of LIST may produce zero, one, or more elements in the returned value.</source>
          <target state="translated">LIST의 각 요소 (로컬에 &lt;code&gt;$_&lt;/code&gt; 를 각 요소 로 설정)에 대해 BLOCK 또는 EXPR을 평가하고 각 평가 결과로 구성된 목록 값을 리턴합니다. 스칼라 컨텍스트에서 이렇게 생성 된 총 요소 수를 반환합니다. 목록 컨텍스트에서 BLOCK 또는 EXPR을 평가하므로 LIST의 각 요소는 리턴 된 값에서 0 개 또는 하나 이상의 요소를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e159565a978e2dbd25deef6d431807eb47abbd14" translate="yes" xml:space="preserve">
          <source>Evaluates the BLOCK or EXPR for each element of LIST (locally setting &lt;code&gt;$_&lt;/code&gt; to each element) and returns the list value consisting of those elements for which the expression evaluated to true. In scalar context, returns the number of times the expression was true.</source>
          <target state="translated">LIST의 각 요소 (로컬에 &lt;code&gt;$_&lt;/code&gt; 를 각 요소 로 설정)에 대해 BLOCK 또는 EXPR을 평가하고 표현식이 true로 평가 된 요소로 구성된 목록 값을 리턴합니다. 스칼라 컨텍스트에서 표현식이 true 인 횟수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="adb27bcd152d36bb6aa40c050f7aa6bc064a148c" translate="yes" xml:space="preserve">
          <source>Evaluates the hash in scalar context and returns the result. Handles magic when the hash is tied.</source>
          <target state="translated">스칼라 컨텍스트에서 해시를 평가하고 결과를 리턴합니다. 해시가 묶일 때 마법을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="0b7efdaaae8c2d5acf037415de9e55f35d46853a" translate="yes" xml:space="preserve">
          <source>Evaluates to a list of the words extracted out of</source>
          <target state="translated">추출 된 단어 목록으로 평가</target>
        </trans-unit>
        <trans-unit id="11f4958a116f001f9e79787b5473e92c45467956" translate="yes" xml:space="preserve">
          <source>Evaluating a Perl statement from your C program</source>
          <target state="translated">C 프로그램에서 Perl 문 평가</target>
        </trans-unit>
        <trans-unit id="fdfaa902629988731ecf820e3310a76ecb105be5" translate="yes" xml:space="preserve">
          <source>Evaluating perl code (e.g. via &quot;eval&quot; or &quot;do 'file'&quot;) causes the code to be compiled into an internal format and then, provided there was no error in the compilation, executed. The internal format is based on many distinct</source>
          <target state="translated">Perl 코드를 평가하면 (예 : &quot;eval&quot;또는 &quot;do 'file'&quot;을 통해) 코드가 내부 형식으로 컴파일 된 다음 컴파일에 오류가없는 경우 실행됩니다. 내부 형식은 많은 별개의</target>
        </trans-unit>
        <trans-unit id="e1f930d87a7c101ffac9391f41733ff5b3321f0a" translate="yes" xml:space="preserve">
          <source>Even &lt;code&gt;$x += 5&lt;/code&gt; or &lt;code&gt;$x++&lt;/code&gt; are not guaranteed to be atomic.</source>
          <target state="translated">&lt;code&gt;$x += 5&lt;/code&gt; 또는 &lt;code&gt;$x++&lt;/code&gt; 조차 원 자성이 될 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="459a068431296abdc9a0ee020cbb72e87da92588" translate="yes" xml:space="preserve">
          <source>Even after they stabilize, some tests may fail.</source>
          <target state="translated">이들이 안정화 된 후에도 일부 테스트가 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="014c0223d524d2f9046bd74912b924b926ef1dba" translate="yes" xml:space="preserve">
          <source>Even if a module is thread-safe, it doesn't mean that the module is optimized to work well with threads. A module could possibly be rewritten to utilize the new features in threaded Perl to increase performance in a threaded environment.</source>
          <target state="translated">모듈이 스레드로부터 안전하다고해서 모듈이 스레드와 잘 작동하도록 최적화 된 것은 아닙니다. 스레드 환경에서 성능을 향상시키기 위해 스레드 Perl의 새로운 기능을 활용하도록 모듈을 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea9410fd8b85c13558ab2ec195f440b39ef94e1e" translate="yes" xml:space="preserve">
          <source>Even if a prototype is available at compile time, the body of the subroutine is not (it hasn't been &lt;code&gt;AUTOLOAD&lt;/code&gt; ed yet). perl needs to examine both the &lt;code&gt;()&lt;/code&gt; prototype and the body of a subroutine at compile time to detect that it can safely replace calls to that subroutine with the constant value.</source>
          <target state="translated">컴파일 타임에 프로토 타입을 사용할 수 있어도 서브 루틴의 본문은 아직 없습니다 ( 아직 &lt;code&gt;AUTOLOAD&lt;/code&gt; 되지 않았습니다). perl 은 컴파일 타임에 &lt;code&gt;()&lt;/code&gt; 프로토 타입과 서브 루틴 본문을 모두 검사 하여 서브 루틴에 대한 호출을 상수 값으로 안전하게 바꿀 수 있는지 감지해야합니다.</target>
        </trans-unit>
        <trans-unit id="6e9d9a1a7409534a2957addc0cb2ac7a35e101e4" translate="yes" xml:space="preserve">
          <source>Even if no</source>
          <target state="translated">아니더라도</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
