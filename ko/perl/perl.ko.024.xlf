<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="9a52563c6b228851d7bd722e9df68900d397ecd2" translate="yes" xml:space="preserve">
          <source>Even if there are no groupings in a regexp, it is still possible to find out what exactly matched in a string. If you use them, Perl will set &lt;code&gt;$`&lt;/code&gt; to the part of the string before the match, will set &lt;code&gt;$&amp;amp;&lt;/code&gt; to the part of the string that matched, and will set &lt;code&gt;$'&lt;/code&gt; to the part of the string after the match. An example:</source>
          <target state="translated">정규 표현식에 그룹화가 없더라도 문자열에서 정확히 일치하는 항목을 찾을 수 있습니다. 그것들을 사용한다면, Perl은 일치하기 전에 문자열의 일부로 &lt;code&gt;$`&lt;/code&gt; 를 설정 하고 일치 하는 문자열의 일부로 &lt;code&gt;$&amp;amp;&lt;/code&gt; 를 설정 하고 일치 후에 문자열의 일부로 &lt;code&gt;$'&lt;/code&gt; 를 설정 합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="d0239289e914ec51bf43e7158f9d72ad004bea40" translate="yes" xml:space="preserve">
          <source>Even if you aren't in doubt, consider the mental welfare of the person who has to maintain the code after you, and who will probably put parentheses in the wrong place.</source>
          <target state="translated">확실하지 않은 경우에도, 코드를 관리해야하는 사람과 괄호를 잘못된 곳에 넣는 사람의 정신적 복지를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="2698b39349f79453a318cb744bc9cc6aed1c6f70" translate="yes" xml:space="preserve">
          <source>Even if you don't currently make use of the API interface, it is still worth reading it.</source>
          <target state="translated">현재 API 인터페이스를 사용하지 않더라도 여전히 읽을 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="11193f6fb31e4425ba4f294d83acb0ef83b5308c" translate="yes" xml:space="preserve">
          <source>Even if you don't want to modify an array, this mechanism is useful for passing multiple arrays in a single LIST, because normally the LIST mechanism will merge all the array values so that you can't extract out the individual arrays. For more on typeglobs, see &lt;a href=&quot;perldata#Typeglobs-and-Filehandles&quot;&gt;Typeglobs and Filehandles in perldata&lt;/a&gt;.</source>
          <target state="translated">배열을 수정하지 않더라도이 메커니즘은 단일 LIST에서 여러 배열을 전달하는 데 유용합니다. 일반적으로 LIST 메커니즘은 개별 배열을 추출 할 수 없도록 모든 배열 값을 병합하기 때문입니다. typeglobs에 대한 자세한 내용 &lt;a href=&quot;perldata#Typeglobs-and-Filehandles&quot;&gt;은 perldata의 Typeglobs 및 Filehandles를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="704c6dd5d66c1d05562f24b58fe540e4c1622bbc" translate="yes" xml:space="preserve">
          <source>Even in a pattern that is interpolated and compiled at run-time, literal code blocks will be compiled once, at perl compile time; the following prints &quot;ABCD&quot;:</source>
          <target state="translated">런타임에 보간되고 컴파일되는 패턴에서도 리터럴 코드 블록은 perl 컴파일 타임에 한 번 컴파일됩니다. 다음은 &quot;ABCD&quot;를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="f9a57fec05cf4b4012f5962aa352266b10461d68" translate="yes" xml:space="preserve">
          <source>Even more drastic example of a process-scope change is &lt;code&gt;&lt;a href=&quot;functions/chroot&quot;&gt;chroot()&lt;/a&gt;&lt;/code&gt;: the root directory of all the threads changes, and no thread can undo it (as opposed to &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">프로세스 범위 변경의 더 극적인 예는 &lt;code&gt;&lt;a href=&quot;functions/chroot&quot;&gt;chroot()&lt;/a&gt;&lt;/code&gt; . 모든 스레드의 루트 디렉토리가 변경되며 어떤 스레드도 ( &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; 과 달리) 실행 취소 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="fba46823e424c4e147c0d6ca9c73a6300bf0908c" translate="yes" xml:space="preserve">
          <source>Even numbered minor versions (5.14, 5.16, 5.18) are production versions, and odd numbered minor versions (5.15, 5.17, 5.19) are development versions. Unless you want to try out an experimental feature, you probably never want to install a development version of Perl.</source>
          <target state="translated">짝수 마이너 버전 (5.14, 5.16, 5.18)은 프로덕션 버전이고 홀수 마이너 버전 (5.15, 5.17, 5.19)은 개발 버전입니다. 실험적인 기능을 사용하지 않으려는 경우 Perl의 개발 버전을 설치하고 싶지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="985c32669ab9bb43127ab9478cdf373b1b43c14e" translate="yes" xml:space="preserve">
          <source>Even the fallback for &lt;code&gt;decode&lt;/code&gt; must return octets, which are then decoded with the character encoding that &lt;code&gt;decode&lt;/code&gt; accepts. So for example if you wish to decode octets as UTF-8, and use ISO-8859-15 as a fallback for bytes that are not valid UTF-8, you could write</source>
          <target state="translated">&lt;code&gt;decode&lt;/code&gt; 대한 폴백조차도 옥텟을 반환해야하며, 디코딩 된 문자 인코딩으로 &lt;code&gt;decode&lt;/code&gt; 됩니다. 예를 들어 옥텟을 UTF-8로 디코딩하고 유효한 UTF-8이 아닌 바이트에 대한 폴백으로 ISO-8859-15를 사용하려는 경우 다음을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="899cce7279e173a144c83044ba4c75852234efbb" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;dog&lt;/code&gt; is the first alternative in the second regex, &lt;code&gt;cat&lt;/code&gt; is able to match earlier in the string.</source>
          <target state="translated">비록 &lt;code&gt;dog&lt;/code&gt; 두 번째 정규 표현식의 첫 번째 대안은, &lt;code&gt;cat&lt;/code&gt; 문자열에서 이전과 일치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="491ac4fd5a527c06bb95d6b29c3d2ceec9e2c0d4" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;dog&lt;/code&gt; is the first alternative in the second regexp, &lt;code&gt;cat&lt;/code&gt; is able to match earlier in the string.</source>
          <target state="translated">비록 &lt;code&gt;dog&lt;/code&gt; 두 번째 정규 표현식의 첫 번째 대안은, &lt;code&gt;cat&lt;/code&gt; 문자열에서 이전과 일치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e410bea532f43017a3bc057208bf28febe91829" translate="yes" xml:space="preserve">
          <source>Even though HP-UX 10.20 and 11.00 are not actively maintained by HP anymore, updates for the HP ANSI C compiler are still available from time to time, and it might be advisable to see if updates are applicable. At the moment of writing, the latests available patches for 11.00 that should be applied are PHSS_35098, PHSS_35175, PHSS_35100, PHSS_33036, and PHSS_33902). If you have a SUM account, you can use it to search for updates/patches. Enter &quot;ANSI&quot; as keyword.</source>
          <target state="translated">HP에서 더 이상 HP-UX 10.20 및 11.00을 유지 관리하지 않더라도 HP ANSI C 컴파일러의 업데이트는 수시로 제공되며 업데이트가 적용 가능한지 확인하는 것이 좋습니다. 작성 시점에 적용해야 할 최신 11.00 패치는 PHSS_35098, PHSS_35175, PHSS_35100, PHSS_33036 및 PHSS_33902)입니다. SUM 계정이있는 경우이를 사용하여 업데이트 / 패치를 검색 할 수 있습니다. 키워드로 &quot;ANSI&quot;를 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="66ef75af64ac05e5f42a2e25f67b5dd40dad7f74" translate="yes" xml:space="preserve">
          <source>Even though VOS allows the slash character to appear in object names, because the VOS port of Perl interprets it as a pathname delimiting character, VOS files, directories, or links whose names contain a slash character cannot be processed. Such files must be renamed before they can be processed by Perl.</source>
          <target state="translated">VOS가 슬래시 문자를 오브젝트 이름에 표시하도록 허용하더라도 Perl의 VOS 포트는이를 경로 이름으로 구분하는 문자, VOS 파일, 디렉토리 또는 슬래시 문자가 포함 된 링크로 해석 할 수 없기 때문에 처리 할 수 ​​없습니다. 이러한 파일은 Perl에서 처리하기 전에 이름을 바꿔야합니다.</target>
        </trans-unit>
        <trans-unit id="cdd82719baf99cfe9734df3eaad725f4efdb196d" translate="yes" xml:space="preserve">
          <source>Even though a reference may be declared as a constant, the reference may point to data which may be changed, as this code shows.</source>
          <target state="translated">참조가 상수로 선언 될 수 있지만이 코드가 보여주는 것처럼 참조는 변경 될 수있는 데이터를 가리킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c1ced7503a24a96a968e8abe517680e11868256" translate="yes" xml:space="preserve">
          <source>Even though it doesn't do much, it is still preferable to writing your own classes from scratch.</source>
          <target state="translated">많은 일을하지 않아도 자신의 클래스를 처음부터 작성하는 것이 여전히 바람직합니다.</target>
        </trans-unit>
        <trans-unit id="5d86d002ba38ad23c3e6f35071476718335949c5" translate="yes" xml:space="preserve">
          <source>Even though it looks as though they're the same method calls (uid), they aren't, because a &lt;code&gt;File::stat&lt;/code&gt; object is different from a &lt;code&gt;User::pwent&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;File::stat&lt;/code&gt; 객체가 &lt;code&gt;User::pwent&lt;/code&gt; 객체 와 다르기 때문에 동일한 메소드 호출 (uid) 인 것처럼 보이지만 그렇지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6dc6e1961fe501af8f7b8e43fd427c0320c933fd" translate="yes" xml:space="preserve">
          <source>Even though some of this section may not be understandable to you on first reading, we think it's important enough to highlight some of the gotchas before delving further, so here goes:</source>
          <target state="translated">이 섹션 중 일부는 처음 읽을 때 이해하기 어려울 수 있지만 더 자세히 살펴보기 전에 문제를 강조 표시하는 것이 중요하다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="a15d3a1eac0736a5f4619bbd0fabeec7d4b2fc07" translate="yes" xml:space="preserve">
          <source>Even though these two matches might be thought of as complements, until v5.20 they were so only on Unicode code points.</source>
          <target state="translated">이 두 개의 일치 항목이 보완으로 생각 될 수 있지만 v5.20까지는 유니 코드 코드 포인트에만 적용되었습니다.</target>
        </trans-unit>
        <trans-unit id="763ed71064b10dfe0eadc8f471bf100bdbc4763d" translate="yes" xml:space="preserve">
          <source>Even though with normal text files a &quot;\n&quot; will do the trick, there is still no unified scheme for terminating a line that is portable between Unix, DOS/Win, and Macintosh, except to terminate</source>
          <target state="translated">일반 텍스트 파일의 경우 &quot;\ n&quot;을 사용하여 트릭을 수행 할 수 있지만 Unix, DOS / Win 및 Macintosh간에 이식 가능한 회선을 종료하기위한 통합 체계는 아직 없습니다.</target>
        </trans-unit>
        <trans-unit id="4630d8c85d1750185c25d65fe850b66a19d12625" translate="yes" xml:space="preserve">
          <source>Even though you started with a completely empty hash, after that call to &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; you've created the structure you needed to check for &lt;code&gt;key3&lt;/code&gt; :</source>
          <target state="translated">완전히 빈 해시로 시작했지만 그 호출이 &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; 하면 &lt;code&gt;key3&lt;/code&gt; 를 확인하는 데 필요한 구조를 만들었습니다 .</target>
        </trans-unit>
        <trans-unit id="08c088010f5560d49366ca00a6983df9e83535cb" translate="yes" xml:space="preserve">
          <source>Even when on a single platform (if you can call Unix a single platform), remember not to count on the existence or the contents of particular system-specific files or directories, like</source>
          <target state="translated">단일 플랫폼에서 (유닉스를 단일 플랫폼으로 호출 할 수있는 경우) 특정 시스템 특정 파일 또는 디렉토리의 존재 또는 내용을 신뢰하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="1602f4d9817a3dceaa33d17e6c176137283825a5" translate="yes" xml:space="preserve">
          <source>Even with all this work, regexp matching happens remarkably fast. To speed things up, Perl compiles the regexp into a compact sequence of opcodes that can often fit inside a processor cache. When the code is executed, these opcodes can then run at full throttle and search very quickly.</source>
          <target state="translated">이 모든 작업에도 불구하고 정규 표현식 일치는 매우 빠르게 발생합니다. 작업 속도를 높이기 위해 Perl은 정규식을 프로세서 캐시 안에 들어갈 수있는 간단한 일련의 opcode로 컴파일합니다. 코드가 실행될 때이 opcode는 전체 스로틀에서 실행되고 매우 빠르게 검색 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35946850beee8b541477d17361e646c61666892c" translate="yes" xml:space="preserve">
          <source>Even with the latest version of Perl, it is known that certain constructs with threads may result in warning messages concerning leaked scalars or unreferenced scalars. However, such warnings are harmless, and may safely be ignored.</source>
          <target state="translated">최신 버전의 Perl을 사용하더라도 스레드가있는 특정 구조는 누출 된 스칼라 또는 참조되지 않은 스칼라에 관한 경고 메시지를 생성 할 수 있습니다. 그러나 이러한 경고는 무해하며 무시해도됩니다.</target>
        </trans-unit>
        <trans-unit id="878e531bfbade13b1bab65a888ae7d4bdc1140e8" translate="yes" xml:space="preserve">
          <source>Event Log</source>
          <target state="translated">이벤트 로그</target>
        </trans-unit>
        <trans-unit id="d002601ef62e11979d8b7c94cd10d54da0d3a8e1" translate="yes" xml:space="preserve">
          <source>Ever wanted to know what a regex looked like? You'll need perl compiled with the DEBUGGING flag for this one:</source>
          <target state="translated">정규식이 어떻게 생겼는지 알고 싶습니까? 이것을 위해 DEBUGGING 플래그로 컴파일 된 펄이 필요합니다 :</target>
        </trans-unit>
        <trans-unit id="3fc9126b1847307a5366bc653e3a3467f58a3dfa" translate="yes" xml:space="preserve">
          <source>Every CPAN module has a bug tracker set up in RT, &lt;a href=&quot;http://rt.cpan.org&quot;&gt;http://rt.cpan.org&lt;/a&gt;. You can submit bugs to RT either through its web interface or by email. To email a bug report, send it to bug-&amp;lt;distribution-name&amp;gt;@rt.cpan.org . For example, if you wanted to report a bug in &lt;a href=&quot;http://search.cpan.org/perldoc/Business::ISBN&quot;&gt;Business::ISBN&lt;/a&gt;, you could send a message to bug-Business-ISBN@rt.cpan.org .</source>
          <target state="translated">모든 CPAN 모듈에는 RT ( &lt;a href=&quot;http://rt.cpan.org&quot;&gt;http://rt.cpan.org)&lt;/a&gt; 에 버그 추적기가 설정되어 있습니다 . 웹 인터페이스 또는 이메일을 통해 RT에 버그를 제출할 수 있습니다. 버그 보고서를 이메일로 보내려면 bug- &amp;lt;distribution-name&amp;gt; @ rt.cpan.org로 보내십시오. 예를 들어 &lt;a href=&quot;http://search.cpan.org/perldoc/Business::ISBN&quot;&gt;Business :: ISBN&lt;/a&gt; 에서 버그를보고하려는 경우 bug-Business-ISBN@rt.cpan.org로 메시지를 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8dc7000ca1bb13ca17faed27406eccbd7bcf88b" translate="yes" xml:space="preserve">
          <source>Every Makefile.PL is run by perl in a separate process. Likewise we run 'make' and 'make install' in separate processes. If you have any parameters (e.g. PREFIX, UNINST or the like) you want to pass to the calls, please specify them here.</source>
          <target state="translated">모든 Makefile.PL은 별도의 프로세스에서 perl에 의해 실행됩니다. 마찬가지로 별도의 프로세스에서 'make'및 'make install'을 실행합니다. 호출에 전달할 매개 변수 (예 : PREFIX, UNINST 등)가있는 경우 여기에 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="5243f64d154762b9f500ff300bf1242e41c19e00" translate="yes" xml:space="preserve">
          <source>Every Unicode character is assigned a general category, which is the &quot;most usual categorization of a character&quot; (from &lt;a href=&quot;http://www.unicode.org/reports/tr44&quot;&gt;http://www.unicode.org/reports/tr44&lt;/a&gt;).</source>
          <target state="translated">모든 유니 코드 문자에는 일반 범주가 할당되는데, 이는 &quot;가장 일반적인 문자 분류&quot;( &lt;a href=&quot;http://www.unicode.org/reports/tr44&quot;&gt;http://www.unicode.org/reports/tr44&lt;/a&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="2fe5013abe724619f4b95c9d05a2b40a50dbbb59" translate="yes" xml:space="preserve">
          <source>Every YAML document represents a single hash reference. The valid keys in this hash are as follows:</source>
          <target state="translated">모든 YAML 문서는 단일 해시 참조를 나타냅니다. 이 해시의 유효한 키는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="302f7ff33fa3b90fdd2132b2697fb84f8705e874" translate="yes" xml:space="preserve">
          <source>Every YAML file may contain arbitrary documents according to the YAML specification, and every document is treated as an entity that can specify the treatment of a single distribution.</source>
          <target state="translated">모든 YAML 파일은 YAML 사양에 따라 임의의 문서를 포함 할 수 있으며 모든 문서는 단일 배포 처리를 지정할 수있는 엔티티로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="08580b590313edf277a406f46fd0c846e6d3947e" translate="yes" xml:space="preserve">
          <source>Every case has a specific application and one or more exceptions, and there is no replacement for running a few tests and finding out which method works best for your particular environment, this is why writing optimal code is not an exact science, and why we love using Perl so much - TMTOWTDI.</source>
          <target state="translated">모든 사례에는 특정 응용 프로그램과 하나 이상의 예외가 있으며, 몇 가지 테스트를 실행하고 특정 환경에 가장 적합한 방법을 찾기위한 대체 방법이 없으므로 최적의 코드를 작성하는 것이 정확한 과학이 아니며 우리가 좋아하는 이유입니다 펄을 너무 많이 사용-TMTOWTDI.</target>
        </trans-unit>
        <trans-unit id="e844c7ea0f1cedd3ae0259a6817d00e2a02c10f0" translate="yes" xml:space="preserve">
          <source>Every developer publishing modules on CPAN needs a CPAN ID. Visit &lt;code&gt;&lt;a href=&quot;http://pause.perl.org/&quot;&gt;http://pause.perl.org/&lt;/a&gt;&lt;/code&gt;, select &quot;Request PAUSE Account&quot;, and wait for your request to be approved by the PAUSE administrators.</source>
          <target state="translated">CPAN의 모든 개발자 공개 모듈에는 CPAN ID가 필요합니다. &lt;code&gt;&lt;a href=&quot;http://pause.perl.org/&quot;&gt;http://pause.perl.org/&lt;/a&gt;&lt;/code&gt; 를 방문 하여 &quot;PAUSE 계정 요청&quot;을 선택하고 PAUSE 관리자가 요청을 승인 할 때까지 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="e4befbeaf4f0b8eb62e07538a8708d75b3c87445" translate="yes" xml:space="preserve">
          <source>Every element in an arrayref directly below a 'par' key is eligible to be run in parallel, while vavalues directly below a 'seq' key must be run in sequence.</source>
          <target state="translated">'par'키 바로 아래의 arrayref에있는 모든 요소는 병렬로 실행할 수 있지만 'seq'키 바로 아래의 vavalue는 순서대로 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="e1c563b6d35c0f4b5118e9474a1d4ce3c52e7bcc" translate="yes" xml:space="preserve">
          <source>Every element node in the parse tree is represented by an arrayref of the form: &lt;code&gt;[ &lt;i&gt;elementname&lt;/i&gt;, \%attributes, &lt;i&gt;...subnodes...&lt;/i&gt; ]&lt;/code&gt;. See the example tree dump in the Synopsis, above.</source>
          <target state="translated">구문 분석 트리의 모든 요소 노드는 &lt;code&gt;[ &lt;i&gt;elementname&lt;/i&gt;, \%attributes, &lt;i&gt;...subnodes...&lt;/i&gt; ]&lt;/code&gt; 형식의 arrayref로 표시됩니다 . 위의 개요에서 트리 덤프 예제를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6134bc0f6fbba39ed1a9d9da08c6587b9ff61665" translate="yes" xml:space="preserve">
          <source>Every line here (apart from the braces, of course) contains a macro. The first line sets up the function declaration as Perl expects for PP code; line 3 sets up variable declarations for the argument stack and the target, the return value of the operation. Finally, it tries to see if the addition operation is overloaded; if so, the appropriate subroutine is called.</source>
          <target state="translated">여기의 모든 줄은 물론 중괄호를 제외하고는 매크로를 포함합니다. 첫 번째 줄은 Perl이 PP 코드에 대해 기대하는대로 함수 선언을 설정합니다. 3 행은 인수 스택 및 대상에 대한 변수 선언, 작업의 반환 값을 설정합니다. 마지막으로, 추가 작업이 오버로드되었는지 확인하려고 시도합니다. 그렇다면 적절한 서브 루틴이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a07a9740c8c1d7a3f895cbb42b5e873e7ccb12fd" translate="yes" xml:space="preserve">
          <source>Every source stream is associated with only one file.</source>
          <target state="translated">모든 소스 스트림은 하나의 파일에만 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="5b61ca48fb706399cd7458bb7c44f76e50b97e70" translate="yes" xml:space="preserve">
          <source>Every text node in the tree is represented by a simple (non-ref) string scalar. So you can test &lt;code&gt;&lt;a href=&quot;../../functions/ref&quot;&gt;ref($node)&lt;/a&gt;&lt;/code&gt; to see whether you have an element node or just a text node.</source>
          <target state="translated">트리의 모든 텍스트 노드는 단순한 (비 참조) 문자열 스칼라로 표시됩니다. 따라서 &lt;code&gt;&lt;a href=&quot;../../functions/ref&quot;&gt;ref($node)&lt;/a&gt;&lt;/code&gt; 를 테스트 하여 요소 노드가 있는지 아니면 텍스트 노드 만 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f280cfdb5544f17d8056c7b9960291300e70ff8a" translate="yes" xml:space="preserve">
          <source>Every variable type has its own namespace, as do several non-variable identifiers. This means that you can, without fear of conflict, use the same name for a scalar variable, an array, or a hash--or, for that matter, for a filehandle, a directory handle, a subroutine name, a format name, or a label. This means that $foo and @foo are two different variables. It also means that &lt;code&gt;$foo[1]&lt;/code&gt; is a part of @foo, not a part of $foo. This may seem a bit weird, but that's okay, because it is weird.</source>
          <target state="translated">변수가 아닌 여러 식별자와 마찬가지로 모든 변수 유형에는 고유 한 네임 스페이스가 있습니다. 즉, 충돌에 대한 두려움없이 스칼라 변수, 배열 또는 해시에 대해 동일한 이름을 사용할 수 있습니다. 즉, 파일 핸들, 디렉토리 핸들, 서브 루틴 이름, 형식 이름, 또는 라벨. 이것은 $ foo와 @foo가 서로 다른 변수라는 것을 의미합니다. 또한 &lt;code&gt;$foo[1]&lt;/code&gt; 은 $ foo의 일부가 아닌 @foo의 일부 임을 의미합니다 . 조금 이상하게 보일 수도 있지만 이상하기 때문에 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="88a304f3d76dc1d9d113e9e43b3de43a63253440" translate="yes" xml:space="preserve">
          <source>Everyone needs compound data structures, and in Perl the way you get them is with references. There are four important rules for managing references: Two for making references and two for using them. Once you know these rules you can do most of the important things you need to do with references.</source>
          <target state="translated">누구나 복합 데이터 구조가 필요하며 Perl에서는 참조 방식을 사용합니다. 참조 관리를위한 4 가지 중요한 규칙이 있습니다. 이러한 규칙을 알고 나면 참조로해야 할 중요한 작업을 대부분 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9f3a853f21ee670feb2d57d64386bb213e70924" translate="yes" xml:space="preserve">
          <source>Everything is exported by default</source>
          <target state="translated">기본적으로 모든 것이 내보내집니다</target>
        </trans-unit>
        <trans-unit id="821563e027b1aef4013748dd378d74e1f89659aa" translate="yes" xml:space="preserve">
          <source>Everything that comes with the official</source>
          <target state="translated">공식과 함께 제공되는 모든 것</target>
        </trans-unit>
        <trans-unit id="f760e16023bf894abde8086e9d7f6c930e923eae" translate="yes" xml:space="preserve">
          <source>Evolution</source>
          <target state="translated">Evolution</target>
        </trans-unit>
        <trans-unit id="d7b6ebbed9d8b46f1eee90eb921f0ea47e548b03" translate="yes" xml:space="preserve">
          <source>Exact version of acceptance unclear, but no later than Perl 5.18.</source>
          <target state="translated">정확한 수용 버전은 불분명하지만 Perl 5.18 이하입니다.</target>
        </trans-unit>
        <trans-unit id="e38657e86225451957dba5ba0d3e55c8be9b8de9" translate="yes" xml:space="preserve">
          <source>Exactly equivalent to &lt;code&gt;Perl_croak(aTHX_ &quot;%s&quot;, PL_no_modify)&lt;/code&gt; , but generates terser object code than using &lt;code&gt;Perl_croak&lt;/code&gt; . Less code used on exception code paths reduces CPU cache pressure.</source>
          <target state="translated">&lt;code&gt;Perl_croak(aTHX_ &quot;%s&quot;, PL_no_modify)&lt;/code&gt; 와 정확히 동일 하지만 &lt;code&gt;Perl_croak&lt;/code&gt; 를 사용하는 것보다 terser 객체 코드를 생성합니다 . 예외 코드 경로에 사용되는 코드가 적 으면 CPU 캐시 압력이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="6c8b76dc891dae007ee34c3cafc01118a9a75f9f" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#gv_fetchmeth_pvn&quot;&gt;gv_fetchmeth_pvn&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">&lt;a href=&quot;#gv_fetchmeth_pvn&quot;&gt;gv_fetchmeth_pvn&lt;/a&gt; 과 정확히 동일 하지만 문자열 / 길이 쌍 대신 널 종료 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="108d410dddfe12b3ba82a3d3c5aded251e31ceaa" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#gv_fetchmeth_pvn&quot;&gt;gv_fetchmeth_pvn&lt;/a&gt;, but takes the name string in the form of an SV instead of a string/length pair.</source>
          <target state="translated">&lt;a href=&quot;#gv_fetchmeth_pvn&quot;&gt;gv_fetchmeth_pvn&lt;/a&gt; 과 정확히 동일 하지만 문자열 / 길이 쌍 대신 SV 형식으로 이름 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="752e1ac766f2cea599a309e02440f40a97bb8d75" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#gv_fetchmeth_pvn_autoload&quot;&gt;gv_fetchmeth_pvn_autoload&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">&lt;a href=&quot;#gv_fetchmeth_pvn_autoload&quot;&gt;gv_fetchmeth_pvn_autoload&lt;/a&gt; 와 똑같지 만 문자열 / 길이 쌍 대신 널 종료 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a2b3eb60980e277cbebb6619993b224a080d7c7e" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#gv_fetchmeth_pvn_autoload&quot;&gt;gv_fetchmeth_pvn_autoload&lt;/a&gt;, but takes the name string in the form of an SV instead of a string/length pair.</source>
          <target state="translated">&lt;a href=&quot;#gv_fetchmeth_pvn_autoload&quot;&gt;gv_fetchmeth_pvn_autoload&lt;/a&gt; 와 똑같지 만 문자열 / 길이 쌍 대신 SV 형식으로 이름 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2fed67a8755ba4f29f90415a63203b5925d94458" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_add_name_pvn&quot;&gt;pad_add_name_pvn&lt;/a&gt;, but takes a literal string instead of a string/length pair.</source>
          <target state="translated">&lt;a href=&quot;#pad_add_name_pvn&quot;&gt;pad_add_name_pvn&lt;/a&gt; 과 정확히 동일 하지만 문자열 / 길이 쌍 대신 리터럴 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="08b5afa04635fafa6b86d20073dca412668556d2" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_add_name_pvn&quot;&gt;pad_add_name_pvn&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">&lt;a href=&quot;#pad_add_name_pvn&quot;&gt;pad_add_name_pvn&lt;/a&gt; 과 정확히 동일 하지만 문자열 / 길이 쌍 대신 널 종료 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2ec05cc4ebe9d68aa94cb00389e8f5276b127226" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_add_name_pvn&quot;&gt;pad_add_name_pvn&lt;/a&gt;, but takes the name string in the form of an SV instead of a string/length pair.</source>
          <target state="translated">&lt;a href=&quot;#pad_add_name_pvn&quot;&gt;pad_add_name_pvn&lt;/a&gt; 과 정확히 동일 하지만 문자열 / 길이 쌍 대신 SV 형식으로 이름 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1fc43c20a7b147a5aa429b8bfb5b2198f1bee606" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_findmy_pvn&quot;&gt;pad_findmy_pvn&lt;/a&gt;, but takes a literal string instead of a string/length pair.</source>
          <target state="translated">&lt;a href=&quot;#pad_findmy_pvn&quot;&gt;pad_findmy_pvn&lt;/a&gt; 과 정확히 동일 하지만 문자열 / 길이 쌍 대신 리터럴 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1f5dc14f0356699ed601763f5b30ea66b583f929" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_findmy_pvn&quot;&gt;pad_findmy_pvn&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">&lt;a href=&quot;#pad_findmy_pvn&quot;&gt;pad_findmy_pvn&lt;/a&gt; 과 정확히 동일 하지만 문자열 / 길이 쌍 대신 널 종료 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="381384c344ba8cf1c452502a4a84edc8e962e04a" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_findmy_pvn&quot;&gt;pad_findmy_pvn&lt;/a&gt;, but takes the name string in the form of an SV instead of a string/length pair.</source>
          <target state="translated">&lt;a href=&quot;#pad_findmy_pvn&quot;&gt;pad_findmy_pvn&lt;/a&gt; 과 정확히 동일 하지만 문자열 / 길이 쌍 대신 SV 형식으로 이름 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f7e2d16336a0ca2ee4b68d73a469a9a7d8cd8bf4" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#sv_derived_from_pv&quot;&gt;sv_derived_from_pv&lt;/a&gt;, but doesn't take a &lt;code&gt;flags&lt;/code&gt; parameter.</source>
          <target state="translated">&lt;a href=&quot;#sv_derived_from_pv&quot;&gt;sv_derived_from_pv&lt;/a&gt; 와 정확히 동일 하지만 &lt;code&gt;flags&lt;/code&gt; 매개 변수를 사용 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0ca422a64172952765c1b42b368f2ea1d836ab7e" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#sv_derived_from_pvn&quot;&gt;sv_derived_from_pvn&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">정확히 &lt;a href=&quot;#sv_derived_from_pvn&quot;&gt;sv_derived_from_pvn&lt;/a&gt; 과 비슷 하지만 문자열 / 길이 쌍 대신 널 종료 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="89c565bb719c5d7bd5d0a569932a9c743f646c23" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#sv_derived_from_pvn&quot;&gt;sv_derived_from_pvn&lt;/a&gt;, but takes the name string in the form of an SV instead of a string/length pair.</source>
          <target state="translated">&lt;a href=&quot;#sv_derived_from_pvn&quot;&gt;sv_derived_from_pvn&lt;/a&gt; 과 정확히 같지만 문자열 / 길이 쌍 대신 SV 형식으로 이름 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f536be833f98474874e14c0022645d10cd4c4708" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;code&gt;XopENTRY(XopENTRY(Perl_custom_op_xop(aTHX_ o), which)&lt;/code&gt; but more efficient. The</source>
          <target state="translated">똑같이 &lt;code&gt;XopENTRY(XopENTRY(Perl_custom_op_xop(aTHX_ o), which)&lt;/code&gt; 그러나보다 효율적.</target>
        </trans-unit>
        <trans-unit id="91cb14ad58a1b4462086f211195165ae13adba9c" translate="yes" xml:space="preserve">
          <source>Exactly like C:</source>
          <target state="translated">정확히 C와 같습니다.</target>
        </trans-unit>
        <trans-unit id="7525b0bc0e061494669779471f34623f62998790" translate="yes" xml:space="preserve">
          <source>Exactly what the</source>
          <target state="translated">정확히 무엇</target>
        </trans-unit>
        <trans-unit id="738aaf2dccc78981e8b455dca2a194bd2ca3770c" translate="yes" xml:space="preserve">
          <source>Exactly what were the failed locale settings varies. In the above the settings were that the LC_ALL was &quot;En_US&quot; and the LANG had no value. This error means that Perl detected that you and/or your operating system supplier and/or system administrator have set up the so-called locale system but Perl could not use those settings. This was not dead serious, fortunately: there is a &quot;default locale&quot; called &quot;C&quot; that Perl can and will use, and the script will be run. Before you really fix the problem, however, you will get the same error message each time you run Perl. How to really fix the problem can be found in &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; section &lt;b&gt;LOCALE PROBLEMS&lt;/b&gt;.</source>
          <target state="translated">실패한 로케일 설정은 정확히 다릅니다. 위의 설정은 LC_ALL이 &quot;En_US&quot;이고 LANG에 값이 없었습니다. 이 오류는 Perl이 사용자 및 / 또는 운영 체제 공급 업체 및 / 또는 시스템 관리자가 소위 로케일 시스템을 설정했지만 Perl이 해당 설정을 사용할 수 없음을 감지했음을 의미합니다. 다행스럽게도 이것은 죽지 않았습니다. Perl이 사용할 수있는 &quot;C&quot;라는 &quot;기본 로케일&quot;이 있으며 스크립트가 실행됩니다. 그러나 실제로 문제를 해결하기 전에 Perl을 실행할 때마다 동일한 오류 메시지가 나타납니다. 실제로 문제를 해결하는 방법은 &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; 섹션 &lt;b&gt;LOCALE &lt;/b&gt;PROBLEMS 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d8b6b2bbc7b58a995a5244483a44038c0c9b80cc" translate="yes" xml:space="preserve">
          <source>Examine signals that are blocked and pending. This uses &lt;code&gt;POSIX::SigSet&lt;/code&gt; objects for the &lt;code&gt;sigset&lt;/code&gt; argument. Consult your system's &lt;code&gt;sigpending&lt;/code&gt; manpage for details.</source>
          <target state="translated">차단 및 보류중인 신호를 검사하십시오. 이 사용 &lt;code&gt;POSIX::SigSet&lt;/code&gt; 에 대한 객체 &lt;code&gt;sigset&lt;/code&gt; 의 인수. 자세한 내용은 시스템의 &lt;code&gt;sigpending&lt;/code&gt; 맨 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9cc359cbd82e941e0ce6d56fc00bde6962483e78" translate="yes" xml:space="preserve">
          <source>Examines an op, which is expected to identify a subroutine at runtime, and attempts to determine at compile time which subroutine it identifies. This is normally used during Perl compilation to determine whether a prototype can be applied to a function call.</source>
          <target state="translated">런타임시 서브 루틴을 식별 할 것으로 예상되는 op를 검사하고 컴파일시 서브 루틴이 식별하는 서브 루틴을 판별하려고 시도합니다. 일반적으로 Perl 컴파일 중에 프로토 타입을 함수 호출에 적용 할 수 있는지 여부를 판별하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="21009b11f09e3868b5cd364062bd16a01cd87baf" translate="yes" xml:space="preserve">
          <source>Examining internal data structures with the &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt; functions</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 내부 데이터 구조 검사</target>
        </trans-unit>
        <trans-unit id="3e9d648412ff129c07a7aa241744818aaa63c13b" translate="yes" xml:space="preserve">
          <source>Examining internal data structures with the dump functions</source>
          <target state="translated">덤프 함수를 사용하여 내부 데이터 구조 검사</target>
        </trans-unit>
        <trans-unit id="f25587ebeed31098679dd0a945296052447509f8" translate="yes" xml:space="preserve">
          <source>Examining the tree</source>
          <target state="translated">나무 검사</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="3ee687a4836f2979219916954f4addd8522f2875" translate="yes" xml:space="preserve">
          <source>Example - a Hexadecimal Handle</source>
          <target state="translated">예-16 진 핸들</target>
        </trans-unit>
        <trans-unit id="6dcd3f46d09547b62bf07ba9b2943c95d53ddae3" translate="yes" xml:space="preserve">
          <source>Example 1</source>
          <target state="translated">실시 예 1</target>
        </trans-unit>
        <trans-unit id="d64751054e2d27b855282a556af039128d434ede" translate="yes" xml:space="preserve">
          <source>Example 1: A simple filter.</source>
          <target state="translated">예 1 : 간단한 필터.</target>
        </trans-unit>
        <trans-unit id="1c56ea49918b9baed94cf4bc0ee9f324efc8841a" translate="yes" xml:space="preserve">
          <source>Example 2</source>
          <target state="translated">실시 예 2</target>
        </trans-unit>
        <trans-unit id="c9ff53c2379b7cde740f23e7a5efd8af7e83e70f" translate="yes" xml:space="preserve">
          <source>Example 2: Using the context</source>
          <target state="translated">예 2 : 컨텍스트 사용</target>
        </trans-unit>
        <trans-unit id="93fa8f292e6f2e8759c24edf270a2f53c96a1766" translate="yes" xml:space="preserve">
          <source>Example 3: Using the context within the filter</source>
          <target state="translated">예 3 : 필터 내에서 컨텍스트 사용</target>
        </trans-unit>
        <trans-unit id="39e8f452734bc5ce3b169811da6ab1984a676dbf" translate="yes" xml:space="preserve">
          <source>Example 4: Using filter_del</source>
          <target state="translated">예 4 : filter_del 사용</target>
        </trans-unit>
        <trans-unit id="82dd29f8b1cca5a0b9d8a8b5b47aff607b15559f" translate="yes" xml:space="preserve">
          <source>Example Distroprefs Files</source>
          <target state="translated">Distroprefs 파일 예</target>
        </trans-unit>
        <trans-unit id="8c67a372e04bf6d9b9e0054bc94bbe354f79d761" translate="yes" xml:space="preserve">
          <source>Example implementation might be:</source>
          <target state="translated">구현 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="65cdc590a56f144422e8ab9d8551b4654f6b8393" translate="yes" xml:space="preserve">
          <source>Example of use of &lt;code&gt;%m&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;%m&lt;/code&gt; 사용 예 :</target>
        </trans-unit>
        <trans-unit id="ec471d84b36457f0d9d75c03377c9e3cd5f3de93" translate="yes" xml:space="preserve">
          <source>Example of use:</source>
          <target state="translated">Example of use:</target>
        </trans-unit>
        <trans-unit id="ea87c9b65b6478fdd7882c8529d632b267f39539" translate="yes" xml:space="preserve">
          <source>Example similar to MAN1PODS.</source>
          <target state="translated">MAN1PODS와 유사한 예.</target>
        </trans-unit>
        <trans-unit id="5ab7721397827b925456d2a147cb5704105a62a7" translate="yes" xml:space="preserve">
          <source>Example usage:</source>
          <target state="translated">사용법 예 :</target>
        </trans-unit>
        <trans-unit id="6f46925524d1c01021e97594cd0f9813ff23d01d" translate="yes" xml:space="preserve">
          <source>Example wrapper function, using a custom stacktrace:</source>
          <target state="translated">사용자 정의 스택 추적을 사용하는 래퍼 함수 예제 :</target>
        </trans-unit>
        <trans-unit id="21504e5520a63c06708e793261e7989f6e598670" translate="yes" xml:space="preserve">
          <source>Example.pm</source>
          <target state="translated">Example.pm</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="cad6ecdc1416c4a99a21cafbb2b565e4a7ce52ac" translate="yes" xml:space="preserve">
          <source>Example: Altering Concise Renderings</source>
          <target state="translated">예 : 간결한 렌더링 변경</target>
        </trans-unit>
        <trans-unit id="e9234fbd94650af302f3c53c866ca9eab6d98b89" translate="yes" xml:space="preserve">
          <source>Example: At the command prompt Type &quot;nmake nwinstall&quot;. This will install NetWare Perl on the NetWare Server. Similarly, if you type &quot;nmake install&quot;, this will cause the binaries to be installed on the local machine. (Typically under the c:\perl folder)</source>
          <target state="translated">예 : 명령 프롬프트에서 &quot;nmake nwinstall&quot;을 입력하십시오. NetWare 서버에 NetWare Perl을 설치합니다. 마찬가지로 &quot;nmake install&quot;을 입력하면 이진 파일이 로컬 컴퓨터에 설치됩니다. (일반적으로 c : \ perl 폴더 아래)</target>
        </trans-unit>
        <trans-unit id="24e5d3a101404316459c21180a1f55d046da675c" translate="yes" xml:space="preserve">
          <source>Example: Encode::ROT13</source>
          <target state="translated">예 : Encode :: ROT13</target>
        </trans-unit>
        <trans-unit id="0721ccbd9aaee85c90df176a3976ea110912494f" translate="yes" xml:space="preserve">
          <source>Example: The following code</source>
          <target state="translated">예 : 다음 코드</target>
        </trans-unit>
        <trans-unit id="57772da1cf0c7d363a78ec1c7ba403554cdf5105" translate="yes" xml:space="preserve">
          <source>Example: You can execute the following on the command prompt.</source>
          <target state="translated">예 : 명령 프롬프트에서 다음을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2749017763b820ec8a5aab014519f7d7e9831d5" translate="yes" xml:space="preserve">
          <source>Example: base64 transcoder</source>
          <target state="translated">예 : base64 트랜스 코더</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="1d7dd2b19077ebadaa57d2f6ba2c64d87037ae05" translate="yes" xml:space="preserve">
          <source>Examples (assuming an ASCII platform)</source>
          <target state="translated">예 (ASCII 플랫폼 가정)</target>
        </trans-unit>
        <trans-unit id="47370b8eea1efa5172e76cf237bd26e7f736ebd6" translate="yes" xml:space="preserve">
          <source>Examples for converting:</source>
          <target state="translated">변환의 예 :</target>
        </trans-unit>
        <trans-unit id="386c7abd2323831ffe2716ae79487fcd14a21d5e" translate="yes" xml:space="preserve">
          <source>Examples for rounding:</source>
          <target state="translated">반올림의 예 :</target>
        </trans-unit>
        <trans-unit id="49d15bdd087c216bc7ae6d4ea03d99c8cec52e40" translate="yes" xml:space="preserve">
          <source>Examples in documentation should be illustrative of the concept they're explaining. Sometimes, the best way to show how a language feature works is with a small program the reader can run without modification. More often, examples will consist of a snippet of code containing only the &quot;important&quot; bits. The definition of &quot;important&quot; varies from snippet to snippet. Sometimes it's important to declare &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; , initialize all variables and fully catch every error condition. More often than not, though, those things obscure the lesson the example was intended to teach.</source>
          <target state="translated">문서의 예는 설명하는 개념을 설명해야합니다. 언어 기능의 작동 방식을 보여주는 가장 좋은 방법은 독자가 수정하지 않고도 실행할 수있는 작은 프로그램을 사용하는 것입니다. 더 자주, 예제는 &quot;중요한&quot;비트 만 포함하는 코드 스 니펫으로 구성됩니다. &quot;중요&quot;의 정의는 스 니펫마다 다릅니다. 때때로 선언하는 것이 중요합니다 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; , 모든 변수를 초기화하고 완벽하게 모든 오류 상태를 잡을 수있어. 그러나 종종 그러한 것들은 본 모범이 가르치고 자하는 교훈을 모호하게합니다.</target>
        </trans-unit>
        <trans-unit id="a591376177b86768f6394133fb691d5a829d17d6" translate="yes" xml:space="preserve">
          <source>Examples of invalid syntax:</source>
          <target state="translated">유효하지 않은 구문의 예 :</target>
        </trans-unit>
        <trans-unit id="0d4621bd6639238b0ab788dd2cc321e39c7fc192" translate="yes" xml:space="preserve">
          <source>Examples of legal names are '$foo' for a scalar, '@foo' for an array, '%foo' for a hash, '&amp;amp;foo' or 'foo' for a subroutine and '*foo' for a glob (i.e. all symbol table entries associated with &quot;foo&quot;, including scalar, array, hash, sub and filehandle).</source>
          <target state="translated">유효한 이름의 예는 스칼라의 경우 '$ foo', 배열의 경우 '@foo', 해시의 경우 '% foo', 서브 루틴의 경우 '&amp;amp; foo'또는 'foo', 글로브의 경우 '* foo'입니다 (예 : 모두 스칼라, 배열, 해시, 서브 및 파일 핸들을 포함하여 &quot;foo&quot;와 연관된 기호 테이블 항목).</target>
        </trans-unit>
        <trans-unit id="d7c5ae33ac348a4d6e7614da1b0d7da380e1b269" translate="yes" xml:space="preserve">
          <source>Examples of use</source>
          <target state="translated">사용 예</target>
        </trans-unit>
        <trans-unit id="1a5dea85313337dc5454525e91430329e3b9eb0f" translate="yes" xml:space="preserve">
          <source>Examples of valid syntax (even though the attributes are unknown):</source>
          <target state="translated">유효한 구문의 예 (속성을 알 수는 없지만) :</target>
        </trans-unit>
        <trans-unit id="45b39bd436c5d9cd8f4ca9dd2c7eb59c66eb58b2" translate="yes" xml:space="preserve">
          <source>Examples section another documentation provided by John Heidemann &amp;lt;johnh@ISI.EDU&amp;gt;</source>
          <target state="translated">예제는 John Heidemann &amp;lt;johnh@ISI.EDU&amp;gt;에서 제공하는 다른 문서 섹션</target>
        </trans-unit>
        <trans-unit id="628a5608e1a43ca4bfb86500d847d49e2edd6c80" translate="yes" xml:space="preserve">
          <source>Examples where callbacks are necessary include</source>
          <target state="translated">콜백이 필요한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="f98a53c84b8d27c6aba2afa49d1eb4984f22de98" translate="yes" xml:space="preserve">
          <source>Examples: &quot;[_1]&quot; and &quot;[,_1]&quot;, which are synonymous; and &quot;&lt;code&gt;[,ID-(,_4,-,_2,)]&lt;/code&gt; &quot;, which compiles as &lt;code&gt;&lt;a href=&quot;../functions/join&quot;&gt;join&lt;/a&gt; &quot;&quot;, &quot;ID-(&quot;, $_[4], &quot;-&quot;, $_[2], &quot;)&quot;&lt;/code&gt; .</source>
          <target state="translated">예 : 동의어 인 &quot;[_1]&quot;및 &quot;[, _1]&quot;; &lt;code&gt;&lt;a href=&quot;../functions/join&quot;&gt;join&lt;/a&gt; &quot;&quot;, &quot;ID-(&quot;, $_[4], &quot;-&quot;, $_[2], &quot;)&quot;&lt;/code&gt; &lt;a href=&quot;../functions/join&quot;&gt;조인으로&lt;/a&gt; 컴파일되는 &quot; &lt;code&gt;[,ID-(,_4,-,_2,)]&lt;/code&gt; &quot; .</target>
        </trans-unit>
        <trans-unit id="fc4e742ff692e5060c86af7b99c37b81006ce99b" translate="yes" xml:space="preserve">
          <source>Except &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; , &lt;b&gt;Unicode::Normalize&lt;/b&gt; is required (see also &lt;b&gt;CAVEAT&lt;/b&gt;).</source>
          <target state="translated">제외 &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; , &lt;b&gt;유니 :: 정규화가&lt;/b&gt; 필요 (참고 &lt;b&gt;주의를&lt;/b&gt; ).</target>
        </trans-unit>
        <trans-unit id="26b1235f5e6dc422681dc01e8714586f7ad38364" translate="yes" xml:space="preserve">
          <source>Except for &lt;code&gt;FILTER_ONLY code =&amp;gt; &lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt; {...}&lt;/code&gt; , each of the component filters is called repeatedly, once for each component found in the source code.</source>
          <target state="translated">&lt;code&gt;FILTER_ONLY code =&amp;gt; &lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt; {...}&lt;/code&gt; 제외하고 각 구성 요소 필터는 소스 코드에서 찾은 각 구성 요소마다 한 번씩 반복적으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="21a10e7180b4b8a76ea58d012850b5f1c4bcb634" translate="yes" xml:space="preserve">
          <source>Except importing the functions, 'autoload' is same as 'load'.</source>
          <target state="translated">함수 가져 오기를 제외하고 'autoload'는 'load'와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="18f4bd6df6292a6b95734ee2a00973430550afe7" translate="yes" xml:space="preserve">
          <source>Except specifing the package and quoting module name, 'autoload_remote' is same as 'load_remote'.</source>
          <target state="translated">패키지 지정 및 모듈 이름 인용을 제외하고 'autoload_remote'는 'load_remote'와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="16e04cb1bb937a46789e35dba24fd14a5feb954d" translate="yes" xml:space="preserve">
          <source>Except specifing the package and quoting module name, 'load_remote' is same as 'load'.</source>
          <target state="translated">패키지 지정 및 모듈 이름 인용을 제외하고 'load_remote'는 'load'와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="f55cf6c06e02d10efcfcfb37efbd0c881f531275" translate="yes" xml:space="preserve">
          <source>Excepting those listed above, we're currently unable to guarantee that B::Deparse will produce a pragma at the correct point in the program. (Specifically, pragmas at the beginning of a block often appear right before the start of the block instead.) Since the effects of pragmas are often lexically scoped, this can mean that the pragma holds sway over a different portion of the program than in the input file.</source>
          <target state="translated">위에 나열된 것을 제외하고는 현재 B :: Deparse가 프로그램의 올바른 지점에서 pragma를 생성한다고 보장 할 수 없습니다. (구체적으로, 블록의 시작 부분에있는 pragma는 종종 대신에 블록의 시작 직전에 나타납니다.) pragma의 영향은 어휘 범위에 속하기 때문에 pragma가 프로그램의 다른 부분에 영향을 미칩니다. 입력 파일.</target>
        </trans-unit>
        <trans-unit id="20788aa11834509830be30396b88f6404f087e8c" translate="yes" xml:space="preserve">
          <source>Exception Handling</source>
          <target state="translated">예외 처리</target>
        </trans-unit>
        <trans-unit id="826f288dbfc038dead10724f69465c1bfe17a68f" translate="yes" xml:space="preserve">
          <source>Exception Handling (simple) Macros</source>
          <target state="translated">예외 처리 (단순) 매크로</target>
        </trans-unit>
        <trans-unit id="fa345b763368fc4f9065828d77e9729e19d258cc" translate="yes" xml:space="preserve">
          <source>Exception handing</source>
          <target state="translated">예외 처리</target>
        </trans-unit>
        <trans-unit id="d504b2a99c5e1f8d7e7350318f686e5cbee7a60e" translate="yes" xml:space="preserve">
          <source>Exceptions from autodying functions.</source>
          <target state="translated">자동 염색 기능의 예외.</target>
        </trans-unit>
        <trans-unit id="1242bf8dd433a51fa4c19b0e3a208b834c9fc265" translate="yes" xml:space="preserve">
          <source>Exceptions from autodying system().</source>
          <target state="translated">autodying system ()의 예외.</target>
        </trans-unit>
        <trans-unit id="48741c44a476b90391e45eac22eeaa9b0d399fee" translate="yes" xml:space="preserve">
          <source>Exceptions produced by the &lt;code&gt;autodie&lt;/code&gt; pragma are members of the &lt;a href=&quot;autodie/exception&quot;&gt;autodie::exception&lt;/a&gt; class. The preferred way to work with these exceptions under Perl 5.10 is as follows:</source>
          <target state="translated">&lt;code&gt;autodie&lt;/code&gt; pragma에 의해 생성 된 예외 는 &lt;a href=&quot;autodie/exception&quot;&gt;autodie :: exception&lt;/a&gt; 클래스의 멤버입니다 . Perl 5.10에서 이러한 예외를 처리하는 기본 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5986414d0fc4bb9c4ee5d8198af90a5eb243568c" translate="yes" xml:space="preserve">
          <source>Exceptions, error return codes, exit statuses, and errno settings. Typically used for function or module documentation; program documentation uses DIAGNOSTICS instead. The general rule of thumb is that errors printed to &lt;code&gt;STDOUT&lt;/code&gt; or &lt;code&gt;STDERR&lt;/code&gt; and intended for the end user are documented in DIAGNOSTICS while errors passed internal to the calling program and intended for other programmers are documented in ERRORS. When documenting a function that sets errno, a full list of the possible errno values should be given here.</source>
          <target state="translated">예외, 오류 리턴 코드, 종료 상태 및 errno 설정. 일반적으로 기능 또는 모듈 문서에 사용됩니다. 프로그램 설명서는 대신 DIAGNOSTICS를 사용합니다. 일반적으로 &lt;code&gt;STDOUT&lt;/code&gt; 또는 &lt;code&gt;STDERR&lt;/code&gt; 로 인쇄되고 최종 사용자를위한 오류는 진단에 문서화되고 호출 프로그램 내부에 전달 된 오류는 다른 프로그래머에 대한 오류는 오류에 문서화됩니다. errno를 설정하는 함수를 문서화 할 때 가능한 errno 값의 전체 목록을 여기에 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="3e8ef9fa750a38a235f6f5db2c10f6d27bcf66b2" translate="yes" xml:space="preserve">
          <source>Excessive pride, the sort of thing for which Zeus zaps you. Also the quality that makes you write (and maintain) programs that other people won&amp;rsquo;t want to say bad things about. Hence, the third great virtue of a programmer. See also &lt;b&gt;laziness&lt;/b&gt; and &lt;b&gt;impatience&lt;/b&gt;.</source>
          <target state="translated">과도한 자부심, 제우스가 당신을 za 거리는 것. 또한 다른 사람들이 나쁜 말을하고 싶지 않은 프로그램을 작성하고 유지하게하는 품질. 따라서 프로그래머의 세 번째 미덕. &lt;b&gt;게으름&lt;/b&gt; 과 &lt;b&gt;조바심&lt;/b&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="1ff53c1a7c6e7525075531f3d6b8357745fac262" translate="yes" xml:space="preserve">
          <source>Exchanging signed integers between different platforms works only when all platforms store them in the same format. Most platforms store signed integers in two's-complement notation, so usually this is not an issue.</source>
          <target state="translated">다른 플랫폼간에 부호있는 정수 교환은 모든 플랫폼이 동일한 형식으로 저장 한 경우에만 작동합니다. 대부분의 플랫폼은 부호있는 정수를 2의 보수 표기법으로 저장하므로 일반적으로 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6d598c708e755dc53aa35c070da1bc37864ef85e" translate="yes" xml:space="preserve">
          <source>Exclude the given routine and its descendants from the profile.</source>
          <target state="translated">지정된 루틴 및 해당 하위 항목을 프로파일에서 제외하십시오.</target>
        </trans-unit>
        <trans-unit id="6a8a72f8f7694a401a32218abd4406ae1d283fcc" translate="yes" xml:space="preserve">
          <source>Executables for gzip, zip, and VMStar:</source>
          <target state="translated">gzip, zip 및 VMStar의 실행 파일 :</target>
        </trans-unit>
        <trans-unit id="58de6b665842567beab85d292c3b5870de1c65ae" translate="yes" xml:space="preserve">
          <source>Execute a regexp. The arguments are</source>
          <target state="translated">정규 표현식을 실행하십시오. 논쟁은</target>
        </trans-unit>
        <trans-unit id="bac595ee7bf88de92060cce1abba1b3d844e6519" translate="yes" xml:space="preserve">
          <source>Execute command as a Perl statement. A trailing semicolon will be supplied. If the Perl statement would otherwise be confused for a Perl debugger, use a leading semicolon, too.</source>
          <target state="translated">Perl 문으로 명령을 실행하십시오. 후미 세미콜론이 제공됩니다. Perl 명령문이 Perl 디버거에 대해 혼동 될 경우 선행 세미콜론도 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1c456233f2824914a52bfceba7c1ea3f220aec8f" translate="yes" xml:space="preserve">
          <source>Execute the given C code and print its results. &lt;b&gt;WARNING&lt;/b&gt;: Perl makes heavy use of macros, and</source>
          <target state="translated">주어진 C 코드를 실행하고 결과를 인쇄하십시오. &lt;b&gt;경고&lt;/b&gt; : Perl은 매크로를 많이 사용하며</target>
        </trans-unit>
        <trans-unit id="061e9bcfa95dc9f2f39332fda78eedc474b39569" translate="yes" xml:space="preserve">
          <source>Execute this statement for a hint about where to find CORE:</source>
          <target state="translated">CORE를 찾을 수있는 위치에 대한 힌트를 보려면이 명령문을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="574f52d839fd11f8f8f4c4d0ddacf0528556159a" translate="yes" xml:space="preserve">
          <source>Executing a postponed regular expression 50 times without consuming any input string will result in a fatal error. The maximum depth is compiled into perl, so changing it requires a custom build.</source>
          <target state="translated">입력 문자열을 소비하지 않고 연기 된 정규 표현식을 50 번 실행하면 치명적인 오류가 발생합니다. 최대 깊이는 perl로 컴파일되므로이를 변경하려면 사용자 정의 빌드가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="6d525b71568c2d982f46feb96b332bedcdc6e4a0" translate="yes" xml:space="preserve">
          <source>Execution</source>
          <target state="translated">Execution</target>
        </trans-unit>
        <trans-unit id="13709dfa0128b531e84d0b60f2a2419c6bf04dbf" translate="yes" xml:space="preserve">
          <source>Execution of END blocks</source>
          <target state="translated">END 블록의 실행</target>
        </trans-unit>
        <trans-unit id="675e718a6b33ba2b7929f770db612d9a80f9b87e" translate="yes" xml:space="preserve">
          <source>Execution of a regex generally involves two phases, the first being finding the start point in the string where we should match from, and the second being running the regop interpreter.</source>
          <target state="translated">정규식의 실행에는 일반적으로 두 단계가 포함되는데, 첫 번째 단계는 일치해야 할 문자열에서 시작점을 찾고 두 번째 단계는 정규표 해석기를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="119f08e3cf8da3d7fe34ab1131df979eb14179b1" translate="yes" xml:space="preserve">
          <source>Execution of any &lt;code&gt;CHECK&lt;/code&gt; blocks.</source>
          <target state="translated">모든 &lt;code&gt;CHECK&lt;/code&gt; 블록의 실행</target>
        </trans-unit>
        <trans-unit id="0603019ab35ef11320acde0ed06d6533404cfee9" translate="yes" xml:space="preserve">
          <source>Execution of any &lt;code&gt;END&lt;/code&gt; blocks.</source>
          <target state="translated">모든 &lt;code&gt;END&lt;/code&gt; 블록의 실행</target>
        </trans-unit>
        <trans-unit id="f4f82800233d6c7223698c2e187aa3ccc7d2dc01" translate="yes" xml:space="preserve">
          <source>Execution of the interpreter itself used to be recursive, but thanks to the efforts of Dave Mitchell in the 5.9.x development track, that has changed: now an internal stack is maintained on the heap and the routine is fully iterative. This can make it tricky as the code is quite conservative about what state it stores, with the result that two consecutive lines in the code can actually be running in totally different contexts due to the simulated recursion.</source>
          <target state="translated">인터프리터 자체의 실행은 재귀 적이지만 5.9.x 개발 트랙에서 Dave Mitchell의 노력 덕분에 변경되었습니다. 이제 내부 스택이 힙에 유지되고 루틴은 완전히 반복됩니다. 이것은 코드가 저장하는 상태에 대해 코드가 상당히 보수적이기 때문에 까다로울 수 있으며, 결과적으로 코드의 두 개의 연속 라인이 시뮬레이션 된 재귀로 인해 완전히 다른 컨텍스트에서 실제로 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="248b9fcc2702356b63c40509208ebb73f559ce07" translate="yes" xml:space="preserve">
          <source>Exhaustive information on the topic of references can be found in &lt;a href=&quot;perlreftut&quot;&gt;perlreftut&lt;/a&gt;, &lt;a href=&quot;perllol&quot;&gt;perllol&lt;/a&gt;, &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; and &lt;a href=&quot;perldsc&quot;&gt;perldsc&lt;/a&gt;.</source>
          <target state="translated">참고 주제에 대한 전체 정보는 &lt;a href=&quot;perlreftut&quot;&gt;perlreftut&lt;/a&gt; , &lt;a href=&quot;perllol&quot;&gt;perllol&lt;/a&gt; , &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; 및 &lt;a href=&quot;perldsc&quot;&gt;perldsc&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="76b5089ada110a0136449f09bf11c2275168e2c5" translate="yes" xml:space="preserve">
          <source>Existing 32 bit apps are properly known as LP32, i.e. Longs and Pointers are 32 bit. 64-bit apps are more properly known as LP64. The discriminating feature of a LP64 bit app is its ability to utilise a 64-bit address space. It is perfectly possible to have a LP32 bit app that supports both 64-bit integers (long long) and largefiles (&amp;gt; 2GB), and this is the default for perl-5.6.0.</source>
          <target state="translated">기존 32 비트 앱은 LP32로 올바르게 알려져 있습니다. 즉 Longs 및 Pointers는 32 비트입니다. 64 비트 앱은 LP64로 더 잘 알려져 있습니다. LP64 비트 앱의 차별화 된 기능은 64 비트 주소 공간을 활용하는 기능입니다. 64 비트 정수 (long long)와 큰 파일 (&amp;gt; 2GB)을 모두 지원하는 LP32 비트 앱을 사용하는 것이 가능하며 이는 perl-5.6.0의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="3ce132dcaab82a474dd839ab951c3eef1631d645" translate="yes" xml:space="preserve">
          <source>Existing syntax and semantics should only be marked for destruction in very limited circumstances. If they are believed to be very rarely used, stand in the way of actual improvement to the Perl language or perl interpreter, and if affected code can be easily updated to continue working, they may be considered for removal. When in doubt, caution dictates that we will favor backward compatibility. When a feature is deprecated, a statement of reasoning describing the decision process will be posted, and a link to it will be provided in the relevant perldelta documents.</source>
          <target state="translated">기존 구문과 의미는 매우 제한된 상황에서만 파기되어야합니다. 그것들이 매우 드물게 사용되는 것으로 여겨지면, Perl 언어 또는 perl 인터프리터를 실제로 개선하는 방식으로 서십시오. 영향을받는 코드를 계속 업데이트하기 위해 쉽게 업데이트 할 수 있다면 제거를 고려할 수 있습니다. 확실하지 않은 경우, 이전 버전과의 호환성을 선호한다는주의가 필요합니다. 기능이 더 이상 사용되지 않으면 의사 결정 프로세스를 설명하는 추론 진술이 게시되고 관련 perldelta 문서에 해당 기능에 대한 링크가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="6d9d19533b0fbf724f69a3d7a99a413b54990645" translate="yes" xml:space="preserve">
          <source>Exit Code</source>
          <target state="translated">종료 코드</target>
        </trans-unit>
        <trans-unit id="d71626cd31b069ac3980d7ed6a6abb80f71225a3" translate="yes" xml:space="preserve">
          <source>Exits</source>
          <target state="translated">Exits</target>
        </trans-unit>
        <trans-unit id="bc031d65eaef8ccada69a0c994a430a53a41354d" translate="yes" xml:space="preserve">
          <source>Exotic Templates</source>
          <target state="translated">이국적인 템플릿</target>
        </trans-unit>
        <trans-unit id="2c6c990ee216fb59d7ad72ee8d28ebcceeb5a21e" translate="yes" xml:space="preserve">
          <source>Expand and unexpand tabs like unix expand(1) and unexpand(1)</source>
          <target state="translated">unix expand (1) 및 unexpand (1)와 같은 탭 펼치기 및 펼치기</target>
        </trans-unit>
        <trans-unit id="2b116400884e9dbc3a5bf5fe94b7d6faa8b0dd38" translate="yes" xml:space="preserve">
          <source>Expand conventional syntax constructions into equivalent ones that expose their internal operation.</source>
          <target state="translated">기존 구문 구조를 내부 조작을 노출시키는 동등한 구문 구조로 확장하십시오.</target>
        </trans-unit>
        <trans-unit id="a24145087edc62ad61c2e0e0ed9777002b6b1d94" translate="yes" xml:space="preserve">
          <source>Expand double-quoted strings into the corresponding combinations of concatenation, uc, ucfirst, lc, lcfirst, quotemeta, and join. For instance, print</source>
          <target state="translated">큰 따옴표로 묶은 문자열을 연결, uc, ucfirst, lc, lcfirst, quotemeta 및 join의 해당 조합으로 확장하십시오. 예를 들어, 인쇄</target>
        </trans-unit>
        <trans-unit id="a3cec9741cec0dca8594001a6d2ea842476ee2ac" translate="yes" xml:space="preserve">
          <source>Expand patterns that start with '~' to user name home directories.</source>
          <target state="translated">'~'로 시작하는 패턴을 사용자 이름 홈 디렉토리로 확장하십시오.</target>
        </trans-unit>
        <trans-unit id="8fc5537d5aa41a3bee835484d8a71db89d04af82" translate="yes" xml:space="preserve">
          <source>Expands MM[KS]/Make macros in a text string, using the contents of identically named elements of &lt;code&gt;%$self&lt;/code&gt; , and returns the result as a file specification in Unix syntax.</source>
          <target state="translated">&lt;code&gt;%$self&lt;/code&gt; 와 동일한 이름을 가진 요소의 내용을 사용하여 텍스트 문자열에서 MM [KS] / Make 매크로를 확장 하고 결과를 파일 형식으로 Unix 구문으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4f5783f703e4997395da1ed4bfbdfa29354401cb" translate="yes" xml:space="preserve">
          <source>Expands a message, intended for the user, to include an indication of the current location in the code, if the message does not already appear to be complete.</source>
          <target state="translated">메시지가 아직 완료되지 않은 것으로 나타나면 코드에 현재 위치를 표시하도록 사용자를위한 메시지를 확장합니다.</target>
        </trans-unit>
        <trans-unit id="adde8be1848474c5303345a29bcef52bb4a7e17d" translate="yes" xml:space="preserve">
          <source>Expands the character buffer in the SV so that it has room for the indicated number of bytes (remember to reserve space for an extra trailing &lt;code&gt;NUL&lt;/code&gt; character). Calls &lt;code&gt;sv_grow&lt;/code&gt; to perform the expansion if necessary. Returns a pointer to the character buffer. SV must be of type &amp;gt;= SVt_PV. One alternative is to call &lt;code&gt;sv_grow&lt;/code&gt; if you are not sure of the type of SV.</source>
          <target state="translated">SV에서 문자 버퍼를 확장하여 표시된 바이트 수를위한 공간을 확보합니다 (추가 후행 &lt;code&gt;NUL&lt;/code&gt; 문자를 위한 공간을 확보해야 함 ). 필요한 경우 &lt;code&gt;sv_grow&lt;/code&gt; 를 호출 하여 확장을 수행합니다. 문자 버퍼에 대한 포인터를 반환합니다. SV는&amp;gt; = SVt_PV 유형이어야합니다. 한 가지 대안은 SV 유형을 잘 &lt;code&gt;sv_grow&lt;/code&gt; 경우 sv_grow 를 호출 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e07f45c58aaef41c3cc48eff8856e3deb378b3c7" translate="yes" xml:space="preserve">
          <source>Expands the character buffer in the SV. If necessary, uses &lt;code&gt;sv_unref&lt;/code&gt; and upgrades the SV to &lt;code&gt;SVt_PV&lt;/code&gt; . Returns a pointer to the character buffer. Use the &lt;code&gt;SvGROW&lt;/code&gt; wrapper instead.</source>
          <target state="translated">SV에서 문자 버퍼를 확장합니다. 필요한 경우 &lt;code&gt;sv_unref&lt;/code&gt; 를 사용 하고 SV를 &lt;code&gt;SVt_PV&lt;/code&gt; 로 업그레이드하십시오 . 문자 버퍼에 대한 포인터를 반환합니다. 대신 &lt;code&gt;SvGROW&lt;/code&gt; 래퍼를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="777c7b4c3fe35b49213cdaeefc6c1268989f5da0" translate="yes" xml:space="preserve">
          <source>Expecting a single value is not quite the same as knowing that there will be one. If someone modified</source>
          <target state="translated">하나의 가치를 기대하는 것은 하나의 가치가 있다는 것을 아는 것과는 다릅니다. 누군가가 수정 한 경우</target>
        </trans-unit>
        <trans-unit id="bf72e88f58634dcb4936f677084e0a00acfdd002" translate="yes" xml:space="preserve">
          <source>Expects an anonymous hash of name =&amp;gt; value pairs. Same rules apply for names as in &lt;code&gt;new&lt;/code&gt; . If no argument is supplied, will return the &quot;seen&quot; list of name =&amp;gt; value pairs, in a list context. Otherwise, returns the object itself.</source>
          <target state="translated">이름 =&amp;gt; 값 쌍의 익명 해시가 필요합니다. &lt;code&gt;new&lt;/code&gt; 규칙과 동일한 규칙이 이름에 적용됩니다 . 인수가 제공되지 않으면 목록 컨텍스트에서 이름 =&amp;gt; 값 쌍의 &quot;본&quot;목록을 리턴합니다. 그렇지 않으면 객체 자체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="04b17e379ead5f797c5aa37eb9dc9a107df81896" translate="yes" xml:space="preserve">
          <source>Experimental Details on given and when</source>
          <target state="translated">주어진 시간과 시간에 대한 실험적 세부 사항</target>
        </trans-unit>
        <trans-unit id="f6f74c01abe74837a83d80a82742b5139aa6cefe" translate="yes" xml:space="preserve">
          <source>Experimental Support for Sun Studio Compilers for Linux OS</source>
          <target state="translated">Linux OS 용 Sun Studio 컴파일러에 대한 실험 지원</target>
        </trans-unit>
        <trans-unit id="9e15651ca047ada36f7efb9c2f8e000cd639262b" translate="yes" xml:space="preserve">
          <source>Experimental features made easy</source>
          <target state="translated">간편한 실험 기능</target>
        </trans-unit>
        <trans-unit id="ed2ea169fad6a1c0c998398ba26a1941a42d9f93" translate="yes" xml:space="preserve">
          <source>Experimental features must be experimental in two stable releases before being marked non-experimental. Experimental features will only have their experimental status revoked when they no longer have any design-changing bugs open against them and when they have remained unchanged in behavior for the entire length of a development cycle. In other words, a feature present in v5.20.0 may be marked no longer experimental in v5.22.0 if and only if its behavior is unchanged throughout all of v5.21.</source>
          <target state="translated">실험적인 특징은 실험적이지 않은 것으로 표시되기 전에 두 개의 안정된 릴리스에서 실험되어야합니다. 실험 기능은 더 이상 디자인 변경 버그가 열려 있지 않고 개발주기의 전체 길이 동안 동작이 변경되지 않은 경우에만 실험 상태가 취소됩니다. 즉, v5.20.0에있는 기능은 모든 v5.21에서 동작이 변경되지 않은 경우에만 v5.22.0에서 더 이상 실험적으로 표시되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="812cee3839ce593c6e7f8fb81f34a218fc92295b" translate="yes" xml:space="preserve">
          <source>Experimental implementation to deal with optional_features from META.yml. Still needs coordination with installer software and currently works only for META.yml declaring &lt;code&gt;dynamic_config=0&lt;/code&gt; . Use with caution.</source>
          <target state="translated">META.yml의 optional_features를 처리하기위한 실험적 구현. 여전히 설치 프로그램 소프트웨어와의 조정이 필요하며 현재 &lt;code&gt;dynamic_config=0&lt;/code&gt; 을 선언하는 META.yml에서만 작동합니다 . 주의해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b1a2e6bb257f27dcbf131f0e4c5090288b803bfa" translate="yes" xml:space="preserve">
          <source>Experimental support for using Intel C++ Compiler has been added. Edit win32/Makefile and pick the correct CCTYPE for the Visual C that Intel C was installed into. Also uncomment __ICC to enable Intel C on Visual C support. To set up the build enviroment, from the Start Menu run IA-32 Visual Studio 20__ mode or Intel 64 Visual Studio 20__ mode as appropriate. Then run nmake as usually in that prompt box.</source>
          <target state="translated">Intel C ++ Compiler 사용에 대한 실험 지원이 추가되었습니다. win32 / Makefile을 편집하고 Intel C가 설치된 Visual C의 올바른 CCTYPE을 선택하십시오. 또한 Visual C 지원에서 Intel C를 활성화하려면 __ICC의 주석을 해제하십시오. 빌드 환경을 설정하려면 시작 메뉴에서 IA-32 Visual Studio 20__ 모드 또는 Intel 64 Visual Studio 20__ 모드를 적절히 실행하십시오. 그런 다음 해당 프롬프트 상자에서 일반적으로 nmake를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="512d10cc80bbcc4b910ab34f44eacc0c8a8cab5b" translate="yes" xml:space="preserve">
          <source>Explain how to make a valid fh without going through open()(i.e. apply a layer). For example if the file is not opened through perl, but we want to get back a fh, like it was opened by Perl.</source>
          <target state="translated">open ()을 거치지 않고 유효한 fh를 만드는 방법을 설명하십시오 (즉, 레이어 적용). 예를 들어 파일이 perl을 통해 열리지 않았지만 Perl에서 열린 것처럼 fh를 되 찾으려고합니다.</target>
        </trans-unit>
        <trans-unit id="0ae3abeefc2986f2eb842d3cd9632c0a0316ad1f" translate="yes" xml:space="preserve">
          <source>Explicit context</source>
          <target state="translated">명시 적 컨텍스트</target>
        </trans-unit>
        <trans-unit id="d2d335bbeeb032574984b5eec4fdf9e2563d5abb" translate="yes" xml:space="preserve">
          <source>Explicitly using the &lt;code&gt;ENTER&lt;/code&gt; /&lt;code&gt;SAVETMPS&lt;/code&gt; --&lt;code&gt;FREETMPS&lt;/code&gt; /&lt;code&gt;LEAVE&lt;/code&gt; pairing</source>
          <target state="translated">&lt;code&gt;ENTER&lt;/code&gt; / &lt;code&gt;SAVETMPS&lt;/code&gt; - &lt;code&gt;FREETMPS&lt;/code&gt; / &lt;code&gt;LEAVE&lt;/code&gt; 페어링을 명시 적으로 사용</target>
        </trans-unit>
        <trans-unit id="d165ee97f26b031b938fc12621899c47ca3e7175" translate="yes" xml:space="preserve">
          <source>Exponentiation</source>
          <target state="translated">Exponentiation</target>
        </trans-unit>
        <trans-unit id="f3e4fadb9e370a1e2c0c622c01fc8c77daf93a2c" translate="yes" xml:space="preserve">
          <source>Export</source>
          <target state="translated">Export</target>
        </trans-unit>
        <trans-unit id="b04b1d43c804b579fc2179b2b3b449ae1560ae80" translate="yes" xml:space="preserve">
          <source>Export tags defined</source>
          <target state="translated">태그 내보내기 정의</target>
        </trans-unit>
        <trans-unit id="a10fabb79509133b618928fd32456dad097bd96f" translate="yes" xml:space="preserve">
          <source>Exportable Functions</source>
          <target state="translated">내보낼 수있는 기능</target>
        </trans-unit>
        <trans-unit id="087b5b3729015829a7b8d0086f8e5125870ab2b2" translate="yes" xml:space="preserve">
          <source>Exportable Methods</source>
          <target state="translated">수출 가능한 방법</target>
        </trans-unit>
        <trans-unit id="60fa04392e9fbe49aa17d919da35cd7332fea185" translate="yes" xml:space="preserve">
          <source>Exported utility variables</source>
          <target state="translated">내 보낸 유틸리티 변수</target>
        </trans-unit>
        <trans-unit id="0cd84bdcb23e59371516a9290d82778263ec9c7c" translate="yes" xml:space="preserve">
          <source>Exporter</source>
          <target state="translated">Exporter</target>
        </trans-unit>
        <trans-unit id="e3272220a019edf889f502d8e939100dd7ba6db5" translate="yes" xml:space="preserve">
          <source>Exporter - Implements default import method for modules</source>
          <target state="translated">내보내기-모듈의 기본 가져 오기 방법을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="9677334ff1544480ffd2a9303280ab252a694823" translate="yes" xml:space="preserve">
          <source>Exporter guts</source>
          <target state="translated">수출 용기</target>
        </trans-unit>
        <trans-unit id="733f73993629cd5a5a17865554f4f49f3a533105" translate="yes" xml:space="preserve">
          <source>Exporter has a special method, 'export_to_level' which is used in situations where you can't directly call Exporter's import method. The export_to_level method looks like:</source>
          <target state="translated">Exporter에는 Exporter의 import 메소드를 직접 호출 할 수없는 상황에서 사용되는 특수한 'export_to_level'메소드가 있습니다. export_to_level 메소드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e3e659931fe986137a62058f2b4abcef03d65202" translate="yes" xml:space="preserve">
          <source>Exporter.pm</source>
          <target state="translated">Exporter.pm</target>
        </trans-unit>
        <trans-unit id="dc76f5ce6b0b38a5f000b46176cc35b9cb43b24a" translate="yes" xml:space="preserve">
          <source>Exporter::Heavy</source>
          <target state="translated">Exporter::Heavy</target>
        </trans-unit>
        <trans-unit id="1d1140249dd08a40f776c20b9ddd54b5796c4a08" translate="yes" xml:space="preserve">
          <source>Exporter::Heavy - Exporter guts</source>
          <target state="translated">수출 :: 무거운-수출 용기</target>
        </trans-unit>
        <trans-unit id="5212c627287d01ea51f61b228d900e6e7aa1a003" translate="yes" xml:space="preserve">
          <source>Exporting Without Inheriting from Exporter</source>
          <target state="translated">내보내기에서 상속하지 않고 내보내기</target>
        </trans-unit>
        <trans-unit id="b76a470ae357815e917068bbc5728a8478edaac1" translate="yes" xml:space="preserve">
          <source>Exporting Without Using Exporter's import Method</source>
          <target state="translated">내보내기의 가져 오기 방법을 사용하지 않고 내보내기</target>
        </trans-unit>
        <trans-unit id="1b7c31e16f36f853e2c6c57c0f5c8d014a8558d8" translate="yes" xml:space="preserve">
          <source>Exporting variables is not a good idea. They can change under the hood, provoking horrible effects at-a-distance that are too hard to track and to fix. Trust me: they are not worth it.</source>
          <target state="translated">변수 내보내기는 좋지 않습니다. 그들은 추적하고 고치기가 너무 어려운 거리에서 끔찍한 효과를 유발하여 후드 아래에서 변화 할 수 있습니다. 저를 믿으십시오 : 그들은 가치가 없습니다.</target>
        </trans-unit>
        <trans-unit id="071e64c7e24a9d0c7e9058c9548f279b0db62c55" translate="yes" xml:space="preserve">
          <source>Exporting your new function</source>
          <target state="translated">새로운 기능 내보내기</target>
        </trans-unit>
        <trans-unit id="0e16537914a0163e01ecd7e0945bc56c50eb3849" translate="yes" xml:space="preserve">
          <source>Exports</source>
          <target state="translated">Exports</target>
        </trans-unit>
        <trans-unit id="1a78d15b2b917cc03293d31b108e05ce4d52026f" translate="yes" xml:space="preserve">
          <source>Exports pollute the namespace of the module user. If you must export try to use &lt;code&gt;@EXPORT_OK&lt;/code&gt; in preference to &lt;code&gt;@EXPORT&lt;/code&gt; and avoid short or common symbol names to reduce the risk of name clashes.</source>
          <target state="translated">내보내기는 모듈 사용자의 네임 스페이스를 오염시킵니다. 내 &lt;code&gt;@EXPORT_OK&lt;/code&gt; 하는 경우 &lt;code&gt;@EXPORT&lt;/code&gt; 보다 _OK 를 사용하고 이름 충돌의 위험을 줄이기 위해 짧거나 일반적인 기호 이름을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="19680f4d8bc35c089321258ed1726974e515bb01" translate="yes" xml:space="preserve">
          <source>Exports pollute the namespace of the module user. If you must export try to use @EXPORT_OK in preference to @EXPORT and avoid short or common names to reduce the risk of name clashes.</source>
          <target state="translated">내보내기는 모듈 사용자의 네임 스페이스를 오염시킵니다. 내 보내야하는 경우 @EXPORT보다 @EXPORT_OK를 사용하고 이름 충돌의 위험을 줄이기 위해 짧거나 일반적인 이름을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="b67fdeebc6a730537832b31cf1e590434ac7ad11" translate="yes" xml:space="preserve">
          <source>Exposes the POSIX function getcwd(3) or re-implements it if it's not available.</source>
          <target state="translated">POSIX 함수 getcwd (3)를 노출하거나 사용할 수없는 경우 다시 구현합니다.</target>
        </trans-unit>
        <trans-unit id="848bbebe9b69edd539cf121a71439bdfe81b397c" translate="yes" xml:space="preserve">
          <source>Expressions like this are useful in conditionals:</source>
          <target state="translated">이와 같은 표현식은 조건부에서 유용합니다.</target>
        </trans-unit>
        <trans-unit id="130f8cc58ed68e3a1fe427428482f60dc97e9301" translate="yes" xml:space="preserve">
          <source>Ext/Ension</source>
          <target state="translated">Ext/Ension</target>
        </trans-unit>
        <trans-unit id="8adb87135c238343780172ae48188681cf370acf" translate="yes" xml:space="preserve">
          <source>ExtUtils::CBuilder</source>
          <target state="translated">ExtUtils::CBuilder</target>
        </trans-unit>
        <trans-unit id="0dd29c2a17cfd9dc6e5beb4505e91940187682bf" translate="yes" xml:space="preserve">
          <source>ExtUtils::CBuilder - Compile and link C code for Perl modules</source>
          <target state="translated">ExtUtils :: CBuilder-Perl 모듈을위한 C 코드 컴파일 및 링크</target>
        </trans-unit>
        <trans-unit id="de9e9dbbe64dfc1f06076f5b598c40c5b97a4f07" translate="yes" xml:space="preserve">
          <source>ExtUtils::CBuilder is maintained as part of the Perl 5 core. Please submit any bug reports via the</source>
          <target state="translated">ExtUtils :: CBuilder는 Perl 5 코어의 일부로 유지됩니다. 를 통해 버그 보고서를 제출하십시오</target>
        </trans-unit>
        <trans-unit id="6d9aae08362d79c65318eda6627f0ab746bbee95" translate="yes" xml:space="preserve">
          <source>ExtUtils::CBuilder::Platform::Windows</source>
          <target state="translated">ExtUtils::CBuilder::Platform::Windows</target>
        </trans-unit>
        <trans-unit id="ec8f2943e4d10ff3dad921becf4700a9c605fc5f" translate="yes" xml:space="preserve">
          <source>ExtUtils::CBuilder::Platform::Windows - Builder class for Windows platforms</source>
          <target state="translated">ExtUtils :: CBuilder :: Platform :: Windows-Windows 플랫폼 용 빌더 클래스</target>
        </trans-unit>
        <trans-unit id="0f5f8c4e317cb9e14dbc99f8c4725e7101d063e0" translate="yes" xml:space="preserve">
          <source>ExtUtils::Command</source>
          <target state="translated">ExtUtils::Command</target>
        </trans-unit>
        <trans-unit id="13685feaf020782447b9941746d4b335bddf0883" translate="yes" xml:space="preserve">
          <source>ExtUtils::Command - utilities to replace common UNIX commands in Makefiles etc.</source>
          <target state="translated">ExtUtils :: Command-Makefile 등에서 일반적인 UNIX 명령을 대체하는 유틸리티</target>
        </trans-unit>
        <trans-unit id="1e0e65de42d77495693723755508f19700283291" translate="yes" xml:space="preserve">
          <source>ExtUtils::Command::MM</source>
          <target state="translated">ExtUtils::Command::MM</target>
        </trans-unit>
        <trans-unit id="57baedd89a659e1e0ecff540830bcf69ebde4c0c" translate="yes" xml:space="preserve">
          <source>ExtUtils::Command::MM - Commands for the MM's to use in Makefiles</source>
          <target state="translated">ExtUtils :: Command :: MM-MM이 Makefile에서 사용할 명령</target>
        </trans-unit>
        <trans-unit id="e8520d9305bb1b6b30673860c2a9fc7e0bb43af7" translate="yes" xml:space="preserve">
          <source>ExtUtils::Command::MM encapsulates code which would otherwise have to be done with large &quot;one&quot; liners.</source>
          <target state="translated">ExtUtils :: Command :: MM은 큰 &quot;하나&quot;라이너로 수행해야하는 코드를 캡슐화합니다.</target>
        </trans-unit>
        <trans-unit id="01aca525aa3b0d3504eab62f629ea7ae316a1df9" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant</source>
          <target state="translated">ExtUtils::Constant</target>
        </trans-unit>
        <trans-unit id="eb53ab587c5df3bac6d41d873980d0a80f5c155a" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant - generate XS code to import C header constants</source>
          <target state="translated">ExtUtils :: Constant-C 헤더 상수를 가져 오기 위해 XS 코드 생성</target>
        </trans-unit>
        <trans-unit id="2bfb67938397e6eb325051359a5d323e79a220d8" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant facilitates generating C and XS wrapper code to allow perl modules to AUTOLOAD constants defined in C library header files. It is principally used by the &lt;code&gt;h2xs&lt;/code&gt; utility, on which this code is based. It doesn't contain the routines to scan header files to extract these constants.</source>
          <target state="translated">ExtUtils :: Constant는 C 라이브러리 헤더 파일에 정의 된 상수를 perl 모듈이 AUTOLOAD 할 수 있도록 C 및 XS 랩퍼 코드 생성을 용이하게합니다. 이 코드 는 기본적으로 &lt;code&gt;h2xs&lt;/code&gt; 유틸리티에서 사용됩니다 . 이러한 상수를 추출하기 위해 헤더 파일을 스캔하는 루틴은 포함되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="66069119c4474ce5db2c00c2fc5c7ebe74e509d3" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::Base</source>
          <target state="translated">ExtUtils::Constant::Base</target>
        </trans-unit>
        <trans-unit id="a5a92bf27fd8a70fb8d0d04675721591091d31a8" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::Base - base class for ExtUtils::Constant objects</source>
          <target state="translated">ExtUtils :: Constant :: Base-ExtUtils :: Constant 객체의 기본 클래스</target>
        </trans-unit>
        <trans-unit id="37d28c0e096d851a074af795694f3e4ed605e4fe" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::Base exports no subroutines. The following methods are available</source>
          <target state="translated">ExtUtils :: Constant :: Base는 서브 루틴을 내 보내지 않습니다. 다음 방법을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="cc85f41228edcbb25fda849b24e857773037224e" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::Base provides a base implementation of methods to generate C code to give fast constant value lookup by named string. Currently it's mostly used ExtUtils::Constant::XS, which generates the lookup code for the constant() subroutine found in many XS modules.</source>
          <target state="translated">ExtUtils :: Constant :: Base는 C 코드를 생성하여 명명 된 문자열로 빠른 상수 값 조회를 제공하는 기본 메소드 구현을 제공합니다. 현재 대부분 ExtUtils :: Constant :: XS를 사용하며 많은 XS 모듈에서 발견되는 constant () 서브 루틴에 대한 조회 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="01123cf69ee0503631a353722ce7083ea5078bc4" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::Utils</source>
          <target state="translated">ExtUtils::Constant::Utils</target>
        </trans-unit>
        <trans-unit id="eb7021c674be1dbbac0f5d2f00a2ee805361885c" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::Utils - helper functions for ExtUtils::Constant</source>
          <target state="translated">ExtUtils :: Constant :: Utils-ExtUtils :: Constant 도우미 함수</target>
        </trans-unit>
        <trans-unit id="88fa01ca987de7b887a3c79f4e501e05801215f9" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::Utils packages up utility subroutines used by ExtUtils::Constant, ExtUtils::Constant::Base and derived classes. All its functions are explicitly exportable.</source>
          <target state="translated">ExtUtils :: Constant :: Utils는 ExtUtils :: Constant, ExtUtils :: Constant :: Base 및 파생 클래스에서 사용하는 유틸리티 서브 루틴을 패키지합니다. 모든 기능은 명시 적으로 내보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="691e427f212f20f1a4e97a292f83b191a9330664" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::XS</source>
          <target state="translated">ExtUtils::Constant::XS</target>
        </trans-unit>
        <trans-unit id="7b304383401bf8b504f1c4575e883635046c55a8" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::XS - generate C code for XS modules' constants.</source>
          <target state="translated">ExtUtils :: Constant :: XS-XS 모듈 상수에 대한 C 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a134fe12059f0bb9cd89ef6f92c5ae2e9810c57e" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::XS overrides ExtUtils::Constant::Base to generate C code for XS modules' constants.</source>
          <target state="translated">ExtUtils :: Constant :: XS는 ExtUtils :: Constant :: Base를 재정 의하여 XS 모듈 상수에 대한 C 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="5fb8ee5bc96080dc35b8c113dc4ab7e19f1f7f22" translate="yes" xml:space="preserve">
          <source>ExtUtils::Embed</source>
          <target state="translated">ExtUtils::Embed</target>
        </trans-unit>
        <trans-unit id="939f083947624f21f9b736c75a4f6438e18f6655" translate="yes" xml:space="preserve">
          <source>ExtUtils::Embed - Utilities for embedding Perl in C/C++ applications</source>
          <target state="translated">ExtUtils :: Embed-C / C ++ 응용 프로그램에 Perl을 임베드하기위한 유틸리티</target>
        </trans-unit>
        <trans-unit id="66d1280ba3865302835b81bea028e8fe495e808d" translate="yes" xml:space="preserve">
          <source>ExtUtils::Install</source>
          <target state="translated">ExtUtils::Install</target>
        </trans-unit>
        <trans-unit id="e1917ee01b8bd661c56eb9ac792b975c3df2f5a1" translate="yes" xml:space="preserve">
          <source>ExtUtils::Install - install files from here to there</source>
          <target state="translated">ExtUtils :: Install-여기에서 거기까지 파일 설치</target>
        </trans-unit>
        <trans-unit id="b703bea959a592e6e8e04477edfce4ad8bd309c6" translate="yes" xml:space="preserve">
          <source>ExtUtils::Installed</source>
          <target state="translated">ExtUtils::Installed</target>
        </trans-unit>
        <trans-unit id="3984de1657750a05991b5ea96245f59313691aaf" translate="yes" xml:space="preserve">
          <source>ExtUtils::Installed - Inventory management of installed modules</source>
          <target state="translated">ExtUtils :: Installed-설치된 모듈의 재고 관리</target>
        </trans-unit>
        <trans-unit id="b02212efafd95acf708fbde6c1ea9a18a4ebc3b3" translate="yes" xml:space="preserve">
          <source>ExtUtils::Installed provides a standard way to find out what core and module files have been installed. It uses the information stored in .packlist files created during installation to provide this information. In addition it provides facilities to classify the installed files and to extract directory information from the .packlist files.</source>
          <target state="translated">ExtUtils :: Installed는 설치된 코어 및 모듈 파일을 찾는 표준 방법을 제공합니다. 설치 중에 작성된 .packlist 파일에 저장된 정보를 사용하여이 정보를 제공합니다. 또한 설치된 파일을 분류하고 .packlist 파일에서 디렉토리 정보를 추출하는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="42c25bbd2df5e46fa299efe94a0a5ec1d56bc561" translate="yes" xml:space="preserve">
          <source>ExtUtils::Liblist</source>
          <target state="translated">ExtUtils::Liblist</target>
        </trans-unit>
        <trans-unit id="1c444f69f6d944829dae0bfb3cb19187e41f4b3d" translate="yes" xml:space="preserve">
          <source>ExtUtils::Liblist - determine libraries to use and how to use them</source>
          <target state="translated">ExtUtils :: Liblist-사용할 라이브러리 및 사용 방법 결정</target>
        </trans-unit>
        <trans-unit id="d6d8f29d2d6c812d8608b7eecff6b50d5b23bb32" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM</source>
          <target state="translated">ExtUtils::MM</target>
        </trans-unit>
        <trans-unit id="d9944867a30cc09571228059a446b44834907174" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM - OS adjusted ExtUtils::MakeMaker subclass</source>
          <target state="translated">ExtUtils :: MM-OS 조정 ExtUtils :: MakeMaker 서브 클래스</target>
        </trans-unit>
        <trans-unit id="db5ed850a839f5d75d47dcc96cd13b3666aca25d" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM is a subclass of ExtUtils::MakeMaker which automatically chooses the appropriate OS specific subclass for you (ie. ExtUils::MM_Unix, etc...).</source>
          <target state="translated">ExtUtils :: MM은 ExtUtils :: MakeMaker의 서브 클래스로, 적합한 OS 특정 서브 클래스 (예 : ExtUils :: MM_Unix 등)를 자동으로 선택합니다.</target>
        </trans-unit>
        <trans-unit id="f20ad18d2cdfe05b996f3064f2baa9077e90198e" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_AIX</source>
          <target state="translated">ExtUtils::MM_AIX</target>
        </trans-unit>
        <trans-unit id="e2c65ab01c23a32d98e8b4e3a0d77782b9a1b0c7" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_AIX - AIX specific subclass of ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils :: MM_AIX-ExtUtils :: MM_Unix의 AIX 특정 서브 클래스</target>
        </trans-unit>
        <trans-unit id="82f6a9462d97b2eeba15d489f4c29f1201ca8139" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Any</source>
          <target state="translated">ExtUtils::MM_Any</target>
        </trans-unit>
        <trans-unit id="28e6e24f25939bb77bd8b0e8b5c1b5591ab0a63a" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Any - Platform-agnostic MM methods</source>
          <target state="translated">ExtUtils :: MM_Any-플랫폼에 구애받지 않는 MM 메소드</target>
        </trans-unit>
        <trans-unit id="a4017c7fd6c6b1a7382d3693845441ec57607400" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Any is a subclass of File::Spec. The methods noted here override File::Spec.</source>
          <target state="translated">ExtUtils :: MM_Any는 File :: Spec의 하위 클래스입니다. 여기에 언급 된 메소드는 File :: Spec을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="a07e79b177dfcc3d173d4e96906fb19054e96233" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Any is a superclass for the ExtUtils::MM_* set of modules. It contains methods which are either inherently cross-platform or are written in a cross-platform manner.</source>
          <target state="translated">ExtUtils :: MM_Any는 ExtUtils :: MM_ * 모듈 세트의 수퍼 클래스입니다. 여기에는 기본적으로 크로스 플랫폼 방식이거나 크로스 플랫폼 방식으로 작성된 메소드가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="01e79daa480a30aec67c1c77b38113a2fa75acb1" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_BeOS</source>
          <target state="translated">ExtUtils::MM_BeOS</target>
        </trans-unit>
        <trans-unit id="ff7047e18f778da31bd8596ebbae3ca3c16815a1" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_BeOS - methods to override UN*X behaviour in ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils :: MM_BeOS-ExtUtils :: MakeMaker에서 UN * X 동작을 재정의하는 메소드</target>
        </trans-unit>
        <trans-unit id="32f54e4d1cdff9fa869169ffbe48a1f8a6442f8d" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Cygwin</source>
          <target state="translated">ExtUtils::MM_Cygwin</target>
        </trans-unit>
        <trans-unit id="26a23a31e9ae337b30e976cee9bfe04ee8714af5" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Cygwin - methods to override UN*X behaviour in ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils :: MM_Cygwin-ExtUtils :: MakeMaker에서 UN * X 동작을 재정의하는 메소드</target>
        </trans-unit>
        <trans-unit id="83b34173b4084fe7b0f1b8e7080f5e44721c1652" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_DOS</source>
          <target state="translated">ExtUtils::MM_DOS</target>
        </trans-unit>
        <trans-unit id="ce09d2a78829bfe3f6e4a91c1fda8bf736e91cd1" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_DOS - DOS specific subclass of ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils :: MM_DOS-ExtUtils :: MM_Unix의 DOS 특정 서브 클래스</target>
        </trans-unit>
        <trans-unit id="95c4b06cdebc87ea8f0b490c31911c2d3a160085" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Darwin</source>
          <target state="translated">ExtUtils::MM_Darwin</target>
        </trans-unit>
        <trans-unit id="ce3594f7f3d66367be8d04f9a60ed3e5b23e61ae" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Darwin - special behaviors for OS X</source>
          <target state="translated">ExtUtils :: MM_Darwin-OS X의 특수 동작</target>
        </trans-unit>
        <trans-unit id="a35d39f1996d06db96e0eb3bc7581c9d1bb37583" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_MacOS</source>
          <target state="translated">ExtUtils::MM_MacOS</target>
        </trans-unit>
        <trans-unit id="a75ee91bd51d22344f5f01dea69463550d1b77f8" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_MacOS - once produced Makefiles for MacOS Classic</source>
          <target state="translated">ExtUtils :: MM_MacOS-한 번 MacOS Classic 용 Makefile 생성</target>
        </trans-unit>
        <trans-unit id="05b1c57f6a3a8d6a042ca608dff6a349761c8182" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_NW5</source>
          <target state="translated">ExtUtils::MM_NW5</target>
        </trans-unit>
        <trans-unit id="c8c1829d86b2c857e5650f081f857c1eaf86f3e8" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_NW5 - methods to override UN*X behaviour in ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils :: MM_NW5-ExtUtils :: MakeMaker에서 UN * X 동작을 재정의하는 메소드</target>
        </trans-unit>
        <trans-unit id="e0950761db3807deb0218887807e7b7bff1a358b" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_OS2</source>
          <target state="translated">ExtUtils::MM_OS2</target>
        </trans-unit>
        <trans-unit id="9c18e1ac0450cd34c6460b2c5c7a1220fbf998b2" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_OS2 - methods to override UN*X behaviour in ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils :: MM_OS2-ExtUtils :: MakeMaker에서 UN * X 동작을 재정의하는 메소드</target>
        </trans-unit>
        <trans-unit id="9754f9a33576ee28f994ec3ff4f6032e292d0ec1" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_QNX</source>
          <target state="translated">ExtUtils::MM_QNX</target>
        </trans-unit>
        <trans-unit id="5c959f779c55270f8bb8da4da99da8c51701f934" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_QNX - QNX specific subclass of ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils :: MM_QNX-ExtUtils :: MM_Unix의 QNX 특정 서브 클래스</target>
        </trans-unit>
        <trans-unit id="d9cffc939c33c81ae491e577ff7a0f67f32115db" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_UWIN</source>
          <target state="translated">ExtUtils::MM_UWIN</target>
        </trans-unit>
        <trans-unit id="392dbc1b30426cf86e8bbd0156b4353d7aae576c" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_UWIN - U/WIN specific subclass of ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils :: MM_UWIN-ExtUtils :: MM_Unix의 U / WIN 특정 서브 클래스</target>
        </trans-unit>
        <trans-unit id="6b69e4024267a17dfff2456177fce03e32e171de" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils::MM_Unix</target>
        </trans-unit>
        <trans-unit id="c828df98d7850f84de0cbb81d4e4596caa76f94a" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Unix - methods used by ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils :: MM_Unix-ExtUtils :: MakeMaker에서 사용하는 메소드</target>
        </trans-unit>
        <trans-unit id="2f00201cd4f3a6fbb76802bb39ac7a005b8f24e3" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Unix. This is a temporary solution.</source>
          <target state="translated">ExtUtils :: MM_Unix. 이것은 임시 해결책입니다.</target>
        </trans-unit>
        <trans-unit id="5bbe314072fa79cbbe64e27d3c034cb7ecbc2df1" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_VMS</source>
          <target state="translated">ExtUtils::MM_VMS</target>
        </trans-unit>
        <trans-unit id="c328e4aa3661448cfc600baf641ce3b368446553" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_VMS - methods to override UN*X behaviour in ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils :: MM_VMS-ExtUtils :: MakeMaker에서 UN * X 동작을 재정의하는 메소드</target>
        </trans-unit>
        <trans-unit id="cbf6a31d4b30a3697a77d880951a740af6fe002e" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_VOS</source>
          <target state="translated">ExtUtils::MM_VOS</target>
        </trans-unit>
        <trans-unit id="248c1927adaa54c68b53917bcd12ca60bc242150" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_VOS - VOS specific subclass of ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils :: MM_VOS-ExtUtils :: MM_Unix의 VOS 특정 서브 클래스</target>
        </trans-unit>
        <trans-unit id="01b2b6f5d2a1e4c4ed0f2cb32046a9a5d606a04c" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Win32</source>
          <target state="translated">ExtUtils::MM_Win32</target>
        </trans-unit>
        <trans-unit id="31634682156707a3a92d7105825df2529eb4f747" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Win32 - methods to override UN*X behaviour in ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils :: MM_Win32-ExtUtils :: MakeMaker에서 UN * X 동작을 재정의하는 메서드</target>
        </trans-unit>
        <trans-unit id="dd4f189a6328e4d51489c48940b1b07f49808b7b" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Win95</source>
          <target state="translated">ExtUtils::MM_Win95</target>
        </trans-unit>
        <trans-unit id="ef84388c3c22f4aa37ab1ec6dcdd24ddaa801da4" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Win95 - method to customize MakeMaker for Win9X</source>
          <target state="translated">ExtUtils :: MM_Win95-Win9X 용 MakeMaker를 사용자 정의하는 방법</target>
        </trans-unit>
        <trans-unit id="2eeeaab10b029e1825f471249451e612175f476c" translate="yes" xml:space="preserve">
          <source>ExtUtils::MY</source>
          <target state="translated">ExtUtils::MY</target>
        </trans-unit>
        <trans-unit id="a29677c3a7812ab9e27275d7d315711580baa3c5" translate="yes" xml:space="preserve">
          <source>ExtUtils::MY - ExtUtils::MakeMaker subclass for customization</source>
          <target state="translated">ExtUtils :: MY-사용자 정의를위한 ExtUtils :: MakeMaker 서브 클래스</target>
        </trans-unit>
        <trans-unit id="077ce2e66cf34d26fc93548b5aa4b0a365551ad3" translate="yes" xml:space="preserve">
          <source>ExtUtils::MY is a subclass of ExtUtils::MM. Its provided in your Makefile.PL for you to add and override MakeMaker functionality.</source>
          <target state="translated">ExtUtils :: MY는 ExtUtils :: MM의 서브 클래스입니다. MakeMaker 기능을 추가하고 무시할 수 있도록 Makefile.PL에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a8d99fc9d222321dd1dd6e7c9d39239d74c92fb3" translate="yes" xml:space="preserve">
          <source>ExtUtils::MY might turn out to be a temporary solution, but MY won't go away.</source>
          <target state="translated">ExtUtils :: MY는 임시 솔루션으로 판명 될 수 있지만 MY은 사라지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6da8b7232afb53dfdcd9b1c4dde891781d5ce223" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils::MakeMaker</target>
        </trans-unit>
        <trans-unit id="b8052cbade448d159716f320bb8b7066c1c35927" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker (EUMM) is object oriented. Each directory below the current directory that contains a Makefile.PL is treated as a separate object. This makes it possible to write an unlimited number of Makefiles with a single invocation of WriteMakefile().</source>
          <target state="translated">ExtUtils :: MakeMaker (EUMM)는 객체 지향입니다. Makefile.PL을 포함하는 현재 디렉토리 아래의 각 디렉토리는 별도의 오브젝트로 취급됩니다. 이를 통해 WriteMakefile ()을 한 번 호출하여 무제한의 Makefile을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ea38d2404e8bb2fe915619afea85f24fef8c2cc" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker - Create a module Makefile</source>
          <target state="translated">ExtUtils :: MakeMaker-모듈 Makefile 만들기</target>
        </trans-unit>
        <trans-unit id="e6df2289ed559a450ea26d00c0d0e4cee5508740" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker subclass for customization</source>
          <target state="translated">사용자 정의를위한 ExtUtils :: MakeMaker 서브 클래스</target>
        </trans-unit>
        <trans-unit id="c60c158c602a516f81a6ae9bca65b474a071fe74" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker::Config</source>
          <target state="translated">ExtUtils::MakeMaker::Config</target>
        </trans-unit>
        <trans-unit id="d3014ef697f5ada430bc56427a7b9caae4e6e02c" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker::Config - Wrapper around Config.pm</source>
          <target state="translated">ExtUtils :: MakeMaker :: Config-Config.pm 주위 래퍼</target>
        </trans-unit>
        <trans-unit id="9ccd57b3ecc86c99f88666a4cbfa65fcc3d9511f" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker::FAQ</source>
          <target state="translated">ExtUtils::MakeMaker::FAQ</target>
        </trans-unit>
        <trans-unit id="30461ff8ef34cae5ca5dc88e0a98e8273138112a" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker::FAQ - Frequently Asked Questions About MakeMaker</source>
          <target state="translated">ExtUtils :: MakeMaker :: FAQ-MakeMaker에 대한 질문과 대답</target>
        </trans-unit>
        <trans-unit id="c91ea2c313a203d7ca441511bcd463e56db95e2e" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker::Tutorial</source>
          <target state="translated">ExtUtils::MakeMaker::Tutorial</target>
        </trans-unit>
        <trans-unit id="a40c04994e7a37e13af27331a991a5aa646c9b73" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker::Tutorial - Writing a module with MakeMaker</source>
          <target state="translated">ExtUtils :: MakeMaker :: Tutorial-MakeMaker로 모듈 작성</target>
        </trans-unit>
        <trans-unit id="b357eaa10f6891f76e970ffb5f2bf93f495e4a17" translate="yes" xml:space="preserve">
          <source>ExtUtils::Manifest</source>
          <target state="translated">ExtUtils::Manifest</target>
        </trans-unit>
        <trans-unit id="3226afa87ddca4ba7171d22b9f2b78d098b58f76" translate="yes" xml:space="preserve">
          <source>ExtUtils::Manifest - utilities to write and check a MANIFEST file</source>
          <target state="translated">ExtUtils :: Manifest-매니페스트 파일을 작성하고 확인하는 유틸리티</target>
        </trans-unit>
        <trans-unit id="5668766f97bcd05c6bdb7c965133d9727537b625" translate="yes" xml:space="preserve">
          <source>ExtUtils::Manifest exports no functions by default. The following are exported on request</source>
          <target state="translated">ExtUtils :: Manifest는 기본적으로 함수를 내 보내지 않습니다. 다음은 요청시 수출됩니다</target>
        </trans-unit>
        <trans-unit id="3d683dc5b10b650f60d4d9d340eeb5154c9725c7" translate="yes" xml:space="preserve">
          <source>ExtUtils::Miniperl</source>
          <target state="translated">ExtUtils::Miniperl</target>
        </trans-unit>
        <trans-unit id="9fc3f091d177ebdf88e70a7d90d1a0e96a9ebda2" translate="yes" xml:space="preserve">
          <source>ExtUtils::Miniperl - write the C code for perlmain.c</source>
          <target state="translated">ExtUtils :: Miniperl-perlmain.c에 대한 C 코드 작성</target>
        </trans-unit>
        <trans-unit id="1c32c7f84e8dc881e25db6f6d50706131d6d8758" translate="yes" xml:space="preserve">
          <source>ExtUtils::Mkbootstrap</source>
          <target state="translated">ExtUtils::Mkbootstrap</target>
        </trans-unit>
        <trans-unit id="bbfa5e60d2823fa64c959ef9034364b18eddc3e9" translate="yes" xml:space="preserve">
          <source>ExtUtils::Mkbootstrap - make a bootstrap file for use by DynaLoader</source>
          <target state="translated">ExtUtils :: Mkbootstrap-DynaLoader에서 사용할 부트 스트랩 파일 만들기</target>
        </trans-unit>
        <trans-unit id="6719b923f8e283bd552384bd5af81cadfef85883" translate="yes" xml:space="preserve">
          <source>ExtUtils::Mksymlists</source>
          <target state="translated">ExtUtils::Mksymlists</target>
        </trans-unit>
        <trans-unit id="15ab523f4d3c60af2d551125aa18471a39d07e7c" translate="yes" xml:space="preserve">
          <source>ExtUtils::Mksymlists - write linker options files for dynamic extension</source>
          <target state="translated">ExtUtils :: Mksymlists-동적 확장을위한 링커 옵션 파일 작성</target>
        </trans-unit>
        <trans-unit id="dac17ac78f3539cbb386b1e56ee2b529662e80e5" translate="yes" xml:space="preserve">
          <source>ExtUtils::Packlist</source>
          <target state="translated">ExtUtils::Packlist</target>
        </trans-unit>
        <trans-unit id="2fd0b32af3911843b6577751529d4515df509939" translate="yes" xml:space="preserve">
          <source>ExtUtils::Packlist - manage .packlist files</source>
          <target state="translated">ExtUtils :: Packlist-.packlist 파일 관리</target>
        </trans-unit>
        <trans-unit id="b6cb6e0433e264b8d9ae4674f7b9ee20c7cc9a0e" translate="yes" xml:space="preserve">
          <source>ExtUtils::Packlist provides a standard way to manage .packlist files. Functions are provided to read and write .packlist files. The original .packlist format is a simple list of absolute pathnames, one per line. In addition, this package supports an extended format, where as well as a filename each line may contain a list of attributes in the form of a space separated list of key=value pairs. This is used by the installperl script to differentiate between files and links, for example.</source>
          <target state="translated">ExtUtils :: Packlist는 .packlist 파일을 관리하는 표준 방법을 제공합니다. .packlist 파일을 읽고 쓰는 기능이 제공됩니다. 원래 .packlist 형식은 한 줄에 하나씩 절대 경로 이름의 간단한 목록입니다. 또한이 패키지는 확장 형식을 지원합니다. 여기서 파일 이름뿐만 아니라 각 줄은 공백으로 구분 된 키 = 값 쌍 목록 형식의 속성 목록을 포함 할 수 있습니다. 예를 들어 installperl 스크립트에서 파일과 링크를 구별하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c27f6826e3e72b1481e238cd590b927b9a8c7674" translate="yes" xml:space="preserve">
          <source>ExtUtils::ParseXS</source>
          <target state="translated">ExtUtils::ParseXS</target>
        </trans-unit>
        <trans-unit id="a0bc42ea6560aea10d0d6a20cba29d9f0d9456c6" translate="yes" xml:space="preserve">
          <source>ExtUtils::ParseXS - converts Perl XS code into C code</source>
          <target state="translated">ExtUtils :: ParseXS-Perl XS 코드를 C 코드로 변환</target>
        </trans-unit>
        <trans-unit id="f01cb2601da9ca9e6f049c24d0b16efdb7998074" translate="yes" xml:space="preserve">
          <source>ExtUtils::testlib</source>
          <target state="translated">ExtUtils::testlib</target>
        </trans-unit>
        <trans-unit id="c819a99ea2471502c8a0521252e569cacdf6e150" translate="yes" xml:space="preserve">
          <source>ExtUtils::testlib - add blib/* directories to @INC</source>
          <target state="translated">ExtUtils :: testlib-@INC에 blib / * 디렉토리 추가</target>
        </trans-unit>
        <trans-unit id="1a8525beca2f4f9e103dd4931ef378f407141d6e" translate="yes" xml:space="preserve">
          <source>Extend File Glob to Allow Input and Output Files</source>
          <target state="translated">입력 및 출력 파일을 허용하도록 파일 글로브 확장</target>
        </trans-unit>
        <trans-unit id="fab77626f5cddcb8bbb657382d4af81d5cdf9048" translate="yes" xml:space="preserve">
          <source>Extend your pattern's legibility by permitting whitespace and comments. Details in &lt;a href=&quot;#%2fx&quot;&gt;/x&lt;/a&gt;</source>
          <target state="translated">공백과 주석을 허용하여 패턴의 가독성을 확장하십시오. &lt;a href=&quot;#%2fx&quot;&gt;/ x의&lt;/a&gt; 세부 사항</target>
        </trans-unit>
        <trans-unit id="1d44d230ea6fe0935f3b1482cff787c6266b3d3b" translate="yes" xml:space="preserve">
          <source>Extended &lt;code&gt;expect&lt;/code&gt; . This is a hash reference with four allowed keys, &lt;code&gt;mode&lt;/code&gt; , &lt;code&gt;timeout&lt;/code&gt; , &lt;code&gt;reuse&lt;/code&gt; , and &lt;code&gt;talk&lt;/code&gt; .</source>
          <target state="translated">확장 &lt;code&gt;expect&lt;/code&gt; . 이것은 허용되는 4 개의 키, &lt;code&gt;mode&lt;/code&gt; , &lt;code&gt;timeout&lt;/code&gt; , &lt;code&gt;reuse&lt;/code&gt; 및 &lt;code&gt;talk&lt;/code&gt; 가있는 해시 참조입니다 .</target>
        </trans-unit>
        <trans-unit id="efc98640815d67fe8a62500e0c5368b07039dddc" translate="yes" xml:space="preserve">
          <source>Extended Bracketed Character Classes</source>
          <target state="translated">확장 된 브라켓 문자 클래스</target>
        </trans-unit>
        <trans-unit id="08ad66702e505f4acfeb7ef02a28aef2a444692f" translate="yes" xml:space="preserve">
          <source>Extended Grapheme Clusters (Logical characters)</source>
          <target state="translated">확장 그래프 클러스터 (논리 문자)</target>
        </trans-unit>
        <trans-unit id="b408f65a0dc6251545ba8a1cae00a09cef180586" translate="yes" xml:space="preserve">
          <source>Extended Patterns</source>
          <target state="translated">확장 패턴</target>
        </trans-unit>
        <trans-unit id="57638586a902beff6d532df64e0c7307238ec6d1" translate="yes" xml:space="preserve">
          <source>Extended description and discussion of the program or functions, or the body of the documentation for man pages that document something else. If particularly long, it's a good idea to break this up into subsections &lt;code&gt;=head2&lt;/code&gt; directives like:</source>
          <target state="translated">프로그램이나 기능에 대한 자세한 설명과 토론, 또는 다른 것을 문서화하는 매뉴얼 페이지의 설명서 본문. 특히 길다면 이것을 다음 과 같은 하위 섹션 &lt;code&gt;=head2&lt;/code&gt; 지시어 로 나누는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="e1eee637af0775263c15116e6a9a092f2dd1ed43" translate="yes" xml:space="preserve">
          <source>Extended integer, Perl style. This can be either an optional leading plus or minus sign, followed by a sequence of digits, or an octal string (a zero, optionally followed by '0', '1', .. '7'), or a hexadecimal string (&lt;code&gt;0x&lt;/code&gt; followed by '0' .. '9', 'a' .. 'f', case insensitive), or a binary string (&lt;code&gt;0b&lt;/code&gt; followed by a series of '0' and '1').</source>
          <target state="translated">확장 정수, Perl 스타일. 선택적인 선행 더하기 또는 빼기 부호, 그 뒤에 일련의 숫자 또는 8 진 문자열 (0, 선택적으로 '0', '1', .. '7') 또는 16 진 문자열 ( &lt;code&gt;0x&lt;/code&gt; 뒤에 '0'.. '9', 'a'.. 'f', 대소 문자 구분 안 함) 또는 이진 문자열 ( &lt;code&gt;0b&lt;/code&gt; 뒤에 일련의 '0'및 '1') 이옵니다 .</target>
        </trans-unit>
        <trans-unit id="7f8a27621bd1b83106ef3b26b5852eb1064f0fc5" translate="yes" xml:space="preserve">
          <source>Extended processing of command line options</source>
          <target state="translated">명령 줄 옵션의 확장 된 처리</target>
        </trans-unit>
        <trans-unit id="5db438e4dc97c2c680eb06228229b5484c1bdab3" translate="yes" xml:space="preserve">
          <source>Extending and Embedding Test::More</source>
          <target state="translated">테스트 확장 및 포함 :: 더</target>
        </trans-unit>
        <trans-unit id="8093cc064296db81eb0f5514264d7ee6d955b145" translate="yes" xml:space="preserve">
          <source>Extending it to csh patterns is left as an exercise to the reader.</source>
          <target state="translated">그것을 csh 패턴으로 확장하는 것은 독자에게 연습으로 남습니다.</target>
        </trans-unit>
        <trans-unit id="4e50bd25f128e6a96c634dc99854b32ea96ab716" translate="yes" xml:space="preserve">
          <source>Extending your Extension</source>
          <target state="translated">확장 연장</target>
        </trans-unit>
        <trans-unit id="4f8331dd312ba43f266e8a83a2d73cbbbec52b3f" translate="yes" xml:space="preserve">
          <source>Extension Layers</source>
          <target state="translated">확장 레이어</target>
        </trans-unit>
        <trans-unit id="7e80c98508d4f62822b0432554091a536a41d48e" translate="yes" xml:space="preserve">
          <source>Extension Modules</source>
          <target state="translated">확장 모듈</target>
        </trans-unit>
        <trans-unit id="bd951e4e9e05b88a206b50063022ae727663d6c9" translate="yes" xml:space="preserve">
          <source>Extension based on</source>
          <target state="translated">기반 확장</target>
        </trans-unit>
        <trans-unit id="67518e197246f71238efe738515b0409050e6007" translate="yes" xml:space="preserve">
          <source>Extension based on _.h_ and _.c_ files</source>
          <target state="translated">_.h_ 및 _.c_ 파일 기반 확장</target>
        </trans-unit>
        <trans-unit id="4711cbf045a57cbff83b6f9f271bd795fbb6b53d" translate="yes" xml:space="preserve">
          <source>Extension methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cce4d271f69e77a8f0acdb625f0076753f28069c" translate="yes" xml:space="preserve">
          <source>Extension modules are written in C (or a mix of Perl and C). They are usually dynamically loaded into Perl if and when you need them, but may also be linked in statically. Supported extension modules include Socket, Fcntl, and POSIX.</source>
          <target state="translated">확장 모듈은 C (또는 Perl과 C의 혼합)로 작성됩니다. 그것들은 필요할 때 그리고 필요할 때 일반적으로 Perl에 동적으로로드되지만 정적으로 연결될 수도 있습니다. 지원되는 확장 모듈에는 Socket, Fcntl 및 POSIX가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d5c486c72e2c41ab9d29ece60988b5356674e74f" translate="yes" xml:space="preserve">
          <source>Extension modules can also hook into the Perl parser to define new kinds of compound statements. These are introduced by a keyword which the extension recognizes, and the syntax following the keyword is defined entirely by the extension. If you are an implementor, see &lt;a href=&quot;perlapi#PL_keyword_plugin&quot;&gt;PL_keyword_plugin in perlapi&lt;/a&gt; for the mechanism. If you are using such a module, see the module's documentation for details of the syntax that it defines.</source>
          <target state="translated">확장 모듈은 Perl 구문 분석기에 연결하여 새로운 종류의 복합 명령문을 정의 할 수도 있습니다. 이것들은 확장 기능이 인식하는 키워드에 의해 소개되며, 키워드 다음의 구문은 확장 기능에 의해 완전히 정의됩니다. 구현 &lt;a href=&quot;perlapi#PL_keyword_plugin&quot;&gt;자인&lt;/a&gt; 경우 메커니즘 에 대해서는 perlapi의 PL_keyword_plugin 을 참조하십시오 . 이러한 모듈을 사용하는 경우 해당 모듈에서 정의한 구문에 대한 자세한 내용은 모듈 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="17db2bf16378aa10db2e67a8c2600f3a25122fec" translate="yes" xml:space="preserve">
          <source>Extension modules can also hook into the Perl parser to define new kinds of keyword-headed expression. These may look like functions, but may also look completely different. The syntax following the keyword is defined entirely by the extension. If you are an implementor, see &lt;a href=&quot;perlapi#PL_keyword_plugin&quot;&gt;PL_keyword_plugin in perlapi&lt;/a&gt; for the mechanism. If you are using such a module, see the module's documentation for details of the syntax that it defines.</source>
          <target state="translated">확장 모듈은 Perl 파서에 연결하여 새로운 종류의 키워드 머리 식을 정의 할 수도 있습니다. 이것들은 기능처럼 보일 수도 있지만 완전히 다르게 보일 수도 있습니다. 키워드 다음의 구문은 전적으로 확장자로 정의됩니다. 구현 &lt;a href=&quot;perlapi#PL_keyword_plugin&quot;&gt;자인&lt;/a&gt; 경우 메커니즘 에 대해서는 perlapi의 PL_keyword_plugin 을 참조하십시오 . 이러한 모듈을 사용하는 경우 해당 모듈에서 정의한 구문에 대한 자세한 내용은 모듈 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="656bcfe284e2da39c77d4fdab55b16ad3c654719" translate="yes" xml:space="preserve">
          <source>Extensions</source>
          <target state="translated">Extensions</target>
        </trans-unit>
        <trans-unit id="6e975483dac372a5ca9dfd4b8e5e57b37a1180dd" translate="yes" xml:space="preserve">
          <source>Extensions and XS are, in theory, buildable by anyone using free tools. In practice, many don't, as users of the Acorn platform are used to binary distributions. MakeMaker does run, but no available make currently copes with MakeMaker's makefiles; even if and when this should be fixed, the lack of a Unix-like shell will cause problems with makefile rules, especially lines of the form &lt;code&gt;cd
sdbm &amp;amp;&amp;amp; make all&lt;/code&gt; , and anything using quoting.</source>
          <target state="translated">확장 기능과 XS는 이론적으로 무료 도구를 사용하는 모든 사람이 빌드 할 수 있습니다. 실제로, Acorn 플랫폼의 사용자가 바이너리 배포판에 익숙하기 때문에 많은 사람들이 그렇지 않습니다. MakeMaker는 실행되지만 현재 사용 가능한 make는 MakeMaker의 makefile에 대응하지 않습니다. 이 문제를 해결해야 할 때에도 유닉스 계열 쉘이 없으면 makefile 규칙, 특히 &lt;code&gt;cd sdbm &amp;amp;&amp;amp; make all&lt;/code&gt; 형식의 줄 과 인용 부호를 사용하는 모든 문제가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="f8be19ac765682f953ef7dfbb23fec79e7869c76" translate="yes" xml:space="preserve">
          <source>Extensions may be built either using the contents of the perl source directory tree or from the installed perl library. The recommended way is to build extensions after you have run 'make install' on perl itself. You can do that in any directory on your hard disk that is not below the perl source tree. The support for extensions below the ext directory of the perl distribution is only good for the standard extensions that come with perl.</source>
          <target state="translated">확장은 perl 소스 디렉토리 트리의 내용을 사용하거나 설치된 perl 라이브러리에서 빌드 할 수 있습니다. 권장되는 방법은 perl 자체에서 'make install'을 실행 한 후 확장을 빌드하는 것입니다. 펄 소스 트리 아래에 있지 않은 하드 디스크의 모든 디렉토리에서이를 수행 할 수 있습니다. perl 배포의 ext 디렉토리 아래 확장에 대한 지원은 perl과 함께 제공되는 표준 확장에만 적합합니다.</target>
        </trans-unit>
        <trans-unit id="fd1105050ae42d352634f9a22fd2cfbe7c3340ac" translate="yes" xml:space="preserve">
          <source>Extensions.U</source>
          <target state="translated">Extensions.U</target>
        </trans-unit>
        <trans-unit id="8e77bd8de5230e7d94a54f34b54e4ee866ebaf07" translate="yes" xml:space="preserve">
          <source>External Subroutines (XS)</source>
          <target state="translated">외부 서브 루틴 (XS)</target>
        </trans-unit>
        <trans-unit id="fe58f6fb5713c9d9970ba20c8c7e99ac12d8ebd1" translate="yes" xml:space="preserve">
          <source>External scripts may be called by their basename. Perl will try the same extensions as when processing &lt;b&gt;-S&lt;/b&gt; command-line switch.</source>
          <target state="translated">외부 스크립트는 기본 이름으로 호출 할 수 있습니다. Perl은 &lt;b&gt;-S&lt;/b&gt; 명령 행 스위치를 처리 할 때와 동일한 확장을 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="ac98225101654b1670f972aaf6165f07d86a4dc2" translate="yes" xml:space="preserve">
          <source>External scripts starting with &lt;code&gt;#!&lt;/code&gt; or &lt;code&gt;extproc &lt;/code&gt; will be executed directly, without calling the shell, by calling the program specified on the rest of the first line.</source>
          <target state="translated">&lt;code&gt;#!&lt;/code&gt; 시작하는 외부 스크립트 또는 &lt;code&gt;extproc &lt;/code&gt; 은 쉘을 호출하지 않고 첫 번째 줄의 나머지 부분에 지정된 프로그램을 호출하여 직접 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="26bf182753057236397eb723fd4891db5f117a3e" translate="yes" xml:space="preserve">
          <source>External subroutines (XSUBs) that maintain their own global state may not work correctly. Such XSUBs will either need to maintain locks to protect simultaneous access to global data from different pseudo-processes, or maintain all their state on the Perl symbol table, which is copied naturally when fork() is called. A callback mechanism that provides extensions an opportunity to clone their state will be provided in the near future.</source>
          <target state="translated">자체 글로벌 상태를 유지하는 외부 서브 루틴 (XSUB)은 올바르게 작동하지 않을 수 있습니다. 이러한 XSUB는 다른 의사 프로세스에서 글로벌 데이터에 대한 동시 액세스를 보호하기 위해 잠금을 유지하거나 forl ()가 호출 될 때 자연스럽게 복사되는 Perl 기호 테이블에서 모든 상태를 유지해야합니다. 확장 기능에 상태를 복제 할 수있는 기회를 제공하는 콜백 메커니즘이 조만간 제공 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="fc2399f06f4a8800f1e9f8c63e75b404573137c6" translate="yes" xml:space="preserve">
          <source>Extname</source>
          <target state="translated">Extname</target>
        </trans-unit>
        <trans-unit id="38bd9c2b38d963363075f657df2649a5a865d34f" translate="yes" xml:space="preserve">
          <source>Extra RECNO Methods</source>
          <target state="translated">여분의 RECNO 방법</target>
        </trans-unit>
        <trans-unit id="f428c72b95856a35d58cb6523d1d9bf0d7e2e713" translate="yes" xml:space="preserve">
          <source>Extra debugging of how tries execute.</source>
          <target state="translated">시도 실행 방법에 대한 추가 디버깅</target>
        </trans-unit>
        <trans-unit id="8d0f7f868e14cfcf2986def25df2bc4196200327" translate="yes" xml:space="preserve">
          <source>Extra layers can be inserted to process the data as it flows through. This was the driving need for including the scheme in perl 5.7.0+ - we needed a mechanism to allow data to be translated between perl's internal encoding (conceptually at least Unicode as UTF-8), and the &quot;native&quot; format used by the system. This is provided by the &quot;:encoding(xxxx)&quot; layer which typically sits above the buffering layer.</source>
          <target state="translated">데이터가 통과 할 때 데이터를 처리하기 위해 추가 레이어를 삽입 할 수 있습니다. 이것은 perl 5.7.0+의 체계를 포함시키기위한 원동력이되었습니다. 우리는 perl의 내부 인코딩 (개념적으로는 UTF-8과 같은 개념적으로 최소한 UTF-8)과 체계. 이것은 일반적으로 버퍼링 레이어 위에있는 &quot;: encoding (xxxx)&quot;레이어에 의해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="678bd1bdccc15e114b793e04d18d631885eca63c" translate="yes" xml:space="preserve">
          <source>Extract delimited text sequences from strings.</source>
          <target state="translated">문자열에서 구분 된 텍스트 시퀀스를 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="7254948dbbd318f1e97d0a1eeb40a1eb2d41c79b" translate="yes" xml:space="preserve">
          <source>Extract it like this</source>
          <target state="translated">이렇게 추출</target>
        </trans-unit>
        <trans-unit id="05a2f0e61aa11822c7799b10cf19bd9f231551af" translate="yes" xml:space="preserve">
          <source>Extract it to a spaceless path but not into the perl build source. Don't extract it into the same directory as celib. Make a copy of the &quot;wince-arm-pocket-wce300&quot; folder and rename the copy to &quot;wince-arm-pocket-wce400&quot;. This is a hack so we can build a CE 4.0 binary by linking in CE 3.0 ARM asm; the linker doesn't care. Windows Mobile/WinCE are backwards compatible with machine code like Desktop Windows.</source>
          <target state="translated">공백이없는 경로로 추출하지만 perl 빌드 소스에는 추출하지 마십시오. celib와 동일한 디렉토리에 추출하지 마십시오. &quot;wince-arm-pocket-wce300&quot;폴더의 사본을 작성하고 사본의 이름을 &quot;wince-arm-pocket-wce400&quot;으로 바꾸십시오. 이것은 해킹이므로 CE 3.0 ARM asm에서 링크하여 CE 4.0 바이너리를 빌드 할 수 있습니다. 링커는 상관하지 않습니다. Windows Mobile / WinCE는 데스크톱 Windows와 같은 기계 코드와 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="7749ca362c5039000e30519eec908556e69a793e" translate="yes" xml:space="preserve">
          <source>Extract it to a spaceless path but not into the perl build source. I call this directory &quot;celib-palm-3.0&quot; but in the GitHub snapshot it will be called &quot;celib-master&quot;. Make a copy of the &quot;wince-arm-pocket-wce300-release&quot; folder and rename the copy to &quot;wince-arm-pocket-wce400&quot;. This is a hack so we can build a CE 4.0 binary by linking in CE 3.0 ARM asm; the linker doesn't care. Windows Mobile/WinCE are backwards compatible with machine code like Desktop Windows.</source>
          <target state="translated">공백이없는 경로로 추출하지만 perl 빌드 소스에는 추출하지 마십시오. 이 디렉토리를 &quot;celib-palm-3.0&quot;이라고 부르지 만 GitHub 스냅 샷에서는 &quot;celib-master&quot;라고합니다. &quot;wince-arm-pocket-wce300-release&quot;폴더의 사본을 작성하고 사본 이름을 &quot;wince-arm-pocket-wce400&quot;으로 바꾸십시오. 이것은 해킹이므로 CE 3.0 ARM asm에서 링크하여 CE 4.0 바이너리를 빌드 할 수 있습니다. 링커는 상관하지 않습니다. Windows Mobile / WinCE는 데스크톱 Windows와 같은 기계 코드와 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="6a5aa60c177bb5d75235a8c111f9e4b6cea8ac1c" translate="yes" xml:space="preserve">
          <source>Extract selected sections of POD from input</source>
          <target state="translated">입력에서 선택된 POD 섹션 추출</target>
        </trans-unit>
        <trans-unit id="48348ed6315b959bdb6c19c5f46693033fe9a289" translate="yes" xml:space="preserve">
          <source>Extract this object, optionally to an alternative name.</source>
          <target state="translated">선택적으로 대체 이름으로이 오브젝트를 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="700d36da6316894ea4553b7a4764bc2e9b2ffb63" translate="yes" xml:space="preserve">
          <source>Extracted from core distribution for publishing on the CPAN by S&amp;eacute;bastien Aperghis-Tramoni &amp;lt;sebastien (at) aperghis.net&amp;gt;.</source>
          <target state="translated">S&amp;eacute;bastien Aperghis-Tramoni &amp;lt;sebastien (at) aperghis.net&amp;gt;에 의해 CPAN에 게시하기 위해 핵심 배포본에서 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="33342b226b64c6cbc40d180e3ba186ad44a5f06f" translate="yes" xml:space="preserve">
          <source>Extracting matches</source>
          <target state="translated">일치 추출</target>
        </trans-unit>
        <trans-unit id="16e9f64b08e09da9325dc889d58611a8376664da" translate="yes" xml:space="preserve">
          <source>Extracts a substring out of EXPR and returns it. First character is at offset zero. If OFFSET is negative, starts that far back from the end of the string. If LENGTH is omitted, returns everything through the end of the string. If LENGTH is negative, leaves that many characters off the end of the string.</source>
          <target state="translated">EXPR에서 하위 문자열을 추출하여 리턴합니다. 첫 문자는 오프셋 0입니다. OFFSET이 음수이면 문자열 끝에서 멀리 시작합니다. LENGTH를 생략하면 문자열 끝까지 모든 것을 반환합니다. LENGTH가 음수이면 문자열 끝에 많은 문자를 남겨 둡니다.</target>
        </trans-unit>
        <trans-unit id="7e02013b2bc8b8b15efdd928d9932b054c7620a2" translate="yes" xml:space="preserve">
          <source>Extracts the contents of the tar file. The first argument can either be the name of the tar file to create or a reference to an open file handle (e.g. a GLOB reference). All relative paths in the tar file will be created underneath the current working directory.</source>
          <target state="translated">tar 파일의 내용을 추출합니다. 첫 번째 인수는 작성할 tar 파일의 이름이거나 열린 파일 핸들에 대한 참조 (예 : GLOB 참조) 일 수 있습니다. tar 파일의 모든 상대 경로는 현재 작업 디렉토리 아래에 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="885f6e090c877a36591aaa902dd00c6dd7b9efec" translate="yes" xml:space="preserve">
          <source>Extras.U</source>
          <target state="translated">Extras.U</target>
        </trans-unit>
        <trans-unit id="42f25b6a320c5687fd271f37b1ee97e7d69228f2" translate="yes" xml:space="preserve">
          <source>Extremely similar to open2(), open3() spawns the given $cmd and connects CHLD_OUT for reading from the child, CHLD_IN for writing to the child, and CHLD_ERR for errors. If CHLD_ERR is false, or the same file descriptor as CHLD_OUT, then STDOUT and STDERR of the child are on the same filehandle (this means that an autovivified lexical cannot be used for the STDERR filehandle, see SYNOPSIS). The CHLD_IN will have autoflush turned on.</source>
          <target state="translated">open2 ()와 매우 유사한 open3 ()은 주어진 $ cmd를 생성하고 자식에서 읽기위한 CHLD_OUT, 자식에게 쓰기위한 CHLD_IN, 오류에 대한 CHLD_ERR을 연결합니다. CHLD_ERR이 false이거나 CHLD_OUT과 동일한 파일 디스크립터 인 경우, 하위의 STDOUT 및 STDERR이 동일한 파일 핸들에 있습니다 (이는 자동 활성화 어휘를 STDERR 파일 핸들에 사용할 수 없음을 의미합니다. 시놉시스 참조). CHLD_IN은 자동 세척 기능을 켤 것입니다.</target>
        </trans-unit>
        <trans-unit id="d2122187dffca50e0b79b010ea05ebfa6a4d1181" translate="yes" xml:space="preserve">
          <source>Extshortname</source>
          <target state="translated">Extshortname</target>
        </trans-unit>
        <trans-unit id="e69f20e9f683920d3fb4329abd951e878b1f9372" translate="yes" xml:space="preserve">
          <source>F</source>
          <target state="translated">F</target>
        </trans-unit>
        <trans-unit id="ade1d38216915151ba7db0ce62f3199d7bf8e743" translate="yes" xml:space="preserve">
          <source>F:/bin</source>
          <target state="translated">F:/bin</target>
        </trans-unit>
        <trans-unit id="03688ba6aa340b87549088aa5739944cb6b1dc73" translate="yes" xml:space="preserve">
          <source>FAQ</source>
          <target state="translated">FAQ</target>
        </trans-unit>
        <trans-unit id="65569c995a4785c8ee0ddac72f9a5d5496ad6056" translate="yes" xml:space="preserve">
          <source>FAQs, tricks and tips for &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; 대한 FAQ, 요령 및 팁 .</target>
        </trans-unit>
        <trans-unit id="dec5a3344b6b1da0ebe322bd0a2dfc8eb4528955" translate="yes" xml:space="preserve">
          <source>FATAL errors will cause the program to halt (&lt;code&gt;croak&lt;/code&gt; ), since the problem is so severe that it would be dangerous to continue. (This can always be trapped with &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, but it's not a good idea. Under the circumstances, dying is the best thing to do).</source>
          <target state="translated">치명적 오류는 문제가 너무 심해서 계속 진행하는 것이 위험하기 때문에 프로그램을 중지 ( &lt;code&gt;croak&lt;/code&gt; )시킵니다. (이것은 항상 &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 로 갇힐 수 있지만 좋은 생각은 아닙니다. 상황에서 죽는 것이 가장 좋습니다.)</target>
        </trans-unit>
        <trans-unit id="69754788a4c6beb4ec0ff140aa5c158dca3bfa2a" translate="yes" xml:space="preserve">
          <source>FB_CROAK</source>
          <target state="translated">FB_CROAK</target>
        </trans-unit>
        <trans-unit id="b626cf33b4a041c5ce4d521b41bf3a7b58bd485d" translate="yes" xml:space="preserve">
          <source>FB_DEFAULT</source>
          <target state="translated">FB_DEFAULT</target>
        </trans-unit>
        <trans-unit id="757934dd26eb29cb3152a5f387ec3d2edb168405" translate="yes" xml:space="preserve">
          <source>FB_PERLQQ FB_HTMLCREF FB_XMLCREF</source>
          <target state="translated">FB_PERLQQ FB_HTMLCREF FB_XMLCREF</target>
        </trans-unit>
        <trans-unit id="0a74cbd8c5cb0982de1a9bcfa6850e000455346d" translate="yes" xml:space="preserve">
          <source>FB_QUIET</source>
          <target state="translated">FB_QUIET</target>
        </trans-unit>
        <trans-unit id="0dd7f31fe0e5f67c669f4440fb273121e4c806e4" translate="yes" xml:space="preserve">
          <source>FB_WARN</source>
          <target state="translated">FB_WARN</target>
        </trans-unit>
        <trans-unit id="8e8b3f3bb48e9f1566f046dd9abec5d58654f4a5" translate="yes" xml:space="preserve">
          <source>FCNTL</source>
          <target state="translated">FCNTL</target>
        </trans-unit>
        <trans-unit id="47dadeeeb2bc9f5421eaa6bbbe50810a393d4c66" translate="yes" xml:space="preserve">
          <source>FEATURE BUNDLES</source>
          <target state="translated">기능 번들</target>
        </trans-unit>
        <trans-unit id="ec8e87c2f7d4da8aaca114d6270ea98cb522428f" translate="yes" xml:space="preserve">
          <source>FEATURES = less-&amp;gt;of()</source>
          <target state="translated">특징 = less-&amp;gt; of ()</target>
        </trans-unit>
        <trans-unit id="489edc9160737f1f5321c8439e0d90f85d95108c" translate="yes" xml:space="preserve">
          <source>FEEDBACK</source>
          <target state="translated">FEEDBACK</target>
        </trans-unit>
        <trans-unit id="c895bf1dc50f257bb516434bac2edbda6ee48875" translate="yes" xml:space="preserve">
          <source>FETCHSIZE and STORESIZE are used to provide &lt;code&gt;$#array&lt;/code&gt; and equivalent &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar(@array)&lt;/a&gt;&lt;/code&gt; access.</source>
          <target state="translated">FETCHSIZE 및 STORESIZE는 &lt;code&gt;$#array&lt;/code&gt; 및 동등한 &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar(@array)&lt;/a&gt;&lt;/code&gt; 액세스 를 제공하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="3f799155fde6a8df0e53471e8ebc22e51aee5205" translate="yes" xml:space="preserve">
          <source>FIFO (named pipe).</source>
          <target state="translated">FIFO (명명 된 파이프).</target>
        </trans-unit>
        <trans-unit id="b4915d3a7ef82abdf96f2b5042452a69b2ea344c" translate="yes" xml:space="preserve">
          <source>FILE</source>
          <target state="translated">FILE</target>
        </trans-unit>
        <trans-unit id="65f4de99dee3e085c7a32fb60bb9eaf5617a70cd" translate="yes" xml:space="preserve">
          <source>FILEHANDLE may be an expression whose value can be used as an indirect filehandle, usually the real filehandle name or an autovivified handle.</source>
          <target state="translated">FILEHANDLE은 값이 간접 파일 핸들, 일반적으로 실제 파일 핸들 이름 또는 자동 활성화 핸들로 사용될 수있는 표현식 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb6788548cba81bf001baaa9f81e8e517a13289b" translate="yes" xml:space="preserve">
          <source>FILEHANDLE may be an expression whose value gives the name of the actual filehandle. Thus:</source>
          <target state="translated">FILEHANDLE은 값이 실제 파일 핸들의 이름을 제공하는 표현식 일 수 있습니다. 그러므로:</target>
        </trans-unit>
        <trans-unit id="9fb4f1d17ef878fbfbe96076658397ad86bd5264" translate="yes" xml:space="preserve">
          <source>FILES</source>
          <target state="translated">FILES</target>
        </trans-unit>
        <trans-unit id="9632a4abb88bdcc736407e7934b81d79fbb78781" translate="yes" xml:space="preserve">
          <source>FINDING YOUR WAY AROUND</source>
          <target state="translated">주변 길 찾기</target>
        </trans-unit>
        <trans-unit id="059c8321d5ceafe9f97e631f972d839dbaf5b1d5" translate="yes" xml:space="preserve">
          <source>FIONREAD requires a filehandle connected to a stream, meaning that sockets, pipes, and tty devices work, but</source>
          <target state="translated">FIONREAD에는 스트림에 연결된 파일 핸들이 필요합니다. 즉 소켓, 파이프 및 tty 장치는 작동하지만</target>
        </trans-unit>
        <trans-unit id="f1c14024d456e253b8073d3a89752d6ea8200326" translate="yes" xml:space="preserve">
          <source>FIRSTKEY and NEXTKEY methods go through the keys which were already read, not all the possible keys of the hash.</source>
          <target state="translated">FIRSTKEY 및 NEXTKEY 메서드는 해시의 가능한 모든 키가 아니라 이미 읽은 키를 통과합니다.</target>
        </trans-unit>
        <trans-unit id="df2badbb417734bff12c2cd1ce6852a857e8b49b" translate="yes" xml:space="preserve">
          <source>FLAG VALUES</source>
          <target state="translated">플래그 값</target>
        </trans-unit>
        <trans-unit id="cd98ae36981ee80a267c314ec60000c7f9d30870" translate="yes" xml:space="preserve">
          <source>FLOAT</source>
          <target state="translated">FLOAT</target>
        </trans-unit>
        <trans-unit id="73449ef74937cb8a715e6e9b0bcd4bb4e19f070f" translate="yes" xml:space="preserve">
          <source>FLOATING-POINT ENVIRONMENT</source>
          <target state="translated">부동 소수점 환경</target>
        </trans-unit>
        <trans-unit id="a27448e44064a3e71d47db864ec6590331ae24db" translate="yes" xml:space="preserve">
          <source>FOR MODULE AUTHORS</source>
          <target state="translated">모듈 저자</target>
        </trans-unit>
        <trans-unit id="197bc57f95ecd67e69c42b441c686af9b56b66a3" translate="yes" xml:space="preserve">
          <source>FORMAT CONTROL ATTRIBUTES</source>
          <target state="translated">형식 관리 속성</target>
        </trans-unit>
        <trans-unit id="8c6077236f8ea6885b307ca6cfaf9346871ddc06" translate="yes" xml:space="preserve">
          <source>FORMAT is the</source>
          <target state="translated">형식은</target>
        </trans-unit>
        <trans-unit id="ec5814e0479ce0db049db2be1669d632fac6aa3f" translate="yes" xml:space="preserve">
          <source>FORMATTERS</source>
          <target state="translated">FORMATTERS</target>
        </trans-unit>
        <trans-unit id="d660f8cca36ec17fdb320607d854df06b0b01126" translate="yes" xml:space="preserve">
          <source>FORMATTING SPECIFICATIONS</source>
          <target state="translated">사양 사양</target>
        </trans-unit>
        <trans-unit id="d8b9930b588cfbff9ca8c2607a532bbe28f9a623" translate="yes" xml:space="preserve">
          <source>FORWARD COMPATIBILITY</source>
          <target state="translated">앞으로의 호환성</target>
        </trans-unit>
        <trans-unit id="ac03725b51e3b18352fbcf923063a48e12b26314" translate="yes" xml:space="preserve">
          <source>FREQUENTLY ASKED QUESTIONS</source>
          <target state="translated">자주 묻는 질문</target>
        </trans-unit>
        <trans-unit id="6496f6c84e390b28e94f50597c1286993f14328b" translate="yes" xml:space="preserve">
          <source>FROM THE COMMAND LINE</source>
          <target state="translated">명령 줄에서</target>
        </trans-unit>
        <trans-unit id="8872dc813208d15328cb72820a6753a9ddec0776" translate="yes" xml:space="preserve">
          <source>FTP Archives for Perl Modules:</source>
          <target state="translated">Perl 모듈 용 FTP 아카이브 :</target>
        </trans-unit>
        <trans-unit id="13add5d8be99c7156e522d0830855d1224598c3d" translate="yes" xml:space="preserve">
          <source>FTP Client class</source>
          <target state="translated">FTP 클라이언트 클래스</target>
        </trans-unit>
        <trans-unit id="99c6dd16cd765c469c507fe9b03fc9fa2810bf50" translate="yes" xml:space="preserve">
          <source>FTP Client data connection class</source>
          <target state="translated">FTP 클라이언트 데이터 연결 클래스</target>
        </trans-unit>
        <trans-unit id="d6fc2619f665877d169e9fca0155476e2dbf2fb4" translate="yes" xml:space="preserve">
          <source>FTP servers can work in passive or active mode. Active mode is when you want to transfer data you have to tell the server the address and port to connect to. Passive mode is when the server provide the address and port and you establish the connection.</source>
          <target state="translated">FTP 서버는 수동 또는 활성 모드에서 작동 할 수 있습니다. 활성 모드는 데이터를 전송하려는 경우 서버에 연결할 주소와 포트를 알려야합니다. 수동 모드는 서버가 주소와 포트를 제공하고 연결을 설정하는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="d4fa87de490d6c1ca8c48ecbbdf1e0921be54835" translate="yes" xml:space="preserve">
          <source>FTP stands for File Transfer Protocol. It is a way of transferring files between networked machines. The protocol defines a client (whose commands are provided by this module) and a server (not implemented in this module). Communication is always initiated by the client, and the server responds with a message and a status code (and sometimes with data).</source>
          <target state="translated">FTP는 파일 전송 프로토콜을 나타냅니다. 네트워크 컴퓨터간에 파일을 전송하는 방법입니다. 프로토콜은 클라이언트 (이 모듈에서 명령을 제공하는 클라이언트)와 서버 (이 모듈에서 구현되지 않음)를 정의합니다. 통신은 항상 클라이언트에 의해 시작되며 서버는 메시지 및 상태 코드 (때로는 데이터)로 응답합니다.</target>
        </trans-unit>
        <trans-unit id="63425456f14a800f08b688a005e2e85f84241751" translate="yes" xml:space="preserve">
          <source>FUNCTION</source>
          <target state="translated">FUNCTION</target>
        </trans-unit>
        <trans-unit id="f8bdd6d62e62677a02e5dc952820aa27e8b6384e" translate="yes" xml:space="preserve">
          <source>FUNCTION DIFFERENCES</source>
          <target state="translated">기능 차이</target>
        </trans-unit>
        <trans-unit id="9633f16041f6cad3a579e87f0baed24ec359c5c9" translate="yes" xml:space="preserve">
          <source>FUNCTION IMPLEMENTATIONS</source>
          <target state="translated">기능 구현</target>
        </trans-unit>
        <trans-unit id="a54261bf699a2c75d951095758dc3d3d9845baef" translate="yes" xml:space="preserve">
          <source>FUNCTION SPECIFIC NOTES</source>
          <target state="translated">기능별 참고 사항</target>
        </trans-unit>
        <trans-unit id="e0639bb5342fee4e8d445f26b3a0278cc2fe4679" translate="yes" xml:space="preserve">
          <source>FUNCTIONS</source>
          <target state="translated">FUNCTIONS</target>
        </trans-unit>
        <trans-unit id="256018c65b4eb744f4377a13a19d91631c659dd4" translate="yes" xml:space="preserve">
          <source>FUNCTIONS API</source>
          <target state="translated">기능 API</target>
        </trans-unit>
        <trans-unit id="a8b599c6c2d22b5945b690bad2739bb459f033f6" translate="yes" xml:space="preserve">
          <source>FUNCTIONS FOR REFERENCES</source>
          <target state="translated">참조를위한 기능</target>
        </trans-unit>
        <trans-unit id="546e2c9a8685e17aa5c5cf752632f067b0b1ac92" translate="yes" xml:space="preserve">
          <source>FURTHER READING</source>
          <target state="translated">추가 읽기</target>
        </trans-unit>
        <trans-unit id="9d0a833e883c67f6559509334a96f848be9e54ed" translate="yes" xml:space="preserve">
          <source>Facilities</source>
          <target state="translated">Facilities</target>
        </trans-unit>
        <trans-unit id="0b8af03a8ba1e4c01fa3396b94568da207e2f7a3" translate="yes" xml:space="preserve">
          <source>Factory for creating TAP::Parser output objects</source>
          <target state="translated">TAP :: Parser 출력 객체를 생성하는 팩토리</target>
        </trans-unit>
        <trans-unit id="607919027b2a9b94755ff24dee0db004455fddf6" translate="yes" xml:space="preserve">
          <source>Failover to different communication modes by Nick Williams &amp;lt;</source>
          <target state="translated">Nick Williams의 다른 통신 모드로 장애 조치 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="c563018d20418391a3a741571c4b388d5e704fb2" translate="yes" xml:space="preserve">
          <source>Fails if the Perl DLL found via &lt;code&gt;BEGINLIBPATH&lt;/code&gt; is different from what was loaded on step 1; e.g., another process could have loaded it from &lt;code&gt;LIBPATH&lt;/code&gt; or from a different value of &lt;code&gt;BEGINLIBPATH&lt;/code&gt; . In these cases one needs to modify the setting of the system so that this other process either does not run, or loads the DLL from &lt;code&gt;BEGINLIBPATH&lt;/code&gt; with &lt;code&gt;LIBPATHSTRICT=T&lt;/code&gt; (available with kernels after September 2000).</source>
          <target state="translated">&lt;code&gt;BEGINLIBPATH&lt;/code&gt; 를 통해 찾은 Perl DLL 이 1 단계에서로드 된 것과 다르면 실패합니다 . 예를 들어, 다른 프로세스가 &lt;code&gt;LIBPATH&lt;/code&gt; 또는 다른 값의 &lt;code&gt;BEGINLIBPATH&lt;/code&gt; 에서 프로세스를로드했을 수 있습니다 . 이 경우 하나 개의 요구 사항이 다른 프로세스 중 하나를 실행하지 않도록 시스템의 설정을 수정하거나 부하에서 DLL하는 &lt;code&gt;BEGINLIBPATH&lt;/code&gt; 와 &lt;code&gt;LIBPATHSTRICT=T&lt;/code&gt; (9 월 2000 년 이후 커널 사용 가능).</target>
        </trans-unit>
        <trans-unit id="6c5f423c103a5bffe6de7613de2373184d36088d" translate="yes" xml:space="preserve">
          <source>Fails if the original</source>
          <target state="translated">원본이 실패하면 실패</target>
        </trans-unit>
        <trans-unit id="dd78511c1283702ad2bb60da575ac2d0ff18ab16" translate="yes" xml:space="preserve">
          <source>Failure of user callbacks dispatched using the &lt;code&gt;G_KEEPERR&lt;/code&gt; flag could also result in this warning. See &lt;a href=&quot;perlcall#G_KEEPERR&quot;&gt;G_KEEPERR in perlcall&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;G_KEEPERR&lt;/code&gt; 플래그를 사용하여 디스패치 된 사용자 콜백에 실패하면 이 경고가 발생할 수 있습니다. &lt;a href=&quot;perlcall#G_KEEPERR&quot;&gt;perlcall의 G_KEEPERR을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e175cd49340e07a19035148ceef428c5e5467b03" translate="yes" xml:space="preserve">
          <source>Failure to find a next method will result in an exception being thrown (see below for alternatives).</source>
          <target state="translated">다음 방법을 찾지 못하면 예외가 발생합니다 (대안은 아래 참조).</target>
        </trans-unit>
        <trans-unit id="331a7d40c82f32a89c55031f2f7712cfb5b3bd07" translate="yes" xml:space="preserve">
          <source>Fairly young with a focus on HTML5 and real-time web technologies such as WebSockets.</source>
          <target state="translated">HTML5 및 WebSockets와 같은 실시간 웹 기술에 중점을 둔 상당히 젊습니다.</target>
        </trans-unit>
        <trans-unit id="b3505bf50d858a8755043974e251138d06ee1ab4" translate="yes" xml:space="preserve">
          <source>Fake on-demand retrieval of outstanding PM messages. If &lt;code&gt;force&lt;/code&gt; is false, will not dispatch messages if a real message loop is known to be present. Returns number of messages retrieved.</source>
          <target state="translated">미해결 PM 메시지의 가짜 주문형 검색. 경우 &lt;code&gt;force&lt;/code&gt; 거짓 진정한 메시지 루프가 존재하는 것으로 알려져 경우, 메시지를 전달하지 않습니다. 검색된 메시지 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6b7d9017d82f8622025ae6965855a1db0b5bb68b" translate="yes" xml:space="preserve">
          <source>Fall-through</source>
          <target state="translated">Fall-through</target>
        </trans-unit>
        <trans-unit id="fab000fc839ca496f91ba067964c48702895aed4" translate="yes" xml:space="preserve">
          <source>Fallback Data::Dumper and Storable</source>
          <target state="translated">대체 데이터 :: 덤퍼 및 저장 가능</target>
        </trans-unit>
        <trans-unit id="2a4cf3efe7afe1d41140981a0335c8d83aa5d220" translate="yes" xml:space="preserve">
          <source>Fallback F</source>
          <target state="translated">폴백 F</target>
        </trans-unit>
        <trans-unit id="a969fb863f8d9f84c7595f93fb9e0917427160e1" translate="yes" xml:space="preserve">
          <source>Fallback for encoding -&amp;gt; unicode. When seen, enc2xs adds this character for the decode map only.</source>
          <target state="translated">인코딩-&amp;gt; 유니 코드 대체. 보시면, enc2xs는 디코드 맵에 대해서만이 문자를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="c7fc9099ef21900d77c14fd9245e820c2f3bcb05" translate="yes" xml:space="preserve">
          <source>Fallback for unicode -&amp;gt; encoding. When seen, enc2xs adds this character for the encode map only.</source>
          <target state="translated">유니 코드-&amp;gt; 인코딩의 대체입니다. enc2xs는이 맵을 인코딩 맵에 대해서만 추가합니다.</target>
        </trans-unit>
        <trans-unit id="cc390dbd71040b4339ecd1673e22c52149414722" translate="yes" xml:space="preserve">
          <source>Family-neutral IP socket supporting both IPv4 and IPv6</source>
          <target state="translated">IPv4 및 IPv6을 모두 지원하는 가족 중립 IP 소켓</target>
        </trans-unit>
        <trans-unit id="b4fab41a1c219c7c774d4d5b99f19bfff38b0e96" translate="yes" xml:space="preserve">
          <source>Fancy term for &lt;b&gt;tokenizing&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;토큰 화를&lt;/b&gt; 위한 멋진 용어 .</target>
        </trans-unit>
        <trans-unit id="94700cb17db6026703f0124336c1c74248aa0c67" translate="yes" xml:space="preserve">
          <source>Fancy term for a &lt;b&gt;token&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;토큰에&lt;/b&gt; 대한 멋진 용어 .</target>
        </trans-unit>
        <trans-unit id="ae38f29ac6b64f59f2ed532d4ca0474fdf64d92e" translate="yes" xml:space="preserve">
          <source>Fancy term for a &lt;b&gt;tokener&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;토큰업자를&lt;/b&gt; 위한 공상 기간 .</target>
        </trans-unit>
        <trans-unit id="f5c2b89d95eac3e9d7a030078747e18b17f8f9e8" translate="yes" xml:space="preserve">
          <source>Far More Than Everything You Ever Wanted To Know. An exhaustive treatise on one narrow topic, something of a super-&lt;b&gt;FAQ&lt;/b&gt;. See Tom for far more.</source>
          <target state="translated">당신이 알고 싶었던 것보다 훨씬 더. 하나의 좁은 주제, 철저한 &lt;b&gt;FAQ&lt;/b&gt; 에 대한 철저한 논문 . 훨씬 더 톰을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="97102c70808de7b8e3d760ebf0b36147b801055a" translate="yes" xml:space="preserve">
          <source>FastCalc works exactly like Calc, in stores the numbers in decimal form, chopped into parts.</source>
          <target state="translated">FastCalc는 Calc와 똑같이 작동하며 숫자를 소수점 이하 자릿수로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="915120b00045631c4e8983c0043b1f79dd8a3042" translate="yes" xml:space="preserve">
          <source>Fatal</source>
          <target state="translated">Fatal</target>
        </trans-unit>
        <trans-unit id="b4aa64ef3bff004eb3090e0a608393aba194c2eb" translate="yes" xml:space="preserve">
          <source>Fatal - Replace functions with equivalents which succeed or die</source>
          <target state="translated">치명적-성공하거나 죽는 등가물로 함수 교체</target>
        </trans-unit>
        <trans-unit id="c4d463e2edaea59c2a65ec5996b3a03a5976f772" translate="yes" xml:space="preserve">
          <source>Fatal Warnings</source>
          <target state="translated">치명적인 경고</target>
        </trans-unit>
        <trans-unit id="a4a739fca7ca0c79dbb282ff772c97aebe6957a9" translate="yes" xml:space="preserve">
          <source>Fcntl</source>
          <target state="translated">Fcntl</target>
        </trans-unit>
        <trans-unit id="e79e4cb9771eccd5b0301896c4fb88d90381fa77" translate="yes" xml:space="preserve">
          <source>Fcntl - load the C Fcntl.h defines</source>
          <target state="translated">Fcntl-C로드 Fcntl.h 정의</target>
        </trans-unit>
        <trans-unit id="229c2035f4aec78ea8439cfaab9ef160e590f22f" translate="yes" xml:space="preserve">
          <source>Features can also be turned off by using &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; feature &quot;foo&quot;&lt;/code&gt; . This too has lexical effect.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; feature &quot;foo&quot;&lt;/code&gt; 을 사용 &lt;a href=&quot;functions/no&quot;&gt;하지 않으면&lt;/a&gt; 기능을 끌 수도 있습니다 . 이것도 어휘 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d03d65a3c6febccc90e9f30f5a749117a92b9dcc" translate="yes" xml:space="preserve">
          <source>February 28, 2013</source>
          <target state="translated">2013 년 2 월 28 일</target>
        </trans-unit>
        <trans-unit id="23cf501c0a2b5c8f4c1ddd40cb4a07d73b755042" translate="yes" xml:space="preserve">
          <source>February, 2004; by Chia-liang Kao: make cmpthese and timestr use time statistics for children instead of parent when the style is 'nop'.</source>
          <target state="translated">2004 년 2 월; Chia-liang Kao : 스타일이 'nop'일 때 cmpthese 및 timestr에서 부모 대신 어린이에 대한 시간 통계를 사용하도록합니다.</target>
        </trans-unit>
        <trans-unit id="1d3095f775b3bd756ca42dc28dbbcb522fa556f5" translate="yes" xml:space="preserve">
          <source>Feel free to add any member data fields you need to keep track of things like current font, indentation, horizontal or vertical position, or whatever else you like. Be sure to read &lt;a href=&quot;#PRIVATE-METHODS-AND-DATA&quot;&gt;PRIVATE METHODS AND DATA&lt;/a&gt; to avoid name collisions.</source>
          <target state="translated">현재 글꼴, 들여 쓰기, 가로 또는 세로 위치 또는 기타 원하는 항목을 추적하는 데 필요한 멤버 데이터 필드를 자유롭게 추가하십시오. 이름 충돌을 피하기 위해 &lt;a href=&quot;#PRIVATE-METHODS-AND-DATA&quot;&gt;개인 정보 및 데이터&lt;/a&gt; 를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="70cbb102105e81fb1b4636c361737ff2e64d0599" translate="yes" xml:space="preserve">
          <source>Feel free to update the ticket about your bug on &lt;a href=&quot;http://rt.perl.org&quot;&gt;http://rt.perl.org&lt;/a&gt; if a new version of Perl is released and your bug is still present.</source>
          <target state="translated">Perl의 새로운 버전이 출시되고 버그가 여전히 존재한다면 &lt;a href=&quot;http://rt.perl.org&quot;&gt;http://rt.perl.org에서&lt;/a&gt; 버그에 대한 티켓을 업데이트하십시오 .</target>
        </trans-unit>
        <trans-unit id="fd7064e4dbef9d61b58b480cbcce388f810d38f0" translate="yes" xml:space="preserve">
          <source>Fetch a specified numbered capture. &lt;code&gt;sv&lt;/code&gt; should be set to the scalar to return, the scalar is passed as an argument rather than being returned from the function because when it's called Perl already has a scalar to store the value, creating another one would be redundant. The scalar can be set with &lt;code&gt;sv_setsv&lt;/code&gt; , &lt;code&gt;sv_setpvn&lt;/code&gt; and friends, see &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;.</source>
          <target state="translated">지정된 번호의 캡처를 가져옵니다. &lt;code&gt;sv&lt;/code&gt; 를 반환하려면 스칼라로 설정해야합니다. 스칼라는 함수에서 반환되는 것이 아니라 인수로 전달됩니다. Perl이라는 값을 호출 할 때는 이미 값을 저장하는 스칼라가 있으므로 다른 값을 만드는 것이 중복되기 때문입니다. 스칼라는 설정할 수 있습니다 &lt;code&gt;sv_setsv&lt;/code&gt; , &lt;code&gt;sv_setpvn&lt;/code&gt; 보고, 친구 &lt;a href=&quot;perlapi&quot;&gt;perlapi을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="361d18ac190751239212937c28a02d801b3fdb96" translate="yes" xml:space="preserve">
          <source>Fetch and install dmake somewhere on your path.</source>
          <target state="translated">경로에 dmake를 가져오고 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="804d920af683a75f739608bbcb40c81ec9c0980c" translate="yes" xml:space="preserve">
          <source>Fetches the file you requested and returns the full path to the file.</source>
          <target state="translated">요청한 파일을 가져오고 파일의 전체 경로를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="827c97bde84978a3bb98e5034a1b606013a63c45" translate="yes" xml:space="preserve">
          <source>Fetches the pad name from the given index.</source>
          <target state="translated">주어진 인덱스에서 패드 이름을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="70b0630621dc693a0b82b1ac72066204ea3cb1ff" translate="yes" xml:space="preserve">
          <source>Fiddling with the Perl stack from your C program</source>
          <target state="translated">C 프로그램에서 Perl 스택으로 처리</target>
        </trans-unit>
        <trans-unit id="5264e2b4a8e426bffe920139d4498e83c17f919e" translate="yes" xml:space="preserve">
          <source>FieldHash-based inside-out implementation. Object registry happens automatically. No destructor is needed and objects are thread safe.</source>
          <target state="translated">FieldHash 기반 내부 구현. 개체 레지스트리가 자동으로 발생합니다. 소멸자가 필요하지 않으며 객체는 스레드로부터 안전합니다.</target>
        </trans-unit>
        <trans-unit id="07d174584450454292329995c0541462f26066d7" translate="yes" xml:space="preserve">
          <source>Fields are as follows:</source>
          <target state="translated">필드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6d320afb6b0630e1ccda485797b8576696531e08" translate="yes" xml:space="preserve">
          <source>Fields that aren't applicable to the particular code point argument exist in the returned hash, and are empty.</source>
          <target state="translated">특정 코드 포인트 인수에 적용 할 수없는 필드는 반환 된 해시에 존재하며 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="659f180bfdb0412ca17466a6655bb668ede0196b" translate="yes" xml:space="preserve">
          <source>Figures out which SourceHandler objects to use for a given Source</source>
          <target state="translated">주어진 소스에 사용할 SourceHandler 객체를 알아냅니다.</target>
        </trans-unit>
        <trans-unit id="4b9b547e63da9c5d210106fd0343b71348efc18f" translate="yes" xml:space="preserve">
          <source>Figuring out the hexadecimal sequence of a Unicode character you want or deciphering someone else's hexadecimal Unicode regexp is about as much fun as programming in machine code. So another way to specify Unicode characters is to use the</source>
          <target state="translated">원하는 유니 코드 문자의 16 진수 시퀀스를 파악하거나 다른 사람의 16 진수 유니 코드 정규 표현식을 해독하는 것은 머신 코드에서 프로그래밍하는 것만 큼 재미 있습니다. 유니 코드 문자를 지정하는 또 다른 방법은</target>
        </trans-unit>
        <trans-unit id="2c3cafa4db3f3e1e51b3dff4303502dbe42b7a89" translate="yes" xml:space="preserve">
          <source>File</source>
          <target state="translated">File</target>
        </trans-unit>
        <trans-unit id="00acd6f7be2c3aca96cab1792dd9c533c4fb99b0" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;RPC.pm&lt;/code&gt; : Perl module for the RPC extension.</source>
          <target state="translated">&lt;code&gt;RPC.pm&lt;/code&gt; 파일 : RPC 확장을위한 Perl 모듈.</target>
        </trans-unit>
        <trans-unit id="2572733e62323918ecd19b3a5f28f1fad3d4a4e6" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;RPC.xs&lt;/code&gt; : Interface to some ONC+ RPC bind library functions.</source>
          <target state="translated">File &lt;code&gt;RPC.xs&lt;/code&gt; : 일부 ONC + RPC 바인드 라이브러리 기능에 대한 인터페이스.</target>
        </trans-unit>
        <trans-unit id="0858ff16b7316b0da87cf27e491f57eeba0e7c11" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;rpctest.pl&lt;/code&gt; : Perl test program for the RPC extension.</source>
          <target state="translated">파일 &lt;code&gt;rpctest.pl&lt;/code&gt; : RPC 확장을위한 Perl 테스트 프로그램.</target>
        </trans-unit>
        <trans-unit id="89663ab01d6a733daa8d8f050b0e4c86205af531" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;typemap&lt;/code&gt; : Custom typemap for RPC.xs. (cf. &lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt;)</source>
          <target state="translated">파일 형식 &lt;code&gt;typemap&lt;/code&gt; : RPC.xs 용 사용자 지정 형식 맵. (cf. &lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="0d73d8626a39dd86d3fe7032f41a3ecc0c3dd715" translate="yes" xml:space="preserve">
          <source>File Extraction Problems on Solaris.</source>
          <target state="translated">Solaris의 파일 추출 문제.</target>
        </trans-unit>
        <trans-unit id="94f0aef527a940964fa9d548817f94f5c7e0d938" translate="yes" xml:space="preserve">
          <source>File Handle and Input/Output Stream Utilities</source>
          <target state="translated">파일 핸들 및 입력 / 출력 스트림 유틸리티</target>
        </trans-unit>
        <trans-unit id="2c21dac263de829a5861211698806d60572e8b18" translate="yes" xml:space="preserve">
          <source>File Input and Output</source>
          <target state="translated">파일 입출력</target>
        </trans-unit>
        <trans-unit id="ed7b317f92a6f66879f8f8669d4497dbe06ba062" translate="yes" xml:space="preserve">
          <source>File Names, File Systems and File Locking (see also File Handles)</source>
          <target state="translated">파일 이름, 파일 시스템 및 파일 잠금 (파일 핸들 참조)</target>
        </trans-unit>
        <trans-unit id="a726cab0d7c518573e2f7003375fc21599153b1b" translate="yes" xml:space="preserve">
          <source>File Operations</source>
          <target state="translated">파일 작업</target>
        </trans-unit>
        <trans-unit id="7572853d675e9450d66b583e3f295602cd6e9a54" translate="yes" xml:space="preserve">
          <source>File Permissions on Cygwin</source>
          <target state="translated">Cygwin에 대한 파일 권한</target>
        </trans-unit>
        <trans-unit id="0f4d62f2c22e44d7f4ed81d343bbd5948187b552" translate="yes" xml:space="preserve">
          <source>File Positioning</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a98d820804906c7cbc4a39c07f594d33f47d588" translate="yes" xml:space="preserve">
          <source>File containing the body of the report. Use this to quickly send a prepared message.</source>
          <target state="translated">보고서 본문이 포함 된 파일입니다. 준비된 메시지를 빠르게 보내려면이 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1653ca6d1bd7cd87184004c951688277cfc7e58a" translate="yes" xml:space="preserve">
          <source>File has been &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink()&lt;/a&gt;&lt;/code&gt;ed, or should be deleted on &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">파일의 링크가 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink()&lt;/a&gt;&lt;/code&gt; 되었거나 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; 에서 삭제되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="f5f5f1c8650cee1864991294b341c02bd2c5622a" translate="yes" xml:space="preserve">
          <source>File locking using the &lt;code&gt;F_GETLK&lt;/code&gt; command to &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl()&lt;/a&gt;&lt;/code&gt; is a stub that returns &lt;code&gt;ENOSYS&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl()&lt;/a&gt;&lt;/code&gt; 대한 &lt;code&gt;F_GETLK&lt;/code&gt; 명령을 사용한 파일 잠금 은 &lt;code&gt;ENOSYS&lt;/code&gt; 를 반환하는 스텁입니다 .</target>
        </trans-unit>
        <trans-unit id="dfa00f1ae5815d6eaab80150e5fdb0f9d6b07ccd" translate="yes" xml:space="preserve">
          <source>File names are case insensitive, but case preserving. A pathname that contains a backslash or drive letter is a Win32 pathname, and not subject to the translations applied to POSIX style pathnames, but cygwin will warn you, so better convert them to POSIX.</source>
          <target state="translated">파일 이름은 대소 문자를 구분하지 않지만 대소 문자를 유지합니다. 백 슬래시 또는 드라이브 문자가 포함 된 경로 이름은 Win32 경로 이름이며 POSIX 스타일 경로 이름에 적용된 변환은 적용되지 않지만 cygwin은 경고하므로 POSIX로 변환하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c5919b0472cf28437e422bab84192d0873dd39a7" translate="yes" xml:space="preserve">
          <source>File or pipe to print line number info to. If it is a pipe (say, &lt;code&gt;|visual_perl_db&lt;/code&gt;), then a short message is used. This is the mechanism used to interact with a slave editor or visual debugger, such as the special &lt;code&gt;vi&lt;/code&gt; or &lt;code&gt;emacs&lt;/code&gt; hooks, or the &lt;code&gt;ddd&lt;/code&gt; graphical debugger.</source>
          <target state="translated">줄 번호 정보를 인쇄 할 파일 또는 파이프. 파이프 인 경우 (예 : &lt;code&gt;|visual_perl_db&lt;/code&gt; ) 짧은 메시지가 사용됩니다. 이것은 특수 &lt;code&gt;vi&lt;/code&gt; 또는 &lt;code&gt;emacs&lt;/code&gt; 후크 또는 &lt;code&gt;ddd&lt;/code&gt; 그래픽 디버거 와 같은 슬레이브 편집기 또는 시각적 디버거와 상호 작용하는 데 사용되는 메커니즘 입니다.</target>
        </trans-unit>
        <trans-unit id="f440d36d60fd2a51c020f6cb4de72889008d2bd8" translate="yes" xml:space="preserve">
          <source>File paths in a MANIFEST always use Unix conventions (ie. /) even if you're not on Unix.</source>
          <target state="translated">MANIFEST의 파일 경로는 Unix가 아닌 경우에도 항상 Unix 규칙 (예 : /)을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d684db983e8b5220e9565d325f0ae9bbe13b32e7" translate="yes" xml:space="preserve">
          <source>File size in bytes</source>
          <target state="translated">바이트 단위의 파일 크기</target>
        </trans-unit>
        <trans-unit id="c37e8261b4c2e82f199fe5efaafed18a68582d21" translate="yes" xml:space="preserve">
          <source>File specifications</source>
          <target state="translated">파일 사양</target>
        </trans-unit>
        <trans-unit id="4007cbed1dac0ce1704758796b77f5a74a2f4ba7" translate="yes" xml:space="preserve">
          <source>File specifications containing wildcards are allowed both on the command line and within Perl globs (e.g. &lt;code&gt;&amp;lt;*.c&amp;gt;&lt;/code&gt; ). If the wildcard filespec uses VMS syntax, the resultant filespecs will follow VMS syntax; if a Unix-style filespec is passed in, Unix-style filespecs will be returned. Similar to the behavior of wildcard globbing for a Unix shell, one can escape command line wildcards with double quotation marks &lt;code&gt;&quot;&lt;/code&gt; around a perl program command line argument. However, owing to the stripping of &lt;code&gt;&quot;&lt;/code&gt; characters carried out by the C handling of argv you will need to escape a construct such as this one (in a directory containing the files</source>
          <target state="translated">와일드 카드를 포함하는 파일 스펙은 명령 행과 Perl globs 내에서 모두 허용됩니다 (예 : &lt;code&gt;&amp;lt;*.c&amp;gt;&lt;/code&gt; ). 와일드 카드 파일 스펙이 VMS 구문을 사용하는 경우 결과 파일 스펙은 VMS 구문을 따릅니다. 유닉스 스타일 파일 스펙이 전달되면 유닉스 스타일 파일 스펙이 리턴됩니다. 하나는 큰 따옴표로 명령 줄 와일드 카드를 탈출 할 수있는 유닉스 셸 와일드 카드 대체 (globbing)의 동작과 유사 &lt;code&gt;&quot;&lt;/code&gt; 펄 프로그램 명령 행 인수 주위가. 그러나,의 제거로 인해 &lt;code&gt;&quot;&lt;/code&gt; 자하는 변수는 argv의 처리 C에 의해 수행 당신은 것입니다 이와 같은 구문을 피해야합니다 (파일이 들어있는 디렉토리에서)</target>
        </trans-unit>
        <trans-unit id="2e67adde1ffcac9182fdc414ea1c59b8537d99ba" translate="yes" xml:space="preserve">
          <source>File to output the results to instead of sending as an email. Useful particularly when running perlbug on a machine with no direct internet connection.</source>
          <target state="translated">이메일로 보내지 않고 결과를 출력 할 파일입니다. 인터넷에 직접 연결되지 않은 컴퓨터에서 perlbug를 실행할 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8524b9f3585575ad7dfc6698bc36a14994079bf5" translate="yes" xml:space="preserve">
          <source>File to save your history?</source>
          <target state="translated">역사를 저장하는 파일?</target>
        </trans-unit>
        <trans-unit id="1e509862932466ee82e463191172e37b3cea6512" translate="yes" xml:space="preserve">
          <source>File type -- numeric, but comparable to exported constants -- see Archive::Tar's documentation</source>
          <target state="translated">파일 유형-숫자이지만 내 보낸 상수와 비교 가능-Archive :: Tar의 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0197048641dc3512ca3dbea2bb733e20d4882d0f" translate="yes" xml:space="preserve">
          <source>File::Basename</source>
          <target state="translated">File::Basename</target>
        </trans-unit>
        <trans-unit id="7643855ad41fd167cd1d19d2fc94a1d9a81f520d" translate="yes" xml:space="preserve">
          <source>File::Basename - Parse file paths into directory, filename and suffix.</source>
          <target state="translated">File :: Basename-파일 경로를 디렉토리, 파일 이름 및 접미사로 구문 분석하십시오.</target>
        </trans-unit>
        <trans-unit id="a8d61a1262a25e3e4a3b5f743fafe0ce5ae8780f" translate="yes" xml:space="preserve">
          <source>File::Compare</source>
          <target state="translated">File::Compare</target>
        </trans-unit>
        <trans-unit id="d243fbac9648f0d6978bc733f70a7d07c623feba" translate="yes" xml:space="preserve">
          <source>File::Compare - Compare files or filehandles</source>
          <target state="translated">File :: Compare-파일 또는 파일 핸들 비교</target>
        </trans-unit>
        <trans-unit id="fb8db5002f44755b6149a0ab982916a8075daf8b" translate="yes" xml:space="preserve">
          <source>File::Compare was written by Nick Ing-Simmons. Its original documentation was written by Chip Salzenberg.</source>
          <target state="translated">File :: Compare는 Nick Ing-Simmons에 의해 작성되었습니다. 원본 문서는 Chip Salzenberg가 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="e84e49c86f519c366047d4a68a91823d7167c285" translate="yes" xml:space="preserve">
          <source>File::Compare::cmp is a synonym for File::Compare::compare. It is exported from File::Compare only by request.</source>
          <target state="translated">File :: Compare :: cmp는 File :: Compare :: compare와 동의어입니다. 요청한 경우에만 File :: Compare에서 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="cced95c8b6209ce495a6cd5c577674c5e6e53b3a" translate="yes" xml:space="preserve">
          <source>File::Compare::compare and its sibling functions return 0 if the files are equal, 1 if the files are unequal, or -1 if an error was encountered.</source>
          <target state="translated">File :: Compare :: compare 및 형제 함수는 파일이 같으면 0을, 파일이 같지 않으면 1을, 오류가 발생한 경우 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="def94ece5481d3beb5558118d685c1a96647aecc" translate="yes" xml:space="preserve">
          <source>File::Compare::compare_text does a line by line comparison of the two files. It stops as soon as a difference is detected. compare_text() accepts an optional third argument: This must be a CODE reference to a line comparison function, which returns 0 when both lines are considered equal. For example:</source>
          <target state="translated">File :: Compare :: compare_text는 두 파일을 한 줄씩 비교합니다. 차이가 감지되는 즉시 중지됩니다. compare_text ()는 선택적 세 번째 인수를 허용합니다. 이것은 라인 비교 함수에 대한 CODE 참조 여야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bc3cb79c7383464148f9e6e9b35dc66828ee89ef" translate="yes" xml:space="preserve">
          <source>File::Copy</source>
          <target state="translated">File::Copy</target>
        </trans-unit>
        <trans-unit id="054808322e1fad4b177e7be1b21dbd651d7b51df" translate="yes" xml:space="preserve">
          <source>File::Copy - Copy files or filehandles</source>
          <target state="translated">File :: Copy-파일 또는 파일 핸들 복사</target>
        </trans-unit>
        <trans-unit id="f2e6bb244559c9a61df5a32393bbd55e499cf28c" translate="yes" xml:space="preserve">
          <source>File::Copy also provides the &lt;code&gt;syscopy&lt;/code&gt; routine, which copies the file specified in the first parameter to the file specified in the second parameter, preserving OS-specific attributes and file structure. For Unix systems, this is equivalent to the simple &lt;code&gt;copy&lt;/code&gt; routine, which doesn't preserve OS-specific attributes. For VMS systems, this calls the &lt;code&gt;rmscopy&lt;/code&gt; routine (see below). For OS/2 systems, this calls the &lt;code&gt;syscopy&lt;/code&gt; XSUB directly. For Win32 systems, this calls &lt;code&gt;Win32::CopyFile&lt;/code&gt; .</source>
          <target state="translated">File :: Copy는 또한 &lt;code&gt;syscopy&lt;/code&gt; 루틴을 제공합니다 .이 루틴은 첫 번째 매개 변수에 지정된 파일을 두 번째 매개 변수에 지정된 파일에 복사하여 OS 별 속성 및 파일 구조를 유지합니다. Unix 시스템의 경우 이는 OS 별 속성을 유지하지 않는 간단한 &lt;code&gt;copy&lt;/code&gt; 루틴 과 동일 합니다. VMS 시스템의 경우 &lt;code&gt;rmscopy&lt;/code&gt; 루틴을 호출합니다 (아래 참조). OS / 2 시스템의 경우 &lt;code&gt;syscopy&lt;/code&gt; XSUB를 직접 호출합니다 . Win32 시스템의 경우 &lt;code&gt;Win32::CopyFile&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="67f88864b88bba7acff99452234fd97bf0f47f99" translate="yes" xml:space="preserve">
          <source>File::Copy was written by Aaron Sherman</source>
          <target state="translated">File :: Copy는 Aaron Sherman이 작성했습니다</target>
        </trans-unit>
        <trans-unit id="f01a5358f4ca69063ca392607e003dc733b2597f" translate="yes" xml:space="preserve">
          <source>File::DosGlob</source>
          <target state="translated">File::DosGlob</target>
        </trans-unit>
        <trans-unit id="5c17116d51c1f03e40c8b694ba6c585eabe2a321" translate="yes" xml:space="preserve">
          <source>File::DosGlob - DOS like globbing and then some</source>
          <target state="translated">File :: DosGlob-DOS와 같은 DOS</target>
        </trans-unit>
        <trans-unit id="bfa471141e1f7096bf78ca1f82e51c1164281798" translate="yes" xml:space="preserve">
          <source>File::Fetch</source>
          <target state="translated">File::Fetch</target>
        </trans-unit>
        <trans-unit id="dcff4894464604256beca2d13f60a2e0200dbabf" translate="yes" xml:space="preserve">
          <source>File::Fetch - A generic file fetching mechanism</source>
          <target state="translated">File :: Fetch-일반 파일 가져 오기 메커니즘</target>
        </trans-unit>
        <trans-unit id="c8dc9651ac05b80071b1feb534cf5a5de8f9de03" translate="yes" xml:space="preserve">
          <source>File::Fetch is a generic file fetching mechanism.</source>
          <target state="translated">File :: Fetch는 일반적인 파일 가져 오기 메커니즘입니다.</target>
        </trans-unit>
        <trans-unit id="2cb1276427ae5064c5b11d564d8f990a7923f8fb" translate="yes" xml:space="preserve">
          <source>File::Fetch is able to fetch a variety of uris, by using several external programs and modules.</source>
          <target state="translated">File :: Fetch는 여러 외부 프로그램 및 모듈을 사용하여 다양한 URI를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="652b8a474fd7bf89a6c10654387f68b029ba4afc" translate="yes" xml:space="preserve">
          <source>File::Find</source>
          <target state="translated">File::Find</target>
        </trans-unit>
        <trans-unit id="dabbc689655c180a270054bdf94079c67c56996d" translate="yes" xml:space="preserve">
          <source>File::Find - Traverse a directory tree.</source>
          <target state="translated">File :: Find-디렉토리 트리를 탐색합니다.</target>
        </trans-unit>
        <trans-unit id="602f452d2b6cab137b630932705ec11b4fbc5825" translate="yes" xml:space="preserve">
          <source>File::Find used to produce incorrect results if called recursively. During the development of perl 5.8 this bug was fixed. The first fixed version of File::Find was 1.01.</source>
          <target state="translated">File :: Find를 재귀 적으로 호출하면 잘못된 결과를 생성하는 데 사용됩니다. perl 5.8을 개발하는 동안이 버그가 수정되었습니다. File :: Find의 첫 번째 고정 버전은 1.01입니다.</target>
        </trans-unit>
        <trans-unit id="cf7493e2714621d4472c83b7fb17367a3f07e0e0" translate="yes" xml:space="preserve">
          <source>File::Find::Rule</source>
          <target state="translated">File::Find::Rule</target>
        </trans-unit>
        <trans-unit id="fdabb48d19b73dd4070bb82d3a9c90ab1b81880a" translate="yes" xml:space="preserve">
          <source>File::Glob</source>
          <target state="translated">File::Glob</target>
        </trans-unit>
        <trans-unit id="8d9f792f087977bcc4f2c40334cf6983814a1f4b" translate="yes" xml:space="preserve">
          <source>File::Glob - Perl extension for BSD glob routine</source>
          <target state="translated">File :: Glob-BSD glob 루틴을위한 Perl 확장</target>
        </trans-unit>
        <trans-unit id="5c88309ce18d22b575a2e92f21ed146adc833a5f" translate="yes" xml:space="preserve">
          <source>File::Glob::bsd_glob() implements the FreeBSD glob(3) routine, which is a superset of the POSIX glob() (described in IEEE Std 1003.2 &quot;POSIX.2&quot;). bsd_glob() takes a mandatory &lt;code&gt;pattern&lt;/code&gt; argument, and an optional &lt;code&gt;flags&lt;/code&gt; argument, and returns a list of filenames matching the pattern, with interpretation of the pattern modified by the &lt;code&gt;flags&lt;/code&gt; variable.</source>
          <target state="translated">File :: Glob :: bsd_glob ()는 FreeBSD glob (3) 루틴을 구현합니다. FreeBSD glob (3) 루틴은 POSIX glob ()의 상위 세트입니다 (IEEE Std 1003.2 &quot;POSIX.2&quot;에 설명되어 있음). bsd_glob ()는 필수 &lt;code&gt;pattern&lt;/code&gt; 인수와 선택적 &lt;code&gt;flags&lt;/code&gt; 인수를 사용하고 &lt;code&gt;flags&lt;/code&gt; 변수에 의해 수정 된 패턴을 해석하여 패턴과 일치하는 파일 이름 목록을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="ca454d7c1a5b19f064af8b037120ba60d6c7a525" translate="yes" xml:space="preserve">
          <source>File::GlobMapper</source>
          <target state="translated">File::GlobMapper</target>
        </trans-unit>
        <trans-unit id="7f7d175bf488aed0eb444cb11c08455ad8599ba6" translate="yes" xml:space="preserve">
          <source>File::GlobMapper - Extend File Glob to Allow Input and Output Files</source>
          <target state="translated">File :: GlobMapper-입력 및 출력 파일을 허용하도록 파일 Glob 확장</target>
        </trans-unit>
        <trans-unit id="1ee8431a726a8a5ed8c4e143748ae9ecf3b924c2" translate="yes" xml:space="preserve">
          <source>File::Path</source>
          <target state="translated">File::Path</target>
        </trans-unit>
        <trans-unit id="1686306ed7a2e3c93f30ae5144bea665fa4f6ad8" translate="yes" xml:space="preserve">
          <source>File::Path - Create or remove directory trees</source>
          <target state="translated">File :: Path-디렉토리 트리 작성 또는 제거</target>
        </trans-unit>
        <trans-unit id="a4ef679a008a6f84865a9e072a31d15ade694f3b" translate="yes" xml:space="preserve">
          <source>File::Remove</source>
          <target state="translated">File::Remove</target>
        </trans-unit>
        <trans-unit id="315013b7403b971bbccc00acbcaa29af9f35ca59" translate="yes" xml:space="preserve">
          <source>File::Spec</source>
          <target state="translated">File::Spec</target>
        </trans-unit>
        <trans-unit id="e03ff856a0868930dbc9cd6d64ff461d1bdaaabc" translate="yes" xml:space="preserve">
          <source>File::Spec &amp;lt;= 0.83 has a bug where the file part of catfile is not canonicalized. This override fixes that bug.</source>
          <target state="translated">File :: Spec &amp;lt;= 0.83에는 catfile의 파일 부분이 정규화되지 않은 버그가 있습니다. 이 재정의는 해당 버그를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="5c2545f01462091353041ce999852a980063ef93" translate="yes" xml:space="preserve">
          <source>File::Spec - portably perform operations on file names</source>
          <target state="translated">File :: Spec-파일 이름에 대한 작업을 이식 가능하게 수행</target>
        </trans-unit>
        <trans-unit id="377c35de2ed196f9c5385b1edfdc4eb6ca2a2256" translate="yes" xml:space="preserve">
          <source>File::Spec for Mac OS (Classic)</source>
          <target state="translated">Mac OS 용 File :: Spec (클래식)</target>
        </trans-unit>
        <trans-unit id="e9dc37ac681ea880968c6d2c9418018b55ac8a4a" translate="yes" xml:space="preserve">
          <source>File::Spec for Unix, base for other File::Spec modules</source>
          <target state="translated">Unix 용 File :: Spec, 다른 File :: Spec 모듈의 기본</target>
        </trans-unit>
        <trans-unit id="5d3e2d6a2a684c855af3654d42b2d52642b0b206" translate="yes" xml:space="preserve">
          <source>File::Spec wrappers</source>
          <target state="translated">File :: Spec 래퍼</target>
        </trans-unit>
        <trans-unit id="57d505f90f23c581eff3d8fd504c98b55b80e3f3" translate="yes" xml:space="preserve">
          <source>File::Spec, File::Spec::Unix, File::Spec::Mac, File::Spec::OS2, File::Spec::Win32, File::Spec::VMS, ExtUtils::MakeMaker</source>
          <target state="translated">파일 :: Spec, 파일 :: Spec :: Unix, 파일 :: Spec :: Mac, 파일 :: Spec :: OS2, 파일 :: Spec :: Win32, 파일 :: Spec :: VMS, ExtUtils :: MakeMaker</target>
        </trans-unit>
        <trans-unit id="641add72b7fdbf25abb0c07f6fb8252f0c914b3a" translate="yes" xml:space="preserve">
          <source>File::Spec::Cygwin</source>
          <target state="translated">File::Spec::Cygwin</target>
        </trans-unit>
        <trans-unit id="cdfed1a8102059cb23af35a0f86b67871164f579" translate="yes" xml:space="preserve">
          <source>File::Spec::Cygwin - methods for Cygwin file specs</source>
          <target state="translated">File :: Spec :: Cygwin-Cygwin 파일 스펙에 대한 메소드</target>
        </trans-unit>
        <trans-unit id="e72fdb6ea5dc0105bf8962f6650693bd46fc1242" translate="yes" xml:space="preserve">
          <source>File::Spec::Epoc</source>
          <target state="translated">File::Spec::Epoc</target>
        </trans-unit>
        <trans-unit id="eb8693815ec649d283b89619fb500489b50c284c" translate="yes" xml:space="preserve">
          <source>File::Spec::Epoc - methods for Epoc file specs</source>
          <target state="translated">File :: Spec :: Epoc-Epoc 파일 스펙을위한 메소드</target>
        </trans-unit>
        <trans-unit id="58ab258073f8844f58a13c0e540afd7c70528044" translate="yes" xml:space="preserve">
          <source>File::Spec::Functions</source>
          <target state="translated">File::Spec::Functions</target>
        </trans-unit>
        <trans-unit id="5200acce0e1b5700ec3f6c1ce8b085a9594ec913" translate="yes" xml:space="preserve">
          <source>File::Spec::Functions - portably perform operations on file names</source>
          <target state="translated">File :: Spec :: Functions-파일 이름에 대한 작업을 이식 가능하게 수행</target>
        </trans-unit>
        <trans-unit id="fc6db1e1b5de7797ac516f96a446cab61cfc0d6a" translate="yes" xml:space="preserve">
          <source>File::Spec::Mac</source>
          <target state="translated">File::Spec::Mac</target>
        </trans-unit>
        <trans-unit id="d79a8c64b96c6d94516d88b113e5eac3b9da4ad8" translate="yes" xml:space="preserve">
          <source>File::Spec::Mac - File::Spec for Mac OS (Classic)</source>
          <target state="translated">File :: Spec :: Mac-File :: Spec for Mac OS (클래식)</target>
        </trans-unit>
        <trans-unit id="dd2e7ffeaaea8af26591abffe1ee1b6f540db20c" translate="yes" xml:space="preserve">
          <source>File::Spec::OS2</source>
          <target state="translated">File::Spec::OS2</target>
        </trans-unit>
        <trans-unit id="40e2993be3fcfb49e9dff0bf954a4b4fc18277d7" translate="yes" xml:space="preserve">
          <source>File::Spec::OS2 - methods for OS/2 file specs</source>
          <target state="translated">File :: Spec :: OS2-OS / 2 파일 스펙을위한 메소드</target>
        </trans-unit>
        <trans-unit id="f7a8d4f1ec9c1ccc3e150ac09fa9f67a10dfcb83" translate="yes" xml:space="preserve">
          <source>File::Spec::Unix</source>
          <target state="translated">File::Spec::Unix</target>
        </trans-unit>
        <trans-unit id="0d7acdcbd611107237cca4df6cbd4c594405934d" translate="yes" xml:space="preserve">
          <source>File::Spec::Unix - File::Spec for Unix, base for other File::Spec modules</source>
          <target state="translated">File :: Spec :: Unix-File :: Spec Unix 용, 다른 File :: Spec 모듈 용 기본</target>
        </trans-unit>
        <trans-unit id="bf21f77214d880322c14e8ee35bc09087fde112d" translate="yes" xml:space="preserve">
          <source>File::Spec::VMS</source>
          <target state="translated">File::Spec::VMS</target>
        </trans-unit>
        <trans-unit id="c14aa057f43f4a505144d4210ab15e571114fe16" translate="yes" xml:space="preserve">
          <source>File::Spec::VMS - methods for VMS file specs</source>
          <target state="translated">File :: Spec :: VMS-VMS 파일 스펙에 대한 메소드</target>
        </trans-unit>
        <trans-unit id="2822248f9e471c31171c089c3fdd48b3debb74f9" translate="yes" xml:space="preserve">
          <source>File::Spec::Win32</source>
          <target state="translated">File::Spec::Win32</target>
        </trans-unit>
        <trans-unit id="080364c33593182b7f7f657492fb3b2d46eb857c" translate="yes" xml:space="preserve">
          <source>File::Spec::Win32 - methods for Win32 file specs</source>
          <target state="translated">File :: Spec :: Win32-Win32 파일 사양의 메소드</target>
        </trans-unit>
        <trans-unit id="e0fd4afcd716107e17e677aa59b46d6470fb899a" translate="yes" xml:space="preserve">
          <source>File::Temp</source>
          <target state="translated">File::Temp</target>
        </trans-unit>
        <trans-unit id="3fe450162cf54232d01afd15746195856bbdbb84" translate="yes" xml:space="preserve">
          <source>File::Temp - return name and handle of a temporary file safely</source>
          <target state="translated">File :: Temp-임시 파일의 이름과 핸들을 안전하게 반환</target>
        </trans-unit>
        <trans-unit id="d91ecfa6abec25b99ed11c8b2d5f3accbd385c89" translate="yes" xml:space="preserve">
          <source>File::chdir</source>
          <target state="translated">File::chdir</target>
        </trans-unit>
        <trans-unit id="e83a936a3382a41b1f3f93e3d07a775dcb299d22" translate="yes" xml:space="preserve">
          <source>File::stat</source>
          <target state="translated">File::stat</target>
        </trans-unit>
        <trans-unit id="9639e61c73c9c60e6cfa27fbe83124dab13c12b1" translate="yes" xml:space="preserve">
          <source>File::stat - by-name interface to Perl's built-in stat() functions</source>
          <target state="translated">File :: stat-Perl의 내장 stat () 함수에 대한 이름 별 인터페이스</target>
        </trans-unit>
        <trans-unit id="ef5f659600c421b89a34289668dcda4b8fde8960" translate="yes" xml:space="preserve">
          <source>FileCache</source>
          <target state="translated">FileCache</target>
        </trans-unit>
        <trans-unit id="dd4dfad3675618140d4d83ded99b3dd8deb7df16" translate="yes" xml:space="preserve">
          <source>FileCache - keep more files open than the system permits</source>
          <target state="translated">FileCache-시스템이 허용하는 것보다 많은 파일을 열어 둡니다</target>
        </trans-unit>
        <trans-unit id="a5cc97ff5fda266750b3dee9900ddf98823854aa" translate="yes" xml:space="preserve">
          <source>FileCache does not store the current file offset if it finds it necessary to close a file. When the file is reopened, the offset will be as specified by the original &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; file mode. This could be construed to be a bug.</source>
          <target state="translated">FileCache는 파일을 닫아야하는 경우 현재 파일 오프셋을 저장하지 않습니다. 파일을 다시 열면 오프셋은 원래 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 파일 모드 에서 지정한대로 입니다. 이것은 버그로 해석 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89f533c3cd15e297fdf4aabaf6ece0f9c1be27a5" translate="yes" xml:space="preserve">
          <source>FileHandle</source>
          <target state="translated">FileHandle</target>
        </trans-unit>
        <trans-unit id="794819fbb3c9526c54cbc3cce598cbc494f7c4eb" translate="yes" xml:space="preserve">
          <source>FileHandle - supply object methods for filehandles</source>
          <target state="translated">FileHandle-파일 핸들을위한 객체 메소드 제공</target>
        </trans-unit>
        <trans-unit id="3e986485fa2d06cffe03b4cb5d722b8847e7c236" translate="yes" xml:space="preserve">
          <source>Filehandles</source>
          <target state="translated">Filehandles</target>
        </trans-unit>
        <trans-unit id="745059e953a17e849a5f1d5cc58b8c65a4690f8b" translate="yes" xml:space="preserve">
          <source>Filehandles returned by these functions support the seekable methods.</source>
          <target state="translated">이러한 함수에 의해 반환 된 파일 핸들은 검색 가능한 메소드를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d917728ca0ac0c4b9a39ce3d45425ec35d9ebdc0" translate="yes" xml:space="preserve">
          <source>Filename Case</source>
          <target state="translated">파일명 케이스</target>
        </trans-unit>
        <trans-unit id="fb7a4b255171595818c7e230dab6fcf171fbaa94" translate="yes" xml:space="preserve">
          <source>Filenames</source>
          <target state="translated">Filenames</target>
        </trans-unit>
        <trans-unit id="9fd1eebd086da1a91988827a7bacbfddddd4cb35" translate="yes" xml:space="preserve">
          <source>Filenames can be picked arbitrarily; &lt;code&gt;CPAN.pm&lt;/code&gt; always reads all files (in alphabetical order) and takes the key &lt;code&gt;match&lt;/code&gt; (see below in</source>
          <target state="translated">파일 이름은 임의로 선택할 수 있습니다. &lt;code&gt;CPAN.pm&lt;/code&gt; 은 항상 모든 파일을 사전 순으로 읽고 키를 &lt;code&gt;match&lt;/code&gt; 시킵니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="c9784173a96e4b1510622cabd6602208c753b868" translate="yes" xml:space="preserve">
          <source>Filenames with * and ? will be glob expanded.</source>
          <target state="translated">* 및?가 포함 된 파일 이름 glob 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="048ca477f6d313575e8e768358930dd94a0805a0" translate="yes" xml:space="preserve">
          <source>Files I'm trying to fetch have reserved characters or non-ASCII characters in them. What do I do?</source>
          <target state="translated">가져 오려는 파일에 예약 문자 또는 비 ASCII 문자가 있습니다. 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="119c6ebf5f034a0bdf47e2ccf4a4a00d52bae121" translate="yes" xml:space="preserve">
          <source>Files and Filesystems</source>
          <target state="translated">파일과 파일 시스템</target>
        </trans-unit>
        <trans-unit id="1b66cfb0249a670160094a9d9a1226caf17ef912" translate="yes" xml:space="preserve">
          <source>Files and I/O</source>
          <target state="translated">파일과 I / O</target>
        </trans-unit>
        <trans-unit id="5bcfdef82017aca1b62d322f75f45269c52cebb0" translate="yes" xml:space="preserve">
          <source>Files older than v2.0 will have the one of the version numbers &quot;-1&quot;, &quot;0&quot; or &quot;1&quot;. No minor number was used at that time.</source>
          <target state="translated">v2.0 이전의 파일은 버전 번호 &quot;-1&quot;, &quot;0&quot;또는 &quot;1&quot;중 하나입니다. 당시에는 마이너 번호가 사용되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="ce0b65cbec28e6a52a00f89d26a974e92b387838" translate="yes" xml:space="preserve">
          <source>Files opened without an encoding argument will be in UTF-8:</source>
          <target state="translated">인코딩 인수없이 열린 파일은 UTF-8입니다.</target>
        </trans-unit>
        <trans-unit id="646de437489432c391060b841f63b51dd2e343a9" translate="yes" xml:space="preserve">
          <source>Files which are not &lt;code&gt;mmap()&lt;/code&gt; -able revert to behaving like the &lt;code&gt;:perlio&lt;/code&gt; layer. Writes also behave like the &lt;code&gt;:perlio&lt;/code&gt; layer, as &lt;code&gt;mmap()&lt;/code&gt; for write needs extra house-keeping (to extend the file) which negates any advantage.</source>
          <target state="translated">&lt;code&gt;mmap()&lt;/code&gt; 하지 않은 파일 은 &lt;code&gt;:perlio&lt;/code&gt; 레이어 처럼 동작합니다 . 쓰기를 위한 &lt;code&gt;mmap()&lt;/code&gt; 에는 추가적인 하우스 키핑 (파일 확장)이 필요하기 때문에 쓰기 는 &lt;code&gt;:perlio&lt;/code&gt; 레이어 처럼 동작합니다 .</target>
        </trans-unit>
        <trans-unit id="a624b168584689d4ad50d72852da812cefd7de42" translate="yes" xml:space="preserve">
          <source>Fill the sv with current working directory</source>
          <target state="translated">현재 작업 디렉토리로 sv을 채우십시오.</target>
        </trans-unit>
        <trans-unit id="7c991b879751864162456f044ae4b061287a9ddd" translate="yes" xml:space="preserve">
          <source>Fill up memory with a byte pattern (a byte repeated over and over again) that hopefully catches attempts to access uninitialized memory.</source>
          <target state="translated">초기화되지 않은 메모리에 액세스하려는 시도를 잡아내는 바이트 패턴 (반복 반복되는 바이트)으로 메모리를 채우십시오.</target>
        </trans-unit>
        <trans-unit id="1caa98b8fe4b092dfaf90807d48e36c7313a1fe3" translate="yes" xml:space="preserve">
          <source>Filter DBM keys/values</source>
          <target state="translated">DBM 키 / 값 필터링</target>
        </trans-unit>
        <trans-unit id="49db338137c69e197263cbd2a2a02d160fa11306" translate="yes" xml:space="preserve">
          <source>Filter for DBM_Filter</source>
          <target state="translated">DBM_Filter에 대한 필터</target>
        </trans-unit>
        <trans-unit id="155bc63929438bf5891026e88a669c019cfee1eb" translate="yes" xml:space="preserve">
          <source>Filter the file list so that all the test files run match /(LIST|OF|PATTERNS)/. Note that with this form the patterns are joined by '|' and you cannot supply a list of files, instead the test files are obtained from the MANIFEST.</source>
          <target state="translated">모든 테스트 파일이 / (LIST | OF | PATTERNS) /와 일치하도록 파일 목록을 필터링하십시오. 이 형식에서 패턴은 '|'로 연결됩니다. 파일 목록을 제공 할 수 없으며 대신 MANIFEST에서 테스트 파일을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="d5a596c0ce5a2b7a7aba6646e13f8fdc098b26bf" translate="yes" xml:space="preserve">
          <source>Filter the file list so that all the test files run match PATTERN. Note that this form is distinct from the &lt;b&gt;-re LIST OF PATTERNS&lt;/b&gt; form below in that it allows the file list to be provided as well.</source>
          <target state="translated">모든 테스트 파일이 PATTERN과 일치하도록 파일 목록을 필터링하십시오. 이 양식은 파일 목록도 제공 할 수 있다는 점에서 아래 &lt;b&gt;의 -re LIST OF PATTERNS&lt;/b&gt; 양식과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="42d3a31d1c9ff4adea6e61106fd398bfebcdb7bc" translate="yes" xml:space="preserve">
          <source>Filter::Simple</source>
          <target state="translated">Filter::Simple</target>
        </trans-unit>
        <trans-unit id="8902388c9d4dcc551448da4cca3d317ed63a6414" translate="yes" xml:space="preserve">
          <source>Filter::Simple - Simplified source filtering</source>
          <target state="translated">Filter :: Simple-단순화 된 소스 필터링</target>
        </trans-unit>
        <trans-unit id="4d594a2e8094dc15ca9e42ca0d84c3e0a33987d2" translate="yes" xml:space="preserve">
          <source>Filter::Simple generates a special &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine for your module (see &lt;a href=&quot;#How-it-works&quot;&gt;How it works&lt;/a&gt;) which would normally replace any &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine you might have explicitly declared.</source>
          <target state="translated">Filter :: Simple 은 일반적으로 명시 적으로 선언 한 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 서브 루틴을 대체 &lt;a href=&quot;#How-it-works&quot;&gt;하는&lt;/a&gt; 모듈에 대한 특수 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 서브 루틴을 생성합니다 ( 작동 방법 참조 ) .</target>
        </trans-unit>
        <trans-unit id="5b045aab2dc3c12f8983dd3d86529beb5ee5d291" translate="yes" xml:space="preserve">
          <source>Filter::Simple is now maintained by the Perl5-Porters. Please submit bug via the &lt;code&gt;perlbug&lt;/code&gt; tool that comes with your perl. For usage instructions, read &lt;code&gt;perldoc perlbug&lt;/code&gt; or possibly &lt;code&gt;man perlbug&lt;/code&gt; . For mostly anything else, please contact &amp;lt;perl5-porters@perl.org&amp;gt;.</source>
          <target state="translated">Filter :: Simple은 이제 Perl5-Porters에 의해 유지 보수됩니다. perl과 함께 제공 되는 &lt;code&gt;perlbug&lt;/code&gt; 도구를 통해 버그를 제출 하십시오. 사용법 지시 사항은 &lt;code&gt;perldoc perlbug&lt;/code&gt; 또는 &lt;code&gt;man perlbug&lt;/code&gt; 를 읽으십시오 . 대부분 다른 내용은 &amp;lt;perl5-porters@perl.org&amp;gt;에 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="19879ac495533ad1077ba2c41a6a1388fc0daf98" translate="yes" xml:space="preserve">
          <source>Filter::Simple supports this type of filtering by automatically exporting the &lt;code&gt;FILTER_ONLY&lt;/code&gt; subroutine.</source>
          <target state="translated">Filter :: Simple은 &lt;code&gt;FILTER_ONLY&lt;/code&gt; 서브 루틴 을 자동으로 내보내 이러한 유형의 필터링을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="7738927e99aa19b5661cca71074c5a3666ddd066" translate="yes" xml:space="preserve">
          <source>Filter::Util::Call</source>
          <target state="translated">Filter::Util::Call</target>
        </trans-unit>
        <trans-unit id="7dc52ff0d48741e56609be222232752914b7f609" translate="yes" xml:space="preserve">
          <source>Filter::Util::Call - Perl Source Filter Utility Module</source>
          <target state="translated">Filter :: Util :: Call-펄 소스 필터 유틸리티 모듈</target>
        </trans-unit>
        <trans-unit id="0cabe77e4a0f9142f83082a357c9dd9516395a45" translate="yes" xml:space="preserve">
          <source>Filtering only specific components of source code</source>
          <target state="translated">소스 코드의 특정 구성 요소 만 필터링</target>
        </trans-unit>
        <trans-unit id="0d724af3cdfe968bbaf60122abf6756e0bff8902" translate="yes" xml:space="preserve">
          <source>Filtering only the code parts of source code</source>
          <target state="translated">소스 코드의 코드 부분 만 필터링</target>
        </trans-unit>
        <trans-unit id="064b3406638df42c905600b3e499487ada8eb46b" translate="yes" xml:space="preserve">
          <source>Filters Included</source>
          <target state="translated">포함 된 필터</target>
        </trans-unit>
        <trans-unit id="5a48634134a41cfb47919ca0620c4a4eb370a44f" translate="yes" xml:space="preserve">
          <source>Filters can be created in two main ways</source>
          <target state="translated">필터는 두 가지 주요 방법으로 만들 수 있습니다</target>
        </trans-unit>
        <trans-unit id="f3f0a8fb43e79067faffa3f02bee42380f1453b8" translate="yes" xml:space="preserve">
          <source>Filters everything. Identical in effect to &lt;code&gt;FILTER&lt;/code&gt; .</source>
          <target state="translated">모든 것을 필터링합니다. &lt;code&gt;FILTER&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="dff7559e7e19f13b99b80c4310a808291f2993fd" translate="yes" xml:space="preserve">
          <source>Filters only Perl quotelikes (as interpreted by &lt;code&gt;&amp;amp;Text::Balanced::extract_quotelike&lt;/code&gt; ).</source>
          <target state="translated">Perl 인용구 만 필터링합니다 ( &lt;code&gt;&amp;amp;Text::Balanced::extract_quotelike&lt;/code&gt; 의해 해석 됨 ).</target>
        </trans-unit>
        <trans-unit id="d46715be5a6c7c637a101bd3fb514ca34a022fd4" translate="yes" xml:space="preserve">
          <source>Filters only the pattern literal parts of a Perl quotelike (i.e. the contents of a &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; or an &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;, the first half of an &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Perl 인용문의 패턴 리터럴 부분 만 필터링합니다 (예 : &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 의 첫 번째 절반 인 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; 의 내용 ).</target>
        </trans-unit>
        <trans-unit id="9d6c7da3a59381ce364937477b0de797b35ca66f" translate="yes" xml:space="preserve">
          <source>Filters only the string literal parts of a Perl quotelike (i.e. the contents of a string literal, either half of a &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;, the second half of an &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Perl 인용문의 문자열 리터럴 부분 만 필터링합니다 (즉, 문자열 리터럴의 내용, &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 의 절반, &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 후반 ).</target>
        </trans-unit>
        <trans-unit id="21c3fceb1f21a8d2c7a7604d5f15909ba3c4e6bc" translate="yes" xml:space="preserve">
          <source>Filters only those sections of the source code that are not POD or &lt;code&gt;__DATA__&lt;/code&gt; .</source>
          <target state="translated">POD 또는 &lt;code&gt;__DATA__&lt;/code&gt; 가 아닌 소스 코드의 해당 섹션 만 필터링 합니다.</target>
        </trans-unit>
        <trans-unit id="8d0e4690844c0e997ddfae93ebb04be08becd5b9" translate="yes" xml:space="preserve">
          <source>Filters only those sections of the source code that are not POD, comments, or &lt;code&gt;__DATA__&lt;/code&gt; .</source>
          <target state="translated">POD, 주석 또는 &lt;code&gt;__DATA__&lt;/code&gt; 가 아닌 소스 코드의 해당 섹션 만 필터링 합니다.</target>
        </trans-unit>
        <trans-unit id="73c4703434d54b35a96afa23550eee383050c8e7" translate="yes" xml:space="preserve">
          <source>Filters only those sections of the source code that are not quotelikes, POD, comments, or &lt;code&gt;__DATA__&lt;/code&gt; .</source>
          <target state="translated">인용 부호, POD, 주석 또는 &lt;code&gt;__DATA__&lt;/code&gt; 가 아닌 소스 코드의 해당 섹션 만 필터링 합니다.</target>
        </trans-unit>
        <trans-unit id="6768e7cdb67b7548d17f5b47c853204a354ef8a8" translate="yes" xml:space="preserve">
          <source>Filters only those sections of the source code that are not quotelikes, POD, or &lt;code&gt;__DATA__&lt;/code&gt; .</source>
          <target state="translated">인용 부호, POD 또는 &lt;code&gt;__DATA__&lt;/code&gt; 가 아닌 소스 코드의 해당 섹션 만 필터링 합니다.</target>
        </trans-unit>
        <trans-unit id="0c5efd60aef7150698692bd9522cefaa126df2ec" translate="yes" xml:space="preserve">
          <source>Finally there is the 'default', and the related 'default_get' and 'default_set' options. These options control the &quot;default&quot; object which is provided by the class interface to the methods. Setting &lt;code&gt;default_get&lt;/code&gt; to true tells the constructor to return the default object if it is defined. Setting &lt;code&gt;default_set&lt;/code&gt; to true tells the constructor to make the default object the constructed object. Setting the &lt;code&gt;default&lt;/code&gt; option is like setting both to true. This is used primarily internally and probably isn't interesting to any real user.</source>
          <target state="translated">마지막으로 'default'와 관련 'default_get'및 'default_set'옵션이 있습니다. 이 옵션은 클래스 인터페이스가 메소드에 제공하는 &quot;기본&quot;오브젝트를 제어합니다. &lt;code&gt;default_get&lt;/code&gt; 을 true로 설정 하면 생성자가 기본 오브젝트가 정의 된 경우이를 리턴하도록 지시합니다. &lt;code&gt;default_set&lt;/code&gt; 을 true로 설정 하면 생성자가 기본 객체를 생성 된 객체로 만들도록 지시합니다. &lt;code&gt;default&lt;/code&gt; 옵션을 설정하는 것은 둘 다 true로 설정하는 것과 같습니다. 이것은 주로 내부적으로 사용되며 실제 사용자에게는 흥미가 없을 것입니다.</target>
        </trans-unit>
        <trans-unit id="b793b4c7037146e44c6ebbd985a0e8b5eea1bc2d" translate="yes" xml:space="preserve">
          <source>Finally,</source>
          <target state="translated">Finally,</target>
        </trans-unit>
        <trans-unit id="c007289d889b2ac012d30249ede8e24355c7610c" translate="yes" xml:space="preserve">
          <source>Finally, &lt;a href=&quot;http://search.cpan.org/perldoc/Plack&quot;&gt;Plack&lt;/a&gt; is a Perl module and toolkit that contains PSGI middleware, helpers and adapters to web servers, allowing you to easily deploy scripts which can continue running, and provides flexibility with regards to which web server you use. It can allow existing CGI scripts to enjoy this flexibility and performance with minimal changes, or can be used along with modern Perl web frameworks to make writing and deploying web services with Perl a breeze.</source>
          <target state="translated">마지막으로 &lt;a href=&quot;http://search.cpan.org/perldoc/Plack&quot;&gt;Plack&lt;/a&gt; 은 웹 서버에 PSGI 미들웨어, 헬퍼 및 어댑터를 포함하는 Perl 모듈 및 툴킷 으로, 계속 실행할 수있는 스크립트를 쉽게 배포하고 사용하는 웹 서버와 관련하여 유연성을 제공합니다. 기존 CGI 스크립트는 최소한의 변경으로 이러한 유연성과 성능을 즐기거나 최신 Perl 웹 프레임 워크와 함께 사용하여 Perl을 사용하여 웹 서비스를 작성하고 배포 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ec318bbb4a97f05c20b43c3d365fb178815d120" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;$?&lt;/code&gt; may be set to non-0 value if the external program</source>
          <target state="translated">마지막으로 &lt;code&gt;$?&lt;/code&gt; 외부 프로그램 인 경우 0이 아닌 값으로 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92dd49b4407ac7414e31cf79437fb39879d44f34" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; will traverse up references exactly</source>
          <target state="translated">마지막으로 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; 은 참조를 정확하게 트래버스합니다.</target>
        </trans-unit>
        <trans-unit id="66c1abb8f12ea81297c1b86ceb245b7ba4213937" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; also has an additional affect on the bitwise operators. Normally, the operands and results are treated as &lt;b&gt;unsigned&lt;/b&gt; integers, but with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; the operands and results are &lt;b&gt;signed&lt;/b&gt;. This means, among other things, that ~0 is -1, and -2 &amp;amp; -5 is -6.</source>
          <target state="translated">마지막으로 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용하십시오&lt;/a&gt; . 비트 연산자에도 영향을줍니다. 일반적으로 피연산자와 결과는 &lt;b&gt;부호없는&lt;/b&gt; 정수 로 처리 되지만 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; 를 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 합니다. 피연산자와 결과가 &lt;b&gt;서명&lt;/b&gt; 됩니다. 이는 무엇보다도 ~ 0이 -1이고 -2 &amp;amp; -5가 -6임을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4298e2e9c529f41f2c9de7ef565329b328f06ed5" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;LC_CTYPE&lt;/code&gt; affects the (deprecated) POSIX character-class test functions--&lt;code&gt;POSIX::isalpha()&lt;/code&gt; , &lt;code&gt;POSIX::islower()&lt;/code&gt; , and so on. For example, if you move from the &quot;C&quot; locale to a 7-bit ISO 646 one, you may find--possibly to your surprise--that &lt;code&gt;&quot;|&quot;&lt;/code&gt; moves from the &lt;code&gt;POSIX::ispunct()&lt;/code&gt; class to &lt;code&gt;POSIX::isalpha()&lt;/code&gt; . Unfortunately, this creates big problems for regular expressions. &quot;|&quot; still means alternation even though it matches &lt;code&gt;\w&lt;/code&gt; . Starting in v5.22, a warning will be raised when such a locale is switched into. More details are given several paragraphs further down.</source>
          <target state="translated">마지막으로 &lt;code&gt;LC_CTYPE&lt;/code&gt; 은 (더 이상 사용되지 않는) POSIX 문자 클래스 테스트 함수 ( &lt;code&gt;POSIX::isalpha()&lt;/code&gt; , &lt;code&gt;POSIX::islower()&lt;/code&gt; 등 ) 에 영향을줍니다. 예를 들어 &quot;C&quot;로캘에서 7 비트 ISO 646 로캘로 이동하면 놀랍게도 &lt;code&gt;&quot;|&quot;&lt;/code&gt; 로부터 이동 &lt;code&gt;POSIX::ispunct()&lt;/code&gt; 에 클래스 &lt;code&gt;POSIX::isalpha()&lt;/code&gt; . 불행히도 이것은 정규 표현식에 큰 문제를 일으 킵니다. &quot;|&quot; &lt;code&gt;\w&lt;/code&gt; 와 일치하더라도 대체를 의미 합니다. v5.22부터는 해당 로케일이 전환 될 때 경고가 발생합니다. 자세한 내용은 여러 단락을 더 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="863cc6df01692aa36bb18136100716eadd4c9578" translate="yes" xml:space="preserve">
          <source>Finally, any other list of arguments is taken as a new list value for the KEY variable discarding the previous value.</source>
          <target state="translated">마지막으로, 다른 인수 목록은 이전 값을 버리는 KEY 변수의 새 목록 값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2782a08306f78a46a43ca3f4245df407dada422a" translate="yes" xml:space="preserve">
          <source>Finally, as a general note, try not to use an excessive amount of markup. As documented here and in &lt;a href=&quot;pod/man&quot;&gt;Pod::Man&lt;/a&gt;, you can safely leave Perl variables, function names, man page references, and the like unadorned by markup and the POD translators will figure it out for you. This makes it much easier to later edit the documentation. Note that many existing translators will do the wrong thing with e-mail addresses when wrapped in L&amp;lt;&amp;gt;, so don't do that.</source>
          <target state="translated">마지막으로, 일반적으로 과도한 양의 마크 업을 사용하지 마십시오. 여기 및 &lt;a href=&quot;pod/man&quot;&gt;Pod :: Man&lt;/a&gt; 에 설명 된대로 마크 업에 의해 옹호되지 않은 Perl 변수, 함수 이름, 매뉴얼 페이지 참조 등을 안전하게 남겨 둘 수 있으며 POD 번역가가이를 파악합니다. 따라서 나중에 문서를 훨씬 쉽게 편집 할 수 있습니다. 기존의 많은 번역가들이 L &amp;lt;&amp;gt;에 싸여있을 때 전자 우편 주소로 잘못된 일을하므로 그렇게하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="09dd5948c51d9dbe80c668a49680794506b31bfd" translate="yes" xml:space="preserve">
          <source>Finally, because Perl is frequently (but not always, and certainly not by definition) an interpreted language, you can write your programs and test them without an intermediate compilation step, allowing you to experiment and test/debug quickly and easily. This ease of experimentation flattens the learning curve even more.</source>
          <target state="translated">마지막으로 Perl은 (언제나 정의에 의해서는 항상) 해석되는 언어가 아니기 때문에 중간 컴파일 단계없이 프로그램을 작성하고 테스트 할 수 있으므로 빠르고 쉽게 실험하고 테스트 / 디버그 할 수 있습니다. 이러한 실험의 용이성은 학습 곡선을 더욱 평평하게합니다.</target>
        </trans-unit>
        <trans-unit id="4a510065fc482271aa62171fe6b3a6de41010a11" translate="yes" xml:space="preserve">
          <source>Finally, documentation intended for core Perl developers lives in the</source>
          <target state="translated">마지막으로 핵심 Perl 개발자를위한 문서는</target>
        </trans-unit>
        <trans-unit id="ef0d2a6fbc127dfe3fabf24f53dec0be787cb458" translate="yes" xml:space="preserve">
          <source>Finally, for backward (and we do mean &quot;backward&quot;) compatibility, Perl permits these unnecessary but widely-supported conversions:</source>
          <target state="translated">마지막으로, 이전 버전과의 호환성을 위해 Perl은 다음과 같이 불필요하지만 널리 지원되는 변환을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="b81575352f8aab412fd4cb07d0470076b14f1f18" translate="yes" xml:space="preserve">
          <source>Finally, here is yet another way to do comma-separated value parsing:</source>
          <target state="translated">마지막으로 쉼표로 구분 된 값 구문 분석을 수행하는 또 다른 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="834a9815bc42b39ddd5279d8456b87a013959fa0" translate="yes" xml:space="preserve">
          <source>Finally, here's an example of the full typemap file for mapping C strings of the &lt;code&gt;char *&lt;/code&gt; type to Perl scalars/strings:</source>
          <target state="translated">마지막으로, &lt;code&gt;char *&lt;/code&gt; 타입 의 C 문자열 을 Perl 스칼라 / 문자열 에 매핑하기위한 전체 타입 맵 파일의 예입니다 :</target>
        </trans-unit>
        <trans-unit id="bba57917092f0217e7811ec4321a57605d773dd9" translate="yes" xml:space="preserve">
          <source>Finally, if the command line ends with '&amp;amp;', the entire command is run in the background as an asynchronous subprocess.</source>
          <target state="translated">마지막으로 명령 행이 '&amp;amp;'로 끝나면 전체 명령이 백그라운드에서 비동기 서브 프로세스로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="1e49365bee26ebdbc8e5446418348a20a97dc14c" translate="yes" xml:space="preserve">
          <source>Finally, if you feel like a real challenge, have a go at writing a full-blown Perl macro preprocessor as a source filter. Borrow the useful features from the C preprocessor and any other macro processors you know. The tricky bit will be choosing how much knowledge of Perl's syntax you want your filter to have.</source>
          <target state="translated">마지막으로, 실제 도전과 같은 느낌이 든다면 본격적인 Perl 매크로 프리 프로세서를 소스 필터로 작성하십시오. C 프리 프로세서와 알고있는 다른 매크로 프로세서에서 유용한 기능을 차용하십시오. 까다로운 부분은 필터에 원하는 Perl 구문에 대한 지식을 얼마나 많이 선택 하는가입니다.</target>
        </trans-unit>
        <trans-unit id="88728c279fead59f6cd8637f346aa4a89bc4ca1d" translate="yes" xml:space="preserve">
          <source>Finally, it searches down the C3 MRO list until it reaches the contextually enclosing class, then searches further down the MRO list for the next method with the same name as the contextually enclosing method.</source>
          <target state="translated">마지막으로, C3 MRO 목록이 컨텍스트로 둘러싸인 클래스에 도달 할 때까지 C3 MRO 목록을 검색 한 다음, 컨텍스트로 묶는 메소드와 동일한 이름으로 다음 메소드에 대한 MRO 목록을 추가로 검색합니다.</target>
        </trans-unit>
        <trans-unit id="d8f4b0ff247923b3eb8f0e0514234b9fa893f6fd" translate="yes" xml:space="preserve">
          <source>Finally, it's possible to override localtime and gmtime everywhere, by including the ':override' tag in the import list:</source>
          <target state="translated">마지막으로 가져 오기 목록에 ': override'태그를 포함하여 모든 곳에서 localtime 및 gmtime을 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5aad188b46d292eb5dea6e10dfb430bbcea6367" translate="yes" xml:space="preserve">
          <source>Finally, keep in mind that Perl might not be the right tool for every job. You're a much better advocate if your claims are reasonable and grounded in reality. Dogmatically advocating anything tends to make people discount your message. Be honest about possible disadvantages to your choice of Perl since any choice has trade-offs.</source>
          <target state="translated">마지막으로 Perl이 모든 작업에 적합한 도구는 아닙니다. 당신의 주장이 합리적이고 현실에 근거를 둔다면 훨씬 더 옹호자입니다. 독단적으로 옹호하는 것은 사람들이 귀하의 메시지를 할인하는 경향이 있습니다. 어떤 선택에도 타협이 있기 때문에 Perl 선택에 대한 가능한 단점에 대해 솔직하십시오.</target>
        </trans-unit>
        <trans-unit id="12d654760faef187bf9fcd2c080146c42b559499" translate="yes" xml:space="preserve">
          <source>Finally, keep in mind that subpatterns created inside a DEFINE block count towards the absolute and relative number of captures, so this:</source>
          <target state="translated">마지막으로 DEFINE 블록 내에서 생성 된 하위 패턴은 캡처의 절대 및 상대 수로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="e50add68bf383c512c89d12d1f1fbdacf62aaedc" translate="yes" xml:space="preserve">
          <source>Finally, let's get those four fields. By now, you shouldn't have any problems with the first three fields - but how can we use the byte count of the data in the first field as a length for the data field? Here the codes &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;X&lt;/code&gt; come to the rescue, as they permit jumping back and forth in the string to unpack.</source>
          <target state="translated">마지막으로,이 네 가지 분야를 살펴 보겠습니다. 지금까지 처음 세 필드에는 아무런 문제가 없어야합니다. 그러나 첫 번째 필드의 데이터 바이트 수를 데이터 필드의 길이로 어떻게 사용할 수 있습니까? 여기에서 코드 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;X&lt;/code&gt; 는 압축을 풀기 위해 현에서 앞뒤로 점프 할 수있게함으로써 구조를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="0bb929b935f9baf3ae2ecaa9eade20a81808b33d" translate="yes" xml:space="preserve">
          <source>Finally, most properties related to decomposition are accessible via &lt;a href=&quot;unicode/normalize&quot;&gt;Unicode::Normalize&lt;/a&gt;.</source>
          <target state="translated">마지막으로, 분해와 관련된 대부분의 속성은 &lt;a href=&quot;unicode/normalize&quot;&gt;Unicode :: Normalize&lt;/a&gt; 를 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="de4b908f9ba516df7dd4589f61d68201fc354294" translate="yes" xml:space="preserve">
          <source>Finally, on NFS file systems the link count of the file handle does not always go to zero immediately after unlinking. Currently, this command is expected to fail on NFS disks.</source>
          <target state="translated">마지막으로 NFS 파일 시스템에서 파일 핸들의 링크 수는 링크 해제 직후에 항상 0이되지는 않습니다. 현재이 명령은 NFS 디스크에서 실패 할 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="c0056d49190cd844d22da94e2f6a73f54ba22274" translate="yes" xml:space="preserve">
          <source>Finally, once the loop terminates (because we got a 0 or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in the queue, which serves as a note to terminate), we pass on the notice to our child, and wait for it to exit if we've created a child (lines 27 and 30).</source>
          <target state="translated">마지막으로 루프가 종료되면 ( 큐에 0 또는 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가있어 종료 메모 역할을 함) 통지를 자식에게 전달하고 자식을 만든 경우 종료 될 때까지 기다립니다 ( 27 행 및 30 행).</target>
        </trans-unit>
        <trans-unit id="d4b58a368a203e349112a813fb51574ad5df46e1" translate="yes" xml:space="preserve">
          <source>Finally, quoted strings cannot span multiple lines. The general rule is that the identifier must be a string literal. Stick with that, and you should be safe.</source>
          <target state="translated">마지막으로 따옴표로 묶인 문자열은 여러 줄에 걸쳐있을 수 없습니다. 일반적으로 식별자는 문자열 리터럴이어야합니다. 그걸 지키면 안전해야합니다.</target>
        </trans-unit>
        <trans-unit id="826093a59348aea220454d887a381ab8cec4085f" translate="yes" xml:space="preserve">
          <source>Finally, see the published Unicode Standard (page numbers are from version 6.0.0), including these specific annexes and technical reports:</source>
          <target state="translated">마지막으로 다음과 같은 별첨 및 기술 보고서를 포함하여 게시 된 유니 코드 표준 (페이지 번호는 버전 6.0.0)을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8e4fc718922fd33861fef8abc551f702371be5ab" translate="yes" xml:space="preserve">
          <source>Finally, some built-ins (e.g. &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt;) can't be overridden.</source>
          <target state="translated">마지막으로 일부 내장 (예 : &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; )을 재정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fbb0bc03e6c567aa9d048447baa9b177ddc77752" translate="yes" xml:space="preserve">
          <source>Finally, the &lt;b&gt;-i&lt;/b&gt; switch does not impede execution when no files are given on the command line. In this case, no backup is made (the original file cannot, of course, be determined) and processing proceeds from STDIN to STDOUT as might be expected.</source>
          <target state="translated">마지막으로, &lt;b&gt;-i&lt;/b&gt; 스위치는 명령 행에 파일이 제공되지 않은 경우 실행을 방해하지 않습니다. 이 경우 백업이 작성되지 않으며 (원래 파일을 결정할 수 없음) 예상대로 STDIN에서 STDOUT으로 처리가 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="6e903744590309f2cbd34fe629a8e6cdbf621b80" translate="yes" xml:space="preserve">
          <source>Finally, the &lt;code&gt;//&lt;/code&gt; default delimiters for a match can be changed to arbitrary delimiters by putting an &lt;code&gt;'m'&lt;/code&gt; out front:</source>
          <target state="translated">마지막으로 &lt;code&gt;//&lt;/code&gt; 일치하는 기본 구분 기호는 &lt;code&gt;'m'&lt;/code&gt; 을 앞에 두어 임의의 구분 기호로 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="042bc8fcc5c7d7efd6780c2133d47ab6beba3218" translate="yes" xml:space="preserve">
          <source>Finally, the Mytest.xs file should look something like this:</source>
          <target state="translated">마지막으로 Mytest.xs 파일은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="c759b85c1874191b3c67e6077ecccb7f1cac3596" translate="yes" xml:space="preserve">
          <source>Finally, the Perl community as a whole recognizes that respect for ownership of code, respect for artistic control, proper credit, and active effort to prevent unintentional code skew or communication gaps is vital to the health of the community and Perl itself. Members of a community should not normally have to resort to rules and laws to deal with each other, and this document, although it contains rules so as to be clear, is about an attitude and general approach. The first step in any dispute should be open communication, respect for opposing views, and an attempt at a compromise. In nearly every circumstance nothing more will be necessary, and certainly no more drastic measure should be used until every avenue of communication and discussion has failed.</source>
          <target state="translated">마지막으로, Perl 커뮤니티는 코드 소유권에 대한 존중, 예술적 통제, 적절한 신용에 대한 존중 및 의도하지 않은 코드 왜곡 또는 통신 격차를 방지하기위한 적극적인 노력이 커뮤니티와 Perl 자체의 건강에 매우 중요하다는 것을 인식합니다. 공동체 구성원은 일반적으로 서로를 다루기 위해 규칙과 법률에 의지 할 필요가 없으며,이 문서는 명확하게 규칙이 포함되어 있지만 태도와 일반적인 접근 방식에 관한 것입니다. 분쟁의 첫 단계는 공개 커뮤니케이션, 반대 의견에 대한 존중 및 타협 시도입니다. 거의 모든 상황에서 더 이상 필요한 것은 없으며, 의사 소통과 토론의 모든 길이 실패 할 때까지 더 이상 과감한 조치를 취해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="73b5ad0b05d4d0374aa60aaf0eda94d058db5ae7" translate="yes" xml:space="preserve">
          <source>Finally, the documentation. The job is never done until the paperwork is over, so let's describe the change we've just made. The relevant place is</source>
          <target state="translated">마지막으로 문서. 서류 작업이 끝날 때까지 작업이 완료되지 않으므로 방금 변경 한 내용을 설명하겠습니다. 관련 장소는</target>
        </trans-unit>
        <trans-unit id="80876825b2c59d50931c0454f32d3120b5201e0a" translate="yes" xml:space="preserve">
          <source>Finally, the following set of approaches was offered by Jeffrey Friedl, whose article in issue #5 of The Perl Journal talks about this very matter.</source>
          <target state="translated">마지막으로 Jeffrey Friedl은 Perl Journal 5 호 기사에서이 문제에 대해 다음과 같은 접근 방식을 제시했습니다.</target>
        </trans-unit>
        <trans-unit id="3dff018de1b9478268177e77483e9300bee06c55" translate="yes" xml:space="preserve">
          <source>Finally, the message also can happen under the &lt;code&gt;/x&lt;/code&gt; regex modifier when the &lt;code&gt;\N&lt;/code&gt; is separated by spaces from the &lt;code&gt;{&lt;/code&gt;, in which case, remove the spaces.</source>
          <target state="translated">마지막으로, &lt;code&gt;\N&lt;/code&gt; 이 &lt;code&gt;{&lt;/code&gt; 와 공백으로 분리 될 때 &lt;code&gt;/x&lt;/code&gt; 정규식 수정 자 아래에서 메시지가 발생할 수도 있습니다.이 경우 공백을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="778ba92f0eda34f1617f29aaf6a42ae17012b6e9" translate="yes" xml:space="preserve">
          <source>Finally, the multiple-angle-bracket form does</source>
          <target state="translated">마지막으로 다중 앵글 브래킷 양식은</target>
        </trans-unit>
        <trans-unit id="63f8e8ad12d75d623f33e44387f1b276ef571892" translate="yes" xml:space="preserve">
          <source>Finally, there is a &lt;code&gt;LOGOP&lt;/code&gt; , or logic op. Like a &lt;code&gt;LISTOP&lt;/code&gt; , this has one or more children, but it doesn't have an &lt;code&gt;op_last&lt;/code&gt; field: so you have to follow &lt;code&gt;op_first&lt;/code&gt; and then the &lt;code&gt;OpSIBLING&lt;/code&gt; chain itself to find the last child. Instead it has an &lt;code&gt;op_other&lt;/code&gt; field, which is comparable to the &lt;code&gt;op_next&lt;/code&gt; field described below, and represents an alternate execution path. Operators like &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;?&lt;/code&gt; are &lt;code&gt;LOGOP&lt;/code&gt; s. Note that in general, &lt;code&gt;op_other&lt;/code&gt; may not point to any of the direct children of the &lt;code&gt;LOGOP&lt;/code&gt; .</source>
          <target state="translated">마지막으로 &lt;code&gt;LOGOP&lt;/code&gt; 또는 논리 연산이 있습니다. 유사한 &lt;code&gt;LISTOP&lt;/code&gt; 이 하나 이상의 아이를 가지고 있지만, 그것은이없는 &lt;code&gt;op_last&lt;/code&gt; 필드 : 당신이 따라야 할 수 있도록 &lt;code&gt;op_first&lt;/code&gt; 다음 &lt;code&gt;OpSIBLING&lt;/code&gt; 의 체인 자체가 마지막 자식을 찾을 수 있습니다. 대신 &lt;code&gt;op_other&lt;/code&gt; 필드 가 있으며 ,이 필드는 아래 설명 된 &lt;code&gt;op_next&lt;/code&gt; 필드 와 비슷 하며 대체 실행 경로를 나타냅니다. &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;?&lt;/code&gt; 같은 연산자 있습니다 &lt;code&gt;LOGOP&lt;/code&gt; 들. 일반적으로,주의 &lt;code&gt;op_other&lt;/code&gt; 가 의 직접 아이들의 가리하지 않을 수 있습니다 &lt;code&gt;LOGOP&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a7cdec53bb27d155c030f9892a0eeb03fd88eb1" translate="yes" xml:space="preserve">
          <source>Finally, there is also an entirely different approach by unpacking big endian shorts and packing them in the reverse byte order:</source>
          <target state="translated">마지막으로 빅 엔디안 반바지를 풀고 역 바이트 순서로 포장하여 완전히 다른 접근 방식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="453b0692eb90c0dfa9ea5982b6a592f258b890f5" translate="yes" xml:space="preserve">
          <source>Finally, there is the code that actually does the filtering. For this type of Perl source filter, all the filtering is done in a method called &lt;code&gt;filter()&lt;/code&gt; . (It is also possible to write a Perl source filter using a closure. See the &lt;code&gt;Filter::Util::Call&lt;/code&gt; manual page for more details.) It's called every time the Perl parser needs another line of source to process. The &lt;code&gt;filter()&lt;/code&gt; method, in turn, reads lines from the source stream using the &lt;code&gt;filter_read()&lt;/code&gt; function.</source>
          <target state="translated">마지막으로 실제로 필터링을 수행하는 코드가 있습니다. 이 유형의 Perl 소스 필터의 경우 모든 필터링은 &lt;code&gt;filter()&lt;/code&gt; 라는 메소드에서 수행됩니다 . 클로저를 사용하여 Perl 소스 필터를 작성할 수도 있습니다. 자세한 내용은 &lt;code&gt;Filter::Util::Call&lt;/code&gt; 매뉴얼 페이지를 참조하십시오. Perl 파서가 처리 할 다른 소스 행이 필요할 때마다 호출됩니다. &lt;code&gt;filter()&lt;/code&gt; 메소드는, 차례로 사용하여 소스 스트림으로부터 판독 라인 &lt;code&gt;filter_read()&lt;/code&gt; 함수.</target>
        </trans-unit>
        <trans-unit id="dff384a2e72772724b586203a02673aa837c967d" translate="yes" xml:space="preserve">
          <source>Finally, using accessors makes inheritance much simpler. Subclasses can use the accessors rather than having to know how a parent class is implemented internally.</source>
          <target state="translated">마지막으로 접근자를 사용하면 상속이 훨씬 간단 해집니다. 서브 클래스는 부모 클래스가 내부적으로 어떻게 구현되는지 알 필요없이 접근자를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0ee269426b10540758eda6f3baa910232cd84eb" translate="yes" xml:space="preserve">
          <source>Finally, we have &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Tiny&quot;&gt;Class::Tiny&lt;/a&gt;. This module truly lives up to its name. It has an incredibly minimal API and absolutely no dependencies on any recent Perl. Still, we think it's a lot easier to use than writing your own OO code from scratch.</source>
          <target state="translated">마지막으로 &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Tiny&quot;&gt;Class :: Tiny가&lt;/a&gt; 있습니다. 이 모듈은 그 이름 그대로입니다. API는 매우 작고 최근 Perl에 의존하지 않습니다. 여전히, 우리는 처음부터 자신의 OO 코드를 작성하는 것보다 사용하기가 훨씬 쉽다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="80f162582be94b96acbf3901ff2dad6e5237d61d" translate="yes" xml:space="preserve">
          <source>Finally, when &lt;code&gt;filter&lt;/code&gt; or the anonymous sub are finished processing, they are expected to return the filtered source using &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">마지막으로, &lt;code&gt;filter&lt;/code&gt; 또는 anonymous 서브 처리가 완료되면 &lt;code&gt;$_&lt;/code&gt; 사용하여 필터링 된 소스를 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="237e2517518e5a7e38bf850e59773fff293d743f" translate="yes" xml:space="preserve">
          <source>Finally, you can append an optional third argument, in &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;,&lt;i&gt;arg2&lt;/i&gt;, &lt;i&gt;note&lt;/i&gt;)&lt;/code&gt;, where</source>
          <target state="translated">마지막으로 &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;,&lt;i&gt;arg2&lt;/i&gt;, &lt;i&gt;note&lt;/i&gt;)&lt;/code&gt; 선택적 세 번째 인수를 추가 할 수 있습니다 . 여기서</target>
        </trans-unit>
        <trans-unit id="694939534870b0a1edb23c3bf281899ee38f8c47" translate="yes" xml:space="preserve">
          <source>Finally, you'll need to copy the extension's Perl library module to the</source>
          <target state="translated">마지막으로, 확장의 Perl 라이브러리 모듈을</target>
        </trans-unit>
        <trans-unit id="860f05ae24e478a14a3acf15fc650e6557c5de7d" translate="yes" xml:space="preserve">
          <source>Find POD documents in directory trees</source>
          <target state="translated">디렉토리 트리에서 POD 문서 찾기</target>
        </trans-unit>
        <trans-unit id="e1857def4ee2d2eb29e93e010b1a0b29040a49b1" translate="yes" xml:space="preserve">
          <source>Find a named lexical anywhere in a chain of nested pads. Add fake entries in the inner pads if it's found in an outer one.</source>
          <target state="translated">중첩 된 패드 체인에서 어휘 이름이 지정된 어휘를 찾으십시오. 외부 패드에서 발견되면 내부 패드에 가짜 항목을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="4564f34f47e157e7d1dad65f67463f62f1be357a" translate="yes" xml:space="preserve">
          <source>Find an area of Perl that seems interesting to you, and see if you can work out how it works. Scan through the source, and step over it in the debugger. Play, poke, investigate, fiddle! You'll probably get to understand not just your chosen area but a much wider range of</source>
          <target state="translated">당신에게 흥미로워지는 Perl의 영역을 찾고 그것이 어떻게 작동하는지 알아보십시오. 소스를 스캔하고 디버거에서 소스를 살펴 봅니다. 플레이, 찌르기, 조사, 바이올린! 당신은 아마 당신이 선택한 지역뿐만 아니라 훨씬 더 넓은 범위를 이해하게 될 것입니다</target>
        </trans-unit>
        <trans-unit id="b0f962c203daff2b574f4bbd4661b46cb058cc00" translate="yes" xml:space="preserve">
          <source>Find and return the variable that is named &lt;code&gt;$_&lt;/code&gt; in the lexical scope of the currently-executing function. This may be a lexical &lt;code&gt;$_&lt;/code&gt; , or will otherwise be the global one.</source>
          <target state="translated">현재 실행중인 함수의 어휘 범위에서 이름이 &lt;code&gt;$_&lt;/code&gt; 인 변수를 찾아 반환합니다 . 이것은 어휘 &lt;code&gt;$_&lt;/code&gt; 일 수도 있고 그렇지 않으면 전역일 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="418498cca51e97a1b0d2b4c89d2b05e75464656f" translate="yes" xml:space="preserve">
          <source>Find out whether a plan has been defined. &lt;code&gt;$plan&lt;/code&gt; is either &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (no plan has been set), &lt;code&gt;no_plan&lt;/code&gt; (indeterminate # of tests) or an integer (the number of expected tests).</source>
          <target state="translated">계획이 정의되었는지 확인하십시오. &lt;code&gt;$plan&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (계획이 설정되지 않음), &lt;code&gt;no_plan&lt;/code&gt; (결정되지 않은 테스트 수) 또는 정수 (예상 테스트 수)입니다.</target>
        </trans-unit>
        <trans-unit id="4ac57f2d73d65d94cbdbe0755aabac6325af065d" translate="yes" xml:space="preserve">
          <source>Find the general category of a numeric codepoint.</source>
          <target state="translated">숫자 코드 포인트의 일반 범주를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="a49c3913d7af3c4d57a065a7a52f55890db2015f" translate="yes" xml:space="preserve">
          <source>Find the name of the undefined variable (if any) that caused the operator to issue a &quot;Use of uninitialized value&quot; warning. If match is true, only return a name if its value matches uninit_sv. So roughly speaking, if a unary operator (such as OP_COS) generates a warning, then following the direct child of the op may yield an OP_PADSV or OP_GV that gives the name of the undefined variable. On the other hand, with OP_ADD there are two branches to follow, so we only print the variable name if we get an exact match. desc_p points to a string pointer holding the description of the op. This may be updated if needed.</source>
          <target state="translated">연산자가 &quot;초기화되지 않은 값 사용&quot;경고를 발생시키는 정의되지 않은 변수 (있는 경우)의 이름을 찾으십시오. match가 true이면 해당 값이 uninit_sv와 일치하는 경우에만 이름을 반환합니다. 대략적으로 말하면, 단항 연산자 (예 : OP_COS)가 경고를 생성하면 op의 직계 자식을 따라 정의되지 않은 변수의 이름을 제공하는 OP_PADSV 또는 OP_GV가 생성 될 수 있습니다. 반면에 OP_ADD에는 두 가지 분기가 있으므로 정확히 일치하는 경우에만 변수 이름을 인쇄합니다. desc_p는 op에 대한 설명을 담고있는 문자열 포인터를 가리 킵니다. 필요한 경우 업데이트 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ac43fb4e0d5bd1c0782abaa41490e339609fd8c" translate="yes" xml:space="preserve">
          <source>Find the position of the lexical &lt;code&gt;$_&lt;/code&gt; in the pad of the currently-executing function. Returns the offset in the current pad, or &lt;code&gt;NOT_IN_PAD&lt;/code&gt; if there is no lexical &lt;code&gt;$_&lt;/code&gt; in scope (in which case the global one should be used instead). &lt;a href=&quot;#find_rundefsv&quot;&gt;find_rundefsv&lt;/a&gt; is likely to be more convenient.</source>
          <target state="translated">현재 실행중인 함수의 패드에서 어휘 &lt;code&gt;$_&lt;/code&gt; 의 위치를 ​​찾으십시오 . 현재 패드의 오프셋을 반환하거나 범위에 어휘 &lt;code&gt;$_&lt;/code&gt; 가 없으면 &lt;code&gt;NOT_IN_PAD&lt;/code&gt; 를 반환합니다 (이 경우 전역 오프셋을 대신 사용해야 함). &lt;a href=&quot;#find_rundefsv&quot;&gt;find_rundefsv&lt;/a&gt; 가 더 편리 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="449a6849d1b11914b85fc078a256f3db73a2b32b" translate="yes" xml:space="preserve">
          <source>Find the start position where a regex match should be attempted, or possibly if the regex engine should not be run because the pattern can't match. This is called, as appropriate, by the core, depending on the values of the &lt;code&gt;extflags&lt;/code&gt; member of the &lt;code&gt;regexp&lt;/code&gt; structure.</source>
          <target state="translated">정규식 일치를 시도하거나 패턴이 일치하지 않아서 정규식 엔진을 실행하지 않아야하는 시작 위치를 찾으십시오. 이것은 적절하게 &lt;code&gt;regexp&lt;/code&gt; 구조 의 &lt;code&gt;extflags&lt;/code&gt; 멤버 값에 따라 코어에 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="6483e76c333ac42379066b4aedb6e408fdbe129b" translate="yes" xml:space="preserve">
          <source>FindBin</source>
          <target state="translated">FindBin</target>
        </trans-unit>
        <trans-unit id="24c31d2b2286d66b429b3c123e559310944ed2de" translate="yes" xml:space="preserve">
          <source>FindBin - Locate directory of original perl script</source>
          <target state="translated">FindBin-원래 펄 스크립트의 디렉토리를 찾습니다</target>
        </trans-unit>
        <trans-unit id="4369a8a5c4e42e43d5e7bb66ccfd1c78f33f275a" translate="yes" xml:space="preserve">
          <source>FindBin - optional module which deals with paths relative to the source file.</source>
          <target state="translated">FindBin-소스 파일과 관련된 경로를 처리하는 선택적 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="f086fc99759a8e3bb0203cfe84782842d1a193aa" translate="yes" xml:space="preserve">
          <source>FindBin is supported as part of the core perl distribution. Please send bug reports to &amp;lt;</source>
          <target state="translated">FindBin은 핵심 perl 배포의 일부로 지원됩니다. 버그 신고를 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="9448bfafc842c027dacc4896519d4bae55c41c99" translate="yes" xml:space="preserve">
          <source>Finding IANA Character Set Registry names</source>
          <target state="translated">IANA 문자 세트 레지스트리 이름 찾기</target>
        </trans-unit>
        <trans-unit id="eef2fdb8cb6b261375ae8d62a702d5b95f90b35a" translate="yes" xml:space="preserve">
          <source>Finding Magic</source>
          <target state="translated">마법 찾기</target>
        </trans-unit>
        <trans-unit id="e4f6c5e89298ef6e35e80792cf1b54756849aae5" translate="yes" xml:space="preserve">
          <source>Finding and running system commands made easy</source>
          <target state="translated">손쉬운 시스템 명령 찾기 및 실행</target>
        </trans-unit>
        <trans-unit id="96480ceeb561d8e5864564872e9b2a46637a4002" translate="yes" xml:space="preserve">
          <source>Finding locales</source>
          <target state="translated">로케일 찾기</target>
        </trans-unit>
        <trans-unit id="87d12ac1eef851da5ad3ec16ab4427086784516f" translate="yes" xml:space="preserve">
          <source>Finding packages and VERSION</source>
          <target state="translated">패키지 및 버전 찾기</target>
        </trans-unit>
        <trans-unit id="6d70dab88d530f69df03bc2322d08f1cd465a479" translate="yes" xml:space="preserve">
          <source>Finds the executables PERL and FULLPERL</source>
          <target state="translated">PERL 및 FULLPERL 실행 파일을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="22bcd7072415a74f9601a9db40691f4be186016b" translate="yes" xml:space="preserve">
          <source>Finds the magic pointer for type matching the SV. See &lt;code&gt;sv_magic&lt;/code&gt; .</source>
          <target state="translated">SV와 일치하는 유형의 마술 포인터를 찾습니다. &lt;code&gt;sv_magic&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="25d979215bfecc25b84803c1f222b66fe8c9e2ae" translate="yes" xml:space="preserve">
          <source>Finds the magic pointer of &lt;code&gt;type&lt;/code&gt; with the given &lt;code&gt;vtbl&lt;/code&gt; for the &lt;code&gt;SV&lt;/code&gt; . See &lt;code&gt;sv_magicext&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;SV&lt;/code&gt; 에 대해 주어진 &lt;code&gt;vtbl&lt;/code&gt; 을 사용하여 &lt;code&gt;type&lt;/code&gt; 의 마술 포인터를 찾습니다 . &lt;code&gt;sv_magicext&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="267b05432936f6d23e350d21b3fe892d9d8dbea3" translate="yes" xml:space="preserve">
          <source>Fire the debugger up again on your script and we'll look at the help menu. There's a couple of ways of calling help: a simple '&lt;b&gt;h&lt;/b&gt;' will get the summary help list, '&lt;b&gt;|h&lt;/b&gt;' (pipe-h) will pipe the help through your pager (which is (probably 'more' or 'less'), and finally, '&lt;b&gt;h h&lt;/b&gt;' (h-space-h) will give you the entire help screen. Here is the summary page:</source>
          <target state="translated">스크립트에서 디버거를 다시 시작하면 도움말 메뉴가 표시됩니다. 도움말을 호출하는 몇 가지 방법이 있습니다. 간단한 ' &lt;b&gt;h&lt;/b&gt; '는 요약 도움말 목록을 얻습니다. ' &lt;b&gt;| h&lt;/b&gt; '(pipe-h)는 호출기를 통해 도움말을 파이프합니다 (아마도 'more'또는 'less'). 마지막으로 ' &lt;b&gt;hh&lt;/b&gt; '(h-space-h)는 전체 도움말 화면을 제공합니다. 요약 페이지는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cef42e83f0eb4f1a99e0bddde90be004038a21df" translate="yes" xml:space="preserve">
          <source>Fires when Perl has successfully loaded an individual file, whether from &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;. This probe fires after the file is read from disk and its contents evaluated. The filename argument is converted to local filesystem paths instead of providing &lt;code&gt;Module::Name&lt;/code&gt; -style names.</source>
          <target state="translated">Perl이 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 에서 개별 파일을 성공적으로로드했을 때 발생합니다 . 이 프로브는 파일을 디스크에서 읽고 내용을 평가 한 후에 실행됩니다. filename 인수는 &lt;code&gt;Module::Name&lt;/code&gt; -style 이름 을 제공하는 대신 로컬 파일 시스템 경로로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="7704de478a9404e667918d6d09d2c1e3a1cb6a87" translate="yes" xml:space="preserve">
          <source>Fires when Perl is about to load an individual file, whether from &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;. This probe fires before the file is read from disk. The filename argument is converted to local filesystem paths instead of providing &lt;code&gt;Module::Name&lt;/code&gt; -style names.</source>
          <target state="translated">Perl이 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 에서 개별 파일을로드하려고 할 때 발생합니다 . 이 프로브는 파일을 디스크에서 읽기 전에 시작됩니다. filename 인수는 &lt;code&gt;Module::Name&lt;/code&gt; -style 이름 을 제공하는 대신 로컬 파일 시스템 경로로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="49d7fed0e266f24545d9104466ab74b18bdd8f35" translate="yes" xml:space="preserve">
          <source>Firewalls can be categorized into three basic types.</source>
          <target state="translated">방화벽은 세 가지 기본 유형으로 분류 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a00bc27da396d3a81b2819430816be98253f7657" translate="yes" xml:space="preserve">
          <source>First In, First Out. See also &lt;b&gt;LIFO&lt;/b&gt;. Also a nickname for a &lt;b&gt;named pipe&lt;/b&gt;.</source>
          <target state="translated">선입 선출. &lt;b&gt;LIFO&lt;/b&gt; 도 참조하십시오 . &lt;b&gt;명명 된 파이프&lt;/b&gt; 의 별명이기도합니다 .</target>
        </trans-unit>
        <trans-unit id="8fe7145d9c6c14d380f19ecbb52aad0be3d15872" translate="yes" xml:space="preserve">
          <source>First available in Perl 5.10.1 (the 5.10.0 version behaved differently), binary &lt;code&gt;~~&lt;/code&gt; does a &quot;smartmatch&quot; between its arguments. This is mostly used implicitly in the &lt;code&gt;when&lt;/code&gt; construct described in &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt;, although not all &lt;code&gt;when&lt;/code&gt; clauses call the smartmatch operator. Unique among all of Perl's operators, the smartmatch operator can recurse. The smartmatch operator is &lt;a href=&quot;perlpolicy#experimental&quot;&gt;experimental&lt;/a&gt; and its behavior is subject to change.</source>
          <target state="translated">Perl 5.10.1 (5.10.0 버전과 다르게 동작)에서 처음 사용할 수있는 binary &lt;code&gt;~~&lt;/code&gt; 는 인수간에 &quot;스마트 매치&quot;를 수행합니다. 이것은 대부분의 내재적 사용되는 &lt;code&gt;when&lt;/code&gt; 에 기술 된 구조 &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt; 아니지만 모든 &lt;code&gt;when&lt;/code&gt; 절이 smartmatch 오퍼레이터를 호출한다. 모든 Perl 운영자 중 고유 한 smartmatch 운영자는 재귀 할 수 있습니다. 스마트 매치 연산자는 &lt;a href=&quot;perlpolicy#experimental&quot;&gt;실험&lt;/a&gt; 중이며 동작은 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63af0ded76d246a89c78d019ed5af7004abaf7ca" translate="yes" xml:space="preserve">
          <source>First does a distdir. Then a command $(PREOP) which defaults to a null command, followed by $(TO_UNIX), which defaults to a null command under UNIX, and will convert files in distribution directory to UNIX format otherwise. Next it runs &lt;code&gt;tar&lt;/code&gt; on that directory into a tarfile and deletes the directory. Finishes with a command $(POSTOP) which defaults to a null command.</source>
          <target state="translated">먼저 distdir을 수행합니다. 그런 다음, $ (PREOP) 명령은 기본적으로 널 명령으로 설정되고, $ (TO_UNIX)가 뒤에 오는 UNIX에서는 널 명령으로 설정되며, 그렇지 않으면 분배 디렉토리의 파일을 UNIX 형식으로 변환합니다. 그 다음으로 실행 &lt;code&gt;tar&lt;/code&gt; tar 파일에 해당 디렉토리에와 디렉토리를 삭제합니다. 기본적으로 널 명령으로 설정된 $ (POSTOP) 명령으로 완료합니다.</target>
        </trans-unit>
        <trans-unit id="2af22b932d239ecb2692524f84027e701417e610" translate="yes" xml:space="preserve">
          <source>First does a distdir. Then a command $(PREOP) which defaults to a null command. Next it runs &lt;code&gt;shar&lt;/code&gt; on that directory into a sharfile and deletes the intermediate directory again. Finishes with a command $(POSTOP) which defaults to a null command. Note: For shdist to work properly a &lt;code&gt;shar&lt;/code&gt; program that can handle directories is mandatory.</source>
          <target state="translated">먼저 distdir을 수행합니다. 그런 다음 $ (PREOP) 명령은 기본적으로 널 명령입니다. 다음 으로 해당 디렉토리 에서 &lt;code&gt;shar&lt;/code&gt; 를 sharfile로 실행 하고 중간 디렉토리를 다시 삭제합니다. 기본적으로 널 명령으로 설정된 $ (POSTOP) 명령으로 완료합니다. 참고 : shdist이 제대로 작동 할 수있는 &lt;code&gt;shar&lt;/code&gt; 디렉토리를 처리 할 수있는 프로그램이 필수입니다.</target>
        </trans-unit>
        <trans-unit id="32b6865bf0f3ae68c2cf337647431ed6a911b654" translate="yes" xml:space="preserve">
          <source>First does a distdir. Then a command $(PREOP) which defaults to a null command. Runs &lt;code&gt;$(ZIP) $(ZIPFLAGS)&lt;/code&gt; on that directory into a zipfile. Then deletes that directory. Finishes with a command $(POSTOP) which defaults to a null command.</source>
          <target state="translated">먼저 distdir을 수행합니다. 그런 다음 $ (PREOP) 명령은 기본적으로 널 명령입니다. 실행 &lt;code&gt;$(ZIP) $(ZIPFLAGS)&lt;/code&gt; ZipFile를에 그 디렉토리에. 그런 다음 해당 디렉토리를 삭제합니다. 기본적으로 널 명령으로 설정된 $ (POSTOP) 명령으로 완료합니다.</target>
        </trans-unit>
        <trans-unit id="87237cd69962d954afc8149676070ba7e99a30f3" translate="yes" xml:space="preserve">
          <source>First is the &quot;transitional compilation environment&quot;, described in lfcompile64(5). According to the man page,</source>
          <target state="translated">첫 번째는 lfcompile64 (5)에 설명 된 &quot;전환 컴파일 환경&quot;입니다. 매뉴얼 페이지에 따르면</target>
        </trans-unit>
        <trans-unit id="39f2e43e592aba75880c16ffdbd2296c6893e732" translate="yes" xml:space="preserve">
          <source>First of all &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; gets the type of the third parameter ('CODE' in this case). &lt;code&gt;attributes.pm&lt;/code&gt; checks if there is a subroutine called &lt;code&gt;MODIFY_&amp;lt;reftype&amp;gt;_ATTRIBUTES&lt;/code&gt; in the caller's namespace (here: 'main'). In this case a subroutine &lt;code&gt;MODIFY_CODE_ATTRIBUTES&lt;/code&gt; is required. Then this method is called to check if you have used a &quot;bad attribute&quot;. The subroutine call in this example would look like</source>
          <target state="translated">우선 모든 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 는 세 번째 매개 변수 유형 (이 경우 'CODE')을 가져옵니다 . &lt;code&gt;attributes.pm&lt;/code&gt; 은 호출자의 네임 스페이스 (여기서는 'main')에 &lt;code&gt;MODIFY_&amp;lt;reftype&amp;gt;_ATTRIBUTES&lt;/code&gt; 라는 서브 루틴이 있는지 확인합니다 . 이 경우 서브 루틴 &lt;code&gt;MODIFY_CODE_ATTRIBUTES&lt;/code&gt; 가 필요합니다. 그런 다음 &quot;나쁜 특성&quot;을 사용했는지 확인하기 위해이 메소드가 호출됩니다. 이 예제에서 서브 루틴 호출은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a5edeb3fa4c30eb9326cfd6ee3072f89d302a7fb" translate="yes" xml:space="preserve">
          <source>First of all note that if you're doing this for security reasons (to avoid people seeing passwords, for example) then you should rewrite your program so that critical information is never given as an argument. Hiding the arguments won't make your program completely secure.</source>
          <target state="translated">우선 보안상의 이유로이 작업을 수행하는 경우 (예를 들어 사람들이 암호를 보지 않도록) 중요한 정보가 인수로 제공되지 않도록 프로그램을 다시 작성해야합니다. 논쟁을 숨기더라도 프로그램이 완전히 안전하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="02342cfce74aa40ebbe7459fd67794792aa8eda6" translate="yes" xml:space="preserve">
          <source>First of all note that you have full access to the Symbian device when using Perl: you can do a lot of damage to your device (like removing system files) unless you are careful. Please do take backups before doing anything.</source>
          <target state="translated">우선 Perl을 사용할 때 Symbian 장치에 완전히 액세스 할 수 있습니다.주의하지 않으면 장치 파일을 제거하는 등 장치에 많은 손상을 줄 수 있습니다. 무엇이든하기 전에 백업을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="1463803ecb1c9b404836c68a0992ffedefb430c0" translate="yes" xml:space="preserve">
          <source>First of all, have you tried using the &lt;b&gt;-w&lt;/b&gt; switch?</source>
          <target state="translated">우선, &lt;b&gt;-w&lt;/b&gt; 스위치 를 사용해 &lt;b&gt;보셨습니까&lt;/b&gt; ?</target>
        </trans-unit>
        <trans-unit id="a4f52d54cf15399bdc6e2cfb2dc28b7c88455e40" translate="yes" xml:space="preserve">
          <source>First of all, however, you</source>
          <target state="translated">그러나 우선, 당신은</target>
        </trans-unit>
        <trans-unit id="83147c6de1b08740dd2da15332f4959df7841375" translate="yes" xml:space="preserve">
          <source>First of all, there's a few things you can do to make your life a lot more straightforward when it comes to debugging perl programs, without using the debugger at all. To demonstrate, here's a simple script, named &quot;hello&quot;, with a problem:</source>
          <target state="translated">우선, 디버거를 전혀 사용하지 않고 펄 프로그램을 디버깅 할 때 삶을 훨씬 간단하게 만들기 위해 할 수있는 몇 가지가 있습니다. 다음은 문제가있는 &quot;hello&quot;라는 간단한 스크립트입니다.</target>
        </trans-unit>
        <trans-unit id="04c84bafcaec13f658619ad91db4027ae060911a" translate="yes" xml:space="preserve">
          <source>First of all, when doing a match, one may get no run-time output even if debugging is enabled. This means that the regex engine was never entered and that all of the job was therefore done by the optimizer.</source>
          <target state="translated">우선, 일치하는 경우 디버깅이 활성화되어 있어도 런타임 출력이 나타나지 않을 수 있습니다. 이것은 정규식 엔진이 입력되지 않았으므로 모든 작업이 최적화 프로그램에 의해 수행되었음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="960494596b28f0ed04786d5db795d0496594f162" translate="yes" xml:space="preserve">
          <source>First off, you must have zlib 1.0.5 or better.</source>
          <target state="translated">먼저 zlib 1.0.5 이상이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="5548dc2d3eeb7fa10ed6d62335952f1161d1be5c" translate="yes" xml:space="preserve">
          <source>First problem: deciding which functions will be public API functions and which will be private. All functions whose names begin &lt;code&gt;S_&lt;/code&gt; are private (think &quot;S&quot; for &quot;secret&quot; or &quot;static&quot;). All other functions begin with &quot;Perl_&quot;, but just because a function begins with &quot;Perl_&quot; does not mean it is part of the API. (See &lt;a href=&quot;#Internal-Functions&quot;&gt;Internal Functions&lt;/a&gt;.) The easiest way to be &lt;b&gt;sure&lt;/b&gt; a function is part of the API is to find its entry in &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;. If it exists in &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;, it's part of the API. If it doesn't, and you think it should be (i.e., you need it for your extension), send mail via &lt;a href=&quot;perlbug&quot;&gt;perlbug&lt;/a&gt; explaining why you think it should be.</source>
          <target state="translated">첫 번째 문제 : 어떤 함수가 공개 API 함수이고 어떤 함수가 개인 함수인지 결정. 이름이 &lt;code&gt;S_&lt;/code&gt; 로 시작하는 모든 함수 는 개인용입니다 ( &quot;secret&quot;또는 &quot;static&quot;에 대해 &quot;S&quot;를 생각하십시오). 다른 모든 함수는 &quot;Perl_&quot;로 시작하지만 함수가 &quot;Perl_&quot;로 시작한다고해서 이것이 API의 일부라는 의미는 아닙니다. ( &lt;a href=&quot;#Internal-Functions&quot;&gt;내부 함수를&lt;/a&gt; 참조하십시오 .) 함수가 API의 일부 &lt;b&gt;인지 확인&lt;/b&gt; 하는 가장 쉬운 방법 은 &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; 에서 해당 항목을 찾는 것 입니다. &lt;a href=&quot;perlapi&quot;&gt;perlapi에&lt;/a&gt; 존재 하면 API의 일부입니다. 그렇지 않다면 생각해야한다고 생각하는 경우 (즉, 확장에 필요한 경우) &lt;a href=&quot;perlbug&quot;&gt;perlbug&lt;/a&gt; 를 통해 이유를 설명하는 메일을 보내 십시오.</target>
        </trans-unit>
        <trans-unit id="6c6d177453ba632a0301eb097966ff6e4ecd7e13" translate="yes" xml:space="preserve">
          <source>First runs the &lt;code&gt;get&lt;/code&gt; method to make sure the distribution is downloaded and unpacked. Changes to the directory where the distribution has been unpacked and runs the external commands &lt;code&gt;perl
Makefile.PL&lt;/code&gt; or &lt;code&gt;perl Build.PL&lt;/code&gt; and &lt;code&gt;make&lt;/code&gt; there.</source>
          <target state="translated">먼저 &lt;code&gt;get&lt;/code&gt; 메소드를 실행하여 분배가 다운로드되고 압축 해제되었는지 확인하십시오. 분배 포장을 풀고 설치와 외부 명령을 실행 한 디렉토리로 변경 &lt;code&gt;perl Makefile.PL&lt;/code&gt; 이나 &lt;code&gt;perl Build.PL&lt;/code&gt; 하고 &lt;code&gt;make&lt;/code&gt; 가.</target>
        </trans-unit>
        <trans-unit id="8990c7669972aeb5dbf3f8f7c6f26f615b1eba3b" translate="yes" xml:space="preserve">
          <source>First try</source>
          <target state="translated">첫 시도</target>
        </trans-unit>
        <trans-unit id="8c24340fb0abf478cd12d4c9a81be46a9b570102" translate="yes" xml:space="preserve">
          <source>First version July 22, 1998; last revised November 21, 2001.</source>
          <target state="translated">최초 버전 1998 년 7 월 22 일; 2001 년 11 월 21 일 최종 개정.</target>
        </trans-unit>
        <trans-unit id="f0bcb6253b995340d8661abf6d3eb20fd1447df3" translate="yes" xml:space="preserve">
          <source>First you extract the keys from the hashes into lists, then solve the &quot;removing duplicates&quot; problem described above. For example:</source>
          <target state="translated">먼저 해시에서 키를 목록으로 추출한 다음 위에서 설명한 &quot;중복 제거&quot;문제를 해결하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2044f5e8e1c516409eb219e4d2d2da652d96754d" translate="yes" xml:space="preserve">
          <source>First you get the BS2000 commandline prompt ('*'). Here you may enter your parameters, e.g. &lt;code&gt;-e 'print &quot;Hello World!\\n&quot;;'&lt;/code&gt; (note the double backslash!) or &lt;code&gt;-w&lt;/code&gt; and the name of your Perl script. Filenames starting with &lt;code&gt;/&lt;/code&gt; are searched in the Posix filesystem, others are searched in the BS2000 filesystem. You may even use wildcards if you put a &lt;code&gt;%&lt;/code&gt; in front of your filename (e.g. &lt;code&gt;-w
checkfiles.pl %*.c&lt;/code&gt; ). Read your C/C++ manual for additional possibilities of the commandline prompt (look for PARAMETER-PROMPTING).</source>
          <target state="translated">먼저 BS2000 명령 줄 프롬프트 ( '*')가 나타납니다. 여기에 매개 변수를 입력 할 수 있습니다 (예 : &lt;code&gt;-e 'print &quot;Hello World!\\n&quot;;'&lt;/code&gt; (이중 백 슬래시를 참고하십시오!) 또는 &lt;code&gt;-w&lt;/code&gt; 및 Perl 스크립트의 이름. &lt;code&gt;/&lt;/code&gt; 로 시작하는 파일 이름 은 Posix 파일 시스템에서 검색되고 다른 파일 이름 은 BS2000 파일 시스템에서 검색됩니다. 파일 이름 앞에 &lt;code&gt;%&lt;/code&gt; 를 넣으면 와일드 카드를 사용할 수도 있습니다 (예 : &lt;code&gt;-w checkfiles.pl %*.c&lt;/code&gt; ). 명령 행 프롬프트의 추가 가능성에 대해서는 C / C ++ 매뉴얼을 읽으십시오 (PARAMETER-PROMPTING 찾기).</target>
        </trans-unit>
        <trans-unit id="69813602a455899e097cd99c025cf3e1ca0fd741" translate="yes" xml:space="preserve">
          <source>First you'll need to know how to convert between C types and Perl types, with newSViv() and sv_setnv() and newAV() and all their friends. They're described in &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; and &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;.</source>
          <target state="translated">먼저 newSViv () 및 sv_setnv () 및 newAV () 및 모든 친구를 사용하여 C 유형과 Perl 유형 사이를 변환하는 방법을 알아야합니다. 그것들은 &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; 와 &lt;a href=&quot;perlapi&quot;&gt;perlapi에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d47635cc5b345a29da6fbd6f1b60ef579fbee7af" translate="yes" xml:space="preserve">
          <source>First,</source>
          <target state="translated">First,</target>
        </trans-unit>
        <trans-unit id="d7c19c1fc6c3dbafd3921057c37d39372855cf85" translate="yes" xml:space="preserve">
          <source>First, adding the new possessive &lt;code&gt;+&lt;/code&gt; to any quantifier finds the longest match and does not backtrack. That's important since you want to handle any angle brackets through the recursion, not backtracking. The group &lt;code&gt;[^&amp;lt;&amp;gt;]++&lt;/code&gt; finds one or more non-angle brackets without backtracking.</source>
          <target state="translated">먼저, 새로운 소유 &lt;code&gt;+&lt;/code&gt; 를 수량 자에 추가하면 가장 긴 일치 항목을 찾고 역 추적하지 않습니다. 역 추적이 아닌 재귀를 통해 앵글 브래킷을 처리하려고하기 때문에 중요합니다. &lt;code&gt;[^&amp;lt;&amp;gt;]++&lt;/code&gt; 그룹 은 역 추적없이 하나 이상의 앵글이없는 괄호를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="50b1a9b57fc0e96ef3cb9ee0ed192e6dd3187f0f" translate="yes" xml:space="preserve">
          <source>First, an easy one. Rather than having debugging code that is all-or-nothing, it would be much more useful to be able to control which specific blocks of debugging code get included. Try extending the syntax for debug blocks to allow each to be identified. The contents of the &lt;code&gt;DEBUG&lt;/code&gt; environment variable can then be used to control which blocks get included.</source>
          <target state="translated">먼저 쉬운 일입니다. 전혀 또는 전혀 디버깅 코드를 사용하지 않고 디버깅 코드의 특정 블록이 포함되도록 제어하는 ​​것이 훨씬 유용합니다. 디버그 블록에 대한 구문을 확장하여 각각을 식별하십시오. 그런 다음 &lt;code&gt;DEBUG&lt;/code&gt; 환경 변수 의 내용을 사용하여 포함 할 블록을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f1e59ee032bf3e9e20cd69af8996ee89b862626" translate="yes" xml:space="preserve">
          <source>First, are you sure that the module isn't already on your system? Try &lt;code&gt;perl -MFoo -e 1&lt;/code&gt; . (Replace &quot;Foo&quot; with the name of the module; for instance, &lt;code&gt;perl -MCGI::Carp -e 1&lt;/code&gt; .)</source>
          <target state="translated">먼저, 모듈이 이미 시스템에 있지 않습니까? &lt;code&gt;perl -MFoo -e 1&lt;/code&gt; 을 시도하십시오 . &quot;Foo&quot;를 모듈 이름으로 &lt;code&gt;perl -MCGI::Carp -e 1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ebaf97085b1af9a8aca032d5654d4392116d444" translate="yes" xml:space="preserve">
          <source>First, download the module package from CPAN (e.g., the &quot;Comma Separated Value&quot; text package, Text-CSV-0.01.tar.gz). Then expand the contents of the package into some location on your disk. Most CPAN modules are built with an internal directory structure, so it is usually safe to expand it in the root of your DJGPP installation. Some people prefer to locate source trees under /usr/src (i.e., &lt;code&gt;($DJDIR)/usr/src&lt;/code&gt; ), but you may put it wherever seems most logical to you, *EXCEPT* under the same directory as your perl source code. There are special rules that apply to modules which live in the perl source tree that do not apply to most of the modules in CPAN.</source>
          <target state="translated">먼저 CPAN에서 모듈 패키지를 다운로드하십시오 (예 : &quot;쉼표로 구분 된 값&quot;텍스트 패키지, Text-CSV-0.01.tar.gz). 그런 다음 패키지의 내용을 디스크의 특정 위치로 확장하십시오. 대부분의 CPAN 모듈은 내부 디렉토리 구조로 빌드되므로 일반적으로 DJGPP 설치의 루트에서 확장하는 것이 안전합니다. 어떤 사람들은 / usr / src (예 : &lt;code&gt;($DJDIR)/usr/src&lt;/code&gt; ) 아래에 소스 트리를 찾는 것을 선호 하지만, 펄 소스 코드와 같은 디렉토리 아래 * EXCEPT *가 가장 논리적으로 보이는 곳에 둘 수 있습니다. CPAN의 대부분의 모듈에는 적용되지 않는 perl 소스 트리에있는 모듈에 적용되는 특수 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bd8c84d305c51b13e814aea0158d4e7f9348781" translate="yes" xml:space="preserve">
          <source>First, ensure that you've found an actual bug. Second, ensure you've found an actual bug.</source>
          <target state="translated">먼저 실제 버그를 발견했는지 확인하십시오. 둘째, 실제 버그를 발견했는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="ae1f5078345edb7a706a89221e3d6b7ce9cef2cd" translate="yes" xml:space="preserve">
          <source>First, export the path to the SDK into the build environment:</source>
          <target state="translated">먼저 SDK 경로를 빌드 환경으로 내보내십시오.</target>
        </trans-unit>
        <trans-unit id="f736b2c3892c2f343a0b6266829dd11c79e488a9" translate="yes" xml:space="preserve">
          <source>First, get rid of the libperl.dylib:</source>
          <target state="translated">먼저 libperl.dylib를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="152625e23957ee1b161f4b03465822ac30d6d72d" translate="yes" xml:space="preserve">
          <source>First, it can be confusing to read. In the above example, it's not clear if &lt;code&gt;save&lt;/code&gt; is a method provided by the &lt;code&gt;File&lt;/code&gt; class or simply a subroutine that expects a file object as its first argument.</source>
          <target state="translated">첫째, 읽기가 혼란 스러울 수 있습니다. 위의 예에서, &lt;code&gt;save&lt;/code&gt; 가 &lt;code&gt;File&lt;/code&gt; 클래스에 의해 제공되는 메소드 인지 또는 파일 오브젝트를 첫 번째 인수로 예상하는 서브 루틴인지는 명확하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9d7b42a2c11d81d6afadf3ea1e473b60b0c267e3" translate="yes" xml:space="preserve">
          <source>First, it determines the linearized C3 MRO of the object or class it is being called on.</source>
          <target state="translated">먼저, 호출중인 오브젝트 또는 클래스의 선형화 된 C3 MRO를 판별합니다.</target>
        </trans-unit>
        <trans-unit id="fb4ac5a946a8d4958fc6dfdd3a7c2b8f9b12b58f" translate="yes" xml:space="preserve">
          <source>First, let's look at reading it in from a file. This is something like adding a row at a time. We'll assume that there's a flat file in which each line is a row and each word an element. If you're trying to develop an @AoA array containing all these, here's the right way to do that:</source>
          <target state="translated">먼저 파일에서 읽어 보도록하겠습니다. 한 번에 행을 추가하는 것과 같습니다. 각 줄은 행이고 각 단어는 요소 인 플랫 파일이 있다고 가정합니다. 이 모든 것을 포함하는 @AoA 배열을 개발하려는 경우 올바른 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7e9e25e60917815bcdbb3181b9454d4fd283b6a1" translate="yes" xml:space="preserve">
          <source>First, make sure you have the latest &lt;b&gt;cpan-mac&lt;/b&gt; distribution ( &lt;a href=&quot;http://www.cpan.org/authors/id/CNANDOR/&quot;&gt;http://www.cpan.org/authors/id/CNANDOR/&lt;/a&gt; ), which has utilities for doing all of the steps. Read the cpan-mac directions carefully and install it. If you choose not to use cpan-mac for some reason, there are alternatives listed here.</source>
          <target state="translated">먼저 모든 단계를 수행하는 유틸리티 가있는 최신 &lt;b&gt;cpan-mac&lt;/b&gt; 배포판 ( &lt;a href=&quot;http://www.cpan.org/authors/id/CNANDOR/&quot;&gt;http://www.cpan.org/authors/id/CNANDOR/&lt;/a&gt; ) 이 있는지 확인 하십시오. cpan-mac 지시 사항을주의해서 읽고 설치하십시오. 어떤 이유로 cpan-mac을 사용하지 않기로 선택한 경우 여기에 대안이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e4209086a0693a3c62d398c3fd3a79469cf0aa1" translate="yes" xml:space="preserve">
          <source>First, read &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr36&quot;&gt;Unicode Security Considerations&lt;/a&gt;.</source>
          <target state="translated">먼저 &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr36&quot;&gt;유니 코드 보안 고려 사항을&lt;/a&gt; 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="1be4fd7c33f5ba283ee1991244bc33bbae5e14ad" translate="yes" xml:space="preserve">
          <source>First, remember that &lt;code&gt;[1, 2, 3]&lt;/code&gt; makes an anonymous array containing &lt;code&gt;(1, 2, 3)&lt;/code&gt; , and gives you a reference to that array.</source>
          <target state="translated">먼저 &lt;code&gt;[1, 2, 3]&lt;/code&gt; 은 &lt;code&gt;(1, 2, 3)&lt;/code&gt; 포함하는 익명 배열을 만들고 해당 배열에 대한 참조를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ab31ac192075d493669c9807b4d74587336e2089" translate="yes" xml:space="preserve">
          <source>First, see earlier in this document about &lt;a href=&quot;#Finding-locales&quot;&gt;Finding locales&lt;/a&gt;. That tells how to find which locales are really supported--and more importantly, installed--on your system. In our example error message, environment variables affecting the locale are listed in the order of decreasing importance (and unset variables do not matter). Therefore, having LC_ALL set to &quot;En_US&quot; must have been the bad choice, as shown by the error message. First try fixing locale settings listed first.</source>
          <target state="translated">먼저이 문서의 앞부분에서 &lt;a href=&quot;#Finding-locales&quot;&gt;로캘 찾기&lt;/a&gt; 에 대해 참조하십시오 . 시스템에서 실제로 지원되는 로케일을 찾는 방법을 알려줍니다. 예제 오류 메시지에서 로케일에 영향을주는 환경 변수는 중요도가 감소하는 순서대로 나열되며 설정되지 않은 변수는 중요하지 않습니다. 따라서 LC_ALL을 &quot;En_US&quot;로 설정하면 오류 메시지에 표시된대로 잘못된 선택이되어야합니다. 먼저 로케일 설정을 먼저 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="c27578c07f284f149f1e59f8dc0cd46db350e08e" translate="yes" xml:space="preserve">
          <source>First, see the answer to &quot;Why am I getting long decimals (eg, 19.9499999999999) instead of the numbers I should be getting (eg, 19.95)?&quot;.</source>
          <target state="translated">먼저, &quot;내가 받아야하는 숫자 (예 : 19.95) 대신 십진수가 긴 이유 (예 : 19.9499999999999)는 무엇입니까?&quot;에 대한 답변을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c7929df02929344c4da8c51ff70c78d4168b4050" translate="yes" xml:space="preserve">
          <source>First, type &lt;code&gt;ppm&lt;/code&gt; from a shell and see whether ActiveState's PPM repository has your module. If so, you can install it with &lt;code&gt;ppm&lt;/code&gt; and you won't have to bother with any of the other steps here. You might be able to use the CPAN instructions from the &quot;Unix or Linux&quot; section above as well; give it a try. Otherwise, you'll have to follow the steps below.</source>
          <target state="translated">먼저 쉘에서 &lt;code&gt;ppm&lt;/code&gt; 을 입력 하고 ActiveState의 PPM 저장소에 모듈이 있는지 확인하십시오. 그렇다면 &lt;code&gt;ppm&lt;/code&gt; 으로 설치할 수 있으며 여기에서 다른 단계를 수행 할 필요가 없습니다. 위의 &quot;Unix 또는 Linux&quot;섹션에서 CPAN 명령어를 사용할 수도 있습니다. 시도 해봐. 그렇지 않으면 아래 단계를 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="faab21d0b75e81479aa73f86a04f0c512fa41039" translate="yes" xml:space="preserve">
          <source>First, we include the &lt;code&gt;Filter::Util::Call&lt;/code&gt; module, which exports a number of functions into your filter's namespace. The filter shown above uses two of these functions, &lt;code&gt;filter_add()&lt;/code&gt; and &lt;code&gt;filter_read()&lt;/code&gt; .</source>
          <target state="translated">먼저 &lt;code&gt;Filter::Util::Call&lt;/code&gt; 모듈을 포함하여 여러 함수를 필터 네임 스페이스로 내 보냅니다. 위에 표시된 필터는 &lt;code&gt;filter_add()&lt;/code&gt; 및 &lt;code&gt;filter_read()&lt;/code&gt; 함수 중 두 가지를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="7bf86c04e9a07ad8ffe5ebc09738e5cc682edbbb" translate="yes" xml:space="preserve">
          <source>First, we note that this time-honored 16-bit CPU uses little-endian order, and that's why the low order byte is stored at the lower address. To unpack such a (unsigned) short we'll have to use code &lt;code&gt;v&lt;/code&gt; . A repeat count unpacks all 12 shorts:</source>
          <target state="translated">먼저, 우리는이 명예로운 16 비트 CPU가 리틀 엔디안 순서를 사용하므로 하위 바이트가 하위 주소에 저장되는 이유에 주목합니다. 그러한 (부호없는) short를 풀려면 코드 &lt;code&gt;v&lt;/code&gt; 를 사용해야합니다 . 반복 횟수는 12 개의 반바지를 모두 압축 해제합니다.</target>
        </trans-unit>
        <trans-unit id="e1ae10fa25857645a38bd9df4324915b8e49d413" translate="yes" xml:space="preserve">
          <source>First, what is the op tree, anyway? The op tree is the parsed representation of your program, as we saw in our section on parsing, and it's the sequence of operations that Perl goes through to execute your program, as we saw in &lt;a href=&quot;#Running&quot;&gt;Running&lt;/a&gt;.</source>
          <target state="translated">먼저 op 트리는 무엇입니까? op 트리는 파싱에 대한 섹션에서 보았 듯이 프로그램의 파싱 된 표현이며, Perl이 &lt;a href=&quot;#Running&quot;&gt;Running&lt;/a&gt; 에서 보았 듯이 프로그램을 실행하기 위해 수행하는 일련의 작업입니다 .</target>
        </trans-unit>
        <trans-unit id="cd289dddd1b3873e3f239eb60db04e88470eea20" translate="yes" xml:space="preserve">
          <source>Firstly when &lt;code&gt;inflate&lt;/code&gt; has returned a status other than &lt;code&gt;Z_OK&lt;/code&gt; or &lt;code&gt;Z_BUF_ERROR&lt;/code&gt; . This means that either the end of the compressed data stream has been reached (&lt;code&gt;Z_STREAM_END&lt;/code&gt; ) or there is an error in the compressed data. In either of these cases there is no point in continuing with reading the compressed data, so both loops are terminated.</source>
          <target state="translated">첫째 때 &lt;code&gt;inflate&lt;/code&gt; 아닌 다른 상태에 돌아왔다 &lt;code&gt;Z_OK&lt;/code&gt; 또는 &lt;code&gt;Z_BUF_ERROR&lt;/code&gt; 을 . 이는 압축 된 데이터 스트림의 끝에 도달 했거나 ( &lt;code&gt;Z_STREAM_END&lt;/code&gt; ) 압축 된 데이터에 오류가 있음을 의미합니다. 두 경우 모두 압축 된 데이터를 계속 읽을 필요가 없으므로 두 루프가 모두 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="e91097a50eee7fb0157c9c563333af1f9aad192e" translate="yes" xml:space="preserve">
          <source>Firstly with &lt;code&gt;uncompress&lt;/code&gt;</source>
          <target state="translated">먼저 &lt;code&gt;uncompress&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c691ee82803b4a1c09fe4ae85950833e593adf1e" translate="yes" xml:space="preserve">
          <source>Firstly, copy the source and build a native copy of perl for your host system. Then, in the source to be cross compiled:</source>
          <target state="translated">먼저, 소스를 복사하고 호스트 시스템에 대한 기본 perl 사본을 빌드하십시오. 그런 다음 소스에서 크로스 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="429b0e6343c2120d22b3e87cee9b0d4bae245bf0" translate="yes" xml:space="preserve">
          <source>Firstly, the code is considerably more complex than with the previous example.</source>
          <target state="translated">첫째, 코드는 이전 예제보다 훨씬 더 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="276509a617a885ae6ba6cc6313c1176be3ee48f5" translate="yes" xml:space="preserve">
          <source>Firstly, when either &lt;code&gt;filter&lt;/code&gt; or the anonymous sub are called, a local copy of &lt;code&gt;$_&lt;/code&gt; will automatically be created. It will always contain the empty string at this point.</source>
          <target state="translated">먼저, &lt;code&gt;filter&lt;/code&gt; 또는 익명 서브가 호출되면 &lt;code&gt;$_&lt;/code&gt; 의 로컬 사본 이 자동으로 작성됩니다. 이 시점에서 항상 빈 문자열을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="2cac4ae7495bba4659c20ff2b612b63d1529752e" translate="yes" xml:space="preserve">
          <source>Firstly, you need to establish a baseline time for the existing code, which timing needs to be reliable and repeatable. You'll probably want to use the &lt;code&gt;Benchmark&lt;/code&gt; or &lt;code&gt;Devel::NYTProf&lt;/code&gt; modules, or something similar, for this step, or perhaps the Unix system &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; utility, whichever is appropriate. See the base of this document for a longer list of benchmarking and profiling modules, and recommended further reading.</source>
          <target state="translated">먼저 기존 코드에 대한 기준 시간을 설정해야합니다.이 시간은 신뢰할 수 있고 반복 가능해야합니다. 이 단계 에서 &lt;code&gt;Benchmark&lt;/code&gt; 또는 &lt;code&gt;Devel::NYTProf&lt;/code&gt; 모듈 또는 이와 유사한 것을 사용하거나 Unix 시스템 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 유틸리티 중 적절한 것을 사용하고 싶을 것입니다. 더 긴 벤치마킹 및 프로파일 링 모듈 목록과 추가 권장 사항은이 문서의 기본을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fda4e517cc99c618a0166c7c1427ce12e089520b" translate="yes" xml:space="preserve">
          <source>Five specially named code blocks are executed at the beginning and at the end of a running Perl program. These are the &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;UNITCHECK&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; , and &lt;code&gt;END&lt;/code&gt; blocks.</source>
          <target state="translated">특별히 명명 된 5 개의 코드 블록이 실행중인 Perl 프로그램의 시작과 끝에 실행됩니다. 이들은 &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;UNITCHECK&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; 및 &lt;code&gt;END&lt;/code&gt; 블록입니다.</target>
        </trans-unit>
        <trans-unit id="c722bf4ef529e4eded31ce8c62d796cc90fbd29c" translate="yes" xml:space="preserve">
          <source>Fix as many discovered bugs as possible. Document all the bugs which are not fixed, and all the failures with unknown reasons. Inspect the produced logs</source>
          <target state="translated">발견 된 버그를 가능한 많이 수정하십시오. 수정되지 않은 모든 버그와 알 수없는 이유로 모든 실패를 기록하십시오. 생성 된 로그 검사</target>
        </trans-unit>
        <trans-unit id="b83649da6d49364618a24bf1f42332f131fef232" translate="yes" xml:space="preserve">
          <source>Fixed characters</source>
          <target state="translated">고정 문자</target>
        </trans-unit>
        <trans-unit id="ecfb2a96b4b5f73e1fa6089350af79bfe24ae8f4" translate="yes" xml:space="preserve">
          <source>Fixed, sped-up and enhanced by Tels &lt;a href=&quot;http://bloodgate.com&quot;&gt;http://bloodgate.com&lt;/a&gt; 2001-2003. Further streamlining (api_version 1 etc.) by Tels 2004-2007.</source>
          <target state="translated">Tels &lt;a href=&quot;http://bloodgate.com&quot;&gt;http://bloodgate.com&lt;/a&gt; 2001-2003에 의해 수정, 가속화 및 향상되었습니다 . Tels 2004-2007에 의한 추가 간소화 (api_version 1 등).</target>
        </trans-unit>
        <trans-unit id="405b043abf0e87a42c31429945169f0dd7c5d88d" translate="yes" xml:space="preserve">
          <source>Fixed, speed-up, streamlined and enhanced by Tels 2001 - 2007.</source>
          <target state="translated">Tels 2001-2007에 의해 수정, 속도 향상, 간소화 및 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="3ca59c972a528af8e7a14352bd6c37f9e70222bb" translate="yes" xml:space="preserve">
          <source>Fixed-length mode. Leave-blanks mode.</source>
          <target state="translated">고정 길이 모드. 공백 모드.</target>
        </trans-unit>
        <trans-unit id="959687f22ec208a2b336a28e627dad8c7a247264" translate="yes" xml:space="preserve">
          <source>Fixed-table-size, fixed-key-length hashing</source>
          <target state="translated">고정 테이블 크기, 고정 키 길이 해싱</target>
        </trans-unit>
        <trans-unit id="d34a8295ae4d44653579918a6b463ec2c7d9fc59" translate="yes" xml:space="preserve">
          <source>Fixes up numerous file and directory macros to insure VMS syntax regardless of input syntax. Also makes lists of files comma-separated.</source>
          <target state="translated">입력 구문에 관계없이 VMS 구문을 보장하기 위해 수많은 파일 및 디렉토리 매크로를 수정합니다. 또한 파일 목록을 쉼표로 구분합니다.</target>
        </trans-unit>
        <trans-unit id="d40ac06cf36190f3752a227ce1d3e621fc0665b2" translate="yes" xml:space="preserve">
          <source>Fixing security issues and user-visible bugs in the core</source>
          <target state="translated">핵심 보안 문제 및 사용자가 볼 수있는 버그 수정</target>
        </trans-unit>
        <trans-unit id="29642e3ca9418aa5ace5fd4900eeec9b27f8007e" translate="yes" xml:space="preserve">
          <source>Fixing system locale configuration</source>
          <target state="translated">시스템 로케일 구성 수정</target>
        </trans-unit>
        <trans-unit id="6014390aa4fd7e389a7243e9000e4c32cd912a43" translate="yes" xml:space="preserve">
          <source>Flags described further in &lt;a href=&quot;perlretut#Using-regular-expressions-in-Perl&quot;&gt;Using regular expressions in Perl in perlretut&lt;/a&gt; are:</source>
          <target state="translated">&lt;a href=&quot;perlretut#Using-regular-expressions-in-Perl&quot;&gt;perlretut에서 Perl에서 정규 표현식 사용에&lt;/a&gt; 자세히 설명 된 플래그 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="95cffe720f5843720b2f2791ed48ac4c103a313f" translate="yes" xml:space="preserve">
          <source>Flags may be one of:</source>
          <target state="translated">플래그는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="adc8e7329bf4555216d7a3bfa9cef9955718902b" translate="yes" xml:space="preserve">
          <source>Flags. Use one of:</source>
          <target state="translated">깃발. 다음 중 하나를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6103463409204cb527cdac9c41a9a07b15e276a0" translate="yes" xml:space="preserve">
          <source>Flavors of Perl numeric operations</source>
          <target state="translated">펄 수치 연산의 풍미</target>
        </trans-unit>
        <trans-unit id="8b3926c9cc6bcbb663057b65eb8ebe30826dbb42" translate="yes" xml:space="preserve">
          <source>Floating Point Anomalies with Perl on OS/390</source>
          <target state="translated">OS / 390에서 Perl을 사용한 부동 소수점 이상</target>
        </trans-unit>
        <trans-unit id="5a5e19070c0cf7a423dbae9f66841c3fabf1ca2c" translate="yes" xml:space="preserve">
          <source>Floating point Numbers</source>
          <target state="translated">부동 소수점 숫자</target>
        </trans-unit>
        <trans-unit id="cdc8e382e56841728abcd2d046d6a53518ddf43c" translate="yes" xml:space="preserve">
          <source>Floating point anomalies on BS2000</source>
          <target state="translated">BS2000의 부동 소수점 이상</target>
        </trans-unit>
        <trans-unit id="6458d7358a6010e05479d7d3065fd1dc70e53021" translate="yes" xml:space="preserve">
          <source>Floating point comparisons which handle the &lt;code&gt;NaN&lt;/code&gt; [C99].</source>
          <target state="translated">&lt;code&gt;NaN&lt;/code&gt; 을 처리하는 부동 소수점 비교 [C99]</target>
        </trans-unit>
        <trans-unit id="12643a69610ec7d65c380165a5bf7f423a31ce49" translate="yes" xml:space="preserve">
          <source>Floating point constants are truncated to integer. All parts and results of expressions are also truncated.</source>
          <target state="translated">부동 소수점 상수는 정수로 잘립니다. 식의 모든 부분과 결과도 잘립니다.</target>
        </trans-unit>
        <trans-unit id="cede3872ee4aa83d2bda6798fe8042b21fbcd8fe" translate="yes" xml:space="preserve">
          <source>Floating point values include the special values &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; , for infinity and not-a-number. The infinity can be also negative.</source>
          <target state="translated">부동 소수점 값에는 무한대 및 숫자가 아닌 특수 값 &lt;code&gt;Inf&lt;/code&gt; 및 &lt;code&gt;NaN&lt;/code&gt; 이 포함됩니다 . 무한대도 음수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="709713db0a0caca978c5c319c22711e133d5178a" translate="yes" xml:space="preserve">
          <source>Floating-point Arithmetic</source>
          <target state="translated">부동 소수점 산술</target>
        </trans-unit>
        <trans-unit id="c49d97794f62dac628d25ae12fcfb3dd4f71313b" translate="yes" xml:space="preserve">
          <source>Floating-point numbers are only approximations to what a mathematician would call real numbers. There are infinitely more reals than floats, so some corners must be cut. For example:</source>
          <target state="translated">부동 소수점 숫자는 수학자가 실수라고 부르는 것에 대한 근사치 일뿐입니다. 수레보다 무한히 많은 실수가 있으므로 일부 모서리를 잘라야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6477529bc9646ecedaf8e4ae8b6c8d51a8bc8383" translate="yes" xml:space="preserve">
          <source>Floppy, Zip, Offline Mode</source>
          <target state="translated">플로피, 우편, 오프라인 모드</target>
        </trans-unit>
        <trans-unit id="8a27fc117a1fc8843011dfb82df5f33f7d437936" translate="yes" xml:space="preserve">
          <source>Flush any buffered write data. May possibly be called on readable handles too. Should return 0 on success, -1 on error.</source>
          <target state="translated">버퍼링 된 쓰기 데이터를 비 웁니다. 읽기 가능한 핸들에서도 호출 될 수 있습니다. 성공하면 0을, 에러이면 -1을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="209099cf56b373e5745037d20085b43c5b416a14" translate="yes" xml:space="preserve">
          <source>Flush the cache.</source>
          <target state="translated">캐시를 비 웁니다.</target>
        </trans-unit>
        <trans-unit id="7ea0600877c74e6c0fe89bbd3afcee971963f892" translate="yes" xml:space="preserve">
          <source>Flushes all pending output into the compressed file.</source>
          <target state="translated">보류중인 모든 출력을 압축 파일로 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="082adecce9ec5788047efdf4da353f56b28da59d" translate="yes" xml:space="preserve">
          <source>Flushes any cached buffers to disk.</source>
          <target state="translated">캐시 된 버퍼를 디스크에 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="0946db717a74209041c8e2e8789decc09b0c8c1a" translate="yes" xml:space="preserve">
          <source>Flushes any pending compressed data and then closes the output file/buffer.</source>
          <target state="translated">보류중인 압축 데이터를 플러시 한 다음 출력 파일 / 버퍼를 닫습니다.</target>
        </trans-unit>
        <trans-unit id="cd9697be2c5b575554432a6587a955d4836a8e65" translate="yes" xml:space="preserve">
          <source>Flushes any pending compressed data to &lt;code&gt;$output&lt;/code&gt; .</source>
          <target state="translated">보류중인 압축 데이터를 &lt;code&gt;$output&lt;/code&gt; 플러시합니다 .</target>
        </trans-unit>
        <trans-unit id="3085611069b17b4d4af56b56fce73f275cd2d511" translate="yes" xml:space="preserve">
          <source>Flushes any pending compressed data to the output file/buffer.</source>
          <target state="translated">보류중인 압축 데이터를 출력 파일 / 버퍼로 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="4773551f475406069f00051e9d104d3a35f79ad2" translate="yes" xml:space="preserve">
          <source>Flushes the directory cache.</source>
          <target state="translated">디렉토리 캐시를 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="928fef4d7417d4484f1f3fc7a84c5c97a0c10f03" translate="yes" xml:space="preserve">
          <source>Foldcase</source>
          <target state="translated">Foldcase</target>
        </trans-unit>
        <trans-unit id="8b66e3d01ed62d27bcca95567dd515e099e2e9d3" translate="yes" xml:space="preserve">
          <source>Follow the guidelines in &lt;a href=&quot;perlstyle&quot;&gt;perlstyle&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;perlstyle&quot;&gt;perlstyle&lt;/a&gt; 의 지침을 따르십시오 .</target>
        </trans-unit>
        <trans-unit id="630bce1629a6b0e8bb4da21f695760c25a3efb55" translate="yes" xml:space="preserve">
          <source>Follow the instructions and links on:</source>
          <target state="translated">다음의 지시 사항과 링크를 따르십시오.</target>
        </trans-unit>
        <trans-unit id="444ce8dc04bb6c539c04e93cd526f6da5b1561ad" translate="yes" xml:space="preserve">
          <source>Follow the instructions in</source>
          <target state="translated">의 지침을 따르십시오</target>
        </trans-unit>
        <trans-unit id="e85aee671a6a0df6df7d5aaa8c5a698b13785622" translate="yes" xml:space="preserve">
          <source>Follow the messages ... and you're done.</source>
          <target state="translated">메시지를 따르십시오 ... 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="e08690a98d641e3cbc8171b5ab25389a2271c13b" translate="yes" xml:space="preserve">
          <source>Follow the normal instructions for building perl; e.g, enter bash, run the Configure script, then use &quot;gmake&quot; to build perl.</source>
          <target state="translated">Perl 빌드에 대한 일반적인 지시 사항을 따르십시오. 예를 들어, bash를 입력하고 Configure 스크립트를 실행 한 다음 &quot;gmake&quot;를 사용하여 perl을 빌드하십시오.</target>
        </trans-unit>
        <trans-unit id="864440f25ee94f2eebf5d9e755372bbba17b62ef" translate="yes" xml:space="preserve">
          <source>Followed by a view command to see where we are:</source>
          <target state="translated">다음 위치에보기 명령이옵니다.</target>
        </trans-unit>
        <trans-unit id="d2431a18b10300a9cb947cadd732f97519440b32" translate="yes" xml:space="preserve">
          <source>Following codes are same.</source>
          <target state="translated">다음 코드는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="1a1472c72b3b35650919410041b1e204b2d5f373" translate="yes" xml:space="preserve">
          <source>Following the normal convention of sixteen-color emulators, this module provides a pair of attributes for each color. For every normal color (0 through 7), the corresponding bright color (8 through 15) is obtained by prepending the string &lt;code&gt;bright_&lt;/code&gt; to the normal color name. For example, &lt;code&gt;red&lt;/code&gt; is color 1 and &lt;code&gt;bright_red&lt;/code&gt; is color 9. The same applies for background colors: &lt;code&gt;on_red&lt;/code&gt; is the normal color and &lt;code&gt;on_bright_red&lt;/code&gt; is the bright color. Capitalize these strings for the constant interface.</source>
          <target state="translated">16 색 에뮬레이터의 일반적인 규칙에 따라이 모듈은 각 색상에 대한 한 쌍의 속성을 제공합니다. 모든 일반 색상 (0 ~ 7)에 대해 문자열 &lt;code&gt;bright_&lt;/code&gt; 를 일반 색상 이름 앞에 붙여 해당 밝은 색상 (8 ~ 15)을 얻습니다 . 예를 들어, &lt;code&gt;red&lt;/code&gt; 은 색상 1이고 &lt;code&gt;bright_red&lt;/code&gt; 는 색상 9입니다. 배경색에도 동일하게 적용됩니다. &lt;code&gt;on_red&lt;/code&gt; 는 일반 색상이고 &lt;code&gt;on_bright_red&lt;/code&gt; 는 밝은 색상입니다. 일정한 인터페이스를 위해이 문자열을 대문자로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="339a6f2fa2aeea3b1c39c8b8cdd86cfc5ca212f8" translate="yes" xml:space="preserve">
          <source>Following the optimizer information is a dump of the offset/length table, here split across several lines:</source>
          <target state="translated">옵티 마이저 정보 다음에는 오프셋 / 길이 테이블의 덤프가 있습니다. 여기서 여러 줄로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="122efc697c2e89462f088f0feebaa5c870210258" translate="yes" xml:space="preserve">
          <source>Follows VMS naming conventions for executable files. If the name passed in doesn't exactly match an executable file, appends</source>
          <target state="translated">실행 파일에 대한 VMS 명명 규칙을 따릅니다. 전달 된 이름이 실행 파일과 정확히 일치하지 않으면 추가</target>
        </trans-unit>
        <trans-unit id="fcc0b02fa7c86000beeb89a30eaf5629188e75a8" translate="yes" xml:space="preserve">
          <source>Foo.pm</source>
          <target state="translated">Foo.pm</target>
        </trans-unit>
        <trans-unit id="da5d4e2f7dabe2f03b8a59da35c55f83a0e24606" translate="yes" xml:space="preserve">
          <source>Foo.txt</source>
          <target state="translated">Foo.txt</target>
        </trans-unit>
        <trans-unit id="d715482d55fabe025e318c022fd82a1c933e4100" translate="yes" xml:space="preserve">
          <source>Foo.xs</source>
          <target state="translated">Foo.xs</target>
        </trans-unit>
        <trans-unit id="df808fb24c9efb33a59855928a13b51fb91724c1" translate="yes" xml:space="preserve">
          <source>Foo/Bar.pm</source>
          <target state="translated">Foo/Bar.pm</target>
        </trans-unit>
        <trans-unit id="ac143ab3d1c17f2a31332e229167b913e207dde2" translate="yes" xml:space="preserve">
          <source>Foo::Bar</source>
          <target state="translated">Foo::Bar</target>
        </trans-unit>
        <trans-unit id="cdf8cb90a5029548db08a3400753c839b0a8694f" translate="yes" xml:space="preserve">
          <source>Footers</source>
          <target state="translated">Footers</target>
        </trans-unit>
        <trans-unit id="f7880600348a091a43e2a84906d6002820643108" translate="yes" xml:space="preserve">
          <source>For</source>
          <target state="translated">For</target>
        </trans-unit>
        <trans-unit id="d69332b2911636a58346ec04cf4c168ff3905a2a" translate="yes" xml:space="preserve">
          <source>For &quot;Insecure &lt;code&gt;$ENV{PATH}&lt;/code&gt; &quot; messages, you need to set &lt;code&gt;$ENV{'PATH'}&lt;/code&gt; to a known value, and each directory in the path must be absolute and non-writable by others than its owner and group. You may be surprised to get this message even if the pathname to your executable is fully qualified. This is</source>
          <target state="translated">&quot;안전하지 않은 &lt;code&gt;$ENV{PATH}&lt;/code&gt; &quot;메시지의 경우 &lt;code&gt;$ENV{'PATH'}&lt;/code&gt; 를 알려진 값으로 설정해야하며 경로의 각 디렉토리는 소유자 및 그룹이 아닌 다른 사람이 절대적이고 쓸 수 없어야합니다. 실행 파일의 경로 이름이 정규화 된 경우에도이 메시지가 표시 될 수 있습니다. 이것은</target>
        </trans-unit>
        <trans-unit id="714f0a7ac0b9ec15987d10f44460eec1efc59934" translate="yes" xml:space="preserve">
          <source>For &quot;big&quot; data stores (i.e. ones that exceed available memory) consider using one of the DB modules to store it on disk instead of in RAM. This will incur a penalty in access time, but that's probably better than causing your hard disk to thrash due to massive swapping.</source>
          <target state="translated">&quot;큰&quot;데이터 저장소 (예 : 사용 가능한 메모리를 초과하는 데이터 저장소)의 경우 DB 모듈 중 하나를 사용하여 RAM 대신 디스크에 저장하는 것이 좋습니다. 이로 인해 액세스 시간이 단축 될 수 있지만 대규모 스와핑으로 인해 하드 디스크가 스래쉬되는 것보다 낫습니다.</target>
        </trans-unit>
        <trans-unit id="216bed6df8bedc927acdb0d380e3ce0b17cdad4f" translate="yes" xml:space="preserve">
          <source>For &quot;g&quot; and &quot;G&quot;, this specifies the maximum number of digits to show, including those prior to the decimal point and those after it; for example:</source>
          <target state="translated">&quot;g&quot;및 &quot;G&quot;의 경우 소수점 앞 자릿수 및 그 뒤 자릿수를 포함하여 표시 할 최대 자릿수를 지정합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0f35f055609ac0e205f7abbab4e89f59e70313b8" translate="yes" xml:space="preserve">
          <source>For 256-color emulators, this module additionally provides &lt;code&gt;ansi0&lt;/code&gt; through &lt;code&gt;ansi15&lt;/code&gt; , which are the same as colors 0 through 15 in sixteen-color emulators but use the 256-color escape syntax, &lt;code&gt;grey0&lt;/code&gt; through &lt;code&gt;grey23&lt;/code&gt; ranging from nearly black to nearly white, and a set of RGB colors. The RGB colors are of the form &lt;code&gt;rgb&lt;i&gt;RGB&lt;/i&gt;&lt;/code&gt; where</source>
          <target state="translated">256 색 에뮬레이터의 경우이 모듈은 &lt;code&gt;ansi0&lt;/code&gt; ~ &lt;code&gt;ansi15&lt;/code&gt; 를 추가로 제공합니다.이 색상은 16 색 에뮬레이터의 색상 0 ~ 15와 동일하지만 256 색 이스케이프 구문 인 &lt;code&gt;grey0&lt;/code&gt; ~ &lt;code&gt;grey23&lt;/code&gt; 을 사용 하여 거의 검은 색에서 거의 흰색, RGB 색상의 집합입니다. RGB 색상은 &lt;code&gt;rgb&lt;i&gt;RGB&lt;/i&gt;&lt;/code&gt; 형식입니다 .</target>
        </trans-unit>
        <trans-unit id="9dba65b3ab3aa02b8076d20aa76888328be8a5c9" translate="yes" xml:space="preserve">
          <source>For 256-color terminals, the recognized foreground colors are:</source>
          <target state="translated">256 색 터미널의 경우 인식되는 전경색은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c5d9dc655e83477215f485473f4a8c147ee45bb5" translate="yes" xml:space="preserve">
          <source>For 5.11.0 and later, B::RV is abolished, and IVs can be used to store references, and a new type B::REGEXP is introduced, giving this structure:</source>
          <target state="translated">5.11.0 이상에서는 B :: RV가 폐지되고 IV를 사용하여 참조를 저장하고 새로운 유형 B :: REGEXP가 도입되어 다음 구조를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a3b9459bd4ecaaeabf24e953c1001374ffa8f984" translate="yes" xml:space="preserve">
          <source>For 5.9.0 and earlier, PVLV is a direct subclass of PVMG, and BM is still present as a distinct type, so the base of this diagram is</source>
          <target state="translated">5.9.0 이하의 경우 PVLV는 PVMG의 직접 서브 클래스이며 BM은 여전히 ​​고유 한 유형으로 존재하므로이 다이어그램의 기본은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="12aacf89124604a604d76e2c1ffa17f7f2f13984" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;, you have to be more elaborate:</source>
          <target state="translated">들어 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; , 당신은 더 정교한 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="33083321ae1d2e32225ec575a8dfdad8fc51bef0" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">들어 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="8b70fae6950aa7895e620a82de485cc8ac6c8f65" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, you write</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 위해 , 당신은 쓴다</target>
        </trans-unit>
        <trans-unit id="68b84a9c646a03b6d82fe08053257a1d8dc4ee20" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;, an internal stack of integer arguments unpacked so far is used. You write &lt;code&gt;/&lt;/code&gt;</source>
          <target state="translated">의 경우 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; , 정수 인수의 내부 스택은 지금까지 사용되는 압축을 푼. 당신은 &lt;code&gt;/&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c6bfa42e2fbb77bda7d82e8856005087ade0aff" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">들어 &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="f6f91e66939fc35306c48af011860c291352dd16" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, you write</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 위해 , 당신은 쓴다</target>
        </trans-unit>
        <trans-unit id="9437652f34a1038c4388b97e25d520817a521814" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;, an internal stack of integer arguments unpacked so far is used. You write &lt;code&gt;/&lt;/code&gt;</source>
          <target state="translated">의 경우 &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; , 정수 인수의 내부 스택은 지금까지 사용되는 압축을 푼. 당신은 &lt;code&gt;/&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f9c5e92c976c0b87d55fa26353e0a93acdc6c1ce" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;Build.PL&lt;/code&gt; -based distributions, use the --install_base option:</source>
          <target state="translated">들어 &lt;code&gt;Build.PL&lt;/code&gt; 이 분포 기반의 --install_base 옵션을 사용합니다 :</target>
        </trans-unit>
        <trans-unit id="c829467e9c4b40b28176534e89832125f74b7e18" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;DESTROY&lt;/code&gt; XSUBs only, a T_PTROBJ is optimized to a T_PTRREF. This means the class check is skipped.</source>
          <target state="translated">들어 &lt;code&gt;DESTROY&lt;/code&gt; 에만있는 XSUB하는 T_PTROBJ는 T_PTRREF에 최적화되어 있습니다. 이것은 클래스 확인을 건너 뛰는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3f0884055516afc34f2b13593cc64878ec3fa103" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;DESTROY&lt;/code&gt; XSUBs only, a T_REFOBJ is optimized to a T_REFREF. This means the class check is skipped.</source>
          <target state="translated">들어 &lt;code&gt;DESTROY&lt;/code&gt; 에만있는 XSUB하는 T_REFOBJ는 T_REFREF에 최적화되어 있습니다. 이것은 클래스 확인을 건너 뛰는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1484118e1397c1b2c2710771f398a13c8a642ded" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;DESTROY&lt;/code&gt; XSUBs only, a T_REF_IV_PTR is optimized to a T_PTRREF. This means the class check is skipped.</source>
          <target state="translated">들어 &lt;code&gt;DESTROY&lt;/code&gt; 에만있는 XSUB하는 T_REF_IV_PTR는 T_PTRREF에 최적화되어 있습니다. 이것은 클래스 확인을 건너 뛰는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="66b2f35d5f8f8421c2121030f67ed492cb7aab30" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; codes without a &quot;name|&quot; part, only &lt;code&gt;E&amp;lt;...&amp;gt;&lt;/code&gt; and &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt; codes may occur. That is, authors should not use &quot;&lt;code&gt;L&amp;lt;B&amp;lt;Foo::Bar&amp;gt;&amp;gt;&lt;/code&gt; &quot;.</source>
          <target state="translated">들어 &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; 없이 코드 &quot;이름 |&quot; 부분 만 &lt;code&gt;E&amp;lt;...&amp;gt;&lt;/code&gt; 와 &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt; 코드가 발생할 수있다. 즉, 저자는 &quot; &lt;code&gt;L&amp;lt;B&amp;lt;Foo::Bar&amp;gt;&amp;gt;&lt;/code&gt; &quot;를 사용하지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="45be8d936a33aec210b53bde0ce7f71408df21fa" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;Makefile.PL&lt;/code&gt; -based distributions, use the INSTALL_BASE option when generating Makefiles:</source>
          <target state="translated">&lt;code&gt;Makefile.PL&lt;/code&gt; 기반 배포의 경우 Makefile을 생성 할 때 INSTALL_BASE 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6affbdccf85e4a86ac6e1ea88088cb893b7138f5" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;\N{NAME}&lt;/code&gt; , it is a fatal error if &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; is in effect and the input name is that of a character that won't fit into a byte (i.e., whose ordinal is above 255).</source>
          <target state="translated">들면 &lt;code&gt;\N{NAME}&lt;/code&gt; 경우에는 치명적인 에러가 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; 유효하고 입력 이름이 그 (255 서수 그 위에 예) 바이트에 맞지 않는 문자이다.</target>
        </trans-unit>
        <trans-unit id="e79cd427b6a6f27bc463bdbb4440a5f8655fa529" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;mode=anyorder&lt;/code&gt; CPAN.pm answers a question as soon as the timeout is reached for the next byte in the input stream. In this mode you can use the &lt;code&gt;reuse&lt;/code&gt; parameter to decide what will happen with a question-answer pair after it has been used. In the default case (reuse=0) it is removed from the array, avoiding being used again accidentally. If you want to answer the question &lt;code&gt;Do you really want to &lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; that&lt;/code&gt; several times, then it must be included in the array at least as often as you want this answer to be given. Setting the parameter &lt;code&gt;reuse&lt;/code&gt; to 1 makes this repetition unnecessary.</source>
          <target state="translated">들어 &lt;code&gt;mode=anyorder&lt;/code&gt; CPAN.pm은 제한 시간이 입력 스트림의 다음 바이트에 대한 도달 가능한 한 빨리 질문에 응답합니다. 이 모드에서는 &lt;code&gt;reuse&lt;/code&gt; 매개 변수를 사용하여 질문-응답 쌍이 사용 된 후 발생하는 상황을 결정할 수 있습니다 . 기본 경우 (reuse = 0) 실수로 다시 사용되지 않도록 어레이에서 제거됩니다. 당신이 질문에 대답하려면 &lt;code&gt;Do you really want to &lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; that&lt;/code&gt; 여러 번, 그것은 종종 당신이 대답이 주어질 원하는만큼 적어도 배열에 포함되어야합니다. 매개 변수 &lt;code&gt;reuse&lt;/code&gt; 을 1로 설정 하면이 반복이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9c8630b83e11b62d7083ae08d4bcbe9c6233a2fe" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;mode=deterministic&lt;/code&gt; , the CPAN.pm injects the corresponding answer as soon as the stream matches the regular expression.</source>
          <target state="translated">위해 &lt;code&gt;mode=deterministic&lt;/code&gt; 상기 CPAN.pm의 주입 또는 스트림 정규식과 일치 자마자 상응 않음.</target>
        </trans-unit>
        <trans-unit id="ef14d5377f916291fb2a9d24329993be66568e7c" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;signal&lt;/code&gt; /&lt;code&gt;sigaction&lt;/code&gt; , use &lt;code&gt;rsignal(signo, handler)&lt;/code&gt; .</source>
          <target state="translated">용 &lt;code&gt;signal&lt;/code&gt; / &lt;code&gt;sigaction&lt;/code&gt; , 사용 &lt;code&gt;rsignal(signo, handler)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a61181a75805f7799b6c0c697c05f83d8dd25596" translate="yes" xml:space="preserve">
          <source>For BigInts, no padding occurs.</source>
          <target state="translated">BigInts의 경우 패딩이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="159007f5b1b467e0716f482dcfafb34641ca6593" translate="yes" xml:space="preserve">
          <source>For CPAN distributions, you can assume that the XS types defined by the perl core are already available. Additionally, the core typemap has default XS types for a large number of C types. For example, if you simply return a &lt;code&gt;char *&lt;/code&gt; from your XSUB, the core typemap will have this C type associated with the T_PV XS type. That means your C string will be copied into the PV (pointer value) slot of a new scalar that will be returned from your XSUB to Perl.</source>
          <target state="translated">CPAN 분배의 경우 perl 코어에 의해 정의 된 XS 유형이 이미 사용 가능한 것으로 가정 할 수 있습니다. 또한 코어 유형 맵에는 많은 C 유형에 대한 기본 XS 유형이 있습니다. 예를 들어 XSUB에서 단순히 &lt;code&gt;char *&lt;/code&gt; 를 반환 하면 코어 유형 맵에는이 C 유형이 T_PV XS 유형과 연결됩니다. 즉, C 문자열이 새 스칼라의 PV (포인터 값) 슬롯에 복사되어 XSUB에서 Perl로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="067800c18ab159aedbe7176e2a1ed014fc0ab19b" translate="yes" xml:space="preserve">
          <source>For CPerlMode, see &lt;a href=&quot;http://www.emacswiki.org/cgi-bin/wiki/CPerlMode&quot;&gt;http://www.emacswiki.org/cgi-bin/wiki/CPerlMode&lt;/a&gt;</source>
          <target state="translated">CPerlMode의 경우 &lt;a href=&quot;http://www.emacswiki.org/cgi-bin/wiki/CPerlMode&quot;&gt;http://www.emacswiki.org/cgi-bin/wiki/CPerlMode를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6e12f48bd95a450fad76910cdbdd13b43b481003" translate="yes" xml:space="preserve">
          <source>For Haiku specific problems contact the HaikuPorts developers: &lt;a href=&quot;http://ports.haiku-files.org/&quot;&gt;http://ports.haiku-files.org/&lt;/a&gt;</source>
          <target state="translated">Haiku 관련 문제는 HaikuPorts 개발자에게 문의하십시오. &lt;a href=&quot;http://ports.haiku-files.org/&quot;&gt;http://ports.haiku-files.org/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1aa725456deafc0e9398eb1c8777ad30635d6763" translate="yes" xml:space="preserve">
          <source>For Irix 6.2 with perl threads, you have to have the following patches installed:</source>
          <target state="translated">perl 스레드가있는 Irix 6.2의 경우 다음 패치를 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="a36b859180dd2062331e5d0956bbf601eda4340d" translate="yes" xml:space="preserve">
          <source>For Loops</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f525ec14cf3a7406a3fd20ef6618215772bcd0e1" translate="yes" xml:space="preserve">
          <source>For Mac OS X see README.macosx</source>
          <target state="translated">Mac OS X의 경우 README.macosx를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d38d4d7cfb9b600d5802da277c23639b1baaadfc" translate="yes" xml:space="preserve">
          <source>For OS/2 just use</source>
          <target state="translated">OS / 2의 경우</target>
        </trans-unit>
        <trans-unit id="123b8c1601c884b5764bece329526a87e1364285" translate="yes" xml:space="preserve">
          <source>For Perls earlier than those described above, or when a string is passed to a function outside the scope of &lt;code&gt;unicode_strings&lt;/code&gt; , see the next section.</source>
          <target state="translated">위에서 설명한 것보다 빠른 Perls 또는 &lt;code&gt;unicode_strings&lt;/code&gt; 범위를 벗어난 함수에 문자열을 전달하는 경우 다음 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="51e9cd46d8dc985ae6ee50db0816aefe5399b510" translate="yes" xml:space="preserve">
          <source>For RFC 1950, 1951 and 1952 see</source>
          <target state="translated">RFC 1950, 1951 및 1952에 대해서는</target>
        </trans-unit>
        <trans-unit id="79d250a5e514d12306957ae3038fcbffa25a0e46" translate="yes" xml:space="preserve">
          <source>For SV-heads, the first slot in each arena is reserved, and holds a link to the next arena, some flags, and a note of the number of slots. Snaked through each arena chain is a linked list of free items; when this becomes empty, an extra arena is allocated and divided up into N items which are threaded into the free list.</source>
          <target state="translated">SV- 헤드의 경우 각 경기장의 첫 번째 슬롯이 예약되며 다음 경기장, 일부 플래그 및 슬롯 수에 대한 링크를 보유합니다. 각 경기장 체인을 통해 무료로 제공되는 링크 된 목록이 있습니다. 이것이 비워지면, 여분의 경기장이 할당되고 자유 목록에 스레드되는 N 개의 항목으로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="d83cc596cefab565f5916e26bce4790ad8fbd819" translate="yes" xml:space="preserve">
          <source>For Solaris 2.6 and onwards, there are two different ways for 32-bit applications to manipulate large files (files whose size is &amp;gt; 2GByte). (A 64-bit application automatically has largefile support built in by default.)</source>
          <target state="translated">Solaris 2.6 이상에서는 32 비트 응용 프로그램이 큰 파일 (크기가 2GB 이상인 파일)을 조작하는 두 가지 방법이 있습니다. 64 비트 응용 프로그램에는 기본적으로 큰 파일 지원 기능이 자동으로 내장되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8dd5fe06604a74e02ef8359829b5b43f385d6346" translate="yes" xml:space="preserve">
          <source>For Storable files the rule is that they must be constructed such that &lt;code&gt;Storable::retrieve(file)&lt;/code&gt; returns an array reference and the array elements represent one distropref object each. The conversion from YAML would look like so:</source>
          <target state="translated">저장 가능한 파일의 경우, 규칙은 &lt;code&gt;Storable::retrieve(file)&lt;/code&gt; 가 배열 참조를 리턴하고 배열 요소가 각각 하나의 distropref 오브젝트를 나타내도록 구성되어야합니다. YAML에서의 변환은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8f58ed6574a36d30b785f4f498f48637179894cd" translate="yes" xml:space="preserve">
          <source>For Titlecase, see &lt;a href=&quot;#Titlecase&quot;&gt;Titlecase&lt;/a&gt;.</source>
          <target state="translated">타이틀 케이스을 참조 &lt;a href=&quot;#Titlecase&quot;&gt;타이틀 케이스를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="805f6202ade256f373021f2e5892254d89bc09aa" translate="yes" xml:space="preserve">
          <source>For Unicode versions between 3.1 and 3.1.1 inclusive,</source>
          <target state="translated">3.1에서 3.1.1 사이의 유니 코드 버전의 경우</target>
        </trans-unit>
        <trans-unit id="04defd080a27e1372a9c1dbe8cf6a89380139dd2" translate="yes" xml:space="preserve">
          <source>For Unicode versions between 3.1 and 3.1.1 inclusive, this field is empty unless there is a special folding for Turkic languages, in which case</source>
          <target state="translated">3.1에서 3.1.1 사이의 유니 코드 버전의 경우 Turkic 언어에 대한 특수 폴딩이 없으면이 필드는 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbc319b6a7e7bbc5b0a21fcef4a3c90f8aa75d2f" translate="yes" xml:space="preserve">
          <source>For Unix platforms that will be the equivalent of &quot;unix perlio&quot; or &quot;stdio&quot;. Configure is set up to prefer the &quot;stdio&quot; implementation if the system's library provides for fast access to the buffer; otherwise, it uses the &quot;unix perlio&quot; implementation.</source>
          <target state="translated">&quot;unix perlio&quot;또는 &quot;stdio&quot;와 동등한 Unix 플랫폼의 경우. 시스템 라이브러리가 버퍼에 빠르게 액세스 할 수있는 경우 &quot;stdio&quot;구현을 선호하도록 Configure가 설정됩니다. 그렇지 않으면 &quot;unix perlio&quot;구현을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ddf8e7684d2c33a7c1793ba874a5f04310e9d4fc" translate="yes" xml:space="preserve">
          <source>For WHENCE, you may also use the constants &lt;code&gt;SEEK_SET&lt;/code&gt; , &lt;code&gt;SEEK_CUR&lt;/code&gt; , and &lt;code&gt;SEEK_END&lt;/code&gt; (start of the file, current position, end of the file) from the Fcntl module. Use of the constants is also more portable than relying on 0, 1, and 2. For example to define a &quot;systell&quot; function:</source>
          <target state="translated">WHENCE를 들어, 당신은 또한 상수를 사용할 수 있습니다 &lt;code&gt;SEEK_SET&lt;/code&gt; , &lt;code&gt;SEEK_CUR&lt;/code&gt; , 그리고 &lt;code&gt;SEEK_END&lt;/code&gt; 는 은 fcntl 모듈에서 (파일, 현재 위치, 파일의 끝의 시작). 상수 사용은 0, 1 및 2에 의존하는 것보다 이식성이 뛰어납니다. 예를 들어 &quot;systell&quot;함수를 정의하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="9c6f354666b012fb0b17a8266f1f19a75a5cd7ea" translate="yes" xml:space="preserve">
          <source>For Windows, use a binary version of Perl, &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fstrawberryperl.com%2f&quot;&gt;Strawberry Perl&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.activestate.com%2factiveperl&quot;&gt;ActivePerl&lt;/a&gt; come with a bundled C compiler.</source>
          <target state="translated">Windows의 경우 바이너리 버전의 Perl, &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fstrawberryperl.com%2f&quot;&gt;Strawberry Perl&lt;/a&gt; 및 &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.activestate.com%2factiveperl&quot;&gt;ActivePerl을&lt;/a&gt; 번들 C 컴파일러와 함께 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4096062d54d81319c0a84a69e9fb5a2773f4aae4" translate="yes" xml:space="preserve">
          <source>For a complete description of all MakeMaker methods see &lt;a href=&quot;mm_unix&quot;&gt;ExtUtils::MM_Unix&lt;/a&gt;.</source>
          <target state="translated">모든 MakeMaker 메소드에 대한 자세한 설명은 &lt;a href=&quot;mm_unix&quot;&gt;ExtUtils :: MM_Unix를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8f3ff924d2e8af712b8d94ac227d4cdb31a1d1a1" translate="yes" xml:space="preserve">
          <source>For a complete description of the PerlIO abstraction, consult &lt;a href=&quot;perlapio&quot;&gt;perlapio&lt;/a&gt;.</source>
          <target state="translated">PerlIO 추상화에 대한 자세한 설명은 &lt;a href=&quot;perlapio&quot;&gt;perlapio를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cc9dbf2a0896fe69103f2db77a57c60a5869908f" translate="yes" xml:space="preserve">
          <source>For a complete list of features check &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;.</source>
          <target state="translated">기능 점검 &lt;a href=&quot;feature&quot;&gt;기능&lt;/a&gt; 의 전체 목록을 보려면 .</target>
        </trans-unit>
        <trans-unit id="99ae84c904dc87594aba13edffb373bf48c2a651" translate="yes" xml:space="preserve">
          <source>For a complete version of Tom Christiansen's vi configuration file, see &lt;a href=&quot;http://www.cpan.org/authors/Tom_Christiansen/scripts/toms.exrc.gz&quot;&gt;http://www.cpan.org/authors/Tom_Christiansen/scripts/toms.exrc.gz&lt;/a&gt; , the standard benchmark file for vi emulators. The file runs best with nvi, the current version of vi out of Berkeley, which incidentally can be built with an embedded Perl interpreter--see &lt;a href=&quot;http://www.cpan.org/src/misc/&quot;&gt;http://www.cpan.org/src/misc/&lt;/a&gt; .</source>
          <target state="translated">Tom Christiansen의 vi 구성 파일의 전체 버전은 vi 에뮬레이터의 표준 벤치 마크 파일 인 &lt;a href=&quot;http://www.cpan.org/authors/Tom_Christiansen/scripts/toms.exrc.gz&quot;&gt;http://www.cpan.org/authors/Tom_Christiansen/scripts/toms.exrc.gz를&lt;/a&gt; 참조 하십시오 . 이 파일은 Berkeley의 vi 최신 버전 인 nvi와 함께 최상으로 실행되며 내장 된 Perl 인터프리터를 사용하여 빌드 할 수 있습니다 ( &lt;a href=&quot;http://www.cpan.org/src/misc/&quot;&gt;http://www.cpan.org/src/misc/ 참조)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="666016f5dbbd95bef8b212430bb2473fc2b4dcb2" translate="yes" xml:space="preserve">
          <source>For a comprehensive date and time representation look at the &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; module on CPAN.</source>
          <target state="translated">포괄적 인 날짜 및 시간 표현 은 CPAN 의 &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="16eedbead27a5bc94e1ec2e16fa1f6580882483a" translate="yes" xml:space="preserve">
          <source>For a definition of the meaning and valid values for &lt;code&gt;MemLevel&lt;/code&gt; refer to the</source>
          <target state="translated">&lt;code&gt;MemLevel&lt;/code&gt; 의 의미와 유효 값에 대한 정의 는</target>
        </trans-unit>
        <trans-unit id="a1e24d70e0b1f2c78e32cfdc770b1dd79ea05b81" translate="yes" xml:space="preserve">
          <source>For a definition of the meaning and valid values for &lt;code&gt;WindowBits&lt;/code&gt; refer to the</source>
          <target state="translated">&lt;code&gt;WindowBits&lt;/code&gt; 의 의미와 유효 값에 대한 정의 는</target>
        </trans-unit>
        <trans-unit id="e1dffbb7b106a3b121865266cc8508e33d6967ff" translate="yes" xml:space="preserve">
          <source>For a description of the variables, please have a look at the Glossary file, as written in the Porting folder, or use the url: &lt;a href=&quot;http://perl5.git.perl.org/perl.git/blob/HEAD:/Porting/Glossary&quot;&gt;http://perl5.git.perl.org/perl.git/blob/HEAD:/Porting/Glossary&lt;/a&gt;</source>
          <target state="translated">변수에 대한 설명은 Porting 폴더에 기록 된 용어집 파일을 보거나 URL을 사용하십시오. &lt;a href=&quot;http://perl5.git.perl.org/perl.git/blob/HEAD:/Porting/Glossary&quot;&gt;http://perl5.git.perl.org/perl.git/blob/HEAD:/Porting /용어 사전&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="522716bff942007c71b30eff73794b6a193c83f7" translate="yes" xml:space="preserve">
          <source>For a detailed description of calling conventions from C to Perl, consult &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">C에서 Perl 로의 호출 규칙에 대한 자세한 설명은 &lt;a href=&quot;perlcall&quot;&gt;perlcall을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb11e0b0c0d1be60a6f42c39836c50cc82216796" translate="yes" xml:space="preserve">
          <source>For a discussion of issues surrounding file permissions and &lt;b&gt;-i&lt;/b&gt;, see &lt;a href=&quot;perlfaq5#Why-does-Perl-let-me-delete-read-only-files%3f-Why-does--i-clobber-protected-files%3f-Isn't-this-a-bug-in-Perl%3f&quot;&gt;Why does Perl let me delete read-only files? Why does -i clobber protected files? Isn't this a bug in Perl? in perlfaq5&lt;/a&gt;.</source>
          <target state="translated">파일 권한 및 &lt;b&gt;-i&lt;/b&gt; 관련 문제에 대한 설명 &lt;a href=&quot;perlfaq5#Why-does-Perl-let-me-delete-read-only-files%3f-Why-does--i-clobber-protected-files%3f-Isn't-this-a-bug-in-Perl%3f&quot;&gt;은 Perl에서 읽기 전용 파일을 삭제하는 이유는 무엇입니까?를&lt;/a&gt; 참조하십시오 . -i clobber로 파일을 보호하는 이유는 무엇입니까? 이것은 Perl의 버그가 아닌가? perlfaq5에서 .</target>
        </trans-unit>
        <trans-unit id="c17a0e02c18fc6ec53a4e2d1835d5c3756570710" translate="yes" xml:space="preserve">
          <source>For a full definition of the meaning and valid values for &lt;code&gt;WindowBits&lt;/code&gt; refer to the</source>
          <target state="translated">&lt;code&gt;WindowBits&lt;/code&gt; 의 의미와 유효 값에 대한 전체 정의 는</target>
        </trans-unit>
        <trans-unit id="ab6b2ccf022ed8c112662e8962e31264cb2b6d19" translate="yes" xml:space="preserve">
          <source>For a list of known issues, visit:</source>
          <target state="translated">알려진 문제 목록을 보려면 다음 사이트를 방문하십시오 :</target>
        </trans-unit>
        <trans-unit id="e95ee6825d4d62b379fa548316d0c1e1647b716e" translate="yes" xml:space="preserve">
          <source>For a lot of situations, like interfacing to an error handler, this may be a perfectly adequate solution.</source>
          <target state="translated">오류 처리기와의 인터페이스와 같은 많은 상황에서 이것은 완벽한 솔루션 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78fb5d513c6711626eae157d1505b4fda1465fce" translate="yes" xml:space="preserve">
          <source>For a module, this is generally where the documentation of the interfaces provided by the module goes, usually in the form of a list with an &lt;code&gt;=item&lt;/code&gt; for each interface. Depending on how many interfaces there are, you may want to put that documentation in separate METHODS, FUNCTIONS, CLASS METHODS, or INSTANCE METHODS sections instead and save the DESCRIPTION section for an overview.</source>
          <target state="translated">모듈의 경우, 일반적으로 모듈이 제공하는 인터페이스의 문서화는 일반적으로 각 인터페이스에 대해 &lt;code&gt;=item&lt;/code&gt; 이있는 목록 형식으로되어 있습니다. 인터페이스의 수에 따라 해당 설명서를 별도의 방법, 기능, 클래스 방법 또는 인스턴스 방법 섹션에 배치하고 설명을 위해 설명 섹션을 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1d4f8c4cd53b34a329bab7f01392ac51898bdf5" translate="yes" xml:space="preserve">
          <source>For a more complete explanation of 64-bit issues, see the &quot;Solaris 64-bit Developer's Guide&quot; at &lt;a href=&quot;http://docs.sun.com/&quot;&gt;http://docs.sun.com/&lt;/a&gt;</source>
          <target state="translated">64 비트 문제에 대한 자세한 내용은 &lt;a href=&quot;http://docs.sun.com/&quot;&gt;http://docs.sun.com/&lt;/a&gt; 의 &quot;Solaris 64 비트 개발자 안내서&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8e2c5e657d81bf42c0416b6bb7cf83065d719466" translate="yes" xml:space="preserve">
          <source>For a more complicated interface, see &lt;a href=&quot;dynaloader&quot;&gt;DynaLoader&lt;/a&gt;. Many (most) features of &lt;code&gt;DynaLoader&lt;/code&gt; are not implemented in &lt;code&gt;XSLoader&lt;/code&gt; , like for example the &lt;code&gt;dl_load_flags&lt;/code&gt; , not honored by &lt;code&gt;XSLoader&lt;/code&gt; .</source>
          <target state="translated">더 복잡한 인터페이스는 &lt;a href=&quot;dynaloader&quot;&gt;DynaLoader를&lt;/a&gt; 참조하십시오 . 많은 (대부분의) 기능 &lt;code&gt;DynaLoader&lt;/code&gt; 은 구현되지 않습니다 &lt;code&gt;XSLoader&lt;/code&gt; 예를 들어 같은 &lt;code&gt;dl_load_flags&lt;/code&gt; 영광하지 &lt;code&gt;XSLoader&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5cd2b461432789a1d128d890e829743972bfea8c" translate="yes" xml:space="preserve">
          <source>For a more detailed discussion, see &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Semantics&quot;&gt;Unicode::Semantics&lt;/a&gt; on CPAN.</source>
          <target state="translated">자세한 내용 은 CPAN의 &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Semantics&quot;&gt;Unicode :: Semantics&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="734d1e26906ca381487d708f04f33fc705057ebb" translate="yes" xml:space="preserve">
          <source>For a more featureful version of this program, you should look to the</source>
          <target state="translated">이 프로그램의보다 기능적인 버전을 보려면</target>
        </trans-unit>
        <trans-unit id="6cc9a4597b12d4f9cbe49ad17ba062101c23d9dc" translate="yes" xml:space="preserve">
          <source>For a multi-line string, you can apply the regular expression to each logical line in the string by adding the &lt;code&gt;/m&lt;/code&gt; flag (for &quot;multi-line&quot;). With the &lt;code&gt;/m&lt;/code&gt; flag, the &lt;code&gt;$&lt;/code&gt; matches</source>
          <target state="translated">여러 줄 문자열의 경우 &lt;code&gt;/m&lt;/code&gt; 플래그 를 추가하여 ( &quot;다 줄&quot;) 문자열의 각 논리 줄에 정규식을 적용 할 수 있습니다 . 와 &lt;code&gt;/m&lt;/code&gt; 플래그는 &lt;code&gt;$&lt;/code&gt; 의 일치</target>
        </trans-unit>
        <trans-unit id="a6bf5a779844f3ff794b0be678bf9271933d780d" translate="yes" xml:space="preserve">
          <source>For a platform independent &lt;code&gt;move&lt;/code&gt; function look at the &lt;a href=&quot;../file/copy&quot;&gt;File::Copy&lt;/a&gt; module.</source>
          <target state="translated">플랫폼 독립적 &lt;code&gt;move&lt;/code&gt; 기능은 &lt;a href=&quot;../file/copy&quot;&gt;File :: Copy&lt;/a&gt; 모듈을보십시오.</target>
        </trans-unit>
        <trans-unit id="fab0333533e228e4f9c3f37bd78da5462c6d46ad" translate="yes" xml:space="preserve">
          <source>For a platform independent &lt;code&gt;move&lt;/code&gt; function look at the &lt;a href=&quot;file/copy&quot;&gt;File::Copy&lt;/a&gt; module.</source>
          <target state="translated">플랫폼 독립적 &lt;code&gt;move&lt;/code&gt; 기능은 &lt;a href=&quot;file/copy&quot;&gt;File :: Copy&lt;/a&gt; 모듈을보십시오.</target>
        </trans-unit>
        <trans-unit id="f487551c011cbdc8bfa8463318b0aee937e41d35" translate="yes" xml:space="preserve">
          <source>For a reference of available functions, please consult &lt;a href=&quot;unix&quot;&gt;File::Spec::Unix&lt;/a&gt;, which contains the entire set, and which is inherited by the modules for other platforms. For further information, please see &lt;a href=&quot;mac&quot;&gt;File::Spec::Mac&lt;/a&gt;, &lt;a href=&quot;os2&quot;&gt;File::Spec::OS2&lt;/a&gt;, &lt;a href=&quot;win32&quot;&gt;File::Spec::Win32&lt;/a&gt;, or &lt;a href=&quot;vms&quot;&gt;File::Spec::VMS&lt;/a&gt;.</source>
          <target state="translated">사용 가능한 함수에 대한 참조는 &lt;a href=&quot;unix&quot;&gt;File :: Spec :: Unix&lt;/a&gt; 를 참조하십시오. File :: Spec :: Unix 는 전체 세트를 포함하고 다른 플랫폼의 모듈에 의해 상속됩니다. 자세한 정보는 &lt;a href=&quot;mac&quot;&gt;File :: Spec :: Mac&lt;/a&gt; , &lt;a href=&quot;os2&quot;&gt;File :: Spec :: OS2&lt;/a&gt; , &lt;a href=&quot;win32&quot;&gt;File :: Spec :: Win32&lt;/a&gt; 또는 &lt;a href=&quot;vms&quot;&gt;File :: Spec :: VMS를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3f9c9e2ecd1a16426e5e2b2966118c8ee32aab8e" translate="yes" xml:space="preserve">
          <source>For a regular expression to match, the</source>
          <target state="translated">정규식이 일치하려면</target>
        </trans-unit>
        <trans-unit id="12a058b2c4bc4051745b895283da9f14f036e153" translate="yes" xml:space="preserve">
          <source>For a shorter message you can use &lt;code&gt;carp()&lt;/code&gt; or &lt;code&gt;croak()&lt;/code&gt; which report the error as being from where your module was called. &lt;code&gt;shortmess()&lt;/code&gt; returns the contents of this error message. There is no guarantee that that is where the error was, but it is a good educated guess.</source>
          <target state="translated">더 짧은 메시지의 경우, &lt;code&gt;carp()&lt;/code&gt; 또는 &lt;code&gt;croak()&lt;/code&gt; 을 사용하여 모듈이 호출 된 위치에서 발생한 오류를보고 할 수 있습니다 . &lt;code&gt;shortmess()&lt;/code&gt; 는이 오류 메시지의 내용을 반환합니다. 그것이 오류가 발생한 곳이라는 보장은 없지만 교육을 잘받은 추측입니다.</target>
        </trans-unit>
        <trans-unit id="fb0c681298006459cb4148344c2595f821ef7745" translate="yes" xml:space="preserve">
          <source>For a simple memory dump we unpack some bytes into just as many pairs of hex digits, and use &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; to handle the traditional spacing - 16 bytes to a line:</source>
          <target state="translated">간단한 메모리 덤프를 위해 몇 바이트를 16 진 숫자 쌍으로 압축을 풀고 &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 을 사용 하여 한 줄에 16 바이트의 전통적인 간격을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="e678ac9367be7209ea98d2129135c603f780f7f5" translate="yes" xml:space="preserve">
          <source>For a temporary directory object the directory will be removed unless the CLEANUP argument was used in the constructor (and set to false) or C</source>
          <target state="translated">임시 디렉토리 객체의 경우 생성자에서 CLEANUP 인수를 사용하지 않고 (또는 false로 설정하지 않은 경우) 디렉토리가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="0e148eb23ba15eaf53b9aed2b26acd83d3960120" translate="yes" xml:space="preserve">
          <source>For a yet-more-powerful import facility, see &lt;a href=&quot;#use&quot;&gt;use&lt;/a&gt; and &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;.</source>
          <target state="translated">더욱 강력한 가져 오기 기능은 &lt;a href=&quot;#use&quot;&gt;use&lt;/a&gt; 및 &lt;a href=&quot;perlmod&quot;&gt;perlmod를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="99100d6030ac9440264e837ee275b962c9e0a325" translate="yes" xml:space="preserve">
          <source>For a yet-more-powerful import facility, see &lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; and &lt;a href=&quot;../perlmod&quot;&gt;perlmod&lt;/a&gt;.</source>
          <target state="translated">더욱 강력한 가져 오기 기능은 &lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; 및 &lt;a href=&quot;../perlmod&quot;&gt;perlmod를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="23a93e384211636cb7b918f38dba4af06dd07c92" translate="yes" xml:space="preserve">
          <source>For absolute paths, some cleanup is done, to ensure that the volume name isn't immediately followed by updirs. This is invalid, because this would go beyond &quot;root&quot;. Generally, these cases are handled like their Unix counterparts:</source>
          <target state="translated">절대 경로의 경우 볼륨 이름 바로 뒤에 updir이 표시되지 않도록 일부 정리가 수행됩니다. 이것은 &quot;루트&quot;를 넘어 서기 때문에 유효하지 않습니다. 일반적으로 이러한 경우는 Unix 대응과 같이 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="de74cc30b9d5ee8d61e142d3f7218703345c5703" translate="yes" xml:space="preserve">
          <source>For accessing ftp servers behind such firewalls you usually need to set the environment variable &lt;code&gt;FTP_PASSIVE&lt;/code&gt; or the config variable ftp_passive to a true value.</source>
          <target state="translated">이러한 방화벽 뒤의 ftp 서버에 액세스하려면 일반적으로 환경 변수 &lt;code&gt;FTP_PASSIVE&lt;/code&gt; 또는 구성 변수 ftp_passive를 true 값 으로 설정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="0b4892803f30a1551edad3f36449d4dfea0cc9e9" translate="yes" xml:space="preserve">
          <source>For additional information that may be more accurate for your specific system, see either</source>
          <target state="translated">특정 시스템에보다 정확한 추가 정보는 다음 중 하나를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2a5a320ada3dc4a8bf88fe25047c87af995b7a83" translate="yes" xml:space="preserve">
          <source>For affected functions, the simple strategy to avoid data corruption is to always make the encoding of the exchanged data explicit. Choose an encoding that you know the extension can handle. Convert arguments passed to the extensions to that encoding and convert results back from that encoding. Write wrapper functions that do the conversions for you, so you can later change the functions when the extension catches up.</source>
          <target state="translated">영향을받는 기능의 경우 데이터 손상을 피하는 간단한 전략은 항상 교환 된 데이터의 인코딩을 명시 적으로 만드는 것입니다. 확장 프로그램이 처리 할 수있는 인코딩을 선택하십시오. 확장에 전달 된 인수를 해당 인코딩으로 변환하고 결과를 해당 인코딩에서 다시 변환하십시오. 변환을 수행하는 랩퍼 함수를 ​​작성하여 확장이 따라 올 때 나중에 함수를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="615225b2c41ede3ced593276d5e4d897d1d4111d" translate="yes" xml:space="preserve">
          <source>For alignment commands, a &lt;code&gt;count&lt;/code&gt; of 0 is equivalent to a &lt;code&gt;count&lt;/code&gt; of 1; both are no-ops.</source>
          <target state="translated">정렬 명령의 경우 &lt;code&gt;count&lt;/code&gt; 0은 &lt;code&gt;count&lt;/code&gt; 1 과 같습니다 . 둘 다 아니야.</target>
        </trans-unit>
        <trans-unit id="317a7397e46e0f3311065cf89b919865f2fa40b0" translate="yes" xml:space="preserve">
          <source>For all Perl keywords, a &lt;code&gt;CORE::&lt;/code&gt; prefix will force the built-in function to be used, even if it has been overridden or would normally require the &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; pragma. Despite appearances, this has nothing to do with the CORE package, but is part of Perl's syntax.</source>
          <target state="translated">모든 Perl 키워드에 대해 &lt;code&gt;CORE::&lt;/code&gt; 접두어는 대체되거나 &lt;a href=&quot;feature&quot;&gt;기능&lt;/a&gt; pragma가 필요한 경우에도 내장 함수를 사용하도록합니다 . 외관에도 불구하고 이것은 CORE 패키지와 관련이 없지만 Perl 구문의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="5654c5499f83106c9fbc91a4a0b159f7465964f0" translate="yes" xml:space="preserve">
          <source>For all of these quantifiers, Perl will try to match as much of the string as possible, while still allowing the regexp to succeed. Thus with &lt;code&gt;/a?.../&lt;/code&gt; , Perl will first try to match the regexp with the &lt;code&gt;a&lt;/code&gt; present; if that fails, Perl will try to match the regexp without the &lt;code&gt;a&lt;/code&gt; present. For the quantifier &lt;code&gt;*&lt;/code&gt; , we get the following:</source>
          <target state="translated">이러한 모든 한정자에 대해 Perl은 가능한 많은 문자열을 일치 시키면서도 정규 표현식이 성공하도록 허용합니다. 따라서와 &lt;code&gt;/a?.../&lt;/code&gt; , 펄은 처음으로 정규 표현식과 일치하려고합니다 &lt;code&gt;a&lt;/code&gt; 선물을; 실패 할 경우, 펄이없이 정규 표현식을 일치하려고합니다 &lt;code&gt;a&lt;/code&gt; 존재. 수량 자 &lt;code&gt;*&lt;/code&gt; 의 경우 다음을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="230fb8eb56a362692b30784cae41866149fb8d70" translate="yes" xml:space="preserve">
          <source>For all other systems it defaults to 0.</source>
          <target state="translated">다른 모든 시스템의 경우 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="2e88409e21116c6609cbafa0cf03db229fac1d32" translate="yes" xml:space="preserve">
          <source>For an autoloaded subroutine without a GV, will create a GV even if &lt;code&gt;level &amp;lt; 0&lt;/code&gt; . For an autoloaded subroutine without a stub, GvCV() of the result may be zero.</source>
          <target state="translated">GV가없는 자동로드 서브 루틴의 경우 &lt;code&gt;level &amp;lt; 0&lt;/code&gt; 경우에도 GV를 작성합니다 . 스텁이없는 자동로드 서브 루틴의 경우 결과의 GvCV ()가 0 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fce8b2cbb90270479552270e5bb2cd555b023f38" translate="yes" xml:space="preserve">
          <source>For an example of its output, see &lt;a href=&quot;devel/peek&quot;&gt;Devel::Peek&lt;/a&gt;.</source>
          <target state="translated">출력 예는 &lt;a href=&quot;devel/peek&quot;&gt;Devel :: Peek를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a82a650eab82474d19ec3ef8108ffe5370503228" translate="yes" xml:space="preserve">
          <source>For an example of the use of Net::FTP see</source>
          <target state="translated">Net :: FTP 사용 예는 다음을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bda70344f536c3a618951e75f8672661f9576c18" translate="yes" xml:space="preserve">
          <source>For an excellent all-around resource on the care and feeding of regular expressions, see the book</source>
          <target state="translated">정규 표현식의 관리 및 먹이기에 대한 훌륭한 만능 리소스는 책을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ca7f7d7124f6e693d58d8f8e7a5726f3c3d7d898" translate="yes" xml:space="preserve">
          <source>For an individual module:</source>
          <target state="translated">개별 모듈의 경우 :</target>
        </trans-unit>
        <trans-unit id="e7eb2c9e0a9fd3fe5a6939bf4841e243661494a7" translate="yes" xml:space="preserve">
          <source>For an up-to-date list of plugins available, please check CPAN:</source>
          <target state="translated">사용 가능한 최신 플러그인 목록은 CPAN을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="cbc0f0a5a1b385be37d862973bb36b0e683cb185" translate="yes" xml:space="preserve">
          <source>For an up-to-date listing of CPAN sites, see &lt;a href=&quot;http://www.cpan.org/SITES&quot;&gt;http://www.cpan.org/SITES&lt;/a&gt; or &lt;a href=&quot;ftp://www.cpan.org/SITES&quot;&gt;ftp://www.cpan.org/SITES&lt;/a&gt; .</source>
          <target state="translated">CPAN 사이트의 최신 목록은 &lt;a href=&quot;http://www.cpan.org/SITES&quot;&gt;http://www.cpan.org/SITES&lt;/a&gt; 또는 &lt;a href=&quot;ftp://www.cpan.org/SITES&quot;&gt;ftp://www.cpan.org/SITES를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="d33a39ca090b8a159c7f5059badc4bd7ae75ac58" translate="yes" xml:space="preserve">
          <source>For any anon CVs in the pad, change CvOUTSIDE of that CV from old_cv to new_cv if necessary. Needed when a newly-compiled CV has to be moved to a pre-existing CV struct.</source>
          <target state="translated">패드에있는 임의의 CV의 경우 필요한 경우 해당 CV의 CvOUTSIDE를 old_cv에서 new_cv로 변경하십시오. 새로 컴파일 된 CV를 기존 CV 구조체로 이동해야 할 때 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a477cbd70fca9ccf72bc4fea464de24ee1323a5a" translate="yes" xml:space="preserve">
          <source>For any of the above listed attributes, case is not significant.</source>
          <target state="translated">위에 나열된 속성에 대해서는 대소 문자가 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="03cdf2cd57fb98494228a618ca150d5e64571b39" translate="yes" xml:space="preserve">
          <source>For any text entered at the debugger prompt, leading and trailing whitespace is first stripped before further processing. If a debugger command coincides with some function in your own program, merely precede the function with something that doesn't look like a debugger command, such as a leading &lt;code&gt;;&lt;/code&gt; or perhaps a &lt;code&gt;+&lt;/code&gt; , or by wrapping it with parentheses or braces.</source>
          <target state="translated">디버거 프롬프트에 입력 한 텍스트의 경우 추가 처리 전에 선행 및 후행 공백이 먼저 제거됩니다. 디버거 명령이 자신의 프로그램에서 일부 함수와 일치하는 경우 디버거 명령처럼 보이지 않는 것 (예 : Leading과 같은 것) 만 함수 앞에 추가하십시오 &lt;code&gt;;&lt;/code&gt; 또는 &lt;code&gt;+&lt;/code&gt; 또는 괄호 나 괄호로 묶어서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f345c4981dc60d036c3d28eb6a32e02870746a6" translate="yes" xml:space="preserve">
          <source>For any type of reference, &lt;code&gt;$Carp::RefArgFormatter&lt;/code&gt; is checked (see below). This variable is expected to be a code reference, and the current parameter is passed in. If this function doesn't exist (the variable is undef), or it recurses into &lt;code&gt;Carp&lt;/code&gt; , or it otherwise throws an exception, this is skipped, and Carp moves on to the next option, otherwise checking stops and the string returned is used.</source>
          <target state="translated">모든 참조 유형에 대해 &lt;code&gt;$Carp::RefArgFormatter&lt;/code&gt; 가 검사됩니다 (아래 참조). 이 변수는 코드 참조 일 것으로 예상되며 현재 매개 변수가 전달됩니다.이 함수가 존재하지 않거나 (변수가 undef 인 경우), &lt;code&gt;Carp&lt;/code&gt; 로 되풀이 되거나 예외가 발생하면 건너 뜁니다. 잉어는 다음 옵션으로 넘어갑니다. 그렇지 않으면 검사가 중지되고 반환 된 문자열이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7fa27de554c50c9df409ef4245d850e6b4403907" translate="yes" xml:space="preserve">
          <source>For applications using database backends, the standard &lt;code&gt;DBIx&lt;/code&gt; namespace has tries to help with keeping things nippy, not least because it tries to</source>
          <target state="translated">데이터베이스 백엔드를 사용하는 응용 프로그램의 경우 표준 &lt;code&gt;DBIx&lt;/code&gt; 네임 스페이스는 최소한 다음을 시도하기 때문에 문제를 해결하는 데 도움을줍니다.</target>
        </trans-unit>
        <trans-unit id="1bce7a5486f7524150794956c47fe07d202d9af7" translate="yes" xml:space="preserve">
          <source>For authors of extensions MakeMaker provides several Makefile targets. Most of the support comes from the ExtUtils::Manifest module, where additional documentation can be found.</source>
          <target state="translated">확장 프로그램 작성자를 위해 MakeMaker는 여러 개의 Makefile 대상을 제공합니다. 대부분의 지원은 추가 문서를 찾을 수있는 ExtUtils :: Manifest 모듈에서 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="22bf05bb17e4a865ba888114b8b9f35fd176e0a9" translate="yes" xml:space="preserve">
          <source>For backward compatibility (with Perl 5.6), all properties writable without using the compound form mentioned so far may have &lt;code&gt;Is&lt;/code&gt; or &lt;code&gt;Is_&lt;/code&gt; prepended to their name, so &lt;code&gt;\P{Is_Lu}&lt;/code&gt; , for example, is equal to &lt;code&gt;\P{Lu}&lt;/code&gt; , and &lt;code&gt;\p{IsScript:Arabic}&lt;/code&gt; is equal to &lt;code&gt;\p{Arabic}&lt;/code&gt; .</source>
          <target state="translated">이전 버전과의 호환성 (Perl 5.6과의 호환성)을 위해 지금까지 언급 된 복합 형태를 사용하지 않고 쓰기 가능한 모든 속성 의 이름 앞에 &lt;code&gt;Is&lt;/code&gt; 또는 &lt;code&gt;Is_&lt;/code&gt; 가 있을 수 있으므로 예를 들어 &lt;code&gt;\P{Is_Lu}&lt;/code&gt; 는 &lt;code&gt;\P{Lu}&lt;/code&gt; 와 같습니다. &lt;code&gt;\p{IsScript:Arabic}&lt;/code&gt; 은 &lt;code&gt;\p{Arabic}&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="801eea6f48c31944eef870e82f2becb1739f362a" translate="yes" xml:space="preserve">
          <source>For backward compatibility reasons defining just PERL_GLOBAL_STRUCT doesn't actually hide all symbols inside a big global struct: some PerlIO_xxx vtables are left visible. The PERL_GLOBAL_STRUCT_PRIVATE then hides everything (see how the PERLIO_FUNCS_DECL is used).</source>
          <target state="translated">이전 버전과의 호환성을 위해 PERL_GLOBAL_STRUCT 만 정의하면 실제로 큰 전역 구조체 안에 모든 기호가 숨겨지지 않습니다. 일부 PerlIO_xxx vtable은 표시됩니다. 그런 다음 PERL_GLOBAL_STRUCT_PRIVATE는 모든 것을 숨 깁니다 (PERLIO_FUNCS_DECL 사용 방법 참조).</target>
        </trans-unit>
        <trans-unit id="e59de1fc73fecfb78c070b75065d56f22077db4d" translate="yes" xml:space="preserve">
          <source>For backward compatibility with older implementations that didn't support anonymous globs, &lt;code&gt;Symbol::ungensym&lt;/code&gt; is also provided. But it doesn't do anything.</source>
          <target state="translated">익명 글로브를 지원하지 않는 이전 구현과의 호환성을 위해 &lt;code&gt;Symbol::ungensym&lt;/code&gt; 도 제공됩니다. 그러나 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1875b2cf9d0a9f2703d0d978c0e4f011fb418414" translate="yes" xml:space="preserve">
          <source>For backward compatibility, &lt;code&gt;alternate&lt;/code&gt; (old name) can be used as an alias for &lt;code&gt;variable&lt;/code&gt; .</source>
          <target state="translated">이전 버전과의 호환성을 위해 &lt;code&gt;alternate&lt;/code&gt; (이전 이름)를 &lt;code&gt;variable&lt;/code&gt; 의 별명으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a69034e83ea0d1a42d93d489742ef68d2660151" translate="yes" xml:space="preserve">
          <source>For backward compatibility, it is also possible to pass the parameters as a reference to a hash containing the &lt;code&gt;name=&amp;gt;value&lt;/code&gt; pairs.</source>
          <target state="translated">이전 버전과의 호환성을 위해 &lt;code&gt;name=&amp;gt;value&lt;/code&gt; 쌍을 포함하는 해시에 대한 참조로 매개 변수를 전달할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3148562bf6a9aa8595388062dcaa9f8f17ba0473" translate="yes" xml:space="preserve">
          <source>For backward compatibility, it is also possible to pass the parameters as a reference to a hash containing the name=&amp;gt;value pairs.</source>
          <target state="translated">이전 버전과의 호환성을 위해 이름 =&amp;gt; 값 쌍을 포함하는 해시에 대한 참조로 매개 변수를 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ec61a0442a19b1bc3402a65ad2b4e4eaf169d23" translate="yes" xml:space="preserve">
          <source>For backward-compatibility, if the PADNAMEt_OUTER flag is set, the FLAGS method adds the SVf_FAKE flag, too.</source>
          <target state="translated">하위 호환성을 위해 PADNAMEt_OUTER 플래그가 설정된 경우 FLAGS 메서드는 SVf_FAKE 플래그도 추가합니다.</target>
        </trans-unit>
        <trans-unit id="345abbc3eef47b853413a18eb3df89f5eb02f40e" translate="yes" xml:space="preserve">
          <source>For backwards compatibility in callbacks.</source>
          <target state="translated">콜백에서 이전 버전과의 호환성을 위해.</target>
        </trans-unit>
        <trans-unit id="fc612a7ead920771085f353b3e4c345acbc9a4da" translate="yes" xml:space="preserve">
          <source>For backwards compatibility reasons it is still possible to request a different storage class for use with Math::BigFloat:</source>
          <target state="translated">이전 버전과의 호환성을 위해 Math :: BigFloat에 사용할 다른 스토리지 클래스를 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5515551787402a0e5935331cd95604ada3a19af4" translate="yes" xml:space="preserve">
          <source>For backwards compatibility, the &lt;code&gt;In&lt;/code&gt; prefix may be omitted if there is no naming conflict with a script or any other property, and you can even use an &lt;code&gt;Is&lt;/code&gt; prefix instead in those cases. But don't do this for new code because your code could break in new releases, and this has already happened: There was a time in very early Unicode releases when &lt;code&gt;\p{Hebrew}&lt;/code&gt; would have matched the</source>
          <target state="translated">이전 버전과의 호환성 을 위해 스크립트 나 다른 속성과 이름이 충돌하지 않으면 &lt;code&gt;In&lt;/code&gt; 접두사가 생략 될 수 있으며 대신 이러한 경우 &lt;code&gt;Is&lt;/code&gt; 접두사를 사용할 수도 있습니다 . 그러나 코드가 새 릴리스에서 중단 될 수 있으므로 새 코드에 대해서는이 작업을 수행하지 마십시오. 이미 발생했습니다. &lt;code&gt;\p{Hebrew}&lt;/code&gt; 가</target>
        </trans-unit>
        <trans-unit id="8221b631540f7fb41054f5d592fba788a0c89204" translate="yes" xml:space="preserve">
          <source>For backwards compatibility, this error is also available as &lt;code&gt;$Archive::Tar::error&lt;/code&gt; although it is much recommended you use the method call instead.</source>
          <target state="translated">이전 버전과의 호환성을 위해이 오류는 &lt;code&gt;$Archive::Tar::error&lt;/code&gt; 로도 사용할 수 있지만 대신 메소드 호출을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="04c26648635d004dc1846a0436ba6682f4177e2f" translate="yes" xml:space="preserve">
          <source>For backwards compatibility. Use &lt;code&gt;grok_bin&lt;/code&gt; instead.</source>
          <target state="translated">이전 버전과의 호환성을 위해. 대신 &lt;code&gt;grok_bin&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b83ee316e5b3391a5d7939b8d9c91163c18f189" translate="yes" xml:space="preserve">
          <source>For backwards compatibility. Use &lt;code&gt;grok_hex&lt;/code&gt; instead.</source>
          <target state="translated">이전 버전과의 호환성을 위해. 대신 &lt;code&gt;grok_hex&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="36110c740cb1d17f9559cf294dd0deb0c3ace7b6" translate="yes" xml:space="preserve">
          <source>For backwards compatibility. Use &lt;code&gt;grok_oct&lt;/code&gt; instead.</source>
          <target state="translated">이전 버전과의 호환성을 위해. 대신 &lt;code&gt;grok_oct&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="31ce154734530fbfe5db4b0523f628ba63c57438" translate="yes" xml:space="preserve">
          <source>For best results compile the C file below with the same options as the Perl DLL. However, a lot of functionality will work even if the executable is not an EMX applications, e.g., if compiled with</source>
          <target state="translated">최상의 결과를 얻으려면 아래 Perl DLL과 동일한 옵션으로 C 파일을 컴파일하십시오. 그러나 실행 파일이 EMX 응용 프로그램이 아닌 경우에도 많은 기능이 작동합니다 (예 :</target>
        </trans-unit>
        <trans-unit id="9e295c225a2c063ef46517c1ea68fc0b9b4d3dfb" translate="yes" xml:space="preserve">
          <source>For best results use EMX pdksh. The standard binary (5.2.14 or later) runs under DOS (with &lt;a href=&quot;#RSX&quot;&gt;RSX&lt;/a&gt;) as well, see</source>
          <target state="translated">최상의 결과를 얻으려면 EMX pdksh를 사용하십시오. 표준 바이너리 (5.2.14 이상)는 DOS ( &lt;a href=&quot;#RSX&quot;&gt;RSX 포함&lt;/a&gt; )에서도 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="2f0811095fb18bd277912b660d1d859a6e53803d" translate="yes" xml:space="preserve">
          <source>For bigger projects, &lt;a href=&quot;http://search.cpan.org/perldoc/Moose&quot;&gt;Moose&lt;/a&gt; provides a rich set of features that will let you focus on implementing your business logic.</source>
          <target state="translated">대규모 프로젝트의 경우 &lt;a href=&quot;http://search.cpan.org/perldoc/Moose&quot;&gt;Moose&lt;/a&gt; 는 비즈니스 로직 구현에 집중할 수있는 다양한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d59e13b49a3ea8a677214c0ffa9c8aba3e39fb3c" translate="yes" xml:space="preserve">
          <source>For blocks see &lt;a href=&quot;http://www.unicode.org/Public/UNIDATA/Blocks.txt&quot;&gt;http://www.unicode.org/Public/UNIDATA/Blocks.txt&lt;/a&gt;</source>
          <target state="translated">블록은 &lt;a href=&quot;http://www.unicode.org/Public/UNIDATA/Blocks.txt&quot;&gt;http://www.unicode.org/Public/UNIDATA/Blocks.txt를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6af4234a6a3a035875ec423a946acfcba1e657d0" translate="yes" xml:space="preserve">
          <source>For building and installing non-XS modules, all you need is a working perl under DJGPP. Non-XS modules do not require re-linking the perl binary, and so are simpler to build and install.</source>
          <target state="translated">비 XS 모듈을 빌드하고 설치하려면 DJGPP에서 작동하는 펄만 있으면됩니다. 비 XS 모듈은 perl 바이너리를 다시 연결하지 않아도되므로 빌드 및 설치가 더 간단합니다.</target>
        </trans-unit>
        <trans-unit id="bae42e060753892a262ac6235f3d580be0d729e0" translate="yes" xml:space="preserve">
          <source>For building perl to support Oracle, it needs to be linked with libcl and libpthread. So even if your perl is an unthreaded build, these libraries might be required. See &quot;Oracle on HP-UX&quot; below.</source>
          <target state="translated">Oracle을 지원하기 위해 perl을 빌드하려면 libcl 및 libpthread와 링크되어야합니다. 따라서 perl이 스레드되지 않은 빌드 인 경우에도 이러한 라이브러리가 필요할 수 있습니다. 아래 &quot;Oracle on HP-UX&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ae71424b7af33e662d7ce3e8063ed7f56ae7be34" translate="yes" xml:space="preserve">
          <source>For case-insensitive comparisions, look at the &lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt; case-folding function, available in Perl v5.16 or later:</source>
          <target state="translated">대소 문자를 구분하지 않는 비교 는 Perl v5.16 이상에서 사용 가능한 &lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt; 대소 문자 구분 기능을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1cb5c1d99fc673348b120d9a851d1117c6607188" translate="yes" xml:space="preserve">
          <source>For case-insensitiveness, the &quot;casefolding&quot; of Unicode is used instead of upper/lowercasing both the characters, see &lt;a href=&quot;http://www.unicode.org/unicode/reports/tr21/&quot;&gt;http://www.unicode.org/unicode/reports/tr21/&lt;/a&gt; (Case Mappings).</source>
          <target state="translated">대소 문자를 구분하지 않으려면 두 문자를 모두 대문자 / 소문자 대신 유니 코드의 &quot;casefolding&quot;을 사용 &lt;a href=&quot;http://www.unicode.org/unicode/reports/tr21/&quot;&gt;하십시오&lt;/a&gt; ( http://www.unicode.org/unicode/reports/tr21/(Case Mappings) 참조 ).</target>
        </trans-unit>
        <trans-unit id="724ee81f8304298ce7234758616a260234c90146" translate="yes" xml:space="preserve">
          <source>For changes significant enough to warrant a</source>
          <target state="translated">보증 할만큼 중요한 변경의 경우</target>
        </trans-unit>
        <trans-unit id="3357a4c3d096539100edeae44fe0fc63f41c1eb0" translate="yes" xml:space="preserve">
          <source>For cloning empty array or hash refs, the following may also be used:</source>
          <target state="translated">빈 배열 또는 해시 참조 복제에는 다음을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="52fc59bd49cfa06cf9318166c80386309a2f14db" translate="yes" xml:space="preserve">
          <source>For compactness, '&lt;b&gt;*&lt;/b&gt;' is used as a wildcard instead of showing all possible combinations. For example, entries like:</source>
          <target state="translated">압축을 위해 ' &lt;b&gt;*&lt;/b&gt; '가 가능한 모든 조합을 표시하는 대신 와일드 카드로 사용됩니다. 예를 들어 다음과 같은 항목이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c09a91ddfd48857b97077c2773ecb81af6bc79f" translate="yes" xml:space="preserve">
          <source>For comparisons to a specific language it is often best to create a small project in both languages and compare the results, make sure to use all the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org%2f&quot;&gt;resources&lt;/a&gt; of each language, as a language is far more than just it's syntax.</source>
          <target state="translated">특정 언어와 비교하려면 종종 두 언어로 작은 프로젝트를 만들고 결과를 비교하는 것이 가장 좋습니다 . 언어는 구문 이상의 것이기 때문에 각 언어의 모든 &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org%2f&quot;&gt;리소스&lt;/a&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="5928beb9ec422a398dc240b1a98fb88a78eacc43" translate="yes" xml:space="preserve">
          <source>For compatibility with</source>
          <target state="translated">와의 호환성을 위해</target>
        </trans-unit>
        <trans-unit id="a7092eb766c083ed1177ee219bb4e03d914e1567" translate="yes" xml:space="preserve">
          <source>For compatibility with other parts of Perl, all the single forms given in the table in the &lt;a href=&quot;#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;section above&lt;/a&gt; are recognized. BUT, there are some ambiguities between some Perl extensions and the Unicode properties, all of which are silently resolved in favor of the official Unicode property. To avoid surprises, you should only use &lt;code&gt;prop_invmap()&lt;/code&gt; for forms listed in the table below, which omits the non-recommended ones. The affected forms are the Perl single form equivalents of Unicode properties, such as &lt;code&gt;\p{sc}&lt;/code&gt; being a single-form equivalent of &lt;code&gt;\p{gc=sc}&lt;/code&gt; , which is treated by &lt;code&gt;prop_invmap()&lt;/code&gt; as the &lt;code&gt;Script&lt;/code&gt; property, whose short name is &lt;code&gt;sc&lt;/code&gt; . The table indicates the current ambiguities in the INFO column, beginning with the word &lt;code&gt;&quot;NOT&quot;&lt;/code&gt; .</source>
          <target state="translated">Perl의 다른 부분과의 호환성을 위해 &lt;a href=&quot;#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;위 섹션&lt;/a&gt; 의 표에 제공된 모든 단일 형식 이 인식됩니다. 그러나 일부 Perl 확장과 유니 코드 속성 사이에는 약간의 모호성이 있으며, 이들 모두는 공식적인 유니 코드 속성을 위해 자동으로 해결됩니다. 놀라움을 피하기 위해 아래 표에 나열된 양식 에만 &lt;code&gt;prop_invmap()&lt;/code&gt; 을 사용해야 합니다. 권장하지 않는 양식은 생략되어 있습니다. 영향을받는 형식은 &lt;code&gt;\p{sc}&lt;/code&gt; 와 같은 단일 형식의 Unicode 속성에 해당하는 Perl 단일 형식에 해당합니다. &lt;code&gt;\p{gc=sc}&lt;/code&gt; 와 같은 단일 형식에 해당 합니다. &lt;code&gt;prop_invmap()&lt;/code&gt; 의해 짧은 이름 인 &lt;code&gt;Script&lt;/code&gt; 속성 으로 처리됩니다. 이다 &lt;code&gt;sc&lt;/code&gt; . 이 테이블은 &lt;code&gt;&quot;NOT&quot;&lt;/code&gt; 단어로 시작하여 INFO 열의 현재 모호성을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="e8f8cf45418f21110ef02ba18a8fe7b0e0a35cfe" translate="yes" xml:space="preserve">
          <source>For compatibility with perl scripts written for the Unix environment, Plan 9 Perl uses the POSIX signal emulation provided in Plan 9's ANSI POSIX Environment (APE). Signal stacking isn't supported. The signals provided are:</source>
          <target state="translated">Unix 환경 용으로 작성된 perl 스크립트와의 호환성을 위해 Plan 9 Perl은 Plan 9의 ANSI POSIX Environment (APE)에서 제공되는 POSIX 신호 에뮬레이션을 사용합니다. 신호 스태킹은 지원되지 않습니다. 제공되는 신호는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f7ddc7130612083ca6f3d06a09409b25b9346875" translate="yes" xml:space="preserve">
          <source>For compatibility with popular C library functions, Perl implementations of the mkstemp() family of functions are provided. These are, mkstemp(), mkstemps(), mkdtemp() and mktemp().</source>
          <target state="translated">널리 사용되는 C 라이브러리 함수와의 호환성을 위해 mkstemp () 함수 계열의 Perl 구현이 제공됩니다. mkstemp (), mkstemps (), mkdtemp () 및 mktemp ()입니다.</target>
        </trans-unit>
        <trans-unit id="d25b76835899d4044aad201d72be6ea01f31876a" translate="yes" xml:space="preserve">
          <source>For compatibility with the old B::Terse, this module also adds a method named &lt;code&gt;terse&lt;/code&gt; to B::OP and B::SV objects. The B::SV method is largely compatible with the old one, though authors of new software might be advised to choose a more user-friendly output format. The B::OP &lt;code&gt;terse&lt;/code&gt; method, however, doesn't work well. Since B::Terse was first written, much more information in OPs has migrated to the scratchpad datastructure, but the &lt;code&gt;terse&lt;/code&gt; interface doesn't have any way of getting to the correct pad. As a kludge, the new version will always use the pad for the main program, but for OPs in subroutines this will give the wrong answer or crash.</source>
          <target state="translated">이전 B :: Terse와의 호환성을 위해이 모듈은 &lt;code&gt;terse&lt;/code&gt; 라는 메소드 를 B :: OP 및 B :: SV 객체에 추가합니다. B :: SV 방법은 기존 방법과 대부분 호환되지만 새 소프트웨어 제작자는보다 사용자 친화적 인 출력 형식을 선택하도록 권장 할 수 있습니다. 그러나 B :: OP &lt;code&gt;terse&lt;/code&gt; 방법은 제대로 작동하지 않습니다. B :: Terse가 처음 작성되었으므로 OP의 더 많은 정보가 스크래치 패드 데이터 구조로 마이그레이션되었지만 &lt;code&gt;terse&lt;/code&gt; 인터페이스에는 올바른 패드를 가져올 수있는 방법이 없습니다. kludge로서, 새로운 버전은 항상 메인 프로그램에 패드를 사용하지만 서브 루틴의 OP에 대해서는 잘못된 응답이나 충돌을 일으킬 것입니다.</target>
        </trans-unit>
        <trans-unit id="67ec1b88f948f8864ab885d448e428104a1f5cbb" translate="yes" xml:space="preserve">
          <source>For compiling, you need following:</source>
          <target state="translated">컴파일하려면 다음이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="2c3582fce0d2ea8e40bba69ca7dfa38ec981ba20" translate="yes" xml:space="preserve">
          <source>For completeness, here is &lt;code&gt;asynch_close&lt;/code&gt; . This shows how to remove the entry from the hash &lt;code&gt;Mapping&lt;/code&gt; .</source>
          <target state="translated">완전성을 위해 여기 &lt;code&gt;asynch_close&lt;/code&gt; 가 있습니다. 해시 &lt;code&gt;Mapping&lt;/code&gt; 에서 항목을 제거하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="1c043d0855883cdf3536e0246bdff4dcd9fcd74e" translate="yes" xml:space="preserve">
          <source>For consistency with common usage, perl's Configure script performs some minor manipulations on the operating system name and version number as reported by uname. Here's a partial translation table:</source>
          <target state="translated">일반적인 사용법과 일관성을 유지하기 위해 perl의 Configure 스크립트는 uname에 의해보고 된대로 운영 체제 이름 및 버전 번호를 약간 조작합니다. 다음은 부분 번역 표입니다.</target>
        </trans-unit>
        <trans-unit id="c929174990d09b02dcdbbabbaa2a02596a638c93" translate="yes" xml:space="preserve">
          <source>For constant subroutines, returns the constant SV returned by the subroutine.</source>
          <target state="translated">상수 서브 루틴의 경우 서브 루틴이 리턴 한 상수 SV를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9e387ea14df2d8d86cc5babf9af2677b505e2619" translate="yes" xml:space="preserve">
          <source>For constructs that do interpolate, variables beginning with &quot;&lt;code&gt;$&lt;/code&gt; &quot; or &quot;&lt;code&gt;@&lt;/code&gt; &quot; are interpolated. Subscripted variables such as &lt;code&gt;$a[3]&lt;/code&gt; or &lt;code&gt;$href-&amp;gt;{key}[0]&lt;/code&gt; are also interpolated, as are array and hash slices. But method calls such as &lt;code&gt;$obj-&amp;gt;meth&lt;/code&gt; are not.</source>
          <target state="translated">보간을 수행하는 구문의 경우 &quot; &lt;code&gt;$&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;@&lt;/code&gt; &quot;로 시작하는 변수 가 보간됩니다. &lt;code&gt;$a[3]&lt;/code&gt; 또는 &lt;code&gt;$href-&amp;gt;{key}[0]&lt;/code&gt; 과 같은 첨자 변수 도 배열 및 해시 슬라이스와 같이 보간됩니다. 그러나 &lt;code&gt;$obj-&amp;gt;meth&lt;/code&gt; 와 같은 메소드 호출 은 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ec376fd19b0ff28e80aef02d1aa6f9c7cab7d82a" translate="yes" xml:space="preserve">
          <source>For constructs with three-part delimiters (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;), the search is repeated once more. If the first delimiter is not an opening punctuation, the three delimiters must be the same, such as &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s!!!&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr)))&lt;/a&gt;&lt;/code&gt;, in which case the second delimiter terminates the left part and starts the right part at once. If the left part is delimited by bracketing punctuation (that is &lt;code&gt;()&lt;/code&gt; , &lt;code&gt;[]&lt;/code&gt; , &lt;code&gt;{}&lt;/code&gt; , or &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ), the right part needs another pair of delimiters such as &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s(){}&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr[]//&lt;/a&gt;&lt;/code&gt;. In these cases, whitespace and comments are allowed between the two parts, although the comment must follow at least one whitespace character; otherwise a character expected as the start of the comment may be regarded as the starting delimiter of the right part.</source>
          <target state="translated">세 부분으로 된 구분 기호 ( &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; )가있는 구문의 경우 검색이 한 번 더 반복됩니다. 첫 번째 구분 기호가 구두점이 아닌 경우 세 구분 기호는 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s!!!&lt;/a&gt;&lt;/code&gt; 와 같아야합니다 !!! 및 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr)))&lt;/a&gt;&lt;/code&gt; ,이 경우 상기 제 구분자 왼쪽 종료와 동시에 오른쪽 부분을 개시한다. 왼쪽 부분이 괄호 구두점 (즉 , &lt;code&gt;()&lt;/code&gt; , &lt;code&gt;[]&lt;/code&gt; , &lt;code&gt;{}&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; )으로 구분되면 오른쪽 부분에는 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s(){}&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr[]//&lt;/a&gt;&lt;/code&gt; 와 같은 다른 구분 기호 쌍이 필요합니다.. 이 경우 두 부분 사이에 공백과 주석이 허용되지만 주석은 최소한 하나의 공백 문자 뒤에 와야합니다. 그렇지 않으면 주석의 시작으로 예상되는 문자는 오른쪽 부분의 시작 구분자로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="343bf25e2927a4e247fde284894e20f4a2092df4" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;GLOB_CSH&lt;/code&gt; is a synonym for &lt;code&gt;GLOB_BRACE | GLOB_NOMAGIC | GLOB_QUOTE | GLOB_TILDE | GLOB_ALPHASORT&lt;/code&gt; .</source>
          <target state="translated">편의상 &lt;code&gt;GLOB_CSH&lt;/code&gt; 는 &lt;code&gt;GLOB_BRACE | GLOB_NOMAGIC | GLOB_QUOTE | GLOB_TILDE | GLOB_ALPHASORT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40732251f5c21be8c597889848a82040a77a373e" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;IO::File&lt;/code&gt; exports the O_XXX constants from the Fcntl module, if this module is available.</source>
          <target state="translated">편의상 &lt;code&gt;IO::File&lt;/code&gt; 은이 모듈을 사용할 수있는 경우 Fcntl 모듈에서 O_XXX 상수를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="38a10ffe4a20ca5792a7fd00b9c73d9ce59a1dd3" translate="yes" xml:space="preserve">
          <source>For convenience, Perl sets &lt;code&gt;$+&lt;/code&gt; to the string held by the highest numbered &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; ,... that got assigned (and, somewhat related, &lt;code&gt;$^N&lt;/code&gt; to the value of the &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; ,... most-recently assigned; i.e. the &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; ,... associated with the rightmost closing parenthesis used in the match).</source>
          <target state="translated">편의를 위해, 펄 설정 &lt;code&gt;$+&lt;/code&gt; 번호가 최고에 유지 문자열 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; 다소 관련 할당 얻었다 (그리고 &lt;code&gt;$^N&lt;/code&gt; 의 값에 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , ... 가장 최근이 할당 즉, &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , ...는 경기에서 사용되는 가장 오른쪽 닫는 괄호와 관련이 있습니다).</target>
        </trans-unit>
        <trans-unit id="fb5611347ffd15c1223ef802d0edf52fb7e73b41" translate="yes" xml:space="preserve">
          <source>For convenience, during a &lt;code&gt;'code...'&lt;/code&gt; filtering operation, Filter::Simple provides a package variable (&lt;code&gt;$Filter::Simple::placeholder&lt;/code&gt; ) that contains a pre-compiled regex that matches any placeholder...and captures the identifier within the placeholder. Placeholders can be moved and re-ordered within the source code as needed.</source>
          <target state="translated">편의상 &lt;code&gt;'code...'&lt;/code&gt; 필터링 작업 중에 Filter :: Simple은 모든 자리 표시 자와 일치하는 미리 컴파일 된 정규식을 포함하고 식별자를 캡처 하는 패키지 변수 ( &lt;code&gt;$Filter::Simple::placeholder&lt;/code&gt; )를 제공합니다. 자리 표시 자 내에서 자리 표시자는 필요에 따라 소스 코드 내에서 이동하고 순서를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc4adefa4b79abf45088dcb0ac2e06a348c35319" translate="yes" xml:space="preserve">
          <source>For conversion we have &lt;code&gt;Cygwin::win_to_posix_path()&lt;/code&gt; and &lt;code&gt;Cygwin::posix_to_win_path()&lt;/code&gt; .</source>
          <target state="translated">변환을 위해 &lt;code&gt;Cygwin::win_to_posix_path()&lt;/code&gt; 및 &lt;code&gt;Cygwin::posix_to_win_path()&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d928fe0051212f2f8da39a8b5bc221435184fd0" translate="yes" xml:space="preserve">
          <source>For copyright</source>
          <target state="translated">저작권</target>
        </trans-unit>
        <trans-unit id="1eecebe67970e7a41398f09174a7fb5bf129f3a9" translate="yes" xml:space="preserve">
          <source>For correct handling of East Asian half- and full-width characters, see &lt;a href=&quot;http://search.cpan.org/perldoc/Text::WrapI18N&quot;&gt;Text::WrapI18N&lt;/a&gt;. For more detailed controls: &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Format&quot;&gt;Text::Format&lt;/a&gt;.</source>
          <target state="translated">동아시아 반자 및 전자 문자를 올바르게 처리하려면 &lt;a href=&quot;http://search.cpan.org/perldoc/Text::WrapI18N&quot;&gt;Text :: WrapI18N을&lt;/a&gt; 참조하십시오 . 더 자세한 컨트롤 : &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Format&quot;&gt;Text :: Format&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b6f77b308a2ac839fd33563f9a552da3eeb4daa9" translate="yes" xml:space="preserve">
          <source>For date and time processing look at the many related modules on CPAN. For a comprehensive date and time representation look at the &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; module.</source>
          <target state="translated">날짜 및 시간 처리에 대해서는 CPAN의 많은 관련 모듈을보십시오. 포괄적 인 날짜 및 시간 표현은 &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="07b6da6b04aa2922da90bdf4ba16ff504d7726a7" translate="yes" xml:space="preserve">
          <source>For debugging of CPAN data there is the &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt; command which takes the same arguments as make/test/install and outputs each object's Data::Dumper dump. If an argument looks like a perl variable and contains one of &lt;code&gt;$&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; or &lt;code&gt;%&lt;/code&gt; , it is eval()ed and fed to Data::Dumper directly.</source>
          <target state="translated">CPAN 데이터의 디버깅에는 make / test / install과 동일한 인수를 사용하여 각 오브젝트의 Data :: Dumper 덤프를 출력 하는 &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt; 명령이 있습니다. 인수가 perl 변수처럼 보이고 &lt;code&gt;$&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; 또는 &lt;code&gt;%&lt;/code&gt; 중 하나를 포함 하는 경우 eval ()되어 Data :: Dumper에 직접 공급됩니다.</target>
        </trans-unit>
        <trans-unit id="8a807f2c9fb85faf8c9ac5d861d440bcf8bfce3c" translate="yes" xml:space="preserve">
          <source>For debugging the code of CPAN.pm itself in interactive mode, some debugging aid can be turned on for most packages within CPAN.pm with one of</source>
          <target state="translated">대화식 모드에서 CPAN.pm 코드 자체를 디버깅하기 위해 CPAN.pm 내의 대부분의 패키지에 대해 다음 중 하나를 사용하여 일부 디버깅 지원을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb5d5a55a6b1cad338bb173db36952043185ac23" translate="yes" xml:space="preserve">
          <source>For delays of finer granularity than one second, the Time::HiRes module (from CPAN, and starting from Perl 5.8 part of the standard distribution) provides ualarm(). You may also use Perl's four-argument version of select() leaving the first three arguments undefined, or you might be able to use the &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; interface to access setitimer(2) if your system supports it. See &lt;a href=&quot;perlfaq8&quot;&gt;perlfaq8&lt;/a&gt; for details.</source>
          <target state="translated">1 초보다 세분화 된 지연 시간을 위해 Time :: HiRes 모듈 (CPAN 및 표준 배포의 Perl 5.8에서 시작)은 ualarm ()을 제공합니다. 첫 번째 세 개의 인수를 정의하지 않은 상태로 Perl의 4 인수 버전의 select ()를 사용 하거나 시스템이 지원하는 경우 &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 인터페이스를 사용하여 setitimer (2)에 액세스 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;perlfaq8&quot;&gt;perlfaq8&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cd003af05b2132ba4b881a232af5e4cee8933eae" translate="yes" xml:space="preserve">
          <source>For delays of finer granularity than one second, the Time::HiRes module (from CPAN, and starting from Perl 5.8 part of the standard distribution) provides ualarm(). You may also use Perl's four-argument version of select() leaving the first three arguments undefined, or you might be able to use the &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; interface to access setitimer(2) if your system supports it. See &lt;a href=&quot;../perlfaq8&quot;&gt;perlfaq8&lt;/a&gt; for details.</source>
          <target state="translated">1 초보다 세분화 된 지연 시간을 위해 Time :: HiRes 모듈 (CPAN 및 표준 배포의 Perl 5.8에서 시작)은 ualarm ()을 제공합니다. 첫 번째 세 개의 인수를 정의하지 않은 상태로 Perl의 4 인수 버전의 select ()를 사용 하거나 시스템이 지원하는 경우 &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 인터페이스를 사용하여 setitimer (2)에 액세스 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;../perlfaq8&quot;&gt;perlfaq8&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="048bc05974c11cb3f14983d6e8a4de95a334014e" translate="yes" xml:space="preserve">
          <source>For delays of finer granularity than one second, the Time::HiRes module (from CPAN, and starting from Perl 5.8 part of the standard distribution) provides usleep(). You may also use Perl's four-argument version of select() leaving the first three arguments undefined, or you might be able to use the &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; interface to access setitimer(2) if your system supports it. See &lt;a href=&quot;perlfaq8&quot;&gt;perlfaq8&lt;/a&gt; for details.</source>
          <target state="translated">1 초보다 세분화 된 지연 시간을 위해 Time :: HiRes 모듈 (CPAN 및 표준 배포의 Perl 5.8 부분에서 시작)은 usleep ()을 제공합니다. 첫 번째 세 개의 인수를 정의하지 않은 상태로 Perl의 4 인수 버전의 select ()를 사용 하거나 시스템이 지원하는 경우 &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 인터페이스를 사용하여 setitimer (2)에 액세스 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;perlfaq8&quot;&gt;perlfaq8&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d999a8a7adf00f409cdbfb2fc0969a34ea071e33" translate="yes" xml:space="preserve">
          <source>For delays of finer granularity than one second, the Time::HiRes module (from CPAN, and starting from Perl 5.8 part of the standard distribution) provides usleep(). You may also use Perl's four-argument version of select() leaving the first three arguments undefined, or you might be able to use the &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; interface to access setitimer(2) if your system supports it. See &lt;a href=&quot;../perlfaq8&quot;&gt;perlfaq8&lt;/a&gt; for details.</source>
          <target state="translated">1 초보다 세분화 된 지연 시간을 위해 Time :: HiRes 모듈 (CPAN 및 표준 배포의 Perl 5.8 부분에서 시작)은 usleep ()을 제공합니다. 첫 번째 세 개의 인수를 정의하지 않은 상태로 Perl의 4 인수 버전의 select ()를 사용 하거나 시스템이 지원하는 경우 &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 인터페이스를 사용하여 setitimer (2)에 액세스 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;../perlfaq8&quot;&gt;perlfaq8&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="880c0e9f515e34271c2c3b119d8f343dab33b21c" translate="yes" xml:space="preserve">
          <source>For dependencies that are required in order to run &lt;code&gt;Makefile.PL&lt;/code&gt; , see &lt;code&gt;CONFIGURE_REQUIRES&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;Makefile.PL&lt;/code&gt; 을 실행하는 데 필요한 종속성 은 &lt;code&gt;CONFIGURE_REQUIRES&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="33634f235f0082e4181888900b85711db47d8f18" translate="yes" xml:space="preserve">
          <source>For descriptions of the class hierarchy of these objects and the methods that can be called on them, see below, &lt;a href=&quot;#OVERVIEW-OF-CLASSES&quot;&gt;OVERVIEW OF CLASSES&lt;/a&gt; and &lt;a href=&quot;#OP-RELATED-CLASSES&quot;&gt;OP-RELATED CLASSES&lt;/a&gt;.</source>
          <target state="translated">이러한 객체의 클래스 계층 구조 및 해당 객체에서 호출 할 수있는 메소드에 대한 설명은 아래 &lt;a href=&quot;#OVERVIEW-OF-CLASSES&quot;&gt;의 클래스&lt;/a&gt; 및 &lt;a href=&quot;#OP-RELATED-CLASSES&quot;&gt;OP- 관련 클래스 &lt;/a&gt;의 개요를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f3b2ae9d73ddeeda58bc4e13e54cb8a6fed8f14d" translate="yes" xml:space="preserve">
          <source>For descriptions of the class hierarchy of these objects and the methods that can be called on them, see below, &lt;a href=&quot;#OVERVIEW-OF-CLASSES&quot;&gt;OVERVIEW OF CLASSES&lt;/a&gt; and &lt;a href=&quot;#SV-RELATED-CLASSES&quot;&gt;SV-RELATED CLASSES&lt;/a&gt;.</source>
          <target state="translated">이러한 객체의 클래스 계층 구조 및 해당 객체에서 호출 할 수있는 메소드에 대한 설명은 아래 &lt;a href=&quot;#OVERVIEW-OF-CLASSES&quot;&gt;의 클래스&lt;/a&gt; 및 &lt;a href=&quot;#SV-RELATED-CLASSES&quot;&gt;SV 관련 클래스를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6890c04c351eed8402cc96040025e018355d7713" translate="yes" xml:space="preserve">
          <source>For details, see &lt;code&gt;perldoc ppport.h&lt;/code&gt; .</source>
          <target state="translated">자세한 내용은 &lt;code&gt;perldoc ppport.h&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4be1d326997ed9e19e7a04e776dc614ee400c4f2" translate="yes" xml:space="preserve">
          <source>For details, see the description for &lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;uvchr_to_utf8_flags&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;uvchr_to_utf8_flags에&lt;/a&gt; 대한 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe4cabeb3c36ea2c5a3fbd884ca6fe8ba5049b92" translate="yes" xml:space="preserve">
          <source>For developers wishing to write their own tied arrays, the required methods are briefly defined below. See the &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; section for more detailed descriptive, as well as example code:</source>
          <target state="translated">고유 한 배열을 작성하려는 개발자의 경우 필요한 메소드가 아래에 간략하게 정의되어 있습니다. 예제 코드뿐만 아니라 자세한 설명 은 &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d33242068f9073573772617185fa7b62c43ab672" translate="yes" xml:space="preserve">
          <source>For developers wishing to write their own tied hashes, the required methods are briefly defined below. See the &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; section for more detailed descriptive, as well as example code:</source>
          <target state="translated">고유 한 해시를 작성하려는 개발자의 경우 필요한 메소드가 아래에 간략하게 정의되어 있습니다. 예제 코드뿐만 아니라 자세한 설명 은 &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c6d44567c847615da73e4dc3fbe1131bc5a3e2c2" translate="yes" xml:space="preserve">
          <source>For developers wishing to write their own tied-handle classes, the methods are summarized below. The &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; section not only documents these, but has sample code as well:</source>
          <target state="translated">자신의 연결 핸들 클래스를 작성하려는 개발자를 위해 메소드가 아래에 요약되어 있습니다. &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; 섹션 은 이것들을 문서화 할뿐만 아니라 샘플 코드도 가지고 있습니다 :</target>
        </trans-unit>
        <trans-unit id="928786a6337e41cc2160d3e1f5e15f742b97fa65" translate="yes" xml:space="preserve">
          <source>For developers wishing to write their own tied-scalar classes, the methods are summarized below. The &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; section not only documents these, but has sample code as well:</source>
          <target state="translated">자체 스칼라 클래스를 작성하려는 개발자를 위해 메소드가 아래에 요약되어 있습니다. &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; 섹션 은 이것들을 문서화 할뿐만 아니라 샘플 코드도 가지고 있습니다 :</target>
        </trans-unit>
        <trans-unit id="83e90c795a8afb6a6c9de6553439d8f6cbbf665f" translate="yes" xml:space="preserve">
          <source>For direct examination of the buffer, the variable &lt;a href=&quot;#PL_parser-%3ebufend&quot;&gt;PL_parser-&amp;gt;bufend&lt;/a&gt; points to the end of the buffer. The current lexing position is pointed to by &lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;PL_parser-&amp;gt;bufptr&lt;/a&gt;. Direct use of these pointers is usually preferable to examination of the scalar through normal scalar means.</source>
          <target state="translated">버퍼를 직접 검사하기 위해 변수 &lt;a href=&quot;#PL_parser-%3ebufend&quot;&gt;PL_parser-&amp;gt; bufend&lt;/a&gt; 는 버퍼의 끝을 가리 킵니다. 현재 lexing 위치는 &lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;PL_parser-&amp;gt; bufptr로 지정&lt;/a&gt; 됩니다. 보통 스칼라 수단을 통해 스칼라를 검사하기 위해서는 이러한 포인터를 직접 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="13c49c22472e027f068753f3e29a491152b0010b" translate="yes" xml:space="preserve">
          <source>For distributions that use</source>
          <target state="translated">사용하는 배포판</target>
        </trans-unit>
        <trans-unit id="985017370413b179ae3946fe35f99a058dfef566" translate="yes" xml:space="preserve">
          <source>For doing I/O it is suggested that you use the autotranslating features of PerlIO, see &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;.</source>
          <target state="translated">I / O를 수행하려면 PerlIO의 자동 &lt;a href=&quot;perluniintro&quot;&gt;번역&lt;/a&gt; 기능을 사용하는 것이 좋습니다 ( perluniintro 참조) .</target>
        </trans-unit>
        <trans-unit id="ce51f0686aa7fd04915057c8a38b4ba2a606bb7b" translate="yes" xml:space="preserve">
          <source>For double-quoted strings, the quoting from &lt;code&gt;\Q&lt;/code&gt; is applied after interpolation and escapes are processed.</source>
          <target state="translated">큰 따옴표로 묶인 문자열의 경우 &lt;code&gt;\Q&lt;/code&gt; 의 인용은 보간 및 이스케이프 처리 후 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="7153807fff58e3cc6dcc7b6391711735f5c48fc7" translate="yes" xml:space="preserve">
          <source>For each component, we mention environment variables related to each installation directory. Either choose directories to match your values of the variables, or create/append-to variables to take into account the directories.</source>
          <target state="translated">각 구성 요소에 대해 각 설치 디렉토리와 관련된 환경 변수를 언급합니다. 변수 값과 일치하는 디렉토리를 선택하거나 디렉토리를 고려할 변수를 작성 / 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="ba4c925cffa4324c85082d132c7153102054ac63" translate="yes" xml:space="preserve">
          <source>For each directory in LIST (called $dir here) the lib module also checks to see if a directory called $dir/$archname/auto exists. If so the $dir/$archname directory is assumed to be a corresponding architecture specific directory and is added to @INC in front of $dir. lib.pm also checks if directories called $dir/$version and $dir/$version/$archname exist and adds these directories to @INC.</source>
          <target state="translated">LIST의 각 디렉토리 (여기서는 $ dir)에서 lib 모듈은 $ dir / $ archname / auto라는 디렉토리가 존재하는지 확인합니다. 그렇다면 $ dir / $ archname 디렉토리는 해당 아키텍처 특정 디렉토리로 가정되며 $ dir 앞에 @INC에 추가됩니다. lib.pm은 또한 $ dir / $ version 및 $ dir / $ version / $ archname이라는 디렉토리가 있는지 확인하고이 디렉토리를 @INC에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="d6c50d0e6a86403f83c942ee394e8555abc0ddcd" translate="yes" xml:space="preserve">
          <source>For each directory in LIST (called $dir here) the lib module also checks to see if a directory called $dir/$archname/auto exists. If so the $dir/$archname directory is assumed to be a corresponding architecture specific directory and is also deleted from @INC.</source>
          <target state="translated">LIST의 각 디렉토리 (여기서는 $ dir)에서 lib 모듈은 $ dir / $ archname / auto라는 디렉토리가 존재하는지 확인합니다. 그렇다면 $ dir / $ archname 디렉토리는 해당 아키텍처 특정 디렉토리로 가정되며 @INC에서도 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="64daaac0c21c762b1798b346c0a1931a0dd72bc6" translate="yes" xml:space="preserve">
          <source>For each library that is found, an appropriate directive for a linker options file is generated. The return values are space-separated strings of these directives, rather than elements used on the linker command line.</source>
          <target state="translated">발견 된 각 라이브러리에 대해 링커 옵션 파일에 대한 적절한 지시문이 생성됩니다. 반환 값은 링커 명령 줄에서 사용되는 요소가 아니라 공백으로 구분 된 이러한 지시문의 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="3313c88e144064867d27f9004bd8e9beaf19e663" translate="yes" xml:space="preserve">
          <source>For each line, the &lt;code&gt;PARSER&lt;/code&gt; loop first tries to match a series of digits followed by a word boundary. This match has to start at the place the last match left off (or the beginning of the string on the first match). Since &lt;code&gt;m/ \G( \d+\b
)/gcx&lt;/code&gt; uses the &lt;code&gt;c&lt;/code&gt; flag, if the string does not match that regular expression, perl does not reset pos() and the next match starts at the same position to try a different pattern.</source>
          <target state="translated">각 줄에 대해 &lt;code&gt;PARSER&lt;/code&gt; 루프는 먼저 일련의 숫자와 단어 경계를 일치 시키려고 시도합니다. 이 일치는 마지막 일치가 중단 된 위치에서 시작해야합니다 (또는 첫 번째 일치에서 문자열의 시작). 이후 &lt;code&gt;m/ \G( \d+\b )/gcx&lt;/code&gt; 용도 &lt;code&gt;c&lt;/code&gt; 문자열이 정규 표현식에 일치하지 않는 경우 펄 다른 패턴을 시도하는 동일한 위치에 있지 리셋 POS () 및 다음 검색이 시작 않고, 플래그.</target>
        </trans-unit>
        <trans-unit id="fd6cfb118370f50c9c42bb5e390e24e86523c86f" translate="yes" xml:space="preserve">
          <source>For each line-style ('concise', 'terse', 'linenoise', etc.) there are 3 format-specs which control how OPs are rendered.</source>
          <target state="translated">각 선 스타일 ( '간결한', 'terse', 'linenoise'등)에는 OP가 렌더링되는 방법을 제어하는 ​​3 가지 형식 사양이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ef94716a1f5652ad5d33bb69a0e70bcd8744c37" translate="yes" xml:space="preserve">
          <source>For each of the fields marked &quot;(if any)&quot; the default value on success is an empty string. On failure, all of these values (except the remaining text) are &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&quot;(있는 경우)&quot;로 표시된 각 필드에 대해 성공시 기본값은 빈 문자열입니다. 실패하면,이 값들 (남은 텍스트 제외)은 모두 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4fdf0186b6bb5a61b6cf887ce8022d9f1ed87feb" translate="yes" xml:space="preserve">
          <source>For each of these three lists, the collection of signals set to be trapped is checked before trapping; if your architecture does not implement a particular signal, it will not be trapped but rather silently ignored.</source>
          <target state="translated">이 세 가지 목록 각각에 대해 트래핑되도록 설정된 신호 수집이 트래핑 전에 확인됩니다. 아키텍처가 특정 신호를 구현하지 않으면 트랩되지 않고 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c00c059a52bac42904c37c4c2fb8927b36fa4f53" translate="yes" xml:space="preserve">
          <source>For each such format, pack() generates 4 bits of result. With non-alphabetical characters, the result is based on the 4 least-significant bits of the input character, i.e., on &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord($char)%16&lt;/a&gt;&lt;/code&gt;. In particular, characters &lt;code&gt;&quot;0&quot;&lt;/code&gt; and &lt;code&gt;&quot;1&quot;&lt;/code&gt; generate nybbles 0 and 1, as do bytes &lt;code&gt;&quot;\000&quot;&lt;/code&gt; and &lt;code&gt;&quot;\001&quot;&lt;/code&gt; . For characters &lt;code&gt;&quot;a&quot;..&quot;f&quot;&lt;/code&gt; and &lt;code&gt;&quot;A&quot;..&quot;F&quot;&lt;/code&gt; , the result is compatible with the usual hexadecimal digits, so that &lt;code&gt;&quot;a&quot;&lt;/code&gt; and &lt;code&gt;&quot;A&quot;&lt;/code&gt; both generate the nybble &lt;code&gt;0xA==10&lt;/code&gt; . Use only these specific hex characters with this format.</source>
          <target state="translated">이러한 각 형식에 대해 pack ()은 4 비트의 결과를 생성합니다. 알파벳이 아닌 문자의 경우 결과는 입력 문자의 4 개 최하위 비트, 즉 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord($char)%16&lt;/a&gt;&lt;/code&gt; 합니다. 특히, &lt;code&gt;&quot;0&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;1&quot;&lt;/code&gt; 문자 는 바이트 &lt;code&gt;&quot;\000&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;\001&quot;&lt;/code&gt; 과 같이 nybbles 0 및 1을 생성합니다 . &lt;code&gt;&quot;a&quot;..&quot;f&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;A&quot;..&quot;F&quot;&lt;/code&gt; 문자 의 경우 결과는 일반적인 16 진 숫자와 호환되므로 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;A&quot;&lt;/code&gt; 는 nybble &lt;code&gt;0xA==10&lt;/code&gt; 생성합니다 . 이 형식의 특정 16 진 문자 만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8b61b8ba63bd2e7b3403785e0beac1c665bb76ab" translate="yes" xml:space="preserve">
          <source>For each such format, pack() generates 4 bits of result. With non-alphabetical characters, the result is based on the 4 least-significant bits of the input character, i.e., on &lt;code&gt;&lt;a href=&quot;ord&quot;&gt;ord($char)%16&lt;/a&gt;&lt;/code&gt;. In particular, characters &lt;code&gt;&quot;0&quot;&lt;/code&gt; and &lt;code&gt;&quot;1&quot;&lt;/code&gt; generate nybbles 0 and 1, as do bytes &lt;code&gt;&quot;\000&quot;&lt;/code&gt; and &lt;code&gt;&quot;\001&quot;&lt;/code&gt; . For characters &lt;code&gt;&quot;a&quot;..&quot;f&quot;&lt;/code&gt; and &lt;code&gt;&quot;A&quot;..&quot;F&quot;&lt;/code&gt; , the result is compatible with the usual hexadecimal digits, so that &lt;code&gt;&quot;a&quot;&lt;/code&gt; and &lt;code&gt;&quot;A&quot;&lt;/code&gt; both generate the nybble &lt;code&gt;0xA==10&lt;/code&gt; . Use only these specific hex characters with this format.</source>
          <target state="translated">이러한 각 형식에 대해 pack ()은 4 비트의 결과를 생성합니다. 알파벳이 아닌 문자의 경우 결과는 입력 문자의 4 개 최하위 비트, 즉 &lt;code&gt;&lt;a href=&quot;ord&quot;&gt;ord($char)%16&lt;/a&gt;&lt;/code&gt; 합니다. 특히, &lt;code&gt;&quot;0&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;1&quot;&lt;/code&gt; 문자 는 바이트 &lt;code&gt;&quot;\000&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;\001&quot;&lt;/code&gt; 과 같이 nybbles 0 및 1을 생성합니다 . &lt;code&gt;&quot;a&quot;..&quot;f&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;A&quot;..&quot;F&quot;&lt;/code&gt; 문자 의 경우 결과는 일반적인 16 진 숫자와 호환되므로 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;A&quot;&lt;/code&gt; 는 nybble &lt;code&gt;0xA==10&lt;/code&gt; 생성합니다 . 이 형식의 특정 16 진 문자 만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="56bab3e1fc980d5c9adf77a55a7a575a655bbcbb" translate="yes" xml:space="preserve">
          <source>For earlier Perls, a QP encoder that works on both ASCII and EBCDIC platforms would look somewhat like the following:</source>
          <target state="translated">이전 Perls의 경우 ASCII 및 EBCDIC 플랫폼 모두에서 작동하는 QP 인코더는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d4008829801fc42279d6aea1087db0de93d9c0e6" translate="yes" xml:space="preserve">
          <source>For ease of access, the Perl manual has been split up into several sections.</source>
          <target state="translated">쉬운 접근을 위해 Perl 매뉴얼은 여러 섹션으로 나뉘어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2508ccfe05f4a37451a9fb33f66c8f8a0dd451f8" translate="yes" xml:space="preserve">
          <source>For ease of use also the SEEK_* constants (for seek() and sysseek(), e.g. SEEK_END) and the S_I* constants (for chmod() and stat()) are available for import. They can be imported either separately or using the tags &lt;code&gt;:&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;:mode&lt;/code&gt; .</source>
          <target state="translated">사용하기 쉽도록 SEEK_ * 상수 (see () 및 sysseek (), 예 : SEEK_END) 및 S_I * 상수 (chmod () 및 stat ())를 가져올 수 있습니다. 개별적으로 가져 오거나 태그 &lt;code&gt;:&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;:mode&lt;/code&gt; 를 사용하여 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c36f5b62afea33d1be2e3590e8d7005448aa361a" translate="yes" xml:space="preserve">
          <source>For easier debugging, you may prefer to always use the commas when not setting $Term::ANSIColor::AUTORESET or PUSHCOLOR/POPCOLOR so that you'll get a fatal compile error rather than a warning.</source>
          <target state="translated">보다 쉬운 디버깅을 위해 $ Term :: ANSIColor :: AUTORESET 또는 PUSHCOLOR / POPCOLOR를 설정하지 않을 때 항상 쉼표를 사용하여 경고가 아닌 치명적인 컴파일 오류가 발생하는 것을 선호 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98fbe6111f30281308f810d30686560db37e9754" translate="yes" xml:space="preserve">
          <source>For editors: if you're on Unix you probably have vi or a vi clone already, and possibly an emacs too, so you may not need to download anything. In any emacs the cperl-mode (M-x cperl-mode) gives you perhaps the best available Perl editing mode in any editor.</source>
          <target state="translated">에디터 : Unix를 사용하는 경우 vi 또는 vi 복제본이 이미 있고 emacs도있을 수 있으므로 아무것도 다운로드하지 않아도됩니다. 모든 emacs에서 cperl-mode (Mx cperl-mode)는 모든 편집기에서 가장 유용한 Perl 편집 모드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5aa663054769a993f1d5b54fdeaaf504f9f0a5ea" translate="yes" xml:space="preserve">
          <source>For efficiency reasons, Perl takes a conservative view of whether data is tainted. If an expression contains tainted data, any subexpression may be considered tainted, even if the value of the subexpression is not itself affected by the tainted data.</source>
          <target state="translated">효율성상의 이유로 Perl은 데이터의 오염 여부를 보수적으로 고려합니다. 표현식에 오염 된 데이터가 포함 된 경우 하위 표현식의 값이 오염 된 데이터의 영향을받지 않는 경우에도 하위 표현식이 오염 된 것으로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88d03294b4e14b45668b8c5e5b3dfd1364498c9a" translate="yes" xml:space="preserve">
          <source>For efficiency, consider using &lt;code&gt;newSVpvn&lt;/code&gt; instead.</source>
          <target state="translated">효율성을 &lt;code&gt;newSVpvn&lt;/code&gt; 대신 newSVpvn을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c6f3b14d486219cf0d85fabf0e9eb85e0b88039e" translate="yes" xml:space="preserve">
          <source>For encodings that are implemented by the &lt;code&gt;Encode::XS&lt;/code&gt; module, &lt;code&gt;CHECK&lt;/code&gt;&lt;code&gt;==&lt;/code&gt;&lt;code&gt;Encode::FB_PERLQQ&lt;/code&gt; puts &lt;code&gt;encode&lt;/code&gt; and &lt;code&gt;decode&lt;/code&gt; into &lt;code&gt;perlqq&lt;/code&gt; fallback mode.</source>
          <target state="translated">에 의해 구현되는 인코딩을 위해 &lt;code&gt;Encode::XS&lt;/code&gt; 모듈 &lt;code&gt;CHECK&lt;/code&gt; &lt;code&gt;==&lt;/code&gt; &lt;code&gt;Encode::FB_PERLQQ&lt;/code&gt; 풋의 &lt;code&gt;encode&lt;/code&gt; 및 &lt;code&gt;decode&lt;/code&gt; 에 &lt;code&gt;perlqq&lt;/code&gt; 모드 폴백.</target>
        </trans-unit>
        <trans-unit id="4f0461c72db1796ac384c3743d40421d6d728a24" translate="yes" xml:space="preserve">
          <source>For even better control look at &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Most&quot;&gt;Test::Most&lt;/a&gt;.</source>
          <target state="translated">더 나은 제어를 위해서는 &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Most&quot;&gt;Test :: Most를보십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6de84b40d8c9c92b7839fff9ac4fcc2776aacc0f" translate="yes" xml:space="preserve">
          <source>For even faster execution, you could do:</source>
          <target state="translated">더 빠른 실행을 위해 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b398db36194244f1d9cc63256c82345fa029b47" translate="yes" xml:space="preserve">
          <source>For example &quot;not ok 23 - hole count # TODO insufficient donuts&quot; would result in this structure:</source>
          <target state="translated">예를 들어 &quot;not ok 23-hole count # TODO insufficient donuts&quot;는 다음과 같은 구조로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="a5d3ee5d1b4b93034c4647239c3af6ae67c5bde3" translate="yes" xml:space="preserve">
          <source>For example &lt;code&gt;Carp&lt;/code&gt; itself is listed in &lt;code&gt;%Carp::CarpInternal&lt;/code&gt; . Therefore the full stack backtrace from &lt;code&gt;confess&lt;/code&gt; will not start inside of &lt;code&gt;Carp&lt;/code&gt; , and the short message from calling &lt;code&gt;croak&lt;/code&gt; is not placed on the line where &lt;code&gt;croak&lt;/code&gt; was called.</source>
          <target state="translated">예를 들어 &lt;code&gt;Carp&lt;/code&gt; 자체는 &lt;code&gt;%Carp::CarpInternal&lt;/code&gt; 나열되어 있습니다. 따라서에서 전체 스택 역 추적 &lt;code&gt;confess&lt;/code&gt; 내부에 시작되지 않습니다 &lt;code&gt;Carp&lt;/code&gt; , 및 호출에서 짧은 메시지 &lt;code&gt;croak&lt;/code&gt; 라인에 배치되지 &lt;code&gt;croak&lt;/code&gt; 불렀다.</target>
        </trans-unit>
        <trans-unit id="ace2b7f25e1af57e029dcfd910f2807f801a5827" translate="yes" xml:space="preserve">
          <source>For example &lt;code&gt;TIBETAN VOWEL SIGN VOCALIC RR&lt;/code&gt; with &lt;code&gt;COMBINING TILDE OVERLAY&lt;/code&gt; (&lt;code&gt;U+0344&lt;/code&gt; ) is &lt;code&gt;0FB2 0344 0F71 0F80&lt;/code&gt; in NFD. In this case &lt;code&gt;0FB2 0F80&lt;/code&gt; (&lt;code&gt;TIBETAN VOWEL SIGN VOCALIC R&lt;/code&gt; ) is detected, instead of &lt;code&gt;0FB2 0F71 0F80&lt;/code&gt; . Inserted &lt;code&gt;0344&lt;/code&gt; makes &lt;code&gt;0FB2 0F71 0F80&lt;/code&gt; discontiguous and lack of contraction &lt;code&gt;0FB2 0F71&lt;/code&gt; prohibits &lt;code&gt;0FB2 0F71 0F80&lt;/code&gt; from being detected.</source>
          <target state="translated">예를 들어 , &lt;code&gt;COMBINING TILDE OVERLAY&lt;/code&gt; &lt;code&gt;TIBETAN VOWEL SIGN VOCALIC RR&lt;/code&gt; 오버레이 ( &lt;code&gt;U+0344&lt;/code&gt; )를 갖는 TIBETAN VOWEL SIGN VOCALIC RR 은 NFD에서 &lt;code&gt;0FB2 0344 0F71 0F80&lt;/code&gt; 입니다. 이 경우 &lt;code&gt;0FB2 0F80&lt;/code&gt; ( &lt;code&gt;TIBETAN VOWEL SIGN VOCALIC R&lt;/code&gt; ) 대신에, 검출 &lt;code&gt;0FB2 0F71 0F80&lt;/code&gt; . 삽입 된 &lt;code&gt;0344&lt;/code&gt; 는 &lt;code&gt;0FB2 0F71 0F80&lt;/code&gt; 을 불 연속적으로 만들고 수축 부족 &lt;code&gt;0FB2 0F71&lt;/code&gt; 은 &lt;code&gt;0FB2 0F71 0F80&lt;/code&gt; 이 감지되는 것을 금지 합니다.</target>
        </trans-unit>
        <trans-unit id="30e72f699aeed60ccae59fad4d360b3c19491b02" translate="yes" xml:space="preserve">
          <source>For example &lt;code&gt;U+1F88&lt;/code&gt; is equivalent to &lt;code&gt;U+1F00 U+03B9&lt;/code&gt; , instead of just &lt;code&gt;U+1F80&lt;/code&gt; . This difference matters mainly for certain Greek capital letters with certain modifiers: the Full case-folding decomposes the letter, while the Simple case-folding would map it to a single character.</source>
          <target state="translated">예를 들어 &lt;code&gt;U+1F88&lt;/code&gt; 은 &lt;code&gt;U+1F00 U+03B9&lt;/code&gt; 대신 U + 1F00 U + 03B9 와 &lt;code&gt;U+1F80&lt;/code&gt; . 이 차이는 주로 특정 수정자를 가진 특정 그리스어 대문자의 경우에 중요합니다. 전체 대소 문자는 문자를 분해하고 단순 대소 문자는 단일 문자로 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="b565d7aeb5a29ca8ef10bd80a27e15b4565fe687" translate="yes" xml:space="preserve">
          <source>For example &lt;code&gt;ilogb(20)&lt;/code&gt; is 4, as an integer.</source>
          <target state="translated">예를 들어 &lt;code&gt;ilogb(20)&lt;/code&gt; 은 정수로 4입니다.</target>
        </trans-unit>
        <trans-unit id="214bce966a0b82f5da24e7d2944d4f30b962d2dd" translate="yes" xml:space="preserve">
          <source>For example &lt;code&gt;logb(20)&lt;/code&gt; is 4, as a floating point number.</source>
          <target state="translated">예를 들어 &lt;code&gt;logb(20)&lt;/code&gt; 은 부동 소수점 숫자로 4입니다.</target>
        </trans-unit>
        <trans-unit id="b1b87712e77039600d0bb5eadd729b52754dd4ad" translate="yes" xml:space="preserve">
          <source>For example a &lt;a href=&quot;http://search.cpan.org/perldoc/GDBM_File&quot;&gt;GDBM_File&lt;/a&gt; GDBM_READER tied hash will die with something like:</source>
          <target state="translated">예를 들어 &lt;a href=&quot;http://search.cpan.org/perldoc/GDBM_File&quot;&gt;GDBM_File&lt;/a&gt; GDBM_READER 연결 해시는 다음과 같이 죽습니다.</target>
        </trans-unit>
        <trans-unit id="74bb45479d65e581a981105236dd80b5a848028d" translate="yes" xml:space="preserve">
          <source>For example a template of C</source>
          <target state="translated">예를 들어 C의 템플릿</target>
        </trans-unit>
        <trans-unit id="22c45cfbac1c695f1bfa7c0643b1ffc692ad7e5a" translate="yes" xml:space="preserve">
          <source>For example if there is a &lt;code&gt;=head2&lt;/code&gt; in the POD file prior to a &lt;code&gt;=head1&lt;/code&gt; .</source>
          <target state="translated">예를 들어 &lt;code&gt;=head1&lt;/code&gt; 이전에 POD 파일에 &lt;code&gt;=head2&lt;/code&gt; 가있는 경우 입니다.</target>
        </trans-unit>
        <trans-unit id="0c9f1ca436392d899e51a2acc5e1317d1e2a72ba" translate="yes" xml:space="preserve">
          <source>For example the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fethanschoonover.com%2fsolarized&quot;&gt;Solarized&lt;/a&gt; colors can be mapped with:</source>
          <target state="translated">예를 들어 &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fethanschoonover.com%2fsolarized&quot;&gt;Solarized&lt;/a&gt; 색상은 다음을 사용하여 매핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="313b954d842d0bc62b1462fc60b81d6d65b41bbd" translate="yes" xml:space="preserve">
          <source>For example the Latin &lt;b&gt;script&lt;/b&gt; is spread over several &lt;b&gt;blocks&lt;/b&gt;, such as &lt;code&gt;Basic Latin&lt;/code&gt; , &lt;code&gt;Latin 1 Supplement&lt;/code&gt;, &lt;code&gt;Latin Extended-A&lt;/code&gt; , and &lt;code&gt;Latin Extended-B&lt;/code&gt; . On the other hand, the Latin script does not contain all the characters of the &lt;code&gt;Basic Latin&lt;/code&gt; block (also known as ASCII): it includes only the letters, and not, for example, the digits nor the punctuation.</source>
          <target state="translated">예를 들어 Latin &lt;b&gt;스크립트&lt;/b&gt; 는 &lt;code&gt;Basic Latin&lt;/code&gt; , &lt;code&gt;Latin 1 Supplement&lt;/code&gt; , &lt;code&gt;Latin Extended-A&lt;/code&gt; 및 &lt;code&gt;Latin Extended-B&lt;/code&gt; 와 같은 여러 &lt;b&gt;블록에&lt;/b&gt; 분산되어 있습니다 . 반면, 라틴 스크립트에는 &lt;code&gt;Basic Latin&lt;/code&gt; 블록 의 모든 문자 (ASCII라고도 함)가 포함되어 있지 않습니다. 예를 들어 숫자 나 문장 부호와 같은 문자 만 포함합니다.</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="6812d6ccb69fe61a2edf14ef55d513765cc75692" translate="yes" xml:space="preserve">
          <source>For example, &lt;b&gt;-COE&lt;/b&gt; and &lt;b&gt;-C6&lt;/b&gt; will both turn on UTF-8-ness on both STDOUT and STDERR. Repeating letters is just redundant, not cumulative nor toggling.</source>
          <target state="translated">예를 들어, &lt;b&gt;-COE&lt;/b&gt; 및 &lt;b&gt;-C6&lt;/b&gt; 것 STDOUT 및 STDERR 모두 UTF-8 호에 두 차례. 반복되는 문자는 중복되거나 토글되지 않고 중복됩니다.</target>
        </trans-unit>
        <trans-unit id="29e6ab6115ba236468a1784dbaded696c523a4aa" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;$+{foo}&lt;/code&gt; is equivalent to &lt;code&gt;$1&lt;/code&gt; after the following match:</source>
          <target state="translated">예를 들어, &lt;code&gt;$+{foo}&lt;/code&gt; 는 다음 일치 후 &lt;code&gt;$1&lt;/code&gt; 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="222cd952b129bcca43a9663919abeeb392a2e171" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;&amp;lt;..\\l*b\\file/*glob.p?&amp;gt;&lt;/code&gt; will work as expected (in that it will find something like '..\lib\File/DosGlob.pm' alright). Note that all path components are case-insensitive, and that backslashes and forward slashes are both accepted, and preserved. You may have to double the backslashes if you are putting them in literally, due to double-quotish parsing of the pattern by perl.</source>
          <target state="translated">예를 들어 &lt;code&gt;&amp;lt;..\\l*b\\file/*glob.p?&amp;gt;&lt;/code&gt; 는 예상대로 작동합니다 ( '.. \ lib \ File / DosGlob.pm'과 같은 것을 찾을 수 있습니다). 모든 경로 구성 요소는 대소 문자를 구분하지 않으며 백 슬래시와 슬래시가 모두 허용 및 유지됩니다. 펄로 패턴을 큰 따옴표로 묶기 때문에 백 슬래시를 문자 그대로 넣으면 백 슬래시를 두 배로 늘려야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="062393ae2c2d73fa3bc2e3a2d91a68adfcd83483" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;-oLaTeX&lt;/code&gt; currently tries all of the following classes: Pod::Perldoc::ToLaTeX Pod::Perldoc::Tolatex Pod::Perldoc::ToLatex Pod::Perldoc::ToLATEX Pod::Simple::LaTeX Pod::Simple::latex Pod::Simple::Latex Pod::Simple::LATEX Pod::LaTeX Pod::latex Pod::Latex Pod::LATEX.</source>
          <target state="translated">예를 들어, &lt;code&gt;-oLaTeX&lt;/code&gt; 는 현재 다음 클래스를 모두 시도합니다. Pod :: Perldoc :: ToLaTeX Pod :: Perldoc :: Tolatex Pod :: Perldoc :: ToLatex Pod :: Perldoc :: ToLATEX Pod :: Simple :: LaTeX Pod : : 단순 :: 라텍스 포드 :: 단순 :: 라텍스 포드 :: 단순 :: 라텍스 포드 :: 라텍스 포드 :: 라텍스 포드 :: 라텍스 포드 :: LATEX.</target>
        </trans-unit>
        <trans-unit id="77a1e585a487cc3bfbbd51ad5e562a48a610c1cd" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;HARNESS_PERL_SWITCHES=-T&lt;/code&gt; will turn on taint mode. &lt;code&gt;HARNESS_PERL_SWITCHES=-MDevel::Cover&lt;/code&gt; will run &lt;code&gt;Devel::Cover&lt;/code&gt; for each test.</source>
          <target state="translated">예를 들어, &lt;code&gt;HARNESS_PERL_SWITCHES=-T&lt;/code&gt; 는 오염 모드를 켭니다. &lt;code&gt;HARNESS_PERL_SWITCHES=-MDevel::Cover&lt;/code&gt; 는 각 테스트마다 &lt;code&gt;Devel::Cover&lt;/code&gt; 를 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="86e52df63e27db421ca6b9e4dc513368b0a83476" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;U+0041&lt;/code&gt;&lt;code&gt;&quot;LATIN CAPITAL LETTER A&quot;&lt;/code&gt; was present in the very first Unicode release available, which is &lt;code&gt;1.1&lt;/code&gt; , so this property is true for all valid &quot;*&quot; versions. On the other hand, &lt;code&gt;U+1EFF&lt;/code&gt; was not assigned until version 5.1 when it became &lt;code&gt;&quot;LATIN SMALL LETTER Y WITH LOOP&quot;&lt;/code&gt; , so the only &quot;*&quot; that would match it are 5.1, 5.2, and later.</source>
          <target state="translated">예를 들어 &lt;code&gt;U+0041&lt;/code&gt; &lt;code&gt;&quot;LATIN CAPITAL LETTER A&quot;&lt;/code&gt; 는 사용 가능한 첫 번째 유니 코드 릴리스 인 &lt;code&gt;1.1&lt;/code&gt; 이므로이 속성은 모든 유효한 &quot;*&quot;버전에 적용됩니다. 반면, &lt;code&gt;U+1EFF&lt;/code&gt; 는 &lt;code&gt;&quot;LATIN SMALL LETTER Y WITH LOOP&quot;&lt;/code&gt; 가되었을 때 버전 5.1까지 할당되지 않았 으므로 일치하는 유일한 &quot;*&quot;는 5.1, 5.2 이상입니다.</target>
        </trans-unit>
        <trans-unit id="346cf35fe7206ef61916e68c2ca5d063324557a7" translate="yes" xml:space="preserve">
          <source>For example, Foo::Bar becomes Foo-Bar.</source>
          <target state="translated">예를 들어 Foo :: Bar는 Foo-Bar가됩니다.</target>
        </trans-unit>
        <trans-unit id="ea8cd802fd235063bdbe8cd10be2c1b9866e7e9d" translate="yes" xml:space="preserve">
          <source>For example, MyExpirePolicy::TIEHASH might create an object that contains a regular Perl hash (which it will to store the cached values) and some extra information about the arguments and how old the data is and things like that. Let us call this object `C'.</source>
          <target state="translated">예를 들어 MyExpirePolicy :: TIEHASH는 일반 Perl 해시 (캐시 된 값을 저장)와 인수에 대한 추가 정보 및 데이터의 수명 및 이와 유사한 사항을 포함하는 오브젝트를 작성할 수 있습니다. 이 객체를`C '라고하자.</target>
        </trans-unit>
        <trans-unit id="7e2c26a54a82719f79b06117790e2637ab0e300f" translate="yes" xml:space="preserve">
          <source>For example, a &lt;code&gt;Moose&lt;/code&gt; class can subclass a &lt;code&gt;Moo&lt;/code&gt; class using &lt;code&gt;extends&lt;/code&gt; or consume a &lt;code&gt;Moo&lt;/code&gt; role using &lt;code&gt;with&lt;/code&gt; .</source>
          <target state="translated">예를 들어, &lt;code&gt;Moose&lt;/code&gt; 클래스는 &lt;code&gt;with&lt;/code&gt; 를 사용하여 &lt;code&gt;Moo&lt;/code&gt; 역할을 &lt;code&gt;extends&lt;/code&gt; 하거나 사용하여 &lt;code&gt;Moo&lt;/code&gt; 클래스를 서브 클래스화할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bf2744eaf270dcbbff1985c2b73c221de5631d9d" translate="yes" xml:space="preserve">
          <source>For example, a version of &lt;code&gt;like()&lt;/code&gt; , sans the useful diagnostic messages, could be written as:</source>
          <target state="translated">예를 들어 유용한 진단 메시지 인 &lt;code&gt;like()&lt;/code&gt; 버전은 다음 과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4218fb9c51483864cd6b3fb02448d68465452ff" translate="yes" xml:space="preserve">
          <source>For example, an XSUB</source>
          <target state="translated">예를 들어 XSUB</target>
        </trans-unit>
        <trans-unit id="d908226f910991ef51ebc57880107e99b08586dc" translate="yes" xml:space="preserve">
          <source>For example, consider the code below:</source>
          <target state="translated">예를 들어 아래 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="ec1791bd29717623df33288ef02efc342f0cf537" translate="yes" xml:space="preserve">
          <source>For example, consider the following scenario. You have a DBM database that you need to share with a third-party C application. The C application assumes that</source>
          <target state="translated">예를 들어 다음 시나리오를 고려하십시오. 타사 C 애플리케이션과 공유해야하는 DBM 데이터베이스가 있습니다. C 애플리케이션은 다음을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="8190f04d38d06a461e096583cfda36d375198e8e" translate="yes" xml:space="preserve">
          <source>For example, consider:</source>
          <target state="translated">예를 들어, 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="c1377b5d79a1a1b8f2eb1b799a03d844580027b4" translate="yes" xml:space="preserve">
          <source>For example, given the string:</source>
          <target state="translated">예를 들어 다음과 같은 문자열이 있습니다.</target>
        </trans-unit>
        <trans-unit id="61f7eb35077596ec97c395fa31a4c9dc65c12237" translate="yes" xml:space="preserve">
          <source>For example, here all the areas that are taken literally are underlined with a &quot;^&quot;, and all the in-bracket special regions are underlined with an X:</source>
          <target state="translated">예를 들어, 여기에 문자 그대로 취해진 모든 영역에는 &quot;^&quot;가 밑줄로 표시되고 모든 브래킷 특수 영역에는 X가 밑줄로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="282f0060364377e323c90656e8982dd19487e634" translate="yes" xml:space="preserve">
          <source>For example, here is a loop that inserts index producing entries before any line containing a certain pattern:</source>
          <target state="translated">예를 들어, 다음은 특정 패턴을 포함하는 행 앞에 색인 생성 항목을 삽입하는 루프입니다.</target>
        </trans-unit>
        <trans-unit id="c309481bf35b9a661995259865d469413fa7c131" translate="yes" xml:space="preserve">
          <source>For example, here is a minimal source code filter in a module named BANG.pm. It simply converts every occurrence of the sequence &lt;code&gt;BANG\s+BANG&lt;/code&gt; to the sequence &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt; 'BANG' if $BANG&lt;/code&gt; in any piece of code following a &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; BANG;&lt;/code&gt; statement (until the next &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt; BANG;&lt;/code&gt; statement, if any):</source>
          <target state="translated">예를 들어, BANG.pm이라는 모듈의 최소 소스 코드 필터는 다음과 같습니다. 단순히 시퀀스의 모든 발생을 변환 &lt;code&gt;BANG\s+BANG&lt;/code&gt; 시퀀스에 &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt; 'BANG' if $BANG&lt;/code&gt; 후속 코드의 어느 부분에 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; BANG;&lt;/code&gt; 진술 (다음에 &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt; BANG;&lt;/code&gt; &lt;a href=&quot;../functions/no&quot;&gt;없을&lt;/a&gt; 때까지 ; 진술이있는 경우) :</target>
        </trans-unit>
        <trans-unit id="deab4a0dbceae95053981957ee52dc40c226b6c1" translate="yes" xml:space="preserve">
          <source>For example, here is a sample filter that adds a trailing NULL character to all strings before they are written to the DBM file, and removes the trailing NULL when they are read from the DBM file</source>
          <target state="translated">예를 들어, 다음은 DBM 파일에 쓰기 전에 모든 문자열에 후행 NULL 문자를 추가하고 DBM 파일에서 읽을 때 후행 NULL을 제거하는 샘플 필터입니다.</target>
        </trans-unit>
        <trans-unit id="2ff6a04c682bedfc2159947b94ad35c5e1653401" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;$a&lt;/code&gt; is an object blessed into a package declaring</source>
          <target state="translated">예를 들어 &lt;code&gt;$a&lt;/code&gt; 가 패키지 선언에 축복 된 객체 인 경우</target>
        </trans-unit>
        <trans-unit id="e47691ce5bbf77ccdd2c65322eb9ae19daa34236" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;A&lt;/code&gt; inherits from &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; (in that order), &lt;code&gt;B&lt;/code&gt; overloads &lt;code&gt;+&lt;/code&gt; with &lt;code&gt;\&amp;amp;D::plus_sub&lt;/code&gt; , and &lt;code&gt;C&lt;/code&gt; overloads &lt;code&gt;+&lt;/code&gt; by &lt;code&gt;&quot;plus_meth&quot;&lt;/code&gt; , then the subroutine &lt;code&gt;D::plus_sub&lt;/code&gt; will be called to implement operation &lt;code&gt;+&lt;/code&gt; for an object in package &lt;code&gt;A&lt;/code&gt; .</source>
          <target state="translated">예를 들어, &lt;code&gt;A&lt;/code&gt; 로부터 상속 &lt;code&gt;B&lt;/code&gt; 및 &lt;code&gt;C&lt;/code&gt; (순차), &lt;code&gt;B&lt;/code&gt; 의 과부하 &lt;code&gt;+&lt;/code&gt; 와 &lt;code&gt;\&amp;amp;D::plus_sub&lt;/code&gt; 및 &lt;code&gt;C&lt;/code&gt; 의 과부하 &lt;code&gt;+&lt;/code&gt; 의해 &lt;code&gt;&quot;plus_meth&quot;&lt;/code&gt; 다음 루틴 &lt;code&gt;D::plus_sub&lt;/code&gt; 동작을 구현하기 위해 호출 될 &lt;code&gt;+&lt;/code&gt; 를 위한 패키지의 개체 . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fdb8e022d3a14d860cf1eee66a67b7f130110122" translate="yes" xml:space="preserve">
          <source>For example, if a user accepts only 'ca' (Catalan) and 'es' (Spanish), and the documents/interfaces you have available are just in German, Italian, and Chinese, then the user will most likely want the Italian one (and not the Chinese or German one!), instead of getting nothing. So &lt;code&gt;panic_languages('ca', 'es')&lt;/code&gt; returns a list containing 'it' (Italian).</source>
          <target state="translated">예를 들어 사용자가 'ca'(카탈로니아 어) 및 'es'(스페인어) 만 허용하고 사용 가능한 문서 / 인터페이스가 독일어, 이탈리아어 및 중국어로되어있는 경우 사용자는 이탈리아어를 원할 것입니다. (중국이나 독일은 아닙니다!) 대신 아무것도 얻지 못합니다. 따라서 &lt;code&gt;panic_languages('ca', 'es')&lt;/code&gt; 는 'it'(이탈리아어)가 포함 된 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="886940312d9491ca5ffc8d712e7908d39622ad09" translate="yes" xml:space="preserve">
          <source>For example, if no tests have run &lt;code&gt;is_passing()&lt;/code&gt; will be true because even though a suite with no tests is a failure you can add a passing test to it and start passing.</source>
          <target state="translated">예를 들어, 테스트가 실행되지 않은 경우 &lt;code&gt;is_passing()&lt;/code&gt; 은 true입니다. 테스트가없는 스위트가 실패하더라도 통과 테스트를 추가하고 통과를 시작할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="8759c901db12e35962f36dbb59c087c3f752959f" translate="yes" xml:space="preserve">
          <source>For example, if you add a Unicode string like</source>
          <target state="translated">예를 들어 다음과 같은 유니 코드 문자열을 추가하면</target>
        </trans-unit>
        <trans-unit id="32c9f1310448f772c98938afaa753d6c8ad8468a" translate="yes" xml:space="preserve">
          <source>For example, if you have 4 C functions multiply(), divide(), add(), subtract() all having the signature:</source>
          <target state="translated">예를 들어, 4 개의 C 함수 multiply (), divide (), add (), subtract ()가 모두 서명을 갖는 경우 :</target>
        </trans-unit>
        <trans-unit id="4a173ebec9470f66747de7c5eefed0eb1d0d01a0" translate="yes" xml:space="preserve">
          <source>For example, if you have a uuencoded and compressed source file, it is possible to stack a uudecode filter and an uncompression filter like this:</source>
          <target state="translated">예를 들어, uuencoded 및 압축 된 소스 파일이있는 경우 다음과 같이 uudecode 필터와 압축 해제 필터를 쌓을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9372470a314912841e718aa7d95049e68d683c3" translate="yes" xml:space="preserve">
          <source>For example, if you want all your regular expressions to have /msx on by default, simply put</source>
          <target state="translated">예를 들어, 모든 정규식에 기본적으로 / msx를 설정하려면 간단히</target>
        </trans-unit>
        <trans-unit id="4909c84cf33294d068c280ab4acd84ce25b4c18c" translate="yes" xml:space="preserve">
          <source>For example, if you wanted a function to make a new hash and return a reference to it, you have these options:</source>
          <target state="translated">예를 들어, 새로운 해시를 만들고 참조를 반환하는 함수를 원한다면 다음과 같은 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a570ae33985ad610c93d2b21ee03162407502a4d" translate="yes" xml:space="preserve">
          <source>For example, if your scalar is a reference and you want to modify the SvIVX slot, you can't just do SvROK_off, as that will leak the referent.</source>
          <target state="translated">예를 들어, 스칼라가 참조이고 SvIVX 슬롯을 수정하려는 경우 SvROK_off 만 수행 할 수 없습니다. 그러면 참조가 유출됩니다.</target>
        </trans-unit>
        <trans-unit id="85a3de5be37b1e7d1156f1cef62afbe6c76e2823" translate="yes" xml:space="preserve">
          <source>For example, imagine you want to return a reference from an XSUB function. Inside the XSUB routine, you create an SV which initially has a reference count of one. Then you call &lt;code&gt;newRV_inc&lt;/code&gt; , passing it the just-created SV. This returns the reference as a new SV, but the reference count of the SV you passed to &lt;code&gt;newRV_inc&lt;/code&gt; has been incremented to two. Now you return the reference from the XSUB routine and forget about the SV. But Perl hasn't! Whenever the returned reference is destroyed, the reference count of the original SV is decreased to one and nothing happens. The SV will hang around without any way to access it until Perl itself terminates. This is a memory leak.</source>
          <target state="translated">예를 들어, XSUB 함수에서 참조를 리턴한다고 가정하십시오. XSUB 루틴 내에서 처음에는 참조 카운트가 1 인 SV를 만듭니다. 그런 다음 &lt;code&gt;newRV_inc&lt;/code&gt; 를 호출 하여 방금 생성 한 SV에 전달합니다. 이것은 참조를 새 SV로 반환하지만 &lt;code&gt;newRV_inc&lt;/code&gt; 에 전달한 SV의 참조 카운트 가 2로 증가되었습니다. 이제 XSUB 루틴에서 참조를 반환하고 SV는 잊어 버립니다. 그러나 펄은 그렇지 않았습니다! 반환 된 레퍼런스가 파괴 될 때마다 원래 SV의 레퍼런스 카운트가 1로 줄어들고 아무 일도 일어나지 않습니다. SV는 Perl 자체가 종료 될 때까지 어떤 방법으로도 액세스 할 수 없습니다. 이것은 메모리 누수입니다.</target>
        </trans-unit>
        <trans-unit id="9cb2e2ef894e1ed98060074d6b4776bf06e4d3ee" translate="yes" xml:space="preserve">
          <source>For example, intuition tells you that this XS code:</source>
          <target state="translated">예를 들어 직감은이 XS 코드를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="74d92c0f78a3f35d2b66123bb54771dbbcbaaae8" translate="yes" xml:space="preserve">
          <source>For example, it might return these data (among others) for the difference between 5.008000 and 5.008001:</source>
          <target state="translated">예를 들어 5.008000과 5.008001의 차이에 대해 다음 데이터를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8932a840658bb617ebb44a7bc96b426c503bdff7" translate="yes" xml:space="preserve">
          <source>For example, let's say that you have a long-running database server daemon that you want folks to be able to access from the Web, but only if they go through a CGI interface. You'd have a small, simple CGI program that does whatever checks and logging you feel like, and then acts as a Unix-domain client and connects to your private server.</source>
          <target state="translated">예를 들어, 사람들이 CGI 인터페이스를 통과하는 경우에만 웹에서 액세스 할 수있는 장기 실행 데이터베이스 서버 데몬이 있다고 가정합니다. 검사 및 로깅을 원하는대로 수행 한 다음 Unix 도메인 클라이언트로 작동하고 개인 서버에 연결하는 작고 간단한 CGI 프로그램이 있습니다.</target>
        </trans-unit>
        <trans-unit id="86ba35baedd2bab7b0f63f6847d21e1fa348e167" translate="yes" xml:space="preserve">
          <source>For example, let's say you'd like to have your</source>
          <target state="translated">예를 들어,</target>
        </trans-unit>
        <trans-unit id="194fc6778319983cc9c4ca8c95042faf96fb7b65" translate="yes" xml:space="preserve">
          <source>For example, let's take a GUI driven program. It has a semaphore that it uses to synchronize access to the display, so only one thread is ever drawing at once. Handy, but of course you don't want any thread to start drawing until things are properly set up. In this case, you can create a semaphore with a counter set to zero, and up it when things are ready for drawing.</source>
          <target state="translated">예를 들어, GUI 기반 프로그램을 보자. 디스플레이에 대한 액세스를 동기화하는 데 사용되는 세마포어가 있으므로 한 번에 하나의 스레드 만 그려집니다. 편리하지만, 물건이 제대로 설정 될 때까지 실을 그리기를 원하지 않습니다. 이 경우 카운터를 0으로 설정하여 세마포어를 만들 수 있으며 물건을 그릴 준비가되면 위로 올릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5cc0c799c8ac490a734bb661c428c57117107e1" translate="yes" xml:space="preserve">
          <source>For example, many newer useful APIs are not present in OS/2 v2; many PM-related APIs require DLLs not available on floppy-boot setup.</source>
          <target state="translated">예를 들어, OS / 2 v2에는 최신의 유용한 API가 많이 없습니다. 많은 PM 관련 API에는 플로피 부팅 설정에서 사용할 수없는 DLL이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="dc5f27a11595298226b5ecd1db6f9aeef4a5b4ec" translate="yes" xml:space="preserve">
          <source>For example, on Unix this would escape any single-quotes in $text and put single-quotes around the whole thing.</source>
          <target state="translated">예를 들어, 유닉스에서 이것은 $ text에서 작은 따옴표를 이스케이프 처리하고 모든 것을 작은 따옴표로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="e6ea05a8d9aa3d31bd0e3e1d1aa6044dba6a83b8" translate="yes" xml:space="preserve">
          <source>For example, parsing a L&amp;lt;Foo/&quot;Bar&quot;&amp;gt; link will produce a start-token with a &quot;to&quot; attribute with the value &quot;Foo&quot;, a &quot;type&quot; attribute with the value &quot;pod&quot;, and a &quot;section&quot; attribute with the value &quot;Bar&quot;.</source>
          <target state="translated">예를 들어, L &amp;lt;Foo / &quot;Bar&quot;&amp;gt; 링크를 구문 분석하면 값이 &quot;Foo&quot;인 &quot;to&quot;속성, 값이 &quot;pod&quot;인 &quot;type&quot;속성 및 &quot;section&quot;이있는 시작 토큰이 생성됩니다. 값이 &quot;Bar&quot;인 속성.</target>
        </trans-unit>
        <trans-unit id="4d8ed73a29aeabbe37200513a23647bf9812ba11" translate="yes" xml:space="preserve">
          <source>For example, say you need to create a class implementing overloaded mathematical operators, and would like to provide your own pragma that functions much like &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; You'd like this code</source>
          <target state="translated">예를 들어 오버로드 된 수학 연산자를 구현하는 클래스를 작성해야하고 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 과 매우 유사한 기능을하는 고유 한 pragma를 제공한다고 가정하십시오 . 이 코드를 원합니다</target>
        </trans-unit>
        <trans-unit id="7fbbe0aa9845cec520a90786e8524e8299625199" translate="yes" xml:space="preserve">
          <source>For example, setting prefix_pattern to &lt;code&gt;--|-|\+|\/&lt;/code&gt; and long_prefix_pattern to &lt;code&gt;--|\/&lt;/code&gt; would add Win32 style argument handling.</source>
          <target state="translated">예를 들어 prefix_pattern을 &lt;code&gt;--|-|\+|\/&lt;/code&gt; 하고 long_prefix_pattern을 &lt;code&gt;--|\/&lt;/code&gt; 하면 Win32 스타일 인수 처리가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="83cdc2b87550c2073421ee9d7b2b562b30e21210" translate="yes" xml:space="preserve">
          <source>For example, suppose that a C function is declared as</source>
          <target state="translated">예를 들어, C 함수가 다음과 같이 선언되었다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="3032721d2a0b9447ee105fd0f58af3c782c7c78e" translate="yes" xml:space="preserve">
          <source>For example, suppose that you have a module, A, which already has an import function:</source>
          <target state="translated">예를 들어, 이미 가져 오기 기능이있는 모듈 A가 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="5d59fda06c904abab606e40ac19199fab2edd4c9" translate="yes" xml:space="preserve">
          <source>For example, suppose the start tag &quot;/para&quot; introduces a paragraph, which then continues until the next &quot;/endpara&quot; tag or until another &quot;/para&quot; tag is encountered:</source>
          <target state="translated">예를 들어 시작 태그 &quot;/ para&quot;에 단락이 도입되었다고 가정하면 다음 &quot;/ endpara&quot;태그까지 또는 다른 &quot;/ para&quot;태그가 나타날 때까지 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="722e9b7fb9ae1447f9773a346a88fa54f1637a70" translate="yes" xml:space="preserve">
          <source>For example, suppose under the previous example, the memory footprints were</source>
          <target state="translated">예를 들어, 이전 예에서 메모리 공간이</target>
        </trans-unit>
        <trans-unit id="05d893596622d4a80e535a21a12a1aee563b93bd" translate="yes" xml:space="preserve">
          <source>For example, suppose you have a document that starts out:</source>
          <target state="translated">예를 들어, 시작하는 문서가 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="52828c35e04550c449cacfba26c2cecd5cb47850" translate="yes" xml:space="preserve">
          <source>For example, the following code maintains a private counter, incremented each time the gimme_another() function is called:</source>
          <target state="translated">예를 들어 다음 코드는 gimme_another () 함수가 호출 될 때마다 증가하는 개인 카운터를 유지 관리합니다.</target>
        </trans-unit>
        <trans-unit id="1ed0efd5077b028dc94a3c2fa546515dce13ec61" translate="yes" xml:space="preserve">
          <source>For example, the following computes the same number as the System V sum program:</source>
          <target state="translated">예를 들어, 다음은 System V sum 프로그램과 동일한 숫자를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="19d3a9f832bfede9ec03750347c230d365e34605" translate="yes" xml:space="preserve">
          <source>For example, the following extracts substrings that are valid Perl variables:</source>
          <target state="translated">예를 들어, 다음은 유효한 Perl 변수 인 하위 문자열을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="f07ff2eac86996a294f8c340a4f99d7c05265d15" translate="yes" xml:space="preserve">
          <source>For example, the following filter detects concatenated pairs of strings/quotelikes and reverses the order in which they are concatenated:</source>
          <target state="translated">예를 들어, 다음 필터는 연결된 문자열 / quotelike 쌍을 감지하고 이들이 연결된 순서를 반대로합니다.</target>
        </trans-unit>
        <trans-unit id="1e0c2a812e2e3e862d2489a82a90a6fe426ea8bc" translate="yes" xml:space="preserve">
          <source>For example, the following will do the trick:</source>
          <target state="translated">예를 들어 다음은 트릭을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="e39332b0891fe5b116748687d101665a0ac3bf59" translate="yes" xml:space="preserve">
          <source>For example, the following would cause &lt;a href=&quot;queue&quot;&gt;Thread::Queue&lt;/a&gt; to create a empty, shared array reference via &lt;code&gt;&amp;amp;shared([])&lt;/code&gt; , copy the elements 'foo', 'bar' and 'baz' from &lt;code&gt;@ary&lt;/code&gt; into it, and then place that shared reference onto the queue:</source>
          <target state="translated">예를 들어, 다음은 &lt;a href=&quot;queue&quot;&gt;Thread :: Queue&lt;/a&gt; 가 &lt;code&gt;&amp;amp;shared([])&lt;/code&gt; 를 통해 빈 공유 배열 참조를 작성하고 &lt;code&gt;@ary&lt;/code&gt; 에서 'foo', 'bar'및 'baz'요소를 복사 한 다음 배치합니다. 큐에 대한 공유 참조 :</target>
        </trans-unit>
        <trans-unit id="74318882ba84561a544011d5b07567896cc6c6f2" translate="yes" xml:space="preserve">
          <source>For example, the template &lt;code&gt;x[L]&lt;/code&gt; skips as many bytes as in a packed long, and the template &lt;code&gt;&quot;$t X[$t] $t&quot;&lt;/code&gt; unpacks twice whatever $t (when variable-expanded) unpacks. If the template in brackets contains alignment commands (such as &lt;code&gt;x![d]&lt;/code&gt; ), its packed length is calculated as if the start of the template had the maximal possible alignment.</source>
          <target state="translated">예를 들어, 템플릿 &lt;code&gt;x[L]&lt;/code&gt; 은 압축 된 길이만큼 바이트를 건너 뛰고 &lt;code&gt;&quot;$t X[$t] $t&quot;&lt;/code&gt; 템플릿은 $ t (변수 확장시)의 압축이 풀릴 때마다 두 번 압축을 풉니 다. 대괄호 안의 템플릿에 정렬 명령 (예 : &lt;code&gt;x![d]&lt;/code&gt; )이 포함되어 있으면 템플릿 시작 부분에 가능한 최대 정렬이있는 것처럼 압축 길이가 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="5e7b531e77c163b8c2ffdb3ee7640976837b2cd8" translate="yes" xml:space="preserve">
          <source>For example, the two are equivalent:</source>
          <target state="translated">예를 들어, 두 가지는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="37ab708b8a37671c040bc6173605339df847f5d8" translate="yes" xml:space="preserve">
          <source>For example, this</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="6751e73c6b01b59d5dba968e1ce44f9db2bd48e6" translate="yes" xml:space="preserve">
          <source>For example, this Pod text:</source>
          <target state="translated">예를 들어이 포드 텍스트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f3defe2b1e9069ae388a99caeefdfba166f4eafb" translate="yes" xml:space="preserve">
          <source>For example, this program</source>
          <target state="translated">예를 들어이 프로그램</target>
        </trans-unit>
        <trans-unit id="6361c0f3a8383561486e71f9f602b08950af7cfb" translate="yes" xml:space="preserve">
          <source>For example, this program detects duplicate words, even when they span line breaks (but not paragraph ones). For this example, we don't need &lt;code&gt;/s&lt;/code&gt; because we aren't using dot in a regular expression that we want to cross line boundaries. Neither do we need &lt;code&gt;/m&lt;/code&gt; because we don't want caret or dollar to match at any point inside the record next to newlines. But it's imperative that $/ be set to something other than the default, or else we won't actually ever have a multiline record read in.</source>
          <target state="translated">예를 들어,이 프로그램은 줄 바꿈 (단락은 제외)에 걸쳐있을 때에도 중복 단어를 감지합니다. 이 예제에서는 라인 경계를 넘길 정규 표현식에 도트를 사용하지 않기 때문에 &lt;code&gt;/s&lt;/code&gt; 가 필요하지 않습니다 . 캐럿이나 달러가 줄 바꿈 옆의 레코드 내부에서 일치하지 않기 때문에 &lt;code&gt;/m&lt;/code&gt; 도 필요 하지 않습니다. 그러나 $ /를 기본값 이외의 값으로 설정해야합니다. 그렇지 않으면 실제로 여러 줄 레코드를 읽지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="1bd82174af8f3a036da73ea77435fa503303e9e8" translate="yes" xml:space="preserve">
          <source>For example, this reports that the handle smells IOish (but please don't really do this!):</source>
          <target state="translated">예를 들어, 핸들이 IOish 냄새가 나는 것으로보고되지만 실제로는하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="ef3a161073bd310ed2cbade0af56c0a0b5004f38" translate="yes" xml:space="preserve">
          <source>For example, this will print out $foo every time line 53 is passed:</source>
          <target state="translated">예를 들어, 53 행이 지날 때마다 $ foo를 출력합니다 :</target>
        </trans-unit>
        <trans-unit id="9605a513ac289376aa334b379fb4d5b13b111824" translate="yes" xml:space="preserve">
          <source>For example, to cause the previous filter to filter only up to a line of the form:</source>
          <target state="translated">예를 들어, 이전 필터가 양식의 한 줄까지만 필터링하게하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="300d70e414e6ea43611e3ca2af00e9302dad6ae4" translate="yes" xml:space="preserve">
          <source>For example, to convert ASCII/Latin1 to code page 037 take the output of the second numbers column from the output of recipe 2 (modified to add &lt;code&gt;&quot;\&quot;&lt;/code&gt; characters), and use it in &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; like so:</source>
          <target state="translated">예를 들어 ASCII / Latin1을 코드 페이지 037로 변환하려면 래서 피 2 ( &lt;code&gt;&quot;\&quot;&lt;/code&gt; 문자 를 추가하도록 수정)의 출력에서 ​​두 번째 숫자 열의 출력을 가져 와서 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 에서 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="dd7243dc5fc5fca757ae08f0881832e542544924" translate="yes" xml:space="preserve">
          <source>For example, to convert ISO-8859-1 data into a string in Perl's internal format:</source>
          <target state="translated">예를 들어 ISO-8859-1 데이터를 Perl의 내부 형식으로 된 문자열로 변환하려면 :</target>
        </trans-unit>
        <trans-unit id="a6cd7eef61c208f99d59f8caa4d148fd7c2f1727" translate="yes" xml:space="preserve">
          <source>For example, to convert a string from Perl's internal format into ISO-8859-1, also known as Latin1:</source>
          <target state="translated">예를 들어, 문자열을 Perl의 내부 형식에서 Latin1이라고도하는 ISO-8859-1로 변환하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="c5e7afc76698552bd4261769a00bd251fb42909a" translate="yes" xml:space="preserve">
          <source>For example, to create a new Perl variable called &quot;dberror&quot; that contains both the numeric and descriptive string error values, you could use the following code:</source>
          <target state="translated">예를 들어 숫자 및 설명 문자열 오류 값을 모두 포함하는 &quot;dberror&quot;라는 새 Perl 변수를 작성하려면 다음 코드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4d9b81a8771c07736a765b8d4696ec4b2677d0a" translate="yes" xml:space="preserve">
          <source>For example, to define a property that covers both the Japanese syllabaries (hiragana and katakana), you can define</source>
          <target state="translated">예를 들어, 일본어 음절 (히라가나 및 가타카나)을 모두 포함하는 속성을 정의하려면</target>
        </trans-unit>
        <trans-unit id="e2cb81580d4ab01621fb850e0ae4ed1624280f45" translate="yes" xml:space="preserve">
          <source>For example, to extract an HTML link (which should not contain nested links) use:</source>
          <target state="translated">예를 들어 HTML 링크 (내포 된 링크를 포함하지 않아야 함)를 추출하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c87052aad8c5be2f19681e4d2c2a7fd4fe520629" translate="yes" xml:space="preserve">
          <source>For example, to extract an arbitrary XML tag, but ignore &quot;empty&quot; elements:</source>
          <target state="translated">예를 들어, 임의의 XML 태그를 추출하지만 &quot;빈&quot;요소는 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="9cc0a6697b30109ed6291482e3cc85911a7299a8" translate="yes" xml:space="preserve">
          <source>For example, to find out how many tests unexpectedly succeeded (TODO tests which passed when they shouldn't):</source>
          <target state="translated">예를 들어, 예기치 않게 성공한 테스트 수 (TODO 테스트는 실패했을 때 통과 한 테스트)를 찾으려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="1cae119c444d0ffb7547a1a1d5509bf58d292d18" translate="yes" xml:space="preserve">
          <source>For example, to grab non-empty comments into $1, one should use either one of these:</source>
          <target state="translated">예를 들어, 비어 있지 않은 주석을 $ 1로 가져 오려면 다음 중 하나를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8a90f73c9c3213efb315136981dc33afcfd35395" translate="yes" xml:space="preserve">
          <source>For example, to set the top-of-form format for more than one output channel, you might do the following:</source>
          <target state="translated">예를 들어, 둘 이상의 출력 채널에 대해 최상위 형식을 설정하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="66259dd1f85a2d02b33a9e596d8f1d7b0ac5e796" translate="yes" xml:space="preserve">
          <source>For example, to start a traditional, non-OO module called Some::Module, create a file called</source>
          <target state="translated">예를 들어 Some :: Module이라는 기존의 비 OO 모듈을 시작하려면라는 파일을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f942067356d5cfcd3d6efe175d21ba418d7f8528" translate="yes" xml:space="preserve">
          <source>For example, to trap an interrupt signal, set up a handler like this:</source>
          <target state="translated">예를 들어, 인터럽트 신호를 트랩하려면 다음과 같이 핸들러를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="92fd80c8ef445eeb8d54adb5b6fe2e04ca178559" translate="yes" xml:space="preserve">
          <source>For example, use either</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="e046e6073a1c24e29ced7bc19e8dd56e44b12d30" translate="yes" xml:space="preserve">
          <source>For example, utf8 can be used for code points that don't exist in Unicode, like 9999999, but if you encode that to UTF-8, you get a substitution character (by default; see &lt;a href=&quot;encode#Handling-Malformed-Data&quot;&gt;Handling Malformed Data in Encode&lt;/a&gt; for more ways of dealing with this.)</source>
          <target state="translated">예를 들어 utf8은 9999999와 같이 유니 코드에 존재하지 않는 코드 포인트에 사용될 수 있지만 UTF-8로 인코딩하면 대체 문자를 얻습니다 (기본적 &lt;a href=&quot;encode#Handling-Malformed-Data&quot;&gt;으로 인코딩 된 형식이 잘못된 데이터 처리&lt;/a&gt; 방법 참조). 이것을 다루는.)</target>
        </trans-unit>
        <trans-unit id="d4bde612bc298204724714a89e628fae1a0918cc" translate="yes" xml:space="preserve">
          <source>For example, version 1.04 of Foo::Bar becomes Foo-Bar-1.04.</source>
          <target state="translated">예를 들어 Foo :: Bar 버전 1.04는 Foo-Bar-1.04가됩니다.</target>
        </trans-unit>
        <trans-unit id="266d34ca9cde516548f250156e2acb53b624a8d2" translate="yes" xml:space="preserve">
          <source>For example, we could create an &lt;code&gt;File::MP3&lt;/code&gt; class which &lt;b&gt;inherits&lt;/b&gt; from &lt;code&gt;File&lt;/code&gt; . An &lt;code&gt;File::MP3&lt;/code&gt;&lt;b&gt;is-a&lt;/b&gt;</source>
          <target state="translated">예를 들어 &lt;code&gt;File::MP3&lt;/code&gt; 에서 &lt;b&gt;상속&lt;/b&gt; 되는 &lt;code&gt;File&lt;/code&gt; :: MP3 클래스를 만들 수 있습니다 . &lt;code&gt;File::MP3&lt;/code&gt; &lt;b&gt;이다-A&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="65f8c076e86f7baf2e3727bbe95178fdd7a2c0fd" translate="yes" xml:space="preserve">
          <source>For example, when examining the file</source>
          <target state="translated">예를 들어 파일을 검사 할 때</target>
        </trans-unit>
        <trans-unit id="cb3609c45bff9184744275676cb2ee1d5fe3a104" translate="yes" xml:space="preserve">
          <source>For example, when looking for</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="adf9a9b9f8a7a1cec63a21f932af18f70eee8f7f" translate="yes" xml:space="preserve">
          <source>For example, when processing a file like</source>
          <target state="translated">예를 들어, 다음과 같은 파일을 처리 할 때</target>
        </trans-unit>
        <trans-unit id="cba8aca8bb23f147ba6dc9dc1178ec821ae0173e" translate="yes" xml:space="preserve">
          <source>For example, when you have a NFD/NFKD string, you can get its NFC/NFKC string, by saying</source>
          <target state="translated">예를 들어 NFD / NFKD 문자열이있는 경우 다음과 같이 말하여 NFC / NFKC 문자열을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91c7f19bed899b4adde0ad47a00ae7fce66a506f" translate="yes" xml:space="preserve">
          <source>For example, when you have a list of NFD/NFKD strings, you can get the concatenated NFD/NFKD string from them, by saying</source>
          <target state="translated">예를 들어 NFD / NFKD 문자열 목록이 있으면 다음과 같이 말하여 연결된 NFD / NFKD 문자열을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3034cdf7d48aa118a30ad1afd4515c72ccfcc722" translate="yes" xml:space="preserve">
          <source>For example, whenever you call Perl's built-in &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; function from the package &lt;code&gt;DB&lt;/code&gt; , the arguments that the corresponding stack frame was called with are copied to the &lt;code&gt;@DB::args&lt;/code&gt; array. These mechanisms are enabled by calling Perl with the &lt;b&gt;-d&lt;/b&gt; switch. Specifically, the following additional features are enabled (cf. &lt;a href=&quot;perlvar#%24%5eP&quot;&gt;$^P in perlvar&lt;/a&gt;):</source>
          <target state="translated">예를 들어, 패키지 &lt;code&gt;DB&lt;/code&gt; 에서 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; 함수 를 호출 할 때마다 해당 스택 프레임이 호출 된 &lt;code&gt;@DB::args&lt;/code&gt; 가 @DB :: args 배열에 복사됩니다 . 이러한 메커니즘은 &lt;b&gt;-d&lt;/b&gt; 스위치 와 함께 Perl을 호출하여 활성화됩니다 . 특히 다음과 같은 추가 기능이 활성화됩니다 ( &lt;a href=&quot;perlvar#%24%5eP&quot;&gt;perlvar의 $ ^ P&lt;/a&gt; 참조 ).&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="496a45f3d9650508d730c766abbe2dc2efdff27d" translate="yes" xml:space="preserve">
          <source>For example, with AnyEvent:</source>
          <target state="translated">예를 들어 AnyEvent의 경우 :</target>
        </trans-unit>
        <trans-unit id="50ca852a66a066546e548044450d4b46b8bedbcc" translate="yes" xml:space="preserve">
          <source>For example, you can use this to make sure your filter program managed to finish its output without filling up the disk:</source>
          <target state="translated">예를 들어, 필터 프로그램을 사용하여 디스크를 채우지 않고 출력을 완료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f78ed184c7f600686b51e6745d5640d97f8a709" translate="yes" xml:space="preserve">
          <source>For example, you can write code in EUC-JP as follows:</source>
          <target state="translated">예를 들어 다음과 같이 EUC-JP로 코드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="564fb0ce50134466df15da997cc5a96ad7e5b1e1" translate="yes" xml:space="preserve">
          <source>For example, you don't have to store individual bits in an array (which would mean that you're wasting a lot of space). To convert an array of bits to a string, use &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec()&lt;/a&gt;&lt;/code&gt; to set the right bits. This sets &lt;code&gt;$vec&lt;/code&gt; to have bit N set only if &lt;code&gt;$ints[N]&lt;/code&gt; was set:</source>
          <target state="translated">예를 들어, 배열에 개별 비트를 저장할 필요가 없습니다 (많은 공간을 낭비하고 있음을 의미 함). 비트 배열을 문자열로 변환하려면 &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec()&lt;/a&gt;&lt;/code&gt; 를 사용하여 올바른 비트를 설정하십시오. 이 세트 &lt;code&gt;$vec&lt;/code&gt; 경우 가지고 비트는 N에만 설정 &lt;code&gt;$ints[N]&lt;/code&gt; 설정 하였다 :</target>
        </trans-unit>
        <trans-unit id="e4a9a1afba08c0e0323d4da1c781504ee13c4f37" translate="yes" xml:space="preserve">
          <source>For example...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6547b0cdb06529c1189b765285dbdd443f754cdc" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;^(?&amp;gt;a*)ab&lt;/code&gt; will never match, since &lt;code&gt;(?&amp;gt;a*)&lt;/code&gt; (anchored at the beginning of string, as above) will match</source>
          <target state="translated">예를 들어, &lt;code&gt;^(?&amp;gt;a*)ab&lt;/code&gt; 는 절대로 일치하지 않습니다. &lt;code&gt;(?&amp;gt;a*)&lt;/code&gt; (위와 같이 문자열의 시작 부분에 고정됨)가 일치하므로</target>
        </trans-unit>
        <trans-unit id="163b6b4e5b46ae5e8f49caca2490012167a4aad8" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;perldoc -f &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; .</source>
          <target state="translated">예를 들면 다음과 같습니다. &lt;code&gt;perldoc -f &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ccb8c8d525664be9a2c42a89c1ccb7db9f4d46fb" translate="yes" xml:space="preserve">
          <source>For example: consider the following paragraphs:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1312a2f41c8de401877c05e89632223e0e5cb8c4" translate="yes" xml:space="preserve">
          <source>For examples of MRO implementations, see &lt;code&gt;S_mro_get_linear_isa_c3()&lt;/code&gt; and the &lt;code&gt;BOOT:&lt;/code&gt; section of</source>
          <target state="translated">MRO 구현의 예는 &lt;code&gt;S_mro_get_linear_isa_c3()&lt;/code&gt; 및 &lt;code&gt;BOOT:&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0d9e192f1a62478459e4e0a2eb7cdee0674f974c" translate="yes" xml:space="preserve">
          <source>For examples on how to use &lt;code&gt;ExtUtils::Embed&lt;/code&gt; for building C/C++ applications with embedded perl, see &lt;a href=&quot;../perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">Perl이 포함 된 C / C ++ 애플리케이션을 빌드 하기 위해 &lt;code&gt;ExtUtils::Embed&lt;/code&gt; 를 사용하는 방법에 대한 예제는 &lt;a href=&quot;../perlembed&quot;&gt;perlembed를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8df1fb453c312718721149b4f60d025d43cdae6c" translate="yes" xml:space="preserve">
          <source>For floating-point conversions (&lt;code&gt;e f g E F G&lt;/code&gt; ), numbers are usually assumed to be the default floating-point size on your platform (double or long double), but you can force &quot;long double&quot; with &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt; , or &lt;code&gt;ll&lt;/code&gt; if your platform supports them. You can find out whether your Perl supports long doubles via &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt;:</source>
          <target state="translated">부동 소수점 변환 ( &lt;code&gt;e f g E F G&lt;/code&gt; )의 경우 일반적으로 숫자는 플랫폼에서 기본 부동 소수점 크기 (더블 또는 롱 더블)로 간주되지만 플랫폼의 경우 &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;L&lt;/code&gt; 또는 &lt;code&gt;ll&lt;/code&gt; 로 &quot;긴 더블&quot;을 강제 할 수 있습니다 그들을 지원합니다. &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; 를 통해 Perl이 long double을 지원하는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe9c280207fb4b3b605495f5af12f4167164cdba" translate="yes" xml:space="preserve">
          <source>For floating-point conversions (&lt;code&gt;e f g E F G&lt;/code&gt; ), numbers are usually assumed to be the default floating-point size on your platform (double or long double), but you can force &quot;long double&quot; with &lt;code&gt;&lt;a href=&quot;q&quot;&gt;q&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt; , or &lt;code&gt;ll&lt;/code&gt; if your platform supports them. You can find out whether your Perl supports long doubles via &lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt;:</source>
          <target state="translated">부동 소수점 변환 ( &lt;code&gt;e f g E F G&lt;/code&gt; )의 경우 일반적으로 숫자는 플랫폼에서 기본 부동 소수점 크기 (더블 또는 롱 더블)로 간주되지만 플랫폼의 경우 &lt;code&gt;&lt;a href=&quot;q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;L&lt;/code&gt; 또는 &lt;code&gt;ll&lt;/code&gt; 로 &quot;긴 더블&quot;을 강제 할 수 있습니다 그들을 지원합니다. &lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt; 를 통해 Perl이 long double을 지원하는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a2a4ecd0b9d06146725ffb188a087bc4525a300e" translate="yes" xml:space="preserve">
          <source>For full generality, use the &lt;a href=&quot;perlapi#DO_UTF8&quot;&gt;DO_UTF8 in perlapi&lt;/a&gt; macro to see if the string in an SV is to be</source>
          <target state="translated">완전한 일반성을 위해 &lt;a href=&quot;perlapi#DO_UTF8&quot;&gt;perlapi&lt;/a&gt; 매크로 의 DO_UTF8을 사용하여 SV의 문자열이</target>
        </trans-unit>
        <trans-unit id="a42ce7d9b2566dc0c41503ddc1469a4bc77d0e4c" translate="yes" xml:space="preserve">
          <source>For function arguments declared as &lt;code&gt;const&lt;/code&gt; , omit the const attribute in the generated XS code.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 로 선언 된 함수 인수의 경우 생성 된 XS 코드에서 const 속성을 생략하십시오.</target>
        </trans-unit>
        <trans-unit id="919681d57047d475516f4557861f4178d615833e" translate="yes" xml:space="preserve">
          <source>For functions that can be used in either a scalar or list context, nonabortive failure is generally indicated in scalar context by returning the undefined value, and in list context by returning the empty list.</source>
          <target state="translated">스칼라 또는 목록 컨텍스트에서 사용할 수있는 함수의 경우 일반적으로 정의되지 않은 값을 반환하여 스칼라 컨텍스트와 비 목록을 반환하여 목록 컨텍스트에서 비 붕괴 실패를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="d05f6d928eacb78e02e398b53b981e094d0e39ce" translate="yes" xml:space="preserve">
          <source>For further details on attribute lists and their manipulation, see &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt; and &lt;a href=&quot;attribute/handlers&quot;&gt;Attribute::Handlers&lt;/a&gt;.</source>
          <target state="translated">속성 목록 및 조작에 대한 자세한 내용은 &lt;a href=&quot;attributes&quot;&gt;속성&lt;/a&gt; 및 &lt;a href=&quot;attribute/handlers&quot;&gt;Attribute :: Handlers를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="50dbbde71e3c0e2cc7647eee17d89f78c487f1da" translate="yes" xml:space="preserve">
          <source>For further details see &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;, &lt;a href=&quot;#tied-VARIABLE&quot;&gt;tied VARIABLE&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;../perltie&quot;&gt;pertilie&lt;/a&gt; , &lt;a href=&quot;#tied-VARIABLE&quot;&gt;tied VARIABLE을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fc5472ebf03889c66f3f1d848108e2b6c25b85d0" translate="yes" xml:space="preserve">
          <source>For further details see &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt;, &lt;a href=&quot;#tied-VARIABLE&quot;&gt;tied VARIABLE&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;perltie&quot;&gt;pertilie&lt;/a&gt; , &lt;a href=&quot;#tied-VARIABLE&quot;&gt;tied VARIABLE을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="48c784a1d33771e0a06fd5b4b963ce0c5344b49a" translate="yes" xml:space="preserve">
          <source>For further information about the categories, consult</source>
          <target state="translated">범주에 대한 자세한 내용은 다음을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d3848a5517719cc9d86dc98e4a87784d1b62f6be" translate="yes" xml:space="preserve">
          <source>For further information on how to conduct a proper installation consult the INSTALL file that comes with the perl source and the README file for your platform.</source>
          <target state="translated">올바른 설치 방법에 대한 자세한 내용은 perl 소스와 함께 제공되는 INSTALL 파일 및 해당 플랫폼의 README 파일을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="28c80b9972cc66010ab54cedb561b534cc47e943" translate="yes" xml:space="preserve">
          <source>For further information, please see &lt;a href=&quot;spec/unix&quot;&gt;File::Spec::Unix&lt;/a&gt;, &lt;a href=&quot;spec/mac&quot;&gt;File::Spec::Mac&lt;/a&gt;, &lt;a href=&quot;spec/os2&quot;&gt;File::Spec::OS2&lt;/a&gt;, &lt;a href=&quot;spec/win32&quot;&gt;File::Spec::Win32&lt;/a&gt;, or &lt;a href=&quot;spec/vms&quot;&gt;File::Spec::VMS&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;spec/unix&quot;&gt;File :: Spec :: Unix&lt;/a&gt; , &lt;a href=&quot;spec/mac&quot;&gt;File :: Spec :: Mac&lt;/a&gt; , &lt;a href=&quot;spec/os2&quot;&gt;File :: Spec :: OS2&lt;/a&gt; , &lt;a href=&quot;spec/win32&quot;&gt;File :: Spec :: Win32&lt;/a&gt; 또는 &lt;a href=&quot;spec/vms&quot;&gt;File :: Spec :: VMS를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5edf28281d94a2b5960cec422d6d02a62443a7d6" translate="yes" xml:space="preserve">
          <source>For general suggestions, try requesting &lt;code&gt;CPU&lt;/code&gt; or &lt;code&gt;memory&lt;/code&gt; .</source>
          <target state="translated">일반적인 제안 사항은 &lt;code&gt;CPU&lt;/code&gt; 또는 &lt;code&gt;memory&lt;/code&gt; 요청하십시오 .</target>
        </trans-unit>
        <trans-unit id="d357e5de00d555e2358554ff76cd929d52fe2111" translate="yes" xml:space="preserve">
          <source>For globbing (see &lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;, &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;) (obsolete? Perl uses builtin globbing nowadays...).</source>
          <target state="translated">globbing의 경우 ( &lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt; , &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;perlop의 I / O 연산자&lt;/a&gt; 참조 ) (사용되지 않습니까? Perl은 현재 내장 globbing을 사용합니다 ...)</target>
        </trans-unit>
        <trans-unit id="58503f8e65271fa8fe04c22bfeefeb43b3d52ae2" translate="yes" xml:space="preserve">
          <source>For greater flexibility use &lt;code&gt;constant_types()&lt;/code&gt; , &lt;code&gt;C_constant&lt;/code&gt; and &lt;code&gt;XS_constant&lt;/code&gt; , with which &lt;code&gt;WriteConstants&lt;/code&gt; is implemented.</source>
          <target state="translated">유연성을 높이기 위해 &lt;code&gt;WriteConstants&lt;/code&gt; 가 구현 되는 &lt;code&gt;constant_types()&lt;/code&gt; , &lt;code&gt;C_constant&lt;/code&gt; 및 &lt;code&gt;XS_constant&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0de33270f54dfe208dcaa472e2a23a92f8da154b" translate="yes" xml:space="preserve">
          <source>For hashes there is a specialized hook that gives control over hash keys (but not values). This hook calls &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; 'get' magic if the &quot;set&quot; function in the &lt;code&gt;ufuncs&lt;/code&gt; structure is NULL. The hook is activated whenever the hash is accessed with a key specified as an &lt;code&gt;SV&lt;/code&gt; through the functions &lt;code&gt;hv_store_ent&lt;/code&gt; , &lt;code&gt;hv_fetch_ent&lt;/code&gt; , &lt;code&gt;hv_delete_ent&lt;/code&gt; , and &lt;code&gt;hv_exists_ent&lt;/code&gt; . Accessing the key as a string through the functions without the &lt;code&gt;..._ent&lt;/code&gt; suffix circumvents the hook. See &lt;a href=&quot;hash/util/fieldhash#GUTS&quot;&gt;GUTS in Hash::Util::FieldHash&lt;/a&gt; for a detailed description.</source>
          <target state="translated">해시에는 해시 키를 제어 할 수있는 특수한 후크가 있습니다 (값은 아님). 이 후크 는 &lt;code&gt;ufuncs&lt;/code&gt; 구조 의 &quot;set&quot;함수 가 NULL 인 경우 &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; 'get'매직을 호출 합니다. 후크는 &lt;code&gt;hv_store_ent&lt;/code&gt; , &lt;code&gt;hv_fetch_ent&lt;/code&gt; , &lt;code&gt;hv_delete_ent&lt;/code&gt; 및 &lt;code&gt;hv_exists_ent&lt;/code&gt; 함수를 통해 &lt;code&gt;SV&lt;/code&gt; 로 지정된 키로 해시에 액세스 할 때마다 활성화됩니다 . &lt;code&gt;..._ent&lt;/code&gt; 접미사가 없는 함수를 통해 키로 문자열에 액세스하면 후크가 우회됩니다. 자세한 설명 &lt;a href=&quot;hash/util/fieldhash#GUTS&quot;&gt;은 Hash :: Util :: FieldHash의 GUTS를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8be86894a1183cb1339fe47f94cdbb010d7d4c9e" translate="yes" xml:space="preserve">
          <source>For historical reasons, Exporter supplies a &lt;code&gt;require_version&lt;/code&gt; method that simply delegates to &lt;code&gt;VERSION&lt;/code&gt; . Originally, before &lt;code&gt;UNIVERSAL::VERSION&lt;/code&gt; existed, Exporter would call &lt;code&gt;require_version&lt;/code&gt; .</source>
          <target state="translated">역사적 이유로 Exporter는 단순히 &lt;code&gt;VERSION&lt;/code&gt; 에 위임 하는 &lt;code&gt;require_version&lt;/code&gt; 메소드를 제공합니다 . 원래 &lt;code&gt;UNIVERSAL::VERSION&lt;/code&gt; 존재 하기 전에 Exporter는 &lt;code&gt;require_version&lt;/code&gt; 을 호출했습니다 .</target>
        </trans-unit>
        <trans-unit id="600f113a4040010b3033d7854bba8509d5ed27cc" translate="yes" xml:space="preserve">
          <source>For historical reasons, if &lt;code&gt;pat&lt;/code&gt; is null then the contents of &lt;code&gt;ERRSV&lt;/code&gt; (&lt;code&gt;$@&lt;/code&gt; ) will be used as an error message or object instead of building an error message from arguments. If you want to throw a non-string object, or build an error message in an SV yourself, it is preferable to use the &lt;a href=&quot;#croak_sv&quot;&gt;croak_sv&lt;/a&gt; function, which does not involve clobbering &lt;code&gt;ERRSV&lt;/code&gt; .</source>
          <target state="translated">역사적 이유로 &lt;code&gt;pat&lt;/code&gt; 이 null이면 &lt;code&gt;ERRSV&lt;/code&gt; ( &lt;code&gt;$@&lt;/code&gt; ) 의 내용은 인수에서 오류 메시지를 작성하는 대신 오류 메시지 또는 객체로 사용됩니다. 문자열이 아닌 객체를 던지거나 SV에서 직접 오류 메시지를 작성하려면 &lt;a href=&quot;#croak_sv&quot;&gt;ERRSV 클로버 링을&lt;/a&gt; 포함하지 않는 croak_sv 함수 를 사용하는 것이 &lt;code&gt;ERRSV&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b56608d17c68748711bf4ce7481c7c0f04ebd25a" translate="yes" xml:space="preserve">
          <source>For historical reasons, if you omit the list, &lt;code&gt;$_&lt;/code&gt; is used as the format; to use FILEHANDLE without a list, you must use a real filehandle like &lt;code&gt;FH&lt;/code&gt; , not an indirect one like &lt;code&gt;$fh&lt;/code&gt; . However, this will rarely do what you want; if $_ contains formatting codes, they will be replaced with the empty string and a warning will be emitted if warnings are enabled. Just use &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; if you want to print the contents of $_.</source>
          <target state="translated">역사적 이유로 목록을 생략하면 &lt;code&gt;$_&lt;/code&gt; 가 형식으로 사용됩니다. 목록없이 FILEHANDLE을 사용하려면 &lt;code&gt;$fh&lt;/code&gt; 와 같은 간접 파일이 아니라 &lt;code&gt;FH&lt;/code&gt; 와 같은 실제 파일 핸들을 사용해야합니다 . 그러나 이것은 당신이 원하는 것을 거의하지 않을 것입니다. $ _에 형식 코드가 포함되어 있으면 빈 문자열로 바뀌고 경고가 활성화되면 경고가 표시됩니다. 그냥 사용하는 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 당신이 $의 내용을 인쇄하려면 _.</target>
        </trans-unit>
        <trans-unit id="e79e19888efce3854a52e5d2a8daf4acff793786" translate="yes" xml:space="preserve">
          <source>For historical reasons, if you omit the list, &lt;code&gt;$_&lt;/code&gt; is used as the format; to use FILEHANDLE without a list, you must use a real filehandle like &lt;code&gt;FH&lt;/code&gt; , not an indirect one like &lt;code&gt;$fh&lt;/code&gt; . However, this will rarely do what you want; if $_ contains formatting codes, they will be replaced with the empty string and a warning will be emitted if warnings are enabled. Just use &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; if you want to print the contents of $_.</source>
          <target state="translated">역사적 이유로 목록을 생략하면 &lt;code&gt;$_&lt;/code&gt; 가 형식으로 사용됩니다. 목록없이 FILEHANDLE을 사용하려면 &lt;code&gt;$fh&lt;/code&gt; 와 같은 간접 파일이 아니라 &lt;code&gt;FH&lt;/code&gt; 와 같은 실제 파일 핸들을 사용해야합니다 . 그러나 이것은 당신이 원하는 것을 거의하지 않을 것입니다. $ _에 형식 코드가 포함되어 있으면 빈 문자열로 바뀌고 경고가 활성화되면 경고가 표시됩니다. 그냥 사용하는 &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 당신이 $의 내용을 인쇄하려면 _.</target>
        </trans-unit>
        <trans-unit id="8685cc82ad46d01d9c5b4bb2267ef13097a60367" translate="yes" xml:space="preserve">
          <source>For historical reasons, some values work on almost every system supported by Perl: 0 means read-only, 1 means write-only, and 2 means read/write. We know that these values do</source>
          <target state="translated">역사적 이유로 일부 값은 Perl이 지원하는 거의 모든 시스템에서 작동합니다. 0은 읽기 전용, 1은 쓰기 전용, 2는 읽기 / 쓰기를 의미합니다. 우리는 이러한 가치가</target>
        </trans-unit>
        <trans-unit id="13de78042df7d486da0987893d3eef529f8f05a4" translate="yes" xml:space="preserve">
          <source>For historical reasons, the &lt;code&gt;=value&lt;/code&gt; is optional, but defaults to 1 only where it is safe to do so--that is, mostly for Boolean options. It is always better to assign a specific value using &lt;code&gt;=&lt;/code&gt; . The &lt;code&gt;option&lt;/code&gt; can be abbreviated, but for clarity probably should not be. Several options can be set together. See &lt;a href=&quot;#Configurable-Options&quot;&gt;Configurable Options&lt;/a&gt; for a list of these.</source>
          <target state="translated">역사적 이유로 &lt;code&gt;=value&lt;/code&gt; 는 선택 사항이지만 안전한 경우에만, 즉 대부분 부울 옵션의 경우에만 1로 기본 설정됩니다. &lt;code&gt;=&lt;/code&gt; 를 사용하여 특정 값을 할당하는 것이 좋습니다 . 이 &lt;code&gt;option&lt;/code&gt; 은 약식으로 표현할 수 있지만 명확성을 위해 사용해서는 안됩니다. 여러 옵션을 함께 설정할 수 있습니다. 이들의 목록은 &lt;a href=&quot;#Configurable-Options&quot;&gt;구성 가능한 옵션&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="55b92ebb92494cfbe30e7229baf3e5d9062d8da3" translate="yes" xml:space="preserve">
          <source>For icmp, $ttl can be specified to set the TTL of the outgoing packet.</source>
          <target state="translated">icmp의 경우 $ ttl을 지정하여 발신 패킷의 TTL을 설정할 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
