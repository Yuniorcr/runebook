<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="eae6ee7e119fbc5f2aa2be859ce356e5505eb961" translate="yes" xml:space="preserve">
          <source>On some Unixes, select(2) may report a socket file descriptor as &quot;ready for reading&quot; even when no data is available, and thus any subsequent &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; would block. This can be avoided if you always use O_NONBLOCK on the socket. See select(2) and fcntl(2) for further details.</source>
          <target state="translated">일부 유닉스에서는 select (2)가 사용할 수있는 데이터가 없어도 소켓 파일 디스크립터를 &quot;읽을 수있는 상태&quot;로보고 할 수 있으므로 이후의 &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 는 차단됩니다. 소켓에서 항상 O_NONBLOCK을 사용하면 피할 수 있습니다. 자세한 내용은 select (2) 및 fcntl (2)를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c9de2fe586a63b0f77cf89fdbb109c06623eb1f4" translate="yes" xml:space="preserve">
          <source>On some Unixes, select(2) may report a socket file descriptor as &quot;ready for reading&quot; even when no data is available, and thus any subsequent &lt;code&gt;&lt;a href=&quot;read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; would block. This can be avoided if you always use O_NONBLOCK on the socket. See select(2) and fcntl(2) for further details.</source>
          <target state="translated">일부 유닉스에서는 select (2)가 사용할 수있는 데이터가 없어도 소켓 파일 디스크립터를 &quot;읽을 수있는 상태&quot;로보고 할 수 있으므로 이후의 &lt;code&gt;&lt;a href=&quot;read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 는 차단됩니다. 소켓에서 항상 O_NONBLOCK을 사용하면 피할 수 있습니다. 자세한 내용은 select (2) 및 fcntl (2)를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5ae4b16cd5d25f3c3c80ae711072c40499b4bc55" translate="yes" xml:space="preserve">
          <source>On some older systems, it may sleep up to a full second less than what you requested, depending on how it counts seconds. Most modern systems always sleep the full amount. They may appear to sleep longer than that, however, because your process might not be scheduled right away in a busy multitasking system.</source>
          <target state="translated">일부 구형 시스템에서는 시간을 계산하는 방법에 따라 요청한 것보다 최대 1 초 이하로 절전 모드로 전환 될 수 있습니다. 대부분의 최신 시스템은 항상 최대량을 사용합니다. 그러나 바쁜 멀티 태스킹 시스템에서 프로세스가 바로 예약되지 않았기 때문에 그보다 더 오래 잠자기 상태가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="558bd651fa8715821f75a4be7598cfc24234462e" translate="yes" xml:space="preserve">
          <source>On some operating systems certain signal handlers are supposed to &quot;do something&quot; before returning. One example can be CHLD or CLD, which indicates a child process has completed. On some operating systems the signal handler is expected to &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; for the completed child process. On such systems the deferred signal scheme will not work for those signals: it does not do the &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt;. Again the failure will look like a loop as the operating system will reissue the signal because there are completed child processes that have not yet been &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt;ed for.</source>
          <target state="translated">일부 운영 체제에서 특정 신호 핸들러는 리턴하기 전에 &quot;무엇을 수행&quot;해야합니다. 자식 프로세스가 완료되었음을 나타내는 CHLD 또는 CLD가 한 가지 예입니다. 일부 운영 체제에서 신호 핸들러는 완료된 하위 프로세스 를 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 것으로 예상됩니다 . 이러한 시스템에서는 지연된 신호 체계가 해당 신호에 대해 작동하지 않습니다 . &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 하지 않습니다 . 아직 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 하지 않은 하위 프로세스가 완료되었으므로 운영 체제가 신호를 다시 발행하므로 실패는 루프처럼 보입니다 .</target>
        </trans-unit>
        <trans-unit id="b286c0e46361b954aaba8f772a4a53334de3bd4e" translate="yes" xml:space="preserve">
          <source>On some operating systems such as Win32 installation may not be possible until after a reboot has occurred. This can have varying consequences: removing an old DLL does not impact programs using the new one, but if a new DLL cannot be installed properly until reboot then anything depending on it must wait. The package variable</source>
          <target state="translated">Win32와 같은 일부 운영 체제에서는 재부팅이 발생할 때까지 설치가 불가능할 수 있습니다. 오래된 DLL을 제거해도 새로운 DLL을 사용하는 프로그램에는 영향을 미치지 않지만 재부팅 할 때까지 새 DLL을 제대로 설치할 수없는 경우 대기해야합니다. 패키지 변수</target>
        </trans-unit>
        <trans-unit id="abbe82684e199993d30da7c411dda78b8ffa5204" translate="yes" xml:space="preserve">
          <source>On some operating systems, notably Solaris and Unixware, calling &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; from a child process will flush and close open filehandles in the parent, thereby corrupting the filehandles. On these systems, calling &lt;code&gt;_exit()&lt;/code&gt; is suggested instead. &lt;code&gt;_exit()&lt;/code&gt; is available in Perl through the &lt;code&gt;POSIX&lt;/code&gt; module. Please consult your system's manpages for more information on this.</source>
          <target state="translated">일부 운영 체제, 특히 Solaris 및 Unixware 에서 하위 프로세스에서 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 를 호출 하면 상위에서 열린 파일 핸들을 플러시하고 닫아 파일 핸들이 손상됩니다. 이러한 시스템에서는 대신 &lt;code&gt;_exit()&lt;/code&gt; 호출하는 것이 좋습니다. &lt;code&gt;_exit()&lt;/code&gt; 는 &lt;code&gt;POSIX&lt;/code&gt; 모듈을 통해 Perl에서 사용 가능 합니다. 이에 대한 자세한 내용은 시스템 맨 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e360f8c5bbe5608f4331396810f247c8a100f0a1" translate="yes" xml:space="preserve">
          <source>On some platforms (notably DOS-like ones), the shell may not be capable of dealing with multiline commands, so putting newlines in the string may not get you what you want. You may be able to evaluate multiple commands in a single line by separating them with the command separator character, if your shell supports that (for example, &lt;code&gt;;&lt;/code&gt; on many Unix shells and &lt;code&gt;&amp;amp;&lt;/code&gt; on the Windows NT &lt;code&gt;cmd&lt;/code&gt; shell).</source>
          <target state="translated">일부 플랫폼 (특히 DOS와 같은 플랫폼)에서 쉘은 여러 줄 명령을 처리하지 못할 수 있으므로 문자열에 줄 바꿈을 넣으면 원하는 결과를 얻지 못할 수 있습니다. 쉘이 지원하는 경우 명령 구분 문자 (예 : &lt;code&gt;;&lt;/code&gt; 많은 Unix 쉘 및 &lt;code&gt;&amp;amp;&lt;/code&gt; Windows NT &lt;code&gt;cmd&lt;/code&gt; 쉘) 로 분리하여 여러 명령을 한 줄로 평가할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b7498bd2534b138ca9192ebcb30213ef70ed5c94" translate="yes" xml:space="preserve">
          <source>On some platforms Perl supports retrieving the C level backtrace (similar to what symbolic debuggers like gdb do).</source>
          <target state="translated">일부 플랫폼에서 Perl은 C 레벨 역 추적 (gdb와 같은 기호 디버거와 유사한) 검색을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="a9e0966de849860f2089841e81ee24c757771be3" translate="yes" xml:space="preserve">
          <source>On some platforms such as Windows where the fork() system call is not available, Perl can be built to emulate fork() at the interpreter level. This emulation has limitations related to kill that have to be considered, for code running on Windows and in code intended to be portable.</source>
          <target state="translated">fork () 시스템 호출을 사용할 수없는 Windows와 같은 일부 플랫폼에서는 인터프리터 레벨에서 fork ()를 에뮬레이트하도록 Perl을 빌드 할 수 있습니다. 이 에뮬레이션에는 Windows에서 실행되는 코드와 이식 가능한 코드에서 고려해야 할 kill과 관련된 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4dca8272040520711e1d36a027c5a86ea7b32ae2" translate="yes" xml:space="preserve">
          <source>On some platforms such as Windows where the fork() system call is not available, Perl can be built to emulate fork() at the interpreter level. While the emulation is designed to be as compatible as possible with the real fork() at the level of the Perl program, there are certain important differences that stem from the fact that all the pseudo child &quot;processes&quot; created this way live in the same real process as far as the operating system is concerned.</source>
          <target state="translated">fork () 시스템 호출을 사용할 수없는 Windows와 같은 일부 플랫폼에서는 인터프리터 레벨에서 fork ()를 에뮬레이트하도록 Perl을 빌드 할 수 있습니다. 에뮬레이션은 Perl 프로그램 레벨에서 실제 fork ()와 가능한 한 호환되도록 설계되었지만, 모든 의사 자식 &quot;프로세스&quot;가 이런 방식으로 생성되었다는 사실에서 비롯된 중요한 차이점이 있습니다. 운영 체제에 관한 한 실제 프로세스.</target>
        </trans-unit>
        <trans-unit id="c6a78bf511c92cd39ee02c1151b5e571d5127a45" translate="yes" xml:space="preserve">
          <source>On some platforms such as Windows, where the fork() system call is not available, Perl can be built to emulate fork() in the Perl interpreter. The emulation is designed, at the level of the Perl program, to be as compatible as possible with the &quot;Unix&quot; fork(). However it has limitations that have to be considered in code intended to be portable. See &lt;a href=&quot;../perlfork&quot;&gt;perlfork&lt;/a&gt; for more details.</source>
          <target state="translated">fork () 시스템 호출을 사용할 수없는 Windows와 같은 일부 플랫폼에서는 Perl 인터프리터에서 fork ()를 에뮬레이트하도록 Perl을 빌드 할 수 있습니다. 에뮬레이션은 Perl 프로그램 레벨에서 &quot;Unix&quot;fork ()와 최대한 호환되도록 설계되었습니다. 그러나 이식성이 뛰어난 코드에서는 고려해야 할 한계가 있습니다. 자세한 내용은 &lt;a href=&quot;../perlfork&quot;&gt;perlfork&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="27073e810409a02dd0f24c371c3bfbfa303200d5" translate="yes" xml:space="preserve">
          <source>On some platforms such as Windows, where the fork() system call is not available, Perl can be built to emulate fork() in the Perl interpreter. The emulation is designed, at the level of the Perl program, to be as compatible as possible with the &quot;Unix&quot; fork(). However it has limitations that have to be considered in code intended to be portable. See &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt; for more details.</source>
          <target state="translated">fork () 시스템 호출을 사용할 수없는 Windows와 같은 일부 플랫폼에서는 Perl 인터프리터에서 fork ()를 에뮬레이트하도록 Perl을 빌드 할 수 있습니다. 에뮬레이션은 Perl 프로그램 레벨에서 &quot;Unix&quot;fork ()와 최대한 호환되도록 설계되었습니다. 그러나 이식성이 뛰어난 코드에서는 고려해야 할 한계가 있습니다. 자세한 내용은 &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8ed99749e4754bfa5b0b973c5aff98a5ab4786e4" translate="yes" xml:space="preserve">
          <source>On some platforms the thread-safe library interfaces may fail if the result buffer is too small (for example the user group databases may be rather large, and the reentrant interfaces may have to carry around a full snapshot of those databases). Perl will start with a small buffer, but keep retrying and growing the result buffer until the result fits. If this limitless growing sounds bad for security or memory consumption reasons you can recompile Perl with &lt;code&gt;PERL_REENTRANT_MAXSIZE&lt;/code&gt; defined to the maximum number of bytes you will allow.</source>
          <target state="translated">일부 플랫폼에서 결과 버퍼가 너무 작은 경우 스레드 안전 라이브러리 인터페이스가 실패 할 수 있습니다 (예를 들어, 사용자 그룹 데이터베이스가 너무 클 수 있으며 재진입 인터페이스가 해당 데이터베이스의 전체 스냅 샷을 수행해야 할 수도 있음). Perl은 작은 버퍼로 시작하지만 결과가 맞을 때까지 계속 재 시도하고 결과 버퍼를 증가시킵니다. 보안이나 메모리 소비로 인해 무한한 증가하는 소리가 &lt;code&gt;PERL_REENTRANT_MAXSIZE&lt;/code&gt; 를 허용 된 최대 바이트 수로 정의하여 Perl을 다시 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79a433ae6e8abc1654ff92b55b4f90deb9b64777" translate="yes" xml:space="preserve">
          <source>On some platforms, Windows for example, all allocated memory owned by a thread is deallocated when that thread ends. So if you need that not to happen, you need to use the shared memory functions, such as &lt;code&gt;&lt;a href=&quot;#savesharedpv&quot;&gt;savesharedpv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">예를 들어 Windows와 같은 일부 플랫폼에서는 스레드가 소유 한 모든 할당 된 메모리가 해당 스레드가 종료 될 때 할당이 해제됩니다. 따라서이를 수행하지 않으려면 &lt;code&gt;&lt;a href=&quot;#savesharedpv&quot;&gt;savesharedpv&lt;/a&gt;&lt;/code&gt; 와 같은 공유 메모리 기능을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5a5fee577d9d0e5cea7ff481ecfa7871d14cc642" translate="yes" xml:space="preserve">
          <source>On some platforms, Windows for example, all allocated memory owned by a thread is deallocated when that thread ends. So if you need that not to happen, you need to use the shared memory functions, such as &lt;code&gt;&lt;a href=&quot;#savesharedpvn&quot;&gt;savesharedpvn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">예를 들어 Windows와 같은 일부 플랫폼에서는 스레드가 소유 한 모든 할당 된 메모리가 해당 스레드가 종료 될 때 할당이 해제됩니다. 따라서 필요하지 않은 경우 &lt;code&gt;&lt;a href=&quot;#savesharedpvn&quot;&gt;savesharedpvn&lt;/a&gt;&lt;/code&gt; 과 같은 공유 메모리 기능을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="96135c965e974cf2dcbb35a5a0a72331dbb017cf" translate="yes" xml:space="preserve">
          <source>On some platforms, Windows for example, all allocated memory owned by a thread is deallocated when that thread ends. So if you need that not to happen, you need to use the shared memory functions, such as &lt;code&gt;&lt;a href=&quot;#savesharedsvpv&quot;&gt;savesharedsvpv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">예를 들어 Windows와 같은 일부 플랫폼에서는 스레드가 소유 한 모든 할당 된 메모리가 해당 스레드가 종료 될 때 할당이 해제됩니다. 따라서이를 수행하지 않으려면 &lt;code&gt;&lt;a href=&quot;#savesharedsvpv&quot;&gt;savesharedsvpv&lt;/a&gt;&lt;/code&gt; 와 같은 공유 메모리 기능을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a47d30d42c677c2e62622d2c25ff6400601837c5" translate="yes" xml:space="preserve">
          <source>On some platforms, for example Windows NT, it is not possible to unlink an open file (the file must be closed first). On those platforms, the actual unlinking is deferred until the program ends and good status is returned. A check is still performed to make sure that the filehandle and filename are pointing to the same thing (but not at the time the end block is executed since the deferred removal may not have access to the filehandle).</source>
          <target state="translated">Windows NT와 같은 일부 플랫폼에서는 열린 파일을 링크 해제 할 수 없습니다 (파일을 먼저 닫아야합니다). 해당 플랫폼에서 실제 연결 해제는 프로그램이 종료되고 정상 상태가 반환 될 때까지 지연됩니다. 파일 핸들과 파일 이름이 동일한 것을 가리키고 있는지 확인하기 위해 여전히 검사가 수행됩니다 (그러나 지연 제거가 파일 핸들에 액세스 할 수 없기 때문에 종료 블록이 실행될 때가 아님).</target>
        </trans-unit>
        <trans-unit id="9e21af4bec3442feba775d62193829f8b7a0c4e5" translate="yes" xml:space="preserve">
          <source>On some platforms, it might not be possible to destroy</source>
          <target state="translated">일부 플랫폼에서는 파괴가 불가능할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="b340b3bd6640d116c671c5bca7f5a658b943c207" translate="yes" xml:space="preserve">
          <source>On some platforms, this also makes Perl append suffixes to the filename while searching for it. For example, on Win32 platforms, the &quot;.bat&quot; and &quot;.cmd&quot; suffixes are appended if a lookup for the original name fails, and if the name does not already end in one of those suffixes. If your Perl was compiled with &lt;code&gt;DEBUGGING&lt;/code&gt; turned on, using the &lt;b&gt;-Dp&lt;/b&gt; switch to Perl shows how the search progresses.</source>
          <target state="translated">일부 플랫폼에서는 검색시 파일 이름에 접미사를 추가 할 수도 있습니다. 예를 들어 Win32 플랫폼에서 &quot;.bat&quot;및 &quot;.cmd&quot;접미사는 원래 이름을 찾지 못하면 이름이 해당 접미사 중 하나로 끝나지 않은 경우에 추가됩니다. &lt;b&gt;DEBUGGING을&lt;/b&gt; 켠 &lt;code&gt;DEBUGGING&lt;/code&gt; Perl을 컴파일 한 경우 &lt;b&gt;-Dp&lt;/b&gt; 스위치를 Perl로 사용 하면 검색 진행 방법이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e74540fb7a91002e20c8eda026f9bf8b28624a25" translate="yes" xml:space="preserve">
          <source>On some systems (in general, DOS- and Windows-based systems) binmode() is necessary when you're not working with a text file. For the sake of portability it is a good idea always to use it when appropriate, and never to use it when it isn't appropriate. Also, people can set their I/O to be by default UTF8-encoded Unicode, not bytes.</source>
          <target state="translated">일부 시스템 (일반적으로 DOS 및 Windows 기반 시스템)에서 binmode ()는 텍스트 파일로 작업하지 않을 때 필요합니다. 이식성을 위해 항상 적절한 경우에는 사용하고, 적절하지 않은 경우에는 사용하지 않는 것이 좋습니다. 또한 사람들은 기본적으로 I / O를 바이트가 아닌 UTF8로 인코딩 된 유니 코드로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bae1ed91e60744c25391f2c5a28e8865cb837e1c" translate="yes" xml:space="preserve">
          <source>On some systems, for an IO::Socket object created with new_from_fd(), or created with accept() from such an object, the protocol(), sockdomain() and socktype() methods may return undef.</source>
          <target state="translated">일부 시스템에서 new_from_fd ()로 작성되거나 그러한 오브젝트에서 accept ()로 작성되는 IO :: Socket 오브젝트의 경우 protocol (), sockdomain () 및 socktype () 메소드가 undef를 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cb77e1072ab2963baa8f6d218988c1f72414bff" translate="yes" xml:space="preserve">
          <source>On some systems, the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module's &lt;code&gt;strftime()&lt;/code&gt; function has been extended in a non-standard way to use a &lt;code&gt;%C&lt;/code&gt; format, which they sometimes claim is the &quot;century&quot;. It isn't, because on most such systems, this is only the first two digits of the four-digit year, and thus cannot be used to determine reliably the current century or millennium.</source>
          <target state="translated">일부 시스템에서 &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; 모듈의 &lt;code&gt;strftime()&lt;/code&gt; 함수는 &lt;code&gt;%C&lt;/code&gt; 형식 을 사용하기 위해 비표준 방식으로 확장되어 때로는 &quot;세기&quot;라고 주장합니다. 대부분의 그러한 시스템에서 이것은 4 자리 연도의 처음 두 자리에 불과하므로 현재 세기 나 밀레니엄을 확실하게 결정하는 데 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9a2307b9852232321e1093b21cd83d1ba46b51a6" translate="yes" xml:space="preserve">
          <source>On some systems, there can be cooperative and preemptive threads running simultaneously. (Threads running with realtime priorities often behave cooperatively, for example, while threads running at normal priorities behave preemptively.)</source>
          <target state="translated">일부 시스템에서는 협력 및 선점 스레드가 동시에 실행될 수 있습니다. (예를 들어, 실시간 우선 순위로 실행되는 스레드는 종종 협력 적으로 동작하지만, 일반 우선 순위로 실행되는 스레드는 선제 적으로 동작합니다.)</target>
        </trans-unit>
        <trans-unit id="14dcaed53f17e703b8cfce8077083c7079226d84" translate="yes" xml:space="preserve">
          <source>On some systems, you may have to change single-quotes to double ones, which you must</source>
          <target state="translated">일부 시스템에서는 작은 따옴표를 큰 따옴표로 변경해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a73b71b53a0ef6fd5b9c990fee1a5a53d7f99a60" translate="yes" xml:space="preserve">
          <source>On success in a list context, an array of 3 elements is returned. The elements are:</source>
          <target state="translated">리스트 컨텍스트에서 성공하면 3 개의 요소 배열이 리턴됩니다. 요소는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="104cbe85a4799563175bc8875552e7ec3d9444ff" translate="yes" xml:space="preserve">
          <source>On success in a list context, an array of 6 elements is returned. The elements are:</source>
          <target state="translated">리스트 컨텍스트에서 성공하면 6 개의 요소 배열이 리턴됩니다. 요소는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bb19677ff47ab7a0061dc31fa21208b0fdd0ce0e" translate="yes" xml:space="preserve">
          <source>On success, $decoder is an object that is documented in &lt;a href=&quot;encoding&quot;&gt;Encode::Encoding&lt;/a&gt;. So you can now do this;</source>
          <target state="translated">성공하면 $ decoder는 &lt;a href=&quot;encoding&quot;&gt;Encode :: Encoding에&lt;/a&gt; 문서화 된 객체입니다 . 이제이 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ed1d2d6abe6133cffe9d52759b8403cf251f405" translate="yes" xml:space="preserve">
          <source>On success, the autodying form of &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; returns the</source>
          <target state="translated">성공하면 자동 염색 형식의 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 이</target>
        </trans-unit>
        <trans-unit id="555bab907001ef6e8e0bb6e66b34e7245218e3f9" translate="yes" xml:space="preserve">
          <source>On systems that do not support the HIGH or MEDIUM safety levels (for example Win NT or OS/2) any attempt to change the level will be ignored. The decision to ignore rather than raise an exception allows portable programs to be written with high security in mind for the systems that can support this without those programs failing on systems where the extra tests are irrelevant.</source>
          <target state="translated">HIGH 또는 MEDIUM 안전 수준 (예 : Win NT 또는 OS / 2)을 지원하지 않는 시스템에서는 수준을 변경하려는 시도가 무시됩니다. 예외를 제기하지 않고 무시하기로 결정하면 추가 테스트와 관련이없는 시스템에서 이러한 프로그램이 실패하지 않고이를 지원할 수있는 시스템에 대해 이식성이 높은 프로그램을 염두에두고 작성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c0c64b8ddf70f7334be3908bef0a4e5be9026f3" translate="yes" xml:space="preserve">
          <source>On systems that don't have locales, this pragma will cause your operations to behave as if in the &quot;C&quot; locale; attempts to change the locale will fail.</source>
          <target state="translated">로케일이없는 시스템에서이 pragma는 &quot;C&quot;로케일 에서처럼 조작이 작동하도록합니다. 로케일 변경 시도가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="8a74a95b0c966e10aac8d77a4f0a3bf544781a21" translate="yes" xml:space="preserve">
          <source>On systems that have a grammar that indicates filenames, this ignores the $base filename. Otherwise all path components are assumed to be directories.</source>
          <target state="translated">파일 이름을 나타내는 문법이있는 시스템에서는 $ base 파일 이름을 무시합니다. 그렇지 않으면 모든 경로 구성 요소가 디렉토리 인 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="1b51da93b22332f93d96c5b573c9ad75ab82f7bf" translate="yes" xml:space="preserve">
          <source>On systems that have a grammar that indicates filenames, this ignores the &lt;code&gt;$base&lt;/code&gt; filename as well. Otherwise all path components are assumed to be directories.</source>
          <target state="translated">파일 이름을 나타내는 문법이있는 시스템에서는 &lt;code&gt;$base&lt;/code&gt; 파일 이름도 무시합니다 . 그렇지 않으면 모든 경로 구성 요소가 디렉토리 인 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="5314c4a5a0cc48c834a98edadeb967581bfc1cbf" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, that flag is set on all newly opened file descriptors whose &lt;code&gt;&lt;a href=&quot;fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt;s are</source>
          <target state="translated">파일에서 close-on-exec 플래그를 지원하는 시스템에서 해당 플래그는 &lt;code&gt;&lt;a href=&quot;fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; 가 있는 새로 열린 모든 파일 설명자에 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="be056ae4f4d92fcc824ea5af426faa5948d961c7" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, that flag is set on all newly opened file descriptors whose &lt;code&gt;&lt;a href=&quot;functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt;s are</source>
          <target state="translated">파일에서 close-on-exec 플래그를 지원하는 시스템에서 해당 플래그는 &lt;code&gt;&lt;a href=&quot;functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; 가 있는 새로 열린 모든 파일 설명자에 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="3fcf7eb3896f4c5961c6c4a30af97fd660da9d5d" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptor as determined by the value of &lt;code&gt;$^F&lt;/code&gt; . See &lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">파일에서 close-on-exec 플래그를 지원하는 시스템에서 &lt;code&gt;$^F&lt;/code&gt; 값에 따라 새로 열린 파일 디스크립터에 대해 플래그가 설정됩니다 . &lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;perlvar의 $ ^ F를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c665037f5c6992c82bd182869050b43d00b7e424" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptor as determined by the value of &lt;code&gt;$^F&lt;/code&gt; . See &lt;a href=&quot;perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">파일에서 close-on-exec 플래그를 지원하는 시스템에서 &lt;code&gt;$^F&lt;/code&gt; 값에 따라 새로 열린 파일 디스크립터에 대해 플래그가 설정됩니다 . &lt;a href=&quot;perlvar#%24%5eF&quot;&gt;perlvar의 $ ^ F를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a490a64d93357b4e803f1bde203444d3253ea771" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptor, as determined by the value of $^F. See &lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">파일에서 실행시 닫기 플래그를 지원하는 시스템에서 $ ^ F 값에 따라 새로 열린 파일 설명자에 대해 플래그가 설정됩니다. &lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;perlvar의 $ ^ F를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a8889b4502c97331fb6c0d71d79b94f89a2ce179" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptor, as determined by the value of $^F. See &lt;a href=&quot;perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">파일에서 실행시 닫기 플래그를 지원하는 시스템에서 $ ^ F 값에 따라 새로 열린 파일 설명자에 대해 플래그가 설정됩니다. &lt;a href=&quot;perlvar#%24%5eF&quot;&gt;perlvar의 $ ^ F를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="901c01459d3ad6fdd533264983a881490e329c6b" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptors, as determined by the value of $^F. See &lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">파일에서 close-on-exec 플래그를 지원하는 시스템에서 $ ^ F 값에 따라 새로 열린 파일 디스크립터에 대해 플래그가 설정됩니다. &lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;perlvar의 $ ^ F를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b4b0eeffda71eae98ca0b23d4d9a435052a31c58" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptors, as determined by the value of $^F. See &lt;a href=&quot;perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">파일에서 close-on-exec 플래그를 지원하는 시스템에서 $ ^ F 값에 따라 새로 열린 파일 디스크립터에 대해 플래그가 설정됩니다. &lt;a href=&quot;perlvar#%24%5eF&quot;&gt;perlvar의 $ ^ F를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c0bcb70dd655374823428e8ecf318b875be23f0d" translate="yes" xml:space="preserve">
          <source>On systems that support a real flock(2), locks are inherited across fork() calls, whereas those that must resort to the more capricious fcntl(2) function lose their locks, making it seriously harder to write servers.</source>
          <target state="translated">실제 flock (2)을 지원하는 시스템에서는 잠금이 fork () 호출에서 상속되는 반면, 더 변덕스러운 fcntl (2) 함수에 의존해야하는 잠금은 잠금을 잃어 서버를 작성하기가 훨씬 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="92426fd5bb12f295ba78cf2e855950f52eab1f1b" translate="yes" xml:space="preserve">
          <source>On systems that support fchdir(2), you may pass a filehandle or directory handle as the argument. On systems that don't support fchdir(2), passing handles raises an exception.</source>
          <target state="translated">fchdir (2)를 지원하는 시스템에서는 파일 핸들 또는 디렉토리 핸들을 인수로 전달할 수 있습니다. fchdir (2)를 지원하지 않는 시스템에서 핸들을 전달하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="92172c92aed2c4eacbbf108b43a01fa41c1e7227" translate="yes" xml:space="preserve">
          <source>On systems that support fchmod(2), you may pass filehandles among the files. On systems that don't support fchmod(2), passing filehandles raises an exception. Filehandles must be passed as globs or glob references to be recognized; barewords are considered filenames.</source>
          <target state="translated">fchmod (2)를 지원하는 시스템에서는 파일간에 파일 핸들을 전달할 수 있습니다. fchmod (2)를 지원하지 않는 시스템에서 파일 핸들을 전달하면 예외가 발생합니다. 파일 핸들은 인식하기 위해 glob 또는 glob 참조로 전달되어야합니다. 베어 워드는 파일 이름으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="dc52e8f7e1c0866f647ccf5e1cd248ecabff8b5f" translate="yes" xml:space="preserve">
          <source>On systems that support fchown(2), you may pass filehandles among the files. On systems that don't support fchown(2), passing filehandles raises an exception. Filehandles must be passed as globs or glob references to be recognized; barewords are considered filenames.</source>
          <target state="translated">fchown (2)을 지원하는 시스템에서는 파일 사이에 파일 핸들을 전달할 수 있습니다. fchown (2)을 지원하지 않는 시스템에서 파일 핸들을 전달하면 예외가 발생합니다. 파일 핸들은 인식하기 위해 glob 또는 glob 참조로 전달되어야합니다. 베어 워드는 파일 이름으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="9d32f7bede11ac1c00998cc26b587f02c25e363b" translate="yes" xml:space="preserve">
          <source>On systems that support futimes(2), you may pass filehandles among the files. On systems that don't support futimes(2), passing filehandles raises an exception. Filehandles must be passed as globs or glob references to be recognized; barewords are considered filenames.</source>
          <target state="translated">futimes (2)를 지원하는 시스템에서는 파일간에 파일 핸들을 전달할 수 있습니다. futimes (2)를 지원하지 않는 시스템에서 파일 핸들을 전달하면 예외가 발생합니다. 파일 핸들은 인식하기 위해 glob 또는 glob 참조로 전달되어야합니다. 베어 워드는 파일 이름으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="c71329e94ef821ac647632fa2fb53326dd2a9466" translate="yes" xml:space="preserve">
          <source>On systems that supported it, older versions of Perl used the SA_RESTART flag when installing %SIG handlers. This meant that restartable system calls would continue rather than returning when a signal arrived. In order to deliver deferred signals promptly, Perl 5.8.0 and later do</source>
          <target state="translated">이를 지원하는 시스템에서 이전 버전의 Perl은 % SIG 핸들러를 설치할 때 SA_RESTART 플래그를 사용했습니다. 즉, 신호가 도착했을 때 다시 시작하지 않고 재시작 가능한 시스템 호출이 계속됩니다. 지연된 신호를 즉시 전달하기 위해 Perl 5.8.0 이상은</target>
        </trans-unit>
        <trans-unit id="6ba77bd32e9b25ffdeddd2abe71a6e9ea02320ab" translate="yes" xml:space="preserve">
          <source>On systems traditionally bereft of a usable &lt;b&gt;man&lt;/b&gt; command, the debugger invokes &lt;b&gt;perldoc&lt;/b&gt;. Occasionally this determination is incorrect due to recalcitrant vendors or rather more felicitously, to enterprising users. If you fall into either category, just manually set the $DB::doccmd variable to whatever viewer to view the Perl documentation on your system. This may be set in an rc file, or through direct assignment. We're still waiting for a working example of something along the lines of:</source>
          <target state="translated">전통적으로 사용 가능한 &lt;b&gt;man&lt;/b&gt; 명령을 버린 시스템 에서 디버거는 &lt;b&gt;perldoc을&lt;/b&gt; 호출합니다 . 때때로이 결정은 재 시도적인 공급 업체로 인해 또는 진취적인 사용자에게보다 선의로 인해 올바르지 않습니다. 두 범주 중 하나에 해당하는 경우 $ DB :: doccmd 변수를 시스템의 Perl 문서를 볼 수있는 뷰어로 수동 설정하십시오. 이것은 rc 파일 또는 직접 할당을 통해 설정 될 수 있습니다. 우리는 여전히 다음 라인을 따라 작동하는 예제를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="495743307752ec1e7f711d11bd0bef034af0b675" translate="yes" xml:space="preserve">
          <source>On systems which do support negative epoch values, this module should be able to cope with dates before the start of the epoch, down the minimum value of time_t for the system.</source>
          <target state="translated">음의 에포크 값을 지원하는 시스템에서이 모듈은 에포크가 시작되기 전에 시스템의 최소 time_t 값을 줄인 날짜를 처리 할 수 ​​있어야합니다.</target>
        </trans-unit>
        <trans-unit id="46c423b9491070d51507de37df7f4e753a419998" translate="yes" xml:space="preserve">
          <source>On systems with restrictions on file name length, the file corresponding to a subroutine may have a shorter name that the routine itself. This can lead to conflicting file names. The</source>
          <target state="translated">파일 이름 길이가 제한된 시스템에서 서브 루틴에 해당하는 파일은 루틴 자체보다 짧은 이름을 가질 수 있습니다. 이로 인해 파일 이름이 충돌 할 수 있습니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="fec43c22ce98f30270ab97bbbb4fe9d6075857b3" translate="yes" xml:space="preserve">
          <source>On systems with the concept of a network share (currently only Windows) returns the sharename from a &lt;a href=&quot;file://&quot;&gt;file:////&lt;/a&gt; url. On other operating systems returns empty.</source>
          <target state="translated">네트워크 공유 개념 (현재 Windows 만 해당)이있는 시스템에서는 &lt;a href=&quot;file://&quot;&gt;file : ////&lt;/a&gt; url 에서 공유 이름을 반환합니다 . 다른 운영 체제에서는 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="928cc7ef7cb478fdbb60e26c8543bd66bba1f884" translate="yes" xml:space="preserve">
          <source>On systems with the concept of volume, if &lt;code&gt;$path&lt;/code&gt; and &lt;code&gt;$base&lt;/code&gt; appear to be on two different volumes, we will not attempt to resolve the two paths, and we will instead simply return &lt;code&gt;$path&lt;/code&gt; . Note that previous versions of this module ignored the volume of &lt;code&gt;$base&lt;/code&gt; , which resulted in garbage results part of the time.</source>
          <target state="translated">볼륨 개념이있는 시스템에서 &lt;code&gt;$path&lt;/code&gt; 와 &lt;code&gt;$base&lt;/code&gt; 가 서로 다른 두 볼륨에있는 경우 두 경로를 확인하지 않고 대신 &lt;code&gt;$path&lt;/code&gt; 를 반환 합니다 . 이 모듈의 이전 버전은 &lt;code&gt;$base&lt;/code&gt; 볼륨을 무시 하여 시간의 일부 가비지 결과를 초래했습니다.</target>
        </trans-unit>
        <trans-unit id="04b62c831c8eef6cc7d4b1d7cdb6bf880f9b84f3" translate="yes" xml:space="preserve">
          <source>On text fields the caret enables a kind of fill mode. Instead of an arbitrary expression, the value supplied must be a scalar variable that contains a text string. Perl puts the next portion of the text into the field, and then chops off the front of the string so that the next time the variable is referenced, more of the text can be printed. (Yes, this means that the variable itself is altered during execution of the write() call, and is not restored.) The next portion of text is determined by a crude line-breaking algorithm. You may use the carriage return character (&lt;code&gt;\r&lt;/code&gt; ) to force a line break. You can change which characters are legal to break on by changing the variable &lt;code&gt;$:&lt;/code&gt; (that's $FORMAT_LINE_BREAK_CHARACTERS if you're using the English module) to a list of the desired characters.</source>
          <target state="translated">텍스트 필드에서 캐럿은 일종의 채우기 모드를 활성화합니다. 임의의 표현식 대신 제공된 값은 텍스트 문자열을 포함하는 스칼라 변수 여야합니다. Perl은 텍스트의 다음 부분을 필드에 넣은 후 다음에 변수를 참조 할 때 더 많은 텍스트를 인쇄 할 수 있도록 문자열의 앞면을 잘라냅니다. (예, 이것은 변수 자체가 write () 호출을 실행하는 동안 변경되고 복원되지 않음을 의미합니다.) 텍스트의 다음 부분은 원치 않는 줄 바꿈 알고리즘에 의해 결정됩니다. 캐리지 리턴 문자 ( &lt;code&gt;\r&lt;/code&gt; )를 사용하여 줄 바꿈을 강제 할 수 있습니다. 변수 &lt;code&gt;$:&lt;/code&gt; 를 변경하여 구분할 수있는 문자를 변경할 수 있습니다 . (영어 모듈을 사용하는 경우 $ FORMAT_LINE_BREAK_CHARACTERS)를 원하는 문자 목록에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="c0193cc78fe98d1b4b454c6f69412908ead97760" translate="yes" xml:space="preserve">
          <source>On the AS/400, if PERL5 is in your library list, you may need to wrap your Perl scripts in a CL procedure to invoke them like so:</source>
          <target state="translated">AS / 400에서 PERL5가 라이브러리 목록에 있으면 Perl 스크립트를 CL 프로 시저로 랩핑하여 다음과 같이 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="ea65f5f2a1cec2b70340514d27743f128cc959b6" translate="yes" xml:space="preserve">
          <source>On the given program identified by &lt;code&gt;program_name&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;program_name&lt;/code&gt; 으로 식별 된 주어진 프로그램에서 .</target>
        </trans-unit>
        <trans-unit id="5c9fcecabc9c2ff5c185e1af9b86fe28cd4ccda1" translate="yes" xml:space="preserve">
          <source>On the mainframe Perl currently works under the &quot;Unix system services for OS/390&quot; (formerly known as OpenEdition), VM/ESA OpenEdition, or the BS200 POSIX-BC system (BS2000 is supported in Perl 5.6 and greater). See &lt;a href=&quot;perlos390&quot;&gt;perlos390&lt;/a&gt; for details. Note that for OS/400 there is also a port of Perl 5.8.1/5.10.0 or later to the PASE which is ASCII-based (as opposed to ILE which is EBCDIC-based), see &lt;a href=&quot;perlos400&quot;&gt;perlos400&lt;/a&gt;.</source>
          <target state="translated">메인 프레임에서 Perl은 현재 &quot;OS / 390 용 Unix 시스템 서비스&quot;(이전의 OpenEdition), VM / ESA OpenEdition 또는 BS200 POSIX-BC 시스템 (BS2000은 Perl 5.6 이상에서 지원됨)에서 작동합니다. 자세한 내용은 &lt;a href=&quot;perlos390&quot;&gt;perlos390&lt;/a&gt; 을 참조하십시오. OS / 400의 경우 ASCII 기반 인 PASE에 대한 Perl 5.8.1 / 5.10.0 이상의 포트도 있습니다 (EBCDIC 기반 인 ILE와 반대) . &lt;a href=&quot;perlos400&quot;&gt;perlos400을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="580309d3af9907826e397d1c3342546e17a8ad3c" translate="yes" xml:space="preserve">
          <source>On the opposite end of the scale, a declaration like</source>
          <target state="translated">스케일의 반대쪽 끝에서 다음과 같은 선언</target>
        </trans-unit>
        <trans-unit id="30429117a84b2dd407e0605edcb4b807f19cd366" translate="yes" xml:space="preserve">
          <source>On the other hand, if you want the other meaning, you can do this:</source>
          <target state="translated">반면에 다른 의미를 원하면 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbae3feec67f27fa104cf2845f242f528c54850f" translate="yes" xml:space="preserve">
          <source>On the other hand, if you were actually hoping to treat the array element as a list, you need to look into how references work, because Perl will not magically convert between scalars and lists for you. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">반면에 실제로 배열 요소를 목록으로 취급하려면 Perl이 스칼라와 목록을 마술처럼 변환하지 않기 때문에 참조가 작동하는 방식을 살펴 봐야합니다. &lt;a href=&quot;perlref&quot;&gt;perlref를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ce76eb877363ead375654de95e60f5e7b6c574b5" translate="yes" xml:space="preserve">
          <source>On the other hand, if you were actually hoping to treat the hash element as a list, you need to look into how references work, because Perl will not magically convert between scalars and lists for you. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">반면에 실제로 해시 요소를 목록으로 취급하려면 Perl이 스칼라와 목록을 마술처럼 변환하지 않기 때문에 참조가 작동하는 방식을 살펴 봐야합니다. &lt;a href=&quot;perlref&quot;&gt;perlref를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="528cd15a9b0aff8a5cdc97823c4262e5cf5bb2ab" translate="yes" xml:space="preserve">
          <source>On the other hand, mixing various national standard encodings automagically works unless $data is too short to allow for guessing.</source>
          <target state="translated">반면 $ data가 너무 짧아 추측하기 어려운 경우가 아니라면 다양한 국가 표준 인코딩을 혼합하면 자동으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="095e1a5231bfc256caf5b97c9e59036a8cd94e78" translate="yes" xml:space="preserve">
          <source>On the other hand, sometimes you want to clobber whatever might already be there. To empty out a file before you start writing to it, you can open it in write-only mode:</source>
          <target state="translated">반면에 때로는 이미 존재하는 모든 것을 클로버하고 싶을 때가 있습니다. 파일을 쓰기 전에 파일을 비우려면 쓰기 전용 모드로 파일을 열 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94024e45d5031c319fa3ba71f3df1c69292913dd" translate="yes" xml:space="preserve">
          <source>On the other hand:</source>
          <target state="translated">반면에 :</target>
        </trans-unit>
        <trans-unit id="f18fa46000a23ad2307a5bee120c399fc4cc324f" translate="yes" xml:space="preserve">
          <source>On the right side of a list operator, the comma has very low precedence, such that it controls all comma-separated expressions found there. The only operators with lower precedence are the logical operators &lt;code&gt;&quot;and&quot;&lt;/code&gt; , &lt;code&gt;&quot;or&quot;&lt;/code&gt; , and &lt;code&gt;&quot;not&quot;&lt;/code&gt; , which may be used to evaluate calls to list operators without the need for parentheses:</source>
          <target state="translated">목록 연산자의 오른쪽에서 쉼표는 우선 순위가 매우 낮아서 쉼표로 구분 된 모든 표현식을 제어합니다. 우선 순위가 낮은 유일한 연산자는 논리 연산자 &lt;code&gt;&quot;and&quot;&lt;/code&gt; , &lt;code&gt;&quot;or&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;not&quot;&lt;/code&gt; 이며 괄호없이 연산자를 나열하기위한 호출을 평가하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0b2c5bcb8fba3a9644276ad63b66e732faef04f" translate="yes" xml:space="preserve">
          <source>On these platforms, bear in mind that the EBCDIC character set may have an effect on what happens with some Perl functions (such as &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;), as well as bit-fiddling with ASCII constants using operators like &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;, not to mention dealing with socket interfaces to ASCII computers (see &lt;a href=&quot;#Newlines&quot;&gt;Newlines&lt;/a&gt;).</source>
          <target state="translated">이러한 플랫폼에서 EBCDIC 문자 세트는 일부 Perl 기능 (예 : &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; )에서 발생하는 일에 영향을 줄 수 있으며 &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;|&lt;/code&gt; 와 같은 연산자를 사용하는 ASCII 상수 ASCII 컴퓨터에 대한 소켓 인터페이스를 다루는 것은 말할 것도 없습니다 ( &lt;a href=&quot;#Newlines&quot;&gt;Newlines&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="bf1c918758fe737aef37e1c0ba64400f9f7705ae" translate="yes" xml:space="preserve">
          <source>On those platforms and compilers where &lt;code&gt;bool&lt;/code&gt; really is a boolean (C++, C99), it is easy to forget the cast. You can force &lt;code&gt;bool&lt;/code&gt; to be a &lt;code&gt;char&lt;/code&gt; by compiling with &lt;code&gt;-Accflags=-DPERL_BOOL_AS_CHAR&lt;/code&gt; . You may also wish to run &lt;code&gt;Configure&lt;/code&gt; with something like</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; 이 실제로 부울 (C ++, C99) 인 플랫폼 및 컴파일러에서는 캐스트를 잊어 버리기 쉽습니다. 당신은 강제 할 수 &lt;code&gt;bool&lt;/code&gt; 로 &lt;code&gt;char&lt;/code&gt; 함께 컴파일하여 &lt;code&gt;-Accflags=-DPERL_BOOL_AS_CHAR&lt;/code&gt; . 다음과 같은 방법으로 &lt;code&gt;Configure&lt;/code&gt; 를 실행할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="750180603d4fade1f60619d413443d4388791bcb" translate="yes" xml:space="preserve">
          <source>On threaded builds a regexp may need to be duplicated so that the pattern can be used by multiple threads. This routine is expected to handle the duplication of any private data pointed to by the &lt;code&gt;pprivate&lt;/code&gt; member of the &lt;code&gt;regexp&lt;/code&gt; structure. It will be called with the preconstructed new &lt;code&gt;regexp&lt;/code&gt; structure as an argument, the &lt;code&gt;pprivate&lt;/code&gt; member will point at the &lt;b&gt;old&lt;/b&gt; private structure, and it is this routine's responsibility to construct a copy and return a pointer to it (which Perl will then use to overwrite the field as passed to this routine.)</source>
          <target state="translated">스레드 빌드에서 패턴을 여러 스레드에서 사용할 수 있도록 정규 표현식을 복제해야 할 수도 있습니다. 이 루틴은 &lt;code&gt;regexp&lt;/code&gt; 구조 의 &lt;code&gt;pprivate&lt;/code&gt; 구성원이 가리키는 개인 데이터의 중복을 처리해야합니다 . 사전 구성된 새 &lt;code&gt;regexp&lt;/code&gt; 구조를 인수로 호출하고 &lt;code&gt;pprivate&lt;/code&gt; 구성원은 &lt;b&gt;이전&lt;/b&gt; 개인 구조를 가리키며 사본을 구성하고 포인터를 리턴하는 것은이 루틴의 책임입니다. 이 루틴에 전달 된 필드).&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c8ce1f6dab9f2ca8a499735e7d64c50092c9a849" translate="yes" xml:space="preserve">
          <source>On unthreaded builds this field doesn't exist.</source>
          <target state="translated">스레드되지 않은 빌드에서는이 필드가 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="baf07ba18b50ccd1689ea2941fb77a3117773a24" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;test_out&lt;/code&gt; or &lt;code&gt;test_err&lt;/code&gt; (or &lt;code&gt;test_fail&lt;/code&gt; or &lt;code&gt;test_diag&lt;/code&gt; ) have been called, all further output from &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; will be captured by &lt;a href=&quot;tester&quot;&gt;Test::Builder::Tester&lt;/a&gt;. This means that you will not be able perform further tests to the normal output in the normal way until you call &lt;code&gt;test_test&lt;/code&gt; (well, unless you manually meddle with the output filehandles)</source>
          <target state="translated">일단 &lt;code&gt;test_out&lt;/code&gt; 또는 &lt;code&gt;test_err&lt;/code&gt; (또는 &lt;code&gt;test_fail&lt;/code&gt; 또는 &lt;code&gt;test_diag&lt;/code&gt; 이 )가 호출 한 모든 추가 출력 &lt;a href=&quot;../builder&quot;&gt;테스트 :: 빌더&lt;/a&gt; 에 의해 캡처됩니다 &lt;a href=&quot;tester&quot;&gt;테스트 :: 빌더 :: 테스터&lt;/a&gt; . 즉 , &lt;code&gt;test_test&lt;/code&gt; 를 호출 할 때까지 일반적인 방식으로 일반 출력에 대해 추가 테스트를 수행 할 수 없습니다 (출력 파일 핸들을 수동으로 처리하지 않는 한).</target>
        </trans-unit>
        <trans-unit id="9443afa365a30ff5f37332fa968121f2dbb81425" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;test_test&lt;/code&gt; has been run test output will be redirected back to the original filehandles that &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; was connected to (probably STDOUT and STDERR,) meaning any further tests you run will function normally and cause success/errors for &lt;a href=&quot;../harness&quot;&gt;Test::Harness&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;test_test&lt;/code&gt; 가 실행 되면 테스트 출력은 &lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt; 가 연결된 원래 파일 핸들로 다시 리디렉션 되며 (아마도 STDOUT 및 STDERR), 실행하는 추가 테스트가 정상적으로 작동하고 &lt;a href=&quot;../harness&quot;&gt;Test :: Harness에&lt;/a&gt; 대한 성공 / 오류가 발생 함을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="c0908b28a0f268394a7964fa489d2fda27d507a0" translate="yes" xml:space="preserve">
          <source>Once EOF is detected (&lt;code&gt;$status&lt;/code&gt; is zero) the filter will insert an extra line into the source stream. When this extra line is executed it will print a count of the number of substitutions actually made. Note that &lt;code&gt;$status&lt;/code&gt; is set to &lt;code&gt;1&lt;/code&gt; in this case.</source>
          <target state="translated">EOF가 감지되면 ( &lt;code&gt;$status&lt;/code&gt; 가 0 임) 필터는 소스 스트림에 추가 행을 삽입합니다. 이 추가 라인이 실행될 때 실제로 수행 된 대체 수를 인쇄합니다. 참고 &lt;code&gt;$status&lt;/code&gt; 설정되어 &lt;code&gt;1&lt;/code&gt; 이 경우.</target>
        </trans-unit>
        <trans-unit id="48f0ab6402e0ed10a074d92b2f594ddaae93f903" translate="yes" xml:space="preserve">
          <source>Once Perl sees that you need one of these variables anywhere in the program, it provides them on each and every pattern match. That means that on every pattern match the entire string will be copied, part of it to $`, part to $&amp;amp;, and part to $'. Thus the penalty is most severe with long strings and patterns that match often. Avoid $&amp;amp;, $', and $` if you can, but if you can't, once you've used them at all, use them at will because you've already paid the price. Remember that some algorithms really appreciate them. As of the 5.005 release, the $&amp;amp; variable is no longer &quot;expensive&quot; the way the other two are.</source>
          <target state="translated">Perl은 프로그램의 어느 곳에서나 이러한 변수 중 하나가 필요하다는 것을 알게되면 각각의 모든 패턴 일치에 변수를 제공합니다. 즉, 모든 패턴 일치에서 전체 문자열이 복사되어 일부는 $`로, 일부는 $ &amp;amp;로, 그리고 일부는 $ '로 복사됩니다. 따라서 벌칙과 패턴이 자주 일치하는 경우 벌칙이 가장 심각합니다. 가능하면 $ &amp;amp;, $ '및 $`를 피하십시오. 그러나 사용할 수없는 경우, 이미 사용한 후에는 가격을 이미 지불 했으므로 마음대로 사용하십시오. 일부 알고리즘은 정말 감사합니다. 5.005 릴리스에서 $ &amp;amp; 변수는 더 이상 다른 두 가지 방식과 같이 &quot;비싸지 않습니다&quot;.</target>
        </trans-unit>
        <trans-unit id="296ec9cb13f85c2f6eee6c3dfe23452785f51838" translate="yes" xml:space="preserve">
          <source>Once a feature, construct or module has been marked as deprecated, we may remove it from the Perl core. Unsurprisingly, we say we've &lt;b&gt;removed&lt;/b&gt; these things. When a module is removed, it will no longer ship with Perl, but will continue to be available on CPAN.</source>
          <target state="translated">기능, 구조 또는 모듈이 더 이상 사용되지 않는 것으로 표시되면 Perl 코어에서 제거 할 수 있습니다. 당연히, 우리는 이러한 것들을 &lt;b&gt;제거&lt;/b&gt; 했다고 말합니다 . 모듈을 제거하면 더 이상 Perl과 함께 제공되지 않지만 CPAN에서 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7394cfde1fc1b93e93cb9b4f086c54f1b9ffd59b" translate="yes" xml:space="preserve">
          <source>Once a module has been included in the Perl core, however, everyone involved in maintaining Perl should be aware that the module is still the property of the original author unless the original author explicitly gives up their ownership of it. In particular:</source>
          <target state="translated">그러나 모듈이 Perl 코어에 포함되면 Perl 유지 관리에 관련된 모든 사람은 원래 작성자가 명시 적으로 소유권을 포기하지 않는 한 해당 모듈이 여전히 원래 작성자의 자산임을 인식해야합니다. 특히:</target>
        </trans-unit>
        <trans-unit id="395a04379c153d488a5c8556f8b5ec9aaac6c9a5" translate="yes" xml:space="preserve">
          <source>Once a referent has been blessed, the &lt;code&gt;blessed&lt;/code&gt; function from the &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt; core module can tell us its class name. This subroutine returns an object's class when passed an object, and false otherwise.</source>
          <target state="translated">심판이 축복을 받으면 &lt;a href=&quot;scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt; 핵심 모듈 의 &lt;code&gt;blessed&lt;/code&gt; 기능 으로 클래스 이름을 알 수 있습니다. 이 서브 루틴은 객체를 전달할 때 객체의 클래스를 반환하고 그렇지 않으면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="591c19dc13259933f77d04158c9b97cb405eddcb" translate="yes" xml:space="preserve">
          <source>Once a thread is detached, it may not be joined, and any return data that it might have produced (if it was done and waiting for a join) is lost.</source>
          <target state="translated">스레드가 분리되면 결합되지 않을 수 있으며, 스레드가 생성하고 결합을 기다리는 경우 리턴 된 리턴 데이터가 유실됩니다.</target>
        </trans-unit>
        <trans-unit id="12df76345c558476956303e6bd354373a1af6336" translate="yes" xml:space="preserve">
          <source>Once a todo test starts succeeding, simply move it outside the block. When the block is empty, delete it.</source>
          <target state="translated">할일 테스트가 성공하기 시작하면 간단히 블록 밖으로 이동하십시오. 블록이 비어 있으면 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="de1c57e84d4335aa8d593dcd913db4541c9be506" translate="yes" xml:space="preserve">
          <source>Once a variable is removed, its use triggers an error telling you the variable is unsupported.</source>
          <target state="translated">변수가 제거되면 변수를 지원하지 않는다는 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="aeba7900e971ad3f9f9e894e67cc3b717aab109e" translate="yes" xml:space="preserve">
          <source>Once again, &lt;code&gt;module-starter&lt;/code&gt; or &lt;code&gt;h2xs&lt;/code&gt; has done all the work for you. They produce the standard &lt;code&gt;Makefile.PL&lt;/code&gt; you see when you download and install modules, and this produces a Makefile with a &lt;code&gt;dist&lt;/code&gt; target.</source>
          <target state="translated">다시 한번, &lt;code&gt;module-starter&lt;/code&gt; 또는 &lt;code&gt;h2xs&lt;/code&gt; 가 모든 작업을 완료했습니다. 모듈을 다운로드하고 설치할 때 표시 되는 표준 &lt;code&gt;Makefile.PL&lt;/code&gt; 을 생성하며, &lt;code&gt;dist&lt;/code&gt; 대상 이있는 Makefile을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="8b1aff24b00940dd82d1491dbe39c6cb52b648ed" translate="yes" xml:space="preserve">
          <source>Once approved, changes are merged into &lt;a href=&quot;https://github.com/tpf/perlfaq&quot;&gt;https://github.com/tpf/perlfaq&lt;/a&gt;, the repository which drives &lt;a href=&quot;http://learn.perl.org/faq/&quot;&gt;http://learn.perl.org/faq/&lt;/a&gt;, and they are distributed with the next Perl 5 release.</source>
          <target state="translated">승인되면 변경 사항이 &lt;a href=&quot;http://learn.perl.org/faq/&quot;&gt;http://learn.perl.org/faq/&lt;/a&gt; 를 구동하는 저장소 인 &lt;a href=&quot;https://github.com/tpf/perlfaq&quot;&gt;https://github.com/tpf/perlfaq&lt;/a&gt; 에 병합되고 다음 Perl 5 릴리스와 함께 배포됩니다.</target>
        </trans-unit>
        <trans-unit id="2b54e888aa5f3b1e9daaa58b06235556e830e504" translate="yes" xml:space="preserve">
          <source>Once at the command line, type &lt;code&gt;h&lt;/code&gt; for one-page help screen; the rest should be self-explanatory.</source>
          <target state="translated">명령 행에서 한 페이지 도움말 화면에 &lt;code&gt;h&lt;/code&gt; 를 입력 하십시오. 나머지는 설명이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="480a6fac81e70daea3f924bcfe32eba60a95619a" translate="yes" xml:space="preserve">
          <source>Once called the FILE * should</source>
          <target state="translated">FILE *이라고하면</target>
        </trans-unit>
        <trans-unit id="fadbaf9125427892864d707c6d22361430d22b8f" translate="yes" xml:space="preserve">
          <source>Once ended, no more items may be placed in the queue.</source>
          <target state="translated">종료되면 더 이상 항목을 대기열에 넣을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="916fa7b57196ffe55f0094ed9d80bbb62daf5b2c" translate="yes" xml:space="preserve">
          <source>Once mapped, you can treat &lt;code&gt;$string&lt;/code&gt; as you would any other string. Since you don't necessarily have to load the data, mmap-ing can be very fast and may not increase your memory footprint.</source>
          <target state="translated">일단 매핑되면 &lt;code&gt;$string&lt;/code&gt; 을 다른 문자열처럼 취급 할 수 있습니다 . 데이터를 반드시로드 할 필요는 없으므로 mmap-ing이 매우 빠를 수 있으며 메모리 풋 프린트를 늘리지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48df5812892e79e577960bece1b7fde5e79ea047" translate="yes" xml:space="preserve">
          <source>Once miniperl.exe creation is over, run nmake from the NetWare folder. This will build the Perl interpreter for NetWare as</source>
          <target state="translated">miniperl.exe 작성이 끝나면 NetWare 폴더에서 nmake를 실행하십시오. 이것은 NetWare 용 Perl 인터프리터를 다음과 같이 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="f6c4f57a7ab5a360e46162416f69b58e4d7acd9a" translate="yes" xml:space="preserve">
          <source>Once picked, it is important to stick to your version scheme, without reducing the number of digits. This is because &quot;downstream&quot; packagers, such as the FreeBSD ports system, interpret the version numbers in various ways. If you change the number of digits in your version scheme, you can confuse these systems so they get the versions of your module out of order, which is obviously bad.</source>
          <target state="translated">일단 선택하면 자릿수를 줄이지 않고 버전 체계를 고수하는 것이 중요합니다. 이는 FreeBSD 포트 시스템과 같은 &quot;다운 스트림&quot;패키지 프로그램이 다양한 방식으로 버전 번호를 해석하기 때문입니다. 버전 체계에서 자릿수를 변경하면 이러한 시스템을 혼동하여 모듈 버전이 잘못되어 분명히 나쁠 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07633063ecd66c0146fe9d11656fc4703df1f61f" translate="yes" xml:space="preserve">
          <source>Once produced Makefiles for MacOS Classic</source>
          <target state="translated">MacOS Classic 용 Makefile 제작</target>
        </trans-unit>
        <trans-unit id="654d50c5d753e55a4e1dbf0b00907d7f4969d3a9" translate="yes" xml:space="preserve">
          <source>Once registered, there is no mechanism to switch these hooks off, so if that is necessary you will need to do this yourself. An entry in &lt;code&gt;%^H&lt;/code&gt; is probably the best way, so the effect is lexically scoped; however it is also possible to use the &lt;code&gt;BhkDISABLE&lt;/code&gt; and &lt;code&gt;BhkENABLE&lt;/code&gt; macros to temporarily switch entries on and off. You should also be aware that generally speaking at least one scope will have opened before your extension is loaded, so you will see some &lt;code&gt;pre/post_end&lt;/code&gt; pairs that didn't have a matching &lt;code&gt;start&lt;/code&gt; .</source>
          <target state="translated">일단 등록되면 이러한 후크를 끄는 메커니즘이 없으므로 필요한 경우 직접 수행해야합니다. &lt;code&gt;%^H&lt;/code&gt; 의 항목 이 가장 좋은 방법 일 수 있으므로 효과의 범위는 어휘 범위입니다. 그러나 &lt;code&gt;BhkDISABLE&lt;/code&gt; 및 &lt;code&gt;BhkENABLE&lt;/code&gt; 매크로를 사용하여 항목을 임시로 켜거나 끌 수도 있습니다. 또한 확장 프로그램이로드되기 전에 일반적으로 적어도 하나의 스코프가 열리므로 &lt;code&gt;start&lt;/code&gt; 과 일치하지 않는 &lt;code&gt;pre/post_end&lt;/code&gt; 쌍이 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="bbf6b188e1d6cda2b1c31b9f2ea910f75bac5ce6" translate="yes" xml:space="preserve">
          <source>Once the 'aaab' at the start of the string has matched, and the &lt;code&gt;(*SKIP)&lt;/code&gt; executed, the next starting point will be where the cursor was when the &lt;code&gt;(*SKIP)&lt;/code&gt; was executed.</source>
          <target state="translated">문자열 시작 부분의 'aaab'가 일치하고 &lt;code&gt;(*SKIP)&lt;/code&gt; 가 실행되면 다음 시작 지점은 커서가 &lt;code&gt;(*SKIP)&lt;/code&gt; 이 실행될 때입니다.</target>
        </trans-unit>
        <trans-unit id="8672a62497c5f795c9c2acf9e29afcdfcf0e6269" translate="yes" xml:space="preserve">
          <source>Once the AV has been created, the following operations are possible on it:</source>
          <target state="translated">AV가 작성되면 다음 조작이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="67df8d841097b17fc29c0a4ea72cc77f4ff9a4eb" translate="yes" xml:space="preserve">
          <source>Once the HV has been created, the following operations are possible on it:</source>
          <target state="translated">HV가 작성되면 다음 조작이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="57df9a521b252465d2cd33284b38479df5df9b79" translate="yes" xml:space="preserve">
          <source>Once the filtering has been applied, the original strings, regexes, POD, etc. are re-inserted into the code, by replacing each placeholder with the corresponding original component (from &lt;code&gt;@components&lt;/code&gt; ). Note that this means that the &lt;code&gt;@components&lt;/code&gt; variable must be treated with extreme care within the filter. The &lt;code&gt;@components&lt;/code&gt; array stores the &quot;back- translations&quot; of each placeholder inserted into &lt;code&gt;$_&lt;/code&gt; , as well as the interstitial source code between placeholders. If the placeholder backtranslations are altered in &lt;code&gt;@components&lt;/code&gt; , they will be similarly changed when the placeholders are removed from &lt;code&gt;$_&lt;/code&gt; after the filter is complete.</source>
          <target state="translated">필터링이 적용되면 각 자리 표시자를 해당 원래 구성 요소 ( &lt;code&gt;@components&lt;/code&gt; ) 로 바꾸어 원래 문자열, 정규 표현식, POD 등을 코드에 다시 삽입합니다 . 이는 &lt;code&gt;@components&lt;/code&gt; 변수가 필터 내에서 세 심하게 처리되어야 함을 의미합니다 . &lt;code&gt;@components&lt;/code&gt; 의 배열 저장 삽입 각 자리의 '백 번역 &quot; &lt;code&gt;$_&lt;/code&gt; 뿐만 아니라 자리 사이에 삽입 소스 코드. 플레이스 홀더 &lt;code&gt;@components&lt;/code&gt; 에서 변경되면 , 필터가 완료된 후 플레이스 홀더가 &lt;code&gt;$_&lt;/code&gt; 에서 제거 될 때 이와 유사하게 변경됩니다 .</target>
        </trans-unit>
        <trans-unit id="4bda05c922f6c0e7108b9b6664cf70b280c74345" translate="yes" xml:space="preserve">
          <source>Once the first line has been processed, the flow will look like this:</source>
          <target state="translated">첫 번째 줄이 처리되면 흐름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2abcd9048b9f7de01dd766ea3b827a4a4ca6e4d7" translate="yes" xml:space="preserve">
          <source>Once the generic server socket has been created using the parameters listed above, the server then waits for a new client to connect to it. The server blocks in the &lt;code&gt;&lt;a href=&quot;functions/accept&quot;&gt;accept&lt;/a&gt;&lt;/code&gt; method, which eventually accepts a bidirectional connection from the remote client. (Make sure to autoflush this handle to circumvent buffering.)</source>
          <target state="translated">위에 나열된 매개 변수를 사용하여 일반 서버 소켓이 작성되면 서버는 새 클라이언트가 연결하기를 기다립니다. 서버는 &lt;code&gt;&lt;a href=&quot;functions/accept&quot;&gt;accept&lt;/a&gt;&lt;/code&gt; 메소드를 차단하여 결국 원격 클라이언트로부터 양방향 연결을 승인합니다. (버퍼링을 피하려면이 핸들을 자동 플러시해야합니다.)</target>
        </trans-unit>
        <trans-unit id="3ee769afc72db89229ffb2a909f356b2b29d26cc" translate="yes" xml:space="preserve">
          <source>Once the parser is done, this will return the exit status. If the parser ran an executable, it returns the exit status of the executable.</source>
          <target state="translated">파서가 완료되면 종료 상태를 반환합니다. 파서가 실행 파일을 실행 한 경우 실행 파일의 종료 상태를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4d1cfe61310d7995317dabd0218a153aefb9089c" translate="yes" xml:space="preserve">
          <source>Once the parser is done, this will return the version number for the parsed TAP. Version numbers were introduced with TAP version 13 so if no version number is found version 12 is assumed.</source>
          <target state="translated">파서가 완료되면 파싱 된 TAP의 버전 번호가 반환됩니다. 버전 번호는 TAP 버전 13에서 도입되었으므로 버전 번호가 없으면 버전 12로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="295310f03609b1e9bcb5a3f97bee3cf209b7fdc9" translate="yes" xml:space="preserve">
          <source>Once the parser is done, this will return the wait status. If the parser ran an executable, it returns the wait status of the executable. Otherwise, this merely returns the &lt;code&gt;&lt;a href=&quot;../functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; status.</source>
          <target state="translated">파서가 완료되면 대기 상태를 반환합니다. 파서가 실행 파일을 실행 한 경우 실행 파일의 대기 상태를 반환합니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;../functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; 상태 만 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e563448cf76902cc1f89b5320bc98d51a6a5d5a8" translate="yes" xml:space="preserve">
          <source>Once the prefix an dthe outermost opening delimiter bracket have been recognized, code blocks are extracted by stepping through the input text and trying the following alternatives in sequence:</source>
          <target state="translated">접두사 dthe가 가장 바깥쪽에있는 분리 문자 괄호가 인식되면 입력 텍스트를 단계별로 실행하고 다음 대안을 순서대로 시도하여 코드 블록을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="c16b3faffb99d8d54125fd9ac6e0e713e87e3953" translate="yes" xml:space="preserve">
          <source>Once the program is otherwise done, and once its localization for the first language works right (via the data and methods in Projname::L10N::en_us), you can get together the data for translation. If your first language lexicon isn't an _AUTO lexicon, then you already have all the messages explicitly in the lexicon (or else you'd be getting exceptions thrown when you call $lh-&amp;gt;maketext to get messages that aren't in there). But if you were (advisedly) lazy and are using an _AUTO lexicon, then you've got to make a list of all the phrases that you've so far been letting _AUTO generate for you. There are very many ways to assemble such a list. The most straightforward is to simply grep the source for every occurrence of &quot;maketext&quot; (or calls to wrappers around it, like the above &lt;code&gt;pmt&lt;/code&gt; function), and to log the following phrase.</source>
          <target state="translated">프로그램이 달리 수행되고 Projname :: L10N :: en_us의 데이터 및 메소드를 통해 첫 번째 언어의 현지화가 제대로 작동하면 번역 할 데이터를 모을 수 있습니다. 첫 번째 언어 어휘가 _AUTO 어휘가 아닌 경우 어휘에 이미 명시 적으로 모든 메시지가 있습니다 (또는 $ lh-&amp;gt; maketext를 호출하여 예외 메시지가 표시되어 예외가 발생 함) ). 그러나 (권고 적으로) 게으르고 _AUTO 어휘집을 사용하고 있다면 지금까지 _AUTO가 당신을 위해 만든 모든 문구 목록을 작성해야합니다. 이러한 목록을 구성하는 방법은 매우 많습니다. 가장 간단한 단순히 위와 같이, 주위 래퍼에 &quot;maketext&quot;의 모든 경우의 소스 (또는 통화를 grep을하는 것입니다 &lt;code&gt;pmt&lt;/code&gt; 함수), 다음 문구를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="2748f5e91bdbaf9d65e1b144f8ee5e1cdc0ecbe6" translate="yes" xml:space="preserve">
          <source>Once the reference is stored in a variable like $aref or $href, you can copy it or store it just the same as any other scalar value:</source>
          <target state="translated">참조가 $ aref 또는 $ href와 같은 변수에 저장되면이를 복사하거나 다른 스칼라 값과 동일하게 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15fa63ef5d4644b5d99dc644eff10efe12c6233c" translate="yes" xml:space="preserve">
          <source>Once the size of the program has been determined, the pattern is parsed again, but this time for real. Now &lt;code&gt;SIZE_ONLY&lt;/code&gt; will be false, and the actual construction can occur.</source>
          <target state="translated">프로그램의 크기가 결정되면 패턴은 다시 구문 분석되지만 이번에는 실제에 대한 것입니다. 이제 &lt;code&gt;SIZE_ONLY&lt;/code&gt; 는 false이며 실제 구성이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ce09f4f2086e283549a294da4a8bb0ec70720b9" translate="yes" xml:space="preserve">
          <source>Once this is done, do the following to build any extension:</source>
          <target state="translated">이 작업이 완료되면 다음을 수행하여 확장을 빌드하십시오.</target>
        </trans-unit>
        <trans-unit id="c86d1961dcc0430277520b8cb5786b3c716d4a7c" translate="yes" xml:space="preserve">
          <source>Once this process completes for a given function, it is defined, so future calls to the subroutine will bypass the AUTOLOAD mechanism.</source>
          <target state="translated">주어진 함수에 대해이 프로세스가 완료되면 프로세스가 정의되므로 이후 서브 루틴에 대한 호출은 AUTOLOAD 메커니즘을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="9bc6c924aca0f68365c3f48d14dbdebf3eb3856a" translate="yes" xml:space="preserve">
          <source>Once uploaded, it'll sit unnoticed in your author directory. If you want it connected to the rest of the CPAN, you'll need to go to &quot;Register Namespace&quot; on PAUSE. Once registered, your module will appear in the by-module and by-category listings on CPAN.</source>
          <target state="translated">업로드 한 후에는 제작자 디렉토리에 눈에 띄지 않습니다. CPAN의 나머지 부분에 연결하려면 PAUSE의 &quot;이름 공간 등록&quot;으로 이동해야합니다. 등록되면 모듈이 CPAN의 모듈 별 및 범주 별 목록에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="852b82c0a8fc155a5b67d823ae98f4fd4d342839" translate="yes" xml:space="preserve">
          <source>Once upon a time, C code compilable under both BSD and SysV. In general, code that can be easily converted to run on another &lt;b&gt;platform&lt;/b&gt;, where &amp;ldquo;easily&amp;rdquo; can be defined however you like, and usually is. Anything may be considered portable if you try hard enough, such as a mobile home or London Bridge.</source>
          <target state="translated">옛날 옛적에 C 코드는 BSD와 SysV에서 컴파일 할 수 있습니다. 일반적으로 쉽게 변환 할 수있는 코드는 다른 &lt;b&gt;플랫폼&lt;/b&gt; 에서 실행하기 때문에 &quot;쉽게&quot;원하는대로 정의 할 수 있습니다. 이동 주택이나 런던 브리지와 같이 충분히 노력하면 휴대용으로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="028479890974f67d52e50ca30dc71571debad796" translate="yes" xml:space="preserve">
          <source>Once upon a time, I wrote a program called pstruct. It was a perl program that tried to parse out C structures and display their member offsets for you. This was especially useful for people looking at binary dumps or poking around the kernel.</source>
          <target state="translated">옛날 옛적에, 나는 pstruct라는 프로그램을 작성했습니다. C 구조를 구문 분석하고 멤버 오프셋을 표시하려고 시도한 것은 perl 프로그램이었습니다. 이 기능은 바이너리 덤프를 보거나 커널을 파고 드는 사람들에게 특히 유용했습니다.</target>
        </trans-unit>
        <trans-unit id="5311fe73402702af14e5a56e844da83a8b07a8a6" translate="yes" xml:space="preserve">
          <source>Once upon a time, MakeMaker could produce an approximation of a correct Makefile on MacOS Classic (MacPerl). Due to a lack of maintainers, this fell out of sync with the rest of MakeMaker and hadn't worked in years. Since there's little chance of it being repaired, MacOS Classic is fading away, and the code was icky to begin with, the code has been deleted to make maintenance easier.</source>
          <target state="translated">옛날 옛적에 MakeMaker는 MacOS Classic (MacPerl)에서 올바른 Makefile의 근사치를 생성 할 수있었습니다. 관리자가 없기 때문에 나머지 MakeMaker와 동기화되지 않아 몇 년 동안 작동하지 않았습니다. 수리 가능성이 거의 없기 때문에 MacOS Classic은 사라지고 코드가 시작하기가 어려워 유지 보수를 쉽게하기 위해 코드가 삭제되었습니다.</target>
        </trans-unit>
        <trans-unit id="f360544bd22369fcd1b6d32877524b0035f30449" translate="yes" xml:space="preserve">
          <source>Once upon a time, there was a library called</source>
          <target state="translated">옛날 옛적에,라는 도서관이 있었다</target>
        </trans-unit>
        <trans-unit id="c419b35f29ce772e59b3d6f120a7bf0188bed72b" translate="yes" xml:space="preserve">
          <source>Once we've blessed the hash referred to by &lt;code&gt;$self&lt;/code&gt; we can start calling methods on it. This is useful if you want to put object initialization in its own separate method:</source>
          <target state="translated">&lt;code&gt;$self&lt;/code&gt; 가 참조한 해시를 축복하면 메소드 호출을 시작할 수 있습니다. 이것은 객체 초기화를 자체적 인 별도의 방법으로 배치하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6b240bbed00f45e13a77c757892ecbf1631c45c9" translate="yes" xml:space="preserve">
          <source>Once you can identify individual blocks, try allowing them to be nested. That isn't difficult either.</source>
          <target state="translated">개별 블록을 식별 할 수 있으면 중첩되도록하십시오. 그것은 어렵지 않습니다.</target>
        </trans-unit>
        <trans-unit id="383155a2b30e1482a3f900136a965760218a5249" translate="yes" xml:space="preserve">
          <source>Once you have a reference, you can use the following macro to dereference the reference:</source>
          <target state="translated">참조가 있으면 다음 매크로를 사용하여 참조를 역 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77ad49af6893225c730f233c983aba4b11bcf0d8" translate="yes" xml:space="preserve">
          <source>Once you have done that, you can access the Berkeley DB API functions as &lt;b&gt;DB_File&lt;/b&gt; methods directly like this:</source>
          <target state="translated">이 작업을 완료하면 Berkeley DB API 함수를 다음과 같이 &lt;b&gt;DB_File&lt;/b&gt; 메소드로 직접 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9d9573b46c2994b393d22341f4e2899c15619352" translate="yes" xml:space="preserve">
          <source>Once you have it on, simply bring up a PASE shell and extract the tarball.</source>
          <target state="translated">일단 그것을 켜면 PASE 껍질을 가져 와서 tarball을 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="2403323a2c0ab8ef6892066d26c525181d3596a2" translate="yes" xml:space="preserve">
          <source>Once you have the list of keys, you can process that list before you process the hash elements. For instance, you can sort the keys so you can process them in lexical order:</source>
          <target state="translated">키 목록이 있으면 해시 요소를 처리하기 전에 해당 목록을 처리 할 수 ​​있습니다. 예를 들어, 키를 사전 순으로 처리 할 수 ​​있도록 키를 정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa2bd757e5448bc96817cbaf4661aeb1b493b281" translate="yes" xml:space="preserve">
          <source>Once you have this code, slap it into the second argument of</source>
          <target state="translated">이 코드를 얻은 후에는 두 번째 인수로</target>
        </trans-unit>
        <trans-unit id="ae0a83fd366650f3f9c13c1a72ec5ce82cd02510" translate="yes" xml:space="preserve">
          <source>Once you have your binary file properly opened in the right mode, you can use all the same Perl I/O functions as you used on text files. However, you may wish to use the fixed-size &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; instead of the variable-sized &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; for your input.</source>
          <target state="translated">이진 파일을 올바른 모드로 올바르게 열면 텍스트 파일에서 사용한 것과 동일한 Perl I / O 기능을 모두 사용할 수 있습니다. 그러나 고정 된 크기 사용하실 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 대신 가변 크기의 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 에 귀하의 의견을.</target>
        </trans-unit>
        <trans-unit id="4a97180f59d4ebc49010b5f130f6497cfeb42c05" translate="yes" xml:space="preserve">
          <source>Once you have your hook functions, you need a &lt;code&gt;BHK&lt;/code&gt; structure to put them in. It's best to allocate it statically, since there is no way to free it once it's registered. The function pointers should be inserted into this structure using the &lt;code&gt;BhkENTRY_set&lt;/code&gt; macro, which will also set flags indicating which entries are valid. If you do need to allocate your &lt;code&gt;BHK&lt;/code&gt; dynamically for some reason, be sure to zero it before you start.</source>
          <target state="translated">일단 후크 함수가 있으면 &lt;code&gt;BHK&lt;/code&gt; 구조를 넣어야합니다. 일단 등록하면 해제 할 수있는 방법이 없으므로 정적으로 할당하는 것이 가장 좋습니다. 함수 포인터는 &lt;code&gt;BhkENTRY_set&lt;/code&gt; 매크로를 사용하여이 구조에 삽입해야하며 , 유효한 엔트리를 나타내는 플래그도 설정합니다. 어떤 이유로 &lt;code&gt;BHK&lt;/code&gt; 를 동적으로 할당해야하는 경우 시작하기 전에 BHK 를 0으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="e41f59d96ffbb22709bea4ad583772ec9921c59e" translate="yes" xml:space="preserve">
          <source>Once you know what the type of an object is, you then know what subclass it belongs to, and therefore what methods it supports.</source>
          <target state="translated">객체의 유형이 무엇인지 알면 객체가 속한 서브 클래스와 지원하는 메소드를 알게됩니다.</target>
        </trans-unit>
        <trans-unit id="850880274fc323f37b6b25fc23ccf3a516cbf65a" translate="yes" xml:space="preserve">
          <source>Once you start accumulating users, they'll send you bug reports. If you're lucky, they'll even send you patches. Welcome to the joys of maintaining a software project...</source>
          <target state="translated">사용자 누적을 시작하면 버그 보고서가 전송됩니다. 운이 좋으면 패치도 보내 줄 것입니다. 소프트웨어 프로젝트를 유지하는 기쁨에 오신 것을 환영합니다 ...</target>
        </trans-unit>
        <trans-unit id="ba22e7b4a3b9d48110bef39d92876fccf1215f67" translate="yes" xml:space="preserve">
          <source>Once you're doing this, you may alter Concise output by adding new rendering styles, and by optionally adding callback routines which populate new variables, if such were referenced from those (just added) styles.</source>
          <target state="translated">이 작업을 수행 한 후에는 새 렌더링 스타일을 추가하고 콜백 루틴을 추가하여 (단순히 추가 된) 스타일에서 새 변수를 참조하는 경우 선택적으로 간결한 출력을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="566e6d16d506c3974bf904eb0b48aa55735c513e" translate="yes" xml:space="preserve">
          <source>Once you're done here, check out &lt;a href=&quot;perlhacktips&quot;&gt;perlhacktips&lt;/a&gt; next.</source>
          <target state="translated">여기에 완료되면 다음 &lt;a href=&quot;perlhacktips&quot;&gt;perlhacktips를&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="29ed2494b99283db9c4753c1220697c79a656d72" translate="yes" xml:space="preserve">
          <source>Once you've actually set any options you want (if any), you can go ahead and use the following methods to search for Pod files in particular ways.</source>
          <target state="translated">실제로 원하는 옵션을 설정 한 후에는 다음 방법을 사용하여 특정 방식으로 포드 파일을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23b007b44c67108f453a7c776499a8dd3ea3293f" translate="yes" xml:space="preserve">
          <source>Once you've done that, you can safely omit the encoding part of the open mode:</source>
          <target state="translated">이 작업을 완료하면 열기 모드의 인코딩 부분을 안전하게 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57d330172757358785b8cc8eade4d52dfcf7f16d" translate="yes" xml:space="preserve">
          <source>Once you've ensured that your module passes its own tests - always a good thing to make sure - you can &lt;code&gt;make dist&lt;/code&gt; , and the Makefile will hopefully produce you a nice tarball of your module, ready for upload.</source>
          <target state="translated">모듈이 자체 테스트를 통과했음을 확인하면 (항상 확인하는 것이 좋습니다) &lt;code&gt;make dist&lt;/code&gt; 를 만들 수 있으며 Makefile은 업로드 할 준비가 된 모듈의 멋진 타르볼을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f63abbf1c003f24ebc901d81ec59d8ecd65e101a" translate="yes" xml:space="preserve">
          <source>Once you've installed the NDK and set up your device, all that's left to do is setting up the device and the cross-compilation environment. Blackberry provides a script, &lt;code&gt;bbndk-env.sh&lt;/code&gt; (occasionally named something like &lt;code&gt;bbndk-env_10_1_0_4828.sh&lt;/code&gt; ) which can be used to do this. However, there's a bit of a snag that we have to work through: The script modifies PATH so that 'gcc' or 'ar' point to their cross-compilation equivalents, which screws over the build process.</source>
          <target state="translated">NDK를 설치하고 장치를 설정했으면 장치와 크로스 컴파일 환경을 설정하기 만하면됩니다. Blackberry는 이를 수행하는 데 사용할 수있는 &lt;code&gt;bbndk-env_10_1_0_4828.sh&lt;/code&gt; 스크립트 ( &lt;code&gt;bbndk-env.sh&lt;/code&gt; 와 같은 이름 의 스크립트)를 제공합니다 . 그러나 약간의 걸림돌이 있습니다. 스크립트는 PATH를 수정하여 'gcc'또는 'ar'가 교차 컴파일 동등 물을 가리 키도록하여 빌드 프로세스를 방해합니다.</target>
        </trans-unit>
        <trans-unit id="6dca0ad4315ae940ee938651b8e1193e8aa9a420" translate="yes" xml:space="preserve">
          <source>Once you've localized your program/site/etc. for all desired languages, be sure to show the result (whether live, or via screenshots) to the translators. Once they approve, make every effort to have it then checked by at least one other speaker of that language. This holds true even when (or especially when) the translation is done by one of your own programmers. Some kinds of systems may be harder to find testers for than others, depending on the amount of domain-specific jargon and concepts involved -- it's easier to find people who can tell you whether they approve of your translation for &quot;delete this message&quot; in an email-via-Web interface, than to find people who can give you an informed opinion on your translation for &quot;attribute value&quot; in an XML query tool's interface.</source>
          <target state="translated">프로그램 / 사이트 / 등을 현지화하면 원하는 모든 언어의 경우 결과를 라이브 또는 스크린 샷을 통해 번역자에게 보여주십시오. 승인 한 후에는 해당 언어를 사용하는 다른 한 사람이 확인하도록 모든 노력을 기울이십시오. 이는 프로그래머 중 한 명이 번역을 수행 할 때 (또는 특히) 수행 할 때도 마찬가지입니다. 도메인 별 전문 용어 및 관련 개념의 양에 따라 일부 시스템은 다른 시스템보다 테스터를 찾기가 더 어려울 수 있습니다. XML 쿼리 도구의 인터페이스에서 &quot;속성 값&quot;에 대한 번역에 대한 정보를 제공 할 수있는 사람을 찾는 것보다 웹을 통한 전자 메일 인터페이스.</target>
        </trans-unit>
        <trans-unit id="c53ec1e93f888bd372b8348217b36ca16ed6c602" translate="yes" xml:space="preserve">
          <source>Once you've understood those, embedding Perl in C is easy.</source>
          <target state="translated">이를 이해했다면 Perl을 C에 포함시키는 것은 쉽다.</target>
        </trans-unit>
        <trans-unit id="8154145e302b1a07e64a971e9a8a8af681b5891f" translate="yes" xml:space="preserve">
          <source>Once you've unpacked the distribution, run &quot;sh Configure&quot; (see INSTALL for a full discussion of the Configure options). There is a &quot;hints&quot; file for os390 that specifies the correct values for most things. Some things to watch out for include:</source>
          <target state="translated">배포판의 압축을 풀면 &quot;sh Configure&quot;를 실행하십시오 (Configure 옵션에 대한 자세한 설명은 INSTALL을 참조하십시오). os390에 대한 &quot;힌트&quot;파일이 있으며 대부분의 것들에 대한 올바른 값을 지정합니다. 주의해야 할 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="db5c3d0411160491df177efaf9a707107fc6ab38" translate="yes" xml:space="preserve">
          <source>Once your extension is complete and passes all its tests, installing it is quite simple: you simply run &quot;make install&quot;. You will either need to have write permission into the directories where Perl is installed, or ask your system administrator to run the make for you.</source>
          <target state="translated">확장이 완료되고 모든 테스트를 통과 한 후에는 설치가 매우 간단합니다. &quot;make install&quot;을 실행하기 만하면됩니다. Perl이 설치된 디렉토리에 대한 쓰기 권한이 있거나 시스템 관리자에게 make를 실행하도록 요청해야합니다.</target>
        </trans-unit>
        <trans-unit id="4f49dbc375a0394fd3dd511b9f8226cfef74fa93" translate="yes" xml:space="preserve">
          <source>One additional translation is performed: instead of</source>
          <target state="translated">하나의 추가 번역이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="a68ac543ed261e894527754904db5e74312dfaac" translate="yes" xml:space="preserve">
          <source>One area where there has been conflict is in regards to C locales. (See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.) perl, with one exception and unless told otherwise, sets up the underlying locale the program is running in to the locale passed into it from the environment. This is an important difference from a generic C language program, where the underlying locale is the &quot;C&quot; locale unless the program changes it. As of v5.20, this underlying locale is completely hidden from pure perl code outside the lexical scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; except for a couple of function calls in the POSIX module which of necessity use it. But the underlying locale, with that one exception is exposed to XS code, affecting all C library routines whose behavior is locale-dependent. Your XS code better not assume that the underlying locale is &quot;C&quot;. The exception is the &lt;a href=&quot;perllocale#Category-LC_NUMERIC%3a-Numeric-Formatting&quot;&gt;LC_NUMERIC &lt;/a&gt; locale category, and the reason it is an exception is that experience has shown that it can be problematic for XS code, whereas we have not had reports of problems with the &lt;a href=&quot;perllocale#WHAT-IS-A-LOCALE&quot;&gt;other locale categories&lt;/a&gt;. And the reason for this one category being problematic is that the character used as a decimal point can vary. Many European languages use a comma, whereas English, and hence Perl are expecting a dot (U+002E: FULL STOP). Many modules can handle only the radix character being a dot, and so perl attempts to make it so. Up through Perl v5.20, the attempt was merely to set &lt;code&gt;LC_NUMERIC&lt;/code&gt; upon startup to the &lt;code&gt;&quot;C&quot;&lt;/code&gt; locale. Any &lt;a href=&quot;perllocale#The-setlocale-function&quot;&gt;setlocale()&lt;/a&gt; otherwise would change it; this caused some failures. Therefore, starting in v5.22, perl tries to keep &lt;code&gt;LC_NUMERIC&lt;/code&gt; always set to &lt;code&gt;&quot;C&quot;&lt;/code&gt; for XS code.</source>
          <target state="translated">충돌이 발생한 영역 중 하나는 C 로캘과 관련이 있습니다. ( &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; 참조 ) perl은 한 가지 예외가 있으며 달리 언급하지 않는 한 프로그램이 환경에서 전달 된 로케일로 실행중인 기본 로케일을 설정합니다. 이는 프로그램이 변경하지 않는 한 기본 C가 &quot;C&quot;로캘 인 일반 C 언어 프로그램과의 중요한 차이점입니다. v5.20로,이 기본 로케일이 완전히의 어휘 범위를 벗어난 순수한 펄 코드에서 숨겨진 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; POSIX 모듈에서 필요한 함수 호출을 제외하고는 필요합니다. 그러나 기본 로케일은 XS 코드에 노출되어 있으며 로케일에 따라 동작하는 모든 C 라이브러리 루틴에 영향을줍니다. XS 코드는 기본 로캘이 &quot;C&quot;라고 가정하지 않는 것이 좋습니다. 예외는있다 &lt;a href=&quot;perllocale#Category-LC_NUMERIC%3a-Numeric-Formatting&quot;&gt;LC_NUMERIC의&lt;/a&gt; 로케일 범주, 우리가 문제의 보고서가 없었어요 반면에 예외 인 이유는, 그 경험은 XS 코드에 대한 문제가 될 수 있다는 것을 보여 주었다이다 &lt;a href=&quot;perllocale#WHAT-IS-A-LOCALE&quot;&gt;로케일 범주를&lt;/a&gt;. 그리고이 한 가지 범주가 문제가되는 이유는 소수점으로 사용되는 문자가 다를 수 있기 때문입니다. 많은 유럽 언어는 쉼표를 사용하는 반면 영어이므로 Perl은 점을 기대합니다 (U + 002E : FULL STOP). 많은 모듈이 점인 기수 문자 만 처리 할 수 ​​있으므로 perl이이를 시도합니다. Perl v5.20까지는 시작시 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 을 &lt;code&gt;&quot;C&quot;&lt;/code&gt; 로케일 로 설정하려고했습니다 . 어떤 &lt;a href=&quot;perllocale#The-setlocale-function&quot;&gt;은 setlocale ()&lt;/a&gt; 그렇지 않으면 변경 것입니다; 이로 인해 일부 오류가 발생했습니다. 따라서 v5.22부터 perl 은 XS 코드에 대해 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 을 항상 &lt;code&gt;&quot;C&quot;&lt;/code&gt; 로 설정 하려고 합니다.</target>
        </trans-unit>
        <trans-unit id="6b3b34651f404f7056a8a03b94a1667665687e73" translate="yes" xml:space="preserve">
          <source>One big difference between ASCII-based character sets and EBCDIC ones are the relative positions of the characters when sorted in native order. Of most concern are the upper- and lowercase letters, the digits, and the underscore (&lt;code&gt;&quot;_&quot;&lt;/code&gt; ). On ASCII platforms the native sort order has the digits come before the uppercase letters which come before the underscore which comes before the lowercase letters. On EBCDIC, the underscore comes first, then the lowercase letters, then the uppercase ones, and the digits last. If sorted on an ASCII-based platform, the two-letter abbreviation for a physician comes before the two letter abbreviation for drive; that is:</source>
          <target state="translated">ASCII 기반 문자 집합과 EBCDIC 문자의 큰 차이점은 기본 순서로 정렬 할 때 문자의 상대적 위치입니다. 가장 큰 관심사는 대문자와 소문자, 숫자 및 밑줄 ( &lt;code&gt;&quot;_&quot;&lt;/code&gt; )입니다. ASCII 플랫폼에서 기본 정렬 순서는 숫자가 대문자 앞에오고 밑줄 앞에 소문자가옵니다. EBCDIC에서 밑줄이 먼저오고 소문자, 대문자 및 숫자가 마지막에옵니다. ASCII 기반 플랫폼에서 정렬 된 경우, 의사의 두 글자 약어는 드라이브의 두 글자 약어 앞에옵니다. 그건:</target>
        </trans-unit>
        <trans-unit id="a63660a2be4a88226e8e69f57c474e97932c916a" translate="yes" xml:space="preserve">
          <source>One can also use &quot;short&quot; names:</source>
          <target state="translated">&quot;짧은&quot;이름을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="577442f1eff045466125f84e1aef5d482722c146" translate="yes" xml:space="preserve">
          <source>One can always start</source>
          <target state="translated">하나는 항상 시작할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="29c09e61bbeafec8533e6d27dfc8a923e0fca57d" translate="yes" xml:space="preserve">
          <source>One can build perl with thread support enabled by providing &lt;code&gt;-D usethreads&lt;/code&gt; option to</source>
          <target state="translated">&lt;code&gt;-D usethreads&lt;/code&gt; 옵션을 제공하여 스레드 지원을 사용하여 perl을 빌드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="359cf3d8d5555fb74ca7adc2fbcedf983680dde4" translate="yes" xml:space="preserve">
          <source>One can change the output file handle of the messages by setting $Getopt::Std::OUTPUT_HELP_VERSION. One can print the messages of &lt;code&gt;--help&lt;/code&gt; (without the &lt;code&gt;Usage:&lt;/code&gt; line) and &lt;code&gt;--version&lt;/code&gt; by calling functions help_mess() and version_mess() with the switches string as an argument.</source>
          <target state="translated">$ Getopt :: Std :: OUTPUT_HELP_VERSION을 설정하여 메시지의 출력 파일 핸들을 변경할 수 있습니다. 스위치 문자열을 인수로 사용하여 help_mess () 및 version_mess () 함수를 호출 하여 &lt;code&gt;--help&lt;/code&gt; ( &lt;code&gt;Usage:&lt;/code&gt; 행 없이 ) 및 &lt;code&gt;--version&lt;/code&gt; 메시지를 인쇄 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d414d38c04c2c09cb11f7d028ae1e652935790fa" translate="yes" xml:space="preserve">
          <source>One can check whether the currently loaded ReadLine package supports these methods by checking for corresponding &lt;code&gt;Features&lt;/code&gt; .</source>
          <target state="translated">해당 &lt;code&gt;Features&lt;/code&gt; 을 확인하여 현재로드 된 ReadLine 패키지가 이러한 방법을 지원하는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c198d2cf41321cd565d4f52242fa64736d1a9f4a" translate="yes" xml:space="preserve">
          <source>One can circumnavigate both these problems in two ways. Either transfer and store numbers always in text format, instead of raw binary, or else consider using modules like &lt;code&gt;Data::Dumper&lt;/code&gt; and &lt;code&gt;Storable&lt;/code&gt; (included as of Perl 5.8). Keeping all data as text significantly simplifies matters.</source>
          <target state="translated">이 두 가지 문제를 두 가지 방법으로 우회 할 수 있습니다. 원시 바이너리 대신 항상 텍스트 형식으로 번호를 전송하고 저장하거나 &lt;code&gt;Data::Dumper&lt;/code&gt; 및 &lt;code&gt;Storable&lt;/code&gt; (Perl 5.8에 포함) 과 같은 모듈을 사용하는 것이 좋습니다. 모든 데이터를 텍스트로 유지하면 문제가 크게 단순화됩니다.</target>
        </trans-unit>
        <trans-unit id="09119ba09b711474d1016a03da12b7c5aabeff6a" translate="yes" xml:space="preserve">
          <source>One can get RSX from, say</source>
          <target state="translated">RSX를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc1d1f2f775a433521e449135abda7dc4b545354" translate="yes" xml:space="preserve">
          <source>One can get different parts of EMX from, say</source>
          <target state="translated">예를 들어 EMX의 다른 부분을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1f6c95529bb8b413cce8749a9949bb156c89f7b" translate="yes" xml:space="preserve">
          <source>One can have Unicode in identifier names, but not in package/class or subroutine names. While some limited functionality towards this does exist as of Perl 5.8.0, that is more accidental than designed; use of Unicode for the said purposes is unsupported.</source>
          <target state="translated">식별자 이름에는 유니 코드를 사용할 수 있지만 패키지 / 클래스 또는 서브 루틴 이름에는 유니 코드를 사용할 수 없습니다. Perl 5.8.0부터는 이에 대한 일부 제한된 기능이 존재하지만 이는 의도 한 것보다 우연한 것입니다. 상기 목적으로 유니 코드를 사용하는 것은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="419250bbe62537b6d8975e14166ba62003b501d4" translate="yes" xml:space="preserve">
          <source>One can read this document in the following formats:</source>
          <target state="translated">이 문서를 다음 형식으로 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6893de36816aebf716cd1fd72a1de7d9c51768bf" translate="yes" xml:space="preserve">
          <source>One can replace a numeric repeat count with a template letter enclosed in brackets to use the packed byte length of the bracketed template for the repeat count.</source>
          <target state="translated">숫자 반복 횟수를 대괄호로 묶인 템플리트 문자로 대체하여 반복 횟수에 대괄호로 묶인 템플리트의 압축 된 바이트 길이를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05782b074320e38eef954451f657efc4b11fa74a" translate="yes" xml:space="preserve">
          <source>One case that this does not handle is a gv without SvFAKE set. After</source>
          <target state="translated">이것이 처리되지 않는 경우는 SvFAKE가 설정되지 않은 gv입니다. 후</target>
        </trans-unit>
        <trans-unit id="702f5c0458dfb1f9b9fa361a8264610e99c16724" translate="yes" xml:space="preserve">
          <source>One common debugging approach here, would be to liberally sprinkle a few print statements, to add a check just before we print out our data, and another just after:</source>
          <target state="translated">여기에서 일반적인 디버깅 방법 중 하나는 몇 가지 print 문을 자유롭게 뿌리고 데이터를 인쇄하기 직전에 검사를 추가하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="38e71844bc36e8f5a99e4a47f54b762cb30af6e8" translate="yes" xml:space="preserve">
          <source>One common mistake when using this port with a GUI library like &lt;code&gt;Tk&lt;/code&gt; is assuming that Perl's normal behavior of opening a command-line window will go away. This isn't the case. If you want to start a copy of &lt;code&gt;perl&lt;/code&gt; without opening a command-line window, use the &lt;code&gt;wperl&lt;/code&gt; executable built during the installation process. Usage is exactly the same as normal &lt;code&gt;perl&lt;/code&gt; on Windows, except that options like &lt;code&gt;-h&lt;/code&gt; don't work (since they need a command-line window to print to).</source>
          <target state="translated">이 포트를 &lt;code&gt;Tk&lt;/code&gt; 와 같은 GUI 라이브러리와 함께 사용할 때 한 가지 일반적인 실수 는 Perl의 명령 행 창 열기 동작이 사라진다는 가정입니다. 그렇지 않습니다. 명령 행 창을 열지 않고 &lt;code&gt;perl&lt;/code&gt; 사본을 시작 하려면 설치 프로세스 중에 빌드 된 &lt;code&gt;wperl&lt;/code&gt; 실행 파일을 사용하십시오 . 사용법은 &lt;code&gt;-h&lt;/code&gt; 와 같은 옵션이 작동하지 않는다는 점을 제외하고 Windows의 일반 &lt;code&gt;perl&lt;/code&gt; 과 정확히 동일 합니다. 인쇄하려면 명령 행 창이 필요하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="8a4117118bb75dbafb375915c27d62ebe634dd07" translate="yes" xml:space="preserve">
          <source>One conveys this info to &lt;b&gt;xsubpp&lt;/b&gt; by replacing &lt;code&gt;*&lt;/code&gt; before the argument by &lt;code&gt;&amp;amp;&lt;/code&gt; . &lt;code&gt;&amp;amp;&lt;/code&gt; means that the argument should be passed to a library function by its address. The above two function may be XSUB-ified as</source>
          <target state="translated">인수 앞에 &lt;code&gt;*&lt;/code&gt; 를 &lt;code&gt;&amp;amp;&lt;/code&gt; 로 대체 하여이 정보를 &lt;b&gt;xsubpp&lt;/b&gt; 에 전달합니다 . &lt;code&gt;&amp;amp;&lt;/code&gt; 는 인수가 주소로 라이브러리 함수에 전달되어야 함을 의미합니다. 위의 두 기능은 다음과 같이 XSUB로 인증 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d10907c81f2d55151091ac660924f2a1e254db78" translate="yes" xml:space="preserve">
          <source>One could use this to create subclasses of &lt;b&gt;Pod::Paragraphs&lt;/b&gt; and &lt;b&gt;Pod::InteriorSequences&lt;/b&gt; for specific commands (or to create your own custom node-types in the parse-tree) and add some kind of &lt;b&gt;emit()&lt;/b&gt; method to each custom node/subclass object in the tree. Then all you'd need to do is recursively walk the tree in the desired order, processing the children (most likely from left to right) by formatting them if they are text-strings, or by calling their &lt;b&gt;emit()&lt;/b&gt; method if they are objects/references.</source>
          <target state="translated">이를 사용 하여 특정 명령에 대한 &lt;b&gt;Pod :: Paragraphs&lt;/b&gt; 및 &lt;b&gt;Pod :: InteriorSequences의&lt;/b&gt; 하위 클래스를 만들 거나 구문 분석 트리에서 사용자 지정 노드 유형을 만들거나 각 사용자 지정 노드에 일종의 &lt;b&gt;emit ()&lt;/b&gt; 메서드를 추가 할 수 있습니다 트리의 서브 클래스 객체. 모든 당신은, 또는 호출하여 원하는 순서 트리를 걸어 그들이 텍스트 문자열이있는 경우를 포맷하여 (대부분 왼쪽에서 오른쪽으로) 아이들을 처리하는 재귀 적으로 수행되어 필요할 것 &lt;b&gt;) 발광을 (&lt;/b&gt; 만약 그들이 방법 객체 / 참조.</target>
        </trans-unit>
        <trans-unit id="d5d134d4ce2691a8fd3e620efdc0c0a7dc96f2ab" translate="yes" xml:space="preserve">
          <source>One counterpart, in the column labelled &quot;ASCII-range Unicode&quot; in the table, matches only characters in the ASCII character set.</source>
          <target state="translated">표에서 &quot;ASCII-range Unicode&quot;레이블이 붙은 열에있는 하나의 대응 문자는 ASCII 문자 집합의 문자 만 일치합니다.</target>
        </trans-unit>
        <trans-unit id="e759a7518c2a7615eb212a5b5c617930b5079aa4" translate="yes" xml:space="preserve">
          <source>One especially common bit of Perl code is opening a pipe to &lt;b&gt;sendmail&lt;/b&gt;:</source>
          <target state="translated">특히 Perl 코드 중 하나는 &lt;b&gt;sendmail에&lt;/b&gt; 파이프를 여는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="6006eb32ad88f65a8e3a677b12b70bf0c21cd44a" translate="yes" xml:space="preserve">
          <source>One example module, &lt;a href=&quot;via/quotedprint&quot;&gt;PerlIO::via::QuotedPrint&lt;/a&gt;, is included with Perl 5.8.0, and more example modules are available from CPAN, such as &lt;a href=&quot;http://search.cpan.org/perldoc/PerlIO::via::StripHTML&quot;&gt;PerlIO::via::StripHTML&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/PerlIO::via::Base64&quot;&gt;PerlIO::via::Base64&lt;/a&gt;. The PerlIO::via::StripHTML module for instance, allows you to say:</source>
          <target state="translated">&lt;a href=&quot;via/quotedprint&quot;&gt;PerlIO :: via :: QuotedPrint라는&lt;/a&gt; 하나의 예제 모듈 이 Perl 5.8.0에 포함되어 있으며 CPl 에서 더 많은 예제 모듈 (예 : &lt;a href=&quot;http://search.cpan.org/perldoc/PerlIO::via::StripHTML&quot;&gt;PerlIO :: via :: StripHTML&lt;/a&gt; 및 &lt;a href=&quot;http://search.cpan.org/perldoc/PerlIO::via::Base64&quot;&gt;PerlIO :: via :: Base64)을 사용할 수&lt;/a&gt; 있습니다. 예를 들어 PerlIO :: via :: StripHTML 모듈을 사용하면 다음과 같이 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ffc602a59cde7db4cddb26183a3140b07c9e1e7" translate="yes" xml:space="preserve">
          <source>One exception is the default scalar variable: starting with perl 5.14 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local($_)&lt;/a&gt;&lt;/code&gt; will always strip all magic from $_, to make it possible to safely reuse $_ in a subroutine.</source>
          <target state="translated">하나의 예외는 기본 스칼라 변수입니다. perl 5.14로 시작하면 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local($_)&lt;/a&gt;&lt;/code&gt; 은 항상 $ _에서 모든 매직을 제거하여 서브 루틴에서 $ _를 안전하게 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08b4b3fb221020ddd9f00f023bbae8ca4cbaad9d" translate="yes" xml:space="preserve">
          <source>One facility, one priority.</source>
          <target state="translated">하나의 시설, 하나의 우선 순위.</target>
        </trans-unit>
        <trans-unit id="8aecc974b0a5e7d4fdcb37dff6e7916eb87115e6" translate="yes" xml:space="preserve">
          <source>One form, available starting in Perl 5.14 looks like &lt;code&gt;\o{...}&lt;/code&gt; , where the dots represent one or more octal digits. It can be used for any Unicode character.</source>
          <target state="translated">Perl 5.14부터 사용 가능한 하나의 양식은 &lt;code&gt;\o{...}&lt;/code&gt; 와 유사 하며 점은 하나 이상의 8 진수를 나타냅니다. 모든 유니 코드 문자에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="322c61ed78983eea548dac2ca0c0f3a32df9d886" translate="yes" xml:space="preserve">
          <source>One generally uses it like so:</source>
          <target state="translated">일반적으로 다음과 같이 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5328aa4f92833315a7e49e7973d7b5d5df515277" translate="yes" xml:space="preserve">
          <source>One good reason is when you already have an existing application written in another language that's all done (and done well), or you have an application language specifically designed for a certain task (e.g. prolog, make).</source>
          <target state="translated">한 가지 좋은 이유는 이미 완료된 다른 언어로 작성된 기존 응용 프로그램이 있거나 특정 작업 (예 : 프롤로그, 작성)을 위해 특별히 설계된 응용 프로그램 언어가있는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="5181341efe5d191b40c7bb4f79e039f1b83f3ecd" translate="yes" xml:space="preserve">
          <source>One last thing before we show you how to open files: opening files does not (usually) automatically lock them in Perl. See &lt;a href=&quot;perlfaq5&quot;&gt;perlfaq5&lt;/a&gt; for how to lock.</source>
          <target state="translated">파일을 여는 방법을 보여 드리기 전에 마지막으로해야 할 일 : 파일을 여는 것이 Perl에서 자동으로 잠기지 않습니다. 잠그는 방법 은 &lt;a href=&quot;perlfaq5&quot;&gt;perlfaq5&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b7d0dbf83cb5d86dbb1f5f3433c118dbdc75390f" translate="yes" xml:space="preserve">
          <source>One level of double-quote interpretation is done first, but you can't say &lt;code&gt;&amp;lt;$foo&amp;gt;&lt;/code&gt; because that's an indirect filehandle as explained in the previous paragraph. (In older versions of Perl, programmers would insert curly brackets to force interpretation as a filename glob: &lt;code&gt;&amp;lt;${foo}&amp;gt;&lt;/code&gt; . These days, it's considered cleaner to call the internal function directly as &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob($foo)&lt;/a&gt;&lt;/code&gt;, which is probably the right way to have done it in the first place.) For example:</source>
          <target state="translated">한 쌍의 큰 따옴표 해석이 먼저 수행되지만 &lt;code&gt;&amp;lt;$foo&amp;gt;&lt;/code&gt; 는 이전 단락에서 설명한 간접 파일 핸들이기 때문에 말할 수 없습니다 . (이전 버전의 Perl에서 프로그래머는 중괄호를 삽입하여 파일 이름 glob : &lt;code&gt;&amp;lt;${foo}&amp;gt;&lt;/code&gt; 로 해석하도록 강요 했습니다. 요즘 내부 함수를 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob($foo)&lt;/a&gt;&lt;/code&gt; 로 직접 호출하는 것이 더 깨끗한 것으로 간주됩니다 . 처음에 그것을 수행하는 올바른 방법.) 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="cb3729bf6ea691a9592670464973a67c30ec7dce" translate="yes" xml:space="preserve">
          <source>One line description of the module. Will be included in PPD file.</source>
          <target state="translated">모듈의 한 줄 설명. PPD 파일에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="812bfff50b3cdd6b1a9ee7ea09cf72b33f18f12d" translate="yes" xml:space="preserve">
          <source>One log at a time.</source>
          <target state="translated">한 번에 하나의 로그.</target>
        </trans-unit>
        <trans-unit id="283b267b63bd1be649ecf96f103c3d06603de13e" translate="yes" xml:space="preserve">
          <source>One macro controls the major Perl build flavor: MULTIPLICITY. The MULTIPLICITY build has a C structure that packages all the interpreter state. With multiplicity-enabled perls, PERL_IMPLICIT_CONTEXT is also normally defined, and enables the support for passing in a &quot;hidden&quot; first argument that represents all three data structures. MULTIPLICITY makes multi-threaded perls possible (with the ithreads threading model, related to the macro USE_ITHREADS.)</source>
          <target state="translated">하나의 매크로가 주요 Perl 빌드 특징 인 MULTIPLICITY를 제어합니다. MULTIPLICITY 빌드에는 모든 인터프리터 상태를 패키지하는 C 구조가 있습니다. 다중화 가능 perls를 사용하면 PERL_IMPLICIT_CONTEXT도 일반적으로 정의되며 세 데이터 구조를 모두 나타내는 &quot;숨겨진&quot;첫 번째 인수를 전달할 수 있습니다. MULTIPLICITY는 멀티 스레드 perls를 가능하게합니다 (매크로 USE_ITHREADS와 관련된 ithreads 스레딩 모델 사용).</target>
        </trans-unit>
        <trans-unit id="d690e728f490966c2e852c98cb2c60fa0b1d2fcd" translate="yes" xml:space="preserve">
          <source>One may also use pod directives to quickly comment out a section of code.</source>
          <target state="translated">코드 섹션을 빠르게 주석 처리하기 위해 포드 지시문을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9dbb00f26b5f18e0abff366f4de58cbb31829dd9" translate="yes" xml:space="preserve">
          <source>One may wonder why we call the above calculator symbolic. The reason is that the actual calculation of the value of expression is postponed until the value is</source>
          <target state="translated">왜 우리가 위 계산기를 상징적이라고 부르는지 궁금 할 것입니다. 그 이유는 표현식 값의 실제 계산이 값이 다음과 같이 될 때까지 연기되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="bf00ffa0a786e25adb9ef6ba76b09b1f7cf9677e" translate="yes" xml:space="preserve">
          <source>One might initially guess that Perl would find the &lt;code&gt;at&lt;/code&gt; in &lt;code&gt;cat&lt;/code&gt; and stop there, but that wouldn't give the longest possible string to the first quantifier &lt;code&gt;.*&lt;/code&gt;. Instead, the first quantifier &lt;code&gt;.*&lt;/code&gt; grabs as much of the string as possible while still having the regexp match. In this example, that means having the &lt;code&gt;at&lt;/code&gt; sequence with the final &lt;code&gt;at&lt;/code&gt; in the string. The other important principle illustrated here is that, when there are two or more elements in a regexp, the</source>
          <target state="translated">처음에는 Perl이 &lt;code&gt;cat&lt;/code&gt; &lt;code&gt;at&lt;/code&gt; 를 찾아서 멈추는 것으로 추측 할 수 있지만 첫 번째 수량 자에 가능한 가장 긴 문자열을 제공하지는 않습니다 &lt;code&gt;.*&lt;/code&gt; . 대신 첫 번째 수량 자 &lt;code&gt;.*&lt;/code&gt; 는 정규 표현식 일치를 유지하면서 가능한 한 많은 문자열을 가져옵니다. 이 예에서, 갖는 수단 &lt;code&gt;at&lt;/code&gt; 마지막으로 순서 &lt;code&gt;at&lt;/code&gt; 문자열이다. 여기에 설명 된 다른 중요한 원칙은 정규 표현식에 둘 이상의 요소가있을 때</target>
        </trans-unit>
        <trans-unit id="3150bc5b7154ac86649428809493c4398ced1ef5" translate="yes" xml:space="preserve">
          <source>One might think that &lt;code&gt;\s&lt;/code&gt; is equivalent to &lt;code&gt;[\h\v]&lt;/code&gt; . This is indeed true starting in Perl v5.18, but prior to that, the sole difference was that the vertical tab (&lt;code&gt;&quot;\cK&quot;&lt;/code&gt; ) was not matched by &lt;code&gt;\s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;\s&lt;/code&gt; 는 &lt;code&gt;[\h\v]&lt;/code&gt; 와 같다고 생각할 수 있습니다 . 이것은 실제로 Perl v5.18부터는 사실이지만, 그 이전의 유일한 차이점은 수직 탭 ( &lt;code&gt;&quot;\cK&quot;&lt;/code&gt; )이 &lt;code&gt;\s&lt;/code&gt; 와 일치하지 않았다는 점이었습니다 .</target>
        </trans-unit>
        <trans-unit id="9432dfd3d2e52e33cd8be01a23869f988f439b1e" translate="yes" xml:space="preserve">
          <source>One more thing here. The arrow is optional</source>
          <target state="translated">한 가지 더 있습니다. 화살표는 선택 사항입니다</target>
        </trans-unit>
        <trans-unit id="a5eb562f91efde24f12f2e0986c6a04d104745fa" translate="yes" xml:space="preserve">
          <source>One must be careful with scalars and strings that are passed to print that contain ASCII encodings. One common place for this to occur is in the output of the MIME type header for CGI script writing. For example, many Perl programming guides recommend something similar to:</source>
          <target state="translated">ASCII 인코딩이 포함 된 인쇄를 위해 전달 된 스칼라 및 문자열에주의해야합니다. 이 문제가 발생하는 한 가지 일반적인 위치는 CGI 스크립트 작성을위한 MIME 유형 헤더의 출력입니다. 예를 들어, 많은 Perl 프로그래밍 안내서는 다음과 유사한 것을 권장합니다.</target>
        </trans-unit>
        <trans-unit id="8aa98e22038b28e02e918eedca3ae733d476de73" translate="yes" xml:space="preserve">
          <source>One name for a file. This name is listed in a &lt;b&gt;directory&lt;/b&gt;. You can use it in an &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; to tell the &lt;b&gt;operating system&lt;/b&gt; exactly which file you want to open, and associate the file with a &lt;b&gt;filehandle&lt;/b&gt;, which will carry the subsequent identity of that file in your program, until you close it.</source>
          <target state="translated">파일의 이름. 이 이름은 &lt;b&gt;디렉토리에&lt;/b&gt; 나열됩니다 . 파일을 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 에서 사용 하여 &lt;b&gt;운영 체제&lt;/b&gt; 에 열려는 파일을 정확하게 알려주고 파일을 &lt;b&gt;filehandle&lt;/b&gt; 과 연결하면 파일 &lt;b&gt;핸들&lt;/b&gt; 을 닫을 때까지 해당 파일의 후속 ID를 프로그램에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="f26a31e071285811042cc63d258cbdf20a705a7a" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;Moo&lt;/code&gt; 's most compelling features is its interoperability with &lt;code&gt;Moose&lt;/code&gt; . When someone tries to use &lt;code&gt;Moose&lt;/code&gt; 's introspection API on a &lt;code&gt;Moo&lt;/code&gt; class or role, it is transparently inflated into a &lt;code&gt;Moose&lt;/code&gt; class or role. This makes it easier to incorporate &lt;code&gt;Moo&lt;/code&gt; -using code into a &lt;code&gt;Moose&lt;/code&gt; code base and vice versa.</source>
          <target state="translated">&lt;code&gt;Moo&lt;/code&gt; 의 가장 강력한 기능 중 하나는 &lt;code&gt;Moose&lt;/code&gt; 와의 상호 운용성입니다 . 누군가가 &lt;code&gt;Moo&lt;/code&gt; 클래스 또는 역할에서 &lt;code&gt;Moose&lt;/code&gt; 의 자체 검사 API 를 사용하려고 하면 &lt;code&gt;Moose&lt;/code&gt; 클래스 또는 역할 로 투명하게 팽창됩니다 . 따라서 &lt;code&gt;Moo&lt;/code&gt; 사용 코드를 &lt;code&gt;Moose&lt;/code&gt; 코드베이스에 쉽게 통합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bf48b13931751973cecbe1ffc3a845b843b66dc" translate="yes" xml:space="preserve">
          <source>One of HP porting centres URL's is &lt;a href=&quot;http://hpux.connect.org.uk/&quot;&gt;http://hpux.connect.org.uk/&lt;/a&gt; The port currently available is built with GNU gcc.</source>
          <target state="translated">HP 포팅 센터 URL 중 하나는 &lt;a href=&quot;http://hpux.connect.org.uk/&quot;&gt;http://hpux.connect.org.uk/입니다&lt;/a&gt; . 현재 사용 가능한 포트는 GNU gcc로 빌드되었습니다.</target>
        </trans-unit>
        <trans-unit id="94bda56a061a9cf12b48d3cef39a83cda8c248d2" translate="yes" xml:space="preserve">
          <source>One of Perl's internal formats happens to be UTF-8. Unfortunately, Perl can't keep a secret, so everyone knows about this. That is the source of much confusion. It's better to pretend that the internal format is some unknown encoding, and that you always have to encode and decode explicitly.</source>
          <target state="translated">Perl의 내부 형식 중 하나는 UTF-8입니다. 불행히도 Perl은 비밀을 유지할 수 없으므로 모든 사람이 이에 대해 알고 있습니다. 그것이 많은 혼란의 근원입니다. 내부 형식은 알려지지 않은 인코딩이며 항상 명시 적으로 인코딩 및 디코딩해야한다고 가정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="cc31f4f8c344159a9afe652428d4adbed5ef0111" translate="yes" xml:space="preserve">
          <source>One of the filters between the data and what you get as input or what you end up with as output.</source>
          <target state="translated">데이터와 입력으로 얻는 것과 출력으로 끝나는 것 사이의 필터 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="3850b3f9f916208f5af479bdf2a17050a569dd0c" translate="yes" xml:space="preserve">
          <source>One of the hacks is to disable floating point exceptions on Perl startup (as is the default with EMX). This helps only with compile-time-linked DLLs changing the flags before main() had a chance to be called.</source>
          <target state="translated">해킹 중 하나는 Perl 시작시 부동 소수점 예외를 비활성화하는 것입니다 (EMX의 기본값과 동일). 이것은 main ()이 호출되기 전에 컴파일 타임 링크 DLL이 플래그를 변경하는 경우에만 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="b9aab9b2588d728ddcd8fd3f3150c7ee7136503c" translate="yes" xml:space="preserve">
          <source>One of the major problems with ancient, antemillennial socket code in Perl was that it used hard-coded values for some of the constants, which severely hurt portability. If you ever see code that does anything like explicitly setting &lt;code&gt;$AF_INET = 2&lt;/code&gt; , you know you're in for big trouble. An immeasurably superior approach is to use the &lt;code&gt;Socket&lt;/code&gt; module, which more reliably grants access to the various constants and functions you'll need.</source>
          <target state="translated">Perl에서 고대의 천년 전 소켓 코드의 주요 문제점 중 하나는 일부 상수에 하드 코딩 된 값을 사용하여 이식성이 심각하게 손상되었다는 것입니다. &lt;code&gt;$AF_INET = 2&lt;/code&gt; 명시 적으로 설정하는 것과 같은 코드를 본 적이 있다면 큰 문제가있는 것입니다. 놀랍도록 뛰어난 접근 방식은 &lt;code&gt;Socket&lt;/code&gt; 모듈 을 사용하는 것입니다. 소켓 모듈은 필요한 다양한 상수 및 기능에 대한 액세스를보다 확실하게 부여합니다.</target>
        </trans-unit>
        <trans-unit id="6c4fa2a95a0e37301600fc24249222e084bd9620" translate="yes" xml:space="preserve">
          <source>One of the most important new features in Perl 5 was the capability to manage complicated data structures like multidimensional arrays and nested hashes. To enable these, Perl 5 introduced a feature called 'references', and using references is the key to managing complicated, structured data in Perl. Unfortunately, there's a lot of funny syntax to learn, and the main manual page can be hard to follow. The manual is quite complete, and sometimes people find that a problem, because it can be hard to tell what is important and what isn't.</source>
          <target state="translated">Perl 5의 가장 중요한 새로운 기능 중 하나는 다차원 배열 및 중첩 해시와 같은 복잡한 데이터 구조를 관리하는 기능이었습니다. 이를 가능하게하기 위해 Perl 5는 'references'라는 기능을 도입했으며 Perl에서 복잡한 구조화 된 데이터를 관리하는 데 참조를 사용하는 것이 중요합니다. 불행히도, 배우기에는 많은 재미있는 구문이 있으며, 기본 매뉴얼 페이지를 따르기가 어려울 수 있습니다. 매뉴얼은 매우 완전하며, 사람들은 중요한 것이 무엇이고 무엇이 아닌지를 말하기가 어렵 기 때문에 문제를 발견하기도합니다.</target>
        </trans-unit>
        <trans-unit id="41a97cc2346bbbbc5f26243bf51ad23f4ba0e8d3" translate="yes" xml:space="preserve">
          <source>One of the problems with a filter like:</source>
          <target state="translated">필터와 관련된 문제 중 하나는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a626f07a30077e1f9ff80b843148b2bf2dc96ddf" translate="yes" xml:space="preserve">
          <source>One of the things that makes Perl really powerful is the fact that Perl hackers tend to want to share the solutions to problems they've faced, so you and I don't have to battle with the same problem again.</source>
          <target state="translated">Perl을 정말로 강력하게 만드는 것 중 하나는 Perl 해커가 직면 한 문제에 대한 솔루션을 공유하려는 경향이 있다는 사실입니다. 따라서 귀하와 저는 같은 문제로 다시 싸울 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="aa5b2755a479a90ca14fceb1d31618523426dc94" translate="yes" xml:space="preserve">
          <source>One of the two modules that is used by perlivp was not present in the installation. This is a serious error since it adversely affects perlivp's ability to function. You may be able to correct this by performing a proper perl installation.</source>
          <target state="translated">perlivp에서 사용하는 두 모듈 중 하나가 설치에 없습니다. 이것은 perlivp의 기능에 악영향을 미치기 때문에 심각한 오류입니다. 적절한 perl 설치를 수행하여이를 정정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d738b6e570cef7894a16f160998423dd24b30a2e" translate="yes" xml:space="preserve">
          <source>One or more embedded pattern-match modifiers, to be turned on (or turned off, if preceded by &lt;code&gt;-&lt;/code&gt; ) for the remainder of the pattern or the remainder of the enclosing pattern group (if any).</source>
          <target state="translated">(앞에 경우, 또는 해제 하나 이상 포함 된 패턴 매치 수정이 켜져하기 &lt;code&gt;-&lt;/code&gt; 패턴의 나머지 부분 또는 바깥 쪽 패턴 그룹의 나머지 (있는 경우)에 대한).</target>
        </trans-unit>
        <trans-unit id="721d29636c1b919768ad8c3269b118c8775df092" translate="yes" xml:space="preserve">
          <source>One or more files turned up missing according to a run of &lt;code&gt;ExtUtils::Installed -&amp;gt; validate()&lt;/code&gt; over your installation. Correct by conducting a proper installation.</source>
          <target state="translated">&lt;code&gt;ExtUtils::Installed -&amp;gt; validate()&lt;/code&gt; 실행에 따라 하나 이상의 파일이 누락되었습니다 . 올바르게 설치하여 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="88abd7d83fea4aa59fb220bc8cdda84165c2e0f9" translate="yes" xml:space="preserve">
          <source>One or more modifiers below may optionally follow certain letters in the TEMPLATE (the second column lists letters for which the modifier is valid):</source>
          <target state="translated">아래의 하나 이상의 수정자는 선택적으로 TEMPLATE의 특정 문자 뒤에 올 수 있습니다 (두 번째 열에는 수정자가 유효한 문자가 나열 됨).</target>
        </trans-unit>
        <trans-unit id="3fcfdc5f9b9b3f122957e3a54f34893e2f61290e" translate="yes" xml:space="preserve">
          <source>One or more sections or subsections giving greater detail of available methods and routines and any other relevant information.</source>
          <target state="translated">사용 가능한 방법과 루틴 및 기타 관련 정보를 자세히 설명하는 하나 이상의 섹션 또는 하위 섹션.</target>
        </trans-unit>
        <trans-unit id="c5eeb4b94f000feadb0a97d5609bef506c388a67" translate="yes" xml:space="preserve">
          <source>One other interesting thing that the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; flag allows is chaining substitutions:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; 플래그가 허용 하는 또 다른 흥미로운 점 은 체인 대체입니다.</target>
        </trans-unit>
        <trans-unit id="1f9412fcd9541135d5364daa53310c1798b61f41" translate="yes" xml:space="preserve">
          <source>One other thing to consider is that a CV may be merely undefined rather than freed, eg &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; &amp;amp;foo&lt;/code&gt; . In this case, its refcount may not have reached zero, but we still delete its pad and its &lt;code&gt;CvROOT&lt;/code&gt; etc. Since various children may still have their &lt;code&gt;CvOUTSIDE&lt;/code&gt; pointing at this undefined CV, we keep its own &lt;code&gt;CvOUTSIDE&lt;/code&gt; for the time being, so that the chain of lexical scopes is unbroken. For example, the following should print 123:</source>
          <target state="translated">고려해야 할 또 다른 사항은 CV가 해제되지 않고 정의되지 않은 것일 수 있다는 것입니다 (예 : &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; &amp;amp;foo&lt;/code&gt; . 이 경우 참조 &lt;code&gt;CvROOT&lt;/code&gt; 가 0에 도달하지 않았지만 여전히 패드와 CvROOT 등을 삭제합니다 . 다양한 어린이가 &lt;code&gt;CvOUTSIDE&lt;/code&gt; 가이 정의되지 않은 CV를 가리 키 도록 할 수 있으므로 당분간 자체 &lt;code&gt;CvOUTSIDE&lt;/code&gt; 를 유지 합니다. 어휘 범위의 체인은 끊어지지 않습니다. 예를 들어, 다음은 123을 인쇄해야합니다.</target>
        </trans-unit>
        <trans-unit id="54709e3c9ceaf35c18e13834b92c003e53cefa1d" translate="yes" xml:space="preserve">
          <source>One particularly pernicious problem with the 4NT command shell for Windows is that it (nearly) always treats a % character as indicating that environment variable expansion is needed. Under this shell, it is therefore important to always double any % characters which you want Perl to see (for example, for hash variables), even when they are quoted.</source>
          <target state="translated">Windows 용 4NT 명령 쉘에서 특히 위험한 문제 중 하나는 환경 변수 확장이 필요하다는 것을 나타내는 거의 항상 문자를 % 문자로 취급한다는 것입니다. 따라서이 쉘에서 인용 될 때에도 Perl에 표시 할 % 문자 (예 : 해시 변수)를 항상 두 배로 늘려야합니다.</target>
        </trans-unit>
        <trans-unit id="3b85137385a802506b55867204695f7dbafde5be" translate="yes" xml:space="preserve">
          <source>One possibility is to treat any match against these code points as undefined. But since Perl doesn't have the concept of a match being undefined, it converts this to failing or &lt;code&gt;FALSE&lt;/code&gt; . This is almost, but not quite, what Perl did from v5.14 (when use of these code points became generally reliable) through v5.18. The difference is that Perl treated all &lt;code&gt;\p{}&lt;/code&gt; matches as failing, but all &lt;code&gt;\P{}&lt;/code&gt; matches as succeeding.</source>
          <target state="translated">한 가지 가능성은 이러한 코드 포인트와 일치하는 항목을 정의되지 않은 것으로 취급하는 것입니다. 그러나 Perl에는 정의되지 않은 일치 개념이 없으므로이를 실패 또는 &lt;code&gt;FALSE&lt;/code&gt; 로 변환 합니다 . 이것은 펄이 v5.14부터 (이 코드 포인트를 사용하는 것이 일반적으로 신뢰할 수있게되었을 때) v5.18까지했던 것과 거의 같지 않습니다. 차이점은 Perl은 모든 &lt;code&gt;\p{}&lt;/code&gt; 일치를 실패한 것으로 취급 하지만 모든 &lt;code&gt;\P{}&lt;/code&gt; 는 성공한 것으로 간주한다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="1709a410cf93d9bdbeb6df92828279b6d704a7e5" translate="yes" xml:space="preserve">
          <source>One possible cause for this is that you expected to have imported a constant to your name space with &lt;b&gt;use&lt;/b&gt; or &lt;b&gt;import&lt;/b&gt; while no such importing took place, it may for example be that your operating system does not support that particular constant. Hopefully you did use an explicit import list for the constants you expect to see; please see &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; and &lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;. While an explicit import list would probably have caught this error earlier it naturally does not remedy the fact that your operating system still does not support that constant. Maybe you have a typo in the constants of the symbol import list of &lt;b&gt;use&lt;/b&gt; or &lt;b&gt;import&lt;/b&gt; or in the constant name at the line where this error was triggered?</source>
          <target state="translated">이에 대한 한 가지 가능한 원인은 가져 오기가 수행되지 않은 상태 에서 &lt;b&gt;사용&lt;/b&gt; 또는 &lt;b&gt;가져 오기&lt;/b&gt; 를 &lt;b&gt;사용&lt;/b&gt; 하여 네임 스페이스로 상수를 가져 왔을 것으로 예상 되었기 때문입니다. 예를 들어 운영 체제가 특정 상수를 지원하지 않을 수 있습니다. 바라건대 상수에 대해 명시 적 가져 오기 목록을 사용했으면합니다. &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 및 &lt;a href=&quot;functions/import&quot;&gt;가져 오기&lt;/a&gt; 를 참조하십시오 . 명시 적 가져 오기 목록이이 오류를 조기에 발견했을 수도 있지만 운영 체제가 여전히 해당 상수를 지원하지 않는다는 사실을 자연스럽게 해결할 수는 없습니다. 기호 가져 오기 &lt;b&gt;사용&lt;/b&gt; 또는 &lt;b&gt;가져&lt;/b&gt; 오기 목록의 상수 또는이 오류가 발생한 행의 상수 이름에 오타가있을 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="07ffb8bf7d3f585bbcc39c2a43071e1fcedc7e55" translate="yes" xml:space="preserve">
          <source>One possible cause is that you set the UTF8 flag yourself for data that you thought to be in UTF-8 but it wasn't (it was for example legacy 8-bit data). To guard against this, you can use Encode::decode_utf8.</source>
          <target state="translated">가능한 원인 중 하나는 UTF-8에 있다고 생각했지만 그렇지 않은 데이터 (예 : 레거시 8 비트 데이터)에 대해 UTF8 플래그를 직접 설정했기 때문입니다. 이를 막기 위해 Encode :: decode_utf8을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c03f254e4e39f57b8a0f0a972c88db9a731c9ed" translate="yes" xml:space="preserve">
          <source>One possibly useful value for the &quot;fail&quot; attribute is the method name &quot;failure_handler_auto&quot;. This is a method defined in the class Locale::Maketext itself. You set it with:</source>
          <target state="translated">&quot;fail&quot;속성에 유용한 값 중 하나는 메소드 이름 &quot;failure_handler_auto&quot;입니다. 이것은 Locale :: Maketext 클래스 자체에 정의 된 메소드입니다. 당신은 그것을 설정 :</target>
        </trans-unit>
        <trans-unit id="b269ab649a9c9d812d50cb6b126828e7c900c2dc" translate="yes" xml:space="preserve">
          <source>One problem that comes up all the time is needing a hash whose values are lists. Perl has hashes, of course, but the values have to be scalars; they can't be lists.</source>
          <target state="translated">항상 나타나는 한 가지 문제는 값이 목록 인 해시가 필요하다는 것입니다. 물론 펄에는 해시가 있지만 값은 스칼라 여야합니다. 그들은 목록이 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="da0157bdbeb61d81e4c036f5229eec00b96121c7" translate="yes" xml:space="preserve">
          <source>One problem with this is that it leads to unexpected, and confusting results in some cases:</source>
          <target state="translated">이것의 한 가지 문제는 예기치 않은 결과를 초래하고 어떤 경우에는 혼란스러운 결과를 초래한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="28b64c8c7b545333b3723cd48a2c35dd515526c6" translate="yes" xml:space="preserve">
          <source>One reason of this unfinishedness is its (currently) inherent unportability: since both package names and subroutine names may need to be mapped to file and directory names, the Unicode capability of the filesystem becomes important-- and there unfortunately aren't portable answers.</source>
          <target state="translated">이 미완료의 한 가지 이유는 패키지 이름과 서브 루틴 이름을 모두 파일 및 디렉토리 이름에 매핑해야하기 때문에 파일 시스템의 유니 코드 기능이 중요 해지고 안타깝게도 휴대용 답변이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ea120cdc114e86190ef9485fa0b67ab7b3ed56c2" translate="yes" xml:space="preserve">
          <source>One reason that Perl does not attempt to resolve the role of Unicode in these situations is that the answers are highly dependent on the operating system and the file system(s). For example, whether filenames can be in Unicode and in exactly what kind of encoding, is not exactly a portable concept. Similarly for &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;: how well will the &quot;command-line interface&quot; (and which of them?) handle Unicode?</source>
          <target state="translated">Perl이 이러한 상황에서 유니 코드의 역할을 해결하려고 시도하지 않는 한 가지 이유는 운영 체제 및 파일 시스템에 대한 답변이 크게 달라지기 때문입니다. 예를 들어, 파일 이름이 유니 코드로되어있을 수 있고 정확히 어떤 종류의 인코딩인지는 휴대용 개념이 아닙니다. &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 과 유사하게 : &quot;명령 줄 인터페이스&quot;(및 이들 중 어느 것)가 유니 코드를 얼마나 잘 처리합니까?</target>
        </trans-unit>
        <trans-unit id="f8927d95df9fc41f4dc802a7941a3910e635adce" translate="yes" xml:space="preserve">
          <source>One reference count is stolen, so you may need to do &lt;code&gt;SvREFCNT_inc(func)&lt;/code&gt; .</source>
          <target state="translated">하나의 참조 횟수를 도난 당 &lt;code&gt;SvREFCNT_inc(func)&lt;/code&gt; 해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4267ef088e1112c0c8dad77c36351342e81e6a78" translate="yes" xml:space="preserve">
          <source>One simple way to check that things are in the right place is to print out the hard-coded &lt;code&gt;@INC&lt;/code&gt; that perl looks through for libraries:</source>
          <target state="translated">올바른 위치에 있는지 확인하는 간단한 방법 중 하나 는 펄이 라이브러리를 찾는 하드 코딩 된 &lt;code&gt;@INC&lt;/code&gt; 를 인쇄하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="dc49c03d5b80e5ca3e1e2c3c5c594145d4d2cfdb" translate="yes" xml:space="preserve">
          <source>One solution to you problem might be autoupgrading|upgrading. See the pragmas &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt;, &lt;a href=&quot;../bigint&quot;&gt;bigint&lt;/a&gt; and &lt;a href=&quot;../bigrat&quot;&gt;bigrat&lt;/a&gt; for an easy way to do this.</source>
          <target state="translated">문제에 대한 한 가지 해결책은 자동 업그레이드입니다. 이를 수행하는 쉬운 방법 은 pragmas &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt; , &lt;a href=&quot;../bigint&quot;&gt;bigint&lt;/a&gt; 및 &lt;a href=&quot;../bigrat&quot;&gt;bigrat&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="02a95fea5b4501f9e97b845e1295326b4030d00a" translate="yes" xml:space="preserve">
          <source>One such concept is that of a</source>
          <target state="translated">그러한 개념 중 하나는</target>
        </trans-unit>
        <trans-unit id="9fa9079fbfabecb5820f55e5b80f8f3529f8caa0" translate="yes" xml:space="preserve">
          <source>One thing Perl porters should note is that</source>
          <target state="translated">Perl 포터가 주목해야 할 것은</target>
        </trans-unit>
        <trans-unit id="46c4b185ea7870c493b95dc5795ba2145a16a509" translate="yes" xml:space="preserve">
          <source>One thing you may not want to rely on is the EBCDIC encoding of punctuation characters since these may differ from code page to code page (and once your module or script is rumoured to work with EBCDIC, folks will want it to work with all EBCDIC character sets).</source>
          <target state="translated">문장 부호 문자의 EBCDIC 인코딩은 코드 페이지마다 다를 수 있으므로 한 번만 사용하면 안됩니다 (모듈이나 스크립트가 EBCDIC와 작동한다고 소문되면 사람들은 모든 EBCDIC 문자와 함께 작동하기를 원할 것입니다. 세트).</target>
        </trans-unit>
        <trans-unit id="3339e6cb559916439f958aa73fa10717ebc88663" translate="yes" xml:space="preserve">
          <source>One thing you'll notice about the Perl source is that it's full of macros. Some have called the pervasive use of macros the hardest thing to understand, others find it adds to clarity. Let's take an example, the code which implements the addition operator:</source>
          <target state="translated">Perl 소스에 대해 알 수있는 한 가지는 매크로로 가득하다는 것입니다. 어떤 사람들은 매크로를 광범위하게 사용하는 것이 이해하기 가장 어려운 것이라고 말했고, 다른 사람들은 그것을 명확하게하는 데 도움을줍니다. 더하기 연산자를 구현하는 코드를 예로 들어 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="6281791d1604f0f2ed2c5d9e3d66b1042f62e087" translate="yes" xml:space="preserve">
          <source>One trick is to use &lt;a href=&quot;http://search.cpan.org/perldoc/File::ReadBackwards&quot;&gt;File::ReadBackwards&lt;/a&gt;, which starts at the end of the file. That module provides an object that wraps the real filehandle to make it easy for you to move around the file. Once you get to the spot you need, you can get the actual filehandle and work with it as normal. In this case, you get the file position at the end of the last line you want to keep and truncate the file to that point:</source>
          <target state="translated">한 가지 트릭은 &lt;a href=&quot;http://search.cpan.org/perldoc/File::ReadBackwards&quot;&gt;파일&lt;/a&gt; 끝에서 시작되는 File :: ReadBackwards 를 사용 하는 것입니다. 이 모듈은 실제 파일 핸들을 감싸는 객체를 제공하므로 파일을 쉽게 이동할 수 있습니다. 필요한 지점에 도달하면 실제 파일 핸들을 가져 와서 정상적으로 작업 할 수 있습니다. 이 경우 마지막 줄의 끝에서 파일 위치를 가져 와서 해당 지점까지 파일을 자릅니다.</target>
        </trans-unit>
        <trans-unit id="2f7425b7bd02b814bd9989aec894f5edbf698c87" translate="yes" xml:space="preserve">
          <source>One useful value for &lt;code&gt;PERLDOC_PAGER&lt;/code&gt; is &lt;code&gt;less -+C -E&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;PERLDOC_PAGER&lt;/code&gt; 의 유용한 값 중 하나 는 &lt;code&gt;less -+C -E&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e54e615dc99abeb96e3dcca5dc954ca0886ad54d" translate="yes" xml:space="preserve">
          <source>One way I can do this involves the substitution operator and a double &lt;code&gt;/e&lt;/code&gt; flag. The first &lt;code&gt;/e&lt;/code&gt; evaluates &lt;code&gt;$1&lt;/code&gt; on the replacement side and turns it into &lt;code&gt;$foo&lt;/code&gt; . The second /e starts with &lt;code&gt;$foo&lt;/code&gt; and replaces it with its value. &lt;code&gt;$foo&lt;/code&gt; , then, turns into 'Fred', and that's finally what's left in the string:</source>
          <target state="translated">내가 이것을 할 수있는 한 가지 방법은 대체 연산자와 이중 &lt;code&gt;/e&lt;/code&gt; 플래그를 포함합니다. 첫 번째 &lt;code&gt;/e&lt;/code&gt; 는 대체 측면에서 &lt;code&gt;$1&lt;/code&gt; 을 평가 하여 &lt;code&gt;$foo&lt;/code&gt; 로 바꿉니다 . 두 번째 / e는 &lt;code&gt;$foo&lt;/code&gt; 시작 하여 값으로 바꿉니다. 그런 다음 &lt;code&gt;$foo&lt;/code&gt; 는 'Fred'로 바뀌고 마침내 문자열에 남습니다.</target>
        </trans-unit>
        <trans-unit id="147fc583705f82dfe6c5d25a61550d429d726533" translate="yes" xml:space="preserve">
          <source>One way is to treat the return values as a list and index into it:</source>
          <target state="translated">한 가지 방법은 반환 값을 목록으로 취급하고 그 안에 인덱스하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f26562604a7b87b255854e546e57c428a05a7c6b" translate="yes" xml:space="preserve">
          <source>One way of peeking inside the internal encoding of Unicode characters is to use &lt;code&gt;unpack(&quot;C*&quot;, ...&lt;/code&gt; to get the bytes of whatever the string encoding happens to be, or &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;(&quot;U0..&quot;, ...)&lt;/code&gt; to get the bytes of the UTF-8 encoding:</source>
          <target state="translated">유니 코드 문자의 내부 인코딩 내부를 엿보는 방법 중 하나는 &lt;code&gt;unpack(&quot;C*&quot;, ...&lt;/code&gt; 을 사용하여 문자열 인코딩이 수행되는 모든 바이트를 가져 오거나 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;(&quot;U0..&quot;, ...)&lt;/code&gt; UTF-8 인코딩의 바이트를 얻으려면 :</target>
        </trans-unit>
        <trans-unit id="aa5979d9afcdae3acb920da4d4cb51dd1f70406d" translate="yes" xml:space="preserve">
          <source>One way to avoid namespace collisions in this scenario is to translate the filename into a guaranteed-unique package name, and then compile the code into that package using &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;. In the example below, each file will only be compiled once. Or, the application might choose to clean out the symbol table associated with the file after it's no longer needed. Using &lt;a href=&quot;perlapi#call_argv&quot;&gt;call_argv in perlapi&lt;/a&gt;, We'll call the subroutine &lt;code&gt;Embed::Persistent::eval_file&lt;/code&gt; which lives in the file &lt;code&gt;persistent.pl&lt;/code&gt; and pass the filename and boolean cleanup/cache flag as arguments.</source>
          <target state="translated">이 시나리오에서 네임 스페이스 충돌을 피하는 한 가지 방법은 파일 이름을 보장 된 고유 패키지 이름으로 변환 한 다음 &lt;a href=&quot;functions/eval&quot;&gt;eval을&lt;/a&gt; 사용하여 해당 패키지로 코드를 컴파일하는 것 입니다. 아래 예에서 각 파일은 한 번만 컴파일됩니다. 또는 응용 프로그램이 더 이상 필요하지 않은 파일과 관련된 기호 테이블을 정리하도록 선택할 수 있습니다. 사용 &lt;a href=&quot;perlapi#call_argv&quot;&gt;perlapi에 call_argv을&lt;/a&gt; , 우리는 서브 루틴 호출 할 수 있습니다 &lt;code&gt;Embed::Persistent::eval_file&lt;/code&gt; 파일에 살고 &lt;code&gt;persistent.pl&lt;/code&gt; 을 하고 인수로 파일 이름과 부울 정리 / 캐시 플래그를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="3bf742d4fed91595248e4e766bfc873dce09be23" translate="yes" xml:space="preserve">
          <source>One way to do this is to inject a rare call somewhere near what you're looking for. For example, you could add &lt;code&gt;&lt;a href=&quot;functions/study&quot;&gt;study&lt;/a&gt;&lt;/code&gt; before your method:</source>
          <target state="translated">이를 수행하는 한 가지 방법은 찾고자하는 곳 근처에 드문 전화를하는 것입니다. 예를 들어, 방법 전에 &lt;code&gt;&lt;a href=&quot;functions/study&quot;&gt;study&lt;/a&gt;&lt;/code&gt; 를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2f4920008fd4d756e499ea61ff8d38a964bd84a8" translate="yes" xml:space="preserve">
          <source>One way to find out how much memory is being used by Perl data structures is to install the Devel::Size module from CPAN: it gives you the minimum number of bytes required to store a particular data structure. Please be mindful of the difference between the size() and total_size().</source>
          <target state="translated">Perl 데이터 구조에서 사용중인 메모리 양을 확인하는 한 가지 방법은 CPAN에서 Devel :: Size 모듈을 설치하는 것입니다. 특정 데이터 구조를 저장하는 데 필요한 최소 바이트 수를 제공합니다. size ()와 total_size ()의 차이점에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="00322fdac947c21ed0522e06d3fcf307d762cdd8" translate="yes" xml:space="preserve">
          <source>One way to get around this macro hell is to use the dumping functions in</source>
          <target state="translated">이 매크로 지옥을 피하는 한 가지 방법은 덤프 기능을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="eeda9b7821d8b2cc38107791f4013f43a6f0fb4b" translate="yes" xml:space="preserve">
          <source>One way you can contribute is to send test results for each module that you install. If you install the CPAN::Reporter module, you have the option to automatically generate and deliver test reports to CPAN Testers whenever you run tests on a CPAN package.</source>
          <target state="translated">기여할 수있는 한 가지 방법은 설치하는 각 모듈에 대한 테스트 결과를 보내는 것입니다. CPAN :: Reporter 모듈을 설치하면 CPAN 패키지에서 테스트를 실행할 때마다 테스트 보고서를 자동으로 생성하여 CPAN 테스터에게 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31e7d725bdb8f49cf001861a4a5f8e1249780511" translate="yes" xml:space="preserve">
          <source>One work around is to apply encodings to STDOUT and STDERR as early as possible and before Test::More (or any other Test module) loads.</source>
          <target state="translated">해결 방법 중 하나는 가능한 한 빨리 Test :: More (또는 다른 테스트 모듈)로드 전에 STDOUT 및 STDERR에 인코딩을 적용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="32a8b32d9a6fd88cc288ea2d28ee5e2eb22aa577" translate="yes" xml:space="preserve">
          <source>One would use either of these:</source>
          <target state="translated">다음 중 하나를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d2c29e5eed5921eb0c039672d0a71cd9e82eb212" translate="yes" xml:space="preserve">
          <source>One-Liner Command tips</source>
          <target state="translated">하나의 라이너 명령 팁</target>
        </trans-unit>
        <trans-unit id="c123784569a1603a8fb4810445cb2d1918c306b4" translate="yes" xml:space="preserve">
          <source>One-argument system() (see &lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;), exec() (see &lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;) with redirection or shell meta-characters;</source>
          <target state="translated">리디렉션 또는 쉘 메타 문자가있는 단일 인수 시스템 () ( &lt;a href=&quot;functions/system&quot;&gt;시스템&lt;/a&gt; 참조 ), exec () ( &lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; 참조 );</target>
        </trans-unit>
        <trans-unit id="486e0bed310a26c3d92d0d575fbba324cf28a58e" translate="yes" xml:space="preserve">
          <source>One-line BLOCK may be put on one line, including curlies.</source>
          <target state="translated">컬리를 포함하여 한 줄에 한 줄 블록을 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58784e03024491cc3bfab913b657f51ddfe4ea02" translate="yes" xml:space="preserve">
          <source>One-way visibility means these firewalls try to make themselves invisible to users inside the firewall. An FTP data connection is normally created by sending your IP address to the remote server and then listening for the return connection. But the remote server will not be able to connect to you because of the firewall. For these types of firewall, FTP connections need to be done in a passive mode.</source>
          <target state="translated">단방향 가시성은 이러한 방화벽이 방화벽 내부의 사용자에게 보이지 않게하려고 함을 의미합니다. FTP 데이터 연결은 일반적으로 IP 주소를 원격 서버로 전송 한 후 리턴 연결을 수신하여 작성됩니다. 그러나 방화벽으로 인해 원격 서버가 사용자에게 연결할 수 없습니다. 이러한 유형의 방화벽의 경우 FTP 연결을 수동 모드로 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="c61018f75253ce1e2ca9788d8ce3f56d39e963aa" translate="yes" xml:space="preserve">
          <source>Only &lt;code&gt;#define&lt;/code&gt; symbols get translated; you must still correctly pack up your own arguments to pass as args for locking functions, etc.</source>
          <target state="translated">&lt;code&gt;#define&lt;/code&gt; 기호 만 번역됩니다. 잠금 함수 등을위한 인수로 전달하려면 여전히 자신의 인수를 올바르게 압축해야합니다.</target>
        </trans-unit>
        <trans-unit id="54e17eb2662bd037dd06b791727211df88880e9a" translate="yes" xml:space="preserve">
          <source>Only Intel C++ Compiler v12.1 has been tested. Other versions probably will work. Using Intel C++ Compiler instead of Visual C has the benefit of C99 compatibility which is needed by some CPAN XS modules, while maintaining compatibility with Visual C object code and Visual C debugging infrastructure unlike GCC.</source>
          <target state="translated">Intel C ++ Compiler v12.1 만 테스트되었습니다. 다른 버전도 작동 할 것입니다. Visual C 대신 Intel C ++ Compiler를 사용하면 일부 CPAN XS 모듈에 필요한 C99 호환성의 이점이 있지만 GCC와 달리 Visual C 개체 코드 및 Visual C 디버깅 인프라와의 호환성을 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="833cc9382a3040aac18b72415747288176c0756d" translate="yes" xml:space="preserve">
          <source>Only available in 5.9 and later.</source>
          <target state="translated">5.9 이상에서만 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="791c96ad0d89f4c2a397055a16ea908da3689beb" translate="yes" xml:space="preserve">
          <source>Only certain operations originating outside Perl should be affected, as follows:</source>
          <target state="translated">Perl 외부에서 시작된 특정 작업 만 다음과 같이 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="332e2ea6f0f288093c9c025ee61a2877052c734b" translate="yes" xml:space="preserve">
          <source>Only good for changing &quot;owner&quot; and &quot;other&quot; read-write access. (RISC OS)</source>
          <target state="translated">&quot;소유자&quot;및 &quot;기타&quot;읽기 / 쓰기 액세스 변경에만 적합합니다. (RISC OS)</target>
        </trans-unit>
        <trans-unit id="066c19c4ab7873f5036df4d41c91cf9966174fcb" translate="yes" xml:space="preserve">
          <source>Only good for changing &quot;owner&quot; read-write access, &quot;group&quot;, and &quot;other&quot; bits are meaningless. (Win32)</source>
          <target state="translated">&quot;소유자&quot;읽기 / 쓰기 액세스, &quot;그룹&quot;및 &quot;기타&quot;비트 변경에만 적합합니다. (Win32)</target>
        </trans-unit>
        <trans-unit id="e35c0d1762bd110103b5f686e3235899e75efbd0" translate="yes" xml:space="preserve">
          <source>Only hexadecimal digits are valid between the braces. If an invalid character is encountered, a warning will be issued and the invalid character and all subsequent characters (valid or invalid) within the braces will be discarded.</source>
          <target state="translated">중괄호 사이에는 16 진수 만 유효합니다. 유효하지 않은 문자가 발견되면 경고가 발행되고 중괄호 내의 유효하지 않은 문자 및 모든 후속 문자 (유효 또는 유효하지 않은 문자)는 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="575a185473fa8007dc4a01bd9786576149895549" translate="yes" xml:space="preserve">
          <source>Only hexadecimal digits are valid following &lt;code&gt;\x&lt;/code&gt; . When &lt;code&gt;\x&lt;/code&gt; is followed by fewer than two valid digits, any valid digits will be zero-padded. This means that &lt;code&gt;\x7&lt;/code&gt; will be interpreted as &lt;code&gt;\x07&lt;/code&gt; , and a lone &lt;code&gt;&quot;\x&quot;&lt;/code&gt; will be interpreted as &lt;code&gt;\x00&lt;/code&gt; . Except at the end of a string, having fewer than two valid digits will result in a warning. Note that although the warning says the illegal character is ignored, it is only ignored as part of the escape and will still be used as the subsequent character in the string. For example:</source>
          <target state="translated">&lt;code&gt;\x&lt;/code&gt; 뒤에는 16 진수 만 유효합니다 . 경우 &lt;code&gt;\x&lt;/code&gt; 두 개 미만의 유효 숫자 뒤에, 유효한 숫자 제로 패딩 된 것이다. 이것은 &lt;code&gt;\x7&lt;/code&gt; 이 &lt;code&gt;\x07&lt;/code&gt; 로 해석되고 , &lt;code&gt;&quot;\x&quot;&lt;/code&gt; 는 &lt;code&gt;\x00&lt;/code&gt; 으로 해석 된다는 것을 의미합니다 . 문자열 끝을 제외하고 유효한 숫자가 두 개 미만이면 경고가 표시됩니다. 경고에서 잘못된 문자는 무시되지만 이스케이프의 일부로 만 무시되며 문자열에서 후속 문자로 계속 사용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6fefd95a29f89da3d95e7f9f02daa15254f112a5" translate="yes" xml:space="preserve">
          <source>Only identifiers starting with letters (or underscore) are stored in a package's symbol table. All other symbols are kept in package &lt;code&gt;main&lt;/code&gt; , including all punctuation variables, like $_. In addition, when unqualified, the identifiers STDIN, STDOUT, STDERR, ARGV, ARGVOUT, ENV, INC, and SIG are forced to be in package &lt;code&gt;main&lt;/code&gt; , even when used for other purposes than their built-in ones. If you have a package called &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt;, then you can't use the qualified form of an identifier because it would be instead interpreted as a pattern match, a substitution, or a transliteration.</source>
          <target state="translated">문자 (또는 밑줄)로 시작하는 식별자 만 패키지의 기호 테이블에 저장됩니다. $ _와 같은 모든 문장 부호 변수를 포함하여 다른 모든 기호는 패키지 &lt;code&gt;main&lt;/code&gt; 에 보관됩니다 . 또한 규정되지 않은 경우, STDIN, STDOUT, STDERR, ARGV, ARGVOUT, ENV, INC 및 SIG ID 는 내장 된 것 이외의 다른 용도로 사용되는 경우에도 패키지 &lt;code&gt;main&lt;/code&gt; 에 있어야 합니다. &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; 라는 패키지가있는 경우 패턴 일치, 대체 또는 음역으로 해석되기 때문에 규정 된 형식의 식별자를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9758de0e100772430c6fab7d629b550064e3e906" translate="yes" xml:space="preserve">
          <source>Only implemented on sockets. (Win32, VMS)</source>
          <target state="translated">소켓에서만 구현됩니다. (Win32, VMS)</target>
        </trans-unit>
        <trans-unit id="59e3f78d233739ccaf48b169b4ca0ebaefa1c7ab" translate="yes" xml:space="preserve">
          <source>Only in very early releases; is a subset of</source>
          <target state="translated">매우 초기 릴리스에서만; 의 하위 집합입니다</target>
        </trans-unit>
        <trans-unit id="e3b46eafe2952d2a80f0f05636b70051fd116c6a" translate="yes" xml:space="preserve">
          <source>Only in very rare circumstances should code need to be dealing in Unicode (as opposed to native) code points. In those few cases, use &lt;code&gt;&lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;NATIVE_TO_UNI(utf8_to_uvchr_buf(...))&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">매우 드문 상황에서만 코드가 유니 코드 (기본 코드가 아닌) 코드 포인트를 처리해야합니다. 이 경우 &lt;code&gt;&lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;NATIVE_TO_UNI(utf8_to_uvchr_buf(...))&lt;/a&gt;&lt;/code&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f7a2ea2fb860587376b8c211541f4f73f5bfc66a" translate="yes" xml:space="preserve">
          <source>Only log errors:</source>
          <target state="translated">로그 오류 만 :</target>
        </trans-unit>
        <trans-unit id="150ec79437779628315de700ea569bc7019ae33a" translate="yes" xml:space="preserve">
          <source>Only meaningful if PADNAMEt_OUTER is set.</source>
          <target state="translated">PADNAMEt_OUTER가 설정된 경우에만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3938c3e89a8c33d91a1c3ac566ca87a5a31bade" translate="yes" xml:space="preserve">
          <source>Only my/our variable slots get valid names. The rest are op targets/GVs/constants which are statically allocated or resolved at compile time. These don't have names by which they can be looked up from Perl code at run time through eval&quot;&quot; the way my/our variables can be. Since they can't be looked up by &quot;name&quot; but only by their index allocated at compile time (which is usually in PL_op-&amp;gt;op_targ), wasting a name SV for them doesn't make sense.</source>
          <target state="translated">내 / 우리의 가변 슬롯 만 유효한 이름을 얻습니다. 나머지는 컴파일 타임에 정적으로 할당되거나 해결되는 op 대상 / GV / 상수입니다. 이것들은 &quot;// 변수가 할 수있는 방식&quot;으로 평가를 통해 런타임에 Perl 코드에서 조회 할 수있는 이름이 없습니다. &quot;name&quot;으로 검색 할 수없고 컴파일 타임 (일반적으로 PL_op-&amp;gt; op_targ에 있음)에 할당 된 인덱스로만 조회 할 수 있으므로 이름 SV를 낭비하는 것은 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1f33cd4a2033d06e1657cc72bf00ffb7bbc8903a" translate="yes" xml:space="preserve">
          <source>Only on VMS (where there is no ambiguity between the file and directory portions of a path) and AmigaOS (possibly due to an implementation quirk in this module) does &lt;code&gt;dirname()&lt;/code&gt; work like &lt;code&gt;fileparse($path)&lt;/code&gt; , returning just the $dirs.</source>
          <target state="translated">VMS (경로의 파일과 디렉토리 부분간에 모호성이없는 경우) 및 AmigaOS (이 모듈의 구현 문제로 인해 &lt;code&gt;fileparse($path)&lt;/code&gt; 에서만 &lt;code&gt;dirname()&lt;/code&gt; 이 fileparse ($ path) 와 같이 작동 하여 $ dirs 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cb371934ef388875a4c4834fa50d202d61748f1c" translate="yes" xml:space="preserve">
          <source>Only one encoding is allowed. If you combine modules in a program that have different encodings, only one will be actually used.</source>
          <target state="translated">하나의 인코딩 만 허용됩니다. 인코딩이 다른 프로그램에서 모듈을 결합하면 실제로 하나만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="99a4e5aa3778d9b7cf73bb7582fb4140a87cc1e7" translate="yes" xml:space="preserve">
          <source>Only one timer may be counting at once. Each call disables the previous timer, and an argument of &lt;code&gt;0&lt;/code&gt; may be supplied to cancel the previous timer without starting a new one. The returned value is the amount of time remaining on the previous timer.</source>
          <target state="translated">한 번에 하나의 타이머 만 계산할 수 있습니다. 각 호출은 이전 타이머를 비활성화하고 새 타이머를 시작하지 않고 이전 타이머를 취소하기 위해 인수 &lt;code&gt;0&lt;/code&gt; 을 제공 할 수 있습니다. 반환 된 값은 이전 타이머에 남아있는 시간입니다.</target>
        </trans-unit>
        <trans-unit id="f44c9ad6ed1548b5f164387565fa3e8cb708d77b" translate="yes" xml:space="preserve">
          <source>Only package variables (globals, even if localized) are visible to symbolic references. Lexical variables (declared with my()) aren't in a symbol table, and thus are invisible to this mechanism. For example:</source>
          <target state="translated">패키지 변수 (지역화 된 경우에도 전역 변수) 만 기호 참조에 표시됩니다. 어휘 변수 (my ()로 선언)는 기호 테이블에 없으므로이 메커니즘에는 보이지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8a4fbadaeb2851f2ac1b0ed5194eefd55b4c5de6" translate="yes" xml:space="preserve">
          <source>Only read-accesses (via fetching the value or &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt;) result in calls to the functions; the modify-accesses are performed as on a normal hash.</source>
          <target state="translated">(값을 가져 오거나 &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; ) 읽기 액세스 만 함수를 호출합니다. 수정 액세스는 일반 해시에서와 같이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="b7947c4bc8660c246e83d1a75c7b2184fd12d7e5" translate="yes" xml:space="preserve">
          <source>Only reliable on sockets. (RISC OS)</source>
          <target state="translated">소켓에서만 신뢰할 수 있습니다. (RISC OS)</target>
        </trans-unit>
        <trans-unit id="fdb6f92993012f8b0d4ace849f814451bcfe4e88" translate="yes" xml:space="preserve">
          <source>Only some of these are used by the standard styles, the others are provided for you to delve into optree mechanics, should you wish to add a new style (see &lt;a href=&quot;#add_style&quot;&gt;add_style&lt;/a&gt; below) that uses them. You can also add new ones using &lt;a href=&quot;#add_callback&quot;&gt;add_callback&lt;/a&gt;.</source>
          <target state="translated">이들 중 일부만 표준 스타일에서 사용되며 다른 스타일은 optree 역학을 탐구 할 수 있도록 제공되며, 이를 사용 하는 새 스타일을 추가하려는 경우 (아래 &lt;a href=&quot;#add_style&quot;&gt;add_style&lt;/a&gt; 참조) &lt;a href=&quot;#add_callback&quot;&gt;add_callback을&lt;/a&gt; 사용하여 새로운 것을 추가 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe3b6a74b3cb931875055e55d8dd7ade28775580" translate="yes" xml:space="preserve">
          <source>Only text files containing at least one valid POD command are found.</source>
          <target state="translated">유효한 POD 명령이 하나 이상 포함 된 텍스트 파일 만 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9f9d19343c8e9d3fc7cfa076da595c837a27fd3" translate="yes" xml:space="preserve">
          <source>Only the INPUT part of this is implemented (Perl to XSUB) and there are no known users in core or on CPAN.</source>
          <target state="translated">이 중 INPUT 부분 만 구현되며 (Perl to XSUB) 코어 또는 CPAN에 알려진 사용자가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3e92fe265d981838f6731ee2a1313d924147a101" translate="yes" xml:space="preserve">
          <source>Only the best match for &lt;code&gt;S&lt;/code&gt; is considered. (This is important only if &lt;code&gt;S&lt;/code&gt; has capturing parentheses, and backreferences are used somewhere else in the whole regular expression.)</source>
          <target state="translated">&lt;code&gt;S&lt;/code&gt; 에 대한 최상의 일치 만 고려됩니다. ( &lt;code&gt;S&lt;/code&gt; 에 캡처 괄호가 있고 역 참조가 전체 정규식의 다른 곳에서 사용되는 경우에만 중요합니다 .)</target>
        </trans-unit>
        <trans-unit id="8e81698472dd458b4e2c811d33c204c45a731d7f" translate="yes" xml:space="preserve">
          <source>Only the latest runtime is supported, currently &lt;code&gt;0.9d fix 03&lt;/code&gt;. Perl may run under earlier versions of EMX, but this is not tested.</source>
          <target state="translated">최신 런타임 (현재 &lt;code&gt;0.9d fix 03&lt;/code&gt; 만 지원됩니다 . Perl은 이전 버전의 EMX에서 실행될 수 있지만 테스트되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="ffed3ab3981beea3a9602d82e26d788b9e9c1484" translate="yes" xml:space="preserve">
          <source>Only the modification time is updated. (VMS, RISC OS)</source>
          <target state="translated">수정 시간 만 업데이트됩니다. (VMS, RISC OS)</target>
        </trans-unit>
        <trans-unit id="9aa8446a580db25edb8f05217d7fb57147e13abf" translate="yes" xml:space="preserve">
          <source>Only up to Perl 5.9.4</source>
          <target state="translated">최대 Perl 5.9.4</target>
        </trans-unit>
        <trans-unit id="ac1ac5484f948b783774a56425a6df37a8f81a3b" translate="yes" xml:space="preserve">
          <source>Only valid on r-magic, returns the integer value of the REGEX stored in the MAGIC.</source>
          <target state="translated">r-magic에서만 유효하며 MAGIC에 저장된 REGEX의 정수 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9f66fc81372c8ac766a246f4baea414733aad7cf" translate="yes" xml:space="preserve">
          <source>Only valid on r-magic, returns the string that generated the regexp.</source>
          <target state="translated">r-magic에서만 유효하며 정규 표현식을 생성 한 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a61aeee0d09958da7f9004eaa2f24e389c377add" translate="yes" xml:space="preserve">
          <source>Only when perl was compiled with ithreads.</source>
          <target state="translated">perl이 ithreads로 컴파일 된 경우에만.</target>
        </trans-unit>
        <trans-unit id="cd0ef3273488ddac67311854e00313faa5aef30e" translate="yes" xml:space="preserve">
          <source>Oodles of very useful information in there - this seems to be the way forward.</source>
          <target state="translated">거기에 매우 유용한 정보가 있습니다. 이것은 앞으로 나아갈 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="95ff9f7a98d97e5bb7dd5d8797ddd23ecbc3a49a" translate="yes" xml:space="preserve">
          <source>Oops, we forgot one thing: what if there are spaces at the start of the pattern? &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;  U*&quot;, @stuff)&lt;/code&gt; will have &lt;code&gt;U&lt;/code&gt; as the first active character, even though it's not the first thing in the pattern. In this case, we have to advance &lt;code&gt;patcopy&lt;/code&gt; along with &lt;code&gt;pat&lt;/code&gt; when we see spaces:</source>
          <target state="translated">죄송합니다. 패턴 시작 부분에 공백이 있으면 어떻게해야합니까? &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot; U*&quot;, @stuff)&lt;/code&gt; 은 패턴에서 첫 번째 문자가 아니지만 &lt;code&gt;U&lt;/code&gt; 를 첫 번째 활성 문자로 사용합니다. 이 경우 공간을 볼 때 &lt;code&gt;pat&lt;/code&gt; 과 함께 &lt;code&gt;patcopy&lt;/code&gt; 를 진행 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="74d23243f911dfb26f7142c0a3c3910d6d1436bc" translate="yes" xml:space="preserve">
          <source>Opcode</source>
          <target state="translated">Opcode</target>
        </trans-unit>
        <trans-unit id="d74efeac75c3ed1e29e1ef5d2a48fa327033703a" translate="yes" xml:space="preserve">
          <source>Opcode - Disable named opcodes when compiling perl code</source>
          <target state="translated">Opcode-Perl 코드를 컴파일 할 때 명명 된 opcode를 비활성화합니다</target>
        </trans-unit>
        <trans-unit id="f07e565d51e16d912b38ef0d870eb764e49b25e3" translate="yes" xml:space="preserve">
          <source>Opcode Functions</source>
          <target state="translated">오피 코드 기능</target>
        </trans-unit>
        <trans-unit id="96b61e5d9d0edd94f6948898f1398f5d478335a2" translate="yes" xml:space="preserve">
          <source>Open &quot;membername&quot; from the zip file for reading.</source>
          <target state="translated">읽을 zip 파일에서 &quot;membername&quot;을여십시오.</target>
        </trans-unit>
        <trans-unit id="55f7ee4c6a28ca478d6d447371d4c70238f47b16" translate="yes" xml:space="preserve">
          <source>Open /dev/tty and use the TIOCNOTTY ioctl on it. See</source>
          <target state="translated">/ dev / tty를 열고 TIOCNOTTY ioctl을 사용하십시오. 보다</target>
        </trans-unit>
        <trans-unit id="bdb6e0b133b1b1b5b97afd41a0d0173daaa4add6" translate="yes" xml:space="preserve">
          <source>Open Edition (UNIX System Services) from V2R8 onward does support #!/path/to/perl script invocation. There is a PTF available from IBM for V2R7 that will allow shell/kernel support for #!. USS releases prior to V2R7 did not support the #! means of script invocation. If you are running V2R6 or earlier then see:</source>
          <target state="translated">V2R8 이후의 Open Edition (UNIX 시스템 서비스)은 #! / path / to / perl 스크립트 호출을 지원합니다. #!에 대한 쉘 / 커널 지원을 허용하는 V2R7 용 IBM의 PTF가 있습니다. V2R7 이전의 USS 릴리스는 #! 스크립트 호출 수단. V2R6 이하를 실행중인 경우 다음을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6a72f9cc67788da43d43bb9ed1f39ccdfc57b884" translate="yes" xml:space="preserve">
          <source>Open Perl IDE is an integrated development environment for writing and debugging Perl scripts with ActiveState's ActivePerl distribution under Windows 95/98/NT/2000.</source>
          <target state="translated">Open Perl IDE는 Windows 95 / 98 / NT / 2000에서 ActiveState의 ActivePerl 배포를 사용하여 Perl 스크립트를 작성하고 디버깅하기위한 통합 개발 환경입니다.</target>
        </trans-unit>
        <trans-unit id="23e95096990f8472afd6cb3709ce6af6451d33e6" translate="yes" xml:space="preserve">
          <source>Open a directory for reading.</source>
          <target state="translated">읽을 디렉토리를여십시오.</target>
        </trans-unit>
        <trans-unit id="8ad49f69af5decd196c780b9f3d0aaa3e3816d7b" translate="yes" xml:space="preserve">
          <source>Open a file for read and write.</source>
          <target state="translated">읽고 쓸 파일을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="1e59fee2b2d0c9f3865876e8e0e389d326d3f7c1" translate="yes" xml:space="preserve">
          <source>Open a file for reading for writing. This returns file descriptors, not Perl filehandles. Use &lt;code&gt;POSIX::close&lt;/code&gt; to close the file.</source>
          <target state="translated">쓰기 위해 읽을 파일을 엽니 다. 이것은 Perl 파일 핸들이 아닌 파일 디스크립터를 리턴합니다. &lt;code&gt;POSIX::close&lt;/code&gt; 를 사용 하여 파일을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="6c23e6c0a506e51b8807fe030bb649eaa2c7d5d5" translate="yes" xml:space="preserve">
          <source>Open a file for write, with truncation.</source>
          <target state="translated">잘림과 함께 쓸 파일을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="4308ff2808cb74655d1f6985fb86c3f779077365" translate="yes" xml:space="preserve">
          <source>Open a file read-only with mode 0666.</source>
          <target state="translated">모드 0666으로 파일을 읽기 전용으로 엽니 다.</target>
        </trans-unit>
        <trans-unit id="83b3247daf1ae38653a1c2f6dc56f1f4dd823340" translate="yes" xml:space="preserve">
          <source>Open a process for both reading and writing using open2()</source>
          <target state="translated">open2 ()를 사용하여 읽고 쓰는 프로세스를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="2f8a8512d160e2040075be8a77906336494c9074" translate="yes" xml:space="preserve">
          <source>Open a process for reading, writing, and error handling using open3()</source>
          <target state="translated">open3 ()을 사용하여 읽기, 쓰기 및 오류 처리를위한 프로세스 열기</target>
        </trans-unit>
        <trans-unit id="79ce744f7faf84a934a5966a77055041e905f34c" translate="yes" xml:space="preserve">
          <source>Open returns nonzero on success, the undefined value otherwise. If the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; involved a pipe, the return value happens to be the pid of the subprocess.</source>
          <target state="translated">Open은 성공하면 0이 아닌 값을 반환하고 그렇지 않으면 정의되지 않은 값을 반환합니다. &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 것이 파이프와 관련된 경우 리턴 값은 서브 프로세스의 pid가됩니다.</target>
        </trans-unit>
        <trans-unit id="78b623ce85a0de7052165209a2216ebe49f4e867" translate="yes" xml:space="preserve">
          <source>Open returns nonzero on success, the undefined value otherwise. If the &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; involved a pipe, the return value happens to be the pid of the subprocess.</source>
          <target state="translated">Open은 성공하면 0이 아닌 값을 반환하고 그렇지 않으면 정의되지 않은 값을 반환합니다. &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 것이 파이프와 관련된 경우 리턴 값은 서브 프로세스의 pid가됩니다.</target>
        </trans-unit>
        <trans-unit id="47834b64146be82f867d9923797633975d9cd92f" translate="yes" xml:space="preserve">
          <source>Open should (perhaps indirectly) call &lt;code&gt;PerlIO_allocate()&lt;/code&gt; to allocate a slot in the table and associate it with the layers information for the opened file, by calling &lt;code&gt;PerlIO_push&lt;/code&gt; . The</source>
          <target state="translated">Open은 &lt;code&gt;PerlIO_allocate()&lt;/code&gt; 를 호출 하여 테이블에 슬롯을 할당하고 &lt;code&gt;PerlIO_push&lt;/code&gt; 를 호출하여 열린 파일의 레이어 정보와 연결해야합니다 . 그만큼</target>
        </trans-unit>
        <trans-unit id="fa04c7c6f525f721026d1ba438790f3fcc864164" translate="yes" xml:space="preserve">
          <source>Open the syslog with options &lt;code&gt;ndelay&lt;/code&gt; and &lt;code&gt;pid&lt;/code&gt; , and with facility &lt;code&gt;LOCAL0&lt;/code&gt; :</source>
          <target state="translated">옵션 &lt;code&gt;ndelay&lt;/code&gt; 및 &lt;code&gt;pid&lt;/code&gt; 및 설비 &lt;code&gt;LOCAL0&lt;/code&gt; 으로 syslog 를여십시오 .</target>
        </trans-unit>
        <trans-unit id="49536a6420d53dc725b117e3d37bfc34dfb9bef1" translate="yes" xml:space="preserve">
          <source>OpenBSD core dumps from getprotobyname_r and getservbyname_r with ithreads</source>
          <target state="translated">ithreads가있는 getprotobyname_r 및 getservbyname_r의 OpenBSD 코어 덤프</target>
        </trans-unit>
        <trans-unit id="d32dc42d00fa4f78f0a59f030ed60cd6a30b3295" translate="yes" xml:space="preserve">
          <source>OpenVMS Alpha v7.3-1 and later and all version of OpenVMS I64 support case sensitivity as a process setting (see &lt;code&gt;SET PROCESS
/CASE_LOOKUP=SENSITIVE&lt;/code&gt; ). Perl does not currently support case sensitivity on VMS, but it may in the future, so Perl programs should use the &lt;code&gt;File::Spec-&amp;gt;case_tolerant&lt;/code&gt; method to determine the state, and not the &lt;code&gt;$^O&lt;/code&gt; variable.</source>
          <target state="translated">OpenVMS Alpha v7.3-1 이상 및 모든 버전의 OpenVMS I64는 대소 문자 구분을 프로세스 설정으로 지원합니다 ( &lt;code&gt;SET PROCESS /CASE_LOOKUP=SENSITIVE&lt;/code&gt; ). Perl은 현재 VMS에서 대소 문자 구분을 지원하지 않지만 앞으로는 &lt;code&gt;File::Spec-&amp;gt;case_tolerant&lt;/code&gt; 수 있으므로 Perl 프로그램은 File :: Spec-&amp;gt; case_tolerant 메소드를 사용하여 &lt;code&gt;$^O&lt;/code&gt; 변수가 아닌 상태를 판별해야 합니다.</target>
        </trans-unit>
        <trans-unit id="580bd0fefd9022c163462e267d5f62605679e1bf" translate="yes" xml:space="preserve">
          <source>Opening Binary Files</source>
          <target state="translated">이진 파일 열기</target>
        </trans-unit>
        <trans-unit id="3b6c1a6dbd679781e98b430deca927902564168e" translate="yes" xml:space="preserve">
          <source>Opening Pipes</source>
          <target state="translated">파이프 열기</target>
        </trans-unit>
        <trans-unit id="97614657c24973c63e30d6aea12f0ee16c28cc0b" translate="yes" xml:space="preserve">
          <source>Opening Text Files</source>
          <target state="translated">텍스트 파일 열기</target>
        </trans-unit>
        <trans-unit id="36680b4c4dae060cef49428930207438c7efaa37" translate="yes" xml:space="preserve">
          <source>Opening Text Files for Reading</source>
          <target state="translated">읽을 텍스트 파일 열기</target>
        </trans-unit>
        <trans-unit id="2a72037dbe3a876109b6617803140785c781433b" translate="yes" xml:space="preserve">
          <source>Opening Text Files for Writing</source>
          <target state="translated">쓰기 위해 텍스트 파일 열기</target>
        </trans-unit>
        <trans-unit id="d41c1a93b08d5c6da84630f4e7549a5cfa0c9f29" translate="yes" xml:space="preserve">
          <source>Opening a Berkeley DB Database File</source>
          <target state="translated">버클리 DB 데이터베이스 파일 열기</target>
        </trans-unit>
        <trans-unit id="c901450d25c1b4adffc158756d930772312effed" translate="yes" xml:space="preserve">
          <source>Opening a process does not automatically flush output handles on some platforms. (SunOS, Solaris, HP-UX)</source>
          <target state="translated">프로세스를 열면 일부 플랫폼에서 출력 핸들이 자동으로 플러시되지 않습니다. (SunOS, Solaris, HP-UX)</target>
        </trans-unit>
        <trans-unit id="b294c249cb9dd744fe8333a0cf9a3eaca337d759" translate="yes" xml:space="preserve">
          <source>Opening and setup functions</source>
          <target state="translated">열기 및 설정 기능</target>
        </trans-unit>
        <trans-unit id="9d1b0daa9340247fc5dd5775b7b3c96ab82ed183" translate="yes" xml:space="preserve">
          <source>Opening brace lines up with &quot;if&quot; when conditional spans multiple lines; should be at end-of-line otherwise</source>
          <target state="translated">조건부가 여러 줄에 걸쳐있을 경우 &quot;if&quot;로 괄호를여십시오. 그렇지 않으면 라인의 끝에 있어야합니다</target>
        </trans-unit>
        <trans-unit id="4a1d6b2927f0e3d3a000bd5c08d3176bb52e234e" translate="yes" xml:space="preserve">
          <source>Opening bracket for a lightweight callback. See &lt;a href=&quot;perlcall#LIGHTWEIGHT-CALLBACKS&quot;&gt;LIGHTWEIGHT CALLBACKS in perlcall&lt;/a&gt;.</source>
          <target state="translated">가벼운 콜백을위한 열기 브래킷. &lt;a href=&quot;perlcall#LIGHTWEIGHT-CALLBACKS&quot;&gt;perlcall의 LIGHTWEIGHT CALLBACKS를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2922ae0d4b2356e8683f8338a16e139ec4c04e6a" translate="yes" xml:space="preserve">
          <source>Opening bracket for arguments on a callback. See &lt;code&gt;PUTBACK&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">콜백의 인수에 대한 여는 괄호. &lt;code&gt;PUTBACK&lt;/code&gt; 및 &lt;a href=&quot;perlcall&quot;&gt;perlcall을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e0cd04a850fb6ef4b1c1ae0773c22c62016e5236" translate="yes" xml:space="preserve">
          <source>Opening bracket for temporaries on a callback. See &lt;code&gt;FREETMPS&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">콜백에서 임시 용 여는 괄호. &lt;code&gt;FREETMPS&lt;/code&gt; 및 &lt;a href=&quot;perlcall&quot;&gt;perlcall을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3379b419b90643ab2744dfbdcecf5edbb46257a1" translate="yes" xml:space="preserve">
          <source>Opening bracket on a callback. See &lt;code&gt;LEAVE&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">콜백에서 여는 괄호. &lt;code&gt;LEAVE&lt;/code&gt; 및 &lt;a href=&quot;perlcall&quot;&gt;perlcall을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fcb5320c0f77aa06e6c4f3f19f91a0a627e401dd" translate="yes" xml:space="preserve">
          <source>Opening curly on same line as keyword, if possible, otherwise line up.</source>
          <target state="translated">가능하면 키워드와 같은 줄에 곱슬 곱슬하게, 그렇지 않으면 줄을 긋습니다.</target>
        </trans-unit>
        <trans-unit id="702f344a10799adb9c373ae43617c29a1d640fe4" translate="yes" xml:space="preserve">
          <source>Opening files for read-write is currently not supported if they use stdio (normal perl file handles).</source>
          <target state="translated">stdio (일반적인 perl 파일 핸들)를 사용하는 경우 읽기 / 쓰기를위한 파일 열기는 현재 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f85c9c937148eb202d62793f91340ba09b2f7a5e" translate="yes" xml:space="preserve">
          <source>Opening the data file in write-only or append mode is not supported.</source>
          <target state="translated">쓰기 전용 또는 추가 모드에서 데이터 파일을 여는 것은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c745d61fd7e06451beaeff422ae86fd1baafa519" translate="yes" xml:space="preserve">
          <source>Opens &lt;code&gt;$output&lt;/code&gt; in append mode.</source>
          <target state="translated">추가 모드에서 &lt;code&gt;$output&lt;/code&gt; 을 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="83d174f108cd7d61c427811f31c1c3a17b3fd039" translate="yes" xml:space="preserve">
          <source>Opens a directory named EXPR for processing by &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/telldir&quot;&gt;telldir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/seekdir&quot;&gt;seekdir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/closedir&quot;&gt;closedir&lt;/a&gt;&lt;/code&gt;. Returns true if successful. DIRHANDLE may be an expression whose value can be used as an indirect dirhandle, usually the real dirhandle name. If DIRHANDLE is an undefined scalar variable (or array or hash element), the variable is assigned a reference to a new anonymous dirhandle; that is, it's autovivified. DIRHANDLEs have their own namespace separate from FILEHANDLEs.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/telldir&quot;&gt;telldir&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/seekdir&quot;&gt;seekdir&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/closedir&quot;&gt;closedir&lt;/a&gt;&lt;/code&gt; 로 처리 할 EXPR이라는 디렉토리를 엽니 다 . 성공하면 true를 반환합니다. DIRHANDLE은 값이 간접 dirhandle, 일반적으로 실제 dirhandle 이름으로 사용될 수있는 표현식 일 수 있습니다. DIRHANDLE이 정의되지 않은 스칼라 변수 (또는 배열 또는 해시 요소) 인 경우 변수에 새 익명 디렉토리에 대한 참조가 지정됩니다. 즉, 자동 활성화됩니다. DIRHANDLE에는 FILEHANDLE과 별개의 고유 네임 스페이스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bde0bd94d408d74305c3ef236f8e210809c61889" translate="yes" xml:space="preserve">
          <source>Opens a directory named EXPR for processing by &lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;telldir&quot;&gt;telldir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;seekdir&quot;&gt;seekdir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;rewinddir&quot;&gt;rewinddir&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;closedir&quot;&gt;closedir&lt;/a&gt;&lt;/code&gt;. Returns true if successful. DIRHANDLE may be an expression whose value can be used as an indirect dirhandle, usually the real dirhandle name. If DIRHANDLE is an undefined scalar variable (or array or hash element), the variable is assigned a reference to a new anonymous dirhandle; that is, it's autovivified. DIRHANDLEs have their own namespace separate from FILEHANDLEs.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;telldir&quot;&gt;telldir&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;seekdir&quot;&gt;seekdir&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;rewinddir&quot;&gt;rewinddir&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;closedir&quot;&gt;closedir&lt;/a&gt;&lt;/code&gt; 로 처리 할 EXPR이라는 디렉토리를 엽니 다 . 성공하면 true를 반환합니다. DIRHANDLE은 값이 간접 dirhandle, 일반적으로 실제 dirhandle 이름으로 사용될 수있는 표현식 일 수 있습니다. DIRHANDLE이 정의되지 않은 스칼라 변수 (또는 배열 또는 해시 요소) 인 경우 변수에 새 익명 디렉토리에 대한 참조가 지정됩니다. 즉, 자동 활성화됩니다. DIRHANDLE에는 FILEHANDLE과 별개의 고유 네임 스페이스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef6eec3f73e02b66c5dbdd58e24c78d1b02394cb" translate="yes" xml:space="preserve">
          <source>Opens a pair of connected pipes like the corresponding system call. Note that if you set up a loop of piped processes, deadlock can occur unless you are very careful. In addition, note that Perl's pipes use IO buffering, so you may need to set &lt;code&gt;$|&lt;/code&gt; to flush your WRITEHANDLE after each command, depending on the application.</source>
          <target state="translated">해당 시스템 호출과 같은 연결된 파이프 쌍을 엽니 다. 파이프 프로세스의 루프를 설정하면 매우주의하지 않으면 교착 상태가 발생할 수 있습니다. 또한 Perl의 파이프는 IO 버퍼링을 사용하므로 &lt;code&gt;$|&lt;/code&gt; 를 설정해야 할 수도 있습니다. 응용 프로그램에 따라 각 명령 후에 WRITEHANDLE을 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="97d9deba78acd708222827724c50fc7000bf21a2" translate="yes" xml:space="preserve">
          <source>Opens a socket of the specified kind and attaches it to filehandle SOCKET. DOMAIN, TYPE, and PROTOCOL are specified the same as for the syscall of the same name. You should &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; first to get the proper definitions imported. See the examples in &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">지정된 종류의 소켓을 열고 파일 핸들 SOCKET에 연결합니다. DOMAIN, TYPE 및 PROTOCOL은 동일한 이름의 syscall과 동일하게 지정됩니다. 올바른 정의를 가져 오려면 먼저 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; 사용해야 &lt;a href=&quot;functions/use&quot;&gt;합니다&lt;/a&gt; . &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;소켓 : perlipc의 클라이언트 / 서버 통신&lt;/a&gt; 의 예제를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1bf5e36d7b7be8ff46fbdc02b28950f2a5493007" translate="yes" xml:space="preserve">
          <source>Opens a socket of the specified kind and attaches it to filehandle SOCKET. DOMAIN, TYPE, and PROTOCOL are specified the same as for the syscall of the same name. You should &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; first to get the proper definitions imported. See the examples in &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">지정된 종류의 소켓을 열고 파일 핸들 SOCKET에 연결합니다. DOMAIN, TYPE 및 PROTOCOL은 동일한 이름의 syscall과 동일하게 지정됩니다. 올바른 정의를 가져 오려면 먼저 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; 사용해야 &lt;a href=&quot;use&quot;&gt;합니다&lt;/a&gt; . &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;소켓 : perlipc의 클라이언트 / 서버 통신&lt;/a&gt; 의 예제를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f043104d316702a10e0ee9e23884fe89eeee7102" translate="yes" xml:space="preserve">
          <source>Opens the file whose filename is given by EXPR, and associates it with FILEHANDLE.</source>
          <target state="translated">EXPR에서 제공 한 파일 이름을 가진 파일을 열고 FILEHANDLE과 연결합니다.</target>
        </trans-unit>
        <trans-unit id="f8d3156ec9740e3cf785b92426587c9913bf7a48" translate="yes" xml:space="preserve">
          <source>Opens the file whose filename is given by FILENAME, and associates it with FILEHANDLE. If FILEHANDLE is an expression, its value is used as the real filehandle wanted; an undefined scalar will be suitably autovivified. This function calls the underlying operating system's</source>
          <target state="translated">FILENAME에서 파일 이름을 지정한 파일을 열고 FILEHANDLE과 연결합니다. FILEHANDLE이 표현식 인 경우 해당 값은 원하는 실제 파일 핸들로 사용됩니다. 정의되지 않은 스칼라가 적절하게 자동 활성화됩니다. 이 함수는 기본 운영 체제를 호출합니다</target>
        </trans-unit>
        <trans-unit id="4d5a806f4d052ec496b3b922107438a0577f84fc" translate="yes" xml:space="preserve">
          <source>Opens the syslog. &lt;code&gt;$ident&lt;/code&gt; is prepended to every message. &lt;code&gt;$logopt&lt;/code&gt; contains zero or more of the options detailed below. &lt;code&gt;$facility&lt;/code&gt; specifies the part of the system to report about, for example &lt;code&gt;LOG_USER&lt;/code&gt; or &lt;code&gt;LOG_LOCAL0&lt;/code&gt; : see &lt;a href=&quot;#Facilities&quot;&gt;Facilities&lt;/a&gt; for a list of well-known facilities, and your &lt;code&gt;syslog(3)&lt;/code&gt; documentation for the facilities available in your system. Check &lt;a href=&quot;#SEE-ALSO&quot;&gt;SEE ALSO&lt;/a&gt; for useful links. Facility can be given as a string or a numeric macro.</source>
          <target state="translated">syslog를 엽니 다. 모든 메시지 앞에 &lt;code&gt;$ident&lt;/code&gt; 가 붙습니다. &lt;code&gt;$logopt&lt;/code&gt; 에는 아래에 설명 된 옵션 중 0 개 이상이 포함되어 있습니다. &lt;code&gt;$facility&lt;/code&gt; 는 &lt;code&gt;LOG_USER&lt;/code&gt; 또는 &lt;code&gt;LOG_LOCAL0&lt;/code&gt; 과 같이보고 할 시스템 부분을 지정합니다 . 잘 알려진 기능 목록 은 &lt;a href=&quot;#Facilities&quot;&gt;기능&lt;/a&gt; 을 참조 하고 시스템에서 사용 가능한 기능은 &lt;code&gt;syslog(3)&lt;/code&gt; 문서를 참조하십시오. 유용한 링크도 &lt;a href=&quot;#SEE-ALSO&quot;&gt;참조&lt;/a&gt; 하십시오 . 기능은 문자열 또는 숫자 매크로로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7befdfbc60eb47b3289957505fb12ce62daabea" translate="yes" xml:space="preserve">
          <source>Operating System Interfaces</source>
          <target state="translated">운영 체제 인터페이스</target>
        </trans-unit>
        <trans-unit id="b9967a65c2c4c5007de8b77bf65865521f0d26c6" translate="yes" xml:space="preserve">
          <source>Operating on references to hashes.</source>
          <target state="translated">해시에 대한 참조에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c28848b2a51553304abcd6de3ae0236ffb496efe" translate="yes" xml:space="preserve">
          <source>Operations with overloaded operators preserve the arguments which is exactly what you expect.</source>
          <target state="translated">연산자가 오버로드 된 작업은 정확히 예상 한 인수를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="d4e4327f6fb8077a49e03daa6c0ea206ecb5c16a" translate="yes" xml:space="preserve">
          <source>Operations with overloaded operators preserve the arguments, which is exactly what you expect.</source>
          <target state="translated">오버로드 된 연산자가있는 작업은 인수를 그대로 유지합니다.</target>
        </trans-unit>
        <trans-unit id="f921f14a57cf5d524fbd5fad00e7ed999feb448d" translate="yes" xml:space="preserve">
          <source>Operator Names and Operator Lists</source>
          <target state="translated">운영자 이름 및 운영자 목록</target>
        </trans-unit>
        <trans-unit id="f299c884a708c75ca75144e361f0c5cf282b235f" translate="yes" xml:space="preserve">
          <source>Operator Overloading</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53d6250055dd8231245476710d174685174b7d89" translate="yes" xml:space="preserve">
          <source>Operator Precedence and Associativity</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11c9953040dd3157f9326929003c9899b7cffb21" translate="yes" xml:space="preserve">
          <source>Operator associativity</source>
          <target state="translated">연산자 연관성</target>
        </trans-unit>
        <trans-unit id="08ca8c19d61f0facd586cd4f482f39a253b12167" translate="yes" xml:space="preserve">
          <source>Operator implementations (the values) can be subroutines, references to subroutines, or anonymous subroutines - in other words, anything legal inside a &lt;code&gt;&amp;amp;{ ... }&lt;/code&gt; call. Values specified as strings are interpreted as method names. Thus</source>
          <target state="translated">연산자 구현 (값)은 서브 루틴, 서브 루틴에 대한 참조 또는 익명 서브 루틴 일 수 있습니다. 즉, &lt;code&gt;&amp;amp;{ ... }&lt;/code&gt; 호출 내에서 합법적 인 것 입니다. 문자열로 지정된 값은 메소드 이름으로 해석됩니다. 그러므로</target>
        </trans-unit>
        <trans-unit id="4f99a8916efac564a63d50ce560cad0dd70e1540" translate="yes" xml:space="preserve">
          <source>Operator names are typically small lowercase words like enterloop, leaveloop, last, next, redo etc. Sometimes they are rather cryptic like gv2cv, i_ncmp and ftsvtx.</source>
          <target state="translated">연산자 이름은 일반적으로 enterloop, leaveloop, last, next, redo 등과 같은 작은 소문자입니다. 때로는 gv2cv, i_ncmp 및 ftsvtx와 같이 다소 암호가 사용되기도합니다.</target>
        </trans-unit>
        <trans-unit id="685048571a4f4db99cb190b311def264fc71eb0e" translate="yes" xml:space="preserve">
          <source>Operator precedence</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b559bbb40846a93d37a125fab7a9a1b57c0dd2f9" translate="yes" xml:space="preserve">
          <source>Operator precedence and associativity work in Perl more or less like they do in mathematics.</source>
          <target state="translated">연산자 우선 순위와 연관성은 수학에서와 비슷하게 Perl에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6852b1cd2bb1031ac4d81d694fd94535c3eb3d11" translate="yes" xml:space="preserve">
          <source>Operator tags can be used to refer to groups (or sets) of operators. Tag names always begin with a colon. The Opcode module defines several optags and the user can define others using the define_optag function.</source>
          <target state="translated">연산자 태그는 연산자 그룹 (또는 세트)을 나타내는 데 사용할 수 있습니다. 태그 이름은 항상 콜론으로 시작합니다. Opcode 모듈은 여러 optag를 정의하며 사용자는 define_optag 함수를 사용하여 다른 optag를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="63e0a2d0a1f37e46caa267d78be1feaf655b0cda" translate="yes" xml:space="preserve">
          <source>Operators dealing with filenames are examples.</source>
          <target state="translated">파일 이름을 다루는 연산자가 예입니다.</target>
        </trans-unit>
        <trans-unit id="55ddd8565a51d103a65dc3c453ea6bce04b13905" translate="yes" xml:space="preserve">
          <source>Operators such as &lt;code&gt;**&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sin&quot;&gt;sin&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; force arguments to floating point format.</source>
          <target state="translated">&lt;code&gt;**&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sin&quot;&gt;sin&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; 와 같은 연산자는 인수를 부동 소수점 형식으로 강제합니다.</target>
        </trans-unit>
        <trans-unit id="864704fd78dbf2c79b9e58c4ea43f3220669cded" translate="yes" xml:space="preserve">
          <source>Ops such as chdir obviously effect the process as a whole and not just the code in the compartment. Ops such as rand and srand have a similar but more subtle effect.</source>
          <target state="translated">chdir과 같은 작업은 구획의 코드뿐만 아니라 전체적으로 프로세스에 영향을 미칩니다. rand 및 srand와 같은 작전은 비슷하지만 더 미묘한 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="977af567e0cb291a9f2082343e1b048e5433a7e1" translate="yes" xml:space="preserve">
          <source>Opsets may be manipulated using the perl bit vector operators &amp;amp; (and), | (or), ^ (xor) and ~ (negate/invert).</source>
          <target state="translated">펄 비트 벡터 연산자를 사용하여 옵셋을 조작 할 수 있습니다. (또는), ^ (xor) 및 ~ (negate / invert).</target>
        </trans-unit>
        <trans-unit id="6221772a58b20793863ce371d773cbe75426798d" translate="yes" xml:space="preserve">
          <source>OptiPerl is a Windows IDE with simulated CGI environment, including debugger and syntax-highlighting editor.</source>
          <target state="translated">OptiPerl은 디버거 및 구문 강조 편집기를 포함하여 시뮬레이션 된 CGI 환경을 갖춘 Windows IDE입니다.</target>
        </trans-unit>
        <trans-unit id="3aefe0ba1ba6e76e7b11557d066b96b14e2c986e" translate="yes" xml:space="preserve">
          <source>Optimisation data; subject to change.</source>
          <target state="translated">최적화 데이터; 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6169946bff1ab1bb2fe62a2ebdb2dd4fa18f40fb" translate="yes" xml:space="preserve">
          <source>Optimisation flags; subject to change.</source>
          <target state="translated">최적화 플래그; 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdf5e093149fa15365c797b12b39a00d5ec3a138" translate="yes" xml:space="preserve">
          <source>Optimization</source>
          <target state="translated">Optimization</target>
        </trans-unit>
        <trans-unit id="18a333060bee7f2ee65af71205072e100d62bacc" translate="yes" xml:space="preserve">
          <source>Optimized-away statements are rendered as '???'. This includes statements that have a compile-time side-effect, such as the obscure</source>
          <target state="translated">최적화 된 문은 '???'로 렌더링됩니다. 여기에는 모호한 것과 같이 컴파일 타임 부작용이있는 문장이 포함됩니다</target>
        </trans-unit>
        <trans-unit id="3e1ccc3d0caaae646e1ab71f59e1842b2b4f1166" translate="yes" xml:space="preserve">
          <source>Optimizing that any further is a job for &lt;code&gt;p5p&lt;/code&gt; .</source>
          <target state="translated">더 이상 &lt;code&gt;p5p&lt;/code&gt; 에 대한 작업임을 최적화합니다 .</target>
        </trans-unit>
        <trans-unit id="2b89db00fb49023ab4c0f78acb572909bcf10d35" translate="yes" xml:space="preserve">
          <source>Option Format</source>
          <target state="translated">옵션 형식</target>
        </trans-unit>
        <trans-unit id="f506dd24a9e7c79211553ebe1422f91140092c4a" translate="yes" xml:space="preserve">
          <source>Option Stickiness</source>
          <target state="translated">옵션 끈적임</target>
        </trans-unit>
        <trans-unit id="8b0267bbb54c30709fbd963f611e8c9f6fcd1f57" translate="yes" xml:space="preserve">
          <source>Option words are separated by commas (not whitespace) and follow the usual conventions of compiler backend options.</source>
          <target state="translated">옵션 단어는 공백이 아닌 쉼표로 구분되며 일반적인 컴파일러 백엔드 옵션 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="bd62828c4813996c3de7a8b7f837c827369e6d5e" translate="yes" xml:space="preserve">
          <source>Option, Argument, Parameter, and Configuration File Processing</source>
          <target state="translated">옵션, 인수, 매개 변수 및 구성 파일 처리</target>
        </trans-unit>
        <trans-unit id="16df76c37a27e75c2b404f915ffcff82e54620ed" translate="yes" xml:space="preserve">
          <source>Optional - called when the layer is about to be removed.</source>
          <target state="translated">선택 사항-레이어를 제거하려고 할 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="279393da5192f90d67ca2ac7c82f748509f343b9" translate="yes" xml:space="preserve">
          <source>Optional - if not present a lower layer does the open. If present, called after the layer is pushed for opens which pass a numeric file descriptor. This function is subject to change as there is no easy way to get a lower layer to do the open and then regain control.</source>
          <target state="translated">선택 사항-하위 계층이 없으면 하위 계층이 열립니다. 존재하는 경우 숫자 파일 설명자를 전달하는 열기를 위해 계층을 푸시 한 후 호출됩니다. 이 기능은 하위 계층이 개방을 수행 한 다음 제어를 다시 얻는 쉬운 방법이 없으므로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66c7071a6fa7cb2bb38d9b2c01a05a137c430add" translate="yes" xml:space="preserve">
          <source>Optional - if not present a lower layer does the open. If present, called after the layer is pushed for sysopen style opens which pass a numeric mode and permissions. This function is subject to change as there is no easy way to get a lower layer to do the open and then regain control.</source>
          <target state="translated">선택 사항-하위 계층이 없으면 하위 계층이 열립니다. 존재하는 경우 sysopen 스타일을 열기 위해 계층을 푸시 한 후 호출되며 숫자 모드 및 권한을 전달합니다. 이 기능은 하위 계층이 개방을 수행 한 다음 제어를 다시 얻는 쉬운 방법이 없으므로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00aae857e158214ab9fea8340d3e81b79261acff" translate="yes" xml:space="preserve">
          <source>Optional - if not present a lower layer does the open. If present, called for normal opens after the layer is pushed. This function is subject to change as there is no easy way to get a lower layer to do the open and then regain control.</source>
          <target state="translated">선택 사항-하위 계층이 없으면 하위 계층이 열립니다. 있는 경우 레이어를 누른 후 일반 열림이 필요합니다. 이 기능은 하위 계층이 개방을 수행 한 다음 제어를 다시 얻는 쉬운 방법이 없으므로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c67ecb9d9cd03592e40a8cfa5395a4594326ddf4" translate="yes" xml:space="preserve">
          <source>Optional - if not present the layer is popped on binmode($fh) or when &lt;code&gt;:raw&lt;/code&gt; is pushed. If present it should return 0 on success, -1 on error, or undef to pop the layer.</source>
          <target state="translated">선택 사항-존재하지 않으면 binmode ($ fh) 또는 &lt;code&gt;:raw&lt;/code&gt; 를 누를 때 레이어가 나타 납니다. 존재하는 경우 성공하면 0을, 오류가 발생하면 -1을 반환하거나, 레이어를 팝하도록 undef해야합니다.</target>
        </trans-unit>
        <trans-unit id="ea8b4c621a2282475d1c70505956ae9cadc5c505" translate="yes" xml:space="preserve">
          <source>Optional - if present it will be called immediately after PUSHED has returned. It should return a true value if the layer expects data to be UTF-8 encoded. If it returns true, the result is as if the caller had done</source>
          <target state="translated">선택 사항-존재하는 경우 PUSHED가 반환 된 직후에 호출됩니다. 계층에서 데이터가 UTF-8로 인코딩 될 것으로 예상하면 true 값을 반환해야합니다. 그것이 true를 반환하면, 결과는 호출자가 한 것처럼</target>
        </trans-unit>
        <trans-unit id="74e7ab47ea9482eb12b8ad3e12ec65d52754eeba" translate="yes" xml:space="preserve">
          <source>Optional Exports</source>
          <target state="translated">선택적 수출</target>
        </trans-unit>
        <trans-unit id="a1586faede4e39ea6174b7a684a9a34f79190989" translate="yes" xml:space="preserve">
          <source>Optional Libraries for Perl on Cygwin</source>
          <target state="translated">Cygwin의 Perl 용 선택적 라이브러리</target>
        </trans-unit>
        <trans-unit id="ddd2d4ec70a68949d8c75dd5fb57b7fa281e8e27" translate="yes" xml:space="preserve">
          <source>Optional Parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d44ae4df7ee3a08403ce68c38bfce3a82e017dd" translate="yes" xml:space="preserve">
          <source>Optional argument is (NAMESPACE), where NAMESPACE is the root namespace to use for the compartment (defaults to &quot;Safe::Root0&quot;, incremented for each new compartment).</source>
          <target state="translated">선택적 인수는 (NAMESPACE)입니다. 여기서 NAMESPACE는 구획에 사용할 루트 네임 스페이스입니다 (기본값은 &quot;Safe :: Root0&quot;이며 각 구획마다 증분 됨).</target>
        </trans-unit>
        <trans-unit id="b9ba9d28014863d3a9a0ee7c8bcd9a7976dbaee9" translate="yes" xml:space="preserve">
          <source>Optional positional parameters must come after all mandatory positional parameters. (If there are no mandatory positional parameters then an optional positional parameters can be the first thing in the signature.) If there are multiple optional positional parameters and not enough arguments are supplied to fill them all, they will be filled from left to right.</source>
          <target state="translated">선택적 위치 매개 변수는 모든 필수 위치 매개 변수 뒤에 와야합니다. (필수 위치 매개 변수가없는 경우 선택적 위치 매개 변수가 서명의 첫 번째 항목이 될 수 있습니다.) 여러 선택적 위치 매개 변수가 있고 인수를 모두 채우는 데 충분한 인수가 제공되지 않으면 왼쪽에서 오른쪽으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="555e2b70062eccf33f8313bcc3fba207cf55ade3" translate="yes" xml:space="preserve">
          <source>Optional sorting weight for names, to determine the order of linear testing when multiple names fall in the same case of a switch clause. Higher comes earlier, undefined defaults to zero.</source>
          <target state="translated">스위치 절의 동일한 경우에 여러 이름이있을 때 선형 테스트 순서를 결정하기위한 이름의 선택적 정렬 가중치. 더 높을수록 정의되지 않은 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="da333a941fe0f82279c2c56c201f1766ccc0c3ef" translate="yes" xml:space="preserve">
          <source>Optional state for the subroutine. The state is passed in as &lt;code&gt;$_[1]&lt;/code&gt; . A reference to the subroutine itself is passed in as &lt;code&gt;$_[0]&lt;/code&gt; .</source>
          <target state="translated">서브 루틴의 선택적 상태. 상태는 &lt;code&gt;$_[1]&lt;/code&gt; 으로 전달됩니다 . 서브 루틴 자체에 대한 참조는 &lt;code&gt;$_[0]&lt;/code&gt; 으로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="3640bdb58e89d324060d7d4f59fe26b0786d9f1e" translate="yes" xml:space="preserve">
          <source>Optional system utilities/More</source>
          <target state="translated">선택적 시스템 유틸리티 / 기타</target>
        </trans-unit>
        <trans-unit id="d82440108ab7dd6400453483bc258adad0e75461" translate="yes" xml:space="preserve">
          <source>Optional warnings are enabled by using the &lt;code&gt;warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; and &lt;b&gt;-W&lt;/b&gt; switches. Warnings may be captured by setting &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; to a reference to a routine that will be called on each warning instead of printing it. See &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;warnings&lt;/code&gt; pragma 또는 &lt;b&gt;-w&lt;/b&gt; 및 &lt;b&gt;-W&lt;/b&gt; 스위치 를 사용하여 선택적 경고를 사용할 수 있습니다. &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; 을 인쇄하는 대신 각 경고마다 호출되는 루틴에 대한 참조로 설정하여 경고를 캡처 할 수 있습니다 . &lt;a href=&quot;perlvar&quot;&gt;perlvar를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="24b988e3016e060f13aed9e152faafade2e2cb57" translate="yes" xml:space="preserve">
          <source>Optional. If present should return an SV * representing the string argument passed to the layer when it was pushed. e.g. &quot;:encoding(ascii)&quot; would return an SvPV with value &quot;ascii&quot;. (</source>
          <target state="translated">선택 과목. 있는 경우 레이어를 눌렀을 때 레이어에 전달 된 문자열 인수를 나타내는 SV *를 반환해야합니다. 예를 들어 &quot;: encoding (ascii)&quot;는 값이 &quot;ascii&quot;인 SvPV를 반환합니다. (</target>
        </trans-unit>
        <trans-unit id="f5c256c5844c41d82f2e7aa133aee1f37b9932b4" translate="yes" xml:space="preserve">
          <source>Optional. No return.</source>
          <target state="translated">선택 과목. 돌아올 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ce76e8ee73778e5c913a5dddf60e41e4482a439a" translate="yes" xml:space="preserve">
          <source>Optional. Returns end-of-file state. Default is a function of the return value of FILL or READ.</source>
          <target state="translated">선택 과목. 파일 끝 상태를 리턴합니다. 기본값은 FILL 또는 READ의 반환 값 함수입니다.</target>
        </trans-unit>
        <trans-unit id="aceaf62498201d3cb7c33131b06976b5e7ec5946" translate="yes" xml:space="preserve">
          <source>Optional. Returns error state. Default is no error until a mechanism to signal error (die?) is worked out.</source>
          <target state="translated">선택 과목. 오류 상태를 반환합니다. 오류 신호 메커니즘 (디?)이 해결 될 때까지 기본값은 오류가 없습니다.</target>
        </trans-unit>
        <trans-unit id="d29adb828f03b9de58472833d11e71256f30b852" translate="yes" xml:space="preserve">
          <source>Optional. Used when &lt;code&gt;:raw&lt;/code&gt; layer is pushed (explicitly or as a result of binmode(FH)). If not present layer will be popped. If present should configure layer as binary (or pop itself) and return 0. If it returns -1 for error &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; will fail with layer still on the stack.</source>
          <target state="translated">선택 과목. &lt;code&gt;:raw&lt;/code&gt; 레이어를 눌렀을 때 (명시 적으로 또는 binmode (FH)의 결과) 사용됩니다. 존재하지 않으면 레이어가 나타납니다. 있는 경우 레이어를 이진 (또는 팝 자체)으로 구성하고 0을 반환해야합니다. 오류에 대해 -1을 반환 하면 스택의 레이어에서 여전히 레이어와 함께 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="54b5a80daefc2af51dc49c0805f2d21b91e8668b" translate="yes" xml:space="preserve">
          <source>Optionally calls timethese(), then outputs comparison chart. This:</source>
          <target state="translated">선택적으로 timethese ()를 호출 한 다음 비교 차트를 출력합니다. 이:</target>
        </trans-unit>
        <trans-unit id="8f2a6f0c361fa39f73808260e667b43a0b479347" translate="yes" xml:space="preserve">
          <source>Optionally, for trying out the feature, you may want to enable automatic dumping of the backtrace just before a warning or croak (die) message is emitted, by adding &lt;code&gt;-Accflags=-DUSE_C_BACKTRACE_ON_ERROR&lt;/code&gt; for Configure.</source>
          <target state="translated">선택적으로, 기능을 시험하기 위해 Configure에 &lt;code&gt;-Accflags=-DUSE_C_BACKTRACE_ON_ERROR&lt;/code&gt; 를 추가하여 경고 또는 croak (die) 메시지가 생성되기 직전에 역 추적 자동 덤프를 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6d56e16a59906dea5f31b29892ce1311dd9cccd9" translate="yes" xml:space="preserve">
          <source>Optionally, one can merge the description of types and the list of argument names, rewriting this as</source>
          <target state="translated">선택적으로 타입 설명과 인수 이름 목록을 병합하여 이것을 다음과 같이 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="9c5258ecb746f12e305ee9f0999e8ac50793402b" translate="yes" xml:space="preserve">
          <source>Options (specified by the following modifiers) are:</source>
          <target state="translated">옵션 (다음 수정 자에 의해 지정됨)은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ec1f90c3315fe4700f720cb2f4a9e4c50e170f92" translate="yes" xml:space="preserve">
          <source>Options affect how things are rendered (ie printed). They're presented here by their visual effect, 1st being strongest. They're grouped according to how they interrelate; within each group the options are mutually exclusive (unless otherwise stated).</source>
          <target state="translated">옵션은 사물이 렌더링되는 방법 (예 : 인쇄)에 영향을줍니다. 여기에서 시각적 효과가 가장 강하게 나타납니다. 그것들은 그들이 어떻게 관련되어 있는지에 따라 그룹화됩니다. 각 그룹 내에서 옵션은 상호 배타적입니다 (달리 명시되지 않는 한).</target>
        </trans-unit>
        <trans-unit id="48a464c28a671924b790e4e5d29f7c52e88ad928" translate="yes" xml:space="preserve">
          <source>Options are as described in &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; above; in addition, the following match process modifiers are available:</source>
          <target state="translated">옵션은 위의 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 설명되어 있습니다 . 또한 다음과 같은 일치 프로세스 수정자를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e758911022c90dc88a8767e43a034d257baa395" translate="yes" xml:space="preserve">
          <source>Options are as with &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; with the addition of the following replacement specific options:</source>
          <target state="translated">옵션은 다음과 같은 대체 옵션이 추가 된 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; 와 같습니다.</target>
        </trans-unit>
        <trans-unit id="1be4081ccaf3e011dcb6256fd6926414b643ca82" translate="yes" xml:space="preserve">
          <source>Options can be combined as required.</source>
          <target state="translated">필요에 따라 옵션을 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44de2a921493b7d9eacebba61cb9256d0440d480" translate="yes" xml:space="preserve">
          <source>Options can have values, the value is placed after the option character. Sometimes with whitespace in between, sometimes not:</source>
          <target state="translated">옵션은 값을 가질 수 있으며 값은 옵션 문자 뒤에 위치합니다. 때로는 사이에 공백이 있거나 때로는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6f40af16e1d24ead9dd1ab7a9826636a3e146727" translate="yes" xml:space="preserve">
          <source>Options can take multiple values at once, for example</source>
          <target state="translated">예를 들어 옵션은 한 번에 여러 값을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="3ddfd37b7dede31756596dac520f5a582b7ed831" translate="yes" xml:space="preserve">
          <source>Options controlling sequence numbering</source>
          <target state="translated">시퀀스 넘버링을 제어하는 ​​옵션</target>
        </trans-unit>
        <trans-unit id="9a8a3df69d73a894006df726b5df3d7d2139bdfa" translate="yes" xml:space="preserve">
          <source>Options for Line-Style</source>
          <target state="translated">선 스타일 옵션</target>
        </trans-unit>
        <trans-unit id="58018de8cc3dcfc82b97b039f35b6a1c13becc88" translate="yes" xml:space="preserve">
          <source>Options for Opcode Ordering</source>
          <target state="translated">Opcode 주문 옵션</target>
        </trans-unit>
        <trans-unit id="55b5d2921e00a398b412bd693eeb7b816a5988e5" translate="yes" xml:space="preserve">
          <source>Options for tree-specific formatting</source>
          <target state="translated">트리 별 서식 옵션</target>
        </trans-unit>
        <trans-unit id="85b85ab75dd0ae66d7aa6313828663d28696cdc6" translate="yes" xml:space="preserve">
          <source>Options include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cc4681b46a8bbe1672f6ee5cc5274a5a2e1321f" translate="yes" xml:space="preserve">
          <source>Options sometimes take several values. For example, a program could use multiple directories to search for library files:</source>
          <target state="translated">옵션은 때때로 여러 값을 갖습니다. 예를 들어, 프로그램은 여러 디렉토리를 사용하여 라이브러리 파일을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f78d98a0f0a1d210a552e42c750a6f91f2370150" translate="yes" xml:space="preserve">
          <source>Options that take arguments:</source>
          <target state="translated">인수를 취하는 옵션 :</target>
        </trans-unit>
        <trans-unit id="41151a23e0b5c5a846ca08d323cfca7cf516f1a6" translate="yes" xml:space="preserve">
          <source>Options with hash values</source>
          <target state="translated">해시 값이있는 옵션</target>
        </trans-unit>
        <trans-unit id="60f84bb401de02d865a716cc0a5e1289035f7821" translate="yes" xml:space="preserve">
          <source>Options with multiple names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9529a432aa4df6cdd00e1eef2fc89856c4d9538" translate="yes" xml:space="preserve">
          <source>Options with multiple values</source>
          <target state="translated">여러 값을 가진 옵션</target>
        </trans-unit>
        <trans-unit id="ce4401244b851388c74b7c8db83ca37894df35bc" translate="yes" xml:space="preserve">
          <source>Options with values</source>
          <target state="translated">값이있는 옵션</target>
        </trans-unit>
        <trans-unit id="44b169e466bada4cebf1bd71469144108ff2f954" translate="yes" xml:space="preserve">
          <source>Options.U</source>
          <target state="translated">Options.U</target>
        </trans-unit>
        <trans-unit id="bdd0b506837a990803d8edf137f2934329835748" translate="yes" xml:space="preserve">
          <source>Options:</source>
          <target state="translated">Options:</target>
        </trans-unit>
        <trans-unit id="99fd4ae20169f4f1fd95e0b318eddbf04496e03f" translate="yes" xml:space="preserve">
          <source>Optree Manipulation Functions</source>
          <target state="translated">Optree 조작 함수</target>
        </trans-unit>
        <trans-unit id="6660f96406f6f5efcf28a2f461913aed19ed8b17" translate="yes" xml:space="preserve">
          <source>Optree construction</source>
          <target state="translated">Optree 건축</target>
        </trans-unit>
        <trans-unit id="219c1efc76675f38bcd59bb9804c4faf6887590f" translate="yes" xml:space="preserve">
          <source>Or by including the &lt;a href=&quot;tester/color&quot;&gt;Test::Builder::Tester::Color&lt;/a&gt; module directly in the PERL5LIB.</source>
          <target state="translated">또는 PERL5LIB에 &lt;a href=&quot;tester/color&quot;&gt;Test :: Builder :: Tester :: Color&lt;/a&gt; 모듈을 직접 포함 시키십시오.</target>
        </trans-unit>
        <trans-unit id="939c0047d2a7d9894b911fc7f2bc8d3ef6ebb72b" translate="yes" xml:space="preserve">
          <source>Or even the day of the year (which is what some people think of as a Julian day):</source>
          <target state="translated">또는 심지어 일의 날 (일부 사람들은 줄리안의 날이라고 생각합니다) :</target>
        </trans-unit>
        <trans-unit id="c8d29c4a4243321b13a4333a16028d3427ee5e4d" translate="yes" xml:space="preserve">
          <source>Or even to place backup copies of the original files into another directory (provided the directory already exists):</source>
          <target state="translated">또는 원본 파일의 백업 사본을 다른 디렉토리 (이미 존재하는 경우)에 배치 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a39395a536571e326a3e448e36d0980f046516aa" translate="yes" xml:space="preserve">
          <source>Or even with a literal numeric descriptor:</source>
          <target state="translated">또는 리터럴 숫자 설명자가있는 경우에도 :</target>
        </trans-unit>
        <trans-unit id="ab622aab7528770d4b43d68b1cd75eb516c4a74e" translate="yes" xml:space="preserve">
          <source>Or for months:</source>
          <target state="translated">또는 몇 달 동안 :</target>
        </trans-unit>
        <trans-unit id="4fbd4993cb449934f1a66fbe81f10f2f69d366bb" translate="yes" xml:space="preserve">
          <source>Or here's another sample of using our tied class:</source>
          <target state="translated">또는 묶인 클래스를 사용하는 또 다른 샘플이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1cc3245f722d14e01ba8265aa59ed13c82aa6c08" translate="yes" xml:space="preserve">
          <source>Or if you already have an open filehandle:</source>
          <target state="translated">또는 이미 열린 파일 핸들이있는 경우 :</target>
        </trans-unit>
        <trans-unit id="4b436dc18b09a9237b0e320d550c6bceb76aed2a" translate="yes" xml:space="preserve">
          <source>Or if you don't care to play it safe, like this:</source>
          <target state="translated">또는 다음과 같이 안전하게 플레이하지 않아도되는 경우 :</target>
        </trans-unit>
        <trans-unit id="ab228fa27d4891d818d4fcc6cc01c02a70a2f225" translate="yes" xml:space="preserve">
          <source>Or if you don't mind pulling in a few thousand lines of code just because you're afraid of a little &lt;code&gt;$|&lt;/code&gt; variable:</source>
          <target state="translated">또는 약간의 코드를 두려워해서 수천 줄의 코드를 가져 오는 것이 마음에 들지 않는다면 &lt;code&gt;$|&lt;/code&gt; 변하기 쉬운:</target>
        </trans-unit>
        <trans-unit id="6de1ca81804fc1d18de6212eb9c2eb10c739f658" translate="yes" xml:space="preserve">
          <source>Or if you have a core dump:</source>
          <target state="translated">또는 코어 덤프가있는 경우 :</target>
        </trans-unit>
        <trans-unit id="08ae01f1533c609ba5994d6d80c6e627d6b146ea" translate="yes" xml:space="preserve">
          <source>Or if you really want to save space:</source>
          <target state="translated">또는 실제로 공간을 절약하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="91c274909c10e199bdd764d2f1727e59782d9346" translate="yes" xml:space="preserve">
          <source>Or if you try to do</source>
          <target state="translated">또는 당신이하려고하면</target>
        </trans-unit>
        <trans-unit id="151d66e1a17731064f48e0aa8f42f3272b7c1ba5" translate="yes" xml:space="preserve">
          <source>Or if you want to schedule a</source>
          <target state="translated">또는 일정을 예약하려는 경우</target>
        </trans-unit>
        <trans-unit id="a55b0108f3cf41f36382908140f2919f204761ba" translate="yes" xml:space="preserve">
          <source>Or in a more recent version:</source>
          <target state="translated">또는 최신 버전에서 :</target>
        </trans-unit>
        <trans-unit id="c2f0409db7dd86c778a013b8c1b13fb97d9866d1" translate="yes" xml:space="preserve">
          <source>Or insert multiple javascript source in the header (or for that matter include anything, thought this is not recommended)</source>
          <target state="translated">또는 헤더에 여러 개의 자바 스크립트 소스를 삽입하십시오 (또는 그 문제에 대해서는 이것이 권장되지 않는다고 생각하십시오)</target>
        </trans-unit>
        <trans-unit id="1f2f783b03d3690462c1ad2137de324e8f81f559" translate="yes" xml:space="preserve">
          <source>Or install it RPM Style:</source>
          <target state="translated">또는 RPM 스타일을 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="4e1bab7ea88f309a093f0d39d4f730b201961c56" translate="yes" xml:space="preserve">
          <source>Or instead of storing this in the language class's lexicon, you can (and, in some cases, really should) represent the same bit of knowledge as code in a method in the language class. (That leaves a tidy distinction between the lexicon as the things we know how to</source>
          <target state="translated">또는 이것을 언어 클래스의 어휘집에 저장하는 대신 언어 클래스의 메소드에서 코드와 동일한 지식을 나타낼 수 있습니다. (그것이 우리가 알고있는 것들로 어휘집을 깔끔하게 구분합니다.</target>
        </trans-unit>
        <trans-unit id="7045f93919469e6381656c230b7db826c2eef7c3" translate="yes" xml:space="preserve">
          <source>Or it can localize a typeglob and use the filehandle directly:</source>
          <target state="translated">또는 typeglob를 현지화하고 파일 핸들을 직접 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce435dd3f2375a45ae18754aa5933bf2c436dc74" translate="yes" xml:space="preserve">
          <source>Or just use &lt;code&gt;if&lt;/code&gt; .</source>
          <target state="translated">또는 &lt;code&gt;if&lt;/code&gt; 만 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="136d46bac172392fa4cdf46c2009daa41e71888d" translate="yes" xml:space="preserve">
          <source>Or like this:</source>
          <target state="translated">또는 이렇게 :</target>
        </trans-unit>
        <trans-unit id="48f08d1241f74e59beb562174576b8f1d306023b" translate="yes" xml:space="preserve">
          <source>Or maybe we could use regular expressions:</source>
          <target state="translated">또는 정규 표현식을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3bba577160bb629ef905e44edb323af58458622" translate="yes" xml:space="preserve">
          <source>Or maybe you don't want to &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; at all! Maybe you could use a handler like this:</source>
          <target state="translated">아니면 전혀 &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 싶지 않을 수도 있습니다 ! 아마도 다음과 같은 핸들러를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb07ce954d095bd48c2be1f0fcad35b67c72a58b" translate="yes" xml:space="preserve">
          <source>Or more succinctly:</source>
          <target state="translated">또는 간결하게 :</target>
        </trans-unit>
        <trans-unit id="daea64cee75759eefcb8d884a9ad1d6ffab3b7eb" translate="yes" xml:space="preserve">
          <source>Or the modified Julian Day:</source>
          <target state="translated">또는 수정 된 줄리안 데이 :</target>
        </trans-unit>
        <trans-unit id="37cd5be2ebf8ceaba65ad66ef7810a2d95ad6a73" translate="yes" xml:space="preserve">
          <source>Or to make an swrite() subroutine, which is to write() what sprintf() is to printf(), do this:</source>
          <target state="translated">또는 swrite () 서브 루틴을 만들려면, sprintf ()가 printf () 인 것을 write ()하는 것입니다 :</target>
        </trans-unit>
        <trans-unit id="b578c02852dfedb0541b5bd3610b753c127ee1fb" translate="yes" xml:space="preserve">
          <source>Or to plan a variable number of tests:</source>
          <target state="translated">또는 다양한 테스트 수를 계획하려면 :</target>
        </trans-unit>
        <trans-unit id="534e1e283610aa3e2f191a2196b648a7456ca580" translate="yes" xml:space="preserve">
          <source>Or use &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; to try decoding it:</source>
          <target state="translated">또는 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 을 사용 하여 디코딩을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="70d6fd7de2724ba9f6a39374a9f05288463f8ef9" translate="yes" xml:space="preserve">
          <source>Or use specific un-Unicode properties, like &lt;code&gt;\p{ahex}&lt;/code&gt; and &lt;code&gt;\p{POSIX_Digit&lt;/code&gt; }. Properties still work normally no matter what charset modifiers (&lt;code&gt;/d /u /l /a /aa&lt;/code&gt; ) should be effect.</source>
          <target state="translated">또는 &lt;code&gt;\p{ahex}&lt;/code&gt; 및 &lt;code&gt;\p{POSIX_Digit&lt;/code&gt; } 와 같은 특정 비 유니 코드 속성을 사용하십시오 . 어떤 문자셋 수정 자 ( &lt;code&gt;/d /u /l /a /aa&lt;/code&gt; )가 적용 되더라도 속성은 여전히 ​​정상적으로 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="d147ca7029faa376379ab60dd5e184279f392c55" translate="yes" xml:space="preserve">
          <source>Or use the CPAN module &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt;:</source>
          <target state="translated">또는 CPAN 모듈 &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit :: Vector를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3e3bc5aa2b1c65a2f0536a8ad61f1cf720e70bd7" translate="yes" xml:space="preserve">
          <source>Or use the CPAN module &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Autoformat&quot;&gt;Text::Autoformat&lt;/a&gt;. Formatting files can be easily done by making a shell alias, like so:</source>
          <target state="translated">또는 CPAN 모듈 &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Autoformat&quot;&gt;Text :: Autoformat을&lt;/a&gt; 사용하십시오 . 다음과 같이 쉘 별명을 작성하여 파일 형식화를 쉽게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21cd44b0a63b2724e709817a957ed758ac294220" translate="yes" xml:space="preserve">
          <source>Or we can use the addfile method for more efficient reading of the file:</source>
          <target state="translated">또는 파일을보다 효율적으로 읽을 수 있도록 addfile 메소드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7eb22b9341f8bed904b75d947077206dd520c369" translate="yes" xml:space="preserve">
          <source>Or we will publicly ridicule you. Seriously.</source>
          <target state="translated">아니면 우리는 공개적으로 당신을 비웃을 것입니다. 진심으로.</target>
        </trans-unit>
        <trans-unit id="2c4d7e281aa840be77762aa28882884e3b12c3e2" translate="yes" xml:space="preserve">
          <source>Or with a fixed amount of leading whitespace, with remaining indentation correctly preserved:</source>
          <target state="translated">또는 고정 된 양의 선행 공백이 있고 남은 들여 쓰기가 올바르게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="9f8c04b29e5bdf5cb37189daec86558285ed03bf" translate="yes" xml:space="preserve">
          <source>Or with rationals:</source>
          <target state="translated">또는 합리적 인 경우 :</target>
        </trans-unit>
        <trans-unit id="ac4bf8a39abe6183f58cc853b82a958a3b19f773" translate="yes" xml:space="preserve">
          <source>Or write a small C program using the editor of champions:</source>
          <target state="translated">또는 챔피언 편집기를 사용하여 작은 C 프로그램을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="071de2b484157eae02726aef816948b89ceb81e6" translate="yes" xml:space="preserve">
          <source>Or write it yourself, iterating through the indices and checking the array element at each index until you find one that satisfies the condition:</source>
          <target state="translated">또는 색인을 반복하고 조건을 만족하는 항목을 찾을 때까지 각 색인에서 배열 요소를 확인하여 직접 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="fd30f1e33b918715dd71d5fd528fc3bfe2e3a2f3" translate="yes" xml:space="preserve">
          <source>Or write the &quot;bar&quot; method so you don't need to pass it the output from calling quux.</source>
          <target state="translated">또는 &quot;bar&quot;메소드를 작성하여 quux 호출에서 출력을 전달할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1257832c1f8df8853297c11758dc7f82a58965f3" translate="yes" xml:space="preserve">
          <source>Or you can call these methods, which Pod::Simple::PullParser has defined to work just like Pod::Simple's same-named methods:</source>
          <target state="translated">또는 Pod :: Simple :: PullParser가 Pod :: Simple의 동일한 이름의 메소드와 같이 작동하도록 정의한 다음 메소드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43deb0ef03dcaf9d7f9a23cfd26b6f349abc278d" translate="yes" xml:space="preserve">
          <source>Or you can give the name of a specific module:</source>
          <target state="translated">또는 특정 모듈의 이름을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44f4d760018e2beff2abc7deca32778f6b33edab" translate="yes" xml:space="preserve">
          <source>Or you can just use the &lt;a href=&quot;text/tabs&quot;&gt;Text::Tabs&lt;/a&gt; module (part of the standard Perl distribution).</source>
          <target state="translated">또는 &lt;a href=&quot;text/tabs&quot;&gt;Text :: Tabs&lt;/a&gt; 모듈 (표준 Perl 배포의 일부)을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f560caefa4961932943871223d7a55e15210337" translate="yes" xml:space="preserve">
          <source>Or you can link to a web page:</source>
          <target state="translated">또는 웹 페이지에 링크 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35426ac710dfda840e59a05cb7cce1999af24289" translate="yes" xml:space="preserve">
          <source>Or you can read the entire file contents into a scalar like this:</source>
          <target state="translated">또는 다음과 같이 전체 파일 내용을 스칼라로 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ca35881b01bed9e83e28982a2d8d72c5c6104a0" translate="yes" xml:space="preserve">
          <source>Or you can try casting to a &quot;wide enough&quot; type:</source>
          <target state="translated">또는 &quot;충분히 넓은&quot;유형으로 캐스트를 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="043cc73307c25fd12afc139edc01af1987c07753" translate="yes" xml:space="preserve">
          <source>Or you can use</source>
          <target state="translated">아니면 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="6eacf94ec3c91a6fb8f957244c216f33f4c57d92" translate="yes" xml:space="preserve">
          <source>Or you can use &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt;, though it is less convenient in the general case:</source>
          <target state="translated">또는 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; 사용할 수 있지만 일반적인 경우에는 덜 편리합니다.</target>
        </trans-unit>
        <trans-unit id="931b91df8b44901925eb12d70d322446a86049fc" translate="yes" xml:space="preserve">
          <source>Or you can use &lt;code&gt;add_suspects&lt;/code&gt; method. The difference is that &lt;code&gt;set_suspects&lt;/code&gt; flushes the current suspects list while &lt;code&gt;add_suspects&lt;/code&gt; adds.</source>
          <target state="translated">또는 &lt;code&gt;add_suspects&lt;/code&gt; 메소드를 사용할 수 있습니다 . 차이점은 &lt;code&gt;add_suspects&lt;/code&gt; 가 add_suspects가 추가 하는 동안 현재 의심 목록을 플러시 한다는 &lt;code&gt;set_suspects&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a39a91a0d1d979c65ad41157a37488c0834225c4" translate="yes" xml:space="preserve">
          <source>Or you could check out the &lt;a href=&quot;http://search.cpan.org/perldoc/String::Scanf&quot;&gt;String::Scanf&lt;/a&gt; module on the CPAN instead.</source>
          <target state="translated">또는 대신 CPAN 에서 &lt;a href=&quot;http://search.cpan.org/perldoc/String::Scanf&quot;&gt;String :: Scanf&lt;/a&gt; 모듈을 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5093d94168468d0b2a02ecd19e89cf6d81de9b6e" translate="yes" xml:space="preserve">
          <source>Or you could use this module, like this:</source>
          <target state="translated">또는 다음과 같이이 모듈을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d54e1a4de96da66b4f1be3ddd384e9dc12182b2a" translate="yes" xml:space="preserve">
          <source>Or you may want to override it with something that traps any exceptions, if that's critical to your program:</source>
          <target state="translated">또는 프로그램에 중요한 경우 예외를 포착하는 것으로 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bc5eff73e9b5c554f3a2ea69d7a2e4db2c90148" translate="yes" xml:space="preserve">
          <source>Or you might have had a temporary variable sitting around with the array in it.</source>
          <target state="translated">또는 배열 안에 임시 변수가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="778e7ba107050bb841c6a420e4c310f8b170e2db" translate="yes" xml:space="preserve">
          <source>Or, as a third option you can choose RAND which will make a random decision (something regular CPAN testers will enjoy).</source>
          <target state="translated">또는 세 번째 옵션으로 무작위 결정을 내리는 RAND를 선택할 수 있습니다 (일반 CPAN 테스터가 누릴 수있는 것).</target>
        </trans-unit>
        <trans-unit id="67fb52d7219a77edeaa3410be898dbaaf5eb7940" translate="yes" xml:space="preserve">
          <source>Or, going the other way:</source>
          <target state="translated">또는 다른 방법으로 가십시오.</target>
        </trans-unit>
        <trans-unit id="c9cbc117e700c42b5960566f9d6e3ab9956f8e0e" translate="yes" xml:space="preserve">
          <source>Or, if you want to alter the value, you can even do things like this:</source>
          <target state="translated">또는 값을 변경하려면 다음과 같이 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbaa299505c09af1ba1a690349c0d5013974e787" translate="yes" xml:space="preserve">
          <source>Or, if you want to use SHA-256 instead of the default SHA-1, simply say:</source>
          <target state="translated">또는 기본 SHA-1 대신 SHA-256을 사용하려면 다음과 같이 말하십시오.</target>
        </trans-unit>
        <trans-unit id="43c22f6d092ff91e39fcd2c49c563a09384d2c27" translate="yes" xml:space="preserve">
          <source>Or, if you're fond of VMS command syntax:</source>
          <target state="translated">또는 VMS 명령 구문을 좋아하는 경우 :</target>
        </trans-unit>
        <trans-unit id="8f53b2f39475162ce9507ab6d3bc142ec9ebf18d" translate="yes" xml:space="preserve">
          <source>Or, if you're lazy, just:</source>
          <target state="translated">또는 게으른 경우 :</target>
        </trans-unit>
        <trans-unit id="2e075c729b27aef299f95b8f9b89c3205825fc03" translate="yes" xml:space="preserve">
          <source>Or, if you're using a recent release of Perl, you can just use the Symbol::delete_package() function instead.</source>
          <target state="translated">또는 최신 Perl 릴리스를 사용중인 경우 Symbol :: delete_package () 함수를 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ef47775ad6e32b75e39e1b8250e2051eeafc265" translate="yes" xml:space="preserve">
          <source>Or, in order to retain the UTF-x code points in hexadecimal:</source>
          <target state="translated">또는 UTF-x 코드 포인트를 16 진수로 유지하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="9ac1d61fe8e0e045309c1cd8c9bfbba7d77d8c46" translate="yes" xml:space="preserve">
          <source>Or, just use the fdopen(3S) feature of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">또는 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 의 fdopen (3S) 기능을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b65db10b884b8811cab09d1c35d73c9549dd89e0" translate="yes" xml:space="preserve">
          <source>Or, simply:</source>
          <target state="translated">또는 간단히 :</target>
        </trans-unit>
        <trans-unit id="4509b32489cef8d9fa76782913fc02beac5d2e00" translate="yes" xml:space="preserve">
          <source>Or, you can combine this step with the next to save disk space:</source>
          <target state="translated">또는이 단계를 다음 단계와 결합하여 디스크 공간을 절약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a70a9c965ff5f01a36539ad3a4f1747814f861b5" translate="yes" xml:space="preserve">
          <source>Or, you can use a closure to bundle up the object, its method call, and arguments:</source>
          <target state="translated">또는 클로저를 사용하여 객체, 메서드 호출 및 인수를 묶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e30f14ff059f10f588d2a56e4ed3edbafad53cb" translate="yes" xml:space="preserve">
          <source>Or, you can use the &lt;code&gt;new&lt;/code&gt; method from one of the IO::* modules to create an anonymous filehandle and store that in a scalar variable.</source>
          <target state="translated">또는 IO :: * 모듈 중 하나 에서 &lt;code&gt;new&lt;/code&gt; 메소드를 사용하여 익명 파일 핸들을 작성하고이를 스칼라 변수에 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af6226005e40b70717bca3873f6972ffe8233b17" translate="yes" xml:space="preserve">
          <source>Or, you might want to only process some of the items. If you only want to deal with the keys that start with &lt;code&gt;text:&lt;/code&gt; , you can select just those using &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">또는 일부 항목 만 처리 할 수도 있습니다. &lt;code&gt;text:&lt;/code&gt; 시작하는 키만 처리 하려면 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 을 사용하여 키만 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="40119221cab56480c05aa14722b443b3fea26189" translate="yes" xml:space="preserve">
          <source>Or...</source>
          <target state="translated">Or...</target>
        </trans-unit>
        <trans-unit id="00fcdda14949d42c1610edfba9ca80d41d59564f" translate="yes" xml:space="preserve">
          <source>Or:</source>
          <target state="translated">Or:</target>
        </trans-unit>
        <trans-unit id="ed006a3a71954db6f888573fde1410910ac75da8" translate="yes" xml:space="preserve">
          <source>Oracle on HP-UX</source>
          <target state="translated">HP-UX의 Oracle</target>
        </trans-unit>
        <trans-unit id="d62b80826f613ec1202935a4c2f641139f04ab27" translate="yes" xml:space="preserve">
          <source>Order of initialization: early load()</source>
          <target state="translated">초기화 순서 : early load ()</target>
        </trans-unit>
        <trans-unit id="7393d644018f3205b57f7e4d05fa28a3cb608a27" translate="yes" xml:space="preserve">
          <source>Ordering is important in all these examples. That's because the shell processes file descriptor redirections in strictly left to right order.</source>
          <target state="translated">순서는이 모든 예에서 중요합니다. 쉘이 파일 디스크립터 리디렉션을 왼쪽에서 오른쪽 순서로 엄격하게 처리하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="184a2b9a0782971148728db5cbfcd9146f0d9d22" translate="yes" xml:space="preserve">
          <source>Ordering of two matches for &lt;code&gt;S&lt;/code&gt; is the same as for &lt;code&gt;S&lt;/code&gt; . Similar for two matches for &lt;code&gt;T&lt;/code&gt; .</source>
          <target state="translated">두 경기의 주문 &lt;code&gt;S&lt;/code&gt; 하는 경우와 동일 &lt;code&gt;S&lt;/code&gt; . &lt;code&gt;T&lt;/code&gt; 에 대한 두 개의 일치 항목과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="1f2e5db8ac8798852d4979873043eb23e9daf36e" translate="yes" xml:space="preserve">
          <source>Ordinarily you must assign the returned value to a variable, but there is one situation where an automatic assignment happens. If and only if the input symbol is the only thing inside the conditional of a &lt;code&gt;while&lt;/code&gt; statement (even if disguised as a &lt;code&gt;for(;;)&lt;/code&gt; loop), the value is automatically assigned to the global variable &lt;code&gt;$_&lt;/code&gt; , destroying whatever was there previously. (This may seem like an odd thing to you, but you'll use the construct in almost every Perl script you write.) The &lt;code&gt;$_&lt;/code&gt; variable is not implicitly localized. You'll have to put a &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $_;&lt;/code&gt; before the loop if you want that to happen.</source>
          <target state="translated">일반적으로 반환 된 값을 변수에 할당해야하지만 자동 할당이 발생하는 상황이 있습니다. 입력 심볼이 &lt;code&gt;while&lt;/code&gt; 문의 조건부 내에서 유일한 경우 인 경우 &lt;code&gt;for(;;)&lt;/code&gt; 루프 로 위장한 경우에도 ), 값은 전역 변수 &lt;code&gt;$_&lt;/code&gt; 자동으로 할당되어 이전에 있던 것을 파괴합니다. (이것은 당신에게 이상한 것처럼 보일지 모르지만 작성한 거의 모든 Perl 스크립트에서 구문을 사용합니다.) &lt;code&gt;$_&lt;/code&gt; 변수는 암시 적으로 지역화되지 않았습니다. &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $_;&lt;/code&gt; 를 넣어야합니다 . 원하는 경우 루프 전에.</target>
        </trans-unit>
        <trans-unit id="53258e41460718a5a3f67ea0dcecd0cea963c78d" translate="yes" xml:space="preserve">
          <source>Ordinarily, if you use B::Deparse on a subroutine which has been compiled in the presence of one or more of these pragmas, the output will include statements to turn on the appropriate directives. So if you then compile the code returned by coderef2text, it will behave the same way as the subroutine which you deparsed.</source>
          <target state="translated">일반적으로 하나 이상의 이러한 pragma가있는 상태에서 컴파일 된 서브 루틴에서 B :: Deparse를 사용하면 출력에 해당 지시문을 설정하는 명령문이 포함됩니다. 따라서 coderef2text에서 반환 한 코드를 컴파일하면 파싱 한 서브 루틴과 동일한 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="9eb59a093d68b441c9e588f45e1136962cd97df2" translate="yes" xml:space="preserve">
          <source>Ordinary Paragraph</source>
          <target state="translated">일반 단락</target>
        </trans-unit>
        <trans-unit id="852794a0888b2c26ae66b7390c3dc7aa906b25ab" translate="yes" xml:space="preserve">
          <source>Ordinary scalars are added to queues as they are.</source>
          <target state="translated">정규 스칼라가 그대로 대기열에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="e643b2f1d6d20cd4b1a9b180a96d9d74142343a5" translate="yes" xml:space="preserve">
          <source>Organization of Perl Images</source>
          <target state="translated">펄 이미지의 구성</target>
        </trans-unit>
        <trans-unit id="b7ac1ae7a629fb1e4790255da63efabc71780dd7" translate="yes" xml:space="preserve">
          <source>Original author Charles Bailey</source>
          <target state="translated">원저 Charles Bailey</target>
        </trans-unit>
        <trans-unit id="6bb735e6ea9df22ee5b2de902784152d534e32cf" translate="yes" xml:space="preserve">
          <source>Original author lost in the mists of time. Probably the same as Makemaker.</source>
          <target state="translated">원작자는 시간의 안개 속에서 길을 잃었다. 아마도 Makemaker와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="8478bfad57c6e4bf8f9631f29cfcd8913f5e1f7b" translate="yes" xml:space="preserve">
          <source>Original author: Jos Boumans &amp;lt;kane@cpan.org&amp;gt;. Current maintainer: Chris Williams &amp;lt;bingos@cpan.org&amp;gt;.</source>
          <target state="translated">원저자 : Jos Boumans &amp;lt;kane@cpan.org&amp;gt;. 현재 관리자 : Chris Williams &amp;lt;bingos@cpan.org&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="82456b1a006fa0cfc6f13442efd03f45359b0924" translate="yes" xml:space="preserve">
          <source>Original code by Mark Biggar, overloaded interface by Ilya Zakharevich. Completely rewritten by Tels &lt;a href=&quot;http://bloodgate.com&quot;&gt;http://bloodgate.com&lt;/a&gt; in late 2000, 2001 - 2006 and still at it in 2007.</source>
          <target state="translated">Mark Biggar의 원본 코드, Ilya Zakharevich의 오버로드 된 인터페이스 Tels &lt;a href=&quot;http://bloodgate.com&quot;&gt;http://bloodgate.com&lt;/a&gt; 은 2000 년 후반, 2001 년부터 2006 년까지 완전히 다시 작성 했으며 2007 년에도 다시 작성했습니다 .</target>
        </trans-unit>
        <trans-unit id="4907c478063f242cdad148d2cf2e2a3834c957e0" translate="yes" xml:space="preserve">
          <source>Original code by chromatic, maintained by Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;</source>
          <target state="translated">Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;에 의해 유지되는 색도 별 원본 코드</target>
        </trans-unit>
        <trans-unit id="5aa8fbf538dffef8e3de83026f7b50c6ec7e3e15" translate="yes" xml:space="preserve">
          <source>Original idea (using constants) by Zenin, reimplemented using subs by Russ Allbery &amp;lt;rra@cpan.org&amp;gt;, and then combined with the original idea by Russ with input from Zenin. 256-color support is based on work by Kurt Starsinic. Russ Allbery now maintains this module.</source>
          <target state="translated">Zenin의 원래 아이디어 (상수 사용), Russ Allbery &amp;lt;rra@cpan.org&amp;gt;의 서브를 사용하여 다시 구현 한 다음 Russ의 원래 아이디어와 Zenin의 입력을 결합했습니다. 256 색 지원은 Kurt Starsinic의 작품을 기반으로합니다. Russ Allbery는 이제이 모듈을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="531407d264d0d11235657451697ac677d9049ca2" translate="yes" xml:space="preserve">
          <source>Original math code by Mark Biggar, rewritten by Tels &lt;a href=&quot;http://bloodgate.com/&quot;&gt;http://bloodgate.com/&lt;/a&gt; in late 2000.</source>
          <target state="translated">Mark Biggar의 원래 수학 코드, 2000 년 후반 Tels &lt;a href=&quot;http://bloodgate.com/&quot;&gt;http://bloodgate.com/&lt;/a&gt; 에 의해 다시 작성되었습니다 .</target>
        </trans-unit>
        <trans-unit id="de9fcab0737543137eaab2a0e06f6bd2ca79a9cc" translate="yes" xml:space="preserve">
          <source>Original math code by Mark Biggar, rewritten by Tels &lt;a href=&quot;http://bloodgate.com/&quot;&gt;http://bloodgate.com/&lt;/a&gt; in late 2000. Separated from BigInt and shaped API with the help of John Peacock.</source>
          <target state="translated">Mark Biggar의 원래 수학 코드, 2000 년 후반 Tels &lt;a href=&quot;http://bloodgate.com/&quot;&gt;http://bloodgate.com/&lt;/a&gt; 에 의해 다시 작성되었습니다 . John Peacock의 도움으로 BigInt와 분리되고 API가 형성되었습니다.</target>
        </trans-unit>
        <trans-unit id="016eb101d0bd431b0d9ab4229772d8f00ba5eae2" translate="yes" xml:space="preserve">
          <source>Original module by Lionel Cons (CERN).</source>
          <target state="translated">Lionel Cons (CERN)의 오리지널 모듈.</target>
        </trans-unit>
        <trans-unit id="a9ec70668a9cf8a9b6348458c85a3f762057ac0f" translate="yes" xml:space="preserve">
          <source>Original version by Tom Christiansen, &amp;lt;tchrist@perl.com&amp;gt;.</source>
          <target state="translated">Tom Christiansen의 원본 버전 &amp;lt;tchrist@perl.com&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="93bd0bc0b9a9e635b79e9c5f125cb705f4a31e8d" translate="yes" xml:space="preserve">
          <source>Originally &lt;code&gt;Class::Template&lt;/code&gt; by Dean Roehrich.</source>
          <target state="translated">원래 &lt;code&gt;Class::Template&lt;/code&gt; Dean Roehrich의 템플릿 .</target>
        </trans-unit>
        <trans-unit id="98ac195b142c467725515fdf5766071e9fc6f61f" translate="yes" xml:space="preserve">
          <source>Originally began life in May 1999 as an XS interface to the system mkstemp() function. In March 2000, the OpenBSD mkstemp() code was translated to Perl for total control of the code's security checking, to ensure the presence of the function regardless of operating system and to help with portability. The module was shipped as a standard part of perl from v5.6.1.</source>
          <target state="translated">원래 1999 년 5 월 시스템 mkstemp () 함수에 대한 XS 인터페이스로 시작되었습니다. 2000 년 3 월, OpenBSD mkstemp () 코드는 운영 체제와 상관없이 함수의 존재를 보장하고 이식성을 돕기 위해 코드의 보안 검사를 완전히 제어하기 위해 Perl로 변환되었습니다. 이 모듈은 v5.6.1부터 perl의 표준 부분으로 제공되었습니다.</target>
        </trans-unit>
        <trans-unit id="05d3b834a8e1ec7b7d1784cd966acd56262bc822" translate="yes" xml:space="preserve">
          <source>Originally by Larry Wall. Turned into the &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; module by Ken Williams.</source>
          <target state="translated">원래 Larry Wall이 작성했습니다. Ken Williams 가 &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; 모듈로 전환했습니다.</target>
        </trans-unit>
        <trans-unit id="78ba94984c09fe40c7fb0012a48157ae37638a1c" translate="yes" xml:space="preserve">
          <source>Originally by the perl5-porters.</source>
          <target state="translated">원래 perl5 포터에 의해.</target>
        </trans-unit>
        <trans-unit id="0a58abf22ae0f33a5d3fa45db34e7ceb2370f30b" translate="yes" xml:space="preserve">
          <source>Originally designed and implemented by Malcolm Beattie, mbeattie@sable.ox.ac.uk as part of Safe version 1.</source>
          <target state="translated">원래 Malcolm Beattie (안전 버전 1의 일부로 mbeattie@sable.ox.ac.uk)가 설계하고 구현했습니다.</target>
        </trans-unit>
        <trans-unit id="c8441bf717fcfb993e717e28d6000796e14219bc" translate="yes" xml:space="preserve">
          <source>Originally designed and implemented by Malcolm Beattie.</source>
          <target state="translated">Malcolm Beattie가 처음 설계하고 구현했습니다.</target>
        </trans-unit>
        <trans-unit id="b5b9ddd002b9e83e3e5ffe5e5b5e1758fac1d1ee" translate="yes" xml:space="preserve">
          <source>Originally from the old Unix editor command for &amp;ldquo;Globally search for a Regular Expression and Print it&amp;rdquo;, now used in the general sense of any kind of search, especially text searches. Perl has a built-in &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; function that searches a list for elements matching any given criterion, whereas the &lt;b&gt;grep&lt;/b&gt;(1) program searches for lines matching a &lt;b&gt;regular expression&lt;/b&gt; in one or more files.</source>
          <target state="translated">원래&amp;ldquo;정규 표현식을 전 세계적으로 검색하여 인쇄&amp;rdquo;라는 구 Unix 편집기 명령에서 유래 한 것으로, 이제는 모든 종류의 검색, 특히 텍스트 검색의 일반적인 의미로 사용됩니다. Perl에는 주어진 기준과 일치하는 요소의 목록을 검색하는 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 기능이 내장되어있는 반면 &lt;b&gt;grep&lt;/b&gt; (1) 프로그램 은 하나 이상의 파일에서 &lt;b&gt;정규식&lt;/b&gt; 과 일치하는 행을 검색 합니다.</target>
        </trans-unit>
        <trans-unit id="179faca61deeed3ab0f554d9e5a2deeffd88d631" translate="yes" xml:space="preserve">
          <source>Originally part of &lt;a href=&quot;perlreguts&quot;&gt;perlreguts&lt;/a&gt;.</source>
          <target state="translated">원래 &lt;a href=&quot;perlreguts&quot;&gt;perlreguts의&lt;/a&gt; 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="f99926744d51a0882b56c8605cf23549f21bb7f7" translate="yes" xml:space="preserve">
          <source>Originally ripped off from &lt;a href=&quot;../../../test/harness&quot;&gt;Test::Harness&lt;/a&gt;.</source>
          <target state="translated">원래 &lt;a href=&quot;../../../test/harness&quot;&gt;Test :: Harness&lt;/a&gt; 에서 분리되었습니다 .</target>
        </trans-unit>
        <trans-unit id="71cbfb5529d2f3e7043bc6450156ba2700321efe" translate="yes" xml:space="preserve">
          <source>Originally ripped off from &lt;a href=&quot;../../test/harness&quot;&gt;Test::Harness&lt;/a&gt;.</source>
          <target state="translated">원래 &lt;a href=&quot;../../test/harness&quot;&gt;Test :: Harness&lt;/a&gt; 에서 분리되었습니다 .</target>
        </trans-unit>
        <trans-unit id="10558d1a36f98366d4aafd194d52755ed064b37d" translate="yes" xml:space="preserve">
          <source>Originally written by Dean Roehrich &amp;lt;</source>
          <target state="translated">Dean Roehrich가 처음 작성 함 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="40fdd20b1b0722f4c9f525e21df0d8f46d7d85b2" translate="yes" xml:space="preserve">
          <source>Originally written by Yves Orton, expanded by &amp;AElig;var Arnfj&amp;ouml;r&amp;eth; Bjarmason.</source>
          <target state="translated">Yves Orton이 처음 작성했으며 &amp;AElig;var Arnfj&amp;ouml;r&amp;eth; Bjarmason에 의해 확장되었습니다.</target>
        </trans-unit>
        <trans-unit id="f0958a863745f7bb7b877718e9ffc0407e157bdf" translate="yes" xml:space="preserve">
          <source>Ossanna, Joseph F., and Brian W. Kernighan. &quot;Troff User's Manual,&quot; Computing Science Technical Report No. 54, AT&amp;amp;T Bell Laboratories. This is the best documentation of standard &lt;b&gt;nroff&lt;/b&gt; and &lt;b&gt;troff&lt;/b&gt;. At the time of this writing, it's available at &lt;a href=&quot;http://www.cs.bell-labs.com/cm/cs/cstr.html&quot;&gt;http://www.cs.bell-labs.com/cm/cs/cstr.html&lt;/a&gt;.</source>
          <target state="translated">Ossanna, Joseph F. 및 Brian W. Kernighan. &quot;Troff 사용자 매뉴얼&quot;컴퓨팅 과학 기술 보고서 ​​번호 54, AT &amp;amp; T Bell Laboratories. 이것은 표준 &lt;b&gt;nroff&lt;/b&gt; 및 &lt;b&gt;troff에&lt;/b&gt; 대한 최상의 문서입니다 . 이 문서를 작성할 당시에는 &lt;a href=&quot;http://www.cs.bell-labs.com/cm/cs/cstr.html&quot;&gt;http://www.cs.bell-labs.com/cm/cs/cstr.html&lt;/a&gt; 에서 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4209bd1da7b6357d7fd219e08de4663ac8c8de52" translate="yes" xml:space="preserve">
          <source>Other C compilers (yes, there &lt;b&gt;are&lt;/b&gt; other C compilers than gcc) often have their &quot;strict ANSI&quot; or &quot;strict ANSI with some portability extensions&quot; modes on, like for example the Sun Workshop has its &lt;code&gt;-Xa&lt;/code&gt; mode on (though implicitly), or the DEC (these days, HP...) has its &lt;code&gt;-std1&lt;/code&gt; mode on.</source>
          <target state="translated">다른 C 컴파일러 (예, 거기에 &lt;b&gt;있는&lt;/b&gt; GCC 이외의 다른 C 컴파일러는) 종종 예를 들어, 일 워크샵이있다처럼,에 모드 &quot;일부 휴대 확장과 엄격한 ANSI&quot;그들의 &quot;엄격한 ANSI&quot;또는이 &lt;code&gt;-Xa&lt;/code&gt; (암시하지만)에 모드를 또는 DEC (현재 HP ...)의 &lt;code&gt;-std1&lt;/code&gt; 모드가 켜져 있습니다.</target>
        </trans-unit>
        <trans-unit id="551852c7028ddd04d28686d5a46f202fe2ad7cb7" translate="yes" xml:space="preserve">
          <source>Other Functions</source>
          <target state="translated">다른 기능들</target>
        </trans-unit>
        <trans-unit id="0bdf87a4ace9eb276a876bd8e9250301437be6c5" translate="yes" xml:space="preserve">
          <source>Other Handy Functions</source>
          <target state="translated">기타 편리한 기능</target>
        </trans-unit>
        <trans-unit id="0ae890b35ce85bf30d57cf160315165f538a27b8" translate="yes" xml:space="preserve">
          <source>Other JRRT books fair game for quotes would thus include</source>
          <target state="translated">인용을위한 다른 JRRT 책 공정한 게임은 이렇게 포함 할 것입니다</target>
        </trans-unit>
        <trans-unit id="dfc61fffa8906502d8a54b080f23a45b3b6a145a" translate="yes" xml:space="preserve">
          <source>Other Methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9165ac20a0a94eccf10c1024b71472d0032177d7" translate="yes" xml:space="preserve">
          <source>Other OO Systems</source>
          <target state="translated">다른 OO 시스템</target>
        </trans-unit>
        <trans-unit id="92b14232c00517718a7c45a7ecde335eb02684ba" translate="yes" xml:space="preserve">
          <source>Other OSes</source>
          <target state="translated">다른 OS</target>
        </trans-unit>
        <trans-unit id="ebafbcc27b9633bf022834dac0afdd7fe5320b31" translate="yes" xml:space="preserve">
          <source>Other References</source>
          <target state="translated">다른 참고 문헌</target>
        </trans-unit>
        <trans-unit id="fa1430ad78734f8ef31e36e90d4f36de9f13a735" translate="yes" xml:space="preserve">
          <source>Other Testing Methods</source>
          <target state="translated">다른 테스트 방법</target>
        </trans-unit>
        <trans-unit id="f0e56c564684ea4c937565ef815405ac4aa82ff1" translate="yes" xml:space="preserve">
          <source>Other available flags are:</source>
          <target state="translated">사용 가능한 다른 플래그는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a9a6815e54ae300be1f551c6019a20062ec0f880" translate="yes" xml:space="preserve">
          <source>Other categories</source>
          <target state="translated">다른 카테고리</target>
        </trans-unit>
        <trans-unit id="fa31529000a27db1a7fada94ddb4d6caa2048ed7" translate="yes" xml:space="preserve">
          <source>Other characters that can't appear in Perl identifiers are also supported as aliases with Getopt::Long of at least version 2.39.</source>
          <target state="translated">Perl 식별자에 표시되지 않는 다른 문자도 Getopt :: Long 이상 버전 2.39의 별칭으로 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="6be322bc8ea0db1e8be06d4ec43ad756a099bfb6" translate="yes" xml:space="preserve">
          <source>Other data worth storing in a lexicon might be things like filenames for language-targetted resources:</source>
          <target state="translated">어휘집에 저장할 가치가있는 다른 데이터는 언어 대상 리소스의 파일 이름과 같은 것일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36fefa00642398c0b54d66e1ab2941d7ce0381ab" translate="yes" xml:space="preserve">
          <source>Other environment variables that may influence tests</source>
          <target state="translated">테스트에 영향을 줄 수있는 기타 환경 변수</target>
        </trans-unit>
        <trans-unit id="293561c7c0c8a1abe2aec3c1c2e6ea87fd9c52f7" translate="yes" xml:space="preserve">
          <source>Other examples include</source>
          <target state="translated">다른 예로는</target>
        </trans-unit>
        <trans-unit id="050e92356c2ad433980e335b3cd1c37de82b2130" translate="yes" xml:space="preserve">
          <source>Other examples include (using standard shell syntax to show environment variable settings):</source>
          <target state="translated">다른 예에는 다음이 포함됩니다 (표준 쉘 구문을 사용하여 환경 변수 설정 표시).</target>
        </trans-unit>
        <trans-unit id="0890da9a3fe9000b110723faeb22296dde791fee" translate="yes" xml:space="preserve">
          <source>Other examples include:</source>
          <target state="translated">다른 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9b4e9be46864e281795d5dbc03712be976c67f55" translate="yes" xml:space="preserve">
          <source>Other information in the Unicode data base</source>
          <target state="translated">유니 코드 데이터베이스의 기타 정보</target>
        </trans-unit>
        <trans-unit id="be5464268eb0652d20727c597b5d478658d7e34b" translate="yes" xml:space="preserve">
          <source>Other interesting targets in the generated Makefile are</source>
          <target state="translated">생성 된 Makefile의 다른 흥미로운 대상은</target>
        </trans-unit>
        <trans-unit id="4995af619bf2d3ae8de0384100aa88eb416db8e0" translate="yes" xml:space="preserve">
          <source>Other interesting, non-Perl books</source>
          <target state="translated">펄이 아닌 다른 흥미로운 책들</target>
        </trans-unit>
        <trans-unit id="a0a7f74c7a5b001c1898061e6c8bbb41c2b8f981" translate="yes" xml:space="preserve">
          <source>Other larger &lt;code&gt;regnode&lt;/code&gt; -like structures are defined in</source>
          <target state="translated">다른 더 큰 &lt;code&gt;regnode&lt;/code&gt; 유사 구조는</target>
        </trans-unit>
        <trans-unit id="54a8c70b7563cbb778a36bb5bcccfde96170f9d6" translate="yes" xml:space="preserve">
          <source>Other man pages to check out, like man(1), man(7), makewhatis(8), or catman(8). Normally a simple list of man pages separated by commas, or a paragraph giving the name of a reference work. Man page references, if they use the standard &lt;code&gt;name(section)&lt;/code&gt; form, don't have to be enclosed in L&amp;lt;&amp;gt; (although it's recommended), but other things in this section probably should be when appropriate.</source>
          <target state="translated">man (1), man (7), makewhatis (8) 또는 catman (8)과 같은 다른 맨 페이지를 확인하십시오. 일반적으로 쉼표로 구분 된 간단한 매뉴얼 페이지 또는 참조 작업의 이름을 나타내는 단락입니다. 매뉴얼 페이지 참조가 표준 &lt;code&gt;name(section)&lt;/code&gt; 양식 을 사용하는 경우 L &amp;lt;&amp;gt;로 묶을 필요는 없지만 (권장되지만)이 섹션의 다른 항목은 필요할 때 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a0be4d7126d12c4393a8f81b69236cf7f3adb37" translate="yes" xml:space="preserve">
          <source>Other methods defined in Encode::Encodings</source>
          <target state="translated">Encode :: Encodings에 정의 된 다른 메소드</target>
        </trans-unit>
        <trans-unit id="8b02b29f176b90b35adf0979292f2a1a362170a1" translate="yes" xml:space="preserve">
          <source>Other module design guidelines can be found in &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;.</source>
          <target state="translated">다른 모듈 설계 지침은 &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee6b0460067623519cc565a472bd480c100039cf" translate="yes" xml:space="preserve">
          <source>Other modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35b38a9ced9a9e6defe1372beb74c2a71438500f" translate="yes" xml:space="preserve">
          <source>Other modules provide more specific access: &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::ODBC&quot;&gt;Win32::ODBC&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Alzabo&quot;&gt;Alzabo&lt;/a&gt;, &lt;code&gt;iodbc&lt;/code&gt; , and others found on CPAN Search: &lt;a href=&quot;http://search.cpan.org/&quot;&gt;http://search.cpan.org/&lt;/a&gt; .</source>
          <target state="translated">다른 모듈은보다 구체적인 접근을 제공 : &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::ODBC&quot;&gt;는 Win32 :: ODBC&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Alzabo&quot;&gt;Alzabo는&lt;/a&gt; , &lt;code&gt;iodbc&lt;/code&gt; : 다른 사람들은 CPAN 검색에서 발견 &lt;a href=&quot;http://search.cpan.org/&quot;&gt;http://search.cpan.org/&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d291165f3e48fa04de2df661e5577d3237e36a86" translate="yes" xml:space="preserve">
          <source>Other options</source>
          <target state="translated">다른 옵션</target>
        </trans-unit>
        <trans-unit id="014edefbdeb134528c300bbe292e9dea3d3171e2" translate="yes" xml:space="preserve">
          <source>Other people picked up on this and started to write clever or obfuscated programs to produce the same output, spinning things quickly out of control while still providing hours of amusement for their creators and readers.</source>
          <target state="translated">다른 사람들은 이것을 선택하여 같은 결과물을 만들어 내기 위해 영리하거나 난독 화 된 프로그램을 작성하기 시작했으며, 제작자와 독자들에게 몇 시간의 즐거움을 제공하면서도 통제 할 수없는 것들을 빠르게 돌 렸습니다.</target>
        </trans-unit>
        <trans-unit id="b2c45e1355cf0a47d9a693c24c0422d1a1693c9c" translate="yes" xml:space="preserve">
          <source>Other perls</source>
          <target state="translated">다른 perls</target>
        </trans-unit>
        <trans-unit id="2d78880c37d6825d2ae3118f278c3357f9e4c7a8" translate="yes" xml:space="preserve">
          <source>Other places to ask questions are on the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.perlmonks.org%2f&quot;&gt;PerlMonks site&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fstackoverflow.com%2fquestions%2ftagged%2fperl&quot;&gt;stackoverflow&lt;/a&gt;.</source>
          <target state="translated">다른 질문은 &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.perlmonks.org%2f&quot;&gt;PerlMonks 사이트&lt;/a&gt; 또는 &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fstackoverflow.com%2fquestions%2ftagged%2fperl&quot;&gt;stackoverflow에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="94bfe5471f8f9572c8f23295ec358290aa5c0ef5" translate="yes" xml:space="preserve">
          <source>Other prebuilt perl binaries</source>
          <target state="translated">사전 빌드 된 다른 펄 바이너리</target>
        </trans-unit>
        <trans-unit id="e084077b7075b7e9a73a17897df829f14ab4b896" translate="yes" xml:space="preserve">
          <source>Other return codes are defined. See below and in the Berkeley DB documentation for details. The Berkeley DB documentation should be used as the definitive source.</source>
          <target state="translated">다른 리턴 코드가 정의되어 있습니다. 자세한 내용은 아래 및 Berkeley DB 설명서를 참조하십시오. Berkeley DB 문서는 최종 소스로 사용되어야합니다.</target>
        </trans-unit>
        <trans-unit id="b333dbc669f480c73b5b58df634b402ae239a596" translate="yes" xml:space="preserve">
          <source>Other than &lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt;, this module upgrades to Math::BigRat, meaning that instead of 2.5 you will get 2+1/2 as output.</source>
          <target state="translated">&lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt; 이외 의이 모듈은 Math :: BigRat으로 업그레이드됩니다. 즉, 2.5 대신 2 + 1 / 2가 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="eb36362d59c4594cc709a7ea4be2c2f79bf0b417" translate="yes" xml:space="preserve">
          <source>Other than those two situations, I don't imagine that it's useful to override the &lt;code&gt;maketext&lt;/code&gt; method. (If you run into a situation where it is useful, I'd be interested in hearing about it.)</source>
          <target state="translated">이 두 가지 상황을 제외하고는 &lt;code&gt;maketext&lt;/code&gt; 메서드 를 재정의하는 것이 유용하다고 생각하지 않습니다 . (유용한 상황에 처하면 그것에 대해 듣고 싶습니다.)</target>
        </trans-unit>
        <trans-unit id="3a5b57060690dc31c3058289c6a303662394ee99" translate="yes" xml:space="preserve">
          <source>Other useful functions are &lt;code&gt;Perl_dump_sub&lt;/code&gt; , which turns a &lt;code&gt;GV&lt;/code&gt; into an op tree, &lt;code&gt;Perl_dump_packsubs&lt;/code&gt; which calls &lt;code&gt;Perl_dump_sub&lt;/code&gt; on all the subroutines in a package like so: (Thankfully, these are all xsubs, so there is no op tree)</source>
          <target state="translated">다른 유용한 기능은 &lt;code&gt;Perl_dump_sub&lt;/code&gt; 권수, &lt;code&gt;GV&lt;/code&gt; 를 연산 트리에, &lt;code&gt;Perl_dump_packsubs&lt;/code&gt; 호출 &lt;code&gt;Perl_dump_sub&lt;/code&gt; 을 패키지에 모든 서브 루틴에 같은 : (감사하게도,이 모든 XSUB의, 그래서 연산 나무 없음)</target>
        </trans-unit>
        <trans-unit id="7aec5a2099bba9d9c155d5ff98c8d088a4d87e95" translate="yes" xml:space="preserve">
          <source>Other useful sources include the Unicode Glossary &lt;a href=&quot;http://unicode.org/glossary/&quot;&gt;http://unicode.org/glossary/&lt;/a&gt;, the Free On-Line Dictionary of Computing &lt;a href=&quot;http://foldoc.org/&quot;&gt;http://foldoc.org/&lt;/a&gt;, the Jargon File &lt;a href=&quot;http://catb.org/~esr/jargon/&quot;&gt;http://catb.org/~esr/jargon/&lt;/a&gt;, and Wikipedia &lt;a href=&quot;http://www.wikipedia.org/&quot;&gt;http://www.wikipedia.org/&lt;/a&gt;.</source>
          <target state="translated">다른 유용한 소스로는 유니 코드 용어집 &lt;a href=&quot;http://unicode.org/glossary/&quot;&gt;http://unicode.org/glossary/&lt;/a&gt; , 무료 온라인 사전 사전 &lt;a href=&quot;http://foldoc.org/&quot;&gt;http://foldoc.org/&lt;/a&gt; , 전문 용어 파일 &lt;a href=&quot;http://catb.org/~esr/jargon/&quot;&gt;http://catb.org/~esr/jargon이 있습니다. /&lt;/a&gt; , 그리고 위키 백과 &lt;a href=&quot;http://www.wikipedia.org/&quot;&gt;http://www.wikipedia.org/&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a5dd1af1a4d04ac7e7f3b21f718a7e15571fdc1c" translate="yes" xml:space="preserve">
          <source>Other voting mechanisms may be used instead, as long as the same number of votes is gathered in a transparent manner. Specifically, proposals of which changes to cherry-pick must be visible to everyone on perl5-porters so that the views of everyone interested may be heard.</source>
          <target state="translated">동일한 수의 투표가 투명한 방식으로 수집되는 한, 다른 투표 메커니즘이 대신 사용될 수 있습니다. 특히, 체리 픽에 대한 변경 제안은 perl5 포터에있는 모든 사람이 볼 수 있어야 관심있는 모든 사람의 의견을들을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ac0cc8652af1d4f7f345245edd00769715fa15d" translate="yes" xml:space="preserve">
          <source>Otherwise (i.e., if not a CGI), this tries various OS-specific ways to get the language-tags for the current locale/language, and then pretends that those were the value(s) passed to &lt;code&gt;get_handle&lt;/code&gt; .</source>
          <target state="translated">그렇지 않으면 (CGI가 아닌 경우), 현재 로케일 / 언어의 언어 태그를 가져 오기 위해 다양한 OS 특정 방법을 시도한 다음 &lt;code&gt;get_handle&lt;/code&gt; 로 전달 된 값인 것처럼 가장합니다 .</target>
        </trans-unit>
        <trans-unit id="a8e5ffbd89769bd3258cb9b3ff5d583b3da49162" translate="yes" xml:space="preserve">
          <source>Otherwise if &lt;code&gt;Configure&lt;/code&gt; found out how to do &quot;fast&quot; IO using the system's stdio, then the default layers are:</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;Configure&lt;/code&gt; 가 시스템의 stdio를 사용하여 &quot;빠른&quot;IO를 수행하는 방법을 찾은 경우 기본 계층은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7e1be4e61a83d07cd0d9ce46ed206ea82b9d2b71" translate="yes" xml:space="preserve">
          <source>Otherwise if you really do want to build Perl, you need to get a binary version of &lt;code&gt;gcc&lt;/code&gt; for your system first. Use a search engine to find out how to do this for your operating system.</source>
          <target state="translated">그렇지 않으면 실제로 Perl을 빌드하려면 시스템에 바이너리 버전의 &lt;code&gt;gcc&lt;/code&gt; 가 필요합니다. 검색 엔진을 사용하여 운영 체제에서이를 수행하는 방법을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="16e91ca326f6d29d45932c9e83458e6f42f6b2d6" translate="yes" xml:space="preserve">
          <source>Otherwise the &lt;code&gt;PerlIO&lt;/code&gt; package is a place holder for additional PerlIO related functions.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;PerlIO&lt;/code&gt; 패키지는 추가 PerlIO 관련 기능을위한 자리 표시 자입니다.</target>
        </trans-unit>
        <trans-unit id="64d28c2a38bdb42602aa40deca558a7edd1c1d73" translate="yes" xml:space="preserve">
          <source>Otherwise the default layers are</source>
          <target state="translated">그렇지 않으면 기본 레이어는</target>
        </trans-unit>
        <trans-unit id="8ee20b17c349e20c2d2bb84cf8ffa7aac44d8cc6" translate="yes" xml:space="preserve">
          <source>Otherwise this bracket group is invalid. For example, in the group &quot;[!@#,whatever]&quot;, the first item &lt;code&gt;&quot;!@#&quot;&lt;/code&gt; is neither the empty-string, &quot;_</source>
          <target state="translated">그렇지 않으면이 괄호 그룹이 유효하지 않습니다. 예를 들어 &quot;[! @ #, whatever]&quot;그룹에서 첫 번째 항목 &lt;code&gt;&quot;!@#&quot;&lt;/code&gt; 은 빈 문자열 &quot;_&quot;도 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7aa4578f342729b5a29e5d40bab856fc0c1cb526" translate="yes" xml:space="preserve">
          <source>Otherwise we will try and temporarily redirect STDERR and STDOUT, do a &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; call with your command and then re-open STDERR and STDOUT. This is the method of last resort and will still allow you to execute your commands cleanly. However, no buffers will be available.</source>
          <target state="translated">그렇지 않으면 STDERR 및 STDOUT을 일시적으로 리디렉션하고 명령 으로 &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 호출을 한 다음 STDERR 및 STDOUT을 다시 엽니 다. 이것은 최후의 수단이며 여전히 명령을 깨끗하게 실행할 수 있습니다. 그러나 사용 가능한 버퍼가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c3a8d6e2eac21a8bc64fe947c356d86d63089cab" translate="yes" xml:space="preserve">
          <source>Otherwise, &lt;code&gt;/a&lt;/code&gt; behaves like the &lt;code&gt;/u&lt;/code&gt; modifier, in that case-insensitive matching uses Unicode rules; for example, &quot;k&quot; will match the Unicode &lt;code&gt;\N{KELVIN SIGN}&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; matching, and code points in the Latin1 range, above ASCII will have Unicode rules when it comes to case-insensitive matching.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;/a&lt;/code&gt; 는 &lt;code&gt;/u&lt;/code&gt; 수정 자 처럼 동작 합니다. 대소 문자를 구분하지 않는 일치는 유니 코드 규칙을 사용합니다. 예를 들어, &quot;k&quot;는 &lt;code&gt;/i&lt;/code&gt; 일치 아래 의 유니 코드 &lt;code&gt;\N{KELVIN SIGN}&lt;/code&gt; 과 일치하며 Latin1 범위의 코드 포인트는 ASCII와 일치하지 않으며 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="283ab41299e1a089a797efad0855b8234af41dba" translate="yes" xml:space="preserve">
          <source>Otherwise, &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; demands that a library file be included if it hasn't already been included. The file is included via the do-FILE mechanism, which is essentially just a variety of &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; with the caveat that lexical variables in the invoking script will be invisible to the included code. If it were implemented in pure Perl, it would have semantics similar to the following:</source>
          <target state="translated">그렇지 않으면 라이브러리 파일이 포함되어 있지 않은 경우 포함 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 요구합니다. 이 파일은 do-FILE 메커니즘을 통해 포함되는데, 이는 기본적으로 호출 스크립트의 어휘 변수가 포함 된 코드에 표시되지 않는다는 경고와 함께 다양한 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 입니다. 순수한 Perl로 구현되면 다음과 유사한 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="3d8c7636a7e3958c42214af86cef6bf8fdccad1c" translate="yes" xml:space="preserve">
          <source>Otherwise, &lt;code&gt;&lt;a href=&quot;perllocale&quot;&gt;use locale&lt;/a&gt;&lt;/code&gt; sets the default modifier to &lt;code&gt;/l&lt;/code&gt; ; and &lt;code&gt;&lt;a href=&quot;feature&quot;&gt;use feature 'unicode_strings&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use VERSION&lt;/a&gt;&lt;/code&gt; (or higher) set the default to &lt;code&gt;/u&lt;/code&gt; when not in the same scope as either &lt;code&gt;&lt;a href=&quot;perllocale&quot;&gt;use locale&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;bytes&quot;&gt;use bytes&lt;/a&gt;&lt;/code&gt;. (&lt;code&gt;&lt;a href=&quot;perllocale#Unicode-and-UTF-8&quot;&gt;use locale ':not_characters'&lt;/a&gt;&lt;/code&gt; also sets the default to &lt;code&gt;/u&lt;/code&gt; , overriding any plain &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; .) Unlike the mechanisms mentioned above, these affect operations besides regular expressions pattern matching, and so give more consistent results with other operators, including using &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\l&lt;/code&gt; , etc. in substitution replacements.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;&lt;a href=&quot;perllocale&quot;&gt;use locale&lt;/a&gt;&lt;/code&gt; 하여 기본 수정자를 &lt;code&gt;/l&lt;/code&gt; 로 설정합니다 . 및 &lt;code&gt;&lt;a href=&quot;feature&quot;&gt;use feature 'unicode_strings&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use VERSION&lt;/a&gt;&lt;/code&gt; (또는 그 이상)을 기본으로 설정 &lt;code&gt;/u&lt;/code&gt; 않을 때 하나와 동일한 범위에서 &lt;code&gt;&lt;a href=&quot;perllocale&quot;&gt;use locale&lt;/a&gt;&lt;/code&gt; 나 &lt;code&gt;&lt;a href=&quot;bytes&quot;&gt;use bytes&lt;/a&gt;&lt;/code&gt; . ( &lt;code&gt;&lt;a href=&quot;perllocale#Unicode-and-UTF-8&quot;&gt;use locale ':not_characters'&lt;/a&gt;&lt;/code&gt; 를 사용하면 기본값이 &lt;code&gt;/u&lt;/code&gt; 로 설정되어 일반 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 재정의합니다 .) 위에서 언급 한 메커니즘과 달리, 이는 정규 표현식 패턴 일치 외에 조작에 영향을 미치므로 &lt;code&gt;\U&lt;/code&gt; 사용을 포함하여 다른 연산자와보다 일관된 결과를 제공합니다. U , &lt;code&gt;\l&lt;/code&gt; 대체 대체품 등.</target>
        </trans-unit>
        <trans-unit id="4164414c2bb6199a4fd794c5abe6619c58bbd334" translate="yes" xml:space="preserve">
          <source>Otherwise, &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; demands that a library file be included if it hasn't already been included. The file is included via the do-FILE mechanism, which is essentially just a variety of &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; with the caveat that lexical variables in the invoking script will be invisible to the included code. If it were implemented in pure Perl, it would have semantics similar to the following:</source>
          <target state="translated">그렇지 않으면 라이브러리 파일이 포함되어 있지 않은 경우 포함 &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 요구합니다. 이 파일은 do-FILE 메커니즘을 통해 포함되는데, 이는 기본적으로 호출 스크립트의 어휘 변수가 포함 된 코드에 표시되지 않는다는 경고와 함께 다양한 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 입니다. 순수한 Perl로 구현되면 다음과 유사한 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="b7cd0e99a1d89c3f5e339c3635e7cb0b51fb95e1" translate="yes" xml:space="preserve">
          <source>Otherwise, If EXPR has the UTF8 flag set:</source>
          <target state="translated">그렇지 않으면 EXPR에 UTF8 플래그가 설정된 경우 :</target>
        </trans-unit>
        <trans-unit id="17eeffaf5cce6164da792d14c62e778122ced660" translate="yes" xml:space="preserve">
          <source>Otherwise, Perl quotes non-ASCII characters using an adaptation from Unicode (see &lt;a href=&quot;http://www.unicode.org/reports/tr31/&quot;&gt;http://www.unicode.org/reports/tr31/&lt;/a&gt;). The only code points that are quoted are those that have any of the Unicode properties: Pattern_Syntax, Pattern_White_Space, White_Space, Default_Ignorable_Code_Point, or General_Category=Control.</source>
          <target state="translated">그렇지 않으면 Perl은 유니 코드의 적응을 사용하여 비 ASCII 문자를 인용합니다 ( &lt;a href=&quot;http://www.unicode.org/reports/tr31/&quot;&gt;http://www.unicode.org/reports/tr31/ 참조&lt;/a&gt; ). 인용되는 유일한 코드 포인트는 Pattern_Syntax, Pattern_White_Space, White_Space, Default_Ignorable_Code_Point 또는 General_Category = Control과 같은 유니 코드 속성이있는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4b263d3e8956ad637fdb45e6619d7bb400854c44" translate="yes" xml:space="preserve">
          <source>Otherwise, a reference to a hash giving the mappings (or a reference to a hash of such hashes, explained below) is returned with the following keys and their meanings:</source>
          <target state="translated">그렇지 않으면 매핑을 제공하는 해시에 대한 참조 (또는 아래 설명 된 해시의 해시에 대한 참조)가 다음 키와 의미로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0a064c97bd76ea2baffc6a1f976852c73f8662d5" translate="yes" xml:space="preserve">
          <source>Otherwise, any string that includes a &lt;code&gt;\N{&lt;i&gt;charname&lt;/i&gt;}&lt;/code&gt; or &lt;code&gt;\N{U+&lt;i&gt;code point&lt;/i&gt;}&lt;/code&gt; will automatically have Unicode rules (see &lt;a href=&quot;perlunicode#Byte-and-Character-Semantics&quot;&gt;Byte and Character Semantics in perlunicode&lt;/a&gt;).</source>
          <target state="translated">그렇지 않으면, &lt;code&gt;\N{&lt;i&gt;charname&lt;/i&gt;}&lt;/code&gt; 또는 &lt;code&gt;\N{U+&lt;i&gt;code point&lt;/i&gt;}&lt;/code&gt; 를 포함하는 문자열 은 자동으로 유니 코드 규칙 &lt;a href=&quot;perlunicode#Byte-and-Character-Semantics&quot;&gt;을 갖습니다 (perlunicode의 바이트 및 문자 의미&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="5d003c1d5c8b3dbf299902770f34abe7c1bae5fc" translate="yes" xml:space="preserve">
          <source>Otherwise, besides slowing you down, you're going to break code when the thing in the scalar is actually neither a string nor a number, but a reference:</source>
          <target state="translated">그렇지 않으면, 속도를 늦추는 것 외에도 스칼라의 것이 실제로 문자열이나 숫자가 아니라 참조 일 때 코드가 깨집니다.</target>
        </trans-unit>
        <trans-unit id="3c9e5051cf80855af13f05b6891812714206afb2" translate="yes" xml:space="preserve">
          <source>Otherwise, each group is taken to be a comma-separated group of items, and each item is interpreted as follows:</source>
          <target state="translated">그렇지 않으면 각 그룹은 쉼표로 구분 된 항목 그룹으로 간주되며 각 항목은 다음과 같이 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="44c4557e33865fb576853827b17e4610d1545dd5" translate="yes" xml:space="preserve">
          <source>Otherwise, each item is interpreted as a string literal.</source>
          <target state="translated">그렇지 않으면 각 항목은 문자열 리터럴로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="8160c1d9bfe0c258f726fcde8a38eac529a9399b" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale ':not_characters'&lt;/code&gt; is in effect:</source>
          <target state="translated">그렇지 않은 경우 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale ':not_characters'&lt;/code&gt; 적용됩니다 :</target>
        </trans-unit>
        <trans-unit id="330cfb4214259a5977f17a0c8047846f1febf41e" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; for &lt;code&gt;LC_CTYPE&lt;/code&gt; is in effect:</source>
          <target state="translated">그렇지 않은 경우에 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 에 대한 &lt;code&gt;LC_CTYPE&lt;/code&gt; 이 적용됩니다 :</target>
        </trans-unit>
        <trans-unit id="790132dff7791f0de9ca7fa702e257d000b8a890" translate="yes" xml:space="preserve">
          <source>Otherwise, if fallback is TRUE or undefined for the first operand then see if the &lt;a href=&quot;#Magic-Autogeneration&quot;&gt;rules for autogeneration&lt;/a&gt; allows another of its operators to be used instead.</source>
          <target state="translated">그렇지 않으면, 대체가 참이거나 첫 번째 피연산자에 대해 정의되지 않은 경우 &lt;a href=&quot;#Magic-Autogeneration&quot;&gt;자동 생성 규칙이&lt;/a&gt; 다른 연산자를 대신 사용할 수 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="3ed36ee27979b8527903ca8fac2a605c006c6947" translate="yes" xml:space="preserve">
          <source>Otherwise, if neither &lt;code&gt;CARP_TRACE&lt;/code&gt; nor &lt;code&gt;$Carp::RefArgFormatter&lt;/code&gt; is available, stringify the value ignoring any overloading.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;CARP_TRACE&lt;/code&gt; 나 &lt;code&gt;$Carp::RefArgFormatter&lt;/code&gt; 를 사용할 수 없으면 과부하를 무시하고 값을 문자열 화하십시오.</target>
        </trans-unit>
        <trans-unit id="2f787cbc7a032f69fffb6119d7035816b8ea11e2" translate="yes" xml:space="preserve">
          <source>Otherwise, if the variable &lt;code&gt;$IPC::Cmd::USE_IPC_OPEN3&lt;/code&gt; is set to true (See the &lt;a href=&quot;#Global-Variables&quot;&gt;Global Variables&lt;/a&gt; section), try to execute the command using &lt;a href=&quot;open3&quot;&gt;IPC::Open3&lt;/a&gt;. Buffers will be available on all platforms, interactive commands will still execute cleanly, and also your verbosity settings will be adhered to nicely;</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;$IPC::Cmd::USE_IPC_OPEN3&lt;/code&gt; 변수 가 true로 설정되면 ( &lt;a href=&quot;#Global-Variables&quot;&gt;글로벌 변수&lt;/a&gt; 섹션 참조) &lt;a href=&quot;open3&quot;&gt;IPC :: Open3을&lt;/a&gt; 사용하여 명령을 실행하십시오 . 버퍼는 모든 플랫폼에서 사용할 수 있으며 대화식 명령은 여전히 ​​깨끗하게 실행되며 자세한 설정도 잘 준수합니다.</target>
        </trans-unit>
        <trans-unit id="fe09ff3823115671ffa501d26ad1a577bc040ded" translate="yes" xml:space="preserve">
          <source>Otherwise, if you have the &lt;code&gt;verbose&lt;/code&gt; argument set to true, we fall back to a simple &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; call. We cannot capture any buffers, but interactive commands will still work.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;verbose&lt;/code&gt; 인수를 true로 설정하면 간단한 &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 호출로 돌아갑니다 . 버퍼를 캡처 할 수 없지만 대화식 명령은 계속 작동합니다.</target>
        </trans-unit>
        <trans-unit id="643e7b58bd1c31793f061806f8ffae4f428818df" translate="yes" xml:space="preserve">
          <source>Otherwise, import the functions into a convenient package like &lt;code&gt;HUF&lt;/code&gt; or, more general, &lt;code&gt;Aux&lt;/code&gt;</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;HUF&lt;/code&gt; 또는보다 일반적인 &lt;code&gt;Aux&lt;/code&gt; 와 같은 편리한 패키지로 함수를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="ec3718eb10f9299de84d9700b81d5d9ff67ef5c1" translate="yes" xml:space="preserve">
          <source>Otherwise, it returns the index into the list of the range that contains the code point.; that is, find &lt;code&gt;i&lt;/code&gt; such that</source>
          <target state="translated">그렇지 않으면 코드 포인트가 포함 된 범위 목록으로 인덱스를 반환합니다.; 즉, &lt;code&gt;i&lt;/code&gt; 그런 찾을</target>
        </trans-unit>
        <trans-unit id="0d7b4536a86a677a8d4d8e936e21d06c203d8809" translate="yes" xml:space="preserve">
          <source>Otherwise, one can &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; , which has effects at compile time and run time. Since Perl 5.9.5, this pragma is lexically scoped.</source>
          <target state="translated">그렇지 않으면 컴파일 타임과 런타임에 영향을 미치는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용할&lt;/a&gt; 수 있습니다 . Perl 5.9.5부터이 pragma의 범위는 어휘 범위입니다.</target>
        </trans-unit>
        <trans-unit id="060d2d5af4a10b8f17638e7be02655b970ad0e80" translate="yes" xml:space="preserve">
          <source>Otherwise, the &quot;fail&quot; attribute's value should be a string denoting a method name, so that $lh-&amp;gt;maketext(</source>
          <target state="translated">그렇지 않으면, &quot;fail&quot;속성의 값은 메소드 이름을 나타내는 문자열이어야합니다. 그래서 $ lh-&amp;gt; maketext (</target>
        </trans-unit>
        <trans-unit id="e4d6075a624f71d57d66727413b2c14075c13d0f" translate="yes" xml:space="preserve">
          <source>Otherwise, the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator behaves exactly as the comma operator or list argument separator, according to context.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;=&amp;gt;&lt;/code&gt; 연산자는 컨텍스트에 따라 쉼표 연산자 또는 목록 인수 구분 기호로 정확하게 동작합니다.</target>
        </trans-unit>
        <trans-unit id="153f18b9e853a33ec89bf986e0079606fc138189" translate="yes" xml:space="preserve">
          <source>Otherwise, the right side is a method name or a simple scalar variable containing either the method name or a subroutine reference, and the left side must be either an object (a blessed reference) or a class name (that is, a package name). See &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="translated">그렇지 않으면 오른쪽은 메소드 이름 또는 메소드 이름 또는 서브 루틴 참조를 포함하는 단순 스칼라 변수이고 왼쪽은 오브젝트 (축복 참조) 또는 클래스 이름 (즉, 패키지 이름)이어야합니다. . &lt;a href=&quot;perlobj&quot;&gt;perlobj를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="93adaa86658b0d707fd7e6f95b2dd74b9f755925" translate="yes" xml:space="preserve">
          <source>Otherwise, you can use the File::Temp module.</source>
          <target state="translated">그렇지 않으면 File :: Temp 모듈을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cbc6561d27e47c3ea5b5fa6d9459eb9629b7617" translate="yes" xml:space="preserve">
          <source>Otherwise:</source>
          <target state="translated">Otherwise:</target>
        </trans-unit>
        <trans-unit id="96b81f4b95ad77a7f2490339a2a4369277de66dd" translate="yes" xml:space="preserve">
          <source>Our best advice for verifying a person's mail address is to have them enter their address twice, just as you normally do to change a password. This usually weeds out typos. If both versions match, send mail to that address with a personal message. If you get the message back and they've followed your directions, you can be reasonably assured that it's real.</source>
          <target state="translated">사람의 메일 주소를 확인하기위한 최선의 조언은 일반적으로 암호를 변경하는 것과 마찬가지로 주소를 두 번 입력하는 것입니다. 이것은 일반적으로 오타를 제거합니다. 두 버전이 모두 일치하면 개인 메시지와 함께 해당 주소로 메일을 보내십시오. 메시지를 받고 그들이 당신의 지시를 따랐다면, 당신은 그것이 진짜라고 확신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a36d716e41b5fdfa6778288f0df9280c6ac367a9" translate="yes" xml:space="preserve">
          <source>Our community has a long-held belief that backward-compatibility is a virtue, even when the functionality in question is a design flaw.</source>
          <target state="translated">우리 커뮤니티는 문제의 기능이 디자인 결함 일지라도 이전 버전과의 호환성이 미덕이라고 오랫동안 믿고 있습니다.</target>
        </trans-unit>
        <trans-unit id="aca2af8fba9b0e206c26228fbcf4f0a28aadfadd" translate="yes" xml:space="preserve">
          <source>Our constructor and accessors are not very smart. They don't check that a &lt;code&gt;$path&lt;/code&gt; is defined, nor do they check that a &lt;code&gt;$path&lt;/code&gt; is a valid filesystem path.</source>
          <target state="translated">우리의 생성자와 접근자는 그리 영리하지 않습니다. 그들은 확인하지 않는 &lt;code&gt;$path&lt;/code&gt; 정의 없으며이 있는지 확인 할 수 &lt;code&gt;$path&lt;/code&gt; 유효한 파일 시스템 경로입니다.</target>
        </trans-unit>
        <trans-unit id="02046a00610d7c36994a4a1cfc35b185bf538e5f" translate="yes" xml:space="preserve">
          <source>Our first extension will be very simple. When we call the routine in the extension, it will print out a well-known message and return.</source>
          <target state="translated">첫 번째 확장은 매우 간단합니다. 확장 프로그램에서 루틴을 호출하면 잘 알려진 메시지가 인쇄되어 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ea0a64102e29c4a40939ff09bce3a7c8b3baeb50" translate="yes" xml:space="preserve">
          <source>Our goals include, but are not limited to:</source>
          <target state="translated">우리의 목표는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dd423773d407b1a40adc986c561aae58350fc823" translate="yes" xml:space="preserve">
          <source>Our third extension will take one argument as its input, round off that value, and set the</source>
          <target state="translated">세 번째 확장은 하나의 인수를 입력으로 사용하고 해당 값을 반올림 한 다음</target>
        </trans-unit>
        <trans-unit id="d1eca9c1df299ed6f167227271a421fa1ed8acd5" translate="yes" xml:space="preserve">
          <source>Out of Memory!</source>
          <target state="translated">메모리 부족!</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="dbd857869dc8d796444978bd605ba7b7d270b4e9" translate="yes" xml:space="preserve">
          <source>Output File Glob</source>
          <target state="translated">출력 파일 글롭</target>
        </trans-unit>
        <trans-unit id="cabfa26f9d0a36c1ea391888431d2b012edaa467" translate="yes" xml:space="preserve">
          <source>Output FileGlobs take the</source>
          <target state="translated">출력 FileGlob은</target>
        </trans-unit>
        <trans-unit id="320abeb6fc8745d8377c151e5e59cdadfc038781" translate="yes" xml:space="preserve">
          <source>Output arguments for linking the Perl library and any extensions linked with the current Perl.</source>
          <target state="translated">Perl 라이브러리 및 현재 Perl과 링크 된 확장을 링크하기위한 출력 인수.</target>
        </trans-unit>
        <trans-unit id="dff47f3a71d82ad60cb4cacc40b69b766de3ff9e" translate="yes" xml:space="preserve">
          <source>Output arguments for linking the Perl library and extensions to your application.</source>
          <target state="translated">Perl 라이브러리 및 확장을 응용 프로그램에 링크하기위한 출력 인수.</target>
        </trans-unit>
        <trans-unit id="d4513ca13498ae2966be4acb14ad297fe3972a7d" translate="yes" xml:space="preserve">
          <source>Output data values (when they appear as constants) using Data::Dumper. Without this option, B::Deparse will use some simple routines of its own for the same purpose. Currently, Data::Dumper is better for some kinds of data (such as complex structures with sharing and self-reference) while the built-in routines are better for others (such as odd floating-point values).</source>
          <target state="translated">Data :: Dumper를 사용하여 출력 데이터 값 (상수로 표시 될 때). 이 옵션이 없으면 B :: Deparse는 동일한 목적으로 몇 가지 간단한 루틴을 사용합니다. 현재 Data :: Dumper는 일부 유형의 데이터 (예 : 공유 및 자체 참조가있는 복잡한 구조)에 적합하고 내장 루틴은 다른 유형 (예 : 홀수 부동 소수점 값)에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="946f8eaf8de365c1db6707020e600be8dc0b2d32" translate="yes" xml:space="preserve">
          <source>Output from</source>
          <target state="translated">출력</target>
        </trans-unit>
        <trans-unit id="732197af5a245075eb093be6a52f4e49643ea019" translate="yes" xml:space="preserve">
          <source>Output produced by &lt;code&gt;POSIX::strftime()&lt;/code&gt; , which builds a formatted human-readable date/time string, is affected by the current &lt;code&gt;LC_TIME&lt;/code&gt; locale. Thus, in a French locale, the output produced by the &lt;code&gt;%B&lt;/code&gt; format element (full month name) for the first month of the year would be &quot;janvier&quot;. Here's how to get a list of long month names in the current locale:</source>
          <target state="translated">형식화 된 사람이 읽을 수있는 날짜 / 시간 문자열을 빌드하는 &lt;code&gt;POSIX::strftime()&lt;/code&gt; 의해 생성 된 출력 은 현재 &lt;code&gt;LC_TIME&lt;/code&gt; 로케일의 영향을받습니다 . 따라서 프랑스어 로케일 에서 첫 번째 달의 &lt;code&gt;%B&lt;/code&gt; 형식 요소 (전체 달 이름)에 의해 생성 된 출력은 &quot;janvier&quot;입니다. 현재 로케일에서 긴 달 이름 목록을 얻는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d20389c9ad811915dc895816013a0d6320f55cc3" translate="yes" xml:space="preserve">
          <source>Output record formats are declared as follows:</source>
          <target state="translated">출력 레코드 형식은 다음과 같이 선언됩니다.</target>
        </trans-unit>
        <trans-unit id="8be7301f815488d71ba9c93bb5af631cc0c5c280" translate="yes" xml:space="preserve">
          <source>Output test preamble</source>
          <target state="translated">출력 테스트 프리앰블</target>
        </trans-unit>
        <trans-unit id="0cb96efb75c4bbeb8be2ce6be1b81199c7dc6523" translate="yes" xml:space="preserve">
          <source>Output the string for the given capability padded as appropriate without any parameter substitution.</source>
          <target state="translated">매개 변수 대체없이 적절하게 채워진 지정된 기능에 대한 문자열을 출력하십시오.</target>
        </trans-unit>
        <trans-unit id="e4a057a50b92dcf0b95865eb0847c9c19f40cf41" translate="yes" xml:space="preserve">
          <source>Output the summary for a &lt;a href=&quot;parser/aggregator&quot;&gt;TAP::Parser::Aggregator&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;parser/aggregator&quot;&gt;TAP :: Parser :: Aggregator&lt;/a&gt; 의 요약을 출력하십시오 .</target>
        </trans-unit>
        <trans-unit id="674e1e7520d063a11e6ddc4e4cd926f65dce8e61" translate="yes" xml:space="preserve">
          <source>Output values are BigFloat objects (normalized), except for bstr() and bsstr().</source>
          <target state="translated">bstr () 및 bsstr ()을 제외하고 출력 값은 BigFloat 객체 (정규화 됨)입니다.</target>
        </trans-unit>
        <trans-unit id="5729e52e9619576e333d708f5b86cf53768b1b3b" translate="yes" xml:space="preserve">
          <source>Output values are BigInt objects (normalized), except for the methods which return a string (see &lt;a href=&quot;#SYNOPSIS&quot;&gt;SYNOPSIS&lt;/a&gt;).</source>
          <target state="translated">출력 값은 문자열을 리턴하는 메소드를 제외하고 BigInt 오브젝트 (정규화 됨 )입니다 ( &lt;a href=&quot;#SYNOPSIS&quot;&gt;SYNOPSIS&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="92ee72c25cceb27be8a2caf11cbdcbd8ed211c74" translate="yes" xml:space="preserve">
          <source>Output will be indented and marked with a # so as not to interfere with test output. A newline will be put on the end if there isn't one already.</source>
          <target state="translated">출력은 테스트 출력을 방해하지 않도록 들여 쓰기되고 #으로 표시됩니다. 줄 바꿈이 없으면 끝에 줄 바꿈이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1c19ab0b423651729aa903ab380edeb2bca39734" translate="yes" xml:space="preserve">
          <source>Outputs a literal string with appropriate padding for the current terminal.</source>
          <target state="translated">현재 터미널에 적절한 패딩이있는 리터럴 문자열을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="6ee76fa98a639a0ac269010b7032639b0a171647" translate="yes" xml:space="preserve">
          <source>Outputs:</source>
          <target state="translated">Outputs:</target>
        </trans-unit>
        <trans-unit id="27666598a1e0a42575577d9b60e589550171ef9f" translate="yes" xml:space="preserve">
          <source>Outstanding Issues with Perl on QNX4</source>
          <target state="translated">QNX4에서 Perl의 두드러진 문제</target>
        </trans-unit>
        <trans-unit id="639d7ade090cee980c6bc05e57d3d1577af16a27" translate="yes" xml:space="preserve">
          <source>Outstanding issues with perl under QNX6</source>
          <target state="translated">QNX6에서 펄에 대한 뛰어난 문제</target>
        </trans-unit>
        <trans-unit id="bdf3ed1bb141b837355c86c7c0dd2614394d1b0b" translate="yes" xml:space="preserve">
          <source>Over this group of porters presides Larry Wall. He has the final word in what does and does not change in any of the Perl programming languages. These days, Larry spends most of his time on Perl 6, while Perl 5 is shepherded by a &quot;pumpking&quot;, a porter responsible for deciding what goes into each release and ensuring that releases happen on a regular basis.</source>
          <target state="translated">이 포터 그룹 위에 Larry Wall이 있습니다. 그는 Perl 프로그래밍 언어에서 무엇이 바뀌지 않는지에 대한 최종 단어를 가지고 있습니다. 요즘 Larry는 대부분의 시간을 Perl 6에서 보내며 Perl 5는 각 릴리스에 어떤 일이 발생하는지 결정하고 정기적으로 릴리스가 이루어 지도록하는 포터 인 &quot;펌핑 (pumpking)&quot;에 의해 보호됩니다.</target>
        </trans-unit>
        <trans-unit id="26e40e3844fb4d3113244cc032fb4a908e8fcd75" translate="yes" xml:space="preserve">
          <source>Overloadable Operations</source>
          <target state="translated">과부하 작업</target>
        </trans-unit>
        <trans-unit id="ec86957a0fb6a3d4fbc42d54b629b68b40ef88b9" translate="yes" xml:space="preserve">
          <source>Overloading Constants</source>
          <target state="translated">과부하 상수</target>
        </trans-unit>
        <trans-unit id="b399e489ae1423cf5aaa91fe52bb0ca8621359b8" translate="yes" xml:space="preserve">
          <source>Overloading respects inheritance via the @ISA hierarchy. Inheritance interacts with overloading in two ways.</source>
          <target state="translated">오버로드는 @ISA 계층을 통한 상속을 존중합니다. 상속은 두 가지 방식으로 오버로드와 상호 작용합니다.</target>
        </trans-unit>
        <trans-unit id="d25853ad0b9aa2087c0afaa6cc2a5913f690f84b" translate="yes" xml:space="preserve">
          <source>Overridable by PREFIX</source>
          <target state="translated">PREFIX로 대체 가능</target>
        </trans-unit>
        <trans-unit id="467a685e8ada69aefbe5924cc457f1afc183b3db" translate="yes" xml:space="preserve">
          <source>Overridden by PREFIX.</source>
          <target state="translated">PREFIX로 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="8de838ce5cdf14a3fefb1762cc63935ac8b01d94" translate="yes" xml:space="preserve">
          <source>Overridden methods</source>
          <target state="translated">재정의 된 메소드</target>
        </trans-unit>
        <trans-unit id="18ab6a26cd6f669c409ca6006d7c65633ebdbc28" translate="yes" xml:space="preserve">
          <source>Override Unix. Cygwin case-tolerance depends on managed mount settings and as with MsWin32 on GetVolumeInformation() $ouFsFlags == FS_CASE_SENSITIVE, indicating the case significance when comparing file specifications. Default: 1</source>
          <target state="translated">유닉스를 덮어 씁니다. Cygwin 대 / 소문자 허용 여부는 GetVolumeInformation ()의 MsWin32와 마찬가지로 관리되는 마운트 설정에 따라 달라집니다. $ ouFsFlags == FS_CASE_SENSITIVE는 파일 사양을 비교할 때 대소 문자의 중요성을 나타냅니다. 기본값 : 1</target>
        </trans-unit>
        <trans-unit id="b812a67f3c81aa251e9cf3aa48fd3d76b409d29b" translate="yes" xml:space="preserve">
          <source>Override some of the slower, portable commands with Windows specific ones.</source>
          <target state="translated">속도가 느린 휴대용 명령 중 일부를 Windows 전용 명령으로 재정의하십시오.</target>
        </trans-unit>
        <trans-unit id="d0c9857b122b80fa1b6a56bf1ebf37d184d83e68" translate="yes" xml:space="preserve">
          <source>Override the *DEFINE_VERSION macros with VMS semantics. Translate the MAKEMAKER filepath to VMS style.</source>
          <target state="translated">VMS 시맨틱으로 * DEFINE_VERSION 매크로를 대체하십시오. MAKEMAKER 파일 경로를 VMS 스타일로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="9e106e8d2f26a8506c045db84481cb6d80e276c4" translate="yes" xml:space="preserve">
          <source>Override the built-in hex() method with a version that can handle big integers. This overrides it by exporting it to the current package. Under Perl v5.10.0 and higher, this is not so necessary, as hex() is lexically overridden in the current scope whenever the bigint pragma is active.</source>
          <target state="translated">내장 hex () 메소드를 큰 정수를 처리 할 수있는 버전으로 대체하십시오. 현재 패키지로 내 보내서이를 대체합니다. Perl v5.10.0 이상에서는 bigint pragma가 활성화 될 때마다 hex ()가 현재 범위에서 어휘 적으로 재정의되므로 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="db1255a81faff303e8d6e7d3b798d7ce08d1d0bd" translate="yes" xml:space="preserve">
          <source>Override the built-in hex() method with a version that can handle big numbers. This overrides it by exporting it to the current package. Under Perl v5.10.0 and higher, this is not so necessary, as hex() is lexically overridden in the current scope whenever the bignum pragma is active.</source>
          <target state="translated">내장 hex () 메소드를 큰 숫자를 처리 할 수있는 버전으로 대체하십시오. 현재 패키지로 내 보내서이를 대체합니다. Perl v5.10.0 이상에서는 bignum pragma가 활성화 될 때마다 hex ()가 현재 범위에서 어휘 적으로 재정의되므로 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="912f152c86b0fefa5f757189a8d412dd86bae7f1" translate="yes" xml:space="preserve">
          <source>Override the built-in hex() method with a version that can handle big numbers. This overrides it by exporting it to the current package. Under Perl v5.10.0 and higher, this is not so necessary, as hex() is lexically overridden in the current scope whenever the bigrat pragma is active.</source>
          <target state="translated">내장 hex () 메소드를 큰 숫자를 처리 할 수있는 버전으로 대체하십시오. 현재 패키지로 내 보내서이를 대체합니다. Perl v5.10.0 이상에서는 bigrat pragma가 활성화 될 때마다 hex ()가 현재 범위에서 어휘 적으로 재정의되므로 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="517fe3ab934c9baa1bbd4819a553d1bd788ad3b6" translate="yes" xml:space="preserve">
          <source>Override the built-in oct() method with a version that can handle big integers. This overrides it by exporting it to the current package. Under Perl v5.10.0 and higher, this is not so necessary, as oct() is lexically overridden in the current scope whenever the bigint pragma is active.</source>
          <target state="translated">큰 정수를 처리 할 수있는 버전으로 내장 oct () 메소드를 대체하십시오. 현재 패키지로 내 보내서이를 대체합니다. Perl v5.10.0 이상에서는 bigint pragma가 활성화 될 때마다 현재 범위에서 oct ()가 사 전적으로 재정의되므로 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4bed448b71cf61598fc58c7dedb86dd2c891a406" translate="yes" xml:space="preserve">
          <source>Override the built-in oct() method with a version that can handle big numbers. This overrides it by exporting it to the current package. Under Perl v5.10.0 and higher, this is not so necessary, as oct() is lexically overridden in the current scope whenever the bigint pragma is active.</source>
          <target state="translated">내장 된 oct () 메소드를 큰 숫자를 처리 할 수있는 버전으로 대체하십시오. 현재 패키지로 내 보내서이를 대체합니다. Perl v5.10.0 이상에서는 bigint pragma가 활성화 될 때마다 현재 범위에서 oct ()가 사 전적으로 재정의되므로 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ed5c7e59eb86a96d19a5d320701f2eeae30a9f3d" translate="yes" xml:space="preserve">
          <source>Override the built-in oct() method with a version that can handle big numbers. This overrides it by exporting it to the current package. Under Perl v5.10.0 and higher, this is not so necessary, as oct() is lexically overridden in the current scope whenever the bigrat pragma is active.</source>
          <target state="translated">내장 된 oct () 메소드를 큰 숫자를 처리 할 수있는 버전으로 대체하십시오. 현재 패키지로 내 보내서이를 대체합니다. Perl v5.10.0 이상에서는 bigrat pragma가 활성화 될 때마다 현재 범위에서 oct ()가 사 전적으로 재정의되므로 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a84161f7c8651d9dbb9584e62df4eb94978336a4" translate="yes" xml:space="preserve">
          <source>Override the default link and compile tools.</source>
          <target state="translated">기본 링크 및 컴파일 도구를 대체하십시오.</target>
        </trans-unit>
        <trans-unit id="2e3576b163731229acda47e87e9f9b059e9f4a5b" translate="yes" xml:space="preserve">
          <source>Overriden Methods</source>
          <target state="translated">오버라이드 된 메소드</target>
        </trans-unit>
        <trans-unit id="88ddbf620473fa127baa14c63b6b03e218cdb828" translate="yes" xml:space="preserve">
          <source>Overrides &lt;code&gt;Carp&lt;/code&gt; 's use of &lt;code&gt;@ISA&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;Carp&lt;/code&gt; 의 &lt;code&gt;@ISA&lt;/code&gt; 사용을 재정의합니다 .</target>
        </trans-unit>
        <trans-unit id="0f558940f2808fb5910806545f490b364bd4fae6" translate="yes" xml:space="preserve">
          <source>Overriding *AutoLoader*'s AUTOLOAD Subroutine</source>
          <target state="translated">* AutoLoader *의 AUTOLOAD 서브 루틴 대체</target>
        </trans-unit>
        <trans-unit id="ad165e83687c2095d41c401a84a596f21c23d403" translate="yes" xml:space="preserve">
          <source>Overriding &lt;b&gt;AutoLoader&lt;/b&gt;'s AUTOLOAD Subroutine</source>
          <target state="translated">&lt;b&gt;AutoLoader&lt;/b&gt; 의 AUTOLOAD 서브 루틴 대체</target>
        </trans-unit>
        <trans-unit id="13e4e6c170816454742428861af9c648b7770476" translate="yes" xml:space="preserve">
          <source>Overriding Built-in Functions</source>
          <target state="translated">내장 함수 재정의</target>
        </trans-unit>
        <trans-unit id="0473324f13f95874cc801aec0b7f96d36dd3f4de" translate="yes" xml:space="preserve">
          <source>Overriding MakeMaker Methods</source>
          <target state="translated">MakeMaker 메서드 재정의</target>
        </trans-unit>
        <trans-unit id="8975db571ede7ae4ff4258fa3aa601af32455235" translate="yes" xml:space="preserve">
          <source>Overriding may be done only by importing the name from a module at compile time--ordinary predeclaration isn't good enough. However, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; pragma lets you, in effect, predeclare subs via the import syntax, and these names may then override built-in ones:</source>
          <target state="translated">컴파일 타임에 모듈에서 이름을 가져 와서 만 재정의를 수행 할 수 있습니다. 일반적인 사전 선언으로는 충분하지 않습니다. 그러나, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; pragma는 당신이 사실상 미리 선언 가져 오기 구문을 통해 잠수함,이 이름은 다음 내장 된 것을 오버라이드 (override) 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="304bd31d39d40b4f3f802e079ce7c0e189c81a09" translate="yes" xml:space="preserve">
          <source>Overriding methods and method resolution</source>
          <target state="translated">메소드 및 메소드 분석 대체</target>
        </trans-unit>
        <trans-unit id="ffad1af53b33d79810d2c0405dc312e1ae6928cd" translate="yes" xml:space="preserve">
          <source>Overstruck text is best viewed by page-at-a-time programs that take advantage of the terminal's &lt;b&gt;stand-out&lt;/b&gt; and</source>
          <target state="translated">Overstruck 텍스트가 가장 터미널의 이용을 한 번에 한 페이지 씩 프로그램에서 볼 &lt;b&gt;스탠드 아웃&lt;/b&gt; 과</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="a66e34441ac56e5f8863c6bb5ce6bb649c646c79" translate="yes" xml:space="preserve">
          <source>Ownwership of directories that already exist will not be changed.</source>
          <target state="translated">이미 존재하는 디렉토리의 소유권은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c90ae34a7bbf5b215bf702e4f15a56d1024f60a9" translate="yes" xml:space="preserve">
          <source>Oxford English Dictionary</source>
          <target state="translated">옥스포드 영어 사전</target>
        </trans-unit>
        <trans-unit id="511993d3c99719e38a6779073019dacd7178ddb9" translate="yes" xml:space="preserve">
          <source>P</source>
          <target state="translated">P</target>
        </trans-unit>
        <trans-unit id="a5574a0609f5eaeb5946f32c91fbd5d565ba5c54" translate="yes" xml:space="preserve">
          <source>PA-RISC</source>
          <target state="translated">PA-RISC</target>
        </trans-unit>
        <trans-unit id="b18e26c5d2442635220100cdbb4632471aa32d8c" translate="yes" xml:space="preserve">
          <source>PA-RISC 1.0</source>
          <target state="translated">PA-RISC 1.0</target>
        </trans-unit>
        <trans-unit id="eb216919e4e2e5c1a44316f9467b8ca7837ec3cc" translate="yes" xml:space="preserve">
          <source>PA-RISC 1.1</source>
          <target state="translated">PA-RISC 1.1</target>
        </trans-unit>
        <trans-unit id="db7ada64f0dcd494ae2a9fde52058fe389930fc0" translate="yes" xml:space="preserve">
          <source>PA-RISC 2.0</source>
          <target state="translated">PA-RISC 2.0</target>
        </trans-unit>
        <trans-unit id="a671d1a90e2150d11e2b1f6323c00da36fa35704" translate="yes" xml:space="preserve">
          <source>PA-RISC and Itanium object files are not interchangeable. Although you may be able to use ar to create an archive library of PA-RISC object files on an Itanium system, you cannot link against it using an Itanium link editor.</source>
          <target state="translated">PA-RISC 및 Itanium 개체 파일은 서로 호환되지 않습니다. ar을 사용하여 Itanium 시스템에서 PA-RISC 오브젝트 파일의 아카이브 라이브러리를 작성할 수 있지만 Itanium 링크 편집기를 사용하여 링크 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="6e778bd20eb20ec966352f3796d7c0931f2a1b52" translate="yes" xml:space="preserve">
          <source>PACKAGE</source>
          <target state="translated">PACKAGE</target>
        </trans-unit>
        <trans-unit id="3b24034394fd782a09f93e8a5e6a19e433f5c0b7" translate="yes" xml:space="preserve">
          <source>PACKAGE VARIABLES</source>
          <target state="translated">패키지 변수</target>
        </trans-unit>
        <trans-unit id="f5757bc942837b06dcea162133be87f1399efdb1" translate="yes" xml:space="preserve">
          <source>PAD-RELATED CLASSES</source>
          <target state="translated">패드 관련 클래스</target>
        </trans-unit>
        <trans-unit id="5256fd77701bc17fcebded5655a52af6c191f7ca" translate="yes" xml:space="preserve">
          <source>PADDING OF BASE64 DIGESTS</source>
          <target state="translated">BASE64 거리의 패딩</target>
        </trans-unit>
        <trans-unit id="92903ba42bddaecab9133139d6657d1d38035291" translate="yes" xml:space="preserve">
          <source>PAR - optional module which can treat &lt;code&gt;.par&lt;/code&gt; files as Perl libraries.</source>
          <target state="translated">PAR- &lt;code&gt;.par&lt;/code&gt; 파일을 Perl 라이브러리로 취급 할 수있는 선택적 모듈입니다 .</target>
        </trans-unit>
        <trans-unit id="8aa67c70b62b88425c0805fe7ee18784ade05280" translate="yes" xml:space="preserve">
          <source>PARNO</source>
          <target state="translated">PARNO</target>
        </trans-unit>
        <trans-unit id="d76071dc758ed7e342554ae65110a5912fa75887" translate="yes" xml:space="preserve">
          <source>PARSING OPTIONS</source>
          <target state="translated">파싱 ​​옵션</target>
        </trans-unit>
        <trans-unit id="2f27cfe52f75001eb8b13ac0b269b4d71a7d0eff" translate="yes" xml:space="preserve">
          <source>PATCHING</source>
          <target state="translated">PATCHING</target>
        </trans-unit>
        <trans-unit id="b991d9932b6d73d6525c72b0344ecaf0a6e70612" translate="yes" xml:space="preserve">
          <source>PATCHING PERL</source>
          <target state="translated">펄링 펄</target>
        </trans-unit>
        <trans-unit id="09bd6a353a7bb8a33e37cfee71ada9fc9ce37d89" translate="yes" xml:space="preserve">
          <source>PATH</source>
          <target state="translated">PATH</target>
        </trans-unit>
        <trans-unit id="97000043438fbbe1d01d067a89cdcef2f0e8c14c" translate="yes" xml:space="preserve">
          <source>PATHNAME CONSTANTS</source>
          <target state="translated">PATHNAME 상수</target>
        </trans-unit>
        <trans-unit id="84c16d6a502dba6bf2d3fee213424d5d6bfb7b62" translate="yes" xml:space="preserve">
          <source>PATTERN</source>
          <target state="translated">PATTERN</target>
        </trans-unit>
        <trans-unit id="dac71a6819627d348c31a24b525d7fa382bddadb" translate="yes" xml:space="preserve">
          <source>PCRE/Python Support</source>
          <target state="translated">PCRE / Python 지원</target>
        </trans-unit>
        <trans-unit id="d613d88cb2d86f484f6f82d44ac1fc60722abe20" translate="yes" xml:space="preserve">
          <source>PDF</source>
          <target state="translated">PDF</target>
        </trans-unit>
        <trans-unit id="aa3411cdbe71b0a21abc88a3963b8403693bbc1b" translate="yes" xml:space="preserve">
          <source>PERFORMANCE</source>
          <target state="translated">PERFORMANCE</target>
        </trans-unit>
        <trans-unit id="a039af5d518d5df4edecd9355e8862ee9074cf7a" translate="yes" xml:space="preserve">
          <source>PERL 5 PORTERS</source>
          <target state="translated">펄 5 포터</target>
        </trans-unit>
        <trans-unit id="7e824f1cd9308ba64d688a71fcc968d2bf452aa4" translate="yes" xml:space="preserve">
          <source>PERL 5.8.0 BROKEN IN AMIGAOS</source>
          <target state="translated">AMIGAOS에서 PERL 5.8.0 고장</target>
        </trans-unit>
        <trans-unit id="2ad8575bde04df8f3c3405e287595936fe2f6b74" translate="yes" xml:space="preserve">
          <source>PERL OO SYSTEMS</source>
          <target state="translated">펄 OO 시스템</target>
        </trans-unit>
        <trans-unit id="38707bbc3a64c94dc99f9b43d452049c22f48409" translate="yes" xml:space="preserve">
          <source>PERL.C</source>
          <target state="translated">PERL.C</target>
        </trans-unit>
        <trans-unit id="c4ef015b035531ca89e73efd9974dbb427096dd2" translate="yes" xml:space="preserve">
          <source>PERL.EXE</source>
          <target state="translated">PERL.EXE</target>
        </trans-unit>
        <trans-unit id="0f9466733223ddd1a05cbf29bb33f0f356cbffcb" translate="yes" xml:space="preserve">
          <source>PERL.H</source>
          <target state="translated">PERL.H</target>
        </trans-unit>
        <trans-unit id="4a444e7468c0f9cc5930e13403ef14557c1dcc70" translate="yes" xml:space="preserve">
          <source>PERL.OBJ</source>
          <target state="translated">PERL.OBJ</target>
        </trans-unit>
        <trans-unit id="52d59ca4a1575427154cd0921e5e7f03fc93f8dc" translate="yes" xml:space="preserve">
          <source>PERL5LIB and PERLLIB</source>
          <target state="translated">PERL5LIB 및 PERLLIB</target>
        </trans-unit>
        <trans-unit id="f0a75fb949dd06b3f9081176db6123371bfe89bd" translate="yes" xml:space="preserve">
          <source>PERLDOCS</source>
          <target state="translated">PERLDOCS</target>
        </trans-unit>
        <trans-unit id="985d8b7cd33b8ae8b97c10576f8525c5e43feb2b" translate="yes" xml:space="preserve">
          <source>PERLLIB_PREFIX</source>
          <target state="translated">PERLLIB_PREFIX</target>
        </trans-unit>
        <trans-unit id="a58122b37384a35d76a112224ebc05023622985d" translate="yes" xml:space="preserve">
          <source>PERLSHR</source>
          <target state="translated">PERLSHR</target>
        </trans-unit>
        <trans-unit id="f9b90ea60310458da34842ec49d8ba2dcc6d6842" translate="yes" xml:space="preserve">
          <source>PERL_ARCHIVE: path to libperl.a equivalent to be linked to dynamic extensions.</source>
          <target state="translated">PERL_ARCHIVE : 동적 확장에 링크되는 libperl의 경로.</target>
        </trans-unit>
        <trans-unit id="6b32b9f2a6388fd49d59dc380fdfe54ede4bbab4" translate="yes" xml:space="preserve">
          <source>PERL_ARCHIVE_AFTER: path to a library which should be put on the linker command line</source>
          <target state="translated">PERL_ARCHIVE_AFTER : 링커 명령 행에 배치해야하는 라이브러리의 경로</target>
        </trans-unit>
        <trans-unit id="4c6d51550dda10c59c0baefc83a359a9b3e89e2d" translate="yes" xml:space="preserve">
          <source>PERL_BADFREE</source>
          <target state="translated">PERL_BADFREE</target>
        </trans-unit>
        <trans-unit id="a23a8f24b9f1defe9ff92b59171d38cc844c2e5c" translate="yes" xml:space="preserve">
          <source>PERL_BADLANG</source>
          <target state="translated">PERL_BADLANG</target>
        </trans-unit>
        <trans-unit id="ea61b8e3a3a6f667f8ac07d9441b74f7086fd4b1" translate="yes" xml:space="preserve">
          <source>PERL_DESTRUCT_LEVEL</source>
          <target state="translated">PERL_DESTRUCT_LEVEL</target>
        </trans-unit>
        <trans-unit id="61a82fd6ba532d8a72b14f2af64e53732c3f8065" translate="yes" xml:space="preserve">
          <source>PERL_ENV_TABLES</source>
          <target state="translated">PERL_ENV_TABLES</target>
        </trans-unit>
        <trans-unit id="df55d3100213212432ed7cb5fb2ce8aff5bb5e34" translate="yes" xml:space="preserve">
          <source>PERL_JSON_BACKEND</source>
          <target state="translated">PERL_JSON_BACKEND</target>
        </trans-unit>
        <trans-unit id="7406046b29d774dab6f67c9ebf1226de7875707f" translate="yes" xml:space="preserve">
          <source>PERL_MEM_LOG</source>
          <target state="translated">PERL_MEM_LOG</target>
        </trans-unit>
        <trans-unit id="35728d129bbb3e5ed03314204a1cbf6d4ce2e6d0" translate="yes" xml:space="preserve">
          <source>PERL_SET_CONTEXT(interp) should also be called whenever &lt;code&gt;interp&lt;/code&gt; is used by a thread that did not create it (using either perl_alloc(), or the more esoteric perl_clone()).</source>
          <target state="translated">또한 perl_alloc () 또는보다 난해한 perl_clone ()을 사용하여이를 작성하지 않은 스레드가 &lt;code&gt;interp&lt;/code&gt; 를 사용할 때마다 PERL_SET_CONTEXT (interp)를 호출해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="a871d7bf7b2a02e819c07cf4df026d57906b3e51" translate="yes" xml:space="preserve">
          <source>PERL_SH_DIR</source>
          <target state="translated">PERL_SH_DIR</target>
        </trans-unit>
        <trans-unit id="4e4019cc5e2b7ec5fc3d43d1227c4891f068a0c3" translate="yes" xml:space="preserve">
          <source>PERL_VMS_EXCEPTION_DEBUG</source>
          <target state="translated">PERL_VMS_EXCEPTION_DEBUG</target>
        </trans-unit>
        <trans-unit id="22d485a76570fc46268de520a55e10a9a69f35aa" translate="yes" xml:space="preserve">
          <source>PERL_YAML_BACKEND</source>
          <target state="translated">PERL_YAML_BACKEND</target>
        </trans-unit>
        <trans-unit id="70101c7c85d7116954e48d6da8dddb7074ef2a17" translate="yes" xml:space="preserve">
          <source>PERSISTENT CACHE SUPPORT</source>
          <target state="translated">영구 캐시 지원</target>
        </trans-unit>
        <trans-unit id="60003793ea7b554ef4aa8d86e943a5c0f46d5e37" translate="yes" xml:space="preserve">
          <source>PF_INET, PF_INET6, PF_UNIX, ...</source>
          <target state="translated">PF_INET, PF_INET6, PF_UNIX, ...</target>
        </trans-unit>
        <trans-unit id="fa7ff6fb00a7ace8d98cf880a492dc6c5ffc8ca7" translate="yes" xml:space="preserve">
          <source>PI</source>
          <target state="translated">PI</target>
        </trans-unit>
        <trans-unit id="3490ca5e3137d6e80d152267527e5428418a006e" translate="yes" xml:space="preserve">
          <source>PL files are normally run &lt;b&gt;after&lt;/b&gt; pm_to_blib and include INST_LIB and INST_ARCH in their &lt;code&gt;@INC&lt;/code&gt; , so the just built modules can be accessed... unless the PL file is making a module (or anything else in PM) in which case it is run &lt;b&gt;before&lt;/b&gt; pm_to_blib and does not include INST_LIB and INST_ARCH in its &lt;code&gt;@INC&lt;/code&gt; . This apparently odd behavior is there for backwards compatibility (and it's somewhat DWIM).</source>
          <target state="translated">PL 파일이 정상적으로 실행 &lt;b&gt;후&lt;/b&gt; pm_to_blib과에 INST_LIB 및 INST_ARCH을 포함 &lt;code&gt;@INC&lt;/code&gt; 방금 내장 모듈에 액세스 할 수 있도록 ...의 PL 파일이 실행되는 경우에 모듈 (또는 오후에 아무것도)하고있다 않는 &lt;b&gt;전에를&lt;/b&gt; pm_to_blib이며 &lt;code&gt;@INC&lt;/code&gt; 에 INST_LIB 및 INST_ARCH를 포함하지 않습니다 . 이 명백한 이상한 동작은 이전 버전과의 호환성을위한 것입니다 (그리고 다소 DWIM 임).</target>
        </trans-unit>
        <trans-unit id="1f9b4355202a16dca9278309f8c57bab627534d7" translate="yes" xml:space="preserve">
          <source>PLANE ANGLE CONVERSIONS</source>
          <target state="translated">평면 각도 변환</target>
        </trans-unit>
        <trans-unit id="397f26f7a31d1d29ed32b8ae38758d964d147496" translate="yes" xml:space="preserve">
          <source>PLATFORMS</source>
          <target state="translated">PLATFORMS</target>
        </trans-unit>
        <trans-unit id="0fcaf629ebcd1ef3b077048317114d46dcb1a205" translate="yes" xml:space="preserve">
          <source>PLUGINS</source>
          <target state="translated">PLUGINS</target>
        </trans-unit>
        <trans-unit id="96bb1ede828d06c7c676fc4aca0b2ab0fc3aaec6" translate="yes" xml:space="preserve">
          <source>POD</source>
          <target state="translated">POD</target>
        </trans-unit>
        <trans-unit id="9757efd691d77c4c7ce7af22ae0498da057b96f2" translate="yes" xml:space="preserve">
          <source>POD commands.</source>
          <target state="translated">POD 명령.</target>
        </trans-unit>
        <trans-unit id="4f47ae786af8b3ae6d44df79389191724c8e9b20" translate="yes" xml:space="preserve">
          <source>POD documentation</source>
          <target state="translated">POD 문서</target>
        </trans-unit>
        <trans-unit id="e5ddb6a6721405eb11c587453e0434d2f646aa07" translate="yes" xml:space="preserve">
          <source>POD2MAN_macro</source>
          <target state="translated">POD2MAN_macro</target>
        </trans-unit>
        <trans-unit id="3bd1038b0ae3b6d74e0afdd1bb9c713c175f1f33" translate="yes" xml:space="preserve">
          <source>PODs: Embedded Documentation</source>
          <target state="translated">포드 : 임베디드 설명서</target>
        </trans-unit>
        <trans-unit id="27d22d20fdc49ff65099906e5eeacad058aeb916" translate="yes" xml:space="preserve">
          <source>POPULATE AN INSTALLATION WITH LOTS OF MODULES</source>
          <target state="translated">많은 모듈로 설치하기</target>
        </trans-unit>
        <trans-unit id="dfb1d5b6c2198f6b90dd9fb2aa67809b15a77598" translate="yes" xml:space="preserve">
          <source>PORTABILITY</source>
          <target state="translated">PORTABILITY</target>
        </trans-unit>
        <trans-unit id="fac926bb8a4de690e4dca18f3225a7ad2a06037c" translate="yes" xml:space="preserve">
          <source>PORTABILITY CAVEATS</source>
          <target state="translated">휴대 성 경고</target>
        </trans-unit>
        <trans-unit id="eeaaaed2401766705588000c95399212adce6cd4" translate="yes" xml:space="preserve">
          <source>POS is absolute position. (Seek relative to the start of the file)</source>
          <target state="translated">POS는 절대 위치입니다. (파일 시작과 관련하여 검색)</target>
        </trans-unit>
        <trans-unit id="eff46aebd5f7e19f03d6237cd80da90014c8e132" translate="yes" xml:space="preserve">
          <source>POS is an offset from the current position. (Seek relative to current)</source>
          <target state="translated">POS는 현재 위치에서 오프셋입니다. (전류를 기준으로 탐색)</target>
        </trans-unit>
        <trans-unit id="4a3852f381cc7917e0a6f01c96db05db1939d7a5" translate="yes" xml:space="preserve">
          <source>POS is an offset from the end of the file. (Seek relative to end)</source>
          <target state="translated">POS는 파일 끝에서의 오프셋입니다. (끝을 기준으로 탐색)</target>
        </trans-unit>
        <trans-unit id="23507e798d66fee0b05313c2a15e15ff93e82f20" translate="yes" xml:space="preserve">
          <source>POSIX</source>
          <target state="translated">POSIX</target>
        </trans-unit>
        <trans-unit id="ae89c95fa22e7b32fa45fce7e8bf404e997e9054" translate="yes" xml:space="preserve">
          <source>POSIX - Perl interface to IEEE Std 1003.1</source>
          <target state="translated">POSIX-IEEE Std 1003.1에 대한 Perl 인터페이스</target>
        </trans-unit>
        <trans-unit id="d243eb13195dcdb315427d56a4c35f42dcb04024" translate="yes" xml:space="preserve">
          <source>POSIX CONSTANTS</source>
          <target state="translated">POSIX 상수</target>
        </trans-unit>
        <trans-unit id="5c9c75047d91af941801f6c6002bbc479d31b75d" translate="yes" xml:space="preserve">
          <source>POSIX Character Classes</source>
          <target state="translated">POSIX 문자 클래스</target>
        </trans-unit>
        <trans-unit id="f2d1e7de0e60a574e6d87a0cc3a67de6faf43784" translate="yes" xml:space="preserve">
          <source>POSIX FLAGS</source>
          <target state="translated">POSIX 플래그</target>
        </trans-unit>
        <trans-unit id="569385480ca60be76d48d613b39e1bc91f7990bf" translate="yes" xml:space="preserve">
          <source>POSIX FUNCTIONS</source>
          <target state="translated">POSIX 기능</target>
        </trans-unit>
        <trans-unit id="06b4e35ce432cb4702f6a995fe95c52f8db39c2a" translate="yes" xml:space="preserve">
          <source>POSIX character classes and their Unicode and Perl equivalents:</source>
          <target state="translated">POSIX 문자 클래스 및 해당 유니 코드 및 Perl 동등 항목 :</target>
        </trans-unit>
        <trans-unit id="72593fbc583aea6c901e13572f670a7d0d357161" translate="yes" xml:space="preserve">
          <source>POSIX character classes can be part of a larger bracketed character class. For example,</source>
          <target state="translated">POSIX 문자 클래스는 더 큰 대괄호 문자 클래스의 일부가 될 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="b4c2f7d57ee138ef8741ea704a671378863f20a1" translate="yes" xml:space="preserve">
          <source>POSIX character classes have the form &lt;code&gt;[:class:]&lt;/code&gt;, where</source>
          <target state="translated">POSIX 문자 클래스는 &lt;code&gt;[:class:]&lt;/code&gt; 형식입니다 . 여기서</target>
        </trans-unit>
        <trans-unit id="61668ef8f25bddd14989c415629b0df07e51f44b" translate="yes" xml:space="preserve">
          <source>POSIX functions:</source>
          <target state="translated">POSIX 기능 :</target>
        </trans-unit>
        <trans-unit id="04680e6e37ce6d2dcbb31e0e8a36d7516c0e506b" translate="yes" xml:space="preserve">
          <source>POSIX-BC?</source>
          <target state="translated">POSIX-BC?</target>
        </trans-unit>
        <trans-unit id="864a3ec5736c1f231ee60dfa1ac4b3cf0adce372" translate="yes" xml:space="preserve">
          <source>POSIX.2</source>
          <target state="translated">POSIX.2</target>
        </trans-unit>
        <trans-unit id="3777385d2dd1e8926a9b75a14303ee4b22211baa" translate="yes" xml:space="preserve">
          <source>POSIX.pm</source>
          <target state="translated">POSIX.pm</target>
        </trans-unit>
        <trans-unit id="d45e49d46b986bef0fad349a44b3e4ef42953d70" translate="yes" xml:space="preserve">
          <source>POSIX::SigAction</source>
          <target state="translated">POSIX::SigAction</target>
        </trans-unit>
        <trans-unit id="74a299dde6a5128d521b652f2ba458a4da06a6a1" translate="yes" xml:space="preserve">
          <source>POSIX::SigRt</source>
          <target state="translated">POSIX::SigRt</target>
        </trans-unit>
        <trans-unit id="9cca0191c626eb89ac7a531f06862f8df3747e24" translate="yes" xml:space="preserve">
          <source>POSIX::SigSet</source>
          <target state="translated">POSIX::SigSet</target>
        </trans-unit>
        <trans-unit id="2b1f5cae0839a5eb5bae78193bd1a07008a2110c" translate="yes" xml:space="preserve">
          <source>POSIX::Termios</source>
          <target state="translated">POSIX::Termios</target>
        </trans-unit>
        <trans-unit id="fa4963cab46f1be7f819925dbfd48f68153bfc4a" translate="yes" xml:space="preserve">
          <source>POST-STRING</source>
          <target state="translated">POST-STRING</target>
        </trans-unit>
        <trans-unit id="d0012d64d9af33bc1cf8483ab0fda421fad18ba8" translate="yes" xml:space="preserve">
          <source>POSTSCRIPT</source>
          <target state="translated">POSTSCRIPT</target>
        </trans-unit>
        <trans-unit id="f581395efe2773e539af041b5a27fa1d0df00b1e" translate="yes" xml:space="preserve">
          <source>PRE-STRING</source>
          <target state="translated">PRE-STRING</target>
        </trans-unit>
        <trans-unit id="7840941760ebcd9fee13ec0f1666aa06fbb11bc3" translate="yes" xml:space="preserve">
          <source>PREAMBLE</source>
          <target state="translated">PREAMBLE</target>
        </trans-unit>
        <trans-unit id="69db2c13c51cc2aaf32e02ecde5988835599fa47" translate="yes" xml:space="preserve">
          <source>PREBUILT BINARIES OF PERL FOR SOLARIS.</source>
          <target state="translated">솔라리스를위한 펄의 사전 바이너리.</target>
        </trans-unit>
        <trans-unit id="4772fd326573fd42e768a1b15dd58bbb9cc8b317" translate="yes" xml:space="preserve">
          <source>PREFIX and LIB attribute</source>
          <target state="translated">PREFIX 및 LIB 속성</target>
        </trans-unit>
        <trans-unit id="c6ea2417cccb8facb1f2ec2c030cf1e5c2fcb2f6" translate="yes" xml:space="preserve">
          <source>PREFIX and LIB can be used to set several INSTALL* attributes in one go. Here's an example for installing into your home directory.</source>
          <target state="translated">PREFIX 및 LIB를 사용하여 여러 INSTALL * 속성을 한 번에 설정할 수 있습니다. 다음은 홈 디렉토리에 설치하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="40aa4e60b9a6d17247b06ec0bb028f55b0430593" translate="yes" xml:space="preserve">
          <source>PREFIX is the name of the SYMREF you're walking.</source>
          <target state="translated">PREFIX는 걷는 SYMREF의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="300c67e39443a38d0f595a8a987e17d646e3c291" translate="yes" xml:space="preserve">
          <source>PREFS</source>
          <target state="translated">PREFS</target>
        </trans-unit>
        <trans-unit id="9bc7b53b4ddb9c0604309a8f097387c59f61cafb" translate="yes" xml:space="preserve">
          <source>PREPARING TO USE LOCALES</source>
          <target state="translated">로캘 사용 준비</target>
        </trans-unit>
        <trans-unit id="281d6f01426cc7b0d2d1be7a9e3ef9753991bf8a" translate="yes" xml:space="preserve">
          <source>PREREQUISITES</source>
          <target state="translated">PREREQUISITES</target>
        </trans-unit>
        <trans-unit id="109e7210182e5f1a38490846d4f7c1bf6d1efeaf" translate="yes" xml:space="preserve">
          <source>PREREQUISITES FOR COMPILING PERL ON CYGWIN</source>
          <target state="translated">CYGWIN에서 Perl을 컴파일하기위한 전제 조건</target>
        </trans-unit>
        <trans-unit id="d596e5c41b06e835a227eaeb7f80e95e078526da" translate="yes" xml:space="preserve">
          <source>PRIVATE METHODS AND DATA</source>
          <target state="translated">전용 방법 및 데이터</target>
        </trans-unit>
        <trans-unit id="28128cb215ccf5b12e0dff7a0c33d632bc940a28" translate="yes" xml:space="preserve">
          <source>PROBES</source>
          <target state="translated">PROBES</target>
        </trans-unit>
        <trans-unit id="9f903b4f167ea635d9adabe61a39c7254588d35a" translate="yes" xml:space="preserve">
          <source>PROCESS</source>
          <target state="translated">PROCESS</target>
        </trans-unit>
        <trans-unit id="924eaf1172c6dafd288f2618c0a1efe247bb92db" translate="yes" xml:space="preserve">
          <source>PROFILING</source>
          <target state="translated">PROFILING</target>
        </trans-unit>
        <trans-unit id="85dfd02e93a90ca8a93ed7e5af4995f7549887d0" translate="yes" xml:space="preserve">
          <source>PROFILING TOOLS</source>
          <target state="translated">프로파일 링 도구</target>
        </trans-unit>
        <trans-unit id="9e3a8f7206c88ef34624181efda07f832c576870" translate="yes" xml:space="preserve">
          <source>PROGRAMMER'S INTERFACE</source>
          <target state="translated">프로그래머의 인터페이스</target>
        </trans-unit>
        <trans-unit id="9e97d57f23d497e98a3c17e698f142751c84db81" translate="yes" xml:space="preserve">
          <source>PSEUDO RESPONSES</source>
          <target state="translated">PSEUDO 응답</target>
        </trans-unit>
        <trans-unit id="dd4d85a958623a5705575960b9b4ae857188fa7f" translate="yes" xml:space="preserve">
          <source>PUSHCOLOR, POPCOLOR, and LOCALCOLOR were contributed by openmethods.com voice solutions.</source>
          <target state="translated">PUSHCOLOR, POPCOLOR 및 LOCALCOLOR는 openmethods.com 음성 솔루션에 의해 제공되었습니다.</target>
        </trans-unit>
        <trans-unit id="13e54ce098168f1fa1db9a288e5396806317b03b" translate="yes" xml:space="preserve">
          <source>PV</source>
          <target state="translated">PV</target>
        </trans-unit>
        <trans-unit id="4f4fc2fe1cdfbd4b127686b3c4701bfcc8bf5850" translate="yes" xml:space="preserve">
          <source>PVN</source>
          <target state="translated">PVN</target>
        </trans-unit>
        <trans-unit id="dbe7115eeb4102987d54e476c53cd399a6656a26" translate="yes" xml:space="preserve">
          <source>PVers</source>
          <target state="translated">PVers</target>
        </trans-unit>
        <trans-unit id="4db84d6ad2a10668614932a965ea5a3997c49335" translate="yes" xml:space="preserve">
          <source>Pack Recipes</source>
          <target state="translated">팩 레시피</target>
        </trans-unit>
        <trans-unit id="e5a69f2e40897b5daef39457bf875f755ff8707d" translate="yes" xml:space="preserve">
          <source>Pack and Unpack</source>
          <target state="translated">포장 및 포장 풀기</target>
        </trans-unit>
        <trans-unit id="ae88d737dc553c18917f526e7ed4fab3bcf7d255" translate="yes" xml:space="preserve">
          <source>Pack and unpack can operate in two modes: character mode (&lt;code&gt;C0&lt;/code&gt; mode) where the packed string is processed per character, and UTF-8 byte mode (&lt;code&gt;U0&lt;/code&gt; mode) where the packed string is processed in its UTF-8-encoded Unicode form on a byte-by-byte basis. Character mode is the default unless the format string starts with &lt;code&gt;U&lt;/code&gt; . You can always switch mode mid-format with an explicit &lt;code&gt;C0&lt;/code&gt; or &lt;code&gt;U0&lt;/code&gt; in the format. This mode remains in effect until the next mode change, or until the end of the &lt;code&gt;()&lt;/code&gt; group it (directly) applies to.</source>
          <target state="translated">압축 및 압축 해제는 압축 된 문자열이 문자별로 처리되는 문자 모드 ( &lt;code&gt;C0&lt;/code&gt; 모드)와 압축 된 문자열이 UTF-8로 인코딩 된 유니 코드 형식으로 처리되는 UTF-8 바이트 모드 ( &lt;code&gt;U0&lt;/code&gt; 모드)의 두 가지 모드로 작동 할 수 있습니다. 바이트 단위. 형식 문자열이 &lt;code&gt;U&lt;/code&gt; 로 시작하지 않으면 문자 모드가 기본값 입니다. 형식에서 명시 적 &lt;code&gt;C0&lt;/code&gt; 또는 &lt;code&gt;U0&lt;/code&gt; 을 사용하여 모드 중간 형식을 항상 전환 할 수 있습니다 . 이 모드는 다음 모드가 변경 될 때까지 또는 &lt;code&gt;()&lt;/code&gt; 그룹이 (직접적으로) 적용될 때까지 유효 합니다.</target>
        </trans-unit>
        <trans-unit id="1557120d5088a59d57273db042de727192d13fe4" translate="yes" xml:space="preserve">
          <source>Package &lt;code&gt;overload.pm&lt;/code&gt; provides the following public functions:</source>
          <target state="translated">패키지 &lt;code&gt;overload.pm&lt;/code&gt; 은 다음과 같은 공용 함수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="854d1d4510ef2ba36738b3c6bee00faff7d95b8e" translate="yes" xml:space="preserve">
          <source>Package Lexicals</source>
          <target state="translated">패키지 어휘</target>
        </trans-unit>
        <trans-unit id="2c11074689b7e2ad2c208b4e9d700f62e8d77364" translate="yes" xml:space="preserve">
          <source>Package for overloading Perl operations</source>
          <target state="translated">과부하 작업을위한 패키지</target>
        </trans-unit>
        <trans-unit id="0bb1778e3f25a2a84d101d6e9168311f3de452b1" translate="yes" xml:space="preserve">
          <source>Package lexicals declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; in the main block of a package using &lt;b&gt;AutoLoader&lt;/b&gt; will not be visible to auto-loaded subroutines, due to the fact that the given scope ends at the &lt;code&gt;__END__&lt;/code&gt; marker. A module using such variables as package globals will not work properly under the &lt;b&gt;AutoLoader&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;AutoLoader&lt;/b&gt; 를 사용하여 패키지의 메인 블록에서 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 로 선언 된 패키지 어휘는 주어진 범위가 &lt;code&gt;__END__&lt;/code&gt; 마커 에서 끝나기 때문에 자동로드 서브 루틴에 표시되지 않습니다 . 패키지 전역과 같은 변수를 사용하는 모듈은 &lt;b&gt;AutoLoader에서&lt;/b&gt; 제대로 작동하지 않습니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="61fda0710845c0ff2e124df892b08c2fdc3b0249" translate="yes" xml:space="preserve">
          <source>Package names are sometimes an exception to this rule. Perl informally reserves lowercase module names for &quot;pragma&quot; modules like &lt;code&gt;integer&lt;/code&gt; and &lt;code&gt;strict&lt;/code&gt; . Other modules should begin with a capital letter and use mixed case, but probably without underscores due to limitations in primitive file systems' representations of module names as files that must fit into a few sparse bytes.</source>
          <target state="translated">패키지 이름은 때때로이 규칙에서 예외입니다. Perl은 &lt;code&gt;integer&lt;/code&gt; 및 &lt;code&gt;strict&lt;/code&gt; 와 같은 &quot;pragma&quot;모듈의 소문자 모듈 이름을 비공식적으로 예약 합니다. 다른 모듈은 대문자로 시작하고 대소 문자를 혼합하여 사용해야하지만, 기본 파일 시스템의 모듈 이름 표현이 몇 개의 희소 바이트에 맞아야하는 파일로 제한되기 때문에 밑줄이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="017a94912f4272ea63da9e237abc82a6ecd1cbbc" translate="yes" xml:space="preserve">
          <source>Package namespace of currently executing code.</source>
          <target state="translated">현재 실행중인 코드의 패키지 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="b77eb8988a1d4f067854db5e1f2b1a7c6ddf5108" translate="yes" xml:space="preserve">
          <source>Package the module using &quot;make dist&quot;</source>
          <target state="translated">&quot;make dist&quot;를 사용하여 모듈 패키지</target>
        </trans-unit>
        <trans-unit id="dadc452bc83dd321cf9ff63134d60199b40bf1bd" translate="yes" xml:space="preserve">
          <source>Package-specific Attribute Handling</source>
          <target state="translated">패키지 별 속성 처리</target>
        </trans-unit>
        <trans-unit id="1b6b83de2c1ebd183fc9268fc7fc44ce0413fd67" translate="yes" xml:space="preserve">
          <source>Package/Module names are an exception to this rule. Perl informally reserves lowercase module names for 'pragma' modules like integer and strict. Other modules normally begin with a capital letter and use mixed case with no underscores (need to be short and portable).</source>
          <target state="translated">패키지 / 모듈 이름은이 규칙에서 예외입니다. Perl은 정수 및 엄격과 같은 'pragma'모듈의 소문자 모듈 이름을 비공식적으로 예약합니다. 다른 모듈은 일반적으로 대문자로 시작하며 밑줄이없는 대소 문자를 혼합하여 사용합니다 (짧고 휴대 가능해야 함).</target>
        </trans-unit>
        <trans-unit id="0a999012ffb87b3edac99adbdfc498b12831a1e2" translate="yes" xml:space="preserve">
          <source>Packages</source>
          <target state="translated">Packages</target>
        </trans-unit>
        <trans-unit id="dcec9cb396ed550d472d01c925021db01eb054ef" translate="yes" xml:space="preserve">
          <source>Packages claim that there won't be errors on calls to or from packages explicitly marked as safe by inclusion in &lt;code&gt;@CARP_NOT&lt;/code&gt; , or (if that array is empty) &lt;code&gt;@ISA&lt;/code&gt; . The ability to override what @ISA says is new in 5.8.</source>
          <target state="translated">패키지는 &lt;code&gt;@CARP_NOT&lt;/code&gt; 또는 (배열이 비어있는 경우) &lt;code&gt;@ISA&lt;/code&gt; 에 포함되어 안전하다고 표시된 패키지를 호출하거나 호출 할 때 오류가 없다고 주장합니다 . @ISA의 말을 무시하는 기능은 5.8의 새로운 기능입니다.</target>
        </trans-unit>
        <trans-unit id="ecc8e8a892ee953e2d150356ce7f795f7e40a13f" translate="yes" xml:space="preserve">
          <source>Packages may themselves contain package separators, as in &lt;code&gt;$OUTER::INNER::var&lt;/code&gt; . This implies nothing about the order of name lookups, however. There are no relative packages: all symbols are either local to the current package, or must be fully qualified from the outer package name down. For instance, there is nowhere within package &lt;code&gt;OUTER&lt;/code&gt; that &lt;code&gt;$INNER::var&lt;/code&gt; refers to &lt;code&gt;$OUTER::INNER::var&lt;/code&gt; . &lt;code&gt;INNER&lt;/code&gt; refers to a totally separate global package.</source>
          <target state="translated">패키지 자체는 &lt;code&gt;$OUTER::INNER::var&lt;/code&gt; 과 같이 패키지 구분 기호를 포함 할 수 있습니다 . 그러나 이름 조회 순서에 대해서는 아무 의미가 없습니다. 상대 패키지는 없습니다. 모든 심볼은 현재 패키지에 대해 로컬이거나 외부 패키지 이름에서 정규화되어야합니다. 예를 들어, 패키지 &lt;code&gt;OUTER&lt;/code&gt; 내에 &lt;code&gt;$INNER::var&lt;/code&gt; 이 &lt;code&gt;$OUTER::INNER::var&lt;/code&gt; 참조 하는 곳은 없습니다 . &lt;code&gt;INNER&lt;/code&gt; 는 완전히 별개의 글로벌 패키지를 말합니다.</target>
        </trans-unit>
        <trans-unit id="5c700aceea5d157561b207ea0b138ca42d93986c" translate="yes" xml:space="preserve">
          <source>Packages should NOT be released with succeeding TODO tests. As soon as a TODO test starts working, it should be promoted to a normal test, and the newly working feature should be documented in the release notes or in the change log.</source>
          <target state="translated">성공적인 TODO 테스트를 통해 패키지를 출시해서는 안됩니다. TODO 테스트가 작동을 시작하자마자 정상 테스트로 승격되어야하며 새로 작동하는 기능은 릴리스 정보 또는 변경 로그에 문서화되어야합니다.</target>
        </trans-unit>
        <trans-unit id="f9b3a92a4e9c473029e482a2d030dd34f7fdde67" translate="yes" xml:space="preserve">
          <source>Packages such as the &lt;b&gt;AutoLoader&lt;/b&gt; and &lt;b&gt;SelfLoader&lt;/b&gt; that delay loading of subroutines within packages can create problems with package lexicals defined using &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt;. While the &lt;b&gt;vars&lt;/b&gt; pragma cannot duplicate the effect of package lexicals (total transparency outside of the package), it can act as an acceptable substitute by pre-declaring global symbols, ensuring their availability to the later-loaded routines.</source>
          <target state="translated">패키지 내의 서브 루틴 로딩을 지연 시키는 &lt;b&gt;AutoLoader&lt;/b&gt; 및 &lt;b&gt;SelfLoader&lt;/b&gt; 와 같은 패키지는 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt; 사용하여 정의 된 패키지 어휘에 문제를 일으킬 수 있습니다 . (가) 동안 &lt;b&gt;바르&lt;/b&gt; 프라그가 패키지 lexicals 효과 (패키지의 전체 투명도 외부)를 복제 할 수 있고, 그것은 나중에 로딩 루틴 가용성을 보장 미리 선언 글로벌 부호를 수용 대체물로서 작용할 수있다.</target>
        </trans-unit>
        <trans-unit id="3a39b68c35be609fae3db651a70893a29f102145" translate="yes" xml:space="preserve">
          <source>Packaging</source>
          <target state="translated">Packaging</target>
        </trans-unit>
        <trans-unit id="ebd1d6c956dcaa7e80ad01427e2c132c913acd56" translate="yes" xml:space="preserve">
          <source>Packing Numbers</source>
          <target state="translated">포장 번호</target>
        </trans-unit>
        <trans-unit id="77ff08af8cc464aced5aa97fba37b76b1a287c76" translate="yes" xml:space="preserve">
          <source>Packing Text</source>
          <target state="translated">포장 텍스트</target>
        </trans-unit>
        <trans-unit id="1608f8af08441cd12fe9e2fbae53022489534f12" translate="yes" xml:space="preserve">
          <source>Packing and Unpacking C Structures</source>
          <target state="translated">C 구조체 포장 및 포장 풀기</target>
        </trans-unit>
        <trans-unit id="755fc829fa6b30f5bd0dea1183fbb4e40f383943" translate="yes" xml:space="preserve">
          <source>Packing and unpacking numbers implies conversion to and from some</source>
          <target state="translated">포장 및 포장 풀기 번호는 일부와의 변환을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c9cf82b43fad60a42156fab44e3aea80e40a265e" translate="yes" xml:space="preserve">
          <source>Pad Data Structures</source>
          <target state="translated">패드 데이터 구조</target>
        </trans-unit>
        <trans-unit id="a949a19a50821443871b3357ef792d3486159a28" translate="yes" xml:space="preserve">
          <source>Padre is cross-platform IDE for Perl written in Perl using wxWidgets to provide a native look and feel. It's open source under the Artistic License. It is one of the newer Perl IDEs.</source>
          <target state="translated">Padre는 기본 모양과 느낌을 제공하기 위해 wxWidgets를 사용하여 Perl로 작성된 Perl 용 크로스 플랫폼 IDE입니다. 예술 라이센스에 따라 오픈 소스입니다. 최신 Perl IDE 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="e71eceb99b088c6966163f1c30b69039a2bc1008" translate="yes" xml:space="preserve">
          <source>Pairs of arguments will always be preserved in a single command, this is a heuristic for things like pm_to_blib and pod2man which work on pairs of arguments. This makes things like this safe:</source>
          <target state="translated">한 쌍의 인수는 항상 단일 명령으로 유지됩니다. 이는 pm_to_blib 및 pod2man과 같은 인수 쌍에서 작동하는 휴리스틱입니다. 이렇게하면 안전한 것입니다 :</target>
        </trans-unit>
        <trans-unit id="6a74d0b33c52deb33630c75d846ae47130145559" translate="yes" xml:space="preserve">
          <source>Paragraph mode?</source>
          <target state="translated">단락 모드?</target>
        </trans-unit>
        <trans-unit id="8968f4cd8542e8f5dcc7b6c003f463e1278703a3" translate="yes" xml:space="preserve">
          <source>Parallel tests</source>
          <target state="translated">병렬 테스트</target>
        </trans-unit>
        <trans-unit id="c5a55bab9e3352eacabd04b4af1ceaafddafe1be" translate="yes" xml:space="preserve">
          <source>Parameters are passed to the Perl subroutine using the Perl stack. This is the purpose of the code beginning with the line &lt;code&gt;dSP&lt;/code&gt; and ending with the line &lt;code&gt;PUTBACK&lt;/code&gt; . The &lt;code&gt;dSP&lt;/code&gt; declares a local copy of the stack pointer. This local copy should &lt;b&gt;always&lt;/b&gt; be accessed as &lt;code&gt;SP&lt;/code&gt; .</source>
          <target state="translated">매개 변수는 Perl 스택을 사용하여 Perl 서브 루틴으로 전달됩니다. 이것은 &lt;code&gt;dSP&lt;/code&gt; 라인으로 시작하고 &lt;code&gt;PUTBACK&lt;/code&gt; 라인으로 끝나는 코드의 목적입니다 . &lt;code&gt;dSP&lt;/code&gt; 스택 포인터의 로컬 복사본을 선언합니다. 이 로컬 복사본은 &lt;b&gt;항상 &lt;/b&gt; &lt;code&gt;SP&lt;/code&gt; 로 액세스 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="80783f8285e6c8c2e9ad9134ffee91ec59453e8c" translate="yes" xml:space="preserve">
          <source>Parameters for the './Build install' command? Typical frequently used setting:</source>
          <target state="translated">'./Build install'명령의 매개 변수? 일반적으로 자주 사용되는 설정 :</target>
        </trans-unit>
        <trans-unit id="1d97e41da27293ace4ed2fbd57ab78ff1ca66f70" translate="yes" xml:space="preserve">
          <source>Parameters for the './Build' command? Setting might be:</source>
          <target state="translated">'./Build'명령의 매개 변수? 설정은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f5e610dc6ea79e1fa2fc73a9c4a9f25754369b4d" translate="yes" xml:space="preserve">
          <source>Parameters for the 'make install' command? Typical frequently used setting:</source>
          <target state="translated">'make install'명령의 매개 변수? 일반적으로 자주 사용되는 설정 :</target>
        </trans-unit>
        <trans-unit id="ac5f82546938b3fb52bd2ca5918d7cd917da5ad3" translate="yes" xml:space="preserve">
          <source>Parameters for the 'make' command? Typical frequently used setting:</source>
          <target state="translated">'make'명령의 매개 변수? 일반적으로 자주 사용되는 설정 :</target>
        </trans-unit>
        <trans-unit id="2daf65e57908f6e4e34be353735de186e29fbed1" translate="yes" xml:space="preserve">
          <source>Parameters for the 'perl Build.PL' command?</source>
          <target state="translated">'perl Build.PL'명령의 매개 변수?</target>
        </trans-unit>
        <trans-unit id="f2122e9ae0f9d0d393a429df01b5fba0a3936055" translate="yes" xml:space="preserve">
          <source>Parameters for the 'perl Makefile.PL' command?</source>
          <target state="translated">'perl Makefile.PL'명령의 매개 변수?</target>
        </trans-unit>
        <trans-unit id="12a675963c2d259ddd1261e2417e886a181a761a" translate="yes" xml:space="preserve">
          <source>Parameters preceded by &lt;code&gt;IN_OUTLIST&lt;/code&gt; /&lt;code&gt;IN_OUT&lt;/code&gt; /&lt;code&gt;OUT&lt;/code&gt;</source>
          <target state="translated">앞에 매개 변수 &lt;code&gt;IN_OUTLIST&lt;/code&gt; / &lt;code&gt;IN_OUT&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b0232bb8a39fafc143ca61d9de251f7dcdc27d0d" translate="yes" xml:space="preserve">
          <source>Parameters preceded by &lt;code&gt;OUTLIST&lt;/code&gt; /&lt;code&gt;IN_OUTLIST&lt;/code&gt; /&lt;code&gt;OUT&lt;/code&gt; /&lt;code&gt;IN_OUT&lt;/code&gt; keywords are considered to be used by the C subroutine</source>
          <target state="translated">선행 파라미터 &lt;code&gt;OUTLIST&lt;/code&gt; / &lt;code&gt;IN_OUTLIST&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt; / &lt;code&gt;IN_OUT&lt;/code&gt; 의 키워드는 C 서브 루틴에 의해 사용되는 것으로 간주</target>
        </trans-unit>
        <trans-unit id="41ae2823f661f6ddef5e94291c2f12cd43c213a8" translate="yes" xml:space="preserve">
          <source>Parameters preceded by &lt;code&gt;OUTLIST&lt;/code&gt; keyword do not appear in the usage signature of the generated Perl function.</source>
          <target state="translated">&lt;code&gt;OUTLIST&lt;/code&gt; 키워드가 앞에 오는 매개 변수 는 생성 된 Perl 함수의 사용법 서명에 나타나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="44ce2ab75a2d568796b9a81ad9fe53a999fb4475" translate="yes" xml:space="preserve">
          <source>Parameters with C pointer types can have different semantic: C functions with similar declarations</source>
          <target state="translated">C 포인터 유형의 매개 변수는 다른 의미를 가질 수 있습니다. 비슷한 선언의 C 함수</target>
        </trans-unit>
        <trans-unit id="381c775599d6e4185d4410725809e360928357cd" translate="yes" xml:space="preserve">
          <source>Parameters:</source>
          <target state="translated">Parameters:</target>
        </trans-unit>
        <trans-unit id="626558c7945f5a0bd6dde776e79591456600acd2" translate="yes" xml:space="preserve">
          <source>Params::Check</source>
          <target state="translated">Params::Check</target>
        </trans-unit>
        <trans-unit id="3c31e71b866e2be1b160d9df7e242f80a1e4ff7c" translate="yes" xml:space="preserve">
          <source>Params::Check - A generic input parsing/checking mechanism.</source>
          <target state="translated">Params :: Check-일반적인 입력 파싱 / 확인 메커니즘입니다.</target>
        </trans-unit>
        <trans-unit id="8e747ae27947e13afe9efbf29825a7aff5681ea5" translate="yes" xml:space="preserve">
          <source>Params::Check can do the following things for you:</source>
          <target state="translated">Params :: Check는 다음 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2c3a97d4f65d97cc22a071d5d73380ed7818098" translate="yes" xml:space="preserve">
          <source>Params::Check is a generic input parsing/checking mechanism.</source>
          <target state="translated">Params :: Check는 일반적인 입력 구문 분석 / 확인 메커니즘입니다.</target>
        </trans-unit>
        <trans-unit id="0fcb11d8c3d4312636cc39b23c2f21a9a26545a6" translate="yes" xml:space="preserve">
          <source>Parrot</source>
          <target state="translated">Parrot</target>
        </trans-unit>
        <trans-unit id="f3350f0a17047f5a3aa07948204b506a6f7b873f" translate="yes" xml:space="preserve">
          <source>Parrot now uses C3</source>
          <target state="translated">앵무새는 이제 C3를 사용합니다</target>
        </trans-unit>
        <trans-unit id="39fea3034dad6653f4f66f72da190aee39c9d313" translate="yes" xml:space="preserve">
          <source>Parse &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::TAP&quot;&gt;TAP&lt;/a&gt; output</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::TAP&quot;&gt;TAP&lt;/a&gt; 출력 구문 분석</target>
        </trans-unit>
        <trans-unit id="864de3b696d3e06b04ffd3f5a91d959dcce58e7a" translate="yes" xml:space="preserve">
          <source>Parse Call Graph and a Grammar</source>
          <target state="translated">통화 그래프 및 문법 분석</target>
        </trans-unit>
        <trans-unit id="9712b394a0364a991bc67a7d52542c55240f7409" translate="yes" xml:space="preserve">
          <source>Parse META.yml and META.json CPAN metadata files</source>
          <target state="translated">META.yml 및 META.json CPAN 메타 데이터 파일 구문 분석</target>
        </trans-unit>
        <trans-unit id="00d969b75c5246184c1f10c93d4e0b0704ad883c" translate="yes" xml:space="preserve">
          <source>Parse Pod into a simple parse tree</source>
          <target state="translated">간단한 파싱 트리로 포드 파싱</target>
        </trans-unit>
        <trans-unit id="ce3404387b94afbebba7dec68b6b2b2a625f85c8" translate="yes" xml:space="preserve">
          <source>Parse a $file and return what $VERSION is set to by the first assignment. It will return the string &quot;undef&quot; if it can't figure out what $VERSION is. $VERSION should be for all to see, so &lt;code&gt;&lt;a href=&quot;../functions/our&quot;&gt;our&lt;/a&gt; $VERSION&lt;/code&gt; or plain $VERSION are okay, but &lt;code&gt;&lt;a href=&quot;../functions/my&quot;&gt;my&lt;/a&gt; $VERSION&lt;/code&gt; is not.</source>
          <target state="translated">$ file을 구문 분석하고 첫 번째 할당에서 $ VERSION이 설정된 것을 반환하십시오. $ VERSION이 무엇인지 알 수 없으면 &quot;undef&quot;라는 문자열을 반환합니다. 모두가 볼 수 있도록, 그래서 $ VERSION은해야 &lt;code&gt;&lt;a href=&quot;../functions/our&quot;&gt;our&lt;/a&gt; $VERSION&lt;/code&gt; 또는 일반 $ VERSION은 좋아하지만, &lt;code&gt;&lt;a href=&quot;../functions/my&quot;&gt;my&lt;/a&gt; $VERSION&lt;/code&gt; 없습니다.</target>
        </trans-unit>
        <trans-unit id="ad88342fff52b537c53c546c60e5e4da39c0d95b" translate="yes" xml:space="preserve">
          <source>Parse a Perl arithmetic expression. This may contain operators of precedence down to the bit shift operators. The expression must be followed (and thus terminated) either by a comparison or lower-precedence operator or by something that would normally terminate an expression such as semicolon. If</source>
          <target state="translated">Perl 산술 표현식을 구문 분석하십시오. 여기에는 비트 시프트 연산자보다 우선 순위가 높은 연산자가 포함될 수 있습니다. 표현식은 비교 또는 우선 순위가 낮은 연산자 또는 일반적으로 세미콜론과 같은 표현식을 종료하는 것으로 뒤 따릅니다 (따라서 종료되어야 함). 만약</target>
        </trans-unit>
        <trans-unit id="d13919626420ad4ba57c7f1e236f7e3f81a7aa3e" translate="yes" xml:space="preserve">
          <source>Parse a Perl list expression. This may contain operators of precedence down to the comma operator. The expression must be followed (and thus terminated) either by a low-precedence logic operator such as &lt;code&gt;or&lt;/code&gt; or by something that would normally terminate an expression such as semicolon. If</source>
          <target state="translated">Perl 목록 표현식을 구문 분석하십시오. 여기에는 쉼표 연산자보다 우선 순위가 높은 연산자가 포함될 수 있습니다. 표현식은 우선 순위가 낮은 논리 연산자와 같이 &lt;code&gt;or&lt;/code&gt; 세미콜론과 같은 표현식을 정상적으로 종료하는 것으로 뒤 따릅니다 (따라서 종료되어야 함) . 만약</target>
        </trans-unit>
        <trans-unit id="73a31decc1f7a5c619a6729c16f491108de487bb" translate="yes" xml:space="preserve">
          <source>Parse a Perl term expression. This may contain operators of precedence down to the assignment operators. The expression must be followed (and thus terminated) either by a comma or lower-precedence operator or by something that would normally terminate an expression such as semicolon. If</source>
          <target state="translated">Perl 용어 표현식을 구문 분석하십시오. 여기에는 할당 연산자보다 우선 순위가 높은 연산자가 포함될 수 있습니다. 쉼표 또는 우선 순위가 낮은 연산자 나 일반적으로 세미콜론과 같은 표현식을 종료하는 것이 표현식 뒤에 있어야합니다. 만약</target>
        </trans-unit>
        <trans-unit id="03fd37a1b5d20bde462eaebffb2d4fbe34e1d46e" translate="yes" xml:space="preserve">
          <source>Parse a sequence of zero or more Perl statements. These may be normal imperative statements, including optional labels, or declarations that have compile-time effect, or any mixture thereof. The statement sequence ends when a closing brace or end-of-file is encountered in a place where a new statement could have validly started. It is up to the caller to ensure that the dynamic parser state (&lt;a href=&quot;#PL_parser&quot;&gt;PL_parser&lt;/a&gt; et al) is correctly set to reflect the source of the code to be parsed and the lexical context for the statements.</source>
          <target state="translated">0 개 이상의 Perl 문의 시퀀스를 구문 분석하십시오. 이는 선택적 레이블 또는 컴파일 타임 효과가있는 선언 또는 이들의 혼합을 포함한 일반적인 명령문 일 수 있습니다. 새 명령문이 유효하게 시작될 수있는 위치에서 닫는 중괄호 또는 파일 끝이 발견되면 명령문 순서가 종료됩니다. 동적 파서 상태 ( &lt;a href=&quot;#PL_parser&quot;&gt;PL_parser&lt;/a&gt; et al)가 구문 분석 할 코드의 소스와 명령문의 어휘 컨텍스트를 반영하도록 올바르게 설정되었는지 확인하는 것은 호출자에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce089482d2db81fc038bc61d37035494dbd4a5e7" translate="yes" xml:space="preserve">
          <source>Parse a single complete Perl code block. This consists of an opening brace, a sequence of statements, and a closing brace. The block constitutes a lexical scope, so &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; variables and various compile-time effects can be contained within it. It is up to the caller to ensure that the dynamic parser state (&lt;a href=&quot;#PL_parser&quot;&gt;PL_parser&lt;/a&gt; et al) is correctly set to reflect the source of the code to be parsed and the lexical context for the statement.</source>
          <target state="translated">하나의 완전한 Perl 코드 블록을 구문 분석하십시오. 이것은 여는 중괄호, 일련의 명령문 및 닫는 중괄호로 구성됩니다. 그래서 블록은 어휘 범위를 구성하는 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 변수 및 각종 컴파일시 효과가 그 안에 포함될 수있다. 동적 파서 상태 ( &lt;a href=&quot;#PL_parser&quot;&gt;PL_parser&lt;/a&gt; et al)가 구문 분석 할 코드의 소스와 명령문의 어휘 컨텍스트를 반영하도록 올바르게 설정되었는지 확인하는 것은 호출자에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="9eba5130051b754a15b7c0146935178b7a793c12" translate="yes" xml:space="preserve">
          <source>Parse a single complete Perl expression. This allows the full expression grammar, including the lowest-precedence operators such as &lt;code&gt;or&lt;/code&gt; . The expression must be followed (and thus terminated) by a token that an expression would normally be terminated by: end-of-file, closing bracketing punctuation, semicolon, or one of the keywords that signals a postfix expression-statement modifier. If</source>
          <target state="translated">하나의 완전한 Perl 표현식을 구문 분석하십시오. 이 같은 최저 우선 순위 연산자를 포함한 전체 표현 문법을 허용 &lt;code&gt;or&lt;/code&gt; . 표현식은 파일 끝, 닫는 대괄호 문장 부호, 세미콜론 또는 접미사 expression-statement modifier를 알리는 키워드 중 하나에 의해 일반적으로 표현식이 종료되는 토큰으로 표현식 뒤에 와야합니다. 만약</target>
        </trans-unit>
        <trans-unit id="58f6019da7384a5fca463ab30964f465a7e74317" translate="yes" xml:space="preserve">
          <source>Parse a single complete Perl statement. This may be a normal imperative statement or a declaration that has compile-time effect, and may include optional labels. It is up to the caller to ensure that the dynamic parser state (&lt;a href=&quot;#PL_parser&quot;&gt;PL_parser&lt;/a&gt; et al) is correctly set to reflect the source of the code to be parsed and the lexical context for the statement.</source>
          <target state="translated">하나의 완전한 Perl 문을 구문 분석하십시오. 이는 일반적인 명령형 명령이거나 컴파일 타임 효과가있는 선언 일 수 있으며 선택적 레이블을 포함 할 수 있습니다. 동적 파서 상태 ( &lt;a href=&quot;#PL_parser&quot;&gt;PL_parser&lt;/a&gt; et al)가 구문 분석 할 코드의 소스와 명령문의 어휘 컨텍스트를 반영하도록 올바르게 설정되었는지 확인하는 것은 호출자에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="47cabbfacc2ecefb926eabaa7917ccc6eda5e749" translate="yes" xml:space="preserve">
          <source>Parse a single label, possibly optional, of the type that may prefix a Perl statement. It is up to the caller to ensure that the dynamic parser state (&lt;a href=&quot;#PL_parser&quot;&gt;PL_parser&lt;/a&gt; et al) is correctly set to reflect the source of the code to be parsed. If</source>
          <target state="translated">Perl 문 앞에 붙일 수있는 유형의 단일 레이블 (선택적)을 구문 분석하십시오. 동적 파서 상태 ( &lt;a href=&quot;#PL_parser&quot;&gt;PL_parser&lt;/a&gt; 등)가 구문 분석 될 코드의 소스를 반영하도록 올바르게 설정되었는지 확인하는 것은 호출자에게 달려 있습니다. 만약</target>
        </trans-unit>
        <trans-unit id="2760bb775d2f5ac01c987fbbfc94d63c9c899e62" translate="yes" xml:space="preserve">
          <source>Parse a single unadorned Perl statement. This may be a normal imperative statement or a declaration that has compile-time effect. It does not include any label or other affixture. It is up to the caller to ensure that the dynamic parser state (&lt;a href=&quot;#PL_parser&quot;&gt;PL_parser&lt;/a&gt; et al) is correctly set to reflect the source of the code to be parsed and the lexical context for the statement.</source>
          <target state="translated">단일의 옹호되지 않은 Perl 문을 구문 분석하십시오. 이것은 일반적인 명령 또는 컴파일 타임 효과가있는 선언 일 수 있습니다. 라벨이나 기타 부착물은 포함되어 있지 않습니다. 동적 파서 상태 ( &lt;a href=&quot;#PL_parser&quot;&gt;PL_parser&lt;/a&gt; et al)가 구문 분석 할 코드의 소스와 명령문의 어휘 컨텍스트를 반영하도록 올바르게 설정되었는지 확인하는 것은 호출자에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c6f184ce547c8aba43670b279e40b0257db5871" translate="yes" xml:space="preserve">
          <source>Parse an L&amp;lt;&amp;gt; formatting code in POD text</source>
          <target state="translated">POD 텍스트에서 L &amp;lt;&amp;gt; 형식화 코드 구문 분석</target>
        </trans-unit>
        <trans-unit id="e36fba2ce293e9dd2d7ccd39cdd6da710089a942" translate="yes" xml:space="preserve">
          <source>Parse and process a file with pod in it:</source>
          <target state="translated">포드가있는 파일을 구문 분석하고 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="95c795a721b662a23c96150509b7defee01aa093" translate="yes" xml:space="preserve">
          <source>Parse file paths into directory, filename and suffix.</source>
          <target state="translated">파일 경로를 디렉토리, 파일 이름 및 접미사로 구문 분석하십시오.</target>
        </trans-unit>
        <trans-unit id="7ef71ab4754324a2f907d13e0118b212e436f9d9" translate="yes" xml:space="preserve">
          <source>Parse text into an array of tokens or array of arrays</source>
          <target state="translated">텍스트를 토큰 배열 또는 배열 배열로 구문 분석</target>
        </trans-unit>
        <trans-unit id="8f66dc0790859dd1eeb3a917210e58e38ca209e0" translate="yes" xml:space="preserve">
          <source>Parse::CPAN::Meta</source>
          <target state="translated">Parse::CPAN::Meta</target>
        </trans-unit>
        <trans-unit id="14f134b3af22420beae12cee1984569fcb79b734" translate="yes" xml:space="preserve">
          <source>Parse::CPAN::Meta - Parse META.yml and META.json CPAN metadata files</source>
          <target state="translated">구문 분석 :: CPAN :: Meta-구문 분석 META.yml 및 META.json CPAN 메타 데이터 파일</target>
        </trans-unit>
        <trans-unit id="fe64ba8660ae82053a168a558e1390828e9d75c0" translate="yes" xml:space="preserve">
          <source>Parse::RecDescent uses &lt;code&gt;extract_codeblock($text, '{}&amp;lt;&amp;gt;')&lt;/code&gt; to extract the code within the &lt;code&gt;&amp;lt;defer:...&amp;gt;&lt;/code&gt; directive, but there's a problem.</source>
          <target state="translated">Parse :: RecDescent는 &lt;code&gt;extract_codeblock($text, '{}&amp;lt;&amp;gt;')&lt;/code&gt; 을 사용하여 &lt;code&gt;&amp;lt;defer:...&amp;gt;&lt;/code&gt; 지시문 내에서 코드를 추출 하지만 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="418d1a5bd76755f2c0308bd1eebe8bb8f1bdc41d" translate="yes" xml:space="preserve">
          <source>Parser Components</source>
          <target state="translated">파서 컴포넌트</target>
        </trans-unit>
        <trans-unit id="fe2f07bac5eb2fe04d3c37f8f55ba8daadac0f8d" translate="yes" xml:space="preserve">
          <source>Parses a string containing a valid YAML stream into a list of Perl data structures.</source>
          <target state="translated">유효한 YAML 스트림을 포함하는 문자열을 Perl 데이터 구조 목록으로 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="581e381893d5cec0eef75cd617fe11072fd60c0d" translate="yes" xml:space="preserve">
          <source>Parses from &lt;code&gt;$source&lt;/code&gt; file to &lt;code&gt;$to&lt;/code&gt; file. Similar to &lt;a href=&quot;parser#parse_from_file&quot;&gt;parse_from_file in Pod::Parser&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;$source&lt;/code&gt; 파일에서 &lt;code&gt;$to&lt;/code&gt; 파일 로 구문 분석 합니다. &lt;a href=&quot;parser#parse_from_file&quot;&gt;Pod :: Parser의 parse_from_file과&lt;/a&gt; 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="092f1e46c6bd81566c97fcc512b18db5d5c4aab0" translate="yes" xml:space="preserve">
          <source>Parses the uri and creates a corresponding File::Fetch::Item object, that is ready to be &lt;code&gt;fetch&lt;/code&gt; ed and returns it.</source>
          <target state="translated">구문 분석하는 URI를하고 해당 파일 : 가져 오기 : Item 객체가 될 준비가 생성 &lt;code&gt;fetch&lt;/code&gt; 에드 반환을.</target>
        </trans-unit>
        <trans-unit id="7294d33710169103141018bfcb0ee5ad3daa81e2" translate="yes" xml:space="preserve">
          <source>Parsing</source>
          <target state="translated">Parsing</target>
        </trans-unit>
        <trans-unit id="201a7c8f517e70abce0e1a757b9f06ab6e1eaa4c" translate="yes" xml:space="preserve">
          <source>Parsing complications</source>
          <target state="translated">구문 분석 합병증</target>
        </trans-unit>
        <trans-unit id="56105dfe20714874a2e829f3d18d1b5e096635b7" translate="yes" xml:space="preserve">
          <source>Parsing for construction</source>
          <target state="translated">건설 파싱</target>
        </trans-unit>
        <trans-unit id="60d12b966804dcb52fae0aab613b1970bacceb22" translate="yes" xml:space="preserve">
          <source>Parsing for size</source>
          <target state="translated">크기 파싱</target>
        </trans-unit>
        <trans-unit id="80341dac319c1b5410ead916b5a70b09b9ef0f4d" translate="yes" xml:space="preserve">
          <source>Parsing harness related environmental variables where appropriate</source>
          <target state="translated">적절한 경우 파싱 하네스 관련 환경 변수</target>
        </trans-unit>
        <trans-unit id="f5b02e670994bc090c4464c23b48f3c45762f6da" translate="yes" xml:space="preserve">
          <source>Parsing is implemented per &lt;a href=&quot;../perlpodspec&quot;&gt;perlpodspec&lt;/a&gt;. For backward compatibility, links where there is no section and name contains spaces, or links where the entirety of the link (except for the anchor text if given) is enclosed in double-quotes are interpreted as links to a section (L&amp;lt;/section&amp;gt;).</source>
          <target state="translated">&lt;a href=&quot;../perlpodspec&quot;&gt;perlpodspec에&lt;/a&gt; 따라 구문 분석이 구현됩니다 . 이전 버전과의 호환성을 위해 섹션이없고 이름이없는 링크에는 공백이 포함되어 있거나 링크 전체 (제공된 경우 앵커 텍스트 제외)가 큰 따옴표로 묶인 링크는 섹션에 대한 링크로 해석됩니다 (L &amp;lt;/ section &amp;gt;).</target>
        </trans-unit>
        <trans-unit id="21fec48dc32ed2c2c516a7d00eccd1fc2dbbf7ca" translate="yes" xml:space="preserve">
          <source>Parsing of the &lt;code&gt;#!&lt;/code&gt; switches starts wherever &quot;perl&quot; is mentioned in the line. The sequences &quot;-*&quot; and &quot;- &quot; are specifically ignored so that you could, if you were so inclined, say</source>
          <target state="translated">&lt;code&gt;#!&lt;/code&gt; 파싱 ! 스위치는 라인에서 &quot;perl&quot;이 언급 될 때마다 시작됩니다. &quot;-*&quot;및 &quot;-&quot;시퀀스는 특별히 무시되므로 기울어 졌을 경우 다음과 같이 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4a66fb666677831fbb89c4617c9cb55023dbd3e" translate="yes" xml:space="preserve">
          <source>Parsing of the bracketed character class construct, &lt;code&gt;[...]&lt;/code&gt; , is rather different than the rule used for the rest of the pattern. The terminator of this construct is found using the same rules as for finding the terminator of a &lt;code&gt;{}&lt;/code&gt; -delimited construct, the only exception being that &lt;code&gt;]&lt;/code&gt; immediately following &lt;code&gt;[&lt;/code&gt; is treated as though preceded by a backslash.</source>
          <target state="translated">대괄호로 묶은 문자 클래스 구문 &lt;code&gt;[...]&lt;/code&gt; 의 구문 분석은 나머지 패턴에 사용 된 규칙과 다소 다릅니다. 이 구문의 종결자는 &lt;code&gt;{}&lt;/code&gt; 구분 구문 의 종결자를 찾는 것과 동일한 규칙을 사용하여 발견되며 &lt;code&gt;[&lt;/code&gt; 바로 다음의 &lt;code&gt;]&lt;/code&gt; 는 백 슬래시가 앞에 오는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="73445354eb44bc4201e65870d8cf75c662a12338" translate="yes" xml:space="preserve">
          <source>Parsing options from an arbitrary array</source>
          <target state="translated">임의 배열에서 옵션 파싱</target>
        </trans-unit>
        <trans-unit id="7c23dc7bccdc54b6af40c30891098a1ec3018d31" translate="yes" xml:space="preserve">
          <source>Parsing options from an arbitrary string</source>
          <target state="translated">임의의 문자열에서 옵션 파싱</target>
        </trans-unit>
        <trans-unit id="fae1cc5f61c39d7ca25192b6ad11336a46da6cc3" translate="yes" xml:space="preserve">
          <source>Part 1: The basics</source>
          <target state="translated">1 부 : 기초</target>
        </trans-unit>
        <trans-unit id="0ef5ae5e92fc124e5a59c33d1478fa00e49ca98c" translate="yes" xml:space="preserve">
          <source>Part 2: Power tools</source>
          <target state="translated">2 부 : 전동 공구</target>
        </trans-unit>
        <trans-unit id="67d014ca4761f29f2d21414f531603a8e6bec46f" translate="yes" xml:space="preserve">
          <source>Pass an undef value to disable it:</source>
          <target state="translated">undef 값을 전달하여 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="6c2219e935754aed07fd99bb89a0b43879d2aa88" translate="yes" xml:space="preserve">
          <source>Pass arrays and hashes by reference, not by value. For one thing, it's the only way to pass multiple lists or hashes (or both) in a single call/return. It also avoids creating a copy of all the contents. This requires some judgement, however, because any changes will be propagated back to the original data. If you really want to mangle (er, modify) a copy, you'll have to sacrifice the memory needed to make one.</source>
          <target state="translated">값이 아닌 참조로 배열과 해시를 전달하십시오. 우선, 단일 호출 / 반환으로 여러 목록 또는 해시 (또는 둘 다)를 전달할 수있는 유일한 방법입니다. 또한 모든 내용의 사본을 작성하지 않습니다. 그러나 변경 사항이 원래 데이터로 다시 전파되므로 약간의 판단이 필요합니다. 사본을 실제로 엉망으로 만들려면 사본을 만드는 데 필요한 메모리를 희생해야합니다.</target>
        </trans-unit>
        <trans-unit id="0faa9975944d7d7c5896c953cdfdaa9399cd924e" translate="yes" xml:space="preserve">
          <source>Pass arrays as references so more parameters can be added later (it's also faster). Convert functions into methods where appropriate. Split large methods into smaller more flexible ones. Inherit methods from other modules if appropriate.</source>
          <target state="translated">나중에 더 많은 매개 변수를 추가 할 수 있도록 배열을 참조로 전달하십시오 (더 빠름). 적절한 경우 함수를 메소드로 변환하십시오. 큰 방법을 더 작은 방법으로 나눕니다. 적절한 경우 다른 모듈에서 메소드를 상속하십시오.</target>
        </trans-unit>
        <trans-unit id="7d95906c33f61c39cf91fb90166084e4d01776d3" translate="yes" xml:space="preserve">
          <source>Pass by Reference</source>
          <target state="translated">참조로 전달</target>
        </trans-unit>
        <trans-unit id="053ad74d06c8d9f5eb6073c958d95571ac0cf875" translate="yes" xml:space="preserve">
          <source>Pass-through options</source>
          <target state="translated">통과 옵션</target>
        </trans-unit>
        <trans-unit id="b99c51ad09b3295fb732520f288da663a4c77836" translate="yes" xml:space="preserve">
          <source>Passed in implicitly via standard input. This works only if there are no filename arguments--to pass arguments to a STDIN-read program you must explicitly specify a &quot;-&quot; for the program name.</source>
          <target state="translated">표준 입력을 통해 암시 적으로 전달됩니다. 파일 이름 인수가없는 경우에만 작동합니다. STDIN 읽기 프로그램에 인수를 전달하려면 프로그램 이름에 &quot;-&quot;를 명시 적으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="c1dfda537026966c5e1e28098e3760a352bbbd9e" translate="yes" xml:space="preserve">
          <source>Passing &lt;code&gt;$hash{ 'foo' }&lt;/code&gt; to a subroutine used to be a special case, though. Since you could assign directly to &lt;code&gt;$_[0]&lt;/code&gt; , Perl had to be ready to make that assignment so it created the hash key ahead of time:</source>
          <target state="translated">하지만 &lt;code&gt;$hash{ 'foo' }&lt;/code&gt; 를 서브 루틴에 전달 하는 것은 특별한 경우였습니다. &lt;code&gt;$_[0]&lt;/code&gt; 에 직접 할당 할 수 있기 때문에 Perl은 할당을 할 준비가되었으므로 미리 해시 키를 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="5c25d01562076258933dad64551143b78c5bd332" translate="yes" xml:space="preserve">
          <source>Passing NULL for SV creates a constant sub equivalent to &lt;code&gt;sub BAR () {}&lt;/code&gt; , which won't be called if used as a destructor, but will suppress the overhead of a call to &lt;code&gt;AUTOLOAD&lt;/code&gt; . (This form, however, isn't eligible for inlining at compile time.)</source>
          <target state="translated">SV에 NULL을 전달하면 &lt;code&gt;sub BAR () {}&lt;/code&gt; 해당하는 상수 하위가 만들어 지며 소멸자로 사용되는 경우 호출되지 않지만 &lt;code&gt;AUTOLOAD&lt;/code&gt; 에 대한 호출의 오버 헤드는 억제됩니다 . 그러나이 양식은 컴파일 타임에 인라인 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="92e7a89cda780976fa2b2bf15b8fa16940c9e791" translate="yes" xml:space="preserve">
          <source>Passing Parameters</source>
          <target state="translated">전달 매개 변수</target>
        </trans-unit>
        <trans-unit id="631e829d46dd7a132eee37564669347bda1fdeb4" translate="yes" xml:space="preserve">
          <source>Passing Symbol Table Entries (typeglobs)</source>
          <target state="translated">기호 테이블 항목 전달 (typeglobs)</target>
        </trans-unit>
        <trans-unit id="9c282987a3e4a9c1f484c40c67cee6ec02907f83" translate="yes" xml:space="preserve">
          <source>Passing a true value for &lt;code&gt;$no_file&lt;/code&gt; indicates that the path being split only contains directory components, even on systems where you can usually (when not supporting a foreign syntax) tell the difference between directories and files at a glance.</source>
          <target state="translated">&lt;code&gt;$no_file&lt;/code&gt; true 값을 전달하면 일반적으로 (외래 구문을 지원하지 않을 때) 디렉토리와 파일의 차이를 한눈에 알 수있는 시스템에서도 분할되는 경로에 디렉토리 구성 요소 만 포함됨을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="57e7c7fde542cf4bbfc2454d2a7557dc31e803b8" translate="yes" xml:space="preserve">
          <source>Passing an array reference containing only one element, 'name', is special cased to return a list of names rather than a list of hash references, making it equivalent to calling &lt;code&gt;list_files&lt;/code&gt; without arguments.</source>
          <target state="translated">하나의 요소 인 'name'만 포함하는 배열 참조를 전달하는 것은 해시 참조 목록이 아닌 이름 목록을 반환하는 특수한 경우로, 인수없이 &lt;code&gt;list_files&lt;/code&gt; 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="33e2edde52cbb4ec756e8a81aaf676fa8eab3f52" translate="yes" xml:space="preserve">
          <source>Passing an array reference containing only one element, 'name', is special cased to return a list of names rather than a list of hash references.</source>
          <target state="translated">하나의 요소 인 'name'만 포함하는 배열 참조를 전달하는 것은 해시 참조 목록이 아닌 이름 목록을 반환하기 위해 특수한 경우입니다.</target>
        </trans-unit>
        <trans-unit id="73e454c3c193b2c18919a57428be215c94732d74" translate="yes" xml:space="preserve">
          <source>Passing an empty string &quot;&quot; as the first argument to &lt;code&gt;catdir()&lt;/code&gt; is like passing&lt;code&gt;File::Spec-&amp;gt;rootdir()&lt;/code&gt; as the first argument, i.e.</source>
          <target state="translated">&lt;code&gt;catdir()&lt;/code&gt; 의 첫 번째 인수로 빈 문자열 &quot;&quot;을 전달하는 것은 &lt;code&gt;File::Spec-&amp;gt;rootdir()&lt;/code&gt; 을 첫 번째 인수로 전달하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d6de5b84e84c7ec759c47090ea234e479eb3f3b2" translate="yes" xml:space="preserve">
          <source>Passing array/hash refs that contain objects may not work for Perl prior to 5.10.0.</source>
          <target state="translated">객체가 포함 된 배열 / 해시 참조를 전달하면 5.10.0 이전의 Perl에서 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="778d28f8a8c46b422aec9c2654919755f059cdd6" translate="yes" xml:space="preserve">
          <source>Passing new options to the $walker is the easiest way to change amongst any pre-defined styles (the ones you add are automatically recognized as options), and is the only way to alter rendering order without calling compile again. Note however that rendering state is still shared amongst multiple $walker objects, so they must still be used in a coordinated manner.</source>
          <target state="translated">사전 정의 된 스타일 중에서 변경하는 가장 쉬운 방법은 $ walker에 새 옵션을 전달하는 것 (추가 한 스타일은 자동으로 옵션으로 인식됨)이며 다시 컴파일을 호출하지 않고 렌더링 순서를 변경하는 유일한 방법입니다. 그러나 렌더링 상태는 여전히 여러 $ walker 객체간에 공유되므로 여전히 조정 된 방식으로 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="000338825dc1ad597f0654c697650b0c505e9d75" translate="yes" xml:space="preserve">
          <source>Passing objects on queues may not work if the objects' classes do not support sharing. See &lt;a href=&quot;../threads/shared#BUGS-AND-LIMITATIONS&quot;&gt;BUGS AND LIMITATIONS in threads::shared&lt;/a&gt; for more.</source>
          <target state="translated">객체 클래스가 공유를 지원하지 않으면 대기열에서 객체 전달이 작동하지 않을 수 있습니다. 자세한 내용 &lt;a href=&quot;../threads/shared#BUGS-AND-LIMITATIONS&quot;&gt;은 threads :: shared의 버그 및 제한을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b55ad2737b0f246adb41a25f43c9856e1465d7d3" translate="yes" xml:space="preserve">
          <source>Passing only one of the first two elements as &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is equivalent to passing a 0 and will not have the effect described when both are &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. This also triggers an uninitialized warning.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 로 처음 두 요소 중 하나만 전달하는 것은 0을 전달하는 것과 같으며 둘 다 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 일 때 설명 된 효과가 없습니다 . 또한 초기화되지 않은 경고를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="816c2ea902ef30f358f592af797150423983b160" translate="yes" xml:space="preserve">
          <source>Passing only one of the first two elements as &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is equivalent to passing a 0 and will not have the effect described when both are &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. This also triggers an uninitialized warning.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 로 처음 두 요소 중 하나만 전달하는 것은 0을 전달하는 것과 같으며 둘 다 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 일 때 설명 된 효과가 없습니다 . 또한 초기화되지 않은 경고를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="ff65b3fe44892512aa53628ad3cbe12f9d7ca3ec" translate="yes" xml:space="preserve">
          <source>Passing the tied object to &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">묶인 물체를 &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85ec73bc8762feb2e3028dbf252686e023bd6e19" translate="yes" xml:space="preserve">
          <source>Past contributions from: brian d foy &lt;code&gt;&amp;lt;bdfoy@cpan.org&amp;gt;&lt;/code&gt; Adriano R. Ferreira &lt;code&gt;&amp;lt;ferreira@cpan.org&amp;gt;&lt;/code&gt; , Sean M. Burke &lt;code&gt;&amp;lt;sburke@cpan.org&amp;gt;&lt;/code&gt;</source>
          <target state="translated">과거 기여 : brian d foy &lt;code&gt;&amp;lt;bdfoy@cpan.org&amp;gt;&lt;/code&gt; Adriano R. Ferreira &lt;code&gt;&amp;lt;ferreira@cpan.org&amp;gt;&lt;/code&gt; , Sean M. Burke &lt;code&gt;&amp;lt;sburke@cpan.org&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c5e8c22064e37b00fe594c59a2558cd9b22cdd1" translate="yes" xml:space="preserve">
          <source>Past contributions from: brian d foy &lt;code&gt;&amp;lt;bdfoy@cpan.org&amp;gt;&lt;/code&gt; Adriano R. Ferreira &lt;code&gt;&amp;lt;ferreira@cpan.org&amp;gt;&lt;/code&gt; ; Sean M. Burke &lt;code&gt;&amp;lt;sburke@cpan.org&amp;gt;&lt;/code&gt; ; significant portions copied from</source>
          <target state="translated">과거 기여 : brian d foy &lt;code&gt;&amp;lt;bdfoy@cpan.org&amp;gt;&lt;/code&gt; Adriano R. Ferreira &lt;code&gt;&amp;lt;ferreira@cpan.org&amp;gt;&lt;/code&gt; ; Sean M. Burke &lt;code&gt;&amp;lt;sburke@cpan.org&amp;gt;&lt;/code&gt; ; 중요한 부분에서 복사</target>
        </trans-unit>
        <trans-unit id="b20a451c29c9cea2e46c19630395de2df6f76e08" translate="yes" xml:space="preserve">
          <source>Past contributors are: brian d foy &lt;code&gt;&amp;lt;bdfoy@cpan.org&amp;gt;&lt;/code&gt; Adriano R. Ferreira &lt;code&gt;&amp;lt;ferreira@cpan.org&amp;gt;&lt;/code&gt; , Sean M. Burke &lt;code&gt;&amp;lt;sburke@cpan.org&amp;gt;&lt;/code&gt; , Kenneth Albanowski &lt;code&gt;&amp;lt;kjahds@kjahds.com&amp;gt;&lt;/code&gt; , Andy Dougherty &lt;code&gt;&amp;lt;doughera@lafcol.lafayette.edu&amp;gt;&lt;/code&gt; , and many others.</source>
          <target state="translated">과거 기여자 : brian d foy &lt;code&gt;&amp;lt;bdfoy@cpan.org&amp;gt;&lt;/code&gt; Adriano R. Ferreira &lt;code&gt;&amp;lt;ferreira@cpan.org&amp;gt;&lt;/code&gt; , Sean M. Burke &lt;code&gt;&amp;lt;sburke@cpan.org&amp;gt;&lt;/code&gt; , Kenneth Albanowski &lt;code&gt;&amp;lt;kjahds@kjahds.com&amp;gt;&lt;/code&gt; , Andy Dougherty &lt;code&gt;&amp;lt;doughera@lafcol.lafayette.edu&amp;gt;&lt;/code&gt; 및 기타 다수</target>
        </trans-unit>
        <trans-unit id="5b790410ca6021f643b25dc0684b80c6ac035a6f" translate="yes" xml:space="preserve">
          <source>Patch style</source>
          <target state="translated">패치 스타일</target>
        </trans-unit>
        <trans-unit id="e616d246e566a6e437d4992af55f91c42a43620c" translate="yes" xml:space="preserve">
          <source>Patch, extend or subclass an existing module where possible</source>
          <target state="translated">가능한 경우 기존 모듈 패치, 확장 또는 서브 클래스</target>
        </trans-unit>
        <trans-unit id="57bddba1c66e0b8fdc9d892c78bfc22f25c546f6" translate="yes" xml:space="preserve">
          <source>Patches against Pod::Simple are welcome. Please send bug reports to &amp;lt;bug-pod-simple@rt.cpan.org&amp;gt;.</source>
          <target state="translated">Pod :: Simple에 대한 패치는 환영합니다. 버그 리포트를 &amp;lt;bug-pod-simple@rt.cpan.org&amp;gt;로 보내주십시오.</target>
        </trans-unit>
        <trans-unit id="139936b1a9a84a97721c26af3e777c3a03af1e6f" translate="yes" xml:space="preserve">
          <source>Patches are reviewed and discussed on the p5p list. Simple, uncontroversial patches will usually be applied without any discussion. When the patch is applied, the ticket will be updated and you will receive email. In addition, an email will be sent to the p5p list.</source>
          <target state="translated">패치는 p5p 목록에서 검토 및 논의됩니다. 논란의 여지가없는 간단한 패치는 일반적으로 논의없이 적용됩니다. 패치가 적용되면 티켓이 업데이트되고 이메일을 받게됩니다. 또한 p5p 목록으로 이메일이 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="f960f4eadeba1dd57f417d470c8e32c7459acc42" translate="yes" xml:space="preserve">
          <source>Patches may be applied by the pumpkin holder without the explicit cooperation of the module author if and only if they are very minor, time-critical in some fashion (such as urgent security fixes), or if the module author cannot be reached. Those patches must still be given back to the author when possible, and if the author decides on an alternate fix in their version, that fix should be strongly preferred unless there is a serious problem with it. Any changes not endorsed by the author should be marked as such, and the contributor of the change acknowledged.</source>
          <target state="translated">패치가 매우 작고 시간이 중요한 경우 (예 : 긴급 보안 수정) 또는 모듈 작성자에게 연락 할 수없는 경우에만 모듈 작성자의 명시적인 협력없이 패치를 호박 홀더가 적용 할 수 있습니다. 이러한 패치는 가능하면 제작자에게 다시 제공해야하며 제작자가 해당 버전의 대체 수정 프로그램을 결정하는 경우 심각한 문제가없는 한이 수정 프로그램을 강력히 선호해야합니다. 저자가 보증하지 않은 모든 변경 사항은 그대로 표시되어야하며 변경의 기여자는 인정해야합니다.</target>
        </trans-unit>
        <trans-unit id="bb89b691c1294b8ada4f9cd31a429e4caf872c3f" translate="yes" xml:space="preserve">
          <source>Patches speak louder than words</source>
          <target state="translated">패치는 단어보다 더 크게 말합니다</target>
        </trans-unit>
        <trans-unit id="d54931049c09c712e0cbea3d090e4d3b4a105c0b" translate="yes" xml:space="preserve">
          <source>Patches that add new warnings or errors or deprecate features.</source>
          <target state="translated">새로운 경고 나 오류를 추가하거나 기능을 사용하지 않는 패치.</target>
        </trans-unit>
        <trans-unit id="29abf1c3bbb8c54b1cd55ff655f670f9ebc399ee" translate="yes" xml:space="preserve">
          <source>Patches that add or remove features.</source>
          <target state="translated">기능을 추가하거나 제거하는 패치.</target>
        </trans-unit>
        <trans-unit id="f84461a4c1a5b5e429209771f4e83af6717ee46b" translate="yes" xml:space="preserve">
          <source>Patches that break binary compatibility. (Please talk to a pumpking.)</source>
          <target state="translated">이진 호환성을 손상시키는 패치. (호박에게 이야기하십시오.)</target>
        </trans-unit>
        <trans-unit id="323fd112f38ff019a7ad9800eabd680b9a815934" translate="yes" xml:space="preserve">
          <source>Patches that fix CVEs or security issues. These changes should be run through the perl5-security-report@perl.org mailing list rather than applied directly.</source>
          <target state="translated">CVE 또는 보안 문제를 해결하는 패치 이러한 변경 사항은 직접 적용하지 않고 perl5-security-report@perl.org 메일 링리스트를 통해 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="f0910db599c5e57f13f342f2401ca7baceb18c00" translate="yes" xml:space="preserve">
          <source>Patches that fix anything which prevents or seriously impacts the build or installation of perl.</source>
          <target state="translated">Perl의 빌드 또는 설치를 방해하거나 심각하게 영향을 미치는 것을 수정하는 패치.</target>
        </trans-unit>
        <trans-unit id="21130596c95c32860a5fe99dde40cbc8202f1859" translate="yes" xml:space="preserve">
          <source>Patches that fix crashing bugs, assertion failures and memory corruption but which do not otherwise change perl's functionality or negatively impact performance.</source>
          <target state="translated">충돌 버그, 어설 션 오류 및 메모리 손상을 수정하지만 펄의 기능을 변경하거나 성능에 부정적인 영향을 미치지 않는 패치.</target>
        </trans-unit>
        <trans-unit id="c95c81109a9edefb7a99fa1792240b1c8c4accc7" translate="yes" xml:space="preserve">
          <source>Patches that fix regressions in perl's behavior relative to previous releases, no matter how old the regression, since some people may upgrade from very old versions of perl to the latest version.</source>
          <target state="translated">일부 사용자는 이전 버전의 perl에서 최신 버전으로 업그레이드 할 수 있기 때문에 이전 버전에 비해 펄의 동작에서 회귀를 수정하는 패치.</target>
        </trans-unit>
        <trans-unit id="93c3b06e57a98513617dbda85f73638d28687b18" translate="yes" xml:space="preserve">
          <source>Patches which change behaviour (fixing bugs or introducing new features) must include regression tests to verify that everything works as expected.</source>
          <target state="translated">동작을 변경하는 패치 (버그 수정 또는 새로운 기능 도입)에는 모든 것이 예상대로 작동하는지 확인하기위한 회귀 테스트가 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="8270f0c679e10266c6a9f82f5a4c89d2c3cc697e" translate="yes" xml:space="preserve">
          <source>Patches without documentation are probably ill-thought out or incomplete. No features can be added or changed without documentation, so submitting a patch for the appropriate pod docs as well as the source code is important.</source>
          <target state="translated">문서가없는 패치는 생각하지 않거나 불완전 할 수 있습니다. 설명서 없이는 기능을 추가하거나 변경할 수 없으므로 적절한 포드 문서와 소스 코드에 대한 패치를 제출하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="e27ae82b9a6b018ee112b21851652cbe49271b3b" translate="yes" xml:space="preserve">
          <source>Patching a core module</source>
          <target state="translated">핵심 모듈 패치</target>
        </trans-unit>
        <trans-unit id="519e39132bb98418cc0483cc446ccf5f3c8dcffe" translate="yes" xml:space="preserve">
          <source>Path</source>
          <target state="translated">Path</target>
        </trans-unit>
        <trans-unit id="0b1fe397674f2ea0ca0d83a858144940f7da6b34" translate="yes" xml:space="preserve">
          <source>Patterns are implicitly anchored at the beginning and end of each string when testing for a match.</source>
          <target state="translated">일치를 테스트 할 때 각 문자열의 시작과 끝에 패턴이 암시 적으로 고정됩니다.</target>
        </trans-unit>
        <trans-unit id="d223d697e7957195cfa22daa9019ad4f989b3028" translate="yes" xml:space="preserve">
          <source>Patterns are subject to an additional level of interpretation as a regular expression. This is done as a second pass, after variables are interpolated, so that regular expressions may be incorporated into the pattern from the variables. If this is not what you want, use &lt;code&gt;\Q&lt;/code&gt; to interpolate a variable literally.</source>
          <target state="translated">패턴은 정규 표현식으로 추가 해석 수준이 적용됩니다. 이는 변수가 보간 된 후 두 번째 패스로 수행되므로 정규식이 변수의 패턴에 통합 될 수 있습니다. 이것이 마음에 들지 않으면 &lt;code&gt;\Q&lt;/code&gt; 를 사용 하여 변수를 문자 그대로 보간하십시오.</target>
        </trans-unit>
        <trans-unit id="e23f050b63735be39db7dcbaa09bfdd36470f510" translate="yes" xml:space="preserve">
          <source>Patterns of the form /#\d/ will be replaced with the</source>
          <target state="translated">/ # \ d / 형식의 패턴은</target>
        </trans-unit>
        <trans-unit id="657c59b79c5dc51478a7a404f0af13b53b988447" translate="yes" xml:space="preserve">
          <source>Paul Green (Paul.Green@stratus.com)</source>
          <target state="translated">폴 그린 (Paul.Green@stratus.com)</target>
        </trans-unit>
        <trans-unit id="7bea737592f1b2469295059802a7399af95a087a" translate="yes" xml:space="preserve">
          <source>Paul Marquess</source>
          <target state="translated">폴 마르케스</target>
        </trans-unit>
        <trans-unit id="1da5f372b188cb5eeeeafb09b1f0a31fca9b993f" translate="yes" xml:space="preserve">
          <source>Paul Marquess &amp;lt;Paul.Marquess@btinternet.com&amp;gt;</source>
          <target state="translated">폴 마퀴스 &amp;lt;Paul.Marquess@btinternet.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="4fbcf625afc3d507d379cacdea04bbc6b875a1d5" translate="yes" xml:space="preserve">
          <source>Paul Marquess &amp;lt;pmqs@cpan.org&amp;gt;</source>
          <target state="translated">폴 마퀴스 &amp;lt;pmqs@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="c4337beb0e4af629844f1525d967a958a8d53fbd" translate="yes" xml:space="preserve">
          <source>Paul Marquess pmqs@cpan.org</source>
          <target state="translated">폴 마르케스 pmqs@cpan.org</target>
        </trans-unit>
        <trans-unit id="914e119a6f7c68c285bad290780b5645e4c2e6e0" translate="yes" xml:space="preserve">
          <source>Paul Szabo identified the race condition originally, and Brendan O'Dea wrote an implementation for Debian that addressed the problem. That code was used as a basis for the current code. Their efforts are greatly appreciated.</source>
          <target state="translated">Paul Szabo는 원래 경쟁 조건을 확인했으며 Brendan O'Dea는이 문제를 해결 한 데비안 구현을 작성했습니다. 이 코드는 현재 코드의 기초로 사용되었습니다. 그들의 노력은 대단히 감사합니다.</target>
        </trans-unit>
        <trans-unit id="37c56bd6f44f98356093abe0640820d8fc0e4efe" translate="yes" xml:space="preserve">
          <source>Pay a special attention to the function &lt;code&gt;constant&lt;/code&gt; . This name appears twice in the generated .xs file: once in the first part, as a static C function, then another time in the second part, when an XSUB interface to this static C function is defined.</source>
          <target state="translated">함수 &lt;code&gt;constant&lt;/code&gt; 특별한주의를 기울이십시오 . 이 이름은 생성 된 .xs 파일에 두 번 나타납니다. 첫 번째 부분에서는 정적 C 함수로 한 번, 두 번째 부분에서는 다른 시간으로이 정적 C 함수에 대한 XSUB 인터페이스가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="fd86f5fbb7a13e213f07f240ee7591f9616574c1" translate="yes" xml:space="preserve">
          <source>Pay careful attention to the next example:</source>
          <target state="translated">다음 예에주의를 기울이십시오.</target>
        </trans-unit>
        <trans-unit id="8629c3dd5ba30eee7c4ac6064407b780f19df3f6" translate="yes" xml:space="preserve">
          <source>Pay special attention to &lt;a href=&quot;#METHODS-FOR-PARSING-AND-PROCESSING&quot;&gt;METHODS FOR PARSING AND PROCESSING&lt;/a&gt; and to the objects described in &lt;a href=&quot;inputobjects&quot;&gt;Pod::InputObjects&lt;/a&gt;. The former describes the gory details and parameters for how to customize and extend the parsing behavior of &lt;b&gt;Pod::Parser&lt;/b&gt;. &lt;b&gt;Pod::InputObjects&lt;/b&gt; provides several objects that may all be used interchangeably as parse-trees. The most obvious one is the &lt;b&gt;Pod::ParseTree&lt;/b&gt; object. It defines the basic interface and functionality that all things trying to be a POD parse-tree should do. A &lt;b&gt;Pod::ParseTree&lt;/b&gt; is defined such that each &quot;node&quot; may be a text-string, or a reference to another parse-tree. Each &lt;b&gt;Pod::Paragraph&lt;/b&gt; object and each &lt;b&gt;Pod::InteriorSequence&lt;/b&gt; object also supports the basic parse-tree interface.</source>
          <target state="translated">&lt;a href=&quot;#METHODS-FOR-PARSING-AND-PROCESSING&quot;&gt;패딩 및 처리 방법&lt;/a&gt; 과 &lt;a href=&quot;inputobjects&quot;&gt;Pod :: InputObjects에&lt;/a&gt; 설명 된 객체에 특히주의 하십시오 . 전자는 &lt;b&gt;Pod :: Parser&lt;/b&gt; 의 구문 분석 동작을 사용자 정의하고 확장하는 방법에 대한 세부 사항 및 매개 변수를 설명합니다 . &lt;b&gt;Pod :: InputObjects&lt;/b&gt; 는 모두 구문 분석 트리로 상호 교환 적으로 사용될 수있는 여러 개체를 제공합니다. 가장 확실한 것은 &lt;b&gt;Pod :: ParseTree&lt;/b&gt; 객체입니다. POD 구문 분석 트리가 되려는 모든 작업이 수행해야하는 기본 인터페이스와 기능을 정의합니다. &lt;b&gt;포드 :: 파스 트리가&lt;/b&gt; 각 &quot;노드&quot;는 텍스트 문자열, 또는 다른 구문 분석 트리에 대한 참조 할 수 있도록 정의된다. 각 &lt;b&gt;Pod :: Paragraph&lt;/b&gt; 객체와 각각&lt;b&gt;Pod :: InteriorSequence&lt;/b&gt; 객체는 기본 구문 분석 트리 인터페이스도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="8c0ffaf5c4cb2ca5b26bd5b8ebbf764c3f361b3b" translate="yes" xml:space="preserve">
          <source>Peeking At Perl's Internal Encoding</source>
          <target state="translated">Perl의 내부 인코딩 엿보기</target>
        </trans-unit>
        <trans-unit id="9326788fe51cb580ed1b0dbf97738788d7548374" translate="yes" xml:space="preserve">
          <source>Peep-hole Optimisation and Analysis</source>
          <target state="translated">들여다 보는 구멍 최적화 및 분석</target>
        </trans-unit>
        <trans-unit id="942951d0647566db32d37d28d3b5cb152d328945" translate="yes" xml:space="preserve">
          <source>Peephole optimizations are done by calling the function pointed to by the global variable &lt;code&gt;PL_peepp&lt;/code&gt; . By default, &lt;code&gt;PL_peepp&lt;/code&gt; just calls the function pointed to by the global variable &lt;code&gt;PL_rpeepp&lt;/code&gt; . By default, that performs some basic op fixups and optimisations along the execution-order op chain, and recursively calls &lt;code&gt;PL_rpeepp&lt;/code&gt; for each side chain of ops (resulting from conditionals). Extensions may provide additional optimisations or fixups, hooking into either the per-subroutine or recursive stage, like this:</source>
          <target state="translated">틈 구멍 최적화는 전역 변수 &lt;code&gt;PL_peepp&lt;/code&gt; 가 가리키는 함수를 호출하여 수행됩니다 . 기본적으로 &lt;code&gt;PL_peepp&lt;/code&gt; 는 전역 변수 &lt;code&gt;PL_rpeepp&lt;/code&gt; 에 의해 지정된 함수 만 호출합니다 . 기본적으로 실행 순서 op 체인을 따라 기본 op 수정 및 최적화를 수행 하고 조건부에서 나온 op의 각 체인에 대해 &lt;code&gt;PL_rpeepp&lt;/code&gt; 를 재귀 적으로 호출합니다 . 확장은 다음과 같이 서브 루틴 또는 재귀 단계 중 하나에 연결하여 추가 최적화 또는 수정을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d7bbafed59a27c1513d780d5e784c2a12ef1dc5" translate="yes" xml:space="preserve">
          <source>People frequently expect it to work like this. So it does.</source>
          <target state="translated">사람들은 종종 이와 같이 작동하기를 기대합니다. 그렇습니다.</target>
        </trans-unit>
        <trans-unit id="bc1de57d7a939bd26a67e8c9562637156f53e824" translate="yes" xml:space="preserve">
          <source>People have a hard time remembering that some functions default to $_, or @ARGV, or whatever, but that others which you might expect to do not.</source>
          <target state="translated">사람들은 일부 함수는 기본적으로 $ _, @ARGV 또는 그 밖의 모든 것을 기억하지만 어려움을 겪을 것으로 생각하는 것을 기억하기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="af3c23d7810d9feb567b332e5161af8d9bd9f452" translate="yes" xml:space="preserve">
          <source>People like to see their strings nicely sorted--or as Unicode parlance goes, collated. But again, what do you mean by collate?</source>
          <target state="translated">사람들은 문자열이 멋지게 정렬되어 있거나 유니 코드 어법에 따라 정렬되는 것을보고 싶어합니다. 그러나 다시 한 번 collate는 무엇을 의미합니까?</target>
        </trans-unit>
        <trans-unit id="895626deb1f05ce05a822ae049fef844846a6710" translate="yes" xml:space="preserve">
          <source>People sometimes point out that &lt;a href=&quot;../db_file&quot;&gt;DB_File&lt;/a&gt; will do something similar, and ask why &lt;code&gt;Tie::File&lt;/code&gt; module is necessary.</source>
          <target state="translated">사람들은 때때로 &lt;a href=&quot;../db_file&quot;&gt;DB_File&lt;/a&gt; 이 비슷한 것을 할 것이라고 지적하고 왜 &lt;code&gt;Tie::File&lt;/code&gt; 모듈이 필요한지 묻습니다 .</target>
        </trans-unit>
        <trans-unit id="99dcc00aba3ea5fec8f203b99f7aa0dc52bd345a" translate="yes" xml:space="preserve">
          <source>Per default all untar operations are done with the perl module Archive::Tar; by setting this variable to true the external tar command is used if available; on Unix this is usually preferred because they have a reliable and fast gnutar implementation.</source>
          <target state="translated">기본적으로 모든 untar 작업은 perl 모듈 Archive :: Tar; 이 변수를 true로 설정하면 사용 가능한 경우 외부 tar 명령이 사용됩니다. 유닉스에서는 이것이 안정적이고 빠른 gnutar 구현을 가지고 있기 때문에 일반적으로 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="c4f661f9e3bbabdfe8977d8e07c04f728f007afa" translate="yes" xml:space="preserve">
          <source>Per-Interpreter Variables</source>
          <target state="translated">통역사 변수</target>
        </trans-unit>
        <trans-unit id="2559c9f59f217f32b3e891e1ab6877c4f55356cc" translate="yes" xml:space="preserve">
          <source>Per-instance Data</source>
          <target state="translated">인스턴스 별 데이터</target>
        </trans-unit>
        <trans-unit id="637c16442a8f555cae097e71247c5fc7ee45adfd" translate="yes" xml:space="preserve">
          <source>Per-instance flag bits</source>
          <target state="translated">인스턴스 별 플래그 비트</target>
        </trans-unit>
        <trans-unit id="24a428fdaa34dbb9d25a2ae2897474ba4a8b3383" translate="yes" xml:space="preserve">
          <source>Perceptive Perl hackers may have noticed that a &lt;code&gt;for&lt;/code&gt; loop has a return value, and that this value can be captured by wrapping the loop in a &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; block. The reward for this discovery is this cautionary advice: The return value of a &lt;code&gt;for&lt;/code&gt; loop is unspecified and may change without notice. Do not rely on it.</source>
          <target state="translated">Perlive Perl 해커들은 &lt;code&gt;for&lt;/code&gt; 루프가 리턴 값을 가지고 있으며이 값을 루프를 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 블록 으로 감싸서 캡처 할 수 있음을 알 수 있습니다 . 이 발견에 대한 보상은 다음과 같은주의 사항입니다. &lt;code&gt;for&lt;/code&gt; 루프 의 반환 값 은 지정되지 않으며 예고없이 변경 될 수 있습니다. 그것에 의존하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="2c46ae69f753cf6246720edd2c4a9cebd27597f5" translate="yes" xml:space="preserve">
          <source>Perform cache scanning ('atstart', 'atexit' or 'never')?</source>
          <target state="translated">캐시 검색을 수행합니까 ( 'atstart', 'atexit'또는 'never')?</target>
        </trans-unit>
        <trans-unit id="c63fc543a09237e1df38dff5523874d7739bd5c9" translate="yes" xml:space="preserve">
          <source>Perform sorting on one type of platform only.</source>
          <target state="translated">한 가지 유형의 플랫폼에서만 정렬을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="c27007b93a4bc1c8de4cbbfbb0c5571ba69e57a4" translate="yes" xml:space="preserve">
          <source>Perform the equivalent of &lt;code&gt;&lt;a href=&quot;../functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; on the array.</source>
          <target state="translated">어레이 에서 &lt;code&gt;&lt;a href=&quot;../functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; 에 해당하는 작업을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="f4070651c463f5c50952530e94f62331111d1bf1" translate="yes" xml:space="preserve">
          <source>Perform the equivalent of &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; on the array.</source>
          <target state="translated">어레이 에서 &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; 에 해당하는 작업을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="64184a2388a7346fec59e49f0f94873466b15963" translate="yes" xml:space="preserve">
          <source>Perform whatever actions the command line args specified. The &lt;code&gt;prove&lt;/code&gt; command line tool consists of the following code:</source>
          <target state="translated">명령 행이 지정한 조치를 수행하십시오. 는 &lt;code&gt;prove&lt;/code&gt; 명령 줄 도구는 다음과 같은 코드로 구성</target>
        </trans-unit>
        <trans-unit id="0cb883fc85b1fd84aaebb7319c682c586a065641" translate="yes" xml:space="preserve">
          <source>Performance considerations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b696788f6758fff45816e3f44d267110dbc7d28" translate="yes" xml:space="preserve">
          <source>Performance issues</source>
          <target state="translated">성능 문제</target>
        </trans-unit>
        <trans-unit id="75fbc5c30da07f1356bcf407f1026c09ad8550fb" translate="yes" xml:space="preserve">
          <source>Performance testing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9a7e43f70de19f613749fe02de0e154833f44cd" translate="yes" xml:space="preserve">
          <source>Performing Perl pattern matches and substitutions from your C program</source>
          <target state="translated">C 프로그램에서 Perl 패턴 일치 및 대체 수행</target>
        </trans-unit>
        <trans-unit id="b82005b8824a2b9aeaec337d4f6692160e086478" translate="yes" xml:space="preserve">
          <source>Performs a callback to the Perl sub whose name is in the SV. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">이름이 SV에있는 Perl 서브에 콜백을 수행합니다. &lt;a href=&quot;perlcall&quot;&gt;perlcall을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c9a6e4b7d6eb6de9cfa7c1c05de09156f5313aec" translate="yes" xml:space="preserve">
          <source>Performs a callback to the specified Perl method. The blessed object must be on the stack. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">지정된 Perl 메소드에 대한 콜백을 수행합니다. 축복받은 물건이 쌓여 있어야합니다. &lt;a href=&quot;perlcall&quot;&gt;perlcall을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7f3fb532eda4a585d8b90e5f5df9aa47f234c3a5" translate="yes" xml:space="preserve">
          <source>Performs a callback to the specified Perl sub. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">지정된 Perl 서브에 대한 콜백을 수행합니다. &lt;a href=&quot;perlcall&quot;&gt;perlcall을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="49600604ba37ec7bb2caf7fae02578e1f3fb4be1" translate="yes" xml:space="preserve">
          <source>Performs a callback to the specified named and package-scoped Perl subroutine with &lt;code&gt;argv&lt;/code&gt; (a NULL-terminated array of strings) as arguments. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">인수 로 &lt;code&gt;argv&lt;/code&gt; (NULL로 끝나는 문자열 배열) 를 사용하여 지정된 명명 된 패키지 범위 Perl 서브 루틴에 대한 콜백을 수행합니다 . &lt;a href=&quot;perlcall&quot;&gt;perlcall을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ada148fba94bb82b7e37d39db36e65570e59f9e9" translate="yes" xml:space="preserve">
          <source>Performs an &lt;code&gt;hv_iternext&lt;/code&gt; , &lt;code&gt;hv_iterkey&lt;/code&gt; , and &lt;code&gt;hv_iterval&lt;/code&gt; in one operation.</source>
          <target state="translated">수행하는 &lt;code&gt;hv_iternext&lt;/code&gt; , &lt;code&gt;hv_iterkey&lt;/code&gt; 및 &lt;code&gt;hv_iterval&lt;/code&gt; 하나의 작업이다.</target>
        </trans-unit>
        <trans-unit id="08fa9ec15a0ad6b718fdf2229eda1c22f6e3ebcd" translate="yes" xml:space="preserve">
          <source>Performs some preprocessing to the string to ensure that it has the correct characteristics of a version. Flags the object if it contains an underscore (which denotes this is an alpha version). The boolean qv denotes that the version should be interpreted as if it had multiple decimals, even if it doesn't.</source>
          <target state="translated">문자열의 일부 전처리를 수행하여 버전의 올바른 특성을 갖도록합니다. 밑줄 (알파 버전임을 나타냄)이 포함 된 객체를 표시합니다. 부울 qv는 버전이 소수가 아닌 경우에도 버전이 여러 개의 소수를 갖는 것처럼 해석되어야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8509e18df89af9b03f62a1a48a7b2cabc5f8fb27" translate="yes" xml:space="preserve">
          <source>Performs the default fixup of the arguments part of an &lt;code&gt;entersub&lt;/code&gt; op tree. This consists of applying list context to each of the argument ops. This is the standard treatment used on a call marked with &lt;code&gt;&amp;amp;&lt;/code&gt; , or a method call, or a call through a subroutine reference, or any other call where the callee can't be identified at compile time, or a call where the callee has no prototype.</source>
          <target state="translated">&lt;code&gt;entersub&lt;/code&gt; op 트리 에서 인수 부분의 기본 수정을 수행합니다 . 이는 각 인수 op에 목록 컨텍스트를 적용하는 것으로 구성됩니다. 이는 &lt;code&gt;&amp;amp;&lt;/code&gt; 로 표시된 통화, 메소드 호출 또는 서브 루틴 참조를 통한 호출 또는 컴파일 타임에 수신자를 식별 할 수없는 다른 호출 또는 수신자가없는 호출에 사용되는 표준 처리입니다. 원기.</target>
        </trans-unit>
        <trans-unit id="f72b3c1a72c8131e9de33c78c73bf05b880137dc" translate="yes" xml:space="preserve">
          <source>Performs the fixup of the arguments part of an &lt;code&gt;entersub&lt;/code&gt; op tree based on a subroutine prototype. This makes various modifications to the argument ops, from applying context up to inserting &lt;code&gt;refgen&lt;/code&gt; ops, and checking the number and syntactic types of arguments, as directed by the prototype. This is the standard treatment used on a subroutine call, not marked with &lt;code&gt;&amp;amp;&lt;/code&gt; , where the callee can be identified at compile time and has a prototype.</source>
          <target state="translated">서브 루틴 프로토 타입을 기반으로 &lt;code&gt;entersub&lt;/code&gt; op 트리 의 인수 부분의 수정을 수행합니다 . 이는 프로토 타입의 지시에 따라 컨텍스트 적용부터 &lt;code&gt;refgen&lt;/code&gt; op 삽입 , 인수의 수와 구문 유형 확인 등 인수 ops를 다양하게 수정합니다 . 이는 &lt;code&gt;&amp;amp;&lt;/code&gt; 로 표시되지 않은 서브 루틴 호출에 사용되는 표준 처리 로, 호출시 수신자를 식별 할 수 있고 프로토 타입이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6157a20bbb392600596ac64ab923dad03e358522" translate="yes" xml:space="preserve">
          <source>Performs the fixup of the arguments part of an &lt;code&gt;entersub&lt;/code&gt; op tree either based on a subroutine prototype or using default list-context processing. This is the standard treatment used on a subroutine call, not marked with &lt;code&gt;&amp;amp;&lt;/code&gt; , where the callee can be identified at compile time.</source>
          <target state="translated">서브 루틴 프로토 타입을 기반으로하거나 기본 목록 컨텍스트 처리를 사용하여 &lt;code&gt;entersub&lt;/code&gt; op 트리 의 인수 부분의 수정을 수행합니다 . 이는 &lt;code&gt;&amp;amp;&lt;/code&gt; 로 표시되지 않은 서브 루틴 호출에 사용되는 표준 처리 방식으로, 컴파일 시점에 수신자를 식별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="710b350b3985543df26a6fea7ac3e9557988bb88" translate="yes" xml:space="preserve">
          <source>Perhaps the most common mistake programmers make is to attempt to optimize their code before a program actually does anything useful - this is a bad idea. There's no point in having an extremely fast program that doesn't work. The first job is to get a program to</source>
          <target state="translated">프로그래머가 가장 흔히 저지르는 실수는 프로그램이 실제로 유용한 작업을 수행하기 전에 코드를 최적화하는 것입니다. 이것은 나쁜 생각입니다. 작동하지 않는 매우 빠른 프로그램을 가질 필요는 없습니다. 첫 번째 일은 프로그램을 얻는 것입니다</target>
        </trans-unit>
        <trans-unit id="f111d810e7ca920bda8f128569fc002610c45314" translate="yes" xml:space="preserve">
          <source>Perl</source>
          <target state="translated">Perl</target>
        </trans-unit>
        <trans-unit id="c1f70e71f78a6960e6bfc54f17ed9725d674c2b0" translate="yes" xml:space="preserve">
          <source>Perl 5 Documentation</source>
          <target state="translated">Perl 5 설명서</target>
        </trans-unit>
        <trans-unit id="8f5e9c26fdc65b3f883a3cb850a843ffd41fb0f9" translate="yes" xml:space="preserve">
          <source>Perl 5 Porters</source>
          <target state="translated">펄 5 포터</target>
        </trans-unit>
        <trans-unit id="142bd9030035d40d81779a4f9a904554905faa01" translate="yes" xml:space="preserve">
          <source>Perl 5 has extension mechanisms, modules and XS, specifically to avoid the need to keep changing the Perl interpreter. You can write modules that export functions, you can give those functions prototypes so they can be called like built-in functions, you can even write XS code to mess with the runtime data structures of the Perl interpreter if you want to implement really complicated things.</source>
          <target state="translated">Perl 5에는 확장 메커니즘, 모듈 및 XS가 있으며 특히 Perl 인터프리터를 계속 변경하지 않아도됩니다. 함수를 내보내는 모듈을 작성할 수 있고, 함수 프로토 타입을 제공하여 내장 함수처럼 호출 할 수 있습니다. XS 코드를 작성하여 Perl 인터프리터의 런타임 데이터 구조를 혼란스럽게 만들 수도 있습니다. .</target>
        </trans-unit>
        <trans-unit id="365a603ab08b813cf9c586a16f80eeba34a1d121" translate="yes" xml:space="preserve">
          <source>Perl 5 is developed by a community, not a corporate entity. Every change contributed to the Perl core is the result of a donation. Typically, these donations are contributions of code or time by individual members of our community. On occasion, these donations come in the form of corporate or organizational sponsorship of a particular individual or project.</source>
          <target state="translated">Perl 5는 기업체가 아닌 커뮤니티에 의해 개발되었습니다. 펄 코어에 기여한 모든 변화는 기부의 결과입니다. 일반적으로 이러한 기부는 지역 사회의 개별 구성원이 코드 또는 시간을 기증 한 것입니다. 때때로, 이러한 기부는 특정 개인 또는 프로젝트에 대한 기업 또는 조직의 후원 형태로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="c7abcac9fa9f634d755f347614a5c92a44d2c3e5" translate="yes" xml:space="preserve">
          <source>Perl 5 was successfully compiled and tested on:</source>
          <target state="translated">Perl 5가 성공적으로 컴파일 및 테스트되었습니다 :</target>
        </trans-unit>
        <trans-unit id="c7ebebb63cc5cd6e093751f9acf8676fc8362950" translate="yes" xml:space="preserve">
          <source>Perl 5.10 added three specials, &lt;code&gt;${^MATCH}&lt;/code&gt; , &lt;code&gt;${^PREMATCH}&lt;/code&gt; , and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; to do the same job but without the global performance penalty. Perl 5.10 only sets these variables if you compile or execute the regular expression with the &lt;code&gt;/p&lt;/code&gt; modifier.</source>
          <target state="translated">Perl 5.10 은 글로벌 성능 저하없이 동일한 작업을 수행하기 위해 &lt;code&gt;${^MATCH}&lt;/code&gt; , &lt;code&gt;${^PREMATCH}&lt;/code&gt; 및 &lt;code&gt;${^POSTMATCH}&lt;/code&gt; 세 가지 스페셜을 추가했습니다 . Perl 5.10은 &lt;code&gt;/p&lt;/code&gt; 수정자를 사용하여 정규식을 컴파일하거나 실행하는 경우에만 이러한 변수를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="ce44e09ff142e65fee17e89d97567bf27f5d29b1" translate="yes" xml:space="preserve">
          <source>Perl 5.10 also introduced named capture groups and named backreferences. To attach a name to a capturing group, you write either &lt;code&gt;(?&amp;lt;name&amp;gt;...)&lt;/code&gt; or &lt;code&gt;(?'name'...)&lt;/code&gt;. The backreference may then be written as &lt;code&gt;\g{name}&lt;/code&gt; . It is permissible to attach the same name to more than one group, but then only the leftmost one of the eponymous set can be referenced. Outside of the pattern a named capture group is accessible through the &lt;code&gt;%+&lt;/code&gt; hash.</source>
          <target state="translated">Perl 5.10은 또한 명명 된 캡처 그룹과 명명 된 역 참조를 도입했습니다. 캡처 그룹에 이름을 첨부하려면 &lt;code&gt;(?&amp;lt;name&amp;gt;...)&lt;/code&gt; 또는 &lt;code&gt;(?'name'...)&lt;/code&gt; . 역 참조는 &lt;code&gt;\g{name}&lt;/code&gt; 으로 작성 될 수 있습니다 . 동일한 이름을 둘 이상의 그룹에 첨부 할 수 있지만 가장 왼쪽의 시조 세트 만 참조 할 수 있습니다. 패턴 외부에서 명명 된 캡처 그룹은 &lt;code&gt;%+&lt;/code&gt; 해시를 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d78bc07daf7287cd2d82e764c55679c183debb95" translate="yes" xml:space="preserve">
          <source>Perl 5.10 introduced a number of control verbs intended to provide detailed control over the backtracking process, by directly influencing the regexp engine and by providing monitoring techniques. As all the features in this group are experimental and subject to change or removal in a future version of Perl, the interested reader is referred to &lt;a href=&quot;perlre#Special-Backtracking-Control-Verbs&quot;&gt;Special Backtracking Control Verbs in perlre&lt;/a&gt; for a detailed description.</source>
          <target state="translated">Perl 5.10은 정규식 엔진에 직접 영향을 미치고 모니터링 기술을 제공함으로써 역 추적 프로세스에 대한 세부적인 제어를 제공하기위한 많은 제어 동사를 도입했습니다. 이 그룹의 모든 기능은 실험적이며 향후 Perl 버전에서 변경 또는 제거 될 예정이므로 자세한 설명 은 관심있는 독자 &lt;a href=&quot;perlre#Special-Backtracking-Control-Verbs&quot;&gt;를 perlre의 특수 역 추적 제어 동사로&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d8fc66ff20f940e5def5d5b04e16e404fe2d5094" translate="yes" xml:space="preserve">
          <source>Perl 5.12 an newer is not compatible with the IBM fileset perl.libext.</source>
          <target state="translated">Perl 5.12 최신 버전은 IBM 파일 세트 perl.libext와 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ea53addd5f513ae8ff9630b1ab8b434a441c0d82" translate="yes" xml:space="preserve">
          <source>Perl 5.16 introduced a slightly more efficient mechanism that notes separately whether each of &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; , and &lt;code&gt;$'&lt;/code&gt; have been seen, and thus may only need to copy part of the string. Perl 5.20 introduced a much more efficient copy-on-write mechanism which eliminates any slowdown.</source>
          <target state="translated">Perl 5.16에서는 &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; 및 &lt;code&gt;$'&lt;/code&gt; 각각이 표시되는지 여부를 별도로 기록하는 약간 더 효율적인 메커니즘을 도입 하여 문자열의 일부만 복사하면됩니다. Perl 5.20은 속도를 늦추지 않는 훨씬 효율적인 복사 중 복사 메커니즘을 도입했습니다.</target>
        </trans-unit>
        <trans-unit id="ecdd633a06acc3333c70644f93001a3679676523" translate="yes" xml:space="preserve">
          <source>Perl 5.18 introduced a new class, B::PADLIST, returned by B::CV's &lt;code&gt;PADLIST&lt;/code&gt; method.</source>
          <target state="translated">Perl 5.18은 B :: CV의 &lt;code&gt;PADLIST&lt;/code&gt; 메소드에 의해 리턴되는 새로운 클래스 B :: PADLIST를 도입했습니다 .</target>
        </trans-unit>
        <trans-unit id="6b567ee259b41361a0ad9018ea4088cb70239efc" translate="yes" xml:space="preserve">
          <source>Perl 5.22 also introduces the experimental &quot;const&quot; attribute as an alternative. (Disable the &quot;experimental::const_attr&quot; warnings if you want to use it.) When applied to an anonymous subroutine, it forces the sub to be called when the &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; expression is evaluated. The return value is captured and turned into a constant subroutine:</source>
          <target state="translated">Perl 5.22는 실험적인 &quot;const&quot;속성을 대안으로 소개합니다. (사용하려는 경우 &quot;experimental :: const_attr&quot;경고를 비활성화하십시오.) 익명 서브 루틴에 적용되면 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 표현식이 평가 될 때 서브가 강제로 호출됩니다 . 리턴 값이 캡처되어 일정한 서브 루틴으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="cf5bb1f9d37da5d5c2d35eb2fe5db684768a1718" translate="yes" xml:space="preserve">
          <source>Perl 5.22 introduced the B::PADNAMELIST and B::PADNAME classes.</source>
          <target state="translated">Perl 5.22는 B :: PADNAMELIST 및 B :: PADNAME 클래스를 도입했습니다.</target>
        </trans-unit>
        <trans-unit id="2c423e3fdc417abd5c0a870160561ad280c5b05c" translate="yes" xml:space="preserve">
          <source>Perl 5.6 added support for Unicode characters with code points &amp;gt; 255, and Perl 5.8 has full support for Unicode characters in hash keys. Perl internally encodes strings with these characters using utf8, and Storable serializes them as utf8. By default, if an older version of Perl encounters a utf8 value it cannot represent, it will &lt;code&gt;croak()&lt;/code&gt; . To change this behaviour so that Storable deserializes utf8 encoded values as the string of bytes (effectively dropping the</source>
          <target state="translated">Perl 5.6은 코드 포인트가 255보다 큰 유니 코드 문자에 대한 지원을 추가했으며 Perl 5.8은 해시 키의 유니 코드 문자를 완벽하게 지원합니다. Perl은 utf8을 사용하여 이러한 문자로 문자열을 내부적으로 인코딩하고 Storable은 문자열을 utf8로 직렬화합니다. 기본적으로, 이전 버전의 Perl이 나타낼 수없는 utf8 값을 발견하면 &lt;code&gt;croak()&lt;/code&gt; 됩니다. Storable이 utf8로 인코딩 된 값을 바이트 문자열로 deserialize하도록이 동작을 변경하려면</target>
        </trans-unit>
        <trans-unit id="4d666cc8f0c2aafb781a5c3ee7854aa462c22563" translate="yes" xml:space="preserve">
          <source>Perl 5.6 and earlier used a quicksort algorithm to implement sort. That algorithm was not stable, so</source>
          <target state="translated">Perl 5.6 및 이전 버전에서는 정렬을 구현하기 위해 빠른 정렬 알고리즘을 사용했습니다. 그 알고리즘은 안정적이지 않아서</target>
        </trans-unit>
        <trans-unit id="cc23cb198586dd32a543690c051c8df0366d1085" translate="yes" xml:space="preserve">
          <source>Perl 5.6 lets you write binary numbers directly with the &lt;code&gt;0b&lt;/code&gt; notation:</source>
          <target state="translated">Perl 5.6에서는 &lt;code&gt;0b&lt;/code&gt; 표기법으로 이진 숫자를 직접 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="45926b613d53010c55908af141dded6cf0223b03" translate="yes" xml:space="preserve">
          <source>Perl 5.6.0 introduced Unicode support. It's important for porters and XS writers to understand this support and make sure that the code they write does not corrupt Unicode data.</source>
          <target state="translated">Perl 5.6.0은 유니 코드 지원을 도입했습니다. 포터와 XS 작성자가이 지원을 이해하고 작성하는 코드가 유니 코드 데이터를 손상시키지 않는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="d766774f1389bd4f4ba4c170949b6d3cfbd45c53" translate="yes" xml:space="preserve">
          <source>Perl 5.6.x introduced the ability to optional configure the perl interpreter to use C's &lt;code&gt;long long&lt;/code&gt; type to allow scalars to store 64 bit integers on 32 bit systems. However, due to the way the Perl configuration system generated the C configuration files on non-Windows platforms, and the way Storable generates its header, nothing in the Storable file header reflected whether the perl writing was using 32 or 64 bit integers, despite the fact that Storable was storing some data differently in the file. Hence Storable running on perl with 64 bit integers will read the header from a file written by a 32 bit perl, not realise that the data is actually in a subtly incompatible format, and then go horribly wrong (possibly crashing) if it encountered a stored integer. This is a design failure.</source>
          <target state="translated">Perl 5.6.x는 스칼라가 32 비트 시스템에 64 비트 정수를 저장할 수 있도록 C의 &lt;code&gt;long long&lt;/code&gt; 유형을 사용하도록 perl 인터프리터를 선택적으로 구성하는 기능을 도입했습니다 . 그러나 Perl 구성 시스템이 Windows 이외의 플랫폼에서 C 구성 파일을 생성하는 방식과 Storable이 헤더를 생성하는 방식으로 인해 Storable 파일 헤더에는 Perl 쓰기가 32 비트 또는 64 비트 정수를 사용하는지 여부가 반영되지 않았습니다. Storable이 일부 데이터를 파일에 다르게 저장했다는 사실. 따라서 64 비트 정수로 perl에서 실행 가능한 Storable은 32 비트 perl로 작성된 파일에서 헤더를 읽습니다. 데이터가 실제로 호환되지 않는 형식이라는 것을 알지 못하고 저장된 경우 정수. 이것은 설계 실패입니다.</target>
        </trans-unit>
        <trans-unit id="85ca30a6ededa148e4bfea0d2618456fe4f02a72" translate="yes" xml:space="preserve">
          <source>Perl 5.8 adds support for restricted hashes, which have keys restricted to a given set, and can have values locked to be read only. By default, when Storable encounters a restricted hash on a perl that doesn't support them, it will deserialize it as a normal hash, silently discarding any placeholder keys and leaving the keys and all values unlocked. To make Storable &lt;code&gt;croak()&lt;/code&gt; instead, set &lt;code&gt;$Storable::downgrade_restricted&lt;/code&gt; to a &lt;code&gt;FALSE&lt;/code&gt; value. To restore the default set it back to some &lt;code&gt;TRUE&lt;/code&gt; value.</source>
          <target state="translated">Perl 5.8은 키가 지정된 세트로 제한되어 있고 읽기 전용으로 잠긴 값을 가질 수있는 제한된 해시에 대한 지원을 추가합니다. 기본적으로 Storable은이를 지원하지 않는 펄에서 제한된 해시를 만나면 일반 해시로 역 직렬화하여 자리 표시 자 키를 자동으로 버리고 키와 모든 값을 잠금 해제 상태로 둡니다. 대신 Storable &lt;code&gt;croak()&lt;/code&gt; 를 만들려면 &lt;code&gt;$Storable::downgrade_restricted&lt;/code&gt; 를 &lt;code&gt;FALSE&lt;/code&gt; 값으로 설정하십시오. 기본값을 복원하려면 다시 &lt;code&gt;TRUE&lt;/code&gt; 값 으로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="565a4d4fa800ce5182da9b6ba981e8a739829623" translate="yes" xml:space="preserve">
          <source>Perl 5.8.0 added support for Unicode on EBCDIC platforms. This support was allowed to lapse in later releases, but was revived in 5.22. Unicode support is somewhat more complex to implement since additional conversions are needed. See &lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt; for more information.</source>
          <target state="translated">Perl 5.8.0은 EBCDIC 플랫폼에서 유니 코드에 대한 지원을 추가했습니다. 이 지원은 이후 릴리스에서 없어 질 수 있었지만 5.22에서 부활했습니다. 추가 변환이 필요하므로 유니 코드 지원은 구현하기가 다소 복잡합니다. 자세한 정보는 &lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1d3bf07733afdb8eccda724369492b44b06d3912" translate="yes" xml:space="preserve">
          <source>Perl 5.8.0 and later avoid these problems by &quot;deferring&quot; signals. That is, when the signal is delivered to the process by the system (to the C code that implements Perl) a flag is set, and the handler returns immediately. Then at strategic &quot;safe&quot; points in the Perl interpreter (e.g. when it is about to execute a new opcode) the flags are checked and the Perl level handler from %SIG is executed. The &quot;deferred&quot; scheme allows much more flexibility in the coding of signal handlers as we know the Perl interpreter is in a safe state, and that we are not in a system library function when the handler is called. However the implementation does differ from previous Perls in the following ways:</source>
          <target state="translated">Perl 5.8.0 이상은 신호를 &quot;지연&quot;하여 이러한 문제를 방지합니다. 즉, 신호가 시스템에 의해 프로세스 (Perl을 구현하는 C 코드로)에 전달되면 플래그가 설정되고 핸들러는 즉시 리턴합니다. 그런 다음 Perl 인터프리터의 전략적인 &quot;안전한&quot;지점 (예 : 새 opcode를 실행하려고 할 때)에서 플래그를 확인하고 % SIG의 Perl 레벨 핸들러를 실행합니다. &quot;지연된 (deferred)&quot;체계는 Perl 인터프리터가 안전한 상태에 있고 핸들러가 호출 될 때 시스템 라이브러리 함수에 있지 않다는 것을 알기 때문에 신호 핸들러의 코딩에 훨씬 더 많은 유연성을 허용합니다. 그러나 다음과 같은 점에서 구현이 이전 Perls와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="e73fd9ce0c7c872add12735883aa527cd3cbf5df" translate="yes" xml:space="preserve">
          <source>Perl 5.8.0 or later</source>
          <target state="translated">Perl 5.8.0 이상</target>
        </trans-unit>
        <trans-unit id="4e8757ee96021b145f4cb52d1033c040338543b5" translate="yes" xml:space="preserve">
          <source>Perl 6 is a reinvention of Perl, it is a language in the same lineage but not compatible. The two are complementary, not mutually exclusive. Perl 6 is not meant to replace Perl 5, and vice versa. See &lt;a href=&quot;#What-is-Perl-6%3f&quot;&gt;What is Perl 6?&lt;/a&gt; below to find out more.</source>
          <target state="translated">Perl 6은 Perl의 재발 명입니다. 동일한 계보의 언어이지만 호환되지는 않습니다. 이 둘은 상호 배타적이지 않고 상호 보완 적입니다. Perl 6은 Perl 5를 대체하지 않으며 그 반대도 마찬가지입니다. 참조 &lt;a href=&quot;#What-is-Perl-6%3f&quot;&gt;펄 6은 무엇입니까? &lt;/a&gt;자세한 내용은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="70eed57e9021b8ec1bdc60c299cf0007c990e85c" translate="yes" xml:space="preserve">
          <source>Perl 6 was</source>
          <target state="translated">펄 6은</target>
        </trans-unit>
        <trans-unit id="c935317046cb2fe37bcb5104606c71edb33387e0" translate="yes" xml:space="preserve">
          <source>Perl &lt;b&gt;borrows syntax&lt;/b&gt; and concepts from many languages: awk, sed, C, Bourne Shell, Smalltalk, Lisp and even English. Other languages have borrowed syntax from Perl, particularly its regular expression extensions. So if you have programmed in another language you will see familiar pieces in Perl. They often work the same, but see &lt;a href=&quot;perltrap&quot;&gt;perltrap&lt;/a&gt; for information about how they differ.</source>
          <target state="translated">Perl &lt;b&gt;은&lt;/b&gt; awk, sed, C, Bourne Shell, Smalltalk, Lisp 및 영어와 같은 여러 언어에서 &lt;b&gt;구문&lt;/b&gt; 과 개념을 &lt;b&gt;빌 렸습니다&lt;/b&gt; . 다른 언어는 Perl에서 구문, 특히 정규 표현식 확장을 빌 렸습니다. 따라서 다른 언어로 프로그래밍 한 경우 Perl에 익숙한 조각이 표시됩니다. 그들은 종종 동일하게 작동하지만 &lt;a href=&quot;perltrap&quot;&gt;차이점에&lt;/a&gt; 대한 정보는 perltrap 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a37780bb487077495edf8f34f760c1da9044ebae" translate="yes" xml:space="preserve">
          <source>Perl API not supported by ppport.h</source>
          <target state="translated">ppport.h가 지원하지 않는 Perl API</target>
        </trans-unit>
        <trans-unit id="5b7471df455475e2c7d2175b53792162c97edfe3" translate="yes" xml:space="preserve">
          <source>Perl Authors Upload Server. Contains links to information for module authors.</source>
          <target state="translated">Perl Authors 업로드 서버. 모듈 작성자를위한 정보에 대한 링크가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bf74964bb9b0e9e3d4da81f0703933934a7c358" translate="yes" xml:space="preserve">
          <source>Perl Best Practices</source>
          <target state="translated">펄 베스트 프랙티스</target>
        </trans-unit>
        <trans-unit id="2cc43b42e51a4a8837fffe3af550658174edb610" translate="yes" xml:space="preserve">
          <source>Perl Books</source>
          <target state="translated">펄 북</target>
        </trans-unit>
        <trans-unit id="a3a9e748e5c4dd7f9dfa7cc95a251e60be896a8f" translate="yes" xml:space="preserve">
          <source>Perl Classes</source>
          <target state="translated">펄 클래스</target>
        </trans-unit>
        <trans-unit id="e482403a1124e0521d166c90c8a0769c85673b5e" translate="yes" xml:space="preserve">
          <source>Perl Cookbook</source>
          <target state="translated">펄 요리 책</target>
        </trans-unit>
        <trans-unit id="d4efb54c65e7e3af46d13e87c7581a8dcba624d0" translate="yes" xml:space="preserve">
          <source>Perl DLL</source>
          <target state="translated">펄 DLL</target>
        </trans-unit>
        <trans-unit id="3283f18cd28cbde0549accd86697398505934bb4" translate="yes" xml:space="preserve">
          <source>Perl Editor by EngInSite is a complete integrated development environment (IDE) for creating, testing, and debugging Perl scripts; the tool runs on Windows 9x/NT/2000/XP or later.</source>
          <target state="translated">EngInSite의 Perl Editor는 Perl 스크립트 작성, 테스트 및 디버깅을위한 완벽한 통합 개발 환경 (IDE)입니다. 이 도구는 Windows 9x / NT / 2000 / XP 이상에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="7ac9d4c93ef979889b211c88f596e981156f45f4" translate="yes" xml:space="preserve">
          <source>Perl Extensions</source>
          <target state="translated">펄 확장</target>
        </trans-unit>
        <trans-unit id="f71fad82087d419a133c0dced88c67e1f9877063" translate="yes" xml:space="preserve">
          <source>Perl FAQ</source>
          <target state="translated">펄 FAQ</target>
        </trans-unit>
        <trans-unit id="da7c8c4aaafde8c9b2e5f84c7552444fbb08c636" translate="yes" xml:space="preserve">
          <source>Perl Fails Because Of Unresolved Symbol sockatmark</source>
          <target state="translated">해결되지 않은 기호 sockatmark로 인해 Perl이 실패 함</target>
        </trans-unit>
        <trans-unit id="7c3d43451e7cda778a3f9c97b52abf3fd44bedb9" translate="yes" xml:space="preserve">
          <source>Perl Functions by Category</source>
          <target state="translated">카테고리 별 펄 함수</target>
        </trans-unit>
        <trans-unit id="920e14089fbbc423ee2d5724c1de68632aef3813" translate="yes" xml:space="preserve">
          <source>Perl GNU Info Files on AmigaOS</source>
          <target state="translated">AmigaOS의 Perl GNU 정보 파일</target>
        </trans-unit>
        <trans-unit id="37de2a8ad505f52fcef06a6993c850291e480520" translate="yes" xml:space="preserve">
          <source>Perl HTML Documentation on AmigaOS</source>
          <target state="translated">AmigaOS에 대한 Perl HTML 문서</target>
        </trans-unit>
        <trans-unit id="05eb1caf8706fb276d9b12087337d5c6103138c5" translate="yes" xml:space="preserve">
          <source>Perl LaTeX Documentation on AmigaOS</source>
          <target state="translated">AmigaOS에 대한 Perl LaTeX 문서</target>
        </trans-unit>
        <trans-unit id="91a43bc6de8b72c656ec8849bbbaebef043357f9" translate="yes" xml:space="preserve">
          <source>Perl Modules</source>
          <target state="translated">펄 모듈</target>
        </trans-unit>
        <trans-unit id="216d171ee4524430a28634ae1013da6c2f558efa" translate="yes" xml:space="preserve">
          <source>Perl Objects And C Structures</source>
          <target state="translated">펄 객체와 C 구조</target>
        </trans-unit>
        <trans-unit id="a472684894e509305085eced5d45bf35bf21cca5" translate="yes" xml:space="preserve">
          <source>Perl Smokers ( &lt;a href=&quot;http://www.nntp.perl.org/group/perl.daily-build/&quot;&gt;http://www.nntp.perl.org/group/perl.daily-build/&lt;/a&gt; and &lt;a href=&quot;http://www.nntp.perl.org/group/perl.daily-build.reports/&quot;&gt;http://www.nntp.perl.org/group/perl.daily-build.reports/&lt;/a&gt; ) automatically test Perl source releases on platforms with various configurations.</source>
          <target state="translated">Perl Smokers ( &lt;a href=&quot;http://www.nntp.perl.org/group/perl.daily-build/&quot;&gt;http://www.nntp.perl.org/group/perl.daily-build/&lt;/a&gt; 및 &lt;a href=&quot;http://www.nntp.perl.org/group/perl.daily-build.reports/&quot;&gt;http://www.nntp.perl.org/group/perl.daily-build.reports/&lt;/a&gt; ) 자동으로 Perl 테스트 다양한 구성의 플랫폼에서 소스 릴리스.</target>
        </trans-unit>
        <trans-unit id="a5b49734e895fa49b2262a8eac32c0a87b309e7f" translate="yes" xml:space="preserve">
          <source>Perl Source Filter</source>
          <target state="translated">펄 소스 필터</target>
        </trans-unit>
        <trans-unit id="d9385cb28cfa7ddf46c00b8a389aa72f1c3ecd2f" translate="yes" xml:space="preserve">
          <source>Perl Source Filter Utility Module</source>
          <target state="translated">펄 소스 필터 유틸리티 모듈</target>
        </trans-unit>
        <trans-unit id="11827d68497a169d041d5a9b84cc14e0b5402701" translate="yes" xml:space="preserve">
          <source>Perl Threads Are Not X Threads</source>
          <target state="translated">펄 스레드는 X 스레드가 아닙니다</target>
        </trans-unit>
        <trans-unit id="0d5f49a6432453dfdae5c9b853d5d2137d7a3d82" translate="yes" xml:space="preserve">
          <source>Perl Traps</source>
          <target state="translated">펄 트랩</target>
        </trans-unit>
        <trans-unit id="e81612c89b54aaefee5157e85c78728a2455e0ca" translate="yes" xml:space="preserve">
          <source>Perl XS' attempt at a solution to this is the concept of typemaps. At an abstract level, a Perl XS typemap is nothing but a recipe for converting from a certain Perl data structure to a certain C data structure and vice versa. Since there can be C types that are sufficiently similar to one another to warrant converting with the same logic, XS typemaps are represented by a unique identifier, henceforth called an &lt;b&gt;XS type&lt;/b&gt; in this document. You can then tell the XS compiler that multiple C types are to be mapped with the same XS typemap.</source>
          <target state="translated">Perl XS의 해결책은 타입 맵의 개념입니다. 추상적 인 수준에서 Perl XS 타입 맵은 특정 Perl 데이터 구조에서 특정 C 데이터 구조로 또는 그 반대로 변환하기위한 레시피 일뿐입니다. 동일한 논리로 변환하기 위해 서로 충분히 유사한 C 유형이있을 수 있으므로 &lt;b&gt;XS 유형&lt;/b&gt; 맵은 고유 식별자로 표시되므로이 문서 에서는 &lt;b&gt;XS 유형&lt;/b&gt; 이라고합니다 . 그런 다음 여러 C 유형이 동일한 XS 유형 맵으로 매핑되도록 XS 컴파일러에 알릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5aedddb9bed4a6f9cc4928e309c3362165c3d8aa" translate="yes" xml:space="preserve">
          <source>Perl actually inserts the following code:</source>
          <target state="translated">Perl은 실제로 다음 코드를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="0370590002494d49cbee29303986558b8c939d60" translate="yes" xml:space="preserve">
          <source>Perl actually stands for Pathologically Eclectic Rubbish Lister, but don't tell anyone I said that.</source>
          <target state="translated">펄은 실제로 병리학 적으로 절충 적 쓰레기 목록을 나타내지 만, 내가 말한 사람에게는 아무 것도 말하지 않는다.</target>
        </trans-unit>
        <trans-unit id="4ac1014663aa23e842df07d5739089aa502fbf6c" translate="yes" xml:space="preserve">
          <source>Perl adds magic to an SV using the sv_magic function:</source>
          <target state="translated">Perl은 sv_magic 함수를 사용하여 SV에 마법을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="c3b8bb4554b031723a2e07241fd747dea1d44323" translate="yes" xml:space="preserve">
          <source>Perl after 5.8.7 has support for the &lt;code&gt;CLONE_SKIP&lt;/code&gt; special subroutine. Like &lt;code&gt;CLONE&lt;/code&gt; , &lt;code&gt;CLONE_SKIP&lt;/code&gt; is called once per package; however, it is called just before cloning starts, and in the context of the parent thread. If it returns a true value, then no objects of that class will be cloned; or rather, they will be copied as unblessed, undef values. For example: if in the parent there are two references to a single blessed hash, then in the child there will be two references to a single undefined scalar value instead. This provides a simple mechanism for making a module threadsafe; just add &lt;code&gt;sub CLONE_SKIP { 1 }&lt;/code&gt; at the top of the class, and &lt;code&gt;DESTROY()&lt;/code&gt; will now only be called once per object. Of course, if the child thread needs to make use of the objects, then a more sophisticated approach is needed.</source>
          <target state="translated">5.8.7 이후의 Perl은 &lt;code&gt;CLONE_SKIP&lt;/code&gt; 특수 서브 루틴을 지원합니다 . 마찬가지로 &lt;code&gt;CLONE&lt;/code&gt; , &lt;code&gt;CLONE_SKIP&lt;/code&gt; 은 패키지에 한 번이라고합니다; 그러나 복제가 시작되기 직전 및 상위 스레드 컨텍스트에서 호출됩니다. true 값을 반환하면 해당 클래스의 개체가 복제되지 않습니다. 또는 오히려 축복되지 않은 undef 값으로 복사됩니다. 예를 들어, 부모에 단일 축복 해시에 대한 두 개의 참조가있는 경우 자식에는 정의되지 않은 단일 스칼라 값에 대한 두 개의 참조가 대신 사용됩니다. 이것은 모듈을 스레드로부터 안전하게 만드는 간단한 메커니즘을 제공합니다. 클래스 상단에 &lt;code&gt;sub CLONE_SKIP { 1 }&lt;/code&gt; 을 추가 하고 &lt;code&gt;DESTROY()&lt;/code&gt; 개체 당 한 번만 호출됩니다. 물론 자식 스레드가 객체를 사용해야하는 경우보다 정교한 접근 방식이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c3994bbd1bc4bb2e8469e1a722d815312e8adf0c" translate="yes" xml:space="preserve">
          <source>Perl allows multiple inheritance, which means that a class can inherit from multiple parents. While this is possible, we strongly recommend against it. Generally, you can use &lt;b&gt;roles&lt;/b&gt; to do everything you can do with multiple inheritance, but in a cleaner way.</source>
          <target state="translated">펄은 다중 상속을 허용하는데, 이는 클래스가 여러 부모로부터 상속받을 수 있음을 의미합니다. 이것이 가능하지만 반대하는 것이 좋습니다. 일반적으로 &lt;b&gt;역할&lt;/b&gt; 을 사용 하여 다중 상속으로 할 수있는 모든 작업을보다 깔끔하게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1876b83bb7cab17e23b16333856308b07e0072a3" translate="yes" xml:space="preserve">
          <source>Perl allows strings to contain a superset of Unicode code points, up to the limit of what is storable in an unsigned integer on your system, but these may not be accepted by other languages/systems. At one time, it was legal in some standards to have code points up to 0x7FFF_FFFF, but not higher. Code points above 0xFFFF_FFFF require larger than a 32 bit word.</source>
          <target state="translated">Perl은 문자열이 시스템의 부호없는 정수로 저장 가능한 것의 한계까지 유니 코드 코드 포인트의 수퍼 세트를 포함 할 수 있지만 다른 언어 / 시스템에서는 허용되지 않을 수 있습니다. 한 번에, 일부 표준에서는 최대 0x7FFF_FFFF까지의 코드 포인트를 갖는 것이 합법적이지만 높지는 않았습니다. 0xFFFF_FFFF보다 큰 코드 포인트에는 32 비트 워드보다 큰 코드가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="2ac9734d0ed22e02e26ee85745c9780f4e398059" translate="yes" xml:space="preserve">
          <source>Perl already</source>
          <target state="translated">펄은 이미</target>
        </trans-unit>
        <trans-unit id="15634b8ec3adda1649ae8821b358664ffd34a247" translate="yes" xml:space="preserve">
          <source>Perl also defines a consistent extension syntax for features not found in standard tools like &lt;b&gt;awk&lt;/b&gt; and &lt;b&gt;lex&lt;/b&gt;. The syntax for most of these is a pair of parentheses with a question mark as the first thing within the parentheses. The character after the question mark indicates the extension.</source>
          <target state="translated">Perl은 &lt;b&gt;awk&lt;/b&gt; 및 &lt;b&gt;lex&lt;/b&gt; 와 같은 표준 도구에는없는 기능에 대해 일관된 확장 구문을 정의합니다 . 대부분의 구문은 괄호 안의 첫 번째로 물음표가있는 괄호 쌍입니다. 물음표 뒤의 문자는 확장명을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a619d021759a90d753880bfe4b40f68e2b5378ff" translate="yes" xml:space="preserve">
          <source>Perl also guarantees that the ranges &lt;code&gt;A-Z&lt;/code&gt; , &lt;code&gt;a-z&lt;/code&gt; , &lt;code&gt;0-9&lt;/code&gt; , and any subranges of these match what an English-only speaker would expect them to match on any platform. That is, &lt;code&gt;[A-Z]&lt;/code&gt; matches the 26 ASCII uppercase letters; &lt;code&gt;[a-z]&lt;/code&gt; matches the 26 lowercase letters; and &lt;code&gt;[0-9]&lt;/code&gt; matches the 10 digits. Subranges, like &lt;code&gt;[h-k]&lt;/code&gt; , match correspondingly, in this case just the four letters &lt;code&gt;&quot;h&quot;&lt;/code&gt; , &lt;code&gt;&quot;i&quot;&lt;/code&gt; , &lt;code&gt;&quot;j&quot;&lt;/code&gt; , and &lt;code&gt;&quot;k&quot;&lt;/code&gt; . This is the natural behavior on ASCII platforms where the code points (ordinal values) for &lt;code&gt;&quot;h&quot;&lt;/code&gt; through &lt;code&gt;&quot;k&quot;&lt;/code&gt; are consecutive integers (0x68 through 0x6B). But special handling to achieve this may be needed on platforms with a non-ASCII native character set. For example, on EBCDIC platforms, the code point for &lt;code&gt;&quot;h&quot;&lt;/code&gt; is 0x88, &lt;code&gt;&quot;i&quot;&lt;/code&gt; is 0x89, &lt;code&gt;&quot;j&quot;&lt;/code&gt; is 0x91, and &lt;code&gt;&quot;k&quot;&lt;/code&gt; is 0x92. Perl specially treats &lt;code&gt;[h-k]&lt;/code&gt; to exclude the seven code points in the gap: 0x8A through 0x90. This special handling is only invoked when the range is a subrange of one of the ASCII uppercase, lowercase, and digit ranges, AND each end of the range is expressed either as a literal, like &lt;code&gt;&quot;A&quot;&lt;/code&gt; , or as a named character (&lt;code&gt;\N{...}&lt;/code&gt; , including the &lt;code&gt;\N{U+...&lt;/code&gt; form).</source>
          <target state="translated">Perl은 또한 범위 &lt;code&gt;A-Z&lt;/code&gt; , &lt;code&gt;a-z&lt;/code&gt; , &lt;code&gt;0-9&lt;/code&gt; 및 이들의 하위 범위가 영어 전용 스피커가 모든 플랫폼에서 일치 할 것으로 예상하는 것과 일치 함을 보장합니다 . 즉, &lt;code&gt;[A-Z]&lt;/code&gt; 는 26 개의 ASCII 대문자와 일치합니다. &lt;code&gt;[a-z]&lt;/code&gt; 는 26 개의 소문자와 일치합니다. 및 &lt;code&gt;[0-9]&lt;/code&gt; 10 자리수 일치한다. &lt;code&gt;[h-k]&lt;/code&gt; 와 같은 하위 범위는 해당하는 경우에만 일치합니다.이 경우 &lt;code&gt;&quot;h&quot;&lt;/code&gt; , &lt;code&gt;&quot;i&quot;&lt;/code&gt; , &lt;code&gt;&quot;j&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;k&quot;&lt;/code&gt; 네 글자 만 일치합니다 . 이것은 &lt;code&gt;&quot;h&quot;&lt;/code&gt; 부터 &lt;code&gt;&quot;k&quot;&lt;/code&gt; &quot; 까지 의 코드 포인트 (정수 값)가있는 ASCII 플랫폼에서 자연스러운 동작입니다.케이&quot;연속 정수입니다 (0x68 ~ 0x6B). 그러나 비 ASCII 기본 문자 세트가있는 플랫폼에서는이를 달성하기위한 특수 처리가 필요할 수 있습니다. 예를 들어 EBCDIC 플랫폼에서 &lt;code&gt;&quot;h&quot;&lt;/code&gt; 의 코드 포인트 는 0x88이고 &lt;code&gt;&quot;i&quot;&lt;/code&gt; 는 0x89이며 &lt;code&gt;&quot;j&quot;&lt;/code&gt; 는 0x91이며 &lt;code&gt;&quot;k&quot;&lt;/code&gt; 는 0x92입니다. Perl은 특별히 &lt;code&gt;[h-k]&lt;/code&gt; 를 처리 하여 0x8A에서 0x90까지의 갭에서 7 개의 코드 포인트를 제외시킵니다. 이 특수 처리는 범위가 ASCII 대문자, 소문자 및 숫자 범위 중 하나의 하위 범위 인 경우에만 호출되며 범위의 각 끝은 &lt;code&gt;&quot;A&quot;&lt;/code&gt; 와 같은 리터럴 또는 이름 지정된 문자 ( &lt;code&gt;\N{...}&lt;/code&gt; &lt;code&gt;\N{U+...&lt;/code&gt; 형식을 포함하여 N {...} ).</target>
        </trans-unit>
        <trans-unit id="43ed4c36b705c801489a6eaa310a7c1790004938" translate="yes" xml:space="preserve">
          <source>Perl also has environment variables that control how Perl handles data specific to particular natural languages; see &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="translated">Perl은 또한 Perl이 특정 자연 언어에 특정한 데이터를 처리하는 방법을 제어하는 ​​환경 변수를 가지고 있습니다. &lt;a href=&quot;perllocale&quot;&gt;perllocale을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8ec1e88310a904c3504c234668eb6f0ebab9fa04" translate="yes" xml:space="preserve">
          <source>Perl also has its own built-in variables whose names don't follow these rules. They have strange names so they don't accidentally collide with one of your normal variables. Strings that match parenthesized parts of a regular expression are saved under names containing only digits after the &lt;code&gt;$&lt;/code&gt; (see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; and &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;). In addition, several special variables that provide windows into the inner working of Perl have names containing punctuation characters and control characters. These are documented in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;.</source>
          <target state="translated">Perl에는 이름이 이러한 규칙을 따르지 않는 자체 내장 변수도 있습니다. 그들은 이상한 이름을 가지고 있기 때문에 실수로 일반적인 변수 중 하나와 충돌하지 않습니다. 정규 표현식의 괄호로 묶은 부분과 일치하는 문자열은 &lt;code&gt;$&lt;/code&gt; 뒤에 숫자 만 포함 된 이름으로 저장됩니다 ( &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 및 &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; 참조 ). 또한 Perl의 내부 작업에 창을 제공하는 몇 가지 특수 변수에는 문장 부호 문자와 제어 문자가 포함 된 이름이 있습니다. 이것들은 &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; 에 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="841c07e6d7a8a9202a2c193293298a117297f325" translate="yes" xml:space="preserve">
          <source>Perl also has single-form extensions that refer to blocks, &lt;code&gt;In_Cyrillic&lt;/code&gt; , meaning &lt;code&gt;Block=Cyrillic&lt;/code&gt; . These have always been written in the new style.</source>
          <target state="translated">Perl은 또한 블록을 나타내는 단일 형식 확장명을 가지고 있습니다. &lt;code&gt;In_Cyrillic&lt;/code&gt; 은 &lt;code&gt;Block=Cyrillic&lt;/code&gt; 을 의미 합니다. 이들은 항상 새로운 스타일로 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="e768cdcaf855f3ac360271eae70fa3fb2f42dd9c" translate="yes" xml:space="preserve">
          <source>Perl also lets you use a dereferenced scalar reference in a method call. That's a mouthful, so let's look at some code:</source>
          <target state="translated">Perl을 사용하면 메소드 호출에서 역 참조 된 스칼라 참조를 사용할 수도 있습니다. 그것은 한 입입니다, 그래서 몇 가지 코드를 보자 :</target>
        </trans-unit>
        <trans-unit id="bb3ab86dafec3fc1c1204665ff3d23b69370b1f7" translate="yes" xml:space="preserve">
          <source>Perl also lets you use a scalar containing a string as a class name:</source>
          <target state="translated">Perl을 사용하면 문자열을 클래스 이름으로 포함하는 스칼라를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="371faeea377937a5cb124120c079958efb812b1f" translate="yes" xml:space="preserve">
          <source>Perl also provides some additional extensions and short-cut synonyms for Unicode properties.</source>
          <target state="translated">Perl은 유니 코드 속성에 대한 몇 가지 추가 확장 및 바로 가기 동의어도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bc3b136059aadb780f36682ea1b93270fac2fc5f" translate="yes" xml:space="preserve">
          <source>Perl also uses two special typedefs, I32 and I16, which will always be at least 32-bits and 16-bits long, respectively. (Again, there are U32 and U16, as well.) They will usually be exactly 32 and 16 bits long, but on Crays they will both be 64 bits.</source>
          <target state="translated">Perl은 또한 각각 32 비트와 16 비트 길이 인 두 개의 특수 typedef 인 I32와 I16을 사용합니다. (다시 말해서 U32와 U16도 있습니다.) 그것들은 보통 정확히 32와 16 비트 길이이지만, Crays에서는 둘 다 64 비트입니다.</target>
        </trans-unit>
        <trans-unit id="d9ec80db167215866b69eb0ca3e0370b7320f73c" translate="yes" xml:space="preserve">
          <source>Perl and its various modules and components, including its test frameworks, may sometimes make use of certain other environment variables. Some of these are specific to a particular platform. Please consult the appropriate module documentation and any documentation for your platform (like &lt;a href=&quot;perlsolaris&quot;&gt;perlsolaris&lt;/a&gt;, &lt;a href=&quot;perllinux&quot;&gt;perllinux&lt;/a&gt;, &lt;a href=&quot;perlmacosx&quot;&gt;perlmacosx&lt;/a&gt;, &lt;a href=&quot;perlwin32&quot;&gt;perlwin32&lt;/a&gt;, etc) for variables peculiar to those specific situations.</source>
          <target state="translated">테스트 프레임 워크를 포함하여 Perl과 다양한 모듈 및 구성 요소는 때때로 특정 환경 변수를 사용할 수 있습니다. 이들 중 일부는 특정 플랫폼에 따라 다릅니다. 특정 상황에 고유 한 변수에 대해서는 적절한 모듈 설명서 및 플랫폼에 대한 문서 (예 : &lt;a href=&quot;perlsolaris&quot;&gt;perlsolaris&lt;/a&gt; , &lt;a href=&quot;perllinux&quot;&gt;perllinux&lt;/a&gt; , &lt;a href=&quot;perlmacosx&quot;&gt;perlmacosx&lt;/a&gt; , &lt;a href=&quot;perlwin32&quot;&gt;perlwin32&lt;/a&gt; 등)를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d1f38ea6665b57c86a485191974a93669f79515b" translate="yes" xml:space="preserve">
          <source>Perl applications</source>
          <target state="translated">펄 어플리케이션</target>
        </trans-unit>
        <trans-unit id="502f7e3b25466218701794ac8b146d454581203f" translate="yes" xml:space="preserve">
          <source>Perl attempts to flush all files opened for output before forking the child process, but this may not be supported on some platforms (see &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt;). To be safe, you may need to set &lt;code&gt;$|&lt;/code&gt; ($AUTOFLUSH in English) or call the &lt;code&gt;autoflush()&lt;/code&gt; method of &lt;code&gt;IO::Handle&lt;/code&gt; on any open handles to avoid duplicate output.</source>
          <target state="translated">Perl은 하위 프로세스를 분기하기 전에 출력을 위해 열린 모든 파일을 비우려고 시도하지만 일부 플랫폼에서는 지원되지 않을 수 있습니다 ( &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt; 참조 ). 안전을 위해 &lt;code&gt;$|&lt;/code&gt; 를 설정해야 할 수도 있습니다. (영어로 $ AUTOFLUSH) 또는 중복 출력을 피하기 위해 열린 &lt;code&gt;IO::Handle&lt;/code&gt; 에서 IO :: Handle 의 &lt;code&gt;autoflush()&lt;/code&gt; 메소드를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="310c094e234f2eeac0cd6d541a4252ff1573cf15" translate="yes" xml:space="preserve">
          <source>Perl attempts to flush all files opened for output before forking the child process, but this may not be supported on some platforms (see &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;). To be safe, you may need to set &lt;code&gt;$|&lt;/code&gt; ($AUTOFLUSH in English) or call the &lt;code&gt;autoflush()&lt;/code&gt; method of &lt;code&gt;IO::Handle&lt;/code&gt; on any open handles to avoid duplicate output.</source>
          <target state="translated">Perl은 하위 프로세스를 분기하기 전에 출력을 위해 열린 모든 파일을 비우려고 시도하지만 일부 플랫폼에서는 지원되지 않을 수 있습니다 ( &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; 참조 ). 안전을 위해 &lt;code&gt;$|&lt;/code&gt; 를 설정해야 할 수도 있습니다. (영어로 $ AUTOFLUSH) 또는 중복 출력을 피하기 위해 열린 &lt;code&gt;IO::Handle&lt;/code&gt; 에서 IO :: Handle 의 &lt;code&gt;autoflush()&lt;/code&gt; 메소드를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="de17dd0dec4269e99ee3620228765bf8385c7342" translate="yes" xml:space="preserve">
          <source>Perl attempts to flush all files opened for output before the exec, but this may not be supported on some platforms (see &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt;). To be safe, you may need to set &lt;code&gt;$|&lt;/code&gt; ($AUTOFLUSH in English) or call the &lt;code&gt;autoflush()&lt;/code&gt; method of &lt;code&gt;IO::Handle&lt;/code&gt; on any open handles to avoid lost output.</source>
          <target state="translated">Perl은 실행 전에 출력을 위해 열린 모든 파일을 비우려고 시도하지만 일부 플랫폼에서는 지원되지 않을 수 있습니다 ( &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt; 참조 ). 안전을 위해 &lt;code&gt;$|&lt;/code&gt; 를 설정해야 할 수도 있습니다. ($ AUTOFLUSH 영어) 또는 출력 손실을 피하기 위해 열린 &lt;code&gt;IO::Handle&lt;/code&gt; 에서 IO :: Handle 의 &lt;code&gt;autoflush()&lt;/code&gt; 메소드를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="003b4d9ba004fb0af8689ed0414255d30b89d115" translate="yes" xml:space="preserve">
          <source>Perl attempts to flush all files opened for output before the exec, but this may not be supported on some platforms (see &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;). To be safe, you may need to set &lt;code&gt;$|&lt;/code&gt; ($AUTOFLUSH in English) or call the &lt;code&gt;autoflush()&lt;/code&gt; method of &lt;code&gt;IO::Handle&lt;/code&gt; on any open handles to avoid lost output.</source>
          <target state="translated">Perl은 실행 전에 출력을 위해 열린 모든 파일을 비우려고 시도하지만 일부 플랫폼에서는 지원되지 않을 수 있습니다 ( &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; 참조 ). 안전을 위해 &lt;code&gt;$|&lt;/code&gt; 를 설정해야 할 수도 있습니다. ($ AUTOFLUSH 영어) 또는 출력 손실을 피하기 위해 열린 &lt;code&gt;IO::Handle&lt;/code&gt; 에서 IO :: Handle 의 &lt;code&gt;autoflush()&lt;/code&gt; 메소드를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="7d4f20a9384f8bc5428825b882bff482c1a8070c" translate="yes" xml:space="preserve">
          <source>Perl automatically calls the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method when processing a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement for a module. Modules and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; are documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; and &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;. Understanding the concept of modules and how the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement operates is important to understanding the Exporter.</source>
          <target state="translated">Perl 은 모듈 의 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 문을 처리 할 때 자동으로 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 메소드를 호출합니다 . 모듈 및 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 은 &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; 및 &lt;a href=&quot;perlmod&quot;&gt;perlmod에&lt;/a&gt; 문서화되어 있습니다. 내보내기 개념을 이해하려면 모듈 개념과 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 문 작동 방식 을 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="f61b6a6317cfa23498f15dd9d06745532cf81070" translate="yes" xml:space="preserve">
          <source>Perl automatically enables a set of special security checks, called</source>
          <target state="translated">Perl은 자동으로 특별한 보안 검사 세트를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="fbe832a4f97c9466dde588ba9b2da8adad2850de" translate="yes" xml:space="preserve">
          <source>Perl automatically handles most of the common ways a method might be redefined. However, there are a few ways you could change a method in a stash without the cache code noticing, in which case you need to call this method afterwards:</source>
          <target state="translated">Perl은 메소드를 재정의 할 수있는 대부분의 일반적인 방법을 자동으로 처리합니다. 그러나 캐시 코드를 알리지 않고 숨김에서 메소드를 변경할 수있는 몇 가지 방법이 있습니다.이 경우 나중에이 메소드를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="036d8f87f677f8c5718f1d28012fa559462c3777" translate="yes" xml:space="preserve">
          <source>Perl automatically provides large file support when built under 64-bit Windows.</source>
          <target state="translated">Perl은 64 비트 Windows에서 빌드 될 때 자동으로 큰 파일 지원을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7a716c995ea81037d2661a333de648b734bf1c68" translate="yes" xml:space="preserve">
          <source>Perl believes that no machine ever has more than one of &lt;code&gt;change&lt;/code&gt; , &lt;code&gt;age&lt;/code&gt; , or &lt;code&gt;quota&lt;/code&gt; implemented, nor more than one of either &lt;code&gt;comment&lt;/code&gt; or &lt;code&gt;class&lt;/code&gt; . Some machines do not support &lt;code&gt;expire&lt;/code&gt; , &lt;code&gt;gecos&lt;/code&gt; , or allegedly, &lt;code&gt;passwd&lt;/code&gt; . You may call these methods no matter what machine you're on, but they return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if unimplemented.</source>
          <target state="translated">Perl은 어떤 머신도 &lt;code&gt;change&lt;/code&gt; , &lt;code&gt;age&lt;/code&gt; 또는 &lt;code&gt;quota&lt;/code&gt; 중 하나 이상을 구현하거나 &lt;code&gt;comment&lt;/code&gt; 또는 &lt;code&gt;class&lt;/code&gt; 중 하나 이상을 구현 한 적이 없다고 생각합니다 . 일부 시스템은 &lt;code&gt;expire&lt;/code&gt; , &lt;code&gt;gecos&lt;/code&gt; 또는 &lt;code&gt;passwd&lt;/code&gt; 를 지원하지 않습니다 . 어떤 컴퓨터를 사용하든 이러한 메서드를 호출 할 수 있지만 구현되지 않은 경우 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="5d0360d06e2a1778dd48425c09025dbdf8293f8e" translate="yes" xml:space="preserve">
          <source>Perl binary able to run this extension, load XS modules, etc...</source>
          <target state="translated">Perl 바이너리는이 확장을 실행할 수 있고 XS 모듈 등을로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb8da21c98e2920d923d329d6f68942a153a615f" translate="yes" xml:space="preserve">
          <source>Perl binary distributions come with a</source>
          <target state="translated">Perl 바이너리 배포판에는</target>
        </trans-unit>
        <trans-unit id="25b8cd5db95b73c8697ce2a24fc9a3c4624497ef" translate="yes" xml:space="preserve">
          <source>Perl binary for tasks that can be done by miniperl.</source>
          <target state="translated">miniperl로 수행 할 수있는 작업을위한 Perl 바이너리.</target>
        </trans-unit>
        <trans-unit id="b72df5c4242785794c622b22864eb9d8a2e74001" translate="yes" xml:space="preserve">
          <source>Perl builds and runs on a bewildering number of platforms. Virtually all known and current Unix derivatives are supported (perl's native platform), as are other systems like VMS, DOS, OS/2, Windows, QNX, BeOS, OS X, MPE/iX and the Amiga.</source>
          <target state="translated">Perl은 놀라 울 정도로 많은 플랫폼에서 빌드하고 실행합니다. VMS, DOS, OS / 2, Windows, QNX, BeOS, OS X, MPE / iX 및 Amiga와 같은 다른 시스템과 마찬가지로 알려진 모든 최신 Unix 파생 제품 (perl의 기본 플랫폼)이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="96b360f2cb263510b9740f1a358943c2a62edfbc" translate="yes" xml:space="preserve">
          <source>Perl by default comes with the latest supported Unicode version built-in, but the goal is to allow you to change to use any earlier one. In Perls v5.20 and v5.22, however, the earliest usable version is Unicode 5.1. Perl v5.18 is able to handle all earlier versions.</source>
          <target state="translated">기본적으로 Perl에는 지원되는 최신 유니 코드 버전이 기본 제공되지만 목표는 이전 버전을 사용하도록 변경하는 것입니다. 그러나 Perls v5.20 및 v5.22에서 사용 가능한 가장 초기 버전은 유니 코드 5.1입니다. Perl v5.18은 모든 이전 버전을 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="858924b099068580d5d02f65c2520871f9621191" translate="yes" xml:space="preserve">
          <source>Perl by default is very forgiving. In order to make it more robust it is recommended to start every program with the following lines:</source>
          <target state="translated">Perl은 기본적으로 매우 관대합니다. 보다 강력하게하기 위해 모든 프로그램을 다음 줄로 시작하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="41943c9223a2849d683a6cec44cbaf36e58b907e" translate="yes" xml:space="preserve">
          <source>Perl can be built so that it by default will try to execute</source>
          <target state="translated">Perl은 기본적으로 실행을 시도하도록 빌드 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="36ba407dbee2d6e43709ef0153d960c56996ecc9" translate="yes" xml:space="preserve">
          <source>Perl can be compiled on platforms that run any of three commonly used EBCDIC character sets, listed below.</source>
          <target state="translated">Perl은 아래에 나열된 세 가지 일반적으로 사용되는 EBCDIC 문자 세트를 실행하는 플랫폼에서 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bea19b77ce1281f9b9bf9a47baf0d79604e6dd7a" translate="yes" xml:space="preserve">
          <source>Perl can be compiled with either HP's ANSI C compiler or with gcc. The former is recommended, as not only can it compile Perl with no difficulty, but also can take advantage of features listed later that require the use of HP compiler-specific command-line flags.</source>
          <target state="translated">Perl은 HP의 ANSI C 컴파일러 또는 gcc로 컴파일 할 수 있습니다. 전자는 Perl을 어려움없이 컴파일 할 수있을뿐만 아니라 HP 컴파일러 특정 명령 행 플래그를 사용해야하는 나중에 나열된 기능을 활용할 수 있으므로 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="f05f1e5361560b59743e9bd4f32b54cc023f431f" translate="yes" xml:space="preserve">
          <source>Perl can be compiled with either IBM's ANSI C compiler or with gcc. The former is recommended, as not only can it compile Perl with no difficulty, but also can take advantage of features listed later that require the use of IBM compiler-specific command-line flags.</source>
          <target state="translated">Perl은 IBM ANSI C 컴파일러 또는 gcc로 컴파일 할 수 있습니다. 전자는 Perl을 어려움없이 컴파일 할 수있을뿐만 아니라 IBM 컴파일러 특정 명령 행 플래그를 사용해야하는 나중에 나열된 기능을 활용할 수 있으므로 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="19a69f0e2f064ea4c82b3309e77eb45ccd797a4c" translate="yes" xml:space="preserve">
          <source>Perl can be compiled with either IBM's ANSI C compiler or with gcc. The former is recommended, as not only it can compile Perl with no difficulty, but also can take advantage of features listed later that require the use of IBM compiler-specific command-line flags.</source>
          <target state="translated">Perl은 IBM ANSI C 컴파일러 또는 gcc로 컴파일 할 수 있습니다. 전자는 Perl을 어려움없이 컴파일 할 수있을뿐만 아니라 IBM 컴파일러 특정 명령 행 플래그를 사용해야하는 나중에 나열된 기능을 활용할 수 있으므로 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="751c036d6e62fec07bc2f5f4e73156154792a0fd" translate="yes" xml:space="preserve">
          <source>Perl can be compiled with gcc from MinGW release 3 and later (using gcc 3.4.5 and later). It can be downloaded here:</source>
          <target state="translated">Perl은 MinGW 릴리스 3 이상에서 gcc로 컴파일 할 수 있습니다 (gcc 3.4.5 이상 사용). 여기에서 다운로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e57623077581e01731874e47fb8c2a4b90f970b" translate="yes" xml:space="preserve">
          <source>Perl can be run under the &quot;C&quot; locale by setting the environment variable &lt;code&gt;LC_ALL&lt;/code&gt; to &quot;C&quot;. This method is perhaps a bit more civilized than the &lt;code&gt;PERL_BADLANG&lt;/code&gt; approach, but setting &lt;code&gt;LC_ALL&lt;/code&gt; (or other locale variables) may affect other programs as well, not just Perl. In particular, external programs run from within Perl will see these changes. If you make the new settings permanent (read on), all programs you run see the changes. See &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt; for the full list of relevant environment variables and &lt;a href=&quot;#USING-LOCALES&quot;&gt;USING LOCALES&lt;/a&gt; for their effects in Perl. Effects in other programs are easily deducible. For example, the variable &lt;code&gt;LC_COLLATE&lt;/code&gt; may well affect your &lt;b&gt;sort&lt;/b&gt; program (or whatever the program that arranges &quot;records&quot; alphabetically in your system is called).</source>
          <target state="translated">환경 변수 &lt;code&gt;LC_ALL&lt;/code&gt; 을 &quot;C&quot; 로 설정하여 &quot;C&quot;로케일에서 Perl을 실행할 수 있습니다 . 이 방법은 아마도 &lt;code&gt;PERL_BADLANG&lt;/code&gt; 접근 방식 보다 약간 문명화 되었지만 &lt;code&gt;LC_ALL&lt;/code&gt; (또는 다른 로케일 변수)을 설정하면 Perl뿐만 아니라 다른 프로그램에도 영향을 줄 수 있습니다. 특히 Perl 내에서 실행되는 외부 프로그램은 이러한 변경 사항을 보게됩니다. 새 설정을 영구적 (읽기)으로 설정하면 실행하는 모든 프로그램에 변경 사항이 표시됩니다. 관련 환경 변수의 전체 목록은 &lt;a href=&quot;#ENVIRONMENT&quot;&gt;환경&lt;/a&gt; 을 참조 하고 Perl에서의 영향에 대해서는 &lt;a href=&quot;#USING-LOCALES&quot;&gt;LOCALES 사용&lt;/a&gt; 을 참조하십시오 . 다른 프로그램의 효과는 쉽게 추론 할 수 있습니다. 예를 들어 &lt;code&gt;LC_COLLATE&lt;/code&gt; 변수 는 &lt;b&gt;정렬에&lt;/b&gt; 영향을 줄 수 있습니다.&lt;b&gt;&lt;/b&gt; 프로그램 (또는 시스템에서 알파벳순으로 &quot;레코드&quot;를 정렬하는 프로그램이 호출 됨).</target>
        </trans-unit>
        <trans-unit id="afea4028a165b75f73beb84894121ff0308d01df" translate="yes" xml:space="preserve">
          <source>Perl can be used for almost any coding problem, even ones which require integrating specialist C code for extra speed. As with any tool it can be used well or badly. Perl has many strengths, and a few weaknesses, precisely which areas are good and bad is often a personal choice.</source>
          <target state="translated">Perl은 거의 모든 코딩 문제에 사용할 수 있으며 추가 속도를 위해 전문가 C 코드를 통합해야하는 경우도 있습니다. 모든 도구와 마찬가지로 잘 사용하거나 잘못 사용할 수 있습니다. 펄은 많은 강점과 약점을 가지고 있으며, 어떤 영역이 좋고 나쁜지를 정확하게 선택하는 것이 종종 개인적인 선택입니다.</target>
        </trans-unit>
        <trans-unit id="9f84aec4fa7ef06751c778c8e8173ffe00dcd629" translate="yes" xml:space="preserve">
          <source>Perl can compile and run under EBCDIC platforms. See &lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt;. This is transparent for the most part, but because the character sets differ, you shouldn't use numeric (decimal, octal, nor hex) constants to refer to characters. You can safely say &lt;code&gt;'A'&lt;/code&gt; , but not &lt;code&gt;0x41&lt;/code&gt; . You can safely say &lt;code&gt;'\n'&lt;/code&gt; , but not &lt;code&gt;\012&lt;/code&gt; . However, you can use macros defined in</source>
          <target state="translated">Perl은 EBCDIC 플랫폼에서 컴파일하고 실행할 수 있습니다. &lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic를&lt;/a&gt; 참조하십시오 . 이것은 대부분 투명하지만 문자 집합이 다르기 때문에 숫자 (10 진수, 8 진수 또는 16 진수) 상수를 사용하여 문자를 참조하면 안됩니다. 안전하게 &lt;code&gt;'A'&lt;/code&gt; 라고 말할 수 있지만 &lt;code&gt;0x41&lt;/code&gt; 은 말할 수 없습니다 . 안전하게 &lt;code&gt;'\n'&lt;/code&gt; 말할 수 있지만 &lt;code&gt;\012&lt;/code&gt; 말할 수 없습니다 . 그러나에 정의 된 매크로를 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="fa07386a80b47ab8df8b6dbe1e6a41311efb8910" translate="yes" xml:space="preserve">
          <source>Perl can internally represent numbers in 3 different ways: as native integers, as native floating point numbers, and as decimal strings. Decimal strings may have an exponential notation part, as in &lt;code&gt;&quot;12.34e-56&quot;&lt;/code&gt; .</source>
          <target state="translated">펄은 내부적으로 3 가지 방식으로 숫자를 표현할 수 있습니다 : 기본 정수, 기본 부동 소수점 숫자, 10 진수 문자열. &lt;code&gt;&quot;12.34e-56&quot;&lt;/code&gt; 에서와 같이 십진 문자열에는 지수 표기법 부분이있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="05cb1fb37d34785f635f75844d77033b80fc24ef" translate="yes" xml:space="preserve">
          <source>Perl can process line directives, much like the C preprocessor. Using this, one can control Perl's idea of filenames and line numbers in error or warning messages (especially for strings that are processed with &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;). The syntax for this mechanism is almost the same as for most C preprocessors: it matches the regular expression</source>
          <target state="translated">Perl은 C 프리 프로세서와 매우 유사한 라인 지시문을 처리 할 수 ​​있습니다. 이를 사용하여 오류 또는 경고 메시지 (특히 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 처리되는 문자열의 경우)에서 파일 이름 및 줄 번호에 대한 Perl의 아이디어를 제어 할 수 있습니다 . 이 메커니즘의 구문은 대부분의 C 프리 프로세서와 거의 동일합니다. 정규식과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="87b4bc522cc9bacefe7588c2849722683c7ccc0c" translate="yes" xml:space="preserve">
          <source>Perl can provide access to all non-provisional Unicode character properties, though not all are enabled by default. The omitted ones are the Unihan properties (accessible via the CPAN module &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Unihan&quot;&gt;Unicode::Unihan&lt;/a&gt;) and certain deprecated or Unicode-internal properties. (An installation may choose to recompile Perl's tables to change this. See &lt;a href=&quot;#Unicode-character-properties-that-are-NOT-accepted-by-Perl&quot;&gt;Unicode character properties that are NOT accepted by Perl&lt;/a&gt;.)</source>
          <target state="translated">Perl은 임시가 아닌 모든 유니 코드 문자 속성에 대한 액세스를 제공 할 수 있지만 기본적으로 모두 활성화되어 있지는 않습니다. 생략 된 속성은 Unihan 속성 (CPAN 모듈 &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Unihan&quot;&gt;Unicode :: Unihan을&lt;/a&gt; 통해 액세스 가능 )과 더 이상 사용되지 않거나 유니 코드 내부 속성입니다. (설치는이를 변경하기 위해 Perl의 테이블을 다시 컴파일하도록 선택할 수 있습니다. Perl에서 &lt;a href=&quot;#Unicode-character-properties-that-are-NOT-accepted-by-Perl&quot;&gt;허용되지 않는 유니 코드 문자 특성을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="b9d3bae2bf6cbe36ec81823e26589a3e2497f6c1" translate="yes" xml:space="preserve">
          <source>Perl cannot be compiled with threading support ATM.</source>
          <target state="translated">스레딩 지원 ATM으로 Perl을 컴파일 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5aa9ff89c6dfca6cc410567a511ce06ca99ab635" translate="yes" xml:space="preserve">
          <source>Perl cannot protect you from all possibilities shown in the examples--there is no substitute for your own vigilance--but, when &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect, Perl uses the tainting mechanism (see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;) to mark string results that become locale-dependent, and which may be untrustworthy in consequence. Here is a summary of the tainting behavior of operators and functions that may be affected by the locale:</source>
          <target state="translated">Perl은 예제에 표시된 모든 가능성으로부터 사용자를 보호 할 수 없습니다 (자신의 경계를 대신 할 수는 없지만) &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 이 유효한 경우 Perl은 오염 메커니즘 ( &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; 참조 )을 사용하여 로케일에 따라 달라지는 문자열 결과를 표시합니다. 신뢰할 수없는 결과가 될 수 있습니다. 로케일의 영향을받을 수있는 연산자 및 함수의 오염 동작에 대한 요약은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d5f3aa702381872bb34697babcd6d91dd23feeed" translate="yes" xml:space="preserve">
          <source>Perl code is always compiled into an internal format before execution.</source>
          <target state="translated">Perl 코드는 실행 전에 항상 내부 형식으로 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="c5cce9b9678a00b1fe024a9af1e795642a5bcb9c" translate="yes" xml:space="preserve">
          <source>Perl comes with a wide selection of builtin functions. Some of the ones we've already seen include &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt;. A list of them is given at the start of &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; and you can easily read about any given function by using &lt;code&gt;perldoc -f &lt;i&gt;functionname&lt;/i&gt;&lt;/code&gt;.</source>
          <target state="translated">Perl은 다양한 내장 기능을 제공합니다. 우리가 이미 본 것 중 일부는 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; 입니다. 이들의 목록은 &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; 의 시작 부분에 제공되며 &lt;code&gt;perldoc -f &lt;i&gt;functionname&lt;/i&gt;&lt;/code&gt; 을 사용하여 주어진 기능에 대해 쉽게 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d575f0416db18e1fc564b29cf8cc390222ecf415" translate="yes" xml:space="preserve">
          <source>Perl comes with an interactive debugger, which you can start with the &lt;code&gt;-d&lt;/code&gt; switch. It's fully explained in &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;.</source>
          <target state="translated">Perl은 대화식 디버거와 함께 제공되며 &lt;code&gt;-d&lt;/code&gt; 스위치로 시작할 수 있습니다 . &lt;a href=&quot;perldebug&quot;&gt;perldebug에&lt;/a&gt; 자세히 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="641c8779114365eacf0b514d71b892f3c88f6444" translate="yes" xml:space="preserve">
          <source>Perl compiler backend to produce perl code</source>
          <target state="translated">펄 코드를 생성하는 펄 컴파일러 백엔드</target>
        </trans-unit>
        <trans-unit id="a425209baf3b199ee00ab768f1943ede83ed4ff4" translate="yes" xml:space="preserve">
          <source>Perl contains internal support for reporting its own memory usage, but this is a fairly advanced concept that requires some understanding of how memory allocation works. See &lt;a href=&quot;perldebguts#Debugging-Perl-Memory-Usage&quot;&gt;Debugging Perl Memory Usage in perldebguts&lt;/a&gt; for the details.</source>
          <target state="translated">Perl은 자체 메모리 사용을보고하기위한 내부 지원을 포함하지만 이것은 메모리 할당 작동 방식에 대한 이해가 필요한 상당히 고급 개념입니다. 자세한 내용 &lt;a href=&quot;perldebguts#Debugging-Perl-Memory-Usage&quot;&gt;은 perldebguts에서 Perl 메모리 사용 디버깅을&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="a29ee67698d8ff496114e40d0f60aa708da987ff" translate="yes" xml:space="preserve">
          <source>Perl continues to warn (using the warning category &lt;code&gt;&quot;nonchar&quot;&lt;/code&gt; , which is a sub-category of &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; ) if an attempt is made to output noncharacters.</source>
          <target state="translated">비 문자를 출력하려고 시도하는 경우 Perl은 계속 경고합니다 (경고 범주 &lt;code&gt;&quot;nonchar&quot;&lt;/code&gt; , &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; 의 하위 범주 사용 ).</target>
        </trans-unit>
        <trans-unit id="baa05b026a869001e1e5be6e67df2e5d03445c53" translate="yes" xml:space="preserve">
          <source>Perl currently only supports single-byte locales for &lt;code&gt;LC_COLLATE&lt;/code&gt; . This means that a UTF-8 locale likely will just give you machine-native ordering. Use &lt;a href=&quot;unicode/collate&quot;&gt;Unicode::Collate&lt;/a&gt; for the full implementation of the Unicode Collation Algorithm.</source>
          <target state="translated">Perl은 현재 &lt;code&gt;LC_COLLATE&lt;/code&gt; 에 대한 1 바이트 로케일 만 지원합니다 . 이것은 UTF-8 로케일이 기계 고유의 순서를 제공 할 가능성이 있음을 의미합니다. Unicode Collation Algorithm을 완전히 구현 하려면 &lt;a href=&quot;unicode/collate&quot;&gt;Unicode :: Collate&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="77cf5a91724851c2026eb0ed52027faf2ff9d8f3" translate="yes" xml:space="preserve">
          <source>Perl debug information is frequently required not just by debuggers, but also by modules that need some &quot;special&quot; information to do their job properly, like profilers.</source>
          <target state="translated">Perl 디버그 정보는 디버거뿐만 아니라 프로파일 러와 같이 작업을 올바르게 수행하기 위해 &quot;특별한&quot;정보가 필요한 모듈에도 필요합니다.</target>
        </trans-unit>
        <trans-unit id="edcd0b1168988fe6213df824f5ad91c7a66c6c43" translate="yes" xml:space="preserve">
          <source>Perl defines the following zero-width assertions:</source>
          <target state="translated">Perl은 다음과 같이 폭이 0 인 어설 션을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="6b26390b798af49773d52f4620dbbc3aff54133e" translate="yes" xml:space="preserve">
          <source>Perl deliberately randomizes hash order for security purposes on both ASCII and EBCDIC platforms.</source>
          <target state="translated">Perl은 ASCII 및 EBCDIC 플랫폼 모두에서 보안 목적으로 해시 순서를 의도적으로 무작위 화합니다.</target>
        </trans-unit>
        <trans-unit id="b360e4dc6087d3b16edb381fbc0c1f20ea026de5" translate="yes" xml:space="preserve">
          <source>Perl derives from the ubiquitous C programming language and to a lesser extent from sed, awk, the Unix shell, and many other tools and languages.</source>
          <target state="translated">Perl은 유비쿼터스 C 프로그래밍 언어와 sed, awk, Unix 쉘 및 기타 여러 도구 및 언어에서 파생됩니다.</target>
        </trans-unit>
        <trans-unit id="82ed6e041cbd4aae6a032a9f05ea11dde0c68044" translate="yes" xml:space="preserve">
          <source>Perl does its own &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; formatting: it emulates the C function sprintf(3), but doesn't use it except for floating-point numbers, and even then only standard modifiers are allowed. Non-standard extensions in your local sprintf(3) are therefore unavailable from Perl.</source>
          <target state="translated">Perl은 자체 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 형식을 수행합니다. C 함수 sprintf (3)를 에뮬레이트하지만 부동 소수점 숫자를 제외하고는 사용하지 않으며 표준 수정 자만 허용됩니다. 따라서 로컬 sprintf (3)의 비표준 확장은 Perl에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9fd3bbafbe5f224f645e29f633eba572a0b47a6b" translate="yes" xml:space="preserve">
          <source>Perl does its own &lt;code&gt;&lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; formatting: it emulates the C function sprintf(3), but doesn't use it except for floating-point numbers, and even then only standard modifiers are allowed. Non-standard extensions in your local sprintf(3) are therefore unavailable from Perl.</source>
          <target state="translated">Perl은 자체 &lt;code&gt;&lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 형식을 수행합니다. C 함수 sprintf (3)를 에뮬레이트하지만 부동 소수점 숫자를 제외하고는 사용하지 않으며 표준 수정 자만 허용됩니다. 따라서 로컬 sprintf (3)의 비표준 확장은 Perl에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a4d0575e168bcb93baf91092d083b3f45edc7784" translate="yes" xml:space="preserve">
          <source>Perl does not allow overloading of ranges, so you can neither safely use ranges with bigint endpoints, nor is the iterator variable a bigint.</source>
          <target state="translated">Perl은 범위의 오버로드를 허용하지 않으므로 bigint 엔드 포인트에 범위를 안전하게 사용할 수 없으며 반복자 변수도 bigint입니다.</target>
        </trans-unit>
        <trans-unit id="c115815d6de8f54c97b95bbf1feacf608d2cdd8a" translate="yes" xml:space="preserve">
          <source>Perl does not call the shell to expand wild cards when you pass &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; explicit parameter lists instead of strings with possible shell wildcards in them. Unfortunately, the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt;, and backtick functions provide no such alternate calling convention, so more subterfuge will be required.</source>
          <target state="translated">당신이 통과 할 때 펄은 와일드 카드를 확장하는 쉘을 호출하지 않습니다 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 들을 가능한 쉘 와일드 카드로 명시 적 매개 변수 목록 대신 문자열. 불행하게도, &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 및 backtick 함수는 이러한 대체 호출 규칙을 제공하지 않으므로 더 많은 서브 퍼지가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="acf14eaf9fdbdb615c0b9a213270f3740bd4a2b7" translate="yes" xml:space="preserve">
          <source>Perl does not care about file systems, but the perl library contains many files with long names, so to install it intact one needs a file system which supports long file names.</source>
          <target state="translated">Perl은 파일 시스템을 신경 쓰지 않지만 perl 라이브러리에는 긴 이름을 가진 많은 파일이 포함되어 있으므로 그대로 설치하려면 긴 파일 이름을 지원하는 파일 시스템이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="5354348a14ac18fad5dfd9ae6dc9f4e8955fd5e4" translate="yes" xml:space="preserve">
          <source>Perl does not depend on the registry, but it can look up certain default values if you choose to put them there. Perl attempts to read entries from &lt;code&gt;HKEY_CURRENT_USER\Software\Perl&lt;/code&gt; and &lt;code&gt;HKEY_LOCAL_MACHINE\Software\Perl&lt;/code&gt; . Entries in the former override entries in the latter. One or more of the following entries (of type REG_SZ or REG_EXPAND_SZ) may be set:</source>
          <target state="translated">Perl은 레지스트리에 의존하지 않지만 특정 기본값을 배치하도록 선택하면 특정 기본값을 찾을 수 있습니다. Perl은 &lt;code&gt;HKEY_CURRENT_USER\Software\Perl&lt;/code&gt; 및 &lt;code&gt;HKEY_LOCAL_MACHINE\Software\Perl&lt;/code&gt; 에서 항목을 읽으려고합니다 . 전자의 항목은 후자의 항목보다 우선합니다. REG_SZ 또는 REG_EXPAND_SZ 유형의 다음 항목 중 하나 이상을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6697dea8bad1c38bf0eecc9764ad8eaf5ace311" translate="yes" xml:space="preserve">
          <source>Perl does not enforce private and public parts of its modules as you may have been used to in other languages like C++, Ada, or Modula-17. Perl doesn't have an infatuation with enforced privacy. It would prefer that you stayed out of its living room because you weren't invited, not because it has a shotgun.</source>
          <target state="translated">C ++, Ada 또는 Modula-17과 같은 다른 언어에서 익숙했을 수 있으므로 Perl은 모듈의 개인 및 공용 부분을 강요하지 않습니다. Perl은 개인 정보 보호에 열광하지 않습니다. 초청이 아니기 때문에 초대받지 않았기 때문에 거실에서 나가는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7376046122227141976ff6a43223937f5fa71800" translate="yes" xml:space="preserve">
          <source>Perl does not expand &lt;code&gt;~&lt;/code&gt; in filenames, which is good, since some folks use it for their backup files:</source>
          <target state="translated">Perl은 파일 이름에서 &lt;code&gt;~&lt;/code&gt; 를 확장하지 않습니다. 일부 사람들은 파일 이름을 백업 파일로 사용하기 때문에 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5b47de2bb8098559e3bf2dcabce87f213a6eb4f0" translate="yes" xml:space="preserve">
          <source>Perl does not have any built-in way to express roles. In the past, people just bit the bullet and used multiple inheritance. Nowadays, there are several good choices on CPAN for using roles.</source>
          <target state="translated">Perl에는 역할을 표현할 수있는 기본 제공 방법이 없습니다. 과거에는 사람들이 총알을 물고 여러 상속을 사용했습니다. 요즘에는 CPAN에서 역할을 사용하기위한 몇 가지 좋은 선택이 있습니다.</target>
        </trans-unit>
        <trans-unit id="eea568e6b9c913375e5a754c242df8539876547c" translate="yes" xml:space="preserve">
          <source>Perl does not provide any special syntax for class definitions. A package is simply a namespace containing variables and subroutines. The only difference is that in a class, the subroutines may expect a reference to an object or the name of a class as the first argument. This is purely a matter of convention, so a class may contain both methods and subroutines which</source>
          <target state="translated">Perl은 클래스 정의를위한 특별한 구문을 제공하지 않습니다. 패키지는 단순히 변수와 서브 루틴을 포함하는 네임 스페이스입니다. 유일한 차이점은 클래스에서 서브 루틴이 첫 번째 인수로 오브젝트 또는 클래스 이름에 대한 참조를 예상 할 수 있다는 것입니다. 이것은 순전히 관습의 문제이므로 클래스에는 메소드와 서브 루틴이 모두 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5c3b122d3c32f38c2b6df0053286a38a52964b9" translate="yes" xml:space="preserve">
          <source>Perl does not provide any special syntax for defining a method. A method is simply a regular subroutine, and is declared with &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt;. What makes a method special is that it expects to receive either an object or a class name as its first argument.</source>
          <target state="translated">Perl은 메소드를 정의하기위한 특별한 구문을 제공하지 않습니다. 메소드는 단순히 일반 서브 루틴이며 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 로 선언됩니다 . 메소드를 특별하게 만드는 것은 오브젝트 또는 클래스 이름을 첫 번째 인수로 수신해야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cedf75e55d51d5b15900a202031f864d4002fc15" translate="yes" xml:space="preserve">
          <source>Perl doesn't match multiple characters in a bracketed character class unless the character that maps to them is explicitly mentioned, and it doesn't match them at all if the character class is inverted, which otherwise could be highly confusing. See &lt;a href=&quot;perlrecharclass#Bracketed-Character-Classes&quot;&gt;Bracketed Character Classes in perlrecharclass&lt;/a&gt;, and &lt;a href=&quot;perlrecharclass#Negation&quot;&gt;Negation in perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">괄호로 묶은 문자를 명시 적으로 언급하지 않으면 괄호로 묶은 문자 클래스에서 여러 문자가 일치하지 않으며, 문자 클래스가 반전 된 경우에는 문자가 일치하지 않으므로 혼동 될 수 있습니다. 참조 &lt;a href=&quot;perlrecharclass#Bracketed-Character-Classes&quot;&gt;perlrecharclass에 괄호 문자 클래스&lt;/a&gt; 및 &lt;a href=&quot;perlrecharclass#Negation&quot;&gt;perlrecharclass에서 부정&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="160ee861b96d9abcad026bc93515a6480468d14a" translate="yes" xml:space="preserve">
          <source>Perl doesn't officially have a no-op operator, but the bare constants &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; are special-cased not to produce a warning in void context, so you can for example safely do</source>
          <target state="translated">Perl은 공식적으로 no-op 연산자를 가지고 있지 않지만 베어 상수 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;1&lt;/code&gt; 은 빈 공간에서 경고를 생성하지 않도록 특수한 경우이므로 안전하게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee11bfd628d5bc290b395480aaa995c735fee62a" translate="yes" xml:space="preserve">
          <source>Perl doesn't understand &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; as numeric literals, but you can have them as strings, and Perl will convert them as needed: &quot;Inf&quot; + 1. (You can, however, import them from the POSIX extension; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; POSIX qw(Inf NaN);&lt;/code&gt; and then use them as literals.)</source>
          <target state="translated">Perl은 &lt;code&gt;Inf&lt;/code&gt; 와 &lt;code&gt;NaN&lt;/code&gt; 을 숫자 리터럴로 이해하지 못하지만 문자열로 사용할 수 있으며 Perl은 필요에 따라 &quot;Inf&quot;+ 1.로 변환합니다. 그러나 POSIX 확장에서 가져올 수 있습니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; POSIX qw(Inf NaN);&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용하십시오&lt;/a&gt; . (Inf NaN); 그런 다음 리터럴로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f06c7777ec6a9cec60c6bbba96236c8c49e10f30" translate="yes" xml:space="preserve">
          <source>Perl enables DECC$EFS_CASE_PRESERVE and DECC$ARGV_PARSE_STYLE by default. Note that the latter only takes effect when extended parse is set in the process in which Perl is running. When these features are explicitly disabled in the environment or the CRTL does not support them, Perl follows the traditional CRTL behavior of downcasing command-line arguments and returning file specifications in lower case only.</source>
          <target state="translated">Perl은 기본적으로 DECC $ EFS_CASE_PRESERVE 및 DECC $ ARGV_PARSE_STYLE을 활성화합니다. 후자는 Perl이 실행중인 프로세스에서 확장 구문 분석이 설정된 경우에만 적용됩니다. 이러한 기능이 환경에서 명시 적으로 비활성화되거나 CRTL이이를 지원하지 않는 경우 Perl은 명령 행 인수를 다운 소싱하고 파일 스펙을 소문자로만 리턴하는 기존 CRTL 동작을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="9a7ffa77beb4b5bfb6e9cd592ffc3d63fefd5d7f" translate="yes" xml:space="preserve">
          <source>Perl environment problems</source>
          <target state="translated">펄 환경 문제</target>
        </trans-unit>
        <trans-unit id="efd321f1d642a6164aeb6c6061ba19e8d5553328" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists($myarray[$key])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">펄 당량 : &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists($myarray[$key])&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1023174861c373cd70c764cd28a1ffe52c362de1" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; @array;&lt;/code&gt; .</source>
          <target state="translated">펄 당량 : &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; @array;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1efb4e8b7d1884210a677a24eedc3aaa4097d90" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; @new_array = ($scalar1, $scalar2, $scalar3...);&lt;/code&gt;</source>
          <target state="translated">펄 동등 : &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; @new_array = ($scalar1, $scalar2, $scalar3...);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="994d82ebaabf45f0326fee88481665e6c0ceb2c7" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop(@myarray);&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">펄 당량 : &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop(@myarray);&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0c448473e835de05f1fd2f4b0a4490f988bfea19" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt; @myarray, $elem;&lt;/code&gt; .</source>
          <target state="translated">펄 당량 : &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt; @myarray, $elem;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c7b86a8f8deba930918279e3c4fc84bda790f23" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift(@myarray);&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">펄 당량 : &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift(@myarray);&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b4b1f7bdfb013ea4679d96a3812b271f5a3c227d" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt; @myarray, ( (&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;) x $n );&lt;/code&gt;</source>
          <target state="translated">펄 당량 : &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt; @myarray, ( (&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;) x $n );&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="066d54dd7f117a044b123bb5ad4d4d8cf43e8b71" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;@myarray = ();&lt;/code&gt; .</source>
          <target state="translated">펄 당량 : &lt;code&gt;@myarray = ();&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cef9ffe6af51e7c258630229039bfd2bf1b03f4a" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;@{&quot;$name&quot;}&lt;/code&gt; .</source>
          <target state="translated">해당 펄 : &lt;code&gt;@{&quot;$name&quot;}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8aec2fb1965c42df65abc2f4f5003e7dd1e44262" translate="yes" xml:space="preserve">
          <source>Perl extension for BSD glob routine</source>
          <target state="translated">BSD glob 루틴을위한 Perl 확장</target>
        </trans-unit>
        <trans-unit id="24aff9b9093549c7d05ba26875dcbd18c62f3127" translate="yes" xml:space="preserve">
          <source>Perl extension for SHA-1/224/256/384/512</source>
          <target state="translated">SHA-1 / 224 / 256 / 384 / 512 용 Perl 확장</target>
        </trans-unit>
        <trans-unit id="403524ab53fcfa65297b5c6d11da8a41e9bdf68e" translate="yes" xml:space="preserve">
          <source>Perl extension for Version Objects</source>
          <target state="translated">버전 객체의 Perl 확장</target>
        </trans-unit>
        <trans-unit id="c24a560ca7260d4a2d7424b6161a53890073335c" translate="yes" xml:space="preserve">
          <source>Perl extension for sharing data structures between threads</source>
          <target state="translated">스레드간에 데이터 구조를 공유하기위한 Perl 확장</target>
        </trans-unit>
        <trans-unit id="3668aadc429b1304c6228d98dc9c4677872a86f1" translate="yes" xml:space="preserve">
          <source>Perl extension to manipulate DCL symbols</source>
          <target state="translated">DCL 심볼을 조작하기위한 Perl 확장</target>
        </trans-unit>
        <trans-unit id="b4ef3d43e200cfbf35d2a7b6f42754d585642e16" translate="yes" xml:space="preserve">
          <source>Perl extensions are packages which provide both XS and Perl code to add new functionality to perl. (XS is a meta-language which simplifies writing C code which interacts with Perl, see &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for more details.) The Perl code for an extension is treated like any other library module - it's made available in your script through the appropriate &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; statement, and usually defines a Perl package containing the extension.</source>
          <target state="translated">Perl 확장은 XS와 Perl 코드를 모두 제공하여 perl에 새로운 기능을 추가하는 패키지입니다. (XS는 펄과 상호 작용이 참조 C 코드 작성 단순화하는 메타 언어입니다 &lt;a href=&quot;perlxs&quot;&gt;perlxs을&lt;/a&gt; 자세한 내용을.) 확장에 대한 펄 코드가 다른 라이브러리 모듈처럼 취급 - 그것은 적절한 통해 스크립트에서 사용할 것 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 명령문으로 구성되며 일반적으로 확장을 포함하는 Perl 패키지를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="f81d1af8c2de641461c82be3969f85e5ad3bba8c" translate="yes" xml:space="preserve">
          <source>Perl flavors</source>
          <target state="translated">펄 맛</target>
        </trans-unit>
        <trans-unit id="7d53205939368bef651c20e6009f95c9046101c6" translate="yes" xml:space="preserve">
          <source>Perl for VMS supports redirection of input and output on the command line, using a subset of Bourne shell syntax:</source>
          <target state="translated">Perl for VMS는 Bourne 쉘 구문의 서브 세트를 사용하여 명령 행에서 입력 및 출력의 경로 재 지정을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="903e263457faf9b024e447e13142cbcffaf64dc8" translate="yes" xml:space="preserve">
          <source>Perl functions</source>
          <target state="translated">펄 함수</target>
        </trans-unit>
        <trans-unit id="5eab57fb6512949ddd22c0f3a298921f86d2bf10" translate="yes" xml:space="preserve">
          <source>Perl had to change internally to decouple &quot;bytes&quot; from &quot;characters&quot;. It is important that you too change your ideas, if you haven't already, so that &quot;byte&quot; and &quot;character&quot; no longer mean the same thing in your mind.</source>
          <target state="translated">Perl은 &quot;바이트&quot;를 &quot;문자&quot;에서 분리하기 위해 내부적으로 변경해야했습니다. 아직 아이디어를 바꾸지 않았다면, &quot;바이트&quot;와 &quot;캐릭터&quot;가 더 이상 같은 의미를 가지지 않도록하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="eb521c7add3b7379a78d9a6b6db7917dc107bbad" translate="yes" xml:space="preserve">
          <source>Perl has a mechanism for intermixing documentation with source code. While it's expecting the beginning of a new statement, if the compiler encounters a line that begins with an equal sign and a word, like this</source>
          <target state="translated">Perl에는 문서를 소스 코드와 혼합하는 메커니즘이 있습니다. 새로운 문장의 시작을 기대하고 있지만 컴파일러가 등호와 단어로 시작하는 줄을 발견하면</target>
        </trans-unit>
        <trans-unit id="1e3d0cb76e6880e13fbb5d4447acbcbd4213008d" translate="yes" xml:space="preserve">
          <source>Perl has a mechanism to help you generate simple reports and charts. To facilitate this, Perl helps you code up your output page close to how it will look when it's printed. It can keep track of things like how many lines are on a page, what page you're on, when to print page headers, etc. Keywords are borrowed from FORTRAN: format() to declare and write() to execute; see their entries in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;. Fortunately, the layout is much more legible, more like BASIC's PRINT USING statement. Think of it as a poor man's nroff(1).</source>
          <target state="translated">Perl에는 간단한 보고서 및 차트를 생성 할 수있는 메커니즘이 있습니다. 이를 용이하게하기 위해 Perl은 출력 페이지가 인쇄 될 때의 모양에 가깝게 코딩하도록 도와줍니다. 페이지에 몇 줄이 있는지, 어떤 페이지에 있는지, 언제 페이지 머리글을 인쇄 할 것인지 등을 추적 할 수 있습니다. FORTRAN에서 키워드를 빌립니다. format ()은 선언하고 write ()는 실행합니다. &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; 의 항목을 참조하십시오 . 다행스럽게도 레이아웃은 BASIC의 PRINT USING 문과 같이 훨씬 읽기 쉽습니다. 그것을 가난한 사람의 nroff (1)로 생각하십시오.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
