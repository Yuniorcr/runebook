<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="6dabe892652409d7baaf4ea9766517a9552179bd" translate="yes" xml:space="preserve">
          <source>Here's another simplistic example that illustrates the use of thread signalling in conjunction with a semaphore to provide rudimentary</source>
          <target state="translated">다음은 초보를 제공하기 위해 세마포어와 함께 스레드 신호 사용을 보여주는 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="de1305ff8bab2aad6bcd989ab04908e0dc517958" translate="yes" xml:space="preserve">
          <source>Here's another strategy: Open a pipe to yourself, using &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(MYSELF, &quot;|-&quot;)&lt;/code&gt; (see &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;) and always write() to MYSELF instead of STDOUT. Have your child process massage its STDIN to rearrange headers and footers however you like. Not very convenient, but doable.</source>
          <target state="translated">또 다른 전략은 다음과 같습니다. &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(MYSELF, &quot;|-&quot;)&lt;/code&gt; 사용하여 파이프를 열고 ( &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; 참조 ) 항상 STDOUT 대신 MYSELF에 write ()하십시오. 아이가 STDIN을 마사지하여 머리글과 바닥 글을 원하는대로 재 배열하도록하십시오. 매우 편리하지는 않지만 실행 가능합니다.</target>
        </trans-unit>
        <trans-unit id="5ac230c93491a8097772635d05027ee087235965" translate="yes" xml:space="preserve">
          <source>Here's another way to check for sentences in a paragraph:</source>
          <target state="translated">단락에서 문장을 확인하는 또 다른 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="273a17fa15878be17fe206b05c8584be04a69acf" translate="yes" xml:space="preserve">
          <source>Here's another, slightly less painful, way to do it from Benjamin Goldberg, who uses a zero-width negative look-behind assertion.</source>
          <target state="translated">너비가 0 인 음수 비하인드 어설 션을 사용하는 Benjamin Goldberg의 약간 덜 고통스러운 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cddef9286505d532aaa041e36320e67de4b2c80" translate="yes" xml:space="preserve">
          <source>Here's another; let's compute spherical volumes:</source>
          <target state="translated">여기 또 다른 것이 있습니다. 구형 볼륨을 계산해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="15dc729f18ba699bddbeda2935fed34db64f6cdb" translate="yes" xml:space="preserve">
          <source>Here's code that finds everything between START and END in a paragraph:</source>
          <target state="translated">단락에서 START와 END 사이의 모든 것을 찾는 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="26eff15275e0bc723eda9623b566a21d7d660ee9" translate="yes" xml:space="preserve">
          <source>Here's how a C programmer might code up a particular algorithm in Perl:</source>
          <target state="translated">C 프로그래머가 Perl에서 특정 알고리즘을 코딩하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c646f07c7dfa6ee86de30d8e7226eba37cb787f8" translate="yes" xml:space="preserve">
          <source>Here's how to do one operation using a loop. We'll assume an @AoA variable as before.</source>
          <target state="translated">루프를 사용하여 하나의 작업을 수행하는 방법은 다음과 같습니다. 이전과 같이 @AoA 변수를 가정합니다.</target>
        </trans-unit>
        <trans-unit id="268a5d49f5ba74b653796a536ebf6253b796189f" translate="yes" xml:space="preserve">
          <source>Here's how to perform each step for each operating system. This is &amp;lt;not&amp;gt; a substitute for reading the README and INSTALL files that might have come with your module!</source>
          <target state="translated">각 운영 체제에 대해 각 단계를 수행하는 방법은 다음과 같습니다. 이것은 모듈과 함께 제공 될 수있는 README 및 INSTALL 파일을 대신하는 &amp;lt;not&amp;gt;입니다!</target>
        </trans-unit>
        <trans-unit id="f61d7cd6d889dcf489e482c04dbdd66a13cc2eb1" translate="yes" xml:space="preserve">
          <source>Here's how to use &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;\G&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;\G&lt;/code&gt; 와 함께 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; 를 사용하는 방법은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="72b07fa8c9ee5cfa969d3c94936ee2dff05c5e76" translate="yes" xml:space="preserve">
          <source>Here's how to use our little example:</source>
          <target state="translated">작은 예제를 사용하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f9a1c6d8d1b1e5ebc9092a952afe3520c4d3df94" translate="yes" xml:space="preserve">
          <source>Here's how we can make the first example safer:</source>
          <target state="translated">첫 번째 예제를보다 안전하게 만드는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1c3c6addf8c05cad39d9f725c53d0c79d67cc1b7" translate="yes" xml:space="preserve">
          <source>Here's how you might write a function that returns a list of keys occurring in all the hashes passed to it:</source>
          <target state="translated">전달 된 모든 해시에서 발생하는 키 목록을 반환하는 함수를 작성하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ae2023d3bcf8a706017206316be16158eb0a8503" translate="yes" xml:space="preserve">
          <source>Here's how you'd compile the example in the next section, &lt;a href=&quot;#Adding-a-Perl-interpreter-to-your-C-program&quot;&gt;Adding a Perl interpreter to your C program&lt;/a&gt;, on my Linux box:</source>
          <target state="translated">다음은 리눅스 상자에서 &lt;a href=&quot;#Adding-a-Perl-interpreter-to-your-C-program&quot;&gt;C 프로그램에 Perl 인터프리터 추가&lt;/a&gt; 섹션의 예제를 컴파일하는 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="3c91b848d807e7b04b1ab06ec49ea4392d7ec7d3" translate="yes" xml:space="preserve">
          <source>Here's how, given a vector in &lt;code&gt;$vec&lt;/code&gt; , you can get those bits into your &lt;code&gt;@ints&lt;/code&gt; array:</source>
          <target state="translated">&lt;code&gt;$vec&lt;/code&gt; 의 벡터가 주어지면 &lt;code&gt;@ints&lt;/code&gt; 배열에 해당 비트를 얻는 방법은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="22975b2012514ff308ba25754da36c22aeb6ce2b" translate="yes" xml:space="preserve">
          <source>Here's one strategy: If you have a fixed-size footer, you can get footers by checking $FORMAT_LINES_LEFT before each write() and print the footer yourself if necessary.</source>
          <target state="translated">한 가지 전략이 있습니다. 고정 크기 바닥 글이있는 경우 각 write () 전에 $ FORMAT_LINES_LEFT를 확인하여 바닥 글을 가져와 필요한 경우 바닥 글을 직접 인쇄 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="525e3062fa27a1689f30b9419dfa2b5e57815b15" translate="yes" xml:space="preserve">
          <source>Here's our &lt;code&gt;File&lt;/code&gt; class once more:</source>
          <target state="translated">&lt;code&gt;File&lt;/code&gt; 클래스는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="b1783e928a570b5dc6d74dafaff14364959e7e0f" translate="yes" xml:space="preserve">
          <source>Here's our &lt;code&gt;File&lt;/code&gt; class with &lt;code&gt;Class::Accessor&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;Class::Accessor&lt;/code&gt; &lt;code&gt;File&lt;/code&gt; 클래스는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="57354b9e0e2f7e59368dea0a84947b0e2a0827cd" translate="yes" xml:space="preserve">
          <source>Here's some advice: supply a creation mode of &lt;code&gt;0666&lt;/code&gt; for regular files (in &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;) and one of &lt;code&gt;0777&lt;/code&gt; for directories (in &lt;code&gt;&lt;a href=&quot;functions/mkdir&quot;&gt;mkdir&lt;/a&gt;&lt;/code&gt;) and executable files. This gives users the freedom of choice: if they want protected files, they might choose process umasks of &lt;code&gt;022&lt;/code&gt; , &lt;code&gt;027&lt;/code&gt; , or even the particularly antisocial mask of &lt;code&gt;077&lt;/code&gt; . Programs should rarely if ever make policy decisions better left to the user. The exception to this is when writing files that should be kept private: mail files, web browser cookies,</source>
          <target state="translated">다음은 몇 가지 조언입니다. 일반 파일 ( &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; ) 의 경우 &lt;code&gt;0666&lt;/code&gt; , 디렉토리 ( &lt;code&gt;&lt;a href=&quot;functions/mkdir&quot;&gt;mkdir&lt;/a&gt;&lt;/code&gt; ) 및 실행 파일 의 경우 &lt;code&gt;0777&lt;/code&gt; 중 하나를 작성 하십시오. 따라서 보호 된 파일을 원할 경우 프로세스 umask &lt;code&gt;022&lt;/code&gt; , &lt;code&gt;027&lt;/code&gt; 또는 특히 반사회적 마스크 &lt;code&gt;077&lt;/code&gt; 을 선택할 수 있습니다 . 정책 결정을 사용자에게 더 잘 맡기는 경우가 거의 없습니다. 단, 비공개로 유지해야하는 파일 (메일 파일, 웹 브라우저 쿠키,</target>
        </trans-unit>
        <trans-unit id="e2752daa5f028f44257bc9623ea0f7f9230b9d85" translate="yes" xml:space="preserve">
          <source>Here's some advice: supply a creation mode of &lt;code&gt;0666&lt;/code&gt; for regular files (in &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;) and one of &lt;code&gt;0777&lt;/code&gt; for directories (in &lt;code&gt;&lt;a href=&quot;mkdir&quot;&gt;mkdir&lt;/a&gt;&lt;/code&gt;) and executable files. This gives users the freedom of choice: if they want protected files, they might choose process umasks of &lt;code&gt;022&lt;/code&gt; , &lt;code&gt;027&lt;/code&gt; , or even the particularly antisocial mask of &lt;code&gt;077&lt;/code&gt; . Programs should rarely if ever make policy decisions better left to the user. The exception to this is when writing files that should be kept private: mail files, web browser cookies,</source>
          <target state="translated">다음은 몇 가지 조언입니다. 일반 파일 ( &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; ) 의 경우 &lt;code&gt;0666&lt;/code&gt; , 디렉토리 ( &lt;code&gt;&lt;a href=&quot;mkdir&quot;&gt;mkdir&lt;/a&gt;&lt;/code&gt; ) 및 실행 파일 의 경우 &lt;code&gt;0777&lt;/code&gt; 중 하나를 작성 하십시오. 따라서 보호 된 파일을 원할 경우 프로세스 umask &lt;code&gt;022&lt;/code&gt; , &lt;code&gt;027&lt;/code&gt; 또는 특히 반사회적 마스크 &lt;code&gt;077&lt;/code&gt; 을 선택할 수 있습니다 . 정책 결정을 사용자에게 더 잘 맡기는 경우가 거의 없습니다. 단, 비공개로 유지해야하는 파일 (메일 파일, 웹 브라우저 쿠키,</target>
        </trans-unit>
        <trans-unit id="4ed39bdc449f7cf4b3c38e3ffdf7cd70fa08f940" translate="yes" xml:space="preserve">
          <source>Here's some code that finds sentences that begin with &quot;From &quot; (which would be mangled by many mailers):</source>
          <target state="translated">다음은 &quot;보낸 사람&quot;으로 시작하는 문장을 찾는 코드입니다.</target>
        </trans-unit>
        <trans-unit id="aa42825d4fc178008e13f884fd63afc0d6bcd50d" translate="yes" xml:space="preserve">
          <source>Here's some entries from the output of the property &quot;Nv&quot;, which has format &lt;code&gt;&quot;ar&quot;&lt;/code&gt; .</source>
          <target state="translated">다음은 &lt;code&gt;&quot;ar&quot;&lt;/code&gt; 형식의 &quot; Nv&quot;속성 출력 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="983afceb3200f14ad7cf769e6f457a540b745124" translate="yes" xml:space="preserve">
          <source>Here's some more recommendations</source>
          <target state="translated">몇 가지 권장 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="425356b04c5e4659def26c3afe717def29a81e4c" translate="yes" xml:space="preserve">
          <source>Here's something Larry suggested: if a &lt;code&gt;U&lt;/code&gt; is the first active format during a &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, (for example, &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; &quot;U3C8&quot;, @stuff&lt;/code&gt; ) then the resulting string should be treated as UTF-8 encoded.</source>
          <target state="translated">Larry가 제안한 내용은 다음과 같습니다. &lt;code&gt;U&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 동안 첫 번째 활성 형식 인 경우 (예 : &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; &quot;U3C8&quot;, @stuff&lt;/code&gt; ) 결과 문자열은 UTF-8 인코딩으로 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="b314a6f828aa6ba79d336b2bc1f9e451bb9826c7" translate="yes" xml:space="preserve">
          <source>Here's that program; tested on v5.14.</source>
          <target state="translated">그 프로그램은 다음과 같습니다. v5.14에서 테스트되었습니다.</target>
        </trans-unit>
        <trans-unit id="7c1fe856f88363dd186e2e7ada6054be89d9b374" translate="yes" xml:space="preserve">
          <source>Here's the answer to the problem I posed earlier, of reformatting a file of city and country names.</source>
          <target state="translated">여기에 도시 및 국가 이름 파일을 다시 포맷하는 문제에 대한 답변이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec2064253b0b50a2575cd193f528ea54b5bba134" translate="yes" xml:space="preserve">
          <source>Here's the case of taking a reference to the same memory location again and again:</source>
          <target state="translated">동일한 메모리 위치를 반복해서 참조하는 경우는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="687ec9bc2da6b7d16d8a23c230dfb7c1307404b0" translate="yes" xml:space="preserve">
          <source>Here's the code. We'll</source>
          <target state="translated">코드는 다음과 같습니다. 잘</target>
        </trans-unit>
        <trans-unit id="22e52845e690ffb85ae425e49263d746dcf8be45" translate="yes" xml:space="preserve">
          <source>Here's the code:</source>
          <target state="translated">코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="92d590121c2fc19f8a6623b373db411150058833" translate="yes" xml:space="preserve">
          <source>Here's the constructor:</source>
          <target state="translated">생성자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="67de0300ad7e657a8db469b4cb89cf11ed0c9b15" translate="yes" xml:space="preserve">
          <source>Here's the fetch for our DotFiles example.</source>
          <target state="translated">다음은 DotFiles 예제의 페치입니다.</target>
        </trans-unit>
        <trans-unit id="ea37c8a435a5d1ae861daa3601c34204e044ad1a" translate="yes" xml:space="preserve">
          <source>Here's the general rule: When you approach a task commonly done using a whole range of platforms, think about writing portable code. That way, you don't sacrifice much by way of the implementation choices you can avail yourself of, and at the same time you can give your users lots of platform choices. On the other hand, when you have to take advantage of some unique feature of a particular platform, as is often the case with systems programming (whether for Unix, Windows, VMS, etc.), consider writing platform-specific code.</source>
          <target state="translated">일반적인 규칙은 다음과 같습니다. 광범위한 플랫폼을 사용하여 일반적으로 수행되는 작업에 접근 할 때 이식 가능한 코드 작성을 고려하십시오. 그렇게하면, 당신이 이용할 수있는 구현 선택에 의해 많은 것을 희생하지 않으며, 동시에 사용자에게 많은 플랫폼 선택을 줄 수 있습니다. 반면, 시스템 프로그래밍 (유닉스, Windows, VMS 등)의 경우와 같이 특정 플랫폼의 고유 한 기능을 활용해야하는 경우 플랫폼 별 코드 작성을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="b5763f4294d53b8fde1e0d145ff3e1ebda9932aa" translate="yes" xml:space="preserve">
          <source>Here's the start of</source>
          <target state="translated">여기에 시작입니다</target>
        </trans-unit>
        <trans-unit id="62dfcd0f3177b39de6db7b0fd66738d0abd59908" translate="yes" xml:space="preserve">
          <source>Here's two outputs (or 'renderings'), using the -exec and -basic (i.e. default) formatting conventions on the same code snippet.</source>
          <target state="translated">다음은 동일한 코드 스 니펫에서 -exec 및 -basic (예 : 기본) 형식 지정 규칙을 사용하는 두 가지 출력 (또는 '렌더링')입니다.</target>
        </trans-unit>
        <trans-unit id="b7e6198c27f03baf5a7cf4c101c7cbf2083f6919" translate="yes" xml:space="preserve">
          <source>Here's what happens: when Perl reads in a string literal, it sticks to 8 bit encoding as long as it can. (But perhaps originally it was internally encoded as UTF-8, when you dumped it.) When it has to give that up because other characters are added to the text string, it silently upgrades the string to UTF-8.</source>
          <target state="translated">Perl이 문자열 리터럴을 읽을 때 가능한 한 8 비트 인코딩을 고수합니다. (그러나 원래는 덤프했을 때 내부적으로 UTF-8로 인코딩되었습니다.) 다른 문자가 텍스트 문자열에 추가되어 포기하면 문자열을 UTF-8로 자동 업그레이드합니다.</target>
        </trans-unit>
        <trans-unit id="3d080817ae211b70ffb8548327b1435f255163a6" translate="yes" xml:space="preserve">
          <source>Here,</source>
          <target state="translated">Here,</target>
        </trans-unit>
        <trans-unit id="664fb069ea88b967ad1512f692644a45d6f7de10" translate="yes" xml:space="preserve">
          <source>Here, &quot;=head1 Foo&quot; and &quot;=cut&quot; are command paragraphs because the first line of each matches &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=[a-zA-Z]/&lt;/a&gt;&lt;/code&gt;. &quot;</source>
          <target state="translated">여기서 &quot;= head1 Foo&quot;와 &quot;= cut&quot;은 각각의 첫 번째 줄이 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=[a-zA-Z]/&lt;/a&gt;&lt;/code&gt; 와 일치하기 때문에 명령 단락입니다. 입니다. &quot;</target>
        </trans-unit>
        <trans-unit id="0b2d91e5d5873ea3e50cabcf6bf495277d88e43b" translate="yes" xml:space="preserve">
          <source>Here, $subroutine is the function that the caller called (rather than the function containing the caller). Note that $subroutine may be &lt;code&gt;(&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;)&lt;/code&gt; if the frame is not a subroutine call, but an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;. In such a case additional elements $evaltext and &lt;code&gt;$is_require&lt;/code&gt; are set: &lt;code&gt;$is_require&lt;/code&gt; is true if the frame is created by a &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement, $evaltext contains the text of the &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; EXPR&lt;/code&gt; statement. In particular, for an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; BLOCK&lt;/code&gt; statement, $subroutine is &lt;code&gt;(&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;)&lt;/code&gt; , but $evaltext is undefined. (Note also that each &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement creates a &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; frame inside an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; EXPR&lt;/code&gt; frame.) $subroutine may also be &lt;code&gt;(unknown)&lt;/code&gt; if this particular subroutine happens to have been deleted from the symbol table. &lt;code&gt;$hasargs&lt;/code&gt; is true if a new instance of &lt;code&gt;@_&lt;/code&gt; was set up for the frame. &lt;code&gt;$hints&lt;/code&gt; and &lt;code&gt;$bitmask&lt;/code&gt; contain pragmatic hints that the caller was compiled with. &lt;code&gt;$hints&lt;/code&gt; corresponds to &lt;code&gt;$^H&lt;/code&gt; , and &lt;code&gt;$bitmask&lt;/code&gt; corresponds to &lt;code&gt;${^WARNING_BITS}&lt;/code&gt; . The &lt;code&gt;$hints&lt;/code&gt; and &lt;code&gt;$bitmask&lt;/code&gt; values are subject to change between versions of Perl, and are not meant for external use.</source>
          <target state="translated">여기서 $ subroutine은 호출자가 포함 된 함수가 아니라 호출자가 호출 한 함수입니다. 주 $ 서브 루틴이 될 수 있음 &lt;code&gt;(&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;)&lt;/code&gt; 프레임이 서브 루틴 호출하지만,없는 경우 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; . 이러한 경우 $ evaltext 및 &lt;code&gt;$is_require&lt;/code&gt; 요소가 추가 로 설정됩니다. &lt;code&gt;$is_require&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 문으로 프레임을 만들면 true 이고 $ evaltext는 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; EXPR&lt;/code&gt; 문의 텍스트를 포함합니다 . 특히 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; BLOCK&lt;/code&gt; 문의 경우 $ subroutine은 &lt;code&gt;(&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;)&lt;/code&gt; 이지만 $ evaltext는 정의되어 있지 않습니다. (또한 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement 는 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; EXPR&lt;/code&gt; EXPR 프레임 내에 &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 프레임을 만듭니다 .) 이 특정 서브 루틴이 심볼 테이블에서 삭제 된 경우 $ subroutine도 &lt;code&gt;(unknown)&lt;/code&gt; . &lt;code&gt;$hasargs&lt;/code&gt; 는 새 인스턴스 인 &lt;code&gt;@_&lt;/code&gt; 있으면 참 와 &lt;code&gt;$bitmask&lt;/code&gt; 는 호출자가 컴파일 한 실용적인 힌트를 포함합니다. &lt;code&gt;$hints&lt;/code&gt; 는 &lt;code&gt;$^H&lt;/code&gt; 에 해당 하고 &lt;code&gt;$bitmask&lt;/code&gt; 는 &lt;code&gt;${^WARNING_BITS}&lt;/code&gt; 해당합니다 . &lt;code&gt;$hints&lt;/code&gt; 와 값은 펄 버전 간의 변경 될 수 있으며, 외부에는 적합하지 않습니다.프레임에 설정되었습니다. &lt;code&gt;$hints&lt;/code&gt; &lt;code&gt;$bitmask&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0cf857d30373eeccb44d9f659b21b0118b696cbc" translate="yes" xml:space="preserve">
          <source>Here, $subroutine is the function that the caller called (rather than the function containing the caller). Note that $subroutine may be &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;)&lt;/code&gt; if the frame is not a subroutine call, but an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;. In such a case additional elements $evaltext and &lt;code&gt;$is_require&lt;/code&gt; are set: &lt;code&gt;$is_require&lt;/code&gt; is true if the frame is created by a &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement, $evaltext contains the text of the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; EXPR&lt;/code&gt; statement. In particular, for an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; BLOCK&lt;/code&gt; statement, $subroutine is &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;)&lt;/code&gt; , but $evaltext is undefined. (Note also that each &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement creates a &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; frame inside an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; EXPR&lt;/code&gt; frame.) $subroutine may also be &lt;code&gt;(unknown)&lt;/code&gt; if this particular subroutine happens to have been deleted from the symbol table. &lt;code&gt;$hasargs&lt;/code&gt; is true if a new instance of &lt;code&gt;@_&lt;/code&gt; was set up for the frame. &lt;code&gt;$hints&lt;/code&gt; and &lt;code&gt;$bitmask&lt;/code&gt; contain pragmatic hints that the caller was compiled with. &lt;code&gt;$hints&lt;/code&gt; corresponds to &lt;code&gt;$^H&lt;/code&gt; , and &lt;code&gt;$bitmask&lt;/code&gt; corresponds to &lt;code&gt;${^WARNING_BITS}&lt;/code&gt; . The &lt;code&gt;$hints&lt;/code&gt; and &lt;code&gt;$bitmask&lt;/code&gt; values are subject to change between versions of Perl, and are not meant for external use.</source>
          <target state="translated">여기서 $ subroutine은 호출자가 포함 된 함수가 아니라 호출자가 호출 한 함수입니다. 주 $ 서브 루틴이 될 수 있음 &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;)&lt;/code&gt; 프레임이 서브 루틴 호출하지만,없는 경우 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; . 이러한 경우 $ evaltext 및 &lt;code&gt;$is_require&lt;/code&gt; 요소가 추가 로 설정됩니다. &lt;code&gt;$is_require&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 문으로 프레임을 만들면 true 이고 $ evaltext는 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; EXPR&lt;/code&gt; 문의 텍스트를 포함합니다 . 특히 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; BLOCK&lt;/code&gt; 문의 경우 $ subroutine은 &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;)&lt;/code&gt; 이지만 $ evaltext는 정의되어 있지 않습니다. (또한 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement 는 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; EXPR&lt;/code&gt; EXPR 프레임 내에 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 프레임을 만듭니다 .) 이 특정 서브 루틴이 심볼 테이블에서 삭제 된 경우 $ subroutine도 &lt;code&gt;(unknown)&lt;/code&gt; . &lt;code&gt;$bitmask&lt;/code&gt; 는 호출자가 컴파일 한 실용적인 힌트를 포함합니다. &lt;code&gt;$hints&lt;/code&gt; 는 &lt;code&gt;$^H&lt;/code&gt; 에 해당 하고 &lt;code&gt;$bitmask&lt;/code&gt; 는 &lt;code&gt;${^WARNING_BITS}&lt;/code&gt; 해당합니다 . &lt;code&gt;$hints&lt;/code&gt; 와 값은 펄 버전 간의 변경 될 수 있으며, 외부에는 적합하지 않습니다. &lt;code&gt;$hasargs&lt;/code&gt; 의 새로운 인스턴스 마찬가지입니다 &lt;code&gt;@_&lt;/code&gt; 이 프레임에 설정되었다. &lt;code&gt;$hints&lt;/code&gt; 와 &lt;code&gt;$bitmask&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="caa26f85e260be75edcd0346a364ee2896d298ec" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;(?&amp;gt;[^()]+)&lt;/code&gt; breaks the degeneracy of string partitioning by gobbling up as much of the string as possible and keeping it. Then match failures fail much more quickly.</source>
          <target state="translated">여기에서 &lt;code&gt;(?&amp;gt;[^()]+)&lt;/code&gt; 는 가능한 한 많은 문자열을 가져 와서 유지함으로써 문자열 분할의 축 퇴성을 깨뜨립니다. 그러면 일치 실패가 훨씬 빨리 실패합니다.</target>
        </trans-unit>
        <trans-unit id="a1b989b57eb518dccad89ad922a4fe2c3b8290b8" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;.?&lt;/code&gt; eats its maximal one character at the earliest possible position in the string, &lt;code&gt;'a'&lt;/code&gt; in &lt;code&gt;programming&lt;/code&gt; , leaving &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m{1,2}&lt;/a&gt;&lt;/code&gt; the opportunity to match both &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt;'s. Finally,</source>
          <target state="translated">여기 &lt;code&gt;.?&lt;/code&gt; 문자열에서 가능한 가장 빠른 위치에서 최대 한 문자를 먹습니다. &lt;code&gt;'a'&lt;/code&gt; 에서 &lt;code&gt;programming&lt;/code&gt; , 떠나 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m{1,2}&lt;/a&gt;&lt;/code&gt; 모두 일치 할 수있는 기회 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 의합니다. 드디어,</target>
        </trans-unit>
        <trans-unit id="a4a0735ee9beb6f441c46c7bd92351e785038614" translate="yes" xml:space="preserve">
          <source>Here, The earliest possible match is at the first &lt;code&gt;'m'&lt;/code&gt; in &lt;code&gt;programming&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m{1,2}&lt;/a&gt;&lt;/code&gt; is the first quantifier, so it gets to match a maximal &lt;code&gt;mm&lt;/code&gt; .</source>
          <target state="translated">가장 빠른 시합은 처음입니다 &lt;code&gt;'m'&lt;/code&gt; &lt;code&gt;programming&lt;/code&gt; 'm' 입니다 . &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m{1,2}&lt;/a&gt;&lt;/code&gt; 는 첫 번째 수량 자이므로 최대 &lt;code&gt;mm&lt;/code&gt; 과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="3716a6d294692219d3cd1801d8d99a5dbba94e08" translate="yes" xml:space="preserve">
          <source>Here, all the alternatives match at the first string position, so the first alternative is the one that matches. If some of the alternatives are truncations of the others, put the longest ones first to give them a chance to match.</source>
          <target state="translated">여기에서 모든 대안은 첫 번째 문자열 위치에서 일치하므로 첫 번째 대안은 일치하는 대안입니다. 일부 대안이 다른 대안보다 잘린 경우 가장 긴 대안을 먼저 배치하여 일치시킬 수있는 기회를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="689480ae64fc1f47a0a934be3391ff1dd20b6f51" translate="yes" xml:space="preserve">
          <source>Here, code is written for all the currently linked extensions along with code for &lt;code&gt;DBI&lt;/code&gt; and &lt;code&gt;DBD::Oracle&lt;/code&gt; .</source>
          <target state="translated">여기에는 현재 연결된 모든 확장에 대한 코드와 &lt;code&gt;DBI&lt;/code&gt; 및 &lt;code&gt;DBD::Oracle&lt;/code&gt; 코드가 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="6aaaa9a188728345ceda0023a2930141166a0d68" translate="yes" xml:space="preserve">
          <source>Here, the code points 0x964 and 0x965 are both used in Bengali, Devanagari, Gurmukhi, and Oriya, but no other scripts.</source>
          <target state="translated">여기서 코드 포인트 0x964 및 0x965는 모두 벵골어, 데바 나가리, 구르 무키 및 오리 야에서 사용되지만 다른 스크립트는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c6406af5e03eb4f4938f3da32dd26a4c74c548ed" translate="yes" xml:space="preserve">
          <source>Here, the regexp matches at the start of the string. The first quantifier &lt;code&gt;.*&lt;/code&gt; grabs as much as possible, leaving just a single &lt;code&gt;'m'&lt;/code&gt; for the second quantifier &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m{1,2}&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">여기서 정규 표현식은 문자열의 시작 부분과 일치합니다. 첫 번째 수량 자 &lt;code&gt;.*&lt;/code&gt; 는 가능한 한 많이 잡아 단일 &lt;code&gt;'m'&lt;/code&gt; 두 번째 수량 자 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m{1,2}&lt;/a&gt;&lt;/code&gt; 대해 'm' .</target>
        </trans-unit>
        <trans-unit id="7d40285a9c3c8ccdbd6762112a10bef59352519d" translate="yes" xml:space="preserve">
          <source>Here, when the '$a' in the eval is being compiled, f() is not currently being executed, so its $a is not available for capture.</source>
          <target state="translated">여기서 eval의 '$ a'를 컴파일 할 때 f ()가 현재 실행되고 있지 않으므로 $ a를 캡처 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="dd7c1c3b995f345fd62ac66cfeb3e09d91946309" translate="yes" xml:space="preserve">
          <source>Here, when the '\&amp;amp;a' in the eval is being compiled, f() is not currently being executed, so its &amp;amp;a is not available for capture.</source>
          <target state="translated">여기서 eval의 '\ &amp;amp; a'를 컴파일 할 때 f ()가 현재 실행되고 있지 않으므로 &amp;amp; a를 캡처 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ede19d3c74e6b3a68c4bd3de5c03f1c72f2ba22c" translate="yes" xml:space="preserve">
          <source>Hex strings may only represent integers. Strings that would cause integer overflow trigger a warning. Leading whitespace is not stripped, unlike oct(). To present something as hex, look into &lt;a href=&quot;#printf&quot;&gt;printf&lt;/a&gt;, &lt;a href=&quot;#sprintf&quot;&gt;sprintf&lt;/a&gt;, and &lt;a href=&quot;#unpack&quot;&gt;unpack&lt;/a&gt;.</source>
          <target state="translated">16 진 문자열은 정수만 나타낼 수 있습니다. 정수 오버 플로우를 유발하는 문자열은 경고를 트리거합니다. oct ()와 달리 선행 공백은 제거되지 않습니다. 16 진수로 표현하려면 &lt;a href=&quot;#printf&quot;&gt;printf&lt;/a&gt; , &lt;a href=&quot;#sprintf&quot;&gt;sprintf&lt;/a&gt; 및&lt;a href=&quot;#unpack&quot;&gt; unpack을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d4ab04b2f53a36bbb2dc5c2deb103b3c069c62c2" translate="yes" xml:space="preserve">
          <source>Hex strings may only represent integers. Strings that would cause integer overflow trigger a warning. Leading whitespace is not stripped, unlike oct(). To present something as hex, look into &lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;, &lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;, and &lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;.</source>
          <target state="translated">16 진 문자열은 정수만 나타낼 수 있습니다. 정수 오버 플로우를 유발하는 문자열은 경고를 트리거합니다. oct ()와 달리 선행 공백은 제거되지 않습니다. 16 진수로 표현하려면 &lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt; , &lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt; 및&lt;a href=&quot;unpack&quot;&gt; unpack을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f63676066d11c05b5d8b9b8be78e1e17f582eed6" translate="yes" xml:space="preserve">
          <source>Hexadecimal (prefixed with &quot;0x&quot;) and binary numbers (prefixed with &quot;0b&quot;) are accepted, too. Please note that octal numbers are not recognized by new(), so the following will print &quot;123&quot;:</source>
          <target state="translated">16 진수 ( &quot;0x&quot;접두사)와 2 진수 ( &quot;0b&quot;접두사)도 사용할 수 있습니다. 8 진수는 new ()로 인식되지 않으므로 다음은 &quot;123&quot;을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="2486d235457d8e2812e9f4481543bdfa3dc85c5e" translate="yes" xml:space="preserve">
          <source>Hexadecimal Notation</source>
          <target state="translated">16 진법</target>
        </trans-unit>
        <trans-unit id="d754dce244e30fbc42722c0d0d3408fc0e8b5ff5" translate="yes" xml:space="preserve">
          <source>Hexadecimal escapes</source>
          <target state="translated">16 진수 탈출</target>
        </trans-unit>
        <trans-unit id="0055aac53ab95723749bf6b5bb8f9b5857c75d3e" translate="yes" xml:space="preserve">
          <source>Hexadecimal floating point can start just like a hexadecimal literal, and it can be followed by an optional fractional hexadecimal part, but it must be followed by &lt;code&gt;p&lt;/code&gt; , an optional sign, and a power of two. The format is useful for accurately presenting floating point values, avoiding conversions to or from decimal floating point, and therefore avoiding possible loss in precision. Notice that while most current platforms use the 64-bit IEEE 754 floating point, not all do. Another potential source of (low-order) differences are the floating point rounding modes, which can differ between CPUs, operating systems, and compilers, and which Perl doesn't control.</source>
          <target state="translated">16 진 부동 소수점은 16 진 리터럴처럼 시작할 수 있으며 선택적 16 진 16 진 부분이 올 수 있지만 &lt;code&gt;p&lt;/code&gt; 뒤에는 선택적 부호와 2의 거듭 제곱이 와야합니다 . 이 형식은 부동 소수점 값을 정확하게 표시하고 십진 부동 소수점으로 또는 소수 부동 소수점으로의 변환을 피하여 가능한 정밀도 손실을 피하는 데 유용합니다. 대부분의 최신 플랫폼은 64 비트 IEEE 754 부동 소수점을 사용하지만 모든 플랫폼을 사용하는 것은 아닙니다. (낮은 순서의) 차이점의 또 다른 잠재적 원인은 부동 소수점 반올림 모드로, CPU, 운영 체제 및 컴파일러마다 다를 수 있으며 Perl이 제어하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c5f839007ffa6c33e78ea32b2edbfe75db988fef" translate="yes" xml:space="preserve">
          <source>Hexadecimal, octal, or binary, representations in string literals (e.g. '0xff') are not automatically converted to their integer representation. The hex() and oct() functions make these conversions for you. See &lt;a href=&quot;functions/hex&quot;&gt;hex&lt;/a&gt; and &lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt; for more details.</source>
          <target state="translated">문자열 리터럴의 16 진, 8 진 또는 2 진 표현 (예 : '0xff')은 정수 표현으로 자동 변환되지 않습니다. hex () 및 oct () 함수는 이러한 변환을 수행합니다. &lt;a href=&quot;functions/hex&quot;&gt;16 진수&lt;/a&gt; 및 &lt;a href=&quot;functions/oct&quot;&gt;10 &lt;/a&gt;진수 참조 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="af0d47fb48d369e779ea66f99b77ac3ba09d56e3" translate="yes" xml:space="preserve">
          <source>Hey, isn't Perl supposed to make this sort of thing easy? Well, it does, if you use the right tools. &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; are designed to help you out when dealing with fixed-width data like the above. Let's have a look at a solution with &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">이봐, 펄은 이런 종류의 일을 쉬워야하지 않니? 올바른 도구를 사용하면 좋습니다. &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 은 위와 같은 고정 너비 데이터를 처리 할 때 도움이되도록 설계되었습니다. &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 을 사용하여 솔루션을 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="38419124bd7b06ea4fc82f2ec5707cd4239617e6" translate="yes" xml:space="preserve">
          <source>Hiding Perl_</source>
          <target state="translated">Perl_ 숨기기</target>
        </trans-unit>
        <trans-unit id="1428b1718a9c369e65d9d918143e0a1d8ca542e9" translate="yes" xml:space="preserve">
          <source>Hiding or invalidating some other definition of the same name. (Not to be confused with &lt;b&gt;overloading&lt;/b&gt;, which adds definitions that must be disambiguated some other way.) To confuse the issue further, we use the word with two overloaded definitions: to describe how you can define your own &lt;b&gt;subroutine&lt;/b&gt; to hide a built-in &lt;b&gt;function&lt;/b&gt; of the same name (see the section &amp;ldquo;Overriding Built-in Functions&amp;rdquo; in Camel chapter 11, &amp;ldquo;Modules&amp;rdquo;), and to describe how you can define a replacement &lt;b&gt;method&lt;/b&gt; in a &lt;b&gt;derived class&lt;/b&gt; to hide a &lt;b&gt;base class&lt;/b&gt;&amp;rsquo;s method of the same name (see Camel chapter 12, &amp;ldquo;Objects&amp;rdquo;).</source>
          <target state="translated">동일한 이름의 다른 정의를 숨기거나 무효화합니다. (와 혼동되지 않기 &lt;b&gt;오버로드&lt;/b&gt; . 다른 방법으로 명확해야 정의를 추가) 문제를 더 혼란, 우리는 두 개의 오버로드 정의와 단어를 사용하려면 : 당신이 당신의 자신을 정의하는 방법을 설명하는 &lt;b&gt;서브 루틴을&lt;/b&gt; 숨길 내장 &lt;b&gt;기능&lt;/b&gt; 이 대체 정의 할 수있는 방법을 같은 이름의, 그리고 설명하기 위해 ( &quot;내장 함수 재정의&quot;낙타 제 11 장에서, &quot;모듈&quot;섹션 참조) &lt;b&gt;방법&lt;/b&gt; A의 &lt;b&gt;파생 클래스&lt;/b&gt; 숨기기 위해 &lt;b&gt;기본 클래스&lt;/b&gt; 의의 방법을 같은 이름 (카멜 12 장 &quot;객체&quot;참조).</target>
        </trans-unit>
        <trans-unit id="c470287cb379da96c293a62fb8664cf2247d2b55" translate="yes" xml:space="preserve">
          <source>High Level</source>
          <target state="translated">높은 레벨</target>
        </trans-unit>
        <trans-unit id="ad6c175822059b79229ebfc786ac972d1cc9dd61" translate="yes" xml:space="preserve">
          <source>High resolution alarm, sleep, gettimeofday, interval timers</source>
          <target state="translated">고해상도 알람, 수면, gettimeofday, 간격 타이머</target>
        </trans-unit>
        <trans-unit id="06ec56d2d4a59020901e32260159cfaa9fcc9ac8" translate="yes" xml:space="preserve">
          <source>High-level commands do such initializations automatically.</source>
          <target state="translated">고급 명령은 이러한 초기화를 자동으로 수행합니다.</target>
        </trans-unit>
        <trans-unit id="e29ea1646e3ae3268842b4efea0250df490ad525" translate="yes" xml:space="preserve">
          <source>Higher-Order Perl</source>
          <target state="translated">더 높은 순서의 Perl</target>
        </trans-unit>
        <trans-unit id="2f40e6c9a09885ca0cf7997c2375c0fe1fb31d9f" translate="yes" xml:space="preserve">
          <source>Hint: The &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; tutorial covers the T_INOUT, T_IN, and T_OUT XS types nicely.</source>
          <target state="translated">힌트 : &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; 튜토리얼은 T_INOUT, T_IN 및 T_OUT XS 유형을 잘 다룹니다.</target>
        </trans-unit>
        <trans-unit id="e3d4d7c7e48bee9d90099bb119b39917c09def77" translate="yes" xml:space="preserve">
          <source>Hint: sometimes appending &lt;code&gt;&quot;, stopped&quot;&lt;/code&gt; to your message will cause it to make better sense when the string &lt;code&gt;&quot;at foo line 123&quot;&lt;/code&gt; is appended. Suppose you are running script &quot;canasta&quot;.</source>
          <target state="translated">힌트 : 메시지에 &lt;code&gt;&quot;, stopped&quot;&lt;/code&gt; 을 추가 하면 &lt;code&gt;&quot;at foo line 123&quot;&lt;/code&gt; 문자열 이 추가 될 때 더 잘 이해 될 수 있습니다 . &quot;canasta&quot;스크립트를 실행한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="2e7ad51592f12093f07f504091e6b4574d36b5ff" translate="yes" xml:space="preserve">
          <source>Hints for Writing Pod</source>
          <target state="translated">포드 작성을위한 힌트</target>
        </trans-unit>
        <trans-unit id="cd94510567b2e65da4d128c15c97d4b8bf6c814e" translate="yes" xml:space="preserve">
          <source>Hintsfile support</source>
          <target state="translated">힌트 파일 지원</target>
        </trans-unit>
        <trans-unit id="57ec96f40e52a96bf96bf4e1bcab6928fd860e76" translate="yes" xml:space="preserve">
          <source>Historical note: A few older Pod processors would not see a &quot;&amp;gt;&quot; as closing a &quot;C&amp;lt;&quot; code, if the &quot;&amp;gt;&quot; was immediately preceded by a &quot;-&quot;. This was so that this:</source>
          <target state="translated">기록 참고 : &quot;&amp;gt;&quot;바로 앞에 &quot;-&quot;가 있으면 일부 이전 포드 프로세서는 &quot;&amp;gt;&quot;를 &quot;C &amp;lt;&quot;코드를 닫는 것으로 볼 수 없습니다. 이것은 이렇게 :</target>
        </trans-unit>
        <trans-unit id="456da061b07638f2efc60c23c53fa3c2c51535e7" translate="yes" xml:space="preserve">
          <source>Historical notes: 'die' used to be the default value of &lt;code&gt;$huge&lt;/code&gt; . Now, 'wrap' is the default value.</source>
          <target state="translated">역사적 메모 : 'die'는 기본값 &lt;code&gt;$huge&lt;/code&gt; 였습니다. 이제 'wrap'이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="a4bea0d3c8dc12ea86900e60a2460f211b081d43" translate="yes" xml:space="preserve">
          <source>Historically, any software that you give away, particularly if you make the source code available as well. Now often called &lt;b&gt;open source software&lt;/b&gt;. Recently there has been a trend to use the term in contradistinction to &lt;b&gt;open source software&lt;/b&gt;, to refer only to free software released under the Free Software Foundation&amp;rsquo;s GPL (General Public License), but this is difficult to justify etymologically.</source>
          <target state="translated">역사적으로, 특히 소스 코드를 사용할 수있게하는 경우 제공하는 모든 소프트웨어. 이제는 종종 &lt;b&gt;오픈 소스 소프트웨어&lt;/b&gt; 라고 &lt;b&gt;합니다&lt;/b&gt; . 최근 에 자유 소프트웨어 재단의 GPL (General Public License)에 따라 공개 된 자유 소프트웨어만을 언급 하기 위해 &lt;b&gt;오픈 소스 소프트웨어&lt;/b&gt; 에 대립하는 용어를 사용하는 경향 이 있었지만 이는 어원 적으로 정당화하기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="97391b474b93a4ff5ad2004bc1c3d103a9fb4d4e" translate="yes" xml:space="preserve">
          <source>Historically, only the pumpking cherry-picked changes from bleadperl into maintperl. This has scaling problems. At the same time, maintenance branches of stable versions of Perl need to be treated with great care. To that end, as of Perl 5.12, we have a new process for maint branches.</source>
          <target state="translated">역사적으로 호박 벚나무 따기 만 bleadperl에서 maintperl로 바뀝니다. 스케일링 문제가 있습니다. 동시에, 안정적인 버전의 Perl의 유지 관리 지점은 세심한주의를 기울여야합니다. 이를 위해 Perl 5.12부터 maint 브랜치를위한 새로운 프로세스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a70077bc9082a3c8ea160dc01f918a3a65a6e212" translate="yes" xml:space="preserve">
          <source>Historically, these would be generated by the &lt;a href=&quot;h2ph&quot;&gt;h2ph&lt;/a&gt; tool, part of the standard perl distribution. This program converts &lt;code&gt;cpp(1)&lt;/code&gt; directives in C header files to files containing subroutine definitions, like &lt;code&gt;SYS_getitimer()&lt;/code&gt; , which you can use as arguments to your functions. It doesn't work perfectly, but it usually gets most of the job done. Simple files like</source>
          <target state="translated">역사적으로, 이들은 표준 perl 분포의 일부인 &lt;a href=&quot;h2ph&quot;&gt;h2ph&lt;/a&gt; 도구에 의해 생성되었습니다 . 이 프로그램 은 C 헤더 파일의 &lt;code&gt;cpp(1)&lt;/code&gt; 지시문을 &lt;code&gt;SYS_getitimer()&lt;/code&gt; 와 같은 서브 루틴 정의가 포함 된 파일 로 변환 하여 함수의 인수로 사용할 수 있습니다. 완벽하게 작동하지는 않지만 일반적으로 대부분의 작업이 완료됩니다. 간단한 파일</target>
        </trans-unit>
        <trans-unit id="723525aec4e05b078bfa1f7212775fddba5a19b2" translate="yes" xml:space="preserve">
          <source>Historically, we've held ourselves to a far higher standard than backward-compatibility -- bugward-compatibility. Any accident of implementation or unintentional side-effect of running some bit of code has been considered to be a feature of the language to be defended with the same zeal as any other feature or functionality. No matter how frustrating these unintentional features may be to us as we continue to improve Perl, these unintentional features often deserve our protection. It is very important that existing software written in Perl continue to work correctly. If end-user developers have adopted a bug as a feature, we need to treat it as such.</source>
          <target state="translated">역사적으로 우리는 이전 버전과의 호환성 (버그와의 호환성)보다 훨씬 더 높은 표준을 유지해 왔습니다. 구현 실수 또는 일부 비트 코드 실행으로 인한 의도하지 않은 부작용은 다른 특징 또는 기능과 동일한 열정으로 방어 할 언어의 특징으로 간주되었습니다. Perl을 계속 개선함에 따라 이러한 의도하지 않은 기능이 얼마나 실망 스러울지라도 이러한 의도하지 않은 기능은 종종 보호받을 가치가 있습니다. Perl로 작성된 기존 소프트웨어가 계속 올바르게 작동하는 것이 매우 중요합니다. 최종 사용자 개발자가 버그를 기능으로 채택한 경우이를 버그로 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="2e6d74e94851d72f49d2c6b59183be96d60c8e34" translate="yes" xml:space="preserve">
          <source>History and Background</source>
          <target state="translated">역사와 배경</target>
        </trans-unit>
        <trans-unit id="ace535b09698d3ae2888504e132d0829ba6b4d7d" translate="yes" xml:space="preserve">
          <source>History of CPAN Meta Spec changes</source>
          <target state="translated">CPAN 메타 사양 변경 내역</target>
        </trans-unit>
        <trans-unit id="3e8e120f18fdbffd8b9be5d8fa532f5e8e03fa02" translate="yes" xml:space="preserve">
          <source>History of Middle Earth</source>
          <target state="translated">중간계의 역사</target>
        </trans-unit>
        <trans-unit id="9d34c3581dd43beee5ddd060d0bab25f439fd94b" translate="yes" xml:space="preserve">
          <source>History of WinCE port</source>
          <target state="translated">WinCE 포트의 역사</target>
        </trans-unit>
        <trans-unit id="9733ac081a67789bdb91140dbb2aaf4de5c5ec7b" translate="yes" xml:space="preserve">
          <source>Hmm. What happened here? If you've been following along, you know that the above pattern should be effectively (almost) the same as the last one; enclosing the &lt;code&gt;d&lt;/code&gt; in a character class isn't going to change what it matches. So why does the first not print while the second one does?</source>
          <target state="translated">흠. 여기 뭔 일 있었 니? 당신이 따라왔다면, 위의 패턴은 마지막 패턴과 실질적으로 (거의) 동일해야합니다. 문자 클래스에서 &lt;code&gt;d&lt;/code&gt; 를 묶어 도 일치하는 것을 변경하지 않습니다. 그렇다면 왜 첫 번째는 인쇄하지 않고 두 번째는 인쇄하지 않습니까?</target>
        </trans-unit>
        <trans-unit id="821ac8e428a38ddcf25e2027bc128ec6e743a489" translate="yes" xml:space="preserve">
          <source>Hmm... that's still a bit ugly. How about this:</source>
          <target state="translated">흠 ... 그건 여전히 못 생겼다. 이건 어때요:</target>
        </trans-unit>
        <trans-unit id="511721548acc73e7ad2a7122ec29970e3c6188d3" translate="yes" xml:space="preserve">
          <source>Holds information on the longest string that must occur at a fixed offset from the start of the pattern, and the longest string that must occur at a floating offset from the start of the pattern. Used to do Fast-Boyer-Moore searches on the string to find out if its worth using the regex engine at all, and if so where in the string to search.</source>
          <target state="translated">패턴 시작에서 고정 오프셋에서 발생해야하는 가장 긴 문자열과 패턴 시작에서 부동 오프셋에서 발생해야하는 가장 긴 문자열에 대한 정보를 보유합니다. 문자열에서 Fast-Boyer-Moore 검색을 수행하여 정규식 엔진을 사용할 가치가 있는지 여부와 문자열에서 검색 할 위치를 찾는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="959988c98232c3eb8b17616f91948b459e04946f" translate="yes" xml:space="preserve">
          <source>Holds some explanation in the case of an error.</source>
          <target state="translated">에러가 발생했을 경우에 대한 설명을 담고 있습니다.</target>
        </trans-unit>
        <trans-unit id="01443708f436be923f0aee8880549437dad1a448" translate="yes" xml:space="preserve">
          <source>Holds the last reported error. Kept for historical reasons, but its use is very much discouraged. Use the &lt;code&gt;error()&lt;/code&gt; method instead:</source>
          <target state="translated">마지막으로보고 된 오류를 보유합니다. 역사적인 이유로 유지되었지만 사용이 매우 권장되지 않습니다. &lt;code&gt;error()&lt;/code&gt; 메소드를 대신 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c95db6ed76758307edcf864f1a4ab2acb112562d" translate="yes" xml:space="preserve">
          <source>Holds the output of the &lt;code&gt;date&lt;/code&gt; command when the configuration file was produced. This is used to tag both</source>
          <target state="translated">구성 파일이 생성 될 때 &lt;code&gt;date&lt;/code&gt; 명령 의 출력을 보유합니다 . 둘 다 태그하는 데 사용됩니다</target>
        </trans-unit>
        <trans-unit id="739c29f4f6f84e7a7eaff9a32fa3671bc3d08941" translate="yes" xml:space="preserve">
          <source>Holds the private path used by Configure to find out the libraries. Its value is prepend to libpth. This variable takes care of special machines, like the mips. Usually, it should be empty.</source>
          <target state="translated">라이브러리가 찾기 위해 Configure에서 사용하는 개인 경로를 보유합니다. 그 값은 libpth 앞에 붙습니다. 이 변수는 밉과 같은 특수 기계를 처리합니다. 일반적으로 비어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="582b824400c82cf0f40f9f7c604827d48ea750f5" translate="yes" xml:space="preserve">
          <source>Holds the standard error of the executed command (or empty string if there was no STDERR output or if &lt;code&gt;discard_output&lt;/code&gt; was used; it's always defined!)</source>
          <target state="translated">실행 된 명령의 표준 오류를 보유합니다 (또는 STDERR 출력이 없거나 &lt;code&gt;discard_output&lt;/code&gt; _ 출력 이 사용 된 경우 빈 문자열, 항상 정의 됨).</target>
        </trans-unit>
        <trans-unit id="7c3e4c3ddb7125c1c1e75cedd0d2a9c28f53291d" translate="yes" xml:space="preserve">
          <source>Holds the standard output and error of the executed command merged into one stream (or empty string if there was no output at all or if &lt;code&gt;discard_output&lt;/code&gt; was used; it's always defined!)</source>
          <target state="translated">실행 된 명령의 표준 출력 및 오류를 하나의 스트림으로 병합합니다 (또는 출력이 전혀 없거나 &lt;code&gt;discard_output&lt;/code&gt; 이 사용 된 경우 빈 문자열, 항상 정의 됨).</target>
        </trans-unit>
        <trans-unit id="5f9c8ab4b280eb2c610d191400d239df37776272" translate="yes" xml:space="preserve">
          <source>Holds the standard output of the executed command (or empty string if there was no STDOUT output or if &lt;code&gt;discard_output&lt;/code&gt; was used; it's always defined!)</source>
          <target state="translated">실행 된 명령의 표준 출력을 보유합니다 (또는 STDOUT 출력이 없거나 &lt;code&gt;discard_output&lt;/code&gt; _ 출력 이 사용 된 경우 빈 문자열, 항상 정의 됨).</target>
        </trans-unit>
        <trans-unit id="1f43fffdbf7b0c05af0b8fc8fcc67b1c8be39947" translate="yes" xml:space="preserve">
          <source>Home page for ISO 15924.</source>
          <target state="translated">ISO 15924 홈페이지.</target>
        </trans-unit>
        <trans-unit id="1ba2fa3de9992cda18c006a91b37960fee16b9e0" translate="yes" xml:space="preserve">
          <source>Hook manipulation</source>
          <target state="translated">후크 조작</target>
        </trans-unit>
        <trans-unit id="4bd8f3f03a576b2088bd73a2339d07fca1de805d" translate="yes" xml:space="preserve">
          <source>Hooks</source>
          <target state="translated">Hooks</target>
        </trans-unit>
        <trans-unit id="4b09a3b7ef7178d5866c8b4122a3b1b80e280cb2" translate="yes" xml:space="preserve">
          <source>Hopefully the contents of each of the filters should be self-explanatory. Both &quot;fetch&quot; filters remove the terminating NULL, and both &quot;store&quot; filters add a terminating NULL.</source>
          <target state="translated">각 필터의 ​​내용이 자명해야합니다. 두 &quot;fetch&quot;필터는 종료 NULL을 제거하고 두 &quot;store&quot;필터는 종료 NULL을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="b28755c4371822ab05bbd3edfbd84f8ae5c44516" translate="yes" xml:space="preserve">
          <source>How Do I Convert Binary Data Into a Particular Encoding, Or Vice Versa?</source>
          <target state="translated">이진 데이터를 특정 인코딩으로 변환하거나 그 반대로 변환하는 방법</target>
        </trans-unit>
        <trans-unit id="5ec153ad02980479ddc59f23ab37e27027e62588" translate="yes" xml:space="preserve">
          <source>How Do I Detect Data That's Not Valid In a Particular Encoding?</source>
          <target state="translated">특정 인코딩에서 유효하지 않은 데이터를 어떻게 탐지합니까?</target>
        </trans-unit>
        <trans-unit id="83daa5c8b58e95efd16e89c69000aaf2de146549" translate="yes" xml:space="preserve">
          <source>How Do I Display Unicode? How Do I Input Unicode?</source>
          <target state="translated">유니 코드를 어떻게 표시합니까? 유니 코드는 어떻게 입력합니까?</target>
        </trans-unit>
        <trans-unit id="eed7b35ef6f59f0cb6c635063802f8b69563cf7e" translate="yes" xml:space="preserve">
          <source>How Do I Find Out What Encoding a File Has?</source>
          <target state="translated">파일 인코딩이 무엇인지 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="87e4752c70fc96666a27cf0847bc95f48c8b5c9c" translate="yes" xml:space="preserve">
          <source>How Do I Know Whether My String Is In Unicode?</source>
          <target state="translated">내 문자열이 유니 코드인지 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="9a4dab32f52f3d5fb8384770ca50058013424c08" translate="yes" xml:space="preserve">
          <source>How Do I Make My Scripts Work With Unicode?</source>
          <target state="translated">스크립트가 유니 코드로 작동하게하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="aa967413382158f18536864c2c5f2d495ed0e167" translate="yes" xml:space="preserve">
          <source>How Does Unicode Work With Traditional Locales?</source>
          <target state="translated">유니 코드는 전통적인 로켈과 어떻게 작동합니까?</target>
        </trans-unit>
        <trans-unit id="ed7d6cb8e007f613e72e9f2c9f88a4738718ec79" translate="yes" xml:space="preserve">
          <source>How Lexical Warnings interact with &lt;b&gt;-w&lt;/b&gt;/&lt;code&gt;$^W&lt;/code&gt; :</source>
          <target state="translated">어휘 경고가 &lt;b&gt;-w&lt;/b&gt; / &lt;code&gt;$^W&lt;/code&gt; 와 상호 작용하는 방법 :</target>
        </trans-unit>
        <trans-unit id="d1d502798bd5bd5bfc80ae2ff245f8510eaa3465" translate="yes" xml:space="preserve">
          <source>How Perl Chooses an Operator Implementation</source>
          <target state="translated">Perl이 운영자 구현을 선택하는 방법</target>
        </trans-unit>
        <trans-unit id="9d0dbe99bf0e202fd46e73a61d85e7d37d314d99" translate="yes" xml:space="preserve">
          <source>How PerlIO_apply_layera fits in, where its docs, was it made public?</source>
          <target state="translated">PerlIO_apply_layera는 어떻게 문서에 공개 되었습니까?</target>
        </trans-unit>
        <trans-unit id="d5c739c2b8daeba650fc90008192e941caa8ca99" translate="yes" xml:space="preserve">
          <source>How SUPER is Resolved</source>
          <target state="translated">SUPER가 해결되는 방법</target>
        </trans-unit>
        <trans-unit id="30ea041c36c78a4bf2e3a15655945d87e8d2b703" translate="yes" xml:space="preserve">
          <source>How To Write A Makefile.PL</source>
          <target state="translated">Makefile.PL 작성 방법</target>
        </trans-unit>
        <trans-unit id="4a252fc6f68b2a5fddacedeb60aa9691abebcc2a" translate="yes" xml:space="preserve">
          <source>How a piece of code actually goes about doing its job. Users of the code should not count on implementation details staying the same unless they are part of the published &lt;b&gt;interface&lt;/b&gt;.</source>
          <target state="translated">실제로 코드 작업이 수행되는 방식 코드 사용자는 게시 된 &lt;b&gt;인터페이스의&lt;/b&gt; 일부가 아닌 한 동일하게 유지되는 구현 세부 정보에 의존해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="e2e38e1473acd589790c55670049e3a998855b25" translate="yes" xml:space="preserve">
          <source>How are you supposed to know what flavour of Make a Makefile has been generated for if you didn't specify a value explicitly? Search the generated Makefile for the definition of the MAKE variable, which is used to recursively invoke the Make utility. That will tell you what Make you're supposed to invoke the Makefile with.</source>
          <target state="translated">명시 적으로 값을 지정하지 않은 경우 Makefile의 어떤 풍미가 생성되었는지 어떻게 알 수 있습니까? 생성 된 Makefile에서 MAKE 변수의 정의를 검색하십시오. 이는 Make 변수를 재귀 적으로 호출하는 데 사용됩니다. Makefile을 호출 할 Make를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="411ad64f6dc4be13b3049742bd05bd21505c6bc7" translate="yes" xml:space="preserve">
          <source>How big is it?</source>
          <target state="translated">얼마나 큽니까?</target>
        </trans-unit>
        <trans-unit id="27c74f66aeb35e0636195d822a7e3464616e6fc2" translate="yes" xml:space="preserve">
          <source>How can I access a dynamic variable while a similarly named lexical is in scope?</source>
          <target state="translated">비슷한 이름의 어휘가 범위 내에있는 동안 동적 변수에 어떻게 액세스 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="a4335b4f09781554b24ada06ac33e99c54ce3d7c" translate="yes" xml:space="preserve">
          <source>How can I access or change N characters of a string?</source>
          <target state="translated">문자열의 N 문자를 어떻게 액세스하거나 변경할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="5371ca66bd4ba8690a33a1384214275dda640111" translate="yes" xml:space="preserve">
          <source>How can I always keep my hash sorted?</source>
          <target state="translated">항상 해시를 정렬하여 유지하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="8584960f36ac9f047e34a3eda935743347b5f7f6" translate="yes" xml:space="preserve">
          <source>How can I call backticks without shell processing?</source>
          <target state="translated">쉘 처리없이 백틱을 어떻게 호출 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="cd430257f97dbf507a96e7339aa72325a34a2ee9" translate="yes" xml:space="preserve">
          <source>How can I call my system's unique C functions from Perl?</source>
          <target state="translated">Perl에서 시스템 고유의 C 함수를 어떻게 호출 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="90f43bbd8d5db22db1ec788113816dce3fba1fdc" translate="yes" xml:space="preserve">
          <source>How can I capture STDERR from an external command?</source>
          <target state="translated">외부 명령에서 STDERR을 어떻게 캡처 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="84907121b70e047be5c9daea9434199430d20e18" translate="yes" xml:space="preserve">
          <source>How can I catch accesses to undefined variables, functions, or methods?</source>
          <target state="translated">정의되지 않은 변수, 함수 또는 메소드에 대한 액세스를 어떻게 포착 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="e13761e1cadfb4e6d275a8cd44df7f322009226b" translate="yes" xml:space="preserve">
          <source>How can I check if a key exists in a multilevel hash?</source>
          <target state="translated">다중 레벨 해시에 키가 있는지 어떻게 확인합니까?</target>
        </trans-unit>
        <trans-unit id="9501d5027299df90931400bb41c70210a1c7aacf" translate="yes" xml:space="preserve">
          <source>How can I comment out a large block of Perl code?</source>
          <target state="translated">큰 Perl 코드 블록을 주석 처리하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="639138b8959cf833940b74db28e00ac3d078eb9d" translate="yes" xml:space="preserve">
          <source>How can I compare two dates and find the difference?</source>
          <target state="translated">두 날짜를 비교하고 차이점을 찾으려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="92731d0a16ed8941afe35ab6fae1c71e5ff73d63" translate="yes" xml:space="preserve">
          <source>How can I compile my Perl program into byte code or C?</source>
          <target state="translated">Perl 프로그램을 바이트 코드 또는 C로 컴파일하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="f297bf1c9610312e098c5eff2eb10783e881e05c" translate="yes" xml:space="preserve">
          <source>How can I convert my shell script to perl?</source>
          <target state="translated">쉘 스크립트를 펄로 변환하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="fc9934bcfd8649f3922c04fc5693703b33981e29" translate="yes" xml:space="preserve">
          <source>How can I convince others to use Perl?</source>
          <target state="translated">다른 사람들에게 Perl을 사용하도록 설득하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="61781e6bf9642bee00811fb1e34ef7698e18ae20" translate="yes" xml:space="preserve">
          <source>How can I copy a file?</source>
          <target state="translated">파일을 어떻게 복사 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="62ee42141b7c95a311d0f8cb97c8e383832868b4" translate="yes" xml:space="preserve">
          <source>How can I count the number of occurrences of a substring within a string?</source>
          <target state="translated">문자열 내에서 하위 문자열의 발생 횟수를 어떻게 계산할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="f0aa6516dbefab9dd5eb5222f4701f9c5f218b7c" translate="yes" xml:space="preserve">
          <source>How can I determine if a string is a text string or a binary string?</source>
          <target state="translated">문자열이 텍스트 문자열인지 이진 문자열인지 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="218779f6e2b4819e8fa691d46344a18cc62cfb76" translate="yes" xml:space="preserve">
          <source>How can I do RPC in Perl?</source>
          <target state="translated">Perl에서 RPC를 어떻게 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="67ea1bb995fcd1fc57c8e9b92a095f41d9b7834f" translate="yes" xml:space="preserve">
          <source>How can I do an atexit() or setjmp()/longjmp()? (Exception handling)</source>
          <target state="translated">atexit () 또는 setjmp () / longjmp ()를 어떻게 할 수 있습니까? (예외 처리)</target>
        </trans-unit>
        <trans-unit id="5af190bbb735548d1facf32f768401f6d294971f" translate="yes" xml:space="preserve">
          <source>How can I do approximate matching?</source>
          <target state="translated">근사 일치는 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="570f18a5d24dc2e398fe91082824106830a64146" translate="yes" xml:space="preserve">
          <source>How can I expand variables in text strings?</source>
          <target state="translated">텍스트 문자열에서 변수를 어떻게 확장 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="79199189d2f681d40463922bceb5338164a11bf3" translate="yes" xml:space="preserve">
          <source>How can I find out my current or calling package?</source>
          <target state="translated">현재 또는 통화중인 패키지를 어떻게 찾을 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="2174489b130a993ef91515d9a1c4f01f1df7d31d" translate="yes" xml:space="preserve">
          <source>How can I find the Julian Day?</source>
          <target state="translated">줄리안 데이는 어떻게 찾을 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="b9735d79cbde5c76c3fddd9a7f2ea2d91841d1f1" translate="yes" xml:space="preserve">
          <source>How can I free an array or hash so my program shrinks?</source>
          <target state="translated">프로그램이 축소되도록 배열 또는 해시를 해제하는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="a65a81dcfe85675764c8fa953a5501143a7a4d4c" translate="yes" xml:space="preserve">
          <source>How can I get #!perl to work on [MS-DOS,NT,...]?</source>
          <target state="translated">#! perl을 [MS-DOS, NT, ...]에서 어떻게 작동시킬 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="bf6b38eb1c743c27901f724e241bc103f6e22f1a" translate="yes" xml:space="preserve">
          <source>How can I get &lt;code&gt;#!perl&lt;/code&gt; to work on [MS-DOS,NT,...]?</source>
          <target state="translated">&lt;code&gt;#!perl&lt;/code&gt; 을 [MS-DOS, NT, ...]에서 어떻게 작동 시킬 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="402e6fe7ce516fa4af09165ec04abd0ecfff56b0" translate="yes" xml:space="preserve">
          <source>How can I get a binary version of Perl?</source>
          <target state="translated">바이너리 버전의 Perl을 어떻게 구할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="f01d20dc05214c47d4b244f669680dc5511e26c5" translate="yes" xml:space="preserve">
          <source>How can I get the unique keys from two hashes?</source>
          <target state="translated">두 개의 해시에서 고유 키를 어떻게 얻을 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="c41c416bf1bb0f25b4ae1ae9fd568032d02685fd" translate="yes" xml:space="preserve">
          <source>How can I hide the source for my Perl program?</source>
          <target state="translated">Perl 프로그램의 소스를 숨기려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="6c1e3d2428ca43719e62fc8b4685854b671a4efe" translate="yes" xml:space="preserve">
          <source>How can I hope to use regular expressions without creating illegible and unmaintainable code?</source>
          <target state="translated">읽을 수없고 유지 관리 할 수없는 코드를 만들지 않고 정규식을 사용하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="b41e3d8caca6f525dc73482358563647f9033bf1" translate="yes" xml:space="preserve">
          <source>How can I know how many entries are in a hash?</source>
          <target state="translated">해시에 몇 개의 항목이 있는지 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="91090b21439190b378705149c5300b111d7f99b3" translate="yes" xml:space="preserve">
          <source>How can I lock a file?</source>
          <target state="translated">파일을 어떻게 잠글 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="2b525e6fbe8d4f65916593a6d6f3bcc00b55e5ee" translate="yes" xml:space="preserve">
          <source>How can I make &lt;code&gt;\w&lt;/code&gt; match national character sets?</source>
          <target state="translated">&lt;code&gt;\w&lt;/code&gt; 자국 문자 세트와 일치 시키 려면 어떻게 해야합니까?</target>
        </trans-unit>
        <trans-unit id="493e8171097525007801a396579dca3fc0ae7646" translate="yes" xml:space="preserve">
          <source>How can I make \w match national character sets?</source>
          <target state="translated">\ w를 자국 문자 세트와 일치 시키려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="8efd8bb825816036c83b0bc4f4bc86a0e0087ba8" translate="yes" xml:space="preserve">
          <source>How can I make a filehandle local to a subroutine? How do I pass filehandles between subroutines? How do I make an array of filehandles?</source>
          <target state="translated">서브 루틴에 파일 핸들을 로컬로 만들려면 어떻게해야합니까? 서브 루틴간에 파일 핸들을 어떻게 전달합니까? 파일 핸들 배열을 만들려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="225121f6ad8826944237905943573b1a1ad7146a" translate="yes" xml:space="preserve">
          <source>How can I make my CGI script more efficient?</source>
          <target state="translated">CGI 스크립트를보다 효율적으로 만들려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="aa449d7fc61d0c5f65c319dcdaf3c309d5a861d5" translate="yes" xml:space="preserve">
          <source>How can I make my Perl program run faster?</source>
          <target state="translated">Perl 프로그램을 더 빨리 실행하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="da8314c9a027c83b1de3d8a02639e8b7fd488456" translate="yes" xml:space="preserve">
          <source>How can I make my Perl program take less memory?</source>
          <target state="translated">Perl 프로그램의 메모리를 줄이려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="ab79906bd54ede65c9167982f83df39910ca41eb" translate="yes" xml:space="preserve">
          <source>How can I make my hash remember the order I put elements into it?</source>
          <target state="translated">요소를 넣은 순서를 해시로 기억 시키려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="eff3ee7a75a95b7dc6ebbcab6cdc87f62eaed0b6" translate="yes" xml:space="preserve">
          <source>How can I make the Perl equivalent of a C structure/C++ class/hash or array of hashes or arrays?</source>
          <target state="translated">Perl을 C 구조 / C ++ 클래스 / 해시 또는 해시 또는 어레이 배열과 동등하게 만들려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="313eaa4ceba4000008228fa89da4dfffac4883cb" translate="yes" xml:space="preserve">
          <source>How can I manipulate fixed-record-length files?</source>
          <target state="translated">고정 레코드 길이 파일을 어떻게 조작 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="e9c4cf85e44267039f73e90a4005aa7e0fbde93f" translate="yes" xml:space="preserve">
          <source>How can I match a locale-smart version of /[a-zA-Z]/?</source>
          <target state="translated">로케일 스마트 버전의 / [a-zA-Z] /를 어떻게 일치시킬 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="a09d0b29b89d8c572780ffdaa75b2f1b8df250c7" translate="yes" xml:space="preserve">
          <source>How can I match a locale-smart version of &lt;code&gt;/[a-zA-Z]/&lt;/code&gt; ?</source>
          <target state="translated">로케일 스마트 버전의 &lt;code&gt;/[a-zA-Z]/&lt;/code&gt; 를 어떻게 일치시킬 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="acc211b194ec96e0a9f39c2fc3c9760c5684f182" translate="yes" xml:space="preserve">
          <source>How can I match strings with multibyte characters?</source>
          <target state="translated">멀티 바이트 문자로 문자열을 어떻게 일치시킬 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="77dcf6b0c4c91ea96666741c5ba2af5b17f44eab" translate="yes" xml:space="preserve">
          <source>How can I measure time under a second?</source>
          <target state="translated">1 초 이내에 시간을 어떻게 측정 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="3db0de0b51e68209069c4bcced248be111e64bf1" translate="yes" xml:space="preserve">
          <source>How can I open a file with a leading &quot;&amp;gt;&quot; or trailing blanks?</source>
          <target state="translated">선행 &quot;&amp;gt;&quot;또는 후행 공백이있는 파일을 어떻게 열 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="2e27cd7875437a1d5b58c674aa20e1a1f445ed2f" translate="yes" xml:space="preserve">
          <source>How can I open a filehandle to a string?</source>
          <target state="translated">문자열로 파일 핸들을 어떻게 열 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="66bdbd7c5e5fc4cc3882f787c23fdf9783890787" translate="yes" xml:space="preserve">
          <source>How can I open a pipe both to and from a command?</source>
          <target state="translated">명령과 파이프를 어떻게 열 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="cc95647ff06623df9f3fe7b151e5174f6d8d433a" translate="yes" xml:space="preserve">
          <source>How can I output Roman numerals?</source>
          <target state="translated">로마 숫자를 어떻게 출력 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="e415a2ec1d5bacc294697e39127dad698ce08519" translate="yes" xml:space="preserve">
          <source>How can I output my numbers with commas added?</source>
          <target state="translated">쉼표를 추가하여 숫자를 어떻게 출력 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="71d9df292afc1f28ab8d43537f9b2fc5e1d5e39d" translate="yes" xml:space="preserve">
          <source>How can I pass/return a {Function, FileHandle, Array, Hash, Method, Regex}?</source>
          <target state="translated">{함수, FileHandle, 배열, 해시, 메소드, 정규식}을 전달 / 반환하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="607da88807131fb0d75ed3b744e20b136c3c6945" translate="yes" xml:space="preserve">
          <source>How can I prevent addition of unwanted keys into a hash?</source>
          <target state="translated">원치 않는 키가 해시에 추가되지 않도록하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="132c95be002620b77b84199839203d3bbecd265f" translate="yes" xml:space="preserve">
          <source>How can I print out a word-frequency or line-frequency summary?</source>
          <target state="translated">단어 빈도 또는 라인 빈도 요약을 인쇄하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="9b8afbc5c9adfffb10eaf9f9e73e6a5dd9a33727" translate="yes" xml:space="preserve">
          <source>How can I pull out lines between two patterns that are themselves on different lines?</source>
          <target state="translated">서로 다른 선에있는 두 패턴 사이의 선을 어떻게 뽑을 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="aa09f1e8ecf9751a8e601635407b1b85b484a991" translate="yes" xml:space="preserve">
          <source>How can I quote a variable to use in a regex?</source>
          <target state="translated">정규식에서 사용할 변수를 어떻게 인용 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="5048ee292d54dc738c8b2e4a4e9d40ed88661804" translate="yes" xml:space="preserve">
          <source>How can I read a single character from a file? From the keyboard?</source>
          <target state="translated">파일에서 단일 문자를 읽으려면 어떻게해야합니까? 키보드에서?</target>
        </trans-unit>
        <trans-unit id="bd4bea532194d27e8f4c0167b3ea139fc3e738e8" translate="yes" xml:space="preserve">
          <source>How can I read in a file by paragraphs?</source>
          <target state="translated">단락별로 파일을 어떻게 읽을 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="d86b23e0a7033694a41285ad01891788240ba487" translate="yes" xml:space="preserve">
          <source>How can I read in an entire file all at once?</source>
          <target state="translated">전체 파일을 한 번에 읽을 수있는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="be068faf9cf22c97ef84fb173f7722fe689af084" translate="yes" xml:space="preserve">
          <source>How can I recognise a UTF-8 string?</source>
          <target state="translated">UTF-8 문자열을 어떻게 인식합니까?</target>
        </trans-unit>
        <trans-unit id="28052c84845f30a6d5db733cf8047009c5a791db" translate="yes" xml:space="preserve">
          <source>How can I reliably rename a file?</source>
          <target state="translated">파일 이름을 안정적으로 바꾸려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="8a768c48e2e0b2fc34f88cb4e753c4bb5f8f926e" translate="yes" xml:space="preserve">
          <source>How can I remove duplicate elements from a list or array?</source>
          <target state="translated">목록이나 배열에서 중복 요소를 제거하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="daff1cd30b2b776eb20a1e8ba332328966a941c8" translate="yes" xml:space="preserve">
          <source>How can I set up a footer format to be used with write()?</source>
          <target state="translated">write ()와 함께 사용할 바닥 글 형식을 설정하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="e1d8eb9609efe77a17044341626f5d092fb4352d" translate="yes" xml:space="preserve">
          <source>How can I sleep() or alarm() for under a second?</source>
          <target state="translated">잠깐 동안 잠을 자려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="2e588f9010bcd10392f7edf040ae56a945189e99" translate="yes" xml:space="preserve">
          <source>How can I split a [character]-delimited string except when inside [character]?</source>
          <target state="translated">[문자] 내부를 제외하고 [문자]로 구분 된 문자열을 어떻게 분할 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="043a45581bbf861e01b6d8df458229f88cd7fe73" translate="yes" xml:space="preserve">
          <source>How can I store a multidimensional array in a DBM file?</source>
          <target state="translated">다차원 배열을 DBM 파일에 저장하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="3e3f15708830cd90fcc2e8ed11e6fc04c0345d66" translate="yes" xml:space="preserve">
          <source>How can I take a string and turn it into epoch seconds?</source>
          <target state="translated">현을 가져 와서 에포크 초로 바꾸려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="279887cb82cd1ebda6c6c1a0b09fc6f0014cb878" translate="yes" xml:space="preserve">
          <source>How can I tell if a variable is tainted?</source>
          <target state="translated">변수가 오염되었는지 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="58516c6da782669b8d9c7cfc7d02262b3e4bb1bb" translate="yes" xml:space="preserve">
          <source>How can I tell whether a certain element is contained in a list or array?</source>
          <target state="translated">특정 요소가 목록 또는 배열에 포함되어 있는지 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="81aaf6c4723167313d15ab1c5f7e5b530f8557ce" translate="yes" xml:space="preserve">
          <source>How can I tell whether there's a character waiting on a filehandle?</source>
          <target state="translated">파일 핸들을 기다리는 캐릭터가 있는지 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="b2fcf8739ca319f39af63e3ce5170d91f44f77f2" translate="yes" xml:space="preserve">
          <source>How can I translate tildes (~) in a filename?</source>
          <target state="translated">파일 이름에서 물결표 (~)를 어떻게 번역 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="881f014c19a83fce123198524d0af95f5abeddf7" translate="yes" xml:space="preserve">
          <source>How can I use Perl interactively?</source>
          <target state="translated">Perl을 대화식으로 사용하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="4822820e0cebd48f928eec2f020bfeb1c6c58fcc" translate="yes" xml:space="preserve">
          <source>How can I use Perl's -i option from within a program?</source>
          <target state="translated">프로그램 내에서 Perl의 -i 옵션을 어떻게 사용할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="b59721a4c76a7fca29f80e903b0f2dded9b41579" translate="yes" xml:space="preserve">
          <source>How can I use Perl's &lt;code&gt;-i&lt;/code&gt; option from within a program?</source>
          <target state="translated">프로그램 내에서 Perl의 &lt;code&gt;-i&lt;/code&gt; 옵션을 어떻게 사용할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="a0b830d488369e5b57f08961ae54b6541e391fcb" translate="yes" xml:space="preserve">
          <source>How can I use a filehandle indirectly?</source>
          <target state="translated">파일 핸들을 간접적으로 사용하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="2954afefc188233ca0982e40813f35aedafa9c02" translate="yes" xml:space="preserve">
          <source>How can I use a reference as a hash key?</source>
          <target state="translated">참조를 해시 키로 사용하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="1cd3f90234d9f2d28d7f7859571cd8142dbcb6f4" translate="yes" xml:space="preserve">
          <source>How can I use a variable as a variable name?</source>
          <target state="translated">변수를 변수 이름으로 사용하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="0c905d4e5eee64ffc80c2808116d673741258304" translate="yes" xml:space="preserve">
          <source>How can I use curses with Perl?</source>
          <target state="translated">Perl에서 저주를 어떻게 사용합니까?</target>
        </trans-unit>
        <trans-unit id="50c6bbc4fb82176bf9d1327a643a764fb7e991f8" translate="yes" xml:space="preserve">
          <source>How can I write a GUI (X, Tk, Gtk, etc.) in Perl?</source>
          <target state="translated">Perl에서 GUI (X, Tk, Gtk 등)를 작성하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="81e8482ca19f1c03f3246a06ec608fbebf4e5f7c" translate="yes" xml:space="preserve">
          <source>How can I write expect in Perl?</source>
          <target state="translated">Perl에서 어떻게 expect를 쓸 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="1ed0197c720cb0aff97775cc40d6071cc2ec1d85" translate="yes" xml:space="preserve">
          <source>How can I write() into a string?</source>
          <target state="translated">문자열에 어떻게 write () 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="ebe948a96ce8ed3fcef25d460b5826d6e46a03f1" translate="yes" xml:space="preserve">
          <source>How can you figure out what to add? Assuming your Perl is post-5.001, execute a &lt;code&gt;perl -V&lt;/code&gt; command and pay special attention to the &quot;cc&quot; and &quot;ccflags&quot; information.</source>
          <target state="translated">추가 할 내용을 어떻게 알 수 있습니까? Perl이 5.001 이후라고 가정하면 &lt;code&gt;perl -V&lt;/code&gt; 명령을 실행 하고 &quot;cc&quot;및 &quot;ccflags&quot;정보에 특별한주의를 기울이십시오.</target>
        </trans-unit>
        <trans-unit id="7839a80cf8d473225aea7a22d12034d28e88fd87" translate="yes" xml:space="preserve">
          <source>How can you tell the difference between a non-zero status that is the result of a VMS native error status or an encoded Unix status? You can not unless you look at the ${^CHILD_ERROR_NATIVE} value. The ${^CHILD_ERROR_NATIVE} value returns the actual VMS status value and check the severity bits. If the severity bits are equal to 1, then if the numeric value for &lt;code&gt;$?&lt;/code&gt; is between 2 and 255 or 0, then &lt;code&gt;$?&lt;/code&gt; accurately reflects a value passed back from a Unix application. If &lt;code&gt;$?&lt;/code&gt; is 1, and the severity bits indicate a VMS error (2), then &lt;code&gt;$?&lt;/code&gt; is from a Unix application exit value.</source>
          <target state="translated">VMS 기본 오류 상태 또는 인코딩 된 Unix 상태의 결과 인 0이 아닌 상태의 차이점을 어떻게 알 수 있습니까? $ {^ CHILD_ERROR_NATIVE} 값을 보지 않으면 안됩니다. $ {^ CHILD_ERROR_NATIVE} 값은 실제 VMS 상태 값을 반환하고 심각도 비트를 확인합니다. 심각도 비트가 1과 같으면 &lt;code&gt;$?&lt;/code&gt; 2에서 255 또는 0 사이이고 &lt;code&gt;$?&lt;/code&gt; Unix 응용 프로그램에서 전달 된 값을 정확하게 반영합니다. 만약 &lt;code&gt;$?&lt;/code&gt; 1이고 심각도 비트는 VMS 오류 (2)를 나타내고 &lt;code&gt;$?&lt;/code&gt; Unix 응용 프로그램 종료 값에서옵니다.</target>
        </trans-unit>
        <trans-unit id="10e8b70e261dbd1684433d0e38a377a1e6c6f1bf" translate="yes" xml:space="preserve">
          <source>How come exec() doesn't return?</source>
          <target state="translated">exec ()가 어떻게 반환되지 않습니까?</target>
        </trans-unit>
        <trans-unit id="642d4ca1dadf5e67b2382dbc957dee2d26101ca3" translate="yes" xml:space="preserve">
          <source>How come when I open a file read-write it wipes it out?</source>
          <target state="translated">파일을 읽고 쓸 때 어떻게 지워지나요?</target>
        </trans-unit>
        <trans-unit id="120ce3c4d0d569cc353775c742050f216df78c10" translate="yes" xml:space="preserve">
          <source>How come? Because once upon a time, the argument to push() had to be a real array, not just a reference to one. That's no longer true. In fact, the line marked &quot;implicit deref&quot; above works just fine--in this instance--to do what the one that says explicit deref did.</source>
          <target state="translated">어떻게 오세요? 옛날 옛적에 push ()에 대한 인수는 단지 하나의 참조가 아니라 실제 배열이어야했기 때문입니다. 더 이상 사실이 아닙니다. 사실, 위의 &quot;암시 적 역 참조&quot;라고 표시된 줄은 명시 적 역 참조라고하는 것을 수행하기 위해 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="35cd8e41b71c05362e2e05b8fea674b5b9428071" translate="yes" xml:space="preserve">
          <source>How do I add a directory to my include path (@INC) at runtime?</source>
          <target state="translated">런타임에 포함 경로 (@INC)에 디렉토리를 어떻게 추가합니까?</target>
        </trans-unit>
        <trans-unit id="a8c4b858302cc359dbd26e7a94330185357e2027" translate="yes" xml:space="preserve">
          <source>How do I add the directory my program lives in to the module/library search path?</source>
          <target state="translated">프로그램이있는 디렉토리를 모듈 / 라이브러리 검색 경로에 어떻게 추가합니까?</target>
        </trans-unit>
        <trans-unit id="3767a07fd4ca1c10dc3a53f806060f350ef02ac9" translate="yes" xml:space="preserve">
          <source>How do I adopt or take over a module already on CPAN?</source>
          <target state="translated">CPAN에서 이미 모듈을 채택하거나 인계하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="2b820f99468b1968d2885fc455211ce9aab00b68" translate="yes" xml:space="preserve">
          <source>How do I ask the user for a password?</source>
          <target state="translated">사용자에게 비밀번호를 요청하는 방법</target>
        </trans-unit>
        <trans-unit id="203a77501794721d243b497cab58f25f10122bf4" translate="yes" xml:space="preserve">
          <source>How do I automate an HTML form submission?</source>
          <target state="translated">HTML 양식 제출을 자동화하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="b9487e21fcb84b27b564a1a52da3c445074087f9" translate="yes" xml:space="preserve">
          <source>How do I avoid zombies on a Unix system?</source>
          <target state="translated">유닉스 시스템에서 좀비를 피하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="f3a92921961d16b06b6e90c94b5e844a5163c8ba" translate="yes" xml:space="preserve">
          <source>How do I capitalize all the words on one line?</source>
          <target state="translated">한 줄에 모든 단어를 대문자로 쓰려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="4bb5fa72780a70fbcd38ea05720abb4024270f79" translate="yes" xml:space="preserve">
          <source>How do I change the Nth occurrence of something?</source>
          <target state="translated">N 번째 항목을 어떻게 변경합니까?</target>
        </trans-unit>
        <trans-unit id="bbe71d73de3e4f641a5e48b9cabe7daee1df1bb9" translate="yes" xml:space="preserve">
          <source>How do I change, delete, or insert a line in a file, or append to the beginning of a file?</source>
          <target state="translated">파일에서 행을 변경, 삭제 또는 삽입하거나 파일의 시작 부분에 어떻게 추가합니까?</target>
        </trans-unit>
        <trans-unit id="26ebac281176cc167fc28682837fc8035f2df7f9" translate="yes" xml:space="preserve">
          <source>How do I check a valid mail address?</source>
          <target state="translated">유효한 메일 주소는 어떻게 확인합니까?</target>
        </trans-unit>
        <trans-unit id="a6d4bc02f449734d8d38a8c79be0738d1807657b" translate="yes" xml:space="preserve">
          <source>How do I check whether input is ready on the keyboard?</source>
          <target state="translated">키보드에서 입력이 준비되었는지 어떻게 확인합니까?</target>
        </trans-unit>
        <trans-unit id="e9d5289c1b2381a4bfc799f6d79379a45148a056" translate="yes" xml:space="preserve">
          <source>How do I clear a package?</source>
          <target state="translated">패키지를 지우려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="da64d3ab23e8dfda8ada8eca869e3e4304053e10" translate="yes" xml:space="preserve">
          <source>How do I clear the screen?</source>
          <target state="translated">화면을 지우려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="dc7b6aff1b04d81838ccfc000e127a9b49e09b59" translate="yes" xml:space="preserve">
          <source>How do I close a file descriptor by number?</source>
          <target state="translated">번호로 파일 디스크립터를 닫으려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="2102c2d58d3c697659db6f147f9c7750ead5e836" translate="yes" xml:space="preserve">
          <source>How do I close a process's filehandle without waiting for it to complete?</source>
          <target state="translated">프로세스가 완료되기를 기다리지 않고 프로세스의 파일 핸들을 닫으려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="82c4851509fc2188559dfc3bbd26e54406e86a76" translate="yes" xml:space="preserve">
          <source>How do I compare strings?</source>
          <target state="translated">문자열을 어떻게 비교합니까?</target>
        </trans-unit>
        <trans-unit id="a5014833338499c76ba684cef2ad05a8939c7509" translate="yes" xml:space="preserve">
          <source>How do I compute the difference of two arrays? How do I compute the intersection of two arrays?</source>
          <target state="translated">두 배열의 차이를 어떻게 계산합니까? 두 배열의 교집합을 어떻게 계산합니까?</target>
        </trans-unit>
        <trans-unit id="28baf17ec2f9a6ff5d6d17753e8bf70e57ef541a" translate="yes" xml:space="preserve">
          <source>How do I convert a string to UTF-8?</source>
          <target state="translated">문자열을 UTF-8로 어떻게 변환합니까?</target>
        </trans-unit>
        <trans-unit id="a1ff2698b449bb489c981be9b3dd682dc2dd11e3" translate="yes" xml:space="preserve">
          <source>How do I convert between numeric representations/bases/radixes?</source>
          <target state="translated">숫자 표현 /베이스 / 기수를 어떻게 변환합니까?</target>
        </trans-unit>
        <trans-unit id="0e154b3973b3e38c40dce2887c701eeb759ba7d9" translate="yes" xml:space="preserve">
          <source>How do I convert from encoding FOO to encoding BAR?</source>
          <target state="translated">인코딩 FOO에서 인코딩 BAR로 어떻게 변환합니까?</target>
        </trans-unit>
        <trans-unit id="f9aa83752cb5484c41a1a794b8c3e92b85b90232" translate="yes" xml:space="preserve">
          <source>How do I copy an entire directory?</source>
          <target state="translated">전체 디렉토리를 어떻게 복사합니까?</target>
        </trans-unit>
        <trans-unit id="878e0980aa72aa1b56f3382c08eb0ae977818037" translate="yes" xml:space="preserve">
          <source>How do I count the number of lines in a file?</source>
          <target state="translated">파일의 줄 수는 어떻게 계산합니까?</target>
        </trans-unit>
        <trans-unit id="86a1974c296e30057e2194a7ef2242b7c1cfd98c" translate="yes" xml:space="preserve">
          <source>How do I create a Module::Build based Build.PL derived from an ExtUtils::MakeMaker focused Makefile.PL?</source>
          <target state="translated">ExtUtils :: MakeMaker 중심의 Makefile.PL에서 파생 된 Module :: Build 기반 Build.PL을 어떻게 작성합니까?</target>
        </trans-unit>
        <trans-unit id="aa6bdbe546fadef34a6ec8c386dc99a9b330832e" translate="yes" xml:space="preserve">
          <source>How do I create a class?</source>
          <target state="translated">수업은 어떻게 만듭니 까?</target>
        </trans-unit>
        <trans-unit id="4d74113d708c10f061b26ff7fcdab35341dbf82e" translate="yes" xml:space="preserve">
          <source>How do I create a module?</source>
          <target state="translated">모듈은 어떻게 만듭니 까?</target>
        </trans-unit>
        <trans-unit id="236c38bf7065e57bd631c8a83a8f5bfc130478e7" translate="yes" xml:space="preserve">
          <source>How do I create a static variable?</source>
          <target state="translated">정적 변수는 어떻게 만듭니 까?</target>
        </trans-unit>
        <trans-unit id="b74b37fe4636da83763c3e9df557c6184ae8c0f0" translate="yes" xml:space="preserve">
          <source>How do I create a switch or case statement?</source>
          <target state="translated">switch 또는 case 문을 작성하는 방법</target>
        </trans-unit>
        <trans-unit id="87e0957c61f867da042ce74af89ed18af7f653b6" translate="yes" xml:space="preserve">
          <source>How do I cross-reference my Perl programs?</source>
          <target state="translated">Perl 프로그램을 상호 참조하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="70f54b8026aba3fe0b07c960855d5b7aab7bb809" translate="yes" xml:space="preserve">
          <source>How do I debug my Perl programs?</source>
          <target state="translated">Perl 프로그램을 어떻게 디버깅합니까?</target>
        </trans-unit>
        <trans-unit id="97378d9d3fe8991aaac89412355467232d0a4c27" translate="yes" xml:space="preserve">
          <source>How do I declare/create a structure?</source>
          <target state="translated">구조를 선언 / 만드는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="2f51e7bb07a2328659ee4f97c52bb6f158f54842" translate="yes" xml:space="preserve">
          <source>How do I decode a MIME/BASE64 string?</source>
          <target state="translated">MIME / BASE64 문자열을 어떻게 디코딩합니까?</target>
        </trans-unit>
        <trans-unit id="2cd19e271c87d62d106f8fec30b522eacf831c74" translate="yes" xml:space="preserve">
          <source>How do I decode encrypted password files?</source>
          <target state="translated">암호화 된 비밀번호 파일을 어떻게 디코딩합니까?</target>
        </trans-unit>
        <trans-unit id="23d494744b67cf68faa6ba521e0dbfb0f945c204" translate="yes" xml:space="preserve">
          <source>How do I decode or create those %-encodings on the web?</source>
          <target state="translated">웹에서 이러한 % 인코딩을 어떻게 디코딩하거나 생성합니까?</target>
        </trans-unit>
        <trans-unit id="ee2564195c16e10af1a2a54e803a2d5eaa4bba4a" translate="yes" xml:space="preserve">
          <source>How do I define methods for every class/object?</source>
          <target state="translated">모든 클래스 / 객체에 대한 메소드를 어떻게 정의합니까?</target>
        </trans-unit>
        <trans-unit id="65a1e2e0843b152e3e957dda320e2bd68a2d232e" translate="yes" xml:space="preserve">
          <source>How do I delete a directory tree?</source>
          <target state="translated">디렉토리 트리를 어떻게 삭제합니까?</target>
        </trans-unit>
        <trans-unit id="c6598461e8184a71f0045d1091c9275b621efb6c" translate="yes" xml:space="preserve">
          <source>How do I delete the last N lines from a file?</source>
          <target state="translated">파일에서 마지막 N 줄을 어떻게 삭제합니까?</target>
        </trans-unit>
        <trans-unit id="82c2c49b1820b2e4b306f272a2091aeedd8bf680" translate="yes" xml:space="preserve">
          <source>How do I determine whether a scalar is a number/whole/integer/float?</source>
          <target state="translated">스칼라가 숫자 / 전체 / 정수 / 부동인지 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="f65b76741f09d6f8756a10de0d88399c941d8dbe" translate="yes" xml:space="preserve">
          <source>How do I do (anything)?</source>
          <target state="translated">어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="5a3899f947a018efe1a69e369cf5894457670072" translate="yes" xml:space="preserve">
          <source>How do I do a &lt;code&gt;tail -f&lt;/code&gt; in perl?</source>
          <target state="translated">Perl에서 &lt;code&gt;tail -f&lt;/code&gt; 를 어떻게 수행 합니까?</target>
        </trans-unit>
        <trans-unit id="08d06a078c58ebbf0c5a4ee81c3c6214665f0e66" translate="yes" xml:space="preserve">
          <source>How do I do a tail -f in perl?</source>
          <target state="translated">Perl에서 tail -f를 어떻게 수행합니까?</target>
        </trans-unit>
        <trans-unit id="8a1d6beddae75cca1e0c47c227a5ded3e3a37f2c" translate="yes" xml:space="preserve">
          <source>How do I do fancy stuff with the keyboard/screen/mouse?</source>
          <target state="translated">키보드 / 스크린 / 마우스로 어떻게 멋진 일을합니까?</target>
        </trans-unit>
        <trans-unit id="beaabf13bf44c3d2a6f003d0da1ad9d016f78129" translate="yes" xml:space="preserve">
          <source>How do I dup() a filehandle in Perl?</source>
          <target state="translated">Perl에서 파일 핸들을 어떻게 dup ()합니까?</target>
        </trans-unit>
        <trans-unit id="c99c99752028698e07bd697c4f55f10aeb2574b2" translate="yes" xml:space="preserve">
          <source>How do I efficiently match many regular expressions at once?</source>
          <target state="translated">한 번에 여러 정규식을 효율적으로 일치시키는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="d8501dfb7a286a0bc3e79d726ff0aa33a83b4611" translate="yes" xml:space="preserve">
          <source>How do I expand function calls in a string?</source>
          <target state="translated">문자열에서 함수 호출을 어떻게 확장합니까?</target>
        </trans-unit>
        <trans-unit id="40ad9f6ac9837b05501210a465bcfa76304dce6b" translate="yes" xml:space="preserve">
          <source>How do I expand tabs in a string?</source>
          <target state="translated">문자열에서 탭을 어떻게 확장합니까?</target>
        </trans-unit>
        <trans-unit id="1794d4b7480b0f45fea6bded5c811dbf977507ba" translate="yes" xml:space="preserve">
          <source>How do I extract URLs?</source>
          <target state="translated">URL은 어떻게 추출합니까?</target>
        </trans-unit>
        <trans-unit id="4490e28bfd20b3131d4a6a9a43d5708c9217af3c" translate="yes" xml:space="preserve">
          <source>How do I extract selected columns from a string?</source>
          <target state="translated">문자열에서 선택한 열을 어떻게 추출합니까?</target>
        </trans-unit>
        <trans-unit id="5e9ce3143a0232dce445afb94a4cd2cbabc5866a" translate="yes" xml:space="preserve">
          <source>How do I fetch an HTML file?</source>
          <target state="translated">HTML 파일을 가져 오려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="5874d66493051782bd5b330106175c43ebb7b6dd" translate="yes" xml:space="preserve">
          <source>How do I fetch/put an (S)FTP file?</source>
          <target state="translated">(S) FTP 파일을 어떻게 가져 오거나 넣습니까?</target>
        </trans-unit>
        <trans-unit id="930fdbc050be8c4df7c4e53dd8aa59f284368264" translate="yes" xml:space="preserve">
          <source>How do I find matching/nesting anything?</source>
          <target state="translated">일치하는 항목을 찾는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="bc8fb538829e6c584fa0187f483d1bbaba9e7351" translate="yes" xml:space="preserve">
          <source>How do I find out if I'm running interactively or not?</source>
          <target state="translated">대화식으로 실행 중인지 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="67eefe0342c38d62f056273caef773f2b1d22382" translate="yes" xml:space="preserve">
          <source>How do I find out my hostname, domainname, or IP address?</source>
          <target state="translated">호스트 이름, 도메인 이름 또는 IP 주소를 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="b35cce5c620df3c5213a5b63c9524655cbb9d4b9" translate="yes" xml:space="preserve">
          <source>How do I find out which operating system I'm running under?</source>
          <target state="translated">어떤 운영 체제를 실행하고 있는지 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="01907eb2e6a268c88ab9c2c3bfb59105a7c7e3c4" translate="yes" xml:space="preserve">
          <source>How do I find the current century or millennium?</source>
          <target state="translated">현재 세기 나 밀레니엄은 어떻게 찾습니까?</target>
        </trans-unit>
        <trans-unit id="3463510f64a1c5a49fcc37902eead9f9ac95605b" translate="yes" xml:space="preserve">
          <source>How do I find the day or week of the year?</source>
          <target state="translated">일 또는 주를 어떻게 찾습니까?</target>
        </trans-unit>
        <trans-unit id="982d40212fc998a0686d78df9c4ba26898354f0e" translate="yes" xml:space="preserve">
          <source>How do I find the first array element for which a condition is true?</source>
          <target state="translated">조건이 참인 첫 번째 배열 요소를 어떻게 찾습니까?</target>
        </trans-unit>
        <trans-unit id="74e25e9ffe5b922252ebf9163105b704200cdbaf" translate="yes" xml:space="preserve">
          <source>How do I find the soundex value of a string?</source>
          <target state="translated">문자열의 soundex 값을 어떻게 찾습니까?</target>
        </trans-unit>
        <trans-unit id="d5fb344779130b34177124faae9f510c7450c0be" translate="yes" xml:space="preserve">
          <source>How do I find the user's mail address?</source>
          <target state="translated">사용자의 메일 주소는 어떻게 찾습니까?</target>
        </trans-unit>
        <trans-unit id="9b5f48590c3589b927773b9f4489ef3e2df19ab7" translate="yes" xml:space="preserve">
          <source>How do I find which modules are installed on my system?</source>
          <target state="translated">시스템에 어떤 모듈이 설치되어 있는지 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="db22bcad0e65ee82eb15cee813db7ad1bc862f74" translate="yes" xml:space="preserve">
          <source>How do I find yesterday's date?</source>
          <target state="translated">어제 날짜는 어떻게 찾습니까?</target>
        </trans-unit>
        <trans-unit id="f14d19d9f33ebecf97e59acd91f7a3e35d168a35" translate="yes" xml:space="preserve">
          <source>How do I flush/unbuffer an output filehandle? Why must I do this?</source>
          <target state="translated">출력 파일 핸들을 플러시 / 버퍼 해제하려면 어떻게해야합니까? 왜 이렇게해야합니까?</target>
        </trans-unit>
        <trans-unit id="50ced00e1da5731e9f081395bef33daf71015cca" translate="yes" xml:space="preserve">
          <source>How do I fork a daemon process?</source>
          <target state="translated">데몬 프로세스를 어떻게 포크합니까?</target>
        </trans-unit>
        <trans-unit id="af1e555b8ad44f5ee09984b301d45f763b3ab693" translate="yes" xml:space="preserve">
          <source>How do I get a file's timestamp in perl?</source>
          <target state="translated">펄에서 파일의 타임 스탬프를 어떻게 얻습니까?</target>
        </trans-unit>
        <trans-unit id="f416b305fcb8113d5bc19886df8b83bac5c89fb3" translate="yes" xml:space="preserve">
          <source>How do I get a random number between X and Y?</source>
          <target state="translated">X와 Y 사이의 난수를 어떻게 얻습니까?</target>
        </trans-unit>
        <trans-unit id="0f092c3cc9246e7de03f0d8e8c730fbe8df49215" translate="yes" xml:space="preserve">
          <source>How do I get the screen size?</source>
          <target state="translated">화면 크기는 어떻게 얻습니까?</target>
        </trans-unit>
        <trans-unit id="c3313630d3f982060a390f5f1946717a57153c40" translate="yes" xml:space="preserve">
          <source>How do I handle binary data correctly?</source>
          <target state="translated">이진 데이터를 올바르게 처리하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="3d9eeab5302abcd051b9c7c58a10262f71b93d0d" translate="yes" xml:space="preserve">
          <source>How do I handle circular lists?</source>
          <target state="translated">순환 목록을 어떻게 처리합니까?</target>
        </trans-unit>
        <trans-unit id="25bc3d27f1f1d3400779cec866f02e11e267bcde" translate="yes" xml:space="preserve">
          <source>How do I handle linked lists?</source>
          <target state="translated">링크 된 목록을 어떻게 처리합니까?</target>
        </trans-unit>
        <trans-unit id="22ab3c17d49644f7643e768f33f866efb0521ae5" translate="yes" xml:space="preserve">
          <source>How do I install a &quot;DEVELOPER RELEASE&quot; of a module?</source>
          <target state="translated">모듈의 &quot;DEVELOPER RELEASE&quot;를 어떻게 설치합니까?</target>
        </trans-unit>
        <trans-unit id="51ca5bd4b613176b7121cb512580f3d074cc9e12" translate="yes" xml:space="preserve">
          <source>How do I install a module and all its dependencies from the commandline, without being prompted for anything, despite my CPAN configuration (or lack thereof)?</source>
          <target state="translated">CPAN 구성 (또는 부족)에도 불구하고 아무 프롬프트없이 모듈과 모듈의 모든 종속성을 명령 줄에서 어떻게 설치합니까?</target>
        </trans-unit>
        <trans-unit id="332f266fa06f1a0ab802b1da5c10c6890675f4de" translate="yes" xml:space="preserve">
          <source>How do I install a module from CPAN?</source>
          <target state="translated">CPAN에서 모듈을 어떻게 설치합니까?</target>
        </trans-unit>
        <trans-unit id="779b60119e9ac89f1b4bb8ccca7aa17790f78529" translate="yes" xml:space="preserve">
          <source>How do I keep my own module/library directory?</source>
          <target state="translated">자체 모듈 / 라이브러리 디렉토리를 유지하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="712ff90db628f146b683448ab9a743ea57d1a8f1" translate="yes" xml:space="preserve">
          <source>How do I keep persistent data across program calls?</source>
          <target state="translated">프로그램 호출에서 지속적인 데이터를 유지하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="a20b09e11bad429f8e02c602624e45b441c22369" translate="yes" xml:space="preserve">
          <source>How do I look up a hash element by value?</source>
          <target state="translated">값으로 해시 요소를 어떻게 조회합니까?</target>
        </trans-unit>
        <trans-unit id="fc81f211ace7f04a35490b5be3fe4452ee1626e9" translate="yes" xml:space="preserve">
          <source>How do I make a system() exit on control-C?</source>
          <target state="translated">control-C에서 system ()을 어떻게 종료합니까?</target>
        </trans-unit>
        <trans-unit id="58c641789837b76dd9abee18041837a328da4bf8" translate="yes" xml:space="preserve">
          <source>How do I make a temporary file name?</source>
          <target state="translated">임시 파일 이름은 어떻게 만듭니 까?</target>
        </trans-unit>
        <trans-unit id="f0fab6b039e898671e7205067775272f3896476e" translate="yes" xml:space="preserve">
          <source>How do I make sure users can't enter values into a form that causes my CGI script to do bad things?</source>
          <target state="translated">사용자가 CGI 스크립트가 나쁜 일을하게하는 양식에 값을 입력 할 수 없도록하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="9e83c97b2d0052618a071494ce58ad0aa5de46bd" translate="yes" xml:space="preserve">
          <source>How do I manipulate arrays of bits?</source>
          <target state="translated">비트 배열을 어떻게 조작합니까?</target>
        </trans-unit>
        <trans-unit id="f91d0deef997d3bfa3ece796fb840e0045a0792b" translate="yes" xml:space="preserve">
          <source>How do I match XML, HTML, or other nasty, ugly things with a regex?</source>
          <target state="translated">XML, HTML 또는 다른 불쾌한 추악한 것들을 정규식과 어떻게 일치 시키는가?</target>
        </trans-unit>
        <trans-unit id="9e10d6b9fcc0dce9241e02f9e3f41bcdabf8cf6b" translate="yes" xml:space="preserve">
          <source>How do I match a regular expression that's in a variable?</source>
          <target state="translated">변수에있는 정규식과 어떻게 일치합니까?</target>
        </trans-unit>
        <trans-unit id="5d4e304caa9da74ae39c7e0f1bc8a660a934e36b" translate="yes" xml:space="preserve">
          <source>How do I merge two hashes?</source>
          <target state="translated">두 개의 해시를 어떻게 병합합니까?</target>
        </trans-unit>
        <trans-unit id="e98a867a19e12d012764c76bf6e04f0613af63d6" translate="yes" xml:space="preserve">
          <source>How do I modify the shadow password file on a Unix system?</source>
          <target state="translated">유닉스 시스템에서 섀도 패스워드 파일을 어떻게 수정합니까?</target>
        </trans-unit>
        <trans-unit id="c7095e8729e8a7f2287429c858bc0e6162426248" translate="yes" xml:space="preserve">
          <source>How do I multiply matrices?</source>
          <target state="translated">행렬을 어떻게 곱합니까?</target>
        </trans-unit>
        <trans-unit id="9460689c66cd7c2602f152fc7b62b5a75f54acdd" translate="yes" xml:space="preserve">
          <source>How do I open a file without blocking?</source>
          <target state="translated">차단하지 않고 파일을 어떻게 열 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="9724c57d7e62b1229f27e461cfe00d869c775e7e" translate="yes" xml:space="preserve">
          <source>How do I pack arrays of doubles or floats for XS code?</source>
          <target state="translated">XS 코드를 위해 double 또는 float 배열을 어떻게 포장합니까?</target>
        </trans-unit>
        <trans-unit id="4400dc02ad15b6fc00f373b7446035015d4ee6bf" translate="yes" xml:space="preserve">
          <source>How do I pad a string with blanks or pad a number with zeroes?</source>
          <target state="translated">공백으로 문자열을 채우거나 0으로 숫자를 채우려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="d0e3e8a036359d14fc456cf2c14236b5f608bd62" translate="yes" xml:space="preserve">
          <source>How do I parse a mail header?</source>
          <target state="translated">메일 헤더를 어떻게 파싱합니까?</target>
        </trans-unit>
        <trans-unit id="9e0cafd923d528d129dae6e8757b0045ebfe45d2" translate="yes" xml:space="preserve">
          <source>How do I perform an operation on a series of integers?</source>
          <target state="translated">일련의 정수에서 작업을 수행하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="0ea5e302520f6bb39c41ab5c626ec6b77bff9c77" translate="yes" xml:space="preserve">
          <source>How do I permute N elements of a list?</source>
          <target state="translated">목록의 N 개 요소를 치환하는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="5b942fa715d105d63d048d010625e34a4e15cc06" translate="yes" xml:space="preserve">
          <source>How do I print out or copy a recursive data structure?</source>
          <target state="translated">재귀 데이터 구조를 인쇄하거나 복사하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="0cee12c0d629b76061795de4e8ea8e8aad20c9a2" translate="yes" xml:space="preserve">
          <source>How do I print something out in color?</source>
          <target state="translated">컬러로 인쇄하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="8c5e011ff87e317620443254f20726209e4d5142" translate="yes" xml:space="preserve">
          <source>How do I print to more than one file at once?</source>
          <target state="translated">한 번에 여러 파일로 인쇄하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="8e6e30c99d7d46a63b6dd2a8de7f090b5c3b78f8" translate="yes" xml:space="preserve">
          <source>How do I process an entire hash?</source>
          <target state="translated">전체 해시를 어떻게 처리합니까?</target>
        </trans-unit>
        <trans-unit id="271b9d3d652ec230aba0c388cad00cfb6ec4cadb" translate="yes" xml:space="preserve">
          <source>How do I process each word on each line?</source>
          <target state="translated">각 줄에서 각 단어를 어떻게 처리합니까?</target>
        </trans-unit>
        <trans-unit id="067d5b88bfca3ed1b6b7d97cd252f5dd16cbb5b2" translate="yes" xml:space="preserve">
          <source>How do I process/modify each element of an array?</source>
          <target state="translated">배열의 각 요소를 어떻게 처리 / 수정합니까?</target>
        </trans-unit>
        <trans-unit id="4b013be3c59b874a12db528d39cfb66ea2b4d285" translate="yes" xml:space="preserve">
          <source>How do I profile my Perl programs?</source>
          <target state="translated">Perl 프로그램을 어떻게 프로파일합니까?</target>
        </trans-unit>
        <trans-unit id="907ce6af6f55d655a78f0e8c0ae363954d37ba4f" translate="yes" xml:space="preserve">
          <source>How do I put a &quot;-?&quot; option into a Getopt::Long?</source>
          <target state="translated">&quot;-&quot;를 어떻게 넣습니까? 옵션을 Getopt :: Long?</target>
        </trans-unit>
        <trans-unit id="c7fe97c54150572fb4431657021f14d59fd4861f" translate="yes" xml:space="preserve">
          <source>How do I put a password on my web pages?</source>
          <target state="translated">웹 페이지에 비밀번호를 어떻게 입력합니까?</target>
        </trans-unit>
        <trans-unit id="aabceca15e4a4d5d9ca824c2b010057c5ffb938d" translate="yes" xml:space="preserve">
          <source>How do I randomly update a binary file?</source>
          <target state="translated">이진 파일을 무작위로 어떻게 업데이트합니까?</target>
        </trans-unit>
        <trans-unit id="be52f21f6d10d6ab8f3f91d7f9754bf001810264" translate="yes" xml:space="preserve">
          <source>How do I read and write the serial port?</source>
          <target state="translated">직렬 포트를 읽고 쓰는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="88cf95522fd81b968df3c101e350990093c3aa09" translate="yes" xml:space="preserve">
          <source>How do I read email?</source>
          <target state="translated">이메일은 어떻게 읽습니까?</target>
        </trans-unit>
        <trans-unit id="f7f8ec70d59120dd78e53b84aba791742e9edd1e" translate="yes" xml:space="preserve">
          <source>How do I read just one key without waiting for a return key?</source>
          <target state="translated">리턴 키를 기다리지 않고 하나의 키를 어떻게 읽습니까?</target>
        </trans-unit>
        <trans-unit id="90d36808740d961fdd3bc4db24c2ee814f31ee7c" translate="yes" xml:space="preserve">
          <source>How do I redefine a builtin function, operator, or method?</source>
          <target state="translated">내장 함수, 연산자 또는 메소드를 어떻게 재정의합니까?</target>
        </trans-unit>
        <trans-unit id="64b8d2bb065ca77fe0dc5f5fef705f4b317c4fca" translate="yes" xml:space="preserve">
          <source>How do I redirect to another page?</source>
          <target state="translated">다른 페이지로 리디렉션하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="0261e937b4173727b02c00645ba76e6a415fae20" translate="yes" xml:space="preserve">
          <source>How do I reformat a paragraph?</source>
          <target state="translated">단락을 어떻게 다시 포맷합니까?</target>
        </trans-unit>
        <trans-unit id="0eeeab64d2dc7e3dd771f347a9a11591454f54b3" translate="yes" xml:space="preserve">
          <source>How do I remove HTML from a string?</source>
          <target state="translated">문자열에서 HTML을 어떻게 제거합니까?</target>
        </trans-unit>
        <trans-unit id="7190f2c95452c7e338420c52915e20b7f528657f" translate="yes" xml:space="preserve">
          <source>How do I remove consecutive pairs of characters?</source>
          <target state="translated">연속 된 문자 쌍을 제거하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="d5da8d0925bfcf1ec95ecac71470e320a20303f5" translate="yes" xml:space="preserve">
          <source>How do I reset an each() operation part-way through?</source>
          <target state="translated">each () 작업을 도중에 어떻게 재설정합니까?</target>
        </trans-unit>
        <trans-unit id="344b42394088d6a1b32ccef3d8e8decb8e4c01b4" translate="yes" xml:space="preserve">
          <source>How do I reverse a string?</source>
          <target state="translated">문자열을 어떻게 바꾸나요?</target>
        </trans-unit>
        <trans-unit id="c109790cdec5d8d7c505dc674edb8df7914a81e2" translate="yes" xml:space="preserve">
          <source>How do I select a random element from an array?</source>
          <target state="translated">배열에서 임의의 요소를 어떻게 선택합니까?</target>
        </trans-unit>
        <trans-unit id="199c93de57e75c85ebb9d101614dabcde24b6614" translate="yes" xml:space="preserve">
          <source>How do I select a random line from a file?</source>
          <target state="translated">파일에서 임의의 줄을 어떻게 선택합니까?</target>
        </trans-unit>
        <trans-unit id="39ccafc4ea9b3fd7b952612609873f9c549c7c42" translate="yes" xml:space="preserve">
          <source>How do I send email?</source>
          <target state="translated">이메일을 보내려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="56fc4c1960e173cac75e9d994591b6be91c2c2f5" translate="yes" xml:space="preserve">
          <source>How do I set CPU limits?</source>
          <target state="translated">CPU 제한은 어떻게 설정합니까?</target>
        </trans-unit>
        <trans-unit id="73ae95585e094adfdbb75ef9f256a18859cff476" translate="yes" xml:space="preserve">
          <source>How do I set a file's timestamp in perl?</source>
          <target state="translated">펄에서 파일의 타임 스탬프를 어떻게 설정합니까?</target>
        </trans-unit>
        <trans-unit id="7015da22cf6dfd7afb1594ce5e8862f937d3b755" translate="yes" xml:space="preserve">
          <source>How do I set the time and date?</source>
          <target state="translated">시간과 날짜를 어떻게 설정합니까?</target>
        </trans-unit>
        <trans-unit id="36b77dc941cd48cd98a47f8dbd2c57de165d3aa2" translate="yes" xml:space="preserve">
          <source>How do I shuffle an array randomly?</source>
          <target state="translated">배열을 무작위로 섞는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="c56fb4f98404c5161610269f73993e7de95a3de7" translate="yes" xml:space="preserve">
          <source>How do I skip some return values?</source>
          <target state="translated">일부 반환 값을 건너 뛰려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="f999ee460d48e77fd71574c2f54756bd21091885" translate="yes" xml:space="preserve">
          <source>How do I sort a hash (optionally by value instead of key)?</source>
          <target state="translated">해시를 정렬하려면 어떻게해야합니까 (선택적으로 키 대신 값으로)?</target>
        </trans-unit>
        <trans-unit id="3557025618ab23a2cf788475e1bcca26065db241" translate="yes" xml:space="preserve">
          <source>How do I sort an array by (anything)?</source>
          <target state="translated">(아무 것으로) 배열을 어떻게 정렬합니까?</target>
        </trans-unit>
        <trans-unit id="11e9e959693213fc786f53e3eeef7ea5001cbb5a" translate="yes" xml:space="preserve">
          <source>How do I start a process in the background?</source>
          <target state="translated">백그라운드에서 프로세스를 시작하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="e8df49adcf72001a3aba0a320e673d15d1fbff49" translate="yes" xml:space="preserve">
          <source>How do I store complex data structures with DB_File?</source>
          <target state="translated">DB_File로 복잡한 데이터 구조를 어떻게 저장합니까?</target>
        </trans-unit>
        <trans-unit id="d0810d8592d3996c240e80dd3d6e5421e650a5a9" translate="yes" xml:space="preserve">
          <source>How do I strip blank space from the beginning/end of a string?</source>
          <target state="translated">문자열의 시작 / 끝에서 공백을 어떻게 제거합니까?</target>
        </trans-unit>
        <trans-unit id="8ae8648605278dba0e8e66d1aa18bb02cd9cbee2" translate="yes" xml:space="preserve">
          <source>How do I substitute case-insensitively on the LHS while preserving case on the RHS?</source>
          <target state="translated">RHS에서 케이스를 보존하면서 LHS에서 대소 문자를 구분하지 않고 대체하는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="32d79b5f1ff74cbc3bfb77b42941e7971f7cd494" translate="yes" xml:space="preserve">
          <source>How do I tell the difference between errors from the shell and perl?</source>
          <target state="translated">쉘과 펄의 오류의 차이점을 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="402cd06b394cf67e3d76498ee9b3e9b9d87437a0" translate="yes" xml:space="preserve">
          <source>How do I temporarily block warnings?</source>
          <target state="translated">경고를 일시적으로 차단하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="c0789eca0c8fd61b4175e61db4aa71f599404e50" translate="yes" xml:space="preserve">
          <source>How do I test whether two arrays or hashes are equal?</source>
          <target state="translated">두 배열 또는 해시가 같은지 어떻게 테스트합니까?</target>
        </trans-unit>
        <trans-unit id="e84b81ceb7f858ca3fa98015c2c4dfea66af9e8b" translate="yes" xml:space="preserve">
          <source>How do I timeout a slow event?</source>
          <target state="translated">느린 이벤트 시간을 어떻게 초과합니까?</target>
        </trans-unit>
        <trans-unit id="e46e5cb6feaa9bdc58f6ceead41bdfe807157710" translate="yes" xml:space="preserve">
          <source>How do I trap control characters/signals?</source>
          <target state="translated">제어 문자 / 신호를 어떻게 트랩합니까?</target>
        </trans-unit>
        <trans-unit id="d2dd15b6c1b33b3c86eddf841d0c83120333ce34" translate="yes" xml:space="preserve">
          <source>How do I traverse a directory tree?</source>
          <target state="translated">디렉토리 트리를 어떻게 통과합니까?</target>
        </trans-unit>
        <trans-unit id="e9dd0c064f83a182ab0d7dad0b56b72fe36b708b" translate="yes" xml:space="preserve">
          <source>How do I unescape a string?</source>
          <target state="translated">문자열을 이스케이프 해제하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="de74f402e85f9eee7aa46222792929c66c3f3ab7" translate="yes" xml:space="preserve">
          <source>How do I use MIME to make an attachment to a mail message?</source>
          <target state="translated">MIME을 사용하여 메일 메시지에 첨부하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="ec6da1c1f95c027b2d1444208c25f958dcd9f486" translate="yes" xml:space="preserve">
          <source>How do I use a regular expression to strip C-style comments from a file?</source>
          <target state="translated">파일에서 C 스타일 주석을 제거하기 위해 정규식을 어떻게 사용합니까?</target>
        </trans-unit>
        <trans-unit id="a8b6bf66c7856a15f241de6c0802175e07cd63b3" translate="yes" xml:space="preserve">
          <source>How do I use all this in extensions?</source>
          <target state="translated">확장에서이 모든 것을 어떻게 사용합니까?</target>
        </trans-unit>
        <trans-unit id="b826b48e54f42be4d7b4af41a8de11eb743f6b7a" translate="yes" xml:space="preserve">
          <source>How do I use an SQL database?</source>
          <target state="translated">SQL 데이터베이스는 어떻게 사용합니까?</target>
        </trans-unit>
        <trans-unit id="2bdd87983f12ab09515439198b26c02b64e724f4" translate="yes" xml:space="preserve">
          <source>How do I validate input?</source>
          <target state="translated">입력은 어떻게 확인합니까?</target>
        </trans-unit>
        <trans-unit id="26964c4f36b19d9f1a78d8688cbdbdb4cea51cb7" translate="yes" xml:space="preserve">
          <source>How do I verify a credit card checksum?</source>
          <target state="translated">신용 카드 체크섬은 어떻게 확인합니까?</target>
        </trans-unit>
        <trans-unit id="4f3796bf485f2eb722b7ed35a129d4469581633e" translate="yes" xml:space="preserve">
          <source>How do we do it? You might think first to use &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;; however, since &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; collapses blank fields, you'll never know whether a record was income or expenditure. Oops. Well, you could always use &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">우리는 어떻게합니까? 먼저 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 을 사용한다고 생각할 수도 있습니다 . 그러나 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 이 빈 필드를 축소하므로 레코드가 수입인지 지출인지 알 수 없습니다. 죄송합니다. 글쎄, 당신은 항상 &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;&lt;/code&gt; 을 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="adb503b87f7ea09a8ed712efab2105d52de66798" translate="yes" xml:space="preserve">
          <source>How do we know if the &lt;code&gt;U&lt;/code&gt; is the first format in the &lt;code&gt;pat&lt;/code&gt; ? Well, if we have a pointer to the start of &lt;code&gt;pat&lt;/code&gt; then, if we see a &lt;code&gt;U&lt;/code&gt; we can test whether we're still at the start of the string. So, here's where &lt;code&gt;pat&lt;/code&gt; is set up:</source>
          <target state="translated">&lt;code&gt;U&lt;/code&gt; 가 &lt;code&gt;pat&lt;/code&gt; 의 첫 번째 형식 인지 어떻게 알 수 있습니까? 음, &lt;code&gt;pat&lt;/code&gt; 의 시작에 대한 포인터가 있다면 &lt;code&gt;U&lt;/code&gt; 를 보면 여전히 문자열의 시작에 있는지 테스트 할 수 있습니다. 여기 &lt;code&gt;pat&lt;/code&gt; 이 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="41c2d105be109eed3cac8eac59cfe5a2af927614" translate="yes" xml:space="preserve">
          <source>How do we prepare to fix this up? First we locate the code in question - the &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; happens at runtime, so it's going to be in one of the</source>
          <target state="translated">이 문제를 해결하기 위해 어떻게 준비합니까? 먼저 문제의 코드를 찾습니다. &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 은 런타임에 발생하므로 다음 중 하나에 속합니다.</target>
        </trans-unit>
        <trans-unit id="24a7f470a36048c277bd60a862a28514c120a416" translate="yes" xml:space="preserve">
          <source>How do you know that you've made the right decisions? Have you picked an interface design that will cause problems later? Have you picked the most appropriate name? Do you have any questions?</source>
          <target state="translated">올바른 결정을 내렸다는 것을 어떻게 알 수 있습니까? 나중에 문제를 일으킬 인터페이스 디자인을 선택 했습니까? 가장 적합한 이름을 선택 했습니까? 질문있으세요?</target>
        </trans-unit>
        <trans-unit id="41a4f1d575f0f11ff6874b18c40b76daeb66d4c2" translate="yes" xml:space="preserve">
          <source>How do you print it out? Why can't you say just &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; @AoA&lt;/code&gt; ? How do you sort it? How can you pass it to a function or get one of these back from a function? Is it an object? Can you save it to disk to read back later? How do you access whole rows or columns of that matrix? Do all the values have to be numeric?</source>
          <target state="translated">어떻게 인쇄합니까? 왜 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; @AoA&lt;/code&gt; &lt;a href=&quot;functions/print&quot;&gt;인쇄&lt;/a&gt; 한다고 말할 수 없습니까 ? 어떻게 정렬합니까? 어떻게 함수에 전달하거나 함수에서 다시 가져올 수 있습니까? 대상입니까? 나중에 읽을 수 있도록 디스크에 저장할 수 있습니까? 해당 행렬의 전체 행 또는 열에 어떻게 액세스합니까? 모든 값이 숫자 여야합니까?</target>
        </trans-unit>
        <trans-unit id="0db30a52c84584239974d26d09f54763e3e6b602" translate="yes" xml:space="preserve">
          <source>How do you want to capitalize those words?</source>
          <target state="translated">이 단어들을 어떻게 대문자로 사용 하시겠습니까?</target>
        </trans-unit>
        <trans-unit id="057ea76fe6b43747bac035e0aa618c75b67755d7" translate="yes" xml:space="preserve">
          <source>How does &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;P&lt;/code&gt; work? Imagine some pointer in the buffer about to be unpacked: If it isn't the null pointer (which will smartly produce the &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; value) we have a start address - but then what? Perl has no way of knowing how long this &quot;fixed length string&quot; is, so it's up to you to specify the actual size as an explicit length after &lt;code&gt;P&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;P&lt;/code&gt; 로 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 는 어떻게 작동합니까? 버퍼에서 언 패킹 될 일부 포인터를 상상해보십시오. 널 포인터가 아닌 경우 ( &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 값을 생성 할 ) 시작 주소가 있습니다. Perl은이 &quot;고정 길이 문자열&quot;의 길이를 알 수있는 방법이 없으므로 실제 크기를 &lt;code&gt;P&lt;/code&gt; 뒤에 명시 적 길이로 지정하는 것은 사용자의 몫 입니다.</target>
        </trans-unit>
        <trans-unit id="9905196a168946e4c1e199eb5d4a39f1df926922" translate="yes" xml:space="preserve">
          <source>How does C3 work</source>
          <target state="translated">C3는 어떻게 작동합니까</target>
        </trans-unit>
        <trans-unit id="ec67f8e66f8cd607856093fe73d4e05432e16189" translate="yes" xml:space="preserve">
          <source>How does Perl compare with other languages like Java, Python, REXX, Scheme, or Tcl?</source>
          <target state="translated">Perl은 Java, Python, REXX, Scheme 또는 Tcl과 같은 다른 언어와 어떻게 비교됩니까?</target>
        </trans-unit>
        <trans-unit id="1c4f7191bdf4e77d9f3df9d3633a24eb4798422b" translate="yes" xml:space="preserve">
          <source>How does Perl store UTF-8 strings?</source>
          <target state="translated">Perl은 UTF-8 문자열을 어떻게 저장합니까?</target>
        </trans-unit>
        <trans-unit id="d6555d1bc4e0774734c01cf5a9778e9667013a49" translate="yes" xml:space="preserve">
          <source>How does UTF-8 represent Unicode characters?</source>
          <target state="translated">UTF-8은 유니 코드 문자를 어떻게 표현합니까?</target>
        </trans-unit>
        <trans-unit id="7cc6d699d794fc3ac271d46b893bbe5d8af9561d" translate="yes" xml:space="preserve">
          <source>How does the HAS_QUUX become defined where it needs to be? Well, if Foonix happens to be Unixy enough to be able to run the Configure script, and Configure has been taught about detecting and testing quux(), the HAS_QUUX will be correctly defined. In other platforms, the corresponding configuration step will hopefully do the same.</source>
          <target state="translated">HAS_QUUX는 필요한 곳에 어떻게 정의됩니까? Foonix가 Configure 스크립트를 실행할 수있을 정도로 Unixy 인 경우 quux () 감지 및 테스트에 대해 Configure에 대해 학습 한 경우 HAS_QUUX가 올바르게 정의됩니다. 다른 플랫폼에서는 해당 구성 단계가 동일하게 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="a7654b1f75662fbb39441273d3ed984d7a322d6a" translate="yes" xml:space="preserve">
          <source>How far up the call stack should &lt;code&gt;$Test&lt;/code&gt; look when reporting where the test failed.</source>
          <target state="translated">테스트가 실패한 위치를보고 할 때 콜 스택에서 &lt;code&gt;$Test&lt;/code&gt; 까지의 거리 .</target>
        </trans-unit>
        <trans-unit id="085217ef4c6745e3415b3c7e78584430d39a3a20" translate="yes" xml:space="preserve">
          <source>How field hashes work</source>
          <target state="translated">필드 해시 작동 방식</target>
        </trans-unit>
        <trans-unit id="1dd6a17cb4033f4f74df1bb6912b8a28a8074084" translate="yes" xml:space="preserve">
          <source>How it works</source>
          <target state="translated">작동 원리</target>
        </trans-unit>
        <trans-unit id="0c8392c4bc182245c6112422d8ac379f29dc0269" translate="yes" xml:space="preserve">
          <source>How many days shall we keep statistics about downloads?</source>
          <target state="translated">다운로드에 대한 통계는 며칠 동안 유지해야합니까?</target>
        </trans-unit>
        <trans-unit id="a2df7a98d6c586141cd04b6aa0105c17934a6b57" translate="yes" xml:space="preserve">
          <source>How many items shall we keep in the statistics about downloads?</source>
          <target state="translated">다운로드 통계에 몇 개의 항목을 보관해야합니까?</target>
        </trans-unit>
        <trans-unit id="a4c476d15c4f91ec82f82f8c5a4b611455926ad6" translate="yes" xml:space="preserve">
          <source>How many things you have to skip over when moving from the beginning of a string or array to a specific position within it. Thus, the minimum offset is zero, not one, because you don&amp;rsquo;t skip anything to get to the first item.</source>
          <target state="translated">문자열이나 배열의 시작 부분에서 특정 위치로 이동할 때 건너 뛰어야 할 항목 수 따라서 첫 번째 항목으로 이동하는 항목을 건너 뛰지 않기 때문에 최소 오프셋은 1이 아니라 0입니다.</target>
        </trans-unit>
        <trans-unit id="06d061df76ab13c25cd39004271d0f48f24f772c" translate="yes" xml:space="preserve">
          <source>How multiple interpreters and concurrency are supported</source>
          <target state="translated">여러 통역사 및 동시성이 지원되는 방법</target>
        </trans-unit>
        <trans-unit id="6077b2c6a621300c72c26286304312a48389905e" translate="yes" xml:space="preserve">
          <source>How often are new versions of Perl released?</source>
          <target state="translated">Perl의 새 버전은 얼마나 자주 출시됩니까?</target>
        </trans-unit>
        <trans-unit id="09667313848c3831b4f83a58be79ca17489cfe27" translate="yes" xml:space="preserve">
          <source>How stable is Perl?</source>
          <target state="translated">Perl은 얼마나 안정적입니까?</target>
        </trans-unit>
        <trans-unit id="83c34a283446a710c37e72f2a9adb47d8902892c" translate="yes" xml:space="preserve">
          <source>How that string gets evaluated is entirely subject to the command interpreter on your system. On most platforms, you will have to protect shell metacharacters if you want them treated literally. This is in practice difficult to do, as it's unclear how to escape which characters. See &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; for a clean and safe example of a manual &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; to emulate backticks safely.</source>
          <target state="translated">해당 문자열을 평가하는 방법은 시스템의 명령 인터프리터에 전적으로 적용됩니다. 대부분의 플랫폼에서 문자 그대로 처리하려면 셸 메타 문자를 보호해야합니다. 어떤 캐릭터를 이스케이프 처리하는 방법이 확실하지 않기 때문에 실제로는 수행하기가 어렵습니다. 백틱을 안전하게 에뮬레이트 하는 수동 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; 의 깨끗하고 안전한 예제는 &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="32e58ed61895689f9ea71e1d65dd7b363842c21f" translate="yes" xml:space="preserve">
          <source>How to Eat an Egg on a Net</source>
          <target state="translated">그물에 계란을 먹는 방법</target>
        </trans-unit>
        <trans-unit id="1e92c63bea5bacbfe17288aa9b727bd5b57d76ef" translate="yes" xml:space="preserve">
          <source>How to Export</source>
          <target state="translated">수출 방법</target>
        </trans-unit>
        <trans-unit id="c94aa75d1f562c0c7126364d18c31a48ccae10ce" translate="yes" xml:space="preserve">
          <source>How to Import</source>
          <target state="translated">가져 오는 방법</target>
        </trans-unit>
        <trans-unit id="66e5306e1ee37b9c8432fab22e675761fdae05d9" translate="yes" xml:space="preserve">
          <source>How to build it - possible changes to Makefile.PL etc.</source>
          <target state="translated">빌드 방법-Makefile.PL 등의 변경 가능</target>
        </trans-unit>
        <trans-unit id="ca504da3ad384a1782b8a80c01519809d8213b8a" translate="yes" xml:space="preserve">
          <source>How to contribute to the perlfaq</source>
          <target state="translated">perlfaq에 기여하는 방법</target>
        </trans-unit>
        <trans-unit id="59750c3fc03389b5d7028878d6d502ec39f41a63" translate="yes" xml:space="preserve">
          <source>How to create a new module</source>
          <target state="translated">새 모듈을 만드는 방법</target>
        </trans-unit>
        <trans-unit id="117233b2c5097bb47b4e325f79c07984d73d5ef7" translate="yes" xml:space="preserve">
          <source>How to get a package, unwrap it, and make a change before building it?</source>
          <target state="translated">패키지를 가져 와서 포장을 풀고 빌드하기 전에 변경하는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="581ecead393f1357725f2a7ad157c2752daf62ea" translate="yes" xml:space="preserve">
          <source>How to install it.</source>
          <target state="translated">설치 방법</target>
        </trans-unit>
        <trans-unit id="745ad195185248d449699ab965e2e195908cc3f7" translate="yes" xml:space="preserve">
          <source>How to release and distribute a module.</source>
          <target state="translated">모듈을 해제하고 배포하는 방법.</target>
        </trans-unit>
        <trans-unit id="fac65371d245ce74fd54b584511aa21b655f4973" translate="yes" xml:space="preserve">
          <source>How to report errors. &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; says to throw an exception on any POD formatting error. &lt;code&gt;stderr&lt;/code&gt; says to report errors on standard error, but not to throw an exception. &lt;code&gt;pod&lt;/code&gt; says to include a POD ERRORS section in the resulting documentation summarizing the errors. &lt;code&gt;none&lt;/code&gt; ignores POD errors entirely, as much as possible.</source>
          <target state="translated">오류를보고하는 방법 &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 는 모든 POD 형식 오류에 대해 예외를 던지라고 말합니다. &lt;code&gt;stderr&lt;/code&gt; 는 표준 오류에 대한 오류를보고하지만 예외는 발생시키지 말라고 말합니다. &lt;code&gt;pod&lt;/code&gt; 는 결과 문서에 오류를 요약 한 POD ERRORS 섹션을 포함 시키라고 말합니다. &lt;code&gt;none&lt;/code&gt; 은 가능한 한 POD 오류를 완전히 무시 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d7d2e49b42408e54cf7a34c3e80635f480f9c4a8" translate="yes" xml:space="preserve">
          <source>How to use Field Hashes</source>
          <target state="translated">필드 해시 사용법</target>
        </trans-unit>
        <trans-unit id="fc1ff928efd359368d94e6d36c9ac3ed9b57df61" translate="yes" xml:space="preserve">
          <source>How to use ppport.h</source>
          <target state="translated">ppport.h 사용법</target>
        </trans-unit>
        <trans-unit id="76a1aee9e2d87dca5af8b9f3523a520421f66d36" translate="yes" xml:space="preserve">
          <source>How to use the perlfaq</source>
          <target state="translated">perlfaq를 사용하는 방법</target>
        </trans-unit>
        <trans-unit id="3f24180ceba0ec0cc68f9d5c0e1e26d52c83ce1f" translate="yes" xml:space="preserve">
          <source>How you access/control keyboards, screens, and pointing devices (&quot;mice&quot;) is system-dependent. Try the following modules:</source>
          <target state="translated">키보드, 화면 및 포인팅 장치 ( &quot;마우스&quot;)에 대한 액세스 / 제어 방법은 시스템에 따라 다릅니다. 다음 모듈을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="4bc300db17dcedeb6194b557a3ba400e45f35668" translate="yes" xml:space="preserve">
          <source>How you choose to license your work is a personal decision. The general mechanism is to assert your Copyright and then make a declaration of how others may copy/use/modify your work.</source>
          <target state="translated">작업 라이센스를 선택하는 방법은 개인적인 결정입니다. 일반적인 메커니즘은 귀하의 저작권을 주장한 다음 다른 사람이 귀하의 저작물을 복사 / 사용 / 수정하는 방법에 대한 선언을하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="eb2f13a23bf4830d2fc62239cefe549717cd58f6" translate="yes" xml:space="preserve">
          <source>How your various pieces of data relate to each other and what shape they make when you put them all together, as in a rectangular table or a triangular tree.</source>
          <target state="translated">다양한 데이터 조각이 서로 관련되는 방식과 직사각형 테이블 또는 삼각형 트리와 같이 모두 함께 모을 때 만드는 모양</target>
        </trans-unit>
        <trans-unit id="d3b89735ac32202767302de6090cfe3b522ac706" translate="yes" xml:space="preserve">
          <source>However adding a Time::Piece object to another Time::Piece object will cause a runtime error.</source>
          <target state="translated">그러나 다른 Time :: Piece 객체에 Time :: Piece 객체를 추가하면 런타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="30f041c654fc533b28dcc332c81f8669c3b80359" translate="yes" xml:space="preserve">
          <source>However any other combinations of &lt;code&gt;\&lt;/code&gt; followed by a character are not substituted but only skipped, in order to parse them as regular expressions at the following step. As &lt;code&gt;\c&lt;/code&gt; is skipped at this step, &lt;code&gt;@&lt;/code&gt; of &lt;code&gt;\c@&lt;/code&gt; in RE is possibly treated as an array symbol (for example &lt;code&gt;@foo&lt;/code&gt; ), even though the same text in &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq//&lt;/a&gt;&lt;/code&gt; gives interpolation of &lt;code&gt;\c@&lt;/code&gt; .</source>
          <target state="translated">그러나 &lt;code&gt;\&lt;/code&gt; 다음에 문자가 오는 다른 조합은 다음 단계에서 정규 표현식으로 구문 분석하기 위해 대체되지 않고 건너 뜁니다. 마찬가지로 &lt;code&gt;\c&lt;/code&gt; ,이 단계에서 건너 &lt;code&gt;@&lt;/code&gt; 의 &lt;code&gt;\c@&lt;/code&gt; 에서 RE 가능성 (예를 들어, 어레이에 대한 심볼로서 취급된다 &lt;code&gt;@foo&lt;/code&gt; 동일한 텍스트에도) &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq//&lt;/a&gt;&lt;/code&gt; 보간 제공 &lt;code&gt;\c@&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16e29f719714863d70b942d575046dbb5cba98f5" translate="yes" xml:space="preserve">
          <source>However calling these methods only affects the use of the methods above that can return a data connection. They have no effect on methods &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;put&lt;/code&gt; , &lt;code&gt;put_unique&lt;/code&gt; and those that do not require data connections.</source>
          <target state="translated">그러나 이러한 메소드를 호출하면 데이터 연결을 리턴 할 수있는 위의 메소드 사용에만 영향을줍니다. 메소드 &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;put&lt;/code&gt; , &lt;code&gt;put_unique&lt;/code&gt; 및 데이터 연결이 필요없는 메소드에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4dd9e96cfe2926dfabdbc85765517e42ef1d89e7" translate="yes" xml:space="preserve">
          <source>However if you use them for methods it is up to you to figure out how to make inheritance work.)</source>
          <target state="translated">그러나 메소드에 사용하면 상속 작업을 수행하는 방법을 결정해야합니다.)</target>
        </trans-unit>
        <trans-unit id="3eb546f277a4853248567d6d99dbadcec1483c0f" translate="yes" xml:space="preserve">
          <source>However it is possible to :</source>
          <target state="translated">그러나 다음이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="b048a4ce1b3f69d17018ba3c836a5e60080a819e" translate="yes" xml:space="preserve">
          <source>However the parent classes are set, the package's &lt;code&gt;@ISA&lt;/code&gt; variable will contain a list of those parents. This is simply a list of scalars, each of which is a string that corresponds to a package name.</source>
          <target state="translated">그러나 부모 클래스가 설정되면 패키지의 &lt;code&gt;@ISA&lt;/code&gt; 변수에 해당 부모 목록이 포함됩니다. 이것은 단순히 스칼라 목록이며, 각각은 패키지 이름에 해당하는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="ba3e62d1138ee32c59c072f255ef49bd8748a854" translate="yes" xml:space="preserve">
          <source>However the results of other styles of rounding differ if the digit immediately to the right of the rounding place (skipping the decimal point) is 5 and if there are no digits, or no digits other than 0, after that 5. In such cases:</source>
          <target state="translated">그러나 다른 반올림 스타일의 결과는 반올림 위치 바로 오른쪽에있는 자릿수 (소수점 건너 뛰기)가 5이고 그 이후 5 뒤에 숫자가 없거나 0 이외의 숫자가없는 경우 다릅니다.</target>
        </trans-unit>
        <trans-unit id="4fbf8823a3b3cfa62eaf7d0dd429a9afbd37439d" translate="yes" xml:space="preserve">
          <source>However the test engine bleeds these message to screen in unexpected moments. Two messages of this kind</source>
          <target state="translated">그러나 테스트 엔진은 예상치 못한 순간에 이러한 메시지를 화면에 표시합니다. 이런 종류의 두 가지 메시지</target>
        </trans-unit>
        <trans-unit id="ef8fc937e43b67ff40714fcd8d7fd4e3c6c06fbf" translate="yes" xml:space="preserve">
          <source>However you should never rely on the numerical position of any opcode within the opset. In other words both sides of a bit vector operator should be opsets returned from Opcode functions.</source>
          <target state="translated">그러나 옵셋 내에서 opcode의 숫자 위치에 의존해서는 안됩니다. 즉, 비트 벡터 연산자의 양쪽은 Opcode 함수에서 반환 된 opset이어야합니다.</target>
        </trans-unit>
        <trans-unit id="98648e73024116127cb39bd5de118b8a0a2cc6ca" translate="yes" xml:space="preserve">
          <source>However, Filter::Simple is smart enough to notice your existing &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; and Do The Right Thing with it. That is, if you explicitly define an &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine in a package that's using Filter::Simple, that &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine will still be invoked immediately after any filter you install.</source>
          <target state="translated">그러나 Filter :: Simple은 기존 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 하고 올바른 작업 을 수행 할 수있을 정도로 똑똑 합니다. 즉, Filter :: Simple을 사용하는 패키지에서 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 서브 루틴 을 명시 적으로 정의하면 필터를 설치 한 직후에도 해당 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 서브 루틴이 계속 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="c4b48fb21a2bbb8cdba9c4ae239ab0a9635d85aa" translate="yes" xml:space="preserve">
          <source>However, Perl supports Unicode, see &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;.</source>
          <target state="translated">그러나 Perl은 유니 코드를 지원합니다 ( &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="6aacf8e8d0ef0c63358a4dd55406f6405076e03d" translate="yes" xml:space="preserve">
          <source>However, a dynamically loaded Perl extension is forced to use some symbols from the perl executable, e.g., to know how to find the arguments to the functions: the arguments live on the perl internal evaluation stack. The solution is to put the main code of the interpreter into a DLL, and make the</source>
          <target state="translated">그러나 동적으로로드 된 Perl 확장은 perl 실행 파일의 일부 기호를 사용하여 함수에 대한 인수를 찾는 방법을 알아야합니다. 인수는 Perl 내부 평가 스택에 있습니다. 해결책은 인터프리터의 주요 코드를 DLL에 넣고</target>
        </trans-unit>
        <trans-unit id="cb42fd65a00722a5c95e1e740839f3eb31964f36" translate="yes" xml:space="preserve">
          <source>However, a misapplied space-to-NBSP replacement could (wrongly) produce something equivalent to this:</source>
          <target state="translated">그러나 잘못 적용된 NBSP 대체는 다음과 같은 것을 잘못 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81448f13f8166a4612eb5d956580cdb8ee3e6da5" translate="yes" xml:space="preserve">
          <source>However, a value assigned to &lt;code&gt;$(&lt;/code&gt; must be a single number used to set the real gid. So the value given by &lt;code&gt;$(&lt;/code&gt; should</source>
          <target state="translated">그러나 &lt;code&gt;$(&lt;/code&gt; 할당 된 값 은 실제 gid를 설정하는 데 사용되는 단일 숫자 여야합니다. 따라서 &lt;code&gt;$(&lt;/code&gt; 의해 주어진 값 은</target>
        </trans-unit>
        <trans-unit id="2623bb5aade26c0a0ddb97e7e99b8d0d79bed6e1" translate="yes" xml:space="preserve">
          <source>However, anyone particularly interested in getting the full value of the treelet, can just traverse the content of the treeleet @$treelet_object. To wit:</source>
          <target state="translated">그러나 트리 릿의 전체 가치를 얻는 데 특히 관심이있는 사람은 treeleet @ $ treelet_object의 내용을 통과 할 수 있습니다. 재치 :</target>
        </trans-unit>
        <trans-unit id="120fef724fd1ad9704e66311dce9e65e6c74f159" translate="yes" xml:space="preserve">
          <source>However, as an 80% solution it is still effective, as it has caught bugs in the past.</source>
          <target state="translated">그러나 80 % 솔루션으로 과거에는 버그를 발견 했으므로 여전히 효과적입니다.</target>
        </trans-unit>
        <trans-unit id="dc3b493b7bf70efb7fa8d258ead45b41c49f7ae9" translate="yes" xml:space="preserve">
          <source>However, because there are</source>
          <target state="translated">그러나 있기 때문에</target>
        </trans-unit>
        <trans-unit id="fd72d7b069cc72d81b73b3f8597e881a55bd64a6" translate="yes" xml:space="preserve">
          <source>However, calling any &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; methods in such an &lt;code&gt;END&lt;/code&gt; block will most likely</source>
          <target state="translated">그러나 이러한 &lt;code&gt;END&lt;/code&gt; 블록 에서 &lt;a href=&quot;threads&quot;&gt;스레드&lt;/a&gt; 메소드를 호출 하면 대부분</target>
        </trans-unit>
        <trans-unit id="c314b40d0f00ce73038bbcc98e7f0ca7b1457690" translate="yes" xml:space="preserve">
          <source>However, for the following, the items are already shared, so their references are added directly to the queue, and no cloning takes place:</source>
          <target state="translated">그러나 다음의 경우 항목이 이미 공유되므로 해당 참조가 큐에 직접 추가되며 복제가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bdc1303f64a141ea4136f512c4911ecba9b92d10" translate="yes" xml:space="preserve">
          <source>However, for the one-off simple case where I don't want to pull out a full templating system, I'll use a string that has two Perl scalar variables in it. In this example, I want to expand &lt;code&gt;$foo&lt;/code&gt; and &lt;code&gt;$bar&lt;/code&gt; to their variable's values:</source>
          <target state="translated">그러나 전체 템플릿 시스템을 꺼내고 싶지 않은 일회성 간단한 경우에는 두 개의 Perl 스칼라 변수가있는 문자열을 사용합니다. 이 예에서는 &lt;code&gt;$foo&lt;/code&gt; 및 &lt;code&gt;$bar&lt;/code&gt; 를 변수 값 으로 확장하려고 합니다.</target>
        </trans-unit>
        <trans-unit id="5ff029079aabc6f922c78c4701467310a318c5e3" translate="yes" xml:space="preserve">
          <source>However, if a Perl script begins with the Unicode &lt;code&gt;BOM&lt;/code&gt; (UTF-16LE, UTF16-BE, or UTF-8), or if the script looks like non-&lt;code&gt;BOM&lt;/code&gt; -marked UTF-16 of either endianness, Perl will correctly read in the script as the appropriate Unicode encoding. (&lt;code&gt;BOM&lt;/code&gt; -less UTF-8 cannot be effectively recognized or differentiated from ISO 8859-1 or other eight-bit encodings.)</source>
          <target state="translated">그러나 Perl 스크립트가 유니 코드 &lt;code&gt;BOM&lt;/code&gt; (UTF-16LE, UTF16-BE 또는 UTF-8)으로 시작하거나 스크립트가 비 엔디안의 &lt;code&gt;BOM&lt;/code&gt; 이 아닌 UTF-16으로 표시되면 Perl은 적절한 유니 코드 인코딩으로 스크립트를 작성하십시오. ( &lt;code&gt;BOM&lt;/code&gt; - 덜 UTF-8을 효과적으로 인식 또는 ISO 8859-1 또는 다른 8 비트 인코딩을 구별 할 수 없다.)</target>
        </trans-unit>
        <trans-unit id="7a530119f7016cecda2473b0ac614ce58e818515" translate="yes" xml:space="preserve">
          <source>However, if a particular species of quote character is included in the delimiter specification, then that type of quote will be correctly handled. for example, if &lt;code&gt;$text&lt;/code&gt; is:</source>
          <target state="translated">그러나 특정 종의 인용 문자가 구분 기호 스펙에 포함되어 있으면 해당 인용 유형이 올바르게 처리됩니다. 예를 들어 &lt;code&gt;$text&lt;/code&gt; 가 다음 과 같은 경우 :</target>
        </trans-unit>
        <trans-unit id="9e2ebae72b3d33fdf44dedb85d641ca00f3f57a1" translate="yes" xml:space="preserve">
          <source>However, if all you want to do is change your time zone, you can probably get away with setting an environment variable:</source>
          <target state="translated">그러나 시간대를 변경하기 만하면 환경 변수를 설정하여 벗어날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e12d8527d56fa8ab8e8667f75a93e6392109725d" translate="yes" xml:space="preserve">
          <source>However, if hitting EOF is an expected and normal event, you do not want to exit simply because you have run out of input. Instead, you probably just want to exit an input loop. You can then test to see if an actual error has caused the loop to terminate, and act accordingly:</source>
          <target state="translated">그러나 EOF 적중이 예상되는 정상적인 이벤트 인 경우 입력이 부족하여 종료하지 않으려 고합니다. 대신 입력 루프를 종료하고 싶을 것입니다. 그런 다음 실제 오류로 인해 루프가 종료되었는지 확인하고 그에 따라 조치를 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29e1fafc250caebd597211caeac2164bfd06193d" translate="yes" xml:space="preserve">
          <source>However, if the &lt;code&gt;]&lt;/code&gt; is the</source>
          <target state="translated">그러나 &lt;code&gt;]&lt;/code&gt; 가</target>
        </trans-unit>
        <trans-unit id="8b420ee9db4dd8d8741d24e9570ff42a7cdea42c" translate="yes" xml:space="preserve">
          <source>However, if the command contained arguments that contained whitespace, stringifying the command would lose the significance of the whitespace. Therefore, &lt;code&gt;IPC::Cmd&lt;/code&gt; will quote any arguments containing whitespace in your command if the command is passed as an arrayref and contains special characters.</source>
          <target state="translated">그러나 명령에 공백이 포함 된 인수가 포함 된 경우 명령을 문자열 화하면 공백의 중요성이 없어집니다. 따라서 명령이 arrayref로 전달되고 특수 문자가 포함 된 경우 &lt;code&gt;IPC::Cmd&lt;/code&gt; 는 명령에 공백을 포함하는 인수를 인용합니다.</target>
        </trans-unit>
        <trans-unit id="6cc1c4bf7e539678ba51b5fda046a8f31ec28dde" translate="yes" xml:space="preserve">
          <source>However, if the data can't be parsed as valid Perl, then it is passed as an uninterpreted string. For example:</source>
          <target state="translated">그러나 데이터를 유효한 Perl로 구문 분석 할 수 없으면 해석되지 않은 문자열로 전달됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="713c4744650ad1f6870512c16d626634ea8370be" translate="yes" xml:space="preserve">
          <source>However, if the input text was passed in a variable, that variable's &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; value is updated to point at the first character after the extracted text. That means that in a list context the various subroutines can be used much like regular expressions. For example:</source>
          <target state="translated">그러나 입력 텍스트가 변수로 전달 된 경우 해당 변수의 &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 값이 추출 된 텍스트 다음의 첫 문자를 가리 키도록 업데이트됩니다. 이는리스트 컨텍스트에서 다양한 서브 루틴이 정규 표현식과 매우 유사하게 사용될 수 있음을 의미합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="755d5a289c3e42c14904a4a718307f0b6e480799" translate="yes" xml:space="preserve">
          <source>However, if the kernel set-id script feature isn't disabled, Perl will complain loudly that your set-id script is insecure. You'll need to either disable the kernel set-id script feature, or put a C wrapper around the script. A C wrapper is just a compiled program that does nothing except call your Perl program. Compiled programs are not subject to the kernel bug that plagues set-id scripts. Here's a simple wrapper, written in C:</source>
          <target state="translated">그러나 커널 set-id 스크립트 기능이 비활성화되어 있지 않으면 Perl은 set-id 스크립트가 안전하지 않다고 크게 불평합니다. 커널 set-id 스크립트 기능을 비활성화하거나 스크립트 주위에 C 래퍼를 배치해야합니다. AC 래퍼는 Perl 프로그램을 호출하는 것 외에는 아무것도하지 않는 컴파일 된 프로그램입니다. 컴파일 된 프로그램은 set-id 스크립트를 괴롭히는 커널 버그의 영향을받지 않습니다. 다음은 C로 작성된 간단한 래퍼입니다.</target>
        </trans-unit>
        <trans-unit id="cbc9ddee054ab9351fcec45d24db4192d4d2775c" translate="yes" xml:space="preserve">
          <source>However, if the list element is itself a variable, it appears that you can change a list element. However, the list element is the variable, not the data. You're not changing the list element, but something the list element refers to. The list element itself doesn't change: it's still the same variable.</source>
          <target state="translated">그러나 목록 요소 자체가 변수 인 경우 목록 요소를 변경할 수있는 것으로 나타납니다. 그러나 list 요소는 데이터가 아니라 변수입니다. 목록 요소를 변경하지 않고 목록 요소가 참조하는 것입니다. 목록 요소 자체는 변경되지 않습니다. 여전히 동일한 변수입니다.</target>
        </trans-unit>
        <trans-unit id="1ff33c873357001776962a640d53584ca4867e68" translate="yes" xml:space="preserve">
          <source>However, if the string value associated with &amp;lt;reject&amp;gt; is &quot;MAX&quot;, then &lt;code&gt;extract_tagged&lt;/code&gt; returns the complete text up to the point of failure. If the string is &quot;PARA&quot;, &lt;code&gt;extract_tagged&lt;/code&gt; returns only the first paragraph after the tag (up to the first line that is either empty or contains only whitespace characters). If the string is &quot;&quot;, the the default behaviour (i.e. failure) is reinstated.</source>
          <target state="translated">그러나 &amp;lt;reject&amp;gt;와 연관된 문자열 값이 &quot;MAX&quot;인 경우 &lt;code&gt;extract_tagged&lt;/code&gt; 는 전체 텍스트를 실패 지점까지 리턴합니다. 문자열이 &quot;PARA&quot;인 경우 &lt;code&gt;extract_tagged&lt;/code&gt; 는 태그 다음의 첫 번째 단락 (공백이거나 공백 문자 만 포함하는 첫 번째 줄까지) 만 반환합니다. 문자열이 &quot;&quot;이면 기본 동작 (예 : 실패)이 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="a40e24fb0252cc9815324344313381a888c122c8" translate="yes" xml:space="preserve">
          <source>However, if there is no matching &lt;code&gt;}&lt;/code&gt;, Perl doesn't know if it was mistakenly omitted, or if &lt;code&gt;[^\n]{&lt;/code&gt; was desired, and raises this error. If you meant the former, add the right brace; if you meant the latter, escape the brace with a backslash, like so: &lt;code&gt;\N\{&lt;/code&gt;</source>
          <target state="translated">그러나 일치하는 &lt;code&gt;}&lt;/code&gt; 이 없으면 Perl은 실수로 생략되었는지 또는 &lt;code&gt;[^\n]{&lt;/code&gt; 을 (를) 원하는지 알 수 없으므로이 오류가 발생합니다. 전자를 의미한다면 올바른 버팀대를 추가하십시오. 후자를 의미하는 경우 다음과 같이 백 슬래시로 중괄호를 이스케이프하십시오. &lt;code&gt;\N\{&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4db7ce89f0ac0ff04237db2ffe65056106401da4" translate="yes" xml:space="preserve">
          <source>However, if you have fixed sized records, then you might do something more like this:</source>
          <target state="translated">그러나 고정 된 레코드 크기를 가진 경우 다음과 같은 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0a31e0971a11a0c1d822f02efd0eb4f79c74f3a" translate="yes" xml:space="preserve">
          <source>However, if you set &quot;_AUTO =&amp;gt; 1&quot; in the %Lexicon in, ThisProject/I18N/en.pm (assuming that English (en) is the language that all your programmers will be using for this project's internal message keys), then you don't ever have to go adding lines like this</source>
          <target state="translated">그러나 % Lexicon in, ThisProject / I18N / en.pm에서 &quot;_AUTO =&amp;gt; 1&quot;을 설정하면 (영어 (en)는 모든 프로그래머가이 프로젝트의 내부 메시지 키에 사용하는 언어라고 가정) 이런 식으로 줄을 추가하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="a09363cd76b1dde7e3a57d25fdf3272ced3af2ab" translate="yes" xml:space="preserve">
          <source>However, if you want the old behavior (and think carefully about that because it's a weird side effect), you can pass a hash slice instead. Perl 5.004 didn't make this a special case:</source>
          <target state="translated">그러나 이전 동작을 원한다면 (그리고 이상한 부작용이기 때문에 신중하게 생각하면) 대신 해시 슬라이스를 전달할 수 있습니다. Perl 5.004는 이것을 특별한 경우로 만들지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="c9bcfc80dafa07d27c313feb7344f54609aa72b0" translate="yes" xml:space="preserve">
          <source>However, if you're not using git, you can still produce a suitable patch. You'll need a pristine copy of the Perl source to diff against. The porters prefer unified diffs. Using GNU &lt;code&gt;diff&lt;/code&gt; , you can produce a diff like this:</source>
          <target state="translated">그러나 git을 사용하지 않는 경우에도 여전히 적절한 패치를 생성 할 수 있습니다. 비교해 보려면 펄 소스의 깨끗한 사본이 필요합니다. 포터들은 통일 된 차이를 선호합니다. GNU &lt;code&gt;diff&lt;/code&gt; 를 사용 하면 다음과 같은 diff를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="912422cfe6349f661271a697889a1ce04bbb7530" translate="yes" xml:space="preserve">
          <source>However, in list context, the line input operator returns all of the lines as a list. The first line goes into &lt;code&gt;@array[1]&lt;/code&gt; and the rest of the lines mysteriously disappear:</source>
          <target state="translated">그러나 목록 컨텍스트에서 행 입력 연산자는 모든 행을 목록으로 리턴합니다. 첫 번째 줄은 &lt;code&gt;@array[1]&lt;/code&gt; 로 들어가고 나머지 줄은 신비롭게 사라집니다.</target>
        </trans-unit>
        <trans-unit id="a4cbc737f6445190a51915b10ef52747baeb38d6" translate="yes" xml:space="preserve">
          <source>However, in the case you are using &lt;code&gt;LANGUAGE&lt;/code&gt; : it affects the language of informational, warning, and error messages output by commands (in other words, it's like &lt;code&gt;LC_MESSAGES&lt;/code&gt; ) but it has higher priority than &lt;code&gt;LC_ALL&lt;/code&gt; . Moreover, it's not a single value but instead a &quot;path&quot; (&quot;:&quot;-separated list) of</source>
          <target state="translated">그러나 &lt;code&gt;LANGUAGE&lt;/code&gt; 를 사용하는 경우 명령에 의해 출력되는 정보, 경고 및 오류 메시지의 언어 (즉, &lt;code&gt;LC_MESSAGES&lt;/code&gt; 와 유사 함 )에 영향을 주지만 &lt;code&gt;LC_ALL&lt;/code&gt; 보다 우선 순위가 높습니다 . 또한 단일 값이 아니라 &quot;경로&quot;( &quot;:&quot;로 구분 된 목록)입니다.</target>
        </trans-unit>
        <trans-unit id="fdfb88ca6aeb7caca106e8a86ebad4a7bd611554" translate="yes" xml:space="preserve">
          <source>However, it does mean that functions like &lt;code&gt;is_deeply()&lt;/code&gt; cannot be used to test the internals of string overloaded objects. In this case I would suggest &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Deep&quot;&gt;Test::Deep&lt;/a&gt; which contains more flexible testing functions for complex data structures.</source>
          <target state="translated">그러나 &lt;code&gt;is_deeply()&lt;/code&gt; 와 같은 함수를 사용하여 문자열 오버로드 된 객체의 내부를 테스트 할 수는 없습니다. 이 경우 복잡한 데이터 구조에 대해 더 유연한 테스트 기능을 포함 하는 &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Deep&quot;&gt;Test :: Deep&lt;/a&gt; 을 제안 합니다.</target>
        </trans-unit>
        <trans-unit id="4b56d396ba6f1980056b816ee33f44e386574d54" translate="yes" xml:space="preserve">
          <source>However, it is important to remember that Perl threads cannot magically do things unless your operating system's threads allow it. So if your system blocks the entire process on &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep()&lt;/a&gt;&lt;/code&gt;, Perl usually will, as well.</source>
          <target state="translated">그러나 Perl 스레드는 운영 체제의 스레드가 허용하지 않는 한 마술처럼 작업을 수행 할 수 없다는 것을 기억해야합니다. 따라서 시스템이 &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep()&lt;/a&gt;&lt;/code&gt; 에서 전체 프로세스를 차단하면 일반적으로 Perl도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="9d9bc751c2a736800a6ded071584d5744291603c" translate="yes" xml:space="preserve">
          <source>However, it is possible to set up attribute handlers that are called at other points in the program's compilation or execution, by explicitly stating the phase (or phases) in which you wish the attribute handler to be called. For example:</source>
          <target state="translated">그러나 속성 핸들러를 호출 할 단계를 명시 적으로 지정하여 프로그램 컴파일 또는 실행의 다른 지점에서 호출되는 속성 핸들러를 설정할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="495f4657c76d2b9516ad67652bc58b23f23940a2" translate="yes" xml:space="preserve">
          <source>However, it would be unwise to write tests such as:</source>
          <target state="translated">그러나 다음과 같은 테스트를 작성하는 것은 현명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b30399fa602102d2334ab528f7c1b9ececea8d0d" translate="yes" xml:space="preserve">
          <source>However, it's impossible to &lt;b&gt;perform&lt;/b&gt; the operations in this order: you have to find the values of &lt;code&gt;$b&lt;/code&gt; and &lt;code&gt;$c&lt;/code&gt; before you add them together, for instance. So, the other thread that runs through the op tree is the execution order: each op has a field &lt;code&gt;op_next&lt;/code&gt; which points to the next op to be run, so following these pointers tells us how perl executes the code. We can traverse the tree in this order using the &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; option to &lt;code&gt;B::Terse&lt;/code&gt; :</source>
          <target state="translated">그러나이 순서대로 작업 을 &lt;b&gt;수행&lt;/b&gt; 하는 것은 불가능 합니다. 예를 들어 &lt;code&gt;$b&lt;/code&gt; 와 &lt;code&gt;$c&lt;/code&gt; 를 함께 추가하기 전에 값을 찾아야합니다 . 따라서 op 트리를 통해 실행되는 다른 스레드는 실행 순서입니다. 각 op에는 다음 op가 실행될 &lt;code&gt;op_next&lt;/code&gt; 필드가 있으므로이 포인터를 따르면 perl이 코드를 실행하는 방법을 알 수 있습니다. &lt;code&gt;B::Terse&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 옵션을 사용하여이 순서대로 트리를 순회 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a3fd83f97cb972df229bb4d55a4c188b477d626" translate="yes" xml:space="preserve">
          <source>However, long experience has shown that many programming tasks may be significantly simplified by using repeated subexpressions that may match zero-length substrings. Here's a simple example being:</source>
          <target state="translated">그러나 오랜 경험에 따르면 길이가 0 인 하위 문자열과 일치 할 수있는 반복 된 하위 표현식을 사용하면 많은 프로그래밍 작업이 크게 단순화 될 수 있습니다. 다음은 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="ccc9947a9b58d2f4b1cd78cbf550721e43e5ecea" translate="yes" xml:space="preserve">
          <source>However, note that &lt;code&gt;sv_unmagic&lt;/code&gt; removes all magic of a certain &lt;code&gt;type&lt;/code&gt; from the &lt;code&gt;SV&lt;/code&gt; . If you want to remove only certain magic of a &lt;code&gt;type&lt;/code&gt; based on the magic virtual table, use &lt;code&gt;sv_unmagicext&lt;/code&gt; instead:</source>
          <target state="translated">그러나 &lt;code&gt;sv_unmagic&lt;/code&gt; 은 &lt;code&gt;SV&lt;/code&gt; 에서 특정 &lt;code&gt;type&lt;/code&gt; 의 모든 마술을 제거합니다 . 매직 가상 테이블을 기반으로 특정 &lt;code&gt;type&lt;/code&gt; 매직 만 제거 하려면 대신 &lt;code&gt;sv_unmagicext&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3714710035618507b561178df5f82b541c8974c8" translate="yes" xml:space="preserve">
          <source>However, note that even as the specified layers are &quot;pushed on top&quot; for open() and binmode(), this doesn't mean that the effects are limited to the &quot;top&quot;: PerlIO layers can be very 'active' and inspect and affect layers also deeper in the stack. As an example there is a layer called &quot;raw&quot; which repeatedly &quot;pops&quot; layers until it reaches the first layer that has declared itself capable of handling binary data. The &quot;pushed&quot; layers are processed in left-to-right order.</source>
          <target state="translated">그러나 지정된 레이어가 open () 및 binmode ()에 대해 &quot;맨 위로 푸시&quot;되더라도 효과가 &quot;맨 위&quot;로 제한되는 것은 아닙니다. PerlIO 레이어는 매우 '활성'일 수 있습니다. 스택에서 더 깊이있는 레이어에 영향을줍니다. 예를 들어 이진 데이터를 처리 할 수 ​​있다고 선언 한 첫 번째 레이어에 도달 할 때까지 레이어를 반복적으로 &quot;팝핑&quot;하는 &quot;raw&quot;라는 레이어가 있습니다. &quot;푸시 된&quot;레이어는 왼쪽에서 오른쪽 순서로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="237e671ead4e4f448bac6dfef4927434cec18095" translate="yes" xml:space="preserve">
          <source>However, on earlier Perls, or if you pass strings to subroutines outside the feature's scope, you can force Unicode rules by changing the encoding to UTF-8 by doing &lt;code&gt;utf8::upgrade($string)&lt;/code&gt; . This can be used safely on any string, as it checks and does not change strings that have already been upgraded.</source>
          <target state="translated">그러나 이전 Perls에서 또는 기능 범위 밖의 서브 루틴에 문자열을 전달하는 경우 &lt;code&gt;utf8::upgrade($string)&lt;/code&gt; 을 수행하여 인코딩을 UTF-8로 변경하여 유니 코드 규칙을 강제 실행할 수 있습니다 . 이미 업그레이드 된 문자열을 확인하고 변경하지 않으므로 모든 문자열에서 안전하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d790ef4b7b652054f8ef9f08eabcfceb4c9c9d7" translate="yes" xml:space="preserve">
          <source>However, only double quotes &quot;interpolate&quot; variables and special characters such as newlines (&lt;code&gt;\n&lt;/code&gt; ):</source>
          <target state="translated">그러나 큰 따옴표 만 &quot;보간&quot;변수와 개행 ( &lt;code&gt;\n&lt;/code&gt; ) 과 같은 특수 문자를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="5f40951889d3378b60336de3c7c19a48f84efe15" translate="yes" xml:space="preserve">
          <source>However, over the years, changes in gcc, GNU ld, and Solaris ld have made it difficult to automatically detect which ld ultimately gets called. You may have to manually edit config.sh and add the -Wl,-E flags yourself, or else run Configure interactively and add the flags at the appropriate prompts.</source>
          <target state="translated">그러나 수년 동안 gcc, GNU ld 및 Solaris ld의 변경으로 인해 어떤 ld가 궁극적으로 호출되는지 자동으로 감지하기가 어려워졌습니다. config.sh를 수동으로 편집하고 -Wl, -E 플래그를 직접 추가하거나 대화식으로 구성을 실행하고 적절한 프롬프트에서 플래그를 추가해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7abae8990eb0eaeb22dbcaa2121181a9c3213635" translate="yes" xml:space="preserve">
          <source>However, since I am running a very recent Hurd snapshot, in which a lot of bugs that were exposed by the Perl test suite have been fixed, you may encounter more failures. Likely candidates are: &quot;op/stat&quot;, &quot;lib/io_pipe&quot;, &quot;lib/io_sock&quot;, &quot;lib/io_udp&quot; and &quot;lib/time&quot;.</source>
          <target state="translated">그러나 Perl 테스트 스위트에 의해 노출 된 많은 버그가 수정 된 최신 Hurd 스냅 샷을 실행 중이므로 더 많은 오류가 발생할 수 있습니다. 후보는 &quot;op / stat&quot;, &quot;lib / io_pipe&quot;, &quot;lib / io_sock&quot;, &quot;lib / io_udp&quot;및 &quot;lib / time&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="0a2932991138cff6cda965e1aa59120419d51793" translate="yes" xml:space="preserve">
          <source>However, since prototype checking happens at compile time, the assignment above happens too late to be of much use. You could address this by putting the whole loop of assignments within a BEGIN block, forcing it to occur during compilation.</source>
          <target state="translated">그러나 프로토 타입 검사는 컴파일 타임에 수행되므로 위의 과제는 너무 늦어서 많이 사용되지 않습니다. BEGIN 블록 내에 전체 할당 루프를 배치하여 컴파일 중에 발생하도록하여이 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5dc0373ab5a69dc9065fd1361f3fe68378bd857" translate="yes" xml:space="preserve">
          <source>However, some people find that code harder to read than writing it with parentheses:</source>
          <target state="translated">그러나 일부 사람들은 괄호로 코드를 작성하는 것보다 코드를 읽기가 어렵다는 것을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="e33f317ee43849ba21e4562b2cfcaf42b63f23a8" translate="yes" xml:space="preserve">
          <source>However, that doesn't work if the line ending isn't a newline. You might change that &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; so you can count the number of times the input record separator, &lt;code&gt;$/&lt;/code&gt; , shows up:</source>
          <target state="translated">그러나 줄 끝이 줄 바꿈이 아닌 경우 작동하지 않습니다. 해당 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; /// 로 변경 하여 입력 레코드 구분 기호 &lt;code&gt;$/&lt;/code&gt; 가 표시 되는 횟수를 계산할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ff8d86d9a6fdf31c1cce87bc99b477e123d4270e" translate="yes" xml:space="preserve">
          <source>However, the &lt;b&gt;.ph&lt;/b&gt; files almost double in size when built using &lt;b&gt;-h&lt;/b&gt;.</source>
          <target state="translated">그러나 &lt;b&gt;-h를&lt;/b&gt; 사용하여 빌드 하면 &lt;b&gt;.ph&lt;/b&gt; 파일의 크기가 거의 두 배가됩니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="dbf1c5152a0ddfa7cc0b45d1130d02f94e11246a" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;W&lt;/code&gt; specifier does operate on whole characters, as does the &lt;code&gt;U&lt;/code&gt; specifier.</source>
          <target state="translated">그러나 &lt;code&gt;W&lt;/code&gt; 지정자는 &lt;code&gt;U&lt;/code&gt; 지정자 와 마찬가지로 전체 문자에서 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="3da026c415acace03626d9fb7e1ee90aa243fe42" translate="yes" xml:space="preserve">
          <source>However, the above usage will create global variables throughout your program, which is bad programming practice. &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; creates lexically scoped variables instead. The variables are scoped to the block (i.e. a bunch of statements surrounded by curly-braces) in which they are defined.</source>
          <target state="translated">그러나 위의 사용법은 프로그램 전체에 전역 변수를 생성하므로 프로그래밍이 잘못됩니다. &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 사 전적으로 대신 변수를 범위 작성합니다. 변수는 블록이 정의 된 블록 (즉, 중괄호로 묶은 여러 문장)으로 범위가 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="643bcb3d157afa153f651f6fc7ccfed78f3e704a" translate="yes" xml:space="preserve">
          <source>However, the call in:</source>
          <target state="translated">그러나 전화 :</target>
        </trans-unit>
        <trans-unit id="30ecfcc25810d7a7cdf5b6a2a73a83af471c9442" translate="yes" xml:space="preserve">
          <source>However, the generated Perl function is called in very C-ish style:</source>
          <target state="translated">그러나 생성 된 Perl 함수는 매우 C-ish 스타일로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="be1c834c7d4d71f52243b42559f80aabe198a844" translate="yes" xml:space="preserve">
          <source>However, the matching position of the input variable would be set to &quot;exit;&quot; (i.e.</source>
          <target state="translated">그러나 입력 변수의 일치 위치는 &quot;exit;&quot;로 설정됩니다. (즉</target>
        </trans-unit>
        <trans-unit id="d95f0313fce5fa0d84ae8a729df3c8f4e82e2159" translate="yes" xml:space="preserve">
          <source>However, the result of such a slice cannot be localized, deleted or used in assignment. These are otherwise very much consistent with hash slices using the @ symbol.</source>
          <target state="translated">그러나 이러한 슬라이스의 결과는 지역화, 삭제 또는 할당에 사용할 수 없습니다. 그렇지 않으면 @ 기호를 사용하는 해시 슬라이스와 매우 일치합니다.</target>
        </trans-unit>
        <trans-unit id="c017b28f94bbc1527d3a99433c0d70601c0484be" translate="yes" xml:space="preserve">
          <source>However, the shortcut requires that you specify exactly two command-line arguments, &lt;code&gt;indirs&lt;/code&gt; and &lt;code&gt;outdir&lt;/code&gt; .</source>
          <target state="translated">그러나 바로 가기에는 정확히 두 개의 명령 줄 인수 인 &lt;code&gt;indirs&lt;/code&gt; 및 &lt;code&gt;outdir&lt;/code&gt; 을 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="174d3b644e004445441e24cae4b9fd65f9fed124" translate="yes" xml:space="preserve">
          <source>However, their are many, many other differences. For example, this works in Perl 5:</source>
          <target state="translated">그러나 그것들은 많은 다른 많은 차이점입니다. 예를 들어, 이것은 Perl 5에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="431ca5f68339a06fd3a547e35432cecf8dddda74" translate="yes" xml:space="preserve">
          <source>However, there are places where this breaks down. Certain Perl constructs are for Unicode only, such as &lt;code&gt;\p{Alpha}&lt;/code&gt; . They assume that 0xD7 always has its Unicode meaning (or the equivalent on EBCDIC platforms). Since Latin1 is a subset of Unicode and 0xD7 is the multiplication sign in both Latin1 and Unicode, &lt;code&gt;\p{Alpha}&lt;/code&gt; will never match it, regardless of locale. A similar issue occurs with &lt;code&gt;\N{...}&lt;/code&gt; . Prior to v5.20, It is therefore a bad idea to use &lt;code&gt;\p{}&lt;/code&gt; or &lt;code&gt;\N{}&lt;/code&gt; under plain &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; --</source>
          <target state="translated">그러나 이것이 고장난 곳이 있습니다. 특정 Perl 구성은 &lt;code&gt;\p{Alpha}&lt;/code&gt; 와 같은 유니 코드 전용 입니다. 그들은 0xD7이 항상 유니 코드 의미 (또는 EBCDIC 플랫폼에서 동등한 의미)를 가지고 있다고 가정합니다. Latin1은 유니 코드의 하위 집합이고 0xD7은 Latin1과 유니 코드의 곱셈 부호이므로 &lt;code&gt;\p{Alpha}&lt;/code&gt; 는 로캘에 관계없이 일치하지 않습니다. &lt;code&gt;\N{...}&lt;/code&gt; 에서도 비슷한 문제가 발생합니다 . 이전 v5.20에 따라서 사용하는 나쁜 생각 &lt;code&gt;\p{}&lt;/code&gt; 또는 &lt;code&gt;\N{}&lt;/code&gt; 일반에서 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; -</target>
        </trans-unit>
        <trans-unit id="79a79d341666f9d08432041587a457666ea4e643" translate="yes" xml:space="preserve">
          <source>However, there is a third way: perl DLL exports the main() function and several callbacks to customize the search path. Below is a complete example of a &quot;Perl loader&quot; which</source>
          <target state="translated">그러나 세 번째 방법이 있습니다. perl DLL은 main () 함수와 여러 콜백을 내보내 검색 경로를 사용자 정의합니다. 아래는 &quot;펄 로더&quot;의 완전한 예입니다.</target>
        </trans-unit>
        <trans-unit id="167fa8624f523d65d674923630d20eace6f440ad" translate="yes" xml:space="preserve">
          <source>However, there is one other function which manipulates the reference count of its argument. The &lt;code&gt;newRV_inc&lt;/code&gt; function, you will recall, creates a reference to the specified argument. As a side effect, it increments the argument's reference count. If this is not what you want, use &lt;code&gt;newRV_noinc&lt;/code&gt; instead.</source>
          <target state="translated">그러나 인수의 참조 횟수를 조작하는 다른 함수가 있습니다. &lt;code&gt;newRV_inc&lt;/code&gt; 의 기능은, 당신을 기억합니다, 지정된 인수에 대한 참조를 만듭니다. 부작용으로 인수의 참조 횟수가 증가합니다. 이것이 원하는 것이 &lt;code&gt;newRV_noinc&lt;/code&gt; 대신 newRV_noinc를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="78acaa936efa9d2893b28f11a288123a0f9298ff" translate="yes" xml:space="preserve">
          <source>However, these two XSUBs provide almost identical generated C code: &lt;b&gt;xsubpp&lt;/b&gt; compiler is smart enough to figure out the &lt;code&gt;CODE:&lt;/code&gt; section from the first two lines of the description of XSUB. What about &lt;code&gt;OUTPUT:&lt;/code&gt; section? In fact, that is absolutely the same! The &lt;code&gt;OUTPUT:&lt;/code&gt; section can be removed as well,</source>
          <target state="translated">그러나이 두 XSUB는 거의 동일하게 생성 된 C 코드를 제공합니다. &lt;b&gt;xsubpp&lt;/b&gt; 컴파일러는 XSUB 설명의 처음 두 줄에서 &lt;code&gt;CODE:&lt;/code&gt; 섹션 을 알아낼 수있을 정도로 똑똑 합니다. 무엇에 대한 &lt;code&gt;OUTPUT:&lt;/code&gt; 섹션? 사실, 그것은 완전히 같습니다! &lt;code&gt;OUTPUT:&lt;/code&gt; 섹션도 제거 할 수있다</target>
        </trans-unit>
        <trans-unit id="8993e8546f1a446361af9208f62149f37c72c7da" translate="yes" xml:space="preserve">
          <source>However, this approach is limited to the first arguments following &quot;root&quot; (again, see &lt;code&gt;Unix-&amp;gt;canonpath()&lt;/code&gt; ). If there are more arguments that move up the directory tree, an invalid path going beyond root can be created.</source>
          <target state="translated">그러나이 방법은 &quot;root&quot;다음에 오는 첫 번째 인수로 제한됩니다 (다시 &lt;code&gt;Unix-&amp;gt;canonpath()&lt;/code&gt; ). 디렉토리 트리를 위로 이동하는 인수가 더 있으면 루트를 넘어서는 잘못된 경로를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a498e0a44f0f9f8fbe6e40968d0b21c8d56b2479" translate="yes" xml:space="preserve">
          <source>However, this request is ignored, as the current code now uses the low-level math library for directly storing the number parts.</source>
          <target state="translated">그러나 현재 코드는 숫자 부분을 직접 저장하기 위해 저수준 수학 라이브러리를 사용하므로이 요청은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="1c442891dca9145a3b9c79c668f4b9ec23f39a60" translate="yes" xml:space="preserve">
          <source>However, this still does not guarantee that these DLL may be loaded. The reason is the mangling of the name of the</source>
          <target state="translated">그러나 그래도이 DLL이로드 될 수 있음을 보증하지는 않습니다. 그 이유는</target>
        </trans-unit>
        <trans-unit id="2084b9ad89039a2ea6c4200ac2905bee170c22b7" translate="yes" xml:space="preserve">
          <source>However, to help ease understanding, it is suggested that you place a &quot;&amp;amp;&quot; next to the variable name and away from the variable type), and place a &quot;*&quot; near the variable type, but away from the variable name (as in the call to foo above). By doing so, it is easy to understand exactly what will be passed to the C function; it will be whatever is in the &quot;last column&quot;.</source>
          <target state="translated">그러나 이해하기 쉽도록 변수 이름 옆에 &quot;&amp;amp;&quot;를 배치하고 변수 유형에서 멀리 떨어 뜨리고 변수 유형 근처에 &quot;*&quot;를 배치하지만 위의 foo에 대한 호출). 그렇게하면 C 함수에 전달 될 내용을 정확하게 이해하기가 쉽습니다. &quot;마지막 열&quot;에있는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ae3f94bdf7ac1269b60e51c2ce0911730992c14a" translate="yes" xml:space="preserve">
          <source>However, under some circumstances, this behavior may be excessively slow. For example, suppose you have a million-record file, and you want to do:</source>
          <target state="translated">그러나 일부 상황에서는이 동작이 너무 느려질 수 있습니다. 예를 들어, 백만 레코드 파일이 있고 다음을 수행하려고한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="37cab8dafbfef6134cbae52136465a602af12595" translate="yes" xml:space="preserve">
          <source>However, unless you tell &lt;code&gt;Memoize&lt;/code&gt; that these calls are equivalent, it will not know that, and it will compute the values for these invocations of your function separately, and store them separately.</source>
          <target state="translated">그러나 이러한 호출이 동등하다는 것을 &lt;code&gt;Memoize&lt;/code&gt; 에 알리지 않으면이를 알 수 없으며 함수의 이러한 호출에 대한 값을 별도로 계산하여 별도로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="142779c491fb94a0d076da32b3296ae6b26999c0" translate="yes" xml:space="preserve">
          <source>However, up through v5.20, Perl initialized things on start-up so that &lt;code&gt;LC_NUMERIC&lt;/code&gt; was set to the &quot;C&quot; locale. But if any code anywhere changed it, it would stay changed. This means that your module can't count on &lt;code&gt;LC_NUMERIC&lt;/code&gt; being something in particular, and you can't expect floating point numbers (including version strings) to have dots in them. If you don't allow for a non-dot, your code could break if anyone anywhere changed the locale. For this reason, v5.22 changed the behavior so that Perl tries to keep &lt;code&gt;LC_NUMERIC&lt;/code&gt; in the &quot;C&quot; locale except around the operations internally where it should be something else. Misbehaving XS code will always be able to change the locale anyway, but the most common instance of this is checked for and handled.</source>
          <target state="translated">그러나 v5.20까지 Perl은 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 이 &quot;C&quot;로케일로 설정 되도록 시작시 항목을 초기화했습니다 . 그러나 코드가 어디에서나 변경되면 변경 상태를 유지합니다. 이것은 모듈이 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 을 특별히 고려할 수 없으며 부동 소수점 숫자 (버전 문자열 포함)에 점이있을 것으로 기대할 수 없음을 의미합니다. 점이 아닌 것을 허용하지 않으면, 누군가가 로케일을 변경하면 코드가 깨질 수 있습니다. 이러한 이유로 v5.22는 Perl이 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 을 &quot;C&quot;로케일 로 유지하도록 동작을 변경하여 내부적으로 다른 곳이 아닌 조작을 제외하고는 &quot;C&quot;로케일 을 유지 합니다. XS 코드가 잘못 작동하면 항상 로케일을 변경할 수 있지만 가장 일반적인 인스턴스가 확인되고 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="068b747d32004750485efe98f8d1cbafa2e0e35a" translate="yes" xml:space="preserve">
          <source>However, using &lt;code&gt;&amp;amp;&lt;/code&gt; in the call still overrides the prototype of &lt;code&gt;foo&lt;/code&gt; if present:</source>
          <target state="translated">그러나 호출에서 &lt;code&gt;&amp;amp;&lt;/code&gt; 를 사용 하면 &lt;code&gt;foo&lt;/code&gt; 의 프로토 타입이있는 경우 여전히 재정의합니다 .</target>
        </trans-unit>
        <trans-unit id="f9fabcfc6b8511bdc0a7ecd34a3e04f701d2b56e" translate="yes" xml:space="preserve">
          <source>However, using &lt;code&gt;\015\012&lt;/code&gt; (or &lt;code&gt;\cM\cJ&lt;/code&gt; , or &lt;code&gt;\x0D\x0A&lt;/code&gt; ) can be tedious and unsightly, as well as confusing to those maintaining the code. As such, the &lt;code&gt;Socket&lt;/code&gt; module supplies the Right Thing for those who want it.</source>
          <target state="translated">그러나 &lt;code&gt;\015\012&lt;/code&gt; (또는 &lt;code&gt;\cM\cJ&lt;/code&gt; 또는 &lt;code&gt;\x0D\x0A&lt;/code&gt; )를 사용하면 코드를 유지 관리하는 사람들과 혼동을 줄뿐만 아니라 지루하고보기 흉하지 않을 수 있습니다. 따라서 &lt;code&gt;Socket&lt;/code&gt; 모듈은 원하는 사람들에게 올바른 것을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="163537b4f5c11cd47e9722700a60c6c7ea0ade4a" translate="yes" xml:space="preserve">
          <source>However, using the code requires that you have a working C compiler and can use it to build and install a CPAN module. Here's a solution using the standard &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module, which is already on your system (assuming your system supports POSIX).</source>
          <target state="translated">그러나 코드를 사용하려면 작동중인 C 컴파일러가 있어야하며이를 사용하여 CPAN 모듈을 빌드하고 설치할 수 있습니다. 다음 은 시스템에 이미 있는 표준 &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; 모듈을 사용하는 솔루션입니다 (시스템이 POSIX를 지원한다고 가정).</target>
        </trans-unit>
        <trans-unit id="a4350da00ad3028f4efc1846f8fc750c07ee286a" translate="yes" xml:space="preserve">
          <source>However, when it's a list-context assignment and you're trying to use &lt;code&gt;||&lt;/code&gt; for control flow, you probably need &lt;code&gt;&quot;or&quot;&lt;/code&gt; so that the assignment takes higher precedence.</source>
          <target state="translated">그러나 목록 컨텍스트 지정이고 &lt;code&gt;||&lt;/code&gt; 제어 흐름의 경우 할당이 더 높은 우선 순위를 갖도록 &lt;code&gt;&quot;or&quot;&lt;/code&gt; 이 필요할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="41f9727ede39a1ce5211e24f06cf1afdd8d7ee83" translate="yes" xml:space="preserve">
          <source>However, you can change the way an object is smartmatched by overloading the &lt;code&gt;~~&lt;/code&gt; operator. This is allowed to extend the usual smartmatch semantics. For objects that do have an &lt;code&gt;~~&lt;/code&gt; overload, see &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt;.</source>
          <target state="translated">그러나 &lt;code&gt;~~&lt;/code&gt; 연산자 를 오버로드하여 객체의 스마트 매칭 방식을 변경할 수 있습니다 . 이는 일반적인 스마트 매치 시맨틱을 확장 할 수 있습니다. 할 객체가 가지고 들어 &lt;code&gt;~~&lt;/code&gt; 과부하를 볼 &lt;a href=&quot;overload&quot;&gt;과부하&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b89d0d284e64c095a60bef4f1dd049a654a9b8f4" translate="yes" xml:space="preserve">
          <source>However, you can suppress the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; by using an explicit, empty import list. Both of these still happen at compile-time:</source>
          <target state="translated">그러나 명시적인 빈 가져 오기 목록을 사용하여 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 를 억제 할 수 있습니다 . 이 두 가지 모두 여전히 컴파일 타임에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2eb959e8b316e23c060bb14a1aa10ea6663e7a66" translate="yes" xml:space="preserve">
          <source>However, you have to be more cautious with namespace and variable scoping when using a persistent interpreter. In previous examples we've been using global variables in the default package &lt;code&gt;main&lt;/code&gt; . We knew exactly what code would be run, and assumed we could avoid variable collisions and outrageous symbol table growth.</source>
          <target state="translated">그러나 영속 인터프리터를 사용할 때는 네임 스페이스와 변수 범위 지정에 더주의해야합니다. 이전 예제에서는 기본 패키지 &lt;code&gt;main&lt;/code&gt; 에서 전역 변수를 사용했습니다 . 우리는 어떤 코드가 실행 될지 정확히 알고 있었고, 변수 충돌과 터무니없는 심볼 테이블 증가를 피할 수 있다고 가정했습니다.</target>
        </trans-unit>
        <trans-unit id="e66a879553ebe7b620fa37901232bfb863aa6d3d" translate="yes" xml:space="preserve">
          <source>However, you may know that you intend to use the results in a particular context, where some pragmas are already in scope. In this case, you use the &lt;b&gt;ambient_pragmas&lt;/b&gt; method to describe the assumptions you wish to make.</source>
          <target state="translated">그러나 일부 pragma가 이미 범위에있는 특정 상황에서 결과를 사용하려고 할 수도 있습니다. 이 경우, &lt;b&gt;ambient_pragmas&lt;/b&gt; 메소드를 사용하여 원하는 가정을 설명하십시오.</target>
        </trans-unit>
        <trans-unit id="56cfa87ada9834b01835bf9c64cf509441054b7b" translate="yes" xml:space="preserve">
          <source>However, you might be out of luck if you expect that means there is a real person on the other side. With the &lt;a href=&quot;http://search.cpan.org/perldoc/Expect&quot;&gt;Expect&lt;/a&gt; module, another program can pretend to be a person. The program might even come close to passing the Turing test.</source>
          <target state="translated">그러나 반대편에 진짜 사람이 있다는 것을 의미한다면 운이 나쁠 수도 있습니다. &lt;a href=&quot;http://search.cpan.org/perldoc/Expect&quot;&gt;Expect&lt;/a&gt; 모듈을 사용하면 다른 프로그램이 사람인 것처럼 가장 할 수 있습니다. 이 프로그램은 튜링 테스트를 통과하는 것에 가깝습니다.</target>
        </trans-unit>
        <trans-unit id="a422dec568026043ae4e005023457a913a05b272" translate="yes" xml:space="preserve">
          <source>However, you must not do this, for example:</source>
          <target state="translated">그러나 다음과 같이이 작업을 수행해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="e3a4e64a25b29be20841a60bc10f2c0bc37e06f9" translate="yes" xml:space="preserve">
          <source>However, you should &lt;b&gt;not&lt;/b&gt; blindly rely on perl always doing the right thing. Particularly, perl will mistakenly return true when you clear the hash by repeatedly calling DELETE until it is empty. You are therefore advised to supply your own SCALAR method when you want to be absolutely sure that your hash behaves nicely in scalar context.</source>
          <target state="translated">그러나 항상 올바른 일을하는 펄에 맹목적으로 의존 해서는 &lt;b&gt;안됩니다&lt;/b&gt; . 특히, 펄은 비어있을 때까지 DELETE를 반복해서 호출하여 해시를 지우면 true를 잘못 반환합니다. 따라서 해시가 스칼라 컨텍스트에서 훌륭하게 작동하도록하려면 자체 SCALAR 방법을 제공하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="59d2100593fec39720245432930b526325693698" translate="yes" xml:space="preserve">
          <source>Hugo van der Sanden &amp;lt;hv@crypt0.demon.co.uk&amp;gt;</source>
          <target state="translated">휴고 반 데르 샌덴 &amp;lt;hv@crypt0.demon.co.uk&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9711a7cfeff071972d36fdd6050e80bc9d749c0b" translate="yes" xml:space="preserve">
          <source>Hyperlinks</source>
          <target state="translated">Hyperlinks</target>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="68ea31ac882843ca3bb7347afdcbec874605911e" translate="yes" xml:space="preserve">
          <source>I almost always use keys that are themselves valid lexicon values. One notable exception is when the value is quite long. For example, to get the screenful of data that a command-line program might return when given an unknown switch, I often just use a brief, self-explanatory key such as &quot;_USAGE_MESSAGE&quot;. At that point I then go and immediately to define that lexicon entry in the ProjectClass::L10N::en lexicon (since English is always my &quot;project language&quot;):</source>
          <target state="translated">나는 거의 항상 유효한 어휘 값인 키를 사용합니다. 주목할만한 예외 중 하나는 값이 매우 길 때입니다. 예를 들어, 알 수없는 스위치가 주어 졌을 때 명령 줄 프로그램이 반환 할 수있는 데이터를 얻기 위해 종종 &quot;_USAGE_MESSAGE&quot;와 같은 간단한 설명 키를 사용합니다. 그 시점에서 나는 즉시 ProjectClass :: L10N :: en lexicon에 lexicon 항목을 정의합니다 (영어는 항상 &quot;프로젝트 언어&quot;이므로).</target>
        </trans-unit>
        <trans-unit id="a12498934a0d4cbe958ea9ae2277b44bccce11e2" translate="yes" xml:space="preserve">
          <source>I am not root, how can I install a module in a personal directory?</source>
          <target state="translated">루트가 아닙니다. 개인 디렉터리에 모듈을 어떻게 설치할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="720225fb87f4fceb999d3d3c67fa208ed54fe066" translate="yes" xml:space="preserve">
          <source>I am sure there are bugs in the code. If you do find any, or can suggest any enhancements, I would welcome your comments.</source>
          <target state="translated">코드에 버그가 있다고 확신합니다. 당신이 발견하거나 개선 사항을 제안 할 수 있다면, 나는 당신의 의견을 환영합니다.</target>
        </trans-unit>
        <trans-unit id="f822dc00911ca2b5b17523234c19e71174239e30" translate="yes" xml:space="preserve">
          <source>I assume that each language class derives (directly or indirectly) from your project class, and also defines its @ISA, its %Lexicon, or both. But I anticipate no dire consequences if these assumptions do not hold.</source>
          <target state="translated">각 언어 클래스는 프로젝트 클래스에서 (직접 또는 간접적으로) 파생되며 @ISA, % Lexicon 또는 둘 다를 정의한다고 가정합니다. 그러나 이러한 가정이 유지되지 않으면 심각한 결과는 없을 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="5f16057cfc74a8e91522c5a546d3a88bbd9af3c3" translate="yes" xml:space="preserve">
          <source>I can picture all sorts of circumstances where you just do not want lookup to be able to fail (since failing normally means that maketext throws a &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, although see the next section for greater control over that). But here's one circumstance where _AUTO lexicons are meant to be</source>
          <target state="translated">조회가 실패하기를 원하지 않는 모든 종류의 상황을 묘사 할 수 있습니다 (일반적으로 실패하면 maketext가 &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 던지는 것을 의미하기 때문에 다음 섹션을 참조하십시오). 그러나 여기에 _AUTO 사전이 있어야 할 상황이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4089c61d9307c046d40cd9abd561382f7f03ee3" translate="yes" xml:space="preserve">
          <source>I cannot embed perl into my program, or use</source>
          <target state="translated">프로그램에 펄을 포함 시키거나 사용할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="31d3f8a1fa15d729190062c1ddc4f7dd97a4bdd9" translate="yes" xml:space="preserve">
          <source>I cannot embed perl into my program, or use _perl.dll_ from my program.</source>
          <target state="translated">프로그램에 perl을 포함 시키거나 프로그램에서 _perl.dll_을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0dfdb8e8d03951e17fc904de692bb5bbd7335317" translate="yes" xml:space="preserve">
          <source>I cannot run external programs</source>
          <target state="translated">외부 프로그램을 실행할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="03ed42e550b2837d803cc938a5c931b4a08219dc" translate="yes" xml:space="preserve">
          <source>I copied the Perl binary from one machine to another, but scripts don't work.</source>
          <target state="translated">한 컴퓨터에서 다른 컴퓨터로 Perl 바이너리를 복사했지만 스크립트가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9327e89bd234d7a986b2da9100760b6e37c4547a" translate="yes" xml:space="preserve">
          <source>I could start up faster by delaying compilation until it should be needed, but this gets a &quot;panic: top_level&quot; when using the pragma form in Perl 5.001e.</source>
          <target state="translated">컴파일이 필요할 때까지 지연시켜 더 빨리 시작할 수 있지만 Perl 5.001e에서 pragma 양식을 사용할 때 &quot;panic : top_level&quot;이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="88a201ad71d898eadaddaac681114556a0d035b9" translate="yes" xml:space="preserve">
          <source>I do not anticipate that you will need (or particularly want) to nest bracket groups, but you are welcome to email me with convincing (real-life) arguments to the contrary.</source>
          <target state="translated">나는 당신이 괄호 그룹을 중첩해야 할 것이라고 기대하지는 않지만 (실제로) 설득력있는 주장을 이메일로 보내주십시오.</target>
        </trans-unit>
        <trans-unit id="3bb5142da6ee5443fb8a1f91f511fc41a8d23e27" translate="yes" xml:space="preserve">
          <source>I don't have a C compiler. How can I build my own Perl interpreter?</source>
          <target state="translated">C 컴파일러가 없습니다. 어떻게 펄 통역사를 만들 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="d6d0389812dedc1090c3af8ee3195c2e1255c8d3" translate="yes" xml:space="preserve">
          <source>I foresee no problems with having multiple inheritance in your hierarchy of language classes. (As usual, however, Perl will complain bitterly if you have a cycle in the hierarchy: i.e., if any class is its own ancestor.)</source>
          <target state="translated">언어 클래스의 계층 구조에서 다중 상속을하는 데 아무런 문제가 없다고 생각합니다. 그러나 평소와 같이 Perl은 계층 구조에주기가있는 경우 (즉, 클래스가 자체 조상 인 경우) 심하게 불평합니다.</target>
        </trans-unit>
        <trans-unit id="371ea8fdbc8bb052c307098a6984a7c87ed2802d" translate="yes" xml:space="preserve">
          <source>I get an error when I run this from my shell (which happens to be bash). That may look like perl forgot it has a &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; function, but my shebang line is not the path to perl, so the shell runs the script, and I get the error.</source>
          <target state="translated">내 쉘에서 이것을 실행할 때 오류가 발생합니다 (bash). 그것은 perl처럼 보일 수도 있지만 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; 함수를 가지고 있지만 내 shebang 줄은 perl의 경로가 아니므로 쉘이 스크립트를 실행하고 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="25b36e7f52406231ec7c4381f27e5a02ba4d1de4" translate="yes" xml:space="preserve">
          <source>I grabbed the sources and tried to compile but gdbm/dynamic loading/malloc/linking/... failed. How do I make it work?</source>
          <target state="translated">나는 소스를 잡고 컴파일하려고했지만 gdbm / dynamic loading / malloc / linking / ...이 실패했습니다. 어떻게 작동합니까?</target>
        </trans-unit>
        <trans-unit id="12aeb2257dccbb467ef10e49ef5687a5f072930e" translate="yes" xml:space="preserve">
          <source>I have no clue what this does. Strips function prefixes?</source>
          <target state="translated">나는 이것이 무엇을하는지 전혀 모른다. 함수 접두사를 제거 하시겠습니까?</target>
        </trans-unit>
        <trans-unit id="fc30870b270d5fd5a0e0ca93284b0967a0e43a00" translate="yes" xml:space="preserve">
          <source>I have supposed that since this module is concerned with file I/O, almost all normal use of it will be heavily I/O bound. This means that the time to maintain complicated data structures inside the module will be dominated by the time to actually perform the I/O. When there was an opportunity to spend CPU time to avoid doing I/O, I usually tried to take it.</source>
          <target state="translated">이 모듈은 파일 I / O와 관련이 있기 때문에 거의 모든 일반적인 사용은 I / O에 크게 구속됩니다. 이는 모듈 내에서 복잡한 데이터 구조를 유지하는 시간이 실제로 I / O를 수행하는 시간에 의해 지배됨을 의미합니다. I / O를 피하기 위해 CPU 시간을 소비 할 기회가 있었을 때 나는 보통 그것을 시도했습니다.</target>
        </trans-unit>
        <trans-unit id="9f890badb47c01638de767ac6be14f492fbbfa01" translate="yes" xml:space="preserve">
          <source>I installed a Bundle and had a couple of fails. When I retried, everything resolved nicely. Can this be fixed to work on first try?</source>
          <target state="translated">번들을 설치했는데 몇 가지 오류가 발생했습니다. 다시 시도하면 모든 것이 잘 해결되었습니다. 첫 번째 시도에서 작동하도록 수정할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="f93fb27a66a374179e4455b8d8985c2d226a8af1" translate="yes" xml:space="preserve">
          <source>I installed a new version of module X but CPAN keeps saying, I have the old version installed</source>
          <target state="translated">모듈 X의 새 버전을 설치했지만 CPAN에서 계속 이전 버전이 설치되어 있다고 말합니다.</target>
        </trans-unit>
        <trans-unit id="ce465a8fc00712ba52e5306e95737f3b12576087" translate="yes" xml:space="preserve">
          <source>I know of no way to find out the state of popups</source>
          <target state="translated">팝업 상태를 알 수있는 방법이 없습니다</target>
        </trans-unit>
        <trans-unit id="50ca6fc19f7270831b580874499d55acf40e475f" translate="yes" xml:space="preserve">
          <source>I know of no way to find out the state of redirection of popups to the disk</source>
          <target state="translated">팝업이 디스크로 리디렉션되는 상태를 알 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="74eeceb13c393c687a92a5cda3bd40599b660cd1" translate="yes" xml:space="preserve">
          <source>I lost track; what encoding is the internal format really?</source>
          <target state="translated">나는 길을 잃었다. 내부 형식은 실제로 어떤 인코딩입니까?</target>
        </trans-unit>
        <trans-unit id="d25ced27930e65857371f29ffd1a913f02b5e4b7" translate="yes" xml:space="preserve">
          <source>I love it when a plan comes together</source>
          <target state="translated">계획이 모일 때 나는 그것을 좋아한다</target>
        </trans-unit>
        <trans-unit id="606078fbab11616b11caaa1df541827c0df787a2" translate="yes" xml:space="preserve">
          <source>I maintain a mailing list on which I occasionally announce new versions of Memoize. The list is for announcements only, not discussion. To join, send an empty message to mjd-perl-memoize-request@Plover.com.</source>
          <target state="translated">나는 때때로 새로운 버전의 Memoize를 발표하는 메일 링리스트를 유지한다. 이 목록은 공지가 아닌 토론 용입니다. 가입하려면 빈 메시지를 mjd-perl-memoize-request@Plover.com으로 보내십시오.</target>
        </trans-unit>
        <trans-unit id="92c1a5ec60a557a8f6b6b470a96e90910a56e1c7" translate="yes" xml:space="preserve">
          <source>I pointed out that &lt;code&gt;Memoize&lt;/code&gt; uses a hash, and that looking up a number in the hash is necessarily going to take a lot longer than a single multiplication. There really is no way to speed up the &lt;code&gt;square&lt;/code&gt; function.</source>
          <target state="translated">나는 &lt;code&gt;Memoize&lt;/code&gt; 가 해시를 사용하고 해시에서 숫자를 찾는 것이 단일 곱셈보다 훨씬 오래 걸릴 것이라고 지적했습니다 . 실제로 &lt;code&gt;square&lt;/code&gt; 함수의 속도를 높일 방법이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="44584b7f38a4c7c497d3af92b7cb4267fde694f9" translate="yes" xml:space="preserve">
          <source>I promised to give you 90% of the benefit with 10% of the details, and that means I left out 90% of the details. Now that you have an overview of the important parts, it should be easier to read the &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; manual page, which discusses 100% of the details.</source>
          <target state="translated">나는 10 %의 세부 사항으로 혜택의 90 %를 제공하겠다고 약속했고, 이는 90 %의 세부 사항을 생략했음을 의미합니다. 중요한 부분에 대한 개요를 &lt;a href=&quot;perlref&quot;&gt;보았&lt;/a&gt; 으므로 perlref 매뉴얼 페이지를 보다 쉽게 ​​읽을 수 있습니다 . 자세한 내용은 100 %를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="fe86a2ccd7bbbde333da23b987f2e2e4802f719a" translate="yes" xml:space="preserve">
          <source>I put a regular expression into $/ but it didn't work. What's wrong?</source>
          <target state="translated">정규 표현식을 $ /에 넣었지만 작동하지 않았습니다. 뭐가 문제 야?</target>
        </trans-unit>
        <trans-unit id="73511fb1b7957dad066b5bf11010746dfb956b61" translate="yes" xml:space="preserve">
          <source>I recommend reading all of these:</source>
          <target state="translated">이 모든 것을 읽는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b7928600b482b60ec404a555ac7072bbe1486616" translate="yes" xml:space="preserve">
          <source>I say &quot;your portion of the stack&quot; above because PP code doesn't necessarily get the whole stack to itself: if your function calls another function, you'll only want to expose the arguments aimed for the called function, and not (necessarily) let it get at your own data. The way we do this is to have a &quot;virtual&quot; bottom-of-stack, exposed to each function. The mark stack keeps bookmarks to locations in the argument stack usable by each function. For instance, when dealing with a tied variable, (internally, something with &quot;P&quot; magic) Perl has to call methods for accesses to the tied variables. However, we need to separate the arguments exposed to the method to the argument exposed to the original function - the store or fetch or whatever it may be. Here's roughly how the tied &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; is implemented; see &lt;code&gt;av_push&lt;/code&gt; in</source>
          <target state="translated">PP 코드가 반드시 전체 스택 자체를 가져 오지는 않기 때문에 위에서 &quot;스택의 일부&quot;라고 말합니다. 함수가 다른 함수를 호출하는 경우 호출 된 함수를 대상으로하는 인수 만 노출하고 싶을 필요는 없습니다. ) 자신의 데이터를 얻습니다. 이를 수행하는 방법은 &quot;가상&quot;스택의 최하위를 각 함수에 노출시키는 것입니다. 마크 스택은 각 함수에서 사용할 수있는 인수 스택의 위치에 책갈피를 유지합니다. 예를 들어, 묶인 변수를 처리 할 때 (내부적으로 &quot;P&quot;마술이있는 것) Perl은 묶인 변수에 액세스하기위한 메소드를 호출해야합니다. 그러나 메소드에 노출 된 인수를 원래 함수 (스토어 또는 페치 또는 기타)에 노출 된 인수로 분리해야합니다. 여기'대략적인 &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; 가 어떻게 구현 되는지 ; 보다 &lt;code&gt;av_push&lt;/code&gt; in</target>
        </trans-unit>
        <trans-unit id="bd010707291df43195b163d13725276025549dad" translate="yes" xml:space="preserve">
          <source>I still don't get locking. I just want to increment the number in the file. How can I do this?</source>
          <target state="translated">여전히 잠금이되지 않습니다. 파일의 숫자를 늘리고 싶습니다. 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="0c3fa205e2bf9a49a23f4b51209de0f9232902bf" translate="yes" xml:space="preserve">
          <source>I think it would help to give some concrete examples to make it easier to understand the API. Of course I agree that the API has to be concise, but since there is no second document that is more of a guide, I think that it'd make it easier to start with the doc which is an API, but has examples in it in places where things are unclear, to a person who is not a PerlIO guru (yet).</source>
          <target state="translated">API를 이해하기 쉽도록 구체적인 예제를 제공하는 것이 도움이 될 것이라고 생각합니다. 물론 나는 API가 간결해야한다는 데 동의하지만, 더 많은 가이드가있는 두 번째 문서가 없기 때문에 API 인 문서로 시작하는 것이 더 쉬울 것이라고 생각하지만 예제가 있습니다. PerlIO 전문가 (아직)가 아닌 사람에게 일이 불분명 한 곳에서.</target>
        </trans-unit>
        <trans-unit id="09ffd110a6022c3eacd4a506a275e7c45f272e0d" translate="yes" xml:space="preserve">
          <source>I think that keys as lexicon values makes the completed lexicon entries more readable:</source>
          <target state="translated">사전 값인 키는 완성 된 사전 항목을 더 읽기 쉽게 만든다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="794953983b61d639901830159ca78a40665adca3" translate="yes" xml:space="preserve">
          <source>I used 'lynx' to fetch a file, but its contents is all wrong!</source>
          <target state="translated">파일을 가져 오기 위해 'lynx'를 사용했지만 내용이 모두 잘못되었습니다!</target>
        </trans-unit>
        <trans-unit id="14dcb94db4c292bdfbf0b5c851ca4df4a4bf4c31" translate="yes" xml:space="preserve">
          <source>I want to clean up my mess, and install a new perl along with all modules I have. How do I go about it?</source>
          <target state="translated">엉망을 정리하고 모든 모듈과 함께 새로운 펄을 설치하고 싶습니다. 어떻게하면 되나요?</target>
        </trans-unit>
        <trans-unit id="0c2d698fc768ffb8cd382c1370e66993c67187ee" translate="yes" xml:space="preserve">
          <source>I {changed directory, modified my environment} in a perl script. How come the change disappeared when I exited the script? How do I get my changes to be visible?</source>
          <target state="translated">펄 스크립트에서 {디렉토리를 변경하고 환경을 수정했습니다}. 스크립트를 종료하면 어떻게 변경이 사라 집니까? 변경 사항을 표시하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="8d4b0ae21d1479e72399aeb9631081d458e4ae16" translate="yes" xml:space="preserve">
          <source>I&amp;lt;bar&amp;gt;</source>
          <target state="translated">I&amp;lt;bar&amp;gt;</target>
        </trans-unit>
        <trans-unit id="3bb667cf6d485cf87366e4fa5d3fb7627b160f2b" translate="yes" xml:space="preserve">
          <source>I'll define the</source>
          <target state="translated">나는 정의 할 것이다</target>
        </trans-unit>
        <trans-unit id="5cc9daab4dbfbc15ce11a2a71cb8dfe5485782e2" translate="yes" xml:space="preserve">
          <source>I'm afraid that we're not quite through with the alignment catch yet. The hydra raises another ugly head when you pack arrays of structures:</source>
          <target state="translated">우리는 아직 얼라인먼트 캐치를 아직 끝내지 못하고 있습니다. 구조물 배열을 포장 할 때 히드라가 또 다른 추악한 머리를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f883cc87b6710df9317db1561fdc26ada281ddbe" translate="yes" xml:space="preserve">
          <source>I'm frequently irritated with the CPAN shell's inability to help me select a good mirror.</source>
          <target state="translated">CPAN 쉘이 좋은 미러를 선택할 수 없다는 점에 자주 짜증이납니다.</target>
        </trans-unit>
        <trans-unit id="70a3ef0517de91698e88a243cc2feee12ba385a3" translate="yes" xml:space="preserve">
          <source>I'm having trouble matching over more than one line. What's wrong?</source>
          <target state="translated">두 줄 이상 일치하는 데 문제가 있습니다. 뭐가 문제 야?</target>
        </trans-unit>
        <trans-unit id="8b9d03c166b0dec7e59491eb481c804d58495438" translate="yes" xml:space="preserve">
          <source>I'm not totally sure that locale names map satisfactorily to language tags. Think REAL hard about how you use this. YOU HAVE BEEN WARNED.</source>
          <target state="translated">로캘 이름이 언어 태그에 만족스럽게 매핑되는지 확실하지 않습니다. 이것을 사용하는 방법에 대해 REAL을 열심히 생각하십시오. 경고를 받았습니다.</target>
        </trans-unit>
        <trans-unit id="73daa2b6bdc84827d06ade0cf82b30946cb9ce40" translate="yes" xml:space="preserve">
          <source>I'm offering this port &quot;as is&quot;. You can ask me questions, but I can't guarantee I'll be able to answer them. There are some excellent books available on the Perl language; consult a book seller.</source>
          <target state="translated">이 포트를 &quot;있는 그대로&quot;제공하고 있습니다. 당신은 나에게 질문을 할 수 있지만, 내가 대답 할 수 있다고 보장 할 수는 없습니다. Perl 언어로 된 훌륭한 책들이 있습니다; 서적 판매자에게 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="4357a589e4e3b7a00e21bb3c83ca3b640b5e0ab8" translate="yes" xml:space="preserve">
          <source>I'm ok, you're not ok.</source>
          <target state="translated">난 괜찮아 넌 괜찮아</target>
        </trans-unit>
        <trans-unit id="108bd315655f1ba897c01059e340ad678da6e2f4" translate="yes" xml:space="preserve">
          <source>I'm sure most of us have seen code which looks like, (or worse than), this:</source>
          <target state="translated">우리 대부분은 다음과 같은 코드를 보았을 것입니다.</target>
        </trans-unit>
        <trans-unit id="76c00e4567fd7637d5e9878ed4c5f66e616b88b8" translate="yes" xml:space="preserve">
          <source>I've considered making all the above functions that output language tags return all those tags strictly in lowercase. Having all your language tags in lowercase does make some things easier. But you might as well just lowercase as you like, or call &lt;code&gt;encode_language_tag($lang1)&lt;/code&gt; where appropriate.</source>
          <target state="translated">출력 언어 태그를 출력하는 위의 모든 기능을 모든 태그를 소문자로 엄격하게 반환하는 것을 고려했습니다. 모든 언어 태그를 소문자로 사용하면 더 쉽게 할 수 있습니다. 그러나 원하는대로 소문자를 입력하거나 적절한 경우 &lt;code&gt;encode_language_tag($lang1)&lt;/code&gt; 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="88c5fcd7802546df837a3bf463ca41dcbe3c282a" translate="yes" xml:space="preserve">
          <source>I've read perlembed, perlguts, etc., but I can't embed perl in my C program; what am I doing wrong?</source>
          <target state="translated">나는 perlembed, perlguts 등을 읽었지만 C 프로그램에 perl을 포함시킬 수는 없다. 내가 뭘 잘못하고 있죠?</target>
        </trans-unit>
        <trans-unit id="c880785e491d41fc494e4fbfcd55e995f2687586" translate="yes" xml:space="preserve">
          <source>I/O Operators</source>
          <target state="translated">I / O 연산자</target>
        </trans-unit>
        <trans-unit id="1fa930eaf91e1f81994700657728c3a757afb3cf" translate="yes" xml:space="preserve">
          <source>I/O flow (the actual 5 minute tutorial)</source>
          <target state="translated">I / O 흐름 (실제 5 분 자습서)</target>
        </trans-unit>
        <trans-unit id="46fc5fcf49da9b0ec975af77958aa41975a1fe45" translate="yes" xml:space="preserve">
          <source>I/O redirection and backgrounding</source>
          <target state="translated">I / O 리디렉션 및 배경</target>
        </trans-unit>
        <trans-unit id="8571fe32abe041d9dce3d7d7c47b858f248fa514" translate="yes" xml:space="preserve">
          <source>I18N AND L10N</source>
          <target state="translated">I18N과 L10N</target>
        </trans-unit>
        <trans-unit id="e6b903dcac2bbc1b40e43d5e333946755137d36f" translate="yes" xml:space="preserve">
          <source>I18N::Charset</source>
          <target state="translated">I18N::Charset</target>
        </trans-unit>
        <trans-unit id="de5d730fbdbbf0183cf0f4683f1a73058ef3481c" translate="yes" xml:space="preserve">
          <source>I18N::Collate</source>
          <target state="translated">I18N::Collate</target>
        </trans-unit>
        <trans-unit id="01ad2dd6dde49d7565416cd97f4d499093f9d249" translate="yes" xml:space="preserve">
          <source>I18N::Collate - compare 8-bit scalar data according to the current locale</source>
          <target state="translated">I18N :: Collate-현재 로케일에 따라 8 비트 스칼라 데이터 비교</target>
        </trans-unit>
        <trans-unit id="e106875b328699ace6767aa9c5ecab5bca3b0bd8" translate="yes" xml:space="preserve">
          <source>I18N::LangTags</source>
          <target state="translated">I18N::LangTags</target>
        </trans-unit>
        <trans-unit id="169f8297167d0e993d7316faae039b48a7c3bab1" translate="yes" xml:space="preserve">
          <source>I18N::LangTags - functions for dealing with RFC3066-style language tags</source>
          <target state="translated">I18N :: LangTags-RFC3066 스타일 언어 태그를 처리하는 기능</target>
        </trans-unit>
        <trans-unit id="921275b7d99f260593561350c7678a20816444ed" translate="yes" xml:space="preserve">
          <source>I18N::LangTags::Detect</source>
          <target state="translated">I18N::LangTags::Detect</target>
        </trans-unit>
        <trans-unit id="778875cc577b876aab7ab802d4648cdcd4ee6cae" translate="yes" xml:space="preserve">
          <source>I18N::LangTags::Detect - detect the user's language preferences</source>
          <target state="translated">I18N :: LangTags :: Detect-사용자의 언어 기본 설정 감지</target>
        </trans-unit>
        <trans-unit id="c04ea1622f377702e175508a3a481907575a2f47" translate="yes" xml:space="preserve">
          <source>I18N::LangTags::List</source>
          <target state="translated">I18N::LangTags::List</target>
        </trans-unit>
        <trans-unit id="020bb812c335fc278093b15a03a292e40918c844" translate="yes" xml:space="preserve">
          <source>I18N::LangTags::List -- tags and names for human languages</source>
          <target state="translated">I18N :: LangTags :: List-인간 언어의 태그 및 이름</target>
        </trans-unit>
        <trans-unit id="e3646198e54c82833384221bb49e8cf11f385f8f" translate="yes" xml:space="preserve">
          <source>I18N::Langinfo</source>
          <target state="translated">I18N::Langinfo</target>
        </trans-unit>
        <trans-unit id="75f77bed8de0aee0770843a55893169b79d25155" translate="yes" xml:space="preserve">
          <source>I18N::Langinfo - query locale information</source>
          <target state="translated">I18N :: Langinfo-로캘 정보 쿼리</target>
        </trans-unit>
        <trans-unit id="fde9493a25e191231f11e09ab4dbdd30b2b2a8bf" translate="yes" xml:space="preserve">
          <source>I18N:Collate obsolete</source>
          <target state="translated">I18N : 더 이상 사용되지 않는 컬렉션</target>
        </trans-unit>
        <trans-unit id="0afef78a7afa599e29cd712fed951b6314ade53c" translate="yes" xml:space="preserve">
          <source>I18n and l10n</source>
          <target state="translated">I18n 및 L10N</target>
        </trans-unit>
        <trans-unit id="0e13c62333772940b082221be7ca7762de31a069" translate="yes" xml:space="preserve">
          <source>IBM XL C for AIX</source>
          <target state="translated">AIX 용 IBM XL C</target>
        </trans-unit>
        <trans-unit id="c8afdae11327e149f5501c448b30becf77bc4954" translate="yes" xml:space="preserve">
          <source>IBM XL C/C++ for AIX</source>
          <target state="translated">AIX 용 IBM XL C / C ++</target>
        </trans-unit>
        <trans-unit id="90317bc062fe454cff88014258aea7e36e9b3afc" translate="yes" xml:space="preserve">
          <source>IBM calls its implementation of long doubles 128-bit, but it is not the IEEE 128-bit (&quot;quadruple precision&quot;) which would give 116 bit of mantissa (nor it is implemented in hardware), instead it's a special software implementation called &quot;double-double&quot;, which gives 106 bits of mantissa.</source>
          <target state="translated">IBM은 long doubles 128 비트 구현을 호출하지만 IEEE 116 비트 ( &quot;사중 정밀도&quot;)가 아니라 116 비트의 가수 (하드웨어로 구현되지 않음)가 아니라 &quot; double-double &quot;은 106 비트의 가수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="896c500f28ef7df0fbbd0268cb9652b7cfe0014c" translate="yes" xml:space="preserve">
          <source>IBM uses the AIX system Perl (V5.6.0 on AIX 5.1 and V5.8.2 on AIX 5.2 / 5.3 and 6.1; V5.8.8 on AIX 5.3 TL11 and AIX 6.1 TL4; V5.10.1 on AIX 7.1) for some AIX system scripts. If you switch the links in /usr/bin from the AIX system Perl (/usr/opt/perl5) to the newly build Perl then you get the same features as with the IBM AIX system Perl if the threaded options are used.</source>
          <target state="translated">IBM은 일부 AIX 시스템 스크립트에 AIX 시스템 Perl (AIX 5.1 / 5.3 및 6.1의 경우 AIX 5.1 및 V5.8.2, AIX 5.3 TL11 및 AIX 6.1 TL4의 경우 V5.8.8, AIX 7.1의 경우 V5.10.1)을 사용합니다. AIX 시스템 Perl (/ usr / opt / perl5)에서 새로 빌드 된 Perl로 / usr / bin의 링크를 전환하면 스레드 옵션이 사용되는 경우 IBM AIX 시스템 Perl과 동일한 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ade9d724c5b212d6e78013557f35ac5c64927377" translate="yes" xml:space="preserve">
          <source>ICU Character Mapping Tables &lt;a href=&quot;http://site.icu-project.org/charts/charset&quot;&gt;http://site.icu-project.org/charts/charset&lt;/a&gt;</source>
          <target state="translated">ICU 문자 매핑 테이블 &lt;a href=&quot;http://site.icu-project.org/charts/charset&quot;&gt;http://site.icu-project.org/charts/charset&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="92d0be3756020c7fb70f5f8d43b6e18e96de1472" translate="yes" xml:space="preserve">
          <source>ICU Home Page &lt;a href=&quot;http://www.icu-project.org/&quot;&gt;http://www.icu-project.org/&lt;/a&gt;</source>
          <target state="translated">ICU 홈페이지 &lt;a href=&quot;http://www.icu-project.org/&quot;&gt;http://www.icu-project.org/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4b3a4d066585cb49384b262b020e538f42a1f2ef" translate="yes" xml:space="preserve">
          <source>ICU:Conversion Data &lt;a href=&quot;http://www.icu-project.org/userguide/conversion-data.html&quot;&gt;http://www.icu-project.org/userguide/conversion-data.html&lt;/a&gt;</source>
          <target state="translated">ICU : 전환 데이터 &lt;a href=&quot;http://www.icu-project.org/userguide/conversion-data.html&quot;&gt;http://www.icu-project.org/userguide/conversion-data.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="89f89c02cf47e091e726a4e07b88af0966806897" translate="yes" xml:space="preserve">
          <source>ID</source>
          <target state="translated">ID</target>
        </trans-unit>
        <trans-unit id="46c5f048dbe4176fe265d2a79feb829754221b1e" translate="yes" xml:space="preserve">
          <source>IDENTIFYING CHARACTER CODE SETS</source>
          <target state="translated">문자 코드 세트 식별</target>
        </trans-unit>
        <trans-unit id="98eebf3bdf415d089af03ec0debc7c66f797a900" translate="yes" xml:space="preserve">
          <source>IETF Policy on Character Sets and Languages</source>
          <target state="translated">문자 집합 및 언어에 대한 IETF 정책</target>
        </trans-unit>
        <trans-unit id="6a5d66d70494ee5ff5a453f224b81868447c393b" translate="yes" xml:space="preserve">
          <source>IMPLEMENTATION</source>
          <target state="translated">IMPLEMENTATION</target>
        </trans-unit>
        <trans-unit id="282613097967896b3e57bca75eb0bce558486a26" translate="yes" xml:space="preserve">
          <source>IMPLEMENTATION DETAILS</source>
          <target state="translated">구현 세부 사항</target>
        </trans-unit>
        <trans-unit id="0e35eae7c0731d3856fc41389b70ba2d34677ec0" translate="yes" xml:space="preserve">
          <source>IMPLEMENTATION NOTE</source>
          <target state="translated">구현 노트</target>
        </trans-unit>
        <trans-unit id="00f6ac93461571c87bf08a0fa480109344a9be63" translate="yes" xml:space="preserve">
          <source>IMPLICIT LOADING</source>
          <target state="translated">묵시적 로딩</target>
        </trans-unit>
        <trans-unit id="926527594f94772fcf38d60a2b632b1bb4c3c38c" translate="yes" xml:space="preserve">
          <source>IMPORTANT!</source>
          <target state="translated">IMPORTANT!</target>
        </trans-unit>
        <trans-unit id="c2e68d710cae68fae1b4d1132f818132a6f1837f" translate="yes" xml:space="preserve">
          <source>IMPORTANT: if you use this &lt;code&gt;-S&lt;/code&gt; switch, be sure to delete the CONFIG environment variable before running the script:</source>
          <target state="translated">중요 :이 &lt;code&gt;-S&lt;/code&gt; 스위치 를 사용 하는 경우 스크립트를 실행하기 전에 CONFIG 환경 변수를 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="7696e648752c3c28012375bdb960a19fe39b8205" translate="yes" xml:space="preserve">
          <source>IMPORTS THE FUNCTIONS</source>
          <target state="translated">기능을 가져옵니다</target>
        </trans-unit>
        <trans-unit id="6a09657af85954f963dea9fb1156c8ea7994677c" translate="yes" xml:space="preserve">
          <source>IN6ADDR_ANY, IN6ADDR_LOOPBACK</source>
          <target state="translated">IN6ADDR_ANY, IN6ADDR_LOOPBACK</target>
        </trans-unit>
        <trans-unit id="8b4b83ea115334b0957635d43569bbc4350f1369" translate="yes" xml:space="preserve">
          <source>INADDR_ANY, INADDR_BROADCAST, INADDR_LOOPBACK, INADDR_NONE</source>
          <target state="translated">INADDR_ANY, INADDR_BROADCAST, INADDR_LOOPBACK, INADDR_NONE</target>
        </trans-unit>
        <trans-unit id="cbe356b54ea95780c909073ac988ee31715e5615" translate="yes" xml:space="preserve">
          <source>INDIVIDUAL RESULTS</source>
          <target state="translated">개별 결과</target>
        </trans-unit>
        <trans-unit id="87d0fcde0a601e06d986c8740283892296dbb885" translate="yes" xml:space="preserve">
          <source>INHERITANCE</source>
          <target state="translated">INHERITANCE</target>
        </trans-unit>
        <trans-unit id="bc46a4e0420d357db7bfbcb7b5fcbc613dc48c1b" translate="yes" xml:space="preserve">
          <source>INIT</source>
          <target state="translated">INIT</target>
        </trans-unit>
        <trans-unit id="c335a27a082cc8d17dd36dc0eda3086cb0c9baaa" translate="yes" xml:space="preserve">
          <source>INSTALL</source>
          <target state="translated">INSTALL</target>
        </trans-unit>
        <trans-unit id="bcfd83b3c8dcdbc242801037551b58c708467a92" translate="yes" xml:space="preserve">
          <source>INSTALL PERL ON CYGWIN</source>
          <target state="translated">CYGWIN에 PERL 설치</target>
        </trans-unit>
        <trans-unit id="9d09dba09f4e15504911bf4a5e67189762904dd8" translate="yes" xml:space="preserve">
          <source>INSTALLATION</source>
          <target state="translated">INSTALLATION</target>
        </trans-unit>
        <trans-unit id="16fff6f9fc1411630b91667c135606baff1eac91" translate="yes" xml:space="preserve">
          <source>INSTALLING PERL IN OPENVOS</source>
          <target state="translated">OPENVOS에서 PERL 설치</target>
        </trans-unit>
        <trans-unit id="df84db65783bcfd646d621819ed5a53534ed4081" translate="yes" xml:space="preserve">
          <source>INSTALLSITELIB=i:\perl\lib</source>
          <target state="translated">INSTALLSITELIB=i:\perl\lib</target>
        </trans-unit>
        <trans-unit id="f1bd7855c675170fd5743049f5030b83e6d9486c" translate="yes" xml:space="preserve">
          <source>INSTALL_BASE</source>
          <target state="translated">INSTALL_BASE</target>
        </trans-unit>
        <trans-unit id="972644501aef360867a4520d3945803529f2cc3e" translate="yes" xml:space="preserve">
          <source>INSTALL_BASE can be passed into Makefile.PL to change where your module will be installed. INSTALL_BASE is more like what everyone else calls &quot;prefix&quot; than PREFIX is.</source>
          <target state="translated">INSTALL_BASE는 Makefile.PL로 전달되어 모듈 설치 위치를 변경할 수 있습니다. INSTALL_BASE는 다른 사람들이 PREFIX보다 &quot;접두사&quot;라고 부르는 것과 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="964f70f55608056234ee8f272195661f239be038" translate="yes" xml:space="preserve">
          <source>INSTALL_BASE in MakeMaker and &lt;code&gt;--install_base&lt;/code&gt; in Module::Build (as of 0.28) install to the same location. If you want MakeMaker and Module::Build to install to the same location simply set INSTALL_BASE and &lt;code&gt;--install_base&lt;/code&gt; to the same location.</source>
          <target state="translated">MakeMaker의 INSTALL_BASE와 Module :: Build의 &lt;code&gt;--install_base&lt;/code&gt; (0.28 기준)는 동일한 위치에 설치됩니다. MakeMaker와 Module :: Build를 같은 위치에 설치하려면 INSTALL_BASE와 &lt;code&gt;--install_base&lt;/code&gt; 를 같은 위치로 설정 하면됩니다.</target>
        </trans-unit>
        <trans-unit id="c3f863f63a3576929f3be4a5b8b4b41019807a08" translate="yes" xml:space="preserve">
          <source>INSTALL_BASE tells these tools to put your modules into</source>
          <target state="translated">INSTALL_BASE는 이러한 도구에 모듈을 넣도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="7b883de1f22bd64a8fb3db547deeba102b803a0e" translate="yes" xml:space="preserve">
          <source>INSTALL_BASE was added in 6.31.</source>
          <target state="translated">INSTALL_BASE는 6.31에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="6f436e25f27f33e27c6053472309a17baa61d133" translate="yes" xml:space="preserve">
          <source>INTERFACE</source>
          <target state="translated">INTERFACE</target>
        </trans-unit>
        <trans-unit id="325df994199a5a3b5bfde97c65a8f35d498e9bab" translate="yes" xml:space="preserve">
          <source>INTERNAL FORMAT</source>
          <target state="translated">내부 형식</target>
        </trans-unit>
        <trans-unit id="f2ee4f9d199f048c10a5b49f80f81e925ff271d9" translate="yes" xml:space="preserve">
          <source>INTERNAL VARIABLE TYPES</source>
          <target state="translated">내부 변수 유형</target>
        </trans-unit>
        <trans-unit id="ae880205d974d478a4f8301ed9ed724acfe764dd" translate="yes" xml:space="preserve">
          <source>INTERNALS</source>
          <target state="translated">INTERNALS</target>
        </trans-unit>
        <trans-unit id="0270ca97abe5bddc53ed95fb7179da4406621a18" translate="yes" xml:space="preserve">
          <source>INTRODUCTION</source>
          <target state="translated">INTRODUCTION</target>
        </trans-unit>
        <trans-unit id="9d8fb39373007c2c84580d473e2a6e10a1f4c15d" translate="yes" xml:space="preserve">
          <source>IO</source>
          <target state="translated">IO</target>
        </trans-unit>
        <trans-unit id="9703b620b98df0424c1d2891029b0a53270adadc" translate="yes" xml:space="preserve">
          <source>IO - load various IO modules</source>
          <target state="translated">IO-다양한 IO 모듈로드</target>
        </trans-unit>
        <trans-unit id="8218c7c584e2e73f83429a7a715ed0c77b1e9143" translate="yes" xml:space="preserve">
          <source>IO Functions</source>
          <target state="translated">IO 기능</target>
        </trans-unit>
        <trans-unit id="c2e82ec6ecdf1d506a4bc4471deaf660ec582141" translate="yes" xml:space="preserve">
          <source>IO:: style interface to &lt;a href=&quot;compress/zlib&quot;&gt;Compress::Zlib&lt;/a&gt;</source>
          <target state="translated">IO :: &lt;a href=&quot;compress/zlib&quot;&gt;Compress :: Zlib에 대한&lt;/a&gt; 스타일 인터페이스</target>
        </trans-unit>
        <trans-unit id="d76ad5f2ab8e85a14e373d86896f0b50ad94632d" translate="yes" xml:space="preserve">
          <source>IO::Compress::Base</source>
          <target state="translated">IO::Compress::Base</target>
        </trans-unit>
        <trans-unit id="f7a823195ba1022235bbaa930f5dacd9dcd2cde3" translate="yes" xml:space="preserve">
          <source>IO::Compress::Base - Base Class for IO::Compress modules</source>
          <target state="translated">IO :: Compress :: Base-IO :: Compress 모듈의 기본 클래스</target>
        </trans-unit>
        <trans-unit id="2246092601d71db730b1277537bdfeb99922692b" translate="yes" xml:space="preserve">
          <source>IO::Compress::Bzip2</source>
          <target state="translated">IO::Compress::Bzip2</target>
        </trans-unit>
        <trans-unit id="4c110e2dd18855a5ac17fa0ff96df45279296253" translate="yes" xml:space="preserve">
          <source>IO::Compress::Bzip2 - Write bzip2 files/buffers</source>
          <target state="translated">IO :: Compress :: Bzip2-쓰기 bzip2 파일 / 버퍼</target>
        </trans-unit>
        <trans-unit id="faeedf86bc5c3bf443dc7cb32aca40a75c1a61b1" translate="yes" xml:space="preserve">
          <source>IO::Compress::Deflate</source>
          <target state="translated">IO::Compress::Deflate</target>
        </trans-unit>
        <trans-unit id="a24fa13516822c712bdf720b0c4b0786c457612f" translate="yes" xml:space="preserve">
          <source>IO::Compress::Deflate - Write RFC 1950 files/buffers</source>
          <target state="translated">IO :: Compress :: Deflate-RFC 1950 파일 / 버퍼 쓰기</target>
        </trans-unit>
        <trans-unit id="f27ab19280760fb919a1e3287acc4b2ced04c845" translate="yes" xml:space="preserve">
          <source>IO::Compress::FAQ</source>
          <target state="translated">IO::Compress::FAQ</target>
        </trans-unit>
        <trans-unit id="c7fa9683b439c9ad1a7266191cc46683626bdae6" translate="yes" xml:space="preserve">
          <source>IO::Compress::Gzip</source>
          <target state="translated">IO::Compress::Gzip</target>
        </trans-unit>
        <trans-unit id="9e41ceaa77fd713ed3c8d8b1bfe6a609a7ddcea6" translate="yes" xml:space="preserve">
          <source>IO::Compress::Gzip - Write RFC 1952 files/buffers</source>
          <target state="translated">IO :: Compress :: Gzip-RFC 1952 파일 / 버퍼 쓰기</target>
        </trans-unit>
        <trans-unit id="3205da05670e0698dd32ff4811dcf7e209aab757" translate="yes" xml:space="preserve">
          <source>IO::Compress::RawDeflate</source>
          <target state="translated">IO::Compress::RawDeflate</target>
        </trans-unit>
        <trans-unit id="94bf2f893b55a2f57dfacc0d6c1e83c0ef44793d" translate="yes" xml:space="preserve">
          <source>IO::Compress::RawDeflate - Write RFC 1951 files/buffers</source>
          <target state="translated">IO :: Compress :: RawDeflate-RFC 1951 파일 / 버퍼 작성</target>
        </trans-unit>
        <trans-unit id="7015e5f6eae1214c2df0155ccaef808cdc7d0769" translate="yes" xml:space="preserve">
          <source>IO::Compress::Zip</source>
          <target state="translated">IO::Compress::Zip</target>
        </trans-unit>
        <trans-unit id="b05cb1e00a4226cff2f721fcd3f609b4ad94b38c" translate="yes" xml:space="preserve">
          <source>IO::Compress::Zip - Write zip files/buffers</source>
          <target state="translated">IO :: Compress :: Zip-zip 파일 / 버퍼 쓰기</target>
        </trans-unit>
        <trans-unit id="4bf7c8cfd258e92c5a7a288432da2eb725c5d32c" translate="yes" xml:space="preserve">
          <source>IO::Dir</source>
          <target state="translated">IO::Dir</target>
        </trans-unit>
        <trans-unit id="f3b94128fba8d6583679638179ef4a0530bdd5d3" translate="yes" xml:space="preserve">
          <source>IO::Dir - supply object methods for directory handles</source>
          <target state="translated">IO :: Dir-디렉토리 핸들을위한 객체 메소드 제공</target>
        </trans-unit>
        <trans-unit id="1287d92d070eaf8f54116ae56a21bfe69917a99d" translate="yes" xml:space="preserve">
          <source>IO::File</source>
          <target state="translated">IO::File</target>
        </trans-unit>
        <trans-unit id="aef399115f05d82a203fb89d5e657a748c3e82de" translate="yes" xml:space="preserve">
          <source>IO::File - supply object methods for filehandles</source>
          <target state="translated">IO :: File-파일 핸들을위한 객체 메소드 제공</target>
        </trans-unit>
        <trans-unit id="85678e755d6fdd386f63c43333047c282a85eb74" translate="yes" xml:space="preserve">
          <source>IO::Handle</source>
          <target state="translated">IO::Handle</target>
        </trans-unit>
        <trans-unit id="d2ccf931b06cca09cc21fc6e3f7adaeb42eedc30" translate="yes" xml:space="preserve">
          <source>IO::Handle - supply object methods for I/O handles</source>
          <target state="translated">IO :: Handle-I / O 핸들에 대한 공급 오브젝트 메소드</target>
        </trans-unit>
        <trans-unit id="33e6674e03fd1f9387dffec88a9442f12eb239c1" translate="yes" xml:space="preserve">
          <source>IO::Handle-&amp;gt;format_formfeed(EXPR)</source>
          <target state="translated">IO::Handle-&amp;gt;format_formfeed(EXPR)</target>
        </trans-unit>
        <trans-unit id="4328314a142bc495dbcedc8dec821af05b31bc33" translate="yes" xml:space="preserve">
          <source>IO::Handle-&amp;gt;format_line_break_characters EXPR</source>
          <target state="translated">IO :: 핸들-&amp;gt; format_line_break_characters EXPR</target>
        </trans-unit>
        <trans-unit id="6e5d46bf8e867cd748990f3121e29b41bc040337" translate="yes" xml:space="preserve">
          <source>IO::Handle-&amp;gt;input_record_separator( EXPR )</source>
          <target state="translated">IO :: 핸들-&amp;gt; 입력 _ 레코드 _ 분리기 (EXPR)</target>
        </trans-unit>
        <trans-unit id="88d38bb7198b1035ad2fe3e3a4c8b631ea81ae89" translate="yes" xml:space="preserve">
          <source>IO::Handle-&amp;gt;output_field_separator( EXPR )</source>
          <target state="translated">IO :: 핸들-&amp;gt; output_field_separator (EXPR)</target>
        </trans-unit>
        <trans-unit id="960c5c651b09566f1754a215a5295869a49e219e" translate="yes" xml:space="preserve">
          <source>IO::Handle-&amp;gt;output_record_separator( EXPR )</source>
          <target state="translated">IO :: Handle-&amp;gt; output_record_separator (EXPR)</target>
        </trans-unit>
        <trans-unit id="7d7436d4629d382e64fc528a233e4705d021fb55" translate="yes" xml:space="preserve">
          <source>IO::Pipe</source>
          <target state="translated">IO::Pipe</target>
        </trans-unit>
        <trans-unit id="00e90fb1e0a6527593ec48869ad8bdd4be4727ec" translate="yes" xml:space="preserve">
          <source>IO::Pipe - supply object methods for pipes</source>
          <target state="translated">IO :: Pipe-파이프에 대한 공급 오브젝트 메소드</target>
        </trans-unit>
        <trans-unit id="7411852690ce77d3e52c0392cb140a1da3c8926a" translate="yes" xml:space="preserve">
          <source>IO::Poll</source>
          <target state="translated">IO::Poll</target>
        </trans-unit>
        <trans-unit id="4af10858345e94c5247f732b4f8aeefb3d3033f8" translate="yes" xml:space="preserve">
          <source>IO::Poll - Object interface to system poll call</source>
          <target state="translated">IO :: Poll-시스템 폴 호출에 대한 오브젝트 인터페이스</target>
        </trans-unit>
        <trans-unit id="a68be240586077bf55c7114e0c2dd0a3089b0b00" translate="yes" xml:space="preserve">
          <source>IO::Seekable</source>
          <target state="translated">IO::Seekable</target>
        </trans-unit>
        <trans-unit id="aca83121c079f3f44793e1fb400037048e6c0ec3" translate="yes" xml:space="preserve">
          <source>IO::Seekable - supply seek based methods for I/O objects</source>
          <target state="translated">IO :: 검색 가능-I / O 객체에 대한 검색 기반 검색 방법</target>
        </trans-unit>
        <trans-unit id="a4d83b02d49f96871e2c2e3d92dc1e0d34ec01f3" translate="yes" xml:space="preserve">
          <source>IO::Select</source>
          <target state="translated">IO::Select</target>
        </trans-unit>
        <trans-unit id="f909f3c8685d0640556ffd855c6e6b3161826eb6" translate="yes" xml:space="preserve">
          <source>IO::Select - OO interface to the select system call</source>
          <target state="translated">IO :: Select-선택 시스템 호출에 대한 OO 인터페이스</target>
        </trans-unit>
        <trans-unit id="77ccdb7781ae721df7a63530341f8d0e30eb9ba3" translate="yes" xml:space="preserve">
          <source>IO::Socket</source>
          <target state="translated">IO::Socket</target>
        </trans-unit>
        <trans-unit id="bcf86f1138a4fa3de29dc58d70750df124a76378" translate="yes" xml:space="preserve">
          <source>IO::Socket - Object interface to socket communications</source>
          <target state="translated">IO :: Socket-소켓 통신을위한 객체 인터페이스</target>
        </trans-unit>
        <trans-unit id="d9cad026ce1354129e7518abf6e60742a423f5cd" translate="yes" xml:space="preserve">
          <source>IO::Socket::INET</source>
          <target state="translated">IO::Socket::INET</target>
        </trans-unit>
        <trans-unit id="21c7e3d3993af799697bb17b584159010291f1ca" translate="yes" xml:space="preserve">
          <source>IO::Socket::INET - Object interface for AF_INET domain sockets</source>
          <target state="translated">IO :: Socket :: INET-AF_INET 도메인 소켓을위한 객체 인터페이스</target>
        </trans-unit>
        <trans-unit id="8d370bee8efab5b347f028125483323b0c8ed6d8" translate="yes" xml:space="preserve">
          <source>IO::Socket::UNIX</source>
          <target state="translated">IO::Socket::UNIX</target>
        </trans-unit>
        <trans-unit id="fd6fc205eb14f250173655f91ae8e3991e80a0fc" translate="yes" xml:space="preserve">
          <source>IO::Socket::UNIX - Object interface for AF_UNIX domain sockets</source>
          <target state="translated">IO :: Socket :: UNIX-AF_UNIX 도메인 소켓을위한 객체 인터페이스</target>
        </trans-unit>
        <trans-unit id="cc9efdf30a325c69f4eff01ffa74edfa8d13285c" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::AnyInflate</source>
          <target state="translated">IO::Uncompress::AnyInflate</target>
        </trans-unit>
        <trans-unit id="3f52359b31109c62a3cfec4235eb32afa54b7e76" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::AnyInflate - Uncompress zlib-based (zip, gzip) file/buffer</source>
          <target state="translated">IO :: Uncompress :: AnyInflate-zlib 기반 (zip, gzip) 파일 / 버퍼 압축 해제</target>
        </trans-unit>
        <trans-unit id="9bcf772c56ff61361b8adfe8ed0930e47dd806cc" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::AnyUncompress</source>
          <target state="translated">IO::Uncompress::AnyUncompress</target>
        </trans-unit>
        <trans-unit id="da915e62cd2924afaf5bdf41d62bf124d1816c96" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::AnyUncompress - Uncompress gzip, zip, bzip2 or lzop file/buffer</source>
          <target state="translated">IO :: Uncompress :: AnyUncompress-gzip, zip, bzip2 또는 lzop 파일 / 버퍼 압축 해제</target>
        </trans-unit>
        <trans-unit id="5b9d98befeabd4f68c0ee5ed490ad9ef9466ce0b" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Base</source>
          <target state="translated">IO::Uncompress::Base</target>
        </trans-unit>
        <trans-unit id="6dd0aef5e96daa96cabb662e679bcaf3f782ff34" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Base - Base Class for IO::Uncompress modules</source>
          <target state="translated">IO :: Uncompress :: Base-IO :: Uncompress 모듈의 기본 클래스</target>
        </trans-unit>
        <trans-unit id="47626e73b0c552496671b93615517289c7a72139" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Bunzip2</source>
          <target state="translated">IO::Uncompress::Bunzip2</target>
        </trans-unit>
        <trans-unit id="558fc1d47555183743c62caa50f8fea7e57150e4" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Bunzip2 - Read bzip2 files/buffers</source>
          <target state="translated">IO :: Uncompress :: Bunzip2-bzip2 파일 / 버퍼 읽기</target>
        </trans-unit>
        <trans-unit id="c56a044dac563ce20e270b6dad9d51e1ed4d67b5" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Gunzip</source>
          <target state="translated">IO::Uncompress::Gunzip</target>
        </trans-unit>
        <trans-unit id="6858dbc4b4fa294b4bc17de10e3aec6d95c7a29d" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Gunzip - Read RFC 1952 files/buffers</source>
          <target state="translated">IO :: Uncompress :: Gunzip-RFC 1952 파일 / 버퍼 읽기</target>
        </trans-unit>
        <trans-unit id="bdd707a0a7c129500d87baf2238a9f12252dc1a6" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Inflate</source>
          <target state="translated">IO::Uncompress::Inflate</target>
        </trans-unit>
        <trans-unit id="9ea3fd5cd65551930396ea883f6b4523a57e56f5" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Inflate - Read RFC 1950 files/buffers</source>
          <target state="translated">IO :: Uncompress :: Inflate-RFC 1950 파일 / 버퍼 읽기</target>
        </trans-unit>
        <trans-unit id="2387ca346858e6f631ae40207df5832845bfa4d3" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::RawInflate</source>
          <target state="translated">IO::Uncompress::RawInflate</target>
        </trans-unit>
        <trans-unit id="0d1105cd05d8ddcb7bbad73158149f37cd425d0a" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::RawInflate - Read RFC 1951 files/buffers</source>
          <target state="translated">IO :: Uncompress :: RawInflate-RFC 1951 파일 / 버퍼 읽기</target>
        </trans-unit>
        <trans-unit id="eb25986effc3adf3d081252f8af9cf0ffcfb3a8a" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Unzip</source>
          <target state="translated">IO::Uncompress::Unzip</target>
        </trans-unit>
        <trans-unit id="7aed8f7e034916e56f4674cc0310d37a446ee94f" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Unzip - Read zip files/buffers</source>
          <target state="translated">IO :: Uncompress :: Unzip-zip 파일 / 버퍼 읽기</target>
        </trans-unit>
        <trans-unit id="f4c4eb93eddc35e78414020ae5db828e1e7864b8" translate="yes" xml:space="preserve">
          <source>IO::Zlib</source>
          <target state="translated">IO::Zlib</target>
        </trans-unit>
        <trans-unit id="d04446e459b1e71b578f998f8ab90764c4b0f8e3" translate="yes" xml:space="preserve">
          <source>IO::Zlib - IO:: style interface to &lt;a href=&quot;../compress/zlib&quot;&gt;Compress::Zlib&lt;/a&gt;</source>
          <target state="translated">IO :: Zlib-IO :: &lt;a href=&quot;../compress/zlib&quot;&gt;Compress :: Zlib에 대한&lt;/a&gt; 스타일 인터페이스</target>
        </trans-unit>
        <trans-unit id="e66f01e3abb1a4678f130fa0379ceec3adaec42e" translate="yes" xml:space="preserve">
          <source>IP protocol constants to use as the third argument to socket(), the level argument to getsockopt() or setsockopt(), or the value of the &lt;code&gt;SO_PROTOCOL&lt;/code&gt; socket option.</source>
          <target state="translated">socket ()에 대한 세 번째 인수, getsockopt () 또는 setsockopt ()에 대한 레벨 인수 또는 &lt;code&gt;SO_PROTOCOL&lt;/code&gt; 소켓 옵션 의 값으로 사용할 IP 프로토콜 상수 .</target>
        </trans-unit>
        <trans-unit id="25bb80888fafae35a8c04a482f4c52ba12354860" translate="yes" xml:space="preserve">
          <source>IPC::Cmd</source>
          <target state="translated">IPC::Cmd</target>
        </trans-unit>
        <trans-unit id="4aa727aa3bbf49a23200ff9a15dd661ace7ba750" translate="yes" xml:space="preserve">
          <source>IPC::Cmd - finding and running system commands made easy</source>
          <target state="translated">IPC :: Cmd-시스템 명령을 쉽게 찾고 실행</target>
        </trans-unit>
        <trans-unit id="9e94bec610bda8b6d6dba9768e7c89860ea7cbd2" translate="yes" xml:space="preserve">
          <source>IPC::Cmd allows you to run commands platform independently, interactively if desired, but have them still work.</source>
          <target state="translated">IPC :: Cmd를 사용하면 원하는 경우 대화식으로 명령 플랫폼을 독립적으로 실행할 수 있지만 여전히 작동합니다.</target>
        </trans-unit>
        <trans-unit id="55a4e391e67ff1bdcc3e16ba0fb5ae458ce57904" translate="yes" xml:space="preserve">
          <source>IPC::Msg</source>
          <target state="translated">IPC::Msg</target>
        </trans-unit>
        <trans-unit id="6b32de39850adb752165f60b3bda5f0d97f34ff3" translate="yes" xml:space="preserve">
          <source>IPC::Msg - SysV Msg IPC object class</source>
          <target state="translated">IPC :: Msg-SysV Msg IPC 객체 클래스</target>
        </trans-unit>
        <trans-unit id="9dd902f8639b58e7edb7b6f8c06c22ac41c9ca2e" translate="yes" xml:space="preserve">
          <source>IPC::Open2</source>
          <target state="translated">IPC::Open2</target>
        </trans-unit>
        <trans-unit id="699765d9577f1c1501174faba27f2ca1f61d47cd" translate="yes" xml:space="preserve">
          <source>IPC::Open2 - open a process for both reading and writing using open2()</source>
          <target state="translated">IPC :: Open2-open2 ()를 사용하여 읽고 쓰는 프로세스를 엽니 다</target>
        </trans-unit>
        <trans-unit id="6e80951681402ceb79b82897f2cb2015d59ab625" translate="yes" xml:space="preserve">
          <source>IPC::Open3</source>
          <target state="translated">IPC::Open3</target>
        </trans-unit>
        <trans-unit id="cbebbea4476633d292dae0e9b37d3ff0220e8a12" translate="yes" xml:space="preserve">
          <source>IPC::Open3 - open a process for reading, writing, and error handling using open3()</source>
          <target state="translated">IPC :: Open3-open3 ()을 사용하여 읽기, 쓰기 및 오류 처리를위한 프로세스 열기</target>
        </trans-unit>
        <trans-unit id="5696dbec647d54eae7948ff758da75aceb6e7bdd" translate="yes" xml:space="preserve">
          <source>IPC::Semaphore</source>
          <target state="translated">IPC::Semaphore</target>
        </trans-unit>
        <trans-unit id="4ac3e2f97ecebc0c9df272394b412c2bc0e4c139" translate="yes" xml:space="preserve">
          <source>IPC::Semaphore - SysV Semaphore IPC object class</source>
          <target state="translated">IPC :: Semaphore-SysV 세마포어 IPC 객체 클래스</target>
        </trans-unit>
        <trans-unit id="eaac05351199d5338d0c67774a49f0ff5b08ddcd" translate="yes" xml:space="preserve">
          <source>IPC::SharedMem</source>
          <target state="translated">IPC::SharedMem</target>
        </trans-unit>
        <trans-unit id="b67329129b7437abd470390d9b8de8b506578731" translate="yes" xml:space="preserve">
          <source>IPC::SharedMem - SysV Shared Memory IPC object class</source>
          <target state="translated">IPC :: SharedMem-SysV 공유 메모리 IPC 객체 클래스</target>
        </trans-unit>
        <trans-unit id="cac6bf077ecf12b8c4774537cb90121c12f40546" translate="yes" xml:space="preserve">
          <source>IPC::SysV</source>
          <target state="translated">IPC::SysV</target>
        </trans-unit>
        <trans-unit id="4a65a5b9999ec2f5bcb9aefce9ed4d2ebb83e351" translate="yes" xml:space="preserve">
          <source>IPC::SysV - System V IPC constants and system calls</source>
          <target state="translated">IPC :: SysV-시스템 V IPC 상수 및 시스템 호출</target>
        </trans-unit>
        <trans-unit id="eb04f21953f498789cba10742ad8acc6a3a6d8ee" translate="yes" xml:space="preserve">
          <source>IPC::[Run|Open3] will first read all of STDOUT, then all of STDERR, meaning the output looks like '13' on STDOUT and '24' on STDERR, instead of</source>
          <target state="translated">IPC :: [Run | Open3]은 먼저 모든 STDOUT을 읽은 다음 모든 STDERR을 읽습니다. 즉, 출력은 STDOUT에서 '13', STDERR에서 '24'로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="c31963d765721dcd50b3ac6ea7828e71081eb9d0" translate="yes" xml:space="preserve">
          <source>IPPROTO_IP, IPPROTO_IPV6, IPPROTO_TCP, ...</source>
          <target state="translated">IPPROTO_IP, IPPROTO_IPV6, IPPROTO_TCP, ...</target>
        </trans-unit>
        <trans-unit id="d605f8c901e4d72b551c09d9a4925d13cd9fbbb6" translate="yes" xml:space="preserve">
          <source>IPTOS_LOWDELAY, IPTOS_THROUGHPUT, IPTOS_RELIABILITY, ...</source>
          <target state="translated">IPTOS_LOWDELAY, IPTOS_THROUGHPUT, IPTOS_RELIABILITY, ...</target>
        </trans-unit>
        <trans-unit id="b69eb35e4d4802a904ccf4f4eadf16b1c7831980" translate="yes" xml:space="preserve">
          <source>IPV6_ADD_MEMBERSHIP, IPV6_MTU, IPV6_V6ONLY, ...</source>
          <target state="translated">IPV6_ADD_MEMBERSHIP, IPV6_MTU, IPV6_V6ONLY, ...</target>
        </trans-unit>
        <trans-unit id="5dcc16ca06e8e1e2d76e2715098a08de9cb62845" translate="yes" xml:space="preserve">
          <source>IP_OPTIONS, IP_TOS, IP_TTL, ...</source>
          <target state="translated">IP_OPTIONS, IP_TOS, IP_TTL, ...</target>
        </trans-unit>
        <trans-unit id="a68fa8efe4a09d8c0c63ae60426d9366434bccb2" translate="yes" xml:space="preserve">
          <source>IRC</source>
          <target state="translated">IRC</target>
        </trans-unit>
        <trans-unit id="e845e309f2bc4605301c4c8195c02b9ee45aab86" translate="yes" xml:space="preserve">
          <source>IRIX 6.5 documentation on syslog, &lt;a href=&quot;http://techpubs.sgi.com/library/tpl/cgi-bin/getdoc.cgi?coll=0650&amp;amp;db=man&amp;amp;fname=3c+syslog&quot;&gt;http://techpubs.sgi.com/library/tpl/cgi-bin/getdoc.cgi?coll=0650&amp;amp;db=man&amp;amp;fname=3c+syslog&lt;/a&gt;</source>
          <target state="translated">syslog에 대한 IRIX 6.5 설명서, &lt;a href=&quot;http://techpubs.sgi.com/library/tpl/cgi-bin/getdoc.cgi?coll=0650&amp;amp;db=man&amp;amp;fname=3c+syslog&quot;&gt;http://techpubs.sgi.com/library/tpl/cgi-bin/getdoc.cgi?coll=0650&amp;amp;db=man&amp;amp;fname=3c+syslog&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f776e0bcef88f6053e04b30cd9568a2f517c3848" translate="yes" xml:space="preserve">
          <source>ISO 6429 is available from ISO for a charge; the author of this module does not own a copy of it. Since the source material for ISO 6429 was ECMA-048 and the latter is available for free, there seems little reason to obtain the ISO standard.</source>
          <target state="translated">ISO 6429는 ISO에서 유료로 제공됩니다. 이 모듈의 작성자는 해당 모듈의 사본을 소유하지 않습니다. ISO 6429의 소스 자료는 ECMA-048이고 후자는 무료로 제공되므로 ISO 표준을 얻을 이유가 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="3353e215f71b71f7414efad5057c41576384753e" translate="yes" xml:space="preserve">
          <source>ISO 8859</source>
          <target state="translated">ISO 8859</target>
        </trans-unit>
        <trans-unit id="8fb0773017f88d072a29c4af9bf4189cc9c9a466" translate="yes" xml:space="preserve">
          <source>ISO 8859-1 (Latin-1)</source>
          <target state="translated">ISO 8859-1 (라틴 -1)</target>
        </trans-unit>
        <trans-unit id="58189607ac5de761659ad85bfe08184fa60a5f97" translate="yes" xml:space="preserve">
          <source>ISO codes for country sub-divisions (states, counties, provinces, etc), as defined in ISO 3166-2. This module is not part of the Locale-Codes distribution, but is available from CPAN in CPAN/modules/by-module/Locale/</source>
          <target state="translated">ISO 3166-2에 정의 된 국가 하위 구역 (주, 카운티, 주 등)에 대한 ISO 코드. 이 모듈은 로케일 코드 분배의 일부는 아니지만 CPAN / 모듈 / 모듈 / 로케일 /의 CPAN에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="e2562b9e7af09019f9f6f2808d127ef571d29778" translate="yes" xml:space="preserve">
          <source>ISO-2022-JP-1 (RFC2237) is a superset of ISO-2022-JP (RFC1468) which adds support for JIS X 0212-1990. That means you can use the same code to decode to utf8 but not vice versa.</source>
          <target state="translated">ISO-2022-JP-1 (RFC2237)은 JIS X 0212-1990에 대한 지원을 추가하는 ISO-2022-JP (RFC1468)의 상위 집합입니다. 즉, 동일한 코드를 사용하여 utf8로 디코딩 할 수 있지만 그 반대의 경우는 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="13dc9cc90e3e41be961fd70df5f28ccfd86e620a" translate="yes" xml:space="preserve">
          <source>ISSUES</source>
          <target state="translated">ISSUES</target>
        </trans-unit>
        <trans-unit id="6c84053d4886e789ea8b111c5248970e59a2046c" translate="yes" xml:space="preserve">
          <source>IS_NUMBER_NOT_INT will be set with IS_NUMBER_IN_UV if trailing decimals were seen (in which case *valuep gives the true value truncated to an integer), and IS_NUMBER_NEG if the number is negative (in which case *valuep holds the absolute value). IS_NUMBER_IN_UV is not set if e notation was used or the number is larger than a UV.</source>
          <target state="translated">IS_NUMBER_NOT_INT는 소수점 이하 자릿수가 보이는 경우 IS_NUMBER_IN_UV로 설정되며 (이 경우 * valuep는 정수로 잘린 실제 값을 제공함) 숫자가 음수 인 경우 IS_NUMBER_NEG (이 경우 * valuep는 절대 값을 보유 함)입니다. e 표기법을 사용했거나 숫자가 UV보다 큰 경우 IS_NUMBER_IN_UV는 설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e849c5f96439c1fe622e4ace3225dd079d5ce0bc" translate="yes" xml:space="preserve">
          <source>ITEM</source>
          <target state="translated">ITEM</target>
        </trans-unit>
        <trans-unit id="e98fda145e73c44d41ee1cf81a9942997f60dc03" translate="yes" xml:space="preserve">
          <source>ITEM...</source>
          <target state="translated">ITEM...</target>
        </trans-unit>
        <trans-unit id="81355db038b4c2e62588bc2f02426816803c8b50" translate="yes" xml:space="preserve">
          <source>ITEMHASH</source>
          <target state="translated">ITEMHASH</target>
        </trans-unit>
        <trans-unit id="932eaaf5a36529c34a7868b56cba634f534f39b4" translate="yes" xml:space="preserve">
          <source>IV</source>
          <target state="translated">IV</target>
        </trans-unit>
        <trans-unit id="3776b457f4a64c1c2e929c3beb97e225d7174238" translate="yes" xml:space="preserve">
          <source>Iain Truskett. Updated by the Perl 5 Porters.</source>
          <target state="translated">이언 트루 케트 Perl 5 포터가 업데이트했습니다.</target>
        </trans-unit>
        <trans-unit id="d3280028436889a62f2d1e26e6623a3b63327bf8" translate="yes" xml:space="preserve">
          <source>Idea by Tony Bowden and Paul Johnson, code by Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;, wardrobe by Calvin Klein.</source>
          <target state="translated">Tony Bowden과 Paul Johnson의 아이디어, Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;의 코드, Calvin Klein의 옷장.</target>
        </trans-unit>
        <trans-unit id="38eaa27bde2babc938a1d3f61f24a4c3c9ee9393" translate="yes" xml:space="preserve">
          <source>Ideally, all instances of &lt;code&gt;PL_sub_generation++&lt;/code&gt; in perl source outside of</source>
          <target state="translated">이상적으로 는 펄 소스 에있는 &lt;code&gt;PL_sub_generation++&lt;/code&gt; 의 모든 인스턴스 가</target>
        </trans-unit>
        <trans-unit id="b72ac1e7c6fddbcf97426592a619f53420c1c124" translate="yes" xml:space="preserve">
          <source>Ideally, someone who's slightly familiar with your module should be able to refresh their memory without hitting &quot;page down&quot;. As your reader continues through the document, they should receive a progressively greater amount of knowledge.</source>
          <target state="translated">이상적으로 모듈에 약간 익숙한 사람은 &quot;페이지 다운&quot;을 누르지 않고 메모리를 새로 고칠 수 있어야합니다. 독자가 문서를 계속 읽으면 점차 많은 지식을 얻게됩니다.</target>
        </trans-unit>
        <trans-unit id="71c30d178b22c94b418adae6de96d27ac6651de9" translate="yes" xml:space="preserve">
          <source>Identical to &lt;a href=&quot;#lrint&quot;&gt;lrint&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#lrint&quot;&gt;lrint와&lt;/a&gt; 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="189f7c8820b5d91329256424f9abd34533abf5d2" translate="yes" xml:space="preserve">
          <source>Identical to &lt;code&gt;has_errors&lt;/code&gt; , but also returns true if any TODO tests unexpectedly succeeded. This is more akin to &quot;warnings&quot;.</source>
          <target state="translated">&lt;code&gt;has_errors&lt;/code&gt; 와 동일 하지만 예기치 않은 TODO 테스트가 있으면 true를 리턴합니다. 이것은 &quot;경고&quot;와 더 유사합니다.</target>
        </trans-unit>
        <trans-unit id="725851e6339b491e1de8826e667b9695d8cea364" translate="yes" xml:space="preserve">
          <source>Identical to grok_number_flags() with flags set to zero.</source>
          <target state="translated">플래그가 0으로 설정된 grok_number_flags ()와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="9052a2716f89fc7937386d07b0ec6eb570325f21" translate="yes" xml:space="preserve">
          <source>Identifier parsing</source>
          <target state="translated">식별자 파싱</target>
        </trans-unit>
        <trans-unit id="96bd1c9d626bb40d98db0e06c9d88504407f597b" translate="yes" xml:space="preserve">
          <source>Identifies _POSIX_ARG_MAX as a constant sub, optimized to an IV. Although POSIX isn't entirely consistent across platforms, this is likely to be present in virtually all of them.</source>
          <target state="translated">_POSIX_ARG_MAX를 IV에 최적화 된 상수 서브로 식별합니다. POSIX가 여러 플랫폼에서 완전히 일치하지는 않지만 사실상 모든 플랫폼에 존재할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="651807fc401b8332ec409deb81843bccbd052364" translate="yes" xml:space="preserve">
          <source>Identifies md5 as an XS function. The export is needed so that BC can find it in main.</source>
          <target state="translated">md5를 XS 함수로 식별합니다. BC 주가 주요 수출품을 찾을 수 있도록 수출이 필요하다.</target>
        </trans-unit>
        <trans-unit id="c85a93ef2b6eb1be3e8769838c333c812af4359a" translate="yes" xml:space="preserve">
          <source>Identify a remote machine name. The auto-login process searches the .netrc file for a machine token that matches the remote machine specified. Once a match is made, the subsequent .netrc tokens are processed, stopping when the end of file is reached or an- other machine or a default token is encountered.</source>
          <target state="translated">원격 시스템 이름을 식별하십시오. 자동 로그인 프로세스는 지정된 원격 시스템과 일치하는 시스템 토큰을 .netrc 파일에서 검색합니다. 일치하면 후속 .netrc 토큰이 처리되어 파일 끝에 도달하거나 다른 시스템 또는 기본 토큰에 도달하면 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="ad36a5ddf7af0b9b2aadce75c61491b0c464af3b" translate="yes" xml:space="preserve">
          <source>Identify a user on the remote machine. If this token is present, the auto-login process will initiate a login using the specified name.</source>
          <target state="translated">원격 시스템에서 사용자를 식별하십시오. 이 토큰이 있으면 자동 로그인 프로세스가 지정된 이름을 사용하여 로그인을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="93ca58cc90c1952df3129b0ab2a244d796f9ba81" translate="yes" xml:space="preserve">
          <source>Identify and return the FQDN of the current host.</source>
          <target state="translated">현재 호스트의 FQDN을 식별하고 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="1b3b4987c2d4674f5207d125a1368bf151a6aeb4" translate="yes" xml:space="preserve">
          <source>Identify the C functions which use some inband info as an indication of failure. They may be candidates to return undef or an empty list in case of failure. If the failure may be detected without a call to the C function, you may want to use an INIT: section to report the failure. For failures detectable after the C function returns one may want to use a POSTCALL: section to process the failure. In more complicated cases use CODE: or PPCODE: sections.</source>
          <target state="translated">장애 표시로 일부 대역 정보를 사용하는 C 기능을 식별하십시오. 실패한 경우 undef 또는 빈 목록을 반환 할 수 있습니다. C 함수를 호출하지 않고 실패가 감지되면 INIT : 섹션을 사용하여 실패를보고 할 수 있습니다. C 함수가 리턴 된 후 감지 가능한 실패의 경우 POSTCALL : 섹션을 사용하여 실패를 처리 할 수 ​​있습니다. 더 복잡한 경우에는 CODE : 또는 PPCODE : 섹션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b1d8de6657b1cd9ff03db4bb8c676352163c1ab9" translate="yes" xml:space="preserve">
          <source>Identify the C functions with input/output or output parameters. The XSUBs for these functions may be able to return lists to Perl.</source>
          <target state="translated">입력 / 출력 또는 출력 매개 변수를 사용하여 C 기능을 식별하십시오. 이러한 함수에 대한 XSUB는 목록을 Perl로 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90f84ba2bf147a844b20d38f482ee57bb2e58f7e" translate="yes" xml:space="preserve">
          <source>Identify the pointers in the C function parameter lists and return values. Some pointers may be used to implement input/output or output parameters, they can be handled in XS with the &lt;code&gt;&amp;amp;&lt;/code&gt; unary operator, and, possibly, using the NO_INIT keyword. Some others will require handling of types like &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; *&lt;/code&gt; , and one needs to decide what a useful Perl translation will do in such a case. When the semantic is clear, it is advisable to put the translation into a typemap file.</source>
          <target state="translated">C 함수 매개 변수 목록에서 포인터를 식별하고 값을 리턴하십시오. 일부 포인터는 입력 / 출력 또는 출력 매개 변수를 구현하는 데 사용될 수 있으며 XS에서 &lt;code&gt;&amp;amp;&lt;/code&gt; 단항 연산자를 사용하거나 NO_INIT 키워드를 사용하여 처리 할 수 ​​있습니다 . 다른 것들은 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; *&lt;/code&gt; 와 같은 타입의 처리를 요구할 것이고, 그러한 경우에 유용한 Perl 변환이 무엇을할지 결정해야합니다. 시맨틱이 명확하면 변환을 유형 맵 파일에 넣는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b3f574cc58fec6b5a326569871a9bc4c7e511150" translate="yes" xml:space="preserve">
          <source>Identify the structures used by the C functions. In many cases it may be helpful to use the T_PTROBJ typemap for these structures so they can be manipulated by Perl as blessed objects. (This is handled automatically by &lt;code&gt;h2xs -x&lt;/code&gt; .)</source>
          <target state="translated">C 함수가 사용하는 구조를 식별하십시오. 많은 경우에 이러한 구조에 대해 T_PTROBJ 타입 맵을 사용하는 것이 도움이 될 수 있으므로 Perl에서 축복 된 객체로 조작 할 수 있습니다. 이것은 &lt;code&gt;h2xs -x&lt;/code&gt; 에 의해 자동으로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="7cadfb291553bfe2fe292f1f1bdcc23146b4ce0c" translate="yes" xml:space="preserve">
          <source>Identify which values are used by only the C and XSUB functions themselves, say, when a parameter to a function should be a contents of a global variable. If Perl does not need to access the contents of the value then it may not be necessary to provide a translation for that value from C to Perl.</source>
          <target state="translated">함수의 매개 변수가 전역 변수의 내용이어야하는 경우와 같이 C 및 XSUB 함수 만 사용하는 값을 식별하십시오. Perl이 값의 내용에 액세스 할 필요가 없으면 C에서 Perl로 해당 값에 대한 변환을 제공하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="56f43be29163ab63b1344b6e022e099866950791" translate="yes" xml:space="preserve">
          <source>Identifying DLLs</source>
          <target state="translated">DLL 식별</target>
        </trans-unit>
        <trans-unit id="322518cb4fde79b98b609332667667f3d3c4e560" translate="yes" xml:space="preserve">
          <source>Idhash-based inside-out implementation with explicit object registry. No destructor is needed and objects are thread safe.</source>
          <target state="translated">명시 적 객체 레지스트리를 사용한 Idhash 기반 내부 구현. 소멸자가 필요하지 않으며 객체는 스레드로부터 안전합니다.</target>
        </trans-unit>
        <trans-unit id="bc58745f8a36f6c13d8394fd39a743ccc1e12aee" translate="yes" xml:space="preserve">
          <source>Idhash-based inside-out implementation. Like &lt;code&gt;Name_id&lt;/code&gt; it needs a &lt;code&gt;DESTROY&lt;/code&gt; method and would need &lt;code&gt;CLONE&lt;/code&gt; for thread support.</source>
          <target state="translated">Idhash 기반 내부 구현. 마찬가지로 &lt;code&gt;Name_id&lt;/code&gt; 그것은 필요한 &lt;code&gt;DESTROY&lt;/code&gt; 방법 및 필요 &lt;code&gt;CLONE&lt;/code&gt; 스레드를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="37c8800e90368fca825ac19f3c1c00b3997debbb" translate="yes" xml:space="preserve">
          <source>If $ENV{'PERLIO_DEBUG'} is not set PerlIO_debug() is a no-op.</source>
          <target state="translated">$ ENV { 'PERLIO_DEBUG'}이 설정되지 않은 경우 PerlIO_debug ()는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="34dc71088c30578327b9b7bd86a2add6dfe92c0b" translate="yes" xml:space="preserve">
          <source>If $Term::ANSIColor::AUTOLOCAL is set (see below), it takes precedence over $Term::ANSIColor::AUTORESET, and the latter is ignored.</source>
          <target state="translated">$ Term :: ANSIColor :: AUTOLOCAL이 설정되면 (아래 참조) $ Term :: ANSIColor :: AUTORESET보다 우선하며 후자는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d7df1e43ea1f957f59393ae695f2cf9b6d2d606b" translate="yes" xml:space="preserve">
          <source>If $Term::ANSIColor::AUTOLOCAL is set, each sequence of color constants will be implicitly preceded by LOCALCOLOR. In other words, the following:</source>
          <target state="translated">$ Term :: ANSIColor :: AUTOLOCAL을 설정하면 각 색상 상수 시퀀스에 내재적으로 LOCALCOLOR이옵니다. 다시 말해 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9886d30e7ae4310a71b5b389e615e24f477c9c12" translate="yes" xml:space="preserve">
          <source>If $Term::ANSIColor::AUTOLOCAL is set, it takes precedence over $Term::ANSIColor::AUTORESET, and the latter is ignored.</source>
          <target state="translated">$ Term :: ANSIColor :: AUTOLOCAL이 설정되면 $ Term :: ANSIColor :: AUTORESET보다 우선하며 후자는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="00b4b93a6e7c56aaf9898bc10e1ac72d3a78d804" translate="yes" xml:space="preserve">
          <source>If $base doesn't have a trailing colon, the last element of $base is assumed to be a filename. This filename is ignored. Otherwise all path components are assumed to be directories.</source>
          <target state="translated">$ base에 후행 콜론이 없으면 $ base의 마지막 요소는 파일 이름 인 것으로 가정합니다. 이 파일 이름은 무시됩니다. 그렇지 않으면 모든 경로 구성 요소가 디렉토리 인 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="e44a850613a15c52040db7b75a563e3363f3a945" translate="yes" xml:space="preserve">
          <source>If $base is not present or '', then $base is set to the current working directory. If $base is relative, then it is converted to absolute form using &lt;code&gt;rel2abs()&lt;/code&gt; . This means that it is taken to be relative to the current working directory.</source>
          <target state="translated">$ base가 없거나 ''인 경우 $ base는 현재 작업 디렉토리로 설정됩니다. $ base가 상대적이면 &lt;code&gt;rel2abs()&lt;/code&gt; 사용하여 절대 형식으로 변환됩니다 . 이는 현재 작업 디렉토리와 관련이 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="845e455de01e5f024d6cd4c4973aa19e89db7d23" translate="yes" xml:space="preserve">
          <source>If $base is not present or '', then &lt;a href=&quot;../../cwd&quot;&gt;cwd()&lt;/a&gt; is used. If $base is relative, then it is converted to absolute form using &lt;a href=&quot;#rel2abs()&quot;&gt;rel2abs()&lt;/a&gt;. This means that it is taken to be relative to &lt;a href=&quot;../../cwd&quot;&gt;cwd()&lt;/a&gt;.</source>
          <target state="translated">$ base가 없거나 ''이면 &lt;a href=&quot;../../cwd&quot;&gt;cwd ()&lt;/a&gt; 가 사용됩니다. $ base가 상대적이면 &lt;a href=&quot;#rel2abs()&quot;&gt;rel2abs ()를&lt;/a&gt; 사용하여 절대 형식으로 변환됩니다 . 즉, &lt;a href=&quot;../../cwd&quot;&gt;cwd ()에&lt;/a&gt; 상대적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="b9272bd7bdd63c187d96603ba9d632df6f83a5a3" translate="yes" xml:space="preserve">
          <source>If $base is not present or '', then the current working directory is used. If $base is relative, then it is converted to absolute form using &lt;code&gt;rel2abs()&lt;/code&gt; . This means that it is taken to be relative to the current working directory.</source>
          <target state="translated">$ base가 없거나 ''인 경우 현재 작업 디렉토리가 사용됩니다. $ base가 상대적이면 &lt;code&gt;rel2abs()&lt;/code&gt; 사용하여 절대 형식으로 변환됩니다 . 이는 현재 작업 디렉토리와 관련이 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3eeec7a0508f8bfb175a7dfc1c9f776420700e6b" translate="yes" xml:space="preserve">
          <source>If $chld_out is a string (that is, a bareword filehandle rather than a glob or a reference) and it begins with &lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt;, then the child will send output directly to that file handle. If $chld_in is a string that begins with &lt;code&gt;&amp;lt;&amp;amp;&lt;/code&gt; , then $chld_in will be closed in the parent, and the child will read from it directly. In both cases, there will be a dup(2) instead of a pipe(2) made.</source>
          <target state="translated">$ chld_out이 문자열 (즉, glob 또는 참조가 아닌 베어 워드 파일 핸들)이고 &lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt; 로 시작 하면 자식은 해당 파일 핸들로 직접 출력을 보냅니다. $ chld_in이 &lt;code&gt;&amp;lt;&amp;amp;&lt;/code&gt; 로 시작하는 문자열이면 $ chld_in은 부모에서 닫히고 자식은 직접 읽습니다. 두 경우 모두 pipe (2) 대신 dup (2)이 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="44fc8fa9695e13537785e072991da9317e572016" translate="yes" xml:space="preserve">
          <source>If $device is given, this device is used to bind the source endpoint before sending the ping packet. I believe this only works with superuser privileges and with udp and icmp protocols at this time.</source>
          <target state="translated">$ device가 제공되면이 장치는 ping 패킷을 보내기 전에 소스 엔드 포인트를 바인딩하는 데 사용됩니다. 나는 이것이 현재 수퍼 유저 권한과 udp 및 icmp 프로토콜에서만 작동한다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="c0ccd65f83616cd6cb2edfc67d2ca291d582e3dc" translate="yes" xml:space="preserve">
          <source>If $dont_execute is true it will only print what it was going to do without actually doing it. Default is false.</source>
          <target state="translated">$ dont_execute가 true 인 경우 실제로 수행하지 않고 수행 한 작업 만 인쇄합니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="4487f23cdc43d77eefda03ffdb355fcd16d21554" translate="yes" xml:space="preserve">
          <source>If $dry_run is true it will only print what it was going to do without actually doing it. Default is false.</source>
          <target state="translated">$ dry_run이 true 인 경우 실제로 수행하지 않고 수행 한 작업 만 인쇄합니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="18c02a1762fa9a8596890767dac4fd996ccee7b8" translate="yes" xml:space="preserve">
          <source>If $file is not given, output goes to STDOUT.</source>
          <target state="translated">$ file을 지정하지 않으면 출력은 STDOUT으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="d0d307167134c6f267f7b1e5ea27d0a25a9d1edd" translate="yes" xml:space="preserve">
          <source>If $lang1 is not a valid language tag, returns empty-list in a list context, undef in a scalar context.</source>
          <target state="translated">$ lang1이 유효한 언어 태그가 아닌 경우 스칼라 컨텍스트에서 undef로 목록 컨텍스트에서 빈 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5ee23960e33f02c0ec76877b3b88bcea62b52eb5" translate="yes" xml:space="preserve">
          <source>If $options{allow_variables} is true it will leave &lt;code&gt;'$(FOO)'&lt;/code&gt; make variables untouched. If false they will be escaped like any other &lt;code&gt;$&lt;/code&gt; . Defaults to true.</source>
          <target state="translated">$ options {allow_variables}가 true이면 &lt;code&gt;'$(FOO)'&lt;/code&gt; 는 변수를 건드리지 않습니다. 거짓이면 다른 &lt;code&gt;$&lt;/code&gt; 처럼 이스케이프됩니다 . 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="7e4290bb3a94a4f28c693632b42d671f5b272d5b" translate="yes" xml:space="preserve">
          <source>If $opts{allow_variables} is true, make variables of the form &lt;code&gt;$(...)&lt;/code&gt; will not be escaped. Other &lt;code&gt;$&lt;/code&gt; will. Default is to escape all &lt;code&gt;$&lt;/code&gt; .</source>
          <target state="translated">$ opts {allow_variables}가 true이면 &lt;code&gt;$(...)&lt;/code&gt; 형식의 변수를 이스케이프 처리하지 마십시오. 다른 &lt;code&gt;$&lt;/code&gt; will. 기본값은 모든 &lt;code&gt;$&lt;/code&gt; 를 이스케이프하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="855199c44e171a04babf60aa36fe8d5f139967b6" translate="yes" xml:space="preserve">
          <source>If $opts{append} is true the $file will be appended to rather than overwritten. Default is to overwrite.</source>
          <target state="translated">$ opts {append}가 true 인 경우 $ file은 덮어 쓰지 않고 추가됩니다. 기본값은 덮어 쓰기입니다.</target>
        </trans-unit>
        <trans-unit id="6f940e23e748b82cd99453c8e14fb88e03638ce9" translate="yes" xml:space="preserve">
          <source>If $path and $base appear to be on two different volumes, we will not attempt to resolve the two paths, and we will instead simply return $path. Note that previous versions of this module ignored the volume of $base, which resulted in garbage results part of the time.</source>
          <target state="translated">$ path와 $ base가 서로 다른 두 볼륨에있는 경우 두 경로를 확인하지 않고 대신 $ path를 반환합니다. 이 모듈의 이전 버전은 $ base의 볼륨을 무시하여 시간의 일부 가비지 결과를 초래했습니다.</target>
        </trans-unit>
        <trans-unit id="850236350e7bb82f14f3904d51572fc6195796da" translate="yes" xml:space="preserve">
          <source>If $path is absolute, it is cleaned up and returned using &lt;a href=&quot;#canonpath()&quot;&gt;canonpath()&lt;/a&gt;.</source>
          <target state="translated">$ path가 절대이면 &lt;a href=&quot;#canonpath()&quot;&gt;canonpath ()를&lt;/a&gt; 사용하여 정리되고 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="8dd162a4e3a5b7fb03319f43889033f3ce26c0ac" translate="yes" xml:space="preserve">
          <source>If $path is already absolute, it is returned and $base is ignored.</source>
          <target state="translated">$ path가 이미 절대이면 반환되고 $ base는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="777c7fd35866ed59635fd89f40d3d520a0dbf9c9" translate="yes" xml:space="preserve">
          <source>If $path is relative, it is converted to absolute form using &lt;a href=&quot;#rel2abs()&quot;&gt;rel2abs()&lt;/a&gt;. This means that it is taken to be relative to &lt;a href=&quot;../../cwd&quot;&gt;cwd()&lt;/a&gt;.</source>
          <target state="translated">$ path가 상대적이면 &lt;a href=&quot;#rel2abs()&quot;&gt;rel2abs ()를&lt;/a&gt; 사용하여 절대 형식으로 변환됩니다 . 즉, &lt;a href=&quot;../../cwd&quot;&gt;cwd ()에&lt;/a&gt; 상대적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7ca3a7041ed2c9c63e8a6e3a8ccf54b7c562514d" translate="yes" xml:space="preserve">
          <source>If $path is relative, it is converted to absolute form using &lt;code&gt;rel2abs()&lt;/code&gt; . This means that it is taken to be relative to the current working directory.</source>
          <target state="translated">$ path가 상대적이면 &lt;code&gt;rel2abs()&lt;/code&gt; 사용하여 절대 형식으로 변환됩니다 . 이는 현재 작업 디렉토리와 관련이 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5254527bc2e7fffb01bf04870bf9b3803ac84a3a" translate="yes" xml:space="preserve">
          <source>If $skip is undefined then the skip file will be autodetected and used if it is found. If $skip is a reference to an array then it is assumed the array contains the list of patterns, if $skip is a true non reference it is assumed to be the filename holding the list of patterns, any other value of $skip is taken to mean that no install filtering should occur.</source>
          <target state="translated">$ skip이 정의되어 있지 않으면 건너 뛰기 파일이 자동 감지되어 발견되면 사용됩니다. $ skip이 배열에 대한 참조 인 경우 배열에 패턴 목록이 포함되어 있다고 가정하고 $ skip가 참 비 참조 인 경우 패턴 목록을 보유한 파일 이름으로 간주되며 $ skip의 다른 값을 가져옵니다 설치 필터링이 발생하지 않아야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8fa5810ef2976d0d9f6da3cb5784a5117836d30e" translate="yes" xml:space="preserve">
          <source>If $tos is given, this ToS is configured into the socket.</source>
          <target state="translated">$ tos가 주어지면이 ToS가 소켓에 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="92f994b9259d086e448ddc0c57c689110cb3a4ae" translate="yes" xml:space="preserve">
          <source>If $uninstall_shadows is true any differing versions throughout @INC will be uninstalled. This is &quot;make install UNINST=1&quot;</source>
          <target state="translated">$ uninstall_shadows가 true이면 @INC 전체의 다른 버전이 제거됩니다. &quot;UNINST = 1 설치&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="d25dc89b5c8f1043b2555a0a5b1ef64713bc4410" translate="yes" xml:space="preserve">
          <source>If $verbose is true, will print out each file removed. Default is false.</source>
          <target state="translated">$ verbose가 true이면 제거 된 각 파일을 인쇄합니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="bcca2238b940008ca2f6edea6b116ca4f08340a0" translate="yes" xml:space="preserve">
          <source>If $verbose is true, will print out each file removed. Default is false. This is &quot;make install VERBINST=1&quot;. $verbose values going up to 5 show increasingly more diagnostics output.</source>
          <target state="translated">$ verbose가 true이면 제거 된 각 파일을 인쇄합니다. 기본값은 false입니다. 이것은 &quot;make install VERBINST = 1&quot;입니다. 5까지 올라가는 $ verbose 값은 점점 더 많은 진단 결과를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="fe6210a09cf838e292147ff60a09be55f53fc7bf" translate="yes" xml:space="preserve">
          <source>If 'pattern' is an empty string, the last</source>
          <target state="translated">'pattern'이 빈 문자열이면 마지막</target>
        </trans-unit>
        <trans-unit id="1ce161c1d1a95615015e87f6deb5c4e15fba876e" translate="yes" xml:space="preserve">
          <source>If 0, allows</source>
          <target state="translated">0이면 허용</target>
        </trans-unit>
        <trans-unit id="e3e28f04766a1a5f37a30a978712cb8019a0f8ec" translate="yes" xml:space="preserve">
          <source>If 0, perl ignores setlocale() failing. May be useful with some strange</source>
          <target state="translated">0이면 perl은 setlocale () 실패를 무시합니다. 이상하게도 유용 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0fcc1cd2f54ca974c2f03b70436631faa5fcbfff" translate="yes" xml:space="preserve">
          <source>If 0, perl would not warn of in case of unwarranted free(). With older perls this might be useful in conjunction with the module DB_File, which was buggy when dynamically linked and OMF-built.</source>
          <target state="translated">0이면, 펄은 보증되지 않은 free ()의 경우 경고하지 않습니다. 이전 perls에서는 동적으로 링크되고 OMF로 빌드 될 때 버그가있는 DB_File 모듈과 함께 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0184b287a86a499460e472243734776163d62a28" translate="yes" xml:space="preserve">
          <source>If 0, then you have specified the G_DISCARD flag.</source>
          <target state="translated">0이면 G_DISCARD 플래그를 지정했습니다.</target>
        </trans-unit>
        <trans-unit id="59622b7a1ad0df9c79750964aae25dbf7a4a54d5" translate="yes" xml:space="preserve">
          <source>If 1, then the item actually returned by the Perl subroutine will be stored on the Perl stack - the section</source>
          <target state="translated">1이면 Perl 서브 루틴이 실제로 리턴 한 항목은 Perl 스택에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="dea4460b4f37611ed7726bdc86a6a203f8857086" translate="yes" xml:space="preserve">
          <source>If 1. and 2. didn't work, the environment variables &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LANG&lt;/code&gt; (in that order) are matched for anything looking like UTF-8, and if any found, &lt;code&gt;:utf8&lt;/code&gt; is used as the default encoding for the open pragma.</source>
          <target state="translated">1과 2가 작동하지 않으면 환경 변수 &lt;code&gt;LC_ALL&lt;/code&gt; 과 &lt;code&gt;LANG&lt;/code&gt; (순서대로)가 UTF-8과 같은 것으로 일치하며, 발견되면 &lt;code&gt;:utf8&lt;/code&gt; 이 열린 pragma의 기본 인코딩으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="564ba04f0c77bd18f1de6b5d8d1c4de41e90203f" translate="yes" xml:space="preserve">
          <source>If 1. didn't work but we are under the locale pragma, the environment variables &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LANG&lt;/code&gt; (in that order) are matched for encodings (the part after &quot;&lt;code&gt;.&lt;/code&gt;&quot;, if any), and if any found, that is used as the default encoding for the open pragma.</source>
          <target state="translated">1. 작동하지 않지만 로케일 pragma 아래에있는 경우 환경 변수 &lt;code&gt;LC_ALL&lt;/code&gt; 및 &lt;code&gt;LANG&lt;/code&gt; (순서대로)는 인코딩 ( &quot; &lt;code&gt;.&lt;/code&gt; &quot; 뒤에있는 부분 )과 찾은 경우 사용됩니다. 열린 pragma의 기본 인코딩으로.</target>
        </trans-unit>
        <trans-unit id="5cc7e264f1e9eeedc8d7e2b14c1a68dd77cae7b4" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;PL_parser-&amp;gt;bufptr&lt;/a&gt; is pointing to the very end of the current chunk (i.e., the current chunk has been entirely consumed), normally the current chunk will be discarded at the same time that the new chunk is read in. If</source>
          <target state="translated">&lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;PL_parser-&amp;gt; bufptr&lt;/a&gt; 이 현재 청크의 맨 끝을 가리키는 경우 (즉, 현재 청크가 완전히 소비 된 경우) 일반적으로 현재 청크는 새 청크를 읽을 때 동시에 폐기됩니다.</target>
        </trans-unit>
        <trans-unit id="baa00f7897b1c66fe0a596f5bb93527533128be4" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../../term/ansicolor&quot;&gt;Term::ANSIColor&lt;/a&gt; cannot be found (or &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Console&quot;&gt;Win32::Console&lt;/a&gt; if running under Windows) tests will be run without color.</source>
          <target state="translated">경우 &lt;a href=&quot;../../term/ansicolor&quot;&gt;기간 : ANSIColor가&lt;/a&gt; (또는 찾을 수 없습니다 &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Console&quot;&gt;에서 Win32 : 콘솔&lt;/a&gt; 윈도우에서 실행되는 경우) 테스트는 색상없이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="42a72e58cfc32531fbd4fab5178d34e628485bf7" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../cpan/meta&quot;&gt;CPAN::Meta&lt;/a&gt; is installed, MakeMaker will automatically generate</source>
          <target state="translated">경우 &lt;a href=&quot;../cpan/meta&quot;&gt;CPAN :: 메타가&lt;/a&gt; 설치되어 MakeMaker가 자동으로 생성됩니다</target>
        </trans-unit>
        <trans-unit id="108eca6848696cd0de287a231d549cff82edd6aa" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;-t&lt;/b&gt; is given, &lt;b&gt;pod2text&lt;/b&gt; will take the current width of your screen from this environment variable, if available. It overrides terminal width information in TERMCAP.</source>
          <target state="translated">경우 &lt;b&gt;-t가&lt;/b&gt; 주어집니다, &lt;b&gt;pod2text이&lt;/b&gt; 가능한 경우,이 환경 변수에서 화면의 현재 너비를 취할 것입니다. TERMCAP의 터미널 너비 정보를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="fc2c6665b79caef5aa91e98d089e901b7263b1c2" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;-t&lt;/b&gt; is given, &lt;b&gt;pod2text&lt;/b&gt; will use the contents of this environment variable if available to determine the correct formatting sequences for your current terminal device.</source>
          <target state="translated">경우 &lt;b&gt;-t가&lt;/b&gt; 주어집니다, &lt;b&gt;pod2text이&lt;/b&gt; 가능한 현재의 터미널 장치에 대한 올바른 형식의 순서를 결정하는 경우이 환경 변수의 내용을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9c867f84603d2f4182710d040ee18f9885c092cc" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;Locale::Maketext::Lexicon&lt;/b&gt; is not present, it implements a minimal localization function by simply interpolating &lt;code&gt;[_1]&lt;/code&gt; with the first argument, &lt;code&gt;[_2]&lt;/code&gt; with the second, etc. Interpolated function like &lt;code&gt;[quant,_1]&lt;/code&gt; are treated as &lt;code&gt;[_1]&lt;/code&gt; , with the sole exception of &lt;code&gt;[tense,_1,X]&lt;/code&gt; , which will append &lt;code&gt;ing&lt;/code&gt; to &lt;code&gt;_1&lt;/code&gt; when X is &lt;code&gt;present&lt;/code&gt; , or appending &lt;code&gt;ed&lt;/code&gt; to &amp;lt;_1&amp;gt; otherwise.</source>
          <target state="translated">경우 &lt;b&gt;로케일 :: Maketext :: 어휘집이&lt;/b&gt; 없는, 단순히 보간함으로써 최소 파악 기능을 구현 &lt;code&gt;[_1]&lt;/code&gt; 첫번째 인수 &lt;code&gt;[_2]&lt;/code&gt; 등 등 번째 보간 함수 &lt;code&gt;[quant,_1]&lt;/code&gt; 로 처리 &lt;code&gt;[_1]&lt;/code&gt; , 유일한 예외 &lt;code&gt;[tense,_1,X]&lt;/code&gt; 추가합니다, &lt;code&gt;ing&lt;/code&gt; 에 &lt;code&gt;_1&lt;/code&gt; X 인 경우 &lt;code&gt;present&lt;/code&gt; 또는 추가 &lt;code&gt;ed&lt;/code&gt; 에 &amp;lt;_1&amp;gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="3079127a0d6aa2996f8f83dac436403e0868d7e3" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;all&lt;/b&gt; of these are the case, then you need to set the &lt;code&gt;$eof&lt;/code&gt; parameter to true on the final call (and only the final call) to &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; .</source>
          <target state="translated">이 &lt;b&gt;모든&lt;/b&gt; 경우 에 해당하는 경우 최종 호출 (최종 호출 만)에서 &lt;code&gt;$eof&lt;/code&gt; 매개 변수를 &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="1304e40e4e83fe3d3333f01173ec1c6d1e1c6f99" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;pod2man&lt;/b&gt; fails with errors, see &lt;a href=&quot;pod/man&quot;&gt;Pod::Man&lt;/a&gt; and &lt;a href=&quot;pod/simple&quot;&gt;Pod::Simple&lt;/a&gt; for information about what those errors might mean.</source>
          <target state="translated">경우 &lt;b&gt;pod2man이&lt;/b&gt; 오류와 함께 실패를 참조 &lt;a href=&quot;pod/man&quot;&gt;포드 :: 남자&lt;/a&gt; 와 &lt;a href=&quot;pod/simple&quot;&gt;포드 :: 간단한&lt;/a&gt; 이러한 오류는 의미 할 수 있습니다 무엇에 대한 정보를.</target>
        </trans-unit>
        <trans-unit id="f4176eb0fb0948998c97b4edf835cbf5dcd8f3b5" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;pod2text&lt;/b&gt; fails with errors, see &lt;a href=&quot;pod/text&quot;&gt;Pod::Text&lt;/a&gt; and &lt;a href=&quot;pod/simple&quot;&gt;Pod::Simple&lt;/a&gt; for information about what those errors might mean. Internally, it can also produce the following diagnostics:</source>
          <target state="translated">경우 &lt;b&gt;pod2text이&lt;/b&gt; 오류와 함께 실패를 참조 &lt;a href=&quot;pod/text&quot;&gt;포드 :: 텍스트&lt;/a&gt; 와 &lt;a href=&quot;pod/simple&quot;&gt;포드 :: 간단한&lt;/a&gt; 이러한 오류는 의미 할 수 있습니다 무엇에 대한 정보를. 내부적으로 다음 진단을 생성 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="988f5c207e367599a6818bf91e93811516af5517" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&quot;/&quot;&lt;/code&gt; is the delimiter then the initial &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; is optional. With the &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; you can use any pair of non-whitespace (ASCII) characters as delimiters. This is particularly useful for matching path names that contain &lt;code&gt;&quot;/&quot;&lt;/code&gt; , to avoid LTS (leaning toothpick syndrome). If &lt;code&gt;&quot;?&quot;&lt;/code&gt; is the delimiter, then a match-only-once rule applies, described in &lt;code&gt;m?&lt;i&gt;PATTERN&lt;/i&gt;?&lt;/code&gt; below. If &lt;code&gt;&quot;'&quot;&lt;/code&gt; (single quote) is the delimiter, no interpolation is performed on the</source>
          <target state="translated">경우 &lt;code&gt;&quot;/&quot;&lt;/code&gt; 구분 기호는 다음 초기 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 은 선택 사항입니다. 으로 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 당신은 공백이 아닌 (ASCII)를 분리 문자로 문자의 쌍을 사용할 수 있습니다. 이것은 LTS (lean toothpick syndrome)를 피하기 위해 &lt;code&gt;&quot;/&quot;&lt;/code&gt; 가 포함 된 경로 이름을 일치시키는 데 특히 유용합니다 . 만약 &lt;code&gt;&quot;?&quot;&lt;/code&gt; 구분 기호는 다음과 같습니다. &lt;code&gt;m?&lt;i&gt;PATTERN&lt;/i&gt;?&lt;/code&gt; 설명 된 일치 전용 규칙이 적용 됩니까? &lt;i&gt;패턴&lt;/i&gt; ? 이하. 경우 &lt;code&gt;&quot;'&quot;&lt;/code&gt; (따옴표)가 구분 기호, 더 보간이 수행되지 않습니다</target>
        </trans-unit>
        <trans-unit id="4134f85a82aca95ee568f43289ebb0ed4545d2aa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$@&lt;/code&gt; is empty then the string &lt;code&gt;&quot;Died&quot;&lt;/code&gt; is used.</source>
          <target state="translated">경우 &lt;code&gt;$@&lt;/code&gt; 다음 문자열 비어 &lt;code&gt;&quot;Died&quot;&lt;/code&gt; 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f1898954d30bb03694346f5c287c1a5d39827435" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$@&lt;/code&gt; is empty then the string &lt;code&gt;&quot;Warning: Something's wrong&quot;&lt;/code&gt; is used.</source>
          <target state="translated">경우 &lt;code&gt;$@&lt;/code&gt; 다음 문자열 비어 &lt;code&gt;&quot;Warning: Something's wrong&quot;&lt;/code&gt; 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8349dcfb4261ce55d683cb8a5fd2171cf0fa3a9f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$Storable::Deparse&lt;/code&gt; and/or &lt;code&gt;$Storable::Eval&lt;/code&gt; are set to false values, then the value of &lt;code&gt;$Storable::forgive_me&lt;/code&gt; (see below) is respected while serializing and deserializing.</source>
          <target state="translated">경우 &lt;code&gt;$Storable::Deparse&lt;/code&gt; 및 / 또는 &lt;code&gt;$Storable::Eval&lt;/code&gt; 잘못된 값으로 설정되어, 다음의 값 &lt;code&gt;$Storable::forgive_me&lt;/code&gt; 직렬화 및 역 직렬화하는 동안 (아래 참조)를 존중한다.</target>
        </trans-unit>
        <trans-unit id="e98020b671aa605e805711cb6bc682413e70f748" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$_&lt;/code&gt; is lexical in the scope where the &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; appears (because it has been declared with the deprecated &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; construct) then, in addition to being locally aliased to the list elements, &lt;code&gt;$_&lt;/code&gt; keeps being lexical inside the block; i.e., it can't be seen from the outside, avoiding any potential side-effects.</source>
          <target state="translated">경우 &lt;code&gt;$_&lt;/code&gt; 상기 범위 어휘이다 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 나타난다는 (그것이되지 선언 되었기 때문에 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; 로컬 목록 요소 별명되는 것에 더하여, 다음 구조) &lt;code&gt;$_&lt;/code&gt; 블록 내부 어휘 인 유지; 즉, 잠재적 부작용을 피하면서 외부에서 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4f7113393512805f0f59fa7b96e8b849e1995d1c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$_&lt;/code&gt; is lexical in the scope where the &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; appears (because it has been declared with the deprecated &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; construct), then, in addition to being locally aliased to the list elements, &lt;code&gt;$_&lt;/code&gt; keeps being lexical inside the block; that is, it can't be seen from the outside, avoiding any potential side-effects.</source>
          <target state="translated">경우 &lt;code&gt;$_&lt;/code&gt; 하여 범위 어휘이다 &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 나타납니다이 (가되지 않는 선언되어 있기 때문에 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; , 로컬리스트 요소 별칭 될뿐만 아니라, 다음, 구조) &lt;code&gt;$_&lt;/code&gt; 블록 내부의 어휘있는 유지; 즉, 잠재적 부작용을 피하면서 외부에서 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cb93a45a461425fe55c63aa4556c32605c5c3edf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$_&lt;/code&gt; is lexical in the scope where the &lt;code&gt;&lt;a href=&quot;grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; appears (because it has been declared with the deprecated &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; construct) then, in addition to being locally aliased to the list elements, &lt;code&gt;$_&lt;/code&gt; keeps being lexical inside the block; i.e., it can't be seen from the outside, avoiding any potential side-effects.</source>
          <target state="translated">경우 &lt;code&gt;$_&lt;/code&gt; 상기 범위 어휘이다 &lt;code&gt;&lt;a href=&quot;grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 나타난다는 (그것이되지 선언 되었기 때문에 &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; 로컬 목록 요소 별명되는 것에 더하여, 다음 구조) &lt;code&gt;$_&lt;/code&gt; 블록 내부 어휘 인 유지; 즉, 잠재적 부작용을 피하면서 외부에서 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="25899b6abc79ff8d8c10640cbdc4955bb3e63743" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$_&lt;/code&gt; is lexical in the scope where the &lt;code&gt;&lt;a href=&quot;map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; appears (because it has been declared with the deprecated &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; construct), then, in addition to being locally aliased to the list elements, &lt;code&gt;$_&lt;/code&gt; keeps being lexical inside the block; that is, it can't be seen from the outside, avoiding any potential side-effects.</source>
          <target state="translated">경우 &lt;code&gt;$_&lt;/code&gt; 하여 범위 어휘이다 &lt;code&gt;&lt;a href=&quot;map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 나타납니다이 (가되지 않는 선언되어 있기 때문에 &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; , 로컬리스트 요소 별칭 될뿐만 아니라, 다음, 구조) &lt;code&gt;$_&lt;/code&gt; 블록 내부의 어휘있는 유지; 즉, 잠재적 부작용을 피하면서 외부에서 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2bf18bea13d8e6a37cbbcfdc3ed1634945661fd3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; are scalars then after these statements</source>
          <target state="translated">경우 &lt;code&gt;$a&lt;/code&gt; 와 &lt;code&gt;$b&lt;/code&gt; 스칼라는이 문 다음에 다음이다</target>
        </trans-unit>
        <trans-unit id="92cf042152ebf0550f54e6d7d3ad9a3448e3c104" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$a&lt;/code&gt; pointed to an array of two elements then we would see the following.</source>
          <target state="translated">경우 &lt;code&gt;$a&lt;/code&gt; 두 요소의 배열에 대한 지적은 우리는 다음을 볼 것입니다.</target>
        </trans-unit>
        <trans-unit id="fee2f2e0ebac86e4349ab49b826ea37defd988af" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$aref&lt;/code&gt; holds a reference to an array, then &lt;code&gt;$aref-&amp;gt;[3]&lt;/code&gt; is the fourth element of the array. Don't confuse this with &lt;code&gt;$aref[3]&lt;/code&gt; , which is the fourth element of a totally different array, one deceptively named &lt;code&gt;@aref&lt;/code&gt; . &lt;code&gt;$aref&lt;/code&gt; and &lt;code&gt;@aref&lt;/code&gt; are unrelated the same way that &lt;code&gt;$item&lt;/code&gt; and &lt;code&gt;@item&lt;/code&gt; are.</source>
          <target state="translated">&lt;code&gt;$aref&lt;/code&gt; 가 배열에 대한 참조를 보유 하면 $ aref- &lt;code&gt;$aref-&amp;gt;[3]&lt;/code&gt; 은 배열의 네 번째 요소입니다. 이것을 &lt;code&gt;@aref&lt;/code&gt; 라고하는 완전히 다른 배열의 네 번째 요소 인 &lt;code&gt;$aref[3]&lt;/code&gt; 와 혼동하지 마십시오 . &lt;code&gt;$aref&lt;/code&gt; 와 &lt;code&gt;@aref&lt;/code&gt; 는 &lt;code&gt;$item&lt;/code&gt; 과 &lt;code&gt;@item&lt;/code&gt; 과 같은 방식으로 관련이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="de74274409753dd786fd5d63e5d1412ca957382c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$base&lt;/code&gt; is not defined, Euler's number (e) is used:</source>
          <target state="translated">&lt;code&gt;$base&lt;/code&gt; 가 정의되지 않은 경우 오일러 번호 (e)가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0050f172fa605210fb670bacd9e4150d6ef91f04" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$base&lt;/code&gt; is not present or '', then &lt;a href=&quot;../cwd&quot;&gt;Cwd::cwd()&lt;/a&gt; is used. If &lt;code&gt;$base&lt;/code&gt; is relative, then it is converted to absolute form using &lt;a href=&quot;#rel2abs()&quot;&gt;rel2abs()&lt;/a&gt;. This means that it is taken to be relative to &lt;a href=&quot;../cwd&quot;&gt;Cwd::cwd()&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;$base&lt;/code&gt; ''존재 여부이며, 다음 &lt;a href=&quot;../cwd&quot;&gt;CWD : CWD ()이&lt;/a&gt; 사용된다. 경우 &lt;code&gt;$base&lt;/code&gt; 상대적 후이를 이용하여 절대 형태로 전환된다 &lt;a href=&quot;#rel2abs()&quot;&gt;rel2abs을 ()&lt;/a&gt; . 이것은 &lt;a href=&quot;../cwd&quot;&gt;Cwd :: cwd ()에&lt;/a&gt; 상대적인 것으로 간주됨을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="7addd5930cc7a5f994dbe5d5d02d12cbcde98a29" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$buffer&lt;/code&gt; consists of multiple concatenated gzip data streams only the first will be uncompressed. Use &lt;code&gt;gunzip&lt;/code&gt; with the &lt;code&gt;MultiStream&lt;/code&gt; option in the &lt;code&gt;IO::Uncompress::Gunzip&lt;/code&gt; module if you need to deal with concatenated data streams.</source>
          <target state="translated">&lt;code&gt;$buffer&lt;/code&gt; 가 여러 개의 연결된 gzip 데이터 스트림으로 구성된 경우 첫 번째 만 압축 해제됩니다. 연결된 데이터 스트림을 처리해야하는 경우 &lt;code&gt;IO::Uncompress::Gunzip&lt;/code&gt; 모듈 의 &lt;code&gt;MultiStream&lt;/code&gt; 옵션 과 함께 &lt;code&gt;gunzip&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c05ab0710c330ccfa58b05a1d99cb1930161cb6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$fh&lt;/code&gt; is a filehandle, such as is returned by &lt;code&gt;IO::File&lt;/code&gt; or one of the other &lt;code&gt;IO&lt;/code&gt; modules, you may use:</source>
          <target state="translated">경우 &lt;code&gt;$fh&lt;/code&gt; 같은 의해 반환되는 파일 핸들입니다 &lt;code&gt;IO::File&lt;/code&gt; 또는 다른 하나의 &lt;code&gt;IO&lt;/code&gt; 모듈, 당신은 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="80cddfe7cac5da52e604c2e95ecabe44db020236" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$id&lt;/code&gt; is the id of a registered object (see &lt;a href=&quot;#register&quot;&gt;register&lt;/a&gt;), returns the object, otherwise an undefined value. For registered objects this is the inverse function of &lt;code&gt;id()&lt;/code&gt; .</source>
          <target state="translated">경우 &lt;code&gt;$id&lt;/code&gt; (참조 등록 된 오브젝트의 ID 인 &lt;a href=&quot;#register&quot;&gt;등록&lt;/a&gt; ), 오브젝트 달리 정의되지 않은 값을 반환한다. 등록 된 객체의 경우 이것은 &lt;code&gt;id()&lt;/code&gt; 의 역함수 입니다.</target>
        </trans-unit>
        <trans-unit id="cc434bb4b25d64e8d72b26a1167930b8ab9c02ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input&lt;/code&gt; is a scalar reference, the compressed data will be read from &lt;code&gt;$$input&lt;/code&gt; .</source>
          <target state="translated">경우 &lt;code&gt;$input&lt;/code&gt; 스칼라 기준이고, 상기 압축 된 데이터로부터 판독한다 &lt;code&gt;$$input&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1deee19e273a335c0c4f6a1643abcff33ad56b8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a scalar reference, the input data will be read from &lt;code&gt;$$input_filename_or_reference&lt;/code&gt; .</source>
          <target state="translated">경우 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 스칼라 기준이며, 입력 데이터로부터 판독한다 &lt;code&gt;$$input_filename_or_reference&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="442fe7b0ca25d4c885c4e854d9668346a5bb7269" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;anyinflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$input_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;문자로 구분 된 문자열 인 경우 &lt;code&gt;anyinflate&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="9aa314fdcd8580313e8abf8e02f29427ab27b460" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;anyuncompress&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$input_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;문자로 구분 된 문자열 인 경우 &lt;code&gt;anyuncompress&lt;/code&gt; 은 문자열 이</target>
        </trans-unit>
        <trans-unit id="18a54dcb23d30a160237fad9927225b0b52fd938" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;bunzip2&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$input_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;문자로 구분 된 문자열 인 경우 &lt;code&gt;bunzip2&lt;/code&gt; 는 다음과 같이 가정합니다.</target>
        </trans-unit>
        <trans-unit id="2674b9a8665c681ee519359fca9a33d0c649f2e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;bzip2&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$input_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;문자로 구분 된 문자열 인 경우 &lt;code&gt;bzip2&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="8d40f68b3835780881ecdd758b0745e5d0346006" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;deflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$input_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;문자로 구분 된 문자열 인 경우 &lt;code&gt;deflate&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="4fe4284a3754ea968d5efe965b410a0bdc45da42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;gunzip&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$input_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;문자로 구분 된 문자열 인 경우 &lt;code&gt;gunzip&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="54bfc13f24ab6d2f1fe87f0e4095f9cb61a84059" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;gzip&lt;/code&gt; will assume that it is an</source>
          <target state="translated">경우 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 문자로 구분되는 문자열 인 &quot;&amp;lt;&quot;와 &quot;&amp;gt;&quot; &lt;code&gt;gzip&lt;/code&gt; 그것이이 있다고 가정합니다</target>
        </trans-unit>
        <trans-unit id="9bc5cf10f5ea974c9dba92b8ddcdee6c56efe154" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;inflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">경우 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 문자로 구분되는 문자열 인 &quot;&amp;lt;&quot;와 &quot;&amp;gt;&quot; &lt;code&gt;inflate&lt;/code&gt; 그것이이 있다고 가정합니다</target>
        </trans-unit>
        <trans-unit id="8e074643e90fcbea02cb6c241eab28946a00d829" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;rawdeflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$input_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;문자로 구분 된 문자열 인 경우 &lt;code&gt;rawdeflate&lt;/code&gt; 는 문자열 이</target>
        </trans-unit>
        <trans-unit id="c17eec5153adb41349f1323f8a2716fe9be3d4a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;rawinflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$input_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;문자로 구분 된 문자열 인 경우 &lt;code&gt;rawinflate&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="4ab52d4fbbd216b398b3cd45ad27a194f5b5a84f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;unzip&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$input_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;문자로 구분 된 문자열 인 경우 &lt;code&gt;unzip&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="35a8f72eaee6c21d9a2ad219023a7a4de0558584" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;zip&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$input_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;문자로 구분 된 문자열 인 경우 &lt;code&gt;zip&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="2e1657129b850f80b9a61087ceca9451d92c60dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is an array reference, each element in the array must be a filename.</source>
          <target state="translated">&lt;code&gt;$input_filename_or_reference&lt;/code&gt; 경우 배열 참조는, 어레이의 각 요소는 이름이어야한다.</target>
        </trans-unit>
        <trans-unit id="9bbc80ca8dd7a56323169258329eaced7ec9500d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$n&lt;/code&gt; is negative, returns the digit counting from left.</source>
          <target state="translated">경우 &lt;code&gt;$n&lt;/code&gt; , 음수 왼쪽에서 숫자 계산을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="320bf336e74d67e7ea69246db25f2a4bdd482c4d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$num_tests&lt;/code&gt; is omitted, the number of tests run will be used, like no_plan.</source>
          <target state="translated">경우 &lt;code&gt;$num_tests&lt;/code&gt; 생략, 테스트의 수는 no_plan처럼 사용됩니다 실행합니다.</target>
        </trans-unit>
        <trans-unit id="2d1acd93b6a6ef1f8b92bfb6d087b55815058f80" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output&lt;/code&gt; is a buffer and &lt;code&gt;Append&lt;/code&gt; is enabled, all compressed data will be append to the end of &lt;code&gt;$output&lt;/code&gt; . Otherwise &lt;code&gt;$output&lt;/code&gt; will be cleared before any data is written to it.</source>
          <target state="translated">경우 &lt;code&gt;$output&lt;/code&gt; 버퍼이며 &lt;code&gt;Append&lt;/code&gt; 활성화되어, 모든 압축 된 데이터의 끝에 추가 될 것이다 &lt;code&gt;$output&lt;/code&gt; . 그렇지 않으면 데이터가 기록되기 전에 &lt;code&gt;$output&lt;/code&gt; 이 지워집니다.</target>
        </trans-unit>
        <trans-unit id="e8582554c9105fe0c715aaa06eeaea2d3fcfc688" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output&lt;/code&gt; is a file or a filehandle, it must be seekable.</source>
          <target state="translated">경우 &lt;code&gt;$output&lt;/code&gt; 파일이나 파일 핸들을, 그것은 시크해야합니다.</target>
        </trans-unit>
        <trans-unit id="430d11ebbae99eabba1b751c1fb7c8e38808dc22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output&lt;/code&gt; is a filehandle, the file pointer will be positioned to the end of the file via a call to &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; before any compressed data is written to it. Otherwise the file pointer will not be moved.</source>
          <target state="translated">경우 &lt;code&gt;$output&lt;/code&gt; 파일 핸들입니다 파일 포인터에 대한 호출을 통해 파일의 끝에 배치됩니다 &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 모든 압축 된 데이터가 기록되기 전에. 그렇지 않으면 파일 포인터가 이동되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6f34a91ef18a1100dcab801875430fa2964155e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output&lt;/code&gt; is a filename and &lt;code&gt;Append&lt;/code&gt; is enabled, the file will be opened in append mode. Otherwise the contents of the file, if any, will be truncated before any compressed data is written to it.</source>
          <target state="translated">경우 &lt;code&gt;$output&lt;/code&gt; 파일 이름이며 &lt;code&gt;Append&lt;/code&gt; 활성화되어, 파일은 확장 모드에서 열립니다. 그렇지 않으면 압축 된 데이터가 파일에 기록되기 전에 파일의 내용이 잘립니다.</target>
        </trans-unit>
        <trans-unit id="905a4b022cfd04d4344f06eb8d1d7814fe3b2e8c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output&lt;/code&gt; is a scalar reference, the compressed data will be stored in &lt;code&gt;$$output&lt;/code&gt; .</source>
          <target state="translated">경우 &lt;code&gt;$output&lt;/code&gt; 스칼라 기준이고, 상기 압축 된 데이터를 저장한다 &lt;code&gt;$$output&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="130d5c72326e4e51651ab55caf6ff565c16bd2ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a scalar reference, the compressed data will be stored in &lt;code&gt;$$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="translated">경우 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 스칼라를 참조하고, 압축 데이터를 저장한다 &lt;code&gt;$$output_filename_or_reference&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6e6e43463d8cf9f8c4cc955f62290b2d79a9ce9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a scalar reference, the uncompressed data will be stored in &lt;code&gt;$$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="translated">경우 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 스칼라 참조이며, 압축되지 않은 데이터에 저장됩니다 &lt;code&gt;$$output_filename_or_reference&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ffed2a8f82140ef8dc0c4ed699c9112d9f907c47" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;anyinflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$output_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;문자로 구분 된 문자열 인 경우 &lt;code&gt;anyinflate&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="b9f151907f2e5c73c6d5a7f5e3827d63f2d086e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;anyuncompress&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$output_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;문자로 구분 된 문자열 인 경우 &lt;code&gt;anyuncompress&lt;/code&gt; 은 문자열 이</target>
        </trans-unit>
        <trans-unit id="eb784e91a1d15b001b3d17241bbd0f023fa0db31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;bunzip2&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$output_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;문자로 구분 된 문자열 인 경우 &lt;code&gt;bunzip2&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="308eaa4a6536e52e6cbbe3d9c09c32dfa80725fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;bzip2&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$output_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;문자로 구분 된 문자열 인 경우 &lt;code&gt;bzip2&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="632c19749781b38310b67e8cb7d2da8bcbd87fa7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;deflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$output_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;문자로 구분 된 문자열 인 경우 &lt;code&gt;deflate&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="4846f7304e22cdc9a232215f9939eddfa8d9211d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;gunzip&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$output_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;문자로 구분 된 문자열 인 경우 &lt;code&gt;gunzip&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="4f11ec72b95266da1fd717b81d461cc92a72f199" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;gzip&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$output_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;문자로 구분 된 문자열 인 경우 &lt;code&gt;gzip&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="f099e710944546f4f6281f3a2de13a8288ffdd0a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;inflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">경우 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 문자 &quot;&amp;lt;&quot;와 &quot;&amp;gt;&quot;로 구분되는 문자열입니다 &lt;code&gt;inflate&lt;/code&gt; 그것이이 있다고 가정합니다</target>
        </trans-unit>
        <trans-unit id="cceae651ad537fbe024d4ffd9a457c78fec4fbd7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;rawdeflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$output_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;문자로 구분 된 문자열 인 경우 &lt;code&gt;rawdeflate&lt;/code&gt; 는 문자열 이</target>
        </trans-unit>
        <trans-unit id="767601b4f86c38e1ce00ed67d4e6753dd438a660" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;rawinflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$output_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;문자로 구분 된 문자열 인 경우 &lt;code&gt;rawinflate&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="c227dd1ee1e8b9659ffdea7cebe0fc1ef9dd1a51" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;unzip&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$output_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;문자로 구분 된 문자열 인 경우 &lt;code&gt;unzip&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="2ae55891ab5b00668d1e680f825b4abc927f84c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;zip&lt;/code&gt; will assume that it is an</source>
          <target state="translated">&lt;code&gt;$output_filename_or_reference&lt;/code&gt; 가 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot; &lt;code&gt;zip&lt;/code&gt; 문자로 구분 된 문자열 인 경우 은</target>
        </trans-unit>
        <trans-unit id="a78a9fcfd00ce247c78fb42d76b95940b9310c9c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is an array reference, the compressed data will be pushed onto the array.</source>
          <target state="translated">경우 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 배열 기준이고, 상기 압축 된 데이터는 어레이 상에 푸시한다.</target>
        </trans-unit>
        <trans-unit id="37e6606fa0b627f8a29d46dde4b8ebad46bd51a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is an array reference, the uncompressed data will be pushed onto the array.</source>
          <target state="translated">경우 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 배열 참조되면, 압축 데이터는 어레이 상에 푸시한다.</target>
        </trans-unit>
        <trans-unit id="369470062bc6b67bd375785b11035d408478ab66" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$path&lt;/code&gt; is absolute, it is cleaned up and returned using &lt;a href=&quot;#canonpath&quot;&gt;canonpath&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;$path&lt;/code&gt; 절대, 그것은 청소 및 사용하여 반환 &lt;a href=&quot;#canonpath&quot;&gt;canonpath을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8992ca77fb991d344a3dd6a4f26aedbf1b0f1d7f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$path&lt;/code&gt; is relative, it is converted to absolute form using &lt;a href=&quot;#rel2abs()&quot;&gt;rel2abs()&lt;/a&gt;. This means that it is taken to be relative to &lt;a href=&quot;../cwd&quot;&gt;Cwd::cwd()&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;$path&lt;/code&gt; 상대적이며,이를 이용하여 절대 형태로 전환된다 &lt;a href=&quot;#rel2abs()&quot;&gt;rel2abs을 ()&lt;/a&gt; . 이것은 &lt;a href=&quot;../cwd&quot;&gt;Cwd :: cwd ()에&lt;/a&gt; 상대적인 것으로 간주됨을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="529756014729906a36945c0c1d2b4d6306a5c66b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$potential_libs&lt;/code&gt; is empty, the return value will be empty. Otherwise, the libraries specified by &lt;code&gt;$Config{perllibs}&lt;/code&gt; (see Config.pm) will be appended to the list of &lt;code&gt;$potential_libs&lt;/code&gt; . The libraries will be searched for in the directories specified in &lt;code&gt;$potential_libs&lt;/code&gt; , &lt;code&gt;$Config{libpth}&lt;/code&gt; , and in &lt;code&gt;$Config{installarchlib}/CORE&lt;/code&gt; . For each library that is found, a space-separated list of fully qualified library pathnames is generated.</source>
          <target state="translated">경우 &lt;code&gt;$potential_libs&lt;/code&gt; 비어, 반환 값은 비어 있습니다. 그렇지 않으면 &lt;code&gt;$Config{perllibs}&lt;/code&gt; (Config.pm 참조)로 지정된 라이브러리 가 &lt;code&gt;$potential_libs&lt;/code&gt; 목록에 추가됩니다 . 라이브러리는 &lt;code&gt;$potential_libs&lt;/code&gt; , &lt;code&gt;$Config{libpth}&lt;/code&gt; 및 &lt;code&gt;$Config{installarchlib}/CORE&lt;/code&gt; 지정된 디렉토리에서 검색됩니다. . 발견 된 각 라이브러리에 대해 공백으로 구분 된 완전한 라이브러리 경로 이름 목록이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="6e553e7605e3100f0e3fcb5a8fa623376f34f081" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$priority&lt;/code&gt; permits, logs &lt;code&gt;$message&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;($format, @args)&lt;/code&gt; with the addition that &lt;code&gt;%m&lt;/code&gt; in $message or &lt;code&gt;$format&lt;/code&gt; is replaced with &lt;code&gt;&quot;$!&quot;&lt;/code&gt; (the latest error message).</source>
          <target state="translated">경우 &lt;code&gt;$priority&lt;/code&gt; 허가, 기록 &lt;code&gt;$message&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;($format, @args)&lt;/code&gt; 하는 첨가 &lt;code&gt;%m&lt;/code&gt; $ 메시지 또는 &lt;code&gt;$format&lt;/code&gt; 으로 대체 &lt;code&gt;&quot;$!&quot;&lt;/code&gt; (최신 오류 메시지).</target>
        </trans-unit>
        <trans-unit id="9f52d52d1ba29c4eacb016d029d5d02c84a30a69" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$ref&lt;/code&gt; is a blessed reference the name of the package that it is blessed into is returned. Otherwise &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;$ref&lt;/code&gt; 축복 참조는 리턴으로 축복하고있는 패키지의 이름입니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="79e261aa8c38ef64f4ef56cc680e427a28531090" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$ref&lt;/code&gt; is a reference the basic Perl type of the variable referenced is returned as a plain string (such as &lt;code&gt;ARRAY&lt;/code&gt; or &lt;code&gt;HASH&lt;/code&gt; ). Otherwise &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;$ref&lt;/code&gt; (예 참조 변수의 기본 펄 타입은 일반 문자열로 반환되는 참조입니다 &lt;code&gt;ARRAY&lt;/code&gt; 또는 &lt;code&gt;HASH&lt;/code&gt; ). 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="fac5930e7537a0d644cf3490408ca500262cfef0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$ref&lt;/code&gt; is reference the internal memory address of the referenced value is returned as a plain integer. Otherwise &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;$ref&lt;/code&gt; 참조입니다 참조 값의 내부 메모리 주소는 일반 정수로 반환됩니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4f2f6d4bd4dbef02b5adcb98b33be7311853de12" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$result&lt;/code&gt; is undefined the corresponding parser has reached the end of its input (and will automatically be removed from the multiplexer).</source>
          <target state="translated">경우 &lt;code&gt;$result&lt;/code&gt; 정의되지 대응 파서는 입력이 종료 할 때 (자동 멀티플렉서에서 제거한다).</target>
        </trans-unit>
        <trans-unit id="3a340f9f260eea8720ddb9232a9ecfe918063812" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; does not match any part of &lt;code&gt;$string&lt;/code&gt; , returns &lt;code&gt;-1&lt;/code&gt; in scalar context and an empty list in list context.</source>
          <target state="translated">경우 &lt;code&gt;$substring&lt;/code&gt; 의 어떤 부분과 일치하지 않는 &lt;code&gt;$string&lt;/code&gt; , 반환 &lt;code&gt;-1&lt;/code&gt; 스칼라 문맥과 목록 문맥에서 빈 목록을.</target>
        </trans-unit>
        <trans-unit id="34f2ce5e748390e7ea9b7256361ae68fda804dd4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; does not match any part of &lt;code&gt;$string&lt;/code&gt; , returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in scalar context and an empty list in list context.</source>
          <target state="translated">경우 &lt;code&gt;$substring&lt;/code&gt; 의 일부 일치하지 않는 &lt;code&gt;$string&lt;/code&gt; , 반환 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 스칼라 문맥과 목록 문맥에서 빈 목록.</target>
        </trans-unit>
        <trans-unit id="78ec8c638c3f85aaeb890b68130939aac53cb1a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; does not match any part of &lt;code&gt;$string&lt;/code&gt; , returns an empty list.</source>
          <target state="translated">경우 &lt;code&gt;$substring&lt;/code&gt; 의 일부 일치하지 않는 &lt;code&gt;$string&lt;/code&gt; 빈 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7dc9206b35b196b0963c771281e4b1c34fd9c295" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; matches a part of &lt;code&gt;$string&lt;/code&gt; , all the occurrences of the matching part are replaced by &lt;code&gt;$replacement&lt;/code&gt; (&lt;code&gt;$string&lt;/code&gt; is modified) and &lt;code&gt;$count&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;$substring&lt;/code&gt; 의 일부와 일치 &lt;code&gt;$string&lt;/code&gt; , 일치하는 부분의 모든 발생에 의해 대체되는 &lt;code&gt;$replacement&lt;/code&gt; ( &lt;code&gt;$string&lt;/code&gt; 수정) 및 &lt;code&gt;$count&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b46dcd3b846eff16d0953c63180197a9948d71b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; matches a part of &lt;code&gt;$string&lt;/code&gt; , in scalar context, returns &lt;b&gt;a reference to&lt;/b&gt; the first occurrence of the matching part (&lt;code&gt;$match_ref&lt;/code&gt; is always true if matches, since every reference is &lt;b&gt;true&lt;/b&gt;); in list context, returns the first occurrence of the matching part.</source>
          <target state="translated">경우 &lt;code&gt;$substring&lt;/code&gt; 의 일부와 일치 &lt;code&gt;$string&lt;/code&gt; , 스칼라 문맥에서, 반환 &lt;b&gt;에 대한 참조&lt;/b&gt; 일치하는 부분의 첫 번째 항목을 ( &lt;code&gt;$match_ref&lt;/code&gt; 모든 기준이기 때문에, 항상 일치하는 경우는 true입니다 &lt;b&gt;진정한&lt;/b&gt; ); 목록 컨텍스트에서 일치하는 부분의 첫 항목을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c160da8add608824da0efecdea8fe8dbd7d4c55a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; matches a part of &lt;code&gt;$string&lt;/code&gt; , returns all the matching parts (or matching count in scalar context).</source>
          <target state="translated">경우 &lt;code&gt;$substring&lt;/code&gt; 의 일부와 일치 &lt;code&gt;$string&lt;/code&gt; , 일치하는 모든 부품 (스칼라 문맥 또는 일치하는 수를) 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c10bc187ce931b2a7b22530d13ae4fe64805817c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; matches a part of &lt;code&gt;$string&lt;/code&gt; , returns the position of the first occurrence of the matching part in scalar context; in list context, returns a two-element list of the position and the length of the matching part.</source>
          <target state="translated">경우 &lt;code&gt;$substring&lt;/code&gt; 일부 일치 &lt;code&gt;$string&lt;/code&gt; 스칼라 컨텍스트 매칭 부 처음 나타나는 위치를 반환한다; 목록 컨텍스트에서 일치하는 부분의 위치와 길이의 두 요소로 된 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d649e7e5214d8eb5d7dfa63d2b26508aa3ec136c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; matches a part of &lt;code&gt;$string&lt;/code&gt; , the first occurrence of the matching part is replaced by &lt;code&gt;$replacement&lt;/code&gt; (&lt;code&gt;$string&lt;/code&gt; is modified) and &lt;code&gt;$count&lt;/code&gt; (always equals to &lt;code&gt;1&lt;/code&gt; ) is returned.</source>
          <target state="translated">경우 &lt;code&gt;$substring&lt;/code&gt; 일부 일치 &lt;code&gt;$string&lt;/code&gt; , 일치 부분의 처음 발생에 의해 대체된다 &lt;code&gt;$replacement&lt;/code&gt; ( &lt;code&gt;$string&lt;/code&gt; 수정) 및 &lt;code&gt;$count&lt;/code&gt; (항상 같음 &lt;code&gt;1&lt;/code&gt; )이 반환된다.</target>
        </trans-unit>
        <trans-unit id="923955b556ee1c107b87425fc0d239520dd618a5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$thing&lt;/code&gt; refers to an object, then this function returns the name of the package the object has been blessed into. If &lt;code&gt;$thing&lt;/code&gt; doesn't contain a reference to a blessed object, the &lt;code&gt;blessed&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;$thing&lt;/code&gt; 개체를 참조,이 기능은 객체로 축복 된 패키지의 이름을 반환합니다. 경우 &lt;code&gt;$thing&lt;/code&gt; 축복받은 객체의 참조가 포함되어 있지 않습니다 &lt;code&gt;blessed&lt;/code&gt; 함수가 반환 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62b5b827c9fa69b1b1193c08475c48b1b10adad6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$total-&amp;gt;{bad} == 0&lt;/code&gt; and &lt;code&gt;$total-&amp;gt;{max} &amp;gt; 0&lt;/code&gt; , you've got a successful test.</source>
          <target state="translated">경우 &lt;code&gt;$total-&amp;gt;{bad} == 0&lt;/code&gt; 과 &lt;code&gt;$total-&amp;gt;{max} &amp;gt; 0&lt;/code&gt; , 당신은 성공적인 테스트를 가지고있다.</target>
        </trans-unit>
        <trans-unit id="7e9127d14922a52db0d5d2508646de8dbb02dabc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$var&lt;/code&gt; is a scalar that has both numeric and string values, the result is true.</source>
          <target state="translated">경우 &lt;code&gt;$var&lt;/code&gt; 모두 숫자 및 문자열 값이 스칼라이며, 결과는 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="811b177adb678df1c7fcd2ebe9a8006c41328bc7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$var&lt;/code&gt; is a scalar which was coded as a vstring the result is true.</source>
          <target state="translated">경우 &lt;code&gt;$var&lt;/code&gt; vstring으로 코딩 된 스칼라이고 결과는 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="eea1e5cda1b021861102b8f6816c7f61a9adac01" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$x&lt;/code&gt; and &lt;code&gt;$y&lt;/code&gt; are non-zero, they must be relative primes, i.e., &lt;code&gt;bgcd($y, $mod)==1&lt;/code&gt; . '&lt;code&gt;NaN&lt;/code&gt; ' is returned when no modular multiplicative inverse exists.</source>
          <target state="translated">경우 &lt;code&gt;$x&lt;/code&gt; 와 &lt;code&gt;$y&lt;/code&gt; 비제로, 그들은 즉 상대적으로 소수,해야 &lt;code&gt;bgcd($y, $mod)==1&lt;/code&gt; . 모듈 형 곱셈 역수가 존재하지 않으면 ' &lt;code&gt;NaN&lt;/code&gt; '이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f1241f2fba2bddba0f0228a9100bb47c11034264" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$z&lt;/code&gt; is associated with a buffer, this method has no effect and always returns &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;$z&lt;/code&gt; 버퍼와 연결되어,이 방법은 효과가 없습니다 항상 반환 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c2e0c2819ecb9af14cc06d8987b7eee133a60fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;%+&lt;/code&gt; or &lt;code&gt;%-&lt;/code&gt; is being operated on, if any.</source>
          <target state="translated">만약 &lt;code&gt;%+&lt;/code&gt; 또는 &lt;code&gt;%-&lt;/code&gt; 있는 경우에 운영되고있다.</target>
        </trans-unit>
        <trans-unit id="33759bad70947890a80808b87beeb0ad07a9f99a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is overloaded then the same implementation is used for both the</source>
          <target state="translated">경우 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 다음 과부하 동일한 구현 모두에 사용</target>
        </trans-unit>
        <trans-unit id="2655a0d13879bb1273409b47214e136f442c0716" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;'-'&lt;/code&gt; is the first or last character in a character class, it is treated as an ordinary character.</source>
          <target state="translated">경우 &lt;code&gt;'-'&lt;/code&gt; 문자 클래스의 첫 번째 또는 마지막 문자가, 그것은 일반 문자로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="3fbcc9b880c1850b742f9cae8dd87f58567ba57c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;'-'&lt;/code&gt; is the first or last character in a character class, it is treated as an ordinary character; &lt;code&gt;[-ab]&lt;/code&gt; , &lt;code&gt;[ab-]&lt;/code&gt; and &lt;code&gt;[a\-b]&lt;/code&gt; are all equivalent.</source>
          <target state="translated">경우 &lt;code&gt;'-'&lt;/code&gt; 문자 클래스의 첫 번째 또는 마지막 문자가, 그것은 일반 문자로 처리됩니다; &lt;code&gt;[-ab]&lt;/code&gt; , &lt;code&gt;[ab-]&lt;/code&gt; 및 &lt;code&gt;[a\-b]&lt;/code&gt; 는 모두 같습니다.</target>
        </trans-unit>
        <trans-unit id="8b4ef209f3736a149a4cf48e4ad6ea5f08cb5ced" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;'fallback'&lt;/code&gt; is TRUE and no copy constructor is defined then, for objects not based on scalars, Perl may silently fall back on simple assignment - that is, assignment of the object reference. In effect, this disables the copy constructor mechanism since no new copy of the object data is created. This is almost certainly not what you want. (It is, however, consistent: for example, Perl's fallback for the &lt;code&gt;++&lt;/code&gt; operator is to increment the reference itself.)</source>
          <target state="translated">경우 &lt;code&gt;'fallback'&lt;/code&gt; , 객체 참조의 할당이다 - 참이고 어떤 복사 생성자는 스칼라 기반으로하지 않는 개체에 대해 다음 정의되지 펄은 자동으로 간단한 과제에 다시 떨어질 수 있습니다. 실제로, 객체 데이터의 새 복사본이 만들어지지 않기 때문에 복사 생성자 메커니즘이 비활성화됩니다. 이것은 거의 확실히 당신이 원하는 것이 아닙니다. (그러나 일관성이 있습니다. 예를 들어, &lt;code&gt;++&lt;/code&gt; 연산자에 대한 Perl의 폴백 은 참조 자체를 증가시키는 것입니다.)</target>
        </trans-unit>
        <trans-unit id="f876580a65734a569954c7e1c0d71566801b2a2a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;'fallback'&lt;/code&gt; is undefined or TRUE then a copy constructor can be autogenerated, but only for objects based on scalars. In other cases it needs to be defined explicitly. Where an object's data is stored as, for example, an array of scalars, the following might be appropriate:</source>
          <target state="translated">경우 &lt;code&gt;'fallback'&lt;/code&gt; 정의되지 않았거나 TRUE되어 다음 복사 생성자는하지만 스칼라에 기반하여 객체에 대한, 자동 생성 할 수 있습니다. 다른 경우에는 명시 적으로 정의해야합니다. 객체의 데이터가 예를 들어 스칼라 배열로 저장되는 경우 다음이 적합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aaf2bfa6a27ac22ef6886057189af7b7a1f09aa1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-&amp;gt;offs[num].start&lt;/code&gt; or &lt;code&gt;-&amp;gt;offs[num].end&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt; then that capture group did not match. &lt;code&gt;-&amp;gt;offs[0].start/end&lt;/code&gt; represents &lt;code&gt;$&amp;amp;&lt;/code&gt; (or &lt;code&gt;${^MATCH}&lt;/code&gt; under &lt;code&gt;//p&lt;/code&gt; ) and &lt;code&gt;-&amp;gt;offs[paren].end&lt;/code&gt; matches &lt;code&gt;$$paren&lt;/code&gt; where &lt;code&gt;$paren &lt;/code&gt; = 1&amp;gt;.</source>
          <target state="translated">만약 &lt;code&gt;-&amp;gt;offs[num].start&lt;/code&gt; 또는 &lt;code&gt;-&amp;gt;offs[num].end&lt;/code&gt; 입니다 &lt;code&gt;-1&lt;/code&gt; 캡처 그룹이 일치하지 않습니다 그. &lt;code&gt;-&amp;gt;offs[0].start/end&lt;/code&gt; 나타내는 &lt;code&gt;$&amp;amp;&lt;/code&gt; (또는 &lt;code&gt;${^MATCH}&lt;/code&gt; 아래 &lt;code&gt;//p&lt;/code&gt; )과 &lt;code&gt;-&amp;gt;offs[paren].end&lt;/code&gt; 일치 &lt;code&gt;$$paren&lt;/code&gt; 여기서 &lt;code&gt;$paren &lt;/code&gt; = 1&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="c6203f8ab9db59ac080a4fb390ff800c0d1e53c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-&lt;/code&gt; is not a recognized switch letter, getopts() supports arguments &lt;code&gt;--help&lt;/code&gt; and &lt;code&gt;--version&lt;/code&gt; . If &lt;code&gt;main::HELP_MESSAGE()&lt;/code&gt; and/or &lt;code&gt;main::VERSION_MESSAGE()&lt;/code&gt; are defined, they are called; the arguments are the output file handle, the name of option-processing package, its version, and the switches string. If the subroutines are not defined, an attempt is made to generate intelligent messages; for best results, define $main::VERSION.</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; 가 인식되는 전환 문자가 아닌 경우 getopts ()는 인수 &lt;code&gt;--help&lt;/code&gt; 및 &lt;code&gt;--version&lt;/code&gt; 을 지원합니다 . 경우 &lt;code&gt;main::HELP_MESSAGE()&lt;/code&gt; 및 / 또는 &lt;code&gt;main::VERSION_MESSAGE()&lt;/code&gt; 정의되어, 그들 불리는; 인수는 출력 파일 핸들, 옵션 처리 패키지 이름, 버전 및 스위치 문자열입니다. 서브 루틴이 정의되지 않은 경우 지능형 메시지를 생성하려고 시도합니다. 최상의 결과를 얻으려면 $ main :: VERSION을 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="7069d110eb31ac59c5fa5654832fee9ae99f4bc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-Strict&lt;/code&gt; is disabled, then &lt;code&gt;$string&lt;/code&gt; can contain any character except NULL. If any null characters are present, the field will be truncated at the first NULL.</source>
          <target state="translated">&lt;code&gt;-Strict&lt;/code&gt; 를 사용하지 않으면 &lt;code&gt;$string&lt;/code&gt; 은 NULL을 제외한 모든 문자를 포함 할 수 있습니다. 널 문자가 존재하면 필드는 첫 번째 NULL에서 잘립니다.</target>
        </trans-unit>
        <trans-unit id="72b90d51b78e3f86c015e424f0a9c82ae7cdd392" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:full&lt;/code&gt; is present, for expansion of &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt;, the string</source>
          <target state="translated">경우 &lt;code&gt;:full&lt;/code&gt; 의 확장을 위해 존재하는 &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt; 문자열</target>
        </trans-unit>
        <trans-unit id="34845b5a7409ae2ff88602a784737cd832c5bd71" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:short&lt;/code&gt; is present, and</source>
          <target state="translated">경우 &lt;code&gt;:short&lt;/code&gt; , 존재하고</target>
        </trans-unit>
        <trans-unit id="51514fa7ee13d4abe63d9987d2badb1e9b04ad61" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; winds up off the top of the stack it report the highest context.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;../functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; 스택의 상단 떨어져 바람이이 가장 높은 상황을보고한다.</target>
        </trans-unit>
        <trans-unit id="b1ac9c6b50bb86cfe48d37ba1ee2e0f181649af5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (not a string &lt;code&gt;&quot;undef&quot;&lt;/code&gt; ) is passed explicitly as the value for this key, any normalization is not carried out (this may make tailoring easier if any normalization is not desired). Under &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; , only contiguous contractions are resolved; e.g. even if &lt;code&gt;A-ring&lt;/code&gt; (and &lt;code&gt;A-ring-cedilla&lt;/code&gt; ) is ordered after &lt;code&gt;Z&lt;/code&gt; , &lt;code&gt;A-cedilla-ring&lt;/code&gt; would be primary equal to &lt;code&gt;A&lt;/code&gt; . In this point, &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;, preprocess =&amp;gt; &lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt; { NFD(&lt;a href=&quot;../functions/shift&quot;&gt;shift&lt;/a&gt;) })&lt;/code&gt;&lt;b&gt;is not&lt;/b&gt; equivalent to &lt;code&gt;(normalization =&amp;gt; 'NFD')&lt;/code&gt; .</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (안 문자열 &lt;code&gt;&quot;undef&quot;&lt;/code&gt; )이 키 값으로 명시 적으로 전달되고, 어떤 정상화는 (모든 정상화가 요구되지 않은 경우이 쉽게 재봉 할 수 있습니다) 수행되지 않습니다. 에서 &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; 만 연속 수축 해결; 경우에도 예를 들면 &lt;code&gt;A-ring&lt;/code&gt; (및 &lt;code&gt;A-ring-cedilla&lt;/code&gt; ) 후 주문한 &lt;code&gt;Z&lt;/code&gt; 는 , &lt;code&gt;A-cedilla-ring&lt;/code&gt; 동일한 기본 것이다 . 이 시점에서 &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;, preprocess =&amp;gt; &lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt; { NFD(&lt;a href=&quot;../functions/shift&quot;&gt;shift&lt;/a&gt;) })&lt;/code&gt; &lt;code&gt;A&lt;/code&gt; &lt;a href=&quot;../functions/undef&quot;&gt; undef&lt;/a&gt; , preprocess =&amp;gt; &lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt; {NFD ( &lt;a href=&quot;../functions/shift&quot;&gt;shift&lt;/a&gt; )}) &lt;b&gt;는 이 아닙니다&lt;/b&gt; 동등 &lt;code&gt;(normalization =&amp;gt; 'NFD')&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa3ebd4a416f2ed67a7f6e0321914f19253d4061" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is passed explicitly as the value for this key, no file is read (but you can define collation elements via &lt;code&gt;entry&lt;/code&gt; ).</source>
          <target state="translated">만약 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가이 키의 값으로 명시 적으로 전달파일을 읽지 않습니다 (그러나 &lt;code&gt;entry&lt;/code&gt; 를 통해 데이터 정렬 요소를 정의 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="311ed3b2b34ac0afe5f28bb9003642de34a3cf73" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is passed explicitly as the value for this key, weight for Hangul syllables is treated as undefined without decomposition into Hangul Jamo. But definition of weight for Hangul syllables in &lt;code&gt;table&lt;/code&gt; or &lt;code&gt;entry&lt;/code&gt; is still valid.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가이 키의 값으로 명시 적으로 전달 되면 한글 음절의 가중치는 한글 자모로 분해되지 않고 정의되지 않은 것으로 처리됩니다. 그러나 &lt;code&gt;table&lt;/code&gt; 또는 &lt;code&gt;entry&lt;/code&gt; 에서 한글 음절의 무게 정의 는 여전히 유효합니다.</target>
        </trans-unit>
        <trans-unit id="a0847d602472c48d4557dcd264e5fd82c70ededc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Devel::Peek&lt;/code&gt; directive has a &lt;code&gt;:opd=FLAGS&lt;/code&gt; argument, this switches on debugging of opcode dispatch. &lt;code&gt;FLAGS&lt;/code&gt; should be a combination of &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt; , and &lt;code&gt;P&lt;/code&gt; (see &lt;b&gt;-D&lt;/b&gt; flags in &lt;a href=&quot;../perlrun&quot;&gt;perlrun&lt;/a&gt;). &lt;code&gt;:opd&lt;/code&gt; is a shortcut for &lt;code&gt;:opd=st&lt;/code&gt; .</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Devel::Peek&lt;/code&gt; 지시어는있다 &lt;code&gt;:opd=FLAGS&lt;/code&gt; 인수를,이 연산 코드 파견의 디버깅에 전환합니다. &lt;code&gt;FLAGS&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;t&lt;/code&gt; 및 &lt;code&gt;P&lt;/code&gt; 의 조합이어야합니다 ( &lt;a href=&quot;../perlrun&quot;&gt;perlrun의 &lt;/a&gt;&lt;b&gt;-D&lt;/b&gt; 플래그 참조). ). &lt;code&gt;:opd&lt;/code&gt; 는 &lt;code&gt;:opd=st&lt;/code&gt; 의 바로 가기입니다 .</target>
        </trans-unit>
        <trans-unit id="dae0c23c00276e5219bdb2cdf7fffc6926c2f0f3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; can read the file but cannot compile it, it returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and sets an error message in &lt;code&gt;$@&lt;/code&gt; . If &lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; cannot read the file, it returns undef and sets &lt;code&gt;$!&lt;/code&gt; to the error. Always check &lt;code&gt;$@&lt;/code&gt; first, as compilation could fail in a way that also sets &lt;code&gt;$!&lt;/code&gt; . If the file is successfully compiled, &lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; returns the value of the last expression evaluated.</source>
          <target state="translated">만약 &lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 파일을 읽을 수 있지만 그것을 컴파일 할 수 없습니다, 그것은 반환 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 과에서 오류 메시지를 설정 &lt;code&gt;$@&lt;/code&gt; . 경우 &lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 파일을 읽을 수 없습니다, 그것은 미확정 및 세트 반환 &lt;code&gt;$!&lt;/code&gt; 오류에. 컴파일은 &lt;code&gt;$!&lt;/code&gt; 를 설정하는 방식으로 실패 할 수 있으므로 항상 &lt;code&gt;$@&lt;/code&gt; 먼저 확인하십시오 . . 파일이 성공적으로 컴파일되면 &lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 는 마지막으로 평가 된 식의 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e753c27e9c7187898b162963067981265acf4ee7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; can read the file but cannot compile it, it returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and sets an error message in &lt;code&gt;$@&lt;/code&gt; . If &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; cannot read the file, it returns undef and sets &lt;code&gt;$!&lt;/code&gt; to the error. Always check &lt;code&gt;$@&lt;/code&gt; first, as compilation could fail in a way that also sets &lt;code&gt;$!&lt;/code&gt; . If the file is successfully compiled, &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; returns the value of the last expression evaluated.</source>
          <target state="translated">하면 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 파일을 읽을 수 있지만 그것을 컴파일 할 수 없습니다, 그것은 반환 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 과에서 오류 메시지를 설정 &lt;code&gt;$@&lt;/code&gt; . 경우 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 파일을 읽을 수 없습니다, 그것은 미확정 및 세트 반환 &lt;code&gt;$!&lt;/code&gt; 오류에. 컴파일은 &lt;code&gt;$!&lt;/code&gt; 를 설정하는 방식으로 실패 할 수 있으므로 항상 &lt;code&gt;$@&lt;/code&gt; 먼저 확인하십시오 . . 파일이 성공적으로 컴파일되면 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 는 마지막으로 평가 된 식의 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a29f1441f3fe81108d43067a84beeb2b3df06a0c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; really is needed, then consider using the following:</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 정말 필요 후 다음 사용을 고려 :</target>
        </trans-unit>
        <trans-unit id="fbdbd42df3d8a3289f178b0b712d70c88452aff7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; encounters an operating system error, &lt;code&gt;$!&lt;/code&gt; will be set with the corresponding error message. It can be helpful to check &lt;code&gt;$!&lt;/code&gt; when you are reading from filehandles you don't trust, such as a tty or a socket. The following example uses the operator form of &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; and dies if the result is not defined.</source>
          <target state="translated">만약 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 만남 운영 시스템 오류, &lt;code&gt;$!&lt;/code&gt; 해당 오류 메시지와 함께 설정됩니다. &lt;code&gt;$!&lt;/code&gt; 를 확인하면 도움이 될 수 있습니다 ! 파일 핸들에서 읽을 때 tty 또는 소켓과 같은 신뢰할 수 없습니다. 다음 예제는 연산자 형태의 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 을 사용 하고 결과가 정의되지 않은 경우 죽습니다.</target>
        </trans-unit>
        <trans-unit id="d241999daf1d6b5b1d790a94e12c3db4b7639b62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; does not point to a well-formed UTF-8 character and UTF8 warnings are enabled, zero is returned and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) to -1. If those warnings are off, the computed value if well-defined (or the Unicode REPLACEMENT CHARACTER, if not) is silently returned, and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) so that (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ) is the next possible position in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; that could begin a non-malformed character. See &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchr&lt;/a&gt; for details on when the REPLACEMENT CHARACTER is returned.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 활성화되어 잘 형성 UTF8 문자와 UTF8 경고 가리 키지 않는 제로가 반환되고 &lt;code&gt;*retlen&lt;/code&gt; 은 (경우 설정 &lt;code&gt;retlen&lt;/code&gt; 는 -1 NULL이 아닌). 이러한 경고가 해제 된 경우 올바르게 정의 된 경우 계산 된 값 (또는 유니 코드 REPLACEMENT CHARACTER가 아닌 경우)이 자동으로 반환되고 &lt;code&gt;*retlen&lt;/code&gt; 이 설정되어 ( &lt;code&gt;retlen&lt;/code&gt; 이 NULL이 아닌 경우 ) ( &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; )이 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 의 다음 가능한 위치 비 변형 문자를 시작할 수 . REPLACEMENT CHARACTER가 리턴되는시기에 대한 세부 사항 은 &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchr&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e0d74bacc686d5d25a69c27fe56691316eb86755" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; does not point to a well-formed UTF-8 character and UTF8 warnings are enabled, zero is returned and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) to -1. If those warnings are off, the computed value, if well-defined (or the Unicode REPLACEMENT CHARACTER if not), is silently returned, and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) so that (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ) is the next possible position in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; that could begin a non-malformed character. See &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchr&lt;/a&gt; for details on when the REPLACEMENT CHARACTER is returned.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 활성화되어 잘 형성 UTF8 문자와 UTF8 경고 가리 키지 않는 제로가 반환되고 &lt;code&gt;*retlen&lt;/code&gt; 은 (경우 설정 &lt;code&gt;retlen&lt;/code&gt; 는 -1 NULL이 아닌). 이러한 경고가 해제 된 경우, 잘 정의 된 경우 계산 된 값 (또는 유니 코드 대체 문자가 아닌 경우)이 자동으로 리턴되고 &lt;code&gt;*retlen&lt;/code&gt; 이 설정되어 ( &lt;code&gt;retlen&lt;/code&gt; 이 NULL이 아닌 경우 ) ( &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; )이됩니다. &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 의 다음 가능한 위치 변형되지 않은 문자를 시작할 수 REPLACEMENT CHARACTER가 리턴되는시기에 대한 세부 사항 은 &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchr&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bd7ce6c8380ad430d911ba4aeab09bd5672c569b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; points to one of the detected malformations, and UTF8 warnings are enabled, zero is returned and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; doesn't point to NULL) to -1. If those warnings are off, the computed value if well-defined (or the Unicode REPLACEMENT CHARACTER, if not) is silently returned, and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) so that (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ) is the next possible position in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; that could begin a non-malformed character. See &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchr&lt;/a&gt; for details on when the REPLACEMENT CHARACTER is returned.</source>
          <target state="translated">만약 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 검출 기형 중 하나의 포인트와 UTF8 경고는, 설정되어 제로가 리턴되고 &lt;code&gt;*retlen&lt;/code&gt; 가 (만약 설정 &lt;code&gt;retlen&lt;/code&gt; 가 -1 NULL을 가리키고 있지 않음). 이러한 경고가 해제 된 경우, 잘 정의 된 경우 계산 된 값 (또는 유니 코드 대체 문자가 아닌 경우)이 자동으로 리턴되고 &lt;code&gt;*retlen&lt;/code&gt; 이 설정되어 ( &lt;code&gt;retlen&lt;/code&gt; 이 NULL이 아닌 경우 ) ( &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; )이 비 변형 문자를 시작할 수 있는 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 다음 위치 . REPLACEMENT CHARACTER가 리턴되는시기에 대한 세부 사항 은 &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchr&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f087a32f599c70b71522f617c69df5af3084d9d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; points to one of the detected malformations, and UTF8 warnings are enabled, zero is returned and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) to -1. If those warnings are off, the computed value if well-defined (or the Unicode REPLACEMENT CHARACTER, if not) is silently returned, and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) so that (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ) is the next possible position in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; that could begin a non-malformed character. See &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchr&lt;/a&gt; for details on when the REPLACEMENT CHARACTER is returned.</source>
          <target state="translated">만약 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 검출 기형 중 하나의 포인트와 UTF8 경고는, 설정되어 제로가 리턴되고 &lt;code&gt;*retlen&lt;/code&gt; 가 (만약 설정 &lt;code&gt;retlen&lt;/code&gt; 가 -1 NULL이 아니다). 이러한 경고가 해제 된 경우, 잘 정의 된 경우 계산 된 값 (또는 유니 코드 REPLACEMENT CHARACTER, 그렇지 않은 경우)이 자동으로 리턴되고 &lt;code&gt;*retlen&lt;/code&gt; 이 설정되어 ( &lt;code&gt;retlen&lt;/code&gt; 이 NULL이 아닌 경우 ) ( &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; )이 비 변형 문자를 시작할 수 있는 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 다음 위치 . REPLACEMENT CHARACTER가 리턴되는시기에 대한 세부 사항 은 &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchr&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5f4f6bcfdeca5ca3ce7d26db71a53789a3b67e8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; is invoked as &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; ' '&lt;/code&gt; or with no arguments (which really means &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;(' ', $_)&lt;/code&gt; , see &lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;), Perl will set this flag. The regex engine can then check for it and set the SKIPWHITE and WHITE extflags. To do this, the Perl engine does:</source>
          <target state="translated">만약 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 로 호출 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; ' '&lt;/code&gt; 정말 의미 (또는 인수로 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;(' ', $_)&lt;/code&gt; , 참조 &lt;a href=&quot;functions/split&quot;&gt;분할&lt;/a&gt; ), 펄이 플래그를 설정합니다. 그런 다음 정규식 엔진이이를 확인하고 SKIPWHITE 및 WHITE extflags를 설정할 수 있습니다. 이를 위해 Perl 엔진은 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="5670ad2e09b0f96c2653919425d0503ae94298b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; is not called explicitly, it is called implicitly without a parameter at the first use of the &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; operator. However, there are a few situations where programs are likely to want to call &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt;. One is for generating predictable results, generally for testing or debugging. There, you use &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand($seed)&lt;/a&gt;&lt;/code&gt;, with the same &lt;code&gt;$seed&lt;/code&gt; each time. Another case is that you may want to call &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; after a &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; to avoid child processes sharing the same seed value as the parent (and consequently each other).</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; 명시 적으로 호출되지 않습니다, 그것은의 첫 번째 사용에서 매개 변수없이 암시 적으로 호출 &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; 운영자입니다. 그러나 프로그램이 &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; 를 호출하려고하는 상황이 몇 가지 있습니다 . 하나는 일반적으로 테스트 또는 디버깅을 위해 예측 가능한 결과를 생성하기위한 것입니다. 거기, 당신은 사용 &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand($seed)&lt;/a&gt;&lt;/code&gt; 매번같은 &lt;code&gt;$seed&lt;/code&gt; 와 함께 srand ($ seed) 를 사용합니다. 또 다른 경우는 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; 다음에 srand () 를 호출하여 부모와 동일한 시드 값을 공유하는 하위 프로세스 (및 결과적으로 서로 ) 를 피할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cccd9e31f8fdf12513d7e9607d1902ac2bd43369" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; is passed the special filehandle consisting of an underline, no stat is done, but the current contents of the stat structure from the last &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt;, or filetest are returned. Example:</source>
          <target state="translated">만약 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 밑줄로 구성된 특수한 파일 핸들을 전달, 어떤 스탯이 이루어지지되지만, 마지막에서 합계 구조의 현재 내용 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; 는이 , 또는 파일 테스트가 반환됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="3a943f3015131830c0ed79135dd6ffd5caeedbfa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; is specified as an argument to &lt;code&gt;autodie&lt;/code&gt; , then it uses &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::System::Simple&quot;&gt;IPC::System::Simple&lt;/a&gt; to do the heavy lifting. See the description of that module for more information.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 에 대한 인수로 지정 &lt;code&gt;autodie&lt;/code&gt; , 그것은 사용하는 &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::System::Simple&quot;&gt;IPC :: 시스템 :: 간단한&lt;/a&gt; 무거운 리프팅을 할 수 있습니다. 자세한 정보는 해당 모듈의 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3a8b7802544453fc6ad5238177a90c2f0eccb634" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (including &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ) is in effect and POSIX::setlocale() has been called, the character used for the decimal separator in formatted floating-point numbers is affected by the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;.</source>
          <target state="translated">만약 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (를 포함하여 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ) 효과 POSIX ::은 setlocale ()가 호출 된에, 형식의 부동 소수점 숫자의 소수 구분에 사용되는 문자에 의해 영향을 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 의 로케일. 참조 &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; 및&lt;a href=&quot;posix&quot;&gt; POSIX를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="037fc9127a03dbcb60108531d797528430fc80ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; encounters an operating system error, &lt;code&gt;$!&lt;/code&gt; will be set with the corresponding error message. It can be helpful to check &lt;code&gt;$!&lt;/code&gt; when you are reading from filehandles you don't trust, such as a tty or a socket. The following example uses the operator form of &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; and dies if the result is not defined.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 인 경우 만남 운영 시스템 오류, &lt;code&gt;$!&lt;/code&gt; 해당 오류 메시지와 함께 설정됩니다. &lt;code&gt;$!&lt;/code&gt; 를 확인하면 도움이 될 수 있습니다 ! 파일 핸들에서 읽을 때 tty 또는 소켓과 같은 신뢰할 수 없습니다. 다음 예제는 연산자 형태의 &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 을 사용 하고 결과가 정의되지 않은 경우 죽습니다.</target>
        </trans-unit>
        <trans-unit id="2d7702ac9f2d2a81c61f2c22a4643a2b4934ac53" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; is not called explicitly, it is called implicitly without a parameter at the first use of the &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; operator. However, there are a few situations where programs are likely to want to call &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt;. One is for generating predictable results, generally for testing or debugging. There, you use &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand($seed)&lt;/a&gt;&lt;/code&gt;, with the same &lt;code&gt;$seed&lt;/code&gt; each time. Another case is that you may want to call &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; after a &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; to avoid child processes sharing the same seed value as the parent (and consequently each other).</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; 명시 적으로 호출되지 않습니다, 그것은의 첫 번째 사용에서 매개 변수없이 암시 적으로 호출 &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; 운영자입니다. 그러나 프로그램이 &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; 를 호출하려고하는 상황이 몇 가지 있습니다 . 하나는 일반적으로 테스트 또는 디버깅을 위해 예측 가능한 결과를 생성하기위한 것입니다. 거기, 당신은 사용 &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand($seed)&lt;/a&gt;&lt;/code&gt; 를 사용합니다. &lt;code&gt;$seed&lt;/code&gt; 매번 $ seed . 또 다른 경우는 &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; 호출 후 &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 하여 부모와 동일한 시드 값을 공유하는 하위 프로세스 (및 결과적으로 서로 ) 를 피할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0e39dea0f8d4bc40933767354a2f3ede98ed2f3d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; is passed the special filehandle consisting of an underline, no stat is done, but the current contents of the stat structure from the last &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt;, or filetest are returned. Example:</source>
          <target state="translated">만약 &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 밑줄로 구성된 특수한 파일 핸들을 전달, 어떤 스탯이 이루어지지되지만, 마지막에서 합계 구조의 현재 내용 &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; 는이 , 또는 파일 테스트가 반환됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="4d0fc4f120e9a470fc6f07be480b6e3ed0441ee3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; is in effect:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; &lt;a href=&quot;use&quot;&gt;사용하는&lt;/a&gt; 경우 적용됩니다 :</target>
        </trans-unit>
        <trans-unit id="acafe9c3ebbd6459bfa75fbfb2c2b7c67ce9bcdd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (including &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ) is in effect and POSIX::setlocale() has been called, the character used for the decimal separator in formatted floating-point numbers is affected by the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale. See &lt;a href=&quot;../perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;../posix&quot;&gt;POSIX&lt;/a&gt;.</source>
          <target state="translated">만약 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (를 포함하여 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ) 효과 POSIX ::은 setlocale ()가 호출 된에, 형식의 부동 소수점 숫자의 소수 구분에 사용되는 문자에 의해 영향을 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 의 로케일. &lt;a href=&quot;../perllocale&quot;&gt;perllocale&lt;/a&gt; 및&lt;a href=&quot;../posix&quot;&gt; POSIX를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4fa0102bfd20d7fca81e7a9229fd0c15e53ef801" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;@descriptions&lt;/code&gt; is given, these correspond to the keys used in each call to the add() method. Returns an array of the requested parsers (in the requested order) in list context or an array reference in scalar context.</source>
          <target state="translated">만약 &lt;code&gt;@descriptions&lt;/code&gt; 이 주어집니다, 키 이러한 대응은 추가 () 메소드에 대한 각 호출에 사용. 요청 된 파서의 배열을 요청 된 순서대로 목록 컨텍스트에서 또는 스칼라 컨텍스트에서 배열 참조를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="19fd000c86a54d51f5f77fda0d06393c9c4850ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;A'&lt;/code&gt; coincide: &lt;code&gt;AB&lt;/code&gt; is a better match than &lt;code&gt;AB'&lt;/code&gt; if &lt;code&gt;B&lt;/code&gt; is a better match for &lt;code&gt;T&lt;/code&gt; than &lt;code&gt;B'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;A'&lt;/code&gt; 일치 하는 경우 : &lt;code&gt;AB&lt;/code&gt; 가 &lt;code&gt;AB'&lt;/code&gt; 보다 일치하는 경우 &lt;code&gt;B&lt;/code&gt; 는 을위한 더 나은 일치 &lt;code&gt;T&lt;/code&gt; 보다 &lt;code&gt;B'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d1cdd4b8faba979c10f3007699d2ae7796c4a29c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is a better match for &lt;code&gt;S&lt;/code&gt; than &lt;code&gt;A'&lt;/code&gt;, &lt;code&gt;AB&lt;/code&gt; is a better match than &lt;code&gt;A'B'&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;A&lt;/code&gt; 는 을위한 더 나은 일치 &lt;code&gt;S&lt;/code&gt; 이상은 &lt;code&gt;A'&lt;/code&gt; , &lt;code&gt;AB&lt;/code&gt; 는 보다 더 나은 일치 &lt;code&gt;A'B'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4156d315c54ceb2fee7698af8b63e714f0a2462c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Append&lt;/code&gt; is enabled, all compressed data will be append to the end of the output buffer. Otherwise the output buffer will be cleared before any compressed data is written to it.</source>
          <target state="translated">경우 &lt;code&gt;Append&lt;/code&gt; 활성화되어, 모든 압축 된 데이터는 출력 버퍼의 끝에 추가 될 것이다. 그렇지 않으면 압축 된 데이터를 쓰기 전에 출력 버퍼가 지워집니다.</target>
        </trans-unit>
        <trans-unit id="949b457391fc5cf37099eaecff56b10b510ca113" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Append&lt;/code&gt; is enabled, all uncompressed data will be append to the end of the output buffer. Otherwise the output buffer will be cleared before any uncompressed data is written to it.</source>
          <target state="translated">만약 &lt;code&gt;Append&lt;/code&gt; 가 활성화 된 압축되지 않은 모든 데이터가 출력 버퍼의 끝에 추가됩니다. 그렇지 않으면 압축되지 않은 데이터가 쓰여지기 전에 출력 버퍼가 지워집니다.</target>
        </trans-unit>
        <trans-unit id="badd301fd65baa8719ba53ea1a80949656267442" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Append&lt;/code&gt; is enabled, the file will be opened in append mode. Otherwise the contents of the file, if any, will be truncated before any compressed data is written to it.</source>
          <target state="translated">만약 &lt;code&gt;Append&lt;/code&gt; 활성화되어, 파일이 추가 모드에서 열립니다. 그렇지 않으면 압축 된 데이터가 파일에 기록되기 전에 파일의 내용이 잘립니다.</target>
        </trans-unit>
        <trans-unit id="1454be0505ecbcd6144a8007fb6e1b0593fddf1e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Append&lt;/code&gt; is enabled, the file will be opened in append mode. Otherwise the contents of the file, if any, will be truncated before any uncompressed data is written to it.</source>
          <target state="translated">만약 &lt;code&gt;Append&lt;/code&gt; 활성화되어, 파일이 추가 모드에서 열립니다. 그렇지 않으면 압축되지 않은 데이터가 파일에 기록되기 전에 파일의 내용이 잘립니다.</target>
        </trans-unit>
        <trans-unit id="65081513c33900b0638266063d522dfa1dd85637" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Append&lt;/code&gt; is enabled, the filehandle will be positioned to the end of the file via a call to &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; before any compressed data is written to it. Otherwise the file pointer will not be moved.</source>
          <target state="translated">&lt;code&gt;Append&lt;/code&gt; 가 활성화 된 경우 파일 핸들은 &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 요청을 통해 파일 끝에 배치됩니다. 압축 된 데이터가 기록되기 전에 합니다. 그렇지 않으면 파일 포인터가 이동되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="26fb68f8b046494190d2e776943c032f469c5adb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Append&lt;/code&gt; is enabled, the filehandle will be positioned to the end of the file via a call to &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; before any uncompressed data is written to it. Otherwise the file pointer will not be moved.</source>
          <target state="translated">&lt;code&gt;Append&lt;/code&gt; 가 활성화 된 경우 파일 핸들은 &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 요청을 통해 파일 끝에 배치됩니다. 모든 비 압축 데이터가 기록되기 전에. 그렇지 않으면 파일 포인터가 이동되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a8cc3d0792e66bfb9901cb16087529158d209e53" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;anyinflate&lt;/code&gt; has completed.</source>
          <target state="translated">경우 &lt;code&gt;AutoClose&lt;/code&gt; 지정되고, 그 값에 해당하고, 그 후에 폐쇄되는 모든 입력 및 / 또는 출력 파일 핸들을 초래할 것이다 &lt;code&gt;anyinflate&lt;/code&gt; 가 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="6e70bd36d1a537ad13b970c5e3018a8db164c8ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;anyuncompress&lt;/code&gt; has completed.</source>
          <target state="translated">경우 &lt;code&gt;AutoClose&lt;/code&gt; 지정되고, 그 값에 해당하고, 그 후에 폐쇄되는 모든 입력 및 / 또는 출력 파일 핸들을 초래할 것이다 &lt;code&gt;anyuncompress&lt;/code&gt; 가 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="c9769aa738284afde961b2f9bd816825ddcd7550" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;bunzip2&lt;/code&gt; has completed.</source>
          <target state="translated">경우 &lt;code&gt;AutoClose&lt;/code&gt; 지정되고, 그 값에 해당하고, 그 후에 폐쇄되는 모든 입력 및 / 또는 출력 파일 핸들을 초래할 것 &lt;code&gt;bunzip2&lt;/code&gt; 는이 완성되었다.</target>
        </trans-unit>
        <trans-unit id="45ce2b192ba4b06ccb81a9f97e89861c03acbbf0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;bzip2&lt;/code&gt; has completed.</source>
          <target state="translated">경우 &lt;code&gt;AutoClose&lt;/code&gt; 지정되고, 그 값에 해당하고, 그 후에 폐쇄되는 모든 입력 및 / 또는 출력 파일 핸들을 초래할 것 &lt;code&gt;bzip2&lt;/code&gt; 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="931b26269125b502ee9a79f1079ca4ffe0db45ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;deflate&lt;/code&gt; has completed.</source>
          <target state="translated">경우 &lt;code&gt;AutoClose&lt;/code&gt; 지정되고, 그 값에 해당하고, 그 후에 폐쇄되는 모든 입력 및 / 또는 출력 파일 핸들을 초래할 것 &lt;code&gt;deflate&lt;/code&gt; 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="e1fd436eb74e99c1011e676ef2d33a7ca8f221d0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;gunzip&lt;/code&gt; has completed.</source>
          <target state="translated">경우 &lt;code&gt;AutoClose&lt;/code&gt; 지정되고, 그 값에 해당하고, 그 후에 폐쇄되는 모든 입력 및 / 또는 출력 파일 핸들을 초래할 것 &lt;code&gt;gunzip&lt;/code&gt; 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="88e88b090b73765991b48faaa8220edbbe4df365" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;gzip&lt;/code&gt; has completed.</source>
          <target state="translated">경우 &lt;code&gt;AutoClose&lt;/code&gt; 지정되고, 그 값에 해당하고, 그 후에 폐쇄되는 모든 입력 및 / 또는 출력 파일 핸들을 초래할 것이다 &lt;code&gt;gzip&lt;/code&gt; 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="a90d9e6b94ea9918e75047142b2356a3ca3ce954" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;inflate&lt;/code&gt; has completed.</source>
          <target state="translated">경우 &lt;code&gt;AutoClose&lt;/code&gt; 지정되고, 그 값에 해당하는, 모든 입력 및 / 또는 출력 파일 핸들을 초래할 것이다 일단 폐쇄 &lt;code&gt;inflate&lt;/code&gt; 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="8a6b1372a509b879eaf5e2572538481635eccd1a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;rawdeflate&lt;/code&gt; has completed.</source>
          <target state="translated">경우 &lt;code&gt;AutoClose&lt;/code&gt; 지정되고, 그 값에 해당하는, 모든 입력 및 / 또는 출력 파일 핸들을 초래할 것이다 일단 폐쇄 &lt;code&gt;rawdeflate&lt;/code&gt; 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="49cd128d450ba32be8b448e6b5ad08dbf2c6fedd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;rawinflate&lt;/code&gt; has completed.</source>
          <target state="translated">경우 &lt;code&gt;AutoClose&lt;/code&gt; 지정되고, 그 값에 해당하는, 모든 입력 및 / 또는 출력 파일 핸들을 초래할 것이다 일단 폐쇄 &lt;code&gt;rawinflate&lt;/code&gt; 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="c0389ec2b7c0d6d8486da6034ee7b237f00728a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;unzip&lt;/code&gt; has completed.</source>
          <target state="translated">경우 &lt;code&gt;AutoClose&lt;/code&gt; 지정되고, 그 값에 해당하는, 모든 입력 및 / 또는 출력 파일 핸들을 초래할 것이다 한번 폐쇄되고 &lt;code&gt;unzip&lt;/code&gt; 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="b28f338327748e0ed3d3b45714c8c08b6240edf4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;zip&lt;/code&gt; has completed.</source>
          <target state="translated">경우 &lt;code&gt;AutoClose&lt;/code&gt; 지정되고, 그 값에 해당하는, 모든 입력 및 / 또는 출력 파일 핸들을 초래할 것이다 일단 폐쇄 &lt;code&gt;zip&lt;/code&gt; 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="2f369078e4170f80457a1f35c7563da5a1cc6678" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Blocking&lt;/code&gt; is set to 0, the connection will be in nonblocking mode. If not specified it defaults to 1 (blocking mode).</source>
          <target state="translated">&lt;code&gt;Blocking&lt;/code&gt; 경우 0으로 설정, 연결 모드 블로킹에있을 것입니다. 지정하지 않으면 기본값은 1 (차단 모드)입니다.</target>
        </trans-unit>
        <trans-unit id="27ca4e9e26da273f75ec2f01acbae00f6340bacd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DATA&lt;/code&gt; is not specified then the result will indicate that the server wishes the data to be sent. The data must then be sent using the &lt;code&gt;datasend&lt;/code&gt; and &lt;code&gt;dataend&lt;/code&gt; methods described in &lt;a href=&quot;cmd&quot;&gt;Net::Cmd&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;DATA&lt;/code&gt; 지정되지 않은 결과는 서버에서 전송되는 데이터를 원하는 것으로 표시됩니다. 그런 다음 &lt;a href=&quot;cmd&quot;&gt;Net :: Cmd에&lt;/a&gt; 설명 된 &lt;code&gt;datasend&lt;/code&gt; 및 &lt;code&gt;dataend&lt;/code&gt; 메소드를 사용하여 데이터를 보내야합니다. .</target>
        </trans-unit>
        <trans-unit id="a2e077eab3d667c955449b8c582fa6b4685309db" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ExactAddresses&lt;/code&gt; is passed to the constructor, then addresses should be a valid rfc2821-quoted address, although Net::SMTP will accept the address surrounded by angle brackets.</source>
          <target state="translated">만약 &lt;code&gt;ExactAddresses&lt;/code&gt; 가 생성자에 전달 Net :: SMTP는 꺾쇠 괄호로 묶은 주소를 허용하지만 주소는 유효한 rfc2821 인용 주소 여야합니다.</target>
        </trans-unit>
        <trans-unit id="3d6f9a7de111ad6f15c5cac01bf2df035fda0020" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FH&lt;/code&gt; is specified then it is expected to be a valid filehandle and the result will be printed to it, on success a true value will be returned. If &lt;code&gt;FH&lt;/code&gt; is not specified then the return value, on success, will be a reference to an array containing the article requested, each entry in the array will contain one line of the article.</source>
          <target state="translated">&lt;code&gt;FH&lt;/code&gt; 가 지정 되면 유효한 파일 핸들이 될 것으로 예상되고 결과가 인쇄되며 성공하면 true 값이 리턴됩니다. &lt;code&gt;FH&lt;/code&gt; 인 경우 다음 성공 반환 값을 지정하지 않고, 요청 된 문서를 포함하는 배열을 참조 할 것, 어레이의 각 항목은 문서의 한 행을 포함 할 것이다.</target>
        </trans-unit>
        <trans-unit id="dcf85df21ad4f13a17a67e275700748df1fd4365" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Features&lt;/code&gt; method reports a feature &lt;code&gt;attribs&lt;/code&gt; as present, the method &lt;code&gt;Attribs&lt;/code&gt; is not dummy.</source>
          <target state="translated">경우 &lt;code&gt;Features&lt;/code&gt; 방법은 기능보고 &lt;code&gt;attribs&lt;/code&gt; 선물로를, 방법 &lt;code&gt;Attribs&lt;/code&gt; 은 더미 없습니다.</target>
        </trans-unit>
        <trans-unit id="4e81c8aad04f59a1692e53f2e58534a0dee91bde" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;File&lt;/code&gt; inherited from &lt;code&gt;DataSource&lt;/code&gt; , which inherited from &lt;code&gt;Thing&lt;/code&gt; , then Perl would keep looking &quot;up the chain&quot; if necessary.</source>
          <target state="translated">경우, &lt;code&gt;File&lt;/code&gt; 로부터 상속 된 &lt;code&gt;DataSource&lt;/code&gt; 로부터 상속, &lt;code&gt;Thing&lt;/code&gt; , 다음 펄이 필요한 경우 &quot;체인까지&quot;계속 찾고있다.</target>
        </trans-unit>
        <trans-unit id="871f80a19c627be0f52c1b6ef1cd6cbad1358e34" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FileHandle::open&lt;/code&gt; is given a numeric mode, it passes that mode and the optional permissions value to the Perl &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; operator. For convenience, &lt;code&gt;FileHandle::import&lt;/code&gt; tries to import the O_XXX constants from the Fcntl module. If dynamic loading is not available, this may fail, but the rest of FileHandle will still work.</source>
          <target state="translated">경우 &lt;code&gt;FileHandle::open&lt;/code&gt; 숫자 모드를 주어, 그 모드와 펄에 대한 선택 권한 값 전달 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 연산자를. 편의상 &lt;code&gt;FileHandle::import&lt;/code&gt; 는 Fcntl 모듈에서 O_XXX 상수를 가져 시도합니다. 동적 로딩을 사용할 수 없으면 실패 할 수 있지만 나머지 FileHandle은 여전히 ​​작동합니다.</target>
        </trans-unit>
        <trans-unit id="bb1f139d098c0a906b0eeef1ef6e5dc6d9836cd4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FileHandle::open&lt;/code&gt; receives a Perl mode string (&quot;&amp;gt;&quot;, &quot;+&amp;lt;&quot;, etc.) or a POSIX fopen() mode string (&quot;w&quot;, &quot;r+&quot;, etc.), it uses the basic Perl &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">경우 &lt;code&gt;FileHandle::open&lt;/code&gt; 펄 모드 문자열을 수신한다 ( &quot;&amp;gt;&quot;, &quot;+는 &amp;lt;&quot;, 등) 또는 (등 &quot;w&quot;, &quot;R +&quot;)는 POSIX는 fopen 모드 () 문자열, 상기 기본 펄 사용 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 운영자.</target>
        </trans-unit>
        <trans-unit id="a2feaf81d0c85e64b59f8f9c85179dcb22ae1819" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GLOB_NOSORT&lt;/code&gt; is not in effect, sort filenames is alphabetical order (case does not matter) rather than in ASCII order.</source>
          <target state="translated">경우 &lt;code&gt;GLOB_NOSORT&lt;/code&gt; 가 유효하지 않다, 종류의 파일 이름 알파벳 순서 오히려 ASCII 순서보다 (경우는 문제가되지 않습니다)입니다.</target>
        </trans-unit>
        <trans-unit id="67e8ee96965d8f4239b93f54928c2446de8f1552" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GNU&lt;/code&gt; cc (gcc) is used, this variable holds &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;2&lt;/code&gt; to indicate whether the compiler is version 1 or 2. This is used in setting some of the default cflags. It is set to '' if not gcc.</source>
          <target state="translated">경우 &lt;code&gt;GNU&lt;/code&gt; 의 CC (GCC)을 사용하고,이 변수는 보유 &lt;code&gt;1&lt;/code&gt; 또는 &lt;code&gt;2&lt;/code&gt; 컴파일러 버전 1 또는 2.이 기본 CFLAGS의 일부를 설정하는 데 사용되어 있는지 여부를 나타냅니다. gcc가 아닌 경우 ''로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="ee184683f7c3453d93a7bedbc7d10e7e2d4b99bb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GNU&lt;/code&gt; cc (gcc) is used, this variable holds the operating system and version used to compile gcc. It is set to '' if not gcc, or if nothing useful can be parsed as the os version.</source>
          <target state="translated">경우 &lt;code&gt;GNU&lt;/code&gt; 의 CC (GCC)가 사용되며,이 변수는 컴파일 GCC에 사용되는 운영 체제 및 버전을 보유하고 있습니다. gcc가 아닌 경우 또는 ''os 버전으로 구문 분석 할 수있는 내용이없는 경우 ''로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="c7c81dd0bd77cba1c688390cdf8b5eb031575d80" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GNU&lt;/code&gt; cc (gcc) is used, this variable will enable (if set) the -ansi and -pedantic ccflags for building core files (through cflags script). (See</source>
          <target state="translated">경우 &lt;code&gt;GNU&lt;/code&gt; 의 CC (GCC)가 사용되며,이 변수 (CFLAGS 스크립트를 통해) 코어 파일을 구축 (설정되는 경우) -ansi와 -pedantic ccflags 수있게된다. (보다</target>
        </trans-unit>
        <trans-unit id="0efd17fe9103ee1aaae0dc765c4fdcda7599e53f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IO::File::open&lt;/code&gt; is given a mode that includes the &lt;code&gt;:&lt;/code&gt; character, it passes all the three arguments to the three-argument &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">경우 &lt;code&gt;IO::File::open&lt;/code&gt; 포함하는 모드 주어진다 &lt;code&gt;:&lt;/code&gt; 문자를,이 세 가지 인수에 대한 모든 세 개의 인수를 전달 &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 연산자를.</target>
        </trans-unit>
        <trans-unit id="6b022840a97cd5dd7f3b791be6eab1e939aa4189" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IO::File::open&lt;/code&gt; is given a numeric mode, it passes that mode and the optional permissions value to the Perl &lt;code&gt;&lt;a href=&quot;../functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; operator. The permissions default to 0666.</source>
          <target state="translated">경우 &lt;code&gt;IO::File::open&lt;/code&gt; 숫자 모드를 주어, 그 모드와 펄에 대한 선택 권한 값 전달 &lt;code&gt;&lt;a href=&quot;../functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 연산자를. 사용 권한의 기본값은 0666입니다.</target>
        </trans-unit>
        <trans-unit id="53e83efe8c19dc0d9571afae7a20a9dcda69bd25" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IO::File::open&lt;/code&gt; receives a Perl mode string (&quot;&amp;gt;&quot;, &quot;+&amp;lt;&quot;, etc.) or an ANSI C fopen() mode string (&quot;w&quot;, &quot;r+&quot;, etc.), it uses the basic Perl &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; operator (but protects any special characters).</source>
          <target state="translated">경우 &lt;code&gt;IO::File::open&lt;/code&gt; 펄 모드 문자열을 수신한다 ( &quot;&amp;gt;&quot;, &quot;+는 &amp;lt;&quot;, 등) 또는 ANSI C는 fopen 모드 () 문자열 ( &quot;w&quot;, &quot;R +&quot;등)는 사용 기본 Perl &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 연산자 (특수 문자는 보호)</target>
        </trans-unit>
        <trans-unit id="25244641705396e9c5a0c603f886177852688f85" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LIST OF FILES TO TEST&lt;/code&gt; is omitted, the file list is obtained from the manifest. The file list may include shell wildcards which will be expanded out.</source>
          <target state="translated">경우 &lt;code&gt;LIST OF FILES TO TEST&lt;/code&gt; 생략 된 파일 목록은 매니페스트에서 얻을 수있다. 파일 목록에는 확장 될 쉘 와일드 카드가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc047fe00993cc36f1bde2a682c140574f3968b4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Level =&amp;gt; Z_BEST_SPEED&lt;/code&gt; has been specified then XFL is set to 2. If &lt;code&gt;Level =&amp;gt; Z_BEST_COMPRESSION&lt;/code&gt; has been specified then XFL is set to 4. Otherwise XFL is set to 0.</source>
          <target state="translated">경우 &lt;code&gt;Level =&amp;gt; Z_BEST_SPEED&lt;/code&gt; 다음 지정 XFL은 2로 설정되어있는 경우 &lt;code&gt;Level =&amp;gt; Z_BEST_COMPRESSION&lt;/code&gt; XFL은 그렇지 XFL을 0으로 설정 4로 설정 한 후 지정되었습니다.</target>
        </trans-unit>
        <trans-unit id="0aa2ad74e8011287eeea7635ab9b549166e0107b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LimitOutput&lt;/code&gt; is enabled, the &lt;code&gt;ConsumeInput&lt;/code&gt; option will also be enabled.</source>
          <target state="translated">경우 &lt;code&gt;LimitOutput&lt;/code&gt; 이 활성화되면, &lt;code&gt;ConsumeInput&lt;/code&gt; 의 옵션도 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="6b5272a0252e677f68469c99e247e850a281513f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Listen&lt;/code&gt; is defined then a listen socket is created, else if the socket type, which is derived from the protocol, is SOCK_STREAM then connect() is called. If the &lt;code&gt;Listen&lt;/code&gt; argument is given, but false, the queue size will be set to 5.</source>
          <target state="translated">경우 &lt;code&gt;Listen&lt;/code&gt; 다음 정의 된 프로토콜에서 파생 된 소켓 형이 호출 한 후 연결 SOCK_STREAM가 () 인 경우는, 소켓이 생성됩니다 다른 들어요. 는 IF &lt;code&gt;Listen&lt;/code&gt; 인수가 주어하지만 거짓되고, 큐 크기는 5로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="119d044a27ad244e9922efb2919b95739dfc6f48" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MESSAGE-SPEC&lt;/code&gt; is a reference to a list of two message numbers and the second number in a range is less than or equal to the first then the range represents all messages in the group after the first message number.</source>
          <target state="translated">경우 &lt;code&gt;MESSAGE-SPEC&lt;/code&gt; 보다 적은 두 메시지 번호 목록과 범위 제 번호에 대한 참조 또는 우선 범위와 동일한 제 1 메시지 번호 뒤에 그룹의 모든 메시지를 의미한다.</target>
        </trans-unit>
        <trans-unit id="8fae31070991ff1f03f3487ee3feed2b35c28afa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MESSAGE&lt;/code&gt; is not specified then the message must be sent using the &lt;code&gt;datasend&lt;/code&gt; and &lt;code&gt;dataend&lt;/code&gt; methods from &lt;a href=&quot;cmd&quot;&gt;Net::Cmd&lt;/a&gt;</source>
          <target state="translated">경우 &lt;code&gt;MESSAGE&lt;/code&gt; 지정되지 메시지가 사용하여 전송해야 &lt;code&gt;datasend&lt;/code&gt; 및 &lt;code&gt;dataend&lt;/code&gt; 에서 방법 &lt;a href=&quot;cmd&quot;&gt;넷 :: Cmd를&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b4f8b5e83cced9672fcf844844603c4b1519fbeb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NEXT&lt;/code&gt; redispatching is used in the methods of a &quot;diamond&quot; class hierarchy:</source>
          <target state="translated">&quot;다이아몬드&quot;클래스 계층의 메소드에서 &lt;code&gt;NEXT&lt;/code&gt; 재배포가 사용되는 경우 :</target>
        </trans-unit>
        <trans-unit id="fa6cc1f17445fc581970662d0c27067922cd4606" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is not specified and the &lt;code&gt;$input&lt;/code&gt; parameter is a filename, the value of &lt;code&gt;$input&lt;/code&gt; will be used for the zip filename header field.</source>
          <target state="translated">경우 &lt;code&gt;Name&lt;/code&gt; 지정하지 않 &lt;code&gt;$input&lt;/code&gt; 매개 변수가 파일 이름입니다,의 값 &lt;code&gt;$input&lt;/code&gt; 압축 파일 이름 헤더 필드에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="16fa552eaed310969186dcb3a6fc9c674d262d84" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is not specified and the &lt;code&gt;$input&lt;/code&gt; parameter is not a filename, no zip filename field will be created.</source>
          <target state="translated">경우 &lt;code&gt;Name&lt;/code&gt; 지정되지하고있다 &lt;code&gt;$input&lt;/code&gt; 매개 변수가 파일 이름이 아니라, 더 압축 파일 이름 필드는 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="35533bcb02c546225ef493f044a6f536db7a71c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PERL_SCAN_ALLOW_UNDERSCORES&lt;/code&gt; is set in</source>
          <target state="translated">&lt;code&gt;PERL_SCAN_ALLOW_UNDERSCORES&lt;/code&gt; 가 설정된 경우</target>
        </trans-unit>
        <trans-unit id="52cb6eab9df9b80f7b8043595e084ea362a195f8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; environment variable is set, it will be used as a command for comparing unexpected multiline results. If you have GNU diff installed, you might want to set &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; to &lt;code&gt;diff -u&lt;/code&gt; . If you don't have a suitable program, you might install the &lt;code&gt;Text::Diff&lt;/code&gt; module and then set &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; to be &lt;code&gt;perl
-MText::Diff -e 'print diff(@ARGV)'&lt;/code&gt; . If &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; isn't set but the &lt;code&gt;Algorithm::Diff&lt;/code&gt; module is available, then it will be used to show the differences in multiline results.</source>
          <target state="translated">경우 &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; 의 환경 변수가 설정되어, 그것은 예기치 않은 여러 결과를 비교하기위한 명령으로 사용됩니다. GNU diff가 설치되어 있으면 &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; 를 &lt;code&gt;diff -u&lt;/code&gt; 로 설정하려고 할 수 있습니다 . 적합한 프로그램이없는 경우 &lt;code&gt;Text::Diff&lt;/code&gt; 모듈을 설치 한 다음 &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; 를 &lt;code&gt;perl -MText::Diff -e 'print diff(@ARGV)'&lt;/code&gt; 로 설정할 수 있습니다 . 경우 &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; 가 설정하지만되지 않은 &lt;code&gt;Algorithm::Diff&lt;/code&gt; 모듈을 사용할 수, 다음은 여러 결과의 차이를 표시하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dee3b30e6a54d64d92736caa387fa1fa00014452" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PerlIO_push&lt;/code&gt; was performed and open has failed, it must &lt;code&gt;PerlIO_pop&lt;/code&gt; itself, since if it's not, the layer won't be removed and may cause bad problems.</source>
          <target state="translated">경우 &lt;code&gt;PerlIO_push&lt;/code&gt; 이 수행 된 오픈에 실패했습니다, 그것은해야한다 &lt;code&gt;PerlIO_pop&lt;/code&gt; 그렇지 않은 경우, 층이 제거되지 않기 때문에, 그 자체를 나쁜 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e92add0536c750719a7004e9b389b82f89f36216" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Proto&lt;/code&gt; is not given and you specify a symbolic &lt;code&gt;PeerPort&lt;/code&gt; port, then the constructor will try to derive &lt;code&gt;Proto&lt;/code&gt; from the service name. As a last resort &lt;code&gt;Proto&lt;/code&gt; &quot;tcp&quot; is assumed. The &lt;code&gt;Type&lt;/code&gt; parameter will be deduced from &lt;code&gt;Proto&lt;/code&gt; if not specified.</source>
          <target state="translated">경우 &lt;code&gt;Proto&lt;/code&gt; 주어지지하고 상징적 지정 &lt;code&gt;PeerPort&lt;/code&gt; 의 포트를 다음 생성자를 도출하기 위해 노력할 것입니다 &lt;code&gt;Proto&lt;/code&gt; 서비스 이름에서. 최후의 수단으로 &lt;code&gt;Proto&lt;/code&gt; &quot;tcp&quot;가 가정됩니다. &lt;code&gt;Type&lt;/code&gt; 매개 변수를 추론됩니다 &lt;code&gt;Proto&lt;/code&gt; 지정되지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="fe5b8d2d2cf1b0bc68bdf3e0b890723eb0712304" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SkipBad&lt;/code&gt; is true the &lt;code&gt;recipient&lt;/code&gt; will not return an error when a bad address is encountered and it will return an array of addresses that did succeed.</source>
          <target state="translated">경우 &lt;code&gt;SkipBad&lt;/code&gt; 는 사실이다 &lt;code&gt;recipient&lt;/code&gt; 잘못된 주소가 발견 될 때 오류를 반환하지 않습니다 그것은 성공 않았다 주소의 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d0468225999e79fdda0c8dc21ac9ecaa76acd0e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Strict&lt;/code&gt; is enabled the following behaviour will be policed:</source>
          <target state="translated">경우 &lt;code&gt;Strict&lt;/code&gt; IS가 활성화 된 다음과 같은 동작이 치안을한다 :</target>
        </trans-unit>
        <trans-unit id="b96d3e92a2737a01f8355b6b1112adb835436235" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;TIMEOUT&lt;/code&gt; is missing, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, or less than or equal to 0, then this call behaves the same as &lt;code&gt;dequeue_nb&lt;/code&gt; .</source>
          <target state="translated">경우 &lt;code&gt;TIMEOUT&lt;/code&gt; 가 누락 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 또는 작거나 0보다,이 호출은 동일하게 동작 &lt;code&gt;dequeue_nb&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b3dbb2f4f8d2f84122800f9964093173fd31ae6b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Tie::File&lt;/code&gt; 's memory limit is large enough, all the writing will done in memory. Then, when you call &lt;code&gt;-&amp;gt;flush&lt;/code&gt; , the entire file will be rewritten in a single pass.</source>
          <target state="translated">경우 &lt;code&gt;Tie::File&lt;/code&gt; 의 메모리 제한이 충분히 큰이며, 모든 쓰기는 메모리에서 수행됩니다. 그런 다음 &lt;code&gt;-&amp;gt;flush&lt;/code&gt; 를 호출 하면 전체 파일이 단일 패스로 다시 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="717bb6fc0375ed7c5d36f69b6a41d7203067aa19" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;UCA_Version&lt;/code&gt; is 26 or later, the &lt;code&gt;identical&lt;/code&gt; level is preferred; &lt;code&gt;Unicode::Collate-&amp;gt;new(identical =&amp;gt; 1)&lt;/code&gt; and &lt;code&gt;Unicode::Collate-&amp;gt;new(identical =&amp;gt; 1,&lt;/code&gt;&lt;code&gt;variable =&amp;gt; &quot;non-ignorable&quot;, level =&amp;gt; 3)&lt;/code&gt; should be used.</source>
          <target state="translated">경우 &lt;code&gt;UCA_Version&lt;/code&gt; 가 26 이상이되면, &lt;code&gt;identical&lt;/code&gt; 레벨이 바람직하다; &lt;code&gt;Unicode::Collate-&amp;gt;new(identical =&amp;gt; 1)&lt;/code&gt; 및 &lt;code&gt;Unicode::Collate-&amp;gt;new(identical =&amp;gt; 1,&lt;/code&gt; &lt;code&gt;variable =&amp;gt; &quot;non-ignorable&quot;, level =&amp;gt; 3)&lt;/code&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="02434c0e062f79bd3d8c8ef802e8385afcfb68a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;UCA_Version&lt;/code&gt; is equal to or greater than 14, default is &lt;code&gt;[]&lt;/code&gt; (i.e. no rearrangement).</source>
          <target state="translated">경우 &lt;code&gt;UCA_Version&lt;/code&gt; 는 같거나 14보다 큰 경우, 디폴트는 없다 &lt;code&gt;[]&lt;/code&gt; (즉, 어떠한 재 배열).</target>
        </trans-unit>
        <trans-unit id="b309f1cb237c3cb1331fc5e7c80d1a3dc5b1ba82" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;VALUE&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; then the debug level will be set to the default debug level for the class.</source>
          <target state="translated">&lt;code&gt;VALUE&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 인 경우 디버그 레벨은 클래스의 기본 디버그 레벨로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="44072f8a4414482a73ce8e1b198996a838545678" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;WHERE&lt;/code&gt; is given then the first &lt;code&gt;WHERE&lt;/code&gt; bytes of the file will not be transferred, and the remaining bytes will be appended to the local file if it already exists.</source>
          <target state="translated">만약 &lt;code&gt;WHERE&lt;/code&gt; 다음 첫 번째 주어진 &lt;code&gt;WHERE&lt;/code&gt; 파일의 바이트가 전송되지 않습니다, 그리고 이미 존재하는 경우 나머지 바이트는 로컬 파일에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="3cdf8e9a5929ab26a43f519805188b99c5f0b522" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;appendOutput&lt;/code&gt; is enabled in the constructor for the bunzip2 object, the uncompressed data will be appended to &lt;code&gt;$output&lt;/code&gt; . If not enabled, &lt;code&gt;$output&lt;/code&gt; will be truncated before the uncompressed data is written to it.</source>
          <target state="translated">bunzip2 오브젝트의 생성자에서 &lt;code&gt;appendOutput&lt;/code&gt; 이 사용 가능한 경우 압축되지 않은 데이터가 &lt;code&gt;$output&lt;/code&gt; 추가됩니다 . 사용하지 않으면 압축되지 않은 데이터가 쓰기 전에 &lt;code&gt;$output&lt;/code&gt; 이 잘립니다.</target>
        </trans-unit>
        <trans-unit id="f450b4455b8d11ffbd473a1bb2010cafedaed33e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;appendOutput&lt;/code&gt; is enabled in the constructor for the bzip2 object, the compressed data will be appended to &lt;code&gt;$output&lt;/code&gt; . If not enabled, &lt;code&gt;$output&lt;/code&gt; will be truncated before the compressed data is written to it.</source>
          <target state="translated">bzip2 객체의 생성자에서 &lt;code&gt;appendOutput&lt;/code&gt; 이 활성화 된 경우 압축 된 데이터가 &lt;code&gt;$output&lt;/code&gt; 추가됩니다 . 사용하지 않으면 압축 된 데이터를 쓰기 전에 &lt;code&gt;$output&lt;/code&gt; 이 잘립니다.</target>
        </trans-unit>
        <trans-unit id="1b199e24b4ee7d3c552a01dcb6637c8cc3a9e1f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bundling_override&lt;/code&gt; is enabled, bundling is enabled as with &lt;code&gt;bundling&lt;/code&gt; but now long option names override option bundles.</source>
          <target state="translated">경우 &lt;code&gt;bundling_override&lt;/code&gt; 가 활성화되어 번들은에서와 같이 사용할 수 있습니다 &lt;code&gt;bundling&lt;/code&gt; 하지만 지금은 긴 옵션 이름 재정의 옵션 번들.</target>
        </trans-unit>
        <trans-unit id="e3dc97ff755fb934bfd6f1a8ed830ff62cc4e40b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;consumeInput&lt;/code&gt; is enabled in the constructor for the bunzip2 object, &lt;code&gt;$input&lt;/code&gt; will have all compressed data removed from it after uncompression. On &lt;code&gt;BZ_OK&lt;/code&gt; return this will mean that &lt;code&gt;$input&lt;/code&gt; will be an empty string; when &lt;code&gt;BZ_STREAM_END&lt;/code&gt;&lt;code&gt;$input&lt;/code&gt; will either be an empty string or will contain whatever data immediately followed the compressed data stream.</source>
          <target state="translated">bunzip2 오브젝트의 생성자에서 &lt;code&gt;consumeInput&lt;/code&gt; 이 사용 가능한 경우 , &lt;code&gt;$input&lt;/code&gt; 은 압축 해제 후 모든 압축 된 데이터가 제거됩니다. 에 &lt;code&gt;BZ_OK&lt;/code&gt; 이 있음을 의미합니다 반환 &lt;code&gt;$input&lt;/code&gt; 빈 문자열이 될 것이다; &lt;code&gt;BZ_STREAM_END&lt;/code&gt; &lt;code&gt;$input&lt;/code&gt; 이 빈 문자열이거나 압축 된 데이터 스트림 바로 뒤에 오는 모든 데이터를 포함 할 때</target>
        </trans-unit>
        <trans-unit id="d1dd05ec9d332008df8a7389201274fce30d7a10" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cv&lt;/code&gt; is a constant sub eligible for inlining, returns the constant value returned by the sub. Otherwise, returns NULL.</source>
          <target state="translated">&lt;code&gt;cv&lt;/code&gt; 가 인라인 할 수있는 상수 하위 인 경우 하위에서 반환 한 상수 값을 반환합니다. 그렇지 않으면 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d37d86734f002378b0c0f7d856f9af361e68cbc0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;done_testing()&lt;/code&gt; is called twice, the second call will issue a failing test.</source>
          <target state="translated">경우 &lt;code&gt;done_testing()&lt;/code&gt; 두 번 호출되고, 두 번째 호출은 실패 테스트를 발행합니다.</target>
        </trans-unit>
        <trans-unit id="a074a15a27ab0ac63397d85c19569d7f123797eb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;down()&lt;/code&gt; attempts to decrement the counter below zero, it blocks until the counter is large enough. Note that while a semaphore can be created with a starting count of zero, any &lt;code&gt;up()&lt;/code&gt; or &lt;code&gt;down()&lt;/code&gt; always changes the counter by at least one, and so &lt;code&gt;$semaphore-&amp;gt;down(0)&lt;/code&gt; is the same as &lt;code&gt;$semaphore-&amp;gt;down(1)&lt;/code&gt; .</source>
          <target state="translated">경우 &lt;code&gt;down()&lt;/code&gt; 시도가 영하 카운터를 감소하기 위해서는 블록 카운터가 충분히 큰 때까지. 시작 카운트가 0 인 세마포어를 만들 수 있지만, &lt;code&gt;up()&lt;/code&gt; 또는 &lt;code&gt;down()&lt;/code&gt; 항상 카운터를 하나 이상 변경하므로 &lt;code&gt;$semaphore-&amp;gt;down(0)&lt;/code&gt; 은 &lt;code&gt;$semaphore-&amp;gt;down(1)&lt;/code&gt; 와 같습니다. down (1) .</target>
        </trans-unit>
        <trans-unit id="40ba804a2596516d0c1570f7f282c973ab9c2345" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;extract&lt;/code&gt; is called without a list of file names, the entire contents of the archive are extracted.</source>
          <target state="translated">경우 &lt;code&gt;extract&lt;/code&gt; 파일 이름 목록없이 호출, 아카이브의 전체 내용이 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="fd1942906fddd7c45d5614b21cfa194ab92d3708" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fallback&lt;/code&gt; is TRUE for both operands then perform the usual operation for the operator, treating the operands as numbers, strings, or booleans as appropriate for the operator (see note).</source>
          <target state="translated">두 피연산자 모두에 대해 &lt;code&gt;fallback&lt;/code&gt; 가 참 이면 피연산자를 연산자에 적합한 숫자, 문자열 또는 부울로 처리하여 연산자에 대해 일반적인 작업을 수행하십시오 (주 참조).</target>
        </trans-unit>
        <trans-unit id="5fd52e0f8326669fc207b7050c548b0008ac0b17" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; &amp;amp; SV_SMAGIC is true, will call SvSETMAGIC. If &lt;code&gt;flags&lt;/code&gt; &amp;amp; SV_HAS_TRAILING_NUL is true, then &lt;code&gt;ptr[len]&lt;/code&gt; must be &lt;code&gt;NUL&lt;/code&gt; , and the realloc will be skipped (i.e. the buffer is actually at least 1 byte longer than &lt;code&gt;len&lt;/code&gt; , and already meets the requirements for storing in &lt;code&gt;SvPVX&lt;/code&gt; ).</source>
          <target state="translated">경우 &lt;code&gt;flags&lt;/code&gt; 및 SV_SMAGIC이 참, SvSETMAGIC를 호출합니다. 경우 &lt;code&gt;flags&lt;/code&gt; 및 SV_HAS_TRAILING_NUL 해당하는 다음 &lt;code&gt;ptr[len]&lt;/code&gt; 있어야 &lt;code&gt;NUL&lt;/code&gt; 및 realloc을 스킵한다 (즉, 버퍼는보다 적어도 1 바이트 이상 실제로 &lt;code&gt;len&lt;/code&gt; 및 이미 기억 요건을 충족 &lt;code&gt;SvPVX&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0edc0d40cf1bae07e3194b59cda754464ac0af29" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; does not include the &lt;code&gt;G_DISCARD&lt;/code&gt; flag then &lt;code&gt;hv_delete&lt;/code&gt; will create and return a mortal copy of the deleted value.</source>
          <target state="translated">경우 &lt;code&gt;flags&lt;/code&gt; 인클루드하지 않는 &lt;code&gt;G_DISCARD&lt;/code&gt; 의 플래그를 다음 &lt;code&gt;hv_delete&lt;/code&gt; 는 생성하고 삭제 된 값의 인간의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="10df1aa8bd4f0824119d6cef9b8d19de3f0f48a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; has SV_FORCE_UTF8_UPGRADE set, this function assumes that the PV will expand when converted to UTF-8, and skips the extra work of checking for that. Typically this flag is used by a routine that has already parsed the string and found such characters, and passes this information on so that the work doesn't have to be repeated.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; 에 SV_FORCE_UTF8_UPGRADE가 설정되어 있으면 이 함수는 UTF-8로 변환 될 때 PV가 확장된다고 가정하고 추가 점검 작업을 건너 뜁니다. 일반적으로이 플래그는 이미 문자열을 구문 분석하고 해당 문자를 찾은 루틴에서 사용하며이 정보를 전달하여 작업을 반복 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="37b250f1c8aff9dcda9cab5ceb3c6ef02e048bcc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; has the &lt;code&gt;SV_SMAGIC&lt;/code&gt; bit set, will &lt;code&gt;mg_set&lt;/code&gt; on &lt;code&gt;dsv&lt;/code&gt; afterwards if appropriate. &lt;code&gt;sv_catpvn&lt;/code&gt; and &lt;code&gt;sv_catpvn_nomg&lt;/code&gt; are implemented in terms of this function.</source>
          <target state="translated">경우 &lt;code&gt;flags&lt;/code&gt; 이 &lt;code&gt;SV_SMAGIC&lt;/code&gt; 의 비트 세트를합니다 &lt;code&gt;mg_set&lt;/code&gt; 에 &lt;code&gt;dsv&lt;/code&gt; 필요한 경우 나중에. &lt;code&gt;sv_catpvn&lt;/code&gt; 및 &lt;code&gt;sv_catpvn_nomg&lt;/code&gt; 는이 기능의 관점에서 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="3ef48bc44bf4f8b7aeee22cccd386b0d4dcfb8f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;frame &amp;amp; 4&lt;/code&gt; , arguments to functions are printed, plus context and caller info. If &lt;code&gt;frame &amp;amp; 8&lt;/code&gt; , overloaded &lt;code&gt;stringify&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt;d &lt;code&gt;FETCH&lt;/code&gt; is enabled on the printed arguments. If &lt;code&gt;frame
&amp;amp; 16&lt;/code&gt; , the return value from the subroutine is printed.</source>
          <target state="translated">&lt;code&gt;frame &amp;amp; 4&lt;/code&gt; 인 경우 함수에 대한 인수와 컨텍스트 및 호출자 정보가 인쇄됩니다. &lt;code&gt;frame &amp;amp; 8&lt;/code&gt; 인 경우 , 인쇄 된 인수 에서 오버로드 &lt;code&gt;stringify&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; d &lt;code&gt;FETCH&lt;/code&gt; 가 활성화됩니다. &lt;code&gt;frame &amp;amp; 16&lt;/code&gt; 인 경우 서브 루틴의 리턴 값이 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="b54e3981c02655a1fab1a806eaa02120a0c9bfed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;function&lt;/code&gt; was the name of a function, then &lt;code&gt;memoize&lt;/code&gt; hides the old version and installs the new memoized version under the old name, so that &lt;code&gt;&amp;amp;function(...)&lt;/code&gt; actually invokes the memoized version.</source>
          <target state="translated">경우 &lt;code&gt;function&lt;/code&gt; 함수의 이름이고, 다음 &lt;code&gt;memoize&lt;/code&gt; 는 이전 버전을 숨기고 이전 이름으로 새로운 memoized 버전을 설치, 그래서 &lt;code&gt;&amp;amp;function(...)&lt;/code&gt; 실제로 memoized 버전을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="4823580da2e2f493ed7ea495228a6fb43531c2a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;get_handle&lt;/code&gt; senses that it's running in program that was invoked as a CGI, then it tries to get language-tags out of the environment variable &quot;HTTP_ACCEPT_LANGUAGE&quot;, and it pretends that those were the languages passed as parameters to &lt;code&gt;get_handle&lt;/code&gt; .</source>
          <target state="translated">경우 &lt;code&gt;get_handle&lt;/code&gt; 그것은 CGI로 호출 된 프로그램에서 실행중인 것을 감각, 다음은 환경 변수 &quot;HTTP_ACCEPT_LANGUAGE&quot;에서 언어 태그를 가져 오려고 시도하고, 그가에 매개 변수로 전달하는 언어라고 척 &lt;code&gt;get_handle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a5501c614e6eee43f2f2b50112bdb8a824a2fea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;gv&lt;/code&gt; is a completely empty typeglob, it is deleted from the stash.</source>
          <target state="translated">경우 &lt;code&gt;gv&lt;/code&gt; 완전히 빈 타입 글로브입니다, 그것은 숨김에서 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="171c792393c3bd16ce8492fbf51df1d34df47fa3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;gv&lt;/code&gt; is a typeglob containing only a sufficiently-ordinary constant sub, the typeglob is replaced with a scalar-reference placeholder that more compactly represents the same thing.</source>
          <target state="translated">&lt;code&gt;gv&lt;/code&gt; 가 충분히 일반적인 상수 서브 만 포함하는 타입 글로브 인 경우 , 타입 글로브는 동일한 것을보다 간결하게 나타내는 스칼라 참조 자리 표시 자로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="15863e2e3bcfe9bf34415295eb886e40c8b84a73" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;gv&lt;/code&gt; is a typeglob whose subroutine entry is a constant sub eligible for inlining, or &lt;code&gt;gv&lt;/code&gt; is a placeholder reference that would be promoted to such a typeglob, then returns the value returned by the sub. Otherwise, returns NULL.</source>
          <target state="translated">경우 &lt;code&gt;gv&lt;/code&gt; 그 루틴 엔트리 인라인 또는 동안 일정한 서브 적격 인 타입 글로브이고 &lt;code&gt;gv&lt;/code&gt; 이러한 타입 글로브 승격 될 플레이스 홀더 기준이며, 그때 서브 의해 반환 값을 반환한다. 그렇지 않으면 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5b76926b7fe43456ac634077129deadebe6d1749" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ignoreName&lt;/code&gt; or &lt;code&gt;undefName&lt;/code&gt; is used, character names should be specified as a comment (following &lt;code&gt;#&lt;/code&gt; ) on each line.</source>
          <target state="translated">&lt;code&gt;ignoreName&lt;/code&gt; 또는 &lt;code&gt;undefName&lt;/code&gt; 을 사용하는 경우 각 행 에서 문자 이름을 주석 ( &lt;code&gt;#&lt;/code&gt; 다음에 )으로 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="606bfb04b8810dddbc165299090455517c6f31d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len&lt;/code&gt; is 0, it will be calculated using &lt;code&gt;strlen(s)&lt;/code&gt; , (which means if you use this option, that &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; can't have embedded &lt;code&gt;NUL&lt;/code&gt; characters and has to have a terminating &lt;code&gt;NUL&lt;/code&gt; byte).</source>
          <target state="translated">경우 &lt;code&gt;len&lt;/code&gt; 0,이를 사용하여 계산됩니다 &lt;code&gt;strlen(s)&lt;/code&gt; (이 옵션을 사용하는 경우 것으로, 어떤 수단 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 포함 할 수 없습니다 &lt;code&gt;NUL&lt;/code&gt; 의 문자와 종료해야합니다 &lt;code&gt;NUL&lt;/code&gt; 의 바이트).</target>
        </trans-unit>
        <trans-unit id="564f6927aa67faeb8390b79eb296fc0609382f07" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;list_archive()&lt;/code&gt; is passed an array reference as its third argument it returns a list of hash references containing the requested properties of each file. The following list of properties is supported: full_path, name, size, mtime (last modified date), mode, uid, gid, linkname, uname, gname, devmajor, devminor, prefix, type.</source>
          <target state="translated">경우 &lt;code&gt;list_archive()&lt;/code&gt; 세 번째 인자로 배열 참조를 전달 각 파일의 요구 된 속성을 포함하는 해시 참조 목록을 반환한다. full_path, 이름, 크기, mtime (마지막 수정 날짜), mode, uid, gid, linkname, uname, gname, devmajor, devminor, prefix, type 등의 속성 목록이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="30b6892ba87f6c10d6419b32b55f7a86419b6ce9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;list_files()&lt;/code&gt; is passed an array reference as its first argument it returns a list of hash references containing the requested properties of each file. The following list of properties is supported: name, size, mtime (last modified date), mode, uid, gid, linkname, uname, gname, devmajor, devminor, prefix.</source>
          <target state="translated">경우 &lt;code&gt;list_files()&lt;/code&gt; 첫 번째 인수로 배열 참조를 전달 각 파일의 요구 된 속성을 포함하는 해시 참조 목록을 반환한다. 이름, 크기, mtime (마지막 수정 날짜), mode, uid, gid, linkname, uname, gname, devmajor, devminor, prefix 등의 속성 목록이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="6b6ca16484970453642612331b9f95d68983da46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;make_path&lt;/code&gt; or &lt;code&gt;remove_tree&lt;/code&gt; encounter an error, a diagnostic message will be printed to &lt;code&gt;STDERR&lt;/code&gt; via &lt;code&gt;carp&lt;/code&gt; (for non-fatal errors), or via &lt;code&gt;croak&lt;/code&gt; (for fatal errors).</source>
          <target state="translated">경우 &lt;code&gt;make_path&lt;/code&gt; 또는 &lt;code&gt;remove_tree&lt;/code&gt; 발생 오류, 진단 메시지를 출력한다 &lt;code&gt;STDERR&lt;/code&gt; 통해 &lt;code&gt;carp&lt;/code&gt; (치명적 오류) 또는 비아 &lt;code&gt;croak&lt;/code&gt; (치명적인 오류).</target>
        </trans-unit>
        <trans-unit id="e12005256b82b7dbf15e43b617aa6446b9ea3caa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;merge&lt;/code&gt; is true the harness will create parsers that merge STDOUT and STDERR together for any processes they start.</source>
          <target state="translated">경우 &lt;code&gt;merge&lt;/code&gt; 사실이다 하네스은 시작하는 모든 프로세스를 위해 함께 STDOUT 및 STDERR 병합 파서를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a5a417a1f8bba03650439d46556e6b5e2f42cdc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;namlen&lt;/code&gt; is greater than zero then a &lt;code&gt;savepvn&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;namlen&lt;/code&gt; 는 다음 제로 (A)보다 큰 &lt;code&gt;savepvn&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a5b4f60a5261a12c3ad5e79f21f3b4cceb3007ea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new()&lt;/code&gt; is invoked with arguments and the &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt; method fails for any reason, &lt;code&gt;new()&lt;/code&gt; returns undef.</source>
          <target state="translated">만약 &lt;code&gt;new()&lt;/code&gt; 인수로 호출되고있다 &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt; 메소드는 어떤 이유로 실패, &lt;code&gt;new()&lt;/code&gt; 반환 미확정.</target>
        </trans-unit>
        <trans-unit id="14b4ce4ab1caa8905ea03f71030c64a0c404abbc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pass_through&lt;/code&gt; is also enabled, options processing will terminate at the first unrecognized option, or non-option, whichever comes first.</source>
          <target state="translated">경우 &lt;code&gt;pass_through&lt;/code&gt; 이 또한 활성화되어, 옵션은 둘 중 먼저 첫 번째 인식 옵션, 또는 비 - 옵션에서 종료됩니다 처리.</target>
        </trans-unit>
        <trans-unit id="c02b449190a1b90198a28e96aea10bbc105c7788" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pe1&lt;/code&gt; is non-NULL and the pointer it points to is not NULL, that pointer is considered an end pointer to the position 1 byte past the maximum point in &lt;code&gt;s1&lt;/code&gt; beyond which scanning will not continue under any circumstances. (This routine assumes that UTF-8 encoded input strings are not malformed; malformed input can cause it to read past &lt;code&gt;pe1&lt;/code&gt; ). This means that if both &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;pe1&lt;/code&gt; are specified, and &lt;code&gt;pe1&lt;/code&gt; is less than &lt;code&gt;s1&lt;/code&gt; +&lt;code&gt;l1&lt;/code&gt; , the match will never be successful because it can never get as far as its goal (and in fact is asserted against). Correspondingly for &lt;code&gt;pe2&lt;/code&gt; with respect to &lt;code&gt;s2&lt;/code&gt; .</source>
          <target state="translated">경우 &lt;code&gt;pe1&lt;/code&gt; 아닌 NULL이고 그것을 가리키는 포인터가 NULL이 아닌, 그 포인터의 최대 포인트 과거의 위치를 1 바이트로 끝 포인터로 간주됩니다 &lt;code&gt;s1&lt;/code&gt; 검사는 어떤 상황에서도 계속할 것이다 이상. (이 루틴은 UTF-8로 인코딩 된 입력 문자열의 형식이 잘못되었다고 가정합니다. 잘못된 형식의 입력으로 인해 &lt;code&gt;pe1&lt;/code&gt; 지나서 읽힐 수 있습니다 .) 이는 &lt;code&gt;l1&lt;/code&gt; 과 &lt;code&gt;pe1&lt;/code&gt; 이 모두 지정되고 &lt;code&gt;pe1&lt;/code&gt; 이 &lt;code&gt;s1&lt;/code&gt; + &lt;code&gt;l1&lt;/code&gt; 보다 작 으면 , 목표까지 도달 할 수 없기 때문에 (성공적으로 주장되지 않음) 일치하지 않습니다. &lt;code&gt;s2&lt;/code&gt; 와 관련하여 &lt;code&gt;pe2&lt;/code&gt; 에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="e5414852c94de9d937514c7b2ffd918737261abd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;permute&lt;/code&gt; is enabled, this means that</source>
          <target state="translated">&lt;code&gt;permute&lt;/code&gt; 가 활성화 된 경우</target>
        </trans-unit>
        <trans-unit id="e47709e624b959c659a6f5424e397b7429bd08c4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;preprocess&lt;/code&gt; and/or &lt;code&gt;normalization&lt;/code&gt; is applied, the code points of the string after them (in NFD by default) are used.</source>
          <target state="translated">경우 &lt;code&gt;preprocess&lt;/code&gt; 및 / 또는 &lt;code&gt;normalization&lt;/code&gt; 적용됩니다 (기본적으로 NFD에서) 그 후 문자열의 코드 포인트가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c7a3e0b813ddb5c552aec4199fd49e48847ff2c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;prompt()&lt;/code&gt; detects that it is not running interactively and there is nothing on STDIN or if the PERL_MM_USE_DEFAULT environment variable is set to true, the $default will be used without prompting. This prevents automated processes from blocking on user input.</source>
          <target state="translated">경우 &lt;code&gt;prompt()&lt;/code&gt; 가 대화 형으로 실행되지 않고 STDIN 아무것도 또는 PERL_MM_USE_DEFAULT 환경 변수가 true로 설정되어있는 경우 $ 기본이 메시지를 표시하지 않고 사용되는이 없음을 감지합니다. 따라서 자동화 된 프로세스가 사용자 입력을 차단하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="9d8185228e8e06faca877b9d0926aab5904e951a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;require_order&lt;/code&gt; is enabled, options processing terminates when the first non-option is encountered.</source>
          <target state="translated">&lt;code&gt;require_order&lt;/code&gt; 가 사용 가능한 경우 , 옵션이 아닌 첫 번째 옵션이 발견되면 옵션 처리가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="7ec89b0e13a7db5b1125011c45839f2c6cfb36ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;require_order&lt;/code&gt; is enabled, options processing will terminate at the first unrecognized option, or non-option, whichever comes first and all remaining arguments are passed to &lt;code&gt;@ARGV&lt;/code&gt; instead of the catchall &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; if present. However, if &lt;code&gt;permute&lt;/code&gt; is enabled instead, results can become confusing.</source>
          <target state="translated">&lt;code&gt;require_order&lt;/code&gt; 가 사용 가능한 경우 , 옵션 처리는 인식 할 수없는 첫 번째 옵션 또는 옵션이 아닌 옵션에서 종료되며 나머지 모든 인수는 catchall &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 대신 &lt;code&gt;@ARGV&lt;/code&gt; 로 전달 됩니다 (있는 경우). 그러나 대신 &lt;code&gt;permute&lt;/code&gt; 를 사용하면 결과가 혼동 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba0fe2f6810522d3880f034d6ed2e0c1aaeec082" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;set_locale()&lt;/code&gt; fails for some reason (for example, an attempt to set to a locale unknown to the system), the locale for the category is not changed, and the function returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;set_locale()&lt;/code&gt; 어떤 이유로 실패 (예를 들어, 시스템에 로케일 알 수없는 세트에 시도), 카테고리에 대한 로케일을 변경하고, 함수가 반환되지 않은 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04ffb889ba3672c819c8ebc2556d3ca7f2216415" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sv&lt;/code&gt; is not already magical, Perl uses the &lt;code&gt;SvUPGRADE&lt;/code&gt; macro to convert &lt;code&gt;sv&lt;/code&gt; to type &lt;code&gt;SVt_PVMG&lt;/code&gt; . Perl then continues by adding new magic to the beginning of the linked list of magical features. Any prior entry of the same type of magic is deleted. Note that this can be overridden, and multiple instances of the same type of magic can be associated with an SV.</source>
          <target state="translated">&lt;code&gt;sv&lt;/code&gt; 가 아직 마법이 아닌 경우 Perl은 &lt;code&gt;SvUPGRADE&lt;/code&gt; 매크로를 사용하여 &lt;code&gt;sv&lt;/code&gt; 를 유형 &lt;code&gt;SVt_PVMG&lt;/code&gt; 로 변환 합니다. 그런 다음 Perl은 연결된 마법 기능 목록의 시작 부분에 새로운 마법을 추가합니다. 동일한 유형의 매직을 입력하면 삭제됩니다. 이를 재정의 할 수 있으며 동일한 유형의 매직의 여러 인스턴스를 SV와 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5c3008df77cfa39eeaefce991da14fbe22117ea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;u1&lt;/code&gt; is true, the string &lt;code&gt;s1&lt;/code&gt; is assumed to be in UTF-8-encoded Unicode; otherwise it is assumed to be in native 8-bit encoding. Correspondingly for &lt;code&gt;u2&lt;/code&gt; with respect to &lt;code&gt;s2&lt;/code&gt; .</source>
          <target state="translated">경우 &lt;code&gt;u1&lt;/code&gt; 사실, 문자열 &lt;code&gt;s1&lt;/code&gt; UTF-8 인코딩 유니 것으로 가정되고; 그렇지 않으면 네이티브 8 비트 인코딩으로 가정합니다. &lt;code&gt;s2&lt;/code&gt; 와 관련하여 &lt;code&gt;u2&lt;/code&gt; 에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="fcb599464a46f537e87d3017df24f3e8e2283ffd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;uv&lt;/code&gt; is a Unicode surrogate code point and UNICODE_WARN_SURROGATE is set, the function will raise a warning, provided UTF8 warnings are enabled. If instead UNICODE_DISALLOW_SURROGATE is set, the function will fail and return NULL. If both flags are set, the function will both warn and return NULL.</source>
          <target state="translated">경우 &lt;code&gt;uv&lt;/code&gt; 유니 코드 서로 게이트 코드 포인트이며 UNICODE_WARN_SURROGATE를 설정, 함수는 경고, 제공 UTF8 경고가 활성화를 올릴 것이다. 대신 UNICODE_DISALLOW_SURROGATE가 설정되면 함수는 실패하고 NULL을 반환합니다. 두 플래그가 모두 설정되면 함수는 경고를 표시하고 NULL을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ae30129230a55488ef814c14253472811e67904d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; in</source>
          <target state="translated">만약 &lt;code&gt;value&lt;/code&gt; 에</target>
        </trans-unit>
        <trans-unit id="02c3454635e56b23178636e2bb6aec32fcd96776" translate="yes" xml:space="preserve">
          <source>If @DynaLoader::dl_resolve_using contains &lt;code&gt;-L*&lt;/code&gt; or &lt;code&gt;-l*&lt;/code&gt; entries then Mkbootstrap will automatically add a dl_findfile() call to the generated &lt;code&gt;*.bs&lt;/code&gt; file.</source>
          <target state="translated">@DynaLoader :: dl_resolve_using에 &lt;code&gt;-L*&lt;/code&gt; 또는 &lt;code&gt;-l*&lt;/code&gt; 항목이 포함되어 있으면 Mkbootstrap 은 생성 된 &lt;code&gt;*.bs&lt;/code&gt; 파일에 dl_findfile () 호출을 자동으로 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="203a87ac5779da1d943be09c716f0304a892b601" translate="yes" xml:space="preserve">
          <source>If @args is not given, an empty list will be used.</source>
          <target state="translated">@args를 지정하지 않으면 빈 목록이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f3523d8b4dddaad91344458f88af994bb31e6c10" translate="yes" xml:space="preserve">
          <source>If @imports are given, they are passed through to the use. So this:</source>
          <target state="translated">@imports가 제공되면 사용으로 전달됩니다. 그래서 이거:</target>
        </trans-unit>
        <trans-unit id="649b9ffd5b70f81915b08f4bc8291a1a2ce523f9" translate="yes" xml:space="preserve">
          <source>If @suffixes are given each element is a pattern (either a string or a &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;) matched against the end of the $filename. The matching portion is removed and becomes the $suffix.</source>
          <target state="translated">@suffixes가 주어지면 각 요소는 $ filename의 끝과 일치 하는 패턴 (문자열 또는 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; )입니다. 일치하는 부분이 제거되고 $ suffix가됩니다.</target>
        </trans-unit>
        <trans-unit id="e062bfde8c040f50084c09a806e3edbdcdba4c2d" translate="yes" xml:space="preserve">
          <source>If ATTR is not specified, coloralias() returns the standard color name to which ALIAS is aliased, if any, or undef if ALIAS does not exist.</source>
          <target state="translated">ATTR을 지정하지 않으면 coloralias ()는 ALIAS의 별칭이있는 표준 색상 이름을 반환하거나 ALIAS가 없으면 undef를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f999d6f241c02db8ba7aa5052a43f699b6917b00" translate="yes" xml:space="preserve">
          <source>If ATTR is specified, coloralias() sets up an alias of ALIAS for the standard color ATTR. From that point forward, ALIAS can be passed into color(), colored(), and colorvalid() and will have the same meaning as ATTR. One possible use of this facility is to give more meaningful names to the 256-color RGB colors. Only alphanumerics, &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;_&lt;/code&gt; , and &lt;code&gt;-&lt;/code&gt; are allowed in alias names.</source>
          <target state="translated">ATTR을 지정하면 coloralias ()는 표준 색상 ATTR에 대한 별칭 별칭을 설정합니다. 그 시점부터 ALIAS는 color (), colored () 및 colorvalid ()로 전달 될 수 있으며 ATTR과 동일한 의미를 갖습니다. 이 기능을 사용할 수있는 한 가지 방법은 256 색 RGB 색상에 더 의미있는 이름을 지정하는 것입니다. 영숫자 만 &lt;code&gt;.&lt;/code&gt; 별명에는 , &lt;code&gt;_&lt;/code&gt; 및 &lt;code&gt;-&lt;/code&gt; 가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="ed33ee3bf815a6c3c728d6a64deacab551214ad3" translate="yes" xml:space="preserve">
          <source>If BITS is 16 or more, bytes of the input string are grouped into chunks of size BITS/8, and each group is converted to a number as with pack()/unpack() with big-endian formats &lt;code&gt;n&lt;/code&gt; /&lt;code&gt;N&lt;/code&gt; (and analogously for BITS==64). See &lt;a href=&quot;#pack&quot;&gt;pack&lt;/a&gt; for details.</source>
          <target state="translated">BITS가 16 이상인 경우 입력 문자열의 바이트는 BITS / 8 크기의 청크로 그룹화되며 각 그룹은 큰 엔디안 형식의 &lt;code&gt;n&lt;/code&gt; / &lt;code&gt;N&lt;/code&gt; (및 유사하게 pack () / unpack ()과 같은 숫자로 변환됩니다. BITS == 64의 경우). 자세한 내용은 &lt;a href=&quot;#pack&quot;&gt;팩&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5890dee5bd815a9a6b870ab0d81456c70fdb6033" translate="yes" xml:space="preserve">
          <source>If BITS is 16 or more, bytes of the input string are grouped into chunks of size BITS/8, and each group is converted to a number as with pack()/unpack() with big-endian formats &lt;code&gt;n&lt;/code&gt; /&lt;code&gt;N&lt;/code&gt; (and analogously for BITS==64). See &lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt; for details.</source>
          <target state="translated">BITS가 16 이상인 경우 입력 문자열의 바이트는 BITS / 8 크기의 청크로 그룹화되며 각 그룹은 큰 엔디안 형식의 &lt;code&gt;n&lt;/code&gt; / &lt;code&gt;N&lt;/code&gt; (및 유사하게 pack () / unpack ()과 같은 숫자로 변환됩니다. BITS == 64의 경우). 자세한 내용은 &lt;a href=&quot;pack&quot;&gt;팩&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="eafc581ec466397a85b26357c350bc4ac6773df9" translate="yes" xml:space="preserve">
          <source>If BITS is 8, &quot;elements&quot; coincide with bytes of the input string.</source>
          <target state="translated">BITS가 8 인 경우 &quot;요소&quot;는 입력 문자열의 바이트와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="1e3d642ff4115aae3b45ab10f3f174f7b8799465" translate="yes" xml:space="preserve">
          <source>If BUILD_REQUIRES is not empty, it will be dumped as $BUILD_REQUIRES hashref.</source>
          <target state="translated">BUILD_REQUIRES가 비어 있지 않으면 $ BUILD_REQUIRES hashref로 덤프됩니다.</target>
        </trans-unit>
        <trans-unit id="2f52aed81a4b81abc4bfb5eb234cabe8285fe520" translate="yes" xml:space="preserve">
          <source>If CHLD_IN begins with &lt;code&gt;&amp;lt;&amp;amp;&lt;/code&gt; , then CHLD_IN will be closed in the parent, and the child will read from it directly. If CHLD_OUT or CHLD_ERR begins with &lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt;, then the child will send output directly to that filehandle. In both cases, there will be a dup(2) instead of a pipe(2) made.</source>
          <target state="translated">CHLD_IN이 &lt;code&gt;&amp;lt;&amp;amp;&lt;/code&gt; 로 시작하면 CHLD_IN이 부모에서 닫히고 자식은 직접 읽습니다. CHLD_OUT 또는 CHLD_ERR이 &lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt; 로 시작 하면 자식은 해당 파일 핸들로 직접 출력을 보냅니다. 두 경우 모두 pipe (2) 대신 dup (2)이 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="7212fe99a84e995b8956769eedd21cc0b4318074" translate="yes" xml:space="preserve">
          <source>If Configure detects &lt;code&gt;mmap()&lt;/code&gt; functions this layer is provided (with &quot;perlio&quot; as a &quot;base&quot;) which does &quot;read&quot; operations by mmap()ing the file. Performance improvement is marginal on modern systems, so it is mainly there as a proof of concept. It is likely to be unbundled from the core at some point. The &quot;mmap&quot; layer is a reasonable model for a minimalist &quot;derived&quot; layer.</source>
          <target state="translated">Configure에서 &lt;code&gt;mmap()&lt;/code&gt; 함수를 감지하면 파일을 mmap () 하여 &quot;읽기&quot;작업을 수행하는이 계층이 &quot;perlio&quot;를 &quot;base&quot;로 제공합니다. 최신 시스템에서는 성능 향상이 미미하므로 주로 개념 증명으로 사용됩니다. 언젠가는 코어에서 번들로 제공 될 수 있습니다. &quot;mmap&quot;레이어는 미니멀리스트 &quot;파생&quot;레이어에 적합한 모델입니다.</target>
        </trans-unit>
        <trans-unit id="47e49834bb6e6d998b14887fad543f4fe5a1147b" translate="yes" xml:space="preserve">
          <source>If Configure detects this system has a signbit() that will work with our NVs, then we just use it via the #define in perl.h. Otherwise, fall back on this implementation. The main use of this function is catching -0.0.</source>
          <target state="translated">Configure가이 시스템에 NV와 작동하는 signbit ()가 있음을 감지하면 perl.h의 #define을 통해 사용합니다. 그렇지 않으면이 구현으로 돌아갑니다. 이 함수의 주요 용도는 -0.0을 잡는 것입니다.</target>
        </trans-unit>
        <trans-unit id="14abe49a0e4ae66bc9fb22dcac00158a0e0ddd4d" translate="yes" xml:space="preserve">
          <source>If D calls an autoloaded method 'foo' which is defined in class A, then the method is loaded into class A, then executed. If C then calls method 'foo', and that method was reimplemented in class B, but set to be autoloaded, then the lookup mechanism never gets to the AUTOLOAD mechanism in B because it first finds the method already loaded in A, and so erroneously uses that. If the method foo had been stubbed in B, then the lookup mechanism would have found the stub, and correctly loaded and used the sub from B.</source>
          <target state="translated">D가 클래스 A에 정의 된 자동로드 된 메소드 'foo'를 호출하면 메소드가 클래스 A에로드 된 후 실행됩니다. C가 메소드 'foo'를 호출하고 해당 메소드가 클래스 B에서 다시 구현되었지만 자동로드되도록 설정된 경우, 조회 메커니즘은 먼저 A에로드 된 메소드를 먼저 찾아서 잘못 검색하므로 B의 AUTOLOAD 메커니즘에 도달하지 않습니다. 사용합니다. 메소드 foo가 B에서 스텁 된 경우, 검색 메커니즘은 스텁을 찾아서 B에서 서브를 올바르게로드하고 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="91710ed7923201057d536dad32d2aa3d9a3bd35e" translate="yes" xml:space="preserve">
          <source>If DUCET is not installed, it is recommended to copy the file from &lt;a href=&quot;http://www.unicode.org/Public/UCA/latest/allkeys.txt&quot;&gt;http://www.unicode.org/Public/UCA/latest/allkeys.txt&lt;/a&gt; to &amp;lt;a place in @INC&amp;gt;/Unicode/Collate/allkeys.txt manually.</source>
          <target state="translated">DUCET이 설치되어 있지 않은 경우 &lt;a href=&quot;http://www.unicode.org/Public/UCA/latest/allkeys.txt&quot;&gt;http://www.unicode.org/Public/UCA/latest/allkeys.txt&lt;/a&gt; 에서 &amp;lt;@INC&amp;gt; /Unicode/Collate/allkeys.txt의 위치로 파일을 수동으로 복사하는 것이 좋습니다. .</target>
        </trans-unit>
        <trans-unit id="63ee7188cb79ae72f03905ea0c72ed0cf711430e" translate="yes" xml:space="preserve">
          <source>If EVENT_MASK is given, then, if EVENT_MASK is non-zero, IO is added to the list of file descriptors and the next call to poll will check for any event specified in EVENT_MASK. If EVENT_MASK is zero then IO will be removed from the list of file descriptors.</source>
          <target state="translated">EVENT_MASK가 제공되면 EVENT_MASK가 0이 아닌 경우 IO가 파일 디스크립터 목록에 추가되고 다음 폴링 호출은 EVENT_MASK에 지정된 이벤트를 확인합니다. EVENT_MASK가 0이면 IO가 파일 디스크립터 목록에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="bd3d21a82a01626375b0a1ef9fd969a22666fce2" translate="yes" xml:space="preserve">
          <source>If EVENT_MASK is not given then the return value will be the current event mask value for IO.</source>
          <target state="translated">EVENT_MASK가 제공되지 않으면 리턴 값은 IO의 현재 이벤트 마스크 값이됩니다.</target>
        </trans-unit>
        <trans-unit id="24c1cc8102964c640118dc422f140e282d6a071d" translate="yes" xml:space="preserve">
          <source>If EXPR is &lt;code&gt;EXPR1 &amp;amp;&amp;amp; EXPR2&lt;/code&gt; or &lt;code&gt;EXPR1 &lt;a href=&quot;functions/and&quot;&gt;and&lt;/a&gt; EXPR2&lt;/code&gt; , the test is applied</source>
          <target state="translated">EXPR이 &lt;code&gt;EXPR1 &amp;amp;&amp;amp; EXPR2&lt;/code&gt; 또는 &lt;code&gt;EXPR1 &lt;a href=&quot;functions/and&quot;&gt;and&lt;/a&gt; EXPR2&lt;/code&gt; 인 경우 테스트가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="34b0086c490eacc160b851838628c17c1a42195c" translate="yes" xml:space="preserve">
          <source>If EXPR is &lt;code&gt;EXPR1 || EXPR2&lt;/code&gt; , &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; , or &lt;code&gt;EXPR1 &lt;a href=&quot;functions/or&quot;&gt;or&lt;/a&gt; EXPR2&lt;/code&gt; , the test is applied</source>
          <target state="translated">EXPR이 &lt;code&gt;EXPR1 || EXPR2&lt;/code&gt; 경우 || EXPR2 , &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; 또는 &lt;code&gt;EXPR1 &lt;a href=&quot;functions/or&quot;&gt;or&lt;/a&gt; EXPR2&lt;/code&gt; 테스트가 적용됨)</target>
        </trans-unit>
        <trans-unit id="204a0454b1de60634e71646d68fb30fb2441fd3c" translate="yes" xml:space="preserve">
          <source>If EXPR is a bareword, the require assumes a &quot;</source>
          <target state="translated">EXPR이 기본 단어 인 경우 요구 사항은 &quot;</target>
        </trans-unit>
        <trans-unit id="9736cd87f1cff71e99f8827cbdbed7d4bb55c258" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; uses the current time (as returned by time(3)).</source>
          <target state="translated">EXPR을 생략하면 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 은 현재 시간을 사용합니다 (time (3)에 의해 리턴 됨).</target>
        </trans-unit>
        <trans-unit id="6546ecbea2a684b1dddb3701f62d17cc4c008989" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, &lt;code&gt;&lt;a href=&quot;localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; uses the current time (as returned by time(3)).</source>
          <target state="translated">EXPR을 생략하면 &lt;code&gt;&lt;a href=&quot;localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 은 현재 시간을 사용합니다 (time (3)에 의해 리턴 됨).</target>
        </trans-unit>
        <trans-unit id="cc0b8d50332776e14a75cf158fdbe3c24ae9c657" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, stats &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">EXPR을 생략하면 통계 &lt;code&gt;$_&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="456f6be70dd618e1ee3287e7f4f8da001e29c2cb" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, unpacks the &lt;code&gt;$_&lt;/code&gt; string. See &lt;a href=&quot;../perlpacktut&quot;&gt;perlpacktut&lt;/a&gt; for an introduction to this function.</source>
          <target state="translated">EXPR을 생략하면 &lt;code&gt;$_&lt;/code&gt; 문자열의 압축을 풉니 다 . &lt;a href=&quot;../perlpacktut&quot;&gt;perlpacktut&lt;/a&gt; 참조이 기능에 대한 소개는 를 .</target>
        </trans-unit>
        <trans-unit id="b61a1720b65aee85f5ca14d3364f5d86fb223f23" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, unpacks the &lt;code&gt;$_&lt;/code&gt; string. See &lt;a href=&quot;perlpacktut&quot;&gt;perlpacktut&lt;/a&gt; for an introduction to this function.</source>
          <target state="translated">EXPR을 생략하면 &lt;code&gt;$_&lt;/code&gt; 문자열의 압축을 풉니 다 . &lt;a href=&quot;perlpacktut&quot;&gt;perlpacktut&lt;/a&gt; 참조이 기능에 대한 소개는 를 .</target>
        </trans-unit>
        <trans-unit id="d36eccdc92b1d6936c118cc354859012973685d8" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">EXPR을 생략하면 &lt;code&gt;$_&lt;/code&gt; 사용합니다. .</target>
        </trans-unit>
        <trans-unit id="1172cb3a4a7f1f2dfc6dcf55076a98d031996813" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, uses &lt;code&gt;$_&lt;/code&gt; . To go the other way (produce a number in octal), use sprintf() or printf():</source>
          <target state="translated">EXPR을 생략하면 &lt;code&gt;$_&lt;/code&gt; 사용합니다. . 다른 방법으로 (8 진수로 숫자를 생성하려면) sprintf () 또는 printf ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="488f2cec4909ee80d1ac152c113a7f5b407ac400" translate="yes" xml:space="preserve">
          <source>If FILEHANDLE is an undefined scalar variable (or array or hash element), a new filehandle is autovivified, meaning that the variable is assigned a reference to a newly allocated anonymous filehandle. Otherwise if FILEHANDLE is an expression, its value is the real filehandle. (This is considered a symbolic reference, so &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict &quot;refs&quot;&lt;/code&gt; should</source>
          <target state="translated">FILEHANDLE이 정의되지 않은 스칼라 변수 (또는 배열 또는 해시 요소) 인 경우 새 파일 핸들이 자동으로 활성화되므로 변수에 새로 할당 된 익명 파일 핸들에 대한 참조가 지정됩니다. 그렇지 않으면 FILEHANDLE이 표현식 인 경우 해당 값은 실제 파일 핸들입니다. (이것은 그래서, 상징적 참조로 간주됩니다 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict &quot;refs&quot;&lt;/code&gt; 한다</target>
        </trans-unit>
        <trans-unit id="7bf316535c25573b5c20cc7acfbdffbec7d384a1" translate="yes" xml:space="preserve">
          <source>If FILEHANDLE is an undefined scalar variable (or array or hash element), a new filehandle is autovivified, meaning that the variable is assigned a reference to a newly allocated anonymous filehandle. Otherwise if FILEHANDLE is an expression, its value is the real filehandle. (This is considered a symbolic reference, so &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; strict &quot;refs&quot;&lt;/code&gt; should</source>
          <target state="translated">FILEHANDLE이 정의되지 않은 스칼라 변수 (또는 배열 또는 해시 요소) 인 경우 새 파일 핸들이 자동으로 활성화되므로 변수에 새로 할당 된 익명 파일 핸들에 대한 참조가 지정됩니다. 그렇지 않으면 FILEHANDLE이 표현식 인 경우 해당 값은 실제 파일 핸들입니다. (이것은 그래서, 상징적 참조로 간주됩니다 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; strict &quot;refs&quot;&lt;/code&gt; 한다</target>
        </trans-unit>
        <trans-unit id="7edd9359c1108403094d8175c9c20835e326b96f" translate="yes" xml:space="preserve">
          <source>If FILEHANDLE is unspecified, output goes to the current default output channel, which starts out as STDOUT but may be changed by the &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; operator. If the FILEHANDLE is an EXPR, then the expression is evaluated and the resulting string is used to look up the name of the FILEHANDLE at run time. For more on formats, see &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt;.</source>
          <target state="translated">FILEHANDLE을 지정하지 않으면 출력이 현재 기본 출력 채널로 이동하여 STDOUT으로 시작하지만 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 연산자에 의해 변경 될 수 있습니다 . FILEHANDLE이 EXPR 인 경우 표현식이 평가되고 결과 문자열이 런타임에 FILEHANDLE의 이름을 찾는 데 사용됩니다. 형식에 대한 자세한 내용은 &lt;a href=&quot;perlform&quot;&gt;perlform을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="64a3c2a915faecffdca2e95dc4489ca8da06212f" translate="yes" xml:space="preserve">
          <source>If FILEHANDLE is unspecified, output goes to the current default output channel, which starts out as STDOUT but may be changed by the &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; operator. If the FILEHANDLE is an EXPR, then the expression is evaluated and the resulting string is used to look up the name of the FILEHANDLE at run time. For more on formats, see &lt;a href=&quot;../perlform&quot;&gt;perlform&lt;/a&gt;.</source>
          <target state="translated">FILEHANDLE을 지정하지 않으면 출력이 현재 기본 출력 채널로 이동하여 STDOUT으로 시작하지만 &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 연산자에 의해 변경 될 수 있습니다 . FILEHANDLE이 EXPR 인 경우 표현식이 평가되고 결과 문자열이 런타임에 FILEHANDLE의 이름을 찾는 데 사용됩니다. 형식에 대한 자세한 내용은 &lt;a href=&quot;../perlform&quot;&gt;perlform을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="42bee98ad679afc0b47a6a37b45d0b7a351045fa" translate="yes" xml:space="preserve">
          <source>If FUNCTION is a string starting with &lt;code&gt;CORE::&lt;/code&gt; , the rest is taken as a name for a Perl builtin. If the builtin's arguments cannot be adequately expressed by a prototype (such as &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;), prototype() returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, because the builtin does not really behave like a Perl function. Otherwise, the string describing the equivalent prototype is returned.</source>
          <target state="translated">FUNCTION이 &lt;code&gt;CORE::&lt;/code&gt; 시작하는 문자열 인 경우 나머지는 Perl 내장의 이름으로 사용됩니다. 기본 제공 인수가 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 과 같은 프로토 타입으로 적절하게 표현 될 수없는 경우 prototype ()은 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환합니다. , 내장은 실제로 Perl 함수처럼 동작하지 않기 때문에 합니다. 그렇지 않으면 동등한 프로토 타입을 설명하는 문자열이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="cae550505561d57b299b4a003dc8830ba8e1ee71" translate="yes" xml:space="preserve">
          <source>If FUNCTION is a string starting with &lt;code&gt;CORE::&lt;/code&gt; , the rest is taken as a name for a Perl builtin. If the builtin's arguments cannot be adequately expressed by a prototype (such as &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;), prototype() returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, because the builtin does not really behave like a Perl function. Otherwise, the string describing the equivalent prototype is returned.</source>
          <target state="translated">FUNCTION이 &lt;code&gt;CORE::&lt;/code&gt; 시작하는 문자열 인 경우 나머지는 Perl 내장의 이름으로 사용됩니다. 기본 제공 인수가 &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 과 같은 프로토 타입으로 적절하게 표현 될 수없는 경우 prototype ()은 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환합니다. , 내장은 실제로 Perl 함수처럼 동작하지 않기 때문에 합니다. 그렇지 않으면 동등한 프로토 타입을 설명하는 문자열이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="cc31873f684622a14f7af2ea2005b39a1781e830" translate="yes" xml:space="preserve">
          <source>If G_ARRAY is specified</source>
          <target state="translated">G_ARRAY가 지정된 경우</target>
        </trans-unit>
        <trans-unit id="abc56a2d0a54c75c4dee47cdfefa046b0f36c198" translate="yes" xml:space="preserve">
          <source>If G_DISCARD is specified, the return value will always be 0.</source>
          <target state="translated">G_DISCARD가 지정되면 리턴 값은 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="61b15d293eca2c7db4238b66ac8714ddc363a1b1" translate="yes" xml:space="preserve">
          <source>If G_SCALAR is specified</source>
          <target state="translated">G_SCALAR가 지정된 경우</target>
        </trans-unit>
        <trans-unit id="bd626ea4da9803c896a3f690bf6350bffa4a5047" translate="yes" xml:space="preserve">
          <source>If I don't see that &quot;Perl:&quot;, it's not from perl.</source>
          <target state="translated">&quot;Perl :&quot;이 보이지 않으면 펄이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7f881d9fe9fd9028d68d11b8271492af01bf7e3c" translate="yes" xml:space="preserve">
          <source>If ID is omitted, it defaults to &lt;code&gt;1&lt;/code&gt; . If a single character is given for ID, the numeric value of that character is used.</source>
          <target state="translated">ID를 생략하면 기본값은 &lt;code&gt;1&lt;/code&gt; 입니다. 입니다. ID에 단일 문자가 제공되면 해당 문자의 숫자 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b781e9bc0c2157f6dabdbd2804f21e2dc4d3a773" translate="yes" xml:space="preserve">
          <source>If KEY starts and ends with a slash, the string in between is treated as a regular expression and only keys matching this regexp are displayed</source>
          <target state="translated">KEY가 슬래시로 시작하고 끝나는 경우 사이에있는 문자열은 정규식으로 취급되며이 정규 표현식과 일치하는 키만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="97bf7fa576e4d2080ce6127c0f4cd5a7adce4cf1" translate="yes" xml:space="preserve">
          <source>If LAYER is omitted or specified as &lt;code&gt;:raw&lt;/code&gt; the filehandle is made suitable for passing binary data. This includes turning off possible CRLF translation and marking it as bytes (as opposed to Unicode characters). Note that, despite what may be implied in</source>
          <target state="translated">LAYER가 생략되거나 &lt;code&gt;:raw&lt;/code&gt; 로 지정된 경우 파일 핸들은 이진 데이터를 전달하는 데 적합합니다. 여기에는 가능한 CRLF 변환을 끄고 바이트 단위로 표시하는 것이 포함됩니다 (유니 코드 문자와 반대). 내포 된 내용에도 불구하고</target>
        </trans-unit>
        <trans-unit id="283b8c8f4ffd49cdc5f923f3f2b2ef054e93376f" translate="yes" xml:space="preserve">
          <source>If LAYER is present it is a single string, but may contain multiple directives. The directives alter the behaviour of the filehandle. When LAYER is present, using binmode on a text file makes sense.</source>
          <target state="translated">LAYER가 있으면 단일 문자열이지만 여러 지시문이 포함될 수 있습니다. 지시문은 파일 핸들의 동작을 변경합니다. LAYER가 있으면 텍스트 파일에서 binmode를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="bc78056370f87ab6c8598a43f74f4b98bd9074c2" translate="yes" xml:space="preserve">
          <source>If LIMIT is negative, it is treated as if it were instead arbitrarily large; as many fields as possible are produced.</source>
          <target state="translated">LIMIT가 음수 인 경우에는 임의로 임의로 큰 것처럼 취급됩니다. 가능한 많은 분야가 생산됩니다.</target>
        </trans-unit>
        <trans-unit id="0394dbfeda7095aa516dcefff51b8b66aab7006b" translate="yes" xml:space="preserve">
          <source>If LIMIT is omitted (or, equivalently, zero), then it is usually treated as if it were instead negative but with the exception that trailing empty fields are stripped (empty leading fields are always preserved); if all fields are empty, then all fields are considered to be trailing (and are thus stripped in this case). Thus, the following:</source>
          <target state="translated">LIMIT가 생략 된 경우 (또는 동등하게 0 인 경우), 대신 빈 필드가 제거된다는 점을 제외하고는 일반적으로 음수 인 것처럼 처리됩니다 (빈 선행 필드는 항상 보존 됨). 모든 필드가 비어 있으면 모든 필드가 후행 인 것으로 간주되므로이 경우 제거됩니다. 따라서 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ec1ca6d6c3c8c30d74e46da0d1f8dfee1a937ce1" translate="yes" xml:space="preserve">
          <source>If LIMIT is specified and positive, it represents the maximum number of fields into which the EXPR may be split; in other words, LIMIT is one greater than the maximum number of times EXPR may be split. Thus, the LIMIT value &lt;code&gt;1&lt;/code&gt; means that EXPR may be split a maximum of zero times, producing a maximum of one field (namely, the entire value of EXPR). For instance:</source>
          <target state="translated">LIMIT가 지정되고 양수이면 EXPR이 분할 될 수있는 최대 필드 수를 나타냅니다. 즉, LIMIT는 EXPR이 분할 될 수있는 최대 횟수보다 1이 큽니다. 따라서 LIMIT 값 &lt;code&gt;1&lt;/code&gt; 은 EXPR이 최대 0 회 분할되어 최대 하나의 필드 (즉, EXPR의 전체 값)를 생성 할 수 있음을 의미합니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="a1e79f492508e7edc8814a0c2f8fb560a886956d" translate="yes" xml:space="preserve">
          <source>If LIST consists of the empty string, &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; spawns an interactive DCL subprocess, in the same fashion as typing &lt;b&gt;SPAWN&lt;/b&gt; at the DCL prompt.</source>
          <target state="translated">LIST가 빈 문자열로 구성된 경우 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 은 &lt;b&gt;SPAWN&lt;/b&gt; 을 입력하는 것과 같은 방식으로 대화식 DCL 서브 프로세스를 생성합니다.&lt;b&gt;&lt;/b&gt; 은 DCL 프롬프트에서 을 합니다.</target>
        </trans-unit>
        <trans-unit id="8af421f1352b89476d8e2fb680c100c5c55fb16a" translate="yes" xml:space="preserve">
          <source>If LIST is omitted, &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">LIST가 생략되면 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;$_&lt;/code&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="15ba1dd13707a281770468c5a2f35927f1cf24ea" translate="yes" xml:space="preserve">
          <source>If LIST is omitted, &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">LIST가 생략되면 &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;$_&lt;/code&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="f8725f581ae126bd53637cc6004bb31b10e046db" translate="yes" xml:space="preserve">
          <source>If Mac::Files could not be loaded, the empty string is returned.</source>
          <target state="translated">Mac :: Files를로드 할 수 없으면 빈 문자열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9556835597cabed412f1a27672edf9d6d8a5a68b" translate="yes" xml:space="preserve">
          <source>If N is &amp;gt; 0, rounds to the Nth digit from the left. If N &amp;lt; 0, rounds to the Nth digit after the dot. Since BigInts are integers, the case N &amp;lt; 0 is a no-op for them.</source>
          <target state="translated">N이 0보다 크면 왼쪽에서 N 번째 숫자로 반올림합니다. N &amp;lt;0 인 경우, 점 다음의 N 번째 숫자로 반올림합니다. BigInts는 정수이므로 N &amp;lt;0 인 경우에는 해당 항목이 없습니다.</target>
        </trans-unit>
        <trans-unit id="809aa45c402e18c1090663e0bbd2fdac630054bb" translate="yes" xml:space="preserve">
          <source>If NUMBER is omitted, uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">NUMBER가 생략되면 &lt;code&gt;$_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e18ed7b6aa1dfe2acf7667704a25f494c6c53b1" translate="yes" xml:space="preserve">
          <source>If OFFSET and LENGTH specify a substring that is partly outside the string, only the part within the string is returned. If the substring is beyond either end of the string, substr() returns the undefined value and produces a warning. When used as an lvalue, specifying a substring that is entirely outside the string raises an exception. Here's an example showing the behavior for boundary cases:</source>
          <target state="translated">OFFSET 및 LENGTH가 부분적으로 문자열 외부에있는 부분 문자열을 지정하면 문자열 내의 부분 만 반환됩니다. 부분 문자열이 문자열의 양쪽 끝을 초과하면 substr ()은 정의되지 않은 값을 반환하고 경고를 생성합니다. lvalue로 사용될 때 전체 문자열 외부에있는 하위 문자열을 지정하면 예외가 발생합니다. 다음은 경계 사례의 동작을 보여주는 예입니다.</target>
        </trans-unit>
        <trans-unit id="805a2c8a87b8f6b59ee6ee34433c46d30a4b7687" translate="yes" xml:space="preserve">
          <source>If PATTERN is &lt;code&gt;/^/&lt;/code&gt; , then it is treated as if it used the &lt;a href=&quot;../perlreref#OPERATORS&quot;&gt;multiline modifier&lt;/a&gt; (&lt;code&gt;/^/m&lt;/code&gt; ), since it isn't much use otherwise.</source>
          <target state="translated">PATTERN이 &lt;code&gt;/^/&lt;/code&gt; 이면 &lt;a href=&quot;../perlreref#OPERATORS&quot;&gt;다중 행 수정 자&lt;/a&gt; ( &lt;code&gt;/^/m&lt;/code&gt; )를 사용한 것처럼 취급됩니다 .</target>
        </trans-unit>
        <trans-unit id="f31e710fa5dc3bb0149beaea0c04322fd5b027e6" translate="yes" xml:space="preserve">
          <source>If PATTERN is &lt;code&gt;/^/&lt;/code&gt; , then it is treated as if it used the &lt;a href=&quot;perlreref#OPERATORS&quot;&gt;multiline modifier&lt;/a&gt; (&lt;code&gt;/^/m&lt;/code&gt; ), since it isn't much use otherwise.</source>
          <target state="translated">PATTERN이 &lt;code&gt;/^/&lt;/code&gt; 이면 여러 줄 &lt;a href=&quot;perlreref#OPERATORS&quot;&gt;수정자를&lt;/a&gt; 사용하는 것처럼 처리됩니다 ( &lt;code&gt;/^/m&lt;/code&gt; )를 .</target>
        </trans-unit>
        <trans-unit id="8ab2206e4a8b71981bc3526b21e6f961d2fc978f" translate="yes" xml:space="preserve">
          <source>If PATTERN matches the empty string, the EXPR is split at the match position (between characters). As an example, the following:</source>
          <target state="translated">PATTERN이 빈 문자열과 일치하면 EXPR은 일치 위치 (문자 사이)에서 분할됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d1b7e2477c70af9a1ce418a622d9557a0b72af87" translate="yes" xml:space="preserve">
          <source>If PERL5LIB is not defined, PERLLIB is used. Directories are separated (like in PATH) by a colon on Unixish platforms and by a semicolon on Windows (the proper path separator being given by the command &lt;code&gt;perl
-V:&lt;i&gt;path_sep&lt;/i&gt;&lt;/code&gt;).</source>
          <target state="translated">PERL5LIB가 정의되지 않은 경우 PERLLIB가 사용됩니다. 디렉토리는 PATH와 같이 Unixish 플랫폼의 콜론과 Windows의 세미콜론 ( &lt;code&gt;perl -V:&lt;i&gt;path_sep&lt;/i&gt;&lt;/code&gt; &lt;i&gt;path_sep&lt;/i&gt; 명령으로 제공되는 적절한 경로 구분 기호)으로 구분됩니다 .&lt;i&gt;&lt;/i&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="e3cb4284864a564ca2b51274a4f3fa62dd73a592" translate="yes" xml:space="preserve">
          <source>If PERL_PV_ESCAPE_ALL is set then all input chars will be output using &lt;code&gt;\x01F1&lt;/code&gt; style escapes, otherwise if PERL_PV_ESCAPE_NONASCII is set, only non-ASCII chars will be escaped using this style; otherwise, only chars above 255 will be so escaped; other non printable chars will use octal or common escaped patterns like &lt;code&gt;\n&lt;/code&gt; . Otherwise, if PERL_PV_ESCAPE_NOBACKSLASH then all chars below 255 will be treated as printable and will be output as literals.</source>
          <target state="translated">PERL_PV_ESCAPE_ALL이 설정되면 모든 입력 문자가 &lt;code&gt;\x01F1&lt;/code&gt; 스타일 이스케이프를 사용하여 출력되고 , 그렇지 않으면 PERL_PV_ESCAPE_NONASCII가 설정되면이 스타일을 사용하여 비 ASCII 문자 만 이스케이프됩니다. 그렇지 않으면 255 이상의 문자 만 이스케이프됩니다. 인쇄 할 수없는 다른 문자는 &lt;code&gt;\n&lt;/code&gt; 과 같은 8 진 또는 일반적인 이스케이프 패턴을 사용 합니다. 그렇지 않으면 PERL_PV_ESCAPE_NOBACKSLASH 인 경우 255 미만의 모든 문자는 인쇄 가능한 것으로 처리되고 리터럴로 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="03a5b31adb12c35d2862c64e653c8076e4f81a1b" translate="yes" xml:space="preserve">
          <source>If PERL_PV_ESCAPE_FIRSTCHAR is set then only the first char of the string will be escaped, regardless of max. If the output is to be in hex, then it will be returned as a plain hex sequence. Thus the output will either be a single char, an octal escape sequence, a special escape like &lt;code&gt;\n&lt;/code&gt; or a hex value.</source>
          <target state="translated">PERL_PV_ESCAPE_FIRSTCHAR이 설정되면 최대 값에 관계없이 문자열의 첫 번째 문자 만 이스케이프됩니다. 출력이 16 진인 경우 일반 16 진 순서로 리턴됩니다. 따라서 출력은 단일 문자, 8 진 이스케이프 시퀀스, &lt;code&gt;\n&lt;/code&gt; 과 같은 특수 이스케이프입니다. 또는 16 진수 값입니다.</target>
        </trans-unit>
        <trans-unit id="4fd0e08a5001bbfc2db16575c706877131f99c11" translate="yes" xml:space="preserve">
          <source>If PERL_PV_ESCAPE_RE is set then the escape char used will be a '%' and not a '\\'. This is because regexes very often contain backslashed sequences, whereas '%' is not a particularly common character in patterns.</source>
          <target state="translated">PERL_PV_ESCAPE_RE가 설정되면 사용 된 이스케이프 문자는 '\\'가 아닌 '%'가됩니다. 정규 표현식에는 백 슬래시 시퀀스가 ​​포함되는 경우가 많고 '%'는 패턴에서 특히 일반적인 문자가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c327fff20e1a2d0d479391141282091e826a55c6" translate="yes" xml:space="preserve">
          <source>If PERL_PV_ESCAPE_UNI is set then the input string is treated as UTF-8 if PERL_PV_ESCAPE_UNI_DETECT is set then the input string is scanned using &lt;code&gt;is_utf8_string()&lt;/code&gt; to determine if it is UTF-8.</source>
          <target state="translated">PERL_PV_ESCAPE_UNI가 설정된 경우 PERL_PV_ESCAPE_UNI_DETECT가 설정된 경우 입력 문자열은 UTF-8로 처리되고 입력 문자열은 &lt;code&gt;is_utf8_string()&lt;/code&gt; 을 사용하여 UTF-8인지 판별합니다.</target>
        </trans-unit>
        <trans-unit id="19515a44b91c296bde08fb195c3206ce5ee06393" translate="yes" xml:space="preserve">
          <source>If PID is a subprocess started by a piped &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; (see &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;), &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; will wait for that subprocess, and return its final status value in &lt;code&gt;$?&lt;/code&gt; . If PID is a subprocess created in some other way (e.g. SPAWNed before Perl was invoked), &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; will simply check once per second whether the process has completed, and return when it has. (If PID specifies a process that isn't a subprocess of the current process, and you invoked Perl with the &lt;code&gt;-w&lt;/code&gt; switch, a warning will be issued.)</source>
          <target state="translated">PID가 파이프 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 의해 시작된 서브 프로세스 인 경우 ( &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; 참조 ) &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; 는 해당 서브 프로세스를 대기하고 최종 상태 값을 &lt;code&gt;$?&lt;/code&gt; . PID가 다른 방식으로 작성된 서브 프로세스 인 경우 (예 : Perl을 호출하기 전에 SPAWNed) &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; 는 프로세스가 완료되었는지 여부를 초당 한 번만 점검하고 프로세스가 완료되면 리턴합니다. PID가 현재 프로세스의 서브 프로세스가 아닌 프로세스를 지정하고 &lt;code&gt;-w&lt;/code&gt; 스위치를 사용하여 Perl을 호출 하면 경고가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="2833d231deee2ce7c48c3ef06baaabad2e5a0de9" translate="yes" xml:space="preserve">
          <source>If PPCODE: directive is not used, &lt;code&gt;void&lt;/code&gt; return value should be used only for subroutines which do not return a value,</source>
          <target state="translated">PPCODE : 지시문을 사용하지 않으면 &lt;code&gt;void&lt;/code&gt; 반환 값은 값을 반환하지 않는 서브 루틴에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c393beed824f2acf513d9860e129eb5ffe2baeec" translate="yes" xml:space="preserve">
          <source>If PadnameOUTER is set on the pad name, then that slot in the frame AV is a REFCNT'ed reference to a lexical from &quot;outside&quot;. Such entries are sometimes referred to as 'fake'. In this case, the name does not use 'low' and 'high' to store a cop_seq range, since it is in scope throughout. Instead 'high' stores some flags containing info about the real lexical (is it declared in an anon, and is it capable of being instantiated multiple times?), and for fake ANONs, 'low' contains the index within the parent's pad where the lexical's value is stored, to make cloning quicker.</source>
          <target state="translated">패드 이름에 PadnameOUTER가 설정되어 있으면 프레임 AV의 해당 슬롯은 &quot;외부&quot;의 어휘에 대한 REFCNT 참조입니다. 이러한 항목은 '가짜'라고도합니다. 이 경우, 이름은 cop_seq 범위를 저장하는 데 'low'및 'high'를 사용하지 않습니다. 범위는 전체에 걸쳐 있기 때문입니다. 대신 'high'는 실제 어휘에 대한 정보를 포함하는 일부 플래그를 저장하고 (익명으로 선언되고 여러 번 인스턴스화 될 수 있습니까?), 가짜 ANON의 경우 'low'는 부모 패드 내의 인덱스를 포함합니다. lexical의 값이 저장되어 복제 속도가 빨라집니다.</target>
        </trans-unit>
        <trans-unit id="40be3d27de878e5185ba9875f176a67d8334894d" translate="yes" xml:space="preserve">
          <source>If Perl cannot find the method in any of these classes, it will die with an error message.</source>
          <target state="translated">Perl이 이러한 클래스 중 하나에서 메소드를 찾을 수 없으면 오류 메시지와 함께 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="3a89c2d4d03a490ab54c26429553ad753f25a36f" translate="yes" xml:space="preserve">
          <source>If Perl finds that the found executable is of PM type when the current session is not, it will start the new process in a separate session of necessary type. Call via &lt;code&gt;OS2::Process&lt;/code&gt; to disable this magic.</source>
          <target state="translated">Perl이 현재 세션이 아닌 경우 발견 된 실행 파일이 PM 유형 인 경우 필요한 유형의 별도 세션에서 새 프로세스를 시작합니다. 이 마법을 비활성화하려면 &lt;code&gt;OS2::Process&lt;/code&gt; 를 통해 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="289a7b0542dd20aefdd9191d5f173083a238571f" translate="yes" xml:space="preserve">
          <source>If Perl has been compiled using Perl's malloc you can analyze Perl memory usage by setting $ENV{PERL_DEBUG_MSTATS}.</source>
          <target state="translated">Perl의 malloc을 사용하여 Perl을 컴파일 한 경우 $ ENV {PERL_DEBUG_MSTATS}를 설정하여 Perl 메모리 사용량을 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="230e2bfc79d0ba462c1beaf813fc67b45a5f8378" translate="yes" xml:space="preserve">
          <source>If Perl is not built to use PerlIO as its IO system then only the two pseudo-layers &lt;code&gt;:bytes&lt;/code&gt; and &lt;code&gt;:crlf&lt;/code&gt; are available.</source>
          <target state="translated">Perl이 IO 시스템으로 PerlIO를 사용하도록 빌드되지 않은 경우 두 개의 의사 계층 &lt;code&gt;:bytes&lt;/code&gt; 및 &lt;code&gt;:crlf&lt;/code&gt; 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6264d3e40b3079f00ff5fcba981797a472b669d0" translate="yes" xml:space="preserve">
          <source>If Perl was not built with socket support, the system call version of &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; is not available at all. If socket support is present, then the system call version of &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; functions only for file descriptors attached to sockets. It will not provide information about regular files or pipes, since the CRTL &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; routine does not provide this functionality.</source>
          <target state="translated">Perl이 소켓 지원으로 빌드되지 않은 경우 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 의 시스템 호출 버전을 전혀 사용할 수 없습니다. 소켓 지원이 존재하면, 소켓에 접속 된 파일 디스크립터에 대해서만 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 함수 의 시스템 호출 버전 . CRTL &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; 이후 일반 파일 또는 파이프에 대한 정보를 제공하지 않습니다. 루틴은이 기능을 제공하지 않기 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f4a129f6da7edb3d3e9d992e64ee7ec5edc1382d" translate="yes" xml:space="preserve">
          <source>If Perldoc is running under MSWin and uses this class as a formatter, the output will be opened with</source>
          <target state="translated">Perldoc이 MSWin에서 실행 중이고이 클래스를 포맷터로 사용하는 경우 출력은</target>
        </trans-unit>
        <trans-unit id="48a7e7d61da87b6e49574cb96f576ab3af92a97c" translate="yes" xml:space="preserve">
          <source>If Pod::Man is given the &lt;code&gt;utf8&lt;/code&gt; option, the encoding of its output file handle will be forced to UTF-8 if possible, overriding any existing encoding. This will be done even if the file handle is not created by Pod::Man and was passed in from outside. This maintains consistency regardless of PERL_UNICODE and other settings.</source>
          <target state="translated">Pod :: Man에 &lt;code&gt;utf8&lt;/code&gt; 이 제공된 경우 옵션 되면 가능한 경우 출력 파일 핸들의 인코딩이 기존 인코딩을 대체하여 UTF-8로 강제됩니다. 이것은 파일 핸들이 Pod :: Man에 의해 작성되지 않고 외부에서 전달 된 경우에도 수행됩니다. 이는 PERL_UNICODE 및 기타 설정에 관계없이 일관성을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="89e668a66a16049973d228d4291fce70e3c9695a" translate="yes" xml:space="preserve">
          <source>If Pod::Man is unavailable, this function will warn and return undef.</source>
          <target state="translated">Pod :: Man을 사용할 수없는 경우이 함수는 경고를 표시하고 undef를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0b2424487d45dbfa5c1b518ecd9497b822e7398c" translate="yes" xml:space="preserve">
          <source>If Pod::Simple sends an event where the element name has a dash, period, or colon, the corresponding method name will have a underscore in its place. For example, &quot;foo.bar:baz&quot; becomes start_foo_bar_baz and end_foo_bar_baz.</source>
          <target state="translated">Pod :: Simple에서 요소 이름에 대시, 마침표 또는 콜론이있는 이벤트를 보내면 해당 메서드 이름에 밑줄이 표시됩니다. 예를 들어 &quot;foo.bar:baz&quot;는 start_foo_bar_baz 및 end_foo_bar_baz가됩니다.</target>
        </trans-unit>
        <trans-unit id="9e0153ee2898f6429d842dbcd6c0696456ff28ca" translate="yes" xml:space="preserve">
          <source>If Pod::Text is given the &lt;code&gt;utf8&lt;/code&gt; option, the encoding of its output file handle will be forced to UTF-8 if possible, overriding any existing encoding. This will be done even if the file handle is not created by Pod::Text and was passed in from outside. This maintains consistency regardless of PERL_UNICODE and other settings.</source>
          <target state="translated">Pod :: Text에 &lt;code&gt;utf8&lt;/code&gt; 옵션 이 제공 되면 가능한 경우 출력 파일 핸들의 인코딩이 기존 인코딩을 대체하여 UTF-8로 강제됩니다. 이것은 파일 핸들이 Pod :: Text에 의해 작성되지 않고 외부에서 전달 된 경우에도 수행됩니다. 이는 PERL_UNICODE 및 기타 설정에 관계없이 일관성을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="a28c6ae29cd39f20d43e841a87f74f6e887bacb7" translate="yes" xml:space="preserve">
          <source>If RXf_WHITE is set in addition to this flag, &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; will behave like &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; &quot; &quot;&lt;/code&gt; under the Perl engine.</source>
          <target state="translated">이 플래그 외에 RXf_WHITE가 설정되면 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 은 Perl 엔진에서 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; &quot; &quot;&lt;/code&gt; 처럼 동작합니다 .</target>
        </trans-unit>
        <trans-unit id="03dddb9eda0980e6158ca2dd506258dca11f657b" translate="yes" xml:space="preserve">
          <source>If SIGNAL is either the number 0 or the string &lt;code&gt;ZERO&lt;/code&gt; (or &lt;code&gt;SIGZERO&lt;/code&gt; ), no signal is sent to the process, but &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; checks whether it's</source>
          <target state="translated">SIGNAL이 숫자 0이거나 문자열 &lt;code&gt;ZERO&lt;/code&gt; (또는 &lt;code&gt;SIGZERO&lt;/code&gt; )이면 프로세스에 신호가 전송되지 않지만 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="a487625a13afee57a95232e398ffaae21162742b" translate="yes" xml:space="preserve">
          <source>If SIGNAL is either the number 0 or the string &lt;code&gt;ZERO&lt;/code&gt; (or &lt;code&gt;SIGZERO&lt;/code&gt; ), no signal is sent to the process, but &lt;code&gt;&lt;a href=&quot;kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; checks whether it's</source>
          <target state="translated">SIGNAL이 숫자 0이거나 문자열 &lt;code&gt;ZERO&lt;/code&gt; (또는 &lt;code&gt;SIGZERO&lt;/code&gt; )이면 프로세스에 신호가 전송되지 않지만 &lt;code&gt;&lt;a href=&quot;kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="34e4af5120e01452063bdba16ab4dbac8800d707" translate="yes" xml:space="preserve">
          <source>If SUBNAME or BLOCK is omitted, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;s in standard string comparison order. If SUBNAME is specified, it gives the name of a subroutine that returns an integer less than, equal to, or greater than &lt;code&gt;0&lt;/code&gt; , depending on how the elements of the list are to be ordered. (The &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; and &lt;code&gt;cmp&lt;/code&gt; operators are extremely useful in such routines.) SUBNAME may be a scalar variable name (unsubscripted), in which case the value provides the name of (or a reference to) the actual subroutine to use. In place of a SUBNAME, you can provide a BLOCK as an anonymous, in-line sort subroutine.</source>
          <target state="translated">SUBNAME 또는 BLOCK이 생략 된 경우 표준 문자열 비교 순서로 s를 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; . SUBNAME을 지정 하면 목록의 요소를 정렬하는 방법에 따라 &lt;code&gt;0&lt;/code&gt; 보다 작거나 같거나 큰 정수를 리턴하는 서브 루틴의 이름을 제공합니다 . ( &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 및 &lt;code&gt;cmp&lt;/code&gt; 연산자는 이러한 루틴에서 매우 유용합니다.) SUBNAME은 스칼라 변수 이름 (미 첨자) 일 수 있으며,이 경우 값은 사용할 실제 서브 루틴의 이름 (또는 참조)을 제공합니다. SUBNAME 대신, 익명의 인라인 정렬 서브 루틴으로 BLOCK을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6247155ef0e0949eed5f5b9ad662fcdc5e0b1a55" translate="yes" xml:space="preserve">
          <source>If SUBNAME or BLOCK is omitted, &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;s in standard string comparison order. If SUBNAME is specified, it gives the name of a subroutine that returns an integer less than, equal to, or greater than &lt;code&gt;0&lt;/code&gt; , depending on how the elements of the list are to be ordered. (The &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; and &lt;code&gt;cmp&lt;/code&gt; operators are extremely useful in such routines.) SUBNAME may be a scalar variable name (unsubscripted), in which case the value provides the name of (or a reference to) the actual subroutine to use. In place of a SUBNAME, you can provide a BLOCK as an anonymous, in-line sort subroutine.</source>
          <target state="translated">SUBNAME 또는 BLOCK이 생략 된 경우 표준 문자열 비교 순서로 s를 &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; . SUBNAME을 지정 하면 목록의 요소를 정렬하는 방법에 따라 &lt;code&gt;0&lt;/code&gt; 보다 작거나 같거나 큰 정수를 리턴하는 서브 루틴의 이름을 제공합니다 . ( &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 및 &lt;code&gt;cmp&lt;/code&gt; 연산자는 이러한 루틴에서 매우 유용합니다.) SUBNAME은 스칼라 변수 이름 (미 첨자) 일 수 있으며,이 경우 값은 사용할 실제 서브 루틴의 이름 (또는 참조)을 제공합니다. SUBNAME 대신, 익명의 인라인 정렬 서브 루틴으로 BLOCK을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a13dff4a6a23dd2b6f1693ccf60f7a4736231a4" translate="yes" xml:space="preserve">
          <source>If TEMPLATE requires more arguments than pack() is given, pack() assumes additional &lt;code&gt;&quot;&quot;&lt;/code&gt; arguments. If TEMPLATE requires fewer arguments than given, extra arguments are ignored.</source>
          <target state="translated">TEMPLATE에 pack ()보다 많은 인수가 필요한 경우 pack ()은 추가 &lt;code&gt;&quot;&quot;&lt;/code&gt; 인수를 가정합니다 . TEMPLATE에 지정된 것보다 적은 수의 인수가 필요한 경우 추가 인수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="71eeb63629102190a2491abe8e8c2cd018b18803" translate="yes" xml:space="preserve">
          <source>If Unix level &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;lseek&lt;/code&gt; is not appropriate for (say) sockets then the &quot;unix&quot; layer can be replaced (at open time or even dynamically) with a &quot;socket&quot; layer.</source>
          <target state="translated">소켓에 유닉스 레벨 &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;lseek&lt;/code&gt; 가 적절하지 않다면, &quot;유닉스&quot;레이어를 &quot;소켓&quot;레이어로 (개방 시간 또는 동적으로) 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="adc19b00b38eb533e11534d089e59dc6d18d7552" translate="yes" xml:space="preserve">
          <source>If VARIABLE is a hash, it chomps the hash's values, but not its keys, resetting the &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; iterator in the process.</source>
          <target state="translated">VARIABLE이 해시 인 경우 프로세스에서 &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 반복자를 재설정하여 키가 아닌 해시 값을 숨 깁니다 .</target>
        </trans-unit>
        <trans-unit id="dafdb7a192ed4ebf56859ae04ece9ebbc7f84c1d" translate="yes" xml:space="preserve">
          <source>If VARIABLE is a hash, it chomps the hash's values, but not its keys, resetting the &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; iterator in the process.</source>
          <target state="translated">VARIABLE이 해시 인 경우 프로세스에서 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 반복자를 재설정하여 키가 아닌 해시 값을 숨 깁니다 .</target>
        </trans-unit>
        <trans-unit id="a9c742cbb93e88b3095e1366a5e0ca8820689343" translate="yes" xml:space="preserve">
          <source>If VERSION is provided, &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; sets the &lt;code&gt;$VERSION&lt;/code&gt; variable in the given namespace to a &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; object with the VERSION provided. VERSION must be a &quot;strict&quot; style version number as defined by the &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; module: a positive decimal number (integer or decimal-fraction) without exponentiation or else a dotted-decimal v-string with a leading 'v' character and at least three components. You should set &lt;code&gt;$VERSION&lt;/code&gt; only once per package.</source>
          <target state="translated">VERSION이 제공되면 &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; 는 제공된 네임 스페이스 의 &lt;code&gt;$VERSION&lt;/code&gt; 변수를 VERSION이 제공된 &lt;a href=&quot;version&quot;&gt;버전&lt;/a&gt; 객체로 설정합니다. VERSION은 &lt;a href=&quot;version&quot;&gt;버전&lt;/a&gt; 모듈에 의해 정의 된 &quot;엄격한&quot;스타일 버전 번호 여야합니다. 지수가없는 양의 10 진수 (정수 또는 10 진수) 또는 앞에 'v'문자가 있고 최소 3 개의 점이있는 10 진 v-string 구성 요소. 패키지 당 &lt;code&gt;$VERSION&lt;/code&gt; 한 번만 설정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="4bfad8b6a5366a04a7526e534903361716196c11" translate="yes" xml:space="preserve">
          <source>If VERSION is provided, &lt;code&gt;&lt;a href=&quot;package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; sets the &lt;code&gt;$VERSION&lt;/code&gt; variable in the given namespace to a &lt;a href=&quot;../version&quot;&gt;version&lt;/a&gt; object with the VERSION provided. VERSION must be a &quot;strict&quot; style version number as defined by the &lt;a href=&quot;../version&quot;&gt;version&lt;/a&gt; module: a positive decimal number (integer or decimal-fraction) without exponentiation or else a dotted-decimal v-string with a leading 'v' character and at least three components. You should set &lt;code&gt;$VERSION&lt;/code&gt; only once per package.</source>
          <target state="translated">VERSION이 제공되면 &lt;code&gt;&lt;a href=&quot;package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; 는 제공된 네임 스페이스 의 &lt;code&gt;$VERSION&lt;/code&gt; 변수를 VERSION이 제공된 &lt;a href=&quot;../version&quot;&gt;버전&lt;/a&gt; 객체로 설정합니다. VERSION은 &lt;a href=&quot;../version&quot;&gt;버전&lt;/a&gt; 모듈에 의해 정의 된 &quot;엄격한&quot;스타일 버전 번호 여야합니다. 지수가없는 양의 10 진수 (정수 또는 10 진수) 또는 앞에 'v'문자가 있고 최소 3 개의 점이있는 10 진 v-string 구성 요소. 패키지 당 &lt;code&gt;$VERSION&lt;/code&gt; 한 번만 설정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="562d6a085d036935dc458e97eb2b83b32b781d44" translate="yes" xml:space="preserve">
          <source>If a</source>
          <target state="translated">만약</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
