<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="b981c090e0ccf2394ca9d98ec6e98f5fdb3b15ee" translate="yes" xml:space="preserve">
          <source>use &lt;code&gt;&amp;amp;len&lt;/code&gt; ). If you do not care what the length of the data is, use the &lt;code&gt;SvPV_nolen&lt;/code&gt; macro. Historically the &lt;code&gt;SvPV&lt;/code&gt; macro with the global variable &lt;code&gt;PL_na&lt;/code&gt; has been used in this case. But that can be quite inefficient because &lt;code&gt;PL_na&lt;/code&gt; must be accessed in thread-local storage in threaded Perl. In any case, remember that Perl allows arbitrary strings of data that may both contain NULs and might not be terminated by a &lt;code&gt;NUL&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab7c0594a0c4ad4b7139bc4478498a69f7e492fd" translate="yes" xml:space="preserve">
          <source>use &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b438f8ebaf9cd38ef6ddc105cb8f6b0e5c7983a5" translate="yes" xml:space="preserve">
          <source>use &lt;code&gt;B&amp;lt;&amp;gt;&lt;/code&gt; for commands names like &lt;b&gt;cat&lt;/b&gt; or &lt;b&gt;grep&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="912f09261e74f066e3e24f4b46906e4342000bf4" translate="yes" xml:space="preserve">
          <source>use &lt;code&gt;C&amp;lt;&amp;gt;&lt;/code&gt; for function, variable and module names (and more generally anything that can be considered part of code, like filehandles or specific values). Note that function names are considered more readable with parentheses after their name, that is &lt;code&gt;function()&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91895a1cf51d91f57aca46510d3d62ba8b32f1ee" translate="yes" xml:space="preserve">
          <source>use &lt;code&gt;F&amp;lt;&amp;gt;&lt;/code&gt; or &lt;code&gt;C&amp;lt;&amp;gt;&lt;/code&gt; for file names. &lt;code&gt;F&amp;lt;&amp;gt;&lt;/code&gt; should be the only Pod code for file names, but as most Pod formatters render it as italic, Unix and Windows paths with their slashes and backslashes may be less readable, and better rendered with &lt;code&gt;C&amp;lt;&amp;gt;&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdc3bde8eda2284372421b6e4025b7b2372a316b" translate="yes" xml:space="preserve">
          <source>use Bourne shell (&lt;code&gt;sh(1)&lt;/code&gt; ) redirection syntax in backticks, not &lt;code&gt;csh(1)&lt;/code&gt; ! Details on why Perl's &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; and backtick and pipe opens all use the Bourne shell are in the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16599c655382953c8630fbbdb2c964d3e8dee9ae" translate="yes" xml:space="preserve">
          <source>use Module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90f04428920392ff9b2def8ba0ed469f079b6502" translate="yes" xml:space="preserve">
          <source>use Module LIST</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ed0869d2d4fc928494f42d5819555da7a79edd6" translate="yes" xml:space="preserve">
          <source>use Module VERSION</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2de803ffc4c0a3b39ed0dff30412c19bd9d9fee" translate="yes" xml:space="preserve">
          <source>use Module VERSION LIST</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed1b16f9eadabbae879f86b68ec71e8b6d05ca67" translate="yes" xml:space="preserve">
          <source>use Perl; used to provide a slashdot-style news/blog website covering all things Perl, from minutes of the meetings of the Perl 6 Design team to conference announcements with (ir)relevant discussion. It no longer accepts updates, but you can still use the site to read old entries and comments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d91bc845470d4a86d4018011a4792f7dcf86f037" translate="yes" xml:space="preserve">
          <source>use SA_RESTART. Consequently, restartable system calls can fail (with $! set to &lt;code&gt;EINTR&lt;/code&gt; ) in places where they previously would have succeeded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c7c49503a611307f683497f7df47accbf51802a" translate="yes" xml:space="preserve">
          <source>use VERSION</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86d6a1e3bbd163625d7fac651620cbfa17805164" translate="yes" xml:space="preserve">
          <source>use bytes;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59d6056cfb56b5a37f62f1bf027d56c8cb904bd1" translate="yes" xml:space="preserve">
          <source>use integer vs. use bigint</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="814151fffad1e37f33b4e503823e70b6bbf3c04b" translate="yes" xml:space="preserve">
          <source>use integer;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d1d48f5b10a148ad0e4d39b9da43de87d730e84" translate="yes" xml:space="preserve">
          <source>use of a backslash to include a space in a word</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f5c67435c71d9a6ca9c3233dedb2dc1513c55c2" translate="yes" xml:space="preserve">
          <source>use of a backslash to remove the special meaning of a double-quote</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6fe0074742b81fff90e497bf135242ea8e89606" translate="yes" xml:space="preserve">
          <source>use of quotes to include a space in a word</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c01026ad061791e802cf597a172313b49e695da" translate="yes" xml:space="preserve">
          <source>use re 'strict'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cda9500ef317eb6fc5a5f798984325090df1150f" translate="yes" xml:space="preserve">
          <source>use re;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53e07a32bf191d6917ee6fd863f0b52632a86798" translate="yes" xml:space="preserve">
          <source>use strict</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8428b0851b0684a353e7ed0874608908c7b5144e" translate="yes" xml:space="preserve">
          <source>use strict;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="371d195a9f9f3ece23b26e71d1dd939d2d111281" translate="yes" xml:space="preserve">
          <source>use symbolic references are when you really must refer to the symbol table. This may be because it's something that one can't take a real reference to, such as a format name. Doing so may also be important for method calls, since these always go through the symbol table for resolution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b052d587b755b57eec4828588dac107af257aee" translate="yes" xml:space="preserve">
          <source>use the &lt;code&gt;sources&lt;/code&gt; parameter below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbacfc4c115173ec78e0b2e5387eefbdb941b814" translate="yes" xml:space="preserve">
          <source>use the brackets. These are correct: &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(FH)&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;(FH, 0,
2)&lt;/code&gt; and &quot;copying from STDIN to FILE&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16242ca7d468c97ea7b6997607a050d2e0014a3f" translate="yes" xml:space="preserve">
          <source>use utf8;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d9bf76551e571ede80cc893a3c04b1861a56e60" translate="yes" xml:space="preserve">
          <source>use warnings;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43e6bb793575b0e1c61db35e98228f60aeaf2f8d" translate="yes" xml:space="preserve">
          <source>use()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d05287976184d88c455cd302b00f63b076bbdc63" translate="yes" xml:space="preserve">
          <source>use64bits.U</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de888ddd185c016565479b29ef9407370202fca3" translate="yes" xml:space="preserve">
          <source>usebacktrace.U</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c75278e55d10139a00150399331bbf063800d605" translate="yes" xml:space="preserve">
          <source>useconds or interval more than ...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83a7a6b40353b9f6be160c361611ae311dfb9752" translate="yes" xml:space="preserve">
          <source>useconds or uinterval equal to or more than 1000000</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="192a56759d36454cc0b8c812e31845e9ed10b130" translate="yes" xml:space="preserve">
          <source>used</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73decdd966503bbba3c9fd02a2b5f2ce91746665" translate="yes" xml:space="preserve">
          <source>used by &lt;code&gt;DynaLoader&lt;/code&gt; for DLL name mangling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e30f4a35ac593e13f39f5488a20368f2d3e27f69" translate="yes" xml:space="preserve">
          <source>used by &lt;code&gt;File::Copy::copy&lt;/code&gt; , see &lt;a href=&quot;file/copy&quot;&gt;File::Copy&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6651965b06637ac206b1de96bf978eb27b24abe2" translate="yes" xml:space="preserve">
          <source>used by Microsoft C/C++), all of these functions will be available for use. Otherwise, you won't be able to perform the SHA-384 and SHA-512 transforms, both of which require 64-bit operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bcdb1a3c67ee6a36e9c8f01fec7794365214c0a" translate="yes" xml:space="preserve">
          <source>used in the Canonical Ordering Algorithm. For Unicode 5.1, this is described in Section 3.11 &lt;code&gt;Canonical Ordering Behavior&lt;/code&gt; available at &lt;a href=&quot;http://www.unicode.org/versions/Unicode5.1.0/&quot;&gt;http://www.unicode.org/versions/Unicode5.1.0/&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d652c7d874ec8b1c40417e324ea5d062c754cc5c" translate="yes" xml:space="preserve">
          <source>used in this way, the result of evaluation of &lt;code&gt;code&lt;/code&gt; is put into the special variable &lt;code&gt;$^R&lt;/code&gt; . This happens immediately, so &lt;code&gt;$^R&lt;/code&gt; can be used from other &lt;code&gt;(?{ code })&lt;/code&gt; assertions inside the same regular expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="910e6213db30e16ad6b1c4b4021611873d6ce5e8" translate="yes" xml:space="preserve">
          <source>usedtrace.U</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae3154c3ec5c365c6959f779a04adc35659601ba" translate="yes" xml:space="preserve">
          <source>usefaststdio.U</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="682aa3c2d38618cf64e946cc3bbd2fc8a96d01db" translate="yes" xml:space="preserve">
          <source>useful programs are slow</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64cd2a07a89b1a0f1da29526d021d0937a062dc3" translate="yes" xml:space="preserve">
          <source>useful:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86959ccaa35c5e158cbc673c5b275d5c75322ffb" translate="yes" xml:space="preserve">
          <source>usekernprocpathname.U</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfb174e9b45efda0d2813ab34a52566fc0e5149a" translate="yes" xml:space="preserve">
          <source>uselfs.U</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a865fd135358714278adf708601a551aa95d374" translate="yes" xml:space="preserve">
          <source>uselongdbl.U</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f139461261d4e47392a29d9a1470571a111a9dc" translate="yes" xml:space="preserve">
          <source>uselongdouble.cbu</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55dcabac6b2a581cb97ea8cc9bfb5c2c032a1aa2" translate="yes" xml:space="preserve">
          <source>usemorebits.U</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cacd09fc8d7a5be6357aae988bf81988f273cde2" translate="yes" xml:space="preserve">
          <source>usemultiplicity.U</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="999728bc8bffebc44a36dcc8573424d9a99a522c" translate="yes" xml:space="preserve">
          <source>usenm.U</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="135519af067f60479443d73bde99b3ce40a82660" translate="yes" xml:space="preserve">
          <source>usensgetexecutablepath.U</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8a6096831b8f25daa716e7ca10d96073259de34" translate="yes" xml:space="preserve">
          <source>useperlio.U</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97f9b6453ab8627d3cd32b5de7ede1a376eb1e42" translate="yes" xml:space="preserve">
          <source>usequadmath.U</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12dea96fec20593566ab75692c9949596833adc9" translate="yes" xml:space="preserve">
          <source>user</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="948109d35f9658f13aa26db4dca1ebe12f69c043" translate="yes" xml:space="preserve">
          <source>user interface (tty or graphical)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99cd2c26d48da74abf7a71cda0673fef004fd48c" translate="yes" xml:space="preserve">
          <source>user time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7e2c648dc9941f38aea4196f90df226d6e93b2b" translate="yes" xml:space="preserve">
          <source>uses</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fe9b31e1cb4034ae05b748f916caeb04bc961ae" translate="yes" xml:space="preserve">
          <source>uses &lt;code&gt;$a&lt;/code&gt; for the width, &lt;code&gt;$b&lt;/code&gt; for the precision, and &lt;code&gt;$c&lt;/code&gt; as the value to format; while:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09830868f1f121ce087a3809e753c0b99304db3d" translate="yes" xml:space="preserve">
          <source>uses dl_findfile() to determine the filename to load</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5af968b0841a76d30d08c146e669a78b4cab19ad" translate="yes" xml:space="preserve">
          <source>uses empty string matches as separators to produce the output 'a:b:c'; thus, the empty string may be used to split EXPR into a list of its component characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90fd05af98859035d1a5f230da49fa1011416f54" translate="yes" xml:space="preserve">
          <source>uses the 'b' in 'abc' as a separator to produce the output 'a:c'. However, this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0385b247665cc9feec9dd5e3fae26654605693e5" translate="yes" xml:space="preserve">
          <source>uses the &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a1854e57bb3e0204fcdb39b3f71fdc0b1165103" translate="yes" xml:space="preserve">
          <source>uses the lexical variables that are maintained by the closure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09d1afddd581a0eacf04d5d0d5756a7efff2579d" translate="yes" xml:space="preserve">
          <source>uses the object passed to the method to store any context data, whereas the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3ceef66b33c51bee6d1bb1d471003d812947110" translate="yes" xml:space="preserve">
          <source>uses the string &lt;code&gt;&quot;\n&quot;&lt;/code&gt; as the line delimiter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3cd2678befce2c7f2ae3fa75bbf277408ae4f0c" translate="yes" xml:space="preserve">
          <source>usesocks.U</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9de3288841199ccb6c310b320eb302bb6d60b04" translate="yes" xml:space="preserve">
          <source>usethreads.U</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92bd75ebd8fd2b0179172217b15350cc6d4002f0" translate="yes" xml:space="preserve">
          <source>using</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="598c217817c73e5780e3966c099266496e2980d1" translate="yes" xml:space="preserve">
          <source>using GNU libc and you can ignore &lt;code&gt;LANGUAGE&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16fc297cbc600394f05f8c2154dec797fd2616a9" translate="yes" xml:space="preserve">
          <source>using the &lt;b&gt;parseopts()&lt;/b&gt; method. The set of currently accepted parse-options is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ddf1529ff81cf1646da1b5ad744e5598d0ce2a2" translate="yes" xml:space="preserve">
          <source>using the G_EVAL flag, it promptly reset &lt;code&gt;$@&lt;/code&gt; . This results in the failure of the outermost test for &lt;code&gt;$@&lt;/code&gt; , and thereby the failure of the error trap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb699932692b6b7e2ea37fceb7f7f660756e9c08" translate="yes" xml:space="preserve">
          <source>using the mkstemp() from this module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74206ccb17460da0011cfb062984120700d158f9" translate="yes" xml:space="preserve">
          <source>usrinc.U</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f68489ebd04ca3a9cf85cc582f26b952d9e0e821" translate="yes" xml:space="preserve">
          <source>usually denotes an intensity, but the name does not matter). The number</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="552fa32543fec03ccf6183c2b935ef13e3235d5b" translate="yes" xml:space="preserve">
          <source>usually have their own documentation, either in the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b8f21f7c75d9b9f23162e7287673f1417b09fab" translate="yes" xml:space="preserve">
          <source>usually need to be overridden by subclasses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81f0c4ab9b5679964eab3692a28c6daa905d6fc9" translate="yes" xml:space="preserve">
          <source>utf8</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf16403afd56538795ee624940c94265c7f38841" translate="yes" xml:space="preserve">
          <source>utf8 - Perl pragma to enable/disable UTF-8 (or UTF-EBCDIC) in source code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a594f2111ee293665faf1e597c91b88defdbc7c8" translate="yes" xml:space="preserve">
          <source>utf8.h</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c23f5615906bc56a2ba756aeb96aa29939293657" translate="yes" xml:space="preserve">
          <source>utf8::unicode_to_native() and utf8::native_to_unicode()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1817968011ad57f4fc7f6411c6afa179d20d5f52" translate="yes" xml:space="preserve">
          <source>utfebcdic.h</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccf120ba24ab73f5ca75edfecede60e684a35e77" translate="yes" xml:space="preserve">
          <source>utility (which should be installed if you have gcc 3.0 or newer installed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e41e3186138fd652f131d74e1372b713a50e4b13" translate="yes" xml:space="preserve">
          <source>utility available from the shell or from the C library. Consult your system's documentation for information on iconv.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b875306388033d91efeec1a88fa3e69e64258572" translate="yes" xml:space="preserve">
          <source>utility is distributed as part of the &lt;a href=&quot;http://search.cpan.org/perldoc/Module::Starter&quot;&gt;Module::Starter&lt;/a&gt; CPAN package. It creates a directory with stubs of all the necessary files to start a new module, according to recent &quot;best practice&quot; for module development, and is invoked from the command line, thus:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1c19560c50c6028812fe75cd093528162e899fa" translate="yes" xml:space="preserve">
          <source>utility which can be used to package Perl scripts and/or Perl library directories into SIS files, which can be installed to the device. To run the sisify.pl utility, you will need to have the 'makesis' and 'uidcrc' utilities already installed. If you don't have the Win32 SDKs, you may try for example &lt;a href=&quot;http://gnupoc.sourceforge.net/&quot;&gt;http://gnupoc.sourceforge.net/&lt;/a&gt; or &lt;a href=&quot;http://symbianos.org/~andreh/&quot;&gt;http://symbianos.org/~andreh/&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5b20e9780dfec2e3ed9c87a6333e7f3f40af656" translate="yes" xml:space="preserve">
          <source>utility will look for errors in your markup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abd2ad286bf2e0b3a412f26ebf2a2be21f7de0fc" translate="yes" xml:space="preserve">
          <source>utility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5b9fa572bc5bd55617cfad38a4c758f62792ceb" translate="yes" xml:space="preserve">
          <source>utility. If none of these apply then passive mode is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14409714f17737ef57cc19222c7537577b62d475" translate="yes" xml:space="preserve">
          <source>utils/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07be56c9175d1e0cf47abe27bd2ea4c74d0a71b7" translate="yes" xml:space="preserve">
          <source>utime</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e021c739267a3c120765dfd8bbf7a3476cf90409" translate="yes" xml:space="preserve">
          <source>utime LIST</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3677a34e80cc23f49ad5f1fae628d097e1c1e1cb" translate="yes" xml:space="preserve">
          <source>uu encoding and decoding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a38d8cbd20d9932ba948efaa364bb62651d5ad4" translate="yes" xml:space="preserve">
          <source>v</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="361122ca0dc8560cf79ff094f6193cd4093bfbfc" translate="yes" xml:space="preserve">
          <source>v1.0.0 &amp;ndash; first public release, 2012-02-27</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8d7aee24dfe0953c95b730f8777dd9d65515b2c" translate="yes" xml:space="preserve">
          <source>v5.22 core Perl runs on z/OS (formerly OS/390). Theoretically it could run on the successors of OS/400 on AS/400 minicomputers as well as VM/ESA, and BS2000 for S/390 Mainframes. Such computers use EBCDIC character sets internally (usually Character Code Set ID 0037 for OS/400 and either 1047 or POSIX-BC for S/390 systems).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39f69c278f46165447f30d10acf54277aaa3d5fc" translate="yes" xml:space="preserve">
          <source>val</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c204f11609a31497c02218b5e5a0a169c78effbe" translate="yes" xml:space="preserve">
          <source>valgrind</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53046fa987b388728c455fdf478e8c9a874dace2" translate="yes" xml:space="preserve">
          <source>valid as UTF-8. A line consisting of simply &quot;#&quot;, an e-acute, and any non-highbit byte, is sufficient to establish this file's encoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f32b67c7e26342af42efabc674d441dca0a281c5" translate="yes" xml:space="preserve">
          <source>value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e7e5e9fa34075181b1c3ae301720ed61601a7be" translate="yes" xml:space="preserve">
          <source>value is returned. It is up to the user to call &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; if they so desire.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="216685f7982133ab569ad4dfe5f678f3e1dbbd1f" translate="yes" xml:space="preserve">
          <source>value of 4. Pod processors may complain if</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="789c8a7b03ce1d1295ddf529b2afdf58a3077c30" translate="yes" xml:space="preserve">
          <source>value of the array pointed to by $AoA. If you wanted the C notion, you'd have to write &lt;code&gt;${$AoA[$i]}&lt;/code&gt; to force the &lt;code&gt;$AoA[$i]&lt;/code&gt; to get evaluated first before the leading &lt;code&gt;$&lt;/code&gt; dereferencer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8f2b9679159768f9feb1485f4697501baee27a2" translate="yes" xml:space="preserve">
          <source>value which forms part of the method names described in &lt;a href=&quot;#Package-specific-Attribute-Handling&quot;&gt;Package-specific Attribute Handling&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8ad9fad6207027296ab17875f3071f0a7723f9b" translate="yes" xml:space="preserve">
          <source>value, with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="345c822266c73d960e7e049d7d44d3fac7c7ec19" translate="yes" xml:space="preserve">
          <source>value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1de6ed8b204380a369710406f1cf40db9ea3121e" translate="yes" xml:space="preserve">
          <source>value. If the user does not call either of these methods then the result will be a reference to a &lt;code&gt;Net::FTP::dataconn&lt;/code&gt; based object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44415ffb02a62884cecd489fafaf5338dd30ca7a" translate="yes" xml:space="preserve">
          <source>value. If you want to see if the array is empty, just use &lt;code&gt;if (@array) { # not empty }&lt;/code&gt; for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="417801383c26ee78fc40ea379e8eda01aa338144" translate="yes" xml:space="preserve">
          <source>value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="048b0cb1b94379c74e7e8c8ede496e3edbea3386" translate="yes" xml:space="preserve">
          <source>values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17a7c4c339f3492b8acb953db7732092bf51412a" translate="yes" xml:space="preserve">
          <source>values ARRAY</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2634c50fe8c56acb708defe572a6f66bd0ae2e7a" translate="yes" xml:space="preserve">
          <source>values EXPR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be8bd433d6363b535b0f1f125f2785bdc4c730c2" translate="yes" xml:space="preserve">
          <source>values HASH</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52427f1ebccdb4fcea47bc5d0e5145b7b892e93d" translate="yes" xml:space="preserve">
          <source>values from 0 to 5, such as &lt;code&gt;rgb000&lt;/code&gt; or &lt;code&gt;rgb515&lt;/code&gt; . Similarly, the recognized background colors are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e74a3ebadeba9abb6c66ee5f8ffd1d486ee6fcb8" translate="yes" xml:space="preserve">
          <source>values from 0 to 5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6ad9de07df6ee716656600f984ea5e44acf9199" translate="yes" xml:space="preserve">
          <source>values may already be available through the POSIX, Errno, or Fcntl modules.) The &lt;b&gt;pl2pm&lt;/b&gt; file in the distribution may help in your conversion, but it's just a mechanical process and therefore far from bulletproof.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6d212092cfb3c4de0fc9e126c8856174b98ea6d" translate="yes" xml:space="preserve">
          <source>values of variables, open file handles) are not affected by calling &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c78a54d54f417f166b040fd1193f989fbac7669b" translate="yes" xml:space="preserve">
          <source>vaproto.U</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5b4e786e382d03c28e9edfab2d8149378ae69df" translate="yes" xml:space="preserve">
          <source>var</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="442355f6097724b9f300211ae8b56c9215274278" translate="yes" xml:space="preserve">
          <source>varargs.h</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32c263408bb93f559077c6e179bd9ba556508a09" translate="yes" xml:space="preserve">
          <source>varglob (VARNAME)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b46d0172433dd6895dac7544b9dacbb87b361e9f" translate="yes" xml:space="preserve">
          <source>variable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f28cdc93712b217f7e1a7f8c732549e7fca12478" translate="yes" xml:space="preserve">
          <source>variable. If found, and the value does not begin with a slash, and the terminal type name is the same as the environment string</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73be3da84c74dd524e9174ed859ebd8fbe0ecb3e" translate="yes" xml:space="preserve">
          <source>variables with) the compartment's namespace and only that data will be visible to code evaluated in the compartment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="328b2913d40a4414bbacabb3a360dbd897edd419" translate="yes" xml:space="preserve">
          <source>vars</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0738423627650c10c37e4c0cb07def0732c0229" translate="yes" xml:space="preserve">
          <source>vars - Perl pragma to predeclare global variable names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fda85e28248463329b5095a7e36c028b3156227" translate="yes" xml:space="preserve">
          <source>vary in size. The alignment constraint of the structure can be greater than any of its elements. [And if you think that this doesn't affect anything common, dismember the next cellphone that you see. Many have ARM cores, and the ARM structure rules make &lt;code&gt;sizeof (foo_t)&lt;/code&gt; == 4]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b803e7ca5c714dbd85bf00d511fbc99a77690ad2" translate="yes" xml:space="preserve">
          <source>vec</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c54a18ac21d0acf2be7f8a4af68b6de9a68db6ff" translate="yes" xml:space="preserve">
          <source>vec EXPR,OFFSET,BITS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32af47b87ac2b19a971faaedbed3373dcd83c6e8" translate="yes" xml:space="preserve">
          <source>vector flag</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f997c58732c07191b9cf44ba3c5fdd710cc19a22" translate="yes" xml:space="preserve">
          <source>vendorarch.U</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78c0f01568b26ab7021a574fad5f974198aad6d0" translate="yes" xml:space="preserve">
          <source>vendorbin.U</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="660495819236779e293a0a32c3609f3b6829ad8a" translate="yes" xml:space="preserve">
          <source>vendorhtml1dir.U</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba034d33799b6d494964ade71fe262b57e78da69" translate="yes" xml:space="preserve">
          <source>vendorhtml3dir.U</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c5f94ad3d73d98afb7e36c994b2d58e93b157c9" translate="yes" xml:space="preserve">
          <source>vendorlib.U</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2284692bf04e52a99af83b0173dbfd7bb5474851" translate="yes" xml:space="preserve">
          <source>vendorman1dir.U</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bb32aac5c75643dd8a475440312246f61ee79e2" translate="yes" xml:space="preserve">
          <source>vendorman3dir.U</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="105d52e11b963cf884747461ead872a0d154eae4" translate="yes" xml:space="preserve">
          <source>vendorprefix.U</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5ff5428b3a391d0a31fc7b9d32363c3703413d8" translate="yes" xml:space="preserve">
          <source>vendorscript.U</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e0b8aa15aad848de36cf3fd23d80803845b78d5" translate="yes" xml:space="preserve">
          <source>ver</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a4dc0c486f7ec2c6e9ab752e3ce6d8bf47f6d1c" translate="yes" xml:space="preserve">
          <source>verbatim paragraphs, but</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c692273deb2772da307ffe37041fef77bf4baa97" translate="yes" xml:space="preserve">
          <source>version</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3b94753b152e0687bf16e0e66bde6c46129e227" translate="yes" xml:space="preserve">
          <source>version 0.2304</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10ac6ea1ff9c002c30c590cc6d63a98d39a0b85d" translate="yes" xml:space="preserve">
          <source>version 1.4414</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76c801534aba92a44e1c434c81eb16f53ac7ddba" translate="yes" xml:space="preserve">
          <source>version 1.70</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50dd6edfb9d761a98efb572f5834520db1b98413" translate="yes" xml:space="preserve">
          <source>version 3.1, this means configuring with &lt;code&gt;-Doptimize=-g3&lt;/code&gt; . Other compilers might use a different switch (if they support debugging macros at all).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d8e3493b0cc6a16d5dae9adf9f2dd0db64b3340" translate="yes" xml:space="preserve">
          <source>version 5.021009</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44d2f7e0b9f8b8f230b98d6215f70ce9e9142a5e" translate="yes" xml:space="preserve">
          <source>version mismatch</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6d98fbd6e1f722af1a7187d887c11be3eebc59e" translate="yes" xml:space="preserve">
          <source>version number to standard output, then exits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="753706ebef33a950942786467c39030e3338394b" translate="yes" xml:space="preserve">
          <source>version of documentation (&lt;b&gt;very&lt;/b&gt; recommended) outside of OS/2, one needs an IBM's reader (may be available on IBM ftp sites (?) (URL anyone?)) or shipped with PC DOS 7.0 and IBM's Visual Age C++ 3.5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8debcc6e279c738f85bcad06098d11cd2de6baac" translate="yes" xml:space="preserve">
          <source>version of the callback with the same args, or if the f is invalid, set errno to EBADF and return</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da458f9f51eff82b9638d6edc4d1ce471a6ba279" translate="yes" xml:space="preserve">
          <source>version of the callback with the same args, or if the f is invalid, set errno to EBADF.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89ea6fd5613838ed30c0baa85610d353411b9790" translate="yes" xml:space="preserve">
          <source>version/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="636593de67e783331b57ae2dba0e1181ac91cb43" translate="yes" xml:space="preserve">
          <source>version/archname/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="278658a67f306172b28c147dd5c2b59021a8cb9c" translate="yes" xml:space="preserve">
          <source>versiononly.U</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95280caf11d86c580985b1777a2534b60278693b" translate="yes" xml:space="preserve">
          <source>versus/csh.whynot</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e74295bfc2ed0b52d40073e8ebad555100df1380" translate="yes" xml:space="preserve">
          <source>very</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81cacac029430830dfca23f87b705db6949c1ea0" translate="yes" xml:space="preserve">
          <source>very same place</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2e6aa26ddeffa0689780c36cd916b4d3bb69f77" translate="yes" xml:space="preserve">
          <source>very simple</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efbea1089258378284b4c64dc60908c3c6b4f3b3" translate="yes" xml:space="preserve">
          <source>vfork.h</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="833da188871dde4c49e08271ff3deff524b7992c" translate="yes" xml:space="preserve">
          <source>vi</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a19e070e30616772d5e5bccf22dd825266237820" translate="yes" xml:space="preserve">
          <source>via</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b741f8124ff9a5cff40f1444836353cc05d2208" translate="yes" xml:space="preserve">
          <source>via &lt;code&gt;sh.exe&lt;/code&gt; via &lt;code&gt;perl.exe&lt;/code&gt; , but this is a price to pay if you want to use non-conforming program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b68c8b6949fa7692f33f6e0bbc33b71066897e0" translate="yes" xml:space="preserve">
          <source>via pointers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65f7d47d7029da85cdba5bc94831dbaa426ce6e5" translate="yes" xml:space="preserve">
          <source>via shell</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1e73a24ed2cd61923e64ac891a0cf0355e98da1" translate="yes" xml:space="preserve">
          <source>vianame() normally returns an ordinal code point, but when the input name is of the form &lt;code&gt;U+...&lt;/code&gt; , it returns a chr instead. In this case, if &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; is in effect and the character won't fit into a byte, it returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and raises a warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="857a269ccef5d7fbbb98d9ddef77bc0b5d9701a9" translate="yes" xml:space="preserve">
          <source>vice versa</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af84d91fde168566c7dc18f3121ea2fbe651af1f" translate="yes" xml:space="preserve">
          <source>virtual</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="273d3211f66d3ed5bfd77d7571871ddef64f03b6" translate="yes" xml:space="preserve">
          <source>virtual time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd9d67fe1b466b2dd61a9d25c1346a7e24941513" translate="yes" xml:space="preserve">
          <source>vms/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92e911c38db62b637631e5e6d4e2f54b71f1b1ec" translate="yes" xml:space="preserve">
          <source>vmsish</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6f4b16934c4d0ae88fbb45f248668506c1e515a" translate="yes" xml:space="preserve">
          <source>vmsish - Perl pragma to control VMS-specific language features</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47c9b6c34c34bb84a495fafd2ac449b137a21fcf" translate="yes" xml:space="preserve">
          <source>vmsperl list, vmsperl-subscribe@perl.org</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43e59f877b6e30149c0ab30290dad796aad04379" translate="yes" xml:space="preserve">
          <source>vmsperl on the web, &lt;a href=&quot;http://www.sidhe.org/vmsperl/index.html&quot;&gt;http://www.sidhe.org/vmsperl/index.html&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9cede9b80ea3abd89c755f1117337d429162c86" translate="yes" xml:space="preserve">
          <source>void</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9901ea7bc50240c07dbde1f94425cb15aba6f905" translate="yes" xml:space="preserve">
          <source>volume names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aff024fe4ab0fece4091de044c58c9ae4233383a" translate="yes" xml:space="preserve">
          <source>w</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daaad336276d15594d0e765f96c17cd746bf4971" translate="yes" xml:space="preserve">
          <source>wait</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16599a2caf0e43357dfd62cf1bbedac5d4f9aa78" translate="yes" xml:space="preserve">
          <source>wait() and waitpid() can be passed a pseudo-process ID returned by fork(). These calls will properly wait for the termination of the pseudo-process and return its status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69c29097cb967e595fc1da3e699aa0f1c4465d43" translate="yes" xml:space="preserve">
          <source>wait(2)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2adada1e71a33f071825f68863aa78076956f91c" translate="yes" xml:space="preserve">
          <source>waitpid</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a5601dcd3b6db75e71ed2908ce3b9fba9edaa57" translate="yes" xml:space="preserve">
          <source>waitpid PID,FLAGS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33a4d790db96047d8f48435d61872442016da10a" translate="yes" xml:space="preserve">
          <source>waitpid(3)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a714f64e3698739073c4107159d7e2ec7580a59" translate="yes" xml:space="preserve">
          <source>wallclock time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36fae1179f0e54b2fbcfa0e1e58a96822af50f7c" translate="yes" xml:space="preserve">
          <source>want a record separator of 0777, specify it as &lt;b&gt;-0x1FF&lt;/b&gt;. (This means that you cannot use the &lt;b&gt;-x&lt;/b&gt; option with a directory name that consists of hexadecimal digits, or else Perl will think you have specified a hex number to &lt;b&gt;-0&lt;/b&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa1de8a88193794f6bcd0270bd3c78df8da87f33" translate="yes" xml:space="preserve">
          <source>want locks to block access, then go ahead and tie them to something and manage this yourself. This is done on purpose. While managing access to variables is a good thing, Perl doesn't force you out of its living room...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42f9df8dd43a1cbf03eed19f45b2ac004af68f76" translate="yes" xml:space="preserve">
          <source>want to follow an &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; with some other statement, you can use one of these styles to avoid the warning:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1be38d5f877aab6abdfed0efc178920ad9fb017d" translate="yes" xml:space="preserve">
          <source>want to follow an &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; with some other statement, you can use one of these styles to avoid the warning:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b18cfd0bd3a597bb757ac9a15224a9fadf94a687" translate="yes" xml:space="preserve">
          <source>want to make the same transformation to all keys and/or values in a DBM database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8898e1e919ff199c09160ba3765d7cb61b031b32" translate="yes" xml:space="preserve">
          <source>want to make the same transformation to all keys, all values or both.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80f812f0ab1052c34ba58a9aa6c43451d87573ad" translate="yes" xml:space="preserve">
          <source>want to subclass &lt;a href=&quot;../parser&quot;&gt;TAP::Parser&lt;/a&gt;'s grammar the best thing to do is read through the code. There's no easy way of summarizing it here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76f51d192120dd11344a546a620674d65ea15871" translate="yes" xml:space="preserve">
          <source>wantarray</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77921eed5c933c5cd87a4b266d8972f000e6983e" translate="yes" xml:space="preserve">
          <source>wanted()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5383092a76f9a7f2052899ae6bf06e0ebac04977" translate="yes" xml:space="preserve">
          <source>wants</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e586b17a78dad3ec40f5515d1f0072bbcf17f64" translate="yes" xml:space="preserve">
          <source>wants to succeed, so it uses the standard pattern back-off-and-retry and lets &lt;code&gt;\D*&lt;/code&gt; expand to just &quot;AB&quot; this time. Now there's indeed something following &quot;AB&quot; that is not &quot;123&quot;. It's &quot;C123&quot;, which suffices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c8ea4760fcb5dff8ec1af0394a338be9df55090" translate="yes" xml:space="preserve">
          <source>warn</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd055b1e3e77f358b39e3dcec164c30e81c00105" translate="yes" xml:space="preserve">
          <source>warn LIST</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f4c20cf2e4f20443c501790a359300f5f40529f" translate="yes" xml:space="preserve">
          <source>warning messages. These messages will be displayed by default. But this is not the same as &lt;code&gt;verbose&lt;/code&gt; mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f6be01127af67b499b57da0fae72ba37a45a9a4" translate="yes" xml:space="preserve">
          <source>warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd207fab08951eb6cee30e4969e79ca50d1f7c65" translate="yes" xml:space="preserve">
          <source>warnings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69788f5b932d69519f6c6fa630facec7b52027c8" translate="yes" xml:space="preserve">
          <source>warnings. The difference is that although the previously mandatory warnings are still enabled by default, they can then be subsequently enabled or disabled with the lexical warning pragma. For example, in the code below, an &lt;code&gt;&quot;isn't numeric&quot;&lt;/code&gt; warning will only be reported for the &lt;code&gt;$a&lt;/code&gt; variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25304d614db590d11bde4fb00d1385306732fa04" translate="yes" xml:space="preserve">
          <source>warnings::register</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38c5e56d56c5509ef7afa87cb247e50311f9a294" translate="yes" xml:space="preserve">
          <source>warnings::register - warnings import function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3de521d3619155e9228f83cc5f773bfcbfc52749" translate="yes" xml:space="preserve">
          <source>was</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f062dc50293a6ebef0644413f16dbe666de1a1ed" translate="yes" xml:space="preserve">
          <source>was available through the &lt;code&gt;Thread.pm&lt;/code&gt; API. This threading model has been deprecated, and was removed as of Perl 5.10.0.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f19bc6bea19581bc44bbfb345e232346246a9a6" translate="yes" xml:space="preserve">
          <source>was called without options, but with the additional behaviour that the temporary file is removed by the object destructor if UNLINK is set to true (the default).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f83d8fcf9f9f581aff720bc3d0f0345f5631b7ae" translate="yes" xml:space="preserve">
          <source>was changed to return some value(s), having specified G_DISCARD will mean that they will be wiped by the time control returns from</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="358b1b390577816773119471fd35f58a152fe39c" translate="yes" xml:space="preserve">
          <source>was deliberately picked to avoid namespace tainting -- this module may be used as a base class so method names that appear in Encode::Encoding are avoided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ef5ff209fb64ad33c3a43e09b9777f546e6d687" translate="yes" xml:space="preserve">
          <source>was disabled, IO::Zlib has not much chance of working.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc39726c2752bbbdac1623dec16d2ec7ec5530fe" translate="yes" xml:space="preserve">
          <source>was modified after creation. Note that if a temp directory is your current directory, it cannot be removed - a warning will be given in this case. C</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c2cacfa9911a9740c2f39057d9556ce6e3a53b2" translate="yes" xml:space="preserve">
          <source>was not built, user must have HOST perl and properly edit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1a5fcfd7b191fc7b62fed25dba309a60f6a62f6" translate="yes" xml:space="preserve">
          <source>was used to invoke native compiler to create HOST miniperl, which then facilitates cross-compiling process. Extension building support was added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66ffd23620129e551f53385e61617103184d89ce" translate="yes" xml:space="preserve">
          <source>was written, not even Perl 5.6.0 had been born yet, many features documented in the book remained unimplemented for a long time. Perl 5.8 corrected much of this, and the introduction of the UTF8 flag is one of them. You can think of there being two fundamentally different kinds of strings and string-operations in Perl: one a byte-oriented mode for when the internal UTF8 flag is off, and the other a character-oriented mode for when the internal UTF8 flag is on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="181b4dd436ea635e496b642bf6193eba9531e9f5" translate="yes" xml:space="preserve">
          <source>wasn't installed or doesn't work for you, you can</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="146b5dae12284acb165c37a9e39cd9753cbc537e" translate="yes" xml:space="preserve">
          <source>wc</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fe0dfef3d9b02dc86d540b75c78abe297bdb20e" translate="yes" xml:space="preserve">
          <source>we can write the more sensible (see &lt;a href=&quot;test/more&quot;&gt;Test::More&lt;/a&gt; for a full explanation of is() and other testing functions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85ea3c732a0cadb4cba11f8084adbc162ad146ff" translate="yes" xml:space="preserve">
          <source>we prevent backtracking and find the count of the longest matching string at each matching starting point like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d0b0b7bc297d97e84595de72ecb8a0030fdd17e" translate="yes" xml:space="preserve">
          <source>we've checked all its derived classes (i.e. before we tried &lt;code&gt;Mother&lt;/code&gt; and &lt;code&gt;MaternalGrandparent&lt;/code&gt; ).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcb9e7c68cc7aee9b7ae828bf3eb4f0c0ab95fcd" translate="yes" xml:space="preserve">
          <source>weaken</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae27e6a12247433968a2426ceb5f2faec9f64b2d" translate="yes" xml:space="preserve">
          <source>webget</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79b1646e47722f151fadfe6b4b9cfd75b5507a18" translate="yes" xml:space="preserve">
          <source>week number</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6894b43bb03af96eabb423701dc0bc9e071a3e0" translate="yes" xml:space="preserve">
          <source>were affected. This leads to spooky, incorrect action at a distance that is hard to debug.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a8fc1dcdcb951afef794f96428b2c2d30d4cbdd" translate="yes" xml:space="preserve">
          <source>were fine, but the hard ones like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3e74349971aeb0151fc1bfbab7d483e124b80fe" translate="yes" xml:space="preserve">
          <source>were merged, so perlce build process comes in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9421eaaa36860a069e3089b1dd32635567692a1f" translate="yes" xml:space="preserve">
          <source>were the command shell, this would probably work better:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a110e6b9a361653a042e3f5dfbac4c6105693789" translate="yes" xml:space="preserve">
          <source>what</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5028edf30c355a53744774edb4e246a65bdda7eb" translate="yes" xml:space="preserve">
          <source>what &lt;code&gt;File::GlobMapper&lt;/code&gt; does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b36160c1ec6399ee58f1e1eaed45b1a11a29091d" translate="yes" xml:space="preserve">
          <source>what follows, it just leaves the choice open. Thus, after</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="235cc5e25df726ef139cc4e3ed273f18953c310e" translate="yes" xml:space="preserve">
          <source>what it does</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a97de175ae265b931e0f47d8189ba1c158846c3" translate="yes" xml:space="preserve">
          <source>what you want to use to capture the output from a command; for that you should use merely backticks or &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt;, as described in &lt;a href=&quot;perlop#%60STRING%60&quot;&gt;`STRING` in perlop&lt;/a&gt;. Return value of -1 indicates a failure to start the program or an error of the wait(2) system call (inspect $! for the reason).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3926fc849cd226411c2dc28dbb3c1ac9425d41ae" translate="yes" xml:space="preserve">
          <source>what you want to use to capture the output from a command; for that you should use merely backticks or &lt;code&gt;&lt;a href=&quot;qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt;, as described in &lt;a href=&quot;../perlop#%60STRING%60&quot;&gt;`STRING` in perlop&lt;/a&gt;. Return value of -1 indicates a failure to start the program or an error of the wait(2) system call (inspect $! for the reason).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a01f2e26cea4a9807d9d068afa0bdc36ba5e00e" translate="yes" xml:space="preserve">
          <source>what you're doing, you can use the &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&lt;/code&gt; modifiers to force big- or little-endian byte-order on floating-point values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d869db7fe62fb07c25a0403ecaea55031744b5fb" translate="yes" xml:space="preserve">
          <source>whatever</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="021bc9488a6a6118c1c75c3f7a5aeeaa12491ccd" translate="yes" xml:space="preserve">
          <source>whatever falls between &lt;code&gt;\Q&lt;/code&gt; and &lt;code&gt;\E&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30603fa9e0f620c305cd627ab0ff138a960c48bd" translate="yes" xml:space="preserve">
          <source>when</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed6268873901e8209d3ac22fc700c31706eaa9bd" translate="yes" xml:space="preserve">
          <source>when &quot;dumping&quot;; it has nothing to do with $| auto-flush.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c89dac7f6e160306ca10f788c9bd6a54efcd1ffc" translate="yes" xml:space="preserve">
          <source>when &lt;code&gt;xsubpp&lt;/code&gt; is invoked with &lt;code&gt;-s foo_&lt;/code&gt; will install a &lt;code&gt;foo_bar&lt;/code&gt; function in Perl, but really call &lt;code&gt;bar(i)&lt;/code&gt; in C. Most of the time, this is the opposite of what you want and failure modes are somewhat obscure, so please avoid this option where possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75aed76d9314bc923e71101c151f2b2893f266e7" translate="yes" xml:space="preserve">
          <source>when another process is holding the lockfile. This is an experimental feature that is not yet tested very well. This second shell then does not write the history file, does not use the metadata file, and has a different prompt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba1a27d93b87aa252d9684f7f42d0351ba582ec5" translate="yes" xml:space="preserve">
          <source>when necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cd9d2e738a8b92221411f890d0e1eb0c5e3b660" translate="yes" xml:space="preserve">
          <source>when the element to return happens to be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b023844c7b290ca1a038802a6472c7aeafce41c" translate="yes" xml:space="preserve">
          <source>when the element to return happens to be &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="938c56ff8ee83ab6578974df30b9d1c7e33fe7dd" translate="yes" xml:space="preserve">
          <source>when the functions are called from within the scope of the &lt;code&gt;&lt;a href=&quot;bytes&quot;&gt;use bytes&lt;/a&gt;&lt;/code&gt; pragma</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ce6402418c47b212eb07ca370a93108ff150f4a" translate="yes" xml:space="preserve">
          <source>when the imaginary part is zero (otherwise, it would not be called an extension, would it?).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb1cef34e0771ae508dd63618b6d7ebc545d708d" translate="yes" xml:space="preserve">
          <source>when this tutorial was written. It has now been split off with &lt;code&gt;pp_unpack&lt;/code&gt; to its own file,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac26161b0187ead053283bca27ee59e832cfa160" translate="yes" xml:space="preserve">
          <source>when you ask for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e5e701932ff1e08475464ba8b75ee91dc43d41c" translate="yes" xml:space="preserve">
          <source>when you intended</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e06c432fa349d548f06ebf0f8b460c130ec25ac" translate="yes" xml:space="preserve">
          <source>when you meant</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="320723f30d494b8eb54e4b744bfd8f4219fbd71c" translate="yes" xml:space="preserve">
          <source>when you meant to say</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b09f6864ed10d92f6a10d3420ae332e50823d21" translate="yes" xml:space="preserve">
          <source>when you should have said</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfe41b37d5bad835ce1295749ffd97e4c9fffaac" translate="yes" xml:space="preserve">
          <source>when you should have written this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46148cc3b4d2b3ac8073f14b0cba7f25ffff54bd" translate="yes" xml:space="preserve">
          <source>where</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab1c267bd23a7a2761e1a1311799eacd65a53cf8" translate="yes" xml:space="preserve">
          <source>where &quot;ENCODING&quot; must be a valid encoding name that the Encode module recognises.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f76ee4872ba64c6359656344e5d58fab47ab470" translate="yes" xml:space="preserve">
          <source>where $MAKE is whatever 'make' program you have configured perl to use. Use &quot;perl -V:make&quot; to find out what this is. Some extensions may not provide a testsuite (so &quot;$MAKE test&quot; may not do anything or fail), but most serious ones do.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8069144ce0898197e96d2bb7ebc0edbdaca8457" translate="yes" xml:space="preserve">
          <source>where $term is a return value of Term::ReadLine-&amp;gt;new().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9c15a20c87c2836864971183b1c442723a838ac" translate="yes" xml:space="preserve">
          <source>where $x is either less than -128 or more than 127; the &lt;code&gt;&quot;c&quot;&lt;/code&gt; format is only for encoding native operating system characters (ASCII, EBCDIC, and so on) and not for Unicode characters, so Perl behaved as if you meant</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bbc43aec00d96c64d05508ffb3bbad3e39afaec" translate="yes" xml:space="preserve">
          <source>where $x is either less than 0 or more than 255. However, &lt;code&gt;U0&lt;/code&gt; -mode expects all values to fall in the interval [0, 255], so Perl behaved as if you meant:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00bca38c6c6b0a3593705b287c03db33903d5e5f" translate="yes" xml:space="preserve">
          <source>where $x is either less than 0 or more than 255; the &lt;code&gt;&quot;C&quot;&lt;/code&gt; format is only for encoding native operating system characters (ASCII, EBCDIC, and so on) and not for Unicode characters, so Perl behaved as if you meant</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="890f9b49db55ce1098a844385610bbb13debaa4c" translate="yes" xml:space="preserve">
          <source>where 0x0400 stands for &lt;code&gt;U+0400&lt;/code&gt; , CYRILLIC CAPITAL LETTER IE WITH GRAVE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="825d5d6d780f8829ebcd8a7016c279905b219a90" translate="yes" xml:space="preserve">
          <source>where 7E is the hexadecimal ASCII code point for &quot;~&quot;. Here is an example of decoding such a URL in any EBCDIC code page:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4809a830fe1a3429edeff7f9faf0dee554dbec4" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;$parser&lt;/code&gt; is a reference to the parser object, &lt;code&gt;$text&lt;/code&gt; is the text-string encountered, and &lt;code&gt;$ptree_node&lt;/code&gt; is a reference to the current node in the parse-tree (usually an interior-sequence object or else the top-level node of the parse-tree).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d298264d5947d99205d766cae90ed2313035af45" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;$parser&lt;/code&gt; is a reference to the parser object, and &lt;code&gt;$ptree&lt;/code&gt; is a reference to the parse-tree object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5957a8e4bc7c51d1071eb22f8fe1b48116af9153" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;$parser&lt;/code&gt; is a reference to the parser object, and &lt;code&gt;$sequence&lt;/code&gt; is a reference to the interior-sequence object. [</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15d410b2ce2184b4347be136da68a7719dc0ad85" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;$source&lt;/code&gt; is the filespec of the file being installed. &lt;code&gt;$target&lt;/code&gt; is where it is being installed to, and &lt;code&gt;$uninstalled&lt;/code&gt; is any shadow file that is in &lt;code&gt;@INC&lt;/code&gt; or &lt;code&gt;$ENV{PERL5LIB}&lt;/code&gt; or other standard locations, and &lt;code&gt;$pattern&lt;/code&gt; is the pattern that caused a source file to be skipped. In future more keys will be added, such as to show created directories, however this requires changes in other modules and must therefore wait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a731b563e701bcb16a123ecab85071d224c107aa" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;$where_to_export&lt;/code&gt; is an integer telling how far up the calling stack to export your symbols, and &lt;code&gt;@what_to_export&lt;/code&gt; is an array telling what symbols *to* export (usually this is &lt;code&gt;@_&lt;/code&gt; ). The &lt;code&gt;$package&lt;/code&gt; argument is currently unused.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48e1c4094f5de010428575d8622f327516bc33ae" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;HERE&lt;/code&gt; can be replaced by other identifiers like with normal Perl HERE-docs. All details below about the typemap textual format remain valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="721c549e68ff19e2994566a74f0b393f57d254d1" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;MyParser&lt;/code&gt; is some subclass of &lt;b&gt;Pod::Parser&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b03bee177daa8ad34db5c35f4571b92ff18e039c" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;SP&lt;/code&gt; is the macro that represents the local copy of the stack pointer, and &lt;code&gt;num&lt;/code&gt; is the number of elements the stack should be extended by.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de39703cfc1e976397e4c498b4e76e18c8f99017" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;a&lt;/code&gt; is the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6950fd3c6bf4eda6d69d7afe08226888f67c407d" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;function&lt;/code&gt; is the name of the function you want to memoize, or a reference to it. &lt;code&gt;memoize&lt;/code&gt; returns a reference to the new, memoized version of the function, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on a non-fatal error. At present, there are no non-fatal errors, but there might be some in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9baeb27f249365fedd4a037a93595125d9a6014e" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;rho&lt;/code&gt; is the distance to the origin, and &lt;code&gt;theta&lt;/code&gt; the angle between the vector and the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd9e76180b06bd2a44ffe663c1ff849e0a103ca7" translate="yes" xml:space="preserve">
          <source>where FALLBACK can take any of the three values TRUE, FALSE, or UNDEF. If you do not set any FALLBACK value when using OVERLOAD, it defaults to UNDEF. FALLBACK is not used except when one or more functions using OVERLOAD have been defined. Please see &lt;a href=&quot;overload#fallback&quot;&gt;fallback in overload&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50396b7e08b271e8034d662ba4fd67f410cb1b19" translate="yes" xml:space="preserve">
          <source>where a more complete solution would split the URL into components and apply a full s/// substitution only to the appropriate parts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21585635f4365441aa2484d0f4019c953a7d7b86" translate="yes" xml:space="preserve">
          <source>where chr(0xff) is expected but the test fails because the result is chr(0xff). Exactly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16f78d439c89dcc67cc6d31385ff3dcec533675f" translate="yes" xml:space="preserve">
          <source>where each successive 'list add' option will push the value of add into array ref $list-&amp;gt;{'add'}. The result would be like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="517c0898eef6d5914aa381031eb301a948ecc075" translate="yes" xml:space="preserve">
          <source>where such changes can be applied by the means of cherry-picking from blead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1ba074422bf23c3944014acd8f065e730791214" translate="yes" xml:space="preserve">
          <source>where that number is the command number, and which you'd use to access with the built-in &lt;b&gt;csh&lt;/b&gt;-like history mechanism. For example, &lt;code&gt;!17&lt;/code&gt; would repeat command number 17. The depth of the angle brackets indicates the nesting depth of the debugger. You could get more than one set of brackets, for example, if you'd already at a breakpoint and then printed the result of a function call that itself has a breakpoint, or you step into an expression via &lt;code&gt;s/n/t
expression&lt;/code&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe3cffb107c47b95f0ae454e3de2e7e1743bb5ce" translate="yes" xml:space="preserve">
          <source>where the &lt;code&gt;&quot;|&quot;&lt;/code&gt; is a binary operator with an operand on the right, but no operand on the left.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b244c23995363daf148f79037f34977ba5711e52" translate="yes" xml:space="preserve">
          <source>where the &lt;code&gt;TYPEMAP&lt;/code&gt; keyword must appear in the first column of a new line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="764e081905d06edddf30c836b21ee0f9eb49e89c" translate="yes" xml:space="preserve">
          <source>where the &lt;code&gt;minlen&lt;/code&gt; would be 3 but &lt;code&gt;minlenret&lt;/code&gt; would only be 2 as the \d is required to match but is not actually included in the matched content. This distinction is particularly important as the substitution logic uses the &lt;code&gt;minlenret&lt;/code&gt; to tell if it can do in-place substitutions (these can result in considerable speed-up).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e11e55dd4712573d987efd1c0884f0c120edda61" translate="yes" xml:space="preserve">
          <source>where the Perl equivalent of &lt;code&gt;register_fatal&lt;/code&gt; and the callback it registers, &lt;code&gt;pcb1&lt;/code&gt; , might look like this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34cc28c0ed6b3b975c1f8b2f5bfccf3f2b674b4a" translate="yes" xml:space="preserve">
          <source>where the first argument, an &lt;code&gt;SV*&lt;/code&gt; , must be a reference, and the second argument is a stash. The returned &lt;code&gt;SV*&lt;/code&gt; can now be used in the same way as any other SV.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb8f1012228e6574e355ca23612690ce9ced4433" translate="yes" xml:space="preserve">
          <source>where the format expects to process a byte (a character with a value below 256), but a higher value was provided instead. Perl uses the value modulus 256 instead, as if you had provided:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b51b446492bdddf5835c8b7127ee3a8fcffa16ed" translate="yes" xml:space="preserve">
          <source>where the format expects to process a sequence of bytes (character with a value below 256), but some of the characters had a higher value. Perl uses the character values modulus 256 instead, as if you had provided:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c49be26fe2412d08b959e58ce62ecd11e8effd9" translate="yes" xml:space="preserve">
          <source>where these arguments mean:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fe303f9adde4840e097ed0d238372b72ff5d199" translate="yes" xml:space="preserve">
          <source>where those dot files live</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00a755e878e51b6d3d95aae065147ee2272798c2" translate="yes" xml:space="preserve">
          <source>where you'd otherwise have to write</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09c0979062616fd0606b29296df335c67d5531c0" translate="yes" xml:space="preserve">
          <source>whereupon we might see something like this, with each pair of hex digits corresponding to a byte:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fac826754ebef5d0de7380bb2ebdf79ac73e626" translate="yes" xml:space="preserve">
          <source>whether the contents are interpreted as a signed or unsigned number,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc2033256fe72f3be5253a7be85085b830e059f5" translate="yes" xml:space="preserve">
          <source>whether the next byte is in the range 0x80 - 0xBF. If so, the parser may conclude that this file is in UTF-8, and all highbit sequences in the file should be assumed to be UTF-8. Otherwise the parser should treat the file as being in CP-1252. (A better check, and which works on EBCDIC platforms as well, is to pass a copy of the sequence to &lt;a href=&quot;utf8&quot;&gt;utf8::decode()&lt;/a&gt; which performs a full validity check on the sequence and returns TRUE if it is valid UTF-8, FALSE otherwise. This function is always pre-loaded, is fast because it is written in C, and will only get called at most once, so you don't need to avoid it out of performance concerns.) In the unlikely circumstance that the first highbit sequence in a truly non-UTF-8 file happens to appear to be UTF-8, one can cater to our heuristic (as well as any more intelligent heuristic) by prefacing that line with a comment line containing a highbit sequence that is clearly</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13f9423890a306b627963ea70ef49e8541a4438e" translate="yes" xml:space="preserve">
          <source>whether we should try to change or remove those dot files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed04ff4dabf1e2d4cd6b89136c2b24dec27ecca4" translate="yes" xml:space="preserve">
          <source>which</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d060cbd0fbb1156378e849bb6c04d6e687e74342" translate="yes" xml:space="preserve">
          <source>which can also be done with &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map()&lt;/a&gt;&lt;/code&gt; which is made to transform one list into another:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="679cb19369252215832643aae001a33e00c3edb8" translate="yes" xml:space="preserve">
          <source>which can just be converted to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1058597fc80ec1ae6c9468976c2082b39dc74418" translate="yes" xml:space="preserve">
          <source>which can print filenames terminated by the null character, you can say this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a1bf5f9e60cb26d6cb10d695574f7486a7350a5" translate="yes" xml:space="preserve">
          <source>which can work together</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26e6474c54d74f5e1b54fbb84567108ec9ec0be7" translate="yes" xml:space="preserve">
          <source>which contains a list of newXS() calls near the end. Removing unnecessary calls, and rerunning</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ba7f1a2c7d9e13feaebe2336a9a9752e948dcc6" translate="yes" xml:space="preserve">
          <source>which contains the profiling data collected during the execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="209bf9b2c21856efbe58794a447fa26435ea0055" translate="yes" xml:space="preserve">
          <source>which could also be written this way, using a trick that's come to be known as the Schwartzian Transform:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75ba4f37004a47ec33e2d83893fc18c49f7a2c2b" translate="yes" xml:space="preserve">
          <source>which did not load a particular DLL yet. This is why the DLLs are mapped to the shared memory region.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b963e7a5bc43a79a319cd65245b0963a9a74082" translate="yes" xml:space="preserve">
          <source>which does nothing, but succeeds on all the &quot;usual&quot; build targets. To do so, use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e68ca264c19e5e1287272ae8a0a048239c69afc" translate="yes" xml:space="preserve">
          <source>which has a length of 43. So, the properly padded version is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97b9b7ce1f9f8564271626441b5ed04c89fe2ee5" translate="yes" xml:space="preserve">
          <source>which has the short form</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf2897e01293c7352f75dce51f4052d41ff51799" translate="yes" xml:space="preserve">
          <source>which includes newly-installed via &lt;code&gt;Bundle::OS2_default&lt;/code&gt; modules. Doing testing via &lt;code&gt;CPAN.pm&lt;/code&gt; is going to be painfully slow, since it statically links a new executable per XS extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="740279f94d278254c20a1964b766588db7905a52" translate="yes" xml:space="preserve">
          <source>which interact with the memory allocator in other ways than via malloc(), realloc(), free(), calloc(), sbrk() and brk();</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27e6eae0fd902584be95e5d4c59ccdf92b2c93d3" translate="yes" xml:space="preserve">
          <source>which is Perl shorthand for the more explicitly written version:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2c5c74f3c46665187c755c53e173135dab99bf8" translate="yes" xml:space="preserve">
          <source>which is also expressed by this formula:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04c6ac4120301d7049af98011b0e572414db64b0" translate="yes" xml:space="preserve">
          <source>which is equivalent to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16a66c1b8256121eec60a422104c678c527a1b68" translate="yes" xml:space="preserve">
          <source>which is even the same as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40217363f21b2e6fa15982c559837fa626b0eb67" translate="yes" xml:space="preserve">
          <source>which is exactly what we had defined for negative real numbers above. The &lt;code&gt;&lt;a href=&quot;../functions/sqrt&quot;&gt;sqrt&lt;/a&gt;&lt;/code&gt; returns only one of the solutions: if you want the both, use the &lt;code&gt;root&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41660e5f3a05c257d71cd236ed7137b3831af720" translate="yes" xml:space="preserve">
          <source>which is generated from</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed4894b8ab4c596c6c6382023f8f4837da06efce" translate="yes" xml:space="preserve">
          <source>which is hard-wired to replace all occurrences of the string &lt;code&gt;&quot;Joe&quot;&lt;/code&gt; to &lt;code&gt;&quot;Jim&quot;&lt;/code&gt; . Not particularly Useful, but it is the first example and I wanted to keep it simple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4f1633dff7d510a448e9aaeeb40cb63e6e279d1" translate="yes" xml:space="preserve">
          <source>which is not, consequently, deparsed correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d53450b0fdca8bc7a9a33283360f4cc8874d6819" translate="yes" xml:space="preserve">
          <source>which is presumably easier to read than the old way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="590e9b690bb3d4c0ee4fe08d74808195b747676b" translate="yes" xml:space="preserve">
          <source>which is probably not what you were expecting. Unfortunately at least one reasonably common and modern C compiler does &quot;real backward compatibility&quot; here, in AIX that is what still happens even though the rest of the AIX compiler is very happily C89.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29eb09005f5e9aeeb936021e842907d6266dcfda" translate="yes" xml:space="preserve">
          <source>which is ready to be printed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="457319eaa9e4f3b728ed192e5fdb2e515988f305" translate="yes" xml:space="preserve">
          <source>which is the correct answer. This example illustrates that it is important not only to match what is desired, but to reject what is not desired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b2a157cb124d5116a790751a46e4a73627b6581" translate="yes" xml:space="preserve">
          <source>which is true (&lt;code&gt;&lt;a href=&quot;../functions/abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt; has the regular meaning for real number, i.e. stands for the absolute value). This example explains why the norm of &lt;code&gt;z&lt;/code&gt; is noted &lt;code&gt;&lt;a href=&quot;../functions/abs&quot;&gt;abs(z)&lt;/a&gt;&lt;/code&gt;: it extends the &lt;code&gt;&lt;a href=&quot;../functions/abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt; function to complex numbers, yet is the regular &lt;code&gt;&lt;a href=&quot;../functions/abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt; we know when the complex number actually has no imaginary part... This justifies</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3080d1b7e175b0f68ccca8d1ffcce6a17814f888" translate="yes" xml:space="preserve">
          <source>which is visible in other functions called from that subroutine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f78cd391c699a6564a6185a15b2c00459cb4b5f7" translate="yes" xml:space="preserve">
          <source>which lasts until the end of that BLOCK.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="400ae171fcca992b111ee0c9eaa8e6bbbbb647ec" translate="yes" xml:space="preserve">
          <source>which lasts until the end of that BLOCK. Note that this doesn't mean everything is an integer, merely that Perl will use integer operations for arithmetic, comparison, and bitwise operators. For example, even under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; , if you take the &lt;code&gt;&lt;a href=&quot;functions/sqrt&quot;&gt;sqrt(2)&lt;/a&gt;&lt;/code&gt;, you'll still get &lt;code&gt;1.4142135623731&lt;/code&gt; or so.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c45a01f777cdc33148420b0a627621b88968ca28" translate="yes" xml:space="preserve">
          <source>which looks like your module is doing something wrong. Instead, you want to put the blame on the user, and say this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="910ece59a1ee7a779c7904607756d8ac6f43840e" translate="yes" xml:space="preserve">
          <source>which makes Configure to use the &lt;code&gt;nm&lt;/code&gt; tool when scanning for library symbols, which usually is not done in AIX.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d3700f0082a2cd4c6079cbe90c96db947b50f48" translate="yes" xml:space="preserve">
          <source>which makes the intention more clear.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cd3d9060c1ace30dd6e2d6262dfd40d2021cad0" translate="yes" xml:space="preserve">
          <source>which may be useful for debugging a program that uses &lt;code&gt;Term::ReadLine&lt;/code&gt; itself. Do not forget to detach your shell from the TTY in the window that corresponds to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e2010dc06ea0515288724e36b214acf56509e41" translate="yes" xml:space="preserve">
          <source>which may modify the second input argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eee2fd622722c8b192547f36dd5b9891b7a1ad1e" translate="yes" xml:space="preserve">
          <source>which means</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04a52cf2a6a5e0c79d4fd67cec9d2eb15a88cc21" translate="yes" xml:space="preserve">
          <source>which outputs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f62e72ff87682e720abfa0dc12f99261d01428f" translate="yes" xml:space="preserve">
          <source>which pinpoints the real problem. Finally the script can now be modified to fix the original problem by destroying the API object before the untie:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac6415ae9e2075f760e53b307b58defa828d2b3f" translate="yes" xml:space="preserve">
          <source>which prints</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb6c88a0a4a00ee65fac2ab2a88d44234ed99c16" translate="yes" xml:space="preserve">
          <source>which prints (on my machine):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6aa678d657ea6708638daf467b4e464862338f7" translate="yes" xml:space="preserve">
          <source>which probably isn't what you intended (the &lt;code&gt;'???'&lt;/code&gt; is a sign that perl optimized away a constant value).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f77411f51027e18d6942d6aafcf90ba55ec2701" translate="yes" xml:space="preserve">
          <source>which produces the output (again, long lines have been wrapped here)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bef5e7ef43fdb712239e626bd67fabf93a351f45" translate="yes" xml:space="preserve">
          <source>which produces:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2902720610777e0cb05329288b1b2cd5b87bdd4" translate="yes" xml:space="preserve">
          <source>which provides a new Perl interpreter for each thread, and, by default, results in no data or state information being shared between threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f92ba8d28d485765994bd16e6b0139ab94d5b990" translate="yes" xml:space="preserve">
          <source>which puts literal commas into some of the list items. Write it without commas if you don't want them to appear in your data:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87d11dc8fa4ace81bc6cff5f401501d4f07cbd6a" translate="yes" xml:space="preserve">
          <source>which puts you into a readline interface. If &lt;code&gt;Term::ReadKey&lt;/code&gt; and either of &lt;code&gt;Term::ReadLine::Perl&lt;/code&gt; or &lt;code&gt;Term::ReadLine::Gnu&lt;/code&gt; are installed, history and command completion are supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f4d24b8ce89da9965a39a4a2a60f5482730186f" translate="yes" xml:space="preserve">
          <source>which rely on special alignment which is not provided by Perl's malloc().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdcf525abe96dbcca08ea62d672f58f208fd0fe2" translate="yes" xml:space="preserve">
          <source>which returns 'a/b/c' under Unix. Or:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec1e3337a0ee7b60523959a46060f22ddce31714" translate="yes" xml:space="preserve">
          <source>which returns a string consisting of the first character from each string. Using pack, we can write</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d4e654a3fe5a13b1285db512bfaad46b825adcf" translate="yes" xml:space="preserve">
          <source>which reverses the order of method call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a42738502aac554f3685b010c8c33d17b8d8a89" translate="yes" xml:space="preserve">
          <source>which runs script non-interactively, printing info on each entry into a subroutine and each executed line into the file named</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a26dc4262a5b530b9fd0491393a70987f0cb95f8" translate="yes" xml:space="preserve">
          <source>which sets the debugging packages directly. Note that &lt;code&gt;o debug 0&lt;/code&gt; turns debugging off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13c1eb00f520026b6ba1e70a18a4964822f7275f" translate="yes" xml:space="preserve">
          <source>which should be interpreted as a link to the &lt;code&gt;vertical|bar/slash&lt;/code&gt; POD page and not as a link to the &lt;code&gt;slash&lt;/code&gt; section of the &lt;code&gt;bar&lt;/code&gt; POD page with an anchor text of &lt;code&gt;vertical&lt;/code&gt; . Note that not only the anchor text will need to have formatting codes expanded, but so will the target of the link (to deal with E&amp;lt;&amp;gt; and Z&amp;lt;&amp;gt; formatting codes), and special handling of the section may be necessary depending on whether the translator wants to consider markup in sections to be significant when resolving links. See &lt;a href=&quot;../perlpodspec&quot;&gt;perlpodspec&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82d18cd1d1191a0e6eb914334f14809f4e2df5fc" translate="yes" xml:space="preserve">
          <source>which shows that spaces are still possible in the code parts. Nevertheless, when working with code and conditional expressions, the extended form of regexps is almost necessary in creating and debugging regexps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c562409303f52b59b405fbd73bdc489d191355d6" translate="yes" xml:space="preserve">
          <source>which specifies that the ambient pragmas are exactly those which are in scope at the point of calling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a01b2a58a6fdba96f9248e9340f26dd88b40f22f" translate="yes" xml:space="preserve">
          <source>which the range operator becomes false again. It doesn't become false till the next time the range operator is evaluated. It can test the right operand and become false on the same evaluation it became true (as in &lt;b&gt;awk&lt;/b&gt;), but it still returns true once. If you don't want it to test the right operand until the next evaluation, as in &lt;b&gt;sed&lt;/b&gt;, just use three dots (&lt;code&gt;&quot;...&quot;&lt;/code&gt; ) instead of two. In all other regards, &lt;code&gt;&quot;...&quot;&lt;/code&gt; behaves just like &lt;code&gt;&quot;..&quot;&lt;/code&gt; does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81c23090ff08e0fb68830283659fa8701d911f41" translate="yes" xml:space="preserve">
          <source>which then may be given to subsequent gprof runs to accumulate data over several runs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bc38136202aaeb79aacb17bb0b21ad3bf7c2961" translate="yes" xml:space="preserve">
          <source>which understands command arguments. One of such ports is listed in &lt;a href=&quot;#Prerequisites&quot;&gt;Prerequisites&lt;/a&gt; under RSX. Do not forget to set variable &lt;code&gt;&lt;a href=&quot;#PERL_SH_DIR&quot;&gt;PERL_SH_DIR&lt;/a&gt;&lt;/code&gt; as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da06cc8f27f2a4277c9d2ea18a97a8abd08b8a8d" translate="yes" xml:space="preserve">
          <source>which uses &lt;code&gt;(?&amp;gt;...)&lt;/code&gt; matches exactly when the one above does (verifying this yourself would be a productive exercise), but finishes in a fourth the time when used on a similar string with 1000000 &lt;code&gt;a&lt;/code&gt; s. Be aware, however, that, when this construct is followed by a quantifier, it currently triggers a warning message under the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma or &lt;b&gt;-w&lt;/b&gt; switch saying it &lt;code&gt;&quot;matches null string many times in regex&quot;&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1742d6043b0a0627cfbbf796a8a4aec58b9ba1e" translate="yes" xml:space="preserve">
          <source>which will automatically coerce the actual scalar type into an IV, UV, double, or string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fb146e9079ae4bc7011dc3190cd3e0c07fe95ee" translate="yes" xml:space="preserve">
          <source>which will call</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a70f5704ad119ee244b693c30eb2b8ff7c442560" translate="yes" xml:space="preserve">
          <source>which will cause</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="607626ffbe3fb95a065011f0e19304f91e5ce829" translate="yes" xml:space="preserve">
          <source>which will determine if more memory needs to be allocated. If so, it will call the function &lt;code&gt;sv_grow&lt;/code&gt; . Note that &lt;code&gt;SvGROW&lt;/code&gt; can only increase, not decrease, the allocated memory of an SV and that it does not automatically add space for the trailing &lt;code&gt;NUL&lt;/code&gt; byte (perl's own string functions typically do &lt;code&gt;SvGROW(sv, len + 1)&lt;/code&gt; ).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1979ea935ff5d0f72dacbfc022d39ca4775f4154" translate="yes" xml:space="preserve">
          <source>which will do conversion from LF to CR/LF on the output, or in the environment settings (add this to your .bashrc):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f602755896feed19e862deed34ab69b1cc800288" translate="yes" xml:space="preserve">
          <source>which will echo the cat command's output as it is generated, instead of waiting until the program has completed to print it out. It also checks the return value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b50d57b41b49f3ab1ba2caaab449544638d7c8f0" translate="yes" xml:space="preserve">
          <source>which will expand the macros using cpp. Don't be scared by the results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e71b54891a6848222e41887418f6d0101fb71a1" translate="yes" xml:space="preserve">
          <source>which will export Exporter's own import() method into YourModule. Everything will work as before but you won't need to include Exporter in &lt;code&gt;@YourModule::ISA&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b87794d0dcf9a6a672b27ff15db2b5b5df0e9109" translate="yes" xml:space="preserve">
          <source>which will match assigned characters known to be part of the Greek script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b95b054f4d66abe300e2020ad56271297a5fff0f" translate="yes" xml:space="preserve">
          <source>which will override system(), exec(), &lt;code&gt;``&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open(,'...|')&lt;/a&gt;&lt;/code&gt;. With current perl you may override only system(), readpipe() - the explicit version of &lt;code&gt;``&lt;/code&gt; , and maybe exec(). The code will substitute the one-argument call to system() by &lt;code&gt;CORE::system('cmd.exe', '/c', &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;)&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="456a31b1679a3c242ee6fcfa550ef4cff72097d5" translate="yes" xml:space="preserve">
          <source>which will print something like this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d9f99b15b9cecc682a88d237aaf65afdade60cb" translate="yes" xml:space="preserve">
          <source>which will pull in the crlf PerlIO layer which does LF -&amp;gt; CRLF conversion on every output generated by perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f021bf96a0c4f48629afad5e6635345dc7b47e5" translate="yes" xml:space="preserve">
          <source>which works exactly as it does for the &lt;code&gt;V&lt;/code&gt; and &lt;code&gt;X&lt;/code&gt; commands. Requires the &lt;code&gt;PadWalker&lt;/code&gt; module version 0.08 or higher; will warn if this isn't installed. Output is pretty-printed in the same style as for &lt;code&gt;V&lt;/code&gt; and the format is controlled by the same options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11c1ab2f8d5d6cd3a60669a9963f5426c9daee0d" translate="yes" xml:space="preserve">
          <source>which would produce:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a1c45867db7ee2d51ddbd3c9e7a13e56f64c459" translate="yes" xml:space="preserve">
          <source>which, again, is the default that you should probably never change. You cannot use this keyword on versions of perl before 5.16 to make XSUBs &lt;code&gt;static&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d75fc0dff9af022da4a609d39c10fe2dc49a67f" translate="yes" xml:space="preserve">
          <source>whichever is appropriate.) Also, make sure that the DLLs for external libraries are usable with with executables compiled without &lt;code&gt;-Zmtd&lt;/code&gt; options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6517f89c46c3f0d6db9cb009b8c7d1f98c371fa0" translate="yes" xml:space="preserve">
          <source>while</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c755db4e16e1ebd5579bf9df24c0a9dde1dc936a" translate="yes" xml:space="preserve">
          <source>while the object methods of the class still work as designed. This is a key feature of inside-out classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5daa18cf1bbf438222f9cb7416fc2f0b139eb61" translate="yes" xml:space="preserve">
          <source>while this is invalid:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2f5ed52eb803c45683b5fc0aa9520f29eb7cf52" translate="yes" xml:space="preserve">
          <source>whole class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a8cc6fdee71abc3b1476fb220e9d1cd4edb423d" translate="yes" xml:space="preserve">
          <source>whose dot files this object represents</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fd57b2686f4898d067d4a56c073c64e61db82bf" translate="yes" xml:space="preserve">
          <source>whose lookup failed, and naming the line number where the calling $lh-&amp;gt;maketext(</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10cff4034cedfb92a272cddd774b8b63e3bdad06" translate="yes" xml:space="preserve">
          <source>why</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70bec8a9bf5ecd2e6b37316e112b3f4c615ad4d3" translate="yes" xml:space="preserve">
          <source>width</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37d41699bdee4fcb969ca499eb0f8b82c60d59cc" translate="yes" xml:space="preserve">
          <source>will</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e698af09629b7ab425fc48e2a23b9a874214ff2" translate="yes" xml:space="preserve">
          <source>will all be loaded correctly by the &lt;b&gt;SelfLoader&lt;/b&gt;, and the &lt;b&gt;SelfLoader&lt;/b&gt; will ensure that the packages 'foo' and 'baz' correctly have the &lt;b&gt;SelfLoader&lt;/b&gt;&lt;code&gt;AUTOLOAD&lt;/code&gt; method when the data after &lt;code&gt;__DATA__&lt;/code&gt; is first parsed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="802b42bef12951357b89ef5b2a13122fbe99ef9d" translate="yes" xml:space="preserve">
          <source>will allow calling myref() as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f588d27875535a5a81b909a3f21a13470c6000b" translate="yes" xml:space="preserve">
          <source>will allow the user to specify an argument of the form &lt;code&gt;&quot;rsh cat file |&quot;&lt;/code&gt; , but will not work on a filename that happens to have a trailing space, while</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdd84ef15151c715185c9415f2310209f946b6e6" translate="yes" xml:space="preserve">
          <source>will also turn on the &lt;code&gt;DEBUGGING&lt;/code&gt; compilation symbol which enables all the internal debugging code in Perl. There are a whole bunch of things you can debug with this: &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; lists them all, and the best way to find out about them is to play about with them. The most useful options are probably</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b4ff705741e98869e5239461b8d80b3db153b63" translate="yes" xml:space="preserve">
          <source>will always be appropriately set before</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="800502b2521db5dda562d1522427959496f11b6d" translate="yes" xml:space="preserve">
          <source>will automatically call &lt;code&gt;deflateSetDictionary&lt;/code&gt; directly after calling &lt;code&gt;deflateInit&lt;/code&gt; . The Adler32 value for the dictionary can be obtained by calling the method &lt;code&gt;$d-&amp;gt;dict_adler()&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac2d106304a82f8979d078a5d1a630e0bf0bbed4" translate="yes" xml:space="preserve">
          <source>will automatically call &lt;code&gt;deflateSetDictionary&lt;/code&gt; directly after calling &lt;code&gt;deflateInit&lt;/code&gt; . The Adler32 value for the dictionary can be obtained by calling the method &lt;code&gt;$d-&lt;/code&gt; dict_adler()&amp;gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf4cadec0746e1a5ab432f127230623d5e7091d8" translate="yes" xml:space="preserve">
          <source>will automatically search in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="047046a9e670aa4336adfdf1872082aee6bc3385" translate="yes" xml:space="preserve">
          <source>will automatically search when adding directories to @&lt;code&gt;INC&lt;/code&gt; . The elements in the list are separated by spaces. This is only useful if you have a perl library directory tree structured like the default one. See &lt;code&gt;INSTALL&lt;/code&gt; for how this works. The versioned site_perl directory was introduced in 5.005, so that is the lowest possible value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77ff54c41540566c24d6f01703b68b71c5db0b9e" translate="yes" xml:space="preserve">
          <source>will be a reference to a glob which can be treated as a perl file handle. It refers to the layer below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f36a5ca854b3b31929c9a757a81400bb46baa6a" translate="yes" xml:space="preserve">
          <source>will be added to the list if not present, as will any types given in the list of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ee7188301caacf79b6af8dcb2c81f839071db3f" translate="yes" xml:space="preserve">
          <source>will be appropriately labeled using arrow notation. You can specify names for individual values to be dumped if you use the &lt;code&gt;Dump()&lt;/code&gt; method, or you can change the default &lt;code&gt;$VAR&lt;/code&gt; prefix to something else. See &lt;code&gt;$Data::Dumper::Varname&lt;/code&gt; and &lt;code&gt;$Data::Dumper::Terse&lt;/code&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5d33fb37764bb4ed1953600f4adf836066df187" translate="yes" xml:space="preserve">
          <source>will be assigned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b924079b9f868588e8837d7d50c4a682e44dca9" translate="yes" xml:space="preserve">
          <source>will be associated with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02ae7304f1d07ef95ca9aa9e7fec2131cfb9259b" translate="yes" xml:space="preserve">
          <source>will be assumed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69e74f77cfb1d64cc1f2b8b0e7553a0f92d29c07" translate="yes" xml:space="preserve">
          <source>will be assumed. In a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ffcf20d5b3d655c1147575473aace4b9819db78" translate="yes" xml:space="preserve">
          <source>will be at the start of a block, so variables may be defined in it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf4139ebee2a50a45a47c6c20c8db3e1866f4f96" translate="yes" xml:space="preserve">
          <source>will be automatically appended if no dot is present in the name. The workaround is as simple as that: since</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a46024906c3202205c9b86fbe8cd6c05e18f661" translate="yes" xml:space="preserve">
          <source>will be automatically closed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5391631955c2960d94bb3306b3cf823fd72eb2e" translate="yes" xml:space="preserve">
          <source>will be called, or whatever is the override, see &lt;a href=&quot;#PERL_SH_DIR&quot;&gt;PERL_SH_DIR&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39863063f526390d21b54f0437be449e32146e0d" translate="yes" xml:space="preserve">
          <source>will be evaluated by &lt;code&gt;wanted()&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28165e3b4da95eac8adbdc3dff70bd1aebff0f5c" translate="yes" xml:space="preserve">
          <source>will be extracted as if it were:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b611847a2698bb295db4bc4d7f2ff88d3d7bfd77" translate="yes" xml:space="preserve">
          <source>will be incorrectly parsed as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c7777c83dbab33571eaae602d63da07c1775c05" translate="yes" xml:space="preserve">
          <source>will be interpreted DWIMically, often as a comparison against &lt;code&gt;$_&lt;/code&gt; , and may be null to generate a &lt;code&gt;default&lt;/code&gt; block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75321a4f0c9b87d6d48f48cc9f64b5f655545b5c" translate="yes" xml:space="preserve">
          <source>will be modified to the last $octets position at end of decode. Returns true if $terminator appears output, else returns false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5444aae0d6bc7e881d14ae4362de10908be2d8bc" translate="yes" xml:space="preserve">
          <source>will be moved, and the buffer shortened. This hides the discarded text from any lexing code that runs later, as if the text had never appeared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb90a1b23ad48d9287e458757890f8e9565a8afc" translate="yes" xml:space="preserve">
          <source>will be retried. This lets you type &lt;code&gt;man debug&lt;/code&gt; or &lt;code&gt;man op&lt;/code&gt; from the debugger.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ef44a7f700e88aec4c8b15477ecc69c13f947c3" translate="yes" xml:space="preserve">
          <source>will be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1970ab6c3e7f53185ec961c7b96e2bec3982ca45" translate="yes" xml:space="preserve">
          <source>will be some defined value if the open succeeds, but &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if it fails;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0e5f84ae9a025c95805cfbdda7aba5f2e868b56" translate="yes" xml:space="preserve">
          <source>will be treated as a boolean match because the rules say both a regex match and an explicit test on &lt;code&gt;$_&lt;/code&gt; will be treated as boolean.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bdb6f7a9a73bafa81d66281077d808cd4f13be5" translate="yes" xml:space="preserve">
          <source>will be twice UTF-8 encoded. A &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; ':encoding(utf8)'&lt;/code&gt; would have avoided the bug, or explicitly opening also the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee4475df6e379629545ed6276a569f3e2eb1ef11" translate="yes" xml:space="preserve">
          <source>will be undefined, since a recursive structure cannot be constructed using one Perl statement. You should set the &lt;code&gt;Purity&lt;/code&gt; flag to 1 to get additional statements that will correctly fill in these references. Moreover, if &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed when strictures are in effect, you need to ensure that any variables it accesses are previously declared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eee291ac39ab0e01b156565c777f946041d54d02" translate="yes" xml:space="preserve">
          <source>will be used as the handler for subsequently installed signals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d9bc2ddc4bc2a031e22465c252b6377da6be593" translate="yes" xml:space="preserve">
          <source>will be used for password.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="189f210a322c7c2ba81e0ea9896d29ddd547e1b5" translate="yes" xml:space="preserve">
          <source>will be used for the name of the extension. If module_name is not supplied then the name of the first header file will be used, with the first character capitalized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9eed5428b5ca4033b733f6e4eabddbdf0bae1ff" translate="yes" xml:space="preserve">
          <source>will be used instead and the output piped through your favourite pager.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00ea2b0f5cc2323252a0479beca63d9f1b08fa40" translate="yes" xml:space="preserve">
          <source>will be warning free regardless of what $ref actually is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84d0d493e062ada8d958a287014680fe0c8e6db1" translate="yes" xml:space="preserve">
          <source>will be zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75c5acef5fb2e47df2bf90c4d4c3a7831000cfcd" translate="yes" xml:space="preserve">
          <source>will become:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0318a0bb7d80ff064a8678b238ad297c5e7ed6b" translate="yes" xml:space="preserve">
          <source>will both result in the proper type due to the way the overloaded math works.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed44e6c8395b95eb951ed01fb3df61dd611bca88" translate="yes" xml:space="preserve">
          <source>will build a Perl that supports dynamic loading (which requires a shared</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2287cd95ce18a71437cb52ed8b1caefedff9eaca" translate="yes" xml:space="preserve">
          <source>will call the Unix emulation library's &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; emulation, which attempts to provide emulation of the stdin, stdout, stderr in force in the parent, providing the child program uses a compatible version of the emulation library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dd319675b257f0d34e3db5d71aeabc5c8458128" translate="yes" xml:space="preserve">
          <source>will call the native command line direct and no such emulation of a child Unix program will exists. Mileage &lt;b&gt;will&lt;/b&gt; vary. (RISC OS)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5562a8abf4cafe3ad9adfb9e7cbb5beff80d11ed" translate="yes" xml:space="preserve">
          <source>will cause the entire file to be slurped. For large files, it's better to loop:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c184916ba1fdcc854b79c2ce8f3611570d536868" translate="yes" xml:space="preserve">
          <source>will cause the handler to be called with a similar argument list (except, of course, that &lt;code&gt;$_[2]&lt;/code&gt; will be a reference to the variable).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caee4713a9cdf89a7945419e9d20fb846188deb3" translate="yes" xml:space="preserve">
          <source>will compile XS code into C code by embedding the constructs necessary to let C functions manipulate Perl values and creates the glue necessary to let Perl access those functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf8a15fdda50374b4163d238b2097ac33d5e0df4" translate="yes" xml:space="preserve">
          <source>will compile XS code into C code by embedding the constructs necessary to let C functions manipulate Perl values and creates the glue necessary to let Perl access those functions. The compiler uses typemaps to determine how to map C function parameters and variables to Perl values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="958cf42d40b9694a262fb0dd1a956ccae7aeee61" translate="yes" xml:space="preserve">
          <source>will construct a &quot;binary&quot; stream, but then enable UTF-8 translation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca2af336688d1e8d5e00a2d443084fd9b744a776" translate="yes" xml:space="preserve">
          <source>will correctly push BLUE onto the top of the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff1d4f6ecbef028562f10ecf8ba054ec728c45eb" translate="yes" xml:space="preserve">
          <source>will create the file &quot;FOO.BAT&quot;. Note &quot;pl2bat&quot; strips any .pl suffix and adds a .bat suffix to the generated file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9d73e9ce730e824d01662cbda4e3da1fcf3537f" translate="yes" xml:space="preserve">
          <source>will do an implicit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abce4a07e1007ee8dd7654b319b0cda84bc64efd" translate="yes" xml:space="preserve">
          <source>will do it for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7108818138127d16c4094725bba30a3d913149fe" translate="yes" xml:space="preserve">
          <source>will do what you mean (fail if stuff is empty)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="066b5eeba4c2198d50173831282c3c44664d4d50" translate="yes" xml:space="preserve">
          <source>will effectively become</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b01657f6df9723f80897f0a01fd87afb4d0fa02" translate="yes" xml:space="preserve">
          <source>will extract and format the documentation from any file in the current directory, any Perl module installed on the system, or any of the standard documentation pages, such as this one. Use &lt;code&gt;perldoc &amp;lt;name&amp;gt;&lt;/code&gt; to get information on any of the utilities described in this document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="915564ffa096011256f1ddfb99671491100c6813" translate="yes" xml:space="preserve">
          <source>will fail, since Test.pm considers the second argument to be a regex! The best bet is to use the one-argument form:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="212fc5e54752a78ba3b78f936f759ccf3eed955c" translate="yes" xml:space="preserve">
          <source>will generate or as a reference to a hash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a53f1b0c5018113eb37388423f971ca2d0e17a9" translate="yes" xml:space="preserve">
          <source>will give the same result with or without &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; The power operator &lt;code&gt;**&lt;/code&gt; is also not affected, so that 2 ** .5 is always the square root of 2. Now, it so happens that the pre- and post- increment and decrement operators, ++ and --, are not affected by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; either. Some may rightly consider this to be a bug -- but at least it's a long-standing one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e522bd0030bde0cd245c6a6a2088de240b790d1c" translate="yes" xml:space="preserve">
          <source>will have exactly the opposite restrictions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="911e01951fb3b7f75048f4c14389ccff0d911ab7" translate="yes" xml:space="preserve">
          <source>will have the same effect. This construct is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="027d9dd767a399ed29c2f093303b12c4fc85e09e" translate="yes" xml:space="preserve">
          <source>will have their leading dashes stripped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2194c108734d216b207d2d189e6b066bdc993596" translate="yes" xml:space="preserve">
          <source>will have to specify the installation directories as these most probably have changed since perl itself has been installed. They will have to do this by calling</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd5c38ed8c7727c38022b12bfd4163d2940b7d68" translate="yes" xml:space="preserve">
          <source>will hold.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbda0dd99d938557f490efeb2ffa5530b4ef022d" translate="yes" xml:space="preserve">
          <source>will in most computers print 0, not 1, because even such simple numbers as 0.6 and 0.2 cannot be presented exactly by floating-point numbers. What you think in the above as 'three' is really more like 2.9999999999999995559.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b96340c4517d8e5916a24e5c0c58c099ab880e5" translate="yes" xml:space="preserve">
          <source>will initially increment &lt;code&gt;$cnt&lt;/code&gt; up to 8; then during backtracking, its value will be unwound back to 4, which is the value assigned to &lt;code&gt;$res&lt;/code&gt; . At the end of the regex execution, $cnt will be wound back to its initial value of 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="482fd60cac120fdf28a98539580c1dc1bf947239" translate="yes" xml:space="preserve">
          <source>will invoke &lt;code&gt;ExtUtils::Embed&lt;/code&gt; functions while building your application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec31983ab84cf33f76bb7f28f95cd8a45d78dd13" translate="yes" xml:space="preserve">
          <source>will it apply the &lt;code&gt;Bent&lt;/code&gt; attribute to the variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdb47b66626fed7da3a69fabf094bf802562db6c" translate="yes" xml:space="preserve">
          <source>will just extract the &quot;USAGE&quot; section; some of the utilities will automatically call</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be6de1408397f34ac967e76e8f03f5647f72bce4" translate="yes" xml:space="preserve">
          <source>will load MODULE only if CONDITION evaluates to true. The above statement has no effect unless &lt;code&gt;CONDITION&lt;/code&gt; is true. If the CONDITION does evaluate to true, then the above line has the same effect as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="417947d63110228931cd8773ca1769b0152ef181" translate="yes" xml:space="preserve">
          <source>will lock the tied file. &lt;code&gt;MODE&lt;/code&gt; has the same meaning as the second argument to the Perl built-in &lt;code&gt;&lt;a href=&quot;../functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; function; for example &lt;code&gt;LOCK_SH&lt;/code&gt; or &lt;code&gt;LOCK_EX | LOCK_NB&lt;/code&gt; . (These constants are provided by the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Fcntl ':flock'&lt;/code&gt; declaration.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fde5332cf051e296efcfa60b991d8b50c9c48011" translate="yes" xml:space="preserve">
          <source>will look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e385389da5f12d892ae543d3886ffd128ec573e" translate="yes" xml:space="preserve">
          <source>will match &quot;foo&quot; using the locale's rules for case-insensitive matching, but the &lt;code&gt;/l&lt;/code&gt; does not affect how the &lt;code&gt;\U&lt;/code&gt; operates. Most likely you want both of them to use locale rules. To do this, instead compile the regular expression within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; . This both implicitly adds the &lt;code&gt;/l&lt;/code&gt; , and applies locale rules to the &lt;code&gt;\U&lt;/code&gt; . The lesson is to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , and not &lt;code&gt;/l&lt;/code&gt; explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="109f68c2b8ad8f0d77ed465628f16e2a2c2e7277" translate="yes" xml:space="preserve">
          <source>will match &lt;code&gt;\x8e&lt;/code&gt; , even though &lt;code&gt;\x89&lt;/code&gt; is &quot;i&quot; and &lt;code&gt;\x91 &lt;/code&gt; is &quot;j&quot;, and &lt;code&gt;\x8e&lt;/code&gt; is a gap character, from the alphabetic viewpoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90a6766448c16d38bfe8dff80f09487335928909" translate="yes" xml:space="preserve">
          <source>will match &lt;code&gt;blah&lt;/code&gt; in any case, some spaces, and an exact (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b19d9e504a210ea89daa1807562b0478767084f" translate="yes" xml:space="preserve">
          <source>will match, and &lt;code&gt;$1&lt;/code&gt; will be &lt;code&gt;AB&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; will be &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;$3&lt;/code&gt; will not be set. If another branch in the inner parentheses was matched, such as in the string 'ACDE', then the &lt;code&gt;D&lt;/code&gt; and &lt;code&gt;E&lt;/code&gt; would have to be matched as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db2173f99c15aec604a37b03bb19ad87c2e9686f" translate="yes" xml:space="preserve">
          <source>will modify $u2 as well as $u1, because both variables are references to the same array. Had &lt;code&gt;getusers&lt;/code&gt; not been memoized, $u1 and $u2 would have referred to different arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56a0e2c0e3a6bfe2b40c936f6d822ddccc889e47" translate="yes" xml:space="preserve">
          <source>will neither assign 42 to $x</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9edcb2b7ab077ed29ec9d28bcba6b5e91ef13ffe" translate="yes" xml:space="preserve">
          <source>will never be accessed. Additionally, the existence of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="524ef249301f2929ce4307d365e5fa52cb183591" translate="yes" xml:space="preserve">
          <source>will never match, as the &lt;code&gt;a++&lt;/code&gt; will gobble up all the &lt;code&gt;a&lt;/code&gt; 's in the string and won't leave any for the remaining part of the pattern. This feature can be extremely useful to give perl hints about where it shouldn't backtrack. For instance, the typical &quot;match a double-quoted string&quot; problem can be most efficiently performed when written as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf101365c53e8f42c5b08ca87943df667dc3b58c" translate="yes" xml:space="preserve">
          <source>will not affect</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0a53a44c73c968f4506c42dbd7c202fdde9aa25" translate="yes" xml:space="preserve">
          <source>will not automatically generate prototype code for all xsubs. This flag will enable prototypes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37f358342227139465ebf67d77c4e5c07cc3ca01" translate="yes" xml:space="preserve">
          <source>will not create an intermediate list of 500,000 integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a909cd12fa7841454a3513c9ecc27aa26ed050e5" translate="yes" xml:space="preserve">
          <source>will not, and a subsequent pop won't restore the correct attributes. PUSHCOLOR pushes the attributes set by its argument, which is normally a string of color constants. It can't ask the terminal what the current attributes are.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aecbb74b57e959a8f88701a03d15ec0b4986702" translate="yes" xml:space="preserve">
          <source>will not. If you are using background colors, you will probably want to either use say() (in newer versions of Perl) or print the newline with a separate print statement to avoid confusing the terminal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51cb32ab55ef73ac4c7e3b3c80f2c3a6bd4c4502" translate="yes" xml:space="preserve">
          <source>will output &quot;o&quot; twice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a06e774b79ee30cc4528a712043ad54d3f5a1a0f" translate="yes" xml:space="preserve">
          <source>will output &lt;code&gt;0&lt;/code&gt; on default 32-bit builds, since &lt;code&gt;bigint&lt;/code&gt; never sees the string literals. To ensure the expression is all treated as &lt;code&gt;Math::BigInt&lt;/code&gt; objects, use a literal number in the expression:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07967563cc177965a7ed97715e81d6fdae7cbfa8" translate="yes" xml:space="preserve">
          <source>will output &lt;code&gt;0&lt;/code&gt; on default 32-bit builds, since &lt;code&gt;bigrat&lt;/code&gt; never sees the string literals. To ensure the expression is all treated as &lt;code&gt;Math::BigInt&lt;/code&gt; or &lt;code&gt;BigFloat&lt;/code&gt; objects, use a literal number in the expression:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b71659f573a74f6d9f73f656d46b8610e6881c01" translate="yes" xml:space="preserve">
          <source>will output &lt;code&gt;0&lt;/code&gt; on default 32-bit builds, since &lt;code&gt;bigrat&lt;/code&gt; never sees the string literals. To ensure the expression is all treated as &lt;code&gt;Math::BigInt&lt;/code&gt; or &lt;code&gt;Math::BigRat&lt;/code&gt; objects, use a literal number in the expression:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d7a9b3fb1f88c1e1d18d8b9c37f765ed993681d" translate="yes" xml:space="preserve">
          <source>will place into $count the number of digit groups found in $string. This happens because the pattern match is in list context (since it is being assigned to the empty list), and will therefore return a list of all matching parts of the string. The list assignment in scalar context will translate that into the number of elements (here, the number of times the pattern matched) and assign that to $count. Note that simply using</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="158b4d249db9d3c641342d6ffe07a57aa001b196" translate="yes" xml:space="preserve">
          <source>will preserve the error and restore reliable error handling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d893c24989b32aee817b8346e7ad376f369b2d24" translate="yes" xml:space="preserve">
          <source>will print</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd687fe7714e5a81fa512dd577f023b74092d11e" translate="yes" xml:space="preserve">
          <source>will print 2, not 1. The only exception is that regular expressions have &lt;code&gt;\X&lt;/code&gt; for matching an extended grapheme cluster. (Thus &lt;code&gt;\X&lt;/code&gt; in a regular expression would match the entire sequence of both the example characters.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5094300d0d532d8932e70f6691fa42ee86dfc712" translate="yes" xml:space="preserve">
          <source>will print nothing but newlines. Use either &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt; or &lt;a href=&quot;bigfloat&quot;&gt;Math::BigFloat&lt;/a&gt; to get this to work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f20759593b002250a08ac3165608cf59d1d82f9" translate="yes" xml:space="preserve">
          <source>will print out:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e9aaf473ea286c62a53337f9951358323be6844" translate="yes" xml:space="preserve">
          <source>will print the number of items returned from the Perl subroutine and their value (for simplicity it assumes that they are integer). So if</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f115f3fe71ae59d269dceb54d217a18d98aaf788" translate="yes" xml:space="preserve">
          <source>will print the sorted contents of the file named</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="898011ad8ba0ad932dc0a21e6656a3baf0ccd836" translate="yes" xml:space="preserve">
          <source>will print: 5.8, -5, 7, 3, 2, 10, 1, 2147483647, -2147483648</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2df2915d4c95ac1935b8649d919c89f0b71efb7" translate="yes" xml:space="preserve">
          <source>will produce HTML pages from POD.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35a48bc9e89843fe90d9679e3c72dc42ba9f3426" translate="yes" xml:space="preserve">
          <source>will produce a customized executable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37ce8d4fdf5864184a859e4556249981464a898f" translate="yes" xml:space="preserve">
          <source>will produce error messages, usually caused by the fact that there are still threads running when the program exits. You should not be alarmed by this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40a447e2e638aff917b8a98c4dbccbd2ef36fe3c" translate="yes" xml:space="preserve">
          <source>will read a record of no more than 32768 characters from $fh. If you're not reading from a record-oriented file (or your OS doesn't have record-oriented files), then you'll likely get a full chunk of data with every read. If a record is larger than the record size you've set, you'll get the record back in pieces. Trying to set the record size to zero or less is deprecated and will cause $/ to have the value of &quot;undef&quot;, which will cause reading in the (rest of the) whole file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dbce3601b41181a479b14fe24812dbea1320b3d" translate="yes" xml:space="preserve">
          <source>will remain open. The fact that Berkeley DB then reports the attempt to open a database that is already open via the catch-all &quot;Invalid argument&quot; doesn't help.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f37ba2b9a5fbee754eb7c8269a813aeb18cd4ca" translate="yes" xml:space="preserve">
          <source>will require a leading colon (as in &lt;code&gt;&quot;=for :formatname&quot;&lt;/code&gt; , or &lt;code&gt;&quot;=begin :formatname&quot; ... &quot;=end :formatname&quot;&lt;/code&gt; ), to signal that the text is not raw data, but instead</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00e02cdb26815577afd3b77c2b81936feda569cf" translate="yes" xml:space="preserve">
          <source>will reset the display mode afterward, whereas:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfd246ad185bc0482eb908f8133758235cbeffe1" translate="yes" xml:space="preserve">
          <source>will restore the value of &lt;code&gt;SV&lt;/code&gt; using the stored value. It doesn't handle magic. Use &lt;code&gt;save_scalar&lt;/code&gt; if magic is affected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcf47e23e9e89e816d5345e18bf5cc985f8e41ea" translate="yes" xml:space="preserve">
          <source>will result in the &lt;code&gt;@_&lt;/code&gt; array having the following values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b214f323b0d930bc4b48c529ba1af86a9de0d7a3" translate="yes" xml:space="preserve">
          <source>will set &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; , but</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f66b27e740d658271832997896a10c6bbc45b211" translate="yes" xml:space="preserve">
          <source>will set &lt;code&gt;vax&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abeb9a24b6c6f570b68ade97160028350917ace8" translate="yes" xml:space="preserve">
          <source>will set all three.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6454ef3b29477d49c2c7980e79cde8b57c1ed94f" translate="yes" xml:space="preserve">
          <source>will still exist after the call to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="588ec16637097d7d1d0638d77c96a8a5032b93a3" translate="yes" xml:space="preserve">
          <source>will test only the regex, which causes both operands to be treated as boolean. Watch out for this one, then, because an arrayref is always a true value, which makes it effectively redundant. Not a good idea.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcbf4eab8642ab8923d66dad2868cf95ad241494" translate="yes" xml:space="preserve">
          <source>will then attempt to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f4bb9d65e83043ff5b7e82034ad61c789030aed" translate="yes" xml:space="preserve">
          <source>will transliterate any A to X.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c5ff1dc5075b42cbe189997bcd24a4dd7044963" translate="yes" xml:space="preserve">
          <source>will trigger two filters, one for the reading of the key and one for the reading of the value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ed3f8cd65c348f27de4a80b666167e4693d1656" translate="yes" xml:space="preserve">
          <source>will try loading the classes YourProjClass::en_us (note lowercase!), YourProjClass::fr, YourProjClass::kon, YourProjClass::i_klingon and YourProjClass::i_klingon_romanized. (And it'll stop at the first one that actually loads.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c097b2a013bfe704dfa7b64798a8d4b40a34ed49" translate="yes" xml:space="preserve">
          <source>will use smart matching (only the first operand is considered), whereas</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cc2cc537da4d8f70033128374e99deb871707f6" translate="yes" xml:space="preserve">
          <source>will use smartmatching because only</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="514139923bd059976cc81a9bef6162ccd170175a" translate="yes" xml:space="preserve">
          <source>will usually call</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81fcf2d95c7bfeca0899d8452fef6f4f9bd6f8d9" translate="yes" xml:space="preserve">
          <source>will work as well.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2892afe1b68a0f4ac688e2819db40fcb2dbe61aa" translate="yes" xml:space="preserve">
          <source>will work correctly. These mixed cases don't do always work when using Math::BigInt or Math::BigFloat alone, or at least not in the way normal Perl scalars work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc5353c166b1ce6a2755fffe1f9473c7c604fb2e" translate="yes" xml:space="preserve">
          <source>will work in many but not all cases. You see, it's too simple-minded for certain kinds of C programs, in particular, those with what appear to be comments in quoted strings. For that, you'd need something like this, created by Jeffrey Friedl and later modified by Fred Curtis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="786d912fad11b712a3268fcedeb0dec988a5d652" translate="yes" xml:space="preserve">
          <source>will work with earlier versions of Perl 5. Hence, such a module may take full advantage of syntactical and other improvements in Perl 5 blead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d11df7412eb53de0f032fa263537630590c98be8" translate="yes" xml:space="preserve">
          <source>win32/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef20e66907c936dd8f32cedd2cde044f7f103034" translate="yes" xml:space="preserve">
          <source>win32/perllib.c</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffc229a00767de35e4be6135e2ffebcf9882c38a" translate="yes" xml:space="preserve">
          <source>wince</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="123bb8126c34dd474d44011b10cfbf904c3172d4" translate="yes" xml:space="preserve">
          <source>wince port was kept in the same</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cd6bd4c16cc2a47ce31db4e0755a63599fc21d0" translate="yes" xml:space="preserve">
          <source>wince/Makefile.ce</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fcd25a39d2037183044a8897e9a5333d727fded" translate="yes" xml:space="preserve">
          <source>with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="516d8aa61b6759073fd78a57717de8007b3370ce" translate="yes" xml:space="preserve">
          <source>with 0 if it does, 1 if it does not (ie. shell's idea of true and false).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38b9a576bee545c23ad008343813d9e755e740e0" translate="yes" xml:space="preserve">
          <source>with 0 if it does, 1 if it does not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd393d67aeb1a238c4b9b75ace210101e95a963c" translate="yes" xml:space="preserve">
          <source>with &lt;code&gt;$1&lt;/code&gt; being the line number for the next line, and &lt;code&gt;$3&lt;/code&gt; being the optional filename (specified with or without quotes). Note that no whitespace may precede the &lt;code&gt;#&lt;/code&gt; , unlike modern C preprocessors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd277e84169e71230b173e5e86d5c72e9dd4d149" translate="yes" xml:space="preserve">
          <source>with C</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f35039fcfb7ca39f0e93041f2c52c34be88131b" translate="yes" xml:space="preserve">
          <source>with DOS hooks is available in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f257153d465d0a7a17934523c7043d1cba8cb62c" translate="yes" xml:space="preserve">
          <source>with DTrace support enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79e46a1b41acc15ccc42adaa2b069f673632f7cc" translate="yes" xml:space="preserve">
          <source>with Pre-5.0 MakeMakers. Since version 5.00 of MakeMaker such a line can be deleted safely. MakeMaker recognizes when there's nothing to be linked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="902f1c78737d167fe1b8e5be3f95f9481cbb5856" translate="yes" xml:space="preserve">
          <source>with a field hash, the entry will be collected, even if it was later overwritten with a plain scalar key (every positive integer is a candidate). This is true even if the original entry was deleted in the meantime. In fact, deletion from a field hash, and also a test for existence constitute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b1ee94282ce6cd2f8ed1cd3d21d10ed8a2ffaba" translate="yes" xml:space="preserve">
          <source>with a shell</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6712fdd90b5e830ff760a98c106a30072131fe7e" translate="yes" xml:space="preserve">
          <source>with a special meaning described here or above. You can cause characters that normally function as metacharacters to be interpreted literally by prefixing them with a &quot;\&quot; (e.g., &quot;\.&quot; matches a &quot;.&quot;, not any character; &quot;\\&quot; matches a &quot;\&quot;). This escape mechanism is also required for the character used as the pattern delimiter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b805bc366a9ebde9467176c73458adee5451ed76" translate="yes" xml:space="preserve">
          <source>with actual &lt;code&gt;&lt;a href=&quot;../functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; support. Trailing newline is removed. Returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on &lt;code&gt;EOF&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90fb5185e4bcea673e4052e2147a5dec2bf61fa2" translate="yes" xml:space="preserve">
          <source>with all the statically loaded extensions built in. Compare the generated</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5634ec8df617c002f5cf19e1a0d68429da0d491c" translate="yes" xml:space="preserve">
          <source>with any non-default flags appearing between the caret and the colon. A test that looks at such stringification thus doesn't need to have the system default flags hard-coded in it, just the caret. If new flags are added to Perl, the meaning of the caret's expansion will change to include the default for those flags, so the test will still work, unchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb83d536946bb8d10aca0b9c5349a4fa97876fb1" translate="yes" xml:space="preserve">
          <source>with arguments &lt;code&gt;arg1 arg2 arg3&lt;/code&gt; the same way as on any other platform, by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e596474483116f71691799bfb6c85c3d8699a856" translate="yes" xml:space="preserve">
          <source>with bugs in memory allocations which are caught by Perl's malloc();</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43e71f90be5e8d458fd62d980464b4dcacad2891" translate="yes" xml:space="preserve">
          <source>with command line &quot;-size 10 -sizes 24 -sizes 48&quot; will perform the equivalent of the assignments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6bb8f0d0bfad7a5f424f1936641a121be95eced" translate="yes" xml:space="preserve">
          <source>with contents being (compare with &lt;a href=&quot;#Making-executables-with-a-custom-collection-of-statically-loaded-extensions&quot;&gt;Making executables with a custom collection of statically loaded extensions&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df572e1bbeb0b7187cd03ae0e3427ee531dc9c89" translate="yes" xml:space="preserve">
          <source>with djtarx. If you want to use long file names under w95 and also to get Perl to pass all its tests, don't forget to use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a6e45130091d1990376001a155acd12e04c02af" translate="yes" xml:space="preserve">
          <source>with invaluable help from Chris Nandor, and valuable help from Brandon Allbery, Charles Bailey, Graham Barr, Dominic Dunlop, Jarkko Hietaniemi, Ben Holzman, Tom Horsley, Nick Ing-Simmons, Tuomas J. Lukka, Laszlo Molnar, Alan Olsen, Peter Prymmer, Gurusamy Sarathy, Christoph Spalinger, Dan Sugalski, Larry Virden, and Ilya Zakharevich.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65cc0156037f347b1259f3f102b72fce7d5f35cb" translate="yes" xml:space="preserve">
          <source>with libperl, any static extensions (usually just DynaLoader), and any other libraries needed on this system. libperl is usually</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf9772e7a963a2d3d329698d4cb2a55502f8d67b" translate="yes" xml:space="preserve">
          <source>with more error checking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83256d944b6616f13d11d6f626aca53da1031053" translate="yes" xml:space="preserve">
          <source>with nonempty prefix1 and prefix2. If &lt;code&gt;prefix1&lt;/code&gt; is indeed a prefix of a builtin library search path, prefix2 is substituted. The error may appear if components are not found, or are too long. See &quot;PERLLIB_PREFIX&quot; in &lt;a href=&quot;perlos2&quot;&gt;perlos2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb3f3ef30b8362c52d5cc55a8fa4f09f4693fecb" translate="yes" xml:space="preserve">
          <source>with one range: an anonymous array with a single element that consists of another anonymous array whose first element is the first code point in the block, and whose second element is the final code point in the block. On an EBCDIC platform, the first two Unicode blocks are not contiguous. Their range sets are lists containing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad93216dd3f12b7821d87a82a121ecedc2fe0262" translate="yes" xml:space="preserve">
          <source>with other auxiliary files, but, and this is important to note, there should be &lt;b&gt;no&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb0e475b39d05deac173d43929afb30eefa9a066" translate="yes" xml:space="preserve">
          <source>with some customization slots left out to be filled later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="578150dd4f4464b258a72af475d097b197c86ecf" translate="yes" xml:space="preserve">
          <source>with such a routine added (and slightly modified str()):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c303466efe4cbf12a616af1540bc1eb7aaeaf47" translate="yes" xml:space="preserve">
          <source>with the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d1c3bf8c1f9945ec4599b301b51d74a3a85654a" translate="yes" xml:space="preserve">
          <source>with the array elements, returning the number of matches found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06a358e9a286ee4b634c109bfb039300741fcb98" translate="yes" xml:space="preserve">
          <source>with the first line being</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39ef66642cc8f022fcb29b6192f16996d968e41f" translate="yes" xml:space="preserve">
          <source>with the given set of sections. See &lt;b&gt;add_selection()&lt;/b&gt; for adding to the current set of selected sections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="681d9ba240a75cd0133e9a797e48af7f60cc1289" translate="yes" xml:space="preserve">
          <source>with the key specified by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc8ddfc8af720ff32b46e111b20ee99ab44a3ee8" translate="yes" xml:space="preserve">
          <source>with the options '--url &lt;a href=&quot;http://example.com&quot;&gt;http://example.com&lt;/a&gt;'. When running multiple tests they will each receive the same arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9af249b71f06549e6ec04dac84cfb0149e01d8b1" translate="yes" xml:space="preserve">
          <source>with the same effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22d6b042eb59b4513f175226eb07a3dda4da0955" translate="yes" xml:space="preserve">
          <source>with the same result as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d916cf8b9311e482b651049d8b87bf349a501880" translate="yes" xml:space="preserve">
          <source>with the sequence &lt;code&gt;1100&lt;/code&gt; repeating again and again. In addition to this limitation, the exponent of the binary number is also restricted when it is represented as a floating point number. On typical hardware, floating point values can store numbers with up to 53 binary digits, and with binary exponents between -1024 and 1024. In decimal representation this is close to 16 decimal digits and decimal exponents in the range of -304..304. The upshot of all this is that Perl cannot store a number like 12345678901234567 as a floating point number on such architectures without loss of information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ba1d9aa0bd57431c1856954244f3cbc94acd62d" translate="yes" xml:space="preserve">
          <source>with these bytes using this option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f47eb77d09add43952b7bda3f6a0a9cdacda272" translate="yes" xml:space="preserve">
          <source>with this one, once the &lt;code&gt;o&lt;/code&gt; ption &lt;code&gt;frame=2&lt;/code&gt; has been set:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f42ef62128025c7fd38f4952b8a2dc53beb818e7" translate="yes" xml:space="preserve">
          <source>within</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92f70e05ed425bf86c4992009349d575e4339965" translate="yes" xml:space="preserve">
          <source>within the affected package, but across scopes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de8017cefaab0d61aa697455fcae07e9312b74bc" translate="yes" xml:space="preserve">
          <source>within the referenced group is used as an independent subpattern in place of the group reference itself. Because the group reference may be contained</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d4e654c613ea68bffeeab1587b7dbac44826c2b" translate="yes" xml:space="preserve">
          <source>without</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10f2461de60c6d5b4ff8c4b7507377311e349c19" translate="yes" xml:space="preserve">
          <source>without LIB, setting PREFIX replaces the initial &lt;code&gt;$Config{prefix}&lt;/code&gt; part of those INSTALL* arguments, even if the latter are explicitly set (but are set to still start with &lt;code&gt;$Config{prefix}&lt;/code&gt; ).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a80d0259d1e71d6750796bdfe9afa977177dab1" translate="yes" xml:space="preserve">
          <source>without a good reason.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2ca9034d0099c94e02d85eb5ba30cf9f74f58f0" translate="yes" xml:space="preserve">
          <source>without the newlines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4732a6d7f96eade3f478fdd4097e2f5ce9f0b28d" translate="yes" xml:space="preserve">
          <source>won't be run at all</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18c4254d09ff75421e3936447920117069935d2e" translate="yes" xml:space="preserve">
          <source>won't recursively apply those macros for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cbcd90adc4b192a87a625850b7f231caddf0eb3" translate="yes" xml:space="preserve">
          <source>word</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c614707e1344dd5a41b584a7fa3720507a41566c" translate="yes" xml:space="preserve">
          <source>word anchor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d44b255df34f22674d602b2084de78dd16835268" translate="yes" xml:space="preserve">
          <source>wordmatch-line.html</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e274eeff768c6396088ec6eb091f4bf4d47ab1e0" translate="yes" xml:space="preserve">
          <source>work</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c6b6f215bf47eca2a6fa7e244846ed1b5e4779d" translate="yes" xml:space="preserve">
          <source>work in this construct, because modifiers don't take loop labels. Sorry. You can always put another block inside of it (for &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;) or around it (for &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;) to do that sort of thing. For &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;, just double the braces:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62bee0aec6969f0ad0809c8d6cc21d4734187295" translate="yes" xml:space="preserve">
          <source>work properly on native code points and strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e912ba21c9cf05d0fc8a8967f5359aab2729eca4" translate="yes" xml:space="preserve">
          <source>work under OS/390 and on the Macintosh; you probably don't want to use them in new code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12b6bdd47224ffe593cf3bd066979ef986b0dfa4" translate="yes" xml:space="preserve">
          <source>work within a &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; { } while&lt;/code&gt; construct. See &lt;a href=&quot;perlsyn#Loop-Control&quot;&gt;Loop Control in perlsyn&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63b2e519f2bfeef08075c12043e9e0b8da4fe0fe" translate="yes" xml:space="preserve">
          <source>work. (This is equivalent to &lt;code&gt;$&lt;i&gt;human&lt;/i&gt;++&lt;/code&gt;, where</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10f5ebe6acb4467b71602be4c4fdb44c44fa26b6" translate="yes" xml:space="preserve">
          <source>worker</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f69649f0cb724dcfcaf5d34bac347a0650ed559" translate="yes" xml:space="preserve">
          <source>works because &lt;code&gt;$AoA[0]&lt;/code&gt; already held an array reference. If you try that on an undefined variable, you'll take an exception. That's because the implicit derefererence will never autovivify an undefined variable the way &lt;code&gt;@{ }&lt;/code&gt; always will:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15124ebfba7fc813f38c973245978f037d3342fc" translate="yes" xml:space="preserve">
          <source>works bottom-up, so does the first pass of perl compilation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2f86c6b40fe0bcf02c6b1cac00b3639a3aa830f" translate="yes" xml:space="preserve">
          <source>works just fine. For some storage methods, you need a little glue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d192b622956789bdecb1e8dc26768ccb0a1de12d" translate="yes" xml:space="preserve">
          <source>works like a normal hash, except that it stringifies a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eef62adcae43a43a24a531e0fcd32b343c0335e6" translate="yes" xml:space="preserve">
          <source>works like the corresponding perl commands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="278395d966ca8f15d90253e7a54af657001b22d5" translate="yes" xml:space="preserve">
          <source>works out the package name and subroutine name from &lt;code&gt;cv&lt;/code&gt; , and then calls &lt;code&gt;croak()&lt;/code&gt; . Hence if &lt;code&gt;cv&lt;/code&gt; is &lt;code&gt;&amp;amp;ouch::awk&lt;/code&gt; , it would call &lt;code&gt;croak&lt;/code&gt; as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6be0ee6d5b9de8b6dd59c468448f9682ef33c831" translate="yes" xml:space="preserve">
          <source>works? That way you can type a line, get the answer, type a line, get the answer, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0955dd818206a40e89101bb215630d0623e506fc" translate="yes" xml:space="preserve">
          <source>would</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cd672c18cd6ca58a99d38415467298ac7edcacd" translate="yes" xml:space="preserve">
          <source>would allocate a 64K buffer for use in an emergency. See the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b290e6292697adca00d7d3d5662240ab8fc30bb" translate="yes" xml:space="preserve">
          <source>would be</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b69dbdbceacfeb0d76b23c42db32158c5c4f060" translate="yes" xml:space="preserve">
          <source>would be enough, but having full path would make it easier to use your script under *nix.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fac17e9022ec2b662ea926d0797f33367aaf872c" translate="yes" xml:space="preserve">
          <source>would be executed in a manner equivalent to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b9b72bb55102abb737a9210715fff3a86c182fa" translate="yes" xml:space="preserve">
          <source>would be introduced with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee71ebda44e2dc671943d14d6333655aa8766836" translate="yes" xml:space="preserve">
          <source>would become:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc7bc135c1fe15a09a47ef32c483c004c406321c" translate="yes" xml:space="preserve">
          <source>would cause a longjmp right back to the guard in &lt;code&gt;perl_run&lt;/code&gt; , popping both runops loops, which is clearly incorrect. One way to avoid this is for the tie code to do a &lt;code&gt;JMPENV_PUSH&lt;/code&gt; before executing &lt;code&gt;FETCH&lt;/code&gt; in the inner runops loop, but for efficiency reasons, perl in fact just sets a flag, using &lt;code&gt;CATCH_SET(TRUE)&lt;/code&gt; . The &lt;code&gt;pp_require&lt;/code&gt; , &lt;code&gt;pp_entereval&lt;/code&gt; and &lt;code&gt;pp_entertry&lt;/code&gt; ops check this flag, and if true, they call &lt;code&gt;docatch&lt;/code&gt; , which does a &lt;code&gt;JMPENV_PUSH&lt;/code&gt; and starts a new runops level to execute the code, rather than doing it on the current loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ebd799d293a64e9ed9d39b91ac1f7fed34f437f" translate="yes" xml:space="preserve">
          <source>would cause the following handlers to be invoked:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b330e24a100ad409d9215e9accd6009a0f6b093" translate="yes" xml:space="preserve">
          <source>would compile to this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c97745307a9b13afa0ef5df546ac7a72284b1bc2" translate="yes" xml:space="preserve">
          <source>would correctly match something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71f0319df98f9c2b350311a9ad295b643da5cc03" translate="yes" xml:space="preserve">
          <source>would do. In scalar context, glob iterates through such filename expansions, returning undef when the list is exhausted. This is the internal function implementing the &lt;code&gt;&amp;lt;*.c&amp;gt;&lt;/code&gt; operator, but you can use it directly. If EXPR is omitted, &lt;code&gt;$_&lt;/code&gt; is used. The &lt;code&gt;&amp;lt;*.c&amp;gt;&lt;/code&gt; operator is discussed in more detail in &lt;a href=&quot;../perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f56783a28f8038eb78e33a3c46a24ab091b4d2d" translate="yes" xml:space="preserve">
          <source>would do. In scalar context, glob iterates through such filename expansions, returning undef when the list is exhausted. This is the internal function implementing the &lt;code&gt;&amp;lt;*.c&amp;gt;&lt;/code&gt; operator, but you can use it directly. If EXPR is omitted, &lt;code&gt;$_&lt;/code&gt; is used. The &lt;code&gt;&amp;lt;*.c&amp;gt;&lt;/code&gt; operator is discussed in more detail in &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37edd169eed8b427b6f69da497b122303092f2b0" translate="yes" xml:space="preserve">
          <source>would fail, returning:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="574cbd21dd4f01cc7e9a5d6c3ebf7c3fc8d35449" translate="yes" xml:space="preserve">
          <source>would get the POD name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e320d29fdf6132581dd222d085e227ad58bf37f" translate="yes" xml:space="preserve">
          <source>would give a full stack backtrace starting from the first caller outside of __PACKAGE__. (Unless that package was also internal to Perl.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad5c29604d0563177f85184d5b38f87b92f96450" translate="yes" xml:space="preserve">
          <source>would indicate that the module's loadable object has an extension of &lt;code&gt;unusual_ext&lt;/code&gt; instead of the more usual &lt;code&gt;$Config{dlext}&lt;/code&gt; . NOTE: This also requires that the module's</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="585e126f2d7d5e783ec33329e484ff25c16ca6ba" translate="yes" xml:space="preserve">
          <source>would look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb35630d9819ace128f90170b4e7e21fb8a844e0" translate="yes" xml:space="preserve">
          <source>would make the output file be &lt;code&gt;&lt;a href=&quot;../functions/index&quot;&gt;index.html&lt;/a&gt;&lt;/code&gt; rather than &lt;code&gt;&lt;a href=&quot;../functions/index&quot;&gt;index.html?x=y&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f64975e657327e4be32b5539242811882551af4" translate="yes" xml:space="preserve">
          <source>would match the same as &lt;code&gt;/(Y) ( (X) \g3 \g1 )/x&lt;/code&gt; . This allows you to interpolate regexes into larger regexes and not have to worry about the capture groups being renumbered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2f054955a6bf9756cf704fa72217ac295bd0e6a" translate="yes" xml:space="preserve">
          <source>would not distinguish whether an argument to a C function which is of the form, say, &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; *&lt;/code&gt; , is an input, output, or input/output parameter. In particular, argument declarations of the form</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d43dd196be51f739a2f740fe5b9d6d8d4e1e385a" translate="yes" xml:space="preserve">
          <source>would not have worked, since a pattern match in scalar context will only return true or false, rather than a count of matches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="673f3639cd000b9c54db8198e731d97836c69096" translate="yes" xml:space="preserve">
          <source>would parse as equivalent to this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9212fded8d922f55d00c869b65a88f38d24b2983" translate="yes" xml:space="preserve">
          <source>would print out:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c9640bfb221618fc100b05da2396d3c0c4bbe0f" translate="yes" xml:space="preserve">
          <source>would result in the executable file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ad2605d7b28e739c8b99351ef9b3563d4182742" translate="yes" xml:space="preserve">
          <source>would result in the library file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1f85381415339898b4e35b7420b2a30ff7e6961" translate="yes" xml:space="preserve">
          <source>would result in the object file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f7d3dbcc73cffec6f45fb591952a386e20faa47" translate="yes" xml:space="preserve">
          <source>would return the same result, since all sets of both types of specified delimiter brackets are correctly nested and balanced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c4cff5293b552fd612d13d20febeef5d79d3555" translate="yes" xml:space="preserve">
          <source>would return:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="549c70e9abc983bc89d50811971c8d7b3d089c20" translate="yes" xml:space="preserve">
          <source>would run</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0812d8966a2250845dc2d619797b74c9d0e4dab" translate="yes" xml:space="preserve">
          <source>would use &lt;code&gt;$a&lt;/code&gt; for the width and precision, and &lt;code&gt;$b&lt;/code&gt; as the value to format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c4ae51d8b1c837faa9e910a2f351d7de1dfa952" translate="yes" xml:space="preserve">
          <source>wouldn't know where the two parameters we pushed were--remember that up to now all the stack pointer manipulation we have done is with our local copy,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="275a8dd6709a5e2c891d71deaa74a09a2b8d5d39" translate="yes" xml:space="preserve">
          <source>wrap_code_ref (CODEREF)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffbf27fe46bcaa79a98677fcde1803710c322360" translate="yes" xml:space="preserve">
          <source>wrap_code_refs_within (...)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21b372156d56807f806631ed6933c5523d17885c" translate="yes" xml:space="preserve">
          <source>wraplist</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a519839bb77029f84f6e3675490ad147a55b8b60" translate="yes" xml:space="preserve">
          <source>wrapped wraplen</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1d0c6c1c29e6ad5164072a5b21340dca7fcb052" translate="yes" xml:space="preserve">
          <source>write</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd01faf5c1113bb980804714f1a3c4f4eca294e2" translate="yes" xml:space="preserve">
          <source>write EXPR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45c37b30717044052f1540db05b5ad1c8bba5bf9" translate="yes" xml:space="preserve">
          <source>write FILEHANDLE</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc499117dc83408f0c557cc8b2161889aed51087" translate="yes" xml:space="preserve">
          <source>write code faster</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9a1d28af222c28b77e752b332e8cb55ca3c14d7" translate="yes" xml:space="preserve">
          <source>write faster code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d71d56a74dcab217f5cf3d91986820cbce58120" translate="yes" xml:space="preserve">
          <source>write.exe</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="047dd1341a6717dbc4836719e3c574b3bc97bb54" translate="yes" xml:space="preserve">
          <source>write_mymeta</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1935d7b6e1cdaa0cb2a12b33ef6db0f1f938bf83" translate="yes" xml:space="preserve">
          <source>writing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4b48a81cdab1e1a5dd37907d6c85ca1c61ddc7c" translate="yes" xml:space="preserve">
          <source>wrong</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11f6ad8ec52a2984abaafd7c3b516503785c2072" translate="yes" xml:space="preserve">
          <source>x</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93dff1d783f239eb6df3ffae594ded880d8c2dfb" translate="yes" xml:space="preserve">
          <source>x/../y</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3482696e3765ecb95ff0b00a865fd23521383490" translate="yes" xml:space="preserve">
          <source>xhtml-symbol.ent</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1922a234bb92764a276a8524d28cdb446d3c7da" translate="yes" xml:space="preserve">
          <source>xor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd656af3459b27df22cf48bccc070225063ef3e2" translate="yes" xml:space="preserve">
          <source>xs_init</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9be87fada2e3b55bddb69633715a8cbf8d48722a" translate="yes" xml:space="preserve">
          <source>xsinit(), ldopts(), ccopts(), perl_inc(), ccflags(), ccdlflags(), xsi_header(), xsi_protos(), xsi_body()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fff56fa3f2f5449b8620c18875a8982395117c3" translate="yes" xml:space="preserve">
          <source>xsinit.c</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8caed3fb038593e7e6d1f13475278cfc4b1647e5" translate="yes" xml:space="preserve">
          <source>xsubpp</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15440904d1068b6f9c7bcddb1d5eab1ae01d515d" translate="yes" xml:space="preserve">
          <source>xsubpp - compiler to convert Perl XS code into C code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41906962c9fe690a96247971b9ba3de3ba3eef8c" translate="yes" xml:space="preserve">
          <source>xsubpp supports a special syntax for returning packed C arrays to perl. If the XS return type is given as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7714417f80a650aa8bcd07aa2560cd2d5b40da3b" translate="yes" xml:space="preserve">
          <source>xsubpp variables and internal functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7313a6242468b7d1e99857893c09fca6dc3ad1eb" translate="yes" xml:space="preserve">
          <source>xsubpp will copy the contents of &lt;code&gt;nelem * sizeof(type)&lt;/code&gt; bytes from RETVAL to an SV and push it onto the stack. This is only really useful if the number of items to be returned is known at compile time and you don't mind having a string of bytes in your SV. Use T_ARRAY to push a variable number of arguments onto the return stack (they won't be packed as a single string though).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f8459982f9f619f4b0d9af2542a2086e56a4bef" translate="yes" xml:space="preserve">
          <source>xy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95cb0bfd2977c761298d9624e4b4d4c72a39974a" translate="yes" xml:space="preserve">
          <source>y</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2f77ac0db8f1535051c3dc4f93ef1b8f6478c1d" translate="yes" xml:space="preserve">
          <source>y///</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5619be32b1efe2b008dbb33c1045b38215c4948" translate="yes" xml:space="preserve">
          <source>yacc</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d12d9f2a97a58598b867d00b4faff8074cd34270" translate="yes" xml:space="preserve">
          <source>yacc.U</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9251acc6192fd21eb64ccb0b45a380892e1c36b3" translate="yes" xml:space="preserve">
          <source>yaml_backend</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b636d2c48aad51e77144c248b661fb67f7fc03c6" translate="yes" xml:space="preserve">
          <source>yield the same result but</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="271d1c708984e0c55c15fabaa11bd2d3b1458de9" translate="yes" xml:space="preserve">
          <source>yield:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4f99a7dbe9a425fcc68c36757fe48467fa8d7b7" translate="yes" xml:space="preserve">
          <source>yielding the number of seconds that elapsed between January 1, 1970 (the beginning of the Unix epoch), and the moment I began writing this sentence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edb0f5b1f639a3886e3180c47fe86c3a6a263842" translate="yes" xml:space="preserve">
          <source>yields</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="341f78d1b5a5471d159f158c1f163fc170e38478" translate="yes" xml:space="preserve">
          <source>yields:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5056f4f5d35641712437421dd222826fdd613905" translate="yes" xml:space="preserve">
          <source>you can assume that the input &quot;ac&quot; will output &quot;ac&quot;, and that &quot;abc&quot; will output only &quot;c&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a951aa1692118fb65f6cadcde16979f8bb55362a" translate="yes" xml:space="preserve">
          <source>you can expect one of these messages (which you actually get is dependent on the version of Perl you are using)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="761c473c3fb3b7c8d7e8e15ee579ff0b662dcc3c" translate="yes" xml:space="preserve">
          <source>you can force interpretation as a reserved word by adding anything that makes it more than a bareword:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="279056ca82a6811880a0d9a6128de1be6e230a2e" translate="yes" xml:space="preserve">
          <source>you can guarantee that the locale will be ISO8859-1. Use POSIX character classes instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e460c422109538339eeeb6480684b4f306f3de3" translate="yes" xml:space="preserve">
          <source>you can make them all to use the same XSUB using this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5afb3eb8089babca339a0a5ab5ffd74baff0bfbd" translate="yes" xml:space="preserve">
          <source>you can press &lt;code&gt;Ctrl-Insert&lt;/code&gt; now, and cut-and-paste from the resulting file - created in the directory you started</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b6d4e3eef8985d17155740fc1fb9090692c91b7" translate="yes" xml:space="preserve">
          <source>you can roll it all into one line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="228c9492d3cafe3be9e270db9be067f6669b75db" translate="yes" xml:space="preserve">
          <source>you can simply write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73c2c64bf57a41908c42c9a1cc5c7680a481d9b9" translate="yes" xml:space="preserve">
          <source>you can unambiguously represent data. Here is what we mean by &quot;unambiguously&quot;. After &lt;code&gt;$utf8 = decode(&quot;foo&quot;, $octet)&lt;/code&gt; ,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0769ff9fc11160998b5a34787676ea117e16054" translate="yes" xml:space="preserve">
          <source>you can use the &lt;code&gt;EVERY::LAST&lt;/code&gt; pseudo-class:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c36535a9c2aa5358bd3fa1a809a56719daa66a5" translate="yes" xml:space="preserve">
          <source>you can write</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1510a5ad8c738b5c46b5a17800ed9f6671e57b9a" translate="yes" xml:space="preserve">
          <source>you can write just</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d905b4762422cd8888fe106e63e876390030933" translate="yes" xml:space="preserve">
          <source>you could do it like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32cbafc88f9919f00875fa01fc871ad53657d16c" translate="yes" xml:space="preserve">
          <source>you could retry with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f31af4d40aa4d113abb8700320d0dec76296cdee" translate="yes" xml:space="preserve">
          <source>you could set DESTDIR=~/tmp/ and installation would go into</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97a047f9ba32f1e569d7e98e12e7892d5f52a397" translate="yes" xml:space="preserve">
          <source>you declare any of your own fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3069e6795247a4cf630775dcb371de41a404867d" translate="yes" xml:space="preserve">
          <source>you didn't read the above and tried to use tar instead of pax, you'll first have to remove the (now corrupt) perl directory</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75cceb83b150b42b6f5f66b5da740fdbd16273b6" translate="yes" xml:space="preserve">
          <source>you load the module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4411228d0f2dd0ed520803b8f3074cfee30a2f8" translate="yes" xml:space="preserve">
          <source>you make certain that all locales will always and only be either an ISO8859-1, or, if you don't have a deficient C library, a UTF-8 locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30a3a6e75011da9030503c667c7b05d715ebcfe8" translate="yes" xml:space="preserve">
          <source>you may THINK you wrote the same thing as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01380cc536db3e96b59620f22f2fbfa4c077a9a7" translate="yes" xml:space="preserve">
          <source>you may need to reinstall the ActivePerl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d19c7e9e52eed6d3f22ce761e226a5c29f3ad43e" translate="yes" xml:space="preserve">
          <source>you may tell the compiler to use integer operations (see &lt;a href=&quot;integer&quot;&gt;integer&lt;/a&gt; for a detailed explanation) from here to the end of the enclosing BLOCK. An inner BLOCK may countermand this by saying</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a31b287da5d839e2dc623eaffd98dff0ccb062a" translate="yes" xml:space="preserve">
          <source>you need to either recompile your Perl in Tru64 4.0D or upgrade your Tru64 4.0D to at least 4.0F: the sockatmark() system call was added in Tru64 4.0F, and the IO extension refers that symbol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1722764b528ff2473944177b83c3cd9a8e51bc17" translate="yes" xml:space="preserve">
          <source>you provide.) In the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c0579f9be815c7ee48d8d23d3d66d5cb6cfc45a" translate="yes" xml:space="preserve">
          <source>you use to build Perl, adding the extension's name to the &lt;code&gt;ext&lt;/code&gt; macro, and the extension's object file to the &lt;code&gt;extobj&lt;/code&gt; macro. You'll also need to build the extension's object file, either by adding dependencies to the main</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a387eb2e97a3c9d50bfe300a1159fb7c3637c367" translate="yes" xml:space="preserve">
          <source>you want the pattern to use the initial values of the variables regardless of whether they change or not. (But there are saner ways of accomplishing this than using &lt;code&gt;/o&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d89d3b483dbdfd382255886b6f76f6f9ed539d8" translate="yes" xml:space="preserve">
          <source>you will find the shell more convenient than the bare shell before.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6d52094053e2271b8e6b8811f157b555c3d0bed" translate="yes" xml:space="preserve">
          <source>you will have to write the explicit full form</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae9b86dc8d723ffd5fd2d5e039182429061deb40" translate="yes" xml:space="preserve">
          <source>you will have:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de50066896083dd63404bb3575f5f66f75090162" translate="yes" xml:space="preserve">
          <source>you will see the slightly more helpful</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0667d305a0b0067742e1926b7aa78a3f1f8f9b8a" translate="yes" xml:space="preserve">
          <source>you would write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b78865bd8c1873f7d311dc1d94a79c917244ed27" translate="yes" xml:space="preserve">
          <source>you'll get &lt;code&gt;mytime() + 2&lt;/code&gt; , not &lt;code&gt;mytime(2)&lt;/code&gt; , which is how it would be parsed without a prototype. If you want to force a unary function to have the same precedence as a list operator, add &lt;code&gt;;&lt;/code&gt; to the end of the prototype:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e6a0e9c6d7617f1874cbd34d69a61bb043ae4b0" translate="yes" xml:space="preserve">
          <source>your class is, rather than having to tell Perl</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92646319ab3ad914c108ec6e67cecb3d15d2b874" translate="yes" xml:space="preserve">
          <source>your regexp. So by default, using both interpolation and code expressions in the same regexp is not allowed. If you're not concerned about malicious users, it is possible to bypass this security check by invoking &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval'&lt;/code&gt; :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d71de9ec3c1742da5275ab3e4ce303c6d416f57" translate="yes" xml:space="preserve">
          <source>your table now reads:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edec9917c4429bd24f7af5accd2ac28ce6871922" translate="yes" xml:space="preserve">
          <source>your-handler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20770554c8961543d282b97286ecde3fed631f64" translate="yes" xml:space="preserve">
          <source>yourself</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17ddec5322f6ed39ba7950d6ba2bd67e67db5b6a" translate="yes" xml:space="preserve">
          <source>yourself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="395df8f7c51f007019cb30201c49e884b46b92fa" translate="yes" xml:space="preserve">
          <source>z</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa8c41330509455ee5679d04ed41535d280d9a89" translate="yes" xml:space="preserve">
          <source>zero</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5211a4a12dbc3325a3db2a2cce5d6220da5eb9c2" translate="yes" xml:space="preserve">
          <source>zero is at the North Pole, not at the Equator on the west coast of Africa (Bay of Guinea). You need to subtract your geographical coordinates from</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2234786d04df9bc1bb3c3da3df83549bbae76b7" translate="yes" xml:space="preserve">
          <source>zero-width assertions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f375b5e2bd318e7607d853092dbfbe693321844" translate="yes" xml:space="preserve">
          <source>zip $input_filename_or_reference =&amp;gt; $output_filename_or_reference [, OPTS]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57968f12798767ae5da8b15a0c383ad79d0f338b" translate="yes" xml:space="preserve">
          <source>zlib</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bada2d421ea3b0a4ee659093f79079ed4b9623f" translate="yes" xml:space="preserve">
          <source>{atan2, cos, exp, floor, fmod, frexp, isnan, log, modf, pow, sin, sqrt}l, strtold</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8afa9f0630cc708f3254bd632424571d7937a2d" translate="yes" xml:space="preserve">
          <source>| &lt;b&gt;-C&lt;/b&gt; ] [ &lt;b&gt;-S&lt;/b&gt; ] [ &lt;b&gt;-t&lt;/b&gt; ] [ &lt;b&gt;-d&lt;/b&gt; ] [ &lt;b&gt;-A&lt;/b&gt; ] [ &lt;b&gt;-h&lt;/b&gt; ] [ &lt;b&gt;-T&lt;/b&gt; ]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94864efe9c101c7cfe388d5b720d16e84936f991" translate="yes" xml:space="preserve">
          <source>| &lt;b&gt;-f&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a314cca084c8d6e6c8f5328b453da7f8a87abf9" translate="yes" xml:space="preserve">
          <source>} =</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb3c6e4de85bd9eae26fdc63e75f10a7f39e850e" translate="yes" xml:space="preserve">
          <source>~</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3546d92b553cbec03ec46dfae3482c4878748b52" translate="yes" xml:space="preserve">
          <source>~/.netscape/history.db</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10147e78c8415aa0b473fbb8dbea5a8966778c0c" translate="yes" xml:space="preserve">
          <source>~/.perldb</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d2cbdb9094f5f4954c6330da66315ee120c6274" translate="yes" xml:space="preserve">
          <source>~/.proverc</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac3bc4988958b749f7dd1bd7030e495f8d6af1a4" translate="yes" xml:space="preserve">
          <source>~/bin</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="402b4ddfdf31bfc73a7ea7ed2fb0f95b5a09a270" translate="yes" xml:space="preserve">
          <source>~/lib/perl5</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db83d96aced0e2c019a65ecc608c84bc6c391ed3" translate="yes" xml:space="preserve">
          <source>~/man</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbf98088c0d37c38d37fa49f16a667216d44ef13" translate="yes" xml:space="preserve">
          <source>~/tmp</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03f8609dad484cb98c24755bd4acb64e2459cdb6" translate="yes" xml:space="preserve">
          <source>~/tmp/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a812c8dbd85a0c3fe37d9f84374737a4801d2bc" translate="yes" xml:space="preserve">
          <source>~/tmp/lib/perl5</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45cb8fa08bbb384bb68753d12c4d9b9b524fcc41" translate="yes" xml:space="preserve">
          <source>~/tmp/usr/local/lib/perl</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14df47b7b7486d3776ef10c4c880ca067065a0b7" translate="yes" xml:space="preserve">
          <source>~name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5b55a0e439c0317089da34fd3674db902e0188e" translate="yes" xml:space="preserve">
          <source>ἀ-</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50400a9a3ca82dc97c2a62a8cb1fd9c90797027b" translate="yes" xml:space="preserve">
          <source>℞ 0: Standard preamble</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2a5f8ffdee8b1fc6db174346c9351f7a691c79d" translate="yes" xml:space="preserve">
          <source>℞ 10: Custom named characters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d99e547ff698f044bb6f9ec55492f016195b8b76" translate="yes" xml:space="preserve">
          <source>℞ 11: Names of CJK codepoints</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ef3e77c58b7d3c354fb4a79adbe9a3824db9a8f" translate="yes" xml:space="preserve">
          <source>℞ 12: Explicit encode/decode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b67beb4bfc4b3e25c970a54c813cc2a0e285a8b" translate="yes" xml:space="preserve">
          <source>℞ 13: Decode program arguments as utf8</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6b8e850a711b941c3b488e2ed88459f7223a720" translate="yes" xml:space="preserve">
          <source>℞ 14: Decode program arguments as locale encoding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1887bd908402fa513516cc0ea0a1a3025b915578" translate="yes" xml:space="preserve">
          <source>℞ 15: Declare STD{IN,OUT,ERR} to be utf8</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2ebb62517d037f392732882c882d1ba5fc9ecc2" translate="yes" xml:space="preserve">
          <source>℞ 16: Declare STD{IN,OUT,ERR} to be in locale encoding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebb3cf37c9c1d0a5bb342f588f5b09dbb35be67a" translate="yes" xml:space="preserve">
          <source>℞ 17: Make file I/O default to utf8</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2270d23ccbd9ab2a598ab2468255ab751d4c25c2" translate="yes" xml:space="preserve">
          <source>℞ 18: Make all I/O and args default to utf8</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8babe67379748497306ce72a6dad66fc99fc1e81" translate="yes" xml:space="preserve">
          <source>℞ 19: Open file with specific encoding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b034eaf8616461baa8e3d15f4ad99a4b7d97e42" translate="yes" xml:space="preserve">
          <source>℞ 1: Generic Unicode-savvy filter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b729d9a4ed3a62e05db384dc3e1d5044801f8d4e" translate="yes" xml:space="preserve">
          <source>℞ 20: Unicode casing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3b7526897174f1d984b158eeaedadfd87945792" translate="yes" xml:space="preserve">
          <source>℞ 21: Unicode case-insensitive comparisons</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1cf2c7882da8c0f9ff3908b5f16003eae636f3e" translate="yes" xml:space="preserve">
          <source>℞ 22: Match Unicode linebreak sequence in regex</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4cf00c9ea31f803c1577db0d44ba0e0609610ed" translate="yes" xml:space="preserve">
          <source>℞ 23: Get character category</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ef354f30d35eb886f206035ce256589f9655f23" translate="yes" xml:space="preserve">
          <source>℞ 24: Disabling Unicode-awareness in builtin charclasses</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="992aea2e1ad40f008b3e87938c62de07b67f29dc" translate="yes" xml:space="preserve">
          <source>℞ 25: Match Unicode properties in regex with \p, \P</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9031b7ab091f3539c164cdd9834c8ea6ca177c41" translate="yes" xml:space="preserve">
          <source>℞ 26: Custom character properties</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a93543794d643ee0acfa19d73095b8305fc87183" translate="yes" xml:space="preserve">
          <source>℞ 27: Unicode normalization</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3af91d59321e31bb1b94eea9e6b20a303f096c4b" translate="yes" xml:space="preserve">
          <source>℞ 28: Convert non-ASCII Unicode numerics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28555117568adeb829bdaa480f535af4c8603c5e" translate="yes" xml:space="preserve">
          <source>℞ 29: Match Unicode grapheme cluster in regex</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7f40e2d4b5881274c99d4faa54dde14ad616cad" translate="yes" xml:space="preserve">
          <source>℞ 2: Fine-tuning Unicode warnings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b1e91f2708a78bbedb8e5f5d87aea1a336f35a3" translate="yes" xml:space="preserve">
          <source>℞ 30: Extract by grapheme instead of by codepoint (regex)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55cfb33ebf5f1e852b3093f5c7d0bec6229f8ea6" translate="yes" xml:space="preserve">
          <source>℞ 31: Extract by grapheme instead of by codepoint (substr)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2ba8073c4eed5409155c51ade3f945a630b558c" translate="yes" xml:space="preserve">
          <source>℞ 32: Reverse string by grapheme</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9ce223e0840c6abef41097684eb5f1c650104df" translate="yes" xml:space="preserve">
          <source>℞ 33: String length in graphemes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53c13862cc87714e333fa62d8720a158c6f355ab" translate="yes" xml:space="preserve">
          <source>℞ 34: Unicode column-width for printing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87c7c9b1652730b229a2e3ba08465d7c12a8cfc8" translate="yes" xml:space="preserve">
          <source>℞ 35: Unicode collation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c95a7a0882b520eaa9bb5d4fbc45228b8c18573" translate="yes" xml:space="preserve">
          <source>℞ 36: Case-</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2ce8d21b9aecfb67a96ff13188b0a89e0a5624f" translate="yes" xml:space="preserve">
          <source>℞ 36: Case- _and_ accent-insensitive Unicode sort</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="968af3413a857a361da7bcd3d91cb10c913d6e25" translate="yes" xml:space="preserve">
          <source>℞ 37: Unicode locale collation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec65982ad998f2507cc77eee201536acd5324b7e" translate="yes" xml:space="preserve">
          <source>℞ 38: Making &lt;code&gt;cmp&lt;/code&gt; work on text instead of codepoints</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="752951dd1ac1d7aaa972f69d508595bf5911635b" translate="yes" xml:space="preserve">
          <source>℞ 38: Making cmp work on text instead of codepoints</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82c6a6149a99cdb0e50810b081474bdbf59d7dfd" translate="yes" xml:space="preserve">
          <source>℞ 39: Case-</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d5852da7209d5884eebf3b9eb1eb39a14ba85cd" translate="yes" xml:space="preserve">
          <source>℞ 39: Case- _and_ accent-insensitive comparisons</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60b49826b5438b22cc51f4ed224510924e54001e" translate="yes" xml:space="preserve">
          <source>℞ 3: Declare source in utf8 for identifiers and literals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f875003d571e6d58aad407fafc68fd83431ef5c" translate="yes" xml:space="preserve">
          <source>℞ 40: Case-</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="012ea33c9fc5bf5e135a6a94297f8e911c2c2728" translate="yes" xml:space="preserve">
          <source>℞ 40: Case- _and_ accent-insensitive locale comparisons</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4537b129b3ba8f2d3226ebf93ad67329cc1da482" translate="yes" xml:space="preserve">
          <source>℞ 41: Unicode linebreaking</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffb493f106ab48250c4114cb54731a428a45f791" translate="yes" xml:space="preserve">
          <source>℞ 42: Unicode text in DBM hashes, the tedious way</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1f50342b103e421d1acc80b87da618d9d7dbcbf" translate="yes" xml:space="preserve">
          <source>℞ 43: Unicode text in DBM hashes, the easy way</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be7f9e81a5e53cdd3b016c1ec9d11fc76ad6eba7" translate="yes" xml:space="preserve">
          <source>℞ 44: PROGRAM: Demo of Unicode collation and printing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35d3a90ee9a924edf21b2fcf53b46d3f1ee47cd1" translate="yes" xml:space="preserve">
          <source>℞ 4: Characters and their numbers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c799958f1af6fc7d0af3b5af403902598504cc5" translate="yes" xml:space="preserve">
          <source>℞ 5: Unicode literals by character number</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="552601dd95b39360794bf9c6c82f6ccf33fa9abf" translate="yes" xml:space="preserve">
          <source>℞ 6: Get character name by number</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16cf8eadbcf317c2200365ffa590b025a1e5c8c9" translate="yes" xml:space="preserve">
          <source>℞ 7: Get character number by name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="914bc39318d79633608c077d658050da4a15d838" translate="yes" xml:space="preserve">
          <source>℞ 8: Unicode named characters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f674921da6a254bb1bdedb20a3aa7a9fc774879" translate="yes" xml:space="preserve">
          <source>℞ 9: Unicode named sequences</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
