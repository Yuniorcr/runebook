<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="b981c090e0ccf2394ca9d98ec6e98f5fdb3b15ee" translate="yes" xml:space="preserve">
          <source>use &lt;code&gt;&amp;amp;len&lt;/code&gt; ). If you do not care what the length of the data is, use the &lt;code&gt;SvPV_nolen&lt;/code&gt; macro. Historically the &lt;code&gt;SvPV&lt;/code&gt; macro with the global variable &lt;code&gt;PL_na&lt;/code&gt; has been used in this case. But that can be quite inefficient because &lt;code&gt;PL_na&lt;/code&gt; must be accessed in thread-local storage in threaded Perl. In any case, remember that Perl allows arbitrary strings of data that may both contain NULs and might not be terminated by a &lt;code&gt;NUL&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;&amp;amp;len&lt;/code&gt; 사용 ). 데이터 길이가 중요하지 않으면 &lt;code&gt;SvPV_nolen&lt;/code&gt; 매크로를 사용하십시오 . 역사적으로 글로벌 변수 &lt;code&gt;PL_na&lt;/code&gt; 를 가진 &lt;code&gt;SvPV&lt;/code&gt; 매크로 가이 경우에 사용되었습니다. 그러나 &lt;code&gt;PL_na&lt;/code&gt; 는 스레드 Perl의 스레드 로컬 스토리지에서 액세스해야 하므로 상당히 비효율적 일 수 있습니다 . 어쨌든 Perl은 NUL을 포함하고 &lt;code&gt;NUL&lt;/code&gt; 에 의해 종료되지 않을 수있는 임의의 데이터 문자열을 허용한다는 것을 기억하십시오 .</target>
        </trans-unit>
        <trans-unit id="ab7c0594a0c4ad4b7139bc4478498a69f7e492fd" translate="yes" xml:space="preserve">
          <source>use &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">사용 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b438f8ebaf9cd38ef6ddc105cb8f6b0e5c7983a5" translate="yes" xml:space="preserve">
          <source>use &lt;code&gt;B&amp;lt;&amp;gt;&lt;/code&gt; for commands names like &lt;b&gt;cat&lt;/b&gt; or &lt;b&gt;grep&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;cat&lt;/b&gt; 또는 &lt;b&gt;grep&lt;/b&gt; 과 같은 명령 이름 에는 &lt;code&gt;B&amp;lt;&amp;gt;&lt;/code&gt; 를 사용하십시오 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="912f09261e74f066e3e24f4b46906e4342000bf4" translate="yes" xml:space="preserve">
          <source>use &lt;code&gt;C&amp;lt;&amp;gt;&lt;/code&gt; for function, variable and module names (and more generally anything that can be considered part of code, like filehandles or specific values). Note that function names are considered more readable with parentheses after their name, that is &lt;code&gt;function()&lt;/code&gt; .</source>
          <target state="translated">함수, 변수 및 모듈 이름 (및 일반적으로 파일 핸들 또는 특정 값과 같이 코드의 일부로 간주 될 수있는 모든 것)에 &lt;code&gt;C&amp;lt;&amp;gt;&lt;/code&gt; 를 사용하십시오 . 함수 이름은 이름 뒤에 괄호를 사용하여 더 읽기 쉬운 것으로 간주됩니다 . 즉 &lt;code&gt;function()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="91895a1cf51d91f57aca46510d3d62ba8b32f1ee" translate="yes" xml:space="preserve">
          <source>use &lt;code&gt;F&amp;lt;&amp;gt;&lt;/code&gt; or &lt;code&gt;C&amp;lt;&amp;gt;&lt;/code&gt; for file names. &lt;code&gt;F&amp;lt;&amp;gt;&lt;/code&gt; should be the only Pod code for file names, but as most Pod formatters render it as italic, Unix and Windows paths with their slashes and backslashes may be less readable, and better rendered with &lt;code&gt;C&amp;lt;&amp;gt;&lt;/code&gt; .</source>
          <target state="translated">사용 &lt;code&gt;F&amp;lt;&amp;gt;&lt;/code&gt; 나 &lt;code&gt;C&amp;lt;&amp;gt;&lt;/code&gt; 파일 이름. &lt;code&gt;F&amp;lt;&amp;gt;&lt;/code&gt; 는 파일 이름에 대한 유일한 포드 코드 여야하지만 대부분의 포드 포맷터는 이탤릭체로 렌더링하므로 슬래시와 백 슬래시가있는 Unix 및 Windows 경로는 읽기 어렵고 &lt;code&gt;C&amp;lt;&amp;gt;&lt;/code&gt; 더 잘 렌더링됩니다 .</target>
        </trans-unit>
        <trans-unit id="bdc3bde8eda2284372421b6e4025b7b2372a316b" translate="yes" xml:space="preserve">
          <source>use Bourne shell (&lt;code&gt;sh(1)&lt;/code&gt; ) redirection syntax in backticks, not &lt;code&gt;csh(1)&lt;/code&gt; ! Details on why Perl's &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; and backtick and pipe opens all use the Bourne shell are in the</source>
          <target state="translated">&lt;code&gt;csh(1)&lt;/code&gt; 아닌 백틱에서 Bourne shell ( &lt;code&gt;sh(1)&lt;/code&gt; ) 리디렉션 구문을 사용하십시오 ! Perl의 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 및 backtick 및 파이프 열기가 모두 Bourne 쉘을 사용하는 이유에 대한 세부 사항</target>
        </trans-unit>
        <trans-unit id="16599c655382953c8630fbbdb2c964d3e8dee9ae" translate="yes" xml:space="preserve">
          <source>use Module</source>
          <target state="translated">모듈 사용</target>
        </trans-unit>
        <trans-unit id="90f04428920392ff9b2def8ba0ed469f079b6502" translate="yes" xml:space="preserve">
          <source>use Module LIST</source>
          <target state="translated">모듈 LIST 사용</target>
        </trans-unit>
        <trans-unit id="7ed0869d2d4fc928494f42d5819555da7a79edd6" translate="yes" xml:space="preserve">
          <source>use Module VERSION</source>
          <target state="translated">모듈 버전 사용</target>
        </trans-unit>
        <trans-unit id="c2de803ffc4c0a3b39ed0dff30412c19bd9d9fee" translate="yes" xml:space="preserve">
          <source>use Module VERSION LIST</source>
          <target state="translated">모듈 버전 목록 사용</target>
        </trans-unit>
        <trans-unit id="ed1b16f9eadabbae879f86b68ec71e8b6d05ca67" translate="yes" xml:space="preserve">
          <source>use Perl; used to provide a slashdot-style news/blog website covering all things Perl, from minutes of the meetings of the Perl 6 Design team to conference announcements with (ir)relevant discussion. It no longer accepts updates, but you can still use the site to read old entries and comments.</source>
          <target state="translated">Perl을 사용하십시오. Perl 6 디자인 팀 회의록에서 (ir) 관련 토론이있는 회의 발표에 이르기까지 Perl의 모든 내용을 다루는 슬래시 도트 스타일의 뉴스 / 블로그 웹 사이트를 제공하는 데 사용됩니다. 더 이상 업데이트를 수락하지 않지만 사이트를 사용하여 이전 항목과 주석을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d91bc845470d4a86d4018011a4792f7dcf86f037" translate="yes" xml:space="preserve">
          <source>use SA_RESTART. Consequently, restartable system calls can fail (with $! set to &lt;code&gt;EINTR&lt;/code&gt; ) in places where they previously would have succeeded.</source>
          <target state="translated">SA_RESTART를 사용하십시오. 결과적으로 다시 시작 가능한 시스템 호출은 이전에 성공했던 위치에서 $!가 &lt;code&gt;EINTR&lt;/code&gt; 로 설정되어 실패 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4c7c49503a611307f683497f7df47accbf51802a" translate="yes" xml:space="preserve">
          <source>use VERSION</source>
          <target state="translated">버전 사용</target>
        </trans-unit>
        <trans-unit id="86d6a1e3bbd163625d7fac651620cbfa17805164" translate="yes" xml:space="preserve">
          <source>use bytes;</source>
          <target state="translated">바이트 사용;</target>
        </trans-unit>
        <trans-unit id="59d6056cfb56b5a37f62f1bf027d56c8cb904bd1" translate="yes" xml:space="preserve">
          <source>use integer vs. use bigint</source>
          <target state="translated">정수 사용 vs. bigint 사용</target>
        </trans-unit>
        <trans-unit id="814151fffad1e37f33b4e503823e70b6bbf3c04b" translate="yes" xml:space="preserve">
          <source>use integer;</source>
          <target state="translated">정수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3d1d48f5b10a148ad0e4d39b9da43de87d730e84" translate="yes" xml:space="preserve">
          <source>use of a backslash to include a space in a word</source>
          <target state="translated">단어에 공백을 포함하기 위해 백 슬래시 사용</target>
        </trans-unit>
        <trans-unit id="1f5c67435c71d9a6ca9c3233dedb2dc1513c55c2" translate="yes" xml:space="preserve">
          <source>use of a backslash to remove the special meaning of a double-quote</source>
          <target state="translated">큰 따옴표의 특수 의미를 제거하기 위해 백 슬래시 사용</target>
        </trans-unit>
        <trans-unit id="f6fe0074742b81fff90e497bf135242ea8e89606" translate="yes" xml:space="preserve">
          <source>use of quotes to include a space in a word</source>
          <target state="translated">단어에 공백을 포함하기 위해 따옴표 사용</target>
        </trans-unit>
        <trans-unit id="8c01026ad061791e802cf597a172313b49e695da" translate="yes" xml:space="preserve">
          <source>use re 'strict'</source>
          <target state="translated">다시 '엄격한'을 사용하십시오</target>
        </trans-unit>
        <trans-unit id="cda9500ef317eb6fc5a5f798984325090df1150f" translate="yes" xml:space="preserve">
          <source>use re;</source>
          <target state="translated">다시 사용;</target>
        </trans-unit>
        <trans-unit id="53e07a32bf191d6917ee6fd863f0b52632a86798" translate="yes" xml:space="preserve">
          <source>use strict</source>
          <target state="translated">엄격한 사용</target>
        </trans-unit>
        <trans-unit id="8428b0851b0684a353e7ed0874608908c7b5144e" translate="yes" xml:space="preserve">
          <source>use strict;</source>
          <target state="translated">엄격한 사용;</target>
        </trans-unit>
        <trans-unit id="371d195a9f9f3ece23b26e71d1dd939d2d111281" translate="yes" xml:space="preserve">
          <source>use symbolic references are when you really must refer to the symbol table. This may be because it's something that one can't take a real reference to, such as a format name. Doing so may also be important for method calls, since these always go through the symbol table for resolution.</source>
          <target state="translated">기호 참조 사용은 실제로 기호 테이블을 참조해야 할 때입니다. 형식 이름과 같이 실제로 참조 할 수없는 것이기 때문일 수 있습니다. 분석을 위해 항상 심볼 테이블을 통과하기 때문에 메소드 호출에도 중요 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b052d587b755b57eec4828588dac107af257aee" translate="yes" xml:space="preserve">
          <source>use the &lt;code&gt;sources&lt;/code&gt; parameter below.</source>
          <target state="translated">아래 의 &lt;code&gt;sources&lt;/code&gt; 매개 변수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="cbacfc4c115173ec78e0b2e5387eefbdb941b814" translate="yes" xml:space="preserve">
          <source>use the brackets. These are correct: &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(FH)&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;(FH, 0,
2)&lt;/code&gt; and &quot;copying from STDIN to FILE&quot;.</source>
          <target state="translated">괄호를 사용하십시오. 다음은 올바른 : &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(FH)&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;(FH, 0, 2)&lt;/code&gt; 및 &quot;FILE에 STDIN에서 복사&quot;.</target>
        </trans-unit>
        <trans-unit id="16242ca7d468c97ea7b6997607a050d2e0014a3f" translate="yes" xml:space="preserve">
          <source>use utf8;</source>
          <target state="translated">utf8을 사용하십시오;</target>
        </trans-unit>
        <trans-unit id="9d9bf76551e571ede80cc893a3c04b1861a56e60" translate="yes" xml:space="preserve">
          <source>use warnings;</source>
          <target state="translated">경고를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="43e6bb793575b0e1c61db35e98228f60aeaf2f8d" translate="yes" xml:space="preserve">
          <source>use()</source>
          <target state="translated">use()</target>
        </trans-unit>
        <trans-unit id="d05287976184d88c455cd302b00f63b076bbdc63" translate="yes" xml:space="preserve">
          <source>use64bits.U</source>
          <target state="translated">use64bits.U</target>
        </trans-unit>
        <trans-unit id="de888ddd185c016565479b29ef9407370202fca3" translate="yes" xml:space="preserve">
          <source>usebacktrace.U</source>
          <target state="translated">usebacktrace.U</target>
        </trans-unit>
        <trans-unit id="c75278e55d10139a00150399331bbf063800d605" translate="yes" xml:space="preserve">
          <source>useconds or interval more than ...</source>
          <target state="translated">useconds 또는 간격 이상 ...</target>
        </trans-unit>
        <trans-unit id="83a7a6b40353b9f6be160c361611ae311dfb9752" translate="yes" xml:space="preserve">
          <source>useconds or uinterval equal to or more than 1000000</source>
          <target state="translated">1000000 이상의 useconds 또는 uinterval</target>
        </trans-unit>
        <trans-unit id="192a56759d36454cc0b8c812e31845e9ed10b130" translate="yes" xml:space="preserve">
          <source>used</source>
          <target state="translated">used</target>
        </trans-unit>
        <trans-unit id="73decdd966503bbba3c9fd02a2b5f2ce91746665" translate="yes" xml:space="preserve">
          <source>used by &lt;code&gt;DynaLoader&lt;/code&gt; for DLL name mangling.</source>
          <target state="translated">DLL 이름 맹 글링을 위해 &lt;code&gt;DynaLoader&lt;/code&gt; 에서 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="e30f4a35ac593e13f39f5488a20368f2d3e27f69" translate="yes" xml:space="preserve">
          <source>used by &lt;code&gt;File::Copy::copy&lt;/code&gt; , see &lt;a href=&quot;file/copy&quot;&gt;File::Copy&lt;/a&gt;.</source>
          <target state="translated">에서 사용하는 &lt;code&gt;File::Copy::copy&lt;/code&gt; , 참조 &lt;a href=&quot;file/copy&quot;&gt;파일 :: 복사&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6651965b06637ac206b1de96bf978eb27b24abe2" translate="yes" xml:space="preserve">
          <source>used by Microsoft C/C++), all of these functions will be available for use. Otherwise, you won't be able to perform the SHA-384 and SHA-512 transforms, both of which require 64-bit operations.</source>
          <target state="translated">Microsoft C / C ++에서 사용하는 경우 이러한 기능을 모두 사용할 수 있습니다. 그렇지 않으면 64 비트 작업이 필요한 SHA-384 및 SHA-512 변환을 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4bcdb1a3c67ee6a36e9c8f01fec7794365214c0a" translate="yes" xml:space="preserve">
          <source>used in the Canonical Ordering Algorithm. For Unicode 5.1, this is described in Section 3.11 &lt;code&gt;Canonical Ordering Behavior&lt;/code&gt; available at &lt;a href=&quot;http://www.unicode.org/versions/Unicode5.1.0/&quot;&gt;http://www.unicode.org/versions/Unicode5.1.0/&lt;/a&gt;</source>
          <target state="translated">정식 순서 알고리즘에 사용됩니다. 유니 코드 5.1의 경우, 이는 &lt;a href=&quot;http://www.unicode.org/versions/Unicode5.1.0/&quot;&gt;http://www.unicode.org/versions/Unicode5.1.0/에&lt;/a&gt; 있는 3.11 절의 &lt;code&gt;Canonical Ordering Behavior&lt;/code&gt; 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d652c7d874ec8b1c40417e324ea5d062c754cc5c" translate="yes" xml:space="preserve">
          <source>used in this way, the result of evaluation of &lt;code&gt;code&lt;/code&gt; is put into the special variable &lt;code&gt;$^R&lt;/code&gt; . This happens immediately, so &lt;code&gt;$^R&lt;/code&gt; can be used from other &lt;code&gt;(?{ code })&lt;/code&gt; assertions inside the same regular expression.</source>
          <target state="translated">이러한 방식으로 사용되는 &lt;code&gt;code&lt;/code&gt; 평가 결과 는 특수 변수 &lt;code&gt;$^R&lt;/code&gt; 됩니다. 이것은 즉시 발생하므로 동일한 정규 표현식 내의 다른 &lt;code&gt;(?{ code })&lt;/code&gt; 어설 션 에서 &lt;code&gt;$^R&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="910e6213db30e16ad6b1c4b4021611873d6ce5e8" translate="yes" xml:space="preserve">
          <source>usedtrace.U</source>
          <target state="translated">usedtrace.U</target>
        </trans-unit>
        <trans-unit id="ae3154c3ec5c365c6959f779a04adc35659601ba" translate="yes" xml:space="preserve">
          <source>usefaststdio.U</source>
          <target state="translated">usefaststdio.U</target>
        </trans-unit>
        <trans-unit id="682aa3c2d38618cf64e946cc3bbd2fc8a96d01db" translate="yes" xml:space="preserve">
          <source>useful programs are slow</source>
          <target state="translated">유용한 프로그램이 느리다</target>
        </trans-unit>
        <trans-unit id="64cd2a07a89b1a0f1da29526d021d0937a062dc3" translate="yes" xml:space="preserve">
          <source>useful:</source>
          <target state="translated">useful:</target>
        </trans-unit>
        <trans-unit id="86959ccaa35c5e158cbc673c5b275d5c75322ffb" translate="yes" xml:space="preserve">
          <source>usekernprocpathname.U</source>
          <target state="translated">usekernprocpathname.U</target>
        </trans-unit>
        <trans-unit id="dfb174e9b45efda0d2813ab34a52566fc0e5149a" translate="yes" xml:space="preserve">
          <source>uselfs.U</source>
          <target state="translated">uselfs.U</target>
        </trans-unit>
        <trans-unit id="4a865fd135358714278adf708601a551aa95d374" translate="yes" xml:space="preserve">
          <source>uselongdbl.U</source>
          <target state="translated">uselongdbl.U</target>
        </trans-unit>
        <trans-unit id="8f139461261d4e47392a29d9a1470571a111a9dc" translate="yes" xml:space="preserve">
          <source>uselongdouble.cbu</source>
          <target state="translated">uselongdouble.cbu</target>
        </trans-unit>
        <trans-unit id="55dcabac6b2a581cb97ea8cc9bfb5c2c032a1aa2" translate="yes" xml:space="preserve">
          <source>usemorebits.U</source>
          <target state="translated">usemorebits.U</target>
        </trans-unit>
        <trans-unit id="cacd09fc8d7a5be6357aae988bf81988f273cde2" translate="yes" xml:space="preserve">
          <source>usemultiplicity.U</source>
          <target state="translated">usemultiplicity.U</target>
        </trans-unit>
        <trans-unit id="999728bc8bffebc44a36dcc8573424d9a99a522c" translate="yes" xml:space="preserve">
          <source>usenm.U</source>
          <target state="translated">usenm.U</target>
        </trans-unit>
        <trans-unit id="135519af067f60479443d73bde99b3ce40a82660" translate="yes" xml:space="preserve">
          <source>usensgetexecutablepath.U</source>
          <target state="translated">usensgetexecutablepath.U</target>
        </trans-unit>
        <trans-unit id="f8a6096831b8f25daa716e7ca10d96073259de34" translate="yes" xml:space="preserve">
          <source>useperlio.U</source>
          <target state="translated">useperlio.U</target>
        </trans-unit>
        <trans-unit id="97f9b6453ab8627d3cd32b5de7ede1a376eb1e42" translate="yes" xml:space="preserve">
          <source>usequadmath.U</source>
          <target state="translated">usequadmath.U</target>
        </trans-unit>
        <trans-unit id="12dea96fec20593566ab75692c9949596833adc9" translate="yes" xml:space="preserve">
          <source>user</source>
          <target state="translated">user</target>
        </trans-unit>
        <trans-unit id="948109d35f9658f13aa26db4dca1ebe12f69c043" translate="yes" xml:space="preserve">
          <source>user interface (tty or graphical)</source>
          <target state="translated">사용자 인터페이스 (tty 또는 그래픽)</target>
        </trans-unit>
        <trans-unit id="99cd2c26d48da74abf7a71cda0673fef004fd48c" translate="yes" xml:space="preserve">
          <source>user time</source>
          <target state="translated">사용자 시간</target>
        </trans-unit>
        <trans-unit id="a7e2c648dc9941f38aea4196f90df226d6e93b2b" translate="yes" xml:space="preserve">
          <source>uses</source>
          <target state="translated">uses</target>
        </trans-unit>
        <trans-unit id="8fe9b31e1cb4034ae05b748f916caeb04bc961ae" translate="yes" xml:space="preserve">
          <source>uses &lt;code&gt;$a&lt;/code&gt; for the width, &lt;code&gt;$b&lt;/code&gt; for the precision, and &lt;code&gt;$c&lt;/code&gt; as the value to format; while:</source>
          <target state="translated">사용 &lt;code&gt;$a&lt;/code&gt; 폭에 대해 &lt;code&gt;$b&lt;/code&gt; 정밀도에 대한, 그리고 &lt;code&gt;$c&lt;/code&gt; 포맷 값으로; 동안:</target>
        </trans-unit>
        <trans-unit id="09830868f1f121ce087a3809e753c0b99304db3d" translate="yes" xml:space="preserve">
          <source>uses dl_findfile() to determine the filename to load</source>
          <target state="translated">dl_findfile ()을 사용하여로드 할 파일 이름을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="5af968b0841a76d30d08c146e669a78b4cab19ad" translate="yes" xml:space="preserve">
          <source>uses empty string matches as separators to produce the output 'a:b:c'; thus, the empty string may be used to split EXPR into a list of its component characters.</source>
          <target state="translated">빈 문자열 일치를 구분 기호로 사용하여 출력 'a : b : c'를 생성합니다. 따라서 빈 문자열을 사용하여 EXPR을 구성 요소 문자 목록으로 분할 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90fd05af98859035d1a5f230da49fa1011416f54" translate="yes" xml:space="preserve">
          <source>uses the 'b' in 'abc' as a separator to produce the output 'a:c'. However, this:</source>
          <target state="translated">출력 'a : c'를 생성하기 위해 'abc'의 'b'를 구분 기호로 사용합니다. 그러나 이것은 :</target>
        </trans-unit>
        <trans-unit id="0385b247665cc9feec9dd5e3fae26654605693e5" translate="yes" xml:space="preserve">
          <source>uses the &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; class.</source>
          <target state="translated">&lt;a href=&quot;threads&quot;&gt;스레드&lt;/a&gt; 클래스를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="7a1854e57bb3e0204fcdb39b3f71fdc0b1165103" translate="yes" xml:space="preserve">
          <source>uses the lexical variables that are maintained by the closure.</source>
          <target state="translated">클로저에 의해 유지되는 어휘 변수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="09d1afddd581a0eacf04d5d0d5756a7efff2579d" translate="yes" xml:space="preserve">
          <source>uses the object passed to the method to store any context data, whereas the</source>
          <target state="translated">메소드에 전달 된 객체를 사용하여 컨텍스트 데이터를 저장하는 반면</target>
        </trans-unit>
        <trans-unit id="c3ceef66b33c51bee6d1bb1d471003d812947110" translate="yes" xml:space="preserve">
          <source>uses the string &lt;code&gt;&quot;\n&quot;&lt;/code&gt; as the line delimiter.</source>
          <target state="translated">문자열 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 을 줄 구분자로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c3cd2678befce2c7f2ae3fa75bbf277408ae4f0c" translate="yes" xml:space="preserve">
          <source>usesocks.U</source>
          <target state="translated">usesocks.U</target>
        </trans-unit>
        <trans-unit id="f9de3288841199ccb6c310b320eb302bb6d60b04" translate="yes" xml:space="preserve">
          <source>usethreads.U</source>
          <target state="translated">usethreads.U</target>
        </trans-unit>
        <trans-unit id="92bd75ebd8fd2b0179172217b15350cc6d4002f0" translate="yes" xml:space="preserve">
          <source>using</source>
          <target state="translated">using</target>
        </trans-unit>
        <trans-unit id="598c217817c73e5780e3966c099266496e2980d1" translate="yes" xml:space="preserve">
          <source>using GNU libc and you can ignore &lt;code&gt;LANGUAGE&lt;/code&gt; .</source>
          <target state="translated">GNU libc를 사용하면 &lt;code&gt;LANGUAGE&lt;/code&gt; 를 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="16fc297cbc600394f05f8c2154dec797fd2616a9" translate="yes" xml:space="preserve">
          <source>using the &lt;b&gt;parseopts()&lt;/b&gt; method. The set of currently accepted parse-options is as follows:</source>
          <target state="translated">&lt;b&gt;parseopts ()&lt;/b&gt; 메소드 사용 현재 허용되는 구문 분석 옵션 세트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5ddf1529ff81cf1646da1b5ad744e5598d0ce2a2" translate="yes" xml:space="preserve">
          <source>using the G_EVAL flag, it promptly reset &lt;code&gt;$@&lt;/code&gt; . This results in the failure of the outermost test for &lt;code&gt;$@&lt;/code&gt; , and thereby the failure of the error trap.</source>
          <target state="translated">G_EVAL 플래그를 사용하여 &lt;code&gt;$@&lt;/code&gt; 즉시 재설정 합니다. 이로 인해 &lt;code&gt;$@&lt;/code&gt; 에 대한 가장 바깥 쪽 테스트 가 실패하여 오류 트랩이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="eb699932692b6b7e2ea37fceb7f7f660756e9c08" translate="yes" xml:space="preserve">
          <source>using the mkstemp() from this module.</source>
          <target state="translated">이 모듈에서 mkstemp () 사용.</target>
        </trans-unit>
        <trans-unit id="74206ccb17460da0011cfb062984120700d158f9" translate="yes" xml:space="preserve">
          <source>usrinc.U</source>
          <target state="translated">usrinc.U</target>
        </trans-unit>
        <trans-unit id="f68489ebd04ca3a9cf85cc582f26b952d9e0e821" translate="yes" xml:space="preserve">
          <source>usually denotes an intensity, but the name does not matter). The number</source>
          <target state="translated">일반적으로 강도를 나타내지 만 이름은 중요하지 않습니다. 수</target>
        </trans-unit>
        <trans-unit id="552fa32543fec03ccf6183c2b935ef13e3235d5b" translate="yes" xml:space="preserve">
          <source>usually have their own documentation, either in the</source>
          <target state="translated">일반적으로</target>
        </trans-unit>
        <trans-unit id="5b8f21f7c75d9b9f23162e7287673f1417b09fab" translate="yes" xml:space="preserve">
          <source>usually need to be overridden by subclasses.</source>
          <target state="translated">일반적으로 서브 클래스로 대체해야합니다.</target>
        </trans-unit>
        <trans-unit id="81f0c4ab9b5679964eab3692a28c6daa905d6fc9" translate="yes" xml:space="preserve">
          <source>utf8</source>
          <target state="translated">utf8</target>
        </trans-unit>
        <trans-unit id="bf16403afd56538795ee624940c94265c7f38841" translate="yes" xml:space="preserve">
          <source>utf8 - Perl pragma to enable/disable UTF-8 (or UTF-EBCDIC) in source code</source>
          <target state="translated">utf8-소스 코드에서 UTF-8 (또는 UTF-EBCDIC)을 활성화 / 비활성화하는 Perl pragma</target>
        </trans-unit>
        <trans-unit id="a594f2111ee293665faf1e597c91b88defdbc7c8" translate="yes" xml:space="preserve">
          <source>utf8.h</source>
          <target state="translated">utf8.h</target>
        </trans-unit>
        <trans-unit id="c23f5615906bc56a2ba756aeb96aa29939293657" translate="yes" xml:space="preserve">
          <source>utf8::unicode_to_native() and utf8::native_to_unicode()</source>
          <target state="translated">utf8 :: unicode_to_native () 및 utf8 :: native_to_unicode ()</target>
        </trans-unit>
        <trans-unit id="1817968011ad57f4fc7f6411c6afa179d20d5f52" translate="yes" xml:space="preserve">
          <source>utfebcdic.h</source>
          <target state="translated">utfebcdic.h</target>
        </trans-unit>
        <trans-unit id="ccf120ba24ab73f5ca75edfecede60e684a35e77" translate="yes" xml:space="preserve">
          <source>utility (which should be installed if you have gcc 3.0 or newer installed).</source>
          <target state="translated">유틸리티 (gcc 3.0 이상을 설치 한 경우 설치해야 함).</target>
        </trans-unit>
        <trans-unit id="e41e3186138fd652f131d74e1372b713a50e4b13" translate="yes" xml:space="preserve">
          <source>utility available from the shell or from the C library. Consult your system's documentation for information on iconv.</source>
          <target state="translated">쉘 또는 C 라이브러리에서 사용 가능한 유틸리티. iconv에 대한 내용은 시스템 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b875306388033d91efeec1a88fa3e69e64258572" translate="yes" xml:space="preserve">
          <source>utility is distributed as part of the &lt;a href=&quot;http://search.cpan.org/perldoc/Module::Starter&quot;&gt;Module::Starter&lt;/a&gt; CPAN package. It creates a directory with stubs of all the necessary files to start a new module, according to recent &quot;best practice&quot; for module development, and is invoked from the command line, thus:</source>
          <target state="translated">유틸리티는 &lt;a href=&quot;http://search.cpan.org/perldoc/Module::Starter&quot;&gt;Module :: Starter&lt;/a&gt; CPAN 패키지의 일부로 배포됩니다 . 모듈 개발을위한 최근의 &quot;모범 사례&quot;에 따라 새 모듈을 시작하는 데 필요한 모든 파일이 포함 된 디렉토리를 작성하고 명령 행에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d1c19560c50c6028812fe75cd093528162e899fa" translate="yes" xml:space="preserve">
          <source>utility which can be used to package Perl scripts and/or Perl library directories into SIS files, which can be installed to the device. To run the sisify.pl utility, you will need to have the 'makesis' and 'uidcrc' utilities already installed. If you don't have the Win32 SDKs, you may try for example &lt;a href=&quot;http://gnupoc.sourceforge.net/&quot;&gt;http://gnupoc.sourceforge.net/&lt;/a&gt; or &lt;a href=&quot;http://symbianos.org/~andreh/&quot;&gt;http://symbianos.org/~andreh/&lt;/a&gt;.</source>
          <target state="translated">Perl 스크립트 및 / 또는 Perl 라이브러리 디렉토리를 SIS 파일로 패키지하여 장치에 설치할 수있는 유틸리티입니다. sisify.pl 유틸리티를 실행하려면 'makesis'및 'uidcrc'유틸리티가 이미 설치되어 있어야합니다. Win32 SDK가없는 경우 &lt;a href=&quot;http://gnupoc.sourceforge.net/&quot;&gt;http://gnupoc.sourceforge.net/&lt;/a&gt; 또는 &lt;a href=&quot;http://symbianos.org/~andreh/&quot;&gt;http://symbianos.org/~andreh/&lt;/a&gt; 와 같이 시도 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b5b20e9780dfec2e3ed9c87a6333e7f3f40af656" translate="yes" xml:space="preserve">
          <source>utility will look for errors in your markup.</source>
          <target state="translated">유틸리티가 마크 업에서 오류를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="abd2ad286bf2e0b3a412f26ebf2a2be21f7de0fc" translate="yes" xml:space="preserve">
          <source>utility.</source>
          <target state="translated">utility.</target>
        </trans-unit>
        <trans-unit id="e5b9fa572bc5bd55617cfad38a4c758f62792ceb" translate="yes" xml:space="preserve">
          <source>utility. If none of these apply then passive mode is used.</source>
          <target state="translated">유용. 이들 중 어느 것도 적용되지 않으면 수동 모드가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="14409714f17737ef57cc19222c7537577b62d475" translate="yes" xml:space="preserve">
          <source>utils/</source>
          <target state="translated">utils/</target>
        </trans-unit>
        <trans-unit id="07be56c9175d1e0cf47abe27bd2ea4c74d0a71b7" translate="yes" xml:space="preserve">
          <source>utime</source>
          <target state="translated">utime</target>
        </trans-unit>
        <trans-unit id="e021c739267a3c120765dfd8bbf7a3476cf90409" translate="yes" xml:space="preserve">
          <source>utime LIST</source>
          <target state="translated">utime 목록</target>
        </trans-unit>
        <trans-unit id="3677a34e80cc23f49ad5f1fae628d097e1c1e1cb" translate="yes" xml:space="preserve">
          <source>uu encoding and decoding</source>
          <target state="translated">uu 인코딩 및 디코딩</target>
        </trans-unit>
        <trans-unit id="7a38d8cbd20d9932ba948efaa364bb62651d5ad4" translate="yes" xml:space="preserve">
          <source>v</source>
          <target state="translated">v</target>
        </trans-unit>
        <trans-unit id="361122ca0dc8560cf79ff094f6193cd4093bfbfc" translate="yes" xml:space="preserve">
          <source>v1.0.0 &amp;ndash; first public release, 2012-02-27</source>
          <target state="translated">v1.0.0 &amp;ndash; 첫 공개, 2012-02-27</target>
        </trans-unit>
        <trans-unit id="d8d7aee24dfe0953c95b730f8777dd9d65515b2c" translate="yes" xml:space="preserve">
          <source>v5.22 core Perl runs on z/OS (formerly OS/390). Theoretically it could run on the successors of OS/400 on AS/400 minicomputers as well as VM/ESA, and BS2000 for S/390 Mainframes. Such computers use EBCDIC character sets internally (usually Character Code Set ID 0037 for OS/400 and either 1047 or POSIX-BC for S/390 systems).</source>
          <target state="translated">v5.22 코어 Perl은 z / OS (이전의 OS / 390)에서 실행됩니다. 이론적으로는 AS / 400 미니 컴퓨터뿐만 아니라 VM / ESA 및 S / 390 메인 프레임 용 BS2000의 OS / 400의 후속 버전에서도 실행될 수 있습니다. 이러한 컴퓨터는 내부적으로 EBCDIC 문자 세트를 사용합니다 (일반적으로 OS / 400의 경우 문자 코드 세트 ID 0037, S / 390 시스템의 경우 1047 또는 POSIX-BC).</target>
        </trans-unit>
        <trans-unit id="39f69c278f46165447f30d10acf54277aaa3d5fc" translate="yes" xml:space="preserve">
          <source>val</source>
          <target state="translated">val</target>
        </trans-unit>
        <trans-unit id="c204f11609a31497c02218b5e5a0a169c78effbe" translate="yes" xml:space="preserve">
          <source>valgrind</source>
          <target state="translated">valgrind</target>
        </trans-unit>
        <trans-unit id="53046fa987b388728c455fdf478e8c9a874dace2" translate="yes" xml:space="preserve">
          <source>valid as UTF-8. A line consisting of simply &quot;#&quot;, an e-acute, and any non-highbit byte, is sufficient to establish this file's encoding.</source>
          <target state="translated">UTF-8로 유효합니다. 이 파일의 인코딩을 설정하려면 단순히 &quot;#&quot;, e-acute 및 non-highbit 바이트로 구성된 행이면 충분합니다.</target>
        </trans-unit>
        <trans-unit id="f32b67c7e26342af42efabc674d441dca0a281c5" translate="yes" xml:space="preserve">
          <source>value</source>
          <target state="translated">value</target>
        </trans-unit>
        <trans-unit id="1e7e5e9fa34075181b1c3ae301720ed61601a7be" translate="yes" xml:space="preserve">
          <source>value is returned. It is up to the user to call &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; if they so desire.</source>
          <target state="translated">값이 반환됩니다. 원하는 경우 &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; 을 호출하는 것은 사용자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="216685f7982133ab569ad4dfe5f678f3e1dbbd1f" translate="yes" xml:space="preserve">
          <source>value of 4. Pod processors may complain if</source>
          <target state="translated">포드 프로세서는 다음과 같은 경우에 불만을 제기 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="789c8a7b03ce1d1295ddf529b2afdf58a3077c30" translate="yes" xml:space="preserve">
          <source>value of the array pointed to by $AoA. If you wanted the C notion, you'd have to write &lt;code&gt;${$AoA[$i]}&lt;/code&gt; to force the &lt;code&gt;$AoA[$i]&lt;/code&gt; to get evaluated first before the leading &lt;code&gt;$&lt;/code&gt; dereferencer.</source>
          <target state="translated">$ AoA가 가리키는 배열의 값. C 개념을 원한다면 &lt;code&gt;${$AoA[$i]}&lt;/code&gt; 를 작성하여 &lt;code&gt;$AoA[$i]&lt;/code&gt; 가 선행 &lt;code&gt;$&lt;/code&gt; 역 참조 자 보다 먼저 평가되도록해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b8f2b9679159768f9feb1485f4697501baee27a2" translate="yes" xml:space="preserve">
          <source>value which forms part of the method names described in &lt;a href=&quot;#Package-specific-Attribute-Handling&quot;&gt;Package-specific Attribute Handling&lt;/a&gt; below.</source>
          <target state="translated">아래 &lt;a href=&quot;#Package-specific-Attribute-Handling&quot;&gt;패키지 별 속성 처리에&lt;/a&gt; 설명 된 메소드 이름의 일부를 구성하는 값 .</target>
        </trans-unit>
        <trans-unit id="d8ad9fad6207027296ab17875f3071f0a7723f9b" translate="yes" xml:space="preserve">
          <source>value, with</source>
          <target state="translated">가치</target>
        </trans-unit>
        <trans-unit id="345c822266c73d960e7e049d7d44d3fac7c7ec19" translate="yes" xml:space="preserve">
          <source>value.</source>
          <target state="translated">value.</target>
        </trans-unit>
        <trans-unit id="1de6ed8b204380a369710406f1cf40db9ea3121e" translate="yes" xml:space="preserve">
          <source>value. If the user does not call either of these methods then the result will be a reference to a &lt;code&gt;Net::FTP::dataconn&lt;/code&gt; based object.</source>
          <target state="translated">값. 사용자가 이러한 방법 중 하나를 호출하지 않으면 결과는 &lt;code&gt;Net::FTP::dataconn&lt;/code&gt; 기반 객체에 대한 참조가됩니다 .</target>
        </trans-unit>
        <trans-unit id="44415ffb02a62884cecd489fafaf5338dd30ca7a" translate="yes" xml:space="preserve">
          <source>value. If you want to see if the array is empty, just use &lt;code&gt;if (@array) { # not empty }&lt;/code&gt; for example.</source>
          <target state="translated">값. 배열이 비어 있는지 확인하려면 예를 들어 &lt;code&gt;if (@array) { # not empty }&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="417801383c26ee78fc40ea379e8eda01aa338144" translate="yes" xml:space="preserve">
          <source>value:</source>
          <target state="translated">value:</target>
        </trans-unit>
        <trans-unit id="048b0cb1b94379c74e7e8c8ede496e3edbea3386" translate="yes" xml:space="preserve">
          <source>values</source>
          <target state="translated">values</target>
        </trans-unit>
        <trans-unit id="17a7c4c339f3492b8acb953db7732092bf51412a" translate="yes" xml:space="preserve">
          <source>values ARRAY</source>
          <target state="translated">ARRAY 값</target>
        </trans-unit>
        <trans-unit id="2634c50fe8c56acb708defe572a6f66bd0ae2e7a" translate="yes" xml:space="preserve">
          <source>values EXPR</source>
          <target state="translated">EXPR 값</target>
        </trans-unit>
        <trans-unit id="be8bd433d6363b535b0f1f125f2785bdc4c730c2" translate="yes" xml:space="preserve">
          <source>values HASH</source>
          <target state="translated">값 해시</target>
        </trans-unit>
        <trans-unit id="52427f1ebccdb4fcea47bc5d0e5145b7b892e93d" translate="yes" xml:space="preserve">
          <source>values from 0 to 5, such as &lt;code&gt;rgb000&lt;/code&gt; or &lt;code&gt;rgb515&lt;/code&gt; . Similarly, the recognized background colors are:</source>
          <target state="translated">&lt;code&gt;rgb000&lt;/code&gt; 또는 &lt;code&gt;rgb515&lt;/code&gt; 와 같은 0에서 5 사이의 값 . 마찬가지로 인식되는 배경색은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e74a3ebadeba9abb6c66ee5f8ffd1d486ee6fcb8" translate="yes" xml:space="preserve">
          <source>values from 0 to 5.</source>
          <target state="translated">0에서 5 사이의 값.</target>
        </trans-unit>
        <trans-unit id="e6ad9de07df6ee716656600f984ea5e44acf9199" translate="yes" xml:space="preserve">
          <source>values may already be available through the POSIX, Errno, or Fcntl modules.) The &lt;b&gt;pl2pm&lt;/b&gt; file in the distribution may help in your conversion, but it's just a mechanical process and therefore far from bulletproof.</source>
          <target state="translated">POSIX, Errno 또는 Fcntl 모듈을 통해 값을 이미 사용할 수 있습니다.) 배포판 의 &lt;b&gt;pl2pm&lt;/b&gt; 파일은 변환에 도움이 될 수 있지만 기계적 프로세스 일 뿐이므로 방탄과는 거리가 멀습니다.</target>
        </trans-unit>
        <trans-unit id="b6d212092cfb3c4de0fc9e126c8856174b98ea6d" translate="yes" xml:space="preserve">
          <source>values of variables, open file handles) are not affected by calling &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">변수 값, 열린 파일 핸들)은 &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt; 호출의 영향을받지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c78a54d54f417f166b040fd1193f989fbac7669b" translate="yes" xml:space="preserve">
          <source>vaproto.U</source>
          <target state="translated">vaproto.U</target>
        </trans-unit>
        <trans-unit id="e5b4e786e382d03c28e9edfab2d8149378ae69df" translate="yes" xml:space="preserve">
          <source>var</source>
          <target state="translated">var</target>
        </trans-unit>
        <trans-unit id="442355f6097724b9f300211ae8b56c9215274278" translate="yes" xml:space="preserve">
          <source>varargs.h</source>
          <target state="translated">varargs.h</target>
        </trans-unit>
        <trans-unit id="32c263408bb93f559077c6e179bd9ba556508a09" translate="yes" xml:space="preserve">
          <source>varglob (VARNAME)</source>
          <target state="translated">바르 글로브 (VARNAME)</target>
        </trans-unit>
        <trans-unit id="b46d0172433dd6895dac7544b9dacbb87b361e9f" translate="yes" xml:space="preserve">
          <source>variable</source>
          <target state="translated">variable</target>
        </trans-unit>
        <trans-unit id="f28cdc93712b217f7e1a7f8c732549e7fca12478" translate="yes" xml:space="preserve">
          <source>variable. If found, and the value does not begin with a slash, and the terminal type name is the same as the environment string</source>
          <target state="translated">변하기 쉬운. 발견되면 값이 슬래시로 시작하지 않고 터미널 유형 이름이 환경 문자열과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="73be3da84c74dd524e9174ed859ebd8fbe0ecb3e" translate="yes" xml:space="preserve">
          <source>variables with) the compartment's namespace and only that data will be visible to code evaluated in the compartment.</source>
          <target state="translated">구획의 네임 스페이스를 포함하고 해당 데이터 만 구획에서 코드 평가할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="328b2913d40a4414bbacabb3a360dbd897edd419" translate="yes" xml:space="preserve">
          <source>vars</source>
          <target state="translated">vars</target>
        </trans-unit>
        <trans-unit id="d0738423627650c10c37e4c0cb07def0732c0229" translate="yes" xml:space="preserve">
          <source>vars - Perl pragma to predeclare global variable names</source>
          <target state="translated">vars-전역 변수 이름을 미리 선언하는 Perl pragma</target>
        </trans-unit>
        <trans-unit id="3fda85e28248463329b5095a7e36c028b3156227" translate="yes" xml:space="preserve">
          <source>vary in size. The alignment constraint of the structure can be greater than any of its elements. [And if you think that this doesn't affect anything common, dismember the next cellphone that you see. Many have ARM cores, and the ARM structure rules make &lt;code&gt;sizeof (foo_t)&lt;/code&gt; == 4]</source>
          <target state="translated">크기가 다릅니다. 구조의 정렬 구속 조건은 임의의 요소보다 클 수 있습니다. [이것이 일반적인 것에 영향을 미치지 않는다고 생각되면 다음에 보이는 휴대 전화를 삭제하십시오. 많은 사람들이 ARM 코어를 가지고 있으며, ARM 구조 규칙은 &lt;code&gt;sizeof (foo_t)&lt;/code&gt; == 4를 만듭니다. ]</target>
        </trans-unit>
        <trans-unit id="b803e7ca5c714dbd85bf00d511fbc99a77690ad2" translate="yes" xml:space="preserve">
          <source>vec</source>
          <target state="translated">vec</target>
        </trans-unit>
        <trans-unit id="c54a18ac21d0acf2be7f8a4af68b6de9a68db6ff" translate="yes" xml:space="preserve">
          <source>vec EXPR,OFFSET,BITS</source>
          <target state="translated">vec EXPR, 오프셋, 비트</target>
        </trans-unit>
        <trans-unit id="32af47b87ac2b19a971faaedbed3373dcd83c6e8" translate="yes" xml:space="preserve">
          <source>vector flag</source>
          <target state="translated">벡터 플래그</target>
        </trans-unit>
        <trans-unit id="f997c58732c07191b9cf44ba3c5fdd710cc19a22" translate="yes" xml:space="preserve">
          <source>vendorarch.U</source>
          <target state="translated">vendorarch.U</target>
        </trans-unit>
        <trans-unit id="78c0f01568b26ab7021a574fad5f974198aad6d0" translate="yes" xml:space="preserve">
          <source>vendorbin.U</source>
          <target state="translated">vendorbin.U</target>
        </trans-unit>
        <trans-unit id="660495819236779e293a0a32c3609f3b6829ad8a" translate="yes" xml:space="preserve">
          <source>vendorhtml1dir.U</source>
          <target state="translated">vendorhtml1dir.U</target>
        </trans-unit>
        <trans-unit id="ba034d33799b6d494964ade71fe262b57e78da69" translate="yes" xml:space="preserve">
          <source>vendorhtml3dir.U</source>
          <target state="translated">vendorhtml3dir.U</target>
        </trans-unit>
        <trans-unit id="5c5f94ad3d73d98afb7e36c994b2d58e93b157c9" translate="yes" xml:space="preserve">
          <source>vendorlib.U</source>
          <target state="translated">vendorlib.U</target>
        </trans-unit>
        <trans-unit id="2284692bf04e52a99af83b0173dbfd7bb5474851" translate="yes" xml:space="preserve">
          <source>vendorman1dir.U</source>
          <target state="translated">vendorman1dir.U</target>
        </trans-unit>
        <trans-unit id="0bb32aac5c75643dd8a475440312246f61ee79e2" translate="yes" xml:space="preserve">
          <source>vendorman3dir.U</source>
          <target state="translated">vendorman3dir.U</target>
        </trans-unit>
        <trans-unit id="105d52e11b963cf884747461ead872a0d154eae4" translate="yes" xml:space="preserve">
          <source>vendorprefix.U</source>
          <target state="translated">vendorprefix.U</target>
        </trans-unit>
        <trans-unit id="e5ff5428b3a391d0a31fc7b9d32363c3703413d8" translate="yes" xml:space="preserve">
          <source>vendorscript.U</source>
          <target state="translated">vendorscript.U</target>
        </trans-unit>
        <trans-unit id="5e0b8aa15aad848de36cf3fd23d80803845b78d5" translate="yes" xml:space="preserve">
          <source>ver</source>
          <target state="translated">ver</target>
        </trans-unit>
        <trans-unit id="3a4dc0c486f7ec2c6e9ab752e3ce6d8bf47f6d1c" translate="yes" xml:space="preserve">
          <source>verbatim paragraphs, but</source>
          <target state="translated">축약어 단락이지만</target>
        </trans-unit>
        <trans-unit id="c692273deb2772da307ffe37041fef77bf4baa97" translate="yes" xml:space="preserve">
          <source>version</source>
          <target state="translated">version</target>
        </trans-unit>
        <trans-unit id="d3b94753b152e0687bf16e0e66bde6c46129e227" translate="yes" xml:space="preserve">
          <source>version 0.2304</source>
          <target state="translated">버전 0.2304</target>
        </trans-unit>
        <trans-unit id="10ac6ea1ff9c002c30c590cc6d63a98d39a0b85d" translate="yes" xml:space="preserve">
          <source>version 1.4414</source>
          <target state="translated">버전 1.4414</target>
        </trans-unit>
        <trans-unit id="76c801534aba92a44e1c434c81eb16f53ac7ddba" translate="yes" xml:space="preserve">
          <source>version 1.70</source>
          <target state="translated">버전 1.70</target>
        </trans-unit>
        <trans-unit id="50dd6edfb9d761a98efb572f5834520db1b98413" translate="yes" xml:space="preserve">
          <source>version 3.1, this means configuring with &lt;code&gt;-Doptimize=-g3&lt;/code&gt; . Other compilers might use a different switch (if they support debugging macros at all).</source>
          <target state="translated">버전 3.1의 경우 &lt;code&gt;-Doptimize=-g3&lt;/code&gt; 으로 구성하는 것을 의미합니다 . 다른 컴파일러는 다른 스위치를 사용할 수 있습니다 (매크로 디버깅을 지원하는 경우).</target>
        </trans-unit>
        <trans-unit id="6d8e3493b0cc6a16d5dae9adf9f2dd0db64b3340" translate="yes" xml:space="preserve">
          <source>version 5.021009</source>
          <target state="translated">버전 5.021009</target>
        </trans-unit>
        <trans-unit id="44d2f7e0b9f8b8f230b98d6215f70ce9e9142a5e" translate="yes" xml:space="preserve">
          <source>version mismatch</source>
          <target state="translated">버전 불일치</target>
        </trans-unit>
        <trans-unit id="e6d98fbd6e1f722af1a7187d887c11be3eebc59e" translate="yes" xml:space="preserve">
          <source>version number to standard output, then exits.</source>
          <target state="translated">버전 번호를 표준 출력으로 설정 한 다음 종료합니다.</target>
        </trans-unit>
        <trans-unit id="753706ebef33a950942786467c39030e3338394b" translate="yes" xml:space="preserve">
          <source>version of documentation (&lt;b&gt;very&lt;/b&gt; recommended) outside of OS/2, one needs an IBM's reader (may be available on IBM ftp sites (?) (URL anyone?)) or shipped with PC DOS 7.0 and IBM's Visual Age C++ 3.5.</source>
          <target state="translated">문서의 버전 ( &lt;b&gt;아주&lt;/b&gt; OS / 2의 외부를 권장), 하나는 ()? IBM FTP 사이트 (에서 구할 수 있습니다 (URL 누구?))는 IBM의 독자가 필요하거나 PC DOS 7.0 및 IBM의 비주얼 시대 C ++ 3.5과 함께 제공.</target>
        </trans-unit>
        <trans-unit id="8debcc6e279c738f85bcad06098d11cd2de6baac" translate="yes" xml:space="preserve">
          <source>version of the callback with the same args, or if the f is invalid, set errno to EBADF and return</source>
          <target state="translated">동일한 인수를 가진 콜백의 버전 또는 f가 유효하지 않은 경우 errno를 EBADF로 설정하고 리턴</target>
        </trans-unit>
        <trans-unit id="da458f9f51eff82b9638d6edc4d1ce471a6ba279" translate="yes" xml:space="preserve">
          <source>version of the callback with the same args, or if the f is invalid, set errno to EBADF.</source>
          <target state="translated">args가 동일한 콜백의 버전 또는 f가 유효하지 않은 경우 errno를 EBADF로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="89ea6fd5613838ed30c0baa85610d353411b9790" translate="yes" xml:space="preserve">
          <source>version/</source>
          <target state="translated">version/</target>
        </trans-unit>
        <trans-unit id="636593de67e783331b57ae2dba0e1181ac91cb43" translate="yes" xml:space="preserve">
          <source>version/archname/</source>
          <target state="translated">version/archname/</target>
        </trans-unit>
        <trans-unit id="278658a67f306172b28c147dd5c2b59021a8cb9c" translate="yes" xml:space="preserve">
          <source>versiononly.U</source>
          <target state="translated">versiononly.U</target>
        </trans-unit>
        <trans-unit id="95280caf11d86c580985b1777a2534b60278693b" translate="yes" xml:space="preserve">
          <source>versus/csh.whynot</source>
          <target state="translated">versus/csh.whynot</target>
        </trans-unit>
        <trans-unit id="e74295bfc2ed0b52d40073e8ebad555100df1380" translate="yes" xml:space="preserve">
          <source>very</source>
          <target state="translated">very</target>
        </trans-unit>
        <trans-unit id="81cacac029430830dfca23f87b705db6949c1ea0" translate="yes" xml:space="preserve">
          <source>very same place</source>
          <target state="translated">매우 같은 곳</target>
        </trans-unit>
        <trans-unit id="f2e6aa26ddeffa0689780c36cd916b4d3bb69f77" translate="yes" xml:space="preserve">
          <source>very simple</source>
          <target state="translated">매우 간단</target>
        </trans-unit>
        <trans-unit id="efbea1089258378284b4c64dc60908c3c6b4f3b3" translate="yes" xml:space="preserve">
          <source>vfork.h</source>
          <target state="translated">vfork.h</target>
        </trans-unit>
        <trans-unit id="833da188871dde4c49e08271ff3deff524b7992c" translate="yes" xml:space="preserve">
          <source>vi</source>
          <target state="translated">vi</target>
        </trans-unit>
        <trans-unit id="a19e070e30616772d5e5bccf22dd825266237820" translate="yes" xml:space="preserve">
          <source>via</source>
          <target state="translated">via</target>
        </trans-unit>
        <trans-unit id="3b741f8124ff9a5cff40f1444836353cc05d2208" translate="yes" xml:space="preserve">
          <source>via &lt;code&gt;sh.exe&lt;/code&gt; via &lt;code&gt;perl.exe&lt;/code&gt; , but this is a price to pay if you want to use non-conforming program.</source>
          <target state="translated">via &lt;code&gt;sh.exe&lt;/code&gt; via &lt;code&gt;perl.exe&lt;/code&gt; 이지만, 부적합한 프로그램을 사용하려는 경우 지불하는 가격입니다.</target>
        </trans-unit>
        <trans-unit id="3b68c8b6949fa7692f33f6e0bbc33b71066897e0" translate="yes" xml:space="preserve">
          <source>via pointers</source>
          <target state="translated">포인터를 통해</target>
        </trans-unit>
        <trans-unit id="65f7d47d7029da85cdba5bc94831dbaa426ce6e5" translate="yes" xml:space="preserve">
          <source>via shell</source>
          <target state="translated">쉘을 통해</target>
        </trans-unit>
        <trans-unit id="f1e73a24ed2cd61923e64ac891a0cf0355e98da1" translate="yes" xml:space="preserve">
          <source>vianame() normally returns an ordinal code point, but when the input name is of the form &lt;code&gt;U+...&lt;/code&gt; , it returns a chr instead. In this case, if &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; is in effect and the character won't fit into a byte, it returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and raises a warning.</source>
          <target state="translated">vianame ()은 일반적으로 서수 코드 포인트를 반환하지만 입력 이름이 &lt;code&gt;U+...&lt;/code&gt; 형식 이면 대신 chr을 반환합니다. 이 경우 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 이 유효하고 문자가 바이트에 맞지 않으면 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환 하고 경고를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="857a269ccef5d7fbbb98d9ddef77bc0b5d9701a9" translate="yes" xml:space="preserve">
          <source>vice versa</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af84d91fde168566c7dc18f3121ea2fbe651af1f" translate="yes" xml:space="preserve">
          <source>virtual</source>
          <target state="translated">virtual</target>
        </trans-unit>
        <trans-unit id="273d3211f66d3ed5bfd77d7571871ddef64f03b6" translate="yes" xml:space="preserve">
          <source>virtual time</source>
          <target state="translated">가상 시간</target>
        </trans-unit>
        <trans-unit id="fd9d67fe1b466b2dd61a9d25c1346a7e24941513" translate="yes" xml:space="preserve">
          <source>vms/</source>
          <target state="translated">vms/</target>
        </trans-unit>
        <trans-unit id="92e911c38db62b637631e5e6d4e2f54b71f1b1ec" translate="yes" xml:space="preserve">
          <source>vmsish</source>
          <target state="translated">vmsish</target>
        </trans-unit>
        <trans-unit id="b6f4b16934c4d0ae88fbb45f248668506c1e515a" translate="yes" xml:space="preserve">
          <source>vmsish - Perl pragma to control VMS-specific language features</source>
          <target state="translated">vmsish-VMS 관련 언어 기능을 제어하는 ​​Perl pragma</target>
        </trans-unit>
        <trans-unit id="47c9b6c34c34bb84a495fafd2ac449b137a21fcf" translate="yes" xml:space="preserve">
          <source>vmsperl list, vmsperl-subscribe@perl.org</source>
          <target state="translated">vmsperl 목록, vmsperl-subscribe@perl.org</target>
        </trans-unit>
        <trans-unit id="43e59f877b6e30149c0ab30290dad796aad04379" translate="yes" xml:space="preserve">
          <source>vmsperl on the web, &lt;a href=&quot;http://www.sidhe.org/vmsperl/index.html&quot;&gt;http://www.sidhe.org/vmsperl/index.html&lt;/a&gt;</source>
          <target state="translated">웹의 vmsperl, &lt;a href=&quot;http://www.sidhe.org/vmsperl/index.html&quot;&gt;http://www.sidhe.org/vmsperl/index.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e9cede9b80ea3abd89c755f1117337d429162c86" translate="yes" xml:space="preserve">
          <source>void</source>
          <target state="translated">void</target>
        </trans-unit>
        <trans-unit id="9901ea7bc50240c07dbde1f94425cb15aba6f905" translate="yes" xml:space="preserve">
          <source>volume names</source>
          <target state="translated">볼륨 이름</target>
        </trans-unit>
        <trans-unit id="aff024fe4ab0fece4091de044c58c9ae4233383a" translate="yes" xml:space="preserve">
          <source>w</source>
          <target state="translated">w</target>
        </trans-unit>
        <trans-unit id="daaad336276d15594d0e765f96c17cd746bf4971" translate="yes" xml:space="preserve">
          <source>wait</source>
          <target state="translated">wait</target>
        </trans-unit>
        <trans-unit id="16599a2caf0e43357dfd62cf1bbedac5d4f9aa78" translate="yes" xml:space="preserve">
          <source>wait() and waitpid() can be passed a pseudo-process ID returned by fork(). These calls will properly wait for the termination of the pseudo-process and return its status.</source>
          <target state="translated">wait () 및 waitpid ()는 fork ()에 의해 리턴 된 의사 프로세스 ID로 전달 될 수 있습니다. 이러한 호출은 의사 프로세스가 종료 될 때까지 기다렸다가 상태를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="69c29097cb967e595fc1da3e699aa0f1c4465d43" translate="yes" xml:space="preserve">
          <source>wait(2)</source>
          <target state="translated">wait(2)</target>
        </trans-unit>
        <trans-unit id="2adada1e71a33f071825f68863aa78076956f91c" translate="yes" xml:space="preserve">
          <source>waitpid</source>
          <target state="translated">waitpid</target>
        </trans-unit>
        <trans-unit id="7a5601dcd3b6db75e71ed2908ce3b9fba9edaa57" translate="yes" xml:space="preserve">
          <source>waitpid PID,FLAGS</source>
          <target state="translated">웨이 피드 PID, 플래그</target>
        </trans-unit>
        <trans-unit id="33a4d790db96047d8f48435d61872442016da10a" translate="yes" xml:space="preserve">
          <source>waitpid(3)</source>
          <target state="translated">waitpid(3)</target>
        </trans-unit>
        <trans-unit id="4a714f64e3698739073c4107159d7e2ec7580a59" translate="yes" xml:space="preserve">
          <source>wallclock time</source>
          <target state="translated">벽시계 시간</target>
        </trans-unit>
        <trans-unit id="36fae1179f0e54b2fbcfa0e1e58a96822af50f7c" translate="yes" xml:space="preserve">
          <source>want a record separator of 0777, specify it as &lt;b&gt;-0x1FF&lt;/b&gt;. (This means that you cannot use the &lt;b&gt;-x&lt;/b&gt; option with a directory name that consists of hexadecimal digits, or else Perl will think you have specified a hex number to &lt;b&gt;-0&lt;/b&gt;.)</source>
          <target state="translated">0777의 레코드 구분 기호를 &lt;b&gt;원하면 -0x1FF&lt;/b&gt; 로 지정하십시오 . (이것은 16 진수로 구성된 디렉토리 이름과 함께 &lt;b&gt;-x&lt;/b&gt; 옵션을 사용할 수 없다는 것을 의미합니다. 그렇지 않으면 Perl은 16 진 숫자를 &lt;b&gt;-0으로&lt;/b&gt; 지정했다고 생각합니다 .)</target>
        </trans-unit>
        <trans-unit id="fa1de8a88193794f6bcd0270bd3c78df8da87f33" translate="yes" xml:space="preserve">
          <source>want locks to block access, then go ahead and tie them to something and manage this yourself. This is done on purpose. While managing access to variables is a good thing, Perl doesn't force you out of its living room...</source>
          <target state="translated">잠금 장치가 액세스를 차단 한 다음 계속해서 무언가에 연결하고 직접 관리하십시오. 이것은 의도적으로 이루어집니다. 변수에 대한 액세스를 관리하는 것이 좋지만 Perl은 거실에서 당신을 강요하지 않습니다 ...</target>
        </trans-unit>
        <trans-unit id="42f9df8dd43a1cbf03eed19f45b2ac004af68f76" translate="yes" xml:space="preserve">
          <source>want to follow an &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; with some other statement, you can use one of these styles to avoid the warning:</source>
          <target state="translated">다른 진술과 함께 &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 를 따르고 싶다면 경고를 피하기 위해 다음 스타일 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1be38d5f877aab6abdfed0efc178920ad9fb017d" translate="yes" xml:space="preserve">
          <source>want to follow an &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; with some other statement, you can use one of these styles to avoid the warning:</source>
          <target state="translated">다른 진술과 함께 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 를 따르고 싶다면 경고를 피하기 위해 다음 스타일 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b18cfd0bd3a597bb757ac9a15224a9fadf94a687" translate="yes" xml:space="preserve">
          <source>want to make the same transformation to all keys and/or values in a DBM database.</source>
          <target state="translated">DBM 데이터베이스의 모든 키 및 / 또는 값을 동일하게 변환하려고합니다.</target>
        </trans-unit>
        <trans-unit id="8898e1e919ff199c09160ba3765d7cb61b031b32" translate="yes" xml:space="preserve">
          <source>want to make the same transformation to all keys, all values or both.</source>
          <target state="translated">모든 키, 모든 값 또는 둘 다에 동일한 변환을 수행하려고합니다.</target>
        </trans-unit>
        <trans-unit id="80f812f0ab1052c34ba58a9aa6c43451d87573ad" translate="yes" xml:space="preserve">
          <source>want to subclass &lt;a href=&quot;../parser&quot;&gt;TAP::Parser&lt;/a&gt;'s grammar the best thing to do is read through the code. There's no easy way of summarizing it here.</source>
          <target state="translated">&lt;a href=&quot;../parser&quot;&gt;TAP :: Parser&lt;/a&gt; 문법 을 서브 클래스로 만들고 싶다면 코드를 통해 읽는 것이 가장 좋습니다. 여기에 요약하는 쉬운 방법은 없습니다.</target>
        </trans-unit>
        <trans-unit id="76f51d192120dd11344a546a620674d65ea15871" translate="yes" xml:space="preserve">
          <source>wantarray</source>
          <target state="translated">wantarray</target>
        </trans-unit>
        <trans-unit id="77921eed5c933c5cd87a4b266d8972f000e6983e" translate="yes" xml:space="preserve">
          <source>wanted()</source>
          <target state="translated">wanted()</target>
        </trans-unit>
        <trans-unit id="5383092a76f9a7f2052899ae6bf06e0ebac04977" translate="yes" xml:space="preserve">
          <source>wants</source>
          <target state="translated">wants</target>
        </trans-unit>
        <trans-unit id="4e586b17a78dad3ec40f5515d1f0072bbcf17f64" translate="yes" xml:space="preserve">
          <source>wants to succeed, so it uses the standard pattern back-off-and-retry and lets &lt;code&gt;\D*&lt;/code&gt; expand to just &quot;AB&quot; this time. Now there's indeed something following &quot;AB&quot; that is not &quot;123&quot;. It's &quot;C123&quot;, which suffices.</source>
          <target state="translated">성공하기를 원하므로 표준 패턴 백 오프 및 재 시도를 사용 하고 이번에 는 &lt;code&gt;\D*&lt;/code&gt; 를 &quot;AB&quot;로 확장 할 수 있습니다 . 이제 &quot;123&quot;이 아닌 &quot;AB&quot;뒤에 무언가가 있습니다. &quot;C123&quot;으로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="4c8ea4760fcb5dff8ec1af0394a338be9df55090" translate="yes" xml:space="preserve">
          <source>warn</source>
          <target state="translated">warn</target>
        </trans-unit>
        <trans-unit id="dd055b1e3e77f358b39e3dcec164c30e81c00105" translate="yes" xml:space="preserve">
          <source>warn LIST</source>
          <target state="translated">경고 목록</target>
        </trans-unit>
        <trans-unit id="3f4c20cf2e4f20443c501790a359300f5f40529f" translate="yes" xml:space="preserve">
          <source>warning messages. These messages will be displayed by default. But this is not the same as &lt;code&gt;verbose&lt;/code&gt; mode.</source>
          <target state="translated">경고 메시지. 이 메시지는 기본적으로 표시됩니다. 그러나 이것은 &lt;code&gt;verbose&lt;/code&gt; 모드 와 동일하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9f6be01127af67b499b57da0fae72ba37a45a9a4" translate="yes" xml:space="preserve">
          <source>warning.</source>
          <target state="translated">warning.</target>
        </trans-unit>
        <trans-unit id="bd207fab08951eb6cee30e4969e79ca50d1f7c65" translate="yes" xml:space="preserve">
          <source>warnings</source>
          <target state="translated">warnings</target>
        </trans-unit>
        <trans-unit id="69788f5b932d69519f6c6fa630facec7b52027c8" translate="yes" xml:space="preserve">
          <source>warnings. The difference is that although the previously mandatory warnings are still enabled by default, they can then be subsequently enabled or disabled with the lexical warning pragma. For example, in the code below, an &lt;code&gt;&quot;isn't numeric&quot;&lt;/code&gt; warning will only be reported for the &lt;code&gt;$a&lt;/code&gt; variable.</source>
          <target state="translated">경고. 차이점은 이전에 필수 경고가 기본적으로 계속 활성화되어 있지만 어휘 경고 프라그 마를 사용하여 나중에 활성화하거나 비활성화 할 수 있다는 것입니다. 예를 들어 아래 코드에서 &lt;code&gt;&quot;isn't numeric&quot;&lt;/code&gt; 경고는 &lt;code&gt;$a&lt;/code&gt; 변수에 대해서만보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="25304d614db590d11bde4fb00d1385306732fa04" translate="yes" xml:space="preserve">
          <source>warnings::register</source>
          <target state="translated">warnings::register</target>
        </trans-unit>
        <trans-unit id="38c5e56d56c5509ef7afa87cb247e50311f9a294" translate="yes" xml:space="preserve">
          <source>warnings::register - warnings import function</source>
          <target state="translated">warnings :: register-경고 가져 오기 기능</target>
        </trans-unit>
        <trans-unit id="3de521d3619155e9228f83cc5f773bfcbfc52749" translate="yes" xml:space="preserve">
          <source>was</source>
          <target state="translated">was</target>
        </trans-unit>
        <trans-unit id="f062dc50293a6ebef0644413f16dbe666de1a1ed" translate="yes" xml:space="preserve">
          <source>was available through the &lt;code&gt;Thread.pm&lt;/code&gt; API. This threading model has been deprecated, and was removed as of Perl 5.10.0.)</source>
          <target state="translated">&lt;code&gt;Thread.pm&lt;/code&gt; API를 통해 사용할 수 있었습니다 . 이 스레딩 모델은 더 이상 사용되지 않으며 Perl 5.10.0부터 제거되었습니다.)</target>
        </trans-unit>
        <trans-unit id="1f19bc6bea19581bc44bbfb345e232346246a9a6" translate="yes" xml:space="preserve">
          <source>was called without options, but with the additional behaviour that the temporary file is removed by the object destructor if UNLINK is set to true (the default).</source>
          <target state="translated">옵션없이 호출되었지만 UNLINK가 true (기본값)로 설정된 경우 오브젝트 소멸자가 임시 파일을 제거하는 추가 동작이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f83d8fcf9f9f581aff720bc3d0f0345f5631b7ae" translate="yes" xml:space="preserve">
          <source>was changed to return some value(s), having specified G_DISCARD will mean that they will be wiped by the time control returns from</source>
          <target state="translated">G_DISCARD를 지정하면 일부 값을 반환하도록 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="358b1b390577816773119471fd35f58a152fe39c" translate="yes" xml:space="preserve">
          <source>was deliberately picked to avoid namespace tainting -- this module may be used as a base class so method names that appear in Encode::Encoding are avoided.</source>
          <target state="translated">이 모듈은 기본 클래스로 사용될 수 있으므로 Encode :: Encoding에 나타나는 메서드 이름을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ef5ff209fb64ad33c3a43e09b9777f546e6d687" translate="yes" xml:space="preserve">
          <source>was disabled, IO::Zlib has not much chance of working.</source>
          <target state="translated">IO :: Zlib가 작동하지 않을 가능성이 적습니다.</target>
        </trans-unit>
        <trans-unit id="cc39726c2752bbbdac1623dec16d2ec7ec5530fe" translate="yes" xml:space="preserve">
          <source>was modified after creation. Note that if a temp directory is your current directory, it cannot be removed - a warning will be given in this case. C</source>
          <target state="translated">생성 후 수정되었습니다. 임시 디렉토리가 현재 디렉토리 인 경우 제거 할 수 없습니다.이 경우 경고가 표시됩니다. 씨</target>
        </trans-unit>
        <trans-unit id="1c2cacfa9911a9740c2f39057d9556ce6e3a53b2" translate="yes" xml:space="preserve">
          <source>was not built, user must have HOST perl and properly edit</source>
          <target state="translated">빌드되지 않았습니다. 사용자에게는 HOST perl이 있어야하며 올바르게 편집</target>
        </trans-unit>
        <trans-unit id="e1a5fcfd7b191fc7b62fed25dba309a60f6a62f6" translate="yes" xml:space="preserve">
          <source>was used to invoke native compiler to create HOST miniperl, which then facilitates cross-compiling process. Extension building support was added.</source>
          <target state="translated">HOST miniperl을 작성하기 위해 원시 컴파일러를 호출하는 데 사용되었으며, 이는 크로스 컴파일 프로세스를 용이하게합니다. 확장 건물 지원이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="66ffd23620129e551f53385e61617103184d89ce" translate="yes" xml:space="preserve">
          <source>was written, not even Perl 5.6.0 had been born yet, many features documented in the book remained unimplemented for a long time. Perl 5.8 corrected much of this, and the introduction of the UTF8 flag is one of them. You can think of there being two fundamentally different kinds of strings and string-operations in Perl: one a byte-oriented mode for when the internal UTF8 flag is off, and the other a character-oriented mode for when the internal UTF8 flag is on.</source>
          <target state="translated">Perl 5.6.0조차도 아직 태어나지 않았으며이 책에 기록 된 많은 기능들이 오랫동안 구현되지 않은 채 남아있었습니다. Perl 5.8은이 중 많은 부분을 수정했으며 UTF8 플래그의 도입이 그 중 하나입니다. Perl에는 근본적으로 다른 종류의 문자열과 문자열 연산이 있다고 생각할 수 있습니다. 하나는 내부 UTF8 플래그가 꺼져있을 때 바이트 지향 모드이고 다른 하나는 내부 UTF8 플래그가 켜져있을 때 문자 지향 모드입니다. .</target>
        </trans-unit>
        <trans-unit id="181b4dd436ea635e496b642bf6193eba9531e9f5" translate="yes" xml:space="preserve">
          <source>wasn't installed or doesn't work for you, you can</source>
          <target state="translated">설치되지 않았거나 작동하지 않는 경우</target>
        </trans-unit>
        <trans-unit id="146b5dae12284acb165c37a9e39cd9753cbc537e" translate="yes" xml:space="preserve">
          <source>wc</source>
          <target state="translated">wc</target>
        </trans-unit>
        <trans-unit id="3fe0dfef3d9b02dc86d540b75c78abe297bdb20e" translate="yes" xml:space="preserve">
          <source>we can write the more sensible (see &lt;a href=&quot;test/more&quot;&gt;Test::More&lt;/a&gt; for a full explanation of is() and other testing functions).</source>
          <target state="translated">우리는 더 현명하게 쓸 수 있습니다 ( is () 및 기타 테스트 함수에 대한 자세한 설명 은 &lt;a href=&quot;test/more&quot;&gt;Test :: More&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="85ea3c732a0cadb4cba11f8084adbc162ad146ff" translate="yes" xml:space="preserve">
          <source>we prevent backtracking and find the count of the longest matching string at each matching starting point like so:</source>
          <target state="translated">역 추적을 방지하고 다음과 같이 일치하는 각 시작점에서 가장 긴 일치 문자열의 수를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="3d0b0b7bc297d97e84595de72ecb8a0030fdd17e" translate="yes" xml:space="preserve">
          <source>we've checked all its derived classes (i.e. before we tried &lt;code&gt;Mother&lt;/code&gt; and &lt;code&gt;MaternalGrandparent&lt;/code&gt; ).</source>
          <target state="translated">우리는 모든 파생 클래스를 확인했습니다 (즉, &lt;code&gt;Mother&lt;/code&gt; 및 &lt;code&gt;MaternalGrandparent&lt;/code&gt; 시도하기 전에 ).</target>
        </trans-unit>
        <trans-unit id="fcb9e7c68cc7aee9b7ae828bf3eb4f0c0ab95fcd" translate="yes" xml:space="preserve">
          <source>weaken</source>
          <target state="translated">weaken</target>
        </trans-unit>
        <trans-unit id="ae27e6a12247433968a2426ceb5f2faec9f64b2d" translate="yes" xml:space="preserve">
          <source>webget</source>
          <target state="translated">webget</target>
        </trans-unit>
        <trans-unit id="79b1646e47722f151fadfe6b4b9cfd75b5507a18" translate="yes" xml:space="preserve">
          <source>week number</source>
          <target state="translated">주 번호</target>
        </trans-unit>
        <trans-unit id="b6894b43bb03af96eabb423701dc0bc9e071a3e0" translate="yes" xml:space="preserve">
          <source>were affected. This leads to spooky, incorrect action at a distance that is hard to debug.</source>
          <target state="translated">영향을 받았다. 이로 인해 디버그하기 어려운 거리에서 짜증나고 잘못된 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0a8fc1dcdcb951afef794f96428b2c2d30d4cbdd" translate="yes" xml:space="preserve">
          <source>were fine, but the hard ones like</source>
          <target state="translated">괜찮 았지만 어려운 사람들은</target>
        </trans-unit>
        <trans-unit id="b3e74349971aeb0151fc1bfbab7d483e124b80fe" translate="yes" xml:space="preserve">
          <source>were merged, so perlce build process comes in</source>
          <target state="translated">perlce 빌드 프로세스가 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="9421eaaa36860a069e3089b1dd32635567692a1f" translate="yes" xml:space="preserve">
          <source>were the command shell, this would probably work better:</source>
          <target state="translated">커맨드 쉘 이었다면 아마도 더 잘 작동 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="a110e6b9a361653a042e3f5dfbac4c6105693789" translate="yes" xml:space="preserve">
          <source>what</source>
          <target state="translated">what</target>
        </trans-unit>
        <trans-unit id="5028edf30c355a53744774edb4e246a65bdda7eb" translate="yes" xml:space="preserve">
          <source>what &lt;code&gt;File::GlobMapper&lt;/code&gt; does.</source>
          <target state="translated">어떤 &lt;code&gt;File::GlobMapper&lt;/code&gt; 않습니다.</target>
        </trans-unit>
        <trans-unit id="b36160c1ec6399ee58f1e1eaed45b1a11a29091d" translate="yes" xml:space="preserve">
          <source>what follows, it just leaves the choice open. Thus, after</source>
          <target state="translated">그 뒤에는 선택의 여지가 남아 있습니다. 따라서 후</target>
        </trans-unit>
        <trans-unit id="235cc5e25df726ef139cc4e3ed273f18953c310e" translate="yes" xml:space="preserve">
          <source>what it does</source>
          <target state="translated">그것이하는 일</target>
        </trans-unit>
        <trans-unit id="9a97de175ae265b931e0f47d8189ba1c158846c3" translate="yes" xml:space="preserve">
          <source>what you want to use to capture the output from a command; for that you should use merely backticks or &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt;, as described in &lt;a href=&quot;perlop#%60STRING%60&quot;&gt;`STRING` in perlop&lt;/a&gt;. Return value of -1 indicates a failure to start the program or an error of the wait(2) system call (inspect $! for the reason).</source>
          <target state="translated">명령의 출력을 캡처하기 위해 사용하려는 것; &lt;a href=&quot;perlop#%60STRING%60&quot;&gt;perlop의`STRING`에&lt;/a&gt; 설명 된대로 백틱 또는 &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt; 만 사용해야합니다 . -1의 반환 값은 프로그램 시작 실패 또는 wait (2) 시스템 호출 오류 (이유로 $!를 검사)를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3926fc849cd226411c2dc28dbb3c1ac9425d41ae" translate="yes" xml:space="preserve">
          <source>what you want to use to capture the output from a command; for that you should use merely backticks or &lt;code&gt;&lt;a href=&quot;qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt;, as described in &lt;a href=&quot;../perlop#%60STRING%60&quot;&gt;`STRING` in perlop&lt;/a&gt;. Return value of -1 indicates a failure to start the program or an error of the wait(2) system call (inspect $! for the reason).</source>
          <target state="translated">명령의 출력을 캡처하기 위해 사용하려는 것; &lt;a href=&quot;../perlop#%60STRING%60&quot;&gt;perlop의`STRING`에&lt;/a&gt; 설명 된대로 백틱 또는 &lt;code&gt;&lt;a href=&quot;qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt; 만 사용해야합니다 . -1의 반환 값은 프로그램 시작 실패 또는 wait (2) 시스템 호출 오류 (이유로 $!를 검사)를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2a01f2e26cea4a9807d9d068afa0bdc36ba5e00e" translate="yes" xml:space="preserve">
          <source>what you're doing, you can use the &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&lt;/code&gt; modifiers to force big- or little-endian byte-order on floating-point values.</source>
          <target state="translated">당신이하고있는 일에, &lt;code&gt;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;&lt;/code&gt; 수정자를 사용하여 부동 소수점 값에서 빅 엔디안 또는 리틀 엔디안 바이트 순서를 강제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d869db7fe62fb07c25a0403ecaea55031744b5fb" translate="yes" xml:space="preserve">
          <source>whatever</source>
          <target state="translated">whatever</target>
        </trans-unit>
        <trans-unit id="021bc9488a6a6118c1c75c3f7a5aeeaa12491ccd" translate="yes" xml:space="preserve">
          <source>whatever falls between &lt;code&gt;\Q&lt;/code&gt; and &lt;code&gt;\E&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;\Q&lt;/code&gt; 와 &lt;code&gt;\E&lt;/code&gt; 사이에있는 모든 것</target>
        </trans-unit>
        <trans-unit id="30603fa9e0f620c305cd627ab0ff138a960c48bd" translate="yes" xml:space="preserve">
          <source>when</source>
          <target state="translated">when</target>
        </trans-unit>
        <trans-unit id="ed6268873901e8209d3ac22fc700c31706eaa9bd" translate="yes" xml:space="preserve">
          <source>when &quot;dumping&quot;; it has nothing to do with $| auto-flush.)</source>
          <target state="translated">&quot;덤핑&quot;할 때; $ |와는 아무런 관련이 없습니다. 자동 세척.)</target>
        </trans-unit>
        <trans-unit id="c89dac7f6e160306ca10f788c9bd6a54efcd1ffc" translate="yes" xml:space="preserve">
          <source>when &lt;code&gt;xsubpp&lt;/code&gt; is invoked with &lt;code&gt;-s foo_&lt;/code&gt; will install a &lt;code&gt;foo_bar&lt;/code&gt; function in Perl, but really call &lt;code&gt;bar(i)&lt;/code&gt; in C. Most of the time, this is the opposite of what you want and failure modes are somewhat obscure, so please avoid this option where possible.</source>
          <target state="translated">&lt;code&gt;xsubpp&lt;/code&gt; 가 &lt;code&gt;-s foo_&lt;/code&gt; 로 호출 되면 foo_ 는 Perl에 &lt;code&gt;foo_bar&lt;/code&gt; 함수를 설치 하지만 실제로 C에서는 &lt;code&gt;bar(i)&lt;/code&gt; 를 호출 합니다 . 대부분의 경우, 이것은 원하는 것과 반대이며 실패 모드는 다소 모호합니다. 가능한 경우 옵션.</target>
        </trans-unit>
        <trans-unit id="75aed76d9314bc923e71101c151f2b2893f266e7" translate="yes" xml:space="preserve">
          <source>when another process is holding the lockfile. This is an experimental feature that is not yet tested very well. This second shell then does not write the history file, does not use the metadata file, and has a different prompt.</source>
          <target state="translated">다른 프로세스가 잠금 파일을 보유하고있을 때. 아직 테스트되지 않은 실험적인 기능입니다. 그런 다음이 두 번째 셸은 기록 파일을 쓰지 않고 메타 데이터 파일을 사용하지 않으며 다른 프롬프트를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="ba1a27d93b87aa252d9684f7f42d0351ba582ec5" translate="yes" xml:space="preserve">
          <source>when necessary.</source>
          <target state="translated">필요할 땐.</target>
        </trans-unit>
        <trans-unit id="3cd9d2e738a8b92221411f890d0e1eb0c5e3b660" translate="yes" xml:space="preserve">
          <source>when the element to return happens to be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">반환 할 요소가 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 일 때 .</target>
        </trans-unit>
        <trans-unit id="7b023844c7b290ca1a038802a6472c7aeafce41c" translate="yes" xml:space="preserve">
          <source>when the element to return happens to be &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">반환 할 요소가 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 일 때 .</target>
        </trans-unit>
        <trans-unit id="938c56ff8ee83ab6578974df30b9d1c7e33fe7dd" translate="yes" xml:space="preserve">
          <source>when the functions are called from within the scope of the &lt;code&gt;&lt;a href=&quot;bytes&quot;&gt;use bytes&lt;/a&gt;&lt;/code&gt; pragma</source>
          <target state="translated">기능은 내에서 호출 할 때의 범위를 &lt;code&gt;&lt;a href=&quot;bytes&quot;&gt;use bytes&lt;/a&gt;&lt;/code&gt; 프라그 마를</target>
        </trans-unit>
        <trans-unit id="8ce6402418c47b212eb07ca370a93108ff150f4a" translate="yes" xml:space="preserve">
          <source>when the imaginary part is zero (otherwise, it would not be called an extension, would it?).</source>
          <target state="translated">허수 부가 0 일 때 (그렇지 않으면 확장이라고 부르지 않겠습니까?)</target>
        </trans-unit>
        <trans-unit id="eb1cef34e0771ae508dd63618b6d7ebc545d708d" translate="yes" xml:space="preserve">
          <source>when this tutorial was written. It has now been split off with &lt;code&gt;pp_unpack&lt;/code&gt; to its own file,</source>
          <target state="translated">이 튜토리얼이 작성되었을 때 이제 &lt;code&gt;pp_unpack&lt;/code&gt; 을 사용하여 자체 파일 로 분리되었습니다 .</target>
        </trans-unit>
        <trans-unit id="ac26161b0187ead053283bca27ee59e832cfa160" translate="yes" xml:space="preserve">
          <source>when you ask for</source>
          <target state="translated">당신이 요청할 때</target>
        </trans-unit>
        <trans-unit id="3e5e701932ff1e08475464ba8b75ee91dc43d41c" translate="yes" xml:space="preserve">
          <source>when you intended</source>
          <target state="translated">당신이 의도했을 때</target>
        </trans-unit>
        <trans-unit id="6e06c432fa349d548f06ebf0f8b460c130ec25ac" translate="yes" xml:space="preserve">
          <source>when you meant</source>
          <target state="translated">네가 의미했을 때</target>
        </trans-unit>
        <trans-unit id="320723f30d494b8eb54e4b744bfd8f4219fbd71c" translate="yes" xml:space="preserve">
          <source>when you meant to say</source>
          <target state="translated">말할 때</target>
        </trans-unit>
        <trans-unit id="0b09f6864ed10d92f6a10d3420ae332e50823d21" translate="yes" xml:space="preserve">
          <source>when you should have said</source>
          <target state="translated">당신이 말했을 때</target>
        </trans-unit>
        <trans-unit id="bfe41b37d5bad835ce1295749ffd97e4c9fffaac" translate="yes" xml:space="preserve">
          <source>when you should have written this:</source>
          <target state="translated">당신이 이것을 써야 할 때 :</target>
        </trans-unit>
        <trans-unit id="46148cc3b4d2b3ac8073f14b0cba7f25ffff54bd" translate="yes" xml:space="preserve">
          <source>where</source>
          <target state="translated">where</target>
        </trans-unit>
        <trans-unit id="ab1c267bd23a7a2761e1a1311799eacd65a53cf8" translate="yes" xml:space="preserve">
          <source>where &quot;ENCODING&quot; must be a valid encoding name that the Encode module recognises.</source>
          <target state="translated">여기서 &quot;ENCODING&quot;은 Encode 모듈이 인식하는 유효한 인코딩 이름이어야합니다.</target>
        </trans-unit>
        <trans-unit id="3f76ee4872ba64c6359656344e5d58fab47ab470" translate="yes" xml:space="preserve">
          <source>where $MAKE is whatever 'make' program you have configured perl to use. Use &quot;perl -V:make&quot; to find out what this is. Some extensions may not provide a testsuite (so &quot;$MAKE test&quot; may not do anything or fail), but most serious ones do.</source>
          <target state="translated">여기서 $ MAKE는 펄이 사용하도록 구성한 'make'프로그램입니다. 이것이 무엇인지 알아 보려면 &quot;perl -V : make&quot;를 사용하십시오. 일부 확장 프로그램은 테스트 슈트를 제공하지 않을 수 있으므로 ( &quot;$ MAKE 테스트&quot;는 아무 것도 수행하지 않거나 실패 할 수 있음) 가장 심각한 확장은 테스트 슈트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c8069144ce0898197e96d2bb7ebc0edbdaca8457" translate="yes" xml:space="preserve">
          <source>where $term is a return value of Term::ReadLine-&amp;gt;new().</source>
          <target state="translated">여기서 $ term은 Term :: ReadLine-&amp;gt; new ()의 반환 값입니다.</target>
        </trans-unit>
        <trans-unit id="b9c15a20c87c2836864971183b1c442723a838ac" translate="yes" xml:space="preserve">
          <source>where $x is either less than -128 or more than 127; the &lt;code&gt;&quot;c&quot;&lt;/code&gt; format is only for encoding native operating system characters (ASCII, EBCDIC, and so on) and not for Unicode characters, so Perl behaved as if you meant</source>
          <target state="translated">여기서 $ x는 -128보다 작거나 127보다 큽니다. &lt;code&gt;&quot;c&quot;&lt;/code&gt; 당신이 의미하는 것처럼 형식은 기본 운영 체제 문자 인코딩입니다 (ASCII는 EBCDIC는, 등) 펄은 행동이 아니라 유니 코드 문자, 그래서</target>
        </trans-unit>
        <trans-unit id="5bbc43aec00d96c64d05508ffb3bbad3e39afaec" translate="yes" xml:space="preserve">
          <source>where $x is either less than 0 or more than 255. However, &lt;code&gt;U0&lt;/code&gt; -mode expects all values to fall in the interval [0, 255], so Perl behaved as if you meant:</source>
          <target state="translated">여기서 $ x는 0보다 작거나 255보다 큽니다. 그러나 &lt;code&gt;U0&lt;/code&gt; 모드는 모든 값이 [0, 255] 간격에있을 것으로 예상하므로 Perl은 다음과 같은 의미로 동작합니다.</target>
        </trans-unit>
        <trans-unit id="00bca38c6c6b0a3593705b287c03db33903d5e5f" translate="yes" xml:space="preserve">
          <source>where $x is either less than 0 or more than 255; the &lt;code&gt;&quot;C&quot;&lt;/code&gt; format is only for encoding native operating system characters (ASCII, EBCDIC, and so on) and not for Unicode characters, so Perl behaved as if you meant</source>
          <target state="translated">여기서 $ x는 0보다 작거나 255보다 큽니다. &lt;code&gt;&quot;C&quot;&lt;/code&gt; 형식은 당신이 의미하는 것처럼 (ASCII, EBCDIC가 등) 및 유니 코드 문자를 들면, 펄 있도록 행동 기본 운영 체제 문자 인코딩입니다</target>
        </trans-unit>
        <trans-unit id="890f9b49db55ce1098a844385610bbb13debaa4c" translate="yes" xml:space="preserve">
          <source>where 0x0400 stands for &lt;code&gt;U+0400&lt;/code&gt; , CYRILLIC CAPITAL LETTER IE WITH GRAVE.</source>
          <target state="translated">여기서 0x0400은 &lt;code&gt;U+0400&lt;/code&gt; , CYRILLIC CAPITAL LETTER IE WITH GRAVE를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="825d5d6d780f8829ebcd8a7016c279905b219a90" translate="yes" xml:space="preserve">
          <source>where 7E is the hexadecimal ASCII code point for &quot;~&quot;. Here is an example of decoding such a URL in any EBCDIC code page:</source>
          <target state="translated">여기서 7E는 &quot;~&quot;의 16 진 ASCII 코드 포인트입니다. 다음은 EBCDIC 코드 페이지에서 이러한 URL을 디코딩하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="d4809a830fe1a3429edeff7f9faf0dee554dbec4" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;$parser&lt;/code&gt; is a reference to the parser object, &lt;code&gt;$text&lt;/code&gt; is the text-string encountered, and &lt;code&gt;$ptree_node&lt;/code&gt; is a reference to the current node in the parse-tree (usually an interior-sequence object or else the top-level node of the parse-tree).</source>
          <target state="translated">여기서 &lt;code&gt;$parser&lt;/code&gt; 는 파서 객체에 대한 참조이고 &lt;code&gt;$text&lt;/code&gt; 는 발견 된 텍스트 문자열이며 &lt;code&gt;$ptree_node&lt;/code&gt; 는 구문 분석 트리의 현재 노드에 대한 참조입니다 (일반적으로 내부 순서 객체 또는 최상위 노드). 구문 분석 트리).</target>
        </trans-unit>
        <trans-unit id="d298264d5947d99205d766cae90ed2313035af45" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;$parser&lt;/code&gt; is a reference to the parser object, and &lt;code&gt;$ptree&lt;/code&gt; is a reference to the parse-tree object.</source>
          <target state="translated">여기서 &lt;code&gt;$parser&lt;/code&gt; 는 구문 분석기 오브젝트에 대한 참조 이고 &lt;code&gt;$ptree&lt;/code&gt; 는 구문 분석 트리 오브젝트에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="5957a8e4bc7c51d1071eb22f8fe1b48116af9153" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;$parser&lt;/code&gt; is a reference to the parser object, and &lt;code&gt;$sequence&lt;/code&gt; is a reference to the interior-sequence object. [</source>
          <target state="translated">여기서 &lt;code&gt;$parser&lt;/code&gt; 는 파서 객체에 대한 참조 이고 &lt;code&gt;$sequence&lt;/code&gt; 는 내부 시퀀스 객체에 대한 참조입니다. [</target>
        </trans-unit>
        <trans-unit id="15d410b2ce2184b4347be136da68a7719dc0ad85" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;$source&lt;/code&gt; is the filespec of the file being installed. &lt;code&gt;$target&lt;/code&gt; is where it is being installed to, and &lt;code&gt;$uninstalled&lt;/code&gt; is any shadow file that is in &lt;code&gt;@INC&lt;/code&gt; or &lt;code&gt;$ENV{PERL5LIB}&lt;/code&gt; or other standard locations, and &lt;code&gt;$pattern&lt;/code&gt; is the pattern that caused a source file to be skipped. In future more keys will be added, such as to show created directories, however this requires changes in other modules and must therefore wait.</source>
          <target state="translated">여기서 &lt;code&gt;$source&lt;/code&gt; 는 설치중인 파일의 파일 사양입니다. &lt;code&gt;$target&lt;/code&gt; 은 설치 될 위치이며 &lt;code&gt;$uninstalled&lt;/code&gt; 는 &lt;code&gt;@INC&lt;/code&gt; 또는 &lt;code&gt;$ENV{PERL5LIB}&lt;/code&gt; 또는 기타 표준 위치에 있는 섀도 파일 이며 &lt;code&gt;$pattern&lt;/code&gt; 은 소스 파일을 건너 뛴 패턴입니다. 앞으로 생성 된 디렉토리를 표시하는 등의 추가 키가 추가 될 예정이지만 다른 모듈을 변경해야하므로 기다려야합니다.</target>
        </trans-unit>
        <trans-unit id="a731b563e701bcb16a123ecab85071d224c107aa" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;$where_to_export&lt;/code&gt; is an integer telling how far up the calling stack to export your symbols, and &lt;code&gt;@what_to_export&lt;/code&gt; is an array telling what symbols *to* export (usually this is &lt;code&gt;@_&lt;/code&gt; ). The &lt;code&gt;$package&lt;/code&gt; argument is currently unused.</source>
          <target state="translated">여기서 &lt;code&gt;$where_to_export&lt;/code&gt; 는 심볼을 내보내는 호출 스택까지의 거리를 나타내는 정수이고 &lt;code&gt;@what_to_export&lt;/code&gt; 는 * to * 내보내기 할 심볼을 나타내는 배열입니다 (보통이 값은 &lt;code&gt;@_&lt;/code&gt; ). &lt;code&gt;$package&lt;/code&gt; 인수는 현재 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="48e1c4094f5de010428575d8622f327516bc33ae" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;HERE&lt;/code&gt; can be replaced by other identifiers like with normal Perl HERE-docs. All details below about the typemap textual format remain valid.</source>
          <target state="translated">여기서 &lt;code&gt;HERE&lt;/code&gt; 는 일반적인 Perl HERE-docs와 같은 다른 식별자로 대체 될 수 있습니다. 타입 맵 텍스트 형식에 대한 아래의 모든 세부 사항은 유효합니다.</target>
        </trans-unit>
        <trans-unit id="721c549e68ff19e2994566a74f0b393f57d254d1" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;MyParser&lt;/code&gt; is some subclass of &lt;b&gt;Pod::Parser&lt;/b&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;MyParser&lt;/code&gt; 는 &lt;b&gt;Pod :: Parser&lt;/b&gt; 의 일부 서브 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="b03bee177daa8ad34db5c35f4571b92ff18e039c" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;SP&lt;/code&gt; is the macro that represents the local copy of the stack pointer, and &lt;code&gt;num&lt;/code&gt; is the number of elements the stack should be extended by.</source>
          <target state="translated">여기서 &lt;code&gt;SP&lt;/code&gt; 는 스택 포인터의 로컬 복사본을 나타내는 매크로이고 &lt;code&gt;num&lt;/code&gt; 은 스택을 확장해야하는 요소의 수입니다.</target>
        </trans-unit>
        <trans-unit id="de39703cfc1e976397e4c498b4e76e18c8f99017" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;a&lt;/code&gt; is the</source>
          <target state="translated">여기서 &lt;code&gt;a&lt;/code&gt; 은 IS</target>
        </trans-unit>
        <trans-unit id="6950fd3c6bf4eda6d69d7afe08226888f67c407d" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;function&lt;/code&gt; is the name of the function you want to memoize, or a reference to it. &lt;code&gt;memoize&lt;/code&gt; returns a reference to the new, memoized version of the function, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on a non-fatal error. At present, there are no non-fatal errors, but there might be some in the future.</source>
          <target state="translated">여기서 &lt;code&gt;function&lt;/code&gt; 은 메모 할 함수의 이름 또는 참조입니다. &lt;code&gt;memoize&lt;/code&gt; 는 새로운 메모리 버전의 함수에 대한 참조를 반환하거나 치명적이지 않은 오류에 대해서는 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환합니다 . 현재 치명적이지 않은 오류는 없지만 앞으로 몇 가지 오류가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9baeb27f249365fedd4a037a93595125d9a6014e" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;rho&lt;/code&gt; is the distance to the origin, and &lt;code&gt;theta&lt;/code&gt; the angle between the vector and the</source>
          <target state="translated">여기서 &lt;code&gt;rho&lt;/code&gt; 는 원점까지의 거리이며, &lt;code&gt;theta&lt;/code&gt; 는 벡터와</target>
        </trans-unit>
        <trans-unit id="fd9e76180b06bd2a44ffe663c1ff849e0a103ca7" translate="yes" xml:space="preserve">
          <source>where FALLBACK can take any of the three values TRUE, FALSE, or UNDEF. If you do not set any FALLBACK value when using OVERLOAD, it defaults to UNDEF. FALLBACK is not used except when one or more functions using OVERLOAD have been defined. Please see &lt;a href=&quot;overload#fallback&quot;&gt;fallback in overload&lt;/a&gt; for more details.</source>
          <target state="translated">여기서 FALLBACK은 세 가지 값 TRUE, FALSE 또는 UNDEF 중 하나를 사용할 수 있습니다. OVERLOAD를 사용할 때 FALLBACK 값을 설정하지 않으면 기본값은 UNDEF입니다. OVERLOAD를 사용하는 하나 이상의 기능이 정의 된 경우를 제외하고는 FALLBACK이 사용되지 않습니다. 자세한 내용 &lt;a href=&quot;overload#fallback&quot;&gt;은 과부하 폴백&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="50396b7e08b271e8034d662ba4fd67f410cb1b19" translate="yes" xml:space="preserve">
          <source>where a more complete solution would split the URL into components and apply a full s/// substitution only to the appropriate parts.</source>
          <target state="translated">더 완벽한 솔루션은 URL을 구성 요소로 나누고 적절한 부분에만 전체 s /// 대체를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="21585635f4365441aa2484d0f4019c953a7d7b86" translate="yes" xml:space="preserve">
          <source>where chr(0xff) is expected but the test fails because the result is chr(0xff). Exactly.</source>
          <target state="translated">여기서 chr (0xff)는 예상되지만 결과는 chr (0xff)이므로 테스트에 실패합니다. 바로 그거죠.</target>
        </trans-unit>
        <trans-unit id="16f78d439c89dcc67cc6d31385ff3dcec533675f" translate="yes" xml:space="preserve">
          <source>where each successive 'list add' option will push the value of add into array ref $list-&amp;gt;{'add'}. The result would be like</source>
          <target state="translated">각각의 연속적인 'list add'옵션은 add의 값을 array ref $ list-&amp;gt; { 'add'}로 푸시합니다. 결과는 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="517c0898eef6d5914aa381031eb301a948ecc075" translate="yes" xml:space="preserve">
          <source>where such changes can be applied by the means of cherry-picking from blead.</source>
          <target state="translated">이러한 변화는 블리드에서 체리 따기 방법으로 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1ba074422bf23c3944014acd8f065e730791214" translate="yes" xml:space="preserve">
          <source>where that number is the command number, and which you'd use to access with the built-in &lt;b&gt;csh&lt;/b&gt;-like history mechanism. For example, &lt;code&gt;!17&lt;/code&gt; would repeat command number 17. The depth of the angle brackets indicates the nesting depth of the debugger. You could get more than one set of brackets, for example, if you'd already at a breakpoint and then printed the result of a function call that itself has a breakpoint, or you step into an expression via &lt;code&gt;s/n/t
expression&lt;/code&gt; command.</source>
          <target state="translated">여기서 해당 번호는 명령 번호이며 내장 된 &lt;b&gt;csh&lt;/b&gt; 와 같은 히스토리 메커니즘 으로 액세스하는 데 사용됩니다 . 예를 들어 &lt;code&gt;!17&lt;/code&gt; 은 명령 번호 17 을 반복합니다. 꺾쇠 괄호의 깊이는 디버거의 중첩 깊이를 나타냅니다. 예를 들어, 이미 브레이크 포인트에 있고 그 자체에 브레이크 포인트가있는 함수 호출의 결과를 인쇄했거나 &lt;code&gt;s/n/t expression&lt;/code&gt; 명령을 통해 표현식으로 들어가는 경우, 둘 이상의 대괄호 세트를 얻을 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="fe3cffb107c47b95f0ae454e3de2e7e1743bb5ce" translate="yes" xml:space="preserve">
          <source>where the &lt;code&gt;&quot;|&quot;&lt;/code&gt; is a binary operator with an operand on the right, but no operand on the left.</source>
          <target state="translated">어디에 &lt;code&gt;&quot;|&quot;&lt;/code&gt; 오른쪽에는 피연산자가 있지만 왼쪽에는 피연산자가없는 이진 연산자입니다.</target>
        </trans-unit>
        <trans-unit id="b244c23995363daf148f79037f34977ba5711e52" translate="yes" xml:space="preserve">
          <source>where the &lt;code&gt;TYPEMAP&lt;/code&gt; keyword must appear in the first column of a new line.</source>
          <target state="translated">여기서 &lt;code&gt;TYPEMAP&lt;/code&gt; 키워드는 새 줄의 첫 번째 열에 나타나야합니다.</target>
        </trans-unit>
        <trans-unit id="764e081905d06edddf30c836b21ee0f9eb49e89c" translate="yes" xml:space="preserve">
          <source>where the &lt;code&gt;minlen&lt;/code&gt; would be 3 but &lt;code&gt;minlenret&lt;/code&gt; would only be 2 as the \d is required to match but is not actually included in the matched content. This distinction is particularly important as the substitution logic uses the &lt;code&gt;minlenret&lt;/code&gt; to tell if it can do in-place substitutions (these can result in considerable speed-up).</source>
          <target state="translated">여기서 &lt;code&gt;minlen&lt;/code&gt; 은 3이지만 &lt;code&gt;minlenret&lt;/code&gt; 은 2 일뿐 입니다. \ d는 일치해야하지만 실제로는 일치하는 내용에 포함되지 않습니다. 대체 로직은 &lt;code&gt;minlenret&lt;/code&gt; 을 사용하여 내부 대체를 수행 할 수 있는지 여부를 알려주기 때문에 특히 중요합니다 ( 이로 인해 상당한 속도 향상이 발생할 수 있음).</target>
        </trans-unit>
        <trans-unit id="e11e55dd4712573d987efd1c0884f0c120edda61" translate="yes" xml:space="preserve">
          <source>where the Perl equivalent of &lt;code&gt;register_fatal&lt;/code&gt; and the callback it registers, &lt;code&gt;pcb1&lt;/code&gt; , might look like this</source>
          <target state="translated">여기서 &lt;code&gt;register_fatal&lt;/code&gt; 에 해당하는 Perl과 등록한 콜백 &lt;code&gt;pcb1&lt;/code&gt; 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="34cc28c0ed6b3b975c1f8b2f5bfccf3f2b674b4a" translate="yes" xml:space="preserve">
          <source>where the first argument, an &lt;code&gt;SV*&lt;/code&gt; , must be a reference, and the second argument is a stash. The returned &lt;code&gt;SV*&lt;/code&gt; can now be used in the same way as any other SV.</source>
          <target state="translated">여기서 첫 번째 인수 인 &lt;code&gt;SV*&lt;/code&gt; 는 참조 여야하고 두 번째 인수는 숨김입니다. 반환 된 &lt;code&gt;SV*&lt;/code&gt; 는 이제 다른 SV와 같은 방식으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb8f1012228e6574e355ca23612690ce9ced4433" translate="yes" xml:space="preserve">
          <source>where the format expects to process a byte (a character with a value below 256), but a higher value was provided instead. Perl uses the value modulus 256 instead, as if you had provided:</source>
          <target state="translated">여기서 형식은 바이트 (256 미만의 값을 갖는 문자)를 처리 할 것으로 예상되지만 대신 더 높은 값이 제공되었습니다. Perl은 다음과 같이 값 계수 256을 대신 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b51b446492bdddf5835c8b7127ee3a8fcffa16ed" translate="yes" xml:space="preserve">
          <source>where the format expects to process a sequence of bytes (character with a value below 256), but some of the characters had a higher value. Perl uses the character values modulus 256 instead, as if you had provided:</source>
          <target state="translated">여기서 형식은 일련의 바이트 (256 미만의 값을 갖는 문자)를 처리하지만 일부 문자는 더 높은 값을가집니다. Perl은 다음과 같이 문자 값 계수 256을 대신 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5c49be26fe2412d08b959e58ce62ecd11e8effd9" translate="yes" xml:space="preserve">
          <source>where these arguments mean:</source>
          <target state="translated">이 논쟁의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4fe303f9adde4840e097ed0d238372b72ff5d199" translate="yes" xml:space="preserve">
          <source>where those dot files live</source>
          <target state="translated">그 도트 파일이있는 곳</target>
        </trans-unit>
        <trans-unit id="00a755e878e51b6d3d95aae065147ee2272798c2" translate="yes" xml:space="preserve">
          <source>where you'd otherwise have to write</source>
          <target state="translated">당신이 달리 써야 할 곳</target>
        </trans-unit>
        <trans-unit id="09c0979062616fd0606b29296df335c67d5531c0" translate="yes" xml:space="preserve">
          <source>whereupon we might see something like this, with each pair of hex digits corresponding to a byte:</source>
          <target state="translated">여기서 우리는 다음과 같은 것을 볼 수 있습니다. 각 16 진수 숫자 쌍은 바이트에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="6fac826754ebef5d0de7380bb2ebdf79ac73e626" translate="yes" xml:space="preserve">
          <source>whether the contents are interpreted as a signed or unsigned number,</source>
          <target state="translated">내용이 부호있는 숫자 또는 부호없는 숫자로 해석되는지 여부</target>
        </trans-unit>
        <trans-unit id="dc2033256fe72f3be5253a7be85085b830e059f5" translate="yes" xml:space="preserve">
          <source>whether the next byte is in the range 0x80 - 0xBF. If so, the parser may conclude that this file is in UTF-8, and all highbit sequences in the file should be assumed to be UTF-8. Otherwise the parser should treat the file as being in CP-1252. (A better check, and which works on EBCDIC platforms as well, is to pass a copy of the sequence to &lt;a href=&quot;utf8&quot;&gt;utf8::decode()&lt;/a&gt; which performs a full validity check on the sequence and returns TRUE if it is valid UTF-8, FALSE otherwise. This function is always pre-loaded, is fast because it is written in C, and will only get called at most once, so you don't need to avoid it out of performance concerns.) In the unlikely circumstance that the first highbit sequence in a truly non-UTF-8 file happens to appear to be UTF-8, one can cater to our heuristic (as well as any more intelligent heuristic) by prefacing that line with a comment line containing a highbit sequence that is clearly</source>
          <target state="translated">다음 바이트가 0x80-0xBF 범위에 있는지 여부 그렇다면 파서는이 파일이 UTF-8이라고 결론 내릴 수 있으며 파일의 모든 고 비트 시퀀스는 UTF-8로 가정해야합니다. 그렇지 않으면 파서는 파일을 CP-1252에있는 것으로 간주해야합니다. (더 나은 확인 및 EBCDIC 플랫폼에서도 작동하는 것은 시퀀스 사본을 &lt;a href=&quot;utf8&quot;&gt;utf8 :: decode ()&lt;/a&gt; 에 전달하는 것입니다.시퀀스에서 전체 유효성 검사를 수행하고 UTF-8이 유효하면 TRUE를, 그렇지 않으면 FALSE를 반환합니다. 이 함수는 항상 사전로드되어 있고 C로 작성되기 때문에 빠르며 최대 한 번만 호출되므로 성능 문제를 피할 필요가 없습니다.) 실제로 비 UTF-8 파일에서 UTF-8 인 것처럼 보이면 명확하게 높은 비트 시퀀스를 포함하는 주석 줄로 해당 줄을 미리 지정하여 휴리스틱 (더 지능적인 휴리스틱)을 제공 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="13f9423890a306b627963ea70ef49e8541a4438e" translate="yes" xml:space="preserve">
          <source>whether we should try to change or remove those dot files</source>
          <target state="translated">해당 도트 파일을 변경하거나 제거해야하는지 여부</target>
        </trans-unit>
        <trans-unit id="ed04ff4dabf1e2d4cd6b89136c2b24dec27ecca4" translate="yes" xml:space="preserve">
          <source>which</source>
          <target state="translated">which</target>
        </trans-unit>
        <trans-unit id="d060cbd0fbb1156378e849bb6c04d6e687e74342" translate="yes" xml:space="preserve">
          <source>which can also be done with &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map()&lt;/a&gt;&lt;/code&gt; which is made to transform one list into another:</source>
          <target state="translated">하나의 목록을 다른 목록으로 변환하기 위해 만들어진 &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map()&lt;/a&gt;&lt;/code&gt; 도 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="679cb19369252215832643aae001a33e00c3edb8" translate="yes" xml:space="preserve">
          <source>which can just be converted to:</source>
          <target state="translated">다음과 같이 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1058597fc80ec1ae6c9468976c2082b39dc74418" translate="yes" xml:space="preserve">
          <source>which can print filenames terminated by the null character, you can say this:</source>
          <target state="translated">널 문자로 끝나는 파일 이름을 인쇄 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a1bf5f9e60cb26d6cb10d695574f7486a7350a5" translate="yes" xml:space="preserve">
          <source>which can work together</source>
          <target state="translated">함께 일할 수있는</target>
        </trans-unit>
        <trans-unit id="26e6474c54d74f5e1b54fbb84567108ec9ec0be7" translate="yes" xml:space="preserve">
          <source>which contains a list of newXS() calls near the end. Removing unnecessary calls, and rerunning</source>
          <target state="translated">마지막에 newXS () 호출 목록이 들어 있습니다. 불필요한 통화 제거 및 재실행</target>
        </trans-unit>
        <trans-unit id="3ba7f1a2c7d9e13feaebe2336a9a9752e948dcc6" translate="yes" xml:space="preserve">
          <source>which contains the profiling data collected during the execution.</source>
          <target state="translated">여기에는 실행 중에 수집 된 프로파일 링 데이터가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="209bf9b2c21856efbe58794a447fa26435ea0055" translate="yes" xml:space="preserve">
          <source>which could also be written this way, using a trick that's come to be known as the Schwartzian Transform:</source>
          <target state="translated">Schwartzian Transform이라고 알려진 트릭을 사용하여 이러한 방식으로 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="75ba4f37004a47ec33e2d83893fc18c49f7a2c2b" translate="yes" xml:space="preserve">
          <source>which did not load a particular DLL yet. This is why the DLLs are mapped to the shared memory region.</source>
          <target state="translated">아직 특정 DLL을로드하지 않았습니다. 이것이 DLL이 공유 메모리 영역에 매핑되는 이유입니다.</target>
        </trans-unit>
        <trans-unit id="7b963e7a5bc43a79a319cd65245b0963a9a74082" translate="yes" xml:space="preserve">
          <source>which does nothing, but succeeds on all the &quot;usual&quot; build targets. To do so, use</source>
          <target state="translated">아무것도하지 않지만 모든 &quot;일반적인&quot;빌드 대상에서 성공합니다. 그렇게하려면</target>
        </trans-unit>
        <trans-unit id="1e68ca264c19e5e1287272ae8a0a048239c69afc" translate="yes" xml:space="preserve">
          <source>which has a length of 43. So, the properly padded version is</source>
          <target state="translated">길이는 43입니다. 따라서 올바르게 패딩 된 버전은</target>
        </trans-unit>
        <trans-unit id="97b9b7ce1f9f8564271626441b5ed04c89fe2ee5" translate="yes" xml:space="preserve">
          <source>which has the short form</source>
          <target state="translated">짧은 형태를 가진</target>
        </trans-unit>
        <trans-unit id="cf2897e01293c7352f75dce51f4052d41ff51799" translate="yes" xml:space="preserve">
          <source>which includes newly-installed via &lt;code&gt;Bundle::OS2_default&lt;/code&gt; modules. Doing testing via &lt;code&gt;CPAN.pm&lt;/code&gt; is going to be painfully slow, since it statically links a new executable per XS extension.</source>
          <target state="translated">여기에는 &lt;code&gt;Bundle::OS2_default&lt;/code&gt; 모듈을 통해 새로 설치된 것이 포함됩니다 . &lt;code&gt;CPAN.pm&lt;/code&gt; 을 통한 테스트 는 XS 확장마다 새로운 실행 파일을 정적으로 연결하기 때문에 매우 느리게 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="740279f94d278254c20a1964b766588db7905a52" translate="yes" xml:space="preserve">
          <source>which interact with the memory allocator in other ways than via malloc(), realloc(), free(), calloc(), sbrk() and brk();</source>
          <target state="translated">malloc (), realloc (), free (), calloc (), sbrk () 및 brk ()를 통해 다른 방법으로 메모리 할당 자와 상호 작용합니다.</target>
        </trans-unit>
        <trans-unit id="27e6eae0fd902584be95e5d4c59ccdf92b2c93d3" translate="yes" xml:space="preserve">
          <source>which is Perl shorthand for the more explicitly written version:</source>
          <target state="translated">보다 명확하게 작성된 버전의 Perl 속기입니다.</target>
        </trans-unit>
        <trans-unit id="e2c5c74f3c46665187c755c53e173135dab99bf8" translate="yes" xml:space="preserve">
          <source>which is also expressed by this formula:</source>
          <target state="translated">이 공식으로도 표현됩니다.</target>
        </trans-unit>
        <trans-unit id="04c6ac4120301d7049af98011b0e572414db64b0" translate="yes" xml:space="preserve">
          <source>which is equivalent to</source>
          <target state="translated">어느 것이</target>
        </trans-unit>
        <trans-unit id="16a66c1b8256121eec60a422104c678c527a1b68" translate="yes" xml:space="preserve">
          <source>which is even the same as</source>
          <target state="translated">그것은 심지어</target>
        </trans-unit>
        <trans-unit id="40217363f21b2e6fa15982c559837fa626b0eb67" translate="yes" xml:space="preserve">
          <source>which is exactly what we had defined for negative real numbers above. The &lt;code&gt;&lt;a href=&quot;../functions/sqrt&quot;&gt;sqrt&lt;/a&gt;&lt;/code&gt; returns only one of the solutions: if you want the both, use the &lt;code&gt;root&lt;/code&gt; function.</source>
          <target state="translated">위의 음의 실수로 정의한 것입니다. &lt;code&gt;&lt;a href=&quot;../functions/sqrt&quot;&gt;sqrt&lt;/a&gt;&lt;/code&gt; 솔루션의 한 반환 : 당신이 모두를 원하는 경우 사용 &lt;code&gt;root&lt;/code&gt; 기능을.</target>
        </trans-unit>
        <trans-unit id="41660e5f3a05c257d71cd236ed7137b3831af720" translate="yes" xml:space="preserve">
          <source>which is generated from</source>
          <target state="translated">에서 생성 된</target>
        </trans-unit>
        <trans-unit id="ed4894b8ab4c596c6c6382023f8f4837da06efce" translate="yes" xml:space="preserve">
          <source>which is hard-wired to replace all occurrences of the string &lt;code&gt;&quot;Joe&quot;&lt;/code&gt; to &lt;code&gt;&quot;Jim&quot;&lt;/code&gt; . Not particularly Useful, but it is the first example and I wanted to keep it simple.</source>
          <target state="translated">&lt;code&gt;&quot;Joe&quot;&lt;/code&gt; 문자열 을 &lt;code&gt;&quot;Jim&quot;&lt;/code&gt; 문자열로 대체하기 위해 배선되어 있습니다. 특히 유용하지는 않지만 첫 번째 예이며 간단하게 유지하고 싶었습니다.</target>
        </trans-unit>
        <trans-unit id="a4f1633dff7d510a448e9aaeeb40cb63e6e279d1" translate="yes" xml:space="preserve">
          <source>which is not, consequently, deparsed correctly.</source>
          <target state="translated">결과적으로 올바르게 파싱되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d53450b0fdca8bc7a9a33283360f4cc8874d6819" translate="yes" xml:space="preserve">
          <source>which is presumably easier to read than the old way:</source>
          <target state="translated">이전 방식보다 읽기가 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="590e9b690bb3d4c0ee4fe08d74808195b747676b" translate="yes" xml:space="preserve">
          <source>which is probably not what you were expecting. Unfortunately at least one reasonably common and modern C compiler does &quot;real backward compatibility&quot; here, in AIX that is what still happens even though the rest of the AIX compiler is very happily C89.</source>
          <target state="translated">아마 당신이 기대했던 것이 아닙니다. 불행히도 적어도 하나의 합리적이고 현대적인 C 컴파일러는 여기서 &quot;실제로 이전 버전과의 호환성&quot;을 수행합니다. AIX에서는 나머지 AIX 컴파일러가 매우 행복하게 C89 인 경우에도 여전히 발생합니다.</target>
        </trans-unit>
        <trans-unit id="29eb09005f5e9aeeb936021e842907d6266dcfda" translate="yes" xml:space="preserve">
          <source>which is ready to be printed.</source>
          <target state="translated">인쇄 할 준비가되었습니다.</target>
        </trans-unit>
        <trans-unit id="457319eaa9e4f3b728ed192e5fdb2e515988f305" translate="yes" xml:space="preserve">
          <source>which is the correct answer. This example illustrates that it is important not only to match what is desired, but to reject what is not desired.</source>
          <target state="translated">정답입니다. 이 예제는 원하는 것을 일치시킬뿐만 아니라 원하지 않는 것을 거부하는 것이 중요 함을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="2b2a157cb124d5116a790751a46e4a73627b6581" translate="yes" xml:space="preserve">
          <source>which is true (&lt;code&gt;&lt;a href=&quot;../functions/abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt; has the regular meaning for real number, i.e. stands for the absolute value). This example explains why the norm of &lt;code&gt;z&lt;/code&gt; is noted &lt;code&gt;&lt;a href=&quot;../functions/abs&quot;&gt;abs(z)&lt;/a&gt;&lt;/code&gt;: it extends the &lt;code&gt;&lt;a href=&quot;../functions/abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt; function to complex numbers, yet is the regular &lt;code&gt;&lt;a href=&quot;../functions/abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt; we know when the complex number actually has no imaginary part... This justifies</source>
          <target state="translated">이는 참입니다 ( &lt;code&gt;&lt;a href=&quot;../functions/abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt; 는 실수에 대한 일반적인 의미, 즉 절대 값을 나타냄). 이 예제는 &lt;code&gt;z&lt;/code&gt; 의 규범이 &lt;code&gt;&lt;a href=&quot;../functions/abs&quot;&gt;abs(z)&lt;/a&gt;&lt;/code&gt; 언급 된 이유를 설명합니다 . &lt;code&gt;&lt;a href=&quot;../functions/abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt; 함수를 복소수로 확장 하지만 복소수가 실제로 허수 부분을 갖지 않을 때 알고 있는 규칙적인 &lt;code&gt;&lt;a href=&quot;../functions/abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt; ...</target>
        </trans-unit>
        <trans-unit id="3080d1b7e175b0f68ccca8d1ffcce6a17814f888" translate="yes" xml:space="preserve">
          <source>which is visible in other functions called from that subroutine</source>
          <target state="translated">해당 서브 루틴에서 호출 된 다른 기능에서 볼 수 있습니다</target>
        </trans-unit>
        <trans-unit id="f78cd391c699a6564a6185a15b2c00459cb4b5f7" translate="yes" xml:space="preserve">
          <source>which lasts until the end of that BLOCK.</source>
          <target state="translated">해당 블록이 끝날 때까지 지속됩니다.</target>
        </trans-unit>
        <trans-unit id="400ae171fcca992b111ee0c9eaa8e6bbbbb647ec" translate="yes" xml:space="preserve">
          <source>which lasts until the end of that BLOCK. Note that this doesn't mean everything is an integer, merely that Perl will use integer operations for arithmetic, comparison, and bitwise operators. For example, even under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; , if you take the &lt;code&gt;&lt;a href=&quot;functions/sqrt&quot;&gt;sqrt(2)&lt;/a&gt;&lt;/code&gt;, you'll still get &lt;code&gt;1.4142135623731&lt;/code&gt; or so.</source>
          <target state="translated">해당 블록이 끝날 때까지 지속됩니다. 이것이 모든 것이 정수임을 의미하는 것은 아니며, Perl은 산술, 비교 및 ​​비트 연산자에 정수 연산을 사용할 것입니다. 예를 들어, 심지어에서 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; 당신이 가지고가는 경우에, &lt;code&gt;&lt;a href=&quot;functions/sqrt&quot;&gt;sqrt(2)&lt;/a&gt;&lt;/code&gt; , 당신은 여전히거야 &lt;code&gt;1.4142135623731&lt;/code&gt; 정도.</target>
        </trans-unit>
        <trans-unit id="c45a01f777cdc33148420b0a627621b88968ca28" translate="yes" xml:space="preserve">
          <source>which looks like your module is doing something wrong. Instead, you want to put the blame on the user, and say this:</source>
          <target state="translated">모듈이 잘못하고있는 것 같습니다. 대신 사용자에게 책임을 묻고 다음과 같이 말하십시오.</target>
        </trans-unit>
        <trans-unit id="910ece59a1ee7a779c7904607756d8ac6f43840e" translate="yes" xml:space="preserve">
          <source>which makes Configure to use the &lt;code&gt;nm&lt;/code&gt; tool when scanning for library symbols, which usually is not done in AIX.</source>
          <target state="translated">라이브러리 심볼을 스캔 할 때 &lt;code&gt;nm&lt;/code&gt; 도구 를 사용하도록 구성합니다. 일반적으로 AIX에서는 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2d3700f0082a2cd4c6079cbe90c96db947b50f48" translate="yes" xml:space="preserve">
          <source>which makes the intention more clear.</source>
          <target state="translated">의도를 더 명확하게합니다.</target>
        </trans-unit>
        <trans-unit id="8cd3d9060c1ace30dd6e2d6262dfd40d2021cad0" translate="yes" xml:space="preserve">
          <source>which may be useful for debugging a program that uses &lt;code&gt;Term::ReadLine&lt;/code&gt; itself. Do not forget to detach your shell from the TTY in the window that corresponds to</source>
          <target state="translated">&lt;code&gt;Term::ReadLine&lt;/code&gt; 자체 를 사용하는 프로그램을 디버깅하는 데 유용 할 수 있습니다 . 해당 창에서 쉘을 TTY에서 분리하는 것을 잊지 마십시오</target>
        </trans-unit>
        <trans-unit id="7e2010dc06ea0515288724e36b214acf56509e41" translate="yes" xml:space="preserve">
          <source>which may modify the second input argument.</source>
          <target state="translated">두 번째 입력 인수를 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eee2fd622722c8b192547f36dd5b9891b7a1ad1e" translate="yes" xml:space="preserve">
          <source>which means</source>
          <target state="translated">그 의미는</target>
        </trans-unit>
        <trans-unit id="04a52cf2a6a5e0c79d4fd67cec9d2eb15a88cc21" translate="yes" xml:space="preserve">
          <source>which outputs</source>
          <target state="translated">어떤 출력</target>
        </trans-unit>
        <trans-unit id="3f62e72ff87682e720abfa0dc12f99261d01428f" translate="yes" xml:space="preserve">
          <source>which pinpoints the real problem. Finally the script can now be modified to fix the original problem by destroying the API object before the untie:</source>
          <target state="translated">실제 문제를 정확히 지적합니다. 마지막으로 스크립트를 풀기 전에 API 객체를 제거하여 원래 문제를 해결하도록 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac6415ae9e2075f760e53b307b58defa828d2b3f" translate="yes" xml:space="preserve">
          <source>which prints</source>
          <target state="translated">인쇄</target>
        </trans-unit>
        <trans-unit id="bb6c88a0a4a00ee65fac2ab2a88d44234ed99c16" translate="yes" xml:space="preserve">
          <source>which prints (on my machine):</source>
          <target state="translated">어느 것이 (내 기계에) 인쇄됩니까?</target>
        </trans-unit>
        <trans-unit id="c6aa678d657ea6708638daf467b4e464862338f7" translate="yes" xml:space="preserve">
          <source>which probably isn't what you intended (the &lt;code&gt;'???'&lt;/code&gt; is a sign that perl optimized away a constant value).</source>
          <target state="translated">아마도 당신이 의도 한 것이 아닐 것입니다 ( &lt;code&gt;'???'&lt;/code&gt; 는 펄이 상수 값을 최적화하는 부호입니다).</target>
        </trans-unit>
        <trans-unit id="3f77411f51027e18d6942d6aafcf90ba55ec2701" translate="yes" xml:space="preserve">
          <source>which produces the output (again, long lines have been wrapped here)</source>
          <target state="translated">출력을 생성합니다 (다시 긴 줄이 여기에 줄 바꿈되었습니다)</target>
        </trans-unit>
        <trans-unit id="bef5e7ef43fdb712239e626bd67fabf93a351f45" translate="yes" xml:space="preserve">
          <source>which produces:</source>
          <target state="translated">어떤 생산 :</target>
        </trans-unit>
        <trans-unit id="f2902720610777e0cb05329288b1b2cd5b87bdd4" translate="yes" xml:space="preserve">
          <source>which provides a new Perl interpreter for each thread, and, by default, results in no data or state information being shared between threads.</source>
          <target state="translated">각 스레드에 대해 새로운 Perl 인터프리터를 제공하며 기본적으로 스레드간에 데이터 또는 상태 정보가 공유되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f92ba8d28d485765994bd16e6b0139ab94d5b990" translate="yes" xml:space="preserve">
          <source>which puts literal commas into some of the list items. Write it without commas if you don't want them to appear in your data:</source>
          <target state="translated">목록 항목 중 일부에 리터럴 쉼표를 넣습니다. 데이터에 표시하지 않으려면 쉼표없이 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="87d11dc8fa4ace81bc6cff5f401501d4f07cbd6a" translate="yes" xml:space="preserve">
          <source>which puts you into a readline interface. If &lt;code&gt;Term::ReadKey&lt;/code&gt; and either of &lt;code&gt;Term::ReadLine::Perl&lt;/code&gt; or &lt;code&gt;Term::ReadLine::Gnu&lt;/code&gt; are installed, history and command completion are supported.</source>
          <target state="translated">readline 인터페이스로 연결됩니다. 경우 &lt;code&gt;Term::ReadKey&lt;/code&gt; 와 하나의 &lt;code&gt;Term::ReadLine::Perl&lt;/code&gt; 또는 &lt;code&gt;Term::ReadLine::Gnu&lt;/code&gt; 설치되어, 역사, 명령 완료가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="6f4d24b8ce89da9965a39a4a2a60f5482730186f" translate="yes" xml:space="preserve">
          <source>which rely on special alignment which is not provided by Perl's malloc().</source>
          <target state="translated">이것은 Perl의 malloc ()에서 제공하지 않는 특별한 정렬에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="fdcf525abe96dbcca08ea62d672f58f208fd0fe2" translate="yes" xml:space="preserve">
          <source>which returns 'a/b/c' under Unix. Or:</source>
          <target state="translated">유닉스에서 'a / b / c'를 반환합니다. 또는:</target>
        </trans-unit>
        <trans-unit id="ec1e3337a0ee7b60523959a46060f22ddce31714" translate="yes" xml:space="preserve">
          <source>which returns a string consisting of the first character from each string. Using pack, we can write</source>
          <target state="translated">각 문자열에서 첫 번째 문자로 구성된 문자열을 반환합니다. 팩을 사용해 쓸 수있다</target>
        </trans-unit>
        <trans-unit id="3d4e654a3fe5a13b1285db512bfaad46b825adcf" translate="yes" xml:space="preserve">
          <source>which reverses the order of method call.</source>
          <target state="translated">메소드 호출 순서를 반대로합니다.</target>
        </trans-unit>
        <trans-unit id="0a42738502aac554f3685b010c8c33d17b8d8a89" translate="yes" xml:space="preserve">
          <source>which runs script non-interactively, printing info on each entry into a subroutine and each executed line into the file named</source>
          <target state="translated">스크립트를 비 대화식으로 실행하여 서브 루틴의 각 항목에 대한 정보와 이름이 지정된 파일의 각 행에 대한 정보를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="a26dc4262a5b530b9fd0491393a70987f0cb95f8" translate="yes" xml:space="preserve">
          <source>which sets the debugging packages directly. Note that &lt;code&gt;o debug 0&lt;/code&gt; turns debugging off.</source>
          <target state="translated">디버깅 패키지를 직접 설정합니다. 참고 &lt;code&gt;o debug 0&lt;/code&gt; 턴 오프 디버깅.</target>
        </trans-unit>
        <trans-unit id="13c1eb00f520026b6ba1e70a18a4964822f7275f" translate="yes" xml:space="preserve">
          <source>which should be interpreted as a link to the &lt;code&gt;vertical|bar/slash&lt;/code&gt; POD page and not as a link to the &lt;code&gt;slash&lt;/code&gt; section of the &lt;code&gt;bar&lt;/code&gt; POD page with an anchor text of &lt;code&gt;vertical&lt;/code&gt; . Note that not only the anchor text will need to have formatting codes expanded, but so will the target of the link (to deal with E&amp;lt;&amp;gt; and Z&amp;lt;&amp;gt; formatting codes), and special handling of the section may be necessary depending on whether the translator wants to consider markup in sections to be significant when resolving links. See &lt;a href=&quot;../perlpodspec&quot;&gt;perlpodspec&lt;/a&gt; for more information.</source>
          <target state="translated">이는 앵커 텍스트가 &lt;code&gt;vertical&lt;/code&gt; 인 &lt;code&gt;bar&lt;/code&gt; POD 페이지 의 &lt;code&gt;slash&lt;/code&gt; 섹션에 대한 링크가 아니라 &lt;code&gt;vertical|bar/slash&lt;/code&gt; POD 페이지에 대한 링크로 해석되어야합니다 . 앵커 텍스트뿐만 아니라 형식 코드를 확장해야 할뿐만 아니라 링크 대상 (E &amp;lt;&amp;gt; 및 Z &amp;lt;&amp;gt; 형식 코드를 처리하기 위해)과 섹션의 특수 처리가 필요한지 여부에 따라 필요할 수 있습니다. 번역가는 링크를 확인할 때 섹션의 마크 업을 중요하게 고려하려고합니다. 자세한 내용은 &lt;a href=&quot;../perlpodspec&quot;&gt;perlpodspec&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="82d18cd1d1191a0e6eb914334f14809f4e2df5fc" translate="yes" xml:space="preserve">
          <source>which shows that spaces are still possible in the code parts. Nevertheless, when working with code and conditional expressions, the extended form of regexps is almost necessary in creating and debugging regexps.</source>
          <target state="translated">코드 부분에 공백이 여전히 가능하다는 것을 보여줍니다. 그럼에도 불구하고 코드 및 조건식을 사용할 때 정규식의 확장 양식은 정규식을 작성하고 디버깅하는 데 거의 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c562409303f52b59b405fbd73bdc489d191355d6" translate="yes" xml:space="preserve">
          <source>which specifies that the ambient pragmas are exactly those which are in scope at the point of calling.</source>
          <target state="translated">이것은 주변 pragma가 호출 시점의 범위에있는 것을 정확하게 지정합니다.</target>
        </trans-unit>
        <trans-unit id="a01b2a58a6fdba96f9248e9340f26dd88b40f22f" translate="yes" xml:space="preserve">
          <source>which the range operator becomes false again. It doesn't become false till the next time the range operator is evaluated. It can test the right operand and become false on the same evaluation it became true (as in &lt;b&gt;awk&lt;/b&gt;), but it still returns true once. If you don't want it to test the right operand until the next evaluation, as in &lt;b&gt;sed&lt;/b&gt;, just use three dots (&lt;code&gt;&quot;...&quot;&lt;/code&gt; ) instead of two. In all other regards, &lt;code&gt;&quot;...&quot;&lt;/code&gt; behaves just like &lt;code&gt;&quot;..&quot;&lt;/code&gt; does.</source>
          <target state="translated">범위 연산자가 다시 false가됩니다. 다음에 범위 연산자가 평가 될 때까지 거짓이되지 않습니다. 올바른 피연산자를 테스트하고 &lt;b&gt;awk&lt;/b&gt; 에서와 같이 true가 된 동일한 평가에서 false가 될 수 있지만 여전히 한 번 true를 반환합니다. 다음 평가 때까지 올바른 피연산자를 테스트하지 않으려면 &lt;b&gt;sed&lt;/b&gt; 에서와 같이 두 개의 점 대신 세 개의 점 ( &lt;code&gt;&quot;...&quot;&lt;/code&gt; ) 만 사용하십시오 . 다른 모든 측면에서 &lt;code&gt;&quot;...&quot;&lt;/code&gt; 은 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 과 같은 방식으로 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="81c23090ff08e0fb68830283659fa8701d911f41" translate="yes" xml:space="preserve">
          <source>which then may be given to subsequent gprof runs to accumulate data over several runs.</source>
          <target state="translated">그런 다음 후속 gprof 실행에 제공되어 여러 실행에 걸쳐 데이터를 축적 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bc38136202aaeb79aacb17bb0b21ad3bf7c2961" translate="yes" xml:space="preserve">
          <source>which understands command arguments. One of such ports is listed in &lt;a href=&quot;#Prerequisites&quot;&gt;Prerequisites&lt;/a&gt; under RSX. Do not forget to set variable &lt;code&gt;&lt;a href=&quot;#PERL_SH_DIR&quot;&gt;PERL_SH_DIR&lt;/a&gt;&lt;/code&gt; as well.</source>
          <target state="translated">명령 인수를 이해합니다. 이러한 포트 중 하나가 RSX의 &lt;a href=&quot;#Prerequisites&quot;&gt;전제 조건&lt;/a&gt; 에 나열되어 있습니다. &lt;code&gt;&lt;a href=&quot;#PERL_SH_DIR&quot;&gt;PERL_SH_DIR&lt;/a&gt;&lt;/code&gt; 변수도 설정하는 것을 잊지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="da06cc8f27f2a4277c9d2ea18a97a8abd08b8a8d" translate="yes" xml:space="preserve">
          <source>which uses &lt;code&gt;(?&amp;gt;...)&lt;/code&gt; matches exactly when the one above does (verifying this yourself would be a productive exercise), but finishes in a fourth the time when used on a similar string with 1000000 &lt;code&gt;a&lt;/code&gt; s. Be aware, however, that, when this construct is followed by a quantifier, it currently triggers a warning message under the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma or &lt;b&gt;-w&lt;/b&gt; switch saying it &lt;code&gt;&quot;matches null string many times in regex&quot;&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;(?&amp;gt;...)&lt;/code&gt; 를 사용 하는 것은 위의 것과 같을 때 정확히 일치하지만 (이를 스스로 검증하는 것은 생산적인 연습이 될 것입니다), 1000000 &lt;code&gt;a&lt;/code&gt; 의 유사한 문자열에서 사용될 때 네 번째 시간에 완료됩니다 . 그러나이 구문 다음에 수량자가 오는 경우, 현재 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma 또는 &lt;b&gt;-w&lt;/b&gt; 스위치 &lt;code&gt;&quot;matches null string many times in regex&quot;&lt;/code&gt; 함 &quot;을 나타내는 경고 메시지를 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="c1742d6043b0a0627cfbbf796a8a4aec58b9ba1e" translate="yes" xml:space="preserve">
          <source>which will automatically coerce the actual scalar type into an IV, UV, double, or string.</source>
          <target state="translated">실제 스칼라 유형을 IV, UV, 이중 또는 문자열로 자동 강제합니다.</target>
        </trans-unit>
        <trans-unit id="6fb146e9079ae4bc7011dc3190cd3e0c07fe95ee" translate="yes" xml:space="preserve">
          <source>which will call</source>
          <target state="translated">어느 것이 전화</target>
        </trans-unit>
        <trans-unit id="a70f5704ad119ee244b693c30eb2b8ff7c442560" translate="yes" xml:space="preserve">
          <source>which will cause</source>
          <target state="translated">이로 인해</target>
        </trans-unit>
        <trans-unit id="607626ffbe3fb95a065011f0e19304f91e5ce829" translate="yes" xml:space="preserve">
          <source>which will determine if more memory needs to be allocated. If so, it will call the function &lt;code&gt;sv_grow&lt;/code&gt; . Note that &lt;code&gt;SvGROW&lt;/code&gt; can only increase, not decrease, the allocated memory of an SV and that it does not automatically add space for the trailing &lt;code&gt;NUL&lt;/code&gt; byte (perl's own string functions typically do &lt;code&gt;SvGROW(sv, len + 1)&lt;/code&gt; ).</source>
          <target state="translated">더 많은 메모리를 할당해야하는지 결정합니다. 그렇다면 &lt;code&gt;sv_grow&lt;/code&gt; 함수를 호출합니다 . 참고 것을 &lt;code&gt;SvGROW&lt;/code&gt; 가 만 증가시킬 수있다, SV에의 할당 된 메모리를 감소되지 않고 자동으로 뒤에 공간을 추가하지 않습니다 &lt;code&gt;NUL&lt;/code&gt; 의 (펄 자신의 문자열 함수는 일반적으로 할 바이트 &lt;code&gt;SvGROW(sv, len + 1)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1979ea935ff5d0f72dacbfc022d39ca4775f4154" translate="yes" xml:space="preserve">
          <source>which will do conversion from LF to CR/LF on the output, or in the environment settings (add this to your .bashrc):</source>
          <target state="translated">출력 또는 환경 설정에서 LF에서 CR / LF로 변환합니다 (.bashrc에 추가).</target>
        </trans-unit>
        <trans-unit id="f602755896feed19e862deed34ab69b1cc800288" translate="yes" xml:space="preserve">
          <source>which will echo the cat command's output as it is generated, instead of waiting until the program has completed to print it out. It also checks the return value.</source>
          <target state="translated">프로그램이 출력을 완료 할 때까지 기다리지 않고 생성 된 cat 명령의 출력을 에코합니다. 또한 반환 값을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="b50d57b41b49f3ab1ba2caaab449544638d7c8f0" translate="yes" xml:space="preserve">
          <source>which will expand the macros using cpp. Don't be scared by the results.</source>
          <target state="translated">cpp를 사용하여 매크로를 확장합니다. 결과에 무서워하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="9e71b54891a6848222e41887418f6d0101fb71a1" translate="yes" xml:space="preserve">
          <source>which will export Exporter's own import() method into YourModule. Everything will work as before but you won't need to include Exporter in &lt;code&gt;@YourModule::ISA&lt;/code&gt; .</source>
          <target state="translated">Exporter 자신의 import () 메소드를 YourModule로 내 보냅니다. 모든 것이 이전처럼 작동하지만 &lt;code&gt;@YourModule::ISA&lt;/code&gt; Exporter를 포함시킬 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b87794d0dcf9a6a672b27ff15db2b5b5df0e9109" translate="yes" xml:space="preserve">
          <source>which will match assigned characters known to be part of the Greek script.</source>
          <target state="translated">그리스어 스크립트의 일부인 것으로 알려진 지정된 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="b95b054f4d66abe300e2020ad56271297a5fff0f" translate="yes" xml:space="preserve">
          <source>which will override system(), exec(), &lt;code&gt;``&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open(,'...|')&lt;/a&gt;&lt;/code&gt;. With current perl you may override only system(), readpipe() - the explicit version of &lt;code&gt;``&lt;/code&gt; , and maybe exec(). The code will substitute the one-argument call to system() by &lt;code&gt;CORE::system('cmd.exe', '/c', &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;)&lt;/code&gt; .</source>
          <target state="translated">이것은 system (), exec (), &lt;code&gt;``&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open(,'...|')&lt;/a&gt;&lt;/code&gt; 을 무시합니다 . 의 명시 적 버전 - 현재 펄 만 시스템 (), readpipe ()를 오버라이드 (override) 할 수 있습니다 &lt;code&gt;``&lt;/code&gt; , 그리고 어쩌면 간부 인 (). 이 코드는 &lt;code&gt;CORE::system('cmd.exe', '/c', &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;)&lt;/code&gt; 로 system ()에 대한 인수 하나를 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="456a31b1679a3c242ee6fcfa550ef4cff72097d5" translate="yes" xml:space="preserve">
          <source>which will print something like this</source>
          <target state="translated">이런 식으로 인쇄됩니다</target>
        </trans-unit>
        <trans-unit id="9d9f99b15b9cecc682a88d237aaf65afdade60cb" translate="yes" xml:space="preserve">
          <source>which will pull in the crlf PerlIO layer which does LF -&amp;gt; CRLF conversion on every output generated by perl.</source>
          <target state="translated">이는 perl에 의해 생성 된 모든 출력에서 ​​LF-&amp;gt; CRLF 변환을 수행하는 crlf PerlIO 계층을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="3f021bf96a0c4f48629afad5e6635345dc7b47e5" translate="yes" xml:space="preserve">
          <source>which works exactly as it does for the &lt;code&gt;V&lt;/code&gt; and &lt;code&gt;X&lt;/code&gt; commands. Requires the &lt;code&gt;PadWalker&lt;/code&gt; module version 0.08 or higher; will warn if this isn't installed. Output is pretty-printed in the same style as for &lt;code&gt;V&lt;/code&gt; and the format is controlled by the same options.</source>
          <target state="translated">이는 &lt;code&gt;V&lt;/code&gt; 및 &lt;code&gt;X&lt;/code&gt; 명령 과 동일하게 작동 합니다. &lt;code&gt;PadWalker&lt;/code&gt; 모듈 버전 0.08 이상이 필요합니다 . 설치되어 있지 않으면 경고합니다. 출력은 &lt;code&gt;V&lt;/code&gt; 와 동일한 스타일로 인쇄되며 형식은 동일한 옵션으로 제어됩니다.</target>
        </trans-unit>
        <trans-unit id="11c1ab2f8d5d6cd3a60669a9963f5426c9daee0d" translate="yes" xml:space="preserve">
          <source>which would produce:</source>
          <target state="translated">어떤 생산 :</target>
        </trans-unit>
        <trans-unit id="5a1c45867db7ee2d51ddbd3c9e7a13e56f64c459" translate="yes" xml:space="preserve">
          <source>which, again, is the default that you should probably never change. You cannot use this keyword on versions of perl before 5.16 to make XSUBs &lt;code&gt;static&lt;/code&gt; .</source>
          <target state="translated">다시 말하지만, 절대 변경해서는 안되는 기본값입니다. XSUB를 &lt;code&gt;static&lt;/code&gt; 으로 만들기 위해 5.16 이전의 perl 버전에서는이 키워드를 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="7d75fc0dff9af022da4a609d39c10fe2dc49a67f" translate="yes" xml:space="preserve">
          <source>whichever is appropriate.) Also, make sure that the DLLs for external libraries are usable with with executables compiled without &lt;code&gt;-Zmtd&lt;/code&gt; options.</source>
          <target state="translated">또한 외부 라이브러리의 DLL을 &lt;code&gt;-Zmtd&lt;/code&gt; 옵션 없이 컴파일 된 실행 파일과 함께 사용할 수 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="6517f89c46c3f0d6db9cb009b8c7d1f98c371fa0" translate="yes" xml:space="preserve">
          <source>while</source>
          <target state="translated">while</target>
        </trans-unit>
        <trans-unit id="c755db4e16e1ebd5579bf9df24c0a9dde1dc936a" translate="yes" xml:space="preserve">
          <source>while the object methods of the class still work as designed. This is a key feature of inside-out classes.</source>
          <target state="translated">클래스의 객체 메소드는 여전히 설계된대로 작동합니다. 이것은 인사이드 아웃 클래스의 주요 기능입니다.</target>
        </trans-unit>
        <trans-unit id="e5daa18cf1bbf438222f9cb7416fc2f0b139eb61" translate="yes" xml:space="preserve">
          <source>while this is invalid:</source>
          <target state="translated">이것이 유효하지 않은 동안 :</target>
        </trans-unit>
        <trans-unit id="d2f5ed52eb803c45683b5fc0aa9520f29eb7cf52" translate="yes" xml:space="preserve">
          <source>whole class</source>
          <target state="translated">학급</target>
        </trans-unit>
        <trans-unit id="5a8cc6fdee71abc3b1476fb220e9d1cd4edb423d" translate="yes" xml:space="preserve">
          <source>whose dot files this object represents</source>
          <target state="translated">이 객체가 나타내는 도트 파일</target>
        </trans-unit>
        <trans-unit id="3fd57b2686f4898d067d4a56c073c64e61db82bf" translate="yes" xml:space="preserve">
          <source>whose lookup failed, and naming the line number where the calling $lh-&amp;gt;maketext(</source>
          <target state="translated">조회가 실패하고 $ lh-&amp;gt; maketext (</target>
        </trans-unit>
        <trans-unit id="10cff4034cedfb92a272cddd774b8b63e3bdad06" translate="yes" xml:space="preserve">
          <source>why</source>
          <target state="translated">why</target>
        </trans-unit>
        <trans-unit id="70bec8a9bf5ecd2e6b37316e112b3f4c615ad4d3" translate="yes" xml:space="preserve">
          <source>width</source>
          <target state="translated">width</target>
        </trans-unit>
        <trans-unit id="37d41699bdee4fcb969ca499eb0f8b82c60d59cc" translate="yes" xml:space="preserve">
          <source>will</source>
          <target state="translated">will</target>
        </trans-unit>
        <trans-unit id="9e698af09629b7ab425fc48e2a23b9a874214ff2" translate="yes" xml:space="preserve">
          <source>will all be loaded correctly by the &lt;b&gt;SelfLoader&lt;/b&gt;, and the &lt;b&gt;SelfLoader&lt;/b&gt; will ensure that the packages 'foo' and 'baz' correctly have the &lt;b&gt;SelfLoader&lt;/b&gt;&lt;code&gt;AUTOLOAD&lt;/code&gt; method when the data after &lt;code&gt;__DATA__&lt;/code&gt; is first parsed.</source>
          <target state="translated">&lt;b&gt;SelfLoader&lt;/b&gt; 는 &lt;b&gt;SelfLoader에&lt;/b&gt; 의해 모두 올바르게로드 되고 &lt;b&gt;SelfLoader&lt;/b&gt; 는 &lt;code&gt;__DATA__&lt;/code&gt; 이후의 데이터 가 처음 구문 분석 될 때 패키지 'foo'및 'baz'에 &lt;b&gt;SelfLoader &lt;/b&gt; &lt;code&gt;AUTOLOAD&lt;/code&gt; 메소드 가 올바르게 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="802b42bef12951357b89ef5b2a13122fbe99ef9d" translate="yes" xml:space="preserve">
          <source>will allow calling myref() as</source>
          <target state="translated">myref ()를 다음과 같이 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f588d27875535a5a81b909a3f21a13470c6000b" translate="yes" xml:space="preserve">
          <source>will allow the user to specify an argument of the form &lt;code&gt;&quot;rsh cat file |&quot;&lt;/code&gt; , but will not work on a filename that happens to have a trailing space, while</source>
          <target state="translated">사용자가 &lt;code&gt;&quot;rsh cat file |&quot;&lt;/code&gt; 형식의 인수를 지정할 수있게합니다. 후행 공백이있는 파일 이름에는 작동하지 않지만</target>
        </trans-unit>
        <trans-unit id="cdd84ef15151c715185c9415f2310209f946b6e6" translate="yes" xml:space="preserve">
          <source>will also turn on the &lt;code&gt;DEBUGGING&lt;/code&gt; compilation symbol which enables all the internal debugging code in Perl. There are a whole bunch of things you can debug with this: &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; lists them all, and the best way to find out about them is to play about with them. The most useful options are probably</source>
          <target state="translated">또한 &lt;code&gt;DEBUGGING&lt;/code&gt; 컴파일 심볼을 켜서 Perl의 모든 내부 디버깅 코드를 활성화합니다. 이것으로 디버깅 할 수있는 많은 것들이 있습니다 : &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; 은 그것들을 모두 나열하고, 그것들을 알아내는 가장 좋은 방법은 그들과 놀아 보는 것입니다. 가장 유용한 옵션은 아마도</target>
        </trans-unit>
        <trans-unit id="1b4ff705741e98869e5239461b8d80b3db153b63" translate="yes" xml:space="preserve">
          <source>will always be appropriately set before</source>
          <target state="translated">항상 전에 적절하게 설정됩니다</target>
        </trans-unit>
        <trans-unit id="800502b2521db5dda562d1522427959496f11b6d" translate="yes" xml:space="preserve">
          <source>will automatically call &lt;code&gt;deflateSetDictionary&lt;/code&gt; directly after calling &lt;code&gt;deflateInit&lt;/code&gt; . The Adler32 value for the dictionary can be obtained by calling the method &lt;code&gt;$d-&amp;gt;dict_adler()&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;deflateInit&lt;/code&gt; 를 호출 한 후 &lt;code&gt;deflateSetDictionary&lt;/code&gt; 를 자동으로 호출 합니다. 사전에 대한 Adler32 값은 &lt;code&gt;$d-&amp;gt;dict_adler()&lt;/code&gt; 메소드를 호출하여 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ac2d106304a82f8979d078a5d1a630e0bf0bbed4" translate="yes" xml:space="preserve">
          <source>will automatically call &lt;code&gt;deflateSetDictionary&lt;/code&gt; directly after calling &lt;code&gt;deflateInit&lt;/code&gt; . The Adler32 value for the dictionary can be obtained by calling the method &lt;code&gt;$d-&lt;/code&gt; dict_adler()&amp;gt;.</source>
          <target state="translated">&lt;code&gt;deflateInit&lt;/code&gt; 를 호출 한 후 &lt;code&gt;deflateSetDictionary&lt;/code&gt; 를 자동으로 호출 합니다. 사전에 대한 Adler32 값은 &lt;code&gt;$d-&lt;/code&gt; dict_adler ()&amp;gt; 메소드를 호출하여 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bf4cadec0746e1a5ab432f127230623d5e7091d8" translate="yes" xml:space="preserve">
          <source>will automatically search in</source>
          <target state="translated">자동으로 검색합니다</target>
        </trans-unit>
        <trans-unit id="047046a9e670aa4336adfdf1872082aee6bc3385" translate="yes" xml:space="preserve">
          <source>will automatically search when adding directories to @&lt;code&gt;INC&lt;/code&gt; . The elements in the list are separated by spaces. This is only useful if you have a perl library directory tree structured like the default one. See &lt;code&gt;INSTALL&lt;/code&gt; for how this works. The versioned site_perl directory was introduced in 5.005, so that is the lowest possible value.</source>
          <target state="translated">@ &lt;code&gt;INC&lt;/code&gt; 에 디렉토리를 추가하면 자동으로 검색됩니다 . 목록의 요소는 공백으로 구분됩니다. 이것은 펄 라이브러리 디렉토리 트리가 기본 디렉토리 구조와 같이 구조화 된 경우에만 유용합니다. 작동 방법 은 &lt;code&gt;INSTALL&lt;/code&gt; 를 참조하십시오 . 버전이 지정된 site_perl 디렉토리는 5.005에 도입되었으므로 가능한 가장 낮은 값입니다.</target>
        </trans-unit>
        <trans-unit id="77ff54c41540566c24d6f01703b68b71c5db0b9e" translate="yes" xml:space="preserve">
          <source>will be a reference to a glob which can be treated as a perl file handle. It refers to the layer below.</source>
          <target state="translated">perl 파일 핸들로 취급 될 수있는 glob에 대한 참조가됩니다. 아래 계층을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1f36a5ca854b3b31929c9a757a81400bb46baa6a" translate="yes" xml:space="preserve">
          <source>will be added to the list if not present, as will any types given in the list of</source>
          <target state="translated">목록에 지정된 유형과 마찬가지로 목록에없는 경우 목록에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="2ee7188301caacf79b6af8dcb2c81f839071db3f" translate="yes" xml:space="preserve">
          <source>will be appropriately labeled using arrow notation. You can specify names for individual values to be dumped if you use the &lt;code&gt;Dump()&lt;/code&gt; method, or you can change the default &lt;code&gt;$VAR&lt;/code&gt; prefix to something else. See &lt;code&gt;$Data::Dumper::Varname&lt;/code&gt; and &lt;code&gt;$Data::Dumper::Terse&lt;/code&gt; below.</source>
          <target state="translated">화살표 표기법을 사용하여 적절히 레이블이 지정됩니다. &lt;code&gt;Dump()&lt;/code&gt; 메서드 를 사용하는 경우 덤프 할 개별 값의 이름을 지정 하거나 기본 &lt;code&gt;$VAR&lt;/code&gt; 접두사를 다른 것으로 변경할 수 있습니다 . 아래의 &lt;code&gt;$Data::Dumper::Varname&lt;/code&gt; 및 &lt;code&gt;$Data::Dumper::Terse&lt;/code&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b5d33fb37764bb4ed1953600f4adf836066df187" translate="yes" xml:space="preserve">
          <source>will be assigned.</source>
          <target state="translated">할당됩니다.</target>
        </trans-unit>
        <trans-unit id="4b924079b9f868588e8837d7d50c4a682e44dca9" translate="yes" xml:space="preserve">
          <source>will be associated with</source>
          <target state="translated">와 연결됩니다</target>
        </trans-unit>
        <trans-unit id="02ae7304f1d07ef95ca9aa9e7fec2131cfb9259b" translate="yes" xml:space="preserve">
          <source>will be assumed.</source>
          <target state="translated">가정합니다.</target>
        </trans-unit>
        <trans-unit id="69e74f77cfb1d64cc1f2b8b0e7553a0f92d29c07" translate="yes" xml:space="preserve">
          <source>will be assumed. In a</source>
          <target state="translated">가정합니다. 안에</target>
        </trans-unit>
        <trans-unit id="3ffcf20d5b3d655c1147575473aace4b9819db78" translate="yes" xml:space="preserve">
          <source>will be at the start of a block, so variables may be defined in it.</source>
          <target state="translated">블록이 시작될 때 변수가 정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf4139ebee2a50a45a47c6c20c8db3e1866f4f96" translate="yes" xml:space="preserve">
          <source>will be automatically appended if no dot is present in the name. The workaround is as simple as that: since</source>
          <target state="translated">이름에 점이 없으면 자동으로 추가됩니다. 해결 방법은 다음과 같이 간단합니다.</target>
        </trans-unit>
        <trans-unit id="5a46024906c3202205c9b86fbe8cd6c05e18f661" translate="yes" xml:space="preserve">
          <source>will be automatically closed.</source>
          <target state="translated">자동으로 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="a5391631955c2960d94bb3306b3cf823fd72eb2e" translate="yes" xml:space="preserve">
          <source>will be called, or whatever is the override, see &lt;a href=&quot;#PERL_SH_DIR&quot;&gt;PERL_SH_DIR&lt;/a&gt;.</source>
          <target state="translated">호출되거나 대체가 무엇이든 &lt;a href=&quot;#PERL_SH_DIR&quot;&gt;PERL_SH_DIR을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="39863063f526390d21b54f0437be449e32146e0d" translate="yes" xml:space="preserve">
          <source>will be evaluated by &lt;code&gt;wanted()&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;wanted()&lt;/code&gt; 의해 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="28165e3b4da95eac8adbdc3dff70bd1aebff0f5c" translate="yes" xml:space="preserve">
          <source>will be extracted as if it were:</source>
          <target state="translated">마치 다음과 같이 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="b611847a2698bb295db4bc4d7f2ff88d3d7bfd77" translate="yes" xml:space="preserve">
          <source>will be incorrectly parsed as:</source>
          <target state="translated">다음과 같이 잘못 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="6c7777c83dbab33571eaae602d63da07c1775c05" translate="yes" xml:space="preserve">
          <source>will be interpreted DWIMically, often as a comparison against &lt;code&gt;$_&lt;/code&gt; , and may be null to generate a &lt;code&gt;default&lt;/code&gt; block.</source>
          <target state="translated">는 종종 &lt;code&gt;$_&lt;/code&gt; 에 대한 비교로 DWIMically 해석되며 &lt;code&gt;default&lt;/code&gt; 블록 을 생성하기 위해 null 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="75321a4f0c9b87d6d48f48cc9f64b5f655545b5c" translate="yes" xml:space="preserve">
          <source>will be modified to the last $octets position at end of decode. Returns true if $terminator appears output, else returns false.</source>
          <target state="translated">디코드가 끝날 때 마지막 $ octets 위치로 수정됩니다. $ terminator가 출력으로 나타나면 true를, 그렇지 않으면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5444aae0d6bc7e881d14ae4362de10908be2d8bc" translate="yes" xml:space="preserve">
          <source>will be moved, and the buffer shortened. This hides the discarded text from any lexing code that runs later, as if the text had never appeared.</source>
          <target state="translated">이동하고 버퍼가 줄어 듭니다. 이렇게하면 텍스트가 표시되지 않은 것처럼 나중에 실행되는 어휘 코드에서 버려진 텍스트가 숨겨집니다.</target>
        </trans-unit>
        <trans-unit id="fb90a1b23ad48d9287e458757890f8e9565a8afc" translate="yes" xml:space="preserve">
          <source>will be retried. This lets you type &lt;code&gt;man debug&lt;/code&gt; or &lt;code&gt;man op&lt;/code&gt; from the debugger.</source>
          <target state="translated">재 시도됩니다. 디버거에서 &lt;code&gt;man debug&lt;/code&gt; 또는 &lt;code&gt;man op&lt;/code&gt; 를 입력 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ef44a7f700e88aec4c8b15477ecc69c13f947c3" translate="yes" xml:space="preserve">
          <source>will be returned.</source>
          <target state="translated">반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1970ab6c3e7f53185ec961c7b96e2bec3982ca45" translate="yes" xml:space="preserve">
          <source>will be some defined value if the open succeeds, but &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if it fails;</source>
          <target state="translated">열림이 성공하면 정의 된 값이지만 실패하면 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="b0e5f84ae9a025c95805cfbdda7aba5f2e868b56" translate="yes" xml:space="preserve">
          <source>will be treated as a boolean match because the rules say both a regex match and an explicit test on &lt;code&gt;$_&lt;/code&gt; will be treated as boolean.</source>
          <target state="translated">규칙에 따르면 정규 표현식 일치와 &lt;code&gt;$_&lt;/code&gt; 의 명시 적 테스트가 모두 부울로 처리되므로 규칙이 부울 일치 로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="7bdb6f7a9a73bafa81d66281077d808cd4f13be5" translate="yes" xml:space="preserve">
          <source>will be twice UTF-8 encoded. A &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; ':encoding(utf8)'&lt;/code&gt; would have avoided the bug, or explicitly opening also the</source>
          <target state="translated">UTF-8로 두 번 인코딩됩니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; ':encoding(utf8)'&lt;/code&gt; 버그를 회피하거나, 명시 적으로도 열 것</target>
        </trans-unit>
        <trans-unit id="ee4475df6e379629545ed6276a569f3e2eb1ef11" translate="yes" xml:space="preserve">
          <source>will be undefined, since a recursive structure cannot be constructed using one Perl statement. You should set the &lt;code&gt;Purity&lt;/code&gt; flag to 1 to get additional statements that will correctly fill in these references. Moreover, if &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed when strictures are in effect, you need to ensure that any variables it accesses are previously declared.</source>
          <target state="translated">재귀 구조는 하나의 Perl 문을 사용하여 구성 할 수 없으므로 정의되지 않습니다. 이러한 참조를 올바르게 채우는 추가 명령문을 얻으려면 &lt;code&gt;Purity&lt;/code&gt; 플래그를 1로 설정해야합니다 . 더욱이, &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 적용될 때 평가되는 경우 , 액세스하는 모든 변수가 이전에 선언되었는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="eee291ac39ab0e01b156565c777f946041d54d02" translate="yes" xml:space="preserve">
          <source>will be used as the handler for subsequently installed signals.</source>
          <target state="translated">이후에 설치되는 신호의 처리기로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4d9bc2ddc4bc2a031e22465c252b6377da6be593" translate="yes" xml:space="preserve">
          <source>will be used for password.</source>
          <target state="translated">비밀번호로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="189f210a322c7c2ba81e0ea9896d29ddd547e1b5" translate="yes" xml:space="preserve">
          <source>will be used for the name of the extension. If module_name is not supplied then the name of the first header file will be used, with the first character capitalized.</source>
          <target state="translated">확장명에 사용됩니다. module_name을 제공하지 않으면 첫 번째 문자가 대문자로 사용 된 첫 번째 헤더 파일의 이름이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e9eed5428b5ca4033b733f6e4eabddbdf0bae1ff" translate="yes" xml:space="preserve">
          <source>will be used instead and the output piped through your favourite pager.</source>
          <target state="translated">대신에 사용되며 선호하는 호출기를 통해 출력이 파이프됩니다.</target>
        </trans-unit>
        <trans-unit id="00ea2b0f5cc2323252a0479beca63d9f1b08fa40" translate="yes" xml:space="preserve">
          <source>will be warning free regardless of what $ref actually is.</source>
          <target state="translated">실제로 $ ref가 무엇이든 관계없이 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="84d0d493e062ada8d958a287014680fe0c8e6db1" translate="yes" xml:space="preserve">
          <source>will be zero.</source>
          <target state="translated">0이됩니다.</target>
        </trans-unit>
        <trans-unit id="75c5acef5fb2e47df2bf90c4d4c3a7831000cfcd" translate="yes" xml:space="preserve">
          <source>will become:</source>
          <target state="translated">될 것입니다:</target>
        </trans-unit>
        <trans-unit id="e0318a0bb7d80ff064a8678b238ad297c5e7ed6b" translate="yes" xml:space="preserve">
          <source>will both result in the proper type due to the way the overloaded math works.</source>
          <target state="translated">오버로드 된 수학이 작동하는 방식으로 인해 올바른 유형이됩니다.</target>
        </trans-unit>
        <trans-unit id="ed44e6c8395b95eb951ed01fb3df61dd611bca88" translate="yes" xml:space="preserve">
          <source>will build a Perl that supports dynamic loading (which requires a shared</source>
          <target state="translated">동적 로딩을 지원하는 Perl을 빌드합니다 (공유가 필요함)</target>
        </trans-unit>
        <trans-unit id="2287cd95ce18a71437cb52ed8b1caefedff9eaca" translate="yes" xml:space="preserve">
          <source>will call the Unix emulation library's &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; emulation, which attempts to provide emulation of the stdin, stdout, stderr in force in the parent, providing the child program uses a compatible version of the emulation library.</source>
          <target state="translated">는 자식 프로그램이 호환 가능한 버전의 에뮬레이션 라이브러리를 사용하는 경우 부모에서 강제로 stdin, stdout, stderr 에뮬레이션을 제공하려고 시도 하는 Unix 에뮬레이션 라이브러리의 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 에뮬레이션 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="9dd319675b257f0d34e3db5d71aeabc5c8458128" translate="yes" xml:space="preserve">
          <source>will call the native command line direct and no such emulation of a child Unix program will exists. Mileage &lt;b&gt;will&lt;/b&gt; vary. (RISC OS)</source>
          <target state="translated">네이티브 커맨드 라인을 직접 호출하고 자식 Unix 프로그램의 에뮬레이션은 존재하지 않습니다. 마일리지 &lt;b&gt;가&lt;/b&gt; 다를 수 있습니다. (RISC OS)</target>
        </trans-unit>
        <trans-unit id="5562a8abf4cafe3ad9adfb9e7cbb5beff80d11ed" translate="yes" xml:space="preserve">
          <source>will cause the entire file to be slurped. For large files, it's better to loop:</source>
          <target state="translated">전체 파일이 슬러 핑됩니다. 큰 파일의 경우 반복하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c184916ba1fdcc854b79c2ce8f3611570d536868" translate="yes" xml:space="preserve">
          <source>will cause the handler to be called with a similar argument list (except, of course, that &lt;code&gt;$_[2]&lt;/code&gt; will be a reference to the variable).</source>
          <target state="translated">핸들러가 비슷한 인수 목록으로 호출되도록합니다 (물론 &lt;code&gt;$_[2]&lt;/code&gt; 가 변수에 대한 참조 임을 제외하고 ).</target>
        </trans-unit>
        <trans-unit id="caee4713a9cdf89a7945419e9d20fb846188deb3" translate="yes" xml:space="preserve">
          <source>will compile XS code into C code by embedding the constructs necessary to let C functions manipulate Perl values and creates the glue necessary to let Perl access those functions.</source>
          <target state="translated">C 함수가 Perl 값을 조작하게하는 데 필요한 구문을 임베드하여 XS 코드를 C 코드로 컴파일하고 Perl이 해당 함수에 액세스하도록하는 데 필요한 접착제를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="bf8a15fdda50374b4163d238b2097ac33d5e0df4" translate="yes" xml:space="preserve">
          <source>will compile XS code into C code by embedding the constructs necessary to let C functions manipulate Perl values and creates the glue necessary to let Perl access those functions. The compiler uses typemaps to determine how to map C function parameters and variables to Perl values.</source>
          <target state="translated">C 함수가 Perl 값을 조작하게하는 데 필요한 구문을 임베드하여 XS 코드를 C 코드로 컴파일하고 Perl이 해당 함수에 액세스하도록하는 데 필요한 접착제를 작성합니다. 컴파일러는 유형 맵을 사용하여 C 함수 매개 변수 및 변수를 Perl 값에 맵핑하는 방법을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="958cf42d40b9694a262fb0dd1a956ccae7aeee61" translate="yes" xml:space="preserve">
          <source>will construct a &quot;binary&quot; stream, but then enable UTF-8 translation.</source>
          <target state="translated">&quot;이진&quot;스트림을 구성하지만 UTF-8 변환을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="ca2af336688d1e8d5e00a2d443084fd9b744a776" translate="yes" xml:space="preserve">
          <source>will correctly push BLUE onto the top of the stack.</source>
          <target state="translated">스택 상단에 BLUE를 올바르게 넣습니다.</target>
        </trans-unit>
        <trans-unit id="ff1d4f6ecbef028562f10ecf8ba054ec728c45eb" translate="yes" xml:space="preserve">
          <source>will create the file &quot;FOO.BAT&quot;. Note &quot;pl2bat&quot; strips any .pl suffix and adds a .bat suffix to the generated file.</source>
          <target state="translated">&quot;FOO.BAT&quot;파일을 생성합니다. 참고 &quot;pl2bat&quot;는 모든 .pl 접미사를 제거하고 생성 된 파일에 .bat 접미사를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="d9d73e9ce730e824d01662cbda4e3da1fcf3537f" translate="yes" xml:space="preserve">
          <source>will do an implicit</source>
          <target state="translated">암시 적으로 할 것입니다</target>
        </trans-unit>
        <trans-unit id="abce4a07e1007ee8dd7654b319b0cda84bc64efd" translate="yes" xml:space="preserve">
          <source>will do it for you.</source>
          <target state="translated">당신을 위해 그것을 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="7108818138127d16c4094725bba30a3d913149fe" translate="yes" xml:space="preserve">
          <source>will do what you mean (fail if stuff is empty)</source>
          <target state="translated">당신이 의미하는 것을 할 것입니다 (물건이 비어 있으면 실패)</target>
        </trans-unit>
        <trans-unit id="066b5eeba4c2198d50173831282c3c44664d4d50" translate="yes" xml:space="preserve">
          <source>will effectively become</source>
          <target state="translated">효과적으로 될 것입니다</target>
        </trans-unit>
        <trans-unit id="7b01657f6df9723f80897f0a01fd87afb4d0fa02" translate="yes" xml:space="preserve">
          <source>will extract and format the documentation from any file in the current directory, any Perl module installed on the system, or any of the standard documentation pages, such as this one. Use &lt;code&gt;perldoc &amp;lt;name&amp;gt;&lt;/code&gt; to get information on any of the utilities described in this document.</source>
          <target state="translated">현재 디렉토리의 파일, 시스템에 설치된 Perl 모듈 또는이 문서와 같은 표준 문서 페이지에서 문서를 추출하여 형식을 지정합니다. &lt;code&gt;perldoc &amp;lt;name&amp;gt;&lt;/code&gt; 을 사용 하여이 문서에 설명 된 유틸리티에 대한 정보를 얻으십시오.</target>
        </trans-unit>
        <trans-unit id="915564ffa096011256f1ddfb99671491100c6813" translate="yes" xml:space="preserve">
          <source>will fail, since Test.pm considers the second argument to be a regex! The best bet is to use the one-argument form:</source>
          <target state="translated">Test.pm은 두 번째 인수를 정규식으로 간주하기 때문에 실패합니다! 가장 좋은 방법은 하나의 인수 형식을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="212fc5e54752a78ba3b78f936f759ccf3eed955c" translate="yes" xml:space="preserve">
          <source>will generate or as a reference to a hash.</source>
          <target state="translated">해시를 생성하거나 참조로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2a53f1b0c5018113eb37388423f971ca2d0e17a9" translate="yes" xml:space="preserve">
          <source>will give the same result with or without &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; The power operator &lt;code&gt;**&lt;/code&gt; is also not affected, so that 2 ** .5 is always the square root of 2. Now, it so happens that the pre- and post- increment and decrement operators, ++ and --, are not affected by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; either. Some may rightly consider this to be a bug -- but at least it's a long-standing one.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; 를 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하거나 사용 하지 않고 동일한 결과를 제공합니다 . 전력 연산자 &lt;code&gt;**&lt;/code&gt; 도 영향을받지 않으므로 2 ** .5는 항상 2의 제곱근입니다. 이제, 증분 및 후행 증가 및 감소 연산자 인 ++ 및-는 발생하지 않습니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용의&lt;/a&gt; 영향 어느 한 쪽. 어떤 사람들은 이것이 버그라고 생각할 수도 있지만 적어도 그것은 오래된 버그입니다.</target>
        </trans-unit>
        <trans-unit id="e522bd0030bde0cd245c6a6a2088de240b790d1c" translate="yes" xml:space="preserve">
          <source>will have exactly the opposite restrictions.</source>
          <target state="translated">정확히 반대의 제한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="911e01951fb3b7f75048f4c14389ccff0d911ab7" translate="yes" xml:space="preserve">
          <source>will have the same effect. This construct is</source>
          <target state="translated">같은 효과가 있습니다. 이 구조는</target>
        </trans-unit>
        <trans-unit id="027d9dd767a399ed29c2f093303b12c4fc85e09e" translate="yes" xml:space="preserve">
          <source>will have their leading dashes stripped.</source>
          <target state="translated">선행 대시가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="2194c108734d216b207d2d189e6b066bdc993596" translate="yes" xml:space="preserve">
          <source>will have to specify the installation directories as these most probably have changed since perl itself has been installed. They will have to do this by calling</source>
          <target state="translated">perl 자체가 설치된 이후에 가장 많이 변경되었으므로 설치 디렉토리를 지정해야합니다. 그들은 전화를 통해이 작업을 수행해야합니다</target>
        </trans-unit>
        <trans-unit id="fd5c38ed8c7727c38022b12bfd4163d2940b7d68" translate="yes" xml:space="preserve">
          <source>will hold.</source>
          <target state="translated">개최합니다.</target>
        </trans-unit>
        <trans-unit id="cbda0dd99d938557f490efeb2ffa5530b4ef022d" translate="yes" xml:space="preserve">
          <source>will in most computers print 0, not 1, because even such simple numbers as 0.6 and 0.2 cannot be presented exactly by floating-point numbers. What you think in the above as 'three' is really more like 2.9999999999999995559.</source>
          <target state="translated">0.6 및 0.2와 같은 간단한 숫자조차도 부동 소수점 숫자로 정확하게 표현할 수 없기 때문에 대부분의 컴퓨터에서 1이 아닌 0을 인쇄합니다. 위의 '3'으로 생각하는 것은 실제로 2.9999999999999995559와 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="0b96340c4517d8e5916a24e5c0c58c099ab880e5" translate="yes" xml:space="preserve">
          <source>will initially increment &lt;code&gt;$cnt&lt;/code&gt; up to 8; then during backtracking, its value will be unwound back to 4, which is the value assigned to &lt;code&gt;$res&lt;/code&gt; . At the end of the regex execution, $cnt will be wound back to its initial value of 0.</source>
          <target state="translated">처음에 &lt;code&gt;$cnt&lt;/code&gt; 를 8까지 증가시킵니다 . 역 추적하는 동안 그 값은 &lt;code&gt;$res&lt;/code&gt; 할당 된 값인 4로 풀린다 . 정규식 실행이 끝나면 $ cnt는 초기 값 0으로 다시 감 깁니다.</target>
        </trans-unit>
        <trans-unit id="482fd60cac120fdf28a98539580c1dc1bf947239" translate="yes" xml:space="preserve">
          <source>will invoke &lt;code&gt;ExtUtils::Embed&lt;/code&gt; functions while building your application.</source>
          <target state="translated">응용 프로그램을 빌드하는 동안 &lt;code&gt;ExtUtils::Embed&lt;/code&gt; 함수를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="ec31983ab84cf33f76bb7f28f95cd8a45d78dd13" translate="yes" xml:space="preserve">
          <source>will it apply the &lt;code&gt;Bent&lt;/code&gt; attribute to the variable.</source>
          <target state="translated">&lt;code&gt;Bent&lt;/code&gt; 속성을 변수에 적용합니다 .</target>
        </trans-unit>
        <trans-unit id="cdb47b66626fed7da3a69fabf094bf802562db6c" translate="yes" xml:space="preserve">
          <source>will just extract the &quot;USAGE&quot; section; some of the utilities will automatically call</source>
          <target state="translated">&quot;USAGE&quot;섹션을 추출합니다. 일부 유틸리티는 자동으로 호출됩니다</target>
        </trans-unit>
        <trans-unit id="be6de1408397f34ac967e76e8f03f5647f72bce4" translate="yes" xml:space="preserve">
          <source>will load MODULE only if CONDITION evaluates to true. The above statement has no effect unless &lt;code&gt;CONDITION&lt;/code&gt; is true. If the CONDITION does evaluate to true, then the above line has the same effect as:</source>
          <target state="translated">CONDITION이 true로 평가되는 경우에만 MODULE을로드합니다. &lt;code&gt;CONDITION&lt;/code&gt; 이 true가 아니면 위의 설명은 적용되지 않습니다 . CONDITION이 true로 평가되면 위의 행은 다음과 같은 효과를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="417947d63110228931cd8773ca1769b0152ef181" translate="yes" xml:space="preserve">
          <source>will lock the tied file. &lt;code&gt;MODE&lt;/code&gt; has the same meaning as the second argument to the Perl built-in &lt;code&gt;&lt;a href=&quot;../functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; function; for example &lt;code&gt;LOCK_SH&lt;/code&gt; or &lt;code&gt;LOCK_EX | LOCK_NB&lt;/code&gt; . (These constants are provided by the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Fcntl ':flock'&lt;/code&gt; declaration.)</source>
          <target state="translated">묶인 파일을 잠급니다. &lt;code&gt;MODE&lt;/code&gt; 는 Perl 내장 &lt;code&gt;&lt;a href=&quot;../functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 함수에 대한 두 번째 인수와 같은 의미를 갖습니다 . 예를 들어 &lt;code&gt;LOCK_SH&lt;/code&gt; 또는 &lt;code&gt;LOCK_EX | LOCK_NB&lt;/code&gt; . (이 상수는 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Fcntl ':flock'&lt;/code&gt; 선언에 의해 제공됩니다 .)</target>
        </trans-unit>
        <trans-unit id="fde5332cf051e296efcfa60b991d8b50c9c48011" translate="yes" xml:space="preserve">
          <source>will look like this:</source>
          <target state="translated">다음과 같이 보일 것입니다 :</target>
        </trans-unit>
        <trans-unit id="9e385389da5f12d892ae543d3886ffd128ec573e" translate="yes" xml:space="preserve">
          <source>will match &quot;foo&quot; using the locale's rules for case-insensitive matching, but the &lt;code&gt;/l&lt;/code&gt; does not affect how the &lt;code&gt;\U&lt;/code&gt; operates. Most likely you want both of them to use locale rules. To do this, instead compile the regular expression within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; . This both implicitly adds the &lt;code&gt;/l&lt;/code&gt; , and applies locale rules to the &lt;code&gt;\U&lt;/code&gt; . The lesson is to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , and not &lt;code&gt;/l&lt;/code&gt; explicitly.</source>
          <target state="translated">대소 문자를 구분하지 않는 로케일 규칙을 사용하여 &quot;foo&quot;와 일치하지만 &lt;code&gt;/l&lt;/code&gt; 은 &lt;code&gt;\U&lt;/code&gt; 작동 방식에 영향을 미치지 않습니다 . 둘 다 로케일 규칙을 사용하기를 원할 것입니다. 이렇게하려면 대신 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 범위 내에서 정규식을 컴파일하십시오 . 이것은 암시 적으로 &lt;code&gt;/l&lt;/code&gt; 을 추가하고 로케일 규칙을 &lt;code&gt;\U&lt;/code&gt; 합니다. 교훈은 &lt;code&gt;/l&lt;/code&gt; 이 아닌 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 을 &lt;a href=&quot;functions/use&quot;&gt;사용하는 것&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="109f68c2b8ad8f0d77ed465628f16e2a2c2e7277" translate="yes" xml:space="preserve">
          <source>will match &lt;code&gt;\x8e&lt;/code&gt; , even though &lt;code&gt;\x89&lt;/code&gt; is &quot;i&quot; and &lt;code&gt;\x91 &lt;/code&gt; is &quot;j&quot;, and &lt;code&gt;\x8e&lt;/code&gt; is a gap character, from the alphabetic viewpoint.</source>
          <target state="translated">일치 &lt;code&gt;\x8e&lt;/code&gt; 하더라도, &lt;code&gt;\x89&lt;/code&gt; 있다 &quot;나는&quot;및 &lt;code&gt;\x91 &lt;/code&gt; &quot;J&quot;, 그리고 &lt;code&gt;\x8e&lt;/code&gt; 알파벳 관점에서 갭 문자입니다.</target>
        </trans-unit>
        <trans-unit id="90a6766448c16d38bfe8dff80f09487335928909" translate="yes" xml:space="preserve">
          <source>will match &lt;code&gt;blah&lt;/code&gt; in any case, some spaces, and an exact (</source>
          <target state="translated">일치 &lt;code&gt;blah&lt;/code&gt; (어떤 경우, 어떤 공간 및 정확한에</target>
        </trans-unit>
        <trans-unit id="0b19d9e504a210ea89daa1807562b0478767084f" translate="yes" xml:space="preserve">
          <source>will match, and &lt;code&gt;$1&lt;/code&gt; will be &lt;code&gt;AB&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; will be &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;$3&lt;/code&gt; will not be set. If another branch in the inner parentheses was matched, such as in the string 'ACDE', then the &lt;code&gt;D&lt;/code&gt; and &lt;code&gt;E&lt;/code&gt; would have to be matched as well.</source>
          <target state="translated">일치하고 &lt;code&gt;$1&lt;/code&gt; 은 &lt;code&gt;AB&lt;/code&gt; 가 되고 &lt;code&gt;$2&lt;/code&gt; 는 &lt;code&gt;B&lt;/code&gt; 가 되고 &lt;code&gt;$3&lt;/code&gt; 은 설정되지 않습니다. 문자열 'ACDE'와 같이 내부 괄호의 다른 분기가 일치하면 &lt;code&gt;D&lt;/code&gt; 와 &lt;code&gt;E&lt;/code&gt; 도 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="db2173f99c15aec604a37b03bb19ad87c2e9686f" translate="yes" xml:space="preserve">
          <source>will modify $u2 as well as $u1, because both variables are references to the same array. Had &lt;code&gt;getusers&lt;/code&gt; not been memoized, $u1 and $u2 would have referred to different arrays.</source>
          <target state="translated">두 변수가 동일한 배열에 대한 참조이므로 $ u1과 $ u1을 수정합니다. &lt;code&gt;getusers&lt;/code&gt; 가 메모 되지 않았다면 $ u1과 $ u2는 다른 배열을 참조했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="56a0e2c0e3a6bfe2b40c936f6d822ddccc889e47" translate="yes" xml:space="preserve">
          <source>will neither assign 42 to $x</source>
          <target state="translated">42를 $ x에 할당하지 않습니다</target>
        </trans-unit>
        <trans-unit id="9edcb2b7ab077ed29ec9d28bcba6b5e91ef13ffe" translate="yes" xml:space="preserve">
          <source>will never be accessed. Additionally, the existence of</source>
          <target state="translated">액세스되지 않습니다. 또한, 존재</target>
        </trans-unit>
        <trans-unit id="524ef249301f2929ce4307d365e5fa52cb183591" translate="yes" xml:space="preserve">
          <source>will never match, as the &lt;code&gt;a++&lt;/code&gt; will gobble up all the &lt;code&gt;a&lt;/code&gt; 's in the string and won't leave any for the remaining part of the pattern. This feature can be extremely useful to give perl hints about where it shouldn't backtrack. For instance, the typical &quot;match a double-quoted string&quot; problem can be most efficiently performed when written as:</source>
          <target state="translated">일치하지 않을 경우, AS &lt;code&gt;a++&lt;/code&gt; 모든 중얼 것 &lt;code&gt;a&lt;/code&gt; '문자열에 S와 패턴의 나머지 부분에 대한 어떤을 떠나지 않을 것입니다. 이 기능은 역 추적해서는 안되는 위치에 대한 펄 힌트를 제공하는 데 매우 유용합니다. 예를 들어, 일반적인 &quot;큰 따옴표 문자열 일치&quot;문제는 다음과 같이 쓸 때 가장 효율적으로 수행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf101365c53e8f42c5b08ca87943df667dc3b58c" translate="yes" xml:space="preserve">
          <source>will not affect</source>
          <target state="translated">영향을 미치지 않습니다</target>
        </trans-unit>
        <trans-unit id="f0a53a44c73c968f4506c42dbd7c202fdde9aa25" translate="yes" xml:space="preserve">
          <source>will not automatically generate prototype code for all xsubs. This flag will enable prototypes.</source>
          <target state="translated">모든 xsub에 대한 프로토 타입 코드를 자동으로 생성하지는 않습니다. 이 플래그는 프로토 타입을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="37f358342227139465ebf67d77c4e5c07cc3ca01" translate="yes" xml:space="preserve">
          <source>will not create an intermediate list of 500,000 integers.</source>
          <target state="translated">500,000 정수의 중간 목록을 만들지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a909cd12fa7841454a3513c9ecc27aa26ed050e5" translate="yes" xml:space="preserve">
          <source>will not, and a subsequent pop won't restore the correct attributes. PUSHCOLOR pushes the attributes set by its argument, which is normally a string of color constants. It can't ask the terminal what the current attributes are.</source>
          <target state="translated">그렇지 않으면 후속 팝은 올바른 속성을 복원하지 않습니다. PUSHCOLOR는 인수로 설정된 속성을 푸시합니다.이 속성은 일반적으로 색상 상수 문자열입니다. 현재 속성이 무엇인지 터미널에 요청할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5aecbb74b57e959a8f88701a03d15ec0b4986702" translate="yes" xml:space="preserve">
          <source>will not. If you are using background colors, you will probably want to either use say() (in newer versions of Perl) or print the newline with a separate print statement to avoid confusing the terminal.</source>
          <target state="translated">하지 않을 것이다. 배경색을 사용하는 경우 say () (최신 버전의 Perl)를 사용하거나 터미널을 혼동하지 않도록 별도의 print 문으로 줄 바꿈을 인쇄 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51cb32ab55ef73ac4c7e3b3c80f2c3a6bd4c4502" translate="yes" xml:space="preserve">
          <source>will output &quot;o&quot; twice.</source>
          <target state="translated">&quot;o&quot;를 두 번 출력합니다.</target>
        </trans-unit>
        <trans-unit id="a06e774b79ee30cc4528a712043ad54d3f5a1a0f" translate="yes" xml:space="preserve">
          <source>will output &lt;code&gt;0&lt;/code&gt; on default 32-bit builds, since &lt;code&gt;bigint&lt;/code&gt; never sees the string literals. To ensure the expression is all treated as &lt;code&gt;Math::BigInt&lt;/code&gt; objects, use a literal number in the expression:</source>
          <target state="translated">&lt;code&gt;bigint&lt;/code&gt; 는 문자열 리터럴을 볼 수 없으므로 기본 32 비트 빌드에서 &lt;code&gt;0&lt;/code&gt; 을 출력 합니다. 표현식이 모두 &lt;code&gt;Math::BigInt&lt;/code&gt; 객체 로 취급되도록하려면 표현식 에 리터럴 숫자를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="07967563cc177965a7ed97715e81d6fdae7cbfa8" translate="yes" xml:space="preserve">
          <source>will output &lt;code&gt;0&lt;/code&gt; on default 32-bit builds, since &lt;code&gt;bigrat&lt;/code&gt; never sees the string literals. To ensure the expression is all treated as &lt;code&gt;Math::BigInt&lt;/code&gt; or &lt;code&gt;BigFloat&lt;/code&gt; objects, use a literal number in the expression:</source>
          <target state="translated">&lt;code&gt;bigrat&lt;/code&gt; 은 문자열 리터럴을 볼 수 없으므로 기본 32 비트 빌드에서 &lt;code&gt;0&lt;/code&gt; 을 출력 합니다. 표현식이 모두 &lt;code&gt;Math::BigInt&lt;/code&gt; 또는 &lt;code&gt;BigFloat&lt;/code&gt; 오브젝트 로 처리되도록하려면 표현식 에 리터럴 숫자를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b71659f573a74f6d9f73f656d46b8610e6881c01" translate="yes" xml:space="preserve">
          <source>will output &lt;code&gt;0&lt;/code&gt; on default 32-bit builds, since &lt;code&gt;bigrat&lt;/code&gt; never sees the string literals. To ensure the expression is all treated as &lt;code&gt;Math::BigInt&lt;/code&gt; or &lt;code&gt;Math::BigRat&lt;/code&gt; objects, use a literal number in the expression:</source>
          <target state="translated">&lt;code&gt;bigrat&lt;/code&gt; 은 문자열 리터럴을 볼 수 없으므로 기본 32 비트 빌드에서 &lt;code&gt;0&lt;/code&gt; 을 출력 합니다. 표현식이 모두 &lt;code&gt;Math::BigInt&lt;/code&gt; 또는 &lt;code&gt;Math::BigRat&lt;/code&gt; 객체 로 처리되도록하려면 표현식 에 리터럴 숫자를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5d7a9b3fb1f88c1e1d18d8b9c37f765ed993681d" translate="yes" xml:space="preserve">
          <source>will place into $count the number of digit groups found in $string. This happens because the pattern match is in list context (since it is being assigned to the empty list), and will therefore return a list of all matching parts of the string. The list assignment in scalar context will translate that into the number of elements (here, the number of times the pattern matched) and assign that to $count. Note that simply using</source>
          <target state="translated">$ string에있는 숫자 그룹의 수를 $ count에 넣습니다. 패턴 일치가 목록 컨텍스트에 있기 때문에 (빈 목록에 지정되기 때문에) 문자열의 일치하는 모든 부분의 목록을 리턴합니다. 스칼라 컨텍스트의 목록 지정은이를 요소 수 (여기서는 패턴이 일치 한 횟수)로 변환하여 $ count에 지정합니다. 단순히</target>
        </trans-unit>
        <trans-unit id="158b4d249db9d3c641342d6ffe07a57aa001b196" translate="yes" xml:space="preserve">
          <source>will preserve the error and restore reliable error handling.</source>
          <target state="translated">오류를 보존하고 안정적인 오류 처리를 복원합니다.</target>
        </trans-unit>
        <trans-unit id="d893c24989b32aee817b8346e7ad376f369b2d24" translate="yes" xml:space="preserve">
          <source>will print</source>
          <target state="translated">인쇄합니다</target>
        </trans-unit>
        <trans-unit id="fd687fe7714e5a81fa512dd577f023b74092d11e" translate="yes" xml:space="preserve">
          <source>will print 2, not 1. The only exception is that regular expressions have &lt;code&gt;\X&lt;/code&gt; for matching an extended grapheme cluster. (Thus &lt;code&gt;\X&lt;/code&gt; in a regular expression would match the entire sequence of both the example characters.)</source>
          <target state="translated">유일한 예외는 정규 표현식 에 확장 grapheme 클러스터와 일치하는 &lt;code&gt;\X&lt;/code&gt; 가 있다는 것 입니다. ( 정규 표현식에서 &lt;code&gt;\X&lt;/code&gt; 는 두 예제 문자의 전체 순서와 일치합니다.)</target>
        </trans-unit>
        <trans-unit id="5094300d0d532d8932e70f6691fa42ee86dfc712" translate="yes" xml:space="preserve">
          <source>will print nothing but newlines. Use either &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt; or &lt;a href=&quot;bigfloat&quot;&gt;Math::BigFloat&lt;/a&gt; to get this to work.</source>
          <target state="translated">줄 바꿈 만 인쇄합니다. 중 사용 &lt;a href=&quot;../bignum&quot;&gt;의 bignum&lt;/a&gt; 또는 &lt;a href=&quot;bigfloat&quot;&gt;수학 :: BigFloat을&lt;/a&gt; 일이 얻을.</target>
        </trans-unit>
        <trans-unit id="5f20759593b002250a08ac3165608cf59d1d82f9" translate="yes" xml:space="preserve">
          <source>will print out:</source>
          <target state="translated">인쇄합니다 :</target>
        </trans-unit>
        <trans-unit id="2e9aaf473ea286c62a53337f9951358323be6844" translate="yes" xml:space="preserve">
          <source>will print the number of items returned from the Perl subroutine and their value (for simplicity it assumes that they are integer). So if</source>
          <target state="translated">Perl 서브 루틴에서 리턴 된 항목 수와 해당 값을 인쇄합니다 (간단하게하기 위해 정수라고 가정 함). 그래서 만약</target>
        </trans-unit>
        <trans-unit id="f115f3fe71ae59d269dceb54d217a18d98aaf788" translate="yes" xml:space="preserve">
          <source>will print the sorted contents of the file named</source>
          <target state="translated">이름이 지정된 파일의 정렬 된 내용을 인쇄합니다</target>
        </trans-unit>
        <trans-unit id="898011ad8ba0ad932dc0a21e6656a3baf0ccd836" translate="yes" xml:space="preserve">
          <source>will print: 5.8, -5, 7, 3, 2, 10, 1, 2147483647, -2147483648</source>
          <target state="translated">인쇄 : 5.8, -5, 7, 3, 2, 10, 1, 2147483647, -2147483648</target>
        </trans-unit>
        <trans-unit id="a2df2915d4c95ac1935b8649d919c89f0b71efb7" translate="yes" xml:space="preserve">
          <source>will produce HTML pages from POD.</source>
          <target state="translated">POD에서 HTML 페이지를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="35a48bc9e89843fe90d9679e3c72dc42ba9f3426" translate="yes" xml:space="preserve">
          <source>will produce a customized executable.</source>
          <target state="translated">사용자 정의 된 실행 파일을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="37ce8d4fdf5864184a859e4556249981464a898f" translate="yes" xml:space="preserve">
          <source>will produce error messages, usually caused by the fact that there are still threads running when the program exits. You should not be alarmed by this.</source>
          <target state="translated">일반적으로 프로그램이 종료 될 때 여전히 스레드가 실행되고 있기 때문에 오류 메시지가 생성됩니다. 이것에 놀라지 마십시오.</target>
        </trans-unit>
        <trans-unit id="40a447e2e638aff917b8a98c4dbccbd2ef36fe3c" translate="yes" xml:space="preserve">
          <source>will read a record of no more than 32768 characters from $fh. If you're not reading from a record-oriented file (or your OS doesn't have record-oriented files), then you'll likely get a full chunk of data with every read. If a record is larger than the record size you've set, you'll get the record back in pieces. Trying to set the record size to zero or less is deprecated and will cause $/ to have the value of &quot;undef&quot;, which will cause reading in the (rest of the) whole file.</source>
          <target state="translated">$ fh에서 32768 자 이하의 레코드를 읽습니다. 레코드 지향 파일에서 읽지 않는 경우 (또는 OS에 레코드 지향 파일이없는 경우) 읽을 때마다 전체 데이터 청크를 얻을 수 있습니다. 레코드가 설정 한 레코드 크기보다 큰 경우 레코드를 조각으로 다시 가져옵니다. 레코드 크기를 0 이하로 설정하면 더 이상 사용되지 않으며 $ /에 &quot;undef&quot;값이 지정되어 전체 파일의 나머지 부분을 읽게됩니다.</target>
        </trans-unit>
        <trans-unit id="9dbce3601b41181a479b14fe24812dbea1320b3d" translate="yes" xml:space="preserve">
          <source>will remain open. The fact that Berkeley DB then reports the attempt to open a database that is already open via the catch-all &quot;Invalid argument&quot; doesn't help.</source>
          <target state="translated">열린 상태로 유지됩니다. 그런 다음 버클리 DB는 포괄적 인 &quot;잘못된 인수&quot;를 통해 이미 열려있는 데이터베이스를 열려고 시도했다는 사실이 도움이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6f37ba2b9a5fbee754eb7c8269a813aeb18cd4ca" translate="yes" xml:space="preserve">
          <source>will require a leading colon (as in &lt;code&gt;&quot;=for :formatname&quot;&lt;/code&gt; , or &lt;code&gt;&quot;=begin :formatname&quot; ... &quot;=end :formatname&quot;&lt;/code&gt; ), to signal that the text is not raw data, but instead</source>
          <target state="translated">텍스트가 원시 데이터가 아니라 대신 신호임을 &lt;code&gt;&quot;=begin :formatname&quot; ... &quot;=end :formatname&quot;&lt;/code&gt; 콜론 ( &lt;code&gt;&quot;=for :formatname&quot;&lt;/code&gt; 또는 &quot;= begin : formatname&quot;... &quot;= end : formatname&quot; )이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="00e02cdb26815577afd3b77c2b81936feda569cf" translate="yes" xml:space="preserve">
          <source>will reset the display mode afterward, whereas:</source>
          <target state="translated">나중에 디스플레이 모드를 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="cfd246ad185bc0482eb908f8133758235cbeffe1" translate="yes" xml:space="preserve">
          <source>will restore the value of &lt;code&gt;SV&lt;/code&gt; using the stored value. It doesn't handle magic. Use &lt;code&gt;save_scalar&lt;/code&gt; if magic is affected.</source>
          <target state="translated">저장된 값을 사용하여 &lt;code&gt;SV&lt;/code&gt; 값을 복원합니다 . 마법을 다루지 않습니다. 마법이 영향을받는 경우 &lt;code&gt;save_scalar&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bcf47e23e9e89e816d5345e18bf5cc985f8e41ea" translate="yes" xml:space="preserve">
          <source>will result in the &lt;code&gt;@_&lt;/code&gt; array having the following values:</source>
          <target state="translated">될 것이다 &lt;code&gt;@_&lt;/code&gt; 의 다음 값을 갖는 배열 :</target>
        </trans-unit>
        <trans-unit id="b214f323b0d930bc4b48c529ba1af86a9de0d7a3" translate="yes" xml:space="preserve">
          <source>will set &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; , but</source>
          <target state="translated">설정합니다 , &lt;code&gt;v&lt;/code&gt; 및 &lt;code&gt;x&lt;/code&gt; 하지만, &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f66b27e740d658271832997896a10c6bbc45b211" translate="yes" xml:space="preserve">
          <source>will set &lt;code&gt;vax&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;vax&lt;/code&gt; 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="abeb9a24b6c6f570b68ade97160028350917ace8" translate="yes" xml:space="preserve">
          <source>will set all three.</source>
          <target state="translated">세 가지를 모두 설정합니다.</target>
        </trans-unit>
        <trans-unit id="6454ef3b29477d49c2c7980e79cde8b57c1ed94f" translate="yes" xml:space="preserve">
          <source>will still exist after the call to</source>
          <target state="translated">에 전화 한 후에도 여전히 존재합니다</target>
        </trans-unit>
        <trans-unit id="588ec16637097d7d1d0638d77c96a8a5032b93a3" translate="yes" xml:space="preserve">
          <source>will test only the regex, which causes both operands to be treated as boolean. Watch out for this one, then, because an arrayref is always a true value, which makes it effectively redundant. Not a good idea.</source>
          <target state="translated">정규 표현식 만 테스트하여 두 피연산자가 모두 부울로 처리됩니다. arrayref는 항상 실제 값이므로 효과적으로 중복되기 때문에이 점을주의하십시오. 좋은 생각이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="bcbf4eab8642ab8923d66dad2868cf95ad241494" translate="yes" xml:space="preserve">
          <source>will then attempt to:</source>
          <target state="translated">그런 다음 시도합니다 :</target>
        </trans-unit>
        <trans-unit id="9f4bb9d65e83043ff5b7e82034ad61c789030aed" translate="yes" xml:space="preserve">
          <source>will transliterate any A to X.</source>
          <target state="translated">A를 X로 음역합니다.</target>
        </trans-unit>
        <trans-unit id="8c5ff1dc5075b42cbe189997bcd24a4dd7044963" translate="yes" xml:space="preserve">
          <source>will trigger two filters, one for the reading of the key and one for the reading of the value.</source>
          <target state="translated">하나는 키를 읽고 다른 하나는 값을 읽는 두 개의 필터를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="3ed3f8cd65c348f27de4a80b666167e4693d1656" translate="yes" xml:space="preserve">
          <source>will try loading the classes YourProjClass::en_us (note lowercase!), YourProjClass::fr, YourProjClass::kon, YourProjClass::i_klingon and YourProjClass::i_klingon_romanized. (And it'll stop at the first one that actually loads.)</source>
          <target state="translated">YourProjClass :: en_us (소문자 소문자!), YourProjClass :: fr, YourProjClass :: kon, YourProjClass :: i_klingon 및 YourProjClass :: i_klingon_romanized 클래스를로드하려고합니다. (그리고 실제로로드되는 첫 번째 것에서 멈출 것입니다.)</target>
        </trans-unit>
        <trans-unit id="c097b2a013bfe704dfa7b64798a8d4b40a34ed49" translate="yes" xml:space="preserve">
          <source>will use smart matching (only the first operand is considered), whereas</source>
          <target state="translated">스마트 매칭을 사용하지만 (첫 번째 피연산자 만 고려 됨)</target>
        </trans-unit>
        <trans-unit id="5cc2cc537da4d8f70033128374e99deb871707f6" translate="yes" xml:space="preserve">
          <source>will use smartmatching because only</source>
          <target state="translated">스마트 매칭을 사용하므로</target>
        </trans-unit>
        <trans-unit id="514139923bd059976cc81a9bef6162ccd170175a" translate="yes" xml:space="preserve">
          <source>will usually call</source>
          <target state="translated">보통 전화 할 것이다</target>
        </trans-unit>
        <trans-unit id="81fcf2d95c7bfeca0899d8452fef6f4f9bd6f8d9" translate="yes" xml:space="preserve">
          <source>will work as well.)</source>
          <target state="translated">잘 작동합니다.)</target>
        </trans-unit>
        <trans-unit id="2892afe1b68a0f4ac688e2819db40fcb2dbe61aa" translate="yes" xml:space="preserve">
          <source>will work correctly. These mixed cases don't do always work when using Math::BigInt or Math::BigFloat alone, or at least not in the way normal Perl scalars work.</source>
          <target state="translated">제대로 작동합니다. 이러한 혼합 사례는 Math :: BigInt 또는 Math :: BigFloat를 단독으로 사용하거나 최소한 일반 Perl 스칼라가 작동하지 않는 경우 항상 작동하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="bc5353c166b1ce6a2755fffe1f9473c7c604fb2e" translate="yes" xml:space="preserve">
          <source>will work in many but not all cases. You see, it's too simple-minded for certain kinds of C programs, in particular, those with what appear to be comments in quoted strings. For that, you'd need something like this, created by Jeffrey Friedl and later modified by Fred Curtis.</source>
          <target state="translated">많은 경우에 작동하지만 모든 경우에 작동하지는 않습니다. 알다시피, 특정 종류의 C 프로그램, 특히 인용 된 문자열에 주석으로 보이는 프로그램에는 너무 단순합니다. 이를 위해서는 Jeffrey Friedl에 의해 생성되고 나중에 Fred Curtis에 의해 수정 된 이와 같은 것이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="786d912fad11b712a3268fcedeb0dec988a5d652" translate="yes" xml:space="preserve">
          <source>will work with earlier versions of Perl 5. Hence, such a module may take full advantage of syntactical and other improvements in Perl 5 blead.</source>
          <target state="translated">따라서 이러한 모듈은 Perl 5 블리드의 구문 및 기타 개선 사항을 최대한 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d11df7412eb53de0f032fa263537630590c98be8" translate="yes" xml:space="preserve">
          <source>win32/</source>
          <target state="translated">win32/</target>
        </trans-unit>
        <trans-unit id="ef20e66907c936dd8f32cedd2cde044f7f103034" translate="yes" xml:space="preserve">
          <source>win32/perllib.c</source>
          <target state="translated">win32/perllib.c</target>
        </trans-unit>
        <trans-unit id="ffc229a00767de35e4be6135e2ffebcf9882c38a" translate="yes" xml:space="preserve">
          <source>wince</source>
          <target state="translated">wince</target>
        </trans-unit>
        <trans-unit id="123bb8126c34dd474d44011b10cfbf904c3172d4" translate="yes" xml:space="preserve">
          <source>wince port was kept in the same</source>
          <target state="translated">wince 포트는 동일하게 유지되었습니다</target>
        </trans-unit>
        <trans-unit id="5cd6bd4c16cc2a47ce31db4e0755a63599fc21d0" translate="yes" xml:space="preserve">
          <source>wince/Makefile.ce</source>
          <target state="translated">wince/Makefile.ce</target>
        </trans-unit>
        <trans-unit id="8fcd25a39d2037183044a8897e9a5333d727fded" translate="yes" xml:space="preserve">
          <source>with</source>
          <target state="translated">with</target>
        </trans-unit>
        <trans-unit id="516d8aa61b6759073fd78a57717de8007b3370ce" translate="yes" xml:space="preserve">
          <source>with 0 if it does, 1 if it does not (ie. shell's idea of true and false).</source>
          <target state="translated">그렇다면 0, 그렇지 않으면 1 (즉, 쉘의 참과 거짓에 대한 아이디어).</target>
        </trans-unit>
        <trans-unit id="38b9a576bee545c23ad008343813d9e755e740e0" translate="yes" xml:space="preserve">
          <source>with 0 if it does, 1 if it does not.</source>
          <target state="translated">있는 경우 0, 그렇지 않은 경우 1</target>
        </trans-unit>
        <trans-unit id="fd393d67aeb1a238c4b9b75ace210101e95a963c" translate="yes" xml:space="preserve">
          <source>with &lt;code&gt;$1&lt;/code&gt; being the line number for the next line, and &lt;code&gt;$3&lt;/code&gt; being the optional filename (specified with or without quotes). Note that no whitespace may precede the &lt;code&gt;#&lt;/code&gt; , unlike modern C preprocessors.</source>
          <target state="translated">와 &lt;code&gt;$1&lt;/code&gt; 라인의 다음 라인 수, 인 &lt;code&gt;$3&lt;/code&gt; (선택 사양) 파일 이름 인 (또는 인용 부호없이 지정). 최신 C 전처리 기와는 달리 &lt;code&gt;#&lt;/code&gt; 앞에 공백이 없어야합니다 .</target>
        </trans-unit>
        <trans-unit id="dd277e84169e71230b173e5e86d5c72e9dd4d149" translate="yes" xml:space="preserve">
          <source>with C</source>
          <target state="translated">C로</target>
        </trans-unit>
        <trans-unit id="5f35039fcfb7ca39f0e93041f2c52c34be88131b" translate="yes" xml:space="preserve">
          <source>with DOS hooks is available in</source>
          <target state="translated">DOS 후크 포함</target>
        </trans-unit>
        <trans-unit id="f257153d465d0a7a17934523c7043d1cba8cb62c" translate="yes" xml:space="preserve">
          <source>with DTrace support enabled.</source>
          <target state="translated">DTrace 지원이 활성화 된 상태.</target>
        </trans-unit>
        <trans-unit id="79e46a1b41acc15ccc42adaa2b069f673632f7cc" translate="yes" xml:space="preserve">
          <source>with Pre-5.0 MakeMakers. Since version 5.00 of MakeMaker such a line can be deleted safely. MakeMaker recognizes when there's nothing to be linked.</source>
          <target state="translated">5.0 이전 MakeMakers MakeMaker 버전 5.00부터 이러한 행을 안전하게 삭제할 수 있습니다. MakeMaker는 연결할 것이 없을 때 인식합니다.</target>
        </trans-unit>
        <trans-unit id="902f1c78737d167fe1b8e5be3f95f9481cbb5856" translate="yes" xml:space="preserve">
          <source>with a field hash, the entry will be collected, even if it was later overwritten with a plain scalar key (every positive integer is a candidate). This is true even if the original entry was deleted in the meantime. In fact, deletion from a field hash, and also a test for existence constitute</source>
          <target state="translated">필드 해시를 사용하면 나중에 일반 스칼라 키로 덮어 쓴 경우에도 항목이 수집됩니다 (모든 양의 정수는 후 보임). 그 동안 원래 항목이 삭제 된 경우에도 마찬가지입니다. 실제로 필드 해시에서 삭제 및 존재 테스트도 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="6b1ee94282ce6cd2f8ed1cd3d21d10ed8a2ffaba" translate="yes" xml:space="preserve">
          <source>with a shell</source>
          <target state="translated">껍질로</target>
        </trans-unit>
        <trans-unit id="6712fdd90b5e830ff760a98c106a30072131fe7e" translate="yes" xml:space="preserve">
          <source>with a special meaning described here or above. You can cause characters that normally function as metacharacters to be interpreted literally by prefixing them with a &quot;\&quot; (e.g., &quot;\.&quot; matches a &quot;.&quot;, not any character; &quot;\\&quot; matches a &quot;\&quot;). This escape mechanism is also required for the character used as the pattern delimiter.</source>
          <target state="translated">여기 또는 위에 설명 된 특별한 의미로 일반적으로 메타 문자로 기능하는 문자는 앞에 &quot;\&quot;를 붙여서 문자 그대로 해석되도록 할 수 있습니다 (예 : &quot;\.&quot;는 문자가 아닌 &quot;.&quot;와 일치하고 &quot;\\&quot;는 &quot;\&quot;와 일치). 이 이스케이프 메커니즘은 패턴 구분 기호로 사용 된 문자에도 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b805bc366a9ebde9467176c73458adee5451ed76" translate="yes" xml:space="preserve">
          <source>with actual &lt;code&gt;&lt;a href=&quot;../functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; support. Trailing newline is removed. Returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on &lt;code&gt;EOF&lt;/code&gt; .</source>
          <target state="translated">실제 &lt;code&gt;&lt;a href=&quot;../functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 지원. 후행 줄 바꿈이 제거됩니다. &lt;code&gt;EOF&lt;/code&gt; 에 대해 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="90fb5185e4bcea673e4052e2147a5dec2bf61fa2" translate="yes" xml:space="preserve">
          <source>with all the statically loaded extensions built in. Compare the generated</source>
          <target state="translated">정적으로로드 된 모든 확장이 내장되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5634ec8df617c002f5cf19e1a0d68429da0d491c" translate="yes" xml:space="preserve">
          <source>with any non-default flags appearing between the caret and the colon. A test that looks at such stringification thus doesn't need to have the system default flags hard-coded in it, just the caret. If new flags are added to Perl, the meaning of the caret's expansion will change to include the default for those flags, so the test will still work, unchanged.</source>
          <target state="translated">캐럿과 콜론 사이에 기본값이 아닌 플래그가 표시됩니다. 따라서 그러한 문자열을 보는 테스트는 시스템 기본 플래그를 하드 코딩 할 필요가 없으며 캐럿 만 필요합니다. 새 플래그가 Perl에 추가되면, 캐럿 확장의 의미는 해당 플래그의 기본값을 포함하도록 변경되므로 테스트는 변경없이 계속 작동합니다.</target>
        </trans-unit>
        <trans-unit id="bb83d536946bb8d10aca0b9c5349a4fa97876fb1" translate="yes" xml:space="preserve">
          <source>with arguments &lt;code&gt;arg1 arg2 arg3&lt;/code&gt; the same way as on any other platform, by</source>
          <target state="translated">인수 &lt;code&gt;arg1 arg2 arg3&lt;/code&gt; 을 사용 하여 다른 플랫폼과 동일한 방식으로</target>
        </trans-unit>
        <trans-unit id="e596474483116f71691799bfb6c85c3d8699a856" translate="yes" xml:space="preserve">
          <source>with bugs in memory allocations which are caught by Perl's malloc();</source>
          <target state="translated">Perl의 malloc ()에 의해 잡히는 메모리 할당에 버그가 있습니다.</target>
        </trans-unit>
        <trans-unit id="43e71f90be5e8d458fd62d980464b4dcacad2891" translate="yes" xml:space="preserve">
          <source>with command line &quot;-size 10 -sizes 24 -sizes 48&quot; will perform the equivalent of the assignments</source>
          <target state="translated">명령 줄 &quot;-size 10-sizes 24-sizes 48&quot;을 사용하면 할당과 동일한 기능을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="a6bb8f0d0bfad7a5f424f1936641a121be95eced" translate="yes" xml:space="preserve">
          <source>with contents being (compare with &lt;a href=&quot;#Making-executables-with-a-custom-collection-of-statically-loaded-extensions&quot;&gt;Making executables with a custom collection of statically loaded extensions&lt;/a&gt;)</source>
          <target state="translated">내용이있는 경우 ( &lt;a href=&quot;#Making-executables-with-a-custom-collection-of-statically-loaded-extensions&quot;&gt;정적으로로드 된 확장 프로그램의 사용자 정의 콜렉션으로 실행 파일 작성과&lt;/a&gt; 비교 )</target>
        </trans-unit>
        <trans-unit id="df572e1bbeb0b7187cd03ae0e3427ee531dc9c89" translate="yes" xml:space="preserve">
          <source>with djtarx. If you want to use long file names under w95 and also to get Perl to pass all its tests, don't forget to use</source>
          <target state="translated">djtarx로. w95에서 긴 파일 이름을 사용하고 Perl이 모든 테스트를 통과하게하려면 사용하는 것을 잊지 마십시오.</target>
        </trans-unit>
        <trans-unit id="0a6e45130091d1990376001a155acd12e04c02af" translate="yes" xml:space="preserve">
          <source>with invaluable help from Chris Nandor, and valuable help from Brandon Allbery, Charles Bailey, Graham Barr, Dominic Dunlop, Jarkko Hietaniemi, Ben Holzman, Tom Horsley, Nick Ing-Simmons, Tuomas J. Lukka, Laszlo Molnar, Alan Olsen, Peter Prymmer, Gurusamy Sarathy, Christoph Spalinger, Dan Sugalski, Larry Virden, and Ilya Zakharevich.</source>
          <target state="translated">Chris Nandor의 소중한 도움과 Brandon Allbery, Charles Bailey, Graham Barr, Dominic Dunlop, Jarkko Hietaniemi, Ben Holzman, Tom Horsley, Nick Ing-Simmons, Tuomas J. Lukka, Laszlo Molnar, Alan Olsen, Peter Prymmer의 소중한 도움 Gurusamy Sarathy, Christoph Spalinger, Dan Sugalski, Larry Virden 및 Ilya Zakharevich.</target>
        </trans-unit>
        <trans-unit id="65cc0156037f347b1259f3f102b72fce7d5f35cb" translate="yes" xml:space="preserve">
          <source>with libperl, any static extensions (usually just DynaLoader), and any other libraries needed on this system. libperl is usually</source>
          <target state="translated">libperl, 정적 확장 (일반적으로 DynaLoader) 및이 시스템에 필요한 기타 라이브러리가 포함됩니다. libperl은 보통</target>
        </trans-unit>
        <trans-unit id="bf9772e7a963a2d3d329698d4cb2a55502f8d67b" translate="yes" xml:space="preserve">
          <source>with more error checking.</source>
          <target state="translated">더 많은 오류 검사와 함께.</target>
        </trans-unit>
        <trans-unit id="83256d944b6616f13d11d6f626aca53da1031053" translate="yes" xml:space="preserve">
          <source>with nonempty prefix1 and prefix2. If &lt;code&gt;prefix1&lt;/code&gt; is indeed a prefix of a builtin library search path, prefix2 is substituted. The error may appear if components are not found, or are too long. See &quot;PERLLIB_PREFIX&quot; in &lt;a href=&quot;perlos2&quot;&gt;perlos2&lt;/a&gt;.</source>
          <target state="translated">비어 있지 않은 접두사 1과 접두사 2로. 경우 &lt;code&gt;prefix1&lt;/code&gt; 은 참으로 내장 라이브러리 검색 경로의 접두어, prefix2 대체됩니다. 구성 요소를 찾을 수 없거나 너무 길면 오류가 표시 될 수 있습니다. 에서 &quot;PERLLIB_PREFIX&quot;을 참조하십시오 &lt;a href=&quot;perlos2&quot;&gt;perlos2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fb3f3ef30b8362c52d5cc55a8fa4f09f4693fecb" translate="yes" xml:space="preserve">
          <source>with one range: an anonymous array with a single element that consists of another anonymous array whose first element is the first code point in the block, and whose second element is the final code point in the block. On an EBCDIC platform, the first two Unicode blocks are not contiguous. Their range sets are lists containing</source>
          <target state="translated">첫 번째 요소가 블록의 첫 번째 코드 포인트이고 두 번째 요소가 블록의 마지막 코드 포인트 인 다른 익명 배열로 구성된 단일 요소가있는 익명 배열. EBCDIC 플랫폼에서 처음 두 개의 유니 코드 블록은 인접하지 않습니다. 그들의 범위 세트는 다음을 포함하는 목록입니다</target>
        </trans-unit>
        <trans-unit id="ad93216dd3f12b7821d87a82a121ecedc2fe0262" translate="yes" xml:space="preserve">
          <source>with other auxiliary files, but, and this is important to note, there should be &lt;b&gt;no&lt;/b&gt;</source>
          <target state="translated">기타 보조 파일,하지만, 이것이 중요하다으로,이 없어야 &lt;b&gt;더&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fb0e475b39d05deac173d43929afb30eefa9a066" translate="yes" xml:space="preserve">
          <source>with some customization slots left out to be filled later.</source>
          <target state="translated">일부 사용자 지정 슬롯은 나중에 채울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="578150dd4f4464b258a72af475d097b197c86ecf" translate="yes" xml:space="preserve">
          <source>with such a routine added (and slightly modified str()):</source>
          <target state="translated">그런 루틴이 추가되고 약간 수정 된 str () :</target>
        </trans-unit>
        <trans-unit id="0c303466efe4cbf12a616af1540bc1eb7aaeaf47" translate="yes" xml:space="preserve">
          <source>with the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d1c3bf8c1f9945ec4599b301b51d74a3a85654a" translate="yes" xml:space="preserve">
          <source>with the array elements, returning the number of matches found.</source>
          <target state="translated">배열 요소와 함께 발견 된 일치 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="06a358e9a286ee4b634c109bfb039300741fcb98" translate="yes" xml:space="preserve">
          <source>with the first line being</source>
          <target state="translated">첫 줄이</target>
        </trans-unit>
        <trans-unit id="39ef66642cc8f022fcb29b6192f16996d968e41f" translate="yes" xml:space="preserve">
          <source>with the given set of sections. See &lt;b&gt;add_selection()&lt;/b&gt; for adding to the current set of selected sections.</source>
          <target state="translated">주어진 섹션 세트로. 현재 선택된 섹션 세트에 추가하려면 &lt;b&gt;add_selection ()&lt;/b&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="681d9ba240a75cd0133e9a797e48af7f60cc1289" translate="yes" xml:space="preserve">
          <source>with the key specified by</source>
          <target state="translated">로 지정된 키로</target>
        </trans-unit>
        <trans-unit id="fc8ddfc8af720ff32b46e111b20ee99ab44a3ee8" translate="yes" xml:space="preserve">
          <source>with the options '--url &lt;a href=&quot;http://example.com&quot;&gt;http://example.com&lt;/a&gt;'. When running multiple tests they will each receive the same arguments.</source>
          <target state="translated">'--url &lt;a href=&quot;http://example.com&quot;&gt;http://example.com&lt;/a&gt; ' 옵션을 사용하십시오 . 여러 테스트를 실행할 때 각각 동일한 인수를받습니다.</target>
        </trans-unit>
        <trans-unit id="9af249b71f06549e6ec04dac84cfb0149e01d8b1" translate="yes" xml:space="preserve">
          <source>with the same effect.</source>
          <target state="translated">같은 효과로.</target>
        </trans-unit>
        <trans-unit id="22d6b042eb59b4513f175226eb07a3dda4da0955" translate="yes" xml:space="preserve">
          <source>with the same result as</source>
          <target state="translated">와 같은 결과</target>
        </trans-unit>
        <trans-unit id="d916cf8b9311e482b651049d8b87bf349a501880" translate="yes" xml:space="preserve">
          <source>with the sequence &lt;code&gt;1100&lt;/code&gt; repeating again and again. In addition to this limitation, the exponent of the binary number is also restricted when it is represented as a floating point number. On typical hardware, floating point values can store numbers with up to 53 binary digits, and with binary exponents between -1024 and 1024. In decimal representation this is close to 16 decimal digits and decimal exponents in the range of -304..304. The upshot of all this is that Perl cannot store a number like 12345678901234567 as a floating point number on such architectures without loss of information.</source>
          <target state="translated">시퀀스 &lt;code&gt;1100&lt;/code&gt; 이 반복해서 반복됩니다. 이 제한 사항 외에도 이진 숫자의 지수는 부동 소수점 숫자로 표시 될 때 제한됩니다. 일반적인 하드웨어에서 부동 소수점 값은 최대 53 개의 이진수를 사용하고 -1024와 1024 사이의 이진 지수를 가진 숫자를 저장할 수 있습니다. 10 진수로 표시하면 -304..304 범위의 10 진수와 16 진수에 가깝습니다. 이 모든 결론은 Perl이 12345678901234567과 같은 숫자를 정보 손실없이 그러한 아키텍처에서 부동 소수점 숫자로 저장할 수 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6ba1d9aa0bd57431c1856954244f3cbc94acd62d" translate="yes" xml:space="preserve">
          <source>with these bytes using this option.</source>
          <target state="translated">이 옵션을 사용하여 이러한 바이트와 함께.</target>
        </trans-unit>
        <trans-unit id="9f47eb77d09add43952b7bda3f6a0a9cdacda272" translate="yes" xml:space="preserve">
          <source>with this one, once the &lt;code&gt;o&lt;/code&gt; ption &lt;code&gt;frame=2&lt;/code&gt; has been set:</source>
          <target state="translated">이것에 의해, 일단 &lt;code&gt;o&lt;/code&gt; ption의 &lt;code&gt;frame=2&lt;/code&gt; 된 세트를 가지고</target>
        </trans-unit>
        <trans-unit id="f42ef62128025c7fd38f4952b8a2dc53beb818e7" translate="yes" xml:space="preserve">
          <source>within</source>
          <target state="translated">within</target>
        </trans-unit>
        <trans-unit id="92f70e05ed425bf86c4992009349d575e4339965" translate="yes" xml:space="preserve">
          <source>within the affected package, but across scopes.</source>
          <target state="translated">영향을받는 패키지 내에서 또는 범위 내에서</target>
        </trans-unit>
        <trans-unit id="de8017cefaab0d61aa697455fcae07e9312b74bc" translate="yes" xml:space="preserve">
          <source>within the referenced group is used as an independent subpattern in place of the group reference itself. Because the group reference may be contained</source>
          <target state="translated">참조 된 그룹 내에서 그룹 참조 자체 대신 독립 서브 패턴으로 사용됩니다. 그룹 참조가 포함될 수 있기 때문에</target>
        </trans-unit>
        <trans-unit id="0d4e654c613ea68bffeeab1587b7dbac44826c2b" translate="yes" xml:space="preserve">
          <source>without</source>
          <target state="translated">without</target>
        </trans-unit>
        <trans-unit id="10f2461de60c6d5b4ff8c4b7507377311e349c19" translate="yes" xml:space="preserve">
          <source>without LIB, setting PREFIX replaces the initial &lt;code&gt;$Config{prefix}&lt;/code&gt; part of those INSTALL* arguments, even if the latter are explicitly set (but are set to still start with &lt;code&gt;$Config{prefix}&lt;/code&gt; ).</source>
          <target state="translated">LIB가 없으면 PREFIX를 설정 하면 INSTALL * 인수 의 초기 &lt;code&gt;$Config{prefix}&lt;/code&gt; 부분이 명시 적으로 설정 되더라도 ( &lt;code&gt;$Config{prefix}&lt;/code&gt; 시작하도록 설정되어 있음) 대체 됩니다 .</target>
        </trans-unit>
        <trans-unit id="8a80d0259d1e71d6750796bdfe9afa977177dab1" translate="yes" xml:space="preserve">
          <source>without a good reason.</source>
          <target state="translated">정당한 이유없이</target>
        </trans-unit>
        <trans-unit id="c2ca9034d0099c94e02d85eb5ba30cf9f74f58f0" translate="yes" xml:space="preserve">
          <source>without the newlines.</source>
          <target state="translated">줄 바꿈없이.</target>
        </trans-unit>
        <trans-unit id="4732a6d7f96eade3f478fdd4097e2f5ce9f0b28d" translate="yes" xml:space="preserve">
          <source>won't be run at all</source>
          <target state="translated">전혀 실행되지 않습니다</target>
        </trans-unit>
        <trans-unit id="18c4254d09ff75421e3936447920117069935d2e" translate="yes" xml:space="preserve">
          <source>won't recursively apply those macros for you.</source>
          <target state="translated">해당 매크로를 재귀 적으로 적용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3cbcd90adc4b192a87a625850b7f231caddf0eb3" translate="yes" xml:space="preserve">
          <source>word</source>
          <target state="translated">word</target>
        </trans-unit>
        <trans-unit id="c614707e1344dd5a41b584a7fa3720507a41566c" translate="yes" xml:space="preserve">
          <source>word anchor</source>
          <target state="translated">단어 앵커</target>
        </trans-unit>
        <trans-unit id="d44b255df34f22674d602b2084de78dd16835268" translate="yes" xml:space="preserve">
          <source>wordmatch-line.html</source>
          <target state="translated">wordmatch-line.html</target>
        </trans-unit>
        <trans-unit id="e274eeff768c6396088ec6eb091f4bf4d47ab1e0" translate="yes" xml:space="preserve">
          <source>work</source>
          <target state="translated">work</target>
        </trans-unit>
        <trans-unit id="6c6b6f215bf47eca2a6fa7e244846ed1b5e4779d" translate="yes" xml:space="preserve">
          <source>work in this construct, because modifiers don't take loop labels. Sorry. You can always put another block inside of it (for &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;) or around it (for &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;) to do that sort of thing. For &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;, just double the braces:</source>
          <target state="translated">수정자는 루프 레이블을 사용하지 않기 때문에이 구문에서 작동합니다. 죄송합니다. 항상 다른 블록을 그 안에 ( &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; ) 또는 주위에 ( &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; ) 넣어서 그런 종류의 일을 할 수 있습니다. 를 들어 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; , 그냥 괄호를 두 배로 :</target>
        </trans-unit>
        <trans-unit id="62bee0aec6969f0ad0809c8d6cc21d4734187295" translate="yes" xml:space="preserve">
          <source>work properly on native code points and strings.</source>
          <target state="translated">기본 코드 포인트 및 문자열에서 올바르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e912ba21c9cf05d0fc8a8967f5359aab2729eca4" translate="yes" xml:space="preserve">
          <source>work under OS/390 and on the Macintosh; you probably don't want to use them in new code.</source>
          <target state="translated">OS / 390 및 Macintosh에서 작동합니다. 아마도 새 코드에서 사용하고 싶지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="12b6bdd47224ffe593cf3bd066979ef986b0dfa4" translate="yes" xml:space="preserve">
          <source>work within a &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; { } while&lt;/code&gt; construct. See &lt;a href=&quot;perlsyn#Loop-Control&quot;&gt;Loop Control in perlsyn&lt;/a&gt;.</source>
          <target state="translated">구성 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; { } while&lt;/code&gt; &lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {} 내에서 작업하십시오 . &lt;a href=&quot;perlsyn#Loop-Control&quot;&gt;perlsyn의 루프 제어를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="63b2e519f2bfeef08075c12043e9e0b8da4fe0fe" translate="yes" xml:space="preserve">
          <source>work. (This is equivalent to &lt;code&gt;$&lt;i&gt;human&lt;/i&gt;++&lt;/code&gt;, where</source>
          <target state="translated">작업. (이것은 &lt;code&gt;$&lt;i&gt;human&lt;/i&gt;++&lt;/code&gt; 와 같습니다.</target>
        </trans-unit>
        <trans-unit id="10f5ebe6acb4467b71602be4c4fdb44c44fa26b6" translate="yes" xml:space="preserve">
          <source>worker</source>
          <target state="translated">worker</target>
        </trans-unit>
        <trans-unit id="8f69649f0cb724dcfcaf5d34bac347a0650ed559" translate="yes" xml:space="preserve">
          <source>works because &lt;code&gt;$AoA[0]&lt;/code&gt; already held an array reference. If you try that on an undefined variable, you'll take an exception. That's because the implicit derefererence will never autovivify an undefined variable the way &lt;code&gt;@{ }&lt;/code&gt; always will:</source>
          <target state="translated">&lt;code&gt;$AoA[0]&lt;/code&gt; 이미 배열 참조를 보유 했기 때문에 작동합니다 . 정의되지 않은 변수에서 시도하면 예외가 발생합니다. 암시 적 역 참조는 &lt;code&gt;@{ }&lt;/code&gt; 항상 정의하는 방식으로 정의되지 않은 변수를 자동으로 활성화하지 않기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="15124ebfba7fc813f38c973245978f037d3342fc" translate="yes" xml:space="preserve">
          <source>works bottom-up, so does the first pass of perl compilation.</source>
          <target state="translated">상향식으로 작동하므로 펄 컴파일의 첫 번째 패스도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="b2f86c6b40fe0bcf02c6b1cac00b3639a3aa830f" translate="yes" xml:space="preserve">
          <source>works just fine. For some storage methods, you need a little glue.</source>
          <target state="translated">잘 작동합니다. 일부 저장 방법의 경우 약간의 접착제가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d192b622956789bdecb1e8dc26768ccb0a1de12d" translate="yes" xml:space="preserve">
          <source>works like a normal hash, except that it stringifies a</source>
          <target state="translated">일반 해시처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="eef62adcae43a43a24a531e0fcd32b343c0335e6" translate="yes" xml:space="preserve">
          <source>works like the corresponding perl commands.</source>
          <target state="translated">해당 perl 명령처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="278395d966ca8f15d90253e7a54af657001b22d5" translate="yes" xml:space="preserve">
          <source>works out the package name and subroutine name from &lt;code&gt;cv&lt;/code&gt; , and then calls &lt;code&gt;croak()&lt;/code&gt; . Hence if &lt;code&gt;cv&lt;/code&gt; is &lt;code&gt;&amp;amp;ouch::awk&lt;/code&gt; , it would call &lt;code&gt;croak&lt;/code&gt; as:</source>
          <target state="translated">&lt;code&gt;cv&lt;/code&gt; 에서 패키지 이름과 서브 루틴 이름을 처리 한 다음 &lt;code&gt;croak()&lt;/code&gt; 을 호출합니다 . 따라서 &lt;code&gt;cv&lt;/code&gt; 가 &lt;code&gt;&amp;amp;ouch::awk&lt;/code&gt; 인 경우 다음과 같이 &lt;code&gt;croak&lt;/code&gt; 을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="6be0ee6d5b9de8b6dd59c468448f9682ef33c831" translate="yes" xml:space="preserve">
          <source>works? That way you can type a line, get the answer, type a line, get the answer, etc.</source>
          <target state="translated">공장? 그렇게하면 줄을 입력하고 답을 얻거나 줄을 입력하고 답을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0955dd818206a40e89101bb215630d0623e506fc" translate="yes" xml:space="preserve">
          <source>would</source>
          <target state="translated">would</target>
        </trans-unit>
        <trans-unit id="1cd672c18cd6ca58a99d38415467298ac7edcacd" translate="yes" xml:space="preserve">
          <source>would allocate a 64K buffer for use in an emergency. See the</source>
          <target state="translated">응급 상황에 사용할 64K 버퍼를 할당합니다. 참조</target>
        </trans-unit>
        <trans-unit id="0b290e6292697adca00d7d3d5662240ab8fc30bb" translate="yes" xml:space="preserve">
          <source>would be</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b69dbdbceacfeb0d76b23c42db32158c5c4f060" translate="yes" xml:space="preserve">
          <source>would be enough, but having full path would make it easier to use your script under *nix.)</source>
          <target state="translated">충분하지만 전체 경로가 있으면 * nix에서 스크립트를 더 쉽게 사용할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="fac17e9022ec2b662ea926d0797f33367aaf872c" translate="yes" xml:space="preserve">
          <source>would be executed in a manner equivalent to</source>
          <target state="translated">다음과 같은 방식으로 실행됩니다</target>
        </trans-unit>
        <trans-unit id="5b9b72bb55102abb737a9210715fff3a86c182fa" translate="yes" xml:space="preserve">
          <source>would be introduced with:</source>
          <target state="translated">와 함께 소개됩니다 :</target>
        </trans-unit>
        <trans-unit id="ee71ebda44e2dc671943d14d6333655aa8766836" translate="yes" xml:space="preserve">
          <source>would become:</source>
          <target state="translated">될 것입니다 :</target>
        </trans-unit>
        <trans-unit id="fc7bc135c1fe15a09a47ef32c483c004c406321c" translate="yes" xml:space="preserve">
          <source>would cause a longjmp right back to the guard in &lt;code&gt;perl_run&lt;/code&gt; , popping both runops loops, which is clearly incorrect. One way to avoid this is for the tie code to do a &lt;code&gt;JMPENV_PUSH&lt;/code&gt; before executing &lt;code&gt;FETCH&lt;/code&gt; in the inner runops loop, but for efficiency reasons, perl in fact just sets a flag, using &lt;code&gt;CATCH_SET(TRUE)&lt;/code&gt; . The &lt;code&gt;pp_require&lt;/code&gt; , &lt;code&gt;pp_entereval&lt;/code&gt; and &lt;code&gt;pp_entertry&lt;/code&gt; ops check this flag, and if true, they call &lt;code&gt;docatch&lt;/code&gt; , which does a &lt;code&gt;JMPENV_PUSH&lt;/code&gt; and starts a new runops level to execute the code, rather than doing it on the current loop.</source>
          <target state="translated">&lt;code&gt;perl_run&lt;/code&gt; 에서 가드로 longjmp를 다시 발생시켜 두 룬 루프를 모두 터뜨릴 수 있습니다. 이를 피하는 한 가지 방법 은 내부 runops 루프에서 &lt;code&gt;FETCH&lt;/code&gt; 를 실행하기 전에 타이 코드가 &lt;code&gt;JMPENV_PUSH&lt;/code&gt; 를 수행하는 것이지만 효율성상의 이유로 perl은 실제로 &lt;code&gt;CATCH_SET(TRUE)&lt;/code&gt; 사용하여 플래그를 설정합니다 . &lt;code&gt;pp_require&lt;/code&gt; , &lt;code&gt;pp_entereval&lt;/code&gt; 및 &lt;code&gt;pp_entertry&lt;/code&gt; 작전이 플래그를 확인하고, 그들이 전화 true의 경우 &lt;code&gt;docatch&lt;/code&gt; 않습니다, &lt;code&gt;JMPENV_PUSH&lt;/code&gt; 을 하고 시작을 새로운 runops 오히려 전류 루프에 그 일을보다, 코드를 실행하는 수준.</target>
        </trans-unit>
        <trans-unit id="8ebd799d293a64e9ed9d39b91ac1f7fed34f437f" translate="yes" xml:space="preserve">
          <source>would cause the following handlers to be invoked:</source>
          <target state="translated">다음 핸들러가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="2b330e24a100ad409d9215e9accd6009a0f6b093" translate="yes" xml:space="preserve">
          <source>would compile to this:</source>
          <target state="translated">이것을 컴파일합니다 :</target>
        </trans-unit>
        <trans-unit id="c97745307a9b13afa0ef5df546ac7a72284b1bc2" translate="yes" xml:space="preserve">
          <source>would correctly match something like this:</source>
          <target state="translated">다음과 같이 올바르게 일치합니다.</target>
        </trans-unit>
        <trans-unit id="71f0319df98f9c2b350311a9ad295b643da5cc03" translate="yes" xml:space="preserve">
          <source>would do. In scalar context, glob iterates through such filename expansions, returning undef when the list is exhausted. This is the internal function implementing the &lt;code&gt;&amp;lt;*.c&amp;gt;&lt;/code&gt; operator, but you can use it directly. If EXPR is omitted, &lt;code&gt;$_&lt;/code&gt; is used. The &lt;code&gt;&amp;lt;*.c&amp;gt;&lt;/code&gt; operator is discussed in more detail in &lt;a href=&quot;../perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">할것이다. 스칼라 컨텍스트에서 glob은 이러한 파일 이름 확장을 반복하여 목록이 소진되면 undef를 반환합니다. 이것은 &lt;code&gt;&amp;lt;*.c&amp;gt;&lt;/code&gt; 연산자를 구현하는 내부 함수 이지만 직접 사용할 수 있습니다. EXPR을 생략하면 &lt;code&gt;$_&lt;/code&gt; 가 사용됩니다. &lt;code&gt;&amp;lt;*.c&amp;gt;&lt;/code&gt; 오퍼레이터에 자세히 설명되어 &lt;a href=&quot;../perlop#I%2fO-Operators&quot;&gt;perlop에서 I / O 연산자&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f56783a28f8038eb78e33a3c46a24ab091b4d2d" translate="yes" xml:space="preserve">
          <source>would do. In scalar context, glob iterates through such filename expansions, returning undef when the list is exhausted. This is the internal function implementing the &lt;code&gt;&amp;lt;*.c&amp;gt;&lt;/code&gt; operator, but you can use it directly. If EXPR is omitted, &lt;code&gt;$_&lt;/code&gt; is used. The &lt;code&gt;&amp;lt;*.c&amp;gt;&lt;/code&gt; operator is discussed in more detail in &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">할것이다. 스칼라 컨텍스트에서 glob은 이러한 파일 이름 확장을 반복하여 목록이 소진되면 undef를 반환합니다. 이것은 &lt;code&gt;&amp;lt;*.c&amp;gt;&lt;/code&gt; 연산자를 구현하는 내부 함수 이지만 직접 사용할 수 있습니다. EXPR을 생략하면 &lt;code&gt;$_&lt;/code&gt; 가 사용됩니다. &lt;code&gt;&amp;lt;*.c&amp;gt;&lt;/code&gt; 오퍼레이터에 자세히 설명되어 &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;perlop에서 I / O 연산자&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="37edd169eed8b427b6f69da497b122303092f2b0" translate="yes" xml:space="preserve">
          <source>would fail, returning:</source>
          <target state="translated">실패, 반환 :</target>
        </trans-unit>
        <trans-unit id="574cbd21dd4f01cc7e9a5d6c3ebf7c3fc8d35449" translate="yes" xml:space="preserve">
          <source>would get the POD name</source>
          <target state="translated">포드 이름을 얻을 것이다</target>
        </trans-unit>
        <trans-unit id="6e320d29fdf6132581dd222d085e227ad58bf37f" translate="yes" xml:space="preserve">
          <source>would give a full stack backtrace starting from the first caller outside of __PACKAGE__. (Unless that package was also internal to Perl.)</source>
          <target state="translated">__PACKAGE__ 외부의 첫 번째 호출자부터 시작하여 전체 스택 역 추적을 제공합니다. (패키지가 Perl 내부에 있지 않은 한)</target>
        </trans-unit>
        <trans-unit id="ad5c29604d0563177f85184d5b38f87b92f96450" translate="yes" xml:space="preserve">
          <source>would indicate that the module's loadable object has an extension of &lt;code&gt;unusual_ext&lt;/code&gt; instead of the more usual &lt;code&gt;$Config{dlext}&lt;/code&gt; . NOTE: This also requires that the module's</source>
          <target state="translated">모듈의로드 가능한 객체의 확장이 있음을 나타냅니다 &lt;code&gt;unusual_ext&lt;/code&gt; 대신 평소 &lt;code&gt;$Config{dlext}&lt;/code&gt; . 참고 : 이것은 또한 모듈의</target>
        </trans-unit>
        <trans-unit id="585e126f2d7d5e783ec33329e484ff25c16ca6ba" translate="yes" xml:space="preserve">
          <source>would look like this:</source>
          <target state="translated">다음과 같이 보일 것입니다 :</target>
        </trans-unit>
        <trans-unit id="fb35630d9819ace128f90170b4e7e21fb8a844e0" translate="yes" xml:space="preserve">
          <source>would make the output file be &lt;code&gt;&lt;a href=&quot;../functions/index&quot;&gt;index.html&lt;/a&gt;&lt;/code&gt; rather than &lt;code&gt;&lt;a href=&quot;../functions/index&quot;&gt;index.html?x=y&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">만들 것이다 출력 파일은 다음 &lt;code&gt;&lt;a href=&quot;../functions/index&quot;&gt;index.html&lt;/a&gt;&lt;/code&gt; 을 보다는 &lt;code&gt;&lt;a href=&quot;../functions/index&quot;&gt;index.html?x=y&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f64975e657327e4be32b5539242811882551af4" translate="yes" xml:space="preserve">
          <source>would match the same as &lt;code&gt;/(Y) ( (X) \g3 \g1 )/x&lt;/code&gt; . This allows you to interpolate regexes into larger regexes and not have to worry about the capture groups being renumbered.</source>
          <target state="translated">동일한 일치하는 것처럼 &lt;code&gt;/(Y) ( (X) \g3 \g1 )/x&lt;/code&gt; . 이를 통해 정규식을 더 큰 정규식으로 보간하고 캡처 그룹의 번호를 다시 지정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c2f054955a6bf9756cf704fa72217ac295bd0e6a" translate="yes" xml:space="preserve">
          <source>would not distinguish whether an argument to a C function which is of the form, say, &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; *&lt;/code&gt; , is an input, output, or input/output parameter. In particular, argument declarations of the form</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; *&lt;/code&gt; 형식의 C 함수에 대한 인수가 입력, 출력 또는 입력 / 출력 매개 변수 인지 구분하지 않습니다 . 특히, 형식의 인수 선언</target>
        </trans-unit>
        <trans-unit id="d43dd196be51f739a2f740fe5b9d6d8d4e1e385a" translate="yes" xml:space="preserve">
          <source>would not have worked, since a pattern match in scalar context will only return true or false, rather than a count of matches.</source>
          <target state="translated">스칼라 컨텍스트의 패턴 일치는 일치 횟수가 아닌 true 또는 false 만 리턴하므로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="673f3639cd000b9c54db8198e731d97836c69096" translate="yes" xml:space="preserve">
          <source>would parse as equivalent to this:</source>
          <target state="translated">다음과 동등한 것으로 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="9212fded8d922f55d00c869b65a88f38d24b2983" translate="yes" xml:space="preserve">
          <source>would print out:</source>
          <target state="translated">인쇄합니다 :</target>
        </trans-unit>
        <trans-unit id="6c9640bfb221618fc100b05da2396d3c0c4bbe0f" translate="yes" xml:space="preserve">
          <source>would result in the executable file</source>
          <target state="translated">실행 파일이 생성됩니다</target>
        </trans-unit>
        <trans-unit id="1ad2605d7b28e739c8b99351ef9b3563d4182742" translate="yes" xml:space="preserve">
          <source>would result in the library file</source>
          <target state="translated">라이브러리 파일이 생성됩니다</target>
        </trans-unit>
        <trans-unit id="b1f85381415339898b4e35b7420b2a30ff7e6961" translate="yes" xml:space="preserve">
          <source>would result in the object file</source>
          <target state="translated">객체 파일이 생성됩니다</target>
        </trans-unit>
        <trans-unit id="1f7d3dbcc73cffec6f45fb591952a386e20faa47" translate="yes" xml:space="preserve">
          <source>would return the same result, since all sets of both types of specified delimiter brackets are correctly nested and balanced.</source>
          <target state="translated">지정된 구분 기호 대괄호의 두 유형 모두가 올바르게 중첩되고 균형이 조정되므로 동일한 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2c4cff5293b552fd612d13d20febeef5d79d3555" translate="yes" xml:space="preserve">
          <source>would return:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="549c70e9abc983bc89d50811971c8d7b3d089c20" translate="yes" xml:space="preserve">
          <source>would run</source>
          <target state="translated">달릴 것이다</target>
        </trans-unit>
        <trans-unit id="f0812d8966a2250845dc2d619797b74c9d0e4dab" translate="yes" xml:space="preserve">
          <source>would use &lt;code&gt;$a&lt;/code&gt; for the width and precision, and &lt;code&gt;$b&lt;/code&gt; as the value to format.</source>
          <target state="translated">사용하는 것이 &lt;code&gt;$a&lt;/code&gt; 폭과 정밀도 및 위해 &lt;code&gt;$b&lt;/code&gt; 형식으로 값.</target>
        </trans-unit>
        <trans-unit id="5c4ae51d8b1c837faa9e910a2f351d7de1dfa952" translate="yes" xml:space="preserve">
          <source>wouldn't know where the two parameters we pushed were--remember that up to now all the stack pointer manipulation we have done is with our local copy,</source>
          <target state="translated">우리가 밀었던 두 매개 변수가 어디에 있는지 알 수 없었습니다. 지금까지 우리가 수행 한 모든 스택 포인터 조작은 로컬 복사본을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="275a8dd6709a5e2c891d71deaa74a09a2b8d5d39" translate="yes" xml:space="preserve">
          <source>wrap_code_ref (CODEREF)</source>
          <target state="translated">wrap_code_ref (CODEREF)</target>
        </trans-unit>
        <trans-unit id="ffbf27fe46bcaa79a98677fcde1803710c322360" translate="yes" xml:space="preserve">
          <source>wrap_code_refs_within (...)</source>
          <target state="translated">wrap_code_refs_within (...)</target>
        </trans-unit>
        <trans-unit id="21b372156d56807f806631ed6933c5523d17885c" translate="yes" xml:space="preserve">
          <source>wraplist</source>
          <target state="translated">wraplist</target>
        </trans-unit>
        <trans-unit id="a519839bb77029f84f6e3675490ad147a55b8b60" translate="yes" xml:space="preserve">
          <source>wrapped wraplen</source>
          <target state="translated">랩핑 랩핑</target>
        </trans-unit>
        <trans-unit id="e1d0c6c1c29e6ad5164072a5b21340dca7fcb052" translate="yes" xml:space="preserve">
          <source>write</source>
          <target state="translated">write</target>
        </trans-unit>
        <trans-unit id="dd01faf5c1113bb980804714f1a3c4f4eca294e2" translate="yes" xml:space="preserve">
          <source>write EXPR</source>
          <target state="translated">EXPR 작성</target>
        </trans-unit>
        <trans-unit id="45c37b30717044052f1540db05b5ad1c8bba5bf9" translate="yes" xml:space="preserve">
          <source>write FILEHANDLE</source>
          <target state="translated">FILEHANDLE 작성</target>
        </trans-unit>
        <trans-unit id="dc499117dc83408f0c557cc8b2161889aed51087" translate="yes" xml:space="preserve">
          <source>write code faster</source>
          <target state="translated">더 빠른 코드 작성</target>
        </trans-unit>
        <trans-unit id="a9a1d28af222c28b77e752b332e8cb55ca3c14d7" translate="yes" xml:space="preserve">
          <source>write faster code</source>
          <target state="translated">더 빠른 코드 작성</target>
        </trans-unit>
        <trans-unit id="6d71d56a74dcab217f5cf3d91986820cbce58120" translate="yes" xml:space="preserve">
          <source>write.exe</source>
          <target state="translated">write.exe</target>
        </trans-unit>
        <trans-unit id="047dd1341a6717dbc4836719e3c574b3bc97bb54" translate="yes" xml:space="preserve">
          <source>write_mymeta</source>
          <target state="translated">write_mymeta</target>
        </trans-unit>
        <trans-unit id="1935d7b6e1cdaa0cb2a12b33ef6db0f1f938bf83" translate="yes" xml:space="preserve">
          <source>writing</source>
          <target state="translated">writing</target>
        </trans-unit>
        <trans-unit id="a4b48a81cdab1e1a5dd37907d6c85ca1c61ddc7c" translate="yes" xml:space="preserve">
          <source>wrong</source>
          <target state="translated">wrong</target>
        </trans-unit>
        <trans-unit id="11f6ad8ec52a2984abaafd7c3b516503785c2072" translate="yes" xml:space="preserve">
          <source>x</source>
          <target state="translated">x</target>
        </trans-unit>
        <trans-unit id="93dff1d783f239eb6df3ffae594ded880d8c2dfb" translate="yes" xml:space="preserve">
          <source>x/../y</source>
          <target state="translated">x/../y</target>
        </trans-unit>
        <trans-unit id="3482696e3765ecb95ff0b00a865fd23521383490" translate="yes" xml:space="preserve">
          <source>xhtml-symbol.ent</source>
          <target state="translated">xhtml-symbol.ent</target>
        </trans-unit>
        <trans-unit id="f1922a234bb92764a276a8524d28cdb446d3c7da" translate="yes" xml:space="preserve">
          <source>xor</source>
          <target state="translated">xor</target>
        </trans-unit>
        <trans-unit id="bd656af3459b27df22cf48bccc070225063ef3e2" translate="yes" xml:space="preserve">
          <source>xs_init</source>
          <target state="translated">xs_init</target>
        </trans-unit>
        <trans-unit id="9be87fada2e3b55bddb69633715a8cbf8d48722a" translate="yes" xml:space="preserve">
          <source>xsinit(), ldopts(), ccopts(), perl_inc(), ccflags(), ccdlflags(), xsi_header(), xsi_protos(), xsi_body()</source>
          <target state="translated">xsinit (), ldopts (), ccopts (), perl_inc (), ccflags (), ccdlflags (), xsi_header (), xsi_protos (), xsi_body ()</target>
        </trans-unit>
        <trans-unit id="1fff56fa3f2f5449b8620c18875a8982395117c3" translate="yes" xml:space="preserve">
          <source>xsinit.c</source>
          <target state="translated">xsinit.c</target>
        </trans-unit>
        <trans-unit id="8caed3fb038593e7e6d1f13475278cfc4b1647e5" translate="yes" xml:space="preserve">
          <source>xsubpp</source>
          <target state="translated">xsubpp</target>
        </trans-unit>
        <trans-unit id="15440904d1068b6f9c7bcddb1d5eab1ae01d515d" translate="yes" xml:space="preserve">
          <source>xsubpp - compiler to convert Perl XS code into C code</source>
          <target state="translated">xsubpp-Perl XS 코드를 C 코드로 변환하는 컴파일러</target>
        </trans-unit>
        <trans-unit id="41906962c9fe690a96247971b9ba3de3ba3eef8c" translate="yes" xml:space="preserve">
          <source>xsubpp supports a special syntax for returning packed C arrays to perl. If the XS return type is given as</source>
          <target state="translated">xsubpp는 압축 된 C 배열을 perl로 리턴하기위한 특수 구문을 지원합니다. XS 반환 유형이 다음과 같이 주어진 경우</target>
        </trans-unit>
        <trans-unit id="7714417f80a650aa8bcd07aa2560cd2d5b40da3b" translate="yes" xml:space="preserve">
          <source>xsubpp variables and internal functions</source>
          <target state="translated">xsubpp 변수 및 내부 함수</target>
        </trans-unit>
        <trans-unit id="7313a6242468b7d1e99857893c09fca6dc3ad1eb" translate="yes" xml:space="preserve">
          <source>xsubpp will copy the contents of &lt;code&gt;nelem * sizeof(type)&lt;/code&gt; bytes from RETVAL to an SV and push it onto the stack. This is only really useful if the number of items to be returned is known at compile time and you don't mind having a string of bytes in your SV. Use T_ARRAY to push a variable number of arguments onto the return stack (they won't be packed as a single string though).</source>
          <target state="translated">xsubpp는 &lt;code&gt;nelem * sizeof(type)&lt;/code&gt; 바이트의 내용을 RETVAL에서 SV로 복사 하여 스택으로 푸시합니다. 이것은 반환 할 항목 수를 컴파일 타임에 알고 SV에 바이트 문자열이있는 것을 신경 쓰지 않는 경우에만 실제로 유용합니다. T_ARRAY를 사용하여 가변 개수의 인수를 리턴 스택으로 푸시하십시오 (단, 단일 문자열로 압축되지는 않음).</target>
        </trans-unit>
        <trans-unit id="5f8459982f9f619f4b0d9af2542a2086e56a4bef" translate="yes" xml:space="preserve">
          <source>xy</source>
          <target state="translated">xy</target>
        </trans-unit>
        <trans-unit id="95cb0bfd2977c761298d9624e4b4d4c72a39974a" translate="yes" xml:space="preserve">
          <source>y</source>
          <target state="translated">y</target>
        </trans-unit>
        <trans-unit id="d2f77ac0db8f1535051c3dc4f93ef1b8f6478c1d" translate="yes" xml:space="preserve">
          <source>y///</source>
          <target state="translated">y///</target>
        </trans-unit>
        <trans-unit id="f5619be32b1efe2b008dbb33c1045b38215c4948" translate="yes" xml:space="preserve">
          <source>yacc</source>
          <target state="translated">yacc</target>
        </trans-unit>
        <trans-unit id="d12d9f2a97a58598b867d00b4faff8074cd34270" translate="yes" xml:space="preserve">
          <source>yacc.U</source>
          <target state="translated">yacc.U</target>
        </trans-unit>
        <trans-unit id="9251acc6192fd21eb64ccb0b45a380892e1c36b3" translate="yes" xml:space="preserve">
          <source>yaml_backend</source>
          <target state="translated">yaml_backend</target>
        </trans-unit>
        <trans-unit id="b636d2c48aad51e77144c248b661fb67f7fc03c6" translate="yes" xml:space="preserve">
          <source>yield the same result but</source>
          <target state="translated">같은 결과를 얻지 만</target>
        </trans-unit>
        <trans-unit id="271d1c708984e0c55c15fabaa11bd2d3b1458de9" translate="yes" xml:space="preserve">
          <source>yield:</source>
          <target state="translated">yield:</target>
        </trans-unit>
        <trans-unit id="b4f99a7dbe9a425fcc68c36757fe48467fa8d7b7" translate="yes" xml:space="preserve">
          <source>yielding the number of seconds that elapsed between January 1, 1970 (the beginning of the Unix epoch), and the moment I began writing this sentence.</source>
          <target state="translated">1970 년 1 월 1 일 (유닉스 시대의 시작)과 내가이 문장을 쓰기 시작한 시간 사이에 경과 된 시간 (초)을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="edb0f5b1f639a3886e3180c47fe86c3a6a263842" translate="yes" xml:space="preserve">
          <source>yields</source>
          <target state="translated">yields</target>
        </trans-unit>
        <trans-unit id="341f78d1b5a5471d159f158c1f163fc170e38478" translate="yes" xml:space="preserve">
          <source>yields:</source>
          <target state="translated">yields:</target>
        </trans-unit>
        <trans-unit id="5056f4f5d35641712437421dd222826fdd613905" translate="yes" xml:space="preserve">
          <source>you can assume that the input &quot;ac&quot; will output &quot;ac&quot;, and that &quot;abc&quot; will output only &quot;c&quot;.</source>
          <target state="translated">입력 &quot;ac&quot;는 &quot;ac&quot;를 출력하고 &quot;abc&quot;는 &quot;c&quot;만 출력한다고 가정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a951aa1692118fb65f6cadcde16979f8bb55362a" translate="yes" xml:space="preserve">
          <source>you can expect one of these messages (which you actually get is dependent on the version of Perl you are using)</source>
          <target state="translated">이 메시지 중 하나를 기대할 수 있습니다 (실제로받는 Perl 버전에 따라 다릅니다)</target>
        </trans-unit>
        <trans-unit id="761c473c3fb3b7c8d7e8e15ee579ff0b662dcc3c" translate="yes" xml:space="preserve">
          <source>you can force interpretation as a reserved word by adding anything that makes it more than a bareword:</source>
          <target state="translated">비 단어 이상의 의미를 갖는 것을 추가하여 예약어로 해석을 강제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="279056ca82a6811880a0d9a6128de1be6e230a2e" translate="yes" xml:space="preserve">
          <source>you can guarantee that the locale will be ISO8859-1. Use POSIX character classes instead.</source>
          <target state="translated">로케일이 ISO8859-1임을 보장 할 수 있습니다. 대신 POSIX 문자 클래스를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5e460c422109538339eeeb6480684b4f306f3de3" translate="yes" xml:space="preserve">
          <source>you can make them all to use the same XSUB using this:</source>
          <target state="translated">다음을 사용하여 모두 동일한 XSUB를 사용하도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5afb3eb8089babca339a0a5ab5ffd74baff0bfbd" translate="yes" xml:space="preserve">
          <source>you can press &lt;code&gt;Ctrl-Insert&lt;/code&gt; now, and cut-and-paste from the resulting file - created in the directory you started</source>
          <target state="translated">지금 &lt;code&gt;Ctrl-Insert&lt;/code&gt; 를 누르고 시작한 디렉토리에 생성 된 결과 파일에서 잘라 내기 및 붙여 넣기를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b6d4e3eef8985d17155740fc1fb9090692c91b7" translate="yes" xml:space="preserve">
          <source>you can roll it all into one line:</source>
          <target state="translated">한 줄에 모두 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="228c9492d3cafe3be9e270db9be067f6669b75db" translate="yes" xml:space="preserve">
          <source>you can simply write:</source>
          <target state="translated">간단히 쓸 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="73c2c64bf57a41908c42c9a1cc5c7680a481d9b9" translate="yes" xml:space="preserve">
          <source>you can unambiguously represent data. Here is what we mean by &quot;unambiguously&quot;. After &lt;code&gt;$utf8 = decode(&quot;foo&quot;, $octet)&lt;/code&gt; ,</source>
          <target state="translated">분명하게 데이터를 표현할 수 있습니다. 여기에 &quot;명백하게&quot;라는 의미가 있습니다. 후 &lt;code&gt;$utf8 = decode(&quot;foo&quot;, $octet)&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="a0769ff9fc11160998b5a34787676ea117e16054" translate="yes" xml:space="preserve">
          <source>you can use the &lt;code&gt;EVERY::LAST&lt;/code&gt; pseudo-class:</source>
          <target state="translated">&lt;code&gt;EVERY::LAST&lt;/code&gt; 의사 클래스를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5c36535a9c2aa5358bd3fa1a809a56719daa66a5" translate="yes" xml:space="preserve">
          <source>you can write</source>
          <target state="translated">당신은 쓸 수 있습니다</target>
        </trans-unit>
        <trans-unit id="1510a5ad8c738b5c46b5a17800ed9f6671e57b9a" translate="yes" xml:space="preserve">
          <source>you can write just</source>
          <target state="translated">당신은 그냥 쓸 수 있습니다</target>
        </trans-unit>
        <trans-unit id="1d905b4762422cd8888fe106e63e876390030933" translate="yes" xml:space="preserve">
          <source>you could do it like so:</source>
          <target state="translated">당신은 그렇게 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="32cbafc88f9919f00875fa01fc871ad53657d16c" translate="yes" xml:space="preserve">
          <source>you could retry with</source>
          <target state="translated">당신은 다시 시도 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="f31af4d40aa4d113abb8700320d0dec76296cdee" translate="yes" xml:space="preserve">
          <source>you could set DESTDIR=~/tmp/ and installation would go into</source>
          <target state="translated">DESTDIR = ~ / tmp /를 설정하면 설치가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="97a047f9ba32f1e569d7e98e12e7892d5f52a397" translate="yes" xml:space="preserve">
          <source>you declare any of your own fields.</source>
          <target state="translated">자신의 필드를 선언합니다.</target>
        </trans-unit>
        <trans-unit id="3069e6795247a4cf630775dcb371de41a404867d" translate="yes" xml:space="preserve">
          <source>you didn't read the above and tried to use tar instead of pax, you'll first have to remove the (now corrupt) perl directory</source>
          <target state="translated">위의 내용을 읽지 않고 pax 대신 tar를 사용하려고 시도했습니다. 먼저 (현재 손상된) perl 디렉토리를 제거해야합니다</target>
        </trans-unit>
        <trans-unit id="75cceb83b150b42b6f5f66b5da740fdbd16273b6" translate="yes" xml:space="preserve">
          <source>you load the module.</source>
          <target state="translated">모듈을로드합니다.</target>
        </trans-unit>
        <trans-unit id="a4411228d0f2dd0ed520803b8f3074cfee30a2f8" translate="yes" xml:space="preserve">
          <source>you make certain that all locales will always and only be either an ISO8859-1, or, if you don't have a deficient C library, a UTF-8 locale.</source>
          <target state="translated">모든 로케일이 항상 ISO8859-1이거나 부족한 C 라이브러리가없는 경우 UTF-8 로케일이어야합니다.</target>
        </trans-unit>
        <trans-unit id="30a3a6e75011da9030503c667c7b05d715ebcfe8" translate="yes" xml:space="preserve">
          <source>you may THINK you wrote the same thing as</source>
          <target state="translated">당신은 당신이 같은 것을 쓴 생각</target>
        </trans-unit>
        <trans-unit id="01380cc536db3e96b59620f22f2fbfa4c077a9a7" translate="yes" xml:space="preserve">
          <source>you may need to reinstall the ActivePerl.</source>
          <target state="translated">ActivePerl을 다시 설치해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d19c7e9e52eed6d3f22ce761e226a5c29f3ad43e" translate="yes" xml:space="preserve">
          <source>you may tell the compiler to use integer operations (see &lt;a href=&quot;integer&quot;&gt;integer&lt;/a&gt; for a detailed explanation) from here to the end of the enclosing BLOCK. An inner BLOCK may countermand this by saying</source>
          <target state="translated">여기에서 엔 클로징 BLOCK의 끝까지 정수 연산 ( 자세한 설명 은 &lt;a href=&quot;integer&quot;&gt;정수&lt;/a&gt; 참조)을 사용하도록 컴파일러에 지시 할 수 있습니다 . 내부 블록은 다음과 같이 말함으로써 이것을 막을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="6a31b287da5d839e2dc623eaffd98dff0ccb062a" translate="yes" xml:space="preserve">
          <source>you need to either recompile your Perl in Tru64 4.0D or upgrade your Tru64 4.0D to at least 4.0F: the sockatmark() system call was added in Tru64 4.0F, and the IO extension refers that symbol.</source>
          <target state="translated">Tru64 4.0D에서 Perl을 다시 컴파일하거나 Tru64 4.0D를 4.0F 이상으로 업그레이드해야합니다. sockatmark () 시스템 호출은 Tru64 4.0F에서 추가되었으며 IO 확장은 해당 기호를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1722764b528ff2473944177b83c3cd9a8e51bc17" translate="yes" xml:space="preserve">
          <source>you provide.) In the</source>
          <target state="translated">제공합니다.)</target>
        </trans-unit>
        <trans-unit id="5c0579f9be815c7ee48d8d23d3d66d5cb6cfc45a" translate="yes" xml:space="preserve">
          <source>you use to build Perl, adding the extension's name to the &lt;code&gt;ext&lt;/code&gt; macro, and the extension's object file to the &lt;code&gt;extobj&lt;/code&gt; macro. You'll also need to build the extension's object file, either by adding dependencies to the main</source>
          <target state="translated">확장명을 &lt;code&gt;ext&lt;/code&gt; 매크로에 추가하고 확장명 오브젝트 파일을 &lt;code&gt;extobj&lt;/code&gt; 매크로에 추가하여 Perl을 빌드하는 데 사용합니다 . 또한 메인에 의존성을 추가하여 확장의 객체 파일을 빌드해야합니다.</target>
        </trans-unit>
        <trans-unit id="a387eb2e97a3c9d50bfe300a1159fb7c3637c367" translate="yes" xml:space="preserve">
          <source>you want the pattern to use the initial values of the variables regardless of whether they change or not. (But there are saner ways of accomplishing this than using &lt;code&gt;/o&lt;/code&gt;.)</source>
          <target state="translated">패턴이 변수의 변경 여부에 관계없이 변수의 초기 값을 사용하도록합니다. (그러나 &lt;code&gt;/o&lt;/code&gt; 를 사용하는 것보다 이것을 달성하는 더 좋은 방법이 있습니다.)</target>
        </trans-unit>
        <trans-unit id="6d89d3b483dbdfd382255886b6f76f6f9ed539d8" translate="yes" xml:space="preserve">
          <source>you will find the shell more convenient than the bare shell before.</source>
          <target state="translated">이전의 쉘보다 쉘이 더 편리하다는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6d52094053e2271b8e6b8811f157b555c3d0bed" translate="yes" xml:space="preserve">
          <source>you will have to write the explicit full form</source>
          <target state="translated">당신은 명시 적 전체 양식을 작성해야합니다</target>
        </trans-unit>
        <trans-unit id="ae9b86dc8d723ffd5fd2d5e039182429061deb40" translate="yes" xml:space="preserve">
          <source>you will have:</source>
          <target state="translated">당신은 할 것:</target>
        </trans-unit>
        <trans-unit id="de50066896083dd63404bb3575f5f66f75090162" translate="yes" xml:space="preserve">
          <source>you will see the slightly more helpful</source>
          <target state="translated">조금 더 도움이 될 것입니다</target>
        </trans-unit>
        <trans-unit id="0667d305a0b0067742e1926b7aa78a3f1f8f9b8a" translate="yes" xml:space="preserve">
          <source>you would write:</source>
          <target state="translated">당신은 쓸 것입니다 :</target>
        </trans-unit>
        <trans-unit id="b78865bd8c1873f7d311dc1d94a79c917244ed27" translate="yes" xml:space="preserve">
          <source>you'll get &lt;code&gt;mytime() + 2&lt;/code&gt; , not &lt;code&gt;mytime(2)&lt;/code&gt; , which is how it would be parsed without a prototype. If you want to force a unary function to have the same precedence as a list operator, add &lt;code&gt;;&lt;/code&gt; to the end of the prototype:</source>
          <target state="translated">&lt;code&gt;mytime(2)&lt;/code&gt; 아닌 &lt;code&gt;mytime() + 2&lt;/code&gt; 얻 습니다 . 이것은 프로토 타입없이 파싱되는 방법입니다. 단항 함수가리스트 연산자와 동일한 우선 순위를 갖도록하려면 추가하십시오 &lt;code&gt;;&lt;/code&gt; 프로토 타입 끝까지 :</target>
        </trans-unit>
        <trans-unit id="7e6a0e9c6d7617f1874cbd34d69a61bb043ae4b0" translate="yes" xml:space="preserve">
          <source>your class is, rather than having to tell Perl</source>
          <target state="translated">수업은 펄에게 말하지 않고</target>
        </trans-unit>
        <trans-unit id="92646319ab3ad914c108ec6e67cecb3d15d2b874" translate="yes" xml:space="preserve">
          <source>your regexp. So by default, using both interpolation and code expressions in the same regexp is not allowed. If you're not concerned about malicious users, it is possible to bypass this security check by invoking &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval'&lt;/code&gt; :</source>
          <target state="translated">정규식. 따라서 기본적으로 동일한 정규 표현식에서 보간 및 코드 표현식을 모두 사용할 수 없습니다. 악의적 인 사용자가 걱정되지 않는다면 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval'&lt;/code&gt; 을 호출하여이 보안 검사를 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7d71de9ec3c1742da5275ab3e4ce303c6d416f57" translate="yes" xml:space="preserve">
          <source>your table now reads:</source>
          <target state="translated">당신의 테이블은 이제 읽습니다 :</target>
        </trans-unit>
        <trans-unit id="edec9917c4429bd24f7af5accd2ac28ce6871922" translate="yes" xml:space="preserve">
          <source>your-handler</source>
          <target state="translated">your-handler</target>
        </trans-unit>
        <trans-unit id="20770554c8961543d282b97286ecde3fed631f64" translate="yes" xml:space="preserve">
          <source>yourself</source>
          <target state="translated">yourself</target>
        </trans-unit>
        <trans-unit id="17ddec5322f6ed39ba7950d6ba2bd67e67db5b6a" translate="yes" xml:space="preserve">
          <source>yourself.</source>
          <target state="translated">yourself.</target>
        </trans-unit>
        <trans-unit id="395df8f7c51f007019cb30201c49e884b46b92fa" translate="yes" xml:space="preserve">
          <source>z</source>
          <target state="translated">z</target>
        </trans-unit>
        <trans-unit id="aa8c41330509455ee5679d04ed41535d280d9a89" translate="yes" xml:space="preserve">
          <source>zero</source>
          <target state="translated">zero</target>
        </trans-unit>
        <trans-unit id="5211a4a12dbc3325a3db2a2cce5d6220da5eb9c2" translate="yes" xml:space="preserve">
          <source>zero is at the North Pole, not at the Equator on the west coast of Africa (Bay of Guinea). You need to subtract your geographical coordinates from</source>
          <target state="translated">0은 아프리카 서해안 (기니 베이)의 적도가 아닌 북극에 있습니다. 지리적 좌표를 빼야합니다.</target>
        </trans-unit>
        <trans-unit id="d2234786d04df9bc1bb3c3da3df83549bbae76b7" translate="yes" xml:space="preserve">
          <source>zero-width assertions</source>
          <target state="translated">폭이 0 인 어설 션</target>
        </trans-unit>
        <trans-unit id="9f375b5e2bd318e7607d853092dbfbe693321844" translate="yes" xml:space="preserve">
          <source>zip $input_filename_or_reference =&amp;gt; $output_filename_or_reference [, OPTS]</source>
          <target state="translated">zip $ input_filename_or_reference =&amp;gt; $ output_filename_or_reference [, OPTS]</target>
        </trans-unit>
        <trans-unit id="57968f12798767ae5da8b15a0c383ad79d0f338b" translate="yes" xml:space="preserve">
          <source>zlib</source>
          <target state="translated">zlib</target>
        </trans-unit>
        <trans-unit id="0bada2d421ea3b0a4ee659093f79079ed4b9623f" translate="yes" xml:space="preserve">
          <source>{atan2, cos, exp, floor, fmod, frexp, isnan, log, modf, pow, sin, sqrt}l, strtold</source>
          <target state="translated">{atan2, cos, exp, floor, fmod, frexp, isnan, log, modf, pow, sin, sqrt}l, strtold</target>
        </trans-unit>
        <trans-unit id="f8afa9f0630cc708f3254bd632424571d7937a2d" translate="yes" xml:space="preserve">
          <source>| &lt;b&gt;-C&lt;/b&gt; ] [ &lt;b&gt;-S&lt;/b&gt; ] [ &lt;b&gt;-t&lt;/b&gt; ] [ &lt;b&gt;-d&lt;/b&gt; ] [ &lt;b&gt;-A&lt;/b&gt; ] [ &lt;b&gt;-h&lt;/b&gt; ] [ &lt;b&gt;-T&lt;/b&gt; ]</source>
          <target state="translated">| &lt;b&gt;-C&lt;/b&gt; ] [ &lt;b&gt;-S&lt;/b&gt; ] [ &lt;b&gt;-t&lt;/b&gt; ] [ &lt;b&gt;-d&lt;/b&gt; ] [ &lt;b&gt;-A&lt;/b&gt; ] [ &lt;b&gt;-h&lt;/b&gt; ] [ &lt;b&gt;-T&lt;/b&gt; ]</target>
        </trans-unit>
        <trans-unit id="94864efe9c101c7cfe388d5b720d16e84936f991" translate="yes" xml:space="preserve">
          <source>| &lt;b&gt;-f&lt;/b&gt;</source>
          <target state="translated">| &lt;b&gt;-f&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7a314cca084c8d6e6c8f5328b453da7f8a87abf9" translate="yes" xml:space="preserve">
          <source>} =</source>
          <target state="translated">} =</target>
        </trans-unit>
        <trans-unit id="fb3c6e4de85bd9eae26fdc63e75f10a7f39e850e" translate="yes" xml:space="preserve">
          <source>~</source>
          <target state="translated">~</target>
        </trans-unit>
        <trans-unit id="3546d92b553cbec03ec46dfae3482c4878748b52" translate="yes" xml:space="preserve">
          <source>~/.netscape/history.db</source>
          <target state="translated">~/.netscape/history.db</target>
        </trans-unit>
        <trans-unit id="10147e78c8415aa0b473fbb8dbea5a8966778c0c" translate="yes" xml:space="preserve">
          <source>~/.perldb</source>
          <target state="translated">~/.perldb</target>
        </trans-unit>
        <trans-unit id="2d2cbdb9094f5f4954c6330da66315ee120c6274" translate="yes" xml:space="preserve">
          <source>~/.proverc</source>
          <target state="translated">~/.proverc</target>
        </trans-unit>
        <trans-unit id="ac3bc4988958b749f7dd1bd7030e495f8d6af1a4" translate="yes" xml:space="preserve">
          <source>~/bin</source>
          <target state="translated">~/bin</target>
        </trans-unit>
        <trans-unit id="402b4ddfdf31bfc73a7ea7ed2fb0f95b5a09a270" translate="yes" xml:space="preserve">
          <source>~/lib/perl5</source>
          <target state="translated">~/lib/perl5</target>
        </trans-unit>
        <trans-unit id="db83d96aced0e2c019a65ecc608c84bc6c391ed3" translate="yes" xml:space="preserve">
          <source>~/man</source>
          <target state="translated">~/man</target>
        </trans-unit>
        <trans-unit id="bbf98088c0d37c38d37fa49f16a667216d44ef13" translate="yes" xml:space="preserve">
          <source>~/tmp</source>
          <target state="translated">~/tmp</target>
        </trans-unit>
        <trans-unit id="03f8609dad484cb98c24755bd4acb64e2459cdb6" translate="yes" xml:space="preserve">
          <source>~/tmp/</source>
          <target state="translated">~/tmp/</target>
        </trans-unit>
        <trans-unit id="5a812c8dbd85a0c3fe37d9f84374737a4801d2bc" translate="yes" xml:space="preserve">
          <source>~/tmp/lib/perl5</source>
          <target state="translated">~/tmp/lib/perl5</target>
        </trans-unit>
        <trans-unit id="45cb8fa08bbb384bb68753d12c4d9b9b524fcc41" translate="yes" xml:space="preserve">
          <source>~/tmp/usr/local/lib/perl</source>
          <target state="translated">~/tmp/usr/local/lib/perl</target>
        </trans-unit>
        <trans-unit id="14df47b7b7486d3776ef10c4c880ca067065a0b7" translate="yes" xml:space="preserve">
          <source>~name</source>
          <target state="translated">~name</target>
        </trans-unit>
        <trans-unit id="b5b55a0e439c0317089da34fd3674db902e0188e" translate="yes" xml:space="preserve">
          <source>ἀ-</source>
          <target state="translated">ἀ-</target>
        </trans-unit>
        <trans-unit id="50400a9a3ca82dc97c2a62a8cb1fd9c90797027b" translate="yes" xml:space="preserve">
          <source>℞ 0: Standard preamble</source>
          <target state="translated">℞ 0: Standard preamble</target>
        </trans-unit>
        <trans-unit id="c2a5f8ffdee8b1fc6db174346c9351f7a691c79d" translate="yes" xml:space="preserve">
          <source>℞ 10: Custom named characters</source>
          <target state="translated">℞ 10: Custom named characters</target>
        </trans-unit>
        <trans-unit id="d99e547ff698f044bb6f9ec55492f016195b8b76" translate="yes" xml:space="preserve">
          <source>℞ 11: Names of CJK codepoints</source>
          <target state="translated">℞ 11: Names of CJK codepoints</target>
        </trans-unit>
        <trans-unit id="3ef3e77c58b7d3c354fb4a79adbe9a3824db9a8f" translate="yes" xml:space="preserve">
          <source>℞ 12: Explicit encode/decode</source>
          <target state="translated">℞ 12: Explicit encode/decode</target>
        </trans-unit>
        <trans-unit id="5b67beb4bfc4b3e25c970a54c813cc2a0e285a8b" translate="yes" xml:space="preserve">
          <source>℞ 13: Decode program arguments as utf8</source>
          <target state="translated">℞ 13: Decode program arguments as utf8</target>
        </trans-unit>
        <trans-unit id="e6b8e850a711b941c3b488e2ed88459f7223a720" translate="yes" xml:space="preserve">
          <source>℞ 14: Decode program arguments as locale encoding</source>
          <target state="translated">℞ 14: Decode program arguments as locale encoding</target>
        </trans-unit>
        <trans-unit id="1887bd908402fa513516cc0ea0a1a3025b915578" translate="yes" xml:space="preserve">
          <source>℞ 15: Declare STD{IN,OUT,ERR} to be utf8</source>
          <target state="translated">℞ 15: Declare STD{IN,OUT,ERR} to be utf8</target>
        </trans-unit>
        <trans-unit id="e2ebb62517d037f392732882c882d1ba5fc9ecc2" translate="yes" xml:space="preserve">
          <source>℞ 16: Declare STD{IN,OUT,ERR} to be in locale encoding</source>
          <target state="translated">℞ 16: Declare STD{IN,OUT,ERR} to be in locale encoding</target>
        </trans-unit>
        <trans-unit id="ebb3cf37c9c1d0a5bb342f588f5b09dbb35be67a" translate="yes" xml:space="preserve">
          <source>℞ 17: Make file I/O default to utf8</source>
          <target state="translated">℞ 17: Make file I/O default to utf8</target>
        </trans-unit>
        <trans-unit id="2270d23ccbd9ab2a598ab2468255ab751d4c25c2" translate="yes" xml:space="preserve">
          <source>℞ 18: Make all I/O and args default to utf8</source>
          <target state="translated">℞ 18: Make all I/O and args default to utf8</target>
        </trans-unit>
        <trans-unit id="8babe67379748497306ce72a6dad66fc99fc1e81" translate="yes" xml:space="preserve">
          <source>℞ 19: Open file with specific encoding</source>
          <target state="translated">℞ 19: Open file with specific encoding</target>
        </trans-unit>
        <trans-unit id="7b034eaf8616461baa8e3d15f4ad99a4b7d97e42" translate="yes" xml:space="preserve">
          <source>℞ 1: Generic Unicode-savvy filter</source>
          <target state="translated">℞ 1: Generic Unicode-savvy filter</target>
        </trans-unit>
        <trans-unit id="b729d9a4ed3a62e05db384dc3e1d5044801f8d4e" translate="yes" xml:space="preserve">
          <source>℞ 20: Unicode casing</source>
          <target state="translated">℞ 20: Unicode casing</target>
        </trans-unit>
        <trans-unit id="f3b7526897174f1d984b158eeaedadfd87945792" translate="yes" xml:space="preserve">
          <source>℞ 21: Unicode case-insensitive comparisons</source>
          <target state="translated">℞ 21: Unicode case-insensitive comparisons</target>
        </trans-unit>
        <trans-unit id="f1cf2c7882da8c0f9ff3908b5f16003eae636f3e" translate="yes" xml:space="preserve">
          <source>℞ 22: Match Unicode linebreak sequence in regex</source>
          <target state="translated">℞ 22: Match Unicode linebreak sequence in regex</target>
        </trans-unit>
        <trans-unit id="e4cf00c9ea31f803c1577db0d44ba0e0609610ed" translate="yes" xml:space="preserve">
          <source>℞ 23: Get character category</source>
          <target state="translated">℞ 23: Get character category</target>
        </trans-unit>
        <trans-unit id="7ef354f30d35eb886f206035ce256589f9655f23" translate="yes" xml:space="preserve">
          <source>℞ 24: Disabling Unicode-awareness in builtin charclasses</source>
          <target state="translated">℞ 24: Disabling Unicode-awareness in builtin charclasses</target>
        </trans-unit>
        <trans-unit id="992aea2e1ad40f008b3e87938c62de07b67f29dc" translate="yes" xml:space="preserve">
          <source>℞ 25: Match Unicode properties in regex with \p, \P</source>
          <target state="translated">℞ 25: Match Unicode properties in regex with \p, \P</target>
        </trans-unit>
        <trans-unit id="9031b7ab091f3539c164cdd9834c8ea6ca177c41" translate="yes" xml:space="preserve">
          <source>℞ 26: Custom character properties</source>
          <target state="translated">℞ 26: Custom character properties</target>
        </trans-unit>
        <trans-unit id="a93543794d643ee0acfa19d73095b8305fc87183" translate="yes" xml:space="preserve">
          <source>℞ 27: Unicode normalization</source>
          <target state="translated">℞ 27: Unicode normalization</target>
        </trans-unit>
        <trans-unit id="3af91d59321e31bb1b94eea9e6b20a303f096c4b" translate="yes" xml:space="preserve">
          <source>℞ 28: Convert non-ASCII Unicode numerics</source>
          <target state="translated">℞ 28: Convert non-ASCII Unicode numerics</target>
        </trans-unit>
        <trans-unit id="28555117568adeb829bdaa480f535af4c8603c5e" translate="yes" xml:space="preserve">
          <source>℞ 29: Match Unicode grapheme cluster in regex</source>
          <target state="translated">℞ 29: Match Unicode grapheme cluster in regex</target>
        </trans-unit>
        <trans-unit id="f7f40e2d4b5881274c99d4faa54dde14ad616cad" translate="yes" xml:space="preserve">
          <source>℞ 2: Fine-tuning Unicode warnings</source>
          <target state="translated">℞ 2: Fine-tuning Unicode warnings</target>
        </trans-unit>
        <trans-unit id="7b1e91f2708a78bbedb8e5f5d87aea1a336f35a3" translate="yes" xml:space="preserve">
          <source>℞ 30: Extract by grapheme instead of by codepoint (regex)</source>
          <target state="translated">℞ 30: Extract by grapheme instead of by codepoint (regex)</target>
        </trans-unit>
        <trans-unit id="55cfb33ebf5f1e852b3093f5c7d0bec6229f8ea6" translate="yes" xml:space="preserve">
          <source>℞ 31: Extract by grapheme instead of by codepoint (substr)</source>
          <target state="translated">℞ 31: Extract by grapheme instead of by codepoint (substr)</target>
        </trans-unit>
        <trans-unit id="c2ba8073c4eed5409155c51ade3f945a630b558c" translate="yes" xml:space="preserve">
          <source>℞ 32: Reverse string by grapheme</source>
          <target state="translated">℞ 32: Reverse string by grapheme</target>
        </trans-unit>
        <trans-unit id="c9ce223e0840c6abef41097684eb5f1c650104df" translate="yes" xml:space="preserve">
          <source>℞ 33: String length in graphemes</source>
          <target state="translated">℞ 33: String length in graphemes</target>
        </trans-unit>
        <trans-unit id="53c13862cc87714e333fa62d8720a158c6f355ab" translate="yes" xml:space="preserve">
          <source>℞ 34: Unicode column-width for printing</source>
          <target state="translated">℞ 34: Unicode column-width for printing</target>
        </trans-unit>
        <trans-unit id="87c7c9b1652730b229a2e3ba08465d7c12a8cfc8" translate="yes" xml:space="preserve">
          <source>℞ 35: Unicode collation</source>
          <target state="translated">℞ 35: Unicode collation</target>
        </trans-unit>
        <trans-unit id="0c95a7a0882b520eaa9bb5d4fbc45228b8c18573" translate="yes" xml:space="preserve">
          <source>℞ 36: Case-</source>
          <target state="translated">℞ 36: Case-</target>
        </trans-unit>
        <trans-unit id="d2ce8d21b9aecfb67a96ff13188b0a89e0a5624f" translate="yes" xml:space="preserve">
          <source>℞ 36: Case- _and_ accent-insensitive Unicode sort</source>
          <target state="translated">℞ 36: Case- _and_ accent-insensitive Unicode sort</target>
        </trans-unit>
        <trans-unit id="968af3413a857a361da7bcd3d91cb10c913d6e25" translate="yes" xml:space="preserve">
          <source>℞ 37: Unicode locale collation</source>
          <target state="translated">℞ 37: Unicode locale collation</target>
        </trans-unit>
        <trans-unit id="ec65982ad998f2507cc77eee201536acd5324b7e" translate="yes" xml:space="preserve">
          <source>℞ 38: Making &lt;code&gt;cmp&lt;/code&gt; work on text instead of codepoints</source>
          <target state="translated">℞ 38: Making &lt;code&gt;cmp&lt;/code&gt; work on text instead of codepoints</target>
        </trans-unit>
        <trans-unit id="752951dd1ac1d7aaa972f69d508595bf5911635b" translate="yes" xml:space="preserve">
          <source>℞ 38: Making cmp work on text instead of codepoints</source>
          <target state="translated">℞ 38: Making cmp work on text instead of codepoints</target>
        </trans-unit>
        <trans-unit id="82c6a6149a99cdb0e50810b081474bdbf59d7dfd" translate="yes" xml:space="preserve">
          <source>℞ 39: Case-</source>
          <target state="translated">℞ 39: Case-</target>
        </trans-unit>
        <trans-unit id="8d5852da7209d5884eebf3b9eb1eb39a14ba85cd" translate="yes" xml:space="preserve">
          <source>℞ 39: Case- _and_ accent-insensitive comparisons</source>
          <target state="translated">℞ 39: Case- _and_ accent-insensitive comparisons</target>
        </trans-unit>
        <trans-unit id="60b49826b5438b22cc51f4ed224510924e54001e" translate="yes" xml:space="preserve">
          <source>℞ 3: Declare source in utf8 for identifiers and literals</source>
          <target state="translated">℞ 3: Declare source in utf8 for identifiers and literals</target>
        </trans-unit>
        <trans-unit id="8f875003d571e6d58aad407fafc68fd83431ef5c" translate="yes" xml:space="preserve">
          <source>℞ 40: Case-</source>
          <target state="translated">℞ 40: Case-</target>
        </trans-unit>
        <trans-unit id="012ea33c9fc5bf5e135a6a94297f8e911c2c2728" translate="yes" xml:space="preserve">
          <source>℞ 40: Case- _and_ accent-insensitive locale comparisons</source>
          <target state="translated">℞ 40: Case- _and_ accent-insensitive locale comparisons</target>
        </trans-unit>
        <trans-unit id="4537b129b3ba8f2d3226ebf93ad67329cc1da482" translate="yes" xml:space="preserve">
          <source>℞ 41: Unicode linebreaking</source>
          <target state="translated">℞ 41: Unicode linebreaking</target>
        </trans-unit>
        <trans-unit id="ffb493f106ab48250c4114cb54731a428a45f791" translate="yes" xml:space="preserve">
          <source>℞ 42: Unicode text in DBM hashes, the tedious way</source>
          <target state="translated">℞ 42: Unicode text in DBM hashes, the tedious way</target>
        </trans-unit>
        <trans-unit id="f1f50342b103e421d1acc80b87da618d9d7dbcbf" translate="yes" xml:space="preserve">
          <source>℞ 43: Unicode text in DBM hashes, the easy way</source>
          <target state="translated">℞ 43: Unicode text in DBM hashes, the easy way</target>
        </trans-unit>
        <trans-unit id="be7f9e81a5e53cdd3b016c1ec9d11fc76ad6eba7" translate="yes" xml:space="preserve">
          <source>℞ 44: PROGRAM: Demo of Unicode collation and printing</source>
          <target state="translated">℞ 44: PROGRAM: Demo of Unicode collation and printing</target>
        </trans-unit>
        <trans-unit id="35d3a90ee9a924edf21b2fcf53b46d3f1ee47cd1" translate="yes" xml:space="preserve">
          <source>℞ 4: Characters and their numbers</source>
          <target state="translated">℞ 4: Characters and their numbers</target>
        </trans-unit>
        <trans-unit id="8c799958f1af6fc7d0af3b5af403902598504cc5" translate="yes" xml:space="preserve">
          <source>℞ 5: Unicode literals by character number</source>
          <target state="translated">℞ 5: Unicode literals by character number</target>
        </trans-unit>
        <trans-unit id="552601dd95b39360794bf9c6c82f6ccf33fa9abf" translate="yes" xml:space="preserve">
          <source>℞ 6: Get character name by number</source>
          <target state="translated">℞ 6: Get character name by number</target>
        </trans-unit>
        <trans-unit id="16cf8eadbcf317c2200365ffa590b025a1e5c8c9" translate="yes" xml:space="preserve">
          <source>℞ 7: Get character number by name</source>
          <target state="translated">℞ 7: Get character number by name</target>
        </trans-unit>
        <trans-unit id="914bc39318d79633608c077d658050da4a15d838" translate="yes" xml:space="preserve">
          <source>℞ 8: Unicode named characters</source>
          <target state="translated">℞ 8: Unicode named characters</target>
        </trans-unit>
        <trans-unit id="3f674921da6a254bb1bdedb20a3aa7a9fc774879" translate="yes" xml:space="preserve">
          <source>℞ 9: Unicode named sequences</source>
          <target state="translated">℞ 9: Unicode named sequences</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
