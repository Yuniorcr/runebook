<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="5ce2bae285dbd09666d07f99e460e4eebea8c753" translate="yes" xml:space="preserve">
          <source>This method uses &lt;code&gt;commands_quote&lt;/code&gt; to determine the correct quote. If &lt;code&gt;commands_quote&lt;/code&gt; is a space, no quoting will take place.</source>
          <target state="translated">이 방법은 &lt;code&gt;commands_quote&lt;/code&gt; 를 사용하여 올바른 따옴표를 결정합니다. 경우 &lt;code&gt;commands_quote&lt;/code&gt; 는 공간이다, 더 열릴 예정이다 인용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="475ff388d47d9ff8c537b04d4cf8fd2786ec177c" translate="yes" xml:space="preserve">
          <source>This method was added in v0.20 of Math::BigRat (May 2007).</source>
          <target state="translated">이 방법은 Math :: BigRat (2007 년 5 월) v0.20에서 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="a9fdbef062f1e260e975ac993cde1b7e7c35b43d" translate="yes" xml:space="preserve">
          <source>This method was added in v0.22 of Math::BigRat (April 2008).</source>
          <target state="translated">이 방법은 Math :: BigRat (2008 년 4 월) v0.22에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="4f274a73d8190736635c257c7c7cb3e3c0fe18c0" translate="yes" xml:space="preserve">
          <source>This method was added in v1.82 of Math::BigInt (April 2007).</source>
          <target state="translated">이 방법은 Math :: BigInt (2007 년 4 월) v1.82에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="892100fd26e628f38d9cdb9d5d762a8a6ee16072" translate="yes" xml:space="preserve">
          <source>This method was added in v1.84 of Math::BigInt (April 2007).</source>
          <target state="translated">이 방법은 Math :: BigInt (2007 년 4 월) v1.84에서 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="def53de6390772e9ab517671e2de82585ed2894d" translate="yes" xml:space="preserve">
          <source>This method was added in v1.87 of Math::BigInt (June 2007).</source>
          <target state="translated">이 방법은 Math :: BigInt (2007 년 6 월) v1.87에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="e5821a661d4054cf93a3f0baee35e1a4e8ee9c19" translate="yes" xml:space="preserve">
          <source>This method will be called when the &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; function is called.</source>
          <target state="translated">이 메소드는 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 함수가 호출 될 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="33be8d090d52cdf9ebec70873885856aba821ff5" translate="yes" xml:space="preserve">
          <source>This method will be called when the &lt;code&gt;&lt;a href=&quot;functions/getc&quot;&gt;getc&lt;/a&gt;&lt;/code&gt; function is called.</source>
          <target state="translated">이 메소드는 &lt;code&gt;&lt;a href=&quot;functions/getc&quot;&gt;getc&lt;/a&gt;&lt;/code&gt; 함수가 호출 될 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="07abfda6230642bdc24b2988efac200062ab0904" translate="yes" xml:space="preserve">
          <source>This method will be called when the handle is closed via the &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">이 함수 는 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 함수 를 통해 핸들을 닫을 때 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="8c952116674febc1216a1fb0e4796db40ca65ad8" translate="yes" xml:space="preserve">
          <source>This method will be called when the handle is read from via the &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; 함수 를 통해 핸들을 읽을 때이 메소드가 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="53bcf4b7992a6d18135efe380f6cf616566ace5a" translate="yes" xml:space="preserve">
          <source>This method will be called when the handle is written to via the &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">이 메소드는 &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; 함수 를 통해 핸들을 쓸 때 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="2f7eb1cf0cb3798f7407e75f4a0686ab61a556fd" translate="yes" xml:space="preserve">
          <source>This method will be triggered every time an element in the tied array is set (written). It takes two arguments beyond its self reference: the index at which we're trying to store something and the value we're trying to put there.</source>
          <target state="translated">이 방법은 연결된 배열의 요소가 설정 (쓰기) 될 때마다 트리거됩니다. 자체 참조를 넘어 두 가지 인수가 필요합니다. 우리가 무언가를 저장하려는 색인과 거기에 넣는 가치.</target>
        </trans-unit>
        <trans-unit id="fef1865fb35cee1965cbfbe2864d43cfb61253d3" translate="yes" xml:space="preserve">
          <source>This method will be triggered every time an element in the tied hash is accessed (read). It takes one argument beyond its self reference: the key whose value we're trying to fetch.</source>
          <target state="translated">이 방법은 연결된 해시의 요소에 액세스 (읽기) 할 때마다 트리거됩니다. 자체 참조를 넘어 하나의 인수가 필요합니다. 키를 가져 오려는 키입니다.</target>
        </trans-unit>
        <trans-unit id="6ff0eaa0013ee12dae761b1f3a38cc41d40d71c7" translate="yes" xml:space="preserve">
          <source>This method will be triggered every time an element in the tied hash is set (written). It takes two arguments beyond its self reference: the index at which we're trying to store something, and the value we're trying to put there.</source>
          <target state="translated">이 방법은 연결된 해시의 요소가 설정 (쓰기) 될 때마다 트리거됩니다. 자체 참조를 넘어 두 가지 인수가 필요합니다. 우리가 무언가를 저장하려는 색인과 거기에 넣는 가치.</target>
        </trans-unit>
        <trans-unit id="f154ed5d9dede0079ff14f755f8d64da0b6d8569" translate="yes" xml:space="preserve">
          <source>This method will be triggered every time an individual element the tied array is accessed (read). It takes one argument beyond its self reference: the index whose value we're trying to fetch.</source>
          <target state="translated">이 방법은 연결된 배열의 개별 요소에 액세스 (읽기) 할 때마다 트리거됩니다. 자체 참조를 넘어서 하나의 인수가 필요합니다. 인덱스를 가져 오려는 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="ce4bdb5814566177219471512f35e981a551516b" translate="yes" xml:space="preserve">
          <source>This method will be triggered every time the tied handle is printed to with the &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say()&lt;/a&gt;&lt;/code&gt; functions. Beyond its self reference it also expects the list that was passed to the print function.</source>
          <target state="translated">이 메소드는 묶인 핸들이 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say()&lt;/a&gt;&lt;/code&gt; 함수로 인쇄 될 때마다 트리거됩니다 . 자체 참조 외에 인쇄 기능에 전달 된 목록도 예상합니다.</target>
        </trans-unit>
        <trans-unit id="46e361c76a8fe326ef26947ed7b27ef6314ab7da" translate="yes" xml:space="preserve">
          <source>This method will be triggered every time the tied handle is printed to with the &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf()&lt;/a&gt;&lt;/code&gt; function. Beyond its self reference it also expects the format and list that was passed to the printf function.</source>
          <target state="translated">이 메소드는 묶인 핸들이 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf()&lt;/a&gt;&lt;/code&gt; 함수로 인쇄 될 때마다 트리거됩니다 . 자체 참조 외에 printf 함수에 전달 된 형식과 목록도 예상합니다.</target>
        </trans-unit>
        <trans-unit id="4d2309a54c3a525e60bc8a57c49ad44a6f62e89e" translate="yes" xml:space="preserve">
          <source>This method will be triggered every time the tied variable is accessed (read). It takes no arguments beyond its self reference, which is the object representing the scalar we're dealing with. Because in this case we're using just a SCALAR ref for the tied scalar object, a simple $$self allows the method to get at the real value stored there. In our example below, that real value is the process ID to which we've tied our variable.</source>
          <target state="translated">이 메소드는 묶인 변수에 액세스 (읽기) 할 때마다 트리거됩니다. 우리가 다루는 스칼라를 나타내는 객체 인 자체 참조를 넘어서는 인수를 취하지 않습니다. 이 경우 우리는 연결된 스칼라 객체에 대해 SCALAR 참조 만 사용하기 때문에 간단한 $$ self를 사용하면 메소드가 저장된 실제 값을 얻을 수 있습니다. 아래 예에서 해당 실제 값은 변수를 연결 한 프로세스 ID입니다.</target>
        </trans-unit>
        <trans-unit id="074aba193a7d4ab7fc2d92f3649243f7a2526fbd" translate="yes" xml:space="preserve">
          <source>This method will be triggered every time the tied variable is set (assigned). Beyond its self reference, it also expects one (and only one) argument: the new value the user is trying to assign. Don't worry about returning a value from STORE; the semantic of assignment returning the assigned value is implemented with FETCH.</source>
          <target state="translated">이 방법은 묶인 변수가 설정 (할당) 될 때마다 트리거됩니다. 자체 참조 외에도 사용자가 할당하려는 새로운 가치라는 단 하나의 주장이 필요합니다. STORE에서 값을 반환하는 것에 대해 걱정하지 마십시오. 할당 된 값을 반환하는 할당의 의미는 FETCH로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="a70c828d5225a812501600b7ba6a4a618714e8ab" translate="yes" xml:space="preserve">
          <source>This method will be triggered when the &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; occurs. This can be useful if the class needs to know when no further calls will be made. (Except DESTROY of course.) See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;The untie Gotcha&lt;/a&gt; below for more details.</source>
          <target state="translated">때이 방법은 트리거됩니다 &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; 발생합니다. 더 이상 전화를 걸지 않을 때 클래스가 알아야 할 경우에 유용합니다. (물론 DESTROY는 제외) 자세한 내용 &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;은&lt;/a&gt; 아래 untie Gotcha 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c6dadf6ee9215d45834b1ebd72a2a25ea540b456" translate="yes" xml:space="preserve">
          <source>This method will be triggered when the tied variable needs to be destructed. As with other object classes, such a method is seldom necessary, because Perl deallocates its moribund object's memory for you automatically--this isn't C++, you know. We'll use a DESTROY method here for debugging purposes only.</source>
          <target state="translated">이 방법은 묶인 변수를 파기해야 할 때 트리거됩니다. 다른 객체 클래스와 마찬가지로 Perl은 많은 객체 객체의 메모리를 자동으로 할당 해제하기 때문에 거의 필요하지 않습니다. C ++이 아닙니다. 여기서는 디버깅 목적으로 만 DESTROY 메소드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="aba37b5cce6ea3c8466dd8e8d0896cfdf208ff19" translate="yes" xml:space="preserve">
          <source>This method will be triggered when the tied variable needs to be destructed. As with the scalar tie class, this is almost never needed in a language that does its own garbage collection, so this time we'll just leave it out.</source>
          <target state="translated">이 방법은 묶인 변수를 파기해야 할 때 트리거됩니다. 스칼라 타이 클래스와 마찬가지로, 이것은 자체 가비지 콜렉션을 수행하는 언어에서는 거의 필요하지 않으므로 이번에는 생략합니다.</target>
        </trans-unit>
        <trans-unit id="1a30c4c1dc9863704c12fdf1f1b5872e08e0156b" translate="yes" xml:space="preserve">
          <source>This method will be triggered when the user is going to iterate through the hash, such as via a keys() or each() call.</source>
          <target state="translated">이 메소드는 사용자가 keys () 또는 each () 호출과 같은 해시를 통해 반복하려고 할 때 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="241be65c4fe89a7db745cd5e6028ee4cea0a4bd5" translate="yes" xml:space="preserve">
          <source>This method will do a file transfer between two remote ftp servers. If &lt;code&gt;DEST_FILE&lt;/code&gt; is omitted then the leaf name of &lt;code&gt;SRC_FILE&lt;/code&gt; will be used.</source>
          <target state="translated">이 방법은 두 개의 원격 ftp 서버간에 파일 전송을 수행합니다. 경우 &lt;code&gt;DEST_FILE&lt;/code&gt; 은 다음 생략의 잎 이름 &lt;code&gt;SRC_FILE&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="714241362af6626714a493d5da28a5f3831d1838" translate="yes" xml:space="preserve">
          <source>This method will get/set the corresponding parse-tree of the interior sequence's text.</source>
          <target state="translated">이 메소드는 내부 시퀀스 텍스트의 해당 구문 분석 트리를 가져 오거나 설정합니다.</target>
        </trans-unit>
        <trans-unit id="81f73213adc2e84a3c6f2373dbd483c50f803f34" translate="yes" xml:space="preserve">
          <source>This method will get/set the corresponding parse-tree of the paragraph's text.</source>
          <target state="translated">이 메소드는 단락 텍스트의 해당 구문 분석 트리를 가져 오거나 설정합니다.</target>
        </trans-unit>
        <trans-unit id="e9978ed2996dd9bcc230654360a798a867715edb" translate="yes" xml:space="preserve">
          <source>This method will read the named file and deserialize it to a data structure, determining whether it should be JSON or YAML based on the filename. The file will be read using the &quot;:utf8&quot; IO layer.</source>
          <target state="translated">이 메소드는 명명 된 파일을 읽고 데이터 구조로 역 직렬화하여 파일 이름을 기준으로 JSON 또는 YAML이어야하는지 여부를 결정합니다. &quot;: utf8&quot;IO 계층을 사용하여 파일을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="b67738b0ceee5f0e621228df6d40624bf3ba896e" translate="yes" xml:space="preserve">
          <source>This method will reset the deflation object &lt;code&gt;$d&lt;/code&gt; . It can be used when you are compressing multiple data streams and want to use the same object to compress each of them. It should only be used once the previous data stream has been flushed successfully, i.e. a call to &lt;code&gt;$d-&amp;gt;flush(Z_FINISH)&lt;/code&gt; has returned &lt;code&gt;Z_OK&lt;/code&gt; .</source>
          <target state="translated">이 메소드는 수축 오브젝트 &lt;code&gt;$d&lt;/code&gt; 재설정합니다 . 여러 데이터 스트림을 압축하고 동일한 오브젝트를 사용하여 각 데이터 스트림을 압축하려는 경우 사용할 수 있습니다. 이전 데이터 스트림이 성공적으로 플러시 된 후에 만 ​​사용해야합니다. 즉 &lt;code&gt;$d-&amp;gt;flush(Z_FINISH)&lt;/code&gt; 호출이 &lt;code&gt;Z_OK&lt;/code&gt; 를 반환 했습니다 .</target>
        </trans-unit>
        <trans-unit id="c896817c407b0236207a4f8181caaf53efac5199" translate="yes" xml:space="preserve">
          <source>This method will reset the inflation object &lt;code&gt;$i&lt;/code&gt; . It can be used when you are uncompressing multiple data streams and want to use the same object to uncompress each of them.</source>
          <target state="translated">이 방법은 인플레이션 객체 &lt;code&gt;$i&lt;/code&gt; 재설정합니다 . 여러 데이터 스트림을 압축 해제하고 동일한 오브젝트를 사용하여 각 데이터 압축을 해제하려는 경우에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c910df5717be7f7845368e614ada212ccc95c585" translate="yes" xml:space="preserve">
          <source>This method will return a &lt;a href=&quot;result&quot;&gt;TAP::Parser::Result&lt;/a&gt; object representing the current line of TAP.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;result&quot;&gt;TAP&lt;/a&gt; 의 현재 줄을 나타내는 TAP :: Parser :: Result 객체 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="94dd0495b55dbb9479c740e8c7707434102ef2b3" translate="yes" xml:space="preserve">
          <source>This method will return the</source>
          <target state="translated">이 메소드는</target>
        </trans-unit>
        <trans-unit id="64b72f6b7b9c90292fdf0c07acf00371c342b31f" translate="yes" xml:space="preserve">
          <source>This method will return the corresponding text of the paragraph.</source>
          <target state="translated">이 메서드는 단락의 해당 텍스트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eb400e4423b1637ce4c15ebb34457f31a6dff2be" translate="yes" xml:space="preserve">
          <source>This method, also added in 5.22, returns the ID of the outer padlist.</source>
          <target state="translated">5.22에 추가 된이 방법은 외부 padlist의 ID를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4592c3f20e832c80ee7755d708e2fc413aad3a8b" translate="yes" xml:space="preserve">
          <source>This method, introduced in 5.22, returns an ID shared by clones of the same padlist.</source>
          <target state="translated">5.22에 도입 된이 방법은 동일한 padlist의 클론이 공유 한 ID를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9809e060290c8d05a80c630d780720e4ef068203" translate="yes" xml:space="preserve">
          <source>This method, introduced in 5.22, returns the B::PADNAMELIST. It is equivalent to &lt;code&gt;ARRAYelt&lt;/code&gt; with a 0 argument.</source>
          <target state="translated">5.22에 도입 된이 방법은 B :: PADNAMELIST를 반환합니다. 인수가 0 인 &lt;code&gt;ARRAYelt&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="29b87abd8043418845a4e29d3099fa81c542084b" translate="yes" xml:space="preserve">
          <source>This model is also handy for a form of recursive programming where, rather than having a subroutine call itself, it instead creates another thread. Prime and Fibonacci generators both map well to this form of the pipeline model. (A version of a prime number generator is presented later on.)</source>
          <target state="translated">이 모델은 서브 루틴 호출 자체가 아닌 다른 스레드를 생성하는 재귀 프로그래밍 형식에도 유용합니다. 프라임 및 피보나치 생성기는 모두 이러한 형태의 파이프 라인 모델에 잘 매핑됩니다. 소수 생성기의 버전은 나중에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="30009f920550802cc665953dfad42c7d9264746f" translate="yes" xml:space="preserve">
          <source>This model is common in GUI and server programs, where a main thread waits for some event and then passes that event to the appropriate worker threads for processing. Once the event has been passed on, the boss thread goes back to waiting for another event.</source>
          <target state="translated">이 모델은 기본 스레드가 일부 이벤트를 기다린 다음 해당 이벤트를 처리하기 위해 해당 작업자 스레드로 전달하는 GUI 및 서버 프로그램에서 일반적입니다. 이벤트가 전달되면 보스 스레드는 다시 다른 이벤트를 대기합니다.</target>
        </trans-unit>
        <trans-unit id="b15bc8cde549f860c8eb7d12b3582c3e0ea39cf3" translate="yes" xml:space="preserve">
          <source>This model is particularly useful if the system running the program will distribute multiple threads across different processors. It can also be useful in ray tracing or rendering engines, where the individual threads can pass on interim results to give the user visual feedback.</source>
          <target state="translated">이 모델은 프로그램을 실행하는 시스템이 여러 프로세서에 여러 스레드를 분산시키는 경우에 특히 유용합니다. 또한 개별 스레드가 임시 결과를 전달하여 사용자에게 시각적 피드백을 제공 할 수있는 광선 추적 또는 렌더링 엔진에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a46d487d5e105c40547660dc27acaa14d80672b3" translate="yes" xml:space="preserve">
          <source>This model makes the most sense if you have multiple processors so two or more threads will be executing in parallel, though it can often make sense in other contexts as well. It tends to keep the individual tasks small and simple, as well as allowing some parts of the pipeline to block (on I/O or system calls, for example) while other parts keep going. If you're running different parts of the pipeline on different processors you may also take advantage of the caches on each processor.</source>
          <target state="translated">이 모델은 프로세서가 여러 개인 경우 두 개 이상의 스레드가 병렬로 실행되는 경우에 가장 적합하지만 다른 컨텍스트에서도 의미가 있습니다. 개별 작업을 작고 단순하게 유지하는 한편 파이프 라인의 일부를 차단 (예 : I / O 또는 시스템 호출)하는 동안 다른 부분은 계속 진행하는 경향이 있습니다. 파이프 라인의 다른 부분을 다른 프로세서에서 실행중인 경우 각 프로세서의 캐시를 활용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca5c3fc9e826014a4bf6c25dd9dfaa294e403640" translate="yes" xml:space="preserve">
          <source>This modifier is automatically selected by default when none of the others are, so yet another name for it is &quot;Default&quot;.</source>
          <target state="translated">이 수정자는 다른 설정이 없으면 기본적으로 자동으로 선택되므로 다른 이름은 &quot;Default&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="7d496a068117111419859bc00c9612b716988f03" translate="yes" xml:space="preserve">
          <source>This modifier is useful for people who only incidentally use Unicode, and who do not wish to be burdened with its complexities and security concerns.</source>
          <target state="translated">이 수정자는 실수로 유니 코드 만 사용하고 복잡성과 보안 문제로 부담을 느끼고 싶지 않은 사람들에게 유용합니다.</target>
        </trans-unit>
        <trans-unit id="0e5335d13a0034ff0e79330d63821913e0ac8c3f" translate="yes" xml:space="preserve">
          <source>This modifier may be specified to be the default by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature
'unicode_strings&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale ':not_characters'&lt;/code&gt; , or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use VERSION&lt;/a&gt;&lt;/code&gt; (or higher), but see &lt;a href=&quot;#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect?&lt;/a&gt;.</source>
          <target state="translated">이 수정하여 기본으로 지정할 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale ':not_characters'&lt;/code&gt; , 또는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use VERSION&lt;/a&gt;&lt;/code&gt; (또는 그 이상) 만 볼 &lt;a href=&quot;#Which-character-set-modifier-is-in-effect%3f&quot;&gt;효과에 어떤 문자 집합을 수정? &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="4e12be54768ee3b0c57bff3f17db521cb0aa4207" translate="yes" xml:space="preserve">
          <source>This modifier may be specified to be the default by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , but see &lt;a href=&quot;#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect?&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 을 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하여이 수정자를 기본값으로 지정할 수 있지만 &lt;a href=&quot;#Which-character-set-modifier-is-in-effect%3f&quot;&gt;어떤 문자 세트 수정자가 유효한지&lt;/a&gt; 확인하십시오 . .</target>
        </trans-unit>
        <trans-unit id="7947231e9d8ba8a56b871805ba4f83e34edd5a3b" translate="yes" xml:space="preserve">
          <source>This modifier may be specified to be the default by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/a'&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/aa'&lt;/code&gt; . If you do so, you may actually have occasion to use the &lt;code&gt;/u&lt;/code&gt; modifier explicitly if there are a few regular expressions where you do want full Unicode rules (but even here, it's best if everything were under feature &lt;code&gt;&quot;unicode_strings&quot;&lt;/code&gt; , along with the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/aa'&lt;/code&gt; ). Also see &lt;a href=&quot;#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect?&lt;/a&gt;.</source>
          <target state="translated">이 수정하여 기본으로 지정할 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/a'&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/aa'&lt;/code&gt; . 그렇게하면 완전한 유니 코드 규칙을 원하는 정규 표현식이 몇 개인 경우 실제로 &lt;code&gt;/u&lt;/code&gt; 수정자를 명시 적으로 사용할 수 있습니다 (그러나 여기에서도 모든 것이 &lt;code&gt;&quot;unicode_strings&quot;&lt;/code&gt; 기능 과 함께 사용되는 것이 가장 좋습니다) . &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/aa'&lt;/code&gt; ). &lt;a href=&quot;#Which-character-set-modifier-is-in-effect%3f&quot;&gt;어떤 문자 세트 수정자가 유효한지&lt;/a&gt; 참조하십시오 . .</target>
        </trans-unit>
        <trans-unit id="612208176f5e5f15f70f9fe87ffb9885ed3fb4f8" translate="yes" xml:space="preserve">
          <source>This modifier means to use the &quot;Default&quot; native rules of the platform except when there is cause to use Unicode rules instead, as follows:</source>
          <target state="translated">이 수정자는 다음과 같이 대신 유니 코드 규칙을 사용해야하는 경우를 제외하고 플랫폼의 &quot;기본&quot;기본 규칙을 사용함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="749227e1bbfa4aaec7c32f6b70520da88bebf428" translate="yes" xml:space="preserve">
          <source>This modifier stands for ASCII-restrict (or ASCII-safe). This modifier, unlike the others, may be doubled-up to increase its effect.</source>
          <target state="translated">이 수정자는 ASCII 제한 (또는 ASCII 안전)을 나타냅니다. 이 수정자는 다른 수정 자와 달리 효과를 높이기 위해 두 배가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa6de4fa0b87cce4f41c3c3e6b2f399a24f53e8f" translate="yes" xml:space="preserve">
          <source>This module abstracts and provides all of the hooks into Perl internal debugging functionality, so that various implementations of Perl debuggers (or packages that want to simply get at the &quot;privileged&quot; debugging data) can all benefit from the development of this common code. Currently used by Swat, the perl/Tk GUI debugger.</source>
          <target state="translated">이 모듈은 Perl 내부 디버깅 기능에 대한 모든 후크를 추상화하고 제공하므로 Perl 디버거의 다양한 구현 (또는 &quot;권한이있는&quot;디버깅 데이터를 가져 오려는 패키지)이이 공통 코드 개발의 이점을 누릴 수 있습니다. 현재 perl / Tk GUI 디버거 인 Swat에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6875f545409eef33a68dd7123f3a8648204e39c4" translate="yes" xml:space="preserve">
          <source>This module allows one to set this attribute on a subroutine that is already defined. For Perl subroutines (XSUBs are fine), it may or may not do what you want, depending on the code inside the subroutine, with details subject to change in future Perl versions. You may run into problems with lvalue context not being propagated properly into the subroutine, or maybe even assertion failures. For this reason, a warning is emitted if warnings are enabled. In other words, you should only do this if you really know what you are doing. You have been warned.</source>
          <target state="translated">이 모듈을 사용하면 이미 정의 된 서브 루틴에서이 속성을 설정할 수 있습니다. Perl 서브 루틴 (XSUB는 괜찮음)의 경우 서브 루틴 내부 코드에 따라 향후 Perl 버전에서 변경 될 수있는 세부 사항과 함께 원하는 것을 수행하거나 수행하지 않을 수 있습니다. lvalue 컨텍스트가 서브 루틴에 제대로 전파되지 않거나 어설 션 오류가 발생하는 문제가 발생할 수 있습니다. 이러한 이유로 경고가 활성화되면 경고가 발생합니다. 다시 말해서, 자신이하고있는 일을 정말로 알고있는 경우에만이를 수행해야합니다. 경고를 받았습니다.</target>
        </trans-unit>
        <trans-unit id="a965ba5c24e8c32086e33820dca8017e296c7bac" translate="yes" xml:space="preserve">
          <source>This module also adds a stack trace to the error message when perl dies. This is useful for pinpointing what caused the death. The &lt;b&gt;-traceonly&lt;/b&gt; (or just &lt;b&gt;-t&lt;/b&gt;) flag turns off the explanations of warning messages leaving just the stack traces. So if your script is dieing, run it again with</source>
          <target state="translated">이 모듈은 또한 perl이 죽을 때 오류 메시지에 스택 추적을 추가합니다. 이것은 사망 원인을 정확히 찾아내는 데 유용합니다. &lt;b&gt;-traceonly&lt;/b&gt; (또는 &lt;b&gt;-t&lt;/b&gt; 단지 스택 흔적을 남기지 경고 메시지의 설명 오프) 플래그집니다. 스크립트가 죽으면 다시 실행하십시오</target>
        </trans-unit>
        <trans-unit id="8f7fb6f3dfdd280d1b2872ffca7de6a38c89ca71" translate="yes" xml:space="preserve">
          <source>This module also provides a function &lt;code&gt;I18N::LangTags::List::is_decent( &lt;i&gt;langtag&lt;/i&gt; )&lt;/code&gt; that returns true iff the language tag is syntactically valid and is for general use (like &quot;fr&quot; or &quot;fr-ca&quot;, below). That is, it returns false for tags that are syntactically invalid and for tags, like &quot;aus&quot;, that are listed in brackets below. This function is not exported.</source>
          <target state="translated">이 모듈은 &lt;code&gt;I18N::LangTags::List::is_decent( &lt;i&gt;langtag&lt;/i&gt; )&lt;/code&gt; &lt;i&gt;langtag&lt;/i&gt; 기능도 제공합니다&lt;i&gt;&lt;/i&gt; 은 언어 태그가 구문 상 유효하고 일반적인 용도 (아래 &quot;fr&quot;또는 &quot;fr-ca&quot;등) 인 경우 true를 반환 ) . 즉, 구문 상 유효하지 않은 태그와 &quot;aus&quot;와 같이 아래 괄호 안에있는 태그에 대해서는 false를 반환합니다. 이 기능은 내보내지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="35c9fcef6d8c497b285988252e5e12636887688f" translate="yes" xml:space="preserve">
          <source>This module and its competitor, the CPANPLUS module, are both much cooler than the other. CPAN.pm is older. CPANPLUS was designed to be more modular, but it was never intended to be compatible with CPAN.pm.</source>
          <target state="translated">이 모듈과 경쟁사 인 CPANPLUS 모듈은 다른 모듈보다 훨씬 시원합니다. CPAN.pm이 이전 버전입니다. CPANPLUS는 모듈 식으로 설계되었지만 CPAN.pm과 호환되도록 설계되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="784f2f639e9afabf2dc275e208777379339cfa1d" translate="yes" xml:space="preserve">
          <source>This module attempts to be squeaky clean w.r.t &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; and when warnings are enabled.</source>
          <target state="translated">이 모듈 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; 경고가 활성화 된 경우</target>
        </trans-unit>
        <trans-unit id="004ba23e4c1d9e020129a075fb1542d515c8beb8" translate="yes" xml:space="preserve">
          <source>This module by Jos Boumans &amp;lt;kane@cpan.org&amp;gt;.</source>
          <target state="translated">이 모듈은 Jos Boumans &amp;lt;kane@cpan.org&amp;gt;에서 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3512e67f1197d03fbeb001853d009060532cfa22" translate="yes" xml:space="preserve">
          <source>This module can build the C portions of Perl modules by invoking the appropriate compilers and linkers in a cross-platform manner. It was motivated by the &lt;code&gt;Module::Build&lt;/code&gt; project, but may be useful for other purposes as well. However, it is</source>
          <target state="translated">이 모듈은 적절한 컴파일러 및 링커를 크로스 플랫폼 방식으로 호출하여 Perl 모듈의 C 부분을 빌드 할 수 있습니다. &lt;code&gt;Module::Build&lt;/code&gt; 에서 동기를 부여했습니다. 프로젝트에 되었지만 다른 목적에도 유용 할 수 있습니다. 그러나 그것은</target>
        </trans-unit>
        <trans-unit id="26eefbe0903fb2ede95e48daeed0c357506e5da6" translate="yes" xml:space="preserve">
          <source>This module can provoke sizeable inefficiencies for regular expressions, due to unfortunate implementation details. If performance matters in your application and you don't need $PREMATCH, $MATCH, or $POSTMATCH, try doing</source>
          <target state="translated">이 모듈은 불행한 구현 세부 사항으로 인해 정규 표현식에 대해 상당한 비 효율성을 유발할 수 있습니다. 응용 프로그램에서 성능이 중요하고 $ PREMATCH, $ MATCH 또는 $ POSTMATCH가 필요하지 않은 경우</target>
        </trans-unit>
        <trans-unit id="5e29d99feceeb44433f425fbac43b49ef593d502" translate="yes" xml:space="preserve">
          <source>This module comes in two flavors: one for modern perls (5.10 and above) and one for ancient obsolete perls. The version for modern perls has support for Unicode. The version for old perls does not. You can tell which version you have installed by looking at &lt;code&gt;$Text::Tabs::SUBVERSION&lt;/code&gt; : it is &lt;code&gt;old&lt;/code&gt; for obsolete perls and &lt;code&gt;modern&lt;/code&gt; for current perls.</source>
          <target state="translated">이 모듈은 현대 펄 (5.10 이상)과 고대 낡은 펄용의 두 가지 맛이 있습니다. 최신 perls 버전은 유니 코드를 지원합니다. 이전 perls의 버전은 그렇지 않습니다. 당신은 당신이보고 설치 한 버전을 알 수 있습니다 &lt;code&gt;$Text::Tabs::SUBVERSION&lt;/code&gt; : 그것이 &lt;code&gt;old&lt;/code&gt; 쓸모 perls과 &lt;code&gt;modern&lt;/code&gt; 현재 perls합니다.</target>
        </trans-unit>
        <trans-unit id="febd1d0bc1aeb9c9dc580b98ecebabe324968f11" translate="yes" xml:space="preserve">
          <source>This module comes in two flavors: one for modern perls (5.10 and above) and one for ancient obsolete perls. The version for modern perls has support for Unicode. The version for old perls does not. You can tell which version you have installed by looking at &lt;code&gt;$Text::Wrap::SUBVERSION&lt;/code&gt; : it is &lt;code&gt;old&lt;/code&gt; for obsolete perls and &lt;code&gt;modern&lt;/code&gt; for current perls.</source>
          <target state="translated">이 모듈은 현대 펄 (5.10 이상)과 고대 낡은 펄용의 두 가지 맛이 있습니다. 최신 perls 버전은 유니 코드를 지원합니다. 이전 perls의 버전은 그렇지 않습니다. 당신은 당신이보고 설치 한 버전을 알 수 있습니다 &lt;code&gt;$Text::Wrap::SUBVERSION&lt;/code&gt; : 그것이 &lt;code&gt;old&lt;/code&gt; 쓸모 perls과 &lt;code&gt;modern&lt;/code&gt; 현재 perls합니다.</target>
        </trans-unit>
        <trans-unit id="d14a28688b621d987b1f8fc9e23815cd4abf0ed8" translate="yes" xml:space="preserve">
          <source>This module contains a good example of how to use tie to implement a cache and an example of how to make a tied variable readonly to those outside of it.</source>
          <target state="translated">이 모듈에는 tie를 사용하여 캐시를 구현하는 방법과 묶인 변수를 읽기 전용으로 만드는 방법에 대한 좋은 예가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d311a4e7a3db9109ca676b3552f311797aef79ac" translate="yes" xml:space="preserve">
          <source>This module contains methods to test the reachability of remote hosts on a network. A ping object is first created with optional parameters, a variable number of hosts may be pinged multiple times and then the connection is closed.</source>
          <target state="translated">이 모듈에는 네트워크에서 원격 호스트의 연결 가능성을 테스트하는 방법이 포함되어 있습니다. 핑 개체는 먼저 선택적 매개 변수를 사용하여 만들어지며 가변 수의 호스트가 여러 번 핑될 수 있으며 연결이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="0e0177cabfcfd905cc13252e41134159a6c784e5" translate="yes" xml:space="preserve">
          <source>This module deals with a lot of system dependencies and has quite a few architecture specific &lt;code&gt;if&lt;/code&gt; s in the code.</source>
          <target state="translated">이 모듈 시스템 종속성의 많은 거래와 꽤 아키텍처 특정이 &lt;code&gt;if&lt;/code&gt; 코드에들.</target>
        </trans-unit>
        <trans-unit id="048af0729c3efd4457ee6a9d255333490a26b61d" translate="yes" xml:space="preserve">
          <source>This module defines a standard</source>
          <target state="translated">이 모듈은 표준을 정의합니다</target>
        </trans-unit>
        <trans-unit id="ccc077b805dfb6d70b724e9bdd6fb4fe5347a6c3" translate="yes" xml:space="preserve">
          <source>This module defines one public function, &lt;code&gt;I18N::LangTags::Detect::detect()&lt;/code&gt; . This function is not exported (nor is even exportable), and it takes no parameters.</source>
          <target state="translated">이 모듈은 하나의 공용 함수 &lt;code&gt;I18N::LangTags::Detect::detect()&lt;/code&gt; 합니다. 이 함수는 익스포트되지 않으며 (아직 익스포트 가능하지 않음) 매개 변수를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d9f93c560d9ab4f740a2b97f280df75095aa9c1e" translate="yes" xml:space="preserve">
          <source>This module defines some basic input objects used by &lt;b&gt;Pod::Parser&lt;/b&gt; when reading and parsing POD text from an input source. The following objects are defined:</source>
          <target state="translated">이 모듈은 입력 소스에서 POD 텍스트를 읽고 구문 분석 할 때 &lt;b&gt;Pod :: Parser&lt;/b&gt; 가 사용하는 몇 가지 기본 입력 오브젝트를 정의합니다 . 다음과 같은 객체가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="5588b6a383faab0057a18646001f16348459eef2" translate="yes" xml:space="preserve">
          <source>This module defines three public functions, &lt;code&gt;plan(...)&lt;/code&gt; , &lt;code&gt;ok(...)&lt;/code&gt; , and &lt;code&gt;skip(...)&lt;/code&gt; . By default, all three are exported by the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Test;&lt;/code&gt; statement.</source>
          <target state="translated">이 모듈은 &lt;code&gt;plan(...)&lt;/code&gt; , &lt;code&gt;ok(...)&lt;/code&gt; 및 &lt;code&gt;skip(...)&lt;/code&gt; 세 가지 공용 함수를 정의합니다 . 기본적으로 세 가지 모두 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Test;&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 으로 내보내집니다 . 성명서.</target>
        </trans-unit>
        <trans-unit id="0d26bb4e43183e0559ebca4dee112bd3a0d0b364" translate="yes" xml:space="preserve">
          <source>This module encapsulates reading &lt;a href=&quot;../cpan&quot;&gt;Distroprefs&lt;/a&gt; and matching them against CPAN distributions.</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;../cpan&quot;&gt;Distropref&lt;/a&gt; 읽기를 캡슐화 하여 CPAN 분포와 비교합니다.</target>
        </trans-unit>
        <trans-unit id="0c9dfd5842361144dbb1663f5f104740841b03d0" translate="yes" xml:space="preserve">
          <source>This module ensures that all data written to the DBM file is null terminated. This is useful when you have a perl script that needs to interoperate with a DBM file that a C program also uses. A fairly common issue is for the C application to include the terminating null in a string when it writes to the DBM file. This filter will ensure that all data written to the DBM file can be read by the C application.</source>
          <target state="translated">이 모듈은 DBM 파일에 기록 된 모든 데이터가 널 종료되도록합니다. 이는 C 프로그램이 사용하는 DBM 파일과 상호 운용해야하는 perl 스크립트가있는 경우 유용합니다. 상당히 일반적인 문제는 C 애플리케이션이 DBM 파일에 쓸 때 문자열에 종료 널을 포함시키는 것입니다. 이 필터는 C 응용 프로그램이 DBM 파일에 기록 된 모든 데이터를 읽을 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="cd7e8d1d3170c6e8daec0f86fc59011732a6349b" translate="yes" xml:space="preserve">
          <source>This module exports convenience functions for all of the class methods provided by File::Spec.</source>
          <target state="translated">이 모듈은 File :: Spec에서 제공하는 모든 클래스 메소드에 대한 편의 기능을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="225bff521140d6082b4081701a5c9f07eb77dbdc" translate="yes" xml:space="preserve">
          <source>This module exports exactly one function, &lt;code&gt;memoize&lt;/code&gt; . The rest of the functions in this package are None of Your Business.</source>
          <target state="translated">이 모듈은 정확히 하나의 함수, &lt;code&gt;memoize&lt;/code&gt; 를 내 보냅니다 . 이 패키지의 나머지 기능은 귀하의 비즈니스에 국한되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b53f8e98717e2df0ba097b4ab532a6f74e551ea4" translate="yes" xml:space="preserve">
          <source>This module exports two functions by default, &lt;code&gt;timelocal()&lt;/code&gt; and &lt;code&gt;timegm()&lt;/code&gt; .</source>
          <target state="translated">이 모듈은 기본적으로 &lt;code&gt;timelocal()&lt;/code&gt; 및 &lt;code&gt;timegm()&lt;/code&gt; 두 함수를 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="d62e7ee6ec8e2b5b39029ab7ee6ccd36cf4dfeb9" translate="yes" xml:space="preserve">
          <source>This module extends the terse diagnostics normally emitted by both the perl compiler and the perl interpreter (from running perl with a -w switch or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; ), augmenting them with the more explicative and endearing descriptions found in &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt;. Like the other pragmata, it affects the compilation phase of your program rather than merely the execution phase.</source>
          <target state="translated">이 모듈은 perl 컴파일러와 perl 인터프리터 (일반적으로 -w 스위치를 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 하여 perl을 실행하거나 경고를 사용하여 )에서 발생하는 간결한 진단을 확장하여 &lt;a href=&quot;perldiag&quot;&gt;perldiag에&lt;/a&gt; 있는보다 설명적이고 사랑스러운 설명으로 기능을 보강합니다 . 다른 pragmata와 마찬가지로 실행 단계가 아닌 프로그램의 컴파일 단계에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="3ec683936a1587c1835f23fd06a510bf338b7e80" translate="yes" xml:space="preserve">
          <source>This module has been deprecated since perl v5.18. See &lt;a href=&quot;#DESCRIPTION&quot;&gt;DESCRIPTION&lt;/a&gt; and &lt;a href=&quot;#BUGS&quot;&gt;BUGS&lt;/a&gt;.</source>
          <target state="translated">이 모듈은 perl v5.18부터 더 이상 사용되지 않습니다. &lt;a href=&quot;#DESCRIPTION&quot;&gt;DESCRIPTION&lt;/a&gt; 및 &lt;a href=&quot;#BUGS&quot;&gt;버그를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2117e00acdbd9807a78cbd1ea4a675762026720f" translate="yes" xml:space="preserve">
          <source>This module has two interfaces, one through color() and colored() and the other through constants. It also offers the utility functions uncolor(), colorstrip(), colorvalid(), and coloralias(), which have to be explicitly imported to be used (see &lt;a href=&quot;#SYNOPSIS&quot;&gt;SYNOPSIS&lt;/a&gt;).</source>
          <target state="translated">이 모듈에는 하나의 color () 및 colored () 인터페이스와 상수를 통한 인터페이스가 있습니다. 또한 uncolor (), colorstrip (), colorvalid () 및 coloralias ()와 같은 유틸리티 함수를 제공하며,이를 사용하려면 명시 적으로 가져와야합니다 ( &lt;a href=&quot;#SYNOPSIS&quot;&gt;SYNOPSIS&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="0b510432f8750d5bbad1de7af5fced7b88ef44df" translate="yes" xml:space="preserve">
          <source>This module implements China-based Chinese charset encodings. Encodings supported are as follows.</source>
          <target state="translated">이 모듈은 중국 기반 중국어 문자셋 인코딩을 구현합니다. 지원되는 인코딩은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="18f94573bd55ebab6dfdf33a299319140ec5bdab" translate="yes" xml:space="preserve">
          <source>This module implements Japanese charset encodings. Encodings supported are as follows.</source>
          <target state="translated">이 모듈은 일본어 문자셋 인코딩을 구현합니다. 지원되는 인코딩은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="85a823a7495a5d305f8dfc87daf3a9452bf40405" translate="yes" xml:space="preserve">
          <source>This module implements Korean charset encodings. Encodings supported are as follows.</source>
          <target state="translated">이 모듈은 한국어 문자셋 인코딩을 구현합니다. 지원되는 인코딩은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1ac6b792bfff4da11b88119131c465048e55ab98" translate="yes" xml:space="preserve">
          <source>This module implements RFC 2047 Mime Header Encoding. There are 3 variant encoding names; &lt;code&gt;MIME-Header&lt;/code&gt; , &lt;code&gt;MIME-B&lt;/code&gt; and &lt;code&gt;MIME-Q&lt;/code&gt; . The difference is described below</source>
          <target state="translated">이 모듈은 RFC 2047 Mime 헤더 인코딩을 구현합니다. 세 가지 변형 인코딩 이름이 있습니다. &lt;code&gt;MIME-Header&lt;/code&gt; , &lt;code&gt;MIME-B&lt;/code&gt; 및 &lt;code&gt;MIME-Q&lt;/code&gt; . 차이점은 아래에 설명되어 있습니다</target>
        </trans-unit>
        <trans-unit id="fd2c9a90ea8e309e706421846f519bfe977d609d" translate="yes" xml:space="preserve">
          <source>This module implements UTF-7 encoding documented in RFC 2152. UTF-7, as its name suggests, is a 7-bit re-encoded version of UTF-16BE. It is designed to be MTA-safe and expected to be a standard way to exchange Unicoded mails via mails. But with the advent of UTF-8 and 8-bit compliant MTAs, UTF-7 is hardly ever used.</source>
          <target state="translated">이 모듈은 RFC 2152에 문서화 된 UTF-7 인코딩을 구현합니다. UTF-7은 이름에서 알 수 있듯이 UTF-16BE의 7 비트 재 인코딩 된 버전입니다. MTA 안전하도록 설계되었으며 메일을 통해 유니 코드 메일을 교환하는 표준 방법이 될 것으로 예상됩니다. 그러나 UTF-8 및 8 비트 호환 MTA의 출현으로 UTF-7은 거의 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6a778bf541b175d3967361a621a9111e411a3873" translate="yes" xml:space="preserve">
          <source>This module implements a PerlIO layer that works on files encoded in the quoted-printable format. It will decode from quoted-printable while reading from a handle, and it will encode as quoted-printable while writing to a handle.</source>
          <target state="translated">이 모듈은 인용 인쇄 가능한 형식으로 인코딩 된 파일에서 작동하는 PerlIO 계층을 구현합니다. 핸들에서 읽는 동안 따옴표로 묶은 인쇄 가능에서 디코딩되고 핸들에 쓰는 동안 따옴표로 묶은 인쇄 가능으로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="ed550b03d65e4b729769320dd5e86c30fc421672" translate="yes" xml:space="preserve">
          <source>This module implements a client interface to the POP3 protocol, enabling a perl5 application to talk to POP3 servers. This documentation assumes that you are familiar with the POP3 protocol described in RFC1939.</source>
          <target state="translated">이 모듈은 POP3 프로토콜에 대한 클라이언트 인터페이스를 구현하여 perl5 애플리케이션이 POP3 서버와 통신 할 수 있도록합니다. 이 문서는 사용자가 RFC1939에 설명 된 POP3 프로토콜에 익숙하다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="f3343630b02b7f19c2e9f15e0bc9d4d62bafd5e3" translate="yes" xml:space="preserve">
          <source>This module implements a client interface to the SMTP and ESMTP protocol, enabling a perl5 application to talk to SMTP servers. This documentation assumes that you are familiar with the concepts of the SMTP protocol described in RFC821.</source>
          <target state="translated">이 모듈은 SMTP 및 ESMTP 프로토콜에 대한 클라이언트 인터페이스를 구현하여 perl5 애플리케이션이 SMTP 서버와 통신 할 수 있도록합니다. 이 문서는 사용자가 RFC821에 설명 된 SMTP 프로토콜의 개념에 익숙하다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="208a0fbb6b2b9365a0b457c6e7c2a20c4ee8bdbb" translate="yes" xml:space="preserve">
          <source>This module implements all Character Encoding Schemes of Unicode that are officially documented by Unicode Consortium (except, of course, for UTF-8, which is a native format in perl).</source>
          <target state="translated">이 모듈은 공식적으로 유니 코드 컨소시엄에서 문서화 한 모든 유니 코드 문자 인코딩 체계를 구현합니다 (물론 perl의 기본 형식 인 UTF-8 제외).</target>
        </trans-unit>
        <trans-unit id="4a5fc149cac5c063339467ffcf19fbcbdd274ebc" translate="yes" xml:space="preserve">
          <source>This module implements symbol and dingbats encodings. Encodings supported are as follows.</source>
          <target state="translated">이 모듈은 심볼 및 딩뱃 인코딩을 구현합니다. 지원되는 인코딩은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="91d2629cfba9471ae750b605c30149641a050967" translate="yes" xml:space="preserve">
          <source>This module implements the Windows-specific parts of ExtUtils::CBuilder. Most of the Windows-specific stuff has to do with compiling and linking C code. Currently we support the 3 compilers perl itself supports: MSVC, BCC, and GCC.</source>
          <target state="translated">이 모듈은 ExtUtils :: CBuilder의 Windows 특정 부분을 구현합니다. 대부분의 Windows 관련 항목은 C 코드 컴파일 및 링크와 관련이 있습니다. 현재 우리는 3 개의 컴파일러 perl 자체를 지원합니다 : MSVC, BCC 및 GCC.</target>
        </trans-unit>
        <trans-unit id="f9fa4e0ad3f8d3bc6d28f8c2e962b8d03cb9cfa8" translate="yes" xml:space="preserve">
          <source>This module implements tradition Chinese charset encodings as used in Taiwan and Hong Kong. Encodings supported are as follows.</source>
          <target state="translated">이 모듈은 대만과 홍콩에서 사용되는 중국어 번체 문자셋 인코딩을 구현합니다. 지원되는 인코딩은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6d3abe1f6aae133c8268ef4a9c7e2b3f247e4b85" translate="yes" xml:space="preserve">
          <source>This module implements various EBCDIC-Based encodings. Encodings supported are as follows.</source>
          <target state="translated">이 모듈은 다양한 EBCDIC 기반 인코딩을 구현합니다. 지원되는 인코딩은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="71223016b72a87a85df3e296ab0f30c149dbcfa6" translate="yes" xml:space="preserve">
          <source>This module implements various single byte encodings. For most cases it uses \x80-\xff (upper half) to map non-ASCII characters. Encodings supported are as follows.</source>
          <target state="translated">이 모듈은 다양한 단일 바이트 인코딩을 구현합니다. 대부분의 경우 \ x80- \ xff (상반부)를 사용하여 비 ASCII 문자를 매핑합니다. 지원되는 인코딩은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cc2e021c9aa08753ca094f4f9555269ba3008c18" translate="yes" xml:space="preserve">
          <source>This module inherits from &lt;code&gt;ExtUtils::CBuilder::Base&lt;/code&gt; , so any functionality not implemented here will be implemented there. The interfaces are defined by the &lt;a href=&quot;../../cbuilder&quot;&gt;ExtUtils::CBuilder&lt;/a&gt; documentation.</source>
          <target state="translated">이 모듈은 &lt;code&gt;ExtUtils::CBuilder::Base&lt;/code&gt; 에서 상속 받으 므로 여기에 구현되지 않은 기능은 여기에서 구현됩니다. 인터페이스는 &lt;a href=&quot;../../cbuilder&quot;&gt;ExtUtils :: CBuilder&lt;/a&gt; 문서에 의해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="19da1ff10a7249eedb446c4c19eb17fbb02bae8e" translate="yes" xml:space="preserve">
          <source>This module internally uses the epoch seconds system that is provided via the perl &lt;code&gt;&lt;a href=&quot;../functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; function and supported by &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 perl &lt;code&gt;&lt;a href=&quot;../functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; 함수 를 통해 제공 되고 &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 지원 하는 에포크 초 시스템을 내부적으로 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="458e3aac1c45af194716db0ddfa546c2e44d1b98" translate="yes" xml:space="preserve">
          <source>This module is a &quot;pure virtual base class&quot;--it has nothing of its own. It's just there to inherit from one of the various DBM packages. It prefers ndbm for compatibility reasons with Perl 4, then Berkeley DB (See &lt;a href=&quot;db_file&quot;&gt;DB_File&lt;/a&gt;), GDBM, SDBM (which is always there--it comes with Perl), and finally ODBM. This way old programs that used to use NDBM via dbmopen() can still do so, but new ones can reorder @ISA:</source>
          <target state="translated">이 모듈은 &quot;순수한 가상 기본 클래스&quot;입니다. 자체 모듈이 없습니다. 다양한 DBM 패키지 중 하나에서 상속하기 만하면됩니다. Perl 4와 호환성을 위해 ndbm을 선호하고 Berkeley DB ( &lt;a href=&quot;db_file&quot;&gt;DB_File&lt;/a&gt; 참조 ), GDBM, SDBM (항상 Perl과 함께 제공됨) 및 마지막으로 ODBM을 선호합니다. 이런 식으로 dbmopen ()을 통해 NDBM을 사용했던 이전 프로그램은 여전히 ​​그렇게 할 수 있지만 새로운 프로그램은 @ISA를 재정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c04eeff8ead05e06a53857583cc861707b5c717" translate="yes" xml:space="preserve">
          <source>This module is a simple wrapper around &lt;b&gt;Locale::Maketext::Lexicon&lt;/b&gt;, designed to alleviate the need of creating</source>
          <target state="translated">이 모듈은 &lt;b&gt;Locale :: Maketext :: Lexicon&lt;/b&gt; 주위의 간단한 래퍼로 , 작성의 필요성을 완화시킵니다.</target>
        </trans-unit>
        <trans-unit id="e16f5e2a01129069277c30d3b7f3daee0fb1dd1b" translate="yes" xml:space="preserve">
          <source>This module is an implementation of Unicode Technical Standard #10 (a.k.a. UTS #10) - Unicode Collation Algorithm (a.k.a. UCA).</source>
          <target state="translated">이 모듈은 Unicode Technical Standard # 10 (일명 UTS # 10)-Unicode Collation Algorithm (일명 UCA)의 구현입니다.</target>
        </trans-unit>
        <trans-unit id="c1b7492744c579fc1d9bfb8835d90982b09e7c1d" translate="yes" xml:space="preserve">
          <source>This module is an outgrowth of the &lt;code&gt;Module::Build&lt;/code&gt; project, to which there have been many contributors. Notably, Randy W. Sims submitted lots of code to support 3 compilers on Windows and helped with various other platform-specific issues. Ilya Zakharevich has contributed fixes for OS/2; John E. Malmberg and Peter Prymmer have done likewise for VMS.</source>
          <target state="translated">이 모듈은 많은 기여자가 있는 &lt;code&gt;Module::Build&lt;/code&gt; 프로젝트 의 결과물입니다 . 특히 Randy W. Sims는 Windows에서 3 개의 컴파일러를 지원하기 위해 많은 코드를 제출했으며 다양한 플랫폼 별 문제를 해결했습니다. Ilya Zakharevich는 OS / 2의 수정 사항을 제공했습니다. John E. Malmberg와 Peter Prymmer도 마찬가지로 VMS를 수행했습니다.</target>
        </trans-unit>
        <trans-unit id="1f5ba4ee559ca9f1454b4c1a05d7f38b94f36610" translate="yes" xml:space="preserve">
          <source>This module is based on a Perl 4 library, timelocal.pl, that was included with Perl 4.036, and was most likely written by Tom Christiansen.</source>
          <target state="translated">이 모듈은 Perl 4.036에 포함되어 있으며 Tom Christiansen이 작성한 Perl 4 라이브러리 인 timelocal.pl을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="4cbc64a6620dfb67500a67bd41b8098f113352da" translate="yes" xml:space="preserve">
          <source>This module is by no means trying to be a complete testing system. It's just to get you started. Once you're off the ground its recommended you look at &lt;a href=&quot;more&quot;&gt;Test::More&lt;/a&gt;.</source>
          <target state="translated">이 모듈이 완전한 테스트 시스템이 되려고하는 것은 아닙니다. 시작하기 만하면됩니다. 일단 당신이 땅에서 벗어나면 &lt;a href=&quot;more&quot;&gt;Test :: More&lt;/a&gt; 를 보라 .</target>
        </trans-unit>
        <trans-unit id="2753244f46b0ce153d304706dfb95e861d35abaf" translate="yes" xml:space="preserve">
          <source>This module is copyright (C) Charles Bailey, Tim Bunce and David Landgren 1995-2013. All rights reserved.</source>
          <target state="translated">이 모듈은 Charles Bailey, Tim Bunce 및 David Landgren 1995-2013에 저작권이 있습니다 (C). 판권 소유.</target>
        </trans-unit>
        <trans-unit id="c3dc79528e0a53341f5f1a2385863e6d0f321326" translate="yes" xml:space="preserve">
          <source>This module is copyright (c) 2002 - 2009 Jos Boumans &amp;lt;kane@cpan.org&amp;gt;. All rights reserved.</source>
          <target state="translated">이 모듈은 (c) 2002-2009 Jos Boumans &amp;lt;kane@cpan.org&amp;gt;에 저작권이 있습니다. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="e106aa2d7581dc33a3d1c862720a197c581da1e6" translate="yes" xml:space="preserve">
          <source>This module is designed to support operations commonly performed on file specifications (usually called &quot;file names&quot;, but not to be confused with the contents of a file, or Perl's file handles), such as concatenating several directory and file names into a single path, or determining whether a path is rooted. It is based on code directly taken from MakeMaker 5.17, code written by Andreas K&amp;ouml;nig, Andy Dougherty, Charles Bailey, Ilya Zakharevich, Paul Schinder, and others.</source>
          <target state="translated">이 모듈은 여러 디렉토리 및 파일 이름을 단일 경로로 연결하는 것과 같이 파일 스펙 (일반적으로 &quot;파일 이름&quot;이라고하지만 파일의 내용 또는 Perl의 파일 핸들과 혼동되지 않도록 함)에서 일반적으로 수행되는 조작을 지원하도록 설계되었습니다. 경로가 루팅되었는지 여부를 결정합니다. 이 코드는 Andreas K&amp;ouml;nig, Andy Dougherty, Charles Bailey, Ilya Zakharevich, Paul Schinder 등이 작성한 MakeMaker 5.17에서 직접 가져온 코드를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="b88b2f05f3eb8f5317475c544c0d41c821542019" translate="yes" xml:space="preserve">
          <source>This module is designed to work with &lt;a href=&quot;encoding&quot;&gt;Encode::Encoding&lt;/a&gt;. To make the Base64 transcoder example above really work, you could write a module like this:</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;encoding&quot;&gt;Encode :: Encoding&lt;/a&gt; 과 함께 작동하도록 설계되었습니다 . 위의 Base64 트랜스 코더 예제를 실제로 작동 시키려면 다음과 같은 모듈을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3eaa300076a46b36258692823afcaf30f3da1dac" translate="yes" xml:space="preserve">
          <source>This module is experimental, and may contain bugs. Please report bugs to the address below.</source>
          <target state="translated">이 모듈은 실험용이며 버그가 포함되어있을 수 있습니다. 아래 주소로 버그를 신고하십시오.</target>
        </trans-unit>
        <trans-unit id="df5a318ad47ed1cb98fcceb8a257ad12588cd0fd" translate="yes" xml:space="preserve">
          <source>This module is free software, you may distribute it under the same terms as Perl itself.</source>
          <target state="translated">이 모듈은 자유 소프트웨어이므로 Perl과 동일한 조건으로 배포 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fdd885419be85bc33964005f90fc4cadf3fdd76" translate="yes" xml:space="preserve">
          <source>This module is free software, you may distribute it under the same terms as Perl.</source>
          <target state="translated">이 모듈은 자유 소프트웨어이며 Perl과 동일한 조건으로 배포 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="922385d4cd422695e010d41aeec2d5c5dffbe730" translate="yes" xml:space="preserve">
          <source>This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.</source>
          <target state="translated">이 모듈은 자유 소프트웨어입니다. Perl 자체와 동일한 용어로 사용, 재배포 및 / 또는 수정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8713cb7bfbc646a13e38df90a39fe040d945517a" translate="yes" xml:space="preserve">
          <source>This module is free software. You may distribute it under the same terms as Perl itself.</source>
          <target state="translated">이 모듈은 자유 소프트웨어입니다. Perl 자체와 동일한 조건으로 배포 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="870a9546afdd84e9a3a4ff38074b2ee21c55579d" translate="yes" xml:space="preserve">
          <source>This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">이 모듈은 자유 소프트웨어입니다. Perl과 동일한 용어로 재배포 및 / 또는 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0830e7b6d0dd0580741b7e45292c09ed7c6c8d7" translate="yes" xml:space="preserve">
          <source>This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself. See &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlartistic.html&quot;&gt;perlartistic&lt;/a&gt;.</source>
          <target state="translated">이 모듈은 자유 소프트웨어입니다. Perl과 동일한 용어로 재배포 및 / 또는 수정할 수 있습니다. &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlartistic.html&quot;&gt;perlartistic&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3300a405455959dd665a3badfe243e6fa30c2626" translate="yes" xml:space="preserve">
          <source>This module is free software; you can redistribute it or modify it under the same terms as Perl itself.</source>
          <target state="translated">이 모듈은 자유 소프트웨어입니다. Perl 자체와 동일한 용어로 재배포하거나 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="428130d7bad8c548e3890e11a89bef5821bc3665" translate="yes" xml:space="preserve">
          <source>This module is just a translation of the C</source>
          <target state="translated">이 모듈은 C의 번역 일뿐입니다</target>
        </trans-unit>
        <trans-unit id="53d4261ed48fcbc4558e06b2e6b719f698501a77" translate="yes" xml:space="preserve">
          <source>This module is just for testing expiration semantics. It's not a very good example of how to write an expiration module.</source>
          <target state="translated">이 모듈은 만료 시맨틱을 테스트하기위한 것입니다. 만기 모듈을 작성하는 방법에 대한 좋은 예는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f745572f29549c61507fb4f34a61c7a87abbc5ec" translate="yes" xml:space="preserve">
          <source>This module is managed in an open GitHub repository, &lt;a href=&quot;https://github.com/theory/pod-simple/&quot;&gt;https://github.com/theory/pod-simple/&lt;/a&gt;. Feel free to fork and contribute, or to clone &lt;a href=&quot;git://github.com/theory/pod-simple.git&quot;&gt;git://github.com/theory/pod-simple.git&lt;/a&gt; and send patches!</source>
          <target state="translated">이 모듈은 개방형 GitHub 리포지토리 ( &lt;a href=&quot;https://github.com/theory/pod-simple/&quot;&gt;https://github.com/theory/pod-simple/)&lt;/a&gt; 에서 관리됩니다 . 자유롭게 포크하고 기여하거나 &lt;a href=&quot;git://github.com/theory/pod-simple.git&quot;&gt;git : //github.com/theory/pod-simple.git&lt;/a&gt; 을 복제 하고 패치를 보내십시오!</target>
        </trans-unit>
        <trans-unit id="7d0ab6711ea5063095e0e85b171ef73740045783" translate="yes" xml:space="preserve">
          <source>This module is not compatible with Unix &lt;code&gt;compress&lt;/code&gt; .</source>
          <target state="translated">이 모듈은 Unix &lt;code&gt;compress&lt;/code&gt; 와 호환되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d1c6a1686a9e6172b47ee3f5d419b358b2cc40a5" translate="yes" xml:space="preserve">
          <source>This module is not intended for direct use in application code. Its sole purpose is to be sub-classed by IO::Compress modules.</source>
          <target state="translated">이 모듈은 응용 프로그램 코드에서 직접 사용하기위한 것이 아닙니다. 유일한 목적은 IO :: Compress 모듈에 의해 서브 클래 싱되는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0f3671c101f1cebdeab0ce875c68fe36c60360d8" translate="yes" xml:space="preserve">
          <source>This module is not intended for direct use in application code. Its sole purpose is to be sub-classed by IO::Uncompress modules.</source>
          <target state="translated">이 모듈은 응용 프로그램 코드에서 직접 사용하기위한 것이 아닙니다. 유일한 목적은 IO :: Uncompress 모듈로 서브 클래 싱하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7164bd2152d2e3839e89dbfa3b86eaa11bce3dbe" translate="yes" xml:space="preserve">
          <source>This module is part of the Time::Piece distribution. It allows the user to find out the number of minutes, hours, days, weeks or years in a given number of seconds. It is returned by Time::Piece when you delta two Time::Piece objects.</source>
          <target state="translated">이 모듈은 Time :: Piece 배포의 일부입니다. 사용자는 주어진 시간 (초)에서 분, 시간, 일, 주 또는 년을 찾을 수 있습니다. 두 Time :: Piece 객체를 델타하면 Time :: Piece에 의해 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="22df619b80747d338bb7c64e8fdc1d4aef53ad12" translate="yes" xml:space="preserve">
          <source>This module is part of the core Perl distribution and is also maintained for CPAN by Jonathan Stowe &amp;lt;jns@gellyfish.co.uk&amp;gt;.</source>
          <target state="translated">이 모듈은 핵심 Perl 분배의 일부이며 Jonathan Stowe &amp;lt;jns@gellyfish.co.uk&amp;gt;에 의해 CPAN에 대해서도 유지 보수됩니다.</target>
        </trans-unit>
        <trans-unit id="194bd926549ad2d7bd7a1e89514e8690d0700ec1" translate="yes" xml:space="preserve">
          <source>This module is released under the same terms as Perl itself.</source>
          <target state="translated">이 모듈은 Perl 자체와 동일한 용어로 출시됩니다.</target>
        </trans-unit>
        <trans-unit id="9e7d44a3d58cea8a100de62304c29f63b460d560" translate="yes" xml:space="preserve">
          <source>This module is still in beta. Cygwin-knowledgeable folks are invited to offer patches and suggestions.</source>
          <target state="translated">이 모듈은 아직 베타 버전입니다. Cygwin 지식이 풍부한 사람들이 패치와 제안을 제공하도록 초대되었습니다.</target>
        </trans-unit>
        <trans-unit id="f3a7ded1d62af46df9b70aea1e61bb63a4d5e250" translate="yes" xml:space="preserve">
          <source>This module is used by &lt;code&gt;h2xs&lt;/code&gt; to write the file</source>
          <target state="translated">이 모듈은 &lt;code&gt;h2xs&lt;/code&gt; 에서 파일을 쓰는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a7926bd29bba2324b3fe7c588f46c743752e1304" translate="yes" xml:space="preserve">
          <source>This module is used for running batch-conversions of a lot of HTML documents</source>
          <target state="translated">이 모듈은 많은 HTML 문서의 일괄 변환을 실행하는 데 사용됩니다</target>
        </trans-unit>
        <trans-unit id="839a2e768fddb8f7898e0f04347e52df5765427a" translate="yes" xml:space="preserve">
          <source>This module is used internally as a base class by Time::localtime And Time::gmtime functions. It creates a Time::tm struct object which is addressable just like's C's tm structure from</source>
          <target state="translated">이 모듈은 Time :: localtime 및 Time :: gmtime 함수에 의해 내부적으로 기본 클래스로 사용됩니다. C의 tm 구조와 마찬가지로 주소를 지정할 수있는 Time :: tm struct 객체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="07f553b400d2280f304688df200f5b35ef787f6a" translate="yes" xml:space="preserve">
          <source>This module is used to implement the special hashes &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%-&lt;/code&gt; , but it can be used to tie other variables as you choose.</source>
          <target state="translated">이 모듈은 특수 해시 &lt;code&gt;%+&lt;/code&gt; 및 &lt;code&gt;%-&lt;/code&gt; 를 구현하는 데 사용 되지만 원하는대로 다른 변수를 연결하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1910d98cb0d7696e9377a9fe44d03beb3d7a9af8" translate="yes" xml:space="preserve">
          <source>This module is used when interoperating with a C/C++ application that uses a C int as either the key and/or value in the DBM file.</source>
          <target state="translated">이 모듈은 C int를 DBM 파일의 키 및 / 또는 값으로 사용하는 C / C ++ 애플리케이션과 상호 운용 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d8aa8f33e315204f28ac3fdb706ab3fb362c4d36" translate="yes" xml:space="preserve">
          <source>This module is useful for people who are writing their own back end, or who are learning about the Perl internals. It's not useful to the average programmer.</source>
          <target state="translated">이 모듈은 자신의 백엔드를 작성하거나 Perl 내부에 대해 배우는 사람들에게 유용합니다. 일반 프로그래머에게는 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="422eedc66ca57180bd78963179219d9ec2d2c3fd" translate="yes" xml:space="preserve">
          <source>This module is very unusual as overloaded modules go: it does not provide any usual overloaded operators, instead it provides an implementation for &lt;a href=&quot;#nomethod&quot;&gt;nomethod&lt;/a&gt;. In this example the &lt;code&gt;nomethod&lt;/code&gt; subroutine returns an object which encapsulates operations done over the objects: &lt;code&gt;symbolic-&amp;gt;new(3)&lt;/code&gt; contains &lt;code&gt;['n', 3]&lt;/code&gt; , &lt;code&gt;2 +
symbolic-&amp;gt;new(3)&lt;/code&gt; contains &lt;code&gt;['+', 2, ['n', 3]]&lt;/code&gt; .</source>
          <target state="translated">이 모듈은 오버로드 된 모듈로 인해 매우 이례적입니다. 일반적인 오버로드 된 연산자를 제공하지 않고 대신 &lt;a href=&quot;#nomethod&quot;&gt;nomethod&lt;/a&gt; 구현을 제공합니다 . 이 예제에서 &lt;code&gt;nomethod&lt;/code&gt; 서브 루틴은 오브젝트에 대해 수행 된 조작을 캡슐화하는 오브젝트를 리턴합니다. &lt;code&gt;symbolic-&amp;gt;new(3)&lt;/code&gt; contains &lt;code&gt;['n', 3]&lt;/code&gt; , &lt;code&gt;2 + symbolic-&amp;gt;new(3)&lt;/code&gt; contains &lt;code&gt;['+', 2, ['n', 3]]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4c8914133b0b2bfc077d6c38150d307c0367148" translate="yes" xml:space="preserve">
          <source>This module looks for several environment variables, including REQUEST_METHOD, HTTP_ACCEPT_LANGUAGE, LANGUAGE, LC_ALL, LC_MESSAGES, and LANG.</source>
          <target state="translated">이 모듈은 REQUEST_METHOD, HTTP_ACCEPT_LANGUAGE, LANGUAGE, LC_ALL, LC_MESSAGES 및 LANG를 포함한 여러 환경 변수를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="0ac738d7d9941c37feb5165dcbb5c6ab9416052c" translate="yes" xml:space="preserve">
          <source>This module may change to use a different pod-to-nroff formatter class in the future, and this may change what options are supported.</source>
          <target state="translated">이 모듈은 나중에 다른 pod-to-nroff 포맷터 클래스를 사용하도록 변경 될 수 있으며 지원되는 옵션이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76f27fbed99d6c60d342c39616884795be44e886" translate="yes" xml:space="preserve">
          <source>This module may change to use a different text formatter class in the future, and this may change what options are supported.</source>
          <target state="translated">이 모듈은 나중에 다른 텍스트 포맷터 클래스를 사용하도록 변경 될 수 있으며 지원되는 옵션이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94ae7d6ead04954a6412192772bd33bb7b8d4073" translate="yes" xml:space="preserve">
          <source>This module mediates between some version that perl sees in a package and the version that is published by the CPAN indexer.</source>
          <target state="translated">이 모듈은 패키지에서 볼 수있는 일부 버전과 CPAN 색인 작성기에서 공개 한 버전 사이를 중개합니다.</target>
        </trans-unit>
        <trans-unit id="c80cea19736436ea3f987c3515d4cecb255844b4" translate="yes" xml:space="preserve">
          <source>This module needs Compress::Zlib.</source>
          <target state="translated">이 모듈에는 Compress :: Zlib가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a8a13e816f80341d5aa494b1b85b44f3bab37b43" translate="yes" xml:space="preserve">
          <source>This module needs Perl5.005 or better.</source>
          <target state="translated">이 모듈은 Perl5.005 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="2b02becbf011b5e3018f1c6556299552bd0354bc" translate="yes" xml:space="preserve">
          <source>This module needs the Encode module.</source>
          <target state="translated">이 모듈에는 Encode 모듈이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="9ccf2db8e0457ff61f46dc8eef8b595c0400ca84" translate="yes" xml:space="preserve">
          <source>This module needs to have been built with zlib 1.2.1 or better to work. A fatal error will be thrown if &lt;code&gt;Merge&lt;/code&gt; is used with an older version of zlib.</source>
          <target state="translated">이 모듈은 zlib 1.2.1 이상으로 구축되어 작동해야합니다. 이전 버전의 zlib와 함께 &lt;code&gt;Merge&lt;/code&gt; 를 사용 하면 치명적인 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="7cdcfb5298a84fa590094f08e92147e6cb58d161" translate="yes" xml:space="preserve">
          <source>This module offers a single utility function, &lt;code&gt;findsym()&lt;/code&gt; .</source>
          <target state="translated">이 모듈은 단일 유틸리티 함수 인 &lt;code&gt;findsym()&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="fd94e0e36732e7bf036abc385f751fb424ec5ec9" translate="yes" xml:space="preserve">
          <source>This module only provides a single function, parselink(), which takes the text of an L&amp;lt;&amp;gt; formatting code and parses it. It returns the anchor text for the link (if any was given), the anchor text possibly inferred from the name and section, the name or URL, the section if any, and the type of link. The type will be one of &lt;code&gt;url&lt;/code&gt; , &lt;code&gt;pod&lt;/code&gt; , or &lt;code&gt;man&lt;/code&gt; , indicating a URL, a link to a POD page, or a link to a Unix manual page.</source>
          <target state="translated">이 모듈은 단일 함수 parselink () 만 제공합니다. parselink ()는 L &amp;lt;&amp;gt; 형식 코드의 텍스트를 가져와 구문 분석합니다. 링크의 앵커 텍스트 (제공된 경우), 이름 및 섹션, 이름 또는 URL, 섹션 (있는 경우) 및 링크 유형에서 유추 된 앵커 텍스트를 리턴합니다. 유형은 &lt;code&gt;url&lt;/code&gt; , &lt;code&gt;pod&lt;/code&gt; 또는 &lt;code&gt;man&lt;/code&gt; 중 하나입니다. URL, POD 페이지 링크 또는 Unix 매뉴얼 페이지 링크를 나타내는 .</target>
        </trans-unit>
        <trans-unit id="3d4bf504a913c2345fd7fde3fd0264ab90a67f31" translate="yes" xml:space="preserve">
          <source>This module overloads two operators, stringify (&quot;&quot;) and numify (0+).</source>
          <target state="translated">이 모듈은 stringify ( &quot;&quot;) 및 numify (0+)의 두 연산자를 오버로드합니다.</target>
        </trans-unit>
        <trans-unit id="d52e08497f6544c9fedb6034ea4aa6706f4c4317" translate="yes" xml:space="preserve">
          <source>This module predefines the methods below:</source>
          <target state="translated">이 모듈은 아래 방법을 미리 정의합니다.</target>
        </trans-unit>
        <trans-unit id="af4cffa0841bdd7591fb2ce3aa6ee9b4fc1581e2" translate="yes" xml:space="preserve">
          <source>This module presumes that all packages on CPAN</source>
          <target state="translated">이 모듈은 CPAN의 모든 패키지를 가정합니다.</target>
        </trans-unit>
        <trans-unit id="50019593ee938407217545d40776fee521fc69e2" translate="yes" xml:space="preserve">
          <source>This module prints the contents of the parse tree, but without as much information as &lt;a href=&quot;debug&quot;&gt;B::Debug&lt;/a&gt;. For comparison, &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt; &quot;Hello, world.&quot;&lt;/code&gt; produced 96 lines of output from B::Debug, but only 6 from B::Terse.</source>
          <target state="translated">이 모듈은 구문 분석 트리의 내용을 인쇄하지만 &lt;a href=&quot;debug&quot;&gt;B :: Debug&lt;/a&gt; 만큼 많은 정보가 없습니다 . 비교하려면 &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt; &quot;Hello, world.&quot;&lt;/code&gt; &lt;a href=&quot;../functions/print&quot;&gt;인쇄하십시오&lt;/a&gt; .B :: Debug에서 96 줄의 출력을 생성했지만 B :: Terse에서는 6 줄만 생성했습니다.</target>
        </trans-unit>
        <trans-unit id="478ba76e6bcddb62163ef813460ff3c7881b3c2c" translate="yes" xml:space="preserve">
          <source>This module provide 3 convenience functions to calculate the digest of files. The following functions are provided:</source>
          <target state="translated">이 모듈은 파일 다이제스트를 계산하는 3 가지 편의 기능을 제공합니다. 다음과 같은 기능이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="b0083752d49808e75aaa209a550d644242bd0980" translate="yes" xml:space="preserve">
          <source>This module provide a convenient way to create directories of arbitrary depth and to delete an entire directory subtree from the filesystem.</source>
          <target state="translated">이 모듈은 임의 깊이의 디렉토리를 작성하고 파일 시스템에서 전체 디렉토리 서브 트리를 삭제하는 편리한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b6054fa3fccb1f634d2e293413bd446f27771c13" translate="yes" xml:space="preserve">
          <source>This module provides a Perl interface that allows the reading of bzip2 files/buffers.</source>
          <target state="translated">이 모듈은 bzip2 파일 / 버퍼를 읽을 수있는 Perl 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="729eaec16403ec99e135cb527b2c362360b4f51e" translate="yes" xml:space="preserve">
          <source>This module provides a Perl interface that allows the reading of files/buffers that conform to RFC 1950.</source>
          <target state="translated">이 모듈은 RFC 1950을 준수하는 파일 / 버퍼를 읽을 수있는 Perl 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="003753405c286c7fe622e166edd07fb3084e88a1" translate="yes" xml:space="preserve">
          <source>This module provides a Perl interface that allows the reading of files/buffers that conform to RFC 1951.</source>
          <target state="translated">이 모듈은 RFC 1951을 준수하는 파일 / 버퍼를 읽을 수있는 Perl 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="450a22809e6b641290e567e29533943a53385d76" translate="yes" xml:space="preserve">
          <source>This module provides a Perl interface that allows the reading of files/buffers that conform to RFC 1952.</source>
          <target state="translated">이 모듈은 RFC 1952를 준수하는 파일 / 버퍼를 읽을 수있는 Perl 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="84795f8eb8a320fda32e6f1d9e107bd19023949a" translate="yes" xml:space="preserve">
          <source>This module provides a Perl interface that allows the reading of files/buffers that have been compressed in a number of formats that use the zlib compression library.</source>
          <target state="translated">이 모듈은 zlib 압축 라이브러리를 사용하는 여러 형식으로 압축 된 파일 / 버퍼를 읽을 수있는 Perl 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8e71e73c8ba4d3b122b4773810a5bebea41be94e" translate="yes" xml:space="preserve">
          <source>This module provides a Perl interface that allows the reading of files/buffers that have been compressed with a variety of compression libraries.</source>
          <target state="translated">이 모듈은 다양한 압축 라이브러리로 압축 된 파일 / 버퍼를 읽을 수있는 Perl 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2c4e9ced7b139b449826926366ef08ab126e2617" translate="yes" xml:space="preserve">
          <source>This module provides a Perl interface that allows the reading of zlib files/buffers.</source>
          <target state="translated">이 모듈은 zlib 파일 / 버퍼를 읽을 수있는 Perl 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bb765e95103323750609fe94be953d11119327d1" translate="yes" xml:space="preserve">
          <source>This module provides a Perl interface that allows writing bzip2 compressed data to files or buffer.</source>
          <target state="translated">이 모듈은 bzip2 압축 데이터를 파일 또는 버퍼에 쓸 수있는 Perl 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f21907b6980e5b1e79e7f9b10f3d5f2a64818f33" translate="yes" xml:space="preserve">
          <source>This module provides a Perl interface that allows writing compressed data to files or buffer as defined in RFC 1950.</source>
          <target state="translated">이 모듈은 RFC 1950에 정의 된대로 파일 또는 버퍼에 압축 된 데이터를 쓸 수있는 Perl 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="da5ecc8ed3afbcb78fee4753b59d94b3fd278392" translate="yes" xml:space="preserve">
          <source>This module provides a Perl interface that allows writing compressed data to files or buffer as defined in RFC 1951.</source>
          <target state="translated">이 모듈은 RFC 1951에 정의 된대로 파일 또는 버퍼에 압축 된 데이터를 쓸 수있는 Perl 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4dad75c362e8d8f7864bd95ffad74f285ca796dd" translate="yes" xml:space="preserve">
          <source>This module provides a Perl interface that allows writing compressed data to files or buffer as defined in RFC 1952.</source>
          <target state="translated">이 모듈은 RFC 1952에 정의 된대로 파일 또는 버퍼에 압축 된 데이터를 쓸 수있는 Perl 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="776878df4a774de7ed832c7c095295fe08ea92ae" translate="yes" xml:space="preserve">
          <source>This module provides a Perl interface that allows writing zip compressed data to files or buffer.</source>
          <target state="translated">이 모듈은 zip 압축 데이터를 파일 또는 버퍼에 쓸 수있는 Perl 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="122a388521f8308fb94e1159722c14bed6d323e8" translate="yes" xml:space="preserve">
          <source>This module provides a function &lt;code&gt;I18N::LangTags::List::name( &lt;i&gt;langtag&lt;/i&gt; ) &lt;/code&gt; that takes a language tag (see &lt;a href=&quot;../langtags&quot;&gt;I18N::LangTags&lt;/a&gt;) and returns the best attempt at an English name for it, or undef if it can't make sense of the tag.</source>
          <target state="translated">이 모듈은 &lt;code&gt;I18N::LangTags::List::name( &lt;i&gt;langtag&lt;/i&gt; ) &lt;/code&gt; 기능을 제공하여 언어 태그를 가져 &lt;i&gt;오고&lt;/i&gt; ( &lt;a href=&quot;../langtags&quot;&gt;I18N :: LangTags&lt;/a&gt; 참조 ) 영어 이름으로 최선의 시도를 반환하거나,이를 수행 할 수없는 경우 undef 태그 감각.</target>
        </trans-unit>
        <trans-unit id="96823924a180df110252f785d7a14a45c7a178c6" translate="yes" xml:space="preserve">
          <source>This module provides a variety of constants, structure manipulators and other functions related to socket-based networking. The values and functions provided are useful when used in conjunction with Perl core functions such as socket(), setsockopt() and bind(). It also provides several other support functions, mostly for dealing with conversions of network addresses between human-readable and native binary forms, and for hostname resolver operations.</source>
          <target state="translated">이 모듈은 다양한 상수, 구조 조작기 및 소켓 기반 네트워킹과 관련된 기타 기능을 제공합니다. 제공된 값과 함수는 socket (), setsockopt () 및 bind ()와 같은 Perl 핵심 함수와 함께 사용될 때 유용합니다. 또한 사람이 읽을 수있는 이진 형식과 원시 이진 형식 간의 네트워크 주소 변환 및 호스트 이름 확인자 작업을 처리하기위한 여러 가지 다른 지원 기능도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c14c6338e762c52ff6d582916956b99716820151" translate="yes" xml:space="preserve">
          <source>This module provides aliases for the built-in variables whose names no one seems to like to read. Variables with side-effects which get triggered just by accessing them (like $0) will still be affected.</source>
          <target state="translated">이 모듈은 아무도 이름을 읽지 않는 내장 변수에 대한 별명을 제공합니다. 부작용이있는 변수 (예 : $ 0)에 액세스하여 트리거되는 변수는 여전히 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="db82fd21a4c838f2cb867e238f620528a9b4e06a" translate="yes" xml:space="preserve">
          <source>This module provides an interface that allows filters to be applied to tied Hashes associated with DBM files. It builds on the DBM Filter hooks that are present in all the *DB*_File modules included with the standard Perl source distribution from version 5.6.1 onwards. In addition to the *DB*_File modules distributed with Perl, the BerkeleyDB module, available on CPAN, supports the DBM Filter hooks. See &lt;a href=&quot;perldbmfilter&quot;&gt;perldbmfilter&lt;/a&gt; for more details on the DBM Filter hooks.</source>
          <target state="translated">이 모듈은 DBM 파일과 연관된 연결된 해시에 필터를 적용 할 수있는 인터페이스를 제공합니다. 버전 5.6.1부터 표준 Perl 소스 분배에 포함 된 모든 * DB * _File 모듈에있는 DBM 필터 후크를 기반으로합니다. Perl과 함께 분배 된 * DB * _File 모듈 외에도 CPAN에서 사용 가능한 BerkeleyDB 모듈은 DBM 필터 후크를 지원합니다. DBM 필터 후크에 대한 자세한 내용 은 &lt;a href=&quot;perldbmfilter&quot;&gt;perldbmfilter&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d5d483b4b377e197aedecfe9fa15f04f3c6c2c95" translate="yes" xml:space="preserve">
          <source>This module provides functions for determining the pathname of the current working directory. It is recommended that getcwd (or another *cwd() function) be used in</source>
          <target state="translated">이 모듈은 현재 작업 디렉토리의 경로 이름을 결정하는 기능을 제공합니다. getcwd (또는 다른 * cwd () 함수)를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="37033effa06ce25f227ce23dc6a9e45e7efa61d9" translate="yes" xml:space="preserve">
          <source>This module provides functions that are the inverse of built-in perl functions &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt;. They accept a date as a six-element array, and return the corresponding &lt;code&gt;&lt;a href=&quot;../functions/time&quot;&gt;time(2)&lt;/a&gt;&lt;/code&gt; value in seconds since the system epoch (Midnight, January 1, 1970 GMT on Unix, for example). This value can be positive or negative, though POSIX only requires support for positive values, so dates before the system's epoch may not work on all operating systems.</source>
          <target state="translated">이 모듈은 내장 펄 함수 &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; 의 역 함수를 제공합니다 . 그것들은 날짜를 6 요소 배열로 받아들이고 , 시스템 시대 (예 : Unix에서 1970 년 1 월 1 일 자정)부터 초 단위로 해당 &lt;code&gt;&lt;a href=&quot;../functions/time&quot;&gt;time(2)&lt;/a&gt;&lt;/code&gt; 값을 초 단위로 반환합니다 . 이 값은 양수 또는 음수 일 수 있지만 POSIX는 양수 값만 지원하면되므로 시스템 시대 이전 날짜가 모든 운영 체제에서 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1ece64b49e28f99121f72eab284aec43cb55951" translate="yes" xml:space="preserve">
          <source>This module provides functions to encode and decode strings into and from the base64 encoding specified in RFC 2045 -</source>
          <target state="translated">이 모듈은 RFC 2045에 지정된 base64 인코딩으로 문자열을 인코딩 및 디코딩하는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="990d143d4bc42dc7eed0bcd6394bda54ff57474f" translate="yes" xml:space="preserve">
          <source>This module provides functions to encode and decode strings into and from the quoted-printable encoding specified in RFC 2045 -</source>
          <target state="translated">이 모듈은 RFC 2045에 지정된 인용 인쇄 가능한 인코딩으로 문자열을 인코딩 및 디코딩하는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0c4de2f96f0939e0587055f3524c8f314354960c" translate="yes" xml:space="preserve">
          <source>This module provides methods for array-tying classes. See &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; for a list of the functions required in order to tie an array to a package. The basic &lt;b&gt;Tie::Array&lt;/b&gt; package provides stub &lt;code&gt;DESTROY&lt;/code&gt; , and &lt;code&gt;EXTEND&lt;/code&gt; methods that do nothing, stub &lt;code&gt;DELETE&lt;/code&gt; and &lt;code&gt;EXISTS&lt;/code&gt; methods that croak() if the delete() or exists() builtins are ever called on the tied array, and implementations of &lt;code&gt;PUSH&lt;/code&gt; , &lt;code&gt;POP&lt;/code&gt; , &lt;code&gt;SHIFT&lt;/code&gt; , &lt;code&gt;UNSHIFT&lt;/code&gt; , &lt;code&gt;SPLICE&lt;/code&gt; and &lt;code&gt;CLEAR&lt;/code&gt; in terms of basic &lt;code&gt;FETCH&lt;/code&gt; , &lt;code&gt;STORE&lt;/code&gt; , &lt;code&gt;FETCHSIZE&lt;/code&gt; , &lt;code&gt;STORESIZE&lt;/code&gt; .</source>
          <target state="translated">이 모듈은 배열 묶기 클래스를위한 메소드를 제공합니다. 배열을 패키지에 연결하는 데 필요한 함수 목록은 &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; 를 참조하십시오 . 기본 &lt;b&gt;Tie :: Array&lt;/b&gt; 패키지는 스텁 &lt;code&gt;DESTROY&lt;/code&gt; 및 아무것도 수행하지 않는 &lt;code&gt;EXTEND&lt;/code&gt; 메소드 , delete () 또는 exist () 내장이 연결 배열에서 호출 된 경우 croak ()하는 스텁 &lt;code&gt;DELETE&lt;/code&gt; 및 &lt;code&gt;EXISTS&lt;/code&gt; 메소드 및 &lt;code&gt;PUSH&lt;/code&gt; 구현을 제공합니다 . 기본 &lt;code&gt;FETCH&lt;/code&gt; , &lt;code&gt;STORE&lt;/code&gt; , &lt;code&gt;FETCHSIZE&lt;/code&gt; 의 &lt;code&gt;POP&lt;/code&gt; , &lt;code&gt;SHIFT&lt;/code&gt; , &lt;code&gt;UNSHIFT&lt;/code&gt; , &lt;code&gt;SPLICE&lt;/code&gt; 및 &lt;code&gt;CLEAR&lt;/code&gt; , &lt;code&gt;STORESIZE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a02a6b6db2368ef791da2effa9e60fac9461270d" translate="yes" xml:space="preserve">
          <source>This module provides some skeletal methods for handle-tying classes. See &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; for a list of the functions required in tying a handle to a package. The basic &lt;b&gt;Tie::Handle&lt;/b&gt; package provides a &lt;code&gt;new&lt;/code&gt; method, as well as methods &lt;code&gt;TIEHANDLE&lt;/code&gt; , &lt;code&gt;PRINT&lt;/code&gt; , &lt;code&gt;PRINTF&lt;/code&gt; and &lt;code&gt;GETC&lt;/code&gt; .</source>
          <target state="translated">이 모듈은 핸들 타이 클래스를위한 일부 스켈 레탈 메소드를 제공합니다. 핸들을 패키지에 묶는 데 필요한 기능 목록은 &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; 를 참조하십시오 . 기본 &lt;b&gt;Tie :: Handle&lt;/b&gt; 패키지는 &lt;code&gt;TIEHANDLE&lt;/code&gt; , &lt;code&gt;PRINT&lt;/code&gt; , &lt;code&gt;PRINTF&lt;/code&gt; 및 &lt;code&gt;GETC&lt;/code&gt; 메소드뿐만 아니라 &lt;code&gt;new&lt;/code&gt; 메소드를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="9e1739e1ebdefff1631d8440f9ca833c6b68c52a" translate="yes" xml:space="preserve">
          <source>This module provides some skeletal methods for hash-tying classes. See &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; for a list of the functions required in order to tie a hash to a package. The basic &lt;b&gt;Tie::Hash&lt;/b&gt; package provides a &lt;code&gt;new&lt;/code&gt; method, as well as methods &lt;code&gt;TIEHASH&lt;/code&gt; , &lt;code&gt;EXISTS&lt;/code&gt; and &lt;code&gt;CLEAR&lt;/code&gt; . The &lt;b&gt;Tie::StdHash&lt;/b&gt; and &lt;b&gt;Tie::ExtraHash&lt;/b&gt; packages provide most methods for hashes described in &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; (the exceptions are &lt;code&gt;UNTIE&lt;/code&gt; and &lt;code&gt;DESTROY&lt;/code&gt; ). They cause tied hashes to behave exactly like standard hashes, and allow for selective overwriting of methods. &lt;b&gt;Tie::Hash&lt;/b&gt; grandfathers the &lt;code&gt;new&lt;/code&gt; method: it is used if &lt;code&gt;TIEHASH&lt;/code&gt; is not defined in the case a class forgets to include a &lt;code&gt;TIEHASH&lt;/code&gt; method.</source>
          <target state="translated">이 모듈은 해시 타이 잉 클래스를위한 일부 스켈 레탈 메소드를 제공합니다. 해시를 패키지에 연결하는 데 필요한 함수 목록은 &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; 를 참조하십시오 . 기본 &lt;b&gt;Tie :: Hash&lt;/b&gt; 패키지는 &lt;code&gt;TIEHASH&lt;/code&gt; , &lt;code&gt;EXISTS&lt;/code&gt; 및 &lt;code&gt;CLEAR&lt;/code&gt; 메소드뿐만 아니라 &lt;code&gt;new&lt;/code&gt; 메소드를 제공합니다 . &lt;b&gt;타이 :: StdHash&lt;/b&gt; 과 &lt;b&gt;타이 :: ExtraHash&lt;/b&gt; 패키지에 설명 된 해시에 가장 방법을 제공 &lt;a href=&quot;../perltie&quot;&gt;perltie를&lt;/a&gt; (예외가 &lt;code&gt;UNTIE&lt;/code&gt; 과 &lt;code&gt;DESTROY&lt;/code&gt; ). 묶인 해시가 표준 해시와 똑같이 동작하게하고, 메소드를 선택적으로 덮어 쓸 수 있습니다. &lt;b&gt;넥타이 :: 해시&lt;/b&gt; 할아버지&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt; &lt;code&gt;new&lt;/code&gt; 메소드 : 클래스가 &lt;code&gt;TIEHASH&lt;/code&gt; 메소드 포함을 잊어 버린 경우 &lt;code&gt;TIEHASH&lt;/code&gt; 가 정의되지 않은 경우에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4010b9458f00ef557ee377f021a5154f08e74c91" translate="yes" xml:space="preserve">
          <source>This module provides some skeletal methods for scalar-tying classes. See &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; for a list of the functions required in tying a scalar to a package. The basic &lt;b&gt;Tie::Scalar&lt;/b&gt; package provides a &lt;code&gt;new&lt;/code&gt; method, as well as methods &lt;code&gt;TIESCALAR&lt;/code&gt; , &lt;code&gt;FETCH&lt;/code&gt; and &lt;code&gt;STORE&lt;/code&gt; . The &lt;b&gt;Tie::StdScalar&lt;/b&gt; package provides all the methods specified in &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;. It inherits from &lt;b&gt;Tie::Scalar&lt;/b&gt; and causes scalars tied to it to behave exactly like the built-in scalars, allowing for selective overloading of methods. The &lt;code&gt;new&lt;/code&gt; method is provided as a means of grandfathering, for classes that forget to provide their own &lt;code&gt;TIESCALAR&lt;/code&gt; method.</source>
          <target state="translated">이 모듈은 스칼라 타이 링 클래스를위한 일부 스켈 레탈 메소드를 제공합니다. 스칼라를 패키지에 묶는 데 필요한 함수 목록은 &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; 를 참조하십시오 . 기본 &lt;b&gt;Tie :: Scalar&lt;/b&gt; 패키지는 &lt;code&gt;new&lt;/code&gt; 메소드 와 &lt;code&gt;TIESCALAR&lt;/code&gt; , &lt;code&gt;FETCH&lt;/code&gt; 및 &lt;code&gt;STORE&lt;/code&gt; 메소드를 제공합니다 . &lt;b&gt;타이 :: StdScalar의&lt;/b&gt; 패키지에 지정된 모든 방법을 제공 &lt;a href=&quot;../perltie&quot;&gt;perltie을&lt;/a&gt; . &lt;b&gt;Tie :: Scalar&lt;/b&gt; 에서 상속되며 연결된 스칼라가 내장 스칼라와 똑같이 동작하도록하여 선택적으로 메서드를 오버로드 할 수 있습니다. &lt;code&gt;new&lt;/code&gt; 방법은 자신의를 제공하는 것을 잊지 클래스, 기득권의 수단으로 제공됩니다 &lt;code&gt;TIESCALAR&lt;/code&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="45a6ced9686dd2822231048fa2c17a6218884f07" translate="yes" xml:space="preserve">
          <source>This module provides the ability to use references as hash keys if you first &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; the hash variable to this module. Normally, only the keys of the tied hash itself are preserved as references; to use references as keys in hashes-of-hashes, use Tie::RefHash::Nestable, included as part of Tie::RefHash.</source>
          <target state="translated">이 모듈은 먼저 해시 변수를이 모듈에 &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 한 경우 참조를 해시 키로 사용하는 기능을 제공합니다 . 일반적으로 연결된 해시 자체의 키만 참조로 유지됩니다. 해시 해시에서 키로 참조를 사용하려면 Tie :: RefHash :: Nestable을 사용하고 Tie :: RefHash의 일부로 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="ebae6f4a623ce67e5227c5968ced52d6ec8a379b" translate="yes" xml:space="preserve">
          <source>This module provides things that are useful in decoding Pod E&amp;lt;...&amp;gt; sequences. Presumably, it should be used only by Pod parsers and/or formatters.</source>
          <target state="translated">이 모듈은 Pod E &amp;lt;...&amp;gt; 시퀀스를 디코딩하는 데 유용한 기능을 제공합니다. 아마도 포드 파서 및 / 또는 포맷터 만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="0b9bdfe8079862de56a9be28719c20253e80c566" translate="yes" xml:space="preserve">
          <source>This module provides thread-safe FIFO queues that can be accessed safely by any number of threads.</source>
          <target state="translated">이 모듈은 여러 스레드가 안전하게 액세스 할 수있는 스레드 안전 FIFO 대기열을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c893e4865fad5c4ebef15f59be14ed58305bf748" translate="yes" xml:space="preserve">
          <source>This module provides you with objects that will collate according to your national character set, provided that the POSIX setlocale() function is supported on your system.</source>
          <target state="translated">이 모듈은 POSIX setlocale () 함수가 시스템에서 지원되는 경우 자국 문자 세트에 따라 조합 할 오브젝트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3c80ba9c5ba8104333b035c434045b2d217f883f" translate="yes" xml:space="preserve">
          <source>This module provides you with the framework to write</source>
          <target state="translated">이 모듈은 작성할 프레임 워크를 제공합니다</target>
        </trans-unit>
        <trans-unit id="a42cca3ae2e3ec2aed33868679dacb4f08255f28" translate="yes" xml:space="preserve">
          <source>This module replaces the standard &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; functions with implementations that return objects. It does so in a backwards compatible manner, so that using localtime/gmtime in the way documented in perlfunc will still return what you expect.</source>
          <target state="translated">이 모듈은 표준 &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; 함수를 객체를 반환하는 구현으로 대체 합니다. 이전 버전과 호환되는 방식으로 수행되므로 perlfunc에 설명 된 방식으로 localtime / gmtime을 사용하면 여전히 원하는 결과가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a5bdc953dcd00c8d1fe5956d84a4a3e6df9745fe" translate="yes" xml:space="preserve">
          <source>This module should implement a method named &lt;code&gt;new&lt;/code&gt; that returns an object with two methods: &lt;code&gt;IN&lt;/code&gt; and &lt;code&gt;OUT&lt;/code&gt; . These should return filehandles to use for debugging input and output correspondingly. The &lt;code&gt;new&lt;/code&gt; method should inspect an argument containing the value of &lt;code&gt;$ENV{PERLDB_NOTTY}&lt;/code&gt; at startup, or &lt;code&gt;&quot;$ENV{HOME}/.perldbtty$$&quot;&lt;/code&gt; otherwise. This file is not inspected for proper ownership, so security hazards are theoretically possible.</source>
          <target state="translated">이 모듈은 &lt;code&gt;IN&lt;/code&gt; 과 &lt;code&gt;OUT&lt;/code&gt; 의 두 가지 방법으로 객체를 반환하는 &lt;code&gt;new&lt;/code&gt; 라는 메서드를 구현해야합니다 . 입력 및 출력 디버깅에 사용할 파일 핸들을 반환해야합니다. &lt;code&gt;new&lt;/code&gt; 방법은의 값을 포함하는 인수 검사해야 &lt;code&gt;$ENV{PERLDB_NOTTY}&lt;/code&gt; 시작할 때, 또는 &lt;code&gt;&quot;$ENV{HOME}/.perldbtty$$&quot;&lt;/code&gt; 그렇지. 이 파일은 적절한 소유권을 검사하지 않았으므로 이론적으로 보안 위험이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a41ba09a40a54e49a9ee3baae88659ee7ff44a3" translate="yes" xml:space="preserve">
          <source>This module simplifies the task of writing test files for Perl modules, such that their output is in the format that &lt;a href=&quot;test/harness&quot;&gt;Test::Harness&lt;/a&gt; expects to see.</source>
          <target state="translated">이 모듈은 Perl 모듈에 대한 테스트 파일 작성 작업을 단순화하여 출력이 &lt;a href=&quot;test/harness&quot;&gt;Test :: Harness가&lt;/a&gt; 예상 하는 형식으로되어 있도록합니다 .</target>
        </trans-unit>
        <trans-unit id="11c0f42159d2cd738d87f4668e591361666ef5d1" translate="yes" xml:space="preserve">
          <source>This module supplies line breaking conformant with &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr14&quot;&gt;UAX#14 Unicode Line Breaking Algorithm&lt;/a&gt;.</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr14&quot;&gt;UAX # 14 Unicode Line Breaking Algorithm&lt;/a&gt; 을 준수하는 줄 바꿈을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="7362dd1991fb64d8e60d1766b453419474c1d7a8" translate="yes" xml:space="preserve">
          <source>This module supports dual-valued variables created using &lt;code&gt;dualvar()&lt;/code&gt; from &lt;a href=&quot;../scalar/util&quot;&gt;Scalar::Util&lt;/a&gt;. However, while &lt;code&gt;$!&lt;/code&gt; acts like a dualvar, it is implemented as a tied SV. To propagate its value, use the follow construct, if needed:</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;../scalar/util&quot;&gt;Scalar :: Util의 &lt;/a&gt; &lt;code&gt;dualvar()&lt;/code&gt; 을 사용하여 생성 된 이중 값 변수를 지원합니다 . 그러나 &lt;code&gt;$!&lt;/code&gt; 듀얼 바처럼 작동하며, 묶인 SV로 구현됩니다. 값을 전파하려면 필요한 경우 다음 구문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4a9a2cc7b64dab0e46b52256bb4b3682e797fe2a" translate="yes" xml:space="preserve">
          <source>This module supports the sharing of the following data types only: scalars and scalar refs, arrays and array refs, and hashes and hash refs.</source>
          <target state="translated">이 모듈은 스칼라 및 스칼라 참조, 배열 및 배열 참조, 해시 및 해시 참조와 같은 데이터 유형의 공유 만 지원합니다.</target>
        </trans-unit>
        <trans-unit id="a0c98feb7e76c5e1cd4d46ac2f59afc0263d11ba" translate="yes" xml:space="preserve">
          <source>This module takes the existing &lt;code&gt;File::Glob&lt;/code&gt; module as a starting point and extends it to allow new filenames to be derived from the files matched by &lt;code&gt;File::Glob&lt;/code&gt; .</source>
          <target state="translated">이 모듈은 기존 &lt;code&gt;File::Glob&lt;/code&gt; 모듈을 시작점으로 사용하여 &lt;code&gt;File::Glob&lt;/code&gt; 과 일치하는 파일 에서 새 파일 이름을 파생 할 수 있도록 확장합니다 .</target>
        </trans-unit>
        <trans-unit id="a954cd9e0b1a91ff11e964474367fdd384bdca9c" translate="yes" xml:space="preserve">
          <source>This module tells its users that functions in the FOOBAR package are to be autoloaded from after the &lt;code&gt;__DATA__&lt;/code&gt; token. See also &lt;a href=&quot;perlsub#Autoloading&quot;&gt;Autoloading in perlsub&lt;/a&gt;.</source>
          <target state="translated">이 모듈은 사용자에게 FOOBAR 패키지의 기능이 &lt;code&gt;__DATA__&lt;/code&gt; 토큰 이후에 자동로드되도록 알려줍니다 . &lt;a href=&quot;perlsub#Autoloading&quot;&gt;perlsub 자동로드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="939a336b2bb3143f369fbb6ba3a4974db4ff7afa" translate="yes" xml:space="preserve">
          <source>This module uses POSIX::setlocale(). The basic collation conversion is done by strxfrm() which terminates at NUL characters being a decent C routine. collate_xfrm() handles embedded NUL characters gracefully.</source>
          <target state="translated">이 모듈은 POSIX :: setlocale ()을 사용합니다. 기본 데이터 정렬 변환은 적절한 C 루틴 인 NUL 문자에서 끝나는 strxfrm ()에 의해 수행됩니다. collate_xfrm ()은 포함 된 NUL 문자를 정상적으로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="3d7e780fb3434a21970906d8c1e16da4e1e4c306" translate="yes" xml:space="preserve">
          <source>This module uses Term::Cap to retrieve the formatting escape sequences for the current terminal, and falls back on the ECMA-48 (the same in this regard as ANSI X3.64 and ISO 6429, the escape codes also used by DEC VT100 terminals) if the bold, underline, and reset codes aren't set in the termcap information.</source>
          <target state="translated">이 모듈은 Term :: Cap을 사용하여 현재 터미널에 대한 형식화 이스케이프 시퀀스를 검색하고 ECMA-48 (이는 ANSI X3.64 및 ISO 6429와 동일), DEC VT100 터미널에서도 이스케이프 코드를 사용합니다. ) 굵게, 밑줄 및 재설정 코드가 termcap 정보에 설정되어 있지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="058e434497d0f41de20212a7e71136f58de19c26" translate="yes" xml:space="preserve">
          <source>This module uses the Encode module.</source>
          <target state="translated">이 모듈은 Encode 모듈을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f4b71953fa4633537c604ac518e043ed458e0579" translate="yes" xml:space="preserve">
          <source>This module was conceived while talking with Tony Bowden in his kitchen one night about the problems I was having writing some really complicated feature into the new Testing module. He observed that the main problem is not dealing with these edge cases but that people hate to write tests &lt;b&gt;at all&lt;/b&gt;. What was needed was a dead simple module that took all the hard work out of testing and was really, really easy to learn. Paul Johnson simultaneously had this idea (unfortunately, he wasn't in Tony's kitchen). This is it.</source>
          <target state="translated">이 모듈은 어느 날 밤 그의 부엌에서 Tony Bowden과 새로운 테스팅 모듈에 정말 복잡한 기능을 쓰는 데 있었던 문제에 대해 이야기하면서 생각되었습니다. 그는 주요한 문제는 이러한 엣지 사례를 다루지 않고 사람들이 &lt;b&gt;전혀&lt;/b&gt; 테스트를 작성하는 것을 싫어한다는 것을 관찰했다 . 필요한 것은 테스트에서 모든 노력을 빼앗아 실제로 배우기 쉬운 죽은 간단한 모듈이었습니다. Paul Johnson은 동시에이 아이디어를 가지고있었습니다 (불행히도 그는 Tony의 부엌에 없었습니다). 이거 야.</target>
        </trans-unit>
        <trans-unit id="44e053a287d50cc7ccc07846fa0cd204c00c77bf" translate="yes" xml:space="preserve">
          <source>This module was forked from &lt;a href=&quot;base&quot;&gt;base&lt;/a&gt; to remove the cruft that had accumulated in it.</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;base&quot;&gt;베이스&lt;/a&gt; 에 포크로 쌓여 있던 크래프트를 제거했습니다.</target>
        </trans-unit>
        <trans-unit id="415f859ceb0027d691de683de60a6caa41bf897e" translate="yes" xml:space="preserve">
          <source>This module was introduced with Perl 5.004_04.</source>
          <target state="translated">이 모듈은 Perl 5.004_04에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="d78d05cb96bc7dd60c1272000024e5786c3b344f" translate="yes" xml:space="preserve">
          <source>This module was originally maintained in Perl core by the Perl 5 Porters.</source>
          <target state="translated">이 모듈은 원래 Perl 5 Porters에 의해 Perl 코어에서 유지 보수되었습니다.</target>
        </trans-unit>
        <trans-unit id="d496390246382aaea7191d7bd504a81ceae75b9b" translate="yes" xml:space="preserve">
          <source>This module was written by Paul Marquess,</source>
          <target state="translated">이 모듈은 Paul Marquess가 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="db6bc597ca48fae1b90746fab4916cd0188777f9" translate="yes" xml:space="preserve">
          <source>This module will arrange for the following methods to be available via the object returned from the &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call.</source>
          <target state="translated">이 모듈은 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 호출 에서 반환 된 객체를 통해 다음 메소드를 사용할 수 있도록 정렬합니다 .</target>
        </trans-unit>
        <trans-unit id="2764651445501a5ce090459b163069724d513467" translate="yes" xml:space="preserve">
          <source>This module will ensure that all data written to the DBM will be encoded in UTF-8.</source>
          <target state="translated">이 모듈은 DBM에 기록 된 모든 데이터가 UTF-8로 인코딩되도록합니다.</target>
        </trans-unit>
        <trans-unit id="d4e571c7af10e51826ae47ab8231a6af4b7edd1a" translate="yes" xml:space="preserve">
          <source>This module will have no effect unless Term::ANSIColor is installed.</source>
          <target state="translated">Term :: ANSIColor를 설치하지 않으면이 모듈이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bc002eb3536b764cc0a1a4a051dbfbb6d0617a7a" translate="yes" xml:space="preserve">
          <source>This module's default exports override the core getgrent(), getgruid(), and getgrnam() functions, replacing them with versions that return &quot;User::grent&quot; objects. This object has methods that return the similarly named structure field name from the C's passwd structure from</source>
          <target state="translated">이 모듈의 기본 내보내기는 핵심 getgrent (), getgruid () 및 getgrnam () 함수를 재정 의하여 &quot;User :: grent&quot;객체를 반환하는 버전으로 대체합니다. 이 객체에는 C의 암호 구조에서 비슷한 이름의 구조 필드 이름을 반환하는 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1581c51cdf9361d52e5059029b51bf081eb34a2a" translate="yes" xml:space="preserve">
          <source>This module's default exports override the core gethostbyname() and gethostbyaddr() functions, replacing them with versions that return &quot;Net::hostent&quot; objects. This object has methods that return the similarly named structure field name from the C's hostent structure from</source>
          <target state="translated">이 모듈의 기본 내보내기는 핵심 gethostbyname () 및 gethostbyaddr () 함수를 재정 의하여 &quot;Net :: hostent&quot;객체를 반환하는 버전으로 대체합니다. 이 객체에는 C의 호스트 구조에서 비슷한 이름의 구조 필드 이름을 반환하는 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1cf48308305a0353920dde6f36f9628e64db01d0" translate="yes" xml:space="preserve">
          <source>This module's default exports override the core getnetbyname() and getnetbyaddr() functions, replacing them with versions that return &quot;Net::netent&quot; objects. This object has methods that return the similarly named structure field name from the C's netent structure from</source>
          <target state="translated">이 모듈의 기본 내보내기는 핵심 getnetbyname () 및 getnetbyaddr () 함수를 재정 의하여 &quot;Net :: netent&quot;객체를 반환하는 버전으로 대체합니다. 이 객체에는 C의 netent 구조체에서 비슷한 이름의 구조체 필드 이름을 반환하는 메서드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="63eeed3630a3c131f9be311caba9fa2bc27d9b47" translate="yes" xml:space="preserve">
          <source>This module's default exports override the core getprotoent(), getprotobyname(), and getnetbyport() functions, replacing them with versions that return &quot;Net::protoent&quot; objects. They take default second arguments of &quot;tcp&quot;. This object has methods that return the similarly named structure field name from the C's protoent structure from</source>
          <target state="translated">이 모듈의 기본 내보내기는 핵심 getprotoent (), getprotobyname () 및 getnetbyport () 함수를 재정 의하여 &quot;Net :: protoent&quot;객체를 반환하는 버전으로 대체합니다. &quot;tcp&quot;의 기본 두 번째 인수를 사용합니다. 이 객체에는 C의 protoent 구조에서 비슷한 이름의 구조 필드 이름을 반환하는 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4107e545f5b1cf8c8a8164c3254d8e830266adf1" translate="yes" xml:space="preserve">
          <source>This module's default exports override the core getpwent(), getpwuid(), and getpwnam() functions, replacing them with versions that return &lt;code&gt;User::pwent&lt;/code&gt; objects. This object has methods that return the similarly named structure field name from the C's passwd structure from</source>
          <target state="translated">이 모듈의 기본 내보내기는 핵심 getpwent (), getpwuid () 및 getpwnam () 함수를 &lt;code&gt;User::pwent&lt;/code&gt; 객체 를 반환하는 버전으로 대체합니다 . 이 객체에는 C의 암호 구조에서 비슷한 이름의 구조 필드 이름을 반환하는 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="10fb02d2375c44b6670d64106c1e02dfe50c1c6b" translate="yes" xml:space="preserve">
          <source>This module's default exports override the core getservent(), getservbyname(), and getnetbyport() functions, replacing them with versions that return &quot;Net::servent&quot; objects. They take default second arguments of &quot;tcp&quot;. This object has methods that return the similarly named structure field name from the C's servent structure from</source>
          <target state="translated">이 모듈의 기본 내보내기는 핵심 getservent (), getservbyname () 및 getnetbyport () 함수를 재정 의하여 &quot;Net :: servent&quot;객체를 반환하는 버전으로 대체합니다. &quot;tcp&quot;의 기본 두 번째 인수를 사용합니다. 이 객체에는 C의 서브 스트레이트 구조에서 비슷한 이름의 구조 필드 이름을 리턴하는 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7599d7934dafe0542e5b1a0c799f665df33f32e3" translate="yes" xml:space="preserve">
          <source>This module's default exports override the core gmtime() function, replacing it with a version that returns &quot;Time::tm&quot; objects. This object has methods that return the similarly named structure field name from the C's tm structure from</source>
          <target state="translated">이 모듈의 기본 내보내기는 핵심 gmtime () 함수를 재정 의하여 &quot;Time :: tm&quot;객체를 반환하는 버전으로 대체합니다. 이 객체에는 C의 tm 구조에서 비슷한 이름의 구조 필드 이름을 반환하는 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c7368710f29f58e692e516e823ad1d056f89a07" translate="yes" xml:space="preserve">
          <source>This module's default exports override the core localtime() function, replacing it with a version that returns &quot;Time::tm&quot; objects. This object has methods that return the similarly named structure field name from the C's tm structure from</source>
          <target state="translated">이 모듈의 기본 내보내기는 핵심 localtime () 함수를 재정 의하여 &quot;Time :: tm&quot;객체를 반환하는 버전으로 대체합니다. 이 객체에는 C의 tm 구조에서 비슷한 이름의 구조 필드 이름을 반환하는 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d73f3c14e45154d8cf626f7be1ef9892237475eb" translate="yes" xml:space="preserve">
          <source>This module's default exports override the core stat() and lstat() functions, replacing them with versions that return &quot;File::stat&quot; objects. This object has methods that return the similarly named structure field name from the stat(2) function; namely, dev, ino, mode, nlink, uid, gid, rdev, size, atime, mtime, ctime, blksize, and blocks.</source>
          <target state="translated">이 모듈의 기본 내보내기는 핵심 stat () 및 lstat () 함수를 재정 의하여 &quot;File :: stat&quot;객체를 반환하는 버전으로 대체합니다. 이 객체에는 stat (2) 함수에서 비슷한 이름의 구조 필드 이름을 반환하는 메서드가 있습니다. 즉, dev, ino, mode, nlink, uid, gid, rdev, size, atime, mtime, ctime, blksize 및 blocks입니다.</target>
        </trans-unit>
        <trans-unit id="cd05da270956b31cc43582962e51390407dca252" translate="yes" xml:space="preserve">
          <source>This module, when inherited by a package, allows that package's class to define attribute handler subroutines for specific attributes. Variables and subroutines subsequently defined in that package, or in packages derived from that package may be given attributes with the same names as the attribute handler subroutines, which will then be called in one of the compilation phases (i.e. in a &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; , or &lt;code&gt;END&lt;/code&gt; block). (&lt;code&gt;UNITCHECK&lt;/code&gt; blocks don't correspond to a global compilation phase, so they can't be specified here.)</source>
          <target state="translated">이 모듈은 패키지에 의해 상속 될 때 패키지의 클래스가 특정 속성에 대한 속성 핸들러 서브 루틴을 정의 할 수 있도록합니다. 해당 패키지 또는 해당 패키지에서 파생 된 패키지에 이후에 정의 된 변수 및 서브 루틴에는 속성 처리기 서브 루틴과 동일한 이름의 속성이 제공 될 수 있으며, 컴파일 단계 중 하나 (예 : &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; ) 에서 호출됩니다 또는 &lt;code&gt;END&lt;/code&gt; 블록). ( &lt;code&gt;UNITCHECK&lt;/code&gt; 의 그들이 여기에 지정 될 수 있도록 블록, 글로벌 컴파일 단계에 해당하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="d4b82d477760eacd25bf3c70a5e788527be511b5" translate="yes" xml:space="preserve">
          <source>This modules handles the BOM as follows.</source>
          <target state="translated">이 모듈은 다음과 같이 BOM을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="3973d4b3df1b4f6e4e1a4578c3854df16aa9cfcc" translate="yes" xml:space="preserve">
          <source>This name should be as descriptive, accurate, and complete as possible. Avoid any risk of ambiguity. Always try to use two or more whole words. Generally the name should reflect what is special about what the module does rather than how it does it. Please use nested module names to group informally or categorize a module. There should be a very good reason for a module not to have a nested name. Module names should begin with a capital letter.</source>
          <target state="translated">이 이름은 설명이 정확하고 정확해야합니다. 모호성의 위험을 피하십시오. 항상 두 개 이상의 전체 단어를 사용하십시오. 일반적으로 이름은 모듈이 수행하는 방식이 아니라 모듈의 기능에 대한 특별한 사항을 반영해야합니다. 중첩 된 모듈 이름을 사용하여 비공식적으로 그룹화하거나 모듈을 분류하십시오. 모듈이 중첩 된 이름을 가지지 않는 데에는 상당한 이유가 있습니다. 모듈 이름은 대문자로 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="64f3b2bdf54de52b80ace773443b078978c32943" translate="yes" xml:space="preserve">
          <source>This newer style is consistent with the values of other Unicode properties. To preserve backward compatibility, all the functions in Unicode::UCD that return block names (except as noted) return the old-style ones. &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; returns the new-style and can be used to convert from old-style to new-style:</source>
          <target state="translated">이 새로운 스타일은 다른 유니 코드 속성의 값과 일치합니다. 이전 버전과의 호환성을 유지하기 위해 블록 이름을 반환하는 유니 코드 :: UCD의 모든 함수 (표시된 것 제외)는 이전 스타일의 함수를 반환합니다. &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases ()&lt;/a&gt; 는 새 스타일을 반환하며 이전 스타일에서 새 스타일로 변환하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00215ed790925e9c90e37af405255e37b3a2b3c0" translate="yes" xml:space="preserve">
          <source>This normalizer function will store scalar context return values in the disk file under keys that begin with &lt;code&gt;S:&lt;/code&gt; , and list context return values under keys that begin with &lt;code&gt;L:&lt;/code&gt; .</source>
          <target state="translated">이 노멀 라이저 함수는 스칼라 컨텍스트 리턴 값을 디스크 파일의 &lt;code&gt;S:&lt;/code&gt; 시작하는 키 아래에 저장 하고 &lt;code&gt;L:&lt;/code&gt; 시작하는 키 아래에 컨텍스트 리턴 값을 나열합니다 .</target>
        </trans-unit>
        <trans-unit id="af82ed0821cc193322bac301a4efb5cd0be9cd17" translate="yes" xml:space="preserve">
          <source>This normally doesn't happen at the Perl level unless a variable is undef'ed or the last variable holding a reference to it is changed or overwritten. At the internal level, however, reference counts can be manipulated with the following macros:</source>
          <target state="translated">변수가 정의되지 않았거나 변수에 대한 참조를 보유한 마지막 변수가 변경되거나 덮어 쓰기되지 않으면 일반적으로 Perl 수준에서 발생하지 않습니다. 그러나 내부 수준에서는 다음 매크로를 사용하여 참조 카운트를 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="781831a4fcab5b31277395d81bbf01ada61ab8de" translate="yes" xml:space="preserve">
          <source>This number describes the earliest compatible &lt;code&gt;PERL_REVISION&lt;/code&gt; of Perl (&lt;code&gt;compatibility&lt;/code&gt; here being defined as sufficient</source>
          <target state="translated">이 숫자 는 Perl 의 가장 초기 호환 가능한 &lt;code&gt;PERL_REVISION&lt;/code&gt; 을 설명합니다 ( 여기서 &lt;code&gt;compatibility&lt;/code&gt; 은 충분한 것으로 정의 됨)</target>
        </trans-unit>
        <trans-unit id="0c3631049473f76e2dd0f9b657a8b5bb99ef0ce8" translate="yes" xml:space="preserve">
          <source>This number describes the earliest compatible &lt;code&gt;PERL_SUBVERSION&lt;/code&gt; of Perl (&lt;code&gt;compatibility&lt;/code&gt; here being defined as sufficient</source>
          <target state="translated">이 숫자 는 Perl 의 가장 초기 호환 가능한 &lt;code&gt;PERL_SUBVERSION&lt;/code&gt; 을 설명합니다 ( 여기서 &lt;code&gt;compatibility&lt;/code&gt; 은 충분한 것으로 정의 됨)</target>
        </trans-unit>
        <trans-unit id="74feee9a515674df1fbf3fa550f4ebde2a393edc" translate="yes" xml:space="preserve">
          <source>This number describes the earliest compatible &lt;code&gt;PERL_VERSION&lt;/code&gt; of Perl (&lt;code&gt;compatibility&lt;/code&gt; here being defined as sufficient</source>
          <target state="translated">이 숫자 는 Perl 의 가장 초기 호환 가능한 &lt;code&gt;PERL_VERSION&lt;/code&gt; 을 설명합니다 ( 여기서 &lt;code&gt;compatibility&lt;/code&gt; 은 충분한 것으로 정의 됨)</target>
        </trans-unit>
        <trans-unit id="3daf144ec9102bb41c4b3e85d9d925806042ef77" translate="yes" xml:space="preserve">
          <source>This object corresponds to a tree of parsed POD text. As POD text is scanned from left to right, it is parsed into an ordered list of text-strings and &lt;b&gt;Pod::InteriorSequence&lt;/b&gt; objects (in order of appearance). A &lt;b&gt;Pod::ParseTree&lt;/b&gt; object corresponds to this list of strings and sequences. Each interior sequence in the parse-tree may itself contain a parse-tree (since interior sequences may be nested).</source>
          <target state="translated">이 객체는 파싱 된 POD 텍스트 트리에 해당합니다. POD 텍스트는 왼쪽에서 오른쪽으로 스캔 될 때 순서가 지정된 텍스트 문자열 및 &lt;b&gt;Pod :: InteriorSequence&lt;/b&gt; 객체 (모양 순서) 로 구문 분석됩니다 . &lt;b&gt;포드 :: 파스 트리의&lt;/b&gt; 문자열과 시퀀스이 목록 객체에 해당합니다. 구문 분석 트리의 각 내부 시퀀스는 자체적으로 구문 분석 트리를 포함 할 수 있습니다 (내부 시퀀스가 ​​중첩 될 수 있으므로).</target>
        </trans-unit>
        <trans-unit id="c65aad4d731c650bf589bf8e7d6030572457b243" translate="yes" xml:space="preserve">
          <source>This object model leads to a tight coupling between subclasses. If one class wants to inherit from another (and both classes access object data), the classes must agree about implementation details. Inheritance can only be used among classes that are maintained together, in a single source or not.</source>
          <target state="translated">이 객체 모델은 서브 클래스 사이의 긴밀한 연결로 이어집니다. 한 클래스가 다른 클래스에서 상속을 원하고 (두 클래스 모두 객체 데이터에 액세스하는 경우) 클래스는 구현 세부 사항에 동의해야합니다. 상속은 단일 소스에서 함께 또는 유지되지 않는 클래스 사이에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75906e4fa98bc1c55561b974f97399cf50b738ce" translate="yes" xml:space="preserve">
          <source>This obviously matches, but in the process of matching, the subexpression &lt;code&gt;a*&lt;/code&gt; first grabbed the &lt;code&gt;a&lt;/code&gt; . Doing so, however, wouldn't allow the whole regexp to match, so after backtracking, &lt;code&gt;a*&lt;/code&gt; eventually gave back the &lt;code&gt;a&lt;/code&gt; and matched the empty string. Here, what &lt;code&gt;a*&lt;/code&gt; matched was</source>
          <target state="translated">이것은 분명히 일치하지만 일치하는 과정에서 하위 표현식 &lt;code&gt;a*&lt;/code&gt; 먼저 &lt;code&gt;a&lt;/code&gt; 를 잡았습니다 . 그래서 되돌아 후, 그래서, 그러나, 일치 전체 정규 표현식을 허용하지 않을 이렇게, &lt;code&gt;a*&lt;/code&gt; 결국 다시했다 &lt;code&gt;a&lt;/code&gt; 하고 빈 문자열을 일치. 여기서 &lt;code&gt;a*&lt;/code&gt; 와 일치하는 것은</target>
        </trans-unit>
        <trans-unit id="ce31346ef13bdd3b410f6693045b75e1d727f213" translate="yes" xml:space="preserve">
          <source>This one works differently from normal strings:</source>
          <target state="translated">이것은 일반 문자열과 다르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8dceabe6741f9e9be624acb0758d7a05df91f7b1" translate="yes" xml:space="preserve">
          <source>This operates as above, but the &lt;code&gt;Filter&lt;/code&gt; argument with a non-zero value causes the entire script, and not just literals, to be translated from the encoding into UTF-8. This allows identifiers in the source to be in that encoding as well. (Problems may occur if the encoding is not a superset of ASCII; imagine all your semi-colons being translated into something different.) One can use this form to make</source>
          <target state="translated">위와 같이 작동하지만 값이 0이 아닌 &lt;code&gt;Filter&lt;/code&gt; 인수는 리터럴뿐만 아니라 전체 스크립트가 인코딩에서 UTF-8로 변환되도록합니다. 이를 통해 소스의 식별자도 해당 인코딩에있을 수 있습니다. (인코딩이 ASCII의 상위 집합이 아닌 경우 문제가 발생할 수 있습니다. 모든 세미콜론이 다른 것으로 변환되는 것을 상상해보십시오.)이 양식을 사용하여</target>
        </trans-unit>
        <trans-unit id="bafbb273ef65724f67929789d4cf1821d369332e" translate="yes" xml:space="preserve">
          <source>This operator changes only the modification time of the file (VMS revision date) on ODS-2 volumes and ODS-5 volumes without access dates enabled. On ODS-5 volumes with access dates enabled, the true access time is modified.</source>
          <target state="translated">이 연산자는 액세스 날짜를 사용하지 않고 ODS-2 볼륨 및 ODS-5 볼륨의 파일 수정 시간 (VMS 개정 날짜) 만 변경합니다. 액세스 날짜가 활성화 된 ODS-5 볼륨에서 실제 액세스 시간이 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="ffba20ee3390ab6f7cdbeb9ab15cfb5e9016cca0" translate="yes" xml:space="preserve">
          <source>This operator is also handy for inverting a hash, although there are some caveats. If a value is duplicated in the original hash, only one of those can be represented as a key in the inverted hash. Also, this has to unwind one hash and build a whole new one, which may take some time on a large hash, such as from a DBM file.</source>
          <target state="translated">이 연산자는 해시를 뒤집는데도 유용하지만 몇 가지주의 사항이 있습니다. 원래 해시에서 값이 복제되면 그 중 하나만 역 해시에서 키로 표시 될 수 있습니다. 또한 이것은 하나의 해시를 풀고 완전히 새로운 해시를 빌드해야합니다. DBM 파일과 같은 큰 해시에는 시간이 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b8267c16c345a02931d07745eab202ccd1416fa" translate="yes" xml:space="preserve">
          <source>This operator is implemented using the standard &lt;code&gt;File::Glob&lt;/code&gt; extension. See &lt;a href=&quot;../file/glob&quot;&gt;File::Glob&lt;/a&gt; for details, including &lt;code&gt;bsd_glob&lt;/code&gt; which does not treat whitespace as a pattern separator.</source>
          <target state="translated">이 연산자는 표준 &lt;code&gt;File::Glob&lt;/code&gt; 확장자를 사용하여 구현됩니다 . 공백을 패턴 구분자로 처리하지 않는 &lt;code&gt;bsd_glob&lt;/code&gt; 를 포함하여 자세한 내용 은 &lt;a href=&quot;../file/glob&quot;&gt;File :: Glob&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="157d8ec0928a934391402a13da061adc37466e6a" translate="yes" xml:space="preserve">
          <source>This operator is implemented using the standard &lt;code&gt;File::Glob&lt;/code&gt; extension. See &lt;a href=&quot;file/glob&quot;&gt;File::Glob&lt;/a&gt; for details, including &lt;code&gt;bsd_glob&lt;/code&gt; which does not treat whitespace as a pattern separator.</source>
          <target state="translated">이 연산자는 표준 &lt;code&gt;File::Glob&lt;/code&gt; 확장자를 사용하여 구현됩니다 . 공백을 패턴 구분자로 처리하지 않는 &lt;code&gt;bsd_glob&lt;/code&gt; 를 포함하여 자세한 내용 은 &lt;a href=&quot;file/glob&quot;&gt;File :: Glob&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a18ef89c767fe3092cd7cbf7617a73212c9cedcd" translate="yes" xml:space="preserve">
          <source>This operator is implemented via the &lt;code&gt;File::Glob&lt;/code&gt; extension on most platforms. See &lt;a href=&quot;file/glob&quot;&gt;File::Glob&lt;/a&gt; for portability information.</source>
          <target state="translated">이 연산자는 대부분의 플랫폼 에서 &lt;code&gt;File::Glob&lt;/code&gt; 확장을 통해 구현됩니다 . 이식성 정보는 &lt;a href=&quot;file/glob&quot;&gt;File :: Glob&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f61ddb296f9de510c527089fa0d0e6f18a12bcc4" translate="yes" xml:space="preserve">
          <source>This operator quotes (and possibly compiles) its</source>
          <target state="translated">이 연산자는 따옴표를 인용하고 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="00bfef75bba78bb67546c7867c9c5ceacd8cc589" translate="yes" xml:space="preserve">
          <source>This option allow the filename field in the zip header to be modified before it is written to the zip file.</source>
          <target state="translated">이 옵션을 사용하면 zip 헤더의 파일 이름 필드를 zip 파일에 쓰기 전에 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31a1073c0be295447c4fa6a92df15986893583ac" translate="yes" xml:space="preserve">
          <source>This option applies to any input or output data streams to &lt;code&gt;anyinflate&lt;/code&gt; that are filehandles.</source>
          <target state="translated">이 옵션 은 파일 핸들 인 모든 &lt;code&gt;anyinflate&lt;/code&gt; 에 대한 모든 입력 또는 출력 데이터 스트림에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f9285c30af9b4fbbee720f406a006d97f4010015" translate="yes" xml:space="preserve">
          <source>This option applies to any input or output data streams to &lt;code&gt;anyuncompress&lt;/code&gt; that are filehandles.</source>
          <target state="translated">이 옵션 은 파일 처리 인 &lt;code&gt;anyuncompress&lt;/code&gt; 에 대한 모든 입력 또는 출력 데이터 스트림에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e84a1d77a7ad064325b540c87fc270941af6172d" translate="yes" xml:space="preserve">
          <source>This option applies to any input or output data streams to &lt;code&gt;bunzip2&lt;/code&gt; that are filehandles.</source>
          <target state="translated">이 옵션 은 파일 핸들 인 &lt;code&gt;bunzip2&lt;/code&gt; 에 대한 모든 입력 또는 출력 데이터 스트림에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="991318af65c036237347589558cc5bbc7b747313" translate="yes" xml:space="preserve">
          <source>This option applies to any input or output data streams to &lt;code&gt;bzip2&lt;/code&gt; that are filehandles.</source>
          <target state="translated">이 옵션 은 파일 핸들 인 &lt;code&gt;bzip2&lt;/code&gt; 의 모든 입력 또는 출력 데이터 스트림에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e3937b065e9e10f42a614e20da537cf76f206b09" translate="yes" xml:space="preserve">
          <source>This option applies to any input or output data streams to &lt;code&gt;deflate&lt;/code&gt; that are filehandles.</source>
          <target state="translated">이 옵션 은 파일 핸들 인 &lt;code&gt;deflate&lt;/code&gt; 를 빼기 위해 모든 입력 또는 출력 데이터 스트림에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7597a37aa86998ead804f6646d406a8232322d5c" translate="yes" xml:space="preserve">
          <source>This option applies to any input or output data streams to &lt;code&gt;gunzip&lt;/code&gt; that are filehandles.</source>
          <target state="translated">이 옵션 은 파일 핸들 인 &lt;code&gt;gunzip&lt;/code&gt; 에 대한 모든 입력 또는 출력 데이터 스트림에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="3b1d88507893c4f30c1f99b3dd08ad9bcc7749d4" translate="yes" xml:space="preserve">
          <source>This option applies to any input or output data streams to &lt;code&gt;gzip&lt;/code&gt; that are filehandles.</source>
          <target state="translated">이 옵션 은 파일 핸들 인 &lt;code&gt;gzip&lt;/code&gt; 에 대한 모든 입력 또는 출력 데이터 스트림에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="197d2e92c12a668b61b45cede98ce89082acf98a" translate="yes" xml:space="preserve">
          <source>This option applies to any input or output data streams to &lt;code&gt;inflate&lt;/code&gt; that are filehandles.</source>
          <target state="translated">이 옵션 은 파일 핸들 인 &lt;code&gt;inflate&lt;/code&gt; 하기 위해 모든 입력 또는 출력 데이터 스트림에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="11085e39e2558052d844319712c721f6cf03a406" translate="yes" xml:space="preserve">
          <source>This option applies to any input or output data streams to &lt;code&gt;rawdeflate&lt;/code&gt; that are filehandles.</source>
          <target state="translated">이 옵션 은 파일 처리 인 &lt;code&gt;rawdeflate&lt;/code&gt; 의 모든 입력 또는 출력 데이터 스트림에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="5edfb063fb42d1f72af8e3277ad4716ba885c487" translate="yes" xml:space="preserve">
          <source>This option applies to any input or output data streams to &lt;code&gt;rawinflate&lt;/code&gt; that are filehandles.</source>
          <target state="translated">이 옵션 은 파일 처리 인 &lt;code&gt;rawinflate&lt;/code&gt; 의 모든 입력 또는 출력 데이터 스트림에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="8b0f73e1567ccae83577dd7200eae7bda2188288" translate="yes" xml:space="preserve">
          <source>This option applies to any input or output data streams to &lt;code&gt;unzip&lt;/code&gt; that are filehandles.</source>
          <target state="translated">이 옵션 은 파일 핸들 인 &lt;code&gt;unzip&lt;/code&gt; 을 풀기 위한 모든 입력 또는 출력 데이터 스트림에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="295f0cfd4ded98b9574af22ae3b9d33935ef4669" translate="yes" xml:space="preserve">
          <source>This option applies to any input or output data streams to &lt;code&gt;zip&lt;/code&gt; that are filehandles.</source>
          <target state="translated">이 옵션 은 파일 핸들 인 &lt;code&gt;zip&lt;/code&gt; 으로의 입력 또는 출력 데이터 스트림에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2812ec45ee9aa481cedeafcd91c6fd310ce87a63" translate="yes" xml:space="preserve">
          <source>This option can be used when there is useful information immediately following the compressed data stream, and you don't know the length of the compressed data stream.</source>
          <target state="translated">압축 된 데이터 스트림 바로 뒤에 유용한 정보가 있고 압축 된 데이터 스트림의 길이를 모르는 경우이 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96e75df71c1bf6e90ec730c6cdd32614d5b40bf0" translate="yes" xml:space="preserve">
          <source>This option can be useful when the compressed data is embedded in another file/data structure and it is not possible to work out where the compressed data begins without having to read the first few bytes. If this is the case, the uncompression can be</source>
          <target state="translated">이 옵션은 압축 된 데이터가 다른 파일 / 데이터 구조에 포함되어 있고 처음 몇 바이트를 읽지 않고 압축 된 데이터가 시작되는 위치를 해결할 수 없을 때 유용합니다. 이 경우 압축 해제는</target>
        </trans-unit>
        <trans-unit id="ae71b12d470fda92f5396caeec200106ff4f6bc5" translate="yes" xml:space="preserve">
          <source>This option can be useful when you are processing compressed data that is embedded in another file/buffer. In this case the data that immediately follows the compressed stream will be left in the input buffer.</source>
          <target state="translated">이 옵션은 다른 파일 / 버퍼에 포함 된 압축 데이터를 처리 할 때 유용 할 수 있습니다. 이 경우 압축 스트림 바로 다음에 오는 데이터는 입력 버퍼에 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="05c5aace4afdf3704689266ed36cfe4a30bb343e" translate="yes" xml:space="preserve">
          <source>This option causes all configuration options to be reset to their default values as if the environment variable POSIXLY_CORRECT had been set.</source>
          <target state="translated">이 옵션을 사용하면 환경 변수 POSIXLY_CORRECT가 설정된 것처럼 모든 구성 옵션이 기본값으로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="0bb7609607b04e591708c21193516c45ee13b415" translate="yes" xml:space="preserve">
          <source>This option causes all configuration options to be reset to their default values.</source>
          <target state="translated">이 옵션을 사용하면 모든 구성 옵션이 기본값으로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="96a82215c08e826a1eb80ae96999f098e98a4ee7" translate="yes" xml:space="preserve">
          <source>This option controls how data is written to the output buffer by the &lt;code&gt;$d-&amp;gt;deflate&lt;/code&gt; and &lt;code&gt;$d-&amp;gt;flush&lt;/code&gt; methods.</source>
          <target state="translated">이 옵션은 &lt;code&gt;$d-&amp;gt;deflate&lt;/code&gt; 및 &lt;code&gt;$d-&amp;gt;flush&lt;/code&gt; 메소드로 출력 버퍼에 데이터를 쓰는 방법을 제어합니다 .</target>
        </trans-unit>
        <trans-unit id="c90b7070ba70482f3b4e42afba1dbe1ff165436c" translate="yes" xml:space="preserve">
          <source>This option controls how data is written to the output buffer by the &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; method.</source>
          <target state="translated">이 옵션은 &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; 메소드로 출력 버퍼에 데이터를 쓰는 방법을 제어합니다 .</target>
        </trans-unit>
        <trans-unit id="59041bc47f2bcbc25e18c7446422e8f7a244ca3a" translate="yes" xml:space="preserve">
          <source>This option controls the &quot;external file attributes&quot; field in the central header of the zip file. This is a 4 byte field.</source>
          <target state="translated">이 옵션은 zip 파일의 중앙 헤더에서 &quot;외부 파일 속성&quot;필드를 제어합니다. 이것은 4 바이트 필드입니다.</target>
        </trans-unit>
        <trans-unit id="fe53ff997f22ee3b8e3b5b499037b30213ed7a2b" translate="yes" xml:space="preserve">
          <source>This option controls what the &lt;code&gt;&lt;a href=&quot;../../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; method does with uncompressed data.</source>
          <target state="translated">이 옵션은 압축되지 않은 데이터에 대한 &lt;code&gt;&lt;a href=&quot;../../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 방법의 기능을 제어 합니다.</target>
        </trans-unit>
        <trans-unit id="2fd5bc077a448b0ac8688176c0355190f56eee1f" translate="yes" xml:space="preserve">
          <source>This option controls whether the extra checks defined below are used when carrying out the decompression. When Strict is on, the extra tests are carried out, when Strict is off they are not.</source>
          <target state="translated">이 옵션은 압축 해제시 아래 정의 된 추가 검사를 사용할지 여부를 제어합니다. Strict가 켜져 있으면 Strict가 꺼져 있으면 추가 테스트가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="e8f91b605f96e49eba45a2533f216bb9aa5630d4" translate="yes" xml:space="preserve">
          <source>This option controls whether the filename field in the zip header is</source>
          <target state="translated">이 옵션은 zip 헤더의 파일 이름 필드가</target>
        </trans-unit>
        <trans-unit id="c9ccbe84ff4c87c8d1938d3fb3bc36c35924a163" translate="yes" xml:space="preserve">
          <source>This option controls whether the zip file/buffer output is created in streaming mode.</source>
          <target state="translated">이 옵션은 zip 파일 / 버퍼 출력이 스트리밍 모드에서 생성되는지 여부를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="25df283cc49b2b02eee383b551fc895c82bca588" translate="yes" xml:space="preserve">
          <source>This option defaults to 1.</source>
          <target state="translated">이 옵션의 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="34b650f76678c6a01e22f15770dea69e53718082" translate="yes" xml:space="preserve">
          <source>This option defaults to 4096.</source>
          <target state="translated">이 옵션의 기본값은 4096입니다.</target>
        </trans-unit>
        <trans-unit id="d5f2929171736f86edabd8e4e81e6b76f585f308" translate="yes" xml:space="preserve">
          <source>This option defaults to &lt;b&gt;false&lt;/b&gt;.</source>
          <target state="translated">이 옵션의 기본값은 &lt;b&gt;false&lt;/b&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0fe4b53be5e0e4b306e7b8817dee109e7d56e3b6" translate="yes" xml:space="preserve">
          <source>This option defaults to false.</source>
          <target state="translated">이 옵션의 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="3c17c5d6de4659d46fac1329201d45aebab6728c" translate="yes" xml:space="preserve">
          <source>This option defaults to off.</source>
          <target state="translated">이 옵션은 기본적으로 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b6fb11ab3c3f09a5247ca571c81e532a6439637" translate="yes" xml:space="preserve">
          <source>This option defaults to true.</source>
          <target state="translated">이 옵션의 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="a49b3dde1d982fff6659af9dbc370e4c81b2a251" translate="yes" xml:space="preserve">
          <source>This option expects an array reference with exactly three elements: &lt;code&gt;$atime&lt;/code&gt; , &lt;code&gt;mtime&lt;/code&gt; and &lt;code&gt;$ctime&lt;/code&gt; . These correspond to the last access time, last modification time and creation time respectively.</source>
          <target state="translated">이 옵션은 정확히 &lt;code&gt;$atime&lt;/code&gt; , &lt;code&gt;mtime&lt;/code&gt; 및 &lt;code&gt;$ctime&lt;/code&gt; 세 가지 요소를 가진 배열 참조를 예상합니다 . 이들은 각각 마지막 액세스 시간, 마지막 수정 시간 및 생성 시간에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="d7b61a9548815335c12044934c6edf6afc0fade2" translate="yes" xml:space="preserve">
          <source>This option expects an array reference with exactly two elements: &lt;code&gt;$uid&lt;/code&gt; and &lt;code&gt;$gid&lt;/code&gt; . These values correspond to the numeric User ID (UID) and Group ID (GID) of the owner of the files respectively.</source>
          <target state="translated">이 옵션은 정확히 &lt;code&gt;$uid&lt;/code&gt; 및 &lt;code&gt;$gid&lt;/code&gt; 두 가지 요소를 가진 배열 참조를 예상합니다 . 이 값은 각각 파일 소유자의 숫자 UID (UI) 및 그룹 ID (GID)에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="f5e3123268242816c97985ddf2abce0d046136ba" translate="yes" xml:space="preserve">
          <source>This option is a no-op.</source>
          <target state="translated">이 옵션은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1144456033d4b378e77675f24087a7a175d1be93" translate="yes" xml:space="preserve">
          <source>This option is case-insensitive.</source>
          <target state="translated">이 옵션은 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2511f05b6374c7879cb361cf57c595c2e2f72590" translate="yes" xml:space="preserve">
          <source>This option is checked when you write out the tarfile using &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;create_archive&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;create_archive&lt;/code&gt; 를 사용하여 tarfile을 쓸 때이 옵션이 점검됩니다 .</target>
        </trans-unit>
        <trans-unit id="1b2a2a4f5928dc68068bb78c6282de092775a8e0" translate="yes" xml:space="preserve">
          <source>This option is enabled by default.</source>
          <target state="translated">이 옵션은 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4549d37c19966c81c9e8c6bc7457a6a5da6fd6d3" translate="yes" xml:space="preserve">
          <source>This option is mostly used when reading from a filehandle, in which case the file pointer will be left pointing to the first byte directly after the compressed data stream.</source>
          <target state="translated">이 옵션은 주로 파일 핸들에서 읽을 때 사용되며,이 경우 파일 포인터는 압축 된 데이터 스트림 바로 다음에 첫 번째 바이트를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="da3c768aaf3f5e035f976487f87837b11b5b30c6" translate="yes" xml:space="preserve">
          <source>This option is no longer supported. It is still documented only to aid in the debugging of old programs that use it. Old programs should be converted to use the &lt;code&gt;HASH&lt;/code&gt; option instead.</source>
          <target state="translated">이 옵션은 더 이상 지원되지 않습니다. 그것은 그것을 사용하는 오래된 프로그램의 디버깅을 돕기 위해 여전히 문서화되어 있습니다. 이전 프로그램은 &lt;code&gt;HASH&lt;/code&gt; 옵션을 대신 사용하도록 변환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a4a6ba823380e81c3792a98e87160d5e375b14e6" translate="yes" xml:space="preserve">
          <source>This option is obscure and discouraged.</source>
          <target state="translated">이 옵션은 불분명하고 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c86f3c4424a2a7c5541c3bc97e781d1a1d2bf31e" translate="yes" xml:space="preserve">
          <source>This option is only valid if the &lt;code&gt;Method&lt;/code&gt; is ZIP_CM_BZIP2. It is ignored otherwise.</source>
          <target state="translated">이 옵션은 &lt;code&gt;Method&lt;/code&gt; 가 ZIP_CM_BZIP2 인 경우에만 유효합니다 . 그렇지 않으면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="e287076e946d3a88fdf8e217ada09ffe773941d3" translate="yes" xml:space="preserve">
          <source>This option is only valid if the &lt;code&gt;Method&lt;/code&gt; is ZIP_CM_LZMA. It is ignored otherwise.</source>
          <target state="translated">이 옵션은 &lt;code&gt;Method&lt;/code&gt; 가 ZIP_CM_LZMA 인 경우에만 유효합니다 . 그렇지 않으면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="e47f433c8815bcca005cf8fc1f8f226523161029" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$input&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the file being closed once either the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method is called or the IO::Uncompress::AnyInflate object is destroyed.</source>
          <target state="translated">이 옵션은 &lt;code&gt;$input&lt;/code&gt; 매개 변수가 파일 핸들 인 경우에만 유효합니다 . 지정된 경우 값이 true이면 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 메소드가 호출되거나 IO :: Uncompress :: AnyInflate 오브젝트가 삭제 되면 파일이 닫힙니다 .</target>
        </trans-unit>
        <trans-unit id="4c7afb5a8e42acbe0e34fc5f5b8fc4326a8529d5" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$input&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the file being closed once either the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method is called or the IO::Uncompress::AnyUncompress object is destroyed.</source>
          <target state="translated">이 옵션은 &lt;code&gt;$input&lt;/code&gt; 매개 변수가 파일 핸들 인 경우에만 유효합니다 . 지정되고 값이 true이면 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 메소드가 호출되거나 IO :: Uncompress :: AnyUncompress 오브젝트가 삭제 되면 파일이 닫힙니다 .</target>
        </trans-unit>
        <trans-unit id="4c90c6efe9d75228bc8980202147dbd8e5b1d098" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$input&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the file being closed once either the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method is called or the IO::Uncompress::Bunzip2 object is destroyed.</source>
          <target state="translated">이 옵션은 &lt;code&gt;$input&lt;/code&gt; 매개 변수가 파일 핸들 인 경우에만 유효합니다 . 지정되고 값이 true이면 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 메소드가 호출되거나 IO :: Uncompress :: Bunzip2 오브젝트가 삭제 되면 파일이 닫힙니다 .</target>
        </trans-unit>
        <trans-unit id="1a0451d52242cab341bf29b753116dd306cc10b7" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$input&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the file being closed once either the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method is called or the IO::Uncompress::Gunzip object is destroyed.</source>
          <target state="translated">이 옵션은 &lt;code&gt;$input&lt;/code&gt; 매개 변수가 파일 핸들 인 경우에만 유효합니다 . 지정되고 값이 true이면 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 메소드가 호출되거나 IO :: Uncompress :: Gunzip 오브젝트가 소멸 되면 파일이 닫힙니다 .</target>
        </trans-unit>
        <trans-unit id="c6cccd64b3f769d6fde655234d1c117fd17fbdc4" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$input&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the file being closed once either the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method is called or the IO::Uncompress::Inflate object is destroyed.</source>
          <target state="translated">이 옵션은 &lt;code&gt;$input&lt;/code&gt; 매개 변수가 파일 핸들 인 경우에만 유효합니다 . 지정되고 값이 true이면 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 메소드가 호출되거나 IO :: Uncompress :: Inflate 오브젝트가 소멸 되면 파일이 닫힙니다 .</target>
        </trans-unit>
        <trans-unit id="a026bdcb25c56dbca754467a3829013c39db31ac" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$input&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the file being closed once either the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method is called or the IO::Uncompress::RawInflate object is destroyed.</source>
          <target state="translated">이 옵션은 &lt;code&gt;$input&lt;/code&gt; 매개 변수가 파일 핸들 인 경우에만 유효합니다 . 지정되고 값이 true이면 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 메소드가 호출되거나 IO :: Uncompress :: RawInflate 오브젝트가 소멸 되면 파일이 닫힙니다 .</target>
        </trans-unit>
        <trans-unit id="f4a3d8b2fb37fa80663bb31ac23a1f0cc61d52e6" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$input&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the file being closed once either the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method is called or the IO::Uncompress::Unzip object is destroyed.</source>
          <target state="translated">이 옵션은 &lt;code&gt;$input&lt;/code&gt; 매개 변수가 파일 핸들 인 경우에만 유효합니다 . 지정되고 값이 true이면 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 메소드가 호출되거나 IO :: Uncompress :: Unzip 오브젝트가 소멸 되면 파일이 닫힙니다 .</target>
        </trans-unit>
        <trans-unit id="a47e1179435d09c1507a883d5e990db962771a45" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$output&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the &lt;code&gt;$output&lt;/code&gt; being closed once either the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method is called or the &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; object is destroyed.</source>
          <target state="translated">이 옵션은 &lt;code&gt;$output&lt;/code&gt; 매개 변수가 파일 핸들 인 경우에만 유효합니다 . 지정되고 값이 true이면 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 메소드가 호출되거나 &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; 오브젝트가 소멸 되면 &lt;code&gt;$output&lt;/code&gt; 이 닫힙니다 .</target>
        </trans-unit>
        <trans-unit id="97fb53611300748a1b7f47bb19f220d7d3bb2490" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$output&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the &lt;code&gt;$output&lt;/code&gt; being closed once either the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method is called or the &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; object is destroyed.</source>
          <target state="translated">이 옵션은 &lt;code&gt;$output&lt;/code&gt; 매개 변수가 파일 핸들 인 경우에만 유효합니다 . 지정되고 값이 true이면 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 메소드가 호출되거나 &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; 오브젝트가 소멸 되면 &lt;code&gt;$output&lt;/code&gt; 이 닫힙니다 .</target>
        </trans-unit>
        <trans-unit id="258816e7ba3830736405fb29e1fd5aa78fa1b61a" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$output&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the &lt;code&gt;$output&lt;/code&gt; being closed once either the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method is called or the &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; object is destroyed.</source>
          <target state="translated">이 옵션은 &lt;code&gt;$output&lt;/code&gt; 매개 변수가 파일 핸들 인 경우에만 유효합니다 . 지정되고 값이 true이면 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 메소드가 호출되거나 &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; 오브젝트가 소멸 되면 &lt;code&gt;$output&lt;/code&gt; 이 닫힙니다 .</target>
        </trans-unit>
        <trans-unit id="33f553ec8eed6ca2655d0af84e094c777ea4ac37" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$output&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the &lt;code&gt;$output&lt;/code&gt; being closed once either the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method is called or the &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; object is destroyed.</source>
          <target state="translated">이 옵션은 &lt;code&gt;$output&lt;/code&gt; 매개 변수가 파일 핸들 인 경우에만 유효합니다 . 지정되고 값이 true이면 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 메소드가 호출되거나 &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; 오브젝트가 소멸 되면 &lt;code&gt;$output&lt;/code&gt; 이 닫힙니다 .</target>
        </trans-unit>
        <trans-unit id="29176bb9d55bdad6e9210947b4806edcc6d975b2" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$output&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the &lt;code&gt;$output&lt;/code&gt; being closed once either the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method is called or the &lt;code&gt;IO::Compress::Zip&lt;/code&gt; object is destroyed.</source>
          <target state="translated">이 옵션은 &lt;code&gt;$output&lt;/code&gt; 매개 변수가 파일 핸들 인 경우에만 유효합니다 . 지정되고 값이 true이면 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 메소드가 호출되거나 &lt;code&gt;IO::Compress::Zip&lt;/code&gt; 오브젝트가 소멸 되면 &lt;code&gt;$output&lt;/code&gt; 이 닫힙니다 .</target>
        </trans-unit>
        <trans-unit id="f4da7e81811658139a241d2fcf49caaf6fc6d794" translate="yes" xml:space="preserve">
          <source>This option is significantly slower than the other one.</source>
          <target state="translated">이 옵션은 다른 옵션보다 상당히 느립니다.</target>
        </trans-unit>
        <trans-unit id="43ce55b0c5bee0085af75b3bb5923ccf3a65b644" translate="yes" xml:space="preserve">
          <source>This option is used to compress input data and append it to an existing compressed data stream in &lt;code&gt;$output&lt;/code&gt; . The end result is a single compressed data stream stored in &lt;code&gt;$output&lt;/code&gt; .</source>
          <target state="translated">이 옵션은 입력 데이터를 압축하여 &lt;code&gt;$output&lt;/code&gt; 의 기존 압축 데이터 스트림에 추가하는 데 사용됩니다 . 최종 결과는 &lt;code&gt;$output&lt;/code&gt; 저장된 단일 압축 데이터 스트림 입니다.</target>
        </trans-unit>
        <trans-unit id="c905ba8910d975a79e749c35e513e95ca43f84ed" translate="yes" xml:space="preserve">
          <source>This option means that you want to limit the results just to items whose podnames match the given glob/wildcard expression. For example, you might limit your search to just &quot;LWP::*&quot;, to search only for modules starting with &quot;LWP::*&quot; (but not including the module &quot;LWP&quot; itself); or you might limit your search to &quot;LW*&quot; to see only modules whose (full) names begin with &quot;LW&quot;; or you might search for &quot;*Find*&quot; to search for all modules with &quot;Find&quot; somewhere in their full name. (You can also use &quot;?&quot; in a glob expression; so &quot;DB?&quot; will match &quot;DBI&quot; and &quot;DBD&quot;.)</source>
          <target state="translated">이 옵션은 podname이 주어진 glob / wildcard 표현식과 일치하는 항목으로 만 결과를 제한하고자 함을 의미합니다. 예를 들어, &quot;LWP :: *&quot;로 시작하는 모듈 만 검색하기 위해 &quot;LWP :: *&quot;로 검색을 제한 할 수 있지만 &quot;LWP&quot;자체는 포함하지 않습니다. 또는 이름이 &quot;LW&quot;로 시작하는 모듈 만 보려면 &quot;LW *&quot;로 검색을 제한 할 수 있습니다. 또는 &quot;* Find *&quot;를 검색하여 이름이 &quot;Find&quot;인 모든 모듈을 검색 할 수 있습니다. glob 표현식에 &quot;?&quot;를 사용할 수도 있으므로 &quot;DB?&quot;는 &quot;DBI&quot;및 &quot;DBD&quot;와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="20360642d3c9e99dc2a287f8242c272ca5705a34" translate="yes" xml:space="preserve">
          <source>This option says to instead output literal UTF-8 characters. If your *roff implementation can handle it, this is the best output format to use and avoids corruption of documents containing non-ASCII characters. However, be warned that *roff source with literal UTF-8 characters is not supported by many implementations and may even result in segfaults and other bad behavior.</source>
          <target state="translated">이 옵션은 리터럴 UTF-8 문자를 대신 출력하도록합니다. * roff 구현이이를 처리 할 수있는 경우 이것이 사용하기에 가장 적합한 출력 형식이며 ASCII가 아닌 문자가 포함 된 문서의 손상을 피합니다. 그러나 리터럴 UTF-8 문자가있는 * roff 소스는 많은 구현에서 지원되지 않으며 segfaults 및 기타 잘못된 동작을 초래할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="198821065f8114e37c282b1dc5e2e1e562fb79c1" translate="yes" xml:space="preserve">
          <source>This option takes a parameter that must be a reference to a sub. On entry to the sub the &lt;code&gt;$_&lt;/code&gt; variable will contain the name to be filtered. If no filename is available &lt;code&gt;$_&lt;/code&gt; will contain an empty string.</source>
          <target state="translated">이 옵션은 하위에 대한 참조 여야하는 매개 변수를 사용합니다. 하위 항목을 입력하면 &lt;code&gt;$_&lt;/code&gt; 변수에 필터링 할 이름이 포함됩니다. 파일 이름이 없으면 &lt;code&gt;$_&lt;/code&gt; 에 빈 문자열이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="3c97397612f397cc9803106ff617ed57fcd7bbdd" translate="yes" xml:space="preserve">
          <source>This option was introduced to let you easily customize which</source>
          <target state="translated">이 옵션은 쉽게 사용자 정의 할 수 있도록 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="478ef92f533a2a64ed38715adae3641923596540" translate="yes" xml:space="preserve">
          <source>This option will uncompress the contents of &lt;code&gt;$string&lt;/code&gt; before processing the input file/buffer.</source>
          <target state="translated">이 옵션은 입력 파일 / 버퍼를 처리하기 전에 &lt;code&gt;$string&lt;/code&gt; 의 내용을 압축 해제합니다 .</target>
        </trans-unit>
        <trans-unit id="94e79c8cc707f4d220ebc5676b2e7c094b43e26e" translate="yes" xml:space="preserve">
          <source>This option, if set to a true value, suppresses the URL when anchor text is given, so this example would be formatted as just &lt;code&gt;foo&lt;/code&gt; . This can produce less cluttered output in cases where the URLs are not particularly important.</source>
          <target state="translated">이 옵션을 true로 설정하면 앵커 텍스트가 제공 될 때 URL이 표시되지 않으므로이 예제는 &lt;code&gt;foo&lt;/code&gt; 형식으로 표시됩니다 . 이것은 URL이 특별히 중요하지 않은 경우 덜 복잡한 출력을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d73e8a9fe84394bb733d349d80f809abc0c71549" translate="yes" xml:space="preserve">
          <source>This overload was introduced in Perl 5.12.</source>
          <target state="translated">이 과부하는 Perl 5.12에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="80f1948b993b572ddd0ded00367d4480f0e1a9dd" translate="yes" xml:space="preserve">
          <source>This overrides all the default install locations. Man pages, libraries, scripts, etc... MakeMaker will try to make an educated guess about where to place things under the new PREFIX based on your Config defaults. Failing that, it will fall back to a structure which should be sensible for your platform.</source>
          <target state="translated">이것은 모든 기본 설치 위치를 대체합니다. 매뉴얼 페이지, 라이브러리, 스크립트 등 ... MakeMaker는 구성 기본값을 기반으로 새 PREFIX 아래에 항목을 배치 할 위치에 대한 정확한 추측을 시도합니다. 실패하면 플랫폼에 적합한 구조로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="444e5337bdc60ac371985ae433717f80c0fb2273" translate="yes" xml:space="preserve">
          <source>This overrides the default behavior of &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; inside the newly created thread only.</source>
          <target state="translated">이것은 새로 작성된 스레드 내에서만 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 의 기본 작동을 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="519b8612e911f1f56d7cf335d416b8b3e0b034ae" translate="yes" xml:space="preserve">
          <source>This package allows a tied hash to autoload its values on the first access, and to use the cached value on the following accesses.</source>
          <target state="translated">이 패키지를 사용하면 연결 해시가 첫 번째 액세스에서 값을 자동로드하고 다음 액세스에서 캐시 된 값을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52216942838934faafa12f993b9e33de2dc6a37f" translate="yes" xml:space="preserve">
          <source>This package has been part of the perl core since perl 5.001. It has been released separately to CPAN so older installations can benefit from bug fixes.</source>
          <target state="translated">이 패키지는 perl 5.001 이후 펄 코어의 일부였습니다. CPAN에 별도로 릴리스되었으므로 이전 설치에서는 버그 수정의 혜택을 누릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2c6b0ed0d74189431901579ee94937bb8d4ce64" translate="yes" xml:space="preserve">
          <source>This package has been part of the perl core since the first release of perl5. It has been released separately to CPAN so older installations can benefit from bug fixes.</source>
          <target state="translated">이 패키지는 perl5의 첫 번째 릴리스 이후 펄 코어의 일부였습니다. CPAN에 별도로 릴리스되었으므로 이전 설치에서는 버그 수정의 혜택을 누릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8604a04f6b263dfa751e272224470b230a03d1e8" translate="yes" xml:space="preserve">
          <source>This package has the same copyright and license as the perl core.</source>
          <target state="translated">이 패키지는 펄 코어와 동일한 저작권 및 라이센스를가집니다.</target>
        </trans-unit>
        <trans-unit id="5b6805fe29e54bd4efe3c6b5cfa333a68b6dd7e7" translate="yes" xml:space="preserve">
          <source>This package has the same copyright and license as the perl core:</source>
          <target state="translated">이 패키지는 펄 코어와 동일한 저작권 및 라이센스를가집니다 :</target>
        </trans-unit>
        <trans-unit id="3dd0926d44817739b9d6d9f6b9c878553eedc873" translate="yes" xml:space="preserve">
          <source>This package has the same functionality as CPAN.pm, but tries to prevent the usage of compiled extensions during its own execution. Its primary purpose is a rescue in case you upgraded perl and broke binary compatibility somehow.</source>
          <target state="translated">이 패키지는 CPAN.pm과 기능은 동일하지만 자체 실행 중에 컴파일 된 확장이 사용되지 않도록합니다. 주요 목적은 펄을 업그레이드하고 어떻게 든 바이너리 호환성을 깨뜨린 경우를 대비 한 구조입니다.</target>
        </trans-unit>
        <trans-unit id="5ec260b88b13584e3875f1a95d421c8de3085165" translate="yes" xml:space="preserve">
          <source>This package is free software and is provided &quot;as is&quot; without express or implied warranty. It may be used, redistributed and/or modified under the same terms as Perl itself.</source>
          <target state="translated">이 패키지는 무료 소프트웨어이며 명시 적 또는 묵시적 보증없이 &quot;있는 그대로&quot;제공됩니다. Perl 자체와 동일한 용어로 사용, 재배포 및 / 또는 수정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d169e6cde7a05a46328dee15bc92ea9fbd31c5a" translate="yes" xml:space="preserve">
          <source>This package is just a front end to some other packages. It's a stub to set up a common interface to the various ReadLine implementations found on CPAN (under the &lt;code&gt;Term::ReadLine::*&lt;/code&gt; namespace).</source>
          <target state="translated">이 패키지는 다른 패키지의 프론트 엔드입니다. CPAN ( &lt;code&gt;Term::ReadLine::*&lt;/code&gt; 네임 스페이스 아래)에있는 다양한 ReadLine 구현에 대한 공통 인터페이스를 설정하는 토막 입니다.</target>
        </trans-unit>
        <trans-unit id="ce76c6c4371370495517baf3705b461101fff8c7" translate="yes" xml:space="preserve">
          <source>This package is meant as a base of Pod::Perldoc formatters, like &lt;a href=&quot;totext&quot;&gt;Pod::Perldoc::ToText&lt;/a&gt;, &lt;a href=&quot;toman&quot;&gt;Pod::Perldoc::ToMan&lt;/a&gt;, etc.</source>
          <target state="translated">이 패키지는 &lt;a href=&quot;totext&quot;&gt;Pod :: Perldoc :: ToText&lt;/a&gt; , &lt;a href=&quot;toman&quot;&gt;Pod :: Perldoc :: ToMan&lt;/a&gt; 등과 같은 Pod :: Perldoc 포맷터의 기본으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="9180a230452e68871f0598e03ac17371f08687f4" translate="yes" xml:space="preserve">
          <source>This package is still a work in progress. ;-)</source>
          <target state="translated">이 패키지는 여전히 진행중인 작업입니다. ;-)</target>
        </trans-unit>
        <trans-unit id="5132ab88c97f356a0cb81785c11fd445555c2f78" translate="yes" xml:space="preserve">
          <source>This package lets you create and manipulate complex numbers. By default,</source>
          <target state="translated">이 패키지를 사용하면 복소수를 생성하고 조작 할 수 있습니다. 기본적으로,</target>
        </trans-unit>
        <trans-unit id="0502ae210c839a0d5612b4c49c9ee0a00914b58d" translate="yes" xml:space="preserve">
          <source>This packs &lt;code&gt;3*@buffer&lt;/code&gt; bytes, but it turns out that the size of &lt;code&gt;buffer_t&lt;/code&gt; is four times &lt;code&gt;BUFLEN&lt;/code&gt; ! The moral of the story is that the required alignment of a structure or array is propagated to the next higher level where we have to consider padding</source>
          <target state="translated">이것은 &lt;code&gt;3*@buffer&lt;/code&gt; 바이트를 압축 하지만 &lt;code&gt;buffer_t&lt;/code&gt; 의 크기는 &lt;code&gt;BUFLEN&lt;/code&gt; 의 4 배 입니다 . 이야기의 도덕은 구조 또는 배열의 필요한 정렬이 패딩을 고려해야하는 다음 상위 레벨로 전파된다는 것입니다</target>
        </trans-unit>
        <trans-unit id="946e326f892b4b8b1ddce244173724cf9a7d1bb8" translate="yes" xml:space="preserve">
          <source>This page covers the very basics of understanding, creating and using regular expressions ('regexes') in Perl.</source>
          <target state="translated">이 페이지는 Perl에서 정규식 ( 'regexes')을 이해하고 작성하고 사용하는 기본 사항을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="dce9886ab9b0a9a0def511caa51f7fe80e84aea2" translate="yes" xml:space="preserve">
          <source>This page describes the syntax of regular expressions in Perl.</source>
          <target state="translated">이 페이지에서는 Perl의 정규 표현식 구문에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="317e90a756283c2e548a97a6d078f31d1baf3825" translate="yes" xml:space="preserve">
          <source>This page provides a basic tutorial on understanding, creating and using regular expressions in Perl. It serves as a complement to the reference page on regular expressions &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;. Regular expressions are an integral part of the &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; operators and so this tutorial also overlaps with &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt; and &lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;.</source>
          <target state="translated">이 페이지는 Perl에서 정규식 이해, 작성 및 사용에 대한 기본 학습서를 제공합니다. 정규 표현식 &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; 의 참조 페이지를 보완합니다 . 정규식은 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 연산자 의 필수 부분 &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;이므로이&lt;/a&gt; 튜토리얼 은 perlop 및 &lt;a href=&quot;functions/split&quot;&gt;split의 &lt;/a&gt;Regexp Quote-Like 연산자 와 겹칩니다 .</target>
        </trans-unit>
        <trans-unit id="5dd11d6815b6bbd5757b2908c5f7f36d9fc65ef7" translate="yes" xml:space="preserve">
          <source>This parameter allows additional metadata to be stored in the ExtraField in the gzip header. An RFC 1952 compliant ExtraField consists of zero or more subfields. Each subfield consists of a two byte header followed by the subfield data.</source>
          <target state="translated">이 매개 변수를 사용하면 추가 메타 데이터를 gzip 헤더의 ExtraField에 저장할 수 있습니다. RFC 1952 호환 ExtraField는 0 개 이상의 서브 필드로 구성됩니다. 각 서브 필드는 2 바이트 헤더와 서브 필드 데이터로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="6c5f89c77abee951f08c51fc642a03fa6b870eac" translate="yes" xml:space="preserve">
          <source>This parameter controls the setting of a bit in the zip central header. It is used to signal that the data stored in the zip file/buffer is probably text.</source>
          <target state="translated">이 매개 변수는 Zip 중앙 헤더의 비트 설정을 제어합니다. zip 파일 / 버퍼에 저장된 데이터가 아마도 텍스트라는 신호를 보내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f7ab5c8a3bc9a88a9534a62193fcda4a2a345ca3" translate="yes" xml:space="preserve">
          <source>This parameter controls the setting of the FLG.FTEXT bit in the gzip header. It is used to signal that the data stored in the gzip file/buffer is probably text.</source>
          <target state="translated">이 매개 변수는 gzip 헤더에서 FLG.FTEXT 비트의 설정을 제어합니다. gzip 파일 / 버퍼에 저장된 데이터가 아마도 텍스트라는 신호를 보내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1d135fdd7e0c9609625dc055c076f0bab706088f" translate="yes" xml:space="preserve">
          <source>This parameter defaults to 0.</source>
          <target state="translated">이 매개 변수의 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="a954f8a244020c9f424e9822cfad5459a2f5fec4" translate="yes" xml:space="preserve">
          <source>This parameter is ignored.</source>
          <target state="translated">이 매개 변수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="3095070e85d1a1b0788b86dc1c47569b11d0ecb4" translate="yes" xml:space="preserve">
          <source>This parameter is used to specify the ambient pragmas which are stored in the special hash %^H.</source>
          <target state="translated">이 매개 변수는 특수 해시 % ^ H에 저장된 주변 pragma를 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e57f8e4024e58b80873e8cbfaa23d47d4d596bfc" translate="yes" xml:space="preserve">
          <source>This parameter works like &lt;code&gt;overrideCJK&lt;/code&gt; , so see there for examples.</source>
          <target state="translated">이 매개 변수는 &lt;code&gt;overrideCJK&lt;/code&gt; 와 같이 작동 하므로 예제를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ac9494fe5df3170e77a2748f1c2b29eb01128b21" translate="yes" xml:space="preserve">
          <source>This pattern matches nothing and always fails. It can be used to force the engine to backtrack. It is equivalent to &lt;code&gt;(?!)&lt;/code&gt;, but easier to read. In fact, &lt;code&gt;(?!)&lt;/code&gt; gets optimised into &lt;code&gt;(*FAIL)&lt;/code&gt; internally.</source>
          <target state="translated">이 패턴은 아무 것도 일치하지 않으며 항상 실패합니다. 엔진을 강제로 역 추적하는 데 사용할 수 있습니다. 그것은 동일합니다 &lt;code&gt;(?!)&lt;/code&gt; 하지만, 쉽게 읽을 수. 실제로 &lt;code&gt;(?!)&lt;/code&gt; 는 내부적 으로 &lt;code&gt;(*FAIL)&lt;/code&gt; 로 최적화됩니다 .</target>
        </trans-unit>
        <trans-unit id="9d7331a8c75f2ab7015003fc1a186b402d4f4b0f" translate="yes" xml:space="preserve">
          <source>This pattern matches nothing and causes the end of successful matching at the point at which the &lt;code&gt;(*ACCEPT)&lt;/code&gt; pattern was encountered, regardless of whether there is actually more to match in the string. When inside of a nested pattern, such as recursion, or in a subpattern dynamically generated via &lt;code&gt;(??{})&lt;/code&gt; , only the innermost pattern is ended immediately.</source>
          <target state="translated">이 패턴은 아무것도 일치하지 않으며 실제로 문자열에 일치하는 항목이 더 있는지 여부에 관계없이 &lt;code&gt;(*ACCEPT)&lt;/code&gt; 패턴이 발생한 지점에서 성공적인 일치를 종료 합니다. 재귀와 같은 중첩 패턴의 내부 또는 &lt;code&gt;(??{})&lt;/code&gt; 를 통해 동적으로 생성 된 하위 패턴의 경우 가장 안쪽의 패턴 만 즉시 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="19f045887dd160fbc7bf52fef1325dee9e3b92d8" translate="yes" xml:space="preserve">
          <source>This perl distribution comes with a tremendous amount of documentation. To add these to the built-in manuals that come with Plan 9, from /sys/src/cmd/perl/5.00301 (adjust version appropriately) run:</source>
          <target state="translated">이 펄 배포판에는 엄청난 양의 문서가 제공됩니다. /sys/src/cmd/perl/5.00301에서 Plan 9와 함께 제공되는 내장 매뉴얼에 추가하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="faaee2dbff571e442cc459d64235bf7e75251410" translate="yes" xml:space="preserve">
          <source>This phase is not called &quot;BEGIN&quot; to avoid confusion with &lt;code&gt;BEGIN&lt;/code&gt; -blocks, as those are executed during compile-time of any compilation unit, not just the top-level program. A new, localised compile-time entered at run-time, for example by constructs as &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; &quot;use SomeModule&quot;&lt;/code&gt; are not global interpreter phases, and therefore aren't reflected by &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; .</source>
          <target state="translated">이 단계는 최상위 프로그램뿐만 아니라 컴파일 단위의 컴파일 타임 동안 실행되므로 &lt;code&gt;BEGIN&lt;/code&gt; 블록 과 혼동을 피하기 위해 &quot;BEGIN&quot;이라고 하지 않습니다. 예를 들어 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; &quot;use SomeModule&quot;&lt;/code&gt; 이 전역 인터프리터 단계가 아니므 로 런타임에 입력 된 새로운 현지화 된 컴파일 타임은 구문에 의해 구성 되므로 &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; 반영되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="38d412691b698918f3fb521b6c5dd0a3a033324a" translate="yes" xml:space="preserve">
          <source>This pipes &quot;foo&quot; to the &quot;less&quot; pager and prints &quot;bar&quot; on the console:</source>
          <target state="translated">&quot;foo&quot;를 &quot;less&quot;호출기로 파이프하고 콘솔에 &quot;bar&quot;를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="aa4d6fbd955f7e5cef0d107f07af92fd7a485df2" translate="yes" xml:space="preserve">
          <source>This pipes &quot;foo&quot; to the pager and writes &quot;bar&quot; in the file &quot;blurch&quot;:</source>
          <target state="translated">&quot;foo&quot;를 호출기로 파이프하고 &quot;blurch&quot;파일에 &quot;bar&quot;를 씁니다.</target>
        </trans-unit>
        <trans-unit id="f5e952eb46ee9ecbd24ef00bffe49334d2cc3dad" translate="yes" xml:space="preserve">
          <source>This pipes &quot;foo\nbar\n&quot; to the less pager:</source>
          <target state="translated">&quot;foo \ nbar \ n&quot;을 적은 호출기로 파이프합니다.</target>
        </trans-unit>
        <trans-unit id="9ef24b3495020011602b2e6eab8942a1d3d9b7c9" translate="yes" xml:space="preserve">
          <source>This port can also be built on IA64/AMD64 using:</source>
          <target state="translated">이 포트는 다음을 사용하여 IA64 / AMD64에 구축 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca794b2a97ff2f3e9f3ab8b1358dfca57eef50e2" translate="yes" xml:space="preserve">
          <source>This port currently supports MakeMaker (the set of modules that is used to build extensions to perl). Therefore, you should be able to build and install most extensions found in the CPAN sites.</source>
          <target state="translated">이 포트는 현재 MakeMaker (Perl에 대한 확장을 빌드하는 데 사용되는 모듈 세트)를 지원합니다. 따라서 CPAN 사이트에있는 대부분의 확장을 빌드하고 설치할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="da8d54e517da55f89f98bd5f4b007e4f6e30203a" translate="yes" xml:space="preserve">
          <source>This port fully supports MakeMaker (the set of modules that is used to build extensions to perl). Therefore, you should be able to build and install most extensions found in the CPAN sites. See &lt;a href=&quot;#Usage-Hints-for-Perl-on-Windows&quot;&gt;Usage Hints for Perl on Windows&lt;/a&gt; below for general hints about this.</source>
          <target state="translated">이 포트는 MakeMaker (Perl에 대한 확장을 빌드하는 데 사용되는 모듈 세트)를 완벽하게 지원합니다. 따라서 CPAN 사이트에있는 대부분의 확장을 빌드하고 설치할 수 있어야합니다. 이에 대한 일반적인 힌트는 아래의 &lt;a href=&quot;#Usage-Hints-for-Perl-on-Windows&quot;&gt;Windows에서 Perl의 사용법 힌트를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eca5da1d69d15505d5dfe7b2200728b9e2a69857" translate="yes" xml:space="preserve">
          <source>This port of Perl also uses Unix-epoch date values internally. As long as you are dealing with ASCII character string representations of dates, this should not be an issue. The supported epoch is January 1, 1980 to January 17, 2038.</source>
          <target state="translated">이 Perl 포트는 내부적으로 Unix-epoch 날짜 값을 사용합니다. 날짜의 ASCII 문자열 표현을 다루는 한, 이것은 문제가되지 않습니다. 지원되는시기는 1980 년 1 월 1 일부터 2038 년 1 월 17 일까지입니다.</target>
        </trans-unit>
        <trans-unit id="3b59478e1d9adc5bbc9ae74efe6d7c2a8e595477" translate="yes" xml:space="preserve">
          <source>This port of Perl version 5 prefers Unix-style, slash-separated pathnames over OpenVOS-style greater-than-separated pathnames. OpenVOS-style pathnames should work in most contexts, but if you have trouble, replace all greater-than characters by slash characters. Because the slash character is used as a pathname delimiter, Perl cannot process OpenVOS pathnames containing a slash character in a directory or file name; these must be renamed.</source>
          <target state="translated">이 Perl 버전 5 포트는 OpenVOS 스타일보다 큰 경로 이름보다 슬래시로 구분 된 Unix 스타일 경로 이름을 선호합니다. OpenVOS 스타일 경로 이름은 대부분의 컨텍스트에서 작동하지만 문제가 발생하면 큰 문자를 모두 슬래시 문자로 바꾸십시오. 슬래시 문자는 경로 이름 구분 기호로 사용되므로 Perl은 디렉토리 또는 파일 이름에 슬래시 문자가 포함 된 OpenVOS 경로 이름을 처리 할 수 ​​없습니다. 이름을 바꿔야합니다.</target>
        </trans-unit>
        <trans-unit id="5661c31774bac29706eeedad5ca0b82e3ef23fed" translate="yes" xml:space="preserve">
          <source>This port was originally contributed by Gary Ng around 5.003_24, and borrowed from the Hip Communications port that was available at the time. Various people have made numerous and sundry hacks since then.</source>
          <target state="translated">이 포트는 원래 Gary Ng가 5.003_24 경에 기부했으며 당시 사용 가능한 Hip Communications 포트에서 빌 렸습니다. 그 이후로 다양한 사람들이 수많은 해킹 해킹을 해왔습니다.</target>
        </trans-unit>
        <trans-unit id="791faea88ef9fd32067c73f960fb805edbc087f6" translate="yes" xml:space="preserve">
          <source>This port will support dynamic loading, but it is not selected by default. If you would like to experiment with dynamic loading then be sure to specify -Dusedl in the arguments to the Configure script. See the comments in hints/os390.sh for more information on dynamic loading. If you build with dynamic loading then you will need to add the $archlibexp/CORE directory to your LIBPATH environment variable in order for perl to work. See the config.sh file for the value of $archlibexp. If in trying to use Perl you see an error message similar to:</source>
          <target state="translated">이 포트는 동적로드를 지원하지만 기본적으로 선택되어 있지 않습니다. 동적로드를 실험하려면 Configure 스크립트의 인수에 -Dusedl을 지정하십시오. 동적 로딩에 대한 자세한 내용은 hints / os390.sh의 주석을 참조하십시오. 동적 로딩으로 빌드하는 경우 perl이 작동하려면 $ archlibexp / CORE 디렉토리를 LIBPATH 환경 변수에 추가해야합니다. $ archlibexp의 값은 config.sh 파일을 참조하십시오. Perl을 사용하려고하면 다음과 유사한 오류 메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="66e0b9c8e30e0b67210d260345f05889e99ff243" translate="yes" xml:space="preserve">
          <source>This pragma allows overloading of Perl's operators for a class. To overload built-in functions, see &lt;a href=&quot;perlsub#Overriding-Built-in-Functions&quot;&gt;Overriding Built-in Functions in perlsub&lt;/a&gt; instead.</source>
          <target state="translated">이 pragma를 사용하면 클래스에 대한 Perl 연산자를 오버로드 할 수 있습니다. 내장 함수를 오버로드하려면 대신 &lt;a href=&quot;perlsub#Overriding-Built-in-Functions&quot;&gt;perlsub에서 내장&lt;/a&gt; 함수 대체를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca794d61d2dfe5a76e1bb77807f394d0b2d09964" translate="yes" xml:space="preserve">
          <source>This pragma allows you to declare constants at compile-time.</source>
          <target state="translated">이 pragma를 사용하면 컴파일 타임에 상수를 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c01b8b1ad50eec7e989d0f266d4a4fc89f5d88b" translate="yes" xml:space="preserve">
          <source>This pragma allows you to lexically disable or enable overloading.</source>
          <target state="translated">이 pragma를 사용하면 사전에 과부하를 비활성화하거나 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c428d7745a523c21e13cd202bfe44587bda59ff5" translate="yes" xml:space="preserve">
          <source>This pragma also affects encoding of the 0x80..0xFF code point range: normally characters in that range are left as eight-bit bytes (unless they are combined with characters with code points 0x100 or larger, in which case all characters need to become UTF-8 encoded), but if the &lt;code&gt;encoding&lt;/code&gt; pragma is present, even the 0x80..0xFF range always gets UTF-8 encoded.</source>
          <target state="translated">이 pragma는 0x80..0xFF 코드 포인트 범위의 인코딩에도 영향을줍니다. 일반적으로 해당 범위의 문자는 8 비트 바이트로 남습니다 (코드 포인트가 0x100 이상인 문자와 결합되지 않은 경우 모든 문자가 UTF 여야 함) -2) 부호화하지만, 만약 &lt;code&gt;encoding&lt;/code&gt; 래그가 존재조차 0x80..0xFF 범위는 항상 UTF-8 인코딩 얻는다.</target>
        </trans-unit>
        <trans-unit id="cd54481ef89d3dcd2f0d998cbd0de47400ae94c4" translate="yes" xml:space="preserve">
          <source>This pragma arranges for all inputs from files to be translated into Unicode from the current locale as specified in the environment (see &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt;), and all outputs to files to be translated back into the locale. (See &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;). On a per-filehandle basis, you can instead use the &lt;a href=&quot;http://search.cpan.org/perldoc/PerlIO::locale&quot;&gt;PerlIO::locale&lt;/a&gt; module, or the &lt;a href=&quot;http://search.cpan.org/perldoc/Encode::Locale&quot;&gt;Encode::Locale&lt;/a&gt; module, both available from CPAN. The latter module also has methods to ease the handling of &lt;code&gt;ARGV&lt;/code&gt; and environment variables, and can be used on individual strings. If you know that all your locales will be UTF-8, as many are these days, you can use the &lt;a href=&quot;perlrun#-C&quot;&gt;-C&lt;/a&gt; command line switch.</source>
          <target state="translated">이 pragma는 파일의 모든 입력을 환경에 지정된대로 현재 로케일에서 유니 코드로 변환하고 ( &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt; 참조 ) 파일로의 모든 출력을 로케일로 다시 변환하도록 정렬합니다 . ( &lt;a href=&quot;open&quot;&gt;열기&lt;/a&gt; 참조 ). 파일 핸들 단위로 대신 CPAN에서 사용 가능한 &lt;a href=&quot;http://search.cpan.org/perldoc/PerlIO::locale&quot;&gt;PerlIO :: locale&lt;/a&gt; 모듈 또는 &lt;a href=&quot;http://search.cpan.org/perldoc/Encode::Locale&quot;&gt;Encode :: Locale&lt;/a&gt; 모듈을 사용할 수 있습니다. 후자의 모듈에는 &lt;code&gt;ARGV&lt;/code&gt; 및 환경 변수 를 쉽게 처리 할 수있는 방법이 있으며 개별 문자열에서 사용할 수 있습니다. 요즘과 같이 모든 로케일이 UTF-8이된다는 것을 알고 있다면 &lt;a href=&quot;perlrun#-C&quot;&gt;-C&lt;/a&gt; 명령 행 스위치를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="34db7e44f64dc2e33987c7fbd44c07e44789bfa8" translate="yes" xml:space="preserve">
          <source>This pragma dates from the days when UTF-8-enabled editors were uncommon. But that was long ago, and the need for it is greatly diminished. That, coupled with the fact that it doesn't work with threads, along with other problems, (see &lt;a href=&quot;#BUGS&quot;&gt;BUGS&lt;/a&gt;) have led to its being deprecated. It is planned to remove this pragma in a future Perl version. New code should be written in UTF-8, and the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; pragma used instead (see &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt; and &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt; for details). Old code should be converted to UTF-8, via something like the recipe in the &lt;a href=&quot;#SYNOPSIS&quot;&gt;SYNOPSIS&lt;/a&gt; (though this simple approach may require manual adjustments afterwards).</source>
          <target state="translated">이 pragma는 UTF-8 지원 편집기가 흔하지 않은 시절부터 시작되었습니다. 그러나 그것은 오래 전에 이루어졌으며, 그 필요성은 크게 줄어 들었습니다. 그것은 다른 문제와 함께 스레드에서 작동하지 않는다는 사실과 함께 ( &lt;a href=&quot;#BUGS&quot;&gt;BUGS&lt;/a&gt; 참조 ) 더 이상 사용되지 않습니다. 향후 Perl 버전에서이 pragma를 제거 할 계획입니다. 새로운 코드는 UTF-8로 작성되어야하며, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 대신 사용 pragma는 (참조 &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt; 및 &lt;a href=&quot;utf8&quot;&gt;UTF8&lt;/a&gt; 자세한 내용을). &lt;a href=&quot;#SYNOPSIS&quot;&gt;SYNOPSIS&lt;/a&gt; 의 레시피와 같은 방법으로 이전 코드를 UTF-8로 변환해야합니다 (이 간단한 방법은 나중에 수동 조정이 필요할 수 있음).</target>
        </trans-unit>
        <trans-unit id="4adb9dc70f3c9381053e6cf64fee4c07c531fe57" translate="yes" xml:space="preserve">
          <source>This pragma doesn't affect I/O. Nor does it change the internal representation of strings, only their interpretation. There are still several places where Unicode isn't fully supported, such as in filenames.</source>
          <target state="translated">이 pragma는 I / O에 영향을 미치지 않습니다. 또한 문자열의 내부 표현뿐만 아니라 해석 만 변경하지 않습니다. 파일 이름과 같이 유니 코드가 완전히 지원되지 않는 곳이 여전히 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0a1053bcb46765bc08bab8c76c7daf170b6ab41" translate="yes" xml:space="preserve">
          <source>This pragma doesn't work well with &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; because PerlIO does not get along very well with it. When &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; contains non-ASCII characters it prints funny or gets &quot;wide character warnings&quot;. To understand it, try the code below.</source>
          <target state="translated">이 pragma는 PerlIO 와 잘 어울리지 않기 때문에 &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; 하지 않습니다. &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; 에 ASCII가 아닌 문자가 포함되어 있으면 재미있게 인쇄되거나 &quot;와이드 문자 경고&quot;가 표시됩니다. 이해하려면 아래 코드를 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="842309da32a571cffd281160b3136685717f49db" translate="yes" xml:space="preserve">
          <source>This pragma first appeared in Perl v5.8.0. It has been enhanced in later releases as specified above.</source>
          <target state="translated">이 pragma는 Perl v5.8.0에서 처음 등장했습니다. 위에 지정된 이후 릴리스에서 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="ea296547782279e5c0e53a333818543fc8821038" translate="yes" xml:space="preserve">
          <source>This pragma is used to enable a Perl script to be written in encodings that aren't strictly ASCII nor UTF-8. It translates all or portions of the Perl program script from a given encoding into UTF-8, and changes the PerlIO layers of &lt;code&gt;STDIN&lt;/code&gt; and &lt;code&gt;STDOUT&lt;/code&gt; to the encoding specified.</source>
          <target state="translated">이 pragma는 Perl 스크립트를 ASCII 나 UTF-8이 아닌 인코딩으로 작성하는 데 사용됩니다. Perl 프로그램 스크립트의 일부 또는 전부를 주어진 인코딩에서 UTF-8로 변환하고 &lt;code&gt;STDIN&lt;/code&gt; 및 &lt;code&gt;STDOUT&lt;/code&gt; 의 PerlIO 계층을 지정된 인코딩으로 변경 합니다.</target>
        </trans-unit>
        <trans-unit id="b2499dd223fe6da7fc3aa8e53b4286111a638895" translate="yes" xml:space="preserve">
          <source>This pragma lets you switch to the &quot;C3&quot; resolution order. In simple terms, &quot;C3&quot; order ensures that shared parent classes are never searched before child classes, so Perl will now search: &lt;code&gt;Child&lt;/code&gt; , &lt;code&gt;Father&lt;/code&gt; , &lt;code&gt;PaternalGrandparent&lt;/code&gt; , &lt;code&gt;Mother&lt;/code&gt;&lt;code&gt;MaternalGrandparent&lt;/code&gt; , and finally &lt;code&gt;SharedGreatGrandParent&lt;/code&gt; . Note however that this is not &quot;breadth-first&quot; searching: All the &lt;code&gt;Father&lt;/code&gt; ancestors (except the common ancestor) are searched before any of the &lt;code&gt;Mother&lt;/code&gt; ancestors are considered.</source>
          <target state="translated">이 pragma를 사용하면 &quot;C3&quot;해상도 순서로 전환 할 수 있습니다. 간단히 말하면, &quot;C3&quot;순서는 공유 상위 클래스가 하위 클래스보다 먼저 검색되지 않도록하기 때문에 Perl은 이제 &lt;code&gt;Child&lt;/code&gt; , &lt;code&gt;Father&lt;/code&gt; , &lt;code&gt;PaternalGrandparent&lt;/code&gt; , &lt;code&gt;Mother&lt;/code&gt; &lt;code&gt;MaternalGrandparent&lt;/code&gt; 및 마지막으로 &lt;code&gt;SharedGreatGrandParent&lt;/code&gt; 를 검색 합니다. 모든이가 &quot;폭 우선&quot;검색 아니라고하지만 참고 &lt;code&gt;Father&lt;/code&gt; 의 모든 먼저 검색된다 (공통 조상 제외) 조상 &lt;code&gt;Mother&lt;/code&gt; 조상으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="2063e0ed31e4ca83c59af99843b134e51c1d67ca" translate="yes" xml:space="preserve">
          <source>This pragma reflects early attempts to incorporate Unicode into perl and has since been superseded. It breaks encapsulation (i.e. it exposes the innards of how the perl executable currently happens to store a string), and use of this module for anything other than debugging purposes is strongly discouraged. If you feel that the functions here within might be useful for your application, this possibly indicates a mismatch between your mental model of Perl Unicode and the current reality. In that case, you may wish to read some of the perl Unicode documentation: &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;, &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt;, &lt;a href=&quot;perlunifaq&quot;&gt;perlunifaq&lt;/a&gt; and &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;.</source>
          <target state="translated">이 pragma는 유니 코드를 펄에 통합하려는 초기의 시도를 반영하며 이후 대체되었습니다. 캡슐화를 중단합니다 (즉, 현재 perl 실행 파일이 문자열을 저장하는 방식의 내부를 노출). 디버깅 이외의 용도로이 모듈을 사용하지 않는 것이 좋습니다. 여기에있는 함수가 응용 프로그램에 유용하다고 생각되면 Perl Unicode의 정신 모델과 현재 현실이 일치하지 않을 수 있습니다. 이 경우, &lt;a href=&quot;perluniintro&quot;&gt;perlniintro&lt;/a&gt; , &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; , &lt;a href=&quot;perlunifaq&quot;&gt;perlunifaq&lt;/a&gt; 및 &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; 와 같은 perl Unicode 문서 중 일부를 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2ef074ee97cc67ce380e960a125c4b931d1340ce" translate="yes" xml:space="preserve">
          <source>This pragma tells the compiler to change the behaviour of the filetest permission operators, &lt;code&gt;-r&lt;/code&gt;&lt;code&gt;-w&lt;/code&gt;&lt;code&gt;-x&lt;/code&gt;&lt;code&gt;-R&lt;/code&gt;&lt;code&gt;-W&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; (see &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;).</source>
          <target state="translated">이 pragma는 파일 테스트 권한 연산자 &lt;code&gt;-r&lt;/code&gt; &lt;code&gt;-w&lt;/code&gt; &lt;code&gt;-x&lt;/code&gt; &lt;code&gt;-R&lt;/code&gt; &lt;code&gt;-W&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; 의 동작을 변경하도록 컴파일러에 지시합니다 ( &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="221ed9ae1b0c79e2438890e0d6c973d357078c4b" translate="yes" xml:space="preserve">
          <source>This pragma tells the compiler to enable (or disable) the use of POSIX locales for built-in operations (for example, LC_CTYPE for regular expressions, LC_COLLATE for string comparison, and LC_NUMERIC for number formatting). Each &quot;use locale&quot; or &quot;no locale&quot; affects statements to the end of the enclosing BLOCK.</source>
          <target state="translated">이 pragma는 내장 연산에 POSIX 로케일 사용을 활성화 (또는 비활성화)하도록 컴파일러에 지시합니다 (예 : 정규식의 경우 LC_CTYPE, 문자열 비교의 경우 LC_COLLATE, 숫자 형식의 경우 LC_NUMERIC). 각각의 &quot;사용 로케일&quot;또는 &quot;로케일 없음&quot;은 묶는 BLOCK의 끝에 대한 명령문에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="e609830a837e5307b3fb39be2d58dc9501e3994d" translate="yes" xml:space="preserve">
          <source>This pragma was created so you can explicitly tell Perl that operations executed within its scope are to use Unicode rules. More operations are affected with newer perls. See &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;The Unicode Bug&lt;/a&gt;.</source>
          <target state="translated">이 pragma는 해당 범위 내에서 실행되는 작업이 유니 코드 규칙을 사용한다는 것을 Perl에 명시 적으로 알릴 수 있도록 만들어졌습니다. 더 많은 작업이 새로운 perls의 영향을받습니다. &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;유니 코드 버그를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="700e6f2388b406cbe201cbb98323ed5f25c8d4b4" translate="yes" xml:space="preserve">
          <source>This pragma works just like the &lt;code&gt;strict&lt;/code&gt; pragma. This means that the scope of the warning pragma is limited to the enclosing block. It also means that the pragma setting will not leak across files (via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;). This allows authors to independently define the degree of warning checks that will be applied to their module.</source>
          <target state="translated">이 pragma는 &lt;code&gt;strict&lt;/code&gt; pragma 처럼 작동합니다 . 이는 경고 pragma의 범위가 둘러싸는 블록으로 제한됨을 의미합니다. 또한 pragma 설정이 파일 전체에서 누출되지 않습니다 ( &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 사용 ). 이를 통해 작성자는 모듈에 적용될 경고 확인 정도를 독립적으로 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30a2879d5d48273acab2ab3a9f22c1edf08032e3" translate="yes" xml:space="preserve">
          <source>This prints</source>
          <target state="translated">이것은 인쇄</target>
        </trans-unit>
        <trans-unit id="b6e212e7ef6ac1844cda369639e0440d069cad8b" translate="yes" xml:space="preserve">
          <source>This prints &quot;bar&quot; and writes &quot;foo&quot; into the file &quot;blurch&quot;:</source>
          <target state="translated">&quot;bar&quot;를 인쇄하고 &quot;blurch&quot;파일에 &quot;foo&quot;를 씁니다.</target>
        </trans-unit>
        <trans-unit id="d54bfbbae93113b4950fc2d869fb4754b9ce7e99" translate="yes" xml:space="preserve">
          <source>This prints &quot;bar&quot; and writes &quot;foo&quot; to the file &quot;blurch&quot;:</source>
          <target state="translated">&quot;bar&quot;를 인쇄하고 &quot;blurch&quot;파일에 &quot;foo&quot;를 씁니다.</target>
        </trans-unit>
        <trans-unit id="efd4b33e8216cea60a6219dc7e5bd98ac5e87040" translate="yes" xml:space="preserve">
          <source>This prints &quot;foo&quot; (&quot;bar&quot; disappears into nowhereland):</source>
          <target state="translated">이것은 &quot;foo&quot;를 출력합니다 ( &quot;bar&quot;는 아무데도 사라집니다) :</target>
        </trans-unit>
        <trans-unit id="41ff0d603c865bec8366dedecbae0223cb1c3622" translate="yes" xml:space="preserve">
          <source>This prints &lt;code&gt;2.7&lt;/code&gt; .</source>
          <target state="translated">이것은 &lt;code&gt;2.7&lt;/code&gt; 을 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="bb91200cd90a472a1ae9cb007ac03043f56be426" translate="yes" xml:space="preserve">
          <source>This prints out the name and version of all modules used and then exits.</source>
          <target state="translated">사용 된 모든 모듈의 이름과 버전이 인쇄되고 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="f686232da2ac609974851dce432c4e1340ec7365" translate="yes" xml:space="preserve">
          <source>This prints out your environment like the printenv(1) program, but in a different order:</source>
          <target state="translated">이것은 printenv (1) 프로그램과 같은 환경을 다른 순서로 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="04d447d63dbf460d4723e288297a46d354df3e2a" translate="yes" xml:space="preserve">
          <source>This prints two doublequotes:</source>
          <target state="translated">이렇게하면 큰 따옴표 두 개가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="345205710c1209079bdf05b4d146f25fe0a01f36" translate="yes" xml:space="preserve">
          <source>This prints:</source>
          <target state="translated">인쇄합니다 :</target>
        </trans-unit>
        <trans-unit id="d21d1db17e4be9e2f5e50a54879f0a7c98d4455f" translate="yes" xml:space="preserve">
          <source>This probably isn't as useful as you might think. Normally, you shouldn't need to.</source>
          <target state="translated">이것은 아마도 생각만큼 유용하지 않습니다. 일반적으로 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="341bfd19674c6dfeba3ffe584bfdf82c2776cb1e" translate="yes" xml:space="preserve">
          <source>This probably makes more sense for a human: enter a block, start a statement. Get the values of &lt;code&gt;$b&lt;/code&gt; and &lt;code&gt;$c&lt;/code&gt; , and add them together. Find &lt;code&gt;$a&lt;/code&gt; , and assign one to the other. Then leave.</source>
          <target state="translated">이것은 아마도 인간에게 더 의미가 있습니다. 블록을 입력하고 진술을 시작하십시오. &lt;code&gt;$b&lt;/code&gt; 및 &lt;code&gt;$c&lt;/code&gt; 의 값을 가져와 함께 더하십시오. &lt;code&gt;$a&lt;/code&gt; 찾아서 다른 것을 할당하십시오. 그런 다음 떠나십시오.</target>
        </trans-unit>
        <trans-unit id="d9d98988085b44026120bb435150bffabf68b9c3" translate="yes" xml:space="preserve">
          <source>This probably sounds a bit more confusing than it really is, so let's go through this program piece by piece and see what it does. (For those of you who might be trying to remember exactly what a prime number is, it's a number that's only evenly divisible by itself and 1.)</source>
          <target state="translated">이것은 아마도 실제보다 약간 더 혼란스럽게 들릴 것이므로이 프로그램을 하나씩 살펴보고 그것이 무엇을하는지 봅시다. (소수를 정확히 기억하려고하는 사람들에게는 그 자체로 1과 균등하게 나눌 수있는 숫자입니다.)</target>
        </trans-unit>
        <trans-unit id="e016023303c59d801c6e740a285fec3afa4a6473" translate="yes" xml:space="preserve">
          <source>This problem can usually be solved by making the inner subroutine anonymous, using the &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; syntax. When inner anonymous subs that reference lexical subroutines in outer subroutines are created, they are automatically rebound to the current values of such lexical subs.</source>
          <target state="translated">이 문제는 일반적으로 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; 구문을 사용하여 내부 서브 루틴을 익명으로 만들어 해결할 수 있습니다 . 외부 서브 루틴에서 어휘 서브 루틴을 참조하는 내부 익명 서브가 작성되면 자동으로 해당 어휘 서브의 현재 값으로 리바운드됩니다.</target>
        </trans-unit>
        <trans-unit id="b60e9bed0f73061b937a8fe5fecd9ad0d49454e0" translate="yes" xml:space="preserve">
          <source>This problem can usually be solved by making the inner subroutine anonymous, using the &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; syntax. When inner anonymous subs that reference variables in outer subroutines are created, they are automatically rebound to the current values of such variables.</source>
          <target state="translated">이 문제는 일반적으로 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; 구문을 사용하여 내부 서브 루틴을 익명으로 만들어 해결할 수 있습니다 . 외부 서브 루틴에서 변수를 참조하는 내부 익명 서브가 작성되면 자동으로 해당 변수의 현재 값으로 리바운드됩니다.</target>
        </trans-unit>
        <trans-unit id="30e5c26de90551718f152502391c103ab788e07b" translate="yes" xml:space="preserve">
          <source>This problem usually involves one of the Perl built-ins that has the same name a Unix command that uses octal numbers as arguments on the command line. In this example, &lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod&lt;/a&gt;&lt;/code&gt; on the command line knows that its first argument is octal because that's what it does:</source>
          <target state="translated">이 문제는 일반적으로 명령 행에서 8 진 숫자를 인수로 사용하는 Unix 명령과 동일한 이름을 가진 Perl 내장 중 하나를 포함합니다. 이 예제 에서 명령 행의 &lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod&lt;/a&gt;&lt;/code&gt; 는 첫 번째 인수가 8 진임을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="78b6c2ab73ee787f434ee0ce1c24dc74fd9f5055" translate="yes" xml:space="preserve">
          <source>This problem was fixed in perl 5.004_05, so preventing it means upgrading your version of perl. ;)</source>
          <target state="translated">이 문제는 perl 5.004_05에서 수정되었으므로이를 방지하는 것은 perl 버전을 업그레이드하는 것을 의미합니다. ;)</target>
        </trans-unit>
        <trans-unit id="149ef363e988711abf3a930d8381275df0baf405" translate="yes" xml:space="preserve">
          <source>This processes the lines in &lt;code&gt;@lines&lt;/code&gt; (where each list item must be a defined value, and must contain exactly one line of content -- so no items like &lt;code&gt;&quot;foo\nbar&quot;&lt;/code&gt; are allowed). The final &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is used to indicate the end of document being parsed.</source>
          <target state="translated">이것은 &lt;code&gt;@lines&lt;/code&gt; 행을 처리합니다. 여기서 각 목록 항목은 정의 된 값이어야하며 정확히 한 줄의 내용을 포함해야합니다. 따라서 &lt;code&gt;&quot;foo\nbar&quot;&lt;/code&gt; 와 같은 항목 은 허용되지 않습니다. 최종 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 는 파싱되는 문서의 끝을 나타내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6c20dce79362eb3c48b58c8e5bc86aad6133c323" translate="yes" xml:space="preserve">
          <source>This produces a patch based on the difference between blead and your current branch. It's important to make sure that blead is up to date before producing the diff, that's why we call &lt;code&gt;git pull&lt;/code&gt; first.</source>
          <target state="translated">이것은 블리드와 현재 브랜치의 차이를 기반으로 패치를 생성합니다. diff를 생성하기 전에 블리드가 최신 상태인지 확인하는 것이 중요 &lt;code&gt;git pull&lt;/code&gt; 먼저 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="5a3bf030e7bf490188072c702d468c0925c814bb" translate="yes" xml:space="preserve">
          <source>This produces the Perl docs online book &lt;code&gt;perl.INF&lt;/code&gt; . Install in on &lt;code&gt;BOOKSHELF&lt;/code&gt; path.</source>
          <target state="translated">이것은 Perl docs 온라인 서적 &lt;code&gt;perl.INF&lt;/code&gt; 를 생성합니다 . &lt;code&gt;BOOKSHELF&lt;/code&gt; 경로 에 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="2c9c734dac073d3001ca1ea5f8fa8cfb8daa173b" translate="yes" xml:space="preserve">
          <source>This program is Copyright 1990,2015 by Johan Vromans. This program is free software; you can redistribute it and/or modify it under the terms of the Perl Artistic License or the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.</source>
          <target state="translated">이 프로그램은 Johan Vromans의 저작권 1990,2015입니다. 이 프로그램은 무료 소프트웨어입니다. 자유 소프트웨어 재단이 출판 한 Perl Artistic License 또는 GNU General Public License의 조항에 따라 재배포 및 / 또는 수정할 수 있습니다. 라이센스 버전 2 또는 (선택에 따라) 이후 버전.</target>
        </trans-unit>
        <trans-unit id="26f7f8dba51ed564d4c376a299ad1ccb7d59f62d" translate="yes" xml:space="preserve">
          <source>This program is designed to help you generate and send bug reports (and thank-you notes) about perl5 and the modules which ship with it.</source>
          <target state="translated">이 프로그램은 perl5와 함께 제공되는 모듈에 대한 버그 보고서 (및 감사 노트)를 생성하고 보내는 데 도움이되도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="2cac2059d04ed459899445fb7d4adafed92ceb31" translate="yes" xml:space="preserve">
          <source>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</source>
          <target state="translated">이 프로그램은 유용 할 것이라는 희망으로 배포되었지만 어떠한 보증도하지 않습니다. 상품성 또는 특정 목적에의 적합성에 대한 묵시적 보증조차 포함하지 않습니다. 자세한 내용은 GNU General Public License를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d8761e66f0aa0865d7b8a0fad53a385acc12de1d" translate="yes" xml:space="preserve">
          <source>This program is distributed in the hope that it will be useful, but without any warranty; without even the implied warranty of merchantability or fitness for a particular purpose.</source>
          <target state="translated">이 프로그램은 유용하지만 보증없이 희망에 따라 배포됩니다. 상업성이나 특정 목적에의 적합성에 대한 묵시적 보증없이.</target>
        </trans-unit>
        <trans-unit id="2b736eab48b8800afefb519e32bdf619448f2254" translate="yes" xml:space="preserve">
          <source>This program is distributed under the Artistic License.</source>
          <target state="translated">이 프로그램은 예술 라이센스에 따라 배포됩니다.</target>
        </trans-unit>
        <trans-unit id="d1d0a6a12423ce6569360d8955fb54c14fc9d18b" translate="yes" xml:space="preserve">
          <source>This program is distributed under the same terms as perl itself. See &lt;a href=&quot;http://perl.org/&quot;&gt;http://perl.org/&lt;/a&gt; or &lt;a href=&quot;http://cpan.org/&quot;&gt;http://cpan.org/&lt;/a&gt; for more info on that.</source>
          <target state="translated">이 프로그램은 perl 자체와 동일한 용어로 배포됩니다. 이에 대한 자세한 내용은 &lt;a href=&quot;http://perl.org/&quot;&gt;http://perl.org/&lt;/a&gt; 또는 &lt;a href=&quot;http://cpan.org/&quot;&gt;http://cpan.org/&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c09da468beec666c3faa34069fc9e34aec608126" translate="yes" xml:space="preserve">
          <source>This program is easy to understand. &lt;code&gt;#!/usr/bin/perl&lt;/code&gt; is the standard way to invoke a perl program from the shell. &lt;code&gt;$regexp = &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;;&lt;/code&gt; saves the first command line argument as the regexp to be used, leaving the rest of the command line arguments to be treated as files. &lt;code&gt;while (&amp;lt;&amp;gt;)&lt;/code&gt; loops over all the lines in all the files. For each line, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; if /$regexp/;&lt;/code&gt; prints the line if the regexp matches the line. In this line, both &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;/$regexp/&lt;/code&gt; use the default variable &lt;code&gt;$_&lt;/code&gt; implicitly.</source>
          <target state="translated">이 프로그램은 이해하기 쉽습니다. &lt;code&gt;#!/usr/bin/perl&lt;/code&gt; 은 쉘에서 perl 프로그램을 호출하는 표준 방법입니다. &lt;code&gt;$regexp = &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;;&lt;/code&gt; 첫 번째 명령 줄 인수를 사용할 정규 표현식으로 저장하고 나머지 명령 줄 인수는 파일로 처리합니다. &lt;code&gt;while (&amp;lt;&amp;gt;)&lt;/code&gt; 는 모든 파일의 모든 줄을 반복합니다. 각 라인의 경우, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; if /$regexp/;&lt;/code&gt; 정규 표현식이 줄과 일치하면 줄을 인쇄합니다. 이 줄에서 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;/$regexp/&lt;/code&gt; 는 기본 변수 &lt;code&gt;$_&lt;/code&gt; 암시 적 으로 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="b3f9820f4fcf840eefdc1fac524d68220274e583" translate="yes" xml:space="preserve">
          <source>This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself</source>
          <target state="translated">이 프로그램은 무료 소프트웨어입니다. Perl과 동일한 용어로 재배포 및 / 또는 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46aefc944a8368be1c5041bb6eeeeb6f411fe967" translate="yes" xml:space="preserve">
          <source>This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">이 프로그램은 무료 소프트웨어입니다. Perl과 동일한 용어로 재배포 및 / 또는 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eda486acda27bdf9cd66949e1266b5a78cb661d8" translate="yes" xml:space="preserve">
          <source>This program is free software; you may redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">이 프로그램은 무료 소프트웨어입니다. Perl 자체와 동일한 용어로 재배포 및 / 또는 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49a9ebce432bc6f7a5abfa1673ae23d082772d50" translate="yes" xml:space="preserve">
          <source>This program is maintained by the Perl 5 Porters. The CPAN distribution is maintained by S&amp;eacute;bastien Aperghis-Tramoni &amp;lt;</source>
          <target state="translated">이 프로그램은 Perl 5 Porter가 관리합니다. CPAN 배포는 S&amp;eacute;bastien Aperghis-Tramoni &amp;lt;</target>
        </trans-unit>
        <trans-unit id="d98f469a4bef1492cbd51567cf72d3226f5fb0a1" translate="yes" xml:space="preserve">
          <source>This program provides an easy way to send a thank-you message back to the authors and maintainers of perl. It's just</source>
          <target state="translated">이 프로그램은 perl의 저자와 관리자에게 감사의 메시지를 쉽게 보낼 수있는 방법을 제공합니다. 그냥</target>
        </trans-unit>
        <trans-unit id="474e6c18a35ba4d4e6ef7db0a92aa1f2c8019fc7" translate="yes" xml:space="preserve">
          <source>This program uses the pipeline model to generate prime numbers. Each thread in the pipeline has an input queue that feeds numbers to be checked, a prime number that it's responsible for, and an output queue into which it funnels numbers that have failed the check. If the thread has a number that's failed its check and there's no child thread, then the thread must have found a new prime number. In that case, a new child thread is created for that prime and stuck on the end of the pipeline.</source>
          <target state="translated">이 프로그램은 파이프 라인 모델을 사용하여 소수를 생성합니다. 파이프 라인의 각 스레드에는 검사 할 숫자를 제공하는 입력 큐, 담당하는 소수 및 검사에 실패한 숫자를 퍼널 링하는 출력 큐가 있습니다. 스레드에 검사에 실패한 숫자가 있고 하위 스레드가없는 경우 스레드가 새로운 소수를 찾은 것입니다. 이 경우 해당 프라임에 대해 새 하위 스레드가 작성되고 파이프 라인 끝에 붙어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bd07d758efadc42857a5a0bab51cd8a077edefd" translate="yes" xml:space="preserve">
          <source>This program will print only the line containing &quot;Bar&quot;. If the range operator is changed to &lt;code&gt;...&lt;/code&gt; , it will also print the &quot;Baz&quot; line.</source>
          <target state="translated">이 프로그램은 &quot;Bar&quot;가 포함 된 줄만 인쇄합니다. 범위 연산자가 &lt;code&gt;...&lt;/code&gt; 로 변경 되면 &quot;Baz&quot;줄도 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="f91a32c34a450fa3aaeea5e09b4bf9753a0de2ef" translate="yes" xml:space="preserve">
          <source>This program will probably hang until you kill it. The only way it won't hang is if one of the two threads acquires both locks first. A guaranteed-to-hang version is more complicated, but the principle is the same.</source>
          <target state="translated">이 프로그램은 당신이 죽일 때까지 중단 될 것입니다. 중단되지 않는 유일한 방법은 두 스레드 중 하나가 두 잠금을 먼저 획득하는 것입니다. 매달린 버전은 더 복잡하지만 원칙은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="5342717fe0bceba26cbcb8fb4ec4c851e52a537d" translate="yes" xml:space="preserve">
          <source>This project was originated by the late Nick Ing-Simmons and later maintained by Dan Kogai</source>
          <target state="translated">이 프로젝트는 Nick Ing-Simmons 말기에서 시작되었으며 나중에 Dan Kogai가 관리합니다.</target>
        </trans-unit>
        <trans-unit id="d353efbbda92520a2429ad4f8535f649667e5952" translate="yes" xml:space="preserve">
          <source>This property is always written in the compound form. For example, &lt;code&gt;\p{Bidi_Class:R}&lt;/code&gt; matches characters that are normally written right to left. Unlike the &lt;code&gt;&lt;a href=&quot;#General_Category&quot;&gt;General_Category&lt;/a&gt;&lt;/code&gt; property, this property can have more values added in a future Unicode release. Those listed above comprised the complete set for many Unicode releases, but others were added in Unicode 6.3; you can always find what the current ones are in in &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;. And &lt;a href=&quot;http://www.unicode.org/reports/tr9/&quot;&gt;http://www.unicode.org/reports/tr9/&lt;/a&gt; describes how to use them.</source>
          <target state="translated">이 속성은 항상 복합 형식으로 작성됩니다. 예를 들어, &lt;code&gt;\p{Bidi_Class:R}&lt;/code&gt; 은 일반적으로 오른쪽에서 왼쪽으로 쓰는 문자와 일치합니다. &lt;code&gt;&lt;a href=&quot;#General_Category&quot;&gt;General_Category&lt;/a&gt;&lt;/code&gt; 속성 과 달리이 속성은 향후 유니 코드 릴리스에서 더 많은 값을 추가 할 수 있습니다. 위에 나열된 것들은 많은 유니 코드 릴리스에 대한 완전한 세트로 구성되었지만 다른 것들은 유니 코드 6.3에 추가되었습니다. 당신은 항상 &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt; 에있는 것들을 찾을 수 있습니다 . 그리고 &lt;a href=&quot;http://www.unicode.org/reports/tr9/&quot;&gt;http://www.unicode.org/reports/tr9/&lt;/a&gt; 는 그것들을 사용하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="9d34b69b565209c628e5e765cbc6639e949afb7e" translate="yes" xml:space="preserve">
          <source>This property is used when you need to know in what Unicode version(s) a character is.</source>
          <target state="translated">이 속성은 문자가 어떤 유니 코드 버전인지 알아야 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ba740c0026c45f2093377326c9e21d5c765b2b70" translate="yes" xml:space="preserve">
          <source>This provides access to most of the Win32 GUI widgets from Perl. Obviously, it only runs under Win32, and uses native widgets. The Perl interface doesn't really follow the C interface: it's been made more Perlish, and the documentation is pretty good. More advanced stuff may require familiarity with the C Win32 APIs, or reference to MSDN.</source>
          <target state="translated">이를 통해 Perl에서 대부분의 Win32 GUI 위젯에 액세스 할 수 있습니다. 분명히 Win32에서만 실행되며 기본 위젯을 사용합니다. Perl 인터페이스는 실제로 C 인터페이스를 따르지 않습니다. 더 Perlish로 만들어졌으며 문서는 꽤 좋습니다. 고급 기능을 사용하려면 C Win32 API에 익숙하거나 MSDN을 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="05ed7360b5662052cf8df531a4821820675f5a90" translate="yes" xml:space="preserve">
          <source>This provides an alternate means to specify function names to be exported from the extension. Its value is a reference to an array of function names to be exported by the extension. These names are passed through unaltered to the linker options file.</source>
          <target state="translated">이는 확장에서 내보낼 함수 이름을 지정하는 대체 수단을 제공합니다. 이 값은 확장 프로그램에서 내보낼 함수 이름 배열에 대한 참조입니다. 이러한 이름은 변경되지 않은 상태로 링커 옵션 파일로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="b6d4501c0d8df55386bc41a04cfb00e365ded86e" translate="yes" xml:space="preserve">
          <source>This provides an alternate means to specify function names to be exported from the extension. Its value is a reference to an array of function names to be exported by the extension. These names are passed through unaltered to the linker options file. Specifying a value for the FUNCLIST attribute suppresses automatic generation of the bootstrap function for the package. To still create the bootstrap name you have to specify the package name in the DL_FUNCS hash:</source>
          <target state="translated">이는 확장에서 내보낼 함수 이름을 지정하는 대체 수단을 제공합니다. 이 값은 확장 프로그램에서 내보낼 함수 이름 배열에 대한 참조입니다. 이러한 이름은 변경되지 않은 상태로 링커 옵션 파일로 전달됩니다. FUNCLIST 속성 값을 지정하면 패키지에 대한 부트 스트랩 기능의 자동 생성이 억제됩니다. 부트 스트랩 이름을 계속 작성하려면 DL_FUNCS 해시에서 패키지 이름을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="e5949eb8258f363515432b75a3130bd3950de7ae" translate="yes" xml:space="preserve">
          <source>This provides console orientated output formatting for &lt;a href=&quot;../../harness&quot;&gt;TAP::Harness&lt;/a&gt; when run with multiple &lt;a href=&quot;../../harness#jobs&quot;&gt;jobs in TAP::Harness&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;../../harness&quot;&gt;TAP :: Harness &lt;/a&gt;&lt;a href=&quot;../../harness#jobs&quot;&gt;에서&lt;/a&gt; 여러 작업으로 실행될 때 TAP :: Harness에 대한 콘솔 지향 출력 형식을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="9181d13c6755b2d2d5fcc68549a86008e0459f52" translate="yes" xml:space="preserve">
          <source>This provides console orientated output formatting for TAP::Harness.</source>
          <target state="translated">TAP :: Harness에 대한 콘솔 지향 출력 형식을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d034d371e8adbdcae6dcc8b5f1035f643b009166" translate="yes" xml:space="preserve">
          <source>This provides file orientated output formatting for &lt;a href=&quot;../../harness&quot;&gt;TAP::Harness&lt;/a&gt;. It is particularly important when running with parallel tests, as it ensures that test results are not interleaved, even when run verbosely.</source>
          <target state="translated">&lt;a href=&quot;../../harness&quot;&gt;TAP :: Harness에&lt;/a&gt; 대한 파일 지향 출력 형식을 제공합니다 . 병렬 테스트를 실행할 때는 특히 중요하지만 테스트 결과가 인터리브되지 않도록 보장하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="be3613f62ba727bb8044f064f871c5a2ffe96d89" translate="yes" xml:space="preserve">
          <source>This provides file orientated output formatting for TAP::Harness.</source>
          <target state="translated">TAP :: Harness에 대한 파일 지향 출력 형식을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e79f6eddf4d757dda9eee150d598652b5e165fe6" translate="yes" xml:space="preserve">
          <source>This provides the &lt;code&gt;&lt;a href=&quot;functions/__sub__&quot;&gt;__SUB__&lt;/a&gt;&lt;/code&gt; token that returns a reference to the current subroutine or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; outside of a subroutine.</source>
          <target state="translated">이것은 현재 서브 루틴에 대한 참조를 리턴하거나 서브 루틴 외부의 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 리턴하는 &lt;code&gt;&lt;a href=&quot;functions/__sub__&quot;&gt;__SUB__&lt;/a&gt;&lt;/code&gt; 토큰을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="224c6e548e4884dfbdfe2ac071bf15dda7c825fc" translate="yes" xml:space="preserve">
          <source>This puts the executables in f:/perllib/bin. Manually move them to the &lt;code&gt;PATH&lt;/code&gt; , manually move the built</source>
          <target state="translated">실행 파일은 f : / perllib / bin에 저장됩니다. 수동으로 &lt;code&gt;PATH&lt;/code&gt; 로 옮기고 빌드 된 것을 수동으로 움직입니다.</target>
        </trans-unit>
        <trans-unit id="d9a0cac7b723579ba6e539b4576a4997c5b49e8f" translate="yes" xml:space="preserve">
          <source>This read-only variable contains a reference to the last-read filehandle. This is set by &lt;code&gt;&amp;lt;HANDLE&amp;gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;. This is the same handle that &lt;code&gt;$.&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; without arguments use. It is also the handle used when Perl appends &quot;, &amp;lt;STDIN&amp;gt; line 1&quot; to an error or warning message.</source>
          <target state="translated">이 읽기 전용 변수에는 마지막으로 읽은 파일 핸들에 대한 참조가 포함됩니다. 이것은 &lt;code&gt;&amp;lt;HANDLE&amp;gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 로 설정 됩니다. 이것은 &lt;code&gt;$.&lt;/code&gt; 와 같은 핸들입니다 . 그리고 &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 인수를 사용하지 않고. 또한 Perl이 &quot;, &amp;lt;STDIN&amp;gt; line 1&quot;을 오류 또는 경고 메시지에 추가 할 때 사용되는 핸들입니다.</target>
        </trans-unit>
        <trans-unit id="2e9c374af25573cbb8a011c91df0b5de175403d9" translate="yes" xml:space="preserve">
          <source>This reads the Pod content of the file (or filehandle) that you specify, and processes it with that &lt;code&gt;$parser&lt;/code&gt; object, according to however &lt;code&gt;$parser&lt;/code&gt; 's class works, and according to whatever parser options you have set up for this &lt;code&gt;$parser&lt;/code&gt; object.</source>
          <target state="translated">이것은 사용자가 지정하는 파일 (또는 핸들)의 포드 내용을 읽고, 그와 함께 처리 &lt;code&gt;$parser&lt;/code&gt; 객체, 그러나에 따라 &lt;code&gt;$parser&lt;/code&gt; 클래스 작품의, 그리고 당신이에 설정 한 어떤 파서 옵션에 따라 &lt;code&gt;$parser&lt;/code&gt; 객체 .</target>
        </trans-unit>
        <trans-unit id="c31dda74f7214f2c1e1f0e262ad534c6710776eb" translate="yes" xml:space="preserve">
          <source>This regex from Benjamin Goldberg will add commas to numbers:</source>
          <target state="translated">Benjamin Goldberg 의이 정규식은 숫자에 쉼표를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="ba5402a82ba706913f690e8b3975f67ccd9cac88" translate="yes" xml:space="preserve">
          <source>This regexp displays a common task: perform a case-insensitive match. Perl provides a way of avoiding all those brackets by simply appending an &lt;code&gt;'i'&lt;/code&gt; to the end of the match. Then &lt;code&gt;/[yY][eE][sS]/;&lt;/code&gt; can be rewritten as &lt;code&gt;/yes/i;&lt;/code&gt; . The &lt;code&gt;'i'&lt;/code&gt; stands for case-insensitive and is an example of a</source>
          <target state="translated">이 정규식은 일반적인 작업을 표시합니다. 대소 문자를 구분하지 않습니다. 펄은 경기의 끝에 &lt;code&gt;'i'&lt;/code&gt; 를 추가하여 모든 대괄호를 피하는 방법을 제공합니다 . 그런 다음 &lt;code&gt;/[yY][eE][sS]/;&lt;/code&gt; &lt;code&gt;/yes/i;&lt;/code&gt; 로 다시 쓸 수 있습니다 . . 는 &lt;code&gt;'i'&lt;/code&gt; 대소 문자 구별 약자와의 예</target>
        </trans-unit>
        <trans-unit id="f039b2c10f0c743bc7161531bc5bb4ee7cf32e0f" translate="yes" xml:space="preserve">
          <source>This regexp matches at the earliest string position, &lt;code&gt;'T'&lt;/code&gt; . One might think that &lt;code&gt;e&lt;/code&gt; , being leftmost in the alternation, would be matched, but &lt;code&gt;r&lt;/code&gt; produces the longest string in the first quantifier.</source>
          <target state="translated">이 정규 표현식은 가장 빠른 문자열 위치 &lt;code&gt;'T'&lt;/code&gt; 에서 일치합니다 . 교대에서 가장 왼쪽에있는 &lt;code&gt;e&lt;/code&gt; 가 일치 한다고 생각할 수도 있지만 &lt;code&gt;r&lt;/code&gt; 은 첫 번째 수량 자에서 가장 긴 문자열을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a7d61ce1428d48124b4e47e558b037fdd3f04877" translate="yes" xml:space="preserve">
          <source>This registers warning categories for the given names and is primarily for use by the warnings::register pragma.</source>
          <target state="translated">지정된 이름에 대한 경고 범주를 등록하며 주로 warnings :: register pragma에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ac7da667100d67a773306ce2d3526ac0aaefa222" translate="yes" xml:space="preserve">
          <source>This release (5.14) uses &lt;code&gt;unix&lt;/code&gt; as the bottom layer on Win32, and so still uses the C compiler's numeric file descriptor routines. There is an experimental native &lt;code&gt;win32&lt;/code&gt; layer, which is expected to be enhanced and should eventually become the default under Win32.</source>
          <target state="translated">이 릴리스 (5.14)는 &lt;code&gt;unix&lt;/code&gt; 를 Win32의 최하위 계층으로 사용하므로 여전히 C 컴파일러의 숫자 파일 디스크립터 루틴을 사용합니다. 실험적인 기본 &lt;code&gt;win32&lt;/code&gt; 레이어가 있으며 이는 향상 될 것으로 예상되며 결국 Win32에서 기본값이되어야합니다.</target>
        </trans-unit>
        <trans-unit id="08e93ba339b839f549405138c86c3e7a085e38a6" translate="yes" xml:space="preserve">
          <source>This release of Storable can be used on a newer version of Perl to serialize data which is not supported by earlier Perls. By default, Storable will attempt to do the right thing, by &lt;code&gt;croak()&lt;/code&gt; ing if it encounters data that it cannot deserialize. However, the defaults can be changed as follows:</source>
          <target state="translated">이 Storable 릴리스는 최신 Perl 버전에서 사용되어 이전 Perls에서 지원하지 않는 데이터를 직렬화 할 수 있습니다. 기본적으로 Storable은 deserialize 할 수없는 데이터가 발견되면 &lt;code&gt;croak()&lt;/code&gt; 하여 올바른 작업을 시도합니다 . 그러나 기본값은 다음과 같이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d1b77b3467fa5b58df05f447b8e32028382b1ea" translate="yes" xml:space="preserve">
          <source>This relies on the fact that uninitialized array elements are set to NULL.</source>
          <target state="translated">이것은 초기화되지 않은 배열 요소가 NULL로 설정되어 있다는 사실에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="9d7d55aad79de70107f3e8211b62fbf8c98570e5" translate="yes" xml:space="preserve">
          <source>This renders a print statement, which includes a call to the function. It's identical to rendering a file with a use call and that single statement, except for the filename which appears in the nextstate ops.</source>
          <target state="translated">함수에 대한 호출을 포함하는 print 문을 렌더링합니다. nextstate ops에 나타나는 파일 이름을 제외하고 use 호출과 단일 명령문으로 파일을 렌더링하는 것과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="ea6f5b9409b135d9fd2914f5e9712bb211e3d415" translate="yes" xml:space="preserve">
          <source>This renders all functions in the B::Concise package with the source lines. It eschews the O framework so that the stashref can be passed directly to B::Concise::compile(). See -stash option for a more convenient way to render a package.</source>
          <target state="translated">이렇게하면 B :: Concise 패키지의 모든 기능이 소스 행과 함께 렌더링됩니다. stashref가 B :: Concise :: compile ()에 직접 전달 될 수 있도록 O 프레임 워크를 생략합니다. 보다 편리한 패키지 렌더링 방법은 -stash 옵션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="65869e50f6892b08c4cf7dcb78cc5963bf748c6b" translate="yes" xml:space="preserve">
          <source>This requires &lt;code&gt;perl-5.8&lt;/code&gt; or higher, compiled with &lt;code&gt;perlio&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;perlio&lt;/code&gt; 로 컴파일 된 &lt;code&gt;perl-5.8&lt;/code&gt; 이상 이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="cf4909d18f4323c37d07bae96a1d0080562f63f5" translate="yes" xml:space="preserve">
          <source>This requires require a 64-bit MIPS CPU (R8000, R10000, ...)</source>
          <target state="translated">이를 위해서는 64 비트 MIPS CPU (R8000, R10000, ...)가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="f7da7513031db644267fa4b13fabe99ed2a030c7" translate="yes" xml:space="preserve">
          <source>This restores one of the standard line-styles: &lt;code&gt;terse&lt;/code&gt; , &lt;code&gt;concise&lt;/code&gt; , &lt;code&gt;linenoise&lt;/code&gt; , &lt;code&gt;debug&lt;/code&gt; , &lt;code&gt;env&lt;/code&gt; , into effect. It also accepts style names previously defined with add_style().</source>
          <target state="translated">그러면 표준 선 스타일 중 하나 인 &lt;code&gt;terse&lt;/code&gt; , &lt;code&gt;concise&lt;/code&gt; , &lt;code&gt;linenoise&lt;/code&gt; , &lt;code&gt;debug&lt;/code&gt; , &lt;code&gt;env&lt;/code&gt; 가복원 됩니다. 또한 add_style ()로 이전에 정의 된 스타일 이름도 허용합니다.</target>
        </trans-unit>
        <trans-unit id="f0559182bda8492a3ca4dae9b14b73dc55291956" translate="yes" xml:space="preserve">
          <source>This restores the default behavior after you've changed it with '-main' (it's not normally needed). If no subroutine name/ref is given, main is rendered, regardless of this flag.</source>
          <target state="translated">'-main'으로 변경 한 후 기본 동작이 복원됩니다 (일반적으로 필요하지 않음). 서브 루틴 이름 / 참조가 제공되지 않으면이 플래그에 관계없이 main이 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="f49545d47b4c2e67130feb223d7916803e2151e7" translate="yes" xml:space="preserve">
          <source>This restores the token object(s) to the front of the parser stream.</source>
          <target state="translated">토큰 객체를 파서 스트림의 전면으로 복원합니다.</target>
        </trans-unit>
        <trans-unit id="438306ebd9d1acbe91b86dc11907f9e6dab643b7" translate="yes" xml:space="preserve">
          <source>This returns NULL if the variable does not exist.</source>
          <target state="translated">변수가 존재하지 않으면 NULL을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c37bfa051bc09e91f6aa8c8e068658f22a9b05b4" translate="yes" xml:space="preserve">
          <source>This returns a glob reference for the symbol table entry of VARNAME in the package of the compartment. VARNAME must be the &lt;b&gt;name&lt;/b&gt; of a variable without any leading type marker. For example:</source>
          <target state="translated">구획 패키지에서 VARNAME의 기호 테이블 항목에 대한 glob 참조를 리턴합니다. VARNAME은 선행 유형 표시자가없는 변수 의 &lt;b&gt;이름&lt;/b&gt; 이어야합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4846a06785f0daaeee2213d80f23082c8fa4965c" translate="yes" xml:space="preserve">
          <source>This returns a handy stringified value of this object. This is useful for debugging, as in:</source>
          <target state="translated">이것은이 객체의 편리한 문자열 값을 반환합니다. 다음과 같이 디버깅에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b1ea704d04f7c3ec75b7f4e64aa2fc6d627bedce" translate="yes" xml:space="preserve">
          <source>This returns a list of the elements of the op's aux data structure, or a null list if there is no aux. What will be returned depends on the object's type, but will typically be a collection of &lt;code&gt;B::IV&lt;/code&gt; , &lt;code&gt;B::GV&lt;/code&gt; , etc. objects. &lt;code&gt;cv&lt;/code&gt; is the &lt;code&gt;B::CV&lt;/code&gt; object representing the sub that the op is contained within.</source>
          <target state="translated">op의 aux 데이터 구조 요소 목록을 표시하거나 aux가 없으면 null 목록을 반환합니다. 반환되는 것은 객체의 유형에 따라 다르지만 일반적으로 &lt;code&gt;B::IV&lt;/code&gt; , &lt;code&gt;B::GV&lt;/code&gt; 등의 객체 컬렉션입니다 . &lt;code&gt;cv&lt;/code&gt; 는 op가 포함 된 하위를 나타내는 &lt;code&gt;B::CV&lt;/code&gt; 객체입니다.</target>
        </trans-unit>
        <trans-unit id="78c4d2eacb966527e478f0083cb85da673514051" translate="yes" xml:space="preserve">
          <source>This returns a list of the names of all the installed modules. The perl 'core' is given the special name 'Perl'.</source>
          <target state="translated">설치된 모든 모듈의 이름 목록이 반환됩니다. 펄 '코어'에는 특수 이름 'Perl'이 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="a39fe91e6096e4528d2eface949d54878f13adb3" translate="yes" xml:space="preserve">
          <source>This returns a new parser object, where</source>
          <target state="translated">새로운 파서 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c0e359e0a6bfe07d5ae556f45550772e1dc21138" translate="yes" xml:space="preserve">
          <source>This returns a normal Perl scalar from $x. It is used automatically whenever a scalar is needed, for instance in array index operations.</source>
          <target state="translated">$ x에서 일반 Perl 스칼라를 반환합니다. 예를 들어 배열 인덱스 작업에서 스칼라가 필요할 때마다 자동으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4bedda000844c8f0e165c8e9491e25dc6f787dac" translate="yes" xml:space="preserve">
          <source>This returns a reference to a hash which has short general category names (such as &lt;code&gt;Lu&lt;/code&gt; , &lt;code&gt;Nd&lt;/code&gt; , &lt;code&gt;Zs&lt;/code&gt; , &lt;code&gt;S&lt;/code&gt; ) as keys and long names (such as &lt;code&gt;UppercaseLetter&lt;/code&gt; , &lt;code&gt;DecimalNumber&lt;/code&gt; , &lt;code&gt;SpaceSeparator&lt;/code&gt; , &lt;code&gt;Symbol&lt;/code&gt; ) as values. The hash is reversible in case you need to go from the long names to the short names. The general category is the one returned from &lt;a href=&quot;#charinfo()&quot;&gt;charinfo()&lt;/a&gt; under the &lt;code&gt;category&lt;/code&gt; key.</source>
          <target state="translated">이는 키로 일반 카테고리 이름 (예 : &lt;code&gt;Lu&lt;/code&gt; , &lt;code&gt;Nd&lt;/code&gt; , &lt;code&gt;Zs&lt;/code&gt; , &lt;code&gt;S&lt;/code&gt; )이 있고 값 으로 &lt;code&gt;UppercaseLetter&lt;/code&gt; (예 : UppercaseLetter , &lt;code&gt;DecimalNumber&lt;/code&gt; , &lt;code&gt;SpaceSeparator&lt;/code&gt; , &lt;code&gt;Symbol&lt;/code&gt; ) 가있는 해시에 대한 참조를 리턴 합니다. 긴 이름에서 짧은 이름으로 이동해야하는 경우 해시를 되돌릴 수 있습니다. 일반 카테고리는 &lt;code&gt;category&lt;/code&gt; 키 아래의 &lt;a href=&quot;#charinfo()&quot;&gt;charinfo ()&lt;/a&gt; 에서 리턴 된 카테고리 입니다.</target>
        </trans-unit>
        <trans-unit id="88c58feecc3765e5c4080f925afe0ce2010395de" translate="yes" xml:space="preserve">
          <source>This returns a reference to a hash which has the short bidi (bidirectional) type names (such as &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;R&lt;/code&gt; ) as keys and long names (such as &lt;code&gt;Left-to-Right&lt;/code&gt; , &lt;code&gt;Right-to-Left&lt;/code&gt; ) as values. The hash is reversible in case you need to go from the long names to the short names. The bidi type is the one returned from &lt;a href=&quot;#charinfo()&quot;&gt;charinfo()&lt;/a&gt; under the &lt;code&gt;bidi&lt;/code&gt; key. For the exact meaning of the various bidi classes the Unicode TR9 is recommended reading: &lt;a href=&quot;http://www.unicode.org/reports/tr9/&quot;&gt;http://www.unicode.org/reports/tr9/&lt;/a&gt; (as of Unicode 5.0.0)</source>
          <target state="translated">이는 짧은 bidi (양방향) 유형 이름 (예 : &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;R&lt;/code&gt; )을 키로, 긴 이름 (예 : &lt;code&gt;Left-to-Right&lt;/code&gt; , &lt;code&gt;Right-to-Left&lt;/code&gt; )을 값 으로 갖는 해시에 대한 참조를 리턴 합니다. 긴 이름에서 짧은 이름으로 이동해야하는 경우 해시를 되돌릴 수 있습니다. bidi 유형은 &lt;code&gt;bidi&lt;/code&gt; 키 아래의 &lt;a href=&quot;#charinfo()&quot;&gt;charinfo ()&lt;/a&gt; 에서 반환 된 유형입니다 . 다양한 bidi 클래스의 정확한 의미를 위해 유니 코드 TR9를 읽는 것이 좋습니다. &lt;a href=&quot;http://www.unicode.org/reports/tr9/&quot;&gt;http://www.unicode.org/reports/tr9/&lt;/a&gt; (유니 코드 5.0.0부터)</target>
        </trans-unit>
        <trans-unit id="9b6e4381af622706d0b561391364ef549fe16051" translate="yes" xml:space="preserve">
          <source>This returns a reference to a hash whose keys are all the distinct Unicode (no Perl extension) properties, and whose values are the respective values for those properties for the input &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt;.</source>
          <target state="translated">키가 모두 고유 한 유니 코드 (확장자 없음) 특성이고 값이 입력 &lt;a href=&quot;#code-point-argument&quot;&gt;코드 포인트 인수&lt;/a&gt; 의 해당 특성 값인 해시에 대한 참조를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="92aa49cb1c3f622edac6a155f13e38f83b6dfb08" translate="yes" xml:space="preserve">
          <source>This returns a scalar reference to the string that this token holds. This can be useful if you don't want to memory-copy the potentially large text value (well, as large as a paragraph or a verbatim block) as calling $token-&amp;gt;text would do.</source>
          <target state="translated">이 토큰이 보유한 문자열에 대한 스칼라 참조를 리턴합니다. 이것은 $ token-&amp;gt; text를 호출하는 것처럼 잠재적으로 큰 텍스트 값 (문단 또는 축약 블록만큼 큰)을 메모리 복사하지 않으려는 경우에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78d7fbfdd37ad836b426c426d9f57674d28b607c" translate="yes" xml:space="preserve">
          <source>This returns a textual representation of the object (likely to b useful for deparsing and debugging), or an empty string if the op type doesn't support this. &lt;code&gt;cv&lt;/code&gt; is the &lt;code&gt;B::CV&lt;/code&gt; object representing the sub that the op is contained within.</source>
          <target state="translated">이것은 객체의 텍스트 표현 (파싱 및 디버깅에 유용 할 것 같음) 또는 op 유형이이를 지원하지 않는 경우 빈 문자열을 반환합니다. &lt;code&gt;cv&lt;/code&gt; 는 op가 포함 된 하위를 나타내는 &lt;code&gt;B::CV&lt;/code&gt; 객체입니다.</target>
        </trans-unit>
        <trans-unit id="5163e24143304da0c24ab6f05ddab5463a924808" translate="yes" xml:space="preserve">
          <source>This returns all the case foldings in the current version of Unicode in the form of a reference to a hash. Each key to the hash is the decimal representation of a Unicode character that has a casefold to other than itself. The casefold of a semi-colon is itself, so it isn't in the hash; likewise for a lowercase &quot;a&quot;, but there is an entry for a capital &quot;A&quot;. The hash value for each key is another hash, identical to what is returned by &lt;a href=&quot;#casefold()&quot;&gt;casefold()&lt;/a&gt; if called with that code point as its argument. So the value &lt;code&gt;all_casefolds()-&amp;gt;{&lt;a href=&quot;../functions/ord&quot;&gt;ord&lt;/a&gt;(&quot;A&quot;)}'&lt;/code&gt; is equivalent to &lt;code&gt;casefold(&lt;a href=&quot;../functions/ord&quot;&gt;ord&lt;/a&gt;(&quot;A&quot;))&lt;/code&gt; ;</source>
          <target state="translated">이렇게하면 현재 버전의 유니 코드에서 모든 대소 문자를 해시에 대한 참조 형식으로 반환합니다. 해시의 각 키는 자신 이외의 다른 사례가있는 유니 코드 문자의 10 진수 표현입니다. 세미콜론의 사례는 자체이므로 해시에는 없습니다. 마찬가지로 소문자 &quot;a&quot;에 대해서도 대문자 &quot;A&quot;에 대한 항목이 있습니다. 각 키의 해시 값은 다른 해시이며, 해당 코드 포인트를 인수로 사용하여 호출 한 경우 &lt;a href=&quot;#casefold()&quot;&gt;casefold ()에서&lt;/a&gt; 반환되는 것과 동일합니다 . 따라서 &lt;code&gt;all_casefolds()-&amp;gt;{&lt;a href=&quot;../functions/ord&quot;&gt;ord&lt;/a&gt;(&quot;A&quot;)}'&lt;/code&gt; 은 &lt;code&gt;casefold(&lt;a href=&quot;../functions/ord&quot;&gt;ord&lt;/a&gt;(&quot;A&quot;))&lt;/code&gt; 와 같습니다.</target>
        </trans-unit>
        <trans-unit id="cc96752d9a4198cd2cf54c44f2b3b5b10b6e33c5" translate="yes" xml:space="preserve">
          <source>This returns information about the input &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt; as a reference to a hash of fields as defined by the Unicode standard. If the &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt; is not assigned in the standard (i.e., has the general category &lt;code&gt;Cn&lt;/code&gt; meaning &lt;code&gt;Unassigned&lt;/code&gt; ) or is a non-character (meaning it is guaranteed to never be assigned in the standard), &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">이것은 유니 코드 표준에 의해 정의 된대로 필드의 해시에 대한 참조로 입력 &lt;a href=&quot;#code-point-argument&quot;&gt;코드 포인트 인수&lt;/a&gt; 에 대한 정보를 리턴합니다 . 경우 &lt;a href=&quot;#code-point-argument&quot;&gt;코드 포인트 인수가&lt;/a&gt; 표준에 할당되지 않은 (즉, 일반 카테고리가 &lt;code&gt;Cn&lt;/code&gt; 의미 &lt;code&gt;Unassigned&lt;/code&gt; ) 또는 (이 표준에 배정하지 않는다는 보장을 의미)가 아닌 문자, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="eb91ab331ab9de210b4db7e921e9ff160732003a" translate="yes" xml:space="preserve">
          <source>This returns the (almost) locale-independent case folding of the character specified by the &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt;. (Starting in Perl v5.16, the core function &lt;code&gt;&lt;a href=&quot;../functions/fc&quot;&gt;fc()&lt;/a&gt;&lt;/code&gt; returns the &lt;code&gt;full&lt;/code&gt; mapping (described below) faster than this does, and for entire strings.)</source>
          <target state="translated">이것은 &lt;a href=&quot;#code-point-argument&quot;&gt;코드 포인트 argument로&lt;/a&gt; 지정된 문자의 (거의) 로케일 독립적 대소 문자를 리턴합니다 . (Perl v5.16부터 핵심 함수 &lt;code&gt;&lt;a href=&quot;../functions/fc&quot;&gt;fc()&lt;/a&gt;&lt;/code&gt; 는 전체 문자열에 대해 &lt;code&gt;full&lt;/code&gt; 매핑 (아래 설명 참조)을 더 빠르게 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="91677229ee695edb8db59966a9bf52f69db7141f" translate="yes" xml:space="preserve">
          <source>This returns the ExtUtils::Packlist object for the specified module.</source>
          <target state="translated">지정된 모듈에 대한 ExtUtils :: Packlist 개체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="91c8292002290e5d7ad79eff5f6aca62a17b0302" translate="yes" xml:space="preserve">
          <source>This returns the file format version as number. It is a string like &quot;2.007&quot;. This value is suitable for numeric comparisons.</source>
          <target state="translated">파일 형식 버전을 숫자로 반환합니다. &quot;2.007&quot;과 같은 문자열입니다. 이 값은 숫자 비교에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="b28a3d3b844d30822d117ab98847259c42e20f28" translate="yes" xml:space="preserve">
          <source>This returns the file format version. It is a string like &quot;2.7&quot;.</source>
          <target state="translated">파일 형식 버전을 반환합니다. &quot;2.7&quot;과 같은 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="88abd5e16e9b3ba61f0f89ea977172fa6b064d17" translate="yes" xml:space="preserve">
          <source>This returns the filename that this parser object was set to read from.</source>
          <target state="translated">파서 객체를 읽도록 설정된 파일 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bccff29a1ac784a814e5e53a8041bdec5c902b0f" translate="yes" xml:space="preserve">
          <source>This returns the full path of the first occurrence to the file. Package names (eg 'A::B') are automatically converted to directory names in the selected directory. Additionally, '.pm', '.pl' and '.pod' are automatically appended to the search as required. (So, for example, under Unix, &quot;A::B&quot; is converted to &quot;somedir/A/B.pm&quot;, &quot;somedir/A/B.pod&quot;, or &quot;somedir/A/B.pl&quot;, as appropriate.)</source>
          <target state="translated">이것은 첫 번째 발생의 전체 경로를 파일로 리턴합니다. 패키지 이름 (예 : 'A :: B')은 선택한 디렉토리의 디렉토리 이름으로 자동 변환됩니다. 또한 필요에 따라 '.pm', '.pl'및 '.pod'가 자동으로 검색에 추가됩니다. 따라서 예를 들어 Unix에서 &quot;A :: B&quot;는 다음과 같이 &quot;somedir / A / B.pm&quot;, &quot;somedir / A / B.pod&quot;또는 &quot;somedir / A / B.pl&quot;로 변환됩니다. 적당한.)</target>
        </trans-unit>
        <trans-unit id="2a501f04d237b4afdc751c24d97b1564c6c9be99" translate="yes" xml:space="preserve">
          <source>This returns the function name as a string (e.g. &quot;PL_ppaddr[OP_ADD]&quot;, &quot;PL_ppaddr[OP_RV2AV]&quot;).</source>
          <target state="translated">함수 이름을 문자열로 반환합니다 (예 : &quot;PL_ppaddr [OP_ADD]&quot;, &quot;PL_ppaddr [OP_RV2AV]&quot;).</target>
        </trans-unit>
        <trans-unit id="a6c7ba8cdf1911985e871524f867f03a73878f39" translate="yes" xml:space="preserve">
          <source>This returns the given noun form which is appropriate for the quantity &lt;code&gt;$number&lt;/code&gt; according to this language's conventions. &lt;code&gt;numerate&lt;/code&gt; is used internally by &lt;code&gt;quant&lt;/code&gt; to quantify nouns. Use it directly -- usually from bracket notation -- to avoid &lt;code&gt;quant&lt;/code&gt; 's implicit call to &lt;code&gt;numf&lt;/code&gt; and output of a numeric quantity.</source>
          <target state="translated">이것은 이 언어의 규칙에 따라 수량 &lt;code&gt;$number&lt;/code&gt; 에 적합한 주어진 명사 양식을 리턴합니다 . &lt;code&gt;numerate&lt;/code&gt; 는 명사를 정량화하기 위해 &lt;code&gt;quant&lt;/code&gt; 에 의해 내부적으로 사용됩니다 . &lt;code&gt;quant&lt;/code&gt; 의 &lt;code&gt;numf&lt;/code&gt; 에 대한 암시 적 호출 및 숫자 수량의 출력 을 피하려면 직접 대괄호 표기법으로 직접 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ecd76e9b7635df85484a01189e6a2f492cf6d79" translate="yes" xml:space="preserve">
          <source>This returns the given number formatted nicely according to this language's conventions. Maketext's default method is mostly to just take the normal string form of the number (applying sprintf &quot;%G&quot; for only very large numbers), and then to add commas as necessary. (Except that we apply &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr/,./.,/&lt;/a&gt;&lt;/code&gt; if $language-&amp;gt;{'numf_comma'} is true; that's a bit of a hack that's useful for languages that express two million as &quot;2.000.000&quot; and not as &quot;2,000,000&quot;).</source>
          <target state="translated">이 언어의 규칙에 따라 형식이 지정된 주어진 숫자를 반환합니다. Maketext의 기본 방법은 대부분 숫자의 일반적인 문자열 형식 (매우 큰 숫자에만 sprintf &quot;% G&quot;적용)을 취한 다음 필요에 따라 쉼표를 추가하는 것입니다. ( $ language-&amp;gt; { 'numf_comma'}가 true 인 경우 &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr/,./.,/&lt;/a&gt;&lt;/code&gt; 적용한다는 점을 제외하고 는 &quot;백만이 아닌&quot;2.000.000 &quot;으로 표현되는 언어에는 유용한 해킹입니다. 2,000,000 &quot;).</target>
        </trans-unit>
        <trans-unit id="025fac90217d4ce617ea39a22bf3a99d01ca61a8" translate="yes" xml:space="preserve">
          <source>This returns the hashref that is the attribute set for this start-token. This is useful if (for example) you want to ask what all the attributes are -- you can just do &lt;code&gt;&lt;a href=&quot;../../functions/keys&quot;&gt;keys&lt;/a&gt; %{$token-&amp;gt;attr_hash}&lt;/code&gt;</source>
          <target state="translated">이 시작 토큰에 대해 설정된 속성 인 해시 참조를 리턴합니다. 이것은 (예를 들어) 모든 속성이 무엇인지 묻고 싶을 때 유용 &lt;code&gt;&lt;a href=&quot;../../functions/keys&quot;&gt;keys&lt;/a&gt; %{$token-&amp;gt;attr_hash}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26a1d54ba9e2a0e72117dea2ff05555485f06342" translate="yes" xml:space="preserve">
          <source>This returns the name of the associated .packlist file</source>
          <target state="translated">연결된 .packlist 파일의 이름이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8714a4ea9c89be9e02bb0a484046217a2fdc2659" translate="yes" xml:space="preserve">
          <source>This returns the next token object (which will be of a subclass of &lt;a href=&quot;pullparsertoken&quot;&gt;Pod::Simple::PullParserToken&lt;/a&gt;), or undef if the parser-stream has hit the end of the document.</source>
          <target state="translated">그러면 다음 토큰 객체 ( &lt;a href=&quot;pullparsertoken&quot;&gt;Pod :: Simple :: PullParserToken&lt;/a&gt; 의 서브 클래스가 됨 )를 반환하거나 파서 스트림이 문서의 끝에 도달하면 undef를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="db9439ac80b35bc802acd8f20ce2c7390e307d09" translate="yes" xml:space="preserve">
          <source>This returns the op description from the global C PL_op_desc array (e.g. &quot;addition&quot; &quot;array deref&quot;).</source>
          <target state="translated">전역 C PL_op_desc 배열 (예 : &quot;addition&quot; &quot;array deref&quot;)에서 op 설명을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5681c12774f7d1547e4176d6eccb3ccd12074a1f" translate="yes" xml:space="preserve">
          <source>This returns the op name as a string (e.g. &quot;add&quot;, &quot;rv2av&quot;).</source>
          <target state="translated">op 이름을 문자열로 반환합니다 (예 : &quot;add&quot;, &quot;rv2av&quot;).</target>
        </trans-unit>
        <trans-unit id="7c24d1c30b8541d36722cb533fdf5d0b9d4b051d" translate="yes" xml:space="preserve">
          <source>This returns the potentially locale-dependent case mappings of the &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt;. The mappings may be longer than a single code point (which the basic Unicode case mappings as returned by &lt;a href=&quot;#charinfo()&quot;&gt;charinfo()&lt;/a&gt; never are).</source>
          <target state="translated">&lt;a href=&quot;#code-point-argument&quot;&gt;코드 포인트 인수&lt;/a&gt; 의 잠재적 인 로케일 종속 대소 문자 맵핑을 리턴합니다 . 매핑은 단일 코드 포인트보다 길 수 있습니다 ( &lt;a href=&quot;#charinfo()&quot;&gt;charinfo ()에&lt;/a&gt; 의해 반환되는 기본 유니 코드 대 / 소문자 매핑은 절대 안 됨).</target>
        </trans-unit>
        <trans-unit id="e407d9572ab9c5f99771767ba652986d36609117" translate="yes" xml:space="preserve">
          <source>This returns the tagname for this end-token object. For example, parsing a &quot;=head1 ...&quot; line will give you a start-token with the tagname of &quot;head1&quot;, token(s) for its content, and then an end-token with the tagname of &quot;head1&quot;.</source>
          <target state="translated">이 엔드 토큰 객체의 태그 이름을 반환합니다. 예를 들어, &quot;= head1 ...&quot;줄을 구문 분석하면 &quot;name1&quot;이라는 태그 이름을 가진 시작 토큰, 내용에 대한 토큰 및 &quot;head1&quot;이라는 태그 이름을 가진 종료 토큰이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="1457f9cf582cb43f3b8ece06b77a4a774ea5edd5" translate="yes" xml:space="preserve">
          <source>This returns the tagname for this start-token object. For example, parsing a &quot;=head1 ...&quot; line will give you a start-token with the tagname of &quot;head1&quot;, token(s) for its content, and then an end-token with the tagname of &quot;head1&quot;.</source>
          <target state="translated">시작 토큰 객체의 태그 이름을 반환합니다. 예를 들어, &quot;= head1 ...&quot;줄을 구문 분석하면 &quot;name1&quot;이라는 태그 이름을 가진 시작 토큰, 내용에 대한 토큰 및 &quot;head1&quot;이라는 태그 이름을 가진 종료 토큰이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a92df26815537e43f9c0925776fd61d439836096" translate="yes" xml:space="preserve">
          <source>This returns the text that this token holds. For example, parsing C&amp;lt;foo&amp;gt; will return a C start-token, a text-token, and a C end-token. And if you want to get the &quot;foo&quot; out of the text-token, call &lt;code&gt;$token-&amp;gt;text&lt;/code&gt;</source>
          <target state="translated">이 토큰이 보유한 텍스트를 반환합니다. 예를 들어 C &amp;lt;foo&amp;gt;를 구문 분석하면 C 시작 토큰, 텍스트 토큰 및 C 엔드 토큰이 반환됩니다. 그리고 텍스트 토큰에서 &quot;foo&quot;를 가져 오려면 &lt;code&gt;$token-&amp;gt;text&lt;/code&gt; 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="37adaa267b32499cf66804411e8414b1ad1805e1" translate="yes" xml:space="preserve">
          <source>This returns the thread's context in the same manner as &lt;a href=&quot;functions/wantarray&quot;&gt;wantarray&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;functions/wantarray&quot;&gt;wantarray&lt;/a&gt; 와 같은 방식으로 스레드 컨텍스트를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="e65fe0dbb6e214f3cd7dbd02a6dc6c382b0c30da" translate="yes" xml:space="preserve">
          <source>This returns the type of the token. This will be either the string &quot;start&quot;, the string &quot;text&quot;, or the string &quot;end&quot;.</source>
          <target state="translated">토큰 유형을 반환합니다. 이것은 문자열 &quot;start&quot;, 문자열 &quot;text&quot;또는 문자열 &quot;end&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="11b6f6f063cb5805a948af38969c126392d218a6" translate="yes" xml:space="preserve">
          <source>This returns the value of the</source>
          <target state="translated">이것은 값을 반환합니다</target>
        </trans-unit>
        <trans-unit id="6e7567ac847e3dd9703ee4f767f192a1f4433a0b" translate="yes" xml:space="preserve">
          <source>This returns the value of the Unicode property given by the second parameter for the &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt; given by the first.</source>
          <target state="translated">첫 번째 &lt;a href=&quot;#code-point-argument&quot;&gt;코드 포인트 인수에&lt;/a&gt; 대한 두 번째 매개 변수가 제공 한 Unicode 특성 값을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="00254886c0f76de134b6342f6c209f119eee2c52" translate="yes" xml:space="preserve">
          <source>This returns the version number for the specified module.</source>
          <target state="translated">지정된 모듈의 버전 번호를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="28cb21f0ce04fc34237dafa4d05afb66efd55c58" translate="yes" xml:space="preserve">
          <source>This returns the version of the Unicode Character Database, in other words, the version of the Unicode standard the database implements. The version is a string of numbers delimited by dots (&lt;code&gt;'.'&lt;/code&gt; ).</source>
          <target state="translated">이것은 유니 코드 문자 데이터베이스의 버전, 즉 데이터베이스가 구현하는 유니 코드 표준의 버전을 리턴합니다. 버전은 점 ( &lt;code&gt;'.'&lt;/code&gt; )으로 구분 된 문자열입니다 .</target>
        </trans-unit>
        <trans-unit id="0537cb9604bd46fdc53aedf1ef4d31156ea69d21" translate="yes" xml:space="preserve">
          <source>This returns true if &lt;code&gt;$parser&lt;/code&gt; has read from a source, and come to the end of that source.</source>
          <target state="translated">&lt;code&gt;$parser&lt;/code&gt; 가 소스에서 읽고 해당 소스의 끝 부분에 도달 하면 true를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="d892085e64119e5b73847e052d7936e4ec27fd45" translate="yes" xml:space="preserve">
          <source>This returns true if &lt;code&gt;$parser&lt;/code&gt; has read from a source, and has seen Pod content in it.</source>
          <target state="translated">&lt;code&gt;$parser&lt;/code&gt; 가 소스에서 읽고 Pod 컨텐츠를 본 경우 true를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="0b811ea00850392c2bee3b4f40af1e1b677b7142" translate="yes" xml:space="preserve">
          <source>This returns true only if there has been any real content seen for this document. Returns false in cases where the document contains content, but does not make use of any Pod markup.</source>
          <target state="translated">이 문서에 실제 내용이있는 경우에만 true를 반환합니다. 문서에 내용이 포함되어 있지만 포드 마크 업을 사용하지 않는 경우 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e28605a00b749132376858f485353c17ca2a0f0d" translate="yes" xml:space="preserve">
          <source>This routine also returns a different number of arguments depending on the success or failure of the call to statfs. If there is an error, the error number is returned as a single-element array. If the call is successful, then a 7-element array is returned. Since only one argument is passed into this function, we need room on the stack to hold the 7 values which may be returned.</source>
          <target state="translated">이 루틴은 또한 statfs 호출의 성공 또는 실패에 따라 다른 수의 인수를 리턴합니다. 오류가 있으면 오류 번호가 단일 요소 배열로 반환됩니다. 호출이 성공하면 7 요소 배열이 리턴됩니다. 이 함수에는 하나의 인수 만 전달되므로 스택에 7 개의 값을 보유 할 공간이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="5b820e747b00eb7161f8b3a6555a694bd263c329" translate="yes" xml:space="preserve">
          <source>This routine behaves identically to the final two forms. That is, it does not return &lt;b&gt;true&lt;/b&gt; if the code point has a decomposition consisting of another single code point, nor if its decomposition starts with a code point whose combining class is non-zero. Code points that meet either of these conditions should also not be produced by composition normalization, which is probably why you should use the &lt;code&gt;Full_Composition_Exclusion&lt;/code&gt; property instead, as shown above.</source>
          <target state="translated">이 루틴은 마지막 두 양식과 동일하게 작동합니다. 즉, 코드 포인트에 다른 단일 코드 포인트로 구성된 분해가 있거나 분해 클래스가 0이 아닌 코드 포인트로 분해가 시작되는 경우에는 &lt;b&gt;true를&lt;/b&gt; 반환하지 않습니다 . 이러한 조건 중 하나를 충족하는 코드 포인트는 컴포지션 정규화로 생성되지 않아야하므로 위와 같이 &lt;code&gt;Full_Composition_Exclusion&lt;/code&gt; 속성을 대신 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e6cbcd70e8dd9e2b5edee3c69038ed73e9a903ad" translate="yes" xml:space="preserve">
          <source>This routine checks to see what types of magic &lt;code&gt;sv&lt;/code&gt; has. If the mg_type field is an uppercase letter, then the mg_obj is copied to &lt;code&gt;nsv&lt;/code&gt; , but the mg_type field is changed to be the lowercase letter.</source>
          <target state="translated">이 루틴은 어떤 유형의 매직 &lt;code&gt;sv&lt;/code&gt; 이 있는지 확인합니다 . mg_type 필드가 대문자이면 mg_obj가 복사됩니다 &lt;code&gt;nsv&lt;/code&gt; 하지만 mg_type 필드는 소문자 편지로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="156fe43e5f5152548ce6f33bee1b7f0723071b2f" translate="yes" xml:space="preserve">
          <source>This routine expects a single parameter--a reference to a subroutine or variable. It returns a list of attributes, which may be empty. If passed invalid arguments, it uses die() (via &lt;a href=&quot;carp&quot;&gt;Carp::croak&lt;/a&gt;) to raise a fatal exception. If it can find an appropriate package name for a class method lookup, it will include the results from a &lt;code&gt;FETCH_&lt;i&gt;type&lt;/i&gt;_ATTRIBUTES&lt;/code&gt; call in its return list, as described in &lt;a href=&quot;#Package-specific-Attribute-Handling&quot;&gt;Package-specific Attribute Handling&lt;/a&gt; below. Otherwise, only &lt;a href=&quot;#Built-in-Attributes&quot;&gt;built-in attributes&lt;/a&gt; will be returned.</source>
          <target state="translated">이 루틴은 단일 매개 변수, 즉 서브 루틴 또는 변수에 대한 참조를 필요로합니다. 비어있을 수있는 속성 목록을 반환합니다. 유효하지 않은 인수를 전달하면 die () ( &lt;a href=&quot;carp&quot;&gt;Carp :: croak&lt;/a&gt; 를 통해 )를 사용하여 치명적인 예외를 발생시킵니다. 클래스 메소드 검색에 적합한 패키지 이름을 찾을 수 있으면 아래 &lt;a href=&quot;#Package-specific-Attribute-Handling&quot;&gt;패키지 별 속성 처리에&lt;/a&gt; 설명 된대로 &lt;code&gt;FETCH_&lt;i&gt;type&lt;/i&gt;_ATTRIBUTES&lt;/code&gt; 호출 의 결과를 리턴 목록에 포함 시킵니다. 그렇지 않으면 &lt;a href=&quot;#Built-in-Attributes&quot;&gt;내장 속성&lt;/a&gt; 만 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f1cbd8c6e15630953581b673b778fa0654a81555" translate="yes" xml:space="preserve">
          <source>This routine expects a single parameter--a reference to a subroutine or variable. It returns the built-in type of the referenced variable, ignoring any package into which it might have been blessed. This can be useful for determining the</source>
          <target state="translated">이 루틴은 단일 매개 변수, 즉 서브 루틴 또는 변수에 대한 참조를 필요로합니다. 참조 된 변수의 내장 유형을 리턴하며, 축복 된 패키지는 무시합니다. 이것은</target>
        </trans-unit>
        <trans-unit id="a441bbdb5a22183756c86532b0bd8538c60db634" translate="yes" xml:space="preserve">
          <source>This routine is automatically used whenever a scalar is required:</source>
          <target state="translated">이 루틴은 스칼라가 필요할 때마다 자동으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="af05f40d5a349a9cf28386764e38317c02e23a0c" translate="yes" xml:space="preserve">
          <source>This routine provides word completion on the list of words in the array (or array ref).</source>
          <target state="translated">이 루틴은 배열 (또는 배열 참조)의 단어 목록에서 단어 완성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a12916af343198cbe644e34418361cddb6245ff7" translate="yes" xml:space="preserve">
          <source>This routine returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if the Unicode version being used is so early that it doesn't have this property.</source>
          <target state="translated">이 루틴은 사용중인 유니 코드 버전이 너무 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 이 특성이없는 경우 undef를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="101ceccec63478c5c011c3caa8244abb6108d41c" translate="yes" xml:space="preserve">
          <source>This routine returns a pointer to a &lt;code&gt;MAGIC&lt;/code&gt; structure stored in the SV. If the SV does not have that magical feature, &lt;code&gt;NULL&lt;/code&gt; is returned. If the SV has multiple instances of that magical feature, the first one will be returned. &lt;code&gt;mg_findext&lt;/code&gt; can be used to find a &lt;code&gt;MAGIC&lt;/code&gt; structure of an SV based on both its magic type and its magic virtual table:</source>
          <target state="translated">이 루틴은 SV에 저장된 &lt;code&gt;MAGIC&lt;/code&gt; 구조에 대한 포인터를 반환합니다 . SV에 해당 마법 기능이 없으면 &lt;code&gt;NULL&lt;/code&gt; 이 반환됩니다. SV에 해당 마법 기능의 인스턴스가 여러 개있는 경우 첫 번째 기능이 반환됩니다. &lt;code&gt;mg_findext&lt;/code&gt; 는 마법 유형과 마법 가상 테이블을 기반으로 SV 의 &lt;code&gt;MAGIC&lt;/code&gt; 구조 를 찾는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="be064f7d7fc8c5c81c03e6f7693444f3da761d4d" translate="yes" xml:space="preserve">
          <source>This runs all the given</source>
          <target state="translated">이 모든 주어진 주어진</target>
        </trans-unit>
        <trans-unit id="5f9d330768a086b11c3fee8aaebb21d2fcbcb969" translate="yes" xml:space="preserve">
          <source>This runs some basic sanity tests on the source tree and helps catch basic errors before you submit a patch.</source>
          <target state="translated">이것은 소스 트리에서 몇 가지 기본 온 전성 테스트를 실행하며 패치를 제출하기 전에 기본 오류를 포착하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="b456dbbb28104ac1fe79034d2719d013d951db2d" translate="yes" xml:space="preserve">
          <source>This safer version of &lt;a href=&quot;#chop&quot;&gt;chop&lt;/a&gt; removes any trailing string that corresponds to the current value of &lt;code&gt;$/&lt;/code&gt; (also known as $INPUT_RECORD_SEPARATOR in the &lt;code&gt;English&lt;/code&gt; module). It returns the total number of characters removed from all its arguments. It's often used to remove the newline from the end of an input record when you're worried that the final record may be missing its newline. When in paragraph mode (&lt;code&gt;$/ = ''&lt;/code&gt; ), it removes all trailing newlines from the string. When in slurp mode (&lt;code&gt;$/ = &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ) or fixed-length record mode (&lt;code&gt;$/&lt;/code&gt; is a reference to an integer or the like; see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;) chomp() won't remove anything. If VARIABLE is omitted, it chomps &lt;code&gt;$_&lt;/code&gt; . Example:</source>
          <target state="translated">이보다 안전한 &lt;a href=&quot;#chop&quot;&gt;chop&lt;/a&gt; 버전은 &lt;code&gt;$/&lt;/code&gt; 의 현재 값 ( &lt;code&gt;English&lt;/code&gt; 모듈 에서 $ INPUT_RECORD_SEPARATOR라고도 함)에 해당하는 후행 문자열을 제거합니다 . 모든 인수에서 제거 된 총 문자 수를 반환합니다. 최종 레코드에 줄 바꿈이 누락 될 염려가있는 경우 입력 레코드 끝에서 줄 바꿈을 제거하는 데 자주 사용됩니다. 단락 모드 ( &lt;code&gt;$/ = ''&lt;/code&gt; )에서는 문자열에서 모든 후행 줄 바꿈을 제거합니다. slurp 모드 ( &lt;code&gt;$/ = &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ) 또는 고정 길이 레코드 모드 ( &lt;code&gt;$/&lt;/code&gt; 는 정수 등을 참조합니다. &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; 참조 )에서 chomp ()는 아무것도 제거하지 않습니다. VARIABLE을 생략하면 mp &lt;code&gt;$_&lt;/code&gt; . 예:</target>
        </trans-unit>
        <trans-unit id="ade7671cda06ea60596db7de673c42e7e9809682" translate="yes" xml:space="preserve">
          <source>This safer version of &lt;a href=&quot;chop&quot;&gt;chop&lt;/a&gt; removes any trailing string that corresponds to the current value of &lt;code&gt;$/&lt;/code&gt; (also known as $INPUT_RECORD_SEPARATOR in the &lt;code&gt;English&lt;/code&gt; module). It returns the total number of characters removed from all its arguments. It's often used to remove the newline from the end of an input record when you're worried that the final record may be missing its newline. When in paragraph mode (&lt;code&gt;$/ = ''&lt;/code&gt; ), it removes all trailing newlines from the string. When in slurp mode (&lt;code&gt;$/ = &lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ) or fixed-length record mode (&lt;code&gt;$/&lt;/code&gt; is a reference to an integer or the like; see &lt;a href=&quot;../perlvar&quot;&gt;perlvar&lt;/a&gt;) chomp() won't remove anything. If VARIABLE is omitted, it chomps &lt;code&gt;$_&lt;/code&gt; . Example:</source>
          <target state="translated">이보다 안전한 &lt;a href=&quot;chop&quot;&gt;chop&lt;/a&gt; 버전은 &lt;code&gt;$/&lt;/code&gt; 의 현재 값 ( &lt;code&gt;English&lt;/code&gt; 모듈 에서 $ INPUT_RECORD_SEPARATOR라고도 함)에 해당하는 후행 문자열을 제거합니다 . 모든 인수에서 제거 된 총 문자 수를 반환합니다. 최종 레코드에 줄 바꿈이 누락 될 염려가있는 경우 입력 레코드 끝에서 줄 바꿈을 제거하는 데 자주 사용됩니다. 단락 모드 ( &lt;code&gt;$/ = ''&lt;/code&gt; )에서는 문자열에서 모든 후행 줄 바꿈을 제거합니다. slurp 모드 ( &lt;code&gt;$/ = &lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ) 또는 고정 길이 레코드 모드 ( &lt;code&gt;$/&lt;/code&gt; 는 정수 등을 참조합니다. &lt;a href=&quot;../perlvar&quot;&gt;perlvar&lt;/a&gt; 참조 )에서 chomp ()는 아무것도 제거하지 않습니다. VARIABLE을 생략하면 mp &lt;code&gt;$_&lt;/code&gt; . 예:</target>
        </trans-unit>
        <trans-unit id="29322e1fae611c7a4ec6b18f01c0e5539c007dbe" translate="yes" xml:space="preserve">
          <source>This same method is available from pure perl via, &lt;code&gt;mro::method_changed_in(classname)&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;mro::method_changed_in(classname)&lt;/code&gt; 통해 동일한 펄에서 동일한 방법을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e7a4db1ab47139698e5958a2175645481a1041ec" translate="yes" xml:space="preserve">
          <source>This says &lt;code&gt;$a&lt;/code&gt; is a reference (ROK), which points to another SV which is a PVAV, an array. The array has one element, element zero, which is another SV. The field &lt;code&gt;FILL&lt;/code&gt; above indicates the last element in the array, similar to &lt;code&gt;$#$a&lt;/code&gt; .</source>
          <target state="translated">이것은 &lt;code&gt;$a&lt;/code&gt; 가 참조 (ROK)이며 PVAV 인 어레이 인 다른 SV를 가리 킵니다. 배열에는 하나의 요소 (요소 0)가 있으며 이는 다른 SV입니다. 위의 &lt;code&gt;FILL&lt;/code&gt; 필드 는 &lt;code&gt;$#$a&lt;/code&gt; 와 유사하게 배열의 마지막 요소를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="036ebde834d76ddc89809412a48e08bc1aad5dd1" translate="yes" xml:space="preserve">
          <source>This says &lt;code&gt;$a&lt;/code&gt; is an SV, a scalar. The scalar is an IV, a number. Its reference count is 1. It has the &lt;code&gt;IOK&lt;/code&gt; flag set, meaning it is currently being evaluated as a number. Because IOK is set we look at the IV item to see what is in the scalar.</source>
          <target state="translated">이것은 &lt;code&gt;$a&lt;/code&gt; 가 스칼라 인 SV 라고 말합니다 . 스칼라는 숫자 IV입니다. 참조 횟수는 1입니다. &lt;code&gt;IOK&lt;/code&gt; 플래그가 설정되어 있으며 현재 숫자로 평가되고 있습니다. IOK가 설정되었으므로 IV 항목을보고 스칼라에있는 항목을 봅니다.</target>
        </trans-unit>
        <trans-unit id="2536195f9e270d7a0608ccd9b92c67b39acf3e86" translate="yes" xml:space="preserve">
          <source>This says &lt;code&gt;$a&lt;/code&gt; is an SV, a scalar. The scalar type is a PVIV, which is capable of holding an integer (IV) and/or a string (PV) value. The scalar's head is allocated at address 0xbe9a8, while the body is at 0xbc288. Its reference count is 1. It has the &lt;code&gt;POK&lt;/code&gt; flag set, meaning its current PV field is valid. Because POK is set we look at the PV item to see what is in the scalar. The \0 at the end indicate that this PV is properly NUL-terminated. Note that the IV field still contains its old numeric value, but because FLAGS doesn't have IOK set, we must ignore the IV item. CUR indicates the number of characters in the PV. LEN indicates the number of bytes allocated for the PV (at least one more than CUR, because LEN includes an extra byte for the end-of-string marker, then usually rounded up to some efficient allocation unit).</source>
          <target state="translated">이것은 &lt;code&gt;$a&lt;/code&gt; 가 스칼라 인 SV 라고 말합니다 . 스칼라 유형은 PVIV이며 정수 (IV) 및 / 또는 문자열 (PV) 값을 보유 할 수 있습니다. 스칼라의 헤드는 주소 0xbe9a8에 할당되고 본문은 0xbc288에 할당됩니다. 참조 횟수는 1입니다. &lt;code&gt;POK&lt;/code&gt; 가 있습니다.현재 PV 필드가 유효 함을 의미하는 플래그 설정. POK가 설정되었으므로 PV 항목을보고 스칼라에 무엇이 있는지 확인합니다. 끝에있는 \ 0은이 PV가 제대로 NUL로 종료되었음을 나타냅니다. IV 필드에는 여전히 이전 숫자 값이 포함되지만 FLAGS에는 IOK가 설정되어 있지 않으므로 IV 항목을 무시해야합니다. CUR은 PV의 문자 수를 나타냅니다. LEN은 PV에 할당 된 바이트 수를 나타냅니다 (LEN은 문자열 끝 표시자를위한 추가 바이트를 포함하고 일반적으로 일부 효율적인 할당 단위로 반올림되므로).</target>
        </trans-unit>
        <trans-unit id="d4038eb2f65cf90ff5c5db0ff06612a08d942853" translate="yes" xml:space="preserve">
          <source>This says that records are delimited by the string &lt;code&gt;es&lt;/code&gt; . If the file contained the following data:</source>
          <target state="translated">이는 레코드가 문자열 &lt;code&gt;es&lt;/code&gt; 로 구분된다고 말합니다 . 파일에 다음 데이터가 포함 된 경우 :</target>
        </trans-unit>
        <trans-unit id="c3f732b3da7c2a158f6a684ddbc311ca908a5e5b" translate="yes" xml:space="preserve">
          <source>This says what packages are internal to Perl. &lt;code&gt;Carp&lt;/code&gt; will never report an error as being from a line in a package that is internal to Perl. For example:</source>
          <target state="translated">이것은 Perl의 내부에 어떤 패키지가 있는지를 나타냅니다. &lt;code&gt;Carp&lt;/code&gt; 는 Perl 내부의 패키지 라인에서 오류를보고하지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="94c9a814257648d20b0d4f2bf7acb2782a18b6ea" translate="yes" xml:space="preserve">
          <source>This says which packages are internal to Perl's warning system. For generating a full stack backtrace this is the same as being internal to Perl, the stack backtrace will not start inside packages that are listed in &lt;code&gt;%Carp::CarpInternal&lt;/code&gt; . But it is slightly different for the summary message generated by &lt;code&gt;carp&lt;/code&gt; or &lt;code&gt;croak&lt;/code&gt; . There errors will not be reported on any lines that are calling packages in &lt;code&gt;%Carp::CarpInternal&lt;/code&gt; .</source>
          <target state="translated">이것은 어떤 패키지가 Perl의 경고 시스템 내부에 있는지를 나타냅니다. 전체 스택 역 추적을 생성하는 경우 이는 Perl 내부와 동일하며 스택 역 추적은 &lt;code&gt;%Carp::CarpInternal&lt;/code&gt; 나열된 패키지 내부에서 시작되지 않습니다 . 그러나 &lt;code&gt;carp&lt;/code&gt; 또는 &lt;code&gt;croak&lt;/code&gt; 에 의해 생성 된 요약 메시지는 약간 다릅니다 . &lt;code&gt;%Carp::CarpInternal&lt;/code&gt; 에서 패키지를 호출하는 행에는 오류가보고되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="31106a1a20d4ea51da0f7d90c3fe4fb2b5ff8f01" translate="yes" xml:space="preserve">
          <source>This scenario will mostly be applicable to code that is meant to be called from within destructors, asynchronous callbacks, and signal handlers. In such situations, where the code being called has little relation to the surrounding dynamic context, the main program needs to be insulated from errors in the called code, even if they can't be handled intelligently. It may also be useful to do this with code for &lt;code&gt;__DIE__&lt;/code&gt; or &lt;code&gt;__WARN__&lt;/code&gt; hooks, and &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">이 시나리오는 소멸자, 비동기 콜백 및 신호 처리기 내에서 호출되는 코드에 주로 적용됩니다. 호출되는 코드가 주변 동적 컨텍스트와 거의 관련이없는 상황에서, 주 프로그램은 지능적으로 처리 할 수 ​​없더라도 호출 된 코드의 오류로부터 격리되어야합니다. &lt;code&gt;__DIE__&lt;/code&gt; 또는 &lt;code&gt;__WARN__&lt;/code&gt; 후크에 대한 코드를 사용하여이 작업을 수행 하고 함수를 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 것도 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e17cbd723cbdc191dc4fdc562d2ff451e857ff96" translate="yes" xml:space="preserve">
          <source>This script shows how to override the default sorting algorithm that BTREE uses. Instead of using the normal lexical ordering, a case insensitive compare function will be used.</source>
          <target state="translated">이 스크립트는 BTREE가 사용하는 기본 정렬 알고리즘을 재정의하는 방법을 보여줍니다. 일반적인 어휘 순서를 사용하는 대신 대소 문자를 구분하지 않는 비교 기능이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="af317b7379a832e3b0678b6eea769f242beb3e07" translate="yes" xml:space="preserve">
          <source>This script,</source>
          <target state="translated">이 스크립트는</target>
        </trans-unit>
        <trans-unit id="cc448c949fa2502c3de5bd50cf25e079f49a973e" translate="yes" xml:space="preserve">
          <source>This section also applies to other overloaded math packages, like Math::String.</source>
          <target state="translated">이 섹션은 Math :: String과 같은 다른 오버로드 된 수학 패키지에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="be390d54ea95c83e1fca1268a1911351d2f7df4c" translate="yes" xml:space="preserve">
          <source>This section applies fully to Perls starting with v5.22. Various caveats for earlier releases are in the &lt;a href=&quot;#Earlier-releases-caveats&quot;&gt;Earlier releases caveats&lt;/a&gt; subsection below.</source>
          <target state="translated">이 섹션은 v5.22부터 Perls에 완전히 적용됩니다. 이전 릴리스에 대한 다양한 경고는 아래 의 &lt;a href=&quot;#Earlier-releases-caveats&quot;&gt;초기 릴리스 경고&lt;/a&gt; 섹션에 있습니다.</target>
        </trans-unit>
        <trans-unit id="56dd90ab92335c6f36e8ed1d4a60c84c97df21db" translate="yes" xml:space="preserve">
          <source>This section concerns the lookahead and lookbehind assertions. First, a little background.</source>
          <target state="translated">이 섹션에서는 미리보기 및 찾아보기 어설 션에 대해 설명합니다. 먼저 작은 배경.</target>
        </trans-unit>
        <trans-unit id="ab4a7c816ed65ffc082450cf0217f6cf1db2cf6e" translate="yes" xml:space="preserve">
          <source>This section deals with I/O and the &quot;f&quot; issues: filehandles, flushing, formats, and footers.</source>
          <target state="translated">이 섹션에서는 I / O 및 &quot;f&quot;문제 (파일 처리, 플러시, 형식 및 바닥 글)를 다룹니다.</target>
        </trans-unit>
        <trans-unit id="c67dd2be244aa67b2c3982a2251efd0aba82da6e" translate="yes" xml:space="preserve">
          <source>This section deals with general Perl language issues that don't clearly fit into any of the other sections.</source>
          <target state="translated">이 섹션은 다른 섹션에는 명확하게 맞지 않는 일반적인 Perl 언어 문제를 다룹니다.</target>
        </trans-unit>
        <trans-unit id="4dacb0d5b8529783cda24f9a101a291fd790bb1b" translate="yes" xml:space="preserve">
          <source>This section deals with questions related to running web sites, sending and receiving email as well as general networking.</source>
          <target state="translated">이 섹션에서는 웹 사이트 실행, 전자 메일 송수신 및 일반 네트워킹과 관련된 질문을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="b8c7e75fcfcb79fa2aefcfcb9d7bd00c769af0ac" translate="yes" xml:space="preserve">
          <source>This section defines an interface that allows in-memory compression using the</source>
          <target state="translated">이 섹션은 다음을 사용하여 메모리 내 압축이 가능한 인터페이스를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="07d89dd508bd9a1955f604c65746a72fe10cd652" translate="yes" xml:space="preserve">
          <source>This section defines an interface that allows in-memory uncompression using the</source>
          <target state="translated">이 섹션은 다음을 사용하여 메모리 내 압축 해제를 허용하는 인터페이스를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="3243853ef1a289c9e89d976c5c5c21cc63e5a678" translate="yes" xml:space="preserve">
          <source>This section defines the interface available that allows in-memory uncompression using the</source>
          <target state="translated">이 섹션에서는 사용 가능한 메모리 압축 풀기를 허용하는 인터페이스를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="95a0852ba843f17dcbe1940f17029f381d5d77f9" translate="yes" xml:space="preserve">
          <source>This section describes the accuracy/precision handling in Math::Big* as it used to be and as it is now, complete with an explanation of all terms and abbreviations.</source>
          <target state="translated">이 섹션에서는 Math :: Big *의 정확도 / 정밀도 처리에 대해 설명했으며 현재와 마찬가지로 모든 용어와 약어에 대한 설명을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="39aef7a353c321f38285ab3f99461b24884c7fa4" translate="yes" xml:space="preserve">
          <source>This section describes the re-implementation of the tmpnam() and tmpfile() functions described in L</source>
          <target state="translated">이 절에서는 L에 설명 된 tmpnam () 및 tmpfile () 함수의 재 구현에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="5b6ee285a0e0ef806b91b3b763a8498277e66885" translate="yes" xml:space="preserve">
          <source>This section describes the recommended interface for generating temporary files and directories.</source>
          <target state="translated">이 절에서는 임시 파일 및 디렉토리 생성을위한 권장 인터페이스에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="69aa90134b4dce1d696ebb05a6dbb67cf8770a91" translate="yes" xml:space="preserve">
          <source>This section describes the steps to be performed to build PerlCE. You may find additional information about building perl for WinCE at &lt;a href=&quot;http://perlce.sourceforge.net&quot;&gt;http://perlce.sourceforge.net&lt;/a&gt; and some pre-built binaries.</source>
          <target state="translated">이 섹션에서는 PerlCE를 빌드하기 위해 수행 할 단계를 설명합니다. &lt;a href=&quot;http://perlce.sourceforge.net&quot;&gt;http://perlce.sourceforge.net&lt;/a&gt; 및 일부 사전 빌드 된 바이너리 에서 WinCE 용 perl 빌드에 대한 추가 정보를 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="11f3d56c367a6b305dcc2c5edd92d44276e1ff5b" translate="yes" xml:space="preserve">
          <source>This section describes the steps to be performed to build a Perl NLM and other associated NLMs.</source>
          <target state="translated">이 섹션에서는 Perl NLM 및 기타 관련 NLM을 빌드하기 위해 수행되는 단계에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="73c6a4b67a7eaa7527571d5faec72b4bfebc75e4" translate="yes" xml:space="preserve">
          <source>This section documents functions to manipulate CVs which are code-values, or subroutines. For more information, see &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;.</source>
          <target state="translated">이 절에서는 코드 값 또는 서브 루틴 인 CV를 조작하는 기능에 대해 설명합니다. 자세한 정보는 &lt;a href=&quot;perlguts&quot;&gt;perlguts를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="33ac896f6350aabd5af3622467a85a4b6b744251" translate="yes" xml:space="preserve">
          <source>This section gives some details on all extensions that aren't just synonyms for compound-form Unicode properties (for those properties, you'll have to refer to the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr44&quot;&gt;Unicode Standard&lt;/a&gt;.</source>
          <target state="translated">이 섹션에서는 복합 형식의 유니 코드 속성과 동의어가 아닌 모든 확장에 대한 세부 정보를 제공합니다 (해당 속성의 경우 &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr44&quot;&gt;유니 코드 표준&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="954cb379e9610eb88d0cd37b6e5358601612440b" translate="yes" xml:space="preserve">
          <source>This section hopes to clarify how Perl handles quoted constructs. Although the most common reason to learn this is to unravel labyrinthine regular expressions, because the initial steps of parsing are the same for all quoting operators, they are all discussed together.</source>
          <target state="translated">이 섹션에서는 Perl이 인용 된 구문을 처리하는 방법을 명확하게 설명하려고합니다. 이것을 배우는 가장 일반적인 이유는 미로 정규 표현식을 풀기위한 것이지만, 파싱의 초기 단계는 모든 인용 연산자에 대해 동일하기 때문에 모두 함께 논의됩니다.</target>
        </trans-unit>
        <trans-unit id="7547891b2c07526eb3624e622a75bf7d7cccf2c6" translate="yes" xml:space="preserve">
          <source>This section is about functions (really macros) that classify characters into types, such as punctuation versus alphabetic, etc. Most of these are analogous to regular expression character classes. (See &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;POSIX Character Classes in perlrecharclass&lt;/a&gt;.) There are several variants for each class. (Not all macros have all variants; each item below lists the ones valid for it.) None are affected by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; , and only the ones with &lt;code&gt;LC&lt;/code&gt; in the name are affected by the current locale.</source>
          <target state="translated">이 섹션은 문장 부호 대 알파벳 등의 문자를 유형으로 분류하는 함수 (실제 매크로)에 관한 것입니다. 대부분은 정규 표현식 문자 클래스와 유사합니다. ( &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;perlrecharclass의 POSIX 문자 클래스를&lt;/a&gt; 참조하십시오 .) 각 클래스마다 몇 가지 변형이 있습니다. 모든 매크로에 모든 변형이있는 것은 아니며 아래 각 항목에 유효한 매크로가 나열되어 있습니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용의&lt;/a&gt; 영향은 없으며 이름에 &lt;code&gt;LC&lt;/code&gt; 가있는 것만 현재 로케일의 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="d919f2203b8f136316a99d5a21a115c2a5759b1a" translate="yes" xml:space="preserve">
          <source>This section is intended to supplement and clarify the discussion in &lt;a href=&quot;perlpod#Command-Paragraph&quot;&gt;Command Paragraph in perlpod&lt;/a&gt;. These are the currently recognized Pod commands:</source>
          <target state="translated">이 섹션은 &lt;a href=&quot;perlpod#Command-Paragraph&quot;&gt;perlpod의 Command Paragraph에&lt;/a&gt; 대한 논의를 보완하고 명확하게하기위한 것 입니다. 다음은 현재 인식되는 포드 명령입니다.</target>
        </trans-unit>
        <trans-unit id="12d39af9317de3b208731a0e9f6172ef3ca0985f" translate="yes" xml:space="preserve">
          <source>This section is just an outline of some of the things code in a compartment might do (intentionally or unintentionally) which can have an effect outside the compartment.</source>
          <target state="translated">이 섹션은 컴 파트먼트의 코드가 의도적이거나 의도하지 않은 방식으로 컴 파트먼트 외부에 영향을 줄 수있는 작업 중 일부에 대한 개요입니다.</target>
        </trans-unit>
        <trans-unit id="afce53c6f9505fd215e3565d5b9cbd7590482493" translate="yes" xml:space="preserve">
          <source>This section is only necessary for those who want to write a compiler backend module that can be used via this module.</source>
          <target state="translated">이 섹션은이 모듈을 통해 사용할 수있는 컴파일러 백엔드 모듈을 작성하려는 사람들에게만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1d2dead1ebaa9a0daf17a7735104700bab6a62c1" translate="yes" xml:space="preserve">
          <source>This section is only relevant if you want to use the &lt;code&gt;FOOBAR::DATA&lt;/code&gt; together with the &lt;b&gt;SelfLoader&lt;/b&gt;.</source>
          <target state="translated">이 섹션은 &lt;code&gt;FOOBAR::DATA&lt;/code&gt; &lt;b&gt;SelfLoader&lt;/b&gt; 와 함께 사용하려는 경우에만 관련이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6b8111cc382b6e222eab22ae8b7285382f21bba0" translate="yes" xml:space="preserve">
          <source>This section is surprisingly small because the rest of the FAQ is littered with answers involving regular expressions. For example, decoding a URL and checking whether something is a number can be handled with regular expressions, but those answers are found elsewhere in this document (in &lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt;: &quot;How do I decode or create those %-encodings on the web&quot; and &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt;: &quot;How do I determine whether a scalar is a number/whole/integer/float&quot;, to be precise).</source>
          <target state="translated">이 섹션은 놀랍게도 작습니다. FAQ의 나머지 부분에는 정규 표현식과 관련된 답변이 포함되어 있기 때문입니다. 예를 들어, URL을 디코딩하고 숫자인지 확인하는 것은 정규 표현식으로 처리 할 수 ​​있지만이 답변은이 문서의 다른 부분에서 찾을 수 있습니다 ( &lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt; : &quot;웹에서 이러한 %-인코딩을 디코딩하거나 작성하는 방법&quot;및 &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4).&lt;/a&gt; : &quot;스칼라가 숫자 / 전체 / 정수 / 부동인지 어떻게 알 수 있습니까?&quot;)</target>
        </trans-unit>
        <trans-unit id="e488b03478a9d4c34a486aa35881d2d7c336d0b6" translate="yes" xml:space="preserve">
          <source>This section is surprisingly small because the rest of the FAQ is littered with answers involving regular expressions. For example, decoding a URL and checking whether something is a number can be handled with regular expressions, but those answers are found elsewhere in this document (in perlfaq9 : &quot;How do I decode or create those %-encodings on the web&quot; and perlfaq4 : &quot;How do I determine whether a scalar is a number/whole/integer/float&quot;, to be precise).</source>
          <target state="translated">이 섹션은 놀랍게도 작습니다. FAQ의 나머지 부분에는 정규 표현식과 관련된 답변이 포함되어 있기 때문입니다. 예를 들어, URL을 디코딩하고 숫자인지 확인하는 것은 정규 표현식으로 처리 할 수 ​​있지만이 답변은이 문서의 다른 부분에서 찾을 수 있습니다 (perlfaq9 : &quot;웹에서 이러한 %-인코딩을 디코딩하거나 작성하는 방법&quot;및 perlfaq4). : &quot;스칼라가 숫자 / 전체 / 정수 / 부동인지 어떻게 알 수 있습니까?&quot;)</target>
        </trans-unit>
        <trans-unit id="94757c3cee869d3cff315104b19f6299d40770f6" translate="yes" xml:space="preserve">
          <source>This section of the FAQ answers questions about where to find source and documentation for Perl, support, and related matters.</source>
          <target state="translated">이 FAQ 섹션에서는 Perl, 지원 및 관련 문제에 대한 소스 및 문서를 찾을 수있는 위치에 대한 질문에 답변합니다.</target>
        </trans-unit>
        <trans-unit id="dd108d0d127c5d70473c9d7274a370ea63329739" translate="yes" xml:space="preserve">
          <source>This section of the FAQ answers questions related to manipulating numbers, dates, strings, arrays, hashes, and miscellaneous data issues.</source>
          <target state="translated">이 FAQ 섹션에서는 숫자, 날짜, 문자열, 배열, 해시 및 기타 데이터 문제 조작과 관련된 질문에 답변합니다.</target>
        </trans-unit>
        <trans-unit id="43d6c325f900a7d6a933d383734e7454f02fa808" translate="yes" xml:space="preserve">
          <source>This section of the FAQ answers questions related to programmer tools and programming support.</source>
          <target state="translated">이 FAQ 섹션은 프로그래머 도구 및 프로그래밍 지원과 관련된 질문에 답변합니다.</target>
        </trans-unit>
        <trans-unit id="8c63d2f74bc0df3e2938dcd3a6724a679f1d5b9f" translate="yes" xml:space="preserve">
          <source>This section of the FAQ answers very general, high-level questions about Perl.</source>
          <target state="translated">이 FAQ 섹션은 Perl에 대한 매우 일반적인 고급 질문에 대한 답변입니다.</target>
        </trans-unit>
        <trans-unit id="f91732cbb36111757913713f2dd27264f7f4075b" translate="yes" xml:space="preserve">
          <source>This section of the Perl FAQ covers questions involving operating system interaction. Topics include interprocess communication (IPC), control over the user-interface (keyboard, screen and pointing devices), and most anything else not related to data manipulation.</source>
          <target state="translated">Perl FAQ의이 섹션은 운영 체제 상호 작용과 관련된 질문을 다룹니다. 프로세스 간 통신 (IPC), 사용자 인터페이스 제어 (키보드, 화면 및 포인팅 장치) 및 데이터 조작과 관련이없는 대부분의 항목이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d25ee711a891d2493e43b730a8ee5f38afba1662" translate="yes" xml:space="preserve">
          <source>This section only applies to you if you have existing data written out by Storable 2.02 or earlier on perl 5.6.0 or 5.6.1 on Unix or Linux which has been configured with 64 bit integer support (not the default) If you got a precompiled perl, rather than running Configure to build your own perl from source, then it almost certainly does not affect you, and you can stop reading now (unless you're curious). If you're using perl on Windows it does not affect you.</source>
          <target state="translated">이 섹션은 64 비트 정수 지원 (기본값 아님)으로 구성된 유닉스 또는 Linux에서 perl 5.6.0 또는 5.6.1에서 Storable 2.02 이전 버전으로 작성된 기존 데이터가있는 경우에만 적용됩니다 (사전 컴파일되지 않은 경우). perl, 소스를 사용하여 자신 만의 perl을 빌드하도록 구성을 실행하는 것보다는 거의 확실하게 영향을 미치지 않으며, 궁금한 경우가 아니라면 지금 읽기를 중단 할 수 있습니다. Windows에서 perl을 사용하는 경우 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5b9a6489148fff3cc80ff958733f7f998b0b3cdf" translate="yes" xml:space="preserve">
          <source>This server accepts one of five different commands, sending output back to the client. Unlike most network servers, this one handles only one incoming client at a time. Multitasking servers are covered in Chapter 16 of the Camel.</source>
          <target state="translated">이 서버는 다섯 가지 명령 중 하나를 받아 들여 클라이언트로 출력을 보냅니다. 대부분의 네트워크 서버와 달리이 서버는 한 번에 하나의 수신 클라이언트 만 처리합니다. 멀티 태스킹 서버는 Camel의 16 장에서 다룹니다.</target>
        </trans-unit>
        <trans-unit id="ffb206fa8662fa49c173d5f9d350cc23a1d8b5c6" translate="yes" xml:space="preserve">
          <source>This server takes the trouble to clone off a child version via fork() for each incoming request. That way it can handle many requests at once, which you might not always want. Even if you don't fork(), the listen() will allow that many pending connections. Forking servers have to be particularly careful about cleaning up their dead children (called &quot;zombies&quot; in Unix parlance), because otherwise you'll quickly fill up your process table. The REAPER subroutine is used here to call waitpid() for any child processes that have finished, thereby ensuring that they terminate cleanly and don't join the ranks of the living dead.</source>
          <target state="translated">이 서버는 들어오는 각 요청에 대해 fork ()를 통해 하위 버전을 복제하는 데 어려움을 겪습니다. 그렇게하면 한 번에 많은 요청을 처리 할 수 ​​있으며 항상 원치 않을 수도 있습니다. fork ()를하지 않더라도 listen ()은 보류중인 많은 연결을 허용합니다. 포크 서버는 프로세스 테이블을 빠르게 채울 수 있기 때문에 죽은 자식 (유닉스 용어에서 &quot;좀비&quot;라고 함)을 정리하는 데 특히주의해야합니다. REAPER 서브 루틴은 여기에서 완료된 모든 하위 프로세스에 대해 waitpid ()를 호출하여 깨끗하게 종료되고 살아있는 사람의 순위에 합류하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="3c5ebe323e1cea15acbe8beafe841f6d123af5cf" translate="yes" xml:space="preserve">
          <source>This set of instructions is meant to describe a so-called &quot;native&quot; port of Perl to the Windows platform. This includes both 32-bit and 64-bit Windows operating systems. The resulting Perl requires no additional software to run (other than what came with your operating system). Currently, this port is capable of using one of the following compilers on the Intel x86 architecture:</source>
          <target state="translated">이 지시 사항 세트는 Windows 플랫폼에 대한 소위 &quot;기본&quot;포트 Perl을 설명하기위한 것입니다. 여기에는 32 비트 및 64 비트 Windows 운영 체제가 모두 포함됩니다. 결과 Perl은 운영 체제와 함께 제공된 소프트웨어 외에 추가 소프트웨어를 실행할 필요가 없습니다. 현재이 포트는 Intel x86 아키텍처에서 다음 컴파일러 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8777023fd72f0e0c5194df7056fed5f92ab1ed79" translate="yes" xml:space="preserve">
          <source>This sets &lt;code&gt;$\&lt;/code&gt; to newline and then sets &lt;code&gt;$/&lt;/code&gt; to the null character.</source>
          <target state="translated">이 세트 &lt;code&gt;$\&lt;/code&gt; 줄 바꿈과는 설정 &lt;code&gt;$/&lt;/code&gt; 널 문자로.</target>
        </trans-unit>
        <trans-unit id="4549dd71bcce8b09d1c070ffac130c9cb9eed0b2" translate="yes" xml:space="preserve">
          <source>This sets a variable in op/numconvert.t.</source>
          <target state="translated">op / numconvert.t에 변수를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="df79d9971c873dd56e1affe3565f833f5f4ef4be" translate="yes" xml:space="preserve">
          <source>This sets the</source>
          <target state="translated">이것은</target>
        </trans-unit>
        <trans-unit id="cc422551baf5bd378e1441e1ffd937104c35c5d0" translate="yes" xml:space="preserve">
          <source>This sets the accuracy for all math operations. The argument must be greater than or equal to zero. See Math::BigInt's bround() function for details.</source>
          <target state="translated">모든 수학 연산의 정확도를 설정합니다. 인수는 0보다 크거나 같아야합니다. 자세한 내용은 Math :: BigInt의 bround () 함수를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3b2057b585966ee5e34a71b1fcc4af8dffd8aef3" translate="yes" xml:space="preserve">
          <source>This sets the default per-thread stack size at the start of the application.</source>
          <target state="translated">응용 프로그램 시작시 스레드 별 기본 스택 크기를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="d80f3ae97beba02bd7de41d9d2bef09e8032704e" translate="yes" xml:space="preserve">
          <source>This sets the filehandle that &lt;code&gt;$parser&lt;/code&gt; 's output will be written to. You can pass &lt;code&gt;*STDOUT&lt;/code&gt; or &lt;code&gt;*STDERR&lt;/code&gt; , otherwise you should probably do something like this:</source>
          <target state="translated">이것은 &lt;code&gt;$parser&lt;/code&gt; 의 출력이 쓰여질 파일 핸들을 설정합니다 . &lt;code&gt;*STDOUT&lt;/code&gt; 또는 &lt;code&gt;*STDERR&lt;/code&gt; 을 전달할 수 있습니다 . 그렇지 않으면 다음과 같이해야합니다.</target>
        </trans-unit>
        <trans-unit id="af102c7f2132a623b34e9347ca5e8597fbe36895" translate="yes" xml:space="preserve">
          <source>This sets the language code to tag this document as being in. By default, it is currently the value of the environment variable &lt;code&gt;RTFDEFLANG&lt;/code&gt; , or if that's not set, then the value 1033 (for US English).</source>
          <target state="translated">이 코드는이 문서에있는 언어 태그를 설정합니다. 기본적으로 현재 환경 변수 &lt;code&gt;RTFDEFLANG&lt;/code&gt; 의 값 이거나 설정되지 않은 경우 값 1033 (미국 영어의 경우)입니다.</target>
        </trans-unit>
        <trans-unit id="529a10bfb87aaa836949c559d932aa868d0ea517" translate="yes" xml:space="preserve">
          <source>This sets the precision for all math operations. The argument can be any integer. Negative values mean a fixed number of digits after the dot, and are &amp;lt;B&amp;gt;ignored&amp;lt;/B&amp;gt; since all operations happen in integer space. A positive value rounds to this digit left from the dot. 0 or 1 mean round to integer and are ignore like negative values.</source>
          <target state="translated">모든 수학 연산의 정밀도를 설정합니다. 인수는 정수일 수 있습니다. 음수 값은 점 뒤에 고정 된 자릿수를 의미하며 모든 연산이 정수 공간에서 발생하므로 &amp;lt;B&amp;gt; 무시 &amp;lt;/ B&amp;gt;됩니다. 양수 값은 점에서 왼쪽으로이 숫자로 반올림합니다. 0 또는 1은 정수로 반올림하며 음수 값처럼 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="674e5733f608427771b5b90d6f64c3b452aa5b35" translate="yes" xml:space="preserve">
          <source>This sets the precision for all math operations. The argument can be any integer. Negative values mean a fixed number of digits after the dot, while a positive value rounds to this digit left from the dot. 0 or 1 mean round to integer. See Math::BigInt's bfround() function for details.</source>
          <target state="translated">모든 수학 연산의 정밀도를 설정합니다. 인수는 정수일 수 있습니다. 음수 값은 점 뒤에 고정 된 자릿수를 의미하고 양수 값은 점에서 왼쪽으로이 숫자로 반올림합니다. 0 또는 1은 정수로 반올림합니다. 자세한 내용은 Math :: BigInt의 bfround () 함수를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7b5668a047104c30653c0804d67e484bf29d90cb" translate="yes" xml:space="preserve">
          <source>This sets the soft and hard limits to 10 and 20 seconds, respectively. After 10 seconds of time spent running on the CPU (not &quot;wall&quot; time), the process will be sent a signal (XCPU on some systems) which, if not trapped, will cause the process to terminate. If that signal is trapped, then after 10 more seconds (20 seconds in total) the process will be killed with a non-trappable signal.</source>
          <target state="translated">소프트 및 하드 제한을 각각 10 초와 20 초로 설정합니다. &quot;벽&quot;시간이 아닌 CPU에서 10 초의 시간을 소비 한 후 프로세스는 트랩되지 않은 경우 프로세스를 종료시키는 신호 (일부 시스템의 XCPU)를 전송합니다. 해당 신호가 포착되면 10 초 이상 (총 20 초) 후에 트랩 할 수없는 신호로 프로세스가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="130c125b35cf3d3da34044cd207b5628dc2ffac8" translate="yes" xml:space="preserve">
          <source>This sets the string that &lt;code&gt;$parser&lt;/code&gt; 's output will be sent to, instead of any filehandle.</source>
          <target state="translated">이것은 파일 핸들 대신 &lt;code&gt;$parser&lt;/code&gt; 출력이 전송 될 문자열을 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="ce02c4df1fe3dcc67a7d36b7b1e441cff60cc978" translate="yes" xml:space="preserve">
          <source>This sets what class is used for rendering the files. The default is &quot;Pod::Simple::HTML&quot;. If you set it to something else, it should probably be a subclass of Pod::Simple::HTML, and you should &lt;code&gt;&lt;a href=&quot;../../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; that class so that's it's loaded before Pod::Simple::HTMLBatch tries loading it.</source>
          <target state="translated">파일 렌더링에 사용되는 클래스를 설정합니다. 기본값은 &quot;Pod :: Simple :: HTML&quot;입니다. 다른 것으로 설정하면 아마도 Pod :: Simple :: HTML의 서브 클래스 여야하고 Pod :: Simple :: HTMLBatch가로드를 시도하기 전에로드되도록 해당 클래스를 &lt;code&gt;&lt;a href=&quot;../../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 하거나 &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="ec1e3d22ca8911a43038e77812f3f3938f114390" translate="yes" xml:space="preserve">
          <source>This sets what class is used for searching for the files. The default is &quot;Pod::Simple::Search&quot;. If you set it to something else, it should probably be a subclass of Pod::Simple::Search, and you should &lt;code&gt;&lt;a href=&quot;../../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; that class so that's it's loaded before Pod::Simple::HTMLBatch tries loading it.</source>
          <target state="translated">파일 검색에 사용되는 클래스를 설정합니다. 기본값은 &quot;Pod :: Simple :: Search&quot;입니다. 다른 것으로 설정하면 아마도 Pod :: Simple :: Search의 서브 클래스 여야하고 Pod :: Simple :: HTMLBatch가로드를 시도하기 전에로드되도록 해당 클래스를 &lt;code&gt;&lt;a href=&quot;../../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 하거나 &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="0ef0f761ac69580bceb47730cfb76aca36efdbeb" translate="yes" xml:space="preserve">
          <source>This shares the variable(s) in the argument list with the compartment. This is almost identical to exporting variables using the &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; module.</source>
          <target state="translated">인수 목록의 변수를 구획과 공유합니다. &lt;a href=&quot;exporter&quot;&gt;내보내기&lt;/a&gt; 모듈을 사용하여 변수를 내보내는 것과 거의 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="3d3464b620ba9f7ef03d81ee4683ae7ba242d757" translate="yes" xml:space="preserve">
          <source>This should &lt;b&gt;ONLY&lt;/b&gt; be used on memory obtained using &lt;a href=&quot;#Newx&quot;&gt;Newx&lt;/a&gt; and friends.</source>
          <target state="translated">이것은 &lt;a href=&quot;#Newx&quot;&gt;Newx&lt;/a&gt; 와 친구들을 사용하여 얻은 메모리 &lt;b&gt;에서만&lt;/b&gt; 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d79a68f01e1702d7ec1c9976d188db9c7f2aece8" translate="yes" xml:space="preserve">
          <source>This should allow read/write access to any files that are extracted from the zip file/buffer`.</source>
          <target state="translated">이것은 zip 파일 / 버퍼에서 추출 된 모든 파일에 대한 읽기 / 쓰기 액세스를 허용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b4bc0e6df3ccf75b9d4b22bada1e150f1c0bf5e1" translate="yes" xml:space="preserve">
          <source>This should be fixed already.</source>
          <target state="translated">이것은 이미 수정되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="d375da43f6c63dd4302e9f62a049ebffa1351990" translate="yes" xml:space="preserve">
          <source>This should be interpreted as '&lt;code&gt;PVOP&lt;/code&gt; ' only. The &lt;code&gt;_OR_SVOP&lt;/code&gt; is because the only core &lt;code&gt;PVOP&lt;/code&gt; , &lt;code&gt;OP_TRANS&lt;/code&gt; , can sometimes be a &lt;code&gt;SVOP&lt;/code&gt; instead.</source>
          <target state="translated">이것은 ' &lt;code&gt;PVOP&lt;/code&gt; '로만 해석되어야합니다 . &lt;code&gt;_OR_SVOP&lt;/code&gt; 는 유일한 핵심 때문이다 &lt;code&gt;PVOP&lt;/code&gt; , &lt;code&gt;OP_TRANS&lt;/code&gt; 이 , 때로는 될 수 &lt;code&gt;SVOP&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="13a5db63688f7fa372582799c1bd3dfdaa3ba0cd" translate="yes" xml:space="preserve">
          <source>This should be replaced by the full path to your clang executable if it is not in your path.</source>
          <target state="translated">경로에없는 경우 clang 실행 파일의 전체 경로로 바꿔야합니다.</target>
        </trans-unit>
        <trans-unit id="b5a95a55a5803d791f964bba2e2a1d75b4c88370" translate="yes" xml:space="preserve">
          <source>This should be the first thing you call in your test script. It declares your testing plan, how many there will be, if any of them should be allowed to fail, and so on.</source>
          <target state="translated">테스트 스크립트에서 가장 먼저 호출해야합니다. 테스트 계획, 계획 수, 실패 여부 등을 선언합니다.</target>
        </trans-unit>
        <trans-unit id="c0f01ea79ad3c782b34e1c39edb42ab144bd80b0" translate="yes" xml:space="preserve">
          <source>This should build everything. Specifically, it will create perl.exe, perl522.dll at the perl toplevel, and various other extension dll's under the lib\auto directory. If the build fails for any reason, make sure you have done the previous steps correctly.</source>
          <target state="translated">이것은 모든 것을 구축해야합니다. 특히 perl.exe, perl522.dll을 perl 최상위 수준에 만들고 다양한 기타 확장 dll을 lib \ auto 디렉토리에 만듭니다. 어떤 이유로 든 빌드가 실패하면 이전 단계를 올바르게 수행했는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="30ba9060ffc1293bd461e0db035bb80a563a059f" translate="yes" xml:space="preserve">
          <source>This should build miniperl and then fail when it tries to run it.</source>
          <target state="translated">miniperl을 빌드 한 다음 실행하려고하면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="678375f3c34a52f1c875afc4e9a5d9d1a7cc959a" translate="yes" xml:space="preserve">
          <source>This should create an executable</source>
          <target state="translated">이것은 실행 파일을 만들어야합니다</target>
        </trans-unit>
        <trans-unit id="0343ed053df7e2ae641054c461a6d9ef120ebfaa" translate="yes" xml:space="preserve">
          <source>This should match any sequences of characters that aren't &lt;code&gt;\xDF&lt;/code&gt; nor what &lt;code&gt;\xDF&lt;/code&gt; matches under &lt;code&gt;/i&lt;/code&gt;. &lt;code&gt;&quot;s&quot;&lt;/code&gt; isn't &lt;code&gt;\xDF&lt;/code&gt; , but Unicode says that &lt;code&gt;&quot;ss&quot;&lt;/code&gt; is what &lt;code&gt;\xDF&lt;/code&gt; matches under &lt;code&gt;/i&lt;/code&gt;. So which one &quot;wins&quot;? Do you fail the match because the string has &lt;code&gt;ss&lt;/code&gt; or accept it because it has an &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; followed by another &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;? Perl has chosen the latter. (See note in &lt;a href=&quot;#Bracketed-Character-Classes&quot;&gt;Bracketed Character Classes&lt;/a&gt; above.)</source>
          <target state="translated">이는 &lt;code&gt;\xDF&lt;/code&gt; 가 아닌 문자 와 &lt;code&gt;/i&lt;/code&gt; 에서 &lt;code&gt;\xDF&lt;/code&gt; 일치 하는 문자 시퀀스와 일치해야합니다 . &lt;code&gt;&quot;s&quot;&lt;/code&gt; 는 &lt;code&gt;\xDF&lt;/code&gt; 가 아니지만, 유니 코드에 따르면 &lt;code&gt;&quot;ss&quot;&lt;/code&gt; 는 &lt;code&gt;\xDF&lt;/code&gt; 가 &lt;code&gt;/i&lt;/code&gt; 에서 일치하는 것 입니다. 어느 쪽이 &quot;승리&quot;합니까? 문자열에 &lt;code&gt;ss&lt;/code&gt; 가 있기 때문에 일치하지 않거나 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 가 있고 다른 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 가 있기 때문에 수락 합니까? 펄은 후자를 선택했다. ( 위의 &lt;a href=&quot;#Bracketed-Character-Classes&quot;&gt;괄호로 묶은 문자 클래스의&lt;/a&gt; 참고 사항을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="050396cf8762718cb34435af8d06d17eb8dd7bc6" translate="yes" xml:space="preserve">
          <source>This should not be used to supply default values for parameters. One would normally use this when a function parameter must be processed by another library function before it can be used. Default parameters are covered in the next section.</source>
          <target state="translated">매개 변수의 기본값을 제공하는 데 사용해서는 안됩니다. 함수 매개 변수를 사용하기 전에 다른 라이브러리 함수에서 처리해야하는 경우 일반적으로이를 사용합니다. 기본 매개 변수는 다음 섹션에서 다룹니다.</target>
        </trans-unit>
        <trans-unit id="8b1ca7922101edcce2a492b3a6c129abd8a583e6" translate="yes" xml:space="preserve">
          <source>This should only be necessary if</source>
          <target state="translated">이 경우에만 필요합니다</target>
        </trans-unit>
        <trans-unit id="598f32a1125324d2a241a1c920bc050b40fac3d7" translate="yes" xml:space="preserve">
          <source>This should rarely be necessary, as the Perl &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; function is to be used for things that Perl opened itself, even if it was a dup of a numeric descriptor as with &lt;code&gt;MHCONTEXT&lt;/code&gt; above. But if you really have to, you may be able to do this:</source>
          <target state="translated">Perl &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; 함수는 위의 &lt;code&gt;MHCONTEXT&lt;/code&gt; 에서와 같이 숫자 설명 자의 dup이더라도 Perl 자체에서 열린 것에 사용 되므로 거의 필요하지 않습니다 . 그러나 정말로해야 할 경우 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7c7e9b83cb4841b6e6724c1f7e531bbbc2b68cb" translate="yes" xml:space="preserve">
          <source>This shows &lt;code&gt;$a&lt;/code&gt; is a reference pointing to an SV. That SV is a PVHV, a hash. Fields RITER and EITER are used by &lt;code&gt;&lt;a href=&quot;../functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;$a&lt;/code&gt; 가 SV를 가리키는 참조 임을 나타냅니다 . 그 SV는 해시 인 PVHV입니다. RITER 및 EITER 필드는 &lt;code&gt;&lt;a href=&quot;../functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4544b90fccd9dc8117d7d96fcbc15a1ca629dfae" translate="yes" xml:space="preserve">
          <source>This shows that</source>
          <target state="translated">이것은</target>
        </trans-unit>
        <trans-unit id="b55aa05d72ea8d4828d039cb967e2a4c2c9f3f35" translate="yes" xml:space="preserve">
          <source>This shows that we have an SV which is a reference, which points at another SV. In this case that second SV is a PVMG, a blessed scalar. Because it is blessed it has the &lt;code&gt;OBJECT&lt;/code&gt; flag set. Note that an SV which holds a C pointer also has the &lt;code&gt;IOK&lt;/code&gt; flag set. The &lt;code&gt;STASH&lt;/code&gt; is set to the package name which this SV was blessed into.</source>
          <target state="translated">이것은 우리가 다른 SV를 가리키는 참조 인 SV를 가지고 있음을 보여줍니다. 이 경우 두 번째 SV는 축복 스칼라 인 PVMG입니다. 복이 있기 때문에 &lt;code&gt;OBJECT&lt;/code&gt; 플래그가 설정되어 있습니다. C 포인터를 보유한 SV에도 &lt;code&gt;IOK&lt;/code&gt; 플래그가 설정되어 있습니다. &lt;code&gt;STASH&lt;/code&gt; 이 SV가에 축복 된 패키지 이름으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="d6b36418bf4797a5df13199701553bd6ebeff202" translate="yes" xml:space="preserve">
          <source>This shows the sorts of output the &lt;code&gt;l&lt;/code&gt; command can produce:</source>
          <target state="translated">&lt;code&gt;l&lt;/code&gt; 명령이 생성 할 수있는 출력 종류를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="220ae5d1e65680423ed0fee8d1ae71265a4673d1" translate="yes" xml:space="preserve">
          <source>This shows the variables used in the subroutine &lt;code&gt;clear_noremap&lt;/code&gt; . The variable &lt;code&gt;$ready_to_print&lt;/code&gt; is a my() (lexical) variable, &lt;b&gt;i&lt;/b&gt;ntroduced (first declared with my()) on line 1069, and used on line 1079. The variable &lt;code&gt;$&amp;amp;&lt;/code&gt; from the main package is used on 1086, and so on.</source>
          <target state="translated">서브 루틴 &lt;code&gt;clear_noremap&lt;/code&gt; 에 사용 된 변수를 보여줍니다 . 변수의 &lt;code&gt;$ready_to_print&lt;/code&gt; A가 내 () (어휘) 변수이며, &lt;b&gt;내가&lt;/b&gt; ntroduced 라인 1069에와 변수 라인 1079에 사용 (첫째 내 ()로 선언) &lt;code&gt;$&amp;amp;&lt;/code&gt; 메인 패키지 등 1086에 사용되며, .</target>
        </trans-unit>
        <trans-unit id="e3a1a612c118404300b4fc88e912d956be940f47" translate="yes" xml:space="preserve">
          <source>This shows us two libraries being updated and two being added, one of which has an undefined version in the right-hand side version.</source>
          <target state="translated">이것은 두 개의 라이브러리가 업데이트되고 두 개의 라이브러리가 추가되고 있음을 보여줍니다. 그 중 하나는 오른쪽 버전에 정의되지 않은 버전이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9392876266258935c97915a0016be1ab3e077a8" translate="yes" xml:space="preserve">
          <source>This shows what a reference looks like when it references a simple scalar.</source>
          <target state="translated">간단한 스칼라를 참조 할 때 참조 모양을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="62c1dd6d2092bdafabfdd27d34aabe7eb07a45cc" translate="yes" xml:space="preserve">
          <source>This shows what a reference to an array looks like.</source>
          <target state="translated">배열에 대한 참조 모양을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="19b0c298e2bbc25317cee46892abecba84a7892d" translate="yes" xml:space="preserve">
          <source>This signifies that this entry should be replaced by the decompositions for all the code points whose decomposition is algorithmically calculated. (All of them are currently in one range and no others outside the range are likely to ever be added to Unicode; the &lt;code&gt;&quot;n&quot;&lt;/code&gt; format has this same entry.) These can be generated via the function &lt;a href=&quot;normalize&quot;&gt;Unicode::Normalize::NFD()&lt;/a&gt;.</source>
          <target state="translated">이는 분해가 알고리즘 적으로 계산되는 모든 코드 포인트에 대해이 항목이 분해로 대체되어야 함을 나타냅니다. (이들 모두는 현재 한 범위에 있고 범위 밖의 다른 것은 유니 코드에 추가 될 가능성이 없습니다. &lt;code&gt;&quot;n&quot;&lt;/code&gt; 형식은 동일한 항목을 갖습니다.) &lt;a href=&quot;normalize&quot;&gt;유니 코드 :: Normalize :: NFD ( )&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8a3ee18b62d8c4cf82c2682ec3f88357d163d3e8" translate="yes" xml:space="preserve">
          <source>This silent implicit decoding is known as &quot;upgrading&quot;. That may sound positive, but it's best to avoid it.</source>
          <target state="translated">이 자동 암시 적 디코딩을 &quot;업그레이드&quot;라고합니다. 긍정적 인 것처럼 들리지만 피하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="75ceec87638702fc9211fcbb47c663ad2b557d5f" translate="yes" xml:space="preserve">
          <source>This simplifies the reverse operation as the number of repetitions can be unpacked with the &lt;code&gt;/&lt;/code&gt; code:</source>
          <target state="translated">&lt;code&gt;/&lt;/code&gt; 코드를 사용하여 반복 횟수를 풀 수 있으므로 역 동작이 간단 해집니다 .</target>
        </trans-unit>
        <trans-unit id="c76a52e49b25fb93c5814da39f8a0ca4f090ec45" translate="yes" xml:space="preserve">
          <source>This simply calls &lt;code&gt;sv_magic&lt;/code&gt; and coerces the &lt;code&gt;gv&lt;/code&gt; argument into an &lt;code&gt;SV&lt;/code&gt; .</source>
          <target state="translated">이것은 단순히 &lt;code&gt;sv_magic&lt;/code&gt; 을 호출 하고 &lt;code&gt;gv&lt;/code&gt; 인수를 &lt;code&gt;SV&lt;/code&gt; 로 강제 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="15c5bc95dce18ddda2693ffc0b4a16e21790eea4" translate="yes" xml:space="preserve">
          <source>This simply evaluates any expression (&lt;code&gt;$got eq $expected&lt;/code&gt; is just a simple example) and uses that to determine if the test succeeded or failed. A true expression passes, a false one fails. Very simple.</source>
          <target state="translated">이것은 단순히 모든 표현식을 평가하고 ( &lt;code&gt;$got eq $expected&lt;/code&gt; 는 단순한 예일뿐)이를 사용하여 테스트의 성공 또는 실패 여부를 판별합니다. 진정한 표현은 통과하고, 거짓 표현은 실패합니다. 매우 간단합니다.</target>
        </trans-unit>
        <trans-unit id="3d969d8fe90ed0cdf3881a37bda779e5984f6b64" translate="yes" xml:space="preserve">
          <source>This simply passes the C representation of the Perl variable (an SV*) in and out of the XS layer. This can be used if the C code wants to deal directly with the Perl variable.</source>
          <target state="translated">이는 XS 계층 안팎으로 Perl 변수 (SV *)의 C 표현을 전달합니다. C 코드가 Perl 변수를 직접 처리하려는 경우에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e6d63f50f6edf8d1ca7caa25f784dd03a42ad6f" translate="yes" xml:space="preserve">
          <source>This simultaneously affects all threads of the program, so it may be problematic to use locales in threaded applications except where there is a single locale applicable to all threads.</source>
          <target state="translated">이것은 동시에 프로그램의 모든 스레드에 영향을 미치므로 모든 스레드에 적용 가능한 단일 로캘이있는 경우를 제외하고 스레드 응용 프로그램에서 로캘을 사용하는 것이 문제가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39e7f436f0844c6bf989784164030c8f8ea5c91c" translate="yes" xml:space="preserve">
          <source>This software enables you to upgrade software on your computer and so is inherently dangerous because the newly installed software may contain bugs and may alter the way your computer works or even make it unusable. Please consider backing up your data before every upgrade.</source>
          <target state="translated">이 소프트웨어를 사용하면 컴퓨터에서 소프트웨어를 업그레이드 할 수 있으므로 새로 설치된 소프트웨어에 버그가 포함되어 컴퓨터 작동 방식을 변경하거나 사용하지 못하게 될 수 있으므로 본질적으로 위험합니다. 업그레이드 할 때마다 데이터 백업을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="95b86ac068430d7abe3629291f82ebff76fb040f" translate="yes" xml:space="preserve">
          <source>This software is copyright (c) 1996- by Andreas Koenig.</source>
          <target state="translated">이 소프트웨어는 Andreas Koenig에 의해 저작권이 있습니다 (c) 1996-.</target>
        </trans-unit>
        <trans-unit id="67032da8813d4f4a0a08f93013ebb3760de4d75d" translate="yes" xml:space="preserve">
          <source>This software is copyright (c) 2013 by Tim Jenness and the UK Particle Physics and Astronomy Research Council.</source>
          <target state="translated">이 소프트웨어는 Tim Jenness와 UK Particle Physics and Astronomy Research Council에 의해 (c) 2013 저작권이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff5cf6253d3c58ee0e8370fe0b1014e17ef0f493" translate="yes" xml:space="preserve">
          <source>This software is copyright (c) 2014 by Adam Kennedy and Contributors.</source>
          <target state="translated">이 소프트웨어는 Adam Kennedy와 Contributors에 의해 2014 년 저작권이 있습니다 (c).</target>
        </trans-unit>
        <trans-unit id="0dbd632224b5aa617ba78b7d9260ccc05095f469" translate="yes" xml:space="preserve">
          <source>This software is released under the MIT license cited below. Additionally, when this software is distributed with &lt;b&gt;Perl Kit, Version 5&lt;/b&gt;, you may also redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">이 소프트웨어는 아래 인용 된 MIT 라이센스에 따라 배포됩니다. 또한이 소프트웨어가 &lt;b&gt;Perl Kit, Version 5&lt;/b&gt; 와 함께 배포되는 경우 &lt;b&gt;Perl&lt;/b&gt; 과 동일한 조건으로 소프트웨어 를 재배포 및 / 또는 수정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8cc7587a3592d000978422dcd1052715c6866c6" translate="yes" xml:space="preserve">
          <source>This software pattern is so widely applicable that Attribute::Handlers provides a way to automate it: specifying &lt;code&gt;'autotie'&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Attribute::Handlers&lt;/code&gt; statement. So, the cycling example, could also be written:</source>
          <target state="translated">이 소프트웨어 패턴은 광범위하게 적용 가능하므로 Attribute :: Handlers는이를 자동화하는 방법을 제공합니다. &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Attribute::Handlers&lt;/code&gt; Attribute :: Handlers 문 에서 &lt;code&gt;'autotie'&lt;/code&gt; 를 지정 하십시오 . 따라서 사이클링 예제도 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e4e18e30d88ab31167f2d6596e06fcdc6dfcfae" translate="yes" xml:space="preserve">
          <source>This somewhat unpredictable behavior can be avoided with the experimental &quot;bitwise&quot; feature, new in Perl 5.22. You can enable it via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature
'bitwise'&lt;/code&gt; . By default, it will warn unless the &lt;code&gt;&quot;experimental::bitwise&quot;&lt;/code&gt; warnings category has been disabled. (&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; experimental 'bitwise'&lt;/code&gt; will enable the feature and disable the warning.) Under this feature, the four standard bitwise operators (&lt;code&gt;~ | &amp;amp; ^&lt;/code&gt;) are always numeric. Adding a dot after each operator (&lt;code&gt;~. |. &amp;amp;. ^.&lt;/code&gt; ) forces it to treat its operands as strings:</source>
          <target state="translated">Perl 5.22의 새로운 기능인 실험적인 &quot;비트 단위&quot;기능으로 이러한 예측할 수없는 동작을 피할 수 있습니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'bitwise'&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 기능을 통해 활성화 할 수 있습니다 . &lt;code&gt;&quot;experimental::bitwise&quot;&lt;/code&gt; 경고 범주가 비활성화되어 있지 않으면 기본적으로 경고가 표시됩니다. ( &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; experimental 'bitwise'&lt;/code&gt; 경고 기능을 사용하거나 사용하지 않도록한다.)이 기능에서, 네 개의 표준 비트 연산자 ( &lt;code&gt;~ | &amp;amp; ^&lt;/code&gt; ) 항상 숫자입니다. 각 연산자 뒤에 점을 추가하면 ( &lt;code&gt;~. |. &amp;amp;. ^.&lt;/code&gt; ) 피연산자를 문자열로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="c23e7895c905e61a802fac11e961fcc5116c44d1" translate="yes" xml:space="preserve">
          <source>This sort of code can be a real eyesore to read, as well as being very sensitive to typos, and it's much clearer to dereference the variable explicitly. We're side-stepping the issue of working with object-oriented programming techniques to encapsulate variable access via methods, only accessible through an object. Here we're just discussing the technical implementation of choice, and whether this has an effect on performance. We can see whether this dereferencing operation, has any overhead by putting comparative code in a file and running a &lt;code&gt;Benchmark&lt;/code&gt; test.</source>
          <target state="translated">이런 종류의 코드는 읽기가 쉬울뿐만 아니라 오타에 매우 민감 할 수 있으며 변수를 명시 적으로 역 참조하는 것이 훨씬 더 명확합니다. 우리는 객체 지향 프로그래밍 기술을 사용하여 메소드를 통한 변수 액세스를 캡슐화하고 객체를 통해서만 액세스 할 수있는 문제를 회피하고 있습니다. 여기서 우리는 선택의 기술적 구현과 이것이 성능에 영향을 미치는지 여부를 논의하고 있습니다. 비교 코드를 파일에 넣고 &lt;code&gt;Benchmark&lt;/code&gt; 테스트를 실행하여이 역 참조 작업에 오버 헤드가 있는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a97c4e8f1d7ea6446c4098759acfa71805444e34" translate="yes" xml:space="preserve">
          <source>This special variable is correctly set to the pseudo-process ID. It can be used to identify pseudo-processes within a particular session. Note that this value is subject to recycling if any pseudo-processes are launched after others have been wait()-ed on.</source>
          <target state="translated">이 특수 변수는 의사 프로세스 ID로 올바르게 설정되어 있습니다. 특정 세션 내에서 의사 프로세스를 식별하는 데 사용할 수 있습니다. 다른 값을 대기 한 후 의사 프로세스가 시작된 경우이 값은 재활용 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6c4aceca7fa6325a5de35ebe0aa5f8ca9090348" translate="yes" xml:space="preserve">
          <source>This specifies a search for library &lt;code&gt;gl&lt;/code&gt; as before. If that search fails to find the library, it looks at the next item in the list. The &lt;code&gt;:nosearch&lt;/code&gt; flag will prevent searching for the libraries that follow, so it simply returns the value as &lt;code&gt;-Ld:\mesalibs -lmesa -luser32&lt;/code&gt;, since GCC can use that value as is with its linker.</source>
          <target state="translated">이전과 같이 라이브러리 &lt;code&gt;gl&lt;/code&gt; 에 대한 검색을 지정합니다 . 해당 검색에서 라이브러리를 찾지 못하면 목록에서 다음 항목을 찾습니다. &lt;code&gt;:nosearch&lt;/code&gt; 단순히 같은 값을 반환 있도록 플래그는 다음과 라이브러리 검색을 방지 할 수 있습니다 &lt;code&gt;-Ld:\mesalibs -lmesa -luser32&lt;/code&gt; 그 링커와 같이 GCC 그 값을 사용할 수 있기 때문에.</target>
        </trans-unit>
        <trans-unit id="15c61edb09c43955982bc45d6acb4f0c4af7b4ab" translate="yes" xml:space="preserve">
          <source>This specifies an option to call the formatter &lt;b&gt;w&lt;/b&gt;ith. For example, &lt;code&gt;-w textsize:15&lt;/code&gt; will call &lt;code&gt;$formatter-&amp;gt;textsize(15)&lt;/code&gt; on the formatter object before it is used to format the object. For this to be valid, the formatter class must provide such a method, and the value you pass should be valid. (So if &lt;code&gt;textsize&lt;/code&gt; expects an integer, and you do &lt;code&gt;-w textsize:big&lt;/code&gt;, expect trouble.)</source>
          <target state="translated">이 포맷터를 호출 할 수있는 옵션이 지정 &lt;b&gt;승&lt;/b&gt; i 번째입니다. 예를 들어, &lt;code&gt;-w textsize:15&lt;/code&gt; 는 오브젝트를 형식화하는 데 사용되기 전에 포맷터 오브젝트에서 &lt;code&gt;$formatter-&amp;gt;textsize(15)&lt;/code&gt; 를 호출 합니다. 이것이 유효하려면 포맷터 클래스가 그러한 메소드를 제공해야하며 전달하는 값이 유효해야합니다. 따라서 &lt;code&gt;textsize&lt;/code&gt; 에 정수가 필요하고 &lt;code&gt;-w textsize:big&lt;/code&gt; 을 수행하면 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="14a814b946e54a59ba68d016b5b039bbdb959679" translate="yes" xml:space="preserve">
          <source>This specifies that the director &quot;somedir&quot; is the input. (This can be an absolute or relative path, it doesn't matter.)</source>
          <target state="translated">이것은 &quot;somedir&quot;디렉터가 입력임을 지정합니다. (절대 또는 상대 경로 일 수 있지만 중요하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="6e3a29e95276948f0b11420f703cc3aaddffd6ef" translate="yes" xml:space="preserve">
          <source>This specifies that the input directories are the items in the arrayref &lt;code&gt;\@dirs&lt;/code&gt; .</source>
          <target state="translated">입력 디렉토리가 arrayref &lt;code&gt;\@dirs&lt;/code&gt; 의 항목임을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="63679666659be8466fb9bd4dddfdca5063fd3f26" translate="yes" xml:space="preserve">
          <source>This specifies that the output is not to be sent to a pager, but is to be sent directly to STDOUT.</source>
          <target state="translated">출력이 호출기로 전송되지 않고 STDOUT으로 직접 전송되도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="b1a8fe6a04c1ca76ee22b76d1682c8136ef9711f" translate="yes" xml:space="preserve">
          <source>This specifies that the output is to be sent neither to a pager nor to STDOUT, but is to be saved to the specified filename. Example: &lt;code&gt;perldoc -oLaTeX -dtextwrapdocs.tex Text::Wrap&lt;/code&gt;</source>
          <target state="translated">출력이 호출기 나 STDOUT으로 보내지 않고 지정된 파일 이름으로 저장되도록 지정합니다. 예 : &lt;code&gt;perldoc -oLaTeX -dtextwrapdocs.tex Text::Wrap&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="45d4b28c13ac9c0ec2726a96f6188b8beab502af" translate="yes" xml:space="preserve">
          <source>This specifies that you want Perldoc to try using a Pod-formatting class for the output format that you specify. For example: &lt;code&gt;-oman&lt;/code&gt; . This is actually just a wrapper around the &lt;code&gt;-M&lt;/code&gt; switch; using &lt;code&gt;-o&lt;i&gt;formatname&lt;/i&gt;&lt;/code&gt; just looks for a loadable class by adding that format name (with different capitalizations) to the end of different classname prefixes.</source>
          <target state="translated">이는 Perldoc이 지정한 출력 형식에 대해 포드 형식화 클래스를 사용하도록 지정합니다. 예를 들면 다음과 같습니다. &lt;code&gt;-oman&lt;/code&gt; 입니다. 이것은 실제로 &lt;code&gt;-M&lt;/code&gt; 스위치 주위의 래퍼 일뿐입니다 . &lt;code&gt;-o&lt;i&gt;formatname&lt;/i&gt;&lt;/code&gt; 사용 하면 다른 클래스 이름 접두사 끝에 해당 형식 이름을 다른 대문자로 추가하여로드 가능한 클래스를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="9e4b01265a71898dfb9f81df9b68ddce9ce51346" translate="yes" xml:space="preserve">
          <source>This specifies that you want the HTML output to go into the current directory.</source>
          <target state="translated">이것은 HTML 출력이 현재 디렉토리로 들어가도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="2ae7a3e343e7bbeb0dfb1ab04a69a9932581a88b" translate="yes" xml:space="preserve">
          <source>This specifies that you want the HTML output to go into the directory 'somedir'. (This can be an absolute or relative path, it doesn't matter.)</source>
          <target state="translated">이것은 HTML 출력이 'somedir'디렉토리로 들어가도록 지정합니다. (절대 또는 상대 경로 일 수 있지만 중요하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="e7729b553095fc163c271a3e43dbeb5e583f17f6" translate="yes" xml:space="preserve">
          <source>This specifies that you want the dirs &quot;somedir&quot;, &quot;someother&quot;, and &quot;also&quot; scanned, just as if you'd passed the arrayref &lt;code&gt;[qw( somedir someother also)]&lt;/code&gt; . Note that a &quot;:&quot;-separator is normal under Unix, but Under MSWin, you'll need &lt;code&gt;'somedir;someother;also'&lt;/code&gt; instead, since the pathsep on MSWin is &quot;;&quot; instead of &quot;:&quot;. (And</source>
          <target state="translated">이것은 arrayref &lt;code&gt;[qw( somedir someother also)]&lt;/code&gt; 전달한 것처럼 &quot;somedir&quot;, &quot;someother&quot;및 &quot;also&quot;디렉토리를 스캔하도록 지정합니다 . 유닉스에서는 &quot;:&quot;-separator가 일반적이지만 MSWin에서는 &lt;code&gt;'somedir;someother;also'&lt;/code&gt; 의 pathsep가 &quot;;&quot;이므로 'somedir; someother; 또한' 가 필요합니다 . 대신에 &quot;:&quot;. (과</target>
        </trans-unit>
        <trans-unit id="b8852ab4d60e276583c1dd4292c015bb068208e6" translate="yes" xml:space="preserve">
          <source>This specifies the module that you want to try using for formatting the pod. The class must at least provide a &lt;code&gt;parse_from_file&lt;/code&gt; method. For example: &lt;code&gt;perldoc -MPod::Perldoc::ToChecker&lt;/code&gt; .</source>
          <target state="translated">포드를 포맷하는 데 사용하려는 모듈을 지정합니다. 클래스는 최소한 &lt;code&gt;parse_from_file&lt;/code&gt; 메소드를 제공해야합니다 . 예를 들면 : &lt;code&gt;perldoc -MPod::Perldoc::ToChecker&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be95e643e0441d56be0f4bdb53c658cbf47d5fc4" translate="yes" xml:space="preserve">
          <source>This specifies what string should be put at the beginning of the contents page. The default is a string more or less like this:</source>
          <target state="translated">내용 페이지의 시작 부분에 어떤 문자열을 넣어야하는지 지정합니다. 기본값은 다음과 같은 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="9c8f94ea33d23c19ce77204a84bf9dc0e745ad73" translate="yes" xml:space="preserve">
          <source>This specifies what string should be put at the end of the contents page. The default is a string more or less like this:</source>
          <target state="translated">내용 페이지의 끝에 어떤 문자열을 넣어야하는지 지정합니다. 기본값은 다음과 같은 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="6917d9958e46c59dbadffa0d75ffc8ead9eeb027" translate="yes" xml:space="preserve">
          <source>This specifies where to find a YAML file of test scheduling rules. If not provided, it looks for a default file to use. It first checks for a file given in the &lt;code&gt;HARNESS_RULESFILE&lt;/code&gt; environment variable, then it checks for</source>
          <target state="translated">테스트 예약 규칙의 YAML 파일을 찾을 위치를 지정합니다. 제공되지 않으면 사용할 기본 파일을 찾습니다. 먼저 &lt;code&gt;HARNESS_RULESFILE&lt;/code&gt; 환경 변수에 지정된 파일을 확인한 다음 확인합니다.</target>
        </trans-unit>
        <trans-unit id="c702c584a5b241344dd398527ce50b4bfbe9b63e" translate="yes" xml:space="preserve">
          <source>This stage is controlled by the macro &lt;code&gt;SIZE_ONLY&lt;/code&gt; being set.</source>
          <target state="translated">이 단계는 매크로 &lt;code&gt;SIZE_ONLY&lt;/code&gt; 가 설정되어 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="bad4c7bd6149d53fef7284ef08f67b09b3206bd8" translate="yes" xml:space="preserve">
          <source>This statement is not a legal contract. This statement is not a legal document in any way, shape, or form. Perl is distributed under the GNU Public License and under the Artistic License; those are the precise legal terms. This statement isn't about the law or licenses. It's about community, mutual respect, trust, and good-faith cooperation.</source>
          <target state="translated">이 진술은 법적 계약이 아닙니다. 이 진술은 어떤 식 으로든 형태 또는 형태에 대한 법적 문서가 아닙니다. Perl은 GNU Public License 및 Artistic License에 따라 배포됩니다. 그것들은 정확한 법적 용어입니다. 이 진술은 법률 또는 라이센스에 관한 것이 아닙니다. 공동체, 상호 존중, 신뢰 및 선의의 협력에 관한 것입니다.</target>
        </trans-unit>
        <trans-unit id="5a98c55935426becf715b954b892501f79db080b" translate="yes" xml:space="preserve">
          <source>This statement should at least appear in the README file. You may also wish to include it in a Copying file and your source files. Remember to include the other words in addition to the Copyright.</source>
          <target state="translated">이 문장은 최소한 README 파일에 나타나야합니다. 복사 파일과 소스 파일에 포함시킬 수도 있습니다. 저작권 외에 다른 단어도 포함시켜야합니다.</target>
        </trans-unit>
        <trans-unit id="5584a0e56dfda5fbec4748cd6a50bc455909922d" translate="yes" xml:space="preserve">
          <source>This step is listed for completeness only. Since it does not change semantics, details of this step are not documented and are subject to change without notice. This step is performed over the finite automaton that was generated during the previous pass.</source>
          <target state="translated">이 단계는 완전성에 대해서만 나열됩니다. 시맨틱을 변경하지 않으므로이 단계의 세부 사항은 문서화되지 않으며 사전 통지없이 변경 될 수 있습니다. 이 단계는 이전 단계에서 생성 된 유한 오토 마톤에 대해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="54c5eb8ed193c34bf7512d41b140b26cac84363b" translate="yes" xml:space="preserve">
          <source>This step is the last one for all constructs except regular expressions, which are processed further.</source>
          <target state="translated">이 단계는 정규식을 제외한 모든 구성에 대한 마지막 단계이며 추가 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="821b4588528e230329db6b553dfd4048a67b80be" translate="yes" xml:space="preserve">
          <source>This still doesn't guarantee that a real person is answering your prompts or reading your output.</source>
          <target state="translated">그래도 실제 사람이 프롬프트에 응답하거나 출력을 읽도록 보장하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="a7c9161f97b6f8900f13bf7304c1db4d0488adaf" translate="yes" xml:space="preserve">
          <source>This stores the number of eval groups in the pattern. This is used for security purposes when embedding compiled regexes into larger patterns with &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">패턴에 평가 그룹 수를 저장합니다. 이것은 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 사용하여 컴파일 된 정규 표현식을 더 큰 패턴으로 임베드 할 때 보안 목적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="fc38633b5aabfda04a32707218d9bef85297337b" translate="yes" xml:space="preserve">
          <source>This strategy can employ a network connection. As such it would be computationally expensive.</source>
          <target state="translated">이 전략은 네트워크 연결을 사용할 수 있습니다. 따라서 계산 비용이 많이 듭니다.</target>
        </trans-unit>
        <trans-unit id="55b6f7ba63a618224a4b898bcbb27d9706c30d52" translate="yes" xml:space="preserve">
          <source>This string tells Perl to consult the CRTL's internal &lt;code&gt;environ&lt;/code&gt; array of key-value pairs, using</source>
          <target state="translated">이 문자열은 Perl에게 다음을 사용하여 키-값 쌍 의 CRTL의 내부 &lt;code&gt;environ&lt;/code&gt; 배열 을 참조하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="7ae6448a0aa9566553b6817c071e02a343cc087d" translate="yes" xml:space="preserve">
          <source>This struct typedef</source>
          <target state="translated">이 구조체 typedef</target>
        </trans-unit>
        <trans-unit id="f1bc15138286b1a37e209e8a6243ffb9f2ea5373" translate="yes" xml:space="preserve">
          <source>This structure is used for handling data structures that the regex engine needs to handle specially during a clone or free operation on the compiled product. Each element in the data array has a corresponding element in the what array. During compilation regops that need special structures stored will add an element to each array using the add_data() routine and then store the index in the regop.</source>
          <target state="translated">이 구조는 정규식 엔진이 컴파일 된 제품에서 복제 또는 자유 작업 중에 특별히 처리해야하는 데이터 구조를 처리하는 데 사용됩니다. 데이터 배열의 각 요소는 what 배열의 해당 요소를 갖습니다. 컴파일하는 동안 특수 구조가 필요한 regop은 add_data () 루틴을 사용하여 각 배열에 요소를 추가 한 다음 인덱스를 regop에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="d78d4b0d4925694b27ab08d1c6e58334dc8e28bc" translate="yes" xml:space="preserve">
          <source>This style of commenting has been largely superseded by the raw, freeform commenting that is allowed with the &lt;code&gt;//x&lt;/code&gt; modifier.</source>
          <target state="translated">이 스타일의 주석은 &lt;code&gt;//x&lt;/code&gt; 수정 자 와 함께 허용되는 원시 자유형 주석으로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="97f344b018a57310e7df154cc09c4a4c8ffc8347" translate="yes" xml:space="preserve">
          <source>This subroutine accepts a new style name and three style arguments as above, and creates, registers, and selects the newly named style. It is an error to re-add a style; call set_style_standard() to switch between several styles.</source>
          <target state="translated">이 서브 루틴은 위와 같이 새 스타일 이름과 세 가지 스타일 인수를 허용하고 새로 이름 지정된 스타일을 작성, 등록 및 선택합니다. 스타일을 다시 추가하는 것은 오류입니다. 여러 스타일 사이를 전환하려면 set_style_standard ()를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="d4edd10fd3d7f6f2e8552ea6e5bfd25a981a931d" translate="yes" xml:space="preserve">
          <source>This subroutine produces a standard help message, derived from the program's POD section SYNOPSIS using &lt;a href=&quot;../pod/usage&quot;&gt;Pod::Usage&lt;/a&gt;. It takes the same arguments as VersionMessage(). In particular, you cannot tie it directly to an option, e.g.:</source>
          <target state="translated">이 서브 루틴은 &lt;a href=&quot;../pod/usage&quot;&gt;Pod :: Usage를&lt;/a&gt; 사용하여 프로그램의 POD 섹션 SYNOPSIS에서 파생 된 표준 도움말 메시지를 생성합니다 . VersionMessage ()와 동일한 인수를 사용합니다. 특히 다음과 같은 옵션에 직접 연결할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5689fa040b7fc66f95972afdb83490d423250c81" translate="yes" xml:space="preserve">
          <source>This subroutine provides a standard version message. Its argument can be:</source>
          <target state="translated">이 서브 루틴은 표준 버전 메시지를 제공합니다. 그 주장은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8ecee5dd8e0a61ddae4c3d45c386aa7954dd0f33" translate="yes" xml:space="preserve">
          <source>This subroutine will add commas to your number:</source>
          <target state="translated">이 서브 루틴은 번호에 쉼표를 추가합니다 :</target>
        </trans-unit>
        <trans-unit id="f33530c08d2ea0b801b43fac5cff8bb563110c57" translate="yes" xml:space="preserve">
          <source>This succeeds if the &quot;martian&quot; character GX is in the string, and fails otherwise. If you don't like using (?&amp;lt;!), a zero-width negative look-behind assertion, you can replace (?&amp;lt;![A-Z]) with (?:^|[^A-Z]).</source>
          <target state="translated">&quot;martian&quot;문자 GX가 문자열에 있으면 성공하고 그렇지 않으면 실패합니다. 너비가 0 인 음수 룩 어설 션 인 (? &amp;lt;!)를 사용하지 않으려면 (? &amp;lt;! [AZ])를 (? : ^ | [^ AZ])로 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85a98330f72d7fa29e768ec7aa2344fb1a20cbca" translate="yes" xml:space="preserve">
          <source>This suppresses printing of VMS status messages to SYS$OUTPUT and SYS$ERROR if Perl terminates with an error status, and allows programs that are expecting &quot;unix-style&quot; Perl to avoid having to parse VMS error messages. It does not suppress any messages from Perl itself, just the messages generated by DCL after Perl exits. The DCL symbol $STATUS will still have the termination status, but with a high-order bit set:</source>
          <target state="translated">이것은 Perl이 오류 상태로 종료되면 VMS 상태 메시지가 SYS $ OUTPUT 및 SYS $ ERROR로 인쇄되지 않도록하고 &quot;unix-style&quot;Perl을 기대하는 프로그램이 VMS 오류 메시지를 구문 분석하지 않아도되도록합니다. Perl 자체의 메시지는 표시하지 않으며 Perl이 종료 된 후 DCL에 의해 생성 된 메시지 만 표시합니다. DCL 기호 $ STATUS는 여전히 종료 상태이지만 상위 비트 세트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a73c08f06f0acf42846845d03633aa9b47905a33" translate="yes" xml:space="preserve">
          <source>This surprising autovivification in what does not at first--or even second--glance appear to be an lvalue context may be fixed in a future release.</source>
          <target state="translated">언뜻보기에 또는 심지어 두 번째로 보이지 않는 것에서 의이 놀라운 자생은 다음 릴리스에서 수정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e56b6634af06492105c8150cce8eec38c642722a" translate="yes" xml:space="preserve">
          <source>This switch causes Perl to dump core after compiling your program. You can then in theory take this core dump and turn it into an executable file by using the</source>
          <target state="translated">이 스위치는 프로그램을 컴파일 한 후 Perl이 코어를 덤프하도록합니다. 이론적 으로이 코어 덤프를 가져 와서 실행 파일로 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdeac32803cbaac383dc34d3e5d5f188b61766f8" translate="yes" xml:space="preserve">
          <source>This switch really just enables the global &lt;code&gt;$^W&lt;/code&gt; variable; normally, the lexically scoped &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma is preferred. You can disable or promote into fatal errors specific warnings using &lt;code&gt;__WARN__&lt;/code&gt; hooks, as described in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; and &lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;. See also &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt; and &lt;a href=&quot;perltrap&quot;&gt;perltrap&lt;/a&gt;. A fine-grained warning facility is also available if you want to manipulate entire classes of warnings; see &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">이 스위치는 실제로 글로벌 &lt;code&gt;$^W&lt;/code&gt; 변수 만 활성화합니다 . 일반적으로 어휘 범위 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma가 선호됩니다. &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; 및 &lt;a href=&quot;functions/warn&quot;&gt;warn에&lt;/a&gt; 설명 된대로 &lt;code&gt;__WARN__&lt;/code&gt; 후크를 사용하여 치명적 오류 관련 경고를 사용하지 않도록 설정하거나 승격시킬 수 있습니다 . &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt; 및 &lt;a href=&quot;perltrap&quot;&gt;perltrap&lt;/a&gt; 도 참조하십시오 . 전체 클래스의 경고를 조작하려는 경우 세분화 된 경고 기능도 사용할 수 있습니다. &lt;a href=&quot;warnings&quot;&gt;경고를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b9aace5953cb75e0bd50c74f57a0b38f9c0103c2" translate="yes" xml:space="preserve">
          <source>This symbol conditionally defines the symbol &lt;code&gt;BSD&lt;/code&gt; when running on a &lt;code&gt;BSD&lt;/code&gt; system.</source>
          <target state="translated">이 기호 는 &lt;code&gt;BSD&lt;/code&gt; 시스템 에서 실행될 때 &lt;code&gt;BSD&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="9dffb9b12a2139e8c4c666d76c2bbb94b410515d" translate="yes" xml:space="preserve">
          <source>This symbol contains the type of pointer returned by mmap() (and simultaneously the type of the first argument). It can be &lt;code&gt;void *&lt;/code&gt; or &lt;code&gt;caddr_t&lt;/code&gt; .</source>
          <target state="translated">이 기호에는 mmap ()에 의해 반환되는 포인터 유형과 동시에 첫 번째 인수 유형이 포함됩니다. &lt;code&gt;void *&lt;/code&gt; 또는 &lt;code&gt;caddr_t&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e78cc593a5e3d5f9580ef534ee09e8fe0d641140" translate="yes" xml:space="preserve">
          <source>This symbol contains the type of pointer returned by shmat(). It can be &lt;code&gt;void *&lt;/code&gt; or &lt;code&gt;char *&lt;/code&gt; .</source>
          <target state="translated">이 기호에는 shmat ()에서 반환 한 포인터 유형이 포함되어 있습니다. &lt;code&gt;void *&lt;/code&gt; 또는 &lt;code&gt;char *&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="584f3ba36a4f3dda7bd8acb2eea24bb10daa748c" translate="yes" xml:space="preserve">
          <source>This symbol is defined if using the &lt;code&gt;FILE_ptr&lt;/code&gt; macro as an lvalue to increase the pointer by n has the side effect of decreasing the value of File_cnt(fp) by n.</source>
          <target state="translated">이 기호는 &lt;code&gt;FILE_ptr&lt;/code&gt; 매크로를 lvalue로 사용하여 포인터를 n만큼 늘리면 File_cnt (fp)의 값이 n만큼 감소하는 부작용이있는 경우에 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="0683919acfce603ad7685e97943788fb4e37c119" translate="yes" xml:space="preserve">
          <source>This symbol is defined if using the &lt;code&gt;FILE_ptr&lt;/code&gt; macro as an lvalue to increase the pointer by n leaves File_cnt(fp) unchanged.</source>
          <target state="translated">이 기호는 &lt;code&gt;FILE_ptr&lt;/code&gt; 매크로를 lvalue로 사용하여 포인터를 n만큼 늘리면 File_cnt (fp)가 변경되지 않은 경우에 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="93f9dcbec7fb63d67f75a0e1d4dc9ae41d2b59f2" translate="yes" xml:space="preserve">
          <source>This symbol is set to &lt;code&gt;struct direct&lt;/code&gt; or &lt;code&gt;struct dirent&lt;/code&gt; depending on whether dirent is available or not. You should use this pseudo type to portably declare your directory entries.</source>
          <target state="translated">이 기호는 dirent의 사용 가능 여부에 따라 &lt;code&gt;struct direct&lt;/code&gt; 또는 &lt;code&gt;struct dirent&lt;/code&gt; 를 구성하도록 설정됩니다 . 디렉토리 유형을 이식 가능하게 선언하려면이 의사 유형을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ac5221df55c0b6f88cbdccf1d492a80ec8b042ec" translate="yes" xml:space="preserve">
          <source>This symbol reflects the patchlevel, if available. Will usually come from the</source>
          <target state="translated">이 기호는 가능한 경우 패치 수준을 나타냅니다. 보통에서 올 것이다</target>
        </trans-unit>
        <trans-unit id="b709a76faa1011cf3f1c524bd59100484a2a8c2a" translate="yes" xml:space="preserve">
          <source>This symbol will be defined if the C compiler supports fpos64_t.</source>
          <target state="translated">C 컴파일러가 fpos64_t를 지원하는 경우이 기호가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="343c9a95f0e1882d7b8de9c8d965312cb38ddb59" translate="yes" xml:space="preserve">
          <source>This symbol will be defined if the C compiler supports int64_t.</source>
          <target state="translated">이 기호는 C 컴파일러가 int64_t를 지원하는 경우 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="9fabec6c07d2b2eb93287e97cce2db59d9d91ab9" translate="yes" xml:space="preserve">
          <source>This symbol will be defined if the C compiler supports off64_t.</source>
          <target state="translated">이 기호는 C 컴파일러가 off64_t를 지원하는 경우 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="425b3d025cac3f927d48be352caec0255a6ff1f6" translate="yes" xml:space="preserve">
          <source>This symbol will be defined if the C compiler supports ptrdiff_t.</source>
          <target state="translated">C 컴파일러가 ptrdiff_t를 지원하는 경우이 기호가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="8b08c311a150e9da2b658a2599a4ffb33ccacd56" translate="yes" xml:space="preserve">
          <source>This symbol will be defined if the C compiler supports socklen_t.</source>
          <target state="translated">C 컴파일러가 socklen_t를 지원하는 경우이 기호가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="025aea88f0880f5a01a7cfa41a1296fe3bb5e473" translate="yes" xml:space="preserve">
          <source>This symbol, if defined, indicates that the malloc_good_size routine is available for use.</source>
          <target state="translated">이 기호는 정의 된 경우 malloc_good_size 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8a656f9000aaa7b4a0b80166141d60895ed70146" translate="yes" xml:space="preserve">
          <source>This symbol, if defined, indicates that the malloc_size routine is available for use.</source>
          <target state="translated">이 기호는 정의 된 경우 malloc_size 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9f16a25b173530b121560b8b39634ea26912b006" translate="yes" xml:space="preserve">
          <source>This symbol, if defined, indicates that the system provides a prototype for the modfl() function. Otherwise, it is up to the program to supply one. C99 says it should be long double modfl(long double, long double *);</source>
          <target state="translated">이 기호는 정의 된 경우 시스템이 modfl () 함수의 프로토 타입을 제공함을 나타냅니다. 그렇지 않으면 프로그램을 제공하는 것은 프로그램의 책임입니다. C99는 long double modfl (long double, long double *)이어야한다고 말합니다.</target>
        </trans-unit>
        <trans-unit id="46fd1ea7339001ddcefcaaf1e70c3783b77303d2" translate="yes" xml:space="preserve">
          <source>This symbol, if defined, indicates that the system stores the variable argument list datatype, va_list, in a format that cannot be copied by simple assignment, so that some other means must be used when copying is required. As such systems vary in their provision (or non-provision) of copying mechanisms,</source>
          <target state="translated">이 기호가 정의 된 경우 시스템이 변수 인수 목록 데이터 유형 va_list를 단순 지정으로 복사 할 수없는 형식으로 저장하므로 복사가 필요한 경우 다른 수단을 사용해야 함을 나타냅니다. 이러한 시스템은 복사 메커니즘의 제공 (또는 비 제공)이 다양하므로</target>
        </trans-unit>
        <trans-unit id="33cfc6c8458868fdba1853ad63d6a5ab248c80dd" translate="yes" xml:space="preserve">
          <source>This symbol, if defined, indicates that we can use _NSGetExecutablePath and realpath to get a full path for the executable, and hence convert $^X to an absolute path.</source>
          <target state="translated">이 기호가 정의되어 있으면 _NSGetExecutablePath 및 realpath를 사용하여 실행 파일의 전체 경로를 얻을 수 있으므로 $ ^ X를 절대 경로로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e5579cd2141da02375bbc1afc9cdf3e216d16eb" translate="yes" xml:space="preserve">
          <source>This symbol, if defined, tells that fflush(&lt;code&gt;NULL&lt;/code&gt; ) correctly flushes all pending stdio output without side effects. In particular, on some platforms calling fflush(&lt;code&gt;NULL&lt;/code&gt; ) *still* corrupts &lt;code&gt;STDIN&lt;/code&gt; if it is a pipe.</source>
          <target state="translated">이 기호는 정의 된 경우 fflush ( &lt;code&gt;NULL&lt;/code&gt; )가 부작용없이 보류중인 모든 stdio 출력을 올바르게 플러시 함을 나타냅니다. 특히, 일부 플랫폼에서 fflush ( &lt;code&gt;NULL&lt;/code&gt; ) * still *을 호출 하면 파이프 인 경우 &lt;code&gt;STDIN&lt;/code&gt; 이 손상 됩니다.</target>
        </trans-unit>
        <trans-unit id="345492b736fde856a18832ea228dc15b7f57e1fd" translate="yes" xml:space="preserve">
          <source>This symbol, if defined, tells that to flush all pending stdio output one must loop through all the stdio file handles stored in an array and fflush them. Note that if fflushNULL is defined, fflushall will not even be probed for and will be left undefined.</source>
          <target state="translated">이 기호가 정의되어 있으면 보류중인 모든 stdio 출력을 플러시하려면 배열에 저장된 모든 stdio 파일 핸들을 반복하여 플러시해야합니다. fflushNULL이 정의 된 경우 fflushall은 검사되지 않으며 정의되지 않은 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="dcd9bfb79795353183cc954075073576d42a4a96" translate="yes" xml:space="preserve">
          <source>This syntax can be used with any class or object method:</source>
          <target state="translated">이 구문은 모든 클래스 또는 객체 메소드와 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="361a88cbd3ef11a7c4b058ea6f65a1768cf1bf06" translate="yes" xml:space="preserve">
          <source>This syntax make the caret a special character inside a bracketed character class, but only if it is the first character of the class. So if you want the caret as one of the characters to match, either escape the caret or else don't list it first.</source>
          <target state="translated">이 구문은 캐럿을 대괄호로 묶은 문자 클래스 내부의 특수 문자로 만들지 만 클래스의 첫 번째 문자 인 경우에만 가능합니다. 따라서 캐럿을 문자 중 하나로 일치 시키려면 캐럿을 이스케이프하거나 먼저 나열하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="cf8882c6e41ea0e436011545b6eac42846ae64e6" translate="yes" xml:space="preserve">
          <source>This syntax must be enabled with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'postderef'&lt;/code&gt; . It is experimental, and will warn by default unless &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings
'experimental::postderef'&lt;/code&gt; is in effect.</source>
          <target state="translated">이 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'postderef'&lt;/code&gt; 을 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하여 활성화해야합니다 . 실험적이며 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'experimental::postderef'&lt;/code&gt; 적용 &lt;a href=&quot;functions/no&quot;&gt;되지&lt;/a&gt; 않는 한 기본적으로 경고 합니다.</target>
        </trans-unit>
        <trans-unit id="2448d5ee0ab20cace7d0d694356cb8b018b6fff7" translate="yes" xml:space="preserve">
          <source>This syntax must be enabled with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'refaliasing'&lt;/code&gt; . It is experimental, and will warn by default unless &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings
'experimental::refaliasing'&lt;/code&gt; is in effect.</source>
          <target state="translated">이 구문은 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'refaliasing'&lt;/code&gt; 을 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하여 활성화해야합니다 . 실험적인 것이며 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'experimental::refaliasing'&lt;/code&gt; 적용 &lt;a href=&quot;functions/no&quot;&gt;되지&lt;/a&gt; 않는 한 기본적으로 경고 합니다.</target>
        </trans-unit>
        <trans-unit id="17f3dce1b8ffb69288b5e7233eedf50e51bf6d28" translate="yes" xml:space="preserve">
          <source>This table should give some indication on the relative speed of different algorithms. It is sorted by throughput based on a benchmark done with of some implementations of this API:</source>
          <target state="translated">이 표는 다른 알고리즘의 상대 속도에 대한 정보를 제공해야합니다. 이 API의 일부 구현으로 수행 된 벤치 마크를 기반으로 처리량별로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="61e7d00a447b322e0b6281e41be210174353561f" translate="yes" xml:space="preserve">
          <source>This tag holds groups of assorted specialist opcodes that don't warrant having optags defined for them.</source>
          <target state="translated">이 태그에는 정의 된 optag가 없음을 보증하지 않는 여러 분류 된 전문 opcode 그룹이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b596b3ecff7c84a2d9f652cda2f444e71a7c9fa" translate="yes" xml:space="preserve">
          <source>This tag holds opcodes related to loading modules and getting information about calling environment and args.</source>
          <target state="translated">이 태그에는 모듈로드 및 호출 환경 및 인수에 대한 정보 얻기와 관련된 opcode가 있습니다.</target>
        </trans-unit>
        <trans-unit id="04ae009bf5132dad193828814ac61d5405735292" translate="yes" xml:space="preserve">
          <source>This tag is simply a bucket for opcodes that are unlikely to be used via a tag name but need to be tagged for completeness and documentation.</source>
          <target state="translated">이 태그는 단순히 태그 이름을 통해 사용되지 않지만 완전성과 문서화를 위해 태그를 지정해야하는 opcode의 버킷입니다.</target>
        </trans-unit>
        <trans-unit id="2f05cedd800de4070129a2009cffd984beb3db08" translate="yes" xml:space="preserve">
          <source>This takes a list of operator names and returns the corresponding list of operator descriptions.</source>
          <target state="translated">연산자 이름 목록을 가져와 해당 연산자 설명 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7c7d2a6226efbfa63a2425be94ed3ca13dcfd261" translate="yes" xml:space="preserve">
          <source>This takes a list of strings (which are presumed to be language-tags; strings that aren't, are ignored); and after each one, this function inserts super-ordinate forms that don't already appear in the list. The original list, plus these insertions, is returned.</source>
          <target state="translated">여기에는 문자열 목록이 필요합니다 (언어 태그 인 것으로 추정되고 그렇지 않은 문자열은 무시 됨). 그리고 각 함수 다음에이 함수는 목록에 아직 나타나지 않은 상위 ​​양식을 삽입합니다. 원본 목록과 이러한 삽입이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="13fd8ee50911015c2027466ceb16f127d689e9d2" translate="yes" xml:space="preserve">
          <source>This takes a locale name (like &quot;en&quot;, &quot;en_US&quot;, or &quot;en_US.ISO8859-1&quot;) and maps it to a language tag. If it's not mappable (as with, notably, &quot;C&quot; and &quot;POSIX&quot;), this returns empty-list in a list context, or undef in a scalar context.</source>
          <target state="translated">로캘 이름 (예 : &quot;en&quot;, &quot;en_US&quot;또는 &quot;en_US.ISO8859-1&quot;)을 사용하여 언어 태그에 매핑합니다. 매핑 할 수없는 경우 (특히 &quot;C&quot;및 &quot;POSIX&quot;와 같이) 목록 컨텍스트에서 빈 목록을 반환하거나 스칼라 컨텍스트에서 undef를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bec8c5f2b922f1fda3abe6ef42f1ed85d0f41b3d" translate="yes" xml:space="preserve">
          <source>This takes an optional parameter, the name of a .packlist. If the file exists, it will be opened and the contents of the file will be read. The new() method returns a reference to a hash. This hash holds an entry for each line in the .packlist. In the case of old-style .packlists, the value associated with each key is undef. In the case of new-style .packlists, the value associated with each key is a hash containing the key=value pairs following the filename in the .packlist.</source>
          <target state="translated">선택적 매개 변수 인 .packlist의 이름을 사용합니다. 파일이 존재하면 파일이 열리고 파일 내용을 읽습니다. new () 메소드는 해시에 대한 참조를 리턴합니다. 이 해시는 .packlist의 각 줄에 대한 항목을 보유합니다. 이전 스타일의 .packlists의 경우 각 키와 관련된 값은 undef입니다. 새로운 스타일의 .packlist의 경우 각 키와 관련된 값은 .packlist의 파일 이름 뒤에 key = value 쌍을 포함하는 해시입니다.</target>
        </trans-unit>
        <trans-unit id="cc773e12adc99441c781ca39ab744dcff4457a5a" translate="yes" xml:space="preserve">
          <source>This takes an optional parameter, the name of the .packlist to be read. If no file is specified, the .packlist specified to new() will be read. If the .packlist does not exist, Carp::croak will be called.</source>
          <target state="translated">선택적인 매개 변수 인 .packlist의 이름을 읽습니다. 파일을 지정하지 않으면 new ()로 지정된 .packlist를 읽습니다. .packlist가 없으면 Carp :: croak가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="1a1bc9e2453dd25ae8b25a05301cb1b80e688d4f" translate="yes" xml:space="preserve">
          <source>This takes an optional parameter, the name of the .packlist to be written. If no file is specified, the .packlist specified to new() will be overwritten.</source>
          <target state="translated">이것은 선택적 매개 변수, 작성할 .packlist의 이름을 사용합니다. 파일을 지정하지 않으면 new ()로 지정된 .packlist를 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="71c865c7274d3c7e5bfe698effd4f04214f7cd15" translate="yes" xml:space="preserve">
          <source>This takes name/value pairs that effect how the test is run.</source>
          <target state="translated">테스트 실행 방법에 영향을주는 이름 / 값 쌍이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="cc76b10f19749554379a021ff3eedaa58c818a23" translate="yes" xml:space="preserve">
          <source>This takes one mandatory parameter, the name of a module. It checks that all the files listed in the modules .packlist actually exist, and returns a list of any missing files. If an optional second argument which evaluates to true is given any missing files will be removed from the .packlist</source>
          <target state="translated">여기에는 하나의 필수 매개 변수 인 모듈 이름이 사용됩니다. 모듈 .packlist에 나열된 모든 파일이 실제로 존재하는지 확인하고 누락 된 파일 목록을 반환합니다. 선택적인 두 번째 인수가 true로 평가되면 누락 된 파일이 .packlist에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="5b5d51a829067c0f74043220e1f7dc0a082fd9a1" translate="yes" xml:space="preserve">
          <source>This takes one mandatory parameter, the name of a module. It returns a list of all the directories from the package. Additional parameters are allowed. The first is one of the strings &quot;prog&quot;, &quot;doc&quot; or &quot;all&quot;, to select either just program directories, just manual directories or all directories. The remaining parameters are a list of directories. The directories returned will be restricted to those under the specified directories. This method returns only the leaf directories that contain files from the specified module.</source>
          <target state="translated">여기에는 하나의 필수 매개 변수 인 모듈 이름이 사용됩니다. 패키지에서 모든 디렉토리 목록을 리턴합니다. 추가 매개 변수가 허용됩니다. 첫 번째는 &quot;prog&quot;, &quot;doc&quot;또는 &quot;all&quot;문자열 중 하나이며 프로그램 디렉토리, 수동 디렉토리 또는 모든 디렉토리 중 하나를 선택합니다. 나머지 매개 변수는 디렉토리 목록입니다. 리턴 된 디렉토리는 지정된 디렉토리 아래의 디렉토리로 제한됩니다. 이 메소드는 지정된 모듈의 파일을 포함하는 리프 디렉토리 만 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d2af5c7a635840c9a764106b51edcb4ae7965f15" translate="yes" xml:space="preserve">
          <source>This takes one mandatory parameter, the name of a module. It returns a list of all the filenames from the package. To obtain a list of core perl files, use the module name 'Perl'. Additional parameters are allowed. The first is one of the strings &quot;prog&quot;, &quot;doc&quot; or &quot;all&quot;, to select either just program files, just manual files or all files. The remaining parameters are a list of directories. The filenames returned will be restricted to those under the specified directories.</source>
          <target state="translated">여기에는 하나의 필수 매개 변수 인 모듈 이름이 사용됩니다. 패키지의 모든 파일 이름 목록을 반환합니다. 코어 perl 파일 목록을 얻으려면 모듈 이름 'Perl'을 사용하십시오. 추가 매개 변수가 허용됩니다. 첫 번째는 문자열 &quot;prog&quot;, &quot;doc&quot;또는 &quot;all&quot;중 하나이며 프로그램 파일, 수동 파일 또는 모든 파일을 선택합니다. 나머지 매개 변수는 디렉토리 목록입니다. 반환 된 파일 이름은 지정된 디렉토리에있는 파일 이름으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="c87f6895af9c38d5c250f2c66fe4725760f823f0" translate="yes" xml:space="preserve">
          <source>This takes optional named parameters. Without parameters, this searches for all the installed .packlists on the system using information from &lt;code&gt;%Config::Config&lt;/code&gt; and the default module search paths &lt;code&gt;@INC&lt;/code&gt; . The packlists are read using the &lt;a href=&quot;packlist&quot;&gt;ExtUtils::Packlist&lt;/a&gt; module.</source>
          <target state="translated">선택적 명명 된 매개 변수가 필요합니다. 매개 변수가 없으면 &lt;code&gt;%Config::Config&lt;/code&gt; 와 기본 모듈 검색 경로 &lt;code&gt;@INC&lt;/code&gt; 를 사용하여 시스템에 설치된 모든 .packlist를 검색합니다 . 팩리스트는 &lt;a href=&quot;packlist&quot;&gt;ExtUtils :: Packlist를&lt;/a&gt; 사용하여 읽습니다. 모듈을 .</target>
        </trans-unit>
        <trans-unit id="9a03ab8b368c68d278641fea23e27727f8dbba74" translate="yes" xml:space="preserve">
          <source>This target is stubbed out. Not sure why.</source>
          <target state="translated">이 목표는 스터브 아웃되었습니다. 이유가 확실하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f1ca50a85da91c16a0a908f36c57ff992ef7c02c" translate="yes" xml:space="preserve">
          <source>This technique of separation of the glue part from the workhorse part has obvious tradeoffs: if you want to change a Perl interface, you need to change two places in your code. However, it removes a lot of clutter, and makes the workhorse part independent from idiosyncrasies of Perl calling convention. (In fact, there is nothing Perl-specific in the above description, a different version of &lt;b&gt;xsubpp&lt;/b&gt; might have translated this to TCL glue or Python glue as well.)</source>
          <target state="translated">접착제 부분을 가공물 부분에서 분리하는이 기술은 명백한 절충점이 있습니다. Perl 인터페이스를 변경하려면 코드에서 두 위치를 변경해야합니다. 그러나, 그것은 많은 혼란을 제거하고, 작업 부분을 Perl 호출 규칙의 특유 성과 독립적으로 만듭니다. (실제로, 위의 설명에서 Perl에 특정한 것은 없으며, 다른 버전의 &lt;b&gt;xsubpp&lt;/b&gt; 가 이것을 TCL 접착제 또는 Python 접착제로 변환했을 수도 있습니다.)</target>
        </trans-unit>
        <trans-unit id="579494abf777c1edad219e4e3e72f24bade80f1c" translate="yes" xml:space="preserve">
          <source>This technique was popular for a while (and was recommended in Damian Conway's</source>
          <target state="translated">이 기술은 한동안 인기가 있었고 (Damian Conway 's에서 권장되었습니다)</target>
        </trans-unit>
        <trans-unit id="5e8f5ce6d67f7bf4b479db2dfff968206c152d0a" translate="yes" xml:space="preserve">
          <source>This tells the compiler to use integer operations from here to the end of the enclosing BLOCK. On many machines, this doesn't matter a great deal for most computations, but on those without floating point hardware, it can make a big difference in performance.</source>
          <target state="translated">이것은 컴파일러에게 여기에서 둘러싸는 BLOCK의 끝까지 정수 연산을 사용하도록 지시합니다. 많은 컴퓨터에서 이것은 대부분의 계산에서 큰 문제가되지 않지만 부동 소수점 하드웨어가없는 컴퓨터에서는 성능에 큰 차이를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c227c573c801b67ab844d5a781ca2d861b5ad11" translate="yes" xml:space="preserve">
          <source>This test harness is the same as &lt;a href=&quot;../harness&quot;&gt;TAP::Harness&lt;/a&gt;, but test results are output in color. Passing tests are printed in green. Failing tests are in red. Skipped tests are blue on a white background and TODO tests are printed in white.</source>
          <target state="translated">이 테스트 하네스는 &lt;a href=&quot;../harness&quot;&gt;TAP :: Harness&lt;/a&gt; 와 동일 하지만 테스트 결과는 컬러로 출력됩니다. 합격 시험은 녹색으로 인쇄됩니다. 실패한 테스트는 빨간색입니다. 건너 뛴 테스트는 흰색 배경에서 파란색이고 TODO 테스트는 흰색으로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="56c5da5399251bb5e1db8f624c5839bd6c16417b" translate="yes" xml:space="preserve">
          <source>This test not coming out ok could indicate that you have in fact installed a bLuRfle.pm module or that the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; &quot; require \&quot;$module_name.pm\&quot;; &quot;&lt;/code&gt; test may give misleading results with your installation of perl. If yours is the latter case then please let the author know.</source>
          <target state="translated">이 테스트가 제대로 수행되지 않으면 bLuRfle.pm 모듈을 실제로 설치했거나 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; &quot; require \&quot;$module_name.pm\&quot;; &quot;&lt;/code&gt; 테스트를 수행하면 perl을 설치하면 잘못된 결과를 초래할 수 있습니다. 후자의 경우 저자에게 알려주십시오.</target>
        </trans-unit>
        <trans-unit id="d7779eb97d1704eb5b38f4af625c19d04da87929" translate="yes" xml:space="preserve">
          <source>This third program fails to run because &lt;code&gt;$&amp;amp;&lt;/code&gt; is tainted: it is the result of a match involving &lt;code&gt;\w&lt;/code&gt; while &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect.</source>
          <target state="translated">이 세 번째 프로그램 은 &lt;code&gt;$&amp;amp;&lt;/code&gt; 이 (가) 오염 되어 실행되지 않습니다 : &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 을 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하는 동안 &lt;code&gt;\w&lt;/code&gt; 와 일치하는 결과입니다 . 이 적용 .</target>
        </trans-unit>
        <trans-unit id="a3af2bc97cd9f37316fc3da9caf4914a2a7462bf" translate="yes" xml:space="preserve">
          <source>This threshold can be changed from 100, by recompiling the</source>
          <target state="translated">이 임계 값을 다시 컴파일하여 100에서 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a47e3515c81e527144a0c9b60fab0d504885832" translate="yes" xml:space="preserve">
          <source>This tie class has chosen to return an error rather than raising an exception if its constructor should fail. While this is how dbmopen() works, other classes may well not wish to be so forgiving. It checks the global variable &lt;code&gt;$^W&lt;/code&gt; to see whether to emit a bit of noise anyway.</source>
          <target state="translated">이 타이 클래스는 생성자가 실패해야하는 경우 예외를 발생시키는 대신 오류를 반환하도록 선택했습니다. 이것이 dbmopen ()의 작동 방식이지만 다른 클래스는 그렇게 용서하고 싶지 않을 수 있습니다. 어쨌든 약간의 노이즈를 방출할지 여부를 확인하기 위해 전역 변수 &lt;code&gt;$^W&lt;/code&gt; 를 검사합니다 .</target>
        </trans-unit>
        <trans-unit id="65215d2823f33c6578d2c1ee584a26f404ed972a" translate="yes" xml:space="preserve">
          <source>This time only two filters have been used -- we only need to manipulate the contents of the key, so it wasn't necessary to install any value filters.</source>
          <target state="translated">이번에는 두 개의 필터 만 사용되었습니다. 키의 내용 만 조작하면되므로 값 필터를 설치할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ce475e5b88de267f8c35364dcce4ac0349ad1b9f" translate="yes" xml:space="preserve">
          <source>This time only two filters have been used; we only need to manipulate the contents of the key, so it wasn't necessary to install any value filters.</source>
          <target state="translated">이번에는 두 개의 필터 만 사용되었습니다. 키의 내용 만 조작하면되므로 값 필터를 설치할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="33080a774d1683a847960294bf99870a610d6d24" translate="yes" xml:space="preserve">
          <source>This time we get the right answer:</source>
          <target state="translated">이번에는 정답을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="de132ff4c4de4a8dae8876bdea9d65e3845d2e34" translate="yes" xml:space="preserve">
          <source>This time we have got all the key/value pairs, including the multiple values associated with the key &lt;code&gt;Wall&lt;/code&gt; .</source>
          <target state="translated">이번에는 &lt;code&gt;Wall&lt;/code&gt; 키와 관련된 여러 값을 포함하여 모든 키 / 값 쌍을 얻었습니다 .</target>
        </trans-unit>
        <trans-unit id="549daec07a3febc80783db85efb5cb76a1300cf5" translate="yes" xml:space="preserve">
          <source>This time we've decided to blow up (raise an exception) if the renice fails--there's no place for us to return an error otherwise, and it's probably the right thing to do.</source>
          <target state="translated">이번에 우리는 renice가 실패 할 경우 폭발 (예외 발생)하기로 결정했습니다. 그렇지 않으면 오류를 반환 할 수있는 곳이 없으며 아마도 옳은 일일 것입니다.</target>
        </trans-unit>
        <trans-unit id="e8220bb1a44581d2e3ca1f66709b3d28e4dca5ce" translate="yes" xml:space="preserve">
          <source>This time whenever &lt;code&gt;CallSavedSub1&lt;/code&gt; gets called it will execute the Perl subroutine &lt;code&gt;joe&lt;/code&gt; (assuming it exists) rather than &lt;code&gt;fred&lt;/code&gt; as was originally requested in the call to &lt;code&gt;SaveSub1&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;CallSavedSub1&lt;/code&gt; 는 CallSavedSub1 이 호출 될 때마다 원래 &lt;code&gt;SaveSub1&lt;/code&gt; 호출에서 요청한 &lt;code&gt;fred&lt;/code&gt; 대신 Perl 서브 루틴 &lt;code&gt;joe&lt;/code&gt; (존재한다고 가정) 를 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="f97f664a05e05836532f171c31abc8294dc4fa2e" translate="yes" xml:space="preserve">
          <source>This timeout prevents CPAN from hanging when trying to parse a pathologically coded $VERSION from a module.</source>
          <target state="translated">이 시간 종료는 모듈에서 병적으로 코딩 된 $ VERSION을 구문 분석 할 때 CPAN이 정지되는 것을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="818cb77ceebe03d7349ba167c3cce5e948a3bb9b" translate="yes" xml:space="preserve">
          <source>This tip has been brought to you by Nick Ing-Simmons and Stas Bekman.</source>
          <target state="translated">이 팁은 Nick Ing-Simmons와 Stas Bekman이 가져 왔습니다.</target>
        </trans-unit>
        <trans-unit id="1ad35df16ed4d238965d8000164af0c76d6be400" translate="yes" xml:space="preserve">
          <source>This token is only available under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; or the &quot;current_sub&quot; feature. See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;.</source>
          <target state="translated">이 토큰은 아래에만 사용할 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; 또는 &quot;current_sub&quot;기능. &lt;a href=&quot;feature&quot;&gt;기능을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="35716269721e35aed3ed9931d09baf8957f4a7d8" translate="yes" xml:space="preserve">
          <source>This token is only available under &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; or the &quot;current_sub&quot; feature. See &lt;a href=&quot;../feature&quot;&gt;feature&lt;/a&gt;.</source>
          <target state="translated">이 토큰은 아래에만 사용할 수 있습니다 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; 또는 &quot;current_sub&quot;기능. &lt;a href=&quot;../feature&quot;&gt;기능을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a442863544084141507fc6b9cc253372f4528af" translate="yes" xml:space="preserve">
          <source>This token tells &lt;b&gt;sigtrap&lt;/b&gt; to install handlers for all subsequently listed signals. This is the default behavior.</source>
          <target state="translated">이 토큰은 &lt;b&gt;sigtrap&lt;/b&gt; 에게 이후에 나열된 모든 신호에 대한 핸들러를 설치하도록 지시 합니다. 이것이 기본 동작입니다.</target>
        </trans-unit>
        <trans-unit id="563416938874462a6a3a7e213b018a4bbf3569b4" translate="yes" xml:space="preserve">
          <source>This token tells &lt;b&gt;sigtrap&lt;/b&gt; to install handlers only for subsequently listed signals which aren't already trapped or ignored.</source>
          <target state="translated">이 토큰은 &lt;b&gt;sigtrap&lt;/b&gt; 에게 아직 트랩되거나 무시되지 않은 이후에 나열된 신호에 대해서만 핸들러를 설치하도록 지시 합니다.</target>
        </trans-unit>
        <trans-unit id="dbef2365e83f0b66bb2b5afb7a58a64a398a46f8" translate="yes" xml:space="preserve">
          <source>This tool isn't appropriate for reporting bugs in any version prior to Perl 5.0.</source>
          <target state="translated">이 도구는 Perl 5.0 이전 버전의 버그를보고하는 데 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="88cd36d63ba450353c54dc7196ff92a040ad99b2" translate="yes" xml:space="preserve">
          <source>This translates as &quot;set &lt;code&gt;TARG&lt;/code&gt; to 10, push a pointer to &lt;code&gt;TARG&lt;/code&gt; onto the stack; set &lt;code&gt;TARG&lt;/code&gt; to 20, push a pointer to &lt;code&gt;TARG&lt;/code&gt; onto the stack&quot;. At the end of the operation, the stack does not contain the values 10 and 20, but actually contains two pointers to &lt;code&gt;TARG&lt;/code&gt; , which we have set to 20.</source>
          <target state="translated">등이를 번역 &quot;세트 &lt;code&gt;TARG&lt;/code&gt; 10는 포인터 푸시 &lt;code&gt;TARG&lt;/code&gt; 를 스택에, 세트 &lt;code&gt;TARG&lt;/code&gt; (20)는 포인터를 밀어 &lt;code&gt;TARG&lt;/code&gt; 스택으로&quot;. 작업이 끝나면 스택에는 값 10과 20이 포함되지 않지만 실제로는 &lt;code&gt;TARG&lt;/code&gt; 에 대한 두 개의 포인터가 포함되어 있습니다.이 포인터 는 20으로 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="ba94eb90171beedcd9bec6456a8694f27844f356" translate="yes" xml:space="preserve">
          <source>This transport contacts a remote SMTP server over TCP. It optionally uses SSL and can authenticate to the server via SASL.</source>
          <target state="translated">이 전송은 TCP를 통해 원격 SMTP 서버에 연결합니다. 선택적으로 SSL을 사용하고 SASL을 통해 서버를 인증 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5f84e699be8b82423bdf0c8efc71c8b6cffc002" translate="yes" xml:space="preserve">
          <source>This tree has 5 nodes (one per &lt;code&gt;TYPE&lt;/code&gt; specifier), only 3 of them are not optimized away (one per number in the left column). The immediate children of the given node correspond to &lt;code&gt;{}&lt;/code&gt; pairs on the same level of indentation, thus this listing corresponds to the tree:</source>
          <target state="translated">이 트리에는 5 개의 노드 ( &lt;code&gt;TYPE&lt;/code&gt; 지정 자당 하나 )가 있으며 그 중 3 개만 최적화되지 않습니다 (왼쪽 열의 숫자 당 하나). 주어진 노드의 직계 자식은 같은 들여 쓰기 수준의 &lt;code&gt;{}&lt;/code&gt; 쌍에 해당하므로이 목록은 트리에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="10bdb23da270b66c79801ca69744614d31056771" translate="yes" xml:space="preserve">
          <source>This tries loading classes based on the language-tags you give (like &lt;code&gt;(&quot;en-US&quot;, &quot;sk&quot;, &quot;kon&quot;, &quot;es-MX&quot;, &quot;ja&quot;, &quot;i-klingon&quot;)&lt;/code&gt; , and for the first class that succeeds, returns YourProjClass::</source>
          <target state="translated">이렇게하면 제공하는 언어 태그 (예 &lt;code&gt;(&quot;en-US&quot;, &quot;sk&quot;, &quot;kon&quot;, &quot;es-MX&quot;, &quot;ja&quot;, &quot;i-klingon&quot;)&lt;/code&gt; 기반으로 클래스를로드하려고합니다. 및 첫 번째에 대한 합니다. 성공한 클래스는 YourProjClass :를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2350736fbbdb09c3e03af560458218f7c39a0887" translate="yes" xml:space="preserve">
          <source>This tries to get the title string out of $parser, by getting some tokens, and scanning them for the title, and then ungetting them so that you can process the token-stream from the beginning.</source>
          <target state="translated">이것은 토큰을 가져 와서 제목을 스캔 한 다음 토큰 스트림을 가져 와서 처음부터 토큰 스트림을 처리하여 $ parser에서 제목 문자열을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="2c43b29369b0643df2b475c636f7ba4a7760104c" translate="yes" xml:space="preserve">
          <source>This tutorial assumes that the make program that Perl is configured to use is called &lt;code&gt;make&lt;/code&gt; . Instead of running &quot;make&quot; in the examples that follow, you may have to substitute whatever make program Perl has been configured to use. Running &lt;b&gt;perl -V:make&lt;/b&gt; should tell you what it is.</source>
          <target state="translated">이 튜토리얼은 펄이 사용하도록 구성되어 있는지 만들기 프로그램이 호출한다고 가정 &lt;code&gt;make&lt;/code&gt; . 다음 예제에서 &quot;make&quot;를 실행하는 대신 Perl이 사용하도록 구성된 make 프로그램을 대체해야 할 수도 있습니다. &lt;b&gt;perl -V : make를&lt;/b&gt; 실행 하면 그것이 무엇인지 알려줘야합니다.</target>
        </trans-unit>
        <trans-unit id="8c02c1e1c4554cfc38ab4519576c46376d729f42" translate="yes" xml:space="preserve">
          <source>This tutorial can still be used on such a system. The XSUB build mechanism will check the system and build a dynamically-loadable library if possible, or else a static library and then, optionally, a new statically-linked executable with that static library linked in.</source>
          <target state="translated">이 튜토리얼은 여전히 ​​그러한 시스템에서 사용될 수 있습니다. XSUB 빌드 메커니즘은 시스템을 확인하고 가능하면 동적으로로드 가능한 라이브러리 또는 정적 라이브러리를 빌드 한 다음 선택적으로 해당 정적 라이브러리가 링크 된 새 정적 링크 실행 파일을 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="042a6a29ffea342487866bd18b2ff67e8550a4e6" translate="yes" xml:space="preserve">
          <source>This tutorial describes the use of Perl interpreter threads (sometimes referred to as</source>
          <target state="translated">이 학습서에서는 Perl 인터프리터 스레드 (때로는</target>
        </trans-unit>
        <trans-unit id="584c62ddbbc858e85333edcc1d7b6494d833b45b" translate="yes" xml:space="preserve">
          <source>This tutorial flattens the learning curve by discussing regular expression concepts, along with their notation, one at a time and with many examples. The first part of the tutorial will progress from the simplest word searches to the basic regular expression concepts. If you master the first part, you will have all the tools needed to solve about 98% of your needs. The second part of the tutorial is for those comfortable with the basics and hungry for more power tools. It discusses the more advanced regular expression operators and introduces the latest cutting-edge innovations.</source>
          <target state="translated">이 튜토리얼은 정규 표현 개념과 표기법, 한 번에 하나씩 그리고 많은 예제를 논의함으로써 학습 곡선을 평평하게합니다. 학습서의 첫 번째 부분은 가장 간단한 단어 검색에서 기본 정규 표현식 개념으로 진행됩니다. 첫 번째 부분을 마스터하면 약 98 %의 요구를 해결하는 데 필요한 모든 도구가 제공됩니다. 튜토리얼의 두 번째 부분은 기본 사항에 익숙하고 더 많은 전동 공구를 원하는 사람들을위한 것입니다. 보다 고급 정규 표현식 연산자에 대해 설명하고 최신 최첨단 혁신을 소개합니다.</target>
        </trans-unit>
        <trans-unit id="09418d1e9dc1ccd649181b2ae1d0e9cc30227030" translate="yes" xml:space="preserve">
          <source>This tutorial speaks in rather absolute terms, and provides only a limited view of the wealth of character string related features that Perl has to offer. For most projects, this information will probably suffice.</source>
          <target state="translated">이 튜토리얼은 절대적인 용어로 설명하고 Perl이 제공해야하는 다양한 문자열 관련 기능에 대한 제한된보기 만 제공합니다. 대부분의 프로젝트에서이 정보로 충분할 것입니다.</target>
        </trans-unit>
        <trans-unit id="5a1babab3f5740242709a97dfef0170b83cfd116" translate="yes" xml:space="preserve">
          <source>This tutorial starts with very simple examples and becomes more complex, with each new example adding new features. Certain concepts may not be completely explained until later in the tutorial in order to slowly ease the reader into building extensions.</source>
          <target state="translated">이 튜토리얼은 매우 간단한 예제로 시작하여 새로운 예제를 추가 할 때마다 새로운 기능을 추가함으로써 더욱 복잡해집니다. 독자가 건물 확장을 천천히 편하게하기 위해 튜토리얼 후반까지 특정 개념을 완전히 설명하지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="513743e90a808d724cf722e256c18c6a577aed36" translate="yes" xml:space="preserve">
          <source>This tutorial was written from a Unix point of view. Where I know them to be otherwise different for other platforms (e.g. Win32), I will list them. If you find something that was missed, please let me know.</source>
          <target state="translated">이 튜토리얼은 유닉스 관점에서 작성되었습니다. 다른 플랫폼 (예 : Win32)과 다른 점을 알고있는 경우 이들을 나열합니다. 놓친 부분이 있으면 알려주십시오.</target>
        </trans-unit>
        <trans-unit id="2d3bc7e20dd6d03170372006d4bcd471be2b1a05" translate="yes" xml:space="preserve">
          <source>This tutorial will educate the reader on the steps involved in creating a Perl extension. The reader is assumed to have access to &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;, &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; and &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;.</source>
          <target state="translated">이 학습서에서는 Perl 확장 작성과 관련된 단계에 대해 독자에게 교육합니다. 독자는 &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; , &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; 및 &lt;a href=&quot;perlxs&quot;&gt;perlxs에&lt;/a&gt; 액세스 할 수 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="73d6133ba18859a5eaedd64f01ef459aa33a4f61" translate="yes" xml:space="preserve">
          <source>This ucfirst form of #var generates a tag-value form of itself for display; it converts '#Var' into a 'Var =&amp;gt; #var' style, which is then handled as described above. (Imp-note: #Vars cannot be used for conditional-fills, because the =&amp;gt; #var transform is done after the check for #Var's value).</source>
          <target state="translated">이 ucfirst 형식의 #var은 표시 할 자체의 태그-값 형식을 생성합니다. '#Var'을 'Var =&amp;gt; #var'스타일로 변환 한 다음 위에서 설명한대로 처리합니다. 참고 : #Var의 값을 확인한 후 =&amp;gt; #var 변환이 수행되므로 조건부 채우기에는 #Vars를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e1c48ccdb02bacfa9c7db277adb42c2586c3c859" translate="yes" xml:space="preserve">
          <source>This unloading is usually necessary when embedding a shared-object perl (e.g. one configured with -Duseshrplib) within a larger application, and the perl interpreter is created and destroyed several times within the lifetime of the application. In this case it is possible that the system dynamic linker will unload and then subsequently reload the shared libperl without relocating any references to it from any files DynaLoaded by the previous incarnation of the interpreter. As a result, any shared objects opened by DynaLoader may point to a now invalid 'ghost' of the libperl shared object, causing apparently random memory corruption and crashes. This behaviour is most commonly seen when using Apache and mod_perl built with the APXS mechanism.</source>
          <target state="translated">이 언로드는 일반적으로 더 큰 응용 프로그램 내에 공유 오브젝트 perl (예 : -Duseshrplib로 구성된 것)을 임베드 할 때 필요하며 perl 인터프리터는 응용 프로그램의 수명 내에 여러 번 작성되어 파괴됩니다. 이 경우, 시스템 동적 링커는 인터프리터의 이전 구현에 의해 DynaLoaded 파일에서 참조를 재배치하지 않고 공유 libperl을 언로드 한 다음 다시로드 할 수 있습니다. 결과적으로, DynaLoader에 의해 열린 공유 객체는 libperl 공유 객체의 현재 유효하지 않은 '고스트'를 가리켜 서 임의의 메모리 손상 및 충돌을 일으킬 수 있습니다. 이 동작은 APXS 메커니즘으로 빌드 된 Apache 및 mod_perl을 사용할 때 가장 일반적으로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="1b13f3deb5370e5675a9d76c565d42ae5d602f71" translate="yes" xml:space="preserve">
          <source>This usage is deprecated, because the behavior is likely to change in a future version of Perl.</source>
          <target state="translated">향후 버전의 Perl에서는 동작이 변경 될 수 있으므로이 사용법은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d8b6fb62901deb9e84ba258e77b4c4979b396131" translate="yes" xml:space="preserve">
          <source>This used to provide support for the old 5.005 threading module. It now does nothing.</source>
          <target state="translated">이전 5.005 스레딩 모듈을 지원하는 데 사용되었습니다. 이제는 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ad74ce7c330e222ac3a23c23df9097ca9cc782c1" translate="yes" xml:space="preserve">
          <source>This uses &lt;code&gt;[...]&lt;/code&gt; notation to create a new anonymous array, and &lt;code&gt;$aref2&lt;/code&gt; is assigned a reference to the new array. The new array is initialized with the contents of the array referred to by &lt;code&gt;$aref1&lt;/code&gt; .</source>
          <target state="translated">이것은 &lt;code&gt;[...]&lt;/code&gt; 표기법을 사용하여 새로운 익명 배열을 만들고 &lt;code&gt;$aref2&lt;/code&gt; 에 새로운 배열에 대한 참조가 할당됩니다. 새 배열은 &lt;code&gt;$aref1&lt;/code&gt; 참조하는 배열의 내용으로 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="0ec25d0bdb752659175b1040a999aeb2b6d490b8" translate="yes" xml:space="preserve">
          <source>This uses a comment character so that we can distinguish a &lt;code&gt;set&lt;/code&gt; value (from a previous</source>
          <target state="translated">주석 문자를 사용하여 &lt;code&gt;set&lt;/code&gt; 값을 이전 과 구별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc1cad67a921e3eb4640eba7ead1b7740937eea5" translate="yes" xml:space="preserve">
          <source>This uses file descriptors such as those obtained by calling &lt;code&gt;POSIX::open&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;POSIX::open&lt;/code&gt; 을 호출하여 얻은 것과 같은 파일 디스크립터를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="5a9ad1aba7c9a639b483b1f8f929290363dd11bd" translate="yes" xml:space="preserve">
          <source>This utility is designed to write a Makefile for an extension module from a Makefile.PL. It is based on the Makefile.SH model provided by Andy Dougherty and the perl5-porters.</source>
          <target state="translated">이 유틸리티는 Makefile.PL에서 확장 모듈의 Makefile을 작성하도록 설계되었습니다. Andy Dougherty와 perl5-porter가 제공 한 Makefile.SH 모델을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="b24b7df29646f7c014772e5059f3068df5bbacbd" translate="yes" xml:space="preserve">
          <source>This utility takes a list of libraries in the form &lt;code&gt;-llib1 -llib2
-llib3&lt;/code&gt; and returns lines suitable for inclusion in an extension Makefile. Extra library paths may be included with the form &lt;code&gt;-L/another/path&lt;/code&gt; this will affect the searches for all subsequent libraries.</source>
          <target state="translated">이 유틸리티는 &lt;code&gt;-llib1 -llib2 -llib3&lt;/code&gt; 형식의 라이브러리 목록을 사용 하여 확장자 Makefile에 포함하기에 적합한 행을 리턴합니다. 추가 라이브러리 경로는 &lt;code&gt;-L/another/path&lt;/code&gt; 형식으로 포함될 수 있으며 이는 이후의 모든 라이브러리 검색에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="b766c16803f46a0ae895c110a4b6edf915519f91" translate="yes" xml:space="preserve">
          <source>This utility will read *.pl files (given as parameters) and write corresponding *.pm files. The pl2pm utilities does the following:</source>
          <target state="translated">이 유틸리티는 * .pl 파일 (매개 변수로 제공)을 읽고 해당 * .pm 파일을 작성합니다. pl2pm 유틸리티는 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="a410c695becbafd5bc2593139ba56b80c63242e8" translate="yes" xml:space="preserve">
          <source>This utility, that comes with the &lt;code&gt;Digest::SHA&lt;/code&gt; module, is used to print or verify SHA checksums.</source>
          <target state="translated">&lt;code&gt;Digest::SHA&lt;/code&gt; 모듈 과 함께 제공되는이 유틸리티 는 SHA 체크섬을 인쇄하거나 확인하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fa4ff7242b8a2fd67b36df12914e2cc6d1af606d" translate="yes" xml:space="preserve">
          <source>This value can be adjusted to reduce security checking if required. The value is only relevant when C</source>
          <target state="translated">필요한 경우 보안 검사를 줄이기 위해이 값을 조정할 수 있습니다. 이 값은 C</target>
        </trans-unit>
        <trans-unit id="7591c615f6c14e41979e1eaadb2f09a869a865a0" translate="yes" xml:space="preserve">
          <source>This value overrides any &lt;code&gt;stack_size&lt;/code&gt; parameter given to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; . Its primary purpose is to permit setting the per-thread stack size for legacy threaded applications.</source>
          <target state="translated">이 값은 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; 를 &lt;a href=&quot;functions/use&quot;&gt;사용하도록&lt;/a&gt; 주어진 &lt;code&gt;stack_size&lt;/code&gt; 매개 변수를 대체합니다 . 주요 목적은 레거시 스레드 응용 프로그램의 스레드 별 스택 크기를 설정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="41ecf008113019e40a6e54f73ff5a98b48282c9e" translate="yes" xml:space="preserve">
          <source>This variable (default is 1) controls whether to enforce the contents of $^E to start with &lt;code&gt;SYS0003&lt;/code&gt; -like id. If set to 0, then the string value of $^E is what is available from the OS/2 message file. (Some messages in this file have an &lt;code&gt;SYS0003&lt;/code&gt; -like id prepended, some not.)</source>
          <target state="translated">이 변수 (기본값은 1)는 $ ^ E의 내용을 &lt;code&gt;SYS0003&lt;/code&gt; 과 유사한 id 로 시작할지 여부를 제어합니다 . 0으로 설정되면 문자열 값 $ ^ E는 OS / 2 메시지 파일에서 사용 가능한 값입니다. (이 파일의 일부 메시지는 앞에 추가 된 &lt;code&gt;SYS0003&lt;/code&gt; 과 유사한 ID를 갖습니다 .)</target>
        </trans-unit>
        <trans-unit id="16732492f2d070676c6f99bbc0efae47b95f7071" translate="yes" xml:space="preserve">
          <source>This variable bears the symbol value to be used during open() or fcntl() to turn on non-blocking I/O for a file descriptor. If you wish to switch between blocking and non-blocking, you may try ioctl(&lt;code&gt;FIOSNBIO&lt;/code&gt; ) instead, but that is only supported by some devices.</source>
          <target state="translated">이 변수는 open () 또는 fcntl () 중에 파일 디스크립터에 대한 비 블로킹 I / O를 설정하는 데 사용되는 기호 값을 갖습니다. 차단과 비 차단간에 전환하려면 대신 ioctl ( &lt;code&gt;FIOSNBIO&lt;/code&gt; )을 시도 할 수 있지만 일부 장치에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="cca2eeea3350d961dcaad04aa855c2a1f247bac2" translate="yes" xml:space="preserve">
          <source>This variable bears the symbolic errno code set by read() when no data is present on the file and non-blocking I/O was enabled (otherwise, read() blocks naturally).</source>
          <target state="translated">이 변수는 파일에 데이터가없고 비 차단 I / O가 활성화 된 경우 (그렇지 않으면 자연스럽게 read () 블록) read ()로 설정된 기호 errno 코드를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="248382abe33b16964803e73f6ecfb34faabcc93f" translate="yes" xml:space="preserve">
          <source>This variable can be used to determine whether the Perl interpreter executing a script is in the right range of versions:</source>
          <target state="translated">이 변수는 스크립트를 실행하는 Perl 인터프리터가 올바른 버전의 버전인지 여부를 판별하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dfea1020f3dea68d67242c313286038f4a0d0e35" translate="yes" xml:space="preserve">
          <source>This variable can be used to establish a fallthrough for the cases where nm fails to find a symbol. If usenm is false or usenm is true and mistrustnm is false, this variable has no effect. If usenm is true and mistrustnm is &lt;code&gt;compile&lt;/code&gt; , a test program will be compiled to try to find any symbol that can't be located via nm lookup. If mistrustnm is &lt;code&gt;run&lt;/code&gt; , the test program will be run as well as being compiled.</source>
          <target state="translated">nm가 심볼을 찾지 못하는 경우에이 변수를 사용하여 폴 스루를 설정할 수 있습니다. usenm가 false이거나 usenm가 true이고 mistrustnm이 false 인 경우이 변수는 영향을 미치지 않습니다. usenm이 true이고 mistrustnm이 &lt;code&gt;compile&lt;/code&gt; 인 경우 nm 검색을 통해 찾을 수없는 기호를 찾기 위해 테스트 프로그램이 컴파일됩니다. mistrustnm이 &lt;code&gt;run&lt;/code&gt; 되면 테스트 프로그램이 실행되고 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="4b0fbadd8567e78cf31399e6a2260ad4aafcd61e" translate="yes" xml:space="preserve">
          <source>This variable combines api_revision, api_version, and api_subversion in a format such as 5.6.1 (or 5_6_1) suitable for use as a directory name. This is filesystem dependent.</source>
          <target state="translated">이 변수는 api_revision, api_version 및 api_subversion을 디렉토리 이름으로 사용하기에 적합한 5.6.1 (또는 5_6_1) 형식으로 결합합니다. 이것은 파일 시스템에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="3a2c3f8de756634885e7def1800fcfd4dd0d57a3" translate="yes" xml:space="preserve">
          <source>This variable conditionally defined &lt;code&gt;PERL_VENDORARCH&lt;/code&gt; .</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;PERL_VENDORARCH&lt;/code&gt; 를 정의 했습니다 .</target>
        </trans-unit>
        <trans-unit id="efd929c3d0bcbeeec8636fa669401d4e86c870d3" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;ARCHLIB&lt;/code&gt; to hold the pathname of architecture-dependent library files for $package. If $archlib is the same as $privlib, then this is set to undef.</source>
          <target state="translated">이 변수는 $ package에 대한 아키텍처 종속 라이브러리 파일의 경로 이름을 보유하도록 &lt;code&gt;ARCHLIB&lt;/code&gt; 를 조건부로 정의 합니다. $ archlib가 $ privlib와 같으면 undef로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="ef97d2a231904adfc4265eba4006701690eed6ca" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;CAN_VAPROTO&lt;/code&gt; on systems supporting prototype declaration of functions with a variable number of arguments. See also prototype.</source>
          <target state="translated">이 변수 는 가변 개수의 인수로 함수의 프로토 타입 선언을 지원하는 시스템에서 조건 적으로 &lt;code&gt;CAN_VAPROTO&lt;/code&gt; 를 정의합니다 . 프로토 타입도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="980485e36e7b05790618d387e3c7b5f9dffdd4ab" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;CASTNEG&lt;/code&gt; , which indicates whether the C compiler can cast negative float to unsigned.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;CASTNEG&lt;/code&gt; 를 정의 하는데 , 이는 C 컴파일러가 음수 부동 소수점을 부호없는 것으로 캐스트 할 수 있는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6a2c21b1fb400d236c7f8b93084483db1894c446" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;CHARVSPRINTF&lt;/code&gt; if this system has vsprintf returning type (char*). The trend seems to be to declare it as &quot;int vsprintf()&quot;.</source>
          <target state="translated">이 시스템에 vsprintf 리턴 유형 (char *)이있는 &lt;code&gt;CHARVSPRINTF&lt;/code&gt; 변수는 조건부로 CHARVSPRINTF를 정의합니다 . 트렌드는 이것을 &quot;int vsprintf ()&quot;로 선언하는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="5078955ce08b58cadcdb20d3c38df82d26ee60ff" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;CTERMID&lt;/code&gt; if ctermid() is available to generate filename for terminal.</source>
          <target state="translated">이 변수는 ctermid ()를 사용하여 터미널의 파일 이름을 생성 할 수있는 경우 조건 적으로 &lt;code&gt;CTERMID&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="978df228f8d800c08979baf4f0b9bb0fc46ebfa9" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;DIRNAMLEN&lt;/code&gt; , which indicates to the C program that the length of directory entry names is provided by a d_namelen field.</source>
          <target state="translated">이 변수는 &lt;code&gt;DIRNAMLEN&lt;/code&gt; 을 조건부로 정의 하며 , 이는 디렉토리 항목 이름의 길이가 d_namelen 필드에 의해 제공됨을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="df3c72fff3ec53eb910b33c4d8de7ba859b22249" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;DLSYM_NEEDS_UNDERSCORE&lt;/code&gt; , which indicates that we need to prepend an underscore to the symbol name before calling dlsym().</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;DLSYM_NEEDS_UNDERSCORE&lt;/code&gt; 를 정의합니다 . 이는 dlsym ()을 호출하기 전에 기호 이름 앞에 밑줄을 추가해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="49b013eda5d273dde0c71244769fe3ad52ab910f" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;EBCDIC&lt;/code&gt; if this system uses &lt;code&gt;EBCDIC&lt;/code&gt; encoding.</source>
          <target state="translated">이 시스템이 &lt;code&gt;EBCDIC&lt;/code&gt; 인코딩을 사용하는 경우이 변수는 조건부로 &lt;code&gt;EBCDIC&lt;/code&gt; 을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="95f5847b07ee6a0574affcb0afba6691ba0cb5dc" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;EOF_NONBLOCK&lt;/code&gt; if &lt;code&gt;EOF&lt;/code&gt; can be seen when reading from a non-blocking I/O source.</source>
          <target state="translated">이 변수는 조건부 정의 &lt;code&gt;EOF_NONBLOCK&lt;/code&gt; 을 경우 &lt;code&gt;EOF&lt;/code&gt; 가 비 블로킹 I / O 소스에서 읽을 때 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0af8dac12168ddb05c87d99076fc3d364dbfc497" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;GRPASSWD&lt;/code&gt; , which indicates that struct group in &amp;lt;grp.h&amp;gt; contains gr_passwd.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;GRPASSWD&lt;/code&gt; 를 정의합니다 . 이는 &amp;lt;grp.h&amp;gt;의 구조체 그룹에 gr_passwd가 포함되어 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e239460b32f067f0e57a573c2a38cc269c4e8cf6" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_DEPRECATED&lt;/code&gt; , which indicates that &lt;code&gt;GCC&lt;/code&gt; can handle the attribute for marking deprecated APIs</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HASATTRIBUTE_DEPRECATED&lt;/code&gt; 를 정의합니다 . 이는 &lt;code&gt;GCC&lt;/code&gt; 가 더 이상 사용되지 않는 API를 표시하기위한 속성을 처리 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="096a4e7335c9e97171f7b50c60f3c4f1d139650c" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_FORMAT&lt;/code&gt; , which indicates the C compiler can check for printf-like formats.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HASATTRIBUTE_FORMAT&lt;/code&gt; 을 정의합니다 . 이는 C 컴파일러가 printf와 같은 형식을 확인할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0fc32aff59b98aa4940aa65546e2ce2f0bae5f6b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_MALLOC&lt;/code&gt; , which indicates the C compiler can understand functions as having malloc-like semantics.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HASATTRIBUTE_MALLOC&lt;/code&gt; 을 정의합니다 . 이는 C 컴파일러가 malloc와 유사한 의미를 갖는 것으로 함수를 이해할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cc77040e22d8dbd38fd3bdef2b4c807ff2648d0f" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_NONNULL&lt;/code&gt; , which indicates that the C compiler can know that certain arguments must not be &lt;code&gt;NULL&lt;/code&gt; , and will check accordingly at compile time.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HASATTRIBUTE_NONNULL&lt;/code&gt; 을 정의합니다 . 이는 C 컴파일러가 특정 인수가 &lt;code&gt;NULL&lt;/code&gt; 이 아니어야한다는 것을 알 수 있으며 컴파일시 적절하게 검사합니다.</target>
        </trans-unit>
        <trans-unit id="c1ca1b192eaeeef39ff342721f49f9732f5c25b0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_NORETURN&lt;/code&gt; , which indicates that the C compiler can know that certain functions are guaranteed never to return.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HASATTRIBUTE_NORETURN&lt;/code&gt; 을 정의합니다 . 이는 C 컴파일러가 특정 함수가 절대 리턴하지 않을 것임을 알 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="35f0cde07593cb535b92fefc63eb7d81d46fe8bb" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_PURE&lt;/code&gt; , which indicates that the C compiler can know that certain functions are &lt;code&gt;pure&lt;/code&gt; functions, meaning that they have no side effects, and only rely on function input</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HASATTRIBUTE_PURE&lt;/code&gt; 를 정의합니다 . 이는 C 컴파일러가 특정 함수가 &lt;code&gt;pure&lt;/code&gt; 함수임을 알 수 있으며, 이는 부작용이 없으며 함수 입력에만 의존 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="420fa8e106aa6be346627e32f034151a52362ffe" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_UNUSED&lt;/code&gt; , which indicates that the C compiler can know that certain variables and arguments may not always be used, and to not throw warnings if they don't get used.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HASATTRIBUTE_UNUSED&lt;/code&gt; 를 정의합니다 . 이는 C 컴파일러가 특정 변수 및 인수가 항상 사용되지 않을 수 있음을 알 수 있으며 사용되지 않을 경우 경고를 발생시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ddcad35f0c318736909295f4f6cd964d37f1a53f" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_WARN_UNUSED_RESULT&lt;/code&gt; , which indicates that the C compiler can know that certain functions have a return values that must not be ignored, such as malloc() or open().</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HASATTRIBUTE_WARN_UNUSED_RESULT&lt;/code&gt; 를 정의합니다 . 이는 C 컴파일러가 malloc () 또는 open ()과 같이 특정 함수에 무시해서는 안되는 반환 값이 있음을 알 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4f215b234b46ef7c56eb723ad08f919ae0a7c950" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_ACCESS&lt;/code&gt; if the access() system call is available to check for access permissions using real IDs.</source>
          <target state="translated">이 변수 는 access () 시스템 호출이 실제 ID를 사용하여 액세스 권한을 확인할 수있는 경우 &lt;code&gt;HAS_ACCESS&lt;/code&gt; 를 조건부로 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="7c105d4e6058827fec8056bf20316718cbab9faa" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_CLOSEDIR&lt;/code&gt; if closedir() is available.</source>
          <target state="translated">closedir ()를 사용할 수있는 &lt;code&gt;HAS_CLOSEDIR&lt;/code&gt; 변수는 조건부로 HAS_CLOSEDIR을 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="8654218934b9b6758432460c578cc5a644b91d92" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_ENDHOSTENT&lt;/code&gt; if endhostent() is available to close whatever was being used for host queries.</source>
          <target state="translated">endhostent ()를 사용하여 호스트 쿼리에 사용중인 항목을 닫을 수있는 &lt;code&gt;HAS_ENDHOSTENT&lt;/code&gt; 변수는 조건부로 HAS_ENDHOSTENT를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="79e5c8edfd4691e1b4f25bb1c714fe1507e829f4" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_ENDNETENT&lt;/code&gt; if endnetent() is available to close whatever was being used for network queries.</source>
          <target state="translated">endnetent ()를 사용하여 네트워크 쿼리에 사용중인 항목을 모두 닫을 수있는 &lt;code&gt;HAS_ENDNETENT&lt;/code&gt; 변수는 조건부로 HAS_ENDNETENT를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="23979ba16f9e3dd7409c1aeb4d7d4d5911e864e5" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_ENDPROTOENT&lt;/code&gt; if endprotoent() is available to close whatever was being used for protocol queries.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_ENDPROTOENT&lt;/code&gt; ()를 사용하여 프로토콜 쿼리에 사용중인 항목을 닫을 수있는 경우 조건부로 HAS_ENDPROTOENT를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="1f85023e116dfb459bcb6c6b9ea107e1880da801" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_ENDSERVENT&lt;/code&gt; if endservent() is available to close whatever was being used for service queries.</source>
          <target state="translated">이 변수는 endservent ()를 사용하여 서비스 쿼리에 사용중인 항목을 닫을 수있는 경우 조건부로 &lt;code&gt;HAS_ENDSERVENT&lt;/code&gt; 를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="9026ce557a983587089262cdc30c657f39523536" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_FEGETROUND&lt;/code&gt; if fegetround() is available to get the floating point rounding mode.</source>
          <target state="translated">부동 소수점 반올림 모드를 얻기 위해 fegetround ()를 사용할 수있는 &lt;code&gt;HAS_FEGETROUND&lt;/code&gt; 변수는 조건부로 HAS_FEGETROUND를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="a5695e9822f626cc75613841b734f1880b97e1cd" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_FGETPOS&lt;/code&gt; if fgetpos() is available to get the file position indicator.</source>
          <target state="translated">이 변수는 fgetpos ()를 사용하여 파일 위치 표시기를 가져올 수있는 경우 조건부로 &lt;code&gt;HAS_FGETPOS&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="ecd11d67113d55076e38c3f87fbec174b96046c1" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_FLOCK&lt;/code&gt; if flock() is available to do file locking.</source>
          <target state="translated">이 변수는 flock ()을 사용하여 파일 잠금을 수행 할 수있는 경우 조건부로 &lt;code&gt;HAS_FLOCK&lt;/code&gt; 을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="d12df32e7c3e2769df2173cc4aeba55819c508b3" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_FPGETROUND&lt;/code&gt; if fpgetround() is available to get the floating point rounding mode.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_FPGETROUND&lt;/code&gt; ()를 사용하여 부동 소수점 반올림 모드를 사용할 수있는 경우 조건부로 HAS_FPGETROUND를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="7caed5a67bbd1068f15dc1afc8a52fbcbb8a3a6c" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_FSETPOS&lt;/code&gt; if fsetpos() is available to set the file position indicator.</source>
          <target state="translated">이 변수는 fsetpos ()를 사용하여 파일 위치 표시기를 설정할 수있는 경우 조건부로 &lt;code&gt;HAS_FSETPOS&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="4ca1f26e1ee2a6d6b7bcc20d2c601de0d8652782" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_GETESPWNAM&lt;/code&gt; if getespwnam() is available to retrieve enhanced (shadow) password entries by name.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_GETESPWNAM&lt;/code&gt; ()을 사용하여 강화 된 (그림자) 비밀번호 항목을 이름으로 검색 할 수있는 경우 조건부로 HAS_GETESPWNAM을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="523b849ed0e10fbdf244f4e8cd77184e7b2e7e2e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_GETHOSTENT&lt;/code&gt; if gethostent() is available to look up host names in some data base or another.</source>
          <target state="translated">이 변수는 gethostent ()를 사용하여 일부 데이터베이스 나 다른 호스트에서 호스트 이름을 조회 할 수있는 경우 조건부로 &lt;code&gt;HAS_GETHOSTENT&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="c477102d11cefe29ba1af921e3e01940cce25886" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_GETNETENT&lt;/code&gt; if getnetent() is available to look up network names in some data base or another.</source>
          <target state="translated">이 변수는 getnetent ()를 사용하여 일부 데이터베이스에서 네트워크 이름을 조회 할 수있는 경우 &lt;code&gt;HAS_GETNETENT&lt;/code&gt; 를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="3dd4221c56df17e7463336ebb61e6a0a59685106" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_GETPAGESIZE&lt;/code&gt; if getpagesize() is available to get the system page size.</source>
          <target state="translated">getpagesize ()를 사용하여 시스템 페이지 크기를 가져올 수있는 &lt;code&gt;HAS_GETPAGESIZE&lt;/code&gt; 변수는 조건부로 HAS_GETPAGESIZE를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="008f90e9dce5e248f0a062499f460cbfe1316a70" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_GETPGRP&lt;/code&gt; if getpgrp() is available to get the current process group.</source>
          <target state="translated">이 변수는 getpgrp ()를 사용하여 현재 프로세스 그룹을 가져올 수있는 경우 조건부로 &lt;code&gt;HAS_GETPGRP&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="466f30d3944227e178d079578b5e186c11b86479" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_GETPRIORITY&lt;/code&gt; if getpriority() is available to get a process's priority.</source>
          <target state="translated">프로세스 우선 순위를 얻기 위해 getpriority ()를 사용할 수있는 &lt;code&gt;HAS_GETPRIORITY&lt;/code&gt; 변수는 조건부로 HAS_GETPRIORITY를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="f8a60b1d5d8d846ce3f5e6fe4d7b072471b5e6c6" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_GETPROTOENT&lt;/code&gt; if getprotoent() is available to look up protocols in some data base or another.</source>
          <target state="translated">getprotoent ()를 사용하여 일부 데이터베이스에서 프로토콜을 조회 할 수있는 &lt;code&gt;HAS_GETPROTOENT&lt;/code&gt; 변수는 조건부로 HAS_GETPROTOENT를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="703bdebcae3a9b18831e785584b8e179d8f5569d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_GETPRPWNAM&lt;/code&gt; if getprpwnam() is available to retrieve protected (shadow) password entries by name.</source>
          <target state="translated">getprpwnam ()을 사용하여 보호 된 (그림자) 비밀번호 항목을 이름으로 검색 할 수있는 경우이 변수는 조건부로 &lt;code&gt;HAS_GETPRPWNAM&lt;/code&gt; 을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="d470dbda91b75051a9116195c5471b4cc0a994bc" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_GETSERVENT&lt;/code&gt; if getservent() is available to look up network services in some data base or another.</source>
          <target state="translated">getservent ()를 사용하여 일부 데이터베이스에서 네트워크 서비스를 검색 할 수있는 &lt;code&gt;HAS_GETSERVENT&lt;/code&gt; 변수는 조건부로 HAS_GETSERVENT를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="8f1532a01e5d8ec8dbefe92231b99738657124d6" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_GETSPNAM&lt;/code&gt; if getspnam() is available to retrieve SysV shadow password entries by name.</source>
          <target state="translated">getspnam ()을 사용하여 SysV 섀도우 암호 항목을 이름으로 검색 할 수있는 &lt;code&gt;HAS_GETSPNAM&lt;/code&gt; 변수는 조건부로 HAS_GETSPNAM을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="cfad68a688a0a88c6b15faed3a855ee7ed81db88" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_HTONL&lt;/code&gt; if htonl() and its friends are available to do network order byte swapping.</source>
          <target state="translated">이 변수는 htonl ()과 그 친구가 네트워크 순서 바이트 교환을 수행 할 수있는 경우 조건부로 &lt;code&gt;HAS_HTONL&lt;/code&gt; 을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="36ae55fc8ab6d9db052670febb9d6c73ffc9c7fe" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_HYPOT&lt;/code&gt; if hypot is available for numerically stable hypotenuse function.</source>
          <target state="translated">이 변수는 수치 적으로 안정적인 빗변 함수에 hypot를 사용할 수있는 경우 조건부로 &lt;code&gt;HAS_HYPOT&lt;/code&gt; 을 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="1c8f906308fe5425fd5dc9fc6c65283219211f28" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_INDEX&lt;/code&gt; if index() and rindex() are available for string searching.</source>
          <target state="translated">문자열 검색에 index () 및 rindex ()를 사용할 수있는 &lt;code&gt;HAS_INDEX&lt;/code&gt; 변수는 조건부로 HAS_INDEX를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="f58665b1066bffd31d93be9865becf02e07fbc33" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_LINK&lt;/code&gt; if link() is available to create hard links.</source>
          <target state="translated">이 변수는 하드 링크를 만드는 데 link ()를 사용할 수있는 경우 조건부로 &lt;code&gt;HAS_LINK&lt;/code&gt; 를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="f7aaa9b5790c7fed2f4557a1b76230d9dee2b872" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_LOCALECONV&lt;/code&gt; if localeconv() is available for numeric and monetary formatting conventions.</source>
          <target state="translated">localeconv ()를 숫자 및 통화 형식 규칙에 사용할 수있는 &lt;code&gt;HAS_LOCALECONV&lt;/code&gt; 변수는 조건부로 HAS_LOCALECONV를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="a3c4adc80b08fec49de9e85a9758844bbed93d4f" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_LOCKF&lt;/code&gt; if lockf() is available to do file locking.</source>
          <target state="translated">lockf ()를 사용하여 파일 잠금을 수행 할 수있는 &lt;code&gt;HAS_LOCKF&lt;/code&gt; 변수는 조건부로 HAS_LOCKF를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="a3309e731f7ec54de80f5709f885fa11f752d281" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_LONG_DOUBLE&lt;/code&gt; if the long double type is supported.</source>
          <target state="translated">long double 유형이 지원되는 &lt;code&gt;HAS_LONG_DOUBLE&lt;/code&gt; 변수는 조건부로 HAS_LONG_DOUBLE을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="f96dc22b2fabc7d6becfede8302b062283c67511" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_LONG_LONG&lt;/code&gt; if the long long type is supported.</source>
          <target state="translated">이 변수 는 long long 유형이 지원되는 경우 조건부로 &lt;code&gt;HAS_LONG_LONG&lt;/code&gt; 을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="bde46e5f10d187a1e49089e8f14937e758db8660" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_LSTAT&lt;/code&gt; if lstat() is available to do file stats on symbolic links.</source>
          <target state="translated">lstat ()를 사용하여 기호 링크에서 파일 통계를 수행 할 수있는 &lt;code&gt;HAS_LSTAT&lt;/code&gt; 변수는 조건부로 HAS_LSTAT를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="9c29d2f5108f120fc070de1998bbec52bcea01c7" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_MADVISE&lt;/code&gt; if madvise() is available to map a file into memory.</source>
          <target state="translated">이 변수는 madvise ()를 사용하여 파일을 메모리에 맵핑 할 수있는 경우 조건부로 &lt;code&gt;HAS_MADVISE&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="9773977cefbb09ffe9bf40f7bdd75aa66788128d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_MMAP&lt;/code&gt; if mmap() is available to map a file into memory.</source>
          <target state="translated">이 변수는 mmap ()을 사용하여 파일을 메모리에 매핑 할 수있는 경우 조건부로 &lt;code&gt;HAS_MMAP&lt;/code&gt; 을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="e49a09fbe97831dedb0097fc04c353ecd4fdc497" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_MPROTECT&lt;/code&gt; if mprotect() is available to modify the access protection of a memory mapped file.</source>
          <target state="translated">이 변수는 mprotect ()를 사용하여 메모리 매핑 된 파일의 액세스 보호를 수정할 수있는 경우 조건부로 &lt;code&gt;HAS_MPROTECT&lt;/code&gt; 를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="d39b4760c4a7ddea99da224cda29212d2ef99aed" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_MSYNC&lt;/code&gt; if msync() is available to synchronize a mapped file.</source>
          <target state="translated">이 변수는 msync ()를 사용하여 매핑 된 파일을 동기화 할 수있는 경우 조건부로 &lt;code&gt;HAS_MSYNC&lt;/code&gt; 를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="542bb319608c7eec938e5b98398f37ee190044a7" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_MUNMAP&lt;/code&gt; if munmap() is available to unmap a region mapped by mmap().</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_MUNMAP&lt;/code&gt; ()을 사용하여 mmap ()에 의해 매핑 된 영역을 매핑 해제 할 수있는 경우 HAS_MUNMAP을 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="02d3878b96b9be7c2121b2227ea0c924b133a4a0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_NAN&lt;/code&gt; if nan() is available to generate NaN.</source>
          <target state="translated">nan ()을 사용하여 NaN을 생성 할 수있는 &lt;code&gt;HAS_NAN&lt;/code&gt; 변수는 조건부로 HAS_NAN을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="4b6ab26a7e66c25dc87e4ed8365e14b5b776d611" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_NEARBYINT&lt;/code&gt; if nearbyint() is available to return the integral value closest to (according to the current rounding mode) to x.</source>
          <target state="translated">nearint ()를 사용하여 현재 반올림 모드에 따라 가장 가까운 정수 값을 x에 반환 할 수있는 경우이 변수는 조건부로 &lt;code&gt;HAS_NEARBYINT&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="9de8df4ca9d3107d7b5e197ebc2f8b56f2a456de" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_NEXTAFTER&lt;/code&gt; if nextafter() is available to return the next machine representable double from x in direction y.</source>
          <target state="translated">nextafter ()를 사용하여 x에서 y 방향으로 표현할 수있는 다음 기계를 두 번 리턴 할 수있는 경우이 변수는 조건부로 &lt;code&gt;HAS_NEXTAFTER&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="09cc9884f832b1e2f2ad4607b97076420d46d665" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_NEXTTOWARD&lt;/code&gt; if nexttoward() is available to return the next machine representable long double from x in direction y.</source>
          <target state="translated">nexttoward ()를 사용하여 x에서 y 방향으로 표현할 수있는 다음 long long을 리턴 할 수있는 경우이 변수는 조건부로 &lt;code&gt;HAS_NEXTTOWARD&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="e84d3a1694bc236dbf1d7993a1d2c9255724da86" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_PTHREAD_ATTR_SETSCOPE&lt;/code&gt; if pthread_attr_setscope() is available to set the contention scope attribute of a thread attribute object.</source>
          <target state="translated">pthread_attr_setscope ()를 사용하여 스레드 속성 오브젝트의 경합 범위 속성을 설정할 수있는 &lt;code&gt;HAS_PTHREAD_ATTR_SETSCOPE&lt;/code&gt; 변수는 조건부로 HAS_PTHREAD_ATTR_SETSCOPE를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="ca9e53f6ec390b98dfba5bb4f284367970f8d262" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_READDIR&lt;/code&gt; if readdir() is available to read directory entries.</source>
          <target state="translated">readdir ()을 사용하여 디렉토리 항목을 읽을 수있는 &lt;code&gt;HAS_READDIR&lt;/code&gt; 변수는 조건부로 HAS_READDIR을 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="c772ddc21b6658b7802061d88a44caa292765ab3" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_REWINDDIR&lt;/code&gt; if rewinddir() is available.</source>
          <target state="translated">rewinddir ()을 사용할 수있는 &lt;code&gt;HAS_REWINDDIR&lt;/code&gt; 변수는 조건부로 HAS_REWINDDIR을 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="102609636e6adf43c7c619fd51b5305af390db97" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_RMDIR&lt;/code&gt; if rmdir() is available to remove directories.</source>
          <target state="translated">이 변수는 rmdir ()을 사용하여 디렉토리를 제거 할 수있는 경우 조건부로 &lt;code&gt;HAS_RMDIR&lt;/code&gt; 을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="887794d99137721bdeb0c86f2844b40ead019692" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SEEKDIR&lt;/code&gt; if seekdir() is available.</source>
          <target state="translated">seekdir ()을 사용할 수있는 &lt;code&gt;HAS_SEEKDIR&lt;/code&gt; 변수는 조건부로 HAS_SEEKDIR을 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="eabab054867a6e7a1fda52591f68108f354fff8a" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SELECT&lt;/code&gt; if select() is available to select active file descriptors. A &amp;lt;sys/time.h&amp;gt; inclusion may be necessary for the timeout field.</source>
          <target state="translated">이 변수는 select ()를 사용하여 활성 파일 디스크립터를 선택할 수있는 경우 조건부로 &lt;code&gt;HAS_SELECT&lt;/code&gt; 를 정의합니다 . 시간 초과 필드에 &amp;lt;sys / time.h&amp;gt; 포함이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc33f5c99454e91ae2ee5c0078387d95e7d2e9a2" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETHOSTENT&lt;/code&gt; if sethostent() is available.</source>
          <target state="translated">이 변수는 sethostent ()를 사용할 수있는 경우 조건부로 &lt;code&gt;HAS_SETHOSTENT&lt;/code&gt; 를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="75151e22ebcabc154ea71d8ff2b10a358ed030a2" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETLOCALE&lt;/code&gt; if setlocale() is available to handle locale-specific ctype implementations.</source>
          <target state="translated">로케일 별 ctype 구현을 처리하기 위해 setlocale ()을 사용할 수있는 &lt;code&gt;HAS_SETLOCALE&lt;/code&gt; 변수는 조건부로 HAS_SETLOCALE을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="3d673facbb75d108913e27f1a2486a73d55d0236" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETNETENT&lt;/code&gt; if setnetent() is available.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_SETNETENT&lt;/code&gt; ()를 사용할 수있는 경우 조건부로 HAS_SETNETENT를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="7914dcc37c31303f3da0f6e201df5d765f8aa85c" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETPGRP&lt;/code&gt; if setpgrp() is available to set the current process group.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_SETPGRP&lt;/code&gt; ()를 사용하여 현재 프로세스 그룹을 설정할 수있는 경우 조건부로 HAS_SETPGRP를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="2002a17a2c2a55f6f40172b2b8fb58d5b76cdd2a" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETPRIORITY&lt;/code&gt; if setpriority() is available to set a process's priority.</source>
          <target state="translated">프로세스 우선 순위를 설정하기 위해 setpriority ()를 사용할 수있는 &lt;code&gt;HAS_SETPRIORITY&lt;/code&gt; 변수는 조건부로 HAS_SETPRIORITY를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="3c631092c3030de3575c0a7a87bf0eb17b021238" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETPROTOENT&lt;/code&gt; if setprotoent() is available.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_SETPROTOENT&lt;/code&gt; ()를 사용할 수있는 경우 조건부로 HAS_SETPROTOENT를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="0f78400a8b12f8656f01ebbdf5086223548e1e83" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETREGID&lt;/code&gt; if setregid() is available to change the real and effective gid of the current process.</source>
          <target state="translated">이 변수는 setregid ()를 사용하여 현재 프로세스의 실제 및 유효 gid를 변경할 수있는 경우 조건부로 &lt;code&gt;HAS_SETREGID&lt;/code&gt; 를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="30c69bd63c2acea93583c8f9220b4a879c50d781" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETRESGID&lt;/code&gt; if setresgid() is available to change the real, effective and saved gid of the current process.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_SETRESGID&lt;/code&gt; ()를 사용하여 현재 프로세스의 실제 유효하고 저장된 gid를 변경할 수있는 경우 조건부로 HAS_SETRESGID를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="35485f4098b6c1c258054bdb628277a4ccf112e2" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETREUID&lt;/code&gt; if setresuid() is available to change the real, effective and saved uid of the current process.</source>
          <target state="translated">setresuid ()를 사용하여 현재 프로세스의 실제 유효하고 저장된 uid를 변경할 수있는 &lt;code&gt;HAS_SETREUID&lt;/code&gt; 변수는 조건부로 HAS_SETREUID를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="aba8a0bc40989a1ca38df2aae3c387f371d5192b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETREUID&lt;/code&gt; if setreuid() is available to change the real and effective uid of the current process.</source>
          <target state="translated">setreuid ()를 사용하여 현재 프로세스의 실제 유효 uid를 변경할 수있는 경우이 변수는 조건부로 &lt;code&gt;HAS_SETREUID&lt;/code&gt; 를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="eb6783028c86e7bf10a2b92123734f47a7944fac" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETSERVENT&lt;/code&gt; if setservent() is available.</source>
          <target state="translated">이 변수는 setservent ()를 사용할 수있는 경우 조건부로 &lt;code&gt;HAS_SETSERVENT&lt;/code&gt; 를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="56d4df6b62a7f4a67414b6f9ecb8ddad65efc719" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETSID&lt;/code&gt; if setsid() is available to set the process group &lt;code&gt;ID&lt;/code&gt; .</source>
          <target state="translated">이 변수는 setsid ()를 사용하여 프로세스 그룹 &lt;code&gt;ID&lt;/code&gt; 를 설정할 수있는 경우 조건부로 &lt;code&gt;HAS_SETSID&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="a53a8b438b669e85e8dac90bda9a163f72b38dcd" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SIGPROCMASK&lt;/code&gt; if sigprocmask() is available to examine or change the signal mask of the calling process.</source>
          <target state="translated">sigprocmask ()를 사용하여 호출 프로세스의 신호 마스크를 검사하거나 변경할 수있는 &lt;code&gt;HAS_SIGPROCMASK&lt;/code&gt; 변수는 조건부로 HAS_SIGPROCMASK를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="fedaa514d1228b3cb8d459d4c50ec34f00f6ac02" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SOCKET&lt;/code&gt; , which indicates that the &lt;code&gt;BSD&lt;/code&gt; socket interface is supported.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;BSD&lt;/code&gt; 소켓 인터페이스가 지원됨 을 나타내는 &lt;code&gt;HAS_SOCKET&lt;/code&gt; 을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="5acf41a0b06778d8de2ab0c3e21b6db83e6e1a26" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_STAT&lt;/code&gt; if stat() is available to get file status.</source>
          <target state="translated">stat ()를 사용하여 파일 상태를 가져올 수있는 &lt;code&gt;HAS_STAT&lt;/code&gt; 변수는 조건부로 HAS_STAT를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="104dec5b82fbc045989fe3c8c4ef8fa75c373740" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_STRCHR&lt;/code&gt; if strchr() and strrchr() are available for string searching.</source>
          <target state="translated">strchr () 및 strrchr ()을 문자열 검색에 사용할 수있는 &lt;code&gt;HAS_STRCHR&lt;/code&gt; 변수는 조건부로 HAS_STRCHR을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="66c65e480ececd2a54e0b9068f9890c68b2b94ad" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_STRCOLL&lt;/code&gt; if strcoll() is available to compare strings using collating information.</source>
          <target state="translated">이 변수는 배열 정보를 사용하여 문자열을 비교하기 위해 strcoll ()을 사용할 수있는 경우 &lt;code&gt;HAS_STRCOLL&lt;/code&gt; 을 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="b82eb75e3b5d7a021a62e68340d85ee6ee407d5d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_STRERROR&lt;/code&gt; if strerror() is available to translate error numbers to strings.</source>
          <target state="translated">strerror ()를 사용하여 오류 번호를 문자열로 변환 할 수있는 &lt;code&gt;HAS_STRERROR&lt;/code&gt; 변수는 조건부로 HAS_STRERROR를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="157fd2966246701c1e0fd97cb121f370d5243dfd" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_STRXFRM&lt;/code&gt; if strxfrm() is available to transform strings.</source>
          <target state="translated">이 변수는 strxfrm ()을 사용하여 문자열을 변환 할 수있는 경우 조건부로 &lt;code&gt;HAS_STRXFRM&lt;/code&gt; 을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="f665cc4a3804d1cfbb21ea5e1e553f34ba0001f3" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SYSCALL&lt;/code&gt; if syscall() is available call arbitrary system calls.</source>
          <target state="translated">이 변수는 syscall ()을 사용할 수있는 경우 임의의 시스템 호출을 호출하는 경우 조건부로 &lt;code&gt;HAS_SYSCALL&lt;/code&gt; 을 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="76958e03c19c57ba5daadf788ceb559703fda4a7" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SYSTEM&lt;/code&gt; if system() is available to issue a shell command.</source>
          <target state="translated">이 변수는 system ()을 사용하여 쉘 명령을 발행 할 수있는 경우 조건부로 &lt;code&gt;HAS_SYSTEM&lt;/code&gt; 을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="fba0f75ab5519c316f7379166065cac7a0fa0f08" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SYS_ERRLIST&lt;/code&gt; if sys_errlist[] is available to translate error numbers to strings.</source>
          <target state="translated">sys_errlist []를 사용하여 오류 번호를 문자열로 변환 할 수있는 &lt;code&gt;HAS_SYS_ERRLIST&lt;/code&gt; 변수는 조건부로 HAS_SYS_ERRLIST를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="3133e51b2626aefa90c83a60c2bc07b45364f9d8" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SYS_ERRNOLIST&lt;/code&gt; if sys_errnolist[] is available to translate error numbers to the symbolic name.</source>
          <target state="translated">sys_errnolist []를 사용하여 오류 번호를 기호 이름으로 변환 할 수있는 경우이 변수는 조건부로 &lt;code&gt;HAS_SYS_ERRNOLIST&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="3b6cc938eb6588fef7831af7c25c38df6b393dba" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_TELLDIR&lt;/code&gt; if telldir() is available.</source>
          <target state="translated">이 변수는 조건부로 정의합니다 &lt;code&gt;HAS_TELLDIR&lt;/code&gt; telldir ()을 사용할 수있는 경우이 HAS_TELLDIR을 합니다.</target>
        </trans-unit>
        <trans-unit id="13376d783be11f279f6a31e5dca53c18c5518beb" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_TM_TM_GMTOFF&lt;/code&gt; , which indicates indicates to the C program that the struct tm has the tm_gmtoff field.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_TM_TM_GMTOFF&lt;/code&gt; 를 정의합니다 . 이는 struct tm에 tm_gmtoff 필드가 있음을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="a5fdffc25ffd7e4584eb45e68410699ffcf4500b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_TM_TM_ZONE&lt;/code&gt; , which indicates indicates to the C program that the struct tm has the tm_zone field.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_TM_TM_ZONE&lt;/code&gt; 을 정의합니다 . , 이는 struct tm에 tm_zone 필드가 있음을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="56c5c15d4eddf8d206488d6739d6fd8de91eb4bc" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_TRUNCATE&lt;/code&gt; if truncate() is available to truncate files.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_TRUNCATE&lt;/code&gt; 를 정의합니다 truncate ()를 사용하여 파일을자를 수있는 경우 합니다.</target>
        </trans-unit>
        <trans-unit id="e2b911e2460cf128e44ed370b2980c2209097f87" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_TZNAME&lt;/code&gt; if tzname[] is available to access timezone names.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_TZNAME&lt;/code&gt; 을 정의합니다 .tzname []을 사용하여 시간대 이름에 액세스 할 수있는 합니다.</target>
        </trans-unit>
        <trans-unit id="0d2899983d1ce6900d5663872bcf0fe4bc31fe25" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_UNION_SEMUN&lt;/code&gt; if the union semun is defined by including &amp;lt;sys/sem.h&amp;gt;.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_UNION_SEMUN&lt;/code&gt; 을 정의합니다 노조 semun는 &amp;lt;SYS / sem.h에&amp;gt; 포함하여 정의 된 경우.</target>
        </trans-unit>
        <trans-unit id="9dbad1c6f722a7fb60b2580c6825a89a0875ea78" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_USLEEP&lt;/code&gt; if usleep() is available to do high granularity sleeps.</source>
          <target state="translated">usleep ()을 사용하여 세분화 된 휴면을 수행 할 수있는 &lt;code&gt;HAS_USLEEP&lt;/code&gt; 변수는 조건부로 HAS_USLEEP을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="62fcdd3f292691fc949ae90083b1d7e19d396383" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_USTAT&lt;/code&gt; if ustat() is available to query file system statistics by dev_t.</source>
          <target state="translated">이 변수는 ustat ()을 dev_t로 파일 시스템 통계를 조회 할 수있는 경우 &lt;code&gt;HAS_USTAT&lt;/code&gt; 를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="e6da30a5484ed0715193a06b75bbdc0f387b14b5" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_WAITPID&lt;/code&gt; if waitpid() is available to wait for child process.</source>
          <target state="translated">이 변수는 waitpid ()를 사용하여 하위 프로세스를 기다릴 수있는 경우 조건부로 &lt;code&gt;HAS_WAITPID&lt;/code&gt; 를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="ea1ebdb3e07eb3cfa8774547eb7eca99b9cbda6a" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS__FWALK&lt;/code&gt; if _fwalk() is available to apply a function to all the file handles.</source>
          <target state="translated">_fwalk ()를 사용하여 모든 파일 핸들에 함수를 적용 할 수있는 &lt;code&gt;HAS__FWALK&lt;/code&gt; 변수는 조건부로 HAS__FWALK를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="ccfbe62640f2e7f4d3f434546f57dde1c801c589" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_DIRENT&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;dirent.h&amp;gt;.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;I_DIRENT&lt;/code&gt; 를 정의 하며 , C 프로그램에 &amp;lt;dirent.h&amp;gt;가 포함되어야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b09b17b8feebed4fb31ad1053dd929b31fc1552d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_NETINET_IN&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;netinet/in.h&amp;gt;. Otherwise, you may try &amp;lt;sys/in.h&amp;gt;.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;I_NETINET_IN&lt;/code&gt; 을 정의합니다 . 이는 C 프로그램에 &amp;lt;netinet / in.h&amp;gt;를 포함해야 함을 나타냅니다. 그렇지 않으면 &amp;lt;sys / in.h&amp;gt;를 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18545a27b23f4ec408fe168cb07019ddd52aeb9d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_PWD&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;pwd.h&amp;gt;.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;I_PWD&lt;/code&gt; 를 정의 하며 , C 프로그램에 &amp;lt;pwd.h&amp;gt;를 포함해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3999885997764e29fe1e4dcd432c1a48f0dbd137" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_QUADMATH&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;quadmath.h&amp;gt;.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;I_QUADMATH&lt;/code&gt; 를 정의 하며 , 이는 C 프로그램에 &amp;lt;quadmath.h&amp;gt;를 포함해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2a59b19169614e1208d6a92cb8cd08ec908a8e0b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_SYS_IN&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;sys/in.h&amp;gt; instead of &amp;lt;netinet/in.h&amp;gt;.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;I_SYS_IN&lt;/code&gt; 을 정의합니다 . 이는 C 프로그램에 &amp;lt;netinet / in.h&amp;gt; 대신 &amp;lt;sys / in.h&amp;gt;를 포함해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b72fad23f2686fa8a3b7ba796dba5e928d3c1193" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_SYS_SELECT&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;sys/select.h&amp;gt; in order to get the definition of struct timeval.</source>
          <target state="translated">이 변수는 &lt;code&gt;I_SYS_SELECT&lt;/code&gt; 를 조건부로 정의 하며 , 이는 구조체 타임스 벌의 정의를 얻기 위해 &amp;lt;sys / select.h&amp;gt;를 포함해야한다는 것을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="46b3e1dfb1e11c227d687db5d0baaa2e450457de" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_SYS_SOCKIO&lt;/code&gt; to indicate to the C program that socket ioctl codes may be found in &amp;lt;sys/sockio.h&amp;gt; instead of &amp;lt;sys/ioctl.h&amp;gt;.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;I_SYS_SOCKIO&lt;/code&gt; 를 정의 하여 소켓 ioctl 코드가 &amp;lt;sys / ioctl.h&amp;gt; 대신 &amp;lt;sys / sockio.h&amp;gt;에 있음을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="abc49b9ac08dff6a9f6857ae04835d4e61d8c3d9" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_SYS_TIME&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;sys/time.h&amp;gt;.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;I_SYS_TIME&lt;/code&gt; 을 정의 하며 , 이는 C 프로그램에 &amp;lt;sys / time.h&amp;gt;를 포함해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="134ce192071bcaa440fc2e6dd10833f44f8a3750" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_SYS_TIME_KERNEL&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;sys/time.h&amp;gt; with &lt;code&gt;KERNEL&lt;/code&gt; defined.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;I_SYS_TIME_KERNEL&lt;/code&gt; 을 정의합니다 . 이는 C 프로그램에 &lt;code&gt;KERNEL&lt;/code&gt; 이 정의 된 &amp;lt;sys / time.h&amp;gt;를 포함해야 함을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="939cb7b0620edee4edc61983e7278fc31a5c1093" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_SYS_UN&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;sys/un.h&amp;gt; to get &lt;code&gt;UNIX&lt;/code&gt; domain socket definitions.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;I_SYS_UN&lt;/code&gt; 을 정의 하며 , 이는 &lt;code&gt;UNIX&lt;/code&gt; 도메인 소켓 정의 를 가져 오기 위해 &amp;lt;sys / un.h&amp;gt;를 포함해야 함을 C 프로그램에 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="d05b60d3b34826e6947a78549014fc461f91e426" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_SYS_WAIT&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;sys/wait.h&amp;gt;.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;I_SYS_WAIT&lt;/code&gt; 를 정의 하며 , C 프로그램에 &amp;lt;sys / wait.h&amp;gt;를 포함해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cbee00fea0a0e43a823409e3c9ea7ecbe6db0995" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_TIME&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;time.h&amp;gt;.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;I_TIME&lt;/code&gt; 을 정의 하며 , C 프로그램에 &amp;lt;time.h&amp;gt;를 포함해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5e26138c57947cb8f890b9cb6f5d5a73c355cb2b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_VARARGS&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;varargs.h&amp;gt;.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;I_VARARGS&lt;/code&gt; 를 정의합니다.이 변수 는 C 프로그램에 &amp;lt;varargs.h&amp;gt;를 포함해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="58139b2e3b281a9a118c344ae314fa19f7ef819b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;MYMALLOC&lt;/code&gt; in case other parts of the source want to take special action if &lt;code&gt;MYMALLOC&lt;/code&gt; is used. This may include different sorts of profiling or error detection.</source>
          <target state="translated">이 변수는 조건부 정의 &lt;code&gt;MYMALLOC&lt;/code&gt; 를 소스의 다른 부분이있는 경우 특별한 조치를 취해야 할 경우에 &lt;code&gt;MYMALLOC&lt;/code&gt; 가 사용된다. 여기에는 다양한 종류의 프로파일 링 또는 오류 감지가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c8fdadfdd30950a7b700d396be77876a6f4c5f5" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PERL_INC_VERSION_LIST&lt;/code&gt; . It is set to undef when &lt;code&gt;PERL_INC_VERSION_LIST&lt;/code&gt; is empty.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;PERL_INC_VERSION_LIST&lt;/code&gt; 를 정의합니다 . &lt;code&gt;PERL_INC_VERSION_LIST&lt;/code&gt; 가 비어 있으면 undef로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="4ff46e0082d05a29ab6252efc4bd771d18d5878f" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PERL_OTHERLIBDIRS&lt;/code&gt; , which contains a colon-separated set of paths for the perl binary to include in @&lt;code&gt;INC&lt;/code&gt; . See also otherlibdirs.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;PERL_OTHERLIBDIRS&lt;/code&gt; 를 정의합니다 . 여기에는 @ &lt;code&gt;INC&lt;/code&gt; 에 포함 할 perl 바이너리에 대한 콜론으로 구분 된 경로 세트가 포함됩니다 . otherlibdirs도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="caef6d2331c84b17275d3f9012789c819b377ba9" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PERL_VENDORBIN&lt;/code&gt; .</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;PERL_VENDORBIN&lt;/code&gt; 을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="533111c8d8f10b6751abb6a1a0088f4c19073d3e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PERL_VENDORLIB&lt;/code&gt; .</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;PERL_VENDORLIB&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="177a5dd44b77ca5ced87275d19c31e96d16bc7b0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PERL_VENDORSCRIPT&lt;/code&gt; .</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;PERL_VENDORSCRIPT&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="6cc9c3d91fb6f28bed8329dae1d992b2ddc3b88b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PRINTF_FORMAT_NULL_OK&lt;/code&gt; , which indicates the C compiler allows printf-like formats to be null.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;PRINTF_FORMAT_NULL_OK&lt;/code&gt; 를 정의합니다 . 이는 C 컴파일러가 printf와 같은 형식을 null로 허용 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1b45d18a0fa0b9cd91b944a53b1e7323f8adc333" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWAGE&lt;/code&gt; , which indicates that struct passwd contains pw_age.</source>
          <target state="translated">이 변수는 &lt;code&gt;PWAGE&lt;/code&gt; 를 조건부로 정의 하는데 , 이는 struct passwd에 pw_age가 포함되어 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6b184e19c4dcc5f872f5344f6afc9d5aa8890c36" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWCHANGE&lt;/code&gt; , which indicates that struct passwd contains pw_change.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;PWCHANGE&lt;/code&gt; 를 정의합니다 . 이는 struct passwd에 pw_change가 포함되어 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="da5fb50ace415a9312b25c289ac7ee228f0dd1f8" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWCLASS&lt;/code&gt; , which indicates that struct passwd contains pw_class.</source>
          <target state="translated">이 변수는 &lt;code&gt;PWCLASS&lt;/code&gt; 를 조건부로 정의 하는데 , 이는 struct passwd에 pw_class가 포함되어 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9f567085df536f85d28a3794c7c79c2f135c39fc" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWCOMMENT&lt;/code&gt; , which indicates that struct passwd contains pw_comment.</source>
          <target state="translated">이 변수는 &lt;code&gt;PWCOMMENT&lt;/code&gt; 를 조건부로 정의 하는데 , 이는 struct passwd에 pw_comment가 포함되어 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2223305749b21469a0762164dc8dc0df3aaa8c7f" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWEXPIRE&lt;/code&gt; , which indicates that struct passwd contains pw_expire.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;PWEXPIRE&lt;/code&gt; 를 정의합니다 . 이는 struct passwd에 pw_expire가 포함되어 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ebf2af3d9e7342f5f1fe442fb4ba6590cba3aeaf" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWGECOS&lt;/code&gt; , which indicates that struct passwd contains pw_gecos.</source>
          <target state="translated">이 변수는 &lt;code&gt;PWGECOS&lt;/code&gt; 를 조건부로 정의 하는데 , 이는 struct passwd에 pw_gecos가 포함되어 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e4df7b4ce4ecdac74c8fac53257d7c54e9e2b1d2" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWPASSWD&lt;/code&gt; , which indicates that struct passwd contains pw_passwd.</source>
          <target state="translated">이 변수는 &lt;code&gt;PWPASSWD&lt;/code&gt; 를 조건부로 정의 하는데 , 이는 struct passwd에 pw_passwd가 포함되어 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f6f5c85237fcc07cb2101d49b94de63960320aab" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWQUOTA&lt;/code&gt; , which indicates that struct passwd contains pw_quota.</source>
          <target state="translated">이 변수는 &lt;code&gt;PWQUOTA&lt;/code&gt; 를 조건부로 정의 하는데 , 이는 구조체 passwd에 pw_quota가 포함되어 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8e6dc66871cca735678df0954175fa95cf018eb7" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;SETUID_SCRIPTS_ARE_SECURE_NOW&lt;/code&gt; if setuid scripts can be secure. This test looks in</source>
          <target state="translated">setuid 스크립트를 보호 할 수있는 &lt;code&gt;SETUID_SCRIPTS_ARE_SECURE_NOW&lt;/code&gt; 변수는 조건 적으로 SETUID_SCRIPTS_ARE_SECURE_NOW를 정의합니다 . 이 테스트는</target>
        </trans-unit>
        <trans-unit id="81f004e1abf850968e0e52c15f9f6cad13d862f0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;SITEARCH&lt;/code&gt; to hold the pathname of architecture-dependent library files for $package. If $sitearch is the same as $archlib, then this is set to undef.</source>
          <target state="translated">이 변수는 $ package에 대한 아키텍처 종속 라이브러리 파일의 경로 이름을 보유하도록 &lt;code&gt;SITEARCH&lt;/code&gt; 를 조건부로 정의 합니다. $ sitearch가 $ archlib와 같으면 undef로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="8b1027f2dc2d15c75eedea147e9dd18e08a6014d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;STDCHAR&lt;/code&gt; to be the type of char used in</source>
          <target state="translated">이 변수는 &lt;code&gt;STDCHAR&lt;/code&gt; 을 조건부 에서 사용되는 char 유형으로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="f33764730e4076b75f7a54ca0311a31df43bbaae" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;STDIO_CNT_LVALUE&lt;/code&gt; if the &lt;code&gt;FILE_cnt&lt;/code&gt; macro can be used as an lvalue.</source>
          <target state="translated">이 변수는 조건부 정의 &lt;code&gt;STDIO_CNT_LVALUE&lt;/code&gt; 을 경우 &lt;code&gt;FILE_cnt&lt;/code&gt; 의 매크로 좌변로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e69f3a8bd1de18db50aaf0b9ef5033e3dafd978" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;STDIO_PTR_LVALUE&lt;/code&gt; if the &lt;code&gt;FILE_ptr&lt;/code&gt; macro can be used as an lvalue.</source>
          <target state="translated">이 변수는 조건부 정의 &lt;code&gt;STDIO_PTR_LVALUE&lt;/code&gt; 을 경우 &lt;code&gt;FILE_ptr&lt;/code&gt; 의 매크로 좌변로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7bc8c4e73c6aaa4fc8b7bd3db1eed9675bd50c1" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;USE_BSD_GETPGRP&lt;/code&gt; if getpgrp needs one arguments whereas &lt;code&gt;USG&lt;/code&gt; one needs none.</source>
          <target state="translated">이 변수는 getpgrp에 하나의 인수가 필요한 반면 &lt;code&gt;USG&lt;/code&gt; 에는 하나의 인수 가 필요하지 않은 경우 조건부로 &lt;code&gt;USE_BSD_GETPGRP&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="4cb9da0f1f2c05f27c0a4f7de8f8706f136adf70" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;USE_BSD_SETPGRP&lt;/code&gt; if setpgrp needs two arguments whereas &lt;code&gt;USG&lt;/code&gt; one needs none. See also d_setpgid for a &lt;code&gt;POSIX&lt;/code&gt; interface.</source>
          <target state="translated">이 변수는 &lt;code&gt;USE_BSD_SETPGRP&lt;/code&gt; 두 개의 인수가 필요한 반면 &lt;code&gt;USG&lt;/code&gt; 하나에는 필요하지 않은 경우 조건부로 USE_BSD_SETPGRP를 정의합니다 . &lt;code&gt;POSIX&lt;/code&gt; 인터페이스에 대해서는 d_setpgid도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f057b25789e3d0c0c978f875ab711fef26822396" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;USE_IOCNOTTY&lt;/code&gt; to indicate that the ioctl() call with &lt;code&gt;TIOCNOTTY&lt;/code&gt; should be used to void tty association. Otherwise (on &lt;code&gt;USG&lt;/code&gt; probably), it is enough to close the standard file descriptors and do a setpgrp().</source>
          <target state="translated">이 변수는 조건부 정의 &lt;code&gt;USE_IOCNOTTY&lt;/code&gt; 을 가진 IOCTL () 호출을 나타 내기 위해 &lt;code&gt;TIOCNOTTY&lt;/code&gt; 가 무효 TTY 조합으로 사용되어야한다. 그렇지 않으면 ( &lt;code&gt;USG&lt;/code&gt; 에서 ) 표준 파일 디스크립터를 닫고 setpgrp ()를 수행하는 것으로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="c86f9683041fce14f0acc7f22e22cb66e7ecf21d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;USE_SEMCTL_SEMID_DS&lt;/code&gt; , which indicates that struct semid_ds * is to be used for semctl &lt;code&gt;IPC_STAT&lt;/code&gt; .</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;USE_SEMCTL_SEMID_DS&lt;/code&gt; 를 정의합니다 . 이는 struct semid_ds *가 semctl &lt;code&gt;IPC_STAT&lt;/code&gt; 에 사용됨을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="165216a22f48262f27b72dd85b30d1c442227e08" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;USE_SEMCTL_SEMUN&lt;/code&gt; , which indicates that union semun is to be used for semctl &lt;code&gt;IPC_STAT&lt;/code&gt; .</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;USE_SEMCTL_SEMUN&lt;/code&gt; 을 정의 하며 , 이는 semctl &lt;code&gt;IPC_STAT&lt;/code&gt; 에 Union semun이 사용됨을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="d946a174db1c59c6d451a81dd08b793b70e50298" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;USE_STAT_BLOCKS&lt;/code&gt; if this system has a stat structure declaring st_blksize and st_blocks.</source>
          <target state="translated">이 시스템에 st_blksize 및 st_blocks를 선언하는 통계 구조가있는 &lt;code&gt;USE_STAT_BLOCKS&lt;/code&gt; 변수는 조건부로 USE_STAT_BLOCKS를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="4f2a34f2d97a9448f367a3e7dc94f6a98d0c8541" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;USE_STDIO_BASE&lt;/code&gt; if this system has a &lt;code&gt;FILE&lt;/code&gt; structure declaring a usable _base field (or equivalent) in</source>
          <target state="translated">이 시스템 에 사용 가능한 _base 필드 (또는 이와 동등한)를 선언하는 &lt;code&gt;FILE&lt;/code&gt; 구조 가있는 &lt;code&gt;USE_STDIO_BASE&lt;/code&gt; 변수는 조건부로 USE_STDIO_BASE를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="884014009e45fc4b799369297408405b825f05ec" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;USE_STDIO_PTR&lt;/code&gt; if this system has a &lt;code&gt;FILE&lt;/code&gt; structure declaring usable _ptr and _cnt fields (or equivalent) in</source>
          <target state="translated">이 시스템에 사용 가능한 _ptr 및 _cnt 필드 (또는 이에 상응하는)를 선언 하는 &lt;code&gt;FILE&lt;/code&gt; 구조 가있는 &lt;code&gt;USE_STDIO_PTR&lt;/code&gt; 변수는 조건부로 USE_STDIO_PTR을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="e2ce6f3e2ba733cc080d545a7f5345eaada6b53b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;VOIDSIG&lt;/code&gt; if this system declares &quot;void (*signal(...))()&quot; in</source>
          <target state="translated">이 변수는 이 시스템이 &quot;void (* signal (...)) ()&quot;을 선언하면 &lt;code&gt;VOIDSIG&lt;/code&gt; 를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="c1b1eb5455ff0e45585c738f286f73520d2bda4a" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;VOID_CLOSEDIR&lt;/code&gt; if closedir() does not return a value.</source>
          <target state="translated">closedir ()가 값을 반환하지 않으면 이 변수는 조건부로 &lt;code&gt;VOID_CLOSEDIR&lt;/code&gt; 을 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="f67d5b9663b7f0f671bc57d6208cef2ecf39a7bd" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines CASTI32, which indicates whether the C compiler can cast large floats to 32-bit ints.</source>
          <target state="translated">이 변수는 조건 적으로 CASTI32를 정의하는데, 이는 C 컴파일러가 큰 부동 소수점을 32 비트 정수로 캐스트 할 수 있는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1e0e56548eb03f6bba0bfbdaf1893bfedf8b743e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines HAS_DUP2 if dup2() is available to duplicate file descriptors.</source>
          <target state="translated">dup2 ()를 사용하여 파일 디스크립터를 복제 할 수있는 경우이 변수는 조건부로 HAS_DUP2를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="439c57e77afcdbc973932168c0d12a970d487a4f" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines HAS_LC_MONETARY_2008 if libc has the international currency locale rules from &lt;code&gt;POSIX&lt;/code&gt; 1003.1-2008.</source>
          <target state="translated">libc에 &lt;code&gt;POSIX&lt;/code&gt; 1003.1-2008 의 국제 통화 로케일 규칙이있는 경우이 변수는 조건부로 HAS_LC_MONETARY_2008을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="3d55d58456df494116e8e08588b498d9a5a4a48d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines d_dbl_dig if this system's header files provide &lt;code&gt;DBL_DIG&lt;/code&gt; , which is the number of significant digits in a double precision number.</source>
          <target state="translated">이 변수는이 시스템의 헤더 파일 이 배정 밀도 숫자의 유효 자릿수 인 &lt;code&gt;DBL_DIG&lt;/code&gt; 를 제공하는 경우 d_dbl_dig를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="26943f542b57e3d665241442f5609c91f668a2bc" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines d_ldbl_dig if this system's header files provide &lt;code&gt;LDBL_DIG&lt;/code&gt; , which is the number of significant digits in a long double precision number.</source>
          <target state="translated">이 시스템의 헤더 파일이 LDBL_DIG를 제공하는 &lt;code&gt;LDBL_DIG&lt;/code&gt; 변수는 조건부로 d_ldbl_dig를 정의합니다. LDBL_DIG 는 긴 배정도 숫자의 유효 자릿수입니다.</target>
        </trans-unit>
        <trans-unit id="41d4367b100c21704ff1afa07d5fcbbbff3622b5" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines pthread_create_joinable. undef if</source>
          <target state="translated">이 변수는 pthread_create_joinable을 조건부로 정의합니다. 정의하지 않으면</target>
        </trans-unit>
        <trans-unit id="4e65c9696692a1039d19a96f88bbb8715e74549c" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;CHSIZE&lt;/code&gt; symbol, which indicates to the C program that the chsize() routine is available to truncate files. You might need a -lx to get this routine.</source>
          <target state="translated">이 변수는 &lt;code&gt;CHSIZE&lt;/code&gt; 기호를 조건부로 정의하며 , 이는 chsize () 루틴을 사용하여 파일을자를 수 있음을 C 프로그램에 표시합니다. 이 루틴을 얻으려면 -lx가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="846b0e7427992bb9738c034b084170cbd17a9268" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;CRYPT&lt;/code&gt; symbol, which indicates to the C program that the crypt() routine is available to encrypt passwords and the like.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;CRYPT&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 crypt () 루틴이 암호 등을 암호화하는 데 사용 가능함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="357bf08dc30645376499e133bedc6c5b51689b15" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;CSH&lt;/code&gt; symbol, which indicates to the C program that the C-shell exists.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;CSH&lt;/code&gt; 기호를 정의하며 , 이는 C 프로그램이 C 쉘이 존재 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e54e9f341c505bb1d2ec118651994c8e65d0f811" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;FCNTL_CAN_LOCK&lt;/code&gt; symbol and indicates whether file locking with fcntl() works.</source>
          <target state="translated">이 변수는 &lt;code&gt;FCNTL_CAN_LOCK&lt;/code&gt; 기호를 조건부로 정의하고 fcntl ()을 사용한 파일 잠금 작동 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="02d3adba206dca72cb969c2114087d914736e57e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;FLEXFILENAMES&lt;/code&gt; symbol, which indicates that the system supports filenames longer than 14 characters.</source>
          <target state="translated">이 변수는 &lt;code&gt;FLEXFILENAMES&lt;/code&gt; 기호를 조건부로 정의하는데 , 이는 시스템이 14 자보다 긴 파일 이름을 지원함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b6165df6dc3c074b8386cff10673ed582f2313bf" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HASCONST&lt;/code&gt; symbol, which indicates to the C program that this C compiler knows about the const type.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HASCONST&lt;/code&gt; 기호를 정의합니다 .이 기호는이 C 컴파일러가 const 유형에 대해 알고 있음을 C 프로그램에 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="514ce51d44fd8efc6f22a726ff2d864524dc5927" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HASVOLATILE&lt;/code&gt; symbol, which indicates to the C program that this C compiler knows about the volatile declaration.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HASVOLATILE&lt;/code&gt; 기호를 정의합니다 .이 기호는이 C 컴파일러가 휘발성 선언에 대해 알고 있음을 C 프로그램에 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3baa45e96d482436f92754c7ebdc6a73550f0eae" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ACCESSX&lt;/code&gt; symbol, which indicates to the C program that the accessx() routine is available.</source>
          <target state="translated">이 변수 는 C 프로그램에 accessx () 루틴을 사용할 수 있음을 나타내는 &lt;code&gt;HAS_ACCESSX&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="12a76ff5170c955de143e03f08fd4db9b4437e7b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ACOSH&lt;/code&gt; symbol, which indicates to the C program that the acosh() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_ACOSH&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 acosh () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3bbc6bd18282fbbaa0a5df512d46d448872f79f0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_AINTL&lt;/code&gt; symbol, which indicates to the C program that the aintl() routine is available. If copysignl is also present we can emulate modfl.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_AINTL&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 aintl () 루틴을 사용할 수 있음을 나타냅니다. copysignl도 있으면 modfl을 에뮬레이션 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac4f3fc539e3b11a8b62b87684564e56d5832bdb" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ALARM&lt;/code&gt; symbol, which indicates to the C program that the alarm() routine is available.</source>
          <target state="translated">이 변수 는 C 프로그램에 alarm () 루틴을 사용할 수 있음을 나타내는 &lt;code&gt;HAS_ALARM&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="393748ad8a6e58564f59c88a5a65a0fccff40956" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ASCTIME_R&lt;/code&gt; symbol, which indicates to the C program that the asctime_r() routine is available.</source>
          <target state="translated">이 변수 는 C 프로그램에 asctime_r () 루틴을 사용할 수 있음을 나타내는 &lt;code&gt;HAS_ASCTIME_R&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="e6240de5e54fe3a786d797ae169f9a039181d8e9" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ASINH&lt;/code&gt; symbol, which indicates to the C program that the asinh() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_ASINH&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 asinh () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="968fc15f09fb64edc7440ecd0aed6b099eb7c13a" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ATANH&lt;/code&gt; symbol, which indicates to the C program that the atanh() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_ATANH&lt;/code&gt; 기호를 정의하며 , atanh () 루틴을 사용할 수 있음을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="0b6ee241d9266a7948fd72b86cd3046b1822d99c" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ATOLF&lt;/code&gt; symbol, which indicates to the C program that the atolf() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_ATOLF&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 atolf () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7f44fe9ea95c9ae1f907047c17022ef03aa1acbb" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ATOLL&lt;/code&gt; symbol, which indicates to the C program that the atoll() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_ATOLL&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 atoll () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d5e0162b328b8a9b754dac6231795ba2f27a65bb" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_BACKTRACE&lt;/code&gt; symbol, which indicates to the C program that the backtrace() routine is available to get a stack trace.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_BACKTRACE&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 backtrace () 루틴을 사용하여 스택 추적을 가져올 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e96fa08dff1194cea11b6b542d4bb635e9998fe7" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_BCMP&lt;/code&gt; symbol if the bcmp() routine is available to compare strings.</source>
          <target state="translated">이 변수 는 bcmp () 루틴을 사용하여 문자열을 비교할 수있는 경우 &lt;code&gt;HAS_BCMP&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="2c3a347a1f168f38f12b42fec82e5a9d4a71e447" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_BCOPY&lt;/code&gt; symbol if the bcopy() routine is available to copy strings.</source>
          <target state="translated">이 변수 는 bcopy () 루틴을 사용하여 문자열을 복사 할 수있는 경우 &lt;code&gt;HAS_BCOPY&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="fe7d21ac1bac028a9a4864da166ebd5752380e71" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_BZERO&lt;/code&gt; symbol if the bzero() routine is available to set memory to 0.</source>
          <target state="translated">bzero () 루틴을 사용하여 메모리를 0으로 설정할 수 있는 &lt;code&gt;HAS_BZERO&lt;/code&gt; 변수는 조건부로 HAS_BZERO 기호를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="6ca90016e7f6abf49f24d5147f764f4e266fad51" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_CBRT&lt;/code&gt; symbol, which indicates to the C program that the cbrt() (cube root) function is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_CBRT&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 cbrt () (큐브 루트) 함수를 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9190489c62bb031470f6a8b4f7cd7a1825719930" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_CHOWN&lt;/code&gt; symbol, which indicates to the C program that the chown() routine is available.</source>
          <target state="translated">이 변수 는 chown () 루틴을 사용할 수 있음을 C 프로그램에 표시 하는 &lt;code&gt;HAS_CHOWN&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="ab782a1830d8f2fd000403d6b221d923f1975987" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_CHROOT&lt;/code&gt; symbol, which indicates to the C program that the chroot() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_CHROOT&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 chroot () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="32e6c736a6ca4ad0fe4ee89e271bd5cc262bc051" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_CLASS&lt;/code&gt; symbol, which indicates to the C program that the class() routine is available.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_CLASS&lt;/code&gt; 기호를 조건부로 정의하며 , 이는 class () 루틴이 사용 가능함을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="a075a89328697cbb603b70b3c6d8d110f118b481" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_CLEARENV&lt;/code&gt; symbol, which indicates to the C program that the clearenv () routine is available.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_CLEARENV&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 clearenv () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="74f77f33bb77370820b1492e4169ae2248f4c8c7" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_COPYSIGN&lt;/code&gt; symbol, which indicates to the C program that the copysign() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_COPYSIGN&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 copysign () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="98b66499ba2e3361546a98261177f15a6de1a0f6" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_COPYSIGNL&lt;/code&gt; symbol, which indicates to the C program that the copysignl() routine is available. If aintl is also present we can emulate modfl.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_COPYSIGNL&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 copysignl () 루틴을 사용할 수 있음을 나타냅니다. 만약 aintl도 존재한다면 우리는 modfl을 흉내낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df0f6e4346afa66f63cca26a76d791fade6366c0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_CRYPT_R&lt;/code&gt; symbol, which indicates to the C program that the crypt_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_CRYPT_R&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 crypt_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="953edbb919ba277a0602d4f2fae83655b7094d65" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_CTERMID_R&lt;/code&gt; symbol, which indicates to the C program that the ctermid_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_CTERMID_R&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 ctermid_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="88f0e31c279f299ee13d676f3280ed80bdc1ec78" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_CTIME_R&lt;/code&gt; symbol, which indicates to the C program that the ctime_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_CTIME_R&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 ctime_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f94152d7278e725fe89c658a702df792c385b802" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_CUSERID&lt;/code&gt; symbol, which indicates to the C program that the cuserid() routine is available to get character login names.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_CUSERID&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 cuserid () 루틴을 사용하여 문자 로그인 이름을 가져올 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ce2c192cea1c48bf6a95dcfd9e173ca30310cf0e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_DBMINIT_PROTO&lt;/code&gt; symbol, which indicates to the C program that the system provides a prototype for the dbminit() function. Otherwise, it is up to the program to supply one.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_DBMINIT_PROTO&lt;/code&gt; 기호를 조건부로 정의하며 , 이는 시스템이 dbminit () 함수의 프로토 타입을 제공함을 C 프로그램에 표시합니다. 그렇지 않으면 프로그램을 제공하는 것은 프로그램의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="9f277ae3e34118b1fe4f7a94827507d1e32928ea" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_DIFFTIME&lt;/code&gt; symbol, which indicates to the C program that the difftime() routine is available.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_DIFFTIME&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 difftime () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a13740603c74d16121c0903202111151cb13d77c" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_DIRFD&lt;/code&gt; constant, which indicates to the C program that dirfd() is available to return the file descriptor of a directory stream.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_DIRFD&lt;/code&gt; 상수를 정의합니다 .이 상수는 C 프로그램에 dirfd ()를 사용하여 디렉토리 스트림의 파일 디스크립터를 리턴 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="87bbbc4e9449012cc05f3e6c9ced36d1a9bc5f01" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_DIR_DD_FD&lt;/code&gt; symbol, which indicates that the &lt;code&gt;DIR&lt;/code&gt; directory stream type contains a member variable called dd_fd.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_DIR_DD_FD&lt;/code&gt; 기호를 정의합니다 . 이는 &lt;code&gt;DIR&lt;/code&gt; 디렉토리 스트림 유형에 dd_fd라는 멤버 변수가 포함되어 있음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="ca28447a8986907b62f8a42e124cc4cf1327b826" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_DLADDR&lt;/code&gt; symbol, which indicates to the C program that the dladdr() routine is available to get a stack trace.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_DLADDR&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 dladdr () 루틴을 사용하여 스택 추적을 얻을 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="44450e1cdbf629ec9119c59c9f90d2b874b7e95d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_DLERROR&lt;/code&gt; symbol, which indicates to the C program that the dlerror() routine is available.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_DLERROR&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 dlerror () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ed1d2043eb098d6534774a50acff39bfc0910625" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_DLOPEN&lt;/code&gt; symbol, which indicates to the C program that the dlopen() routine is available.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_DLOPEN&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 dlopen () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="feae0a63aaa2182b296fd904e1c563d6c234cfec" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_EACCESS&lt;/code&gt; symbol, which indicates to the C program that the eaccess() routine is available.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_EACCESS&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 eaccess () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fc59246a386f8974acd05f0aa4d2f594daee00df" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ENDGRENT&lt;/code&gt; symbol, which indicates to the C program that the endgrent() routine is available for sequential access of the group database.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_ENDGRENT&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 endgrent () 루틴이 그룹 데이터베이스의 순차적 액세스에 사용 가능함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c3521391643a5fa8000971d289ffbc808252e90e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ENDGRENT_R&lt;/code&gt; symbol, which indicates to the C program that the endgrent_r() routine is available.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_ENDGRENT_R&lt;/code&gt; 기호를 정의하며 endgrent_r () 루틴을 사용할 수 있음을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="8ceecbf6a76e7908e513f849eb1de5b3d245fac5" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ENDHOSTENT_R&lt;/code&gt; symbol, which indicates to the C program that the endhostent_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_ENDHOSTENT_R&lt;/code&gt; 기호를 정의하며 endhostent_r () 루틴을 사용할 수 있음을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="85d098e6acbbd799d64738081bddb484d9041c70" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ENDNETENT_R&lt;/code&gt; symbol, which indicates to the C program that the endnetent_r() routine is available.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_ENDNETENT_R&lt;/code&gt; 기호를 정의하며 endnetent_r () 루틴을 사용할 수 있음을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="416322d92948c65411d0e4d7da6d1b4fcb72938b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ENDPROTOENT_R&lt;/code&gt; symbol, which indicates to the C program that the endprotoent_r() routine is available.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_ENDPROTOENT_R&lt;/code&gt; 기호를 정의하며 endprotoent_r () 루틴을 사용할 수 있음을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="93b579b440342c900503cc17debbb4a84724f3f2" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ENDPWENT&lt;/code&gt; symbol, which indicates to the C program that the endpwent() routine is available for sequential access of the passwd database.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_ENDPWENT&lt;/code&gt; 기호를 정의합니다 .이 기호는 endpwent () 루틴이 passwd 데이터베이스의 순차 액세스에 사용 가능하다는 것을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="5fd0311a9220d51e48d013d60dc59e4fb98646e5" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ENDPWENT_R&lt;/code&gt; symbol, which indicates to the C program that the endpwent_r() routine is available.</source>
          <target state="translated">이 변수 는 C 프로그램에 endpwent_r () 루틴을 사용할 수 있음을 나타내는 &lt;code&gt;HAS_ENDPWENT_R&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="1975eb77352c3791983498df03109baa693a8003" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ENDSERVENT_R&lt;/code&gt; symbol, which indicates to the C program that the endservent_r() routine is available.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_ENDSERVENT_R&lt;/code&gt; 기호를 정의하며 endservent_r () 루틴을 사용할 수 있음을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="b18c6ff2e894197a9996c9fa5fb041fb1da60ebb" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ERF&lt;/code&gt; symbol, which indicates to the C program that the erf() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_ERF&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 erf () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="11cfc319c8768f753a10806f70be842234f0d8c6" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ERFC&lt;/code&gt; symbol, which indicates to the C program that the erfc() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_ERFC&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 erfc () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="607d8c09f8852e64deb233f04ab669fe416307e5" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FAST_STDIO&lt;/code&gt; symbol, which indicates to the C program that the &quot;fast stdio&quot; is available to manipulate the stdio buffers directly.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_FAST_STDIO&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 &quot;고속 stdio&quot;를 사용하여 stdio 버퍼를 직접 조작 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4ccef8ea96652d985074f68d669458feccd5e889" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FCHDIR&lt;/code&gt; symbol, which indicates to the C program that the fchdir() routine is available.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_FCHDIR&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 fchdir () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2b2fd22f810dafdb7f08dee5c7b2267e8ea89ef0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FCHMOD&lt;/code&gt; symbol, which indicates to the C program that the fchmod() routine is available to change mode of opened files.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_FCHMOD&lt;/code&gt; 기호를 정의합니다 .이 기호는 fchmod () 루틴을 사용하여 열린 파일의 모드를 변경할 수 있음을 C 프로그램에 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9c49735af970135b28a3d9f02063c62ac7d11452" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FCHOWN&lt;/code&gt; symbol, which indicates to the C program that the fchown() routine is available to change ownership of opened files.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_FCHOWN&lt;/code&gt; 기호를 정의합니다 .이 기호는 fchown () 루틴을 사용하여 열린 파일의 소유권을 변경할 수 있음을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="f77965caac290b89da17681f28495b9f8fdfe67f" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FCNTL&lt;/code&gt; symbol, and indicates whether the fcntl() function exists</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_FCNTL&lt;/code&gt; 기호를 조건부로 정의 하고 fcntl () 함수가 존재하는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a2fcb0bfc83505fad937da436d307c0c9ada3232" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FDIM&lt;/code&gt; symbol, which indicates to the C program that the fdim() routine is available.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_FDIM&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 fdim () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="11e2724a5c3ae4b7f0de83cc60d5928d8a3f4d81" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FINITE&lt;/code&gt; symbol, which indicates to the C program that the finite() routine is available.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_FINITE&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 finite () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0caf0447193e8dd99c3be264377abad5f070779b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FINITEL&lt;/code&gt; symbol, which indicates to the C program that the finitel() routine is available.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_FINITEL&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 finitel () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ef6f0d37edde2d9b9e3068f863ad72dfd028852d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FLOCK_PROTO&lt;/code&gt; symbol, which indicates to the C program that the system provides a prototype for the flock() function. Otherwise, it is up to the program to supply one.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_FLOCK_PROTO&lt;/code&gt; 기호를 조건부로 정의하며 , 이는 시스템이 flock () 함수의 프로토 타입을 제공함을 C 프로그램에 표시합니다. 그렇지 않으면 프로그램을 제공하는 것은 프로그램의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="b7230abc643d63b3ff949047a34fa476fec01c89" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FMA&lt;/code&gt; symbol, which indicates to the C program that the fma() routine is available.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_FMA&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 fma () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fe2ccccffbf8d2f15aa401771663c24fe0ef72b5" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FMAX&lt;/code&gt; symbol, which indicates to the C program that the fmax() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_FMAX&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 fmax () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3df9fdbc0ab5f9af76565f047d2b383854350a70" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FMIN&lt;/code&gt; symbol, which indicates to the C program that the fmin() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_FMIN&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 fmin () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4c07c14ce41ab8f9b9c87417a26676cf07833635" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FORK&lt;/code&gt; symbol, which indicates to the C program that the fork() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_FORK&lt;/code&gt; 기호를 정의하며 , 이는 fork () 루틴이 사용 가능함을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="c926988df26ecaa58ebdfaa007ae97cb94e0a26e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FPATHCONF&lt;/code&gt; symbol, which indicates to the C program that the pathconf() routine is available to determine file-system related limits and options associated with a given open file descriptor.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_FPATHCONF&lt;/code&gt; 기호를 조건부로 정의합니다 . 이는 C 프로그램에 pathconf () 루틴을 사용하여 주어진 열린 파일 디스크립터와 연관된 파일 시스템 관련 한계 및 옵션을 판별 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9bbd2019de42dcc3e64e59b2a0a5d922b5b1d74e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FPCLASS&lt;/code&gt; symbol, which indicates to the C program that the fpclass() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_FPCLASS&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 fpclass () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d5fe50cfedd8bbd389632006ec016bddca06ada9" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FPCLASSIFY&lt;/code&gt; symbol, which indicates to the C program that the fpclassify() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_FPCLASSIFY&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 fpclassify () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="917f1d97f54623a4d5b664a0773e1e59567c63fe" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FPCLASSL&lt;/code&gt; symbol, which indicates to the C program that the fpclassl() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_FPCLASSL&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 fpclassl () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7d55b5137fd8aae7bd0294444ae3398b83ef2eb0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FP_CLASS&lt;/code&gt; symbol, which indicates to the C program that the fp_class() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_FP_CLASS&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 fp_class () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b4998906b4a9ccf7bdee0f004832d674aa7bbd9a" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FP_CLASSIFY&lt;/code&gt; symbol, which indicates to the C program that the fp_classify() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_FP_CLASSIFY&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 fp_classify () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="41f0ce9e1b9e64ce9cd583c93400552f4e5a6a52" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FP_CLASSL&lt;/code&gt; symbol, which indicates to the C program that the fp_classl() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_FP_CLASSL&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 fp_classl () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9a718ac3558705993c3b67243a1457d9b8addbd1" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FREXPL&lt;/code&gt; symbol, which indicates to the C program that the frexpl() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_FREXPL&lt;/code&gt; 기호를 정의합니다 . 이는 frexpl () 루틴을 사용할 수 있음을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="80c041b61a3854b0c9acdcab50bfa3457a568fcc" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FSEEKO&lt;/code&gt; symbol, which indicates to the C program that the fseeko() routine is available.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_FSEEKO&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 fseeko () 루틴이 사용 가능함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4051a12dce9cc656f7cd21a6c5cca4ada63aa004" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FSTATFS&lt;/code&gt; symbol, which indicates to the C program that the fstatfs() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_FSTATFS&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 fstatfs () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="376e9454716c971bba83efc24ced69d3a6928836" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FSTATVFS&lt;/code&gt; symbol, which indicates to the C program that the fstatvfs() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_FSTATVFS&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 fstatvfs () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="435d2dacb00d4fba9f51b8f56fc86f2e5cd1c130" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FSYNC&lt;/code&gt; symbol, which indicates to the C program that the fsync() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_FSYNC&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 fsync () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3d1a5f264f0ada9a48dfb15cda9ab839d11e60e6" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FTELLO&lt;/code&gt; symbol, which indicates to the C program that the ftello() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_FTELLO&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 ftello () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4064b0e9f22fe23434bd0ec738f58649333e1d6f" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FTIME&lt;/code&gt; symbol, which indicates that the ftime() routine exists. The ftime() routine is basically a sub-second accuracy clock.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_FTIME&lt;/code&gt; 기호를 정의 하여 ftime () 루틴이 존재 함을 나타냅니다. ftime () 루틴은 기본적으로 1 초 미만의 정확도 클럭입니다.</target>
        </trans-unit>
        <trans-unit id="993d1a28d890386a8f56af4b9e1e99b1a4831c24" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FUTIMES&lt;/code&gt; symbol, which indicates to the C program that the futimes() routine is available.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_FUTIMES&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 futimes () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="43ac0e0e1a1e5f5c73c1a3d69bc5a74620bbdbac" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETADDRINFO&lt;/code&gt; symbol, which indicates to the C program that the getaddrinfo() function is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETADDRINFO&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getaddrinfo () 함수를 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7cc91f8b53047d998123d92a6d27f96f7dfebc76" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETCWD&lt;/code&gt; symbol, which indicates to the C program that the getcwd() routine is available to get the current working directory.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETCWD&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 getcwd () 루틴을 사용하여 현재 작업 디렉토리를 가져올 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e7004f7e14bed6afec5bd1f4a037a94dbc84c28f" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETFSSTAT&lt;/code&gt; symbol, which indicates to the C program that the getfsstat() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETFSSTAT&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getfsstat () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2938f1d0c5a29f26cd258b1d2d58005964b3f928" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETGRENT&lt;/code&gt; symbol, which indicates to the C program that the getgrent() routine is available for sequential access of the group database.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_GETGRENT&lt;/code&gt; 기호를 조건부로 정의합니다 .이 기호는 C 프로그램에 getgrent () 루틴이 그룹 데이터베이스의 순차 액세스에 사용 가능함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="09573807a7f9ee202cbace6d8d9b71d9e084b114" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETGRENT_R&lt;/code&gt; symbol, which indicates to the C program that the getgrent_r() routine is available.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_GETGRENT_R&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getgrent_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ffdee0c89f8e16f98534bde8ff72861b068f14e2" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETGRGID_R&lt;/code&gt; symbol, which indicates to the C program that the getgrgid_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETGRGID_R&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getgrgid_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="030e0d1f9c9ec5d5113cadafdb1d46cca6636eba" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETGRNAM_R&lt;/code&gt; symbol, which indicates to the C program that the getgrnam_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETGRNAM_R&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getgrnam_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5df49eaa2617f7f95ae5a3bfea499bb49b6e147a" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETGROUPS&lt;/code&gt; symbol, which indicates to the C program that the getgroups() routine is available to get the list of process groups.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_GETGROUPS&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 getgroups () 루틴을 사용하여 프로세스 그룹 목록을 가져올 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="800265a52655b0eed9fc30b1377171be6fe75acb" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETHOSTBYADDR&lt;/code&gt; symbol, which indicates to the C program that the gethostbyaddr() routine is available to look up hosts by their &lt;code&gt;IP&lt;/code&gt; addresses.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_GETHOSTBYADDR&lt;/code&gt; 기호를 조건부로 정의합니다 . 이는 C 프로그램에 gethostbyaddr () 루틴을 사용하여 &lt;code&gt;IP&lt;/code&gt; 주소로 호스트를 검색 할 수 있음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="3ea6fb7457d69ab022ea88e866995c66dd82da32" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETHOSTBYADDR_R&lt;/code&gt; symbol, which indicates to the C program that the gethostbyaddr_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETHOSTBYADDR_R&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 gethostbyaddr_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f6e8e21dbcc61a6d007e0d9229782dc31b5d46a2" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETHOSTBYNAME&lt;/code&gt; symbol, which indicates to the C program that the gethostbyname() routine is available to look up host names in some data base or other.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_GETHOSTBYNAME&lt;/code&gt; 기호를 조건부로 정의합니다 . 이는 C 프로그램에 gethostbyname () 루틴을 사용하여 일부 데이터베이스 또는 다른 호스트에서 호스트 이름을 찾을 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4bf98ecfa6e8572b6387b8b2c890ea9af37d6e48" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETHOSTBYNAME_R&lt;/code&gt; symbol, which indicates to the C program that the gethostbyname_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETHOSTBYNAME_R&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 gethostbyname_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8ab2674e64e01f9d704936c384471673343e5f6d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETHOSTENT_R&lt;/code&gt; symbol, which indicates to the C program that the gethostent_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETHOSTENT_R&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 gethostent_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b5275b5b15c84ca1128b06be5161f949867399a1" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETHOSTNAME&lt;/code&gt; symbol, which indicates to the C program that the gethostname() routine may be used to derive the host name.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETHOSTNAME&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 gethostname () 루틴을 사용하여 호스트 이름을 파생시킬 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="db277869ea8d6e46267e65bb1f91f362288123a2" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETHOST_PROTOS&lt;/code&gt; symbol, which indicates to the C program that &amp;lt;netdb.h&amp;gt; supplies prototypes for the various gethost*() functions. See also</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETHOST_PROTOS&lt;/code&gt; 기호를 정의합니다 .이 기호는 &amp;lt;netdb.h&amp;gt;가 다양한 gethost * () 함수에 대한 프로토 타입을 제공한다는 것을 C 프로그램에 나타냅니다. 또한보십시오</target>
        </trans-unit>
        <trans-unit id="6911ca40dacf0175aa25657133be0fd097867be4" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETITIMER&lt;/code&gt; symbol, which indicates to the C program that the getitimer() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETITIMER&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getitimer () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f04b4d71f3b0d33d951527806b9faa1b90d89c13" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETLOGIN&lt;/code&gt; symbol, which indicates to the C program that the getlogin() routine is available to get the login name.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETLOGIN&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getlogin () 루틴을 사용하여 로그인 이름을 가져올 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cf1e0fa70097167eda24ba22a85cbfefb047a83b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETLOGIN_R&lt;/code&gt; symbol, which indicates to the C program that the getlogin_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETLOGIN_R&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getlogin_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3040c09147f006139a9558f8a311da05ada71cc3" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETMNT&lt;/code&gt; symbol, which indicates to the C program that the getmnt() routine is available to retrieve one or more mount info blocks by filename.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_GETMNT&lt;/code&gt; 기호를 조건부로 정의합니다 .이 기호는 C 프로그램에 getmnt () 루틴이 파일 이름별로 하나 이상의 마운트 정보 블록을 검색 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="df153c694674c9eb98ea57c25cde4b2529e93311" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETMNTENT&lt;/code&gt; symbol, which indicates to the C program that the getmntent() routine is available to iterate through mounted files to get their mount info.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETMNTENT&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 마운트 된 파일을 통해 반복 정보를 얻기 위해 getmntent () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="998b35a864ca7293bfdbdc5a68d5a152a1d7c29e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETNAMEINFO&lt;/code&gt; symbol, which indicates to the C program that the getnameinfo() function is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETNAMEINFO&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getnameinfo () 함수를 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8474869224bdf2ca0fc35d392c15a984241143e3" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETNETBYADDR&lt;/code&gt; symbol, which indicates to the C program that the getnetbyaddr() routine is available to look up networks by their &lt;code&gt;IP&lt;/code&gt; addresses.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETNETBYADDR&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getnetbyaddr () 루틴을 사용하여 &lt;code&gt;IP&lt;/code&gt; 주소로 네트워크를 검색 할 수 있음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="f75e54ebc6a22f2ef91ec6d724d333f9d033387c" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETNETBYADDR_R&lt;/code&gt; symbol, which indicates to the C program that the getnetbyaddr_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETNETBYADDR_R&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getnetbyaddr_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6b5ef841b8644e4d43f32175f64b87de38e60b50" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETNETBYNAME&lt;/code&gt; symbol, which indicates to the C program that the getnetbyname() routine is available to look up networks by their names.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETNETBYNAME&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getnetbyname () 루틴을 사용하여 이름으로 네트워크를 검색 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="721c47b838e08cebc4dfc525ba1a86bef8ed22b8" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETNETBYNAME_R&lt;/code&gt; symbol, which indicates to the C program that the getnetbyname_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETNETBYNAME_R&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getnetbyname_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5e1f8d2dc25f66de5fe6af8a19d35c75f17a5000" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETNETENT_R&lt;/code&gt; symbol, which indicates to the C program that the getnetent_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETNETENT_R&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getnetent_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="bceed1c7ecb752248dae3627ddd88c982cb3b42e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETNET_PROTOS&lt;/code&gt; symbol, which indicates to the C program that &amp;lt;netdb.h&amp;gt; supplies prototypes for the various getnet*() functions. See also</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETNET_PROTOS&lt;/code&gt; 기호를 정의합니다 .이 기호는 &amp;lt;netdb.h&amp;gt;가 다양한 getnet * () 함수에 대한 프로토 타입을 제공한다는 것을 C 프로그램에 표시합니다. 또한보십시오</target>
        </trans-unit>
        <trans-unit id="7aa9f35159df360d21bd577eca2bcbf715c7998d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETPGID&lt;/code&gt; symbol, which indicates to the C program that the getpgid(pid) function is available to get the process group id.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETPGID&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getpgid (pid) 함수를 사용하여 프로세스 그룹 ID를 가져올 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="04f375e83ea7b8de60cfb2691530d1bc9774418d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETPPID&lt;/code&gt; symbol, which indicates to the C program that the getppid() routine is available to get the parent process &lt;code&gt;ID&lt;/code&gt; .</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_GETPPID&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getppid () 루틴을 사용하여 상위 프로세스 &lt;code&gt;ID&lt;/code&gt; 를 가져올 수 있음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="7a78c1d0e9007adf39f8c4627cff4de19b836276" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETPROTOBYNAME&lt;/code&gt; symbol, which indicates to the C program that the getprotobyname() routine is available to look up protocols by their name.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_GETPROTOBYNAME&lt;/code&gt; 기호를 조건부로 정의합니다 .이 기호는 C 프로그램에 getprotobyname () 루틴을 사용하여 이름으로 프로토콜을 검색 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="94ee0c74e30f9d4b71ac73fae7e719b93f83ff28" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETPROTOBYNAME_R&lt;/code&gt; symbol, which indicates to the C program that the getprotobyname_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETPROTOBYNAME_R&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getprotobyname_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="89d5b6b59bfef172f96bfa6cc53c69ec52250783" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETPROTOBYNUMBER&lt;/code&gt; symbol, which indicates to the C program that the getprotobynumber() routine is available to look up protocols by their number.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETPROTOBYNUMBER&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 getprotobynumber () 루틴이 번호로 프로토콜을 검색 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="368c95f7c37edd3f397895e63f2b56a7b2a21f03" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETPROTOBYNUMBER_R&lt;/code&gt; symbol, which indicates to the C program that the getprotobynumber_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETPROTOBYNUMBER_R&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getprotobynumber_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d05bd546cb9ce10a4ef01cbbaaa2e5620cb6fb98" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETPROTOENT_R&lt;/code&gt; symbol, which indicates to the C program that the getprotoent_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETPROTOENT_R&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getprotoent_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f547c005ea9729c6769bbf465f8db85dfc630fb1" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETPROTO_PROTOS&lt;/code&gt; symbol, which indicates to the C program that &amp;lt;netdb.h&amp;gt; supplies prototypes for the various getproto*() functions. See also</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETPROTO_PROTOS&lt;/code&gt; 기호를 정의합니다 .이 기호는 &amp;lt;netdb.h&amp;gt;가 다양한 getproto * () 함수에 대한 프로토 타입을 제공한다는 것을 C 프로그램에 나타냅니다. 또한보십시오</target>
        </trans-unit>
        <trans-unit id="eaee5a550cc6a07f34637bc2870d60dbfb57bba0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETPWENT&lt;/code&gt; symbol, which indicates to the C program that the getpwent() routine is available for sequential access of the passwd database.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_GETPWENT&lt;/code&gt; 기호를 조건부로 정의합니다 .이 기호는 C 프로그램에 getpwent () 루틴이 passwd 데이터베이스의 순차적 액세스에 사용 가능함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0cfeae59d099abce81836530d715a51913eaf2a9" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETPWENT_R&lt;/code&gt; symbol, which indicates to the C program that the getpwent_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETPWENT_R&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getpwent_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9275e131831690787dbdc11f7dfcedfb8c9f2eda" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETPWNAM_R&lt;/code&gt; symbol, which indicates to the C program that the getpwnam_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETPWNAM_R&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getpwnam_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8827a97094e26a9a854d28073049c8082dc5d239" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETPWUID_R&lt;/code&gt; symbol, which indicates to the C program that the getpwuid_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETPWUID_R&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getpwuid_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ddc4a151da38a54d4688d4389e590a62e281759b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETSERVBYNAME&lt;/code&gt; symbol, which indicates to the C program that the getservbyname() routine is available to look up services by their name.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_GETSERVBYNAME&lt;/code&gt; 기호를 조건부로 정의합니다 . 이는 C 프로그램에 getservbyname () 루틴이 이름별로 서비스를 검색 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f63223f218d82f595643d54737913a982ed89b01" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETSERVBYNAME_R&lt;/code&gt; symbol, which indicates to the C program that the getservbyname_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETSERVBYNAME_R&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getservbyname_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2233b0d3a5dbbbc8649c940b930ca9249fb21aa0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETSERVBYPORT&lt;/code&gt; symbol, which indicates to the C program that the getservbyport() routine is available to look up services by their port.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_GETSERVBYPORT&lt;/code&gt; 기호를 조건부로 정의합니다 . 이는 C 프로그램에 getservbyport () 루틴이 포트별로 서비스를 검색 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e47e4595e0b65cee2c0cb9c76e2aaaffe9e90733" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETSERVBYPORT_R&lt;/code&gt; symbol, which indicates to the C program that the getservbyport_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETSERVBYPORT_R&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 getservbyport_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="07df398a34922beccb5e215e721d52f31b38b932" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETSERVENT_R&lt;/code&gt; symbol, which indicates to the C program that the getservent_r() routine is available.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_GETSERVENT_R&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 getservent_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="08eec3a50cec026084bfb933ad487f92365051f3" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETSERV_PROTOS&lt;/code&gt; symbol, which indicates to the C program that &amp;lt;netdb.h&amp;gt; supplies prototypes for the various getserv*() functions. See also</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETSERV_PROTOS&lt;/code&gt; 기호를 정의합니다 .이 기호는 &amp;lt;netdb.h&amp;gt;가 다양한 getserv * () 함수에 대한 프로토 타입을 제공한다는 것을 C 프로그램에 표시합니다. 또한보십시오</target>
        </trans-unit>
        <trans-unit id="6ee9b27273c95fe6af664a46ca2e4b018eb2a3bb" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETSPNAM_R&lt;/code&gt; symbol, which indicates to the C program that the getspnam_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GETSPNAM_R&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 getspnam_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e672430eb4f4b23e7c8ea71a0d9547945979104c" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETTIMEOFDAY&lt;/code&gt; symbol, which indicates that the gettimeofday() system call exists (to obtain a sub-second accuracy clock). You should probably include &amp;lt;sys/resource.h&amp;gt;.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_GETTIMEOFDAY&lt;/code&gt; 기호를 정의합니다 .이 기호는 gettimeofday () 시스템 호출이 있음을 나타냅니다 (1 초 미만의 정확도 클럭을 얻기 위해). &amp;lt;sys / resource.h&amp;gt;를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="84fced701ac1d8972ad41c237d19c362f2099ca2" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GMTIME_R&lt;/code&gt; symbol, which indicates to the C program that the gmtime_r() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_GMTIME_R&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 gmtime_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1fd3c7d3ad1a3dfa9df8edc33011f70a34e07812" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_HASMNTOPT&lt;/code&gt; symbol, which indicates to the C program that the hasmntopt() routine is available to query the mount options of file systems.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_HASMNTOPT&lt;/code&gt; 기호를 조건부로 정의하며 , 이는 hasmntopt () 루틴이 파일 시스템의 마운트 옵션을 조회하는 데 사용 가능함을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="00e5a920dcdf38a72d0e1f65eec67c25b8f6b02e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ILOGB&lt;/code&gt; symbol, which indicates to the C program that the ilogb() routine is available for extracting the exponent of double x as a signed integer.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_ILOGB&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 ilogb () 루틴을 사용하여 double x의 지수를 부호있는 정수로 추출 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="08c0b5bc5432877b8453b37bdcbcd6004c0f3533" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ILOGBL&lt;/code&gt; symbol, which indicates to the C program that the ilogbl() routine is available for extracting the exponent of long double x as a signed integer. If scalbnl is also present we can emulate frexpl.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_ILOGBL&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 ilogbl () 루틴이 부호있는 정수로 long double x의 지수를 추출 할 수 있음을 나타냅니다. scalbnl도 있으면 frexpl을 에뮬레이션 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7a6e67ac883b1040cb0eb3aa3cd89d5352feb93" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_INETNTOP&lt;/code&gt; symbol, which indicates to the C program that the inet_ntop() function is available.</source>
          <target state="translated">이 변수 는 C 프로그램에 inet_ntop () 함수를 사용할 수 있음을 나타내는 &lt;code&gt;HAS_INETNTOP&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="22502f98a24d835efbc320660dd0c293f19ac278" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_INETPTON&lt;/code&gt; symbol, which indicates to the C program that the inet_pton() function is available.</source>
          <target state="translated">이 변수 는 C 프로그램에 inet_pton () 함수를 사용할 수 있음을 나타내는 &lt;code&gt;HAS_INETPTON&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="ff67d886f79098d9924c2d3ff3d0db78ccef4ffe" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_INET_ATON&lt;/code&gt; symbol, which indicates to the C program that the inet_aton() function is available to parse &lt;code&gt;IP&lt;/code&gt; address &lt;code&gt;dotted-quad&lt;/code&gt; strings.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_INET_ATON&lt;/code&gt; 기호를 조건부로 정의합니다 . 이는 C 프로그램에 inet_aton () 함수를 사용하여 &lt;code&gt;IP&lt;/code&gt; 주소 점진 &lt;code&gt;dotted-quad&lt;/code&gt; 문자열 을 구문 분석 할 수 있음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="ab41c4767757cf5520d581b43402f2b69d925446" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_IP_MREQ&lt;/code&gt; symbol, which indicates the availability of a struct ip_mreq.</source>
          <target state="translated">이 변수 는 struct ip_mreq의 가용성을 나타내는 &lt;code&gt;HAS_IP_MREQ&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="55f85ff4272b951d973813125721ee335bf64458" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_IP_MREQ_SOURCE&lt;/code&gt; symbol, which indicates the availability of a struct ip_mreq_source.</source>
          <target state="translated">이 변수 는 struct ip_mreq_source의 가용성을 나타내는 &lt;code&gt;HAS_IP_MREQ_SOURCE&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="72388a4f1ba17b3fd0e62b5152d323f4548da870" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ISASCII&lt;/code&gt; constant, which indicates to the C program that isascii() is available.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_ISASCII&lt;/code&gt; 상수를 조건부로 정의하며 , 이는 isascii ()가 사용 가능함을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="5a5c21b2a9944da065cad96d5e707e6c815182d3" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ISBLANK&lt;/code&gt; constant, which indicates to the C program that isblank() is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_ISBLANK&lt;/code&gt; 상수를 정의합니다 . 이는 C 프로그램에 isblank ()를 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fcfef1f9f54abc2b109ba1f21e62b9cb30d767cd" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ISFINITE&lt;/code&gt; symbol, which indicates to the C program that the isfinite() routine is available.</source>
          <target state="translated">이 변수 는 C 프로그램에 isfinite () 루틴을 사용할 수 있음을 나타내는 &lt;code&gt;HAS_ISFINITE&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="b52552318ae18b7d8b2396ea779d84538ec17c45" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ISFINITEL&lt;/code&gt; symbol, which indicates to the C program that the isfinitel() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_ISFINITEL&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 isfinitel () 루틴이 사용 가능함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5cd5f09b0af60ecfb75127a22d7e1ee2c772c023" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ISINF&lt;/code&gt; symbol, which indicates to the C program that the isinf() routine is available.</source>
          <target state="translated">이 변수 는 C 프로그램에 isinf () 루틴을 사용할 수 있음을 나타내는 &lt;code&gt;HAS_ISINF&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="a94a2b2142e85325054f5f4823ba6b83d8fa642a" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ISINFL&lt;/code&gt; symbol, which indicates to the C program that the isinfl() routine is available.</source>
          <target state="translated">이 변수 는 C 프로그램에 isinfl () 루틴을 사용할 수 있음을 나타내는 &lt;code&gt;HAS_ISINFL&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="4fd09d1b06bd7c7d728ac0ffd960b30379c4a768" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ISNAN&lt;/code&gt; symbol, which indicates to the C program that the isnan() routine is available.</source>
          <target state="translated">이 변수 는 C 프로그램에 isnan () 루틴을 사용할 수 있음을 나타내는 &lt;code&gt;HAS_ISNAN&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="0ae4b6ae907fe92bcc5cb3aa1a2e0540e4b58a60" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ISNANL&lt;/code&gt; symbol, which indicates to the C program that the isnanl() routine is available.</source>
          <target state="translated">이 변수 는 C 프로그램에 isnanl () 루틴을 사용할 수 있음을 나타내는 &lt;code&gt;HAS_ISNANL&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="94a6de8a4e8a40a43a72c3936b6277b9b9b82512" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ISNORMAL&lt;/code&gt; symbol, which indicates to the C program that the isnormal() routine is available.</source>
          <target state="translated">이 변수 는 C 프로그램에 isnormal () 루틴을 사용할 수 있음을 나타내는 &lt;code&gt;HAS_ISNORMAL&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="9461c7ba3e2b8bec7df67bc8c282aae74033fc39" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_KILLPG&lt;/code&gt; symbol, which indicates to the C program that the killpg() routine is available to kill process groups.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_KILLPG&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 killpg () 루틴이 프로세스 그룹을 강제 종료 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="274a3e469317759be16452a214542288c6b937a7" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_LCHOWN&lt;/code&gt; symbol, which indicates to the C program that the lchown() routine is available to operate on a symbolic link (instead of following the link).</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_LCHOWN&lt;/code&gt; 기호를 정의합니다 .이 기호는 lchown () 루틴이 기호 링크에서 작동 할 수 있음을 C 프로그램에 표시합니다 (링크를 따르는 대신).</target>
        </trans-unit>
        <trans-unit id="0f56859453fc1d27f3f17bb37fc0a2d155502907" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_LDEXPL&lt;/code&gt; symbol, which indicates to the C program that the ldexpl() routine is available.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_LDEXPL&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 ldexpl () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a37d8cf4a0848f3d9bb4cc5545717c3e60e45b64" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_LGAMMA&lt;/code&gt; symbol, which indicates to the C program that the lgamma() routine is available for the log gamma function. See also d_tgamma and d_lgamma_r.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_LGAMMA&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 lgamma () 루틴이 로그 감마 함수에 사용 가능함을 나타냅니다. d_tgamma 및 d_lgamma_r도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5b284947de52d44afb16de832ba8c676b549a69b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_LGAMMA_R&lt;/code&gt; symbol, which indicates to the C program that the lgamma_r() routine is available for the log gamma function, without using the global signgam variable.</source>
          <target state="translated">이 변수 는 전역 signgam 변수를 사용하지 않고 lgamma_r () 루틴을 로그 감마 함수에 사용할 수 있음을 C 프로그램에 표시 하는 &lt;code&gt;HAS_LGAMMA_R&lt;/code&gt; 기호를 조건부로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="ffb5213a88acb50acec17dbb6c54f9e6a79439a1" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_LLRINT&lt;/code&gt; symbol, which indicates to the C program that the llrint() routine is available to return the long long value closest to (according to the current rounding mode) to x.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_LLRINT&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 llrint () 루틴이 현재 반올림 모드에 따라 가장 긴 long 값을 x에 반환 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="36eb192d0749628551dd02acda589177da2e7d35" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_LLRINTL&lt;/code&gt; symbol, which indicates to the C program that the llrintl() routine is available to return the long long value closest to (according to the current rounding mode) to long double x.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_LLRINTL&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 llrintl () 루틴을 사용하여 (현재 반올림 모드에 따라) 가장 긴 long 값을 long double x에 반환 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="507a36c2b350b208ae4a46fb5a72082e021ebc45" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_LLROUND&lt;/code&gt; symbol, which indicates to the C program that the llround() routine is available to return the long long value nearest to x.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_LLROUND&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 llround () 루틴을 사용하여 x에 가장 가까운 long long 값을 반환 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="376c225543a2aa31e29c03d6e79d5c7959f398b0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_LLROUNDL&lt;/code&gt; symbol, which indicates to the C program that the llroundl() routine is available to return the long long value nearest to long double x.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_LLROUNDL&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 llroundl () 루틴이 long double x에 가장 가까운 long long 값을 리턴 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="26b625166da5e7848c2b479c515fe2ce2068675c" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_LOCALTIME_R&lt;/code&gt; symbol, which indicates to the C program that the localtime_r() routine is available.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_LOCALTIME_R&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 localtime_r () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c32fe04a06654e46c76a07b1aa643b0837f3e1c9" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_LOGB&lt;/code&gt; symbol, which indicates to the C program that the logb() routine is available to extract the exponent of x.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_LOGB&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 logb () 루틴을 사용하여 x의 지수를 추출 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="707826980dd3a292f3abccaa532be36235824b3f" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_LRINT&lt;/code&gt; symbol, which indicates to the C program that the lrint() routine is available to return the integral value closest to (according to the current rounding mode) to x.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_LRINT&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 lrint () 루틴을 사용하여 (현재 반올림 모드에 따라) 가장 가까운 정수 값을 x에 반환 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="13c1d76b4549133b6a13e4a1416e75f07fde92c7" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_LRINTL&lt;/code&gt; symbol, which indicates to the C program that the lrintl() routine is available to return the integral value closest to (according to the current rounding mode) to long double x.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_LRINTL&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 lrintl () 루틴을 사용하여 (현재 반올림 모드에 따라) long double x에 가장 가까운 정수 값을 반환 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="68fa84636788a64a519f29a7d95a105e7ea43315" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_LROUND&lt;/code&gt; symbol, which indicates to the C program that the lround() routine is available to return the integral value nearest to x.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_LROUND&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 lround () 루틴이 x에 가장 가까운 정수 값을 리턴 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8a554bc9a850d4c6deffc69109e332c1e8434acb" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_LROUNDL&lt;/code&gt; symbol, which indicates to the C program that the lroundl() routine is available to return the integral value nearest to x of the long double argument.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_LROUNDL&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 lroundl () 루틴을 사용하여 long double 인수의 x에 가장 가까운 정수 값을 리턴 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9026f0b5e7d8f8d8ec995eda93ddae70790dcdbd" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_LSEEK_PROTO&lt;/code&gt; symbol, which indicates to the C program that the system provides a prototype for the lseek() function. Otherwise, it is up to the program to supply one.</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_LSEEK_PROTO&lt;/code&gt; 기호를 조건부로 정의하며 , 이는 시스템이 lseek () 함수의 프로토 타입을 제공함을 C 프로그램에 표시합니다. 그렇지 않으면 프로그램을 제공하는 것은 프로그램의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="702f47257224cd23f04e020414c05342dff68475" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MBLEN&lt;/code&gt; symbol, which indicates to the C program that the mblen() routine is available to find the number of bytes in a multibye character.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_MBLEN&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 mblen () 루틴이 멀티 바이 문자의 바이트 수를 찾을 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="68073aab3a42045bf6c2864188f0973dd612c281" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MBSTOWCS&lt;/code&gt; symbol, which indicates to the C program that the mbstowcs() routine is available to convert a multibyte string into a wide character string.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_MBSTOWCS&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 mbstowcs () 루틴을 사용하여 멀티 바이트 문자열을 와이드 문자열로 변환 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="42b542845477967812c79aae9ed300adea839dd9" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MBTOWC&lt;/code&gt; symbol, which indicates to the C program that the mbtowc() routine is available to convert multibyte to a wide character.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_MBTOWC&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 mbtowc () 루틴을 사용하여 멀티 바이트를 와이드 문자로 변환 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="102db711f4b0e45e67feb844a2fc8fe9e66537a6" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MEMCHR&lt;/code&gt; symbol, which indicates to the C program that the memchr() routine is available to locate characters within a C string.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_MEMCHR&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에서 memchr () 루틴을 사용하여 C 문자열 내에서 문자를 찾을 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7235ca768c8d034cec91ebe2d78865b39fdf2ba7" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MEMCMP&lt;/code&gt; symbol, which indicates to the C program that the memcmp() routine is available to compare blocks of memory.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_MEMCMP&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 memcmp () 루틴을 사용하여 메모리 블록을 비교할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9bebe696de97246540e522bb2e6da8fab93032d1" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MEMCPY&lt;/code&gt; symbol, which indicates to the C program that the memcpy() routine is available to copy blocks of memory.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_MEMCPY&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 memcpy () 루틴을 사용하여 메모리 블록을 복사 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="325a4968300d1d00834d074e2dda029f39634d7f" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MEMMOVE&lt;/code&gt; symbol, which indicates to the C program that the memmove() routine is available to copy potentially overlapping blocks of memory.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_MEMMOVE&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 memmove () 루틴을 사용하여 잠재적으로 겹치는 메모리 블록을 복사 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c7d0f000fc251635fd80e34aa635da5773481577" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MEMSET&lt;/code&gt; symbol, which indicates to the C program that the memset() routine is available to set blocks of memory.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_MEMSET&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 memset () 루틴을 사용하여 메모리 블록을 설정할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="dc8f79cfbd2b96ee25d6d1ee5c1384a4ad8b5b3b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MKDIR&lt;/code&gt; symbol, which indicates to the C program that the mkdir() routine is available to create</source>
          <target state="translated">이 변수는 &lt;code&gt;HAS_MKDIR&lt;/code&gt; 기호를 조건부로 정의합니다 .이 기호는 C 프로그램에 mkdir () 루틴을 작성할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0dfb53b8b3dee823205d19c28ace4b726497760a" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MKDTEMP&lt;/code&gt; symbol, which indicates to the C program that the mkdtemp() routine is available to exclusively create a uniquely named temporary directory.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_MKDTEMP&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 mkdtemp () 루틴이 고유하게 이름 지정된 임시 디렉토리를 독점적으로 작성할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c1f680310dfb70f55e565d1e0109be2e8e4c87f5" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MKFIFO&lt;/code&gt; symbol, which indicates to the C program that the mkfifo() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_MKFIFO&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 mkfifo () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d329c85fbd87b445b67f4dc354564f846b9735aa" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MKSTEMP&lt;/code&gt; symbol, which indicates to the C program that the mkstemp() routine is available to exclusively create and open a uniquely named temporary file.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_MKSTEMP&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 mkstemp () 루틴이 고유하게 이름 지정된 임시 파일을 독점적으로 작성하고 열 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8805b03cf4516a990a6b253e051e527792bc4add" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MKSTEMPS&lt;/code&gt; symbol, which indicates to the C program that the mkstemps() routine is available to exclusively create and open a uniquely named (with a suffix) temporary file.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_MKSTEMPS&lt;/code&gt; 기호를 정의합니다 . 이는 C 프로그램에 mkstemps () 루틴을 사용하여 고유 한 이름을 가진 임시 파일을 독점적으로 작성하고 열 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="206f66bb208940b6f4dad138b2fc18cc3c165061" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MKTIME&lt;/code&gt; symbol, which indicates to the C program that the mktime() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_MKTIME&lt;/code&gt; 기호를 정의하며 , 이는 mktime () 루틴이 사용 가능함을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="f8b01b3cc879138798d33d0417c145e742ff8d00" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MODFL&lt;/code&gt; symbol, which indicates to the C program that the modfl() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_MODFL&lt;/code&gt; 기호를 정의하며 , 이는 modfl () 루틴이 사용 가능함을 C 프로그램에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="59c032422721290310c184282c0c203c9082b8f1" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MSG&lt;/code&gt; symbol, which indicates that the entire msg*(2) library is present.</source>
          <target state="translated">이 변수는 조건부로 전체 msg * (2) 라이브러리가 있음을 나타내는 &lt;code&gt;HAS_MSG&lt;/code&gt; 기호를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="fb5e836bd1b6ceda16daf87a813a852108bdbdb9" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MSGCTL&lt;/code&gt; symbol, which indicates to the C program that the msgctl() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_MSGCTL&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 msgctl () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1ef076a7a468a1472229759a7af88f68403a3519" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MSGGET&lt;/code&gt; symbol, which indicates to the C program that the msgget() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_MSGGET&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 msgget () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="95826169e9ec6e737b42970b82165e9dd23743e0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MSGRCV&lt;/code&gt; symbol, which indicates to the C program that the msgrcv() routine is available.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;HAS_MSGRCV&lt;/code&gt; 기호를 정의합니다 .이 기호는 C 프로그램에 msgrcv () 루틴을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8325f3391840c0f56f190ee2693366b6e70a6573" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MSGSND&lt;/code&gt; symbol, which indicates to the C program that the msgsnd() routine is available.</source>
          <target state="translated">이 변수는 조건부로 정의 &lt;code&gt;HAS_MSGSND&lt;/code&gt; 의 msgsnd는 () 루틴을 사용할 수있는 C 프로그램에 표시 기호를.</target>
        </trans-unit>
        <trans-unit id="84941c248e23475cd8c896889cac2c4c99454a7c" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MSG_CTRUNC&lt;/code&gt; symbol, which indicates that the &lt;code&gt;MSG_CTRUNC&lt;/code&gt; is available. #ifdef is not enough because it may be an enum, glibc has been known to do this.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;MSG_CTRUNC&lt;/code&gt; 가 사용 가능함 을 나타내는 &lt;code&gt;HAS_MSG_CTRUNC&lt;/code&gt; 기호를 정의합니다 . #ifdef는 열거 형일 수 있기 때문에 충분하지 않습니다. glibc는이를 수행하는 것으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="950da7c3fd59c0e17f00f095ffc534d207054985" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MSG_DONTROUTE&lt;/code&gt; symbol, which indicates that the &lt;code&gt;MSG_DONTROUTE&lt;/code&gt; is available. #ifdef is not enough because it may be an enum, glibc has been known to do this.</source>
          <target state="translated">이 변수 는 &lt;code&gt;MSG_DONTROUTE&lt;/code&gt; 가 사용 가능함 을 나타내는 &lt;code&gt;HAS_MSG_DONTROUTE&lt;/code&gt; 기호를 조건부로 정의합니다 . #ifdef는 열거 형일 수 있기 때문에 충분하지 않습니다. glibc는이를 수행하는 것으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="340fb73e5613c1253991bbcd58d22b8f0a4f607a" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MSG_OOB&lt;/code&gt; symbol, which indicates that the &lt;code&gt;MSG_OOB&lt;/code&gt; is available. #ifdef is not enough because it may be an enum, glibc has been known to do this.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;MSG_OOB&lt;/code&gt; 가 사용 가능함 을 나타내는 &lt;code&gt;HAS_MSG_OOB&lt;/code&gt; 기호를 정의합니다 . #ifdef는 열거 형일 수 있기 때문에 충분하지 않습니다. glibc는이를 수행하는 것으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ba5b98861532f57b23f48c18b0143746c802ead" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MSG_PEEK&lt;/code&gt; symbol, which indicates that the &lt;code&gt;MSG_PEEK&lt;/code&gt; is available. #ifdef is not enough because it may be an enum, glibc has been known to do this.</source>
          <target state="translated">이 변수는 조건 적으로 &lt;code&gt;MSG_PEEK&lt;/code&gt; 가 사용 가능함 을 나타내는 &lt;code&gt;HAS_MSG_PEEK&lt;/code&gt; 기호를 정의합니다 . #ifdef는 열거 형일 수 있기 때문에 충분하지 않습니다. glibc는이를 수행하는 것으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="21d1bc76282392273685e2fda20d7ff8209a22b5" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MSG_PROXY&lt;/code&gt; symbol, which indicates that the &lt;code&gt;MSG_PROXY&lt;/code&gt; is available. #ifdef is not enough because it may be an enum, glibc has been known to do this.</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_MSG_PROXY&lt;/code&gt; 기호를 정의합니다 . 이는 &lt;code&gt;MSG_PROXY&lt;/code&gt; 가 사용 가능함 을 나타냅니다 . #ifdef는 열거 형일 수 있기 때문에 충분하지 않습니다. glibc는이를 수행하는 것으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1603a6598296b1c4fdf0ef321efb381ba924904" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_NDBM&lt;/code&gt; symbol, which indicates that both the</source>
          <target state="translated">이 변수는 조건부로 &lt;code&gt;HAS_NDBM&lt;/code&gt; 기호를 정의합니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
