<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="8df52c6dbe1d57b617631599c530a100984708ce" translate="yes" xml:space="preserve">
          <source>When choosing a new salt create a random two character string whose characters come from the set &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; (like &lt;code&gt;&lt;a href=&quot;join&quot;&gt;join&lt;/a&gt; '', ('.',
'/', 0..9, 'A'..'Z', 'a'..'z')[&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt; 64, &lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt; 64]&lt;/code&gt; ). This set of characters is just a recommendation; the characters allowed in the salt depend solely on your system's crypt library, and Perl can't restrict what salts &lt;code&gt;&lt;a href=&quot;crypt&quot;&gt;crypt()&lt;/a&gt;&lt;/code&gt; accepts.</source>
          <target state="translated">새 솔트를 선택할 때 문자 세트 &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; 에서 나오는 임의의 2 문자열을 만듭니다 (예 : &lt;code&gt;&lt;a href=&quot;join&quot;&gt;join&lt;/a&gt; '', ('.', '/', 0..9, 'A'..'Z', 'a'..'z')[&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt; 64, &lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt; 64]&lt;/code&gt; ). 이 문자 집합은 권장 사항입니다. 솔트에 허용되는 문자는 시스템의 크립 라이브러리에만 의존하며 Perl은 &lt;code&gt;&lt;a href=&quot;crypt&quot;&gt;crypt()&lt;/a&gt;&lt;/code&gt; 허용 하는 솔트를 제한 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="ba90a2d042a133e843c0ea1363bae85f48e8fd9f" translate="yes" xml:space="preserve">
          <source>When combined with variable declaration, simple scalar assignment to &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; variables (as in &lt;code&gt;state $x = 42&lt;/code&gt; ) is executed only the first time. When such statements are evaluated subsequent times, the assignment is ignored. The behavior of this sort of assignment to non-scalar variables is undefined.</source>
          <target state="translated">변수 선언과 결합하면 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 변수에 대한 간단한 스칼라 할당 ( &lt;code&gt;state $x = 42&lt;/code&gt; )은 처음으로 만 실행됩니다. 그러한 진술이 이후에 평가 될 때, 할당은 무시된다. 비-스칼라 변수에 대한 이러한 종류의 할당 동작은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8723e913d037ae6e1a9af1f510a75733eba10e88" translate="yes" xml:space="preserve">
          <source>When comparing &lt;code&gt;$]&lt;/code&gt; , string comparison operators are &lt;b&gt;highly recommended&lt;/b&gt;. The inherent limitations of binary floating point representation can sometimes lead to incorrect comparisons for some numbers on some architectures.</source>
          <target state="translated">&lt;code&gt;$]&lt;/code&gt; 를 비교할 때는 문자열 비교 연산자를 &lt;b&gt;적극 권장&lt;/b&gt; 합니다. 이진 부동 소수점 표현의 고유 한 제한으로 인해 일부 아키텍처에서 일부 숫자가 잘못 비교 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9cb0233568f5abd1d88fb8340be5337623b26d31" translate="yes" xml:space="preserve">
          <source>When compiling Perl in Tru64 you may (depending on the compiler release) see two warnings like this</source>
          <target state="translated">Tru64에서 Perl을 컴파일 할 때 (컴파일러 릴리스에 따라) 다음과 같은 두 가지 경고가 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfc6666c4c5744908a4efd082506a76f331670ff" translate="yes" xml:space="preserve">
          <source>When compiling Perl, you must use an ANSI C compiler. AIX does not ship an ANSI compliant C compiler with AIX by default, but binary builds of gcc for AIX are widely available. A version of gcc is also included in the AIX Toolbox which is shipped with AIX.</source>
          <target state="translated">Perl을 컴파일 할 때는 ANSI C 컴파일러를 사용해야합니다. AIX는 기본적으로 AIX와 함께 ANSI 호환 C 컴파일러를 제공하지 않지만 AIX 용 바이너리 gcc 빌드는 널리 사용 가능합니다. gcc 버전도 AIX와 함께 제공되는 AIX Toolbox에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f65988610c7d74b5ae9b07dd95c21b84e89fdc66" translate="yes" xml:space="preserve">
          <source>When compiling Perl, you must use an ANSI C compiler. AIX does not ship an ANSI compliant C-compiler with AIX by default, but binary builds of gcc for AIX are widely available.</source>
          <target state="translated">Perl을 컴파일 할 때는 ANSI C 컴파일러를 사용해야합니다. AIX는 기본적으로 AIX와 함께 ANSI 호환 C- 컴파일러를 제공하지 않지만 AIX 용 바이너리 gcc 빌드는 널리 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="e54d0f630f4052fa4f5e8949b94bd1a858274b61" translate="yes" xml:space="preserve">
          <source>When compiling Perl, you must use an ANSI C compiler. The C compiler that ships with all HP-UX systems is a K&amp;amp;R compiler that should only be used to build new kernels.</source>
          <target state="translated">Perl을 컴파일 할 때는 ANSI C 컴파일러를 사용해야합니다. 모든 HP-UX 시스템과 함께 제공되는 C 컴파일러는 새 커널을 빌드하는 데만 사용해야하는 K &amp;amp; R 컴파일러입니다.</target>
        </trans-unit>
        <trans-unit id="396066667b73652500c61d9a6b382668c31190fa" translate="yes" xml:space="preserve">
          <source>When compiling in PASE, there is no &quot;oslevel&quot; command. Therefore, you may want to create a script called &quot;oslevel&quot; that echoes the level of AIX that your version of PASE runtime supports. If you're unsure, consult your documentation or use &quot;4.3.3.0&quot;.</source>
          <target state="translated">PASE에서 컴파일 할 때는 &quot;oslevel&quot;명령이 없습니다. 따라서 PASE 런타임 버전이 지원하는 AIX 레벨을 에코하는 &quot;oslevel&quot;이라는 스크립트를 작성할 수 있습니다. 확실하지 않은 경우 설명서를 참조하거나 &quot;4.3.3.0&quot;을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="975dca0ce3b92270da7ce263ccd6670142595f91" translate="yes" xml:space="preserve">
          <source>When complementing strings, if all characters have ordinal values under 256, then their complements will, also. But if they do not, all characters will be in either 32- or 64-bit complements, depending on your architecture. So for example, &lt;code&gt;~&quot;\x{3B1}&quot;&lt;/code&gt; is &lt;code&gt;&quot;\x{FFFF_FC4E}&quot;&lt;/code&gt; on 32-bit machines and &lt;code&gt;&quot;\x{FFFF_FFFF_FFFF_FC4E}&quot;&lt;/code&gt; on 64-bit machines.</source>
          <target state="translated">문자열을 보완 할 때 모든 문자에 256 미만의 서수 값이있는 경우 해당 문자열도 보완합니다. 그러나 그렇지 않은 경우 모든 문자는 아키텍처에 따라 32 비트 또는 64 비트 보수로 표시됩니다. 예를 들어, 32 비트 시스템 에서는 &lt;code&gt;~&quot;\x{3B1}&quot;&lt;/code&gt; 이 &lt;code&gt;&quot;\x{FFFF_FC4E}&quot;&lt;/code&gt; 이고 64 비트 시스템에서는 &lt;code&gt;&quot;\x{FFFF_FFFF_FFFF_FC4E}&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="927dc05b306a20a322eed6c8168ca784ea3ed41b" translate="yes" xml:space="preserve">
          <source>When configured for bundling, single-character options are matched case sensitive while long options are matched case insensitive. To have the single-character options matched case insensitive as well, use:</source>
          <target state="translated">번들로 구성하면 단일 문자 옵션은 대소 문자를 구분하고 긴 옵션은 대소 문자를 구분하지 않습니다. 단일 문자 옵션과 대소 문자를 구분하지 않으려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c4fb4623ce7c6c321834d001ce6f813a2fa89505" translate="yes" xml:space="preserve">
          <source>When creating and extending application programming interfaces (APIs) for Symbian or Series 60 or Series 80 or Series 90 it is suggested that trademarks, registered trademarks, or trade names are not used in the API names. Instead, developers should consider basing the API naming in the existing (C++, or maybe Java) public component and API naming, modified as appropriate by the rules of the programming language the new APIs are for.</source>
          <target state="translated">Symbian 또는 Series 60 또는 Series 80 또는 Series 90 용 API (Application Programming Interface)를 작성 및 확장 할 때 API 이름에 상표, 등록 상표 또는 상표 이름을 사용하지 않는 것이 좋습니다. 대신 개발자는 기존 (C ++ 또는 Java) 공용 구성 요소 및 API 명명에 기반하여 API 명명을 기반으로 새 API의 프로그래밍 언어 규칙에 따라 적절히 수정해야합니다.</target>
        </trans-unit>
        <trans-unit id="8dc80c71b0aa717f38046cb0d740616e9bd6381f" translate="yes" xml:space="preserve">
          <source>When dealing with C structures one should select either &lt;b&gt;T_PTROBJ&lt;/b&gt; or &lt;b&gt;T_PTRREF&lt;/b&gt; for the XS type. Both types are designed to handle pointers to complex objects. The T_PTRREF type will allow the Perl object to be unblessed while the T_PTROBJ type requires that the object be blessed. By using T_PTROBJ one can achieve a form of type-checking because the XSUB will attempt to verify that the Perl object is of the expected type.</source>
          <target state="translated">C 구조를 다룰 때 하나 하나 선택해야 &lt;b&gt;T_PTROBJ&lt;/b&gt; 또는 &lt;b&gt;T_PTRREF을&lt;/b&gt; XS를 유형. 두 유형 모두 복잡한 객체에 대한 포인터를 처리하도록 설계되었습니다. T_PTRREF 타입은 Perl 객체가 축복받지 못하게하는 반면 T_PTROBJ 타입은 객체가 축복 될 것을 요구합니다. T_PTROBJ를 사용하면 XSUB가 Perl 개체가 예상 형식인지 확인하려고 시도하기 때문에 형식 검사 형식을 달성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ef807c417305a11bdb217741916eb3c09e8b5cd" translate="yes" xml:space="preserve">
          <source>When dealing with binary files (or text files in binary mode) be sure to explicitly set $/ to the appropriate value for your file format before using &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이진 파일 (이진 모드의 텍스트 파일)을 처리 할 때 &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt; 를 사용하기 전에 $ /를 파일 형식에 적절한 값으로 명시 적으로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d089cbb7da6fb1de4b8e802beb51489b821fccc7" translate="yes" xml:space="preserve">
          <source>When dealing with references, it is important to handle them with caution. The &lt;code&gt;INIT:&lt;/code&gt; block first calls SvGETMAGIC(paths), in case paths is a tied variable. Then it checks that &lt;code&gt;SvROK&lt;/code&gt; returns true, which indicates that paths is a valid reference. (Simply checking &lt;code&gt;SvROK&lt;/code&gt; won't trigger FETCH on a tied variable.) It then verifies that the object referenced by paths is an array, using &lt;code&gt;SvRV&lt;/code&gt; to dereference paths, and &lt;code&gt;SvTYPE&lt;/code&gt; to discover its type. As an added test, it checks that the array referenced by paths is non-empty, using the &lt;code&gt;av_top_index&lt;/code&gt; function (which returns -1 if the array is empty). The XSRETURN_UNDEF macro is used to abort the XSUB and return the undefined value whenever all three of these conditions are not met.</source>
          <target state="translated">참조를 다룰 때는주의해서 다루어야합니다. &lt;code&gt;INIT:&lt;/code&gt; 블록은 첫 번째 경우 경로에 연결된 변수이다 SvGETMAGIC (경로)를 호출한다. 그런 다음 &lt;code&gt;SvROK&lt;/code&gt; 가 true를 반환 하는지 확인하여 경로가 유효한 참조임을 나타냅니다. &lt;code&gt;SvROK&lt;/code&gt; 를 확인 하면 연결된 변수에서 FETCH가 트리거되지 않습니다. 그런 다음 경로에서 참조하는 객체가 &lt;code&gt;SvRV&lt;/code&gt; 를 사용하여 경로를 참조하고 &lt;code&gt;SvTYPE&lt;/code&gt; 을 사용하여 해당 유형을 검색 하는 배열 인지 확인합니다. 추가 테스트로서, &lt;code&gt;av_top_index&lt;/code&gt; 를 사용하여 경로가 참조하는 배열이 비어 있지 않은지 확인합니다.함수 (배열이 비어 있으면 -1을 반환). XSRETURN_UNDEF 매크로는 XSUB를 중단하고이 세 가지 조건이 모두 충족되지 않을 때마다 정의되지 않은 값을 반환하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="38a7bf875048ed175efb40337595a64499d137a5" translate="yes" xml:space="preserve">
          <source>When dealing with strings containing characters that cannot be represented using an eight-bit character set, perl uses an internal representation that is a permissive version of Unicode's UTF-8 encoding[2]. This uses single bytes to represent characters from the ASCII character set, and sequences of two or more bytes for all other characters. (See &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; for more information about the relationship between UTF-8 and perl's encoding, utf8. The difference isn't important for this discussion.)</source>
          <target state="translated">8 비트 문자 집합을 사용하여 표현할 수없는 문자를 포함하는 문자열을 처리 할 때 perl은 허용 가능한 유니 코드 UTF-8 인코딩 버전 인 내부 표현을 사용합니다 [2]. 단일 바이트를 사용하여 ASCII 문자 세트의 문자를 나타내며 다른 모든 문자의 경우 2 바이트 이상의 시퀀스를 사용합니다. UTF-8과 perl의 인코딩 utf8 사이의 관계에 대한 자세한 정보는 &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; 를 참조하십시오 . 차이점은이 논의에서 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ec373fa59b49b953efac841d6f570fdf4b7bbe64" translate="yes" xml:space="preserve">
          <source>When debugging a script that uses #! and is thus normally found in $PATH, the -S option causes perl to search $PATH for it, so you don't have to type the path or &lt;code&gt;which $scriptname&lt;/code&gt; .</source>
          <target state="translated">#!를 사용하는 스크립트를 디버깅 할 때 따라서 일반적으로 $ PATH에 있으며 -S 옵션을 사용하면 perl이 $ PATH를 검색하므로 경로 또는 &lt;code&gt;which $scriptname&lt;/code&gt; 을 입력 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="f6fa41bd97a298d1cd8b0e0f363528cda01ea2a0" translate="yes" xml:space="preserve">
          <source>When defining multiple constants, you cannot use the values of other constants defined in the same declaration. This is because the calling package doesn't know about any constant within that group until</source>
          <target state="translated">여러 상수를 정의 할 때 동일한 선언에 정의 된 다른 상수의 값을 사용할 수 없습니다. 호출 패키지는 해당 그룹 내에서 상수를 알지 못하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="4723c71ed09d6ef17fa09da9076bcc24872495e5" translate="yes" xml:space="preserve">
          <source>When designing an interface between Perl and a C library a straight translation from C to XS (such as created by &lt;code&gt;h2xs -x&lt;/code&gt; ) is often sufficient. However, sometimes the interface will look very C-like and occasionally nonintuitive, especially when the C function modifies one of its parameters, or returns failure inband (as in &quot;negative return values mean failure&quot;). In cases where the programmer wishes to create a more Perl-like interface the following strategy may help to identify the more critical parts of the interface.</source>
          <target state="translated">Perl과 C 라이브러리 사이의 인터페이스를 설계 할 때 C에서 XS 로의 직접적인 변환 (예 : &lt;code&gt;h2xs -x&lt;/code&gt; 작성 )으로 충분합니다. 그러나, 특히 C 함수가 매개 변수 중 하나를 수정하거나 실패 대역을 리턴 할 때 ( &quot;음수 리턴 값은 실패&quot;와 같이) 인터페이스가 C와 매우 유사하고 때로는 직관적이지 않은 경우가 있습니다. 프로그래머가 더 Perl과 유사한 인터페이스를 작성하려는 경우 다음 전략이 인터페이스의 더 중요한 부분을 식별하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a3b14a33a7328d3c4446b4818b46b0e10681a93" translate="yes" xml:space="preserve">
          <source>When developing interactive and/or potentially long-running applications, it's a good idea to maintain a persistent interpreter rather than allocating and constructing a new interpreter multiple times. The major reason is speed: since Perl will only be loaded into memory once.</source>
          <target state="translated">대화 형 및 / 또는 장기 실행 가능한 응용 프로그램을 개발할 때는 새로운 통역사를 여러 번 할당하고 구성하는 대신 지속적인 통역사를 유지하는 것이 좋습니다. 가장 큰 이유는 속도입니다. Perl은 한 번만 메모리에로드되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="bf6878bf07602f9398e0aebf78788b970eee0437" translate="yes" xml:space="preserve">
          <source>When doing XS / Symbian C++ programming include first the Symbian headers, then any standard C/POSIX headers, then Perl headers, and finally any application headers.</source>
          <target state="translated">XS / Symbian C ++ 프로그래밍을 수행 할 때는 먼저 Symbian 헤더, 표준 C / POSIX 헤더, Perl 헤더 및 마지막으로 모든 애플리케이션 헤더가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="68e541a18f2f1ca2cdf86c535b1f959438918ee4" translate="yes" xml:space="preserve">
          <source>When downloading from CPAN, save your file with a &lt;code&gt;.tgz&lt;/code&gt; extension instead of &lt;code&gt;.tar.gz&lt;/code&gt;. All other periods in the filename should be replaced with underscores. For example, &lt;code&gt;Your-Module-1.33.tar.gz&lt;/code&gt; should be downloaded as &lt;code&gt;Your-Module-1_33.tgz&lt;/code&gt;.</source>
          <target state="translated">CPAN에서 다운로드 할 때 파일 을 &lt;code&gt;.tar.gz&lt;/code&gt; 대신 &lt;code&gt;.tgz&lt;/code&gt; 확장자로 저장하십시오 . 파일 이름의 다른 모든 마침표는 밑줄로 바꿔야합니다. 예를 들어, &lt;code&gt;Your-Module-1.33.tar.gz&lt;/code&gt; 로 다운로드해야합니다 &lt;code&gt;Your-Module-1_33.tgz&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a4bca7ef82b244e2bfab60f9ed2d006dc99b5fe" translate="yes" xml:space="preserve">
          <source>When each filter is called by Perl, a local copy of &lt;code&gt;$_&lt;/code&gt; will contain the key or value to be filtered. Filtering is achieved by modifying the contents of &lt;code&gt;$_&lt;/code&gt; . The return code from the filter is ignored.</source>
          <target state="translated">Perl이 각 필터를 호출하면 &lt;code&gt;$_&lt;/code&gt; 의 로컬 사본에 필터링 할 키 또는 값이 포함됩니다. 필터링은 &lt;code&gt;$_&lt;/code&gt; 의 내용을 수정하여 수행됩니다 . 필터의 리턴 코드는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d0a0c84572d5c8f36ddeeedc2b34034d9368a3d3" translate="yes" xml:space="preserve">
          <source>When embedded code is quantified, successful matches will call the code once for each matched iteration of the quantifier. For example:</source>
          <target state="translated">임베드 된 코드가 수량화되면, 성공적인 일치는 수량 자의 각 일치 반복마다 코드를 한 번 호출합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b2de387631853c970d098f700c90774516567311" translate="yes" xml:space="preserve">
          <source>When evaluated, the typeglob produces a scalar value that represents all the objects of that name, including any filehandle, format, or subroutine. When assigned to, it causes the name mentioned to refer to whatever &lt;code&gt;*&lt;/code&gt; value was assigned to it. Example:</source>
          <target state="translated">평가할 때 typeglob는 파일 핸들, 형식 또는 서브 루틴을 포함하여 해당 이름의 모든 오브젝트를 나타내는 스칼라 값을 생성합니다. 할당되면 언급 된 이름이 &lt;code&gt;*&lt;/code&gt; 값이 할당 된 것을 가리 킵니다 . 예:</target>
        </trans-unit>
        <trans-unit id="4c69b020552d0b8ae9319c611f51330e0fd5df99" translate="yes" xml:space="preserve">
          <source>When exec() is called inside a pseudo-process then DESTROY methods and END blocks will still be called after the external process returns.</source>
          <target state="translated">의사 프로세스 내에서 exec ()를 호출하면 외부 프로세스가 리턴 된 후에도 DESTROY 메소드 및 END 블록이 계속 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="8c7eebc997f4f93f028327a4f1ff0c0608dc29e2" translate="yes" xml:space="preserve">
          <source>When execution of the program reaches a subroutine call, a call to &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; (</source>
          <target state="translated">프로그램 실행이 서브 루틴 호출에 도달하면 &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; (</target>
        </trans-unit>
        <trans-unit id="1b8b87da2107f5f6b07c4ad0b8f0c3bd9b3e2787" translate="yes" xml:space="preserve">
          <source>When execution of the program uses &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; to enter a non-XS subroutine and the 0x80 bit is set in &lt;code&gt;$^P&lt;/code&gt; , a call to &lt;code&gt;&amp;amp;DB::goto&lt;/code&gt; is made, with &lt;code&gt;$DB::sub&lt;/code&gt; holding the name of the subroutine being entered.</source>
          <target state="translated">프로그램 실행에서 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 를 사용하여 비 XS 서브 루틴을 입력하고 0x80 비트가 &lt;code&gt;$^P&lt;/code&gt; 설정 되면 &lt;code&gt;$DB::sub&lt;/code&gt; 가 입력 된 서브 루틴의 이름을 보유하면서 &lt;code&gt;&amp;amp;DB::goto&lt;/code&gt; 가 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="a7780be4ab5e34307ca9834bebf3c5ea11f2bda2" translate="yes" xml:space="preserve">
          <source>When exitcode is non-zero, a message box appears, otherwise the console closes, so you might have to catch an exit with status 0 in your program to see any output.</source>
          <target state="translated">종료 코드가 0이 아니면 메시지 상자가 나타나고 그렇지 않으면 콘솔이 닫히므로 출력을 보려면 프로그램에서 상태 0의 종료를 잡아야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b361c8c46cd947899ffa296e187a289b54d8046a" translate="yes" xml:space="preserve">
          <source>When field hashes are used, the basic structure remains the same. Each lexical hash will be made a field hash. The call to &lt;code&gt;refaddr&lt;/code&gt; can be omitted from the accessor methods. DESTROY and CLONE methods are not necessary.</source>
          <target state="translated">필드 해시를 사용하는 경우 기본 구조는 동일하게 유지됩니다. 각 어휘 해시는 필드 해시가됩니다. 접근 자 메소드에서 &lt;code&gt;refaddr&lt;/code&gt; 에 대한 호출을 생략 할 수 있습니다. DESTROY 및 CLONE 메소드는 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7ff1c534eb53fb9adf1f1f7cdd902bdbfec52451" translate="yes" xml:space="preserve">
          <source>When finding a program to run, Perl first asks the OS to look for executables on &lt;code&gt;PATH&lt;/code&gt; (OS/2 adds extension</source>
          <target state="translated">실행할 프로그램을 찾을 때 Perl은 먼저 &lt;code&gt;PATH&lt;/code&gt; 에서 실행 파일을 찾도록 OS에 요청합니다 (OS / 2는 확장을 추가합니다)</target>
        </trans-unit>
        <trans-unit id="13a2688e14421cbafe067aeaa351f65e3474e11f" translate="yes" xml:space="preserve">
          <source>When finished, &lt;code&gt;$input&lt;/code&gt; will be completely processed (assuming there were no errors). If the deflation was successful it writes the deflated data to &lt;code&gt;$output&lt;/code&gt; and returns a status value of &lt;code&gt;Z_OK&lt;/code&gt; .</source>
          <target state="translated">완료되면 &lt;code&gt;$input&lt;/code&gt; 이 완전히 처리됩니다 (오류가 없다고 가정). 수축이 성공하면 수축 된 데이터를 &lt;code&gt;$output&lt;/code&gt; 쓰고 상태 값 &lt;code&gt;Z_OK&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3d09ef2037aaa8553df4a9d1d56e3501c5f5a619" translate="yes" xml:space="preserve">
          <source>When followed by a BLOCK, &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; is actually a flow control statement rather than a function. If there is a &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; BLOCK attached to a BLOCK (typically in a &lt;code&gt;while&lt;/code&gt; or &lt;code&gt;foreach&lt;/code&gt; ), it is always executed just before the conditional is about to be evaluated again, just like the third part of a &lt;code&gt;for&lt;/code&gt; loop in C. Thus it can be used to increment a loop variable, even when the loop has been continued via the &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; statement (which is similar to the C &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; statement).</source>
          <target state="translated">BLOCK이 뒤 따르면 &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 는 실제로 함수가 아닌 플로우 제어 명령문입니다. BLOCK에 &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; BLOCK이 첨부 된 경우 (일반적으로 &lt;code&gt;while&lt;/code&gt; 또는 &lt;code&gt;foreach&lt;/code&gt; ), C 의 &lt;code&gt;for&lt;/code&gt; 루프 의 세 번째 부분과 같이 조건부가 다시 평가되기 직전에 항상 실행 됩니다. 루프가 &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 명령문 (C &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 문과 유사 함)을 통해 계속 된 경우에도 루프 변수를 증가시키는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2cd67d2b65a87b65d002d9fa075eef11fc3372a5" translate="yes" xml:space="preserve">
          <source>When followed by a BLOCK, &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; is actually a flow control statement rather than a function. If there is a &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; BLOCK attached to a BLOCK (typically in a &lt;code&gt;while&lt;/code&gt; or &lt;code&gt;foreach&lt;/code&gt; ), it is always executed just before the conditional is about to be evaluated again, just like the third part of a &lt;code&gt;for&lt;/code&gt; loop in C. Thus it can be used to increment a loop variable, even when the loop has been continued via the &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; statement (which is similar to the C &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; statement).</source>
          <target state="translated">BLOCK이 뒤 따르면 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 는 실제로 함수가 아닌 플로우 제어 명령문입니다. BLOCK에 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; BLOCK이 첨부 된 경우 (일반적으로 &lt;code&gt;while&lt;/code&gt; 또는 &lt;code&gt;foreach&lt;/code&gt; ), C 의 &lt;code&gt;for&lt;/code&gt; 루프 의 세 번째 부분과 같이 조건부가 다시 평가되기 직전에 항상 실행 됩니다. 루프가 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 명령문 (C &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 문과 유사 함)을 통해 계속 된 경우에도 루프 변수를 증가시키는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="aa8159a0d83694276288a2a5fe07fe61d16edc97" translate="yes" xml:space="preserve">
          <source>When functions within an XS source file must be separated into packages the PACKAGE keyword should be used. This keyword is used with the MODULE keyword and must follow immediately after it when used.</source>
          <target state="translated">XS 소스 파일 내의 함수를 패키지로 분리해야하는 경우 PACKAGE 키워드를 사용해야합니다. 이 키워드는 MODULE 키워드와 함께 사용되며 사용될 때 바로 뒤에 와야합니다.</target>
        </trans-unit>
        <trans-unit id="c6f577a0659ee785a75d16bfb954974346b28a9b" translate="yes" xml:space="preserve">
          <source>When given an ambiguous local time, the timelocal() function should always return the epoch for the</source>
          <target state="translated">현지 시간이 모호한 경우 timelocal () 함수는 항상 에포크를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="905210e566be8553d344f14d5ca8c62a30b6a0a2" translate="yes" xml:space="preserve">
          <source>When handling output parameters with a PPCODE section, be sure to handle 'set' magic properly. See &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; for details about 'set' magic.</source>
          <target state="translated">PPCODE 섹션으로 출력 매개 변수를 처리 할 때 'set'마술을 올바르게 처리하십시오. 'set'마술에 대한 자세한 내용은 &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="76666973f161e896d15ace4d3f87a7a9c3ef5759" translate="yes" xml:space="preserve">
          <source>When in doubt, parenthesize. At the very least it will let some poor schmuck bounce on the % key in &lt;b&gt;vi&lt;/b&gt;.</source>
          <target state="translated">의심스러운 경우 괄호로 묶습니다. 최소한 &lt;b&gt;vi&lt;/b&gt; 의 % 키에서 일부 빈약 한 schmuck이 바운스되도록 할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="b4688043e9a06a71613858ea73f001a633497cb7" translate="yes" xml:space="preserve">
          <source>When in doubt, run the &lt;b&gt;awk&lt;/b&gt; construct through &lt;b&gt;a2p&lt;/b&gt; and see what it gives you.</source>
          <target state="translated">확실치 않은 경우 &lt;b&gt;a2p를&lt;/b&gt; 통해 &lt;b&gt;awk&lt;/b&gt; 구문을 실행하고 그것이 무엇을 제공하는지 확인하십시오.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0c9ab777cdba3a81e6f12be90b090ea8b365cf98" translate="yes" xml:space="preserve">
          <source>When in doubt, you can use</source>
          <target state="translated">의심스러운 경우 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="6948014018e5357f830915cd0ed311117487ecb2" translate="yes" xml:space="preserve">
          <source>When invoked as &lt;code&gt;`perl -MExtUtils::Embed -e ldopts --`&lt;/code&gt; the following options are recognized:</source>
          <target state="translated">&lt;code&gt;`perl -MExtUtils::Embed -e ldopts --`&lt;/code&gt; 로 호출되면 다음 옵션이 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="cc36b4e11ce2156b2b41d828826a07de94fcec39" translate="yes" xml:space="preserve">
          <source>When invoked as &lt;code&gt;`perl -MExtUtils::Embed -e xsinit --`&lt;/code&gt; the following options are recognized:</source>
          <target state="translated">&lt;code&gt;`perl -MExtUtils::Embed -e xsinit --`&lt;/code&gt; 로 호출되면 다음 옵션이 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="ee150951d5eb2b6fd45fd97edec569546ed48f9b" translate="yes" xml:space="preserve">
          <source>When invoked using a single string, &lt;b&gt;parseopts&lt;/b&gt; treats the string as the name of a parse-option and returns its corresponding value if it exists (returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if it doesn't).</source>
          <target state="translated">단일 문자열을 사용하여 호출하면 &lt;b&gt;parseopts&lt;/b&gt; 는 문자열을 구문 분석 옵션의 이름으로 취급하고 해당하는 경우 해당 값을 반환합니다 ( 없는 경우 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환 ).</target>
        </trans-unit>
        <trans-unit id="7277cd46617f74f2842ee4af54a1d49db21e598b" translate="yes" xml:space="preserve">
          <source>When invoked with multiple arguments, &lt;b&gt;parseopts&lt;/b&gt; treats them as key/value pairs and the specified parse-option names are set to the given values. Any unspecified parse-options are unaffected.</source>
          <target state="translated">여러 인수로 호출하면 &lt;b&gt;parseopts&lt;/b&gt; 는이를 인수 를 키 / 값 쌍으로 취급하고 지정된 구문 분석 옵션 이름이 지정된 값으로 설정됩니다. 지정되지 않은 구문 분석 옵션은 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f1033de63c389a24f6517627a4b9b4657247752f" translate="yes" xml:space="preserve">
          <source>When invoked with no additional arguments, &lt;b&gt;parseopts&lt;/b&gt; returns a hashtable of all the current parsing options.</source>
          <target state="translated">추가 인수없이 호출하면 &lt;b&gt;parseopts&lt;/b&gt; 는 모든 현재 구문 분석 옵션의 해시 테이블을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8a84fb9fbc48134e4aa29a0c0010fa21ec733eeb" translate="yes" xml:space="preserve">
          <source>When invoked with parameters the following are accepted and optional:</source>
          <target state="translated">매개 변수와 함께 호출되면 다음이 승인되고 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="3db92287943a254b1a1b0d74b4c460a69a45306e" translate="yes" xml:space="preserve">
          <source>When is a bool not a bool?</source>
          <target state="translated">부울은 언제 부울이 아닌가?</target>
        </trans-unit>
        <trans-unit id="7b77a4a5d5b65846fa5a3f0440157e545f392596" translate="yes" xml:space="preserve">
          <source>When it appears singly, it causes the sequences &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt;, &lt;code&gt;\w&lt;/code&gt; , and the Posix character classes to match only in the ASCII range. They thus revert to their pre-5.6, pre-Unicode meanings. Under &lt;code&gt;/a&lt;/code&gt; , &lt;code&gt;\d&lt;/code&gt; always means precisely the digits &lt;code&gt;&quot;0&quot;&lt;/code&gt; to &lt;code&gt;&quot;9&quot;&lt;/code&gt; ; &lt;code&gt;\s&lt;/code&gt; means the five characters &lt;code&gt;[ \f\n\r\t]&lt;/code&gt; , and starting in Perl v5.18, the vertical tab; &lt;code&gt;\w&lt;/code&gt; means the 63 characters &lt;code&gt;[A-Za-z0-9_]&lt;/code&gt; ; and likewise, all the Posix classes such as &lt;code&gt;[[:print:]]&lt;/code&gt; match only the appropriate ASCII-range characters.</source>
          <target state="translated">단독으로 나타나면 시퀀스 &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; 및 Posix 문자 클래스가 ASCII 범위에서만 일치합니다. 따라서 그들은 5.6 이전의 유니 코드 이전의 의미로 되돌아갑니다. &lt;code&gt;/a&lt;/code&gt; 아래 에서 &lt;code&gt;\d&lt;/code&gt; 항상 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 부터 &lt;code&gt;&quot;9&quot;&lt;/code&gt; 까지 의 숫자를 정확하게 의미합니다 . &lt;code&gt;\s&lt;/code&gt; 는 다섯 개의 문자 &lt;code&gt;[ \f\n\r\t]&lt;/code&gt; 를 의미하며 세로 탭 Perl v5.18에서 시작합니다. &lt;code&gt;\w&lt;/code&gt; 는 63자를 의미합니다 &lt;code&gt;[A-Za-z0-9_]&lt;/code&gt; ; 마찬가지로 &lt;code&gt;[[:print:]]&lt;/code&gt; 와 같은 모든 Posix 클래스 는 적절한 ASCII 범위 문자 만 일치합니다.</target>
        </trans-unit>
        <trans-unit id="ae018fd8a3823b08fc79c33ba2f6c60484d5a434" translate="yes" xml:space="preserve">
          <source>When it comes to time-space tradeoffs, Perl nearly always prefers to throw memory at a problem. Scalars in Perl use more memory than strings in C, arrays take more than that, and hashes use even more. While there's still a lot to be done, recent releases have been addressing these issues. For example, as of 5.004, duplicate hash keys are shared amongst all hashes using them, so require no reallocation.</source>
          <target state="translated">시공간 트레이드 오프와 관련하여 Perl은 거의 항상 문제가 발생했을 때 메모리를 버리는 것을 선호합니다. Perl의 스칼라는 C의 문자열보다 많은 메모리를 사용하고 배열은 그 이상을 사용하며 해시는 훨씬 더 많이 사용합니다. 아직해야 할 일이 많지만 최근 릴리스에서는 이러한 문제가 해결되었습니다. 예를 들어 5.004부터 중복 해시 키는이를 사용하는 모든 해시간에 공유되므로 재 할당 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e21264012009a4f52f16ff3209c2f52a03a6b032" translate="yes" xml:space="preserve">
          <source>When it comes to undefined variables that would trigger a warning under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; , you can promote the warning to an error.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 에서 경고를 트리거하는 정의되지 않은 변수에 대해서는 경고를 오류로 승격시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea78a63efa4e07bcbad222b4b53d8108119efd5b" translate="yes" xml:space="preserve">
          <source>When it converges, you got a functional variant of</source>
          <target state="translated">수렴하면 다음과 같은 기능적 변형이 생깁니다.</target>
        </trans-unit>
        <trans-unit id="079267d57082e05e5aa6528a39e11837b4f6a244" translate="yes" xml:space="preserve">
          <source>When it starts, the debugger reads your rc file (</source>
          <target state="translated">시작되면 디버거는 rc 파일을 읽습니다 (</target>
        </trans-unit>
        <trans-unit id="f1e1e6def162fe17764cc69d6d5531c8389ffa63" translate="yes" xml:space="preserve">
          <source>When items collide into a given hash bucket the order they are stored in the chain is no longer predictable in Perl 5.18. This has the intention to make it harder to observe a collision. This behavior can be overridden by using the PERL_PERTURB_KEYS environment variable, see &lt;a href=&quot;perlrun#PERL_PERTURB_KEYS&quot;&gt;PERL_PERTURB_KEYS in perlrun&lt;/a&gt;.</source>
          <target state="translated">항목이 지정된 해시 버킷에 충돌하면 체인에 저장된 순서를 Perl 5.18에서 더 이상 예측할 수 없습니다. 이것은 충돌을 관찰하기 어렵게하는 의도가있다. PERL_PERTURB_KEYS 환경 변수를 사용하여이 동작을 무시할 수 있습니다 . &lt;a href=&quot;perlrun#PERL_PERTURB_KEYS&quot;&gt;perlrun의 PERL_PERTURB_KEYS를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="65043d3a1d3f5988941ccbcf07e25510773d1e57" translate="yes" xml:space="preserve">
          <source>When loading &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt;, you must &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; before you &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads::shared&lt;/code&gt; . (&lt;code&gt;threads&lt;/code&gt; will emit a warning if you do it the other way around.)</source>
          <target state="translated">로딩 할 때 &lt;a href=&quot;threads/shared&quot;&gt;스레드가 :: 공유&lt;/a&gt; , 당신은해야한다 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; 당신이 전에 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads::shared&lt;/code&gt; . ( 다른 방법으로 &lt;code&gt;threads&lt;/code&gt; 를 수행하면 스레드 에서 경고가 발생합니다.)</target>
        </trans-unit>
        <trans-unit id="4d97ad32fbcc62b0394446ba4a901eea150b590d" translate="yes" xml:space="preserve">
          <source>When looking for &lt;code&gt;DBD::Oracle&lt;/code&gt; relative to a search path, we should find</source>
          <target state="translated">를 찾을 때 &lt;code&gt;DBD::Oracle&lt;/code&gt; 검색 경로를 기준으로, 우리는 찾아야한다</target>
        </trans-unit>
        <trans-unit id="d1306624a66d42061de8cb1de14bb165b2e9253e" translate="yes" xml:space="preserve">
          <source>When naming your module, consider the following:</source>
          <target state="translated">모듈 이름을 지정할 때 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="a2f6fa234dea48f4123a74cda1902ae1a1335eb2" translate="yes" xml:space="preserve">
          <source>When no destination is specified for an option, GetOptions will store the resultant value in a global variable named &lt;code&gt;opt_&lt;/code&gt;</source>
          <target state="translated">옵션에 대상을 지정하지 않으면 GetOptions는 결과 값을 &lt;code&gt;opt_&lt;/code&gt; 라는 전역 변수에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="d995d17f45ad38c16e65d9df03d9013a6e8bd451" translate="yes" xml:space="preserve">
          <source>When non-&lt;code&gt;NULL&lt;/code&gt; , the function pointed by this variable will be called each time an OP is freed with the corresponding OP as the argument. This allows extensions to free any extra attribute they have locally attached to an OP. It is also assured to first fire for the parent OP and then for its kids.</source>
          <target state="translated">&lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우이 변수가 가리키는 함수는 해당 OP를 인수로 사용하여 OP를 해제 할 때마다 호출됩니다. 이를 통해 확장은 OP에 로컬로 연결된 추가 속성을 해제 할 수 있습니다. 또한 먼저 부모 OP와 그 이후의 아이들을 위해 해고해야합니다.</target>
        </trans-unit>
        <trans-unit id="fda14717d0ef780a84b7072c8af4b8c2a6e41355" translate="yes" xml:space="preserve">
          <source>When non-zero this options will make bzip2 use a decompression algorithm that uses less memory at the expense of increasing the amount of time taken for decompression.</source>
          <target state="translated">0이 아닌 경우이 옵션을 사용하면 bzip2는 압축 해제에 걸리는 시간을 늘리는 대신 메모리를 적게 사용하는 압축 해제 알고리즘을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="53e144afe4dd441bf4ca7ad26c550e29a83fc4df" translate="yes" xml:space="preserve">
          <source>When open() is given an explicit list of layers (with the three-arg syntax), they override the list declared using this pragma. open() can also be given a single colon (:) for a layer name, to override this pragma and use the default (&lt;code&gt;:raw&lt;/code&gt; on Unix, &lt;code&gt;:crlf&lt;/code&gt; on Windows).</source>
          <target state="translated">open ()에 명시적인 레이어 목록 (3 개 인수 구문 사용)이 제공되면이 pragma를 사용하여 선언 된 목록을 재정의합니다. 레이어 이름에 대해 open ()에 단일 콜론 (:)을 부여하여이 pragma를 재정의하고 기본값 ( &lt;code&gt;:raw&lt;/code&gt; , Windows의 경우 &lt;code&gt;:crlf&lt;/code&gt; )을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea26acaec78382fd2c97d3e0f9466f873120022e" translate="yes" xml:space="preserve">
          <source>When opened for writing, empty parts of the file will have NULL (0x00) bytes written to them.</source>
          <target state="translated">쓰기 위해 열면 파일의 빈 부분에 NULL (0x00) 바이트가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="4a6b9011509d11da3fcfb04f15c06a413aa28bf6" translate="yes" xml:space="preserve">
          <source>When opening a file, it's seldom a good idea to continue if the request failed, so &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; is frequently used with &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. Even if &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; won't do what you want (say, in a CGI script, where you want to format a suitable error message (but there are modules that can help with that problem)) always check the return value from opening a file.</source>
          <target state="translated">파일을 열 때 요청이 실패한 경우 계속하지 않는 것이 좋습니다. 따라서 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 은 종종 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 와 함께 사용됩니다 . &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 가 원하는 작업을 수행하지 않더라도 (예를 들어 CGI 스크립트에서 적절한 오류 메시지를 형식화하려는 경우 (그러나 해당 문제를 해결할 수있는 모듈이있는 경우)) 항상 파일 열기에서 반환 값을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="713d157f79aa607cdf5ba0f3803c5ba5ac49d060" translate="yes" xml:space="preserve">
          <source>When opening a file, it's seldom a good idea to continue if the request failed, so &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; is frequently used with &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. Even if &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; won't do what you want (say, in a CGI script, where you want to format a suitable error message (but there are modules that can help with that problem)) always check the return value from opening a file.</source>
          <target state="translated">파일을 열 때 요청이 실패한 경우 계속하지 않는 것이 좋습니다. 따라서 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 은 종종 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 와 함께 사용됩니다 . &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 가 원하는 작업을 수행하지 않더라도 (예를 들어 CGI 스크립트에서 적절한 오류 메시지를 형식화하려는 경우 (그러나 해당 문제를 해결할 수있는 모듈이있는 경우)) 항상 파일 열기에서 반환 값을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="136d8820f5385aeb92b2b0d8596ed06c40a27f32" translate="yes" xml:space="preserve">
          <source>When passed a single hash-ref, &lt;b&gt;parseopts&lt;/b&gt; uses that hash to completely reset the existing parse-options, all previous parse-option values are lost.</source>
          <target state="translated">단일 해시 참조를 전달하면 &lt;b&gt;parseopts&lt;/b&gt; 는 해당 해시를 사용하여 기존 구문 분석 옵션을 완전히 재설정하면 모든 이전 구문 분석 옵션 값이 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="47b91ab5f28f979fd8b5568f2d0f9b2f727e616c" translate="yes" xml:space="preserve">
          <source>When perl begins to parse any block construct that provides a lexical scope (e.g., eval body, required file, subroutine body, loop body, or conditional block), the existing value of &lt;code&gt;$^H&lt;/code&gt; is saved, but its value is left unchanged. When the compilation of the block is completed, it regains the saved value. Between the points where its value is saved and restored, code that executes within BEGIN blocks is free to change the value of &lt;code&gt;$^H&lt;/code&gt; .</source>
          <target state="translated">perl이 어휘 범위 (예 : 평가 본문, 필수 파일, 서브 루틴 본문, 루프 본문 또는 조건부 블록)를 제공하는 블록 구성을 구문 분석하기 시작하면 &lt;code&gt;$^H&lt;/code&gt; 의 기존 값 이 저장되지만 값은 변경되지 않습니다. 블록 컴파일이 완료되면 저장된 값을 다시 얻습니다. 값이 저장 및 복원되는 지점 사이에서 BEGIN 블록 내에서 실행되는 코드는 &lt;code&gt;$^H&lt;/code&gt; 값을 자유롭게 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8e10e03e69e1ff5f3a594f297790818dcb4b2f72" translate="yes" xml:space="preserve">
          <source>When perl executes something like &lt;code&gt;addop&lt;/code&gt; , how does it pass on its results to the next op? The answer is, through the use of stacks. Perl has a number of stacks to store things it's currently working on, and we'll look at the three most important ones here.</source>
          <target state="translated">펄이 &lt;code&gt;addop&lt;/code&gt; 과 같은 것을 실행하면 결과가 다음 연산에 어떻게 전달됩니까? 답은 스택을 사용하는 것입니다. 펄은 현재 작업중인 것들을 저장할 수있는 스택을 가지고 있으며 여기서 가장 중요한 3 가지를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="b736497c10b0a6402c79bf644d3d7290bca7e8df" translate="yes" xml:space="preserve">
          <source>When perl executes the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; expression, it translates the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;PIPE&amp;gt;&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; calls in the C run-time library and thence to the operating system kernel. perl sets &lt;code&gt;$!&lt;/code&gt; to the C library's &lt;code&gt;errno&lt;/code&gt; if one of these calls fails.</source>
          <target state="translated">perl이 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 표현식을 실행하면 C 런타임 라이브러리 에서 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;PIPE&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 호출을 변환 한 다음 운영 체제 커널로 변환합니다. 펄은 &lt;code&gt;$!&lt;/code&gt; 이러한 호출 중 하나가 실패하면 C 라이브러리의 &lt;code&gt;errno&lt;/code&gt; 에 .</target>
        </trans-unit>
        <trans-unit id="c23db1f0df62364b5b67f120eb77a3d581033b3c" translate="yes" xml:space="preserve">
          <source>When perl is compiled with support for memory footprint debugging (default with Perl's malloc()), Devel::Peek provides an access to this API.</source>
          <target state="translated">Perl이 메모리 풋 프린트 디버깅을 지원하도록 컴파일 될 때 (기본값은 Perl의 malloc ()) Devel :: Peek는이 API에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="215e17f5873c9b21cb203952a3ef2363b112bec3" translate="yes" xml:space="preserve">
          <source>When perl is configured to use ithreads, it will use re-entrant library calls in preference to non-re-entrant versions. There is a bug in FreeBSD's &lt;code&gt;readdir_r&lt;/code&gt; function in versions 4.5 and earlier that can cause a SEGV when reading large directories. A patch for FreeBSD libc is available (see &lt;a href=&quot;http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631&quot;&gt;http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631&lt;/a&gt; ) which has been integrated into FreeBSD 4.6.</source>
          <target state="translated">perl이 ithread를 사용하도록 구성되면 재진입이 아닌 버전보다 재진입 라이브러리 호출을 사용합니다. 4.5 이전 버전 의 FreeBSD의 &lt;code&gt;readdir_r&lt;/code&gt; 함수에는 큰 디렉토리를 읽을 때 SEGV를 유발할 수 있는 버그 가 있습니다. FreeBSD 4.6에 통합 된 FreeBSD libc 용 패치가 있습니다 ( &lt;a href=&quot;http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631&quot;&gt;http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="09323de6d789f44fb18ba022fc8c8c24e89843b3" translate="yes" xml:space="preserve">
          <source>When present this option will limit the number of compressed bytes read from the input file/buffer to &lt;code&gt;$size&lt;/code&gt; . This option can be used in the situation where there is useful data directly after the compressed data stream and you know beforehand the exact length of the compressed data stream.</source>
          <target state="translated">이 옵션이 있으면 입력 파일 / 버퍼에서 읽은 압축 바이트 수가 &lt;code&gt;$size&lt;/code&gt; 됩니다. 이 옵션은 압축 된 데이터 스트림 바로 뒤에 유용한 데이터가 있고 압축 된 데이터 스트림의 정확한 길이를 미리 알고있는 상황에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ede0a2d2bf6a5a00a9412db1d402428ce441463" translate="yes" xml:space="preserve">
          <source>When presented with something that might have several different interpretations, Perl uses the &lt;b&gt;DWIM&lt;/b&gt; (that's &quot;Do What I Mean&quot;) principle to pick the most probable interpretation. This strategy is so successful that Perl programmers often do not suspect the ambivalence of what they write. But from time to time, Perl's notions differ substantially from what the author honestly meant.</source>
          <target state="translated">여러 가지 다른 해석이있을 수있는 무언가가 제시 될 때 Perl은 &lt;b&gt;DWIM&lt;/b&gt; ( &quot;무엇을 의미합니까?&quot;) 원칙을 사용하여 가장 가능성있는 해석을 선택합니다. 이 전략은 매우 성공하여 Perl 프로그래머는 종종 자신이 쓴 내용의 모호성을 의심하지 않습니다. 그러나 때때로 Perl의 개념은 저자가 정직하게 의미 한 것과 크게 다릅니다.</target>
        </trans-unit>
        <trans-unit id="3ad187dab51002d9f1db84c4af0c7454d06b80be" translate="yes" xml:space="preserve">
          <source>When printed, a complex number is usually shown under its cartesian style</source>
          <target state="translated">인쇄시 복소수는 일반적으로 직교 스타일로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5caa7cd7539097bbbb349ec1e585b2c803d154a7" translate="yes" xml:space="preserve">
          <source>When prompted, pick a subject that summarizes your changes.</source>
          <target state="translated">메시지가 표시되면 변경 사항을 요약 한 주제를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="0c308dc95015b79380949643660ba2048891c6cf" translate="yes" xml:space="preserve">
          <source>When putting items into &lt;code&gt;%^H&lt;/code&gt; , in order to avoid conflicting with other users of the hash there is a convention regarding which keys to use. A module should use only keys that begin with the module's name (the name of its main package) and a &quot;/&quot; character. For example, a module &lt;code&gt;Foo::Bar&lt;/code&gt; should use keys such as &lt;code&gt;Foo::Bar/baz&lt;/code&gt; .</source>
          <target state="translated">항목을 &lt;code&gt;%^H&lt;/code&gt; 넣을 때 다른 해시 사용자와의 충돌을 피하기 위해 사용할 키에 관한 규칙이 있습니다. 모듈은 모듈 이름 (기본 패키지 이름)과 &quot;/&quot;문자로 시작하는 키만 사용해야합니다. 예를 들어, &lt;code&gt;Foo::Bar&lt;/code&gt; 모듈 은 &lt;code&gt;Foo::Bar/baz&lt;/code&gt; 와 같은 키를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="97c16015d247b91d71c9d2f79344302034231eb3" translate="yes" xml:space="preserve">
          <source>When reading from a file or filehandle, set &lt;code&gt;&lt;a href=&quot;../../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; before reading.</source>
          <target state="translated">파일 또는 파일 핸들에서 읽을 때는 읽기 전에 &lt;code&gt;&lt;a href=&quot;../../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 를 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="f0130766d53ae0779f7ffce6dac2883bf210c349" translate="yes" xml:space="preserve">
          <source>When reading from a socket, remember that the default input record separator &lt;code&gt;$/&lt;/code&gt; is &lt;code&gt;\n&lt;/code&gt; , but robust socket code will recognize as either &lt;code&gt;\012&lt;/code&gt; or &lt;code&gt;\015\012&lt;/code&gt; as end of line:</source>
          <target state="translated">소켓에서 읽을 때 기본 입력 레코드 구분 기호 &lt;code&gt;$/&lt;/code&gt; 는 &lt;code&gt;\n&lt;/code&gt; 이지만 강력한 소켓 코드는 줄 끝으로 &lt;code&gt;\012&lt;/code&gt; 또는 &lt;code&gt;\015\012&lt;/code&gt; 로 인식됩니다 .</target>
        </trans-unit>
        <trans-unit id="ff12069c161fb8190739473ed34f724f30594524" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::AnyInflate will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">압축 된 입력 데이터를 읽을 때 IO :: Uncompress :: AnyInflate는 &lt;code&gt;$num&lt;/code&gt; 바이트 단위로 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="16d4e8c4e7b7384f70b2f1766cc139537265740d" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::AnyUncompress will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">압축 된 입력 데이터를 읽을 때 IO :: Uncompress :: AnyUncompress는 &lt;code&gt;$num&lt;/code&gt; 바이트 단위로 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="32ca9aeb1f06332449d6eb9320261dff0e66b312" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::Bunzip2 will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">압축 된 입력 데이터를 읽을 때 IO :: Uncompress :: Bunzip2는 &lt;code&gt;$num&lt;/code&gt; 바이트 단위로 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="50715bb3c754686d721e8aea919c37db141e1994" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::Gunzip will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">압축 된 입력 데이터를 읽을 때 IO :: Uncompress :: Gunzip은 &lt;code&gt;$num&lt;/code&gt; 바이트 단위로 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="59f000056402b83ac85f2986c043bbc1a33d0339" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::Inflate will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">압축 된 입력 데이터를 읽을 때 IO :: Uncompress :: Inflate는 &lt;code&gt;$num&lt;/code&gt; 바이트 단위로 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="07686b740fde1338aeadfd29d15b206d9e710502" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::RawInflate will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">압축 된 입력 데이터를 읽을 때 IO :: Uncompress :: RawInflate는 &lt;code&gt;$num&lt;/code&gt; 바이트 단위로 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="f6933aca30493bfe2ae64d115f3d25c9d4614976" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::Unzip will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">압축 된 입력 데이터를 읽을 때 IO :: Uncompress :: Unzip은 &lt;code&gt;$num&lt;/code&gt; 바이트 단위로 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="4d74245b43f70a678ebe3b1f9167c1e1ba7b4408" translate="yes" xml:space="preserve">
          <source>When referenced, &lt;code&gt;$!&lt;/code&gt; retrieves the current value of the C &lt;code&gt;errno&lt;/code&gt; integer variable. If &lt;code&gt;$!&lt;/code&gt; is assigned a numerical value, that value is stored in &lt;code&gt;errno&lt;/code&gt; . When referenced as a string, &lt;code&gt;$!&lt;/code&gt; yields the system error string corresponding to &lt;code&gt;errno&lt;/code&gt; .</source>
          <target state="translated">참조하면 &lt;code&gt;$!&lt;/code&gt; C &lt;code&gt;errno&lt;/code&gt; 정수 변수 의 현재 값을 검색합니다 . 만약 &lt;code&gt;$!&lt;/code&gt; 숫자 값이 지정되면 해당 값은 &lt;code&gt;errno&lt;/code&gt; 에 저장됩니다 . 문자열로 참조 될 때 &lt;code&gt;$!&lt;/code&gt; &lt;code&gt;errno&lt;/code&gt; 에 해당하는 시스템 오류 문자열을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="27e9bf02eb38760deb66646d65b7d40e7944e879" translate="yes" xml:space="preserve">
          <source>When referring to characters by using a E&amp;lt;n&amp;gt; numeric code, numbers in the range 32-126 refer to those well known US-ASCII characters (also defined there by Unicode, with the same meaning), which all Pod formatters must render faithfully. Characters whose E&amp;lt;&amp;gt; numbers are in the ranges 0-31 and 127-159 should not be used (neither as literals, nor as E&amp;lt;number&amp;gt; codes), except for the literal byte-sequences for newline (ASCII 13, ASCII 13 10, or ASCII 10), and tab (ASCII 9).</source>
          <target state="translated">E &amp;lt;n&amp;gt; 숫자 코드를 사용하여 문자를 참조 할 때 32-126 범위의 숫자는 잘 알려진 US-ASCII 문자 (유일한 의미로 유니 코드로 정의 됨)를 나타내며 모든 포드 포맷터가 충실하게 렌더링해야합니다. . 개행에 대한 리터럴 바이트 순서 (ASCII 13, ASCII 13)를 제외하고 E &amp;lt;&amp;gt; 숫자가 0-31 및 127-159 범위에있는 문자는 리터럴 또는 E &amp;lt;번호&amp;gt; 코드로 사용하지 않아야합니다. 10 또는 ASCII 10) 및 탭 (ASCII 9).</target>
        </trans-unit>
        <trans-unit id="df6e47ff65713a910476ca008419bf15d9f92656" translate="yes" xml:space="preserve">
          <source>When registering new categories of warning, you can supply more names to warnings::register like this:</source>
          <target state="translated">새로운 범주의 경고를 등록 할 때 다음과 같이 warnings :: register에 더 많은 이름을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59e513d53fd0a8e9868f35002e2f8f73a3de8302" translate="yes" xml:space="preserve">
          <source>When removing directory trees, if you want to examine each file to decide whether to delete it (and possibly leaving large swathes alone),</source>
          <target state="translated">디렉토리 트리를 제거 할 때 각 파일을 검사하여 파일을 삭제할지 여부를 결정하려면 (또는 큰 면봉 만 남겨 두어야 함),</target>
        </trans-unit>
        <trans-unit id="ca0ea7cec59778756e53aaa7191d9a85c0fefd1a" translate="yes" xml:space="preserve">
          <source>When rendering Pod to a format that allows comments (i.e., to nearly any format other than plaintext), a Pod formatter must insert comment text identifying its name and version number, and the name and version numbers of any modules it might be using to process the Pod. Minimal examples:</source>
          <target state="translated">주석을 허용하는 형식 (예 : 일반 텍스트 이외의 다른 형식)으로 포드를 렌더링 할 때 포드 포맷터는 이름 및 버전 번호를 식별하는 주석 텍스트와 처리하는 데 사용할 모듈의 이름 및 버전 번호를 삽입해야합니다. 포드. 최소 예 :</target>
        </trans-unit>
        <trans-unit id="2ad27da5819e821c8cd5bf0434eaf270b819ceff" translate="yes" xml:space="preserve">
          <source>When rendering Pod to a format that has two kinds of hyphens (-), one that's a non-breaking hyphen, and another that's a breakable hyphen (as in &quot;object-oriented&quot;, which can be split across lines as &quot;object-&quot;, newline, &quot;oriented&quot;), formatters are encouraged to generally translate &quot;-&quot; to non-breaking hyphen, but may apply heuristics to convert some of these to breaking hyphens.</source>
          <target state="translated">포드를 두 가지 종류의 하이픈 (-)이있는 형식으로 렌더링 할 때, 하나는 끊지 않는 하이픈이고 다른 하나는 분리 할 수있는 하이픈입니다 ( &quot;객체 지향&quot;에서와 같이 &quot;개체-&quot;로 여러 줄로 나눌 수 있음) , 개행, &quot;중심&quot;), 포맷터는 일반적으로 &quot;-&quot;를 중단되지 않는 하이픈으로 변환하는 것이 권장되지만 휴리스틱을 적용하여 이들 중 일부를 끊는 하이픈으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f52c5a574eb5f1fd47869d07460df5abd7dd5137" translate="yes" xml:space="preserve">
          <source>When reporting a bug, please run through this checklist:</source>
          <target state="translated">버그를보고 할 때 다음 점검표를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="8b6bb8cb7867586650585befc2c1fd8387be0539" translate="yes" xml:space="preserve">
          <source>When reporting bugs/problems please include as much information as possible. It may be difficult for me to reproduce the problem as almost every setup is different.</source>
          <target state="translated">버그 / 문제보고시 가능한 많은 정보를 포함하십시오. 거의 모든 설정이 다르기 때문에 문제를 재현하기 어려울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2af35fcfc2870add3a574f13c6598d925c1d896" translate="yes" xml:space="preserve">
          <source>When resolving a request for a global DLL, the table of already-loaded specific DLLs is (effectively) ignored; moreover, specific DLLs are</source>
          <target state="translated">전역 DLL에 대한 요청을 해결할 때 이미로드 된 특정 DLL 테이블은 (효과적으로) 무시됩니다. 또한 특정 DLL은</target>
        </trans-unit>
        <trans-unit id="62379e9d05e773d7f9a20bc63493ce786aebefd0" translate="yes" xml:space="preserve">
          <source>When returning a C array to Perl the XS writer must provide an integer variable called &lt;code&gt;size_$var&lt;/code&gt; containing the number of elements in the array. This is used to determine how many elements should be pushed onto the return argument stack. This is not required on input since Perl knows how many arguments are on the stack when the routine is called. Ordinarily this variable would be called &lt;code&gt;size_RETVAL&lt;/code&gt; .</source>
          <target state="translated">C 배열을 Perl로 리턴 할 때 XS 기록기는 배열의 요소 수를 포함하는 &lt;code&gt;size_$var&lt;/code&gt; 이라는 정수 변수를 제공해야합니다 . 리턴 인수 스택에 몇 개의 요소를 푸시해야하는지 결정하는 데 사용됩니다. Perl은 루틴이 호출 될 때 스택에 몇 개의 인수가 있는지 알고 있으므로 입력시 필요하지 않습니다. 일반적으로이 변수는 &lt;code&gt;size_RETVAL&lt;/code&gt; 이라고 합니다 .</target>
        </trans-unit>
        <trans-unit id="8ca08b2641f1d92e43e0d4ac166dca80cda23751" translate="yes" xml:space="preserve">
          <source>When returning a non-null result the type of the return is relevant. If it is an AV then the elements of the AV are the weak reference RVs which point at this item. If it is any other type then the item itself is the weak reference.</source>
          <target state="translated">널이 아닌 결과를 리턴 할 때 리턴 유형이 관련됩니다. AV 인 경우 AV의 요소는이 항목을 가리키는 약한 참조 RV입니다. 다른 유형이라면 항목 자체는 약한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="97489cccab69eb1d35c1a341e128a78067c55f21" translate="yes" xml:space="preserve">
          <source>When rounding a number, different 'styles' or 'kinds' of rounding are possible. (Note that random rounding, as in Math::Round, is not implemented.)</source>
          <target state="translated">숫자를 반올림 할 때 다른 '스타일'또는 '종류'반올림이 가능합니다. (Math :: Round에서와 같이 임의의 반올림은 구현되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="b2582b20778ca5521eeab7f1f747014dfe26c89f" translate="yes" xml:space="preserve">
          <source>When run it produces this output</source>
          <target state="translated">실행될 때이 출력이 생성됩니다</target>
        </trans-unit>
        <trans-unit id="160ab26c7ebae1afd875b8a69bb2544386a0a133" translate="yes" xml:space="preserve">
          <source>When run, the script will produce this error message:</source>
          <target state="translated">스크립트를 실행하면 다음과 같은 오류 메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="5d4a1a1df4c481bafe8952728953b7a8106417f0" translate="yes" xml:space="preserve">
          <source>When running &lt;code&gt;perl Makefile.PL&lt;/code&gt; , the environment variable &lt;code&gt;PERL5_CPAN_IS_EXECUTING&lt;/code&gt; is set to the full path of the &lt;code&gt;Makefile.PL&lt;/code&gt; that is being executed. This prevents runaway processes with newer versions of Module::Install.</source>
          <target state="translated">실행시 &lt;code&gt;perl Makefile.PL&lt;/code&gt; , 환경 변수 &lt;code&gt;PERL5_CPAN_IS_EXECUTING&lt;/code&gt; 는 의 전체 경로 설정 &lt;code&gt;Makefile.PL&lt;/code&gt; 실행되고있다. 이렇게하면 최신 버전의 Module :: Install을 사용하여 런 어웨이 프로세스를 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2495ae50df460c2e127a2a6fc0eec9930e9be952" translate="yes" xml:space="preserve">
          <source>When running taint checks, either because the program was running setuid or setgid, or the &lt;b&gt;-T&lt;/b&gt; or &lt;b&gt;-t&lt;/b&gt; switch was specified, neither PERL5LIB nor PERLLIB is consulted. The program should instead say:</source>
          <target state="translated">프로그램이 setuid 또는 setgid를 실행 중이거나 &lt;b&gt;-T&lt;/b&gt; 또는 &lt;b&gt;-t&lt;/b&gt; 스위치가 지정되어 있기 때문에 오염 검사를 실행할 때 PERL5LIB 또는 PERLLIB는 참조되지 않습니다. 프로그램은 대신 다음과 같이 말해야합니다.</target>
        </trans-unit>
        <trans-unit id="7b3cb45c9a7da578dedba06cdb9f023a384333cd" translate="yes" xml:space="preserve">
          <source>When running this program, redirect &lt;code&gt;STDOUT&lt;/code&gt; so it is possible to check the output is correct from following test runs and use the system &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; utility to check the overall runtime.</source>
          <target state="translated">이 프로그램을 실행할 때 &lt;code&gt;STDOUT&lt;/code&gt; 을 재지 정하여 다음 테스트 실행에서 출력이 올바른지 확인하고 시스템 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 유틸리티를 사용 하여 전체 런타임을 점검하십시오.</target>
        </trans-unit>
        <trans-unit id="7975efeb25c8aaa03ac880e03163e48a54218208" translate="yes" xml:space="preserve">
          <source>When running under Eunice this variable contains a command which will convert a shell script to the proper form of text file for it to be executable by the shell. On other systems it is a no-op.</source>
          <target state="translated">Eunice에서 실행될 때이 변수에는 쉘 스크립트를 쉘에서 실행할 수 있도록 쉘 스크립트를 적절한 형식의 텍스트 파일로 변환하는 명령이 포함됩니다. 다른 시스템에서는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="401f0ab26dc2fddd741da0955da0f9c560a5d28d" translate="yes" xml:space="preserve">
          <source>When safe signals is in effect (the default behavior - see &lt;a href=&quot;#Unsafe-signals&quot;&gt;Unsafe signals&lt;/a&gt; for more details), then signals may be sent and acted upon by individual threads.</source>
          <target state="translated">안전 신호가 적용되면 (기본 동작- 자세한 내용 은 &lt;a href=&quot;#Unsafe-signals&quot;&gt;안전하지 않은 신호&lt;/a&gt; 참조) 개별 스레드에서 신호를 보내고 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="dba60ff6fd07f256c35eeeb0201541b7eaafeee0" translate="yes" xml:space="preserve">
          <source>When satisfied with the results, rerun the &lt;code&gt;installcmd&lt;/code&gt; target. Now you can copy &lt;code&gt;perl5.8.2.exe&lt;/code&gt; to &lt;code&gt;perl.exe&lt;/code&gt; , and install the other OMF-build executables: &lt;code&gt;perl__.exe&lt;/code&gt; etc. They are ready to be used.</source>
          <target state="translated">결과에 만족하면 &lt;code&gt;installcmd&lt;/code&gt; 대상을 다시 실행하십시오 . 이제 &lt;code&gt;perl5.8.2.exe&lt;/code&gt; 를 &lt;code&gt;perl.exe&lt;/code&gt; 로 복사 하고 다른 OMF 빌드 실행 파일 인 &lt;code&gt;perl__.exe&lt;/code&gt; 등을 설치할 수 있습니다. 사용할 준비가되었습니다.</target>
        </trans-unit>
        <trans-unit id="64d487e30347818adf665d0d1f254f13a4106809" translate="yes" xml:space="preserve">
          <source>When saving source, include evals that generate no subroutines.</source>
          <target state="translated">소스를 저장할 때 서브 루틴을 생성하지 않는 에바를 포함 시키십시오.</target>
        </trans-unit>
        <trans-unit id="c90d39de52f44bc4955e7d1999e5bc6bf1c25af5" translate="yes" xml:space="preserve">
          <source>When saving source, include source that did not compile.</source>
          <target state="translated">소스를 저장할 때 컴파일되지 않은 소스를 포함 시키십시오.</target>
        </trans-unit>
        <trans-unit id="398d8ece97f780e7acaac52b6e525bbaea7d6236" translate="yes" xml:space="preserve">
          <source>When searching for single-character delimiters, escaped delimiters and &lt;code&gt;\\&lt;/code&gt; are skipped. For example, while searching for terminating &lt;code&gt;/&lt;/code&gt;, combinations of &lt;code&gt;\\&lt;/code&gt; and &lt;code&gt;\/&lt;/code&gt; are skipped. If the delimiters are bracketing, nested pairs are also skipped. For example, while searching for a closing &lt;code&gt;]&lt;/code&gt; paired with the opening &lt;code&gt;[&lt;/code&gt;, combinations of &lt;code&gt;\\&lt;/code&gt; , &lt;code&gt;\]&lt;/code&gt;, and &lt;code&gt;\[&lt;/code&gt; are all skipped, and nested &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt; are skipped as well. However, when backslashes are used as the delimiters (like &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq\\&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr\\\&lt;/a&gt;&lt;/code&gt;), nothing is skipped. During the search for the end, backslashes that escape delimiters or other backslashes are removed (exactly speaking, they are not copied to the safe location).</source>
          <target state="translated">단일 문자 분리 문자를 검색 할 때 이스케이프 분리 문자와 &lt;code&gt;\\&lt;/code&gt; 는 건너 뜁니다. 예를 들어, 종료 &lt;code&gt;/&lt;/code&gt; 를 검색하는 동안 &lt;code&gt;\\&lt;/code&gt; 와 &lt;code&gt;\/&lt;/code&gt; 조합 은 건너 뜁니다. 분리 문자가 브라케팅 인 경우 중첩 쌍도 건너 뜁니다. 폐쇄를 검색하는 동안, 예를 들어 &lt;code&gt;]&lt;/code&gt; 개구와 쌍 &lt;code&gt;[&lt;/code&gt; 의 조합 &lt;code&gt;\\&lt;/code&gt; , &lt;code&gt;\]&lt;/code&gt; 및 &lt;code&gt;\[&lt;/code&gt; 모두 생략하고, 중첩되어 &lt;code&gt;[&lt;/code&gt; 및 &lt;code&gt;]&lt;/code&gt; 은 물론 생략된다. 그러나 백 슬래시가 구분자로 사용되는 경우 ( &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq\\&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr\\\&lt;/a&gt;&lt;/code&gt; )를 건너 뜁니다. 끝을 검색하는 동안 구분 기호 또는 다른 백 슬래시를 이스케이프 처리하는 백 슬래시는 제거됩니다 (정확하게 말하면 안전한 위치로 복사되지 않습니다).</target>
        </trans-unit>
        <trans-unit id="32c34df309dbf3ee7f15cd5785f504c8f035d38f" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;&quot;1&quot;&lt;/code&gt; or &lt;code&gt;&quot;RANDOM&quot;&lt;/code&gt; then traversing keys will be randomized. Every time a hash is inserted into the key order will change in a random fashion. The order may not be repeatable in a following program run even if the PERL_HASH_SEED has been specified. This is the default mode for perl.</source>
          <target state="translated">로 설정하면 &lt;code&gt;&quot;1&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;RANDOM&quot;&lt;/code&gt; 다음 횡단 키는 무작위됩니다. 해시가 키 순서에 삽입 될 때마다 임의의 방식으로 변경됩니다. PERL_HASH_SEED가 지정된 경우에도 다음 프로그램 실행에서 순서를 반복하지 못할 수 있습니다. 이것은 perl의 기본 모드입니다.</target>
        </trans-unit>
        <trans-unit id="04d0e5e2f5a4ede1100f0e4584215cbbf899e23b" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;&quot;2&quot;&lt;/code&gt; or &lt;code&gt;&quot;DETERMINISTIC&quot;&lt;/code&gt; then inserting keys into a hash will cause the key order to change, but in a way that is repeatable from program run to program run.</source>
          <target state="translated">로 설정하면 &lt;code&gt;&quot;2&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;DETERMINISTIC&quot;&lt;/code&gt; 다음 해시에 삽입 키는 변화에 키 순서를 야기하지만, 프로그램 실행에 프로그램 실행에서 반복하는 방법으로합니다.</target>
        </trans-unit>
        <trans-unit id="9e7128c2c7dce5a0a3a9029329df5cbd50b2f0b7" translate="yes" xml:space="preserve">
          <source>When set to a true value, will cause &lt;code&gt;remove_tree&lt;/code&gt; to skip the files for which the process lacks the required privileges needed to delete files, such as delete privileges on VMS. In other words, the code will make no attempt to alter file permissions. Thus, if the process is interrupted, no filesystem object will be left in a more permissive mode.</source>
          <target state="translated">true 값으로 설정하면 &lt;code&gt;remove_tree&lt;/code&gt; 가 VMS에 대한 삭제 권한과 같이 파일을 삭제하는 데 필요한 권한이 프로세스에없는 파일을 건너 뜁니다. 즉, 코드는 파일 권한을 변경하려고 시도하지 않습니다. 따라서 프로세스가 중단되면 파일 시스템 객체가 더 허용 가능한 모드로 유지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c7f5dc6825eff7e1f171e69f42059c82111432c0" translate="yes" xml:space="preserve">
          <source>When set to a true value, will cause all files and subdirectories to be removed, except the initially specified directories. This comes in handy when cleaning out an application's scratch directory.</source>
          <target state="translated">true로 설정하면 처음에 지정된 디렉토리를 제외한 모든 파일과 서브 디렉토리가 제거됩니다. 응용 프로그램의 스크래치 디렉토리를 정리할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="2ff22a09dbb1fd01f1d9e27ed6ec106512c2eedc" translate="yes" xml:space="preserve">
          <source>When set, Data::Dumper will emit single, non-self-referential values as atoms/terms rather than statements. This means that the &lt;code&gt;$VAR&lt;/code&gt;</source>
          <target state="translated">설정하면 Data :: Dumper는 자체가 아닌 단일 값을 명령문이 아닌 원자 / 항으로 방출합니다. 이는 &lt;code&gt;$VAR&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe8e786dd3039d8dd6d2bfab15396a2a2af496f5" translate="yes" xml:space="preserve">
          <source>When set, controls the network timeout (counted in seconds).</source>
          <target state="translated">설정하면 네트워크 시간 초과 (초 단위)를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="b5e8c42abd62cd10178b1f40a287ed255997e01d" translate="yes" xml:space="preserve">
          <source>When set, enables the use of double quotes for representing string values. Whitespace other than space will be represented as &lt;code&gt;[\n\t\r]&lt;/code&gt; , &quot;unsafe&quot; characters will be backslashed, and unprintable characters will be output as quoted octal integers. The default is 0.</source>
          <target state="translated">설정하면 문자열 값을 나타내는 데 큰 따옴표를 사용할 수 있습니다. 공백 이외의 공백은 &lt;code&gt;[\n\t\r]&lt;/code&gt; 되고 &quot;안전하지 않은&quot;문자는 백 슬래시되며 인쇄 할 수없는 문자는 인용 된 8 진 정수로 출력됩니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="e7c58b77eb133eea8c15ca3a9398533c775f314b" translate="yes" xml:space="preserve">
          <source>When should I decode or encode?</source>
          <target state="translated">언제 디코딩 또는 인코딩해야합니까?</target>
        </trans-unit>
        <trans-unit id="1dc62984ecca7c09ade87153ed4ccd6695dd04ce" translate="yes" xml:space="preserve">
          <source>When shouldn't I program in Perl?</source>
          <target state="translated">언제 Perl에서 프로그램해서는 안되나요?</target>
        </trans-unit>
        <trans-unit id="38a0e44be6c1f4e08e2750d9d92dbacbb5e6685b" translate="yes" xml:space="preserve">
          <source>When something is contained in something else, particularly when that might be considered surprising: &amp;ldquo;I&amp;rsquo;ve embedded a complete Perl interpreter in my editor!&amp;rdquo;</source>
          <target state="translated">무언가가 다른 것에 포함되어있을 때, 특히 놀라운 것으로 여겨 질 때 :&amp;ldquo;저는 완전한 Perl 인터프리터를 편집기에 내장했습니다!&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="0a4af2a22b89ee59f46fa6ec1a2f89f7c8de8e00" translate="yes" xml:space="preserve">
          <source>When speaking about regexes we need to distinguish between their source code form and their internal form. In this document we will use the term &quot;pattern&quot; when we speak of their textual, source code form, and the term &quot;program&quot; when we speak of their internal representation. These correspond to the terms</source>
          <target state="translated">정규 표현식에 대해 말할 때 소스 코드 형식과 내부 형식을 구별해야합니다. 이 문서에서는 텍스트, 소스 코드 형식, 내부 표현을 말할 때 &quot;프로그램&quot;이라는 용어를 사용할 때 &quot;패턴&quot;이라는 용어를 사용합니다. 이들은 용어에 해당합니다</target>
        </trans-unit>
        <trans-unit id="71fc37572f09658b981cd729d4958d3d9535564d" translate="yes" xml:space="preserve">
          <source>When specified (localised) in a module's</source>
          <target state="translated">모듈에 지정된 경우 (현지화 됨)</target>
        </trans-unit>
        <trans-unit id="0b48aaafd2407a97f05ee6a676562dca0cfeebf8" translate="yes" xml:space="preserve">
          <source>When starting scripts directly, Perl uses exactly the same algorithm as for the search of script given by &lt;b&gt;-S&lt;/b&gt; command-line option: it will look in the current directory, then on components of &lt;code&gt;$ENV{PATH}&lt;/code&gt; using the following order of appended extensions: no extension,</source>
          <target state="translated">스크립트를 직접 시작할 때 Perl은 &lt;b&gt;-S&lt;/b&gt; 명령 행 옵션으로 제공되는 스크립트를 검색 할 때와 동일한 알고리즘을 사용 합니다. 현재 디렉토리를 찾은 후 다음 순서의 추가 된 확장자를 사용하여 &lt;code&gt;$ENV{PATH}&lt;/code&gt; 구성 요소를 찾습니다. : 연장 없음,</target>
        </trans-unit>
        <trans-unit id="31501718ea48b1c7c96923d7f9ebcfb80e76fc7d" translate="yes" xml:space="preserve">
          <source>When storing doubles in network order, their value is stored as text. However, you should also not expect non-numeric floating-point values such as infinity and &quot;not a number&quot; to pass successfully through a nstore()/retrieve() pair.</source>
          <target state="translated">복식을 네트워크 순서로 저장하면 해당 값이 텍스트로 저장됩니다. 그러나 무한대 및 &quot;숫자가 아님&quot;과 같은 숫자가 아닌 부동 소수점 값이 nstore () / retrieve () 쌍을 통과 할 것으로 예상해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="aadbffec66a30c1a002a47c90a7b1248371d0324" translate="yes" xml:space="preserve">
          <source>When testing applications, often you find yourself needing to provide functionality in your test environment that would usually be provided by external modules. Rather than munging the &lt;code&gt;%INC&lt;/code&gt; by hand to mark these external modules as loaded, so they are not attempted to be loaded by perl, this module offers you a very simple way to mark modules as loaded and/or unloaded.</source>
          <target state="translated">응용 프로그램을 테스트 할 때 테스트 환경에서 일반적으로 외부 모듈에서 제공하는 기능을 제공해야하는 경우가 종종 있습니다. 이 외부 모듈을로드 된 것으로 표시하기 위해 수동으로 &lt;code&gt;%INC&lt;/code&gt; 를 뭉치지 않고 펄이로드하려고 시도하지 않고이 모듈은 모듈을로드 및 / 또는 언로드 된 것으로 표시하는 매우 간단한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="961c445e33a9a31bd9e2652fe106daffb549bbdf" translate="yes" xml:space="preserve">
          <source>When that string is compiled from bracket notation into a real Perl sub, it's basically turned into:</source>
          <target state="translated">해당 문자열이 대괄호 표기법에서 실제 Perl 하위로 컴파일되면 기본적으로 다음과 같이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="956082e29333281c1000de72a422a6d173c77cc1" translate="yes" xml:space="preserve">
          <source>When the # flag and a precision are given in the %o conversion, the precision is incremented if it's necessary for the leading &quot;0&quot;.</source>
          <target state="translated">% o 변환에 # 플래그와 정밀도가 주어지면 선행 &quot;0&quot;에 필요한 경우 정밀도가 증가합니다.</target>
        </trans-unit>
        <trans-unit id="b4c77bd95ba1c8037180b07d06856855d317ef69" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;all&lt;/code&gt; parameter is omitted or false, then the tied hash elements will be the contents of the leftmost defined buffer with the name of the associated hash key. In other words, the tied hash will behave as &lt;code&gt;%+&lt;/code&gt; .</source>
          <target state="translated">때 &lt;code&gt;all&lt;/code&gt; 매개 변수를 생략 또는 거짓되고, 그 해시 연결 요소는 관련된 해시 키의 이름으로 정의 좌측의 버퍼의 내용이 될 것이다. 다시 말해, 묶인 해시는 &lt;code&gt;%+&lt;/code&gt; 로 동작합니다 .</target>
        </trans-unit>
        <trans-unit id="d840453ed70b6c8cd04f568b5e24263c8a47ca21" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;all&lt;/code&gt; parameter is provided, then the tied hash elements will be array refs listing the contents of each capture buffer whose name is the same as the associated hash key. If none of these buffers were involved in the match, the contents of that array ref will be as many &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; values as there are capture buffers with that name. In other words, the tied hash will behave as &lt;code&gt;%-&lt;/code&gt; .</source>
          <target state="translated">때 &lt;code&gt;all&lt;/code&gt; 매개 변수를 제공하고, 그 연결된 해시 요소 이름 관련된 해시 키와 동일한 각 캡쳐 버퍼의 내용을 나열 어레이 심판 것이다. 이러한 버퍼 중 어느 것도 일치하지 않으면 해당 배열 참조의 내용은 해당 이름을 가진 캡처 버퍼 가있는만큼 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 값이됩니다. 즉, 묶인 해시는 &lt;code&gt;%-&lt;/code&gt; 로 동작합니다 .</target>
        </trans-unit>
        <trans-unit id="ad645af5beffff4dcf298e97bda326c957e193d6" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;exUnix2&lt;/code&gt; option is present it will trigger the creation of a Unix2 extra field (ID is &quot;Ux&quot;) in the local zip header. This will be populated with &lt;code&gt;$uid&lt;/code&gt; and &lt;code&gt;$gid&lt;/code&gt; . An empty Unix2 extra field will also be created in the central zip header.</source>
          <target state="translated">때 &lt;code&gt;exUnix2&lt;/code&gt; 의 옵션이 존재는 로컬 헤더 압축 (ID는 &quot;UX는&quot;임) Unix2 추가 필드의 생성을 트리거 할 것이다. &lt;code&gt;$uid&lt;/code&gt; 및 &lt;code&gt;$gid&lt;/code&gt; 로 채워집니다 . 중앙의 zip 헤더에 빈 Unix2 추가 필드도 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="40f9a81cf7aa8b00ade31d3ca1a070fc29516dbb" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;exUnixN&lt;/code&gt; option is present it will trigger the creation of a UnixN extra field (ID is &quot;ux&quot;) in both the local and central zip headers. This will be populated with &lt;code&gt;$uid&lt;/code&gt; and &lt;code&gt;$gid&lt;/code&gt; . The UID &amp;amp; GID are stored as 32-bit integers.</source>
          <target state="translated">때 &lt;code&gt;exUnixN&lt;/code&gt; 의 옵션이 존재는 로컬 및 중앙 압축 헤더 (ID는 &quot;UX&quot;임) UnixN 추가 필드의 생성을 트리거 할 것이다. &lt;code&gt;$uid&lt;/code&gt; 및 &lt;code&gt;$gid&lt;/code&gt; 로 채워집니다 . UID 및 GID는 32 비트 정수로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="97ce970ca586eb9f9dd65ce4eb91d435bcb2b455" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;frame&lt;/code&gt; option is set, the debugger would print entered (and optionally exited) subroutines in different styles. See &lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt; for incredibly long examples of these.</source>
          <target state="translated">때 &lt;code&gt;frame&lt;/code&gt; 옵션을 설정, 디버거는 다른 스타일에서 서브 루틴을 입력 (선택적 종료) 인쇄 할 것이다. &lt;a href=&quot;perldebguts&quot;&gt;이것들에&lt;/a&gt; 대한 엄청나게 긴 예는 perldebguts 를 보십시오 .</target>
        </trans-unit>
        <trans-unit id="801df7cc1a118615aee66edb536ee9e06cf840b5" translate="yes" xml:space="preserve">
          <source>When the CPAN module is used for the first time, a configuration dialogue tries to determine a couple of site specific options. The result of the dialog is stored in a hash reference &lt;code&gt; $CPAN::Config &lt;/code&gt; in a file CPAN/Config.pm.</source>
          <target state="translated">CPAN 모듈을 처음 사용하는 경우 구성 대화 상자에서 몇 가지 사이트 별 옵션을 결정하려고합니다. 대화 상자의 결과는 CPAN / Config.pm 파일 의 해시 참조 &lt;code&gt; $CPAN::Config &lt;/code&gt; 에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="7cb924f6e524bd0e1830b8259c680c4e75924eac" translate="yes" xml:space="preserve">
          <source>When the CPAN shell enters a subshell via the look command, it sets the environment CPAN_SHELL_LEVEL to 1, or increments that variable if it is already set.</source>
          <target state="translated">CPAN 쉘이 look 명령을 통해 서브 쉘에 들어가면 환경 CPAN_SHELL_LEVEL을 1로 설정하거나 이미 설정된 경우 해당 변수를 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="3650ff6a9d15f4cddf8e012952c2eb6d79121733" translate="yes" xml:space="preserve">
          <source>When the CPAN shell is started it normally displays a greeting message that contains the running version and the status of readline support.</source>
          <target state="translated">CPAN 쉘이 시작되면 일반적으로 실행중인 버전과 readline 지원 상태를 포함하는 인사말 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3b2e82923d74c1d230a5130604df06c8f537a860" translate="yes" xml:space="preserve">
          <source>When the SV is read from or written to, the &lt;code&gt;uf_val&lt;/code&gt; or &lt;code&gt;uf_set&lt;/code&gt; function will be called with &lt;code&gt;uf_index&lt;/code&gt; as the first arg and a pointer to the SV as the second. A simple example of how to add &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; magic is shown below. Note that the ufuncs structure is copied by sv_magic, so you can safely allocate it on the stack.</source>
          <target state="translated">SV를 읽거나 쓸 때 &lt;code&gt;uf_val&lt;/code&gt; 또는 &lt;code&gt;uf_set&lt;/code&gt; 함수는 &lt;code&gt;uf_index&lt;/code&gt; 를 첫 번째 인수로 사용하고 SV에 대한 포인터를 두 번째로 사용하여 호출됩니다 . &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; 매직 을 추가하는 방법에 대한 간단한 예 는 다음과 같습니다. ufuncs 구조는 sv_magic에 의해 복사되므로 스택에 안전하게 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cf75e5eda3afd46688cf75f69b185773f733453" translate="yes" xml:space="preserve">
          <source>When the Storable engine does not find any &lt;code&gt;STORABLE_thaw&lt;/code&gt; hook routine, it tries to load the class by requiring the package dynamically (using the blessed package name), and then re-attempts the lookup. If at that time the hook cannot be located, the engine croaks. Note that this mechanism will fail if you define several classes in the same file, but &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; warned you.</source>
          <target state="translated">Storable 엔진이 &lt;code&gt;STORABLE_thaw&lt;/code&gt; 후크 루틴을 찾지 못하면 패키지를 동적으로 요구하여 (축복 된 패키지 이름 사용) 클래스를로드 한 다음 조회를 다시 시도합니다. 그때 후크를 찾을 수 없으면 엔진이 삐걱 거립니다. 동일한 파일에 여러 클래스를 정의하면이 메커니즘이 실패하지만 &lt;a href=&quot;perlmod&quot;&gt;perlmod가&lt;/a&gt; 경고합니다.</target>
        </trans-unit>
        <trans-unit id="44a6516f88b32cd0929f74947668f35c10106658" translate="yes" xml:space="preserve">
          <source>When the actual VMS termination status of the child is an error, internally the &lt;code&gt;$!&lt;/code&gt; value will be set to the closest Unix errno value to that error so that Perl scripts that test for error messages will see the expected Unix style error message instead of a VMS message.</source>
          <target state="translated">자식의 실제 VMS 종료 상태가 오류 인 경우 내부적으로 &lt;code&gt;$!&lt;/code&gt; 오류 메시지를 테스트하는 Perl 스크립트가 VMS 메시지 대신 예상되는 Unix 스타일 오류 메시지를 볼 수 있도록 value가 해당 오류에 가장 가까운 Unix errno 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="2e8f0d2ae12a2e39fe8c86870d0da6c283532175" translate="yes" xml:space="preserve">
          <source>When the arguments get executed via the system shell, results are subject to its quirks and capabilities. See &lt;a href=&quot;../perlop#%60STRING%60&quot;&gt;`STRING` in perlop&lt;/a&gt; for details.</source>
          <target state="translated">인수가 시스템 셸을 통해 실행되면 결과에 문제가 생길 수 있습니다. 자세한 내용 &lt;a href=&quot;../perlop#%60STRING%60&quot;&gt;은 perlop의`STRING`을&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="1fb744771cfcd60aec9ab66ef08b4b0d1508a2fd" translate="yes" xml:space="preserve">
          <source>When the arguments get executed via the system shell, results are subject to its quirks and capabilities. See &lt;a href=&quot;perlop#%60STRING%60&quot;&gt;`STRING` in perlop&lt;/a&gt; for details.</source>
          <target state="translated">인수가 시스템 셸을 통해 실행되면 결과에 문제가 생길 수 있습니다. 자세한 내용 &lt;a href=&quot;perlop#%60STRING%60&quot;&gt;은 perlop의`STRING`을&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="af5d3dc3800fc64d81a21bf6e187c8743b336401" translate="yes" xml:space="preserve">
          <source>When the class is to match caselessly under &lt;code&gt;/i&lt;/code&gt; matching rules, and a character that is explicitly mentioned inside the class matches a multiple-character sequence caselessly under Unicode rules, the class will also match that sequence. For example, Unicode says that the letter &lt;code&gt;LATIN SMALL LETTER SHARP S&lt;/code&gt; should match the sequence &lt;code&gt;ss&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; rules. Thus,</source>
          <target state="translated">클래스가 &lt;code&gt;/i&lt;/code&gt; 일치 규칙에서 대소 문자를 구분하지 않고 클래스 내부에서 명시 적으로 언급 된 문자가 유니 코드 규칙에서 대소 문자없이 여러 문자 시퀀스를 일치시키는 경우 클래스도 해당 순서와 일치합니다. 예를 들어, 유니 코드 문자 말한다 &lt;code&gt;LATIN SMALL LETTER SHARP S&lt;/code&gt; 는 시퀀스와 일치해야 &lt;code&gt;ss&lt;/code&gt; 아래에 &lt;code&gt;/i&lt;/code&gt; 규칙. 그러므로,</target>
        </trans-unit>
        <trans-unit id="4739858b160d44355cadf7e584ea672d7f556732" translate="yes" xml:space="preserve">
          <source>When the code will run on only two or three operating systems, you may need to consider only the differences of those particular systems. The important thing is to decide where the code will run and to be deliberate in your decision.</source>
          <target state="translated">코드가 2 개 또는 3 개의 운영 체제에서만 실행될 경우 해당 특정 시스템의 차이점 만 고려해야합니다. 중요한 것은 코드가 실행될 위치를 결정하고 신중하게 결정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="dfc1084fa585e179656ac972bdfbaccc526f6fbd" translate="yes" xml:space="preserve">
          <source>When the config variable ftp_passive is set, all downloads will be run with the environment variable FTP_PASSIVE set to this value. This is in general a good idea as it influences both Net::FTP and LWP based connections. The same effect can be achieved by starting the cpan shell with this environment variable set. For Net::FTP alone, one can also always set passive mode by running libnetcfg.</source>
          <target state="translated">구성 변수 ftp_passive가 설정되면 환경 변수 FTP_PASSIVE가이 값으로 설정된 상태에서 모든 다운로드가 실행됩니다. Net :: FTP 및 LWP 기반 연결 모두에 영향을 미치므로 일반적으로 좋은 생각입니다. 이 환경 변수 세트로 cpan 쉘을 시작하면 동일한 효과를 얻을 수 있습니다. Net :: FTP 단독의 경우 libnetcfg를 실행하여 항상 수동 모드를 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="78466bcc2cdd4ead9e6349b03cf49de5263729eb" translate="yes" xml:space="preserve">
          <source>When the database contains only UTF-8, a wrapper function or method is a convenient way to replace all your &lt;code&gt;fetchrow_array&lt;/code&gt; and &lt;code&gt;fetchrow_hashref&lt;/code&gt; calls. A wrapper function will also make it easier to adapt to future enhancements in your database driver. Note that at the time of this writing (January 2012), the DBI has no standardized way to deal with UTF-8 data. Please check the &lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI documentation&lt;/a&gt; to verify if that is still true.</source>
          <target state="translated">데이터베이스에 UTF-8 만 포함 된 경우 랩퍼 함수 또는 메소드는 모든 &lt;code&gt;fetchrow_array&lt;/code&gt; 및 &lt;code&gt;fetchrow_hashref&lt;/code&gt; 호출 을 대체하는 편리한 방법 입니다. 랩퍼 기능을 사용하면 데이터베이스 드라이버의 향후 개선 사항에보다 쉽게 ​​적응할 수 있습니다. 이 글을 쓰는 시점 (2012 년 1 월)에 DBI는 UTF-8 데이터를 처리하는 표준화 된 방법이 없습니다. 체크하시기 바랍니다 &lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI 문서를&lt;/a&gt; 그 여전히 해당하는 경우 확인합니다.</target>
        </trans-unit>
        <trans-unit id="424c9b91abc16b60883f34954f20bc0920b45171" translate="yes" xml:space="preserve">
          <source>When the execution of your program reaches a point that can hold a breakpoint, the &lt;code&gt;DB::DB()&lt;/code&gt; subroutine is called if any of the variables &lt;code&gt;$DB::trace&lt;/code&gt; , &lt;code&gt;$DB::single&lt;/code&gt; , or &lt;code&gt;$DB::signal&lt;/code&gt; is true. These variables are not &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;izable. This feature is disabled when executing inside &lt;code&gt;DB::DB()&lt;/code&gt; , including functions called from it unless &lt;code&gt;$^D &amp;amp; (1&amp;lt;&amp;lt;30)&lt;/code&gt; is true.</source>
          <target state="translated">프로그램 실행이 중단 점을 보유 할 수있는 지점에 도달 하면 변수 &lt;code&gt;$DB::trace&lt;/code&gt; , &lt;code&gt;$DB::single&lt;/code&gt; 또는 &lt;code&gt;$DB::signal&lt;/code&gt; 가 true 인 경우 &lt;code&gt;DB::DB()&lt;/code&gt; 서브 루틴이 호출됩니다. . 이러한 변수는 아니다 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; izable. 이 기능은 &lt;code&gt;$^D &amp;amp; (1&amp;lt;&amp;lt;30)&lt;/code&gt; 이 (가 ) 아닌 경우 호출 된 함수를 포함하여 &lt;code&gt;DB::DB()&lt;/code&gt; 내부에서 실행할 때 비활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="b4013fd718fab58c3590b6ef9433727cc8d4f1b2" translate="yes" xml:space="preserve">
          <source>When the file</source>
          <target state="translated">파일이</target>
        </trans-unit>
        <trans-unit id="0e9d22cf15c89f0be579b7cac8b2920cd0618fca" translate="yes" xml:space="preserve">
          <source>When the files you're processing are small, it doesn't much matter which way you do it, but it makes a huge difference when they start getting larger.</source>
          <target state="translated">처리하는 파일이 작을 때는 어떤 방식 으로든 중요하지 않지만 더 커지기 시작하면 큰 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3edca323b0aa2a8c22d79426f73f2c12bb6d2e6d" translate="yes" xml:space="preserve">
          <source>When the inner subroutine is called, it will see the value of the outer subroutine's lexical subroutine as it was before and during the *first* call to the outer subroutine; in this case, after the first call to the outer subroutine is complete, the inner and outer subroutines will no longer share a common value for the lexical subroutine. In other words, it will no longer be shared. This will especially make a difference if the lexical subroutines accesses lexical variables declared in its surrounding scope.</source>
          <target state="translated">내부 서브 루틴이 호출 될 때, 외부 서브 루틴에 대한 * first * 호출 이전과 그 동안 외부 서브 루틴의 어휘 서브 루틴 값이 표시됩니다. 이 경우, 외부 서브 루틴에 대한 첫 번째 호출이 완료된 후, 내부 및 외부 서브 루틴은 더 이상 어휘 서브 루틴에 대한 공통 값을 공유하지 않습니다. 즉, 더 이상 공유되지 않습니다. 어휘 서브 루틴이 주변 범위에 선언 된 어휘 변수에 액세스하는 경우 특히 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8e896e8cfb6883a198899b3b354096b8ef21889" translate="yes" xml:space="preserve">
          <source>When the inner subroutine is called, it will see the value of the outer subroutine's variable as it was before and during the *first* call to the outer subroutine; in this case, after the first call to the outer subroutine is complete, the inner and outer subroutines will no longer share a common value for the variable. In other words, the variable will no longer be shared.</source>
          <target state="translated">내부 서브 루틴이 호출되면 외부 서브 루틴에 대한 * first * 호출 이전과 호출 동안의 외부 서브 루틴 변수 값이 표시됩니다. 이 경우 외부 서브 루틴에 대한 첫 번째 호출이 완료된 후 내부 및 외부 서브 루틴은 더 이상 변수의 공통 값을 공유하지 않습니다. 즉, 변수가 더 이상 공유되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="631ef295238142aad88b3365a36b169f7f950bf1" translate="yes" xml:space="preserve">
          <source>When the last reference to an object goes away, the object is destroyed. If you only have one reference to an object stored in a lexical scalar, the object is destroyed when that scalar goes out of scope. If you store the object in a package global, that object may not go out of scope until the program exits.</source>
          <target state="translated">객체에 대한 마지막 참조가 사라지면 객체가 파괴됩니다. 어휘 스칼라에 저장된 오브젝트에 대한 참조가 하나만있는 경우 해당 스칼라가 범위를 벗어나면 오브젝트가 삭제됩니다. 패키지 전역에 개체를 저장하면 프로그램이 종료 될 때까지 해당 개체가 범위를 벗어날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4bd6e1ab0ed4ba3f062fe2340aa266f01cbc661" translate="yes" xml:space="preserve">
          <source>When the layer is pushed as part of an &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; call, &lt;code&gt;PUSHED&lt;/code&gt; will be called</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 통화의 일부로 레이어를 푸시하면 &lt;code&gt;PUSHED&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0128971f85240b4f39abca0c6ce4a11b4e096972" translate="yes" xml:space="preserve">
          <source>When the layer is pushed, the current value of &lt;code&gt;$PerlIO::encoding::fallback&lt;/code&gt; is saved and used as the CHECK argument when calling the Encode methods encode() and decode().</source>
          <target state="translated">계층을 푸시하면 &lt;code&gt;$PerlIO::encoding::fallback&lt;/code&gt; 의 현재 값 이 저장되어 Encode 메서드 encode () 및 decode ()를 호출 할 때 CHECK 인수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8cb85b7bdde203de76612ce7dec71db2d2570629" translate="yes" xml:space="preserve">
          <source>When the lib module is first loaded it records the current value of @INC in an array &lt;code&gt;@lib::ORIG_INC&lt;/code&gt; . To restore @INC to that value you can say</source>
          <target state="translated">lib 모듈이 처음로드되면 @INC의 현재 값을 &lt;code&gt;@lib::ORIG_INC&lt;/code&gt; 배열에 기록합니다 . @INC를 그 값으로 복원하려면 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="415f4830f0a5c60f55a1d0556cdab8350fdd12bf" translate="yes" xml:space="preserve">
          <source>When the match runs, the first part of the regular expression (&lt;code&gt;\b(foo)&lt;/code&gt; ) finds a possible match right at the beginning of the string, and loads up $1 with &quot;Foo&quot;. However, as soon as the matching engine sees that there's no whitespace following the &quot;Foo&quot; that it had saved in $1, it realizes its mistake and starts over again one character after where it had the tentative match. This time it goes all the way until the next occurrence of &quot;foo&quot;. The complete regular expression matches this time, and you get the expected output of &quot;table follows foo.&quot;</source>
          <target state="translated">일치가 실행되면 정규식의 첫 번째 부분 ( &lt;code&gt;\b(foo)&lt;/code&gt; )은 문자열의 시작 부분에서 가능한 일치를 찾고 &quot;Foo&quot;를 사용하여 $ 1을로드합니다. 그러나 일치하는 엔진이 $ 1에 저장 한 &quot;Foo&quot;뒤에 공백이 없다는 것을 알게 되 자마자 실수를 인식하고 잠정적으로 일치 한 위치에서 한 문자를 다시 시작합니다. 이번에는 다음 번 &quot;foo&quot;가 나타날 때까지 계속 진행됩니다. 완전한 정규 표현식이 이번에는 일치하고 &quot;table follows foo&quot;의 예상 출력을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="3d9aa22c95db143c4f71ce6060fc0fa951e547b8" translate="yes" xml:space="preserve">
          <source>When the object goes out of scope, the destructor is called. This destructor will attempt to unlink the file (using L</source>
          <target state="translated">객체가 범위를 벗어나면 소멸자가 호출됩니다. 이 소멸자는 파일을 연결 해제하려고 시도합니다 (L을 사용하여</target>
        </trans-unit>
        <trans-unit id="08260b550e8cbd87b7894a9886c2e5f84f74a639" translate="yes" xml:space="preserve">
          <source>When the optimisation criteria have been satisfied, &lt;code&gt;reg_try()&lt;/code&gt; is called to perform the match.</source>
          <target state="translated">최적화 기준이 충족되면 일치를 수행하기 위해 &lt;code&gt;reg_try()&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5ec2c96e37a54667487e24f12619de8d206380fe" translate="yes" xml:space="preserve">
          <source>When the output is a filename, it will truncate the contents of the file before writing any compressed data. If the output is a filehandle its position will not be changed. If the output is a buffer, it will be wiped before any compressed data is output.</source>
          <target state="translated">출력이 파일 이름 인 경우 압축 된 데이터를 쓰기 전에 파일의 내용을 자릅니다. 출력이 파일 핸들 인 경우 위치가 변경되지 않습니다. 출력이 버퍼 인 경우 압축 된 데이터가 출력되기 전에 지워집니다.</target>
        </trans-unit>
        <trans-unit id="490632792a6bd230d4b7574b0a1ce3af888c0fe9" translate="yes" xml:space="preserve">
          <source>When the output is a filename, it will truncate the contents of the file before writing any uncompressed data. If the output is a filehandle its position will not be changed. If the output is a buffer, it will be wiped before any uncompressed data is output.</source>
          <target state="translated">출력이 파일 이름 인 경우 압축되지 않은 데이터를 쓰기 전에 파일의 내용을 자릅니다. 출력이 파일 핸들 인 경우 위치가 변경되지 않습니다. 출력이 버퍼 인 경우 압축되지 않은 데이터가 출력되기 전에 지워집니다.</target>
        </trans-unit>
        <trans-unit id="923167a1de1c89698b7cefa97410f6784a41b41c" translate="yes" xml:space="preserve">
          <source>When the program has terminated, the output may be examined and sorted using any standard text filtering utilities. Something like the following may be sufficient:</source>
          <target state="translated">프로그램이 종료되면 표준 텍스트 필터링 유틸리티를 사용하여 출력을 검사하고 정렬 할 수 있습니다. 다음과 같은 것이 충분할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2704235b2d8eb8f428696670573c7525bbfe494" translate="yes" xml:space="preserve">
          <source>When the script ends, and you want to change some values in the generated</source>
          <target state="translated">스크립트가 종료되고 생성 된 일부 값을 변경하려는 경우</target>
        </trans-unit>
        <trans-unit id="116008ef85147614241af5722a4a2daf4c0fac34" translate="yes" xml:space="preserve">
          <source>When the script terminates the profiler will create a database of the profile information that you can turn into reports using the profiler's tools. See &amp;lt;perlperf&amp;gt; for details.</source>
          <target state="translated">스크립트가 종료되면 프로파일 러는 프로파일 러 도구를 사용하여 보고서로 전환 할 수있는 프로파일 정보 데이터베이스를 작성합니다. 자세한 내용은 &amp;lt;perlperf&amp;gt;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d7811c9ae79cafa461b23dd21d92c2852fa57021" translate="yes" xml:space="preserve">
          <source>When the string contains a Unicode named code point &lt;code&gt;\N{...}&lt;/code&gt;</source>
          <target state="translated">문자열에 코드 포인트 &lt;code&gt;\N{...}&lt;/code&gt; 이라는 유니 코드가 포함 된 경우</target>
        </trans-unit>
        <trans-unit id="219689a8c46c6da015ee7181b846d635f06ea57d" translate="yes" xml:space="preserve">
          <source>When the string contains a Unicode-only code point</source>
          <target state="translated">문자열에 유니 코드 전용 코드 포인트가 포함 된 경우</target>
        </trans-unit>
        <trans-unit id="c5aaa6f97ab5589891e81e58fbc94f58509000ee" translate="yes" xml:space="preserve">
          <source>When the string has come from an external source marked as Unicode</source>
          <target state="translated">문자열이 유니 코드로 표시된 외부 소스에서 온 경우</target>
        </trans-unit>
        <trans-unit id="33e82ba1ad1caecfef00b667970977ee30c1a1ff" translate="yes" xml:space="preserve">
          <source>When the taint mode (&lt;code&gt;-T&lt;/code&gt; ) is in effect, the &quot;.&quot; directory is removed from &lt;code&gt;@INC&lt;/code&gt; , and the environment variables &lt;code&gt;PERL5LIB&lt;/code&gt; and &lt;code&gt;PERLLIB&lt;/code&gt; are ignored by Perl. You can still adjust &lt;code&gt;@INC&lt;/code&gt; from outside the program by using the &lt;code&gt;-I&lt;/code&gt; command line option as explained in &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;. The two environment variables are ignored because they are obscured, and a user running a program could be unaware that they are set, whereas the &lt;code&gt;-I&lt;/code&gt; option is clearly visible and therefore permitted.</source>
          <target state="translated">테 인트 모드 ( &lt;code&gt;-T&lt;/code&gt; )가 적용되면 &quot;.&quot; &lt;code&gt;@INC&lt;/code&gt; 에서 디렉토리가 제거되고 환경 변수 &lt;code&gt;PERL5LIB&lt;/code&gt; 및 &lt;code&gt;PERLLIB&lt;/code&gt; 는 Perl에 의해 무시됩니다. &lt;a href=&quot;perlrun&quot;&gt;perlrun에&lt;/a&gt; 설명 된대로 &lt;code&gt;-I&lt;/code&gt; 명령 행 옵션을 사용하여 프로그램 외부에서 &lt;code&gt;@INC&lt;/code&gt; 를 조정할 수 있습니다 . 두 개의 환경 변수는 가려져 무시되므로 프로그램을 실행하는 사용자는 설정 여부를 알지 못하는 반면 &lt;code&gt;-I&lt;/code&gt; 옵션은 명확하게 표시되므로 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="05614cc2a7184900b0ce6634ffcfa41b43df8b62" translate="yes" xml:space="preserve">
          <source>When the test file finishes, outputs the summary, together.</source>
          <target state="translated">테스트 파일이 완료되면 요약을 함께 출력합니다.</target>
        </trans-unit>
        <trans-unit id="4c7dc2674104ea2267f99aaaacf86ff6b7f8474b" translate="yes" xml:space="preserve">
          <source>When there is no BLOCK, &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; is a function that falls through the current &lt;code&gt;when&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; block instead of iterating a dynamically enclosing &lt;code&gt;foreach&lt;/code&gt; or exiting a lexically enclosing &lt;code&gt;&lt;a href=&quot;given&quot;&gt;given&lt;/a&gt;&lt;/code&gt;. In Perl 5.14 and earlier, this form of &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; was only available when the &lt;code&gt;&quot;switch&quot;&lt;/code&gt; feature was enabled. See &lt;a href=&quot;../feature&quot;&gt;feature&lt;/a&gt; and &lt;a href=&quot;../perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt; for more information.</source>
          <target state="translated">BLOCK이 없으면 &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 는 동적으로 동봉하는 &lt;code&gt;foreach&lt;/code&gt; 를 반복 하거나 &lt;code&gt;&lt;a href=&quot;given&quot;&gt;given&lt;/a&gt;&lt;/code&gt; 어휘 동봉을 종료하는 대신 현재 &lt;code&gt;when&lt;/code&gt; 또는 &lt;code&gt;default&lt;/code&gt; 블록을 통과하는 함수입니다 . Perl 5.14 이하에서는 &lt;code&gt;&quot;switch&quot;&lt;/code&gt; 기능이 활성화 된 경우에만 이 형태의 &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 을 사용할 수 있었습니다. 자세한 내용 &lt;a href=&quot;../perlsyn#Switch-Statements&quot;&gt;은 perlsyn의 &lt;/a&gt;&lt;a href=&quot;../feature&quot;&gt;기능&lt;/a&gt; 및 스위치 문 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d0601e1c27a0dc14d5d3038756194559ec0b7177" translate="yes" xml:space="preserve">
          <source>When there is no BLOCK, &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; is a function that falls through the current &lt;code&gt;when&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; block instead of iterating a dynamically enclosing &lt;code&gt;foreach&lt;/code&gt; or exiting a lexically enclosing &lt;code&gt;given&lt;/code&gt; . In Perl 5.14 and earlier, this form of &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; was only available when the &lt;code&gt;&quot;switch&quot;&lt;/code&gt; feature was enabled. See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; and &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt; for more information.</source>
          <target state="translated">BLOCK이 없으면 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 는 동적으로 동봉하는 &lt;code&gt;foreach&lt;/code&gt; 를 반복 하거나 &lt;code&gt;given&lt;/code&gt; 어휘 동봉을 종료하는 대신 현재 &lt;code&gt;when&lt;/code&gt; 또는 &lt;code&gt;default&lt;/code&gt; 블록을 통과하는 함수입니다 . Perl 5.14 이하에서는 &lt;code&gt;&quot;switch&quot;&lt;/code&gt; 기능이 활성화 된 경우에만 이 형태의 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 을 사용할 수 있었습니다. 자세한 내용 &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;은 perlsyn의 &lt;/a&gt;&lt;a href=&quot;feature&quot;&gt;기능&lt;/a&gt; 및 스위치 문 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d14e56899b59096c05cd14ff3a8ecfb95a7d60b7" translate="yes" xml:space="preserve">
          <source>When there is no method, it takes the method name as the name of the encoding and encodes the instance</source>
          <target state="translated">메소드가없는 경우 메소드 이름을 인코딩 이름으로 사용하고 인스턴스를 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="b009ed76d6586de96f41fbede53e1b376b816ad5" translate="yes" xml:space="preserve">
          <source>When these are embedded in another pattern, what they match does not change, regardless of parenthesization or what modifiers are in effect in that outer pattern.</source>
          <target state="translated">이들이 다른 패턴에 임베드되면 괄호 나 외부 패턴에 어떤 수정자가 적용되는지에 관계없이 일치하는 항목이 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e1c33d2bb86243cd92baa102e04bd026d16cffb4" translate="yes" xml:space="preserve">
          <source>When this code is executed there is no output. Here's why:</source>
          <target state="translated">이 코드가 실행되면 출력이 없습니다. 이유는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7f61484b00c940e7437bf32bc5684d2e69d1807c" translate="yes" xml:space="preserve">
          <source>When this code is run only the &lt;code&gt;Derived&lt;/code&gt; object, &lt;code&gt;$b&lt;/code&gt; , will generate a warning.</source>
          <target state="translated">이 코드가 실행되면 &lt;code&gt;Derived&lt;/code&gt; 객체 인 &lt;code&gt;$b&lt;/code&gt; 만 경고를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="917174880fc77c13ccda7d2e62ec7ea358e2a066" translate="yes" xml:space="preserve">
          <source>When this code is run with the &lt;b&gt;-w&lt;/b&gt; flag, a warning will be produced for the &lt;code&gt;$a&lt;/code&gt; line: &lt;code&gt;&quot;Reversed += operator&quot;&lt;/code&gt; .</source>
          <target state="translated">이 코드를 &lt;b&gt;-w&lt;/b&gt; 플래그 와 함께 실행 하면 &lt;code&gt;$a&lt;/code&gt; 행에 대해 &lt;code&gt;&quot;Reversed += operator&quot;&lt;/code&gt; 경고가 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="16748736985dd4c981bc264b989b01547f68e378" translate="yes" xml:space="preserve">
          <source>When this form of the pragma is used, only the non-character portions of locales are used by Perl, for example &lt;code&gt;LC_NUMERIC&lt;/code&gt; . Perl assumes that you have translated all the characters it is to operate on into Unicode (actually the platform's native character set (ASCII or EBCDIC) plus Unicode). For data in files, this can conveniently be done by also specifying</source>
          <target state="translated">이 형식의 pragma를 사용하는 경우 로케일의 문자가 아닌 부분 만 Perl에 의해 사용됩니다 (예 : &lt;code&gt;LC_NUMERIC&lt;/code&gt; ) . Perl은 조작 할 모든 문자를 유니 코드 (실제로 플랫폼의 기본 문자 세트 (ASCII 또는 EBCDIC)와 유니 코드)로 변환했다고 가정합니다. 파일의 데이터의 경우 다음을 지정하여 편리하게 수행 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="f3b915026102758b5ff7da846b6098df7e775168" translate="yes" xml:space="preserve">
          <source>When this function is called, the function referenced by</source>
          <target state="translated">이 함수가 호출되면</target>
        </trans-unit>
        <trans-unit id="01472604570ddd05a81c224b83daf7199b2292ca" translate="yes" xml:space="preserve">
          <source>When this is set to &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;OBJECT&lt;/code&gt; will be automagically derived from &lt;code&gt;O_FILES&lt;/code&gt; .</source>
          <target state="translated">이로 설정하면 &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;OBJECT&lt;/code&gt; 자동적로부터 유도 될 &lt;code&gt;O_FILES&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e7dd367eef2d9f8124f8f23ef52e931a536491c" translate="yes" xml:space="preserve">
          <source>When this is true, CPAN will set PERL_MM_USE_DEFAULT to a true value. This causes ExtUtils::MakeMaker (and compatible) prompts to use default values instead of stopping to prompt you to answer questions. It also sets NONINTERACTIVE_TESTING to a true value to signal more generally that distributions should not try to interact with you.</source>
          <target state="translated">이것이 참이면 CPAN은 PERL_MM_USE_DEFAULT를 참 값으로 설정합니다. 이로 인해 ExtUtils :: MakeMaker (및 호환 가능) 프롬프트가 멈추지 않고 기본값을 사용하여 질문에 대한 프롬프트를 표시합니다. 또한 NONINTERACTIVE_TESTING을 실제 값으로 설정하여 분배가 사용자와 상호 작용하지 않아야 함을 더 일반적으로 알립니다.</target>
        </trans-unit>
        <trans-unit id="d2ca05f5323dff5f446952bd69ac6477b5186d11" translate="yes" xml:space="preserve">
          <source>When to Still Use local()</source>
          <target state="translated">여전히 local ()을 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="84389d029ef5726370dd8c2cf19105277288fbc8" translate="yes" xml:space="preserve">
          <source>When to Use OO</source>
          <target state="translated">OO를 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="1aff41766b1c1facad70ba1087945ce4b9ff69fd" translate="yes" xml:space="preserve">
          <source>When true this parameter will set the FLG.FHCRC bit to 1 in the gzip header and set the CRC16 header field to the CRC of the complete gzip header except the CRC16 field itself.</source>
          <target state="translated">true 인 경우이 매개 변수는 gzip 헤더에서 FLG.FHCRC 비트를 1로 설정하고 CRC16 필드 자체를 제외하고 CRC16 헤더 필드를 전체 gzip 헤더의 CRC로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="71e94facdb69a355a340449fba8e5c34fbd178ec" translate="yes" xml:space="preserve">
          <source>When true, perform the generation and addition to the MANIFEST of the SIGNATURE file in the distdir during 'make distdir', via 'cpansign -s'.</source>
          <target state="translated">true 인 경우 'cpansign -s'를 통해 'make distdir'중에 distdir에서 SIGNATURE 파일의 MANIFEST 생성 및 추가를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="2f8d8efe7dc5d620dd4b31a7d176203c2784135f" translate="yes" xml:space="preserve">
          <source>When true, suppresses the appending of installations to &lt;code&gt;perllocal&lt;/code&gt; .</source>
          <target state="translated">true 인 경우 &lt;code&gt;perllocal&lt;/code&gt; 에 설치를 추가하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="92a480e39d3219d70893b100f9cf0554ca8d0e6e" translate="yes" xml:space="preserve">
          <source>When true, suppresses the generation and addition to the MANIFEST of the META.yml and META.json module meta-data files during 'make distdir'.</source>
          <target state="translated">true 인 경우 'make distdir'중에 META.yml 및 META.json 모듈 메타 데이터 파일의 MANIFEST에 대한 생성 및 추가를 억제합니다.</target>
        </trans-unit>
        <trans-unit id="8f0d56eaaf65617686939dad5c1d3b6bcfce688e" translate="yes" xml:space="preserve">
          <source>When true, suppresses the generation of MYMETA.yml and MYMETA.json module meta-data files during 'perl Makefile.PL'.</source>
          <target state="translated">true 인 경우 'perl Makefile.PL'동안 MYMETA.yml 및 MYMETA.json 모듈 메타 데이터 파일 생성을 억제합니다.</target>
        </trans-unit>
        <trans-unit id="b0686c4aa533a7288139fdb7b691343d38cb093e" translate="yes" xml:space="preserve">
          <source>When true, suppresses the writing of &lt;code&gt;packlist&lt;/code&gt; files for installs.</source>
          <target state="translated">true 인 경우 설치를위한 &lt;code&gt;packlist&lt;/code&gt; 파일 쓰기를 억제 합니다.</target>
        </trans-unit>
        <trans-unit id="f79c2493f27b952ee97bbc3534495620a8d27f41" translate="yes" xml:space="preserve">
          <source>When trying to explain stacks, most computer science textbooks mumble something about spring-loaded columns of cafeteria plates: the last thing you pushed on the stack is the first thing you pop off. That'll do for our purposes: your C program will push some arguments onto &quot;the Perl stack&quot;, shut its eyes while some magic happens, and then pop the results--the return value of your Perl subroutine--off the stack.</source>
          <target state="translated">스택을 설명하려고 할 때, 대부분의 컴퓨터 과학 교과서는 스프링 식 카페테리아 판 열에 대해 무언가를 혼동합니다. 스택에 마지막으로 밀었던 것은 가장 먼저 터지는 것입니다. 그것은 우리의 목적을 위해 할 것입니다 : 당신의 C 프로그램은 어떤 인수를 &quot;펄 스택&quot;에 푸시하고, 어떤 마법이 발생하는 동안 눈을 감고, 그 결과 (펄 서브 루틴의 반환 값)를 스택에서 팝합니다.</target>
        </trans-unit>
        <trans-unit id="d64835545d5a37bef9d2f55b36f2fe943d1540a7" translate="yes" xml:space="preserve">
          <source>When tying a handle, the first argument to &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; should begin with an asterisk. So, if you are tying STDOUT, use &lt;code&gt;*STDOUT&lt;/code&gt; . If you have assigned it to a scalar variable, say &lt;code&gt;$handle&lt;/code&gt; , use &lt;code&gt;*$handle&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt; $handle&lt;/code&gt; ties the scalar variable &lt;code&gt;$handle&lt;/code&gt; , not the handle inside it.</source>
          <target state="translated">핸들을 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 때 첫 번째로 묶을 인수 는 별표로 시작해야합니다. 따라서 STDOUT을 묶는 경우 &lt;code&gt;*STDOUT&lt;/code&gt; 을 사용하십시오 . 이를 스칼라 변수 (예 &lt;code&gt;$handle&lt;/code&gt; 지정한 경우 &lt;code&gt;*$handle&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt; $handle&lt;/code&gt; 은 내부 &lt;code&gt;$handle&lt;/code&gt; 이 아닌 스칼라 변수 $ handle을 묶 습니다.</target>
        </trans-unit>
        <trans-unit id="47eb3f77b1aa39c24f8302cc0873a61651a1ff55" translate="yes" xml:space="preserve">
          <source>When used as a class method (&lt;code&gt;CLASS-&amp;gt;isa( TYPE )&lt;/code&gt; , sometimes referred to as a static method), &lt;code&gt;isa&lt;/code&gt; returns</source>
          <target state="translated">클래스 메소드 ( &lt;code&gt;CLASS-&amp;gt;isa( TYPE )&lt;/code&gt; , 때로는 정적 메소드라고도 함)로 사용될 경우 &lt;code&gt;isa&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="162b9c04aadf8419ca082eaa8547d0e2ff3e950b" translate="yes" xml:space="preserve">
          <source>When used as a filter we want to invoke it like this:</source>
          <target state="translated">필터로 사용될 때 다음과 같이 호출하려고합니다.</target>
        </trans-unit>
        <trans-unit id="b4db60389b8735ef282c0fba599e707380d0e9b0" translate="yes" xml:space="preserve">
          <source>When used as an instance or class method (&lt;code&gt;$obj-&amp;gt;isa( TYPE )&lt;/code&gt; ), &lt;code&gt;isa&lt;/code&gt; returns</source>
          <target state="translated">인스턴스 또는 클래스 메소드 ( &lt;code&gt;$obj-&amp;gt;isa( TYPE )&lt;/code&gt; ) 로 사용될 경우 &lt;code&gt;isa&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="5e6ec0259043a949cd69ad7f24d41a6b32189cc3" translate="yes" xml:space="preserve">
          <source>When used like this, options and their possible values are removed from &lt;code&gt;@myopts&lt;/code&gt; , the global &lt;code&gt;@ARGV&lt;/code&gt; is not touched at all.</source>
          <target state="translated">이와 같이 사용하면 옵션과 가능한 값이 &lt;code&gt;@myopts&lt;/code&gt; 에서 제거되고 전역 &lt;code&gt;@ARGV&lt;/code&gt; 는 전혀 손대지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ea41fdab3a3ea375bf5d28665d083eb7efcab0b4" translate="yes" xml:space="preserve">
          <source>When used like this:</source>
          <target state="translated">이렇게 사용하면 :</target>
        </trans-unit>
        <trans-unit id="55e5fa91bb111ccb9cef7a1998ea49cd864765f0" translate="yes" xml:space="preserve">
          <source>When used on a hash element, it tells you whether the value is defined, not whether the key exists in the hash. Use &lt;a href=&quot;#exists&quot;&gt;exists&lt;/a&gt; for the latter purpose.</source>
          <target state="translated">해시 요소에서 사용될 때 키가 해시에 있는지 여부가 아니라 값이 정의되었는지 여부를 알려줍니다. 사용은 &lt;a href=&quot;#exists&quot;&gt;존재&lt;/a&gt; 후자의 목적을 위해.</target>
        </trans-unit>
        <trans-unit id="9b6188971c7d17d6c416874631a361633fc0e0a7" translate="yes" xml:space="preserve">
          <source>When used on a hash element, it tells you whether the value is defined, not whether the key exists in the hash. Use &lt;a href=&quot;exists&quot;&gt;exists&lt;/a&gt; for the latter purpose.</source>
          <target state="translated">해시 요소에서 사용될 때 키가 해시에 있는지 여부가 아니라 값이 정의되었는지 여부를 알려줍니다. 사용은 &lt;a href=&quot;exists&quot;&gt;존재&lt;/a&gt; 후자의 목적을 위해.</target>
        </trans-unit>
        <trans-unit id="50c2719662a96956c6434b730a2ed7499859c514" translate="yes" xml:space="preserve">
          <source>When used on an element of an array or hash, &lt;code&gt;is_shared&lt;/code&gt; checks if the specified element belongs to a shared array or hash. (It does not check the contents of that element.)</source>
          <target state="translated">배열 또는 해시의 요소에서 사용되는 경우 &lt;code&gt;is_shared&lt;/code&gt; 는 지정된 요소가 공유 배열 또는 해시에 속하는지 확인합니다. 해당 요소의 내용을 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4c68152ee142aad2a08fe0b7ebba2ea1aa45f4fa" translate="yes" xml:space="preserve">
          <source>When used to pass a perl list to C the XS writer must provide a function (named after the array type but with 'Ptr' substituted for '*') to allocate the memory required to hold the list. A pointer should be returned. It is up to the XS writer to free the memory on exit from the function. The variable &lt;code&gt;ix_$var&lt;/code&gt; is set to the number of elements in the new array.</source>
          <target state="translated">Perl 목록을 C로 전달하는 데 사용되는 경우 XS 기록기는 목록을 보유하는 데 필요한 메모리를 할당하는 함수 (배열 유형의 이름을 지정하지만 'Ptr'이 '*'로 대체 됨)를 제공해야합니다. 포인터가 반환되어야합니다. 함수에서 나갈 때 메모리를 비우는 것은 XS 기록기에 달려 있습니다. &lt;code&gt;ix_$var&lt;/code&gt; 변수 는 새 배열의 요소 수로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="39279e0ab9adf92c0d9845ce33153aaae548b141" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;.&lt;/code&gt;, the repeat count determines the starting position to calculate the value offset as follows:</source>
          <target state="translated">와 함께 사용하는 경우 &lt;code&gt;.&lt;/code&gt; 반복 횟수는 다음과 같이 값 오프셋을 계산할 시작 위치를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="059dd6ca0ad7f29f71f81bb70c2d0a3da8cc3820" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;@&lt;/code&gt; , the repeat count represents an offset from the start of the innermost &lt;code&gt;()&lt;/code&gt; group.</source>
          <target state="translated">&lt;code&gt;@&lt;/code&gt; 와 함께 사용될 때 반복 횟수는 가장 안쪽 &lt;code&gt;()&lt;/code&gt; 그룹 의 시작부터 오프셋을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="745e9758fddddfd17b1f8070f37c73b6ef6dd2f4" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;Z&lt;/code&gt; , a &lt;code&gt;*&lt;/code&gt; as the repeat count is guaranteed to add a trailing null byte, so the resulting string is always one byte longer than the byte length of the item itself.</source>
          <target state="translated">함께 사용하면 &lt;code&gt;Z&lt;/code&gt; 하는 &lt;code&gt;*&lt;/code&gt; 결과 문자열이 항목 자체의 바이트 길이보다 한 바이트 이상 항상 있도록 반복 횟수로는, 뒤에 널 바이트를 추가로 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="501ee2b6d5b82410bf49c6ef557d5b8111f9b9e9" translate="yes" xml:space="preserve">
          <source>When used with class methods, the problem is even worse. Because Perl allows subroutine names to be written as barewords, Perl has to guess whether the bareword after the method is a class name or subroutine name. In other words, Perl can resolve the syntax as either &lt;code&gt;File-&amp;gt;new( $path, $data )&lt;/code&gt;&lt;b&gt;or&lt;/b&gt;&lt;code&gt;new( File( $path, $data ) )&lt;/code&gt; .</source>
          <target state="translated">클래스 메소드와 함께 사용하면 문제가 더욱 악화됩니다. Perl에서는 서브 루틴 이름을 베어 워드로 작성할 수 있으므로 Perl은 메소드 뒤의 베어 워드가 클래스 이름인지 서브 루틴 이름인지 추측해야합니다. 즉, Perl은 구문을 &lt;code&gt;File-&amp;gt;new( $path, $data )&lt;/code&gt; &lt;b&gt;또는 &lt;/b&gt; &lt;code&gt;new( File( $path, $data ) )&lt;/code&gt; 로 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f87eff678443c76527dd2ab6f92ce339964a9f84" translate="yes" xml:space="preserve">
          <source>When used with command line options:</source>
          <target state="translated">명령 행 옵션과 함께 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="034d2956d3ab35d5d0a3009bf9f647819ce96d9f" translate="yes" xml:space="preserve">
          <source>When userelocatableinc is true, this variable holds the location that make install should copy the perl binary to, with all the run-time relocatable paths calculated from this at install time. When used, it is initialized to the original value of binexp, and then binexp is set to</source>
          <target state="translated">userelocatableinc가 true 인 경우,이 변수는 설치시 perl 2 진을 복사해야하는 위치를 설치시 모든 런타임 재배치 가능 경로로 계산합니다. 사용하면 binexp의 원래 값으로 초기화되고 binexp는</target>
        </trans-unit>
        <trans-unit id="52d8c19f5d99981fe4c4d2fcb09c34b0b19ca9a0" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&lt;/code&gt; on a &lt;code&gt;()&lt;/code&gt; group, this affects all types inside the group that accept byte-order modifiers, including all subgroups. It is silently ignored for all other types. You are not allowed to override the byte-order within a group that already has a byte-order modifier suffix.</source>
          <target state="translated">&lt;code&gt;()&lt;/code&gt; 그룹 에서 &lt;code&gt;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;&lt;/code&gt; 를 사용하면 모든 하위 그룹을 포함하여 바이트 순서 수정자를 허용하는 그룹 내의 모든 유형에 영향을줍니다. 다른 모든 유형에서는 자동으로 무시됩니다. 이미 바이트 순서 수정 자 접미어가있는 그룹 내에서 바이트 순서를 대체 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="834a7e8ec8b7da2f955444b22e5081d5fee5d139" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;Exporter&lt;/code&gt; with the standard &lt;code&gt;strict&lt;/code&gt; and &lt;code&gt;warnings&lt;/code&gt; pragmas, the &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; keyword is needed to declare the package variables &lt;code&gt;@EXPORT_OK&lt;/code&gt; , &lt;code&gt;@EXPORT&lt;/code&gt; , &lt;code&gt;@ISA&lt;/code&gt; , etc.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;Exporter&lt;/code&gt; 기준으로 &lt;code&gt;strict&lt;/code&gt; 및 &lt;code&gt;warnings&lt;/code&gt; 프라 그마는 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 키워드는 패키지 변수 선언 할 필요가 &lt;code&gt;@EXPORT_OK&lt;/code&gt; , &lt;code&gt;@EXPORT&lt;/code&gt; , &lt;code&gt;@ISA&lt;/code&gt; 등</target>
        </trans-unit>
        <trans-unit id="098b7ca0910242ebfe289953bb787b86df641163" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;IPC::Open3&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, if you provide a string as the &lt;code&gt;command&lt;/code&gt; argument, it is assumed to be appropriately escaped. You can use the &lt;code&gt;QUOTE&lt;/code&gt; constant to use as a portable quote character (see above). However, if you provide an array reference, special rules apply:</source>
          <target state="translated">&lt;code&gt;IPC::Open3&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 을 사용할 때 &lt;code&gt;command&lt;/code&gt; 인수 로 문자열을 제공하면 적절하게 이스케이프 된 것으로 간주됩니다. &lt;code&gt;QUOTE&lt;/code&gt; 상수를 사용하여 이식 가능한 인용 문자로 사용할 수 있습니다 (위 참조). 그러나 배열 참조를 제공하는 경우 특수 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ac72f6ccde75b586d99f93dce2fef690fbdd778e" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;IPC::Run&lt;/code&gt; , if you provide a string as the &lt;code&gt;command&lt;/code&gt; argument, the string will be split on whitespace to determine the individual elements of your command. Although this will usually just Do What You Mean, it may break if you have files or commands with whitespace in them.</source>
          <target state="translated">&lt;code&gt;IPC::Run&lt;/code&gt; 사용할 때 &lt;code&gt;command&lt;/code&gt; 인수 로 문자열을 제공 하면 문자열이 공백으로 분할되어 명령의 개별 요소를 판별합니다. 이것은 일반적으로 의미하는 바를 수행하지만 파일이나 명령에 공백이 있으면 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="887f4ef11aea133bd95f7e158dd018aa1d9071b1" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;autodie&lt;/code&gt; or &lt;code&gt;Fatal&lt;/code&gt; with user subroutines, the declaration of those subroutines must appear before the first use of &lt;code&gt;Fatal&lt;/code&gt; or &lt;code&gt;autodie&lt;/code&gt; , or have been exported from a module. Attempting to use &lt;code&gt;Fatal&lt;/code&gt; or &lt;code&gt;autodie&lt;/code&gt; on other user subroutines will result in a compile-time error.</source>
          <target state="translated">사용자 서브 루틴과 함께 &lt;code&gt;autodie&lt;/code&gt; 또는 &lt;code&gt;Fatal&lt;/code&gt; 을 사용할 때 해당 서브 루틴 선언은 &lt;code&gt;Fatal&lt;/code&gt; 또는 &lt;code&gt;autodie&lt;/code&gt; 를 처음 사용하기 전에 나타나 거나 모듈에서 내 보내야 합니다. 다른 사용자 서브 루틴에서 &lt;code&gt;Fatal&lt;/code&gt; 또는 &lt;code&gt;autodie&lt;/code&gt; 를 사용하려고 하면 컴파일 타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8ea0745997af7ee70fec196994401476b7830212" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;fd_retrieve&lt;/code&gt; , objects are retrieved in sequence, one object (i.e. one recursive tree) per associated &lt;code&gt;store_fd&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;fd_retrieve&lt;/code&gt; 를 사용하면 연관된 &lt;code&gt;store_fd&lt;/code&gt; 당 하나의 오브젝트 (즉, 하나의 재귀 트리)로 오브젝트가 순서대로 검색됩니다 .</target>
        </trans-unit>
        <trans-unit id="e2d48fc5105eb38ba5d5e3af6a3868bf8d76aac7" translate="yes" xml:space="preserve">
          <source>When using GCC, that entry specifies that MakeMaker should first look for &lt;code&gt;libgl.a&lt;/code&gt; (followed by &lt;code&gt;gl.a&lt;/code&gt; ) in all the locations specified by &lt;code&gt;$Config{libpth}&lt;/code&gt; .</source>
          <target state="translated">GCC를 사용할 때, 해당 항목은 MakeMaker가 먼저 &lt;code&gt;$Config{libpth}&lt;/code&gt; 의해 지정된 모든 위치에서 &lt;code&gt;libgl.a&lt;/code&gt; ( gl.a 뒤에)를 &lt;code&gt;gl.a&lt;/code&gt; 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="d3c3fbdf4905ed574790e43ad2b1e958281ade4d" translate="yes" xml:space="preserve">
          <source>When using Module::Build, this will usually be:</source>
          <target state="translated">Module :: Build를 사용할 때 일반적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="04e10d3b847f5d46ec45809bdc9654ea510527e6" translate="yes" xml:space="preserve">
          <source>When using PUSHCOLOR, POPCOLOR, and LOCALCOLOR, it's particularly important to not put commas between the constants.</source>
          <target state="translated">PUSHCOLOR, POPCOLOR 및 LOCALCOLOR를 사용할 때 상수 사이에 쉼표를 사용하지 않는 것이 특히 중요합니다.</target>
        </trans-unit>
        <trans-unit id="0fcdfebaed2e26ac7b40fe2bc2a6520f86b06a73" translate="yes" xml:space="preserve">
          <source>When using Term::ReadLine, you can turn ornaments on so that your input stands out against the output from CPAN.pm.</source>
          <target state="translated">Term :: ReadLine을 사용할 때 입력을 CPAN.pm의 출력과 비교할 수 있도록 장식품을 켤 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bb24a915046f34ce04a56f60336d0fb58d6c025" translate="yes" xml:space="preserve">
          <source>When using Unix or MSDOS syntax this emulates the &lt;code&gt;dirname(1)&lt;/code&gt; shell function which is subtly different from how &lt;code&gt;fileparse()&lt;/code&gt; works. It returns all but the last level of a file path even if the last level is clearly a directory. In effect, it is not returning the directory portion but simply the path one level up acting like &lt;code&gt;&lt;a href=&quot;../functions/chop&quot;&gt;chop()&lt;/a&gt;&lt;/code&gt; for file paths.</source>
          <target state="translated">Unix 또는 MSDOS 구문을 사용 하는 경우 &lt;code&gt;fileparse()&lt;/code&gt; 작동 방식과 약간 다른 &lt;code&gt;dirname(1)&lt;/code&gt; 쉘 함수를 에뮬레이트 합니다. 마지막 레벨이 명확하게 디렉토리 인 경우에도 파일 경로의 마지막 레벨을 제외한 모든 레벨을 리턴합니다. 실제로 디렉토리 부분을 반환하지 않고 단순히 파일 경로에 대해 &lt;code&gt;&lt;a href=&quot;../functions/chop&quot;&gt;chop()&lt;/a&gt;&lt;/code&gt; 처럼 작동하는 경로를 한 단계 높이고 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd36b103bb843eb67404d1ba086bba3444a9a91a" translate="yes" xml:space="preserve">
          <source>When using a compiler other than GCC, the above entry will search for &lt;code&gt;gl.lib&lt;/code&gt; (followed by &lt;code&gt;libgl.lib&lt;/code&gt; ).</source>
          <target state="translated">GCC 이외의 컴파일러를 사용하는 경우 위 항목은 &lt;code&gt;gl.lib&lt;/code&gt; ( libgl.lib가 뒤 &lt;code&gt;libgl.lib&lt;/code&gt; )를 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="a204d7a3df2c41a83e110893f714e673583621f8" translate="yes" xml:space="preserve">
          <source>When using a custom engine that doesn't support the &lt;code&gt;(?:)&lt;/code&gt; construct for inline modifiers, it's probably best to have &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; stringify to the supplied pattern, note that this will create undesired patterns in cases such as:</source>
          <target state="translated">인라인 수정 자에 대해 &lt;code&gt;(?:)&lt;/code&gt; 구문을 지원하지 않는 사용자 정의 엔진을 사용하는 경우 제공된 패턴에 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 문자열을 지정하는 것이 가장 좋습니다 . 다음과 같은 경우에는 원하지 않는 패턴이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="aa29772ff0d1046f60f263e930495cc6300916c4" translate="yes" xml:space="preserve">
          <source>When using a signature, the arguments are still available in the special array variable &lt;code&gt;@_&lt;/code&gt; , in addition to the lexical variables of the signature. There is a difference between the two ways of accessing the arguments: &lt;code&gt;@_&lt;/code&gt;</source>
          <target state="translated">서명을 사용하는 경우 서명 의 어휘 변수 외에 특수 배열 변수 &lt;code&gt;@_&lt;/code&gt; 에서 인수를 계속 사용할 수 있습니다 . 인수에 액세스하는 두 가지 방법 사이에 차이가있다 : &lt;code&gt;@_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="551ef8173c29847114a58bb1f60332f351498c93" translate="yes" xml:space="preserve">
          <source>When using any of these routines (except &lt;code&gt;call_argv&lt;/code&gt; ), the programmer must manipulate the Perl stack. These include the following macros and functions:</source>
          <target state="translated">&lt;code&gt;call_argv&lt;/code&gt; 를 제외한 이러한 루틴을 사용하는 경우 프로그래머는 Perl 스택을 조작해야합니다. 여기에는 다음과 같은 매크로 및 기능이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b83deb7885e7123190175e707dccaec554d080b8" translate="yes" xml:space="preserve">
          <source>When using look-ahead assertions and negations, this can all get even trickier. Imagine you'd like to find a sequence of non-digits not followed by &quot;123&quot;. You might try to write that as</source>
          <target state="translated">미리보기 어설 션과 부정을 사용할 때이 모든 것이 더욱 까다로워 질 수 있습니다. &quot;123&quot;이 아닌 숫자가 아닌 일련의 시퀀스를 찾고 싶다고 상상해보십시오. 다음과 같이 쓰려고 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="104bb1d18df407b49f695cf681f4f8244f6c16f3" translate="yes" xml:space="preserve">
          <source>When using perl on OS/390 please keep in mind that the EBCDIC and ASCII character sets are different. See perlebcdic.pod for more on such character set issues. Perl builtin functions that may behave differently under EBCDIC are also mentioned in the perlport.pod document.</source>
          <target state="translated">OS / 390에서 perl을 사용할 때 EBCDIC 및 ASCII 문자 세트가 다르다는 것을 명심하십시오. 이러한 문자 세트 문제에 대한 자세한 내용은 perlebcdic.pod를 참조하십시오. EBCDIC에서 다르게 작동 할 수있는 Perl 내장 함수는 perlport.pod 문서에도 언급되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ef7e739e319a736386db6464491dd098d4f2bf1" translate="yes" xml:space="preserve">
          <source>When using perldoc in it's &lt;code&gt;-m&lt;/code&gt; mode (display module source code), &lt;code&gt;perldoc&lt;/code&gt; will attempt to use the pager set in &lt;code&gt;PERLDOC_SRC_PAGER&lt;/code&gt; . A useful setting for this command is your favorite editor as in &lt;code&gt;/usr/bin/nano&lt;/code&gt; . (Don't judge me.)</source>
          <target state="translated">perldoc을 &lt;code&gt;-m&lt;/code&gt; 모드 (디스플레이 모듈 소스 코드) 로 사용하는 경우 &lt;code&gt;perldoc&lt;/code&gt; 은 &lt;code&gt;PERLDOC_SRC_PAGER&lt;/code&gt; 에 설정된 페이저 사용을 시도합니다 . 이 명령에 유용한 설정은 &lt;code&gt;/usr/bin/nano&lt;/code&gt; 에서 선호하는 편집기 입니다. (나를 판단하지 마십시오.)</target>
        </trans-unit>
        <trans-unit id="6f3d08e19ee9978bf8615d5e1fb391a30ff5fc30" translate="yes" xml:space="preserve">
          <source>When using the &quot;syn&quot; protocol, use this method to determine the reachability of the remote host. This method is meant to be called up to as many times as ping() was called. Each call returns the host (as passed to ping()) that came back with the TCP ACK. The order in which the hosts are returned may not necessarily be the same order in which they were SYN queued using the ping() method. If the timeout is reached before the TCP ACK is received, or if the remote host is not listening on the port attempted, then the TCP connection will not be established and ack() will return undef. In list context, the host, the ack time, and the dotted ip string will be returned instead of just the host. If the optional $host argument is specified, the return value will be pertaining to that host only. This call simply does nothing if you are using any protocol other than syn.</source>
          <target state="translated">&quot;syn&quot;프로토콜을 사용할 때이 방법을 사용하여 원격 호스트의 도달 가능성을 판별하십시오. 이 메소드는 ping ()이 호출 된 횟수만큼 호출됩니다. 각 호출은 TCP ACK와 함께 제공된 호스트 (ping ()에 전달됨)를 반환합니다. 호스트가 리턴되는 순서는 반드시 ping () 메소드를 사용하여 SYN 큐된 순서와 반드시 같을 필요는 없습니다. TCP ACK가 수신되기 전에 시간 초과에 도달하거나 원격 호스트가 시도한 포트에서 수신 대기하지 않으면 TCP 연결이 설정되지 않고 ack ()이 undef를 반환합니다. 목록 컨텍스트에서 호스트, ack 시간 및 점으로 구분 된 IP 문자열이 호스트 대신 반환됩니다. 선택적 $ host 인수가 지정되면 리턴 값은 해당 호스트에만 관련됩니다.syn 이외의 프로토콜을 사용하는 경우이 호출은 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8669a447d2a5338b38de691880feda228a223459" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;+&lt;/code&gt; prototype, your function must check that the argument is of an acceptable type.</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 프로토 타입을 사용할 때 함수는 인수가 허용 가능한 유형인지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="665e3521b5bde08e89b6fb412400db5ea3876686" translate="yes" xml:space="preserve">
          <source>When using the Borland compiler, the second item is returned as &lt;code&gt;-Ld:\mesalibs mesa.lib user32.lib&lt;/code&gt;, and MakeMaker takes care of moving the &lt;code&gt;-Ld:\mesalibs&lt;/code&gt; to the correct place in the linker command line.</source>
          <target state="translated">Borland 컴파일러를 사용할 때 두 번째 항목은 &lt;code&gt;-Ld:\mesalibs mesa.lib user32.lib&lt;/code&gt; 로 리턴되며 MakeMaker 는 &lt;code&gt;-Ld:\mesalibs&lt;/code&gt; 를 링커 명령 행의 올바른 위치로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="182973d530ef056d12686b9b768cbe121c56d846" translate="yes" xml:space="preserve">
          <source>When using the GUI version of SAM, click on the Kernel Configuration icon, then the Configurable Parameters icon. Scroll down and select the maxdsiz line. From the Actions menu, select the Modify Configurable Parameter item. Insert the new formula into the Formula/Value box. Then follow the instructions to rebuild your kernel and reboot your system.</source>
          <target state="translated">SAM의 GUI 버전을 사용하는 경우 커널 구성 아이콘을 클릭 한 다음 구성 가능한 매개 변수 아이콘을 클릭하십시오. 아래로 스크롤하여 maxdsiz 줄을 선택하십시오. 조치 메뉴에서 구성 가능한 매개 변수 수정 항목을 선택하십시오. 새 수식을 수식 / 값 상자에 삽입하십시오. 그런 다음 지침에 따라 커널을 다시 빌드하고 시스템을 재부팅하십시오.</target>
        </trans-unit>
        <trans-unit id="7f3f457ad81c7a19053f3621a5ae319fe9cb4521" translate="yes" xml:space="preserve">
          <source>When using the Visual C compiler, the second item is returned as &lt;code&gt;-libpath:d:\mesalibs mesa.lib user32.lib&lt;/code&gt;.</source>
          <target state="translated">Visual C 컴파일러를 사용할 때 두 번째 항목은 &lt;code&gt;-libpath:d:\mesalibs mesa.lib user32.lib&lt;/code&gt; 로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="fa76c289706bb600b3c9b3e3777d7935b3662cb5" translate="yes" xml:space="preserve">
          <source>When using the constants, if you don't want to have to remember to add the &lt;code&gt;, RESET&lt;/code&gt; at the end of each print line, you can set $Term::ANSIColor::AUTORESET to a true value. Then, the display mode will automatically be reset if there is no comma after the constant. In other words, with that variable set:</source>
          <target state="translated">상수를 사용할 때 각 인쇄 줄 끝에 &lt;code&gt;, RESET&lt;/code&gt; 을 추가하지 않아도되는 경우 $ Term :: ANSIColor :: AUTORESET을 true로 설정할 수 있습니다. 그러면 상수 다음에 쉼표가 없으면 디스플레이 모드가 자동으로 재설정됩니다. 즉, 해당 변수가 설정된 경우 :</target>
        </trans-unit>
        <trans-unit id="a51c1c8c0eb3074d9df3759b3281e7508c8091a5" translate="yes" xml:space="preserve">
          <source>When using this compiler to build Perl, you should make sure that the flag -Aa is added to the cpprun and cppstdin variables in the config.sh file (though see the section on 64-bit perl below). If you are using a recent version of the Perl distribution, these flags are set automatically.</source>
          <target state="translated">이 컴파일러를 사용하여 Perl을 빌드 할 때 -Aa 플래그가 config.sh 파일의 cpprun 및 cppstdin 변수에 추가되어 있는지 확인해야합니다 (아래 64 비트 perl 섹션 참조). 최신 버전의 Perl 분배를 사용중인 경우이 플래그가 자동으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="9d278a4b7e876e4a2527267176d89369b93fdace" translate="yes" xml:space="preserve">
          <source>When verifying an existing digest string you should use the digest as the salt (like &lt;code&gt;&lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ). The SALT used to create the digest is visible as part of the digest. This ensures crypt() will hash the new string with the same salt as the digest. This allows your code to work with the standard &lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt; and with more exotic implementations. In other words, assume nothing about the returned string itself nor about how many bytes of SALT may matter.</source>
          <target state="translated">기존 다이제스트 문자열을 확인할 때 다이제스트를 소금으로 사용해야합니다 (예 : &lt;code&gt;&lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ). 다이제스트를 만드는 데 사용 된 SALT는 다이제스트의 일부로 표시됩니다. 이렇게하면 crypt ()가 다이제스트와 동일한 소금으로 새 문자열을 해시합니다. 이를 통해 코드가 표준 &lt;a href=&quot;crypt&quot;&gt;암호화&lt;/a&gt; 및보다 이국적인 구현과 함께 작동 할 수 있습니다 . 다시 말해, 반환 된 문자열 자체 나 SALT 바이트 수에 대해서는 아무 것도 가정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1154d04d428d0c152c2ffba2d49aad6c93079515" translate="yes" xml:space="preserve">
          <source>When verifying an existing digest string you should use the digest as the salt (like &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ). The SALT used to create the digest is visible as part of the digest. This ensures crypt() will hash the new string with the same salt as the digest. This allows your code to work with the standard &lt;a href=&quot;#crypt&quot;&gt;crypt&lt;/a&gt; and with more exotic implementations. In other words, assume nothing about the returned string itself nor about how many bytes of SALT may matter.</source>
          <target state="translated">기존 다이제스트 문자열을 확인할 때 다이제스트를 소금으로 사용해야합니다 (예 : &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ). 다이제스트를 만드는 데 사용 된 SALT는 다이제스트의 일부로 표시됩니다. 이렇게하면 crypt ()가 다이제스트와 동일한 소금으로 새 문자열을 해시합니다. 이를 통해 코드가 표준 &lt;a href=&quot;#crypt&quot;&gt;암호화&lt;/a&gt; 및보다 이국적인 구현과 함께 작동 할 수 있습니다 . 다시 말해, 반환 된 문자열 자체 나 SALT 바이트 수에 대해서는 아무 것도 가정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3ffe4a395b717a174f8af1eb199172f9bf8e1018" translate="yes" xml:space="preserve">
          <source>When we bless something, we are not blessing the variable which contains a reference to that thing, nor are we blessing the reference that the variable stores; we are blessing the thing that the variable refers to (sometimes known as the</source>
          <target state="translated">우리가 무언가를 축복 할 때, 우리는 그 것에 대한 언급을 포함하는 변수를 축복하지 않으며, 변수가 저장하는 참조를 축복하지도 않습니다. 우리는 변수가 말하는 것을 축복하고 있습니다 (때때로</target>
        </trans-unit>
        <trans-unit id="7f1d89cf9a7bec3f0e241604b9f6d2928198590e" translate="yes" xml:space="preserve">
          <source>When we call &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; on a variable, we are actually blessing the underlying data structure that the variable refers to. We are not blessing the reference itself, nor the variable that contains that reference. That's why the second call to &lt;code&gt;blessed( $bar )&lt;/code&gt; returns false. At that point &lt;code&gt;$bar&lt;/code&gt; is no longer storing a reference to an object.</source>
          <target state="translated">변수에 대해 &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 이라고 부르면 실제로 변수가 참조하는 기본 데이터 구조를 축복하는 것입니다. 우리는 참조 자체 나 그 참조를 포함하는 변수를 축복하지 않습니다. 이것이 &lt;code&gt;blessed( $bar )&lt;/code&gt; 대한 두 번째 호출이 false를 반환 하는 이유 입니다. 이 시점에서 &lt;code&gt;$bar&lt;/code&gt; 는 더 이상 객체에 대한 참조를 저장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c70879bf53ea832ca0790a74069f648240179f77" translate="yes" xml:space="preserve">
          <source>When we make a method call, Perl arranges for the method's &lt;b&gt;invocant&lt;/b&gt; to be passed as the first argument. &lt;b&gt;Invocant&lt;/b&gt; is a fancy name for the thing on the left side of the arrow. The invocant can either be a class name or an object. We can also pass additional arguments to the method:</source>
          <target state="translated">우리가 메서드 호출을 할 때, 방법의 펄 주선 &lt;b&gt;invocant는&lt;/b&gt; 첫 번째 인수로 전달합니다. &lt;b&gt;옹호자&lt;/b&gt; 는 화살의 왼쪽에있는 물건의 멋진 이름입니다. 호출자는 클래스 이름 또는 오브젝트 일 수 있습니다. 메소드에 추가 인수를 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e5660d78c1c3767afae15f24a83c561307c4b20" translate="yes" xml:space="preserve">
          <source>When we say &quot;Mac OS&quot; below, we mean Mac OS 7, 8, and 9, and</source>
          <target state="translated">아래에서 &quot;Mac OS&quot;라고하면 Mac OS 7, 8 및 9를 의미하며</target>
        </trans-unit>
        <trans-unit id="32e492af43a84b7607b727f8ffe43ea47c5296c8" translate="yes" xml:space="preserve">
          <source>When we want to place values to be returned to the caller onto the stack, we use the series of macros that begin with &quot;XPUSH&quot;. There are five different versions, for placing integers, unsigned integers, doubles, strings, and Perl scalars on the stack. In our example, we placed a Perl scalar onto the stack. (In fact this is the only macro which can be used to return multiple values.)</source>
          <target state="translated">호출자에게 반환 될 값을 스택에 배치하려면 &quot;XPUSH&quot;로 시작하는 일련의 매크로를 사용합니다. 스택에 정수, 부호없는 정수, 복식, 문자열 및 Perl 스칼라를 배치하기위한 5 가지 버전이 있습니다. 이 예에서는 스택에 Perl 스칼라를 배치했습니다. 실제로 이것은 여러 값을 반환하는 데 사용할 수있는 유일한 매크로입니다.</target>
        </trans-unit>
        <trans-unit id="5c32617504af087d7eaf74d60f9f81f18d15e5a1" translate="yes" xml:space="preserve">
          <source>When words that are longer than &lt;code&gt;$columns&lt;/code&gt; are encountered, they are broken up. &lt;code&gt;wrap()&lt;/code&gt; adds a &lt;code&gt;&quot;\n&quot;&lt;/code&gt; at column &lt;code&gt;$columns&lt;/code&gt; . This behavior can be overridden by setting &lt;code&gt;$huge&lt;/code&gt; to 'die' or to 'overflow'. When set to 'die', large words will cause &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; to be called. When set to 'overflow', large words will be left intact.</source>
          <target state="translated">&lt;code&gt;$columns&lt;/code&gt; 보다 긴 단어 가 발견되면 나뉩니다. &lt;code&gt;wrap()&lt;/code&gt; 은 &lt;code&gt;$columns&lt;/code&gt; 열에 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 을 추가합니다 . &lt;code&gt;$huge&lt;/code&gt; 를 'die'또는 'overflow' 로 설정하면이 동작을 무시할 수 있습니다 . 'die'로 설정하면 큰 단어로 인해 &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; 가 호출됩니다. '오버플로'로 설정하면 큰 단어가 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="52a8fd5862d63d0243193e3a0106e35c7816b525" translate="yes" xml:space="preserve">
          <source>When writing a DBM filter it is</source>
          <target state="translated">DBM 필터를 작성할 때</target>
        </trans-unit>
        <trans-unit id="6e29ef5da6dd2ada1107f66b4d19daef44972a34" translate="yes" xml:space="preserve">
          <source>When writing a Perl extension for general consumption, one should expect that the extension will be used with versions of Perl different from the version available on your machine. Since you are reading this document, the version of Perl on your machine is probably 5.005 or later, but the users of your extension may have more ancient versions.</source>
          <target state="translated">일반적인 소비를 위해 Perl 확장을 작성할 때 확장은 시스템에서 사용 가능한 버전과 다른 Perl 버전과 함께 사용될 것으로 예상해야합니다. 이 문서를 읽고 있으므로 컴퓨터의 Perl 버전은 5.005 이상일 수 있지만 확장 사용자에게는 더 오래된 버전이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b339c5d874b742d033a9c15bc59a2eb32b3fde03" translate="yes" xml:space="preserve">
          <source>When writing a character UV to a UTF-8 string, &lt;b&gt;always&lt;/b&gt; use &lt;code&gt;uvchr_to_utf8&lt;/code&gt; , unless &lt;code&gt;UVCHR_IS_INVARIANT(uv))&lt;/code&gt; in which case you can use &lt;code&gt;*s = uv&lt;/code&gt; .</source>
          <target state="translated">UTF-8 문자열에 UV 문자를 쓸 때 &lt;code&gt;UVCHR_IS_INVARIANT(uv))&lt;/code&gt; 아닌 경우 &lt;b&gt;항상 &lt;/b&gt; &lt;code&gt;uvchr_to_utf8&lt;/code&gt; 을 사용 하십시오 . 이 경우 &lt;code&gt;*s = uv&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f50a991a4544cc3b4a29ac32fb9e95a158b8cf9" translate="yes" xml:space="preserve">
          <source>When writing a gzip file this interface will</source>
          <target state="translated">gzip 파일을 작성할 때이 인터페이스는</target>
        </trans-unit>
        <trans-unit id="bb628954db56a328fb9c77ac1ab1c6c9e5566f04" translate="yes" xml:space="preserve">
          <source>When writing to a file or filehandle, set &lt;code&gt;&lt;a href=&quot;../../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; before writing to the file.</source>
          <target state="translated">파일 또는 파일 핸들에 쓸 때는 파일에 쓰기 전에 &lt;code&gt;&lt;a href=&quot;../../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 를 설정 하십시오.</target>
        </trans-unit>
        <trans-unit id="b83d473ca051f901386a9b5075ab3cc8642b96d1" translate="yes" xml:space="preserve">
          <source>When you</source>
          <target state="translated">때를</target>
        </trans-unit>
        <trans-unit id="2677cbf7ed31e30ff85aaafd2211c14bcf4260ba" translate="yes" xml:space="preserve">
          <source>When you are content with suspects list, you can now</source>
          <target state="translated">용의자 목록에 만족하면 이제</target>
        </trans-unit>
        <trans-unit id="2f2f89e3cbdda44107d5b7350f0150202920760d" translate="yes" xml:space="preserve">
          <source>When you are done, the XS-module install process will have added information to your &quot;perllocal&quot; information telling that the perl binary has been replaced, and what module was installed. You can view this information at any time by using the command:</source>
          <target state="translated">완료되면 XS 모듈 설치 프로세스는 &quot;perllocal&quot;정보에 perl 바이너리가 교체되었음을 알리는 정보와 설치된 모듈을 추가합니다. 다음 명령을 사용하여 언제든지이 정보를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="081b49cdc45047c15c231503ee57d721c9ac98ea" translate="yes" xml:space="preserve">
          <source>When you are going to use the GNU C compiler (gcc), and you don't have gcc yet, you can either build it yourself from the sources (available from e.g. &lt;a href=&quot;http://gcc.gnu.org/mirrors.html&quot;&gt;http://gcc.gnu.org/mirrors.html&lt;/a&gt;) or fetch a prebuilt binary from the HP porting center at &lt;a href=&quot;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&quot;&gt;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&lt;/a&gt; or from the DSPP (you need to be a member) at &lt;a href=&quot;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&quot;&gt;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&lt;/a&gt; (Browse through the list, because there are often multiple versions of the same package available).</source>
          <target state="translated">GNU C 컴파일러 (gcc)를 사용하려고하는데 아직 gcc가없는 경우 소스에서 직접 빌드 할 수 있습니다 (예 : &lt;a href=&quot;http://gcc.gnu.org/mirrors.html&quot;&gt;http://gcc.gnu.org/mirrors.html&lt;/a&gt; ) 또는 HP 포팅 센터 ( &lt;a href=&quot;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&quot;&gt;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search)&lt;/a&gt; 또는 &lt;a href=&quot;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&quot;&gt;http&lt;/a&gt; ( http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search= 검색) 에서 사전 빌드 된 바이너리를 가져옵니다. : //h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801? ciid = 2a08725cc2f02110725cc2f02110275d6e10RCRD &amp;amp; jumpid = reg_r1002_usen_c-001_title_r0001 과 동일하기 때문에 여러 패키지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e1fba30b9427287c1016e2b2ee037287889c225" translate="yes" xml:space="preserve">
          <source>When you are manually creating a UCM file, you should copy ascii.ucm or an existing encoding which is close to yours, rather than write your own from scratch.</source>
          <target state="translated">UCM 파일을 수동으로 작성하는 경우, 처음부터 직접 작성하지 않고 ascii.ucm 또는 기존 인코딩과 가까운 인코딩을 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="4780d196081ec9146c3e56c719b52c3ce1654983" translate="yes" xml:space="preserve">
          <source>When you are satisfied with the results of tests, install the build C libraries for extensions:</source>
          <target state="translated">테스트 결과에 만족하면 확장을위한 빌드 C 라이브러리를 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="a59f72a1e66eb8909341fcc7e63f4b0c726287dd" translate="yes" xml:space="preserve">
          <source>When you are sure that only a few subdirectories lead to failures, you may want to add &lt;code&gt;-j4&lt;/code&gt; option to &lt;code&gt;make&lt;/code&gt; to speed up skipping subdirectories with already finished build.</source>
          <target state="translated">당신이 확실 몇 하위 디렉토리가 실패로 이어질 것을 때, 당신은 추가 할 수 있습니다 &lt;code&gt;-j4&lt;/code&gt; 에 옵션을 &lt;code&gt;make&lt;/code&gt; 이미 완성 된 빌드 서브 디렉토리를 건너 뛰는 속도를.</target>
        </trans-unit>
        <trans-unit id="c0610c400691e07d6b5c5967ea7cb5f197bdd7da" translate="yes" xml:space="preserve">
          <source>When you are using the &quot;stream&quot; protocol, this call pre-opens the tcp socket. It's only necessary to do this if you want to provide a different timeout when creating the connection, or remove the overhead of establishing the connection from the first ping. If you don't call &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, the connection is automatically opened the first time &lt;code&gt;ping()&lt;/code&gt; is called. This call simply does nothing if you are using any protocol other than stream.</source>
          <target state="translated">&quot;스트림&quot;프로토콜을 사용하는 경우이 호출은 tcp 소켓을 미리 엽니 다. 연결을 만들 때 다른 시간 초과를 제공하거나 첫 번째 핑에서 연결을 설정하는 오버 헤드를 제거하려는 경우에만이 작업을 수행하면됩니다. &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 호출하지 않으면 &lt;code&gt;ping()&lt;/code&gt; 처음 호출 할 때 연결이 자동으로 열립니다 . 이 호출은 스트림 이외의 프로토콜을 사용하는 경우 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a9fd269eddc721c08a06a789973e8783627db576" translate="yes" xml:space="preserve">
          <source>When you build modules, tell Perl where to install the modules.</source>
          <target state="translated">모듈을 빌드 할 때 Perl에게 모듈을 설치할 위치를 알려주십시오.</target>
        </trans-unit>
        <trans-unit id="d2efe854f0b34964ee2879b9748bb899c2079d18" translate="yes" xml:space="preserve">
          <source>When you call &lt;code&gt;bar&lt;/code&gt; with arguments, you see that &lt;code&gt;foo&lt;/code&gt; got the same &lt;code&gt;@_&lt;/code&gt; :</source>
          <target state="translated">인수와 함께 &lt;code&gt;bar&lt;/code&gt; 를 호출하면 &lt;code&gt;foo&lt;/code&gt; 가 동일한 &lt;code&gt;@_&lt;/code&gt; 를 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="010f5217ea46f708fe21b0efa65632329708b27e" translate="yes" xml:space="preserve">
          <source>When you call a method, the thing on the left side of the arrow is passed as the first argument to the method. That means when we call &lt;code&gt;Critter-&amp;gt;new()&lt;/code&gt; , the &lt;code&gt;new()&lt;/code&gt; method receives the string &lt;code&gt;&quot;Critter&quot;&lt;/code&gt; as its first argument. When we call &lt;code&gt;$fred-&amp;gt;speak()&lt;/code&gt; , the &lt;code&gt;$fred&lt;/code&gt; variable is passed as the first argument to &lt;code&gt;speak()&lt;/code&gt; .</source>
          <target state="translated">메소드를 호출하면 화살표의 왼쪽에있는 것이 메소드의 첫 번째 인수로 전달됩니다. 즉 , &lt;code&gt;Critter-&amp;gt;new()&lt;/code&gt; 호출 하면 &lt;code&gt;new()&lt;/code&gt; 메서드는 첫 번째 인수로 문자열 &lt;code&gt;&quot;Critter&quot;&lt;/code&gt; 를 받습니다 . &lt;code&gt;$fred-&amp;gt;speak()&lt;/code&gt; 호출 하면 &lt;code&gt;$fred&lt;/code&gt; 변수가 &lt;code&gt;speak()&lt;/code&gt; 의 첫 번째 인수로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="f9ac7d5348373bdb94113353aa9433d2aa26a56e" translate="yes" xml:space="preserve">
          <source>When you change a &lt;b&gt;value&lt;/b&gt; as it is being copied. [From French &amp;ldquo;in passing&amp;rdquo;, as in the exotic pawn-capturing maneuver in chess.]</source>
          <target state="translated">&lt;b&gt;값&lt;/b&gt; 을 복사 할 때 &lt;b&gt;값&lt;/b&gt; 을 변경할 때 [체스에서 이국적인 전당포를 잡는 작전에서와 같이 프랑스어에서 &quot;통과 중&quot;.</target>
        </trans-unit>
        <trans-unit id="f19e6c82fbc2b2542cdae76f95f1a0c2e0deb19b" translate="yes" xml:space="preserve">
          <source>When you chop() a mathemagical object it is promoted to a string and its mathemagical properties are lost. The same can happen with other operations as well.</source>
          <target state="translated">mathemagical 객체를 chop ()하면 문자열로 승격되고 mathemagical 속성이 손실됩니다. 다른 작업에서도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="ffb591449d98f90fa2f19a8fc5d8c220dd517b21" translate="yes" xml:space="preserve">
          <source>When you combine legacy data and Unicode, the legacy data needs to be upgraded to Unicode. Normally the legacy data is assumed to be ISO 8859-1 (or EBCDIC, if applicable).</source>
          <target state="translated">레거시 데이터와 유니 코드를 결합 할 경우 레거시 데이터를 유니 코드로 업그레이드해야합니다. 일반적으로 레거시 데이터는 ISO 8859-1 (또는 해당되는 경우 EBCDIC) 인 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="177eeefc399a73cfd5bfb70b98c9df5de8601114" translate="yes" xml:space="preserve">
          <source>When you create a map, you SHOULD make your mappings round-trip safe. That is, &lt;code&gt;encode('your-encoding', decode('your-encoding', $data)) eq
$data&lt;/code&gt; stands for all characters that are marked as &lt;code&gt;|0&lt;/code&gt;. Here is how to make sure:</source>
          <target state="translated">지도를 만들 때 안전하게 왕복 여행을해야합니다. 즉, &lt;code&gt;encode('your-encoding', decode('your-encoding', $data)) eq $data&lt;/code&gt; 는 &lt;code&gt;|0&lt;/code&gt; 으로 표시된 모든 문자를 나타냅니다 . 확인하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bb9cd7b8a4ff60818aa2eb01184f94103173f0c2" translate="yes" xml:space="preserve">
          <source>When you declare a constant such as &lt;code&gt;PI&lt;/code&gt; using the method shown above, each machine your script runs upon can have as many digits of accuracy as it can use. Also, your program will be easier to read, more likely to be maintained (and maintained correctly), and far less likely to send a space probe to the wrong planet because nobody noticed the one equation in which you wrote &lt;code&gt;3.14195&lt;/code&gt; .</source>
          <target state="translated">위에 표시된 방법을 사용하여 &lt;code&gt;PI&lt;/code&gt; 와 같은 상수를 선언하면 스크립트가 실행되는 각 컴퓨터는 사용할 수있는만큼의 정확도를 가질 수 있습니다. 또한 프로그램이 읽기 쉽고, 유지 보수 (정확하게 유지) 될 가능성이 높으며, &lt;code&gt;3.14195&lt;/code&gt; 라는 한 방정식을 아무도 모르기 때문에 우주 탐사선을 잘못된 행성에 보낼 가능성이 훨씬 낮 습니다 .</target>
        </trans-unit>
        <trans-unit id="34ad5430f738cd6a6ba4f6afa7a8297067c10fdd" translate="yes" xml:space="preserve">
          <source>When you decode(=?</source>
          <target state="translated">해독 할 때 (=?</target>
        </trans-unit>
        <trans-unit id="1f9cd5bf8b9a9dc5c6c543459671e6a174da6ded" translate="yes" xml:space="preserve">
          <source>When you decode, &lt;code&gt;\x&lt;i&gt;HH&lt;/i&gt;&lt;/code&gt; is inserted for a malformed character, where</source>
          <target state="translated">디코딩 할 때 잘못된 문자에 대해 &lt;code&gt;\x&lt;i&gt;HH&lt;/i&gt;&lt;/code&gt; 가 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="8f3fe5c47178db8be10e4d3c50152806e0a7dfbf" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;pullparser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt; object, you might get an object of this class.</source>
          <target state="translated">&lt;a href=&quot;pullparser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt; 객체에서 $ parser-&amp;gt; get_token을 수행하면 이 클래스의 객체를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdee2ab8e3f283c88595afe8fae4920b1af2e43f" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;pullparser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt;, you might get an object of this class.</source>
          <target state="translated">&lt;a href=&quot;pullparser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt; 에서 $ parser-&amp;gt; get_token을 수행하면 이 클래스의 객체를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e49f09f58c9d01d7e0d1ab18e02275ef3d85f650" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;pullparser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt;, you should get an object of a subclass of Pod::Simple::PullParserToken.</source>
          <target state="translated">&lt;a href=&quot;pullparser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt; 에서 $ parser-&amp;gt; get_token을 수행하면 Pod :: Simple :: PullParserToken 서브 클래스의 객체를 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="e5d10bb84f2ae2965aec52096372e0823e1ccc9f" translate="yes" xml:space="preserve">
          <source>When you do an open() and specify extra PerlIO layers to be deployed, the layers you specify are &quot;pushed&quot; on top of the already existing default stack. One way to see it is that &quot;operating system is on the left&quot; and &quot;Perl is on the right&quot;.</source>
          <target state="translated">open ()을 수행하고 배포 할 추가 PerlIO 레이어를 지정하면 지정한 레이어가 이미 존재하는 기본 스택 위에 &quot;푸시&quot;됩니다. 이를 확인하는 한 가지 방법은 &quot;운영 체제가 왼쪽에 있고&quot;및 &quot;펄이 오른쪽에 있다는 것&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="deae100a89ba77dc88cb549c116cc2863e7500d7" translate="yes" xml:space="preserve">
          <source>When you do so, make sure you leave at least &lt;b&gt;U0000&lt;/b&gt; to &lt;b&gt;U0020&lt;/b&gt; as is, unless your environment is EBCDIC.</source>
          <target state="translated">그렇게 할 때 환경이 EBCDIC이 아닌 경우 최소한 &lt;b&gt;U0000&lt;/b&gt; ~ &lt;b&gt;U0020&lt;/b&gt; 을 그대로 두십시오 .</target>
        </trans-unit>
        <trans-unit id="5f9d98bf0fca35661c7810840d0018afb1d2ce55" translate="yes" xml:space="preserve">
          <source>When you do this, you replace ordinary Perl ops with custom ops by creating ops with the type &lt;code&gt;OP_CUSTOM&lt;/code&gt; and the &lt;code&gt;op_ppaddr&lt;/code&gt; of your own PP function. This should be defined in XS code, and should look like the PP ops in &lt;code&gt;pp_*.c&lt;/code&gt;. You are responsible for ensuring that your op takes the appropriate number of values from the stack, and you are responsible for adding stack marks if necessary.</source>
          <target state="translated">이 작업을 수행하면 &lt;code&gt;OP_CUSTOM&lt;/code&gt; 유형 과 자체 PP 기능 의 &lt;code&gt;op_ppaddr&lt;/code&gt; 로 op를 작성하여 일반 Perl op를 사용자 정의 op로 대체 하십시오. 이것은 XS 코드로 정의되어야하며 &lt;code&gt;pp_*.c&lt;/code&gt; 의 PP ops와 같아야합니다 . 귀하는 op가 스택에서 적절한 수의 값을 가져 오는지 확인해야하며 필요한 경우 스택 표시를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="f0737e549db78c3f56b6cebadc591bd894132914" translate="yes" xml:space="preserve">
          <source>When you encode, it just encodes UTF-8 string with</source>
          <target state="translated">인코딩 할 때 UTF-8 문자열 만 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="2cb93abd34cd25594e79f391f2b423cc436f1f2e" translate="yes" xml:space="preserve">
          <source>When you execute this script, Perl creates a source stream for the file. Before the parser processes any of the lines from the file, the source stream looks like this:</source>
          <target state="translated">이 스크립트를 실행하면 Perl은 파일의 소스 스트림을 작성합니다. 파서는 파일에서 행을 처리하기 전에 소스 스트림은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="542d61dee2b7e163e5110ea366ba8573d821b115" translate="yes" xml:space="preserve">
          <source>When you get tired of writing a custom print for your data structures, you might look at the standard &lt;a href=&quot;dumpvalue&quot;&gt;Dumpvalue&lt;/a&gt; or &lt;a href=&quot;data/dumper&quot;&gt;Data::Dumper&lt;/a&gt; modules. The former is what the Perl debugger uses, while the latter generates parsable Perl code. For example:</source>
          <target state="translated">데이터 구조에 대한 사용자 정의 인쇄를 작성하는 데 &lt;a href=&quot;dumpvalue&quot;&gt;지치면&lt;/a&gt; 표준 Dumpvalue 또는 &lt;a href=&quot;data/dumper&quot;&gt;Data :: Dumper&lt;/a&gt; 모듈을 볼 수 있습니다. 전자는 Perl 디버거가 사용하는 것이고 후자는 파싱 가능한 Perl 코드를 생성합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="18b18f51c5b3a1ef29698b4db45e17c63b163a2a" translate="yes" xml:space="preserve">
          <source>When you have Module::Build installed and a module comes with both a Makefile.PL and a Build.PL, which shall have precedence?</source>
          <target state="translated">Module :: Build가 설치되어 있고 모듈에 Makefile.PL과 Build.PL이 함께 제공되는 경우 우선 순위는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="90be52d2f2a07a95a09a611578f9d43f7cd9edea" translate="yes" xml:space="preserve">
          <source>When you have Term::ANSIColor installed, you can turn on colorized output to have some visual differences between normal CPAN.pm output, warnings, debugging output, and the output of the modules being installed. Set your favorite colors after some experimenting with the Term::ANSIColor module.</source>
          <target state="translated">Term :: ANSIColor를 설치 한 경우 일반 CPAN.pm 출력, 경고, 디버깅 출력 및 설치중인 모듈의 출력간에 시각적 차이가 있도록 색상 화 된 출력을 켤 수 있습니다. Term :: ANSIColor 모듈을 실험 한 후 원하는 색상을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="805d35dab8fe4274cb0dab9ee72a05d301e431cf" translate="yes" xml:space="preserve">
          <source>When you have a &lt;code&gt;$normalized&lt;/code&gt; string and an &lt;code&gt;$unnormalized&lt;/code&gt; string following it, a simple concatenation is wrong:</source>
          <target state="translated">당신이있을 때 &lt;code&gt;$normalized&lt;/code&gt; 문자열과 &lt;code&gt;$unnormalized&lt;/code&gt; 를 다음 문자열을, 간단한 연결은 잘못된 것입니다 :</target>
        </trans-unit>
        <trans-unit id="5fc33624ab4cb034a50a1d77e4381e870301d931" translate="yes" xml:space="preserve">
          <source>When you have a duplicate entry, mark either one with '|1' or '|3'.</source>
          <target state="translated">중복 된 항목이 있으면 '| 1'또는 '| 3'으로 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="c0776eaeac3f4218a7b8598aad81420ef0246911" translate="yes" xml:space="preserve">
          <source>When you list the arguments to the XSUB in the .xs file, that tells &lt;b&gt;xsubpp&lt;/b&gt; which argument corresponds to which of the argument stack (i.e., the first one listed is the first argument, and so on). You invite disaster if you do not list them in the same order as the function expects them.</source>
          <target state="translated">.xs 파일에 XSUB에 대한 인수를 나열하면 &lt;b&gt;xsubpp&lt;/b&gt; 에게 인수 스택의 어느 인수에 해당하는 인수가 있는지 &lt;b&gt;xsubpp&lt;/b&gt; 에 알려줍니다 (즉, 첫 번째 인수는 첫 번째 인수 등). 기능이 예상하는 순서대로 나열하지 않으면 재해를 초대합니다.</target>
        </trans-unit>
        <trans-unit id="4fe7c5d2090255d1c2f0cf1a507f4b889f93bbfd" translate="yes" xml:space="preserve">
          <source>When you make a script executable, in order to make it usable as a command, the system will pass switches to perl from the script's #! line. Perl checks that any command line switches given to a setuid (or setgid) script actually match the ones set on the #! line. Some Unix and Unix-like environments impose a one-switch limit on the #! line, so you may need to use something like &lt;code&gt;-wU&lt;/code&gt; instead of &lt;code&gt;-w -U&lt;/code&gt; under such systems. (This issue should arise only in Unix or Unix-like environments that support #! and setuid or setgid scripts.)</source>
          <target state="translated">스크립트를 실행 가능하게하면 명령으로 사용 가능하게하기 위해 시스템은 스크립트의 #!에서 스위치를 perl로 전달합니다. 선. Perl은 setuid (또는 setgid) 스크립트에 제공된 명령 행 스위치가 실제로 #!에 설정된 명령 행 스위치와 일치하는지 확인합니다. 선. 일부 유닉스 및 유닉스 계열 환경은 #! 이러한 시스템 에서는 &lt;code&gt;-w -U&lt;/code&gt; 대신 &lt;code&gt;-wU&lt;/code&gt; 와 같은 것을 사용해야 할 수도 있습니다. 이 문제는 #! 및 setuid 또는 setgid 스크립트를 지원하는 Unix 또는 Unix와 유사한 환경에서만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b95cff40ad5c3e10b014358530a3857e4311a17f" translate="yes" xml:space="preserve">
          <source>When you override a built-in, your replacement should be consistent (if possible) with the built-in native syntax. You can achieve this by using a suitable prototype. To get the prototype of an overridable built-in, use the &lt;code&gt;&lt;a href=&quot;functions/prototype&quot;&gt;prototype&lt;/a&gt;&lt;/code&gt; function with an argument of &lt;code&gt;&quot;CORE::builtin_name&quot;&lt;/code&gt; (see &lt;a href=&quot;functions/prototype&quot;&gt;prototype&lt;/a&gt;).</source>
          <target state="translated">내장을 재정의하는 경우 대체는 내장 네이티브 구문과 일치해야합니다 (가능한 경우). 적합한 프로토 타입을 사용하여이를 달성 할 수 있습니다. 재정의 가능한 기본 제공의 프로토 타입을 가져 오려면 &lt;code&gt;&quot;CORE::builtin_name&quot;&lt;/code&gt; 인수와 함께 &lt;code&gt;&lt;a href=&quot;functions/prototype&quot;&gt;prototype&lt;/a&gt;&lt;/code&gt; 함수를 사용 하십시오 ( &lt;a href=&quot;functions/prototype&quot;&gt;prototype&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="cde2c695557d23e73e52834a17ed471dd59562aa" translate="yes" xml:space="preserve">
          <source>When you replace this variable, it is considered a good practice to store the possibly previously installed hook and that you recall it inside your own.</source>
          <target state="translated">이 변수를 교체 할 때는 이전에 설치했을 가능성이있는 후크를 저장하고 자신의 내부에서 호출하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="582bd31e20cc087ebfe2ecd8d499eadfcfa005d7" translate="yes" xml:space="preserve">
          <source>When you run Makefile.PL, it makes a Makefile. That's the whole point of MakeMaker. The Makefile.PL is a simple program which loads ExtUtils::MakeMaker and runs the WriteMakefile() function to generate a Makefile.</source>
          <target state="translated">Makefile.PL을 실행하면 Makefile이 만들어집니다. 그것이 MakeMaker의 핵심입니다. Makefile.PL은 ExtUtils :: MakeMaker를로드하고 WriteMakefile () 함수를 실행하여 Makefile을 생성하는 간단한 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="b579e440e9d1d7b9d0889bfe36abfaf0be29b72d" translate="yes" xml:space="preserve">
          <source>When you run a Perl script, something else is running the script for you, and that something else may output error messages. The script might emit its own warnings and error messages. Most of the time you cannot tell who said what.</source>
          <target state="translated">Perl 스크립트를 실행할 때 다른 스크립트가 스크립트를 실행 중이고 다른 오류 메시지가 출력 될 수 있습니다. 스크립트는 자체 경고 및 오류 메시지를 표시 할 수 있습니다. 대부분의 경우 누가 무엇을 말했는지 말할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b459c97000689bfb2a9636d9e9707ca71827210e" translate="yes" xml:space="preserve">
          <source>When you run this program, you should get something back that looks like this:</source>
          <target state="translated">이 프로그램을 실행하면 다음과 같은 내용이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="a4188abf09b28b37cfb9f20a3ac1868d9c6a543c" translate="yes" xml:space="preserve">
          <source>When you say &quot;make test&quot;, Perl uses the</source>
          <target state="translated">&quot;make test&quot;라고 말하면 Perl은</target>
        </trans-unit>
        <trans-unit id="7919c60f354343e7a5369000b965c8d2d0632381" translate="yes" xml:space="preserve">
          <source>When you see &lt;code&gt;charset=gb2312&lt;/code&gt; on mails and web pages, they really mean &lt;code&gt;euc-cn&lt;/code&gt; encodings. To fix that, &lt;code&gt;gb2312&lt;/code&gt; is aliased to &lt;code&gt;euc-cn&lt;/code&gt; . Use &lt;code&gt;gb2312-raw&lt;/code&gt; when you really mean it.</source>
          <target state="translated">메일 및 웹 페이지에 &lt;code&gt;charset=gb2312&lt;/code&gt; 가 표시되면 실제로 &lt;code&gt;euc-cn&lt;/code&gt; 인코딩을 의미 합니다. 이를 해결하기 위해 &lt;code&gt;gb2312&lt;/code&gt; 는 &lt;code&gt;euc-cn&lt;/code&gt; 에 별명이 지정됩니다 . 실제로 의미가있는 경우 &lt;code&gt;gb2312-raw&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="17139aebb0fce79faa8dece070270ecb6b39cc8b" translate="yes" xml:space="preserve">
          <source>When you see &lt;code&gt;charset=ks_c_5601-1987&lt;/code&gt; on mails and web pages, they really mean &quot;cp949&quot; encodings. To fix that, the following aliases are set;</source>
          <target state="translated">메일 및 웹 페이지에 &lt;code&gt;charset=ks_c_5601-1987&lt;/code&gt; 이 표시되면 실제로는 &quot;cp949&quot;인코딩을 의미합니다. 이를 해결하기 위해 다음과 같은 별명이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="bed16d4ef44043e0ee787c3f181832f24be03ea6" translate="yes" xml:space="preserve">
          <source>When you speak one language and the computer thinks you&amp;rsquo;re speaking another. You&amp;rsquo;ll see odd translations when you send UTF‑8, for instance, but the computer thinks you sent Latin-1, showing all sorts of weird characters instead. The term is written 「文字化け」in Japanese and means &amp;ldquo;character rot&amp;rdquo;, an apt description. Pronounced [&lt;code&gt;modʑibake&lt;/code&gt; ] in standard &lt;b&gt;IPA&lt;/b&gt; phonetics, or approximately &amp;ldquo;moh-jee-bah-keh&amp;rdquo;.</source>
          <target state="translated">한 언어를 말할 때 컴퓨터는 다른 언어를 말하는 것으로 생각합니다. 예를 들어 UTF-8을 보내면 이상한 번역이 표시되지만 컴퓨터는 라틴 -1을 보냈다고 생각하여 모든 종류의 이상한 문자를 표시합니다. 이 용어는 일본어로 &quot;文字 化 け&quot;로 작성되며 적절한 설명 인&amp;ldquo;문자 썩음&amp;rdquo;을 의미합니다. 표준 &lt;b&gt;IPA&lt;/b&gt; 음성학에서 약 [ &lt;code&gt;modʑibake&lt;/code&gt; ] 또는 약&amp;ldquo;moh-jee-bah-keh&amp;rdquo;.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="665a5769943788c4623d27cfed3bae7f7e133317" translate="yes" xml:space="preserve">
          <source>When you specify arguments to routines in the .xs file, you are really passing three pieces of information for each argument listed. The first piece is the order of that argument relative to the others (first, second, etc). The second is the type of argument, and consists of the type declaration of the argument (e.g., int, char*, etc). The third piece is the calling convention for the argument in the call to the library function.</source>
          <target state="translated">.xs 파일에서 루틴에 인수를 지정하면 실제로 나열된 각 인수에 대해 세 가지 정보가 전달됩니다. 첫 번째 작품은 다른 사람에 대한 주장의 순서입니다 (첫 번째, 두 번째 등). 두 번째는 인수의 유형이며 인수의 유형 선언으로 구성됩니다 (예 : int, char * 등). 세 번째 부분은 라이브러리 함수 호출에서 인수에 대한 호출 규칙입니다.</target>
        </trans-unit>
        <trans-unit id="92bc744ea7824ccea4eeb23e82728fbc4ddab899" translate="yes" xml:space="preserve">
          <source>When you supply a separate display name it becomes possible to run a test more than once; the display name is effectively the alias by which the test is known inside the harness. The harness doesn't care if it runs the same test more than once when each invocation uses a different name.</source>
          <target state="translated">별도의 표시 이름을 제공하면 테스트를 두 번 이상 실행할 수 있습니다. 표시 이름은 사실상 테스트가 하네스 내부에서 알려진 별칭입니다. 하네스는 각 호출이 다른 이름을 사용할 때 동일한 테스트를 두 번 이상 실행하는지 상관하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f5d8e81bcb99e99cbe008b301dbaa4156e030e10" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;&lt;a href=&quot;../functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; to lock the file, &lt;code&gt;Tie::File&lt;/code&gt; assumes that the read cache is no longer trustworthy, because another process might have modified the file since the last time it was read. Therefore, a successful call to &lt;code&gt;&lt;a href=&quot;../functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; discards the contents of the read cache and the internal record offset table.</source>
          <target state="translated">당신이 사용할 때 &lt;code&gt;&lt;a href=&quot;../functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 파일을 잠글, &lt;code&gt;Tie::File&lt;/code&gt; 다른 프로세스가 읽은 마지막 시간 이후 파일을 수정 한 수 있기 때문에 읽기 캐시는 더 이상 신뢰할이 있다고 가정합니다. 따라서 &lt;code&gt;&lt;a href=&quot;../functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 성공적으로 호출 하면 읽기 캐시 및 내부 레코드 오프셋 테이블의 내용이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="de1ea55b20ff67d97a482097e7d303cd94b1b34c" translate="yes" xml:space="preserve">
          <source>When you use Perl from C, your C program will--usually--allocate, &quot;run&quot;, and deallocate a</source>
          <target state="translated">C에서 Perl을 사용하면 C 프로그램은 일반적으로 a를 할당, &quot;실행&quot;및 할당 해제합니다.</target>
        </trans-unit>
        <trans-unit id="5b4b7e46fe751c099868927c5d1568ad4f11af65" translate="yes" xml:space="preserve">
          <source>When you use the &lt;b&gt;-n&lt;/b&gt; and &lt;b&gt;-p&lt;/b&gt; switches to Perl, &lt;code&gt;BEGIN&lt;/code&gt; and &lt;code&gt;END&lt;/code&gt; work just as they do in &lt;b&gt;awk&lt;/b&gt;, as a degenerate case. Both &lt;code&gt;BEGIN&lt;/code&gt; and &lt;code&gt;CHECK&lt;/code&gt; blocks are run when you use the &lt;b&gt;-c&lt;/b&gt; switch for a compile-only syntax check, although your main code is not.</source>
          <target state="translated">당신이 사용하는 경우 &lt;b&gt;-n&lt;/b&gt; 및 &lt;b&gt;-p&lt;/b&gt; 펄에 스위치를, &lt;code&gt;BEGIN&lt;/code&gt; 및 &lt;code&gt;END&lt;/code&gt; 의 그들이에서와 마찬가지로 작업 &lt;b&gt;AWK&lt;/b&gt; 퇴보 한 경우로,. 두 &lt;code&gt;BEGIN&lt;/code&gt; 및 &lt;code&gt;CHECK&lt;/code&gt; 당신이 사용하는 경우 블록이 실행됩니다 &lt;b&gt;-c&lt;/b&gt; 컴파일 전용 구문 점검을 위해 스위치를 메인 코드는 아니지만.</target>
        </trans-unit>
        <trans-unit id="6e7c5168dc3e4d09a86a5c07db61ae55b067c306" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma or Perl's &lt;b&gt;-w&lt;/b&gt; command-line option, you may see warnings about useless uses of constants or functions in &quot;void context&quot;. Void context just means the value has been discarded, such as a statement containing only &lt;code&gt;&quot;fred&quot;;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/getpwuid&quot;&gt;getpwuid(0);&lt;/a&gt;&lt;/code&gt;. It still counts as scalar context for functions that care whether or not they're being called in list context.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 프라그 펄의 &lt;b&gt;-w&lt;/b&gt; 명령 줄 옵션을, 당신은 &quot;무효 컨텍스트&quot;상수 또는 함수의 쓸모없는 사용에 대한 경고가 표시 될 수 있습니다. 무효 컨텍스트는 단지 &lt;code&gt;&quot;fred&quot;;&lt;/code&gt; 만 포함하는 문장과 같이 값이 삭제되었음을 의미합니다 . 또는 &lt;code&gt;&lt;a href=&quot;functions/getpwuid&quot;&gt;getpwuid(0);&lt;/a&gt;&lt;/code&gt; . 리스트 컨텍스트에서 호출되는지 여부를 관리하는 함수의 스칼라 컨텍스트로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="f561cbf428cfa38a570f079c8fe3f1e6c4934924" translate="yes" xml:space="preserve">
          <source>When you want to encode Unicode for mails and web pages, however, do not use UTF-7 unless you are sure your recipients and readers can handle it. Very few MUAs and WWW Browsers support these days (only Mozilla seems to support one). For general cases, use UTF-8 for message body and MIME-Header for header instead.</source>
          <target state="translated">그러나 메일 및 웹 페이지 용 유니 코드를 인코딩하려는 경우 수신자 및 독자가 처리 할 수 ​​있다고 확신하지 않는 한 UTF-7을 사용하지 마십시오. 요즘 지원하는 MUA 및 WWW 브라우저는 거의 없습니다 (Mozilla 만 지원). 일반적인 경우에는 메시지 본문에 UTF-8을 사용하고 대신 헤더에 MIME- 헤더를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d1594b9a6f30c884e42aa7810e12c05455ffa364" translate="yes" xml:space="preserve">
          <source>When you want to write to a file, you first have to decide what to do about any existing contents of that file. You have two basic choices here: to preserve or to clobber.</source>
          <target state="translated">파일에 쓰려면 먼저 해당 파일의 기존 내용에 대해 수행 할 작업을 결정해야합니다. 여기에는 두 가지 기본 선택이 있습니다 : 보존 또는 클로버.</target>
        </trans-unit>
        <trans-unit id="f729e16e6d70d308845c4e263f4f5d66444de2cc" translate="yes" xml:space="preserve">
          <source>When you're done with your filehandles, you should &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; them (though to be honest, Perl will clean up after you if you forget):</source>
          <target state="translated">파일 핸들링을 마쳤 으면 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; 해야합니다 (솔직하지만 Perl은 잊어 버린 후에 정리합니다).</target>
        </trans-unit>
        <trans-unit id="f855bc56e9b2d1a2f4296535cb927b2c13c9dd7d" translate="yes" xml:space="preserve">
          <source>When you're using RETVAL to return an &lt;code&gt;SV *&lt;/code&gt; , there's some magic going on behind the scenes that should be mentioned. When you're manipulating the argument stack using the ST(x) macro, for example, you usually have to pay special attention to reference counts. (For more about reference counts, see &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;.) To make your life easier, the typemap file automatically makes &lt;code&gt;RETVAL&lt;/code&gt; mortal when you're returning an &lt;code&gt;SV *&lt;/code&gt; . Thus, the following two XSUBs are more or less equivalent:</source>
          <target state="translated">RETVAL을 사용하여 &lt;code&gt;SV *&lt;/code&gt; 를 반환하면 언급해야 할 장면 뒤에 약간의 마술이 있습니다. 예를 들어 ST (x) 매크로를 사용하여 인수 스택을 조작 할 때는 일반적으로 참조 횟수에 특별한주의를 기울여야합니다. 참조 횟수에 대한 자세한 내용은 &lt;a href=&quot;perlguts&quot;&gt;perlguts를&lt;/a&gt; 참조하십시오 .보다 편리하게 사용할 수 있도록 typemap 파일 은 &lt;code&gt;SV *&lt;/code&gt; 를 반환 할 때 &lt;code&gt;RETVAL&lt;/code&gt; 을 자동으로 치명적 으로 만듭니다 . 따라서 다음 두 XSUB는 거의 동일합니다.</target>
        </trans-unit>
        <trans-unit id="5829efde6fb988f406fa62c8ae4c250e14e41e30" translate="yes" xml:space="preserve">
          <source>When you've found that there isn't a module available for what you're trying to do, and you've had to write the code yourself, consider packaging up the solution into a module and uploading it to CPAN so that others can benefit.</source>
          <target state="translated">수행하려는 작업에 사용할 수있는 모듈이없고 코드를 직접 작성해야하는 경우 솔루션을 모듈에 패키징하고 CPAN에 업로드하여 다른 사용자가 할 수 있도록하십시오 이익.</target>
        </trans-unit>
        <trans-unit id="6b113771452e06c12bd2750d8700f91d2cc72def" translate="yes" xml:space="preserve">
          <source>When you've got your name sorted out and you're sure that your module is wanted and not currently available, it's time to start coding.</source>
          <target state="translated">이름을 정리하고 모듈을 원하고 현재 사용할 수없는 것이 확실한 경우 코딩을 시작할 차례입니다.</target>
        </trans-unit>
        <trans-unit id="baa149e5f728be9fcf5c842fafa04ad779a77d18" translate="yes" xml:space="preserve">
          <source>When your child is done running tests, you must call &lt;code&gt;finalize&lt;/code&gt; to clean up and tell the parent your pass/fail status.</source>
          <target state="translated">자녀가 시험을 &lt;code&gt;finalize&lt;/code&gt; 를 호출 하여 부모에게 합격 / 실패 상태를 알려야합니다.</target>
        </trans-unit>
        <trans-unit id="701f121f0767fb048f9a1e9cdd7bcb29143a3d18" translate="yes" xml:space="preserve">
          <source>When your module encounters an error it should do one or more of:</source>
          <target state="translated">모듈에 오류가 발생하면 다음 중 하나 이상을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="7d300f1dcd786450162ec26ef8c71857af330be4" translate="yes" xml:space="preserve">
          <source>When, &lt;code&gt;$Archive::Tar::CHMOD&lt;/code&gt; is enabled, this setting controls whether the permissions on files from the archive are used without modification of if they are filtered by removing any setid bits and applying the current umask.</source>
          <target state="translated">시, &lt;code&gt;$Archive::Tar::CHMOD&lt;/code&gt; 활성화되어, 아카이브에서 파일에 대한 권한 여부를이 설정 컨트롤은 어떤 setid 비트를 제거하고 현재의 umask를 적용하여 필터링하는 경우의 수정없이 사용된다.</target>
        </trans-unit>
        <trans-unit id="cabccb147592c137e487eb001cea479dffb70830" translate="yes" xml:space="preserve">
          <source>Whenever a Berkeley DB function returns data via one of its parameters, the equivalent &lt;b&gt;DB_File&lt;/b&gt; method does exactly the same.</source>
          <target state="translated">Berkeley DB 함수가 매개 변수 중 하나를 통해 데이터를 리턴 할 때마다 동등한 &lt;b&gt;DB_File&lt;/b&gt; 메소드는 정확히 동일합니다.</target>
        </trans-unit>
        <trans-unit id="6a800aba7242513688fb7365bc61881077cd8882" translate="yes" xml:space="preserve">
          <source>Whenever a Perl subroutine is called using one of the</source>
          <target state="translated">Perl 서브 루틴이 다음 중 하나를 사용하여 호출 될 때마다</target>
        </trans-unit>
        <trans-unit id="6344d70f52ab5669e0f868bcc4766007019f0e1c" translate="yes" xml:space="preserve">
          <source>Whenever a reference is used as a field hash key, the object registry is checked and a new entry is made if necessary. The field hash is then added to the list of fields this reference has used.</source>
          <target state="translated">참조가 필드 해시 키로 사용될 때마다 오브젝트 레지스트리가 점검되고 필요한 경우 새 항목이 작성됩니다. 그런 다음이 참조가 사용한 필드 목록에 필드 해시가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="ac59cb12b90f854e158e9f7e8d962f434ede4764" translate="yes" xml:space="preserve">
          <source>Whenever control returns from the</source>
          <target state="translated">제어가</target>
        </trans-unit>
        <trans-unit id="58a47aafac8fca0c788807bc11f865583b9a79dd" translate="yes" xml:space="preserve">
          <source>Whenever possible, new features should be prototyped in a CPAN module before they will be considered for the core.</source>
          <target state="translated">가능할 때마다 핵심 기능을 고려하기 전에 CPAN 모듈에서 새로운 기능을 프로토 타입해야합니다.</target>
        </trans-unit>
        <trans-unit id="a368a6c064c79ec6ec1d84f92fa7a58354e83dad" translate="yes" xml:space="preserve">
          <source>Whenever this is applied to a string which doesn't quite meet the pattern's expectations such as &lt;code&gt;&quot;abc  &quot;&lt;/code&gt; or &lt;code&gt;&quot;abc  def &quot;&lt;/code&gt; , the regex engine will backtrack, approximately once for each character in the string. But we know that there is no way around taking</source>
          <target state="translated">이것이 &lt;code&gt;&quot;abc &quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;abc def &quot;&lt;/code&gt; 와 같은 패턴의 기대치를 충족시키지 않는 문자열에 적용될 때마다 정규 표현식 엔진은 문자열의 각 문자에 대해 약 한 번 역 추적합니다. 그러나 우리는 복용 주위에 방법이 없다는 것을 알고</target>
        </trans-unit>
        <trans-unit id="1d972aca2274b3be6437814e7f18c3f8fdf56c12" translate="yes" xml:space="preserve">
          <source>Whenever you do I/O on a file in Perl, you do so through what in Perl is called a &lt;b&gt;filehandle&lt;/b&gt;. A filehandle is an internal name for an external file. It is the job of the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; function to make the association between the internal name and the external name, and it is the job of the &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; function to break that association.</source>
          <target state="translated">펄에서 파일 I / O를 할 때마다, 당신은 펄의 소위를 통해이를 &lt;b&gt;핸들&lt;/b&gt; . 파일 핸들은 외부 파일의 내부 이름입니다. 내부 이름과 외부 이름을 연결 하는 것은 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 기능의 작업이며 해당 연결을 끊는 것은 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 기능 의 작업입니다 .</target>
        </trans-unit>
        <trans-unit id="ed7093ca3cc4a3c897e96991516ce1f4f0fcfd4e" translate="yes" xml:space="preserve">
          <source>Whenever you have more than one subprocess, you must be careful that each closes whichever half of any pipes created for interprocess communication it is not using. This is because any child process reading from the pipe and expecting an EOF will never receive it, and therefore never exit. A single process closing a pipe is not enough to close it; the last process with the pipe open must close it for it to read EOF.</source>
          <target state="translated">서브 프로세스가 둘 이상있을 때마다 프로세스 간 통신을 위해 작성된 파이프 중 절반이 사용하지 않는 파이프가 닫히도록주의해야합니다. 이는 파이프에서 읽고 EOF를 기대하는 모든 하위 프로세스가이를 수신하지 않으므로 종료되지 않기 때문입니다. 파이프를 닫는 단일 프로세스로는 파이프를 닫을 수 없습니다. EOF를 읽으려면 파이프를 연 상태에서 마지막 프로세스를 닫아야합니다.</target>
        </trans-unit>
        <trans-unit id="cd1ee0eb738b950d883ab6c08ca29be20ef06df7" translate="yes" xml:space="preserve">
          <source>Whenever you're communicating text with anything that is external to your perl process, like a database, a text file, a socket, or another program. Even if the thing you're communicating with is also written in Perl.</source>
          <target state="translated">데이터베이스, 텍스트 파일, 소켓 또는 다른 프로그램과 같이 펄 프로세스 외부의 텍스트와 텍스트를 통신 할 때마다 당신이 통신하는 것이 Perl로 쓰여져 있더라도.</target>
        </trans-unit>
        <trans-unit id="cc31f890f5831db8c47f9104a5fd72a40a9b958c" translate="yes" xml:space="preserve">
          <source>Whenever your encoded, binary string is used together with a text string, Perl will assume that your binary string was encoded with ISO-8859-1, also known as latin-1. If it wasn't latin-1, then your data is unpleasantly converted. For example, if it was UTF-8, the individual bytes of multibyte characters are seen as separate characters, and then again converted to UTF-8. Such double encoding can be compared to double HTML encoding (&lt;code&gt;&amp;amp;amp;gt;&lt;/code&gt; ), or double URI encoding (&lt;code&gt;%253E&lt;/code&gt; ).</source>
          <target state="translated">인코딩 된 이진 문자열이 텍스트 문자열과 함께 사용될 때마다 Perl은 이진 문자열이 라틴 -1이라고도하는 ISO-8859-1로 인코딩 된 것으로 가정합니다. 라틴 -1이 아닌 경우 데이터가 불쾌하게 변환됩니다. 예를 들어, UTF-8 인 경우 멀티 바이트 문자의 개별 바이트는 별도의 문자로 표시되고 다시 UTF-8로 변환됩니다. 이러한 이중 인코딩은 이중 HTML 인코딩 ( &lt;code&gt;&amp;amp;amp;gt;&lt;/code&gt; ) 또는 이중 URI 인코딩 ( &lt;code&gt;%253E&lt;/code&gt; ) 과 비교 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e1d629f115a3e97bf6ae620fc76d3801dd8ef401" translate="yes" xml:space="preserve">
          <source>Whenever your program accesses data or resources that can be accessed by other threads, you must take steps to coordinate access or risk data inconsistency and race conditions. Note that Perl will protect its internals from your race conditions, but it won't protect you from you.</source>
          <target state="translated">프로그램이 다른 스레드에서 액세스 할 수있는 데이터 또는 리소스에 액세스 할 때마다 액세스를 조정하거나 데이터 불일치 및 경쟁 조건을 위험에 빠뜨리기위한 단계를 수행해야합니다. Perl은 경쟁 조건으로부터 내부를 보호하지만 귀하를 보호하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="525f61b6729229b1a8854a9e50bcaa52ea96b131" translate="yes" xml:space="preserve">
          <source>Where</source>
          <target state="translated">Where</target>
        </trans-unit>
        <trans-unit id="fb9b184246f9c47c2085ba5fb400e91c6332924c" translate="yes" xml:space="preserve">
          <source>Where 1 is the position of the first char in the string. Note that position can be 0, or larger than the actual length of the pattern, likewise length can be zero.</source>
          <target state="translated">여기서 1은 문자열에서 첫 번째 문자의 위치입니다. 위치는 0이거나 패턴의 실제 길이보다 클 수 있으며, 마찬가지로 길이는 0 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73e22419719a01d34b548da9ec30ecb83ae08c13" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;$id1&lt;/code&gt; , &lt;code&gt;$id2&lt;/code&gt; are two byte subfield ID's.</source>
          <target state="translated">여기서 &lt;code&gt;$id1&lt;/code&gt; , &lt;code&gt;$id2&lt;/code&gt; 는 2 바이트 서브 필드 ID입니다.</target>
        </trans-unit>
        <trans-unit id="b9cb4e493b9dc9b7340611ceb99bc1cecceb2405" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;$id1&lt;/code&gt; , &lt;code&gt;$id2&lt;/code&gt; are two byte subfield ID's. The second byte of the ID cannot be 0, unless the &lt;code&gt;Strict&lt;/code&gt; option has been disabled.</source>
          <target state="translated">여기서 &lt;code&gt;$id1&lt;/code&gt; , &lt;code&gt;$id2&lt;/code&gt; 는 2 바이트 서브 필드 ID입니다. &lt;code&gt;Strict&lt;/code&gt; 옵션이 비활성화되어 있지 않으면 ID의 두 번째 바이트는 0이 될 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="de8d3be1468ab688b0e6e35d8cea1268cae0caa0" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;$r1&lt;/code&gt; can be a reference to any kind of data structure you'd like. It will be deeply copied. Because &lt;code&gt;dclone&lt;/code&gt; takes and returns references, you'd have to add extra punctuation if you had a hash of arrays that you wanted to copy.</source>
          <target state="translated">여기서 &lt;code&gt;$r1&lt;/code&gt; 은 원하는 모든 종류의 데이터 구조에 대한 참조가 될 수 있습니다. 깊이 복사됩니다. 때문에 &lt;code&gt;dclone&lt;/code&gt; 이 소요 반환 참조, 당신은 당신이 복사 싶어 배열의 해시가 있다면 별도의 문장을 추가해야 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="29126cbcaebf3032a0f200bdad16fd67b9d2ca9f" translate="yes" xml:space="preserve">
          <source>Where a &lt;b&gt;compiler&lt;/b&gt; remembers symbols. A program like Perl must somehow remember all the names of all the &lt;b&gt;variables&lt;/b&gt;, &lt;b&gt;filehandles&lt;/b&gt;, and &lt;b&gt;subroutines&lt;/b&gt; you&amp;rsquo;ve used. It does this by placing the names in a symbol table, which is implemented in Perl using a &lt;b&gt;hash table&lt;/b&gt;. There is a separate symbol table for each &lt;b&gt;package&lt;/b&gt; to give each package its own &lt;b&gt;namespace&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;컴파일러가&lt;/b&gt; 기호를 기억 하는 곳 . Perl과 같은 프로그램은 사용했던 모든 &lt;b&gt;변수&lt;/b&gt; , &lt;b&gt;파일 핸들&lt;/b&gt; 및 &lt;b&gt;서브 루틴&lt;/b&gt; 의 모든 이름을 어떻게 든 기억해야합니다 . 이는 &lt;b&gt;해시 테이블을&lt;/b&gt; 사용하여 Perl에서 구현되는 심볼 테이블에 이름을 배치하여 수행 &lt;b&gt;합니다&lt;/b&gt; . 각 &lt;b&gt;패키지&lt;/b&gt; 마다 고유 한 &lt;b&gt;네임 스페이스&lt;/b&gt; 를 제공하기 위해 각 패키지 마다 별도의 기호 테이블이 &lt;b&gt;있습니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="841b8cfbd59c36bfe89c29e0da6a4675a6abce15" translate="yes" xml:space="preserve">
          <source>Where are modules installed?</source>
          <target state="translated">모듈은 어디에 설치되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="77cc20dcc0c42287d0cc6c95ce660feb0b4c5aeb" translate="yes" xml:space="preserve">
          <source>Where can I buy a commercial version of Perl?</source>
          <target state="translated">Perl의 상용 버전은 어디에서 구입할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="08cf7f142b0ee15a977fe964d0ddcdb1002739ae" translate="yes" xml:space="preserve">
          <source>Where can I get Perl macros for vi?</source>
          <target state="translated">vi 용 Perl 매크로를 어디서 구할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="406cbb0495a55956cb84611a8d86c9d721557519" translate="yes" xml:space="preserve">
          <source>Where can I get information on Perl?</source>
          <target state="translated">Perl에 대한 정보는 어디서 얻을 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="c63d9dfa4f6d6dcfc8103ea7650db10cd8e27fea" translate="yes" xml:space="preserve">
          <source>Where can I get perl-mode or cperl-mode for emacs?</source>
          <target state="translated">emacs에 대한 펄 모드 또는 cperl 모드는 어디서 구할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="f0f1c9d2159564047b740e7956f5640af04f1e3c" translate="yes" xml:space="preserve">
          <source>Where can I learn about CGI or Web programming in Perl?</source>
          <target state="translated">Perl에서 CGI 또는 웹 프로그래밍에 대해 어디서 배울 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="703366e9bd37f95d6d2b90762995773aff84d67e" translate="yes" xml:space="preserve">
          <source>Where can I learn about linking C with Perl?</source>
          <target state="translated">C와 Perl을 연결하는 방법은 어디에서 배울 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="ed8bfc60bd9d8b7923b8341ed07d83afc289bc35" translate="yes" xml:space="preserve">
          <source>Where can I learn about object-oriented Perl programming?</source>
          <target state="translated">객체 지향 Perl 프로그래밍에 대해 어디서 배울 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="210221a52d88064b34135e9105ebfd5d49152b00" translate="yes" xml:space="preserve">
          <source>Where can I post questions?</source>
          <target state="translated">질문을 어디에 게시 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="34466094d5547ae836abe0422810851106c8e987" translate="yes" xml:space="preserve">
          <source>Where do I get the include files to do ioctl() or syscall()?</source>
          <target state="translated">ioctl () 또는 syscall ()을 수행하기 위해 포함 파일을 어디서 구할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="ae774b74efc34a0e83321577caf18754079572a2" translate="yes" xml:space="preserve">
          <source>Where do I send bug reports?</source>
          <target state="translated">버그 보고서를 어디로 보내야합니까?</target>
        </trans-unit>
        <trans-unit id="93218aab454721cc4e38fe91ac1668248deeae63" translate="yes" xml:space="preserve">
          <source>Where is the implementation?</source>
          <target state="translated">구현은 어디에 있습니까?</target>
        </trans-unit>
        <trans-unit id="8a78c0649556030e4985847b409471ca9ebd9274" translate="yes" xml:space="preserve">
          <source>Where people get into trouble is here:</source>
          <target state="translated">사람들이 어려움에 처한 곳은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f616a42d8ce8b58cf95a9bfc5e5383c6c84dc620" translate="yes" xml:space="preserve">
          <source>Where prereqs are concerned, if META_MERGE is used, prerequisites are merged with their counterpart &lt;code&gt;WriteMakefile()&lt;/code&gt; argument (PREREQ_PM is merged into {prereqs}{runtime}{requires}, BUILD_REQUIRES into &lt;code&gt;{prereqs}{build}{requires}&lt;/code&gt; , CONFIGURE_REQUIRES into &lt;code&gt;{prereqs}{configure}{requires}&lt;/code&gt; , and TEST_REQUIRES into &lt;code&gt;{prereqs}{test}{requires})&lt;/code&gt; . When prereqs are specified with META_ADD, the only prerequisites added to the file come from the metadata, not &lt;code&gt;WriteMakefile()&lt;/code&gt; arguments.</source>
          <target state="translated">전제 조건이 관련된 경우 META_MERGE가 사용되는 경우 전제 조건은 해당 &lt;code&gt;WriteMakefile()&lt;/code&gt; 인수와 병합됩니다 (PREREQ_PM은 {prereqs} {runtime} {requires}에 병합되고, BUILD_REQUIRES는 &lt;code&gt;{prereqs}{build}{requires}&lt;/code&gt; prereqs } {build} {requires}에 , CONFIGURE_REQUIRES는 &lt;code&gt;{prereqs}{configure}{requires}&lt;/code&gt; prereqs } prereqs} {configure} {requires} 및 TEST_REQUIRES를 &lt;code&gt;{prereqs}{test}{requires})&lt;/code&gt; prereqs } {test} {requires}) 로 보냅니다 . META_ADD로 전제 조건을 지정하면 파일에 추가 된 유일한 전제 조건은 &lt;code&gt;WriteMakefile()&lt;/code&gt; 인수가 아닌 메타 데이터에서 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="2578ad2cf7eb4212c4c2f76a99c66a64a699a6f4" translate="yes" xml:space="preserve">
          <source>Where the $way is a value from zero ($theta0, $phi0) to one ($theta1, $phi1). Note that antipodal points (where their distance is</source>
          <target state="translated">여기서 $ way는 0 ($ theta0, $ phi0)에서 1 ($ theta1, $ phi1) 사이의 값입니다. 대퇴 점 (거리가있는 곳)</target>
        </trans-unit>
        <trans-unit id="fd6d6e78410be236f0ee8b2e37126d4a25f62f65" translate="yes" xml:space="preserve">
          <source>Where the 'DSLIP' characters have the following meanings:</source>
          <target state="translated">'DSLIP'문자의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3a57b05d69f49e2636c91eefc4c6774814129e12" translate="yes" xml:space="preserve">
          <source>Where there is only one operand (or only one operand with overloading) the checks in respect of the other operand above are skipped.</source>
          <target state="translated">피연산자가 하나만 있거나 오버로드가있는 피연산자 만 하나 인 경우 위의 다른 피연산자에 대한 검사는 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="293c942f397777e729937e1824d906951d88e087" translate="yes" xml:space="preserve">
          <source>Where these steps occur in the actual execution of a perl program is determined by whether the pattern involves interpolating any string variables. If interpolation occurs, then compilation happens at run time. If it does not, then compilation is performed at compile time. (The &lt;code&gt;/o&lt;/code&gt; modifier changes this, as does &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; to a certain extent.) The engine doesn't really care that much.</source>
          <target state="translated">이러한 단계가 실제 perl 프로그램 실행에서 발생하는 경우 패턴에 문자열 변수 보간이 포함되는지 여부에 따라 결정됩니다. 보간이 발생하면 런타임에 컴파일이 수행됩니다. 그렇지 않은 경우 컴파일시 컴파일이 수행됩니다. ( &lt;code&gt;/o&lt;/code&gt; 수정자는 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 와 마찬가지로이를 변경합니다 .) 엔진은 실제로 그다지 신경 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cca423190a1a1c785b9d576f8083e40dd5389585" translate="yes" xml:space="preserve">
          <source>Where to Find the Community</source>
          <target state="translated">커뮤니티를 찾을 수있는 곳</target>
        </trans-unit>
        <trans-unit id="536ef5aba264e8d2aec71ea10430b9efa22dfe0c" translate="yes" xml:space="preserve">
          <source>Where to find the perlfaq</source>
          <target state="translated">perlfaq을 찾을 수있는 곳</target>
        </trans-unit>
        <trans-unit id="74e10717c102dd0c9df4c18b5606b9aaf6912d10" translate="yes" xml:space="preserve">
          <source>Where you look to find a pointer to information somewhere else. (See &lt;b&gt;indirection&lt;/b&gt;.) References come in two flavors: &lt;b&gt;symbolic references&lt;/b&gt; and &lt;b&gt;hard references&lt;/b&gt;.</source>
          <target state="translated">다른 곳의 정보에 대한 포인터를 찾는 곳. (참조 &lt;b&gt;간접를&lt;/b&gt; .) 참고 문헌은 두 가지 종류로 제공 : &lt;b&gt;상징적 참조&lt;/b&gt; 및 &lt;b&gt;하드 참조&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="500583f76e5e2a57eb1022812ab875f23db70975" translate="yes" xml:space="preserve">
          <source>Where's the catch? Padding is neither required before the first field &lt;code&gt;count&lt;/code&gt; , nor between this and the next field &lt;code&gt;glyph&lt;/code&gt; , so why can't we simply pack like this:</source>
          <target state="translated">캐치는 어? 어? 첫 번째 필드 &lt;code&gt;count&lt;/code&gt; 이전 이나 다음 필드 &lt;code&gt;glyph&lt;/code&gt; 사이에 패딩이 필요하지 않으므로 다음 과 같이 간단하게 포장 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="85ff01499d11ce21062a9b96027ab58ee226aad3" translate="yes" xml:space="preserve">
          <source>Where,</source>
          <target state="translated">Where,</target>
        </trans-unit>
        <trans-unit id="7e741bc3dcef0123eeda11543758853be2aac149" translate="yes" xml:space="preserve">
          <source>Where:</source>
          <target state="translated">Where:</target>
        </trans-unit>
        <trans-unit id="4d453f1163fdbba0e62b8cfe55db1c43bd938110" translate="yes" xml:space="preserve">
          <source>Whereas a QP decoder that works on both ASCII and EBCDIC platforms would look somewhat like the following:</source>
          <target state="translated">ASCII 및 EBCDIC 플랫폼 모두에서 작동하는 QP 디코더는 다음과 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="4c1007108b497a2f8b15b3dc9255f03fbd82a20c" translate="yes" xml:space="preserve">
          <source>Whereas here's how a Perl programmer more comfortable with the idiom might do it:</source>
          <target state="translated">Perl 프로그래머가 관용구에 더 익숙한 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5db7dff8fd1589f3c435af6d45d16e0816b2e9c4" translate="yes" xml:space="preserve">
          <source>Whereas if you comment out the two lines I said you might wish to, then it shows it to you this way instead:</source>
          <target state="translated">내가 원한다고 말한 두 줄을 주석 처리하면 대신 다음과 같이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="aa7a6da1ef7f2699440e362142ae5565af060786" translate="yes" xml:space="preserve">
          <source>Wherever a list of operators can be given you can use one or more opsets. See also Manipulating Opsets below.</source>
          <target state="translated">운영자 목록을 제공 할 수있는 곳마다 하나 이상의 옵셋을 사용할 수 있습니다. 아래의 조작 조작을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c457c17dce216494419135c71949242b8d09d0bb" translate="yes" xml:space="preserve">
          <source>Wherever possible, shareable images are preferred to object libraries, and object libraries to plain object files. In accordance with VMS naming conventions, ext() looks for files named</source>
          <target state="translated">가능하면 공유 가능한 이미지는 객체 라이브러리보다 선호되고 객체 라이브러리는 일반 객체 파일보다 선호됩니다. VMS 명명 규칙에 따라 ext ()는 이름이 지정된 파일을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="60f21be64cee3c558562d0924a678b1007587a17" translate="yes" xml:space="preserve">
          <source>Whether PadnamePV is in UTF8. Currently, this is always true.</source>
          <target state="translated">PadnamePV가 UTF8인지 여부 현재 이것은 항상 사실입니다.</target>
        </trans-unit>
        <trans-unit id="63b3304921bf73755f27746fb53954b4a8c4de93" translate="yes" xml:space="preserve">
          <source>Whether command line arguments are allowed to be mixed with options. Default is disabled unless environment variable POSIXLY_CORRECT has been set, in which case &lt;code&gt;require_order&lt;/code&gt; is enabled.</source>
          <target state="translated">명령 행 인수를 옵션과 혼합 할 수 있는지 여부 환경 변수 POSIXLY_CORRECT가 설정되지 않은 경우 기본값은 사용 불가능하며,이 경우 &lt;code&gt;require_order&lt;/code&gt; 가 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="faea90df33f36630a481da4cad34e4c79bf52fc5" translate="yes" xml:space="preserve">
          <source>Whether command line arguments are allowed to be mixed with options. Default is enabled unless environment variable POSIXLY_CORRECT has been set, in which case &lt;code&gt;permute&lt;/code&gt; is disabled. Note that &lt;code&gt;permute&lt;/code&gt; is the opposite of &lt;code&gt;require_order&lt;/code&gt; .</source>
          <target state="translated">명령 행 인수를 옵션과 혼합 할 수 있는지 여부 환경 변수 POSIXLY_CORRECT를 설정하지 않으면 기본값이 사용되며,이 경우 &lt;code&gt;permute&lt;/code&gt; 가 사용되지 않습니다. 참고 &lt;code&gt;permute&lt;/code&gt; 반대입니다 &lt;code&gt;require_order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf16a187d3ac8048da2c0a9f49f8874167f5a83b" translate="yes" xml:space="preserve">
          <source>Whether or not the op has been optimized by the peephole optimizer.</source>
          <target state="translated">들여다 보는 구멍 최적화 프로그램에 의해 op가 최적화되었는지 여부</target>
        </trans-unit>
        <trans-unit id="99e430c2678f913bd7c7b93452d560622af7b626" translate="yes" xml:space="preserve">
          <source>Whether or not the test should output numbers. That is, this if true:</source>
          <target state="translated">테스트에서 숫자를 출력해야하는지 여부입니다. 즉, 이것이 사실이라면 :</target>
        </trans-unit>
        <trans-unit id="5f8067023624d336e348da355a79650c3095a919" translate="yes" xml:space="preserve">
          <source>Whether or not to be verbose about what it is doing -- it will default to $Module::Load::Conditional::VERBOSE</source>
          <target state="translated">수행중인 작업에 대한 자세한 여부-기본값은 $ Module :: Load :: Conditional :: VERBOSE입니다.</target>
        </trans-unit>
        <trans-unit id="a8f7f78ec0e44e67b9396390cd1ee3bcf0e5e14e" translate="yes" xml:space="preserve">
          <source>Whether this entry belongs to an outer pad. Entries for which this is true are often referred to as 'fake'.</source>
          <target state="translated">이 항목이 외부 패드에 속하는지 여부 이것이 사실 인 항목을 종종 '가짜'라고합니다.</target>
        </trans-unit>
        <trans-unit id="6283322d116e1d51f7edcd1ec872a9eed355ceb1" translate="yes" xml:space="preserve">
          <source>Whether this is a &quot;state&quot; variable.</source>
          <target state="translated">이것이 &quot;상태&quot;변수인지 여부.</target>
        </trans-unit>
        <trans-unit id="e7034c09da28fdb3d58392534621cc03eebbd14d" translate="yes" xml:space="preserve">
          <source>Whether this is an &quot;our&quot; variable.</source>
          <target state="translated">이것이 &quot;우리&quot;변수인지 여부</target>
        </trans-unit>
        <trans-unit id="8fe93610e6b23e15b98198b34ad48105c383339a" translate="yes" xml:space="preserve">
          <source>Whether to abort printing if debugger signal flag is raised.</source>
          <target state="translated">디버거 신호 플래그가 발생한 경우 인쇄 중단 여부입니다.</target>
        </trans-unit>
        <trans-unit id="2985490d3101108f328098168c5a21b3bc3c5a70" translate="yes" xml:space="preserve">
          <source>Whether to add a table-of-contents at the top of each page (called an index for the sake of tradition).</source>
          <target state="translated">각 페이지 맨 위에 목차를 추가할지 여부 (전통적으로 색인이라고 함).</target>
        </trans-unit>
        <trans-unit id="3a911a7e2bce47416920de6f21016acd3029366b" translate="yes" xml:space="preserve">
          <source>Whether to anchor every definition &lt;code&gt;=item&lt;/code&gt; directive. This needs to be enabled if you want to be able to link to specific &lt;code&gt;=item&lt;/code&gt; directives, which are output as &lt;code&gt;&amp;lt;dt&amp;gt;&lt;/code&gt; elements. Disabled by default.</source>
          <target state="translated">모든 정의 &lt;code&gt;=item&lt;/code&gt; 지시문 을 앵커할지 여부 &lt;code&gt;&amp;lt;dt&amp;gt;&lt;/code&gt; 요소 로 출력되는 특정 &lt;code&gt;=item&lt;/code&gt; 지시문 에 링크하려면이 기능을 활성화해야합니다 . 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="626413839d3d50a20deaaad85828e47d347f236c" translate="yes" xml:space="preserve">
          <source>Whether to call these extended grapheme clusters &quot;characters&quot; depends on your point of view. If you are a programmer, you probably would tend towards seeing each element in the sequences as one unit, or &quot;character&quot;. However from the user's point of view, the whole sequence could be seen as one &quot;character&quot; since that's probably what it looks like in the context of the user's language. In this document, we take the programmer's point of view: one &quot;character&quot; is one Unicode code point.</source>
          <target state="translated">이러한 확장 된 grapheme 클러스터를 &quot;문자&quot;로 호출할지 여부는 사용자의 관점에 따라 다릅니다. 프로그래머라면 아마도 시퀀스의 각 요소를 하나의 단위 또는 &quot;문자&quot;로 보는 경향이있을 것입니다. 그러나 사용자 관점에서 전체 시퀀스는 하나의 &quot;문자&quot;로 표시 될 수 있습니다. 이는 아마도 사용자 언어의 맥락에서 보일 수 있기 때문일 것입니다. 이 문서에서 우리는 프로그래머의 관점을 취합니다. 하나의 &quot;문자&quot;는 하나의 유니 코드 코드 포인트입니다.</target>
        </trans-unit>
        <trans-unit id="ee66335b9db0c1d5103deb721dc40777dd212c3c" translate="yes" xml:space="preserve">
          <source>Whether to print chars with high bit set in binary or &quot;as is&quot;.</source>
          <target state="translated">이진으로 높은 비트가 설정된 문자를 인쇄할지 또는 &quot;있는 그대로&quot;인쇄할지 여부</target>
        </trans-unit>
        <trans-unit id="238ca87137bc56748ce05a002a71d9a6db9c7ebe" translate="yes" xml:space="preserve">
          <source>Whether to print contents of globs.</source>
          <target state="translated">글롭의 내용을 인쇄할지 여부.</target>
        </trans-unit>
        <trans-unit id="d3a12643fc63beef0ef6ccef6dae848daa691587" translate="yes" xml:space="preserve">
          <source>Whether to try to find the subroutine name given the reference.</source>
          <target state="translated">참조가 주어진 서브 루틴 이름을 찾으려고하는지 여부</target>
        </trans-unit>
        <trans-unit id="bfd0c6dfe7d4e4cba4e02f1a0ab33700dc1c327f" translate="yes" xml:space="preserve">
          <source>Whether to turn every =head1 directive into a link pointing to the top of the page (specifically, the opening body tag).</source>
          <target state="translated">모든 = head1 지시문을 페이지의 상단 (특히 여는 본문 태그)을 가리키는 링크로 변환할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="d26288162f4ab8ff9ae48923849befc89334a4a3" translate="yes" xml:space="preserve">
          <source>Whether to write the non-overloaded form of the stringify-overloaded objects.</source>
          <target state="translated">오버로드되지 않은 형식의 stringify-overloaded 객체를 작성할지 여부</target>
        </trans-unit>
        <trans-unit id="db40c6156e22d6cc6531821dd75bdcb0d45e3842" translate="yes" xml:space="preserve">
          <source>Whether various library calls are thread-safe is outside the control of Perl. Calls often suffering from not being thread-safe include: &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt;, functions fetching user, group and network information (such as &lt;code&gt;&lt;a href=&quot;functions/getgrent&quot;&gt;getgrent()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/gethostent&quot;&gt;gethostent()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getnetent&quot;&gt;getnetent()&lt;/a&gt;&lt;/code&gt; and so on), &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt;. In general, calls that depend on some global external state.</source>
          <target state="translated">다양한 라이브러리 호출이 스레드로부터 안전한지 여부는 Perl이 제어 할 수 없습니다. 스레드로부터 안전하지 않은 호출에는 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; , 사용자, 그룹 및 네트워크 정보를 가져 오는 함수 (예 : &lt;code&gt;&lt;a href=&quot;functions/getgrent&quot;&gt;getgrent()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/gethostent&quot;&gt;gethostent()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/getnetent&quot;&gt;getnetent()&lt;/a&gt;&lt;/code&gt; 등), &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; . 일반적으로 일부 글로벌 외부 상태에 의존하는 통화.</target>
        </trans-unit>
        <trans-unit id="201246e3611962dc1ed1a9edc779811bfcd3278b" translate="yes" xml:space="preserve">
          <source>Whether you are using NIS does not matter. Amazingly enough, the same bug also affects Solaris.</source>
          <target state="translated">NIS 사용 여부는 중요하지 않습니다. 놀랍게도 같은 버그는 Solaris에도 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="f8e039fc339d1036f86bd64ce844762f9417fe8b" translate="yes" xml:space="preserve">
          <source>Whether you use &lt;code&gt;perlbug&lt;/code&gt; or send the email manually, please make your Subject line informative. &quot;a bug&quot; is not informative. Neither is &quot;perl crashes&quot; nor is &quot;HELP!!!&quot;. These don't help. A compact description of what's wrong is fine.</source>
          <target state="translated">&lt;code&gt;perlbug&lt;/code&gt; 를 사용하든 이메일을 수동으로 보내든 , 제목 줄에 정보를 제공하십시오. &quot;버그&quot;는 유익하지 않습니다. &quot;perl crash&quot;도 &quot;HELP !!!&quot;도 아닙니다. 이것들은 도움이되지 않습니다. 무엇이 잘못되었는지 간략하게 설명하면 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0cde069a15e713b9fe4a9a6b7078fade7daf5170" translate="yes" xml:space="preserve">
          <source>Whew! That is all the rest of the characters and character classes.</source>
          <target state="translated">아휴! 그것은 나머지 모든 문자와 문자 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="56043e0fa27cef8d93950adbdc599597748f590d" translate="yes" xml:space="preserve">
          <source>Which &lt;a href=&quot;tie/hash&quot;&gt;Tie::Hash&lt;/a&gt; operation is being performed from the Perl level on &lt;code&gt;%+&lt;/code&gt; or &lt;code&gt;%+&lt;/code&gt; , if any:</source>
          <target state="translated">어떤 &lt;a href=&quot;tie/hash&quot;&gt;타이 :: 해시&lt;/a&gt; 작업이에 펄 수준에서 수행되고 &lt;code&gt;%+&lt;/code&gt; 또는 &lt;code&gt;%+&lt;/code&gt; (있는 경우) :</target>
        </trans-unit>
        <trans-unit id="babf69836d4addec6f5a5308cb5825c678eb405e" translate="yes" xml:space="preserve">
          <source>Which Perl blogs should I read?</source>
          <target state="translated">어떤 Perl 블로그를 읽어야합니까?</target>
        </trans-unit>
        <trans-unit id="54a12a94c6d59fab4aeefed76c9781df10879a85" translate="yes" xml:space="preserve">
          <source>Which YAML implementation would you prefer?</source>
          <target state="translated">어떤 YAML 구현을 원하십니까?</target>
        </trans-unit>
        <trans-unit id="88e9358d41b432fbb58126174b7979a4235a746a" translate="yes" xml:space="preserve">
          <source>Which architecture dependent directory?</source>
          <target state="translated">어떤 아키텍처 종속 디렉토리?</target>
        </trans-unit>
        <trans-unit id="b7506b68ee68fa595a60659e338ae77c9646b01d" translate="yes" xml:space="preserve">
          <source>Which character set modifier is in effect?</source>
          <target state="translated">어떤 문자 세트 수정자가 적용됩니까?</target>
        </trans-unit>
        <trans-unit id="dc6d9abe75ea380074d1386fb6bc4638c51ca405" translate="yes" xml:space="preserve">
          <source>Which is checked first, &lt;code&gt;nomethod&lt;/code&gt; or &lt;code&gt;fallback&lt;/code&gt; ? If the two operands of an operator are of different types and both overload the operator, which implementation is used? The following are the precedence rules:</source>
          <target state="translated">어떤 방법을 먼저 확인 합니까 , &lt;code&gt;nomethod&lt;/code&gt; 또는 &lt;code&gt;fallback&lt;/code&gt; ? 연산자의 두 피연산자가 유형이 다르고 연산자에 과부하가 걸리면 어떤 구현이 사용됩니까? 다음은 우선 순위 규칙입니다.</target>
        </trans-unit>
        <trans-unit id="2db62588fd2906af96c2fa483b06db407a80424f" translate="yes" xml:space="preserve">
          <source>Which is effectively just:</source>
          <target state="translated">실제로는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b3fbe5ee09cb06684cac7d1a3e427f0dd899daef" translate="yes" xml:space="preserve">
          <source>Which is what we might expect, the match finds the only &lt;code&gt;cat&lt;/code&gt; in the string and locks onto it. Consider, however, this regexp:</source>
          <target state="translated">우리가 기대할 수있는 것은 경기가 문자열에서 유일한 &lt;code&gt;cat&lt;/code&gt; 를 찾아서 고정시킵니다. 그러나 다음 정규 표현식을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="b248b8b60b90917a66aeb94063d05f7d477a94bd" translate="yes" xml:space="preserve">
          <source>Which magazines have Perl content?</source>
          <target state="translated">어떤 잡지에 Perl 컨텐츠가 있습니까?</target>
        </trans-unit>
        <trans-unit id="786c2c13e1b48f509ddfa13fe457e7ade1e2d5c4" translate="yes" xml:space="preserve">
          <source>Which makes $richard and $dick the same variable, but leaves @richard and @dick as separate arrays. Tricky, eh?</source>
          <target state="translated">$ richard와 $ dick를 같은 변수로 만들지 만 @richard와 @dick을 별도의 배열로 남겨 둡니다. 까다로운?</target>
        </trans-unit>
        <trans-unit id="c62379639a4b05982ed9a5d227696146f851a074" translate="yes" xml:space="preserve">
          <source>Which of the various &lt;code&gt;*OP&lt;/code&gt; structures this op uses. This should be one of the &lt;code&gt;OA_*&lt;/code&gt; constants from</source>
          <target state="translated">이 op가 사용 하는 다양한 &lt;code&gt;*OP&lt;/code&gt; 구조 중 이것은 &lt;code&gt;OA_*&lt;/code&gt; 상수 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="9c28a2fc8be0459fa3248ceb80936f8aba82ccd2" translate="yes" xml:space="preserve">
          <source>Which of these modifiers is in effect at any given point in a regular expression depends on a fairly complex set of interactions. These have been designed so that in general you don't have to worry about it, but this section gives the gory details. As explained below in &lt;a href=&quot;#Extended-Patterns&quot;&gt;Extended Patterns&lt;/a&gt; it is possible to explicitly specify modifiers that apply only to portions of a regular expression. The innermost always has priority over any outer ones, and one applying to the whole expression has priority over any of the default settings that are described in the remainder of this section.</source>
          <target state="translated">정규식의 특정 지점에서 이러한 수정 자 중 어느 것이 적용되는지는 상당히 복잡한 일련의 상호 작용에 달려 있습니다. 이것들은 일반적으로 당신이 그것에 대해 걱정할 필요가 없도록 설계되었지만,이 섹션은 까다로운 세부 사항을 제공합니다. &lt;a href=&quot;#Extended-Patterns&quot;&gt;확장 패턴&lt;/a&gt; 에서 아래에 설명 된 것처럼 정규 표현식의 일부에만 적용되는 수정자를 명시 적으로 지정할 수 있습니다. 가장 안쪽은 항상 바깥쪽에 우선하며, 전체 표현에 적용되는 하나는이 섹션의 나머지 부분에서 설명하는 기본 설정보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="3d81e570041b9ef8c3716fd625de2184bc9fcbe4" translate="yes" xml:space="preserve">
          <source>Which one you pick depends on which of these expressions better reflects the above specification of comments.</source>
          <target state="translated">어떤 것을 고르는 지에 따라 위의 주석 사양을 더 잘 반영하는 표현이 달라집니다.</target>
        </trans-unit>
        <trans-unit id="79ee8492b912fab00990fc318850246c7ab7a4ba" translate="yes" xml:space="preserve">
          <source>Which perhaps unexpectedly yields:</source>
          <target state="translated">예상치 못한 결과가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4e550746bad7dcee6b1162b28bf7aedac094cd1e" translate="yes" xml:space="preserve">
          <source>Which rules apply are determined as described in &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect? in perlre&lt;/a&gt;.</source>
          <target state="translated">적용 &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;되는 문자 집합 수정 자에&lt;/a&gt; 설명 된대로 적용되는 규칙은 무엇입니까? perlre에서 .</target>
        </trans-unit>
        <trans-unit id="b4ea6c1227777eb0d0611636fc0f0ce8660134f3" translate="yes" xml:space="preserve">
          <source>Which substring to check first.</source>
          <target state="translated">먼저 확인할 하위 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="4b26c1ae972001db5809b34aeb5a2c0bda11feda" translate="yes" xml:space="preserve">
          <source>Which text formatter to use. Default is &lt;a href=&quot;pod/text&quot;&gt;Pod::Text&lt;/a&gt;, or for very old Perl versions &lt;a href=&quot;pod/plaintext&quot;&gt;Pod::PlainText&lt;/a&gt;. An alternative would be e.g. &lt;a href=&quot;pod/text/termcap&quot;&gt;Pod::Text::Termcap&lt;/a&gt;.</source>
          <target state="translated">사용할 텍스트 포맷터 기본값은 &lt;a href=&quot;pod/text&quot;&gt;Pod :: Text&lt;/a&gt; 또는 매우 오래된 Perl 버전 &lt;a href=&quot;pod/plaintext&quot;&gt;Pod :: PlainText&lt;/a&gt; 입니다. 대안은 예를 들어 &lt;a href=&quot;pod/text/termcap&quot;&gt;Pod :: Text :: Termcap&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9b8afbe233aaf49239a07d2a4536a6d9be415fc8" translate="yes" xml:space="preserve">
          <source>Which version of Perl should I use?</source>
          <target state="translated">어떤 버전의 Perl을 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="32a93a6b75c99229f45ca5666bf0720d67cc2e24" translate="yes" xml:space="preserve">
          <source>Which version of perl should I use?</source>
          <target state="translated">어떤 버전의 펄을 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="7631d79fe8017e212e81e096dcea8cb82517cdbf" translate="yes" xml:space="preserve">
          <source>Which web framework should I use?</source>
          <target state="translated">어떤 웹 프레임 워크를 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="1bd7ff93be76f4f655ab909493a6705c72660d9c" translate="yes" xml:space="preserve">
          <source>Which will print</source>
          <target state="translated">어느 것이 인쇄 될 것인가</target>
        </trans-unit>
        <trans-unit id="03d7614f12de55df0b888753d3fa1d0fb28069d7" translate="yes" xml:space="preserve">
          <source>Which would attempt to set breakpoints on lines 4 and 6 immediately after debugger initialization. Note that @DB::typeahead is not a supported interface and is subject to change in future releases.</source>
          <target state="translated">디버거 초기화 직후 줄 4와 6에 중단 점을 설정하려고 시도합니다. @DB :: typeahead는 지원되는 인터페이스가 아니며 향후 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c966532947a1e874f5fbb5570050ef3e1254690b" translate="yes" xml:space="preserve">
          <source>Which would generate a format looking something like this:</source>
          <target state="translated">다음과 같은 형식을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="91c0db76a3c1130f40e63caacba5a278833ffb99" translate="yes" xml:space="preserve">
          <source>Which, in the degenerate case of using only ordinary arrays, gives you multidimensional arrays just like C's:</source>
          <target state="translated">일반 배열 만 사용하는 퇴화 된 경우 C와 같은 다차원 배열을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="49233da44986d650dd0c62f9412171689ae74192" translate="yes" xml:space="preserve">
          <source>Whichever version is used, the actual methods are called in the same context (list, scalar, or void) as the original call via &lt;code&gt;EVERY&lt;/code&gt; , and return:</source>
          <target state="translated">어떤 버전을 사용하든 실제 메소드는 &lt;code&gt;EVERY&lt;/code&gt; 를 통해 원래 호출과 동일한 컨텍스트 (리스트, 스칼라 또는 void)에서 호출 되고 다음을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="fed29deaf6c9f70efd08af26605d88141ad2586b" translate="yes" xml:space="preserve">
          <source>While $FORMAT_TOP_NAME contains the name of the current header format, there is no corresponding mechanism to automatically do the same thing for a footer. Not knowing how big a format is going to be until you evaluate it is one of the major problems. It's on the TODO list.</source>
          <target state="translated">$ FORMAT_TOP_NAME에 현재 머리글 형식의 이름이 포함되어 있지만 바닥 글에 대해 자동으로 동일한 작업을 수행하는 해당 메커니즘은 없습니다. 형식이 얼마나 큰지 알지 못하면 큰 문제 중 하나입니다. TODO 목록에 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0cd08c49ca70b961592a79d7ad5531909d37f26" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; provides integer-only arithmetic, there is no analogous mechanism to provide automatic rounding or truncation to a certain number of decimal places. For rounding to a certain number of digits, &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf()&lt;/a&gt;&lt;/code&gt; is usually the easiest route. See &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt;.</source>
          <target state="translated">동안 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; 의 정수 전용 산술 제공, 소수점의 특정 번호로 자동으로 반올림 또는 절단을 제공 할 유사한 메커니즘이 없습니다. 특정 자릿수로 반올림하는 경우 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf()&lt;/a&gt;&lt;/code&gt; 가 일반적으로 가장 쉬운 경로입니다. &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="01f836f2c1198b05b58549da2eae8767a49ca6a1" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;STORABLE_freeze&lt;/code&gt; and &lt;code&gt;STORABLE_thaw&lt;/code&gt; are useful for classes where each instance is independent, this mechanism has difficulty (or is incompatible) with objects that exist as common process-level or system-level resources, such as singleton objects, database pools, caches or memoized objects.</source>
          <target state="translated">&lt;code&gt;STORABLE_freeze&lt;/code&gt; 및 &lt;code&gt;STORABLE_thaw&lt;/code&gt; 는 각 인스턴스가 독립적 인 클래스에 유용 하지만 이 메커니즘은 단일 프로세스, 데이터베이스 풀, 캐시 또는 메모 화 된 객체와 같은 공통 프로세스 레벨 또는 시스템 레벨 자원으로 존재하는 객체와 어려움이 있거나 호환되지 않습니다. .</target>
        </trans-unit>
        <trans-unit id="4a400d769e405e7503768315d8de6e5c08fa4438" translate="yes" xml:space="preserve">
          <source>While B::Deparse goes to some lengths to try to figure out what your original program was doing, some parts of the language can still trip it up; it still fails even on some parts of Perl's own test suite. If you encounter a failure other than the most common ones described in the BUGS section below, you can help contribute to B::Deparse's ongoing development by submitting a bug report with a small example.</source>
          <target state="translated">B :: Deparse는 원래의 프로그램이 무엇을하는지 알아 내기 위해 어느 정도 노력을 기울이지 만 언어의 일부는 여전히 트립 될 수 있습니다. Perl 자체 테스트 스위트의 일부에서도 여전히 실패합니다. 아래의 BUGS 섹션에 설명 된 가장 일반적인 오류 이외의 오류가 발생하면 작은 예제를 사용하여 버그 보고서를 제출하여 B :: Deparse의 지속적인 개발에 기여할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fb4e05a5830c846a9dc5981bceec998799ac3ed" translate="yes" xml:space="preserve">
          <source>While BigInt has extensive handling of inf and NaN, certain quirks remain.</source>
          <target state="translated">BigInt는 inf 및 NaN을 광범위하게 처리하지만 특정 문제는 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd702ed1f93515e973caeb556144e84284909d1e" translate="yes" xml:space="preserve">
          <source>While C guarantees the ordering specified in the struct definition, between different platforms the definitions might differ</source>
          <target state="translated">C는 구조체 정의에 지정된 순서를 보장하지만 다른 플랫폼 간에는 정의가 다를 수 있습니다</target>
        </trans-unit>
        <trans-unit id="cc4691f27fe5f793a7b1a252b87e1f8adf7ae71b" translate="yes" xml:space="preserve">
          <source>While Dan Kogai retains the copyright as a maintainer, credit should go to all those involved. See AUTHORS for a list of those who submitted code to the project.</source>
          <target state="translated">Dan Kogai는 저작권을 유지 관리자로 유지하지만 신용은 관련된 모든 사람에게 제공해야합니다. 프로젝트에 코드를 제출 한 사람들의 목록은 저자를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e79628255662d7502ebd0e9fa4c3c1aca53d77c4" translate="yes" xml:space="preserve">
          <source>While Perl attempts to keep the vaxc$errno value to be current, if errno is not EVMSERR, it may not be from the current operation.</source>
          <target state="translated">Perl은 vaxc $ errno 값을 현재 상태로 유지하려고 시도하지만 errno가 EVMSERR이 아닌 경우 현재 조작이 아닐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82ff355555ab6d2ce0a2840754c6edfffe9b0329" translate="yes" xml:space="preserve">
          <source>While Perl passes arguments to functions by reference, C passes arguments by value; to implement a C function which modifies data of one of the &quot;arguments&quot;, the actual argument of this C function would be a pointer to the data. Thus two C functions with declarations</source>
          <target state="translated">Perl은 참조로 함수에 인수를 전달하지만 C는 값으로 인수를 전달합니다. &quot;인수&quot;중 하나의 데이터를 수정하는 C 함수를 구현하려면이 C 함수의 실제 인수는 데이터에 대한 포인터입니다. 따라서 선언이있는 두 개의 C 함수</target>
        </trans-unit>
        <trans-unit id="c23f9c83568988309005d4ebe9f3a7a4c7b974ed" translate="yes" xml:space="preserve">
          <source>While System V IPC isn't so widely used as sockets, it still has some interesting uses. However, you cannot use SysV IPC or Berkeley mmap() to have a variable shared amongst several processes. That's because Perl would reallocate your string when you weren't wanting it to. You might look into the &lt;code&gt;IPC::Shareable&lt;/code&gt; or &lt;code&gt;threads::shared&lt;/code&gt; modules for that.</source>
          <target state="translated">System V IPC는 소켓으로 널리 사용되지는 않지만 여전히 흥미로운 용도로 사용됩니다. 그러나 SysV IPC 또는 Berkeley mmap ()을 사용하여 여러 프로세스간에 변수를 공유 할 수는 없습니다. 펄은 원하지 않을 때 문자열을 재 할당하기 때문입니다. 이를 위해 &lt;code&gt;IPC::Shareable&lt;/code&gt; 또는 &lt;code&gt;threads::shared&lt;/code&gt; 모듈을 살펴볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="95ba383e6ad59d1d5877dab883127e0598dee045" translate="yes" xml:space="preserve">
          <source>While a nice extension, it's not portable. The Perl code does admittedly use them if available to gain some extra speed (essentially as a funky form of inlining), but you shouldn't.</source>
          <target state="translated">멋진 확장 기능이지만 이식성이 없습니다. Perl 코드는 가능한 경우 여분의 속도를 얻는 데 사용되는 경우 (필수적으로 펑키 인라인 형태로) 인정하지만 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="98ac33662fa3d3f638b9cfcc69effe66a6af5d40" translate="yes" xml:space="preserve">
          <source>While a search is in progress, the progress object's &lt;code&gt;reach&lt;/code&gt; and &lt;code&gt;done&lt;/code&gt; methods are called like this:</source>
          <target state="translated">검색이 진행되는 동안 진행률 객체의 &lt;code&gt;reach&lt;/code&gt; 및 &lt;code&gt;done&lt;/code&gt; 메소드는 다음과 같이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5af2731519a4e72226e3efaa5ed68cb8f21ac8fa" translate="yes" xml:space="preserve">
          <source>While apparently a whole nuther program,</source>
          <target state="translated">분명히 전체적인 프로그램이지만</target>
        </trans-unit>
        <trans-unit id="2192d44f9e946df5ee1f8628bb7cf84591b693e7" translate="yes" xml:space="preserve">
          <source>While building Perl some changes may be necessary to your Cygwin setup so that Perl builds cleanly. These changes are &lt;b&gt;not&lt;/b&gt; required for normal Perl usage.</source>
          <target state="translated">Perl을 빌드하는 동안 Perl이 깔끔하게 빌드되도록 Cygwin 설정에 일부 변경이 필요할 수 있습니다. 일반적인 Perl 사용 에는 이러한 변경이 필요 &lt;b&gt;하지 않습니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="917e67f81e56107e856d601af96f9ace961e9a9a" translate="yes" xml:space="preserve">
          <source>While checking, this module collects document properties, e.g. the nodes for hyperlinks (&lt;code&gt;=headX&lt;/code&gt; , &lt;code&gt;=item&lt;/code&gt; ) and index entries (&lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; ). POD translators can use this feature to syntax-check and get the nodes in a first pass before actually starting to convert. This is expensive in terms of execution time, but allows for very robust conversions.</source>
          <target state="translated">확인하는 동안이 모듈은 문서 속성, 예를 들어 하이퍼 링크 노드 ( &lt;code&gt;=headX&lt;/code&gt; , &lt;code&gt;=item&lt;/code&gt; ) 및 색인 항목 ( &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; )을 수집합니다 . POD 변환기는이 기능을 사용하여 실제로 변환을 시작하기 전에 구문을 검사하고 첫 번째 패스에서 노드를 가져올 수 있습니다. 실행 시간 측면에서 비용이 많이 들지만 매우 강력한 변환이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="6234d5fa2f6fac6ddbcf991bea921371b64250cc" translate="yes" xml:space="preserve">
          <source>While experts may argue about these idioms, a novice to Perl guts may prefer a way which is as little Perl-guts-specific as possible, meaning automatic conversion and automatic call generation, as in &lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;Getting the fat out of XSUBs&lt;/a&gt;. This approach has the additional benefit of protecting the XSUB writer from future changes to the Perl API.</source>
          <target state="translated">전문가들은 이러한 관용구에 대해 논쟁 할 수 있지만, Perl 내장 초보자 &lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;는 XSUB에서 지방을 빼내는&lt;/a&gt; 것과 같이 자동 변환 및 자동 호출 생성을 의미하는 Perl 내장에 대해 가능한 한 적은 방법을 선호 할 수 있습니다 . 이 접근 방식은 XSUB 기록기가 Perl API의 향후 변경으로부터 보호 할 수있는 추가 이점을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="601070e02f682375d5e25990b39de3389f3b8c49" translate="yes" xml:space="preserve">
          <source>While in principle the &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; operator could be implemented via (and with the same rather severe limitations as) the CRTL &lt;code&gt;vfork()&lt;/code&gt; routine, and while some internal support to do just that is in place, the implementation has never been completed, making &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; currently unavailable. A true kernel &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; is expected in a future version of VMS, and the pseudo-fork based on interpreter threads may be available in a future version of Perl on VMS (see &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt;). In the meantime, use &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, backticks, or piped filehandles to create subprocesses.</source>
          <target state="translated">원칙적으로 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 연산자는 CRTL &lt;code&gt;vfork()&lt;/code&gt; 루틴을 통해 구현할 수 있으며 (그와 동일한 제한이 있지만), 이를 수행하기위한 내부 지원이 있지만 구현은 완료되지 않았으며 현재 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 만듭니다. 없는. 향후 버전의 VMS에서는 실제 커널 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 가 예상되며, 인터프리터 스레드를 기반으로하는 의사 포크는 VMS에서 Perl의 향후 버전에서 사용할 수 있습니다 ( &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt; 참조 ). 그 동안 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; , backticks 또는 piped 파일 핸들을 사용하여 서브 프로세스를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="a11b15d87bb1f9501075e6254f16292a57b123f0" translate="yes" xml:space="preserve">
          <source>While in this mode, Perl takes special precautions called</source>
          <target state="translated">이 모드에서 Perl은 특별한 예방 조치를 취합니다.</target>
        </trans-unit>
        <trans-unit id="7c260f0d64ec7ed3061fae8a4547b586a55f37c5" translate="yes" xml:space="preserve">
          <source>While it is permissible to &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; a FileCache managed file, do not do so if you are calling &lt;code&gt;FileCache::cacheout&lt;/code&gt; from a package other than which it was imported, or with another module which overrides &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt;. If you must, use &lt;code&gt;FileCache::cacheout_close&lt;/code&gt; .</source>
          <target state="translated">FileCache 관리 파일 을 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 수는 있지만 &lt;code&gt;FileCache::cacheout&lt;/code&gt; 을 가져온 패키지 이외의 패키지에서 호출 하거나 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 를 재정의하는 다른 모듈 로 호출하는 경우에는 그렇게하지 마십시오 . 필요한 경우 &lt;code&gt;FileCache::cacheout_close&lt;/code&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="959732eaecdd2fded6d5f4730815e7ecfbb3c6a3" translate="yes" xml:space="preserve">
          <source>While it's not necessary for documentation changes, new tests or trivial patches, it's often worth explaining how your change works. Even if it's clear to you today, it may not be clear to a porter next month or next year.</source>
          <target state="translated">문서 변경, 새로운 테스트 또는 사소한 패치에는 필요하지 않지만 변경의 작동 방식을 설명하는 것이 좋습니다. 오늘 당신에게 분명하더라도, 다음 달 또는 내년에 포터에게는 명확하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44568ef65eee77bd20a0348b5e9b725eb8d8f779" translate="yes" xml:space="preserve">
          <source>While it's possible to refer directly to these hash keys outside of the class, it's considered a best practice to wrap all access to the attribute with accessor methods.</source>
          <target state="translated">클래스 외부에서 이러한 해시 키를 직접 참조 할 수는 있지만 접근 자 메서드로 속성에 대한 모든 액세스를 래핑하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d0849418f5c8269f5aff84704c4d9acb674dcdcc" translate="yes" xml:space="preserve">
          <source>While it's true that Perl's regular expressions resemble the DFAs (deterministic finite automata) of the egrep(1) program, they are in fact implemented as NFAs (non-deterministic finite automata) to allow backtracking and backreferencing. And they aren't POSIX-style either, because those guarantee worst-case behavior for all cases. (It seems that some people prefer guarantees of consistency, even when what's guaranteed is slowness.) See the book &quot;Mastering Regular Expressions&quot; (from O'Reilly) by Jeffrey Friedl for all the details you could ever hope to know on these matters (a full citation appears in &lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2&lt;/a&gt;).</source>
          <target state="translated">Perl의 정규 표현식이 egrep (1) 프로그램의 DFA (결정적 유한 오토마타)와 유사하지만 사실 역 추적 및 역 참조를 허용하기 위해 NFA (비 결정적 유한 오토마타)로 구현됩니다. 그리고 POSIX 스타일도 아닙니다. 왜냐하면 모든 경우에 최악의 행동을 보장하기 때문입니다. (일부 사람들은 일관성이 보장되는 것이 느린 경우에도 일관성을 보장하는 것을 선호하는 것 같습니다.) Jeffrey Friedl의 &quot;정규 표현식 마스터 링&quot;(O'Reilly의 책) 책에서 이러한 문제에 대해 알고 자하는 모든 세부 정보를 참조하십시오 ( 전체 인용이 &lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2에&lt;/a&gt; 나타납니다 ).</target>
        </trans-unit>
        <trans-unit id="3329779b59b299850e8b68832610b0b339dc0b1f" translate="yes" xml:space="preserve">
          <source>While it's true that this documentation is somewhat subserious, if you use a program named</source>
          <target state="translated">이 문서가 다소 지루한 것이 사실이지만, 이름이 지정된 프로그램을 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="10a36fcf99a8e338089d469f203ab0168ce94e49" translate="yes" xml:space="preserve">
          <source>While literal lists and named arrays are often interchangeable, that's not the case for hashes. Just because you can subscript a list value like a normal array does not mean that you can subscript a list value as a hash. Likewise, hashes included as parts of other lists (including parameters lists and return lists from functions) always flatten out into key/value pairs. That's why it's good to use references sometimes.</source>
          <target state="translated">리터럴 목록과 명명 된 배열은 종종 상호 교환이 가능하지만 해시에는 해당되지 않습니다. 일반 배열처럼 목록 값을 첨자화할 수 있다고해서 목록 값을 해시로 첨자화할 수있는 것은 아닙니다. 마찬가지로, 다른 목록의 일부로 포함 된 해시 (매개 변수 목록 및 함수의 반환 목록 포함)는 항상 키 / 값 쌍으로 전개됩니다. 따라서 때때로 참조를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="eca6e56d146060aa14a3a670fa7ed2185164c9b5" translate="yes" xml:space="preserve">
          <source>While most important values in this file</source>
          <target state="translated">이 파일에서 가장 중요한 값은</target>
        </trans-unit>
        <trans-unit id="393059c305b4f9157627b86935072088d84089d3" translate="yes" xml:space="preserve">
          <source>While none of the built-in data types have any arbitrary size limits (apart from memory size), there are still a few arbitrary limits: a given variable name may not be longer than 251 characters. Line numbers displayed by diagnostics are internally stored as short integers, so they are limited to a maximum of 65535 (higher numbers usually being affected by wraparound).</source>
          <target state="translated">내장 데이터 유형 중 임의의 크기 제한 (메모리 크기 제외)이없는 경우에도 여전히 임의의 제한이 있습니다. 주어진 변수 이름은 251자를 초과 할 수 없습니다. 진단에 의해 표시되는 행 번호는 내부적으로 짧은 정수로 저장되므로 최대 65535 (일반적으로 랩 어라운드의 영향을받는 숫자)로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="1f300b76b4f41dcdc512a5b3661d8c1aa39ba74e" translate="yes" xml:space="preserve">
          <source>While not entirely limited to Unix-derived operating systems (e.g., WinSock on PCs provides socket support, as do some VMS libraries), you might not have sockets on your system, in which case this section probably isn't going to do you much good. With sockets, you can do both virtual circuits like TCP streams and datagrams like UDP packets. You may be able to do even more depending on your system.</source>
          <target state="translated">유닉스 파생 운영 체제 (예 : PC의 WinSock에서 일부 VMS 라이브러리와 같이 소켓 지원을 제공함)에만 전적으로 제한되지는 않지만 시스템에 소켓이 없을 수 있습니다. 좋은. 소켓을 사용하면 TCP 스트림과 같은 가상 회로와 UDP 패킷과 같은 데이터 그램을 모두 수행 할 수 있습니다. 시스템에 따라 더 많은 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ad3cf3a478c4f24fb9ef9675cf14d8e5c5a06f1" translate="yes" xml:space="preserve">
          <source>While running Configure and when building, you are likely to get quite a few of these warnings:</source>
          <target state="translated">Configure를 실행하거나 빌드 할 때 다음과 같은 경고가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="9b58fa2736239282292bc4dda51122cd95ae2910" translate="yes" xml:space="preserve">
          <source>While short identifiers like &lt;code&gt;$gotit&lt;/code&gt; are probably ok, use underscores to separate words in longer identifiers. It is generally easier to read &lt;code&gt;$var_names_like_this&lt;/code&gt; than &lt;code&gt;$VarNamesLikeThis&lt;/code&gt; , especially for non-native speakers of English. It's also a simple rule that works consistently with &lt;code&gt;VAR_NAMES_LIKE_THIS&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$gotit&lt;/code&gt; 과 같은 짧은 식별자는 괜찮을지 모르지만 밑줄을 사용하여 더 긴 식별자로 단어를 구분하십시오. 일반적으로 영어가 모국어가 아닌 사용자의 경우 &lt;code&gt;$VarNamesLikeThis&lt;/code&gt; 보다 &lt;code&gt;$var_names_like_this&lt;/code&gt; 를 읽는 것이 일반적으로 더 쉽습니다 . &lt;code&gt;VAR_NAMES_LIKE_THIS&lt;/code&gt; 와 일관되게 작동하는 간단한 규칙이기도합니다 .</target>
        </trans-unit>
        <trans-unit id="ae3268e08a1d3bd058ed6f797f7794fd47fc37b4" translate="yes" xml:space="preserve">
          <source>While some developers find fatalizing some warnings to be a useful defensive programming technique, using &lt;code&gt;FATAL =&amp;gt; 'all'&lt;/code&gt; to fatalize all possible warning categories -- including custom ones -- is particularly risky. Therefore, the use of &lt;code&gt;FATAL =&amp;gt; 'all'&lt;/code&gt; is &lt;a href=&quot;perlpolicy#discouraged&quot;&gt;discouraged&lt;/a&gt;.</source>
          <target state="translated">일부 개발자는 일부 경고를 유용한 방어 프로그래밍 기술로 &lt;code&gt;FATAL =&amp;gt; 'all'&lt;/code&gt; 을 사용하여 사용자 지정 범주를 포함하여 가능한 모든 경고 범주를 치 명화하는 것이 특히 위험합니다. 따라서, 사용 &lt;code&gt;FATAL =&amp;gt; 'all'&lt;/code&gt; 입니다 &lt;a href=&quot;perlpolicy#discouraged&quot;&gt;낙담&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f10f744968048551bad6ee098cf44a11a372745" translate="yes" xml:space="preserve">
          <source>While still in that directory, type:</source>
          <target state="translated">해당 디렉토리에있는 동안 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="42ffebb3bbe4e65d94b8f907df7dc389a8053ee0" translate="yes" xml:space="preserve">
          <source>While the GNU project includes Perl in its distributions, there's no such thing as &quot;GNU Perl&quot;. Perl is not produced nor maintained by the Free Software Foundation. Perl's licensing terms are also more open than GNU software's tend to be.</source>
          <target state="translated">GNU 프로젝트에는 배포판에 Perl이 포함되어 있지만 &quot;GNU Perl&quot;과 같은 것은 없습니다. Perl은 Free Software Foundation에서 생산하거나 유지 관리하지 않습니다. Perl의 라이센스 조건은 GNU 소프트웨어보다 더 개방적입니다.</target>
        </trans-unit>
        <trans-unit id="bcb3c100d2dfc2d28078ac3b93ee7e431111c075" translate="yes" xml:space="preserve">
          <source>While the Unicode Standard defines two additional forms of casefolding, one for Turkic languages and one that never maps one character into multiple characters, these are not provided by the Perl core; However, the CPAN module &lt;code&gt;Unicode::Casing&lt;/code&gt; may be used to provide an implementation.</source>
          <target state="translated">유니 코드 표준은 투르크어 언어와 하나의 문자를 여러 문자로 맵핑하지 않는 두 가지 추가적인 케이스 폴딩 형식을 정의하지만 Perl 코어는이를 제공하지 않습니다. 그러나 CPAN 모듈 &lt;code&gt;Unicode::Casing&lt;/code&gt; 을 사용하여 구현을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="761ba2f6d0a7dac9fb4c5d145960b451d6d26420" translate="yes" xml:space="preserve">
          <source>While the key must be a string value (since that's a basic restriction that Perl places on hash keys), the value in the lexicon can currently be of several types: a defined scalar, scalarref, or coderef. The use of these is explained above, in the section 'The &quot;maketext&quot; Method', and Bracket Notation for strings is discussed in the next section.</source>
          <target state="translated">키는 문자열 값이어야하지만 (Perl이 해시 키에 적용하는 기본 제한이므로) 사전의 값은 현재 정의 된 스칼라, 스칼라 참조 또는 코드 참조의 여러 유형일 수 있습니다. 이것의 사용법은 위에서 &quot;maketext&quot;메소드와 문자열에 대한 브라켓 표기법 섹션에서 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="d08b05105bcedd2fb07dc0399888e4c9d241f3f1" translate="yes" xml:space="preserve">
          <source>While the list of arguments might work fine for one, two or even three arguments, any more arguments become hard for the module user to remember, and hard for the module author to manage. If you want to add a new parameter you will have to add it to the end of the list for backward compatibility, and this will probably make your list order unintuitive. Also, if many elements may be undefined you may see the following unattractive method calls:</source>
          <target state="translated">인수 목록은 하나, 둘 또는 세 개의 인수에 대해 잘 작동 할 수 있지만 더 이상 인수는 모듈 사용자가 기억하기 어렵고 모듈 작성자가 관리하기 어려워집니다. 새 매개 변수를 추가하려면 이전 버전과의 호환성을 위해 목록 끝에 추가해야합니다. 그러면 목록 순서가 직관적이지 않을 수 있습니다. 또한 많은 요소가 정의되지 않은 경우 다음과 같은 매력적이지 않은 메소드 호출이 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="019950bbf16db8b6543648ebb335d2eaf049366f" translate="yes" xml:space="preserve">
          <source>While the mapping &quot;infin&quot; to the character &quot;\x{221E}&quot; will (hopefully) have been already handled by the Pod parser, the presence of the character in this file means that it's reasonably important enough to include in a formatter's table that maps from notable Unicode characters to the codes necessary for rendering them. So for a Unicode-to-*roff mapping, for example, this would merit the entry:</source>
          <target state="translated">&quot;\ x {221E}&quot;문자에 대한 &quot;infin&quot;매핑은 포드 파서에서 이미 처리 했음에도 불구하고이 파일에 문자가 있으면 포맷터의 테이블에 포함하기에 충분히 합리적이라는 것을 의미합니다. 주목할만한 유니 코드 문자를 렌더링에 필요한 코드로 매핑합니다. 예를 들어, 유니 코드-투-오프 매핑의 경우 다음과 같은 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="549c813f59b3276935336cbd28f55b4770622941" translate="yes" xml:space="preserve">
          <source>While the two classes may differ in many ways, when it comes to the &lt;code&gt;print_content()&lt;/code&gt; method, they are the same. This means that we can try to call the &lt;code&gt;print_content()&lt;/code&gt; method on an object of either class, and &lt;b&gt;we don't have to know what class the object belongs to!&lt;/b&gt;</source>
          <target state="translated">두 클래스는 여러면에서 다를 수 있지만 &lt;code&gt;print_content()&lt;/code&gt; 메소드와 관련하여 동일합니다. 이것은 우리 가 어느 클래스의 객체 에서 &lt;code&gt;print_content()&lt;/code&gt; 메소드 를 호출하려고 시도 할 수 있고 객체가 &lt;b&gt;어떤 클래스에 속하는지 알 필요가 없다는 것을 의미합니다!&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="05f8c54acc4d9406822b250e87f501917fa0a683" translate="yes" xml:space="preserve">
          <source>While there are currently no architecture-specific extensions or modules distributed with perl, the following directories can be used to hold such files (replace the string VERSION by the appropriate version number):</source>
          <target state="translated">현재 perl과 함께 배포 된 아키텍처 별 확장 또는 모듈은 없지만 다음 디렉토리를 사용하여 해당 파일을 보유 할 수 있습니다 (문자열 VERSION을 적절한 버전 번호로 대체).</target>
        </trans-unit>
        <trans-unit id="0c8516dbb58fd38e067d471797d458e282eb5b87" translate="yes" xml:space="preserve">
          <source>While these operations are not questions of life and death, they are needed for a lot of useful scripts. This forces &lt;code&gt;a.out&lt;/code&gt; -style compile of</source>
          <target state="translated">이러한 작업은 삶과 죽음의 문제가 아니지만 유용한 스크립트가 많이 필요합니다. 이것은 &lt;code&gt;a.out&lt;/code&gt; 스타일의 컴파일을 강제합니다.</target>
        </trans-unit>
        <trans-unit id="1849a634e96a61e2b3cdef3b11aa962d9aad4c39" translate="yes" xml:space="preserve">
          <source>While this actually can be done, it's much harder than you'd think. For example, this one-liner</source>
          <target state="translated">실제로이 작업을 수행 할 수 있지만 생각보다 훨씬 어렵습니다. 예를 들어,이 하나의 라이너</target>
        </trans-unit>
        <trans-unit id="c8b72cb61463146c67f31be1d892fe7495f6bd9f" translate="yes" xml:space="preserve">
          <source>While this allows some (significant?) performance advantages, this makes life much harder for developers, since the above scheme makes it impossible for a DLL to be &quot;linked&quot; to a symbol in the</source>
          <target state="translated">이로 인해 일부 (유용한) 성능 이점이 허용되지만, 위의 구성표를 통해 DLL을 심볼에 &quot;링크&quot;할 수 없기 때문에 개발자의 삶이 훨씬 어려워집니다.</target>
        </trans-unit>
        <trans-unit id="5a4ded2cb5289b97c3775e062e86790bf5432277" translate="yes" xml:space="preserve">
          <source>While this class is currently implemented using the Class::Struct module to build a struct-like class, you shouldn't rely upon this.</source>
          <target state="translated">이 클래스는 현재 Class :: Struct 모듈을 사용하여 구현되어 구조체와 유사한 클래스를 작성하지만이 클래스에 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="e68b146940f9324cc2fc3ad49971a5aa379db2a9" translate="yes" xml:space="preserve">
          <source>While this compiles and runs happily, it probably won't do what's expected, namely it doesn't print &quot;Hello World\n&quot; at all; It will on the other hand do exactly what it was told to do, computers being a bit that way inclined. That is, it will print out a newline character, and you'll get what looks like a blank line. It looks like there's 2 variables when (because of the typo) there's really 3:</source>
          <target state="translated">컴파일과 실행이 행복하지만, 예상대로하지 않을 것입니다. 즉 &quot;Hello World \ n&quot;을 전혀 인쇄하지 않습니다. 다른 한편으로는, 컴퓨터가 그렇게 기울어 지도록 지시받은대로 정확하게 할 것입니다. 즉, 줄 바꿈 문자를 인쇄하고 빈 줄처럼 보입니다. (오타 때문에) 실제로 3이있을 때 2 개의 변수가있는 것처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="b959fa7d0d0730d45d9d80c8527dc6a6d9341163" translate="yes" xml:space="preserve">
          <source>While this currently exists in all three implementations perl itself does not use it.</source>
          <target state="translated">이것은 현재 세 가지 구현 모두에 존재하지만 펄 자체는 그것을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f084942a5c159bd226784a38fd066229baa22988" translate="yes" xml:space="preserve">
          <source>While this document is intended to be useful to all module authors, it is particularly aimed at authors who wish to publish their modules on CPAN.</source>
          <target state="translated">이 문서는 모든 모듈 작성자에게 유용하기는하지만 특히 CPAN에 모듈을 게시하려는 저자를 대상으로합니다.</target>
        </trans-unit>
        <trans-unit id="1785d6466e3128c272757d8a3931f08ab9e01f53" translate="yes" xml:space="preserve">
          <source>While this is legal practice, it is certainly dubious, and downright fatal in at least one platform: for example VMS cc considers this a fatal error. One cause for people often making this mistake is that a &quot;naked char&quot; and therefore dereferencing a &quot;naked char pointer&quot; have an undefined signedness: it depends on the compiler and the flags of the compiler and the underlying platform whether the result is signed or unsigned. For this very same reason using a 'char' as an array index is bad.</source>
          <target state="translated">이것은 법적 관행이지만 적어도 하나의 플랫폼에서 확실히 모호하고 치명적입니다. 예를 들어 VMS cc는이를 치명적인 오류로 간주합니다. 사람들이 종종이 실수를 저지르는 한 가지 원인은 &quot;알몸 문자&quot;와 &quot;알몸 문자 포인터&quot;를 역 참조하는 것은 정의되지 않은 부호를 갖기 때문입니다. 결과는 서명 여부에 따라 컴파일러와 컴파일러의 플래그 및 기본 플랫폼에 따라 다릅니다. 부호없는. 이와 같은 이유로 'char'를 배열 인덱스로 사용하는 것은 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="40200d6701039334e5e5bffbb6cca8ab91bc30ff" translate="yes" xml:space="preserve">
          <source>While this is true on the surface, it's much more efficient to process the file one line or record at a time because then you don't have to read the whole thing into memory at once. It also gives you finer control of the whole process, letting you kill off the child process early if you'd like.</source>
          <target state="translated">표면적으로는 사실이지만 한 번에 한 줄씩 파일을 처리하거나 한 번에 기록하는 것이 훨씬 효율적입니다. 따라서 전체 내용을 한 번에 메모리로 읽을 필요가 없기 때문입니다. 또한 전체 프로세스를보다 세밀하게 제어 할 수 있으므로 원하는 경우 자식 프로세스를 조기에 종료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9790d6e959def47c7e50e558f607fe7ba4374a90" translate="yes" xml:space="preserve">
          <source>While this might be too cumbersome to implement in event-based Pod parsers, it is straightforward for parsers that return parse trees.</source>
          <target state="translated">이벤트 기반 포드 파서에서 구현하기에는 너무 번거로울 수 있지만 파싱 트리를 반환하는 파서는 간단합니다.</target>
        </trans-unit>
        <trans-unit id="81aa0dd02571c7973cd68f4d9f805b1c67ff2c9c" translate="yes" xml:space="preserve">
          <source>While this might by accident work in some platform (where IV happens to be an &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;), in general it cannot. IV might be something larger. Even worse the situation is with more specific types (defined by Perl's configuration step in</source>
          <target state="translated">이것은 우연히 일부 플랫폼 (IV가 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 인 경우 )에서 작동하지만 일반적으로는 불가능합니다. IV는 더 클 수도 있습니다. 더 나쁜 상황은보다 구체적인 유형 (Perl의 구성 단계에서 정의 됨)</target>
        </trans-unit>
        <trans-unit id="82be9c7a2de102e2677bf88ba7443091644097cd" translate="yes" xml:space="preserve">
          <source>While this works reasonably well for unidirectional communication, what about bidirectional communication? The most obvious approach doesn't work:</source>
          <target state="translated">이것은 단방향 통신에 합리적으로 잘 작동하지만 양방향 통신은 어떻습니까? 가장 확실한 접근법은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="26ea84a69e787188d7dfd7dc7bac4a8b95950ee8" translate="yes" xml:space="preserve">
          <source>While threads bring a new set of useful tools, they also bring a number of pitfalls. One pitfall is the race condition:</source>
          <target state="translated">쓰레드는 새로운 유용한 도구 세트를 제공하지만 많은 함정을 가져옵니다. 하나의 함정은 경쟁 조건입니다.</target>
        </trans-unit>
        <trans-unit id="8fb55e176d75bb6afa2c9779e5d12c3767454404" translate="yes" xml:space="preserve">
          <source>While trying to read from his caller-id box, the notorious Jamie Zawinski &lt;code&gt;&amp;lt;jwz@netscape.com&amp;gt;&lt;/code&gt; , after much gnashing of teeth and fighting with &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;, POSIX's &lt;code&gt;tcgetattr&lt;/code&gt; business, and various other functions that go bump in the night, finally came up with this:</source>
          <target state="translated">자신의 발신자 표시 상자에서 악명 높은 Jamie Zawinski &lt;code&gt;&amp;lt;jwz@netscape.com&amp;gt;&lt;/code&gt; 을 읽으려고 시도하는 동안 치아가 많이 &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; , POSIX의 &lt;code&gt;tcgetattr&lt;/code&gt; 비즈니스 및 밤에 부딪히는 다양한 다른 기능 과 싸우고 나면 , 마침내 이것을 생각해 냈습니다.</target>
        </trans-unit>
        <trans-unit id="5ffa8b7afc028fdbcdab4b6dea3d1eb48e0f55ad" translate="yes" xml:space="preserve">
          <source>While using the standard</source>
          <target state="translated">표준을 사용하는 동안</target>
        </trans-unit>
        <trans-unit id="c059f6308f685a568f9b74b626f917b18a45a114" translate="yes" xml:space="preserve">
          <source>While version objects overload stringification, to portably convert &lt;code&gt;$^V&lt;/code&gt; into its string representation, use &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&quot;%vd&quot;&lt;/code&gt; conversion, which works for both v-strings or version objects:</source>
          <target state="translated">버전 객체 가 문자열 화를 오버로드하는 동안 &lt;code&gt;$^V&lt;/code&gt; 를 문자열 표현으로 이식 가능하게 변환 하려면 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&quot;%vd&quot;&lt;/code&gt; 변환을 사용하십시오. 이는 v- 문자열 또는 버전 객체 모두에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="3a5995cddc89ffbbaa6e8a0013934033bfcd3e1f" translate="yes" xml:space="preserve">
          <source>While versions earlier than 5.8.1 had threads they contain too many bugs to support.</source>
          <target state="translated">5.8.1 이전 버전에는 스레드가 있지만 지원하기에는 너무 많은 버그가 있습니다.</target>
        </trans-unit>
        <trans-unit id="daa9a857c615b0eef13a54df6fdfd26532388959" translate="yes" xml:space="preserve">
          <source>While we normally think of patterns as being delimited with &lt;code&gt;/&lt;/code&gt; characters, they can be delimited by almost any character. &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; describes this. For example, the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; above uses braces as delimiters. Selecting another delimiter can avoid quoting the delimiter within the pattern:</source>
          <target state="translated">일반적으로 패턴은 &lt;code&gt;/&lt;/code&gt; 문자 로 구분되는 것으로 생각하지만 거의 모든 문자로 구분할 수 있습니다. &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; 는 이것을 설명합니다. 예를 들어, 위 의 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 는 중괄호를 구분 기호로 사용합니다. 다른 구분 기호를 선택하면 패턴 내에서 구분 기호를 인용하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="09af51d2e240602d6d93896cb9f587c7a82f4e64" translate="yes" xml:space="preserve">
          <source>While we strongly suggest you don't build your objects from scratch, you should know the term &lt;b&gt;bless&lt;/b&gt;. A &lt;b&gt;blessed&lt;/b&gt; data structure (aka &quot;a referent&quot;) is an object. We sometimes say that an object has been &quot;blessed into a class&quot;.</source>
          <target state="translated">객체를 처음부터 만들지 말 것을 강력히 권하지만 &lt;b&gt;축복&lt;/b&gt; 이라는 용어를 알아야합니다 . &lt;b&gt;복&lt;/b&gt; 데이터 구조 (일명 &quot;는 지시 대상&quot;)는 목적으로한다. 우리는 때때로 어떤 대상이&amp;ldquo;계급으로 축복 받았다&amp;rdquo;고 말합니다.</target>
        </trans-unit>
        <trans-unit id="562c113d1f1007e0a6502247b3772bac3c2d33a2" translate="yes" xml:space="preserve">
          <source>While we usually think of quotes as literal values, in Perl they function as operators, providing various kinds of interpolating and pattern matching capabilities. Perl provides customary quote characters for these behaviors, but also provides a way for you to choose your quote character for any of them. In the following table, a &lt;code&gt;{}&lt;/code&gt; represents any pair of delimiters you choose.</source>
          <target state="translated">우리는 일반적으로 인용 부호를 리터럴 값으로 생각하지만 Perl에서는 다양한 보간 및 패턴 일치 기능을 제공하는 연산자로 작동합니다. Perl은 이러한 동작에 대한 따옴표 문자를 제공하지만 따옴표 문자를 선택할 수있는 방법도 제공합니다. 다음 표에서 &lt;code&gt;{}&lt;/code&gt; 는 선택한 구분 기호 쌍을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="34200b2d58936bc37828d3e87d2eebbab2c0f898" translate="yes" xml:space="preserve">
          <source>While we're here, take a closer look at the '&lt;b&gt;x&lt;/b&gt;' command, it's really useful and will merrily dump out nested references, complete objects, partial objects - just about whatever you throw at it:</source>
          <target state="translated">우리가 여기있는 동안 ' &lt;b&gt;x&lt;/b&gt; '명령을 자세히 살펴보면 실제로 유용하며 중첩 된 참조, 완전한 객체, 부분 객체를 버릴 것입니다.</target>
        </trans-unit>
        <trans-unit id="00e2fed4a06f99f6100461a2d8cbb333f4d09501" translate="yes" xml:space="preserve">
          <source>While you can mix double colons with singles quotes, the quotes must come after the colons: &lt;code&gt;$::::'foo&lt;/code&gt; and &lt;code&gt;$foo::'bar&lt;/code&gt; are legal, but &lt;code&gt;$::'::foo&lt;/code&gt; and &lt;code&gt;$foo'::bar&lt;/code&gt; are not.</source>
          <target state="translated">이중 콜론을 단일 인용 부호와 혼합 할 수 있지만 인용 부호는 콜론 뒤에 와야합니다 : &lt;code&gt;$::::'foo&lt;/code&gt; 및 &lt;code&gt;$foo::'bar&lt;/code&gt; 는 합법적이지만 &lt;code&gt;$::'::foo&lt;/code&gt; 및 &lt;code&gt;$foo'::bar&lt;/code&gt; 아닙니다.</target>
        </trans-unit>
        <trans-unit id="078d591b0ade8bcb579420345c7df7b2c236f00e" translate="yes" xml:space="preserve">
          <source>While you can use arbitrary unique IDs for lexicon keys (like &quot;_min_larger_max_error&quot;), it is often useful for if an entry's key is itself a valid value, like this example error message:</source>
          <target state="translated">&quot;_min_larger_max_error&quot;와 같이 사전 키에 임의의 고유 ID를 사용할 수 있지만 다음 예제 오류 메시지와 같이 항목 키 자체가 유효한 값인 경우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="59ac30a04c89545845f0a1e87ea492a8c9c597ff" translate="yes" xml:space="preserve">
          <source>While you're doing that, make really sure you haven't missed a module similar to the one you're about to write.</source>
          <target state="translated">그렇게하는 동안 작성하려는 모듈과 비슷한 모듈을 놓치지 않았는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="c6568ae799534002dc040ff86ba3511a9bd4bd58" translate="yes" xml:space="preserve">
          <source>Whilst control is in the library, an error condition occurs. You have previously set up a Perl callback to handle this situation, so it will get executed. Once the callback has finished, control will drop back to Perl again. Here is what the flow of control will be like in that situation</source>
          <target state="translated">제어가 라이브러리에있는 동안 오류 조건이 발생합니다. 이 상황을 처리하기 위해 이전에 Perl 콜백을 설정 했으므로 실행됩니다. 콜백이 완료되면 컨트롤은 다시 Perl로 돌아갑니다. 그 상황에서 제어 흐름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="47b13cdb0607925057b8e9d36b0386d1a11eb54c" translate="yes" xml:space="preserve">
          <source>Whitespace</source>
          <target state="translated">Whitespace</target>
        </trans-unit>
        <trans-unit id="e3b1deb6ad1643a6518bffe011e47a1bbf2cd01d" translate="yes" xml:space="preserve">
          <source>Whitespace does not delimit fileglobs.</source>
          <target state="translated">공백은 파일 글로브를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="df7fa704cbceacef574fb86983159dfe4b06ae43" translate="yes" xml:space="preserve">
          <source>Whitespace in filenames is tolerated on most systems, but not all, and even on systems where it might be tolerated, some utilities might become confused by such whitespace.</source>
          <target state="translated">파일 이름의 공백은 대부분의 시스템에서 허용되지만 전부는 아니며 허용 될 수있는 시스템에서도 일부 유틸리티는 이러한 공백으로 인해 혼동 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="baf39f9fbe05bd8902b826d4b1716bd33c1e5022" translate="yes" xml:space="preserve">
          <source>Whitespace is ignored.</source>
          <target state="translated">공백은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="09822d18c062da75d056f267dd113eb02444df2b" translate="yes" xml:space="preserve">
          <source>Whitespace is irrelevant:</source>
          <target state="translated">공백은 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e6027b651e819925aa47dc4c27f8a2f557b14aae" translate="yes" xml:space="preserve">
          <source>Who Needs Complicated Data Structures?</source>
          <target state="translated">복잡한 데이터 구조가 필요한 사람</target>
        </trans-unit>
        <trans-unit id="ce404d98012c2a69e116523288638e2bddf0b8c2" translate="yes" xml:space="preserve">
          <source>Who supports Perl? Who develops it? Why is it free?</source>
          <target state="translated">누가 펄을 지원합니까? 누가 개발합니까? 왜 무료입니까?</target>
        </trans-unit>
        <trans-unit id="6272068bf74683d289db3b55d0ea826c2bd453e3" translate="yes" xml:space="preserve">
          <source>Who wrote it (use AUTHORS for multiple people). It's a good idea to include your current e-mail address (or some e-mail address to which bug reports should be sent) or some other contact information so that users have a way of contacting you. Remember that program documentation tends to roam the wild for far longer than you expect and pick a contact method that's likely to last.</source>
          <target state="translated">누가 작성 했습니까 (여러 사람에게 AUTHORS 사용). 사용자가 연락 할 수 있도록 현재 전자 메일 주소 (또는 버그 보고서를 보내야하는 전자 메일 주소) 나 다른 연락처 정보를 포함하는 것이 좋습니다. 프로그램 설명서는 예상보다 훨씬 오랫동안 야생을 로밍하고 지속될 수있는 연락 방법을 선택하는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b22ef207f555182408b6d1958c0f8d72d42ebbcf" translate="yes" xml:space="preserve">
          <source>Whoops! You just put a tab and a formfeed into that filename! Remember that within double quoted strings (&quot;like\this&quot;), the backslash is an escape character. The full list of these is in &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;Quote and Quote-like Operators in perlop&lt;/a&gt;. Unsurprisingly, you don't have a file called &quot;c:(tab)emp(formfeed)oo&quot; or &quot;c:(tab)emp(formfeed)oo.exe&quot; on your legacy DOS filesystem.</source>
          <target state="translated">으악! 그 파일 이름에 탭과 폼 피드를 넣으면됩니다! 큰 따옴표로 묶인 문자열 ( &quot;like \ this&quot;) 내에서 백 슬래시는 이스케이프 문자입니다. 이들의 전체 목록은 &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;perlop의 Quote 및 Quote-like Operators에&lt;/a&gt; 있습니다. 당연히, 레거시 DOS 파일 시스템에 &quot;c : (tab) emp (formfeed) oo&quot;또는 &quot;c : (tab) emp (formfeed) oo.exe&quot;라는 파일이 없습니다.</target>
        </trans-unit>
        <trans-unit id="8c0f41e4219d3445a18de71b89eb22ea90d39e82" translate="yes" xml:space="preserve">
          <source>Whoops. You should instead use this, which will fail if the file doesn't exist:</source>
          <target state="translated">으악. 대신이 파일을 사용하면 파일이 존재하지 않으면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="9560992747d1a6605928cb6a17f56014fb292bd8" translate="yes" xml:space="preserve">
          <source>Why am I getting long decimals (eg, 19.9499999999999) instead of the numbers I should be getting (eg, 19.95)?</source>
          <target state="translated">내가 가져와야하는 숫자 대신 십진수 (예 : 19.9499999999999)를 얻는 이유는 무엇입니까 (예 : 19.95)?</target>
        </trans-unit>
        <trans-unit id="dc84c992e3edcd39e94928310a7c42a03b0e34c8" translate="yes" xml:space="preserve">
          <source>Why aren't my random numbers random?</source>
          <target state="translated">왜 난수가 무작위가 아닌가?</target>
        </trans-unit>
        <trans-unit id="55451ebd45b1e100db71c6105ddc04433d37cb2f" translate="yes" xml:space="preserve">
          <source>Why can't I get the output of a command with system()?</source>
          <target state="translated">system ()으로 명령의 출력을 얻을 수없는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="6283f33f8240aceff8b5bf7c89ea62586d7996ea" translate="yes" xml:space="preserve">
          <source>Why can't I just open(FH, &quot;&amp;gt;file.lock&quot;)?</source>
          <target state="translated">왜 그냥 열 수 없습니까 (FH, &quot;&amp;gt; file.lock&quot;)?</target>
        </trans-unit>
        <trans-unit id="45f36238b104ed9ce41136ab2cd5676c9546b754" translate="yes" xml:space="preserve">
          <source>Why can't I use &quot;C:\temp\foo&quot; in DOS paths? Why doesn't `C:\temp\foo.exe` work?</source>
          <target state="translated">DOS 경로에서 &quot;C : \ temp \ foo&quot;를 사용할 수없는 이유는 무엇입니까? 왜 C : \ temp \ foo.exe가 작동하지 않습니까?</target>
        </trans-unit>
        <trans-unit id="7cf9bf3687394740ded1b7a3b49b00f8b7f479e0" translate="yes" xml:space="preserve">
          <source>Why can't a method included in this same file be found?</source>
          <target state="translated">동일한 파일에 포함 된 방법을 찾을 수없는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="c1b368f947117e2802b241b52fd0f345164c6250" translate="yes" xml:space="preserve">
          <source>Why can't my script read from STDIN after I gave it EOF (^D on Unix, ^Z on MS-DOS)?</source>
          <target state="translated">STDIN에 EOF (유닉스에서는 ^ D, MS-DOS에서는 ^ Z)를 지정한 후에 왜 스크립트를 STDIN에서 읽을 수 없습니까?</target>
        </trans-unit>
        <trans-unit id="4a35a43f2543633bf09ecfd8ed381f93a2e351c4" translate="yes" xml:space="preserve">
          <source>Why chimera build?</source>
          <target state="translated">왜 키메라가 만들어 집니까?</target>
        </trans-unit>
        <trans-unit id="4ad29870738240c44cf5d008e9ef6e5a830b4811" translate="yes" xml:space="preserve">
          <source>Why did MakeMaker reinvent the build configuration wheel? Why not just use autoconf or automake or ppm or Ant or ...</source>
          <target state="translated">MakeMaker가 빌드 구성 휠을 다시 발명 한 이유는 무엇입니까? 왜 autoconf 또는 automake 또는 ppm 또는 Ant 또는 ...를 사용하지 않습니까?</target>
        </trans-unit>
        <trans-unit id="9c94cf8ad35b8d40bcd1d8a24897df534e24a65c" translate="yes" xml:space="preserve">
          <source>Why do I get asked the same questions every time I start the shell?</source>
          <target state="translated">쉘을 시작할 때마다 왜 같은 질문을 받습니까?</target>
        </trans-unit>
        <trans-unit id="88d20a17cd64b1f5b322facdeee78dd428855e4f" translate="yes" xml:space="preserve">
          <source>Why do I get weird spaces when I print an array of lines?</source>
          <target state="translated">배열을 인쇄 할 때 왜 이상한 공백이 생기나요?</target>
        </trans-unit>
        <trans-unit id="22c242ee2f7e6a5499b05c8e9ef2302a328d950b" translate="yes" xml:space="preserve">
          <source>Why do I sometimes get an &quot;Argument list too long&quot; when I use &amp;lt;*&amp;gt;?</source>
          <target state="translated">&amp;lt;*&amp;gt;를 사용할 때 왜 때때로 &quot;인수 목록이 너무 깁니다&quot;가 표시됩니까?</target>
        </trans-unit>
        <trans-unit id="b24284283ebf1fc2287cf9d0bdc0093551feae63" translate="yes" xml:space="preserve">
          <source>Why do I sometimes get an &quot;Argument list too long&quot; when I use ?</source>
          <target state="translated">사용할 때 왜 &quot;인수 목록이 너무 깁니다&quot;가 표시됩니까?</target>
        </trans-unit>
        <trans-unit id="63e6abc6f1a440467925da9b75e53aa88bf445d6" translate="yes" xml:space="preserve">
          <source>Why do Perl operators have different precedence than C operators?</source>
          <target state="translated">Perl 연산자가 C 연산자와 우선 순위가 다른 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="ef2253bfbc8ad66388d03d0bb9e87b886d907b29" translate="yes" xml:space="preserve">
          <source>Why do regex character classes sometimes match only in the ASCII range?</source>
          <target state="translated">정규식 문자 클래스가 ASCII 범위에서만 일치하는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="fe1dc5c347574cf3a08e8eebfbeb7750b39e6b8c" translate="yes" xml:space="preserve">
          <source>Why do setuid perl scripts complain about kernel problems?</source>
          <target state="translated">setuid perl 스크립트가 커널 문제에 대해 불평하는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="026df39820ea4af121bee1f807b65636d02b2c10" translate="yes" xml:space="preserve">
          <source>Why do some characters not uppercase or lowercase correctly?</source>
          <target state="translated">일부 문자가 대문자 나 소문자가 아닌 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="c99d6ee81fb9e8a95f7bcc8c77d79b83dd80d118" translate="yes" xml:space="preserve">
          <source>Why do you want to do that? :-)</source>
          <target state="translated">왜 그렇게 하시겠습니까? :-)</target>
        </trans-unit>
        <trans-unit id="bd94a8382da48e70b41ef67567b746b186c9a0e6" translate="yes" xml:space="preserve">
          <source>Why does Perl let me delete read-only files? Why does -i clobber protected files? Isn't this a bug in Perl?</source>
          <target state="translated">Perl에서 왜 읽기 전용 파일을 삭제할 수 있습니까? -i clobber로 파일을 보호하는 이유는 무엇입니까? 이것은 Perl의 버그가 아닌가?</target>
        </trans-unit>
        <trans-unit id="cc878c7b17c2f51ef8a429a9375cb383410dd74c" translate="yes" xml:space="preserve">
          <source>Why does Perl let me delete read-only files? Why does &lt;code&gt;-i&lt;/code&gt; clobber protected files? Isn't this a bug in Perl?</source>
          <target state="translated">Perl에서 왜 읽기 전용 파일을 삭제할 수 있습니까? &lt;code&gt;-i&lt;/code&gt; clobber로 파일을 보호하는 이유는 무엇 입니까? 이것은 Perl의 버그가 아닌가?</target>
        </trans-unit>
        <trans-unit id="cab7997afd3e855e0bc949d3ba08b5a07d77bad2" translate="yes" xml:space="preserve">
          <source>Why does defined() return true on empty arrays and hashes?</source>
          <target state="translated">빈 배열과 해시에서 defined ()가 true를 반환하는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="a9078f034de31f1b296232dfb6a8a4e24d9d3fe0" translate="yes" xml:space="preserve">
          <source>Why does passing a subroutine an undefined element in a hash create it?</source>
          <target state="translated">해시에서 서브 루틴에 정의되지 않은 요소를 전달하면 왜 생성됩니까?</target>
        </trans-unit>
        <trans-unit id="7586fa4c0b5fc90f209bbbf4172abb17863eb05e" translate="yes" xml:space="preserve">
          <source>Why does using $&amp;amp;, $`, or $' slow my program down?</source>
          <target state="translated">$ &amp;amp;, $`또는 $ '를 사용하면 왜 프로그램 속도가 느려 집니까?</target>
        </trans-unit>
        <trans-unit id="d0d6812625a87b8571932c2c534a16df1d30c46a" translate="yes" xml:space="preserve">
          <source>Why doesn't &quot;my($foo) = &amp;lt;$fh&amp;gt;;&quot; work right?</source>
          <target state="translated">&quot;my ($ foo) = &amp;lt;$ fh&amp;gt;;&quot;가 아닌 이유 제대로 작동합니까?</target>
        </trans-unit>
        <trans-unit id="dce612b6a2414fd18ba042c0e4b6d8009b148ed5" translate="yes" xml:space="preserve">
          <source>Why doesn't &quot;my($foo) = ;&quot; work right?</source>
          <target state="translated">&quot;my ($ foo) =;&quot;가 아닌 이유 제대로 작동합니까?</target>
        </trans-unit>
        <trans-unit id="5027566591e947a691e8c94cf6484817ceca1f52" translate="yes" xml:space="preserve">
          <source>Why doesn't &amp;amp; work the way I want it to?</source>
          <target state="translated">원하는 방식으로 왜 작동하지 않습니까?</target>
        </trans-unit>
        <trans-unit id="4cf8f75bbab1ae3d6a9b3cc517f4738f093df66a" translate="yes" xml:space="preserve">
          <source>Why doesn't glob(&quot;*.*&quot;) get all the files?</source>
          <target state="translated">glob ( &quot;*. *&quot;)가 모든 파일을 가져 오지 않는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="2deaa0032d55ad3bbe4d463b92dc4d6876271de7" translate="yes" xml:space="preserve">
          <source>Why doesn't my sockets program work under System V (Solaris)? What does the error message &quot;Protocol not supported&quot; mean?</source>
          <target state="translated">왜 소켓 프로그램이 System V (Solaris)에서 작동하지 않습니까? &quot;프로토콜이 지원되지 않습니다&quot;라는 오류 메시지는 무엇을 의미합니까?</target>
        </trans-unit>
        <trans-unit id="94b7e3ba62840111acddb7ecbcec36ba2e7bc4b2" translate="yes" xml:space="preserve">
          <source>Why doesn't open() return an error when a pipe open fails?</source>
          <target state="translated">파이프 열림에 실패했을 때 왜 open ()이 오류를 반환하지 않습니까?</target>
        </trans-unit>
        <trans-unit id="39d80c781157cb75a05623de25db34f558131470" translate="yes" xml:space="preserve">
          <source>Why don't Perl one-liners work on my DOS/Mac/VMS system?</source>
          <target state="translated">Perl one-liner가 DOS / Mac / VMS 시스템에서 작동하지 않는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="7efb6bacfd459d208d2e83d3ccd6f5a6e06b31a2" translate="yes" xml:space="preserve">
          <source>Why don't my &amp;lt;</source>
          <target state="translated">왜 내 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="d55b9cceedd9f6975831dcd97371f91faa17e9ba" translate="yes" xml:space="preserve">
          <source>Why don't my &amp;lt;&amp;lt;HERE documents work?</source>
          <target state="translated">&amp;lt;&amp;lt; HERE 문서가 작동하지 않는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="1b729d456f5e2de755ce9ca47664753dfbd6fc06" translate="yes" xml:space="preserve">
          <source>Why don't my tied hashes make the defined/exists distinction?</source>
          <target state="translated">묶인 해시가 정의 / 존재를 구별하지 않는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="ec879bc347cf004a28479d385b991508d06231e9" translate="yes" xml:space="preserve">
          <source>Why don't word-boundary searches with &lt;code&gt;\b&lt;/code&gt; work for me?</source>
          <target state="translated">&lt;code&gt;\b&lt;/code&gt; 단어 경계 검색이 작동 하지 않는 이유는 무엇 입니까?</target>
        </trans-unit>
        <trans-unit id="123e5244abcc6475513e58c7be3baf1e624a09b7" translate="yes" xml:space="preserve">
          <source>Why don't word-boundary searches with \b work for me?</source>
          <target state="translated">\ b로 단어 경계 검색이 작동하지 않는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="aa0f337d4d9c4331ea81d21ad3497b56fec40614" translate="yes" xml:space="preserve">
          <source>Why dynamic linking?</source>
          <target state="translated">동적 연결이 필요한 이유</target>
        </trans-unit>
        <trans-unit id="4dfd253727c4f99a421a3b97c6c33e70ca139825" translate="yes" xml:space="preserve">
          <source>Why is int() broken?</source>
          <target state="translated">왜 int ()가 깨졌습니까?</target>
        </trans-unit>
        <trans-unit id="a9539bbca1f0e44580627232613c4e6433a9dda3" translate="yes" xml:space="preserve">
          <source>Why is there Perl source in my database?</source>
          <target state="translated">데이터베이스에 Perl 소스가있는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="5376410df92e4e194b5ef26e3120b8356d39f687" translate="yes" xml:space="preserve">
          <source>Why isn't my octal data interpreted correctly?</source>
          <target state="translated">8 진 데이터가 왜 올바르게 해석되지 않습니까?</target>
        </trans-unit>
        <trans-unit id="8adf1b58b38027864f2d28cd98aeb834dee11ea7" translate="yes" xml:space="preserve">
          <source>Why strange names?</source>
          <target state="translated">왜 이상한 이름?</target>
        </trans-unit>
        <trans-unit id="d2f963c70a1ed1fc561f572fe023203fb76a83ae" translate="yes" xml:space="preserve">
          <source>Why the heck Encode API is different?</source>
          <target state="translated">도대체 Encode API가 다른 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="2d967f841c57d824cac2c9266688fd2aa1c5db9c" translate="yes" xml:space="preserve">
          <source>Why use ppport.h?</source>
          <target state="translated">왜 ppport.h를 사용합니까?</target>
        </trans-unit>
        <trans-unit id="df4212a2d988730cb90863e6978ac9cd91d10bdc" translate="yes" xml:space="preserve">
          <source>Why would you want a hash of lists? Let's take a simple example: You have a file of city and country names, like this:</source>
          <target state="translated">왜 목록 해시를 원하십니까? 간단한 예를 들어 보자. 다음과 같이 도시 및 국가 이름 파일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f3771c096b7c324730a1a8a01295eb54a206ffa" translate="yes" xml:space="preserve">
          <source>Why, you may ask, would you need a chunk of memory containing some values in binary representation? One good reason is input and output accessing some file, a device, or a network connection, whereby this binary representation is either forced on you or will give you some benefit in processing. Another cause is passing data to some system call that is not available as a Perl function: &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; requires you to provide parameters stored in the way it happens in a C program. Even text processing (as shown in the next section) may be simplified with judicious usage of these two functions.</source>
          <target state="translated">왜 이진 표현으로 일부 값을 포함하는 메모리 청크가 필요합니까? 한 가지 이유는 입력 및 출력이 일부 파일, 장치 또는 네트워크 연결에 액세스하는 것입니다.이 이진 표현은 사용자에게 강요되거나 처리에 도움이됩니다. 또 다른 원인은 Perl 함수로는 사용할 수없는 일부 시스템 호출에 데이터를 전달하는 것입니다. &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 을 사용 하려면 C 프로그램에서 발생하는 방식으로 저장된 매개 변수를 제공해야합니다. 이 두 기능을 신중하게 사용하면 텍스트 처리 (다음 섹션에 표시)도 단순화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1b95af46a7dc5483f3c0502e26f80b536b33809" translate="yes" xml:space="preserve">
          <source>Why? Because &lt;code&gt;can&lt;/code&gt; returns a coderef to mean &quot;yes it can (and the method is this...)&quot;, and then &lt;code&gt;ok&lt;/code&gt; sees a coderef and thinks you're passing a function that you want it to call and consider the truth of the result of! I.e., just like:</source>
          <target state="translated">왜? coderef를 반환 &lt;code&gt;can&lt;/code&gt; 있기 때문에 &quot;그렇습니다 (그리고 메소드는 ...)&quot;입니다. 그러면 &lt;code&gt;ok&lt;/code&gt; 는 coderef를보고 호출하려는 함수를 전달하고 결과의 진실을 고려한다고 생각합니다. 의! 즉, 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c682a5bde8a3f0f1d13f9a9af66f849014ab6208" translate="yes" xml:space="preserve">
          <source>Why? Because &lt;code&gt;nasty_break()&lt;/code&gt; modifies &lt;code&gt;$\&lt;/code&gt; without localizing it first. The value you set in &lt;code&gt;nasty_break()&lt;/code&gt; is still there when you return. The fix is to add &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; so the value doesn't leak out of &lt;code&gt;nasty_break()&lt;/code&gt; :</source>
          <target state="translated">왜? &lt;code&gt;nasty_break()&lt;/code&gt; 는 먼저 지역화하지 않고 &lt;code&gt;$\&lt;/code&gt; 를 수정 하기 때문 입니다. &lt;code&gt;nasty_break()&lt;/code&gt; 에서 설정 한 값 은 반환 할 때 여전히 존재합니다. 수정은 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; 을 추가 하여 값이 &lt;code&gt;nasty_break()&lt;/code&gt; 누출되지 않도록하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="59af40d4a351e635fdbe369d7b681d20a590a23a" translate="yes" xml:space="preserve">
          <source>Wildcard expansion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70477b387f14e0143de5873f3a9e791508ea1046" translate="yes" xml:space="preserve">
          <source>Will My Old Scripts Break?</source>
          <target state="translated">내 오래된 스크립트가 깨지나요?</target>
        </trans-unit>
        <trans-unit id="2758b8d4c9377404295cf137b65b7a19678f3231" translate="yes" xml:space="preserve">
          <source>Will add a file to the in-memory archive, with name &lt;code&gt;$filename&lt;/code&gt; and content &lt;code&gt;$data&lt;/code&gt; . Specific properties can be set using &lt;code&gt;$opthashref&lt;/code&gt; . The following list of properties is supported: name, size, mtime (last modified date), mode, uid, gid, linkname, uname, gname, devmajor, devminor, prefix, type. (On MacOS, the file's path and modification times are converted to Unix equivalents.)</source>
          <target state="translated">이름이 &lt;code&gt;$filename&lt;/code&gt; 이고 content &lt;code&gt;$data&lt;/code&gt; 파일을 메모리 내 아카이브에 추가합니다 . &lt;code&gt;$opthashref&lt;/code&gt; 사용하여 특정 속성을 설정할 수 있습니다 . 이름, 크기, mtime (마지막 수정 날짜), mode, uid, gid, linkname, uname, gname, devmajor, devminor, prefix, type 등의 속성 목록이 지원됩니다. (MacOS에서는 파일 경로 및 수정 시간이 Unix로 변환됩니다.)</target>
        </trans-unit>
        <trans-unit id="af66cccfd8aea183b531eebc0a74a7e923052ebf" translate="yes" xml:space="preserve">
          <source>Will be called when &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; happens. (See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;The untie Gotcha&lt;/a&gt; below.)</source>
          <target state="translated">때 호출 될 &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; 발생합니다. (아래 &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;의 Unt Gotcha&lt;/a&gt; 참조)</target>
        </trans-unit>
        <trans-unit id="5c123e132f25bf178be9ea2aca72fafe2969081c" translate="yes" xml:space="preserve">
          <source>Will be loaded on demand and called automatically by BigInt.</source>
          <target state="translated">요청시로드되며 BigInt가 자동으로 호출합니다.</target>
        </trans-unit>
        <trans-unit id="a669aaf9a433f6903c152ca38a90c9c7cb258f3e" translate="yes" xml:space="preserve">
          <source>Will be prepended to each install path.</source>
          <target state="translated">각 설치 경로 앞에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="9f18d29650d7b716edb7780278b512b0a8a59170" translate="yes" xml:space="preserve">
          <source>Will be used to modify the padding applied to string as described above.</source>
          <target state="translated">위에서 설명한 것처럼 문자열에 적용된 패딩을 수정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a659ce6bd28efeb251560042f49a1924dca7c4a4" translate="yes" xml:space="preserve">
          <source>Will both leave the sentence as is. Normally, when accepting literal string input from the user, quotemeta() or &lt;code&gt;\Q&lt;/code&gt; must be used.</source>
          <target state="translated">둘 다 문장을 그대로 둡니다. 일반적으로 사용자로부터 리터럴 문자열 입력을 승인 할 때는 quotemeta () 또는 &lt;code&gt;\Q&lt;/code&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="10fbb1ac2af71320cfd2110a94f422695cba5311" translate="yes" xml:space="preserve">
          <source>Will cause &lt;code&gt;$sentence&lt;/code&gt; to become &lt;code&gt;'The big bad wolf jumped over...'&lt;/code&gt; .</source>
          <target state="translated">원인이됩니다 &lt;code&gt;$sentence&lt;/code&gt; 이 될 &lt;code&gt;'The big bad wolf jumped over...'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66fbedfbffb0f55bc116220f01908ca58f12e965" translate="yes" xml:space="preserve">
          <source>Will croak() if there is an error.</source>
          <target state="translated">오류가 있으면 croak ()합니다.</target>
        </trans-unit>
        <trans-unit id="a89e6d7112dafb5b2ad3a46406c0ced36b7d13b7" translate="yes" xml:space="preserve">
          <source>Will die() if called on r-magic.</source>
          <target state="translated">r-magic에서 호출하면 die ()됩니다.</target>
        </trans-unit>
        <trans-unit id="0768298b9a0627e90df27324883d97a236031b2a" translate="yes" xml:space="preserve">
          <source>Will dump the contents of any references in a human readable format. Handy for things like...</source>
          <target state="translated">참조의 내용을 사람이 읽을 수있는 형식으로 덤프합니다. 다음과 같은 것들에 편리합니다 ...</target>
        </trans-unit>
        <trans-unit id="481a8de568a61f103c3af4da9f82b1f103a46712" translate="yes" xml:space="preserve">
          <source>Will dump the contents of any references in a human readable format. Usually you want to pass this into &lt;code&gt;note&lt;/code&gt; or &lt;code&gt;diag&lt;/code&gt; .</source>
          <target state="translated">참조의 내용을 사람이 읽을 수있는 형식으로 덤프합니다. 보통 이것을 &lt;code&gt;note&lt;/code&gt; 또는 &lt;code&gt;diag&lt;/code&gt; 에 전달하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="75f83221407c4472808dc0bb2139500f5229338d" translate="yes" xml:space="preserve">
          <source>Will force the generation of test code that uses the older &lt;code&gt;Test&lt;/code&gt; module.</source>
          <target state="translated">이전 &lt;code&gt;Test&lt;/code&gt; 모듈 을 사용하는 테스트 코드를 강제로 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="a329a554ce0cef11ca3198cc6cf9ba23c8d4f77f" translate="yes" xml:space="preserve">
          <source>Will incorrectly print</source>
          <target state="translated">잘못 인쇄됩니다</target>
        </trans-unit>
        <trans-unit id="c610d24bbac520a7e0e174e12fe1f23a3ae5f9e4" translate="yes" xml:space="preserve">
          <source>Will make sure that =head1 will become &amp;lt;h3&amp;gt; and =head2 will become &amp;lt;h4&amp;gt; etc...</source>
          <target state="translated">= head1이 &amp;lt;h3&amp;gt;이되고 = head2가 &amp;lt;h4&amp;gt;가되도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="49024b4120de3dd67c62575e0a4eb5f193ed6c22" translate="yes" xml:space="preserve">
          <source>Will not cause &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; to re-read the directory stream. The entries already read before the &lt;code&gt;&lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir()&lt;/a&gt;&lt;/code&gt; call will just be returned again from a cache buffer. (Win32)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; 이 디렉토리 스트림을 다시 읽지 않도록 합니다. &lt;code&gt;&lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir()&lt;/a&gt;&lt;/code&gt; 호출 전에 이미 읽은 항목 은 캐시 버퍼에서 다시 반환됩니다. (Win32)</target>
        </trans-unit>
        <trans-unit id="aff13c5ad9d691f5f29f20db0a92fc55a16499de" translate="yes" xml:space="preserve">
          <source>Will not work on platforms that do not support the C test for sticky bit.</source>
          <target state="translated">고정 비트에 대한 C 테스트를 지원하지 않는 플랫폼에서는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="19ad79cf64559535aa01bc2039517ce48ed1f305" translate="yes" xml:space="preserve">
          <source>Will output 2, not 1. This is particularly important if you intend to compile the definitions with the &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; operator, and later interpolate them in another pattern.</source>
          <target state="translated">1이 아닌 2를 출력합니다. 이것은 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 연산자로 정의를 컴파일 하고 나중에 다른 패턴으로 보간 하려는 경우에 특히 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="10021ccb8e306fb831263dee40b8f7ca24084b5a" translate="yes" xml:space="preserve">
          <source>Will prevent the automatic use of INSTALL.SKIP as the install skip file.</source>
          <target state="translated">설치 건너 뛰기 파일로 INSTALL.SKIP를 자동으로 사용하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="897aeeccb9736732e15f96f20d971e76dcd3a8ff" translate="yes" xml:space="preserve">
          <source>Will print &lt;code&gt;2&lt;/code&gt; , because &lt;code&gt;$string&lt;/code&gt; is upgraded as UTF-8. Without &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding 'utf8';&lt;/code&gt; , it will print &lt;code&gt;4&lt;/code&gt; instead, since &lt;code&gt;$string&lt;/code&gt; is three octets when interpreted as Latin-1.</source>
          <target state="translated">인쇄 할 &lt;code&gt;2&lt;/code&gt; 를 하기 때문에, &lt;code&gt;$string&lt;/code&gt; UTF-8로 업그레이드됩니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding 'utf8';&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하지 않고 ; &lt;code&gt;$string&lt;/code&gt; 은 Latin-1로 해석 될 때 3 옥텟 이기 때문에 대신 &lt;code&gt;4&lt;/code&gt; 를 인쇄 합니다.</target>
        </trans-unit>
        <trans-unit id="f950740e9c08c94cdc9c22017e9c8d9e11964004" translate="yes" xml:space="preserve">
          <source>Will produce something like this:</source>
          <target state="translated">다음과 같은 것을 생성 할 것입니다 :</target>
        </trans-unit>
        <trans-unit id="db8fa98164c98267f0158f423a3da70d388112fe" translate="yes" xml:space="preserve">
          <source>Will use &lt;a href=&quot;http://search.cpan.org/perldoc/TAP::Harness::Archive&quot;&gt;TAP::Harness::Archive&lt;/a&gt; as the harness class, and save the TAP to &lt;code&gt;file.tgz&lt;/code&gt;</source>
          <target state="translated">사용 &lt;a href=&quot;http://search.cpan.org/perldoc/TAP::Harness::Archive&quot;&gt;TAP :: 하네스 : 아카이브&lt;/a&gt; 하네스 클래스로, 그리고에 TAP 저장 &lt;code&gt;file.tgz&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="d2fdadddae42eb18256ba3d6c7445968142a4fd2" translate="yes" xml:space="preserve">
          <source>Win32 CORE function stubs</source>
          <target state="translated">Win32 CORE 함수 스텁</target>
        </trans-unit>
        <trans-unit id="0cab5c56f7d1ce7bc278eb6ee5c4a8575346a7ef" translate="yes" xml:space="preserve">
          <source>Win32 implementation</source>
          <target state="translated">Win32 구현</target>
        </trans-unit>
        <trans-unit id="c331f9a552ce93a52bd3bbd4fbac9c58a662301b" translate="yes" xml:space="preserve">
          <source>Win32 support for Sys::Syslog</source>
          <target state="translated">Sys :: Syslog에 대한 Win32 지원</target>
        </trans-unit>
        <trans-unit id="263a800b140dc4fe3448979f4261e583bcee830e" translate="yes" xml:space="preserve">
          <source>Win32 users should use the real slash. If you really want to use backslashes, consider using Sarathy's File::DosGlob, which comes with the standard Perl distribution.</source>
          <target state="translated">Win32 사용자는 실제 슬래시를 사용해야합니다. 백 슬래시를 실제로 사용하려면 표준 Perl 배포판과 함께 제공되는 Sarathy의 File :: DosGlob 사용을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="a64d38eb25949cf47b772e208780c5548dc84962" translate="yes" xml:space="preserve">
          <source>Win95 and Win98 and WinME are collectively Win9x and Win32</source>
          <target state="translated">Win95 및 Win98 및 WinME는 총체적으로 Win9x 및 Win32입니다.</target>
        </trans-unit>
        <trans-unit id="38d123584917edd3d65a1c41ab99a9088beb8b64" translate="yes" xml:space="preserve">
          <source>Win98 chokes on things like Encode if we set the max length to nmake's max of 2K. So we go for a more conservative value of 1K.</source>
          <target state="translated">Win98을 최대 길이를 nmake의 최대 2K로 설정하면 Encode와 같은 것들에 질식합니다. 보다 보수적 인 1K 가치를 추구합니다.</target>
        </trans-unit>
        <trans-unit id="dcb6e2235a0d088883e2901a983ef0e7377f83c0" translate="yes" xml:space="preserve">
          <source>Win9x can not &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; an open file (although WinNT can).</source>
          <target state="translated">Win9x는 열린 파일의 &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; 수 없습니다 ( ).</target>
        </trans-unit>
        <trans-unit id="1865487f835d74c1a32dc51f7e3fd10d2bb1c87c" translate="yes" xml:space="preserve">
          <source>Win9x does not correctly report &lt;code&gt;EOF&lt;/code&gt; with a non-blocking read on a closed pipe. You will see the following messages:</source>
          <target state="translated">Win9x는 닫힌 파이프에서 비 차단 판독 값으로 &lt;code&gt;EOF&lt;/code&gt; 를 올바르게보고하지 않습니다 . 다음과 같은 메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="468c4f1d38914eeba7915aa856cfac9060a7a5fe" translate="yes" xml:space="preserve">
          <source>Win9x support was added in 5.6 (Benjamin Stuhl).</source>
          <target state="translated">Win9x 지원은 5.6 (Benjamin Stuhl)에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="bf4f5bc6b10d099fc4024cb19c3bd9cf757e522e" translate="yes" xml:space="preserve">
          <source>Windows .NET Server supports the LLP64 data model on the Intel Itanium architecture.</source>
          <target state="translated">Windows .NET 서버는 Intel Itanium 아키텍처에서 LLP64 데이터 모델을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="6578fbd48a0229e823dac38105b1950bd25957b3" translate="yes" xml:space="preserve">
          <source>Windows Event Log, &lt;a href=&quot;http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wes/wes/windows_event_log.asp&quot;&gt;http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wes/wes/windows_event_log.asp&lt;/a&gt;</source>
          <target state="translated">Windows 이벤트 로그, &lt;a href=&quot;http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wes/wes/windows_event_log.asp&quot;&gt;http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wes/wes/windows_event_log.asp&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="32384d85bc892c2cec1cd8f151b8007b98fa13ff" translate="yes" xml:space="preserve">
          <source>Windows is Win32.</source>
          <target state="translated">Windows는 Win32입니다.</target>
        </trans-unit>
        <trans-unit id="15932d7727c0d0850847ee4a3aea588d05fd6a45" translate="yes" xml:space="preserve">
          <source>Windows is Windows telnet, Cygwin SSH is the OpenSSH implementation under Cygwin on Windows NT, and Mac Terminal is the Terminal application in Mac OS X. Where the entry is other than yes or no, that emulator displays the given attribute as something else instead. Note that on an aixterm, clear doesn't reset colors; you have to explicitly set the colors back to what you want. More entries in this table are welcome.</source>
          <target state="translated">Windows는 Windows 텔넷이고 Cygwin SSH는 Windows NT의 Cygwin에서 OpenSSH 구현이고 Mac Terminal은 Mac OS X의 터미널 응용 프로그램입니다. 항목이 예 또는 아니오가 아닌 경우 해당 에뮬레이터는 지정된 속성을 다른 것으로 표시합니다. aixterm에서 clear는 색상을 재설정하지 않습니다. 원하는 색상을 명시 적으로 다시 설정해야합니다. 이 표에서 더 많은 항목을 환영합니다.</target>
        </trans-unit>
        <trans-unit id="3093bbeb765cee856b62debb98821ba39f27fcc6" translate="yes" xml:space="preserve">
          <source>Windows users who are using &lt;code&gt;nmake&lt;/code&gt; should note that due to a bug in &lt;code&gt;nmake&lt;/code&gt; , when specifying &lt;code&gt;TEST_FILES&lt;/code&gt; you must use back-slashes instead of forward-slashes.</source>
          <target state="translated">사용중인 Windows 사용자 &lt;code&gt;nmake&lt;/code&gt; 때문에 버그에주의해야 &lt;code&gt;nmake&lt;/code&gt; 를 지정하는 경우, &lt;code&gt;TEST_FILES&lt;/code&gt; 당신이 백 슬래시 대신 앞으로 슬래시를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="968c4aaba72bd2883444cce7386789debafb547b" translate="yes" xml:space="preserve">
          <source>Windows-specific tests.</source>
          <target state="translated">Windows 별 테스트</target>
        </trans-unit>
        <trans-unit id="564f8c6e76fbd512be2e38dabdfdd61550d0c3cc" translate="yes" xml:space="preserve">
          <source>With</source>
          <target state="translated">With</target>
        </trans-unit>
        <trans-unit id="a51957fd22adb3afd697fb8ab328d3922f130d4b" translate="yes" xml:space="preserve">
          <source>With $k chosen carefully, and likely to be a small number like 1 or 2. In theory the larger the bucket array the less chance of collision.</source>
          <target state="translated">$ k를 신중하게 선택하고 1 또는 2와 같은 작은 숫자 일 수 있습니다. 이론적으로 버킷 배열이 클수록 충돌 가능성이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="6185bdea28758a42fc320398e067ab2654617d96" translate="yes" xml:space="preserve">
          <source>With 5005threads, you could also &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; a sub such that any calls to that sub from another thread would block until the lock was released.</source>
          <target state="translated">5005threads으로, 당신은 또한 수 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; 잠금이 해제 될 때까지 다른 스레드에서 해당 하위에 대한 호출을 차단하는 것이라고 하위는.</target>
        </trans-unit>
        <trans-unit id="c2c741524004c7f8613fe0df95f2304ad27bfaf6" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;/a&lt;/code&gt; , one can write &lt;code&gt;\d&lt;/code&gt; with confidence that it will only match ASCII characters, and should the need arise to match beyond ASCII, you can instead use &lt;code&gt;\p{Digit}&lt;/code&gt; (or &lt;code&gt;\p{Word}&lt;/code&gt; for &lt;code&gt;\w&lt;/code&gt; ). There are similar &lt;code&gt;\p{...}&lt;/code&gt; constructs that can match beyond ASCII both white space (see &lt;a href=&quot;perlrecharclass#Whitespace&quot;&gt;Whitespace in perlrecharclass&lt;/a&gt;), and Posix classes (see &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;POSIX Character Classes in perlrecharclass&lt;/a&gt;). Thus, this modifier doesn't mean you can't use Unicode, it means that to get Unicode matching you must explicitly use a construct (&lt;code&gt;\p{}&lt;/code&gt; , &lt;code&gt;\P{}&lt;/code&gt; ) that signals Unicode.</source>
          <target state="translated">으로 &lt;code&gt;/a&lt;/code&gt; , 하나는 쓸 수 &lt;code&gt;\d&lt;/code&gt; 대신 사용할 수 있습니다, 그것은 ASCII 문자 만 일치 것이라는 확신으로, 그리고 ASCII 이상 일치하도록 발생할 필요합니다 &lt;code&gt;\p{Digit}&lt;/code&gt; (또는 &lt;code&gt;\p{Word}&lt;/code&gt; 에 대한 &lt;code&gt;\w&lt;/code&gt; ). ASCII 이외의 &lt;a href=&quot;perlrecharclass#Whitespace&quot;&gt;공백 (perlrecharclass의 공백&lt;/a&gt; 참조 ) 및 Posix 클래스 ( &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;perlrecharclass의 POSIX 문자 클래스&lt;/a&gt; 참조)를 모두 만족할 수 있는 유사한 &lt;code&gt;\p{...}&lt;/code&gt; 구문이 있습니다 . 따라서이 수정자는 유니 코드를 사용할 수 없다는 것을 의미하지는 않습니다. 즉, 유니 코드 일치를 가져 오려면 유니 코드를 나타내는 구성 ( &lt;code&gt;\p{}&lt;/code&gt; , &lt;code&gt;\P{}&lt;/code&gt; )을 명시 적으로 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5132b5fe6c695f29613169cf8ff9a2c949197d0f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, you get around this by using a block and an expression where you would place the filehandle:</source>
          <target state="translated">함께 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; , 당신은 블록 및 파일 핸들을 배치 할 표현식을 사용하여이 문제를 해결 얻을 :</target>
        </trans-unit>
        <trans-unit id="487baf6c93470e20c12688608403c20fbdb8e8f3" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt;, both STDOUT and STDERR will go the same place as the script's STDOUT and STDERR, unless the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; command redirects them. Backticks and &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; read &lt;b&gt;only&lt;/b&gt; the STDOUT of your command.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 사용하면 system ( &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 명령이 리디렉션 하지 않는 한 STDOUT 및 STDERR이 스크립트의 STDOUT 및 STDERR과 같은 위치로 이동합니다. 백틱 및 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 은 명령의 STDOUT &lt;b&gt;만&lt;/b&gt; 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="e6ba4c518cc989a85f1859e34fe5315e0670671f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;Class::Tiny&lt;/code&gt; , all accessors are read-write. It generates a constructor for you, as well as the accessors you define.</source>
          <target state="translated">함께 &lt;code&gt;Class::Tiny&lt;/code&gt; 모든 접근은 읽기 - 쓰기를하고 있습니다. 정의한 접근 자뿐만 아니라 생성자를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="c6b55e3069c1cf271c20c8804a7b8c0dbfbb1f17" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;ignore_case&lt;/code&gt; , option specifications for options that only differ in case, e.g., &lt;code&gt;&quot;foo&quot;&lt;/code&gt; and &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; , will be flagged as duplicates.</source>
          <target state="translated">&lt;code&gt;ignore_case&lt;/code&gt; 를 사용하면 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; 와 같이 경우에만 다른 옵션의 옵션 스펙이 중복으로 플래그됩니다.</target>
        </trans-unit>
        <trans-unit id="ee71de233ae712db3a62ad0a5f3c845bcb07690d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;pass_through&lt;/code&gt; anything that is unknown, ambiguous or supplied with an invalid option will not be flagged as an error. Instead the unknown option(s) will be passed to the catchall &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; if present, otherwise through to &lt;code&gt;@ARGV&lt;/code&gt; . This makes it possible to write wrapper scripts that process only part of the user supplied command line arguments, and pass the remaining options to some other program.</source>
          <target state="translated">&lt;code&gt;pass_through&lt;/code&gt; 를 통해 알 수 없거나 모호하거나 잘못된 옵션이 제공되는 것은 오류로 표시되지 않습니다. 대신 알 수없는 옵션은 존재하는 경우 catchall &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 로 전달되고 그렇지 않으면 &lt;code&gt;@ARGV&lt;/code&gt; 로 전달 됩니다. 이를 통해 사용자 제공 명령 행 인수의 일부만 처리하고 나머지 옵션을 다른 프로그램에 전달하는 랩퍼 스크립트를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb95ac886e1d528b24773e6c70b3ed1c1613335e" translate="yes" xml:space="preserve">
          <source>With EXPR, it returns some extra information that the debugger uses to print a stack trace. The value of EXPR indicates how many call frames to go back before the current one.</source>
          <target state="translated">EXPR을 사용하면 디버거가 스택 추적을 인쇄하는 데 사용하는 추가 정보를 반환합니다. EXPR의 값은 현재 호출 이전으로 되돌아 갈 콜 프레임 수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a55096d08b5ad2fe54fd898185c93fb2c1c7dfdd" translate="yes" xml:space="preserve">
          <source>With Mac OS X 10.4 &quot;Tiger&quot; and newer, there is almost no performance penalty for non-prebound libraries. Earlier releases will suffer a greater load time than either the static library, or Apple's pre-bound dynamic library.</source>
          <target state="translated">Mac OS X 10.4 &quot;Tiger&quot;이상을 사용하면 비 사전 라이브러리에 대한 성능 저하가 거의 없습니다. 이전 릴리스는 정적 라이브러리 나 Apple의 사전 바인딩 된 동적 라이브러리보다로드 시간이 더 오래 걸립니다.</target>
        </trans-unit>
        <trans-unit id="5f9d3d0136d8a2d2276cb1a4c4f0bb0c82be3696" translate="yes" xml:space="preserve">
          <source>With NTFS (and no CYGWIN=nontsec), there should be no problems even if perl was built on FAT.</source>
          <target state="translated">NTFS를 사용하면 (CYGWIN = nontsec이 아님), perl이 FAT에 구축 된 경우에도 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="783aaaca75cc72bad41475003df821affc75b7c5" translate="yes" xml:space="preserve">
          <source>With OO style, you can break the message arbitrarily. This means that we are no longer limited to have space for the whole message in memory, i.e. we can handle messages of any size.</source>
          <target state="translated">OO 스타일을 사용하면 메시지를 임의로 중단 할 수 있습니다. 이것은 우리가 더 이상 전체 메시지를위한 공간을 메모리에 저장하는 것으로 제한되지 않는다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c1bf2f77022cd9fed463a5704b297d6ff88b00d5" translate="yes" xml:space="preserve">
          <source>With Perl 5.004 you can also use the TIEHANDLE interface to access compressed files just like ordinary files:</source>
          <target state="translated">Perl 5.004를 사용하면 TIEHANDLE 인터페이스를 사용하여 일반 파일처럼 압축 파일에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f110b40627d54799c1a5b4c023b449d3f05b59d" translate="yes" xml:space="preserve">
          <source>With Perl 5.10 and later, the smart match operator can give you the answer with the least amount of work:</source>
          <target state="translated">Perl 5.10 이상에서 스마트 매치 연산자는 최소한의 작업으로 답변을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e55c608e124b42bf25bf02c154381796e1d9852" translate="yes" xml:space="preserve">
          <source>With a</source>
          <target state="translated">와</target>
        </trans-unit>
        <trans-unit id="f458d9e5c6b401d23a0ff93a93cac73ffa40d782" translate="yes" xml:space="preserve">
          <source>With a &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt;, &lt;code&gt;charscript()&lt;/code&gt; returns the</source>
          <target state="translated">A의 &lt;a href=&quot;#code-point-argument&quot;&gt;코드 포인트 인수&lt;/a&gt; , &lt;code&gt;charscript()&lt;/code&gt; 반환</target>
        </trans-unit>
        <trans-unit id="7cfd816e3af239ee8e3392fa5dd4b28e10c2cbf9" translate="yes" xml:space="preserve">
          <source>With a &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt;&lt;code&gt;charblock()&lt;/code&gt; returns the</source>
          <target state="translated">A의 &lt;a href=&quot;#code-point-argument&quot;&gt;코드 포인트 인수 &lt;/a&gt; &lt;code&gt;charblock()&lt;/code&gt; 반환</target>
        </trans-unit>
        <trans-unit id="cc06a9c18caf674053e4b44b132356a1c540f757" translate="yes" xml:space="preserve">
          <source>With a little extra work, you can get all of the groups in angle brackets even if they are in other angle brackets too. Each time you get a balanced match, remove its outer delimiter (that's the one you just matched so don't match it again) and add it to a queue of strings to process. Keep doing that until you get no matches:</source>
          <target state="translated">약간의 추가 작업으로 모든 그룹이 다른 꺾쇠 괄호 안에 있어도 꺾쇠 괄호로 묶을 수 있습니다. 균형 일치를 얻을 때마다 외부 구분 기호 (방금 일치 한 문자이므로 다시 일치하지 않음)를 제거하고 처리 할 문자열 대기열에 추가하십시오. 일치하지 않을 때까지 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="a69059588956460f70f3f90c71a968d5af85c118" translate="yes" xml:space="preserve">
          <source>With a non-&lt;code&gt;DEBUGGING&lt;/code&gt; perl, the buckets starting from &lt;code&gt;128&lt;/code&gt; have a 4-byte overhead, and thus an 8192-long bucket may take up to 8188-byte allocations.</source>
          <target state="translated">&lt;code&gt;DEBUGGING&lt;/code&gt; perl 이 아닌 경우 &lt;code&gt;128&lt;/code&gt; 에서 시작하는 버킷 은 4 바이트 오버 헤드를 가지므로 8192 길이의 버킷은 최대 8188 바이트 할당이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="3f782793180910fe0c252c5c5e6b40299dd75d89" translate="yes" xml:space="preserve">
          <source>With a slurpy parameter in the signature, there is no upper limit on how many arguments may be passed. A slurpy array parameter may be nameless just like a positional parameter, in which case its only effect is to turn off the argument limit that would otherwise apply:</source>
          <target state="translated">서명에 slurpy 매개 변수를 사용하면 전달할 수있는 인수 수에 대한 상한이 없습니다. slurpy 배열 매개 변수는 위치 매개 변수와 마찬가지로 이름이 없을 수 있습니다.이 경우 유일한 효과는 그렇지 않은 경우 인수 제한을 해제하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f9508f16c80ad6889c699daf40f43720b8251d92" translate="yes" xml:space="preserve">
          <source>With a technique called copy-on-write, the cost of copying with overload could be minimized or even completely avoided. A test implementation of COW did show performance gains for overloaded math, but introduced a performance loss due to a constant overhead for all other operations. So Math::BigInt does currently not COW.</source>
          <target state="translated">COW (Copy-On-Write)라는 기술을 사용하면 과부하로 복사하는 비용을 최소화하거나 완전히 피할 수 있습니다. COW의 테스트 구현은 오버로드 된 수학에 대한 성능 향상을 보여 주었지만 다른 모든 작업에 대한 지속적인 오버 헤드로 인해 성능 손실이 발생했습니다. 따라서 Math :: BigInt는 현재 COW하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ebe6d7c43f224246d4ca3387c92f6cc94b15954" translate="yes" xml:space="preserve">
          <source>With a todo block, the tests inside are expected to fail. Test::More will run the tests normally, but print out special flags indicating they are &quot;todo&quot;. &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; will interpret failures as being ok. Should anything succeed, it will report it as an unexpected success. You then know the thing you had todo is done and can remove the TODO flag.</source>
          <target state="translated">todo 블록을 사용하면 내부 테스트가 실패 할 것으로 예상됩니다. Test :: More는 테스트를 정상적으로 실행하지만 &quot;todo&quot;임을 나타내는 특수 플래그를 인쇄합니다. &lt;a href=&quot;harness&quot;&gt;Test :: Harness&lt;/a&gt; 는 실패를 정상으로 해석합니다. 성공하면 예상치 못한 성공으로보고합니다. 그런 다음해야 할 일이 완료된 것을 알고 TODO 플래그를 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2be7163284f82da14a87936dad63fbf983833559" translate="yes" xml:space="preserve">
          <source>With all of the regexes above, if the regex matched anywhere in the string, it was considered a match. To specify</source>
          <target state="translated">위의 모든 정규 표현식을 사용하여 정규 표현식이 문자열의 모든 위치와 일치하면 일치하는 것으로 간주됩니다. 지정하려면</target>
        </trans-unit>
        <trans-unit id="a49675e374380fe043aff3a5f63d6512021ecfd9" translate="yes" xml:space="preserve">
          <source>With all of the regexps above, if the regexp matched anywhere in the string, it was considered a match. Sometimes, however, we'd like to specify</source>
          <target state="translated">위의 모든 정규 표현식을 사용하여 정규 표현식이 문자열의 모든 위치와 일치하면 일치하는 것으로 간주됩니다. 그러나 때때로 우리는</target>
        </trans-unit>
        <trans-unit id="544d324c6a361c56f15aa84b4f308989bea67735" translate="yes" xml:space="preserve">
          <source>With an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, you should be especially careful to remember what's being looked at when:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 을 사용하면 다음과 같은 경우에 무엇을보고 있는지 기억해야합니다.</target>
        </trans-unit>
        <trans-unit id="250cfbca6e5e22d4d573a90cd37797d2cb8d3ac5" translate="yes" xml:space="preserve">
          <source>With an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, you should be especially careful to remember what's being looked at when:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 을 사용하면 다음과 같은 경우에 무엇을보고 있는지 기억해야합니다.</target>
        </trans-unit>
        <trans-unit id="28933cd0405c565c32304d3c729c7e6f31006ad2" translate="yes" xml:space="preserve">
          <source>With any of these, you can change file descriptors before the call:</source>
          <target state="translated">이 중 하나를 사용하면 호출 전에 파일 디스크립터를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="944f492857a1db6c839174233fd1c02f59c056dd" translate="yes" xml:space="preserve">
          <source>With any version of Perl 5 you can use the basic OO interface:</source>
          <target state="translated">Perl 5의 모든 버전에서 기본 OO 인터페이스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="108bd0cf30895e3a18d32866a5ada0ba72c0b2d2" translate="yes" xml:space="preserve">
          <source>With bundling it is possible to set several single-character options at once. For example if &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; are all valid options,</source>
          <target state="translated">번들로 여러 문자 옵션을 한 번에 설정할 수 있습니다. 예를 들어, &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; 및 &lt;code&gt;x&lt;/code&gt; 가 모두 유효한 옵션 인 경우</target>
        </trans-unit>
        <trans-unit id="bf9c20d6876f103320c9d9424556b25f81d7af24" translate="yes" xml:space="preserve">
          <source>With earlier versions of Perl, you have to do a bit more work. If you are going to make this query many times over arbitrary string values, the fastest way is probably to invert the original array and maintain a hash whose keys are the first array's values:</source>
          <target state="translated">이전 버전의 Perl에서는 조금 더 많은 작업을 수행해야합니다. 이 쿼리를 임의의 문자열 값보다 여러 번 만들려면 가장 빠른 방법은 원래 배열을 반전시키고 키가 첫 번째 배열 값인 해시를 유지하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="089c9811008b67cdbb35efdae3d3f3034c15c2b2" translate="yes" xml:space="preserve">
          <source>With excerpts from Perl, and contributions and suggestions from Ronald J. Kimball, Dave Mitchell, Dominic Dunlop, Mark Jason Dominus, Stephen McCamant, and David Landgren.</source>
          <target state="translated">Perl의 발췌 및 Ronald J. Kimball, Dave Mitchell, Dominic Dunlop, Mark Jason Dominus, Stephen McCamant 및 David Landgren의 공헌 및 제안.</target>
        </trans-unit>
        <trans-unit id="312cf396f9e4b4f5d83643b7fda95efc6c88ff9d" translate="yes" xml:space="preserve">
          <source>With hooks comes the ability to recurse back to the Storable engine. Indeed, hooks are regular Perl code, and Storable is convenient when it comes to serializing and deserializing things, so why not use it to handle the serialization string?</source>
          <target state="translated">후크를 사용하면 Storable 엔진으로 다시 돌아갈 수 있습니다. 실제로 후크는 일반적인 Perl 코드이며 Storable은 직렬화 및 직렬화 해제에 편리합니다. 직렬화 문자열을 처리하는 데 사용하지 않는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="2092bcf7558e6632164a74cbb09d09cc7943a0d7" translate="yes" xml:space="preserve">
          <source>With lots of help and suggestions from Dean Roehrich, Malcolm Beattie, Andreas Koenig, Paul Hudson, Ilya Zakharevich, Paul Marquess, Neil Bowers, Matthew Green, Tim Bunce, Spider Boardman, Ulrich Pfeifer, Stephen McCamant, and Gurusamy Sarathy.</source>
          <target state="translated">Dean Roehrich, Malcolm Beattie, Andreas Koenig, Paul Hudson, Ilya Zakharevich, Paul Marquess, Neil Bowers, Matthew Green, Tim Bunce, Spider Boardman, Ulrich Pfeifer, Stephen McCamant 및 Gurusamy Sarathy의 많은 도움과 제안이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a2d0cebca8f8c753e2f714f5c39699038d3b25f" translate="yes" xml:space="preserve">
          <source>With methods 2 and 3, Perl starts parsing the input file from the beginning, unless you've specified a &lt;b&gt;-x&lt;/b&gt; switch, in which case it scans for the first line starting with &lt;code&gt;#!&lt;/code&gt; and containing the word &quot;perl&quot;, and starts there instead. This is useful for running a program embedded in a larger message. (In this case you would indicate the end of the program using the &lt;code&gt;__END__&lt;/code&gt; token.)</source>
          <target state="translated">방법 2와 3을 사용하면 &lt;b&gt;-x&lt;/b&gt; 스위치를 지정하지 않은 경우 Perl은 처음부터 입력 파일을 구문 분석하기 시작합니다. 이 경우 &lt;code&gt;#!&lt;/code&gt; 으로 시작하는 첫 번째 줄을 검색합니다 . &quot;perl&quot;이라는 단어를 포함하고 대신 시작합니다. 큰 메시지에 포함 된 프로그램을 실행하는 데 유용합니다. (이 경우 &lt;code&gt;__END__&lt;/code&gt; 토큰을 사용하여 프로그램의 끝을 나타냅니다 .)</target>
        </trans-unit>
        <trans-unit id="6316d5824ca52c312f770e770e783e4a6d5033d6" translate="yes" xml:space="preserve">
          <source>With mod_perl and the Apache::Registry module (distributed with mod_perl), httpd will run with an embedded Perl interpreter which pre-compiles your script and then executes it within the same address space without forking. The Apache extension also gives Perl access to the internal server API, so modules written in Perl can do just about anything a module written in C can. For more on mod_perl, see &lt;a href=&quot;http://perl.apache.org/&quot;&gt;http://perl.apache.org/&lt;/a&gt;</source>
          <target state="translated">mod_perl 및 Apache :: Registry 모듈 (mod_perl과 함께 배포)을 사용하면 httpd는 내장 된 Perl 인터프리터와 함께 실행되어 스크립트를 사전 컴파일 한 후 포크없이 동일한 주소 공간 내에서 실행합니다. Apache 확장은 또한 Perl에 내부 서버 API에 대한 액세스를 제공하므로 Perl로 작성된 모듈은 C로 작성된 모듈이 할 수있는 모든 작업을 수행 할 수 있습니다. mod_perl에 대한 자세한 내용은 &lt;a href=&quot;http://perl.apache.org/&quot;&gt;http://perl.apache.org/를&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="cc2eb3f9b78400953fa9a4ff9c87b68e20c7b681" translate="yes" xml:space="preserve">
          <source>With much assistance regarding shared libraries from Marc Sabatella.</source>
          <target state="translated">Marc Sabatella의 공유 라이브러리와 관련하여 많은 도움을 받았습니다.</target>
        </trans-unit>
        <trans-unit id="b462e2e8ccefffa9756bd47bbfa7c723db9b9b54" translate="yes" xml:space="preserve">
          <source>With negative offsets, it remembers its position from the end of the string when the target string is modified:</source>
          <target state="translated">음수 오프셋을 사용하면 대상 문자열이 수정 될 때 문자열 끝에서 위치를 기억합니다.</target>
        </trans-unit>
        <trans-unit id="00344cc849fc9376fff9de99085e79fa3cd552d0" translate="yes" xml:space="preserve">
          <source>With no MASK argument present, it returns the current operator mask of the compartment.</source>
          <target state="translated">MASK 인수가 없으면 구획의 현재 연산자 마스크를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a35650496b577c95afdac0e1ebb0191fd46fd2e0" translate="yes" xml:space="preserve">
          <source>With no argument, the accessor returns a reference to the element's whole array (whether or not the element was specified as &lt;code&gt;'@'&lt;/code&gt; or &lt;code&gt;'*@'&lt;/code&gt; ).</source>
          <target state="translated">인수가 없으면 접근자는 요소의 전체 배열에 대한 참조를 반환합니다 (요소가 &lt;code&gt;'@'&lt;/code&gt; 또는 &lt;code&gt;'*@'&lt;/code&gt; 로 지정되었는지 여부 ).</target>
        </trans-unit>
        <trans-unit id="3a4963e3a2e84181fb9a499ef49896fdab34cd7c" translate="yes" xml:space="preserve">
          <source>With no argument, the accessor returns a reference to the element's whole hash (whether or not the element was specified as &lt;code&gt;'%'&lt;/code&gt; or &lt;code&gt;'*%'&lt;/code&gt; ).</source>
          <target state="translated">인수가 없으면 접근자는 요소의 전체 해시에 대한 참조를 반환합니다 (요소가 &lt;code&gt;'%'&lt;/code&gt; 또는 &lt;code&gt;'*%'&lt;/code&gt; 로 지정되었는지 여부 ).</target>
        </trans-unit>
        <trans-unit id="6bae0e18d43bcb818e56d07261a055232eff0bf8" translate="yes" xml:space="preserve">
          <source>With no arguments (or using &lt;code&gt;threads::all&lt;/code&gt; ) and in a list context, returns a list of all non-joined, non-detached</source>
          <target state="translated">인수가 없거나 ( &lt;code&gt;threads::all&lt;/code&gt; ) 목록 컨텍스트에서 결합되지 않은 분리되지 않은 모든 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d4cfb999178855ab18f46ce9c518e1bd1ef50096" translate="yes" xml:space="preserve">
          <source>With older versions of Perl, the &lt;a href=&quot;http://search.cpan.org/perldoc/IO::String&quot;&gt;IO::String&lt;/a&gt; module provides similar functionality.</source>
          <target state="translated">이전 버전의 Perl에서 &lt;a href=&quot;http://search.cpan.org/perldoc/IO::String&quot;&gt;IO :: String&lt;/a&gt; 모듈은 유사한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c467eeeb4f15846c2e3c26d1b4d74776d4da75d4" translate="yes" xml:space="preserve">
          <source>With one or two arguments, the first argument is a key specifying one element of the hash; the second argument, if present, is assigned to the hash element. If the element type is &lt;code&gt;'%'&lt;/code&gt; , the accessor returns the hash element value. If the element type is &lt;code&gt;'*%'&lt;/code&gt; , a reference to the hash element is returned.</source>
          <target state="translated">하나 또는 두 개의 인수를 사용하면 첫 번째 인수는 해시의 한 요소를 지정하는 키입니다. 존재하는 경우, 두 번째 인수는 해시 요소에 할당됩니다. 요소 유형이 &lt;code&gt;'%'&lt;/code&gt; 인 경우 접근자는 해시 요소 값을 반환합니다. 요소 유형이 &lt;code&gt;'*%'&lt;/code&gt; 이면 해시 요소에 대한 참조가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="043fe821df73a58116e971eada4906da49321cca" translate="yes" xml:space="preserve">
          <source>With one or two arguments, the first argument is an index specifying one element of the array; the second argument, if present, is assigned to the array element. If the element type is &lt;code&gt;'@'&lt;/code&gt; , the accessor returns the array element value. If the element type is &lt;code&gt;'*@'&lt;/code&gt; , a reference to the array element is returned.</source>
          <target state="translated">하나 또는 두 개의 인수를 사용하면 첫 번째 인수는 배열의 한 요소를 지정하는 인덱스입니다. 두 번째 인수 (있는 경우)는 배열 요소에 지정됩니다. 요소 유형이 &lt;code&gt;'@'&lt;/code&gt; 인 경우 접근자는 배열 요소 값을 반환합니다. 요소 유형이 &lt;code&gt;'*@'&lt;/code&gt; 인 경우 배열 요소에 대한 참조가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="d82587a9e3d9d950371c40dd7e06719bffb84440" translate="yes" xml:space="preserve">
          <source>With option -exec, walks tree in execute order, otherwise in basic order.</source>
          <target state="translated">-exec 옵션을 사용하면 트리를 실행 순서대로, 그렇지 않으면 기본 순서로 트리를 이동합니다.</target>
        </trans-unit>
        <trans-unit id="57d705a8d20354296c55ade02ce168e9aba3ea9c" translate="yes" xml:space="preserve">
          <source>With overloaded math, only the first two variants will result in a BigFloat:</source>
          <target state="translated">오버로드 된 수학에서는 처음 두 변형 만 BigFloat가됩니다.</target>
        </trans-unit>
        <trans-unit id="549d9ba8c522ce4226592827b058814ec17aafc9" translate="yes" xml:space="preserve">
          <source>With respect to character matching, there are a few more points you need to know about. First of all, not all characters can be used 'as is' in a match. Some characters, called</source>
          <target state="translated">문자 일치와 관련하여 알아야 할 몇 가지 사항이 더 있습니다. 우선, 모든 문자가 일치하는 '있는 그대로'사용될 수있는 것은 아닙니다. 일부 문자</target>
        </trans-unit>
        <trans-unit id="f52704b066745f4539042b4ca42ac5911b1eae8e" translate="yes" xml:space="preserve">
          <source>With respect to files, one that has the proper permission bit set to let you access the file. With respect to computer programs, one that&amp;rsquo;s written well enough that someone has a chance of figuring out what it&amp;rsquo;s trying to do.</source>
          <target state="translated">파일과 관련하여 파일에 액세스 할 수 있도록 적절한 권한 비트가 설정되어 있습니다. 컴퓨터 프로그램과 관련하여 누군가가하려는 일을 알아낼 수있을 정도로 충분히 잘 작성된 것입니다.</target>
        </trans-unit>
        <trans-unit id="3dc4eefad3d29ef780cb07bfc36df49d416959b4" translate="yes" xml:space="preserve">
          <source>With respect to loading &lt;code&gt;Exporter&lt;/code&gt; and inheriting, there are alternatives with the use of modules like &lt;code&gt;base&lt;/code&gt; and &lt;code&gt;parent&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;Exporter&lt;/code&gt; 로드 및 상속 과 관련하여 &lt;code&gt;base&lt;/code&gt; 및 &lt;code&gt;parent&lt;/code&gt; 와 같은 모듈을 사용하는 대안이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="64aab757411e3efe138dbb9f7787c6359c1eec8b" translate="yes" xml:space="preserve">
          <source>With some firewalls active mode does not work as the server cannot connect to your machine (because you are behind a firewall) and the firewall does not re-write the command. In this case you should set &lt;code&gt;ftp_ext_passive&lt;/code&gt; to a</source>
          <target state="translated">방화벽이있어 서버가 시스템에 연결할 수없고 방화벽이 명령을 다시 쓰지 않기 때문에 일부 방화벽의 경우 활성 모드가 작동하지 않습니다. 이 경우 &lt;code&gt;ftp_ext_passive&lt;/code&gt; 를</target>
        </trans-unit>
        <trans-unit id="39e7b288b06e2af98b83632e08ab80e03b9bf7c3" translate="yes" xml:space="preserve">
          <source>With source filters, you can store the text of your script compressed and use a source filter to uncompress it for Perl's parser:</source>
          <target state="translated">소스 필터를 사용하면 스크립트의 텍스트를 압축하여 저장하고 소스 필터를 사용하여 Perl 파서의 압축을 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3d0833032fe049783c845044de2a75767e40f62" translate="yes" xml:space="preserve">
          <source>With support for &lt;code&gt;LIBPATHSTRICT&lt;/code&gt; this may be circumvented - unless one of DLLs is started from</source>
          <target state="translated">&lt;code&gt;LIBPATHSTRICT&lt;/code&gt; 를 지원하면 DLL 중 하나가 시작되지 않는 한이를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="741296e189dd1627ab6af5dc824e2c81acff153a" translate="yes" xml:space="preserve">
          <source>With that trick MakeMaker will only read the first line and thus read the underscore, while the perl interpreter will evaluate the $VERSION and convert the string into a number. Later operations that treat $VERSION as a number will then be able to do so without provoking a warning about $VERSION not being a number.</source>
          <target state="translated">이 트릭으로 MakeMaker는 첫 번째 행만 읽으므로 밑줄을 읽습니다. 반면 펄 인터프리터는 $ VERSION을 평가하고 문자열을 숫자로 변환합니다. $ VERSION을 숫자로 취급하는 이후의 조작은 $ VERSION이 숫자가 아니라는 경고를 표시하지 않고이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa542340f7199357b9ddb7d211923c323666ef12" translate="yes" xml:space="preserve">
          <source>With the &quot;tcp&quot; protocol the ping() method attempts to establish a connection to the remote host's echo port. If the connection is successfully established, the remote host is considered reachable. No data is actually echoed. This protocol does not require any special privileges but has higher overhead than the &quot;udp&quot; and &quot;icmp&quot; protocols.</source>
          <target state="translated">&quot;tcp&quot;프로토콜을 사용하여 ping () 메소드는 원격 호스트의 에코 포트에 연결을 시도합니다. 연결에 성공하면 원격 호스트에 연결할 수있는 것으로 간주됩니다. 실제로는 데이터가 에코되지 않습니다. 이 프로토콜에는 특별한 권한이 필요하지 않지만 &quot;udp&quot;및 &quot;icmp&quot;프로토콜보다 높은 오버 헤드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c9c2cd66698ade01d6241c0c3475076fe41182f" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma you can use the &lt;code&gt;:locale&lt;/code&gt; layer</source>
          <target state="translated">로 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 프라 그마 당신이 사용할 수있는 &lt;code&gt;:locale&lt;/code&gt; 레이어를</target>
        </trans-unit>
        <trans-unit id="e4721b12184df4c626e83aff44b61b424dee2894" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; operator, the matched variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , etc. are immediately available for use in the replacement expression. With the global modifier, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; will search and replace all occurrences of the regex in the string:</source>
          <target state="translated">으로 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 연산자 유사한 변수 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; 등 교체 식 즉시 사용 가능하다. 전역 수정자를 사용하면 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; 는 문자열에서 모든 정규식을 검색하고 대체합니다.</target>
        </trans-unit>
        <trans-unit id="a5f3ac7301bb1927406401553bc7979a7058d48f" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; pragma you can control the behaviour of the builtin &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; pragma를 사용하면 내장 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; 함수 의 동작을 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="640e6849be58e830210cdb457742bd0e5d46239f" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;IN&lt;/code&gt; subpragma you can declare the default layers of input streams, and with the &lt;code&gt;OUT&lt;/code&gt; subpragma you can declare the default layers of output streams. With the &lt;code&gt;IO&lt;/code&gt; subpragma you can control both input and output streams simultaneously.</source>
          <target state="translated">으로 &lt;code&gt;IN&lt;/code&gt; 의 subpragma 당신은 입력 스트림의 기본 레이어를 선언 할 수 있고, 함께 &lt;code&gt;OUT&lt;/code&gt; 의 subpragma 당신은 출력 스트림의 기본 레이어를 선언 할 수 있습니다. 으로 &lt;code&gt;IO&lt;/code&gt; 의 subpragma 당신은 두 입력을 제어 할 수있는 출력을 동시에 스트리밍합니다.</target>
        </trans-unit>
        <trans-unit id="9a9bb48f29cda9ceed93d7949280d0a2ae7a947b" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; logical name defined as &quot;ENABLE&quot;, setting &lt;code&gt;$?&lt;/code&gt; will cause the new value to be encoded into &lt;code&gt;$^E&lt;/code&gt; so that either the original parent or child exit status values 0 to 255 can be automatically recovered by C programs expecting _POSIX_EXIT behavior. If both a parent and a child exit value are non-zero, then it will be assumed that this is actually a VMS native status value to be passed through. The special value of 0xFFFF is almost a NOOP as it will cause the current native VMS status in the C library to become the current native Perl VMS status, and is handled this way as it is known to not be a valid native VMS status value. It is recommend that only values in the range of normal Unix parent or child status numbers, 0 to 255 are used.</source>
          <target state="translated">으로 &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; 로 정의 논리 이름 설정 &quot;ENABLE&quot; &lt;code&gt;$?&lt;/code&gt; _POSIX_EXIT 동작을 예상하는 C 프로그램이 원래 상위 또는 하위 종료 상태 값 0-255를 자동으로 복구 할 수 있도록 새 값이 &lt;code&gt;$^E&lt;/code&gt; 로 인코딩됩니다 . 상위 및 하위 엑시트 값이 모두 0이 아닌 경우 이는 실제로 전달 될 VMS 기본 상태 값인 것으로 가정합니다. 0xFFFF의 특수 값은 C 라이브러리의 현재 기본 VMS 상태가 현재 기본 Perl VMS 상태가되므로 유효한 기본 VMS 상태 값이 아닌 것으로 알려진 방식으로 처리되므로 거의 NOOP입니다. 일반 Unix 상위 또는 하위 상태 번호 범위 인 0-255 범위의 값만 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d85c0b58283979a05b1d958cf7b8e77666b21187" translate="yes" xml:space="preserve">
          <source>With the C-style operators that would have been written like this:</source>
          <target state="translated">다음과 같이 작성된 C 스타일 연산자를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="12231f536f1fde7f945e73b86c0bb0963f5133af" translate="yes" xml:space="preserve">
          <source>With the FCGI module (from CPAN) and the mod_fastcgi module (available from &lt;a href=&quot;http://www.fastcgi.com/&quot;&gt;http://www.fastcgi.com/&lt;/a&gt; ) each of your Perl programs becomes a permanent CGI daemon process.</source>
          <target state="translated">CPAN의 FCGI 모듈 및 mod_fastcgi 모듈 ( &lt;a href=&quot;http://www.fastcgi.com/&quot;&gt;http://www.fastcgi.com/&lt;/a&gt; 에서 사용 가능 )을 사용하면 각 Perl 프로그램이 영구적 인 CGI 데몬 프로세스가됩니다.</target>
        </trans-unit>
        <trans-unit id="e9f0f761b750ef587b104ca22707f7d417110d25" translate="yes" xml:space="preserve">
          <source>With the MASK argument present, it sets the operator mask for the compartment (equivalent to calling the deny_only method).</source>
          <target state="translated">MASK 인수가 있으면 구획의 연산자 마스크를 설정합니다 (deny_only 메소드 호출과 동일).</target>
        </trans-unit>
        <trans-unit id="a26ddc37c924b20873cf0fb8deaac6c02f3c0643" translate="yes" xml:space="preserve">
          <source>With the _POSIX_EXIT macro set, the Unix exit value of zero is represented as a VMS native status of 1, and the Unix values from 2 to 255 are encoded by the equation:</source>
          <target state="translated">_POSIX_EXIT 매크로가 설정되면 Unix 종료 값 0은 VMS 기본 상태 1로 표시되고 2에서 255까지의 Unix 값은 다음 방정식으로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="b04e80858e882edcc84d0f324c4fa0f1bc41eaae" translate="yes" xml:space="preserve">
          <source>With the check_sigs parameter you can turn signature checking on and off. The default is off for now because the whole tool chain for the functionality is not yet considered mature by some. The author of CPAN.pm would recommend setting it to true most of the time and turning it off only if it turns out to be annoying.</source>
          <target state="translated">check_sigs 매개 변수를 사용하면 서명 확인을 켜거나 끌 수 있습니다. 기능에 대한 전체 툴 체인이 아직 성숙되지 않은 것으로 간주되어 기본값이 해제되어 있습니다. CPAN.pm의 작성자는 대부분의 경우 true로 설정하고 성가신 것으로 판명되는 경우에만 끄는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="65d6f831578499e9dbe5b97d3e54d9d6970d12d6" translate="yes" xml:space="preserve">
          <source>With the completion of Example 4, we now have an easy way to simulate some real-life libraries whose interfaces may not be the cleanest in the world. We shall now continue with a discussion of the arguments passed to the &lt;b&gt;xsubpp&lt;/b&gt; compiler.</source>
          <target state="translated">예제 4가 완성되면서 인터페이스가 세계에서 가장 깨끗하지 않을 수있는 실제 라이브러리를 쉽게 시뮬레이션 할 수 있습니다. 이제 &lt;b&gt;xsubpp&lt;/b&gt; 컴파일러에 전달 된 인수에 대한 설명을 계속하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="1f205214a6ba2cf07a234149bf2d1460c5296c50" translate="yes" xml:space="preserve">
          <source>With the creation of the &lt;code&gt;IO::Compress&lt;/code&gt; and &lt;code&gt;IO::Uncompress&lt;/code&gt; modules no new features are planned for &lt;code&gt;Compress::Zlib&lt;/code&gt; - the new modules do everything that &lt;code&gt;Compress::Zlib&lt;/code&gt; does and then some. Development on &lt;code&gt;Compress::Zlib&lt;/code&gt; will be limited to bug fixes only.</source>
          <target state="translated">의 창조와 &lt;code&gt;IO::Compress&lt;/code&gt; 및 &lt;code&gt;IO::Uncompress&lt;/code&gt; 모듈은 어떤 새로운 기능에 대한 계획이 없습니다 &lt;code&gt;Compress::Zlib&lt;/code&gt; - 새로운 모듈은 모든 것을 할 &lt;code&gt;Compress::Zlib&lt;/code&gt; 다음 몇 가지 수행을합니다. &lt;code&gt;Compress::Zlib&lt;/code&gt; 개발은 버그 수정으로 만 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="23f3553b9522af30d1dac804157bedd65e6495d3" translate="yes" xml:space="preserve">
          <source>With the default setting the size is limited to 128MB. The -1 removes this limit. If the &quot;make test&quot; fails please change your /etc/security/limits as stated above.</source>
          <target state="translated">기본 설정에서는 크기가 128MB로 제한됩니다. -1은이 제한을 제거합니다. &quot;make test&quot;에 실패하면 위에서 설명한대로 / etc / security / limits를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="9b9699d8827c96371e7103bd01aa95e9549d18da" translate="yes" xml:space="preserve">
          <source>With the example above, you knew to look for &lt;code&gt;Perl_pp_add&lt;/code&gt; , but what if there were multiple calls to it all over the place, or you didn't know what the op was you were looking for?</source>
          <target state="translated">위의 예에서, 당신은 &lt;code&gt;Perl_pp_add&lt;/code&gt; 을 찾는 것을 알고 있었지만 , 여기저기서 여러 번의 호출이 있었거나, 당신이 찾고있는 op가 무엇인지 모른다면?</target>
        </trans-unit>
        <trans-unit id="65607d779f766d1b6b4828b7428d0ded3d690325" translate="yes" xml:space="preserve">
          <source>With the following options you get a Perl version which passes all make tests in 32-bit mode.</source>
          <target state="translated">다음 옵션을 사용하면 32 비트 모드에서 모든 make 테스트를 통과하는 Perl 버전이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a8358873bd6ba12b8e2a5bea80bf9adbb46e0a6e" translate="yes" xml:space="preserve">
          <source>With the following options you get a Perl version which passes all make tests in 64-bit mode.</source>
          <target state="translated">다음 옵션을 사용하면 64 비트 모드에서 모든 make 테스트를 통과하는 Perl 버전이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="26bc1ab7fe70714950b9630e3ca1a3522b890186" translate="yes" xml:space="preserve">
          <source>With the following options you get a threaded Perl version which passes all make tests in 64-bit mode.</source>
          <target state="translated">다음 옵션을 사용하면 64 비트 모드에서 모든 테스트를 통과하는 스레드 된 Perl 버전이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="653ecd70c393a4f98976d6cf49198158a3d68bae" translate="yes" xml:space="preserve">
          <source>With the following options you get a threaded Perl version which passes all make tests in threaded 32-bit mode, which is the default configuration for the Perl builds that AIX ships with.</source>
          <target state="translated">다음 옵션을 사용하면 모든 스레드 테스트를 스레드 32 비트 모드로 전달하는 스레드 Perl 버전이 제공되는데, 이는 AIX와 함께 제공되는 Perl 빌드의 기본 구성입니다.</target>
        </trans-unit>
        <trans-unit id="826dec98b275c7a952ab77d69c22223ec197d3b5" translate="yes" xml:space="preserve">
          <source>With the introduction of lexical warnings, mandatory warnings now become</source>
          <target state="translated">사전 경고가 도입됨에 따라 필수 경고는 이제</target>
        </trans-unit>
        <trans-unit id="cb83c7552e22c7b5119774691db23c4fd72dba00" translate="yes" xml:space="preserve">
          <source>With the introduction of the</source>
          <target state="translated">소개와 함께</target>
        </trans-unit>
        <trans-unit id="dd358809edabd87f2081065d37eb93940f155fac" translate="yes" xml:space="preserve">
          <source>With the lock released, process &quot;B&quot; can now continue. It also updates the database and unfortunately it too modifies the data that was in its initial buffer. Once that data gets flushed to disk it will overwrite some/all of the changes process &quot;A&quot; made to the database.</source>
          <target state="translated">잠금이 해제되면 &quot;B&quot;프로세스를 계속 진행할 수 있습니다. 또한 데이터베이스를 업데이트하고 불행히도 초기 버퍼에 있던 데이터도 수정합니다. 해당 데이터가 디스크로 플러시되면 데이터베이스에 대한 변경 프로세스 &quot;A&quot;의 일부 / 모든 내용을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="b4b71a45e3d179fe5db4257fdf8f0f1934140fcb" translate="yes" xml:space="preserve">
          <source>With the release 5.003_01 the dynamically loadable libraries should be rebuilt when a different version of Perl is compiled. In particular, DLLs (including</source>
          <target state="translated">5.003_01 릴리스에서는 다른 버전의 Perl이 컴파일 될 때 동적으로로드 가능한 라이브러리를 다시 빌드해야합니다. 특히 DLL (</target>
        </trans-unit>
        <trans-unit id="5325c34a4ae29cf34042f77f365e0b89df2159a0" translate="yes" xml:space="preserve">
          <source>With this keyword present &lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;The RETVAL Variable&lt;/a&gt; is created, and in the generated call to the subroutine this variable is assigned to, but the value of this variable is not going to be used in the auto-generated code.</source>
          <target state="translated">이 키워드가 있으면 &lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;RETVAL 변수&lt;/a&gt; 가 작성되고 서브 루틴에 대한 생성 된 호출에서이 변수가 지정되지만이 변수의 값은 자동 생성 코드에서 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1f7c25b6745f51eae37c62a2374f7ba131484e1b" translate="yes" xml:space="preserve">
          <source>With this option, the rendering of each statement (starting with the nextstate OP) will be preceded by the 1st line of source code that generates it. For example:</source>
          <target state="translated">이 옵션을 사용하면 각 명령문의 렌더링 (다음 상태 OP로 시작) 앞에 생성 된 소스 코드의 첫 번째 줄이옵니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8f18c563efb0b7956e6e194500e98dba172fcbe5" translate="yes" xml:space="preserve">
          <source>With this syntax, the whitespace character(s) after the &quot;C&amp;lt;&amp;lt;&amp;lt;&quot; and before the &quot;&amp;gt;&amp;gt;&amp;gt;&quot; (or whatever letter) are</source>
          <target state="translated">이 구문에서 &quot;C &amp;lt;&amp;lt;&amp;lt;&quot;다음과 &quot;&amp;gt;&amp;gt;&amp;gt;&quot;앞의 공백 문자 (또는 문자)는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9b739cdb3f9d5a8eac7c3872d89896d374a02d63" translate="yes" xml:space="preserve">
          <source>With this, &quot;somepackage&quot; will be required, then the stash is inspected, and each function is rendered.</source>
          <target state="translated">이를 통해 &quot;somepackage&quot;가 필요하고 숨김이 검사되고 각 기능이 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="a5fec2f4d5db8c4f13f212d9ea51033367a444e6" translate="yes" xml:space="preserve">
          <source>With this, &lt;code&gt;charinrange()&lt;/code&gt; will return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if its input code point maps to &lt;code&gt;$default&lt;/code&gt; . You can avoid this by omitting the &lt;code&gt;&lt;a href=&quot;../functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; statement, and adding a line after the loop to handle the final element of the inversion map.</source>
          <target state="translated">이것으로 &lt;code&gt;charinrange()&lt;/code&gt; 는 입력 코드 포인트가 &lt;code&gt;$default&lt;/code&gt; 매핑되면 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환 합니다. &lt;code&gt;&lt;a href=&quot;../functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 명령문 을 생략하고 루프 뒤에 줄을 추가하여 반전 맵의 최종 요소를 처리하면 이를 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6dae05359217975cb78e41e5b34deca474650edf" translate="yes" xml:space="preserve">
          <source>With threads one must be careful to make sure they all have a chance to run to completion, assuming that is what you want.</source>
          <target state="translated">스레드를 사용하면 원하는 것을 가정하여 스레드가 모두 완료 될 수 있도록주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="caa257633e4cd0d103eaaa262d9da80593127c23" translate="yes" xml:space="preserve">
          <source>With todo tests, it's best to have the tests actually run. That way you'll know when they start passing. Sometimes this isn't possible. Often a failing test will cause the whole program to die or hang, even inside an &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt; BLOCK&lt;/code&gt; with and using &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt;. In these extreme cases you have no choice but to skip over the broken tests entirely.</source>
          <target state="translated">할일 테스트에서는 실제로 테스트를 실행하는 것이 가장 좋습니다. 그렇게하면 그들이지나 가기 시작할 때 알게됩니다. 때때로 이것은 불가능합니다. 종종 테스트에 실패 하면 &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 사용하거나 사용 하는 &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt; BLOCK&lt;/code&gt; 내부에서도 전체 프로그램이 죽거나 중단 됩니다. 이러한 극단적 인 경우에는 깨진 테스트를 완전히 건너 뛸 수밖에 없습니다.</target>
        </trans-unit>
        <trans-unit id="ec0e094c2438c09cc3dbc2cdfeb2a697dd782dc5" translate="yes" xml:space="preserve">
          <source>Within &lt;code&gt;(?[ ])&lt;/code&gt; , no literal characters are allowed unless they are within an inner pair of square brackets, like</source>
          <target state="translated">&lt;code&gt;(?[ ])&lt;/code&gt; 내에서 리터럴 문자는 내부 대괄호 안에 있지 않으면 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2e8425db1df10e66ba739a46b6d044fcd9cc27fd" translate="yes" xml:space="preserve">
          <source>Within Perl, you may use this directly:</source>
          <target state="translated">Perl 내에서 직접 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="34e265601157e7965a7e7bfdb3408a61baf139df" translate="yes" xml:space="preserve">
          <source>Within USS your /etc/profile or $HOME/.profile may limit your ulimit settings. Check that the following command returns reasonable values:</source>
          <target state="translated">USS 내에서 / etc / profile 또는 $ HOME / .profile이 ulimit 설정을 제한 할 수 있습니다. 다음 명령이 적절한 값을 반환하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="29ba20619ba09719c47471e336e4ab5403150666" translate="yes" xml:space="preserve">
          <source>Within a Pod block, there are &lt;b&gt;Pod paragraphs&lt;/b&gt;. A Pod paragraph consists of non-blank lines of text, separated by one or more blank lines.</source>
          <target state="translated">포드 블록 내에는 &lt;b&gt;포드 단락이&lt;/b&gt; 있습니다. 포드 단락은 공백이 아닌 텍스트 줄로 구성되며 하나 이상의 빈 줄로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="e21031e24f9ec987f957a61688b27e62b9c110c1" translate="yes" xml:space="preserve">
          <source>Within a character class:</source>
          <target state="translated">캐릭터 클래스 내에서 :</target>
        </trans-unit>
        <trans-unit id="40c178236d58dee9559c7a2a4195e7fba2bd546e" translate="yes" xml:space="preserve">
          <source>Within a pattern, you may designate subpatterns for later reference by enclosing them in parentheses, and you may refer back to the</source>
          <target state="translated">패턴 내에서 나중에 참조 할 수 있도록 하위 패턴을 괄호로 묶어 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cfdb7962d912e72a66b4f3d5343b1e5e212ac27" translate="yes" xml:space="preserve">
          <source>Within a subroutine the array &lt;code&gt;@_&lt;/code&gt; contains the parameters passed to that subroutine. Inside a subroutine, &lt;code&gt;@_&lt;/code&gt; is the default array for the array operators &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">서브 루틴 내에서 배열 &lt;code&gt;@_&lt;/code&gt; 서브 루틴에 전달 된 매개 변수가 포함되어 있습니다. 서브 루틴 내에서 &lt;code&gt;@_&lt;/code&gt; 은 배열 연산자 &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; 의 기본 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="2ab4fe9703eceeab90b6dcb41e63f66c50a795d5" translate="yes" xml:space="preserve">
          <source>Within search patterns (which also undergo double-quotish substitution) there is an unfortunate ambiguity: Is &lt;code&gt;/$foo[bar]/&lt;/code&gt; to be interpreted as &lt;code&gt;/${foo}[bar]/&lt;/code&gt; (where &lt;code&gt;[bar]&lt;/code&gt; is a character class for the regular expression) or as &lt;code&gt;/${foo[bar]}/&lt;/code&gt; (where &lt;code&gt;[bar]&lt;/code&gt; is the subscript to array @foo)? If @foo doesn't otherwise exist, then it's obviously a character class. If @foo exists, Perl takes a good guess about &lt;code&gt;[bar]&lt;/code&gt; , and is almost always right. If it does guess wrong, or if you're just plain paranoid, you can force the correct interpretation with curly braces as above.</source>
          <target state="translated">검색 패턴 내에 (큰 따옴표로 대체 됨) 불행한 모호성이 있습니다. &lt;code&gt;/$foo[bar]/&lt;/code&gt; 는 &lt;code&gt;/${foo}[bar]/&lt;/code&gt; 로 해석되어야합니다 (여기서 &lt;code&gt;[bar]&lt;/code&gt; 는 정규 표현식) 또는 &lt;code&gt;/${foo[bar]}/&lt;/code&gt; (여기서 &lt;code&gt;[bar]&lt;/code&gt; 는 @foo를 배열하는 첨자입니다)? @foo가 존재하지 않으면 분명히 문자 클래스입니다. @foo가 존재한다면 Perl은 &lt;code&gt;[bar]&lt;/code&gt; 에 대해 좋은 추측을 하고 거의 항상 옳습니다. 그것이 잘못 추측되거나 평범한 편집증이라면 위와 같이 중괄호로 올바른 해석을 강요 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d84dbb525d8c49a11b671ff1144decfba831a5a9" translate="yes" xml:space="preserve">
          <source>Within strings that are to be displayed in a fixed-length text field, each control character is substituted by a space. (But remember the special meaning of &lt;code&gt;\r&lt;/code&gt; when using fill mode.) This is done to avoid misalignment when control characters &quot;disappear&quot; on some output media.</source>
          <target state="translated">고정 길이 텍스트 필드에 표시 될 문자열 내에서 각 제어 문자는 공백으로 대체됩니다. ( 채우기 모드를 사용할 때 &lt;code&gt;\r&lt;/code&gt; 의 특별한 의미를 기억하십시오 .) 이것은 일부 출력 매체에서 제어 문자가 &quot;사라질&quot;때 정렬 오류를 피하기 위해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="4456754ccf74e411d5ea49ec8792a5f2c7c3945a" translate="yes" xml:space="preserve">
          <source>Within that basic form, add the parts that you need to insert, change, or delete lines.</source>
          <target state="translated">해당 기본 양식 내에 선을 삽입, 변경 또는 삭제하는 데 필요한 부품을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="8cbc5afc548aa028061d92c2e27d708ba5cdc361" translate="yes" xml:space="preserve">
          <source>Within that module, create an &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine.</source>
          <target state="translated">해당 모듈 내에서 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 서브 루틴을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="8c44a88f26bc68b39089193962c587ad7e818543" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine do a call to &lt;code&gt;filter_add&lt;/code&gt; , passing it either a subroutine reference.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 서브 루틴 내에서 &lt;code&gt;filter_add&lt;/code&gt; 를 호출하여 서브 루틴 참조를 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="66ccfeaad3b7f2de2f94c5b7b2a2afe57c62216c" translate="yes" xml:space="preserve">
          <source>Within the alternative numbering group, group numbers start at the same position for each alternative. After the group, numbering continues with one higher than the maximum reached across all the alternatives.</source>
          <target state="translated">대체 번호 그룹 내에서 그룹 번호는 각 대체에 대해 동일한 위치에서 시작합니다. 그룹 후에는 모든 대안에서 도달 한 최대 값보다 하나 높은 번호가 계속 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="bee307dd55ae8e02f4730b754c6aca4828fa5f41" translate="yes" xml:space="preserve">
          <source>Within the anonymous subroutine or block that is passed to &lt;code&gt;FILTER&lt;/code&gt; , process the contents of $_ to change the source code in the desired manner.</source>
          <target state="translated">&lt;code&gt;FILTER&lt;/code&gt; 로 전달되는 익명 서브 루틴 또는 블록 내에서 $ _의 내용을 처리하여 원하는 방식으로 소스 코드를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="00c20e56f1d9e34b6bd5de0acc2c9d7db7958c51" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;a href=&quot;feature#The-'unicode_strings'-feature&quot;&gt;use feature 'unicode_strings' &lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;feature#The-'unicode_strings'-feature&quot;&gt;사용&lt;/a&gt; 범위 내 기능 'unicode_strings'</target>
        </trans-unit>
        <trans-unit id="db5115b248b9b3a92796783fe0ad72c64d3ee250" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;a href=&quot;perllocale#Unicode-and-UTF-8&quot;&gt;use locale 'not_characters' &lt;/a&gt;, or &lt;a href=&quot;perllocale&quot;&gt;use locale &lt;/a&gt; and the current locale is a UTF-8 locale.</source>
          <target state="translated">&lt;a href=&quot;perllocale#Unicode-and-UTF-8&quot;&gt;사용&lt;/a&gt; 범위 내에서 'not_characters' &lt;a href=&quot;perllocale&quot;&gt;로케일&lt;/a&gt; 또는 로케일을 사용 하고 현재 로케일은 UTF-8 로케일입니다.</target>
        </trans-unit>
        <trans-unit id="4b75686c25d4349996112a3e43d160bed9377b64" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; or higher</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; 범위 5.012 이상</target>
        </trans-unit>
        <trans-unit id="921e8cdb506222d3c5cb715870308743278f73c9" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , all non-ASCII Latin1 code points are quoted whether the string is encoded as UTF-8 or not. As mentioned above, locale does not affect the quoting of ASCII-range characters. This protects against those locales where characters such as &lt;code&gt;&quot;|&quot;&lt;/code&gt; are considered to be word characters.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 범위 locale 에서 모든 비 ASCII Latin1 코드 포인트는 문자열이 UTF-8로 인코딩되는지 여부에 따라 인용됩니다. 위에서 언급했듯이 로케일은 ASCII 범위 문자의 인용에 영향을 미치지 않습니다. 이것은 &lt;code&gt;&quot;|&quot;&lt;/code&gt; 와 같은 문자가있는 로케일로부터 보호합니다. 단어 문자로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="7f97b0baeb5c1f48ecb7c6036a913594c0cf832a" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 범위 내에서 utf8</target>
        </trans-unit>
        <trans-unit id="6c6da8dacdcff581b760f12d305142c260f19722" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , all non-ASCII Latin1 code points are quoted whether the string is encoded as UTF-8 or not. As mentioned above, locale does not affect the quoting of ASCII-range characters. This protects against those locales where characters such as &lt;code&gt;&quot;|&quot;&lt;/code&gt; are considered to be word characters.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 범위 locale 에서 모든 비 ASCII Latin1 코드 포인트는 문자열이 UTF-8로 인코딩되는지 여부에 따라 인용됩니다. 위에서 언급했듯이 로케일은 ASCII 범위 문자의 인용에 영향을 미치지 않습니다. 이것은 &lt;code&gt;&quot;|&quot;&lt;/code&gt; 와 같은 문자가있는 로케일로부터 보호합니다. 단어 문자로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="b93e8b9c84e9c172138891ffbac960fd8330a481" translate="yes" xml:space="preserve">
          <source>Within the subroutine reference, call &lt;code&gt;filter_read&lt;/code&gt; or &lt;code&gt;filter_read_exact&lt;/code&gt; to &quot;prime&quot; $_ with source code data from the source file that will &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; your module. Check the status value returned to see if any source code was actually read in.</source>
          <target state="translated">서브 루틴 참조 내에서 &lt;code&gt;filter_read&lt;/code&gt; 또는 &lt;code&gt;filter_read_exact&lt;/code&gt; 를 호출 하여 모듈 을 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 소스 파일의 소스 코드 데이터로 $ _를 &quot;프라임&quot;$ _ 하십시오. 리턴 된 상태 값을 확인하여 소스 코드를 실제로 읽었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="4f5dc8da9477105396ff0284ea2a7a7433b232a3" translate="yes" xml:space="preserve">
          <source>Within the while loop we call accept() and check to see if it returns a false value. This would normally indicate a system error needs to be reported. However, the introduction of safe signals (see &lt;a href=&quot;#Deferred-Signals-(Safe-Signals)&quot;&gt;Deferred Signals (Safe Signals)&lt;/a&gt; above) in Perl 5.8.0 means that accept() might also be interrupted when the process receives a signal. This typically happens when one of the forked subprocesses exits and notifies the parent process with a CHLD signal.</source>
          <target state="translated">while 루프 내에서 accept ()를 호출하고 false 값을 반환하는지 확인합니다. 이는 일반적으로 시스템 오류가보고되어야 함을 나타냅니다. 그러나 Perl 5.8.0에 &lt;a href=&quot;#Deferred-Signals-(Safe-Signals)&quot;&gt;안전 신호 (&lt;/a&gt; 위의 지연 신호 (안전 신호) 참조)가 도입되면 프로세스가 신호를 수신 할 때 accept ()도 중단 될 수 있습니다. 이는 일반적으로 분기 된 하위 프로세스 중 하나가 종료되고 CHLD 신호로 상위 프로세스에 알릴 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="17b7808b8c8156fa9926b089d73ad2021671fe67" translate="yes" xml:space="preserve">
          <source>Without Readline support you may see the symbols &quot;^[[A&quot;, &quot;^[[C&quot;, &quot;^[[B&quot;, &quot;^[[D&quot;&quot;, &quot;^H&quot;, ... when using the arrow keys and/or the backspace key.</source>
          <target state="translated">Readline 지원이 없으면 화살표 키를 사용할 때 &quot;^ [[A&quot;, &quot;^ [[C&quot;, &quot;^ [[B&quot;, &quot;^ [[D&quot; &quot;,&quot;^ H &quot;, ...) 기호가 표시 될 수 있습니다. 및 / 또는 백 스페이스 키.</target>
        </trans-unit>
        <trans-unit id="7a72072ff5468f365a1052f00033c60b07221002" translate="yes" xml:space="preserve">
          <source>Without additional configuration, GetOptions() will ignore the case of option names, and allow the options to be abbreviated to uniqueness.</source>
          <target state="translated">추가 구성이 없으면 GetOptions ()는 옵션 이름의 경우를 무시하고 옵션을 고유성으로 줄여줍니다.</target>
        </trans-unit>
        <trans-unit id="d5efb30492f1c199d1a2c0cf117a4ad4a638df64" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves a regular expression for simplifying the individual item strings once the list type has been determined. Usage: E.g. when converting to HTML, one might strip the leading number in an ordered list as &lt;code&gt;&amp;lt;OL&amp;gt;&lt;/code&gt; already prints numbers itself. This must have been set before by either specifying &lt;b&gt;-rx&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;rx()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">인수없이, 목록 유형이 결정되면 개별 항목 문자열을 단순화하기위한 정규식을 검색합니다. 사용법 : 예를 들어 HTML로 변환 할 때 &lt;code&gt;&amp;lt;OL&amp;gt;&lt;/code&gt; 이 이미 숫자 자체를 인쇄 하므로 순서 목록에서 선행 숫자를 제거 할 수 있습니다. &lt;b&gt;new ()&lt;/b&gt; 메소드 에서 &lt;b&gt;-rx&lt;/b&gt; 를 지정 하거나 스칼라 인수로 &lt;b&gt;rx ()&lt;/b&gt; 메소드를 호출하여 설정해야합니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="18657a3de0c78898530507337e291d8dba0f72cc" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves information about the list tag, which can be any scalar. This must have been set before by either specifying &lt;b&gt;-tag&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;tag()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">인수없이, 스칼라 일 수있는 목록 태그에 대한 정보를 검색합니다. &lt;b&gt;new ()&lt;/b&gt; 메소드 에서 &lt;b&gt;-tag&lt;/b&gt; 를 지정 하거나 스칼라 인수로 &lt;b&gt;tag ()&lt;/b&gt; 메소드를 호출하여 이전에 설정되어 있어야합니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8ccc25a668b5326c657bc2f5c79197991b145ee7" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves information about the parent holding this list, which is represented as an arbitrary scalar. This must have been set before by either specifying &lt;b&gt;-parent&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;parent()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">인수없이이리스트를 보유하는 부모에 대한 정보를 검색하며, 이는 임의의 스칼라로 표시됩니다. &lt;b&gt;new ()&lt;/b&gt; 메소드 에서 &lt;b&gt;-parent&lt;/b&gt; 를 지정 하거나 스칼라 인수로 &lt;b&gt;parent ()&lt;/b&gt; 메소드를 호출하여 이전에 설정되어 있어야합니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c9f5dc6cba8c17ba8a8e789cb997502b75241827" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the array of the items in this list. The items may be represented by any scalar. If an argument has been given, it is pushed on the list of items.</source>
          <target state="translated">인수없이이 목록에있는 항목의 배열을 검색합니다. 항목은 임의의 스칼라로 표시 될 수 있습니다. 인수가 주어지면 항목 목록에서 푸시됩니다.</target>
        </trans-unit>
        <trans-unit id="b13b7cf761d2e7e6717a0226cb08e73a66d55812" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the file name the list is in. This must have been set before by either specifying &lt;b&gt;-file&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;file()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">인수가 없으면 목록이있는 파일 이름을 검색합니다. &lt;b&gt;new ()&lt;/b&gt; 메소드 에서 &lt;b&gt;-file&lt;/b&gt; 을 지정 하거나 스칼라 인수와 함께 &lt;b&gt;file ()&lt;/b&gt; 메소드를 호출하여 이전에 설정되어 있어야합니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1b1eba0344418f60cab2e73b154b51b8cc2fd939" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the indent level of the list as specified in &lt;code&gt;=over n&lt;/code&gt; . This must have been set before by either specifying &lt;b&gt;-indent&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;indent()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">인수가 없으면 &lt;code&gt;=over n&lt;/code&gt; 에 지정된대로 목록의 들여 쓰기 레벨을 검색합니다 . &lt;b&gt;new ()&lt;/b&gt; 메소드 에서 &lt;b&gt;-indent&lt;/b&gt; 를 지정 하거나 스칼라 인수와 함께 &lt;b&gt;indent ()&lt;/b&gt; 메소드를 호출하여 설정해야합니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c3a863e0f35dbdfaea66e845edf4708bb6d53918" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the line number where the list started. This must have been set before by either specifying &lt;b&gt;-start&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;start()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">인수없이 목록이 시작된 행 번호를 검색합니다. &lt;b&gt;new ()&lt;/b&gt; 메소드 에서 &lt;b&gt;-start&lt;/b&gt; 를 지정 하거나 스칼라 인수와 함께 &lt;b&gt;start ()&lt;/b&gt; 메소드를 호출하여 설정해야합니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="914d0fa2ff8badbccd79dfd30e292a8ed73be0c1" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the list type, which can be an arbitrary value, e.g. &lt;code&gt;OL&lt;/code&gt; , &lt;code&gt;UL&lt;/code&gt; , ... when thinking the HTML way. This must have been set before by either specifying &lt;b&gt;-type&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;type()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">인수없이 , HTML 방식을 생각할 때 임의의 값 (예 : &lt;code&gt;OL&lt;/code&gt; , &lt;code&gt;UL&lt;/code&gt; , ...)이 될 수있는 목록 유형을 검색합니다 . &lt;b&gt;new ()&lt;/b&gt; 메소드 에서 &lt;b&gt;-type&lt;/b&gt; 을 지정 하거나 스칼라 인수로 &lt;b&gt;type ()&lt;/b&gt; 메소드를 호출하여 이전에 설정되어 있어야합니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0c21aaff33380d9ba14cee3094239dfc4fb494ab" translate="yes" xml:space="preserve">
          <source>Without arguments libnetcfg displays the current configuration.</source>
          <target state="translated">인수없이 libnetcfg는 현재 구성을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="4decffda157c9d482865e95a2bef98fbdd07c180" translate="yes" xml:space="preserve">
          <source>Without autodie (and assuming BAREWORD is an open filehandle/dirhandle) this is a valid call to chdir. But under autodie, &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; will behave like it had the prototype &quot;;$&quot; and thus BAREWORD will be a syntax error (under &quot;use strict&quot;. Without strict, it will interpreted as a filename).</source>
          <target state="translated">autodie가 없으면 (BAREWORD가 열린 파일 핸들 / dirhandle이라고 가정) 이것은 chdir에 대한 유효한 호출입니다. 그러나 autodie에서 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 은 &quot;; $&quot;프로토 타입이있는 것처럼 작동하므로 BAREWORD는 구문 오류 ( &quot;use strict&quot;아래에 있습니다. strict가 없으면 파일 이름으로 해석됩니다).</target>
        </trans-unit>
        <trans-unit id="157dc325ab3004964dba8cb99f25c548e59c3ee6" translate="yes" xml:space="preserve">
          <source>Without binmode this happens to work but without binmode, print() fails instead of write().</source>
          <target state="translated">binmode가 없으면 작동하지만 binmode가 없으면 write () 대신 print ()가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="9fae572f92ad00688736431e8db34f7e13e97183" translate="yes" xml:space="preserve">
          <source>Without compiling a special Perl, there is no way to get the exact same behavior of any versions prior to Perl 5.18.0. The closest one can get is by setting PERL_PERTURB_KEYS to 0 and setting the PERL_HASH_SEED to a known value. We do not advise those settings for production use due to the above security considerations.</source>
          <target state="translated">특별한 Perl을 컴파일하지 않으면 Perl 5.18.0 이전 버전과 동일한 동작을 얻을 수있는 방법이 없습니다. 가장 가까운 것은 PERL_PERTURB_KEYS를 0으로 설정하고 PERL_HASH_SEED를 알려진 값으로 설정하는 것입니다. 위의 보안 고려 사항으로 인해 프로덕션 용 설정은 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="40d89b93ede452cf3a3abe5db73cc3f6990cb465" translate="yes" xml:space="preserve">
          <source>Without sending mail to the address and seeing whether there's a human on the other end to answer you, you cannot fully answer part</source>
          <target state="translated">주소로 메일을 보내지 않고 상대방이 당신에게 답할 수있는 사람이 있는지 알지 못하면 부분적으로 완전히 대답 할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="9dc761ae6cda1ca106ca429a9b91481691a414c5" translate="yes" xml:space="preserve">
          <source>Without tests provided by the original author, how can anyone else changing perl in the future be sure that they haven't unwittingly broken the behaviour the patch implements? And without tests, how can the patch's author be confident that his/her hard work put into the patch won't be accidentally thrown away by someone in the future?</source>
          <target state="translated">원래 작성자가 제공 한 테스트가 없다면, 미래에 펄을 바꾸는 다른 사람이 패치로 구현 한 동작을 실수로 중단하지 않았 음을 어떻게 확인할 수 있습니까? 그리고 테스트없이 패치 작성자는 패치에 넣은 노력이 미래에 누군가 실수로 버려지지 않을 것이라고 어떻게 확신 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="c1443d621edad5afbf828f718460ec1c38b6ccbc" translate="yes" xml:space="preserve">
          <source>Without that empty line before the &quot;=head1&quot;, many translators wouldn't have recognized the &quot;=head1&quot; as starting a Pod block.</source>
          <target state="translated">&quot;= head1&quot;앞에 빈 줄이 없으면 많은 번역가가 &quot;= head1&quot;을 Pod 블록을 시작하는 것으로 인식하지 못했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="d67d28a004691a2df73ec622342b344f42349502" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt; $AUTOLOAD&lt;/code&gt; declaration, this code will not compile under the &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; pragma.</source>
          <target state="translated">포함하지 않는 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt; $AUTOLOAD&lt;/code&gt; 선언이 코드는 아래에 컴파일되지 않습니다 &lt;a href=&quot;strict&quot;&gt;엄격한&lt;/a&gt; 프라그.</target>
        </trans-unit>
        <trans-unit id="9862e56ba4382f4550c0a053a28a9edc67cb29a8" translate="yes" xml:space="preserve">
          <source>Without the \\ before the #, we'd have the start of a Makefile comment, and the macro would be incorrectly defined.</source>
          <target state="translated"># 앞에 \\가 없으면 Makefile 주석이 시작되고 매크로가 잘못 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="c652adb6df9438fc28974e5263002f95713055c4" translate="yes" xml:space="preserve">
          <source>Without the all-critical &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; declaration, putting UTF‑8 in your literals and identifiers won&amp;rsquo;t work right. If you used the standard preamble just given above, this already happened. If you did, you can do things like this:</source>
          <target state="translated">모든 중요한없이 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 선언, 당신의 리터럴 및 식별자 업무를 잘하지 않습니다에 UTF-8을 넣어. 위에서 주어진 표준 프리앰블을 사용했다면 이미 발생한 것입니다. 그렇게했다면 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a805f73e432af03c931e3e4ebc6e43febdbb1b0f" translate="yes" xml:space="preserve">
          <source>Without the braces, Perl would have looked for a $whospeak, a &lt;code&gt;$who::0&lt;/code&gt; , and a &lt;code&gt;$who's&lt;/code&gt; variable. The last two would be the $0 and the $s variables in the (presumably) non-existent package &lt;code&gt;who&lt;/code&gt; .</source>
          <target state="translated">중괄호가 없으면 Perl은 $ whospeak, &lt;code&gt;$who::0&lt;/code&gt; 및 &lt;code&gt;$who's&lt;/code&gt; 변수를 찾았습니다 . 마지막 두 개는 (아마도) 존재하지 않는 패키지 &lt;code&gt;who&lt;/code&gt; 의 $ 0 및 $ s 변수 입니다 .</target>
        </trans-unit>
        <trans-unit id="8b7119185642381b4835e616a2adfce6407060de" translate="yes" xml:space="preserve">
          <source>Without the file handle there is no straightforward way to map from the C callback to the Perl subroutine.</source>
          <target state="translated">파일 핸들이 없으면 C 콜백에서 Perl 서브 루틴으로 맵핑하는 간단한 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="557fc723a913d1e3b2505b4094298be8eec2001a" translate="yes" xml:space="preserve">
          <source>Without the quotes Perl would convert the large number to a floating point constant at compile time and then hand the result to BigInt, which results in an truncated result or a NaN.</source>
          <target state="translated">따옴표가 없으면 Perl은 컴파일 타임에 큰 수를 부동 소수점 상수로 변환 한 다음 결과를 BigInt로 전달하여 결과가 잘 리거나 NaN이됩니다.</target>
        </trans-unit>
        <trans-unit id="ebd1a191c5e0195ae68815f767eadf66793aed3f" translate="yes" xml:space="preserve">
          <source>Without this pragma, if strings operating under byte semantics and strings with Unicode character data are concatenated, the new string will be created by decoding the byte strings as</source>
          <target state="translated">이 pragma가 없으면 바이트 시맨틱에서 작동하는 문자열과 유니 코드 문자 데이터가있는 문자열이 연결되면 바이트 문자열을 다음과 같이 디코딩하여 새 문자열이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="4e3240128cc4ac6294817aa01c1437d4416b9150" translate="yes" xml:space="preserve">
          <source>Word characters</source>
          <target state="translated">단어 문자</target>
        </trans-unit>
        <trans-unit id="c1ab804bf377c2d02f25ebababbe5112fca26b12" translate="yes" xml:space="preserve">
          <source>Work Crew</source>
          <target state="translated">작업 대원</target>
        </trans-unit>
        <trans-unit id="73f4875bffaeefb6bc4c9e5de5982f1c956b5814" translate="yes" xml:space="preserve">
          <source>Work around DCL's 255 character limit several times,and use VMS-style command line quoting in a few cases.</source>
          <target state="translated">DCL의 255 자 제한을 여러 번 해결하고 경우에 따라 VMS 스타일 명령 줄 인용을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="beb03a8c30af39505328c268c1180c75604701a0" translate="yes" xml:space="preserve">
          <source>Work for the pumpking, work for Perl programmers, work for module authors, ... Perl is supposed to be easy.</source>
          <target state="translated">pumpking, Perl 프로그래머, 모듈 작성자를위한 작업, ... Perl은 쉬워야합니다.</target>
        </trans-unit>
        <trans-unit id="b837e4f0aacd9d9f6074d443ecd309cef87e661e" translate="yes" xml:space="preserve">
          <source>Working code is always preferred to pie-in-the-sky ideas. A patch to add a feature stands a much higher chance of making it to the language than does a random feature request, no matter how fervently argued the request might be. This ties into &quot;Will it be useful?&quot;, as the fact that someone took the time to make the patch demonstrates a strong desire for the feature.</source>
          <target state="translated">작업 코드는 항상 최신 아이디어보다 선호됩니다. 기능을 추가하는 패치는 요청이 아무리 격렬하게 주장 되더라도 임의의 기능 요청보다 언어로 만들 가능성이 훨씬 높습니다. 누군가 패치를 작성하는 데 시간이 걸린다는 사실은이 기능에 대한 강한 열망을 보여주기 때문에 &quot;유용합니까?&quot;와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="791f0cf1a4866efe09fa052199378fd87a29a636" translate="yes" xml:space="preserve">
          <source>Working with AVs</source>
          <target state="translated">AV 작업</target>
        </trans-unit>
        <trans-unit id="fcf77865e202a40f39e6dc4633dec2c1c8b8542a" translate="yes" xml:space="preserve">
          <source>Working with HVs</source>
          <target state="translated">HV 작업</target>
        </trans-unit>
        <trans-unit id="9ba6b91bf263dc667dda1becd81a9fbef7358bbd" translate="yes" xml:space="preserve">
          <source>Working with Net::FTP</source>
          <target state="translated">Net :: FTP로 작업하기</target>
        </trans-unit>
        <trans-unit id="9522f5ef01714aab2e2d70111bf52346aa9851c3" translate="yes" xml:space="preserve">
          <source>Working with SVs</source>
          <target state="translated">SV 작업</target>
        </trans-unit>
        <trans-unit id="7efe528e837c3e9dd842174c934d74e9c8e8af64" translate="yes" xml:space="preserve">
          <source>Works currently only for integers.</source>
          <target state="translated">현재 정수에만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c9cb7c59dae1a78441bca64b16b41d57dc70c3e5" translate="yes" xml:space="preserve">
          <source>Works exactly as &lt;code&gt;like()&lt;/code&gt; , only it checks if $got &lt;b&gt;does not&lt;/b&gt; match the given pattern.</source>
          <target state="translated">&lt;code&gt;like()&lt;/code&gt; 동일하게 작동하며 $ got &lt;b&gt;이&lt;/b&gt; 주어진 패턴과 일치 &lt;b&gt;하지 않는지&lt;/b&gt; 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="9232c0576386ef7db9a66e0f3312f80aa2ae0362" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;#localtime&quot;&gt;localtime&lt;/a&gt; but the returned values are localized for the standard Greenwich time zone.</source>
          <target state="translated">처럼 작품 &lt;a href=&quot;#localtime&quot;&gt;의 현지&lt;/a&gt; 하지만 반환 값은 표준 그리니치 시간대로 현지화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="63d895f5ba3197e6e250fa353d94a31dc5531f0f" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;localtime&quot;&gt;localtime&lt;/a&gt; but the returned values are localized for the standard Greenwich time zone.</source>
          <target state="translated">처럼 작품 &lt;a href=&quot;localtime&quot;&gt;의 현지&lt;/a&gt; 하지만 반환 값은 표준 그리니치 시간대로 현지화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="59edd54160d7f94a92175d3ce89e67babbe534fb" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;more&quot;&gt;Test::More&lt;/a&gt;'s &lt;code&gt;cmp_ok()&lt;/code&gt; .</source>
          <target state="translated">처럼 작동 &lt;a href=&quot;more&quot;&gt;테스트 :: 자세히&lt;/a&gt; 의 &lt;code&gt;cmp_ok()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b054b39e72ec238653744e3a117cbf2b7bacaa18" translate="yes" xml:space="preserve">
          <source>Works just like index() except that it returns the position of the</source>
          <target state="translated">index ()와 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="62b7e0373549dae581f58b37784d19f9d489170e" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;sv_catpvf&lt;/code&gt; but copies the text into the SV instead of appending it. Does not handle 'set' magic. See &lt;code&gt;sv_setpvf_mg&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;sv_catpvf&lt;/code&gt; 처럼 작동 하지만 텍스트를 추가하는 대신 SV에 텍스트를 복사합니다. '세트'마법을 처리하지 않습니다. &lt;code&gt;sv_setpvf_mg&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="43ccfff897978a36d025fbdd87f7f80f29da36e5" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;sv_vcatpvf&lt;/code&gt; but copies the text into the SV instead of appending it. Does not handle 'set' magic. See &lt;code&gt;sv_vsetpvf_mg&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;sv_vcatpvf&lt;/code&gt; 처럼 작동 하지만 텍스트를 추가하는 대신 SV에 텍스트를 복사합니다. '세트'마법을 처리하지 않습니다. &lt;code&gt;sv_vsetpvf_mg&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ce9ad1c2559537d328f2e9ae5ccf06d2341106d3" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;sv_vcatpvfn&lt;/code&gt; but copies the text into the SV instead of appending it.</source>
          <target state="translated">&lt;code&gt;sv_vcatpvfn&lt;/code&gt; 처럼 작동 하지만 텍스트를 추가하는 대신 SV에 텍스트를 복사합니다.</target>
        </trans-unit>
        <trans-unit id="e28088b9057a774cbeb7647c942ba983be39b65a" translate="yes" xml:space="preserve">
          <source>Workshops</source>
          <target state="translated">Workshops</target>
        </trans-unit>
        <trans-unit id="aca31ad78f24eb8f34a6f1515e5ad96783f7a4c5" translate="yes" xml:space="preserve">
          <source>World Wide Web, HTML, HTTP, CGI, MIME</source>
          <target state="translated">월드 와이드 웹, HTML, HTTP, CGI, MIME</target>
        </trans-unit>
        <trans-unit id="dc354627de17c28e4a463874cb49fb69cf80c2d0" translate="yes" xml:space="preserve">
          <source>Worse still, if you've got a language like Chinese or Japanese that has hundreds or thousands of characters, then you really can't fit them into a mere 256, so they had to forget about ASCII altogether, and build their own systems using pairs of numbers to refer to one character.</source>
          <target state="translated">설상가상으로, 중국어 나 일본어와 같이 수백 또는 수천 개의 문자를 가진 언어를 가지고 있다면 실제로 256 자에 맞지 않기 때문에 ASCII를 잊어 버리고 자신의 시스템을 구축해야했습니다. 한 문자를 나타내는 숫자 쌍.</target>
        </trans-unit>
        <trans-unit id="c5bfba3d49e2ee674235e330da88197da31a7c79" translate="yes" xml:space="preserve">
          <source>Would print '1', because &lt;code&gt;$foo&lt;/code&gt; holds a reference to the</source>
          <target state="translated">&lt;code&gt;$foo&lt;/code&gt; 는 '1'을 인쇄합니다. 왜냐하면 $ foo 는</target>
        </trans-unit>
        <trans-unit id="cb47f1ed4bc872fb3335bdefcb281f4424715abe" translate="yes" xml:space="preserve">
          <source>Would run bin/foobar.PL like this:</source>
          <target state="translated">bin / foobar.PL을 다음과 같이 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="ead2351e2ba0bd4c816a4c94cc5152ad666ddb3d" translate="yes" xml:space="preserve">
          <source>Wrapper around CPAN.pm without using any XS module</source>
          <target state="translated">XS 모듈을 사용하지 않고 CPAN.pm을 감싸는 래퍼</target>
        </trans-unit>
        <trans-unit id="84ac379977c898d123ab3b5be8e7d1ebcc793262" translate="yes" xml:space="preserve">
          <source>Wrapper around Config.pm</source>
          <target state="translated">Config.pm 주위 래퍼</target>
        </trans-unit>
        <trans-unit id="5e2ec9565586c686048d53d457fe37527f6aad30" translate="yes" xml:space="preserve">
          <source>Wrapper class for calling subs at end of scope</source>
          <target state="translated">범위 끝에서 서브를 호출하기위한 랩퍼 클래스</target>
        </trans-unit>
        <trans-unit id="49754b3431fd16ae1cf0d382c55b7fa7149dd942" translate="yes" xml:space="preserve">
          <source>Wrapping all die calls in a handler routine can be useful to see how, and from where, they're being called, &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; has more information:</source>
          <target state="translated">처리기 루틴에서 모든 다이 호출을 래핑하는 것은 &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; 가 어떻게 그리고 어디에서 호출되는지에 대한 정보를 얻는 데 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c2c61b8accf065e529ff818a1a9f4549b7fc54ab" translate="yes" xml:space="preserve">
          <source>Wrapping with parenthesis allows the wildcard parts of the Input File Glob to be referenced by the second parameter to &lt;code&gt;globmap&lt;/code&gt; , &lt;code&gt;#1.tgz&lt;/code&gt; , the</source>
          <target state="translated">괄호로 &lt;code&gt;globmap&lt;/code&gt; 면 입력 파일 Glob의 와일드 카드 부분을 두 번째 매개 변수로 globmap , &lt;code&gt;#1.tgz&lt;/code&gt; 로 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ee0be976deb11b8b1d2de7c10091a2cf26d9d3d" translate="yes" xml:space="preserve">
          <source>Wraps any CODE references found within the arguments by replacing each with the result of calling &lt;a href=&quot;#wrap_code_ref&quot;&gt;wrap_code_ref&lt;/a&gt; on the CODE reference. Any ARRAY or HASH references in the arguments are inspected recursively.</source>
          <target state="translated">CODE 참조에서 &lt;a href=&quot;#wrap_code_ref&quot;&gt;wrap_code_ref&lt;/a&gt; 를 호출 한 결과로 각각을 대체하여 인수에서 찾은 CODE 참조를 랩핑합니다 . 인수의 ARRAY 또는 HASH 참조는 재귀 적으로 검사됩니다.</target>
        </trans-unit>
        <trans-unit id="c3415b34e4326194b5c5e94f65779568f9ab9142" translate="yes" xml:space="preserve">
          <source>Wraps up an op tree with some additional ops so that at runtime a dynamic scope will be created. The original ops run in the new dynamic scope, and then, provided that they exit normally, the scope will be unwound. The additional ops used to create and unwind the dynamic scope will normally be an &lt;code&gt;enter&lt;/code&gt; /&lt;code&gt;leave&lt;/code&gt; pair, but a &lt;code&gt;scope&lt;/code&gt; op may be used instead if the ops are simple enough to not need the full dynamic scope structure.</source>
          <target state="translated">런타임에 동적 범위가 작성되도록 일부 추가 op로 op 트리를 래핑합니다. 원래 op는 새 동적 범위에서 실행 된 다음 정상적으로 종료되면 범위가 풀립니다. 다이나믹 스코프를 생성 및 해제하는 데 사용되는 추가 ops는 일반적으로 &lt;code&gt;enter&lt;/code&gt; / &lt;code&gt;leave&lt;/code&gt; 쌍이지만 , ops가 전체 다이내믹 스코프 구조를 필요로하지 않을 정도로 단순하면 &lt;code&gt;scope&lt;/code&gt; op가 대신 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a48932789d199bbed709777e2d743ca2bafdc6c" translate="yes" xml:space="preserve">
          <source>Write</source>
          <target state="translated">Write</target>
        </trans-unit>
        <trans-unit id="665e91485da7b1f4da854eb4a64d72b175917c29" translate="yes" xml:space="preserve">
          <source>Write &lt;code&gt;SIZE&lt;/code&gt; bytes of data from &lt;code&gt;BUFFER&lt;/code&gt; to the server, also performing any &amp;lt;CRLF&amp;gt; translation necessary. &lt;code&gt;TIMEOUT&lt;/code&gt; is optional, if not given, the timeout value from the command connection will be used.</source>
          <target state="translated">&lt;code&gt;BUFFER&lt;/code&gt; 에서 서버로 &lt;code&gt;SIZE&lt;/code&gt; 바이트의 데이터를 쓰고 필요한 &amp;lt;CRLF&amp;gt; 변환도 수행하십시오. &lt;code&gt;TIMEOUT&lt;/code&gt; 은 선택 사항이며, 지정하지 않으면 명령 연결의 시간 초과 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9e9970521c52eb1a81f415505a29f59eba7d4c0c" translate="yes" xml:space="preserve">
          <source>Write &lt;code&gt;SIZE&lt;/code&gt; bytes to the shared memory segment at &lt;code&gt;POS&lt;/code&gt; . Returns true if successful, or false if there is an error. See &lt;a href=&quot;../functions/shmwrite&quot;&gt;shmwrite&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;POS&lt;/code&gt; 의 공유 메모리 세그먼트에 &lt;code&gt;SIZE&lt;/code&gt; 바이트를 씁니다 . 성공하면 true를, 오류가 있으면 false를 반환합니다. &lt;a href=&quot;../functions/shmwrite&quot;&gt;shmwrite를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c4d6106f35288022310ffee038cda3aae849b282" translate="yes" xml:space="preserve">
          <source>Write MYMETA information to MYMETA.json and MYMETA.yml.</source>
          <target state="translated">MYMETA 정보를 MYMETA.json 및 MYMETA.yml에 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="a9b6c91570493bdee3be6eef5a6b183ad756cdab" translate="yes" xml:space="preserve">
          <source>Write RFC 1950 files/buffers</source>
          <target state="translated">RFC 1950 파일 / 버퍼 작성</target>
        </trans-unit>
        <trans-unit id="0909abf68380a212e21e5479f6396ce54f63b785" translate="yes" xml:space="preserve">
          <source>Write RFC 1951 files/buffers</source>
          <target state="translated">RFC 1951 파일 / 버퍼 작성</target>
        </trans-unit>
        <trans-unit id="0a1ef998109ed3777e0f667818ad2c1c3ea0b70e" translate="yes" xml:space="preserve">
          <source>Write RFC 1952 files/buffers</source>
          <target state="translated">RFC 1952 파일 / 버퍼 작성</target>
        </trans-unit>
        <trans-unit id="e52a7d8ae8bb89850d8b0bad0931a61da15a6992" translate="yes" xml:space="preserve">
          <source>Write YAMLish data</source>
          <target state="translated">YAMLish 데이터 작성</target>
        </trans-unit>
        <trans-unit id="77878a047db48550e0d5361bfb44d185b930e978" translate="yes" xml:space="preserve">
          <source>Write a formatter as a Pod::Simple subclass</source>
          <target state="translated">Pod :: Simple 서브 클래스로 포맷터 작성</target>
        </trans-unit>
        <trans-unit id="bc54db5c1b3d5ac212fb800fdd56f965140da3e5" translate="yes" xml:space="preserve">
          <source>Write access via git</source>
          <target state="translated">자식을 통한 쓰기 액세스</target>
        </trans-unit>
        <trans-unit id="935636e37a0f4339394c64f63b5cea6433c1f963" translate="yes" xml:space="preserve">
          <source>Write an entry, whose name is equivalent to the file name provided to disk. Optionally takes a second parameter, which is the full native path (including filename) the entry will be written to.</source>
          <target state="translated">이름이 디스크에 제공된 파일 이름과 동일한 항목을 작성하십시오. 선택적으로 두 번째 매개 변수를 사용합니다.이 매개 변수는 항목이 기록 될 전체 기본 경로 (파일 이름 포함)입니다.</target>
        </trans-unit>
        <trans-unit id="5769fe16b9b0cad42af9406c72e837bd0c18c816" translate="yes" xml:space="preserve">
          <source>Write bzip2 files/buffers</source>
          <target state="translated">bzip2 파일 / 버퍼 작성</target>
        </trans-unit>
        <trans-unit id="bafb7482744edca206da4c0baa12b4a11269c914" translate="yes" xml:space="preserve">
          <source>Write documentation in POD</source>
          <target state="translated">POD로 문서 작성</target>
        </trans-unit>
        <trans-unit id="01995de03181a3f8adb7e727e73e6dc5e4e106c7" translate="yes" xml:space="preserve">
          <source>Write files whose names are equivalent to any of the names in &lt;code&gt;@filenames&lt;/code&gt; to disk, creating subdirectories as necessary. This might not work too well under VMS. Under MacPerl, the file's modification time will be converted to the MacOS zero of time, and appropriate conversions will be done to the path. However, the length of each element of the path is not inspected to see whether it's longer than MacOS currently allows (32 characters).</source>
          <target state="translated">&lt;code&gt;@filenames&lt;/code&gt; 의 이름과 동일한 이름을 가진 파일 을 디스크에 쓰고 필요한 경우 하위 디렉토리를 만듭니다. VMS에서는 제대로 작동하지 않을 수 있습니다. MacPerl에서는 파일 수정 시간이 MacOS 0으로 변환되고 경로에 대한 적절한 변환이 수행됩니다. 그러나 경로의 각 요소 길이는 현재 MacOS가 허용하는 길이 (32 자)보다 긴지 검사하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cbcd4ec744f6a0cc7a8100b555d7a1173e6952f5" translate="yes" xml:space="preserve">
          <source>Write linker options files for dynamic extension</source>
          <target state="translated">동적 확장을위한 링커 옵션 파일 작성</target>
        </trans-unit>
        <trans-unit id="dc5fd755a4779cecce293a2a1e919899f32cdf21" translate="yes" xml:space="preserve">
          <source>Write the C code for perlmain.c</source>
          <target state="translated">perlmain.c에 대한 C 코드 작성</target>
        </trans-unit>
        <trans-unit id="0a8eff4063a82696c6af1e9ea9cf555d97a3ea2c" translate="yes" xml:space="preserve">
          <source>Write the in-memory archive to disk. The first argument can either be the name of a file or a reference to an already open filehandle (a GLOB reference).</source>
          <target state="translated">메모리 내 아카이브를 디스크에 기록하십시오. 첫 번째 인수는 파일 이름이거나 이미 열려있는 파일 핸들에 대한 참조 (GLOB 참조) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af8f82dc202f24f05f3598bed445a87ed08771b7" translate="yes" xml:space="preserve">
          <source>Write the state to a file.</source>
          <target state="translated">상태를 파일에 씁니다.</target>
        </trans-unit>
        <trans-unit id="5ea3036e84ed65b742580afd08f2cf97f36ee5c9" translate="yes" xml:space="preserve">
          <source>Write to a file. This uses file descriptors such as those obtained by calling &lt;code&gt;POSIX::open&lt;/code&gt; .</source>
          <target state="translated">파일에 씁니다. &lt;code&gt;POSIX::open&lt;/code&gt; 을 호출하여 얻은 것과 같은 파일 디스크립터를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="fff8491fc63b40787a6bc354a1c28b21cd65c0f1" translate="yes" xml:space="preserve">
          <source>Write to modules@perl.org explaining what you did to contact the current maintainer. The PAUSE admins will also try to reach the maintainer.</source>
          <target state="translated">현재 관리자에게 연락하기 위해 수행 한 작업을 설명하는 modules@perl.org에 문의하십시오. PAUSE 관리자는 관리자에게 연락을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="ec3b4c2700310731999e0d7e25df0c587f5a195d" translate="yes" xml:space="preserve">
          <source>Write zip files/buffers</source>
          <target state="translated">zip 파일 / 버퍼 작성</target>
        </trans-unit>
        <trans-unit id="08d9173120127debf58115903083c7548d3871d3" translate="yes" xml:space="preserve">
          <source>Write-only access to the data in the file.</source>
          <target state="translated">파일의 데이터에 대한 쓰기 전용 액세스</target>
        </trans-unit>
        <trans-unit id="94dee2fafe1d10d5ce6db659eb0c0fcb3d5842be" translate="yes" xml:space="preserve">
          <source>WriteFile</source>
          <target state="translated">WriteFile</target>
        </trans-unit>
        <trans-unit id="8a1db595bd4c07aab5da69c69b2b0b595010f3b7" translate="yes" xml:space="preserve">
          <source>WriteMakefile() now does some basic sanity checks on its parameters to protect against typos and malformatted values. This means some things which happened to work in the past will now throw warnings and possibly produce internal errors.</source>
          <target state="translated">WriteMakefile ()은 오타 및 형식이 잘못된 값으로부터 보호하기 위해 매개 변수에 대한 기본 무결성 검사를 수행합니다. 이는 과거에 작동했던 일부 문제가 이제 경고를 발생시키고 내부 오류를 발생시킬 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6e814e2d111b3599c2bf1ca192478a3ffbfc4053" translate="yes" xml:space="preserve">
          <source>WriteMakefileSnippet ATTRIBUTE =&amp;gt; VALUE [, ...]</source>
          <target state="translated">WriteMakefileSnippet ATTRIBUTE =&amp;gt; VALUE [, ...]</target>
        </trans-unit>
        <trans-unit id="7bdbf771b888449a861406dd116d15dd91371055" translate="yes" xml:space="preserve">
          <source>Writes SIZE bytes from STRING to a memory segment at ADDR starting at position POS. If STRING is too long, only SIZE bytes are used; if STRING is too short, nulls are written to fill out SIZE bytes. Returns true if successful, or false if there is an error.</source>
          <target state="translated">위치 POS에서 시작하여 ADDR의 STRING에서 메모리 세그먼트로 SIZE 바이트를 씁니다. STRING이 너무 길면 SIZE 바이트 만 사용됩니다. STRING이 너무 짧은 경우 SIZE 바이트를 채우기 위해 널이 작성됩니다. 성공하면 true를, 오류가 있으면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5d0ca93d68b5dc214818ef186a1bc3e2b3d7c8cd" translate="yes" xml:space="preserve">
          <source>Writes a file of C code and a file of XS code which you should &lt;code&gt;#include&lt;/code&gt; and &lt;code&gt;INCLUDE&lt;/code&gt; in the C and XS sections respectively of your module's XS code. You probably want to do this in your &lt;code&gt;Makefile.PL&lt;/code&gt; , so that you can easily edit the list of constants without touching the rest of your module. The attributes supported are</source>
          <target state="translated">C 코드 파일과 XS 코드 파일을 작성합니다.이 코드는 모듈 XS 코드의 C 및 XS 섹션에 각각 &lt;code&gt;#include&lt;/code&gt; 및 &lt;code&gt;INCLUDE&lt;/code&gt; 해야 합니다. &lt;code&gt;Makefile.PL&lt;/code&gt; 에서이 작업을 수행하고 싶을 수 있으므로 나머지 모듈을 건드리지 않고 상수 목록을 쉽게 편집 할 수 있습니다. 지원되는 속성은</target>
        </trans-unit>
        <trans-unit id="68caf753088df284b27998c0bc22c79c995c9f8a" translate="yes" xml:space="preserve">
          <source>Writes a formatted record (possibly multi-line) to the specified FILEHANDLE, using the format associated with that file. By default the format for a file is the one having the same name as the filehandle, but the format for the current output channel (see the &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; function) may be set explicitly by assigning the name of the format to the &lt;code&gt;$~&lt;/code&gt; variable.</source>
          <target state="translated">해당 파일과 연관된 형식을 사용하여 형식이 지정된 레코드 (여러 행)를 지정된 FILEHANDLE에 씁니다. 기본적으로 파일의 형식은 파일 핸들과 이름이 같은 형식이지만, 현재 출력 채널의 형식 ( &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 기능 참조 )은 &lt;code&gt;$~&lt;/code&gt; 변수에 형식의 이름을 지정하여 명시 적으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3c8b534fc59790f52bbc323708c6a448e4336f1e" translate="yes" xml:space="preserve">
          <source>Writes a formatted record (possibly multi-line) to the specified FILEHANDLE, using the format associated with that file. By default the format for a file is the one having the same name as the filehandle, but the format for the current output channel (see the &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; function) may be set explicitly by assigning the name of the format to the &lt;code&gt;$~&lt;/code&gt; variable.</source>
          <target state="translated">해당 파일과 연관된 형식을 사용하여 형식이 지정된 레코드 (여러 행)를 지정된 FILEHANDLE에 씁니다. 기본적으로 파일의 형식은 파일 핸들과 이름이 같은 형식이지만, 현재 출력 채널의 형식 ( &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 기능 참조 )은 &lt;code&gt;$~&lt;/code&gt; 변수에 형식의 이름을 지정하여 명시 적으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e8961057173b914aa902d24e81d3c55d00dde52" translate="yes" xml:space="preserve">
          <source>Writes all files in and below the current directory to your</source>
          <target state="translated">현재 디렉토리 내외의 모든 파일을</target>
        </trans-unit>
        <trans-unit id="1ff3060cc065fe5dcf829a42d2a8d401fd64f6d8" translate="yes" xml:space="preserve">
          <source>Writes an empty FORCE: target.</source>
          <target state="translated">빈 FORCE : target을 씁니다.</target>
        </trans-unit>
        <trans-unit id="f5369d43b2f75bf65f1c9b2bf55177161b67ef85" translate="yes" xml:space="preserve">
          <source>Writes are permitted, i.e. opened as &quot;w&quot; or &quot;r+&quot; or &quot;a&quot;, etc.</source>
          <target state="translated">쓰기가 허용됩니다. 즉 &quot;w&quot;또는 &quot;r +&quot;또는 &quot;a&quot;로 열립니다.</target>
        </trans-unit>
        <trans-unit id="bc03658e3c61d9705d37afb50e35b60738df57d4" translate="yes" xml:space="preserve">
          <source>Writes the contents of &lt;code&gt;$buffer&lt;/code&gt; to the compressed file. Returns the number of bytes actually written, or 0 on error.</source>
          <target state="translated">&lt;code&gt;$buffer&lt;/code&gt; 의 내용을 압축 파일에 씁니다 . 실제로 쓴 바이트 수를 반환하거나 오류가 발생하면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3b30b2d9d9b94819a1a73fa66ad9fdb3aaf93cb5" translate="yes" xml:space="preserve">
          <source>Writes the file META.yml (YAML encoded meta-data) and META.json (JSON encoded meta-data) about the module in the distdir. The format follows Module::Build's as closely as possible.</source>
          <target state="translated">distdir의 모듈에 대한 파일 META.yml (YAML 인코딩 메타 데이터) 및 META.json (JSON 인코딩 메타 데이터)을 씁니다. 형식은 가능한 한 Module :: Build를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="759cd7af683913d2e067b4f6ffe525a9a1d4a391" translate="yes" xml:space="preserve">
          <source>Writes the file SIGNATURE with &quot;cpansign -s&quot;.</source>
          <target state="translated">SIGNATURE 파일을 &quot;cpansign -s&quot;로 작성합니다.</target>
        </trans-unit>
        <trans-unit id="284cf58439290385abdec38ca7c004471227b097" translate="yes" xml:space="preserve">
          <source>Writes the output of</source>
          <target state="translated">출력을 씁니다.</target>
        </trans-unit>
        <trans-unit id="fdd8d478482d63bc406cd41436757960d17780fb" translate="yes" xml:space="preserve">
          <source>Writing Accessors</source>
          <target state="translated">접근 자 작성</target>
        </trans-unit>
        <trans-unit id="1986c44b3bdced950b196d1c43f6cf37a6963d63" translate="yes" xml:space="preserve">
          <source>Writing Constructors</source>
          <target state="translated">작문 생성자</target>
        </trans-unit>
        <trans-unit id="ac0e44a3a37a4109877068f7584a4c6e490675d8" translate="yes" xml:space="preserve">
          <source>Writing Perl on an EBCDIC platform is really no different than writing on an &lt;a href=&quot;#ASCII&quot;&gt;ASCII&lt;/a&gt; one, but with different underlying numbers, as we'll see shortly. You'll have to know something about those &lt;a href=&quot;#ASCII&quot;&gt;ASCII&lt;/a&gt; platforms because the documentation is biased and will frequently use example numbers that don't apply to EBCDIC. There are also very few CPAN modules that are written for EBCDIC and which don't work on ASCII; instead the vast majority of CPAN modules are written for ASCII, and some may happen to work on EBCDIC, while a few have been designed to portably work on both.</source>
          <target state="translated">EBCDIC 플랫폼에서 Perl을 작성하는 것은 실제로 &lt;a href=&quot;#ASCII&quot;&gt;ASCII에서&lt;/a&gt; 작성하는 것과 다르지 않지만 곧 알 수 있듯이 기본 숫자가 다릅니다. 설명서가 편향되어 있고 EBCDIC에 적용되지 않는 예제 번호를 자주 사용하므로 &lt;a href=&quot;#ASCII&quot;&gt;ASCII&lt;/a&gt; 플랫폼 에 대해 알아야합니다 . EBCDIC 용으로 작성되었으며 ASCII에서 작동하지 않는 CPAN 모듈도 거의 없습니다. 대신 대부분의 CPAN 모듈은 ASCII 용으로 작성되었으며 일부는 EBCDIC에서 작동 할 수 있지만 일부는 두 가지 모두에서 이식 가능하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="b3e7a0572dc689213dcccc6f0ad9b2cbd894a46a" translate="yes" xml:space="preserve">
          <source>Writing Plugins</source>
          <target state="translated">플러그인 작성</target>
        </trans-unit>
        <trans-unit id="b23e7b02c4f050eb7a5f668109f71a414a28c33d" translate="yes" xml:space="preserve">
          <source>Writing Your Own Debugger</source>
          <target state="translated">자신의 디버거 작성</target>
        </trans-unit>
        <trans-unit id="12d7ef5d9c4d923fdecfc0a2ba03562ba21e7e82" translate="yes" xml:space="preserve">
          <source>Writing a Filter</source>
          <target state="translated">필터 작성</target>
        </trans-unit>
        <trans-unit id="7f135a17864ace6ae98bf7a3b9d9b4e20dd72358" translate="yes" xml:space="preserve">
          <source>Writing a module with MakeMaker</source>
          <target state="translated">MakeMaker로 모듈 작성</target>
        </trans-unit>
        <trans-unit id="f103eaa4bfb0cd111ad63870dfe99daf1dbfeefb" translate="yes" xml:space="preserve">
          <source>Writing a source filter as a separate executable works fine, but a small performance penalty is incurred. For example, if you execute the small example above, a separate subprocess will be created to run the Unix &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; command. Each use of the filter requires its own subprocess. If creating subprocesses is expensive on your system, you might want to consider one of the other options for creating source filters.</source>
          <target state="translated">소스 필터를 별도의 실행 파일로 작성하면 정상적으로 작동하지만 약간의 성능 저하가 발생합니다. 예를 들어, 위의 작은 예제를 실행하면 Unix &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; 명령 을 실행하기위한 별도의 하위 프로세스가 작성됩니다 . 필터를 사용할 때마다 자체 하위 프로세스가 필요합니다. 시스템에서 서브 프로세스 작성 비용이 비싸면 소스 필터 작성을위한 다른 옵션 중 하나를 고려할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc88b791ccf860fd9df472625687a215e4594f7f" translate="yes" xml:space="preserve">
          <source>Writing backticks in your program sends a clear message to the readers of your code that you wanted to collect the output of the command. Why send a clear message that isn't true?</source>
          <target state="translated">프로그램에 백틱을 쓰면 명령의 출력을 수집하려는 코드 독자에게 명확한 메시지를 보냅니다. 사실이 아닌 명확한 메시지를 보내는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="a44149bd1f420e38e67feec9febfbe47dcef5694" translate="yes" xml:space="preserve">
          <source>Writing good test scripts</source>
          <target state="translated">좋은 테스트 스크립트 작성</target>
        </trans-unit>
        <trans-unit id="0d1216f3de5359a11d177bd450454690960a8410" translate="yes" xml:space="preserve">
          <source>Writing subroutines</source>
          <target state="translated">서브 루틴 작성</target>
        </trans-unit>
        <trans-unit id="a553ca3bc37b04388da0cff3bc379f04cee8df42" translate="yes" xml:space="preserve">
          <source>Writing subroutines is easy:</source>
          <target state="translated">서브 루틴 작성은 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="c828d0e28e2f569743446e2de56ca66e456c09b7" translate="yes" xml:space="preserve">
          <source>Writing the patch</source>
          <target state="translated">패치 작성</target>
        </trans-unit>
        <trans-unit id="5c10b682e330dccc302170e80493f9eb65449a91" translate="yes" xml:space="preserve">
          <source>Writing the short option first is recommended because it's easier to read. The long option is long enough to draw the eye to it anyway and the short option can otherwise get lost in visual noise.</source>
          <target state="translated">읽기 쉬운 옵션이므로 짧은 옵션을 먼저 작성하는 것이 좋습니다. 긴 옵션은 어쨌든 시선을 끌 정도로 충분히 길며, 짧은 옵션은 시각적 노이즈에서 길을 잃을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b1d022be94ce5d1101d118c8c80cf3364019b48" translate="yes" xml:space="preserve">
          <source>Writing typemap Entries</source>
          <target state="translated">타입 맵 항목 작성</target>
        </trans-unit>
        <trans-unit id="1292edaa487b14cb74f82d4343628858075e0756" translate="yes" xml:space="preserve">
          <source>Wrong: the Storable engine creates an empty one for you. If you know Eiffel, you can view &lt;code&gt;STORABLE_thaw&lt;/code&gt; as an alternate creation routine.</source>
          <target state="translated">잘못됨 : 저장 가능 엔진이 비어 있습니다. Eiffel을 알고 있다면 &lt;code&gt;STORABLE_thaw&lt;/code&gt; 를 대체 작성 루틴으로 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="7a5fc108bfdd5d96d6f99a6eac89c9af874db7d8" translate="yes" xml:space="preserve">
          <source>XPG operability often implies the presence of an</source>
          <target state="translated">XPG 조작성은 종종</target>
        </trans-unit>
        <trans-unit id="0f082b9799dcb8475e7d6fcb04a5adfa774635d5" translate="yes" xml:space="preserve">
          <source>XPUSH args AND set RETVAL AND assign return value to array</source>
          <target state="translated">XPUSH 인수 및 RETVAL 설정 및 반환 값을 배열에 할당</target>
        </trans-unit>
        <trans-unit id="bdb1d0d2760db0ae33b02dff5258e945e708b990" translate="yes" xml:space="preserve">
          <source>XS</source>
          <target state="translated">XS</target>
        </trans-unit>
        <trans-unit id="92bd1887109d3a53eb97d00630c2016c2f9abe52" translate="yes" xml:space="preserve">
          <source>XS VERSION</source>
          <target state="translated">XS 버전</target>
        </trans-unit>
        <trans-unit id="f150c9e4da4e74cdaf804a24288dd2d36c2aab56" translate="yes" xml:space="preserve">
          <source>XS code added by Greg Bacon &amp;lt;</source>
          <target state="translated">Greg Bacon이 추가 한 XS 코드 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="1cf142c571c2183260c4664ac183845da5980944" translate="yes" xml:space="preserve">
          <source>XS code can usually be made to work with any platform, but dependent libraries, header files, etc., might not be readily available or portable, or the XS code itself might be platform-specific, just as Perl code might be. If the libraries and headers are portable, then it is normally reasonable to make sure the XS code is portable, too.</source>
          <target state="translated">XS 코드는 일반적으로 모든 플랫폼에서 작동하도록 만들 수 있지만 Perl 코드와 마찬가지로 종속 라이브러리, 헤더 파일 등을 쉽게 구할 수 없거나 이식성이 없거나 XS 코드 자체가 플랫폼에 따라 다를 수 있습니다. 라이브러리와 헤더가 이식 가능한 경우 XS 코드도 이식 가능한지 확인하는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="7e8ccd1927a425f4cd71fc5858f4ce61be503a94" translate="yes" xml:space="preserve">
          <source>XS code for using native C functions borrowed from &lt;code&gt;&lt;a href=&quot;http://search.cpan.org/perldoc/Unix::Syslog&quot;&gt;Unix::Syslog&lt;/a&gt;&lt;/code&gt;, written by Marcus Harnisch &amp;lt;</source>
          <target state="translated">Marcus Harnisch가 작성한 &lt;code&gt;&lt;a href=&quot;http://search.cpan.org/perldoc/Unix::Syslog&quot;&gt;Unix::Syslog&lt;/a&gt;&lt;/code&gt; 에서 빌린 네이티브 C 함수를 사용하기위한 XS 코드 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="fe30568ef2d4c300e100572dbcce63bef5e87790" translate="yes" xml:space="preserve">
          <source>XS code has full access to system calls including C library functions. It thus has the capability of interfering with things that the Perl core or other modules have set up, such as signal handlers or file handles. It could mess with the memory, or any number of harmful things. Don't.</source>
          <target state="translated">XS 코드는 C 라이브러리 함수를 포함한 시스템 호출에 대한 모든 액세스 권한을 갖습니다. 따라서 신호 처리기 또는 파일 핸들과 같은 Perl 코어 또는 기타 모듈에서 설정 한 사항을 방해 할 수 있습니다. 메모리 나 여러 가지 유해한 요소를 망칠 수 있습니다. 하지마</target>
        </trans-unit>
        <trans-unit id="33d48b61f9e9a038a7aea1ef00483763c58f6eff" translate="yes" xml:space="preserve">
          <source>XS code is probably better using &quot;typemap&quot; if it expects FILE * arguments. The standard typemap will be adjusted to comprehend any changes in this area.</source>
          <target state="translated">XS 코드는 FILE * 인수가 필요한 경우 &quot;typemap&quot;을 사용하는 것이 좋습니다. 이 영역의 모든 변경 사항을 이해하기 위해 표준 유형 맵이 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="89e8c193e223b649f3d44b4194d19ce56bb23e01" translate="yes" xml:space="preserve">
          <source>XS code is very sensitive to the module version number and will complain if the version number in your Perl module doesn't match. If you change your module's version # without rerunning Makefile.PL the old version number will remain in the Makefile, causing the XS code to be built with the wrong number.</source>
          <target state="translated">XS 코드는 모듈 버전 번호에 매우 민감하며 Perl 모듈의 버전 번호가 일치하지 않으면 불평합니다. Makefile.PL을 다시 실행하지 않고 모듈의 버전 번호를 변경하면 이전 버전 번호가 Makefile에 남아 XS 코드가 잘못된 번호로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="def563b19b3d7a04b960dc4d401ac89d52a4e717" translate="yes" xml:space="preserve">
          <source>XS is an interface description file format used to create an extension interface between Perl and C code (or a C library) which one wishes to use with Perl. The XS interface is combined with the library to create a new library which can then be either dynamically loaded or statically linked into perl. The XS interface description is written in the XS language and is the core component of the Perl extension interface.</source>
          <target state="translated">XS는 Perl과 함께 사용하고자하는 Perl과 C 코드 (또는 C 라이브러리) 사이의 확장 인터페이스를 작성하는 데 사용되는 인터페이스 설명 파일 형식입니다. XS 인터페이스는 라이브러리와 결합되어 새 라이브러리를 생성 한 다음 동적으로로드하거나 정적으로 펄에 링크 할 수 있습니다. XS 인터페이스 설명은 XS 언어로 작성되었으며 Perl 확장 인터페이스의 핵심 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="c6e0da0571ab8b6cd13332fb1b92e13ef69723c3" translate="yes" xml:space="preserve">
          <source>XS modules for all categories but &lt;code&gt;LC_NUMERIC&lt;/code&gt; get the underlying locale, and hence any C library functions they call will use that underlying locale. For more discussion, see &lt;a href=&quot;perlxs#CAVEATS&quot;&gt;CAVEATS in perlxs&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;LC_NUMERIC&lt;/code&gt; 을 제외한 모든 범주의 XS 모듈 은 기본 로캘을 가져 오므로 호출하는 모든 C 라이브러리 함수는 해당 기본 로캘을 사용합니다. 자세한 내용 &lt;a href=&quot;perlxs#CAVEATS&quot;&gt;은 perlxs의주의 사항을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cde8f9f4aa7dc1d35b0c98fee87c3ff3dfbc220c" translate="yes" xml:space="preserve">
          <source>XS-type modules do require re-linking the perl binary, because part of an XS module is written in &quot;C&quot;, and has to be linked together with the perl binary to be executed. This is required because perl under DJGPP is built with the &quot;static link&quot; option, due to the lack of &quot;dynamic linking&quot; in the DJGPP environment.</source>
          <target state="translated">XS- 타입 모듈은 perl 바이너리를 다시 연결해야합니다. XS 모듈의 일부는 &quot;C&quot;로 작성되고 실행되는 perl 바이너리와 함께 연결되어야하기 때문입니다. 이는 DJGPP 환경에서 &quot;동적 연결&quot;이 없기 때문에 DJGPP의 perl이 &quot;정적 연결&quot;옵션으로 구축되기 때문에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="69f57ba624b38c0aa8389aea0ffe9fd217df0165" translate="yes" xml:space="preserve">
          <source>XSLoader</source>
          <target state="translated">XSLoader</target>
        </trans-unit>
        <trans-unit id="afd8fa1c6f48c528375edb581b5cfae64284c5a7" translate="yes" xml:space="preserve">
          <source>XSLoader - Dynamically load C libraries into Perl code</source>
          <target state="translated">XSLoader-C 라이브러리를 Perl 코드에 동적으로로드</target>
        </trans-unit>
        <trans-unit id="4579138c9695c3de09b5142af11ef81d8446e749" translate="yes" xml:space="preserve">
          <source>XSUB.h</source>
          <target state="translated">XSUB.h</target>
        </trans-unit>
        <trans-unit id="4df5cfe3d83127b158a7d5a161b5570785b675ad" translate="yes" xml:space="preserve">
          <source>XSUBs and the Argument Stack</source>
          <target state="translated">XSUB와 인수 스택</target>
        </trans-unit>
        <trans-unit id="3b5999991ea7d60b38c8ca1802a3aa2e3198b825" translate="yes" xml:space="preserve">
          <source>XSUBs are also allowed to avoid automatic conversion of Perl function arguments to C function arguments. See &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for details. Some people prefer manual conversion by inspecting &lt;code&gt;ST(i)&lt;/code&gt; even in the cases when automatic conversion will do, arguing that this makes the logic of an XSUB call clearer. Compare with &lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;Getting the fat out of XSUBs&lt;/a&gt; for a similar tradeoff of a complete separation of &quot;Perl glue&quot; and &quot;workhorse&quot; parts of an XSUB.</source>
          <target state="translated">XSUB는 또한 Perl 함수 인수가 C 함수 인수로 자동 변환되는 것을 피할 수 있습니다. 자세한 내용은 &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; 를 참조하십시오. 일부 사람들은 자동 변환이 수행되는 경우에도 &lt;code&gt;ST(i)&lt;/code&gt; 를 검사하여 수동 변환을 선호 하므로 XSUB 호출의 논리가 더 명확 해집니다. &lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;XSUB&lt;/a&gt; 의 &quot;Perl glue&quot;와 &quot;workhorse&quot;부분을 완전히 분리하는 것과 유사한 트레이드 오프 를 얻으려면 XSUB에서 지방 제거하기 와 비교하십시오 .</target>
        </trans-unit>
        <trans-unit id="54080bcfea2adf5c913b064ead22f355c2ce0033" translate="yes" xml:space="preserve">
          <source>XSUBs are also allowed to return lists, not just scalars. This must be done by manipulating stack values ST(0), ST(1), etc, in a subtly different way. See &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for details.</source>
          <target state="translated">XSUB는 스칼라뿐만 아니라 목록을 리턴 할 수도 있습니다. 이는 스택 값 ST (0), ST (1) 등을 미묘하게 다른 방식으로 조작하여 수행해야합니다. 자세한 내용은 &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="88b3157d6a7563b7eeae312db4f170271aab7d57" translate="yes" xml:space="preserve">
          <source>XSUBs can have variable-length parameter lists by specifying an ellipsis &lt;code&gt;(...)&lt;/code&gt; in the parameter list. This use of the ellipsis is similar to that found in ANSI C. The programmer is able to determine the number of arguments passed to the XSUB by examining the &lt;code&gt;items&lt;/code&gt; variable which the &lt;b&gt;xsubpp&lt;/b&gt; compiler supplies for all XSUBs. By using this mechanism one can create an XSUB which accepts a list of parameters of unknown length.</source>
          <target state="translated">XSUB는 매개 변수 목록에서 줄임표 &lt;code&gt;(...)&lt;/code&gt; 를 지정하여 가변 길이 매개 변수 목록을 가질 수 있습니다 . 생략 부호의 사용은 ANSI C에있는 것과 유사합니다. 프로그래머는 &lt;b&gt;xsubpp&lt;/b&gt; 컴파일러가 모든 XSUB에 제공 하는 &lt;code&gt;items&lt;/code&gt; 변수를 검사하여 XSUB에 전달 된 인수 수를 판별 할 수 있습니다. 이 메커니즘을 사용하면 알 수없는 길이의 매개 변수 목록을 허용하는 XSUB를 만들 수 있습니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3f2e0ddc3d17d87460a2a8a983be1c97c83b73d1" translate="yes" xml:space="preserve">
          <source>XSUBs do not have a CvPADLIST. dXSTARG fetches values from PL_curpad, but that is really the callers pad (a slot of which is allocated by every entersub). Do not get or set CvPADLIST if a CV is an XSUB (as determined by &lt;code&gt;CvISXSUB()&lt;/code&gt; ), CvPADLIST slot is reused for a different internal purpose in XSUBs.</source>
          <target state="translated">XSUB에는 CvPADLIST가 없습니다. dXSTARG는 PL_curpad에서 값을 가져 오지만 실제로는 호출자 패드입니다 (슬롯이 모든 entersub에 의해 할당 됨). CV가 XSUB ( &lt;code&gt;CvISXSUB()&lt;/code&gt; 의해 결정됨) 인 경우 CvPADLIST를 가져 오거나 설정하지 마십시오 . CvPADLIST 슬롯은 XSUB에서 다른 내부 목적으로 재사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6daf3f5f97a3cf191b47d0b650ffb497515d3ee1" translate="yes" xml:space="preserve">
          <source>XSUBs refer to their stack arguments with the macro &lt;b&gt;ST(x)&lt;/b&gt;, where</source>
          <target state="translated">XSUB는 매크로 &lt;b&gt;ST (x)로&lt;/b&gt; 스택 인수를 참조합니다 . 여기서</target>
        </trans-unit>
        <trans-unit id="45e92c706e14fc42e8a65549cfb504f51b80720e" translate="yes" xml:space="preserve">
          <source>XS_DEFINE_VERSION: -D line to set the xs version when compiling.</source>
          <target state="translated">XS_DEFINE_VERSION : 컴파일 할 때 xs 버전을 설정하는 -D 행.</target>
        </trans-unit>
        <trans-unit id="0b91e170805a05f3fc3b4f1fe3e1c801a51a5cd9" translate="yes" xml:space="preserve">
          <source>XS_FILE</source>
          <target state="translated">XS_FILE</target>
        </trans-unit>
        <trans-unit id="c30e58ff83929eb55292bc3f56bfb117c5d6b82f" translate="yes" xml:space="preserve">
          <source>XS_SUBNAME</source>
          <target state="translated">XS_SUBNAME</target>
        </trans-unit>
        <trans-unit id="f6c7bf9f42bb6c2a25e194ec60219f0a8150edce" translate="yes" xml:space="preserve">
          <source>XS_VERSION: version in your .xs file. Defaults to $(VERSION)</source>
          <target state="translated">XS_VERSION : .xs 파일의 버전입니다. 기본적으로 $ (VERSION)</target>
        </trans-unit>
        <trans-unit id="53fccca1190b204bd667ec9d6791fd3b9d14df6c" translate="yes" xml:space="preserve">
          <source>XS_VERSION_MACRO: which macro represents the XS version.</source>
          <target state="translated">XS_VERSION_MACRO : XS 버전을 나타내는 매크로입니다.</target>
        </trans-unit>
        <trans-unit id="20026dc165c030fe3a5d9609a6e61ab26210cbc1" translate="yes" xml:space="preserve">
          <source>XX</source>
          <target state="translated">XX</target>
        </trans-unit>
        <trans-unit id="a9674b19f8c56f785c91a555d0a144522bb318e6" translate="yes" xml:space="preserve">
          <source>XXX</source>
          <target state="translated">XXX</target>
        </trans-unit>
        <trans-unit id="efc0ac66700effcf3b5c6d5cfb0d3ed1e5da5cc1" translate="yes" xml:space="preserve">
          <source>XXX DAPM it would make more sense to make the arg a PADOFFSET void SAVEPADSV(PADOFFSET po)</source>
          <target state="translated">XXX DAPM arg를 PADOFFSET void SAVEPADSV (PADOFFSET po)로 만드는 것이 더 합리적입니다.</target>
        </trans-unit>
        <trans-unit id="0a8c3822391bb958edc27b75e5a6c90f50363bce" translate="yes" xml:space="preserve">
          <source>XXX.</source>
          <target state="translated">XXX.</target>
        </trans-unit>
        <trans-unit id="759d5f762181a933d7c0ff7fd8096838ff6b5ec3" translate="yes" xml:space="preserve">
          <source>XXX: Needs more docs.</source>
          <target state="translated">XXX : 더 많은 문서가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e3a8809017dd76bd26557a5b923ab2ae16c0cdb3" translate="yes" xml:space="preserve">
          <source>XXXX</source>
          <target state="translated">XXXX</target>
        </trans-unit>
        <trans-unit id="23eb4d3f4155395a74e9d534f97ff4c1908f5aac" translate="yes" xml:space="preserve">
          <source>Y</source>
          <target state="translated">Y</target>
        </trans-unit>
        <trans-unit id="50bc04e009ed4a61bc2c2e4c00258238b3cec732" translate="yes" xml:space="preserve">
          <source>YAML result token.</source>
          <target state="translated">YAML 결과 토큰.</target>
        </trans-unit>
        <trans-unit id="bf4ca579becca81a75bf09eee1a917765b24f975" translate="yes" xml:space="preserve">
          <source>YMMV.</source>
          <target state="translated">YMMV.</target>
        </trans-unit>
        <trans-unit id="9a8fc610a3168e82e07390203ce40d7382c7da6f" translate="yes" xml:space="preserve">
          <source>YYYY-MM-DDThh:mm:ss</source>
          <target state="translated">YYYY-MM-DDThh:mm:ss</target>
        </trans-unit>
        <trans-unit id="76ac22fb38468218ad6552d9043d5bb2c7920d48" translate="yes" xml:space="preserve">
          <source>Year Value Interpretation</source>
          <target state="translated">연도 가치 해석</target>
        </trans-unit>
        <trans-unit id="44f6289f7e3326b30824a187cdb204e4dc7264b2" translate="yes" xml:space="preserve">
          <source>Years greater than 999 are interpreted as being the actual year, rather than the offset from 1900. Thus, 1964 would indicate the year Martin Luther King won the Nobel prize, not the year 3864.</source>
          <target state="translated">999 년보다 큰 연도는 1900 년의 상쇄가 아니라 실제 연도로 해석됩니다. 따라서 1964 년은 마틴 루터 킹이 3864 년이 아니라 노벨상을 수상한 연도를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c9ec20e90ee8369d4a4738a1355fc718ca45a57e" translate="yes" xml:space="preserve">
          <source>Years in the range 0..99 are interpreted as shorthand for years in the rolling &quot;current century,&quot; defined as 50 years on either side of the current year. Thus, today, in 1999, 0 would refer to 2000, and 45 to 2045, but 55 would refer to 1955. Twenty years from now, 55 would instead refer to 2055. This is messy, but matches the way people currently think about two digit dates. Whenever possible, use an absolute four digit year instead.</source>
          <target state="translated">0..99 범위의 연도는 현재 연도의 양쪽에서 50 년으로 정의 된 롤링 &quot;현재 세기&quot;에서 연도의 약어로 해석됩니다. 따라서 오늘날 1999 년에 0은 2000을, 45는 2045를, 55는 1955를 가리 킵니다. 20 년이 지난 지금 55는 2055를 가리 킵니다. 이것은 지저분하지만 사람들이 현재 두 가지에 대해 생각하는 방식과 일치합니다. 숫자 날짜. 가능할 때마다 절대 4 자리 연도를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="862a9bbc8aa08db48d5ef905c8dc85be457e6ea8" translate="yes" xml:space="preserve">
          <source>Years in the range 100..999 are interpreted as offset from 1900, so that 112 indicates 2012. This rule also applies to years less than zero (but see note below regarding date range).</source>
          <target state="translated">100..999 범위의 연도는 1900에서 오프셋으로 해석되므로 112는 2012를 나타냅니다.이 규칙은 0보다 작은 연도에도 적용됩니다 (그러나 날짜 범위에 대해서는 아래 참고 참조).</target>
        </trans-unit>
        <trans-unit id="dfc439a506f8ca9ae872d5d02c2ad4c82b034c13" translate="yes" xml:space="preserve">
          <source>Yes it is, see previous answer. Since &lt;code&gt;Compress::Zlib&lt;/code&gt; and therefore &lt;code&gt;IO::Zlib&lt;/code&gt; doesn't support &lt;code&gt;&lt;a href=&quot;../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; on their filehandles, there is little choice but to read the archive into memory. This is ok if you want to do in-memory manipulation of the archive.</source>
          <target state="translated">예, 이전 답변을 참조하십시오. 이후 &lt;code&gt;Compress::Zlib&lt;/code&gt; 따라서 &lt;code&gt;IO::Zlib&lt;/code&gt; 지원하지 않는 &lt;code&gt;&lt;a href=&quot;../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 자신의 파일 핸들에가, 선택의 여지가 있지만, 메모리에 아카이브를 읽을 수 있습니다. 아카이브의 메모리 내 조작을 원한다면 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="acb5099459bfa43931dd4b78a628e1d113168a69" translate="yes" xml:space="preserve">
          <source>Yes it is. It's pure perl, so it's a lot slower then your &lt;code&gt;/bin/tar&lt;/code&gt; However, it's very portable. If speed is an issue, consider using &lt;code&gt;/bin/tar&lt;/code&gt; instead.</source>
          <target state="translated">네 그렇습니다. 순수한 펄이므로 &lt;code&gt;/bin/tar&lt;/code&gt; 보다 훨씬 느리지 만 이식성이 뛰어납니다. 속도가 문제라면 &lt;code&gt;/bin/tar&lt;/code&gt; 를 대신 사용해보십시오.</target>
        </trans-unit>
        <trans-unit id="4107dbe8a030ec286ba38d4f763957128d667542" translate="yes" xml:space="preserve">
          <source>Yes, it does</source>
          <target state="translated">예, 그렇습니다</target>
        </trans-unit>
        <trans-unit id="3678471c058284ba4000bf6331c346c6bbd02a28" translate="yes" xml:space="preserve">
          <source>Yes, that's a lot of expansion.</source>
          <target state="translated">예, 그것은 많은 확장입니다.</target>
        </trans-unit>
        <trans-unit id="eb5a8cd62389870da5aba481f01f1a18a4a6e511" translate="yes" xml:space="preserve">
          <source>Yes, there's a lot of that :-) But more precisely, in UNIX systems there's a utility called &lt;code&gt;file&lt;/code&gt; , which recognizes data files based on their contents (usually their first few bytes). For this to work, a certain file called</source>
          <target state="translated">예, 많은 것들이 있습니다 :-) 그러나 더 정확하게는 UNIX 시스템에는 &lt;code&gt;file&lt;/code&gt; (이것은 일반적으로 처음 몇 바이트)을 기반으로 데이터 파일을 인식하는 file 이라는 유틸리티가 있습니다 . 이것이 작동하려면 특정 파일이</target>
        </trans-unit>
        <trans-unit id="dc1e472e45c46619f7f9549ce98213f0173da937" translate="yes" xml:space="preserve">
          <source>Yes, you can do this by either using the &lt;code&gt;-T&lt;/code&gt; option, or by invoking the program as &lt;code&gt;perlthanks&lt;/code&gt; . Thank-you notes are good. It makes people smile.</source>
          <target state="translated">예, &lt;code&gt;-T&lt;/code&gt; 옵션을 사용하거나 프로그램을 &lt;code&gt;perlthanks&lt;/code&gt; 로 호출 하여이를 수행 할 수 있습니다 . 감사 노트가 좋습니다. 사람들을 웃게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="2c8d0f90fcceba5d3649946cef16ef6f0de57be0" translate="yes" xml:space="preserve">
          <source>Yes, you can! If your sources are UTF-8 encoded, you can indicate that with the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; pragma.</source>
          <target state="translated">그래 넌 할수있어! 소스가 UTF-8로 인코딩 된 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; pragma를 사용 하여 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd3c0b60626749e4fb04200f5ac37da9c3ba6f91" translate="yes" xml:space="preserve">
          <source>Yes, you could probably do the same thing with code like $token-&amp;gt;isa('Pod::Simple::PullParserEndToken'), but that's not so pretty as using just $token-&amp;gt;type, or even the following shortcuts:</source>
          <target state="translated">예, 아마도 $ token-&amp;gt; isa ( 'Pod :: Simple :: PullParserEndToken')와 같은 코드로 똑같은 일을 할 수는 있지만 $ token-&amp;gt; type 또는 다음 단축키를 사용하는 것만 큼 좋지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="9ba10bd10462c10515a891999d5f144a0ef8db84" translate="yes" xml:space="preserve">
          <source>Yes. If you are building a web site with any level of interactivity (forms / users / databases), you will want to use a framework to make handling requests and responses easier.</source>
          <target state="translated">예. 대화 형 수준 (양식 / 사용자 / 데이터베이스)이있는 웹 사이트를 구축하는 경우 프레임 워크를 사용하여 요청 및 응답을보다 쉽게 ​​처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="4131deed69500e1ce76a1aa4746c5be5d04540cb" translate="yes" xml:space="preserve">
          <source>Yes. Perl's garbage collection system takes care of this so everything works out right.</source>
          <target state="translated">예. Perl의 가비지 수집 시스템이이를 처리하므로 모든 것이 올바르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="3a7fae4176564291917eb6c0f952942b7ae63ec5" translate="yes" xml:space="preserve">
          <source>Yes. Read &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; for more information. Some examples follow. (These assume standard Unix shell quoting rules.)</source>
          <target state="translated">예. 자세한 정보는 &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; 을 읽으십시오 . 다음은 몇 가지 예입니다. (이것들은 표준 유닉스 쉘 인용 규칙을 가정합니다.)</target>
        </trans-unit>
        <trans-unit id="85739d75a309637ea84dea150d48798fe5f385f6" translate="yes" xml:space="preserve">
          <source>Yet Another Compiler Compiler. A parser generator without which Perl probably would not have existed. See the file</source>
          <target state="translated">또 다른 컴파일러 컴파일러. 펄이없는 파서 생성기는 아마도 존재하지 않았을 것이다. 파일보기</target>
        </trans-unit>
        <trans-unit id="7fafe5e36aa3122413d32c6d4c8b4284bb245038" translate="yes" xml:space="preserve">
          <source>Yet another capturing group numbering technique (also as from Perl 5.10) deals with the problem of referring to groups within a set of alternatives. Consider a pattern for matching a time of the day, civil or military style:</source>
          <target state="translated">또 다른 캡처 그룹 번호 매기기 기술 (또한 Perl 5.10에서)은 일련의 대안 내에서 그룹을 참조하는 문제를 처리합니다. 하루 중 시간, 시민 또는 군대 스타일을 일치시키는 패턴을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="a23e788a3e5975e13dc401fc7dc400a7d94469f5" translate="yes" xml:space="preserve">
          <source>Yet another framework for writing test scripts</source>
          <target state="translated">테스트 스크립트 작성을위한 또 다른 프레임 워크</target>
        </trans-unit>
        <trans-unit id="50d7418e5885441f0de4ccbd54d601d8993cfb34" translate="yes" xml:space="preserve">
          <source>Yet another pseudo-class that NEXT.pm provides is &lt;code&gt;EVERY&lt;/code&gt; . Its behaviour is considerably simpler than that of the &lt;code&gt;NEXT&lt;/code&gt; family. A call to:</source>
          <target state="translated">NEXT.pm이 제공하는 또 다른 의사 클래스는 &lt;code&gt;EVERY&lt;/code&gt; 입니다. 그 동작은 &lt;code&gt;NEXT&lt;/code&gt; 제품군 보다 훨씬 간단 합니다. 전화 :</target>
        </trans-unit>
        <trans-unit id="807fa18eacfa8333a4615b7233d28577520ce46b" translate="yes" xml:space="preserve">
          <source>Yet another way is to assign to a &lt;code&gt;foreach&lt;/code&gt; loop</source>
          <target state="translated">또 다른 방법은 &lt;code&gt;foreach&lt;/code&gt; 루프 에 할당하는 것입니다</target>
        </trans-unit>
        <trans-unit id="fb6a80ccd3cd48516fa10f2b5e43ec6135ec9451" translate="yes" xml:space="preserve">
          <source>Yet another way would be to use the Devel::Peek module:</source>
          <target state="translated">또 다른 방법은 Devel :: Peek 모듈을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c970e3f1e790a2a4cd28b40401902501b9bc2d74" translate="yes" xml:space="preserve">
          <source>Yields:</source>
          <target state="translated">Yields:</target>
        </trans-unit>
        <trans-unit id="f551936e2c614f3a2dff9203d64b57c373086792" translate="yes" xml:space="preserve">
          <source>You &lt;b&gt;do not&lt;/b&gt; call &lt;code&gt;setlogsock&lt;/code&gt; .</source>
          <target state="translated">당신은 &lt;b&gt;하지 않는&lt;/b&gt; 전화 &lt;code&gt;setlogsock&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="adc6962b12f722ff929475c965699bd91420b623" translate="yes" xml:space="preserve">
          <source>You &lt;b&gt;must&lt;/b&gt; convert characters to UVs using the above functions if you're ever in a situation where you have to match UTF-8 and non-UTF-8 characters. You may not skip over UTF-8 characters in this case. If you do this, you'll lose the ability to match hi-bit non-UTF-8 characters; for instance, if your UTF-8 string contains &lt;code&gt;v196.172&lt;/code&gt; , and you skip that character, you can never match a &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(200)&lt;/a&gt;&lt;/code&gt; in a non-UTF-8 string. So don't do that!</source>
          <target state="translated">당신은 &lt;b&gt;있어야&lt;/b&gt; 당신이 UTF-8 및 UTF-8이 아닌 문자와 일치 할 필요가 어디 상황에서 이제까지 인 경우 위의 기능을 사용하여의 UV로 문자를 변환합니다. 이 경우 UTF-8 문자를 건너 뛸 수 없습니다. 이 작업을 수행하면 UTF-8 비 UTF-8 문자를 일치시키는 기능이 손실됩니다. 예를 들어, UTF-8 문자열에 &lt;code&gt;v196.172&lt;/code&gt; 가 포함되어 있고 해당 문자를 건너 뛰는 경우 비 UTF-8 문자열에서 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(200)&lt;/a&gt;&lt;/code&gt; 과 일치시킬 수 없습니다 . 그러지 마!</target>
        </trans-unit>
        <trans-unit id="84f6ab55499a431ab963225e1b323e598c043cac" translate="yes" xml:space="preserve">
          <source>You &lt;b&gt;must&lt;/b&gt; have the BFD (-lbfd) library installed, otherwise &lt;code&gt;perl&lt;/code&gt; will fail to link. The BFD is usually distributed as part of the GNU binutils.</source>
          <target state="translated">당신은 &lt;b&gt;해야한다&lt;/b&gt; , 설치 BFD (-lbfd) 라이브러리가 다른 &lt;code&gt;perl&lt;/code&gt; 링크에 실패합니다. BFD는 일반적으로 GNU binutils의 일부로 배포됩니다.</target>
        </trans-unit>
        <trans-unit id="b5fb57ccedc3fdf63890d16c6dbd3e60731ff70f" translate="yes" xml:space="preserve">
          <source>You CAN say</source>
          <target state="translated">당신은 말할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="f4ab9d853c38812e284656a7bf6f62a6214856cd" translate="yes" xml:space="preserve">
          <source>You already learned that a &lt;b&gt;method&lt;/b&gt; is a subroutine that operates on an object. You can think of a method as the things that an object can</source>
          <target state="translated">&lt;b&gt;메소드&lt;/b&gt; 는 오브젝트에서 작동하는 서브 루틴이라는 것을 이미 알고 있습니다. 메소드를 객체가 할 수있는 것으로 생각할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="9a0c2a8aac855d59d1e419df17c0d8362fab4ef6" translate="yes" xml:space="preserve">
          <source>You also cannot exit out of the sort block or subroutine using any of the loop control operators described in &lt;a href=&quot;../perlsyn&quot;&gt;perlsyn&lt;/a&gt; or with &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">또한 &lt;a href=&quot;../perlsyn&quot;&gt;perlsyn&lt;/a&gt; 또는 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 에 설명 된 루프 제어 연산자를 사용하여 정렬 블록 또는 서브 루틴을 종료 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="cce8f481cd5c5e068e4367b0b286efd66e3e8b5e" translate="yes" xml:space="preserve">
          <source>You also cannot exit out of the sort block or subroutine using any of the loop control operators described in &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt; or with &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">또한 &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 에 설명 된 루프 제어 연산자를 사용하여 정렬 블록 또는 서브 루틴을 종료 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="6462e3c6fa18441789982aade2cc057d4a5754fa" translate="yes" xml:space="preserve">
          <source>You also don't have to use push(). You could just make a direct assignment if you knew where you wanted to put it:</source>
          <target state="translated">push ()를 사용할 필요도 없습니다. 어디에 배치하고 싶은지 알고 있다면 직접 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="762d8de62e5184e1ddd3f7df62b51251838a45ad" translate="yes" xml:space="preserve">
          <source>You also have to be careful about context. You can assign an array to a scalar to get the number of elements in the array. This only works for arrays, though:</source>
          <target state="translated">또한 상황에주의해야합니다. 배열의 요소 수를 얻기 위해 배열을 스칼라에 할당 할 수 있습니다. 그러나 배열에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e9900e6006f63d330e774e6c340305cdfb9e9fa2" translate="yes" xml:space="preserve">
          <source>You also need dmake. See &lt;a href=&quot;#Make&quot;&gt;Make&lt;/a&gt; above on how to get it.</source>
          <target state="translated">또한 dmake가 필요합니다. 얻는 방법에 대해서는 위의 &lt;a href=&quot;#Make&quot;&gt;확인을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ad4cae9e1d17ccae297619ff7a90fc58163adef4" translate="yes" xml:space="preserve">
          <source>You are allowed to use underscores (underbars) in numeric literals between digits for legibility (but not multiple underscores in a row: &lt;code&gt;23__500&lt;/code&gt; is not legal; &lt;code&gt;23_500&lt;/code&gt; is). You could, for example, group binary digits by threes (as for a Unix-style mode argument such as 0b110_100_100) or by fours (to represent nibbles, as in 0b1010_0110) or in other groups.</source>
          <target state="translated">가독성을 위해 숫자 사이의 숫자 리터럴에 밑줄 (밑줄)을 사용할 수 있습니다 (단, 여러 개의 밑줄 은 사용할 수 없습니다 : &lt;code&gt;23__500&lt;/code&gt; 은 유효하지 않습니다; &lt;code&gt;23_500&lt;/code&gt; 은 유효합니다 ). 예를 들어, 이진수를 3 (0b110_100_100과 같은 유닉스 스타일 모드 인수의 경우) 또는 4 (0b1010_0110에서와 같이 니블을 나타 내기 위해) 또는 다른 그룹으로 그룹화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9086be8aa3acbf107ed69aa30ed1efd2e29806d" translate="yes" xml:space="preserve">
          <source>You are chdir()'d to &lt;code&gt;$File::Find::dir&lt;/code&gt; when the function is called, unless &lt;code&gt;no_chdir&lt;/code&gt; was specified. Note that when changing to directories is in effect the root directory (</source>
          <target state="translated">&lt;code&gt;no_chdir&lt;/code&gt; 이 지정 되지 않은 경우 함수가 호출 될 때 chdir ()이 &lt;code&gt;$File::Find::dir&lt;/code&gt; 있습니다. 디렉토리로 변경하면 사실상 루트 디렉토리 (</target>
        </trans-unit>
        <trans-unit id="765a24f0e7b225890131f993a03189d4db8249a5" translate="yes" xml:space="preserve">
          <source>You are either using a copy of zlib that is older than version 1.2.0 or you want your application code to be able to run with as many different versions of zlib as possible.</source>
          <target state="translated">버전 1.2.0 이전의 zlib 사본을 사용 중이거나 응용 프로그램 코드가 가능한 많은 다른 버전의 zlib와 함께 실행될 수 있기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="a13d801950c0dc8ed9906d27d14a9952af5a263a" translate="yes" xml:space="preserve">
          <source>You are encouraged to participate in the discussion and advocate for your patch. Sometimes your patch may get lost in the shuffle. It's appropriate to send a reminder email to p5p if no action has been taken in a month. Please remember that the Perl 5 developers are all volunteers, and be polite.</source>
          <target state="translated">토론에 참여하고 패치를 옹호하는 것이 좋습니다. 때때로 셔플에서 패치가 손실 될 수 있습니다. 한 달 동안 아무런 조치를 취하지 않은 경우 p5p로 알림 이메일을 보내는 것이 좋습니다. Perl 5 개발자는 모두 자원 봉사자이며 예의 바르게 행동하십시오.</target>
        </trans-unit>
        <trans-unit id="719d41b23df4f3bd674c48a03b68b419d4539869" translate="yes" xml:space="preserve">
          <source>You are encouraged to use &lt;code&gt;is()&lt;/code&gt; and &lt;code&gt;isnt()&lt;/code&gt; over &lt;code&gt;ok()&lt;/code&gt; where possible, however do not be tempted to use them to find out if something is true or false!</source>
          <target state="translated">당신이 사용하는 것이 좋습니다 것은 &lt;code&gt;is()&lt;/code&gt; 과 &lt;code&gt;isnt()&lt;/code&gt; 이상 &lt;code&gt;ok()&lt;/code&gt; 가능한, 그러나 무언가가 참인지 거짓인지 확인하는 데 사용할 유혹하지 마십시오!</target>
        </trans-unit>
        <trans-unit id="7231b46f1cb348d100d3ac2d2fb73b6bf57d8066" translate="yes" xml:space="preserve">
          <source>You are guaranteed that &lt;code&gt;$dirs . $filename . $suffix&lt;/code&gt; will denote the same location as the original $path.</source>
          <target state="translated">&lt;code&gt;$dirs . $filename . $suffix&lt;/code&gt; 보장 됩니다. $ filename $ suffix 는 원래 $ path와 동일한 위치를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="845992c360c01c1fffb9e8ef6310e8cc47a34923" translate="yes" xml:space="preserve">
          <source>You are not supposed to modify arrays while they are being iterated over. For speed and efficiency reasons, Perl internally does not do full reference-counting of iterated items, hence deleting such an item in the middle of an iteration causes Perl to see a freed value.</source>
          <target state="translated">배열이 반복되는 동안 배열을 수정해서는 안됩니다. 속도 및 효율성상의 이유로 Perl은 내부적으로 반복 된 항목의 전체 참조 계산을 수행하지 않으므로 반복 중에 이러한 항목을 삭제하면 Perl이 해제 된 값을 보게됩니다.</target>
        </trans-unit>
        <trans-unit id="c4250931e7c7965b87b322df0e377d3c209e4074" translate="yes" xml:space="preserve">
          <source>You are recommended to change your code to set &lt;code&gt;$/&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; explicitly if you wish to slurp the file. In future versions of Perl assigning a reference to will throw a fatal error.</source>
          <target state="translated">파일을 문지르려면 &lt;code&gt;$/&lt;/code&gt; 를 명시 적으로 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 로 설정하도록 코드를 변경하는 것이 좋습니다 . 이후 버전의 Perl에서 참조를 할당하면 치명적인 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d65f3a3a78dc9835626ba2ec61976c50a4907da1" translate="yes" xml:space="preserve">
          <source>You are responsible for &lt;code&gt;SvREFCNT_inc()&lt;/code&gt; on the return value if you plan to store it anywhere semi-permanently (otherwise it might be deleted out from under you the next time the cache is invalidated).</source>
          <target state="translated">반 영구적으로 &lt;code&gt;SvREFCNT_inc()&lt;/code&gt; 에 저장하려는 경우 반환 값에 대한 SvREFCNT_inc () 에 대한 책임 이 있습니다 (그렇지 않으면 다음에 캐시가 무효화 될 때 아래에서 삭제 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="37e416f1d8fe7e351baa8b0e70e6dc37f69f6f41" translate="yes" xml:space="preserve">
          <source>You are strongly encouraged to implement methods below, at least either encode() or decode().</source>
          <target state="translated">적어도 encode () 또는 decode () 중 하나를 아래에서 구현하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ff134e38e289cfa6f5f3d471d7e0e0fabcbe8c66" translate="yes" xml:space="preserve">
          <source>You are strongly encouraged to migrate any existing threaded code to the new model (i.e., use the &lt;code&gt;threads&lt;/code&gt; and &lt;code&gt;threads::shared&lt;/code&gt; modules) as soon as possible.</source>
          <target state="translated">기존 스레드 코드를 가능한 빨리 새 모델로 마이그레이션 (즉, &lt;code&gt;threads&lt;/code&gt; 및 &lt;code&gt;threads::shared&lt;/code&gt; 모듈 사용)하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2a08b19fff728f8eb38fe62f343715380f316ef9" translate="yes" xml:space="preserve">
          <source>You aren't allowed to modify constants in this way, of course. If an argument were actually literal and you tried to change it, you'd take a (presumably fatal) exception. For example, this won't work:</source>
          <target state="translated">물론 이런 식으로 상수를 수정할 수 없습니다. 인수가 실제로 문자 그대로이고 변경하려고 시도하면 (아마도 치명적인) 예외가 발생합니다. 예를 들어, 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1622820db3665cc19fb76f05a9e122011064bf68" translate="yes" xml:space="preserve">
          <source>You can &quot;make install&quot; already but you should test first.</source>
          <target state="translated">이미 &quot;설치&quot;를 할 수 있지만 먼저 테스트해야합니다.</target>
        </trans-unit>
        <trans-unit id="441d296a1602f9e39d91a622912b032dea66e8b8" translate="yes" xml:space="preserve">
          <source>You can (and should) read more about references in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;. Briefly, references are rather like pointers that know what they point to. (Objects are also a kind of reference, but we won't be needing them right away--if ever.) This means that when you have something which looks to you like an access to a two-or-more-dimensional array and/or hash, what's really going on is that the base type is merely a one-dimensional entity that contains references to the next level. It's just that you can</source>
          <target state="translated">&lt;a href=&quot;perlref&quot;&gt;perlref의&lt;/a&gt; 참조에 대해 더 많이 읽을 수 있습니다 . 간단히 말해서, 참조는 가리키는 것을 아는 포인터와 같습니다. (객체도 일종의 참조이지만, 우리는 지금 당장 필요하지 않을 것입니다.) 이것은 2 차원 이상의 배열에 대한 접근처럼 보이는 것이 있으면 / 또는 해시, 실제로 진행되는 것은 기본 유형이 다음 수준에 대한 참조를 포함하는 1 차원 엔터티라는 것입니다. 단지 당신이 할 수있는 것입니다</target>
        </trans-unit>
        <trans-unit id="4c8d7d3437af9191b3b2ecdbf2e0cc22d58ff901" translate="yes" xml:space="preserve">
          <source>You can &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ize just one element of an aggregate. Usually this is done on dynamics:</source>
          <target state="translated">집계의 한 요소 만 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 화할 수 있습니다 . 일반적으로 이것은 역학에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="3c3c57d183363a886eda26951cab8a3d873beb8e" translate="yes" xml:space="preserve">
          <source>You can access the first characters of a string with substr(). To get the first character, for example, start at position 0 and grab the string of length 1.</source>
          <target state="translated">substr ()을 사용하여 문자열의 첫 문자에 액세스 할 수 있습니다. 예를 들어 첫 번째 문자를 얻으려면 위치 0에서 시작하여 길이가 1 인 문자열을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="4b6168183223c539ff65f81f73941c2c4a8e59c2" translate="yes" xml:space="preserve">
          <source>You can actually chomp anything that's an lvalue, including an assignment:</source>
          <target state="translated">할당을 포함하여 실제로 lvalue 인 것을 숨길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab3659f896bba38cbe056eb37538d331f15d2fcc" translate="yes" xml:space="preserve">
          <source>You can actually chop anything that's an lvalue, including an assignment.</source>
          <target state="translated">실제로 과제를 포함하여 lvalue 인 것을 다질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06e51b7968687b9d39d3fba6b7611216b01c17eb" translate="yes" xml:space="preserve">
          <source>You can actually put an array or hash anywhere in the list, but the first one in the list will soak up all the values, and anything after it will become undefined. This may be useful in a my() or local().</source>
          <target state="translated">실제로 목록의 어느 곳에 나 배열이나 해시를 넣을 수 있지만 목록의 첫 번째 값은 모든 값을 흡수하며 그 이후의 값은 정의되지 않습니다. 이것은 my () 또는 local ()에서 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fcefecb0feb2b6d0223364636eebffcb896a89d" translate="yes" xml:space="preserve">
          <source>You can add customized aliases to standard (&lt;code&gt;:full&lt;/code&gt; ) Unicode naming conventions. The aliases override any standard definitions, so, if you're twisted enough, you can change &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A}&quot;&lt;/code&gt; to mean &lt;code&gt;&quot;B&quot;&lt;/code&gt; , etc.</source>
          <target state="translated">표준 ( &lt;code&gt;:full&lt;/code&gt; ) 유니 코드 이름 지정 규칙 에 사용자 정의 된 별명을 추가 할 수 있습니다 . 별칭은 표준 정의를 재정의하므로 충분히 꼬인 경우 &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A}&quot;&lt;/code&gt; 를 &lt;code&gt;&quot;B&quot;&lt;/code&gt; 등으로 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="422d4c1954392600b653163b725624c46d77f3f0" translate="yes" xml:space="preserve">
          <source>You can adjust the counter by assigning to &lt;code&gt;$.&lt;/code&gt; , but this will not actually move the seek pointer.</source>
          <target state="translated">&lt;code&gt;$.&lt;/code&gt; 에 할당하여 카운터를 조정할 수 있습니다 . 그러나 이것은 실제로 탐색 포인터를 이동시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="add234c624f206426ee8290a3ddfc9b8ceedcb89" translate="yes" xml:space="preserve">
          <source>You can also alter the way the output and logic of &lt;code&gt;Carp&lt;/code&gt; works, by changing some global variables in the &lt;code&gt;Carp&lt;/code&gt; namespace. See the section on &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; below.</source>
          <target state="translated">&lt;code&gt;Carp&lt;/code&gt; 네임 스페이스 에서 일부 전역 변수를 변경 하여 &lt;code&gt;Carp&lt;/code&gt; 의 출력 및 논리 작동 방식을 변경할 수도 있습니다 . 아래의 &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0d61dd797cd63f1042bbffa35621af46e71f5b31" translate="yes" xml:space="preserve">
          <source>You can also call &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; with a reference argument, and if this is trapped within an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;$@&lt;/code&gt; contains that reference. This permits more elaborate exception handling using objects that maintain arbitrary state about the exception. Such a scheme is sometimes preferable to matching particular string values of &lt;code&gt;$@&lt;/code&gt; with regular expressions. Because &lt;code&gt;$@&lt;/code&gt; is a global variable and &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; may be used within object implementations, be careful that analyzing the error object doesn't replace the reference in the global variable. It's easiest to make a local copy of the reference before any manipulations. Here's an example:</source>
          <target state="translated">또한 호출 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 참조 인수와 함께,이는 내 갇혀 경우 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;$@&lt;/code&gt; 그 참조를 포함합니다. 이를 통해 예외에 대한 임의의 상태를 유지하는 객체를 사용하여보다 정교한 예외 처리가 가능합니다. 이러한 체계는 때때로 &lt;code&gt;$@&lt;/code&gt; 의 특정 문자열 값을 정규식과 일치시키는 것보다 선호됩니다 . 때문에 &lt;code&gt;$@&lt;/code&gt; 전역 변수이고 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 객체 구현 내에서 사용할 수 있으며, 오류 개체를 분석하는 글로벌 변수에 대한 참조를 대체하지 않도록주의해야합니다. 조작하기 전에 참조의 로컬 사본을 만드는 것이 가장 쉽습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="151ae294544e5b15c198686df29c5202445b492a" translate="yes" xml:space="preserve">
          <source>You can also call &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; with a reference argument, and if this is trapped within an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;$@&lt;/code&gt; contains that reference. This permits more elaborate exception handling using objects that maintain arbitrary state about the exception. Such a scheme is sometimes preferable to matching particular string values of &lt;code&gt;$@&lt;/code&gt; with regular expressions. Because &lt;code&gt;$@&lt;/code&gt; is a global variable and &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; may be used within object implementations, be careful that analyzing the error object doesn't replace the reference in the global variable. It's easiest to make a local copy of the reference before any manipulations. Here's an example:</source>
          <target state="translated">또한 호출 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 참조 인수와 함께,이는 내 갇혀 경우 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;$@&lt;/code&gt; 그 참조를 포함합니다. 이를 통해 예외에 대한 임의의 상태를 유지하는 객체를 사용하여보다 정교한 예외 처리가 가능합니다. 이러한 체계는 때때로 &lt;code&gt;$@&lt;/code&gt; 의 특정 문자열 값을 정규식과 일치시키는 것보다 선호됩니다 . 때문에 &lt;code&gt;$@&lt;/code&gt; 전역 변수이고 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 객체 구현 내에서 사용할 수 있으며, 오류 개체를 분석하는 글로벌 변수에 대한 참조를 대체하지 않도록주의해야합니다. 조작하기 전에 참조의 로컬 사본을 만드는 것이 가장 쉽습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9cdb85fa1e67a62d3e70dba3d5bf1c75c04f7e09" translate="yes" xml:space="preserve">
          <source>You can also call parse_lines() to parse an array of lines or parse_string_document() to parse a document already in memory. As with parse_file(), parse_lines() and parse_string_document() default to sending their output to &lt;code&gt;STDOUT&lt;/code&gt; unless changed with the output_fh() method.</source>
          <target state="translated">parse_lines ()를 호출하여 행 배열을 구문 분석하거나 parse_string_document ()를 사용하여 이미 메모리에있는 문서를 구문 분석 할 수도 있습니다. parse_file ()과 마찬가지로 parse_lines () 및 parse_string_document () 는 output_fh () 메소드로 변경하지 않는 한 기본적으로 출력을 &lt;code&gt;STDOUT&lt;/code&gt; 으로 전송합니다 .</target>
        </trans-unit>
        <trans-unit id="e57fcafa1ea35942e9edb2cd8f5d66578716838d" translate="yes" xml:space="preserve">
          <source>You can also chain the calls like this, this will make first a copy and then multiply it by 2:</source>
          <target state="translated">이와 같이 호출을 연결하면 먼저 사본을 만든 다음 2를 곱합니다.</target>
        </trans-unit>
        <trans-unit id="029fcbbc45bf12d25b834057d9395bba7ab192ae" translate="yes" xml:space="preserve">
          <source>You can also change the internal suspects list via &lt;code&gt;set_suspects&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;set_suspects&lt;/code&gt; 메소드 를 통해 내부 용의자 목록을 변경할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d2a2e4e937f2dcf302981b9beceb35f4afd812bf" translate="yes" xml:space="preserve">
          <source>You can also choose to use rsync to get a copy of the current source tree for the bleadperl branch and all maintenance branches:</source>
          <target state="translated">rsync를 사용하여 bleadperl 브랜치 및 모든 유지 보수 브랜치에 대한 현재 소스 트리의 사본을 가져 오도록 선택할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="69913c0f24daf22d2c432ea27b2a49c000488188" translate="yes" xml:space="preserve">
          <source>You can also control the 'hushed' flag at run-time, using the built-in routine vmsish::hushed(). Without argument, it returns the hushed status. Since vmsish::hushed is built-in, you do not need to &quot;use vmsish&quot; to call it.</source>
          <target state="translated">내장 루틴 vmsish :: hushed ()를 사용하여 런타임에 'hushed'플래그를 제어 할 수도 있습니다. 인수가 없으면 허쉬 상태를 반환합니다. vmsish :: hushed가 내장되어 있으므로 &quot;vmsish를 사용하여&quot;호출 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="563cd6bbc176ecbc734b5b0b439a546964280899" translate="yes" xml:space="preserve">
          <source>You can also control the character encoding and entities. For example, if you're sure that the POD is properly encoded (using the &lt;code&gt;=encoding&lt;/code&gt; command), you can prevent high-bit characters from being encoded as HTML entities and declare the output character set as UTF-8 before parsing, like so:</source>
          <target state="translated">문자 인코딩 및 엔터티를 제어 할 수도 있습니다. 예를 들어, POD가 올바르게 인코딩 된 경우 ( &lt;code&gt;=encoding&lt;/code&gt; 명령을 사용하여 ), 높은 비트 문자가 HTML 엔티티로 인코딩되지 않도록하고 구문 분석하기 전에 출력 문자 세트를 UTF-8로 선언 할 수 있습니다. :</target>
        </trans-unit>
        <trans-unit id="ce7cb29295e37cbd29b717e64482225d4d4ba414" translate="yes" xml:space="preserve">
          <source>You can also control the shell that perl uses to run system() and backtick commands via PERL5SHELL. See &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="translated">PERL5SHELL을 통해 perl이 system () 및 backtick 명령을 실행하는 데 사용하는 쉘을 제어 할 수도 있습니다. &lt;a href=&quot;perlrun&quot;&gt;perlrun을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4b6274126a67429902f21b4ff102d4a5f157ec82" translate="yes" xml:space="preserve">
          <source>You can also create a circular reference with a single variable:</source>
          <target state="translated">단일 변수를 사용하여 순환 참조를 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe319fa0895a7f47e55075d55fc2289e3b3f2bea" translate="yes" xml:space="preserve">
          <source>You can also do</source>
          <target state="translated">당신은 또한 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="69a5ee6a0a8ad7101d445832b3faf4f8db8fd92c" translate="yes" xml:space="preserve">
          <source>You can also do the same things with the &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; module:</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; 모듈 에서도 동일한 작업을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="efdd9cfab2b6e73dabdc31999bde389ad6e9c40e" translate="yes" xml:space="preserve">
          <source>You can also do the wrapping explicitly by rad2rad(), deg2deg(), and grad2grad().</source>
          <target state="translated">rad2rad (), deg2deg () 및 grad2grad ()를 사용하여 래핑을 명시 적으로 수행 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e971cca5e90229321a699ea5b197dee6a304b5cb" translate="yes" xml:space="preserve">
          <source>You can also do this directly in the match operator using the &lt;code&gt;\Q&lt;/code&gt; and &lt;code&gt;\E&lt;/code&gt; sequences. The &lt;code&gt;\Q&lt;/code&gt; tells Perl where to start escaping special characters, and the &lt;code&gt;\E&lt;/code&gt; tells it where to stop (see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; for more details).</source>
          <target state="translated">&lt;code&gt;\Q&lt;/code&gt; 및 &lt;code&gt;\E&lt;/code&gt; 시퀀스를 사용하여 일치 연산자에서 직접이 작업을 수행 할 수도 있습니다 . &lt;code&gt;\Q&lt;/code&gt; 어디에서 특수 문자를 이스케이프 시작하는 펄을 알려줍니다, 그리고 &lt;code&gt;\E&lt;/code&gt; 곳 (참조 중지하는 방법을 알려줍니다 &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 자세한 내용).</target>
        </trans-unit>
        <trans-unit id="fe2d0afbbbfb95dc9ef1705dc46b6eb4a3e77627" translate="yes" xml:space="preserve">
          <source>You can also do this for most systems using the &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module from CPAN, which is easier to use and in theory more portable.</source>
          <target state="translated">CPAN 의 &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term :: ReadKey&lt;/a&gt; 모듈을 사용하여 대부분의 시스템에서이 작업을 수행 할 수도 있습니다. CPAN은 사용하기 쉽고 이론적으로 이식성이 뛰어납니다.</target>
        </trans-unit>
        <trans-unit id="f3337ad9bcb6d402cd92e0314d2032a9a8dc4c0a" translate="yes" xml:space="preserve">
          <source>You can also easily say to use all categories but one, by either, for example,</source>
          <target state="translated">예를 들어 다음과 같이 두 가지 중 하나만 사용하여 모든 범주를 사용하도록 쉽게 말할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="317bed7b561a99db6e7463d3bee761b35a18aa16" translate="yes" xml:space="preserve">
          <source>You can also embed newlines directly in your strings, i.e., they can end on a different line than they begin. This is nice, but if you forget your trailing quote, the error will not be reported until Perl finds another line containing the quote character, which may be much further on in the script. Variable substitution inside strings is limited to scalar variables, arrays, and array or hash slices. (In other words, names beginning with $ or @, followed by an optional bracketed expression as a subscript.) The following code segment prints out &quot;The price is $100.&quot;</source>
          <target state="translated">또한 줄 바꿈을 문자열에 직접 포함시킬 수 있습니다. 즉, 시작 줄과 다른 줄에서 끝날 수 있습니다. 이것은 좋지만 후행 따옴표를 잊어 버린 경우 Perl이 따옴표 문자가 포함 된 다른 줄을 찾을 때까지 오류 가보고되지 않으며 스크립트에서 훨씬 더 나올 수 있습니다. 문자열 내 변수 대체는 스칼라 변수, 배열 및 배열 또는 해시 슬라이스로 제한됩니다. 즉, 이름은 $ 또는 @로 시작하고 뒤에 괄호로 묶인 선택적 표현식이옵니다. 다음 코드 세그먼트는 &quot;가격은 $ 100입니다.&quot;를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="6dc98b973b8e3861953362cf4137bf9098b40a23" translate="yes" xml:space="preserve">
          <source>You can also explicitly indicate that a single handler is meant to be used for all types of referents like so:</source>
          <target state="translated">또한 단일 핸들러가 다음과 같이 모든 유형의 참조에 사용되도록 명시 적으로 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc7d393dae203f89e29915d158bc84c0d091344a" translate="yes" xml:space="preserve">
          <source>You can also explicitly specify the argument number to use for the join string using something like &lt;code&gt;*2$v&lt;/code&gt;; for example:</source>
          <target state="translated">&lt;code&gt;*2$v&lt;/code&gt; 와 같은 것을 사용하여 결합 문자열에 사용할 인수 번호를 명시 적으로 지정할 수도 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3c69b8b0664f8688a90139832b96e7b725fab5ec" translate="yes" xml:space="preserve">
          <source>You can also gain some minuscule measure of efficiency by pre-extending an array that is going to get big. You can also extend an array by assigning to an element that is off the end of the array. You can truncate an array down to nothing by assigning the null list () to it. The following are equivalent:</source>
          <target state="translated">또한 커질 어레이를 미리 확장하여 약간의 효율성 측정 값을 얻을 수도 있습니다. 배열의 끝에있는 요소에 할당하여 배열을 확장 할 수도 있습니다. 널 (null) 목록 ()을 지정하여 배열을 무단으로자를 수 있습니다. 다음은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="87f6d7508324248bf5fa6b6a6e4e9d73a898fe92" translate="yes" xml:space="preserve">
          <source>You can also get a pointer to the end of the string stored in the SV with the macro:</source>
          <target state="translated">매크로를 사용하여 SV에 저장된 문자열 끝에 대한 포인터를 얻을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="843f7af3e5947338619464418b011d78b7714032" translate="yes" xml:space="preserve">
          <source>You can also get differences with a subtraction, which returns a &lt;a href=&quot;time/seconds&quot;&gt;Time::Seconds&lt;/a&gt; object:</source>
          <target state="translated">빼기를 사용하여 차이를 얻을 수도 있습니다.이 빼기는 &lt;a href=&quot;time/seconds&quot;&gt;Time :: Seconds&lt;/a&gt; 객체 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="0da6f0ff3f9840990993a84402f300e13eb838e3" translate="yes" xml:space="preserve">
          <source>You can also get into subtle problems on those few operations in Perl that actually do care about the difference between a string and a number, such as the magical &lt;code&gt;++&lt;/code&gt; autoincrement operator or the syscall() function.</source>
          <target state="translated">마법의 &lt;code&gt;++&lt;/code&gt; 자동 증가 연산자 또는 syscall () 함수 와 같이 문자열과 숫자의 차이를 실제로 처리하는 Perl의 소수 작업에 대해서는 미묘한 문제가 발생할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd7d480332101e4bfe5db6a1d74af4d69d28cfca" translate="yes" xml:space="preserve">
          <source>You can also get the precision from the next argument using &lt;code&gt;.*&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;.*&lt;/code&gt; 를 사용하여 다음 인수에서 정밀도를 얻을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="31317a51fe6916c8950fb1738da08a3f662e794a" translate="yes" xml:space="preserve">
          <source>You can also go through each element and skip the ones you've seen before. Use a hash to keep track. The first time the loop sees an element, that element has no key in &lt;code&gt;%Seen&lt;/code&gt; . The &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; statement creates the key and immediately uses its value, which is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, so the loop continues to the &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; and increments the value for that key. The next time the loop sees that same element, its key exists in the hash</source>
          <target state="translated">각 요소를 살펴보고 이전에 본 요소를 건너 뛸 수도 있습니다. 해시를 사용하여 추적하십시오. 루프에서 요소를 처음 볼 때 해당 요소에는 &lt;code&gt;%Seen&lt;/code&gt; 키가 없습니다 . &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 문은 키를 생성하고 즉시 자사의 가치, 사용 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 루프가 계속 그래서, &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; 및 해당 키의 값을 증가시킨다. 다음에 루프가 동일한 요소를 볼 때 해당 키는 해시에 존재합니다.</target>
        </trans-unit>
        <trans-unit id="7930ef83d4a331d3e89d11f276bc35572519ad08" translate="yes" xml:space="preserve">
          <source>You can also import the symbolic &lt;code&gt;S_I*&lt;/code&gt; constants from the &lt;code&gt;Fcntl&lt;/code&gt; module:</source>
          <target state="translated">&lt;code&gt;Fcntl&lt;/code&gt; 모듈 에서 기호 &lt;code&gt;S_I*&lt;/code&gt; 상수를 가져올 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="254f31569eb5ae2200e952d6645d10bd474402c9" translate="yes" xml:space="preserve">
          <source>You can also insert hooks into the file inclusion system by putting Perl code directly into &lt;code&gt;@INC&lt;/code&gt; . Those hooks may be subroutine references, array references or blessed objects. See &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; for details.</source>
          <target state="translated">Perl 코드를 &lt;code&gt;@INC&lt;/code&gt; 에 직접 넣어 파일 포함 시스템에 후크를 삽입 할 수도 있습니다 . 이러한 후크는 서브 루틴 참조, 배열 참조 또는 축복 된 객체 일 수 있습니다. 자세한 내용은 &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ae3dcb264a37bf433b3f44d57e7b80c09701bead" translate="yes" xml:space="preserve">
          <source>You can also insert hooks into the import facility by putting Perl code directly into the @INC array. There are three forms of hooks: subroutine references, array references, and blessed objects.</source>
          <target state="translated">Perl 코드를 @INC 배열에 직접 넣어 가져 오기 기능에 후크를 삽입 할 수도 있습니다. 후크에는 서브 루틴 참조, 배열 참조 및 축복 된 객체의 세 가지 형태가 있습니다.</target>
        </trans-unit>
        <trans-unit id="05e59c02014a1d5de9eba1297e8dbc08a175322a" translate="yes" xml:space="preserve">
          <source>You can also just quickly &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; on an undefined value this way:</source>
          <target state="translated">이 방법으로 정의되지 않은 값으로 빠르게 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5af0b3086e446e033f6737e913de95b977971d84" translate="yes" xml:space="preserve">
          <source>You can also look for information at:</source>
          <target state="translated">다음에서 정보를 찾을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="52f3afa40db22b85e32dd734c2f80ac43010fee7" translate="yes" xml:space="preserve">
          <source>You can also override &lt;code&gt;DOES&lt;/code&gt; directly in your own classes. If you override this method, it should never throw an exception.</source>
          <target state="translated">자신의 클래스에서 &lt;code&gt;DOES&lt;/code&gt; 를 직접 재정의 할 수도 있습니다 . 이 메소드를 대체하면 예외가 발생하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="95cd0a4f9ce9a6a1469a2469c1efc68cdb5fae5b" translate="yes" xml:space="preserve">
          <source>You can also pass &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; an explicit encoding to change it on the fly. This isn't exactly &quot;binary&quot; mode, but we still use &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; to do it:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 에 명시 적 인코딩을 전달 하여 즉시 변경할 수도 있습니다. 이것은 정확히 &quot;이진&quot;모드는 아니지만 여전히 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 를 사용 하여 수행합니다.</target>
        </trans-unit>
        <trans-unit id="f90ccf1fd48c6dc4de43f56b2888c9c3134e2996" translate="yes" xml:space="preserve">
          <source>You can also pass a subroutine reference in order to determine and return the proper program to run based on a given test script. The subroutine reference should expect the TAP::Harness object itself as the first argument, and the file name as the second argument. It should return an array reference containing the command to be run and including the test file name. It can also simply return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, in which case TAP::Harness will fall back on executing the test script in Perl:</source>
          <target state="translated">주어진 테스트 스크립트를 기반으로 실행할 적절한 프로그램을 결정하고 리턴하기 위해 서브 루틴 참조를 전달할 수도 있습니다. 서브 루틴 참조는 TAP :: Harness 오브젝트 자체를 첫 번째 인수로, 파일 이름을 두 번째 인수로 예상해야합니다. 실행할 명령을 포함하고 테스트 파일 이름을 포함하는 배열 참조를 리턴해야합니다. 또한 단순히 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환 할 수 있습니다 .이 경우 TAP :: Harness는 Perl에서 테스트 스크립트를 실행하면 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="f73ef4e3f69ff87027791a2bee2e957755bc2ee3" translate="yes" xml:space="preserve">
          <source>You can also read and execute Perl statements from a file while in the midst of your C program, by placing the filename in</source>
          <target state="translated">파일 이름을 다음과 같이하여 C 프로그램 도중 파일에서 Perl 문을 읽고 실행할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9bed781c4a6044ffb67b23fe5c127e03e4dd1a1" translate="yes" xml:space="preserve">
          <source>You can also refer to capture groups relatively, by using a negative number, so that &lt;code&gt;\g-1&lt;/code&gt; and &lt;code&gt;\g{-1}&lt;/code&gt; both refer to the immediately preceding capture group, and &lt;code&gt;\g-2&lt;/code&gt; and &lt;code&gt;\g{-2}&lt;/code&gt; both refer to the group before it. For example:</source>
          <target state="translated">또한 음수를 사용하여 캡처 그룹을 상대적으로 참조 할 수 있으므로 &lt;code&gt;\g-1&lt;/code&gt; 및 &lt;code&gt;\g{-1}&lt;/code&gt; 은 바로 앞의 캡처 그룹을 참조하고 &lt;code&gt;\g-2&lt;/code&gt; 및 &lt;code&gt;\g{-2}&lt;/code&gt; 모두 그 전에 그룹을 참조하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="108a751b15dd5a65748cd5542a9f662a512fab15" translate="yes" xml:space="preserve">
          <source>You can also restrict names to a certain alphabet by specifying the &lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt; pragma:</source>
          <target state="translated">또한 지정하여 특정 알파벳으로 이름을 제한 할 수 있습니다 &lt;a href=&quot;charnames&quot;&gt;charnames의&lt;/a&gt; 프라그를 :</target>
        </trans-unit>
        <trans-unit id="0b5023bd40fe3a7df91e6504812de04a002532fe" translate="yes" xml:space="preserve">
          <source>You can also see in that example that we use &lt;code&gt;utf8_to_uvchr_buf&lt;/code&gt; to get the value of the character; the inverse function &lt;code&gt;uvchr_to_utf8&lt;/code&gt; is available for putting a UV into UTF-8:</source>
          <target state="translated">이 예에서 &lt;code&gt;utf8_to_uvchr_buf&lt;/code&gt; 를 사용 하여 캐릭터의 값을 얻는다는 것을 알 수 있습니다 . 반전 함수 &lt;code&gt;uvchr_to_utf8&lt;/code&gt; 은 UV를 UTF-8에 넣는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a3be218b57aec1fe1552cf95cde772b459e8c4a" translate="yes" xml:space="preserve">
          <source>You can also send pull requests to the Github repository:</source>
          <target state="translated">풀 요청을 Github 리포지토리로 보낼 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a4162cf16b37e0bb4e40d233ea23d3b932f7f0d" translate="yes" xml:space="preserve">
          <source>You can also specify the separator character using hexadecimal notation: &lt;b&gt;-0x&lt;i&gt;HHH...&lt;/i&gt;&lt;/b&gt;, where the &lt;code&gt;&lt;i&gt;H&lt;/i&gt;&lt;/code&gt; are valid hexadecimal digits. Unlike the octal form, this one may be used to specify any Unicode character, even those beyond 0xFF. So if you</source>
          <target state="translated">16 진수 표기법 &lt;b&gt;-0x &lt;i&gt;HHH ...를&lt;/i&gt;&lt;/b&gt; 사용하여 구분 기호 문자를 지정할 수도 있습니다. 여기서 &lt;code&gt;&lt;i&gt;H&lt;/i&gt;&lt;/code&gt; 는 유효한 16 진수입니다. 8 진 형식과 달리이 형식은 0xFF 이외의 문자를 포함하여 모든 유니 코드 문자를 지정하는 데 사용될 수 있습니다. 그래서 당신이</target>
        </trans-unit>
        <trans-unit id="5708c7cba5f95ced05791bc1f781cc7e3ab698d2" translate="yes" xml:space="preserve">
          <source>You can also specify to NOT use something:</source>
          <target state="translated">무언가를 사용하지 않도록 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0e21d8042eb943e53a763ac42b81475843fd69a" translate="yes" xml:space="preserve">
          <source>You can also store data in network order to allow easy sharing across multiple platforms, or when storing on a socket known to be remotely connected. The routines to call have an initial &lt;code&gt;n&lt;/code&gt; prefix for</source>
          <target state="translated">또한 여러 플랫폼에서 쉽게 공유 할 수 있도록 또는 원격으로 연결된 소켓에 저장할 때 네트워크 순서대로 데이터를 저장할 수 있습니다. 호출 할 루틴에는 초기 &lt;code&gt;n&lt;/code&gt; 접두사가 있습니다.</target>
        </trans-unit>
        <trans-unit id="32a000612a53a9f73b8165e9ffd35ee663d455aa" translate="yes" xml:space="preserve">
          <source>You can also subscript a list to get a single element from it:</source>
          <target state="translated">리스트를 첨자 화하여 하나의 요소를 얻을 수도 있습니다 :</target>
        </trans-unit>
        <trans-unit id="e308900a9f85413017177815b933ee92128f909d" translate="yes" xml:space="preserve">
          <source>You can also test a class, to make sure that it has the right ancestor:</source>
          <target state="translated">클래스가 올바른 조상인지 확인하기 위해 클래스를 테스트 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e940484c0812f3991ca3b5162180666fbbc774e9" translate="yes" xml:space="preserve">
          <source>You can also try &lt;code&gt;guess_encoding&lt;/code&gt; function which is exported by default. It takes $data to check and it also takes the list of suspects by option. The optional suspect list is</source>
          <target state="translated">기본적으로 내보내지는 &lt;code&gt;guess_encoding&lt;/code&gt; 함수를 사용해 볼 수도 있습니다 . 검사하는 데 $ data가 필요하며 옵션별로 용의자 목록이 필요합니다. 선택적 용의자 목록은</target>
        </trans-unit>
        <trans-unit id="c6c2bb7263fcb86f56120bac5220dbcae10e778f" translate="yes" xml:space="preserve">
          <source>You can also try to include the module in a one-liner to see if perl finds it:</source>
          <target state="translated">또한 펄이 모듈을 찾는 지 확인하기 위해 하나의 라이너에 모듈을 포함시킬 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b15c66e70792efbd27fd6c112e317c6eb54c5b69" translate="yes" xml:space="preserve">
          <source>You can also try using &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt;, as described in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; (although this is the same thing that many of the modules will do for you).</source>
          <target state="translated">&lt;a href=&quot;perlfunc&quot;&gt;perlfunc에&lt;/a&gt; 설명 된대로 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 사용을 시도 할 수도 있습니다 (여러 모듈이 자동으로 수행하는 것과 동일하지만).</target>
        </trans-unit>
        <trans-unit id="22d0b06ab6697336780029eb518e6cdd2c05382e" translate="yes" xml:space="preserve">
          <source>You can also use</source>
          <target state="translated">당신은 또한 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="b0304b03ea61e4912a40d9a36c7c0d47306360a9" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Tiny::Antlers&quot;&gt;Class::Tiny::Antlers&lt;/a&gt; for &lt;code&gt;Moose&lt;/code&gt; -like syntax.</source>
          <target state="translated">&lt;code&gt;Moose&lt;/code&gt; 와 유사한 구문에 &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Tiny::Antlers&quot;&gt;Class :: Tiny :: Antlers&lt;/a&gt; 를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="37de0be164e83020017ecbe8445d1b73a8f2a1b8" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::REPL&quot;&gt;Devel::REPL&lt;/a&gt; which is an interactive shell for Perl, commonly known as a REPL - Read, Evaluate, Print, Loop. It provides various handy features.</source>
          <target state="translated">REPL-Read, Evaluate, Print, Loop로 알려진 Perl의 대화식 쉘인 &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::REPL&quot;&gt;Devel :: REPL&lt;/a&gt; 을 사용할 수도 있습니다 . 다양한 편리한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9013c35ad3298535ad5c8c74739a6a896be46939" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;http://search.cpan.org/perldoc/Tie::Cycle&quot;&gt;Tie::Cycle&lt;/a&gt; to use a scalar that always has the next element of the circular array:</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Tie::Cycle&quot;&gt;Tie :: Cycle&lt;/a&gt; 을 사용하여 항상 원형 배열의 다음 요소가있는 스칼라를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ed9079885add1db23c7b692dc26264a6c8112995" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;http://search.cpan.org/perldoc/local::lib&quot;&gt;local::lib&lt;/a&gt; to do much of the same thing. Install modules using &lt;a href=&quot;http://search.cpan.org/perldoc/local::lib&quot;&gt;local::lib&lt;/a&gt;'s settings then use the module in your program:</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/local::lib&quot;&gt;local :: lib&lt;/a&gt; 를 사용 하여 동일한 작업을 수행 할 수도 있습니다 . 사용 모듈 설치 &lt;a href=&quot;http://search.cpan.org/perldoc/local::lib&quot;&gt;지역 :: lib 디렉토리를&lt;/a&gt; 다음 프로그램에서 모듈을 사용의 설정을 :</target>
        </trans-unit>
        <trans-unit id="38efc50c4c6a8567a3f07d734113580b8054b830" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;time/piece&quot;&gt;Time::Piece&lt;/a&gt;, which comes with Perl and provides a &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; that returns an object:</source>
          <target state="translated">Perl과 함께 제공되며 객체를 반환하는 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;time/piece&quot;&gt; 시간&lt;/a&gt; 을 제공 하는 Time :: Piece를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe8ff91507ad3e201158ab00126828440dda9b62" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;HANDLE-&amp;gt;input_line_number(EXPR)&lt;/code&gt; to access the line counter for a given filehandle without having to worry about which handle you last accessed.</source>
          <target state="translated">당신은 또한 사용할 수 있습니다 &lt;code&gt;HANDLE-&amp;gt;input_line_number(EXPR)&lt;/code&gt; 마지막으로 액세스 핸들하는 걱정없이 주어진 파일 핸들의 라인 카운터에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfc194c704de65f5fa2e2dc7cdfca08cd861cafc" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;cpan&lt;/code&gt; 's &lt;code&gt;-a&lt;/code&gt; switch to create an autobundle file that &lt;code&gt;CPAN.pm&lt;/code&gt; understands and can use to re-install every module:</source>
          <target state="translated">당신은 또한 사용할 수 있습니다 &lt;code&gt;cpan&lt;/code&gt; 의 &lt;code&gt;-a&lt;/code&gt; 있다는 autobundle 파일을 만들 수있는 스위치 &lt;code&gt;CPAN.pm&lt;/code&gt; 가 이해하고 사용할 수있는 모든 모듈을 다시 설치 :</target>
        </trans-unit>
        <trans-unit id="3ed04ee9d470ae5bb5ded41953f6884557aab9f4" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;while&lt;/code&gt; in a post-condition:</source>
          <target state="translated">당신은 또한 사용할 수 있습니다 &lt;code&gt;while&lt;/code&gt; 후 상태 :</target>
        </trans-unit>
        <trans-unit id="d2490129a2ade6b9a949f50bed0b1d18208e8c0a" translate="yes" xml:space="preserve">
          <source>You can also use Perl one-liners to modify a file in-place. The following changes all 'Fred' to 'Barney' in</source>
          <target state="translated">Perl 원 라이너를 사용하여 파일을 제자리에서 수정할 수도 있습니다. 다음은 모든 'Fred'를 'Barney'로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="ae806fe9a09487e09415c88d84054f11b5bab926" translate="yes" xml:space="preserve">
          <source>You can also use a commercial debugger such as Affrus (Mac OS X), Komodo from Activestate (Windows and Mac OS X), or EPIC (most platforms).</source>
          <target state="translated">Affrus (Mac OS X), Activestate의 Komodo (Windows 및 Mac OS X) 또는 EPIC (대부분의 플랫폼)과 같은 상용 디버거를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="79babd18e608e40e4da78366242734a20c79cee2" translate="yes" xml:space="preserve">
          <source>You can also use a double fork. You immediately &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; for your first child, and the init daemon will &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; for your grandchild once it exits.</source>
          <target state="translated">이중 포크를 사용할 수도 있습니다. 첫 번째 자식을 즉시 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; , init 데몬은 손자 가 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ef85cce54fb95ce8f948edcebadc50c579e68d3" translate="yes" xml:space="preserve">
          <source>You can also use a list slice to select only the elements that you need:</source>
          <target state="translated">목록 조각을 사용하여 필요한 요소 만 선택할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d760c6f0200ce645ec4271e39ed0780a635d6be2" translate="yes" xml:space="preserve">
          <source>You can also use a localized &lt;code&gt;@ARGV&lt;/code&gt; to eliminate the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">현지화 된 &lt;code&gt;@ARGV&lt;/code&gt; 를 사용 하여 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 를 제거 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4613c51eb74aabc580ab960ede735ed7c5a84c03" translate="yes" xml:space="preserve">
          <source>You can also use a subroutine reference as a method:</source>
          <target state="translated">서브 루틴 참조를 메소드로 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4a8095c707393fa806f56c74d791b44c5bdbd35" translate="yes" xml:space="preserve">
          <source>You can also use certain libraries like Config conditionally, but be sure to skip the test gracefully if it's not there.</source>
          <target state="translated">조건부로 Config와 같은 특정 라이브러리를 조건부로 사용할 수도 있지만 테스트가 없으면 정상적으로 건너 뛰십시오.</target>
        </trans-unit>
        <trans-unit id="aee62fec81f8fc5af73b94cc4b6a4396ba0e2b3e" translate="yes" xml:space="preserve">
          <source>You can also use dmake to build using Visual C++; provided, however, you set OSRELEASE to &quot;microsft&quot; (or whatever the directory name under which the Visual C dmake configuration lives) in your environment and edit win32/config.vc to change &quot;make=nmake&quot; into &quot;make=dmake&quot;. The latter step is only essential if you want to use dmake as your default make for building extensions using MakeMaker.</source>
          <target state="translated">dmake를 사용하여 Visual C ++를 사용하여 빌드 할 수도 있습니다. 그러나 사용자 환경에서 OSRELEASE를 &quot;microsft&quot;(또는 Visual C dmake 구성이있는 디렉토리 이름)로 설정하고 win32 / config.vc를 편집하여 &quot;make = nmake&quot;를 &quot;make = dmake&quot;로 변경하십시오. 후자의 단계는 MakeMaker를 사용하여 확장을 빌드하기위한 기본 make로 dmake를 사용하려는 경우에만 필수입니다.</target>
        </trans-unit>
        <trans-unit id="4fabe958607319aed5413ce7d91aa1937c4486e1" translate="yes" xml:space="preserve">
          <source>You can also use file-descriptor redirection to make STDERR a duplicate of STDOUT:</source>
          <target state="translated">파일 디스크립터 리디렉션을 사용하여 STDERR을 STDOUT의 복제본으로 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb1f48473296bb1c89d7c3f43ff784b475814cae" translate="yes" xml:space="preserve">
          <source>You can also use negation in both &lt;code&gt;\p{}&lt;/code&gt; and &lt;code&gt;\P{}&lt;/code&gt; by introducing a caret (&lt;code&gt;^&lt;/code&gt;) between the first brace and the property name: &lt;code&gt;\p{^Tamil}&lt;/code&gt; is equal to &lt;code&gt;\P{Tamil}&lt;/code&gt; .</source>
          <target state="translated">첫 번째 괄호와 속성 이름 사이에 캐럿 ( &lt;code&gt;^&lt;/code&gt; ) 을 도입하여 &lt;code&gt;\p{}&lt;/code&gt; 및 &lt;code&gt;\P{}&lt;/code&gt; 에서 부정을 사용할 수도 있습니다 . &lt;code&gt;\p{^Tamil}&lt;/code&gt; 은 &lt;code&gt;\P{Tamil}&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="6e6a71e5490894554dcf75a2f44b77577d1780db" translate="yes" xml:space="preserve">
          <source>You can also use substr() as an lvalue.</source>
          <target state="translated">substr ()을 lvalue로 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8a027b09bbb1035f68edd31b3dac9da865767c1" translate="yes" xml:space="preserve">
          <source>You can also use the -Duse64bitint flag to Configure. Although there are some minor differences between compiling Perl with this flag versus the -Duse64bitall flag, they should not be noticeable from a Perl user's perspective. When configuring -Duse64bitint using a 64bit gcc on a pa-risc architecture, -Duse64bitint is silently promoted to -Duse64bitall.</source>
          <target state="translated">-Duse64bitint 플래그를 사용하여 구성 할 수도 있습니다. 이 플래그를 사용하여 Perl을 컴파일하는 것과 -Duse64bitall 플래그를 컴파일하는 것에는 약간의 차이가 있지만 Perl 사용자의 관점에서는 눈에 띄지 않아야합니다. pa-risc 아키텍처에서 64 비트 gcc를 사용하여 -Duse64bitint를 구성하면 -Duse64bitint가 자동으로 -Duse64bitall로 승격됩니다.</target>
        </trans-unit>
        <trans-unit id="01f985bfd65126ce04f3352a8f1c24d2647a415c" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;Date::Calc&lt;/a&gt; module using its &lt;code&gt;Today_and_Now&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;Today_and_Now&lt;/code&gt; 함수 를 사용하여 &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;Date :: Calc&lt;/a&gt; 모듈을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5948ec91fdfb792b5884ccadb56a91fc59d16359" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;tie/file&quot;&gt;Tie::File&lt;/a&gt; module which lets you access the lines through a tied array. You can use normal array operations to modify your file, including setting the last index and using &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">당신은 또한 사용할 수 있습니다 &lt;a href=&quot;tie/file&quot;&gt;타이 :: 파일&lt;/a&gt; 당신이 묶여 배열을 통해 라인에 액세스 할 수 있습니다 모듈. 마지막 색인 설정 및 &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; 사용을 포함하여 일반적인 배열 작업을 사용하여 파일을 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cea4cf5784aecf948d1c03056df0b1645df434de" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;**&lt;/code&gt; operator, see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;**&lt;/code&gt; 연산자를 사용할 수도 있습니다 ( &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="aca7a853e98fdbbaafd79c6bf0b9e3d107072aaf" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;\G&lt;/code&gt; anchor in scalar context. You still need the &lt;code&gt;g&lt;/code&gt; flag.</source>
          <target state="translated">스칼라 컨텍스트에서 &lt;code&gt;\G&lt;/code&gt; 앵커를 사용할 수도 있습니다 . 여전히 &lt;code&gt;g&lt;/code&gt; 플래그 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="36d5ff0652d0a9cfb0d9a8028ed64cb97f87e026" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;open3()&lt;/code&gt; function from &lt;a href=&quot;ipc/open3&quot;&gt;IPC::Open3&lt;/a&gt;. Benjamin Goldberg provides some sample code:</source>
          <target state="translated">&lt;a href=&quot;ipc/open3&quot;&gt;IPC :: Open3&lt;/a&gt; 에서 &lt;code&gt;open3()&lt;/code&gt; 함수를 사용할 수도 있습니다 . Benjamin Goldberg는 몇 가지 샘플 코드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="54c10825a7a9a0e79c4bc9a8acb25f8c895c8d2f" translate="yes" xml:space="preserve">
          <source>You can also use the Unix command mknod(1), or on some systems, mkfifo(1). These may not be in your normal path, though.</source>
          <target state="translated">Unix 명령 mknod (1) 또는 일부 시스템 인 mkfifo (1)을 사용할 수도 있습니다. 그러나 이것은 정상적인 경로에 있지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d558c8753e7739908d901edc4316bd26afe6b26c" translate="yes" xml:space="preserve">
          <source>You can also use the complement of \b, \B, to specify that there should not be a word boundary.</source>
          <target state="translated">\ b, \ B의 보수를 사용하여 단어 경계가 없어야 함을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="94817cf57f637575defe9d34927c35a3c77682d8" translate="yes" xml:space="preserve">
          <source>You can also use the following functions to extract the file header information from Storable images:</source>
          <target state="translated">다음 기능을 사용하여 저장 가능 이미지에서 파일 헤더 정보를 추출 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="621c9d7b846400426f6a8d8885a28fc12414361e" translate="yes" xml:space="preserve">
          <source>You can also write that as a single substitution, although it turns out the combined statement is slower than the separate ones. That might not matter to you, though:</source>
          <target state="translated">결합 된 명령문이 별도의 명령문보다 느리지 만 단일 대체로 작성할 수도 있습니다. 그러나 그것은 당신에게 중요하지 않을 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="6e736747d1920ca322bb92742d39b47addfde6fe" translate="yes" xml:space="preserve">
          <source>You can also:</source>
          <target state="translated">당신은 또한 수:</target>
        </trans-unit>
        <trans-unit id="9a39342cae5acfdbd6b63da64d2d504d73f599e3" translate="yes" xml:space="preserve">
          <source>You can alter the global variable $Params::Check::NO_DUPLICATES to control whether the &lt;code&gt;store&lt;/code&gt; 'd key will still be present in your result set. See the &lt;a href=&quot;#Global-Variables&quot;&gt;Global Variables&lt;/a&gt; section below.</source>
          <target state="translated">전역 변수 $ Params :: Check :: NO_DUPLICATES를 변경하여 &lt;code&gt;store&lt;/code&gt; 'd 키가 여전히 결과 세트에 존재 하는지 여부를 제어 할 수 있습니다. 아래의 &lt;a href=&quot;#Global-Variables&quot;&gt;전역 변수&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="330192003f1fea8edf49c86f71523fd9c154de87" translate="yes" xml:space="preserve">
          <source>You can always check the value you're using by printing it in octal notation to ensure it matches what you think it should be. Print it in octal and decimal format:</source>
          <target state="translated">8 진수 표기법으로 인쇄하여 원하는 값과 일치하는지 항상 확인하여 사용중인 값을 확인할 수 있습니다. 8 진수 및 10 진수 형식으로 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="ef6c5c0a821b62556c215147b73e29172a7eabfd" translate="yes" xml:space="preserve">
          <source>You can always use an array reference, in curly braces, in place of the name of an array. For example, &lt;code&gt;@{$aref}&lt;/code&gt; instead of &lt;code&gt;@array&lt;/code&gt; .</source>
          <target state="translated">배열 이름 대신 항상 중괄호 안에 배열 참조를 사용할 수 있습니다. 예를 들어 &lt;code&gt;@array&lt;/code&gt; 대신 &lt;code&gt;@{$aref}&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="4754996a46b2974a193b45735bde04e1ddad5927" translate="yes" xml:space="preserve">
          <source>You can arrange for a callback to be run just before the &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; does its deed, by setting the &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; hook. The associated handler is called with the error text and can change the error message, if it sees fit, by calling &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; again. See &lt;a href=&quot;../perlvar#%25SIG&quot;&gt;%SIG in perlvar&lt;/a&gt; for details on setting &lt;code&gt;%SIG&lt;/code&gt; entries, and &lt;a href=&quot;#eval-BLOCK&quot;&gt;eval BLOCK&lt;/a&gt; for some examples. Although this feature was to be run only right before your program was to exit, this is not currently so: the &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; hook is currently called even inside eval()ed blocks/strings! If one wants the hook to do nothing in such situations, put</source>
          <target state="translated">&lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 후크 를 설정하여 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 가 작업을 수행하기 직전에 콜백을 실행할 수 있습니다 . 연관된 핸들러는 오류 텍스트와 함께 호출되며, 적절한 경우 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 를 다시 호출하여 오류 메시지를 변경할 수 있습니다 . &lt;code&gt;%SIG&lt;/code&gt; 항목 설정에 대한 자세한 내용 &lt;a href=&quot;../perlvar#%25SIG&quot;&gt;은 perlvar의 % SIG를&lt;/a&gt; 참조 하고 일부 예는 &lt;a href=&quot;#eval-BLOCK&quot;&gt;eval BLOCK&lt;/a&gt; 을 참조하십시오 . 이 기능은 프로그램이 종료되기 직전에 실행되었지만 현재는 그렇지 않습니다. &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 후크는 현재 eval () ed 블록 / 문자열 내부에서도 호출됩니다! 그러한 상황에서 후크가 아무것도하지 않기를 원한다면</target>
        </trans-unit>
        <trans-unit id="6d6ebe42604b8b630167882d7abe0a8f91ccbdb6" translate="yes" xml:space="preserve">
          <source>You can arrange for a callback to be run just before the &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; does its deed, by setting the &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; hook. The associated handler is called with the error text and can change the error message, if it sees fit, by calling &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; again. See &lt;a href=&quot;perlvar#%25SIG&quot;&gt;%SIG in perlvar&lt;/a&gt; for details on setting &lt;code&gt;%SIG&lt;/code&gt; entries, and &lt;a href=&quot;#eval-BLOCK&quot;&gt;eval BLOCK&lt;/a&gt; for some examples. Although this feature was to be run only right before your program was to exit, this is not currently so: the &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; hook is currently called even inside eval()ed blocks/strings! If one wants the hook to do nothing in such situations, put</source>
          <target state="translated">&lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 후크 를 설정하여 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 가 작업을 수행하기 직전에 콜백을 실행할 수 있습니다 . 연관된 핸들러는 오류 텍스트와 함께 호출되며, 적절한 경우 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 를 다시 호출하여 오류 메시지를 변경할 수 있습니다 . &lt;code&gt;%SIG&lt;/code&gt; 항목 설정에 대한 자세한 내용 &lt;a href=&quot;perlvar#%25SIG&quot;&gt;은 perlvar의 % SIG를&lt;/a&gt; 참조 하고 일부 예는 &lt;a href=&quot;#eval-BLOCK&quot;&gt;eval BLOCK&lt;/a&gt; 을 참조하십시오 . 이 기능은 프로그램이 종료되기 직전에 실행되었지만 현재는 그렇지 않습니다. &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 후크는 현재 eval () ed 블록 / 문자열 내부에서도 호출됩니다! 그러한 상황에서 후크가 아무것도하지 않기를 원한다면</target>
        </trans-unit>
        <trans-unit id="b111cf2dc7e21ab63d8886219ae9103dbe8e5745" translate="yes" xml:space="preserve">
          <source>You can ask &lt;code&gt;prove&lt;/code&gt; to remember the state of previous test runs and select and/or order the tests to be run based on that saved state.</source>
          <target state="translated">당신은 요청할 수 있습니다 &lt;code&gt;prove&lt;/code&gt; 이전 테스트 실행의 상태를 기억하고 선택 및 / 또는 저장 상태에 따라 실행되어야 할 시험 항목을 주문.</target>
        </trans-unit>
        <trans-unit id="5be6ec0673c2462bb7fe8ce793fcded60eef0f18" translate="yes" xml:space="preserve">
          <source>You can break circular references by creating a &quot;weak reference&quot;. A weak reference does not increment the reference count for a variable, which means that the object can go out of scope and be destroyed. You can weaken a reference with the &lt;code&gt;weaken&lt;/code&gt; function exported by the &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt; module.</source>
          <target state="translated">&quot;약한 참조&quot;를 작성하여 순환 참조를 끊을 수 있습니다. 약한 참조는 변수의 참조 카운트를 증가시키지 않으므로 개체가 범위를 벗어나 파괴 될 수 있습니다. &lt;a href=&quot;scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt; 모듈 에서 내 보낸 &lt;code&gt;weaken&lt;/code&gt; 함수를 사용하여 참조를 약화시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b50c9286c4042666f0e26f5a3f4bc1fff06eaf5" translate="yes" xml:space="preserve">
          <source>You can call the perl visible subroutine something other than &lt;code&gt;constant&lt;/code&gt; if you give the parameter</source>
          <target state="translated">파라미터를 지정 하면 perl visible 서브 루틴을 &lt;code&gt;constant&lt;/code&gt; 이외의 것으로 호출 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="03c6b44929e8d300ef044fa7166e3c54539d868d" translate="yes" xml:space="preserve">
          <source>You can capture its numeric and string content using:</source>
          <target state="translated">다음을 사용하여 숫자 및 문자열 컨텐츠를 캡처 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="596d44f0dc27aeca16b120bcaf752ef2dfa99248" translate="yes" xml:space="preserve">
          <source>You can categorize these CES by 3 criteria: size of each character, endianness, and Byte Order Mark.</source>
          <target state="translated">이러한 CES를 각 문자의 크기, 엔디안 및 바이트 순서 표시의 3 가지 기준으로 분류 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b889973d01196115807ed3e24800abe92e6ed58" translate="yes" xml:space="preserve">
          <source>You can change an array element, but you can't change a list element:</source>
          <target state="translated">배열 요소는 변경할 수 있지만 목록 요소는 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d178a91245c223a6b3d558a26825e4086182ea75" translate="yes" xml:space="preserve">
          <source>You can change both the effective gid and the real gid at the same time by using &lt;code&gt;POSIX::setgid()&lt;/code&gt; (use only a single numeric argument). Changes to &lt;code&gt;$)&lt;/code&gt; require a check to &lt;code&gt;$!&lt;/code&gt; to detect any possible errors after an attempted change.</source>
          <target state="translated">&lt;code&gt;POSIX::setgid()&lt;/code&gt; 를 사용하여 유효 gid와 실제 gid를 동시에 변경할 수 있습니다 (단일 숫자 인수 만 사용). &lt;code&gt;$)&lt;/code&gt; 로 변경하려면 $를 확인해야합니다 &lt;code&gt;$!&lt;/code&gt; 변경 시도 후 가능한 오류를 감지합니다.</target>
        </trans-unit>
        <trans-unit id="59d9719ad7d1133b142fc0ce7a1557db385a25a2" translate="yes" xml:space="preserve">
          <source>You can change both the effective uid and the real uid at the same time by using &lt;code&gt;POSIX::setuid()&lt;/code&gt; . Changes to &lt;code&gt;$&amp;gt;&lt;/code&gt; require a check to &lt;code&gt;$!&lt;/code&gt; to detect any possible errors after an attempted change.</source>
          <target state="translated">&lt;code&gt;POSIX::setuid()&lt;/code&gt; 사용하여 유효 uid와 실제 uid를 동시에 변경할 수 있습니다 . &lt;code&gt;$&amp;gt;&lt;/code&gt; 로 변경하려면 $를 확인해야합니다 &lt;code&gt;$!&lt;/code&gt; 변경 시도 후 가능한 오류를 감지합니다.</target>
        </trans-unit>
        <trans-unit id="57121de58d74f1a64c5b126aeda69842259d90c4" translate="yes" xml:space="preserve">
          <source>You can change both the real gid and the effective gid at the same time by using &lt;code&gt;POSIX::setgid()&lt;/code&gt; . Changes to &lt;code&gt;$(&lt;/code&gt; require a check to &lt;code&gt;$!&lt;/code&gt; to detect any possible errors after an attempted change.</source>
          <target state="translated">&lt;code&gt;POSIX::setgid()&lt;/code&gt; 사용하여 실제 gid와 유효 gid를 동시에 변경할 수 있습니다 . &lt;code&gt;$(&lt;/code&gt; 변경하면 변경 시도 후 가능한 오류를 감지 하기 위해 &lt;code&gt;$!&lt;/code&gt; 를 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b09c5405e2b602271ef0ef2f3017aa480c6d1079" translate="yes" xml:space="preserve">
          <source>You can change options from</source>
          <target state="translated">에서 옵션을 변경할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="d6315b4e978f53eeff4964ee1909c618fbc90cfa" translate="yes" xml:space="preserve">
          <source>You can change the underlying module that does the low-level math operations by using:</source>
          <target state="translated">다음을 사용하여 저수준 수학 연산을 수행하는 기본 모듈을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac0967b2c568b641678650e45e2b539ad81b2c7d" translate="yes" xml:space="preserve">
          <source>You can change this backend library by using:</source>
          <target state="translated">다음을 사용하여이 백엔드 라이브러리를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e271d7bee0eb9af50859c996a87b147d97ca08b1" translate="yes" xml:space="preserve">
          <source>You can change this by using:</source>
          <target state="translated">다음을 사용하여이를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8c0aadd56b5a3424b47f02ac266fd1fef206d7e" translate="yes" xml:space="preserve">
          <source>You can check the values of these variables on your system with</source>
          <target state="translated">시스템에서 이러한 변수의 값을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19186d4d2aa107ae87a9009974a30d3e15b94cd1" translate="yes" xml:space="preserve">
          <source>You can choose if you want to always install (yes), never install (no) or be always asked. In the latter case you can set the default answer for the question to yes (ask/yes) or no (ask/no).</source>
          <target state="translated">항상 설치 (yes), 설치 (no) 또는 항상 요청 여부를 선택할 수 있습니다. 후자의 경우 질문에 대한 기본 답변을 yes (ask / yes) 또는 no (ask / no)로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="432283768bc5fcc2cbc19482faa7326a0cb0200d" translate="yes" xml:space="preserve">
          <source>You can compare $s1 and $s2 above with</source>
          <target state="translated">위의 $ s1과 $ s2를 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cd28c9babbe3b0c5cce52c7e8b6bd3de247f8a7" translate="yes" xml:space="preserve">
          <source>You can compile a special debugging version of Perl, which allows you to use the &lt;code&gt;-D&lt;/code&gt; option of Perl to tell more about what Perl is doing. But sometimes there is no alternative than to dive in with a debugger, either to see the stack trace of a core dump (very useful in a bug report), or trying to figure out what went wrong before the core dump happened, or how did we end up having wrong or unexpected results.</source>
          <target state="translated">Perl의 특수 디버깅 버전을 컴파일 할 수 있으며 Perl의 &lt;code&gt;-D&lt;/code&gt; 옵션 을 사용하여 Perl이 수행하는 작업에 대해 더 자세히 알 수 있습니다. 그러나 때로는 코어 덤프의 스택 추적을 보거나 (버그 보고서에 매우 유용함) 코어 덤프가 발생하기 전에 무엇이 잘못되었는지 또는 어떻게 시도했는지 파악하기 위해 디버거를 사용하는 것 외에 대안이 없습니다. 우리는 잘못되거나 예기치 않은 결과를 낳습니다.</target>
        </trans-unit>
        <trans-unit id="87041007fca4b20217db14f0fb86e591cf75c1a4" translate="yes" xml:space="preserve">
          <source>You can compile perl as a universal binary (built for both ppc and intel). In Mac OS X 10.4 &quot;Tiger&quot;, you must export the 'u' variant of the SDK:</source>
          <target state="translated">perl을 범용 바이너리 (ppc 및 intel 용으로 빌드)로 컴파일 할 수 있습니다. Mac OS X 10.4 &quot;Tiger&quot;에서 SDK의 'u'변형을 내 보내야합니다.</target>
        </trans-unit>
        <trans-unit id="fa58ab427e59cc304b800becf278713e2a473dc4" translate="yes" xml:space="preserve">
          <source>You can compute spherical distances, called &lt;b&gt;great circle distances&lt;/b&gt;, by importing the great_circle_distance() function:</source>
          <target state="translated">great_circle_distance () 함수를 가져와 &lt;b&gt;큰&lt;/b&gt; 원거리라고하는 구면 거리를 계산할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e0e56eaab18c95d9fc59dbbcb6020dceb739e042" translate="yes" xml:space="preserve">
          <source>You can configure &lt;code&gt;CPAN.pm&lt;/code&gt; to automatically use this option too:</source>
          <target state="translated">이 옵션도 자동으로 사용 하도록 &lt;code&gt;CPAN.pm&lt;/code&gt; 을 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2d461022ba384996bf77747145dbd16f78eb1d3d" translate="yes" xml:space="preserve">
          <source>You can control which DBM library you use by loading that library before you call dbmopen():</source>
          <target state="translated">dbmopen ()을 호출하기 전에 해당 라이브러리를로드하여 사용하는 DBM 라이브러리를 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b63a08beb712c643691cdd9c1e77329f30769a82" translate="yes" xml:space="preserve">
          <source>You can create endless loops if the things you serialize via freeze() (for instance) point back to the object we're trying to serialize in the hook.</source>
          <target state="translated">예를 들어 freeze ()를 통해 직렬화하는 것이 후크에서 직렬화하려는 객체를 가리키는 경우 무한 루프를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cc300aa058401f33bcdc1d74e140c0960d7fa90" translate="yes" xml:space="preserve">
          <source>You can define for all tie types an UNTIE method that will be called at untie(). See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;The untie Gotcha&lt;/a&gt; below.</source>
          <target state="translated">모든 타이 유형에 대해 untie ()에서 호출 될 UNTIE 메소드를 정의 할 수 있습니다. 아래 &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;의 Untie Gotcha를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cd22b39009d785c43f4f9453185f24b021494e27" translate="yes" xml:space="preserve">
          <source>You can define your own binary character properties by defining subroutines whose names begin with &lt;code&gt;&quot;In&quot;&lt;/code&gt; or &lt;code&gt;&quot;Is&quot;&lt;/code&gt; . (The experimental feature &lt;a href=&quot;perlre#(%3f%5b-%5d)&quot;&gt;(?[ ]) in perlre&lt;/a&gt; provides an alternative which allows more complex definitions.) The subroutines can be defined in any package. The user-defined properties can be used in the regular expression &lt;code&gt;\p{}&lt;/code&gt; and &lt;code&gt;\P{}&lt;/code&gt; constructs; if you are using a user-defined property from a package other than the one you are in, you must specify its package in the &lt;code&gt;\p{}&lt;/code&gt; or &lt;code&gt;\P{}&lt;/code&gt; construct.</source>
          <target state="translated">이름이 &lt;code&gt;&quot;In&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;Is&quot;&lt;/code&gt; 로 시작하는 서브 루틴을 정의하여 고유 한 2 진 문자 특성을 정의 할 수 있습니다 . ( &lt;a href=&quot;perlre#(%3f%5b-%5d)&quot;&gt;perlre&lt;/a&gt; 의 실험 기능 (? []) 은 더 복잡한 정의를 허용하는 대안을 제공합니다.) 서브 루틴은 모든 패키지에서 정의 할 수 있습니다. 사용자 정의 특성은 정규식 &lt;code&gt;\p{}&lt;/code&gt; 및 &lt;code&gt;\P{}&lt;/code&gt; 구문 에서 사용할 수 있습니다 . 현재 패키지가 아닌 다른 패키지에서 사용자 정의 속성을 사용하는 경우 &lt;code&gt;\p{}&lt;/code&gt; 또는 &lt;code&gt;\P{}&lt;/code&gt; 구문에 패키지를 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="107745b2e3d0c30dbe6a28beb79e3db6db75115c" translate="yes" xml:space="preserve">
          <source>You can define your own character properties and use them in the regular expression with the &lt;code&gt;\p{}&lt;/code&gt; or &lt;code&gt;\P{}&lt;/code&gt; construct. See &lt;a href=&quot;#User-Defined-Character-Properties&quot;&gt;User-Defined Character Properties&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;\p{}&lt;/code&gt; 또는 &lt;code&gt;\P{}&lt;/code&gt; 구문을 사용하여 고유 한 문자 속성을 정의하고 정규식에서 사용할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;#User-Defined-Character-Properties&quot;&gt;사용자 정의 문자 속성&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9472dcd36f94375050dea75545931297e23f500b" translate="yes" xml:space="preserve">
          <source>You can detect the OS mode using &quot;isainfo -v&quot;, e.g.</source>
          <target state="translated">&quot;isainfo -v&quot;를 사용하여 OS 모드를 감지 할 수 있습니다 (예 :</target>
        </trans-unit>
        <trans-unit id="ac56709f3e046a38d3f4f58f4d03fe93d1a1a7f4" translate="yes" xml:space="preserve">
          <source>You can determine your system endianness with this incantation:</source>
          <target state="translated">이 주문으로 시스템 엔디안을 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e10ee4faf1824e9c84d1fdce76b93c2ae5f9fd0" translate="yes" xml:space="preserve">
          <source>You can disable &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; resets on fail with the &lt;code&gt;c&lt;/code&gt; flag, documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; and &lt;a href=&quot;perlreref&quot;&gt;perlreref&lt;/a&gt;. Subsequent matches start where the last successful match ended (the value of &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt;) even if a match on the same string has failed in the meantime. In this case, the match after the &lt;code&gt;while()&lt;/code&gt; loop starts at the &lt;code&gt;a&lt;/code&gt; (where the last match stopped), and since it does not use any anchor it can skip over the &lt;code&gt;a&lt;/code&gt; to find &lt;code&gt;44&lt;/code&gt; .</source>
          <target state="translated">&lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 및 &lt;a href=&quot;perlreref&quot;&gt;perlreref에&lt;/a&gt; 문서화 된 &lt;code&gt;c&lt;/code&gt; 플래그를 사용하여 실패시 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 재설정을 비활성화 할 수 있습니다 . 이후에 일치 하는 문자열은 일치하는 문자열이 일치하지 않더라도 마지막으로 성공한 일치가 종료 된 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 값 )에서 시작됩니다. 이 경우 &lt;code&gt;while()&lt;/code&gt; 루프 이후의 일치 는 &lt;code&gt;a&lt;/code&gt; (마지막 일치가 중지 된 위치) 에서 시작하며 앵커를 사용하지 않으므로 &lt;code&gt;a&lt;/code&gt; 를 건너 뛰어 &lt;code&gt;44&lt;/code&gt; 를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="458912b1d0d0c5a77d13c3e7ffc4ddad22f59daf" translate="yes" xml:space="preserve">
          <source>You can dispense with numbers altogether and create named capture groups. The notation is &lt;code&gt;(?&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;...)&lt;/code&gt; to declare and &lt;code&gt;\g{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt; to reference. (To be compatible with .Net regular expressions, &lt;code&gt;\g{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt; may also be written as &lt;code&gt;\k{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt;, &lt;code&gt;\k&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;\k'&lt;i&gt;name&lt;/i&gt;'&lt;/code&gt;.)</source>
          <target state="translated">숫자를 모두 사용하지 않고 명명 된 캡처 그룹을 만들 수 있습니다. 표기법은 &lt;code&gt;(?&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;...)&lt;/code&gt; 로 선언하고 &lt;code&gt;\g{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt; 으로 참조합니다. .Net 정규식과 호환되도록 &lt;code&gt;\g{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt; 을 &lt;code&gt;\k{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt; , &lt;code&gt;\k&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;\k'&lt;i&gt;name&lt;/i&gt;'&lt;/code&gt; 으로 쓸 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b18d3c8d444331784ad87d0c9066604ce83188e2" translate="yes" xml:space="preserve">
          <source>You can do a similar thing with the value of &lt;code&gt;$0&lt;/code&gt; , which holds the script name. That might hold a relative path, but &lt;code&gt;rel2abs&lt;/code&gt; can turn it into an absolute path. Once you have the</source>
          <target state="translated">스크립트 이름을 보유하는 &lt;code&gt;$0&lt;/code&gt; 값으로 비슷한 작업을 수행 할 수 있습니다 . 그것은 상대 경로를 &lt;code&gt;rel2abs&lt;/code&gt; 수 있지만 rel2abs 는 절대 경로로 바꿀 수 있습니다. 일단 당신이</target>
        </trans-unit>
        <trans-unit id="2cb0b5304ad3a2505b033f6205316fe91cd8667f" translate="yes" xml:space="preserve">
          <source>You can do it yourself:</source>
          <target state="translated">당신은 스스로 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="3df3594ac830b3b367e2449531bc9481e6c2c743" translate="yes" xml:space="preserve">
          <source>You can do some customization by setting up a</source>
          <target state="translated">당신은 설정하여 일부 사용자 정의를 수행 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="e36b0a11441d7f370d1c8f3b9a2c5df0ed14fec0" translate="yes" xml:space="preserve">
          <source>You can do the same thing with foreach and a match using the c flag and the \G anchor, if you do not mind your entire file being in memory at the end.</source>
          <target state="translated">전체 파일이 메모리에 있다는 것을 신경 쓰지 않으면 c 플래그와 \ G 앵커를 사용하여 foreach 및 match와 동일한 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94475bd1aa00e25358f732725451e1c48c0023a3" translate="yes" xml:space="preserve">
          <source>You can do this by filtering a list of &lt;code&gt;Archive::Tar::File&lt;/code&gt; objects based on your criteria. For example, to extract only files that have the string &lt;code&gt;foo&lt;/code&gt; in their title, you would use:</source>
          <target state="translated">기준에 따라 &lt;code&gt;Archive::Tar::File&lt;/code&gt; 객체 목록을 필터링하여이 작업을 수행 할 수 있습니다 . 예를 들어 제목에 문자열 &lt;code&gt;foo&lt;/code&gt; 가있는 파일 만 추출 하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e3b58ea141bf0b2ab8308eba04e2fe1187709b38" translate="yes" xml:space="preserve">
          <source>You can do this in</source>
          <target state="translated">당신은 이것을 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0e82d2d4c5fee3c3455ee13c93472ac8305c2886" translate="yes" xml:space="preserve">
          <source>You can do various useful things to lists:</source>
          <target state="translated">다음과 같이 다양한 유용한 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2293c83d7e9f41c388c0c9ef674c18441a39f91a" translate="yes" xml:space="preserve">
          <source>You can download the NDK from &lt;a href=&quot;http://developer.blackberry.com/native/downloads/&quot;&gt;http://developer.blackberry.com/native/downloads/&lt;/a&gt;.</source>
          <target state="translated">NDK는 &lt;a href=&quot;http://developer.blackberry.com/native/downloads/&quot;&gt;http://developer.blackberry.com/native/downloads/&lt;/a&gt; 에서 다운로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2add1e5f384d4e366c7f0bda81dca221784f796a" translate="yes" xml:space="preserve">
          <source>You can easily do this yourself too by checking each level of the hash before you move onto the next level. This is essentially what &lt;a href=&quot;http://search.cpan.org/perldoc/Data::Diver&quot;&gt;Data::Diver&lt;/a&gt; does for you:</source>
          <target state="translated">다음 레벨로 넘어 가기 전에 해시의 각 레벨을 확인하여 쉽게이 작업을 수행 할 수 있습니다. 이것은 본질적으로 &lt;a href=&quot;http://search.cpan.org/perldoc/Data::Diver&quot;&gt;Data :: Diver&lt;/a&gt; 가 당신을 위해하는 일입니다.</target>
        </trans-unit>
        <trans-unit id="aca937c9b8249ef74f6bdd2a2c24ef2b2c942c33" translate="yes" xml:space="preserve">
          <source>You can effect a sleep of 250 milliseconds this way:</source>
          <target state="translated">이런 식으로 250 밀리 초의 절전 모드를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cf03e7d8c028c108e1f07b9fdfd93ec5a0911cb" translate="yes" xml:space="preserve">
          <source>You can either get the latest perl-for-amiga source from Ninemoons and extract it with:</source>
          <target state="translated">Ninemoons에서 최신 perl-for-amiga 소스를 가져 와서 다음과 같이 추출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc1b686bd86f9825c512e3b19e24ca27d9b0e88c" translate="yes" xml:space="preserve">
          <source>You can embed Pod documentation in your Perl modules and scripts. Start your documentation with an empty line, a &quot;=head1&quot; command at the beginning, and end it with a &quot;=cut&quot; command and an empty line. The &lt;b&gt;perl&lt;/b&gt; executable will ignore the Pod text. You can place a Pod statement where &lt;b&gt;perl&lt;/b&gt; expects the beginning of a new statement, but not within a statement, as that would result in an error. See any of the supplied library modules for examples.</source>
          <target state="translated">Perl 모듈 및 스크립트에 포드 설명서를 포함시킬 수 있습니다. 빈 줄, 시작 부분에 &quot;= head1&quot;명령으로 문서를 시작하고 &quot;= cut&quot;명령 및 빈 줄로 끝냅니다. &lt;b&gt;펄&lt;/b&gt; 실행 파일은 포드 텍스트를 무시합니다. &lt;b&gt;Perl&lt;/b&gt; 이 새 명령문의 시작을 예상하지만 명령문 내에는 오류가 발생할 수있는 포드 명령문을 배치 할 수 있습니다 . 예제는 제공된 라이브러리 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4e8901a24d5203f278555dd6630e84e6495d5c32" translate="yes" xml:space="preserve">
          <source>You can enable automatic UTF-8-ification of your standard file handles, default &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; layer, and &lt;code&gt;@ARGV&lt;/code&gt; by using either the &lt;code&gt;-C&lt;/code&gt; command line switch or the &lt;code&gt;PERL_UNICODE&lt;/code&gt; environment variable, see &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; for the documentation of the &lt;code&gt;-C&lt;/code&gt; switch.</source>
          <target state="translated">당신은 표준 파일 핸들을 자동으로 UTF-8-ification 수 있도록 기본 수 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 층 및 &lt;code&gt;@ARGV&lt;/code&gt; 을 중 하나를 사용하여 &lt;code&gt;-C&lt;/code&gt; 명령 줄 스위치 또는 &lt;code&gt;PERL_UNICODE&lt;/code&gt; 의 환경 변수를 참조 &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; 의 문서에 대한 &lt;code&gt;-C&lt;/code&gt; 스위치.</target>
        </trans-unit>
        <trans-unit id="9b7d65e57af61c849fd344c325e8ff8558b6ea76" translate="yes" xml:space="preserve">
          <source>You can enable this program wide by setting the package variable &lt;code&gt;$Params::Check::VERBOSE&lt;/code&gt; to a true value. For details, see the section on &lt;code&gt;Global Variables&lt;/code&gt; below.</source>
          <target state="translated">패키지 변수 &lt;code&gt;$Params::Check::VERBOSE&lt;/code&gt; 를 true 값 으로 설정하여이 프로그램 전체를 사용할 수 있습니다 . 자세한 내용은 아래 &lt;code&gt;Global Variables&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bd9f5fdd175da39fdf1b2aee95117b6f24089729" translate="yes" xml:space="preserve">
          <source>You can even add a line to the beginning of a file, since the current line prints at the end of the loop:</source>
          <target state="translated">현재 줄이 루프의 끝에 인쇄되므로 파일의 시작 부분에 줄을 추가 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="469cbe63338eb0799dde10314ea7997fd8799ab7" translate="yes" xml:space="preserve">
          <source>You can even chain the operations together as usual:</source>
          <target state="translated">평소와 같이 작업을 함께 연결할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2aadc431d196d9bef8923dcadb3a5f0c2d7f67b9" translate="yes" xml:space="preserve">
          <source>You can even set them to pipe commands. For example, this automatically filters compressed arguments through &lt;b&gt;gzip&lt;/b&gt;:</source>
          <target state="translated">파이프 명령을 설정하도록 설정할 수도 있습니다. 예를 들어, &lt;b&gt;gzip을&lt;/b&gt; 통해 압축 된 인수를 자동으로 필터링합니다 .</target>
        </trans-unit>
        <trans-unit id="5959df3dd95aca5e6820f2cd7c4389121f214d69" translate="yes" xml:space="preserve">
          <source>You can examine the @INC variable from within a perl program to see the order in which Perl searches these directories.</source>
          <target state="translated">Perl 프로그램 내에서 @INC 변수를 검사하여 Perl이 이러한 디렉토리를 검색하는 순서를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b698e2e22416ac9eb31f0b1d16a0dd9b5e075ed0" translate="yes" xml:space="preserve">
          <source>You can expand the macros in a</source>
          <target state="translated">에서 매크로를 확장 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="c6984ea0cc547a7d94d70f8b198039214ca8c15f" translate="yes" xml:space="preserve">
          <source>You can explore the endianness of your platform by unpacking a data structure packed in native format such as:</source>
          <target state="translated">다음과 같은 기본 형식으로 압축 된 데이터 구조를 풀면 플랫폼의 엔디안을 탐색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25084ad020c81115ae6c13e15f94c38c747b7c70" translate="yes" xml:space="preserve">
          <source>You can explore various information from the Unicode data files using the &lt;code&gt;Unicode::UCD&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;Unicode::UCD&lt;/code&gt; 모듈을 사용하여 유니 코드 데이터 파일에서 다양한 정보를 탐색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="214226a1ed44146fabbcdf1d7ff955aea72e1c83" translate="yes" xml:space="preserve">
          <source>You can extend the data conversion shortcuts menu, so for example you can display an SV's IV value with one click, without doing any typing. To do that simply edit ~/.ddd/init file and add after:</source>
          <target state="translated">데이터 변환 바로 가기 메뉴를 확장 할 수 있으므로 예를 들어 입력하지 않고도 한 번의 클릭으로 SV의 IV 값을 표시 할 수 있습니다. 그렇게하려면 ~ / .ddd / init 파일을 편집 한 후 다음을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="9f3b19dace5e1ee6e80db897c83810c886662b0c" translate="yes" xml:space="preserve">
          <source>You can fake a static variable by using a lexical variable which goes out of scope. In this example, you define the subroutine &lt;code&gt;counter&lt;/code&gt; , and it uses the lexical variable &lt;code&gt;$count&lt;/code&gt; . Since you wrap this in a BEGIN block, &lt;code&gt;$count&lt;/code&gt; is defined at compile-time, but also goes out of scope at the end of the BEGIN block. The BEGIN block also ensures that the subroutine and the value it uses is defined at compile-time so the subroutine is ready to use just like any other subroutine, and you can put this code in the same place as other subroutines in the program text (i.e. at the end of the code, typically). The subroutine &lt;code&gt;counter&lt;/code&gt; still has a reference to the data, and is the only way you can access the value (and each time you do, you increment the value). The data in chunk of memory defined by &lt;code&gt;$count&lt;/code&gt; is private to &lt;code&gt;counter&lt;/code&gt; .</source>
          <target state="translated">범위를 벗어난 어휘 변수를 사용하여 정적 변수를 위조 할 수 있습니다. 이 예에서는 서브 루틴 &lt;code&gt;counter&lt;/code&gt; 를 정의 하고 어휘 변수 &lt;code&gt;$count&lt;/code&gt; 사용합니다 . 이것을 BEGIN 블록으로 래핑하기 때문에 &lt;code&gt;$count&lt;/code&gt; 는 컴파일 타임에 정의되지만 BEGIN 블록의 끝에서는 범위를 벗어납니다. BEGIN 블록은 또한 서브 루틴과 그 서브 루틴이 사용하는 값이 컴파일 타임에 정의되도록하여 서브 루틴이 다른 서브 루틴과 마찬가지로 사용할 준비가되었는지 확인하고 프로그램 텍스트의 다른 서브 루틴과 같은 위치에이 코드를 넣을 수 있습니다 ( 즉, 코드 끝에서) 서브 루틴 &lt;code&gt;counter&lt;/code&gt; 여전히 데이터에 대한 참조가 있으며 값에 액세스 할 수있는 유일한 방법입니다 (할 때마다 값을 증가시킵니다). &lt;code&gt;$count&lt;/code&gt; 의해 정의 된 메모리 청크의 데이터는 &lt;code&gt;counter&lt;/code&gt; 전용 입니다.</target>
        </trans-unit>
        <trans-unit id="98bfa69a23c16121bcf7918a14cd66f9c3c6d27f" translate="yes" xml:space="preserve">
          <source>You can find documentation for this module with the perldoc command.</source>
          <target state="translated">perldoc 명령으로이 모듈에 대한 문서를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ec893daacd3a612f16b5ff8e3b0ca737de8a9f5" translate="yes" xml:space="preserve">
          <source>You can find more info about Configure's command line switches in the</source>
          <target state="translated">Configure의 명령 행 스위치에 대한 자세한 정보는</target>
        </trans-unit>
        <trans-unit id="60d30b2a5683150ee021b2d2efe823e684b28b49" translate="yes" xml:space="preserve">
          <source>You can find out whether Perl considers &quot;long double&quot; to be the default floating-point size to use on your platform via &lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt;:</source>
          <target state="translated">Perl이 &quot;long double&quot;을 &lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt; 를 통해 플랫폼에서 사용할 기본 부동 소수점 크기로 간주하는지 여부를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0a14665644553d1c1ca40b3a369c0cfc1687919b" translate="yes" xml:space="preserve">
          <source>You can find out whether Perl considers &quot;long double&quot; to be the default floating-point size to use on your platform via &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt;:</source>
          <target state="translated">Perl이 &quot;long double&quot;을 &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; 를 통해 플랫폼에서 사용할 기본 부동 소수점 크기로 간주하는지 여부를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a8c0376796b23fff5ec186fab67f5500801dd3ed" translate="yes" xml:space="preserve">
          <source>You can find out whether your Perl supports quads via &lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt; 를 통해 Perl이 쿼드를 지원하는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="977c50ef8718482d8b17abe375d1697e8f9a2d66" translate="yes" xml:space="preserve">
          <source>You can find out whether your Perl supports quads via &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; 를 통해 Perl이 쿼드를 지원하는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="58566ff87e227e47e0a6175cb880b0492ff07d0d" translate="yes" xml:space="preserve">
          <source>You can find the bytes that make up a UTF-8 sequence with</source>
          <target state="translated">UTF-8 시퀀스를 구성하는 바이트를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d66bda1e5630ce31a16d647268de04ca99f2d093" translate="yes" xml:space="preserve">
          <source>You can find the full DJGPP distribution on any of the mirrors listed here:</source>
          <target state="translated">여기에 나열된 모든 미러에서 전체 DJGPP 배포를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53a7bd12f9a84d4d155f8bc43066fe15624ba305" translate="yes" xml:space="preserve">
          <source>You can find them for example by</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="abd3b038a5876faa8d912c01ba340b1b8ceaabfa" translate="yes" xml:space="preserve">
          <source>You can follow the formats with numbers to say how many characters should be affected by that format: &lt;code&gt;A12&lt;/code&gt; means &quot;take 12 characters&quot;; &lt;code&gt;x6&lt;/code&gt; means &quot;skip 6 bytes&quot; or &quot;character 0, 6 times&quot;.</source>
          <target state="translated">숫자로 된 형식을 따라 해당 형식의 영향을받는 문자 수를 말할 수 있습니다. &lt;code&gt;A12&lt;/code&gt; 는 &quot;12 자 사용&quot;을 의미합니다. &lt;code&gt;x6&lt;/code&gt; 은 &quot;6 바이트 건너 뛰기&quot;또는 &quot;문자 0, 6 회&quot;를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3e5ffde15ed2080164a5592bd7bb881aeab7fa67" translate="yes" xml:space="preserve">
          <source>You can force Perl to interpret the bareword as a class name by appending &quot;::&quot; to it, like we saw earlier:</source>
          <target state="translated">앞에서 본 것처럼 &quot;::&quot;를 추가하여 Perl이 기본 단어를 클래스 이름으로 해석하도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a0f7fd6c71d8ef00acad73e562310bfdc7188b5" translate="yes" xml:space="preserve">
          <source>You can force Perl to use the first interpretation (i.e. as a method call on the class named &quot;Class&quot;) in two ways. First, you can append a &lt;code&gt;::&lt;/code&gt; to the class name:</source>
          <target state="translated">Perl이 두 가지 방식으로 첫 번째 해석 (즉, &quot;Class&quot;라는 클래스의 메소드 호출)을 사용하도록 할 수 있습니다. 먼저 클래스 이름에 &lt;code&gt;::&lt;/code&gt; 를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3683b364293548110b32df191aa4769c6b0d7861" translate="yes" xml:space="preserve">
          <source>You can force a backreference interpretation always by using the &lt;code&gt;\g{...}&lt;/code&gt; form. You can the force an octal interpretation always by using the &lt;code&gt;\o{...}&lt;/code&gt; form, or for numbers up through \077 (= 63 decimal), by using three digits, beginning with a &quot;0&quot;.</source>
          <target state="translated">&lt;code&gt;\g{...}&lt;/code&gt; 양식 을 사용하여 역 참조 해석을 항상 강제 할 수 있습니다 . &lt;code&gt;\o{...}&lt;/code&gt; 형식을 사용하거나 &quot;0&quot;으로 시작하는 세 자리 숫자를 사용하여 \ 077 (= 10 진수 63)까지의 숫자 를 사용하여 8 진 해석을 강제로 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b877192684c9091db1ed512a1471d2f292aa330b" translate="yes" xml:space="preserve">
          <source>You can force an SV to make its own copy of its string buffer by calling &lt;code&gt;sv_force_normal(sv)&lt;/code&gt; or SvPV_force_nolen(sv).</source>
          <target state="translated">&lt;code&gt;sv_force_normal(sv)&lt;/code&gt; 또는 SvPV_force_nolen (sv) 를 호출하여 SV가 자체 문자열 버퍼 사본을 만들도록 강제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="59bd5097130055276750c2a4628acf949f4c2e6b" translate="yes" xml:space="preserve">
          <source>You can get a precompiled version of gcc from &lt;a href=&quot;http://www.sunfreeware.com/&quot;&gt;http://www.sunfreeware.com/&lt;/a&gt; or &lt;a href=&quot;http://www.blastwave.org/&quot;&gt;http://www.blastwave.org/&lt;/a&gt;. Make sure you pick up the package for your Solaris release.</source>
          <target state="translated">&lt;a href=&quot;http://www.sunfreeware.com/&quot;&gt;http://www.sunfreeware.com/&lt;/a&gt; 또는 &lt;a href=&quot;http://www.blastwave.org/&quot;&gt;http://www.blastwave.org/&lt;/a&gt; 에서 사전 컴파일 된 gcc 버전을 얻을 수 있습니다 . Solaris 릴리스 용 패키지를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="6c43b7d416e3df44e0ee3889ce9e7a7e5b755245" translate="yes" xml:space="preserve">
          <source>You can get an overview of all the files with this command:</source>
          <target state="translated">이 명령으로 모든 파일에 대한 개요를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a325b2e4941194b844aaba1d34803d7f10c46f65" translate="yes" xml:space="preserve">
          <source>You can get and set the current length of the string stored in an SV with the following macros:</source>
          <target state="translated">다음 매크로를 사용하여 SV에 저장된 문자열의 현재 길이를 가져오고 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="498e28fc3884e7bafa55f40835a491ab14376104" translate="yes" xml:space="preserve">
          <source>You can get around this in several ways depending on our situation. First, if you don't want any of the characters in the string to be special, you can escape them with &lt;code&gt;&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;&lt;/code&gt; before you use the string.</source>
          <target state="translated">상황에 따라 여러 가지 방법으로이 문제를 해결할 수 있습니다. 먼저 문자열의 문자 중 특수 문자를 원하지 않으면 문자열을 사용하기 전에 &lt;code&gt;&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;&lt;/code&gt; 로 이스케이프 처리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="2880274dc7c0ec586da21bf05619e960d62718ce" translate="yes" xml:space="preserve">
          <source>You can get at any of these quantities from C very easily; just add &lt;code&gt;Sv&lt;/code&gt; to the name of the field shown in the snippet, and you've got a macro which will return the value: &lt;code&gt;SvCUR(sv)&lt;/code&gt; returns the current length of the string, &lt;code&gt;SvREFCOUNT(sv)&lt;/code&gt; returns the reference count, &lt;code&gt;SvPV(sv, len)&lt;/code&gt; returns the string itself with its length, and so on. More macros to manipulate these properties can be found in &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;.</source>
          <target state="translated">C에서 이러한 수량을 매우 쉽게 얻을 수 있습니다. 스 니펫에 표시된 필드 이름에 &lt;code&gt;Sv&lt;/code&gt; 를 추가 하면 값을 반환하는 매크로가 있습니다. &lt;code&gt;SvCUR(sv)&lt;/code&gt; 는 문자열의 현재 길이를 반환하고 &lt;code&gt;SvREFCOUNT(sv)&lt;/code&gt; 는 참조 카운트를 반환합니다. &lt;code&gt;SvPV(sv, len)&lt;/code&gt; 은 문자열 자체의 길이 등을 반환합니다. 이러한 속성을 조작하는 더 많은 매크로는 &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="98610d953793b8d3a809dccac32eb0df790fe7b6" translate="yes" xml:space="preserve">
          <source>You can get at lists of keys and values with &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values()&lt;/a&gt;&lt;/code&gt; 로 키와 값 목록을 얻을 수 있습니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
