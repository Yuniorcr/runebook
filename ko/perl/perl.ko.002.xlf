<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="978247bca9d3403d64cf859ab2ed2b97f350fddd" translate="yes" xml:space="preserve">
          <source>(F) The regular expression pattern had too many occurrences of the specified modifier. Remove the extraneous ones.</source>
          <target state="translated">(F) 정규 표현식 패턴에 지정된 수정자가 너무 많이 발생했습니다. 불필요한 것을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="fb146807dd8bffd1d737ec18cf6785cbc786b9a1" translate="yes" xml:space="preserve">
          <source>(F) The return statement was executed in mainline code, that is, where there was no subroutine call to return out of. See &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="translated">(F) 리턴 문은 메인 라인 코드, 즉 리턴 할 서브 루틴 호출이없는 곳에서 실행되었습니다. &lt;a href=&quot;perlsub&quot;&gt;perlsub를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6098a03f6f4d905a3c17e165f83f7e82f485e102" translate="yes" xml:space="preserve">
          <source>(F) The script run under suidperl was somehow illegal.</source>
          <target state="translated">(F) suidperl에서 실행되는 스크립트는 어떻게 든 불법이었습니다.</target>
        </trans-unit>
        <trans-unit id="d1e6728e09976d12977cdb710ec12cd9d87f9a0b" translate="yes" xml:space="preserve">
          <source>(F) The script you specified can't be opened for the indicated reason.</source>
          <target state="translated">(F) 지정한 이유로 지정된 스크립트를 열 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c648c9167e0761d360e421e5c128edf829466521" translate="yes" xml:space="preserve">
          <source>(F) The second argument of 3-argument open() is not among the list of valid modes: &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;+&amp;lt;&lt;/code&gt; , &lt;code&gt;+&amp;gt;&lt;/code&gt;, &lt;code&gt;+&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;-|&lt;/code&gt;, &lt;code&gt;|-&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;amp;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">(F) 3- 인수 open ()의 두 번째 인수는 유효한 모드 목록에 없습니다 : &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;+&amp;lt;&lt;/code&gt; , &lt;code&gt;+&amp;gt;&lt;/code&gt; , &lt;code&gt;+&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;-|&lt;/code&gt; , &lt;code&gt;|-&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;amp;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78f88cd4d7e8c9f262e06df604cf9589c1386aa8" translate="yes" xml:space="preserve">
          <source>(F) The second listed construct is no longer legal. Use the first one instead.</source>
          <target state="translated">(F) 두 번째로 나열된 구조물은 더 이상 합법적이지 않습니다. 대신 첫 번째 것을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="73565677aef5a71d0d726d26b5138853a074975a" translate="yes" xml:space="preserve">
          <source>(F) The sort comparison routine specified doesn't seem to exist. Perhaps it's in a different package? See &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;.</source>
          <target state="translated">(F) 지정된 정렬 비교 루틴이 존재하지 않는 것 같습니다. 아마도 다른 패키지에 있습니까? &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0114042314b08da396c0973351c4c1d64ff26560" translate="yes" xml:space="preserve">
          <source>(F) The sort comparison routine specified is declared but doesn't seem to have been defined yet. See &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;.</source>
          <target state="translated">(F) 지정된 정렬 비교 루틴이 선언되었지만 아직 정의되지 않은 것 같습니다. &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="02a44bb32e2ab71cac8eb5e93643e84ef0b50f70" translate="yes" xml:space="preserve">
          <source>(F) The subroutine in question in the CORE package requires its argument to be a hard reference to data of the specified type. Overloading is ignored, so a reference to an object that is not the specified type, but nonetheless has overloading to handle it, will still not be accepted.</source>
          <target state="translated">(F) CORE 패키지의 해당 서브 루틴은 인수가 지정된 유형의 데이터에 대한 하드 참조 여야합니다. 오버로드는 무시되므로 지정된 유형이 아니지만 처리 할 오버로드가있는 객체에 대한 참조는 여전히 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="131b2b4686de1d556c01d4dd1862fb8a2b9f3187" translate="yes" xml:space="preserve">
          <source>(F) The subroutine indicated hasn't been defined, or if it was, it has since been undefined.</source>
          <target state="translated">(F) 표시된 서브 루틴이 정의되지 않았거나 정의 되었으면 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="0d461a2225c0d1f6184ed9b285bc83659756adc9" translate="yes" xml:space="preserve">
          <source>(F) The subroutine registered to handle constant overloading (see &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt;) or a custom charnames handler (see &lt;a href=&quot;charnames#CUSTOM-TRANSLATORS&quot;&gt;CUSTOM TRANSLATORS in charnames&lt;/a&gt;) returned an undefined value.</source>
          <target state="translated">(F)은 서브 루틴은 일정 오버로딩 (참조 처리 등록 &lt;a href=&quot;overload&quot;&gt;과부하&lt;/a&gt; ) 또는 커스텀 charnames 핸들러 (참조 &lt;a href=&quot;charnames#CUSTOM-TRANSLATORS&quot;&gt;charnames의 맞춤 번역자&lt;/a&gt; ) 정의되지 않은 값을 반환.</target>
        </trans-unit>
        <trans-unit id="c1f9080c71015e15b2ade1852b5bbb2f135fe334" translate="yes" xml:space="preserve">
          <source>(F) The syntax for lexically scoped subroutines requires that they have a name with which they can be found.</source>
          <target state="translated">(F) 어휘 범위가 지정된 서브 루틴의 구문에는 찾을 수있는 이름이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="86799c3802b5c3eb669f8d1b3abde88c1c85b55b" translate="yes" xml:space="preserve">
          <source>(F) The target of a msgrcv must be modifiable to be used as a receive buffer.</source>
          <target state="translated">(F) msgrcv의 대상은 수신 버퍼로 사용되도록 수정 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="c47bab31a98eb7d154cf82e3145e626849df19bc" translate="yes" xml:space="preserve">
          <source>(F) The two-character sequence &lt;code&gt;&quot;(*&quot;&lt;/code&gt; in this context in a regular expression pattern should be an indivisible token, with nothing intervening between the &lt;code&gt;&quot;(&quot;&lt;/code&gt; and the &lt;code&gt;&quot;*&quot;&lt;/code&gt; , but you separated them.</source>
          <target state="translated">(F) 이 문맥에서 정규 표현식 패턴 의 두 문자 시퀀스 &lt;code&gt;&quot;(*&quot;&lt;/code&gt; ) 는 &lt;code&gt;&quot;(&quot;&lt;/code&gt; 와 &lt;code&gt;&quot;*&quot;&lt;/code&gt; 사이에 개입하지 않는 불가분의 토큰이어야 하지만 분리했습니다.</target>
        </trans-unit>
        <trans-unit id="4ac1f45a5d66d522a06ae2f21cbf7d78e02aefd3" translate="yes" xml:space="preserve">
          <source>(F) The two-character sequence &lt;code&gt;&quot;(?&quot;&lt;/code&gt; in this context in a regular expression pattern should be an indivisible token, with nothing intervening between the &lt;code&gt;&quot;(&quot;&lt;/code&gt; and the &lt;code&gt;&quot;?&quot;&lt;/code&gt; , but you separated them with whitespace.</source>
          <target state="translated">(F) 이 문맥에서 정규 표현식 패턴 의 두 문자 시퀀스 &lt;code&gt;&quot;(?&quot;&lt;/code&gt; ) 는 &lt;code&gt;&quot;(&quot;&lt;/code&gt; 와 &lt;code&gt;&quot;?&quot;&lt;/code&gt; 사이에 개입하지 않는 불가분의 토큰이어야 하지만 공백으로 분리했습니다.</target>
        </trans-unit>
        <trans-unit id="6338350125dc05e2da942c8c96cdce98dfcfd9d1" translate="yes" xml:space="preserve">
          <source>(F) The unexec() routine failed for some reason. See your local FSF representative, who probably put it there in the first place.</source>
          <target state="translated">(F) 어떤 이유로 unexec () 루틴이 실패했습니다. 현지 FSF 담당자에게 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="431a67d1b0cf465108eb9ceb89999cf7e8b51c44" translate="yes" xml:space="preserve">
          <source>(F) The unpack format P must have an explicit size, not &quot;*&quot;.</source>
          <target state="translated">(F) 압축 해제 형식 P는 &quot;*&quot;가 아닌 명시적인 크기를 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="90d726bde677246d10d511c73ddeeacfe08405ad" translate="yes" xml:space="preserve">
          <source>(F) The yacc parser wanted to grow its stack so it could continue parsing, but realloc() wouldn't give it more memory, virtual or otherwise.</source>
          <target state="translated">(F) yacc 파서는 스택을 확장하여 파싱을 계속할 수 있기를 원했지만 realloc ()은 더 많은 메모리, 가상 또는 기타 메모리를 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f44de810af73fea203323979aad815bcd7d9964d" translate="yes" xml:space="preserve">
          <source>(F) There has to be at least one argument to syscall() to specify the system call to call, silly dilly.</source>
          <target state="translated">(F) 호출 할 시스템 호출을 지정하려면 syscall ()에 하나 이상의 인수가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="a2f074a2e8ab346dbefe5fa4f7b6b35652a24964" translate="yes" xml:space="preserve">
          <source>(F) There is a hard limit to how big a character code point can be due to the fundamental properties of UTF-8, especially on EBCDIC platforms. The given code point exceeds that. The only work-around is to not use such a large code point.</source>
          <target state="translated">(F) UTF-8의 기본 특성, 특히 EBCDIC 플랫폼에서 문자 코드 포인트가 얼마나 클 수 있는지에 대한 제한이 있습니다. 주어진 코드 포인트가 그것을 초과합니다. 유일한 해결 방법은 그러한 큰 코드 포인트를 사용하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9f380236fa00fb1337e61e1e26cdde838c333724" translate="yes" xml:space="preserve">
          <source>(F) There is currently a limit on the length of string which lookbehind can handle. This restriction may be eased in a future release.</source>
          <target state="translated">(F) 현재 lookbehind가 처리 할 수있는 문자열의 길이에는 제한이 있습니다. 이 제한은 향후 릴리스에서 완화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8990b5566ba1d2c523ac5cbce2e5c82b254a3379" translate="yes" xml:space="preserve">
          <source>(F) There is currently a limit to the size of the min and max values of the {min,max} construct. The &amp;lt;-- HERE shows whereabouts in the regular expression the problem was discovered. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">(F) 현재 {min, max} 구문의 최소값과 최대 값의 크기에 제한이 있습니다. &amp;lt;-HERE는 정규식에서 문제가 발견 된 위치를 보여줍니다. &lt;a href=&quot;perlre&quot;&gt;perlre를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9d7d3d2963c2637edd12f3dffba89994c2d2f7a9" translate="yes" xml:space="preserve">
          <source>(F) There was a syntax error within the &lt;code&gt;(?[ ])&lt;/code&gt; . This can happen if the expression inside the construct was completely empty, or if there are too many or few operands for the number of operators. Perl is not smart enough to give you a more precise indication as to what is wrong.</source>
          <target state="translated">(F) &lt;code&gt;(?[ ])&lt;/code&gt; 내에 구문 오류가있었습니다 . 구문 내부의 표현식이 완전히 비어 있거나 연산자 수에 비해 피연산자가 너무 많거나 적은 경우에 발생할 수 있습니다. Perl은 무엇이 잘못되었는지에 대한보다 정확한 표시를 제공 할만큼 똑똑하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4eb4ec6847fb1118e2525f7981c3417b2f856d1d" translate="yes" xml:space="preserve">
          <source>(F) These three characters may not appear in sequence in a double-quotish context. This message is raised only on non-ASCII platforms (a different error message is output on ASCII ones). If you were intending to specify a control character with this sequence, you'll have to use a different way to specify it.</source>
          <target state="translated">(F)이 세 문자는 큰 따옴표 문맥에서 순서대로 나타나지 않을 수 있습니다. 이 메시지는 비 ASCII 플랫폼에서만 발생합니다 (ASCII 플랫폼에서는 다른 오류 메시지가 출력 됨). 이 순서로 제어 문자를 지정하려면 다른 방법으로 제어 문자를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="d0fbd9a1ce33856fbe443b09236ca0d2e6033730" translate="yes" xml:space="preserve">
          <source>(F) This attribute was never supported on &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; declarations.</source>
          <target state="translated">(F)이 속성은 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 선언 에서 지원되지 않았다 .</target>
        </trans-unit>
        <trans-unit id="0873a290fa7a085e52a7a007966e3db2d08ff859" translate="yes" xml:space="preserve">
          <source>(F) This error is likely to occur if you run a perl5 script through a perl4 interpreter, especially if the next 2 tokens are &quot;use strict&quot; or &quot;my $var&quot; or &quot;our $var&quot;.</source>
          <target state="translated">(F)이 오류는 perl4 인터프리터를 통해 perl5 스크립트를 실행할 경우, 특히 다음 2 개의 토큰이 &quot;엄격한 사용&quot;또는 &quot;my $ var&quot;또는 &quot;our $ var&quot;인 경우 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="072063c3c77b06ca14bcbe935ab879cda865cbc8" translate="yes" xml:space="preserve">
          <source>(F) This function requires the argument in that position to be of a certain type. Arrays must be @NAME or &lt;code&gt;@{EXPR}&lt;/code&gt; . Hashes must be %NAME or &lt;code&gt;%{EXPR}&lt;/code&gt; . No implicit dereferencing is allowed--use the {EXPR} forms as an explicit dereference. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">(F)이 함수는 해당 위치의 인수가 특정 유형이어야합니다. 배열은 @NAME 또는 &lt;code&gt;@{EXPR}&lt;/code&gt; 이어야합니다 . 해시는 % NAME 또는 &lt;code&gt;%{EXPR}&lt;/code&gt; 이어야합니다 . 암시 적 역 참조는 허용되지 않습니다. {EXPR} 양식을 명시 적 역 참조로 사용하십시오. &lt;a href=&quot;perlref&quot;&gt;perlref를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1150339443a2f3fcc56e05f6118226e750c50df8" translate="yes" xml:space="preserve">
          <source>(F) This machine doesn't have either waitpid() or wait4(), so only waitpid() without flags is emulated.</source>
          <target state="translated">(F)이 머신에는 waitpid () 또는 wait4 ()가 없으므로 플래그가없는 waitpid () 만 에뮬레이트됩니다.</target>
        </trans-unit>
        <trans-unit id="fd0654da02073cc9adf857d0c5788597f5428534" translate="yes" xml:space="preserve">
          <source>(F) This machine doesn't implement the indicated function, apparently. At least, Configure doesn't think so.</source>
          <target state="translated">(F)이 기계는 표시된 기능을 구현하지 않은 것 같습니다. 적어도 Configure는 그렇게 생각하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d9555c2ff07536a7cbecd77280984ed7335b6ec" translate="yes" xml:space="preserve">
          <source>(F) This machine doesn't implement the select() system call.</source>
          <target state="translated">(F)이 시스템은 select () 시스템 호출을 구현하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8dc3e365a694fcea3f4c0e265853724c37e64b9f" translate="yes" xml:space="preserve">
          <source>(F) This message occurs when a here document label has an initial quotation mark but the final quotation mark is missing. Perhaps you wrote:</source>
          <target state="translated">(F)이 메시지는 here 문서 레이블에 초기 인용 부호가 있지만 최종 인용 부호가없는 경우에 발생합니다. 아마도 당신은 썼다 :</target>
        </trans-unit>
        <trans-unit id="a9c87d2ef6abbf95bce14ad28895eeb35849f28e" translate="yes" xml:space="preserve">
          <source>(F) To do aliasing via references, you must first enable the feature:</source>
          <target state="translated">(F) 참조를 통해 앨리어싱을 수행하려면 먼저 기능을 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="c4f74a0f4a79056501938fe765e53b471441e18b" translate="yes" xml:space="preserve">
          <source>(F) To use lexical subs, you must first enable them:</source>
          <target state="translated">(F) 어휘 하위를 사용하려면 먼저 다음을 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="ce0b329dc2a2c16604936f52a5411eec19f03eb8" translate="yes" xml:space="preserve">
          <source>(F) To use subroutine signatures, you must first enable them:</source>
          <target state="translated">(F) 서브 루틴 서명을 사용하려면 먼저 서명을 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="9abc2a089bebce3d14588d841da52d24618c89c6" translate="yes" xml:space="preserve">
          <source>(F) Turning off the given modifier has the side effect of turning on another one. Perl currently doesn't allow this. Reword the regular expression to use the modifier you want to turn on (and place it before the minus), instead of the one you want to turn off.</source>
          <target state="translated">(F) 주어진 수정자를 끄면 다른 수정자를 켜는 부작용이 있습니다. 펄은 현재 이것을 허용하지 않습니다. 정규식의 단어를 바꾸려면 끄려는 수정 자 대신 켜려는 수정자를 사용하고 빼기 앞에 배치하십시오.</target>
        </trans-unit>
        <trans-unit id="6197e8e862dcf3b1e9487203e3bdd41fc94f2119" translate="yes" xml:space="preserve">
          <source>(F) Unbackslashed parentheses must always be balanced in regular expressions. If you're a vi user, the % key is valuable for finding the matching parenthesis. The &amp;lt;-- HERE shows whereabouts in the regular expression the problem was discovered. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">(F) 백 슬래시가없는 괄호는 항상 정규 표현식에서 균형을 이루어야합니다. vi 사용자 인 경우 % 키는 일치하는 괄호를 찾는 데 유용합니다. &amp;lt;-HERE는 정규식에서 문제가 발견 된 위치를 보여줍니다. &lt;a href=&quot;perlre&quot;&gt;perlre를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ef132c317497935108203b678529cc021105f980" translate="yes" xml:space="preserve">
          <source>(F) Unlike with &quot;next&quot; or &quot;last&quot;, you're not allowed to goto an unspecified destination. See &lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;.</source>
          <target state="translated">(F) &quot;다음&quot;또는 &quot;마지막&quot;과 달리 지정되지 않은 목적지로 이동할 수 없습니다. &lt;a href=&quot;functions/goto&quot;&gt;고토&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="a69241a833fdee19eac50524c07efa679cbe144b" translate="yes" xml:space="preserve">
          <source>(F) Using the &lt;code&gt;!~&lt;/code&gt; operator with &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///r&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///r&lt;/a&gt;&lt;/code&gt; is currently reserved for future use, as the exact behavior has not been decided. (Simply returning the boolean opposite of the modified string is usually not particularly useful.)</source>
          <target state="translated">(F) &lt;code&gt;!~&lt;/code&gt; 연산자를 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///r&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///r&lt;/a&gt;&lt;/code&gt; 정확한 동작이 결정되지 않았으므로 것은 현재 사용하도록 예약되어 있습니다. (수정 된 문자열의 부울 반대쪽을 반환하는 것만으로는 특히 유용하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="9f376943797958f9715d499865da4a5eec3ac339" translate="yes" xml:space="preserve">
          <source>(F) When &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; is called in an lvalue context, the second argument must be greater than or equal to zero.</source>
          <target state="translated">(F) &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; 때 lvalue 컨텍스트에서 가 호출 두 번째 인수는 0보다 크거나 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="8d156b4640c10bcbe7a47acc356f8e9dc776289b" translate="yes" xml:space="preserve">
          <source>(F) When compiling a regex pattern, an unresolved named character or sequence was encountered. This can happen in any of several ways that bypass the lexer, such as using single-quotish context, or an extra backslash in double-quotish:</source>
          <target state="translated">(F) 정규식 패턴을 컴파일 할 때 해결되지 않은 명명 된 문자 또는 시퀀스가 ​​발생했습니다. 이는 단일 인용 컨텍스트를 사용하거나 이중 인용으로 여분의 백 슬래시를 사용하는 것과 같이 어휘 분석기를 우회하는 여러 가지 방법으로 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe723f68464447de981e4ddb6e078b0eaf3c11d2" translate="yes" xml:space="preserve">
          <source>(F) When the &quot;array_base&quot; feature is disabled (e.g., under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16;&lt;/code&gt; ) the special variable &lt;code&gt;$[&lt;/code&gt; , which is deprecated, is now a fixed zero value.</source>
          <target state="translated">(F) &quot;array_base&quot;기능이 비활성화 된 경우 (예 : &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16;&lt;/code&gt; ) 특수 변수 &lt;code&gt;$[&lt;/code&gt; 더 이상 사용되지 않는 는 이제 고정 된 0 값입니다.</target>
        </trans-unit>
        <trans-unit id="f3c9b4275675f1ccb22d79246d69cfb1e07c9cda" translate="yes" xml:space="preserve">
          <source>(F) When trying to initialize the random seed for hashes, Perl could not get any randomness out of your system. This usually indicates Something Very Wrong.</source>
          <target state="translated">(F) 해시의 랜덤 시드를 초기화하려고 할 때, Perl은 시스템에서 임의성을 얻을 수 없습니다. 이것은 대개 뭔가 잘못되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="429d342ada3c44defc7898eb10baa70d3135766a" translate="yes" xml:space="preserve">
          <source>(F) When using the &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; keyword to construct an anonymous subroutine, you must always specify a block of code. See &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="translated">(F) &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 키워드를 사용하여 익명 서브 루틴을 구성 할 때는 항상 코드 블록을 지정해야합니다. &lt;a href=&quot;perlsub&quot;&gt;perlsub를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="27df7cdfafc4264c73dc05b85aa8988bb48958bd" translate="yes" xml:space="preserve">
          <source>(F) While calculating the method resolution order (MRO) of a package, Perl believes it found an infinite loop in the &lt;code&gt;@ISA&lt;/code&gt; hierarchy. This is a crude check that bails out after 100 levels of &lt;code&gt;@ISA&lt;/code&gt; depth.</source>
          <target state="translated">(F) 패키지의 MRO (Method Resolution Order)를 계산하는 동안 Perl은 &lt;code&gt;@ISA&lt;/code&gt; 계층 에서 무한 루프를 발견했다고 생각합니다 . 이것은 100 레벨의 &lt;code&gt;@ISA&lt;/code&gt; 깊이 후에 구제되는 조잡한 검사입니다 .</target>
        </trans-unit>
        <trans-unit id="4f646db7bb15defe8dcbadd597ceedd7f3094d3f" translate="yes" xml:space="preserve">
          <source>(F) While certain functions allow you to specify a filehandle or an &quot;indirect object&quot; before the argument list, this ain't one of them.</source>
          <target state="translated">(F) 특정 함수를 사용하면 인수 목록 앞에 파일 핸들 또는 &quot;간접 객체&quot;를 지정할 수 있지만이 중 하나가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7704c3dc27f023396cfb31711ae6b4d2c36c63ab" translate="yes" xml:space="preserve">
          <source>(F) While under the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest&lt;/code&gt; pragma, switching the real and effective uids or gids failed.</source>
          <target state="translated">(F) &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest&lt;/code&gt; pragma를 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하는 동안 실제적이고 효과적인 uid 또는 gid를 전환하는 데 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="1936a7a9cbb0a3cddb41548a792c3cf332475e2f" translate="yes" xml:space="preserve">
          <source>(F) While under the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest&lt;/code&gt; pragma, we cannot switch the real and effective uids or gids.</source>
          <target state="translated">(F) &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest&lt;/code&gt; pragma를 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하는 동안에는 실제적이고 효과적인 uid 또는 gid를 전환 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="88b481d25e0c70a1fc8e1c7329f7e69ee3d1c763" translate="yes" xml:space="preserve">
          <source>(F) While unpacking, the string buffer was already used up when an unpack length/code combination tried to obtain more data. This results in an undefined value for the length. See &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;.</source>
          <target state="translated">(F) 압축 풀기 중에 압축 풀기 길이 / 코드 조합이 더 많은 데이터를 얻으려고 할 때 문자열 버퍼가 이미 사용되었습니다. 결과적으로 길이에 대한 값이 정의되지 않습니다. &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="085e32de8d9a6f788cee92e9844af3b934798795" translate="yes" xml:space="preserve">
          <source>(F) With &quot;strict subs&quot; in use, a bareword is only allowed as a subroutine identifier, in curly brackets or to the left of the &quot;=&amp;gt;&quot; symbol. Perhaps you need to predeclare a subroutine?</source>
          <target state="translated">(F) &quot;엄격한 하위&quot;를 사용하는 경우 베어 워드는 중괄호 또는 &quot;=&amp;gt;&quot;기호의 왼쪽에있는 서브 루틴 식별자로만 허용됩니다. 아마도 서브 루틴을 미리 선언해야합니까?</target>
        </trans-unit>
        <trans-unit id="57b58322640707b7a82902e3e6f2ebe64dfc6537" translate="yes" xml:space="preserve">
          <source>(F) Within &lt;code&gt;(?[   ])&lt;/code&gt; , all constants interpreted as octal need to be exactly 3 digits long. This helps catch some ambiguities. If your constant is too short, add leading zeros, like</source>
          <target state="translated">(F) 안에 &lt;code&gt;(?[ ])&lt;/code&gt; 8 진수로 해석되는 모든 상수는 정확히 3 자리 여야합니다. 이것은 약간의 모호성을 잡는 데 도움이됩니다. 상수가 너무 짧은 경우와 같이 앞에 0을 추가하십시오</target>
        </trans-unit>
        <trans-unit id="ca2f25d275463356f7bf3b1dbff55ce157785fd6" translate="yes" xml:space="preserve">
          <source>(F) Within regular expression character classes ([]) the syntax beginning with &quot;[.&quot; and ending with &quot;.]&quot; is reserved for future extensions. If you need to represent those character sequences inside a regular expression character class, just quote the square brackets with the backslash: &quot;\[.&quot; and &quot;.\]&quot;. The &amp;lt;-- HERE shows whereabouts in the regular expression the problem was discovered. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">(F) 정규 표현식 문자 클래스 ([]) 내에서 &quot;[.&quot;로 시작하는 구문 &quot;.]&quot;로 끝나는 것은 향후 확장을 위해 예약되어 있습니다. 정규식 문자 클래스 내에서 해당 문자 시퀀스를 나타내려면 백 슬래시 ( &quot;\ [.&quot;)로 대괄호를 인용하십시오. &quot;. \]&quot;입니다. &amp;lt;-HERE는 정규식에서 문제가 발견 된 위치를 보여줍니다. &lt;a href=&quot;perlre&quot;&gt;perlre를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="184842463e428b6f1dafd75047f736cd537b4170" translate="yes" xml:space="preserve">
          <source>(F) Within regular expression character classes ([]) the syntax beginning with &quot;[=&quot; and ending with &quot;=]&quot; is reserved for future extensions. If you need to represent those character sequences inside a regular expression character class, just quote the square brackets with the backslash: &quot;\[=&quot; and &quot;=\]&quot;. The &amp;lt;-- HERE shows whereabouts in the regular expression the problem was discovered. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">(F) 정규 표현식 문자 클래스 ([]) 내에서 &quot;[=&quot;로 시작하고 &quot;=]&quot;로 끝나는 구문은 향후 확장을 위해 예약되어 있습니다. 정규식 문자 클래스 내에서 해당 문자 시퀀스를 나타내려면 백 슬래시 ( &quot;\ [=&quot;and &quot;= \]&quot;)로 대괄호를 인용하십시오. &amp;lt;-HERE는 정규식에서 문제가 발견 된 위치를 보여줍니다. &lt;a href=&quot;perlre&quot;&gt;펄레&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="23ace6fcb5c6042cbd75db4ef61b09d578c80b5d" translate="yes" xml:space="preserve">
          <source>(F) Wrong syntax of character name literal &lt;code&gt;\N{charname}&lt;/code&gt; within double-quotish context. This can also happen when there is a space (or comment) between the &lt;code&gt;\N&lt;/code&gt; and the &lt;code&gt;{&lt;/code&gt; in a regex with the &lt;code&gt;/x&lt;/code&gt; modifier. This modifier does not change the requirement that the brace immediately follow the &lt;code&gt;\N&lt;/code&gt; .</source>
          <target state="translated">(F) 큰 따옴표 문맥 내에서 문자 이름 리터럴 &lt;code&gt;\N{charname}&lt;/code&gt; 구문이 잘못되었습니다 . &lt;code&gt;/x&lt;/code&gt; 수정자를 사용 하는 정규 표현식에서 &lt;code&gt;\N&lt;/code&gt; 과 &lt;code&gt;{&lt;/code&gt; 사이에 공백 (또는 주석)이있는 경우에도 발생할 수 있습니다 . 이 수정자는 중괄호가 즉시 &lt;code&gt;\N&lt;/code&gt; 따라야한다는 요구 사항을 변경하지 않습니다. .</target>
        </trans-unit>
        <trans-unit id="6085a2af88a6a17e8acce3a5bf453724b8738a30" translate="yes" xml:space="preserve">
          <source>(F) You aren't allowed to assign to the item indicated, or otherwise try to change it, such as with an auto-increment.</source>
          <target state="translated">(F) 표시된 항목에 할당하거나 자동 증분과 같은 방식으로 항목을 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2864db319e3825d1d1fe85827e0d4f48aac1fe06" translate="yes" xml:space="preserve">
          <source>(F) You assigned a magical array to a stash element, and then tried to use the subroutine from the same slot. You are asking Perl to do something it cannot do, details subject to change between Perl versions.</source>
          <target state="translated">(F) 마법 요소를 숨김 요소에 할당 한 다음 동일한 슬롯에서 서브 루틴을 사용하려고했습니다. Perl이 할 수없는 일을하도록 요청하고 있습니다. 자세한 내용은 Perl 버전간에 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48b3c575f41492c8a08aae2fc35e03de3a72fa07" translate="yes" xml:space="preserve">
          <source>(F) You attempted to force a different byte-order on a type that is already inside a group with a byte-order modifier. For example you cannot force little-endianness on a type that is inside a big-endian group.</source>
          <target state="translated">(F) 바이트 순서 수정자를 사용하여 이미 그룹 내부에있는 유형에 대해 다른 바이트 순서를 강제하려고했습니다. 예를 들어 빅 엔디안 그룹 내부에있는 유형에서는 리틀 엔디안을 강요 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="881171db5044f0b6f8f4e215fe9373ac4174c267" translate="yes" xml:space="preserve">
          <source>(F) You attempted to use a feature of printf that is accessible from only C. This usually means there's a better way to do it in Perl.</source>
          <target state="translated">(F) C에서만 액세스 할 수있는 printf 기능을 사용하려고 시도했습니다. 이는 일반적으로 Perl에서 더 나은 방법이 있다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="728c161408cd75b5d520b698e4038e343ec4ac30" translate="yes" xml:space="preserve">
          <source>(F) You attempted to weaken something that was not a reference. Only references can be weakened.</source>
          <target state="translated">(F) 참조가 아닌 것을 약화 시키려고했다. 참조 만 약화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db53cc2ffe8f47dd52c929a1c646e99df3d56fdd" translate="yes" xml:space="preserve">
          <source>(F) You called &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt;, but you're not inside a &lt;code&gt;when&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; block.</source>
          <target state="translated">(F) &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 이라고 부르지 만 &lt;code&gt;when&lt;/code&gt; 또는 &lt;code&gt;default&lt;/code&gt; 안에 있지 않습니다. 블록 .</target>
        </trans-unit>
        <trans-unit id="01c970d384c2616397c0a011951a34cd7d7f13a9" translate="yes" xml:space="preserve">
          <source>(F) You called &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; with a scalar argument that was not a reference to an unblessed hash or array.</source>
          <target state="translated">(F) &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 호출했습니다. 을 축복되지 않은 해시 또는 배열에 대한 참조가 아닌 스칼라 인수로 호출했습니다.</target>
        </trans-unit>
        <trans-unit id="6b094e996ef83ed82c43ddac6981b6045c764ee9" translate="yes" xml:space="preserve">
          <source>(F) You called &lt;code&gt;&lt;a href=&quot;functions/reset&quot;&gt;reset('E')&lt;/a&gt;&lt;/code&gt; or similar, which tried to reset all variables in the current package beginning with &quot;E&quot;. In the main package, that includes %ENV. Resetting %ENV is not supported on some systems, notably VMS.</source>
          <target state="translated">(F) 당신은 &lt;code&gt;&lt;a href=&quot;functions/reset&quot;&gt;reset('E')&lt;/a&gt;&lt;/code&gt; 을 불렀다 또는 이와 유사한 했는데 &quot;E&quot;로 시작하는 현재 패키지의 모든 변수를 재설정하려고했습니다. 기본 패키지에는 % ENV가 포함되어 있습니다. 일부 시스템, 특히 VMS에서는 % ENV 재설정이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="36ff677e364d25b1175bceb5641a5524d40444a4" translate="yes" xml:space="preserve">
          <source>(F) You called &lt;code&gt;break&lt;/code&gt; , but you're in a &lt;code&gt;foreach&lt;/code&gt; block rather than a &lt;code&gt;given&lt;/code&gt; block. You probably meant to use &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">(F) 당신은 &lt;code&gt;break&lt;/code&gt; 라고 불렀지 만, 당신은 &lt;code&gt;given&lt;/code&gt; 블록이 아닌 &lt;code&gt;foreach&lt;/code&gt; 블록에 있습니다. 아마 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 을 사용하려고했습니다 .</target>
        </trans-unit>
        <trans-unit id="a94b23e66ba8af20ac0a9a060de4e6b205849b27" translate="yes" xml:space="preserve">
          <source>(F) You called &lt;code&gt;break&lt;/code&gt; , but you're not inside a &lt;code&gt;given&lt;/code&gt; block.</source>
          <target state="translated">(F) 당신은 &lt;code&gt;break&lt;/code&gt; 라고 불렀지 만, 당신은 &lt;code&gt;given&lt;/code&gt; 블록 안에 있지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f14d8e7b888e9377c887b6f95ac5ca271482a594" translate="yes" xml:space="preserve">
          <source>(F) You called &lt;code&gt;perl -x/foo/bar&lt;/code&gt;, but</source>
          <target state="translated">(F) &lt;code&gt;perl -x/foo/bar&lt;/code&gt; 라고 했지만</target>
        </trans-unit>
        <trans-unit id="959aa754460eae6feb41ec2111629d96ea9088b3" translate="yes" xml:space="preserve">
          <source>(F) You called &lt;code&gt;perl -x&lt;/code&gt; , but no line was found in the file beginning with #! and containing the word &quot;perl&quot;.</source>
          <target state="translated">(F) &lt;code&gt;perl -x&lt;/code&gt; 라고 했지만 파일에서 #으로 시작하는 줄이 없습니다! 그리고 &quot;perl&quot;이라는 단어를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="9bb41d38c25f72d107dd36f047a0576786e0f888" translate="yes" xml:space="preserve">
          <source>(F) You called a POSIX function with incorrect arguments. See &lt;a href=&quot;posix#FUNCTIONS&quot;&gt;FUNCTIONS in POSIX&lt;/a&gt; for more information.</source>
          <target state="translated">(F) 잘못된 인수로 POSIX 함수를 호출했습니다. &lt;a href=&quot;posix#FUNCTIONS&quot;&gt;POSIX의 기능&lt;/a&gt; 참조 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3192604eca8b0e227b09ffeb639a165560966235" translate="yes" xml:space="preserve">
          <source>(F) You called a Win32 function with incorrect arguments. See &lt;a href=&quot;http://search.cpan.org/perldoc/Win32&quot;&gt;Win32&lt;/a&gt; for more information.</source>
          <target state="translated">(F) 잘못된 인수로 Win32 함수를 호출했습니다. 자세한 내용은 &lt;a href=&quot;http://search.cpan.org/perldoc/Win32&quot;&gt;Win32&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7d88973c081ed5a972414a044844388eb37b6b45" translate="yes" xml:space="preserve">
          <source>(F) You called a method correctly, and it correctly indicated a package functioning as a class, but that package doesn't define that particular method, nor does any of its base classes. See &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="translated">(F) 메소드를 올바르게 호출했으며 클래스로 작동하는 패키지를 올바르게 표시했지만 해당 패키지가 특정 메소드를 정의하지 않거나 기본 클래스를 정의하지 않습니다. &lt;a href=&quot;perlobj&quot;&gt;perlobj를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9f61b9ada30955bc47801192dbc7ef72d2b2b646" translate="yes" xml:space="preserve">
          <source>(F) You called a method on a class that did not exist, and the method could not be found in UNIVERSAL. This often means that a method requires a package that has not been loaded.</source>
          <target state="translated">(F) 존재하지 않는 클래스에서 메소드를 호출했는데 해당 메소드를 UNIVERSAL에서 찾을 수 없습니다. 이것은 종종 메소드에로드되지 않은 패키지가 필요하다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1336a6e6dba767fccca5ebd6cbbb62ddfc475b1a" translate="yes" xml:space="preserve">
          <source>(F) You can't allocate more than 2^31+&quot;small amount&quot; bytes. This error is most likely to be caused by a typo in the Perl program. e.g., &lt;code&gt;$arr[&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;]&lt;/code&gt; instead of &lt;code&gt;$arr[$time]&lt;/code&gt; .</source>
          <target state="translated">(F) 2 ^ 31 + &quot;소량&quot;바이트 이상을 할당 할 수 없습니다. 이 오류는 Perl 프로그램의 오타가 원인 일 가능성이 큽니다. 예 : &lt;code&gt;$arr[&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;]&lt;/code&gt; 대신 &lt;code&gt;$arr[$time]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7541195c06352428d79ecf0a2e278770c3c338dc" translate="yes" xml:space="preserve">
          <source>(F) You can't allocate more than 64K on an MS-DOS machine.</source>
          <target state="translated">(F) MS-DOS 시스템에서 64K를 초과하여 할당 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7c53fc87dcd05fe5f00ccdfcb49ee87c276ed05e" translate="yes" xml:space="preserve">
          <source>(F) You can't pack a string by supplying a checksum, because the checksumming process loses information, and you can't go the other way. See &lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;.</source>
          <target state="translated">(F) 체크섬 프로세스는 정보를 잃어 버리고 다른 방법으로는 갈 수 없기 때문에 체크섬을 제공하여 문자열을 묶을 수 없습니다. &lt;a href=&quot;functions/unpack&quot;&gt;포장 풀기를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="08f464b49db854661463a9bddef0641f9cff5fca" translate="yes" xml:space="preserve">
          <source>(F) You can't quantify a quantifier without intervening parentheses. So things like ** or +* or ?* are illegal. The &amp;lt;-- HERE shows whereabouts in the regular expression the problem was discovered.</source>
          <target state="translated">(F) 괄호를 사용하지 않고 수량자를 수량화 할 수 없습니다. 따라서 **, + * 또는? *와 같은 것은 불법입니다. &amp;lt;-HERE는 정규식에서 문제가 발견 된 위치를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="753e95513d152b3ef3c87f9d85f4b69f49fd9049" translate="yes" xml:space="preserve">
          <source>(F) You can't specify a repeat count so large that it overflows your signed integers. See &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;.</source>
          <target state="translated">(F) 반복 횟수를 너무 크게 지정하여 부호있는 정수를 오버플로 할 수 없습니다. &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7a0bcac42f7bf3cb15b64e755518b6c3ad156ec2" translate="yes" xml:space="preserve">
          <source>(F) You can't undefine a routine that's currently running. You can, however, redefine it while it's running, and you can even undef the redefined subroutine while the old routine is running. Go figure.</source>
          <target state="translated">(F) 현재 실행중인 루틴을 정의 할 수 없습니다. 그러나 실행중인 동안 재정의 할 수 있으며 이전 루틴이 실행중인 동안 재정의 된 서브 루틴을 정의 해제 할 수도 있습니다. 그림을 이동.</target>
        </trans-unit>
        <trans-unit id="ea506a10d071b33e6fc01bda3a808cecda0317de" translate="yes" xml:space="preserve">
          <source>(F) You can't use system(), exec(), or a piped open in a setuid or setgid script if &lt;code&gt;$ENV{PATH}&lt;/code&gt; contains a directory that is writable by the world. Also, the PATH must not contain any relative directory. See &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;.</source>
          <target state="translated">(F) &lt;code&gt;$ENV{PATH}&lt;/code&gt; 에 세계에서 쓸 수있는 디렉토리가 포함되어 있으면 setuid 또는 setgid 스크립트에서 system (), exec () 또는 파이프 열린을 사용할 수 없습니다 . 또한 PATH에는 상대 디렉토리가 없어야합니다. &lt;a href=&quot;perlsec&quot;&gt;perlsec을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e90d9e25e945b5713e6c94226c8cb00752fe5ab5" translate="yes" xml:space="preserve">
          <source>(F) You can't use system(), exec(), or a piped open in a setuid or setgid script if any of &lt;code&gt;$ENV{PATH}&lt;/code&gt; , &lt;code&gt;$ENV{IFS}&lt;/code&gt; , &lt;code&gt;$ENV{CDPATH}&lt;/code&gt; , &lt;code&gt;$ENV{ENV}&lt;/code&gt; , &lt;code&gt;$ENV{BASH_ENV}&lt;/code&gt; or &lt;code&gt;$ENV{TERM}&lt;/code&gt; are derived from data supplied (or potentially supplied) by the user. The script must set the path to a known value, using trustworthy data. See &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;.</source>
          <target state="translated">(F) &lt;code&gt;$ENV{PATH}&lt;/code&gt; , &lt;code&gt;$ENV{IFS}&lt;/code&gt; , &lt;code&gt;$ENV{CDPATH}&lt;/code&gt; , &lt;code&gt;$ENV{ENV}&lt;/code&gt; , &lt;code&gt;$ENV{BASH_ENV}&lt;/code&gt; 또는 &lt;code&gt;$ENV{TERM}&lt;/code&gt; 은 사용자가 제공하거나 잠재적으로 제공 한 데이터에서 파생됩니다. 스크립트는 신뢰할 수있는 데이터를 사용하여 알려진 값으로 경로를 설정해야합니다. &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="a2d155a35fbe179a6def203f6dec66d58ac7b169" translate="yes" xml:space="preserve">
          <source>(F) You cannot put a repeat count of any kind right after the '/' code. See &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;.</source>
          <target state="translated">(F) '/'코드 바로 뒤에는 어떤 종류의 반복 횟수도 넣을 수 없습니다. &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d0036f720d6af192b41b5e61e7134c67524c579b" translate="yes" xml:space="preserve">
          <source>(F) You defined a character name which ended in a space character. Remove the trailing space(s). Usually these names are defined in the &lt;code&gt;:alias&lt;/code&gt; import argument to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; charnames&lt;/code&gt; , but they could be defined by a translator installed into &lt;code&gt;$^H{charnames}&lt;/code&gt; . See &lt;a href=&quot;charnames#CUSTOM-ALIASES&quot;&gt;CUSTOM ALIASES in charnames&lt;/a&gt;.</source>
          <target state="translated">(F) 공백 문자로 끝나는 문자 이름을 정의했습니다. 후행 공백을 제거하십시오. 일반적으로 이러한 이름은 &lt;code&gt;:alias&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; charnames&lt;/code&gt; 를 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하기 위해 : alias import 인수에 정의되어 있지만 &lt;code&gt;$^H{charnames}&lt;/code&gt; 설치된 변환기에 의해 정의 될 수 있습니다 . &lt;a href=&quot;charnames#CUSTOM-ALIASES&quot;&gt;캐릭터 이름의 커스텀 별칭&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="f3b44bdb6c023b94037f6e9d1051841408750246" translate="yes" xml:space="preserve">
          <source>(F) You defined a character name which had multiple space characters in a row. Change them to single spaces. Usually these names are defined in the &lt;code&gt;:alias&lt;/code&gt; import argument to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; charnames&lt;/code&gt; , but they could be defined by a translator installed into &lt;code&gt;$^H{charnames}&lt;/code&gt; . See &lt;a href=&quot;charnames#CUSTOM-ALIASES&quot;&gt;CUSTOM ALIASES in charnames&lt;/a&gt;.</source>
          <target state="translated">(F) 행에 여러 개의 공백 문자가있는 문자 이름을 정의했습니다. 단일 공백으로 변경하십시오. 일반적으로 이러한 이름은 &lt;code&gt;:alias&lt;/code&gt; 에 정의되어 있습니다 . &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; charnames&lt;/code&gt; 를 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하기 위해 import 인수에 정의되어 있지만 &lt;code&gt;$^H{charnames}&lt;/code&gt; 설치된 변환기에 의해 정의 될 수 있습니다 . &lt;a href=&quot;charnames#CUSTOM-ALIASES&quot;&gt;charnames의 CUSTOM ALIASES를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4b7a33dd0652c526df86e81d06336bdd27b9973d" translate="yes" xml:space="preserve">
          <source>(F) You don't have System V message IPC on your system.</source>
          <target state="translated">(F) 시스템에 System V 메시지 IPC가 없습니다.</target>
        </trans-unit>
        <trans-unit id="29929620c9605299c2f9c77d2074fe7125d8bc7c" translate="yes" xml:space="preserve">
          <source>(F) You don't have System V semaphore IPC on your system.</source>
          <target state="translated">(F) 시스템에 System V 세마포어 IPC가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c47629f7d67107091ad51fd87097bf44694305dd" translate="yes" xml:space="preserve">
          <source>(F) You don't have System V shared memory IPC on your system.</source>
          <target state="translated">(F) 시스템에 System V 공유 메모리 IPC가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c1f976fcf6bcf428955989210860a95e623785e6" translate="yes" xml:space="preserve">
          <source>(F) You either made a typo or have incorrectly put a &lt;code&gt;*&lt;/code&gt; quantifier after an open brace in your pattern. Check the pattern and review &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; for details on legal verb patterns.</source>
          <target state="translated">(F) 오타를 입었거나 잘못 입력 한 경우 &lt;code&gt;*&lt;/code&gt; 패턴에 열린 괄호 후에 * 수량자를 . 유효한 동사 패턴에 대한 자세한 내용 은 패턴을 확인하고 &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; 를 검토 하십시오.</target>
        </trans-unit>
        <trans-unit id="c95811d7212e7295e15b87ad9e57bf816525ebfd" translate="yes" xml:space="preserve">
          <source>(F) You had a (sub-)template that ends with a '/'. There must be another template code following the slash. See &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;.</source>
          <target state="translated">(F) 당신은 '/'로 끝나는 (서브) 템플릿을 가졌습니다. 슬래시 다음에 다른 템플리트 코드가 있어야합니다. &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c5a10b0407273cd3af5f825d2181cc8e51638847" translate="yes" xml:space="preserve">
          <source>(F) You had a (un)pack template that specified a relative position before the beginning of the string being (un)packed. See &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;.</source>
          <target state="translated">(F) 당신은 (언) 패킹 될 문자열의 시작 전에 상대적인 위치를 지정하는 (언) 팩 템플릿을 가졌습니다. 보다&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aa4e3d887c8e937ba03881be0c0e64968d5e38b5" translate="yes" xml:space="preserve">
          <source>(F) You had a pack template that specified a relative position after the end of the string being unpacked. See &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;.</source>
          <target state="translated">(F) 끈이 풀린 후 상대 위치를 지정하는 묶음 템플릿이 있습니다. 보다&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1f5244e28bff8422e1ce0fb0add00a7be0a2f69d" translate="yes" xml:space="preserve">
          <source>(F) You had a template that specified an absolute position outside the string being unpacked. See &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;.</source>
          <target state="translated">(F) 포장을 풀고있는 문자열 외부의 절대 위치를 지정하는 템플릿이 있습니다. 보다&lt;a href=&quot;functions/pack&quot;&gt;팩&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="32831fac2b41a8125e84e4455d9a1b2e507b293a" translate="yes" xml:space="preserve">
          <source>(F) You had a template that specified an absolute position outside the string being unpacked. The string being unpacked was also invalid UTF-8. See &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;.</source>
          <target state="translated">(F) 포장을 풀고있는 문자열 외부의 절대 위치를 지정하는 템플릿이 있습니다. 압축이 풀린 문자열도 유효하지 않은 UTF-8입니다. &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eeb640744c55f1f5964bb8c9a243b5f9078aad67" translate="yes" xml:space="preserve">
          <source>(F) You had an unpack template indicating a counted-length string, but you have also specified an explicit size for the string. See &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;.</source>
          <target state="translated">(F) 계산 된 길이의 문자열을 나타내는 압축 해제 템플릿이 있지만 문자열의 명시적인 크기도 지정했습니다. &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="770ea17de0451bebd0e7cdbfab2f0c7ee3f7dca1" translate="yes" xml:space="preserve">
          <source>(F) You had an unpack template that contained a '/', but this did not follow some unpack specification producing a numeric value. See &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;.</source>
          <target state="translated">(F) '/'가 포함 된 압축 풀기 템플릿이 있지만 숫자 값을 생성하는 압축 풀기 사양을 따르지 않았습니다. &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="64dac83ad13dc2f2fb282fe54f89e4e69c1ffc0b" translate="yes" xml:space="preserve">
          <source>(F) You had something like this:</source>
          <target state="translated">(F) 당신은 다음과 같은 것을 가졌습니다 :</target>
        </trans-unit>
        <trans-unit id="63929c2f80159e9b6d4a89129fd5ad2759397810" translate="yes" xml:space="preserve">
          <source>(F) You have configured Perl to use long doubles but the internals of the long double format are unknown; therefore the hexadecimal float output is impossible.</source>
          <target state="translated">(F) Long double을 사용하도록 Perl을 구성했지만 long double 형식의 내부는 알 수 없습니다. 따라서 16 진 부동 출력은 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="986a95b086a7fa1018fd31af64327ec4514a73be" translate="yes" xml:space="preserve">
          <source>(F) You have used a &lt;code&gt;default&lt;/code&gt; block that is neither inside a &lt;code&gt;foreach&lt;/code&gt; loop nor a &lt;code&gt;given&lt;/code&gt; block. (Note that this error is issued on exit from the &lt;code&gt;default&lt;/code&gt; block, so you won't get the error if you use an explicit &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">(F) &lt;code&gt;foreach&lt;/code&gt; 루프 내부 나 &lt;code&gt;given&lt;/code&gt; 블록에 없는 &lt;code&gt;default&lt;/code&gt; 블록을 사용했습니다 . (이 오류는 &lt;code&gt;default&lt;/code&gt; 블록에서 나갈 때 발생하므로 명시 적 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 를 사용하면 오류가 발생하지 않습니다 .)</target>
        </trans-unit>
        <trans-unit id="73114e29140c870691510021d29c6b2748f1d357" translate="yes" xml:space="preserve">
          <source>(F) You have used a when() block that is neither inside a &lt;code&gt;foreach&lt;/code&gt; loop nor a &lt;code&gt;given&lt;/code&gt; block. (Note that this error is issued on exit from the &lt;code&gt;when&lt;/code&gt; block, so you won't get the error if the match fails, or if you use an explicit &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">(F) &lt;code&gt;foreach&lt;/code&gt; 루프 나 &lt;code&gt;given&lt;/code&gt; 블록 안에 있지 않은 when () 블록을 사용했습니다 . (이 오류는 &lt;code&gt;when&lt;/code&gt; 블록 에서 나갈 때 발생하므로 일치하지 않거나 명시적인 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 를 사용하면 오류가 발생하지 않습니다 .)</target>
        </trans-unit>
        <trans-unit id="c1d12edc9af1329055791fa975f785978a6fe123" translate="yes" xml:space="preserve">
          <source>(F) You manipulated Perl's symbol table directly, stored a reference in it, then tried to access that symbol via conventional Perl syntax. The access triggers Perl to autovivify that typeglob, but it there is no legal conversion from that type of reference to a typeglob.</source>
          <target state="translated">(F) Perl의 심볼 테이블을 직접 조작하고 그 안에 참조를 저장 한 다음 일반적인 Perl 구문을 통해 해당 심볼에 액세스하려고했습니다. 액세스는 Perl을 실행하여 해당 유형을 자동으로 활성화하지만 해당 유형의 참조를 유형으로 변환 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="172ef62f0afe81a43b622ddd9e2ad513b1542d34" translate="yes" xml:space="preserve">
          <source>(F) You may have tried to use &lt;code&gt;\p&lt;/code&gt; which means a Unicode property (for example &lt;code&gt;\p{Lu}&lt;/code&gt; matches all uppercase letters). If you did mean to use a Unicode property, see &lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;Properties accessible through \p{} and \P{} in perluniprops&lt;/a&gt; for a complete list of available properties. If you didn't mean to use a Unicode property, escape the &lt;code&gt;\p&lt;/code&gt; , either by &lt;code&gt;\\p&lt;/code&gt; (just the &lt;code&gt;\p&lt;/code&gt; ) or by &lt;code&gt;\Q\p&lt;/code&gt; (the rest of the string, or until &lt;code&gt;\E&lt;/code&gt; ).</source>
          <target state="translated">(F) 유니 코드 속성을 의미하는 &lt;code&gt;\p&lt;/code&gt; 를 사용하려고했을 수 있습니다 (예 : &lt;code&gt;\p{Lu}&lt;/code&gt; 는 모든 대문자와 일치합니다). 유니 코드 특성을 사용하려는 경우 사용 가능한 특성의 전체 목록은 &lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;perluniprops에서 \ p {} 및 \ P {}를 통해 액세스 가능한&lt;/a&gt; 특성을 참조하십시오 . 당신은 유니 코드 속성을 사용하는 것을 의미하지 않은 경우 탈출 &lt;code&gt;\p&lt;/code&gt; 하여 중, &lt;code&gt;\\p&lt;/code&gt; (단지 &lt;code&gt;\p&lt;/code&gt; ) 또는에 의해 &lt;code&gt;\Q\p&lt;/code&gt; (또는 때까지 문자열의 나머지 &lt;code&gt;\E&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2ab0f8bd6407fa0ac460e400a0fc822f40b04e5d" translate="yes" xml:space="preserve">
          <source>(F) You must now decide whether the final $ in a string was meant to be a literal dollar sign, or was meant to introduce a variable name that happens to be missing. So you have to put either the backslash or the name.</source>
          <target state="translated">(F) 이제 문자열의 마지막 $가 리터럴 달러 기호인지, 누락 된 변수 이름을 도입 할 것인지 결정해야합니다. 따라서 백 슬래시 또는 이름을 입력해야합니다.</target>
        </trans-unit>
        <trans-unit id="017640a4df4ec5a1fff70a3f979aaf8306e351e8" translate="yes" xml:space="preserve">
          <source>(F) You named a loop to break out of, but you're not currently in a loop of that name, not even if you count where you were called from. See &lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;.</source>
          <target state="translated">(F) 당신이 탈출하기 위해 루프의 이름을 지었지만, 당신이 어디에서 왔는지 계산하지 않더라도 현재는 그 이름의 루프에 있지 않습니다. &lt;a href=&quot;functions/last&quot;&gt;마지막&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="0bbf8f624ad11c82184c4daab6ece99ef66cc0b7" translate="yes" xml:space="preserve">
          <source>(F) You named a loop to continue, but you're not currently in a loop of that name, not even if you count where you were called from. See &lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;.</source>
          <target state="translated">(F) 계속하기 위해 루프의 이름을 지정했지만, 어디에서 전화를했는지는 아니더라도 현재는 해당 이름의 루프에 있지 않습니다. &lt;a href=&quot;functions/last&quot;&gt;마지막&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="2d97b67f8b84063019dd5d1ed5b19bfe68e5837e" translate="yes" xml:space="preserve">
          <source>(F) You named a loop to restart, but you're not currently in a loop of that name, not even if you count where you were called from. See &lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;.</source>
          <target state="translated">(F) 당신은 다시 시작하기 위해 루프의 이름을 지었지만, 당신이 어디에서 왔는지 계산하지 않더라도 현재 그 이름의 루프에 있지 않습니다. &lt;a href=&quot;functions/last&quot;&gt;마지막&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="052af7dabe34e4c84c44d4e5c1198944c66ee3de" translate="yes" xml:space="preserve">
          <source>(F) You omitted to close a (?(condition)...) block somewhere in the pattern. Add a closing parenthesis in the appropriate position. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">(F) 패턴에서 (? (condition) ...) 블록을 닫는 것을 생략했습니다. 적절한 위치에 닫는 괄호를 추가하십시오. &lt;a href=&quot;perlre&quot;&gt;perlre를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b0b841e2400aba7a2a1ddb959cb022ec8f614d12" translate="yes" xml:space="preserve">
          <source>(F) You passed a buffer of the wrong size to one of msgctl(), semctl() or shmctl(). In C parlance, the correct sizes are, respectively, sizeof(struct msqid_ds *), sizeof(struct semid_ds *), and sizeof(struct shmid_ds *).</source>
          <target state="translated">(F) 잘못된 크기의 버퍼를 msgctl (), semctl () 또는 shmctl () 중 하나로 전달했습니다. C 용어에서 올바른 크기는 각각 sizeof (struct msqid_ds *), sizeof (struct semid_ds *) 및 sizeof (struct shmid_ds *)입니다.</target>
        </trans-unit>
        <trans-unit id="90c0e43c4a1c808d4f05f79c8c654baf64954786" translate="yes" xml:space="preserve">
          <source>(F) You passed a reference to a blessed array to &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; or another array function. These only accept unblessed array references or arrays beginning explicitly with &lt;code&gt;@&lt;/code&gt; .</source>
          <target state="translated">(F)는하면에 복된 배열에 대한 참조를 전달 &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 또는 다른 배열 함수. 이것들은 축복되지 않은 배열 참조 나 &lt;code&gt;@&lt;/code&gt; 로 명시 적으로 시작하는 배열 만 받아들입니다.</target>
        </trans-unit>
        <trans-unit id="25d00ef574a2f7b0c3e62b36a8e331bdf6bd59c7" translate="yes" xml:space="preserve">
          <source>(F) You passed an invalid ANSI escape sequence to uncolor().</source>
          <target state="translated">(F) 유효하지 않은 ANSI 이스케이프 시퀀스를 uncolor ()에 전달했습니다.</target>
        </trans-unit>
        <trans-unit id="2132dc15cb72c700e67c2378ba735195d57a87d1" translate="yes" xml:space="preserve">
          <source>(F) You passed an invalid alias name to coloralias(). Alias names must consist only of alphanumerics, &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt; , and &lt;code&gt;_&lt;/code&gt; .</source>
          <target state="translated">(F) 유효하지 않은 별칭 이름을 coloralias ()에 전달했습니다. 별명 이름은 영숫자만으로 구성되어야합니다 &lt;code&gt;.&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , 그리고 &lt;code&gt;_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="143d1ad2d555a749ed30c447cfb171b8c70c4fb7" translate="yes" xml:space="preserve">
          <source>(F) You passed an invalid attribute name to color(), colored(), or coloralias().</source>
          <target state="translated">(F) 유효하지 않은 속성 이름을 color (), colored () 또는 coloralias ()에 전달했습니다.</target>
        </trans-unit>
        <trans-unit id="28faddfed8391fa3ce80e9cb9bc5d747d38fafe6" translate="yes" xml:space="preserve">
          <source>(F) You passed an invalid number (like an infinity or not-a-number) to &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">(F) 유효하지 않은 숫자 (무한대 또는 숫자가 아닌)를 전달했습니다. &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; 에 전달했습니다 .</target>
        </trans-unit>
        <trans-unit id="594bd752ab134bb72403c3fab7adee02d8229986" translate="yes" xml:space="preserve">
          <source>(F) You passed die() an empty string (the equivalent of &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt; &quot;&quot;&lt;/code&gt; ) or you called it with no args and &lt;code&gt;$@&lt;/code&gt; was empty.</source>
          <target state="translated">(F) die ()에 빈 문자열 ( &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt; &quot;&quot;&lt;/code&gt; 와 동등 함)을 전달했거나 인수없이 호출했습니다. &lt;code&gt;$@&lt;/code&gt; 가 비어있었습니다.</target>
        </trans-unit>
        <trans-unit id="8f56a56432ce9593e2c4d6679ea27c55811678e0" translate="yes" xml:space="preserve">
          <source>(F) You probably mistyped a constant color name such as:</source>
          <target state="translated">(F) 다음과 같은 일정한 색상 이름을 잘못 입력했을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bb715e42afaafeaab9609fa39232b59a341c9d9" translate="yes" xml:space="preserve">
          <source>(F) You provided a class qualifier in a &quot;my&quot;, &quot;our&quot; or &quot;state&quot; declaration, but this class doesn't exist at this point in your program.</source>
          <target state="translated">(F) &quot;my&quot;, &quot;our&quot;또는 &quot;state&quot;선언으로 클래스 한정자를 제공했지만이 클래스는 현재 프로그램에 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="135a89e0b5c34079dc70d08e0834896303af80e6" translate="yes" xml:space="preserve">
          <source>(F) You said &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; , but the program file doesn't comply with UTF-8 encoding rules. The message prints out the properly encoded characters just before the first bad one. If &lt;code&gt;utf8&lt;/code&gt; warnings are enabled, a warning is generated that gives more details about the type of malformation.</source>
          <target state="translated">(F) &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 한다고 말 했지만 프로그램 파일이 UTF-8 인코딩 규칙을 준수하지 않습니다. 메시지는 첫 번째 불량 문자 바로 전에 올바르게 인코딩 된 문자를 인쇄합니다. &lt;code&gt;utf8&lt;/code&gt; 인 경우 경고가 활성화되어 경고가 기형의 유형에 대한 자세한 정보를 제공 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="83082be7dd4a60dd1c40f045ce110ed91cab0e75" translate="yes" xml:space="preserve">
          <source>(F) You said something like &quot;use Module 42&quot; but in the Module file there are neither package declarations nor a &lt;code&gt;$VERSION&lt;/code&gt; .</source>
          <target state="translated">(F) &quot;use Module 42&quot;와 같은 것을 말했지만 모듈 파일에는 패키지 선언이나 &lt;code&gt;$VERSION&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36a56380658f5242a7507bf38a5ddff4c96e36f6" translate="yes" xml:space="preserve">
          <source>(F) You said something like &quot;use Module 42&quot; but the Module did not define a &lt;code&gt;$VERSION&lt;/code&gt; .</source>
          <target state="translated">(F) &quot;use Module 42&quot;와 같은 것을 말했지만 모듈이 &lt;code&gt;$VERSION&lt;/code&gt; 정의하지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="6727a3af6aad3293e460eca6be967915be18f62b" translate="yes" xml:space="preserve">
          <source>(F) You said something like &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $$ref&lt;/code&gt; , which Perl can't currently handle, because when it goes to restore the old value of whatever $ref pointed to after the scope of the local() is finished, it can't be sure that $ref will still be a reference.</source>
          <target state="translated">(F) 당신은 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $$ref&lt;/code&gt; $$ ref 와 같은 것을 말 했어요 현재 에서 처리 할 수없는 , local ()의 범위가 끝난 후 가리키는 $ ref의 오래된 값을 복원 할 때, $ ref가 여전히 참조가되도록하십시오.</target>
        </trans-unit>
        <trans-unit id="289f6f032228eeaa7948f842a54fd998e06700fb" translate="yes" xml:space="preserve">
          <source>(F) You said to &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;) a file that couldn't be found. Perl looks for the file in all the locations mentioned in @INC, unless the file name included the full path to the file. Perhaps you need to set the PERL5LIB or PERL5OPT environment variable to say where the extra library is, or maybe the script needs to add the library name to @INC. Or maybe you just misspelled the name of the file. See &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; and &lt;a href=&quot;lib&quot;&gt;lib&lt;/a&gt;.</source>
          <target state="translated">(F) 당신은 있다고 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; (또는 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; , 또는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; )을 찾을 수 없습니다 파일을. 파일 이름에 파일의 전체 경로가 포함되어 있지 않으면 Perl은 @INC에 언급 된 모든 위치에서 파일을 찾습니다. 추가 라이브러리가있는 위치를 말하도록 PERL5LIB 또는 PERL5OPT 환경 변수를 설정해야하거나 스크립트가 @INC에 라이브러리 이름을 추가해야 할 수도 있습니다. 또는 파일 이름을 잘못 입력했을 수도 있습니다. &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 및 &lt;a href=&quot;lib&quot;&gt;lib&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="71e19f90d1bf0f904ac1689d02752c4c525ec6f7" translate="yes" xml:space="preserve">
          <source>(F) You said to goto a label that isn't mentioned anywhere that it's possible for us to go to. See &lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;.</source>
          <target state="translated">(F) 당신은 우리가 갈 수있는 곳에서 언급되지 않은 라벨에 가라고 말했습니다. &lt;a href=&quot;functions/goto&quot;&gt;고토&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="cbeef37c86bf57de503c6975c39d62c2487e2b63" translate="yes" xml:space="preserve">
          <source>(F) You should not use the &lt;code&gt;~~&lt;/code&gt; operator on an object that does not overload it: Perl refuses to use the object's underlying structure for the smart match.</source>
          <target state="translated">(F) 과부하가 걸리지 않는 객체 에는 &lt;code&gt;~~&lt;/code&gt; 연산자를 사용하면 안됩니다 . Perl은 스마트 일치를 위해 객체의 기본 구조 사용을 거부합니다.</target>
        </trans-unit>
        <trans-unit id="90bbbd2573c9b934040bfde52197420076284030" translate="yes" xml:space="preserve">
          <source>(F) You specified a *roff font (using &lt;code&gt;fixed&lt;/code&gt; , &lt;code&gt;fixedbold&lt;/code&gt; , etc.) that wasn't either one or two characters. Pod::Man doesn't support *roff fonts longer than two characters, although some *roff extensions do (the canonical versions of &lt;b&gt;nroff&lt;/b&gt; and &lt;b&gt;troff&lt;/b&gt; don't either).</source>
          <target state="translated">(F) 하나 또는 두 개의 문자가 아닌 * roff 글꼴 ( &lt;code&gt;fixed&lt;/code&gt; , &lt;code&gt;fixedbold&lt;/code&gt; 등 사용)을 지정했습니다 . Pod :: Man은 두 개의 문자보다 긴 * roff 글꼴을 지원하지 않지만 일부 * roff 확장자 (정규 버전의 &lt;b&gt;nroff&lt;/b&gt; 및 &lt;b&gt;troff)는 지원합니다.&lt;/b&gt; 는 지원하지 않습니다).</target>
        </trans-unit>
        <trans-unit id="450bd21ba19b8482651deb0214267431c0137ebc" translate="yes" xml:space="preserve">
          <source>(F) You specified a signal hook that was not recognized by Perl. Currently, Perl accepts &lt;code&gt;__DIE__&lt;/code&gt; and &lt;code&gt;__WARN__&lt;/code&gt; as valid signal hooks.</source>
          <target state="translated">(F) Perl이 인식하지 못하는 신호 후크를 지정했습니다. 현재 Perl은 &lt;code&gt;__DIE__&lt;/code&gt; 및 &lt;code&gt;__WARN__&lt;/code&gt; 을 허용합니다. 을 유효한 신호 후크로 합니다.</target>
        </trans-unit>
        <trans-unit id="48c97511646a051e4bc7ac609e49772c63cce0a1" translate="yes" xml:space="preserve">
          <source>(F) You specified a signal name to the kill() function that was not recognized. Say &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -l&lt;/code&gt; in your shell to see the valid signal names on your system.</source>
          <target state="translated">(F) 인식되지 않은 kill () 함수에 신호 이름을 지정했습니다. 쉘에서 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -l&lt;/code&gt; 이라고 말하면 시스템에서 유효한 신호 이름을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="201388e6f1104d74bede54e12238b69d3d4d9194" translate="yes" xml:space="preserve">
          <source>(F) You specified an illegal option to Perl. Don't do that. (If you think you didn't do that, check the #! line to see if it's supplying the bad switch on your behalf.)</source>
          <target state="translated">(F) 귀하는 Perl에 잘못된 옵션을 지정했습니다. 하지마 (그렇지 않다고 생각되면 #! 행을 확인하여 사용자 대신 잘못된 스위치를 제공하고 있는지 확인하십시오.)</target>
        </trans-unit>
        <trans-unit id="9a57bb24a1bf5dc631dda7c07d607e805d5664da" translate="yes" xml:space="preserve">
          <source>(F) You specified an unknown Unicode option. See &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; documentation of the &lt;code&gt;-C&lt;/code&gt; switch for the list of known options.</source>
          <target state="translated">(F) 알 수없는 유니 코드 옵션을 지정했습니다. 알려진 옵션 목록은 &lt;code&gt;-C&lt;/code&gt; 스위치 의 &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="35c3af91c3bc45c10c340c011f66dc25543dec0e" translate="yes" xml:space="preserve">
          <source>(F) You started a regular expression with a quantifier. Backslash it if you meant it literally. The &amp;lt;-- HERE shows whereabouts in the regular expression the problem was discovered. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">(F) 당신은 한정자로 정규 표현식을 시작했습니다. 당신이 말 그대로 그것을 의미한다면 백 슬래시. &amp;lt;-HERE는 정규식에서 문제가 발견 된 위치를 보여줍니다. &lt;a href=&quot;perlre&quot;&gt;펄레&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="507799b665e6a10af2b55203739355466004fe11" translate="yes" xml:space="preserve">
          <source>(F) You started to name a symbol by using a package prefix, and then didn't finish the symbol. In particular, you can't interpolate outside of quotes, so</source>
          <target state="translated">(F) 패키지 접두사를 사용하여 심볼 이름을 지정하기 시작한 후 심볼을 완성하지 못했습니다. 특히 따옴표 외부에서 보간 할 수 없으므로</target>
        </trans-unit>
        <trans-unit id="f93aa5ed65e996505eaee4c164c9a8d7dc9e9fe3" translate="yes" xml:space="preserve">
          <source>(F) You tried compressing an infinity or not-a-number as an unsigned integer with BER, which makes no sense.</source>
          <target state="translated">(F) BER을 사용하여 무한대 또는 숫자가 아닌 부호없는 정수로 압축하려고 시도했지만 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="59d76582aaaf9ff517a85e916071d330a17b0d19" translate="yes" xml:space="preserve">
          <source>(F) You tried converting an infinity or not-a-number to an integer, which makes no sense.</source>
          <target state="translated">(F) 무한대 또는 숫자가 아닌 정수를 정수로 변환하려고 시도했지만 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="47e88695dfd516f1761bfa22bc4fe434e7e797ca" translate="yes" xml:space="preserve">
          <source>(F) You tried printing an infinity or not-a-number as a character (%c), which makes no sense. Maybe you meant '%s', or just stringifying it?</source>
          <target state="translated">(F) 무한대 또는 숫자가 아닌 문자 (% c)로 인쇄하려고했지만 이치에 맞지 않습니다. 어쩌면 당신은 '% s'을 의미 했습니까, 아니면 그냥 그것을 엄격화 했습니까?</target>
        </trans-unit>
        <trans-unit id="a9d00903e902e5ca35aeab45ecd4569e2efdf08b" translate="yes" xml:space="preserve">
          <source>(F) You tried to &lt;code&gt;mro::set_mro(&quot;classname&quot;, &quot;foo&quot;)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; mro 'foo'&lt;/code&gt; , where &lt;code&gt;foo&lt;/code&gt; is not a valid method resolution order (MRO). Currently, the only valid ones supported are &lt;code&gt;dfs&lt;/code&gt; and &lt;code&gt;c3&lt;/code&gt; , unless you have loaded a module that is a MRO plugin. See &lt;a href=&quot;mro&quot;&gt;mro&lt;/a&gt; and &lt;a href=&quot;perlmroapi&quot;&gt;perlmroapi&lt;/a&gt;.</source>
          <target state="translated">(F) &lt;code&gt;mro::set_mro(&quot;classname&quot;, &quot;foo&quot;)&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; mro 'foo'&lt;/code&gt; 하거나 mro 'foo'를 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 했습니다 . 여기서 &lt;code&gt;foo&lt;/code&gt; 는 유효한 메소드 분석 순서 (MRO)가 아닙니다. MRO 플러그인 인 모듈을로드하지 않은 경우 현재 지원되는 유일한 것은 &lt;code&gt;dfs&lt;/code&gt; 및 &lt;code&gt;c3&lt;/code&gt; 입니다. &lt;a href=&quot;mro&quot;&gt;mro&lt;/a&gt; 및 &lt;a href=&quot;perlmroapi&quot;&gt;perlmroapi를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="aa7f6b1d732dcf83c1aa6234e7d7f7ecce6c43e7" translate="yes" xml:space="preserve">
          <source>(F) You tried to access a key from a hash through the indicated typed variable but that key is not allowed by the package of the same type. The indicated package has restricted the set of allowed keys using the &lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt; pragma.</source>
          <target state="translated">(F) 표시된 유형 변수를 통해 해시에서 키에 액세스하려고 시도했지만 동일한 유형의 패키지에서 해당 키를 사용할 수 없습니다. 표시된 패키지가 pragma &lt;a href=&quot;fields&quot;&gt;필드를&lt;/a&gt; 사용하여 허용 된 키 세트를 제한했습니다 .</target>
        </trans-unit>
        <trans-unit id="47195ebb6653351cbaae3a7180b095fc18cc38a3" translate="yes" xml:space="preserve">
          <source>(F) You tried to activate a source filter (usually by loading a source filter module) within a string passed to &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;. This is not permitted under the &lt;code&gt;unicode_eval&lt;/code&gt; feature. Consider using &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; instead. See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;.</source>
          <target state="translated">(F) 전달 된 문자열 내에서 소스 필터를 활성화하려고했습니다 (보통 소스 필터 모듈을로드하여). &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 에. &lt;code&gt;unicode_eval&lt;/code&gt; 기능에서는 허용되지 않습니다. 사용을 고려 &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; 을 대신. &lt;a href=&quot;feature&quot;&gt;기능을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0979a84524da47420a450a05cc6286627b8e6ab5" translate="yes" xml:space="preserve">
          <source>(F) You tried to assign a reference to a non integer to &lt;code&gt;$/&lt;/code&gt; . In older Perls this would have behaved similarly to setting it to a reference to a positive integer, where the integer was the address of the reference. As of Perl 5.20.0 this is a fatal error, to allow future versions of Perl to use non-integer refs for more interesting purposes.</source>
          <target state="translated">(F) 정수가 아닌 참조를 &lt;code&gt;$/&lt;/code&gt; 에 할당하려고했습니다 . 이전 Perls에서는 정수가 참조의 주소 인 양의 정수에 대한 참조로 설정하는 것과 유사하게 작동했을 것입니다. Perl 5.20.0부터는 향후 버전의 Perl이보다 흥미로운 목적으로 정수가 아닌 참조를 사용할 수 있도록하는 치명적인 오류입니다.</target>
        </trans-unit>
        <trans-unit id="05c6cffa95736f357898157f66e51fd53053fc37" translate="yes" xml:space="preserve">
          <source>(F) You tried to assign a reference to a reference constructor, but the two references were not of the same type. You cannot alias a scalar to an array, or an array to a hash; the two types must match.</source>
          <target state="translated">(F) 참조 생성자에 참조를 할당하려고했지만 두 참조가 동일한 유형이 아닙니다. 스칼라를 배열로 또는 배열을 해시로 별명을 지정할 수 없습니다. 두 유형이 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="feae1b83e32befce733c62d81ef3dde590f790af" translate="yes" xml:space="preserve">
          <source>(F) You tried to assign something that was not a reference to an lvalue reference (e.g., &lt;code&gt;\$x = $y&lt;/code&gt; ). If you meant to make $x an alias to $y, use &lt;code&gt;\$x = \$y&lt;/code&gt; .</source>
          <target state="translated">(F) lvalue 참조에 대한 참조가 아닌 것을 할당하려고했습니다 (예 : &lt;code&gt;\$x = $y&lt;/code&gt; ). $ x를 $ y의 별칭으로 만들려면 &lt;code&gt;\$x = \$y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bcf6d72d15130f5e32507d8a891d675aa5f0c530" translate="yes" xml:space="preserve">
          <source>(F) You tried to assign to &lt;code&gt;$&amp;gt;&lt;/code&gt; , and your operating system doesn't support the seteuid() system call (or equivalent), or at least Configure didn't think so.</source>
          <target state="translated">(F) &lt;code&gt;$&amp;gt;&lt;/code&gt; 에 할당하려고했지만 운영 체제가 seteuid () 시스템 호출 (또는 이에 상응하는)을 지원하지 않거나 최소한 Configure는 그렇게 생각하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="cfacbdc2d44b8f4af0928acfaab8ae34b69e5e5d" translate="yes" xml:space="preserve">
          <source>(F) You tried to assign to &lt;code&gt;$&amp;lt;&lt;/code&gt; , and your operating system doesn't support the setruid() system call (or equivalent), or at least Configure didn't think so.</source>
          <target state="translated">(F) &lt;code&gt;$&amp;lt;&lt;/code&gt; 에 할당하려고했으나 운영 체제가 setruid () 시스템 호출 (또는 이에 상응하는)을 지원하지 않거나 최소한 Configure는 그렇게 생각하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="07b5214173c1fa2dec75d7ced9e1c11bcff01d47" translate="yes" xml:space="preserve">
          <source>(F) You tried to assign to &lt;code&gt;$(&lt;/code&gt; , and your operating system doesn't support the setrgid() system call (or equivalent), or at least Configure didn't think so.</source>
          <target state="translated">(F) &lt;code&gt;$(&lt;/code&gt; 에 할당하려고했지만 운영 체제가 setrgid () 시스템 호출 (또는 이에 상응하는)을 지원하지 않거나 최소한 Configure는 그렇게 생각하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="27cc0abdc7428678a64dfbc5b3bcc85aae3fac52" translate="yes" xml:space="preserve">
          <source>(F) You tried to assign to &lt;code&gt;$)&lt;/code&gt; , and your operating system doesn't support the setegid() system call (or equivalent), or at least Configure didn't think so.</source>
          <target state="translated">(F) &lt;code&gt;$)&lt;/code&gt; 을 할당하려고 시도했으며 운영 체제가 setegid () 시스템 호출 (또는 이에 상응하는)을 지원하지 않거나 최소한 Configure는 그렇게 생각하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="063729041dab79b09fb939a66e0b04c3f02257d6" translate="yes" xml:space="preserve">
          <source>(F) You tried to call a subroutine in the &lt;code&gt;CORE::&lt;/code&gt; namespace with &lt;code&gt;&amp;amp;foo&lt;/code&gt; syntax or through a reference. Some subroutines in this package cannot yet be called that way, but must be called as barewords. Something like this will work:</source>
          <target state="translated">(F) &lt;code&gt;CORE::&lt;/code&gt; 네임 스페이스에서 &lt;code&gt;&amp;amp;foo&lt;/code&gt; 구문을 사용하거나 참조를 통해 서브 루틴을 호출하려고했습니다 . 이 패키지의 일부 서브 루틴은 아직 그런 식으로 호출 할 수 없지만 베어 워드로 호출해야합니다. 이와 같은 것이 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1062f7f1f8f8cbe7aa7cef09d607ca1881742df4" translate="yes" xml:space="preserve">
          <source>(F) You tried to call a subroutine with &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;sub&lt;/code&gt; syntax, but the indicated subroutine hasn't been defined, or if it was, it has since been undefined.</source>
          <target state="translated">(F) &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;sub&lt;/code&gt; 구문을 사용하여 서브 루틴을 호출하려고 했지만 표시된 서브 루틴이 정의되지 않았거나 정의되지 않은 경우 서브 루틴이 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="0ce29e49a729e65aceaaffa37f7a4fa3f8649782" translate="yes" xml:space="preserve">
          <source>(F) You tried to call perl with the &lt;b&gt;-e&lt;/b&gt; switch, but</source>
          <target state="translated">(F) &lt;b&gt;-e&lt;/b&gt; 스위치로 perl을 호출하려고 했지만</target>
        </trans-unit>
        <trans-unit id="be9f09d2ff2c23282d5f09c489beb8e9761efd96" translate="yes" xml:space="preserve">
          <source>(F) You tried to call perl with the &lt;b&gt;-m&lt;/b&gt; switch, but you put something other than &quot;=&quot; after the module name.</source>
          <target state="translated">(F) &lt;b&gt;-m&lt;/b&gt; 스위치를 사용하여 perl을 호출하려고했지만 모듈 이름 뒤에 &quot;=&quot;이외의 다른 것을 넣습니다.</target>
        </trans-unit>
        <trans-unit id="e2ce51f1943a0f0fa57ff86c3a0165241043785c" translate="yes" xml:space="preserve">
          <source>(F) You tried to call require with no argument or with an undefined value as an argument. Require expects either a package name or a file-specification as an argument. See &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;.</source>
          <target state="translated">(F) 인수없이 또는 인수로 정의되지 않은 값으로 require를 호출하려고했습니다. Require는 패키지 이름 또는 파일 사양을 인수로 예상합니다. &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5a9f81d54eaa0857272dc230f21139d9d054ad74" translate="yes" xml:space="preserve">
          <source>(F) You tried to create a custom alias for a character name, with the &lt;code&gt;:alias&lt;/code&gt; option to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; charnames&lt;/code&gt; and the specified character in the indicated name isn't valid. See &lt;a href=&quot;charnames#CUSTOM-ALIASES&quot;&gt;CUSTOM ALIASES in charnames&lt;/a&gt;.</source>
          <target state="translated">(F)는 당신은으로, 캐릭터 이름에 대한 사용자 지정 별칭을 만들려고 &lt;code&gt;:alias&lt;/code&gt; 에 옵션을 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; charnames&lt;/code&gt; 및 지정된 이름에 지정된 문자 유효하지 않습니다. &lt;a href=&quot;charnames#CUSTOM-ALIASES&quot;&gt;charnames의 CUSTOM ALIASES를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb1c335cee8792105441b5c173b1526bdb4e5bfe" translate="yes" xml:space="preserve">
          <source>(F) You tried to declare a magical variable as a lexical variable. This is not allowed, because the magic can be tied to only one location (namely the global variable) and it would be incredibly confusing to have variables in your program that looked like magical variables but weren't.</source>
          <target state="translated">(F) 마법 변수를 어휘 변수로 선언하려고했습니다. 마법은 하나의 위치 (즉, 전역 변수)에만 연결될 수 있고 프로그램에서 마법 변수처럼 보이지만 그렇지 않은 변수를 갖는 것은 매우 혼란 스러울 수 있으므로 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3abca6da7dae4f5972582759d9d09fa3cfc29d0c" translate="yes" xml:space="preserve">
          <source>(F) You tried to define a customized To-mapping for lc(), lcfirst, uc(), or ucfirst() (or their string-inlined versions), but you specified an illegal mapping. See &lt;a href=&quot;perlunicode#User-Defined-Character-Properties&quot;&gt;User-Defined Character Properties in perlunicode&lt;/a&gt;.</source>
          <target state="translated">(F) lc (), lcfirst, uc () 또는 ucfirst () (또는 문자열 인라인 버전)에 대해 사용자 정의 된 To- 매핑을 정의하려고했지만 잘못된 매핑을 지정했습니다. &lt;a href=&quot;perlunicode#User-Defined-Character-Properties&quot;&gt;perlunicode의 사용자 정의 문자 특성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dc6952412563288ba53cc3962bc954118ee75001" translate="yes" xml:space="preserve">
          <source>(F) You tried to divide a number by 0 to get the remainder. Most numbers don't take to this kindly.</source>
          <target state="translated">(F) 나머지를 얻기 위해 숫자를 0으로 나누려고했습니다. 대부분의 숫자는 이것을 친절하게 받아들이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c363f0587d0a14de2c3546b6e3479714a4bd1d73" translate="yes" xml:space="preserve">
          <source>(F) You tried to divide a number by 0. Either something was wrong in your logic, or you need to put a conditional in to guard against meaningless input.</source>
          <target state="translated">(F) 숫자를 0으로 나누려고했습니다. 논리에 문제가 있거나 의미없는 입력을 막기 위해 조건을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="79f97edd419196ad91b287fc3875d20771a63514" translate="yes" xml:space="preserve">
          <source>(F) You tried to do a read/write/send/recv operation with a buffer length that is less than 0. This is difficult to imagine.</source>
          <target state="translated">(F) 버퍼 길이가 0보다 작은 읽기 / 쓰기 / 전송 / recv 작업을 시도했습니다. 상상하기 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="5d5fa49bc349cb2da3a612a957baabb6bb7cb44e" translate="yes" xml:space="preserve">
          <source>(F) You tried to do something that the tainting mechanism didn't like. The tainting mechanism is turned on when you're running setuid or setgid, or when you specify &lt;b&gt;-T&lt;/b&gt; to turn it on explicitly. The tainting mechanism labels all data that's derived directly or indirectly from the user, who is considered to be unworthy of your trust. If any such data is used in a &quot;dangerous&quot; operation, you get this error. See &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; for more information.</source>
          <target state="translated">(F) 당신은 오염기구가 좋아하지 않은 일을하려고했습니다. setuid 또는 setgid를 실행할 때 또는 &lt;b&gt;-T&lt;/b&gt; 를 지정 하여 명시 적으로 설정하면 오염 메커니즘이 켜집니다 . 오염 메커니즘은 사용자로부터 직간접 적으로 파생 된 모든 데이터에 귀하의 신뢰에 해당되지 않는 것으로 간주됩니다. 이러한 데이터가 &quot;위험한&quot;작업에 사용되면이 오류가 발생합니다. 자세한 정보는 &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="04f187132d8a09773787d4f0eb8c8a4d25f643e3" translate="yes" xml:space="preserve">
          <source>(F) You tried to do something with a function beginning with &quot;sem&quot;, &quot;shm&quot;, or &quot;msg&quot; but that System V IPC is not implemented in your machine. In some machines the functionality can exist but be unconfigured. Consult your system support.</source>
          <target state="translated">(F) &quot;sem&quot;, &quot;shm&quot;또는 &quot;msg&quot;로 시작하는 기능으로 무언가를 시도했지만 시스템에 해당 시스템 V IPC가 구현되어 있지 않습니다. 일부 컴퓨터에서는 기능이 존재할 수 있지만 구성 해제 될 수 있습니다. 시스템 지원에 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="13c297a61a3c3d6c0c21a7cb0243527c6f4c5662" translate="yes" xml:space="preserve">
          <source>(F) You tried to load a file with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; that failed to compile once already. Perl will not try to compile this file again unless you delete its entry from %INC. See &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; and &lt;a href=&quot;perlvar#%25INC&quot;&gt;%INC in perlvar&lt;/a&gt;.</source>
          <target state="translated">(F) &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 파일을로드하려고 시도 했거나 이미 컴파일에 실패한 파일이 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 합니다. Perl은 % INC에서 항목을 삭제하지 않으면이 파일을 다시 컴파일하지 않습니다. &lt;a href=&quot;perlvar#%25INC&quot;&gt;perlvar의 &lt;/a&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 및 % INC를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8eeebee53fd64e8fa425a2818094534b7e2fe3b9" translate="yes" xml:space="preserve">
          <source>(F) You tried to make an array value spring into existence, and the subscript was probably negative, even counting from end of the array backwards.</source>
          <target state="translated">(F) 배열 값을 스프링으로 만들려고했지만 배열의 끝부터 거꾸로 세어도 첨자가 음수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0987c56bf948df518444d26a634fc6df08517ff" translate="yes" xml:space="preserve">
          <source>(F) You tried to pack something that didn't comply with UTF-8 encoding rules and perl was unable to guess how to make more progress.</source>
          <target state="translated">(F) UTF-8 인코딩 규칙을 준수하지 않는 것을 포장하려고했지만 펄은 더 많은 발전을 이룰 방법을 추측 할 수 없었습니다.</target>
        </trans-unit>
        <trans-unit id="0f6f111d30c67b93089bb856fd04d8aa1669c101" translate="yes" xml:space="preserve">
          <source>(F) You tried to repeat a constant value (often the undefined value) with an assignment operator, which implies modifying the value itself. Perhaps you need to copy the value to a temporary, and repeat that.</source>
          <target state="translated">(F) 할당 연산자를 사용하여 상수 값 (보통 정의되지 않은 값)을 반복하려고했는데 값 자체가 수정되었습니다. 아마도 값을 임시로 복사하고 반복해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="97c951a8f22898d3f91dcff55beaa3e8d25f28d1" translate="yes" xml:space="preserve">
          <source>(F) You tried to return a complete array or hash from an lvalue subroutine, but you called the subroutine in a way that made Perl think you meant to return only one value. You probably meant to write parentheses around the call to the subroutine, which tell Perl that the call should be in list context.</source>
          <target state="translated">(F) lvalue 서브 루틴에서 완전한 배열 또는 해시를 리턴하려고 시도했지만 Perl이 하나의 값만 리턴한다고 생각하는 방식으로 서브 루틴을 호출했습니다. 서브 루틴에 대한 호출 주위에 괄호를 쓰려고했을 것인데, 이는 호출이 목록 컨텍스트에 있어야한다고 Perl에게 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="7cbcad7f90372b5f0f5329fee7ad6b12cb904275" translate="yes" xml:space="preserve">
          <source>(F) You tried to unpack something that didn't comply with UTF-8 encoding rules and perl was unable to guess how to make more progress.</source>
          <target state="translated">(F) UTF-8 인코딩 규칙을 준수하지 않는 것을 풀려고했지만 펄은 더 많은 발전을 이룰 방법을 추측 할 수 없었습니다.</target>
        </trans-unit>
        <trans-unit id="d16c1fb00c3e18338d85bd099c7c6076f3f0b27e" translate="yes" xml:space="preserve">
          <source>(F) You tried to use &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; to reach a label that was too deeply nested for Perl to reach. Perl is doing you a favor by refusing.</source>
          <target state="translated">(F) 펄이 도달하기에는 너무 깊게 중첩 된 라벨에 도달 하기 위해 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 를 사용하려고했습니다 . 펄은 거절함으로써 당신에게 호의를 베풀고 있습니다.</target>
        </trans-unit>
        <trans-unit id="febfe1b6997cda16c1efe794c7d1d646eec14e4f" translate="yes" xml:space="preserve">
          <source>(F) You tried to use a function with a malformed prototype. The syntax of function prototypes is given a brief compile-time check for obvious errors like invalid characters. A more rigorous check is run when the function is called. Perhaps the function's author was trying to write a subroutine signature but didn't enable that feature first (&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'signatures'&lt;/code&gt; ), so the signature was instead interpreted as a bad prototype.</source>
          <target state="translated">(F) 형식이 잘못된 프로토 타입이있는 함수를 사용하려고했습니다. 함수 프로토 타입의 구문에는 유효하지 않은 문자와 같은 명백한 오류에 대한 간단한 컴파일 타임 검사가 제공됩니다. 함수가 호출되면보다 엄격한 검사가 실행됩니다. 아마도 함수의 저자는 서브 루틴 서명을 작성하려고했지만 첫 번째 (이 기능을 사용하지 않도록 설정 한 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'signatures'&lt;/code&gt; 서명 대신 나쁜 프로토 타입으로 해석 그래서,).</target>
        </trans-unit>
        <trans-unit id="b9fc5831885091f728513fc59c94736c671b339f" translate="yes" xml:space="preserve">
          <source>(F) You tried to use a hash as a reference, as in &lt;code&gt;%foo-&amp;gt;{&quot;bar&quot;}&lt;/code&gt; or &lt;code&gt;%$ref-&amp;gt;{&quot;hello&quot;}&lt;/code&gt; . Versions of perl &amp;lt;= 5.22.0 used to allow this syntax, but shouldn't have. This was deprecated in perl 5.6.1.</source>
          <target state="translated">(F) &lt;code&gt;%foo-&amp;gt;{&quot;bar&quot;}&lt;/code&gt; 또는 &lt;code&gt;%$ref-&amp;gt;{&quot;hello&quot;}&lt;/code&gt; 와 같이 해시를 참조로 사용하려고했습니다 . perl &amp;lt;= 5.22.0의 버전은이 구문을 허용하는 데 사용되지만, 그렇지 않아야합니다. 이것은 perl 5.6.1에서 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1e2f9b7b8c68f866082676733ce65b571619374d" translate="yes" xml:space="preserve">
          <source>(F) You tried to use an array as a reference, as in &lt;code&gt;@foo-&amp;gt;[23]&lt;/code&gt; or &lt;code&gt;@$ref-&amp;gt;[99]&lt;/code&gt; . Versions of perl &amp;lt;= 5.22.0 used to allow this syntax, but shouldn't have. This was deprecated in perl 5.6.1.</source>
          <target state="translated">(F) &lt;code&gt;@$ref-&amp;gt;[99]&lt;/code&gt; &lt;code&gt;@foo-&amp;gt;[23]&lt;/code&gt; 또는 @ $ ref-&amp;gt; [99] 에서와 같이 배열을 참조로 사용하려고했습니다 . perl &amp;lt;= 5.22.0의 버전은이 구문을 허용하는 데 사용되지만, 그렇지 않아야합니다. 이것은 perl 5.6.1에서 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="24cc6e3d21667a912bda61be036ce6066d0637aa" translate="yes" xml:space="preserve">
          <source>(F) You tried to use an operator from a Safe compartment in which it's disallowed. See &lt;a href=&quot;safe&quot;&gt;Safe&lt;/a&gt;.</source>
          <target state="translated">(F) 허용되지 않은 안전실의 운전자를 사용하려고했습니다. &lt;a href=&quot;safe&quot;&gt;안전을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="40d1498f8036d7e30b24a88e9cae05fc3f576e01" translate="yes" xml:space="preserve">
          <source>(F) You tried to use in open() a PerlIO layer that does not exist, e.g. open(FH, &quot;&amp;gt;:nosuchlayer&quot;, &quot;somefile&quot;).</source>
          <target state="translated">(F) open ()에서 존재하지 않는 PerlIO 레이어 (예 : open (FH, &quot;&amp;gt; : nosuchlayer&quot;, &quot;somefile&quot;)를 사용하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="9f4e35f1e010f88b64cacafa7ea3fcc33b2acecb" translate="yes" xml:space="preserve">
          <source>(F) You tried, directly or indirectly, to change the value of a constant. You didn't, of course, try &quot;2 = 1&quot;, because the compiler catches that. But an easy way to do the same thing is:</source>
          <target state="translated">(F) 상수 값을 변경하기 위해 직접 또는 간접적으로 시도했습니다. 물론 컴파일러는 &quot;2 = 1&quot;을 시도하지 않았습니다. 그러나 똑같은 일을하는 쉬운 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="17178bf93c80f8ea86565fe1499ab0f0215d9498" translate="yes" xml:space="preserve">
          <source>(F) You used &lt;code&gt;\b{...}&lt;/code&gt; or &lt;code&gt;\B{...}&lt;/code&gt; and the &lt;code&gt;...&lt;/code&gt; is not known to Perl. The current valid ones are given in &lt;a href=&quot;perlrebackslash#%5cb%7b%7d%2c-%5cb%2c-%5cB%7b%7d%2c-%5cB&quot;&gt;\b{}, \b, \B{}, \B in perlrebackslash&lt;/a&gt;.</source>
          <target state="translated">(F) &lt;code&gt;\b{...}&lt;/code&gt; 또는 &lt;code&gt;\B{...}&lt;/code&gt; 를 사용했지만 &lt;code&gt;...&lt;/code&gt; 은 Perl에 알려져 있지 않습니다. 현재 유효한 것은 &lt;a href=&quot;perlrebackslash#%5cb%7b%7d%2c-%5cb%2c-%5cB%7b%7d%2c-%5cB&quot;&gt;perlrebackslash의 \ b {}, \ b, \ B {}, \ B에 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="702b13f2980954824b55e6d620953761dfec6874" translate="yes" xml:space="preserve">
          <source>(F) You used &lt;code&gt;\g0&lt;/code&gt; or similar in a regular expression. You may refer to capturing parentheses only with strictly positive integers (normal backreferences) or with strictly negative integers (relative backreferences). Using 0 does not make sense.</source>
          <target state="translated">(F) 정규 표현식에 &lt;code&gt;\g0&lt;/code&gt; 또는 이와 유사한 것을 사용했습니다 . 엄격하게 양의 정수 (일반 역 참조) 또는 음의 정수 (상대 역 참조)로만 괄호 캡처를 참조 할 수 있습니다. 0을 사용하는 것은 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="28cd0b8032f22eb77e2386a88a5829b801122d86" translate="yes" xml:space="preserve">
          <source>(F) You used &lt;code&gt;\p{}&lt;/code&gt; or &lt;code&gt;\P{}&lt;/code&gt; but the character property by that name could not be found. Maybe you misspelled the name of the property? See &lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;Properties accessible through \p{} and \P{} in perluniprops&lt;/a&gt; for a complete list of available official properties.</source>
          <target state="translated">(F) &lt;code&gt;\p{}&lt;/code&gt; 또는 &lt;code&gt;\P{}&lt;/code&gt; 했지만 해당 이름의 문자 속성을 찾을 수 없습니다. 어쩌면 당신은 재산의 철자를 잘못 썼습니까? 사용 가능한 공식 속성의 전체 목록은 &lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;perluniprops에서 \ p {} 및 \ P {}를 통해 액세스 할 수있는 속성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="69cb1a1b0ddbe26120fe67617ae019329d10084a" translate="yes" xml:space="preserve">
          <source>(F) You used a backslash-character combination which is not recognized by Perl inside character classes. This is a fatal error when the character class is used within &lt;code&gt;(?[ ])&lt;/code&gt; .</source>
          <target state="translated">(F) 문자 클래스 내부에서 Perl에 의해 인식되지 않는 백 슬래시 문자 조합을 사용했습니다. 문자 클래스가 &lt;code&gt;(?[ ])&lt;/code&gt; 내에서 사용될 때 치명적인 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="88674912daafed33e23e5bb37c961244f5d46ca8" translate="yes" xml:space="preserve">
          <source>(F) You used a digit other than 0 or 1 in a binary number.</source>
          <target state="translated">(F) 이진수로 0 또는 1 이외의 숫자를 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="4b39c10b6dd85043336773035730d4513ec9db56" translate="yes" xml:space="preserve">
          <source>(F) You used a pattern of the form &lt;code&gt;(*VERB)&lt;/code&gt; but did not terminate the pattern with a &lt;code&gt;)&lt;/code&gt;. Fix the pattern and retry.</source>
          <target state="translated">(F)를 사용하면 양식의 패턴 사용 &lt;code&gt;(*VERB)&lt;/code&gt; 만에 패턴을 종료하지 않았다 &lt;code&gt;)&lt;/code&gt; . 패턴을 수정하고 다시 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="7c286ea7d129af178a83077af59d26bbd6fe4b54" translate="yes" xml:space="preserve">
          <source>(F) You used a pattern of the form &lt;code&gt;(*VERB:ARG)&lt;/code&gt; but did not terminate the pattern with a &lt;code&gt;)&lt;/code&gt;. Fix the pattern and retry.</source>
          <target state="translated">(F)를 사용하면 양식의 패턴 사용 &lt;code&gt;(*VERB:ARG)&lt;/code&gt; 만에 패턴을 종료하지 않았다 &lt;code&gt;)&lt;/code&gt; . 패턴을 수정하고 다시 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="08e18a27e154c16efd7436c3b451a760941c2bb6" translate="yes" xml:space="preserve">
          <source>(F) You used a pattern that nested too many EVAL calls without consuming any text. Restructure the pattern so that text is consumed.</source>
          <target state="translated">(F) 텍스트를 소비하지 않고 너무 많은 EVAL 호출을 중첩시키는 패턴을 사용했습니다. 텍스트가 사용되도록 패턴을 재구성하십시오.</target>
        </trans-unit>
        <trans-unit id="273539c3f0573d8bcba263a7480443d45af0fa1f" translate="yes" xml:space="preserve">
          <source>(F) You used a pattern that references itself without consuming any input text. You should check the pattern to ensure that recursive patterns either consume text or fail.</source>
          <target state="translated">(F) 입력 텍스트를 사용하지 않고 자신을 참조하는 패턴을 사용했습니다. 재귀 패턴이 텍스트를 소비하거나 실패하는지 패턴을 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="68ce233d96cefbbfdc6b3133927eb00d22035acf" translate="yes" xml:space="preserve">
          <source>(F) You used a pattern that uses too many nested subpattern calls without consuming any text. Restructure the pattern so text is consumed before the nesting limit is exceeded.</source>
          <target state="translated">(F) 텍스트를 소비하지 않고 중첩 된 서브 패턴 호출을 너무 많이 사용하는 패턴을 사용했습니다. 중첩 한계를 초과하기 전에 텍스트를 사용하도록 패턴을 재구성하십시오.</target>
        </trans-unit>
        <trans-unit id="84bf3103d85b0b16b8ffe18d6ec37c090e0cdc12" translate="yes" xml:space="preserve">
          <source>(F) You used a regular expression extension that doesn't make sense. The &amp;lt;-- HERE shows whereabouts in the regular expression the problem was discovered. This may happen when using the &lt;code&gt;(?^...)&lt;/code&gt; construct to tell Perl to use the default regular expression modifiers, and you redundantly specify a default modifier. For other causes, see &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">(F) 말이되지 않는 정규 표현식 확장을 사용했습니다. &amp;lt;-HERE는 정규식에서 문제가 발견 된 위치를 보여줍니다. &lt;code&gt;(?^...)&lt;/code&gt; 구문을 사용하여 Perl에게 기본 정규 표현식 수정자를 사용하도록 지시하고 기본 수정자를 중복 지정하면 이러한 상황이 발생할 수 있습니다 . 다른 원인은 &lt;a href=&quot;perlre&quot;&gt;perlre를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="20def0b0e786659bbca9da38b47e4d457fa52407" translate="yes" xml:space="preserve">
          <source>(F) You used a verb pattern that is not allowed an argument. Remove the argument or check that you are using the right verb.</source>
          <target state="translated">(F) 인수가 허용되지 않는 동사 패턴을 사용했습니다. 인수를 제거하거나 올바른 동사를 사용하고 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="1cd989010970436dbc896d819901c9744f7f1b04" translate="yes" xml:space="preserve">
          <source>(F) You used a verb pattern that requires an argument. Supply an argument or check that you are using the right verb.</source>
          <target state="translated">(F) 인수가 필요한 동사 패턴을 사용했습니다. 인수를 제공하거나 올바른 동사를 사용하고 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="87f0d25e7c99816f9c2e0c94b9e0a10cd66687d3" translate="yes" xml:space="preserve">
          <source>(F) You used an 8 or 9 in an octal number.</source>
          <target state="translated">(F) 8 진수로 8 또는 9를 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="f3c5ae12861eacaae8c2de7411bb8cb7d61c50a1" translate="yes" xml:space="preserve">
          <source>(F) You used index/value array slice syntax (&lt;code&gt;%array[...]&lt;/code&gt; ) as the argument to &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt;. You probably meant &lt;code&gt;@array[...]&lt;/code&gt; with an @ symbol instead.</source>
          <target state="translated">(F) 인덱스 / 값 배열 슬라이스 구문 ( &lt;code&gt;%array[...]&lt;/code&gt; )을 &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; 인수로 사용했습니다. . &lt;code&gt;@array[...]&lt;/code&gt; 대신 @ 기호를 사용 했을 것입니다 .</target>
        </trans-unit>
        <trans-unit id="6d102d7f8864b00a70eec365c014ec3397d7e122" translate="yes" xml:space="preserve">
          <source>(F) You used key/value hash slice syntax (&lt;code&gt;%hash{...}&lt;/code&gt; ) as the argument to &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt;. You probably meant &lt;code&gt;@hash{...}&lt;/code&gt; with an @ symbol instead.</source>
          <target state="translated">(F) 키 / 값 해시 슬라이스 구문 ( &lt;code&gt;%hash{...}&lt;/code&gt; )을 &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; 인수로 사용했습니다. . 아마도 @ 기호가있는 &lt;code&gt;@hash{...}&lt;/code&gt; 를 의미 했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="58f6630fbd5815a4987fd285d7a5c9bdd5cd95c3" translate="yes" xml:space="preserve">
          <source>(F) You used local on a variable name that was previously declared as a lexical variable using &quot;my&quot; or &quot;state&quot;. This is not allowed. If you want to localize a package variable of the same name, qualify it with the package name.</source>
          <target state="translated">(F) 이전에 &quot;my&quot;또는 &quot;state&quot;를 사용하여 어휘 변수로 선언 된 변수 이름에서 local을 사용했습니다. 이것은 허용되지 않습니다. 동일한 이름의 패키지 변수를 현지화하려면 패키지 이름으로 해당 변수를 한정하십시오.</target>
        </trans-unit>
        <trans-unit id="cff696f6bd7b034bed3ab8e4afe8a625f52be854" translate="yes" xml:space="preserve">
          <source>(F) You used something like &lt;code&gt;(?(DEFINE)...|..)&lt;/code&gt; which is illegal. The most likely cause of this error is that you left out a parenthesis inside of the &lt;code&gt;....&lt;/code&gt; part.</source>
          <target state="translated">(F) 당신은 &lt;code&gt;(?(DEFINE)...|..)&lt;/code&gt; 와 같은 것을 불법으로 사용했습니다. 이 오류의 가장 큰 원인은 &lt;code&gt;....&lt;/code&gt; 안에 괄호를 생략했기 때문입니다 . 부분 .</target>
        </trans-unit>
        <trans-unit id="86492b612355c2e310c2b964c4a510da9e5ab9da" translate="yes" xml:space="preserve">
          <source>(F) You used something like &lt;code&gt;\7&lt;/code&gt; in your regular expression, but there are not at least seven sets of capturing parentheses in the expression. If you wanted to have the character with ordinal 7 inserted into the regular expression, prepend zeroes to make it three digits long: &lt;code&gt;\007&lt;/code&gt;</source>
          <target state="translated">(F) 정규식에 &lt;code&gt;\7&lt;/code&gt; 과 같은 것을 사용 했지만 식에 7 개 이상의 캡처 괄호가 없습니다. 서수 7이있는 문자를 정규식에 삽입하려면 3을 길게하여 0을 추가하십시오. &lt;code&gt;\007&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f533704c7254c593ad8ccd5a7de5ca331a185c09" translate="yes" xml:space="preserve">
          <source>(F) You used something like &lt;code&gt;\g{-7}&lt;/code&gt; in your regular expression, but there are not at least seven sets of closed capturing parentheses in the expression before where the &lt;code&gt;\g{-7}&lt;/code&gt; was located.</source>
          <target state="translated">(F) 정규 표현식에 &lt;code&gt;\g{-7}&lt;/code&gt; 과 같은 것을 사용 했지만 &lt;code&gt;\g{-7}&lt;/code&gt; 이 있기 전의 표현에는 적어도 7 개의 닫힌 캡처 괄호가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="20eedd26509d23438406f8c13451c8ecc8610ce2" translate="yes" xml:space="preserve">
          <source>(F) You used something like &lt;code&gt;\k'NAME'&lt;/code&gt; or &lt;code&gt;\k&amp;lt;NAME&amp;gt;&lt;/code&gt; in your regular expression, but there is no corresponding named capturing parentheses such as &lt;code&gt;(?'NAME'...)&lt;/code&gt; or &lt;code&gt;(?&amp;lt;NAME&amp;gt;...)&lt;/code&gt; . Check if the name has been spelled correctly both in the backreference and the declaration.</source>
          <target state="translated">(F) &lt;code&gt;\k'NAME'&lt;/code&gt; 또는 &lt;code&gt;\k&amp;lt;NAME&amp;gt;&lt;/code&gt; 과 같은 것을 사용 했지만 &lt;code&gt;(?'NAME'...)&lt;/code&gt; 또는 &lt;code&gt;(?&amp;lt;NAME&amp;gt;...)&lt;/code&gt; 과 같은 해당 명명 된 캡처 괄호는 없습니다 . )) . 역 참조 및 선언 모두에서 이름의 철자가 올바른지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="c80f04cdcc45163f116540186291e21510a7399f" translate="yes" xml:space="preserve">
          <source>(F) You used the &lt;b&gt;-S&lt;/b&gt; switch, but the copies of the script to execute found in the PATH did not have correct permissions.</source>
          <target state="translated">(F) &lt;b&gt;-S&lt;/b&gt; 스위치를 사용했지만 PATH에서 찾은 스크립트 사본에 올바른 권한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="cf0e35d4317159711f388b8204033a356b9197fc" translate="yes" xml:space="preserve">
          <source>(F) You used the &lt;b&gt;-S&lt;/b&gt; switch, but the script to execute could not be found in the PATH, or at least not with the correct permissions. The script exists in the current directory, but PATH prohibits running it.</source>
          <target state="translated">(F) &lt;b&gt;-S를&lt;/b&gt; 사용했습니다.&lt;b&gt;&lt;/b&gt; 스위치를 사용했지만 PATH에서 실행할 스크립트를 찾을 수 없거나 최소한 올바른 권한이 없습니다. 스크립트가 현재 디렉토리에 존재하지만 PATH는 실행을 금지합니다.</target>
        </trans-unit>
        <trans-unit id="d1b02f0d7e4f51f01bc987ca2b98c94fb4a58c44" translate="yes" xml:space="preserve">
          <source>(F) You used the &lt;b&gt;-S&lt;/b&gt; switch, but the script to execute could not be found in the PATH.</source>
          <target state="translated">(F) &lt;b&gt;-S&lt;/b&gt; 스위치를 사용했지만 PATH에서 실행할 스크립트를 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3400c05a8a734061ea98fdbb159f248382c94c3e" translate="yes" xml:space="preserve">
          <source>(F) You used the syntax of a method call, but the slot filled by the object reference or package name contains an expression that returns a defined value which is neither an object reference nor a package name. Something like this will reproduce the error:</source>
          <target state="translated">(F) 메소드 호출 구문을 사용했지만 오브젝트 참조 또는 패키지 이름으로 채워진 슬롯에 오브젝트 참조 나 패키지 이름이 아닌 정의 된 값을 리턴하는 표현식이 있습니다. 이와 같은 것이 오류를 재현합니다.</target>
        </trans-unit>
        <trans-unit id="41d63af3ce5594eb35bd2f491418feb32117eb7f" translate="yes" xml:space="preserve">
          <source>(F) You used the syntax of a method call, but the slot filled by the object reference or package name contains an undefined value. Something like this will reproduce the error:</source>
          <target state="translated">(F) 메소드 호출 구문을 사용했지만 오브젝트 참조 또는 패키지 이름으로 채워진 슬롯에 정의되지 않은 값이 있습니다. 이와 같은 것이 오류를 재현합니다.</target>
        </trans-unit>
        <trans-unit id="18b13e09d4e08845aab29b6147898169e828ddfb" translate="yes" xml:space="preserve">
          <source>(F) You wrote &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt; $foo&lt;/code&gt; with one argument after somehow causing the current package to be freed. Perl cannot figure out what to do, so it throws up in hands in despair.</source>
          <target state="translated">(F) 당신은 &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt; $foo&lt;/code&gt; $ foo를 썼습니다 어떻게 든 현재 패키지가 해제 된 후 하나의 인수로 를 . 펄은 어떻게해야할지 알 수 없으므로 절망에 빠진다.</target>
        </trans-unit>
        <trans-unit id="b4a9f0f6a7db7e8f10359042617a936ea1fcd37f" translate="yes" xml:space="preserve">
          <source>(F) You wrote &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; &amp;lt;file&amp;gt;&lt;/code&gt; when you should have written &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 'file'&lt;/code&gt; .</source>
          <target state="translated">(F) &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 'file'&lt;/code&gt; 'file'을 작성 해야 할 때 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; &amp;lt;file&amp;gt;&lt;/code&gt; 을 작성했습니다 .</target>
        </trans-unit>
        <trans-unit id="52e296f668c69ac58f1c4c9ce44e7c52c92191cd" translate="yes" xml:space="preserve">
          <source>(F) You wrote something like</source>
          <target state="translated">(F) 너는 다음과 같은 것을 썼다.</target>
        </trans-unit>
        <trans-unit id="6c542e06a12f8da13ac9ec338769f631a3564f28" translate="yes" xml:space="preserve">
          <source>(F) You wrote something like &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/a-z-0//&lt;/a&gt;&lt;/code&gt; which doesn't mean anything at all. To include a &lt;code&gt;-&lt;/code&gt; character in a transliteration, put it either first or last. (In the past, &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/a-z-0//&lt;/a&gt;&lt;/code&gt; was synonymous with &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/a-y//&lt;/a&gt;&lt;/code&gt;, which was probably not what you would have expected.)</source>
          <target state="translated">(F) &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/a-z-0//&lt;/a&gt;&lt;/code&gt; 와 같은 것을 쓰면 아무 의미가 없습니다. 음역에 &lt;code&gt;-&lt;/code&gt; 문자 를 포함 시키려면 문자를 맨 처음이나 마지막에 넣으십시오. (과거에 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/a-z-0//&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/a-y//&lt;/a&gt;&lt;/code&gt; 와 동의어 였으며 이는 아마도 예상했던 것과는 다릅니다 .)</target>
        </trans-unit>
        <trans-unit id="e8e38ea2fa5e64902c76bc95fcce4e33ba6a342b" translate="yes" xml:space="preserve">
          <source>(F) You're on a system such as MS-DOS that gets confused if you try reading from a deleted (but still opened) file. You have to say &lt;code&gt;-i.bak&lt;/code&gt; , or some such.</source>
          <target state="translated">(F) 삭제 된 (아직 열려있는) 파일에서 읽으려고 할 때 혼동되는 MS-DOS와 같은 시스템을 사용하고 있습니다. 당신은 말해야합니다 &lt;code&gt;-i.bak&lt;/code&gt; 또는 이와 합니다.</target>
        </trans-unit>
        <trans-unit id="7a83143d3c986b125503812901b1bff54ca36b16" translate="yes" xml:space="preserve">
          <source>(F) You're running under taint mode, and the &lt;code&gt;%ENV&lt;/code&gt; variable has been aliased to another hash, so it doesn't reflect anymore the state of the program's environment. This is potentially insecure.</source>
          <target state="translated">(F) 테 인트 모드에서 실행 중이고 &lt;code&gt;%ENV&lt;/code&gt; 변수가 다른 해시의 별칭으로 지정되어 더 이상 프로그램 환경의 상태를 반영하지 않습니다. 이것은 잠재적으로 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0a65946a393eb1b5a783157fd0c01027bbec212f" translate="yes" xml:space="preserve">
          <source>(F) You've mixed up your reference types. You have to dereference a reference of the type needed. You can use the ref() function to test the type of the reference, if need be.</source>
          <target state="translated">(F) 참조 유형을 혼합했습니다. 필요한 유형의 참조를 역 참조해야합니다. 필요한 경우 ref () 함수를 사용하여 참조 유형을 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="849a3a21e5e551e148cb4fd317c3f5abb5da518a" translate="yes" xml:space="preserve">
          <source>(F) You've omitted the closing parenthesis in a function prototype definition.</source>
          <target state="translated">(F) 함수 프로토 타입 정의에서 닫는 괄호를 생략했습니다.</target>
        </trans-unit>
        <trans-unit id="637d9c669950d2eb3b7bd08e20f94143e6b586fb" translate="yes" xml:space="preserve">
          <source>(F) You've said &quot;use strict&quot; or &quot;use strict vars&quot;, which indicates that all variables must either be lexically scoped (using &quot;my&quot; or &quot;state&quot;), declared beforehand using &quot;our&quot;, or explicitly qualified to say which package the global variable is in (using &quot;::&quot;).</source>
          <target state="translated">(F) &quot;엄격한 사용&quot;또는 &quot;엄격한 변수 사용&quot;이라고 말했는데, 이는 모든 변수의 어휘 범위 ( &quot;my&quot;또는 &quot;state&quot;사용), &quot;our&quot;를 사용하여 사전에 선언했거나 전역 변수가있는 패키지를 말하십시오 ( &quot;::&quot;사용).</target>
        </trans-unit>
        <trans-unit id="7630ca6246f34eae270881471cf277e175234aa6" translate="yes" xml:space="preserve">
          <source>(F) You've told Perl to dereference a string, something which &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; blocks to prevent it happening accidentally. See &lt;a href=&quot;perlref#Symbolic-references&quot;&gt;Symbolic references in perlref&lt;/a&gt;. This can be triggered by an &lt;code&gt;@&lt;/code&gt; or &lt;code&gt;$&lt;/code&gt; in a double-quoted string immediately before interpolating a variable, for example in &lt;code&gt;&quot;user @$twitter_id&quot;&lt;/code&gt; , which says to treat the contents of &lt;code&gt;$twitter_id&lt;/code&gt; as an array reference; use a &lt;code&gt;\&lt;/code&gt; to have a literal &lt;code&gt;@&lt;/code&gt; symbol followed by the contents of &lt;code&gt;$twitter_id&lt;/code&gt; : &lt;code&gt;&quot;user \@$twitter_id&quot;&lt;/code&gt; .</source>
          <target state="translated">(F)는 당신은 문자열, 뭔가 역 참조 펄 말 했어요 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; 가 실수로 발생 방지하기 위해 블록을. &lt;a href=&quot;perlref#Symbolic-references&quot;&gt;perlref의 기호 참조를 참조&lt;/a&gt; 하십시오 . 이은으로 트리거 될 수 &lt;code&gt;@&lt;/code&gt; 또는 &lt;code&gt;$&lt;/code&gt; 이중 인용 문자열 즉시, 예를 들어, 변수를 보간하기 전에 &lt;code&gt;&quot;user @$twitter_id&quot;&lt;/code&gt; 의 내용 치료라고하는 &lt;code&gt;$twitter_id&lt;/code&gt; 배열 참조로하는 단계; A가 사용하는 &lt;code&gt;\&lt;/code&gt; 문자 그대로 가지고 &lt;code&gt;@&lt;/code&gt; 의 내용 다음 기호 &lt;code&gt;$twitter_id&lt;/code&gt; : &lt;code&gt;&quot;user \@$twitter_id&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="328d1834e87cd3a12d0d886781df832cd4442476" translate="yes" xml:space="preserve">
          <source>(F) You've used the &lt;code&gt;/e&lt;/code&gt; switch to evaluate the replacement for a substitution, but perl found a syntax error in the code to evaluate, most likely an unexpected right brace '}'.</source>
          <target state="translated">(F) &lt;code&gt;/e&lt;/code&gt; 스위치를 사용하여 대체 대체를 평가했지만 perl은 코드에서 구문 오류가 발견되어 예상치 못한 오른쪽 괄호 '}'를 발견했습니다.</target>
        </trans-unit>
        <trans-unit id="494183ad4a67476ddc028be8b3568acd877e49b4" translate="yes" xml:space="preserve">
          <source>(F) Your C library apparently doesn't implement gethostent(), probably because if it did, it'd feel morally obligated to return every hostname on the Internet.</source>
          <target state="translated">(F) C 라이브러리는 gethostent ()를 구현하지 않는 것 같습니다. 아마도 그렇게한다면 인터넷에서 모든 호스트 이름을 반환해야한다는 도덕적 의무가 있기 때문일 것입니다.</target>
        </trans-unit>
        <trans-unit id="f385f8c5fde38f51661c7c67e8c893e31e564018" translate="yes" xml:space="preserve">
          <source>(F) Your Perl has not been configured to have PerlIO, and therefore you cannot use IO layers. To have PerlIO, Perl must be configured with 'useperlio'.</source>
          <target state="translated">(F) Perl이 PerlIO를 갖도록 구성되지 않았으므로 IO 계층을 사용할 수 없습니다. PerlIO를 가지려면 Perl을 'useperlio'로 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="614fec45449f413b67d662f4daef984b9091dd40" translate="yes" xml:space="preserve">
          <source>(F) Your format contains the ~~ repeat-until-blank sequence and a numeric field that will never go blank so that the repetition never terminates. You might use ^# instead. See &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt;.</source>
          <target state="translated">(F) 형식은 ~ ~ 반복 될 때까지 공백 시퀀스와 공백이되지 않는 숫자 필드를 포함하므로 반복이 종료되지 않습니다. 대신 ^ #을 사용할 수 있습니다. 보다&lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="97497e879f52c8e1b00a110160c36bbdbbd91f9e" translate="yes" xml:space="preserve">
          <source>(F) Your machine apparently doesn't implement fcntl(). What is this, a PDP-11 or something?</source>
          <target state="translated">(F) 컴퓨터가 분명히 fcntl ()을 구현하지 않습니다. 이것이 PDP-11 또는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="ed49e7629179f8a9c2972ce9ac26fb47a729c581" translate="yes" xml:space="preserve">
          <source>(F) Your machine apparently doesn't implement ioctl(), which is pretty strange for a machine that supports C.</source>
          <target state="translated">(F) 귀하의 컴퓨터는 분명히 ioctl ()을 구현하지 않습니다. 이는 C를 지원하는 컴퓨터에게는 매우 이상합니다.</target>
        </trans-unit>
        <trans-unit id="af2bb18338059cab0ae7ced878d9e7fe5bd60c7e" translate="yes" xml:space="preserve">
          <source>(F) Your machine doesn't implement a file truncation mechanism that Configure knows about.</source>
          <target state="translated">(F) 시스템은 Configure가 알고있는 파일 잘림 메커니즘을 구현하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b8f0f2fab8ba021c2aff30be6ec8130b769317ce" translate="yes" xml:space="preserve">
          <source>(F) Your machine doesn't implement the sockatmark() functionality, neither as a system call nor an ioctl call (SIOCATMARK).</source>
          <target state="translated">(F) 시스템은 sockatmark () 기능을 시스템 호출이나 ioctl 호출 (SIOCATMARK)로 구현하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0cd83d191af3ec605b7662460573c10840f0c873" translate="yes" xml:space="preserve">
          <source>(F) Your machine doesn't implement the umask function and you tried to use it to restrict permissions for yourself (EXPR &amp;amp; 0700).</source>
          <target state="translated">(F) 컴퓨터가 umask 기능을 구현하지 않았으며이를 사용하여 자신의 권한을 제한하려고했습니다 (EXPR &amp;amp; 0700).</target>
        </trans-unit>
        <trans-unit id="2b11a78ede1b18f203901e0ccba6fd091f9c8f08" translate="yes" xml:space="preserve">
          <source>(F) Your machine doesn't support dump/undump.</source>
          <target state="translated">(F) 컴퓨터가 덤프 / 언 덤프를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0f0aad5b06b2c1ded7cc326569f66bf0ed1faab9" translate="yes" xml:space="preserve">
          <source>(F) Your machine doesn't support opendir() and readdir().</source>
          <target state="translated">(F) 컴퓨터는 opendir () 및 readdir ()을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="645a9a2249bb1cbc3f97634aa27e2af51efd30d4" translate="yes" xml:space="preserve">
          <source>(F) Your machine doesn't support the Berkeley socket mechanism, or at least that's what Configure thought.</source>
          <target state="translated">(F) 컴퓨터가 버클리 소켓 메커니즘을 지원하지 않거나 적어도 그 구성이 생각한 것입니다.</target>
        </trans-unit>
        <trans-unit id="31a3fc23f65aaf3ad2d56cf49b721eeaf820b88a" translate="yes" xml:space="preserve">
          <source>(F) Your platform has very uncommon byte-order and integer size, so it was not possible to set up some or all fixed-width byte-order conversion functions. This is only a problem when you're using the '&amp;lt;' or '&amp;gt;' modifiers in (un)pack templates. See &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;.</source>
          <target state="translated">(F) 플랫폼의 바이트 순서와 정수 크기가 매우 다르기 때문에 일부 또는 모든 고정 너비 바이트 순서 변환 기능을 설정할 수 없습니다. (un) pack 템플릿에서 '&amp;lt;'또는 '&amp;gt;'수정자를 사용하는 경우에만 문제가됩니다. &lt;a href=&quot;functions/pack&quot;&gt;팩&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="541c90b8476d8d95887f552667cf16bb69fc7f1b" translate="yes" xml:space="preserve">
          <source>(F) Your platform's byte-order is neither big-endian nor little-endian, or it has a very strange pointer size. Packing and unpacking big- or little-endian floating point values and pointers may not be possible. See &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;.</source>
          <target state="translated">(F) 플랫폼의 바이트 순서가 빅 엔디안 또는 리틀 엔디안이 아니거나 포인터 크기가 매우 이상합니다. 빅 엔디안 또는 리틀 엔디안 부동 소수점 값 및 포인터의 패킹 및 언 패킹이 불가능할 수 있습니다. &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d9c5b20a54bcaff04c2df514716dd2603bfd867c" translate="yes" xml:space="preserve">
          <source>(F) Your program file begins with a Unicode Byte Order Mark (BOM) which declares it to be in a Unicode encoding that Perl cannot read.</source>
          <target state="translated">(F) 프로그램 파일은 Perl이 읽을 수없는 유니 코드 인코딩으로 선언 된 BOM (Unicode Byte Order Mark)으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="726635fd3d169e64dfd076f6d649aff0097bea8b" translate="yes" xml:space="preserve">
          <source>(F) Your system has POSIX getpgrp(), which takes no argument, unlike the BSD version, which takes a pid.</source>
          <target state="translated">(F) 시스템에는 POSIX getpgrp ()가 있으며, pid를 사용하는 BSD 버전과 달리 인수가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8f18f4da0bdd1b901a5d55a81a0199c8eef69a6b" translate="yes" xml:space="preserve">
          <source>(F) Your system has the setpgrp() from BSD 4.2, which takes no arguments, unlike POSIX setpgid(), which takes a process ID and process group ID.</source>
          <target state="translated">(F) 시스템에는 프로세스 ID와 프로세스 그룹 ID를 취하는 POSIX setpgid ()와 달리 BSD 4.2의 setpgrp ()가 인수를 갖지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9006dfed724faaaccb8df3e81d3833ac06bf1592" translate="yes" xml:space="preserve">
          <source>(F) Your template contains ()-groups with a ridiculously deep nesting level.</source>
          <target state="translated">(F) 템플릿에는 엄청나게 깊은 중첩 수준의 () 그룹이 있습니다.</target>
        </trans-unit>
        <trans-unit id="087118c14335b46c69254da20edb7615b6c9b8ed" translate="yes" xml:space="preserve">
          <source>(F) Your version of executable does not support forking.</source>
          <target state="translated">(F) 실행 가능한 버전이 분기를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d3516c882d9040351bf3f6df8288dc44dfe46801" translate="yes" xml:space="preserve">
          <source>(F) Your version of the C library apparently doesn't do times(). I suspect you're not running on Unix.</source>
          <target state="translated">(F) C 라이브러리 버전은 분명히 times ()를 수행하지 않습니다. 유닉스에서 실행되고 있지 않은 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="ffd7e5c7e49e9ba2dc066dd9d3105fed188cee2a" translate="yes" xml:space="preserve">
          <source>(F) defined() is not useful on arrays because it checks for an undefined</source>
          <target state="translated">(F) defined ()는 정의되지 않은 것을 검사하기 때문에 배열에 유용하지 않습니다</target>
        </trans-unit>
        <trans-unit id="f71023579259ca2a7a41517ed6b679b28ac0b1bb" translate="yes" xml:space="preserve">
          <source>(F) msgsnd() requires a string at least as long as sizeof(long).</source>
          <target state="translated">(F) msgsnd ()는 최소한 sizeof (long)만큼 긴 문자열을 요구합니다.</target>
        </trans-unit>
        <trans-unit id="e56e499593a725d44c18e9aef5ea05ad1730051b" translate="yes" xml:space="preserve">
          <source>(F)(P) Error resolving overloading specified by a method name (as opposed to a subroutine reference): no such method callable via the package. If the method name is &lt;code&gt;???&lt;/code&gt;, this is an internal error.</source>
          <target state="translated">(F) (P) 메소드 이름으로 지정된 과부하 해결 오류 (서브 루틴 참조와 반대) : 패키지를 통해 호출 할 수있는 메소드가 없습니다. 메소드 이름이 &lt;code&gt;???&lt;/code&gt; 내부 오류입니다.</target>
        </trans-unit>
        <trans-unit id="5d26c8170c015de2dca77a57b6b1f545e7a49095" translate="yes" xml:space="preserve">
          <source>(F)(W layer) You tried to do a read/write/send/recv/seek operation with an offset pointing outside the buffer. This is difficult to imagine. The sole exceptions to this are that zero padding will take place when going past the end of the string when either &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread()&lt;/a&gt;&lt;/code&gt;ing a file, or when seeking past the end of a scalar opened for I/O (in anticipation of future reads and to imitate the behavior with real files).</source>
          <target state="translated">(F) (W layer) 버퍼 외부를 가리키는 오프셋으로 읽기 / 쓰기 / 전송 / recv / seek 작업을 시도했습니다. 상상하기 어렵다. 이것에 대한 유일한 예외는 &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread()&lt;/a&gt;&lt;/code&gt; 중 하나가 문자열 끝을 지나갈 때 제로 패딩이 발생한다는 것입니다 는 파일을 할 때 또는 I / O를 위해 열린 스칼라의 끝을 지나갈 때 (미래의 읽기 및 실제 파일로 동작을 모방하기 위해).</target>
        </trans-unit>
        <trans-unit id="03f12d5314d08da8cfff6947dcd2c877601a4f08" translate="yes" xml:space="preserve">
          <source>(File::Spec::VMS used to do this for us, but it's being removed)</source>
          <target state="translated">(File :: Spec :: VMS는 우리를 위해 이것을 사용했지만 제거되고 있습니다)</target>
        </trans-unit>
        <trans-unit id="3570d6a58788aee334edb2e7327f6e3b68455403" translate="yes" xml:space="preserve">
          <source>(For the rest of this section, I'll assume that this &quot;first language class&quot; of Projname::L10N::en_us has _AUTO lexicon.)</source>
          <target state="translated">(이 섹션의 나머지 부분에서는 Projname :: L10N :: en_us의 &quot;제 1 언어 클래스&quot;에 _AUTO 사전이 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="a64416081926d856c0cceb653fefbb7f8243edcc" translate="yes" xml:space="preserve">
          <source>(Formerly &quot;aka&quot;.)</source>
          <target state="translated">(이전의 &quot;aka&quot;)</target>
        </trans-unit>
        <trans-unit id="229825b75900a4d42ff1f4e4b787d0018b60ed2b" translate="yes" xml:space="preserve">
          <source>(Formerly &quot;ava&quot;.)</source>
          <target state="translated">(이전의 &quot;ava&quot;)</target>
        </trans-unit>
        <trans-unit id="145f275077dc0a9c36ca7ac404684635eebe5874" translate="yes" xml:space="preserve">
          <source>(Formerly &quot;bam&quot;.)</source>
          <target state="translated">(이전의 &quot;bam&quot;)</target>
        </trans-unit>
        <trans-unit id="151d9a32a1799e105c76f41beaff824b866de3cc" translate="yes" xml:space="preserve">
          <source>(Formerly &quot;ewe&quot;.)</source>
          <target state="translated">(이전의 &quot;에웨어&quot;)</target>
        </trans-unit>
        <trans-unit id="ff99663ba1c41173da84204bb12f98f44eaebf31" translate="yes" xml:space="preserve">
          <source>(Formerly &quot;ful&quot;.)</source>
          <target state="translated">(이전의 &quot;풀&quot;)</target>
        </trans-unit>
        <trans-unit id="70d4261db30ac61e12879c5dba0a9a584db8093f" translate="yes" xml:space="preserve">
          <source>(Formerly &quot;ibo&quot;.)</source>
          <target state="translated">(이전의 &quot;ibo&quot;)</target>
        </trans-unit>
        <trans-unit id="23caf59cef24559080d6b900edee142e1058c34c" translate="yes" xml:space="preserve">
          <source>(Formerly &quot;in&quot;.)</source>
          <target state="translated">(이전의 &quot;in&quot;)</target>
        </trans-unit>
        <trans-unit id="2f6de56d51f9d574d00c23416e10cd54e5961e26" translate="yes" xml:space="preserve">
          <source>(Formerly &quot;iw&quot;.)</source>
          <target state="translated">(이전의 &quot;iw&quot;)</target>
        </trans-unit>
        <trans-unit id="caec1f1389ac5a0d3e8f324fc432925c3aa88b74" translate="yes" xml:space="preserve">
          <source>(Formerly &quot;jw&quot; because of a typo.)</source>
          <target state="translated">(오타 때문에 이전에는 &quot;jw&quot;)</target>
        </trans-unit>
        <trans-unit id="b6d00d4ba136ef92f276b8de7b8ffd74dad596ef" translate="yes" xml:space="preserve">
          <source>(Formerly &quot;kau&quot;.)</source>
          <target state="translated">(이전의 &quot;kau&quot;)</target>
        </trans-unit>
        <trans-unit id="7ee1dffce695b826e6c8a61ff3e93eceb234ede2" translate="yes" xml:space="preserve">
          <source>(Formerly &quot;kon&quot;.)</source>
          <target state="translated">(이전의 &quot;kon&quot;)</target>
        </trans-unit>
        <trans-unit id="cc06b1078a9062cde8287663826e70f9317a366f" translate="yes" xml:space="preserve">
          <source>(Formerly &quot;lub&quot;.)</source>
          <target state="translated">(이전의 &quot;윤활제&quot;.)</target>
        </trans-unit>
        <trans-unit id="301a2afa6110586dca748d29f337ed4353122c66" translate="yes" xml:space="preserve">
          <source>(Formerly &quot;lug&quot;.)</source>
          <target state="translated">(이전 명칭 &quot;lug&quot;)</target>
        </trans-unit>
        <trans-unit id="f25cb0a1e9ff4edbe153a50fcdc4f1a4f7fdec97" translate="yes" xml:space="preserve">
          <source>(From the security viewpoint, testing for permissions before attempting to do something is silly anyway: if one tries this, there is potential for race conditions. Someone or something might change the permissions between the permissions check and the actual operation. Just try the operation.)</source>
          <target state="translated">(보안 관점에서 볼 때 무언가를 시도하기 전에 권한을 테스트하는 것은 어리석은 일입니다. 누군가 시도하면 경쟁 조건이 발생할 수 있습니다. 누군가 또는 무언가가 권한 확인과 실제 작업간에 권한을 변경할 수 있습니다. .)</target>
        </trans-unit>
        <trans-unit id="5a92a9b5e358cf14ee485ba2e13c196b8e413a18" translate="yes" xml:space="preserve">
          <source>(Historical)</source>
          <target state="translated">(Historical)</target>
        </trans-unit>
        <trans-unit id="d1c22ff5f3432f13922dc3baee312a55d67a6376" translate="yes" xml:space="preserve">
          <source>(Historical) (Until 15th century or so.)</source>
          <target state="translated">(역사) (15 세기 정도까지)</target>
        </trans-unit>
        <trans-unit id="94ce260471d0e8e26d69af5c3e114969bf31b6a5" translate="yes" xml:space="preserve">
          <source>(Historical) NOT Chibchan (which is a language family).</source>
          <target state="translated">(역사적) NOT Chibchan (언어 가족).</target>
        </trans-unit>
        <trans-unit id="450bfa4db793d66c26a96917cf4502dda7f6eb78" translate="yes" xml:space="preserve">
          <source>(Historical) NOT Ladin! NOT Ladino!</source>
          <target state="translated">(역사적) Ladin이 아닙니다! Ladino가 아닙니다!</target>
        </trans-unit>
        <trans-unit id="0dc609aff59e64ef2b9589b3bb38b0edd476d332" translate="yes" xml:space="preserve">
          <source>(Historical?)</source>
          <target state="translated">(Historical?)</target>
        </trans-unit>
        <trans-unit id="2fafd5db1f40260d40c67be6b45e5df8a0f716f8" translate="yes" xml:space="preserve">
          <source>(I don't dare make any comparison with Unicode Consortium and the Vogons here ;) Or, comparing Encode to Babel Fish is completely appropriate -- if you can only stick this into your ear :)</source>
          <target state="translated">(유니 코드 컨소시엄과 Vogons와의 비교는 감히하지 않습니다.) 또는 Encode를 Babel Fish와 비교하는 것이 완벽합니다-귀에 만 붙일 수 있다면 :)</target>
        </trans-unit>
        <trans-unit id="5332303ce804dacc543b9c5fb49ae58e3dd90ddc" translate="yes" xml:space="preserve">
          <source>(I.e. &lt;code&gt;ATTR(ANY)&lt;/code&gt; is a synonym for &lt;code&gt;:ATTR&lt;/code&gt; ).</source>
          <target state="translated">(즉, &lt;code&gt;ATTR(ANY)&lt;/code&gt; 는 &lt;code&gt;:ATTR&lt;/code&gt; 과 동의어입니다 ).</target>
        </trans-unit>
        <trans-unit id="293eff504cb4f9714b7272e90eaae9bc13bc379e" translate="yes" xml:space="preserve">
          <source>(If &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is set, then this depends on the current locale.) Today it is more common to use the quotemeta() function or the &lt;code&gt;\Q&lt;/code&gt; metaquoting escape sequence to disable all metacharacters' special meanings like this:</source>
          <target state="translated">(경우에 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 설정되어, 다음이 현재 로케일에 따라 달라집니다.) 오늘은 quotemeta () 함수 또는 사용하는 것이 일반적이다 &lt;code&gt;\Q&lt;/code&gt; 과 같이 모든 메타 문자 '특별한 의미를 비활성화 metaquoting 이스케이프 시퀀스를 :</target>
        </trans-unit>
        <trans-unit id="6875a21292beabb9918b7735a9167aa85e103833" translate="yes" xml:space="preserve">
          <source>(If a curly bracket occurs in any other context and does not form part of a backslashed sequence like &lt;code&gt;\x{...}&lt;/code&gt; , it is treated as a regular character. However, a deprecation warning is raised for all such occurrences, and in Perl v5.26, literal uses of a curly bracket will be required to be escaped, say by preceding them with a backslash (&lt;code&gt;&quot;\{&quot;&lt;/code&gt; ) or enclosing them within square brackets (&lt;code&gt;&quot;[{]&quot;&lt;/code&gt; ). This change will allow for future syntax extensions (like making the lower bound of a quantifier optional), and better error checking of quantifiers.)</source>
          <target state="translated">(중괄호가 다른 컨텍스트에서 발생하고 &lt;code&gt;\x{...}&lt;/code&gt; 와 같이 백 슬래시 시퀀스의 일부를 형성하지 않으면 일반 문자로 취급되지만 이러한 모든 경우에 대해 사용 중단 경고가 발생합니다. Perl v5.26에서 중괄호를 문자 그대로 사용하려면 백 슬래시 ( &lt;code&gt;&quot;\{&quot;&lt;/code&gt; )로 시작하거나 대괄호 ( &lt;code&gt;&quot;[{]&quot;&lt;/code&gt; )로 묶는 등의 방법 으로 이스케이프 처리해야합니다 . 향후 구문 확장 (양자화의 하한을 선택적으로 만드는 것과 같음) 및 양화 자의 오류 검사를 개선합니다.)</target>
        </trans-unit>
        <trans-unit id="11d2c8ee774262d31e40dea3f3a66aeaf4c1f22e" translate="yes" xml:space="preserve">
          <source>(If the entry doesn't exist, the return value is a single meaningless true value.)</source>
          <target state="translated">항목이 존재하지 않으면 반환 값은 의미없는 단일 값입니다.</target>
        </trans-unit>
        <trans-unit id="a6d5a526ef92e8ad93680d3a65aa7158c7c852ac" translate="yes" xml:space="preserve">
          <source>(If you don't receive a &quot;Can't locate ... in @INC&quot; error message, then Perl found the module name you asked for.)</source>
          <target state="translated">&quot;@INC에서 ...을 찾을 수 없습니다&quot;오류 메시지가 표시되지 않으면 Perl에서 요청한 모듈 이름을 찾은 것입니다.</target>
        </trans-unit>
        <trans-unit id="99a7a0acd725c26a5ae45acbbb16e8bc31a27fa0" translate="yes" xml:space="preserve">
          <source>(If you don't specify test scripts, the whole test suite will be run.)</source>
          <target state="translated">테스트 스크립트를 지정하지 않으면 전체 테스트 스위트가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="7985684dd316aed11b1adec084c4f73194c7d80c" translate="yes" xml:space="preserve">
          <source>(Implementationally, searching with limit_glob ends up setting limit_re and usually dir_prefix.)</source>
          <target state="translated">(구체적으로 limit_glob로 검색하면 limit_re 및 보통 dir_prefix가 설정됩니다.)</target>
        </trans-unit>
        <trans-unit id="25ae98ab791d31d815cbe84ec98fe03b4f5b63bf" translate="yes" xml:space="preserve">
          <source>(In Perls earlier than 5.8.1 the &lt;b&gt;-C&lt;/b&gt; switch was a Win32-only switch that enabled the use of Unicode-aware &quot;wide system call&quot; Win32 APIs. This feature was practically unused, however, and the command line switch was therefore &quot;recycled&quot;.)</source>
          <target state="translated">5.8.1 이전의 Perls에서 &lt;b&gt;-C&lt;/b&gt; 스위치는 유니 코드를 인식하는 &quot;와이드 시스템 호출&quot;Win32 API를 사용할 수있는 Win32 전용 스위치입니다. 그러나이 기능은 실제로 사용되지 않았으므로 명령 행 스위치는 &quot; 재활용 &quot;)</target>
        </trans-unit>
        <trans-unit id="799a90307dde4c2a38f9dd856c0cad03bb288437" translate="yes" xml:space="preserve">
          <source>(In SGMLish jargon, all Pod commands are like block-level elements, whereas all Pod formatting codes are like inline-level elements.)</source>
          <target state="translated">SGMLish 전문 용어에서 모든 포드 명령은 블록 레벨 요소와 비슷하지만 모든 포드 형식 코드는 인라인 레벨 요소와 같습니다.</target>
        </trans-unit>
        <trans-unit id="e95f4a9528bab498d1e4961f121504ef2fd3aa68" translate="yes" xml:space="preserve">
          <source>(In the absence of an explicit &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;, a subroutine, eval, or do FILE automatically returns the value of the last expression evaluated.)</source>
          <target state="translated">명시적인 &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 이 없으면 서브 루틴, eval 또는 do FILE은 마지막으로 평가 된 마지막 값을 자동으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e8700d073c05a7cd45f4c88312a6410a7ccaf3d2" translate="yes" xml:space="preserve">
          <source>(In the absence of an explicit &lt;code&gt;&lt;a href=&quot;return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;, a subroutine, eval, or do FILE automatically returns the value of the last expression evaluated.)</source>
          <target state="translated">명시적인 &lt;code&gt;&lt;a href=&quot;return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 이 없으면 서브 루틴, eval 또는 do FILE은 마지막으로 평가 된 마지막 값을 자동으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cc1615ce00c8de68ce78f0baada446f5b951e3d5" translate="yes" xml:space="preserve">
          <source>(Internal) debug options, probably only useful if &lt;code&gt;-r&lt;/code&gt; included. The &lt;code&gt;t&lt;/code&gt; option prints the object on the top of the stack as it's being tracked. The &lt;code&gt;O&lt;/code&gt; option prints each operator as it's being processed in the execution order of the program.</source>
          <target state="translated">(내부) 디버그 옵션. 아마도 &lt;code&gt;-r&lt;/code&gt; 이 포함 된 경우에만 유용합니다 . &lt;code&gt;t&lt;/code&gt; 의 가 추적중인 것으로 옵션은 스택의 상단에있는 객체를 인쇄합니다. &lt;code&gt;O&lt;/code&gt; 의 이 프로그램의 실행 순서에 따라 처리되는 것 같이, 각 옵션은 오퍼레이터가 인쇄.</target>
        </trans-unit>
        <trans-unit id="1252b953e861a258d910814cd08a40eaecd98f07" translate="yes" xml:space="preserve">
          <source>(Is &lt;code&gt;LATIN CAPITAL LETTER A WITH ACUTE&lt;/code&gt; equal to &lt;code&gt;LATIN CAPITAL LETTER A&lt;/code&gt; ?)</source>
          <target state="translated">(IS &lt;code&gt;LATIN CAPITAL LETTER A WITH ACUTE&lt;/code&gt; 동일한 &lt;code&gt;LATIN CAPITAL LETTER A&lt;/code&gt; ?)</target>
        </trans-unit>
        <trans-unit id="19a31d35fd3cf749a6f2c6f016dc26417e810410" translate="yes" xml:space="preserve">
          <source>(It also provides a kind of workaround for RT#60374: &quot;Safe.pm sort {} bug with -Dusethreads&quot;. See &lt;a href=&quot;http://rt.perl.org/rt3//Public/Bug/Display.html?id=60374&quot;&gt;http://rt.perl.org/rt3//Public/Bug/Display.html?id=60374&lt;/a&gt; for</source>
          <target state="translated">또한 RT # 60374에 대한 일종의 해결 방법을 제공합니다. &quot;-Dusethreads의 Safe.pm sort {} 버그&quot; &lt;a href=&quot;http://rt.perl.org/rt3//Public/Bug/Display.html?id=60374&quot;&gt;http://rt.perl.org/rt3//Public/Bug/Display.html?id= 에&lt;/a&gt; 대한 60374</target>
        </trans-unit>
        <trans-unit id="4968103bd9c33fe0bd4b0d7710cba3cc4b7f7c59" translate="yes" xml:space="preserve">
          <source>(It is actually possible to get private functions by saying:</source>
          <target state="translated">(실제로 다음과 같이 말하면 개인 기능을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a88f4a87692e147c08e6d72244cc2946d8b7c4d" translate="yes" xml:space="preserve">
          <source>(It is actually possible to get private functions by saying: &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $subref = &lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; { ... }; &amp;amp;$subref;&lt;/code&gt; . But there's no way to call that directly as a method, because a method must have a name in the symbol table.)</source>
          <target state="translated">(실제로 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $subref = &lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; { ... }; &amp;amp;$subref;&lt;/code&gt; 라고 말하면 개인 함수를 얻을 수 있습니다. 그러나 메소드는 심볼에 이름이 있어야하기 때문에 메소드로 직접 호출 할 수는 없습니다 표.)</target>
        </trans-unit>
        <trans-unit id="cf8c2c67bc6bba9cb24dd802da2b3ce6b1a21a6c" translate="yes" xml:space="preserve">
          <source>(It is planned to extend this behavior to ranges in &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; in Perl v5.24.)</source>
          <target state="translated">(이 동작을 Perl v5.24 에서 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 범위로 확장 할 계획 입니다.)</target>
        </trans-unit>
        <trans-unit id="78c0bd7f1dbfc5a721844457f76c5e9531be7aad" translate="yes" xml:space="preserve">
          <source>(Linux).</source>
          <target state="translated">(Linux).</target>
        </trans-unit>
        <trans-unit id="2c59eb0b5a3304e9ab1611d4757f5384660b82a6" translate="yes" xml:space="preserve">
          <source>(Mnemonic &quot;This is like that&quot;.)</source>
          <target state="translated">(니모닉 &quot;이것과 같습니다&quot;)</target>
        </trans-unit>
        <trans-unit id="e10d101e5fb81d50e9082ec790450839ba188b38" translate="yes" xml:space="preserve">
          <source>(Mnemonic: &quot;This is ok.&quot;)</source>
          <target state="translated">(니모닉 : &quot;괜찮아.&quot;</target>
        </trans-unit>
        <trans-unit id="7c3374f77fa09317b34268275f5b80bb4dc31f1f" translate="yes" xml:space="preserve">
          <source>(Mnemonic: &quot;This is that.&quot; &quot;This isn't that.&quot;)</source>
          <target state="translated">(니모닉 : &quot;이것이 맞습니다.&quot; &quot;이것이 아닙니다.&quot;</target>
        </trans-unit>
        <trans-unit id="166c71891738ca1cf30d20d5d8c4636b572ccc9d" translate="yes" xml:space="preserve">
          <source>(NFD).</source>
          <target state="translated">(NFD).</target>
        </trans-unit>
        <trans-unit id="9c5bb3805c43c4b933ad7d21352d4e86ffa1e704" translate="yes" xml:space="preserve">
          <source>(NOT &quot;jp&quot;!)</source>
          <target state="translated">( &quot;jp&quot;아님!)</target>
        </trans-unit>
        <trans-unit id="492eff87c9da08b8f14d5953528b66319b80d30e" translate="yes" xml:space="preserve">
          <source>(No, (C) is not needed. No, &quot;all rights reserved&quot; is not needed.)</source>
          <target state="translated">(아니요, (C)는 필요하지 않습니다. &quot;모든 권리 보유&quot;는 필요하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="1355d9347b48e13a4ae0b109b3bbdbb9eb66ce25" translate="yes" xml:space="preserve">
          <source>(Note that a missing or undefined value means a different thing in the first slot than in the second. That's so that &lt;code&gt;batch_convert()&lt;/code&gt; with no arguments (or undef arguments) means &quot;go from @INC, into the current directory.)</source>
          <target state="translated">(없거나 정의되지 않은 값은 첫 번째 슬롯에서 두 번째 슬롯과 다른 것을 의미합니다. 따라서 &lt;code&gt;batch_convert()&lt;/code&gt; 없는 batch_convert () (또는 undef 인수)는 &quot;@INC에서 현재 디렉토리로 이동&quot;을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1a3032eac7bfb2ffbaf6460506183b59585f63db" translate="yes" xml:space="preserve">
          <source>(Note that having *nixish full path to perl</source>
          <target state="translated">(펄에 대한 완전한 경로를 가지고 있음에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="48e170a45cf8d2966c20a07ed3d690064ceb164c" translate="yes" xml:space="preserve">
          <source>(Note that in previous drafts of this document and of perlpod, formatting codes were referred to as &quot;interior sequences&quot;, and this term may still be found in the documentation for Pod parsers, and in error messages from Pod processors.)</source>
          <target state="translated">(이 문서와 perlpod의 이전 초안에서는 서식 코드를 &quot;내부 시퀀스&quot;라고했습니다.이 용어는 포드 파서의 설명서와 포드 프로세서의 오류 메시지에서 찾을 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="233b62f32598318b6eb6ae947a040ff4e967ade4" translate="yes" xml:space="preserve">
          <source>(Note that print doesn't do what you expect if the expression starts with '(' hence the &lt;code&gt;+&lt;/code&gt; )</source>
          <target state="translated">(표현식이 '('로 시작하여 &lt;code&gt;+&lt;/code&gt; )로 시작하면 print는 예상대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a685bbe2884ef5c0dd02e430c8f163847f3ce51d" translate="yes" xml:space="preserve">
          <source>(Note that processing of &lt;code&gt;PERL_RL&lt;/code&gt; for ornaments is in the discretion of the particular used &lt;code&gt;Term::ReadLine::*&lt;/code&gt; package).</source>
          <target state="translated">장식품에 대한 &lt;code&gt;PERL_RL&lt;/code&gt; 처리는 사용 된 특정 &lt;code&gt;Term::ReadLine::*&lt;/code&gt; 패키지 의 재량에 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="4e2778ef521ae1fa2d7ac34c4918dbf3558f6517" translate="yes" xml:space="preserve">
          <source>(Note that some of these may be moved to different libraries - eventually).</source>
          <target state="translated">(이들 중 일부는 다른 라이브러리로 옮겨 질 수 있습니다-결국).</target>
        </trans-unit>
        <trans-unit id="546e022518f1e629160174e4ca81f514c17f6c71" translate="yes" xml:space="preserve">
          <source>(Note that the &lt;a href=&quot;bigint&quot;&gt;bigint&lt;/a&gt;, &lt;a href=&quot;bigrat&quot;&gt;bigrat&lt;/a&gt;, and &lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt; pragmas all support &lt;code&gt;&quot;NaN&quot;&lt;/code&gt; .)</source>
          <target state="translated">(주 그 &lt;a href=&quot;bigint&quot;&gt;BIGINT&lt;/a&gt; , &lt;a href=&quot;bigrat&quot;&gt;bigrat&lt;/a&gt; 과 &lt;a href=&quot;bignum&quot;&gt;의 bignum&lt;/a&gt; 프라 그마 모든 지원 &lt;code&gt;&quot;NaN&quot;&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="01e9d2c00dfed840c5dac793116f604ce7782cdd" translate="yes" xml:space="preserve">
          <source>(Note that the command line there contains a literal atsign-I-N-C. This is handled as a special case by batch_convert, in order to save you having to enter the odd-looking &quot;&quot; as the first command-line parameter when you mean &quot;just use whatever's in @INC&quot;.)</source>
          <target state="translated">(명령 줄에는 리터럴 atsign-INC가 포함되어 있습니다. 이는 &quot;just&quot;를 의미 할 때 이상한 모양의 &quot;&quot;를 첫 번째 명령 줄 매개 변수로 입력하지 않아도되도록 batch_convert에 의해 특수한 경우로 처리됩니다. @INC에있는 모든 것을 사용하십시오. &quot;)</target>
        </trans-unit>
        <trans-unit id="bfb9a883d7456fdcdc1db6d793ab9a36440210e3" translate="yes" xml:space="preserve">
          <source>(Note that the newline is kept separate to avoid confusing the terminal as described above since a background color is being used.)</source>
          <target state="translated">배경색을 사용하고 있으므로 위에서 설명한대로 줄 바꿈을 방지하기 위해 줄 바꿈은 별도로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="4c2b89ad238aefa4861b3ead38cc3a950a87703f" translate="yes" xml:space="preserve">
          <source>(Note that the template &lt;code&gt;A*&lt;/code&gt; would only have packed &lt;code&gt;$str[0]&lt;/code&gt; in full length.)</source>
          <target state="translated">(템플릿 &lt;code&gt;A*&lt;/code&gt; 는 전체 길이로 &lt;code&gt;$str[0]&lt;/code&gt; 만 포장했을 것 입니다.)</target>
        </trans-unit>
        <trans-unit id="fd7bd20183a190bf400bf50bbd6cbac4b1d932f4" translate="yes" xml:space="preserve">
          <source>(Note that these steps are usually handled automatically by the extension's Makefile).</source>
          <target state="translated">(이 단계는 일반적으로 확장 프로그램의 Makefile에 의해 자동으로 처리됩니다.)</target>
        </trans-unit>
        <trans-unit id="c8eb1736f88b50ffbb2960f7c05438db21346262" translate="yes" xml:space="preserve">
          <source>(Note that we don't have to test for invariant characters in the examples above. The functions work on any well-formed UTF-8 input. It's just that its faster to avoid the function overhead when it's not needed.)</source>
          <target state="translated">(위 예제에서 불변 문자를 테스트 할 필요는 없습니다. 함수는 올바른 형식의 UTF-8 입력에서 작동합니다. 필요하지 않은 경우 함수 오버 헤드를 피하는 것이 더 빠릅니다.)</target>
        </trans-unit>
        <trans-unit id="b024759505277f3f0c7ac6e37fe6694d87ea35be" translate="yes" xml:space="preserve">
          <source>(Note that you can put spaces in the template to make it more readable, but they don't translate to spaces in the output.) Here's what we got this time:</source>
          <target state="translated">(가독성을 높이기 위해 템플릿에 공백을 넣을 수는 있지만 출력에서 ​​공백으로 변환되지는 않습니다.) 이번에 얻은 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dd2807f0715a16538be7069494b7b15e1777771e" translate="yes" xml:space="preserve">
          <source>(Note: &quot;mk man&quot; may produce some extraneous noise. Fear not.)</source>
          <target state="translated">(참고 : &quot;mk man&quot;은 외부 소음을 유발할 수 있습니다. 두려워하지 마십시오.)</target>
        </trans-unit>
        <trans-unit id="d411461bb1f05ef733ec9e835ceb320d84309b23" translate="yes" xml:space="preserve">
          <source>(Note: If your rand function consistently returns numbers that are too large or too small, then your version of Perl was probably compiled with the wrong number of RANDBITS.)</source>
          <target state="translated">(참고 : rand 함수가 너무 크거나 작은 숫자를 일관되게 반환하면 Perl 버전이 잘못된 RANDBITS로 컴파일 된 것입니다.)</target>
        </trans-unit>
        <trans-unit id="b57141d9afb7f420276d43eb36561546cdf1db1d" translate="yes" xml:space="preserve">
          <source>(Note: This subroutine is only available under Perl5.005)</source>
          <target state="translated">(참고 :이 서브 루틴은 Perl5.005에서만 사용 가능합니다)</target>
        </trans-unit>
        <trans-unit id="8e437ce6a47a77b7e6aeb1d60b42f0b60edc4c11" translate="yes" xml:space="preserve">
          <source>(Note: the mod_perl apache module uses also this environment variable for its own purposes and extended its semantics. Refer to the mod_perl documentation for more information. Also, spawned threads do the equivalent of setting this variable to the value 1.)</source>
          <target state="translated">(참고 : mod_perl 아파치 모듈은이 환경 변수를 자체 목적으로 사용하고 의미를 확장했습니다. 자세한 내용은 mod_perl 설명서를 참조하십시오. 또한 생성 된 스레드는이 변수를 값 1로 설정하는 것과 같습니다.)</target>
        </trans-unit>
        <trans-unit id="c7cd3ff564af134bb07b5dd021a5faa1ebbc1ae5" translate="yes" xml:space="preserve">
          <source>(Note: we couldn't use MAKEFILE because dmake uses this for something else).</source>
          <target state="translated">(참고 : dmake는 이것을 다른 용도로 사용하기 때문에 MAKEFILE을 사용할 수 없습니다).</target>
        </trans-unit>
        <trans-unit id="8407afebb21fd26808154e780e7ee32251329756" translate="yes" xml:space="preserve">
          <source>(Obviously, this call does not affect any currently extant threads.)</source>
          <target state="translated">(이 호출은 현재 존재하는 스레드에는 영향을 미치지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="412cad67f77110e218e2b89cee40a6217df882f1" translate="yes" xml:space="preserve">
          <source>(Of course you need lha or tar and gunzip for this.)</source>
          <target state="translated">(물론 lha 또는 tar와 gunzip이 필요합니다.)</target>
        </trans-unit>
        <trans-unit id="b58cef1c1013ff90df2979257338e5962a4f3f9d" translate="yes" xml:space="preserve">
          <source>(On EBCDIC platforms, Perl uses instead UTF-EBCDIC, which is a form of UTF-8 adapted for EBCDIC platforms. Below, we just talk about UTF-8. UTF-EBCDIC is like UTF-8, but the details are different. The macros hide the differences from you, just remember that the particular numbers and bit patterns presented below will differ in UTF-EBCDIC.)</source>
          <target state="translated">(EBCDIC 플랫폼에서 Perl은 EBCDIC 플랫폼에 맞게 UTF-8 형식 인 UTF-EBCDIC을 대신 사용합니다. 아래에서는 UTF-8에 대해서만 설명합니다. UTF-EBCDIC는 UTF-8과 유사하지만 세부 사항은 다릅니다. 매크로는 차이점을 숨기고 아래 제시된 특정 숫자와 비트 패턴은 UTF-EBCDIC에서 다름을 기억하십시오.)</target>
        </trans-unit>
        <trans-unit id="3a21ac78f3f37d985b7a09325ab452e0547af12a" translate="yes" xml:space="preserve">
          <source>(On systems that provide a handle for the loaded object such as SunOS and HPUX, $libref will be that handle. On other systems $libref will typically be $filename or a pointer to a buffer containing $filename. The application should not examine or alter $libref in any way.)</source>
          <target state="translated">(SunOS 및 HPUX와 같이로드 된 객체에 대한 핸들을 제공하는 시스템에서는 $ libref가 해당 핸들이됩니다. 다른 시스템에서 $ libref는 일반적으로 $ filename 또는 $ filename을 포함하는 버퍼에 대한 포인터입니다. 어떤 식 으로든 $ libref를 변경하십시오.)</target>
        </trans-unit>
        <trans-unit id="7916f8c996ac07822116110d01cd4bab3b6a88ec" translate="yes" xml:space="preserve">
          <source>(Only in Linux) Run all the tests using the memory leak + naughty memory access tool &quot;valgrind&quot;. The log files will be named</source>
          <target state="translated">(Linux에서만) 메모리 누수 + 나쁜 메모리 액세스 도구 &quot;valgrind&quot;를 사용하여 모든 테스트를 실행하십시오. 로그 파일 이름이 지정됩니다</target>
        </trans-unit>
        <trans-unit id="09e5f8a81952c9376c925e7707e489da99abfd90" translate="yes" xml:space="preserve">
          <source>(Optional.) Flush the cache completely.</source>
          <target state="translated">(선택 사항) 캐시를 완전히 비 웁니다.</target>
        </trans-unit>
        <trans-unit id="5835997c11a74637b108798c0feb5cabefa73433" translate="yes" xml:space="preserve">
          <source>(P) &lt;code&gt;PerlIO_getname&lt;/code&gt; , a perl internal I/O function specific to VMS, was somehow called on another platform. This should not happen.</source>
          <target state="translated">(P) VMS에 특정한 perl 내부 I / O 함수 인 &lt;code&gt;PerlIO_getname&lt;/code&gt; 은 다른 플랫폼에서 호출되었습니다. 이런 일은 일어나지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="dc58db7072e1f7fba8806dfea270837b51e8ed42" translate="yes" xml:space="preserve">
          <source>(P) A &quot;can't happen&quot; error, because safemalloc() should have caught it earlier.</source>
          <target state="translated">(P) safemalloc ()이 일찍 발견했기 때문에 &quot;발생할 수 없음&quot;오류.</target>
        </trans-unit>
        <trans-unit id="58985825d348752b61027dc6b946271aad1faa56" translate="yes" xml:space="preserve">
          <source>(P) A child pseudo-process in the ithreads implementation on Windows was not scheduled within the time period allowed and therefore was not able to initialize properly.</source>
          <target state="translated">(P) Windows에서 ithreads 구현의 하위 의사 프로세스가 허용 된 시간 내에 스케줄되지 않아서 올바르게 초기화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="63218668b70e4bf0756e321b27792ab7906efb49" translate="yes" xml:space="preserve">
          <source>(P) A dynamic loading library &lt;code&gt;.so&lt;/code&gt; or &lt;code&gt;.dll&lt;/code&gt; was being loaded into the process that was built against a different build of perl than the said library was compiled against. Reinstalling the XS module will likely fix this error.</source>
          <target state="translated">(P) 동적 로딩 라이브러리 &lt;code&gt;.so&lt;/code&gt; 또는 &lt;code&gt;.dll&lt;/code&gt; 이 해당 라이브러리가 컴파일 된 것과 다른 perl 빌드에 대해 빌드 된 프로세스에로드되었습니다. XS 모듈을 다시 설치하면이 오류가 해결 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cb0fd8cfa9d90cb793e9bd9036d1253df9aaebc" translate="yes" xml:space="preserve">
          <source>(P) A writable lexical variable became read-only somehow within the scope.</source>
          <target state="translated">(P) 쓰기 가능한 어휘 변수가 어떻게 든 범위 내에서 읽기 전용이되었습니다.</target>
        </trans-unit>
        <trans-unit id="ac6b31d3aa966d7f9fe1cceebfa3f03e43340da8" translate="yes" xml:space="preserve">
          <source>(P) A zero scratch pad offset was detected internally. An attempt was made to free a target that had not been allocated to begin with.</source>
          <target state="translated">(P) 제로 스크래치 패드 오프셋이 내부적으로 감지되었습니다. 시작하도록 할당되지 않은 대상을 해제하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="f7037268510ac900c0157c7edb67d795193fe594" translate="yes" xml:space="preserve">
          <source>(P) A zero scratch pad offset was detected internally. Most likely an operator needed a target but that target had not been allocated for whatever reason.</source>
          <target state="translated">(P) 제로 스크래치 패드 오프셋이 내부적으로 감지되었습니다. 운영자가 대상을 필요로했을 가능성이 높지만 어떤 이유로 든 해당 대상이 할당되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="f41b76a04d15393859eb2e8a61af81282a466dfe" translate="yes" xml:space="preserve">
          <source>(P) An attempt was made to realloc NULL.</source>
          <target state="translated">(P) NULL을 재 할당하려고 시도했다.</target>
        </trans-unit>
        <trans-unit id="805d3fe43254643a25a16315e4e8615d2a57e279" translate="yes" xml:space="preserve">
          <source>(P) An error peculiar to OS/2. Most probably you're using an obsolete version of Perl, and this should not happen anyway.</source>
          <target state="translated">(P) OS / 2 고유의 오류. 아마도 오래된 버전의 Perl을 사용하고있을 것입니다.</target>
        </trans-unit>
        <trans-unit id="75a4e6040f566b1917c1dda02aa011853538432b" translate="yes" xml:space="preserve">
          <source>(P) An error peculiar to VMS. After creating a mailbox to act as a pipe, Perl can't retrieve its name for later use.</source>
          <target state="translated">(P) VMS 고유의 오류. 파이프 역할을하는 사서함을 만든 후 Perl은 나중에 사용할 수 있도록 이름을 검색 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="882287f5af6799879ef1baa93da6c76fdaa28abc" translate="yes" xml:space="preserve">
          <source>(P) An error peculiar to VMS. Perl asked $GETSYI how big you want your mailbox buffers to be, and didn't get an answer.</source>
          <target state="translated">(P) VMS 고유의 오류. 펄은 $ GETSYI에게 당신이 얼마나 큰 사서함 버퍼를 원하는지 물었고 대답을 얻지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="c1300e185b7adf72debf6b8d06e28e06846c42df" translate="yes" xml:space="preserve">
          <source>(P) An error peculiar to VMS. Perl does its own command line redirection, and couldn't open the pipe into which to send data destined for stdout.</source>
          <target state="translated">(P) VMS 고유의 오류. Perl은 자체 명령 행 경로 재 지정을 수행하며 stdout으로 보낼 데이터를 보낼 파이프를 열 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="812c62b1b2b29683f5d1ef78d1a198f61158a009" translate="yes" xml:space="preserve">
          <source>(P) An error peculiar to VMS. Perl thought stdin was a pipe, and tried to reopen it to accept binary data. Alas, it failed.</source>
          <target state="translated">(P) VMS 고유의 오류. Perl은 stdin이 파이프라고 생각하고 이진 데이터를 허용하기 위해 다시 열어 보았습니다. 아아, 그것은 실패했다.</target>
        </trans-unit>
        <trans-unit id="64bfa01bd1fda8165c6383ea96e2f2ebcaaf721a" translate="yes" xml:space="preserve">
          <source>(P) An error peculiar to VMS. Perl was reading values for %ENV before iterating over it, and someone else stuck a message in the stream of data Perl expected. Someone's very confused, or perhaps trying to subvert Perl's population of %ENV for nefarious purposes.</source>
          <target state="translated">(P) VMS 고유의 오류. Perl은 % ENV의 값을 반복하기 전에 값을 읽었으며 다른 사람이 Perl이 예상 한 데이터 스트림에 메시지를 붙였습니다. 누군가 매우 혼란스러워하거나 사악한 목적으로 Perl의 % ENV 인구를 전복 시키려고합니다.</target>
        </trans-unit>
        <trans-unit id="53209a59e0d1b2806deec370767fa6649c89edf1" translate="yes" xml:space="preserve">
          <source>(P) An error peculiar to VMS. Something untoward happened in a VMS system service or RTL routine; Perl's exit status should provide more details. The filename in &quot;at %s&quot; and the line number in &quot;line %d&quot; tell you which section of the Perl source code is distressed.</source>
          <target state="translated">(P) VMS 고유의 오류. VMS 시스템 서비스 또는 RTL 루틴에서 문제가 발생했습니다. Perl의 종료 상태는 자세한 내용을 제공해야합니다. &quot;at % s&quot;의 파일 이름과 &quot;line % d&quot;의 줄 번호는 Perl 소스 코드의 어떤 부분이 고민되는지 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="35d8e83a7783d51e07bff6cffe79f0723868552b" translate="yes" xml:space="preserve">
          <source>(P) An error peculiar to VMS. The internal routine my_pclose() tried to close a pipe which hadn't been opened. This should have been caught earlier as an attempt to close an unopened filehandle.</source>
          <target state="translated">(P) VMS 고유의 오류. 내부 루틴 my_pclose ()가 열리지 않은 파이프를 닫으려고했습니다. 열리지 않은 파일 핸들을 닫으려고 시도했을 때이 문제가 일찍 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="48e66393ab9e9a726bdcc1954cc3fedc04585017" translate="yes" xml:space="preserve">
          <source>(P) An error peculiar to VMS. The process is suffering from exhausted quotas or other plumbing problems.</source>
          <target state="translated">(P) VMS 고유의 오류. 이 프로세스는 할당량 소진 또는 기타 배관 문제로 어려움을 겪고 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4cf27c732ea51afc9bf41a95d1d1db092fbf143" translate="yes" xml:space="preserve">
          <source>(P) An internal error.</source>
          <target state="translated">(P) 내부 오류.</target>
        </trans-unit>
        <trans-unit id="400b3add9082d6a121c9c985001f90d62602e3f8" translate="yes" xml:space="preserve">
          <source>(P) An internal request asked to add a dirhandle entry to something that wasn't a symbol table entry.</source>
          <target state="translated">(P) 내부 요청이 기호 테이블 항목이 아닌 것에 dirhandle 항목을 추가하도록 요청했습니다.</target>
        </trans-unit>
        <trans-unit id="deda62fc99ecdc478d72f62140a8bcf1ceb9272e" translate="yes" xml:space="preserve">
          <source>(P) An internal request asked to add a filehandle entry to something that wasn't a symbol table entry.</source>
          <target state="translated">(P) 내부 요청이 심볼 테이블 항목이 아닌 파일 핸들 항목을 추가하도록 요청했습니다.</target>
        </trans-unit>
        <trans-unit id="8d525d59c29627fcb4cf5fb45ef2ce2262a965b5" translate="yes" xml:space="preserve">
          <source>(P) An internal request asked to add a hash entry to something that wasn't a symbol table entry.</source>
          <target state="translated">(P) 내부 요청이 심볼 테이블 항목이 아닌 것에 해시 항목을 추가하도록 요청했습니다.</target>
        </trans-unit>
        <trans-unit id="bd04872849093dc10c444b9351a52e79cccce00f" translate="yes" xml:space="preserve">
          <source>(P) An internal request asked to add a scalar entry to something that wasn't a symbol table entry.</source>
          <target state="translated">(P) 내부 요청이 기호 테이블 항목이 아닌 것에 스칼라 항목을 추가하도록 요청했습니다.</target>
        </trans-unit>
        <trans-unit id="24d7c84eff9fb4b808ce29551b770d00f60aee1d" translate="yes" xml:space="preserve">
          <source>(P) An internal request asked to add an array entry to something that wasn't a symbol table entry.</source>
          <target state="translated">(P) 내부 요청이 기호 테이블 항목이 아닌 것에 항목을 추가하도록 요청했습니다.</target>
        </trans-unit>
        <trans-unit id="f9de1ed0d252c6ffe68f2b4950da362eb5449670" translate="yes" xml:space="preserve">
          <source>(P) An invalid scratch pad offset was detected internally.</source>
          <target state="translated">(P) 잘못된 스크래치 패드 오프셋이 내부적으로 감지되었습니다.</target>
        </trans-unit>
        <trans-unit id="94844fe4c4b36fd08255764c95d3f23017373808" translate="yes" xml:space="preserve">
          <source>(P) Failed an internal consistency check trying to compile a grep.</source>
          <target state="translated">(P) grep 컴파일을 시도하는 내부 일관성 검사에 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="f74e25267a599f76899b17127eca9205d07ea94d" translate="yes" xml:space="preserve">
          <source>(P) Failed an internal consistency check trying to compile a split.</source>
          <target state="translated">(P) 스플릿 컴파일을 시도하는 내부 일관성 검사에 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="b8748d03b08df071f0c5d63147735eddb25341be" translate="yes" xml:space="preserve">
          <source>(P) Failed an internal consistency check while trying to reset a weak reference.</source>
          <target state="translated">(P) 약한 참조를 재설정하는 중에 내부 일관성 검사에 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="76567e3a92c59ec49c3b6ebddac41922c02d8aa4" translate="yes" xml:space="preserve">
          <source>(P) Failed an internal consistency check while trying to reset all weak references to an object.</source>
          <target state="translated">(P) 객체에 대한 모든 약한 참조를 재설정하는 중에 내부 일관성 검사에 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="ed1b58a13a98656d324ac0b4cf595de055626e6f" translate="yes" xml:space="preserve">
          <source>(P) For some reason you can't check the filesystem of the script for nosuid.</source>
          <target state="translated">(P) 어떤 이유로 스크립트의 파일 시스템에서 nosuid를 확인할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="846d00ab81ca381fc30d174ab49bf08ea7bb02b1" translate="yes" xml:space="preserve">
          <source>(P) For some reason you can't fstat() the script even though you have it open already. Bizarre.</source>
          <target state="translated">(P) 어떤 이유로 스크립트를 이미 열어 놓았더라도 fstat () 할 수 없습니다. 기괴한.</target>
        </trans-unit>
        <trans-unit id="ea00886ad348eaccaa4b809a63f6dfabfb44eb5e" translate="yes" xml:space="preserve">
          <source>(P) It is currently not permitted to load modules when creating a filehandle inside an %INC hook. This can happen with &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;
$fh, '&amp;lt;', \$scalar&lt;/code&gt; , which implicitly loads PerlIO::scalar. Try loading PerlIO::scalar explicitly first.</source>
          <target state="translated">(P) 현재 % INC 후크 안에 파일 핸들을 생성 할 때 모듈을로드 할 수 없습니다. 이것은 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $fh, '&amp;lt;', \$scalar&lt;/code&gt; $ fh, '&amp;lt;', \ $ scalar 를 &lt;a href=&quot;functions/open&quot;&gt;열어&lt;/a&gt; PerlIO :: scalar를 암시 적으로로드 하면 발생할 수 있습니다 . 먼저 PerlIO :: scalar를 명시 적으로로드하십시오.</target>
        </trans-unit>
        <trans-unit id="59c7b7c23f07a81243e56c544e381b40349dbee9" translate="yes" xml:space="preserve">
          <source>(P) One of the file test operators entered a code branch that calls an ACL related-function, but that function is not available on this platform. Earlier checks mean that it should not be possible to enter this branch on this platform.</source>
          <target state="translated">(P) 파일 테스트 운영자 중 하나가 ACL 관련 기능을 호출하는 코드 분기를 입력했지만이 플랫폼에서 해당 기능을 사용할 수 없습니다. 조기 점검은이 플랫폼에서이 지점에 진입 할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="bea433ac846e1206d3fed924939699290f5369d3" translate="yes" xml:space="preserve">
          <source>(P) One of the internal hash routines was passed a null HV pointer.</source>
          <target state="translated">(P) 내부 해시 루틴 중 하나에 널 HV 포인터가 전달되었습니다.</target>
        </trans-unit>
        <trans-unit id="997d69797f4a80218beb1781ad0cef542ace556c" translate="yes" xml:space="preserve">
          <source>(P) Overloading resolution over @ISA tree may be broken by importation stubs. Stubs should never be implicitly created, but explicit calls to &lt;code&gt;can&lt;/code&gt; may break this.</source>
          <target state="translated">(P) 가져 오기 스텁으로 인해 @ISA 트리의 오버로드 해상도가 손상 될 수 있습니다. 스텁은 암시 적으로 작성되지 않아야하지만 명시적인 호출로 인해 이로 인해 문제 &lt;code&gt;can&lt;/code&gt; 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a672aa452663f622bcb9efc632d9f5ddcc3bd368" translate="yes" xml:space="preserve">
          <source>(P) Perl detected an attempt to copy a value to an internal type that cannot be directly assigned to.</source>
          <target state="translated">(P) Perl은 값을 직접 할당 할 수없는 내부 유형으로 복사하려는 시도를 감지했습니다.</target>
        </trans-unit>
        <trans-unit id="cd57912a82e894f3b76de7debf79b5b5081d6696" translate="yes" xml:space="preserve">
          <source>(P) Perl detected an attempt to copy an internal value that is not copiable.</source>
          <target state="translated">(P) Perl은 복사 할 수없는 내부 값을 복사하려는 시도를 감지했습니다.</target>
        </trans-unit>
        <trans-unit id="6a935e8b954c1a4ac41a3601d70d606987e51088" translate="yes" xml:space="preserve">
          <source>(P) Perl got confused as to whether a hash was a plain hash or a symbol table hash when trying to update @ISA caches.</source>
          <target state="translated">(P) Perl은 @ISA 캐시를 업데이트하려고 할 때 해시가 일반 해시인지 또는 심볼 테이블 해시인지에 대해 혼란스러워했습니다.</target>
        </trans-unit>
        <trans-unit id="69c537dcfd79419e3fa221999b0a72efd880156d" translate="yes" xml:space="preserve">
          <source>(P) Perl tried to force the upgrade of an SV to a type which was actually inferior to its current type.</source>
          <target state="translated">(P) Perl은 SV를 실제로 현재 유형보다 열등한 유형으로 업그레이드하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="e7c0cbe400246e10096bcf3fddb3870b7b8aa60f" translate="yes" xml:space="preserve">
          <source>(P) Perl was about to print an error message in &lt;code&gt;$@&lt;/code&gt; , but the &lt;code&gt;$@&lt;/code&gt; variable did not exist, even after an attempt to create it.</source>
          <target state="translated">(P) Perl이 &lt;code&gt;$@&lt;/code&gt; 오류 메시지를 인쇄하려고 했지만 &lt;code&gt;$@&lt;/code&gt; 변수를 작성하려고 시도한 후에도 $ @ 변수가 존재하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="09902ab0b7d22f2db928a38bcd7ddef2eb0376e9" translate="yes" xml:space="preserve">
          <source>(P) Perl's I/O implementation failed an internal consistency check. If you see this message, something is very wrong.</source>
          <target state="translated">(P) Perl의 I / O 구현이 내부 일관성 검사에 실패했습니다. 이 메시지가 표시되면 매우 잘못된 것입니다.</target>
        </trans-unit>
        <trans-unit id="e43882fe07c8f3adca275643c774aed874855180" translate="yes" xml:space="preserve">
          <source>(P) Some internal routine requested a goto (or something like it), and didn't supply the destination.</source>
          <target state="translated">(P) 어떤 내부 루틴은 goto (또는 이와 유사한 것)를 요청했고 목적지를 제공하지 않았다.</target>
        </trans-unit>
        <trans-unit id="f907e28fd9838bc3730b27bd659a35d1581d6e70" translate="yes" xml:space="preserve">
          <source>(P) Something requested a negative number of bytes of malloc.</source>
          <target state="translated">(P) 어떤 것이 음수의 malloc을 요구했다.</target>
        </trans-unit>
        <trans-unit id="8adc4f23f70bb97c8ac3d526ec641b16fd5b36e1" translate="yes" xml:space="preserve">
          <source>(P) Something requested a negative number of bytes of realloc.</source>
          <target state="translated">(P) 무언가 바이트 단위의 realloc을 요청했다.</target>
        </trans-unit>
        <trans-unit id="14449cff4b0537948fd6b4dcfdfdf4f30bae1ecd" translate="yes" xml:space="preserve">
          <source>(P) Something terrible went wrong in setting up for the split.</source>
          <target state="translated">(P) 스플릿을 설정하는 데 끔찍한 일이 있었다.</target>
        </trans-unit>
        <trans-unit id="f4adbeb9044ce4d24ae898fd2352b57b5aad6c7f" translate="yes" xml:space="preserve">
          <source>(P) Something tried to allocate either more memory than possible or a negative amount.</source>
          <target state="translated">(P) 어떤 것이 가능한 것보다 더 많은 메모리를 할당하거나 음의 양을 할당하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="c247a6fde86c0e187f27f20d8c6f2008bfaf717c" translate="yes" xml:space="preserve">
          <source>(P) Something tried to call utf16_to_utf8 with an odd (as opposed to even) byte length.</source>
          <target state="translated">(P) 뭔가 홀수 (짝수와 반대) 바이트 길이로 utf16_to_utf8을 호출하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="42ef3d2046a7280391a4513cfd91699254de4d54" translate="yes" xml:space="preserve">
          <source>(P) Something tried to call utf16_to_utf8_reversed with an odd (as opposed to even) byte length.</source>
          <target state="translated">(P) 무언가가 홀수 (짝수와 달리) 바이트 길이로 utf16_to_utf8_reversed를 호출하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="bdb5ab246092cb7bbb51ab8f1c6cf89f85acb65b" translate="yes" xml:space="preserve">
          <source>(P) Something went badly awry in the regular expression parser. The &amp;lt;-- HERE shows whereabouts in the regular expression the problem was discovered.</source>
          <target state="translated">(P) 정규 표현식 파서에서 무언가 잘못되었다. &amp;lt;-HERE는 정규식에서 문제가 발견 된 위치를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ea8f70d893419122544ad3e3db4bdeca611aeabc" translate="yes" xml:space="preserve">
          <source>(P) Something went badly wrong in the regular expression parser. The &amp;lt;-- HERE shows whereabouts in the regular expression the problem was discovered.</source>
          <target state="translated">(P) 정규 표현식 파서에서 무언가 잘못되었다. &amp;lt;-HERE는 정규식에서 문제가 발견 된 위치를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="83e2a506e0dd76b2f90526cfa59329c0a5ec4759" translate="yes" xml:space="preserve">
          <source>(P) Something went wrong internally when Perl was trying to look up Unicode characters.</source>
          <target state="translated">(P) Perl이 유니 코드 문자를 찾으려고 할 때 내부적으로 문제가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="1474b49d9c211359ca3383cf7b6b4bb61bdac491" translate="yes" xml:space="preserve">
          <source>(P) The attempt to translate a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Module n.n LIST&lt;/code&gt; statement into its equivalent &lt;code&gt;BEGIN&lt;/code&gt; block found an internal inconsistency with the version number.</source>
          <target state="translated">(P) &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Module n.n LIST&lt;/code&gt; 문을 동등한 &lt;code&gt;BEGIN&lt;/code&gt; 블록 으로 변환하려는 시도 에서 버전 번호와 내부 불일치가 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="dc94ac47a124ec9565255f20ffb2b981be020dd0" translate="yes" xml:space="preserve">
          <source>(P) The compiler attempted to do a goto, or something weird like that.</source>
          <target state="translated">(P) 컴파일러가 goto 또는 이상한 것을 시도했습니다.</target>
        </trans-unit>
        <trans-unit id="3140b066a825427b55fbacec7927b11990bb1c15" translate="yes" xml:space="preserve">
          <source>(P) The compiler got confused about which scratch pad it was allocating and freeing temporaries and lexicals from.</source>
          <target state="translated">(P) 컴파일러는 어느 스크래치 패드가 임시 및 어휘를 할당하고 해제했는지에 대해 혼란스러워했다.</target>
        </trans-unit>
        <trans-unit id="7d8e4b6f9d2ec17cd7598513858301157c54c1d6" translate="yes" xml:space="preserve">
          <source>(P) The compiler is screwed up and attempted to use an op that isn't permitted at run time.</source>
          <target state="translated">(P) 컴파일러가 망가져 런타임에 허용되지 않는 op를 사용하려고 시도했습니다.</target>
        </trans-unit>
        <trans-unit id="2518e797a41a53cc3a16b842f80c3d5b229f2e05" translate="yes" xml:space="preserve">
          <source>(P) The foreach iterator got called in a non-loop context frame.</source>
          <target state="translated">(P) foreach 반복자가 비 루프 컨텍스트 프레임에서 호출되었습니다.</target>
        </trans-unit>
        <trans-unit id="3498aa56de14a6994bc9a9e1d9c5ef94fa5d2e1c" translate="yes" xml:space="preserve">
          <source>(P) The internal do_trans routines were called with invalid operational data.</source>
          <target state="translated">(P) 내부 do_trans 루틴이 유효하지 않은 조작 데이터로 호출되었습니다.</target>
        </trans-unit>
        <trans-unit id="c96999bf2ea96ec470ccdf365e03b2b91a727777" translate="yes" xml:space="preserve">
          <source>(P) The internal handling of magical variables has been cursed.</source>
          <target state="translated">(P) 마법 변수의 내부 처리가 저주되었다.</target>
        </trans-unit>
        <trans-unit id="2d8dbaa150d0b56f4dea48ed2ced98b5683b26c4" translate="yes" xml:space="preserve">
          <source>(P) The internal pattern matching routines are out of their gourd.</source>
          <target state="translated">(P) 내부 패턴 매칭 루틴이 조롱박에서 벗어났다.</target>
        </trans-unit>
        <trans-unit id="69167b38f6d187d53564596eb06361602bf85982" translate="yes" xml:space="preserve">
          <source>(P) The internal pattern matching routines blew it big time.</source>
          <target state="translated">(P) 내부 패턴 매칭 루틴이 시간이 많이 걸렸다.</target>
        </trans-unit>
        <trans-unit id="d7b029c21e38165a6d8e4ad7d9c98510fe286a1f" translate="yes" xml:space="preserve">
          <source>(P) The internal pp_match() routine was called with invalid operational data.</source>
          <target state="translated">(P) 내부 pp_match () 루틴이 유효하지 않은 작동 데이터와 함께 호출되었습니다.</target>
        </trans-unit>
        <trans-unit id="30add7c219a2f4a5d23c5c04fcd6100dac0c68f5" translate="yes" xml:space="preserve">
          <source>(P) The internal pp_subst() routine was called with invalid operational data.</source>
          <target state="translated">(P) 내부 pp_subst () 루틴이 유효하지 않은 작동 데이터와 함께 호출되었습니다.</target>
        </trans-unit>
        <trans-unit id="b882a632737f76c740564805feff4a10df851aee" translate="yes" xml:space="preserve">
          <source>(P) The internal routine that does assignment to a substr() was handed a NULL.</source>
          <target state="translated">(P) substr ()에 할당을 수행하는 내부 루틴은 NULL을 전달 받았다.</target>
        </trans-unit>
        <trans-unit id="e4c3eb89b616edfda4b2360cf2603781020cca69" translate="yes" xml:space="preserve">
          <source>(P) The internal routine used to clear a typeglob's entries tried repeatedly, but each time something re-created entries in the glob. Most likely the glob contains an object with a reference back to the glob and a destructor that adds a new object to the glob.</source>
          <target state="translated">(P) typeglob의 항목을 지우는 데 사용 된 내부 루틴은 반복적으로 시도했지만, 항상 glob에 항목을 다시 작성했습니다. 아마도 glob에는 glob에 대한 참조가있는 객체와 glob에 새로운 객체를 추가하는 소멸자가 포함되어있을 가능성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="92453c370c98695c820b9c6b5a88b90716c045ab" translate="yes" xml:space="preserve">
          <source>(P) The internal sv_replace() function was handed a new SV with a reference count other than 1.</source>
          <target state="translated">(P) 내부 sv_replace () 함수는 1 이외의 참조 카운트를 가진 새로운 SV를 전달했습니다.</target>
        </trans-unit>
        <trans-unit id="f1d10ef331590e88d3dd539acaa55182032de5ac" translate="yes" xml:space="preserve">
          <source>(P) The internal sv_upgrade routine adds &quot;members&quot; to an SV, making it into a more specialized kind of SV. The top several SV types are so specialized, however, that they cannot be interconverted. This message indicates that such a conversion was attempted.</source>
          <target state="translated">(P) 내부 sv_upgrade 루틴은 &quot;구성원&quot;을 SV에 추가하여보다 특수한 종류의 SV로 만듭니다. 그러나 상위 몇 가지 SV 유형은 매우 특수화되어있어 상호 변환 할 수 없습니다. 이 메시지는 그러한 변환이 시도되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fe4ad75b272d3e52b9dbd964a661c89696cf6a16" translate="yes" xml:space="preserve">
          <source>(P) The interpreter's sanity check of the C function strxfrm() failed. In your current locale the returned transformation of the string &quot;ab&quot; is shorter than that of the string &quot;a&quot;, which makes no sense.</source>
          <target state="translated">(P) C 함수 strxfrm ()의 인터프리터의 온 전성 점검에 실패했습니다. 현재 로케일에서 문자열 &quot;ab&quot;의 리턴 된 변환은 문자열 &quot;a&quot;의 변환보다 짧으므로 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="caa10dae4e81f1c4e0e1e7e1b36af901e8d7831d" translate="yes" xml:space="preserve">
          <source>(P) The lexer got into a bad state at a case modifier.</source>
          <target state="translated">(P) 렉서가 케이스 수정 자에서 나쁜 상태에 빠졌다.</target>
        </trans-unit>
        <trans-unit id="848a38b2b7a29c3f612333ad0dcbfb9242e0ae8a" translate="yes" xml:space="preserve">
          <source>(P) The lexer got into a bad state parsing a string with brackets.</source>
          <target state="translated">(P) 렉서가 문자열을 괄호로 파싱하는 나쁜 상태에 빠졌다.</target>
        </trans-unit>
        <trans-unit id="d3f93ef0e44473b374c4208ea1b920c7d153d050" translate="yes" xml:space="preserve">
          <source>(P) The lexer got into a bad state while processing a case modifier.</source>
          <target state="translated">(P) 케이스 수정자를 처리하는 동안 어휘 분석기가 잘못된 상태가되었습니다.</target>
        </trans-unit>
        <trans-unit id="da7064a484d4121a5b00bdc6875279cbbfef2172" translate="yes" xml:space="preserve">
          <source>(P) The library function frexp() failed, making printf(&quot;%f&quot;) impossible.</source>
          <target state="translated">(P) 라이브러리 함수 frexp ()가 실패하여 printf ( &quot;% f&quot;)가 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="2047dd7abae12bd27c2ecacda93d00652e347457" translate="yes" xml:space="preserve">
          <source>(P) The malloc package that comes with Perl had an internal failure.</source>
          <target state="translated">(P) Perl과 함께 제공되는 malloc 패키지에 내부 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="a82ab59c9c5dcdf998d55ef85b5159b7ebbb380e" translate="yes" xml:space="preserve">
          <source>(P) The parser got confused when trying to parse a &lt;code&gt;foreach&lt;/code&gt; loop.</source>
          <target state="translated">(P) &lt;code&gt;foreach&lt;/code&gt; 루프 를 파싱하려고 할 때 파서가 혼란 스러웠다 .</target>
        </trans-unit>
        <trans-unit id="877ff07afe0fa8916b2474462d22fd186ffa1d8d" translate="yes" xml:space="preserve">
          <source>(P) The regular expression engine got confused by what the regular expression compiler gave it.</source>
          <target state="translated">(P) 정규 표현식 엔진이 정규 표현식 컴파일러가 준 것에 혼란스러워했다.</target>
        </trans-unit>
        <trans-unit id="b05f30c29b5504a8630326b5a95c517cd6fcc9f4" translate="yes" xml:space="preserve">
          <source>(P) The regular expression engine got passed a regexp program without a valid magic number.</source>
          <target state="translated">(P) 정규식 엔진에 유효한 매직 번호가없는 정규식 프로그램이 전달되었습니다.</target>
        </trans-unit>
        <trans-unit id="ac05e84171c5a8bb39254f819a30950f141e3ef7" translate="yes" xml:space="preserve">
          <source>(P) The regular expression parser is confused.</source>
          <target state="translated">(P) 정규식 파서는 혼란 스럽다.</target>
        </trans-unit>
        <trans-unit id="119df00ff55f6253a00a72f5c82ad4037497448f" translate="yes" xml:space="preserve">
          <source>(P) The savestack probably got out of sync. At least, there was an invalid enum on the top of it.</source>
          <target state="translated">(P) 저장 스택이 동기화되지 않았을 수 있습니다. 적어도 그 위에 잘못된 열거 형이있었습니다.</target>
        </trans-unit>
        <trans-unit id="94817271db547b761a2729d99f3078243552aaf1" translate="yes" xml:space="preserve">
          <source>(P) The savestack was requested to restore more localized values than there are in the savestack.</source>
          <target state="translated">(P) 저장 스택은 저장 스택에있는 것보다 더 많은 지역화 된 값을 복원하도록 요청되었습니다.</target>
        </trans-unit>
        <trans-unit id="350c93f0480aff09e9937e383bb8379378cdb829" translate="yes" xml:space="preserve">
          <source>(P) The split was looping infinitely. (Obviously, a split shouldn't iterate more times than there are characters of input, which is what happened.) See &lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;.</source>
          <target state="translated">(P) 스플릿이 무한 반복되었다. (분할은 입력 문자가있는 것보다 더 많은 시간을 반복해서는 안됩니다. 이런 일이 발생했습니다.) &lt;a href=&quot;functions/split&quot;&gt;split을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="01af9b13bd2be8aa72ae4f732d759961b18d1add" translate="yes" xml:space="preserve">
          <source>(P) The substitution was looping infinitely. (Obviously, a substitution shouldn't iterate more times than there are characters of input, which is what happened.) See the discussion of substitution in &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">(P) 치환이 무한 반복되었다. (대체로, 대체는 입력 된 문자보다 많은 시간을 반복하지 않아야합니다. 이는 발생했습니다.) &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;perlop의 Regexp Quote-Like Operators에서&lt;/a&gt; 대체에 대한 토론을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="096d868e26e229c81806a37b4d321863d23fb558" translate="yes" xml:space="preserve">
          <source>(P) The sv_chop() routine was passed a position that is not within the scalar's string buffer.</source>
          <target state="translated">(P) sv_chop () 루틴에 스칼라의 문자열 버퍼 내에없는 위치가 전달되었습니다.</target>
        </trans-unit>
        <trans-unit id="f0c3dd422524f0a60eae34855bb950f6397c39c4" translate="yes" xml:space="preserve">
          <source>(P) The sv_insert() routine was told to remove more string than there was string.</source>
          <target state="translated">(P) sv_insert () 루틴은 문자열보다 많은 문자열을 제거하도록 지시 받았다.</target>
        </trans-unit>
        <trans-unit id="38d33b303598c9e06325c970fde5f0a3b07ab112" translate="yes" xml:space="preserve">
          <source>(P) This is counted as an internal error, because every machine should supply dbm nowadays, because Perl comes with SDBM. See &lt;a href=&quot;sdbm_file&quot;&gt;SDBM_File&lt;/a&gt;.</source>
          <target state="translated">(P) Perl에는 SDBM이 포함되어 있기 때문에 오늘날 모든 시스템에서 dbm을 제공해야하기 때문에 내부 오류로 계산됩니다. &lt;a href=&quot;sdbm_file&quot;&gt;SDBM_File을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="295b2a9153ab005fc6bfe5d09638e7e6f4db38db" translate="yes" xml:space="preserve">
          <source>(P) This is either an error in Perl, or, if you're using one, your &lt;a href=&quot;perlreapi&quot;&gt;custom regular expression engine&lt;/a&gt;. If not the latter, report the problem through the &lt;a href=&quot;perlbug&quot;&gt;perlbug&lt;/a&gt; utility.</source>
          <target state="translated">(P) 이는 Perl의 오류이거나 &lt;a href=&quot;perlreapi&quot;&gt;사용자 정의 정규식 엔진을&lt;/a&gt; 사용하는 경우 오류입니다 . 후자가 &lt;a href=&quot;perlbug&quot;&gt;아니라면 perlbug&lt;/a&gt; 유틸리티를 통해 문제점을보고하십시오 .</target>
        </trans-unit>
        <trans-unit id="d3076b2ea244338df16e2de88ad9eb91a8ba0351" translate="yes" xml:space="preserve">
          <source>(P) This should have been caught by safemalloc() instead.</source>
          <target state="translated">(P) safemalloc ()이 대신 잡았을 것입니다.</target>
        </trans-unit>
        <trans-unit id="e4b02809f13a7e683a603a83b856454cc2b6fb45" translate="yes" xml:space="preserve">
          <source>(P) We popped the context stack to a block context, and then discovered it wasn't a block context.</source>
          <target state="translated">(P) 컨텍스트 스택을 블록 컨텍스트로 팝한 다음 블록 컨텍스트가 아니라는 것을 발견했습니다.</target>
        </trans-unit>
        <trans-unit id="67d8a45c194a97910d1c643886c073df365d9011" translate="yes" xml:space="preserve">
          <source>(P) We popped the context stack to a context with the specified label, and then discovered it wasn't a context we know how to do a goto in.</source>
          <target state="translated">(P) 컨텍스트 레이블을 지정된 레이블이있는 컨텍스트로 팝한 다음, 우리가 goto를 수행하는 방법을 알고있는 컨텍스트가 아님을 발견했습니다.</target>
        </trans-unit>
        <trans-unit id="e9ebc7c838cd5a3875cdad3a7c6c9f072bce59d6" translate="yes" xml:space="preserve">
          <source>(P) We popped the context stack to a subroutine or eval context, and then discovered it wasn't a subroutine or eval context.</source>
          <target state="translated">(P) 컨텍스트 스택을 서브 루틴 또는 평가 컨텍스트로 팝한 다음 서브 루틴 또는 평가 컨텍스트가 아닌 것을 발견했습니다.</target>
        </trans-unit>
        <trans-unit id="964d90b9224184fd0adab551116db2c863a30f22" translate="yes" xml:space="preserve">
          <source>(P) We popped the context stack to an eval context, and then discovered it wasn't an eval context.</source>
          <target state="translated">(P) 컨텍스트 스택을 평가 컨텍스트로 팝한 다음 평가 컨텍스트가 아니라는 것을 발견했다.</target>
        </trans-unit>
        <trans-unit id="127eed52ad96eb30e23e356e571f87ff81bd7d28" translate="yes" xml:space="preserve">
          <source>(P) When compiling a subroutine call in lvalue context, Perl failed an internal consistency check. It encountered a malformed op tree.</source>
          <target state="translated">(P) lvalue 컨텍스트에서 서브 루틴 호출을 컴파일 할 때 Perl은 내부 일관성 검사에 실패했습니다. 조작 된 op 트리가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="d7e51a2aafbbc975709738292192eb554947b44b" translate="yes" xml:space="preserve">
          <source>(P) When starting a new thread or returning values from a thread, Perl encountered an invalid data type.</source>
          <target state="translated">(P) 새 스레드를 시작하거나 스레드에서 값을 반환 할 때 Perl이 유효하지 않은 데이터 유형을 발견했습니다.</target>
        </trans-unit>
        <trans-unit id="1e351cc02c4c1cabcba7002000dd30dd6a44007b" translate="yes" xml:space="preserve">
          <source>(P) While attempting folding constants an exception other than an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; failure was caught.</source>
          <target state="translated">(P) 접는 상수를 시도하는 동안 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 실패 이외의 예외가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="ae4a4729f26dd616cd92c61b327e9f0c4da6fef7" translate="yes" xml:space="preserve">
          <source>(P) While compiling a pattern that has embedded (?{}) or (??{}) code blocks, perl couldn't locate the code block that should have already been seen and compiled by perl before control passed to the regex compiler.</source>
          <target state="translated">(P) (? {}) 또는 (?? {}) 코드 블록이 포함 된 패턴을 컴파일하는 동안 perl이 제어를 정규식 컴파일러에 전달하기 전에 perl이 이미 보거나 컴파일 한 코드 블록을 찾을 수 없습니다. .</target>
        </trans-unit>
        <trans-unit id="57c898ec4afec8491cb4ea78bb151b1da05f1a80" translate="yes" xml:space="preserve">
          <source>(P) You somehow managed to call &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; on an array that does not keep a reference count on its arguments and cannot be made to do so. Such arrays are not even supposed to be accessible to Perl code, but are only used internally.</source>
          <target state="translated">(P) 어떻게 든 인수에 참조 카운트를 유지하지 않고 배열로 만들 수없는 배열에서 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 를 호출 할 수있었습니다. 이러한 배열은 Perl 코드에 액세스 할 수있는 것이 아니라 내부적으로 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3a707edc44f9eebb1920dd1345721e9bcbf0761d" translate="yes" xml:space="preserve">
          <source>(P) You tried to make a hash value spring into existence, and it couldn't be created for some peculiar reason.</source>
          <target state="translated">(P) 해시 값 스프링을 존재 시키려고했는데, 특정한 이유로 만들 수 없었습니다.</target>
        </trans-unit>
        <trans-unit id="2acb223751eaea719135c277317cce538283806b" translate="yes" xml:space="preserve">
          <source>(P) scan_num() got called on something that wasn't a number.</source>
          <target state="translated">(P) scan_num ()은 숫자가 아닌 어떤 것에 대해 호출되었습니다.</target>
        </trans-unit>
        <trans-unit id="9804aeb16f638b18a424d4091ee834ca399aa241" translate="yes" xml:space="preserve">
          <source>(Perl 5.12)</source>
          <target state="translated">(펄 5.12)</target>
        </trans-unit>
        <trans-unit id="207ea73284ed8f6692ea30ffc773f62051322f05" translate="yes" xml:space="preserve">
          <source>(Perl 5.14)</source>
          <target state="translated">(펄 5.14)</target>
        </trans-unit>
        <trans-unit id="525943c59305200a5d02df199b866dc663ad2b68" translate="yes" xml:space="preserve">
          <source>(Perl 5.20)</source>
          <target state="translated">(펄 5.20)</target>
        </trans-unit>
        <trans-unit id="b39e3b1e2a984c1aea25ca987dbaa1937bebf239" translate="yes" xml:space="preserve">
          <source>(Plane, 2-dimensional) angles may be converted with the following functions.</source>
          <target state="translated">(평면, 2 차원) 각도는 다음 기능으로 변환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d01d5ab09b746324ccf3d6546898399023fc2a9" translate="yes" xml:space="preserve">
          <source>(Pod processors must tolerate a bare &quot;=item&quot; as if it were &quot;=item *&quot;.) Whether &quot;*&quot; is rendered as a literal asterisk, an &quot;o&quot;, or as some kind of real bullet character, is left up to the Pod formatter, and may depend on the level of nesting.</source>
          <target state="translated">포드 프로세서는 &quot;= item *&quot;인 것처럼 베어 &quot;= item&quot;을 허용해야합니다. &quot;*&quot;가 리터럴 별표, &quot;o&quot;또는 실제 글 머리 기호 문자로 렌더링되는지 여부는 남아 있습니다. 포드 포맷터에 중첩 수준에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d718cdb08cf62fcc4a70ad7c7b8d99e27980ff3" translate="yes" xml:space="preserve">
          <source>(Pod processors must tolerate lines like &quot;=item 1&quot; as if they were &quot;=item 1.&quot;, with the period.)</source>
          <target state="translated">포드 프로세서는 마침표가있는 &quot;= 항목 1&quot;인 것처럼 &quot;= 항목 1&quot;과 같은 행을 허용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f64fe4546149791676ad2a3dfb0e3eb4198e04bc" translate="yes" xml:space="preserve">
          <source>(Prior to Perl 5.8,</source>
          <target state="translated">(Perl 5.8 이전,</target>
        </trans-unit>
        <trans-unit id="b441598b9df1e55e3cfbf86ddea17386bca0fa94" translate="yes" xml:space="preserve">
          <source>(Pronounced &quot;Tong-a&quot;, not &quot;Tong-ga&quot;)</source>
          <target state="translated">( &quot;통가&quot;가 아니라 &quot;통가&quot;로 발음)</target>
        </trans-unit>
        <trans-unit id="c37d9452a04d295d6cd42412f70e9c83dd294e38" translate="yes" xml:space="preserve">
          <source>(Putting &lt;code&gt;&lt;a href=&quot;../functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; on the preceding line will work o.k.)</source>
          <target state="translated">( 앞 줄에 &lt;code&gt;&lt;a href=&quot;../functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 을 넣는 것은 정상적으로 작동합니다)</target>
        </trans-unit>
        <trans-unit id="80c5f2dc304d953ccc1260685c05b0ca2ed17b70" translate="yes" xml:space="preserve">
          <source>(Re-)open the handle</source>
          <target state="translated">핸들을 다시 엽니 다</target>
        </trans-unit>
        <trans-unit id="4bb1d9a70b90b86b82ffe9b5019a5301b70833d8" translate="yes" xml:space="preserve">
          <source>(S ambiguous) &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , and &lt;code&gt;*&lt;/code&gt; are both infix operators (modulus, bitwise and, and multiplication)</source>
          <target state="translated">(모호함) &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;*&lt;/code&gt; 는 모두 연산자를 포함합니다 (모듈, 비트 및 곱셈).</target>
        </trans-unit>
        <trans-unit id="ba72a5f44f5971c891c2fd430285b0abebdb16ba" translate="yes" xml:space="preserve">
          <source>(S ambiguous) You said something that may not be interpreted the way you thought. Normally it's pretty easy to disambiguate it by supplying a missing quote, operator, parenthesis pair or declaration.</source>
          <target state="translated">(모호한) 당신은 당신이 생각하는 방식으로 해석되지 않을 수있는 말을했습니다. 일반적으로 누락 된 따옴표, 연산자, 괄호 쌍 또는 선언을 제공하여 명확하게 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b14406b21054e52dd81c8f48e25c79121826f64b" translate="yes" xml:space="preserve">
          <source>(S ambiguous) You used a variable or subroutine call where the parser was expecting an operator. The parser has assumed you really meant to use an operator, but this is highly likely to be incorrect. For example, if you say &quot;*foo *foo&quot; it will be interpreted as if you said &quot;*foo * 'foo'&quot;.</source>
          <target state="translated">(모호한) 파서가 연산자를 기대하는 변수 또는 서브 루틴 호출을 사용했습니다. 파서는 사용자가 실제로 연산자를 사용한다고 가정했지만 이것은 잘못된 것 같습니다. 예를 들어, &quot;* foo * foo&quot;라고 말하면 &quot;* foo * 'foo'&quot;라고 말한 것처럼 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="20f28b8cd59b7fde1bbe53142bdfdd74e32311c2" translate="yes" xml:space="preserve">
          <source>(S ambiguous) You wrote a unary operator followed by something that looks like a binary operator that could also have been interpreted as a term or unary operator. For instance, if you know that the rand function has a default argument of 1.0, and you write</source>
          <target state="translated">(모호한) 단항 연산자 다음에 이진 연산자처럼 보이는 용어 나 단항 연산자로 해석 될 수있는 것을 작성했습니다. 예를 들어, rand 함수의 기본 인수가 1.0이라는 것을 알고</target>
        </trans-unit>
        <trans-unit id="4cb4be7b4dee0cb6392bc7950305e54795e02104" translate="yes" xml:space="preserve">
          <source>(S ambiguous) You wrote something like &lt;code&gt;-foo&lt;/code&gt; , which might be the string &lt;code&gt;&quot;-foo&quot;&lt;/code&gt; , or a call to the function &lt;code&gt;foo&lt;/code&gt; , negated. If you meant the string, just write &lt;code&gt;&quot;-foo&quot;&lt;/code&gt; . If you meant the function call, write &lt;code&gt;-foo()&lt;/code&gt; .</source>
          <target state="translated">(모호함) &lt;code&gt;-foo&lt;/code&gt; 와 같은 문자열을 작성했습니다. 문자열 &lt;code&gt;&quot;-foo&quot;&lt;/code&gt; 또는 &lt;code&gt;foo&lt;/code&gt; 함수에 대한 호출이 무효화 될 수 있습니다. 문자열을 의미하는 경우 &lt;code&gt;&quot;-foo&quot;&lt;/code&gt; 를 작성하십시오 . 함수 호출을 의미 한 경우 &lt;code&gt;-foo()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f02755cefde1af1c27dd0cb99ea9f99ea9f1e541" translate="yes" xml:space="preserve">
          <source>(S debugging) An array was assigned to when it was being freed. Freed values are not supposed to be visible to Perl code. This can also happen if XS code calls &lt;code&gt;av_clear&lt;/code&gt; from a custom magic callback on the array.</source>
          <target state="translated">(S 디버깅) 어레이가 해제 될 때 할당되었습니다. 해제 된 값은 Perl 코드에 표시되지 않아야합니다. XS 코드가 어레이의 사용자 지정 매직 콜백에서 &lt;code&gt;av_clear&lt;/code&gt; 를 호출하는 경우에도 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="551faf713b9b368cef18d71f1242467c1dc199ba" translate="yes" xml:space="preserve">
          <source>(S debugging) Mortalized values are supposed to be freed by the free_tmps() routine. This indicates that something else is freeing the SV before the free_tmps() routine gets a chance, which means that the free_tmps() routine will be freeing an unreferenced scalar when it does try to free it.</source>
          <target state="translated">(S 디버깅) 치명적인 값은 free_tmps () 루틴에 의해 해제됩니다. 이것은 free_tmps () 루틴이 기회를 얻기 전에 SV를 해제하는 무언가가 있음을 나타냅니다. 이는 free_tmps () 루틴이 해제하려고 할 때 참조되지 않은 스칼라를 해제 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f9419ec0daa83f63af71a20505dc62e0dc7c7619" translate="yes" xml:space="preserve">
          <source>(S debugging) Perl was called with invalid debugger flags. Call perl with the &lt;b&gt;-D&lt;/b&gt; option with no flags to see the list of acceptable values. See also &lt;a href=&quot;perlrun#-Dletters&quot;&gt;-Dletters in perlrun&lt;/a&gt;.</source>
          <target state="translated">(S 디버깅) Perl이 유효하지 않은 디버거 플래그와 함께 호출되었습니다. 허용 가능한 값 목록을 보려면 플래그없이 &lt;b&gt;-D&lt;/b&gt; 옵션을 사용하여 perl을 호출 하십시오. &lt;a href=&quot;perlrun#-Dletters&quot;&gt;perlrun의 -Dletters&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="333e2ce052a2296c1c591334a8fbd00eae6ac9ad" translate="yes" xml:space="preserve">
          <source>(S debugging) Some internal routine called run() with a null opcode pointer.</source>
          <target state="translated">(S 디버깅) 널 opcode 포인터와 함께 run ()이라는 내부 루틴.</target>
        </trans-unit>
        <trans-unit id="a8eb46adbf1bf91afdc5d9260b400b6ae61cbd86" translate="yes" xml:space="preserve">
          <source>(S debugging) This indicates that something went wrong and Perl got</source>
          <target state="translated">(S 디버깅) 문제가 발생하여 Perl에 문제가 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c7d1bdb0654de294ea9a1042b05058e1ada0ef37" translate="yes" xml:space="preserve">
          <source>(S debugging) You can't use the &lt;b&gt;-D&lt;/b&gt; option unless the code to produce the desired output is compiled into Perl, which entails some overhead, which is why it's currently left out of your copy.</source>
          <target state="translated">(S 디버깅) 원하는 출력을 생성하는 코드가 Perl로 컴파일되지 않으면 약간의 오버 헤드가 발생 하기 때문에 &lt;b&gt;-D&lt;/b&gt; 옵션을 사용할 수 없으므로 현재 사본에서 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="b75aa65efb65e349d889b5d4a7352e6e8d9b2578" translate="yes" xml:space="preserve">
          <source>(S experimental::autoderef) &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; with a scalar argument is experimental and may change or be removed in a future Perl version. If you want to take the risk of using this feature, simply disable this warning:</source>
          <target state="translated">스칼라 인수가있는 (S Experiment :: autoderef) &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 은 실험적이며 향후 Perl 버전에서 변경되거나 제거 될 수 있습니다. 이 기능을 사용할 위험을 감수하려면이 경고를 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="82c91ac6f02fabc52ebf392a3dbee3d04110bb23" translate="yes" xml:space="preserve">
          <source>(S experimental::autoderef) &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; with a scalar argument is experimental and may change or be removed in a future Perl version. If you want to take the risk of using this feature, simply disable this warning:</source>
          <target state="translated">스칼라 인수가있는 (S Experiment :: autoderef) &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 는 실험적이며 향후 Perl 버전에서 변경되거나 제거 될 수 있습니다. 이 기능을 사용할 위험을 감수하려면이 경고를 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="fce4a7b898b197069e9675f4e017f493007e0f79" translate="yes" xml:space="preserve">
          <source>(S experimental::autoderef) &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; with a scalar argument is experimental and may change or be removed in a future Perl version. If you want to take the risk of using this feature, simply disable this warning:</source>
          <target state="translated">스칼라 인수가있는 (S Experiment :: autoderef) &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; 은 실험적이며 향후 Perl 버전에서 변경되거나 제거 될 수 있습니다. 이 기능을 사용할 위험을 감수하려면이 경고를 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="89683a4ed700756617a913ec4ebb33d06e0fd4cf" translate="yes" xml:space="preserve">
          <source>(S experimental::autoderef) &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; with a scalar argument is experimental and may change or be removed in a future Perl version. If you want to take the risk of using this feature, simply disable this warning:</source>
          <target state="translated">스칼라 인수를 사용한 (S Experiment :: autoderef) &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; 는 실험적이며 향후 Perl 버전에서 변경되거나 제거 될 수 있습니다. 이 기능을 사용할 위험을 감수하려면이 경고를 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="0340dd38854b98f9867f6aa44ac6c8072fd08e4d" translate="yes" xml:space="preserve">
          <source>(S experimental::autoderef) &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; with a scalar argument is experimental and may change or be removed in a future Perl version. If you want to take the risk of using this feature, simply disable this warning:</source>
          <target state="translated">스칼라 인수를 사용한 (S Experiment :: autoderef) &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 은 실험적이며 향후 Perl 버전에서 변경되거나 제거 될 수 있습니다. 이 기능을 사용할 위험을 감수하려면이 경고를 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="0c3d026a607b5e03927eeb3ed8eac149da6c99bc" translate="yes" xml:space="preserve">
          <source>(S experimental::autoderef) &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; with a scalar argument is experimental and may change or be removed in a future Perl version. If you want to take the risk of using this feature, simply disable this warning:</source>
          <target state="translated">스칼라 인수가있는 (S Experiment :: autoderef) &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; 는 실험적이며 향후 Perl 버전에서 변경되거나 제거 될 수 있습니다. 이 기능을 사용할 위험을 감수하려면이 경고를 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="e68fdb013728cb1d7ec62f969f221a60cf74a8d9" translate="yes" xml:space="preserve">
          <source>(S experimental::autoderef) &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; with a scalar argument is experimental and may change or be removed in a future Perl version. If you want to take the risk of using this feature, simply disable this warning:</source>
          <target state="translated">스칼라 인수를 사용한 (S Experimental :: autoderef) &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; 는 실험적이며 향후 Perl 버전에서 변경되거나 제거 될 수 있습니다. 이 기능을 사용할 위험을 감수하려면이 경고를 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="5021d69debf858b6240f2dd49bd775fbde8141b2" translate="yes" xml:space="preserve">
          <source>(S experimental::autoderef) &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; with a scalar argument is experimental and may change or be removed in a future Perl version. If you want to take the risk of using this feature, simply disable this warning:</source>
          <target state="translated">스칼라 인수가있는 (S Experiment :: autoderef) &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 은 실험적이며 향후 Perl 버전에서 변경되거나 제거 될 수 있습니다. 이 기능을 사용할 위험을 감수하려면이 경고를 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="aa7538eaab4c50d4855c80a838be355a22d39ea7" translate="yes" xml:space="preserve">
          <source>(S experimental::bitwise) This warning is emitted if you use bitwise operators (&lt;code&gt;&amp;amp; | ^ ~ &amp;amp;. |. ^. ~.&lt;/code&gt; ) with the &quot;bitwise&quot; feature enabled. Simply suppress the warning if you want to use the feature, but know that in doing so you are taking the risk of using an experimental feature which may change or be removed in a future Perl version:</source>
          <target state="translated">(S Experiment :: bitwise) &quot;비트 단위&quot;기능이 활성화 된 상태에서 비트 단위 연산자 ( &lt;code&gt;&amp;amp; | ^ ~ &amp;amp;. |. ^. ~.&lt;/code&gt; ) 를 사용하면이 경고가 발생합니다 . 이 기능을 사용하려면 경고를 표시하지 않으면 다음 Perl 버전에서 변경되거나 제거 될 수있는 실험 기능을 사용할 위험이 있음을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2908faa6b473b76e5180af87ee7c12baeda5af9" translate="yes" xml:space="preserve">
          <source>(S experimental::const_attr) The &quot;const&quot; attribute is experimental. If you want to use the feature, disable the warning with &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings
'experimental::const_attr'&lt;/code&gt; , but know that in doing so you are taking the risk that your code may break in a future Perl version.</source>
          <target state="translated">(S Experiment :: const_attr) &quot;const&quot;속성은 실험적입니다. 이 기능을 사용하려면 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'experimental::const_attr'&lt;/code&gt; &lt;a href=&quot;functions/no&quot;&gt;없이&lt;/a&gt; 경고를 비활성화 하지만 그렇게하면 향후 Perl 버전에서 코드가 손상 될 위험이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ad53fcff910cd15cdb13953286e2f7c8bb9bd3d" translate="yes" xml:space="preserve">
          <source>(S experimental::lexical_subs) This warning is emitted if you declare a sub with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;. Simply suppress the warning if you want to use the feature, but know that in doing so you are taking the risk of using an experimental feature which may change or be removed in a future Perl version:</source>
          <target state="translated">(S Experiment :: lexical_subs)이 경고는 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 로 하위를 선언하면 생성 됩니다 . 이 기능을 사용하려면 경고를 표시하지 않으면 다음 Perl 버전에서 변경되거나 제거 될 수있는 실험 기능을 사용할 위험이 있음을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbad5f4a6c653501b8412294c388aafb614684b0" translate="yes" xml:space="preserve">
          <source>(S experimental::lexical_topic) Lexical $_ is an experimental feature and its behavior may change or even be removed in any future release of perl. See the explanation under &lt;a href=&quot;perlvar#%24_&quot;&gt;$_ in perlvar&lt;/a&gt;.</source>
          <target state="translated">(S Experiment :: lexical_topic) Lexical $ _은 (는) 실험적인 기능으로, 향후 Perl 릴리스에서 동작이 변경되거나 제거 될 수 있습니다. &lt;a href=&quot;perlvar#%24_&quot;&gt;perlvar의 $ _&lt;/a&gt; 아래에있는 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eb4b3483c568e14f7629df3b582640ad8de933fc" translate="yes" xml:space="preserve">
          <source>(S experimental::postderef) This warning is emitted if you use the experimental postfix dereference syntax. Simply suppress the warning if you want to use the feature, but know that in doing so you are taking the risk of using an experimental feature which may change or be removed in a future Perl version:</source>
          <target state="translated">(S Experiment :: postderef) 실험적인 접미사 역 참조 구문을 사용하면이 경고가 발생합니다. 기능을 사용하려는 경우 경고를 표시하지 않으면 다음 Perl 버전에서 변경되거나 제거 될 수있는 실험 기능을 사용할 위험이 있음을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="b02c9ec0ec327279655983f9284490a1da3b67b2" translate="yes" xml:space="preserve">
          <source>(S experimental::re_strict) The things that are different when a regular expression pattern is compiled under &lt;code&gt;'strict'&lt;/code&gt; are subject to change in future Perl releases in incompatible ways. This means that a pattern that compiles today may not in a future Perl release. This warning is to alert you to that risk.</source>
          <target state="translated">(S Experiment :: re_strict) 정규식 패턴이 &lt;code&gt;'strict'&lt;/code&gt; 로 컴파일 될 때 달라지는 것은 향후 Perl 릴리스에서 호환되지 않는 방식으로 변경 될 수 있습니다. 이는 오늘날 컴파일되는 패턴이 향후 Perl 릴리스에 포함되지 않을 수 있음을 의미합니다. 이 경고는 해당 위험을 경고하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="5a6ad942b8a18ebcd3138fccb9819c5b651d94b9" translate="yes" xml:space="preserve">
          <source>(S experimental::refaliasing) This warning is emitted if you use a reference constructor on the left-hand side of an assignment to alias one variable to another. Simply suppress the warning if you want to use the feature, but know that in doing so you are taking the risk of using an experimental feature which may change or be removed in a future Perl version:</source>
          <target state="translated">(S Experiment :: refaliasing)이 경고는 할당의 왼쪽에서 참조 생성자를 사용하여 한 변수를 다른 변수에 별칭으로 지정하면 발생합니다. 기능을 사용하려는 경우 경고를 표시하지 않으면 다음 Perl 버전에서 변경되거나 제거 될 수있는 실험 기능을 사용할 위험이 있음을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="83fe71478e6e6f777d736c82b7741510c469859e" translate="yes" xml:space="preserve">
          <source>(S experimental::regex_sets) This warning is emitted if you use the syntax &lt;code&gt;(?[   ])&lt;/code&gt; in a regular expression. The details of this feature are subject to change. if you want to use it, but know that in doing so you are taking the risk of using an experimental feature which may change in a future Perl version, you can do this to silence the warning:</source>
          <target state="translated">(S Experiment :: regex_sets) 정규식에서 구문 &lt;code&gt;(?[ ])&lt;/code&gt; 을 사용하면이 경고가 발생합니다 . 이 기능의 세부 사항은 변경 될 수 있습니다. 사용하고 싶지만 향후 Perl 버전에서 변경 될 수있는 실험적인 기능을 사용할 위험이 있다는 것을 알고 있다면 다음과 같이하면 경고가 사라집니다.</target>
        </trans-unit>
        <trans-unit id="916c9c164ebab2e4c58728f563414f67240a8b31" translate="yes" xml:space="preserve">
          <source>(S experimental::signatures) This warning is emitted if you unwrap a subroutine's arguments using a signature. Simply suppress the warning if you want to use the feature, but know that in doing so you are taking the risk of using an experimental feature which may change or be removed in a future Perl version:</source>
          <target state="translated">(S Experiment :: signatures)이 경고는 서명을 사용하여 서브 루틴의 인수를 풀면 생성됩니다. 기능을 사용하려는 경우 경고를 표시하지 않으면 다음 Perl 버전에서 변경되거나 제거 될 수있는 실험 기능을 사용할 위험이 있음을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="10c82f1f80af4babbfdb8f5c206b11f2776c58eb" translate="yes" xml:space="preserve">
          <source>(S experimental::smartmatch) &lt;code&gt;given&lt;/code&gt; depends on smartmatch, which is experimental, so its behavior may change or even be removed in any future release of perl. See the explanation under &lt;a href=&quot;perlsyn#Experimental-Details-on-given-and-when&quot;&gt;Experimental Details on given and when in perlsyn&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;given&lt;/code&gt; (S Experimental :: smartmatch) 는 실험적인 smartmatch에 따라 달라 지므로 향후 perl 릴리스에서 동작이 변경되거나 제거 될 수 있습니다. &lt;a href=&quot;perlsyn#Experimental-Details-on-given-and-when&quot;&gt;perlsyn에있을 때와 주어진 시간에&lt;/a&gt; 대한 실험 세부 사항 의 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fdd3e5ba17d65712c94ebe035be28d22def4047d" translate="yes" xml:space="preserve">
          <source>(S experimental::smartmatch) &lt;code&gt;when&lt;/code&gt; depends on smartmatch, which is experimental. Additionally, it has several special cases that may not be immediately obvious, and their behavior may change or even be removed in any future release of perl. See the explanation under &lt;a href=&quot;perlsyn#Experimental-Details-on-given-and-when&quot;&gt;Experimental Details on given and when in perlsyn&lt;/a&gt;.</source>
          <target state="translated">(실험 :: smartmatch S) &lt;code&gt;when&lt;/code&gt; 실험적 smartmatch에 의존한다. 또한 몇 가지 특수한 경우가있어 즉시 눈에 띄지 않을 수 있으며 향후 펄 릴리스에서 해당 동작이 변경되거나 제거 될 수 있습니다. &lt;a href=&quot;perlsyn#Experimental-Details-on-given-and-when&quot;&gt;perlsyn에있을 때와 주어진 시간에&lt;/a&gt; 대한 실험 세부 사항 의 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="033e17323579638c31cc0cacd135190d1cc367d4" translate="yes" xml:space="preserve">
          <source>(S experimental::smartmatch) This warning is emitted if you use the smartmatch (&lt;code&gt;~~&lt;/code&gt; ) operator. This is currently an experimental feature, and its details are subject to change in future releases of Perl. Particularly, its current behavior is noticed for being unnecessarily complex and unintuitive, and is very likely to be overhauled.</source>
          <target state="translated">(S Experiment :: smartmatch) smartmatch ( &lt;code&gt;~~&lt;/code&gt; ) 연산자 를 사용하면이 경고가 발생합니다 . 이것은 현재 실험적인 기능이며 자세한 내용은 Perl의 향후 릴리스에서 변경 될 수 있습니다. 특히, 현재의 행동은 불필요하게 복잡하고 직관적이지 않은 것으로 눈에 and 다.</target>
        </trans-unit>
        <trans-unit id="45f1db3c32640c6609bb45d36afb9afb2acf825b" translate="yes" xml:space="preserve">
          <source>(S experimental::win32_perlio) The &lt;code&gt;:win32&lt;/code&gt; PerlIO layer is experimental. If you want to take the risk of using this layer, simply disable this warning:</source>
          <target state="translated">(S Experiment :: win32_perlio) &lt;code&gt;:win32&lt;/code&gt; PerlIO 레이어는 실험적입니다. 이 계층을 사용할 위험을 감수하려면이 경고를 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="1ad7ae419aa9f6d7c3d063d420951bea77afcdc1" translate="yes" xml:space="preserve">
          <source>(S glob) Something went wrong with the external program(s) used for &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;*.c&amp;gt;&lt;/code&gt; . Usually, this means that you supplied a &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; pattern that caused the external program to fail and exit with a nonzero status. If the message indicates that the abnormal exit resulted in a coredump, this may also mean that your csh (C shell) is broken. If so, you should change all of the csh-related variables in config.sh: If you have tcsh, make the variables refer to it as if it were csh (e.g. &lt;code&gt;full_csh='/usr/bin/tcsh'&lt;/code&gt; ); otherwise, make them all empty (except that &lt;code&gt;d_csh&lt;/code&gt; should be &lt;code&gt;'undef'&lt;/code&gt; ) so that Perl will think csh is missing. In either case, after editing config.sh, run &lt;code&gt;./Configure -S&lt;/code&gt; and rebuild Perl.</source>
          <target state="translated">(S glob) &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;*.c&amp;gt;&lt;/code&gt; 에 사용 된 외부 프로그램에 문제가 있습니다. 일반적 으로 이는 외부 프로그램이 실패하고 0이 아닌 상태로 종료되도록 하는 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 패턴을 제공했음을 의미합니다 . 비정상 종료로 인해 코어 덤프가 발생했다는 메시지가 표시되면 csh (C 쉘)가 손상되었음을 의미 할 수도 있습니다. 그렇다면 config.sh에서 모든 csh 관련 변수를 변경해야합니다. tcsh가있는 경우 변수가 csh 인 것처럼 변수를 참조하도록하십시오 (예 : &lt;code&gt;full_csh='/usr/bin/tcsh'&lt;/code&gt; ); 그렇지 않으면 펄이 csh가 없다고 생각할 수 있도록 모두 비워 &lt;code&gt;d_csh&lt;/code&gt; ( d_csh 가 &lt;code&gt;'undef'&lt;/code&gt; 이어야 함 제외 ). 두 경우 모두 config.sh를 편집 한 후 다음을 실행하십시오. &lt;code&gt;./Configure -S&lt;/code&gt; 를 구성 하고 Perl을 다시 빌드하십시오.</target>
        </trans-unit>
        <trans-unit id="57bf17f6ca7ff6190ebc8e4ef9abd1014fdeaf6c" translate="yes" xml:space="preserve">
          <source>(S inplace) The &lt;code&gt;-i&lt;/code&gt; option was passed on the command line, indicating that the script is intended to edit files in place, but no files were given. This is usually a mistake, since editing STDIN in place doesn't make sense, and can be confusing because it can make perl look like it is hanging when it is really just trying to read from STDIN. You should either pass a filename to edit, or remove &lt;code&gt;-i&lt;/code&gt; from the command line. See &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; for more details.</source>
          <target state="translated">(S inplace) &lt;code&gt;-i&lt;/code&gt; 옵션이 명령 행에 전달되어 스크립트가 파일을 제자리에 편집하려고하지만 파일이 제공되지 않았 음을 나타냅니다. STDIN을 제자리에서 편집하는 것은 의미가 없으며, 실제로 STDIN에서 읽으려고 할 때 펄이 걸려있는 것처럼 보일 수 있기 때문에 혼란 스러울 수 있습니다. 편집 할 파일 이름을 전달하거나 명령 행에서 &lt;code&gt;-i&lt;/code&gt; 를 제거해야합니다 . 자세한 내용은 &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="99017d5c98c7111caeb37e0238149e19073d086b" translate="yes" xml:space="preserve">
          <source>(S inplace) The creation of the new file failed for the indicated reason.</source>
          <target state="translated">표시된대로 새 파일을 작성하지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="872e1ec2ecca53d6c460fabe9bfadbeb70a1e0ba" translate="yes" xml:space="preserve">
          <source>(S inplace) The implicit opening of a file through use of the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; filehandle, either implicitly under the &lt;code&gt;-n&lt;/code&gt; or &lt;code&gt;-p&lt;/code&gt; command-line switches, or explicitly, failed for the indicated reason. Usually this is because you don't have read permission for a file which you named on the command line.</source>
          <target state="translated">(S inplace) &lt;code&gt;-n&lt;/code&gt; 또는 &lt;code&gt;-p&lt;/code&gt; 명령 행 스위치에서 내재적으로 또는 지정된 이유로 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 파일 핸들 을 사용하여 파일을 내재적으로 여는 데 실패했습니다. 일반적으로 이것은 명령 행에서 지정한 파일에 대한 읽기 권한이 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="f8aa0e126b59eedc4f1e3089d182b69944d541a6" translate="yes" xml:space="preserve">
          <source>(S inplace) The rename done by the &lt;b&gt;-i&lt;/b&gt; switch failed for some reason, probably because you don't have write permission to the directory.</source>
          <target state="translated">(S inplace) 디렉토리에 대한 쓰기 권한이 없기 때문에 &lt;b&gt;-i&lt;/b&gt; 스위치로 수행 한 이름 바꾸기 가 어떤 이유로 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="9f45d85e904ad8d2e46a8c11590e1868cde94827" translate="yes" xml:space="preserve">
          <source>(S inplace) You requested an inplace edit without creating a backup file. Perl was unable to remove the original file to replace it with the modified file. The file was left unmodified.</source>
          <target state="translated">(S 내부) 백업 파일을 작성하지 않고 내부 편집을 요청했습니다. Perl이 원본 파일을 제거하여 수정 된 파일로 바꾸지 못했습니다. 파일이 수정되지 않은 상태로 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="60e28fa03590d3c573412868f576acf564778e7d" translate="yes" xml:space="preserve">
          <source>(S inplace) You tried to use the &lt;b&gt;-i&lt;/b&gt; switch on a special file, such as a file in /dev, a FIFO or an uneditable directory. The file was ignored.</source>
          <target state="translated">(S inplace) / dev의 파일, FIFO 또는 편집 할 수없는 디렉토리와 같은 특수 파일 에서 &lt;b&gt;-i&lt;/b&gt; 스위치 를 사용하려고했습니다 . 파일이 무시되었습니다.</target>
        </trans-unit>
        <trans-unit id="2d58b964b8e780d36834ab6bcf8bc11f8572521c" translate="yes" xml:space="preserve">
          <source>(S inplace) Your filesystem does not support filenames longer than 14 characters and Perl was unable to create a unique filename during inplace editing with the &lt;b&gt;-i&lt;/b&gt; switch. The file was ignored.</source>
          <target state="translated">(S inplace) 파일 시스템이 14자를 초과하는 파일 이름을 지원하지 않으며 Perl이 &lt;b&gt;-i&lt;/b&gt; 스위치를 사용하여 내부 편집하는 동안 고유 한 파일 이름을 만들 수 없습니다 . 파일이 무시되었습니다.</target>
        </trans-unit>
        <trans-unit id="391d83c33870f4fffbee4cb34cb266106102f2c0" translate="yes" xml:space="preserve">
          <source>(S internal) A routine asked for a symbol from a symbol table that ought to have existed already, but for some reason it didn't, and had to be created on an emergency basis to prevent a core dump.</source>
          <target state="translated">(S internal) 루틴은 이미 존재해야하는 기호 테이블에서 기호를 요청했지만 어떤 이유로 든 존재하지 않았으며 코어 덤프를 방지하기 위해 긴급하게 작성해야했습니다.</target>
        </trans-unit>
        <trans-unit id="3dc7deb3d33a3a9c91e8159223954b755e40e62e" translate="yes" xml:space="preserve">
          <source>(S internal) All SV objects are supposed to be allocated from arenas that will be garbage collected on exit. An SV was discovered to be outside any of those arenas.</source>
          <target state="translated">(S 내부) 모든 SV 개체는 종료시 가비지 수집 될 경기장에서 할당됩니다. SV는 그 경기장 밖에서 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="132f16965edd70f073335bfeb30e9d71e26bb833" translate="yes" xml:space="preserve">
          <source>(S internal) An internal warning that the grammar is screwed up.</source>
          <target state="translated">(S 내부) 문법이 망가 졌다는 내부 경고.</target>
        </trans-unit>
        <trans-unit id="a651039a1480d93c4c1be41913d07e3d50bc024f" translate="yes" xml:space="preserve">
          <source>(S internal) On exit, Perl found some strings remaining in the shared string table used for copy on write and for hash keys. The entries should have been freed, so this indicates a bug somewhere.</source>
          <target state="translated">(S 내부) 종료시 Perl은 쓰기시 복사 및 해시 키에 사용되는 공유 문자열 테이블에 남아있는 일부 문자열을 발견했습니다. 항목이 해제되었으므로 어딘가에 버그가 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="44bd489cb47ad43c0ef0a840eff3f0915249f1b4" translate="yes" xml:space="preserve">
          <source>(S internal) Perl maintains a reference-counted internal table of strings to optimize the storage and access of hash keys and other strings. This indicates someone tried to decrement the reference count of a string that can no longer be found in the table.</source>
          <target state="translated">(S internal) Perl은 참조 카운트 된 내부 문자열 테이블을 유지하여 해시 키 및 기타 문자열의 저장 및 액세스를 최적화합니다. 이것은 더 이상 테이블에서 찾을 수없는 문자열의 참조 횟수를 줄이려고 시도했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c67b1748ebb655c7aa8709c6bcede8a9561aabec" translate="yes" xml:space="preserve">
          <source>(S internal) Perl went to decrement the reference count of a scalar to see if it would go to 0, and discovered that it had already gone to 0 earlier, and should have been freed, and in fact, probably was freed. This could indicate that SvREFCNT_dec() was called too many times, or that SvREFCNT_inc() was called too few times, or that the SV was mortalized when it shouldn't have been, or that memory has been corrupted.</source>
          <target state="translated">(S internal) Perl은 스칼라의 참조 카운트를 감소시켜 0이되는지 확인하고, 이미 0으로 갔다가 이미 해제되었고 실제로 해제되었을 것임을 발견했습니다. 이는 SvREFCNT_dec ()가 너무 여러 번 호출되었거나 SvREFCNT_inc ()가 너무 여러 번 호출되었거나 SV를 사용하지 않아야 할 때 또는 메모리가 손상되었다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a2edb81fff00f6b46e37c22621c10b69c421935c" translate="yes" xml:space="preserve">
          <source>(S internal) Perl's internal routine that handles &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; formatting follows a slightly different set of rules when called from C or XS code. Specifically, formats consisting of digits followed by &quot;p&quot; (e.g., &quot;%7p&quot;) are reserved for future use. If you see this message, then an XS module tried to call that routine with one such reserved format.</source>
          <target state="translated">(S internal) &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 를 처리하는 Perl의 내부 루틴 형식 은 C 또는 XS 코드에서 호출 될 때 약간 다른 규칙 세트를 따릅니다. 특히 숫자 뒤에 &quot;p&quot;(예 : &quot;% 7p&quot;)로 구성된 형식은 나중에 사용하기 위해 예약되어 있습니다. 이 메시지가 표시되면 XS 모듈은 예약 된 형식 중 하나를 사용하여 해당 루틴을 호출하려고 시도한 것입니다.</target>
        </trans-unit>
        <trans-unit id="c37b27abb48e8eb5d7ca287f03d264501d8344b8" translate="yes" xml:space="preserve">
          <source>(S internal) Something went wrong in Perl's internal bookkeeping of scalars: not all scalar variables were deallocated by the time Perl exited. What this usually indicates is a memory leak, which is of course bad, especially if the Perl program is intended to be long-running.</source>
          <target state="translated">(S internal) Perl의 스칼라에 대한 내부 부기에서 문제가 발생했습니다. Perl이 종료 될 때까지 모든 스칼라 변수가 할당 해제되지 않았습니다. 이것이 일반적으로 나타내는 것은 메모리 누출이며, 특히 Perl 프로그램이 오래 실행되도록 의도 된 경우에는 특히 나쁩니다.</target>
        </trans-unit>
        <trans-unit id="5c5bd9dca59344b37ed2394cfbc1138baaa0eca0" translate="yes" xml:space="preserve">
          <source>(S internal) The behavior of &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt; after insertion is undefined; it may skip items, or visit items more than once. Consider using &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys()&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">(S internal) 삽입 후 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt; )의 동작 은 정의되어 있지 않습니다. 항목을 건너 뛰거나 항목을 두 번 이상 방문 할 수 있습니다. &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys()&lt;/a&gt;&lt;/code&gt; 사용을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="07ddb82bdff7ed7dd5c6b0c1d3a36605babafcf2" translate="yes" xml:space="preserve">
          <source>(S internal) The exit code detected an internal inconsistency in how many blocks were entered and left.</source>
          <target state="translated">(S internal) 종료 코드는 입력 및 남은 블록 수에서 내부 불일치를 발견했습니다.</target>
        </trans-unit>
        <trans-unit id="eaf5aad3008e85405951cb9dad4eae62767f907f" translate="yes" xml:space="preserve">
          <source>(S internal) The exit code detected an internal inconsistency in how many execution contexts were entered and left.</source>
          <target state="translated">(S internal) 종료 코드가 몇 개의 실행 컨텍스트가 입력되고 남아 있는지에 대한 내부 불일치를 발견했습니다.</target>
        </trans-unit>
        <trans-unit id="72f44f6876e80b1534971437fb4d17c299a6afa6" translate="yes" xml:space="preserve">
          <source>(S internal) The exit code detected an internal inconsistency in how many mortal scalars were allocated and freed.</source>
          <target state="translated">(S internal) 종료 코드는 얼마나 많은 필사 스칼라가 할당되고 해제되었는지에 대한 내부 불일치를 발견했습니다.</target>
        </trans-unit>
        <trans-unit id="dceeb21ca1e86c504a62b53525d02f4f31a4a3a4" translate="yes" xml:space="preserve">
          <source>(S internal) The exit code detected an internal inconsistency in how many values were temporarily localized.</source>
          <target state="translated">(S internal) 종료 코드가 일시적으로 현지화 된 값 수의 내부 불일치를 발견했습니다.</target>
        </trans-unit>
        <trans-unit id="190594aeb2c9a4483221fc4002c86f36ec9ff9b3" translate="yes" xml:space="preserve">
          <source>(S internal) The internal newSVsv() routine was called to duplicate a scalar that had previously been marked as free.</source>
          <target state="translated">(S internal) 내부 newSVsv () 루틴이 이전에 사용 가능으로 표시된 스칼라를 복제하도록 호출되었습니다.</target>
        </trans-unit>
        <trans-unit id="7c7dc801e9fba6300ba40bd725a9fa40574c408e" translate="yes" xml:space="preserve">
          <source>(S internal) The reference counts got screwed up on symbol aliases.</source>
          <target state="translated">(S 내부) 심볼 카운트에서 참조 카운트가 강화되었습니다.</target>
        </trans-unit>
        <trans-unit id="805cf0addb046de8b660e0f8e96a1bc7d9fada35" translate="yes" xml:space="preserve">
          <source>(S internal) The symbol in question was declared but somehow went out of scope before it could possibly have been used.</source>
          <target state="translated">(S internal) 문제의 기호가 선언되었지만 사용하기 전에 어떻게 든 범위를 벗어났습니다.</target>
        </trans-unit>
        <trans-unit id="d1b252c576a82752a42dbb0fe4ed4264a3af151a" translate="yes" xml:space="preserve">
          <source>(S io) An error occurred when Perl implicitly closed a filehandle. This usually indicates your file system ran out of disk space.</source>
          <target state="translated">(S io) Perl이 파일 핸들을 암시 적으로 닫을 때 오류가 발생했습니다. 이것은 일반적으로 파일 시스템에 디스크 공간이 부족함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b3750e6f44fed9ab0221da58f719cb3c95d174e4" translate="yes" xml:space="preserve">
          <source>(S io) You tried to apply an encoding that did not exist to a filehandle, either with open() or binmode().</source>
          <target state="translated">(S io) open () 또는 binmode ()를 사용하여 파일 핸들에 존재하지 않는 인코딩을 적용하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="fa39a61a251f17784b259620eff68ff78d98ee28" translate="yes" xml:space="preserve">
          <source>(S malloc) An internal routine called free() on something that had already been freed.</source>
          <target state="translated">(S malloc) 이미 해제 된 무언가에 대해 free ()라는 내부 루틴.</target>
        </trans-unit>
        <trans-unit id="5d0b521fec65b45130587042c2a612513012a191" translate="yes" xml:space="preserve">
          <source>(S malloc) An internal routine called free() on something that had never been malloc()ed in the first place. Mandatory, but can be disabled by setting environment variable &lt;code&gt;PERL_BADFREE&lt;/code&gt; to 0.</source>
          <target state="translated">(S malloc) 처음에 malloc () 된 적이없는 무언가에 free ()라는 내부 루틴. 필수이지만 환경 변수 &lt;code&gt;PERL_BADFREE&lt;/code&gt; 를 0 으로 설정하여 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d8c259ae60ee2d2d383dd4c7abe117aad0b9ac8c" translate="yes" xml:space="preserve">
          <source>(S malloc) An internal routine called realloc() on something that had already been freed.</source>
          <target state="translated">(S malloc) 이미 해제 된 무언가에 대해 realloc ()이라는 내부 루틴.</target>
        </trans-unit>
        <trans-unit id="a620f32bfd6072f137b8950d3d72d49ef7b5c6d6" translate="yes" xml:space="preserve">
          <source>(S malloc) An internal routine called realloc() on something that had never been malloc()ed in the first place. Mandatory, but can be disabled by setting the environment variable &lt;code&gt;PERL_BADFREE&lt;/code&gt; to 1.</source>
          <target state="translated">(S malloc) 처음에는 malloc () 된 적이없는 것에 대해 realloc ()이라는 내부 루틴입니다. 필수이지만 환경 변수 &lt;code&gt;PERL_BADFREE&lt;/code&gt; 를 1 로 설정하여 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="77bc07a55e926afe8aa19cc310695c60f70caab0" translate="yes" xml:space="preserve">
          <source>(S misc) With &quot;use strict&quot; in effect, you referred to a global variable that you apparently thought was imported from another module, because something else of the same name (usually a subroutine) is exported by that module. It usually means you put the wrong funny character on the front of your variable.</source>
          <target state="translated">(S misc) &quot;엄격한 사용&quot;을 사용하면 동일한 이름의 다른 항목 (보통 서브 루틴)이 해당 모듈에 의해 내보내지기 때문에 다른 모듈에서 가져온 것으로 생각되는 전역 변수를 참조했습니다. 일반적으로 변수 앞에 잘못된 재미있는 문자를 넣는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="573a802cf81c9c779976f7aa813dbd3adec4e6c2" translate="yes" xml:space="preserve">
          <source>(S non_unicode) Perl allows strings to contain a superset of Unicode code points; each code point may be as large as what is storable in an unsigned integer on your system, but these may not be accepted by other languages/systems. This message occurs when you matched a string containing such a code point against a regular expression pattern, and the code point was matched against a Unicode property, &lt;code&gt;\p{...}&lt;/code&gt; or &lt;code&gt;\P{...}&lt;/code&gt; . Unicode properties are only defined on Unicode code points, so the result of this match is undefined by Unicode, but Perl (starting in v5.20) treats non-Unicode code points as if they were typical unassigned Unicode ones, and matched this one accordingly. Whether a given property matches these code points or not is specified in &lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;Properties accessible through \p{} and \P{} in perluniprops&lt;/a&gt;.</source>
          <target state="translated">(S non_unicode) Perl은 문자열이 유니 코드 코드 포인트의 슈퍼 세트를 포함 할 수 있도록합니다. 각 코드 포인트는 시스템의 부호없는 정수에 저장할 수있는 것보다 클 수 있지만 다른 언어 / 시스템에서는 허용되지 않을 수 있습니다. 이 메시지는 이러한 코드 포인트가 포함 된 문자열을 정규식 패턴과 일치시키고 코드 포인트가 유니 코드 특성 인 &lt;code&gt;\p{...}&lt;/code&gt; 또는 &lt;code&gt;\P{...}&lt;/code&gt; 와 일치 할 때 발생합니다 . 유니 코드 속성은 유니 코드 코드 포인트에만 정의되므로이 일치의 결과는 유니 코드에 의해 정의되지 않지만 Perl (v5.20에서 시작)은 유니 코드가 아닌 코드 포인트를 일반적인 할당되지 않은 유니 코드 포인트처럼 처리하고 이에 따라 일치시킵니다. . 주어진 속성이 이러한 코드 포인트와 일치하는지 여부는&lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;\ P {}와 \ P {} perluniprops의를 통해 액세스 속성&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="19b283d9880fdba021f728f4ecad97414f4175d1" translate="yes" xml:space="preserve">
          <source>(S non_unicode) You had a code point above the Unicode maximum of U+10FFFF.</source>
          <target state="translated">(S non_unicode) 유니 코드 최대 값 U + 10FFFF를 초과하는 코드 포인트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e65bd4350fe9dad8bab07ca1af0ee7abcc64cc0" translate="yes" xml:space="preserve">
          <source>(S non_unicode) You performed an operation requiring Unicode rules on a code point that is not in Unicode, so what it should do is not defined. Perl has chosen to have it do nothing, and warn you.</source>
          <target state="translated">(S non_unicode) 유니 코드가 아닌 코드 포인트에서 유니 코드 규칙이 필요한 작업을 수행 했으므로 수행 할 작업이 정의되지 않았습니다. 펄은 아무것도하지 않기로 선택했고 경고했다.</target>
        </trans-unit>
        <trans-unit id="65ce68f38fa2e28e569a079eebc3ab60a8c462a5" translate="yes" xml:space="preserve">
          <source>(S nonchar) Certain codepoints, such as U+FFFE and U+FFFF, are defined by the Unicode standard to be non-characters. Those are legal codepoints, but are reserved for internal use; so, applications shouldn't attempt to exchange them. An application may not be expecting any of these characters at all, and receiving them may lead to bugs. If you know what you are doing you can turn off this warning by &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'nonchar';&lt;/code&gt; .</source>
          <target state="translated">(S nonchar) U + FFFE 및 U + FFFF와 같은 특정 코드 포인트는 유니 코드 표준에 의해 문자가 아닌 것으로 정의됩니다. 그것들은 합법적 인 코드 포인트이지만 내부 용으로 예약되어 있습니다. 따라서 응용 프로그램은 교환을 시도해서는 안됩니다. 응용 프로그램은 이러한 문자를 전혀 기대하지 않을 수 있으며, 이러한 문자를 수신하면 버그가 발생할 수 있습니다. 당신은 당신이 무엇을하고 있는지 알고 있다면 당신은에 의해이 경고 해제 할 수 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'nonchar';&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0bc8b6a3ebad86f966480eeb67b327a6d89ff484" translate="yes" xml:space="preserve">
          <source>(S overflow) The hexadecimal, octal or binary number you have specified either as a literal or as an argument to hex() or oct() is too big for your architecture, and has been converted to a floating point number. On a 32-bit architecture the largest hexadecimal, octal or binary number representable without overflow is 0xFFFFFFFF, 037777777777, or 0b11111111111111111111111111111111 respectively. Note that Perl transparently promotes all numbers to a floating point representation internally--subject to loss of precision errors in subsequent operations.</source>
          <target state="translated">(S overflow) 리터럴 또는 hex () 또는 oct ()에 대한 인수로 지정한 16 진수, 8 진수 또는 2 진수는 아키텍처에 비해 너무 커서 부동 소수점 숫자로 변환되었습니다. 32 비트 아키텍처에서 오버플로없이 표시 할 수있는 가장 큰 16 진수, 8 진수 또는 2 진수는 각각 0xFFFFFFFF, 037777777777 또는 0b11111111111111111111111111111111입니다. Perl은 모든 숫자를 내부적으로 부동 소수점 표현으로 투명하게 승격합니다. 후속 작업에서 정밀도 오류가 없어 질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a81efe3b141644ae1c64ccda8162305de772f81a" translate="yes" xml:space="preserve">
          <source>(S overflow) The number you have passed to srand is too big to fit in your architecture's integer representation. The number has been replaced with the largest integer supported (0xFFFFFFFF on 32-bit architectures). This means you may be getting less randomness than you expect, because different random seeds above the maximum will return the same sequence of random numbers.</source>
          <target state="translated">(S overflow) srand에 전달한 숫자가 너무 커서 아키텍처의 정수 표현에 맞지 않습니다. 이 숫자는 지원되는 가장 큰 정수 (32 비트 아키텍처의 경우 0xFFFFFFFF)로 대체되었습니다. 이는 최대 값을 초과하는 다른 임의의 시드가 동일한 난수 시퀀스를 반환하기 때문에 예상보다 임의성이 떨어질 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="fa880c4ea294018cc8b7759e1f40c09681a9ecd0" translate="yes" xml:space="preserve">
          <source>(S precedence) The old irregular construct</source>
          <target state="translated">(S 우선) 오래된 불규칙 구조</target>
        </trans-unit>
        <trans-unit id="f4f9f0dc0b34226bf8eba2562237c41d577c0e6a" translate="yes" xml:space="preserve">
          <source>(S printf) The %vd (s)printf format does not support version objects with alpha parts.</source>
          <target state="translated">(S printf) % vd (s) printf 형식은 알파 부분이있는 버전 객체를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ce97a4246b6d12bea94b40f3a1725e34f3c6534" translate="yes" xml:space="preserve">
          <source>(S prototype) The subroutine being declared or defined had previously been declared or defined with a different function prototype.</source>
          <target state="translated">(S 프로토 타입) 선언되거나 정의 된 서브 루틴은 이전에 다른 함수 프로토 타입으로 선언 또는 정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="a74017dd7ef16cdde3163d002f96e226e9847a43" translate="yes" xml:space="preserve">
          <source>(S regexp) You used a regular expression with case-insensitive matching, and there is a bug in Perl in which the built-in regular expression folding rules are not accurate. This may lead to incorrect results. Please report this as a bug using the &lt;a href=&quot;perlbug&quot;&gt;perlbug&lt;/a&gt; utility.</source>
          <target state="translated">(S regexp) 대소 문자를 구분하지 않는 정규 표현식을 사용했으며, Perl에 내장 정규 표현식 폴딩 규칙이 정확하지 않은 버그가 있습니다. 잘못된 결과가 발생할 수 있습니다. &lt;a href=&quot;perlbug&quot;&gt;perlbug&lt;/a&gt; 유틸리티를 사용하여 이것을 버그로보고하십시오 .</target>
        </trans-unit>
        <trans-unit id="df864de1124aae42786167d97b20d0e1db294582" translate="yes" xml:space="preserve">
          <source>(S surrogate) You had a UTF-16 surrogate in a context where they are not considered acceptable. These code points, between U+D800 and U+DFFF (inclusive), are used by Unicode only for UTF-16. However, Perl internally allows all unsigned integer code points (up to the size limit available on your platform), including surrogates. But these can cause problems when being input or output, which is likely where this message came from. If you really really know what you are doing you can turn off this warning by &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'surrogate';&lt;/code&gt; .</source>
          <target state="translated">(대리) 허용되지 않는 것으로 간주되는 상황에서 UTF-16 대리가 있습니다. U + D800과 U + DFFF (포함) 사이의 이러한 코드 포인트는 UTF-16의 유니 코드에서만 사용됩니다. 그러나 Perl은 대리자를 포함하여 서명되지 않은 모든 정수 코드 포인트 (플랫폼에서 사용 가능한 크기 제한까지)를 내부적으로 허용합니다. 그러나 입력 또는 출력시 문제가 발생할 수 있으며이 메시지가 나오는 위치 일 수 있습니다. 당신은 정말 당신이하여이 경고를 해제 할 수 있습니다 무엇을하고 있는지 알고 있다면 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'surrogate';&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c0f0ed56bf6fb19cc79ec8dfe5eb86e0e68ffff" translate="yes" xml:space="preserve">
          <source>(S surrogate) You performed an operation requiring Unicode rules on a Unicode surrogate. Unicode frowns upon the use of surrogates for anything but storing strings in UTF-16, but rules are (reluctantly) defined for the surrogates, and they are to do nothing for this operation. Because the use of surrogates can be dangerous, Perl warns.</source>
          <target state="translated">(대리) 유니 코드 대리에 유니 코드 규칙이 필요한 작업을 수행했습니다. 유니 코드는 문자열을 UTF-16으로 저장하는 것 이외의 용도로 서로 게이트를 사용하는 것에 대해 눈살을 찌푸 리지만, 대체물에는 규칙이 (마지막으로) 정의되어 있으며이 작업에는 아무 것도하지 않습니다. Perl은 대리모를 사용하는 것이 위험 할 수 있기 때문에 경고합니다.</target>
        </trans-unit>
        <trans-unit id="f6acf881691f06ec13f8292be3aba45678bee7bb" translate="yes" xml:space="preserve">
          <source>(S syntax) The Perl lexer knows whether to expect a term or an operator. If it sees what it knows to be a term when it was expecting to see an operator, it gives you this warning. Usually it indicates that an operator or delimiter was omitted, such as a semicolon.</source>
          <target state="translated">(S 구문) Perl lexer는 용어 또는 연산자를 기대할지 여부를 알고 있습니다. 운영자를 예상 할 때 용어로 알고있는 것을 알게되면이 경고를 표시합니다. 일반적으로 세미콜론과 같이 연산자 또는 구분 기호가 생략되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4454450ae7b35ebe2cd2fbb1d446acb7866dd2eb" translate="yes" xml:space="preserve">
          <source>(S syntax) There is no keyword &quot;elseif&quot; in Perl because Larry thinks it's ugly. Your code will be interpreted as an attempt to call a method named &quot;elseif&quot; for the class returned by the following block. This is unlikely to be what you want.</source>
          <target state="translated">(S 구문) Larry는 그것이 추악하다고 생각하기 때문에 Perl에는 &quot;elseif&quot;라는 키워드가 없습니다. 코드는 다음 블록에서 반환 한 클래스에 대해 &quot;elseif&quot;라는 메서드를 호출하려는 시도로 해석됩니다. 이것은 당신이 원하는 것이 아닐 것입니다.</target>
        </trans-unit>
        <trans-unit id="a8c2d78dc7d59678e13893fb1795ba6312ba8d4a" translate="yes" xml:space="preserve">
          <source>(S syntax) This is an educated guess made in conjunction with the message &quot;%s found where operator expected&quot;. Don't automatically put a semicolon on the previous line just because you saw this message.</source>
          <target state="translated">(S 구문) 이것은 &quot;연산자가 예상 한 위치에서 % s을 (를) 찾았습니다&quot;라는 메시지와 관련하여 정확한 추측입니다. 이 메시지를 보았 기 때문에 이전 줄에 세미콜론을 자동으로 넣지 마십시오.</target>
        </trans-unit>
        <trans-unit id="c2781a5a2d3b1c269fdba51833459c2daf2cf4b6" translate="yes" xml:space="preserve">
          <source>(S syntax) This is an educated guess made in conjunction with the message &quot;%s found where operator expected&quot;. It often means a subroutine or module name is being referenced that hasn't been declared yet. This may be because of ordering problems in your file, or because of a missing &quot;sub&quot;, &quot;package&quot;, &quot;require&quot;, or &quot;use&quot; statement. If you're referencing something that isn't defined yet, you don't actually have to define the subroutine or package before the current location. You can use an empty &quot;sub foo;&quot; or &quot;package FOO;&quot; to enter a &quot;forward&quot; declaration.</source>
          <target state="translated">(S 구문) 이것은 &quot;연산자가 예상 한 위치에서 % s을 (를) 찾았습니다&quot;라는 메시지와 관련하여 작성된 추측입니다. 그것은 아직 선언되지 않은 서브 루틴 또는 모듈 이름이 참조되고 있음을 의미합니다. 파일의 순서 문제 또는 &quot;sub&quot;, &quot;package&quot;, &quot;require&quot;또는 &quot;use&quot;문이 누락 되었기 때문일 수 있습니다. 아직 정의되지 않은 것을 참조하는 경우 현재 위치 전에 서브 루틴 또는 패키지를 실제로 정의 할 필요는 없습니다. 빈 &quot;sub foo;&quot;를 사용할 수 있습니다. 또는 &quot;패키지 FOO;&quot; &quot;전달&quot;선언을 입력합니다.</target>
        </trans-unit>
        <trans-unit id="f3181ebefec91564c2751781f26571979e02ab21" translate="yes" xml:space="preserve">
          <source>(S syntax) This is an educated guess made in conjunction with the message &quot;%s found where operator expected&quot;. Often the missing operator is a comma.</source>
          <target state="translated">(S 구문) 이것은 &quot;연산자가 예상 한 위치에서 % s을 (를) 찾았습니다&quot;라는 메시지와 관련하여 작성된 추측입니다. 누락 된 연산자는 종종 쉼표입니다.</target>
        </trans-unit>
        <trans-unit id="a2b03541201cb492e4bcc13c8c07d39c4ca0f12c" translate="yes" xml:space="preserve">
          <source>(S utf8) Perl met a wide character (&amp;gt;255) when it wasn't expecting one. This warning is by default on for I/O (like print). The easiest way to quiet this warning is simply to add the &lt;code&gt;:utf8&lt;/code&gt; layer to the output, e.g. &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt; STDOUT, ':utf8'&lt;/code&gt; . Another way to turn off the warning is to add &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'utf8';&lt;/code&gt; but that is often closer to cheating. In general, you are supposed to explicitly mark the filehandle with an encoding, see &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; and &lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;.</source>
          <target state="translated">(S utf8) Perl은 예상치 못한 넓은 문자 (&amp;gt; 255)를 만났습니다. 이 경고는 I / O에 대해 기본적으로 켜져 있습니다 (인쇄와 같은). 이 경고를 해제하는 가장 쉬운 방법은 &lt;code&gt;:utf8&lt;/code&gt; 레이어를 출력 예 : &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt; STDOUT, ':utf8'&lt;/code&gt; . 경고를 끄는 또 다른 방법은 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'utf8';&lt;/code&gt; 하지만 종종 부정 행위에 더 가깝습니다. 일반적으로 파일 핸들을 인코딩으로 명시 적으로 표시해야합니다 (&lt;a href=&quot;open&quot;&gt; open&lt;/a&gt; 및&lt;a href=&quot;functions/binmode&quot;&gt; binmode&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="57855f2bd9937b267a6b6576a7d9eb1c1b15b09c" translate="yes" xml:space="preserve">
          <source>(S utf8) When reading in different encodings, Perl tries to map everything into Unicode characters. The bytes you read in are not legal in this encoding. For example</source>
          <target state="translated">(S utf8) 다른 인코딩으로 읽을 때 Perl은 모든 것을 유니 코드 문자로 매핑하려고 시도합니다. 읽은 바이트는이 인코딩에서 유효하지 않습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="8cd0aaf1873d02e4abc5ce50af24301359e43db8" translate="yes" xml:space="preserve">
          <source>(S utf8)(F) Perl detected a string that didn't comply with UTF-8 encoding rules, even though it had the UTF8 flag on.</source>
          <target state="translated">(S utf8) (F) Perl은 UTF8 플래그가 켜져 있어도 UTF-8 인코딩 규칙을 준수하지 않는 문자열을 감지했습니다.</target>
        </trans-unit>
        <trans-unit id="3683ce30134f0866ff8cc5b425b5c96153f23e84" translate="yes" xml:space="preserve">
          <source>(S) A module passed the flag 0x01 to DynaLoader::dl_load_file() to request that symbols from the stated file are made available globally within the process, but that functionality is not available on this platform. Whilst the module likely will still work, this may prevent the perl interpreter from loading other XS-based extensions which need to link directly to functions defined in the C or XS code in the stated file.</source>
          <target state="translated">(S) 모듈이 지정된 파일의 심볼을 프로세스 내에서 전역 적으로 사용할 수 있도록 요청하기 위해 플래그 0x01을 DynaLoader :: dl_load_file ()에 전달했지만이 플랫폼에서는 해당 기능을 사용할 수 없습니다. 모듈이 여전히 작동 할 수 있지만, 이렇게하면 perl 인터프리터가 명시된 파일의 C 또는 XS 코드에 정의 된 함수에 직접 링크해야하는 다른 XS 기반 확장을로드하지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71fe0e7a0ef74c8ea97478433120256a495f7ddb" translate="yes" xml:space="preserve">
          <source>(S) A warning from the GDBM_File extension that a store failed.</source>
          <target state="translated">(S) GDBM_File 확장에서 저장이 실패했다는 경고.</target>
        </trans-unit>
        <trans-unit id="e2714b5f88acc5f800149b3163d506069fce696e" translate="yes" xml:space="preserve">
          <source>(S) A warning peculiar to VMS. Perl keeps track of the number of times you've called &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;, to determine whether the current call to &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; should affect the current script or a subprocess (see &lt;a href=&quot;perlvms#exec-LIST&quot;&gt;exec LIST in perlvms&lt;/a&gt;). Somehow, this count has become scrambled, so Perl is making a guess and treating this &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; as a request to terminate the Perl script and execute the specified command.</source>
          <target state="translated">(S) VMS 특유의 경고. Perl은 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 를 호출 한 횟수를 추적 하여 현재 호출이 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 이 현재 스크립트 또는 서브 프로세스에 영향을 미치는지(&lt;a href=&quot;perlvms#exec-LIST&quot;&gt; perlvms의 exec LIST&lt;/a&gt; 참조). 어쨌든,이 카운트는 스크램블되었습니다. 그래서 Perl은 추측 하고이 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 를 처리합니다. 를 Perl 스크립트를 종료하고 지정된 명령을 실행하기위한 요청으로 .</target>
        </trans-unit>
        <trans-unit id="5b1ed1e9ebe7c3194ca76ef10180a3dddbee42ff" translate="yes" xml:space="preserve">
          <source>(S) A warning peculiar to VMS. Perl tried to read an element of %ENV from the CRTL's internal environment array and discovered the array was missing. You need to figure out where your CRTL misplaced its environ or define</source>
          <target state="translated">(S) VMS 특유의 경고. Perl이 CRTL의 내부 환경 배열에서 % ENV 요소를 읽으려고 시도했으며 배열이 누락되었음을 발견했습니다. CRTL이 환경을 잘못 배치 한 위치를 파악하거나 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="80a50c6efc131c5760a3154b2ef75d4174884a2e" translate="yes" xml:space="preserve">
          <source>(S) A warning peculiar to VMS. Perl was unable to find the local timezone offset, so it's assuming that local system time is equivalent to UTC. If it's not, define the logical name</source>
          <target state="translated">(S) VMS 특유의 경고. Perl은 로컬 시간대 오프셋을 찾을 수 없으므로 로컬 시스템 시간이 UTC와 같다고 가정합니다. 그렇지 않은 경우 논리적 이름을 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="a0bdeb47a9bc2a4c86556ce039ed7dc145f5ba40" translate="yes" xml:space="preserve">
          <source>(S) A warning peculiar to VMS. The call to &lt;code&gt;sys$getuai&lt;/code&gt; underlying the &lt;code&gt;&lt;a href=&quot;functions/getpwnam&quot;&gt;getpwnam&lt;/a&gt;&lt;/code&gt; operator returned an invalid UIC.</source>
          <target state="translated">(S) VMS 특유의 경고. &lt;code&gt;sys$getuai&lt;/code&gt; 대한 호출 은 &lt;code&gt;&lt;a href=&quot;functions/getpwnam&quot;&gt;getpwnam&lt;/a&gt;&lt;/code&gt; 연산자의잘못된 UIC를 리턴했습니다.</target>
        </trans-unit>
        <trans-unit id="75067461356bbab9bcda2b924a0dbdd21fbc62b3" translate="yes" xml:space="preserve">
          <source>(S) A warning peculiar to VMS. This arises because of the difference between access checks under VMS and under the Unix model Perl assumes. Under VMS, access checks are done by filename, rather than by bits in the stat buffer, so that ACLs and other protections can be taken into account. Unfortunately, Perl assumes that the stat buffer contains all the necessary information, and passes it, instead of the filespec, to the access-checking routine. It will try to retrieve the filespec using the device name and FID present in the stat buffer, but this works only if you haven't made a subsequent call to the CRTL stat() routine, because the device name is overwritten with each call. If this warning appears, the name lookup failed, and the access-checking routine gave up and returned FALSE, just to be conservative. (Note: The access-checking routine knows about the Perl &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; operator and file tests, so you shouldn't ever see this warning in response to a Perl command; it arises only if some internal code takes stat buffers lightly.)</source>
          <target state="translated">(S) VMS 특유의 경고. 이는 VMS와 Unix 모델 Perl이 가정 한 액세스 확인 간의 차이로 인해 발생합니다. VMS에서 액세스 검사는 stat 버퍼의 비트가 아닌 파일 이름으로 수행되므로 ACL 및 기타 보호 기능을 고려할 수 있습니다. 불행히도 Perl은 stat 버퍼에 필요한 모든 정보가 포함되어 있다고 가정하고이를 파일 스펙 대신 액세스 점검 루틴으로 전달합니다. stat 버퍼에 존재하는 장치 이름과 FID를 사용하여 파일 스펙을 검색하려고 시도하지만 CRTL stat () 루틴에 대한 후속 호출을 수행하지 않은 경우에만 작동합니다. 각 호출로 장치 이름을 겹쳐 씁니다. 이 경고가 표시되면 이름 조회가 실패하고 액세스 점검 루틴이 포기되어 FALSE를 리턴 한 것입니다. (노트:액세스 점검 루틴은 Perl에 대해 알고 있습니다. &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 연산자 및 파일 테스트이므로 Perl 명령에 대한 응답으로이 경고가 표시되지 않아야합니다. 일부 내부 코드가 통계 버퍼를 가볍게 사용하는 경우에만 발생합니다.)</target>
        </trans-unit>
        <trans-unit id="930a63fd0c5a6b7a74664583320d536530e1c47e" translate="yes" xml:space="preserve">
          <source>(S) An advisory indicating that the previous error may have been caused by a missing delimiter on a string or pattern, because it eventually ended earlier on the current line.</source>
          <target state="translated">(S) 문자열이나 패턴에서 분리 문자가 누락되어 이전 오류가 발생했을 수 있음을 나타내는 권고. 결과는 현재 행에서 일찍 종료 되었기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="ea431a3e9652c10520b899d17d8c4d7d245822b1" translate="yes" xml:space="preserve">
          <source>(S) An uncaught die() was called when &lt;code&gt;PERL_EXIT_WARN&lt;/code&gt; was set in &lt;code&gt;PL_exit_flags&lt;/code&gt; .</source>
          <target state="translated">(S) &lt;code&gt;PERL_EXIT_WARN&lt;/code&gt; 이 PL_exit_flags 에 설정 되었을 때 잡히지 않은 die ()가 호출 &lt;code&gt;PL_exit_flags&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32a226ec92183bc190d2e2015a61b567573815e2" translate="yes" xml:space="preserve">
          <source>(S) If you see this message, then something is seriously wrong with the internal bookkeeping of op trees. An op tree needed to be freed after a compilation error, but could not be found, so it was leaked instead.</source>
          <target state="translated">(S)이 메시지가 표시되면 op 나무의 내부 부기 문제가 심각합니다. 컴파일 오류 후에 op 트리를 해제해야했지만 찾을 수 없으므로 대신 유출되었습니다.</target>
        </trans-unit>
        <trans-unit id="e31315c4370c451df264360074e78b518d31127a" translate="yes" xml:space="preserve">
          <source>(S) PERL_HASH_SEED should match /^\s*(?:0x)?[0-9a-fA-F]+\s*\z/ but it contained a non hex character. This could mean you are not using the hash seed you think you are.</source>
          <target state="translated">(S) PERL_HASH_SEED는 / ^ \ s * (?: 0x)? [0-9a-fA-F] + \ s * \ z /와 일치해야하지만 16 진 문자가 아닙니다. 이것은 당신이 생각하는 해시 시드를 사용하고 있지 않다는 것을 의미 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="574ab9c7bf2103c1f692194c2ec8c32451ec0a86" translate="yes" xml:space="preserve">
          <source>(S) Perl was run with the environment variable PERL_PERTURB_KEYS defined but containing an unexpected value. The legal values of this setting are as follows.</source>
          <target state="translated">(S) Perl이 환경 변수 PERL_PERTURB_KEYS가 정의되었지만 예상치 않은 값을 포함하여 실행되었습니다. 이 설정의 올바른 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="889f7fc12cf40635318289062b5183bc737b5bb0" translate="yes" xml:space="preserve">
          <source>(S) The implicit close() done by an open() got an error indication on the close(). This usually indicates your file system ran out of disk space.</source>
          <target state="translated">(S) open ()에 의해 수행 된 암시 적 close ()에 close ()에 오류 표시가 있습니다. 이것은 일반적으로 파일 시스템에 디스크 공간이 부족함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="478dd644bf1500e4e55920ac078aec49bfb5ac11" translate="yes" xml:space="preserve">
          <source>(S) The whole warning message will look something like:</source>
          <target state="translated">(S) 전체 경고 메시지는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e2cb7ac39677c13cdd8565b8127088c31a7d55a3" translate="yes" xml:space="preserve">
          <source>(S) You compiled perl with &lt;b&gt;-D&lt;/b&gt;PERL_DEBUG_READONLY_COW (see &lt;a href=&quot;perlguts#Copy-on-Write&quot;&gt;Copy on Write in perlguts&lt;/a&gt;), but a read-only shared string buffer could not be made mutable.</source>
          <target state="translated">(S) &lt;b&gt;-D&lt;/b&gt; PERL_DEBUG_READONLY_COW를 사용 하여 perl을 컴파일 했지만 (perlguts의 &lt;a href=&quot;perlguts#Copy-on-Write&quot;&gt;쓰기시 복사&lt;/a&gt; 참조 ) 읽기 전용 공유 문자열 버퍼를 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2cb363bd5bfb6e77492d1ab85ce15a97859f3690" translate="yes" xml:space="preserve">
          <source>(S) You compiled perl with &lt;b&gt;-D&lt;/b&gt;PERL_DEBUG_READONLY_COW (see &lt;a href=&quot;perlguts#Copy-on-Write&quot;&gt;Copy on Write in perlguts&lt;/a&gt;), but a shared string buffer could not be made read-only.</source>
          <target state="translated">(S) &lt;b&gt;-D&lt;/b&gt; PERL_DEBUG_READONLY_COW를 사용 하여 perl을 컴파일 했습니다 ( &lt;a href=&quot;perlguts#Copy-on-Write&quot;&gt;perlguts의 쓰기시 복사&lt;/a&gt; 참조) ) 공유 문자열 버퍼를 읽기 전용으로 만들 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1d1920922b4140b4a15e07f071743952f23ddb8a" translate="yes" xml:space="preserve">
          <source>(S) You compiled perl with &lt;b&gt;-D&lt;/b&gt;PERL_DEBUG_READONLY_OPS (see &lt;a href=&quot;perlhacktips&quot;&gt;perlhacktips&lt;/a&gt;), but a read-only op tree could not be made mutable before freeing the ops.</source>
          <target state="translated">당신은 펄과 함께 컴파일 (S) &lt;b&gt;-D&lt;/b&gt; PERL_DEBUG_READONLY_OPS (참조 &lt;a href=&quot;perlhacktips&quot;&gt;perlhacktips를&lt;/a&gt; )하지만, 읽기 전용 연산 트리가 작전을 해제하기 전에 변경 가능하게 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="061be05d42d3006ace944036e5366426a28c702c" translate="yes" xml:space="preserve">
          <source>(S) You compiled perl with &lt;b&gt;-D&lt;/b&gt;PERL_DEBUG_READONLY_OPS (see &lt;a href=&quot;perlhacktips&quot;&gt;perlhacktips&lt;/a&gt;), but an op tree could not be made read-only.</source>
          <target state="translated">당신은 펄과 함께 컴파일 (S) &lt;b&gt;-D&lt;/b&gt; PERL_DEBUG_READONLY_OPS (참조 &lt;a href=&quot;perlhacktips&quot;&gt;perlhacktips를&lt;/a&gt; )하지만, 영업 이익 트리를 만들 수 없습니다 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="c1fef223f2a1e28c0dc57c6acbeb950baf45e917" translate="yes" xml:space="preserve">
          <source>(S) exit() was called or the script otherwise finished gracefully when &lt;code&gt;PERL_EXIT_WARN&lt;/code&gt; was set in &lt;code&gt;PL_exit_flags&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;PERL_EXIT_WARN&lt;/code&gt; 에 PERL_EXIT_WARN 이 설정 되면 (S) exit ()가 호출되었거나 스크립트가 정상적으로 완료 &lt;code&gt;PL_exit_flags&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4004e755db0df1ce4f775dedbbb5d6e581d62ef" translate="yes" xml:space="preserve">
          <source>(See &lt;a href=&quot;#Package-specific-Attribute-Handling&quot;&gt;Package-specific Attribute Handling&lt;/a&gt; below.)</source>
          <target state="translated">아래 &lt;a href=&quot;#Package-specific-Attribute-Handling&quot;&gt;패키지 별 속성 처리를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="db2ebfc2e96e7bb52d5fa31d7dbcc56ffaa4bd84" translate="yes" xml:space="preserve">
          <source>(See &lt;a href=&quot;#autochomp&quot;&gt;autochomp&lt;/a&gt;, below.) Records stored into the array will have the record separator string appended before they are written to the file, if they don't have one already. For example, if the record separator string is &lt;code&gt;&quot;\n&quot;&lt;/code&gt; , then the following two lines do exactly the same thing:</source>
          <target state="translated">(아래의 &lt;a href=&quot;#autochomp&quot;&gt;autochomp를&lt;/a&gt; 참조하십시오 .) 배열에 저장된 레코드는 레코드 구분자가없는 경우 파일에 쓰기 전에 레코드 구분자 문자열이 추가됩니다. 예를 들어, 레코드 구분자 문자열이 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 인 경우 다음 두 줄은 정확히 동일한 기능을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="80430ec7983ecf81932712e8136d1fc6999e349e" translate="yes" xml:space="preserve">
          <source>(See &lt;a href=&quot;langtags/detect&quot;&gt;I18N::LangTags::Detect&lt;/a&gt;.)</source>
          <target state="translated">( &lt;a href=&quot;langtags/detect&quot;&gt;I18N :: LangTags :: Detect&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="9b4e95ed885a0ff41d39b669580f7f1627edc618" translate="yes" xml:space="preserve">
          <source>(See &lt;a href=&quot;perlguts#Background-and-PERL_IMPLICIT_CONTEXT&quot;&gt;Background and PERL_IMPLICIT_CONTEXT in perlguts&lt;/a&gt; for the explanation of the &lt;code&gt;aTHX_&lt;/code&gt; . ) Hiding the short forms is very useful for avoiding all sorts of nasty (C preprocessor or otherwise) conflicts with other software packages (Perl defines about 2400 APIs with these short names, take or leave few hundred, so there certainly is room for conflict.)</source>
          <target state="translated">(참조 &lt;a href=&quot;perlguts#Background-and-PERL_IMPLICIT_CONTEXT&quot;&gt;perlguts의 배경 및 PERL_IMPLICIT_CONTEXT을&lt;/a&gt; 의 설명에 대한 &lt;code&gt;aTHX_&lt;/code&gt; .) 짧은 형태를 숨기기 (C 프리 프로세서 또는 기타)이 짧은 이름 2400 개 API에 대한 다른 소프트웨어 패키지와의 충돌 (펄을 정의 불쾌한 모든 종류의를 피하기위한 매우 유용합니다, 몇 백을 가져 가거나 떠날 수 있으므로 분명히 갈등의 여지가 있습니다.)</target>
        </trans-unit>
        <trans-unit id="1b4d2cec47c211a6fd1862a5dc33ef6861851af3" translate="yes" xml:space="preserve">
          <source>(See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; for information about these.) When a Perl interpreter normally starts up, it tells the system it wants to use the system's default locale. This is often, but not necessarily, the &quot;C&quot; or &quot;POSIX&quot; locale. Absent a &lt;code&gt;&quot;use locale&quot;&lt;/code&gt; within the perl code, this mostly has no effect (but see &lt;a href=&quot;perllocale#Not-within-the-scope-of-%22use-locale%22&quot;&gt;Not within the scope of use locale in perllocale&lt;/a&gt;). Also, there is not a problem if the locale you want to use in your embedded Perl is the same as the system default. However, this doesn't work if you have set up and want to use a locale that isn't the system default one. Starting in Perl v5.20, you can tell the embedded Perl interpreter that the locale is already properly set up, and to skip doing its own normal initialization. It skips if the environment variable &lt;code&gt;PERL_SKIP_LOCALE_INIT&lt;/code&gt; is set (even if set to 0 or &lt;code&gt;&quot;&quot;&lt;/code&gt; ). A Perl that has this capability will define the C pre-processor symbol &lt;code&gt;HAS_SKIP_LOCALE_INIT&lt;/code&gt; . This allows code that has to work with multiple Perl versions to do some sort of work-around when confronted with an earlier Perl.</source>
          <target state="translated">이에 대한 정보는 &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; 을 참조하십시오 . Perl 인터프리터가 정상적으로 시작되면 시스템의 기본 로케일을 사용하도록 시스템에 지시합니다. 이것은 종종 &quot;C&quot;또는 &quot;POSIX&quot;로캘 일 필요는 없습니다. 없는 &lt;code&gt;&quot;use locale&quot;&lt;/code&gt; 이 주로 영향을주지 펄 코드 내를 (그러나 참조 &lt;a href=&quot;perllocale#Not-within-the-scope-of-%22use-locale%22&quot;&gt;perllocale에 사용되는 로케일의 범위 내에서되지 않음&lt;/a&gt; ). 또한 포함 된 Perl에서 사용하려는 로케일이 시스템 기본값과 동일하면 문제가 없습니다. 그러나 시스템 기본 로케일이 아닌 로케일을 설정하고 사용하려는 경우에는 작동하지 않습니다. Perl v5.20부터는 임베디드 Perl 인터프리터에 로케일이 이미 올바르게 설정되었음을 알리고 자체 일반 초기화를 건너 뛰도록 지시 할 수 있습니다.환경 변수 인 경우 건너 뜁니다 &lt;code&gt;PERL_SKIP_LOCALE_INIT&lt;/code&gt; 가 설정됩니다 (0 또는 &lt;code&gt;&quot;&quot;&lt;/code&gt; 로 설정되어 있어도 ). 이 기능이있는 Perl은 C 전 처리기 기호 &lt;code&gt;HAS_SKIP_LOCALE_INIT&lt;/code&gt; 를 정의합니다 . 따라서 여러 Perl 버전에서 작동해야하는 코드가 이전 Perl과 직면 할 때 일종의 해결 방법을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04211e27763477afa3d80fad7386d1113f8c29cc" translate="yes" xml:space="preserve">
          <source>(See &lt;a href=&quot;pullparser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt;)</source>
          <target state="translated">( &lt;a href=&quot;pullparser&quot;&gt;Pod :: Simple :: PullParser 참조&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="4435bcd44112f5a4c17ae8f6e10e4a3691dca5ef" translate="yes" xml:space="preserve">
          <source>(Since 15th century or so.)</source>
          <target state="translated">(15 세기 이후)</target>
        </trans-unit>
        <trans-unit id="b4d9f71359ebbc964034671e30ca00d3df8582af" translate="yes" xml:space="preserve">
          <source>(Since Perl 5.18.0) Set to &lt;code&gt;&quot;0&quot;&lt;/code&gt; or &lt;code&gt;&quot;NO&quot;&lt;/code&gt; then traversing keys will be repeatable from run to run for the same PERL_HASH_SEED. Insertion into a hash will not change the order, except to provide for more space in the hash. When combined with setting PERL_HASH_SEED this mode is as close to pre 5.18 behavior as you can get.</source>
          <target state="translated">(Perl 5.18.0부터) &lt;code&gt;&quot;0&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;NO&quot;&lt;/code&gt; 로 설정하면 동일한 PERL_HASH_SEED에 대해 이송 키를 반복해서 실행할 수 있습니다. 해시에 삽입해도 해시에 더 많은 공간을 제공하는 것을 제외하고 순서가 변경되지 않습니다. PERL_HASH_SEED 설정과 결합하면이 모드는 5.18 이전 동작과 거의 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="d2d2fe6a723bb51fba068c1135525897877a8e21" translate="yes" xml:space="preserve">
          <source>(Since Perl 5.8.1) Test whether</source>
          <target state="translated">(Perl 5.8.1 이후) 테스트 여부</target>
        </trans-unit>
        <trans-unit id="6850d529d135189d04f6ba7c3ffa3d4548be7012" translate="yes" xml:space="preserve">
          <source>(Since Perl 5.8.1, new semantics in Perl 5.18.0) Used to override the randomization of Perl's internal hash function. The value is expressed in hexadecimal, and may include a leading 0x. Truncated patterns are treated as though they are suffixed with sufficient 0's as required.</source>
          <target state="translated">(Perl 5.8.1부터 Perl 5.18.0의 새로운 의미론) Perl의 내부 해시 함수의 무작위 화를 대체하는 데 사용됩니다. 값은 16 진수로 표시되며 선행 0x를 포함 할 수 있습니다. 잘린 패턴은 필요한만큼 충분한 0으로 접미사처럼 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="d4dd6a4d9045a95dea822358826542693a655004" translate="yes" xml:space="preserve">
          <source>(Since Perl 5.8.1.) Set to &lt;code&gt;&quot;1&quot;&lt;/code&gt; to display (to STDERR) information about the hash function, seed, and what type of key traversal randomization is in effect at the beginning of execution. This, combined with &lt;a href=&quot;#PERL_HASH_SEED&quot;&gt;PERL_HASH_SEED&lt;/a&gt; and &lt;a href=&quot;#PERL_PERTURB_KEYS&quot;&gt;PERL_PERTURB_KEYS&lt;/a&gt; is intended to aid in debugging nondeterministic behaviour caused by hash randomization.</source>
          <target state="translated">(Perl 5.8.1부터) 해시 함수, 시드 및 실행시 어떤 키 순회 무작위 화 유형에 대한 정보를 STDERR에 표시 하려면 &lt;code&gt;&quot;1&quot;&lt;/code&gt; 로 설정하십시오 . 이것은 &lt;a href=&quot;#PERL_HASH_SEED&quot;&gt;PERL_HASH_SEED&lt;/a&gt; 및 &lt;a href=&quot;#PERL_PERTURB_KEYS&quot;&gt;PERL_PERTURB_KEYS&lt;/a&gt; 와 결합하여 해시 무작위 화로 인한 비 결정적 동작을 디버깅하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="ab21d8a997435eb71526870278e4ae754b59af69" translate="yes" xml:space="preserve">
          <source>(Since Perl v5.8.0) This is the inverse of &lt;code&gt;utf8::native_to_unicode()&lt;/code&gt; , converting the other direction. Again, on ASCII platforms, this returns its input, but on EBCDIC platforms it will find the native platform code point, given any Unicode one.</source>
          <target state="translated">(Perl v5.8.0부터) 이것은 다른 방향으로 변환하는 &lt;code&gt;utf8::native_to_unicode()&lt;/code&gt; 의 역입니다 . 다시 말하지만 ASCII 플랫폼에서는 입력을 반환하지만 EBCDIC 플랫폼에서는 유니 코드에 따라 기본 플랫폼 코드 포인트를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="9ebd6e76ec162df6aa89bf8250ce7d3b6b762192" translate="yes" xml:space="preserve">
          <source>(Since Perl v5.8.0) This takes an unsigned integer (which represents the ordinal number of a character (or a code point) on the platform the program is being run on) and returns its Unicode equivalent value. Since ASCII platforms natively use the Unicode code points, this function returns its input on them. On EBCDIC platforms it converts from EBCDIC to Unicode.</source>
          <target state="translated">(Perl v5.8.0부터) 부호없는 정수 (프로그램이 실행되는 플랫폼에서 문자 (또는 코드 포인트)의 서수를 나타냄)를 사용하여 해당하는 유니 코드 값을 리턴합니다. ASCII 플랫폼은 기본적으로 유니 코드 코드 포인트를 사용하므로이 함수는 입력을 리턴합니다. EBCDIC 플랫폼에서는 EBCDIC에서 유니 코드로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="686aa4c3b90d79d336d163445d2df93abf9a03d8" translate="yes" xml:space="preserve">
          <source>(Solaris) or -Wl,-rpath</source>
          <target state="translated">(Solaris) 또는 -Wl, -path</target>
        </trans-unit>
        <trans-unit id="627865a2c41acf779eb7c1e8aa654a6339214c81" translate="yes" xml:space="preserve">
          <source>(Some operating system distributions may ship the documentation in a different package; for instance, on Debian, you need to install the &lt;code&gt;perl-doc&lt;/code&gt; package.)</source>
          <target state="translated">(일부 운영 체제 배포판은 설명서를 다른 패키지로 제공 할 수 있습니다 (예 : 데비안에서는 &lt;code&gt;perl-doc&lt;/code&gt; 패키지 를 설치해야 함 ).</target>
        </trans-unit>
        <trans-unit id="45a289765e403549d26dee90a83e5678b32695d7" translate="yes" xml:space="preserve">
          <source>(Sometimes spelled</source>
          <target state="translated">(때로는 철자가</target>
        </trans-unit>
        <trans-unit id="55d6e60f7d30af9ac2ff51cca36afde92d7e6b9d" translate="yes" xml:space="preserve">
          <source>(That's Latin for 'warnings'.)</source>
          <target state="translated">( '경고'의 라틴어입니다.)</target>
        </trans-unit>
        <trans-unit id="9a5196ac2e2d06e81470d620bdd55bfb51d31a85" translate="yes" xml:space="preserve">
          <source>(That's all one line.) On my DEC Alpha running old 5.003_05, the incantation is a bit different:</source>
          <target state="translated">(이것은 모두 한 줄입니다.) 이전 5.003_05를 실행하는 DEC Alpha에서는 주문이 약간 다릅니다.</target>
        </trans-unit>
        <trans-unit id="a31a22e93d06d64611216361b6ec50e95eb2e83a" translate="yes" xml:space="preserve">
          <source>(That's currently the same as the following:)</source>
          <target state="translated">(현재 다음과 동일합니다.)</target>
        </trans-unit>
        <trans-unit id="a818127754cf465cce438d8d1ac91ea89b761e67" translate="yes" xml:space="preserve">
          <source>(The &quot;Is&quot; is optional.)</source>
          <target state="translated">&quot;Is&quot;는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="5d3c7b6c512461eb6e8ea369d1cdd236b63c6e3b" translate="yes" xml:space="preserve">
          <source>(The -T is here to prevent '.' from being listed in @INC.) They should all have their own documentation installed and accessible via your system man(1) command. If you do not have a &lt;b&gt;find&lt;/b&gt; program, you can use the Perl &lt;b&gt;find2perl&lt;/b&gt; program instead, which generates Perl code as output you can run through perl. If you have a &lt;b&gt;man&lt;/b&gt; program but it doesn't find your modules, you'll have to fix your manpath. See &lt;a href=&quot;perl&quot;&gt;perl&lt;/a&gt; for details. If you have no system &lt;b&gt;man&lt;/b&gt; command, you might try the &lt;b&gt;perldoc&lt;/b&gt; program.</source>
          <target state="translated">(-T는 @INC에 '.'가 나열되지 않도록하기 위해 여기에 있습니다.) 시스템 man (1) 명령을 통해 액세스 할 수있는 자체 설명서가 모두 있어야합니다. &lt;b&gt;찾기&lt;/b&gt; 프로그램 이없는 경우 대신 Perl &lt;b&gt;find2perl&lt;/b&gt; 프로그램을 사용하여 Perl 을 실행할 수있는 출력으로 Perl 코드를 생성 할 수 있습니다. 당신이있는 경우 &lt;b&gt;사람의&lt;/b&gt; 프로그램을하지만, 그것은 당신의 모듈을 찾을 수없는, 당신은 당신의 MANPATH를 해결해야합니다. 자세한 내용은 &lt;a href=&quot;perl&quot;&gt;perl&lt;/a&gt; 을 참조하십시오. system &lt;b&gt;man&lt;/b&gt; 명령 이 없으면 &lt;b&gt;perldoc&lt;/b&gt; 프로그램을 사용해보십시오 .</target>
        </trans-unit>
        <trans-unit id="6c56b22e726e42ab07cb80338d6020076bf1402f" translate="yes" xml:space="preserve">
          <source>(The PlatformSDKDir might need to be set differently depending on which version you are using. Earlier versions installed into &quot;C:\Program Files\Microsoft SDK&quot;, while the latest versions install into version-specific locations such as &quot;C:\Program Files\Microsoft Platform SDK for Windows Server 2003 R2&quot;.)</source>
          <target state="translated">사용중인 버전에 따라 PlatformSDKDir을 다르게 설정해야 할 수 있습니다. 이전 버전은 &quot;C : \ Program Files \ Microsoft SDK&quot;에 설치되어 있고 최신 버전은 &quot;C : \ Program Files와 같은 버전 별 위치에 설치됩니다. \ Windows Server 2003 R2 용 Microsoft 플랫폼 SDK &quot;).</target>
        </trans-unit>
        <trans-unit id="e0d1d182df0efff18f3c4b3ee696c544779c1b65" translate="yes" xml:space="preserve">
          <source>(The Yao in Malawi?)</source>
          <target state="translated">(말라위의 야오?)</target>
        </trans-unit>
        <trans-unit id="46fd0a21a0514730ee8dd0dce9c85d26b5a8396b" translate="yes" xml:space="preserve">
          <source>(The above documents supersede the collection of tricks that was formerly here in perlbot.)</source>
          <target state="translated">(위의 문서는 이전에 perlbot에서 사용했던 트릭 모음보다 우선합니다.)</target>
        </trans-unit>
        <trans-unit id="2d90a272ac545d8fb2fb65b0295acc24c14af7c1" translate="yes" xml:space="preserve">
          <source>(The above documents supersede the information that was formerly here in perlrepository.)</source>
          <target state="translated">(위의 문서는 이전에 perlrepository에 있었던 정보를 대체합니다.)</target>
        </trans-unit>
        <trans-unit id="99f2a233e4c798964e569888563b25720555e0bf" translate="yes" xml:space="preserve">
          <source>(The above documents supersede the tutorial that was formerly here in perlboot.)</source>
          <target state="translated">(위의 문서는 이전에 perlboot에 있었던 튜토리얼보다 우선합니다.)</target>
        </trans-unit>
        <trans-unit id="ffa134634092fd33228ce058a5ecf5685892879a" translate="yes" xml:space="preserve">
          <source>(The above documents supersede the tutorial that was formerly here in perltooc.)</source>
          <target state="translated">(위의 문서는 이전에 perltooc에 있었던 튜토리얼보다 우선합니다.)</target>
        </trans-unit>
        <trans-unit id="b8b48603f0c74c71b900d4a70be0c98f6b666085" translate="yes" xml:space="preserve">
          <source>(The above documents supersede the tutorial that was formerly here in perltoot.)</source>
          <target state="translated">(위의 문서는 이전에 perltoot에 있었던 자습서보다 우선합니다.)</target>
        </trans-unit>
        <trans-unit id="6c281b7ab089adf36f04b2a437ddf9ecf2800401" translate="yes" xml:space="preserve">
          <source>(The above were numbered only for concise reference below. It is not a requirement that these be passed as an actual list or array.)</source>
          <target state="translated">위의 내용은 아래의 간결한 참조 용으로 만 번호가 매겨져 있습니다. 실제 목록이나 배열로 전달할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="3c03be67d17d8a8bcdeda5d2a4ee5f01b74e7c60" translate="yes" xml:space="preserve">
          <source>(The clumsy construction of the template can be avoided - just read on!)</source>
          <target state="translated">(템플릿의 서투른 구성을 피할 수 있습니다-계속 읽으십시오!)</target>
        </trans-unit>
        <trans-unit id="3719d4816b107705fe6b77df25c501df533b77b2" translate="yes" xml:space="preserve">
          <source>(The dlclose() function is also used by Solaris and some versions of Linux, and is a common choice when providing a &quot;wrapper&quot; on other mechanisms as is done in the OS/2 port.)</source>
          <target state="translated">(dlclose () 함수는 Solaris 및 일부 Linux 버전에서도 사용되며 OS / 2 포트에서 수행되는 다른 메커니즘에서 &quot;래퍼&quot;를 제공 할 때 일반적으로 선택됩니다.)</target>
        </trans-unit>
        <trans-unit id="c51756c3454baa6c808057b69e36bc1ddf49b5cd" translate="yes" xml:space="preserve">
          <source>(The dlopen() function is also used by Solaris and some versions of Linux, and is a common choice when providing a &quot;wrapper&quot; on other mechanisms as is done in the OS/2 port.)</source>
          <target state="translated">(dlopen () 함수는 Solaris 및 일부 Linux 버전에서도 사용되며 OS / 2 포트에서 수행되는 다른 메커니즘에서 &quot;래퍼&quot;를 제공 할 때 일반적으로 선택됩니다.)</target>
        </trans-unit>
        <trans-unit id="e5b81b358edb613bfabb11ad57fbe83ee3c278d5" translate="yes" xml:space="preserve">
          <source>(The epoch was at 00:00 January 1, 1970 GMT.)</source>
          <target state="translated">(신기원은 1970 년 1 월 1 일 00:00시였습니다.)</target>
        </trans-unit>
        <trans-unit id="ddc748efe6e0366098cb313badf4a4144f645dbb" translate="yes" xml:space="preserve">
          <source>(The following is a comprehensive reference to open(): for a gentler introduction you may consider &lt;a href=&quot;../perlopentut&quot;&gt;perlopentut&lt;/a&gt;.)</source>
          <target state="translated">(다음은 open ()에 대한 포괄적 인 참조입니다.보다 부드러운 소개를 위해 &lt;a href=&quot;../perlopentut&quot;&gt;perlopentut을&lt;/a&gt; 고려할 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="60da63d4ac98227f92f63c3e5cc4b7d4c01a3ac4" translate="yes" xml:space="preserve">
          <source>(The following is a comprehensive reference to open(): for a gentler introduction you may consider &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt;.)</source>
          <target state="translated">(다음은 open ()에 대한 포괄적 인 참조입니다.보다 부드러운 소개를 위해 &lt;a href=&quot;perlopentut&quot;&gt;perlopentut을&lt;/a&gt; 고려할 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="322a993a4a3f05f774083a52bcad3313b4b5636a" translate="yes" xml:space="preserve">
          <source>(The following section is borrowed directly from Tim Bunce's modules file, available at your nearest CPAN site.)</source>
          <target state="translated">(다음 섹션은 가장 가까운 CPAN 사이트에있는 Tim Bunce의 모듈 파일에서 직접 차용됩니다.)</target>
        </trans-unit>
        <trans-unit id="d3f429143d25c69a6917c8263dc5caaea3b147cc" translate="yes" xml:space="preserve">
          <source>(The low level &quot;unix&quot; layer may be replaced by a platform specific low level layer.)</source>
          <target state="translated">하위 레벨 &quot;유닉스&quot;계층은 플랫폼 별 하위 레벨 계층으로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcd55cbdbab500567a14d4fb3999bcd145af54d6" translate="yes" xml:space="preserve">
          <source>(The my_perl is for threaded builds.) Just remember that every line, but the last one, should end with \n\</source>
          <target state="translated">(my_perl은 스레드 빌드 용입니다.) 마지막 줄을 제외한 모든 줄은 \ n \로 끝나야합니다.</target>
        </trans-unit>
        <trans-unit id="106619cccc96405763b2a52f9f0b9652d1b77415" translate="yes" xml:space="preserve">
          <source>(The only time that Perl considers a sequence of individual code points as a single logical character is in the &lt;code&gt;\X&lt;/code&gt; construct, already mentioned above. Therefore &quot;character&quot; in this discussion means a single Unicode code point.)</source>
          <target state="translated">Perl이 개별 코드 포인트 시퀀스를 단일 논리 문자로 간주하는 유일한 시간은 이미 언급 한 &lt;code&gt;\X&lt;/code&gt; 구문에 있습니다. 따라서이 설명에서 &quot;문자&quot;는 단일 유니 코드 코드 포인트를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="bead9ab0d2789e23ce7946c1d5b982dfb5f2f0b7" translate="yes" xml:space="preserve">
          <source>(The second line creates a scalar which has both a string value, and a numeric value.) This prints:</source>
          <target state="translated">두 번째 줄은 문자열 값과 숫자 값을 모두 갖는 스칼라를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="dab919d3d01857133900354c7413bb583680fe89" translate="yes" xml:space="preserve">
          <source>(The way &lt;code&gt;&lt;a href=&quot;functions/study&quot;&gt;study&lt;/a&gt;&lt;/code&gt; works is this: a linked list of every character in the string to be searched is made, so we know, for example, where all the &lt;code&gt;'k'&lt;/code&gt; characters are. From each search string, the rarest character is selected, based on some static frequency tables constructed from some C programs and English text. Only those places that contain this &quot;rarest&quot; character are examined.)</source>
          <target state="translated">( &lt;code&gt;&lt;a href=&quot;functions/study&quot;&gt;study&lt;/a&gt;&lt;/code&gt; 작동 하는 방식 은 다음과 같습니다 : 검색 할 문자열의 모든 문자의 링크 된 목록이 만들어 지므로 예를 들어 모든 &lt;code&gt;'k'&lt;/code&gt; 문자가 있는 위치를 알 수 있습니다. 각 검색 문자열에서 가장 희귀 한 문자가 선택됩니다. 일부 C 프로그램과 영어 텍스트로 구성된 일부 정적 빈도 테이블을 기반으로합니다.이 &quot;래 스트&quot;문자가 포함 된 장소 만 검사합니다.)</target>
        </trans-unit>
        <trans-unit id="7ced848246a1f04fd36e4acde8058f5a24044623" translate="yes" xml:space="preserve">
          <source>(The way &lt;code&gt;&lt;a href=&quot;study&quot;&gt;study&lt;/a&gt;&lt;/code&gt; works is this: a linked list of every character in the string to be searched is made, so we know, for example, where all the &lt;code&gt;'k'&lt;/code&gt; characters are. From each search string, the rarest character is selected, based on some static frequency tables constructed from some C programs and English text. Only those places that contain this &quot;rarest&quot; character are examined.)</source>
          <target state="translated">( &lt;code&gt;&lt;a href=&quot;study&quot;&gt;study&lt;/a&gt;&lt;/code&gt; 작동 하는 방식 은 다음과 같습니다 : 검색 할 문자열의 모든 문자의 링크 된 목록이 만들어 지므로 예를 들어 모든 &lt;code&gt;'k'&lt;/code&gt; 문자가 있는 위치를 알 수 있습니다. 각 검색 문자열에서 가장 희귀 한 문자가 선택됩니다. 일부 C 프로그램과 영어 텍스트로 구성된 일부 정적 빈도 테이블을 기반으로합니다.이 &quot;래 스트&quot;문자가 포함 된 장소 만 검사합니다.)</target>
        </trans-unit>
        <trans-unit id="5b09b65f3d7615d9c8998b10512e61c03475522f" translate="yes" xml:space="preserve">
          <source>(There are other regexp modifiers that are available, such as &lt;code&gt;//o&lt;/code&gt; , but their specialized uses are beyond the scope of this introduction. )</source>
          <target state="translated">&lt;code&gt;//o&lt;/code&gt; 와 같이 사용 가능한 다른 정규식 수정자가 있지만 해당 전문 용도는이 소개에서 다루지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ef674054c4d10d9749658409ad9f36c9cb9aa7a4" translate="yes" xml:space="preserve">
          <source>(There is an expanded internal form that you may see in debug output: &lt;code&gt;\N{U+&lt;i&gt;code point&lt;/i&gt;.&lt;i&gt;code point&lt;/i&gt;...}&lt;/code&gt;. The &lt;code&gt;...&lt;/code&gt; means any number of these</source>
          <target state="translated">(디버그 출력에서 볼 수 있다는 확장 된 내부 형식이 있습니다 : &lt;code&gt;\N{U+&lt;i&gt;code point&lt;/i&gt;.&lt;i&gt;code point&lt;/i&gt;...}&lt;/code&gt; .는 &lt;code&gt;...&lt;/code&gt; 이들의 수를 의미</target>
        </trans-unit>
        <trans-unit id="0cef4c08315032515ea7f0175f7b08a2c8696b06" translate="yes" xml:space="preserve">
          <source>(There is no entry in the Latin1 column for &lt;code&gt;isascii&lt;/code&gt; even though there is an &lt;code&gt;isASCII_L1&lt;/code&gt; , which is identical to &lt;code&gt;isASCII&lt;/code&gt; ; the latter name is clearer. There is no entry in the Latin1 column for &lt;code&gt;toupper&lt;/code&gt; because the result can be non-Latin1. You have to use &lt;code&gt;toUPPER_uni&lt;/code&gt; , as described in &lt;a href=&quot;perlapi#Character-case-changing&quot;&gt;Character case changing in perlapi&lt;/a&gt;.)</source>
          <target state="translated">(의 라틴어 컬럼에 항목이 없습니다 &lt;code&gt;isascii&lt;/code&gt; 이 생길 경우에도 &lt;code&gt;isASCII_L1&lt;/code&gt; 동일, &lt;code&gt;isASCII&lt;/code&gt; , 후자 이름이 명확를위한 라틴 컬럼에 항목이 없습니다. &lt;code&gt;toupper&lt;/code&gt; 결과가 비 라틴 수 있기 때문에 당신. &lt;code&gt;toUPPER_uni&lt;/code&gt; 에서 &lt;a href=&quot;perlapi#Character-case-changing&quot;&gt;문자 대소 문자 변경에&lt;/a&gt; 설명 된대로 toUPPER_uni 를 사용해야 합니다.)</target>
        </trans-unit>
        <trans-unit id="1ab73e0519c8fdd4854befdfbc4691ec376d1901" translate="yes" xml:space="preserve">
          <source>(These instructions assume the host is 32-bit Windows. If you're on 64-bit Windows then change &quot;C:\Program Files&quot; to &quot;C:\Program Files (x86)&quot; throughout.)</source>
          <target state="translated">(이 지침은 호스트가 32 비트 Windows라고 가정합니다. 64 비트 Windows를 사용하는 경우 &quot;C : \ Program Files&quot;를 &quot;C : \ Program Files (x86)&quot;로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="0284748ff040695be7f487fe1427820b8ae1d9fc" translate="yes" xml:space="preserve">
          <source>(This is an advanced feature. Skip this section on first reading.)</source>
          <target state="translated">(이것은 고급 기능입니다. 처음 읽을 때는이 섹션을 건너 뛰십시오.)</target>
        </trans-unit>
        <trans-unit id="d1f86c64c0fb13e1165ca2bb3cf75fd21929ca61" translate="yes" xml:space="preserve">
          <source>(This is meant to be somewhat like the AUTOLOAD mechanism in Perl's function call system -- or, looked at another way, like the &lt;a href=&quot;../autoloader&quot;&gt;AutoLoader&lt;/a&gt; module.)</source>
          <target state="translated">(이것은 Perl의 함수 호출 시스템에서 AUTOLOAD 메커니즘과 다소 비슷하거나 &lt;a href=&quot;../autoloader&quot;&gt;AutoLoader&lt;/a&gt; 모듈 과 같은 다른 방법을 고려한 것 입니다.)</target>
        </trans-unit>
        <trans-unit id="cdd641f1539ef2a67db69239bd635f29eb3affaa" translate="yes" xml:space="preserve">
          <source>(This is now used as a subroutine by &lt;code&gt;sv_magic&lt;/code&gt; .)</source>
          <target state="translated">(이제 &lt;code&gt;sv_magic&lt;/code&gt; 에서 서브 루틴으로 사용됩니다 .)</target>
        </trans-unit>
        <trans-unit id="450e46399e1dfa03e74a37b76c191403f7e21d97" translate="yes" xml:space="preserve">
          <source>(This is particularly useful for more complicated data).</source>
          <target state="translated">(이는보다 복잡한 데이터에 특히 유용합니다).</target>
        </trans-unit>
        <trans-unit id="c0bbb992fa49c3682d5cfd26de0a6cdfb574f0e9" translate="yes" xml:space="preserve">
          <source>(This is quite esoteric interface, mainly used to implement numerical algorithms.)</source>
          <target state="translated">(이것은 상당히 난해한 인터페이스이며 주로 숫자 알고리즘을 구현하는 데 사용됩니다.)</target>
        </trans-unit>
        <trans-unit id="b29c9a7ca2e6d2f17cba849bd676844ed769bc13" translate="yes" xml:space="preserve">
          <source>(This is the complete XSUB code for 4 Perl functions!) Four generated Perl function share names with corresponding C functions.</source>
          <target state="translated">(이것은 4 개의 Perl 기능을위한 완전한 XSUB 코드입니다!) 4 개의 생성 된 Perl 기능은 해당 C 기능과 이름을 공유합니다.</target>
        </trans-unit>
        <trans-unit id="318b9e91985ebdb387e65919c8ceba9d2529e396" translate="yes" xml:space="preserve">
          <source>(This is the same thing as &lt;code&gt;[ab]&lt;/code&gt; .) You could also have said the equivalent:</source>
          <target state="translated">( &lt;code&gt;[ab]&lt;/code&gt; 와 같은 내용입니다 .)</target>
        </trans-unit>
        <trans-unit id="1e6c29bd9b75523af99513437a45caa1e768cad7" translate="yes" xml:space="preserve">
          <source>(This method tolerates &quot;AUTHORS&quot; instead of &quot;AUTHOR&quot; too.)</source>
          <target state="translated">(이 방법은 &quot;AUTHOR&quot;대신 &quot;AUTHORS&quot;도 허용합니다.)</target>
        </trans-unit>
        <trans-unit id="78c00b9468e9dba0550ff01127712ff12d28b6f9" translate="yes" xml:space="preserve">
          <source>(This module's core code started out as a routine in Locale::Maketext; but I moved it here once I realized it was more generally useful.)</source>
          <target state="translated">(이 모듈의 핵심 코드는 Locale :: Maketext에서 루틴으로 시작되었지만 더 일반적으로 유용하다는 것을 알게되면 여기로 옮겼습니다.)</target>
        </trans-unit>
        <trans-unit id="1a99ed7428d19447b55d198902918f9e8b4e92a8" translate="yes" xml:space="preserve">
          <source>(This question has nothing to do with the web. See a different FAQ for that.)</source>
          <target state="translated">(이 질문은 웹과 관련이 없습니다. 다른 FAQ를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="304b79906abb30b9dbd694d6901d36565f2ab06d" translate="yes" xml:space="preserve">
          <source>(This start line assumes you have the &lt;b&gt;env&lt;/b&gt; program. You can also put directly the path to your perl executable, like in &lt;code&gt;#!/usr/bin/perl&lt;/code&gt; ).</source>
          <target state="translated">(이 시작 줄은 &lt;b&gt;env&lt;/b&gt; 프로그램 이 있다고 가정합니다 . &lt;code&gt;#!/usr/bin/perl&lt;/code&gt; 과 같이 perl 실행 파일의 경로를 직접 넣을 수도 있습니다 ).</target>
        </trans-unit>
        <trans-unit id="c152a09f07eb9dbb0b701130511a2596b2120e15" translate="yes" xml:space="preserve">
          <source>(This will show as &quot;0.01&quot; in the Symbian Installer.)</source>
          <target state="translated">(Symbian 설치 프로그램에서 &quot;0.01&quot;로 표시됩니다.)</target>
        </trans-unit>
        <trans-unit id="bb4dfbdc156e8445e31beb38de229226c0082c90" translate="yes" xml:space="preserve">
          <source>(This works on machines only for which the device number is negative under NFS.)</source>
          <target state="translated">(이것은 NFS에서 장치 번호가 음수 인 시스템에서만 작동합니다.)</target>
        </trans-unit>
        <trans-unit id="13dfc15518eb94aba08b31ffe0fd3f4ae70409fd" translate="yes" xml:space="preserve">
          <source>(Those options are explained in &lt;a href=&quot;../man&quot;&gt;Pod::Man&lt;/a&gt;.)</source>
          <target state="translated">이러한 옵션은 &lt;a href=&quot;../man&quot;&gt;Pod :: Man에&lt;/a&gt; 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b61a3df860851afb8d19a9abbcf256db93652f70" translate="yes" xml:space="preserve">
          <source>(Thread comparison is based on thread IDs.)</source>
          <target state="translated">스레드 비교는 스레드 ID를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="17f7280a5bad35910c7f0b307524105ba8ca95ba" translate="yes" xml:space="preserve">
          <source>(Typically in Arabic script) (Historical)</source>
          <target state="translated">(일반적으로 아랍어 스크립트) (역사)</target>
        </trans-unit>
        <trans-unit id="1283ec6ec06063d7e56b0b05c2d76ce925324026" translate="yes" xml:space="preserve">
          <source>(Typically in Roman script)</source>
          <target state="translated">(일반적으로 로마 문자)</target>
        </trans-unit>
        <trans-unit id="c7d55cf94c18a95511562bd57f04605173efed9a" translate="yes" xml:space="preserve">
          <source>(Unicode is also creating &lt;code&gt;CLDR&lt;/code&gt; , the &quot;Common Locale Data Repository&quot;, &lt;a href=&quot;http://cldr.unicode.org/&quot;&gt;http://cldr.unicode.org/&lt;/a&gt; which includes more types of information than are available in the POSIX locale system. At the time of this writing, there was no CPAN module that provides access to this XML-encoded data. However, many of its locales have the POSIX-only data extracted, and are available as UTF-8 locales at &lt;a href=&quot;http://unicode.org/Public/cldr/latest/&quot;&gt;http://unicode.org/Public/cldr/latest/&lt;/a&gt;.)</source>
          <target state="translated">(유니 코드도 생성되어 &lt;code&gt;CLDR&lt;/code&gt; 은 &quot;공통 로케일 데이터 저장소&quot;, &lt;a href=&quot;http://cldr.unicode.org/&quot;&gt;http://cldr.unicode.org/&lt;/a&gt; 는 POSIX 로케일 시스템에서 사용할 수있는 것보다 더 많은 정보 유형이 포함됩니다.이 글을 쓰는 시점에서, 어떤 없었다 이 XML 인코딩 데이터에 대한 액세스를 제공하는 CPAN 모듈이지만 많은 로케일에는 POSIX 전용 데이터가 추출되어 있으며 &lt;a href=&quot;http://unicode.org/Public/cldr/latest/&quot;&gt;http://unicode.org/Public/cldr/latest/&lt;/a&gt; 에서 UTF-8 로케일로 사용 가능합니다 . )</target>
        </trans-unit>
        <trans-unit id="0e08710827ea0d15fd7e296378d20798650f0348" translate="yes" xml:space="preserve">
          <source>(Usually the layers are identical on either side of a filehandle but for example with sockets there may be differences, or if you have been using the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma.)</source>
          <target state="translated">(일반적으로 레이어는 파일 핸들의 양쪽에서 동일하지만 소켓의 경우와 같이 차이가 있거나 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 프라그 마를 사용하는 경우 레이어가 동일합니다 .)</target>
        </trans-unit>
        <trans-unit id="1b63c10d2b8ed03b7bef283f8b978c67f239a105" translate="yes" xml:space="preserve">
          <source>(W ambiguous) A subroutine you have declared has the same name as a Perl keyword, and you have used the name without qualification for calling one or the other. Perl decided to call the builtin because the subroutine is not imported.</source>
          <target state="translated">(모호한) 선언 한 서브 루틴의 이름은 Perl 키워드와 동일하며, 호출하지 않아도 이름을 사용했습니다. Perl은 서브 루틴을 가져 오지 않아 내장을 호출하기로 결정했습니다.</target>
        </trans-unit>
        <trans-unit id="ec602e75e96a29c94e711379b8e06128d6720d2b" translate="yes" xml:space="preserve">
          <source>(W ambiguous) You said something like '@foo' in a double-quoted string but there was no array &lt;code&gt;@foo&lt;/code&gt; in scope at the time. If you wanted a literal @foo, then write it as \@foo; otherwise find out what happened to the array you apparently lost track of.</source>
          <target state="translated">큰 따옴표로 묶인 문자열에서 '@foo'와 같은 것을 말했지만 당시에는 범위에 &lt;code&gt;@foo&lt;/code&gt; 배열이 없었 습니다. 리터럴 @foo를 원하면 \ @foo로 작성하십시오. 그렇지 않으면 분명히 잃어버린 배열에 무슨 일이 있었는지 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="079495cf90b2c60d4ebdf405dac80f71d10905d4" translate="yes" xml:space="preserve">
          <source>(W ambiguous) You said something like &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/$\/&lt;/a&gt;&lt;/code&gt; in a regex. The regex &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/foo$\s+bar/m&lt;/a&gt;&lt;/code&gt; translates to: match the word 'foo', the output record separator (see &lt;a href=&quot;perlvar#%24%5c&quot;&gt;$\ in perlvar&lt;/a&gt;) and the letter 's' (one time or more) followed by the word 'bar'.</source>
          <target state="translated">(W 애매 모호한) 당신은 정규 표현식에서 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/$\/&lt;/a&gt;&lt;/code&gt; 같은 것을 말했습니다 . 정규식 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/foo$\s+bar/m&lt;/a&gt;&lt;/code&gt; 은 다음 단어를 번역합니다 : 단어 'foo', 출력 레코드 구분 기호 ( &lt;a href=&quot;perlvar#%24%5c&quot;&gt;perlvar의 $ \&lt;/a&gt; 참조 ) 및 문자 's'(한 번 이상) 다음에 ' 바'.</target>
        </trans-unit>
        <trans-unit id="4b8760477957c4a179ee08cd792db91cf0a281a0" translate="yes" xml:space="preserve">
          <source>(W ambiguous) You wrote something like &lt;code&gt;${foo[2]}&lt;/code&gt; (where foo represents the name of a Perl keyword), which might be looking for element number 2 of the array named &lt;code&gt;@foo&lt;/code&gt; , in which case please write &lt;code&gt;$foo[2]&lt;/code&gt; , or you might have meant to pass an anonymous arrayref to the function named foo, and then do a scalar deref on the value it returns. If you meant that, write &lt;code&gt;${foo([2])}&lt;/code&gt; .</source>
          <target state="translated">(모호합니다) &lt;code&gt;${foo[2]}&lt;/code&gt; (여기서 foo는 펄 키워드의 이름을 나타냄) 와 같은 것을 썼습니다. &lt;code&gt;@foo&lt;/code&gt; 라는 배열의 요소 번호 2를 찾고있을 수 있습니다 .이 경우 &lt;code&gt;$foo[2]&lt;/code&gt; 또는 익명의 arrayref를 foo라는 함수에 전달한 다음 반환되는 값에 대해 스칼라 deref를 수행해야합니다. 그런 의미라면 &lt;code&gt;${foo([2])}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="084dca53c4497f5660abbcf6441688c678ff8a7d" translate="yes" xml:space="preserve">
          <source>(W ambiguous) You wrote something like &lt;code&gt;@{foo}&lt;/code&gt; , which might be asking for the variable &lt;code&gt;@foo&lt;/code&gt; , or it might be calling a function named foo, and dereferencing it as an array reference. If you wanted the variable, you can just write &lt;code&gt;@foo&lt;/code&gt; . If you wanted to call the function, write &lt;code&gt;@{foo()}&lt;/code&gt; ... or you could just not have a variable and a function with the same name, and save yourself a lot of trouble.</source>
          <target state="translated">&lt;code&gt;@foo&lt;/code&gt; 변수를 요청 하거나 foo라는 함수를 호출하여 배열 참조로 역 참조하는 &lt;code&gt;@{foo}&lt;/code&gt; 와 같은 것을 작성 했습니다. 변수를 원한다면 &lt;code&gt;@foo&lt;/code&gt; 만 쓸 수 있습니다 . 함수를 호출하려면 &lt;code&gt;@{foo()}&lt;/code&gt; ...를 쓰십시오 . 그렇지 않으면 같은 이름의 변수와 함수를 가질 수 없으며 많은 문제를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14fd4d715f9a8018aaf51fde0ef01572c3a9a9b2" translate="yes" xml:space="preserve">
          <source>(W bareword) The compiler found a bareword where it expected a conditional, which often indicates that an || or &amp;amp;&amp;amp; was parsed as part of the last argument of the previous construct, for example:</source>
          <target state="translated">(W 베어 워드) 컴파일러는 조건부로 예상되는 베어 워드를 찾았습니다. 이는 종종 || 또는 &amp;amp;&amp;amp;는 이전 구문의 마지막 인수의 일부로 구문 분석되었습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0a75679f869cf803abbe9139fba47c479e66224b" translate="yes" xml:space="preserve">
          <source>(W bareword) You used a qualified bareword of the form &lt;code&gt;Foo::&lt;/code&gt; , but the compiler saw no other uses of that namespace before that point. Perhaps you need to predeclare a package?</source>
          <target state="translated">(W bareword) &lt;code&gt;Foo::&lt;/code&gt; 형식의 정규화 된 베어 워드를 사용 했지만 컴파일러는 그 시점 이전에 해당 네임 스페이스를 다른 용도로 사용하지 않았습니다. 패키지를 미리 선언해야합니까?</target>
        </trans-unit>
        <trans-unit id="53e1259f36617bd490deac8aa3d40862151e6ec1" translate="yes" xml:space="preserve">
          <source>(W closed) The filehandle you're attempting to flock() got itself closed some time before now. Check your control flow. flock() operates on filehandles. Are you attempting to call flock() on a dirhandle by the same name?</source>
          <target state="translated">(W closed) flock ()하려는 파일 핸들이 얼마 전에 닫혔습니다. 제어 흐름을 확인하십시오. flock ()은 파일 핸들에서 작동합니다. 같은 이름으로 dirhandle에서 flock ()을 호출하려고합니까?</target>
        </trans-unit>
        <trans-unit id="4d43ddfded45ebfd41dbbaee3290b1b238857a1d" translate="yes" xml:space="preserve">
          <source>(W closed) The filehandle you're printing on got itself closed sometime before now. Check your control flow.</source>
          <target state="translated">(W closed) 당신이 인쇄하고있는 파일 핸들은 얼마 전에 닫혔습니다. 제어 흐름을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="6a4b270026fc2a66bf1429d325a9c5f91b820999" translate="yes" xml:space="preserve">
          <source>(W closed) The filehandle you're reading from got itself closed sometime before now. Check your control flow.</source>
          <target state="translated">(W closed) 당신이 읽고있는 파일 핸들이 지금 막 언젠가 닫혔습니다. 제어 흐름을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="9024fe0f51607b2265a19aadf35a4c761bd88088" translate="yes" xml:space="preserve">
          <source>(W closed) The filehandle you're writing to got itself closed sometime before now. Check your control flow.</source>
          <target state="translated">(W closed) 당신이 작성하고있는 파일 핸들은 전에 언젠가 닫혔습니다. 제어 흐름을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="cc80a0a86bde9f9811deb2b4047a08d7c517bb7e" translate="yes" xml:space="preserve">
          <source>(W closed) The socket you're sending to got itself closed sometime before now. Check your control flow.</source>
          <target state="translated">(W closed) 당신이 보내고 자하는 소켓은 얼마 전에 닫혔습니다. 제어 흐름을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="7aec4135b79438ad14c3a964c4630183be1a1b09" translate="yes" xml:space="preserve">
          <source>(W closed) You tried to do a bind on a closed socket. Did you forget to check the return value of your socket() call? See &lt;a href=&quot;functions/bind&quot;&gt;bind&lt;/a&gt;.</source>
          <target state="translated">(W closed) 닫힌 소켓에서 바인드를 시도했습니다. socket () 호출의 반환 값을 확인하는 것을 잊었습니까? &lt;a href=&quot;functions/bind&quot;&gt;bind를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a483bc728ce89a356e49e93e25f177a39d0d0bd2" translate="yes" xml:space="preserve">
          <source>(W closed) You tried to do a connect on a closed socket. Did you forget to check the return value of your socket() call? See &lt;a href=&quot;functions/connect&quot;&gt;connect&lt;/a&gt;.</source>
          <target state="translated">(W 닫힘) 닫힌 소켓에서 연결을 시도했습니다. socket () 호출의 반환 값을 확인하는 것을 잊었습니까? &lt;a href=&quot;functions/connect&quot;&gt;connect를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="34608223004dc77e87fe9381938e96c7cf955ac4" translate="yes" xml:space="preserve">
          <source>(W closed) You tried to do a listen on a closed socket. Did you forget to check the return value of your socket() call? See &lt;a href=&quot;functions/listen&quot;&gt;listen&lt;/a&gt;.</source>
          <target state="translated">(W closed) 닫힌 소켓에서 청취하려고했습니다. socket () 호출의 반환 값을 확인하는 것을 잊었습니까? 관련 항목 &lt;a href=&quot;functions/listen&quot;&gt;들을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="71ee5dae4e8472748b97847b021b00dd16e56c28" translate="yes" xml:space="preserve">
          <source>(W closed) You tried to do a shutdown on a closed socket. Seems a bit superfluous.</source>
          <target state="translated">(W closed) 닫힌 소켓에서 시스템 종료를 시도했습니다. 약간 불필요한 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="b0a054724012ff7380cc3bd3fbabe4c0f3adab15" translate="yes" xml:space="preserve">
          <source>(W closed) You tried to do an accept on a closed socket. Did you forget to check the return value of your socket() call? See &lt;a href=&quot;functions/accept&quot;&gt;accept&lt;/a&gt;.</source>
          <target state="translated">(W 폐쇄) 폐쇄 소켓에서 승인을 시도했습니다. socket () 호출의 반환 값을 확인하는 것을 잊었습니까? &lt;a href=&quot;functions/accept&quot;&gt;수락을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="686780402dcd5189e3de84bbbe7e8c3675a26cd5" translate="yes" xml:space="preserve">
          <source>(W closed) You tried to get a socket option on a closed socket. Did you forget to check the return value of your socket() call? See &lt;a href=&quot;functions/getsockopt&quot;&gt;getsockopt&lt;/a&gt;.</source>
          <target state="translated">(W closed) 닫힌 소켓에서 소켓 옵션을 얻으려고했습니다. socket () 호출의 반환 값을 확인하는 것을 잊었습니까? &lt;a href=&quot;functions/getsockopt&quot;&gt;getsockopt를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b5f3fe4ba1c0a3fcc1fd82dbadf8c0a68a06899b" translate="yes" xml:space="preserve">
          <source>(W closed) You tried to get a socket or peer socket name on a closed socket. Did you forget to check the return value of your socket() call?</source>
          <target state="translated">(W closed) 닫힌 소켓에서 소켓 또는 피어 소켓 이름을 얻으려고했습니다. socket () 호출의 반환 값을 확인하는 것을 잊었습니까?</target>
        </trans-unit>
        <trans-unit id="9dd893f13813e0686f88d28dcaa995ea58eff6c6" translate="yes" xml:space="preserve">
          <source>(W closed) You tried to read from a closed filehandle.</source>
          <target state="translated">(W closed) 닫힌 파일 핸들에서 읽으려고했습니다.</target>
        </trans-unit>
        <trans-unit id="b1bc9bc2878143204e9bd4f8c5b8ef8fc1a1d196" translate="yes" xml:space="preserve">
          <source>(W closed) You tried to set a socket option on a closed socket. Did you forget to check the return value of your socket() call? See &lt;a href=&quot;functions/setsockopt&quot;&gt;setsockopt&lt;/a&gt;.</source>
          <target state="translated">(W closed) 닫힌 소켓에 소켓 옵션을 설정하려고했습니다. socket () 호출의 반환 값을 확인하는 것을 잊었습니까? &lt;a href=&quot;functions/setsockopt&quot;&gt;setsockopt를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6691ea148e323c92640a7e1d8e12d6db9b140e15" translate="yes" xml:space="preserve">
          <source>(W closure) An inner (nested)</source>
          <target state="translated">(W 잠금) 내부 (중첩)</target>
        </trans-unit>
        <trans-unit id="ac28de0cbad4c4dfc31aa274d0d0826540c4608a" translate="yes" xml:space="preserve">
          <source>(W closure) During compilation, an inner named subroutine or eval is attempting to capture an outer lexical subroutine that is not currently available. This can happen for one of two reasons. First, the lexical subroutine may be declared in an outer anonymous subroutine that has not yet been created. (Remember that named subs are created at compile time, while anonymous subs are created at run-time.) For example,</source>
          <target state="translated">(W 클로저) 컴파일 중에 이름 지정된 서브 루틴 또는 eval이 현재 사용할 수없는 외부 어휘 서브 루틴을 캡처하려고합니다. 이것은 두 가지 이유 중 하나로 발생할 수 있습니다. 먼저, 어휘 서브 루틴은 아직 작성되지 않은 외부 익명 서브 루틴에서 선언 될 수 있습니다. 명명 된 하위는 컴파일 타임에 생성되고 익명 하위는 런타임에 생성됩니다. 예를 들어,</target>
        </trans-unit>
        <trans-unit id="65c019298a1444d38d91fcf17700dfd268f80742" translate="yes" xml:space="preserve">
          <source>(W closure) During compilation, an inner named subroutine or eval is attempting to capture an outer lexical that is not currently available. This can happen for one of two reasons. First, the outer lexical may be declared in an outer anonymous subroutine that has not yet been created. (Remember that named subs are created at compile time, while anonymous subs are created at run-time.) For example,</source>
          <target state="translated">(W 클로저) 컴파일 중에 이름 지정된 서브 루틴 또는 eval이 현재 사용할 수없는 외부 어휘를 캡처하려고합니다. 이것은 두 가지 이유 중 하나로 발생할 수 있습니다. 먼저, 외부 어휘는 아직 작성되지 않은 외부 익명 서브 루틴에서 선언 될 수 있습니다. 명명 된 하위는 컴파일 타임에 생성되고 익명 하위는 런타임에 생성됩니다. 예를 들어,</target>
        </trans-unit>
        <trans-unit id="f49f3db25d97d6915960909beefeac21238b6f2d" translate="yes" xml:space="preserve">
          <source>(W digit) In parsing an octal numeric constant, a character was unexpectedly encountered that isn't octal. The resulting value is as indicated.</source>
          <target state="translated">(W 숫자) 8 진 숫자 상수를 구문 분석 할 때 8 진수가 아닌 문자가 예기치 않게 발생했습니다. 결과 값은 표시된대로입니다.</target>
        </trans-unit>
        <trans-unit id="5e57358e7c1ec969e817e54f1e65d4d60ed6b951" translate="yes" xml:space="preserve">
          <source>(W digit) You may have tried to use a character other than 0 - 9 or A - F, a - f in a hexadecimal number. Interpretation of the hexadecimal number stopped before the illegal character.</source>
          <target state="translated">(W 숫자) 16 진수로 0-9 또는 A-F 이외의 문자를 사용하려고 시도했을 수 있습니다. 16 진수 숫자의 해석이 잘못된 문자 앞에 멈췄습니다.</target>
        </trans-unit>
        <trans-unit id="00a4e0b3bbab633922e651c73c2306c40de05654" translate="yes" xml:space="preserve">
          <source>(W digit) You may have tried to use a digit other than 0 or 1 in a binary number. Interpretation of the binary number stopped before the offending digit.</source>
          <target state="translated">(W 숫자) 이진수로 0 또는 1 이외의 숫자를 사용하려고 시도했을 수 있습니다. 이진수의 해석은 문제가되는 숫자보다 먼저 중지되었습니다.</target>
        </trans-unit>
        <trans-unit id="84e6efe8b571226f1c56d898f3595c47df2fa3d9" translate="yes" xml:space="preserve">
          <source>(W digit) You may have tried to use an 8 or 9 in an octal number. Interpretation of the octal number stopped before the 8 or 9.</source>
          <target state="translated">(W 숫자) 8 진수로 8 또는 9를 사용하려고 시도했을 수 있습니다. 8 진수의 해석은 8 또는 9 이전에 중지되었습니다.</target>
        </trans-unit>
        <trans-unit id="9fb9a032a154ac7b59a268710cf1949bc22fb256" translate="yes" xml:space="preserve">
          <source>(W exec) A system(), exec(), or piped open call could not execute the named program for the indicated reason. Typical reasons include: the permissions were wrong on the file, the file wasn't found in &lt;code&gt;$ENV{PATH}&lt;/code&gt; , the executable in question was compiled for another architecture, or the #! line in a script points to an interpreter that can't be run for similar reasons. (Or maybe your system doesn't support #! at all.)</source>
          <target state="translated">(W exec) system (), exec () 또는 파이프 열린 호출이 표시된 이유로 지정된 프로그램을 실행할 수 없습니다. 일반적인 이유는 다음과 같습니다. 파일에 대한 권한이 잘못 되었거나 &lt;code&gt;$ENV{PATH}&lt;/code&gt; 에 파일이 없거나 문제의 실행 파일이 다른 아키텍처 또는 #! 스크립트의 라인은 비슷한 이유로 실행할 수없는 인터프리터를 가리 킵니다. (또는 시스템이 #!를 전혀 지원하지 않을 수도 있습니다.)</target>
        </trans-unit>
        <trans-unit id="40cf81f6b21e33cf0de9e73eab5064b147112369" translate="yes" xml:space="preserve">
          <source>(W exec) A warning peculiar to VMS. Waitpid() was asked to wait for a process which isn't a subprocess of the current process. While this is fine from VMS' perspective, it's probably not what you intended.</source>
          <target state="translated">(W exec) VMS 고유의 경고입니다. Waitpid ()는 현재 프로세스의 서브 프로세스가 아닌 프로세스를 기다리라는 요청을 받았습니다. 이것은 VMS의 관점에서는 문제가 없지만 의도 한 것은 아닐 것입니다.</target>
        </trans-unit>
        <trans-unit id="0ee5ddf7eeab37551318e6033433b97f7d5d48d1" translate="yes" xml:space="preserve">
          <source>(W exec) You did an exec() with some statement after it other than a die(). This is almost always an error, because exec() never returns unless there was a failure. You probably wanted to use system() instead, which does return. To suppress this warning, put the exec() in a block by itself.</source>
          <target state="translated">(W exec) die ()가 아닌 다른 명령문 뒤에 exec ()를 수행했습니다. exec ()는 실패하지 않는 한 반환하지 않기 때문에 이것은 거의 항상 오류입니다. 대신 system ()을 사용하고 싶을 수도 있습니다. 이 경고를 표시하지 않으려면 exec () 자체를 블록에 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="278e1a884eb3739698a7e8956cfbb36c8f5f87f4" translate="yes" xml:space="preserve">
          <source>(W exiting) You are exiting a format by unconventional means, such as a goto, or a loop control statement.</source>
          <target state="translated">(W 종료) goto 또는 루프 제어문과 같은 비 전통적인 방법으로 형식을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="67609a2a97401f2b99b78611043cd7f013a46fee" translate="yes" xml:space="preserve">
          <source>(W exiting) You are exiting a rather special block construct (like a sort block or subroutine) by unconventional means, such as a goto, or a loop control statement. See &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;.</source>
          <target state="translated">(W 종료) goto 또는 루프 제어문과 같은 비 전통적인 수단을 사용하여 다소 특수한 블록 구성 (예 : 정렬 블록 또는 서브 루틴)을 종료합니다. &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="423b0191e4cbf769af53341d336458806707caeb" translate="yes" xml:space="preserve">
          <source>(W exiting) You are exiting a subroutine by unconventional means, such as a goto, or a loop control statement.</source>
          <target state="translated">(W 종료) goto 또는 루프 제어문과 같은 비 전통적인 수단으로 서브 루틴을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="577ddf9c905e4347f8a9edb4c94bb3d05b393883" translate="yes" xml:space="preserve">
          <source>(W exiting) You are exiting a substitution by unconventional means, such as a return, a goto, or a loop control statement.</source>
          <target state="translated">(W 종료) 리턴, 이동 또는 루프 제어문과 같은 비 전통적인 수단으로 대체를 종료합니다.</target>
        </trans-unit>
        <trans-unit id="635b5ef261a420bb3046d7f8e4b7a552abb9ebd2" translate="yes" xml:space="preserve">
          <source>(W exiting) You are exiting an eval by unconventional means, such as a goto, or a loop control statement.</source>
          <target state="translated">(W 종료) goto 또는 루프 제어문과 같은 비 전통적인 수단으로 평가를 종료합니다.</target>
        </trans-unit>
        <trans-unit id="61f27ff7875edb61784c966ef6d387cd6a2988db" translate="yes" xml:space="preserve">
          <source>(W illegalproto) A character follows % or @ in a prototype. This is useless, since % and @ gobble the rest of the subroutine arguments.</source>
          <target state="translated">(W illegalproto) 프로토 타입에서 문자는 % 또는 @를 따릅니다. %와 @는 나머지 서브 루틴 인수를 뒤섞기 때문에 이것은 쓸모가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c9ffd9aa561f3b86a313e40b450bfafd500921a5" translate="yes" xml:space="preserve">
          <source>(W illegalproto) A grouping was started with &lt;code&gt;[&lt;/code&gt; but never closed with &lt;code&gt;]&lt;/code&gt;.</source>
          <target state="translated">(W illegalproto) 그룹화가 &lt;code&gt;[&lt;/code&gt; 와 함께 시작 되었지만 결코 종료되지 않았습니다 &lt;code&gt;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6112a30e9d70cd7305832f9bcd92076f9f034086" translate="yes" xml:space="preserve">
          <source>(W illegalproto) An illegal character was found in a prototype declaration. Legal characters in prototypes are $, @, %, *, ;, [, ], &amp;amp;, \, and +. Perhaps you were trying to write a subroutine signature but didn't enable that feature first (&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'signatures'&lt;/code&gt; ), so your signature was instead interpreted as a bad prototype.</source>
          <target state="translated">(W illegalproto) 프로토 타입 선언에서 잘못된 문자가 발견되었습니다. 프로토 타입의 유효한 문자는 $, @, %, *,;, [,], &amp;amp;, \ 및 +입니다. 아마 당신은 서브 루틴 서명을 작성하려고했다하지만 첫 번째 (이 기능을 사용하지 않도록 설정 한 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'signatures'&lt;/code&gt; 서명 대신 나쁜 프로토 타입으로 해석 그래서,).</target>
        </trans-unit>
        <trans-unit id="1db9799c8c1e3509096b870feae3fbef0c02c544" translate="yes" xml:space="preserve">
          <source>(W illegalproto) An illegal character was found in a prototype declaration. The '_' in a prototype must be followed by a ';', indicating the rest of the parameters are optional, or one of '@' or '%', since those two will accept 0 or more final parameters.</source>
          <target state="translated">(W illegalproto) 프로토 타입 선언에서 잘못된 문자가 발견되었습니다. 프로토 타입의 '_'뒤에는 ';'이 와야합니다. 나머지 매개 변수는 선택 사항이거나 '@'또는 '%'중 하나를 나타내는데,이 두 개는 0 개 이상의 최종 매개 변수를 허용하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="c7fd43abca207918c5fc4cdbdfec0cb27e79feb6" translate="yes" xml:space="preserve">
          <source>(W imprecision) The value you attempted to increment or decrement by one is too large for the underlying floating point representation to store accurately, hence the target of &lt;code&gt;++&lt;/code&gt; or &lt;code&gt;--&lt;/code&gt; is unchanged. Perl issues this warning because it has already switched from integers to floating point when values are too large for integers, and now even floating point is insufficient. You may wish to switch to using &lt;a href=&quot;math/bigint&quot;&gt;Math::BigInt&lt;/a&gt; explicitly.</source>
          <target state="translated">(W 부정확도) 1 씩 증가 또는 감소 시키려고 시도한 값이 기본 부동 소수점 표현이 정확하게 저장하기에 너무 커서 &lt;code&gt;++&lt;/code&gt; 또는 &lt;code&gt;--&lt;/code&gt; 의 목표 는 변경되지 않습니다. Perl은 정수에 대해 값이 너무 클 때 정수에서 부동 소수점으로 이미 전환되어 현재 부동 소수점조차도 충분하지 않기 때문에이 경고를 발행합니다. &lt;a href=&quot;math/bigint&quot;&gt;Math :: BigInt를&lt;/a&gt; 명시 적으로 사용하도록 전환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0380d4e9c21d75260f15f61e0e8d75fffecf52b7" translate="yes" xml:space="preserve">
          <source>(W internal) A warning peculiar to VMS. Perl tried to read a logical name or CLI symbol definition when preparing to iterate over %ENV, and didn't see the expected delimiter between key and value, so the line was ignored.</source>
          <target state="translated">(W 내부) VMS 고유의 경고입니다. Perl은 % ENV를 반복 할 준비를 할 때 논리 이름 또는 CLI 기호 정의를 읽으려고했으나 키와 값 사이에 예상되는 구분 기호를 찾지 못해 행이 무시되었습니다.</target>
        </trans-unit>
        <trans-unit id="e0b79079d3e5d0700f6c79112c4f181694c27e32" translate="yes" xml:space="preserve">
          <source>(W internal) A warning peculiar to VMS. Perl tried to read the CRTL's internal environ array, and encountered an element without the &lt;code&gt;=&lt;/code&gt; delimiter used to separate keys from values. The element is ignored.</source>
          <target state="translated">(W 내부) VMS 고유의 경고입니다. Perl은 CRTL의 내부 환경 배열을 읽으려고했지만 키와 값을 구분하는 데 &lt;code&gt;=&lt;/code&gt; 구분 기호 가없는 요소를 발견했습니다 . 요소가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="587287ad8ceaf64ab8230f7bcf5670e31503bcc1" translate="yes" xml:space="preserve">
          <source>(W internal) A warning peculiar to VMS. While Perl was preparing to iterate over %ENV, it encountered a logical name or symbol definition which was too long, so it was truncated to the string shown.</source>
          <target state="translated">(W 내부) VMS 고유의 경고입니다. Perl이 % ENV를 반복 할 준비를하는 중에 논리 이름이나 기호 정의가 너무 길어서 표시된 문자열로 잘 렸습니다.</target>
        </trans-unit>
        <trans-unit id="36ebe0800de98cf6f1b5bf24a60713b3518a1d0b" translate="yes" xml:space="preserve">
          <source>(W internal) Warnings peculiar to VMS. You tried to change or delete an element of the CRTL's internal environ array, but your copy of Perl wasn't built with a CRTL that contained the setenv() function. You'll need to rebuild Perl with a CRTL that does, or redefine</source>
          <target state="translated">(W 내부) VMS에 고유 한 경고. CRTL의 내부 환경 배열 요소를 변경하거나 삭제하려고했지만 Perl 사본이 setenv () 함수가 포함 된 CRTL로 작성되지 않았습니다. CRTL을 사용하여 Perl을 다시 작성하거나 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="ef225bf78a4ffd17a5bb6a41738bbeb914a98db0" translate="yes" xml:space="preserve">
          <source>(W io) A filehandle represents an opened file, and when you opened the file it already went past any symlink you are presumably trying to look for. The operation returned &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. Use a filename instead.</source>
          <target state="translated">(W io) 파일 핸들은 열린 파일을 나타내며 파일을 열었을 때 이미 찾고있는 심볼릭 링크를 지나갔습니다. 작업이 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 리턴했습니다 . 대신 파일 이름을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ee0ffa3b5e5e88aa061e31df24e098e285623887" translate="yes" xml:space="preserve">
          <source>(W io) A single call to write() produced more lines than can fit on a page. See &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt;.</source>
          <target state="translated">(W io) write ()에 대한 단일 호출은 페이지에 맞는 것보다 많은 행을 생성했습니다. &lt;a href=&quot;perlform&quot;&gt;perlform을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3fae264d9cc122df4656cd9db14f53c587dced8a" translate="yes" xml:space="preserve">
          <source>(W io) The dirhandle you are doing a seekdir() on is either closed or not really a dirhandle. Check your control flow.</source>
          <target state="translated">seekdir ()을 수행하고있는 dirhandle이 닫혀 있거나 실제로 dirhandle이 아닙니다. 제어 흐름을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="4e5653964bb3ce999ffdd1f023f2acfeb0cb1b2b" translate="yes" xml:space="preserve">
          <source>(W io) The dirhandle you tried to close is either closed or not really a dirhandle. Check your control flow.</source>
          <target state="translated">(W io) 닫으려는 dirhandle이 닫히거나 실제로 dirhandle이 아닙니다. 제어 흐름을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="127a04276c120f78beaffbfc2313d45b73d1b33b" translate="yes" xml:space="preserve">
          <source>(W io) The dirhandle you tried to do a rewinddir() on is either closed or not really a dirhandle. Check your control flow.</source>
          <target state="translated">(window) rewinddir ()을 시도한 dirhandle이 닫히거나 실제로 dirhandle이 아닙니다. 제어 흐름을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="1d737035b8d4f24c62b1ff52cc5128d37b308243" translate="yes" xml:space="preserve">
          <source>(W io) The dirhandle you tried to telldir() is either closed or not really a dirhandle. Check your control flow.</source>
          <target state="translated">(dir) telldir ()하려고 시도한 dirhandle은 닫혀 있거나 실제로 dirhandle이 아닙니다. 제어 흐름을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="b257e2f649cabca0abfa99bff0088affded75975" translate="yes" xml:space="preserve">
          <source>(W io) The dirhandle you're reading from is either closed or not really a dirhandle. Check your control flow.</source>
          <target state="translated">(W io) 당신이 읽고있는 dirhandle은 닫혀 있거나 실제로 dirhandle이 아닙니다. 제어 흐름을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="cc52e3a1ee5048b6a45ffd6085a3f6b30e6d1327" translate="yes" xml:space="preserve">
          <source>(W io) You opened for reading a filehandle that got the same filehandle id as STDOUT or STDERR. This occurred because you closed STDOUT or STDERR previously.</source>
          <target state="translated">(W io) STDOUT 또는 STDERR과 동일한 파일 핸들 ID를 가진 파일 핸들을 읽기 위해 열었습니다. 이전에 STDOUT 또는 STDERR을 닫았 기 때문에 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="16c9c24089f7631f92df6e520f74b47f2a676640" translate="yes" xml:space="preserve">
          <source>(W io) You opened for writing a filehandle that got the same filehandle id as STDIN. This occurred because you closed STDIN previously.</source>
          <target state="translated">(W io) STDIN과 동일한 파일 핸들 ID를 가진 파일 핸들을 작성하기 위해 열었습니다. 이전에 STDIN을 닫았 기 때문에 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="48e33ef7ad3bda2c544d27c4a2b881dd4cce8a01" translate="yes" xml:space="preserve">
          <source>(W io) You tried to do an lstat on a filehandle. What did you mean by that? lstat() makes sense only on filenames. (Perl did a fstat() instead on the filehandle.)</source>
          <target state="translated">(W io) 파일 핸들에서 lstat를 시도했습니다. 그게 무슨 소리 니? lstat ()는 파일 이름에서만 의미가 있습니다. (펄은 파일 핸들에서 fstat ()를 대신했다.)</target>
        </trans-unit>
        <trans-unit id="324bb1ba42f01059dfedd40debd4b1a4374a4560" translate="yes" xml:space="preserve">
          <source>(W io) You tried to open a scalar reference for reading or writing, using the 3-arg open() syntax:</source>
          <target state="translated">(W io) 3-arg open () 구문을 사용하여 읽기 또는 쓰기를위한 스칼라 참조를 열려고했습니다.</target>
        </trans-unit>
        <trans-unit id="cd0af26043dd5c8a624dc3d3fd913fb0da71fce7" translate="yes" xml:space="preserve">
          <source>(W io) You tried to read from a filehandle opened only for writing, If you intended it to be a read/write filehandle, you needed to open it with &quot;+&amp;lt;&quot; or &quot;+&amp;gt;&quot; or &quot;+&amp;gt;&amp;gt;&quot; instead of with &quot;&amp;gt;&quot;. If you intended only to read from the file, use &quot;&amp;lt;&quot;. See &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;. Another possibility is that you attempted to open filedescriptor 0 (also known as STDIN) for output (maybe you closed STDIN earlier?).</source>
          <target state="translated">(W io) 쓰기 전용으로 열린 파일 핸들에서 읽으려고했습니다. 읽기 / 쓰기 파일 핸들로 사용하려는 경우 대신 &quot;+ &amp;lt;&quot;또는 &quot;+&amp;gt;&quot;또는 &quot;+ &amp;gt;&amp;gt;&quot;로 열어야합니다. &quot;&amp;gt;&quot;와 함께 파일에서 읽기만하려면 &quot;&amp;lt;&quot;를 사용하십시오. &lt;a href=&quot;functions/open&quot;&gt;open을&lt;/a&gt; 참조하십시오 . 또 다른 가능성은 출력을 위해 파일 디스크립터 0 (STDIN이라고도 함)을 열려고 시도했을 수 있습니다 (STDIN을 일찍 닫았을 수 있습니까?).</target>
        </trans-unit>
        <trans-unit id="8be59eeb719b1de30aae260c360f6b5c60cae180" translate="yes" xml:space="preserve">
          <source>(W io) You tried to write on a read-only filehandle. If you intended it to be a read-write filehandle, you needed to open it with &quot;+&amp;lt;&quot; or &quot;+&amp;gt;&quot; or &quot;+&amp;gt;&amp;gt;&quot; instead of with &quot;&amp;lt;&quot; or nothing. If you intended only to write the file, use &quot;&amp;gt;&quot; or &quot;&amp;gt;&amp;gt;&quot;. See &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;.</source>
          <target state="translated">(W io) 읽기 전용 파일 핸들에 쓰려고했습니다. 파일을 읽기 / 쓰기 파일 핸들로 사용하려는 경우 &quot;&amp;lt;&quot;대신 &quot;+ &amp;lt;&quot;또는 &quot;+&amp;gt;&quot;또는 &quot;+ &amp;gt;&amp;gt;&quot;로 열어야합니다. 파일 만 쓰려는 경우 &quot;&amp;gt;&quot;또는 &quot;&amp;gt;&amp;gt;&quot;를 사용하십시오. &lt;a href=&quot;functions/open&quot;&gt;open을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="968ea45fb72fa2c7bd5bcdf03ea7400fdcd81829" translate="yes" xml:space="preserve">
          <source>(W layer) An attempt was made to push an unknown layer onto the Perl I/O system. (Layers take care of transforming data between external and internal representations.) Note that some layers, such as &lt;code&gt;mmap&lt;/code&gt; , are not supported in all environments. If your program didn't explicitly request the failing operation, it may be the result of the value of the environment variable PERLIO.</source>
          <target state="translated">(W 레이어) 알 수없는 레이어를 Perl I / O 시스템에 푸시하려고했습니다. 레이어는 외부 표현과 내부 표현 간의 데이터 변환을 처리합니다. &lt;code&gt;mmap&lt;/code&gt; 과 같은 일부 레이어 는 모든 환경에서 지원되는 것은 아닙니다. 프로그램이 실패한 조작을 명시 적으로 요청하지 않은 경우 환경 변수 PERLIO의 결과 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c622eaff4edeef916a3a7c575dcd4f69353b85c" translate="yes" xml:space="preserve">
          <source>(W layer) When pushing a layer with arguments onto the Perl I/O system you forgot the ) that closes the argument list. (Layers take care of transforming data between external and internal representations.) Perl stopped parsing the layer list at this point and did not attempt to push this layer. If your program didn't explicitly request the failing operation, it may be the result of the value of the environment variable PERLIO.</source>
          <target state="translated">(W 계층) 인수가있는 계층을 Perl I / O 시스템에 푸시 할 때 인수 목록을 닫는)을 잊어 버렸습니다. (레이어는 외부 표현과 내부 표현 간의 데이터 변환을 처리합니다.) Perl은이 시점에서 레이어 목록 구문 분석을 중지하고이 레이어를 푸시하려고 시도하지 않았습니다. 프로그램이 실패한 조작을 명시 적으로 요청하지 않은 경우 환경 변수 PERLIO 값의 결과 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecde0fdfd45c81bcf2a4145082dc4dd084cab4f1" translate="yes" xml:space="preserve">
          <source>(W layer) When pushing layers onto the Perl I/O system, something other than a colon or whitespace was seen between the elements of a layer list. If the previous attribute had a parenthesised parameter list, perhaps that list was terminated too soon.</source>
          <target state="translated">(W 레이어) Perl I / O 시스템으로 레이어를 푸시 할 때 레이어 목록의 요소 사이에 콜론이나 공백 이외의 것이 나타납니다. 이전 속성에 괄호로 묶은 매개 변수 목록이있는 경우 해당 목록이 너무 빨리 종료되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b99a80d131d19e28dda9041e25eeb2f1f73775f2" translate="yes" xml:space="preserve">
          <source>(W locale) While in a single-byte locale (</source>
          <target state="translated">(W 로케일) 1 바이트 로케일 (</target>
        </trans-unit>
        <trans-unit id="0d7aae5004e480ec270f51ea7824d1434b43e076" translate="yes" xml:space="preserve">
          <source>(W locale) You are 1) running under &quot;&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; &quot;; 2) the current locale is not a UTF-8 one; 3) you tried to do the designated case-change operation on the specified Unicode character; and 4) the result of this operation would mix Unicode and locale rules, which likely conflict. Mixing of different rule types is forbidden, so the operation was not done; instead the result is the indicated value, which is the best available that uses entirely Unicode rules. That turns out to almost always be the original character, unchanged.</source>
          <target state="translated">(W 로케일) 1) &quot; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; &quot; 에서 실행 중입니다 . 2) 현재 로케일이 UTF-8이 아닙니다. 3) 지정된 유니 코드 문자에 대해 지정된 대 / 소문자 변경 작업을 시도했습니다. 4)이 작업의 결과는 유니 코드와 로캘 규칙을 혼합하여 충돌 할 수 있습니다. 다른 규칙 유형의 혼합은 금지되어 있으므로 작업이 수행되지 않았습니다. 대신 결과는 표시된 값이며, 이는 완전히 유니 코드 규칙을 사용하는 최상의 값입니다. 거의 항상 원래의 캐릭터로 바뀌지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="9445c5833b7363d2fe4ae697fde2f870ddf47e7a" translate="yes" xml:space="preserve">
          <source>(W locale) You are matching a regular expression using locale rules, and a Unicode boundary is being matched, but the locale is not a Unicode one. This doesn't make sense. Perl will continue, assuming a Unicode (UTF-8) locale, but the results could well be wrong except if the locale happens to be ISO-8859-1 (Latin1) where this message is spurious and can be ignored.</source>
          <target state="translated">(W 로케일) 로케일 규칙을 사용하여 정규식을 일치 시키며 유니 코드 경계가 일치하지만 로케일이 유니 코드가 아닙니다. 이것은 말이되지 않습니다. Perl은 유니 코드 (UTF-8) 로케일을 가정하여 계속 진행하지만 로케일이 ISO-8859-1 (Latin1) 인 경우를 제외하고는 결과가 잘못 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02905fbf32b02f6a8ace973ce43a92893403bf4f" translate="yes" xml:space="preserve">
          <source>(W locale) You are using the named locale, which is a non-UTF-8 one, and which perl has determined is not fully compatible with what it can handle. The second &lt;code&gt;%s&lt;/code&gt; gives a reason.</source>
          <target state="translated">(W 로케일) UTF-8이 아닌 로케일이라는 이름이 지정된 로케일을 사용하고 있으며 perl이 처리 할 수있는 것과 완전히 호환되지 않는다고 판별했습니다. 두 번째 &lt;code&gt;%s&lt;/code&gt; 가 이유를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="03a33e2bd2daeb7394c123da8d1823f81a6f6a4f" translate="yes" xml:space="preserve">
          <source>(W misc) A &quot;my&quot; or &quot;state&quot; subroutine has been redeclared in the current scope or statement, effectively eliminating all access to the previous instance. This is almost always a typographical error. Note that the earlier subroutine will still exist until the end of the scope or until all closure references to it are destroyed.</source>
          <target state="translated">(W misc) &quot;my&quot;또는 &quot;state&quot;서브 루틴이 현재 범위 또는 명령문에서 다시 선언되어 이전 인스턴스에 대한 모든 액세스를 효과적으로 제거합니다. 이것은 거의 항상 인쇄상의 오류입니다. 이전 서브 루틴은 스코프가 끝날 때까지 또는 모든 클로저 참조가 파괴 될 때까지 계속 존재합니다.</target>
        </trans-unit>
        <trans-unit id="bbd888a8b12a9c45d7e56a1c333e4c20223eff1c" translate="yes" xml:space="preserve">
          <source>(W misc) A &quot;my&quot;, &quot;our&quot; or &quot;state&quot; variable has been redeclared in the current scope or statement, effectively eliminating all access to the previous instance. This is almost always a typographical error. Note that the earlier variable will still exist until the end of the scope or until all closure references to it are destroyed.</source>
          <target state="translated">(W misc) &quot;my&quot;, &quot;our&quot;또는 &quot;state&quot;변수는 현재 범위 또는 명령문에서 다시 선언되어 이전 인스턴스에 대한 모든 액세스를 효과적으로 제거합니다. 이것은 거의 항상 인쇄상의 오류입니다. 이전 변수는 범위가 끝날 때까지 또는 변수에 대한 모든 클로저 참조가 소멸 될 때까지 계속 존재합니다.</target>
        </trans-unit>
        <trans-unit id="0a437454e4e59c0c63ef790ff1715aba9f133c24" translate="yes" xml:space="preserve">
          <source>(W misc) A number has been passed as a bitmask argument to select(). Use the vec() function to construct the file descriptor bitmasks for select. See &lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;.</source>
          <target state="translated">(W misc) 숫자가 select ()에 비트 마스크 인수로 전달되었습니다. vec () 함수를 사용하여 선택을위한 파일 디스크립터 비트 마스크를 구성하십시오. &lt;a href=&quot;functions/select&quot;&gt;select를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0c94ce8244014ff24661c0ca75a55652169dcad2" translate="yes" xml:space="preserve">
          <source>(W misc) A sub was declared as sub foo : prototype(A) : prototype(B) {}, for example. Since each sub can only have one prototype, the earlier declaration(s) are discarded while the last one is applied.</source>
          <target state="translated">(W misc) 서브는 예를 들어 sub foo : prototype (A) : prototype (B) {}로 선언되었습니다. 각 서브는 하나의 프로토 타입 만 가질 수 있으므로 이전 선언은 적용되는 동안 이전 선언은 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="217c15d1789f3525b24856092f3f9184fdbf896a" translate="yes" xml:space="preserve">
          <source>(W misc) A warning peculiar to VMS. Perl tried to read the value of an %ENV element from a CLI symbol table, and found a resultant string longer than 1024 characters. The return value has been truncated to 1024 characters.</source>
          <target state="translated">(W misc) VMS 특유의 경고. Perl은 CLI 기호 테이블에서 % ENV 요소의 값을 읽으려고했으나 1024 자보다 긴 결과 문자열을 찾았습니다. 리턴 값이 1024 자로 잘 렸습니다.</target>
        </trans-unit>
        <trans-unit id="dd11fcb880f23ae872f44fc2e5336ede26ae40f1" translate="yes" xml:space="preserve">
          <source>(W misc) Although &lt;a href=&quot;attributes&quot;&gt;attributes.pm&lt;/a&gt; allows this, turning the lvalue attribute on or off on a Perl subroutine that is already defined does not always work properly. It may or may not do what you want, depending on what code is inside the subroutine, with exact details subject to change between Perl versions. Only do this if you really know what you are doing.</source>
          <target state="translated">(W misc) &lt;a href=&quot;attributes&quot;&gt;attributes.pm&lt;/a&gt; 이이를 허용 하지만 이미 정의 된 Perl 서브 루틴에서 lvalue 속성을 켜거나 끄는 것이 항상 제대로 작동하지는 않습니다. 서브 루틴 안에있는 코드에 따라 원하는 내용을 수행 할 수도 있고하지 않을 수도 있습니다. 자세한 내용은 Perl 버전간에 변경 될 수 있습니다. 실제로하고있는 일을 알고있는 경우에만이 작업을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="0776898ec0630aa335d5aaa8eb564217544bbcdc" translate="yes" xml:space="preserve">
          <source>(W misc) An undefined value was assigned to a typeglob, a la &lt;code&gt;*foo = &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . This does nothing. It's possible that you really mean &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; *foo&lt;/code&gt; .</source>
          <target state="translated">(W misc) 정의되지 않은 값이 typeglob에 할당되었습니다 (la &lt;code&gt;*foo = &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . 이것은 아무것도하지 않습니다. 실제로 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; *foo&lt;/code&gt; 의미 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="12437cd31e238da3b2ced4a2306fbe6e5acf5a48" translate="yes" xml:space="preserve">
          <source>(W misc) In a conditional expression, you used &amp;lt;HANDLE&amp;gt;, &amp;lt;*&amp;gt; (glob), &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; as a boolean value. Each of these constructs can return a value of &quot;0&quot;; that would make the conditional expression false, which is probably not what you intended. When using these constructs in conditional expressions, test their values with the &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">(W misc) 조건식에서 &amp;lt;HANDLE&amp;gt;, &amp;lt;*&amp;gt; (glob), &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; 을 부울 값으로 사용했습니다. 이러한 각 구문은 &quot;0&quot;값을 반환 할 수 있습니다. 그것은 조건식을 거짓으로 만들 것입니다. 아마 당신이 의도 한 것이 아닙니다. 조건식에서 이러한 구문을 사용할 때는 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 연산자로 해당 값을 테스트하십시오 .</target>
        </trans-unit>
        <trans-unit id="20059d974af22a8333d150a247e06378d470385d" translate="yes" xml:space="preserve">
          <source>(W misc) Remember that &quot;our&quot; does not localize the declared global variable. You have declared it again in the same lexical scope, which seems superfluous.</source>
          <target state="translated">(W misc) &quot;우리&quot;는 선언 된 전역 변수를 현지화하지 않습니다. 동일한 어휘 범위에서 다시 선언했는데, 불필요한 것으로 보입니다.</target>
        </trans-unit>
        <trans-unit id="5844b97950c2a1072e2ddb5f148dc77415c11973" translate="yes" xml:space="preserve">
          <source>(W misc) The &quot;const&quot; attribute has no effect except on anonymous closure prototypes. You applied it to a subroutine via &lt;a href=&quot;attributes&quot;&gt;attributes.pm&lt;/a&gt;. This is only useful inside an attribute handler for an anonymous subroutine.</source>
          <target state="translated">(W misc) &quot;const&quot;속성은 익명 클로저 프로토 타입을 제외하고는 영향을 미치지 않습니다. &lt;a href=&quot;attributes&quot;&gt;attributes.pm을&lt;/a&gt; 통해 서브 루틴에 적용했습니다. . 이것은 익명 서브 루틴에 대한 속성 핸들러 내에서만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="83ab71cdca9ba1d83ceb17577950410c9f6f3fff" translate="yes" xml:space="preserve">
          <source>(W misc) The pattern match (&lt;code&gt;//&lt;/code&gt; ), substitution (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;), and transliteration (&lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;) operators work on scalar values. If you apply one of them to an array or a hash, it will convert the array or hash to a scalar value (the length of an array, or the population info of a hash) and then work on that scalar value. This is probably not what you meant to do. See &lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt; and &lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt; for alternatives.</source>
          <target state="translated">(W misc) 패턴 일치 ( &lt;code&gt;//&lt;/code&gt; ), 치환 ( &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; ) 및 음역 ( &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; ) 연산자는 스칼라 값에서 작동합니다. 이 중 하나를 배열 또는 해시에 적용하면 배열 또는 해시를 스칼라 값 (배열 길이 또는 해시의 모집단 정보)으로 변환 한 다음 해당 스칼라 값에서 작동합니다. 이것은 아마도 당신이하려는 의도가 아닙니다. &lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt; 및 &lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt; 참조대안 을 .</target>
        </trans-unit>
        <trans-unit id="a6cb938b0a50f702bbe4e1a83af4f783e4f29b59" translate="yes" xml:space="preserve">
          <source>(W misc) The version string contains invalid characters at the end, which are being ignored.</source>
          <target state="translated">(W misc) 버전 문자열 끝에 잘못된 문자가 포함되어 있으며 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="1ac1e31d222cc4c0e5cec20c46a1416397109637" translate="yes" xml:space="preserve">
          <source>(W misc) This prefix usually indicates that a DESTROY() method raised the indicated exception. Since destructors are usually called by the system at arbitrary points during execution, and often a vast number of times, the warning is issued only once for any number of failures that would otherwise result in the same message being repeated.</source>
          <target state="translated">(W misc)이 접두사는 일반적으로 DESTROY () 메소드가 표시된 예외를 발생 시켰음을 나타냅니다. 소멸자는 일반적으로 실행 중에 임의의 지점에서 시스템에 의해 호출되기 때문에 종종 여러 번 호출되기 때문에 동일한 메시지가 반복되는 여러 번의 실패에 대해 경고가 한 번만 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="5c525d33b2f6cbb2cbaccf27a61558723ac97f2a" translate="yes" xml:space="preserve">
          <source>(W misc) Using the &lt;code&gt;:lvalue&lt;/code&gt; declarative syntax to make a Perl subroutine an lvalue subroutine after it has been defined is not permitted. To make the subroutine an lvalue subroutine, add the lvalue attribute to the definition, or put the &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;
foo :lvalue;&lt;/code&gt; declaration before the definition.</source>
          <target state="translated">(W misc) &lt;code&gt;:lvalue&lt;/code&gt; 선언 구문을 사용하여 Perl 서브 루틴을 정의 된 후 lvalue 서브 루틴으로 만드는 것은 허용되지 않습니다. 서브 루틴을 lvalue 서브 루틴으로 만들려면 lvalue 속성을 정의에 추가하거나 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; foo :lvalue;&lt;/code&gt; 정의 전의 선언.</target>
        </trans-unit>
        <trans-unit id="d7bb17126e54088f85c3c0ce7c1c0e874c4e1d14" translate="yes" xml:space="preserve">
          <source>(W misc) You are blessing a reference to a zero length string. This has the effect of blessing the reference into the package main. This is usually not what you want. Consider providing a default target package, e.g. bless($ref, $p || 'MyPackage');</source>
          <target state="translated">(W misc) 길이가 0 인 문자열에 대한 참조를 축복하고 있습니다. 이것은 패키지 메인에 대한 참조를 축복하는 효과가 있습니다. 이것은 일반적으로 원하는 것이 아닙니다. 기본 대상 패키지를 제공하십시오 (예 : bless ($ ref, $ p || 'MyPackage')).</target>
        </trans-unit>
        <trans-unit id="ed823eb758d423a401df73e799d2788b33feee1c" translate="yes" xml:space="preserve">
          <source>(W misc) You assigned to an lvalue subroutine, but what the subroutine returned was a temporary scalar about to be discarded, so the assignment had no effect.</source>
          <target state="translated">(W misc) lvalue 서브 루틴에 할당했지만 서브 루틴이 리턴 한 것은 버려 질 임시 스칼라이므로 할당이 적용되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="9b9202be79ef7c790da62232dde7b953dc21d5a6" translate="yes" xml:space="preserve">
          <source>(W misc) You attempted to specify an offset that was past the end of the array passed to splice(). Splicing will instead commence at the end of the array, rather than past it. If this isn't what you want, try explicitly pre-extending the array by assigning $#array = $offset. See &lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;.</source>
          <target state="translated">(W misc) splice ()에 전달 된 배열의 끝을 지난 오프셋을 지정하려고했습니다. 스 플라이 싱은 대신 어레이의 끝에서 시작하지 않고 시작됩니다. 이것이 원하는 것이 아닌 경우 $ # array = $ offset을 할당하여 명시 적으로 배열을 미리 확장 해보십시오. &lt;a href=&quot;functions/splice&quot;&gt;스플 라이스&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="e97344ac072c36fa30be5354dedbaf9a30a0a229" translate="yes" xml:space="preserve">
          <source>(W misc) You gave a single reference where Perl was expecting a list with an even number of elements (for assignment to a hash). This usually means that you used the anon hash constructor when you meant to use parens. In any case, a hash requires key/value &lt;b&gt;pairs&lt;/b&gt;.</source>
          <target state="translated">(W misc) Perl이 (해시에 할당하기 위해) 짝수 개의 요소가있는 목록을 기대하는 단일 참조를 제공했습니다. 이것은 일반적으로 parens를 사용할 때 anon hash 생성자를 사용했음을 의미합니다. 어쨌든 해시는 키 / 값 &lt;b&gt;쌍이&lt;/b&gt; 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="15abd042a39d9926d65656cbbe08be25424747c8" translate="yes" xml:space="preserve">
          <source>(W misc) You have a \E in a double-quotish string without a &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; or &lt;code&gt;\Q&lt;/code&gt; preceding it.</source>
          <target state="translated">(W misc) 앞에 &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; 또는 &lt;code&gt;\Q&lt;/code&gt; 없는 큰 따옴표 문자열에 \ E가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c0eea9ec7a19fa6b579515762f1950808cc9b1d" translate="yes" xml:space="preserve">
          <source>(W misc) You have attempted to weaken a reference that is already weak. Doing so has no effect.</source>
          <target state="translated">(W misc) 이미 약한 참조를 약화하려고했습니다. 그렇게해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f563a1cd3b0e654993413a90e34bfc8ab4511a9c" translate="yes" xml:space="preserve">
          <source>(W misc) You have used a replacement list that is longer than the search list. So the additional elements in the replacement list are meaningless.</source>
          <target state="translated">(W misc) 검색 목록보다 긴 대체 목록을 사용했습니다. 따라서 교체 목록의 추가 요소는 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="055eeb5e67fd76f17bce2fa389beccc4d1c206eb" translate="yes" xml:space="preserve">
          <source>(W misc) You have used the /d modifier where the searchlist has the same length as the replacelist. See &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; for more information about the /d modifier.</source>
          <target state="translated">(W misc) 검색 목록이 교체 목록과 길이가 같은 / d 수정자를 사용했습니다. / d 수정 자에 대한 자세한 내용은 &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1c43982d36144a2ffd4995fa369c53951ebca965" translate="yes" xml:space="preserve">
          <source>(W misc) You probably referred to an imported subroutine &amp;amp;FOO as $FOO or some such.</source>
          <target state="translated">(W misc) 가져온 서브 루틴 &amp;amp; FOO를 $ FOO 또는 이와 유사한 것으로 참조했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="f28afcc36fb6d498d08aa34ce83936dd22526785" translate="yes" xml:space="preserve">
          <source>(W misc) You seem to have already declared the same global once before in the current lexical scope.</source>
          <target state="translated">(W misc) 현재 어휘 범위에서 이전에 같은 전역을 이미 한 번 선언 한 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="5868eba0d9d25b18fa7c2e6fe83826d858642827" translate="yes" xml:space="preserve">
          <source>(W misc) You specified an odd number of elements to initialize a hash, which is odd, because hashes come in key/value pairs.</source>
          <target state="translated">(W misc) 해시가 키 / 값 쌍으로 이루어지기 때문에 해시를 초기화하기 위해 홀수 개의 요소를 지정했습니다.</target>
        </trans-unit>
        <trans-unit id="324ba9d70516662c8b6bfbd8be1d30db767f254c" translate="yes" xml:space="preserve">
          <source>(W misc) You tried to set the length of an array which has been freed. You can do this by storing a reference to the scalar representing the last index of an array and later assigning through that reference. For example</source>
          <target state="translated">(W misc) 해제 된 배열의 길이를 설정하려고했습니다. 배열의 마지막 인덱스를 나타내는 스칼라에 대한 참조를 저장하고 나중에 해당 참조를 통해 지정하여이를 수행 할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="10e6703969c96e985c2f8be5cfdd7a5050eb6807" translate="yes" xml:space="preserve">
          <source>(W misc) You tried to use a reference as an array index; this probably isn't what you mean, because references in numerical context tend to be huge numbers, and so usually indicates programmer error.</source>
          <target state="translated">(W misc) 참조를 배열 인덱스로 사용하려고했습니다. 숫자 컨텍스트의 참조는 숫자가 많기 때문에 일반적으로 프로그래머 오류를 나타 내기 때문에 이것은 아마도 의미하는 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="961c127b9cc0ad4bd43847fe65d18cac036115ef" translate="yes" xml:space="preserve">
          <source>(W misc) You undefined a subroutine which had previously been eligible for inlining. See &lt;a href=&quot;perlsub#Constant-Functions&quot;&gt;Constant Functions in perlsub&lt;/a&gt; for commentary and workarounds.</source>
          <target state="translated">(W misc) 이전에 인라인 할 수있는 서브 루틴을 정의하지 않았습니다. 주석과 해결 방법 &lt;a href=&quot;perlsub#Constant-Functions&quot;&gt;은 perlsub의 상수 함수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dfe717cbd021e5996741b199692d40604f2ddd47" translate="yes" xml:space="preserve">
          <source>(W misc) You used a backslash-character combination which is not recognized by Perl. The character was understood literally, but this may change in a future version of Perl.</source>
          <target state="translated">(W misc) Perl에서 인식 할 수없는 백 슬래시 문자 조합을 사용했습니다. 캐릭터는 문자 그대로 이해되었지만 이후 버전의 Perl에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e717da40f4bea7168a3f5280e24fbfb5da1b933" translate="yes" xml:space="preserve">
          <source>(W misc) You used the obsolescent &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump()&lt;/a&gt;&lt;/code&gt; built-in function, without fully qualifying it as &lt;code&gt;CORE::dump()&lt;/code&gt; . Maybe it's a typo. See &lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;.</source>
          <target state="translated">(W misc) &lt;code&gt;CORE::dump()&lt;/code&gt; 로 완전히 한정하지 않고 폐기 된 &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump()&lt;/a&gt;&lt;/code&gt; 내장 함수를 사용했습니다 . 어쩌면 오타 일 수도 있습니다. &lt;a href=&quot;functions/dump&quot;&gt;덤프&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="c0cd06fc5e07405e0a5250c8e4b98b249ba297bf" translate="yes" xml:space="preserve">
          <source>(W misc, regexp) You wrote something like &lt;code&gt;\08&lt;/code&gt; , or &lt;code&gt;\179&lt;/code&gt; in a double-quotish string. All but the last digit is treated as a single character, specified in octal. The last digit is the next character in the string. To tell Perl that this is indeed what you want, you can use the &lt;code&gt;\o{ }&lt;/code&gt; syntax, or use exactly three digits to specify the octal for the character.</source>
          <target state="translated">(W misc, regexp) 이중 따옴표 문자열에 &lt;code&gt;\08&lt;/code&gt; 또는 &lt;code&gt;\179&lt;/code&gt; 와 같은 것을 썼습니다 . 마지막 숫자를 제외한 모든 숫자는 8 진수로 지정된 단일 문자로 취급됩니다. 마지막 숫자는 문자열에서 다음 문자입니다. 펄에게 이것이 실제로 원하는 것임을 알리기 위해 &lt;code&gt;\o{ }&lt;/code&gt; 구문을 사용하거나 정확히 3 자리 숫자를 사용하여 문자의 8 진수를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d87808370647207cb23c26a494895bd593e19c4c" translate="yes" xml:space="preserve">
          <source>(W missing) You called a function with fewer arguments than other arguments you supplied indicated would be needed.</source>
          <target state="translated">(W 누락) 제공 한 다른 인수보다 필요한 인수가 적은 함수를 호출했습니다.</target>
        </trans-unit>
        <trans-unit id="6e8560a7cea10e56b2966a8252b5c47858339b3b" translate="yes" xml:space="preserve">
          <source>(W newline) A file operation was attempted on a filename, and that operation failed, PROBABLY because the filename contained a newline, PROBABLY because you forgot to chomp() it off. See &lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;.</source>
          <target state="translated">(W 개행) 파일 이름에 파일 작업을 시도했지만 파일 이름에 개행 문자가 포함되어있어 PROBABLY 작업을 실패했습니다. &lt;a href=&quot;functions/chomp&quot;&gt;씹어&lt;/a&gt; 보기 .</target>
        </trans-unit>
        <trans-unit id="ecad68c5be5ba7eb54444965792ee7f2c653a4e2" translate="yes" xml:space="preserve">
          <source>(W numeric) The indicated string was fed as an argument to an operator that expected a numeric value instead. If you're fortunate the message will identify which operator was so unfortunate.</source>
          <target state="translated">(W numeric) 표시된 문자열이 대신 숫자 값을 예상하는 연산자에 인수로 제공되었습니다. 운이 좋으면 어떤 운영자가 불행한지 메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="ffa9508e53b0c92e963d1b02acbefd8a4acfe9fd" translate="yes" xml:space="preserve">
          <source>(W numeric) The indicated string was fed as an argument to the &lt;code&gt;++&lt;/code&gt; operator which expects either a number or a string matching &lt;code&gt;/^[a-zA-Z]*[0-9]*\z/&lt;/code&gt; . See &lt;a href=&quot;perlop#Auto-increment-and-Auto-decrement&quot;&gt;Auto-increment and Auto-decrement in perlop&lt;/a&gt; for details.</source>
          <target state="translated">(W 숫자) 표시된 문자열이 &lt;code&gt;++&lt;/code&gt; 연산자에 인수로 제공되어 &lt;code&gt;/^[a-zA-Z]*[0-9]*\z/&lt;/code&gt; 일치하는 숫자 또는 문자열이 필요합니다 . &lt;a href=&quot;perlop#Auto-increment-and-Auto-decrement&quot;&gt;Perlop에서 자동 증가 및 자동 감소를&lt;/a&gt; 참조하십시오. 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e747973f9086868d39efd9610fcbe587d13511fb" translate="yes" xml:space="preserve">
          <source>(W numeric) You tried to execute the &lt;a href=&quot;perlop#Multiplicative-Operators&quot;&gt;x &lt;/a&gt; repetition operator &lt;code&gt;Inf&lt;/code&gt; (or &lt;code&gt;-Inf&lt;/code&gt; ) or &lt;code&gt;NaN&lt;/code&gt; times, which doesn't make sense.</source>
          <target state="translated">(W 숫자) &lt;a href=&quot;perlop#Multiplicative-Operators&quot;&gt;x&lt;/a&gt; 반복 연산자 &lt;code&gt;Inf&lt;/code&gt; (또는 &lt;code&gt;-Inf&lt;/code&gt; ) 또는 &lt;code&gt;NaN&lt;/code&gt; 을 실행하려고했습니다. 시간 이치에 맞지 않습니다.</target>
        </trans-unit>
        <trans-unit id="df9ed2c03344d23e71c3f63e7cd7233301c17e01" translate="yes" xml:space="preserve">
          <source>(W numeric) You tried to execute the &lt;a href=&quot;perlop#Multiplicative-Operators&quot;&gt;x &lt;/a&gt; repetition operator fewer than 0 times, which doesn't make sense.</source>
          <target state="translated">(W 숫자) &lt;a href=&quot;perlop#Multiplicative-Operators&quot;&gt;x&lt;/a&gt; 를 실행하려고했습니다. 반복 연산자를 0 회 미만 이치에 맞지 않습니다.</target>
        </trans-unit>
        <trans-unit id="979df2325920e52daaa8be14ea206eccde22447a" translate="yes" xml:space="preserve">
          <source>(W once) Typographical errors often show up as unique variable names. If you had a good reason for having a unique name, then just mention it again somehow to suppress the message. The &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration is also provided for this purpose.</source>
          <target state="translated">(W once) 인쇄상의 오류는 종종 고유 한 변수 이름으로 나타납니다. 고유 한 이름을 가진 충분한 이유가 있다면 메시지를 표시하지 않으려면 다시 언급하십시오. 그만큼 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 선언은이 목적을 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="293cfd81dde512b2040983819ce42833b00e006e" translate="yes" xml:space="preserve">
          <source>(W overflow) Some portion of a version initialization is too large for the size of integers for your architecture. This is not a warning because there is no rational reason for a version to try and use an element larger than typically 2**32. This is usually caused by trying to use some odd mathematical operation as a version, like 100/9.</source>
          <target state="translated">(W overflow) 버전 초기화의 일부가 아키텍처의 정수 크기에 비해 너무 큽니다. 버전이 일반적으로 2 ** 32보다 큰 요소를 사용하려고하는 합리적인 이유가 없기 때문에 이것은 경고가 아닙니다. 이것은 보통 100/9와 같은 이상한 수학 연산을 버전으로 사용하려고 할 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="aa916c900301e3826afbb5c02eaae17fff9b2c9d" translate="yes" xml:space="preserve">
          <source>(W overflow) The hexadecimal floating point had internally more digits than could be output. This can be caused by unsupported long double formats, or by 64-bit integers not being available (needed to retrieve the digits under some configurations).</source>
          <target state="translated">(W overflow) 16 진 부동 소수점은 출력 할 수있는 것보다 내부적으로 더 많은 자릿수를 가졌습니다. 지원되지 않는 long double 형식이나 64 비트 정수를 사용할 수 없기 때문일 수 있습니다 (일부 구성에서는 숫자를 검색해야 함).</target>
        </trans-unit>
        <trans-unit id="138762264bdf623369c76bc48da2075b0cc318e5" translate="yes" xml:space="preserve">
          <source>(W overflow) The hexadecimal floating point has a larger exponent than the floating point supports.</source>
          <target state="translated">(W overflow) 16 진 부동 소수점은 부동 소수점 지원보다 지수가 큽니다.</target>
        </trans-unit>
        <trans-unit id="7814ff9e669078b81e726ef3a3f6f5a884ba7aa0" translate="yes" xml:space="preserve">
          <source>(W overflow) The hexadecimal floating point has a smaller exponent than the floating point supports.</source>
          <target state="translated">(W overflow) 16 진 부동 소수점은 부동 소수점 지원보다 지수가 작습니다.</target>
        </trans-unit>
        <trans-unit id="ffaf16a18b1f69a006ca7d0cf534ff6517d8ea76" translate="yes" xml:space="preserve">
          <source>(W overflow) The hexadecimal floating point literal had more bits in the mantissa (the part between the 0x and the exponent, also known as the fraction or the significand) than the floating point supports.</source>
          <target state="translated">(W overflow) 16 진 부동 소수점 리터럴은 부동 소수점 지원보다 가수 (0x와 지수 사이의 부분 (분수 또는 의미라고도 함)에 더 많은 비트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="afbfa3b5e713c7cfd0fd6a0d70917f864ae78219" translate="yes" xml:space="preserve">
          <source>(W overflow) You called &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; with a number that it could not handle: too large, too small, or NaN. The returned value is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">(W overflow) 처리 할 수없는 숫자로 &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; 을 호출 했습니다 : 너무 크거나 작거나 NaN. 반환 값은 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0d036704b2cebe975d7e914b35acf789231af606" translate="yes" xml:space="preserve">
          <source>(W overflow) You called &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; with a number that was larger than it can reliably handle and &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; probably returned the wrong date. This warning is also triggered with NaN (the special not-a-number value).</source>
          <target state="translated">(W overflow) 안정적으로 처리 할 수있는 것보다 큰 숫자로 &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; 을 호출 했으며 &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; 이 잘못된 날짜를 반환했을 것입니다. 이 경고는 NaN (숫자가 아닌 특수 값)으로도 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="0a311f99c2c8b02930306682b9959eb1c20599da" translate="yes" xml:space="preserve">
          <source>(W overflow) You called &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; with a number that was smaller than it can reliably handle and &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; probably returned the wrong date.</source>
          <target state="translated">(W overflow) 안정적으로 처리하고 &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; 보다 작은 숫자로 &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; 을 호출 했습니다. 이 잘못된 날짜를 반환했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="36f5779623dfa6f6e7074bdae41e1e41b89f241a" translate="yes" xml:space="preserve">
          <source>(W overflow) You called &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; with a number that it could not handle: too large, too small, or NaN. The returned value is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">(W overflow) 너무 크거나 작거나 NaN과 같이 처리 할 수없는 숫자로 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 을 호출 했습니다. 반환 값은 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="59105a430199971f3675bfeb1fffaf7e49ff1f30" translate="yes" xml:space="preserve">
          <source>(W overflow) You called &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; with a number that was larger than it can reliably handle and &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; probably returned the wrong date. This warning is also triggered with NaN (the special not-a-number value).</source>
          <target state="translated">(W overflow) 안정적으로 처리 할 수있는 것보다 큰 숫자로 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 에 전화했고 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 에 잘못된 날짜가 반환되었을 수 있습니다. 이 경고는 NaN (숫자가 아닌 특수 값)으로도 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="a93e07bf0c0bd6b674d691a637cbeb2110ed1a3d" translate="yes" xml:space="preserve">
          <source>(W overflow) You called &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; with a number that was smaller than it can reliably handle and &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; probably returned the wrong date.</source>
          <target state="translated">(W overflow) 안정적으로 처리하고 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 보다 작은 숫자로 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 을 호출 했습니다. 에 잘못된 날짜가 반환되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5aa4610ff7a25c878af96eaca3bd3d08a52b4d72" translate="yes" xml:space="preserve">
          <source>(W overflow) You called &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; with a number that was larger than it can reliably handle and &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; probably slept for less time than requested.</source>
          <target state="translated">(W overflow) 안정적으로 처리하고 &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 할 수있는 수보다 큰 수로 &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 을 호출 했습니다. 이 요청한 것보다 적은 시간 동안 잠을 잤을 .</target>
        </trans-unit>
        <trans-unit id="d9fd3dde1b871c801c860d8a346caace3870778c" translate="yes" xml:space="preserve">
          <source>(W overload) The &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt; pragma was passed an argument it did not recognize. Did you mistype an operator?</source>
          <target state="translated">(W 과부하) &lt;a href=&quot;overload&quot;&gt;과부하&lt;/a&gt; pragma에 인식하지 못하는 인수가 전달되었습니다. 연산자를 잘못 입력 했습니까?</target>
        </trans-unit>
        <trans-unit id="e826b5fc0dae7ccc313c75bbbc79a59aff89f566" translate="yes" xml:space="preserve">
          <source>(W overload) The call to overload::constant contained an odd number of arguments. The arguments should come in pairs.</source>
          <target state="translated">(W 과부하) overload :: constant 호출에 홀수 개의 인수가 포함되었습니다. 인수는 쌍을 이루어야합니다.</target>
        </trans-unit>
        <trans-unit id="be93031fb1c1fd2693de7b970bf1f347826973be" translate="yes" xml:space="preserve">
          <source>(W overload) The second (fourth, sixth, ...) argument of overload::constant needs to be a code reference. Either an anonymous subroutine, or a reference to a subroutine.</source>
          <target state="translated">(W 과부하) overload :: constant의 두 번째 (4 번째, 6 번째, ...) 인수는 코드 참조 여야합니다. 익명 서브 루틴 또는 서브 루틴에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="bb652dad5fd63516cc2d111645fd00a245f45570" translate="yes" xml:space="preserve">
          <source>(W overload) You tried to overload a constant type the overload package is unaware of.</source>
          <target state="translated">(W 과부하) 과부하 패키지가 인식하지 못하는 상수 유형을 과부하하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="cdc892f77860c2fc237ce50d76efd0c8dceb00a4" translate="yes" xml:space="preserve">
          <source>(W pack) Each line in an uuencoded string starts with a length indicator which can't encode values above 63. So there is no point in asking for a line length bigger than that. Perl will behave as if you specified &lt;code&gt;u63&lt;/code&gt; as the format.</source>
          <target state="translated">(W pack) uuencoded 문자열의 각 줄은 63보다 큰 값을 인코딩 할 수없는 길이 표시기로 시작합니다. 따라서 그보다 큰 줄 길이를 요구할 필요가 없습니다. 펄은 &lt;code&gt;u63&lt;/code&gt; 을 지정한 것처럼 동작합니다 을 형식으로 합니다.</target>
        </trans-unit>
        <trans-unit id="eb6f8e362bfe003b879f383a4c911b9a8c85c57c" translate="yes" xml:space="preserve">
          <source>(W pack) You said</source>
          <target state="translated">당신은 말했다</target>
        </trans-unit>
        <trans-unit id="6a2168c56cd322bfb883a2fd9dbaf886812e847c" translate="yes" xml:space="preserve">
          <source>(W pack) You tried something like</source>
          <target state="translated">(W pack) 너는 다음과 같은 것을 시도했다.</target>
        </trans-unit>
        <trans-unit id="331cf753fae1a080c528f36a302470f474fb3136" translate="yes" xml:space="preserve">
          <source>(W pack) You tried to pass a temporary value (like the result of a function, or a computed expression) to the &quot;p&quot; pack() template. This means the result contains a pointer to a location that could become invalid anytime, even before the end of the current statement. Use literals or global values as arguments to the &quot;p&quot; pack() template to avoid this warning.</source>
          <target state="translated">(W pack) &quot;p&quot;pack () 템플릿에 임시 값 (함수 또는 계산식과 같은)을 전달하려고했습니다. 이는 결과에 현재 명령문이 끝나기 전에도 언제든지 유효하지 않은 위치에 대한 포인터가 결과에 포함됨을 의미합니다. 이 경고를 피하려면 리터럴 또는 전역 값을 &quot;p&quot;pack () 템플릿의 인수로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="512f02482767bcddc779471eaf5fc084e966f52c" translate="yes" xml:space="preserve">
          <source>(W parenthesis) You said something like</source>
          <target state="translated">(W 괄호) 너는 다음과 같이 말했다.</target>
        </trans-unit>
        <trans-unit id="ede1f656195c84e1f48728c83c4610d04755c430" translate="yes" xml:space="preserve">
          <source>(W pipe) A fork in a piped open failed with EAGAIN and will be retried after five seconds.</source>
          <target state="translated">(W 파이프) EAGAIN으로 파이프 열린 상태의 포크가 실패했으며 5 초 후에 다시 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="b5a7c11775d339fb6b5d17e9b9676b5723086198" translate="yes" xml:space="preserve">
          <source>(W pipe) You tried to say &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(CMD, &quot;|cmd|&quot;)&lt;/code&gt; , which is not supported. You can try any of several modules in the Perl library to do this, such as IPC::Open2. Alternately, direct the pipe's output to a file using &quot;&amp;gt;&quot;, and then read it in under a different file handle.</source>
          <target state="translated">(W 파이프) &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(CMD, &quot;|cmd|&quot;)&lt;/code&gt; 지원되지 않는 . IPC :: Open2와 같이 Perl 라이브러리의 여러 모듈 중 하나를 사용하여이를 수행 할 수 있습니다. 또는 &quot;&amp;gt;&quot;를 사용하여 파이프의 출력을 파일로 보낸 다음 다른 파일 핸들 아래에서 읽습니다.</target>
        </trans-unit>
        <trans-unit id="b9cd44d6f9338e432eca0100ebb8cf99a11652fc" translate="yes" xml:space="preserve">
          <source>(W pipe) You used the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(FH, &quot;| command&quot;)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(FH, &quot;command |&quot;)&lt;/code&gt; construction, but the command was missing or blank.</source>
          <target state="translated">(W 파이프) &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(FH, &quot;| command&quot;)&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(FH, &quot;command |&quot;)&lt;/code&gt; 구성을 사용했지만 명령이 없거나 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="33a8500596670f4af1c72a4fafc0180e0691f8b6" translate="yes" xml:space="preserve">
          <source>(W portable) The binary number you specified is larger than 2**32-1 (4294967295) and therefore non-portable between systems. See &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for more on portability concerns.</source>
          <target state="translated">(W 휴대용) 지정한 이진 숫자가 2 ** 32-1 (4294967295)보다 커서 시스템간에 이식 할 수 없습니다. 이식성 문제에 대한 자세한 내용은 &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="09d1165dcd6590ca88ce45235db739b3730780ae" translate="yes" xml:space="preserve">
          <source>(W portable) The hexadecimal number you specified is larger than 2**32-1 (4294967295) and therefore non-portable between systems. See &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for more on portability concerns.</source>
          <target state="translated">(W 휴대용) 지정한 16 진수는 2 ** 32-1 (4294967295)보다 커서 시스템간에 이식 할 수 없습니다. &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; 참조이식성 문제에 대한 자세한 를 .</target>
        </trans-unit>
        <trans-unit id="fc835297f2faad908ec35d66fe96ac88817ca399" translate="yes" xml:space="preserve">
          <source>(W portable) The octal number you specified is larger than 2**32-1 (4294967295) and therefore non-portable between systems. See &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for more on portability concerns.</source>
          <target state="translated">(W 휴대용) 지정한 8 진수가 2 ** 32-1 (4294967295)보다 커서 시스템간에 이식 할 수 없습니다. 이식성 문제에 대한 자세한 내용은 &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="64214d18f45799923abe2fb1d80cfb4e5a157cf3" translate="yes" xml:space="preserve">
          <source>(W portable) Using bit vector sizes larger than 32 is non-portable.</source>
          <target state="translated">(W portable) 32보다 큰 비트 벡터 크기를 사용하면 이식 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d926270be302be5e7e03299af7637591efa9d859" translate="yes" xml:space="preserve">
          <source>(W precedence) Your program uses a bitwise logical operator in conjunction with a numeric comparison operator, like this :</source>
          <target state="translated">(W 우선 순위) 프로그램은 다음과 같이 숫자 비교 연산자와 함께 비트 논리 연산자를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="792bff25d5afceb382dc5952aa4d3237868dca22" translate="yes" xml:space="preserve">
          <source>(W printf) Perl does not understand the given format conversion. See &lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;.</source>
          <target state="translated">(W printf) Perl은 주어진 형식 변환을 이해하지 못합니다. &lt;a href=&quot;functions/sprintf&quot;&gt;sprintf를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c27ac7b8639b06bd0fbaa78cd260cb1fd460614" translate="yes" xml:space="preserve">
          <source>(W prototype) A prototype was declared in both the parentheses after the sub name and via the prototype attribute. The prototype in parentheses is useless, since it will be replaced by the prototype from the attribute before it's ever used.</source>
          <target state="translated">(W 프로토 타입) 프로토 타입은 하위 이름 뒤의 괄호와 프로토 타입 속성을 통해 선언되었습니다. 괄호 안의 프로토 타입은 사용하기 전에 속성의 프로토 타입으로 대체되므로 쓸모가 없습니다.</target>
        </trans-unit>
        <trans-unit id="33b95571f8339a2cc0606dafed862a4db48c3be9" translate="yes" xml:space="preserve">
          <source>(W prototype) You've called a function that has a prototype before the parser saw a definition or declaration for it, and Perl could not check that the call conforms to the prototype. You need to either add an early prototype declaration for the subroutine in question, or move the subroutine definition ahead of the call to get proper prototype checking. Alternatively, if you are certain that you're calling the function correctly, you may put an ampersand before the name to avoid the warning. See &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="translated">(W 프로토 타입) 파서가 정의 또는 선언을보기 전에 프로토 타입이있는 함수를 호출했으며 호출이 프로토 타입을 준수하는지 확인할 수 없습니다. 문제가있는 서브 루틴에 대한 초기 프로토 타입 선언을 추가하거나 서브 루틴 정의를 호출보다 먼저 이동하여 프로토 타입을 올바르게 검사해야합니다. 또는 함수를 올바르게 호출한다고 확신하는 경우 경고를 피하기 위해 이름 앞에 앰퍼샌드를 넣을 수 있습니다. &lt;a href=&quot;perlsub&quot;&gt;perlsub를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="edd018a5f62f70fa66e12afd9da66c3f02d8c926" translate="yes" xml:space="preserve">
          <source>(W qw) qw() lists contain items separated by whitespace; as with literal strings, comment characters are not ignored, but are instead treated as literal data. (You may have used different delimiters than the parentheses shown here; braces are also frequently used.)</source>
          <target state="translated">(W qw) qw () 목록은 공백으로 구분 된 항목을 포함합니다. 리터럴 문자열과 마찬가지로 주석 문자는 무시되지 않고 리터럴 데이터로 처리됩니다. (여기에 표시된 괄호와 다른 구분 기호를 사용했을 수도 있습니다. 중괄호도 자주 사용됩니다.)</target>
        </trans-unit>
        <trans-unit id="578fcce7799c47789b0adac33008237c84ca3a49" translate="yes" xml:space="preserve">
          <source>(W qw) qw() lists contain items separated by whitespace; therefore commas aren't needed to separate the items. (You may have used different delimiters than the parentheses shown here; braces are also frequently used.)</source>
          <target state="translated">(W qw) qw () 목록은 공백으로 구분 된 항목을 포함합니다. 따라서 항목을 구분하기 위해 쉼표가 필요하지 않습니다. (여기에 표시된 괄호와 다른 구분 기호를 사용했을 수도 있습니다. 중괄호도 자주 사용됩니다.)</target>
        </trans-unit>
        <trans-unit id="f98cb1c68560387dbc563580499439d4e545c148" translate="yes" xml:space="preserve">
          <source>(W recursion) This subroutine has called itself (directly or indirectly) 100 times more than it has returned. This probably indicates an infinite recursion, unless you're writing strange benchmark programs, in which case it indicates something else.</source>
          <target state="translated">(W 재귀)이 서브 루틴은 리턴 된 것보다 100 배 더 직접적 또는 간접적으로 호출되었습니다. 이상한 벤치 마크 프로그램을 작성하지 않는 한 무한 재귀를 나타낼 수 있습니다.이 경우 다른 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="47929167f9b9dbf125f892daabe93ee9bacbdfe6" translate="yes" xml:space="preserve">
          <source>(W redefine) You redefined a format. To suppress this warning, say</source>
          <target state="translated">(W 재정의) 형식을 재정의했습니다. 이 경고를 표시하지 않으려면</target>
        </trans-unit>
        <trans-unit id="7ea1097acd4664a0298a650f6b5ed50b0394a5e8" translate="yes" xml:space="preserve">
          <source>(W redefine) You redefined a subroutine. To suppress this warning, say</source>
          <target state="translated">(W 재정의) 서브 루틴을 재정의했습니다. 이 경고를 표시하지 않으려면</target>
        </trans-unit>
        <trans-unit id="689f4b16660fc106afaec6518b73b97410cae44a" translate="yes" xml:space="preserve">
          <source>(W redefine)(S) You redefined a subroutine which had previously been eligible for inlining. See &lt;a href=&quot;perlsub#Constant-Functions&quot;&gt;Constant Functions in perlsub&lt;/a&gt; for commentary and workarounds.</source>
          <target state="translated">(W 재정의) (S) 이전에 인라인 할 수있는 서브 루틴을 재정의했습니다. 주석과 해결 방법 &lt;a href=&quot;perlsub#Constant-Functions&quot;&gt;은 perlsub의 상수 함수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3855dda462903bfd0f1cb6416b2c27b1d50dfe13" translate="yes" xml:space="preserve">
          <source>(W redundant) You called a function with more arguments than other arguments you supplied indicated would be needed. Currently only emitted when a printf-type format required fewer arguments than were supplied, but might be used in the future for e.g. &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;.</source>
          <target state="translated">(W 이중화) 제공 한 다른 인수보다 많은 인수가있는 함수를 호출했습니다. 현재 printf 형식 형식이 제공된 것보다 적은 수의 인수가 필요한 경우에만 생성되지만 나중에 &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; 과 같이 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1214eb3b51b8ff26fb1eb34d1309ab5f40c42cad" translate="yes" xml:space="preserve">
          <source>(W regexp) (only under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'strict'&lt;/code&gt; or within &lt;code&gt;(?[...])&lt;/code&gt; )</source>
          <target state="translated">(W 정규 표현식) ( &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'strict'&lt;/code&gt; 또는 &lt;code&gt;(?[...])&lt;/code&gt; 내 에서만 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="afe1f8b1a4d34adb7a2f8d5f9d1021945e4cb7e2" translate="yes" xml:space="preserve">
          <source>(W regexp) Minima should be less than or equal to maxima. If you really want your regexp to match something 0 times, just put {0}.</source>
          <target state="translated">(W 정규 표현식) 최소값은 최대 값보다 작거나 같아야합니다. 정규 표현식을 0 번 일치 시키려면 {0}을 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="310e10e88bd557a50ffed62c0a92ae3cc181eb6a" translate="yes" xml:space="preserve">
          <source>(W regexp) Named Unicode character escapes (&lt;code&gt;\N{...}&lt;/code&gt; ) may return a zero-length sequence. When such an escape is used in a character class its behavior is not well defined. Check that the correct escape has been used, and the correct charname handler is in scope.</source>
          <target state="translated">(W 정규 표현식) 명명 된 유니 코드 문자 이스케이프 ( &lt;code&gt;\N{...}&lt;/code&gt; )는 길이가 0 인 시퀀스를 반환 할 수 있습니다. 이러한 이스케이프가 문자 클래스에서 사용될 때 해당 동작은 잘 정의되지 않습니다. 올바른 이스케이프가 사용되었고 올바른 문자 이름 핸들러가 범위 내에 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="cac34d442feedb85a4f7352a0dc2a4c7f282aa35" translate="yes" xml:space="preserve">
          <source>(W regexp) Named Unicode character escapes &lt;code&gt;(\N{...})&lt;/code&gt; may return a multi-character sequence. Even though a character class is supposed to match just one character of input, perl will match the whole thing correctly, except when the class is inverted (&lt;code&gt;[^...]&lt;/code&gt;), or the escape is the beginning or final end point of a range. For these, what should happen isn't clear at all. In these circumstances, Perl discards all but the first character of the returned sequence, which is not likely what you want.</source>
          <target state="translated">(W regexp) 명명 된 유니 코드 문자 이스케이프 &lt;code&gt;(\N{...})&lt;/code&gt; 는 여러 문자 시퀀스를 반환 할 수 있습니다. 문자 클래스가 입력의 한 문자와 만 일치한다고 가정하더라도 클래스가 반전 되거나 ( &lt;code&gt;[^...]&lt;/code&gt; ) 이스케이프가 시작 또는 마지막 끝점 인 경우를 제외하고 perl은 모든 항목과 정확하게 일치합니다 . 범위. 이를 위해 어떤 일이 발생해야하는지 명확하지 않습니다. 이러한 상황에서 Perl은 리턴 된 순서의 첫 번째 문자를 제외한 모든 문자를 버립니다 (원하는 것은 아님).</target>
        </trans-unit>
        <trans-unit id="979a02ee883c9ec2b29353dd7dff24d69eb2d3ce" translate="yes" xml:space="preserve">
          <source>(W regexp) The &lt;code&gt;p&lt;/code&gt; modifier cannot be turned off once set. Trying to do so is futile.</source>
          <target state="translated">(W 정규식) &lt;code&gt;p&lt;/code&gt; 수정자를 설정 한 후에는 끌 수 없습니다. 그렇게하는 것은 쓸데없는 일입니다.</target>
        </trans-unit>
        <trans-unit id="8836615448ed9381b2dd52c5b2fbe6a905d13b4d" translate="yes" xml:space="preserve">
          <source>(W regexp) The character class constructs [: :], [= =], and [. .] go</source>
          <target state="translated">(W regexp) 문자 클래스는 [: :], [= =] 및 [. .] 가다</target>
        </trans-unit>
        <trans-unit id="9c9b13dc35d66abc0e2ef6aa56dcc54220fb0f95" translate="yes" xml:space="preserve">
          <source>(W regexp) The pattern you've specified would be an infinite loop if the regular expression engine didn't specifically check for that. The &amp;lt;-- HERE shows whereabouts in the regular expression the problem was discovered. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">(W regexp) 정규 표현식 엔진이 특별히 확인하지 않은 경우 지정한 패턴은 무한 루프입니다. &amp;lt;-HERE는 정규식에서 문제가 발견 된 위치를 보여줍니다. &lt;a href=&quot;perlre&quot;&gt;perlre를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="34e218ab696b9069c9cee1fbdc8441bff0b2fd36" translate="yes" xml:space="preserve">
          <source>(W regexp) The regular expression engine uses recursion in complex situations where back-tracking is required. Recursion depth is limited to 32766, or perhaps less in architectures where the stack cannot grow arbitrarily. (&quot;Simple&quot; and &quot;medium&quot; situations are handled without recursion and are not subject to a limit.) Try shortening the string under examination; looping in Perl code (e.g. with &lt;code&gt;while&lt;/code&gt; ) rather than in the regular expression engine; or rewriting the regular expression so that it is simpler or backtracks less. (See &lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2&lt;/a&gt; for information on</source>
          <target state="translated">(W regexp) 정규식 엔진은 역 추적이 필요한 복잡한 상황에서 재귀를 사용합니다. 재귀 깊이는 32766으로 제한되거나 스택이 임의로 성장할 수없는 아키텍처에서는 더 적습니다. ( &quot;단순&quot;및 &quot;중간&quot;상황은 재귀없이 처리되며 제한되지 않습니다.) 검사중인 문자열을 줄이십시오. 정규 표현식 엔진이 아닌 Perl 코드에서 반복 (예 : &lt;code&gt;while&lt;/code&gt; ); 또는 정규식을 다시 작성하여 더 단순하거나 역 추적 할 수 있습니다. (에 대한 정보는 &lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e80a3d940f8d1e707b0bc892519eccf16aea2d95" translate="yes" xml:space="preserve">
          <source>(W regexp) You applied a regular expression quantifier in a place where it makes no sense, such as on a zero-width assertion. Try putting the quantifier inside the assertion instead. For example, the way to match &quot;abc&quot; provided that it is followed by three repetitions of &quot;xyz&quot; is &lt;code&gt;/abc(?=(?:xyz){3})/&lt;/code&gt; , not &lt;code&gt;/abc(?=xyz){3}/&lt;/code&gt; .</source>
          <target state="translated">(W regexp) 너비가 0 인 어설 션과 같이 의미가없는 곳에 정규식 수량자를 적용했습니다. 대신 어설 션 안에 정량자를 넣으십시오. 예를 들어, 방법은 그것이 &quot;XYZ&quot;세 번 반복 하였다 것을 제공 &quot;ABC&quot;와 일치하는 &lt;code&gt;/abc(?=(?:xyz){3})/&lt;/code&gt; 하지 &lt;code&gt;/abc(?=xyz){3}/&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="136a9995a2e015be707b998b2100f17123be4162" translate="yes" xml:space="preserve">
          <source>(W regexp) You have used an internal modifier such as (?-o) that has no meaning unless removed from the entire regexp:</source>
          <target state="translated">(W 정규 표현식) 전체 정규 표현식에서 제거하지 않으면 의미가없는 (? -o)와 같은 내부 수정자를 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="55d68e94b03df6dbd58f4c0d015f0fad8b599b8d" translate="yes" xml:space="preserve">
          <source>(W regexp) You have used an internal modifier such as (?o) that has no meaning unless applied to the entire regexp:</source>
          <target state="translated">(W 정규 표현식) 전체 정규 표현식에 적용되지 않는 한 의미가없는 (? o)와 같은 내부 수정자를 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="4dff6ec1a19e7de52b41046a33967e1771a1d39a" translate="yes" xml:space="preserve">
          <source>(W regexp) You specified something like these:</source>
          <target state="translated">(W regexp) 다음과 같이 지정했습니다.</target>
        </trans-unit>
        <trans-unit id="a554f4535489ad2df9ed3cca605416c0a1c6af75" translate="yes" xml:space="preserve">
          <source>(W regexp) You used a Unicode boundary (&lt;code&gt;\b{...}&lt;/code&gt; or &lt;code&gt;\B{...}&lt;/code&gt; ) in a portion of a regular expression where the character set modifiers &lt;code&gt;/a&lt;/code&gt; or &lt;code&gt;/aa&lt;/code&gt; are in effect. These two modifiers indicate an ASCII interpretation, and this doesn't make sense for a Unicode defintion. The generated regular expression will compile so that the boundary uses all of Unicode. No other portion of the regular expression is affected.</source>
          <target state="translated">(W regexp) 문자 세트 수정 자 &lt;code&gt;/a&lt;/code&gt; 또는 &lt;code&gt;/aa&lt;/code&gt; 가 적용 되는 정규 표현식 부분에서 유니 코드 경계 ( &lt;code&gt;\b{...}&lt;/code&gt; 또는 &lt;code&gt;\B{...}&lt;/code&gt; )를 사용했습니다 . 이 두 수정자는 ASCII 해석을 나타내며 유니 코드 정의에는 적합하지 않습니다. 생성 된 정규식은 경계가 모든 유니 코드를 사용하도록 컴파일됩니다. 정규식의 다른 부분은 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c858a1bb6c94f36a1ad78cfa5e12eef38835bc65" translate="yes" xml:space="preserve">
          <source>(W regexp) You used a backslash-character combination which is not recognized by Perl inside character classes. The character was understood literally, but this may change in a future version of Perl. The &amp;lt;-- HERE shows whereabouts in the regular expression the escape was discovered.</source>
          <target state="translated">(W regexp) 문자 클래스 내부에서 Perl에 의해 인식되지 않는 백 슬래시 문자 조합을 사용했습니다. 캐릭터는 문자 그대로 이해되었지만 이후 버전의 Perl에서 변경 될 수 있습니다. &amp;lt;-HERE는 이스케이프가 발견 된 정규식의 위치를 ​​보여줍니다.</target>
        </trans-unit>
        <trans-unit id="f4b5c5f036648db103b8f6b0d672a6297b55d830" translate="yes" xml:space="preserve">
          <source>(W regexp) You used a backslash-character combination which is not recognized by Perl. The character(s) were understood literally, but this may change in a future version of Perl. The &amp;lt;-- HERE shows whereabouts in the regular expression the escape was discovered.</source>
          <target state="translated">(W regexp) Perl에서 인식 할 수없는 백 슬래시 문자 조합을 사용했습니다. 문자는 문자 그대로 이해되었지만 이후 버전의 Perl에서 변경 될 수 있습니다. &amp;lt;-HERE는 이스케이프가 발견 된 정규식의 위치를 ​​보여줍니다.</target>
        </trans-unit>
        <trans-unit id="726bc29b79e757efbbf6291f3feab7738f4156dd" translate="yes" xml:space="preserve">
          <source>(W regexp) You used the /c modifier in a substitution. The /c modifier is not presently meaningful in substitutions.</source>
          <target state="translated">(W regexp) / c 수정자를 대체에 사용했습니다. / c 수정자는 현재 대체에 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f9138d3ceb624a8a5b53b139e9b01cf402ccd97d" translate="yes" xml:space="preserve">
          <source>(W regexp) You used the /c modifier with a regex operand, but didn't use the /g modifier. Currently, /c is meaningful only when /g is used. (This may change in the future.)</source>
          <target state="translated">(W regexp) 정규식 피연산자와 함께 / c 수정자를 사용했지만 / g 수정자를 사용하지 않았습니다. 현재 / c는 / g가 사용될 때만 의미가 있습니다. (향후 변경 될 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="05230a0b7de0944fc11913778fd1b00ae30b0de3" translate="yes" xml:space="preserve">
          <source>(W regexp) You used the /g modifier on the pattern for a &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; operator. Since &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; always tries to match the pattern repeatedly, the &lt;code&gt;/g&lt;/code&gt; has no effect.</source>
          <target state="translated">(W regexp) &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 연산자 의 패턴에서 / g 수정자를 사용했습니다 . &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 은 항상 패턴을 반복적으로 일치 시키려고하기 때문에 &lt;code&gt;/g&lt;/code&gt; 는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="fce92f52ceba5999bee49caf7c2b501e30f4a70d" translate="yes" xml:space="preserve">
          <source>(W regexp)(F) A character class range must start and end at a literal character, not another character class like &lt;code&gt;\d&lt;/code&gt; or &lt;code&gt;[:alpha:]&lt;/code&gt;. The &quot;-&quot; in your false range is interpreted as a literal &quot;-&quot;. In a &lt;code&gt;(?[...])&lt;/code&gt; construct, this is an error, rather than a warning. Consider quoting the &quot;-&quot;, &quot;\-&quot;. The &amp;lt;-- HERE shows whereabouts in the regular expression the problem was discovered. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">(W regexp) (F) 문자 클래스 범위는 &lt;code&gt;\d&lt;/code&gt; 또는 &lt;code&gt;[:alpha:]&lt;/code&gt; 와 같은 다른 문자 클래스가 아닌 리터럴 문자로 시작하고 끝나야합니다 . 잘못된 범위의 &quot;-&quot;는 리터럴 &quot;-&quot;로 해석됩니다. A의 &lt;code&gt;(?[...])&lt;/code&gt; 구조물이 오히려 경고보다 오류이다. &quot;-&quot;, &quot;\-&quot;를 인용하십시오. &amp;lt;-HERE는 정규식에서 문제가 발견 된 위치를 보여줍니다. &lt;a href=&quot;perlre&quot;&gt;펄레&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="d8e9fa34a2adca3b8cdfab34d848f2df35e1e065" translate="yes" xml:space="preserve">
          <source>(W regexp)(F) The numeric escape (for example &lt;code&gt;\xHH&lt;/code&gt; ) of value &amp;lt; 256 didn't correspond to a single character through the conversion from the encoding specified by the encoding pragma. The escape was replaced with REPLACEMENT CHARACTER (U+FFFD) instead, except within &lt;code&gt;(?[   ])&lt;/code&gt; , where it is a fatal error. The &amp;lt;-- HERE shows whereabouts in the regular expression the escape was discovered.</source>
          <target state="translated">(W regexp) (F) 값이 &amp;lt;256 인 숫자 이스케이프 (예 : &lt;code&gt;\xHH&lt;/code&gt; )는 인코딩 pragma로 지정된 인코딩에서 변환하여 단일 문자에 해당하지 않습니다. 치명적 오류 인 &lt;code&gt;(?[ ])&lt;/code&gt; 내를 제외하고 대신 이스케이프가 REPLACEMENT CHARACTER (U + FFFD)로 대체되었습니다 . &amp;lt;-HERE는 이스케이프가 발견 된 정규식의 위치를 ​​보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ab5d2805454216bda7ba450af2c1070e6d07a77b" translate="yes" xml:space="preserve">
          <source>(W reserved) A lowercase attribute name was used that had a package-specific handler. That name might have a meaning to Perl itself some day, even though it doesn't yet. Perhaps you should use a mixed-case attribute name, instead. See &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt;.</source>
          <target state="translated">(W reserved) 패키지 별 핸들러가있는 소문자 속성 이름이 사용되었습니다. 그 이름은 아직은 아니지만 언젠가 Perl 자체에 의미가있을 수 있습니다. 대신 대소 문자 혼합 속성 이름을 사용해야합니다. &lt;a href=&quot;attributes&quot;&gt;속성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="28a74896a26f8e20c063399ec49864ab28f3d526" translate="yes" xml:space="preserve">
          <source>(W reserved) You used a bareword that might someday be claimed as a reserved word. It's best to put such a word in quotes, or capitalize it somehow, or insert an underbar into it. You might also declare it as a subroutine.</source>
          <target state="translated">(W reserved) 언젠가는 예약어로 주장 될 수있는 베어 워드를 사용했습니다. 그러한 단어를 따옴표로 묶거나 어떻게 든 대문자로 쓰거나 밑줄을 삽입하는 것이 가장 좋습니다. 서브 루틴으로 선언 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7f56b2509559b232b5aa9bdc88fbfd521c4a370" translate="yes" xml:space="preserve">
          <source>(W semicolon) A nearby syntax error was probably caused by a missing semicolon, or possibly some other missing operator, such as a comma.</source>
          <target state="translated">(W 세미콜론) 근처의 구문 오류는 세미콜론이 누락되었거나 쉼표와 같은 다른 누락 된 연산자로 인해 발생했을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c490a0614ad09a273c847f914c444441bd43e759" translate="yes" xml:space="preserve">
          <source>(W signal) Perl has detected that it is being run with the SIGCHLD signal (sometimes known as SIGCLD) disabled. Since disabling this signal will interfere with proper determination of exit status of child processes, Perl has reset the signal to its default value. This situation typically indicates that the parent program under which Perl may be running (e.g. cron) is being very careless.</source>
          <target state="translated">(W 신호) Perl은 SIGCHLD 신호 (SIGCLD라고도 함)가 비활성화 된 상태에서 실행되고 있음을 감지했습니다. 이 신호를 비활성화하면 하위 프로세스의 종료 상태를 올바르게 결정하는 데 방해가되기 때문에 Perl은 신호를 기본값으로 재설정했습니다. 이 상황은 일반적으로 Perl이 실행되는 상위 프로그램 (예 : cron)이 매우 부주의하다는 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d36a3561d6f20cf601cc8fdcd8a0b693b632d4af" translate="yes" xml:space="preserve">
          <source>(W signal) The signal handler named in %SIG doesn't, in fact, exist. Perhaps you put it into the wrong package?</source>
          <target state="translated">(W 신호) % SIG로 명명 된 신호 처리기는 실제로 존재하지 않습니다. 아마도 당신은 그것을 잘못된 패키지에 넣었습니까?</target>
        </trans-unit>
        <trans-unit id="ebc35d5a02e4c063b197676d1cbd12f47c19df5b" translate="yes" xml:space="preserve">
          <source>(W signal) You specified a signal name as a subscript to %SIG that was not recognized. Say &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -l&lt;/code&gt; in your shell to see the valid signal names on your system.</source>
          <target state="translated">(W 신호) 인식되지 않은 신호 이름을 % SIG의 첨자로 지정했습니다. 쉘에서 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -l&lt;/code&gt; 이라고 말하면 시스템에서 유효한 신호 이름을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95ce3889bdccfd28d07038434edbc2f2493245c4" translate="yes" xml:space="preserve">
          <source>(W substr) You supplied a reference as the first argument to substr() used as an lvalue, which is pretty strange. Perhaps you forgot to dereference it first. See &lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;.</source>
          <target state="translated">(W substr) lvalue로 사용 된 substr ()의 첫 번째 인수로 참조를 제공했습니다. 이는 매우 이상합니다. 아마도 당신은 그것을 먼저 역 참조하는 것을 잊었을 것입니다. &lt;a href=&quot;functions/substr&quot;&gt;substr을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="45bd593b8e5b2713b2a66073ce71b9f0acf28d3e" translate="yes" xml:space="preserve">
          <source>(W substr)(F) You tried to reference a substr() that pointed outside of a string. That is, the absolute value of the offset was larger than the length of the string. See &lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;. This warning is fatal if substr is used in an lvalue context (as the left hand side of an assignment or as a subroutine argument for example).</source>
          <target state="translated">(W substr) (F) 문자열 외부를 가리키는 substr ()을 참조하려고했습니다. 즉, 오프셋의 절대 값이 문자열의 길이보다 컸습니다. 보다&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt; . substr이 lvalue 컨텍스트에서 사용되는 경우 (할당의 왼쪽 또는 서브 루틴 인수로)이 경고는 치명적입니다.</target>
        </trans-unit>
        <trans-unit id="3d3783a27c8ae64e0627e00b19a488f16e27fa85" translate="yes" xml:space="preserve">
          <source>(W syntax) A format specified more picture fields than the next line supplied. See &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt;.</source>
          <target state="translated">(W 구문) 형식이 제공된 다음 행보다 많은 그림 필드를 지정했습니다. 보다&lt;a href=&quot;perlform&quot;&gt;perlform을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5675d244b6de72370cd69ca41f42a80de4dd6d27" translate="yes" xml:space="preserve">
          <source>(W syntax) An underscore (underbar) in a numeric constant did not separate two digits.</source>
          <target state="translated">(W 구문) 숫자 상수의 밑줄 (밑줄)은 두 자리를 분리하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="1928c9501e662b0f8de723a59ea0b97a4ece6c53" translate="yes" xml:space="preserve">
          <source>(W syntax) In an ordinary expression, backslash is a unary operator that creates a reference to its argument. The use of backslash to indicate a backreference to a matched substring is valid only as part of a regular expression pattern. Trying to do this in ordinary Perl code produces a value that prints out looking like SCALAR(0xdecaf). Use the $1 form instead.</source>
          <target state="translated">(W 구문) 일반 표현식에서 백 슬래시는 인수에 대한 참조를 작성하는 단항 연산자입니다. 일치하는 하위 문자열에 대한 역 참조를 나타내는 데 백 슬래시를 사용하는 것은 정규식 패턴의 일부로 만 유효합니다. 일반적인 Perl 코드에서이 작업을 시도하면 SCALAR (0xdecaf)와 같은 값이 인쇄됩니다. 대신 $ 1 양식을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8f8213e084e20348a91dcc660ab8e17dcde1e497" translate="yes" xml:space="preserve">
          <source>(W syntax) In scalar context, you've used a hash key/value slice (indicated by %) to select a single element of a hash. Generally it's better to ask for a scalar value (indicated by $). The difference is that &lt;code&gt;$foo{&amp;amp;bar}&lt;/code&gt; always behaves like a scalar, both in the value it returns and when evaluating its argument, while &lt;code&gt;@foo{&amp;amp;bar}&lt;/code&gt; and provides a list context to its subscript, which can do weird things if you're expecting only one subscript. When called in list context, it also returns the key in addition to the value.</source>
          <target state="translated">(W 구문) 스칼라 컨텍스트에서는 해시 키 / 값 슬라이스 (%로 표시)를 사용하여 해시의 단일 요소를 선택했습니다. 일반적으로 스칼라 값 ($로 표시)을 요청하는 것이 좋습니다. 차이점은 &lt;code&gt;$foo{&amp;amp;bar}&lt;/code&gt; 항상 반환하는 값과 인수를 평가할 때 스칼라처럼 동작하지만 &lt;code&gt;@foo{&amp;amp;bar}&lt;/code&gt; 는 첨자에 목록 컨텍스트를 제공하여 하나의 첨자를 기대합니다. 목록 컨텍스트에서 호출되면 값 외에도 키를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="139c16302575faefa44e53211603b79b770480b6" translate="yes" xml:space="preserve">
          <source>(W syntax) In scalar context, you've used an array index/value slice (indicated by %) to select a single element of an array. Generally it's better to ask for a scalar value (indicated by $). The difference is that &lt;code&gt;$foo[&amp;amp;bar]&lt;/code&gt; always behaves like a scalar, both in the value it returns and when evaluating its argument, while &lt;code&gt;%foo[&amp;amp;bar]&lt;/code&gt; provides a list context to its subscript, which can do weird things if you're expecting only one subscript. When called in list context, it also returns the index (what &lt;code&gt;&amp;amp;bar&lt;/code&gt; returns) in addition to the value.</source>
          <target state="translated">(W 구문) 스칼라 컨텍스트에서 배열 인덱스 / 값 슬라이스 (%로 표시)를 사용하여 배열의 단일 요소를 선택했습니다. 일반적으로 스칼라 값 ($로 표시)을 요청하는 것이 좋습니다. 차이점은 &lt;code&gt;$foo[&amp;amp;bar]&lt;/code&gt; 항상 반환하는 값과 인수를 평가할 때 스칼라처럼 동작하지만 &lt;code&gt;%foo[&amp;amp;bar]&lt;/code&gt; 는 첨자에 목록 컨텍스트를 제공합니다. 하나의 첨자를 기대합니다. 리스트 컨텍스트에서 호출되면 값과 함께 인덱스 ( &lt;code&gt;&amp;amp;bar&lt;/code&gt; 가 리턴하는 것)도 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="d8bea33901ad329853cff0f65df1ca724eb5c0d4" translate="yes" xml:space="preserve">
          <source>(W syntax) Multidimensional arrays aren't written like &lt;code&gt;$foo[1,2,3]&lt;/code&gt; . They're written like &lt;code&gt;$foo[1][2][3]&lt;/code&gt; , as in C.</source>
          <target state="translated">(W 구문) 다차원 배열은 &lt;code&gt;$foo[1,2,3]&lt;/code&gt; 처럼 작성되지 않습니다 . C 에서처럼 &lt;code&gt;$foo[1][2][3]&lt;/code&gt; 처럼 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="04868e0f94e46c3fd4ce21403945fec70d551ecb" translate="yes" xml:space="preserve">
          <source>(W syntax) Outside of patterns, backreferences live on as variables. The use of backslashes is grandfathered on the right-hand side of a substitution, but stylistically it's better to use the variable form because other Perl programmers will expect it, and it works better if there are more than 9 backreferences.</source>
          <target state="translated">(W 구문) 패턴 외부에서 역 참조는 변수로 존재합니다. 백 슬래시의 사용은 대체의 오른쪽에 할아버지가 있지만 문체 적으로 다른 Perl 프로그래머가 예상 할 수 있기 때문에 변수 형식을 사용하는 것이 좋으며 역 참조가 9 개 이상인 경우 더 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="86e02829ec2db0aad141e5ff8b7b48fa26969bba" translate="yes" xml:space="preserve">
          <source>(W syntax) The &lt;code&gt;\c&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; construct is intended to be a way to specify non-printable characters. You used it for a printable one, which is better written as simply itself, perhaps preceded by a backslash for non-word characters. Doing it the way you did is not portable between ASCII and EBCDIC platforms.</source>
          <target state="translated">(W 구문) &lt;code&gt;\c&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; 구문은 인쇄 할 수없는 문자를 지정하기위한 것입니다. 인쇄용으로 사용했는데, 단어 자체가 아닌 문자의 경우 백 슬래시가 앞에 오는 단순한 자체로 더 잘 작성되었습니다. ASCII와 EBCDIC 플랫폼 간에는 그렇게 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1e1aacc7413fa4819361698891a0668505640b7d" translate="yes" xml:space="preserve">
          <source>(W syntax) The @ISA array contained the name of another package that doesn't seem to exist.</source>
          <target state="translated">(W 구문) @ISA 배열에는 존재하지 않는 다른 패키지의 이름이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f851398285267cd295332fc573c6ef5e8844f07f" translate="yes" xml:space="preserve">
          <source>(W syntax) The localization of lvalues such as &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local($x=10)&lt;/a&gt;&lt;/code&gt; is legal, but in fact the local() currently has no effect. This may change at some point in the future, but in the meantime such code is discouraged.</source>
          <target state="translated">(W 구문) &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local($x=10)&lt;/a&gt;&lt;/code&gt; 과 같은 lvalue의 지역화 는 합법적이지만 실제로 local ()은 효과가 없습니다. 향후 언젠가 변경 될 수 있지만 그 동안 해당 코드는 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="868eed42e719045825fe91387bc9673310dc7aec" translate="yes" xml:space="preserve">
          <source>(W syntax) The non-matching operator is !~, not !=~. !=~ will be interpreted as the != (numeric not equal) and ~ (1's complement) operators: probably not what you intended.</source>
          <target state="translated">(W 구문) 일치하지 않는 연산자는! = ~가 아니라! ~입니다. ! = ~는! = (숫자가 같지 않음) 및 ~ (1의 보수) 연산자로 해석됩니다. 아마도 의도 한 것과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="aabd129f499f5ee7efbffa7af96de54720d08c45" translate="yes" xml:space="preserve">
          <source>(W syntax) The package variables $a and $b are used for sort comparisons. You used $a or $b in as an operand to the &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; or &lt;code&gt;cmp&lt;/code&gt; operator inside a sort comparison block, and the variable had earlier been declared as a lexical variable. Either qualify the sort variable with the package name, or rename the lexical variable.</source>
          <target state="translated">(W 구문) 패키지 변수 $ a 및 $ b는 정렬 비교에 사용됩니다. 정렬 비교 블록 내 에서 &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;cmp&lt;/code&gt; 연산자 의 피연산자로 $ a 또는 $ b를 사용 했으며 변수가 사전에 어휘 변수로 선언되었습니다. 패키지 이름으로 정렬 변수를 규정하거나 어휘 변수의 이름을 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="dc7dad0ebf00491f7af4d2d3eac617947a87a3f9" translate="yes" xml:space="preserve">
          <source>(W syntax) There is a possible problem with the mixing of a control flow operator (e.g. &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;) and a low-precedence operator like &lt;code&gt;or&lt;/code&gt; . Consider:</source>
          <target state="translated">(W 구문) 제어 흐름 연산자 (예 : &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; )와 &lt;code&gt;or&lt;/code&gt; 와 같은 우선 순위가 낮은 연산자의 혼합에 문제가있을 수 있습니다 . 치다:</target>
        </trans-unit>
        <trans-unit id="3163cc17558e27986562b985237677c957ba5433" translate="yes" xml:space="preserve">
          <source>(W syntax) You assigned a bareword as a signal handler name. Unfortunately, you already have a subroutine of that name declared, which means that Perl 5 will try to call the subroutine when the assignment is executed, which is probably not what you want. (If it IS what you want, put an &amp;amp; in front.)</source>
          <target state="translated">(W 구문) 신호 어 이름으로 베어 워드를 할당했습니다. 불행히도, 이미 그 이름의 서브 루틴이 선언되어 있습니다. 이는 할당이 실행될 때 Perl 5가 서브 루틴을 호출하려고 시도한다는 것을 의미합니다. (원하는 경우 &amp;amp;를 앞에 두십시오.)</target>
        </trans-unit>
        <trans-unit id="3f6363d73db132f7df27b47f3074c7aeebcfa96a" translate="yes" xml:space="preserve">
          <source>(W syntax) You have used a pattern where Perl expected to find a string, as in the first argument to &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt;. Perl will treat the true or false result of matching the pattern against $_ as the string, which is probably not what you had in mind.</source>
          <target state="translated">(W 구문) 첫 번째 인수 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 에서와 같이 Perl이 문자열을 찾을 것으로 예상되는 패턴을 사용했습니다 . 펄은 패턴과 $ _를 일치시키는 참 또는 거짓 결과를 문자열로 취급 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="9cd4a5c747e6ea0c6874c1cfe913ee77b669c12b" translate="yes" xml:space="preserve">
          <source>(W syntax) You said</source>
          <target state="translated">(W 구문) 당신은 말했다</target>
        </trans-unit>
        <trans-unit id="4d42f0406bbe7b69e8abda38fcb04298e09064a5" translate="yes" xml:space="preserve">
          <source>(W syntax) You used &lt;code&gt;$[&lt;/code&gt; in a comparison, such as:</source>
          <target state="translated">(W 구문) 다음과 같은 비교에서 &lt;code&gt;$[&lt;/code&gt; 를 사용 했습니다.</target>
        </trans-unit>
        <trans-unit id="33175e7b41467f7650bcaf1be588d001196cdd86" translate="yes" xml:space="preserve">
          <source>(W syntax) You used length() on either an array or a hash when you probably wanted a count of the items.</source>
          <target state="translated">(W 구문) 항목 수를 원할 때 배열이나 해시에서 length ()를 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="5612f1be811be95b9ea2e71d0bc87cb76a68fc16" translate="yes" xml:space="preserve">
          <source>(W syntax) You used the push() or unshift() function with no arguments apart from the array, like &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push(@x)&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift(@foo)&lt;/a&gt;&lt;/code&gt;. That won't usually have any effect on the array, so is completely useless. It's possible in principle that push(@tied_array) could have some effect if the array is tied to a class which implements a PUSH method. If so, you can write it as &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push(@tied_array,())&lt;/a&gt;&lt;/code&gt; to avoid this warning.</source>
          <target state="translated">(W 구문) &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push(@x)&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift(@foo)&lt;/a&gt;&lt;/code&gt; 와 같이 배열과 별도로 인수없이 push () 또는 unshift () 함수를 사용했습니다 . 그것은 일반적으로 배열에 영향을 미치지 않으므로 완전히 쓸모가 없습니다. 배열이 PUSH 메소드를 구현하는 클래스에 묶여 있으면 push (@tied_array)가 원칙적으로 영향을 줄 수 있습니다. 그렇다면 이 경고를 피하기 위해 &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push(@tied_array,())&lt;/a&gt;&lt;/code&gt; 로 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9d9cf6e3535b5c2226e9e739821bfc01062bb73b" translate="yes" xml:space="preserve">
          <source>(W syntax) You wrote your assignment operator backwards. The = must always come last, to avoid ambiguity with subsequent unary operators.</source>
          <target state="translated">(W 구문) 할당 연산자를 거꾸로 썼습니다. 후속 단항 연산자의 모호성을 피하려면 =는 항상 마지막에 와야합니다.</target>
        </trans-unit>
        <trans-unit id="0988dc3825f261bfe7e6ca09e93a7ef79f9698f8" translate="yes" xml:space="preserve">
          <source>(W syntax) You've run afoul of the rule that says that any list operator followed by parentheses turns into a function, with all the list operators arguments found inside the parentheses. See &lt;a href=&quot;perlop#Terms-and-List-Operators-(Leftward)&quot;&gt;Terms and List Operators (Leftward) in perlop&lt;/a&gt;.</source>
          <target state="translated">(W 구문) 괄호 안에있는 모든 목록 연산자와 괄호 안에있는 모든 연산자는 괄호 안에있는 모든 목록 연산자 인수와 함께 함수로 바뀐다는 규칙에 위배됩니다. &lt;a href=&quot;perlop#Terms-and-List-Operators-(Leftward)&quot;&gt;perlop의 용어 및 목록 연산자 (왼쪽)를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8e677e4399169ad9de0bcb39499a466a52862aad" translate="yes" xml:space="preserve">
          <source>(W syntax) You've used a hash slice (indicated by @) to select a single element of a hash. Generally it's better to ask for a scalar value (indicated by $). The difference is that &lt;code&gt;$foo{&amp;amp;bar}&lt;/code&gt; always behaves like a scalar, both when assigning to it and when evaluating its argument, while &lt;code&gt;@foo{&amp;amp;bar}&lt;/code&gt; behaves like a list when you assign to it, and provides a list context to its subscript, which can do weird things if you're expecting only one subscript.</source>
          <target state="translated">(W 구문) 해시 슬라이스 (@로 표시)를 사용하여 해시의 단일 요소를 선택했습니다. 일반적으로 스칼라 값 ($로 표시)을 요청하는 것이 좋습니다. 차이점은 &lt;code&gt;$foo{&amp;amp;bar}&lt;/code&gt; 항상 스칼라처럼 행동하며, 인수를 할당 할 때와 인수를 평가할 때 모두 &lt;code&gt;@foo{&amp;amp;bar}&lt;/code&gt; 는 그것을 할당 할 때리스트처럼 행동하고 첨자에리스트 컨텍스트를 제공한다는 것입니다 아래 첨자를 하나만 기대하면 이상한 일을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95b0a75562e174b2496250be14ddc21db7f4d104" translate="yes" xml:space="preserve">
          <source>(W syntax) You've used an array slice (indicated by @) to select a single element of an array. Generally it's better to ask for a scalar value (indicated by $). The difference is that &lt;code&gt;$foo[&amp;amp;bar]&lt;/code&gt; always behaves like a scalar, both when assigning to it and when evaluating its argument, while &lt;code&gt;@foo[&amp;amp;bar]&lt;/code&gt; behaves like a list when you assign to it, and provides a list context to its subscript, which can do weird things if you're expecting only one subscript.</source>
          <target state="translated">(W 구문) 배열 슬라이스 (@로 표시)를 사용하여 배열의 단일 요소를 선택했습니다. 일반적으로 스칼라 값 ($로 표시)을 요청하는 것이 좋습니다. 차이점은 &lt;code&gt;$foo[&amp;amp;bar]&lt;/code&gt; 항상 스칼라처럼 행동하며, 인수 를 지정할 때와 인수를 평가할 때 모두 &lt;code&gt;@foo[&amp;amp;bar]&lt;/code&gt; 는 그것을 할당 할 때리스트처럼 행동하고 첨자에리스트 컨텍스트를 제공한다는 것입니다 아래 첨자를 하나만 기대하면 이상한 일을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="641f51994699613e1549f7ef209d11a26e2b585e" translate="yes" xml:space="preserve">
          <source>(W syscalls) Embedded \0 characters in pathnames or other system call arguments produce a warning as of 5.20. The parts after the \0 were formerly ignored by system calls.</source>
          <target state="translated">(W syscalls) 경로 이름 또는 기타 시스템 호출 인수에 \ 0 문자가 포함되어 있으면 5.20부터 경고가 생성됩니다. \ 0 이후의 부분은 이전에 시스템 호출로 무시되었습니다.</target>
        </trans-unit>
        <trans-unit id="eea1d51b89def0acf7f618b47547913acc879ac7" translate="yes" xml:space="preserve">
          <source>(W taint, deprecated) You have supplied &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; with multiple arguments and at least one of them is tainted. This used to be allowed but will become a fatal error in a future version of perl. Untaint your arguments. See &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;.</source>
          <target state="translated">(W taint, deprecated) &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; 에 여러 개의 인수를 제공했으며 그 중 하나 이상이 오염되었습니다. 이것은 허용되었지만 이후 버전의 펄에서는 치명적인 오류가 될 것입니다. 당신의 주장을 억제하십시오. &lt;a href=&quot;perlsec&quot;&gt;perlsec을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="87212ba40dbca26f039d3c5f4668d06844b8cebb" translate="yes" xml:space="preserve">
          <source>(W uninitialized) An undefined value was used as if it were already defined. It was interpreted as a &quot;&quot; or a 0, but maybe it was a mistake. To suppress this warning assign a defined value to your variables.</source>
          <target state="translated">(W 초기화되지 않음) 정의되지 않은 값이 이미 정의 된 것처럼 사용되었습니다. &quot;&quot;또는 0으로 해석되었지만 실수 일 수 있습니다. 이 경고를 표시하지 않으려면 정의 된 값을 변수에 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="c21109fd4c9277652f34f7607902e64df01bc950" translate="yes" xml:space="preserve">
          <source>(W unopened) An I/O operation was attempted on a filehandle that was never initialized. You need to do an open(), a sysopen(), or a socket() call, or call a constructor from the FileHandle package.</source>
          <target state="translated">(W 열리지 않음) 초기화되지 않은 파일 핸들에서 I / O 작업을 시도했습니다. open (), sysopen () 또는 socket () 호출을 수행하거나 FileHandle 패키지에서 생성자를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="9d13ce165320d52b11e43e90a5f319b3dff07700" translate="yes" xml:space="preserve">
          <source>(W unopened) You tried binmode() on a filehandle that was never opened. Check your control flow and number of arguments.</source>
          <target state="translated">(열리지 않은) 열린 적이없는 파일 핸들에서 binmode ()를 시도했습니다. 제어 흐름과 인수 수를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="33254325809ca0f089876420266f8d46dd3cd36e" translate="yes" xml:space="preserve">
          <source>(W unopened) You tried ioctl() on a filehandle that was never opened. Check your control flow and number of arguments.</source>
          <target state="translated">(열리지 않은) 열린 적이없는 파일 핸들에서 ioctl ()을 시도했습니다. 제어 흐름과 인수 수를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="aecaf35d1f0c4447f15709cfdd62df13ce2bfd7b" translate="yes" xml:space="preserve">
          <source>(W unopened) You tried to close a filehandle that was never opened.</source>
          <target state="translated">(열리지 않은 상태) 열지 않은 파일 핸들을 닫으려고했습니다.</target>
        </trans-unit>
        <trans-unit id="dc1d8c0f0b969290f1a5f95acb33bce413ff9ddb" translate="yes" xml:space="preserve">
          <source>(W unopened) You tried to invoke a file test operator on a filehandle that isn't open. Check your control flow. See also &lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;.</source>
          <target state="translated">(열리지 않은 상태) 열려 있지 않은 파일 핸들에서 파일 테스트 연산자를 호출하려고했습니다. 제어 흐름을 확인하십시오. &lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4ba59f97dfd212a4396e40fc430b085c942e206e" translate="yes" xml:space="preserve">
          <source>(W unopened) You tried to read from a filehandle that was never opened.</source>
          <target state="translated">(열리지 않은 상태) 열린 적이없는 파일 핸들에서 읽으려고했습니다.</target>
        </trans-unit>
        <trans-unit id="7ca18c8e0d35c1b1ba436b62ea346403c379a134" translate="yes" xml:space="preserve">
          <source>(W unopened) You tried to use the seek() or sysseek() function on a filehandle that was either never opened or has since been closed.</source>
          <target state="translated">(열리지 않은 상태) 열리지 않았거나 닫힌 파일 핸들에서 seek () 또는 sysseek () 함수를 사용하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="a687149754f7310ab9223be0e7d36b0c518b5d3d" translate="yes" xml:space="preserve">
          <source>(W unopened) You tried to use the stat() function on a filehandle that was either never opened or has since been closed.</source>
          <target state="translated">(열리지 않은 상태) 열지 않았거나 닫힌 파일 핸들에서 stat () 함수를 사용하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="7d9b36aee9bb72aee190203d53735cc95832569f" translate="yes" xml:space="preserve">
          <source>(W unopened) You tried to use the tell() function on a filehandle that was either never opened or has since been closed.</source>
          <target state="translated">(열리지 않은 상태) 열리지 않았거나 닫힌 파일 핸들에서 tell () 함수를 사용하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="b0b2a4cea9ad3f14457445c6831b6e0a484b46c2" translate="yes" xml:space="preserve">
          <source>(W unpack) You have applied the same modifier more than once after a type in a pack template. See &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;.</source>
          <target state="translated">(W 압축 풀기) 팩 템플릿에서 유형을 지정한 후 동일한 수정자를 두 번 이상 적용했습니다. &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c76fe56910f2e01af3e35d2cf6edcb6541e9310e" translate="yes" xml:space="preserve">
          <source>(W unpack) You tried something like</source>
          <target state="translated">(W unpack) 당신은 같은 것을 시도</target>
        </trans-unit>
        <trans-unit id="f8d42c367e5bdfdeea5af0d3e04a3e7a34f2c9f5" translate="yes" xml:space="preserve">
          <source>(W untie) A copy of the object returned from &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;functions/tied&quot;&gt;tied&lt;/a&gt;&lt;/code&gt;) was still valid when &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; was called.</source>
          <target state="translated">(W untie) &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; (또는 &lt;code&gt;&lt;a href=&quot;functions/tied&quot;&gt;tied&lt;/a&gt;&lt;/code&gt; ) 에서 반환 된 객체의 사본은 &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; 가 호출 될 때 여전히 유효했습니다 .</target>
        </trans-unit>
        <trans-unit id="46f9020a7dcd787c1bf1b13be87c622895afbd82" translate="yes" xml:space="preserve">
          <source>(W utf8) You passed a negative number to &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;. Negative numbers are not valid character numbers, so it returns the Unicode replacement character (U+FFFD).</source>
          <target state="translated">(W utf8) &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; 에 음수를 전달했습니다 . 음수는 유효한 문자 번호가 아니므로 유니 코드 대체 문자 (U + FFFD)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="66ebf288df73553c4980b27e84deb25ec3183f3c" translate="yes" xml:space="preserve">
          <source>(W utf8) You tried to open a reference to a scalar for read or append where the scalar contained code points over 0xFF. In-memory files model on-disk files and can only contain bytes.</source>
          <target state="translated">(W utf8) 스칼라에 0xFF 이상의 코드 포인트가 포함 된 읽기 또는 추가를 위해 스칼라에 대한 참조를 열려고했습니다. 인 메모리 파일은 디스크 파일을 모델링하며 바이트 만 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8848dabe5fdd98b21a0c9d16e12de50ff0059dae" translate="yes" xml:space="preserve">
          <source>(W void) A CHECK or INIT block is being defined during run time proper, when the opportunity to run them has already passed. Perhaps you are loading a file with &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; when you should be using &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; instead. Or perhaps you should put the &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; inside a BEGIN block.</source>
          <target state="translated">(W void) CHECK 또는 INIT 블록은 실행 기회가 이미 지나갔을 때 적절한 런타임 중에 정의됩니다. 아마도 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 를 사용해야 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 때 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 또는 do 로 파일을로드하고 있을 것입니다. 또는 BEGIN 블록 안에 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 넣거나 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="90db3f1351f4d1a7f3df67accb71dce113e606f5" translate="yes" xml:space="preserve">
          <source>(W void) You did something without a side effect in a context that does nothing with the return value, such as a statement that doesn't return a value from a block, or the left side of a scalar comma operator. Very often this points not to stupidity on your part, but a failure of Perl to parse your program the way you thought it would. For example, you'd get this if you mixed up your C precedence with Python precedence and said</source>
          <target state="translated">(W void) 블록에서 값을 리턴하지 않는 명령문 또는 스칼라 쉼표 연산자의 왼쪽과 같이 리턴 값으로 아무것도 수행하지 않는 컨텍스트에서 부작용이없는 작업을 수행했습니다. 종종 이것은 당신의 어리 석음이 아니라 Perl이 당신이 생각한 방식으로 프로그램을 파싱하지 않는 것을 지적합니다. 예를 들어 C 우선 순위를 Python 우선 순위와 혼합하여 말했다면</target>
        </trans-unit>
        <trans-unit id="8c28b024772920f2fbe93cb3859bc1a02354768f" translate="yes" xml:space="preserve">
          <source>(W void) You used sort in scalar context, as in :</source>
          <target state="translated">(W void) 다음과 같이 스칼라 컨텍스트에서 정렬을 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="d2694030ac2d81eb103264e70e38e170506566bf" translate="yes" xml:space="preserve">
          <source>(W) &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; was passed an argument it did not recognize. Did you mistype an operator?</source>
          <target state="translated">(W) &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; 가 인식하지 못하는 인수를 전달했습니다. 연산자를 잘못 입력 했습니까?</target>
        </trans-unit>
        <trans-unit id="21016a542724c1bfad5e9b7a16b1394b21adc2e5" translate="yes" xml:space="preserve">
          <source>(W) Pod::PlainText encountered a &lt;code&gt;=back&lt;/code&gt; command that didn't correspond to an &lt;code&gt;=over&lt;/code&gt; command.</source>
          <target state="translated">(W) Pod :: PlainText가 &lt;code&gt;=over&lt;/code&gt; 명령에 해당하지 않는 &lt;code&gt;=back&lt;/code&gt; 명령을 발견했습니다 .</target>
        </trans-unit>
        <trans-unit id="26bfb80fa009b521734a344e5a06b87f176f5beb" translate="yes" xml:space="preserve">
          <source>(W) Something has gone wrong in internal &lt;code&gt;=item&lt;/code&gt; processing. These messages indicate a bug in Pod::Text; you should never see them.</source>
          <target state="translated">(W) 내부 &lt;code&gt;=item&lt;/code&gt; 처리에 문제가 있습니다. 이 메시지는 Pod :: Text의 버그를 나타냅니다. 당신은 그들을 보지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="501975fffba0edbf57d1160976c85133c54a7baf" translate="yes" xml:space="preserve">
          <source>(W) Something has gone wrong in internal &lt;code&gt;=item&lt;/code&gt; processing. This message indicates a bug in Pod::PlainText; you should never see it.</source>
          <target state="translated">(W) 내부 &lt;code&gt;=item&lt;/code&gt; 처리에 문제가 있습니다. 이 메시지는 Pod :: PlainText의 버그를 나타냅니다. 당신은 그것을 보지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="c30dd949e9f2b3a1878daa9c110c45e03e38a3c9" translate="yes" xml:space="preserve">
          <source>(W) The POD source contained a non-standard internal sequence (something of the form &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; ) that Pod::PlainText didn't know about.</source>
          <target state="translated">(W) POD 소스 에 Pod :: PlainText가 알지 못하는 비표준 내부 시퀀스 ( &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; 형식 )가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea328e676adcf58b0759f1c04dd7eec880ac50e0" translate="yes" xml:space="preserve">
          <source>(W) The POD source contained an &lt;code&gt;E&amp;lt;&amp;gt;&lt;/code&gt; escape that Pod::PlainText didn't know about.</source>
          <target state="translated">(W) POD 소스 에 Pod :: PlainText가 알지 못한 &lt;code&gt;E&amp;lt;&amp;gt;&lt;/code&gt; 이스케이프가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a887755cdd505b29af6782ffbf2c58e91dc679f" translate="yes" xml:space="preserve">
          <source>(W) The call to overload::constant contained an odd number of arguments. The arguments should come in pairs.</source>
          <target state="translated">(W) overload :: constant 호출에 홀수 개의 인수가 포함되었습니다. 인수는 쌍을 이루어야합니다.</target>
        </trans-unit>
        <trans-unit id="70cde34602e73ad7fd4f730db8c2bcf41f111987" translate="yes" xml:space="preserve">
          <source>(W) The given character is not a valid pack or unpack type but used to be silently ignored.</source>
          <target state="translated">(W) 지정된 캐릭터가 유효한 팩 또는 언팩 타입은 아니지만 자동 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="e14f1e6bfcb9badd4f5af39b1f5de336049edc31" translate="yes" xml:space="preserve">
          <source>(W) The same, but in ANSI_COLORS_ALIASES. The color mapping was ignored.</source>
          <target state="translated">(W) 동일하지만 ANSI_COLORS_ALIASES. 색상 매핑이 무시되었습니다.</target>
        </trans-unit>
        <trans-unit id="d96a0ecd53e817b1ae2d676c0119d14bcfa595eb" translate="yes" xml:space="preserve">
          <source>(W) The second (fourth, sixth, ...) argument of overload::constant needs to be a code reference. Either an anonymous subroutine, or a reference to a subroutine.</source>
          <target state="translated">(W) overload :: constant의 두 번째 (4 번째, 6 번째, ...) 인수는 코드 참조 여야합니다. 익명 서브 루틴 또는 서브 루틴에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="5eb1c96d7547fa58d3105399dbdfb8e95f920587" translate="yes" xml:space="preserve">
          <source>(W) The specified color mapping from ANSI_COLORS_ALIASES is not valid and could not be parsed. It was ignored.</source>
          <target state="translated">(W) ANSI_COLORS_ALIASES에서 지정된 색상 매핑이 유효하지 않아 파싱 할 수 없습니다. 무시되었습니다.</target>
        </trans-unit>
        <trans-unit id="8acaee73233dd30d36c968a81b33d5c8ccba7c36" translate="yes" xml:space="preserve">
          <source>(W) This is a standard message issued by OS/2 applications, while *nix applications die in silence. It is considered a feature of the OS/2 port. One can easily disable this by appropriate sighandlers, see &lt;a href=&quot;perlipc#Signals&quot;&gt;Signals in perlipc&lt;/a&gt;. See also &quot;Process terminated by SIGTERM/SIGINT&quot; in &lt;a href=&quot;perlos2&quot;&gt;perlos2&lt;/a&gt;.</source>
          <target state="translated">(W) 이것은 OS / 2 어플리케이션이 발행 한 표준 메시지이며 * nix 어플리케이션은 침묵합니다. OS / 2 포트의 기능으로 간주됩니다. 적절한 sighandler에 의해이를 쉽게 비활성화 할 수 있습니다 (perlipc의 &lt;a href=&quot;perlipc#Signals&quot;&gt;신호&lt;/a&gt; 참조) . &lt;a href=&quot;perlos2&quot;&gt;perlos2의&lt;/a&gt; &quot;SIGTERM / SIGINT에 의해 종료 된 프로세스&quot;도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1c10232da8d5a7a1db96c9e95d4de6579ffb3dcc" translate="yes" xml:space="preserve">
          <source>(W) This warning may be due to running a perl5 script through a perl4 interpreter, especially if the word that is being warned about is &quot;use&quot; or &quot;my&quot;.</source>
          <target state="translated">(W)이 경고는 perl4 인터프리터를 통해 perl5 스크립트를 실행했을 때, 특히 경고중인 단어가 &quot;사용&quot;또는 &quot;my&quot;인 경우에 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1212f80ef134690b670704c90585c6d0920a4a27" translate="yes" xml:space="preserve">
          <source>(W) You did &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re;&lt;/code&gt; without any arguments. That isn't very useful.</source>
          <target state="translated">(W) 당신은 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re;&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용했습니다&lt;/a&gt; . 논쟁없이 그다지 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e38b2fa8496c1774dd31b2c5fdb79143f6d43dd2" translate="yes" xml:space="preserve">
          <source>(W) You passed warn() an empty string (the equivalent of &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt; &quot;&quot;&lt;/code&gt; ) or you called it with no args and &lt;code&gt;$@&lt;/code&gt; was empty.</source>
          <target state="translated">(W) warn ()을 빈 문자열 ( &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt; &quot;&quot;&lt;/code&gt; 과 동일 )에 전달했거나 인수없이 호출했으며 &lt;code&gt;$@&lt;/code&gt; 가 비어있었습니다.</target>
        </trans-unit>
        <trans-unit id="fc9c0aa78325e04e4fc87ad0e353fe824600632f" translate="yes" xml:space="preserve">
          <source>(W) You probably mistyped a constant color name such as:</source>
          <target state="translated">(W) 다음과 같은 일정한 색상 이름을 잘못 입력했을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ad31e97078c78dbc2769be19839fd69cffdfd38" translate="yes" xml:space="preserve">
          <source>(W) You probably said %hash{$key} when you meant $hash{$key} or @hash{@keys}. On the other hand, maybe you just meant %hash and got carried away.</source>
          <target state="translated">(W) 아마도 $ hash {$ key} 또는 @hash {@keys}를 의미 할 때 % hash {$ key}라고 말했을 것입니다. 반면에, 아마도 당신은 % hash를 의미하고 쫓겨 났을 것입니다.</target>
        </trans-unit>
        <trans-unit id="3978bcd1515ac8ee88075eadc0c3770c9967d932" translate="yes" xml:space="preserve">
          <source>(W) You specified an invalid alias name on the left hand of the equal sign in a color mapping in ANSI_COLORS_ALIASES. The color mapping was ignored.</source>
          <target state="translated">(W) ANSI_COLORS_ALIASES의 색상 매핑에서 등호 왼쪽에 잘못된 별칭 이름을 지정했습니다. 색상 매핑이 무시되었습니다.</target>
        </trans-unit>
        <trans-unit id="1568d1a0f3b426e26a4ff1c09af9fd2ef4f0d8e9" translate="yes" xml:space="preserve">
          <source>(W) You specified an invalid attribute name on the right hand of the equal sign in a color mapping in ANSI_COLORS_ALIASES. The color mapping was ignored.</source>
          <target state="translated">(W) ANSI_COLORS_ALIASES의 색상 매핑에서 등호 오른쪽에 잘못된 속성 이름을 지정했습니다. 색상 매핑이 무시되었습니다.</target>
        </trans-unit>
        <trans-unit id="66c0aa947d58238ebc42c6ae5df6940103cf64ea" translate="yes" xml:space="preserve">
          <source>(W) You tried to overload a constant type the overload package is unaware of.</source>
          <target state="translated">(W) 과부하 패키지가 인식하지 못하는 상수 유형을 과부하하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="e6c02830c69ec718530355cc9c731ec126bc1ac4" translate="yes" xml:space="preserve">
          <source>(W) You tried to use an unknown subpragma of the &quot;re&quot; pragma.</source>
          <target state="translated">(W) &quot;re&quot;pragma의 알 수없는 서브 프라그 마를 사용하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="237221ab401f92d00b4b13fe24041204327569ad" translate="yes" xml:space="preserve">
          <source>(We use $^X in these examples because it's tainted by default.)</source>
          <target state="translated">(이 예제에서는 기본적으로 오염되어 있기 때문에 $ ^ X를 사용합니다.)</target>
        </trans-unit>
        <trans-unit id="ff0ae87e96bc4227f275a775529e881f38d9f545" translate="yes" xml:space="preserve">
          <source>(We used our knowledge that input conversion for &lt;code&gt;char *&lt;/code&gt; is a &quot;simple&quot; one, thus &lt;code&gt;host&lt;/code&gt; is initialized on the declaration line, and our assignment &lt;code&gt;h = host&lt;/code&gt; is not performed too early. Otherwise one would need to have the assignment &lt;code&gt;h = host&lt;/code&gt; in a CODE: or INIT: section.)</source>
          <target state="translated">(우리는 &lt;code&gt;char *&lt;/code&gt; 에 대한 입력 변환 이 &quot;간단한&quot;것으로 알고 있었 으므로 선언 행에서 &lt;code&gt;host&lt;/code&gt; 가 초기화되고 할당 &lt;code&gt;h = host&lt;/code&gt; 가 너무 일찍 수행되지 않습니다. 그렇지 않으면 할당 &lt;code&gt;h = host&lt;/code&gt; 가 필요 합니다 CODE : 또는 INIT : 섹션에 있습니다.)</target>
        </trans-unit>
        <trans-unit id="cfc6665de88f1833c4368f0118d03017f3a21353" translate="yes" xml:space="preserve">
          <source>(When dealing with floating-point comparisons, it is best to not check for equality, but rather that the difference between the expected and actual result is below a certain amount (called epsilon) which is 0.01 in this case)</source>
          <target state="translated">(부동 소수점 비교를 처리 할 때는 동등성을 확인하는 것이 가장 좋지만 예상 결과와 실제 결과의 차이가이 경우 0.01 인 엡실론이라고하는 특정 양 미만인 경우)</target>
        </trans-unit>
        <trans-unit id="ccac8451a2611ae759c9faf841bb5018f12b19d2" translate="yes" xml:space="preserve">
          <source>(Where BASEEXT is the last component of NAME, and OBJ_EXT is $Config{obj_ext}.)</source>
          <target state="translated">(BASEEXT는 NAME의 마지막 구성 요소이고 OBJ_EXT는 $ Config {obj_ext}입니다.)</target>
        </trans-unit>
        <trans-unit id="e02fb51bf8e3169540ecbf91f4d22e75cb7830a9" translate="yes" xml:space="preserve">
          <source>(Where BASEEXT is the last component of NAME.)</source>
          <target state="translated">(BASEEXT는 NAME의 마지막 구성 요소입니다.)</target>
        </trans-unit>
        <trans-unit id="d0de3cd68244c0838e032c884108802a5c0e7328" translate="yes" xml:space="preserve">
          <source>(Why do we have separate numeric and string comparisons? Because we don't have special variable types, and Perl needs to know whether to sort numerically (where 99 is less than 100) or alphabetically (where 100 comes before 99).</source>
          <target state="translated">(왜 우리는 별도의 숫자와 문자열 비교를해야합니까? 특수 변수 유형이 없기 때문에 Perl은 숫자 (99는 100보다 작은 경우) 또는 알파벳순 (100은 99보다 먼저 나오는 경우)을 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="c3a762aeddeefdae150565438093ccaddaaf9aad" translate="yes" xml:space="preserve">
          <source>(X) A general assertion failed. The file in question must be examined.</source>
          <target state="translated">(X) 일반 주장이 실패했습니다. 해당 파일을 검사해야합니다.</target>
        </trans-unit>
        <trans-unit id="d6a423c5d83c10add2738bacaabc87962a7da812" translate="yes" xml:space="preserve">
          <source>(X) An attempt was made to extend an array, a list, or a string beyond the largest possible memory allocation.</source>
          <target state="translated">(X) 가능한 최대 메모리 할당을 넘어 배열, 목록 또는 문자열을 확장하려고 시도했습니다.</target>
        </trans-unit>
        <trans-unit id="28dc575d7faf81030a7009c3890586ad0bfb13c7" translate="yes" xml:space="preserve">
          <source>(X) See &lt;a href=&quot;perlrun#PERL_SIGNALS&quot;&gt;PERL_SIGNALS in perlrun&lt;/a&gt; for legal values.</source>
          <target state="translated">(X) 유효한 값 &lt;a href=&quot;perlrun#PERL_SIGNALS&quot;&gt;은 perlrun의 PERL_SIGNALS를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="25eb4cc27ccccf735eed888542e4498eb2a2aa6d" translate="yes" xml:space="preserve">
          <source>(X) The #! line (or local equivalent) in a Perl script contains the &lt;b&gt;-M&lt;/b&gt;, &lt;b&gt;-m&lt;/b&gt; or &lt;b&gt;-C&lt;/b&gt; option.</source>
          <target state="translated">(X) #! Perl 스크립트의 line (또는 local equivalent)은 &lt;b&gt;-M&lt;/b&gt; , &lt;b&gt;-m&lt;/b&gt; 또는 &lt;b&gt;-C&lt;/b&gt; 옵션을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="04d47aff5005157bb16498793c9ad8c2d7a871aa" translate="yes" xml:space="preserve">
          <source>(X) The #! line (or local equivalent) in a Perl script contains the &lt;b&gt;-T&lt;/b&gt; option (or the &lt;b&gt;-t&lt;/b&gt; option), but Perl was not invoked with &lt;b&gt;-T&lt;/b&gt; in its command line. This is an error because, by the time Perl discovers a &lt;b&gt;-T&lt;/b&gt; in a script, it's too late to properly taint everything from the environment. So Perl gives up.</source>
          <target state="translated">(X) #! Perl 스크립트의 line (또는 local equivalent)은 &lt;b&gt;-T&lt;/b&gt; 옵션 (또는 &lt;b&gt;-t&lt;/b&gt; 옵션)을 포함하지만 Perl은 명령 행에서 &lt;b&gt;-T&lt;/b&gt; 로 호출되지 않았습니다 . 이것은 Perl 이 스크립트에서 &lt;b&gt;-T&lt;/b&gt; 를 발견 할 때 환경에서 모든 것을 제대로 손상 시키기에는 너무 늦기 때문에 오류 입니다. 그래서 펄은 포기합니다.</target>
        </trans-unit>
        <trans-unit id="7d13ded5daf490cc1bc8bb6b0cd74a13b6c46c88" translate="yes" xml:space="preserve">
          <source>(X) The PERL5OPT environment variable may only be used to set the following switches: &lt;b&gt;-[CDIMUdmtw]&lt;/b&gt;.</source>
          <target state="translated">(X) PERL5OPT 환경 변수는 다음 스위치를 설정하는 데만 사용할 수 있습니다 &lt;b&gt;.-[CDIMUdmtw]&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="8e8047249d025e2fe0c43d96f901bbedf4764fe8" translate="yes" xml:space="preserve">
          <source>(X) The malloc package that comes with Perl had an internal failure.</source>
          <target state="translated">(X) Perl과 함께 제공되는 malloc 패키지에 내부 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="65871f11cf57af573de156d366a86250bc7c9d6a" translate="yes" xml:space="preserve">
          <source>(X) The malloc() function returned 0, indicating there was insufficient remaining memory (or virtual memory) to satisfy the request. Perl has no option but to exit immediately.</source>
          <target state="translated">(X) malloc () 함수가 0을 리턴하여 요청을 충족시키기에 메모리 (또는 가상 메모리)가 충분하지 않음을 나타냅니다. Perl은 즉시 종료 할 수 밖에 없습니다.</target>
        </trans-unit>
        <trans-unit id="74578166360f01e0bd318023e9280f6c6b8eeab2" translate="yes" xml:space="preserve">
          <source>(X) You can't allocate more than 64K on an MS-DOS machine.</source>
          <target state="translated">(X) MS-DOS 시스템에서 64K를 초과하여 할당 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d5e67ac60b668e8e894b678df3573f0eedbd9863" translate="yes" xml:space="preserve">
          <source>(X)(F) The malloc() function returned 0, indicating there was insufficient remaining memory (or virtual memory) to satisfy the request.</source>
          <target state="translated">(X) (F) malloc () 함수가 0을 리턴하여 요청을 충족시키기에 메모리 (또는 가상 메모리)가 충분하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0aa007c669bc8d719d70515c0e663390b1a05031" translate="yes" xml:space="preserve">
          <source>(Yes, I know this function is named a bit oddly. Call it historic reasons.)</source>
          <target state="translated">(예,이 기능의 이름이 조금 이상하다는 것을 알고 있습니다. 역사적인 이유라고 부릅니다.)</target>
        </trans-unit>
        <trans-unit id="8eb8ab7981d2a7c45a30aad058d8576bb511d1b4" translate="yes" xml:space="preserve">
          <source>(Yes, we know that some of these OSes may fall under the Unix category, but we are not a standards body.)</source>
          <target state="translated">(예, 우리는 이러한 OS 중 일부가 유닉스 범주에 속할 수 있지만 표준 기관이 아님을 알고 있습니다.)</target>
        </trans-unit>
        <trans-unit id="a64a87faab12fe29e48406c908901fff7a63848d" translate="yes" xml:space="preserve">
          <source>(You can force portability by specifying a Unicode range, which means that the endpoints are specified by &lt;a href=&quot;perlrecharclass#Character-Ranges&quot;&gt;\N{...} &lt;/a&gt;, but the meaning may still not be obvious.) The stricter rules require that ranges that start or stop with an ASCII character that is not a control have all their endpoints be the literal character, and not some escape sequence (like &lt;code&gt;&quot;\x41&quot;&lt;/code&gt; ), and the ranges must be all digits, or all uppercase letters, or all lowercase letters.</source>
          <target state="translated">(엔드 포인트가 &lt;a href=&quot;perlrecharclass#Character-Ranges&quot;&gt;\ N {...}에&lt;/a&gt; 의해 지정됨을 의미하는 유니 코드 범위를 지정하여 이식성을 강제 할 수 있지만 그 의미는 여전히 명확하지 않을 수 있습니다.) 더 엄격한 규칙은 ASCII로 시작하거나 중지하는 범위를 요구합니다. 제어가 아닌 문자는 모든 엔드 포인트가 리터럴 문자이며 이스케이프 시퀀스 (예 : &lt;code&gt;&quot;\x41&quot;&lt;/code&gt; )가 아니며 범위는 모든 숫자, 모든 대문자 또는 모든 소문자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="40103a04e475e9541eab1f3aaae6dd08be353894" translate="yes" xml:space="preserve">
          <source>(You can't just say &lt;code&gt;$ENV{$key} = $ENV{$key}&lt;/code&gt; , since the Perl optimizer is smart enough to elide the expression.)</source>
          <target state="translated">Perl 옵티마이 저가 표현식을 제거하기에 충분히 똑똑하기 때문에 &lt;code&gt;$ENV{$key} = $ENV{$key}&lt;/code&gt; 만 말할 수는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="102826bc7aefa33ccb389fa417f4b040a4a419e3" translate="yes" xml:space="preserve">
          <source>(You can, of course, specify single characters by using, &lt;code&gt;\x{...}&lt;/code&gt; , &lt;code&gt;\N{...}&lt;/code&gt; , etc.)</source>
          <target state="translated">(물론 &lt;code&gt;\x{...}&lt;/code&gt; , &lt;code&gt;\N{...}&lt;/code&gt; 등 을 사용하여 단일 문자를 지정할 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="e54f3a24beb63ca6443b7641e7e1af7bcf5e3c2b" translate="yes" xml:space="preserve">
          <source>(You may, in fact, want to start with localizing to</source>
          <target state="translated">(실제로 현지화부터 시작하고 싶을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bb2b230b54ad6957c49b6580f615df0eff17f93" translate="yes" xml:space="preserve">
          <source>(added in &lt;code&gt;Sys::Syslog&lt;/code&gt; 0.21). HP-UX is a system which uses such a named pipe.</source>
          <target state="translated">( &lt;code&gt;Sys::Syslog&lt;/code&gt; 0.21에 추가 ). HP-UX는 이러한 명명 된 파이프를 사용하는 시스템입니다.</target>
        </trans-unit>
        <trans-unit id="409526f33747b3d99190c22c4395e3c38ccf1ed4" translate="yes" xml:space="preserve">
          <source>(also known as 90 degrees).</source>
          <target state="translated">(90 도라 고도 함).</target>
        </trans-unit>
        <trans-unit id="0975309405add43e0212a50c2f0bc405f3954769" translate="yes" xml:space="preserve">
          <source>(also see &lt;a href=&quot;#gen_delimited_pat&quot;&gt;gen_delimited_pat&lt;/a&gt; below).</source>
          <target state="translated">( 아래 &lt;a href=&quot;#gen_delimited_pat&quot;&gt;gen_delimited_pat&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="1cdc6cf7e203685897747bffc2262178c7977e11" translate="yes" xml:space="preserve">
          <source>(although &lt;code&gt;extract_tagged&lt;/code&gt; is not currently implemented that way, in order to preserve pre-5.005 compatibility).</source>
          <target state="translated">(하지만 &lt;code&gt;extract_tagged&lt;/code&gt; 현재의 방법, 순서대로 사전 5.005의 호환성을 유지하는 것을 구현되지 않습니다).</target>
        </trans-unit>
        <trans-unit id="f2cfa0da4ed10df5c469d6ab0c502d0727365ce2" translate="yes" xml:space="preserve">
          <source>(although in production code the substitutions might be done in the EBCDIC branch with the function call and separately in the ASCII branch without the expense of the identity map; in Perl v5.22, the identity map is optimized out so there is no expense, but the alternative above is simpler and is also available in v5.22).</source>
          <target state="translated">(프로덕션 코드에서 ID 맵을 사용하지 않고 EBCDIC 분기에서 함수 호출을 사용하고 ASCII 분기에서 별도로 대체를 수행 할 수 있지만 Perl v5.22에서는 ID 맵이 최적화되어 비용이 발생하지 않습니다. 그러나 위의 대안은 더 간단하고 v5.22에서도 사용할 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="4f9622103ba7043a2f17e986f7fa6b31d025760e" translate="yes" xml:space="preserve">
          <source>(and problematic) UTF-8 behaviour of Perl 5.8.0. (See &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perl581delta.html#UTF-8-no-longer-default-under-UTF-8-locales&quot;&gt;UTF-8 no longer default under UTF-8 locales in perl581delta&lt;/a&gt;.)</source>
          <target state="translated">(그리고 문제가있는) Perl 5.8.0의 UTF-8 동작. ( &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perl581delta.html#UTF-8-no-longer-default-under-UTF-8-locales&quot;&gt;perl581delta의 UTF-8 로켈에서 더 이상 UTF-8이 기본값이 아님을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="692b42cc2b3e37f46870d9371dc5e76fada22536" translate="yes" xml:space="preserve">
          <source>(and you have to say &lt;code&gt;not_&lt;/code&gt; ; you can't use the bang &lt;code&gt;!&lt;/code&gt; form). This pseudo category is a shorthand for specifying both &lt;code&gt;:collate&lt;/code&gt; and &lt;code&gt;:ctype&lt;/code&gt; . Hence, in the negated form, it is nearly the same thing as saying</source>
          <target state="translated">(그리고 당신은 &lt;code&gt;not_&lt;/code&gt; 을 말해야 합니다 ; 당신은 bang &lt;code&gt;!&lt;/code&gt; 양식을 사용할 수 없습니다 ). 이 의사 범주는 &lt;code&gt;:collate&lt;/code&gt; 및 &lt;code&gt;:ctype&lt;/code&gt; 을 모두 지정하기위한 축약 형입니다 . 따라서 부정 된 형태로 말하는 것과 거의 같습니다.</target>
        </trans-unit>
        <trans-unit id="6aeff3579e72696260e1169c528784c27ec7b978" translate="yes" xml:space="preserve">
          <source>(answer contributed by brian d foy)</source>
          <target state="translated">(Brian D Foy가 제공 한 답변)</target>
        </trans-unit>
        <trans-unit id="e5076fd75f69e901d6b296f3219688b4e49af9fb" translate="yes" xml:space="preserve">
          <source>(as is one for 5.005_53), and the new version is 5.6.1. Create a file</source>
          <target state="translated">(5.005_53의 경우와 동일) 새 버전은 5.6.1입니다. 파일 만들기</target>
        </trans-unit>
        <trans-unit id="2a87525a6c2a886c0eaf943b38e0ee76d77adf64" translate="yes" xml:space="preserve">
          <source>(as the filename of DUCET) is used. If you will prepare your own table file, any name other than</source>
          <target state="translated">(DUCET의 파일 이름으로)가 사용됩니다. 자신의 테이블 파일을 준비하는 경우 이외의 다른 이름</target>
        </trans-unit>
        <trans-unit id="786ef72f31164be533ff5c7e4a7e63ae5230f32a" translate="yes" xml:space="preserve">
          <source>(assuming the default installation location was chosen).</source>
          <target state="translated">(기본 설치 위치가 선택되었다고 가정).</target>
        </trans-unit>
        <trans-unit id="63c4a5f42cbbe3a05030f3bc9132df45a99212cd" translate="yes" xml:space="preserve">
          <source>(at least) the following lines</source>
          <target state="translated">(적어도) 다음 줄</target>
        </trans-unit>
        <trans-unit id="b948cb7a3253ff3b0a5238bd22a6d610864b716f" translate="yes" xml:space="preserve">
          <source>(at the very end for binary compatibility).</source>
          <target state="translated">(이진 호환성을 위해 맨 끝에).</target>
        </trans-unit>
        <trans-unit id="48792f7a9033374771dbfb100ac3abb29a32dab5" translate="yes" xml:space="preserve">
          <source>(because either it starts with a &quot;_&quot;, or because none of its lexicons have &lt;code&gt;_AUTO =&amp;gt; 1,&lt;/code&gt; ), then we have failed to find a normal way to maketext</source>
          <target state="translated">( &quot;_&quot;로 시작하거나 어휘집에 &lt;code&gt;_AUTO =&amp;gt; 1,&lt;/code&gt; 이 없기 때문에 ) 텍스트를 만드는 일반적인 방법을 찾지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="f6d16baf27904d45d89ec1d9d7ed8281fa17d9fe" translate="yes" xml:space="preserve">
          <source>(because in particular, simply assigning a weak reference back to itself does not work to unweaken it; &lt;code&gt;$REF = $REF&lt;/code&gt; does not work).</source>
          <target state="translated">(특히, 약한 참조를 자체로 다시 할당하면 해제되지 않습니다. &lt;code&gt;$REF = $REF&lt;/code&gt; 는 작동하지 않습니다).</target>
        </trans-unit>
        <trans-unit id="4b16cab82b532af855df5c5a4ca92e48f90985fe" translate="yes" xml:space="preserve">
          <source>(but slightly more complicated). This tree reflects the way Perl parsed your code, but has nothing to do with the execution order. There is an additional &quot;thread&quot; going through the nodes of the tree which shows the order of execution of the nodes. In our simplified example above it looks like:</source>
          <target state="translated">(그러나 약간 더 복잡합니다). 이 트리는 Perl이 코드를 구문 분석 한 방식을 반영하지만 실행 순서와는 아무런 관련이 없습니다. 노드의 실행 순서를 보여주는 트리의 노드를 통과하는 추가 &quot;스레드&quot;가 있습니다. 위의 간단한 예에서 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4693cf64bd9a521498526ddc1119c6dfd5c3b552" translate="yes" xml:space="preserve">
          <source>(c) Tels &lt;a href=&quot;http://bloodgate.com&quot;&gt;http://bloodgate.com&lt;/a&gt; 2003, 2004 - based on BigInt code by Tels from 2001-2003.</source>
          <target state="translated">(c) Tels &lt;a href=&quot;http://bloodgate.com&quot;&gt;http://bloodgate.com&lt;/a&gt; 2003, 2004-2001-2003 년 Tels의 BigInt 코드 기반.</target>
        </trans-unit>
        <trans-unit id="f705994b685d7ab39803fc55afe57bb501708c2b" translate="yes" xml:space="preserve">
          <source>(const) data, and the &lt;code&gt;U&lt;/code&gt; is &amp;lt;undefined&amp;gt;, external symbols referred to.</source>
          <target state="translated">(const) 데이터이고 &lt;code&gt;U&lt;/code&gt; 는 &amp;lt;undefined&amp;gt;이며 외부 기호가 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="f2d8cd4b2f49ebe16d34218b69e616c4bfb7685e" translate="yes" xml:space="preserve">
          <source>(contributed by Alex Beamish)</source>
          <target state="translated">(Alex Beamish 제공)</target>
        </trans-unit>
        <trans-unit id="8a01f14aa6ea03ae12033993b8340bb14bc9dc2b" translate="yes" xml:space="preserve">
          <source>(contributed by Anno Siegel)</source>
          <target state="translated">(Anno Siegel 제공)</target>
        </trans-unit>
        <trans-unit id="fac38ab03b508c364ce52ea99dd09ac56e9be13a" translate="yes" xml:space="preserve">
          <source>(contributed by Ben Morrow)</source>
          <target state="translated">(Ben Morrow 제공)</target>
        </trans-unit>
        <trans-unit id="cab93540468b3299e5e7ff453d2c13989f42fd8e" translate="yes" xml:space="preserve">
          <source>(contributed by Brian McCauley)</source>
          <target state="translated">(브라이언 맥컬리 제공)</target>
        </trans-unit>
        <trans-unit id="5866c9a649588b2bcaf84ab58628c670110cf84d" translate="yes" xml:space="preserve">
          <source>(contributed by Michael Carman)</source>
          <target state="translated">(Michael Carman 제공)</target>
        </trans-unit>
        <trans-unit id="11aa83d938cb90075d1401151f2508d1510688fe" translate="yes" xml:space="preserve">
          <source>(contributed by Peter J. Holzer, hjp-usenet2@hjp.at)</source>
          <target state="translated">(Peter J. Holzer, hjp-usenet2@hjp.at 제공)</target>
        </trans-unit>
        <trans-unit id="5dee00bc78a497a9d448541fd31f216ca89ba87a" translate="yes" xml:space="preserve">
          <source>(contributed by Shlomi Fish)</source>
          <target state="translated">(Shlomi Fish에서 제공)</target>
        </trans-unit>
        <trans-unit id="1e46d3c5ed3722672a09f39374a1a7ffdac24e1c" translate="yes" xml:space="preserve">
          <source>(contributed by Xho)</source>
          <target state="translated">(Xho 제공)</target>
        </trans-unit>
        <trans-unit id="b1ad773d61a232c565a534ba9591dd6ec671fc74" translate="yes" xml:space="preserve">
          <source>(contributed by brian d foy and Ben Morrow)</source>
          <target state="translated">(브라이언 디 포이와 벤 모로우가 제공)</target>
        </trans-unit>
        <trans-unit id="da6037d0c8a0901dbdb8efa83408cf6cf316ca26" translate="yes" xml:space="preserve">
          <source>(contributed by brian d foy and Benjamin Goldberg)</source>
          <target state="translated">(브라이언 디 포이와 벤자민 골드버그가 제공)</target>
        </trans-unit>
        <trans-unit id="b450df445d93e3c6b0f335b0c69c72d7b68c7ec1" translate="yes" xml:space="preserve">
          <source>(contributed by brian d foy and Dave Cross)</source>
          <target state="translated">(brian d foy와 Dave Cross가 제공)</target>
        </trans-unit>
        <trans-unit id="5ecf6719df9ae48ff24c5100a5d4b1ef446cd95f" translate="yes" xml:space="preserve">
          <source>(contributed by brian d foy)</source>
          <target state="translated">(brian d foy 제공)</target>
        </trans-unit>
        <trans-unit id="2c422c445de0783d3809d65cd3e3acd9a5e0e370" translate="yes" xml:space="preserve">
          <source>(contributed by brian d foy, updated Fri Jul 25 12:22:26 PDT 2008)</source>
          <target state="translated">(brian d foy 제공, Fri Jul 25 12:22:26 PDT 2008 업데이트)</target>
        </trans-unit>
        <trans-unit id="9c413c8db2fc0e0a195f2df6b3cb2359816721c7" translate="yes" xml:space="preserve">
          <source>(copyright 2004, Published by O'Reilly Media, Inc.), Damian Conway provides a list of criteria to use when deciding if OO is the right fit for your problem:</source>
          <target state="translated">(저작권 2004, O'Reilly Media, Inc.에서 발행), Damian Conway는 OO가 문제에 적합한 지 결정할 때 사용할 기준 목록을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ea2654366590f288ae6ebd7fdc54bceaf9e6545c" translate="yes" xml:space="preserve">
          <source>(currently the last two may hit a wrong location, but this may improve soon). Under Win* see &lt;a href=&quot;#SYNOPSIS&quot;&gt;SYNOPSIS&lt;/a&gt;.</source>
          <target state="translated">(현재 마지막 두 개는 잘못된 위치에 도달 할 수 있지만 곧 개선 될 수 있습니다). Win *에서 &lt;a href=&quot;#SYNOPSIS&quot;&gt;SYNOPSIS를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="41e74bf7b4c32eb2f41eaf25ee2c6c323ec8d504" translate="yes" xml:space="preserve">
          <source>(cuttable). An atomic operation is an action that can&amp;rsquo;t be interrupted, not one forbidden in a nuclear-free zone.</source>
          <target state="translated">(절단 가능). 원자 작전은 핵없는 지역에서 금지 된 것이 아니라 중단 될 수없는 행동입니다.</target>
        </trans-unit>
        <trans-unit id="b3a9a8199852eb2a04185407b3827576c8e6172d" translate="yes" xml:space="preserve">
          <source>(defaults to the environment variable</source>
          <target state="translated">(기본적으로 환경 변수</target>
        </trans-unit>
        <trans-unit id="c979523d1a9c1a0d77ab7e430a7c98147073391d" translate="yes" xml:space="preserve">
          <source>(deprecated - use &lt;code&gt;(AV *)NULL&lt;/code&gt; instead)</source>
          <target state="translated">(더 이상 사용되지 않음- 대신 &lt;code&gt;(AV *)NULL&lt;/code&gt; 사용)</target>
        </trans-unit>
        <trans-unit id="887821ca73f1fcf6de46ded6b730b60d3beffd8e" translate="yes" xml:space="preserve">
          <source>(deprecated - use &lt;code&gt;(CV *)NULL&lt;/code&gt; instead)</source>
          <target state="translated">(더 이상 사용되지 않음- 대신 &lt;code&gt;(CV *)NULL&lt;/code&gt; 사용)</target>
        </trans-unit>
        <trans-unit id="b53d21700af9fd28a7f43adfe7247f1c0f49ab4c" translate="yes" xml:space="preserve">
          <source>(deprecated - use &lt;code&gt;(HV *)NULL&lt;/code&gt; instead)</source>
          <target state="translated">(더 이상 사용되지 않음- 대신 &lt;code&gt;(HV *)NULL&lt;/code&gt; 사용)</target>
        </trans-unit>
        <trans-unit id="4957206df9fb7ffd7b399b79b2a6449d69017a22" translate="yes" xml:space="preserve">
          <source>(do not forget to run &lt;code&gt;make regen_headers&lt;/code&gt; if you modify this file).</source>
          <target state="translated">( 이 파일을 수정하면 &lt;code&gt;make regen_headers&lt;/code&gt; 를 실행하는 것을 잊지 마십시오 ).</target>
        </trans-unit>
        <trans-unit id="47d764752c9dc13917cf2e5897bbaac62c58fbf5" translate="yes" xml:space="preserve">
          <source>(e.g., the application may hang, or generate an error) due to mutexes that are needed to control functionality within the &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; module.</source>
          <target state="translated">(예를 들어, &lt;a href=&quot;threads&quot;&gt;스레드&lt;/a&gt; 모듈 내의 기능을 제어하는 ​​데 필요한 뮤텍스로 인해 응용 프로그램이 중단되거나 오류가 발생할 수 있음) .</target>
        </trans-unit>
        <trans-unit id="ae81a9ce14e07a570fbb453b8b2d8a4343210087" translate="yes" xml:space="preserve">
          <source>(engineers use</source>
          <target state="translated">(엔지니어는</target>
        </trans-unit>
        <trans-unit id="4a54a48aa166f000450ddb5bbfffb162a4703f6a" translate="yes" xml:space="preserve">
          <source>(equal) if the operands are char-for-char identical. If you really want to know whether two strings--which &lt;code&gt;eq&lt;/code&gt; and &lt;code&gt;cmp&lt;/code&gt; may consider different--are equal as far as collation in the locale is concerned, see the discussion in &lt;a href=&quot;#Category-LC_COLLATE-%3a-Collation&quot;&gt;Category LC_COLLATE : Collation&lt;/a&gt;.</source>
          <target state="translated">피연산자가 char-for-char와 동일한 경우 (동일). 로케일의 데이터 정렬과 관련하여 &lt;code&gt;eq&lt;/code&gt; 와 &lt;code&gt;cmp&lt;/code&gt; 가 다른 것으로 간주 될 수 있는 두 개의 문자열 이 동일한 지 여부를 실제로 알고 싶다면 &lt;a href=&quot;#Category-LC_COLLATE-%3a-Collation&quot;&gt;LC_COLLATE : Collation 범주&lt;/a&gt; 의 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7d245ed086c5e828978b1419867a15ebe5c96265" translate="yes" xml:space="preserve">
          <source>(explained in the next paragraph), separated by spaces. (Other than as used to separate elements, spaces are to be ignored.) Case distinctions in the condition list are not significant. Conditions preceded by &quot;NON_&quot; represent the negation of the condition.</source>
          <target state="translated">(다음 단락에서 설명) 공백으로 구분합니다. (요소를 구분하는 데 사용되는 경우를 제외하고 공백은 무시됩니다.) 조건 목록의 대소 문자 구분이 중요하지 않습니다. &quot;NON_&quot;앞에 오는 조건은 조건의 부정을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b7612ed7f2ab039566cbb6a180523b77c6c55c37" translate="yes" xml:space="preserve">
          <source>(for Win32 Perl)</source>
          <target state="translated">(Win32 Perl 용)</target>
        </trans-unit>
        <trans-unit id="52773988fa05986370e14e73b80f0d9b5d869e6f" translate="yes" xml:space="preserve">
          <source>(for pthreads platforms)</source>
          <target state="translated">(pthreads 플랫폼 용)</target>
        </trans-unit>
        <trans-unit id="f2baa49355f382d8855fa13bc94ef1ce38af8547" translate="yes" xml:space="preserve">
          <source>(have the directories with &lt;code&gt;*.exe&lt;/code&gt; on PATH, and &lt;code&gt;*.dll&lt;/code&gt; on LIBPATH);</source>
          <target state="translated">( PATH에 &lt;code&gt;*.exe&lt;/code&gt; , LIBPATH에 &lt;code&gt;*.dll&lt;/code&gt; 이있는 디렉토리가 있음 );</target>
        </trans-unit>
        <trans-unit id="8b307b3649a26281003eca21c9415192d0da1a2f" translate="yes" xml:space="preserve">
          <source>(have the directory on PATH);</source>
          <target state="translated">(PATH에 디렉토리가 있음);</target>
        </trans-unit>
        <trans-unit id="e78594face702b66af1259171d24ead963a0670c" translate="yes" xml:space="preserve">
          <source>(here the optional &lt;code&gt;IN&lt;/code&gt; keyword is omitted).</source>
          <target state="translated">(여기서 선택적 &lt;code&gt;IN&lt;/code&gt; 키워드는 생략됩니다).</target>
        </trans-unit>
        <trans-unit id="0ca1edf548683a8b18ee06ce8f4d27a28c75a756" translate="yes" xml:space="preserve">
          <source>(i.e. &lt;code&gt;A::foo&lt;/code&gt; is called twice).</source>
          <target state="translated">(즉, &lt;code&gt;A::foo&lt;/code&gt; 가 두 번 호출됩니다).</target>
        </trans-unit>
        <trans-unit id="8f8464e8307b268923dc0c2b5876277d2c0fd5db" translate="yes" xml:space="preserve">
          <source>(i.e., &lt;code&gt;(EXPR &amp;amp; 0700) &amp;gt; 0&lt;/code&gt; ), raises an exception. If umask(2) is not implemented and you are not trying to restrict access for yourself, returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">(예 : &lt;code&gt;(EXPR &amp;amp; 0700) &amp;gt; 0&lt;/code&gt; ) 예외가 발생합니다. umask (2)가 구현되지 않고 사용자 자신에 대한 액세스를 제한하지 않으면 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="8f5d49562cd8c87da892149a0b2d4a8af46e9d52" translate="yes" xml:space="preserve">
          <source>(i.e., &lt;code&gt;(EXPR &amp;amp; 0700) &amp;gt; 0&lt;/code&gt; ), raises an exception. If umask(2) is not implemented and you are not trying to restrict access for yourself, returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">(예 : &lt;code&gt;(EXPR &amp;amp; 0700) &amp;gt; 0&lt;/code&gt; ) 예외가 발생합니다. umask (2)가 구현되지 않고 사용자 자신에 대한 액세스를 제한하지 않으면 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="55c213fac91606d567b36164fd0c347d752bb458" translate="yes" xml:space="preserve">
          <source>(i.e., Unix) you can configure perl with &lt;code&gt;-Accflags=-DPERL_DEBUG_READONLY_COW&lt;/code&gt; and it will turn buffer violations into crashes. You will find it to be marvellously slow, so you may want to skip perl's own tests.</source>
          <target state="translated">(즉, Unix) &lt;code&gt;-Accflags=-DPERL_DEBUG_READONLY_COW&lt;/code&gt; 를 사용 하여 perl을 구성 하면 버퍼 위반이 충돌로 바뀝니다. 놀랍게도 느리게 느껴지므로 펄 자신의 테스트를 건너 뛰고 싶을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce300057bb6cbcc44d6adf16788915bba76efc18" translate="yes" xml:space="preserve">
          <source>(if &lt;a href=&quot;../cpan/meta&quot;&gt;CPAN::Meta&lt;/a&gt; is installed). Clients like &lt;a href=&quot;../cpan&quot;&gt;CPAN&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/perldoc/CPANPLUS&quot;&gt;CPANPLUS&lt;/a&gt; will read this files to see what prerequisites must be fulfilled before building or testing the distribution. If you with to shut this feature off, set the &lt;code&gt;NO_MYMETA&lt;/code&gt;&lt;code&gt;WriteMakeFile()&lt;/code&gt; flag to true.</source>
          <target state="translated">( &lt;a href=&quot;../cpan/meta&quot;&gt;CPAN :: Meta&lt;/a&gt; 가 설치된 경우). &lt;a href=&quot;../cpan&quot;&gt;CPAN&lt;/a&gt; 또는 &lt;a href=&quot;http://search.cpan.org/perldoc/CPANPLUS&quot;&gt;CPANPLUS&lt;/a&gt; 와 같은 클라이언트 는이 파일을 읽고 분배를 빌드하거나 테스트하기 전에 충족해야하는 전제 조건을 확인합니다. 이 기능을 끄려면 &lt;code&gt;NO_MYMETA&lt;/code&gt; &lt;code&gt;WriteMakeFile()&lt;/code&gt; 플래그를 true로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="74e7cc4a040d094131ce7adf1ccff6a9eb9bc3ff" translate="yes" xml:space="preserve">
          <source>(if it exists) are ignored.</source>
          <target state="translated">(있는 경우) 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="8bd7b4287b1a4320a59f0e97575d78114f1f439c" translate="yes" xml:space="preserve">
          <source>(ignore multiple &lt;code&gt;warning L4085&lt;/code&gt; ).</source>
          <target state="translated">(여러 &lt;code&gt;warning L4085&lt;/code&gt; 무시 ).</target>
        </trans-unit>
        <trans-unit id="51361c690dc77f93fb8886da6627b841196647e3" translate="yes" xml:space="preserve">
          <source>(in a new</source>
          <target state="translated">(새로운</target>
        </trans-unit>
        <trans-unit id="92af5b7be830c62c74b2cbee2ea3528c112d9b33" translate="yes" xml:space="preserve">
          <source>(in the CPAN distribution of this module) for how to create a class that supports object sharing.</source>
          <target state="translated">(이 모듈의 CPAN 배포판에서) 객체 공유를 지원하는 클래스를 만드는 방법</target>
        </trans-unit>
        <trans-unit id="facc7193d5281131d9b0521947b073e2e6c2eb5b" translate="yes" xml:space="preserve">
          <source>(installed as</source>
          <target state="translated">(로 설치</target>
        </trans-unit>
        <trans-unit id="70b861787e317f2c2b8cac2c8a1c5c4c08c57918" translate="yes" xml:space="preserve">
          <source>(installed as &lt;a href=&quot;perlamiga&quot;&gt;perlamiga&lt;/a&gt;).</source>
          <target state="translated">( &lt;a href=&quot;perlamiga&quot;&gt;perlamiga&lt;/a&gt; 로 설치됨 ).</target>
        </trans-unit>
        <trans-unit id="4a2fc6f0afe5ebafb971a5f6f6450a8a8966ee80" translate="yes" xml:space="preserve">
          <source>(installed as &lt;a href=&quot;perlcygwin&quot;&gt;perlcygwin&lt;/a&gt;), &lt;a href=&quot;http://www.cygwin.com/&quot;&gt;http://www.cygwin.com/&lt;/a&gt;</source>
          <target state="translated">( &lt;a href=&quot;perlcygwin&quot;&gt;perlcygwin으로&lt;/a&gt; 설치 ), &lt;a href=&quot;http://www.cygwin.com/&quot;&gt;http://www.cygwin.com/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d21126d258fc7e5193f50e33b705649c9f31bd37" translate="yes" xml:space="preserve">
          <source>(installed as &lt;a href=&quot;perlvos&quot;&gt;perlvos&lt;/a&gt;)</source>
          <target state="translated">( &lt;a href=&quot;perlvos&quot;&gt;perlvos&lt;/a&gt; 로 설치됨 )</target>
        </trans-unit>
        <trans-unit id="69a2857991e5de08a1db31d1251389885ffd8caa" translate="yes" xml:space="preserve">
          <source>(internal use only)</source>
          <target state="translated">(내부 전용)</target>
        </trans-unit>
        <trans-unit id="3745d664a5cb578c0bc49111f2af5da3e3f2d003" translate="yes" xml:space="preserve">
          <source>(just by the name of the IO function, like &quot;Read&quot;) with the</source>
          <target state="translated">( &quot;읽기&quot;와 같은 IO 기능의 이름으로)</target>
        </trans-unit>
        <trans-unit id="cd5c26a005439b782269db0e964b40fc7eca11de" translate="yes" xml:space="preserve">
          <source>(like &lt;code&gt;COMBINING ACUTE ACCENT&lt;/code&gt; ). This sequence of base character and modifiers is called a</source>
          <target state="translated">( &lt;code&gt;COMBINING ACUTE ACCENT&lt;/code&gt; 와 같은 ). 이 기본 문자 및 수정 자의 순서를</target>
        </trans-unit>
        <trans-unit id="8620bf49ecd95e38b6d7494e30b7d9014d4bad52" translate="yes" xml:space="preserve">
          <source>(like &lt;code&gt;LATIN CAPITAL LETTER A&lt;/code&gt; ) followed by one or more</source>
          <target state="translated">( &lt;code&gt;LATIN CAPITAL LETTER A&lt;/code&gt; 와 같은 ) 뒤에 하나 이상의</target>
        </trans-unit>
        <trans-unit id="898558423b918aeed50b4db293c37dc4600aa4d3" translate="yes" xml:space="preserve">
          <source>(may be system dependent). If you want to force the creation of a new perl, it is recommended that you delete this</source>
          <target state="translated">(시스템에 따라 다를 수 있음). 새로운 펄을 만들려면 이것을 삭제하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b135c873a61fbd2b70216d59897dae798e688cac" translate="yes" xml:space="preserve">
          <source>(minimum) width</source>
          <target state="translated">(최소) 폭</target>
        </trans-unit>
        <trans-unit id="fb68136270e91ed8ffdbfd39c681ea2d1e249f38" translate="yes" xml:space="preserve">
          <source>(nearly all modules) this has three side effects:</source>
          <target state="translated">(거의 모든 모듈) 여기에는 세 가지 부작용이 있습니다.</target>
        </trans-unit>
        <trans-unit id="394df79e888bb4bc8d5dd0e24df5f278d4cdc8b9" translate="yes" xml:space="preserve">
          <source>(no extension) give an argument &lt;code&gt;n:/bin/blah.&lt;/code&gt; (dot appended) to system().</source>
          <target state="translated">(확장자 없음) 인수 &lt;code&gt;n:/bin/blah.&lt;/code&gt; (점이 추가됨) system ().</target>
        </trans-unit>
        <trans-unit id="e0f8b79485e24e1aa85b5719818060e99b9fac5a" translate="yes" xml:space="preserve">
          <source>(non-super) languages that are probably acceptable to the user, to be used</source>
          <target state="translated">(슈퍼가 아닌) 사용자가 사용할 수있는 언어</target>
        </trans-unit>
        <trans-unit id="df56c4328df4065d33cb67c45603001892660f7c" translate="yes" xml:space="preserve">
          <source>(not locales). See the GNU &lt;code&gt;gettext&lt;/code&gt; library documentation for more information.</source>
          <target state="translated">(로케일이 아님). 자세한 내용은 GNU &lt;code&gt;gettext&lt;/code&gt; 라이브러리 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ca133eb8cde4644a55bd2dd3514979460453ef7d" translate="yes" xml:space="preserve">
          <source>(not simply older ones) set the &lt;code&gt;UNINST&lt;/code&gt; variable.</source>
          <target state="translated">(오래된 것이 아니라) &lt;code&gt;UNINST&lt;/code&gt; 변수를 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="87ba0557f46520422b4ad12ed987b7a873c1f334" translate="yes" xml:space="preserve">
          <source>(not) +</source>
          <target state="translated">(아님) +</target>
        </trans-unit>
        <trans-unit id="a87bac478adeaad45a131a7a1ff824736853050d" translate="yes" xml:space="preserve">
          <source>(note that the argument &lt;code&gt;-my_opts&lt;/code&gt; is taken care of by the &lt;code&gt;extproc&lt;/code&gt; line in your script, see &lt;a href=&quot;#extproc-on-the-first-line&quot;&gt;extproc on the first line&lt;/a&gt;).</source>
          <target state="translated">( &lt;code&gt;-my_opts&lt;/code&gt; 인수 는 스크립트 의 &lt;code&gt;extproc&lt;/code&gt; 행에 의해 처리 &lt;a href=&quot;#extproc-on-the-first-line&quot;&gt;됩니다. 첫 번째 행의 extproc&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2252501faf83dd862f721d37d7fabacb6191045c" translate="yes" xml:space="preserve">
          <source>(note the capital 'O')?</source>
          <target state="translated">(수도 'O'에 주목)?</target>
        </trans-unit>
        <trans-unit id="943a0a81a1832953a2e589fda6975dd0742c8224" translate="yes" xml:space="preserve">
          <source>(or a later version). Note that all these utilities are known to be available from LEO:</source>
          <target state="translated">(또는 이후 버전). 이러한 모든 유틸리티는 LEO에서 제공되는 것으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1d876dbf1a11aabf97fb7b5ced558dd7fc14007" translate="yes" xml:space="preserve">
          <source>(or current directory) and working back up to five levels of '..'.</source>
          <target state="translated">(또는 현재 디렉토리) 및 '..'의 최대 5 단계로 작업.</target>
        </trans-unit>
        <trans-unit id="5d789ea9ecbca64db40cc5cf855ac5aab3b99f9f" translate="yes" xml:space="preserve">
          <source>(or equivalent) to check for executable image, and</source>
          <target state="translated">실행 가능한 이미지를 확인하기 위해 (또는 이에 상응하는)</target>
        </trans-unit>
        <trans-unit id="f682b3c18a9391cb4e366a7aa9b5a7cb465c2e8c" translate="yes" xml:space="preserve">
          <source>(or formerly</source>
          <target state="translated">(또는 이전</target>
        </trans-unit>
        <trans-unit id="d403fe550f70047da65adfbaaaa9a12d0ea25d65" translate="yes" xml:space="preserve">
          <source>(or something like that).</source>
          <target state="translated">(또는 그런 것).</target>
        </trans-unit>
        <trans-unit id="b78679543a880190c17b815dfea3958a0c6bb773" translate="yes" xml:space="preserve">
          <source>(or the second if the first character is a caret) character of a bracketed character class, it does not denote the end of the class (as you cannot have an empty class) and is considered part of the set of characters that can be matched without escaping.</source>
          <target state="translated">(또는 첫 번째 문자가 캐럿 인 경우 두 번째 문자) 대괄호 문자 클래스의 문자는 클래스의 끝을 나타내지 않으며 (빈 클래스를 가질 수 없으므로) 일치 할 수있는 문자 세트의 일부로 간주됩니다. 탈출하지 않고.</target>
        </trans-unit>
        <trans-unit id="d8c8bb7d961236b850f553d2b4e51bb846fabeed" translate="yes" xml:space="preserve">
          <source>(or the value is discarded if</source>
          <target state="translated">(또는 값은</target>
        </trans-unit>
        <trans-unit id="a47590de5dce94882f3eb07aab9c1f1f12b27039" translate="yes" xml:space="preserve">
          <source>(or you could just use &lt;code&gt;VMS::Stdio::remove&lt;/code&gt; , if you've installed the VMS::Stdio extension distributed with Perl). If &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; has to change the file protection to delete the file, and you interrupt it in midstream, the file may be left intact, but with a changed ACL allowing you delete access.</source>
          <target state="translated">(또는 Perl과 함께 배포 된 VMS :: Stdio 확장을 설치 한 경우 &lt;code&gt;VMS::Stdio::remove&lt;/code&gt; 사용할 수 있습니다 ). 링크를 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 하여 파일을 삭제하기 위해 파일 보호를 변경해야하고 파일을 중간 스트림에서 중단하면 파일이 그대로 남아 있지만 ACL을 변경하여 액세스를 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cc4703905ea087120e18389a3b56b4989f1d0ce" translate="yes" xml:space="preserve">
          <source>(or your operating system's equivalent) could not be opened.</source>
          <target state="translated">(또는 운영 체제와 동등한 기능)을 열 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d217df85ffcaff01b34839a3630a0f8777e5129a" translate="yes" xml:space="preserve">
          <source>(or your platform's equivalent procedure) to verify that &lt;b&gt;perl&lt;/b&gt; and its libraries have been installed correctly. A correct installation is verified by output that looks like:</source>
          <target state="translated">(또는 플랫폼의 동등한 절차)를 사용하여 &lt;b&gt;perl&lt;/b&gt; 및 해당 라이브러리가 올바르게 설치되었는지 확인하십시오. 다음과 같은 출력으로 올바른 설치가 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="17fc4954c0e2adfe4c1931803c04d50628b02fa1" translate="yes" xml:space="preserve">
          <source>(or, you don't have to do this yourself because this example is predefined)</source>
          <target state="translated">(또는이 예제는 사전 정의되어 있으므로 직접 할 필요는 없습니다)</target>
        </trans-unit>
        <trans-unit id="0f663554f9cc36dcf3f1877c497fb678b76cc2ed" translate="yes" xml:space="preserve">
          <source>(override) Because of the difficulty concatenating VMS filepaths we must pre-expand the DEST* variables.</source>
          <target state="translated">(재정의) VMS 파일 경로를 연결하는 데 어려움이 있으므로 DEST * 변수를 미리 확장해야합니다.</target>
        </trans-unit>
        <trans-unit id="3e64e5c52f4cbf325d544d16b24131a72496547d" translate="yes" xml:space="preserve">
          <source>(part of the standard perl distribution), which never really got finished. If you find it somewhere,</source>
          <target state="translated">(표준 펄 배포판의 일부), 실제로 끝나지 않았습니다. 어딘가에 있으면</target>
        </trans-unit>
        <trans-unit id="922530c6dd5e24c25c5c1c085800263ea1126411" translate="yes" xml:space="preserve">
          <source>(partly contributed by Aaron Sherman)</source>
          <target state="translated">(아론 셔먼이 일부 기고)</target>
        </trans-unit>
        <trans-unit id="cd3adb25404edd24eec9d649c8bcb704ae0342ed" translate="yes" xml:space="preserve">
          <source>(portions of this answer contributed by Anno Siegel and brian d foy)</source>
          <target state="translated">(이 답변의 일부는 Anno Siegel과 brian d foy가 제공했습니다)</target>
        </trans-unit>
        <trans-unit id="3b2cc61f70b62caaa55962a8021228deb590a600" translate="yes" xml:space="preserve">
          <source>(rather than filename) based input and output. These are safe on the assumption that only pre-existing filehandles are available for use. Usually, to create new filehandles other ops such as open would need to be enabled, if you don't take into account the magical open of ARGV.</source>
          <target state="translated">(파일 이름 대신) 기반 입력 및 출력. 기존 파일 핸들 만 사용할 수 있다고 가정하면 안전합니다. 일반적으로 새 파일 핸들을 만들려면 ARGV의 마법적인 개방을 고려하지 않은 경우 open과 같은 다른 op를 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="2848ad6e5d5a5174fbf33c0f002b92ca3e779b91" translate="yes" xml:space="preserve">
          <source>(rho, theta, pi)</source>
          <target state="translated">(rho, theta, pi)</target>
        </trans-unit>
        <trans-unit id="301eec20fcb8d08c4b477b134f84eea526c7c5a2" translate="yes" xml:space="preserve">
          <source>(rho, theta, z)</source>
          <target state="translated">(rho, theta, z)</target>
        </trans-unit>
        <trans-unit id="6f1730b3336db772520f06bb063d6d6eb975d7d1" translate="yes" xml:space="preserve">
          <source>(see &lt;a href=&quot;#perl_.exe&quot;&gt;perl_.exe&lt;/a&gt;) by</source>
          <target state="translated">에 의해 ( &lt;a href=&quot;#perl_.exe&quot;&gt;perl_.exe&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="57d66dd0e5298b5e96ec3ad469013acc44ce6276" translate="yes" xml:space="preserve">
          <source>(see &lt;a href=&quot;#perl__.exe&quot;&gt;perl__.exe&lt;/a&gt;) if you want to use PM code in your application (as Perl/Tk or OpenGL Perl modules do) without having a text-mode window present.</source>
          <target state="translated">텍스트 모드 창없이 애플리케이션에서 PM 코드를 사용하려면 ( &lt;a href=&quot;#perl__.exe&quot;&gt;perl __. exe&lt;/a&gt; 참조 ) (Perl / Tk 또는 OpenGL Perl 모듈처럼)</target>
        </trans-unit>
        <trans-unit id="13897f93e1b34b9d187d47d10d0d7a7feddc3e26" translate="yes" xml:space="preserve">
          <source>(see &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;) are for. (Avoid exec() (see &lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;) unless you know what you do).</source>
          <target state="translated">( &lt;a href=&quot;functions/open&quot;&gt;열기&lt;/a&gt; 참조 )입니다. (피 간부는 () (참조 &lt;a href=&quot;functions/exec&quot;&gt;간부&lt;/a&gt; 당신은 당신이 무엇을 알고하지 않는 한)).</target>
        </trans-unit>
        <trans-unit id="166724a371ebce21c3789346fabcb64d75a9043d" translate="yes" xml:space="preserve">
          <source>(see &lt;a href=&quot;perlvms&quot;&gt;perlvms&lt;/a&gt;) so that environ is not searched.</source>
          <target state="translated">environ이 검색되지 않도록 ( &lt;a href=&quot;perlvms&quot;&gt;perlvms&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="54b36cc8bf5ee45ddbf22c302f0ff8899587445f" translate="yes" xml:space="preserve">
          <source>(see &lt;a href=&quot;perlvms&quot;&gt;perlvms&lt;/a&gt;) so that the environ array isn't the target of the change to %ENV which produced the warning.</source>
          <target state="translated">( &lt;a href=&quot;perlvms&quot;&gt;perlvms&lt;/a&gt; 참조 ) 환경 배열이 경고를 생성 한 % ENV 변경 대상이되지 않도록하십시오.</target>
        </trans-unit>
        <trans-unit id="fdb75cfc3f651d35ec9dce7ef8ff84370b4689f6" translate="yes" xml:space="preserve">
          <source>(see &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;). In this mode of operation, Perl will raise the warning for all matches against a non-Unicode code point (not just the arguable ones), and it skips the optimizations that might cause the warning to not be output. (It currently still won't warn if the match isn't even attempted, like in the &lt;code&gt;&quot;foobar&quot;&lt;/code&gt; example above.)</source>
          <target state="translated">( &lt;a href=&quot;warnings&quot;&gt;경고&lt;/a&gt; 참조 ). 이 작동 모드에서 Perl은 유니 코드가 아닌 코드 포인트 (논쟁 가능한 포인트가 아닌)에 대해 모든 일치에 대해 경고를 발생시키고 경고가 출력되지 않을 수있는 최적화를 건너 뜁니다. ( 위 의 &lt;code&gt;&quot;foobar&quot;&lt;/code&gt; 예제 에서와 같이 일치가 시도되지 않더라도 현재 경고는 표시되지 않습니다 .)</target>
        </trans-unit>
        <trans-unit id="ae2592aa43fa906f33435791e9b2cf177d7b8878" translate="yes" xml:space="preserve">
          <source>(see Annex 8, UAX #15; and</source>
          <target state="translated">(부록 8, UAX # 15 참조)</target>
        </trans-unit>
        <trans-unit id="bfe137530e41031a5af4ace868c82fe0baa9a25b" translate="yes" xml:space="preserve">
          <source>(see below) and/or</source>
          <target state="translated">(아래 참조) 및 / 또는</target>
        </trans-unit>
        <trans-unit id="2d2a37102316b6b5d1b884637aaaac148e2b754c" translate="yes" xml:space="preserve">
          <source>(see, it's even smart enough to fix my obvious date bug)</source>
          <target state="translated">(내 명백한 날짜 버그를 수정하기에 충분히 똑똑합니다)</target>
        </trans-unit>
        <trans-unit id="219b75b05739b79a0aeb3aa178076f50dcc11a3c" translate="yes" xml:space="preserve">
          <source>(short for Posix Space) Starting in 5.18, this is identical in all its forms to the corresponding &lt;code&gt;isSPACE()&lt;/code&gt; macros. The locale forms of this macro are identical to their corresponding &lt;code&gt;isSPACE()&lt;/code&gt; forms in all Perl releases. In releases prior to 5.18, the non-locale forms differ from their &lt;code&gt;isSPACE()&lt;/code&gt; forms only in that the &lt;code&gt;isSPACE()&lt;/code&gt; forms don't match a Vertical Tab, and the &lt;code&gt;isPSXSPC()&lt;/code&gt; forms do. Otherwise they are identical. Thus this macro is analogous to what &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/[[:space:]]/&lt;/a&gt;&lt;/code&gt; matches in a regular expression. See the &lt;a href=&quot;#Character-classification&quot;&gt;top of this section&lt;/a&gt; for an explanation of variants &lt;code&gt;isPSXSPC_A&lt;/code&gt; , &lt;code&gt;isPSXSPC_L1&lt;/code&gt; , &lt;code&gt;isPSXSPC_uni&lt;/code&gt; , &lt;code&gt;isPSXSPC_utf8&lt;/code&gt; , &lt;code&gt;isPSXSPC_LC&lt;/code&gt; , &lt;code&gt;isPSXSPC_LC_uvchr&lt;/code&gt; , and &lt;code&gt;isPSXSPC_LC_utf8&lt;/code&gt; .</source>
          <target state="translated">(Posix Space의 약자) 5.18부터는 모든 형태에서 해당 &lt;code&gt;isSPACE()&lt;/code&gt; 매크로와 동일합니다. 이 매크로의 로케일 형식은 모든 Perl 릴리스 의 해당 &lt;code&gt;isSPACE()&lt;/code&gt; 형식 과 동일 합니다. 5.18 이전 버전에서는, 비 로케일 형태는 다를 &lt;code&gt;isSPACE()&lt;/code&gt; 에만 점에서 형태 &lt;code&gt;isSPACE()&lt;/code&gt; 형태가 수직 탭과 일치하지 않으며, &lt;code&gt;isPSXSPC()&lt;/code&gt; 형태 않습니다. 그렇지 않으면 동일합니다. 따라서이 매크로는 정규식에서 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/[[:space:]]/&lt;/a&gt;&lt;/code&gt; 와 일치하는 것과 유사합니다 . 참고 항목 &lt;a href=&quot;#Character-classification&quot;&gt;이 섹션의 상단&lt;/a&gt; 변종에 대한 설명 &lt;code&gt;isPSXSPC_A&lt;/code&gt; , &lt;code&gt;isPSXSPC_L1&lt;/code&gt; , &lt;code&gt;isPSXSPC_uni&lt;/code&gt; , &lt;code&gt;isPSXSPC_utf8&lt;/code&gt; , &lt;code&gt;isPSXSPC_LC&lt;/code&gt; , &lt;code&gt;isPSXSPC_LC_uvchr&lt;/code&gt; 및 &lt;code&gt;isPSXSPC_LC_utf8&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4bd5a16e31ac15e68b14071791ee2945208fa3f4" translate="yes" xml:space="preserve">
          <source>(so &lt;code&gt;!foo&lt;/code&gt; would match anything</source>
          <target state="translated">(그래서 &lt;code&gt;!foo&lt;/code&gt; 는 무엇이든 일치합니다.</target>
        </trans-unit>
        <trans-unit id="4c78e0c73b6b30ea430253f9fd658c00503bafdb" translate="yes" xml:space="preserve">
          <source>(that basically means POSIX fopen() style mode strings plus an optional number to indicate the compression level).</source>
          <target state="translated">(기본적으로 POSIX fopen () 스타일 모드 문자열과 압축 수준을 나타내는 선택적 숫자를 의미합니다).</target>
        </trans-unit>
        <trans-unit id="4b9770fcc7679e51bf57c83553ccf77d479a096c" translate="yes" xml:space="preserve">
          <source>(that is, the loop is broken) when Perl detects that a repeated expression matched a zero-length substring. Thus</source>
          <target state="translated">Perl이 반복 된 표현식이 길이가 0 인 하위 문자열과 일치 함을 감지하면 (즉, 루프가 끊어짐) 그러므로</target>
        </trans-unit>
        <trans-unit id="2c2b3767cd67fda7e4ff13d64bc55c53b4c03d5d" translate="yes" xml:space="preserve">
          <source>(that's not a misspelling!) has some good tips on optimization, too. Advice on benchmarking boils down to: benchmark and profile to make sure you're optimizing the right part, look for better algorithms instead of microtuning your code, and when all else fails consider just buying faster hardware. You will probably want to read the answer to the earlier question &quot;How do I profile my Perl programs?&quot; if you haven't done so already.</source>
          <target state="translated">(맞춤법이 아닙니다!)에는 최적화에 대한 유용한 팁도 있습니다. 벤치마킹에 대한 조언은 벤치마킹 및 프로파일로 요약하여 올바른 부분을 최적화하고 코드를 미세 조정하는 대신 더 나은 알고리즘을 찾으십시오. &quot;Perl 프로그램을 어떻게 프로파일 링합니까?&quot;라는 이전 질문에 대한 답을 원할 것입니다. 아직 그렇게하지 않았다면</target>
        </trans-unit>
        <trans-unit id="afd3f53e28b683fb99368ef0532ecf0f00244306" translate="yes" xml:space="preserve">
          <source>(the Camel, 3rd edition) or elsewhere, &lt;code&gt;:raw&lt;/code&gt; is</source>
          <target state="translated">(Camel, 3 판) 또는 다른 곳에서 &lt;code&gt;:raw&lt;/code&gt; is</target>
        </trans-unit>
        <trans-unit id="47fb842f1ec30dc0c1028b06b28202730238d4d6" translate="yes" xml:space="preserve">
          <source>(the bug, fixed in Perl 5.14, is described in &lt;a href=&quot;#BUGS&quot;&gt;BUGS&lt;/a&gt;). One can use this new interface as</source>
          <target state="translated">Perl 5.14에서 수정 된 버그는 &lt;a href=&quot;#BUGS&quot;&gt;BUGS에&lt;/a&gt; 설명되어 있습니다. 이 새로운 인터페이스를</target>
        </trans-unit>
        <trans-unit id="d1c731c58fb8625c1995a9c0d6a37456f30eb3dd" translate="yes" xml:space="preserve">
          <source>(the natural logarithm base) to the power of EXPR. If EXPR is omitted, gives &lt;code&gt;&lt;a href=&quot;exp&quot;&gt;exp($_)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">EXPR의 거듭 제곱에 EXPR이 생략되면 &lt;code&gt;&lt;a href=&quot;exp&quot;&gt;exp($_)&lt;/a&gt;&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="9ca0b781f69e1f8267342418d798ec9abc7f7b5c" translate="yes" xml:space="preserve">
          <source>(the natural logarithm base) to the power of EXPR. If EXPR is omitted, gives &lt;code&gt;&lt;a href=&quot;functions/exp&quot;&gt;exp($_)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">EXPR의 거듭 제곱에 EXPR이 생략되면 &lt;code&gt;&lt;a href=&quot;functions/exp&quot;&gt;exp($_)&lt;/a&gt;&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="e56b737030fe6f76e87a3edfc44265d91450bf34" translate="yes" xml:space="preserve">
          <source>(this may not work on some bizarre filesystems). One should conscientiously choose between the</source>
          <target state="translated">(일부 기괴한 파일 시스템에서는 작동하지 않을 수 있습니다). 양심적으로 선택해야합니다</target>
        </trans-unit>
        <trans-unit id="97ab80c9e1fe35bb7e8323fbb0d7feb27b6cbb77" translate="yes" xml:space="preserve">
          <source>(treat these hex digits as line noise). After this is fixed the build should finish without a lot of fuss.</source>
          <target state="translated">(이 16 진수를 라인 노이즈로 취급하십시오). 이것이 수정 된 후에는 많은 소란없이 빌드가 완료되어야합니다.</target>
        </trans-unit>
        <trans-unit id="1d7a9fe8570b8bcea8b9fe9361ea9bf6600d2508" translate="yes" xml:space="preserve">
          <source>(unless a</source>
          <target state="translated">(가 아니면</target>
        </trans-unit>
        <trans-unit id="4ec7a0d80a1ccd184b27056d454ee1153e6b5715" translate="yes" xml:space="preserve">
          <source>(used only by</source>
          <target state="translated">(만 사용</target>
        </trans-unit>
        <trans-unit id="ac5be747962c1aeaac7e7c81736092a7bc08bb8b" translate="yes" xml:space="preserve">
          <source>(user + system time) spent by the process since the first call to clock() (the definition is &lt;b&gt;not&lt;/b&gt; &quot;since the start of the process&quot;, though if you are lucky these times may be quite close to each other, depending on the system). What this means is that you probably need to store the result of your first call to clock(), and subtract that value from the following results of clock().</source>
          <target state="translated">(사용자 + 시스템 시간) clock ()에 대한 첫 번째 호출 이후 프로세스가 소비 한 것입니다 (정의는 &quot;프로세스 시작 이후&quot; 가 &lt;b&gt;아님)&lt;/b&gt; . 체계). 이것이 의미하는 것은 아마도 clock ()에 대한 첫 번째 호출 결과를 저장하고 다음 clock () 결과에서 해당 값을 빼야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="88e896a405e3f46934bf9370e95fa7933a886563" translate="yes" xml:space="preserve">
          <source>(using &lt;code&gt;Z_FULL_FLUSH&lt;/code&gt; ).</source>
          <target state="translated">( &lt;code&gt;Z_FULL_FLUSH&lt;/code&gt; 사용 ).</target>
        </trans-unit>
        <trans-unit id="02603cd1eae933c0c785a3f79537a20ecf4da31e" translate="yes" xml:space="preserve">
          <source>(where</source>
          <target state="translated">(where</target>
        </trans-unit>
        <trans-unit id="eb610507830351fb8e108f368c849e043989f99c" translate="yes" xml:space="preserve">
          <source>(whether an htmlname, or a number in any base) must consist only of alphanumeric characters -- that is,</source>
          <target state="translated">(htmlname이든 기본 숫자 든) 영숫자로만 구성해야합니다. 즉,</target>
        </trans-unit>
        <trans-unit id="f4cc7c250419a5d866584f91196b41206d58a2e6" translate="yes" xml:space="preserve">
          <source>(which depend on the process)</source>
          <target state="translated">(프로세스에 따라 다름)</target>
        </trans-unit>
        <trans-unit id="a565a6a28b6032770c35f345aa4e5afd3ef5d6b8" translate="yes" xml:space="preserve">
          <source>(which do nothing, and return zero and -1, respectively) or for certain methods you may assume a default behaviour by using a NULL method. The Open method looks for help in the 'parent' layer. The following table summarizes the behaviour:</source>
          <target state="translated">(아무것도하지 않고 각각 0과 -1을 반환합니다) 또는 특정 메소드의 경우 NULL 메소드를 사용하여 기본 동작을 가정 할 수 있습니다. Open 메서드는 '부모'레이어에서 도움을 찾습니다. 다음 표는 동작을 요약 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="d1bfbda3f08bba5e0a64d2c55993b9b59a747e61" translate="yes" xml:space="preserve">
          <source>(which finds the range of code points in the block using &lt;code&gt;prop_invlist&lt;/code&gt; , gets the lower end of the range (0th element) and then looks up the old name for its block using &lt;code&gt;charblock&lt;/code&gt; ).</source>
          <target state="translated">( &lt;code&gt;prop_invlist&lt;/code&gt; 를 사용하여 블록에서 코드 포인트의 범위를 찾고 범위의 맨 아래 (0 번째 요소)를 가져온 다음 &lt;code&gt;charblock&lt;/code&gt; 을 사용하여 해당 블록의 이전 이름을 찾습니다 ).</target>
        </trans-unit>
        <trans-unit id="2bd9e615b04879bf500ca0444285c7b5f58ebaef" translate="yes" xml:space="preserve">
          <source>(which is part of the</source>
          <target state="translated">(이것은</target>
        </trans-unit>
        <trans-unit id="11e91a933773803dea4f7027fc85914141f0b47a" translate="yes" xml:space="preserve">
          <source>(which is used instead)</source>
          <target state="translated">(대신 사용됨)</target>
        </trans-unit>
        <trans-unit id="a6b9b21d617162cc10b61d0e599ca09bfc3a8860" translate="yes" xml:space="preserve">
          <source>(with a handful of exceptions). This is an unfortunate backwards compatibility feature and its use is &lt;b&gt;strongly &lt;a href=&quot;perlpolicy#discouraged&quot;&gt;discouraged&lt;/a&gt;&lt;/b&gt;. You should either prevent the exporting (by saying &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; POSIX ();&lt;/code&gt; , as usual) and then use fully qualified names (e.g. &lt;code&gt;POSIX::SEEK_END&lt;/code&gt; ), or give an explicit import list. If you do neither and opt for the default (as in &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; POSIX;&lt;/code&gt; ), you will import</source>
          <target state="translated">(소수의 예외가 있음). 이것은 불행한 이전 버전과의 호환성 기능이며, 그것의 사용이되어 &lt;b&gt;강하게 &lt;a href=&quot;perlpolicy#discouraged&quot;&gt;낙담&lt;/a&gt;&lt;/b&gt; . (말함으로써 당신도 수출 방지해야 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; POSIX ();&lt;/code&gt; 평소와 같이) 다음 정규화 된 이름 (예를 들어, 사용 &lt;code&gt;POSIX::SEEK_END&lt;/code&gt; ) 또는 명시 적 수입 목록을 제공합니다. 당신이 (에서와 같이 기본값으로 둘 경우 opt 설정하지 않으면 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; POSIX;&lt;/code&gt; ), 당신은 가져옵니다</target>
        </trans-unit>
        <trans-unit id="0e1ed24ac3f83e4bb613f4329aa059c4bf5a4c9c" translate="yes" xml:space="preserve">
          <source>(x, y, z)</source>
          <target state="translated">(x, y, z)</target>
        </trans-unit>
        <trans-unit id="b6f844fee20c55f354c3646d70d08bb8aafbffec" translate="yes" xml:space="preserve">
          <source>(you may need to manually add &lt;code&gt;PERLTYPE=-DPERL_CORE&lt;/code&gt; to this commandline on some versions of Perl; the symptom is that the command-line globbing does not work from OS/2 shells with the newly-compiled executable; check with</source>
          <target state="translated">( 일부 버전의 Perl에서이 명령 행에 &lt;code&gt;PERLTYPE=-DPERL_CORE&lt;/code&gt; 를 수동으로 추가해야 할 수도 있습니다 . 증상은 명령 행 글로브 빙 이 새로 컴파일 된 실행 파일이있는 OS / 2 쉘에서 작동하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a4ad693788c41eaba8ea97f5859834b29c279024" translate="yes" xml:space="preserve">
          <source>(you probably need to add &lt;code&gt;-shared&lt;/code&gt; to the &amp;lt;-Alddlflags&amp;gt; line until RT #118199 is resolved)</source>
          <target state="translated">( RT # 118199가 해결 될 때까지 &amp;lt;-Alddlflags&amp;gt; 라인 에 &lt;code&gt;-shared&lt;/code&gt; 를 추가해야합니다 )</target>
        </trans-unit>
        <trans-unit id="eb95089a2aff367522b36d81eeb4af3aa05259c5" translate="yes" xml:space="preserve">
          <source>) Nested backslashed delimiters, embedded balanced bracket delimiters (for the quotelike operators), and trailing modifiers are all caught. For example, in:</source>
          <target state="translated">) 중첩 백 슬래시 구분 기호, 따옴표와 같은 연산자를위한 포함 된 대괄호 구분 기호 및 후행 수정자가 모두 포착됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="93d1e11773c70e0093dfdf1605f54536a30c04cb" translate="yes" xml:space="preserve">
          <source>) add together two &lt;code&gt;gvsv&lt;/code&gt; s.</source>
          <target state="translated">) 두 개의 &lt;code&gt;gvsv&lt;/code&gt; 를 함께 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="487acab4d37dcb1f88d4268398b649368558f781" translate="yes" xml:space="preserve">
          <source>) and XS code (defined in</source>
          <target state="translated">) 및 XS 코드 (</target>
        </trans-unit>
        <trans-unit id="2af0dc8b4d4fee8ec4a7da24968fc60d5db6f74b" translate="yes" xml:space="preserve">
          <source>) and for which I'll ignore the return value (that's the</source>
          <target state="translated">)에 대해 반환 값을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="5165405c0c57dc222008e31631e6e1160f7f0b2c" translate="yes" xml:space="preserve">
          <source>) and those are hidden inside</source>
          <target state="translated">) 안에 숨겨져 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e5051ed7ca1b9ef31e15eb004126ec2dc0cfec0" translate="yes" xml:space="preserve">
          <source>) and widths (32-bit and 64-bit being the most common today). This affects your programs when they attempt to transfer numbers in binary format from one CPU architecture to another, usually either &quot;live&quot; via network connection, or by storing the numbers to secondary storage such as a disk file or tape.</source>
          <target state="translated">) 및 너비 (32 비트 및 64 비트가 오늘날 가장 일반적입니다). 이것은 하나의 CPU 아키텍처에서 다른 CPU 아키텍처로 2 진 형식으로 숫자를 전송하려고 할 때 (일반적으로 네트워크 연결을 통해 &quot;라이브&quot;) 또는 디스크 파일 또는 테이프와 같은 2 차 스토리지에 숫자를 저장하여 프로그램에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="78d8c7b5bfb4d1d699ad80186c17bd61d5ef6810" translate="yes" xml:space="preserve">
          <source>) are accessed in the function and &lt;code&gt;dTHX&lt;/code&gt; is not used (the &lt;code&gt;dTHX&lt;/code&gt; includes the &lt;code&gt;dVAR&lt;/code&gt; if necessary). One notices the need for &lt;code&gt;dVAR&lt;/code&gt; only with the said compile-time define, because otherwise the Perl global variables are visible as-is.</source>
          <target state="translated">) 함수에 액세스하고 &lt;code&gt;dTHX&lt;/code&gt; 가 사용되지합니다 ( &lt;code&gt;dTHX&lt;/code&gt; 는 포함 &lt;code&gt;dVAR&lt;/code&gt; 필요한 경우). 그렇지 않으면 Perl 전역 변수가있는 그대로 표시되므로, 컴파일 시간이 정의 된 경우에만 &lt;code&gt;dVAR&lt;/code&gt; 이 필요하다는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0af76cebde929dc98391babdd9523facf0df1cb" translate="yes" xml:space="preserve">
          <source>) are also supported Since cygwin-1.7 non-POSIX pathnames are discouraged. Names may contain all printable characters.</source>
          <target state="translated">)도 지원됩니다. cygwin-1.7 비 POSIX 경로 이름은 권장되지 않습니다. 이름에는 인쇄 가능한 모든 문자가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d63c0b1ccaa850ba2ad69dd4a8ae1f8f0b54402" translate="yes" xml:space="preserve">
          <source>) are now created with the names which contain a checksum, thus allowing workaround for OS/2 scheme of caching DLLs.</source>
          <target state="translated">)는 이제 체크섬을 포함하는 이름으로 작성되므로 DLL 캐싱의 OS / 2 체계에 대한 임시 해결책을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="b9bcffac0b0e948cf7f6c750635e76e9488261a5" translate="yes" xml:space="preserve">
          <source>) are the same in both EBCDIC and UTF-EBCDIC. Often, documentation will use the term &quot;UTF-8&quot; to mean UTF-EBCDIC as well. This is the case in this document.</source>
          <target state="translated">)는 EBCDIC 및 UTF-EBCDIC에서 동일합니다. 종종 문서는 UTF-EBCDIC을 의미하기 위해 &quot;UTF-8&quot;이라는 용어를 사용합니다. 이 문서의 경우입니다.</target>
        </trans-unit>
        <trans-unit id="b688477e2141565165881be5ad0bc5987114795f" translate="yes" xml:space="preserve">
          <source>) are the same in both EBCDIC and UTF-EBCDIC.)</source>
          <target state="translated">)는 EBCDIC 및 UTF-EBCDIC에서 동일합니다.)</target>
        </trans-unit>
        <trans-unit id="b4703b8b08940fcfc8d37175488b06d9c5c2113f" translate="yes" xml:space="preserve">
          <source>) are to be ignored (because they cannot be linked against).</source>
          <target state="translated">)를 무시해야합니다 (연결할 수 없기 때문).</target>
        </trans-unit>
        <trans-unit id="228c4d656c7c5862fd93efef71f5a4b7ea37cfce" translate="yes" xml:space="preserve">
          <source>) as a hashref containing match criteria that determine if the current distribution matches the YAML document or not.</source>
          <target state="translated">)는 현재 분포가 YAML 문서와 일치하는지 여부를 결정하는 일치 조건을 포함하는 해시 참조로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0094c9f9603398d1e8131509fbaec9e6e56aa8b2" translate="yes" xml:space="preserve">
          <source>) associated with the module. If so, these will be entirely transparent to the user of the module. It is the responsibility of the</source>
          <target state="translated">)를 모듈과 연관시킵니다. 그렇다면 모듈 사용자에게 완전히 투명하게됩니다. 의 책임입니다</target>
        </trans-unit>
        <trans-unit id="8680fc3067e5b942a71155614ce3702a9457283f" translate="yes" xml:space="preserve">
          <source>) but simply depends on the choice of tmpdir() returned by L&amp;lt;:spec&amp;gt;. On some implementations this location can be set using the C</source>
          <target state="translated">)이지만 L &amp;lt;: spec&amp;gt;이 반환 한 tmpdir ()의 선택에 따라 달라집니다. 일부 구현에서이 위치는 C를 사용하여 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5659f7b4fec9440dfdc3905af70739f39cad629" translate="yes" xml:space="preserve">
          <source>) can be computed by the great_circle_direction() function:</source>
          <target state="translated">)는 great_circle_direction () 함수로 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fe6bd925320e38dae70ff8e3655937d2767bfc3" translate="yes" xml:space="preserve">
          <source>) can be tacked onto this variable to generate a list of directories to search.</source>
          <target state="translated">)를이 변수에 고정시켜 검색 할 디렉토리 목록을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a71d8063cc2fcb4f0ab849a5cf4c8ea8ac77b0fa" translate="yes" xml:space="preserve">
          <source>) contains references to many socket functions which need to be resolved when it's loaded. Most platforms will automatically know where to find the 'dependent' library (e.g.,</source>
          <target state="translated">)에는로드시 해결해야하는 많은 소켓 함수에 대한 참조가 포함되어 있습니다. 대부분의 플랫폼은 '종속'라이브러리를 찾을 수있는 위치를 자동으로 인식합니다 (예 :</target>
        </trans-unit>
        <trans-unit id="6380e7df837c25d9969247c6e203303247a8eb62" translate="yes" xml:space="preserve">
          <source>) for a thorough grounding and reference on the topic.</source>
          <target state="translated">) 주제에 대한 철저한 접지 및 참조</target>
        </trans-unit>
        <trans-unit id="1ef4dbc4e616fa1d18518cdf57dc3f1eed3a7798" translate="yes" xml:space="preserve">
          <source>) for the default perl executable, but for a more ambitious host (like the one that would do fork() emulation) all the extra work needed to pretend that different interpreters are actually different &quot;processes&quot;, would be done here.</source>
          <target state="translated">) 기본 perl 실행 파일의 경우, fork () 에뮬레이션을 수행하는 호스트와 같은보다 야심 찬 호스트의 경우 다른 인터프리터가 실제로 다른 &quot;프로세스&quot;인 척하는 데 필요한 모든 추가 작업이 여기에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="b34bf46ab4b61641e16b10e09bd70715019def08" translate="yes" xml:space="preserve">
          <source>) for your machine. If your compiler complains that certain functions are undefined, or that it can't locate</source>
          <target state="translated">)를 확인하십시오. 컴파일러가 특정 함수가 정의되지 않았거나 찾을 수 없다고 불평하는 경우</target>
        </trans-unit>
        <trans-unit id="0c582b687e9340adf76bd136bafc7a4e60851dd4" translate="yes" xml:space="preserve">
          <source>) from the database.</source>
          <target state="translated">) 데이터베이스에서.</target>
        </trans-unit>
        <trans-unit id="116f8f88f4b3848fbd987990694e39bf840bb1eb" translate="yes" xml:space="preserve">
          <source>) guaranteed to be large enough to represent the size of any string that perl can handle.</source>
          <target state="translated">)는 perl이 처리 할 수있는 문자열의 크기를 나타낼만큼 충분히 커야합니다.</target>
        </trans-unit>
        <trans-unit id="337e0c227846bd92d32db8132d6dfda91291a31c" translate="yes" xml:space="preserve">
          <source>) happens to do both these things.</source>
          <target state="translated">)는이 두 가지를 모두 수행합니다.</target>
        </trans-unit>
        <trans-unit id="8ddfd9e5fba9d0bfae55c0a9cf8e0e887dd2de61" translate="yes" xml:space="preserve">
          <source>) if set, overrides the path to the perl executable that should be used to run the tests (the default being</source>
          <target state="translated">) 설정하면 테스트 실행에 사용해야하는 perl 실행 파일의 경로를 대체합니다 (기본값은</target>
        </trans-unit>
        <trans-unit id="ddd938892f2a1218d436a7ea869a8e613d6a7846" translate="yes" xml:space="preserve">
          <source>) if the constructor was called with UNLINK set to 1 (the default state if UNLINK is not specified).</source>
          <target state="translated">) UNLINK가 1로 설정된 상태에서 생성자가 호출 된 경우 (UNLINK가 지정되지 않은 경우 기본 상태).</target>
        </trans-unit>
        <trans-unit id="475773772c97e29ee6060b95810ad4e1376538fc" translate="yes" xml:space="preserve">
          <source>) illustrating the creation, use and monitoring of a pool of</source>
          <target state="translated">) 풀의 생성, 사용 및 모니터링을 설명</target>
        </trans-unit>
        <trans-unit id="e7e44a7e4150f8fa3f3b373c79a37f8b07bb4a24" translate="yes" xml:space="preserve">
          <source>) into an SV whose reference is rv. SV is blessed if &lt;code&gt;classname&lt;/code&gt; is non-null.</source>
          <target state="translated">)를 참조가 rv 인 SV로 &lt;code&gt;classname&lt;/code&gt; 이 null이 아닌 경우 SV는 축복 입니다.</target>
        </trans-unit>
        <trans-unit id="9dac485013a652075c8f1c4b7fb1d43f1f85a1a3" translate="yes" xml:space="preserve">
          <source>) into an executable:</source>
          <target state="translated">)를 실행 파일로 :</target>
        </trans-unit>
        <trans-unit id="81b4f6fe6b33e8129f5b68846e0235e4b8d609db" translate="yes" xml:space="preserve">
          <source>) is a somewhat special case inasmuch as the concatenation of &lt;code&gt;$File::Find::dir&lt;/code&gt; , &lt;code&gt;'/'&lt;/code&gt; and &lt;code&gt;$_&lt;/code&gt; is not literally equal to &lt;code&gt;$File::Find::name&lt;/code&gt; . The table below summarizes all variants:</source>
          <target state="translated">)는 &lt;code&gt;$File::Find::dir&lt;/code&gt; , &lt;code&gt;'/'&lt;/code&gt; 및 &lt;code&gt;$_&lt;/code&gt; 이 문자 그대로 &lt;code&gt;$File::Find::name&lt;/code&gt; 과 같지 않기 때문에 다소 특별한 경우 입니다. 아래 표에는 모든 변형이 요약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf9470af5d5cf93f057397bef4222a4e4cd5a518" translate="yes" xml:space="preserve">
          <source>) is called instead, otherwise falling back to &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; (</source>
          <target state="translated">) 대신 호출되며, 그렇지 않으면 &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; (</target>
        </trans-unit>
        <trans-unit id="23696ac6362c5f53fb63901a51bae770c8ae962d" translate="yes" xml:space="preserve">
          <source>) is either a text-string or a reference to a &lt;b&gt;Pod::InteriorSequence&lt;/b&gt; object. The nodes appear in the parse-tree in the order in which they were parsed from left-to-right.</source>
          <target state="translated">)은 텍스트 문자열이거나 &lt;b&gt;Pod :: InteriorSequence&lt;/b&gt; 객체에 대한 참조 입니다. 노드는 왼쪽에서 오른쪽으로 구문 분석 된 순서대로 구문 분석 트리에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="5767c1b2b6c18556726990ab8b5bc59c494545e8" translate="yes" xml:space="preserve">
          <source>) is in that special format.</source>
          <target state="translated">)는 그 특별한 형식입니다.</target>
        </trans-unit>
        <trans-unit id="32f86aa54464138379726463882cdceaf0bcc1f8" translate="yes" xml:space="preserve">
          <source>) is made instead, with &lt;code&gt;$DB::sub&lt;/code&gt; holding the name of the called subroutine. (This doesn't happen if the subroutine was compiled in the &lt;code&gt;DB&lt;/code&gt; package.)</source>
          <target state="translated">) 대신 &lt;code&gt;$DB::sub&lt;/code&gt; 가 호출 된 서브 루틴의 이름을 보유합니다. (서브 루틴이 &lt;code&gt;DB&lt;/code&gt; 패키지 에서 컴파일 된 경우에는 발생하지 않습니다 .)</target>
        </trans-unit>
        <trans-unit id="09c02d83fc25240c47808099a2e4f821d696cb01" translate="yes" xml:space="preserve">
          <source>) is used as a package separator for documentation for packages, and as usual, sometimes you need to give the section - &lt;code&gt;3&lt;/code&gt; above - to avoid shadowing by the</source>
          <target state="translated">)는 패키지 문서화를위한 패키지 구분 기호로 사용되며, 평소와 같이 섀도 잉을 피하기 위해 위 의 섹션 &lt;code&gt;3&lt;/code&gt; 을 제공해야 합니다.</target>
        </trans-unit>
        <trans-unit id="5971125402714a98c492903d9612cbceea13e6b3" translate="yes" xml:space="preserve">
          <source>) model. However, some previous functionality is not available. Further, the data sharing models between the two thread models are completely different, and anything to do with data sharing has to be thought differently. With</source>
          <target state="translated">) 모델. 그러나 일부 이전 기능은 사용할 수 없습니다. 또한 두 스레드 모델 간의 데이터 공유 모델은 완전히 다르며 데이터 공유와 관련된 모든 내용은 다르게 생각해야합니다. 와</target>
        </trans-unit>
        <trans-unit id="50d605006e5819d9ee72b0368f957bba921207fa" translate="yes" xml:space="preserve">
          <source>) of EXPR. If EXPR is omitted, returns the log of &lt;code&gt;$_&lt;/code&gt; . To get the log of another base, use basic algebra: The base-N log of a number is equal to the natural log of that number divided by the natural log of N. For example:</source>
          <target state="translated">)의 EXPR. EXPR을 생략하면 &lt;code&gt;$_&lt;/code&gt; 로그를 리턴합니다 . 다른 밑의 로그를 구하려면 기본 대수를 사용하십시오. 숫자의 밑 N 로그는 해당 숫자의 자연 로그를 자연 로그 N으로 나눈 것과 같습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="34c99e6b33b978b2a76257b1ec099dd28fe4c5af" translate="yes" xml:space="preserve">
          <source>) or autoloaded subroutine definitions (often ending in</source>
          <target state="translated">) 또는 자동로드 서브 루틴 정의 (종종</target>
        </trans-unit>
        <trans-unit id="6268b6d7aba0dddbda46ab70ff997d6de27b91a4" translate="yes" xml:space="preserve">
          <source>) or small pieces of modules to be autoloaded (ending in</source>
          <target state="translated">) 또는 자동로드 할 작은 모듈 조각 (</target>
        </trans-unit>
        <trans-unit id="e0b4a008b1b72c63ec0fe1bf922f01ecd1e7dcea" translate="yes" xml:space="preserve">
          <source>) regarding the license:</source>
          <target state="translated">) 라이센스와 관련하여 :</target>
        </trans-unit>
        <trans-unit id="a45f9f3bff2ba18d925d19d588022f6b22bbbb23" translate="yes" xml:space="preserve">
          <source>) result in single code points and are locale independent and unconditional, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned (which means that the case mappings, if any, for the code point are those returned by &lt;a href=&quot;#charinfo()&quot;&gt;charinfo()&lt;/a&gt;).</source>
          <target state="translated">)는 단일 코드 포인트가되며 로케일 독립적이며 무조건적이며 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 리턴됩니다 (즉, 코드 포인트의 경우 케이스 맵핑은 &lt;a href=&quot;#charinfo()&quot;&gt;charinfo ()에&lt;/a&gt; 의해 리턴 된 것임 ).</target>
        </trans-unit>
        <trans-unit id="290a554d5dd4f4fd53f4f0c3f26a8b92afe46af9" translate="yes" xml:space="preserve">
          <source>) routine is available to get the current process group.</source>
          <target state="translated">) 루틴을 사용하여 현재 프로세스 그룹을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbfc535d542b663f5fc6309d86a766d1da4fdbb5" translate="yes" xml:space="preserve">
          <source>) routine is available to set the current process group.</source>
          <target state="translated">) 루틴을 사용하여 현재 프로세스 그룹을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26e28f24fd9b1f154c2e8f05eec3ce59bdb7d39d" translate="yes" xml:space="preserve">
          <source>) see whether a scalar contains a string, an integer, or a floating-point number. But you can still peek and poke these if you will. See the next section.</source>
          <target state="translated">)는 스칼라에 문자열, 정수 또는 부동 소수점 숫자가 포함되어 있는지 확인하십시오. 그러나 당신이 원한다면 여전히 훔쳐 볼 수 있습니다. 다음 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="edd28277fd127085fceb90541640e76ea071b695" translate="yes" xml:space="preserve">
          <source>) slashes, Universal Naming Codes (</source>
          <target state="translated">) 슬래시, 범용 명명 코드 (</target>
        </trans-unit>
        <trans-unit id="6fe21bfd6516c2f8c1ce99da2c5ba6214935b065" translate="yes" xml:space="preserve">
          <source>) that hide the details of the interpreter's context. THX stands for &quot;thread&quot;, &quot;this&quot;, or &quot;thingy&quot;, as the case may be. (And no, George Lucas is not involved. :-) The first character could be 'p' for a &lt;b&gt;p&lt;/b&gt;rototype, 'a' for &lt;b&gt;a&lt;/b&gt;rgument, or 'd' for &lt;b&gt;d&lt;/b&gt;eclaration, so we have &lt;code&gt;pTHX&lt;/code&gt; , &lt;code&gt;aTHX&lt;/code&gt; and &lt;code&gt;dTHX&lt;/code&gt; , and their variants.</source>
          <target state="translated">)는 통역사 컨텍스트의 세부 사항을 숨 깁니다. THX는 &quot;스레드&quot;, &quot;this&quot;또는 &quot;thingy&quot;를 의미합니다. (그리고 아니, 조지 루카스가 포함되어 있지 않습니다. :-) 첫 번째 문자가에 대한 'P'가 될 수 &lt;b&gt;페이지에&lt;/b&gt; 대한 rototype, 'A' 에 대한 rgument, 또는 'D' &lt;b&gt;D의&lt;/b&gt; 우리가 있도록, eclaration &lt;code&gt;pTHX&lt;/code&gt; , &lt;code&gt;aTHX&lt;/code&gt; 및 &lt;code&gt;dTHX&lt;/code&gt; 을 , 그리고 그들의 변종.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e97548e96f2ddff38307a0e5c64c9b937c5a39a0" translate="yes" xml:space="preserve">
          <source>) this is:</source>
          <target state="translated">) 이것은:</target>
        </trans-unit>
        <trans-unit id="58d0b83faa9818666bc1ae3462657cd7ca7c19ae" translate="yes" xml:space="preserve">
          <source>) to &lt;code&gt;PATH&lt;/code&gt; ; copy &lt;code&gt;perl_.exe&lt;/code&gt; to &lt;code&gt;PATH&lt;/code&gt; as &lt;code&gt;perl_5.8.2.exe&lt;/code&gt; . Think whether you need backward-compatibility DLLs. In most cases you do not need to install them yet; but sometime this may simplify the following steps.</source>
          <target state="translated">) ~ &lt;code&gt;PATH&lt;/code&gt; ; 복사 &lt;code&gt;perl_.exe&lt;/code&gt; 을 에 &lt;code&gt;PATH&lt;/code&gt; 로 &lt;code&gt;perl_5.8.2.exe&lt;/code&gt; . 이전 버전과 호환되는 DLL이 필요한지 생각해보십시오. 대부분의 경우 아직 설치할 필요가 없습니다. 그러나 때때로 다음 단계를 단순화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee8d0d482ba732e339db373655156b50d4f689fa" translate="yes" xml:space="preserve">
          <source>) variable.</source>
          <target state="translated">) 변수.</target>
        </trans-unit>
        <trans-unit id="8d6ab57f146723c24d110d324d107fe798a11b43" translate="yes" xml:space="preserve">
          <source>) where there are no parameters (except $_[0], the language handle).</source>
          <target state="translated">) 매개 변수가없는 경우 (언어 핸들 $ _ [0] 제외).</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
