<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="55a77b36211d3d02a45104bff8d76788cd986acc" translate="yes" xml:space="preserve">
          <source>You can get commercial support of Perl if you wish, although for most users the informal support will more than suffice. See the answer to &quot;Where can I buy a commercial version of Perl?&quot; for more information.</source>
          <target state="translated">대부분의 사용자에게는 비공식적 인 지원만으로 충분하지만 원하는 경우 Perl에 대한 상업적 지원을받을 수 있습니다. &quot;Perl의 상용 버전은 어디에서 구입할 수 있습니까?&quot;에 대한 답변을 참조하십시오. 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="83877e131c38375e988c7edf4defa59ad28286ba" translate="yes" xml:space="preserve">
          <source>You can get gzip from &lt;a href=&quot;ftp://prep.ai.mit.edu/pub/gnu/&quot;&gt;ftp://prep.ai.mit.edu/pub/gnu/&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ftp://prep.ai.mit.edu/pub/gnu/&quot;&gt;ftp://prep.ai.mit.edu/pub/gnu/&lt;/a&gt; 에서 gzip을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cc7caff36ea8191fb948cb25382a0802d8b70e3" translate="yes" xml:space="preserve">
          <source>You can get gzip from &lt;a href=&quot;http://www.s390.ibm.com/products/oe/bpxqp1.html&quot;&gt;http://www.s390.ibm.com/products/oe/bpxqp1.html&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://www.s390.ibm.com/products/oe/bpxqp1.html&quot;&gt;http://www.s390.ibm.com/products/oe/bpxqp1.html&lt;/a&gt; 에서 gzip을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ceb45063df183ed03ff063ebe2021495fbb9baff" translate="yes" xml:space="preserve">
          <source>You can get into trouble if you use constants in a context which automatically quotes barewords (as is true for any subroutine call). For example, you can't say &lt;code&gt;$hash{CONSTANT}&lt;/code&gt; because &lt;code&gt;CONSTANT&lt;/code&gt; will be interpreted as a string. Use &lt;code&gt;$hash{CONSTANT()}&lt;/code&gt; or &lt;code&gt;$hash{+CONSTANT}&lt;/code&gt; to prevent the bareword quoting mechanism from kicking in. Similarly, since the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator quotes a bareword immediately to its left, you have to say &lt;code&gt;CONSTANT() =&amp;gt; 'value'&lt;/code&gt; (or simply use a comma in place of the big arrow) instead of &lt;code&gt;CONSTANT =&amp;gt; 'value'&lt;/code&gt; .</source>
          <target state="translated">하위 단어를 자동으로 인용하는 컨텍스트에서 상수를 사용하면 문제가 발생할 수 있습니다 (서브 루틴 호출의 경우와 동일). 예를 들어, &lt;code&gt;CONSTANT&lt;/code&gt; 는 문자열로 해석 되므로 &lt;code&gt;$hash{CONSTANT}&lt;/code&gt; 말할 수 없습니다 . 사용 &lt;code&gt;$hash{CONSTANT()}&lt;/code&gt; 또는 &lt;code&gt;$hash{+CONSTANT}&lt;/code&gt; 에서 발로에서 메커니즘에 따옴표 bareword는 것을 방지 할 수 있습니다. 마찬가지로, 이후 &lt;code&gt;=&amp;gt;&lt;/code&gt; 연산자 시세 bareword는 즉시 그 왼쪽에, 당신은 말을 &lt;code&gt;CONSTANT() =&amp;gt; 'value'&lt;/code&gt; &lt;code&gt;CONSTANT =&amp;gt; 'value'&lt;/code&gt; 대신 value ' (또는 단순히 큰 화살표 대신 쉼표를 사용하십시오) .</target>
        </trans-unit>
        <trans-unit id="e6872803f70582536909b7aa8df4da94cd4d37a4" translate="yes" xml:space="preserve">
          <source>You can have an environment variable PERL_INSTALL_ROOT set which will be prepended as a directory to each installed file (and directory).</source>
          <target state="translated">설치된 각 파일 (및 디렉토리)에 디렉토리로 추가 될 환경 변수 PERL_INSTALL_ROOT 세트를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa58ede728fa900b2be53c5925b3b4ff8069c044" translate="yes" xml:space="preserve">
          <source>You can ignore [pad]THXx when browsing the Perl headers/sources. Those are strictly for use within the core. Extensions and embedders need only be aware of [pad]THX.</source>
          <target state="translated">Perl 헤더 / 소스를 탐색 할 때 [pad] THXx를 무시할 수 있습니다. 그것들은 코어 내에서 엄격하게 사용됩니다. 확장 프로그램 및 내장 프로그램은 [pad] THX 만 인식하면됩니다.</target>
        </trans-unit>
        <trans-unit id="f0a479cb9681a1cb4f6cbb2bcf71ac6471f5092e" translate="yes" xml:space="preserve">
          <source>You can imagine how bad things would be if, for example, the SYS$MANAGER or SYS$SYSTEM logical names were deleted.</source>
          <target state="translated">예를 들어 SYS $ MANAGER 또는 SYS $ SYSTEM 논리 이름이 삭제 된 경우 상황이 얼마나 나쁜지 상상할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2157dc8c06b7685edcc449748ab0e77243e5a157" translate="yes" xml:space="preserve">
          <source>You can immediately see a slightly different focus to the subroutine profiling modules, and we start to see exactly which line of code is taking the most time. That regex line is looking a bit suspicious, for example. Remember that these tools are supposed to be used together, there is no single best way to profile your code, you need to use the best tools for the job.</source>
          <target state="translated">서브 루틴 프로파일 링 모듈에 약간 다른 초점을 즉시 볼 수 있으며, 가장 시간이 오래 걸리는 코드를 정확히 파악하기 시작합니다. 예를 들어 그 정규식 줄은 조금 의심스러워 보입니다. 이러한 도구는 함께 사용되어야하며 코드를 프로파일 링하는 가장 좋은 방법은 없으며 작업에 가장 적합한 도구를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="01ccbef4b59df5e513c51a0c19924a7a01e4981e" translate="yes" xml:space="preserve">
          <source>You can import &lt;code&gt;:pushpop&lt;/code&gt; and maintain a stack of colors using PUSHCOLOR, POPCOLOR, and LOCALCOLOR. PUSHCOLOR takes the attribute string that starts its argument and pushes it onto a stack of attributes. POPCOLOR removes the top of the stack and restores the previous attributes set by the argument of a prior PUSHCOLOR. LOCALCOLOR surrounds its argument in a PUSHCOLOR and POPCOLOR so that the color resets afterward.</source>
          <target state="translated">PUSHCOLOR, POPCOLOR 및 LOCALCOLOR를 사용하여 &lt;code&gt;:pushpop&lt;/code&gt; 을 가져 와서 색상 스택을 유지할 수 있습니다 . PUSHCOLOR는 인수를 시작하는 속성 문자열을 가져 와서 속성 스택으로 푸시합니다. POPCOLOR는 스택의 상단을 제거하고 이전 PUSHCOLOR의 인수로 설정된 이전 속성을 복원합니다. LOCALCOLOR는 PUSHCOLOR 및 POPCOLOR에서 인수를 둘러싼 후 색상이 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="7225c37bbdccefc8a70c019da87c9b8dea7a6b29" translate="yes" xml:space="preserve">
          <source>You can import all the great circle formulas by</source>
          <target state="translated">당신은 모든 위대한 원 수식을 가져올 수 있습니다</target>
        </trans-unit>
        <trans-unit id="6ccdd2eb8d7e6ad6ca52482a2893e8ad5920726c" translate="yes" xml:space="preserve">
          <source>You can import radial coordinate conversion functions by using the &lt;code&gt;:radial&lt;/code&gt; tag:</source>
          <target state="translated">&lt;code&gt;:radial&lt;/code&gt; 태그를 사용하여 방사형 좌표 변환 함수를 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a747eb56defc25ea65ac8c773f590bb69f4cf6d4" translate="yes" xml:space="preserve">
          <source>You can import symbolic mode constants (&lt;code&gt;S_IF*&lt;/code&gt; ) and functions (&lt;code&gt;S_IS*&lt;/code&gt; ) from the Fcntl module:</source>
          <target state="translated">Fcntl 모듈에서 기호 모드 상수 ( &lt;code&gt;S_IF*&lt;/code&gt; ) 및 함수 ( &lt;code&gt;S_IS*&lt;/code&gt; )를 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c7c8f6c731717afeb2f914b548c9389d16df04b0" translate="yes" xml:space="preserve">
          <source>You can include one underscore between any two digits.</source>
          <target state="translated">두 자리 사이에 하나의 밑줄을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06780cff3747acdd27c6cb36674311a1b2286d47" translate="yes" xml:space="preserve">
          <source>You can instead write</source>
          <target state="translated">대신 쓸 수 있습니다</target>
        </trans-unit>
        <trans-unit id="c4bd7d42db9b74a8aac6c0368becb036004d4652" translate="yes" xml:space="preserve">
          <source>You can intermix &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt; matches with &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\G.../g&lt;/a&gt;&lt;/code&gt;, where &lt;code&gt;\G&lt;/code&gt; is a zero-width assertion that matches the exact position where the previous &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt;, if any, left off. Without the &lt;code&gt;/g&lt;/code&gt; modifier, the &lt;code&gt;\G&lt;/code&gt; assertion still anchors at &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; as it was at the start of the operation (see &lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;), but the match is of course only attempted once. Using &lt;code&gt;\G&lt;/code&gt; without &lt;code&gt;/g&lt;/code&gt; on a target string that has not previously had a &lt;code&gt;/g&lt;/code&gt; match applied to it is the same as using the &lt;code&gt;\A&lt;/code&gt; assertion to match the beginning of the string. Note also that, currently, &lt;code&gt;\G&lt;/code&gt; is only properly supported when anchored at the very beginning of the pattern.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\G.../g&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt; 일치를 m / \ G ... / g 와 혼합 할 수 있습니다 . 여기서 &lt;code&gt;\G&lt;/code&gt; 는 이전 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt; 가있는 경우 정확한 위치와 일치하는 폭이 0 인 어설 션입니다 (있는 경우). &lt;code&gt;/g&lt;/code&gt; 수정자가 없으면 &lt;code&gt;\G&lt;/code&gt; 어설 션 은 작업 시작시와 같이 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 여전히 고정 되지만 ( &lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt; 참조 ) 일치는 물론 한 번만 시도됩니다. 사용 &lt;code&gt;\G&lt;/code&gt; 하지 않고 &lt;code&gt;/g&lt;/code&gt; 이전에 있었던 않은 대상 문자열 &lt;code&gt;/g&lt;/code&gt; 적용된 일치하는 것은 사용하는 것과 동일하다 &lt;code&gt;\A&lt;/code&gt; 문자열의 시작과 일치하도록 주장. 또한 현재 &lt;code&gt;\G&lt;/code&gt; 패턴의 맨 처음에 고정 된 경우에만 제대로 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="83b86b2d839c827310b20f3c55919cf18f3acb03" translate="yes" xml:space="preserve">
          <source>You can inversely compute the destination if you know the starting point, direction, and distance:</source>
          <target state="translated">시작점, 방향 및 거리를 알고 있으면 대상을 역으로 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0dfc74f0d7463fa46580b22cd874ca59538b399a" translate="yes" xml:space="preserve">
          <source>You can list opcodes by names, or use a tag name; see &lt;a href=&quot;opcode#Predefined-Opcode-Tags&quot;&gt;Predefined Opcode Tags in Opcode&lt;/a&gt;.</source>
          <target state="translated">이름별로 opcode를 나열하거나 태그 이름을 사용할 수 있습니다. &lt;a href=&quot;opcode#Predefined-Opcode-Tags&quot;&gt;Opcode의 사전 정의 된 Opcode 태그를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="001468774175cba071073df8732faf49990cd65b" translate="yes" xml:space="preserve">
          <source>You can load a custom &lt;a href=&quot;http://search.cpan.org/perldoc/TAP::Parser::Formatter&quot;&gt;TAP::Parser::Formatter&lt;/a&gt;:</source>
          <target state="translated">사용자 정의 &lt;a href=&quot;http://search.cpan.org/perldoc/TAP::Parser::Formatter&quot;&gt;TAP :: Parser :: Formatter를&lt;/a&gt; 로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="97cc72d3ba21acacd11a8df6beb891397824853a" translate="yes" xml:space="preserve">
          <source>You can load custom &lt;a href=&quot;tap/parser/sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;s, to change the way the parser interprets particular</source>
          <target state="translated">사용자 정의 &lt;a href=&quot;tap/parser/sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler를&lt;/a&gt; 로드 하여 파서가 특정을 해석하는 방식을 변경할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="864c8cc598c8e4c08f636d6accb98e4216dd8dc6" translate="yes" xml:space="preserve">
          <source>You can log in to the bug tracking system and comment on existing bug reports. If you have additional information regarding an existing bug, please add it. This will help the porters fix the bug.</source>
          <target state="translated">버그 추적 시스템에 로그인하여 기존 버그 보고서에 댓글을 달 수 있습니다. 기존 버그에 관한 추가 정보가 있으면 추가하십시오. 포터가 버그를 수정하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="70b967da2737530b2ccb33fdb14ce4b355858a95" translate="yes" xml:space="preserve">
          <source>You can look into using the &lt;code&gt;DB_File&lt;/code&gt; module and &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie()&lt;/a&gt;&lt;/code&gt; using the &lt;code&gt;$DB_BTREE&lt;/code&gt; hash bindings as documented in &lt;a href=&quot;db_file#In-Memory-Databases&quot;&gt;In Memory Databases in DB_File&lt;/a&gt;. The &lt;a href=&quot;http://search.cpan.org/perldoc/Tie::IxHash&quot;&gt;Tie::IxHash&lt;/a&gt; module from CPAN might also be instructive. Although this does keep your hash sorted, you might not like the slowdown you suffer from the tie interface. Are you sure you need to do this? :)</source>
          <target state="translated">당신은 사용에 볼 수 &lt;code&gt;DB_File&lt;/code&gt; 의 모듈 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie()&lt;/a&gt;&lt;/code&gt; 은 Using &lt;code&gt;$DB_BTREE&lt;/code&gt; 에 설명 된대로 해시 바인딩 &lt;a href=&quot;db_file#In-Memory-Databases&quot;&gt;DB_File에 메모리 데이터베이스&lt;/a&gt; . CPAN 의 &lt;a href=&quot;http://search.cpan.org/perldoc/Tie::IxHash&quot;&gt;Tie :: IxHash&lt;/a&gt; 모듈도 도움이 될 수 있습니다. 이렇게하면 해시가 정렬되어 유지되지만 넥타이 인터페이스로 인한 속도 저하를 좋아하지 않을 수 있습니다. 이 작업을 수행해야합니까? :)</target>
        </trans-unit>
        <trans-unit id="d03c6c46e2fd91fc95b867e10fbdca9429550351" translate="yes" xml:space="preserve">
          <source>You can make references to anything, including scalars, functions, and other references.</source>
          <target state="translated">스칼라, 함수 및 기타 참조를 포함하여 모든 것을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f238aab29e64ee5c9b032d4d04c0ab30c79c6501" translate="yes" xml:space="preserve">
          <source>You can make the while loop a lot shorter with this suggestion from Benjamin Goldberg:</source>
          <target state="translated">Benjamin Goldberg의 제안으로 while 루프를 훨씬 짧게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ec5f2b2db5f7957e7b186e607473a4a56ae2fd0" translate="yes" xml:space="preserve">
          <source>You can make your configuration changes permanent by calling the command &lt;code&gt;o conf commit&lt;/code&gt; . Alternatively set the &lt;code&gt;auto_commit&lt;/code&gt; variable to true by running &lt;code&gt;o conf init auto_commit&lt;/code&gt; and answering the following question with yes.</source>
          <target state="translated">&lt;code&gt;o conf commit&lt;/code&gt; 명령을 호출하여 구성 변경을 영구적으로 만들 수 있습니다 . 또는 &lt;code&gt;o conf init auto_commit&lt;/code&gt; 을 실행 하고 yes로 다음 질문에 대답 하여 &lt;code&gt;auto_commit&lt;/code&gt; 변수를 true로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="2011dcb658fe55c431da3ed5067e6f4bf4528970" translate="yes" xml:space="preserve">
          <source>You can mimic class subtraction using lookahead. For example, what UTS#18 might write as</source>
          <target state="translated">lookahead를 사용하여 클래스 빼기를 모방 할 수 있습니다. 예를 들어 UTS # 18은 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3461cd371c3715543776c435145f8478a0ac6ec8" translate="yes" xml:space="preserve">
          <source>You can mock TTY input to debugger by adding arbitrary commands to @DB::typeahead. For example, your</source>
          <target state="translated">@DB :: typeahead에 임의의 명령을 추가하여 디버거에 TTY 입력을 조롱 할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="cf9cef6663d4cd69a19179eacb290a6dcc1e8352" translate="yes" xml:space="preserve">
          <source>You can modify &lt;code&gt;@ARGV&lt;/code&gt; before the first &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; as long as the array ends up containing the list of filenames you really want. Line numbers (&lt;code&gt;$.&lt;/code&gt; ) continue as though the input were one big happy file. See the example in &lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt; for how to reset line numbers on each file.</source>
          <target state="translated">배열이 실제로 원하는 파일 이름 목록을 포함하는 한 첫 번째 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 전에 &lt;code&gt;@ARGV&lt;/code&gt; 를 수정할 수 있습니다 . 입력이 하나의 큰 행복한 파일 인 것처럼 줄 번호 ( &lt;code&gt;$.&lt;/code&gt; )는 계속됩니다. 각 파일에서 줄 번호를 재설정하는 방법 은 &lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt; 의 예를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4c8a419c4027fffc2a00680692cdd50042e9d07e" translate="yes" xml:space="preserve">
          <source>You can modify the 'commands' for example to hardwire an absolute path by e.g.</source>
          <target state="translated">예를 들어 'commands'를 수정하여 절대 경로를 고정 배선 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3de41be22b6a5efcacf396fbce08b0572f97fd60" translate="yes" xml:space="preserve">
          <source>You can only declare autoties for types &lt;code&gt;&quot;SCALAR&quot;&lt;/code&gt; , &lt;code&gt;&quot;ARRAY&quot;&lt;/code&gt; , and &lt;code&gt;&quot;HASH&quot;&lt;/code&gt; . They're the only things (apart from typeglobs -- which are not declarable) that Perl can tie.</source>
          <target state="translated">&lt;code&gt;&quot;SCALAR&quot;&lt;/code&gt; , &lt;code&gt;&quot;ARRAY&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;HASH&quot;&lt;/code&gt; 유형에 대한 자동 연결 만 선언 할 수 있습니다 . 그것들은 Perl이 묶을 수있는 유일한 것입니다 (타입 글롭과는 별개입니다).</target>
        </trans-unit>
        <trans-unit id="48d6492d8d5c8ebf50c4b6f0278c97639e62301c" translate="yes" xml:space="preserve">
          <source>You can only obtain this using an alias, and Getopt::Long of at least version 2.13.</source>
          <target state="translated">별명과 최소한 버전 2.13의 Getopt :: Long을 사용하여이를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ce5924582aac2aa9ee7cd1ad99c9e8ff1e6ecea" translate="yes" xml:space="preserve">
          <source>You can only use the elliptical statement to stand in for a complete statement. These examples of how the ellipsis works:</source>
          <target state="translated">완전한 문장을 나타 내기 위해 타원형 문장 만 사용할 수 있습니다. 줄임표 작동 방식에 대한 다음 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9cae8654bfe063f888826b48470927a2c30f96cd" translate="yes" xml:space="preserve">
          <source>You can open a file for input or output using the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; function. It's documented in extravagant detail in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; and &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt;, but in short:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 입력 또는 출력 할 파일을 열 수 있습니다 . &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; 및 &lt;a href=&quot;perlopentut&quot;&gt;perlopentut에 사소한&lt;/a&gt; 세부 사항으로 문서화되어 있지만 짧게 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce96504bc4965bb9a6b5d98ed74131b7aef0ff79" translate="yes" xml:space="preserve">
          <source>You can override predefined aliases by simply applying define_alias(). The new alias is always evaluated first, and when necessary, define_alias() flushes the internal cache to make the new definition available.</source>
          <target state="translated">define_alias ()를 적용하여 미리 정의 된 별칭을 재정의 할 수 있습니다. 새 별명은 항상 먼저 평가되며 필요한 경우 define_alias ()는 내부 캐시를 비워서 새 정의를 사용할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="ef785435f6086fb9fd6b00d9def6f92017001719" translate="yes" xml:space="preserve">
          <source>You can override the default and build a shared libperl if you wish (Configure ... -Duseshrplib).</source>
          <target state="translated">원하는 경우 기본값을 무시하고 공유 라이브러리를 구성 할 수 있습니다 (Configure ... -Duseshrplib).</target>
        </trans-unit>
        <trans-unit id="97ed2e27db33bd8f090672fcd70380db3caec730" translate="yes" xml:space="preserve">
          <source>You can override this by giving extra arguments; see below.</source>
          <target state="translated">추가 인수를 제공하여이를 무시할 수 있습니다. 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="73f74d7cb907a2b7504c7060b4ad0ec87a6506fe" translate="yes" xml:space="preserve">
          <source>You can override this by passing the desired rounding mode as parameter to &lt;code&gt;as_number()&lt;/code&gt; :</source>
          <target state="translated">원하는 반올림 모드를 매개 변수로 &lt;code&gt;as_number()&lt;/code&gt; 에 전달하여이를 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="92b4dbfc185a430ad159257351a9ef1b4f3e946a" translate="yes" xml:space="preserve">
          <source>You can pass an argument to your plugin by appending an &lt;code&gt;=&lt;/code&gt; after the plugin name, eg &lt;code&gt;-PMyPlugin=foo&lt;/code&gt; . You can pass multiple arguments using commas:</source>
          <target state="translated">플러그인 이름 뒤에 &lt;code&gt;=&lt;/code&gt; 를 추가하여 플러그인에 인수를 전달할 수 있습니다 ( 예 : &lt;code&gt;-PMyPlugin=foo&lt;/code&gt; ) . 쉼표를 사용하여 여러 인수를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="577ba47f8467272240629f611eeec9e04fdaf1e6" translate="yes" xml:space="preserve">
          <source>You can pass arguments to your plugin by appending &lt;code&gt;=arg1,arg2,etc&lt;/code&gt; to the plugin name:</source>
          <target state="translated">플러그인 이름에 &lt;code&gt;=arg1,arg2,etc&lt;/code&gt; 을 추가하여 플러그인에 인수를 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d9b26d7e57483cd1ed4bf2659755481a3ca93653" translate="yes" xml:space="preserve">
          <source>You can pick up prebuilt binaries for Solaris from &lt;a href=&quot;http://www.sunfreeware.com/&quot;&gt;http://www.sunfreeware.com/&lt;/a&gt;, &lt;a href=&quot;http://www.blastwave.org&quot;&gt;http://www.blastwave.org&lt;/a&gt;, ActiveState &lt;a href=&quot;http://www.activestate.com/&quot;&gt;http://www.activestate.com/&lt;/a&gt;, and &lt;a href=&quot;http://www.perl.com/&quot;&gt;http://www.perl.com/&lt;/a&gt; under the Binaries list at the top of the page. There are probably other sources as well. Please note that these sites are under the control of their respective owners, not the perl developers.</source>
          <target state="translated">&lt;a href=&quot;http://www.sunfreeware.com/&quot;&gt;http://www.sunfreeware.com/&lt;/a&gt; , &lt;a href=&quot;http://www.blastwave.org&quot;&gt;http://www.blastwave.org&lt;/a&gt; , ActiveState &lt;a href=&quot;http://www.activestate.com/&quot;&gt;http://www.activestate.com/&lt;/a&gt; 및 &lt;a href=&quot;http://www.perl.com/&quot;&gt;http : //www.perl&lt;/a&gt; 에서 Solaris 용 사전 빌드 바이너리를 선택할 수 있습니다 . .com / 페이지 상단의 바이너리 목록 아래에 있습니다. 다른 출처도있을 것입니다. 이 사이트는 펄 개발자가 아닌 해당 소유자의 통제하에 있습니다.</target>
        </trans-unit>
        <trans-unit id="afad181efc494d271a3d1339fc4bea9100125dd3" translate="yes" xml:space="preserve">
          <source>You can preallocate space for a hash by assigning to the keys() function. This rounds up the allocated buckets to the next power of two:</source>
          <target state="translated">keys () 함수에 할당하여 해시를위한 공간을 미리 할당 할 수 있습니다. 이렇게하면 할당 된 버킷이 다음 2의 제곱으로 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="6ece78405c91977c16dd3a742419b856c5fd5394" translate="yes" xml:space="preserve">
          <source>You can probably expect your users to be able to guess that they can request less CPU or memory or just &quot;less&quot; overall.</source>
          <target state="translated">아마도 사용자가 적은 CPU 나 메모리를 요구하거나 전체적으로 &quot;낮은&quot;것을 추측 할 수있을 것으로 예상 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bb56a3e59af78b8d5da4daff16effef12d060e2" translate="yes" xml:space="preserve">
          <source>You can provide this layer when &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;ing the file:</source>
          <target state="translated">파일을 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 때이 계층을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="87d0d59bd2621cca1e6ec0d854420947ec5a4ec5" translate="yes" xml:space="preserve">
          <source>You can put a &lt;code&gt;+&lt;/code&gt; in front of the &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&lt;/code&gt; to indicate that you want both read and write access to the file; thus &lt;code&gt;+&amp;lt;&lt;/code&gt; is almost always preferred for read/write updates--the &lt;code&gt;+&amp;gt;&lt;/code&gt; mode would clobber the file first. You can't usually use either read-write mode for updating textfiles, since they have variable-length records. See the &lt;b&gt;-i&lt;/b&gt; switch in &lt;a href=&quot;../perlrun&quot;&gt;perlrun&lt;/a&gt; for a better approach. The file is created with permissions of &lt;code&gt;0666&lt;/code&gt; modified by the process's &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; value.</source>
          <target state="translated">파일에 대한 읽기 및 쓰기 액세스를 원한다는 것을 나타 내기 위해 &lt;code&gt;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;&lt;/code&gt; 앞에 &lt;code&gt;+&lt;/code&gt; 를 넣을 수 있습니다 . 따라서 &lt;code&gt;+&amp;lt;&lt;/code&gt; 는 거의 항상 읽기 / 쓰기 업데이트에 적합합니다. &lt;code&gt;+&amp;gt;&lt;/code&gt; 모드는 파일을 먼저 복제합니다. 텍스트 파일에는 가변 길이 레코드가 있으므로 일반적으로 텍스트 파일을 업데이트하기 위해 읽기 / 쓰기 모드를 사용할 수 없습니다. 더 나은 접근 방법 은 &lt;a href=&quot;../perlrun&quot;&gt;perlrun&lt;/a&gt; 의 &lt;b&gt;-i&lt;/b&gt; 스위치를 참조하십시오 . 파일은 프로세스의 &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 값에 의해 수정 된 권한 &lt;code&gt;0666&lt;/code&gt; 으로 작성됩니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a5c78cfaaebb70f40ad0f93e0301fba4283c243b" translate="yes" xml:space="preserve">
          <source>You can put a &lt;code&gt;+&lt;/code&gt; in front of the &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&lt;/code&gt; to indicate that you want both read and write access to the file; thus &lt;code&gt;+&amp;lt;&lt;/code&gt; is almost always preferred for read/write updates--the &lt;code&gt;+&amp;gt;&lt;/code&gt; mode would clobber the file first. You can't usually use either read-write mode for updating textfiles, since they have variable-length records. See the &lt;b&gt;-i&lt;/b&gt; switch in &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; for a better approach. The file is created with permissions of &lt;code&gt;0666&lt;/code&gt; modified by the process's &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; value.</source>
          <target state="translated">파일에 대한 읽기 및 쓰기 액세스를 원한다는 것을 나타 내기 위해 &lt;code&gt;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;&lt;/code&gt; 앞에 &lt;code&gt;+&lt;/code&gt; 를 넣을 수 있습니다 . 따라서 &lt;code&gt;+&amp;lt;&lt;/code&gt; 는 거의 항상 읽기 / 쓰기 업데이트에 적합합니다. &lt;code&gt;+&amp;gt;&lt;/code&gt; 모드는 파일을 먼저 복제합니다. 텍스트 파일에는 가변 길이 레코드가 있으므로 일반적으로 텍스트 파일을 업데이트하기 위해 읽기 / 쓰기 모드를 사용할 수 없습니다. 더 나은 접근 방법 은 &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; 의 &lt;b&gt;-i&lt;/b&gt; 스위치를 참조하십시오 . 파일은 프로세스의 &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 값에 의해 수정 된 권한 &lt;code&gt;0666&lt;/code&gt; 으로 작성됩니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7c8c4f9eec7c5f71cbfe88cf0f5ec847885d12d2" translate="yes" xml:space="preserve">
          <source>You can put any backslash sequence character class (with the exception of &lt;code&gt;\N&lt;/code&gt; and &lt;code&gt;\R&lt;/code&gt; ) inside a bracketed character class, and it will act just as if you had put all characters matched by the backslash sequence inside the character class. For instance, &lt;code&gt;[a-f\d]&lt;/code&gt; matches any decimal digit, or any of the lowercase letters between 'a' and 'f' inclusive.</source>
          <target state="translated">백 슬래시 시퀀스 문자 클래스 ( &lt;code&gt;\N&lt;/code&gt; 및 &lt;code&gt;\R&lt;/code&gt; 제외)를 괄호 문자 클래스 안에 넣을 수 있으며, 백 슬래시 시퀀스와 일치하는 모든 문자를 문자 클래스 안에 넣은 것처럼 작동합니다. 예를 들어, &lt;code&gt;[a-f\d]&lt;/code&gt; 는 10 진수 또는 'a'와 'f'사이의 소문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="a88a6953f485e8c5fc3aeb601fd219de754900f0" translate="yes" xml:space="preserve">
          <source>You can read from an open filehandle using the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator. In scalar context it reads a single line from the filehandle, and in list context it reads the whole file in, assigning each line to an element of the list:</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 연산자를 사용하여 열린 파일 핸들에서 읽을 수 있습니다 . 스칼라 문맥에서는 파일 핸들에서 한 줄을 읽고,리스트 문맥에서는 전체 파일을 읽어 각 줄을 목록의 요소에 할당합니다.</target>
        </trans-unit>
        <trans-unit id="91ab2ef6e453973e41443b71f9d3e34175e99630" translate="yes" xml:space="preserve">
          <source>You can read more about profiling in</source>
          <target state="translated">프로파일 링에 대한 자세한 내용은</target>
        </trans-unit>
        <trans-unit id="00f2324bbf3536a80f241b597db331417bcbe8c1" translate="yes" xml:space="preserve">
          <source>You can redistribute and/or modify this document under the same terms as Perl itself.</source>
          <target state="translated">Perl과 동일한 용어로이 문서를 재배포 및 / 또는 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7dc0e1fc9ad5b87e77bf63d3f4081648cdf49ca" translate="yes" xml:space="preserve">
          <source>You can request that the flock() constants (LOCK_SH, LOCK_EX, LOCK_NB and LOCK_UN) be provided by using the tag &lt;code&gt;:&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; . See &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;.</source>
          <target state="translated">당신은 무리 () 상수 (LOCK_SH, LOCK_EX, LOCK_NB 및 LOCK_UN)가 태그를 사용하여 제공하도록 요청할 수 있습니다 &lt;code&gt;:&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; . &lt;a href=&quot;exporter&quot;&gt;내보내기를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e9f4701466ab8780e7a2b0e9f2a17e8d0b7017d5" translate="yes" xml:space="preserve">
          <source>You can request that the old constants (FAPPEND, FASYNC, FCREAT, FDEFER, FEXCL, FNDELAY, FNONBLOCK, FSYNC, FTRUNC) be provided for compatibility reasons by using the tag &lt;code&gt;:Fcompat&lt;/code&gt; . For new applications the newer versions of these constants are suggested (O_APPEND, O_ASYNC, O_CREAT, O_DEFER, O_EXCL, O_NDELAY, O_NONBLOCK, O_SYNC, O_TRUNC).</source>
          <target state="translated">&lt;code&gt;:Fcompat&lt;/code&gt; 태그를 사용하여 이전 상수 (FAPPEND, FASYNC, FCREAT, FDEFER, FEXCL, FNDELAY, FNONBLOCK, FSYNC, FTRUNC)를 호환성 이유로 제공하도록 요청할 수 있습니다. 새로운 애플리케이션의 경우 이러한 상수의 최신 버전이 제안됩니다 (O_APPEND, O_ASYNC, O_CREAT, O_DEFER, O_EXCL, O_NDELAY, O_NONBLOCK, O_SYNC, O_TRUNC).</target>
        </trans-unit>
        <trans-unit id="caaaaed5194349d7e53889bf69ba7c88d167c7d9" translate="yes" xml:space="preserve">
          <source>You can reset this cache by assigning an empty hashref to it, or individually remove keys.</source>
          <target state="translated">빈 해시 참조를 할당하여 캐시를 재설정하거나 키를 개별적으로 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4fc671bd928d082df8dcbc4d77c81ac14538200" translate="yes" xml:space="preserve">
          <source>You can retrieve the result via -&amp;gt;data but usually you don't have to because the stringify operator (&quot;&quot;) is overridden to do exactly that.</source>
          <target state="translated">-&amp;gt; data를 통해 결과를 검색 할 수 있지만 stringify 연산자 ( &quot;&quot;)가이를 정확하게 재정의하기 때문에 일반적으로 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1bc6861c31e761832a97f33e3f90e04d306eb3ee" translate="yes" xml:space="preserve">
          <source>You can return the</source>
          <target state="translated">당신은 반환 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="c5203f3ceab8b6b9bc7b6ca2deddcda6d494d3e9" translate="yes" xml:space="preserve">
          <source>You can run a command in the background with:</source>
          <target state="translated">다음을 사용하여 백그라운드에서 명령을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c92356e98ca4379f9b92a2bcc41db6e953218853" translate="yes" xml:space="preserve">
          <source>You can run all the tests with the following commands:</source>
          <target state="translated">다음 명령을 사용하여 모든 테스트를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dab3a450deb8a8c4cd405b2e23f88d23efbbf2ec" translate="yes" xml:space="preserve">
          <source>You can run an individual test by a command similar to</source>
          <target state="translated">다음과 유사한 명령으로 개별 테스트를 실행할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="7019e534322025bbdc3a56a0ada6decc0fac6688" translate="yes" xml:space="preserve">
          <source>You can run into similar problems when you store &lt;code&gt;&amp;amp;PL_sv_yes&lt;/code&gt; or &lt;code&gt;&amp;amp;PL_sv_no&lt;/code&gt; into AVs or HVs. Trying to modify such elements will give you the following error:</source>
          <target state="translated">&lt;code&gt;&amp;amp;PL_sv_yes&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;PL_sv_no&lt;/code&gt; 를 AV 또는 HV에 저장할 때 비슷한 문제가 발생할 수 있습니다 . 이러한 요소를 수정하려고하면 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="48a3f2e45a171b8580b9277e027aa9cbf304aecf" translate="yes" xml:space="preserve">
          <source>You can run part of the test suite by hand by using one of the following commands from the</source>
          <target state="translated">에서 다음 명령 중 하나를 사용하여 테스트 스위트의 일부를 직접 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9677002a55994cfb79edd644465223dc6f275627" translate="yes" xml:space="preserve">
          <source>You can safely ignore the line about &quot;prototyping behavior&quot; - it is explained in &lt;a href=&quot;perlxs#The-PROTOTYPES%3a-Keyword&quot;&gt;The PROTOTYPES: Keyword in perlxs&lt;/a&gt;.</source>
          <target state="translated">&quot;프로토 타이핑 동작&quot;에 대한 행을 무시 &lt;a href=&quot;perlxs#The-PROTOTYPES%3a-Keyword&quot;&gt;해도&lt;/a&gt; 됩니다. PROTOTYPES : 키워드의 perlxs에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="00bbb0e9f9b7d267fed175221358a00b2882f0e8" translate="yes" xml:space="preserve">
          <source>You can safely replace &lt;code&gt;isa&lt;/code&gt; with &lt;code&gt;DOES&lt;/code&gt; (although the converse is not true).</source>
          <target state="translated">&lt;code&gt;isa&lt;/code&gt; 를 &lt;code&gt;DOES&lt;/code&gt; 로 안전하게 바꿀 수 있습니다 (대화는 사실이 아니지만).</target>
        </trans-unit>
        <trans-unit id="f3c22b7008ae62adff98ca02982c07c25fd7ebcc" translate="yes" xml:space="preserve">
          <source>You can say &lt;code&gt;*foo{PACKAGE}&lt;/code&gt; and &lt;code&gt;*foo{NAME}&lt;/code&gt; to find out what name and package the *foo symbol table entry comes from. This may be useful in a subroutine that gets passed typeglobs as arguments:</source>
          <target state="translated">당신은 말할 수 &lt;code&gt;*foo{PACKAGE}&lt;/code&gt; 및 &lt;code&gt;*foo{NAME}&lt;/code&gt; 어떤 이름을 발견하고 * foo는 심볼 테이블 엔트리에서 오는 패키징. 이것은 typeglobs를 인수로 전달받는 서브 루틴에서 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1966e0b952d6a25db96c9f73b3f341a3e54cf712" translate="yes" xml:space="preserve">
          <source>You can say &lt;code&gt;BEGIN { $Exporter::Verbose=1 }&lt;/code&gt; to see how the specifications are being processed and what is actually being imported into modules.</source>
          <target state="translated">&lt;code&gt;BEGIN { $Exporter::Verbose=1 }&lt;/code&gt; 이라고 말하면 사양을 처리하는 방법과 실제로 모듈로 가져 오는 내용을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ffa8d04bb2be838b7be17e141561b51ef27dbcb" translate="yes" xml:space="preserve">
          <source>You can search CPAN on &lt;a href=&quot;http://metacpan.org&quot;&gt;http://metacpan.org&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/&quot;&gt;http://search.cpan.org/&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://metacpan.org&quot;&gt;http://metacpan.org&lt;/a&gt; 또는 &lt;a href=&quot;http://search.cpan.org/&quot;&gt;http://search.cpan.org/&lt;/a&gt; 에서 CPAN을 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="decda746759f350cc820cd1383e913824bf2e767" translate="yes" xml:space="preserve">
          <source>You can search for &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; related bug reports at &lt;a href=&quot;http://rt.cpan.org/Public/&quot;&gt;http://rt.cpan.org/Public/&lt;/a&gt;. If needed submit any new bugs, problems, patches, etc. to: &lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=threads&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=threads&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://rt.cpan.org/Public/&quot;&gt;http://rt.cpan.org/Public/&lt;/a&gt; 에서 &lt;a href=&quot;threads&quot;&gt;스레드&lt;/a&gt; 관련 버그 보고서를 검색 할 수 있습니다 . 필요한 경우 새로운 버그, 문제, 패치 등을 다음 주소로 제출하십시오. &lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=threads&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=threads&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="802f6c1f9273b694e1c0cdbd6edb66de5f11d6b4" translate="yes" xml:space="preserve">
          <source>You can see from the above that the effect of &lt;code&gt;unicode_strings&lt;/code&gt; increased over several Perl releases. (And Perl's support for Unicode continues to improve; it's best to use the latest available release in order to get the most complete and accurate results possible.) Note that &lt;code&gt;unicode_strings&lt;/code&gt; is automatically chosen if you &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; or higher.</source>
          <target state="translated">위에서 &lt;code&gt;unicode_strings&lt;/code&gt; 의 효과가 여러 Perl 릴리스에 비해 증가 했음을 알 수 있습니다 . Perl의 유니 코드에 대한 지원은 계속 향상되고 있으며 가장 완벽하고 정확한 결과를 얻으려면 사용 가능한 최신 릴리스를 사용하는 것이 가장 좋습니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; 이상 을 &lt;a href=&quot;functions/use&quot;&gt;사용하는&lt;/a&gt; 경우 &lt;code&gt;unicode_strings&lt;/code&gt; 가 자동으로 선택됩니다 .</target>
        </trans-unit>
        <trans-unit id="169f5a8ded36f882f89340ed4481186781ecd0dd" translate="yes" xml:space="preserve">
          <source>You can see this with the following:</source>
          <target state="translated">다음과 같이 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a30453af312489e18bd58825504c04b5c3c816c5" translate="yes" xml:space="preserve">
          <source>You can see whether your Perl was built with PerlIO by running &lt;code&gt;perl -V&lt;/code&gt; and looking for the &lt;code&gt;useperlio=&lt;/code&gt; line. If &lt;code&gt;useperlio&lt;/code&gt; is &lt;code&gt;define&lt;/code&gt; , you have PerlIO; otherwise you don't.</source>
          <target state="translated">&lt;code&gt;perl -V&lt;/code&gt; 를 실행 하고 &lt;code&gt;useperlio=&lt;/code&gt; 행을 찾아서 PerlIO로 Perl을 빌드했는지 여부를 확인할 수 있습니다 . 경우 &lt;code&gt;useperlio&lt;/code&gt; 이 있다 &lt;code&gt;define&lt;/code&gt; , 당신은 PerlIO이있다; 그렇지 않으면 당신은하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1d64238a1676682fd78cc68f5aa21599974d313a" translate="yes" xml:space="preserve">
          <source>You can see which (or neither) threading flavour you have by running &lt;code&gt;perl -V&lt;/code&gt; and looking at the &lt;code&gt;Platform&lt;/code&gt; section. If you have &lt;code&gt;useithreads=define&lt;/code&gt; you have ithreads, if you have &lt;code&gt;use5005threads=define&lt;/code&gt; you have 5.005 threads. If you have neither, you don't have any thread support built in. If you have both, you are in trouble.</source>
          <target state="translated">&lt;code&gt;perl -V&lt;/code&gt; 를 실행 하고 &lt;code&gt;Platform&lt;/code&gt; 섹션을 보면 어떤 스레딩 풍미가 있는지 확인할 수 있습니다 . &lt;code&gt;useithreads=define&lt;/code&gt; 이 있으면 ithread 가 있고 , &lt;code&gt;use5005threads=define&lt;/code&gt; 이있는 경우 5.005 스레드가 있습니다. 둘 다 없으면 스레드 지원 기능이 내장되어 있지 않습니다. 둘 다 가지고 있으면 문제가있는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8dc1d6869249a32d7f829c0b3a5e051d9383488b" translate="yes" xml:space="preserve">
          <source>You can see why the arrows are important. Without them, we would have had to write &lt;code&gt;${$a[1]}[2]&lt;/code&gt; instead of &lt;code&gt;$a[1][2]&lt;/code&gt; . For three-dimensional arrays, they let us write &lt;code&gt;$x[2][3][5]&lt;/code&gt; instead of the unreadable &lt;code&gt;${${$x[2]}[3]}[5]&lt;/code&gt; .</source>
          <target state="translated">화살표가 왜 중요한지 알 수 있습니다. 그들없이, 우리는 작성했을 것이다 &lt;code&gt;${$a[1]}[2]&lt;/code&gt; 대신 &lt;code&gt;$a[1][2]&lt;/code&gt; . 3 차원 배열 의 경우 읽을 수없는 &lt;code&gt;${${$x[2]}[3]}[5]&lt;/code&gt; 대신 &lt;code&gt;$x[2][3][5]&lt;/code&gt; 를 쓰도록하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="b46ad3852d414e337d72bbed36bfa27c57b29adc" translate="yes" xml:space="preserve">
          <source>You can set and query each of these options interactively in the cpan shell with the &lt;code&gt;o conf&lt;/code&gt; or the &lt;code&gt;o conf init&lt;/code&gt; command as specified below.</source>
          <target state="translated">아래에 지정된대로 &lt;code&gt;o conf&lt;/code&gt; 또는 &lt;code&gt;o conf init&lt;/code&gt; 명령을 사용 하여 cpan 쉘에서 이러한 각 옵션을 대화식으로 설정하고 쿼리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="16508b3f102bc9307eda4b040c0235215ac4aad7" translate="yes" xml:space="preserve">
          <source>You can set the &lt;code&gt;%POSIX::SIGRT&lt;/code&gt; elements to set the POSIX realtime signal handlers, use &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; on the elements, and use &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; on the &lt;code&gt;%POSIX::SIGRT&lt;/code&gt; to find out how many POSIX realtime signals there are available &lt;code&gt;(SIGRTMAX - SIGRTMIN + 1&lt;/code&gt; , the &lt;code&gt;SIGRTMAX&lt;/code&gt; is a valid POSIX realtime signal).</source>
          <target state="translated">POSIX 실시간 신호 처리기를 설정하고 요소에 &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; 를 사용 하고 &lt;code&gt;%POSIX::SIGRT&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; 를 사용하여 사용 가능한 POSIX 실시간 신호 수를 확인하려면 &lt;code&gt;%POSIX::SIGRT&lt;/code&gt; 요소를 설정할 수 있습니다 &lt;code&gt;(SIGRTMAX - SIGRTMIN + 1&lt;/code&gt; 이면 &lt;code&gt;SIGRTMAX&lt;/code&gt; 는 유효한 POSIX 실시간 신호입니다.</target>
        </trans-unit>
        <trans-unit id="3f6da332e187deef2beadbe770ab6beeaee593c3" translate="yes" xml:space="preserve">
          <source>You can set the values of the &lt;code&gt;%SIG&lt;/code&gt; hash to be the functions you want to handle the signal. After perl catches the signal, it looks in &lt;code&gt;%SIG&lt;/code&gt; for a key with the same name as the signal, then calls the subroutine value for that key.</source>
          <target state="translated">신호를 처리하려는 함수 가 &lt;code&gt;%SIG&lt;/code&gt; 해시 값을 설정할 수 있습니다 . perl이 신호를 포착 한 후 신호 와 동일한 이름을 가진 키를 &lt;code&gt;%SIG&lt;/code&gt; 에서 찾은 다음 해당 키의 서브 루틴 값을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="bee1469992dc1b9c8f0b603349904e7ab865deb8" translate="yes" xml:space="preserve">
          <source>You can set the variable &lt;code&gt;$File::Find::dont_use_nlink&lt;/code&gt; to 1, if you want to force File::Find to always stat directories. This was used for file systems that do not have an &lt;code&gt;nlink&lt;/code&gt; count matching the number of sub-directories. Examples are ISO-9660 (CD-ROM), AFS, HPFS (OS/2 file system), FAT (DOS file system) and a couple of others.</source>
          <target state="translated">File :: Find를 항상 stat 디렉토리로 강제 설정하려면 &lt;code&gt;$File::Find::dont_use_nlink&lt;/code&gt; 변수를 1로 설정할 수 있습니다 . 서브 디렉토리 수와 일치 하는 &lt;code&gt;nlink&lt;/code&gt; 수 를 갖지 않는 파일 시스템에 사용되었습니다 . 예는 ISO-9660 (CD-ROM), AFS, HPFS (OS / 2 파일 시스템), FAT (DOS 파일 시스템) 및 기타 몇 가지입니다.</target>
        </trans-unit>
        <trans-unit id="5472b025e4a5169aacbf87f4ca700aef907769b9" translate="yes" xml:space="preserve">
          <source>You can set these attributes on the parser object before you call &lt;code&gt;parse_file&lt;/code&gt; (or a similar method) on it:</source>
          <target state="translated">&lt;code&gt;parse_file&lt;/code&gt; (또는 유사한 메소드)을 호출하기 전에 구문 분석기 오브젝트에서 이러한 속성을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d11091c76638b6f543204cac0351812864021173" translate="yes" xml:space="preserve">
          <source>You can set these with cereg.exe, a (remote) registry editor or via the PerlIDE.</source>
          <target state="translated">cereg.exe, (원격) 레지스트리 편집기 또는 PerlIDE를 통해이를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a45d7d92f838159f25ad37c4eba92cfbf985fe7f" translate="yes" xml:space="preserve">
          <source>You can set this in your &lt;code&gt;CPAN.pm&lt;/code&gt; configuration so modules automatically install in your private library directory when you use the CPAN.pm shell:</source>
          <target state="translated">&lt;code&gt;CPAN.pm&lt;/code&gt; 구성 에서 이를 설정하면 CPAN.pm 쉘을 사용할 때 개인 라이브러리 디렉토리에 모듈이 자동으로 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="30390221c1f07dd9de6ff3b92b3e83f72d1fc24c" translate="yes" xml:space="preserve">
          <source>You can sometimes</source>
          <target state="translated">때로는 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="7db7fa33c434550059625aa8e8d2392ae86f8c71" translate="yes" xml:space="preserve">
          <source>You can specify a character class, by enclosing a list of characters in &lt;code&gt;[]&lt;/code&gt; , which will match any character from the list. If the first character after the &quot;[&quot; is &quot;^&quot;, the class matches any character not in the list. Within a list, the &quot;-&quot; character specifies a range, so that &lt;code&gt;a-z&lt;/code&gt; represents all characters between &quot;a&quot; and &quot;z&quot;, inclusive. If you want either &quot;-&quot; or &quot;]&quot; itself to be a member of a class, put it at the start of the list (possibly after a &quot;^&quot;), or escape it with a backslash. &quot;-&quot; is also taken literally when it is at the end of the list, just before the closing &quot;]&quot;. (The following all specify the same class of three characters: &lt;code&gt;[-az]&lt;/code&gt; , &lt;code&gt;[az-]&lt;/code&gt; , and &lt;code&gt;[a\-z]&lt;/code&gt; . All are different from &lt;code&gt;[a-z]&lt;/code&gt; , which specifies a class containing twenty-six characters, even on EBCDIC-based character sets.) Also, if you try to use the character classes &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;\W&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt;, &lt;code&gt;\S&lt;/code&gt; , &lt;code&gt;\d&lt;/code&gt; , or &lt;code&gt;\D&lt;/code&gt; as endpoints of a range, the &quot;-&quot; is understood literally.</source>
          <target state="translated">문자 목록을 &lt;code&gt;[]&lt;/code&gt; 로 묶어 문자 클래스를 지정할 수 있으며,이 문자는 목록의 모든 문자와 일치합니다. &quot;[&quot;뒤의 첫 문자가 &quot;^&quot;이면 클래스는 목록에없는 문자와 일치합니다. 목록에서 &quot;-&quot;문자는 범위를 지정하므로 &lt;code&gt;a-z&lt;/code&gt; 는 &quot;a&quot;와 &quot;z&quot;사이의 모든 문자를 포함합니다. &quot;-&quot;또는 &quot;]&quot;자체가 클래스의 구성원이되도록하려면 목록의 시작 부분 ( &quot;^&quot;뒤에)에 넣거나 백 슬래시로 이스케이프 처리하십시오. &quot;-&quot;는 목록의 끝에있을 때 문자 그대로 &quot;&quot; &quot;닫기 직전에 나타납니다. (다음은 모두 &lt;code&gt;[-az]&lt;/code&gt; , &lt;code&gt;[az-]&lt;/code&gt; ,그리고 &lt;code&gt;[a\-z]&lt;/code&gt; . 모두 &lt;code&gt;[a-z]&lt;/code&gt; 와 다릅니다EBCDIC 기반 문자 세트에서도 26 개의 문자를 포함하는 클래스를 지정합니다.) 또한 문자 클래스 &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;\W&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt; , &lt;code&gt;\S&lt;/code&gt; , &lt;code&gt;\d&lt;/code&gt; 또는 &lt;code&gt;\D&lt;/code&gt; 를 엔드 포인트 로 사용하려고하면 &quot;-&quot;는 문자 그대로 이해됩니다.</target>
        </trans-unit>
        <trans-unit id="26fab1522afd0e2727fdb333919185675d766a45" translate="yes" xml:space="preserve">
          <source>You can specify a precision (for numeric conversions) or a maximum width (for string conversions) by specifying a &lt;code&gt;.&lt;/code&gt; followed by a number. For floating-point formats except &lt;code&gt;g&lt;/code&gt; and &lt;code&gt;G&lt;/code&gt; , this specifies how many places right of the decimal point to show (the default being 6). For example:</source>
          <target state="translated">을 지정하여 정밀도 (숫자 변환의 경우) 또는 최대 너비 (문자열 변환의 경우)를 지정할 수 &lt;code&gt;.&lt;/code&gt; 뒤에 숫자가옵니다. &lt;code&gt;g&lt;/code&gt; 및 &lt;code&gt;G&lt;/code&gt; 를 제외한 부동 소수점 형식 의 경우 소수점 오른쪽에 표시 할 위치 수를 지정합니다 (기본값은 6). 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d7117f36d5a9b63e0e2af83d4187313124e5bec9" translate="yes" xml:space="preserve">
          <source>You can specify a series of alternatives for a pattern using &quot;|&quot; to separate them, so that &lt;code&gt;fee|fie|foe&lt;/code&gt; will match any of &quot;fee&quot;, &quot;fie&quot;, or &quot;foe&quot; in the target string (as would &lt;code&gt;f(e|i|o)e&lt;/code&gt;). The first alternative includes everything from the last pattern delimiter (&quot;(&quot;, &quot;(?:&quot;, etc. or the beginning of the pattern) up to the first &quot;|&quot;, and the last alternative contains everything from the last &quot;|&quot; to the next closing pattern delimiter. That's why it's common practice to include alternatives in parentheses: to minimize confusion about where they start and end.</source>
          <target state="translated">&quot;|&quot;를 사용하여 패턴에 대한 일련의 대안을 지정할 수 있습니다 그 때문에, 그들을 분리하는 &lt;code&gt;fee|fie|foe&lt;/code&gt; &quot;수수료&quot;, &quot;헛소리&quot;, 또는 대상 문자열에 &quot;적&quot;과 일치합니다 (겠습니까의 같은 &lt;code&gt;f(e|i|o)e&lt;/code&gt; ). 첫 번째 대안은 마지막 패턴 구분 기호 ( &quot;(&quot;, &quot;(? :&quot;등 또는 패턴의 시작)부터 첫 번째 &quot;|&quot;까지)를 포함하고 마지막 대안은 마지막 &quot;|&quot; 다음 닫는 패턴 구분 기호에 괄호 안에 대안을 포함시키는 것이 일반적입니다. 시작 및 종료 위치에 대한 혼동을 최소화합니다.</target>
        </trans-unit>
        <trans-unit id="2c0acf2a3cfcada005163c068fb15aa1f1ca963b" translate="yes" xml:space="preserve">
          <source>You can specify several classes to try by joining them with commas or semicolons, as in &lt;code&gt;-MTk::SuperPod;Tk::Pod&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;-MTk::SuperPod;Tk::Pod&lt;/code&gt; 와 같이 쉼표 또는 세미콜론으로 조인하여 여러 클래스를 지정하여 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1590cfec6710042ae4b201c340cadca79997b8f8" translate="yes" xml:space="preserve">
          <source>You can stop using AutoLoader by simply</source>
          <target state="translated">간단하게 AutoLoader 사용을 중지 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="1eb2363990bc861a2294e72254c60f889449d2d6" translate="yes" xml:space="preserve">
          <source>You can switch encodings on an already opened stream by using &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt;; see &lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; 를 사용하여 이미 열린 스트림에서 인코딩을 전환 할 수 있습니다 . &lt;a href=&quot;functions/binmode&quot;&gt;binmode를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ad4a77a592ef4f50bebb75551ecc777ec47349e4" translate="yes" xml:space="preserve">
          <source>You can switch locales as often as you wish at run time with the &lt;code&gt;POSIX::setlocale()&lt;/code&gt; function:</source>
          <target state="translated">&lt;code&gt;POSIX::setlocale()&lt;/code&gt; 함수를 사용하여 런타임에 원하는만큼 로케일을 전환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d35fb0ec3f2c6e87bec34d10cff3e1fa0aa39f99" translate="yes" xml:space="preserve">
          <source>You can test for these with Perl's &lt;b&gt;-S&lt;/b&gt; file test:</source>
          <target state="translated">Perl의 &lt;b&gt;-S&lt;/b&gt; 파일 테스트 를 통해이를 테스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="33cabbc3e6b78a04641195c801755295c5b1770a" translate="yes" xml:space="preserve">
          <source>You can test out changing these variables temporarily, and if the new settings seem to help, put those settings into your shell startup files. Consult your local documentation for the exact details. For Bourne-like shells (&lt;b&gt;sh&lt;/b&gt;, &lt;b&gt;ksh&lt;/b&gt;, &lt;b&gt;bash&lt;/b&gt;, &lt;b&gt;zsh&lt;/b&gt;):</source>
          <target state="translated">이러한 변수의 변경을 일시적으로 테스트 할 수 있으며 새로운 설정이 도움이되는 경우 해당 설정을 쉘 시작 파일에 넣으십시오. 자세한 내용은 지역 설명서를 참조하십시오. Bourne과 같은 쉘 ( &lt;b&gt;sh&lt;/b&gt; , &lt;b&gt;ksh&lt;/b&gt; , &lt;b&gt;bash&lt;/b&gt; , &lt;b&gt;zsh&lt;/b&gt; )의 경우 :</target>
        </trans-unit>
        <trans-unit id="9aef87ade0298c8e39a512c631e34755f8d99a1d" translate="yes" xml:space="preserve">
          <source>You can test whether an SV is using copy-on-write with &lt;code&gt;SvIsCOW(sv)&lt;/code&gt; .</source>
          <target state="translated">SV가 &lt;code&gt;SvIsCOW(sv)&lt;/code&gt; 와 함께 COW ( Copy-On-Write)를 사용 중인지 테스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bb7b765496cd5db87bb4e9bf905826761c1ac026" translate="yes" xml:space="preserve">
          <source>You can therefore save time by reusing this object as follows;</source>
          <target state="translated">따라서이 객체를 다음과 같이 재사용하여 시간을 절약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9025bea13f42c28d6d27d405ef555cfdfb67e0c5" translate="yes" xml:space="preserve">
          <source>You can think of &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; as a &lt;code&gt;typeof&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;typeof&lt;/code&gt; 연산자 로 생각할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cf104869dd9c15f6376b764dcf7d585d45ca8039" translate="yes" xml:space="preserve">
          <source>You can think of &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; as a &lt;code&gt;typeof&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;typeof&lt;/code&gt; 연산자 로 생각할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="728882433c08d9f5799a415b920db42fb16d9b1c" translate="yes" xml:space="preserve">
          <source>You can think of a module as the fundamental unit of reusable Perl code; see &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; for details. Whenever anyone creates a chunk of Perl code that they think will be useful to the world, they register as a Perl developer at &lt;a href=&quot;http://www.cpan.org/modules/04pause.html&quot;&gt;http://www.cpan.org/modules/04pause.html&lt;/a&gt; so that they can then upload their code to the CPAN. The CPAN is the Comprehensive Perl Archive Network and can be accessed at &lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt; , and searched at &lt;a href=&quot;http://search.cpan.org/&quot;&gt;http://search.cpan.org/&lt;/a&gt; .</source>
          <target state="translated">모듈을 재사용 가능한 Perl 코드의 기본 단위로 생각할 수 있습니다. 자세한 내용은 &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; 를 참조하십시오. 누구나 세상에 유용하다고 생각되는 Perl 코드 덩어리를 만들 때마다 &lt;a href=&quot;http://www.cpan.org/modules/04pause.html&quot;&gt;http://www.cpan.org/modules/04pause.html&lt;/a&gt; 에서 Perl 개발자로 등록 하여 코드를 CPAN. CPAN은 포괄적 인 Perl 아카이브 네트워크이며 &lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt; 에서 액세스 하고 &lt;a href=&quot;http://search.cpan.org/&quot;&gt;http://search.cpan.org/&lt;/a&gt; 에서 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="969f96d8ec4df0c71d177e6b1625408e665ae979" translate="yes" xml:space="preserve">
          <source>You can tie the cache tables to any sort of tied hash that you want to, as long as it supports &lt;code&gt;TIEHASH&lt;/code&gt; , &lt;code&gt;FETCH&lt;/code&gt; , &lt;code&gt;STORE&lt;/code&gt; , and &lt;code&gt;EXISTS&lt;/code&gt; . For example,</source>
          <target state="translated">캐시 테이블이 &lt;code&gt;TIEHASH&lt;/code&gt; , &lt;code&gt;FETCH&lt;/code&gt; , &lt;code&gt;STORE&lt;/code&gt; 및 &lt;code&gt;EXISTS&lt;/code&gt; 를 지원하는 한 원하는 모든 종류의 묶인 해시에 연결할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="5dff5882ff33a85a3a95fb0e709084606bfc8485" translate="yes" xml:space="preserve">
          <source>You can try using encryption via source filters (Filter::* from CPAN, or Filter::Util::Call and Filter::Simple since Perl 5.8). But crackers might be able to decrypt it. You can try using the byte code compiler and interpreter described below, but crackers might be able to de-compile it. You can try using the native-code compiler described below, but crackers might be able to disassemble it. These pose varying degrees of difficulty to people wanting to get at your code, but none can definitively conceal it (this is true of every language, not just Perl).</source>
          <target state="translated">소스 필터 (CPAN의 Filter :: * 또는 Perl 5.8 이후 Filter :: Util :: Call 및 Filter :: Simple)를 통해 암호화를 사용해 볼 수 있습니다. 그러나 크래커가 해독 할 수 있습니다. 아래에 설명 된 바이트 코드 컴파일러와 인터프리터를 사용해 볼 수 있지만 크래커가 디 컴파일 할 수 있습니다. 아래에 설명 된 네이티브 코드 컴파일러를 사용해 볼 수 있지만 크래커가이를 분해 할 수 있습니다. 이것들은 코드를 얻고 자하는 사람들에게 다양한 정도의 어려움을 초래하지만, 아무도 그것을 숨길 수는 없습니다 (Perl뿐만 아니라 모든 언어에 해당됩니다).</target>
        </trans-unit>
        <trans-unit id="bd149095683892a2c8050e33a089a96e4ba58ba3" translate="yes" xml:space="preserve">
          <source>You can try using encryption via source filters (Starting from Perl 5.8 the Filter::Simple and Filter::Util::Call modules are included in the standard distribution), but any decent programmer will be able to decrypt it. You can try using the byte code compiler and interpreter described later in &lt;a href=&quot;perlfaq3&quot;&gt;perlfaq3&lt;/a&gt;, but the curious might still be able to de-compile it. You can try using the native-code compiler described later, but crackers might be able to disassemble it. These pose varying degrees of difficulty to people wanting to get at your code, but none can definitively conceal it (true of every language, not just Perl).</source>
          <target state="translated">소스 필터 (Perl 5.8부터 Filter :: Simple 및 Filter :: Util :: Call 모듈이 표준 배포에 포함됨)를 통해 암호화를 사용해 볼 수 있지만 괜찮은 프로그래머는이를 해독 할 수 있습니다. &lt;a href=&quot;perlfaq3&quot;&gt;perlfaq3&lt;/a&gt; 에서 나중에 설명하는 바이트 코드 컴파일러 및 인터프리터를 사용해 볼 수 있지만 궁금한 점이 여전히 디 컴파일 할 수 있습니다. 나중에 설명 할 네이티브 코드 컴파일러를 사용해 볼 수 있지만 크래커가이를 분해 할 수 있습니다. 이 코드는 코드를 얻고 자하는 사람들에게는 다양한 난이도를 제공하지만,이를 완전히 숨길 수는 없습니다 (Perl뿐만 아니라 모든 언어에 해당).</target>
        </trans-unit>
        <trans-unit id="2b09b812e89e288611a3620bc913b5b1b0fe4650" translate="yes" xml:space="preserve">
          <source>You can turn off that eagerness-to-help by declaring an attribute handler with the keyword &lt;code&gt;RAWDATA&lt;/code&gt; . For example:</source>
          <target state="translated">키워드 &lt;code&gt;RAWDATA&lt;/code&gt; 로 속성 핸들러를 선언하여 도움이되는 열망을 끌 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b5701868a13c5d43cf7a782ca599e3f4284f18bb" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;#(%3f%23text)&quot;&gt;(?#text)&lt;/a&gt; to create a comment that ends earlier than the end of the current line, but &lt;code&gt;text&lt;/code&gt; also can't contain the closing delimiter unless escaped with a backslash.</source>
          <target state="translated">당신은 사용할 수 있습니다 &lt;a href=&quot;#(%3f%23text)&quot;&gt;(?하는 #text)를&lt;/a&gt; 끝 이전 현재 행의 끝보다하지만 코멘트를 작성하는 &lt;code&gt;text&lt;/code&gt; 백 슬래시로 이스케이프가 아니면 닫는 구분 기호를 포함 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6d944fb3215d0dd16d4105b924d26c8f26a00944" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;#prop_values()&quot;&gt;prop_values()&lt;/a&gt; to find out if a given property is one which has a restricted set of values, and if so, what those values are. But usually each value actually has several synonyms. For example, in Unicode binary properties,</source>
          <target state="translated">&lt;a href=&quot;#prop_values()&quot;&gt;prop_values ​​()&lt;/a&gt; 를 사용 하여 주어진 속성이 제한된 값 집합을 가진 속성인지 확인하고, 그렇다면 해당 값이 무엇인지 확인할 수 있습니다. 그러나 일반적으로 각 값에는 실제로 여러 동의어가 있습니다. 예를 들어 유니 코드 이진 속성에서</target>
        </trans-unit>
        <trans-unit id="b53d0563bc5da053955b9d3b7d437fbd188f8795" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;http://search.cpan.org/perldoc/Number::Format&quot;&gt;Number::Format&lt;/a&gt; to separate places in a number. It handles locale information for those of you who want to insert full stops instead (or anything else that they want to use, really).</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Number::Format&quot;&gt;Number :: Format&lt;/a&gt; 을 사용 하여 숫자로 장소를 구분할 수 있습니다. 대신 전체 중지를 삽입하려는 사용자 (또는 실제로 사용하려는 다른 것)의 로캘 정보를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="49f5dd665c5e9d2b71ecb4caa05c28940c8fc3d9" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;http://search.cpan.org/perldoc/URI::Find&quot;&gt;URI::Find&lt;/a&gt; to extract URLs from an arbitrary text document.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/URI::Find&quot;&gt;URI :: Find&lt;/a&gt; 를 사용하여 임의의 텍스트 문서에서 URL을 추출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7fe2956ea1b7c9e1e517ba013b7204dc28c702c8" translate="yes" xml:space="preserve">
          <source>You can use &lt;b&gt;-C0&lt;/b&gt; (or &lt;code&gt;&quot;0&quot;&lt;/code&gt; for &lt;code&gt;PERL_UNICODE&lt;/code&gt; ) to explicitly disable all the above Unicode features.</source>
          <target state="translated">당신이 사용할 수있는 &lt;b&gt;-C0&lt;/b&gt; (또는 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 에 대한 &lt;code&gt;PERL_UNICODE&lt;/code&gt; 명시 적으로 사용하지 않도록 설정하는) 모든 유니 위의 특징.</target>
        </trans-unit>
        <trans-unit id="8820cb36e9b0a2ef9812096c3ae47e4337e70f22" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;-w optionname&lt;/code&gt; (without a value) as shorthand for &lt;code&gt;-w optionname:&lt;i&gt;TRUE&lt;/i&gt;&lt;/code&gt;. This is presumably useful in cases of on/off features like: &lt;code&gt;-w page_numbering&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;-w optionname:&lt;i&gt;TRUE&lt;/i&gt;&lt;/code&gt; &lt;i&gt;TRUE의&lt;/i&gt; 약어로 &lt;code&gt;-w optionname&lt;/code&gt; (값없이)을 사용할 수 있습니다 . 이것은 &lt;code&gt;-w page_numbering&lt;/code&gt; 과 같은 on / off 기능의 경우에 유용합니다 .&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="b34722383d4a6c958172dfe61f02074274ede7a9" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; without parentheses to locate the end of each input file, in case you want to append to each file, or reset line numbering (see example in &lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;).</source>
          <target state="translated">당신은 사용할 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 경우에 각 파일 또는 리셋 라인 번호 (예 참조에 추가하려는 각 입력 파일의 끝을 괄호없이 &lt;a href=&quot;functions/eof&quot;&gt;EOF를&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="7509178f0cc142ffa6970d993aa78a311665535a" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; if the columns are separated by whitespace or some other delimiter, as long as whitespace or the delimiter cannot appear as part of the data.</source>
          <target state="translated">공백 또는 구분 기호가 데이터의 일부로 표시 될 수없는 경우 열이 공백 또는 다른 구분 기호로 분리 된 경우 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="207bd81996c41f563d70786505a61f566bf7c9d1" translate="yes" xml:space="preserve">
          <source>You can use Andreas Koenig's CPAN module ( &lt;a href=&quot;http://www.cpan.org/modules/by-module/CPAN&quot;&gt;http://www.cpan.org/modules/by-module/CPAN&lt;/a&gt; ) to automate the following steps, from DECOMPRESS through INSTALL.</source>
          <target state="translated">Andreas Koenig의 CPAN 모듈 ( &lt;a href=&quot;http://www.cpan.org/modules/by-module/CPAN&quot;&gt;http://www.cpan.org/modules/by-module/CPAN&lt;/a&gt; )을 사용하여 DECOMPRESS에서 INSTALL에 이르기까지 다음 단계를 자동화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1a4fa2e9a279c718478efb15dbd58f3963c395b2" translate="yes" xml:space="preserve">
          <source>You can use Perl's somewhat exotic &lt;code&gt;..&lt;/code&gt; operator (documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;):</source>
          <target state="translated">Perl의 다소 이국적인 &lt;code&gt;..&lt;/code&gt; 연산자를 사용할 수 있습니다 ( &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 문서로 작성 ).</target>
        </trans-unit>
        <trans-unit id="0352c7c82515615be31fde318d8a078c0a2c1a97" translate="yes" xml:space="preserve">
          <source>You can use a leading underscore to indicate that a variable or function should not be used outside the package that defined it.</source>
          <target state="translated">선행 밑줄을 사용하여 변수 또는 함수를 정의한 패키지 외부에서 사용해서는 안됨을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="388231cbd33477282c1e5dc7ff7aa725ad26b114" translate="yes" xml:space="preserve">
          <source>You can use a string as if it were a reference. If you use the string &lt;code&gt;&quot;foo&quot;&lt;/code&gt; as an array reference, it's taken to be a reference to the array &lt;code&gt;@foo&lt;/code&gt; . This is called a</source>
          <target state="translated">문자열을 참조 인 것처럼 사용할 수 있습니다. 문자열 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 를 배열 참조로 사용하면 배열 &lt;code&gt;@foo&lt;/code&gt; 에 대한 참조로 간주됩니다 . 이것은</target>
        </trans-unit>
        <trans-unit id="adc3bc3485dafe6de0835e8cb890731728d4f233" translate="yes" xml:space="preserve">
          <source>You can use an &quot;=&quot; instead of the &quot;:&quot;, as in: &lt;code&gt;-w textsize=15&lt;/code&gt; . This might be more (or less) convenient, depending on what shell you use.</source>
          <target state="translated">&lt;code&gt;-w textsize=15&lt;/code&gt; 와 같이 &quot;:&quot;대신 &quot;=&quot;를 사용할 수 있습니다 . 어떤 쉘을 사용 하느냐에 따라 더 편리 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="659b448e1309e418ec405468f01e562189ac5581" translate="yes" xml:space="preserve">
          <source>You can use an alternative library to drive Math::BigInt. See the section &lt;a href=&quot;#MATH-LIBRARY&quot;&gt;MATH LIBRARY&lt;/a&gt; for more information.</source>
          <target state="translated">대체 라이브러리를 사용하여 Math :: BigInt를 구동 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;#MATH-LIBRARY&quot;&gt;MATH LIBRARY&lt;/a&gt; 섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f7c7a81f2a96d58e5477ffb42832551e4a65a1ae" translate="yes" xml:space="preserve">
          <source>You can use and redistribute this document under the same terms as Perl itself.</source>
          <target state="translated">Perl 자체와 동일한 용어로이 문서를 사용하고 재배포 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02346143e059d2c6966f5b1da988acae6f664ce7" translate="yes" xml:space="preserve">
          <source>You can use another collation element table if desired.</source>
          <target state="translated">원하는 경우 다른 데이터 정렬 요소 테이블을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80ffd7e86ab2f265c3b1b5af5301c88022dfacbd" translate="yes" xml:space="preserve">
          <source>You can use any combination of the methods from none to all four.</source>
          <target state="translated">none에서 four까지 방법의 조합을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="727cc3b9105721ca57e170521deb86b9cfbaaa16" translate="yes" xml:space="preserve">
          <source>You can use any combination of the methods, from none, to all four.</source>
          <target state="translated">없음에서 네 가지 방법 모두를 조합하여 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cf084acc213926a976c0b6e7b2d7ff58c8a1c98" translate="yes" xml:space="preserve">
          <source>You can use formatting codes in ordinary paragraphs, for &lt;b&gt;bold&lt;/b&gt;,</source>
          <target state="translated">&lt;b&gt;굵은 글씨&lt;/b&gt; 로 일반 단락에 서식 코드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b0f4d35c03dc40ee00f05e56f139894c4c251ca" translate="yes" xml:space="preserve">
          <source>You can use it as follows:</source>
          <target state="translated">다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfbc7862683635b53050e53b7defa0eddc13b749" translate="yes" xml:space="preserve">
          <source>You can use more than one source filter on a single file. Similarly, you can reuse the same filter in as many files as you like.</source>
          <target state="translated">단일 파일에서 둘 이상의 소스 필터를 사용할 수 있습니다. 마찬가지로, 원하는만큼 많은 파일에서 동일한 필터를 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb2c65d2dbc0740833a918a76d1bf6977975706a" translate="yes" xml:space="preserve">
          <source>You can use parentheses for functions' arguments or omit them according to your personal taste. They are only required occasionally to clarify issues of precedence.</source>
          <target state="translated">함수의 인수에 괄호를 사용하거나 개인 취향에 따라 생략 할 수 있습니다. 우선 순위 문제를 명확히하기 위해 가끔 필요합니다.</target>
        </trans-unit>
        <trans-unit id="78045ec633e87e0c82678bcb8abea9b50b38e139" translate="yes" xml:space="preserve">
          <source>You can use that same structure to count the entries any way that you like. If you want the count of the keys with vowels in them, you just test for that instead:</source>
          <target state="translated">동일한 구조를 사용하여 원하는 방식으로 항목을 계산할 수 있습니다. 모음이있는 키의 수를 원한다면 대신 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="264d904732b18badb8f8af0ee614fe938cb62fd3" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;http://search.cpan.org/perldoc/File::Random&quot;&gt;File::Random&lt;/a&gt; module which provides a function for that algorithm:</source>
          <target state="translated">해당 알고리즘에 대한 기능을 제공하는 &lt;a href=&quot;http://search.cpan.org/perldoc/File::Random&quot;&gt;File :: Random&lt;/a&gt; 모듈을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="12dc43addaceb3325735b42235a5db7b043fe8e8" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ANSIScreen&quot;&gt;Term::ANSIScreen&lt;/a&gt; module to get the special sequence. Import the &lt;code&gt;cls&lt;/code&gt; function (or the &lt;code&gt;:screen&lt;/code&gt; tag):</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Term::ANSIScreen&quot;&gt;Term :: ANSIScreen&lt;/a&gt; 모듈을 사용하여 특수 시퀀스를 얻을 수 있습니다 . &lt;code&gt;cls&lt;/code&gt; 함수 (또는 &lt;code&gt;:screen&lt;/code&gt; 태그)를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="5e45dc25f4fd438a13c8ce07a9424e43bd367039" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;http://search.cpan.org/perldoc/Time::JulianDay&quot;&gt;Time::JulianDay&lt;/a&gt; module available on CPAN. Ensure that you really want to find a Julian day, though, as many people have different ideas about Julian days (see &lt;a href=&quot;http://www.hermetic.ch/cal_stud/jdn.htm&quot;&gt;http://www.hermetic.ch/cal_stud/jdn.htm&lt;/a&gt; for instance):</source>
          <target state="translated">당신은 사용 &lt;a href=&quot;http://search.cpan.org/perldoc/Time::JulianDay&quot;&gt;시간 : JULIANDAY의&lt;/a&gt; CPAN에서 사용 가능한 모듈을. 많은 사람들이 율리우스 일에 대해 다른 생각을 가지고 있기 때문에 율리우스 일을 정말로 찾고 싶어 야합니다 ( 예 : &lt;a href=&quot;http://www.hermetic.ch/cal_stud/jdn.htm&quot;&gt;http://www.hermetic.ch/cal_stud/jdn.htm&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="ba1788ef1bedfa0514aebf9080742800f7823493" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;time/piece&quot;&gt;Time::Piece&lt;/a&gt; module, part of the Standard Library, which can convert a date/time to a Julian Day:</source>
          <target state="translated">표준 라이브러리의 일부인 &lt;a href=&quot;time/piece&quot;&gt;Time :: Piece&lt;/a&gt; 모듈을 사용하면 날짜 / 시간을 율리우스 일로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19bff3f43fe0160ae5712a54b49b7225e08cf437" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; variable to detect if you are currently in the global destruction phase:</source>
          <target state="translated">당신이 사용할 수있는 &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; 전역 파괴 단계에 현재있는 경우 감지 할 변수를 :</target>
        </trans-unit>
        <trans-unit id="c3b01f73c25a67d7de0988508e3d6a08d549191f" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; keyword to fall through from one case to the next:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 키워드를 사용하여 한 사례에서 다음 사례로 넘어갈 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0512ec103381f142d5cd53ad55c41fe8a57f36b8" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $array[$idx]&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $hash{key}&lt;/code&gt; constructs to delete a composite type entry for the current block and restore it when it ends. They return the array/hash value before the localization, which means that they are respectively equivalent to</source>
          <target state="translated">사용자는 사용 &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $array[$idx]&lt;/code&gt; 그리고 &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $hash{key}&lt;/code&gt; 구조를 상기 현재 블록에 대한 복합 타입 항목을 삭제하고 끝나면 복원. 현지화 전에 배열 / 해시 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e75c67446fa3d94c780e921da6acd4affb168a6f" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys()&lt;/a&gt;&lt;/code&gt; built-in function in scalar context to find out have many entries you have in a hash:</source>
          <target state="translated">당신이 사용할 수있는 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys()&lt;/a&gt;&lt;/code&gt; 이 해시에있는 많은 항목이 찾아 내장 기능 스칼라 문맥을 :</target>
        </trans-unit>
        <trans-unit id="32a43fdc7d4ed02e813e0075b65927b5536f01d4" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; functions to reset &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt;. To simply reset the iterator used by &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; without doing anything else, use one of them in void context:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 기능을 사용하여 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 을 재설정 할 수 있습니다 . 다른 작업을 수행하지 않고 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 의해 사용되는 반복자를 간단히 재설정하려면 void 컨텍스트에서 이들 중 하나를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="91d95a3ba11b677c44eabfc4c39139686174c03a" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;END&lt;/code&gt; block to simulate &lt;code&gt;atexit()&lt;/code&gt; . Each package's &lt;code&gt;END&lt;/code&gt; block is called when the program or thread ends. See the &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; manpage for more details about &lt;code&gt;END&lt;/code&gt; blocks.</source>
          <target state="translated">&lt;code&gt;END&lt;/code&gt; 블록을 사용하여 &lt;code&gt;atexit()&lt;/code&gt; 를 시뮬레이션 할 수 있습니다 . 각 패키지의 &lt;code&gt;END&lt;/code&gt; 블록은 프로그램 또는 스레드가 종료 될 때 호출됩니다. 참고 항목 &lt;a href=&quot;perlmod&quot;&gt;perlmod를&lt;/a&gt; 대한 자세한 내용은 맨 &lt;code&gt;END&lt;/code&gt; 블록을.</target>
        </trans-unit>
        <trans-unit id="23320d34367d7c8e19c4f3b2648a39107aaceafc" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;Text::Soundex&lt;/code&gt; module. If you want to do fuzzy or close matching, you might also try the &lt;a href=&quot;http://search.cpan.org/perldoc/String::Approx&quot;&gt;String::Approx&lt;/a&gt;, and &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Metaphone&quot;&gt;Text::Metaphone&lt;/a&gt;, and &lt;a href=&quot;http://search.cpan.org/perldoc/Text::DoubleMetaphone&quot;&gt;Text::DoubleMetaphone&lt;/a&gt; modules.</source>
          <target state="translated">&lt;code&gt;Text::Soundex&lt;/code&gt; 모듈을 사용할 수 있습니다 . 퍼지 또는 근접 일치를 수행하려면 &lt;a href=&quot;http://search.cpan.org/perldoc/String::Approx&quot;&gt;String :: Approx&lt;/a&gt; 및 &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Metaphone&quot;&gt;Text :: Metaphone&lt;/a&gt; 및 &lt;a href=&quot;http://search.cpan.org/perldoc/Text::DoubleMetaphone&quot;&gt;Text :: DoubleMetaphone&lt;/a&gt; 모듈을 사용해보십시오 .</target>
        </trans-unit>
        <trans-unit id="488d88c32abab4c7103bc8a9f7d995aca32467c4" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;UNIVERSAL&lt;/code&gt; class (see &lt;a href=&quot;universal&quot;&gt;UNIVERSAL&lt;/a&gt;). However, please be very careful to consider the consequences of doing this: adding methods to every object is very likely to have unintended consequences. If possible, it would be better to have all your object inherit from some common base class, or to use an object system like Moose that supports roles.</source>
          <target state="translated">&lt;code&gt;UNIVERSAL&lt;/code&gt; 클래스를 사용할 수 있습니다 ( &lt;a href=&quot;universal&quot;&gt;UNIVERSAL&lt;/a&gt; 참조 ). 그러나이 작업의 결과를 고려해야합니다. 모든 개체에 메서드를 추가하면 의도하지 않은 결과가 발생할 수 있습니다. 가능하면 모든 객체를 공통 기본 클래스에서 상속하거나 역할을 지원하는 Moose와 같은 객체 시스템을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9e82c1f5d6a6827f8e16779cc47df9c04d7d8adc" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;\[]&lt;/code&gt; backslash group notation to specify more than one allowed argument type. For example:</source>
          <target state="translated">당신은 사용할 수 있습니다 &lt;code&gt;\[]&lt;/code&gt; 하나 개 이상의 허용 인수 유형을 지정 백 슬래시 그룹 표기법을. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="29a5b3337e458ba95bc1ff4b8a89d182c9528c72" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;break&lt;/code&gt; keyword to break out of the enclosing &lt;code&gt;given&lt;/code&gt; block. Every &lt;code&gt;when&lt;/code&gt; block is implicitly ended with a &lt;code&gt;break&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; 키워드를 사용하여 &lt;code&gt;given&lt;/code&gt; 블록 에서 벗어날 수 있습니다 . 모든 &lt;code&gt;when&lt;/code&gt; 블록은 암시 적으로 종료 &lt;code&gt;break&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4e6268ce8a22314d30cc236ac406a7320d8f9ec" translate="yes" xml:space="preserve">
          <source>You can use the Configure script in non-interactive mode too. When I built my</source>
          <target state="translated">비 대화식 모드에서도 Configure 스크립트를 사용할 수 있습니다. 내가 만들 때</target>
        </trans-unit>
        <trans-unit id="a88ac92f15e86bfef2bc330f6e37cbdfaa5d2949" translate="yes" xml:space="preserve">
          <source>You can use the POSIX character class syntax &lt;code&gt;/[[:alpha:]]/&lt;/code&gt; documented in &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;perlre&quot;&gt;perlre에&lt;/a&gt; 문서화 된 POSIX 문자 클래스 구문 &lt;code&gt;/[[:alpha:]]/&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e278d58c9ab507fbb7f9453e431896c65ad5fd6f" translate="yes" xml:space="preserve">
          <source>You can use the SDK by exporting some additions to Perl's 'ccflags' and '..flags' config variables:</source>
          <target state="translated">Perl의 'ccflags'및 '..flags'구성 변수에 추가 사항을 내보내 SDK를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcba1d434e18427e8484e54d9e14e5566e79c6d1" translate="yes" xml:space="preserve">
          <source>You can use the builtin &lt;code&gt;&lt;a href=&quot;functions/getc&quot;&gt;getc()&lt;/a&gt;&lt;/code&gt; function for most filehandles, but it won't (easily) work on a terminal device. For STDIN, either use the Term::ReadKey module from CPAN or use the sample code in &lt;a href=&quot;functions/getc&quot;&gt;getc&lt;/a&gt;.</source>
          <target state="translated">대부분의 파일 핸들에 내장 &lt;code&gt;&lt;a href=&quot;functions/getc&quot;&gt;getc()&lt;/a&gt;&lt;/code&gt; 함수를 사용할 수 있지만 터미널 장치에서는 (쉽게) 작동하지 않습니다. STDIN의 경우 CPAN의 Term :: ReadKey 모듈을 사용하거나 &lt;a href=&quot;functions/getc&quot;&gt;getc&lt;/a&gt; 의 샘플 코드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ad23301638fa59a074f7b5a830adc451b7882aec" translate="yes" xml:space="preserve">
          <source>You can use the debugger's &lt;code&gt;x&lt;/code&gt; command to dump out complex data structures. For example, given the assignment to $AoA above, here's the debugger output:</source>
          <target state="translated">디버거의 &lt;code&gt;x&lt;/code&gt; 명령을 사용하여 복잡한 데이터 구조를 덤프 할 수 있습니다 . 예를 들어, 위의 $ AoA에 할당 된 경우 디버거 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c95e7176a4cdb8eb19d859ce523240b91e0d516f" translate="yes" xml:space="preserve">
          <source>You can use the following types of values for allow:</source>
          <target state="translated">허용에 다음 유형의 값을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ce0a691bebd0b371247224bb7f78a55fdff48f0" translate="yes" xml:space="preserve">
          <source>You can use the four-argument form of sysread to continually add to a buffer. After you add to the buffer, you check if you have a complete line (using your regular expression).</source>
          <target state="translated">4 개의 인수 형식의 sysread를 사용하여 지속적으로 버퍼에 추가 할 수 있습니다. 버퍼에 추가 한 후 정규식을 사용하여 완전한 행이 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="da343e9c661b7d9b54a6aef1473ed8a755544823" translate="yes" xml:space="preserve">
          <source>You can use the shareware Winzip ( &lt;a href=&quot;http://www.winzip.com&quot;&gt;http://www.winzip.com&lt;/a&gt; ) to decompress and unpack modules.</source>
          <target state="translated">쉐어웨어 Winzip ( &lt;a href=&quot;http://www.winzip.com&quot;&gt;http://www.winzip.com&lt;/a&gt; )을 사용하여 모듈의 압축을 풀고 압축을 풀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29131242da6a21b6f2efd67a20aaa973ec754794" translate="yes" xml:space="preserve">
          <source>You can use the substitution operator to find pairs of characters (or runs of characters) and replace them with a single instance. In this substitution, we find a character in &lt;code&gt;(.)&lt;/code&gt;. The memory parentheses store the matched character in the back-reference &lt;code&gt;\g1&lt;/code&gt; and we use that to require that the same thing immediately follow it. We replace that part of the string with the character in &lt;code&gt;$1&lt;/code&gt; .</source>
          <target state="translated">대체 연산자를 사용하여 문자 쌍 (또는 문자 수)을 찾아 단일 인스턴스로 바꿀 수 있습니다. 이 대체에서 &lt;code&gt;(.)&lt;/code&gt; 에서 문자를 찾습니다 . 메모리 괄호는 일치하는 문자를 역 참조 &lt;code&gt;\g1&lt;/code&gt; 하고이를 사용하여 동일한 문자를 즉시 따라야합니다. 문자열의 해당 부분을 &lt;code&gt;$1&lt;/code&gt; 의 문자로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="b56ec6ea26f22e6bec1d13c6dc597e46c1853d2d" translate="yes" xml:space="preserve">
          <source>You can use the substr() function as an lvalue, in which case EXPR must itself be an lvalue. If you assign something shorter than LENGTH, the string will shrink, and if you assign something longer than LENGTH, the string will grow to accommodate it. To keep the string the same length, you may need to pad or chop your value using &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">substr () 함수를 lvalue로 사용할 수 있습니다.이 경우 EXPR 자체는 lvalue 여야합니다. LENGTH보다 짧은 것을 할당하면 문자열이 줄어들고 LENGTH보다 긴 것을 할당하면 문자열이 그것을 수용하도록 커집니다. 문자열의 길이를 동일하게 유지하려면 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 를 사용하여 값을 채우 거나 잘라 내야 합니다.</target>
        </trans-unit>
        <trans-unit id="5696279d1bd6b651a532c13cf176bc61670cde27" translate="yes" xml:space="preserve">
          <source>You can use the substr() function as an lvalue, in which case EXPR must itself be an lvalue. If you assign something shorter than LENGTH, the string will shrink, and if you assign something longer than LENGTH, the string will grow to accommodate it. To keep the string the same length, you may need to pad or chop your value using &lt;code&gt;&lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">substr () 함수를 lvalue로 사용할 수 있습니다.이 경우 EXPR 자체는 lvalue 여야합니다. LENGTH보다 짧은 것을 할당하면 문자열이 줄어들고 LENGTH보다 긴 것을 할당하면 문자열이 그것을 수용하도록 커집니다. 문자열의 길이를 동일하게 유지하려면 &lt;code&gt;&lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 를 사용하여 값을 채우 거나 잘라 내야 합니다.</target>
        </trans-unit>
        <trans-unit id="cfeed36c7e84bfafbf0ea57f25867379b77f770c" translate="yes" xml:space="preserve">
          <source>You can use the tainted() function of the Scalar::Util module, available from CPAN (or included with Perl since release 5.8.0). See also &lt;a href=&quot;perlsec#Laundering-and-Detecting-Tainted-Data&quot;&gt;Laundering and Detecting Tainted Data in perlsec&lt;/a&gt;.</source>
          <target state="translated">CPAN에서 사용 가능하거나 릴리스 5.8.0부터 Perl에 포함 된 Scalar :: Util 모듈의 tainted () 함수를 사용할 수 있습니다. &lt;a href=&quot;perlsec#Laundering-and-Detecting-Tainted-Data&quot;&gt;perlsec에서 오염 된 데이터 세탁 및 감지를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="09d2af0acba58841da7d114d861e093a90573f8a" translate="yes" xml:space="preserve">
          <source>You can use these macros if you call code that may croak, but you need to do some cleanup before giving control back to Perl. For example:</source>
          <target state="translated">삐걱 거리는 코드를 호출하는 경우 이러한 매크로를 사용할 수 있지만 Perl에 제어권을 부여하기 전에 정리를 수행해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8d60246dfc629fa2c767c2383b114af7d8fad4bc" translate="yes" xml:space="preserve">
          <source>You can use this as a shortcut to determine whether &lt;code&gt;Archive::Tar&lt;/code&gt; will do what you think before passing compressed archives to its &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; method.</source>
          <target state="translated">압축 된 아카이브를 &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 메소드 로 전달하기 전에 &lt;code&gt;Archive::Tar&lt;/code&gt; 가 사용자의 생각을 수행 할 것인지 여부를 판별하는 바로 가기로이를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a2583bc76f12f41a833e44f457c707f446ecc90f" translate="yes" xml:space="preserve">
          <source>You can use this class as the base class for a Pod formatter/processor.</source>
          <target state="translated">이 클래스를 포드 포맷터 / 프로세서의 기본 클래스로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddc269b809151a32259fd4bfb2f0eaf592a60142" translate="yes" xml:space="preserve">
          <source>You can use this subroutine to get and set the traversal mask for a specific hash. Setting the mask ensures that a given hash will produce the same key order. &lt;b&gt;Note&lt;/b&gt; that this does &lt;b&gt;not&lt;/b&gt; guarantee that &lt;b&gt;two&lt;/b&gt; hashes will produce the same key order for the same hash seed and traversal mask, items that collide into one bucket may have different orders regardless of this setting.</source>
          <target state="translated">이 서브 루틴을 사용하여 특정 해시에 대한 순회 마스크를 가져오고 설정할 수 있습니다. 마스크를 설정하면 지정된 해시가 동일한 키 순서를 생성합니다. &lt;b&gt;참고&lt;/b&gt; 이 않습니다 &lt;b&gt;하지&lt;/b&gt; 보장 &lt;b&gt;이&lt;/b&gt; 해시가 동일한 해시 씨와 탐색 마스크 같은 키 순서를 생성합니다이 항목은 도랑에에서 충돌이 설정에 관계없이 다른 순서를 가질 수있다.</target>
        </trans-unit>
        <trans-unit id="4e57a6a3e1ac0e576a34f1deb9cbe35e8438d88f" translate="yes" xml:space="preserve">
          <source>You can use this to find out whether two handles refer to the same underlying descriptor:</source>
          <target state="translated">이것을 사용하여 두 핸들이 동일한 기본 설명자를 참조하는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2f6df83e5ac1b378170dbde8b31e8b10cee41f6" translate="yes" xml:space="preserve">
          <source>You can use this to print out all the variables in a package, for instance. The standard but antiquated</source>
          <target state="translated">예를 들어 이것을 사용하여 패키지의 모든 변수를 인쇄 할 수 있습니다. 표준이지만 낡은</target>
        </trans-unit>
        <trans-unit id="b6fe2602c37d36cd939b3f2966e9882c1457b54a" translate="yes" xml:space="preserve">
          <source>You can use whitespace and the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator to lay them out more nicely:</source>
          <target state="translated">공백과 &lt;code&gt;=&amp;gt;&lt;/code&gt; 연산자를 사용하여 더 멋지게 배치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a2d95bc6981ab5724b117c21adf2c42ff1324ac" translate="yes" xml:space="preserve">
          <source>You can watch Perl's regular expression engine at work to verify for yourself if Perl is recompiling a regular expression. The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re
'debug'&lt;/code&gt; pragma (comes with Perl 5.005 and later) shows the details. With Perls before 5.6, you should see &lt;code&gt;re&lt;/code&gt; reporting that its compiling the regular expression on each iteration. With Perl 5.6 or later, you should only see &lt;code&gt;re&lt;/code&gt; report that for the first iteration.</source>
          <target state="translated">Perl이 정규식을 다시 컴파일하는지 직접 확인하기 위해 직장에서 Perl의 정규식 엔진을 볼 수 있습니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; 프라 그마 (나중에 펄 5.005와 함께 제공) 세부 사항을 보여줍니다. 5.6 이전 Perls, 당신은 볼 수 &lt;code&gt;re&lt;/code&gt; 의 각 반복에 정규 표현식을 컴파일하는 것을보고. Perl 5.6 이상 에서는 첫 번째 반복에 대해서만 &lt;code&gt;re&lt;/code&gt; 보고 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b95a7534126966a35fdb290a82cc3eb90110d990" translate="yes" xml:space="preserve">
          <source>You can work around the first case by using the fully qualified name (&lt;code&gt;$Package::FOO&lt;/code&gt; ) where you need a local value, or by overriding it by saying &lt;code&gt;*FOO = *Package::FOO&lt;/code&gt; in your script.</source>
          <target state="translated">로컬 값이 필요한 정규화 된 이름 ( &lt;code&gt;$Package::FOO&lt;/code&gt; ) 을 사용하거나 스크립트에서 &lt;code&gt;*FOO = *Package::FOO&lt;/code&gt; 라고 말하여 재정 의하여 첫 번째 경우 를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74896a00006c71879750ed85d659cbff45ee1a05" translate="yes" xml:space="preserve">
          <source>You can write this by hand or generate it with 'make manifest'.</source>
          <target state="translated">직접 작성하거나 'make manifest'로 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1c2fce28dbd805f8d7a870a949b6c5834632bf2" translate="yes" xml:space="preserve">
          <source>You can write this more briefly using a grep, which does the same thing.</source>
          <target state="translated">grep을 사용하여 더 간단하게 작성할 수 있습니다. 이는 동일한 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="abb98a8eca7d1aa69e5a0eb195e9e9713bd18c72" translate="yes" xml:space="preserve">
          <source>You can write your regular expressions just like someone on an ASCII platform would do. But keep in mind that using octal or hex notation to specify a particular code point will give you the character that the EBCDIC code page natively maps to it. (This is also true of all double-quoted strings.) If you want to write portably, just use the &lt;code&gt;\N{U+...}&lt;/code&gt; notation everywhere where you would have used &lt;code&gt;\x{...}&lt;/code&gt; , and don't use octal notation at all.</source>
          <target state="translated">ASCII 플랫폼의 누군가와 마찬가지로 정규식을 작성할 수 있습니다. 그러나 8 진 또는 16 진 표기법을 사용하여 특정 코드 포인트를 지정하면 EBCDIC 코드 페이지가 기본적으로 해당 코드 포인트에 맵핑되는 문자를 제공합니다. (이것은 또한 모든 따옴표 문자열의 사실이다.) 당신이 이식 작성하려는 경우, 그냥 사용 &lt;code&gt;\N{U+...}&lt;/code&gt; 당신이 사용했을 경우 사방 표기법을 &lt;code&gt;\x{...}&lt;/code&gt; , 그리고하지 8 진법을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="62834a834066a3093a80c93ec315493101e7f82e" translate="yes" xml:space="preserve">
          <source>You can't disambiguate that by saying &lt;code&gt;\{1}000&lt;/code&gt; , whereas you can fix it with &lt;code&gt;${1}000&lt;/code&gt;. The operation of interpolation should not be confused with the operation of matching a backreference. Certainly they mean two different things on the</source>
          <target state="translated">&lt;code&gt;\{1}000&lt;/code&gt; 이라고 말하면 명확하게 말할 수 없지만 &lt;code&gt;${1}000&lt;/code&gt; 수정할 수 있습니다 . 보간 연산과 역 참조 매칭 연산을 혼동해서는 안됩니다. 확실히 그들은 두 가지 다른 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b18683b4b76072abbee71a6881cdb8bc575df90f" translate="yes" xml:space="preserve">
          <source>You can't have a hash whose values are arrays; hash values can only be scalars. We're stuck with that. But a single reference can refer to an entire array, and references are scalars, so you can have a hash of references to arrays, and it'll act a lot like a hash of arrays, and it'll be just as useful as a hash of arrays.</source>
          <target state="translated">값이 배열 인 해시를 가질 수 없습니다. 해시 값은 스칼라 만 될 수 있습니다. 우리는 그것에 갇혀있다. 그러나 단일 참조는 전체 배열을 참조 할 수 있으며 참조는 스칼라이므로 배열에 대한 참조 해시를 가질 수 있으며 배열의 해시와 매우 유사하게 작동하며 배열 해시.</target>
        </trans-unit>
        <trans-unit id="d10d9e535268b6be7a5edad8c961bf0a3eba1a2f" translate="yes" xml:space="preserve">
          <source>You can't prevent people from sending your script bad data. Even if you add some client-side checks, people may disable them or bypass them completely. For instance, someone might use a module such as &lt;a href=&quot;http://search.cpan.org/perldoc/LWP&quot;&gt;LWP&lt;/a&gt; to submit to your web site. If you want to prevent data that try to use SQL injection or other sorts of attacks (and you should want to), you have to not trust any data that enter your program.</source>
          <target state="translated">사람들이 스크립트에 잘못된 데이터를 보내지 못하게 할 수는 없습니다. 클라이언트 쪽 검사를 추가하더라도 사람들이 검사를 비활성화하거나 완전히 무시할 수 있습니다. 예를 들어, 누군가 &lt;a href=&quot;http://search.cpan.org/perldoc/LWP&quot;&gt;LWP&lt;/a&gt; 와 같은 모듈을 사용 하여 웹 사이트에 제출할 수 있습니다. SQL 인젝션 또는 다른 종류의 공격을 사용하려는 데이터를 방지하려면 (및 원하는 경우) 프로그램에 입력하는 데이터를 신뢰하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="8673b45bcf51a92e5bbd4f8ac4117b4afa807acf" translate="yes" xml:space="preserve">
          <source>You can't produce a tied constant by giving a tied scalar as the value. References to tied variables, however, can be used as constants without any problems.</source>
          <target state="translated">연결 스칼라를 값으로 지정하여 연결 상수를 생성 할 수 없습니다. 그러나 묶인 변수에 대한 참조는 문제없이 상수로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37d171546c154312737dfd62e998eea96bcef04d" translate="yes" xml:space="preserve">
          <source>You can't store GLOB, FORMLINE, REGEXP, etc.... If you can define semantics for those operations, feel free to enhance Storable so that it can deal with them.</source>
          <target state="translated">GLOB, FORMLINE, REGEXP 등을 저장할 수 없습니다. 이러한 작업의 의미를 정의 할 수 있으면 Storable을 향상시켜 처리 할 수 ​​있도록하십시오.</target>
        </trans-unit>
        <trans-unit id="e0c681bde3f10285d1065419cbcfdfe8d15a0638" translate="yes" xml:space="preserve">
          <source>You can't take the address of anything, although a similar operator in Perl is the backslash, which creates a reference.</source>
          <target state="translated">Perl의 유사한 연산자가 백 슬래시이므로 참조를 생성하지만 아무 주소도 취할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3d03f47a54efdf6a567386eabfcea4dcbcebbcab" translate="yes" xml:space="preserve">
          <source>You can't use a reference to an array or hash in quite the same way that you would a real array or hash. For C or C++ programmers unused to distinguishing between arrays and pointers to the same, this can be confusing. If so, just think of it as the difference between a structure and a pointer to a structure.</source>
          <target state="translated">실제 배열이나 해시와 같은 방식으로 배열이나 해시에 대한 참조를 사용할 수 없습니다. 배열과 포인터를 구별하지 않는 C 또는 C ++ 프로그래머의 경우 혼동 될 수 있습니다. 그렇다면 구조와 구조에 대한 포인터의 차이점으로 생각하십시오.</target>
        </trans-unit>
        <trans-unit id="f88b12efd9288b17ac8ba038151b3170bc987f73" translate="yes" xml:space="preserve">
          <source>You can't. Some use the UTF8 flag for this, but that's misuse, and makes well behaved modules like Data::Dumper look bad. The flag is useless for this purpose, because it's off when an 8 bit encoding (by default ISO-8859-1) is used to store the string.</source>
          <target state="translated">당신은 할 수 없습니다. 일부는 이것을 위해 UTF8 플래그를 사용하지만 오용이며 Data :: Dumper와 같은 잘 동작하는 모듈이 나빠 보입니다. 문자열은 8 비트 인코딩 (기본적으로 ISO-8859-1)을 사용하여 문자열을 저장하면 해제되므로 해제되어 있기 때문에이 목적에는 쓸모가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2fd8f1486a5edc4ee6dd1a50f986e5205ada1304" translate="yes" xml:space="preserve">
          <source>You can't. This is because UTF-8 data is stored in bytes just like non-UTF-8 data. The Unicode character 200, (&lt;code&gt;0xC8&lt;/code&gt; for you hex types) capital E with a grave accent, is represented by the two bytes &lt;code&gt;v196.172&lt;/code&gt; . Unfortunately, the non-Unicode string &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(196).chr(172)&lt;/a&gt;&lt;/code&gt; has that byte sequence as well. So you can't tell just by looking -- this is what makes Unicode input an interesting problem.</source>
          <target state="translated">당신은 할 수 없습니다. UTF-8 데이터는 비 UTF-8 데이터와 마찬가지로 바이트로 저장되기 때문입니다. 억음 악센트가있는 유니 코드 문자 200 ( 16 진수 유형의 경우 &lt;code&gt;0xC8&lt;/code&gt; ) 대문자 E는 2 바이트 &lt;code&gt;v196.172&lt;/code&gt; 로 표시됩니다 . 불행하게도, 비 유니 코드 문자열 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(196).chr(172)&lt;/a&gt;&lt;/code&gt; 는 그 바이트 시퀀스도 가지고 있습니다. 따라서보고만으로는 알 수 없습니다. 이것이 유니 코드 입력을 흥미로운 문제로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e5a4ed4ed782a30731e5ac82f99a95d222b188b0" translate="yes" xml:space="preserve">
          <source>You can't. You need to imitate the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; call (see &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for sample code) and then have a signal handler for the INT signal that passes the signal on to the subprocess. Or you can check for it:</source>
          <target state="translated">당신은 할 수 없습니다. &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 호출 을 모방 한 다음 ( 샘플 코드 는 &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; 참조 ) 신호를 서브 프로세스로 전달하는 INT 신호에 대한 신호 핸들러가 있어야합니다. 또는 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="969f4cfd26924af3983dcc03e66552409285562e" translate="yes" xml:space="preserve">
          <source>You can, of course, declare separate handlers for these types as well (but you'll need to specify &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt; warnings 'redefine'&lt;/code&gt; to do it quietly):</source>
          <target state="translated">물론 이러한 유형에 대해 별도의 핸들러를 선언 할 수도 있습니다 (하지만 조용히하려면 &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt; warnings 'redefine'&lt;/code&gt; 를 지정 &lt;a href=&quot;../functions/no&quot;&gt;하지&lt;/a&gt; 않아도 됨 ).</target>
        </trans-unit>
        <trans-unit id="74374dec5e50007a2bb85f4a7c8771f4686fdade" translate="yes" xml:space="preserve">
          <source>You cannot Configure Perl to use long doubles unless you have at least Tru64 V5.0, the long double support simply wasn't functional enough before that. Perl's Configure will override attempts to use the long doubles (you can notice this by Configure finding out that the modfl() function does not work as it should).</source>
          <target state="translated">Tru64 V5.0 이상이 아닌 이상 Long Double을 사용하도록 Perl을 구성 할 수 없습니다. Long Double 지원은 그 이전에는 충분히 기능하지 않았습니다. Perl의 Configure는 long double을 사용하려는 시도보다 우선합니다 (modfl () 함수가 제대로 작동하지 않음을 알아 냄으로써 Configure에 의해 알 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="d8bdeec288ef204b43d051952afe1296036c485c" translate="yes" xml:space="preserve">
          <source>You cannot call &lt;code&gt;format_formfeed()&lt;/code&gt; on a handle, only as a static method. See &lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="translated">정적 메소드로만 핸들에서 &lt;code&gt;format_formfeed()&lt;/code&gt; 를 호출 할 수 없습니다 . &lt;a href=&quot;io/handle&quot;&gt;IO :: Handle을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="206c72a8b7cef7a32a6db021ff310a9ca6c22c22" translate="yes" xml:space="preserve">
          <source>You cannot call &lt;code&gt;format_line_break_characters()&lt;/code&gt; on a handle, only as a static method. See &lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="translated">정적 메서드로만 핸들에서 &lt;code&gt;format_line_break_characters()&lt;/code&gt; 를 호출 할 수 없습니다 . &lt;a href=&quot;io/handle&quot;&gt;IO :: Handle을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="be794aed40b9701358348d087034d06f390762c7" translate="yes" xml:space="preserve">
          <source>You cannot call &lt;code&gt;input_record_separator()&lt;/code&gt; on a handle, only as a static method. See &lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="translated">정적 메소드로만 핸들에서 &lt;code&gt;input_record_separator()&lt;/code&gt; 를 호출 할 수 없습니다 . &lt;a href=&quot;io/handle&quot;&gt;IO :: Handle을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e9632f1b73e717ca255777fe1c2f39799e45e4a" translate="yes" xml:space="preserve">
          <source>You cannot call &lt;code&gt;output_field_separator()&lt;/code&gt; on a handle, only as a static method. See &lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="translated">정적 메소드로만 핸들에서 &lt;code&gt;output_field_separator()&lt;/code&gt; 를 호출 할 수 없습니다 . &lt;a href=&quot;io/handle&quot;&gt;IO :: Handle을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c9f3ec65172d98e67d60dc40971034bddc7747e9" translate="yes" xml:space="preserve">
          <source>You cannot call &lt;code&gt;output_record_separator()&lt;/code&gt; on a handle, only as a static method. See &lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="translated">정적 메소드로만 핸들에서 &lt;code&gt;output_record_separator()&lt;/code&gt; 를 호출 할 수 없습니다 . &lt;a href=&quot;io/handle&quot;&gt;IO :: Handle을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c9134fa5f451fb01a8e6eeae9f39b7f5a89fc7ce" translate="yes" xml:space="preserve">
          <source>You cannot change the ordering once the database has been created. Thus you must use the same compare function every time you access the database.</source>
          <target state="translated">데이터베이스가 작성된 후에는 순서를 변경할 수 없습니다. 따라서 데이터베이스에 액세스 할 때마다 동일한 비교 기능을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="9e33a69a0160e97c284c6f83bf69b3911fb50910" translate="yes" xml:space="preserve">
          <source>You cannot currently get the precision from a specified number, but it is intended that this will be possible in the future, for example using &lt;code&gt;.*2$&lt;/code&gt;:</source>
          <target state="translated">현재 지정된 숫자에서 정밀도를 얻을 수는 없지만 앞으로는 &lt;code&gt;.*2$&lt;/code&gt; 를 사용하여 가능할 것입니다 .</target>
        </trans-unit>
        <trans-unit id="9a19723c24ab74fcf1cad038cc364f2eed15903b" translate="yes" xml:space="preserve">
          <source>You cannot discern from mere inspection which builtins are unary operators (like chop() and chdir()) and which are list operators (like print() and unlink()). (Unless prototyped, user-defined subroutines can &lt;b&gt;only&lt;/b&gt; be list operators, never unary ones.) See &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; and &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="translated">chop () 및 chdir ()과 같은 단항 연산자와 print () 및 unlink ()와 같은 목록 연산자 인 내장 검사 만 구분할 수는 없습니다. 프로토 타입이 아닌 &lt;b&gt;경우&lt;/b&gt; 사용자 정의 서브 루틴은 목록 연산자 일 수 있고 단항 연산자는 될 수 없습니다. &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 및 &lt;a href=&quot;perlsub&quot;&gt;perlsub를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ab137c3fb7d6e07844b33eb499911ea797677bd5" translate="yes" xml:space="preserve">
          <source>You cannot easily tie a multilevel data structure (such as a hash of hashes) to a dbm file. The first problem is that all but GDBM and Berkeley DB have size limitations, but beyond that, you also have problems with how references are to be represented on disk. One experimental module that does partially attempt to address this need is the MLDBM module. Check your nearest CPAN site as described in &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; for source code to MLDBM.</source>
          <target state="translated">다중 레벨 데이터 구조 (예 : 해시 해시)를 dbm 파일에 쉽게 연결할 수 없습니다. 첫 번째 문제는 GDBM과 Berkeley DB를 제외한 모든 크기에는 크기 제한이 있지만 그 이상으로 디스크에서 참조가 표현되는 방식에 문제가 있다는 것입니다. 이러한 요구를 부분적으로 해결하려는 실험 모듈 중 하나는 MLDBM 모듈입니다. 에 설명 된대로 가까운 CPAN 사이트를 확인 &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; MLDBM에 소스 코드.</target>
        </trans-unit>
        <trans-unit id="38213a95a75072574eb5ab9364f983653ee56ffc" translate="yes" xml:space="preserve">
          <source>You cannot easily tie a multilevel data structure (such as a hash of hashes) to a dbm file. The first problem is that all but GDBM and Berkeley DB have size limitations, but beyond that, you also have problems with how references are to be represented on disk. One module that does attempt to address this need is DBM::Deep. Check your nearest CPAN site as described in &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; for source code. Note that despite its name, DBM::Deep does not use dbm. Another earlier attempt at solving the problem is MLDBM, which is also available on the CPAN, but which has some fairly serious limitations.</source>
          <target state="translated">다중 레벨 데이터 구조 (예 : 해시 해시)를 dbm 파일에 쉽게 연결할 수 없습니다. 첫 번째 문제는 GDBM과 Berkeley DB를 제외한 모든 크기에는 크기 제한이 있지만 그 이상으로 디스크에서 참조가 표현되는 방식에 문제가 있다는 것입니다. 이 요구를 해결하려는 하나의 모듈은 DBM :: Deep입니다. 소스 코드 는 &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; 에 설명 된대로 가장 가까운 CPAN 사이트를 확인하십시오 . 이름에도 불구하고 DBM :: Deep은 dbm을 사용하지 않습니다. 이 문제를 해결하기위한 또 다른 초기 시도는 MLDBM입니다. MLDBM은 CPAN에서도 사용 가능하지만 상당히 심각한 제한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="54808a204fe862b1dfa25e752a892b2a04ab63bf" translate="yes" xml:space="preserve">
          <source>You cannot get stack frame information or in any fashion debug functions that were not compiled by Perl, such as those from C or C++ extensions.</source>
          <target state="translated">스택 프레임 정보 나 Perl에 의해 컴파일되지 않은 디버그 함수 (예 : C 또는 C ++ 확장의 함수)는 얻을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b370a3f9299c4f8abb35adc5b9b2b86568a00bc8" translate="yes" xml:space="preserve">
          <source>You cannot lock the individual elements of a container variable:</source>
          <target state="translated">컨테이너 변수의 개별 요소는 잠글 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f2b8b7a26c050e538a292ea22f61da0581625210" translate="yes" xml:space="preserve">
          <source>You cannot portably &quot;stack&quot; cpp directives. For example in the above you need two separate BURGLE() #defines, one for each #ifdef branch.</source>
          <target state="translated">cpp 지시문을 이식 가능하게 &quot;스택&quot;할 수 없습니다. 예를 들어 위의 #ifdef 분기마다 하나씩 두 개의 별도 BURGLE () #defines이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b918f134e01ab04a493d865bacd0ad2555d6eed0" translate="yes" xml:space="preserve">
          <source>You cannot set $RS to a pattern, only a string.</source>
          <target state="translated">$ RS를 패턴으로 설정할 수 없으며 문자열 만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="891970fccef081510b98291902ea82121168e7ae" translate="yes" xml:space="preserve">
          <source>You cannot tie this routine directly to an option, e.g.:</source>
          <target state="translated">이 루틴을 옵션에 직접 연결할 수 없습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="2d9b5eae243979aa930fce2644c85c94e98e03e5" translate="yes" xml:space="preserve">
          <source>You cannot use &lt;b&gt;-i&lt;/b&gt; to create directories or to strip extensions from files.</source>
          <target state="translated">&lt;b&gt;-i&lt;/b&gt; 를 사용하여 디렉토리를 작성하거나 파일에서 확장자를 제거 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="3d40633e0023663f60f6c6868c36efce9e85c50a" translate="yes" xml:space="preserve">
          <source>You compare the sort keys using a binary comparison and get the result of the comparison of the strings using UCA.</source>
          <target state="translated">이진 비교를 사용하여 정렬 키를 비교하고 UCA를 사용하여 문자열을 비교 한 결과를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="794fe9a7963db4b15645c3e75175ca30a42e7c02" translate="yes" xml:space="preserve">
          <source>You could also exclude &lt;code&gt;LC_NUMERIC&lt;/code&gt; , if you don't need it, by</source>
          <target state="translated">필요하지 않은 경우 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 을 제외 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="63946de92748533808fd29d4342bd54a0ec7a953" translate="yes" xml:space="preserve">
          <source>You could also have used the existing block property names:</source>
          <target state="translated">기존 블록 특성 이름을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="eaa54d59d0ed5e55dbc530f16d131415959a1711" translate="yes" xml:space="preserve">
          <source>You could also investigate the can() method in the UNIVERSAL class (part of the standard perl distribution).</source>
          <target state="translated">UNIVERSAL 클래스 (표준 perl 분배의 일부)에서 can () 메소드를 조사 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="802dff37470d190b2a864a13c708bc5907b98d91" translate="yes" xml:space="preserve">
          <source>You could also just know all the perl errors, and although there are some people who may know all of them, you probably don't. However, they all should be in the &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt; manpage. If you don't find the error in there, it probably isn't a perl error.</source>
          <target state="translated">당신은 또한 모든 펄 오류를 알 수 있으며, 그것들을 모두 아는 사람들이 있지만 아마 모르는 사람도 있습니다. 그러나 모두 &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt; 맨 페이지 에 있어야합니다 . 거기에서 오류를 찾지 못하면 아마도 perl 오류가 아닐 것입니다.</target>
        </trans-unit>
        <trans-unit id="80d2dd3ba7c4c2069cf58261b6aaeb6dcd467d24" translate="yes" xml:space="preserve">
          <source>You could also write a single get/set method using an optional argument:</source>
          <target state="translated">선택적 인수를 사용하여 단일 get / set 메소드를 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8444b9fc7a3ed8d2fa7659ffde996510ee7f1f46" translate="yes" xml:space="preserve">
          <source>You could build a web site using &lt;a href=&quot;http://search.cpan.org/perldoc/Plack&quot;&gt;Plack&lt;/a&gt; and your own code, but for anything other than a very basic web site, using a web framework (that uses &lt;a href=&quot;http://search.cpan.org/perldoc/Plack&quot;&gt;Plack&lt;/a&gt;) is a better option.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Plack&quot;&gt;Plack&lt;/a&gt; 과 자체 코드를 사용하여 웹 사이트를 구축 할 수 있지만 매우 기본적인 웹 사이트 이외의 다른 웹 사이트에는 &lt;a href=&quot;http://search.cpan.org/perldoc/Plack&quot;&gt;Plack&lt;/a&gt; 을 사용하는 웹 프레임 워크를 사용 하는 것이 더 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2158ae7a8b9ea3f34a07fb0e90c3b98892665dc8" translate="yes" xml:space="preserve">
          <source>You could conceivably do both.</source>
          <target state="translated">두 가지를 모두 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49073618f97078f446e251732bebc1a46a9b86b9" translate="yes" xml:space="preserve">
          <source>You could do the memoization yourself, by rewriting the function, like this:</source>
          <target state="translated">다음과 같이 함수를 다시 작성하여 메모를 직접 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8bc28868b949ea5a73ffcd10a5a6d7af5c6ab02" translate="yes" xml:space="preserve">
          <source>You could do this:</source>
          <target state="translated">당신은 이것을 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="9e128ecfca5b0e265baad327ad431d782e5e7ffc" translate="yes" xml:space="preserve">
          <source>You could edit that header yourself to remove that last '/', or you might note that Language Environment (LE) APAR PQ39997 describes the problem and PTF's UQ46272 and UQ46271 are the (R8 at least) fixes and apply them. If left unattended that syntax error will turn up as an inability for Perl to build its &quot;Socket&quot; extension.</source>
          <target state="translated">해당 헤더를 직접 편집하여 마지막 '/'를 제거하거나, 언어 환경 (LE) APAR PQ39997이 문제점을 설명하고 PTF의 UQ46272 및 UQ46271이 (적어도 R8) 수정 사항임을 적용 할 수 있습니다. 방치하면 구문 오류가 Perl이 &quot;소켓&quot;확장을 빌드 할 수없는 것으로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="3e7ad6be7d9fb2b01433fa3be5444bc3be8a1d7d" translate="yes" xml:space="preserve">
          <source>You could instead do lookups on $wanted with:</source>
          <target state="translated">대신 다음과 같이 $ wanted에 대한 조회를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="457f8e624ad1da28bfb9cf34b1f79dc6623d16da" translate="yes" xml:space="preserve">
          <source>You could just store all your dates as a number and then subtract. Life isn't always that simple though.</source>
          <target state="translated">모든 날짜를 숫자로 저장 한 다음 빼기 만하면됩니다. 인생이 항상 그렇게 간단한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c19f6ab6291cf9eaf2e211ed563b35ea9ac437b5" translate="yes" xml:space="preserve">
          <source>You could open the document in a web browser, and change the character set or character encoding until you can visually confirm that all characters look the way they should.</source>
          <target state="translated">웹 브라우저에서 문서를 열고 모든 문자가 원하는대로 보이는지 시각적으로 확인할 수있을 때까지 문자 세트 또는 문자 인코딩을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a20c232c667e613d02f2b4874878f40bc6c28f2" translate="yes" xml:space="preserve">
          <source>You could write the last two using the &lt;code&gt;-u&lt;/code&gt; and &lt;code&gt;-d&lt;/code&gt; operators. Commonly available &lt;code&gt;S_IF*&lt;/code&gt; constants are:</source>
          <target state="translated">&lt;code&gt;-u&lt;/code&gt; 및 &lt;code&gt;-d&lt;/code&gt; 연산자를 사용하여 마지막 두 개를 작성할 수 있습니다. 일반적으로 사용 가능한 &lt;code&gt;S_IF*&lt;/code&gt; 상수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2516f9cbf3f3333565923611bf8e4c6225451c64" translate="yes" xml:space="preserve">
          <source>You create the queue with &lt;code&gt;Thread::Queue-&amp;gt;new()&lt;/code&gt; . Then you can add lists of scalars onto the end with &lt;code&gt;enqueue()&lt;/code&gt; , and pop scalars off the front of it with &lt;code&gt;dequeue()&lt;/code&gt; . A queue has no fixed size, and can grow as needed to hold everything pushed on to it.</source>
          <target state="translated">&lt;code&gt;Thread::Queue-&amp;gt;new()&lt;/code&gt; 대기열을 만듭니다 . 그런 다음 &lt;code&gt;enqueue()&lt;/code&gt; 로 스칼라 목록을 끝에 추가 하고 &lt;code&gt;dequeue()&lt;/code&gt; 스칼라를 팝니다 . 대기열의 크기는 고정되어 있지 않으며 대기열에 푸시 된 모든 항목을 보관하는 데 필요한만큼 커질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dede4110b8ccb447bd7101130015f76cda530da1" translate="yes" xml:space="preserve">
          <source>You currently don't need to instantiate a factory in order to use it.</source>
          <target state="translated">현재 팩토리를 사용하기 위해 인스턴스화 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="94aa24e74566493da77121fdf1cf79a43455f271" translate="yes" xml:space="preserve">
          <source>You did not run &lt;code&gt;omflibs&lt;/code&gt; . See &lt;a href=&quot;#Prerequisites&quot;&gt;Prerequisites&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;omflibs&lt;/code&gt; 를 실행하지 않았습니다 . &lt;a href=&quot;#Prerequisites&quot;&gt;전제 조건을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="351e72fc696e530c4b98b81dced35a153aee9b73" translate="yes" xml:space="preserve">
          <source>You did try the &lt;b&gt;-w&lt;/b&gt; switch, didn't you?</source>
          <target state="translated">&lt;b&gt;-w&lt;/b&gt; 스위치를 사용해 보지 않습니까?</target>
        </trans-unit>
        <trans-unit id="88ae653a2469feaccaacebc0c4775e33fd1da464" translate="yes" xml:space="preserve">
          <source>You do need to be careful with the logical names representing process-permanent files, such as &lt;code&gt;SYS$INPUT&lt;/code&gt; and &lt;code&gt;SYS$OUTPUT&lt;/code&gt; . The translations for these logical names are prepended with a two-byte binary value (0x1B 0x00) that needs to be stripped off if you want to use it. (In previous versions of Perl it wasn't possible to get the values of these logical names, as the null byte acted as an end-of-string marker)</source>
          <target state="translated">&lt;code&gt;SYS$INPUT&lt;/code&gt; 및 &lt;code&gt;SYS$OUTPUT&lt;/code&gt; 과 같은 프로세스 영구 파일을 나타내는 논리 이름에주의해야합니다 . 이러한 논리 이름에 대한 변환은 사용하려는 경우 제거해야하는 2 바이트 2 진 값 (0x1B 0x00)이 앞에 붙습니다. (이전 버전의 Perl에서는 널 바이트가 문자열 끝 마커로 작동하므로 이러한 논리적 이름의 값을 얻을 수 없었습니다)</target>
        </trans-unit>
        <trans-unit id="058b0924bf8d4ec16b563bbf0577363645a7bf62" translate="yes" xml:space="preserve">
          <source>You do not call &lt;code&gt;setlogsock&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;setlogsock&lt;/code&gt; 을 호출하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0688f744612cb917b09a1848a221dbc87e7927a1" translate="yes" xml:space="preserve">
          <source>You do not have MT-safe</source>
          <target state="translated">MT 안전 장치가 없습니다</target>
        </trans-unit>
        <trans-unit id="2e1ca2f68a9ba2ef298384c1d65396bc3e584c1e" translate="yes" xml:space="preserve">
          <source>You do not have to override methods shown below unless you have to.</source>
          <target state="translated">필요한 경우가 아니면 아래에 표시된 방법을 재정의 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="d463f5c40ea27790902d715d5582fd331f2a8862" translate="yes" xml:space="preserve">
          <source>You do this by using &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; and replacing your &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt;s with &lt;code&gt;carp&lt;/code&gt; s. If you need to &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, say &lt;code&gt;croak&lt;/code&gt; instead. However, keep &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; in place for your sanity checks - where it really is your module at fault.</source>
          <target state="translated">당신은 사용하여이 작업을 수행 &lt;a href=&quot;carp&quot;&gt;잉어를&lt;/a&gt; 하고 교체 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; 에들 &lt;code&gt;carp&lt;/code&gt; 들. &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 한다면 대신 &lt;code&gt;croak&lt;/code&gt; 라고 말하십시오 . 그러나 위생 검사를 위해 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; 하고 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; -실제로 모듈이 고장난 곳.</target>
        </trans-unit>
        <trans-unit id="005e9bdc4a22cadca7bbf603665f85ba87cfef2b" translate="yes" xml:space="preserve">
          <source>You don't actually</source>
          <target state="translated">당신은 실제로하지 않습니다</target>
        </trans-unit>
        <trans-unit id="27b09323fd0303316a1e04f47208b954d9880846" translate="yes" xml:space="preserve">
          <source>You don't actually &quot;trap&quot; a control character. Instead, that character generates a signal which is sent to your terminal's currently foregrounded process group, which you then trap in your process. Signals are documented in &lt;a href=&quot;perlipc#Signals&quot;&gt;Signals in perlipc&lt;/a&gt; and the section on &quot;Signals&quot; in the Camel.</source>
          <target state="translated">실제로 제어 문자를 &quot;트랩&quot;하지는 않습니다. 대신, 해당 캐릭터는 터미널의 현재 포 그라운드 프로세스 그룹으로 전송되는 신호를 생성 한 다음 프로세스에 갇 힙니다. 신호는 &lt;a href=&quot;perlipc#Signals&quot;&gt;perlipc의 신호&lt;/a&gt; 및 Camel의 &quot;신호&quot;섹션에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b1e2e036145d009e379c1e58f4e8404e4bb7c5f" translate="yes" xml:space="preserve">
          <source>You don't have to check for &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; on the return from &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt;. Like &lt;code&gt;&lt;a href=&quot;ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt;, it maps a &lt;code&gt;0&lt;/code&gt; return from the system call into &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; in Perl. This string is true in boolean context and &lt;code&gt;0&lt;/code&gt; in numeric context. It is also exempt from the normal &lt;b&gt;-w&lt;/b&gt; warnings on improper numeric conversions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; 로부터의 반환 에 &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 것을 확인할 필요가 없습니다 . &lt;code&gt;&lt;a href=&quot;ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; 과 마찬가지로 시스템 호출 의 &lt;code&gt;0&lt;/code&gt; 리턴을 Perl의 &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; 에 맵핑합니다 . 이 문자열은 부울 컨텍스트에서는 true이고 숫자 컨텍스트에서는 &lt;code&gt;0&lt;/code&gt; 입니다. 부적절한 숫자 변환에 대한 일반적인 &lt;b&gt;-w&lt;/b&gt; 경고 도 면제됩니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="91e28b8dde4eef2778828dc13bbb504ddd8429b3" translate="yes" xml:space="preserve">
          <source>You don't have to check for &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; on the return from &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt;. Like &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt;, it maps a &lt;code&gt;0&lt;/code&gt; return from the system call into &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; in Perl. This string is true in boolean context and &lt;code&gt;0&lt;/code&gt; in numeric context. It is also exempt from the normal &lt;b&gt;-w&lt;/b&gt; warnings on improper numeric conversions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; 로부터의 반환 에 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 것을 확인할 필요가 없습니다 . &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; 과 마찬가지로 시스템 호출 의 &lt;code&gt;0&lt;/code&gt; 리턴을 Perl의 &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; 에 맵핑합니다 . 이 문자열은 부울 컨텍스트에서는 true이고 숫자 컨텍스트에서는 &lt;code&gt;0&lt;/code&gt; 입니다. 부적절한 숫자 변환에 대한 일반적인 &lt;b&gt;-w&lt;/b&gt; 경고 도 면제됩니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3317a455934bcb4f5310b2ce1e13684a7b6884c6" translate="yes" xml:space="preserve">
          <source>You don't have to close FILEHANDLE if you are immediately going to do another &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; on it, because &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; closes it for you. (See &lt;a href=&quot;#open-FILEHANDLE&quot;&gt;open&lt;/a&gt;.) However, an explicit &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; on an input file resets the line counter (&lt;code&gt;$.&lt;/code&gt; ), while the implicit close done by &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">당신은 즉시 다른가하려고하는 경우 FILEHANDLE을 닫을 필요가 없습니다 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; , 그것을 이유로 인해 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 당신을 위해 닫히고을. ( &lt;a href=&quot;#open-FILEHANDLE&quot;&gt;open&lt;/a&gt; 참조 ) 그러나 입력 파일을 명시 적으로 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 행 카운터 ( &lt;code&gt;$.&lt;/code&gt; )가 재설정되지만 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 으로 수행 된 암시 적 닫기는 재설정 되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d144697260e1beed6903444902a55fc7aceb423c" translate="yes" xml:space="preserve">
          <source>You don't have to close FILEHANDLE if you are immediately going to do another &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; on it, because &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; closes it for you. (See &lt;a href=&quot;#open-FILEHANDLE&quot;&gt;open&lt;/a&gt;.) However, an explicit &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; on an input file resets the line counter (&lt;code&gt;$.&lt;/code&gt; ), while the implicit close done by &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">당신은 즉시 다른가하려고하는 경우 FILEHANDLE을 닫을 필요가 없습니다 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; , 그것을 이유로 인해 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 당신을 위해 닫히고을. ( &lt;a href=&quot;#open-FILEHANDLE&quot;&gt;open&lt;/a&gt; 참조 ) 그러나 입력 파일을 명시 적으로 &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 행 카운터 ( &lt;code&gt;$.&lt;/code&gt; )가 재설정되지만 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 으로 수행 된 암시 적 닫기는 재설정 되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ada37b6245f195e4fcd7aa6724d9b314782b9989" translate="yes" xml:space="preserve">
          <source>You don't have to do anything new in your extension to get this; since the Perl library provides Perl_get_context(), it will all just work.</source>
          <target state="translated">이를 위해 확장 프로그램에서 새로운 작업을 수행 할 필요는 없습니다. Perl 라이브러리는 Perl_get_context ()를 제공하므로 모두 작동합니다.</target>
        </trans-unit>
        <trans-unit id="0afa6281a85d9c8f0451db68d3408cd7d6bba6a9" translate="yes" xml:space="preserve">
          <source>You don't have to do this all on the command line, though, there are a few GUI options out there. The nice thing about these is you can wave a mouse over a variable and a dump of its data will appear in an appropriate window, or in a popup balloon, no more tiresome typing of 'x $varname' :-)</source>
          <target state="translated">명령 줄에서이 작업을 모두 수행 할 필요는 없지만 몇 가지 GUI 옵션이 있습니다. 이것에 대한 좋은 점은 변수 위에 마우스를 흔들면 해당 데이터 덤프가 적절한 창이나 팝업 풍선에 나타나고 더 이상 'x $ varname'을 타이핑하지 않아도됩니다 :-)</target>
        </trans-unit>
        <trans-unit id="bc3f5455b30ee7863f96aa530c94393c0cafca20" translate="yes" xml:space="preserve">
          <source>You don't have to enclose POSIX class names inside double brackets, hence both of the following work:</source>
          <target state="translated">POSIX 클래스 이름을 이중 괄호 안에 넣을 필요가 없으므로 다음 작업이 모두 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="229ae092ed53a2ce77c4892afb43389969fbd9bc" translate="yes" xml:space="preserve">
          <source>You don't have to use \b to match words though. You can look for non-word characters surrounded by word characters. These strings match the pattern /\b'\b/.</source>
          <target state="translated">그래도 단어를 일치시키기 위해 \ b를 사용할 필요는 없습니다. 단어 문자로 둘러싸인 단어 이외의 문자를 찾을 수 있습니다. 이 문자열은 / \ b '\ b / 패턴과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="21cad750fa1f143b35b4124baa7518d27d8319c9" translate="yes" xml:space="preserve">
          <source>You don't have to worry about finding or paying for Perl; it's freely available and several popular operating systems come with Perl. Community support in places such as Perlmonks ( &lt;a href=&quot;http://www.perlmonks.com&quot;&gt;http://www.perlmonks.com&lt;/a&gt; ) and the various Perl mailing lists ( &lt;a href=&quot;http://lists.perl.org&quot;&gt;http://lists.perl.org&lt;/a&gt; ) means that you can usually get quick answers to your problems.</source>
          <target state="translated">Perl을 찾거나 지불하는 것에 대해 걱정할 필요가 없습니다. 무료로 제공되며 Perl과 함께 널리 사용되는 여러 운영 체제가 있습니다. Perlmonks ( &lt;a href=&quot;http://www.perlmonks.com&quot;&gt;http://www.perlmonks.com&lt;/a&gt; ) 및 다양한 Perl 메일 링리스트 ( &lt;a href=&quot;http://lists.perl.org&quot;&gt;http://lists.perl.org&lt;/a&gt; ) 와 같은 장소에서의 커뮤니티 지원 은 일반적으로 문제점에 대한 빠른 답변을 얻을 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8365eeff3d04c895cb1076cf6e1217da1d00d04f" translate="yes" xml:space="preserve">
          <source>You don't just have to match on fixed strings. In fact, you can match on just about anything you could dream of by using more complex regular expressions. These are documented at great length in &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;, but for the meantime, here's a quick cheat sheet:</source>
          <target state="translated">고정 문자열에서만 일치시킬 필요는 없습니다. 사실, 더 복잡한 정규식을 사용하여 꿈꾸는 모든 것에 대해 일치시킬 수 있습니다. 이것들은 &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; 에 아주 길게 문서화되어 있지만 그 동안 빠른 치트 시트가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="6fa3f4f65b9497a1fe4774a26aaf551f58ec3c5f" translate="yes" xml:space="preserve">
          <source>You don't need to have /usr/ucb/ in your PATH to build perl. If you want /usr/ucb/ in your PATH anyway, make sure that /usr/ucb/ is NOT in your PATH before the directory containing the right C compiler.</source>
          <target state="translated">PATH에 / usr / ucb /가 없어도 perl을 빌드 할 수 있습니다. 어쨌든 PATH에 / usr / ucb /를 원하면 올바른 C 컴파일러를 포함하는 디렉토리 전에 / usr / ucb /가 PATH에 있지 않은지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="e40dd09143f7def3dc81d2ff9344d2600d1d1ae7" translate="yes" xml:space="preserve">
          <source>You don't really have to count them yourself, though, since Perl already does that with the &lt;code&gt;$.&lt;/code&gt; variable, which is the current line number from the last filehandle read:</source>
          <target state="translated">Perl은 이미 &lt;code&gt;$.&lt;/code&gt; 그렇게하기 때문에 실제로는 스스로 계산할 필요가 없습니다 . variable, 마지막으로 읽은 파일 핸들의 현재 줄 번호입니다.</target>
        </trans-unit>
        <trans-unit id="b24e0508e2da733e0f794e663fee88bb39a1e25a" translate="yes" xml:space="preserve">
          <source>You don't skip tests which are failing because there's a bug in your program, or for which you don't yet have code written. For that you use TODO. Read on.</source>
          <target state="translated">프로그램에 버그가 있거나 아직 코드를 작성하지 않았기 때문에 실패한 테스트는 건너 뛰지 않습니다. 이를 위해 TODO를 사용합니다. 읽어.</target>
        </trans-unit>
        <trans-unit id="710a0707d7d6991623d26d4226d9c4d860f3f7d5" translate="yes" xml:space="preserve">
          <source>You forgot to check &lt;code&gt;$?&lt;/code&gt; to see whether the program even ran correctly. Even if you wrote</source>
          <target state="translated">&lt;code&gt;$?&lt;/code&gt; 를 확인하는 것을 잊었 습니까? 프로그램이 제대로 실행되는지 확인하십시오. 당신이 쓴 경우에도</target>
        </trans-unit>
        <trans-unit id="fc90d9f18467dae7f984c44b04f6fed62e49d3b4" translate="yes" xml:space="preserve">
          <source>You get two references to the same array. If you modify &lt;code&gt;$aref1-&amp;gt;[23]&lt;/code&gt; and then look at &lt;code&gt;$aref2-&amp;gt;[23]&lt;/code&gt; you'll see the change.</source>
          <target state="translated">동일한 배열에 대한 두 개의 참조가 있습니다. 당신이 수정 한 경우 &lt;code&gt;$aref1-&amp;gt;[23]&lt;/code&gt; 다음에 보면 &lt;code&gt;$aref2-&amp;gt;[23]&lt;/code&gt; 당신은 변화를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8e5e5638bed24bad2d4ab312bfe1360cb8707ce" translate="yes" xml:space="preserve">
          <source>You have a data file that expresses greetings in different languages. Its format is &quot;[language tag]=[how to say 'Hello']&quot;, like:</source>
          <target state="translated">인사말을 다른 언어로 표현하는 데이터 파일이 있습니다. 형식은 &quot;[language tag] = [ 'Hello']하는 방법&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="afbb6b8d64f8b4b3f378ab57026bdb8753122fdc" translate="yes" xml:space="preserve">
          <source>You have a piece of data on which many different operations are applied.</source>
          <target state="translated">여러 가지 다른 작업이 적용되는 데이터가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8eed8b91591afe605349a4edd81010c1b4133d5" translate="yes" xml:space="preserve">
          <source>You have a very old pdksh. See &lt;a href=&quot;#Prerequisites&quot;&gt;Prerequisites&lt;/a&gt;.</source>
          <target state="translated">아주 오래된 pdksh가 있습니다. &lt;a href=&quot;#Prerequisites&quot;&gt;전제 조건을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0763fc81d3cd7a4189100a79a22596558a167896" translate="yes" xml:space="preserve">
          <source>You have an older version of</source>
          <target state="translated">이전 버전이 있습니다</target>
        </trans-unit>
        <trans-unit id="72b9024251b30a14c45724d6bbd90abab3f232a3" translate="yes" xml:space="preserve">
          <source>You have been warned already in &lt;a href=&quot;#Selecting-What-to-Export&quot;&gt;Selecting What to Export&lt;/a&gt; to not export:</source>
          <target state="translated">내보낼 항목 &lt;a href=&quot;#Selecting-What-to-Export&quot;&gt;선택&lt;/a&gt; 에서 내 보내지 않도록 경고했습니다 .</target>
        </trans-unit>
        <trans-unit id="43dfe62727996603d47468da8d91c958abc24b74" translate="yes" xml:space="preserve">
          <source>You have created an XSUB interface to an application's C API.</source>
          <target state="translated">애플리케이션의 C API에 대한 XSUB 인터페이스를 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="c236e9b8bd9523c45d8e12fd36ee9331405ecbff" translate="yes" xml:space="preserve">
          <source>You have defined an END handler for an attribute that is being applied to a lexical variable. Since the variable may not be available during END this won't happen.</source>
          <target state="translated">어휘 변수에 적용되는 속성에 대한 END 핸들러를 정의했습니다. END 동안 변수를 사용할 수 없기 때문에 이런 일이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="717f15e5bfd4a04630296d7e18d1dc4a8563c670" translate="yes" xml:space="preserve">
          <source>You have set the &lt;code&gt;WindowBits&lt;/code&gt; parameter to &lt;code&gt;-MAX_WBITS&lt;/code&gt; in the constructor for this object, i.e. you are uncompressing a raw deflated data stream (RFC 1951).</source>
          <target state="translated">이 객체의 생성자에서 &lt;code&gt;WindowBits&lt;/code&gt; 매개 변수를 &lt;code&gt;-MAX_WBITS&lt;/code&gt; 로 설정했습니다 . 즉, 원시 수축 데이터 스트림을 압축 해제하고 있습니다 (RFC 1951).</target>
        </trans-unit>
        <trans-unit id="522d08a79de6280adc20232939d047a4cc891b57" translate="yes" xml:space="preserve">
          <source>You have the choice to set the config variable &lt;code&gt;scan_cache&lt;/code&gt; to &lt;code&gt;never&lt;/code&gt; . Then you must clean it up yourself. The other possible values, &lt;code&gt;atstart&lt;/code&gt; and &lt;code&gt;atexit&lt;/code&gt; clean up the build directory when you start (or more precisely, after the first extraction into the build directory) or exit the CPAN shell, respectively. If you never start up the CPAN shell, you probably also have to clean up the build directory yourself.</source>
          <target state="translated">구성 변수 &lt;code&gt;scan_cache&lt;/code&gt; 를 &lt;code&gt;never&lt;/code&gt; 로 설정할 수 있습니다 . 그런 다음 직접 청소해야합니다. 다른 시작 가능한 값인 &lt;code&gt;atstart&lt;/code&gt; 및 &lt;code&gt;atexit&lt;/code&gt; 는 각각 시작시 (또는보다 정확하게는 빌드 디렉토리로 추출한 후) 빌드 디렉토리를 정리하거나 CPAN 쉘을 종료합니다. CPAN 쉘을 시작하지 않으면 빌드 디렉토리를 직접 정리해야합니다.</target>
        </trans-unit>
        <trans-unit id="b2deb6a8cd98a82f2aaaef2ec6bec5741ef832ea" translate="yes" xml:space="preserve">
          <source>You have the same problem with &lt;a href=&quot;time/local&quot;&gt;Time::Local&lt;/a&gt;, which will give the wrong answer for those same special cases:</source>
          <target state="translated">&lt;a href=&quot;time/local&quot;&gt;Time :: Local&lt;/a&gt; 과 동일한 문제가 발생하여 동일한 특수한 경우에 대해 잘못된 답변을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d93e439cde6acc82e52bf85fad48553b810a706b" translate="yes" xml:space="preserve">
          <source>You have to be prepared to &quot;reap&quot; the child process when it finishes.</source>
          <target state="translated">하위 프로세스가 완료되면 &quot;수거&quot;할 준비를해야합니다.</target>
        </trans-unit>
        <trans-unit id="7bc9963f1adfa43aa2eba732c53b836ac12c4562" translate="yes" xml:space="preserve">
          <source>You have to decide whether you want to use string or numeric comparisons.</source>
          <target state="translated">문자열 또는 숫자 비교를 사용할지 결정해야합니다.</target>
        </trans-unit>
        <trans-unit id="4cf51b08c425e59c5631231a092f6037897d07c7" translate="yes" xml:space="preserve">
          <source>You have to decide whether your array has numeric or string indices.</source>
          <target state="translated">배열에 숫자 또는 문자열 인덱스가 있는지 여부를 결정해야합니다.</target>
        </trans-unit>
        <trans-unit id="a73461591d1d0c0412d08a5e1e1cc7e69b28c7fe" translate="yes" xml:space="preserve">
          <source>You have to have Pod::Simple::RTF installed (from the Pod::Simple dist), or this module won't work.</source>
          <target state="translated">Pod :: Simple :: RTF가 Pod :: Simple dist에서 설치되어 있어야합니다. 그렇지 않으면이 모듈이 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="58b51a173ef28ef95718c75aa4bacf0fb0ef7258" translate="yes" xml:space="preserve">
          <source>You have to have installed Pod::Simple::XMLOutStream (from the Pod::Simple dist), or this class won't work.</source>
          <target state="translated">Pod :: Simple :: XMLOutStream (Pod :: Simple dist에서)을 설치해야합니다. 그렇지 않으면이 클래스가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f9f9dbede53dcc87c8a6c2c35d9ae17a92119e03" translate="yes" xml:space="preserve">
          <source>You have to have installed Tk::Pod first, or this class won't load.</source>
          <target state="translated">Tk :: Pod를 먼저 설치해야합니다. 그렇지 않으면이 클래스가로드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="95bfc19d25cce1034c6f167e8df494025bec3f1c" translate="yes" xml:space="preserve">
          <source>You have to have two hex digits after a braceless &lt;code&gt;\x&lt;/code&gt; (use a leading zero to make two). These restrictions are to lower the incidence of typos causing the class to not match what you thought it would.</source>
          <target state="translated">괄호없는 &lt;code&gt;\x&lt;/code&gt; 뒤에 16 진수 숫자가 두 개 있어야합니다 ( 앞에 0을 사용하여 두 개 만들기). 이러한 제한은 오타 발생률을 낮추어 클래스가 생각했던 것과 일치하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="c268b51167b66309dd9d49ba2a2c249b1b287fa0" translate="yes" xml:space="preserve">
          <source>You have to keep track of N yourself. For example, let's say you want to change the fifth occurrence of &lt;code&gt;&quot;whoever&quot;&lt;/code&gt; or &lt;code&gt;&quot;whomever&quot;&lt;/code&gt; into &lt;code&gt;&quot;whosoever&quot;&lt;/code&gt; or &lt;code&gt;&quot;whomsoever&quot;&lt;/code&gt; , case insensitively. These all assume that $_ contains the string to be altered.</source>
          <target state="translated">N 자신을 추적해야합니다. 예를 들어,하자 당신의 다섯 번째 발생 변경하고 싶은 말은 &lt;code&gt;&quot;whoever&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;whomever&quot;&lt;/code&gt; 로 &lt;code&gt;&quot;whosoever&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;whomsoever&quot;&lt;/code&gt; 소문자를 구별, 케이스. 이들은 모두 $ _에 변경할 문자열이 포함되어 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="ac02203046e578344330c6d8542449742080d451" translate="yes" xml:space="preserve">
          <source>You have to run this program by hand; it's not run as part of the Perl installation.</source>
          <target state="translated">이 프로그램을 직접 실행해야합니다. Perl 설치의 일부로 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="64c3798560849a7dba79bf1106dd1dedfd652114" translate="yes" xml:space="preserve">
          <source>You have tried to use one of the &lt;code&gt;-rwxRWX&lt;/code&gt; filetests with &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;
filetest 'access'&lt;/code&gt; in effect. &lt;code&gt;File::stat&lt;/code&gt; will ignore the pragma, and just use the information in the &lt;code&gt;mode&lt;/code&gt; member as usual.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; 를 &lt;a href=&quot;../functions/use&quot;&gt;사용&lt;/a&gt; 하여 &lt;code&gt;-rwxRWX&lt;/code&gt; 파일 테스트 중 하나를 사용하려고했습니다 . &lt;code&gt;File::stat&lt;/code&gt; 는 pragma를 무시하고 평소대로 &lt;code&gt;mode&lt;/code&gt; 멤버 의 정보를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="f298d6edd85361a4fe69a118c738c5c6d1ac6519" translate="yes" xml:space="preserve">
          <source>You just can't, okay? Instead, put all the specifications together with commas between them in a single &lt;code&gt;ATTR(&lt;i&gt;specification&lt;/i&gt;)&lt;/code&gt;.</source>
          <target state="translated">당신은 할 수 없습니다, 알았지? 대신, 모든 스펙을 쉼표와 함께 하나의 &lt;code&gt;ATTR(&lt;i&gt;specification&lt;/i&gt;)&lt;/code&gt; 넣으십시오 .</target>
        </trans-unit>
        <trans-unit id="afbf451f9422303960f49b456d9bb760406138be" translate="yes" xml:space="preserve">
          <source>You likely need to figure out how this multi-byte character got mixed up with your single-byte locale (or perhaps you thought you had a UTF-8 locale, but Perl disagrees).</source>
          <target state="translated">이 멀티 바이트 문자가 단일 바이트 로케일과 어떻게 혼합되었는지 파악해야합니다 (또는 UTF-8 로케일이 있다고 생각했지만 Perl은 동의하지 않습니다).</target>
        </trans-unit>
        <trans-unit id="b36efc02e455a878d40bce54d0800047ed5ce051" translate="yes" xml:space="preserve">
          <source>You may (and usually should) use the three-argument form of open to specify I/O layers (sometimes referred to as &quot;disciplines&quot;) to apply to the handle that affect how the input and output are processed (see &lt;a href=&quot;../open&quot;&gt;open&lt;/a&gt; and &lt;a href=&quot;../perlio&quot;&gt;PerlIO&lt;/a&gt; for more details). For example:</source>
          <target state="translated">당신은 (일반적으로한다) I / 입력 및 출력이 처리되는 방식에 영향을 핸들에 적용 할 (때로는 &quot;분야&quot;라한다) O 레이어를 지정하기 위해 개방의 3 인자 양식을 사용할 수있다 (참조 &lt;a href=&quot;../open&quot;&gt;개방&lt;/a&gt; 및 &lt;a href=&quot;../perlio&quot;&gt;은 PerlIO&lt;/a&gt; 에 대한 자세한 내용은). 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f4242caecdd2a41134c434e48293066c09a61129" translate="yes" xml:space="preserve">
          <source>You may (and usually should) use the three-argument form of open to specify I/O layers (sometimes referred to as &quot;disciplines&quot;) to apply to the handle that affect how the input and output are processed (see &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; and &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt; for more details). For example:</source>
          <target state="translated">당신은 (일반적으로한다) I / 입력 및 출력이 처리되는 방식에 영향을 핸들에 적용 할 (때로는 &quot;분야&quot;라한다) O 레이어를 지정하기 위해 개방의 3 인자 양식을 사용할 수있다 (참조 &lt;a href=&quot;open&quot;&gt;개방&lt;/a&gt; 및 &lt;a href=&quot;perlio&quot;&gt;은 PerlIO&lt;/a&gt; 에 대한 자세한 내용은). 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9e56389d96587e792278e4c558eb5807976007cf" translate="yes" xml:space="preserve">
          <source>You may access the repository over the web. This allows you to browse the tree, see recent commits, subscribe to RSS feeds for the changes, search for particular commits and more. You may access it at &lt;a href=&quot;http://perl5.git.perl.org/perl.git&quot;&gt;http://perl5.git.perl.org/perl.git&lt;/a&gt;. A mirror of the repository is found at &lt;a href=&quot;https://github.com/Perl/perl5&quot;&gt;https://github.com/Perl/perl5&lt;/a&gt;.</source>
          <target state="translated">웹을 통해 저장소에 액세스 할 수 있습니다. 이를 통해 트리를 탐색하고 최근 커밋을보고 변경 사항에 대한 RSS 피드를 구독하고 특정 커밋을 검색하는 등의 작업을 수행 할 수 있습니다. &lt;a href=&quot;http://perl5.git.perl.org/perl.git&quot;&gt;http://perl5.git.perl.org/perl.git&lt;/a&gt; 에서 액세스 할 수 있습니다 . 저장소의 미러는 &lt;a href=&quot;https://github.com/Perl/perl5&quot;&gt;https://github.com/Perl/perl5에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="d839e720ae2e7bff2fab5b0520b346cd44ca6b4d" translate="yes" xml:space="preserve">
          <source>You may add other methods to the UNIVERSAL class via Perl or XS code. You do not need to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; UNIVERSAL&lt;/code&gt; to make these methods available to your program (and you should not do so).</source>
          <target state="translated">Perl 또는 XS 코드를 통해 UNIVERSAL 클래스에 다른 메소드를 추가 할 수 있습니다. 프로그램에서 이러한 메소드를 사용 가능하게 하기 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; UNIVERSAL&lt;/code&gt; 을 사용할 필요 는 없습니다 (그렇지 않아야합니다).</target>
        </trans-unit>
        <trans-unit id="100a6f059c39fc4530e46957891e388f20cf1052" translate="yes" xml:space="preserve">
          <source>You may also choose to assign the strings &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; or &lt;code&gt;&quot;DEFAULT&quot;&lt;/code&gt; as the handler, in which case Perl will try to discard the signal or do the default thing.</source>
          <target state="translated">문자열 &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;DEFAULT&quot;&lt;/code&gt; 를 처리기 로 할당하도록 선택할 수도 있습니다 .이 경우 Perl은 신호를 삭제하거나 기본 작업을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="daa282ce292ff54483ba2ce846a92dc96f9168dc" translate="yes" xml:space="preserve">
          <source>You may also examine the &quot;safe&quot; flag on the output action object which is filled in when given as the third parameter to &lt;code&gt;POSIX::sigaction()&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;POSIX::sigaction()&lt;/code&gt; 세 번째 매개 변수로 제공 될 때 채워지는 출력 조치 오브젝트에서 &quot;safe&quot;플래그를 검사 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="01c5b9373dd2d19d42f55fdae95d97ea20dd07a1" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your core functions.) Access these fields as variables named with a preceding &lt;code&gt;gr_&lt;/code&gt; . Thus, &lt;code&gt;$group_obj-&amp;gt;gid()&lt;/code&gt; corresponds to $gr_gid if you import the fields. Array references are available as regular array variables, so &lt;code&gt;@{ $group_obj-&amp;gt;members() }&lt;/code&gt; would be simply @gr_members.</source>
          <target state="translated">: FIELDS import 태그를 사용하여 모든 구조 필드를 일반 변수로 네임 스페이스에 직접 가져올 수도 있습니다. (이것은 여전히 ​​핵심 기능을 무시합니다.)이 필드는 선행 &lt;code&gt;gr_&lt;/code&gt; 로 이름이 지정된 변수로 액세스하십시오 . 따라서 필드를 가져 오는 경우 &lt;code&gt;$group_obj-&amp;gt;gid()&lt;/code&gt; 는 $ gr_gid에 해당합니다. 배열 참조는 일반 배열 변수로 사용할 수 있으므로 &lt;code&gt;@{ $group_obj-&amp;gt;members() }&lt;/code&gt; 는 단순히 @gr_members입니다.</target>
        </trans-unit>
        <trans-unit id="fa4935199f235ba2f0cd0a1d49e3ac1a3bbd011f" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your core functions.) Access these fields as variables named with a preceding &lt;code&gt;h_&lt;/code&gt; . Thus, &lt;code&gt;$host_obj-&amp;gt;name()&lt;/code&gt; corresponds to $h_name if you import the fields. Array references are available as regular array variables, so for example &lt;code&gt;@{ $host_obj-&amp;gt;aliases()
}&lt;/code&gt; would be simply @h_aliases.</source>
          <target state="translated">: FIELDS import 태그를 사용하여 모든 구조 필드를 일반 변수로 네임 스페이스에 직접 가져올 수도 있습니다. (여전히 핵심 기능보다 우선합니다.)이 필드는 앞에 &lt;code&gt;h_&lt;/code&gt; 로 이름이 지정된 변수로 액세스하십시오 . 따라서 필드를 가져 오는 경우 &lt;code&gt;$host_obj-&amp;gt;name()&lt;/code&gt; 은 $ h_name에 해당합니다. 배열 참조는 일반 배열 변수로 사용할 수 있으므로 예를 들어 &lt;code&gt;@{ $host_obj-&amp;gt;aliases() }&lt;/code&gt; 는 단순히 @h_aliases입니다.</target>
        </trans-unit>
        <trans-unit id="60ec160f76fcfc38cc73d96c90a7ce874d6384c9" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your core functions.) Access these fields as variables named with a preceding &lt;code&gt;n_&lt;/code&gt; . Thus, &lt;code&gt;$net_obj-&amp;gt;name()&lt;/code&gt; corresponds to $n_name if you import the fields. Array references are available as regular array variables, so for example &lt;code&gt;@{ $net_obj-&amp;gt;aliases()
}&lt;/code&gt; would be simply @n_aliases.</source>
          <target state="translated">: FIELDS import 태그를 사용하여 모든 구조 필드를 일반 변수로 네임 스페이스에 직접 가져올 수도 있습니다. (여전히 핵심 기능보다 우선합니다.)이 필드는 앞에 &lt;code&gt;n_&lt;/code&gt; 으로 이름이 지정된 변수로 액세스하십시오 . 따라서 필드를 가져 오면 &lt;code&gt;$net_obj-&amp;gt;name()&lt;/code&gt; 은 $ n_name에 해당합니다. 배열 참조는 일반 배열 변수로 사용할 수 있으므로 예를 들어 &lt;code&gt;@{ $net_obj-&amp;gt;aliases() }&lt;/code&gt; 는 단순히 @n_aliases입니다.</target>
        </trans-unit>
        <trans-unit id="cd8189e5c613aac0e23d3c0670ed3ce2f5ae13db" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your core functions.) Access these fields as variables named with a preceding &lt;code&gt;p_&lt;/code&gt; . Thus, &lt;code&gt;$proto_obj-&amp;gt;name()&lt;/code&gt; corresponds to $p_name if you import the fields. Array references are available as regular array variables, so for example &lt;code&gt;@{ $proto_obj-&amp;gt;aliases()
}&lt;/code&gt; would be simply @p_aliases.</source>
          <target state="translated">: FIELDS import 태그를 사용하여 모든 구조 필드를 일반 변수로 네임 스페이스에 직접 가져올 수도 있습니다. (이것은 여전히 ​​핵심 기능을 재정의합니다.)이 필드는 앞에 &lt;code&gt;p_&lt;/code&gt; 로 이름이 지정된 변수로 액세스하십시오 . 따라서 필드를 가져올 경우 &lt;code&gt;$proto_obj-&amp;gt;name()&lt;/code&gt; 은 $ p_name에 해당합니다. 배열 참조는 일반 배열 변수로 사용할 수 있으므로 예를 들어 &lt;code&gt;@{ $proto_obj-&amp;gt;aliases() }&lt;/code&gt; 는 단순히 @p_aliases입니다.</target>
        </trans-unit>
        <trans-unit id="25ca76eb17a2cf86a0c57fdc15c696e88b6cf4c9" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your core functions.) Access these fields as variables named with a preceding &lt;code&gt;pw_&lt;/code&gt; in front their method names. Thus, &lt;code&gt;$passwd_obj-&amp;gt;shell&lt;/code&gt; corresponds to $pw_shell if you import the fields.</source>
          <target state="translated">: FIELDS import 태그를 사용하여 모든 구조 필드를 일반 변수로 네임 스페이스에 직접 가져올 수도 있습니다. (이것은 여전히 ​​핵심 함수를 무시합니다.) 메소드 이름 앞에 앞에 &lt;code&gt;pw_&lt;/code&gt; 로 이름이 지정된 변수로이 필드에 액세스하십시오 . 따라서 필드를 가져 오는 경우 &lt;code&gt;$passwd_obj-&amp;gt;shell&lt;/code&gt; 은 $ pw_shell에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="274d859e81c068db4c48efa8f50c77493ca5cdbd" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your core functions.) Access these fields as variables named with a preceding &lt;code&gt;s_&lt;/code&gt; . Thus, &lt;code&gt;$serv_obj-&amp;gt;name()&lt;/code&gt; corresponds to $s_name if you import the fields. Array references are available as regular array variables, so for example &lt;code&gt;@{ $serv_obj-&amp;gt;aliases()}&lt;/code&gt; would be simply @s_aliases.</source>
          <target state="translated">: FIELDS import 태그를 사용하여 모든 구조 필드를 일반 변수로 네임 스페이스에 직접 가져올 수도 있습니다. (여전히 핵심 기능보다 우선합니다.)이 필드는 앞에 &lt;code&gt;s_&lt;/code&gt; 로 이름이 지정된 변수로 액세스하십시오 . 따라서 필드를 가져 오는 경우 &lt;code&gt;$serv_obj-&amp;gt;name()&lt;/code&gt; 은 $ s_name에 해당합니다. 배열 참조는 일반 배열 변수로 사용할 수 있으므로 예를 들어 &lt;code&gt;@{ $serv_obj-&amp;gt;aliases()}&lt;/code&gt; 는 단순히 @s_aliases입니다.</target>
        </trans-unit>
        <trans-unit id="447198c5b98b7b54155b70c415358589d509c62e" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your core functions.) Access these fields as variables named with a preceding &lt;code&gt;tm_&lt;/code&gt; in front their method names. Thus, &lt;code&gt;$tm_obj-&amp;gt;mday()&lt;/code&gt; corresponds to $tm_mday if you import the fields.</source>
          <target state="translated">: FIELDS import 태그를 사용하여 모든 구조 필드를 일반 변수로 네임 스페이스에 직접 가져올 수도 있습니다. (여전히 핵심 기능을 재정의합니다.) 메소드 이름 앞에 앞에 &lt;code&gt;tm_&lt;/code&gt; 로 이름이 지정된 변수로이 필드에 액세스하십시오 . 따라서 필드를 가져 오는 경우 &lt;code&gt;$tm_obj-&amp;gt;mday()&lt;/code&gt; 는 $ tm_mday에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="5c856054dbb9356054cca7ccfef163a998ceb55f" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your stat() and lstat() functions.) Access these fields as variables named with a preceding &lt;code&gt;st_&lt;/code&gt; in front their method names. Thus, &lt;code&gt;$stat_obj-&amp;gt;dev()&lt;/code&gt; corresponds to $st_dev if you import the fields.</source>
          <target state="translated">: FIELDS import 태그를 사용하여 모든 구조 필드를 일반 변수로 네임 스페이스에 직접 가져올 수도 있습니다. (여전히 stat () 및 lstat () 함수보다 우선합니다.) 메소드 이름 앞에 앞에 &lt;code&gt;st_&lt;/code&gt; 로 이름이 지정된 변수로이 필드에 액세스하십시오 . 따라서 필드를 가져 오는 경우 &lt;code&gt;$stat_obj-&amp;gt;dev()&lt;/code&gt; 는 $ st_dev에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="a6b6b26fcc9879eca82e69c4a67570540fca4ae9" translate="yes" xml:space="preserve">
          <source>You may also need to apply the patches supplied with the binary distribution of perl. It also makes sense to look on the perl5-porters mailing list for the latest OS/2-related patches (see &lt;a href=&quot;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/&quot;&gt;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/&lt;/a&gt;). Such patches usually contain strings &lt;code&gt;/os2/&lt;/code&gt; and &lt;code&gt;patch&lt;/code&gt; , so it makes sense looking for these strings.</source>
          <target state="translated">바이너리 배포판 perl과 함께 제공된 패치를 적용해야 할 수도 있습니다. 최신 OS / 2 관련 패치 ( &lt;a href=&quot;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/&quot;&gt;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/ 참조&lt;/a&gt; ) 는 perl5-porters 메일 링리스트에서 확인하는 것이 좋습니다. 이러한 패치에는 일반적으로 &lt;code&gt;/os2/&lt;/code&gt; 및 &lt;code&gt;patch&lt;/code&gt; 문자열이 포함 되므로 이러한 문자열을 찾는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6aa8495c9efa1eb6aea78e6cd751529d33d7b29e" translate="yes" xml:space="preserve">
          <source>You may also need to comment out the &lt;code&gt;DELAYLOAD = ...&lt;/code&gt; line in the Makefile if you're using VC++ 6.0 without the latest service pack and the linker reports an internal error.</source>
          <target state="translated">최신 서비스 팩없이 VC ++ 6.0을 사용하고 링커에서 내부 오류를보고하는 경우 Makefile에서 &lt;code&gt;DELAYLOAD = ...&lt;/code&gt; 행 을 주석 처리해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2c64c3fbfbcaace5918da128791239c43cdf19d2" translate="yes" xml:space="preserve">
          <source>You may also use &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined(&amp;amp;func)&lt;/a&gt;&lt;/code&gt; to check whether subroutine &lt;code&gt;&amp;amp;func&lt;/code&gt; has ever been defined. The return value is unaffected by any forward declarations of &lt;code&gt;&amp;amp;func&lt;/code&gt; . A subroutine that is not defined may still be callable: its package may have an &lt;code&gt;AUTOLOAD&lt;/code&gt; method that makes it spring into existence the first time that it is called; see &lt;a href=&quot;../perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="translated">서브 루틴 &lt;code&gt;&amp;amp;func&lt;/code&gt; 이 정의 되었는지 여부를 확인하기 위해 &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined(&amp;amp;func)&lt;/a&gt;&lt;/code&gt; 를 사용할 수도 있습니다 . 리턴 값은 &lt;code&gt;&amp;amp;func&lt;/code&gt; 의 모든 선언에 영향을받지 않습니다 . 정의되지 않은 서브 루틴은 여전히 ​​호출 가능합니다. 패키지에는 &lt;code&gt;AUTOLOAD&lt;/code&gt; 메소드가 있을 수 있습니다 . &lt;a href=&quot;../perlsub&quot;&gt;perlsub를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="172f346295165efa4fd86444269a98fd3b778c01" translate="yes" xml:space="preserve">
          <source>You may also use &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined(&amp;amp;func)&lt;/a&gt;&lt;/code&gt; to check whether subroutine &lt;code&gt;&amp;amp;func&lt;/code&gt; has ever been defined. The return value is unaffected by any forward declarations of &lt;code&gt;&amp;amp;func&lt;/code&gt; . A subroutine that is not defined may still be callable: its package may have an &lt;code&gt;AUTOLOAD&lt;/code&gt; method that makes it spring into existence the first time that it is called; see &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="translated">서브 루틴 &lt;code&gt;&amp;amp;func&lt;/code&gt; 이 정의 되었는지 여부를 확인하기 위해 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined(&amp;amp;func)&lt;/a&gt;&lt;/code&gt; 를 사용할 수도 있습니다 . 리턴 값은 &lt;code&gt;&amp;amp;func&lt;/code&gt; 의 모든 선언에 영향을받지 않습니다 . 정의되지 않은 서브 루틴은 여전히 ​​호출 가능합니다. 패키지에는 &lt;code&gt;AUTOLOAD&lt;/code&gt; 메소드가 있을 수 있습니다 . &lt;a href=&quot;perlsub&quot;&gt;perlsub를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4b5f7479dd4b17df91be39e0264b553fbc922288" translate="yes" xml:space="preserve">
          <source>You may also use backticks to invoke a DCL subprocess, whose output is used as the return value of the expression. The string between the backticks is handled as if it were the argument to the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; operator (see below). In this case, Perl will wait for the subprocess to complete before continuing.</source>
          <target state="translated">백틱을 사용하여 DCL 서브 프로세스를 호출 할 수 있습니다. DCL 서브 프로세스는 출력이 표현식의 리턴 값으로 사용됩니다. 백틱 사이의 문자열은 마치 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 연산자에 대한 인수 인 것처럼 처리됩니다 (아래 참조). 이 경우 Perl은 계속하기 전에 서브 프로세스가 완료 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="5448f65c98891197c6cecbe08ead986b82724f17" translate="yes" xml:space="preserve">
          <source>You may also use dmake. See &lt;a href=&quot;#Make&quot;&gt;Make&lt;/a&gt; above on how to get it.</source>
          <target state="translated">dmake를 사용할 수도 있습니다. 얻는 방법에 대해서는 위의 &lt;a href=&quot;#Make&quot;&gt;확인을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3196fa8d2ff4d6ac1033b15a7916441466060e42" translate="yes" xml:space="preserve">
          <source>You may also use the &lt;a href=&quot;ipc/open3&quot;&gt;IPC::Open3&lt;/a&gt; module (part of the standard perl distribution), but be warned that it has a different order of arguments from &lt;a href=&quot;ipc/open2&quot;&gt;IPC::Open2&lt;/a&gt; (see &lt;a href=&quot;ipc/open3&quot;&gt;IPC::Open3&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;ipc/open3&quot;&gt;IPC :: Open3&lt;/a&gt; 모듈 (표준 perl 배포의 일부)을 사용할 수도 있지만 &lt;a href=&quot;ipc/open2&quot;&gt;IPC :: Open2&lt;/a&gt; 와 다른 순서의 인수가 있음을 경고합니다 ( &lt;a href=&quot;ipc/open3&quot;&gt;IPC :: Open3&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="6b7ef88e606ea55cb21f76eea0e0de1fb7b9db2f" translate="yes" xml:space="preserve">
          <source>You may also want to look at one other option for building a perl that will work on Windows: the README.cygwin file, which give a different set of rules to build a perl for Windows. This method will probably enable you to build a more Unix-compatible perl, but you will also need to download and use various other build-time and run-time support software described in that file.</source>
          <target state="translated">Windows에서 작동하는 perl을 빌드하기위한 다른 옵션 인 README.cygwin 파일을 살펴보면 Windows 용 perl을 빌드하기위한 다른 규칙 세트가 제공됩니다. 이 방법을 사용하면 더 많은 Unix 호환 펄을 빌드 할 수 있지만 해당 파일에 설명 된 다양한 기타 빌드 타임 및 런타임 지원 소프트웨어를 다운로드하여 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="47d8e5afa5f51ce60391c15623a30d357b47dac4" translate="yes" xml:space="preserve">
          <source>You may also want to override the &lt;b&gt;begin_input()&lt;/b&gt; and &lt;b&gt;end_input()&lt;/b&gt; methods for your subclass (to perform any needed per-file and/or per-document initialization or cleanup).</source>
          <target state="translated">서브 파일에 대해 &lt;b&gt;begin_input &lt;/b&gt;&lt;b&gt;()&lt;/b&gt; 및 &lt;b&gt;end_input ()&lt;/b&gt; 메소드 를 대체 할 수도 있습니다 &lt;b&gt;(&lt;/b&gt; 필요한 파일 별 및 / 또는 문서 별 초기화 또는 정리를 수행하기 위해).</target>
        </trans-unit>
        <trans-unit id="fad70035f3a1b89b3667a331878011a9d50cf74f" translate="yes" xml:space="preserve">
          <source>You may also want to read over the source for &lt;code&gt;File::Findgrep&lt;/code&gt; and its constituent modules -- they are a complete (if small) example application that uses Maketext.</source>
          <target state="translated">&lt;code&gt;File::Findgrep&lt;/code&gt; 및 그 구성 모듈에 대한 소스를 읽을 수도 있습니다 . Maketext를 사용하는 완전한 (작은 경우) 예제 응용 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="32c591edfbc105cf26f618c0c72cc57761fceff2" translate="yes" xml:space="preserve">
          <source>You may also wish to discuss with the translators the question of how to relate different subforms of the same language tag, considering how this reacts with &lt;code&gt;get_handle&lt;/code&gt; 's treatment of these. For example, if a user accepts interfaces in &quot;en, fr&quot;, and you have interfaces available in &quot;en-US&quot; and &quot;fr&quot;, what should they get? You may wish to resolve this by establishing that &quot;en&quot; and &quot;en-US&quot; are effectively synonymous, by having one class zero-derive from the other.</source>
          <target state="translated">&lt;code&gt;get_handle&lt;/code&gt; 의 처리 와 어떻게 반응 하는지를 고려할 때, 동일한 언어 태그의 다른 하위 양식을 연관시키는 방법에 대한 질문을 번역자와 논의 할 수도 있습니다 . 예를 들어, 사용자가 &quot;en, fr&quot;의 인터페이스를 허용하고 &quot;en-US&quot;및 &quot;fr&quot;의 인터페이스를 사용할 수 있다면 어떻게해야합니까? &quot;en&quot;과 &quot;en-US&quot;가 한 클래스가 다른 클래스에서 0으로 파생되도록하여 실질적으로 동의어를 설정함으로써이 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05003e2911012bca46d826b18714273b702cbb78" translate="yes" xml:space="preserve">
          <source>You may also, in the Bourne shell tradition, specify an EXPR beginning with &lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt;, in which case the rest of the string is interpreted as the name of a filehandle (or file descriptor, if numeric) to be duped (as &lt;code&gt;dup(2)&lt;/code&gt; ) and opened. You may use &lt;code&gt;&amp;amp;&lt;/code&gt; after &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;+&amp;gt;&lt;/code&gt;, &lt;code&gt;+&amp;gt;&amp;gt;&lt;/code&gt; , and &lt;code&gt;+&amp;lt;&lt;/code&gt; . The mode you specify should match the mode of the original filehandle. (Duping a filehandle does not take into account any existing contents of IO buffers.) If you use the three-argument form, then you can pass either a number, the name of a filehandle, or the normal &quot;reference to a glob&quot;.</source>
          <target state="translated">Bourne 쉘 전통에서 &lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt; 로 시작하는 EXPR을 지정할 수도 있습니다. 이 경우 나머지 문자열은 파일 처리 (또는 숫자 인 경우 파일 설명자)의 이름으로 해석됩니다 ( &lt;code&gt;dup(2)&lt;/code&gt; ) 개설했습니다. 당신은 사용할 수 있습니다 &lt;code&gt;&amp;amp;&lt;/code&gt; 후 &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;+&amp;gt;&lt;/code&gt; , &lt;code&gt;+&amp;gt;&amp;gt;&lt;/code&gt; , 그리고 &lt;code&gt;+&amp;lt;&lt;/code&gt; . 지정한 모드는 원래 파일 핸들의 모드와 일치해야합니다. (파일 핸들을 복제하는 것은 IO 버퍼의 기존 내용을 고려하지 않습니다.) 3 인수 양식을 사용하는 경우 숫자, 파일 핸들 이름 또는 일반적인 &quot;글로브 참조&quot;를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c5fc563eb0d1fd26ae839cfa02427332324573f" translate="yes" xml:space="preserve">
          <source>You may ask whether one of these was implemented on the system Perl was built on by asking the importable &lt;code&gt;pw_has&lt;/code&gt; function about them. This function returns true if all parameters are supported fields on the build platform, false if one or more were not, and raises an exception if you asked about a field that Perl never knows how to provide. Parameters may be in a space-separated string, or as separate arguments. If you pass no parameters, the function returns the list of &lt;code&gt;struct pwd&lt;/code&gt; fields supported by your build platform's C library, as a list in list context, or a space-separated string in scalar context. Note that just because your C library had a field doesn't necessarily mean that it's fully implemented on that system.</source>
          <target state="translated">임포트 가능한 &lt;code&gt;pw_has&lt;/code&gt; 함수를 요청하여 Perl이 빌드 된 시스템에서 이들 중 하나가 구현되었는지 여부를 물을 수 있습니다 . 이 함수는 모든 매개 변수가 빌드 플랫폼에서 지원되는 필드 인 경우 true를 리턴하고 하나 이상이 아닌 경우 false를 리턴하며 Perl이 제공 방법을 모르는 필드에 대해 요청한 경우 예외를 발생시킵니다. 매개 변수는 공백으로 구분 된 문자열에 있거나 별도의 인수 일 수 있습니다. 매개 변수를 전달하지 않으면 함수는 빌드 플랫폼의 C 라이브러리에서 지원하는 &lt;code&gt;struct pwd&lt;/code&gt; 필드 목록을 목록 컨텍스트의 목록으로 또는 스칼라 컨텍스트에서 공백으로 구분 된 문자열로 리턴합니다 . C 라이브러리에 필드가 있다고해서 반드시 해당 시스템에서 완전히 구현 된 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="56003b76083072e5d28f4c38591744948d360c03" translate="yes" xml:space="preserve">
          <source>You may at this point want to consider whether your base class (Projname::L10N), from which all lexicons inherit from (Projname::L10N::en, Projname::L10N::es, etc.), should be an _AUTO lexicon. It may be true that in theory, all needed messages will be in each language class; but in the presumably unlikely or &quot;impossible&quot; case of lookup failure, you should consider whether your program should throw an exception, emit text in English (or whatever your project's first language is), or some more complex solution as described in the section &quot;Controlling Lookup Failure&quot;, above.</source>
          <target state="translated">이 시점에서 모든 어휘집이 (Projname :: L10N :: en, Projname :: L10N :: es 등)에서 상속하는 기본 클래스 (Projname :: L10N)가 _AUTO인지 여부를 고려할 수 있습니다. 사전. 이론적으로 필요한 모든 메시지는 각 언어 클래스에있을 것입니다. 그러나 조회 실패의 가능성이 거의 없거나 &quot;불가능한&quot;경우, 프로그램에서 예외를 발생시켜야하는지, 영어로 텍스트를 내 보내야하는지 (또는 프로젝트의 모국어가 무엇이든) 또는 &quot; 위의 조회 실패 제어 &quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="00dd50349ec2812a0e8ba87a508b17b844d30458" translate="yes" xml:space="preserve">
          <source>You may be able to figure out what's going wrong using the Perl debugger. For information about how to use the debugger &lt;b&gt;perldoc&lt;/b&gt;&lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;.</source>
          <target state="translated">Perl 디버거를 사용하여 무엇이 잘못되었는지 파악할 수 있습니다. 디버거 &lt;b&gt;perldoc &lt;/b&gt;&lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt; 사용 방법에 대한 정보 .</target>
        </trans-unit>
        <trans-unit id="538c1768e7dd08c154327dd9d81d8469210ac3b8" translate="yes" xml:space="preserve">
          <source>You may be mixing the Tru64 cc/ar/ld with the GNU gcc/ar/ld. That may work, but sometimes it doesn't (your gcc or GNU utils may have been compiled for an incompatible OS release).</source>
          <target state="translated">Tru64 cc / ar / ld와 GNU gcc / ar / ld를 혼합했을 수 있습니다. 작동하지만 때로는 그렇지 않습니다 (gcc 또는 GNU utils가 호환되지 않는 OS 릴리스 용으로 컴파일되었을 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="569474da0977b8a6d57c606d4bf816045d439deb" translate="yes" xml:space="preserve">
          <source>You may be more comfortable with the Perl version of that:</source>
          <target state="translated">Perl 버전에 더 익숙 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="a2c2934cf1eab265e83a97c11bed16b38a8b5801" translate="yes" xml:space="preserve">
          <source>You may be presented with strings in any of these equivalent forms. There is currently nothing in Perl 5 that ignores the differences. So you'll have to specially hanlde it. The usual advice is to convert your inputs to &lt;code&gt;NFD&lt;/code&gt; before processing further.</source>
          <target state="translated">이와 동등한 형식으로 문자열이 표시 될 수 있습니다. 현재 Perl 5에는 차이점을 무시하는 것이 없습니다. 그래서 당신은 특별히 그것을 hanlde해야합니다. 일반적인 조언은 추가 처리 전에 입력을 &lt;code&gt;NFD&lt;/code&gt; 로 변환하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="58f64d73709bb7f46995ccc9ddf584cf761fc186" translate="yes" xml:space="preserve">
          <source>You may call &lt;code&gt;can&lt;/code&gt; as a class (static) method or an object method.</source>
          <target state="translated">&lt;code&gt;can&lt;/code&gt; 을 클래스 (정적) 메소드 또는 객체 메소드로 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8cf034da6832021586a2104fbbd0c08a1605f5bc" translate="yes" xml:space="preserve">
          <source>You may call &lt;code&gt;hv_delete&lt;/code&gt; or &lt;code&gt;hv_delete_ent&lt;/code&gt; on the hash entry that the iterator currently points to, without losing your place or invalidating your iterator. Note that in this case the current entry is deleted from the hash with your iterator holding the last reference to it. Your iterator is flagged to free the entry on the next call to &lt;code&gt;hv_iternext&lt;/code&gt; , so you must not discard your iterator immediately else the entry will leak - call &lt;code&gt;hv_iternext&lt;/code&gt; to trigger the resource deallocation.</source>
          <target state="translated">자리를 잃거나 반복자를 무효화하지 않고 반복자가 현재 가리키는 해시 항목에서 &lt;code&gt;hv_delete&lt;/code&gt; 또는 &lt;code&gt;hv_delete_ent&lt;/code&gt; 를 호출 할 수 있습니다 . 이 경우 반복자가 마지막 참조를 보유한 해시에서 현재 항목이 삭제됩니다. 반복자는 &lt;code&gt;hv_iternext&lt;/code&gt; 에 대한 다음 호출에서 항목을 비우 도록 플래그가 지정 되므로 반복기를 즉시 버리지 않아야합니다. 그렇지 않으면 항목이 누출됩니다. &lt;code&gt;hv_iternext&lt;/code&gt; 를 호출 하여 자원 할당 해제를 트리거하십시오.</target>
        </trans-unit>
        <trans-unit id="9be40ceb1a7306a76b520e9584d2eca0a12452f8" translate="yes" xml:space="preserve">
          <source>You may change the pager which is used via &lt;code&gt;o pager=...&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;o pager=...&lt;/code&gt; 명령을 통해 사용되는 호출기를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d0d219cb50b9b95de99bdba2a6790e3027b1988" translate="yes" xml:space="preserve">
          <source>You may choose one of six different protocols to use for the ping. The &quot;tcp&quot; protocol is the default. Note that a live remote host may still fail to be pingable by one or more of these protocols. For example, www.microsoft.com is generally alive but not &quot;icmp&quot; pingable.</source>
          <target state="translated">핑에 사용할 6 가지 프로토콜 중 하나를 선택할 수 있습니다. &quot;tcp&quot;프로토콜이 기본값입니다. 이 프로토콜 중 하나 이상에서 라이브 원격 호스트를 여전히 ping 할 수없는 경우가 있습니다. 예를 들어 www.microsoft.com은 일반적으로 살아 있지만 &quot;icmp&quot;핑 가능하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5b9386b09cdd1212e7410c2ab62737e2149c7f2b" translate="yes" xml:space="preserve">
          <source>You may create a shared library that refers to another library, which may be either an archive library or a shared library. If this second library is a shared library, this is called a &quot;dependent library&quot;. The dependent library's name is recorded in the main shared library, but it is not linked into the shared library. Instead, it is loaded when the main shared library is loaded. This can cause problems if you build an extension on one system and move it to another system where the libraries may not be located in the same place as on the first system.</source>
          <target state="translated">아카이브 라이브러리 또는 공유 라이브러리 일 수있는 다른 라이브러리를 참조하는 공유 라이브러리를 작성할 수 있습니다. 이 두 번째 라이브러리가 공유 라이브러리 인 경우이를 &quot;종속 라이브러리&quot;라고합니다. 종속 라이브러리의 이름은 기본 공유 라이브러리에 기록되지만 공유 라이브러리에 링크되어 있지 않습니다. 대신 기본 공유 라이브러리가로드 될 때로드됩니다. 한 시스템에서 확장을 빌드하고 라이브러리를 첫 번째 시스템과 같은 위치에 있지 않은 다른 시스템으로 이동하면 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c69978ae72909c6a0d4c9ce7bda602f4029ade9" translate="yes" xml:space="preserve">
          <source>You may declare &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; variables at the outermost scope of a file to hide any such identifiers from the world outside that file. This is similar in spirit to C's static variables when they are used at the file level. To do this with a subroutine requires the use of a closure (an anonymous function that accesses enclosing lexicals). If you want to create a private subroutine that cannot be called from outside that block, it can declare a lexical variable containing an anonymous sub reference:</source>
          <target state="translated">당신은 선언 할 수있다 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 해당 파일 외부 세계에서 이러한 식별자를 숨길 수있는 파일의 가장 바깥 쪽 범위에서 변수를. 이것은 파일 수준에서 사용될 때 C의 정적 변수와 정신적으로 유사합니다. 서브 루틴으로이를 수행하려면 클로저 (내장 어휘에 액세스하는 익명 함수)를 사용해야합니다. 해당 블록 외부에서 호출 할 수없는 개인 서브 루틴을 작성하려는 경우 익명 서브 참조를 포함하는 어휘 변수를 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c485e566982c516f185802a5bb8005684c87aaf" translate="yes" xml:space="preserve">
          <source>You may do &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads qw(yield)&lt;/code&gt; , and then just use &lt;code&gt;yield()&lt;/code&gt; in your code.</source>
          <target state="translated">당신은 할 수 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads qw(yield)&lt;/code&gt; 한 다음 바로 사용 &lt;code&gt;yield()&lt;/code&gt; 코드에서.</target>
        </trans-unit>
        <trans-unit id="ad59ee540ee6c5334c4114152f24df062a49e4a1" translate="yes" xml:space="preserve">
          <source>You may encounter the following warning message at Perl startup:</source>
          <target state="translated">Perl 시작시 다음 경고 메시지가 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="294037a277c0cf3bb9e6ace3733986ce5d32b057" translate="yes" xml:space="preserve">
          <source>You may find it helpful to have a &quot;macro dictionary&quot;, which you can produce by saying &lt;code&gt;cpp -dM perl.c | &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; . Even then,</source>
          <target state="translated">&quot;매크로 사전&quot;을 갖는 것이 도움이 될 수 있습니다.이 사전은 &lt;code&gt;cpp -dM perl.c | &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 합니다. 그렇다하더라도,</target>
        </trans-unit>
        <trans-unit id="972b606b3734fb1680ed24e777ce569b72a6f320" translate="yes" xml:space="preserve">
          <source>You may find it helpful to use letter case to indicate the scope or nature of a variable. For example:</source>
          <target state="translated">대소 문자를 사용하여 변수의 범위 또는 특성을 나타내는 것이 도움이 될 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c25f48a1ca763d34150d8bac8dc30aeefcd980b5" translate="yes" xml:space="preserve">
          <source>You may get a bus error core dump from the op/pwent or op/grent tests. If compiled with -g you will see a stack trace much like the following:</source>
          <target state="translated">op / pwent 또는 op / grent 테스트에서 버스 오류 코어 덤프를 얻을 수 있습니다. -g로 컴파일하면 다음과 같은 스택 추적이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="108b6e50ab8abc6a709ca1e727e6115ff077c1f8" translate="yes" xml:space="preserve">
          <source>You may get a warning when doing a threaded build:</source>
          <target state="translated">스레드 빌드를 수행 할 때 경고가 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22f1e826336ce72e185bd16ea03c1b6430323fa0" translate="yes" xml:space="preserve">
          <source>You may have an optional comma before the closing parenthesis of a list literal, so that you can say:</source>
          <target state="translated">목록 리터럴의 닫는 괄호 앞에 선택적 쉼표가있을 수 있으므로 다음과 같이 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94ced856f582ad7ad5a45cb74870b4f4ae27ed8b" translate="yes" xml:space="preserve">
          <source>You may have to add extra libraries as well. Which ones? Perhaps those printed by</source>
          <target state="translated">라이브러리를 추가해야 할 수도 있습니다. 어느 것? 아마</target>
        </trans-unit>
        <trans-unit id="adc5eceb43ab39f0721310d8a087b92c4cf96e19" translate="yes" xml:space="preserve">
          <source>You may have to re-read this entire section a few times...</source>
          <target state="translated">이 전체 섹션을 몇 번 다시 읽어야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e568be51255384d52fb1c41217e7d274f15f0ca" translate="yes" xml:space="preserve">
          <source>You may ignore the error message for the first element of the archive (this doesn't look like a tar archive / skipping to next file...), it's only the directory which will be created automatically anyway.</source>
          <target state="translated">아카이브의 첫 번째 요소에 대한 오류 메시지를 무시할 수 있습니다 (tar 아카이브처럼 보이지 않음 / 다음 파일로 건너 뛰기 ...). 어쨌든 자동으로 생성되는 디렉토리 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="927c6b1abd9425ad341215fb99d87b72f734b089" translate="yes" xml:space="preserve">
          <source>You may intersperse documentation and Perl code within the .pm file. In fact, if you want to use method autoloading, you must do this, as the comment inside the .pm file explains.</source>
          <target state="translated">.pm 파일 내에 문서와 Perl 코드를 삽입 할 수 있습니다. 실제로 메소드 자동로드를 사용하려면 .pm 파일 내의 주석에 설명 된대로이를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="b911c24edf96323dfee0b5a16ac2655f93ba03e8" translate="yes" xml:space="preserve">
          <source>You may lock arrays and hashes as well as scalars. Locking an array, though, will not block subsequent locks on array elements, just lock attempts on the array itself.</source>
          <target state="translated">스칼라뿐만 아니라 배열과 해시를 잠글 수 있습니다. 그러나 배열을 잠그면 배열 요소에 대한 후속 잠금이 차단되지 않고 배열 자체에 대한 잠금 시도 만 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="00344360ec287bdb5274fbd2e88953a8065f329a" translate="yes" xml:space="preserve">
          <source>You may look into the file</source>
          <target state="translated">당신은 파일을 볼 수 있습니다</target>
        </trans-unit>
        <trans-unit id="9516dc740ae77942efcf6e8fd80e5504a8b1fd26" translate="yes" xml:space="preserve">
          <source>You may mail your bug reports (be sure to include full configuration information as output by the myconfig program in the perl source tree, or by &lt;code&gt;perl -V&lt;/code&gt; ) to perlbug@perl.org . If you've succeeded in compiling perl, the &lt;a href=&quot;perlbug&quot;&gt;perlbug&lt;/a&gt; script in the</source>
          <target state="translated">펄 소스 트리에있는 myconfig 프로그램 또는 &lt;code&gt;perl -V&lt;/code&gt; 에 의해 출력 된 전체 구성 정보를 포함하여 버그 보고서 를 perlbug@perl.org로 우송 할 수 있습니다. perl을 성공적으로 컴파일했다면, &lt;a href=&quot;perlbug&quot;&gt;perlbug&lt;/a&gt; 스크립트는</target>
        </trans-unit>
        <trans-unit id="9b598b6ebd49a9a2c8435acfea60cd639dc39cf9" translate="yes" xml:space="preserve">
          <source>You may need the following GNU programs in order to install perl:</source>
          <target state="translated">perl을 설치하려면 다음 GNU 프로그램이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65000230f7491853635f8932fbc750e90e8f3c2d" translate="yes" xml:space="preserve">
          <source>You may need to be</source>
          <target state="translated">당신은해야 할 수도 있습니다</target>
        </trans-unit>
        <trans-unit id="64a7e3cbbe6d605d5c662e6d4594cef6c6e25ffe" translate="yes" xml:space="preserve">
          <source>You may need to carry out some system configuration tasks before running the Configure script for Perl.</source>
          <target state="translated">Perl에 대한 구성 스크립트를 실행하기 전에 일부 시스템 구성 태스크를 수행해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d10056deec90cd668c3f12e0f304b01dde73621d" translate="yes" xml:space="preserve">
          <source>You may need to make this change to scripts written for a Unix system which expect that after a call to &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt;, no files with the names passed to &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; will exist. (Note: This can be changed at compile time; if you &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Config&lt;/code&gt; and &lt;code&gt;$Config{'d_unlink_all_versions'}&lt;/code&gt; is &lt;code&gt;define&lt;/code&gt; , then &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; will delete all versions of a file on the first call.)</source>
          <target state="translated">당신의 호출 후 기대 유닉스 시스템을 위해 작성된 스크립트에이 변경해야 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; , 이름과 어떤 파일이 전달되지 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 존재하는 것이다. (참고 : 이것은 컴파일 타임에 변경 될 수 있습니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Config&lt;/code&gt; 를 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하고 &lt;code&gt;$Config{'d_unlink_all_versions'}&lt;/code&gt; 가 &lt;code&gt;define&lt;/code&gt; 이면 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 는 첫 번째 호출에서 파일의 모든 버전을 삭제합니다.)</target>
        </trans-unit>
        <trans-unit id="3ec14405f03df7cdb78bb123848d4a14d07a8d45" translate="yes" xml:space="preserve">
          <source>You may not (usefully) use a reference as the key to a hash. It will be converted into a string:</source>
          <target state="translated">참조를 해시의 키로 (유용하게) 사용할 수 없습니다. 문자열로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="d8a434e0ce88a99bf8a5488e4b0fad4981c52cd7" translate="yes" xml:space="preserve">
          <source>You may not even need to write the module. Check whether it's already been done in Perl, and avoid re-inventing the wheel unless you have a good reason.</source>
          <target state="translated">모듈을 작성할 필요조차 없습니다. 이미 Perl에서 수행되었는지 확인하고 적절한 이유가 없으면 휠을 다시 발명하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="936986b9e470ced1f7fdf65dd9ad838a32d13386" translate="yes" xml:space="preserve">
          <source>You may not use data derived from outside your program to affect something else outside your program--at least, not by accident. All command line arguments, environment variables, locale information (see &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;), results of certain system calls (&lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/readlink&quot;&gt;readlink()&lt;/a&gt;&lt;/code&gt;, the variable of &lt;code&gt;&lt;a href=&quot;functions/shmread&quot;&gt;shmread()&lt;/a&gt;&lt;/code&gt;, the messages returned by &lt;code&gt;&lt;a href=&quot;functions/msgrcv&quot;&gt;msgrcv()&lt;/a&gt;&lt;/code&gt;, the password, gcos and shell fields returned by the &lt;code&gt;getpwxxx()&lt;/code&gt; calls), and all file input are marked as &quot;tainted&quot;. Tainted data may not be used directly or indirectly in any command that invokes a sub-shell, nor in any command that modifies files, directories, or processes, &lt;b&gt;with the following exceptions&lt;/b&gt;:</source>
          <target state="translated">프로그램 외부에서 파생 된 데이터를 사용하여 프로그램 외부의 다른 것에 영향을 미쳐서는 안됩니다. 모든 명령 행 인수, 환경 변수, 로케일 정보 ( &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; 참조 ), 특정 시스템 호출 결과 ( &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/readlink&quot;&gt;readlink()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/shmread&quot;&gt;shmread()&lt;/a&gt;&lt;/code&gt; 변수 , &lt;code&gt;&lt;a href=&quot;functions/msgrcv&quot;&gt;msgrcv()&lt;/a&gt;&lt;/code&gt; 리턴 한 메시지 , 비밀번호, gcos 및 쉘) &lt;code&gt;getpwxxx()&lt;/code&gt; 호출에 의해 반환되는 필드 ) 및 모든 파일 입력은 &quot;오염 된&quot;것으로 표시됩니다. &lt;b&gt;다음과 같은 예외를 제외&lt;/b&gt; 하고 하위 쉘을 호출하는 명령이나 파일, 디렉토리 또는 프로세스를 수정하는 명령에서 오염 된 데이터를 직접 또는 간접적으로 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="656cab64db0943d80c2c347bdd21c8a07c645dc2" translate="yes" xml:space="preserve">
          <source>You may once in a while try a &quot;make microperl&quot; to see whether we can still compile Perl with just the bare minimum of interfaces. (See README.micro.)</source>
          <target state="translated">때때로 &quot;make microperl&quot;을 시도하여 최소한의 인터페이스만으로 Perl을 컴파일 할 수 있는지 확인할 수 있습니다. (README.micro 참조)</target>
        </trans-unit>
        <trans-unit id="67acb9777380059ff280be22d8c3f8940dae8cc7" translate="yes" xml:space="preserve">
          <source>You may or may not choose to follow this usage. But never write &quot;PERL&quot;, because perl is not an acronym.</source>
          <target state="translated">이 사용법을 따르거나 선택하지 않을 수 있습니다. 그러나 perl은 약어가 아니므로 &quot;PERL&quot;을 쓰지 마십시오.</target>
        </trans-unit>
        <trans-unit id="613fbbe8af8f9b1517992c7dc5a2a0283f5a8c13" translate="yes" xml:space="preserve">
          <source>You may override this as you like; Maketext doesn't use it for anything.</source>
          <target state="translated">당신이 원하는대로 이것을 무시할 수 있습니다; Maketext는 아무것도 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="471b54cb9da3fd2429477493f77011df7439603d" translate="yes" xml:space="preserve">
          <source>You may run into memory limits, in which case you should use the -Xmx option:</source>
          <target state="translated">메모리 제한이 발생할 수 있습니다.이 경우 -Xmx 옵션을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="2b87668ec2b109de55eff18c1a93548bfc928cdb" translate="yes" xml:space="preserve">
          <source>You may see a message about errors while extracting</source>
          <target state="translated">추출하는 동안 오류에 대한 메시지가 표시 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="567b2cee3d4edcc53c5dd10d0ae801a480e80721" translate="yes" xml:space="preserve">
          <source>You may see some messages during Configure that seem suspicious.</source>
          <target state="translated">구성 중에 의심스러운 일부 메시지가 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d40b88fd93e71db6719630cc623bcd6de5e08cd" translate="yes" xml:space="preserve">
          <source>You may see the term &quot;invariant&quot; character or code point. This simply means that the character has the same numeric value and representation when encoded in UTF-8 (or UTF-EBCDIC) as when not. (Note that this is a very different concept from &lt;a href=&quot;#The-13-variant-characters&quot;&gt;The 13 variant characters&lt;/a&gt; mentioned above. Careful prose will use the term &quot;UTF-8 invariant&quot; instead of just &quot;invariant&quot;, but most often you'll see just &quot;invariant&quot;.) For example, the ordinal value of &quot;A&quot; is 193 in most EBCDIC code pages, and also is 193 when encoded in UTF-EBCDIC. All UTF-8 (or UTF-EBCDIC) variant code points occupy at least two bytes when encoded in UTF-8 (or UTF-EBCDIC); by definition, the UTF-8 (or UTF-EBCDIC) invariant code points are exactly one byte whether encoded in UTF-8 (or UTF-EBCDIC), or not. (By now you see why people typically just say &quot;UTF-8&quot; when they also mean &quot;UTF-EBCDIC&quot;. For the rest of this document, we'll mostly be casual about it too.) In ASCII UTF-8, the code points corresponding to the lowest 128 ordinal numbers (0 - 127: the ASCII characters) are invariant. In UTF-EBCDIC, there are 160 invariant characters. (If you care, the EBCDIC invariants are those characters which have ASCII equivalents, plus those that correspond to the C1 controls (128 - 159 on ASCII platforms).)</source>
          <target state="translated">&quot;불변&quot;문자 또는 코드 포인트라는 용어가 표시 될 수 있습니다. 이는 문자가 UTF-8 (또는 UTF-EBCDIC)로 인코딩 될 때 문자가 숫자 값과 표현이 같지 않다는 것을 의미합니다. (이것은 &lt;a href=&quot;#The-13-variant-characters&quot;&gt;13 개의 변형 문자&lt;/a&gt; 와는 매우 다른 개념입니다 .위에 언급했듯이. 신중한 산문은 &quot;불변&quot;대신 &quot;UTF-8 불변&quot;이라는 용어를 사용하지만 대부분 &quot;불변&quot;만 표시됩니다.) 예를 들어 대부분의 EBCDIC 코드 페이지에서 &quot;A&quot;의 서수 값은 193입니다. UTF-EBCDIC으로 인코딩 된 경우 193입니다. 모든 UTF-8 (또는 UTF-EBCDIC) 변형 코드 포인트는 UTF-8 (또는 UTF-EBCDIC)로 인코딩 된 경우 2 바이트 이상을 차지합니다. 정의상 UTF-8 (또는 UTF-EBCDIC)의 불변 코드 포인트는 UTF-8 (또는 UTF-EBCDIC)로 인코딩되었는지 여부에 관계없이 정확히 1 바이트입니다. (이제 사람들이 &quot;UTF-EBCDIC&quot;을 의미 할 때 일반적으로 &quot;UTF-8&quot;이라고 말하는 이유를 알 수 있습니다.이 문서의 나머지 부분에서는 대부분 우연히 설명 할 것입니다. ASCII UTF-8에서 가장 낮은 128 개의 서수 (0-127 : ASCII 문자)에 해당하는 코드 포인트는 변하지 않습니다.UTF-EBCDIC에는 160 개의 고정 문자가 있습니다. (주의하면 EBCDIC 불변 값은 ASCII와 동등한 문자와 C1 제어에 해당하는 문자입니다 (ASCII 플랫폼의 경우 128-159).)</target>
        </trans-unit>
        <trans-unit id="fa093d809cde8bd253ba564171319f316c1ecb65" translate="yes" xml:space="preserve">
          <source>You may set the &lt;code&gt;dw_size&lt;/code&gt; option to limit the amount of data that can be saved in the deferred write buffer. This limit may not exceed the total memory limit. For example, if you set &lt;code&gt;dw_size&lt;/code&gt; to 1000 and &lt;code&gt;memory&lt;/code&gt; to 2500, that means that no more than 1000 bytes of deferred writes will be saved up. The space available for the read cache will vary, but it will always be at least 1500 bytes (if the deferred write buffer is full) and it could grow as large as 2500 bytes (if the deferred write buffer is empty.)</source>
          <target state="translated">지연 쓰기 버퍼에 저장할 수있는 데이터의 양을 제한하기 위해 &lt;code&gt;dw_size&lt;/code&gt; 옵션을 설정할 수 있습니다. 이 제한은 총 메모리 제한을 초과 할 수 없습니다. 예를 들어, &lt;code&gt;dw_size&lt;/code&gt; 를 1000으로 설정 하고 &lt;code&gt;memory&lt;/code&gt; 를 2500으로 설정하면 지연된 쓰기가 1000 바이트 이하로 저장됩니다. 읽기 캐시에 사용 가능한 공간은 다양하지만 항상 최소 1500 바이트 (지연된 쓰기 버퍼가 가득 찬 경우)이고 2500 바이트 (지연된 쓰기 버퍼가 비어있는 경우)만큼 커질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbe802847d2e9437afa3772a7f3ed12ac0cb75f5" translate="yes" xml:space="preserve">
          <source>You may use any combination of these three values 'SUCCESS','FAILURE','DELAY' in the anonymous array reference as defined by RFC3461 (see &lt;a href=&quot;http://www.ietf.org/rfc/rfc3461.txt&quot;&gt;http://www.ietf.org/rfc/rfc3461.txt&lt;/a&gt; for more information. Note: quotations in this topic from same.).</source>
          <target state="translated">RFC3461에 의해 정의 된 익명 배열 참조에서이 세 가지 값 'SUCCESS', 'FAILURE', 'DELAY'의 조합을 사용할 수 있습니다 ( 자세한 내용 은 &lt;a href=&quot;http://www.ietf.org/rfc/rfc3461.txt&quot;&gt;http://www.ietf.org/rfc/rfc3461.txt&lt;/a&gt; 참조) . 참고 :이 주제의 인용문은 동일합니다.).</target>
        </trans-unit>
        <trans-unit id="3726ab64bc777be024735266d80e288f34e7bd83" translate="yes" xml:space="preserve">
          <source>You may use the &lt;code&gt;mv&lt;/code&gt; alias for this function in the same way that you may use the &lt;code&gt;cp&lt;/code&gt; alias for &lt;code&gt;copy&lt;/code&gt; .</source>
          <target state="translated">당신은 사용할 수 있습니다 &lt;code&gt;mv&lt;/code&gt; 당신이 사용할 수있는 동일한 방법으로이 기능에 대한 별칭을 &lt;code&gt;cp&lt;/code&gt; 대한 별칭을 &lt;code&gt;copy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9368b724095114d596f9a9bbd047855f785492a1" translate="yes" xml:space="preserve">
          <source>You may use the syntax &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; File::Copy &quot;cp&quot;&lt;/code&gt; to get at the &lt;code&gt;cp&lt;/code&gt; alias for this function. The syntax is</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; File::Copy &quot;cp&quot;&lt;/code&gt; 구문을 사용 하여이 함수 의 &lt;code&gt;cp&lt;/code&gt; 별명 을 얻을 수 있습니다. 문법은</target>
        </trans-unit>
        <trans-unit id="2ef4fe61a399da32f9cc97283defa049459439a2" translate="yes" xml:space="preserve">
          <source>You may want to configure something like</source>
          <target state="translated">다음과 같은 것을 구성하고 싶을 수도 있습니다</target>
        </trans-unit>
        <trans-unit id="274166c866cd17a4a70da3e9dd16359e3df50e0e" translate="yes" xml:space="preserve">
          <source>You may want to use the &lt;code&gt;&lt;a href=&quot;perlrecharclass#Digits&quot;&gt;/\d/&lt;/a&gt;&lt;/code&gt; construct instead.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;perlrecharclass#Digits&quot;&gt;/\d/&lt;/a&gt;&lt;/code&gt; 구문을 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3d3a0b34238678a39ac71745f1262bf0f4700e24" translate="yes" xml:space="preserve">
          <source>You may want to use the &lt;code&gt;&lt;a href=&quot;perlrecharclass#Whitespace&quot;&gt;/\s/&lt;/a&gt;&lt;/code&gt; construct instead.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;perlrecharclass#Whitespace&quot;&gt;/\s/&lt;/a&gt;&lt;/code&gt; 구문을 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="30ce0fc76dee65d768e8b8edbb86d17b3ec69cef" translate="yes" xml:space="preserve">
          <source>You may want to use the &lt;code&gt;&lt;a href=&quot;perlrecharclass#Word-characters&quot;&gt;/\w/&lt;/a&gt;&lt;/code&gt; construct instead.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;perlrecharclass#Word-characters&quot;&gt;/\w/&lt;/a&gt;&lt;/code&gt; 구문을 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="599db7e90374e2462ae43e1deb74b5ede6e00ac9" translate="yes" xml:space="preserve">
          <source>You may wish to put your version of perl in the PATH of all users by changing the link</source>
          <target state="translated">링크를 변경하여 펄 버전을 모든 사용자의 경로에 넣을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="a667970ef9d2de2018d0cc9d89b6040168c92e68" translate="yes" xml:space="preserve">
          <source>You might also be interested in using the &lt;a href=&quot;benchmark&quot;&gt;Benchmark&lt;/a&gt; to measure and compare code snippets.</source>
          <target state="translated">&lt;a href=&quot;benchmark&quot;&gt;벤치 마크&lt;/a&gt; 를 사용하여 코드 스 니펫을 측정하고 비교할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f2fb8d4423459616a83c78e11c0c6368281abff5" translate="yes" xml:space="preserve">
          <source>You might also find it more fun to use the standard &lt;a href=&quot;tie/file&quot;&gt;Tie::File&lt;/a&gt; module, or the &lt;a href=&quot;db_file&quot;&gt;DB_File&lt;/a&gt; module's &lt;code&gt;$DB_RECNO&lt;/code&gt; bindings, which allow you to tie an array to a file so that accessing an element of the array actually accesses the corresponding line in the file.</source>
          <target state="translated">표준 &lt;a href=&quot;tie/file&quot;&gt;Tie :: File&lt;/a&gt; 모듈 또는 &lt;a href=&quot;db_file&quot;&gt;DB_File&lt;/a&gt; 모듈의 &lt;code&gt;$DB_RECNO&lt;/code&gt; 바인딩 을 사용하는 것이 더 재미있을 수도 있습니다. 이렇게하면 배열의 요소에 액세스 할 때 실제로 배열의 요소에 액세스 할 수 있습니다. 파일.</target>
        </trans-unit>
        <trans-unit id="e08469744ffe89846f236eef2581143171c3fbcd" translate="yes" xml:space="preserve">
          <source>You might also have loaded that from a function:</source>
          <target state="translated">함수에서로드했을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="95a16ffa9a148d97aba69dab68818a05442a9c0f" translate="yes" xml:space="preserve">
          <source>You might also see the terms &lt;b&gt;getter&lt;/b&gt; and &lt;b&gt;setter&lt;/b&gt;. These are two types of accessors. A getter gets the attribute's value, while a setter sets it. Another term for a setter is &lt;b&gt;mutator&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;getter&lt;/b&gt; 및 &lt;b&gt;setter&lt;/b&gt; 라는 용어를 볼 수도 있습니다 . 이들은 두 가지 유형의 접근 자입니다. getter는 속성 값을 가져오고 setter는이를 설정합니다. 세터의 다른 용어는 &lt;b&gt;뮤 테이터입니다&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a6f4008d05ac5a7684642f452fcea99bbe63649d" translate="yes" xml:space="preserve">
          <source>You might also think of closure as a way to write a subroutine template without using eval(). Here's a small example of how closures work:</source>
          <target state="translated">eval ()을 사용하지 않고 서브 루틴 템플릿을 작성하는 방법으로 클로저를 생각할 수도 있습니다. 클로저 작동 방식의 간단한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b07a183cbfa7c2c5ada23e1358bb836c0036ff82" translate="yes" xml:space="preserve">
          <source>You might also want to check out &lt;a href=&quot;perlfaq8#How-do-I-keep-my-own-module%2flibrary-directory%3f&quot;&gt;How do I keep my own module/library directory? in perlfaq8&lt;/a&gt;.</source>
          <target state="translated">또한 체크 아웃 할 수 있습니다 &lt;a href=&quot;perlfaq8#How-do-I-keep-my-own-module%2flibrary-directory%3f&quot;&gt;난 내 자신의 모듈 / 라이브러리 디렉토리를 유지하려면 어떻게합니까? perlfaq8에서&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c9d50c5088a6a6db1dd16f71b5a0b7ad311259d2" translate="yes" xml:space="preserve">
          <source>You might also want to employ anonymous functions for simple signal handlers:</source>
          <target state="translated">간단한 신호 처리기에 익명 함수를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4f0a4c3456aabab2b8397ba18c3d239195efdd9" translate="yes" xml:space="preserve">
          <source>You might also want to have GNU groff for OS/390 installed before running the &quot;make install&quot; step for Perl.</source>
          <target state="translated">Perl에 대해 &quot;make install&quot;단계를 실행하기 전에 OS / 390 용 GNU groff를 설치하기를 원할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fa0f7304d269ada4e265c5dcd91a35489923597" translate="yes" xml:space="preserve">
          <source>You might also want to trap any errors by wrapping an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; block around the whole thing.</source>
          <target state="translated">모든 것을 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 블록으로 감싸서 오류를 잡을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ae14caefeb104abfd32e1ac4b08ddaa6c43442c2" translate="yes" xml:space="preserve">
          <source>You might be tempted to think that deferred writing is like transactions, with &lt;code&gt;flush&lt;/code&gt; as &lt;code&gt;commit&lt;/code&gt; and &lt;code&gt;discard&lt;/code&gt; as &lt;code&gt;rollback&lt;/code&gt; , but it isn't, so don't.</source>
          <target state="translated">당신과 함께, 그 연기 쓰기 트랜잭션처럼 생각하는 유혹 할 수있는 &lt;code&gt;flush&lt;/code&gt; 로 &lt;code&gt;commit&lt;/code&gt; 및 &lt;code&gt;discard&lt;/code&gt; 등의 &lt;code&gt;rollback&lt;/code&gt; 하지만 그렇게하지,하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eadb7f27713b1af6126dec14d8fa3f25be31b545" translate="yes" xml:space="preserve">
          <source>You might be tempted to use &lt;code&gt;$#array + 1&lt;/code&gt; to tell you how many items there are in an array. Don't bother. As it happens, using &lt;code&gt;@array&lt;/code&gt; where Perl expects to find a scalar value (&quot;in scalar context&quot;) will give you the number of elements in the array:</source>
          <target state="translated">&lt;code&gt;$#array + 1&lt;/code&gt; 몇 개의 항목이 있는지 $ # array + 1 을 사용하고 싶을 수도 있습니다 . 귀찮게하지 마십시오. 펄이 스칼라 값 ( &quot;스칼라 컨텍스트에서&quot;)을 찾을 것으로 예상하는 곳에서 &lt;code&gt;@array&lt;/code&gt; 를 사용 하면 배열의 요소 수를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdd5e43c44200a95eaa3aa45d374b3ef4d1b96c7" translate="yes" xml:space="preserve">
          <source>You might consider using just Math::BigInt or Math::BigFloat, since they allow you finer control over what get's done in which module/space. For instance, simple loop counters will be Math::BigInts under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bignum;&lt;/code&gt; and this is slower than keeping them as Perl scalars:</source>
          <target state="translated">Math :: BigInt 또는 Math :: BigFloat 만 사용하면 어떤 모듈 / 공간에서 수행되는 작업을보다 세밀하게 제어 할 수 있으므로 사용하는 것이 좋습니다. 예를 들어 간단한 루프 카운터는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bignum;&lt;/code&gt; 을 &lt;a href=&quot;functions/use&quot;&gt;사용하는&lt;/a&gt; Math :: BigInts입니다 . 그리고 이것은 Perl 스칼라로 유지하는 것보다 느립니다.</target>
        </trans-unit>
        <trans-unit id="602086881bebd3c9c81540dfd1686b9dc1e9a7c1" translate="yes" xml:space="preserve">
          <source>You might expect this to output &quot;12&quot;. In fact, it prints &quot;&amp;lt;&quot;: the ASCII result of treating &quot;|&quot; as a bitwise string operator - that is, the result of treating the operands as the strings &quot;4&quot; and &quot;8&quot; rather than numbers. The fact that numify (&lt;code&gt;0+&lt;/code&gt; ) is implemented but stringify (&lt;code&gt;&quot;&quot;&lt;/code&gt; ) isn't makes no difference since the latter is simply autogenerated from the former.</source>
          <target state="translated">&quot;12&quot;가 출력 될 것으로 예상 할 수 있습니다. 실제로 &quot;&amp;lt;&quot;를 출력합니다 : &quot;|&quot;를 처리 한 ASCII 결과 비트 문자열 연산자-즉 피연산자를 숫자가 아닌 문자열 &quot;4&quot;및 &quot;8&quot;로 처리 한 결과입니다. numify ( &lt;code&gt;0+&lt;/code&gt; )가 구현되었지만 stringify ( &lt;code&gt;&quot;&quot;&lt;/code&gt; )는 전자가 단순히 자동 생성되기 때문에 차이가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ec2b6e72cccd9ea401a92e1c584d3ce729f0ed23" translate="yes" xml:space="preserve">
          <source>You might find these links useful:</source>
          <target state="translated">다음 링크가 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7041884103fb3be2206f9857bdd3e655cde0bf34" translate="yes" xml:space="preserve">
          <source>You might have expected test 3 to fail because it seems to a more general purpose version of test 1. The important difference between them is that test 3 contains a quantifier (&lt;code&gt;\D*&lt;/code&gt; ) and so can use backtracking, whereas test 1 will not. What's happening is that you've asked &quot;Is it true that at the start of $x, following 0 or more non-digits, you have something that's not 123?&quot; If the pattern matcher had let &lt;code&gt;\D*&lt;/code&gt; expand to &quot;ABC&quot;, this would have caused the whole pattern to fail.</source>
          <target state="translated">테스트 3은 좀 더 일반적인 목적의 테스트 1 인 것처럼 보이기 때문에 테스트 3이 실패 할 것으로 예상했을 수 있습니다. 그 사이의 중요한 차이점은 테스트 3에 수량 자 ( &lt;code&gt;\D*&lt;/code&gt; ) 가 포함되어 역 추적을 사용할 수 있지만 테스트 1은 그렇지 않습니다. 무슨 일이 일어나고 있는지 &quot;당신이 $ x의 시작에서 0이 아닌 숫자가 아닌 숫자 다음에 123이 아닌 것을 가지고 있다는 것이 사실입니까?&quot; 패턴 매 처가 &lt;code&gt;\D*&lt;/code&gt; 를 &quot;ABC&quot;로 확장하게 한 경우 전체 패턴이 실패했을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5bd0f9bdd3b3f8f6c3d7920cb7c553cce6d6284" translate="yes" xml:space="preserve">
          <source>You might like to read Mark Jason Dominus's &quot;Suffering From Buffering&quot; at &lt;a href=&quot;http://perl.plover.com/FAQs/Buffering.html&quot;&gt;http://perl.plover.com/FAQs/Buffering.html&lt;/a&gt; .</source>
          <target state="translated">&lt;a href=&quot;http://perl.plover.com/FAQs/Buffering.html&quot;&gt;http://perl.plover.com/FAQs/Buffering.html&lt;/a&gt; 에서 Mark Jason Dominus의 &quot;Suffering From Buffering&quot;을 읽어보십시오 .</target>
        </trans-unit>
        <trans-unit id="d5e0af742e5a24576127c7192de3da3f64667af3" translate="yes" xml:space="preserve">
          <source>You might like to use &lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; to read in a program configuration file. Manual error checking can be done this way:</source>
          <target state="translated">프로그램 구성 파일에서 &lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 를 사용 하여 읽을 수 있습니다 . 다음과 같이 수동 오류 검사를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea3e43e35b42104c2dfdbbb81763643be691010c" translate="yes" xml:space="preserve">
          <source>You might like to use &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; to read in a program configuration file. Manual error checking can be done this way:</source>
          <target state="translated">프로그램 구성 파일에서 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 를 사용 하여 읽을 수 있습니다 . 다음과 같이 수동 오류 검사를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="052100b20ac103ab19054e70ed9a9d17e374ebf5" translate="yes" xml:space="preserve">
          <source>You might love it. You might feel that everyone else needs it. But there might not actually be any real demand for it out there. If you're unsure about the demand your module will have, consider sending out feelers on the &lt;code&gt;comp.lang.perl.modules&lt;/code&gt; newsgroup, or as a last resort, ask the modules list at &lt;code&gt;modules@perl.org&lt;/code&gt; . Remember that this is a closed list with a very long turn-around time - be prepared to wait a good while for a response from them.</source>
          <target state="translated">당신은 그것을 좋아할 것입니다. 다른 사람들이 필요하다고 느낄 수도 있습니다. 그러나 실제로는 실제 수요가 없을 수도 있습니다. 모듈의 요구 사항에 대해 잘 모르는 경우 &lt;code&gt;comp.lang.perl.modules&lt;/code&gt; 뉴스 그룹에서 &lt;code&gt;modules@perl.org&lt;/code&gt; 보내거나 마지막 수단으로 모듈 목록 ( module@perl.org)에 문의하십시오 . 이 답변은 처리 시간이 매우 긴 비공개 목록입니다. 답변을 기다리는 동안 준비를하시기 바랍니다.</target>
        </trans-unit>
        <trans-unit id="169bde04d58834aed9e29a6302664c4d13ccbcd6" translate="yes" xml:space="preserve">
          <source>You might not need all the power of XS. The Inline::C module lets you put C code directly in your Perl source. It handles all the magic to make it work. You still have to learn at least some of the perl API but you won't have to deal with the complexity of the XS support files.</source>
          <target state="translated">XS의 모든 기능이 필요하지 않을 수 있습니다. Inline :: C 모듈을 사용하면 C 코드를 Perl 소스에 직접 넣을 수 있습니다. 그것은 모든 마법을 처리하여 작동시킵니다. 여전히 적어도 일부 perl API를 학습해야하지만 XS 지원 파일의 복잡성을 처리 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="3b031c43f33840adc70b02de47a8fd1daefabaa6" translate="yes" xml:space="preserve">
          <source>You might notice several familiar Perl concepts in this collection of ACM columns from Jon Bentley. The similarity to the title of the major Perl book (which came later) is not completely accidental:</source>
          <target state="translated">Jon Bentley의이 ACM 컬럼 콜렉션에서 몇 가지 친숙한 Perl 개념을 알 수 있습니다. 주요 Perl 책의 제목과 비슷한 점은 나중에 우연히 나오는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="66fdf1bb9d02362c3ab6fa3feaa38bdbfcec77f8" translate="yes" xml:space="preserve">
          <source>You might notice that you could use backticks for much the same effect as opening a pipe for reading:</source>
          <target state="translated">읽을 파이프를 여는 것과 같은 효과를 얻기 위해 백틱을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42704287df9412e9063781246ba069342cd72b32" translate="yes" xml:space="preserve">
          <source>You might notice this when each of the elements of &lt;code&gt;@array&lt;/code&gt; end with a newline. You expect to print one element per line, but notice that every line after the first is indented:</source>
          <target state="translated">&lt;code&gt;@array&lt;/code&gt; 의 각 요소가 줄 바꿈으로 끝나는 경우이를 알 수 있습니다 . 한 줄에 하나의 요소를 인쇄 할 것으로 예상되지만 첫 번째 요소 이후의 모든 줄은 들여 쓰기됩니다.</target>
        </trans-unit>
        <trans-unit id="e3ccde21cef99ed04d4c1fb15da658aad8223bd5" translate="yes" xml:space="preserve">
          <source>You might prefer to go on to &lt;a href=&quot;perllol&quot;&gt;perllol&lt;/a&gt; instead of &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;; it discusses lists of lists and multidimensional arrays in detail. After that, you should move on to &lt;a href=&quot;perldsc&quot;&gt;perldsc&lt;/a&gt;; it's a Data Structure Cookbook that shows recipes for using and printing out arrays of hashes, hashes of arrays, and other kinds of data.</source>
          <target state="translated">당신 은 &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; 대신 &lt;a href=&quot;perllol&quot;&gt;perllol을&lt;/a&gt; 선호한다 ; 목록 및 다차원 배열 목록에 대해 자세히 설명합니다. 그런 다음 &lt;a href=&quot;perldsc&quot;&gt;perldsc&lt;/a&gt; 로 이동해야합니다 . 해시 배열, 해시 배열 및 기타 종류의 데이터를 사용하고 인쇄하는 방법을 보여주는 Data Structure Cookbook입니다.</target>
        </trans-unit>
        <trans-unit id="a6310ecb45c68b753610be852acb876a80aa3c10" translate="yes" xml:space="preserve">
          <source>You might relate this to a fictional 'Translate' module:</source>
          <target state="translated">이것을 가상의 '번역'모듈과 관련시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13ab2e65d93fb0059f6f55ed6a75f22913178d96" translate="yes" xml:space="preserve">
          <source>You might remember &lt;code&gt;ok() or diag()&lt;/code&gt; with the mnemonic &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;() or
&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;()&lt;/code&gt; .</source>
          <target state="translated">니모닉 &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;() or &lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;()&lt;/code&gt; () 또는 &lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt; ()로 &lt;code&gt;ok() or diag()&lt;/code&gt; 를 기억할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="37d4864369383102be2440cd5c5cb4b7987e528b" translate="yes" xml:space="preserve">
          <source>You might sometimes see reference to Rule 1 and Rule 2. Larry's power as Supreme Court is expressed in The Rules:</source>
          <target state="translated">때때로 규칙 1과 규칙 2에 대한 참조를 볼 수 있습니다. 대법원으로서의 래리의 권한은 규칙에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f5b7d1197bc89948add2ed3f352d319d84d2e28b" translate="yes" xml:space="preserve">
          <source>You might try &lt;a href=&quot;encode/guess&quot;&gt;Encode::Guess&lt;/a&gt;, but it has a number of limitations.</source>
          <target state="translated">&lt;a href=&quot;encode/guess&quot;&gt;Encode :: Guess&lt;/a&gt; 시도해 볼 수 있지만 여러 가지 제한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="193b85d5b4fe0e90a0d9c66d7d0b78036e923063" translate="yes" xml:space="preserve">
          <source>You might want to do the same thing for expressing key bindings or the like (since hardwiring &quot;q&quot; as the binding for the function that quits a screen/menu/program is useful only if your language happens to associate &quot;q&quot; with &quot;quit&quot;!)</source>
          <target state="translated">키 바인딩 등을 표현하기 위해 동일한 작업을 수행 할 수도 있습니다 (화면 / 메뉴 / 프로그램을 종료하는 기능의 바인딩이 &quot;q&quot;를 &quot;qt&quot;와 연관시키는 경우에만 유용함). &quot;!)</target>
        </trans-unit>
        <trans-unit id="b5d495d915ce638287be04e211dc9e03d5ac46bf" translate="yes" xml:space="preserve">
          <source>You might want to keep these desktop references close by your keyboard:</source>
          <target state="translated">다음 데스크탑 참조를 키보드로 가까이 두십시오.</target>
        </trans-unit>
        <trans-unit id="0d1eb54f95a4e04b463b84dfe6de9e8067695824" translate="yes" xml:space="preserve">
          <source>You might wonder why &lt;code&gt;'.'&lt;/code&gt; matches everything but &lt;code&gt;&quot;\n&quot;&lt;/code&gt; - why not every character? The reason is that often one is matching against lines and would like to ignore the newline characters. For instance, while the string &lt;code&gt;&quot;\n&quot;&lt;/code&gt; represents one line, we would like to think of it as empty. Then</source>
          <target state="translated">왜 &lt;code&gt;'.'&lt;/code&gt; &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 제외한 모든 문자 와 일치 -왜 모든 문자가 아닌가? 그 이유는 종종 하나가 행과 일치하고 개행 문자를 무시하고 싶어하기 때문입니다. 예를 들어 문자열 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 은 한 줄을 나타내지 만 빈 줄로 생각하고 싶습니다. 그때</target>
        </trans-unit>
        <trans-unit id="e851d081cca3db1538b95133dfa4e2591e66b038" translate="yes" xml:space="preserve">
          <source>You must Configure perl with</source>
          <target state="translated">다음을 사용하여 perl을 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="c18657846c86f19718177ea80036f400e403ff68" translate="yes" xml:space="preserve">
          <source>You must be triply conscious of cross-platform concerns. This usually boils down to using &lt;a href=&quot;file/spec&quot;&gt;File::Spec&lt;/a&gt;, avoiding things like &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; unless absolutely necessary, and not assuming that a given character has a particular ordinal value (code point) or that its UTF-8 representation is composed of particular bytes.</source>
          <target state="translated">크로스 플랫폼 문제를 세 심하게 인식해야합니다. 이것은 일반적으로 &lt;a href=&quot;file/spec&quot;&gt;File :: Spec&lt;/a&gt; 을 사용하여 절대적으로 필요한 경우가 아니라면 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; () 과 같은 것을 피하고 주어진 문자에 특정 서수 값 (코드 포인트)이 있거나 UTF-8 표현이 구성되어 있다고 가정하지 않습니다 특정 바이트.</target>
        </trans-unit>
        <trans-unit id="8daf2a31e4062052794994fb1a77c6bf915b4376" translate="yes" xml:space="preserve">
          <source>You must call &lt;code&gt;plan(...)&lt;/code&gt; once and only once. You should call it in a &lt;code&gt;BEGIN {...}&lt;/code&gt; block, like so:</source>
          <target state="translated">&lt;code&gt;plan(...)&lt;/code&gt; 한 번만 호출해야합니다 . &lt;code&gt;BEGIN {...}&lt;/code&gt; 블록에서 다음과 같이 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0d9b102a51e636379025c1716da72ec7158d144f" translate="yes" xml:space="preserve">
          <source>You must have a plan.</source>
          <target state="translated">계획이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f323bd128da70502b49397ad0f7c4f483197be9e" translate="yes" xml:space="preserve">
          <source>You must have a project base class, which you load, and which you then use as the first argument in the call to YourProjClass-&amp;gt;get_handle(...). It should derive (whether directly or indirectly) from Locale::Maketext. It &lt;b&gt;doesn't matter&lt;/b&gt; how you name this class, although assuming this is the localization component of your Super Mega Program, good names for your project class might be SuperMegaProgram::Localization, SuperMegaProgram::L10N, SuperMegaProgram::I18N, SuperMegaProgram::International, or even SuperMegaProgram::Languages or SuperMegaProgram::Messages.</source>
          <target state="translated">프로젝트베이스 클래스가 있어야하며,로드 한 다음 YourProjClass-&amp;gt; get_handle (...) 호출에서 첫 번째 인수로 사용합니다. Locale :: Maketext에서 (직접 또는 간접적으로) 파생되어야합니다. 그것은 &lt;b&gt;중요하지 않습니다&lt;/b&gt; 이 가정하는 것은 귀하의 슈퍼 메가 프로그램의 현지화 요소이지만 당신은이 클래스의 이름을 지정하는 방법, 프로젝트 클래스에 대한 좋은 이름은 SuperMegaProgram :: 현지화, SuperMegaProgram :: L10N, SuperMegaProgram :: 국제화, SuperMegaProgram 수 있습니다 :: 국제 또는 심지어 SuperMegaProgram :: Languages ​​또는 SuperMegaProgram :: Messages.</target>
        </trans-unit>
        <trans-unit id="739cc975a787be41633b91aa5de71e36b127ddec" translate="yes" xml:space="preserve">
          <source>You must install the &lt;code&gt;Expect&lt;/code&gt; module to use &lt;code&gt;eexpect&lt;/code&gt; . CPAN.pm does not install it for you.</source>
          <target state="translated">&lt;code&gt;eexpect&lt;/code&gt; 를 사용 하려면 &lt;code&gt;Expect&lt;/code&gt; 모듈을 설치해야합니다 . CPAN.pm은이를 설치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="72fde4fbc93c4a749f9096aea6d3bd9a70e80b1d" translate="yes" xml:space="preserve">
          <source>You must install the &lt;code&gt;Expect&lt;/code&gt; module to use &lt;code&gt;expect&lt;/code&gt; . CPAN.pm does not install it for you.</source>
          <target state="translated">당신은 설치해야합니다 &lt;code&gt;Expect&lt;/code&gt; 사용에 모듈을 &lt;code&gt;expect&lt;/code&gt; . CPAN.pm은이를 설치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4490a879ca5d596cdf1f67e2681afb5d54f17c52" translate="yes" xml:space="preserve">
          <source>You must make sure that any paths and path components are properly surrounded with double-quotes if they contain spaces. For example, &lt;code&gt;$potential_libs&lt;/code&gt; could be (literally):</source>
          <target state="translated">경로와 경로 구성 요소에 공백이 포함 된 경우 큰 따옴표로 묶어야합니다. 예를 들어 &lt;code&gt;$potential_libs&lt;/code&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="30c4fd5a99a25cad991844e3c5c4f7509fd399a0" translate="yes" xml:space="preserve">
          <source>You must open your files before you print to them.</source>
          <target state="translated">파일을 인쇄하기 전에 파일을 열어야합니다.</target>
        </trans-unit>
        <trans-unit id="45897939488bd63d927112e2ca64e2fec16238a0" translate="yes" xml:space="preserve">
          <source>You must override the abstract methods as noted above.</source>
          <target state="translated">위에서 언급 한대로 추상 메소드를 대체해야합니다.</target>
        </trans-unit>
        <trans-unit id="2aa81922480ed45c435c4cf0c99c4c4aba3634fc" translate="yes" xml:space="preserve">
          <source>You must use &lt;code&gt;elsif&lt;/code&gt; rather than &lt;code&gt;else if&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;else if&lt;/code&gt; &lt;code&gt;elsif&lt;/code&gt; 대신 elsif 를 사용해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="39c7a78d87a43f543e7180d2370d441ee16c546b" translate="yes" xml:space="preserve">
          <source>You must use an ANSI C compiler to build perl. Perl can be compiled with either Sun's add-on C compiler or with gcc. The C compiler that shipped with SunOS4 will not do.</source>
          <target state="translated">perl을 빌드하려면 ANSI C 컴파일러를 사용해야합니다. Perl은 Sun의 애드온 C 컴파일러 또는 gcc로 컴파일 할 수 있습니다. SunOS4와 함께 제공된 C 컴파일러는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c168b8ed4e8b351eba14fd33d598861cf2969e22" translate="yes" xml:space="preserve">
          <source>You must yourself do any alignment or padding by inserting, for example, enough &lt;code&gt;&quot;x&quot;&lt;/code&gt; es while packing. There is no way for pack() and unpack() to know where characters are going to or coming from, so they handle their output and input as flat sequences of characters.</source>
          <target state="translated">포장하는 동안 충분한 &lt;code&gt;&quot;x&quot;&lt;/code&gt; 를 삽입하여 정렬이나 패딩을 직접해야합니다 . pack ()과 unpack ()은 문자가 어디로 오거나 오는지를 알 수 없으므로 출력 및 입력을 플랫 문자 시퀀스로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="495ba80801ecf71f6944f8f06ac3f6b0ec33f568" translate="yes" xml:space="preserve">
          <source>You need a &quot;make&quot; program to build the sources. If you are using Visual C++ or the Windows SDK tools, nmake will work. Builds using the gcc need dmake.</source>
          <target state="translated">소스를 만들려면 &quot;make&quot;프로그램이 필요합니다. Visual C ++ 또는 Windows SDK 도구를 사용하는 경우 nmake가 작동합니다. gcc를 사용하는 빌드에는 dmake가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="384c0cf5619a59f9ce19e0cd720b3f9bfb700b5a" translate="yes" xml:space="preserve">
          <source>You need a separate perl executable</source>
          <target state="translated">별도의 perl 실행 파일이 필요합니다</target>
        </trans-unit>
        <trans-unit id="aa34c474feea2ebcd51fe52bc61e21c7aa534d7c" translate="yes" xml:space="preserve">
          <source>You need an installed and working gccsdk cross compiler &lt;a href=&quot;http://gccsdk.riscos.info/&quot;&gt;http://gccsdk.riscos.info/&lt;/a&gt; and REXEN &lt;a href=&quot;http://www.cp15.org/programming/&quot;&gt;http://www.cp15.org/programming/&lt;/a&gt;</source>
          <target state="translated">설치 및 작동중인 gccsdk 크로스 컴파일러 &lt;a href=&quot;http://gccsdk.riscos.info/&quot;&gt;http://gccsdk.riscos.info/&lt;/a&gt; 및 REXEN &lt;a href=&quot;http://www.cp15.org/programming/&quot;&gt;http://www.cp15.org/programming/&lt;/a&gt; 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="4caefc1d4e2631b1200ec354d43fce32735ee7c7" translate="yes" xml:space="preserve">
          <source>You need at the very least AmigaOS version 2.0. Recommended is version 3.1.</source>
          <target state="translated">최소한 AmigaOS 버전 2.0이 필요합니다. 버전 3.1이 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="5333f88ac5bf8fd24e224f0d8051b5fec4dfc6b5" translate="yes" xml:space="preserve">
          <source>You need the Unix emulation for AmigaOS, whose most important part is &lt;b&gt;ixemul.library&lt;/b&gt;. For a minimum setup, get the latest versions of the following packages from the Aminet archives ( &lt;a href=&quot;http://www.aminet.net/~aminet/&quot;&gt;http://www.aminet.net/~aminet/&lt;/a&gt; ):</source>
          <target state="translated">AmigaOS에 대한 Unix 에뮬레이션이 필요합니다 . 가장 중요한 부분은 &lt;b&gt;ixemul.library&lt;/b&gt; 입니다. 최소 설정을 위해서는 Aminet 아카이브 ( &lt;a href=&quot;http://www.aminet.net/~aminet/&quot;&gt;http://www.aminet.net/~aminet/&lt;/a&gt; ) 에서 다음 패키지의 최신 버전을 구 하십시오 .</target>
        </trans-unit>
        <trans-unit id="46e89c73cbc6b5dd39fd756e0f6110a1446e5be5" translate="yes" xml:space="preserve">
          <source>You need the following files to build perl (or add new modules):</source>
          <target state="translated">perl을 빌드하거나 새 모듈을 추가하려면 다음 파일이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="9f9c012bcf4380f633cf4f7379c24b96c60ecb4b" translate="yes" xml:space="preserve">
          <source>You need to add either braces or blanks to disambiguate.</source>
          <target state="translated">명확하게하려면 중괄호 또는 공백을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="cd33ddce78ff1c7340f83b621a3b3b7072ee0d07" translate="yes" xml:space="preserve">
          <source>You need to apply the patches in</source>
          <target state="translated">패치를 적용해야합니다</target>
        </trans-unit>
        <trans-unit id="1e3349f1cb25ac13b86ae16e145a0b5decd29f3c" translate="yes" xml:space="preserve">
          <source>You need to correct all the entries which look like file paths (they currently start with &lt;code&gt;f:/&lt;/code&gt;).</source>
          <target state="translated">파일 경로처럼 보이는 모든 항목을 수정해야합니다 (현재 &lt;code&gt;f:/&lt;/code&gt; 로 시작 ).</target>
        </trans-unit>
        <trans-unit id="ac623d9d2638d8e7b4db69f0dfe7d1ff10e6b5e8" translate="yes" xml:space="preserve">
          <source>You need to create a local file or directory handle or a local function.</source>
          <target state="translated">로컬 파일 또는 디렉토리 핸들 또는 로컬 함수를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="f1f5eb114f0c20a6807ea82566cc5f87d3a50a5b" translate="yes" xml:space="preserve">
          <source>You need to fetch the latest perl source (including developers releases). With some probability it is located in</source>
          <target state="translated">최신 펄 소스 (개발자 릴리스 포함)를 가져와야합니다. 약간의 확률로</target>
        </trans-unit>
        <trans-unit id="965f03aeeab996c747b3c012ec9e65e74625b61a" translate="yes" xml:space="preserve">
          <source>You need to give a global variable a temporary value, especially $_.</source>
          <target state="translated">전역 변수에 임시 값, 특히 $ _를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="4566431899ec1f0737bac24e93a9db0aa49d528e" translate="yes" xml:space="preserve">
          <source>You need to have the latest &lt;b&gt;ixemul&lt;/b&gt; (Unix emulation for Amiga) from Aminet.</source>
          <target state="translated">&lt;b&gt;Aminet&lt;/b&gt; 의 최신 &lt;b&gt;ixemul&lt;/b&gt; (Amiga 용 Unix 에뮬레이션)이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="a7ac6e008f84ae7c7059b678b8182fe611763a32" translate="yes" xml:space="preserve">
          <source>You need to have the latest EMX development environment, the full GNU tool suite (gawk renamed to awk, and GNU</source>
          <target state="translated">최신 EMX 개발 환경, 전체 GNU 툴 슈트 (gawk의 이름이 awk, GNU)가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f0226c50fdff6c76ac2211b429b8387e73ade57a" translate="yes" xml:space="preserve">
          <source>You need to have zlib 1.2.1 or better if you want to use the &lt;code&gt;-Merge&lt;/code&gt; option with &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; , &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; and &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;IO::Compress::Gzip&lt;/code&gt; , &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; 및 &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; 와 함께 &lt;code&gt;-Merge&lt;/code&gt; 옵션 을 사용하려면 zlib 1.2.1 이상이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="f7d2bb828dde58ca4350b2c6d38a82848f926212" translate="yes" xml:space="preserve">
          <source>You need to make sure your script is executable, is accessible by the user CGI is running the script under (which is probably not the user account you tested it under), does not rely on any environment variables (like PATH) from the user it isn't running under, and isn't in a location where the CGI server can't find it, basically, more or less. Please see the following for more information:</source>
          <target state="translated">스크립트가 실행 가능한지, 사용자가 액세스 할 수 있는지 확인해야합니다. CGI가 아래에서 스크립트를 실행하고있을 것입니다 (아마도 테스트 한 사용자 계정이 아닐 수도 있음). 사용자의 PATH와 같은 환경 변수에 의존하지 않습니다. CGI 서버가 기본적으로 어느 정도 찾을 수없는 위치에서 실행되고 있지 않습니다. 자세한 내용은 다음을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="28dffbeaeb79cbefc3a6182c3945facf9e0c58d9" translate="yes" xml:space="preserve">
          <source>You need to pass references to these objects. See &lt;a href=&quot;perlsub#Pass-by-Reference&quot;&gt;Pass by Reference in perlsub&lt;/a&gt; for this particular question, and &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; for information on references.</source>
          <target state="translated">이러한 객체에 대한 참조를 전달해야합니다. 참조 &lt;a href=&quot;perlsub#Pass-by-Reference&quot;&gt;perlsub 참조로 패스를&lt;/a&gt; 이 특정 질문에 대해, 그리고 &lt;a href=&quot;perlref&quot;&gt;perlref를&lt;/a&gt; 참조에 대한 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="f3725b76142cf0ba93578fc0f4b37b143a50c105" translate="yes" xml:space="preserve">
          <source>You need to perform the same general operations on related types of data, but with slight variations depending on the specific type of data the operations are applied to.</source>
          <target state="translated">관련 데이터 유형에 대해 동일한 일반 작업을 수행해야하지만 작업이 적용되는 특정 데이터 유형에 따라 약간의 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="eca7b2277d21c0c8eb2a5172b673ea24b48da4eb" translate="yes" xml:space="preserve">
          <source>You need to use &lt;code&gt;sv_magicext&lt;/code&gt; to add magic to SvREADONLY SVs and also to add more than one instance of the same 'how'.</source>
          <target state="translated">SvREADONLY SV에 마법을 추가하고 동일한 '방법'의 둘 이상의 인스턴스를 추가 하려면 &lt;code&gt;sv_magicext&lt;/code&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="48a3262ccbefb20acd592d55306e17827a38c688" translate="yes" xml:space="preserve">
          <source>You now have better understanding of what a source filter is, and you might even have a possible use for them. If you feel like playing with source filters but need a bit of inspiration, here are some extra features you could add to the Debug filter.</source>
          <target state="translated">이제 소스 필터가 무엇인지 더 잘 이해하고 있으며이를 사용할 수도 있습니다. 소스 필터로 연주하고 싶지만 약간의 영감이 필요한 경우 디버그 필터에 추가 할 수있는 몇 가지 추가 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="73cbac231eb90b456375cc000b5becdd4bf8f684" translate="yes" xml:space="preserve">
          <source>You probably cannot fix the thing that runs perl, but you can change how perl outputs its warnings by defining a custom warning and die functions.</source>
          <target state="translated">아마도 perl을 실행하는 것을 고칠 수는 없지만 커스텀 경고 및 다이 기능을 정의하여 perl이 경고를 출력하는 방법을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c42726aad22724c022f0c559e39f4d6e8477c11a" translate="yes" xml:space="preserve">
          <source>You probably cannot mix &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; calls, because &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; is often implemented using &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 은 종종 &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 을 사용하여 구현 되므로 &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 호출을 혼합 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="15661abf22e3cef9f933847127ca80cfb4161e88" translate="yes" xml:space="preserve">
          <source>You probably cannot mix &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; calls, because &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; is often implemented using &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 은 종종 &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 을 사용하여 구현 되므로 &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 호출을 혼합 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c6ea02ffa42491538c740d65bba124e60d5ff937" translate="yes" xml:space="preserve">
          <source>You probably expect this code to print the equivalent of</source>
          <target state="translated">이 코드가</target>
        </trans-unit>
        <trans-unit id="d62ac8cab5911278724664b4481b34fb6ef41dfa" translate="yes" xml:space="preserve">
          <source>You probably meant to use &lt;code&gt;$]&lt;/code&gt; instead. &lt;code&gt;$[&lt;/code&gt; is the base for indexing arrays. &lt;code&gt;$]&lt;/code&gt; is the Perl version number in decimal.</source>
          <target state="translated">아마도 &lt;code&gt;$]&lt;/code&gt; 를 대신 사용하려고했을 것입니다 . &lt;code&gt;$[&lt;/code&gt; 는 배열 색인의 기초입니다. &lt;code&gt;$]&lt;/code&gt; 는 Perl 버전 번호 (10 진수)입니다.</target>
        </trans-unit>
        <trans-unit id="fd777891ad8556771da5ce520e6dfb0017006c11" translate="yes" xml:space="preserve">
          <source>You probably shouldn't rely upon the &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn()&lt;/a&gt;&lt;/code&gt; being podded out forever. Not all pod translators are well-behaved in this regard, and perhaps the compiler will become pickier.</source>
          <target state="translated">당신은 아마 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn()&lt;/a&gt;&lt;/code&gt; 이 영원히 사라지는 것에 의존해서는 안됩니다 . 모든 포드 번역가가 이와 관련하여 잘 작동하는 것은 아니며 컴파일러가 더 까다로워 질 것입니다.</target>
        </trans-unit>
        <trans-unit id="f7e43d034a25f1af2139047ca7966917ab4cd1dd" translate="yes" xml:space="preserve">
          <source>You probably want to use one of the assortment of wrappers, such as &lt;code&gt;SvSetSV&lt;/code&gt; , &lt;code&gt;SvSetSV_nosteal&lt;/code&gt; , &lt;code&gt;SvSetMagicSV&lt;/code&gt; and &lt;code&gt;SvSetMagicSV_nosteal&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;SvSetSV&lt;/code&gt; , &lt;code&gt;SvSetSV_nosteal&lt;/code&gt; , &lt;code&gt;SvSetMagicSV&lt;/code&gt; 및 &lt;code&gt;SvSetMagicSV_nosteal&lt;/code&gt; 과 같은 다양한 랩퍼 중 하나를 사용 하고 싶을 것 입니다.</target>
        </trans-unit>
        <trans-unit id="5d6ef8cdce7f3fb77e02bca3307aceacf65c4aa9" translate="yes" xml:space="preserve">
          <source>You probably wrote something like this:</source>
          <target state="translated">아마도 다음과 같이 썼을 것입니다 :</target>
        </trans-unit>
        <trans-unit id="39ad4b4dd2e75230f3579c0483b312257f0274c5" translate="yes" xml:space="preserve">
          <source>You really need GNU make to compile this. GNU make ships by default with QNX 4.23, but you can get it from quics for earlier versions.</source>
          <target state="translated">이것을 컴파일하려면 GNU make가 정말로 필요합니다. GNU는 기본적으로 QNX 4.23과 함께 제공되지만 이전 버전에서는 quic에서 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e91eff73482d2359765ffe5506e4ead5d70a7574" translate="yes" xml:space="preserve">
          <source>You really probably want to be using &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; instead, because &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; isn't what most people think of as &quot;local&quot;. See &lt;a href=&quot;perlsub#Private-Variables-via-my()&quot;&gt;Private Variables via my() in perlsub&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 은 대부분의 사람들이 &quot;local&quot;이라고 생각하지 않기 때문에 아마도 대신 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 것을 사용하고 싶을 것입니다. 자세한 내용 &lt;a href=&quot;perlsub#Private-Variables-via-my()&quot;&gt;은 perlsub에서 my ()를 통한 전용 변수를&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="ab88c992626b72f6894fc343016d386fe947c5ce" translate="yes" xml:space="preserve">
          <source>You really probably want to be using &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; instead, because &lt;code&gt;&lt;a href=&quot;local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; isn't what most people think of as &quot;local&quot;. See &lt;a href=&quot;../perlsub#Private-Variables-via-my()&quot;&gt;Private Variables via my() in perlsub&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 은 대부분의 사람들이 &quot;local&quot;이라고 생각하지 않기 때문에 아마도 대신 &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 것을 사용하고 싶을 것입니다. 자세한 내용 &lt;a href=&quot;../perlsub#Private-Variables-via-my()&quot;&gt;은 perlsub에서 my ()를 통한 전용 변수를&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="d15f62d6aa63d728245cd3284fc083f9f68cff93" translate="yes" xml:space="preserve">
          <source>You see, if you call pstruct by its other incybernation, c2ph, you have a code generator that translates C code into perl code! Well, structure and union declarations at least, but that's quite a bit.</source>
          <target state="translated">다른 incybernation, c2ph에 의해 pstruct를 호출하면 C 코드를 펄 코드로 변환하는 코드 생성기가 있습니다! 글쎄, 구조 및 공용체 선언은 적어도, 그러나 그것은 약간입니다.</target>
        </trans-unit>
        <trans-unit id="95f74aa64cd2ea580871d2847f70b2776302bedc" translate="yes" xml:space="preserve">
          <source>You should also &quot;register&quot; your op with the Perl interpreter so that it can produce sensible error and warning messages. Since it is possible to have multiple custom ops within the one &quot;logical&quot; op type &lt;code&gt;OP_CUSTOM&lt;/code&gt; , Perl uses the value of &lt;code&gt;o-&amp;gt;op_ppaddr&lt;/code&gt; to determine which custom op it is dealing with. You should create an &lt;code&gt;XOP&lt;/code&gt; structure for each ppaddr you use, set the properties of the custom op with &lt;code&gt;XopENTRY_set&lt;/code&gt; , and register the structure against the ppaddr using &lt;code&gt;Perl_custom_op_register&lt;/code&gt; . A trivial example might look like:</source>
          <target state="translated">또한 적절한 오류 및 경고 메시지를 생성 할 수 있도록 Perl 인터프리터에 op를 &quot;등록&quot;해야합니다. 하나의 &quot;논리적&quot;op 유형 &lt;code&gt;OP_CUSTOM&lt;/code&gt; 내에 여러 개의 사용자 정의 op가있을 수 있으므로 Perl은 &lt;code&gt;o-&amp;gt;op_ppaddr&lt;/code&gt; 의 값을 사용하여 처리중인 사용자 정의 op를 결정합니다. 당신은 만들어야합니다 &lt;code&gt;XOP&lt;/code&gt; 의 , 당신이 사용하는 각 ppaddr에 대한 구조와 사용자 정의 연산의 속성 설정 &lt;code&gt;XopENTRY_set&lt;/code&gt; 을 하고 사용 ppaddr에 대한 구조 등록 &lt;code&gt;Perl_custom_op_register&lt;/code&gt; 를 . 간단한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8cd501f21ed6c5e9d05fc6e18329636984dc10c8" translate="yes" xml:space="preserve">
          <source>You should also check out the Frequently Asked Questions list in comp.unix.* for things like this: the answer is essentially the same. It's very system-dependent. Here's one solution that works on BSD systems:</source>
          <target state="translated">또한 comp.unix. *의 자주 묻는 질문 (FAQ) 목록에서 다음과 같은 사항을 확인해야합니다. 대답은 본질적으로 동일합니다. 매우 시스템에 따라 다릅니다. BSD 시스템에서 작동하는 솔루션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f04dff0eea092cd0ec8988c859db7bf95d5caa53" translate="yes" xml:space="preserve">
          <source>You should also check your modules, and upgrade them if necessary. For example, HTML::Entities requires version &amp;gt;= 1.32 to function correctly, even though the changelog is silent about this.</source>
          <target state="translated">또한 모듈을 확인하고 필요한 경우 업그레이드하십시오. 예를 들어, HTML :: Entities는 changelog에 대해 침묵하더라도 올바르게 작동하려면 버전&amp;gt; 1.32가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1bf271b2d5721f863cabe314c6f3ea53dab9ccef" translate="yes" xml:space="preserve">
          <source>You should also look at &lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt; 도 봐야 합니다.</target>
        </trans-unit>
        <trans-unit id="a2a8e7bc27f2427aec43e373a1d93fb28c7dab24" translate="yes" xml:space="preserve">
          <source>You should also take a look at &lt;a href=&quot;perlmodstyle&quot;&gt;perlmodstyle&lt;/a&gt; for best practices in making a module.</source>
          <target state="translated">또한 모듈을 만드는 모범 사례 를 &lt;a href=&quot;perlmodstyle&quot;&gt;보려면 perlmodstyle&lt;/a&gt; 을 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="50caca8ed03bfd57a516ccc3b6dfa215ef520713" translate="yes" xml:space="preserve">
          <source>You should also try to get feedback from people who are already familiar with the module's application domain and the CPAN naming system. Authors of similar modules, or modules with similar names, may be a good place to start, as are community sites like &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.perlmonks.org&quot;&gt;Perl Monks&lt;/a&gt;.</source>
          <target state="translated">또한 모듈의 애플리케이션 도메인 및 CPAN 이름 지정 시스템에 이미 익숙한 사람들로부터 피드백을 받으십시오. &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.perlmonks.org&quot;&gt;Perl Monks&lt;/a&gt; 와 같은 커뮤니티 사이트와 마찬가지로 유사한 모듈 또는 유사한 이름을 가진 모듈의 작성자를 시작하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="6748d5917300372787fdc7a9ff0a6b3a57b1d0d9" translate="yes" xml:space="preserve">
          <source>You should always support a &lt;code&gt;HASH&lt;/code&gt; argument to &lt;code&gt;TIEHASH&lt;/code&gt; that ties the underlying cache so that the user can specify that the cache is also persistent or that it has some other interesting semantics. The example above demonstrates how to do this, as does &lt;code&gt;Memoize::Expire&lt;/code&gt; .</source>
          <target state="translated">기본 캐시를 연결하는 &lt;code&gt;TIEHASH&lt;/code&gt; 에 대한 &lt;code&gt;HASH&lt;/code&gt; 인수를 항상 지원해야 사용자가 캐시가 지속적이거나 다른 흥미로운 의미를 갖도록 지정할 수 있습니다. 위의 예는 &lt;code&gt;Memoize::Expire&lt;/code&gt; 와 같이이를 수행하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="3be69763ec9a168e71d6a325f5feb839520bece8" translate="yes" xml:space="preserve">
          <source>You should attempt older code to fully use</source>
          <target state="translated">완전히 사용하려면 이전 코드를 시도해야합니다</target>
        </trans-unit>
        <trans-unit id="2aa5702baea4b6cbbf8baf7ed5e04e20725d5137" translate="yes" xml:space="preserve">
          <source>You should be aware that it is unsupported, and is not claimed to be fit for any purpose. If your system allows installation of arbitrary locales, you may find the definitions useful as they are, or as a basis for the development of your own locales.</source>
          <target state="translated">지원되지 않으며 어떤 목적에도 적합하지 않다는 것을 알고 있어야합니다. 시스템에서 임의의 로케일 설치를 허용하는 경우 정의가있는 그대로 또는 고유 한 로케일 개발의 기초로 정의가 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3162405a76386caaa175c4a5b3c2a85402c9c86" translate="yes" xml:space="preserve">
          <source>You should be careful about creating mortal variables. Strange things can happen if you make the same value mortal within multiple contexts, or if you make a variable mortal multiple times. Thinking of &quot;Mortalization&quot; as deferred &lt;code&gt;SvREFCNT_dec&lt;/code&gt; should help to minimize such problems. For example if you are passing an SV which you</source>
          <target state="translated">필사자 변수 작성에주의해야합니다. 여러 상황 내에서 동일한 가치를 필사자로 만들거나 변수 필사자를 여러 번 만들면 이상한 일이 발생할 수 있습니다. &quot;Mortalization&quot;을 지연된 &lt;code&gt;SvREFCNT_dec&lt;/code&gt; 로 생각하면 이러한 문제를 최소화하는 데 도움이됩니다. 예를 들어 SV를 전달하는 경우</target>
        </trans-unit>
        <trans-unit id="f75000df91bba9bce6bbc0dce623bb898fe50b2f" translate="yes" xml:space="preserve">
          <source>You should be very careful when modifying the default values of most special variables described in this document. In most cases you want to localize these variables before changing them, since if you don't, the change may affect other modules which rely on the default values of the special variables that you have changed. This is one of the correct ways to read the whole file at once:</source>
          <target state="translated">이 문서에서 설명하는 대부분의 특수 변수의 기본값을 수정할 때 매우주의해야합니다. 대부분의 경우 이러한 변수를 변경하기 전에 현지화하려고합니다. 변경하지 않으면 변경 한 특수 변수의 기본값에 의존하는 다른 모듈에 영향을 줄 수 있습니다. 이것은 전체 파일을 한 번에 읽는 올바른 방법 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="949c1f70059f0d92507bf8500b354d7dab533cd7" translate="yes" xml:space="preserve">
          <source>You should by now have had a look at &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;, which tells you about Perl's internal variable types: SVs, HVs, AVs and the rest. If not, do that now.</source>
          <target state="translated">지금까지 &lt;a href=&quot;perlguts&quot;&gt;perlguts를&lt;/a&gt; 살펴 보았는데 Perl의 내부 변수 유형 (SV, HV, AV 및 나머지)에 대해 알려줍니다. 그렇지 않다면 지금 그렇게하십시오.</target>
        </trans-unit>
        <trans-unit id="1de8c82aa4b462c346cc4f7308a916f25f4fef57" translate="yes" xml:space="preserve">
          <source>You should have received a copy of the GNU General Public License along with this library program; it should be in the file &lt;code&gt;COPYING&lt;/code&gt; . If not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA</source>
          <target state="translated">이 라이브러리 프로그램과 함께 GNU General Public License의 사본을 받았어야합니다. &lt;code&gt;COPYING&lt;/code&gt; 파일에 있어야합니다 . 그렇지 않은 경우 미국 MA 02110-1301, Boston, 5 층, Franklin Street 51, Free Software Foundation, Inc.에 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="e47e81623eb986394886e54e85f1183c3a98df4e" translate="yes" xml:space="preserve">
          <source>You should in general be leery of using functions that could potentially return lists in scalar context without explicitly stating such. This would be clearer to the casual reader:</source>
          <target state="translated">일반적으로 명시 적으로 언급하지 않고 스칼라 컨텍스트에서 잠재적으로 목록을 리턴 할 수있는 함수를 사용하는 것에 대해주의해야합니다. 이것은 일반 독자에게는 더 분명 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="f07911b4c8d126039388d13cb35130da1027b105" translate="yes" xml:space="preserve">
          <source>You should make a module out of any code that you think is going to be useful to others. Anything that's likely to fill a hole in the communal library and which someone else can slot directly into their program. Any part of your code which you can isolate and extract and plug into something else is a likely candidate.</source>
          <target state="translated">다른 사람들에게 유용하다고 생각되는 코드로 모듈을 만들어야합니다. 공동 라이브러리의 구멍을 채울 가능성이 있고 다른 사람이 직접 프로그램에 슬롯을 넣을 수있는 모든 것. 코드에서 분리하고 추출하여 다른 것을 연결할 수있는 부분은 아마도 후보입니다.</target>
        </trans-unit>
        <trans-unit id="040633d0da585780031086722446751b04946152" translate="yes" xml:space="preserve">
          <source>You should neither care about nor depend on the internal representation; it might change without notice. Use &lt;b&gt;ONLY&lt;/b&gt; method calls like &lt;code&gt;$x-&amp;gt;sign();&lt;/code&gt; instead relying on the internal representation.</source>
          <target state="translated">내부 표현에 신경 쓰거나 의존해서는 안됩니다. 예고없이 변경 될 수 있습니다. &lt;code&gt;$x-&amp;gt;sign();&lt;/code&gt; 과 같은 메소드 호출 &lt;b&gt;만&lt;/b&gt; 사용하십시오 . 대신 내부 표현에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="8e48507edb3519e34f20c7e3d955b48a4ed82ad2" translate="yes" xml:space="preserve">
          <source>You should normally only add directories to @INC. If you need to delete directories from @INC take care to only delete those which you added yourself or which you are certain are not needed by other modules in your script. Other modules may have added directories which they need for correct operation.</source>
          <target state="translated">일반적으로 @INC에만 디렉토리를 추가해야합니다. @INC에서 디렉토리를 삭제해야하는 경우 직접 추가했거나 스크립트의 다른 모듈에 필요하지 않은 디렉토리 만 삭제하십시오. 다른 모듈은 올바른 작동에 필요한 디렉토리를 추가했을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="693cc772a08fe2cee68cbfc24c2a6625d73c01c6" translate="yes" xml:space="preserve">
          <source>You should not depend on the internal format, all accesses must go through accessor methods. E.g. looking at $x-&amp;gt;{sign} is not a bright idea since there is no guaranty that the object in question has such a hashkey, nor is a hash underneath at all.</source>
          <target state="translated">내부 형식에 의존해서는 안되며 모든 액세스는 액세서 메소드를 거쳐야합니다. 예를 들어 $ x-&amp;gt; {sign}을 보는 것은 문제의 객체가 그러한 해시 키를 가지고 있거나 전혀 해시가 없다는 보장이 없기 때문에 밝은 생각이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="d13d5397797f2275509831750bfac02171b7d4f3" translate="yes" xml:space="preserve">
          <source>You should not depend on the internal format, all accesses must go through accessor methods. E.g. looking at $x-&amp;gt;{sign} is not a good idea since there is no guaranty that the object in question has such a hash key, nor is a hash underneath at all.</source>
          <target state="translated">내부 형식에 의존해서는 안되며 모든 액세스는 액세서 메소드를 거쳐야합니다. 예를 들어 $ x-&amp;gt; {sign}을 보는 것은 문제의 객체가 그러한 해시 키를 가지고 있지 않다는 보장이 없기 때문에 좋은 생각이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6e8d21cc64f2bc1e9d1ef661a62db1a121e53da8" translate="yes" xml:space="preserve">
          <source>You should not even &lt;b&gt;want&lt;/b&gt; to use</source>
          <target state="translated">당신은 사용 &lt;b&gt;하고 싶지&lt;/b&gt; 않아야</target>
        </trans-unit>
        <trans-unit id="675338533405ed3338eef5ef4ee169f82f2ec7e6" translate="yes" xml:space="preserve">
          <source>You should not use perl's malloc if you are building with gcc. There are reports of core dumps, especially in the PDL module. The problem appears to go away under -DDEBUGGING, so it has been difficult to track down. Sun's compiler appears to be okay with or without perl's malloc. [XXX further investigation is needed here.]</source>
          <target state="translated">gcc로 빌드하는 경우 perl의 malloc을 사용하지 않아야합니다. 특히 PDL 모듈에서 코어 덤프에 대한 보고서가 있습니다. -DDEBUGGING에서 문제가 사라져서 추적하기가 어렵습니다. 썬의 컴파일러는 펄의 malloc이 있거나없는 것으로 보인다. [XXX 추가 조사가 필요합니다.]</target>
        </trans-unit>
        <trans-unit id="13af3135f590e4077444d490629ef8daddd658bc" translate="yes" xml:space="preserve">
          <source>You should note that, if it is necessary to store the SV (&lt;code&gt;name&lt;/code&gt; in the example above) which corresponds to the Perl subroutine so that it can be used later in the program, it not enough just to store a copy of the pointer to the SV. Say the code above had been like this:</source>
          <target state="translated">나중에 프로그램에서 사용할 수 있도록 Perl 서브 루틴에 해당하는 SV ( 위의 예에서 &lt;code&gt;name&lt;/code&gt; 를 저장해야하는 경우 포인터의 사본을 저장하는 것만으로는 충분하지 않습니다. SV. 위의 코드가 다음과 같다고 가정 해보십시오.</target>
        </trans-unit>
        <trans-unit id="30d7be701b66af4a13ce23ca4f4637ef46685c93" translate="yes" xml:space="preserve">
          <source>You should probably be using lexical variables anyway, although the issue is the same here:</source>
          <target state="translated">어쨌든 어휘 변수를 사용해야 할 수도 있지만 문제는 여기에서 동일합니다.</target>
        </trans-unit>
        <trans-unit id="54112594f7721aec0b526a825c8c553a794597d2" translate="yes" xml:space="preserve">
          <source>You should say</source>
          <target state="translated">당신은 말해야</target>
        </trans-unit>
        <trans-unit id="5ae04df28b1ca8233ad4f14017b75003d4a4c0fc" translate="yes" xml:space="preserve">
          <source>You should seldom if ever use &lt;code&gt;0644&lt;/code&gt; as argument to &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;, because that takes away the user's option to have a more permissive umask. Better to omit it. See the perlfunc(1) entry on &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; for more on this.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 의 인수로 &lt;code&gt;0644&lt;/code&gt; 를 사용하는 경우는 거의 없습니다 . 더 허용 가능한 umask를 갖기위한 사용자의 옵션을 제거하기 때문입니다. 생략하는 것이 좋습니다. 이에 대한 자세한 내용은 &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 의 perlfunc (1) 항목을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5da0398cef906098b3aedb900161f9013fc9dbe" translate="yes" xml:space="preserve">
          <source>You should seldom if ever use &lt;code&gt;0644&lt;/code&gt; as argument to &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;, because that takes away the user's option to have a more permissive umask. Better to omit it. See the perlfunc(1) entry on &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; for more on this.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 의 인수로 &lt;code&gt;0644&lt;/code&gt; 를 사용하는 경우는 거의 없습니다 . 더 허용 가능한 umask를 갖기위한 사용자의 옵션을 제거하기 때문입니다. 생략하는 것이 좋습니다. 이에 대한 자세한 내용은 &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 의 perlfunc (1) 항목을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="93291955e6753d9b28d9290f1f843ab314e860d1" translate="yes" xml:space="preserve">
          <source>You should take great pains to try to pass the function the type of variable it wants, when possible. It will save you a lot of trouble in the long run.</source>
          <target state="translated">가능하면 함수에 원하는 변수 유형을 전달하기 위해 많은 노력을 기울여야합니다. 장기적으로 많은 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="12e9cbf7ef859529e7aa6ad559377e6f6b1073a2" translate="yes" xml:space="preserve">
          <source>You should think long and hard about why you need everything loaded at once. It's just not a scalable solution.</source>
          <target state="translated">한 번에 모든 것을로드해야하는 이유에 대해 길고 열심히 생각해야합니다. 확장 가능한 솔루션이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="60692fdbea6181558282af5a09ad1a91226b0568" translate="yes" xml:space="preserve">
          <source>You should use</source>
          <target state="translated">사용해야합니다</target>
        </trans-unit>
        <trans-unit id="6151ee9c13ae718ea297cb2924721c23869b50eb" translate="yes" xml:space="preserve">
          <source>You should use the &lt;b&gt;-T&lt;/b&gt; flag to enable taint checking (see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;) even if we aren't running setuid or setgid. This is always a good idea for servers or any program run on behalf of someone else (like CGI scripts), because it lessens the chances that people from the outside will be able to compromise your system.</source>
          <target state="translated">setuid 또는 setgid를 실행하지 않는 경우에도 &lt;b&gt;-T&lt;/b&gt; 플래그를 사용하여 오염 검사 ( &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; 참조 ) 를 활성화 해야합니다 . 외부 사용자가 시스템을 손상시킬 수있는 가능성이 줄어들 기 때문에 CGI 스크립트와 같은 다른 사람을 대신하여 실행되는 서버 나 프로그램에는 항상 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c6b52a2caf001c41f2fbe0900c81a2862fac3a04" translate="yes" xml:space="preserve">
          <source>You should use this</source>
          <target state="translated">이것을 사용해야합니다</target>
        </trans-unit>
        <trans-unit id="f980030e1ddd6415377ab007be132a7835310a08" translate="yes" xml:space="preserve">
          <source>You should use this option if you are using UTF-16 and others which linefeed is not $/.</source>
          <target state="translated">UTF-16 및 줄 바꿈이 $ /가 아닌 다른 문자를 사용하는 경우이 옵션을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="db384f65b44d08a41642068cf25462a07360e950" translate="yes" xml:space="preserve">
          <source>You should usually be able to ignore this and just use the module without thinking about deferring. However, special applications may require fine control over which writes are deferred, or may require that all writes be immediate. To disable the autodeferment feature, use</source>
          <target state="translated">일반적으로 이것을 무시하고 지연에 대해 생각하지 않고 모듈을 사용하면됩니다. 그러나 특수 응용 프로그램에서는 쓰기 지연을 정밀하게 제어해야하거나 모든 쓰기를 즉시 수행해야 할 수도 있습니다. 자동 지연 기능을 비활성화하려면</target>
        </trans-unit>
        <trans-unit id="962a252e8053766a043aa7e45b2c62a450a0683c" translate="yes" xml:space="preserve">
          <source>You shouldn't have to care. But you may if your Perl is before 5.14.0 or you haven't specified &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
5.012&lt;/code&gt; (or higher) because otherwise the rules for the code points in the range 128 to 255 are different depending on whether the string they are contained within is in Unicode or not. (See &lt;a href=&quot;perlunicode#When-Unicode-Does-Not-Happen&quot;&gt;When Unicode Does Not Happen in perlunicode&lt;/a&gt;.)</source>
          <target state="translated">신경 쓸 필요는 없습니다. 하지만 당신은 할 수있다 펄은 5.14.0 전에 또는 당신은 지정하지 않은 경우 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; 이상을 인해 여부를 문자열에 따라 다릅니다 128 ~ 255 범위에서 코드 포인트에 대한 그렇지 않으면 규칙 그것들은 유니 코드로되어 있는지 여부에 포함되어 있습니다. &lt;a href=&quot;perlunicode#When-Unicode-Does-Not-Happen&quot;&gt;perlunicode에서 유니 코드가 발생하지 않는 경우를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a8856a657ecb3d97a5c46abba56a556f46cc66ed" translate="yes" xml:space="preserve">
          <source>You shouldn't need to set this variable, since File::Find should now detect such file systems on-the-fly and switch itself to using stat. This works even for parts of your file system, like a mounted CD-ROM.</source>
          <target state="translated">File :: Find는 이러한 파일 시스템을 즉시 감지하고 stat를 사용하여 자체적으로 전환하므로이 변수를 설정할 필요가 없습니다. 이것은 마운트 된 CD-ROM과 같은 파일 시스템의 일부에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="07632dfd399f0ee08d2dcc1bc356caea0fb1fc3a" translate="yes" xml:space="preserve">
          <source>You shouldn't worry about what this format is, because conversion is automatically done when you decode or encode.</source>
          <target state="translated">디코딩 또는 인코딩시 변환이 자동으로 수행되므로이 ​​형식에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1bf2aae490ef3108185dddeac7ace7d36d9b8359" translate="yes" xml:space="preserve">
          <source>You specified a character that has the given plainer way of writing it, and which is also portable to platforms running with different character sets.</source>
          <target state="translated">주어진 명확한 작성 방법을 가지고 있고 다른 문자 세트로 실행되는 플랫폼에 이식 가능한 문자를 지정했습니다.</target>
        </trans-unit>
        <trans-unit id="ba1446898cf703a433f10e50053c48b7c4bd65ea" translate="yes" xml:space="preserve">
          <source>You specify the parameters that will be passed into the XSUB on the line(s) after you declare the function's return value and name. Each input parameter line starts with optional whitespace, and may have an optional terminating semicolon.</source>
          <target state="translated">함수의 반환 값과 이름을 선언 한 후 행에서 XSUB로 전달 될 매개 변수를 지정합니다. 각 입력 매개 변수 행은 선택적 공백으로 시작하며 선택적 종결 세미콜론이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e23d741eb164f1a1d95de07ecc25c6899dd796b" translate="yes" xml:space="preserve">
          <source>You spend lots and lots of money on dedicated hardware, but this is bound to get you talked about.</source>
          <target state="translated">당신은 전용 하드웨어에 많은 돈을 소비하지만, 이것은 당신이 이야기 할 수밖에 없습니다.</target>
        </trans-unit>
        <trans-unit id="e47578a3d656799aa6fd209dfd66ed644e50edb2" translate="yes" xml:space="preserve">
          <source>You then can run the test(s) from your test suite that call &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt;. At this point the output of &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; is safely captured by &lt;a href=&quot;tester&quot;&gt;Test::Builder::Tester&lt;/a&gt; rather than being interpreted as real test output.</source>
          <target state="translated">그런 다음 &lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt; 를 호출하는 테스트 스위트에서 테스트를 실행할 수 있습니다 . 이 시점에서 &lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt; 의 출력은 실제 테스트 출력으로 해석되지 않고 &lt;a href=&quot;tester&quot;&gt;Test :: Builder :: Tester에&lt;/a&gt; 의해 안전하게 캡처됩니다 .</target>
        </trans-unit>
        <trans-unit id="89f392c3f60b78b930a2c99b682f5745b402f97b" translate="yes" xml:space="preserve">
          <source>You tried to use a negative time argument.</source>
          <target state="translated">음의 시간 인수를 사용하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="215da501a4d763185822fdec5710086fea4dd9c5" translate="yes" xml:space="preserve">
          <source>You use an old version of GNU make. See &lt;a href=&quot;#Prerequisites&quot;&gt;Prerequisites&lt;/a&gt;.</source>
          <target state="translated">이전 버전의 GNU make를 사용합니다. &lt;a href=&quot;#Prerequisites&quot;&gt;전제 조건을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="220275358a49875c3abbea24e2340553d9cb4444" translate="yes" xml:space="preserve">
          <source>You use the &lt;code&gt;\G&lt;/code&gt; anchor to start the next match on the same string where the last match left off. The regular expression engine cannot skip over any characters to find the next match with this anchor, so &lt;code&gt;\G&lt;/code&gt; is similar to the beginning of string anchor, &lt;code&gt;^&lt;/code&gt;. The &lt;code&gt;\G&lt;/code&gt; anchor is typically used with the &lt;code&gt;g&lt;/code&gt; flag. It uses the value of &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; as the position to start the next match. As the match operator makes successive matches, it updates &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; with the position of the next character past the last match (or the first character of the next match, depending on how you like to look at it). Each string has its own &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;\G&lt;/code&gt; 앵커를 사용하여 마지막 일치가 중단 된 동일한 문자열에서 다음 일치를 시작합니다. 정규식 엔진은이 앵커와 일치하는 다음 문자를 찾기 위해 문자를 건너 뛸 수 없으므로 &lt;code&gt;\G&lt;/code&gt; 는 문자열 앵커의 시작 인 &lt;code&gt;^&lt;/code&gt; 와 유사합니다 . &lt;code&gt;\G&lt;/code&gt; 앵커는 일반적으로 사용되는 &lt;code&gt;g&lt;/code&gt; 의 플래그. 다음 일치를 시작하는 위치로 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 값을 사용합니다 . 일치 연산자는 연속 일치를 수행하므로 마지막 일치 이후의 다음 문자 위치 (또는 원하는 모양에 따라 다음 일치의 첫 번째 문자 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 로 pos () 를 업데이트합니다 . 각 문자열에는 자체 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc28690a1164ffed63384fc9d48573f0201b1c8c" translate="yes" xml:space="preserve">
          <source>You use the utime() function documented in &lt;a href=&quot;functions/utime&quot;&gt;utime&lt;/a&gt;. By way of example, here's a little program that copies the read and write times from its first argument to all the rest of them.</source>
          <target state="translated">utime에 문서화 된 &lt;a href=&quot;functions/utime&quot;&gt;utime&lt;/a&gt; () 함수를 사용합니다 . 예를 들어, 첫 번째 인수에서 나머지 인수로 읽기 및 쓰기 시간을 복사하는 작은 프로그램이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6636b861a3b2aa1c111b3f0b60ae946532727186" translate="yes" xml:space="preserve">
          <source>You usually can use the value of &lt;code&gt;$^X&lt;/code&gt; to re-invoke an independent copy of the same perl that is currently running, e.g.,</source>
          <target state="translated">일반적으로 &lt;code&gt;$^X&lt;/code&gt; 값을 사용하여 현재 실행중인 동일한 perl의 독립 사본을 다시 호출 할 수 있습니다 ( 예 :</target>
        </trans-unit>
        <trans-unit id="aa6e6cfea08fbea7a5de694a45b0570deb9eda14" translate="yes" xml:space="preserve">
          <source>You usually can't. Memory allocated to lexicals (i.e. my() variables) cannot be reclaimed or reused even if they go out of scope. It is reserved in case the variables come back into scope. Memory allocated to global variables can be reused (within your program) by using undef() and/or delete().</source>
          <target state="translated">당신은 보통 할 수 없습니다. 어휘에 할당 된 메모리 (예 : my () 변수)는 범위를 벗어난 경우에도 회수하거나 재사용 할 수 없습니다. 변수가 다시 범위로 돌아 오면 예약됩니다. 전역 변수에 할당 된 메모리는 undef () 및 / 또는 delete ()를 사용하여 프로그램 내에서 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="654d5925759821a41f7b319f6f5acce1580b7e6a" translate="yes" xml:space="preserve">
          <source>You want to temporarily change just one element of an array or hash.</source>
          <target state="translated">배열 또는 해시의 한 요소 만 임시로 변경하려고합니다.</target>
        </trans-unit>
        <trans-unit id="2ba6881210a4041e425c0b40054f89e605a3c752" translate="yes" xml:space="preserve">
          <source>You will also need to be able to connect over the Internet to the public key servers, like pgp.mit.edu, and their port 11731 (the HKP protocol).</source>
          <target state="translated">또한 인터넷을 통해 pgp.mit.edu와 같은 공개 키 서버 및 해당 포트 11731 (HKP 프로토콜)에 연결할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c62030728cb5bac5bc525932491c14ac0a7adf6d" translate="yes" xml:space="preserve">
          <source>You will also need to download the &quot;Platform SDK&quot; (the &quot;Core SDK&quot; and &quot;MDAC SDK&quot; components are required) for header files, libraries and rc.exe, and &quot;.NET Framework SDK&quot; for more libraries and nmake.exe. Note that the latter (which also includes the free compiler and linker) requires the &quot;.NET Framework Redistributable&quot; to be installed first. This can be downloaded and installed separately, but is included in the &quot;Visual C++ Toolkit 2003&quot; anyway.</source>
          <target state="translated">또한 헤더 파일, 라이브러리 및 rc.exe의 경우 &quot;Platform SDK&quot;( &quot;Core SDK&quot;및 &quot;MDAC SDK&quot;구성 요소가 필요함) 및 추가 라이브러리 및 nmake.exe의 경우 &quot;.NET Framework SDK&quot;를 다운로드해야합니다. . 후자 (무료 컴파일러 및 링커 포함)는 &quot;.NET Framework 재배포 가능 파일&quot;을 먼저 설치해야합니다. 별도로 다운로드하여 설치할 수 있지만 &quot;Visual C ++ Toolkit 2003&quot;에는 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="356f5d0daa70748f28cbf7166d4f341295254619" translate="yes" xml:space="preserve">
          <source>You will also need to download the &quot;Windows SDK&quot; (the &quot;Core SDK&quot; and &quot;MDAC SDK&quot; components are required) for more header files and libraries.</source>
          <target state="translated">더 많은 헤더 파일 및 라이브러리를 보려면 &quot;Windows SDK&quot;( &quot;Core SDK&quot;및 &quot;MDAC SDK&quot;구성 요소가 필요함)를 다운로드해야합니다.</target>
        </trans-unit>
        <trans-unit id="a1a5cfadaa899360662110efdf3739aae4dbc6c1" translate="yes" xml:space="preserve">
          <source>You will encounter this particular error message when you have the &lt;code&gt;strict 'subs'&lt;/code&gt; pragma (or the full strict pragma) in your script. Consider this script:</source>
          <target state="translated">스크립트에 엄격한 &lt;code&gt;strict 'subs'&lt;/code&gt; subs'pragma (또는 전체 엄격한 pragma)가 있으면 이 특정 오류 메시지가 표시됩니다 . 이 스크립트를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="9ef82421bf1d6104efddfdc8565b14c0ddc86aec" translate="yes" xml:space="preserve">
          <source>You will find this behavior is slightly different from that of &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; handlers (which don't suppress the error text, but can instead call &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; again to change it).</source>
          <target state="translated">이 동작은 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 핸들러의 동작과 약간 다릅니다 (에러 텍스트를 억제하지 않고 대신 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 를 다시 호출 하여 변경할 수 있음).</target>
        </trans-unit>
        <trans-unit id="7d85e118af6c81732006143a60990cead4fa03d5" translate="yes" xml:space="preserve">
          <source>You will find this behavior is slightly different from that of &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; handlers (which don't suppress the error text, but can instead call &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; again to change it).</source>
          <target state="translated">이 동작은 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 핸들러의 동작과 약간 다릅니다 (에러 텍스트를 억제하지 않고 대신 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 를 다시 호출 하여 변경할 수 있음).</target>
        </trans-unit>
        <trans-unit id="c01bddfdbad27a7674a351ac148e02cb61a266a6" translate="yes" xml:space="preserve">
          <source>You will get this error message when one of the parameters in the &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call is wrong. Unfortunately there are quite a few parameters to get wrong, so it can be difficult to figure out which one it is.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 호출 의 매개 변수 중 하나 가 잘못 되면이 오류 메시지가 표시됩니다 . 불행히도 잘못된 매개 변수는 매우 많으므로 어느 매개 변수인지 파악하기가 어려울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b306755ccc7dd24d9d304eb11d95322f9c7d1c36" translate="yes" xml:space="preserve">
          <source>You will have to make sure that CCTYPE is set correctly and that CCHOME points to wherever you installed your compiler.</source>
          <target state="translated">CCTYPE이 올바르게 설정되어 있고 CCHOME이 컴파일러를 설치 한 곳을 가리키는 지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="b8d67b6a7548006b180c9c0aa7f1777391e8e3f6" translate="yes" xml:space="preserve">
          <source>You will need a copy of Git for your computer. You can fetch a copy of the repository using the git protocol:</source>
          <target state="translated">컴퓨터에 Git 사본이 필요합니다. git 프로토콜을 사용하여 저장소 사본을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a0e1442c7d674a64133a4ac5cbad0b8f84016fe" translate="yes" xml:space="preserve">
          <source>You will need perl version 5.005_03 or newer.</source>
          <target state="translated">펄 버전 5.005_03 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c20642cf215c3811e3976c0a074a0bc8e167607f" translate="yes" xml:space="preserve">
          <source>You will need the packages mentioned in</source>
          <target state="translated">에 언급 된 패키지가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="125a7a338622da6411e41d9bf9ce7dc1495ae8ff" translate="yes" xml:space="preserve">
          <source>You will need to have Module::Signature installed, which in turn requires that you have at least one of Crypt::OpenPGP module or the command-line</source>
          <target state="translated">Module :: Signature가 설치되어 있어야하며 Crypt :: OpenPGP 모듈 또는 명령 줄 중 하나 이상이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="26225667638a5ef1fac02d60146f2f3c0e15d299" translate="yes" xml:space="preserve">
          <source>You will need to open every other filehandle on your own. Although there are many variants, the most common way to call Perl's open() function is with three arguments and one return value:</source>
          <target state="translated">다른 모든 파일 핸들을 직접 열어야합니다. 많은 변형이 있지만 Perl의 open () 함수를 호출하는 가장 일반적인 방법은 세 개의 인수와 하나의 반환 값을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ced186b3bff5ac2b886750a50b53e155abe57dbc" translate="yes" xml:space="preserve">
          <source>You will probably find these modifiers even more useful if you have to deal with big- or little-endian C structures. Be sure to read &lt;a href=&quot;#Packing-and-Unpacking-C-Structures&quot;&gt;Packing and Unpacking C Structures&lt;/a&gt; for more on that.</source>
          <target state="translated">빅 엔디안 또는 리틀 엔디안 C 구조를 처리해야하는 경우 이러한 수정자가 더 유용 할 것입니다. 이에 대한 자세한 내용은 &lt;a href=&quot;#Packing-and-Unpacking-C-Structures&quot;&gt;포장 및 포장 풀기 C 구조&lt;/a&gt; 를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="299bf5b3f1c12a5c613500fd1bf200a8e448ae9f" translate="yes" xml:space="preserve">
          <source>You will see a message about errors while extracting</source>
          <target state="translated">추출하는 동안 오류에 대한 메시지가 표시됩니다</target>
        </trans-unit>
        <trans-unit id="d4ae5109d0174e4b426288bcd1b8e77508718bce" translate="yes" xml:space="preserve">
          <source>You will sometimes see older books or documentation mention &quot;blessing a reference&quot; or describe an object as a &quot;blessed reference&quot;, but this is incorrect. It isn't the reference that is blessed as an object; it's the thing the reference refers to (i.e. the referent).</source>
          <target state="translated">오래된 책이나 문서에 &quot;참조 축복&quot;이라는 언급이 있거나 대상을 &quot;축복 참조&quot;로 묘사하는 경우가 있지만 이는 잘못된 것입니다. 그것은 대상으로서 축복받은 참조가 아닙니다. 참조가 참조하는 것 (즉, 참조 자)입니다.</target>
        </trans-unit>
        <trans-unit id="e797714a16ef1ab3d51adb0398a2351cdb2d4869" translate="yes" xml:space="preserve">
          <source>You would do</source>
          <target state="translated">당신은 할 것</target>
        </trans-unit>
        <trans-unit id="6a39b437275322e4ded1326f66b7e094ff120686" translate="yes" xml:space="preserve">
          <source>You would do well to understand that the TIEARRAY and TIEHASH interfaces are mere sugar to invoke some perl method calls while using the uniform hash and array syntax. The use of this sugar imposes some overhead (typically about two to four extra opcodes per FETCH/STORE operation, in addition to the creation of all the mortal variables required to invoke the methods). This overhead will be comparatively small if the TIE methods are themselves substantial, but if they are only a few statements long, the overhead will not be insignificant.</source>
          <target state="translated">TIEARRAY 및 TIEHASH 인터페이스는 균일 한 해시 및 배열 구문을 사용하는 동안 일부 perl 메소드 호출을 호출하기위한 단순한 설탕이라는 것을 이해해야합니다. 이 설탕을 사용하면 약간의 오버 헤드가 발생합니다 (일반적으로 FETCH / STORE 작업 당 약 2 ~ 4 개의 추가 opcode가 있으며 메소드를 호출하는 데 필요한 모든 필사자 변수 생성). TIE 방법 자체가 실질적인 경우이 오버 헤드는 비교적 작을 것입니다. 그러나 이들이 단지 몇 개의 진술 일 경우 오버 헤드는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d4ff63e38580a86bc4e960e615187745a0cf46e6" translate="yes" xml:space="preserve">
          <source>You would tell &lt;code&gt;Memoize&lt;/code&gt; to use this normalizer this way:</source>
          <target state="translated">당신은 말할 것 &lt;code&gt;Memoize&lt;/code&gt; 을 이런 식으로 노멀이 사용하는 :</target>
        </trans-unit>
        <trans-unit id="26052a9c2b555b8c00fe517ca714ea40b56ea28f" translate="yes" xml:space="preserve">
          <source>You would think passing files to an XS is difficult, with all the typeglobs and stuff. Well, it isn't.</source>
          <target state="translated">모든 타입 글로브와 함께 XS로 파일을 전달하는 것이 어렵다고 생각할 것입니다. 글쎄요.</target>
        </trans-unit>
        <trans-unit id="97f37569bdb5c4ba52eeb6c3306265613993e5ff" translate="yes" xml:space="preserve">
          <source>You'll also find that &lt;code&gt;foreach&lt;/code&gt; loop used to create a topicalizer and a switch:</source>
          <target state="translated">또한 &lt;code&gt;foreach&lt;/code&gt; 루프는 토픽 라이저와 스위치를 만드는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5e9bf36ecbd53fc8e26acf6fb90205c1b5356d3c" translate="yes" xml:space="preserve">
          <source>You'll also have to choose the appropriate library directory (</source>
          <target state="translated">또한 적절한 라이브러리 디렉토리를 선택해야합니다 (</target>
        </trans-unit>
        <trans-unit id="d14f9a4e84e4a65a6fcadc471d3775e2d2026c66" translate="yes" xml:space="preserve">
          <source>You'll also need to add the following code to the top of the .xs file, just after the include of &quot;XSUB.h&quot;:</source>
          <target state="translated">또한 &quot;XSUB.h&quot;가 포함 된 직후 .xs 파일의 맨 위에 다음 코드를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="067d0f39aaa002449de130921826b00edd6e52d4" translate="yes" xml:space="preserve">
          <source>You'll also see code that does this without a temporary variable, as in</source>
          <target state="translated">다음과 같이 임시 변수 없이이 작업을 수행하는 코드도 볼 수 있습니다</target>
        </trans-unit>
        <trans-unit id="e76c883ffb7e9e13e48b98bafcbb6fa1aa675b80" translate="yes" xml:space="preserve">
          <source>You'll be in trouble. Those should (in 99.8% of the cases) be the simpler and more direct:</source>
          <target state="translated">당신은 곤경에 처할 것입니다. 99.8 %의 경우 더 단순하고 직접적이어야합니다.</target>
        </trans-unit>
        <trans-unit id="f885bd4b3bb53aff3bed3dec0b066248d1576a12" translate="yes" xml:space="preserve">
          <source>You'll have to catch the SIGCHLD signal, and possibly SIGPIPE too. SIGCHLD is sent when the backgrounded process finishes. SIGPIPE is sent when you write to a filehandle whose child process has closed (an untrapped SIGPIPE can cause your program to silently die). This is not an issue with &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system(&quot;cmd&amp;amp;&quot;)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">SIGCHLD 신호를 포착하고 SIGPIPE도 포착해야합니다. 백그라운드 프로세스가 완료되면 SIGCHLD가 전송됩니다. 하위 프로세스가 닫힌 파일 핸들에 쓸 때 SIGPIPE가 전송됩니다 (트랩되지 않은 SIGPIPE로 인해 프로그램이 자동으로 종료 될 수 있음). &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system(&quot;cmd&amp;amp;&quot;)&lt;/a&gt;&lt;/code&gt; 의 문제는 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="2c26c7e5ed49de9efc0c0dba307a9def27936a34" translate="yes" xml:space="preserve">
          <source>You'll have to choose the appropriate compiler (</source>
          <target state="translated">적절한 컴파일러를 선택해야합니다 (</target>
        </trans-unit>
        <trans-unit id="e62d384e427e6ef82a853693fc0380e3a4a6bcdd" translate="yes" xml:space="preserve">
          <source>You'll know your submission has been processed when you receive an email from our ticket tracking system. This email will give you a ticket number. Once your patch has made it to the ticket tracking system, it will also be sent to the perl5-porters@perl.org list.</source>
          <target state="translated">티켓 추적 시스템에서 이메일을 받으면 제출이 처리되었음을 알 수 있습니다. 이 이메일은 티켓 번호를 알려줄 것입니다. 패치가 티켓 추적 시스템에 패치되면 perl5-porters@perl.org 목록으로 보내집니다.</target>
        </trans-unit>
        <trans-unit id="feea2270863ca6e9573aba26122b77d4eeb6b2e7" translate="yes" xml:space="preserve">
          <source>You'll need the &lt;code&gt;nmake&lt;/code&gt; utility, available at &lt;a href=&quot;http://download.microsoft.com/download/vc15/Patch/1.52/W95/EN-US/nmake15.exe&quot;&gt;http://download.microsoft.com/download/vc15/Patch/1.52/W95/EN-US/nmake15.exe&lt;/a&gt; or dmake, available on CPAN. &lt;a href=&quot;http://search.cpan.org/dist/dmake/&quot;&gt;http://search.cpan.org/dist/dmake/&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://download.microsoft.com/download/vc15/Patch/1.52/W95/EN-US/nmake15.exe&quot;&gt;http://download.microsoft.com/download/vc15/Patch/1.52/W95/EN-US/nmake15.exe에&lt;/a&gt; 있는 &lt;code&gt;nmake&lt;/code&gt; 유틸리티 또는 CPAN에있는 dmake 가 필요합니다 . &lt;a href=&quot;http://search.cpan.org/dist/dmake/&quot;&gt;http://search.cpan.org/dist/dmake/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d98bbda9e4101a6a3cc3bbb0d325b9faa857f4a3" translate="yes" xml:space="preserve">
          <source>You'll want to do that in your Perl source tree so the debugger can read the source code. You should see the copyright message, followed by the prompt.</source>
          <target state="translated">디버거가 소스 코드를 읽을 수 있도록 Perl 소스 트리에서이를 수행하려고합니다. 저작권 메시지가 표시되고 프롬프트가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="43eea0417aae56c41dd79afb85423b61a36ecf9b" translate="yes" xml:space="preserve">
          <source>You're confusing the purpose of &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; and backticks (``). &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; runs a command and returns exit status information (as a 16 bit value: the low 7 bits are the signal the process died from, if any, and the high 8 bits are the actual exit value). Backticks (``) run a command and return what it sent to STDOUT.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 과 backticks (``) 의 목적을 혼동하고 있습니다 . &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 은 명령을 실행하고 종료 상태 정보를 16 비트 값으로 리턴합니다. 하위 7 비트는 프로세스가 종료 된 신호이고 상위 8 비트는 실제 종료 값입니다. 백틱 (``)은 명령을 실행하고 STDOUT에 보낸 내용을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0067a9abf52f5d5adc52730de693ce9354a17edf" translate="yes" xml:space="preserve">
          <source>You're encouraged to create self-tests for your module to ensure it's working as intended on the myriad platforms Perl supports; if you upload your module to CPAN, a host of testers will build your module and send you the results of the tests. Again, &lt;code&gt;module-starter&lt;/code&gt; and &lt;code&gt;h2xs&lt;/code&gt; provide a test framework which you can extend - you should do something more than just checking your module will compile. &lt;a href=&quot;test/simple&quot;&gt;Test::Simple&lt;/a&gt; and &lt;a href=&quot;test/more&quot;&gt;Test::More&lt;/a&gt; are good places to start when writing a test suite.</source>
          <target state="translated">Perl이 지원하는 수많은 플랫폼에서 의도 한대로 작동하는지 확인하기 위해 모듈에 대한 자체 테스트를 작성하는 것이 좋습니다. CPAN에 모듈을 업로드하면 여러 테스터가 모듈을 빌드하고 테스트 결과를 보냅니다. 다시 말하지만, &lt;code&gt;module-starter&lt;/code&gt; 와 &lt;code&gt;h2xs&lt;/code&gt; 는 확장 할 수있는 테스트 프레임 워크를 제공합니다. 모듈이 컴파일되는지 확인하는 것 이상의 작업을 수행해야합니다. &lt;a href=&quot;test/simple&quot;&gt;Test :: Simple&lt;/a&gt; 및 &lt;a href=&quot;test/more&quot;&gt;Test :: More&lt;/a&gt; 는 테스트 스위트를 작성할 때 시작하기에 좋은 장소입니다.</target>
        </trans-unit>
        <trans-unit id="1465c23d6a9abbc69d7c02001d0a261855c5206d" translate="yes" xml:space="preserve">
          <source>You're probably trying to convert a string to a number, which Perl only converts as a decimal number. When Perl converts a string to a number, it ignores leading spaces and zeroes, then assumes the rest of the digits are in base 10:</source>
          <target state="translated">문자열을 숫자로 변환하려고 할 것입니다. Perl은 십진수로만 변환합니다. Perl은 문자열을 숫자로 변환 할 때 선행 공백과 0을 무시하고 나머지 숫자는 10 진법으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="f32dee0623a34d25e555f7bd9fe977163f048dfb" translate="yes" xml:space="preserve">
          <source>You're still out of luck if you need to keep track of decaying protons though.</source>
          <target state="translated">부패하는 양성자를 추적해야 할 경우 여전히 운이 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4522acbd81c14b3349dda685727b4174a91c46c1" translate="yes" xml:space="preserve">
          <source>You're unlikely to ever need to construct an object of this class for yourself, but if you want to, call &lt;code&gt;Pod::Simple::PullParserEndToken-&amp;gt;new( &lt;i&gt;tagname&lt;/i&gt; )&lt;/code&gt;</source>
          <target state="translated">이 클래스의 객체를 직접 만들 필요는 없지만 &lt;code&gt;Pod::Simple::PullParserEndToken-&amp;gt;new( &lt;i&gt;tagname&lt;/i&gt; )&lt;/code&gt; &lt;i&gt;tagname&lt;/i&gt; )을 호출하십시오.&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="13c2c796fe95a445a68ec254f6e70e50cbdb3db7" translate="yes" xml:space="preserve">
          <source>You're unlikely to ever need to construct an object of this class for yourself, but if you want to, call &lt;code&gt;Pod::Simple::PullParserStartToken-&amp;gt;new( &lt;i&gt;tagname&lt;/i&gt;, &lt;i&gt;attrhash&lt;/i&gt; )&lt;/code&gt;</source>
          <target state="translated">이 클래스의 객체를 직접 만들 필요는 없지만 원하는 경우 &lt;code&gt;Pod::Simple::PullParserStartToken-&amp;gt;new( &lt;i&gt;tagname&lt;/i&gt;, &lt;i&gt;attrhash&lt;/i&gt; )&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="63fdd43345f7726cfc85c93addac87c77eec8e6e" translate="yes" xml:space="preserve">
          <source>You're unlikely to ever need to construct an object of this class for yourself, but if you want to, call &lt;code&gt;Pod::Simple::PullParserTextToken-&amp;gt;new( &lt;i&gt;text&lt;/i&gt; )&lt;/code&gt;</source>
          <target state="translated">이 클래스의 객체를 직접 만들 필요는 없지만 &lt;code&gt;Pod::Simple::PullParserTextToken-&amp;gt;new( &lt;i&gt;text&lt;/i&gt; )&lt;/code&gt; &lt;i&gt;text&lt;/i&gt; )를 호출하십시오.&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="244e1e138ccb1ddf345dc218bc4eb88a0d9affd5" translate="yes" xml:space="preserve">
          <source>You've asked &lt;code&gt;Fatal&lt;/code&gt; to replace a subroutine, but it's not a Perl built-in, and &lt;code&gt;Fatal&lt;/code&gt; couldn't find it as a regular subroutine. It either doesn't exist or has not yet been defined.</source>
          <target state="translated">&lt;code&gt;Fatal&lt;/code&gt; 에 서브 루틴을 교체 하도록 요청 했지만 Perl이 내장되어 있지 않으며 &lt;code&gt;Fatal&lt;/code&gt; 이 서브 루틴을 일반 서브 루틴으로 찾을 수 없습니다. 존재하지 않거나 아직 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="e40be2d06acbdf1af8b44d624778687fbb9e49ee" translate="yes" xml:space="preserve">
          <source>You've asked &lt;code&gt;Fatal&lt;/code&gt; to try and replace a subroutine which does not exist, or has not yet been defined.</source>
          <target state="translated">존재하지 않거나 아직 정의되지 않은 서브 루틴을 &lt;code&gt;Fatal&lt;/code&gt; 으로 교체 하도록 Fatal 에 요청했습니다 .</target>
        </trans-unit>
        <trans-unit id="b50e18d238da3dcc7957f257361d12bcaab56e61" translate="yes" xml:space="preserve">
          <source>You've called &lt;code&gt;Fatal&lt;/code&gt; with an argument that doesn't look like a subroutine name, nor a switch that this version of Fatal understands.</source>
          <target state="translated">서브 루틴 이름처럼 보이지 않는 인수 나이 버전의 Fatal이 이해하는 스위치를 사용하여 &lt;code&gt;Fatal&lt;/code&gt; 을 호출했습니다 .</target>
        </trans-unit>
        <trans-unit id="dcf998c7dc1a2b4fcde7c406f8c5df0a1daf51ce" translate="yes" xml:space="preserve">
          <source>You've found a bug in &lt;code&gt;Fatal&lt;/code&gt; . Please report it using the &lt;code&gt;perlbug&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;Fatal&lt;/code&gt; 에서 버그를 발견했습니다 . &lt;code&gt;perlbug&lt;/code&gt; 명령을 사용하여보고하십시오 .</target>
        </trans-unit>
        <trans-unit id="475fb69a6a2555d09a61f2284d19f582455e0ff5" translate="yes" xml:space="preserve">
          <source>You've insisted on hints for user-subroutines, either by pre-pending a &lt;code&gt;!&lt;/code&gt; to the subroutine name itself, or earlier in the list of arguments to &lt;code&gt;autodie&lt;/code&gt; . However the subroutine in question does not have any hints available.</source>
          <target state="translated">!를 앞에 붙여서 사용자 서브 루틴에 대한 힌트를 주장했습니다 &lt;code&gt;!&lt;/code&gt; 서브 루틴 이름 자체 또는 &lt;code&gt;autodie&lt;/code&gt; 에 대한 인수 목록의 앞부분에 추가하십시오 . 그러나 해당 서브 루틴에는 사용 가능한 힌트가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3c13a053a1a459196298d76dc68f54350a5781eb" translate="yes" xml:space="preserve">
          <source>You've probably seen shuffling algorithms that work using splice, randomly picking another element to swap the current element with</source>
          <target state="translated">스플 라이스를 사용하여 작동하는 셔플 링 알고리즘을 보았을 수도 있습니다. 현재 요소를 다른 요소로 임의로 선택하여 현재 요소를</target>
        </trans-unit>
        <trans-unit id="4f7734dcac6827c63f3c8f78e3f70fe360dc90d8" translate="yes" xml:space="preserve">
          <source>You've tried to use &lt;code&gt;Fatal&lt;/code&gt; on a Perl built-in that can't be overridden, such as &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, which means that &lt;code&gt;Fatal&lt;/code&gt; can't help you, although some other modules might. See the &lt;a href=&quot;#SEE-ALSO&quot;&gt;SEE ALSO&lt;/a&gt; section of this documentation.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 과 같이 재정의 할 수없는 Perl 내장에서 &lt;code&gt;Fatal&lt;/code&gt; 을 사용하려고 시도했습니다 . 이는 다른 모듈 일지라도 &lt;code&gt;Fatal&lt;/code&gt; 이 도움을 줄 수 없음 을 의미합니다 . 참고 항목 &lt;a href=&quot;#SEE-ALSO&quot;&gt;참조 ALSO의&lt;/a&gt; 이 문서의 섹션을.</target>
        </trans-unit>
        <trans-unit id="770547bed3b38328c9ebe9f8750573476f6753ff" translate="yes" xml:space="preserve">
          <source>Young and free of legacy weight, providing a lightweight and easy to learn API. Has a growing addon ecosystem. It is best used for smaller projects and very easy to learn for beginners.</source>
          <target state="translated">젊고 레거시 무게가 없어 가볍고 배우기 쉬운 API를 제공합니다. 애드온 생태계가 성장하고 있습니다. 소규모 프로젝트에 가장 적합하며 초보자도 쉽게 배울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c6f85b02933dd53061abea03a23ce712a1c9139" translate="yes" xml:space="preserve">
          <source>Your &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; is most probably working just fine. It's the numbers that aren't quite what you think.</source>
          <target state="translated">귀하의 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; 아마 대부분 잘 작동한다. 당신이 생각하지 않는 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="df53f54d51a07584d7be09d83850a7da9c15786b" translate="yes" xml:space="preserve">
          <source>Your basic test. Pass if &lt;code&gt;$test&lt;/code&gt; is true, fail if $test is false. Just like Test::Simple's &lt;code&gt;ok()&lt;/code&gt; .</source>
          <target state="translated">기본 시험. 경우 합격 &lt;code&gt;$test&lt;/code&gt; 참 $ 테스트가 false 인 경우, 실패합니다. Test :: Simple 's &lt;code&gt;ok()&lt;/code&gt; 처럼 .</target>
        </trans-unit>
        <trans-unit id="b237ec1c8f3c84ff91c26a3b96b070c2410531e4" translate="yes" xml:space="preserve">
          <source>Your best bet is to use the single argument form:</source>
          <target state="translated">가장 좋은 방법은 단일 인수 형식을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="30a923bd50861e3e1f2796d154bd6dcc6842fa55" translate="yes" xml:space="preserve">
          <source>Your choice:</source>
          <target state="translated">당신의 선택 :</target>
        </trans-unit>
        <trans-unit id="2240cd19d3c19a8cd0a6388378dc061fa17be90f" translate="yes" xml:space="preserve">
          <source>Your commit message should describe what part of the Perl core you're changing and what you expect your patch to do.</source>
          <target state="translated">커밋 메시지는 변경하려는 Perl 코어의 일부와 패치가 수행 할 작업을 설명해야합니다.</target>
        </trans-unit>
        <trans-unit id="9f522992b80d434f30bfc99a44403ac7ea5d333f" translate="yes" xml:space="preserve">
          <source>Your commit message should describe why the change you are making is important. When someone looks at your change in six months or six years, your intent should be clear.</source>
          <target state="translated">커밋 메시지는 왜 변경이 중요한지 설명해야합니다. 6 개월 또는 6 년 후에 누군가가 변경 사항을 검토 할 때는 의도가 분명해야합니다.</target>
        </trans-unit>
        <trans-unit id="0e92f837de5ea84ed03360a4aeae41a080276983" translate="yes" xml:space="preserve">
          <source>Your current &lt;b&gt;directory&lt;/b&gt;, from which relative pathnames are interpreted by the &lt;b&gt;operating system&lt;/b&gt;. The operating system knows your current directory because you told it with a &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt;, or because you started out in the place where your parent &lt;b&gt;process&lt;/b&gt; was when you were born.</source>
          <target state="translated">현재 &lt;b&gt;디렉토리&lt;/b&gt; 의 상대 경로 이름은로 해석되는, &lt;b&gt;운영 체제&lt;/b&gt; . &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 으로 말 했거나 부모 &lt;b&gt;프로세스&lt;/b&gt; 가 태어 났을 때 시작했기 때문에 운영 체제는 현재 디렉토리를 알고 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d9200ca79b7b623bd2d92209c7c88d5edf0f0d25" translate="yes" xml:space="preserve">
          <source>Your custom type should then be picked up automatically by the &lt;a href=&quot;../parser&quot;&gt;TAP::Parser&lt;/a&gt;.</source>
          <target state="translated">그런 다음 &lt;a href=&quot;../parser&quot;&gt;TAP :: Parser가&lt;/a&gt; 사용자 정의 유형을 자동으로 선택해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8e7f0615cde01baf7008f00eb9c075025028921a" translate="yes" xml:space="preserve">
          <source>Your distribution &lt;b&gt;must&lt;/b&gt; have a &lt;code&gt;NAME&lt;/code&gt; .</source>
          <target state="translated">배포판 에 &lt;code&gt;NAME&lt;/code&gt; 이&lt;b&gt;있어야합니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="df70fd54c497020a59006e2165eb78aadc748605" translate="yes" xml:space="preserve">
          <source>Your first try should probably be the &lt;a href=&quot;text/balanced&quot;&gt;Text::Balanced&lt;/a&gt; module, which is in the Perl standard library since Perl 5.8. It has a variety of functions to deal with tricky text. The &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;Regexp::Common&lt;/a&gt; module can also help by providing canned patterns you can use.</source>
          <target state="translated">첫 번째 시도는 아마도 Perl 5.8 이후의 Perl 표준 라이브러리에 있는 &lt;a href=&quot;text/balanced&quot;&gt;Text :: Balanced&lt;/a&gt; 모듈 이어야합니다 . 까다로운 텍스트를 처리하는 다양한 기능이 있습니다. &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;정규 표현식 :: 공통&lt;/a&gt; 모듈 수 또한 당신이 사용할 수있는 통조림 패턴을 제공하여 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="880f6f429e2d63ef4a94f9a2206ede8287e74da3" translate="yes" xml:space="preserve">
          <source>Your interfaces should be understandable by an average Perl programmer. The following guidelines may help you judge whether your API is sufficiently straightforward:</source>
          <target state="translated">인터페이스는 일반적인 Perl 프로그래머가 이해할 수 있어야합니다. 다음 지침은 API가 충분히 간단한 지 판단하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d26baf198cb18edde520e205142e25037414abf9" translate="yes" xml:space="preserve">
          <source>Your internet domain name</source>
          <target state="translated">인터넷 도메인 이름</target>
        </trans-unit>
        <trans-unit id="c8e05b300242eb52ca20c1b662ee525c5256fe27" translate="yes" xml:space="preserve">
          <source>Your interpreter doesn't know how to communicate with these extensions on its own. A little glue will help. Up until now you've been calling</source>
          <target state="translated">통역사는 이러한 확장 프로그램과의 통신 방법을 모릅니다. 작은 접착제가 도움이 될 것입니다. 지금까지 전화 했어</target>
        </trans-unit>
        <trans-unit id="926b6183d26bfd81c7f17ff04a868dae347149ae" translate="yes" xml:space="preserve">
          <source>Your mileage may vary...</source>
          <target state="translated">귀하의 마일리지가 다를 수 있습니다...</target>
        </trans-unit>
        <trans-unit id="60a065094064545ff1123708e618e1b6cf8cbd1c" translate="yes" xml:space="preserve">
          <source>Your mileage will vary. If in any doubt &lt;b&gt;do not use it&lt;/b&gt;.</source>
          <target state="translated">마일리지가 다를 수 있습니다. 의심스러운 경우 &lt;b&gt;사용하지 마십시오&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="c8a47834f473426f773c0b79429bd305f3db3ac9" translate="yes" xml:space="preserve">
          <source>Your module may be object oriented (OO) or not, or it may have both kinds of interfaces available. There are pros and cons of each technique, which should be considered when you design your API.</source>
          <target state="translated">모듈이 객체 지향 (OO)인지 아닌지 또는 두 종류의 인터페이스를 모두 사용할 수 있습니다. API를 디자인 할 때 고려해야 할 각 기술의 장단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4936a62e724ff21109fff06e820adf4197164d03" translate="yes" xml:space="preserve">
          <source>Your module should also include a README file describing the module and giving pointers to further information (website, author email).</source>
          <target state="translated">또한 모듈에는 모듈을 설명하고 추가 정보 (웹 사이트, 작성자 이메일)에 대한 포인터를 제공하는 README 파일이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="290b95e5d44851668b2e9d3e7d74fdc415789c4e" translate="yes" xml:space="preserve">
          <source>Your module should have a clearly defined scope which is no longer than a single sentence. Can your module be broken down into a family of related modules?</source>
          <target state="translated">모듈은 명확하게 정의 된 범위를 가져야하며 더 이상 한 문장이 아닙니다. 모듈을 관련 모듈로 분류 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="8348552a40cd77a386588c2671c4e766e50a33bd" translate="yes" xml:space="preserve">
          <source>Your module should include documentation aimed at Perl developers. You should use Perl's &quot;plain old documentation&quot; (POD) for your general technical documentation, though you may wish to write additional documentation (white papers, tutorials, etc) in some other format. You need to cover the following subjects:</source>
          <target state="translated">모듈에는 Perl 개발자를위한 문서가 포함되어야합니다. 일반적인 기술 문서에는 Perl의 &quot;일반 문서&quot;(POD)를 사용해야하지만 다른 형식으로 추가 문서 (백서, 자습서 등)를 작성하고 싶을 수도 있습니다. 다음과 같은 주제를 다루어야합니다.</target>
        </trans-unit>
        <trans-unit id="861d9c806a8066b7b2265b2640dfe765fcbec7fa" translate="yes" xml:space="preserve">
          <source>Your module should run successfully under the strict pragma and should run without generating any warnings. Your module should also handle taint-checking where appropriate, though this can cause difficulties in many cases.</source>
          <target state="translated">모듈은 엄격한 pragma에서 성공적으로 실행되어야하며 경고를 생성하지 않고 실행해야합니다. 모듈은 또한 적절한 경우 오염 검사를 처리해야하지만, 많은 경우 어려움을 일으킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55948057c1f1e500efb989c6858ac749bffed2dd" translate="yes" xml:space="preserve">
          <source>Your module will be part of a developer's toolkit. It will not, in itself, form the &lt;b&gt;entire&lt;/b&gt; toolkit. It's tempting to add extra features until your code is a monolithic system rather than a set of modular building blocks.</source>
          <target state="translated">모듈은 개발자 툴킷의 일부가됩니다. 그 자체로는 &lt;b&gt;전체&lt;/b&gt; 툴킷을 형성하지 않습니다 . 코드가 모듈 식 빌딩 블록 세트가 아닌 모 놀리 식 시스템이 될 때까지 추가 기능을 추가하려는 유혹이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad14f196f53d1d71d675a079baed8e60dbe25d0c" translate="yes" xml:space="preserve">
          <source>Your name for distributing the package with the version number included. This is used by 'make dist' to name the resulting archive file.</source>
          <target state="translated">버전 번호가 포함 된 패키지 배포를위한 이름입니다. 'make dist'에서 결과 아카이브 파일의 이름을 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="175b500be69da19db3c39bbbb8f52b905fefd909" translate="yes" xml:space="preserve">
          <source>Your naming should be consistent. For instance, it's better to have:</source>
          <target state="translated">이름이 일관되어야합니다. 예를 들어 다음을 갖는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f42ef3040bfea4a52c4a41099b15560c160072e6" translate="yes" xml:space="preserve">
          <source>Your new toolkit</source>
          <target state="translated">새로운 툴킷</target>
        </trans-unit>
        <trans-unit id="ab842b2beec604e1059561d157771750a66116bd" translate="yes" xml:space="preserve">
          <source>Your patch may be returned with requests for changes, or requests for more detailed explanations about your fix.</source>
          <target state="translated">패치는 변경 요청이나 수정에 대한 자세한 설명 요청과 함께 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fe050a844b774ad50502f71e6d05cbaaefcd33b" translate="yes" xml:space="preserve">
          <source>Your programs can use the Config module to check whether threads are enabled. If your program can't run without them, you can say something like:</source>
          <target state="translated">프로그램은 구성 모듈을 사용하여 스레드가 사용 가능한지 여부를 확인할 수 있습니다. 프로그램이 없으면 프로그램을 실행할 수 없으면 다음과 같이 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3998dbed349b6ee91c59e7ad32be8eef4f4d5eba" translate="yes" xml:space="preserve">
          <source>Your return address. The program will ask you to confirm its default if you don't use this option.</source>
          <target state="translated">귀국 주소 이 옵션을 사용하지 않으면 프로그램에서 기본값을 확인하도록 요청합니다.</target>
        </trans-unit>
        <trans-unit id="b4ef3a10fbcdb1f56987b1c90e4c788bb1481b23" translate="yes" xml:space="preserve">
          <source>Your script will declare a skip with the reason why you skipped and exit immediately with a zero (success). See &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; for details.</source>
          <target state="translated">스크립트는 건너 뛴 이유와 함께 건너 뛰기를 선언하고 즉시 0으로 종료합니다 (성공). 자세한 내용은 &lt;a href=&quot;harness&quot;&gt;Test :: Harness&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2ffadff849a0704c5040d7dc21528967305be780" translate="yes" xml:space="preserve">
          <source>Your system documentation for &lt;code&gt;clock&lt;/code&gt; , &lt;code&gt;clock_gettime&lt;/code&gt; , &lt;code&gt;clock_getres&lt;/code&gt; , &lt;code&gt;clock_nanosleep&lt;/code&gt; , &lt;code&gt;clock_settime&lt;/code&gt; , &lt;code&gt;getitimer&lt;/code&gt; , &lt;code&gt;gettimeofday&lt;/code&gt; , &lt;code&gt;setitimer&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;ualarm&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;clock&lt;/code&gt; , &lt;code&gt;clock_gettime&lt;/code&gt; , &lt;code&gt;clock_getres&lt;/code&gt; , &lt;code&gt;clock_nanosleep&lt;/code&gt; , &lt;code&gt;clock_settime&lt;/code&gt; , &lt;code&gt;getitimer&lt;/code&gt; , &lt;code&gt;gettimeofday&lt;/code&gt; , &lt;code&gt;setitimer&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;ualarm&lt;/code&gt; 에 대한 시스템 문서 .</target>
        </trans-unit>
        <trans-unit id="f45278c990de17bddc07886e62872d5705e84df2" translate="yes" xml:space="preserve">
          <source>Your system may also have man pages installed for those modules, in which case you can probably just use the man(1) command.</source>
          <target state="translated">시스템에 해당 모듈에 대한 매뉴얼 페이지가 설치되어있을 수도 있습니다.이 경우 man (1) 명령 만 사용하면됩니다.</target>
        </trans-unit>
        <trans-unit id="f67311ed40fd91017f49e031b08d5e66ea348e7f" translate="yes" xml:space="preserve">
          <source>Your system may use lockfiles to control multiple access. Make sure you follow the correct protocol. Unpredictable behavior can result from multiple processes reading from one device.</source>
          <target state="translated">시스템은 잠금 파일을 사용하여 다중 액세스를 제어 할 수 있습니다. 올바른 프로토콜을 따르십시오. 하나의 장치에서 여러 프로세스를 읽는 경우 예기치 않은 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69b78ca3bd9762db3a1f2fc87f8707247fab00ca" translate="yes" xml:space="preserve">
          <source>Your terminal expects ISO-8859-1 (yes/no)?</source>
          <target state="translated">터미널에 ISO-8859-1이 필요합니까 (예 / 아니요)?</target>
        </trans-unit>
        <trans-unit id="eb27aa8afa0df31a742a7c36ee000dde7a333d59" translate="yes" xml:space="preserve">
          <source>Your test suite additions should generally follow these guidelines (courtesy of Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;):</source>
          <target state="translated">테스트 스위트 추가는 일반적으로 다음 지침을 따라야합니다 (Grusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt; 제공).</target>
        </trans-unit>
        <trans-unit id="6757bbaa3e59b9eae8d3358f1cb54cb3839ec256" translate="yes" xml:space="preserve">
          <source>Your text string will be sent using the bytes in Perl's internal format. In some cases, Perl will warn you that you're doing something wrong, with a friendly warning:</source>
          <target state="translated">텍스트 문자열은 Perl의 내부 형식으로 된 바이트를 사용하여 전송됩니다. 경우에 따라 Perl은 사용자에게 잘못된 경고 메시지를 표시하면서 경고합니다.</target>
        </trans-unit>
        <trans-unit id="e6fdf4d82698552aa3b04fea17dd3738278fad63" translate="yes" xml:space="preserve">
          <source>Your version number for distributing the package. This defaults to 0.1.</source>
          <target state="translated">패키지 배포를위한 버전 번호. 기본값은 0.1입니다.</target>
        </trans-unit>
        <trans-unit id="6470a2f4b416b0ce03b530f9156d5bf0649ff6c9" translate="yes" xml:space="preserve">
          <source>Your version number for the .xs file of this package. This defaults to the value of the VERSION attribute.</source>
          <target state="translated">이 패키지의 .xs 파일의 버전 번호입니다. 기본값은 VERSION 속성 값입니다.</target>
        </trans-unit>
        <trans-unit id="f943e56eab4587790a7d8e3702190e81dcdaf111" translate="yes" xml:space="preserve">
          <source>YourModule.pm</source>
          <target state="translated">YourModule.pm</target>
        </trans-unit>
        <trans-unit id="a032b09d002bfec745ff9618af85165922efa0c5" translate="yes" xml:space="preserve">
          <source>YourPackage.pm</source>
          <target state="translated">YourPackage.pm</target>
        </trans-unit>
        <trans-unit id="96b451942b04b66df98082b51a96fd9c21c979e6" translate="yes" xml:space="preserve">
          <source>YourPackage.xs</source>
          <target state="translated">YourPackage.xs</target>
        </trans-unit>
        <trans-unit id="3a63a963c11724e54297328f1cd01fab7cc056fb" translate="yes" xml:space="preserve">
          <source>YourProjClass-&amp;gt;fallback_language_classes()</source>
          <target state="translated">YourProjClass-&amp;gt;fallback_language_classes()</target>
        </trans-unit>
        <trans-unit id="93d7ab614acf51e6ed84bd194c23c002e0bc546a" translate="yes" xml:space="preserve">
          <source>YourProjClass-&amp;gt;fallback_languages()</source>
          <target state="translated">YourProjClass-&amp;gt;fallback_languages()</target>
        </trans-unit>
        <trans-unit id="98d44898a77a54f7718ada94977059bdfaa937a9" translate="yes" xml:space="preserve">
          <source>Yuval Kogman &amp;lt;nothingmuch@woobling.org&amp;gt;</source>
          <target state="translated">유발 코 그먼 &amp;lt;nothingmuch@woobling.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="cf3031c81c2a11248f63acc5b78e4d34caa6f6e1" translate="yes" xml:space="preserve">
          <source>Yves Orton suggested and helped for making &lt;code&gt;Sys::Syslog&lt;/code&gt; use the native event logger under Win32 systems.</source>
          <target state="translated">Yves Orton은 &lt;code&gt;Sys::Syslog&lt;/code&gt; 가 Win32 시스템에서 기본 이벤트 로거를 사용 하도록 제안하고 도움을주었습니다 .</target>
        </trans-unit>
        <trans-unit id="909f99a779adb66a76fc53ab56c7dd1caf35d0fd" translate="yes" xml:space="preserve">
          <source>Z</source>
          <target state="translated">Z</target>
        </trans-unit>
        <trans-unit id="f2fd2a56c54b7c37d0d9f4b109a0de518f12a9a8" translate="yes" xml:space="preserve">
          <source>Zeus for Windows is another Win32 multi-language editor/IDE that comes with support for Perl.</source>
          <target state="translated">Windows 용 Zeus는 Perl을 지원하는 다른 Win32 다국어 편집기 / IDE입니다.</target>
        </trans-unit>
        <trans-unit id="db104e2c14625f90e76e1788e4a37b936ee652b6" translate="yes" xml:space="preserve">
          <source>Zlib Library Version Support</source>
          <target state="translated">Zlib 라이브러리 버전 지원</target>
        </trans-unit>
        <trans-unit id="1e5c2f367f02e47a8c160cda1cd9d91decbac441" translate="yes" xml:space="preserve">
          <source>[</source>
          <target state="translated">[</target>
        </trans-unit>
        <trans-unit id="fd2a987f8fd28617d0641e26e1ee23e3f1c471fb" translate="yes" xml:space="preserve">
          <source>[.Foo.Bar]</source>
          <target state="translated">[.Foo.Bar]</target>
        </trans-unit>
        <trans-unit id="4b6373280a08e827a1ab5c68abe6349dceef8925" translate="yes" xml:space="preserve">
          <source>[.Lib.Auto.</source>
          <target state="translated">[.Lib.Auto.</target>
        </trans-unit>
        <trans-unit id="630f50e0cd8cffab6e0a142979fe618389586858" translate="yes" xml:space="preserve">
          <source>[.pod]</source>
          <target state="translated">[.pod]</target>
        </trans-unit>
        <trans-unit id="0cf7207af93f70e6c641ba1e90b8e15f86916573" translate="yes" xml:space="preserve">
          <source>[1] &lt;a href=&quot;http://en.wikipedia.org/wiki/Base64#URL_applications&quot;&gt;http://en.wikipedia.org/wiki/Base64#URL_applications&lt;/a&gt;</source>
          <target state="translated">[1] &lt;a href=&quot;http://en.wikipedia.org/wiki/Base64#URL_applications&quot;&gt;http://en.wikipedia.org/wiki/Base64#URL_applications&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d6819c355b216edc67b6c6a8c6dab5509cee1376" translate="yes" xml:space="preserve">
          <source>[1] &lt;a href=&quot;http://perl.plover.com/Rx/paper/&quot;&gt;http://perl.plover.com/Rx/paper/&lt;/a&gt;</source>
          <target state="translated">[1] &lt;a href=&quot;http://perl.plover.com/Rx/paper/&quot;&gt;http://perl.plover.com/Rx/paper/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f4bcc9cdddccdc2ae22d3c3454a7739be0e29b10" translate="yes" xml:space="preserve">
          <source>[2] &lt;a href=&quot;http://www.unicode.org&quot;&gt;http://www.unicode.org&lt;/a&gt;</source>
          <target state="translated">[2] &lt;a href=&quot;http://www.unicode.org&quot;&gt;http://www.unicode.org&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b002b78bc12a3ff6e29895fae1de731a69f453ae" translate="yes" xml:space="preserve">
          <source>[&lt;b&gt;-help&lt;/b&gt;] [&lt;b&gt;-man&lt;/b&gt;] [&lt;b&gt;-exit&lt;/b&gt;</source>
          <target state="translated">[&lt;b&gt;-help&lt;/b&gt;] [&lt;b&gt;-man&lt;/b&gt;] [&lt;b&gt;-exit&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b0275f738749aa6cac8eb913cf57b88a87e7251a" translate="yes" xml:space="preserve">
          <source>[= =] and [. .]</source>
          <target state="translated">[= =] and [. .]</target>
        </trans-unit>
        <trans-unit id="afca1504bc2e3c3044d29b9874e85f36958af894" translate="yes" xml:space="preserve">
          <source>[Building/installing modules]</source>
          <target state="translated">[Building/installing modules]</target>
        </trans-unit>
        <trans-unit id="1c6555677db9746d71e639d2861c450df21a423a" translate="yes" xml:space="preserve">
          <source>[INTERNAL] Test whether</source>
          <target state="translated">[INTERNAL] Test whether</target>
        </trans-unit>
        <trans-unit id="3e3a19400d8a2d90d0db0e1989c48275083a979d" translate="yes" xml:space="preserve">
          <source>[INTERNAL] Tests whether the UTF8 flag is turned on in the</source>
          <target state="translated">[INTERNAL] Tests whether the UTF8 flag is turned on in the</target>
        </trans-unit>
        <trans-unit id="22eb99e5f093e515d3af9067fe7ea86722b6bbf1" translate="yes" xml:space="preserve">
          <source>[INTERNAL] Turns the</source>
          <target state="translated">[INTERNAL] Turns the</target>
        </trans-unit>
        <trans-unit id="009b33a0528361398d9c707d1795bc4cfafeac38" translate="yes" xml:space="preserve">
          <source>[If you have the recommended version of bash for DJGPP, this is already done for you.]</source>
          <target state="translated">[If you have the recommended version of bash for DJGPP, this is already done for you.]</target>
        </trans-unit>
        <trans-unit id="5af5c7f45b299c973fea5c4dcd0294b1e6234199" translate="yes" xml:space="preserve">
          <source>[If you have the recommended versions of djdev, shell utilities and gawk, all these are already done for you, and you will not need to do anything.]</source>
          <target state="translated">[If you have the recommended versions of djdev, shell utilities and gawk, all these are already done for you, and you will not need to do anything.]</target>
        </trans-unit>
        <trans-unit id="f3b3a575af1d23fed1f5628631ec3936ffe0f6d1" translate="yes" xml:space="preserve">
          <source>[Installing/building perl]</source>
          <target state="translated">[Installing/building perl]</target>
        </trans-unit>
        <trans-unit id="5d1e8f7d83caac3b34475dd7d9e3096070d95629" translate="yes" xml:space="preserve">
          <source>[MAYCHANGE] In other words, the array or hash fetch/store functions don't really fetch and store actual values in the case of tied arrays and hashes. They merely call &lt;code&gt;mg_copy&lt;/code&gt; to attach magic to the values that were meant to be &quot;stored&quot; or &quot;fetched&quot;. Later calls to &lt;code&gt;mg_get&lt;/code&gt; and &lt;code&gt;mg_set&lt;/code&gt; actually do the job of invoking the TIE methods on the underlying objects. Thus the magic mechanism currently implements a kind of lazy access to arrays and hashes.</source>
          <target state="translated">[MAYCHANGE] In other words, the array or hash fetch/store functions don't really fetch and store actual values in the case of tied arrays and hashes. They merely call &lt;code&gt;mg_copy&lt;/code&gt; to attach magic to the values that were meant to be &quot;stored&quot; or &quot;fetched&quot;. Later calls to &lt;code&gt;mg_get&lt;/code&gt; and &lt;code&gt;mg_set&lt;/code&gt; actually do the job of invoking the TIE methods on the underlying objects. Thus the magic mechanism currently implements a kind of lazy access to arrays and hashes.</target>
        </trans-unit>
        <trans-unit id="2c69f013a0c0b9f7ed975da9c912abcf0653290a" translate="yes" xml:space="preserve">
          <source>[NEWVAL]</source>
          <target state="translated">[NEWVAL]</target>
        </trans-unit>
        <trans-unit id="4f834c241d7bdeabf113279ffdacebc7dc88459c" translate="yes" xml:space="preserve">
          <source>[Some of this answer was contributed by Kenneth Albanowski.]</source>
          <target state="translated">[Some of this answer was contributed by Kenneth Albanowski.]</target>
        </trans-unit>
        <trans-unit id="e9c2c8715a2a88d854204445ba9c4d5016aa0191" translate="yes" xml:space="preserve">
          <source>[This function has been largely superseded by the &lt;a href=&quot;#tie-VARIABLE%2cCLASSNAME%2cLIST&quot;&gt;tie&lt;/a&gt; function.]</source>
          <target state="translated">[This function has been largely superseded by the &lt;a href=&quot;#tie-VARIABLE%2cCLASSNAME%2cLIST&quot;&gt;tie&lt;/a&gt; function.]</target>
        </trans-unit>
        <trans-unit id="b1c00ee4c595ea64bb97d342fb1c568e80ba451b" translate="yes" xml:space="preserve">
          <source>[This function has been largely superseded by the &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; function.]</source>
          <target state="translated">[This function has been largely superseded by the &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; function.]</target>
        </trans-unit>
        <trans-unit id="3b25169a6ac2e6f9178110c63d21693ee54fec41" translate="yes" xml:space="preserve">
          <source>[This function has been largely superseded by the &lt;code&gt;&lt;a href=&quot;untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; function.]</source>
          <target state="translated">[This function has been largely superseded by the &lt;code&gt;&lt;a href=&quot;untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; function.]</target>
        </trans-unit>
        <trans-unit id="466698b7c92675c3f06ae6b2691207f2e8b24913" translate="yes" xml:space="preserve">
          <source>[This section provides a short overview only...]</source>
          <target state="translated">[This section provides a short overview only...]</target>
        </trans-unit>
        <trans-unit id="68ecc94bfa207a245a096cc2d83887da582b2e04" translate="yes" xml:space="preserve">
          <source>[This section still under construction. Ignore everything here. Post no bills. Everything not permitted is forbidden.]</source>
          <target state="translated">[This section still under construction. Ignore everything here. Post no bills. Everything not permitted is forbidden.]</target>
        </trans-unit>
        <trans-unit id="69f3514fe4449506ca2c5d0bbc28b3f3698032b0" translate="yes" xml:space="preserve">
          <source>[Well, it was in</source>
          <target state="translated">[Well, it was in</target>
        </trans-unit>
        <trans-unit id="88f04dbeb1493ee12988be863cfacc3c7afc777a" translate="yes" xml:space="preserve">
          <source>[linebreak]</source>
          <target state="translated">[linebreak]</target>
        </trans-unit>
        <trans-unit id="434d82c910fba2a895a5be59050f05f00a371e10" translate="yes" xml:space="preserve">
          <source>[r,t]</source>
          <target state="translated">[r,t]</target>
        </trans-unit>
        <trans-unit id="6018e494126b314973d815b3477ee1c68ccc6d49" translate="yes" xml:space="preserve">
          <source>[space][space]</source>
          <target state="translated">[space][space]</target>
        </trans-unit>
        <trans-unit id="cb559588de140bc32d992097ac9c98f627da21d3" translate="yes" xml:space="preserve">
          <source>\D is a negated \d; it represents any character but a digit</source>
          <target state="translated">\D is a negated \d; it represents any character but a digit</target>
        </trans-unit>
        <trans-unit id="6f370d6af4556227e5ea557e0c0431081559d1a3" translate="yes" xml:space="preserve">
          <source>\D is a negated \d; it represents any other character than a digit, or [^\d]</source>
          <target state="translated">\D is a negated \d; it represents any other character than a digit, or [^\d]</target>
        </trans-unit>
        <trans-unit id="483707e791c24bf4f182daf8d06032f62bf516af" translate="yes" xml:space="preserve">
          <source>\N</source>
          <target state="translated">\N</target>
        </trans-unit>
        <trans-unit id="4b60caece8e9624e4c91f3da6482cbb9fa5912e3" translate="yes" xml:space="preserve">
          <source>\N, like the period, matches any character but &quot;\n&quot;, but it does so regardless of whether the modifier &lt;code&gt;//s&lt;/code&gt; is in effect.</source>
          <target state="translated">\N, like the period, matches any character but &quot;\n&quot;, but it does so regardless of whether the modifier &lt;code&gt;//s&lt;/code&gt; is in effect.</target>
        </trans-unit>
        <trans-unit id="5201358bd3798962465786e1340b8d798eb0da66" translate="yes" xml:space="preserve">
          <source>\S is a negated \s; it represents any non-whitespace character</source>
          <target state="translated">\S is a negated \s; it represents any non-whitespace character</target>
        </trans-unit>
        <trans-unit id="2aaa2b30524de7ddb035b2ae4eda9d942f299a65" translate="yes" xml:space="preserve">
          <source>\S is a negated \s; it represents any non-whitespace character [^\s]</source>
          <target state="translated">\S is a negated \s; it represents any non-whitespace character [^\s]</target>
        </trans-unit>
        <trans-unit id="133129d31f2a64079b4ceec9832484853084047e" translate="yes" xml:space="preserve">
          <source>\W is a negated \w; it represents any non-word character</source>
          <target state="translated">\W is a negated \w; it represents any non-word character</target>
        </trans-unit>
        <trans-unit id="2f560e92ebecb72c198e33822a82e6e5d9a8c550" translate="yes" xml:space="preserve">
          <source>\W is a negated \w; it represents any non-word character [^\w]</source>
          <target state="translated">\W is a negated \w; it represents any non-word character [^\w]</target>
        </trans-unit>
        <trans-unit id="ddc0294fd2b2565335d9fa242ca21ab1de388250" translate="yes" xml:space="preserve">
          <source>\d is a digit and represents</source>
          <target state="translated">\d is a digit and represents</target>
        </trans-unit>
        <trans-unit id="97c6b30e873b86cfc47d930fe4d9ba2652595791" translate="yes" xml:space="preserve">
          <source>\d matches a digit, not just [0-9] but also digits from non-roman scripts</source>
          <target state="translated">\d matches a digit, not just [0-9] but also digits from non-roman scripts</target>
        </trans-unit>
        <trans-unit id="ef7e6794ca9c6a06b54b66f279237fb8daaaeea8" translate="yes" xml:space="preserve">
          <source>\n</source>
          <target state="translated">\n</target>
        </trans-unit>
        <trans-unit id="7b4662d5c71b2e001cf94c995515942d7af18900" translate="yes" xml:space="preserve">
          <source>\s is a whitespace character and represents</source>
          <target state="translated">\s is a whitespace character and represents</target>
        </trans-unit>
        <trans-unit id="34a39001363ef5f5ff61ce5c0f19ca73473f1c4c" translate="yes" xml:space="preserve">
          <source>\s matches a whitespace character, the set [\ \t\r\n\f] and others</source>
          <target state="translated">\s matches a whitespace character, the set [\ \t\r\n\f] and others</target>
        </trans-unit>
        <trans-unit id="5b2fc8d661205bb1347d335b86f497e98283eb99" translate="yes" xml:space="preserve">
          <source>\w is a word character (alphanumeric or _) and represents</source>
          <target state="translated">\w is a word character (alphanumeric or _) and represents</target>
        </trans-unit>
        <trans-unit id="9dec4b43c57ccafde6f9f014b8fdbdc6ad78db44" translate="yes" xml:space="preserve">
          <source>\w matches a word character (alphanumeric or _), not just [0-9a-zA-Z_] but also digits and characters from non-roman scripts</source>
          <target state="translated">\w matches a word character (alphanumeric or _), not just [0-9a-zA-Z_] but also digits and characters from non-roman scripts</target>
        </trans-unit>
        <trans-unit id="3ae3339d3df42bd81574a61520ae7ec1b26f3f20" translate="yes" xml:space="preserve">
          <source>\xXX</source>
          <target state="translated">\xXX</target>
        </trans-unit>
        <trans-unit id="4ff447b8ef42ca51fa6fb287bed8d40f49be58f1" translate="yes" xml:space="preserve">
          <source>]</source>
          <target state="translated">]</target>
        </trans-unit>
        <trans-unit id="5270612a32d634db637d354ac0c6c3ea3a691c4e" translate="yes" xml:space="preserve">
          <source>] ...]</source>
          <target state="translated">] ...]</target>
        </trans-unit>
        <trans-unit id="7ba1b0d7168057117598130b4cf4913ce7a6d1dd" translate="yes" xml:space="preserve">
          <source>] [</source>
          <target state="translated">] [</target>
        </trans-unit>
        <trans-unit id="e5f96af2d25deb494bcf280fcc22ad9c64b0b550" translate="yes" xml:space="preserve">
          <source>] [ &lt;b&gt;--&lt;/b&gt; ] [</source>
          <target state="translated">] [ &lt;b&gt;--&lt;/b&gt; ] [</target>
        </trans-unit>
        <trans-unit id="7837a05d80f9d4246db05db7739ac9da350692ee" translate="yes" xml:space="preserve">
          <source>] [ &lt;b&gt;-A&lt;/b&gt; ] [ &lt;b&gt;-ok&lt;/b&gt; | &lt;b&gt;-okay&lt;/b&gt; | &lt;b&gt;-nok&lt;/b&gt; | &lt;b&gt;-nokay&lt;/b&gt; ]</source>
          <target state="translated">] [ &lt;b&gt;-A&lt;/b&gt; ] [ &lt;b&gt;-ok&lt;/b&gt; | &lt;b&gt;-okay&lt;/b&gt; | &lt;b&gt;-nok&lt;/b&gt; | &lt;b&gt;-nokay&lt;/b&gt; ]</target>
        </trans-unit>
        <trans-unit id="5d5d86b624a368f240fc8ef717bfac5763b684cc" translate="yes" xml:space="preserve">
          <source>] [ &lt;b&gt;-F&lt;/b&gt;</source>
          <target state="translated">] [ &lt;b&gt;-F&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fa5aee76641c8374c4a3bb363faca409d18cd95d" translate="yes" xml:space="preserve">
          <source>] [ &lt;b&gt;-M&lt;/b&gt;[&lt;b&gt;-&lt;/b&gt;]</source>
          <target state="translated">] [ &lt;b&gt;-M&lt;/b&gt;[&lt;b&gt;-&lt;/b&gt;]</target>
        </trans-unit>
        <trans-unit id="fe33edc3b5acacf101538a5199d8ef6004372824" translate="yes" xml:space="preserve">
          <source>] [ &lt;b&gt;-b&lt;/b&gt;</source>
          <target state="translated">] [ &lt;b&gt;-b&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d91a8c76a043075cdd5f57b8dc8dd020742dc547" translate="yes" xml:space="preserve">
          <source>] [ &lt;b&gt;-c&lt;/b&gt;</source>
          <target state="translated">] [ &lt;b&gt;-c&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4088d7468ddaef6b6676933981d369aadcae05a4" translate="yes" xml:space="preserve">
          <source>] [ &lt;b&gt;-e&lt;/b&gt;</source>
          <target state="translated">] [ &lt;b&gt;-e&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d446bd20cd4f210e32dddf0953007e6f2d1b5053" translate="yes" xml:space="preserve">
          <source>] [ &lt;b&gt;-f&lt;/b&gt; ] [ &lt;b&gt;-C [&lt;i&gt;number/list&lt;/i&gt;] &lt;/b&gt;] [ &lt;b&gt;-S&lt;/b&gt; ] [ &lt;b&gt;-x&lt;/b&gt;[</source>
          <target state="translated">] [ &lt;b&gt;-f&lt;/b&gt; ] [ &lt;b&gt;-C [&lt;i&gt;number/list&lt;/i&gt;] &lt;/b&gt;] [ &lt;b&gt;-S&lt;/b&gt; ] [ &lt;b&gt;-x&lt;/b&gt;[</target>
        </trans-unit>
        <trans-unit id="aca1a0eb03ef6c4968553072034eeee79bad305b" translate="yes" xml:space="preserve">
          <source>] [ &lt;b&gt;-l&lt;/b&gt;[</source>
          <target state="translated">] [ &lt;b&gt;-l&lt;/b&gt;[</target>
        </trans-unit>
        <trans-unit id="f481bbb7a3ba5ecc6ab5d2ec8921b0caad222177" translate="yes" xml:space="preserve">
          <source>] [ &lt;b&gt;-m&lt;/b&gt;[&lt;b&gt;-&lt;/b&gt;]</source>
          <target state="translated">] [ &lt;b&gt;-m&lt;/b&gt;[&lt;b&gt;-&lt;/b&gt;]</target>
        </trans-unit>
        <trans-unit id="7be946169865caf0b4ad4e1c551c97f832b6089b" translate="yes" xml:space="preserve">
          <source>] [ &lt;b&gt;-r&lt;/b&gt;</source>
          <target state="translated">] [ &lt;b&gt;-r&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3b371bc5f1731a182afaca0f4c21e6e42f754174" translate="yes" xml:space="preserve">
          <source>] [ &lt;b&gt;-s&lt;/b&gt;</source>
          <target state="translated">] [ &lt;b&gt;-s&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1cab1fd629b30db28801a88fb200dff0c7358250" translate="yes" xml:space="preserve">
          <source>] [ &lt;code&gt;,&lt;/code&gt; [</source>
          <target state="translated">] [ &lt;code&gt;,&lt;/code&gt; [</target>
        </trans-unit>
        <trans-unit id="60ce1ac427ca955aba7df5e26e666a0cbcdc2f9a" translate="yes" xml:space="preserve">
          <source>] [&lt;b&gt;--date&lt;/b&gt;=</source>
          <target state="translated">] [&lt;b&gt;--date&lt;/b&gt;=</target>
        </trans-unit>
        <trans-unit id="d95dd25605574b2c81782f8507419949dc89534a" translate="yes" xml:space="preserve">
          <source>] [&lt;b&gt;--errors&lt;/b&gt;=</source>
          <target state="translated">] [&lt;b&gt;--errors&lt;/b&gt;=</target>
        </trans-unit>
        <trans-unit id="fbbc117050d9385ff235a1dc760a3b8dfa0999cc" translate="yes" xml:space="preserve">
          <source>] [&lt;b&gt;--fixed&lt;/b&gt;=</source>
          <target state="translated">] [&lt;b&gt;--fixed&lt;/b&gt;=</target>
        </trans-unit>
        <trans-unit id="a9250074a5445bcf8eef004dc71ec67ecb9c809b" translate="yes" xml:space="preserve">
          <source>] [&lt;b&gt;--fixedbold&lt;/b&gt;=</source>
          <target state="translated">] [&lt;b&gt;--fixedbold&lt;/b&gt;=</target>
        </trans-unit>
        <trans-unit id="d7f9db810e921cd28d21cd440fca4722b8d4bf69" translate="yes" xml:space="preserve">
          <source>] [&lt;b&gt;--fixedbolditalic&lt;/b&gt;=</source>
          <target state="translated">] [&lt;b&gt;--fixedbolditalic&lt;/b&gt;=</target>
        </trans-unit>
        <trans-unit id="aa2fbdd948dba01a46110fa01725308ca2ef5a08" translate="yes" xml:space="preserve">
          <source>] [&lt;b&gt;--fixeditalic&lt;/b&gt;=</source>
          <target state="translated">] [&lt;b&gt;--fixeditalic&lt;/b&gt;=</target>
        </trans-unit>
        <trans-unit id="6fe77b356c6468bc7d92a318ad6bc1146c2e9172" translate="yes" xml:space="preserve">
          <source>] [&lt;b&gt;--name&lt;/b&gt;=</source>
          <target state="translated">] [&lt;b&gt;--name&lt;/b&gt;=</target>
        </trans-unit>
        <trans-unit id="39d7370445bc798950f647a09f55cf0aa24d1af4" translate="yes" xml:space="preserve">
          <source>] [&lt;b&gt;--nourls&lt;/b&gt;] [&lt;b&gt;--official&lt;/b&gt;] [&lt;b&gt;--quotes&lt;/b&gt;=</source>
          <target state="translated">] [&lt;b&gt;--nourls&lt;/b&gt;] [&lt;b&gt;--official&lt;/b&gt;] [&lt;b&gt;--quotes&lt;/b&gt;=</target>
        </trans-unit>
        <trans-unit id="3ec1ee1005b040af6eed1e1fb1b89be01226d9ce" translate="yes" xml:space="preserve">
          <source>] [&lt;b&gt;--nourls&lt;/b&gt;] [&lt;b&gt;--stderr&lt;/b&gt;] [&lt;b&gt;-w&lt;/b&gt;</source>
          <target state="translated">] [&lt;b&gt;--nourls&lt;/b&gt;] [&lt;b&gt;--stderr&lt;/b&gt;] [&lt;b&gt;-w&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fc864e3beb0db82da5fea274b5d83179e2d64279" translate="yes" xml:space="preserve">
          <source>] [&lt;b&gt;--release&lt;/b&gt;[=</source>
          <target state="translated">] [&lt;b&gt;--release&lt;/b&gt;[=</target>
        </trans-unit>
        <trans-unit id="039bb11ec7e8c6197572dde03eb7f6b45f6c8aa6" translate="yes" xml:space="preserve">
          <source>] [&lt;b&gt;--stderr&lt;/b&gt;] [&lt;b&gt;--utf8&lt;/b&gt;] [&lt;b&gt;--verbose&lt;/b&gt;] [</source>
          <target state="translated">] [&lt;b&gt;--stderr&lt;/b&gt;] [&lt;b&gt;--utf8&lt;/b&gt;] [&lt;b&gt;--verbose&lt;/b&gt;] [</target>
        </trans-unit>
        <trans-unit id="a4b5a58dd7ad938ef0e7ae582da7c0d873b1c242" translate="yes" xml:space="preserve">
          <source>] [&lt;b&gt;-formatter&lt;/b&gt;</source>
          <target state="translated">] [&lt;b&gt;-formatter&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3fea5aca88ab916f93ed287dace98a76f7c143b9" translate="yes" xml:space="preserve">
          <source>] [&lt;b&gt;-i&lt;/b&gt;</source>
          <target state="translated">] [&lt;b&gt;-i&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="53f6bda63d23372157c365e9965c7ef45e33a277" translate="yes" xml:space="preserve">
          <source>] [&lt;b&gt;-output&lt;/b&gt;</source>
          <target state="translated">] [&lt;b&gt;-output&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="18e0dd56af29c5174edbefe6f7085682dda6e116" translate="yes" xml:space="preserve">
          <source>] [&lt;b&gt;-pathlist&lt;/b&gt;</source>
          <target state="translated">] [&lt;b&gt;-pathlist&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="22e124d430902d5c5221cf1c7cf4da237a26222d" translate="yes" xml:space="preserve">
          <source>] [&lt;b&gt;-q&lt;/b&gt;</source>
          <target state="translated">] [&lt;b&gt;-q&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0fde4e5d48f00a1e501ad8fe7e8926bde75175b1" translate="yes" xml:space="preserve">
          <source>] [&lt;b&gt;-verbose&lt;/b&gt;</source>
          <target state="translated">] [&lt;b&gt;-verbose&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e725a8e5ac100bccc71bd3fa100f49857c67db06" translate="yes" xml:space="preserve">
          <source>] ] &lt;code&gt;}&lt;/code&gt;.</source>
          <target state="translated">] ] &lt;code&gt;}&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="840af7de6cad4319ff4be78eacfb9c5acf43cf39" translate="yes" xml:space="preserve">
          <source>] ] [ &lt;b&gt;-0&lt;/b&gt;[</source>
          <target state="translated">] ] [ &lt;b&gt;-0&lt;/b&gt;[</target>
        </trans-unit>
        <trans-unit id="9bd44ceffbf549e2ad098d1002b1d677b7d0aa0b" translate="yes" xml:space="preserve">
          <source>] ] [ &lt;b&gt;-D&lt;/b&gt;[</source>
          <target state="translated">] ] [ &lt;b&gt;-D&lt;/b&gt;[</target>
        </trans-unit>
        <trans-unit id="7bb86a5d6f5da412edc5fa8d69ccfe2ff581bca6" translate="yes" xml:space="preserve">
          <source>] ] [ &lt;b&gt;-I&lt;/b&gt;</source>
          <target state="translated">] ] [ &lt;b&gt;-I&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="598e07f95f029fa4f2ce352acaf2288c664b4b76" translate="yes" xml:space="preserve">
          <source>] ] [ &lt;b&gt;-cw&lt;/b&gt; ] [ &lt;b&gt;-d&lt;/b&gt;[&lt;b&gt;t&lt;/b&gt;][:</source>
          <target state="translated">] ] [ &lt;b&gt;-cw&lt;/b&gt; ] [ &lt;b&gt;-d&lt;/b&gt;[&lt;b&gt;t&lt;/b&gt;][:</target>
        </trans-unit>
        <trans-unit id="9db4a34f3f65d57a976aae91bae6f7bcb0835f01" translate="yes" xml:space="preserve">
          <source>] ] [ &lt;b&gt;-i&lt;/b&gt;[</source>
          <target state="translated">] ] [ &lt;b&gt;-i&lt;/b&gt;[</target>
        </trans-unit>
        <trans-unit id="9d460c5f4d3c2477cabad0ac755529bb24fc2217" translate="yes" xml:space="preserve">
          <source>] ] [ &lt;b&gt;-pna&lt;/b&gt; ] [ &lt;b&gt;-F&lt;/b&gt;</source>
          <target state="translated">] ] [ &lt;b&gt;-pna&lt;/b&gt; ] [ &lt;b&gt;-F&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fc8d2ac6bf0f644f728f5f8cfc8080a8f51efa0e" translate="yes" xml:space="preserve">
          <source>] ] [ [&lt;b&gt;-e&lt;/b&gt;|&lt;b&gt;-E&lt;/b&gt;]</source>
          <target state="translated">] ] [ [&lt;b&gt;-e&lt;/b&gt;|&lt;b&gt;-E&lt;/b&gt;]</target>
        </trans-unit>
        <trans-unit id="9a7dbaad3cf2aa9abf7389e31afb732d6e15865c" translate="yes" xml:space="preserve">
          <source>]. I.e., &quot;_1&quot; becomes with $_[1], and &quot;_-3&quot; is interpreted as $_[-3] (in which case @_ should have at least three elements in it). Note that $_[0] is the language handle, and is typically not named directly.</source>
          <target state="translated">]. I.e., &quot;_1&quot; becomes with $_[1], and &quot;_-3&quot; is interpreted as $_[-3] (in which case @_ should have at least three elements in it). Note that $_[0] is the language handle, and is typically not named directly.</target>
        </trans-unit>
        <trans-unit id="3fad04c26433591d23451512c23642ef92daf2c6" translate="yes" xml:space="preserve">
          <source>]...</source>
          <target state="translated">]...</target>
        </trans-unit>
        <trans-unit id="36407ed3b603d0dfcd1bd6d50bc3fd8861d8d53f" translate="yes" xml:space="preserve">
          <source>][&lt;b&gt;,-p&lt;/b&gt;][&lt;b&gt;,-q&lt;/b&gt;][&lt;b&gt;,-l&lt;/b&gt;] [&lt;b&gt;,-s&lt;/b&gt;</source>
          <target state="translated">][&lt;b&gt;,-p&lt;/b&gt;][&lt;b&gt;,-q&lt;/b&gt;][&lt;b&gt;,-l&lt;/b&gt;] [&lt;b&gt;,-s&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a9030ca5cbcfd3f3b2ec230506e50fbd3cb2d7e0" translate="yes" xml:space="preserve">
          <source>][&lt;b&gt;,-x&lt;/b&gt;</source>
          <target state="translated">][&lt;b&gt;,-x&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8755a99ada779c83177a95e225a5063fe7499c98" translate="yes" xml:space="preserve">
          <source>]] [&lt;b&gt;--section&lt;/b&gt;=</source>
          <target state="translated">]] [&lt;b&gt;--section&lt;/b&gt;=</target>
        </trans-unit>
        <trans-unit id="52fd940d0f74d5bee59eaa7c4f0549763254e747" translate="yes" xml:space="preserve">
          <source>_AUTHORS_</source>
          <target state="translated">_AUTHORS_</target>
        </trans-unit>
        <trans-unit id="6b18f91a4d56bcb4195d01326c1707f269dca59a" translate="yes" xml:space="preserve">
          <source>_FFFE and 0x</source>
          <target state="translated">_FFFE and 0x</target>
        </trans-unit>
        <trans-unit id="9ab76b9bb5c2c00731a6298f38a4cee313b768d1" translate="yes" xml:space="preserve">
          <source>_FFFF), all non-shortest encodings, etc.</source>
          <target state="translated">_FFFF), all non-shortest encodings, etc.</target>
        </trans-unit>
        <trans-unit id="335f29be57bcf11c73c32f1eb934a4263c82062e" translate="yes" xml:space="preserve">
          <source>_MANIFEST_</source>
          <target state="translated">_MANIFEST_</target>
        </trans-unit>
        <trans-unit id="95a35cef151f823296dfad3b7387390964178aff" translate="yes" xml:space="preserve">
          <source>_PDF_ files</source>
          <target state="translated">_PDF_ files</target>
        </trans-unit>
        <trans-unit id="a004e5d824ef48686abd54ae20b660d4a2c545c5" translate="yes" xml:space="preserve">
          <source>_Really_ Symbolic Calculator</source>
          <target state="translated">_Really_ Symbolic Calculator</target>
        </trans-unit>
        <trans-unit id="544b04467d0a8ee1a845e4b919a57d9da6144a5e" translate="yes" xml:space="preserve">
          <source>__DATA__</source>
          <target state="translated">__DATA__</target>
        </trans-unit>
        <trans-unit id="c7919376414e8b09a0411c19eee34a71902436cc" translate="yes" xml:space="preserve">
          <source>__DATA__, __END__, and the FOOBAR::DATA filehandle.</source>
          <target state="translated">__DATA__, __END__, and the FOOBAR::DATA filehandle.</target>
        </trans-unit>
        <trans-unit id="ce8a6e08bc25f2ef37956e900401265cf56138c8" translate="yes" xml:space="preserve">
          <source>__END__</source>
          <target state="translated">__END__</target>
        </trans-unit>
        <trans-unit id="9d5d8995523b8b8951428baa81ea663ff0bd2c77" translate="yes" xml:space="preserve">
          <source>__FILE__</source>
          <target state="translated">__FILE__</target>
        </trans-unit>
        <trans-unit id="a51b95694c81c92580bff6f580f8e200ecf86661" translate="yes" xml:space="preserve">
          <source>__LINE__</source>
          <target state="translated">__LINE__</target>
        </trans-unit>
        <trans-unit id="04bd40a79312fa43a624aef25ac864c0770871a3" translate="yes" xml:space="preserve">
          <source>__PACKAGE__</source>
          <target state="translated">__PACKAGE__</target>
        </trans-unit>
        <trans-unit id="b0563c4fda49219aeb921efb5a63d4cff221a59b" translate="yes" xml:space="preserve">
          <source>__SUB__</source>
          <target state="translated">__SUB__</target>
        </trans-unit>
        <trans-unit id="aba4564d3c1fb21ecf21279947a269bfd72d5448" translate="yes" xml:space="preserve">
          <source>__int64</source>
          <target state="translated">__int64</target>
        </trans-unit>
        <trans-unit id="3485357323ef68368533ee148f92fcc38f19f972" translate="yes" xml:space="preserve">
          <source>_bgcd()</source>
          <target state="translated">_bgcd()</target>
        </trans-unit>
        <trans-unit id="3cde53170729285b62e4195015718cc3fccd9d47" translate="yes" xml:space="preserve">
          <source>_control87(3)</source>
          <target state="translated">_control87(3)</target>
        </trans-unit>
        <trans-unit id="ff4fbe22558273c6659ff3e79e3859bcae2f877b" translate="yes" xml:space="preserve">
          <source>_digit($obj, 0)</source>
          <target state="translated">_digit($obj, 0)</target>
        </trans-unit>
        <trans-unit id="25fb2a539a78bedeb7219e53f2b8469577c24022" translate="yes" xml:space="preserve">
          <source>_digit(123, -1)</source>
          <target state="translated">_digit(123, -1)</target>
        </trans-unit>
        <trans-unit id="a23c4cef0829fb103be12bd8e5048bf513e4694f" translate="yes" xml:space="preserve">
          <source>_perl.exe_</source>
          <target state="translated">_perl.exe_</target>
        </trans-unit>
        <trans-unit id="2f72a716af3238025dd4229dd58b83bc8629ac38" translate="yes" xml:space="preserve">
          <source>_perl_.exe_</source>
          <target state="translated">_perl_.exe_</target>
        </trans-unit>
        <trans-unit id="5991d513b9abe99f11e9b16c8256e4e9e06ca2ba" translate="yes" xml:space="preserve">
          <source>_perl__.exe_</source>
          <target state="translated">_perl__.exe_</target>
        </trans-unit>
        <trans-unit id="2db94965490eada37ae5ff14a1e0846dbe050e7c" translate="yes" xml:space="preserve">
          <source>_perl___.exe_</source>
          <target state="translated">_perl___.exe_</target>
        </trans-unit>
        <trans-unit id="1fdbb463b8aba017e1e17708622b828c0a70d691" translate="yes" xml:space="preserve">
          <source>_prove</source>
          <target state="translated">_prove</target>
        </trans-unit>
        <trans-unit id="998aae22ec5a43bf133ffb2d411823f4c8a72a20" translate="yes" xml:space="preserve">
          <source>_proverc</source>
          <target state="translated">_proverc</target>
        </trans-unit>
        <trans-unit id="be410059a97a4524ce3b914f3e9c9e407663c029" translate="yes" xml:space="preserve">
          <source>_read</source>
          <target state="translated">_read</target>
        </trans-unit>
        <trans-unit id="8f67b7c018384a0d10f9d2b4577d0c0658bc078a" translate="yes" xml:space="preserve">
          <source>_stdlib.h_ functions</source>
          <target state="translated">_stdlib.h_ functions</target>
        </trans-unit>
        <trans-unit id="d4086139b290958ed25f5bd7a1ff3d730dcf31a9" translate="yes" xml:space="preserve">
          <source>_sub()</source>
          <target state="translated">_sub()</target>
        </trans-unit>
        <trans-unit id="ab1aafd933e3c1f34b78838ca464fabb2cd4e4ef" translate="yes" xml:space="preserve">
          <source>_utf8_off</source>
          <target state="translated">_utf8_off</target>
        </trans-unit>
        <trans-unit id="17db770cf15f37a3c9f4bbc8584367bfd333dd75" translate="yes" xml:space="preserve">
          <source>_utf8_on</source>
          <target state="translated">_utf8_on</target>
        </trans-unit>
        <trans-unit id="349a2cf958187a837c3aed60aca5ce84a2ba8f78" translate="yes" xml:space="preserve">
          <source>`Memoizing' a function makes it faster by trading space for time. It does this by caching the return values of the function in a table. If you call the function again with the same arguments, &lt;code&gt;memoize&lt;/code&gt; jumps in and gives you the value out of the table, instead of letting the function compute the value all over again.</source>
          <target state="translated">`Memoizing' a function makes it faster by trading space for time. It does this by caching the return values of the function in a table. If you call the function again with the same arguments, &lt;code&gt;memoize&lt;/code&gt; jumps in and gives you the value out of the table, instead of letting the function compute the value all over again.</target>
        </trans-unit>
        <trans-unit id="97a327decd1b5a73620456539cf89766d09acb8c" translate="yes" xml:space="preserve">
          <source>`` and pipe-open do not work under DOS.</source>
          <target state="translated">`` and pipe-open do not work under DOS.</target>
        </trans-unit>
        <trans-unit id="86f7e437faa5a7fce15d1ddcb9eaeaea377667b8" translate="yes" xml:space="preserve">
          <source>a</source>
          <target state="translated">a</target>
        </trans-unit>
        <trans-unit id="049537f8ff01227a5296e1d4f8184a98a3f6ecb6" translate="yes" xml:space="preserve">
          <source>a &lt;b&gt;-u&lt;/b&gt; flag to make it unbuffered. But very few commands are designed to operate over pipes, so this seldom works unless you yourself wrote the program on the other end of the double-ended pipe.</source>
          <target state="translated">버퍼링하지 않도록 하는 &lt;b&gt;-u&lt;/b&gt; 플래그. 그러나 파이프를 통해 작동하도록 설계된 명령은 거의 없으므로 이중 종단 파이프의 다른 쪽 끝에서 프로그램을 작성하지 않은 경우에는 거의 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="29515f80a90ad15c4d7bd700ddff82308e27f071" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;DESTROY&lt;/code&gt; method), which the call to &lt;code&gt;EVERY::LAST::Destroy&lt;/code&gt; in the inherited destructor then correctly picks up.</source>
          <target state="translated">상속 된 소멸자에서 &lt;code&gt;EVERY::LAST::Destroy&lt;/code&gt; 에 대한 호출이 올바르게 선택 되는 &lt;code&gt;DESTROY&lt;/code&gt; 메소드) .</target>
        </trans-unit>
        <trans-unit id="5b4991d0075936f9dd187e536d33c94e2aa27450" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;new&lt;/code&gt; method), which the call to &lt;code&gt;EVERY::LAST::Init&lt;/code&gt; in the inherited constructor then correctly picks up.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 호출 방법), &lt;code&gt;EVERY::LAST::Init&lt;/code&gt; 상속 생성자는 다음 올바르게 선택합니다.</target>
        </trans-unit>
        <trans-unit id="c969393479d626630230a3b33439fab76b06b48e" translate="yes" xml:space="preserve">
          <source>a PREFIX was given as an argument to WriteMakefile() it will set it to the $new_prefix + $default. This is for systems whose file layouts don't neatly fit into our ideas of prefixes.</source>
          <target state="translated">PREFIX는 WriteMakefile ()에 대한 인수로 제공되었으며 $ new_prefix + $ default로 설정됩니다. 이것은 파일 레이아웃이 우리의 접두사 아이디어에 잘 맞지 않는 시스템을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="1e7f6022e597b2747e658cd9274fe1392855ea63" translate="yes" xml:space="preserve">
          <source>a Pod block with a &quot;=cut&quot; command. In that case, the Pod processor must halt parsing of the input file, and must by default emit a warning.</source>
          <target state="translated">&quot;= cut&quot;명령이있는 포드 블록 이 경우 포드 프로세서는 입력 파일의 구문 분석을 중지해야하며 기본적으로 경고를 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="a295228fd9bd780a4f55d14f8063050501961916" translate="yes" xml:space="preserve">
          <source>a blank (read: empty) line, with the single exception of the file start, which is also starting a paragraph. That means that especially a command (e.g. &lt;code&gt;=head1&lt;/code&gt; )</source>
          <target state="translated">단락을 시작하는 파일 시작을 제외하고 공백 (읽기 : 비어 있음) 행 즉, 특히 명령 (예 : &lt;code&gt;=head1&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="75c1385dc7bf5ab285efa7812871a616728a97fa" translate="yes" xml:space="preserve">
          <source>a blank line.</source>
          <target state="translated">빈 줄.</target>
        </trans-unit>
        <trans-unit id="23d9744ba98ffa764233c38e2d3604f3b2d4a76e" translate="yes" xml:space="preserve">
          <source>a bytestream and should not be treated as such. This makes using I/O mechanisms with internal buffering like stdio (i.e. print() and friends) especially cumbersome. Use syswrite(), or better send(), like in the example below.</source>
          <target state="translated">바이트 스트림이므로 취급해서는 안됩니다. stdio (예 : print () 및 friends)와 같은 내부 버퍼링이있는 I / O 메커니즘을 사용하면 특히 번거 롭습니다. 아래 예와 같이 syswrite () 또는 더 나은 send ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="633f7c37ae295810943767d3bf2df992ec0feaea" translate="yes" xml:space="preserve">
          <source>a call to &lt;code&gt;SvPV()&lt;/code&gt; or one of its variants, in case any call to string overloading updates the internal UTF-8 encoding flag.</source>
          <target state="translated">호출 &lt;code&gt;SvPV()&lt;/code&gt; 또는 그의 변이체의 하나의 스트링에 과부하 업데이트 경우 모든 통화 내부 UTF-8 인코딩 플래그.</target>
        </trans-unit>
        <trans-unit id="3db5176b71e2550579d05b0d599c0802a2e9855b" translate="yes" xml:space="preserve">
          <source>a call to SvPV() or one of its variants, in case any call to string overloading updates the internal flag.</source>
          <target state="translated">문자열 오버로드를 호출하면 내부 플래그가 업데이트되는 경우 SvPV () 또는 해당 변형 중 하나를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="8e150fc9a00a9d6aba574abf6b3ddaf310665b85" translate="yes" xml:space="preserve">
          <source>a caller (that is, if we're in a subroutine or &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;) and the undefined value otherwise. caller never returns XS subs and they are skipped. The next pure perl sub will appear instead of the XS sub in caller's return values. In list context, caller returns</source>
          <target state="translated">호출자 (즉, 우리가 서브 루틴이나 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 있거나 &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; )와 그렇지 않으면 정의되지 않은 값. 호출자는 XS 서브를 반환하지 않으며 건너 뜁니다. 발신자의 반환 값에 XS 하위 대신 다음 순수 펄 하위가 나타납니다. 목록 컨텍스트에서 호출자는</target>
        </trans-unit>
        <trans-unit id="27f90951a846aad1e51cfa906ae9aae15befd397" translate="yes" xml:space="preserve">
          <source>a caller (that is, if we're in a subroutine or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;) and the undefined value otherwise. caller never returns XS subs and they are skipped. The next pure perl sub will appear instead of the XS sub in caller's return values. In list context, caller returns</source>
          <target state="translated">호출자 (즉, 우리가 서브 루틴이나 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 있거나 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; )와 그렇지 않으면 정의되지 않은 값. 호출자는 XS 서브를 반환하지 않으며 건너 뜁니다. 발신자의 반환 값에 XS 하위 대신 다음 순수 펄 하위가 나타납니다. 목록 컨텍스트에서 호출자는</target>
        </trans-unit>
        <trans-unit id="98a69b7d014f4c34538d96daa513e20ae3249ccf" translate="yes" xml:space="preserve">
          <source>a character</source>
          <target state="translated">캐릭터</target>
        </trans-unit>
        <trans-unit id="4d30a63fe6161c410a2de8ef976b935b79ebde5a" translate="yes" xml:space="preserve">
          <source>a directory which the extensions Perl library module passes to the DynaLoader when asking it to map the shareable image, or</source>
          <target state="translated">확장 가능 Perl 라이브러리 모듈이 공유 가능한 이미지를 맵핑하도록 요청할 때 DynaLoader에 전달하는 디렉토리 또는</target>
        </trans-unit>
        <trans-unit id="d53e127062317983028dd489e9754291d72caa45" translate="yes" xml:space="preserve">
          <source>a dummy implementation.</source>
          <target state="translated">더미 구현.</target>
        </trans-unit>
        <trans-unit id="607bd3e7b2e3b5390e3bf8ef6a8b9efe50dc7299" translate="yes" xml:space="preserve">
          <source>a failure of the OS/2 API call, having some workarounds coded).</source>
          <target state="translated">일부 해결 방법이 코딩 된 OS / 2 API 호출 실패).</target>
        </trans-unit>
        <trans-unit id="f2f9eb42b04a6bb70eb81a0ae0a802e7347d6301" translate="yes" xml:space="preserve">
          <source>a filehandle, even though it looks like one). DBNAME is the name of the database (without the</source>
          <target state="translated">파일 핸들처럼 보이지만). DBNAME은 데이터베이스 이름입니다 (</target>
        </trans-unit>
        <trans-unit id="d89a37a0200dc0b35d04809afbc53cbf5901983a" translate="yes" xml:space="preserve">
          <source>a function, and precedence doesn't matter. Otherwise it's a list operator or unary operator, and precedence does matter. Whitespace between the function and left parenthesis doesn't count, so sometimes you need to be careful:</source>
          <target state="translated">기능과 우선 순위는 중요하지 않습니다. 그렇지 않으면 목록 연산자 또는 단항 연산자이며 우선 순위가 중요합니다. 함수와 왼쪽 괄호 사이의 공백은 포함되지 않으므로 때때로주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="42d8657e92871e593008c5368345a46e3ebc4eac" translate="yes" xml:space="preserve">
          <source>a hard reference. If you use it as a reference, it'll be treated as a symbolic reference. That is, the value of the scalar is taken to be the</source>
          <target state="translated">어려운 참조. 참조로 사용하면 기호 참조로 취급됩니다. 즉, 스칼라의 값은</target>
        </trans-unit>
        <trans-unit id="b47a8f555bfc4607fa743152b516f486d86995c9" translate="yes" xml:space="preserve">
          <source>a leading &quot;:&quot;. Empty portions are returned as empty string ''.</source>
          <target state="translated">선행 &quot;:&quot;. 빈 부분은 빈 문자열 ''로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c3ead9f1232af179bcf0c56760a744aa581fa638" translate="yes" xml:space="preserve">
          <source>a long time ago, and some people got used to our funny spelling, and so just as with &lt;code&gt;HTTP_REFERER&lt;/code&gt; &amp;rsquo;s own missing letter, our weird spelling has stuck around.</source>
          <target state="translated">오래 전에, 어떤 사람들은 우리의 재미있는 철자법에 익숙해졌고, &lt;code&gt;HTTP_REFERER&lt;/code&gt; 의 자신의 잃어버린 글자 와 마찬가지로 , 우리의 이상한 철자법이 고착되었습니다.</target>
        </trans-unit>
        <trans-unit id="c5ab2e702917e9fab9c642c3876da1a3b4538ce1" translate="yes" xml:space="preserve">
          <source>a mergesort, which happens to be stable, will be employed anyway. Note that</source>
          <target state="translated">어쨌든 안정적인 병합 정렬이 사용됩니다. 참고</target>
        </trans-unit>
        <trans-unit id="02537a2b811222631d1996c38165a9255a043dba" translate="yes" xml:space="preserve">
          <source>a noun (i.e., saying how much of it there is, while giving the correct form of it). The behavior of this method is handy for English and a few other Western European languages, and you should override it for languages where it's not suitable. You can feel free to read the source, but the current implementation is basically as this pseudocode describes:</source>
          <target state="translated">명사 (즉, 단어의 정확한 형태를 제공하면서 단어가 얼마나 있는지를 말함). 이 방법의 동작은 영어 및 일부 다른 서유럽 언어에 유용하며 적합하지 않은 언어에 대해서는 재정의해야합니다. 소스를 자유롭게 읽을 수 있지만 현재 구현은 기본적으로이 의사 코드가 설명하는대로입니다.</target>
        </trans-unit>
        <trans-unit id="cbaad0f8fdd1c074dd23e8663bc741bba26c0e9b" translate="yes" xml:space="preserve">
          <source>a number &lt;code&gt;OS_MAJOR + 0.001 * OS_MINOR&lt;/code&gt; .</source>
          <target state="translated">숫자 &lt;code&gt;OS_MAJOR + 0.001 * OS_MINOR&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20b1aa3e6979f290ef40d1e602b1d7ee858c53e5" translate="yes" xml:space="preserve">
          <source>a parse error.</source>
          <target state="translated">구문 분석 오류</target>
        </trans-unit>
        <trans-unit id="36958640033ae606fe1d0a4aeb5cf8119f6964e4" translate="yes" xml:space="preserve">
          <source>a particular place, in combination with non-linguistic location-specific information such as what currency is used there. Locales</source>
          <target state="translated">어떤 통화가 사용되는지와 같은 비언어적 위치 별 정보와 함께 특정 장소. 로케일</target>
        </trans-unit>
        <trans-unit id="427679a88e71c9d05f75a15acaaf64e423868907" translate="yes" xml:space="preserve">
          <source>a posteriori</source>
          <target state="translated">후손</target>
        </trans-unit>
        <trans-unit id="a7361da6063a7ceef198f250842e89b36593b797" translate="yes" xml:space="preserve">
          <source>a reference to a &lt;code&gt;Pod::Paragraph&lt;/code&gt; object which contains further information about the paragraph (see &lt;a href=&quot;inputobjects&quot;&gt;Pod::InputObjects&lt;/a&gt; for details).</source>
          <target state="translated">단락에 대한 추가 정보가 포함 된 &lt;code&gt;Pod::Paragraph&lt;/code&gt; 객체에 대한 참조입니다 (자세한 내용은 &lt;a href=&quot;inputobjects&quot;&gt;Pod :: InputObjects&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="c80e050c47afd7c7439491b82841365aa5c3f43a" translate="yes" xml:space="preserve">
          <source>a reference to a &lt;code&gt;Pod::Paragraph&lt;/code&gt; object which contains further information about the paragraph command (see &lt;a href=&quot;inputobjects&quot;&gt;Pod::InputObjects&lt;/a&gt; for details).</source>
          <target state="translated">단락 명령에 대한 추가 정보가 포함 된 &lt;code&gt;Pod::Paragraph&lt;/code&gt; 객체에 대한 참조입니다 (자세한 내용은 &lt;a href=&quot;inputobjects&quot;&gt;Pod :: InputObjects&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="f1cf41b67f8ac934bdb1895a8415ee32895dafcf" translate="yes" xml:space="preserve">
          <source>a reference to the subroutine;</source>
          <target state="translated">서브 루틴에 대한 참조;</target>
        </trans-unit>
        <trans-unit id="c10bb3ae2e9e12614dc451b112b763b0e4c6ea09" translate="yes" xml:space="preserve">
          <source>a reference to the symbol table entry (typeglob) containing the subroutine;</source>
          <target state="translated">서브 루틴을 포함하는 심볼 테이블 엔트리 (typeglob)에 대한 참조;</target>
        </trans-unit>
        <trans-unit id="716ec8e228f41268238a19d64c81add7c59efa1b" translate="yes" xml:space="preserve">
          <source>a regex:</source>
          <target state="translated">정규식 :</target>
        </trans-unit>
        <trans-unit id="ff9123773c3af11dc4fc6c1bb3d5deb9aca9a8cf" translate="yes" xml:space="preserve">
          <source>a regexp and backreferences &lt;code&gt;\g1&lt;/code&gt; , &lt;code&gt;\g2&lt;/code&gt; ,... only</source>
          <target state="translated">정규 표현식과 역 참조 &lt;code&gt;\g1&lt;/code&gt; , &lt;code&gt;\g2&lt;/code&gt; , ... 만</target>
        </trans-unit>
        <trans-unit id="01acfa70c00b2c40814c6e8e07848ca1e6071adc" translate="yes" xml:space="preserve">
          <source>a regexp. This is a really nice feature; what matches later in a regexp is made to depend on what matched earlier in the regexp. Suppose we wanted to look for doubled words in a text, like 'the the'. The following regexp finds all 3-letter doubles with a space in between:</source>
          <target state="translated">정규식. 이것은 정말 좋은 기능입니다. 정규 표현식에서 나중에 일치하는 항목은 정규 표현식에서 이전에 일치하는 항목에 따라 달라집니다. 'the'와 같이 텍스트에서 두 배로 된 단어를 찾고 싶다고 가정 해 봅시다. 다음 정규식은 사이에 공백이있는 3 문자 더블을 모두 찾습니다.</target>
        </trans-unit>
        <trans-unit id="479e514b0897fdfb8d6718c16ce953228a292ea2" translate="yes" xml:space="preserve">
          <source>a regexp; not doing so may lead to surprising and unsatisfactory results.</source>
          <target state="translated">정규식; 그렇게하지 않으면 놀랍고 만족스럽지 않은 결과가 나올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8430d6aa05798e9ad31cc9f0f4c419ec21ff77ea" translate="yes" xml:space="preserve">
          <source>a simple word</source>
          <target state="translated">간단한 단어</target>
        </trans-unit>
        <trans-unit id="e941e8088e0ee725d5a1331bbb15c1f7fa4f3cdd" translate="yes" xml:space="preserve">
          <source>a string of Perl statements.</source>
          <target state="translated">Perl 문의 문자열</target>
        </trans-unit>
        <trans-unit id="76ca2e58b13a0c692067763da1d921195c362fc6" translate="yes" xml:space="preserve">
          <source>a string of octal digits. See also &lt;a href=&quot;#oct&quot;&gt;oct&lt;/a&gt;, if all you have is a string.</source>
          <target state="translated">8 진수 문자열 모든 것이 문자열이면 &lt;a href=&quot;#oct&quot;&gt;oct&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f83ace0c428bcd5408c51dfef2ab5e8998435bd7" translate="yes" xml:space="preserve">
          <source>a string of octal digits. See also &lt;a href=&quot;oct&quot;&gt;oct&lt;/a&gt;, if all you have is a string.</source>
          <target state="translated">8 진수 문자열 모든 것이 문자열이면 &lt;a href=&quot;oct&quot;&gt;oct&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b3166c6d48bdc27e53a55abb43985ea1756a1268" translate="yes" xml:space="preserve">
          <source>a subroutine reference.</source>
          <target state="translated">서브 루틴 참조</target>
        </trans-unit>
        <trans-unit id="04f0c4b1fd780f4be3730ec3c5d7dfd8c9451073" translate="yes" xml:space="preserve">
          <source>a thread:</source>
          <target state="translated">실 :</target>
        </trans-unit>
        <trans-unit id="fe6d7479ae4200c3a6f4997fc5801bb9889aa1b5" translate="yes" xml:space="preserve">
          <source>a whitespace character.)</source>
          <target state="translated">공백 문자.)</target>
        </trans-unit>
        <trans-unit id="78ecd65792fd338affd06e9d02fd8d0820236817" translate="yes" xml:space="preserve">
          <source>a) How do I verify that an email address is correctly formatted?</source>
          <target state="translated">a) 이메일 주소의 형식이 올바른지 어떻게 확인합니까?</target>
        </trans-unit>
        <trans-unit id="1ee08278869a8bdd3842c22f817ca34ed228cb42" translate="yes" xml:space="preserve">
          <source>a+bi</source>
          <target state="translated">a+bi</target>
        </trans-unit>
        <trans-unit id="81541b7da471dd2332c53aedfa2bdfe3a4665452" translate="yes" xml:space="preserve">
          <source>a-f (or A-F, case doesn't matter). Each hexadecimal digit represents four bits, or half a byte. &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; 0x..., &quot;\n&quot;&lt;/code&gt; will show a hexadecimal number in decimal, and &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt; &quot;%x\n&quot;, $decimal&lt;/code&gt; will show a decimal number in hexadecimal. If you have just the &quot;hex digits&quot; of a hexadecimal number, you can use the &lt;code&gt;&lt;a href=&quot;functions/hex&quot;&gt;hex()&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">af (또는 AF, 대소 문자는 중요하지 않습니다). 각 16 진수는 4 비트 또는 반 바이트를 나타냅니다. &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; 0x..., &quot;\n&quot;&lt;/code&gt; 은 16 진수를 10 진수로 표시하고 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt; &quot;%x\n&quot;, $decimal&lt;/code&gt; 은 10 진수를 16 진수로 표시합니다. 16 진 숫자의 &quot;16 진수&quot;만 있으면 &lt;code&gt;&lt;a href=&quot;functions/hex&quot;&gt;hex()&lt;/a&gt;&lt;/code&gt; 함수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ed5e8e851dceeb90b5c2b37a81b2ad11ae340d95" translate="yes" xml:space="preserve">
          <source>a.out-style build</source>
          <target state="translated">스타일 아웃 빌드</target>
        </trans-unit>
        <trans-unit id="5780daf6db0b013dbf82807c9f85abba683b0820" translate="yes" xml:space="preserve">
          <source>about</source>
          <target state="translated">about</target>
        </trans-unit>
        <trans-unit id="8f203a021dc29f479a81bd2dd69f4ea2898f02f6" translate="yes" xml:space="preserve">
          <source>about all the dependencies, so you should make sure that anything is up-to-date, say, by doing</source>
          <target state="translated">모든 의존성에 대해, 그래서 당신은 무엇이든 최신 상태인지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="9fbb397449fabe7370de4e726a586750c0e025d4" translate="yes" xml:space="preserve">
          <source>above</source>
          <target state="translated">above</target>
        </trans-unit>
        <trans-unit id="3f8528380c147f9aa2206094f2404301d5bc3dbf" translate="yes" xml:space="preserve">
          <source>above is set up automatically during the build to a correct value on the builder machine, but is overridable at runtime,</source>
          <target state="translated">위는 빌드하는 동안 빌더 머신에서 올바른 값으로 자동 설정되지만 런타임시 대체 가능합니다.</target>
        </trans-unit>
        <trans-unit id="82451b41fd7878180b6aa2b54e369cbec4e8032c" translate="yes" xml:space="preserve">
          <source>abs</source>
          <target state="translated">abs</target>
        </trans-unit>
        <trans-unit id="a239a7dbad7ea85832efb23e90576b2dd038b7a1" translate="yes" xml:space="preserve">
          <source>abs VALUE</source>
          <target state="translated">abs VALUE</target>
        </trans-unit>
        <trans-unit id="415190d7a2135efc9f152a71915dffbe7a71529a" translate="yes" xml:space="preserve">
          <source>abs, alarm, chomp, chop, chr, chroot, cos, defined, eval, evalbytes, exp, fc, glob, hex, int, lc, lcfirst, length, log, lstat, mkdir, oct, ord, pos, print, printf, quotemeta, readlink, readpipe, ref, require, reverse (in scalar context only), rmdir, say, sin, split (for its second argument), sqrt, stat, study, uc, ucfirst, unlink, unpack.</source>
          <target state="translated">abs, 알람, chomp, chop, chr, chroot, cos, 정의, eval, evalbytes, exp, fc, glob, hex, int, lc, lcfirst, 길이, 로그, lstat, mkdir, oct, ord, pos, print, printf, quotemeta, readlink, readpipe, ref, reverse, (scalar context에서만), rmdir, say, sin, split (두 번째 인수), sqrt, stat, study, uc, ucfirst, unlink, unpack.</target>
        </trans-unit>
        <trans-unit id="5e8fc1f161ebdf02ac9d2d940aca4c69e7ddd903" translate="yes" xml:space="preserve">
          <source>abs_path and friends</source>
          <target state="translated">abs_path와 친구들</target>
        </trans-unit>
        <trans-unit id="a4694021c8d1356f5760adc6ce253b54e2f437f0" translate="yes" xml:space="preserve">
          <source>absolute. This decision was made due to portability reasons. Since &lt;code&gt;File::Spec-&amp;gt;catdir()&lt;/code&gt; returns relative paths on all other operating systems, it will now also follow this convention on Mac OS. Note that this may break some existing scripts.</source>
          <target state="translated">순수한. 이 결정은 이식성 이유로 인해 이루어졌습니다. 이후 &lt;code&gt;File::Spec-&amp;gt;catdir()&lt;/code&gt; 다른 모든 운영 체제에서 상대 경로를 반환합니다, 지금 또한 맥 OS에이 규칙을 따릅니다. 이로 인해 일부 기존 스크립트가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb40247beed3ba10597c7fdb55272d4608c34191" translate="yes" xml:space="preserve">
          <source>absolute. This decision was made due to portability reasons. Since &lt;code&gt;File::Spec-&amp;gt;catfile()&lt;/code&gt; returns relative paths on all other operating systems, it will now also follow this convention on Mac OS. Note that this may break some existing scripts.</source>
          <target state="translated">순수한. 이 결정은 이식성 이유로 인해 이루어졌습니다. 이후 &lt;code&gt;File::Spec-&amp;gt;catfile()&lt;/code&gt; 다른 모든 운영 체제에서 상대 경로를 반환합니다, 지금 또한 맥 OS에이 규칙을 따릅니다. 이로 인해 일부 기존 스크립트가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75eebe6521e20b7f9388d31918b564655eac99ce" translate="yes" xml:space="preserve">
          <source>absolutely cannot wait for the fix to be made upstream, released to CPAN and copied to blead, you must add (or update) a &lt;code&gt;CUSTOMIZED&lt;/code&gt; entry in the</source>
          <target state="translated">수정 사항이 업스트림으로 작성되고 CPAN으로 릴리스되고 블리드에 복사 될 때까지 절대로 기다릴 수 없습니다. &lt;code&gt;CUSTOMIZED&lt;/code&gt; 항목을 CUSTOMIZED 항목에 추가 (또는 업데이트)해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7a532dc15a911b9b9181922abf6ced9885b401e9" translate="yes" xml:space="preserve">
          <source>accent-insensitive Unicode sort</source>
          <target state="translated">악센트에 민감하지 않은 유니 코드 정렬</target>
        </trans-unit>
        <trans-unit id="e586a9d31c9053af08de34074e1d2e2b09839079" translate="yes" xml:space="preserve">
          <source>accent-insensitive comparisons</source>
          <target state="translated">악센트에 구애받지 않는 비교</target>
        </trans-unit>
        <trans-unit id="fc8cc4afa9fee369f0ce78c3b97600f87cf033b7" translate="yes" xml:space="preserve">
          <source>accent-insensitive locale comparisons</source>
          <target state="translated">악센트를 구분하지 않는 로캘 비교</target>
        </trans-unit>
        <trans-unit id="5fb801f2f30ac5b8a6671f1d04a959a51fc1671e" translate="yes" xml:space="preserve">
          <source>accept</source>
          <target state="translated">accept</target>
        </trans-unit>
        <trans-unit id="ae12c11f3760218cae63851a278652cd3eaea3b8" translate="yes" xml:space="preserve">
          <source>accept NEWSOCKET,GENERICSOCKET</source>
          <target state="translated">NEWSOCKET, GENERICSOCKET에 동의</target>
        </trans-unit>
        <trans-unit id="5fc8d440432f0b7db9d7569d2e82bb54a31bbead" translate="yes" xml:space="preserve">
          <source>accept_targets_as_html</source>
          <target state="translated">accept_targets_as_html</target>
        </trans-unit>
        <trans-unit id="67dff9ee8056247422bb2cdd74c074036da47a0c" translate="yes" xml:space="preserve">
          <source>accessing</source>
          <target state="translated">accessing</target>
        </trans-unit>
        <trans-unit id="de3a63299e5e19ed22af733ce3c9c55e72ad3106" translate="yes" xml:space="preserve">
          <source>accessor function for the &quot;safe signals&quot; flag of a SigAction object; see &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for general information on safe (a.k.a. &quot;deferred&quot;) signals. If you wish to handle a signal safely, use this accessor to set the &quot;safe&quot; flag in the &lt;code&gt;POSIX::SigAction&lt;/code&gt; object:</source>
          <target state="translated">SigAction 객체의 &quot;안전 신호&quot;플래그에 대한 접근 자 기능; 안전 (일명 &quot;지연&quot;) 신호에 대한 일반적인 정보는 &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; 을 참조하십시오 . 신호를 안전하게 처리하려면이 접근자를 사용하여 &lt;code&gt;POSIX::SigAction&lt;/code&gt; 객체 에서 &quot;safe&quot;플래그를 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="130627c716765ea3404bece5800d80aa45677b23" translate="yes" xml:space="preserve">
          <source>accessor functions to get/set the values of a SigAction object.</source>
          <target state="translated">접근자는 SigAction 객체의 값을 가져 오거나 설정하는 기능을합니다.</target>
        </trans-unit>
        <trans-unit id="b7f71f41bfbef50f02bf886cf865af8975cb5786" translate="yes" xml:space="preserve">
          <source>accidentally</source>
          <target state="translated">accidentally</target>
        </trans-unit>
        <trans-unit id="3959b939e5424783c493f42cf465f2662e1abbe0" translate="yes" xml:space="preserve">
          <source>acosec</source>
          <target state="translated">acosec</target>
        </trans-unit>
        <trans-unit id="94cd96ac8391252b0d7300cdaef80570e8f1939f" translate="yes" xml:space="preserve">
          <source>acosech</source>
          <target state="translated">acosech</target>
        </trans-unit>
        <trans-unit id="c8be89c327cde8b860df98308b35887bdf811326" translate="yes" xml:space="preserve">
          <source>acot</source>
          <target state="translated">acot</target>
        </trans-unit>
        <trans-unit id="b5aa292058ce240d98a24e0ca78c79be934f0018" translate="yes" xml:space="preserve">
          <source>acotan</source>
          <target state="translated">acotan</target>
        </trans-unit>
        <trans-unit id="299176f2fa0007084d06d47b1d722326f90b487a" translate="yes" xml:space="preserve">
          <source>acotanh</source>
          <target state="translated">acotanh</target>
        </trans-unit>
        <trans-unit id="eef264f7031ee0d55b786c83a83d07ec29a99714" translate="yes" xml:space="preserve">
          <source>acsc</source>
          <target state="translated">acsc</target>
        </trans-unit>
        <trans-unit id="742151db90a3d5f8f47cde2a0573ae956bba7225" translate="yes" xml:space="preserve">
          <source>action&quot; or &quot;manu-</source>
          <target state="translated">액션 &quot;또는&quot;manu-</target>
        </trans-unit>
        <trans-unit id="2bb6b986c5d6fb26dd9dd1054b545ce022371b0c" translate="yes" xml:space="preserve">
          <source>active</source>
          <target state="translated">active</target>
        </trans-unit>
        <trans-unit id="50f46198a1bd51840547aee34fc045921e43d4c6" translate="yes" xml:space="preserve">
          <source>actual</source>
          <target state="translated">actual</target>
        </trans-unit>
        <trans-unit id="5e9b6a0946d93d3600096c34f7b9c6d8f4af95ac" translate="yes" xml:space="preserve">
          <source>actually made it back to</source>
          <target state="translated">실제로 다시</target>
        </trans-unit>
        <trans-unit id="58d1bbce297de3c304a9fefc3b483181872a5c6b" translate="yes" xml:space="preserve">
          <source>add</source>
          <target state="translated">add</target>
        </trans-unit>
        <trans-unit id="1d1b3b51172716d0cb050801b8fab16ebc7d7185" translate="yes" xml:space="preserve">
          <source>add_bits</source>
          <target state="translated">add_bits</target>
        </trans-unit>
        <trans-unit id="8bab9844d8f1c6dd4567678a3d4228ce8b501259" translate="yes" xml:space="preserve">
          <source>add_bits($data, $nbits)</source>
          <target state="translated">add_bits ($ data, $ nbits)</target>
        </trans-unit>
        <trans-unit id="93ac08fbb73a3cad19b1e009a5e2b9a0a78a5e4b" translate="yes" xml:space="preserve">
          <source>add_bits()</source>
          <target state="translated">add_bits()</target>
        </trans-unit>
        <trans-unit id="64dea38af51fbf2c8ff3ee6ea4af6ed53003ace2" translate="yes" xml:space="preserve">
          <source>add_callback ()</source>
          <target state="translated">add_callback ()</target>
        </trans-unit>
        <trans-unit id="94d0e78aca0adb443be5d146e1dac8975ed16903" translate="yes" xml:space="preserve">
          <source>add_style ()</source>
          <target state="translated">add_style ()</target>
        </trans-unit>
        <trans-unit id="c3805175370d19c334b59f45b87343b9f2b7f5e1" translate="yes" xml:space="preserve">
          <source>addition</source>
          <target state="translated">addition</target>
        </trans-unit>
        <trans-unit id="c662180230cad14787d4ab7e77aa08681ce783fa" translate="yes" xml:space="preserve">
          <source>address</source>
          <target state="translated">address</target>
        </trans-unit>
        <trans-unit id="91ea4e7b6b94343d715c7982210567115655cb20" translate="yes" xml:space="preserve">
          <source>adds a new name for a control character.</source>
          <target state="translated">제어 문자의 새 이름을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="9c677b000cbca8edd8a283feb5874aa9705fe891" translate="yes" xml:space="preserve">
          <source>adds it automatically when building a program. However, when accessing an executable as a normal file (e.g.,</source>
          <target state="translated">프로그램을 빌드 할 때 자동으로 추가합니다. 그러나 실행 파일을 일반 파일로 액세스하는 경우 (예 :</target>
        </trans-unit>
        <trans-unit id="095c0c5ecd4727ed55c8b2fdc7688091189d0cae" translate="yes" xml:space="preserve">
          <source>adds the line to the history of input, from where it can be used if the actual &lt;code&gt;&lt;a href=&quot;../functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; is present.</source>
          <target state="translated">실제 &lt;code&gt;&lt;a href=&quot;../functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 이있는 경우 사용할 수있는 위치에서 입력 히스토리에 행을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="b0b7161ec6ad88575ef86bb08f43a11d9469dba1" translate="yes" xml:space="preserve">
          <source>adecimal.</source>
          <target state="translated">adecimal.</target>
        </trans-unit>
        <trans-unit id="b144ec6dfdab55ae2963bf4c782c7e4157019ffd" translate="yes" xml:space="preserve">
          <source>adminaddress</source>
          <target state="translated">adminaddress</target>
        </trans-unit>
        <trans-unit id="916a530bfc75fe948657d7b5108d40fc2508c596" translate="yes" xml:space="preserve">
          <source>advised to follow this introduction with more information from the full Perl manual, the table of contents to which can be found in &lt;a href=&quot;http://search.cpan.org/perldoc/perltoc&quot;&gt;perltoc&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/perltoc&quot;&gt;perltoc&lt;/a&gt; 에서 찾을 수있는 전체 Perl 매뉴얼의 자세한 정보와 함께이 소개를 따르는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="aab93e8e3796f91139b951be5ef4c63e4b3fdff0" translate="yes" xml:space="preserve">
          <source>affect normal access to a variable. (Locks on subs are different, and covered in a bit.) If you really,</source>
          <target state="translated">변수에 대한 일반 액세스에 영향을줍니다. (잠금 장치의 잠금 장치는 다르며 약간 다루어집니다.) 정말로</target>
        </trans-unit>
        <trans-unit id="d16b511453d6e723e850460d0b087be14fb56fb1" translate="yes" xml:space="preserve">
          <source>afs.U</source>
          <target state="translated">afs.U</target>
        </trans-unit>
        <trans-unit id="405906c9d5be6ae5393ca65fb0e7c38e0d585ecb" translate="yes" xml:space="preserve">
          <source>after</source>
          <target state="translated">after</target>
        </trans-unit>
        <trans-unit id="1a8a978377842aa511fbb5bb66f929228650a830" translate="yes" xml:space="preserve">
          <source>after a &lt;b&gt;failure&lt;/b&gt;:</source>
          <target state="translated">&lt;b&gt;실패&lt;/b&gt; 후 :</target>
        </trans-unit>
        <trans-unit id="2391217343165dbdcc1e85432eaed6f2d40232f2" translate="yes" xml:space="preserve">
          <source>after the first line of wrap(). This is not a most effective implementation, one may consider</source>
          <target state="translated">wrap ()의 첫 줄 다음에. 이것은 가장 효과적인 구현이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="d501db092c38ad8292690be746bddff30bdd42c1" translate="yes" xml:space="preserve">
          <source>after which you may use either</source>
          <target state="translated">그 후 당신은 둘 중 하나를 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="d237158794ce68f8acfcb27dbb3524b7d367bc44" translate="yes" xml:space="preserve">
          <source>after you made your modifications.</source>
          <target state="translated">수정 한 후</target>
        </trans-unit>
        <trans-unit id="0de616ced95f0b022d2889588dcde62712d64ff3" translate="yes" xml:space="preserve">
          <source>again, and run</source>
          <target state="translated">다시 실행</target>
        </trans-unit>
        <trans-unit id="80ece22ca1db999b834ed949964a66789d2cf76d" translate="yes" xml:space="preserve">
          <source>against the previous and current perls to see what difference it has made, and whether anything else has slowed down as a consequence.</source>
          <target state="translated">이전과 현재의 perls와 비교하여 어떤 차이가 있었는지, 다른 결과가 느려졌는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="f1525d2f1de4ff409ccb719b4f0bd276a7bb7c21" translate="yes" xml:space="preserve">
          <source>agree on the type of reference and also on the organization of data within the object body. Failure to agree on the type results in immediate death when the wrong method tries to access an object. Failure to agree on data organization may lead to one class trampling over the data of another.</source>
          <target state="translated">참조 유형과 객체 본문 내의 데이터 구성에 동의합니다. 형식에 동의하지 않으면 잘못된 방법으로 객체에 액세스하려고 할 때 즉시 사망합니다. 데이터 구성에 동의하지 않으면 한 클래스가 다른 클래스의 데이터를 짓밟을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73468898c9988e2f9e409b93e8bff16eaa79c0ba" translate="yes" xml:space="preserve">
          <source>alarm</source>
          <target state="translated">alarm</target>
        </trans-unit>
        <trans-unit id="05d57bf3c2063c1b5c9e035ba1e89e203c424841" translate="yes" xml:space="preserve">
          <source>alarm SECONDS</source>
          <target state="translated">알람 시간</target>
        </trans-unit>
        <trans-unit id="605bec3b3bc4303313aa3e75ef5affbb28a79c75" translate="yes" xml:space="preserve">
          <source>albeit with substitutions such as &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s/LATIN//&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s/VULGAR//&lt;/a&gt;&lt;/code&gt; in all cases; &lt;code&gt;s/CAPITAL LETTER//&lt;/code&gt; in some cases; and &lt;code&gt;s/SMALL LETTER ([A-Z])/\l$1/&lt;/code&gt; in some other cases. Controls are listed using their Unicode 6.2 abbreviations. The differences between the 0037 and 1047 sets are flagged with &lt;code&gt;**&lt;/code&gt; . The differences between the 1047 and POSIX-BC sets are flagged with &lt;code&gt;##.&lt;/code&gt; All &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord()&lt;/a&gt;&lt;/code&gt; numbers listed are decimal. If you would rather see this table listing octal values, then run the table (that is, the pod source text of this document, since this recipe may not work with a pod2_other_format translation) through:</source>
          <target state="translated">모든 경우에 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s/LATIN//&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s/VULGAR//&lt;/a&gt;&lt;/code&gt; 와 같은 치환으로 도; &lt;code&gt;s/CAPITAL LETTER//&lt;/code&gt; ; 및 &lt;code&gt;s/SMALL LETTER ([A-Z])/\l$1/&lt;/code&gt; 다른 경우이다. 컨트롤은 유니 코드 6.2 약어를 사용하여 나열됩니다. 0037과 1047 세트의 차이점은 &lt;code&gt;**&lt;/code&gt; 로 표시됩니다 . 1047과 POSIX-BC 세트의 차이점은 &lt;code&gt;##.&lt;/code&gt; 으로 표시됩니다 . 나열된 모든 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord()&lt;/a&gt;&lt;/code&gt; 숫자는 10 진수입니다. 8 진수 값을 나열하는이 테이블을 보려면 다음을 통해 테이블 ​​(이 문서의 포드 소스 텍스트를 작성하십시오.이 레시피는 pod2_other_format 변환에서는 작동하지 않을 수 있음)</target>
        </trans-unit>
        <trans-unit id="3b21e0f54dca09308ec896c51cda4f9ca4dd91a4" translate="yes" xml:space="preserve">
          <source>aliases</source>
          <target state="translated">aliases</target>
        </trans-unit>
        <trans-unit id="3d30739d4c2f9e4b4a11180a7c3327f3e52fd8d3" translate="yes" xml:space="preserve">
          <source>alignbytes.U</source>
          <target state="translated">alignbytes.U</target>
        </trans-unit>
        <trans-unit id="d87c448044defb778f33158d8ccf94a20531d600" translate="yes" xml:space="preserve">
          <source>all</source>
          <target state="translated">all</target>
        </trans-unit>
        <trans-unit id="509fd71434fbe53c02bb286882f845078ef5ee17" translate="yes" xml:space="preserve">
          <source>all compressed data to the output data stream.</source>
          <target state="translated">모든 압축 데이터를 출력 데이터 스트림으로</target>
        </trans-unit>
        <trans-unit id="8130249f3817c584cba8ad27e67056edd1c31fac" translate="yes" xml:space="preserve">
          <source>all its ancestor classes. (This is because the idea of &quot;class data&quot; isn't directly implemented in Perl, but is instead left to individual class-systems to implement as they see fit..)</source>
          <target state="translated">모든 조상 클래스. (이것은 &quot;클래스 데이터&quot;라는 개념이 Perl에서 직접 구현 된 것이 아니라 개별 클래스 시스템에 맞게 구현 된 것입니다.)</target>
        </trans-unit>
        <trans-unit id="8cc5040f7ad90d3df578f4dce7d48b395ac1b9d9" translate="yes" xml:space="preserve">
          <source>all of the help</source>
          <target state="translated">모든 도움</target>
        </trans-unit>
        <trans-unit id="7d7ebf534a4b32567ce1f6b72446d3e09f27b240" translate="yes" xml:space="preserve">
          <source>all other versions of the module you're installing</source>
          <target state="translated">설치할 다른 모든 버전의 모듈</target>
        </trans-unit>
        <trans-unit id="de05e27afdc59b4d9bbeeae86d35f670cdbf6280" translate="yes" xml:space="preserve">
          <source>all remaining lines from is this way:</source>
          <target state="translated">나머지 모든 줄은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f966b162e6dd45e46a9c1021ad48d8c4e414675d" translate="yes" xml:space="preserve">
          <source>all the subroutines are called in a list context.</source>
          <target state="translated">모든 서브 루틴은 목록 컨텍스트에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="78d2c8306e2172f468ed7da94e5e7fdd772dd33e" translate="yes" xml:space="preserve">
          <source>all uncompressed data to the output data stream.</source>
          <target state="translated">압축되지 않은 모든 데이터를 출력 데이터 스트림으로</target>
        </trans-unit>
        <trans-unit id="e6543caf79edcee1b041e9193f69e17c853ef1f4" translate="yes" xml:space="preserve">
          <source>all with optional leading and trailing zeros and/or spaces. Additionally, numbers are allowed to have an underscore between any two digits.</source>
          <target state="translated">선택적인 선행 및 후행 0 및 / 또는 공백이 있습니다. 또한 숫자는 두 자릿수 사이에 밑줄을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="acff2f4d1898df7e94ecaebad18831a97e4519ff" translate="yes" xml:space="preserve">
          <source>all_target</source>
          <target state="translated">all_target</target>
        </trans-unit>
        <trans-unit id="12b42e096b7bca3af7ec1c5ba1a6445e520a72d8" translate="yes" xml:space="preserve">
          <source>allkeys.txt</source>
          <target state="translated">allkeys.txt</target>
        </trans-unit>
        <trans-unit id="78c9d45e7d52c660866b311227728fee1dfd5e6c" translate="yes" xml:space="preserve">
          <source>allocates some memory and constructs a Perl interpreter, along these lines:</source>
          <target state="translated">다음 행을 따라 메모리를 할당하고 Perl 인터프리터를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="4ac387a6f0f3e93209827552db5ced03710025ff" translate="yes" xml:space="preserve">
          <source>allow suppressing all such STDERR output, and instead allow an option for reporting errors/warnings in some other way, whether by triggering a callback, or noting errors in some attribute of the document object, or some similarly unobtrusive mechanism -- or even by appending a &quot;Pod Errors&quot; section to the end of the parsed form of the document.</source>
          <target state="translated">이러한 모든 STDERR 출력을 억제하고 대신 콜백을 트리거하거나 문서 객체의 일부 속성 또는 이와 유사한 눈에 띄지 않는 메커니즘 또는 오류를 추가하여 다른 방법으로 오류 / 경고를보고하는 옵션을 허용합니다. 구문 분석 된 문서 양식의 끝 부분에있는 &quot;팟 오류&quot;섹션</target>
        </trans-unit>
        <trans-unit id="eb4eaf28d97cf6eeb14d04f7a34316c390474dbc" translate="yes" xml:space="preserve">
          <source>allow( $test_me, \@criteria );</source>
          <target state="translated">allow ($ test_me, \ @criteria);</target>
        </trans-unit>
        <trans-unit id="023f8167a0ccb01c809eb2dc9a66997533fa1ae8" translate="yes" xml:space="preserve">
          <source>allowed if $pat is a precompiled regular expression, even if $pat contains &lt;code&gt;(?{ ... })&lt;/code&gt; assertions or &lt;code&gt;(??{ ... })&lt;/code&gt; subexpressions.</source>
          <target state="translated">$ pat에 &lt;code&gt;(?{ ... })&lt;/code&gt; 어설 션 또는 &lt;code&gt;(??{ ... })&lt;/code&gt; 하위 표현식이 포함되어 있어도 $ pat가 사전 컴파일 된 정규 표현식 인 경우 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4301b689bb097155e3bb6d16044296e9269b5529" translate="yes" xml:space="preserve">
          <source>allows Perl to do unsafe operations. Currently the only &quot;unsafe&quot; operations are attempting to unlink directories while running as superuser and running setuid programs with fatal taint checks turned into warnings. Note that warnings must be enabled along with this option to actually</source>
          <target state="translated">Perl이 안전하지 않은 작업을 수행 할 수 있습니다. 현재 유일한 &quot;안전하지 않은&quot;작업은 수퍼 유저로 실행하고 치명적인 오염 검사가 경고로 설정된 setuid 프로그램을 실행하는 동안 디렉토리의 링크를 해제하려고합니다. 실제로이 옵션과 함께 경고를 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="132c35f7c02912ac7c614dd2a393fc9375c90687" translate="yes" xml:space="preserve">
          <source>allows the &lt;code&gt;:default&lt;/code&gt; list from a particular version to be used. This provides the convenience of using the default methods, but the surety that no behavioral changes will occur if the &lt;code&gt;autodie&lt;/code&gt; module is upgraded.</source>
          <target state="translated">특정 버전 의 &lt;code&gt;:default&lt;/code&gt; 목록을 사용할 수 있습니다. 이를 통해 기본 방법을 편리하게 사용할 수 있지만 &lt;code&gt;autodie&lt;/code&gt; 모듈을 업그레이드 할 경우 동작 변경이 발생하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="423d437bbbc6bb7d398c30b28e10d75c03e10783" translate="yes" xml:space="preserve">
          <source>allows you to refer to special variables (like &lt;code&gt;$/&lt;/code&gt; ) with names (like $RS), as though they were in &lt;b&gt;awk&lt;/b&gt;; see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for details.</source>
          <target state="translated">마치 &lt;b&gt;awk&lt;/b&gt; 에있는 것처럼 이름이 $ RS와 같은 특수 변수 (예 &lt;code&gt;$/&lt;/code&gt; ) 를 참조 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; 를 참조하십시오.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f9e2ef61def87209ec2dd5c8efef68de53d4aef6" translate="yes" xml:space="preserve">
          <source>almost</source>
          <target state="translated">almost</target>
        </trans-unit>
        <trans-unit id="f5f5592352120c7c5dd3e80cd891b2a35cc0756a" translate="yes" xml:space="preserve">
          <source>along with #including</source>
          <target state="translated">#include와 함께</target>
        </trans-unit>
        <trans-unit id="f84474a16e6ac5b152e8cf62a4c115b6109f018b" translate="yes" xml:space="preserve">
          <source>alphabetic</source>
          <target state="translated">alphabetic</target>
        </trans-unit>
        <trans-unit id="b859ef3e26b0a8f0f8e5984aa4d45230ec4e08bc" translate="yes" xml:space="preserve">
          <source>already exist</source>
          <target state="translated">이미 존재합니다</target>
        </trans-unit>
        <trans-unit id="34879e54886ec3a6f952c7af1d444870828e03e7" translate="yes" xml:space="preserve">
          <source>already-existing</source>
          <target state="translated">already-existing</target>
        </trans-unit>
        <trans-unit id="09706c418809f1f4cfda992435ca1438eddaaeed" translate="yes" xml:space="preserve">
          <source>also</source>
          <target state="translated">also</target>
        </trans-unit>
        <trans-unit id="53ed2e1b9d4ccdc537294ab308f9c5d1e151cf60" translate="yes" xml:space="preserve">
          <source>also creates the prototyping header files for the internal functions, generates the documentation and a lot of other bits and pieces. It's important that when you add a new function to the core or change an existing one, you change the data in the table in</source>
          <target state="translated">또한 내부 함수에 대한 프로토 타입 헤더 파일을 작성하고 문서와 기타 여러 비트 및 조각을 생성합니다. 코어에 새 기능을 추가하거나 기존 기능을 변경할 때 테이블의 데이터를 변경하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="4298c06d3073002d95a1081fb801b4a99c5de328" translate="yes" xml:space="preserve">
          <source>also exists). Cygwin does not require a</source>
          <target state="translated">또한 존재합니다). Cygwin은</target>
        </trans-unit>
        <trans-unit id="2ce647c4199231c5e08b22c4a1f2a2b4b84f2e7b" translate="yes" xml:space="preserve">
          <source>also includes the platform's native underscore character, no matter what the locale is.</source>
          <target state="translated">로케일이 무엇이든 플랫폼의 기본 밑줄 문자도 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="17b130cdba41303da201c9df43f19e9e6a5a45ad" translate="yes" xml:space="preserve">
          <source>also provides a number of &lt;code&gt;PerlIOBase_xxxx()&lt;/code&gt; functions which are intended to be used in the table slots of classes which do not need to do anything special for a particular method.</source>
          <target state="translated">또한 특정 메서드에 대해 특별한 작업을 수행 할 필요가없는 클래스의 테이블 슬롯에 사용하기위한 여러 &lt;code&gt;PerlIOBase_xxxx()&lt;/code&gt; 함수를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="edb013a0b027689799b6d3bb946b0380fa2999b8" translate="yes" xml:space="preserve">
          <source>alter the interpretation of nested formatting codes, meaning that the following four example lines are identical in meaning:</source>
          <target state="translated">중첩 된 형식화 코드의 해석을 변경하십시오. 즉, 다음 네 가지 예제 행의 의미가 동일합니다.</target>
        </trans-unit>
        <trans-unit id="370d1bb1966aad5766de7d85dcf3b3cc7341ab95" translate="yes" xml:space="preserve">
          <source>alternation</source>
          <target state="translated">alternation</target>
        </trans-unit>
        <trans-unit id="c78b3591272b10760192271aec607cc2988dcb68" translate="yes" xml:space="preserve">
          <source>although without duplicating any side effects that dereferencing the lvalue might trigger, such as from &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie()&lt;/a&gt;&lt;/code&gt;. Other assignment operators work similarly. The following are recognized:</source>
          <target state="translated">lvalue를 참조하지 않는 트리거를 유발할 수있는 부작용 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie()&lt;/a&gt;&lt;/code&gt; 예 : tie ()) 을 복제하지 않아도 됩니다. 다른 할당 연산자도 비슷하게 작동합니다. 다음이 인정됩니다.</target>
        </trans-unit>
        <trans-unit id="6656018ac96d0295d887ff2893ba9af66ae16af2" translate="yes" xml:space="preserve">
          <source>always</source>
          <target state="translated">always</target>
        </trans-unit>
        <trans-unit id="fb980e8b0c064246b90fe9981d818b33511ba028" translate="yes" xml:space="preserve">
          <source>always be called &lt;code&gt;my_cxt_t&lt;/code&gt; . The other &lt;code&gt;CXT*&lt;/code&gt; macros assume the existence of the &lt;code&gt;my_cxt_t&lt;/code&gt; typedef name.</source>
          <target state="translated">항상 &lt;code&gt;my_cxt_t&lt;/code&gt; 라고 합니다 . 다른 &lt;code&gt;CXT*&lt;/code&gt; 매크로는 &lt;code&gt;my_cxt_t&lt;/code&gt; typedef 이름이 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="9e7cc664880363e8a6f8dd216803f53660c055a7" translate="yes" xml:space="preserve">
          <source>ambient_pragmas</source>
          <target state="translated">ambient_pragmas</target>
        </trans-unit>
        <trans-unit id="75a14d5aecfa0926099831db837cd6a62fe95561" translate="yes" xml:space="preserve">
          <source>amed character.</source>
          <target state="translated">재미있는 캐릭터.</target>
        </trans-unit>
        <trans-unit id="de73eac0c305038f0437bc6a1f994a5a4379ed28" translate="yes" xml:space="preserve">
          <source>an</source>
          <target state="translated">an</target>
        </trans-unit>
        <trans-unit id="8f91a7d4c013d689792014cce41cfca93df8643f" translate="yes" xml:space="preserve">
          <source>an arrayref of CPAN::Distroprefs::Pref objects</source>
          <target state="translated">CPAN :: Distroprefs :: Pref 객체의 arrayref</target>
        </trans-unit>
        <trans-unit id="1fd4e0318cb46a3d9d16dba83e533928a4e2874e" translate="yes" xml:space="preserve">
          <source>an embedded newline, so it doesn't remove it. This pattern still removes the newline at the end of the string:</source>
          <target state="translated">포함 된 줄 바꿈이므로 제거하지 않습니다. 이 패턴은 여전히 ​​문자열 끝에서 줄 바꿈을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="419fb031bbb1d3bd852934c637cbdadfffbdbcd6" translate="yes" xml:space="preserve">
          <source>an entire array or an entire hash (or to just about anything else). Names are one kind of reference that you're already familiar with. Think of the President of the United States: a messy, inconvenient bag of blood and bones. But to talk about him, or to represent him in a computer program, all you need is the easy, convenient scalar string &quot;Barack Obama&quot;.</source>
          <target state="translated">전체 배열 또는 전체 해시 (또는 다른 것). 이름은 이미 잘 알고있는 일종의 참조입니다. 혼란스럽고 불편한 피와 뼈로 된 미국 대통령을 생각해보십시오. 그러나 그에 대해 이야기하거나 컴퓨터 프로그램에서 그를 대표하기 위해서는 쉽고 편리한 스칼라 문자열 &quot;Barack Obama&quot;만 있으면됩니다.</target>
        </trans-unit>
        <trans-unit id="2130df2147e633640bd9a0d05e6d376dee6ccd2f" translate="yes" xml:space="preserve">
          <source>an error has occurred, the return value will always be 0.</source>
          <target state="translated">오류가 발생하면 반환 값은 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="753f0741a207012aea84c4e049df342c160b9190" translate="yes" xml:space="preserve">
          <source>an error has occurred, the return value will be 1 and the value on the top of the stack will be</source>
          <target state="translated">오류가 발생하면 반환 값은 1이되고 스택 상단의 값은</target>
        </trans-unit>
        <trans-unit id="409ef8643f1d521a89ca1a0c3155c4a711f5a647" translate="yes" xml:space="preserve">
          <source>an error to register the same object multiple times with varying sets of hashrefs. Any hashrefs that are not registered yet will be added, others ignored.</source>
          <target state="translated">다양한 해시 참조 세트로 동일한 객체를 여러 번 등록하는 오류 아직 등록되지 않은 해시 참조는 추가되고 다른 참조는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="f7cb42641753796859e397b207b75ba5bcc045ca" translate="yes" xml:space="preserve">
          <source>an integer within [-9, +9]), this is called</source>
          <target state="translated">[-9, +9] 내의 정수)라고합니다.</target>
        </trans-unit>
        <trans-unit id="f06df609aed50661247cc6ec96c1599c193c3ec4" translate="yes" xml:space="preserve">
          <source>anchor</source>
          <target state="translated">anchor</target>
        </trans-unit>
        <trans-unit id="04f99c29e783f9cb4ae84f58faccd00a818b9492" translate="yes" xml:space="preserve">
          <source>anchor_items</source>
          <target state="translated">anchor_items</target>
        </trans-unit>
        <trans-unit id="68694b44e6f48917189ec5e4ceb1c0fef7ef80b9" translate="yes" xml:space="preserve">
          <source>anchored fixed string</source>
          <target state="translated">고정 된 고정 문자열</target>
        </trans-unit>
        <trans-unit id="43c00fd1688ea15081e7af4c5f2652c8c8653500" translate="yes" xml:space="preserve">
          <source>anchorify</source>
          <target state="translated">anchorify</target>
        </trans-unit>
        <trans-unit id="f3ef6e09da1f05d18d52776cc5fea65e3b316091" translate="yes" xml:space="preserve">
          <source>anchorname</source>
          <target state="translated">anchorname</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="41f7d9aafc306017d119acf70705c827d97696a7" translate="yes" xml:space="preserve">
          <source>and &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;.)</source>
          <target state="translated">및 &lt;a href=&quot;encode&quot;&gt;인코딩&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1e7b3b70ce0b7269aa85ddea66ae89e1b660b6b7" translate="yes" xml:space="preserve">
          <source>and &lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;, or &lt;a href=&quot;perlfaq5&quot;&gt;perlfaq5&lt;/a&gt;, &quot;How do I flush/unbuffer an output filehandle? Why must I do this?&quot;):</source>
          <target state="translated">및 &lt;a href=&quot;functions/select&quot;&gt;선택&lt;/a&gt; , 또는 &lt;a href=&quot;perlfaq5&quot;&gt;perlfaq5&lt;/a&gt; , &quot;? 어떻게 출력 파일 핸들 버퍼 해제 I를 플러시 /을 내가 왜 이렇게해야 하는가?&quot;)</target>
        </trans-unit>
        <trans-unit id="016f4b3a6b408b7434c9c8addd29fcfb251b75bc" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;$default&lt;/code&gt; is 0.</source>
          <target state="translated">그리고 &lt;code&gt;$default&lt;/code&gt; 0입니다.</target>
        </trans-unit>
        <trans-unit id="79e3a95c66eb0995a5b17cf160488513cd9c4836" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;$status&lt;/code&gt; will contain the</source>
          <target state="translated">그리고 &lt;code&gt;$status&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="fb55aba7e200d190a26516edaeb1e8c8f871d671" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;$status&lt;/code&gt; will hold the</source>
          <target state="translated">그리고 &lt;code&gt;$status&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="f7a05a7c74e5456a922f33cfd811202c94bfd7a6" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;$status&lt;/code&gt; will hold the a</source>
          <target state="translated">그리고 &lt;code&gt;$status&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="faf11d208a41db985f49c9f628222cbd33a1d444" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;$status&lt;/code&gt; will hold the exact</source>
          <target state="translated">그리고 &lt;code&gt;$status&lt;/code&gt; 정확한를 개최합니다</target>
        </trans-unit>
        <trans-unit id="311c8c621fca6c1133276b3546a71e41872cd5b3" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; myint;&lt;/code&gt; is</source>
          <target state="translated">그리고 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; myint;&lt;/code&gt; &lt;a href=&quot;functions/no&quot;&gt;도&lt;/a&gt; 없다. 이다</target>
        </trans-unit>
        <trans-unit id="fe56ad1fd6916544bd67d364c47ef22b8722997c" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;Archive::Tar&lt;/code&gt; will call &lt;code&gt;Cwd::cwd()&lt;/code&gt; internally again.</source>
          <target state="translated">및 &lt;code&gt;Archive::Tar&lt;/code&gt; 호출합니다 &lt;code&gt;Cwd::cwd()&lt;/code&gt; 내부적으로 다시.</target>
        </trans-unit>
        <trans-unit id="aeba6e0c46a5c93c432546b879e4bda2afa3e55c" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;Perl_dump_all&lt;/code&gt; , which dumps all the subroutines in the stash and the op tree of the main root.</source>
          <target state="translated">및 &lt;code&gt;Perl_dump_all&lt;/code&gt; 숨김 및 주요 루트의 연산 트리의 모든 서브 루틴을 덤프.</target>
        </trans-unit>
        <trans-unit id="24b1d9fb54b19f2a4bf7a0a575b93e2448d41ac7" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;asynch_read_if&lt;/code&gt; could look like this</source>
          <target state="translated">및 &lt;code&gt;asynch_read_if&lt;/code&gt; 은 다음과 같을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="52260a6c12657e7cd53ed4aeda42476a80ffde69" translate="yes" xml:space="preserve">
          <source>and C</source>
          <target state="translated">그리고 C</target>
        </trans-unit>
        <trans-unit id="ce624d2a956a4c4fdd87bb0d4c8b8565acc10eb6" translate="yes" xml:space="preserve">
          <source>and CRT DLL. I know no advantages of this executable over &lt;code&gt;perl.exe&lt;/code&gt; , but it cannot fork() at all. Well, one advantage is that the build process is not so convoluted as with &lt;code&gt;perl.exe&lt;/code&gt; .</source>
          <target state="translated">그리고 CRT DLL. &lt;code&gt;perl.exe&lt;/code&gt; 보다이 실행 파일의 장점은 없지만, fork () 할 수는 없습니다. 글쎄, 하나의 장점은 빌드 프로세스가 &lt;code&gt;perl.exe&lt;/code&gt; 와 같이 복잡하지 않다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="d2f78e98c292b6edbfc33a84d6b47bc8f258f6d2" translate="yes" xml:space="preserve">
          <source>and Configure will give up.</source>
          <target state="translated">그리고 구성은 포기합니다.</target>
        </trans-unit>
        <trans-unit id="e6601ba493fd802e8c69e73fa3178575540d2f6c" translate="yes" xml:space="preserve">
          <source>and Mark Adler</source>
          <target state="translated">마크 애들러</target>
        </trans-unit>
        <trans-unit id="86d575fb0f5c883349b5a7f286abb3edbe3207c7" translate="yes" xml:space="preserve">
          <source>and Perl knows that it has to invoke the PerlIOAPR_open() method implemented by the APR layer.</source>
          <target state="translated">Perl은 APR 계층에 의해 구현 된 PerlIOAPR_open () 메소드를 호출해야한다는 것을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="e32c9b9186aa8e9288a2accdf939a5bb0683c0cb" translate="yes" xml:space="preserve">
          <source>and UNIX, &lt;code&gt;$gzerrno&lt;/code&gt; should only be used to check for the presence of</source>
          <target state="translated">UNIX의 경우 &lt;code&gt;$gzerrno&lt;/code&gt; 는 존재 여부를 확인하는 데만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="dce6c6da0aef880545eedbf05f807b0628611184" translate="yes" xml:space="preserve">
          <source>and UTF-16 is the name of the encoding that embraces them.</source>
          <target state="translated">UTF-16은이를 포함하는 인코딩의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c3a319360d3cdf3729627355f1ee1dd75a51847e" translate="yes" xml:space="preserve">
          <source>and ad hoc &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; $test ? &quot;ok 42\n&quot; : &quot;not ok 42\n&quot;&lt;/code&gt; . The decision of which to use depends on what part of the test suite you're working on. This is a measure to prevent a high-level failure (such as Config.pm breaking) from causing basic functionality tests to fail.</source>
          <target state="translated">ad hoc &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; $test ? &quot;ok 42\n&quot; : &quot;not ok 42\n&quot;&lt;/code&gt; 입니다. 사용할 결정은 작업중인 테스트 스위트의 어떤 부분에 따라 다릅니다. 이는 높은 수준의 오류 (예 : Config.pm 차단)로 인해 기본 기능 테스트가 실패하지 않도록하는 조치입니다.</target>
        </trans-unit>
        <trans-unit id="1759eff6deec8639c809421ad0c28a76e0ef5cae" translate="yes" xml:space="preserve">
          <source>and also $Config::Config{'scriptdir'}</source>
          <target state="translated">또한 $ Config :: Config { 'scriptdir'}</target>
        </trans-unit>
        <trans-unit id="092a598de52599e5ea26b086e728adfcb8a8f87b" translate="yes" xml:space="preserve">
          <source>and also how strings are parsed by &lt;code&gt;POSIX::strtod()&lt;/code&gt; as numbers:</source>
          <target state="translated">&lt;code&gt;POSIX::strtod()&lt;/code&gt; 가 문자열 을 숫자로 파싱하는 방법도 있습니다.</target>
        </trans-unit>
        <trans-unit id="53d3cfa28bbb90ed936aa07f73ce71dbef9ab3f7" translate="yes" xml:space="preserve">
          <source>and are now removed.</source>
          <target state="translated">이제 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="d7e49eb1b589da099384cdd5bcb2b002b2679a4a" translate="yes" xml:space="preserve">
          <source>and as</source>
          <target state="translated">그리고</target>
        </trans-unit>
        <trans-unit id="f930cc83716047f99549b196c0f6ea5f5c50196e" translate="yes" xml:space="preserve">
          <source>and auxiliary ones</source>
          <target state="translated">그리고 보조적인 것들</target>
        </trans-unit>
        <trans-unit id="0e8dd9b894bf299a78c91001723d0325159a6a91" translate="yes" xml:space="preserve">
          <source>and basic block profiling with gcc, see the latest GNU CC manual. As of gcc 4.8, this is at &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/Gcov-Intro.html#Gcov-Intro&quot;&gt;http://gcc.gnu.org/onlinedocs/gcc/Gcov-Intro.html#Gcov-Intro&lt;/a&gt;</source>
          <target state="translated">gcc를 사용한 기본 블록 프로파일 링은 최신 GNU CC 매뉴얼을 참조하십시오. gcc 4.8부터는 &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/Gcov-Intro.html#Gcov-Intro&quot;&gt;http://gcc.gnu.org/onlinedocs/gcc/Gcov-Intro.html#Gcov-Intro에 있습니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="67ac2d9e2193d40fc9c92b85950de3190240ebb3" translate="yes" xml:space="preserve">
          <source>and be sure to also set the environment variable _C89_CCMODE=1 (exporting _C89_CCMODE=1 is also a good idea for users of GNU make).</source>
          <target state="translated">환경 변수 _C89_CCMODE = 1도 설정해야합니다 (_C89_CCMODE = 1 내보내기는 GNU make 사용자에게도 좋습니다).</target>
        </trans-unit>
        <trans-unit id="cce2b5ee15547d8411b108ac01a1af3d3a13be3a" translate="yes" xml:space="preserve">
          <source>and belong to the user running the program:</source>
          <target state="translated">프로그램을 실행하는 사용자에게 속합니다.</target>
        </trans-unit>
        <trans-unit id="68c1df893d3dfe1344316c80822ce4982fc34977" translate="yes" xml:space="preserve">
          <source>and by default output is displayed inline.</source>
          <target state="translated">기본적으로 출력은 인라인으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9d972577906aa2c316e9c360f92a8897dc203b61" translate="yes" xml:space="preserve">
          <source>and by definition, the solution is noted</source>
          <target state="translated">정의에 따르면 솔루션은</target>
        </trans-unit>
        <trans-unit id="31788a27790e7797ed6a059ba1faefdb6a39e6a9" translate="yes" xml:space="preserve">
          <source>and call</source>
          <target state="translated">전화</target>
        </trans-unit>
        <trans-unit id="2b74bf70fe4b516f104f35b9ee09019d1d9b9441" translate="yes" xml:space="preserve">
          <source>and call it with &lt;code&gt;perl dangerous.pl 'rm -rfv *|'&lt;/code&gt; , it actually opens a pipe, executes the &lt;code&gt;rm&lt;/code&gt; command and reads &lt;code&gt;rm&lt;/code&gt; 's output from that pipe. If you want all items in &lt;code&gt;@ARGV&lt;/code&gt; to be interpreted as file names, you can use the module &lt;code&gt;ARGV::readonly&lt;/code&gt; from CPAN, or use the double bracket:</source>
          <target state="translated">그리고 &lt;code&gt;perl dangerous.pl 'rm -rfv *|'&lt;/code&gt; 호출하십시오. 실제로 파이프를 열고 &lt;code&gt;rm&lt;/code&gt; 명령을 실행하고 해당 파이프에서 &lt;code&gt;rm&lt;/code&gt; 의 출력을 읽습니다 . &lt;code&gt;@ARGV&lt;/code&gt; 의 모든 항목 을 파일 이름으로 해석 하려면 CPAN 의 모듈 &lt;code&gt;ARGV::readonly&lt;/code&gt; 를 사용하거나 이중 괄호를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cdadfa4e29a3387e757303b12e15c9ac8ce26389" translate="yes" xml:space="preserve">
          <source>and calling &lt;code&gt;Perl_mro_register&lt;/code&gt; :</source>
          <target state="translated">그리고 &lt;code&gt;Perl_mro_register&lt;/code&gt; 호출 :</target>
        </trans-unit>
        <trans-unit id="2dd76bc4189d4946771f4e716aa51df3f1240631" translate="yes" xml:space="preserve">
          <source>and choose your favorite parameters. After a few downloads running the &lt;code&gt;hosts&lt;/code&gt; command will probably assist you in choosing the best mirror sites.</source>
          <target state="translated">원하는 매개 변수를 선택하십시오. &lt;code&gt;hosts&lt;/code&gt; 명령을 실행하는 몇 번의 다운로드 후에는 최상의 미러 사이트를 선택하는 데 도움이 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="a8c3f91d52eab0005bf1821357c56257522b3d7e" translate="yes" xml:space="preserve">
          <source>and concatenate it to</source>
          <target state="translated">그것을 연결</target>
        </trans-unit>
        <trans-unit id="2ff89dcb837ced149fb6b5224ee21778d994fc8a" translate="yes" xml:space="preserve">
          <source>and continuing to the first nul. These octets are interpreted as either UTF-8 or Latin-1, according to whether the &lt;code&gt;LEX_STUFF_UTF8&lt;/code&gt; flag is set in</source>
          <target state="translated">그리고 첫 번째 널까지 계속합니다. 이 8 진수는 &lt;code&gt;LEX_STUFF_UTF8&lt;/code&gt; 플래그 설정 여부에 따라 UTF-8 또는 Latin-1로 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="3b4b74100dbb60dc7d23a3f17b465ea647875121" translate="yes" xml:space="preserve">
          <source>and correct anything wrong you find there. I do not expect it is needed anywhere.</source>
          <target state="translated">당신이 거기에있는 잘못을 정정하십시오. 나는 그것이 어디서나 필요하다고 기대하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c0554b9855c1b4a6c0834e79b079617190a40bcb" translate="yes" xml:space="preserve">
          <source>and dies. Therefore the SunOS 4.1 hints file explicitly sets the ld to be</source>
          <target state="translated">죽는다. 따라서 SunOS 4.1 힌트 파일은 ld를 명시 적으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="c349b5535bebf3c0ad16ae9e94907ffd5cecb983" translate="yes" xml:space="preserve">
          <source>and divines whether they passed or failed based on their output to STDOUT (details above). It prints out each individual test which failed along with a summary report and a how long it all took.</source>
          <target state="translated">그리고 STDOUT에 대한 출력에 기초하여 그들이 통과했는지 실패했는지를 신성하게한다 (상세한 내용). 실패한 각 개별 테스트를 요약 보고서 및 모든 시간이 소요되는 시간과 함께 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="a5fd741bd9f2a58aedde00aa2b92b647f2b4c3d7" translate="yes" xml:space="preserve">
          <source>and doing a bunch of messy heuristics on the resulting</source>
          <target state="translated">그리고 결과에 대한 지저분한 휴리스틱을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="79a24dfc42595a13dbd8f77aa55520c5f2654ac8" translate="yes" xml:space="preserve">
          <source>and earlier, the default setting is based on whether or not $prefix contains the string &lt;code&gt;perl&lt;/code&gt; .</source>
          <target state="translated">이전의 기본 설정은 $ prefix에 &lt;code&gt;perl&lt;/code&gt; 문자열이 포함되어 있는지 여부를 기반으로합니다 .</target>
        </trans-unit>
        <trans-unit id="ca01c68b157f542551615a222bf4d40f1c92ab92" translate="yes" xml:space="preserve">
          <source>and ending at</source>
          <target state="translated">그리고 끝나는</target>
        </trans-unit>
        <trans-unit id="edc511aaa0ea9a61210a5a9707c8841bf5cc309d" translate="yes" xml:space="preserve">
          <source>and even</source>
          <target state="translated">심지어</target>
        </trans-unit>
        <trans-unit id="883426c92d8b38847917d43ce3dd00b6254d2bed" translate="yes" xml:space="preserve">
          <source>and expect C to be B, because the bearing constantly changes when going from A to B (except in some special case like the meridians or the circles of latitudes) and in great_circle_destination() one gives a &lt;b&gt;constant&lt;/b&gt; bearing to follow.</source>
          <target state="translated">A에서 B로 갈 때 베어링이 끊임없이 변경되기 때문에 (자오선이나 위도의 원과 같은 특별한 경우는 제외) great_circle_destination ()에서는 &lt;b&gt;계속&lt;/b&gt; 따라야 할 베어링을 제공하기 때문에 C는 B가 될 것으로 예상합니다 .</target>
        </trans-unit>
        <trans-unit id="3ee040c85734bc842f7986baed3ad3d4c7a277c5" translate="yes" xml:space="preserve">
          <source>and extension authors. If your extension is dynamically loaded, DynaLoader creates</source>
          <target state="translated">확장 저자. 확장이 동적으로로드되면 DynaLoader는</target>
        </trans-unit>
        <trans-unit id="d176fa9bd5235077e8d5cc1dc829719336ead81b" translate="yes" xml:space="preserve">
          <source>and fields. So far, the functions of &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; are unaware of any classes, which I consider a feature. Therefore &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; doesn't address the serialization problems.</source>
          <target state="translated">그리고 분야. 지금까지 &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; 의 기능은 기능을 고려한 클래스를 인식하지 못합니다. 따라서 &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; 는 직렬화 문제를 해결하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6420fc98ccacfbcabdd1358ce52dbb2f18c3b757" translate="yes" xml:space="preserve">
          <source>and for &lt;code&gt;_&lt;/code&gt; to explicitly populate the object using the unexported and undocumented populate() function with CORE::stat():</source>
          <target state="translated">과에 대한 &lt;code&gt;_&lt;/code&gt; 명시 적으로 CORE와 안 export 및 문서화되지 않은 채우기 () 함수 : 합계 ()를 사용하여 객체를 채우려면 :</target>
        </trans-unit>
        <trans-unit id="9ecd2684e5d35794eb09b10452dc598bb0f3ca39" translate="yes" xml:space="preserve">
          <source>and for writing:</source>
          <target state="translated">그리고 쓰기 :</target>
        </trans-unit>
        <trans-unit id="c07a028d906529efcbd2ee19e8498ca6b129b522" translate="yes" xml:space="preserve">
          <source>and from Latin-1 code points to EBCDIC code points</source>
          <target state="translated">라틴 -1 코드 포인트에서 EBCDIC 코드 포인트까지</target>
        </trans-unit>
        <trans-unit id="3f19bd785ca0e403ace13135f2e7d2f6fda0fce7" translate="yes" xml:space="preserve">
          <source>and get &lt;code&gt;&quot;mu&lt;/code&gt; &amp;szlig;&lt;code&gt;&quot;&lt;/code&gt; in &lt;code&gt;$match&lt;/code&gt; , since &lt;code&gt;&quot;mu&lt;/code&gt; &amp;szlig;&lt;code&gt;&quot;&lt;/code&gt; is primary equal to &lt;code&gt;&quot;M&lt;/code&gt; &amp;uuml;&lt;code&gt;SS&quot;&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;&quot;mu&lt;/code&gt; &amp;szlig; &lt;code&gt;&quot;&lt;/code&gt; 는 기본적으로 &lt;code&gt;&quot;M&lt;/code&gt; &amp;uuml; &lt;code&gt;SS&quot;&lt;/code&gt; 와 같으 므로 &lt;code&gt;$match&lt;/code&gt; 에서 &lt;code&gt;&quot;mu&lt;/code&gt; &amp;szlig; &lt;code&gt;&quot;&lt;/code&gt; 를 얻 습니다 .</target>
        </trans-unit>
        <trans-unit id="17094f04dd71da09c7e552c076f1634e82049f36" translate="yes" xml:space="preserve">
          <source>and have it work portably.</source>
          <target state="translated">휴대하게 작동하도록합니다.</target>
        </trans-unit>
        <trans-unit id="a5a8ee21b9af7088e79e9b68f8de88da612fb525" translate="yes" xml:space="preserve">
          <source>and have some pending arguments such as header-file names. This is ok:</source>
          <target state="translated">헤더 파일 이름과 같은 보류중인 인수가 있습니다. 괜찮습니다 :</target>
        </trans-unit>
        <trans-unit id="d2a6339505fec77b2c331da5c4ce78372f108fa3" translate="yes" xml:space="preserve">
          <source>and hence print:</source>
          <target state="translated">따라서 인쇄 :</target>
        </trans-unit>
        <trans-unit id="43fb62ee614e6b7e422fd695927ade0aa52a2d8a" translate="yes" xml:space="preserve">
          <source>and here is a C function to call it</source>
          <target state="translated">여기에 그것을 호출하는 C 함수가 있습니다</target>
        </trans-unit>
        <trans-unit id="5091999bd97a90f1245944c2fb5cff579789d3a7" translate="yes" xml:space="preserve">
          <source>and here is a C function to call it.</source>
          <target state="translated">그리고 이것을 호출하는 C 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b815eb7a25ba6650e8aed21b42d3225c5665f92" translate="yes" xml:space="preserve">
          <source>and if a method-name was given, it is invoked as:</source>
          <target state="translated">method-name이 주어지면 다음과 같이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="cc0088cffc94d4cfc5e772584e99d2d2392934ec" translate="yes" xml:space="preserve">
          <source>and if you want to compress each file one at a time, this will do the trick</source>
          <target state="translated">각 파일을 한 번에 하나씩 압축하려면 트릭을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="99ebfac46815750e967685ef0c045d72e263a9e9" translate="yes" xml:space="preserve">
          <source>and in</source>
          <target state="translated">그리고</target>
        </trans-unit>
        <trans-unit id="633f5443d1716f6d61c0fc8d8b08ec73cf1d7a57" translate="yes" xml:space="preserve">
          <source>and in:</source>
          <target state="translated">그리고 안에 :</target>
        </trans-unit>
        <trans-unit id="1d0130f8a3921bc892b37851ce6cc11bad75e4c1" translate="yes" xml:space="preserve">
          <source>and is</source>
          <target state="translated">그리고</target>
        </trans-unit>
        <trans-unit id="ebbea3f118453a1b7e7d79408e6db651a9e30122" translate="yes" xml:space="preserve">
          <source>and is invoked when you say</source>
          <target state="translated">당신이 말할 때 호출됩니다</target>
        </trans-unit>
        <trans-unit id="7ecd6605c858a1a66d6b614d96b36273cffaf756" translate="yes" xml:space="preserve">
          <source>and is now removed.</source>
          <target state="translated">이제 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="73402b7701fac32d16b3ff7c74498b1589d19a23" translate="yes" xml:space="preserve">
          <source>and is sought only in the current directory.</source>
          <target state="translated">현재 디렉토리에서만 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15dd7cf5f3a3a46ccd4b8609412b5d9ec3d381ec" translate="yes" xml:space="preserve">
          <source>and is typically used to test whether a particular extension is available.</source>
          <target state="translated">일반적으로 특정 확장이 사용 가능한지 테스트하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="040dda9958c7c671c9590ef80fa78defd13909d5" translate="yes" xml:space="preserve">
          <source>and is used like this:</source>
          <target state="translated">다음과 같이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7a0762f239de965ed45f319d1c0a1eb571367472" translate="yes" xml:space="preserve">
          <source>and it always croaks on error.</source>
          <target state="translated">항상 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="37328fc9c48882c8dd3a9ee9675314c5a2fe5451" translate="yes" xml:space="preserve">
          <source>and it is called thusly</source>
          <target state="translated">그리고 그것은 그렇게 불린다</target>
        </trans-unit>
        <trans-unit id="30dae0c952d8a4bc4211df4fa02a32b80f898a03" translate="yes" xml:space="preserve">
          <source>and it will print:</source>
          <target state="translated">그리고 그것은 인쇄됩니다 :</target>
        </trans-unit>
        <trans-unit id="92f48e8870b365babea517ca9b817b451b407aad" translate="yes" xml:space="preserve">
          <source>and it would import the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; override. But if they said</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 재정의를 가져옵니다 . 하지만 그들이 말하면</target>
        </trans-unit>
        <trans-unit id="c15e27e77f8641be998c0928e2456baabe13d2d3" translate="yes" xml:space="preserve">
          <source>and look for 'undef' to find the unsupported APIs (or from Perl use Config).</source>
          <target state="translated">지원되지 않는 API (또는 Perl use Config)를 찾으려면 'undef'를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="d0408bb76ba414190a2d1aabc2693a0c0369eb0d" translate="yes" xml:space="preserve">
          <source>and managing the</source>
          <target state="translated">그리고 관리</target>
        </trans-unit>
        <trans-unit id="6d7251c76d8c565a4c8c07c1d963ea078e2097d6" translate="yes" xml:space="preserve">
          <source>and never returns</source>
          <target state="translated">그리고 절대 반환하지 않습니다</target>
        </trans-unit>
        <trans-unit id="ffbc147df069ca6800db6b624cd3c1abcb34c6b3" translate="yes" xml:space="preserve">
          <source>and no matter which sort of shell it's called from, the Perl program will read from the file</source>
          <target state="translated">어떤 종류의 쉘에서 호출하든 Perl 프로그램은 파일에서 읽습니다.</target>
        </trans-unit>
        <trans-unit id="2f3522d8409fab2c8bd7a9a935e5958b1545b923" translate="yes" xml:space="preserve">
          <source>and not</source>
          <target state="translated">그리고 아닙니다</target>
        </trans-unit>
        <trans-unit id="aece363ea57b99203cb8486606d46afddab39c93" translate="yes" xml:space="preserve">
          <source>and not worry about whether the subscripts are reserved words. In the rare event that you do wish to do something like</source>
          <target state="translated">아래 첨자가 예약어인지 걱정하지 않아도됩니다. 드물게 다음과 같은 일을하고 싶은 경우</target>
        </trans-unit>
        <trans-unit id="90867a465b6b8e0350b0a553fb9bdc04f2f044ec" translate="yes" xml:space="preserve">
          <source>and notify &amp;lt;modules@perl.org&amp;gt;.</source>
          <target state="translated">&amp;lt;modules@perl.org&amp;gt;에게 알리십시오.</target>
        </trans-unit>
        <trans-unit id="4fe6790d00afd2e85336f040031f25d3b71777a0" translate="yes" xml:space="preserve">
          <source>and omit the second call to &lt;code&gt;A::foo&lt;/code&gt; (since it would not be distinct from the first call to &lt;code&gt;A::foo&lt;/code&gt; ).</source>
          <target state="translated">그리고 두 번째 호출을 생략 &lt;code&gt;A::foo&lt;/code&gt; (가 처음 호출 구별되지 않을 것 때문에 &lt;code&gt;A::foo&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="adeced66d67fcec42518c7d43125b26bcafca512" translate="yes" xml:space="preserve">
          <source>and on &lt;code&gt;PATH&lt;/code&gt; . To find arguments for these scripts Perl uses a different algorithm than</source>
          <target state="translated">그리고 &lt;code&gt;PATH&lt;/code&gt; 에 . 이 스크립트에 대한 인수를 찾으려면 Perl은 다른 알고리즘을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2af9cc5d9a90aea15c856967222ce6dfd62554a0" translate="yes" xml:space="preserve">
          <source>and on already open streams, use &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">이미 열린 스트림에서는 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c28d75bfe8ef3f77376f1de537f6ababec7c8f5" translate="yes" xml:space="preserve">
          <source>and one can inspect the value in debugger using all the possible methods.</source>
          <target state="translated">가능한 모든 방법을 사용하여 디버거에서 값을 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e3a44de13daa4279c477d6ae9ad2ae6048934f2" translate="yes" xml:space="preserve">
          <source>and only &lt;a href=&quot;perlvar#%24ERRNO&quot;&gt;$!&lt;/a&gt; and &lt;a href=&quot;perlvar#%24EXTENDED_OS_ERROR&quot;&gt;$^E&lt;/a&gt; will be locale aware. Everything else is unaffected.</source>
          <target state="translated">그리고 단지 &lt;a href=&quot;perlvar#%24ERRNO&quot;&gt;$! &lt;/a&gt;그리고 &lt;a href=&quot;perlvar#%24EXTENDED_OS_ERROR&quot;&gt;$는 ^ E는&lt;/a&gt; 로케일을 인식 할 것이다. 다른 모든 것은 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3dfb4545fb1273b004ecd4b9a59f733f64c1cedd" translate="yes" xml:space="preserve">
          <source>and only if the condition is true. &lt;code&gt;unless&lt;/code&gt; is the opposite, it executes the statement</source>
          <target state="translated">조건이 참인 경우에만. 반대의 &lt;code&gt;unless&lt;/code&gt; 가 아니면 명령문을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="45c260afb98f09cfba9f5207fc8117fcdbcb8feb" translate="yes" xml:space="preserve">
          <source>and only the first of these match:</source>
          <target state="translated">다음 중 첫 번째 만 일치합니다.</target>
        </trans-unit>
        <trans-unit id="32e3341449eff9e33d610a484aa1f31d028b2c36" translate="yes" xml:space="preserve">
          <source>and optimizing the final combined regexp.</source>
          <target state="translated">및 최종 결합 정규식을 최적화하는 단계.</target>
        </trans-unit>
        <trans-unit id="899fcac99a7dec6812e6bf7aee73eeaf10908c82" translate="yes" xml:space="preserve">
          <source>and other auto-generated files.</source>
          <target state="translated">다른 자동 생성 파일.</target>
        </trans-unit>
        <trans-unit id="c684acd53848e74a7154abad5efe0e096b7463d3" translate="yes" xml:space="preserve">
          <source>and part</source>
          <target state="translated">그리고 부분</target>
        </trans-unit>
        <trans-unit id="d67e5dc377fc2536598e164820c52f727da6d6ab" translate="yes" xml:space="preserve">
          <source>and pass &lt;code&gt;$buf&lt;/code&gt; to your send routine. Some protocols demand that the count should include the length of the count itself: then just add 4 to the data length. (But make sure to read &lt;a href=&quot;#Lengths-and-Widths&quot;&gt;Lengths and Widths&lt;/a&gt; before you really code this!)</source>
          <target state="translated">&lt;code&gt;$buf&lt;/code&gt; 를 send 루틴으로 전달 하십시오. 일부 프로토콜은 카운트 자체에 카운트 길이가 포함되도록 요구합니다. 데이터 길이에 4를 추가하십시오. (그러나 실제로 코딩하기 전에 &lt;a href=&quot;#Lengths-and-Widths&quot;&gt;길이와 너비&lt;/a&gt; 를 읽으십시오 !)</target>
        </trans-unit>
        <trans-unit id="d58ccce831f8e9123bc9e80b9e66f8248b980f4c" translate="yes" xml:space="preserve">
          <source>and process time (in UNIX-like systems the sum of</source>
          <target state="translated">프로세스 시간 (UNIX 계열 시스템에서</target>
        </trans-unit>
        <trans-unit id="3fd6226fa225944b6194d79ef250caae14aa04c4" translate="yes" xml:space="preserve">
          <source>and produces results. If you need to customize its behaviour you should probably familiarize yourself with the source first. Enough lecturing.</source>
          <target state="translated">결과를 생성합니다. 동작을 사용자 정의해야하는 경우 먼저 소스에 익숙해 져야합니다. 충분한 강의.</target>
        </trans-unit>
        <trans-unit id="bc18719ba2c64a9b71c32941b959a3b37a8e9ccb" translate="yes" xml:space="preserve">
          <source>and programs into</source>
          <target state="translated">프로그램</target>
        </trans-unit>
        <trans-unit id="04b3f3eb12446afa59ba04e34128aaa73360c8fb" translate="yes" xml:space="preserve">
          <source>and puts the</source>
          <target state="translated">그리고 넣어</target>
        </trans-unit>
        <trans-unit id="1050864b9d5630870510b4c5ed9d494b62e3e1ac" translate="yes" xml:space="preserve">
          <source>and recompile perl</source>
          <target state="translated">펄을 다시 컴파일</target>
        </trans-unit>
        <trans-unit id="04dc98e6e6ecb08df2b06a8c82f091b8669d8771" translate="yes" xml:space="preserve">
          <source>and return a list anyway. If so, then only the last element of the list will be returned.</source>
          <target state="translated">어쨌든 목록을 반환하십시오. 그렇다면 목록의 마지막 요소 만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="bea3ea10f617b4820cdc83a6257e4c5d2c2ed531" translate="yes" xml:space="preserve">
          <source>and returns a sequence of octets.</source>
          <target state="translated">일련의 옥텟을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="69bdd065458a753e9be3338a81aee1403915b245" translate="yes" xml:space="preserve">
          <source>and returns this:</source>
          <target state="translated">이것을 반환합니다 :</target>
        </trans-unit>
        <trans-unit id="05a85acb845c8558aabbfdc75bce2f31eacc6f3d" translate="yes" xml:space="preserve">
          <source>and runs it through the pager specified in &lt;code&gt;$CPAN::Config-&amp;gt;{pager}&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$CPAN::Config-&amp;gt;{pager}&lt;/code&gt; 지정된 호출기를 통해 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="88b01bfc16080bd793c508ce92be40c54c4e0d32" translate="yes" xml:space="preserve">
          <source>and see whether they list something resembling these</source>
          <target state="translated">그들이 이것과 유사한 것을 나열하는지 확인하십시오</target>
        </trans-unit>
        <trans-unit id="9407dd89aa838f3db9bc1ee001171ae499cdf58c" translate="yes" xml:space="preserve">
          <source>and send a line of data to it this way:</source>
          <target state="translated">이런 식으로 데이터 라인을 보내십시오.</target>
        </trans-unit>
        <trans-unit id="834b5f4699ca8ef5bed1ec71205174ca1aa071f2" translate="yes" xml:space="preserve">
          <source>and should never be used lightly.</source>
          <target state="translated">가볍게 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="cc72a00bf5f82a31e19586f8d5648eeb9609f807" translate="yes" xml:space="preserve">
          <source>and so on.</source>
          <target state="translated">등등.</target>
        </trans-unit>
        <trans-unit id="9db3feda6610247fb93d16581c9f1e324a0dc3ce" translate="yes" xml:space="preserve">
          <source>and so on. Note how the trailing sub-version is automatically stripped from the version.</source>
          <target state="translated">등등. 후행 하위 버전이 버전에서 자동으로 제거되는 방법에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="0b888a2f960617a6f6c366d202b424cbea99cdde" translate="yes" xml:space="preserve">
          <source>and some C to call it</source>
          <target state="translated">그리고 일부 C는 그것을 호출합니다</target>
        </trans-unit>
        <trans-unit id="a1e18734fb68f76855ac9d83f86033f89bcb6297" translate="yes" xml:space="preserve">
          <source>and someone has been calling it with an array or expression returning a list:</source>
          <target state="translated">누군가가 목록을 반환하는 배열이나 표현식으로 그것을 호출했습니다.</target>
        </trans-unit>
        <trans-unit id="c88d797f97ab7980940e6fbc2a0b1b0f03bf45ed" translate="yes" xml:space="preserve">
          <source>and start with this template:</source>
          <target state="translated">이 템플릿으로 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="60a1a53956f7f1b07c9ff7e2cf048e0d61cf0aff" translate="yes" xml:space="preserve">
          <source>and still have it work under all the modes Perl could have been compiled with.</source>
          <target state="translated">그리고 Perl이 컴파일 할 수있는 모든 모드에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b93c07a562c2c0c86991f560b275725c74228f04" translate="yes" xml:space="preserve">
          <source>and suffix of C&amp;lt;.dat&amp;gt; would generate a file similar to F</source>
          <target state="translated">C &amp;lt;.dat&amp;gt;의 접미사는 F와 유사한 파일을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="58b0b8a5933189f91ce79bd5aaa4c4a91a53f4c2" translate="yes" xml:space="preserve">
          <source>and symbolic sub references</source>
          <target state="translated">및 상징적 하위 참조</target>
        </trans-unit>
        <trans-unit id="c8bd05940ef361af618d2f58d8ef228c2dc1eee1" translate="yes" xml:space="preserve">
          <source>and that the default flags are kept in a global C variable &lt;code&gt;default_flags&lt;/code&gt; . Suppose that you want to create an interface which is called as</source>
          <target state="translated">기본 플래그는 전역 C 변수 &lt;code&gt;default_flags&lt;/code&gt; 에 유지됩니다 . 다음과 같이 호출되는 인터페이스를 작성한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="97ed4c8cfdc4058f64674afafa62d45ea754ba4b" translate="yes" xml:space="preserve">
          <source>and that will set this class as the default formatter to run when you do &lt;code&gt;perldoc whatever&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;perldoc whatever&lt;/code&gt; 할 때이 클래스를 기본 포맷터로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="38d402cb5ba5ced669d83f33b900f232ec58d72a" translate="yes" xml:space="preserve">
          <source>and the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6a3e1044d78ff80b32d4053c48546a54399bb4a" translate="yes" xml:space="preserve">
          <source>and the (compiled)</source>
          <target state="translated">그리고 (컴파일 된)</target>
        </trans-unit>
        <trans-unit id="7709e2962fcebb7a32dface22926131efe462333" translate="yes" xml:space="preserve">
          <source>and the &lt;code&gt;&quot;-&quot;&lt;/code&gt; shouldn't be the first character. If you want to be hypercorrect, stay case-insensitive and within the 8.3 naming convention (all the files and directories have to be unique within one directory if their names are lowercased and truncated to eight characters before the &lt;code&gt;.&lt;/code&gt;, if any, and to three characters after the &lt;code&gt;.&lt;/code&gt;, if any). (And do not use &lt;code&gt;.&lt;/code&gt;s in directory names.)</source>
          <target state="translated">그리고 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 첫 번째 문자 안된다. 과도하게 수정하려면 대소 문자를 구분하지 않고 8.3 이름 지정 규칙 내에서 유지하십시오 (모든 파일과 디렉토리는 이름이 소문자로되어 있고 &lt;code&gt;.&lt;/code&gt; (있는 경우) 및 3 개로 8 문자로 잘린 경우 하나의 디렉토리 내에서 고유해야합니다) &lt;code&gt;.&lt;/code&gt; 뒤에 나오는 문자 ). 디렉토리 이름에는 .s를 사용하지 마십시오 &lt;code&gt;.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4d66f33f291aa497e1fbb1cea751208ffbc34985" translate="yes" xml:space="preserve">
          <source>and the &lt;code&gt;S_IF*&lt;/code&gt; functions are</source>
          <target state="translated">상기 &lt;code&gt;S_IF*&lt;/code&gt; 기능은</target>
        </trans-unit>
        <trans-unit id="2942a15e2cfe5df5d7b4806203036ff2059365fd" translate="yes" xml:space="preserve">
          <source>and the &lt;code&gt;build&lt;/code&gt; of the &lt;code&gt;prereqs&lt;/code&gt; field of your</source>
          <target state="translated">그리고 당신 의 &lt;code&gt;prereqs&lt;/code&gt; 필드의 &lt;code&gt;build&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ab5709809a705fe3cbf34a47d36a8f9e3b151b2f" translate="yes" xml:space="preserve">
          <source>and the &lt;code&gt;configure&lt;/code&gt; of the &lt;code&gt;prereqs&lt;/code&gt; field of your</source>
          <target state="translated">그리고 &lt;code&gt;configure&lt;/code&gt; 의가 &lt;code&gt;prereqs&lt;/code&gt; 의 필드를하여</target>
        </trans-unit>
        <trans-unit id="02c4a9e6fa1ed7552c9cc696dccfac8693bb8d07" translate="yes" xml:space="preserve">
          <source>and the &lt;code&gt;padadd_STATE&lt;/code&gt; flag get added to</source>
          <target state="translated">그리고 &lt;code&gt;padadd_STATE&lt;/code&gt; 의 플래그에 추가됩니다</target>
        </trans-unit>
        <trans-unit id="3e4685b36d5a4d2703e2682160eabe2135a107d7" translate="yes" xml:space="preserve">
          <source>and the &lt;code&gt;runtime&lt;/code&gt; of the &lt;code&gt;prereqs&lt;/code&gt; field of your</source>
          <target state="translated">그리고 당신 의 &lt;code&gt;prereqs&lt;/code&gt; 필드의 &lt;code&gt;runtime&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="25ff9d2e379f8fa04204de9723f370d19f946094" translate="yes" xml:space="preserve">
          <source>and the &lt;code&gt;test&lt;/code&gt; of the &lt;code&gt;prereqs&lt;/code&gt; field of your</source>
          <target state="translated">그리고 당신 의 &lt;code&gt;prereqs&lt;/code&gt; 필드의 &lt;code&gt;test&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ad51d3bef464cc47afa473cbf58e8f411acbad00" translate="yes" xml:space="preserve">
          <source>and the B part would be serialized by the engine. In &lt;code&gt;STORABLE_thaw&lt;/code&gt; , you would get back the reference to the B' object, deserialized for you.</source>
          <target state="translated">B 부분은 엔진에 의해 직렬화됩니다. 에서 &lt;code&gt;STORABLE_thaw&lt;/code&gt; , 당신은 당신을 위해 직렬화 B 조 '개체에 대한 참조를 다시 얻을 것입니다.</target>
        </trans-unit>
        <trans-unit id="147f20996051af5faf516917523025a59c3b1223" translate="yes" xml:space="preserve">
          <source>and the anonymous sub used with a</source>
          <target state="translated">익명 하위는</target>
        </trans-unit>
        <trans-unit id="be7ddd8a1c2d20b11344c530e59b1a76ec5867c2" translate="yes" xml:space="preserve">
          <source>and the assignments to &lt;code&gt;@ISA&lt;/code&gt; and &lt;code&gt;@EXPORT_OK&lt;/code&gt; happen immediately, leaving no room for something to get awry or just plain wrong.</source>
          <target state="translated">&lt;code&gt;@ISA&lt;/code&gt; 및 &lt;code&gt;@EXPORT_OK&lt;/code&gt; 에 대한 할당은 즉시 발생하므로 무언가 잘못되거나 명백한 잘못이 생길 여지가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ec3881e38f6bc29241523880e8b6087893781e29" translate="yes" xml:space="preserve">
          <source>and the code for rpcb_gettime() can be rewritten as</source>
          <target state="translated">rpcb_gettime () 코드는 다음과 같이 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0b288947e39526d473e38a00227523ed22a3b40" translate="yes" xml:space="preserve">
          <source>and the context and data stacks, as shown by &lt;code&gt;-Dstv&lt;/code&gt; , look like:</source>
          <target state="translated">&lt;code&gt;-Dstv&lt;/code&gt; 로 표시되는 컨텍스트 및 데이터 스택 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0053caf8d86bff52b61e0db6e20570501321030d" translate="yes" xml:space="preserve">
          <source>and the decoding is</source>
          <target state="translated">디코딩은</target>
        </trans-unit>
        <trans-unit id="6db487f2363f1808733e361f4f9ef6e4c29bac55" translate="yes" xml:space="preserve">
          <source>and the dual-life modules are in</source>
          <target state="translated">이중 수명 모듈은</target>
        </trans-unit>
        <trans-unit id="701a5fbfcd6a3d0bfbaa14dc1799d0bcc3687760" translate="yes" xml:space="preserve">
          <source>and the first argument of myref() will be a reference to a scalar, an array, a hash, a code, or a glob.</source>
          <target state="translated">myref ()의 첫 번째 인수는 스칼라, 배열, 해시, 코드 또는 glob에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="41644e439068ccf4dd12a38456eb1c0abd4f9ac4" translate="yes" xml:space="preserve">
          <source>and the following code will read the hexdump in and convert it on the fly back into bytes:</source>
          <target state="translated">다음 코드는 16 진수 덤프를 읽고 바이트 단위로 즉시 변환합니다.</target>
        </trans-unit>
        <trans-unit id="50b6d807bc1aa40041d0aec64ce2f373303ab28d" translate="yes" xml:space="preserve">
          <source>and the latter should be used for consistency.</source>
          <target state="translated">후자는 일관성을 위해 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="a319d5d5f1db6ffbf62ebbd0eae703d0f1b20336" translate="yes" xml:space="preserve">
          <source>and the method form of &lt;code&gt;isa&lt;/code&gt; for the second:</source>
          <target state="translated">두 번째에 대한 &lt;code&gt;isa&lt;/code&gt; 의 메소드 형식 :</target>
        </trans-unit>
        <trans-unit id="d51a49fa5c4b18f00dbcb9d665d43c1102906852" translate="yes" xml:space="preserve">
          <source>and the newer &lt;a href=&quot;concise&quot;&gt;B::Concise&lt;/a&gt;, &lt;a href=&quot;terse&quot;&gt;B::Terse&lt;/a&gt;.</source>
          <target state="translated">최신 &lt;a href=&quot;concise&quot;&gt;B :: Concise&lt;/a&gt; , &lt;a href=&quot;terse&quot;&gt;B :: Terse&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0101ea36f11aa234346b21c12169ca0fa18afce9" translate="yes" xml:space="preserve">
          <source>and the numeric value of $c becomes 5. However, after calling</source>
          <target state="translated">$ c의 숫자 값은 5가됩니다. 그러나 호출 후</target>
        </trans-unit>
        <trans-unit id="59496338c48bb851d2fcd377f515a4eb8426caa1" translate="yes" xml:space="preserve">
          <source>and the old 5.005 style threading, or for that matter, to most other threading systems out there, is that by default, no data is shared. When a new Perl thread is created, all the data associated with the current thread is copied to the new thread, and is subsequently private to that new thread! This is similar in feel to what happens when a Unix process forks, except that in this case, the data is just copied to a different part of memory within the same process rather than a real fork taking place.</source>
          <target state="translated">구식 5.005 스타일 스레딩 또는 그 문제에 대한 대부분의 다른 스레딩 시스템은 기본적으로 데이터가 공유되지 않는다는 것입니다. 새 Perl 스레드가 작성되면 현재 스레드와 연관된 모든 데이터가 새 스레드에 복사되고 이후에 해당 새 스레드의 개인 정보입니다! 이것은 유닉스 프로세스가 포크 될 때 발생하는 것과 비슷하지만,이 경우 데이터는 실제 포크가 아니라 동일한 프로세스 내에서 메모리의 다른 부분으로 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="f98e525fd3fa23c9c2e46620627a8148db25bb3f" translate="yes" xml:space="preserve">
          <source>and the process defaults to expand the filespec) and pass the rest of &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;'s argument to it as parameters. If the token has no file type, and matches a file with null type, then an attempt is made to determine whether the file is an executable image which should be invoked using &lt;code&gt;MCR&lt;/code&gt; or a text file which should be passed to DCL as a command procedure.</source>
          <target state="translated">프로세스는 기본적으로 파일 사양을 확장하고 나머지 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 인수를 매개 변수로 전달합니다. 토큰에 파일 유형이없고 널 유형의 파일과 일치하는 경우 파일이 &lt;code&gt;MCR&lt;/code&gt; 을 사용하여 호출해야하는 실행 가능 이미지인지 또는 명령 프로 시저로서 DCL에 전달되어야하는 텍스트 파일 인지 판별하려고 시도 합니다. .</target>
        </trans-unit>
        <trans-unit id="ddacafb3c506d7d636313e8cd8381b88b300fc0f" translate="yes" xml:space="preserve">
          <source>and the process defaults, and if successful, the resulting file is invoked via &lt;code&gt;MCR&lt;/code&gt; . This allows you to invoke an image directly simply by passing the file specification to &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, a common Unixish idiom. If the token has no file type, and matches a file with null type, then an attempt is made to determine whether the file is an executable image which should be invoked using &lt;code&gt;MCR&lt;/code&gt; or a text file which should be passed to DCL as a command procedure.</source>
          <target state="translated">프로세스 기본값이며 성공한 경우 결과 파일은 &lt;code&gt;MCR&lt;/code&gt; 을 통해 호출됩니다 . 이를 통해 파일 사양을 일반적인 Unixish 관용구 인 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 으로 전달하여 이미지를 직접 호출 할 수 있습니다 . 토큰에 파일 유형이없고 널 유형의 파일과 일치하는 경우 파일이 &lt;code&gt;MCR&lt;/code&gt; 을 사용하여 호출해야하는 실행 가능 이미지인지 또는 명령 프로 시저로서 DCL에 전달되어야하는 텍스트 파일 인지 판별하려고 시도 합니다. .</target>
        </trans-unit>
        <trans-unit id="01a7d35d5fca09ca87a957bce5a8e41bd9acadb8" translate="yes" xml:space="preserve">
          <source>and the repeat count is obtained by popping off the last element from the stack. The</source>
          <target state="translated">반복 횟수는 스택에서 마지막 요소를 팝핑하여 얻습니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="ffb8c286d177a7fde4b96ec8e58df11a57708992" translate="yes" xml:space="preserve">
          <source>and the result is not what you likely expected. No warnings are generated. If you do string &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;'s within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , you should instead change the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; line to do something like:</source>
          <target state="translated">결과는 예상했던 것과 다릅니다. 경고가 생성되지 않습니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 범위 내에서 string &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 을 수행하는 경우 대신 다음과 같이 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 행을 변경해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5826e275e51e2f92c417012d26e57183b67ddebf" translate="yes" xml:space="preserve">
          <source>and the second as</source>
          <target state="translated">그리고 두 번째</target>
        </trans-unit>
        <trans-unit id="4b0c54cf5e55bcce5334c4fb8936e4b45df4be44" translate="yes" xml:space="preserve">
          <source>and the variable is only assigned if the condition is false. In Perl, you need parentheses:</source>
          <target state="translated">변수는 조건이 거짓 인 경우에만 할당됩니다. Perl에서는 괄호가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b195225fa7acc0b96c9d796bff6aa32f9bf25de1" translate="yes" xml:space="preserve">
          <source>and their source code:</source>
          <target state="translated">그리고 그들의 소스 코드 :</target>
        </trans-unit>
        <trans-unit id="a357a0b3b6bb01e41a042b584904f6b12375f3f1" translate="yes" xml:space="preserve">
          <source>and then</source>
          <target state="translated">그리고</target>
        </trans-unit>
        <trans-unit id="a89a3626b8565f1e4fe93595aa23beb07a814bdf" translate="yes" xml:space="preserve">
          <source>and then &lt;code&gt;make install&lt;/code&gt; directly in the subshell.</source>
          <target state="translated">그런 다음 서브 쉘에 직접 &lt;code&gt;make install&lt;/code&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="c057b91530af5ff3d52f001fe2897560766773fd" translate="yes" xml:space="preserve">
          <source>and then I can use it as:</source>
          <target state="translated">그런 다음 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ee1c36bc806d74c955b8deeab5a71a91290b0b4" translate="yes" xml:space="preserve">
          <source>and then at the end add a subroutine (which will override the pre-existing subroutine). Remember to use a tab character to indent the line beginning with &quot;cd&quot;!</source>
          <target state="translated">그런 다음 끝에 서브 루틴을 추가하십시오 (기존 서브 루틴을 대체 함). &quot;cd&quot;로 시작하는 줄을 들여 쓰려면 탭 문자를 사용해야합니다!</target>
        </trans-unit>
        <trans-unit id="ab0d506f35fd3822d193cc9360b63e031c3942f4" translate="yes" xml:space="preserve">
          <source>and then calls the compiled value, and returns that. (I.e., if $key looks like bracket notation, $compiled is a sub, and we return &amp;amp;{$compiled}(@params); but if $key is just a plain string, we just return that.)</source>
          <target state="translated">그런 다음 컴파일 된 값을 호출하고이를 반환합니다. (즉, $ key가 대괄호 표기법처럼 보이면 $ compiled는 하위이고 &amp;amp; {$ compiled} (@ params)를 반환하지만 $ key가 일반 문자열이면 반환합니다.)</target>
        </trans-unit>
        <trans-unit id="44a3152294c4111f2c746a317f7528eba26af20d" translate="yes" xml:space="preserve">
          <source>and then compile Perl. The places where fchdir() is used have alternatives for systems that do not have fchdir() available.</source>
          <target state="translated">그런 다음 Perl을 컴파일하십시오. fchdir ()이 사용되는 장소에는 사용 가능한 fchdir ()이없는 시스템에 대한 대안이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b2df89c641d69f45a815efca5beef7560ca9a0a" translate="yes" xml:space="preserve">
          <source>and then just answer client requests for language $wanted by just looking up</source>
          <target state="translated">그런 다음 조회 만하면 원하는 언어에 대한 고객 요청에 응답 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b1640f57029d1835984f3af20d2191014b99ddf" translate="yes" xml:space="preserve">
          <source>and then only hard references will be allowed for the rest of the enclosing block. An inner block may countermand that with</source>
          <target state="translated">그런 다음 나머지 둘러싸는 블록에 대해 하드 참조 만 허용됩니다. 내부 블록은</target>
        </trans-unit>
        <trans-unit id="451e30567469e8b460f1d3bc5414c41a6638cddf" translate="yes" xml:space="preserve">
          <source>and then re-compiling and installing. (&lt;code&gt;%Config&lt;/code&gt; is available from the Config module).</source>
          <target state="translated">그런 다음 다시 컴파일하고 설치하십시오. ( &lt;code&gt;%Config&lt;/code&gt; 는 구성 모듈에서 사용 가능합니다).</target>
        </trans-unit>
        <trans-unit id="a0240abc49e91dec760c37658ba9b71575aed0e0" translate="yes" xml:space="preserve">
          <source>and then restart the debugger using the &lt;code&gt;R&lt;/code&gt; command (if possible). One can use &lt;code&gt;b
compile subname&lt;/code&gt; for the same purpose.</source>
          <target state="translated">그런 다음 &lt;code&gt;R&lt;/code&gt; 명령을 사용하여 디버거를 다시 시작하십시오 (가능한 경우). 같은 목적으로 &lt;code&gt;b compile subname&lt;/code&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dbf31119ed47c5f8b69e18f4d5f705e1c96574bd" translate="yes" xml:space="preserve">
          <source>and then there's</source>
          <target state="translated">그리고 거기에</target>
        </trans-unit>
        <trans-unit id="353ea5311f06d213fb4274ba5a999ecceb56a41b" translate="yes" xml:space="preserve">
          <source>and then use pax.</source>
          <target state="translated">그리고 pax를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="48126773317a746d38788a830d1f700877f824cc" translate="yes" xml:space="preserve">
          <source>and there are currently 32 types. These different structures contain pointers to various routines that perform additional actions depending on which function is being called.</source>
          <target state="translated">현재 32 가지 유형이 있습니다. 이러한 다른 구조에는 호출되는 기능에 따라 추가 조치를 수행하는 다양한 루틴에 대한 포인터가 있습니다.</target>
        </trans-unit>
        <trans-unit id="125d179aee3f08c5f3f28753f2a610fce93912ec" translate="yes" xml:space="preserve">
          <source>and these</source>
          <target state="translated">그리고 이것들</target>
        </trans-unit>
        <trans-unit id="e1493a3f0807b6f38cd28b6afc4496c286e444bc" translate="yes" xml:space="preserve">
          <source>and these conditions now hold; changes in caps:</source>
          <target state="translated">그리고 이러한 상태는 현재 유지되고 있습니다. 한도 변경 :</target>
        </trans-unit>
        <trans-unit id="634f4431e19540e83429c99c727415ca241cf810" translate="yes" xml:space="preserve">
          <source>and they need renamed to this</source>
          <target state="translated">그들은 이것으로 이름을 바꿔야합니다</target>
        </trans-unit>
        <trans-unit id="c08d7693095dbd2bcba2f2bba00e5c933e696272" translate="yes" xml:space="preserve">
          <source>and things will Just Work.</source>
          <target state="translated">일이 잘 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="13d6234dafca22c495f68d2e93ffa91530cf4576" translate="yes" xml:space="preserve">
          <source>and this all reduces to one string internally. Likewise, if you say</source>
          <target state="translated">그리고 이것은 모두 내부적으로 하나의 문자열로 줄어 듭니다. 마찬가지로 말하면</target>
        </trans-unit>
        <trans-unit id="54d316122df54908b330dbe67e0eb1a7496b2e8d" translate="yes" xml:space="preserve">
          <source>and this is the C function</source>
          <target state="translated">그리고 이것은 C 함수입니다</target>
        </trans-unit>
        <trans-unit id="b0b7cef2e136b9167abea8c18920b79278779cc6" translate="yes" xml:space="preserve">
          <source>and this is the equivalent skeleton for the</source>
          <target state="translated">그리고 이것은</target>
        </trans-unit>
        <trans-unit id="6eebd24f36d63aecef99cba57072fffe82f277ba" translate="yes" xml:space="preserve">
          <source>and this is what it outputs:</source>
          <target state="translated">그리고 이것이 출력되는 것입니다 :</target>
        </trans-unit>
        <trans-unit id="fd12e4da86b9aadfbb2734c8e5f1bee5da3b93ce" translate="yes" xml:space="preserve">
          <source>and this to write compress files, if you have the &lt;code&gt;compress&lt;/code&gt; program available</source>
          <target state="translated">&lt;code&gt;compress&lt;/code&gt; 프로그램을 사용할 수 있는 경우 압축 파일을 작성 합니다.</target>
        </trans-unit>
        <trans-unit id="e2c2bf67a7935e18e359ad79d84198585a4af3bd" translate="yes" xml:space="preserve">
          <source>and this with &lt;code&gt;gunzip&lt;/code&gt;</source>
          <target state="translated">그리고 이건 &lt;code&gt;gunzip&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d39dfbea4e5b4447637693f64c38ebc1f8116f81" translate="yes" xml:space="preserve">
          <source>and thus the North American servers happen to be listed between the European and the South American sites.</source>
          <target state="translated">따라서 북미 서버는 유럽과 남미 사이트 사이에 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="cb400c328bbed62df7bf2a79424df0971a9b0060" translate="yes" xml:space="preserve">
          <source>and to convert it back:</source>
          <target state="translated">다시 변환하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="389eab738d2c24825aaf583e6d4e7e90f7197558" translate="yes" xml:space="preserve">
          <source>and to make a subroutine visible to other packages in the same scope:</source>
          <target state="translated">동일한 범위의 다른 패키지에서 서브 루틴을 볼 수있게하려면 :</target>
        </trans-unit>
        <trans-unit id="217975290eb70597845ac22d0c9eaec6ba4f2b06" translate="yes" xml:space="preserve">
          <source>and to pop the return value out. Take a deep breath...</source>
          <target state="translated">반환 값을 튀어 나옵니다. 심호흡하십시오 ...</target>
        </trans-unit>
        <trans-unit id="f2f253ad479c1e47993bd311d49420fc3740b03a" translate="yes" xml:space="preserve">
          <source>and to prevent the filter's being turned off in any way:</source>
          <target state="translated">어떤 식 으로든 필터가 꺼지는 것을 방지하려면 :</target>
        </trans-unit>
        <trans-unit id="f457722dbced2bf2ae91cbfea945e31146a31b39" translate="yes" xml:space="preserve">
          <source>and to set CCHOME, CCINCDIR and CCLIBDIR as per the environment setup above.</source>
          <target state="translated">위의 환경 설정에 따라 CCHOME, CCINCDIR 및 CCLIBDIR을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="d2fe6dcb8f246d2fce35f742575fa001821e5680" translate="yes" xml:space="preserve">
          <source>and tries again, since it's customary to have file types on all files under VMS.</source>
          <target state="translated">VMS 아래의 모든 파일에 파일 형식이있는 것이 일반적이기 때문에 다시 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="3b1648c7e0ac8e95616dae97bc077625fd8d6af2" translate="yes" xml:space="preserve">
          <source>and uncomment the relevant variables near the end of the file.</source>
          <target state="translated">파일 끝 근처에서 관련 변수의 주석을 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="cfcf943d2393a6f28d49e0ffac0815fd27da0bf6" translate="yes" xml:space="preserve">
          <source>and uncomment the struct.</source>
          <target state="translated">구조체의 주석 처리를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="9e6562a3babb41524cb81f0cde70dfef28222be8" translate="yes" xml:space="preserve">
          <source>and under Win32, the approximately equivalent:</source>
          <target state="translated">그리고 Win32에서는 대략 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="46d5ca958aec010c55ad2c03e5821dac149faf98" translate="yes" xml:space="preserve">
          <source>and use the &lt;code&gt;TIOCNOTTY&lt;/code&gt; ioctl() on it instead. See tty(4) for details.</source>
          <target state="translated">그리고 사용 &lt;code&gt;TIOCNOTTY&lt;/code&gt; 의 대신에 IOCTL을 (). 자세한 내용은 tty (4)를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9f14a6780c851ae104f1481fc1a9906cf9782249" translate="yes" xml:space="preserve">
          <source>and wait:</source>
          <target state="translated">그리고 기다려:</target>
        </trans-unit>
        <trans-unit id="69c07c00f94d0c5b0709bf9c6938ba419bdf55e3" translate="yes" xml:space="preserve">
          <source>and when compiling the POSIX extension</source>
          <target state="translated">POSIX 확장을 컴파일 할 때</target>
        </trans-unit>
        <trans-unit id="6ee8bc7f7f274956ec858de1f58858d8da87dae0" translate="yes" xml:space="preserve">
          <source>and will work on any list:</source>
          <target state="translated">모든 목록에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="56f643ea045d7d28116e861b4f87f762cdd48385" translate="yes" xml:space="preserve">
          <source>and you are attempting to remove an ancestor, such as</source>
          <target state="translated">다음과 같은 조상을 제거하려고합니다.</target>
        </trans-unit>
        <trans-unit id="675d70b7c962e8ca4b793a761fbb9992623d3828" translate="yes" xml:space="preserve">
          <source>and you can create well-formed Unicode with</source>
          <target state="translated">다음과 같이 올바른 형식의 유니 코드를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c639a2ec15edc09ca8e02e951acf39319cc8f44" translate="yes" xml:space="preserve">
          <source>and you want to Export symbol &lt;code&gt;$A::b&lt;/code&gt; back to the module that called package A. Since Exporter relies on the import method to work, via inheritance, as it stands Exporter::import() will never get called. Instead, say the following:</source>
          <target state="translated">그리고 &lt;code&gt;$A::b&lt;/code&gt; 심볼을 패키지 A라는 모듈로 다시 내보내 려고합니다. Exporter :: import ()는 호출되지 않으므로 상속을 통해 import 메소드를 사용하여 상속을 수행합니다. 대신 다음과 같이 말합니다.</target>
        </trans-unit>
        <trans-unit id="622cd26503fac9383fb718bed2b3ddba040f7083" translate="yes" xml:space="preserve">
          <source>and you want to produce an output like this, with each country mentioned once, and then an alphabetical list of the cities in that country:</source>
          <target state="translated">각 국가를 한 번 언급 한 다음 해당 국가의 도시를 알파벳순으로 나열하여 다음과 같은 출력을 생성하려고합니다.</target>
        </trans-unit>
        <trans-unit id="4c1468c599d605484919b48473553ef4293085c5" translate="yes" xml:space="preserve">
          <source>and you're done.</source>
          <target state="translated">그리고 당신은 끝났습니다.</target>
        </trans-unit>
        <trans-unit id="b0adec687e3ab4fff14b5efa8b7087cfcfe80d04" translate="yes" xml:space="preserve">
          <source>and/or</source>
          <target state="translated">and/or</target>
        </trans-unit>
        <trans-unit id="9f29ab58f3ce583beed68be5f3bf29542855d9de" translate="yes" xml:space="preserve">
          <source>angles being equal to</source>
          <target state="translated">같은 각도</target>
        </trans-unit>
        <trans-unit id="03f6df04819f61a4ed7725f72fc3f5557572193e" translate="yes" xml:space="preserve">
          <source>angles.</source>
          <target state="translated">angles.</target>
        </trans-unit>
        <trans-unit id="0a92fab3230134cca6eadd9898325b9b2ae67998" translate="yes" xml:space="preserve">
          <source>anonymous</source>
          <target state="translated">anonymous</target>
        </trans-unit>
        <trans-unit id="f3939ccfbbc78c50725aff277833f2cbdd31e9da" translate="yes" xml:space="preserve">
          <source>anonymous subroutine.)</source>
          <target state="translated">익명 서브 루틴.)</target>
        </trans-unit>
        <trans-unit id="14ccf9a789edbcad8533f0e8977c70173ff9dfa6" translate="yes" xml:space="preserve">
          <source>anonymous@</source>
          <target state="translated">anonymous@</target>
        </trans-unit>
        <trans-unit id="b7c8ffb8fbc67c171328e0e8f643694e8e61b335" translate="yes" xml:space="preserve">
          <source>another</source>
          <target state="translated">another</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
