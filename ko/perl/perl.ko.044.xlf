<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="fe9382125ff2c139dab5a2974252e8c96e13c1f7" translate="yes" xml:space="preserve">
          <source>This does not check if &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt; $brooklyn{tree}&lt;/code&gt; is true, it checks if it returns 1. Very different. Similar caveats exist for false and 0. In these cases, use &lt;code&gt;ok()&lt;/code&gt; .</source>
          <target state="translated">경우에 확인하지 않는 &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt; $brooklyn{tree}&lt;/code&gt; 사실은 매우 다른 1을 반환하는 경우가 확인. false 및 0에 대해서도 비슷한 경고가 있습니다.이 경우 &lt;code&gt;ok()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98a4bb476f64546166599da65496591b48105011" translate="yes" xml:space="preserve">
          <source>This does not consult the local filesystem on Unix, Win32, OS/2 or Mac OS (Classic). It does consult the working environment for VMS (see &lt;a href=&quot;vms#file_name_is_absolute&quot;&gt;file_name_is_absolute in File::Spec::VMS&lt;/a&gt;).</source>
          <target state="translated">Unix, Win32, OS / 2 또는 Mac OS (Classic)의 로컬 파일 시스템은 참조하지 않습니다. VMS의 작업 환경을 참조합니다 ( &lt;a href=&quot;vms#file_name_is_absolute&quot;&gt;File :: Spec :: VMS의 file_name_is_absolute&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="5567db63aec81d4f2bb7d5785e7a6d2074129096" translate="yes" xml:space="preserve">
          <source>This does not consult the local filesystem on Unix, Win32, OS/2, or Mac OS (Classic). It does consult the working environment for VMS (see &lt;a href=&quot;spec/vms#file_name_is_absolute&quot;&gt;file_name_is_absolute in File::Spec::VMS&lt;/a&gt;).</source>
          <target state="translated">Unix, Win32, OS / 2 또는 Mac OS (Classic)의 로컬 파일 시스템은 참조하지 않습니다. VMS의 작업 환경을 참조합니다 ( &lt;a href=&quot;spec/vms#file_name_is_absolute&quot;&gt;File :: Spec :: VMS의 file_name_is_absolute&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="0a35bcc864cbc531874ff7b69a1ed16eb2d6e952" translate="yes" xml:space="preserve">
          <source>This does not need an interpreter context, so the definition has no &lt;code&gt;pTHX&lt;/code&gt; , and it follows that callers don't use &lt;code&gt;aTHX&lt;/code&gt; . (See &lt;a href=&quot;#Background-and-PERL_IMPLICIT_CONTEXT&quot;&gt;Background and PERL_IMPLICIT_CONTEXT&lt;/a&gt;.)</source>
          <target state="translated">인터프리터 컨텍스트가 필요하지 않으므로 정의에는 &lt;code&gt;pTHX&lt;/code&gt; 가 없으며 호출자가 &lt;code&gt;aTHX&lt;/code&gt; 를 사용하지 않습니다 . ( &lt;a href=&quot;#Background-and-PERL_IMPLICIT_CONTEXT&quot;&gt;배경 및 PERL_IMPLICIT_CONTEXT&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="7d5400494835955231d73bab6efd7d27c959f429" translate="yes" xml:space="preserve">
          <source>This does not work with object methods, however; all object methods have to be in the symbol table of some package to be found. See &lt;a href=&quot;perlref#Function-Templates&quot;&gt;Function Templates in perlref&lt;/a&gt; for something of a work-around to this.</source>
          <target state="translated">그러나 객체 메소드에서는 작동하지 않습니다. 모든 객체 메소드는 찾을 패키지의 심볼 테이블에 있어야합니다. 이에 대한 해결 방법 &lt;a href=&quot;perlref#Function-Templates&quot;&gt;은 perlref의 함수 템플리트를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0d2225ec395dc726d6f789db247181b8752831a9" translate="yes" xml:space="preserve">
          <source>This does require you to read the entire archive in to memory first, since otherwise we wouldn't know what data to fill the copy with. (This means that you cannot use the class methods, including &lt;code&gt;iter&lt;/code&gt; on archives that have incompatible filetypes and still expect things to work).</source>
          <target state="translated">그렇지 않으면 복사본을 채울 데이터를 알 수 없으므로 전체 아카이브를 메모리로 먼저 읽어야합니다. (이것은 호환되지 않는 파일 형식이 있고 여전히 작동하는 아카이브의 &lt;code&gt;iter&lt;/code&gt; 를 포함하여 클래스 메소드를 사용할 수 없음을 의미합니다 ).</target>
        </trans-unit>
        <trans-unit id="d695e6a31e5a4eec6a56e77d637d17eb575265f8" translate="yes" xml:space="preserve">
          <source>This does the same:</source>
          <target state="translated">이것은 동일합니다 :</target>
        </trans-unit>
        <trans-unit id="dc02dd18bd8bcc4ec6d08efce5d8f98b8592ad09" translate="yes" xml:space="preserve">
          <source>This doesn't copy the underlying array:</source>
          <target state="translated">이것은 기본 배열을 복사하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6a45cffcf59adcdd497d8553e6a4ac8aa27d7fd9" translate="yes" xml:space="preserve">
          <source>This doesn't do anything to your input, or to your output. It only influences the way your sources are read. You can use Unicode in string literals, in identifiers (but they still have to be &quot;word characters&quot; according to &lt;code&gt;\w&lt;/code&gt; ), and even in custom delimiters.</source>
          <target state="translated">이것은 입력이나 출력에 아무런 영향을 미치지 않습니다. 소스를 읽는 방식에만 영향을줍니다. 문자열 리터럴, 식별자 ( &lt;code&gt;\w&lt;/code&gt; 에 따라 &quot;단어 문자&quot;여야 함 ) 및 사용자 지정 구분 기호로 유니 코드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c08d4d18717ad728adb161ebb6ace72d574c3c92" translate="yes" xml:space="preserve">
          <source>This doesn't mean that a &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; variable declared in a statically enclosing lexical scope would be invisible. Only dynamic scopes are cut off. For example, the &lt;code&gt;bumpx()&lt;/code&gt; function below has access to the lexical $x variable because both the &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; and the &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; occurred at the same scope, presumably file scope.</source>
          <target state="translated">이것은 정적으로 둘러싸는 어휘 범위에서 선언 된 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 변수 가 보이지 않음을 의미하지는 않습니다 . 동적 범위 만 잘립니다. 예를 들어, 아래 의 &lt;code&gt;bumpx()&lt;/code&gt; 함수는 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 가 모두 같은 범위, 아마도 파일 범위에서 발생 했기 때문에 어휘 $ x 변수에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e40a26e5ea83812803ea5b81ef047b1db82eff02" translate="yes" xml:space="preserve">
          <source>This doesn't work if you explicitly specify a loop variable, as in &lt;code&gt;for $item (@array)&lt;/code&gt; . You have to use the default variable &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;for $item (@array)&lt;/code&gt; 에서와 같이 루프 변수를 명시 적으로 지정하면 작동하지 않습니다 . 기본 변수 &lt;code&gt;$_&lt;/code&gt; 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a2c583421317d67ae6f6464366487994f4149ea1" translate="yes" xml:space="preserve">
          <source>This doesn't work so cleanly for varargs functions, though, as macros imply that the number of arguments is known in advance. Instead we either need to spell them out fully, passing &lt;code&gt;aTHX_&lt;/code&gt; as the first argument (the Perl core tends to do this with functions like Perl_warner), or use a context-free version.</source>
          <target state="translated">매크로는 인수의 수를 미리 알 수 있기 때문에 varargs 함수에는 그렇게 잘 작동하지 않습니다. 대신 &lt;code&gt;aTHX_&lt;/code&gt; 를 첫 번째 인수로 전달 하고 (Perl 코어는 Perl_warner와 같은 기능을 사용하는 경향이 있음) 컨텍스트가없는 버전을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="dd35b5e520e91c0129daf21db3448c07f88b99cf" translate="yes" xml:space="preserve">
          <source>This effect can be demonstrated by setting up a test script with both forms, including a &lt;code&gt;debug()&lt;/code&gt; subroutine to emulate typical &lt;code&gt;logger()&lt;/code&gt; functionality.</source>
          <target state="translated">이 효과는 일반적인 &lt;code&gt;logger()&lt;/code&gt; 기능 을 에뮬레이트하기 위해 &lt;code&gt;debug()&lt;/code&gt; 서브 루틴을 포함하여 두 가지 형식으로 테스트 스크립트를 설정하여 시연 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fbe2310a8ff7d61c27678f186cd1f8d32e53b8ee" translate="yes" xml:space="preserve">
          <source>This effectively means that your source code behaves as if it were written in UTF-8 with &lt;code&gt;'use utf8&lt;/code&gt; ' in effect. So even if your editor only supports Shift_JIS, for example, you can still try examples in Chapter 15 of &lt;code&gt;Programming Perl, 3rd Ed.&lt;/code&gt;.</source>
          <target state="translated">이는 사실상 소스 코드가 &lt;code&gt;'use utf8&lt;/code&gt; '을 사용 하여 마치 UTF-8로 작성된 것처럼 작동 함을 의미합니다 . 예를 들어, 편집기가 Shift_JIS 만 지원하더라도 &lt;code&gt;Programming Perl, 3rd Ed.&lt;/code&gt; 15 장에서 예제를 시도 할 수 있습니다 . .</target>
        </trans-unit>
        <trans-unit id="f3a80c354b71b0daaada6c4b42d328f1e3ab3798" translate="yes" xml:space="preserve">
          <source>This enables a trace mode and is primarily for debugging bigint or Math::BigInt.</source>
          <target state="translated">이는 추적 모드를 가능하게하며 주로 bigint 또는 Math :: BigInt를 디버깅하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="9c02cc31d70507771fd57c515a75adc482efe06a" translate="yes" xml:space="preserve">
          <source>This enables a trace mode and is primarily for debugging bignum or Math::BigInt/Math::BigFloat.</source>
          <target state="translated">이는 추적 모드를 가능하게하며 주로 bignum 또는 Math :: BigInt / Math :: BigFloat를 디버깅하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cec63c166c07d8ad2b6a0564923160e4e6afd3a9" translate="yes" xml:space="preserve">
          <source>This enables aliasing via assignment to references:</source>
          <target state="translated">이를 통해 참조 할당을 통해 앨리어싱을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0c59e41b4a3df893d1d884cf9253595b11ba6fc" translate="yes" xml:space="preserve">
          <source>This enables debugging output when calling commandline utilities to fetch files. This also enables &lt;code&gt;Carp::longmess&lt;/code&gt; errors, instead of the regular &lt;code&gt;carp&lt;/code&gt; errors.</source>
          <target state="translated">파일을 가져 오기 위해 명령 줄 유틸리티를 호출 할 때 출력을 디버깅 할 수 있습니다. 또한 일반적인 &lt;code&gt;carp&lt;/code&gt; 오류 대신 &lt;code&gt;Carp::longmess&lt;/code&gt; 오류 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="79613693422bd25bf48f5f8810aa0da8bd572cf9" translate="yes" xml:space="preserve">
          <source>This enables declaration of subroutines via &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; sub foo&lt;/code&gt; , &lt;code&gt;state sub foo&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt; sub foo&lt;/code&gt; syntax. See &lt;a href=&quot;perlsub#Lexical-Subroutines&quot;&gt;Lexical Subroutines in perlsub&lt;/a&gt; for details.</source>
          <target state="translated">이를 통해 서브 루틴의 선언을 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; sub foo&lt;/code&gt; , &lt;code&gt;state sub foo&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt; sub foo&lt;/code&gt; 구문. 자세한 내용 &lt;a href=&quot;perlsub#Lexical-Subroutines&quot;&gt;은 perlsub의 어휘 서브 루틴을&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="80e1dcd9c198904d910331965aa69cd1ca8bccf4" translate="yes" xml:space="preserve">
          <source>This enables the programmer to do operations that combine functionalities that are available in the shell.</source>
          <target state="translated">이를 통해 프로그래머는 쉘에서 사용 가능한 기능을 결합하는 조작을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e90120b49b0763003fb5ddee58d3021476d96c8e" translate="yes" xml:space="preserve">
          <source>This enables unpacking of subroutine arguments into lexical variables by syntax such as</source>
          <target state="translated">이를 통해 다음과 같은 구문으로 서브 루틴 인수를 어휘 변수에 풀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1b55e253e92ad7341b5b1784881c341c542cf5a" translate="yes" xml:space="preserve">
          <source>This entry can be used to store a C structure (the number of bytes to be copied is calculated using the C &lt;code&gt;sizeof&lt;/code&gt; function) and can be used as an alternative to T_PTRREF without having to worry about a memory leak (since Perl will clean up the SV).</source>
          <target state="translated">이 항목은 C 구조를 저장하는 데 사용할 수 있으며 (복사 할 바이트 수는 C &lt;code&gt;sizeof&lt;/code&gt; 함수를 사용하여 계산 됨 ) 메모리 누출에 대해 걱정할 필요없이 T_PTRREF의 대안으로 사용할 수 있습니다 (Perl은 SV).</target>
        </trans-unit>
        <trans-unit id="2f3300c27110c85898913011cf397618813e91ac" translate="yes" xml:space="preserve">
          <source>This environment variable allows the user to specify custom color aliases that will be understood by color(), colored(), and colorvalid(). None of the other functions will be affected, and no new color constants will be created. The custom colors are aliases for existing color names; no new escape sequences can be introduced. Only alphanumerics, &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;_&lt;/code&gt; , and &lt;code&gt;-&lt;/code&gt; are allowed in alias names.</source>
          <target state="translated">이 환경 변수를 사용하면 color (), colored () 및 colorvalid ()로 이해할 수있는 사용자 지정 색 별명을 지정할 수 있습니다. 다른 기능은 영향을받지 않으며 새로운 색 상수가 생성되지 않습니다. 사용자 정의 색상은 기존 색상 이름의 별명입니다. 새로운 이스케이프 시퀀스를 도입 할 수 없습니다. 영숫자 만 &lt;code&gt;.&lt;/code&gt; 별명에는 , &lt;code&gt;_&lt;/code&gt; 및 &lt;code&gt;-&lt;/code&gt; 가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="eeb4dcf1cb6c13fe396a4c4857e58d83a3e881a1" translate="yes" xml:space="preserve">
          <source>This environment variable is read and applied when the Term::ANSIColor module is loaded and is then subsequently ignored. Changes to ANSI_COLORS_ALIASES after the module is loaded will have no effect. See coloralias() for an equivalent facility that can be used at runtime.</source>
          <target state="translated">이 환경 변수는 Term :: ANSIColor 모듈을로드 한 다음 무시할 때 읽고 적용됩니다. 모듈이로드 된 후 ANSI_COLORS_ALIASES를 변경해도 아무런 영향이 없습니다. 런타임에 사용할 수있는 동등한 기능에 대해서는 coloralias ()를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="08e7401d917dc7c04b41058352f2e564e79feab2" translate="yes" xml:space="preserve">
          <source>This environment variable, available starting in Perl v5.20, if set (to any value), tells Perl to not use the rest of the environment variables to initialize with. Instead, Perl uses whatever the current locale settings are. This is particularly useful in embedded environments, see &lt;a href=&quot;perlembed#Using-embedded-Perl-with-POSIX-locales&quot;&gt;Using embedded Perl with POSIX locales in perlembed&lt;/a&gt;.</source>
          <target state="translated">Perl v5.20부터 사용 가능한이 환경 변수는 값을 설정 한 경우 Perl에게 나머지 환경 변수를 사용하여 초기화하지 않도록 지시합니다. 대신, Perl은 현재 로케일 설정을 사용합니다. 이는 임베디드 환경에서 특히 유용 &lt;a href=&quot;perlembed#Using-embedded-Perl-with-POSIX-locales&quot;&gt;합니다. perlembed에서 POSIX 로케일에 임베디드 Perl 사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="01f9c0ecaa03744be9ea320c0c4f588e6b9faad8" translate="yes" xml:space="preserve">
          <source>This evaluates STRING as perl code inside the compartment.</source>
          <target state="translated">이것은 STRING을 구획 내부의 펄 코드로 평가합니다.</target>
        </trans-unit>
        <trans-unit id="85da3ed8e7eeed1d7664ca9b45804ed926dd64a7" translate="yes" xml:space="preserve">
          <source>This evaluates the contents of file FILENAME inside the compartment. See above documentation on the &lt;b&gt;reval&lt;/b&gt; method for further details.</source>
          <target state="translated">구획 내 파일 FILENAME의 내용을 평가합니다. 자세한 내용은 위의 &lt;b&gt;평가&lt;/b&gt; 방법 문서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="c4d1039eeddc372ecb07a9ed65ed3a51b6d6ae64" translate="yes" xml:space="preserve">
          <source>This example added quite a few new concepts. We'll take them one at a time.</source>
          <target state="translated">이 예제는 몇 가지 새로운 개념을 추가했습니다. 한 번에 하나씩 가져갑니다.</target>
        </trans-unit>
        <trans-unit id="b69f2ecf80918f850deb9506044c7c7d1e270ee4" translate="yes" xml:space="preserve">
          <source>This example does not include any retries and may consequently fail to contact a reachable host. The most prominent reason for this is congestion of the queues on the sending host if the number of hosts to contact is sufficiently large.</source>
          <target state="translated">이 예에는 재 시도가 포함되지 않으므로 연결 가능한 호스트에 연결하지 못할 수도 있습니다. 가장 두드러진 이유는 접속할 호스트 수가 충분히 많은 경우 송신 호스트에서 큐가 정체되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="90a572c629dcfb44919f712f7d6b779f25e5dfe2" translate="yes" xml:space="preserve">
          <source>This example is aborted at compile time as we use the attribute &quot;Test&quot; which isn't allowed. &lt;code&gt;MODIFY_CODE_ATTRIBUTES&lt;/code&gt; returns a list that contains a single element ('Test').</source>
          <target state="translated">허용되지 않는 &quot;Test&quot;속성을 사용하므로이 예제는 컴파일 타임에 중단됩니다. &lt;code&gt;MODIFY_CODE_ATTRIBUTES&lt;/code&gt; 는 단일 요소 ( 'Test')가 포함 된 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f90369b8f8beb64315ed6181cebf6923dd367b56" translate="yes" xml:space="preserve">
          <source>This example is fairly trivial; for more complex cases and a deeper explanation, see the links in the &lt;a href=&quot;#SEE-ALSO&quot;&gt;SEE ALSO&lt;/a&gt; section.</source>
          <target state="translated">이 예제는 매우 사소합니다. 더 복잡한 경우와 자세한 설명은 다음 섹션 의 링크를 &lt;a href=&quot;#SEE-ALSO&quot;&gt;참조&lt;/a&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="1253f47712d1828f7f774117d0efa3abf09df500" translate="yes" xml:space="preserve">
          <source>This example is fully equivalent with:</source>
          <target state="translated">이 예제는 다음과 완전히 동일합니다.</target>
        </trans-unit>
        <trans-unit id="4cd1eae4be0b88a312be5ff0a3c94c909b4f359b" translate="yes" xml:space="preserve">
          <source>This example is preferred over the previous one--even for Unix platforms--because now any &lt;code&gt;\015&lt;/code&gt; 's (&lt;code&gt;\cM&lt;/code&gt; 's) are stripped out (and there was much rejoicing).</source>
          <target state="translated">이 예제는 유닉스 플랫폼에서도 이전의 것보다 선호됩니다. 이제 모든 &lt;code&gt;\015&lt;/code&gt; ( &lt;code&gt;\cM&lt;/code&gt; 's)가 제거 되었기 때문에 (기뻐하는 것이 많았습니다).</target>
        </trans-unit>
        <trans-unit id="2155785b4684f8ca5810fa768aca5a675651e726" translate="yes" xml:space="preserve">
          <source>This example prints the mail domain name of the SMTP server known as mailhost:</source>
          <target state="translated">이 예는 mailhost로 알려진 SMTP 서버의 메일 도메인 이름을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="5df3c7e69cf9c030621b9397e847c01645ddee17" translate="yes" xml:space="preserve">
          <source>This example requires the following typemap entry. Consult &lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt; for more information about adding new typemaps for an extension.</source>
          <target state="translated">이 예에는 다음 유형 맵 항목이 필요합니다. 확장을위한 새 유형 맵 추가에 대한 자세한 정보는 &lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="41a9b74b00161dd5b470ab9ac8171979158c1d90" translate="yes" xml:space="preserve">
          <source>This example runs. At compile time &lt;code&gt;MODIFY_CODE_ATTRIBUTES&lt;/code&gt; is called. In that subroutine, we check if any attribute is disallowed and we return a list of these &quot;bad attributes&quot;.</source>
          <target state="translated">이 예제가 실행됩니다. 컴파일 타임에 &lt;code&gt;MODIFY_CODE_ATTRIBUTES&lt;/code&gt; 가 호출됩니다. 이 서브 루틴에서 속성이 허용되지 않는지 확인하고 이러한 &quot;잘못된 속성&quot;목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8ff407d302a1d7afb3f758e29e8d54e23989741b" translate="yes" xml:space="preserve">
          <source>This example sends a small message to the postmaster at the SMTP server known as mailhost:</source>
          <target state="translated">이 예제는 mailhost라는 SMTP 서버의 포스트 마스터에게 작은 메시지를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="78b434a9f3a15806251887966899fdd84de7d2e2" translate="yes" xml:space="preserve">
          <source>This example separates a text into fields which are quote delimited, curly bracketed, and anything else. The delimited and bracketed parts are also blessed to identify them (the &quot;anything else&quot; is unblessed):</source>
          <target state="translated">이 예에서는 텍스트를 따옴표로 구분하고 중괄호로 묶고 그 밖의 다른 필드로 구분합니다. 구분되고 괄호로 묶인 부분은 또한 그것을 식별 할 수있는 축복을받습니다 ( &quot;다른 것&quot;은 축복되지 않음).</target>
        </trans-unit>
        <trans-unit id="9dff0d51281eb7bf5e0a018b6b24fe9e35070941" translate="yes" xml:space="preserve">
          <source>This example shows how to create a database, add key/value pairs to the database, delete keys/value pairs and finally how to enumerate the contents of the database.</source>
          <target state="translated">이 예제는 데이터베이스를 작성하고, 키 / 값 쌍을 데이터베이스에 추가하고, 키 / 값 쌍을 삭제하고, 마지막으로 데이터베이스의 내용을 열거하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="880ede3f528ae25983090ec0e0156cb403c63af8" translate="yes" xml:space="preserve">
          <source>This example shows rewriting weights. &lt;code&gt;rewrite&lt;/code&gt; is allowed to affect code points, weights, and the name.</source>
          <target state="translated">이 예제는 가중치 재 작성을 보여줍니다. &lt;code&gt;rewrite&lt;/code&gt; 는 코드 포인트, 가중치 및 이름에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="780bd69540d0ebaeb9c9ed4a226f52e8bf4d6c92" translate="yes" xml:space="preserve">
          <source>This example shows two calls that should have the same effect:</source>
          <target state="translated">이 예는 동일한 효과를 가져야하는 두 개의 호출을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="84ff60fe8d031f55c9709b2299fa816e68248930" translate="yes" xml:space="preserve">
          <source>This example takes a regular expression from the argument list and prints the lines of input that match it:</source>
          <target state="translated">이 예제는 인수 목록에서 정규식을 가져와 일치하는 입력 행을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="078e5feeaf68f01a2929c0090cee690d8ca945ea" translate="yes" xml:space="preserve">
          <source>This example treats the slightly modified contents of $directory as a hash. The modifications are that the keys</source>
          <target state="translated">이 예에서는 $ directory의 약간 수정 된 내용을 해시로 취급합니다. 수정은 열쇠입니다</target>
        </trans-unit>
        <trans-unit id="98e05dd997bb9813bf387c2523a2ee3778ba728f" translate="yes" xml:space="preserve">
          <source>This example uses a code expression in a conditional to match a definite article, either 'the' in English or 'der|die|das' in German:</source>
          <target state="translated">이 예는 조건부에서 코드 표현식을 사용하여 영어의 'the'또는 독일어의 'der | die | das'와 같은 명확한 기사와 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="c87cae12f1868f49317dcbc2ec2e9d5385ba1820" translate="yes" xml:space="preserve">
          <source>This example will be used with the following Perl statements.</source>
          <target state="translated">이 예제는 다음 Perl 문과 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f8787b73d75916a7f7029d06b65a57928067677b" translate="yes" xml:space="preserve">
          <source>This example will fail to recognize that an error occurred inside the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; . Here's why: the call_Subtract code got executed while perl was cleaning up temporaries when exiting the outer braced block, and because call_Subtract is implemented with</source>
          <target state="translated">이 예제는 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; 내에서 오류가 발생했음을 인식하지 못합니다 . 이유는 다음과 같습니다. 외부 괄호 블록을 종료 할 때 perl이 임시를 정리하는 동안 call_Subtract 코드가 실행되었으며 call_Subtract가</target>
        </trans-unit>
        <trans-unit id="3f78c3b59ae95350e4323c3cb4c7f0dc6fda1338" translate="yes" xml:space="preserve">
          <source>This example works on many platforms that have a shell compatible with Bourne shell:</source>
          <target state="translated">이 예제는 Bourne 쉘과 호환되는 쉘이있는 많은 플랫폼에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="15d5f8da3c8eb09a121cb765eeca738ccef36a74" translate="yes" xml:space="preserve">
          <source>This experimental attribute, introduced in Perl 5.22, only applies to anonymous subroutines. It causes the subroutine to be called as soon as the &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; expression is evaluated. The return value is captured and turned into a constant subroutine.</source>
          <target state="translated">Perl 5.22에 도입 된이 실험 속성은 익명 서브 루틴에만 적용됩니다. &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 표현식이 평가 되 자마자 서브 루틴이 호출되도록 합니다. 리턴 값이 캡처되어 일정한 서브 루틴으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="c659fee685d6111f5eef41a4fc47f104c94d024f" translate="yes" xml:space="preserve">
          <source>This expression is actually equivalent to &lt;code&gt;$x &amp;amp; ($y == 0)&lt;/code&gt; , due to the higher precedence of &lt;code&gt;==&lt;/code&gt; . This is probably not what you want. (If you really meant to write this, disable the warning, or, better, put the parentheses explicitly and write &lt;code&gt;$x &amp;amp; ($y == 0)&lt;/code&gt; ).</source>
          <target state="translated">이 표현은 실제로 동일하다 &lt;code&gt;$x &amp;amp; ($y == 0)&lt;/code&gt; 기인의 높은 우선 순위로 &lt;code&gt;==&lt;/code&gt; . 이것은 아마도 당신이 원하는 것이 아닙니다. (실제로 이것을 쓰려면 경고를 비활성화하거나 괄호를 명시 적으로 넣고 &lt;code&gt;$x &amp;amp; ($y == 0)&lt;/code&gt; )하십시오.</target>
        </trans-unit>
        <trans-unit id="3d95c2dd6bdf3facfce8eb7c29c42e8682159b3f" translate="yes" xml:space="preserve">
          <source>This extension is somewhat contrived. It is based on the code in the previous example. It calls the statfs function multiple times, accepting a reference to an array of filenames as input, and returning a reference to an array of hashes containing the data for each of the filesystems.</source>
          <target state="translated">이 확장은 다소 고안되었습니다. 이전 예제의 코드를 기반으로합니다. statfs 함수를 여러 번 호출하여 파일 이름 배열에 대한 참조를 입력으로 허용하고 각 파일 시스템에 대한 데이터를 포함하는 해시 배열에 대한 참조를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="443c1ad31c99bd2962c1e14f9f6e565d7abce59c" translate="yes" xml:space="preserve">
          <source>This extension is very Unix-oriented (struct statfs and the statfs system call). If you are not running on a Unix system, you can substitute for statfs any other function that returns multiple values, you can hard-code values to be returned to the caller (although this will be a bit harder to test the error case), or you can simply not do this example. If you change the XSUB, be sure to fix the test cases to match the changes.</source>
          <target state="translated">이 확장은 매우 유닉스 지향적입니다 (struct statfs 및 statfs 시스템 호출). Unix 시스템에서 실행하지 않는 경우 여러 값을 반환하는 다른 함수를 statfs 대신 사용할 수 있습니다. 값을 호출자에게 반환하도록 하드 코딩 할 수 있습니다 (오류 사례를 테스트하기가 조금 더 어렵지만), 또는 단순히이 예제를 수행 할 수 없습니다. XSUB를 변경하는 경우 변경 사항에 맞게 테스트 케이스를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="31882b218e30926e9578b39c27a5a21498d0f3ba" translate="yes" xml:space="preserve">
          <source>This fails because the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; makes STDERR go to where STDOUT was going at the time of the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;. The backticks then make STDOUT go to a string, but don't change STDERR (which still goes to the old STDOUT).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 이 STDERR이 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 당시 STDOUT이 가고 있던 곳으로 이동하기 때문에 실패합니다 . 백틱은 STDOUT을 문자열로 만들지 만 STDERR을 변경하지는 않습니다 (이전 STDOUT으로 계속 이동 함).</target>
        </trans-unit>
        <trans-unit id="31d57b0a4260007b8d7df0d0cf0818de49b401fd" translate="yes" xml:space="preserve">
          <source>This failure does not seem to cause any problems. With older gcc versions, &quot;parse error&quot; is reported instead of &quot;missing binary operator&quot;.</source>
          <target state="translated">이 실패는 문제를 일으키지 않는 것 같습니다. 이전 gcc 버전에서는 &quot;이진 연산자 누락&quot;대신 &quot;구문 분석 오류&quot;가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="7e96692d6e8677f9247e8d718c35a2f5314dd78a" translate="yes" xml:space="preserve">
          <source>This feature (introduced in Perl 5.10) significantly extends the power of Perl's pattern matching. By referring to some other capture group anywhere in the pattern with the construct &lt;code&gt;(?group-ref)&lt;/code&gt;, the</source>
          <target state="translated">이 기능 (Perl 5.10에서 도입)은 Perl의 패턴 일치 기능을 크게 확장합니다. 구문 &lt;code&gt;(?group-ref)&lt;/code&gt; 을 사용하여 패턴의 임의의 다른 캡처 그룹을 참조 하면</target>
        </trans-unit>
        <trans-unit id="39313d94f9ceb03c0da32836d49794a646f76b32" translate="yes" xml:space="preserve">
          <source>This feature allows code like this to work :</source>
          <target state="translated">이 기능을 사용하면 다음과 같은 코드가 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d279f2466dab661314717405c1c291df785e033f" translate="yes" xml:space="preserve">
          <source>This feature hasn't been tested with multiple threads, but it will only show the backtrace of the thread doing the backtracing.</source>
          <target state="translated">이 기능은 여러 스레드에서 테스트되지 않았지만 백 트레이싱을 수행하는 스레드의 역 추적 만 표시합니다.</target>
        </trans-unit>
        <trans-unit id="3f31330eeb1eb16a4131ea44941bd450e02ba159" translate="yes" xml:space="preserve">
          <source>This feature is available from Perl 5.16 onwards.</source>
          <target state="translated">이 기능은 Perl 5.16부터 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0eb6c955c276bb211d5f6e97040a35b64f681c9" translate="yes" xml:space="preserve">
          <source>This feature is available from Perl 5.18 onwards.</source>
          <target state="translated">이 기능은 Perl 5.18부터 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5350c7db9e5ccded478eeb543bf7a26b7856c3e9" translate="yes" xml:space="preserve">
          <source>This feature is available from Perl 5.20 onwards.</source>
          <target state="translated">이 기능은 Perl 5.20부터 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d594f14a3251cf1780c8a95d14833fb1764cbcb5" translate="yes" xml:space="preserve">
          <source>This feature is available from Perl 5.22 onwards.</source>
          <target state="translated">이 기능은 Perl 5.22부터 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdd060361bef60c9e8d128e54b15bdf49a0df3f0" translate="yes" xml:space="preserve">
          <source>This feature is available starting with Perl 5.10.</source>
          <target state="translated">이 기능은 Perl 5.10부터 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f16229bb3e38370fa369bac03ef842b45e6ac174" translate="yes" xml:space="preserve">
          <source>This feature is available starting with Perl 5.12; was almost fully implemented in Perl 5.14; and extended in Perl 5.16 to cover &lt;code&gt;&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 기능은 Perl 5.12부터 사용할 수 있습니다. Perl 5.14에서 거의 완전히 구현되었습니다. 그리고 &lt;code&gt;&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;&lt;/code&gt; 를 포함하도록 Perl 5.16에서 확장되었습니다 .</target>
        </trans-unit>
        <trans-unit id="d3fa1f4ec8b7292a36ec1d671af80c0ba1c4dbf6" translate="yes" xml:space="preserve">
          <source>This feature is available starting with Perl 5.16.</source>
          <target state="translated">이 기능은 Perl 5.16부터 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cf7997500a8320557eaa4d36e75775cc5a5b761" translate="yes" xml:space="preserve">
          <source>This feature is available under this name starting with Perl 5.16. In previous versions, it was simply on all the time, and this pragma knew nothing about it.</source>
          <target state="translated">이 기능은이 이름으로 Perl 5.16부터 사용할 수 있습니다. 이전 버전에서는 항상 그저 그랬지만이 pragma는 그것에 대해 전혀 몰랐습니다.</target>
        </trans-unit>
        <trans-unit id="b957d6504ae997d3a3efef291b5e1aad2b736b3a" translate="yes" xml:space="preserve">
          <source>This feature is enabled by 'importing' the non-existent symbol 'verbose'. You would typically enable it by saying</source>
          <target state="translated">이 기능은 존재하지 않는 기호 'verbose'를 '가져 오기'하여 활성화됩니다. 일반적으로</target>
        </trans-unit>
        <trans-unit id="02d76db5faed0f26a8be3e80c39fd86b2f9e9ac8" translate="yes" xml:space="preserve">
          <source>This feature is implemented as a new op type, &lt;code&gt;OP_CUSTOM&lt;/code&gt; . The Perl core does not &quot;know&quot; anything special about this op type, and so it will not be involved in any optimizations. This also means that you can define your custom ops to be any op structure -- unary, binary, list and so on -- you like.</source>
          <target state="translated">이 기능은 새로운 op 유형 인 &lt;code&gt;OP_CUSTOM&lt;/code&gt; 으로 구현됩니다 . Perl 코어는이 op 유형에 대해 특별한 것을 &quot;알지&quot;않으므로 최적화에 관여하지 않습니다. 즉, 원하는 op 구조 (단항, 이진, 목록 등)로 사용자 지정 op를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3d9a13d27e32567256bd5ed07966300b2843571" translate="yes" xml:space="preserve">
          <source>This feature is useful when processing a file format that encapsulates a compressed data stream (e.g. gzip, zip) and there is useful data immediately after the deflation stream.</source>
          <target state="translated">이 기능은 압축 된 데이터 스트림 (예 : gzip, zip)을 캡슐화하는 파일 형식을 처리 할 때 유용하며 수축 스트림 직후에 유용한 데이터가 있습니다.</target>
        </trans-unit>
        <trans-unit id="70ff4f5cd1e98da8a085f691d09087dfafce10bc" translate="yes" xml:space="preserve">
          <source>This feature is useful when processing a file format that encapsulates a compressed data stream (e.g. gzip, zip).</source>
          <target state="translated">이 기능은 압축 된 데이터 스트림을 캡슐화하는 파일 형식 (예 : gzip, zip)을 처리 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e4da939b7443e26e164efdaa4d6f81b9bc175434" translate="yes" xml:space="preserve">
          <source>This feature requires configuration option &lt;b&gt;permute&lt;/b&gt;, see section &lt;a href=&quot;#Configuring-Getopt%3a%3aLong&quot;&gt;Configuring Getopt::Long&lt;/a&gt;.</source>
          <target state="translated">이 기능에는 &lt;b&gt;permute&lt;/b&gt; 구성 옵션이 필요합니다 ( &lt;a href=&quot;#Configuring-Getopt%3a%3aLong&quot;&gt;Getopt :: Long 구성&lt;/a&gt; 섹션 참조) .</target>
        </trans-unit>
        <trans-unit id="b84829a17ad80817afc9eefb1b49f97bfdfe8fac" translate="yes" xml:space="preserve">
          <source>This feature supports the legacy &lt;code&gt;$[&lt;/code&gt; variable. See &lt;a href=&quot;perlvar#%24%5b&quot;&gt;$[ in perlvar&lt;/a&gt; and &lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt;. It is on by default but disabled under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; (see &lt;a href=&quot;#IMPLICIT-LOADING&quot;&gt;IMPLICIT LOADING&lt;/a&gt;, below).</source>
          <target state="translated">이 기능은 레거시 &lt;code&gt;$[&lt;/code&gt; 변수를 지원합니다 . &lt;a href=&quot;perlvar#%24%5b&quot;&gt;perlvar&lt;/a&gt; 및 &lt;a href=&quot;arybase&quot;&gt;arybase의 &lt;/a&gt;$ [를 참조하십시오 . 기본적으로 켜져 있지만 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; 에는 비활성화되어 &lt;a href=&quot;functions/use&quot;&gt;있습니다&lt;/a&gt; (아래의 &lt;a href=&quot;#IMPLICIT-LOADING&quot;&gt;IMPLICIT LOADING&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="ccaa07991a8c1bc153311bc6ab0dcadf92aec838" translate="yes" xml:space="preserve">
          <source>This feature, available starting in v5.12, matches any character that is &lt;b&gt;not&lt;/b&gt; a newline. It is a short-hand for writing &lt;code&gt;[^\n]&lt;/code&gt;, and is identical to the &lt;code&gt;.&lt;/code&gt; metasymbol, except under the &lt;code&gt;/s&lt;/code&gt; flag, which changes the meaning of &lt;code&gt;.&lt;/code&gt;, but not &lt;code&gt;\N&lt;/code&gt; .</source>
          <target state="translated">v5.12부터 사용 가능한이 기능 은 줄 바꿈 이 &lt;b&gt;아닌&lt;/b&gt; 모든 문자와 일치합니다 . &lt;code&gt;[^\n]&lt;/code&gt; 쓰기의 축약 형 이며와 동일합니다 &lt;code&gt;.&lt;/code&gt; metasymbol는 제외하고 &lt;code&gt;/s&lt;/code&gt; 의 의미를 변경 플래그 &lt;code&gt;.&lt;/code&gt; , 그러나 &lt;code&gt;\N&lt;/code&gt; 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="86eab6101dbb39be1f4756f21ad94b3dc3f5b53a" translate="yes" xml:space="preserve">
          <source>This field defaults to the time the &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; object was created if this option is not specified.</source>
          <target state="translated">이 필드의 기본값 은이 옵션이 지정되지 않은 경우 &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; 객체가 작성된 시간 입니다.</target>
        </trans-unit>
        <trans-unit id="0ae6e594e4f58006926409640dc519990e005708" translate="yes" xml:space="preserve">
          <source>This field defaults to the time the &lt;code&gt;IO::Compress::Zip&lt;/code&gt; object was created if this option is not specified and the &lt;code&gt;$input&lt;/code&gt; parameter is not a filename.</source>
          <target state="translated">이 필드 는이 옵션이 지정되지 않고 &lt;code&gt;$input&lt;/code&gt; 매개 변수가 파일 이름이 아닌 경우 &lt;code&gt;IO::Compress::Zip&lt;/code&gt; 오브젝트가 작성된 시간으로 기본 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="e1736869f31835444fcd2554056bb1bdc04ff6bd" translate="yes" xml:space="preserve">
          <source>This field points at a &lt;code&gt;reg_data&lt;/code&gt; structure, which is defined as follows</source>
          <target state="translated">이 필드 는 다음과 같이 정의되는 &lt;code&gt;reg_data&lt;/code&gt; 구조를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="990821d4ec37cddf0c064311fa9c677b83df34b2" translate="yes" xml:space="preserve">
          <source>This field points at a &lt;code&gt;regexp_engine&lt;/code&gt; structure which contains pointers to the subroutines that are to be used for performing a match. It is the compiling routine's responsibility to populate this field before returning the regexp object.</source>
          <target state="translated">이 필드 는 일치를 수행하는 데 사용될 서브 루틴에 대한 포인터를 포함 하는 &lt;code&gt;regexp_engine&lt;/code&gt; 구조를 가리 킵니다 . regexp 객체를 반환하기 전에이 필드를 채우는 것은 컴파일 루틴의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="423f1e020ff559262836a01099aa9f00246b3cb0" translate="yes" xml:space="preserve">
          <source>This file contains instructions how to build Perl for Haiku and lists known problems.</source>
          <target state="translated">이 파일은 Perl for Haiku를 빌드하는 방법과 알려진 문제를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="16e77d17e03a82d35fe5f118c6d17cc03a2f5d43" translate="yes" xml:space="preserve">
          <source>This file contains notes for building perl on the Stratus OpenVOS operating system. Perl is a scripting or macro language that is popular on many systems. See &lt;a href=&quot;perlbook&quot;&gt;perlbook&lt;/a&gt; for a number of good books on Perl.</source>
          <target state="translated">이 파일에는 Stratus OpenVOS 운영 체제에서 perl을 빌드하기위한 참고 사항이 포함되어 있습니다. Perl은 많은 시스템에서 널리 사용되는 스크립팅 또는 매크로 언어입니다. Perl에 관한 많은 좋은 책들에 대해서는 &lt;a href=&quot;perlbook&quot;&gt;perlbook&lt;/a&gt; 을 보십시오 .</target>
        </trans-unit>
        <trans-unit id="1b8ecba533b9b274e408d86f1a2361d08ce45153" translate="yes" xml:space="preserve">
          <source>This file contains the documentation of the perl public API generated by</source>
          <target state="translated">이 파일에는 다음에 의해 생성 된 perl public API의 문서가 들어 있습니다.</target>
        </trans-unit>
        <trans-unit id="772ef66d2f091024ffe5331d4173bb5adc436597" translate="yes" xml:space="preserve">
          <source>This file gives instructions for building Perl 5.7 and above, and also Perl modules for NetWare. Before you start, you may want to read the README file found in the top level directory into which the Perl source code distribution was extracted. Make sure you read and understand the terms under which the software is being distributed.</source>
          <target state="translated">이 파일은 Perl 5.7 이상을 빌드하기위한 지침과 NetWare 용 Perl 모듈을 제공합니다. 시작하기 전에 Perl 소스 코드 분배가 추출 된 최상위 디렉토리에있는 README 파일을 읽을 수 있습니다. 소프트웨어가 배포되는 용어를 읽고 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="6ec203908c78957c98ea92f12965f186f5810be8" translate="yes" xml:space="preserve">
          <source>This file gives the instructions for building Perl5.8 and above for WinCE. Please read and understand the terms under which this software is distributed.</source>
          <target state="translated">이 파일은 WinCE 용 Perl5.8 이상 빌드 지침을 제공합니다. 이 소프트웨어가 배포되는 조건을 읽고 이해하십시오.</target>
        </trans-unit>
        <trans-unit id="cf6acf338e7fac3c001977fe9f2038807c39d850" translate="yes" xml:space="preserve">
          <source>This file is the autogenerated documentation of functions in the Perl interpreter that are documented using Perl's internal documentation format but are not marked as part of the Perl API. In other words, &lt;b&gt;they are not for use in extensions&lt;/b&gt;!</source>
          <target state="translated">이 파일은 Perl의 내부 문서 형식을 사용하여 문서화되었지만 Perl API의 일부로 표시되지 않은 Perl 인터프리터 기능의 자동 생성 문서입니다. 즉, &lt;b&gt;확장에 사용되지 않습니다&lt;/b&gt; !</target>
        </trans-unit>
        <trans-unit id="37bc1fa4735275726caf451da3d6c18e093591a1" translate="yes" xml:space="preserve">
          <source>This file lists everyone who's contributed to Perl. If you submit a patch, you should add your name to this file as part of the patch.</source>
          <target state="translated">이 파일은 Perl에 기여한 모든 사람을 나열합니다. 패치를 제출하면 패치의 일부로이 파일에 이름을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="bfb66abe74ae898df9c2dbe0e11c53cf1576bcaf" translate="yes" xml:space="preserve">
          <source>This file resides somewhere deep in the location you installed your perl library, find it out by</source>
          <target state="translated">이 파일은 펄 라이브러리를 설치 한 위치의 어딘가에 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cb5bba8cb2fb8c111c0a512a6843cebdb2655ae" translate="yes" xml:space="preserve">
          <source>This file will get parsed, and produce a maybe empty &lt;code&gt;@DynaLoader::dl_resolve_using&lt;/code&gt; array for the current architecture. That will be extended by $BSLOADLIBS, which was computed by ExtUtils::Liblist::ext(). If this array still is empty, we do nothing, else we write a .bs file with an &lt;code&gt;@DynaLoader::dl_resolve_using&lt;/code&gt; array.</source>
          <target state="translated">이 파일은 구문 분석 되어 현재 아키텍처에 대해 비어있는 &lt;code&gt;@DynaLoader::dl_resolve_using&lt;/code&gt; 배열을 생성합니다. ExtUtils :: Liblist :: ext ()에 의해 계산 된 $ BSLOADLIBS로 확장됩니다. 이 배열이 여전히 비어 있으면 아무것도하지 않습니다. 그렇지 않으면 &lt;code&gt;@DynaLoader::dl_resolve_using&lt;/code&gt; 배열 로 .bs 파일을 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="77507ae6fec16ecb1a49a0d13053514b63919993" translate="yes" xml:space="preserve">
          <source>This filter ensures that all data written to the DBM file is null terminated. This is useful when you have a perl script that needs to interoperate with a DBM file that a C program also uses. A fairly common issue is for the C application to include the terminating null in a string when it writes to the DBM file. This filter will ensure that all data written to the DBM file can be read by the C application.</source>
          <target state="translated">이 필터는 DBM 파일에 기록 된 모든 데이터가 널 종료되도록합니다. 이는 C 프로그램이 사용하는 DBM 파일과 상호 운용해야하는 perl 스크립트가있는 경우 유용합니다. 상당히 일반적인 문제는 C 애플리케이션이 DBM 파일에 쓸 때 문자열에 종료 널을 포함시키는 것입니다. 이 필터는 C 응용 프로그램이 DBM 파일에 기록 된 모든 데이터를 읽을 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="1a16c760c71ffbcc7dbae1135b5e99738b98c9c4" translate="yes" xml:space="preserve">
          <source>This filter will compress all data before it is written to the database and uncompressed it on reading.</source>
          <target state="translated">이 필터는 데이터베이스에 기록되기 전에 모든 데이터를 압축하고 읽을 때 압축 해제합니다.</target>
        </trans-unit>
        <trans-unit id="ff45bc95d2be91a9f62c2d432c6510d29da26205" translate="yes" xml:space="preserve">
          <source>This final example contains both ordinary and pattern code expressions. It detects whether a binary string &lt;code&gt;1101010010001...&lt;/code&gt; has a Fibonacci spacing 0,1,1,2,3,5,... of the &lt;code&gt;1&lt;/code&gt; 's:</source>
          <target state="translated">이 마지막 예제에는 일반 및 패턴 코드 표현식이 모두 포함되어 있습니다. 이진 문자열 여부를 감지 &lt;code&gt;1101010010001...&lt;/code&gt; 피보나치가의 ..., 0,1,1,2,3,5 간격했다 &lt;code&gt;1&lt;/code&gt; 의 :</target>
        </trans-unit>
        <trans-unit id="4dfd467bd9194695ec17711b8f65393c531e176b" translate="yes" xml:space="preserve">
          <source>This finishes implementation of a primitive symbolic calculator in 50 lines of Perl code. Since the numeric values of subexpressions are not cached, the calculator is very slow.</source>
          <target state="translated">이것으로 50 줄의 Perl 코드로 원시 기호 계산기의 구현을 마칩니다. 하위 표현식의 숫자 값이 캐시되지 않으므로 계산기가 매우 느립니다.</target>
        </trans-unit>
        <trans-unit id="432b2214978806677872de825506327a25e6c8da" translate="yes" xml:space="preserve">
          <source>This first trivial example will call a Perl subroutine,</source>
          <target state="translated">이 첫 번째 간단한 예제는 Perl 서브 루틴을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="7a73aefe087a5a3cae31e7663f998536b4f2db63" translate="yes" xml:space="preserve">
          <source>This flag has 2 effects:</source>
          <target state="translated">이 플래그에는 2 가지 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="caa34b07e62e9949dde06d4f7ad8cedfd3b7de3f" translate="yes" xml:space="preserve">
          <source>This flag has an important effect on Perl's treatment of the string: if UTF-8 data is not properly distinguished, regular expressions, &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;&lt;/code&gt; and other string handling operations will have undesirable (wrong) results.</source>
          <target state="translated">이 플래그는 Perl의 문자열 처리에 중요한 영향을 미칩니다. UTF-8 데이터가 제대로 구별되지 않으면 정규식, &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;&lt;/code&gt; 및 기타 문자열 처리 작업에서 바람직하지 않은 (잘못된) 결과가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a176da4e70ce1acc6541f9df33982a6b757fc468" translate="yes" xml:space="preserve">
          <source>This flag is set to true if the API is tracing through subroutine calls.</source>
          <target state="translated">API가 서브 루틴 호출을 통해 추적하는 경우이 플래그가 true로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="201e9afdfb172b15efef161ffd6b8fd219c793ac" translate="yes" xml:space="preserve">
          <source>This flag is supported in Sun WorkShop Compilers 5.0 and onwards (now marketed under the name Forte) when used on Solaris 7 or later on UltraSparc systems.</source>
          <target state="translated">이 플래그는 UltraSparc 시스템의 Solaris 7 이상에서 사용될 때 Sun WorkShop Compilers 5.0 이상 (현재는 Forte라는 이름으로 판매 됨)에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="b160cdb384c536dc3f048d4a9c7c790cc3b24bae" translate="yes" xml:space="preserve">
          <source>This flag tells Perl to interpret the supplied string as a vector of integers, one for each character in the string. Perl applies the format to each integer in turn, then joins the resulting strings with a separator (a dot &lt;code&gt;.&lt;/code&gt; by default). This can be useful for displaying ordinal values of characters in arbitrary strings:</source>
          <target state="translated">이 플래그는 Perl에게 제공된 문자열을 문자열의 각 문자마다 하나씩 정수 벡터로 해석하도록 지시합니다. 펄은, 차례로 각각의 정수 포맷을 적용 세퍼레이터 얻어진 문자열을 조인 (도트 &lt;code&gt;.&lt;/code&gt; 기본값). 임의의 문자열로 문자의 서수 값을 표시하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f881a1e5bd78a37c63f807e7bc9fe5e3e92898af" translate="yes" xml:space="preserve">
          <source>This flag was removed in perl 5.18.0. &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; ' '&lt;/code&gt; is now special-cased solely in the parser. RXf_SPLIT is still #defined, so you can test for it. This is how it used to work:</source>
          <target state="translated">이 플래그는 perl 5.18.0에서 제거되었습니다. &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; ' '&lt;/code&gt; 은 (는) 이제 구문 분석기에서만 특수한 경우입니다. RXf_SPLIT은 여전히 ​​#defined이므로 테스트 할 수 있습니다. 이것이 작동하는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="d833b586ef20499906978002bb10914b6b58edd4" translate="yes" xml:space="preserve">
          <source>This flag was removed in perl 5.18.0. It is still #defined, so you can set it, but doing so will have no effect. This is how it used to work:</source>
          <target state="translated">이 플래그는 perl 5.18.0에서 제거되었습니다. 여전히 #defined이므로 설정할 수 있지만 아무런 효과가 없습니다. 이것이 작동하는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="dc95d1efdd1713c3cca7c0b3c4bdefdda1fde08a" translate="yes" xml:space="preserve">
          <source>This flag, if given, suppresses the URL when anchor text is given, so this example would be formatted as just &lt;code&gt;foo&lt;/code&gt; . This can produce less cluttered output in cases where the URLs are not particularly important.</source>
          <target state="translated">이 플래그가 지정되면 앵커 텍스트가 제공 될 때 URL을 억제하므로이 예제는 &lt;code&gt;foo&lt;/code&gt; 로 형식화됩니다 . 이것은 URL이 특별히 중요하지 않은 경우 덜 복잡한 출력을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0dbb07c9842c891feb553c44a3898bc7209b8ed" translate="yes" xml:space="preserve">
          <source>This flag, used in the length slot of hash entries and magic structures, specifies the structure contains an &lt;code&gt;SV*&lt;/code&gt; pointer where a &lt;code&gt;char*&lt;/code&gt; pointer is to be expected. (For information only--not to be used).</source>
          <target state="translated">해시 항목 및 매직 구조의 길이 슬롯에 사용되는이 플래그는 구조체 에 &lt;code&gt;char*&lt;/code&gt; 포인터가 필요한 &lt;code&gt;SV*&lt;/code&gt; 포인터가 포함되도록 지정합니다 . 정보 용으로 만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bbab49144d33f97cf4910c662167d2afe655dc3e" translate="yes" xml:space="preserve">
          <source>This forces the &lt;code&gt;AUTOLOAD&lt;/code&gt; for &lt;code&gt;SO_LINGER&lt;/code&gt; to take place before SO_LINGER is encountered later in &lt;code&gt;My&lt;/code&gt; package.</source>
          <target state="translated">이 힘은 &lt;code&gt;AUTOLOAD&lt;/code&gt; 에 대한 &lt;code&gt;SO_LINGER&lt;/code&gt; 는 SO_LINGER가 나중에 발생하기 전에 장소를 취할 &lt;code&gt;My&lt;/code&gt; 패키지.</target>
        </trans-unit>
        <trans-unit id="b15b4ab4a7170566f869487aafa326bf0ce9445d" translate="yes" xml:space="preserve">
          <source>This forces the short and the long members to be little-endian, and is just fine if you don't have too many struct members. But we could also use the byte-order modifier on a group and write the following:</source>
          <target state="translated">이렇게하면 짧은 멤버와 긴 멤버가 리틀 엔디안이되며 너무 많은 구조체 멤버가 없으면 괜찮습니다. 그러나 그룹에서 바이트 순서 수정자를 사용하여 다음을 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="40f05df3e2fa93dbc3244d6e8aa705438a4243e3" translate="yes" xml:space="preserve">
          <source>This form of the pragma allows essentially seamless handling of locales with Unicode. The collation order will be by Unicode code point order. It is strongly recommended that when you need to order and sort strings that you use the standard module &lt;a href=&quot;unicode/collate&quot;&gt;Unicode::Collate&lt;/a&gt; which gives much better results in many instances than you can get with the old-style locale handling.</source>
          <target state="translated">이 형식의 pragma는 기본적으로 유니 코드를 사용하여 로캘을 원활하게 처리 할 수 ​​있도록합니다. 데이터 정렬 순서는 유니 코드 코드 포인트 순서입니다. 표준 모듈 &lt;a href=&quot;unicode/collate&quot;&gt;Unicode :: Collate&lt;/a&gt; 를 사용하는 문자열을 주문하고 정렬해야 할 때 구식 로케일 처리에서 얻을 수있는 것보다 훨씬 더 나은 결과를 제공하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="cdc9f2e82b133c2773ec210a8571ca6b553d5115" translate="yes" xml:space="preserve">
          <source>This formality is needed when properties are not binary; that is, if they can take on more values than just &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;False&lt;/code&gt; . For example, the &lt;code&gt;Bidi_Class&lt;/code&gt; property (see &lt;a href=&quot;#Bidirectional-Character-Types&quot;&gt;Bidirectional Character Types&lt;/a&gt; below), can take on several different values, such as &lt;code&gt;Left&lt;/code&gt; , &lt;code&gt;Right&lt;/code&gt; , &lt;code&gt;Whitespace&lt;/code&gt; , and others. To match these, one needs to specify both the property name (&lt;code&gt;Bidi_Class&lt;/code&gt; ), AND the value being matched against (&lt;code&gt;Left&lt;/code&gt; , &lt;code&gt;Right&lt;/code&gt; ,</source>
          <target state="translated">이 형식은 속성이 이진이 아닌 경우에 필요합니다. 즉, &lt;code&gt;True&lt;/code&gt; 및 &lt;code&gt;False&lt;/code&gt; 보다 많은 값을 사용할 수있는 경우 입니다. 예를 들어 &lt;code&gt;Bidi_Class&lt;/code&gt; 속성 (아래의 &lt;a href=&quot;#Bidirectional-Character-Types&quot;&gt;양방향 문자 유형&lt;/a&gt; 참조)은 &lt;code&gt;Left&lt;/code&gt; , &lt;code&gt;Right&lt;/code&gt; , &lt;code&gt;Whitespace&lt;/code&gt; 등과 같은 여러 가지 다른 값을 사용할 수 있습니다 . 이를 일치 시키려면 속성 이름 ( &lt;code&gt;Bidi_Class&lt;/code&gt; )과 일치하는 값 ( &lt;code&gt;Left&lt;/code&gt; , &lt;code&gt;Right&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="e6b05c6c31caa81ea454aca24f6c1d1188903888" translate="yes" xml:space="preserve">
          <source>This formatting code is syntactically simple, but semantically complex. What it means is that each space in the printable content of this code signifies a non-breaking space.</source>
          <target state="translated">이 형식화 코드는 구문 상 단순하지만 의미 적으로 복잡합니다. 의미하는 것은이 코드의 인쇄 가능한 내용의 각 공간이 비 공백 공간을 의미한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d77c232922b63b050101d5932a616e0ed5728461" translate="yes" xml:space="preserve">
          <source>This free toolkit contains the same compiler and linker that ship with Visual C++ .NET 2003 Professional, but doesn't contain everything necessary to build Perl.</source>
          <target state="translated">이 무료 툴킷에는 Visual C ++ .NET 2003 Professional과 함께 제공되는 것과 동일한 컴파일러 및 링커가 포함되어 있지만 Perl을 빌드하는 데 필요한 모든 것이 포함되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c5a6423b0a65bc38b33d48cf33a85a24bf291a8" translate="yes" xml:space="preserve">
          <source>This free version of Visual C++ 2005 Professional contains the same compiler and linker that ship with the full version, but doesn't contain everything necessary to build Perl.</source>
          <target state="translated">이 무료 버전의 Visual C ++ 2005 Professional에는 정식 버전과 함께 제공되는 것과 동일한 컴파일러 및 링커가 포함되어 있지만 Perl을 빌드하는 데 필요한 모든 것이 포함되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eb31e64d6cc8d22ff5f69477b5a67be71c8242ad" translate="yes" xml:space="preserve">
          <source>This function (not exported) lets you reset the sequence numbers (note that they're numbered arbitrarily, their goal being to be human readable). Its purpose is mostly to support testing, i.e. to compare the concise output from two identical anonymous subroutines (but different instances). Without the reset, B::Concise, seeing that they're separate optrees, generates different sequence numbers in the output.</source>
          <target state="translated">이 기능 (내보내기 안 함)을 사용하면 시퀀스 번호를 재설정 할 수 있습니다 (순서 번호는 임의로 번호가 매겨지며 목표는 사람이 읽을 수 있어야 함). 그 목적은 주로 테스트를 지원하는 것입니다. 즉, 두 개의 동일한 익명 서브 루틴 (그러나 다른 인스턴스)의 간결한 결과를 비교하는 것입니다. 재설정하지 않고 B :: Concise는 별도의 optree임을보고 출력에서 ​​다른 시퀀스 번호를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="1f57c1588a54710c722f648f2f8000721f89bfc3" translate="yes" xml:space="preserve">
          <source>This function accepts any UV as input. To forbid or warn on non-Unicode code points, or those that may be problematic, see &lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;uvchr_to_utf8_flags&lt;/a&gt;.</source>
          <target state="translated">이 기능은 모든 UV를 입력으로 받아들입니다. 비 유니 코드 코드 포인트 또는 문제점이있는 코드 포인트를 금지하거나 경고하려면 &lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;uvchr_to_utf8_flags를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bcc1cbc95f41c6ca77822a286a66032b96a97b23" translate="yes" xml:space="preserve">
          <source>This function accepts two arguments, adds them, and prints their sum. Its return value is the numuber of characters it printed, but you probably didn't care about that. But &lt;code&gt;Memoize&lt;/code&gt; doesn't understand that. If you memoize this function, you will get the result you expect the first time you ask it to print the sum of 2 and 3, but subsequent calls will return 1 (the return value of &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;) without actually printing anything.</source>
          <target state="translated">이 함수는 두 개의 인수를 허용하고 추가 한 다음 합계를 인쇄합니다. 반환 값은 인쇄 된 문자의 숫자이지만, 신경 쓰지 않았을 것입니다. 그러나 &lt;code&gt;Memoize&lt;/code&gt; 는 그것을 이해하지 못합니다. 이 함수를 기억하면 처음으로 2와 3의 합계를 인쇄하도록 요청할 때 예상되는 결과를 얻을 수 있지만 후속 호출은 실제로 인쇄하지 않고 1 ( &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 반환 값)을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="cb8ff2980a7098008fca7a80ae815b328b64b56a" translate="yes" xml:space="preserve">
          <source>This function adheres to the POSIX syntax for command line options, with GNU extensions. In general, this means that options have long names instead of single letters, and are introduced with a double dash &quot;--&quot;. Support for bundling of command line options, as was the case with the more traditional single-letter approach, is provided but not enabled by default.</source>
          <target state="translated">이 함수는 GNU 확장을 사용하여 명령 행 옵션의 POSIX 구문을 준수합니다. 일반적으로 이것은 옵션이 단일 문자 대신 긴 이름을 가지며 이중 대시 &quot;-&quot;로 소개됨을 의미합니다. 보다 전통적인 단일 문자 접근 방식과 마찬가지로 명령 줄 옵션 번들 지원이 제공되지만 기본적으로 활성화되어 있지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="7b0b646247c6327383124f41d35ef99ac00aaf8b" translate="yes" xml:space="preserve">
          <source>This function assigns the prototype of the named core function to &lt;code&gt;sv&lt;/code&gt; , or to a new mortal SV if &lt;code&gt;sv&lt;/code&gt; is NULL. It returns the modified &lt;code&gt;sv&lt;/code&gt; , or NULL if the core function has no prototype. &lt;code&gt;code&lt;/code&gt; is a code as returned by &lt;code&gt;keyword()&lt;/code&gt; . It must not be equal to 0.</source>
          <target state="translated">이 함수는 명명 된 핵심 함수의 프로토 타입을 &lt;code&gt;sv&lt;/code&gt; 에 할당 하거나 &lt;code&gt;sv&lt;/code&gt; 가 NULL 인 경우 새로운 필적 SV에 할당합니다 . 수정 된 &lt;code&gt;sv&lt;/code&gt; 또는 코어 함수에 프로토 타입이없는 경우 NULL을 리턴합니다. &lt;code&gt;code&lt;/code&gt; 는 &lt;code&gt;keyword()&lt;/code&gt; 반환 한 코드 입니다. 0이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="14c8f38efd4e3476b651d12afb352ad397950bd5" translate="yes" xml:space="preserve">
          <source>This function behaves the same way under various pragma, such as in a locale, as &lt;a href=&quot;#lc&quot;&gt;lc&lt;/a&gt; does.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#lc&quot;&gt;lc&lt;/a&gt; 처럼 로케일과 같이 다양한 pragma에서 동일한 방식으로 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="8378e0b6c78c094cc27c1f818ab7aa1e8291a68d" translate="yes" xml:space="preserve">
          <source>This function behaves the same way under various pragma, such as in a locale, as &lt;a href=&quot;lc&quot;&gt;lc&lt;/a&gt; does.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;lc&quot;&gt;lc&lt;/a&gt; 처럼 로케일과 같이 다양한 pragma에서 동일한 방식으로 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="bdf27edd1f3ed7033638bb2d9262acb5626e2202" translate="yes" xml:space="preserve">
          <source>This function behaves the same way under various pragma, such as within &lt;code&gt;&quot;use feature 'unicode_strings&quot;&lt;/code&gt; , as &lt;a href=&quot;#lc&quot;&gt;lc&lt;/a&gt; does, with the single exception of &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; of LATIN CAPITAL LETTER SHARP S (U+1E9E) within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; . The foldcase of this character would normally be &lt;code&gt;&quot;ss&quot;&lt;/code&gt; , but as explained in the &lt;a href=&quot;#lc&quot;&gt;lc&lt;/a&gt; section, case changes that cross the 255/256 boundary are problematic under locales, and are hence prohibited. Therefore, this function under locale returns instead the string &lt;code&gt;&quot;\x{17F}\x{17F}&quot;&lt;/code&gt; , which is the LATIN SMALL LETTER LONG S. Since that character itself folds to &lt;code&gt;&quot;s&quot;&lt;/code&gt; , the string of two of them together should be equivalent to a single U+1E9E when foldcased.</source>
          <target state="translated">이 기능은 내 각종 프라그 하에서 동일한 방법으로 동작하는 &lt;code&gt;&quot;use feature 'unicode_strings&quot;&lt;/code&gt; 로, &lt;a href=&quot;#lc&quot;&gt;LC는&lt;/a&gt; 수행의 단일 제외 &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; 의 범위 내 라틴 대문자 SHARP S (U + 1E9E)의 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; . 이 문자의 접는 문자는 일반적으로 &lt;code&gt;&quot;ss&quot;&lt;/code&gt; 이지만 &lt;a href=&quot;#lc&quot;&gt;lc&lt;/a&gt; 섹션에 설명 된대로 255/256 경계를 넘는 경우 변경은 로캘에서 문제가되므로 금지됩니다. 따라서 로케일 아래의이 함수는 대신 &lt;code&gt;&quot;\x{17F}\x{17F}&quot;&lt;/code&gt; 문자열을 리턴합니다.이 문자는 라틴 문자 중 LONG S입니다. 해당 문자 자체는 &lt;code&gt;&quot;s&quot;&lt;/code&gt; 로 접 힙니다., 둘 중 하나의 문자열은 접을 때 단일 U + 1E9E와 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="ceceba872ecbef53671fa2bb946f4d1ad71c1d4b" translate="yes" xml:space="preserve">
          <source>This function behaves the same way under various pragma, such as within &lt;code&gt;&quot;use feature 'unicode_strings&quot;&lt;/code&gt; , as &lt;a href=&quot;lc&quot;&gt;lc&lt;/a&gt; does, with the single exception of &lt;code&gt;&lt;a href=&quot;fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; of LATIN CAPITAL LETTER SHARP S (U+1E9E) within the scope of &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; . The foldcase of this character would normally be &lt;code&gt;&quot;ss&quot;&lt;/code&gt; , but as explained in the &lt;a href=&quot;lc&quot;&gt;lc&lt;/a&gt; section, case changes that cross the 255/256 boundary are problematic under locales, and are hence prohibited. Therefore, this function under locale returns instead the string &lt;code&gt;&quot;\x{17F}\x{17F}&quot;&lt;/code&gt; , which is the LATIN SMALL LETTER LONG S. Since that character itself folds to &lt;code&gt;&quot;s&quot;&lt;/code&gt; , the string of two of them together should be equivalent to a single U+1E9E when foldcased.</source>
          <target state="translated">이 기능은 내 각종 프라그 하에서 동일한 방법으로 동작하는 &lt;code&gt;&quot;use feature 'unicode_strings&quot;&lt;/code&gt; 로, &lt;a href=&quot;lc&quot;&gt;LC는&lt;/a&gt; 수행의 단일 제외 &lt;code&gt;&lt;a href=&quot;fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; 의 범위 내 라틴 대문자 SHARP S (U + 1E9E)의 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; . 이 문자의 접는 문자는 일반적으로 &lt;code&gt;&quot;ss&quot;&lt;/code&gt; 이지만 &lt;a href=&quot;lc&quot;&gt;lc&lt;/a&gt; 섹션에 설명 된대로 255/256 경계를 넘는 경우 변경은 로캘에서 문제가되므로 금지됩니다. 따라서 로케일 아래의이 함수는 대신 &lt;code&gt;&quot;\x{17F}\x{17F}&quot;&lt;/code&gt; 문자열을 리턴합니다.이 문자는 라틴 문자 중 LONG S입니다. 해당 문자 자체는 &lt;code&gt;&quot;s&quot;&lt;/code&gt; 로 접 힙니다., 둘 중 하나의 문자열은 접을 때 단일 U + 1E9E와 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="8e622f55ce5e0f86a0059d75a25d61e3419fef9f" translate="yes" xml:space="preserve">
          <source>This function behaves the same way under various pragmata, such as in a locale, as &lt;a href=&quot;#lc&quot;&gt;lc&lt;/a&gt; does.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#lc&quot;&gt;lc&lt;/a&gt; 처럼 로케일에서와 같이 다양한 pragmata에서 동일한 방식으로 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="a06484c004f74f9c8853b354936ff3f59e84875a" translate="yes" xml:space="preserve">
          <source>This function behaves the same way under various pragmata, such as in a locale, as &lt;a href=&quot;lc&quot;&gt;lc&lt;/a&gt; does.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;lc&quot;&gt;lc&lt;/a&gt; 처럼 로케일에서와 같이 다양한 pragmata에서 동일한 방식으로 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="d07fce4b805ea45a197ef238496fb301033d2545" translate="yes" xml:space="preserve">
          <source>This function binds a variable to a package class that will provide the implementation for the variable. VARIABLE is the name of the variable to be enchanted. CLASSNAME is the name of a class implementing objects of correct type. Any additional arguments are passed to the appropriate constructor method of the class (meaning &lt;code&gt;TIESCALAR&lt;/code&gt; , &lt;code&gt;TIEHANDLE&lt;/code&gt; , &lt;code&gt;TIEARRAY&lt;/code&gt; , or &lt;code&gt;TIEHASH&lt;/code&gt; ). Typically these are arguments such as might be passed to the &lt;code&gt;dbm_open()&lt;/code&gt; function of C. The object returned by the constructor is also returned by the &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; function, which would be useful if you want to access other methods in CLASSNAME.</source>
          <target state="translated">이 함수는 변수를 구현할 패키지 클래스에 변수를 바인딩합니다. VARIABLE은 매혹 될 변수의 이름입니다. CLASSNAME은 올바른 유형의 객체를 구현하는 클래스의 이름입니다. 추가 인수는 클래스의 적절한 생성자 메서드 ( &lt;code&gt;TIESCALAR&lt;/code&gt; , &lt;code&gt;TIEHANDLE&lt;/code&gt; , &lt;code&gt;TIEARRAY&lt;/code&gt; 또는 &lt;code&gt;TIEHASH&lt;/code&gt; 의미 )에 전달됩니다. 일반적으로 이들은 C의 &lt;code&gt;dbm_open()&lt;/code&gt; 함수에 전달 될 수있는 것과 같은 인수 입니다. 생성자가 리턴 한 오브젝트도 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 함수에 의해 리턴되므로 CLASSNAME의 다른 메소드에 액세스하려는 경우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c3bc0e801ef7f17e4d79ee445885b2be27f25c2b" translate="yes" xml:space="preserve">
          <source>This function binds a variable to a package class that will provide the implementation for the variable. VARIABLE is the name of the variable to be enchanted. CLASSNAME is the name of a class implementing objects of correct type. Any additional arguments are passed to the appropriate constructor method of the class (meaning &lt;code&gt;TIESCALAR&lt;/code&gt; , &lt;code&gt;TIEHANDLE&lt;/code&gt; , &lt;code&gt;TIEARRAY&lt;/code&gt; , or &lt;code&gt;TIEHASH&lt;/code&gt; ). Typically these are arguments such as might be passed to the &lt;code&gt;dbm_open()&lt;/code&gt; function of C. The object returned by the constructor is also returned by the &lt;code&gt;&lt;a href=&quot;tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; function, which would be useful if you want to access other methods in CLASSNAME.</source>
          <target state="translated">이 함수는 변수를 구현할 패키지 클래스에 변수를 바인딩합니다. VARIABLE은 매혹 될 변수의 이름입니다. CLASSNAME은 올바른 유형의 객체를 구현하는 클래스의 이름입니다. 추가 인수는 클래스의 적절한 생성자 메서드 ( &lt;code&gt;TIESCALAR&lt;/code&gt; , &lt;code&gt;TIEHANDLE&lt;/code&gt; , &lt;code&gt;TIEARRAY&lt;/code&gt; 또는 &lt;code&gt;TIEHASH&lt;/code&gt; 의미 )에 전달됩니다. 일반적으로 이들은 C의 &lt;code&gt;dbm_open()&lt;/code&gt; 함수에 전달 될 수있는 것과 같은 인수 입니다. 생성자가 리턴 한 오브젝트도 &lt;code&gt;&lt;a href=&quot;tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 함수에 의해 리턴되므로 CLASSNAME의 다른 메소드에 액세스하려는 경우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5132f8607896a5505c904bfd8891d2794b3208e8" translate="yes" xml:space="preserve">
          <source>This function can take a hash of options:</source>
          <target state="translated">이 함수는 해시 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0cccb23235ebb22439bd8ff2e5a998bf5aa962e" translate="yes" xml:space="preserve">
          <source>This function cannot be used on an entire array or hash to find out how many elements these have. For that, use &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt; @array&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt; &lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;
%hash&lt;/code&gt; , respectively.</source>
          <target state="translated">이 함수는 전체 배열이나 해시에서 사용되어 몇 개의 요소가 있는지 알아낼 수 없습니다. 이를 위해 각각 &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt; @array&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt; &lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; %hash&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0ba6657c5fa298f8f6fa2444117335de3f819a9a" translate="yes" xml:space="preserve">
          <source>This function cannot be used on an entire array or hash to find out how many elements these have. For that, use &lt;code&gt;&lt;a href=&quot;scalar&quot;&gt;scalar&lt;/a&gt; @array&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;scalar&quot;&gt;scalar&lt;/a&gt; &lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;
%hash&lt;/code&gt; , respectively.</source>
          <target state="translated">이 함수는 전체 배열이나 해시에서 사용되어 몇 개의 요소가 있는지 알아낼 수 없습니다. 이를 위해 각각 &lt;code&gt;&lt;a href=&quot;scalar&quot;&gt;scalar&lt;/a&gt; @array&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;scalar&quot;&gt;scalar&lt;/a&gt; &lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt; %hash&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="118dd1a89ee26e341a24a616a4886c6624f3f97c" translate="yes" xml:space="preserve">
          <source>This function causes an immediate core dump. See also the &lt;b&gt;-u&lt;/b&gt; command-line switch in &lt;a href=&quot;../perlrun&quot;&gt;perlrun&lt;/a&gt;, which does the same thing. Primarily this is so that you can use the &lt;b&gt;undump&lt;/b&gt; program (not supplied) to turn your core dump into an executable binary after having initialized all your variables at the beginning of the program. When the new binary is executed it will begin by executing a &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; (with all the restrictions that &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; suffers). Think of it as a goto with an intervening core dump and reincarnation. If &lt;code&gt;LABEL&lt;/code&gt; is omitted, restarts the program from the top. The &lt;code&gt;&lt;a href=&quot;dump&quot;&gt;dump&lt;/a&gt; EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a name to be computed at run time, being otherwise identical to &lt;code&gt;&lt;a href=&quot;dump&quot;&gt;dump&lt;/a&gt; LABEL&lt;/code&gt; .</source>
          <target state="translated">이 기능은 즉시 코어 덤프를 발생시킵니다. &lt;a href=&quot;../perlrun&quot;&gt;perlrun&lt;/a&gt; 의 &lt;b&gt;-u&lt;/b&gt; 명령 줄 스위치 도 참조하십시오 . 기본적으로 이것은 프로그램 시작시 모든 변수를 초기화 한 후 &lt;b&gt;undump&lt;/b&gt; 프로그램 (제공되지 않음)을 사용하여 코어 덤프를 실행 가능한 이진 파일로 전환 할 수 있습니다. 새로운 바이너리가 실행될 때 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; LABEL ( &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 가 겪는 모든 제한 사항)을 실행하여 시작합니다 . 코어 덤프와 환생의 개입으로 생각하십시오. 경우 &lt;code&gt;LABEL&lt;/code&gt; 이 생략 상단에서 프로그램을 다시 시작합니다. &lt;code&gt;&lt;a href=&quot;dump&quot;&gt;dump&lt;/a&gt; EXPR&lt;/code&gt; EXPR&lt;b&gt;&lt;/b&gt;Perl 5.18.0부터 사용 가능한 form은 런타임시 이름을 계산할 수있게하며 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;dump&quot;&gt;dump&lt;/a&gt; LABEL&lt;/code&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="2644b0d090106df2bac79cc1278fe935e270aa17" translate="yes" xml:space="preserve">
          <source>This function causes an immediate core dump. See also the &lt;b&gt;-u&lt;/b&gt; command-line switch in &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;, which does the same thing. Primarily this is so that you can use the &lt;b&gt;undump&lt;/b&gt; program (not supplied) to turn your core dump into an executable binary after having initialized all your variables at the beginning of the program. When the new binary is executed it will begin by executing a &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; (with all the restrictions that &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; suffers). Think of it as a goto with an intervening core dump and reincarnation. If &lt;code&gt;LABEL&lt;/code&gt; is omitted, restarts the program from the top. The &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt; EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a name to be computed at run time, being otherwise identical to &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt; LABEL&lt;/code&gt; .</source>
          <target state="translated">이 기능은 즉시 코어 덤프를 발생시킵니다. &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; 의 &lt;b&gt;-u&lt;/b&gt; 명령 줄 스위치 도 참조하십시오 . 기본적으로 이것은 프로그램 시작시 모든 변수를 초기화 한 후 &lt;b&gt;undump&lt;/b&gt; 프로그램 (제공되지 않음)을 사용하여 코어 덤프를 실행 가능한 이진 파일로 전환 할 수 있습니다. 새로운 바이너리가 실행될 때 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; LABEL ( &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 가 겪는 모든 제한 사항)을 실행하여 시작합니다 . 코어 덤프와 환생의 개입으로 생각하십시오. 경우 &lt;code&gt;LABEL&lt;/code&gt; 이 생략 상단에서 프로그램을 다시 시작합니다. &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt; EXPR&lt;/code&gt; EXPR&lt;b&gt;&lt;/b&gt;Perl 5.18.0부터 사용 가능한 form은 런타임시 이름을 계산할 수있게하며 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt; LABEL&lt;/code&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="8952b46dfeb17de53351ddf4d21ae7d55c07b2d8" translate="yes" xml:space="preserve">
          <source>This function combines &lt;code&gt;perl_inc()&lt;/code&gt; , &lt;code&gt;ccflags()&lt;/code&gt; and &lt;code&gt;ccdlflags()&lt;/code&gt; into one.</source>
          <target state="translated">이 함수는 &lt;code&gt;perl_inc()&lt;/code&gt; , &lt;code&gt;ccflags()&lt;/code&gt; 및 &lt;code&gt;ccdlflags()&lt;/code&gt; 를 하나로 결합합니다.</target>
        </trans-unit>
        <trans-unit id="3221a438c3aad48b5c48a805755ad197928b0f99" translate="yes" xml:space="preserve">
          <source>This function detects things that can't be modified, such as &lt;code&gt;$x+1&lt;/code&gt; , and generates errors for them. For example, &lt;code&gt;$x+1 = 2&lt;/code&gt; would cause it to be called with an op of type OP_ADD and a &lt;code&gt;type&lt;/code&gt; argument of OP_SASSIGN.</source>
          <target state="translated">이 함수는 &lt;code&gt;$x+1&lt;/code&gt; 과 같이 수정할 수없는 것을 감지 하여 오류를 생성합니다. 예를 들어 &lt;code&gt;$x+1 = 2&lt;/code&gt; 는 OP_ADD 유형의 op와 OP_SASSIGN의 &lt;code&gt;type&lt;/code&gt; 인수로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="50025265ce70752e52bdd20aeddabe5be1d58395" translate="yes" xml:space="preserve">
          <source>This function does not use a typemap. Instead, we declare it as accepting one SV* (scalar) parameter, and returning an SV* value, and we take care of populating these scalars within the code. Because we are only returning one value, we don't need a &lt;code&gt;PPCODE:&lt;/code&gt; directive - instead, we use &lt;code&gt;CODE:&lt;/code&gt; and &lt;code&gt;OUTPUT:&lt;/code&gt; directives.</source>
          <target state="translated">이 함수는 타입 맵을 사용하지 않습니다. 대신, 하나의 SV * (스칼라) 매개 변수를 승인하고 SV * 값을 리턴하는 것으로 선언하고 코드 내에서 이러한 스칼라를 채우는 것을 처리합니다. 하나의 값만 반환하므로 &lt;code&gt;PPCODE:&lt;/code&gt; 지시문이 필요하지 않습니다 . 대신 &lt;code&gt;CODE:&lt;/code&gt; 및 &lt;code&gt;OUTPUT:&lt;/code&gt; 지시문을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6180191f0bc721d501520e66b164a9ef20a22d11" translate="yes" xml:space="preserve">
          <source>This function enables/disables error popups associated with hardware errors (Disk not ready etc.) and software exceptions.</source>
          <target state="translated">이 기능은 하드웨어 오류 (디스크 준비 안 됨 등) 및 소프트웨어 예외와 관련된 오류 팝업을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="467712b5ef786ba52bfac5af598e2fd6afe41fb8" translate="yes" xml:space="preserve">
          <source>This function finalizes the optree. Should be called directly after the complete optree is built. It does some additional checking which can't be done in the normal ck_xxx functions and makes the tree thread-safe.</source>
          <target state="translated">이 함수는 optree를 마무리합니다. 완전한 optree가 빌드 된 직후에 호출되어야합니다. 일반적인 ck_xxx 함수에서 수행 할 수없는 추가 검사를 수행하고 트리를 스레드로부터 안전하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="529aa240cc0116c0500e7c8811796b1b622bb45e" translate="yes" xml:space="preserve">
          <source>This function has a &lt;code&gt;Perl_&lt;/code&gt; prefix; i.e. it is defined as &lt;code&gt;Perl_av_fetch&lt;/code&gt; .</source>
          <target state="translated">이 함수에는 &lt;code&gt;Perl_&lt;/code&gt; 접두사가 있습니다. 즉, &lt;code&gt;Perl_av_fetch&lt;/code&gt; 로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="de86eb1f3f7a618ab133b8ece7ae081d7566d329" translate="yes" xml:space="preserve">
          <source>This function has documentation using the &lt;code&gt;apidoc&lt;/code&gt; feature which we'll look at in a second. Some functions have 'd' but not 'A'; docs are good.</source>
          <target state="translated">이 함수에는 &lt;code&gt;apidoc&lt;/code&gt; 기능을 사용하는 문서가 있습니다 . 일부 함수에는 'd'가 있지만 'A'는 없습니다. 문서가 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0ade2373bef2bb276b87f95d3a360655ec661c9a" translate="yes" xml:space="preserve">
          <source>This function invalidates isa caches on the old stash, on all subpackages nested inside it, and on the subclasses of all those, including non-existent packages that have corresponding entries in &lt;code&gt;stash&lt;/code&gt; .</source>
          <target state="translated">이 함수는 기존 숨김, 중첩 된 모든 하위 패키지 및 &lt;code&gt;stash&lt;/code&gt; 에 해당 항목이있는 존재하지 않는 패키지를 포함하여 모든 하위 패키지의 isa 캐시를 무효화합니다 .</target>
        </trans-unit>
        <trans-unit id="c21846dd58e70501c7ae85693ffbb155deb7ba64" translate="yes" xml:space="preserve">
          <source>This function is a deprecated synonym for &lt;a href=&quot;#uvoffuni_to_utf8_flags&quot;&gt;uvoffuni_to_utf8_flags&lt;/a&gt;, which itself, while not deprecated, should be used only in isolated circumstances. These functions were useful for code that wanted to handle both EBCDIC and ASCII platforms with Unicode properties, but starting in Perl v5.20, the distinctions between the platforms have mostly been made invisible to most code, so this function is quite unlikely to be what you want.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#uvoffuni_to_utf8_flags&quot;&gt;uvoffuni_to_utf8_flags&lt;/a&gt; 의 사용되지 않는 동의어이며, 사용되지는 않지만 격리 된 환경에서만 사용해야합니다. 이러한 함수는 유니 코드 속성을 사용하여 EBCDIC 및 ASCII 플랫폼을 모두 처리하려는 코드에 유용했지만 Perl v5.20부터는 플랫폼 간의 차이점이 대부분의 코드에서 보이지 않게되었으므로이 기능은 당신이 원합니다.</target>
        </trans-unit>
        <trans-unit id="2913484e77586e8d68e21770c7b4063c930b583c" translate="yes" xml:space="preserve">
          <source>This function is a good candidate for memoization. If you memoize the `fib' function above, it will compute fib(14) exactly once, the first time it needs to, and then save the result in a table. Then if you ask for fib(14) again, it gives you the result out of the table. While computing fib(14), instead of computing fib(12) twice, it does it once; the second time it needs the value it gets it from the table. It doesn't compute fib(11) four times; it computes it once, getting it from the table the next three times. Instead of making 1,200 recursive calls to `fib', it makes 15. This makes the function about 150 times faster.</source>
          <target state="translated">이 기능은 메모에 적합합니다. 위의`fib '함수를 기억하면 처음으로 fib (14)를 정확히 한 번만 계산 한 다음 결과를 테이블에 저장합니다. 그런 다음 fib (14)를 다시 요청하면 결과가 표에서 나오게됩니다. fib (12)를 두 번 계산하는 대신 fib (14)를 계산하는 동안 한 번 수행합니다. 두 번째로 테이블에서 가져 오는 값이 필요합니다. fib (11)을 네 번 계산하지 않습니다. 한 번 계산하여 다음 세 번 테이블에서 가져옵니다. `fib '에 대해 1,200 회 재귀 호출을하는 대신 15를 만듭니다. 이는 약 150 배 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="8abb1909fce4e7f9c7aa7be2b9644d4d00810b89" translate="yes" xml:space="preserve">
          <source>This function is a part of the public API. All such functions should also have 'd', very few do not.</source>
          <target state="translated">이 함수는 공개 API의 일부입니다. 그러한 모든 기능은 또한 'd'를 가져야하며, 그 중 일부는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="752724e6180b12da8e6cd0e0935f30eed783f92d" translate="yes" xml:space="preserve">
          <source>This function is a stand-in replacement for &lt;a href=&quot;../../scalar/util#%24addr-%3d-refaddr(-%24ref-)&quot;&gt;Scalar::Util::refaddr&lt;/a&gt;, that is, it returns the reference address of its argument as a numeric value. The only difference is that &lt;code&gt;refaddr()&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when given a non-reference while &lt;code&gt;id()&lt;/code&gt; returns its argument unchanged.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;../../scalar/util#%24addr-%3d-refaddr(-%24ref-)&quot;&gt;Scalar :: Util :: refaddr&lt;/a&gt; 의 독립형 대체입니다 . 즉, 인수의 참조 주소를 숫자 값으로 리턴합니다. 유일한 차이점은이다 &lt;code&gt;refaddr()&lt;/code&gt; 복귀 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 동안 비 기준 주어지면 &lt;code&gt;id()&lt;/code&gt; 인수가 그대로 리턴한다.</target>
        </trans-unit>
        <trans-unit id="8a0d9ec972199a89df14d600a89c7347e29e2743" translate="yes" xml:space="preserve">
          <source>This function is deprecated due to the possibility that malformed input could cause reading beyond the end of the input buffer. Use &lt;a href=&quot;#isUTF8_CHAR&quot;&gt;isUTF8_CHAR&lt;/a&gt; instead.</source>
          <target state="translated">이 기능은 잘못된 입력이 입력 버퍼의 끝을 넘어 판독을 야기 할 수 있기 때문에 사용되지 않습니다. 대신 &lt;a href=&quot;#isUTF8_CHAR&quot;&gt;isUTF8_CHAR&lt;/a&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="28ce789b612136fafacb486bd5bb357e8d0e4268" translate="yes" xml:space="preserve">
          <source>This function is disabled if the global variable $KEEP_ALL is true and an unlink on open file is supported. If the unlink is to be deferred to the END block, the file is still registered for removal.</source>
          <target state="translated">글로벌 변수 $ KEEP_ALL이 true이고 열린 파일에서 링크 해제가 지원되는 경우이 기능은 사용 불가능합니다. 링크가 END 블록으로 지연되는 경우 파일은 여전히 ​​제거를 위해 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="8ff75df81e21a36cc9176732a80e9ccf2b68ffdf" translate="yes" xml:space="preserve">
          <source>This function is disabled if the global variable $KEEP_ALL is true.</source>
          <target state="translated">글로벌 변수 $ KEEP_ALL이 true 인 경우이 기능을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1b3c45f3e25d0a4f2eec52ed9b0f4d623aa7d540" translate="yes" xml:space="preserve">
          <source>This function is expected to be used to signal to perl that this SV is about to be written to, and any extra book-keeping needs to be taken care of. Hence, it croaks on read-only values.</source>
          <target state="translated">이 기능은이 SV가 작성 될 예정임을 perl에 알리는 데 사용될 것으로 예상되며 추가 부기 관리가 필요합니다. 따라서 읽기 전용 값을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="046e9e5d6bd1398867e1dee81f27fefb4c212d31" translate="yes" xml:space="preserve">
          <source>This function is expensive in time and memory.</source>
          <target state="translated">이 기능은 시간과 메모리가 비쌉니다.</target>
        </trans-unit>
        <trans-unit id="0e275fe5def47eb8b770fec4e729d202771a5b5a" translate="yes" xml:space="preserve">
          <source>This function is explicitly exported.</source>
          <target state="translated">이 기능은 명시 적으로 내보내집니다.</target>
        </trans-unit>
        <trans-unit id="baae2ca89cb1960ad8e6c66b2b2c6b874d4b3266" translate="yes" xml:space="preserve">
          <source>This function is like &lt;a href=&quot;#eval&quot;&gt;eval&lt;/a&gt; with a string argument, except it always parses its argument, or &lt;code&gt;$_&lt;/code&gt; if EXPR is omitted, as a string of bytes. A string containing characters whose ordinal value exceeds 255 results in an error. Source filters activated within the evaluated code apply to the code itself.</source>
          <target state="translated">이 함수는 항상 인수를 구문 분석하거나 EXPR이 생략 된 경우 &lt;code&gt;$_&lt;/code&gt; 를 바이트 문자열로 해석한다는 점을 제외하고는 문자열 인수가있는 &lt;a href=&quot;#eval&quot;&gt;평가&lt;/a&gt; 와 같습니다 . 서 수가 255를 초과하는 문자가 포함 된 문자열은 오류를 발생시킵니다. 평가 된 코드 내에서 활성화 된 소스 필터는 코드 자체에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="4699e383ec11b8d15b996f85aefd9a02e9b5bdaf" translate="yes" xml:space="preserve">
          <source>This function is like &lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; with a string argument, except it always parses its argument, or &lt;code&gt;$_&lt;/code&gt; if EXPR is omitted, as a string of bytes. A string containing characters whose ordinal value exceeds 255 results in an error. Source filters activated within the evaluated code apply to the code itself.</source>
          <target state="translated">이 함수는 항상 인수를 구문 분석하거나 EXPR이 생략 된 경우 &lt;code&gt;$_&lt;/code&gt; 를 바이트 문자열로 해석한다는 점을 제외하고는 문자열 인수가있는 &lt;a href=&quot;eval&quot;&gt;평가&lt;/a&gt; 와 같습니다 . 서 수가 255를 초과하는 문자가 포함 된 문자열은 오류를 발생시킵니다. 평가 된 코드 내에서 활성화 된 소스 필터는 코드 자체에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="caeb1cd5a4880a4de69d7c039879029a5a9067db" translate="yes" xml:space="preserve">
          <source>This function is like them, but the input is a strict Unicode (as opposed to native) code point. Only in very rare circumstances should code not be using the native code point.</source>
          <target state="translated">이 함수는 그와 비슷하지만 입력은 엄격한 유니 코드 (기본과 반대) 코드 포인트입니다. 매우 드문 상황에서만 코드가 기본 코드 포인트를 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="3a6987023b3feeacf2b107686c8afb184bf9785b" translate="yes" xml:space="preserve">
          <source>This function is most useful in the idiom</source>
          <target state="translated">이 기능은 관용구에서 가장 유용합니다</target>
        </trans-unit>
        <trans-unit id="2ba0cefbbfd398911c6a8851cb85930170c481ec" translate="yes" xml:space="preserve">
          <source>This function is not exported by default, so you'll have to ask for it via:</source>
          <target state="translated">이 기능은 기본적으로 내보내지지 않으므로 다음을 통해 요청해야합니다.</target>
        </trans-unit>
        <trans-unit id="3f6a1a85d5fc88c0e9364254a35bb1ced4455307" translate="yes" xml:space="preserve">
          <source>This function is now largely obsolete, mostly because it's very hard to convert a core file into an executable. That's why you should now invoke it as &lt;code&gt;CORE::dump()&lt;/code&gt; , if you don't want to be warned against a possible typo.</source>
          <target state="translated">이 기능은 코어 파일을 실행 파일로 변환하기가 매우 어렵 기 때문에 이제는 거의 사용되지 않습니다. 가능한 오타에 대해 경고하지 않으려면 이제 &lt;code&gt;CORE::dump()&lt;/code&gt; 로 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5839521ffabe37be44c9b142d6f0e122410904e4" translate="yes" xml:space="preserve">
          <source>This function is only available under the &lt;code&gt;&lt;a href=&quot;evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; feature, a &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; (or higher) declaration, or with a &lt;code&gt;CORE::&lt;/code&gt; prefix. See &lt;a href=&quot;../feature&quot;&gt;feature&lt;/a&gt; for more information.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; 기능, &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; 이상의 &lt;a href=&quot;use&quot;&gt;사용&lt;/a&gt; 선언 또는 &lt;code&gt;CORE::&lt;/code&gt; 접두사 에서만 사용할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;../feature&quot;&gt;기능&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2ce5a3cfad478a3c3fe7a7e04e3ec1df865cc5b4" translate="yes" xml:space="preserve">
          <source>This function is only available under the &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; feature, a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; (or higher) declaration, or with a &lt;code&gt;CORE::&lt;/code&gt; prefix. See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; for more information.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; 기능, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; 이상의 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 선언 또는 &lt;code&gt;CORE::&lt;/code&gt; 접두사 에서만 사용할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;feature&quot;&gt;기능&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e43d0a24f1f599b09639816ea4bcc88309ead9ce" translate="yes" xml:space="preserve">
          <source>This function is only used by sv_true() and friends, and only if the latter's argument is neither SvPOK, SvIOK nor SvNOK. If the flags contain SV_GMAGIC, then it does an mg_get() first.</source>
          <target state="translated">이 함수는 sv_true () 및 friends에서만 사용되며 후자의 인수가 SvPOK, SvIOK 또는 SvNOK가 아닌 경우에만 사용됩니다. 플래그에 SV_GMAGIC이 포함되어 있으면 먼저 mg_get ()을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="0b5776fa05d807fc6265ae0f0ad2309322f8e80a" translate="yes" xml:space="preserve">
          <source>This function is part of the experimental development API, and may change or disappear without notice.</source>
          <target state="translated">이 기능은 실험 개발 API의 일부이며 예고없이 변경되거나 사라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df4b28e7c0c75c36faca5ca1d70518986b2de4c0" translate="yes" xml:space="preserve">
          <source>This function is provided for compatibility with the Unix shell command &lt;code&gt;basename(1)&lt;/code&gt; . It does &lt;b&gt;NOT&lt;/b&gt; always return the file name portion of a path as you might expect. To be safe, if you want the file name portion of a path use &lt;code&gt;fileparse()&lt;/code&gt; .</source>
          <target state="translated">이 함수는 Unix 쉘 명령 &lt;code&gt;basename(1)&lt;/code&gt; 과의 호환성을 위해 제공됩니다 . 예상대로 경로의 파일 이름 부분을 항상 반환 하지는 &lt;b&gt;않습니다&lt;/b&gt; . 안전을 위해 경로의 파일 이름 부분을 원하면 &lt;code&gt;fileparse()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="deb4ec1fbe8c66b8f2020144f5701828bedcfe14" translate="yes" xml:space="preserve">
          <source>This function is provided for compatibility with the Unix shell command &lt;code&gt;dirname(1)&lt;/code&gt; and has inherited some of its quirks. In spite of its name it does &lt;b&gt;NOT&lt;/b&gt; always return the directory name as you might expect. To be safe, if you want the directory name of a path use &lt;code&gt;fileparse()&lt;/code&gt; .</source>
          <target state="translated">이 함수는 Unix 쉘 명령 &lt;code&gt;dirname(1)&lt;/code&gt; 과의 호환성을 위해 제공되며 일부 단점을 물려 받았습니다. 이름에도 불구하고 항상 예상대로 디렉토리 이름을 반환 하지는 &lt;b&gt;않습니다&lt;/b&gt; . 안전을 위해 경로의 디렉토리 이름을 원하면 &lt;code&gt;fileparse()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02937778415d96c12ca24363d4faada4d7809ec7" translate="yes" xml:space="preserve">
          <source>This function is slightly neater and more convenient than the otherwise-equivalent code</source>
          <target state="translated">이 함수는 다른 코드보다 약간 깔끔하고 편리합니다.</target>
        </trans-unit>
        <trans-unit id="253b045013c433366a31c2cad960bf3283fd7d39" translate="yes" xml:space="preserve">
          <source>This function is the implementation of the &lt;a href=&quot;#LINKLIST&quot;&gt;LINKLIST&lt;/a&gt; macro. It should not be called directly.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#LINKLIST&quot;&gt;LINKLIST&lt;/a&gt; 매크로 의 구현입니다 . 직접 호출해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="2a063dac587bf0c596a82a9c061b8f58b0075f3f" translate="yes" xml:space="preserve">
          <source>This function is the reason for &lt;code&gt;Test&lt;/code&gt; 's existence. It's the basic function that handles printing &quot;&lt;code&gt;ok&lt;/code&gt; &quot; or &quot;&lt;code&gt;not ok&lt;/code&gt; &quot;, along with the current test number. (That's what &lt;code&gt;Test::Harness&lt;/code&gt; wants to see.)</source>
          <target state="translated">이 함수는 &lt;code&gt;Test&lt;/code&gt; 가 존재 하는 이유입니다 . 현재 테스트 번호와 함께 &quot; &lt;code&gt;ok&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;not ok&lt;/code&gt; &quot; 인쇄를 처리하는 기본 기능입니다 . (이것이 &lt;code&gt;Test::Harness&lt;/code&gt; 가보고 싶어하는 것입니다.)</target>
        </trans-unit>
        <trans-unit id="077b1426e82943be7223b00766173ba5b1d4acf4" translate="yes" xml:space="preserve">
          <source>This function is used to create an in-memory gzip file with the minimum possible gzip header (exactly 10 bytes).</source>
          <target state="translated">이 함수는 가능한 최소 gzip 헤더 (정확히 10 바이트)를 사용하여 메모리 내 gzip 파일을 작성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4e0a2ccd31b9bdd8066d5b9d22011351f1760ec7" translate="yes" xml:space="preserve">
          <source>This function is used to uncompress an in-memory gzip file.</source>
          <target state="translated">이 기능은 메모리 내 gzip 파일을 압축 해제하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a3560ca8857460f655d69dd6b49d96a0f7f4a536" translate="yes" xml:space="preserve">
          <source>This function is useful for producing a directory tree identical to the intended distribution tree.</source>
          <target state="translated">이 기능은 의도 한 배포 트리와 동일한 디렉토리 트리를 생성하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7f19b2798743cc5e3f86e0124b7ddc89a4b3ff92" translate="yes" xml:space="preserve">
          <source>This function is very slow. Why? To compute fib(14), it first wants to compute fib(13) and fib(12), and add the results. But to compute fib(13), it first has to compute fib(12) and fib(11), and then it comes back and computes fib(12) all over again even though the answer is the same. And both of the times that it wants to compute fib(12), it has to compute fib(11) from scratch, and then it has to do it again each time it wants to compute fib(13). This function does so much recomputing of old results that it takes a really long time to run---fib(14) makes 1,200 extra recursive calls to itself, to compute and recompute things that it already computed.</source>
          <target state="translated">이 기능은 매우 느립니다. 왜? fib (14)를 계산하려면 먼저 fib (13) 및 fib (12)를 계산하고 결과를 추가하려고합니다. 그러나 fib (13)을 계산하려면 먼저 fib (12)와 fib (11)을 계산 한 다음 답이 같더라도 다시 돌아와서 fib (12)를 다시 계산합니다. 그리고 fib (12)를 계산하고자하는 두 시간 모두, 처음부터 fib (11)을 계산해야하며, fib (13)을 계산할 때마다 다시 수행해야합니다. 이 함수는 오래된 결과를 너무 많이 재 계산하므로 실행하는 데 시간이 오래 걸립니다 .-- fib (14)는 이미 계산 한 것을 계산하고 재 계산하기 위해 1,200 개의 재귀 호출을 자체적으로 수행합니다.</target>
        </trans-unit>
        <trans-unit id="658ccab5957d9fcb5acf02b75800173326f8ac18" translate="yes" xml:space="preserve">
          <source>This function is visible to extensions included in the Perl core.</source>
          <target state="translated">이 기능은 Perl 코어에 포함 된 확장에서 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bced169d4ae2df2074f45ec48dfe76cbdcf9e8fb" translate="yes" xml:space="preserve">
          <source>This function isn't exported out of the Perl core.</source>
          <target state="translated">이 함수는 Perl 코어에서 내보내지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="44b0e9309a1e4a7388d6c16c7d9a1708e320c5c8" translate="yes" xml:space="preserve">
          <source>This function makes use of the fact that the presence of tainted data anywhere within an expression renders the entire expression tainted. It would be inefficient for every operator to test every argument for taintedness. Instead, the slightly more efficient and conservative approach is used that if any tainted value has been accessed within the same expression, the whole expression is considered tainted.</source>
          <target state="translated">이 함수는 표현식 내에서 오염 된 데이터가 존재하면 전체 표현식이 오염된다는 사실을 이용합니다. 모든 조작자가 오염에 대한 모든 주장을 테스트하는 것은 비효율적입니다. 대신, 동일한 표현 내에서 오염 된 값에 액세스 한 경우 전체 표현이 오염 된 것으로 간주되는 약간 더 효율적이고 보수적 인 접근 방식이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2fa84a514560c863f7089eb7ca24d6683d764569" translate="yes" xml:space="preserve">
          <source>This function may redirect error popups associated with hardware errors (Disk not ready etc.) and software exceptions to the file POPUPLOG.OS2 at the root directory of the specified drive. Overrides OS2::Error() specified by individual programs. Given argument undef will disable redirection.</source>
          <target state="translated">이 기능은 하드웨어 오류 (디스크 준비 안 됨 등) 및 소프트웨어 예외와 관련된 오류 팝업을 지정된 드라이브의 루트 디렉토리에있는 POPUPLOG.OS2 파일로 리디렉션 할 수 있습니다. 개별 프로그램에 의해 지정된 OS2 :: Error ()를 대체합니다. 주어진 인수 undef는 리디렉션을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="b9c43d91069a9273330810504102211439262d63" translate="yes" xml:space="preserve">
          <source>This function never returns; &lt;code&gt;croak&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; and friends.</source>
          <target state="translated">이 함수는 절대 반환하지 않습니다. &lt;code&gt;croak&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; 및 친구들.</target>
        </trans-unit>
        <trans-unit id="50a0a533f960128e3a086dc96db9b1aafa52d5a7" translate="yes" xml:space="preserve">
          <source>This function normally returns a list. Suppose you memoize it and merge the caches:</source>
          <target state="translated">이 함수는 일반적으로 목록을 반환합니다. 이를 메모하고 캐시를 병합한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="3b85997713311e08de3e59dac5499d89e1dccd03" translate="yes" xml:space="preserve">
          <source>This function only exists if Perl has been compiled to use ithreads.</source>
          <target state="translated">이 함수는 Perl이 ithread를 사용하도록 컴파일 된 경우에만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="61fee0518a7d8b237d34517bc719658c6b719ec4" translate="yes" xml:space="preserve">
          <source>This function only operates on officially approved (not provisional) named sequences.</source>
          <target state="translated">이 기능은 공식적으로 승인 된 (임시가 아닌) 명명 된 시퀀스에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e59aa3c08f27111519b6ecd9388b33347100905a" translate="yes" xml:space="preserve">
          <source>This function only works on &lt;code&gt;new()&lt;/code&gt; and it assumes &lt;code&gt;new()&lt;/code&gt; will return just a single object which isa &lt;code&gt;$class&lt;/code&gt; .</source>
          <target state="translated">이 기능은 작동 &lt;code&gt;new()&lt;/code&gt; 그리고 가정 &lt;code&gt;new()&lt;/code&gt; 사 단 하나의 객체 반환 &lt;code&gt;$class&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2eb7d023997a73d6817733ba90181d612a2b1cdc" translate="yes" xml:space="preserve">
          <source>This function opens either the</source>
          <target state="translated">이 기능은</target>
        </trans-unit>
        <trans-unit id="441aca7229169cbbddd3f285c046a735dc532182" translate="yes" xml:space="preserve">
          <source>This function performs syntax checking on a prototype, &lt;code&gt;proto&lt;/code&gt; . If &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; is true, any illegal characters or mismatched brackets will trigger illegalproto warnings, declaring that they were detected in the prototype for &lt;code&gt;name&lt;/code&gt; .</source>
          <target state="translated">이 함수는 프로토 타입 &lt;code&gt;proto&lt;/code&gt; 에서 구문 검사를 수행합니다 . 경우 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; 사실, 불법 문자 나 일치하지 않는 괄호은의 프로토 타입에서 검출되었다고 선언, 경고 illegalproto 트리거 &lt;code&gt;name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="91930e6b34fa8d1a9857a2f7de94cb11275f2880" translate="yes" xml:space="preserve">
          <source>This function performs the work of the legacy functions gethostbyname(), getservbyname(), inet_aton() and pack_sockaddr_in().</source>
          <target state="translated">이 함수는 레거시 함수 gethostbyname (), getservbyname (), inet_aton () 및 pack_sockaddr_in ()의 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="b69a639ae94b0e84e8a91026a470893dc8e2e4fa" translate="yes" xml:space="preserve">
          <source>This function performs the work of the legacy functions unpack_sockaddr_in(), inet_ntoa(), gethostbyaddr() and getservbyport().</source>
          <target state="translated">이 함수는 레거시 함수 unpack_sockaddr_in (), inet_ntoa (), gethostbyaddr () 및 getservbyport ()의 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="3d1364c8524baa88f5749c97cf4b3c3b92b20d7d" translate="yes" xml:space="preserve">
          <source>This function places an advisory lock on a shared variable or referenced object contained in</source>
          <target state="translated">이 함수는 공유 변수 또는 참조 된 객체에 권고 잠금을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="13aa5d944aea63735721eab1c7c43ad176915f14" translate="yes" xml:space="preserve">
          <source>This function returns a string of &lt;code&gt;boot_$ModuleName&lt;/code&gt; prototypes for each @modules.</source>
          <target state="translated">이 함수는 각 @ 모듈에 대해 boot_ &lt;code&gt;boot_$ModuleName&lt;/code&gt; 프로토 타입 문자열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4f9139a43ab3e4540adae4f5d5020617b2e643b8" translate="yes" xml:space="preserve">
          <source>This function returns a string of calls to &lt;code&gt;newXS()&lt;/code&gt; that glue the module</source>
          <target state="translated">이 함수는 모듈을 붙이는 &lt;code&gt;newXS()&lt;/code&gt; 호출 문자열을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="621ba7bc642c79bf406939acb2b7c2b8df3903c7" translate="yes" xml:space="preserve">
          <source>This function returns an encoded version of the string ($str) given as argument.</source>
          <target state="translated">이 함수는 인수로 지정된 인코딩 된 버전의 문자열 ($ str)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="44086926e42f35072b303b091e9d9e0a7ca33b91" translate="yes" xml:space="preserve">
          <source>This function returns empty-list if given anything other than a formally valid language tag.</source>
          <target state="translated">이 함수는 공식적으로 유효한 언어 태그 이외의 것이 제공되면 빈 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="865f16a5f2b57a820e8bf84b966f732abf36eb70" translate="yes" xml:space="preserve">
          <source>This function returns the plain text version of the string given as argument. The lines of the result are &quot;\n&quot; terminated, even if the $str argument contains &quot;\r\n&quot; terminated lines.</source>
          <target state="translated">이 함수는 인수로 지정된 문자열의 일반 텍스트 버전을 반환합니다. $ str 인수에 &quot;\ r \ n&quot;종결 행이 포함되어 있더라도 결과의 행은 &quot;\ n&quot;종료됩니다.</target>
        </trans-unit>
        <trans-unit id="a5ab5fe7ba11e207b5f81eca8f934ec6da3fef9c" translate="yes" xml:space="preserve">
          <source>This function returns the string that results from decoding the scalar value</source>
          <target state="translated">이 함수는 스칼라 값을 디코딩하여 생성 된 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3d6da7152ac538ef94012168e86ee3522aaad549" translate="yes" xml:space="preserve">
          <source>This function returns the string with the first character modified if it is a control character. It converts it to ^X format first, so that &quot;\cG&quot; becomes &quot;^G&quot;. This is used internally by &lt;a href=&quot;#SAFENAME&quot;&gt;B::GV::SAFENAME&lt;/a&gt;, but you can call it directly.</source>
          <target state="translated">이 함수는 제어 문자 인 경우 첫 번째 문자가 수정 된 문자열을 반환합니다. &quot;\ cG&quot;가 &quot;^ G&quot;가되도록 먼저 ^ X 형식으로 변환합니다. &lt;a href=&quot;#SAFENAME&quot;&gt;B :: GV :: SAFENAME&lt;/a&gt; 내부적으로 사용 되지만 직접 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3960f619466a09edf20242d0c7f969690cbc6219" translate="yes" xml:space="preserve">
          <source>This function should be as efficient as possible to keep your programs running as fast as possible.</source>
          <target state="translated">이 기능은 프로그램을 최대한 빠르게 실행하기 위해 가능한 효율적이어야합니다.</target>
        </trans-unit>
        <trans-unit id="3a1ef4b3781258f0fdbabb5991f2b0a7c13aaadc" translate="yes" xml:space="preserve">
          <source>This function should have been named wantlist() instead.</source>
          <target state="translated">이 함수는 대신 wantlist ()라는 이름을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="0b507d2e008bacdbb9e54edf21d0bbb50fdaab83" translate="yes" xml:space="preserve">
          <source>This function should not be called if you are using the object oriented interface since the it will interfere with the object destructor deleting the file.</source>
          <target state="translated">객체 지향 인터페이스를 사용하는 경우 파일을 삭제하는 객체 소멸자를 방해하므로이 함수를 호출하면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="c82575cb1cd9500578e180e36936964e6acbcd65" translate="yes" xml:space="preserve">
          <source>This function should not have a compatibility macro to define, say, &lt;code&gt;Perl_parse&lt;/code&gt; to &lt;code&gt;parse&lt;/code&gt; . It must be called as &lt;code&gt;Perl_parse&lt;/code&gt; .</source>
          <target state="translated">이 함수에는 &lt;code&gt;Perl_parse&lt;/code&gt; to &lt;code&gt;parse&lt;/code&gt; 를 정의하는 호환성 매크로가 없어야 합니다 . &lt;code&gt;Perl_parse&lt;/code&gt; 로 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="bd99feaf61a2bec56d635937abeb8d24fef9d878" translate="yes" xml:space="preserve">
          <source>This function simply calls the Microsoft C library _getdcwd() function.</source>
          <target state="translated">이 함수는 단순히 Microsoft C 라이브러리 _getdcwd () 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="7c73c162d2f4a3c57002d94f30e626af9a64555c" translate="yes" xml:space="preserve">
          <source>This function simply returns a string defining the same &lt;code&gt;EXTERN_C&lt;/code&gt; macro as</source>
          <target state="translated">이 함수는 단순히 같은 &lt;code&gt;EXTERN_C&lt;/code&gt; 매크로를 정의하는 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9ab2ac7d8042c579036bf811ff64ad55b40d9830" translate="yes" xml:space="preserve">
          <source>This function skips over the automatic calls to &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; made on the behalf of the debugger. If the stack frame requested was a sub called by &lt;code&gt;DB::sub&lt;/code&gt; , the return value will be the frame for the call to &lt;code&gt;DB::sub&lt;/code&gt; , since that has the correct line number/etc. for the call site. If</source>
          <target state="translated">이 함수는 디버거를 대신하여 작성된 &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; 대한 자동 호출을 건너 뜁니다 . 요청 된 스택 프레임이 &lt;code&gt;DB::sub&lt;/code&gt; 의해 호출 된 서브 인 경우, 리턴 값은 올바른 행 번호 등을 가지므로 &lt;code&gt;DB::sub&lt;/code&gt; 에 대한 호출의 프레임이됩니다 . 전화 사이트. 만약</target>
        </trans-unit>
        <trans-unit id="3f1ed900c36dd5852fb31f0242bde189d87ee34e" translate="yes" xml:space="preserve">
          <source>This function takes a list of 0 or more language tags that constitute a given user's Accept-Language list, and returns a list of tags for</source>
          <target state="translated">이 함수는 주어진 사용자의 Accept-Language 목록을 구성하는 0 개 이상의 언어 태그 목록을 가져 와서에 대한 태그 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2e20c9e90738e4e12b4b244ae6847d7d7fb0c7dd" translate="yes" xml:space="preserve">
          <source>This function takes a variable number of arguments, &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; style. The argument list should end with &lt;code&gt;...&lt;/code&gt; , like this:</source>
          <target state="translated">이 함수는 다양한 수의 인수, &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 스타일을 사용합니다. 인수 목록은 다음과 같이 &lt;code&gt;...&lt;/code&gt; 로 끝나야 합니다.</target>
        </trans-unit>
        <trans-unit id="cf2eecbd5d099ce08ffbe9b809327bd3414ba65b" translate="yes" xml:space="preserve">
          <source>This function takes no arguments, and as far as &lt;code&gt;Memoize&lt;/code&gt; is concerned, it always returns the same result. &lt;code&gt;Memoize&lt;/code&gt; is wrong, of course, and the memoized version of this function will call &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; once to get the current time, and it will return that same time every time you call it after that.</source>
          <target state="translated">이 함수는 인수를 취하지 않으며 &lt;code&gt;Memoize&lt;/code&gt; 에 관한 한 항상 동일한 결과를 반환합니다. &lt;code&gt;Memoize&lt;/code&gt; 은 물론, 잘못이며,이 함수의 memoized 버전이 호출 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 현재 시간을 얻기 위해 한 번, 그리고 그 같은 시간에 당신이 그 이후를 호출 할 때마다 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5edb4f65abb2fc47967dac5333a9e803321aac25" translate="yes" xml:space="preserve">
          <source>This function tells the thingy referenced by REF that it is now an object in the CLASSNAME package. If CLASSNAME is omitted, the current package is used. Because a &lt;code&gt;&lt;a href=&quot;bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; is often the last thing in a constructor, it returns the reference for convenience. Always use the two-argument version if a derived class might inherit the function doing the blessing. See &lt;a href=&quot;../perlobj&quot;&gt;perlobj&lt;/a&gt; for more about the blessing (and blessings) of objects.</source>
          <target state="translated">이 함수는 REF가 참조하는 것을 CLASSNAME 패키지의 객체라고 알려줍니다. CLASSNAME을 생략하면 현재 패키지가 사용됩니다. a가 있기 때문에 &lt;code&gt;&lt;a href=&quot;bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 종종 생성자의 마지막 일, 그것은 편의를 위해 참조를 반환합니다. 파생 클래스가 축복을 수행하는 함수를 상속 할 수있는 경우 항상 두 개의 인수 버전을 사용하십시오. 사물의 축복 (및 축복)에 대한 자세한 내용은 &lt;a href=&quot;../perlobj&quot;&gt;perlobj&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="264717bee5831f635e17b82abeba8fa8b801090b" translate="yes" xml:space="preserve">
          <source>This function tells the thingy referenced by REF that it is now an object in the CLASSNAME package. If CLASSNAME is omitted, the current package is used. Because a &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; is often the last thing in a constructor, it returns the reference for convenience. Always use the two-argument version if a derived class might inherit the function doing the blessing. See &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; for more about the blessing (and blessings) of objects.</source>
          <target state="translated">이 함수는 REF가 참조하는 것을 CLASSNAME 패키지의 객체라고 알려줍니다. CLASSNAME을 생략하면 현재 패키지가 사용됩니다. a가 있기 때문에 &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 종종 생성자의 마지막 일, 그것은 편의를 위해 참조를 반환합니다. 파생 클래스가 축복을 수행하는 함수를 상속 할 수있는 경우 항상 두 개의 인수 버전을 사용하십시오. 사물의 축복 (및 축복)에 대한 자세한 내용은 &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5d01eea1f06346371db6a328408650ca1c6b5ca7" translate="yes" xml:space="preserve">
          <source>This function uses the &lt;code&gt;load&lt;/code&gt; function or the &lt;code&gt;autoload_remote&lt;/code&gt; function from Module::Load under the hood.</source>
          <target state="translated">이 함수는 후드 아래의 Module :: Load에서 &lt;code&gt;load&lt;/code&gt; 기능 또는 &lt;code&gt;autoload_remote&lt;/code&gt; 기능을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="dde06d7625f57e7da1a76d11827641ea58931d51" translate="yes" xml:space="preserve">
          <source>This function was useful for code that wanted to handle both EBCDIC and ASCII platforms with Unicode properties, but starting in Perl v5.20, the distinctions between the platforms have mostly been made invisible to most code, so this function is quite unlikely to be what you want. If you do need this precise functionality, use instead &lt;code&gt;&lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;NATIVE_TO_UNI(utf8_to_uvchr_buf(...))&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;NATIVE_TO_UNI(utf8n_to_uvchr(...))&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 유니 코드 속성을 사용하여 EBCDIC 및 ASCII 플랫폼을 모두 처리하려는 코드에 유용했지만 Perl v5.20부터는 플랫폼 간의 차이점이 대부분의 코드에서 보이지 않게되었으므로이 기능은 당신이 원합니다. 이 정확한 기능이 필요하면 &lt;code&gt;&lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;NATIVE_TO_UNI(utf8_to_uvchr_buf(...))&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;NATIVE_TO_UNI(utf8n_to_uvchr(...))&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e428d7e7165fe610c2ec2aae0a7a0abdc81b5d5a" translate="yes" xml:space="preserve">
          <source>This function will calculate and return the binary digest of the bytes of the given file. The function will croak if it fails to open or read the file.</source>
          <target state="translated">이 함수는 주어진 파일의 바이트 이진 다이제스트를 계산하고 반환합니다. 파일을 열거 나 읽지 못하면 함수가 손상됩니다.</target>
        </trans-unit>
        <trans-unit id="e710ca7b4ebf9ab0536802088bacbcbd1c5ec7fb" translate="yes" xml:space="preserve">
          <source>This function will concatenate all arguments, calculate the MD5 digest of this &quot;message&quot;, and return it in binary form. The returned string will be 16 bytes long.</source>
          <target state="translated">이 함수는 모든 인수를 연결하고이 &quot;메시지&quot;의 MD5 다이제스트를 계산하여 이진 형식으로 반환합니다. 반환 된 문자열의 길이는 16 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="c489f76d5438c6d22b3cb418ff3f520db9ae337f" translate="yes" xml:space="preserve">
          <source>This function will convert to UTF-8 (and not warn) even code points that aren't legal Unicode or are problematic, unless &lt;code&gt;flags&lt;/code&gt; contains one or more of the following flags:</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; 가 다음 플래그 중 하나 이상을 포함 하지 않는 한,이 함수는 합법적 인 유니 코드가 아니거나 문제가있는 코드 포인트를 UTF-8로 변환하고 경고하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="bfa2e2cbe1081798fb5dd07961b2589448f68e0d" translate="yes" xml:space="preserve">
          <source>This function will croak if it can't connect to the syslog daemon.</source>
          <target state="translated">이 기능은 syslog 데몬에 연결할 수없는 경우 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="c8fb41e9972ce033692cb3bc009110bcfa6b3909" translate="yes" xml:space="preserve">
          <source>This function will not be confused by overloading or blessing. In internals terms, this extracts the regexp pointer out of the PERL_MAGIC_qr structure so it cannot be fooled.</source>
          <target state="translated">이 기능은 과부 하나 축복으로 혼동되지 않습니다. 내부적으로는 PERL_MAGIC_qr 구조에서 정규 표현식 포인터를 추출하여 속일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bdf7565f2d5b49ccdcf0417e04e7ffb7876b15d0" translate="yes" xml:space="preserve">
          <source>This function will split up your program into files that the AutoLoader module can handle. It is used by both the standard perl libraries and by the MakeMaker utility, to automatically configure libraries for autoloading.</source>
          <target state="translated">이 기능은 프로그램을 AutoLoader 모듈이 처리 할 수있는 파일로 분할합니다. 표준 perl 라이브러리와 MakeMaker 유틸리티에서 자동로드 용 라이브러리를 자동으로 구성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="eb5d34127b41d73e4ad33707ae6e0f3468fa3088" translate="yes" xml:space="preserve">
          <source>This function works like the system call by the same name: it makes the named directory the new root directory for all further pathnames that begin with a &lt;code&gt;/&lt;/code&gt; by your process and all its children. (It doesn't change your current working directory, which is unaffected.) For security reasons, this call is restricted to the superuser. If FILENAME is omitted, does a &lt;code&gt;&lt;a href=&quot;chroot&quot;&gt;chroot&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">이 함수는 같은 이름의 시스템 호출처럼 작동 합니다. 프로세스와 모든 자식 에서 &lt;code&gt;/&lt;/code&gt; 로 시작하는 모든 추가 경로 이름의 명명 된 디렉토리를 새 루트 디렉토리로 만듭니다. (현재 작업 디렉토리는 변경되지 않으며 영향을받지 않습니다.) 보안상의 이유로이 호출은 수퍼 유저로 제한됩니다. FILENAME을 생략하면 &lt;code&gt;&lt;a href=&quot;chroot&quot;&gt;chroot&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;$_&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="a4f0880e6d532a1f27ed2ddbef9335a9b1af6165" translate="yes" xml:space="preserve">
          <source>This function works like the system call by the same name: it makes the named directory the new root directory for all further pathnames that begin with a &lt;code&gt;/&lt;/code&gt; by your process and all its children. (It doesn't change your current working directory, which is unaffected.) For security reasons, this call is restricted to the superuser. If FILENAME is omitted, does a &lt;code&gt;&lt;a href=&quot;functions/chroot&quot;&gt;chroot&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">이 함수는 같은 이름의 시스템 호출처럼 작동 합니다. 프로세스와 모든 자식 에서 &lt;code&gt;/&lt;/code&gt; 로 시작하는 모든 추가 경로 이름의 명명 된 디렉토리를 새 루트 디렉토리로 만듭니다. (현재 작업 디렉토리는 변경되지 않으며 영향을받지 않습니다.) 보안상의 이유로이 호출은 수퍼 유저로 제한됩니다. FILENAME을 생략하면 &lt;code&gt;&lt;a href=&quot;functions/chroot&quot;&gt;chroot&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;$_&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="ef6e36bc13a174b6b1778b35a2d60399ce6095bb" translate="yes" xml:space="preserve">
          <source>This function, if given a language tag, returns all language tags that are alternate forms of this language tag. (I.e., tags which refer to the same language.) This is meant to handle legacy tags caused by the minor changes in language tag standards over the years; and the x-/i- alternation is also dealt with.</source>
          <target state="translated">언어 태그가 지정된 경우이 함수는이 언어 태그의 대체 형식 인 모든 언어 태그를 반환합니다. (즉, 동일한 언어를 참조하는 태그) 이는 수년에 걸쳐 언어 태그 표준의 작은 변화로 인한 레거시 태그를 처리하기위한 것입니다. x- / i-alternation도 다룹니다.</target>
        </trans-unit>
        <trans-unit id="b8a93fcdf2125a7d09fd995b425967c3b4164e45" translate="yes" xml:space="preserve">
          <source>This function, if given a language tag, returns an encoding of it such that:</source>
          <target state="translated">언어 태그가 지정된 경우이 함수는 다음과 같은 인코딩을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ab422ba4ddb7cdb9c2c2585a4c8bf7188aa9975a" translate="yes" xml:space="preserve">
          <source>This function, which is included in the two export tags listed above, takes one or two arguments. The first is the glob pattern. The second is a set of flags ORed together. The available flags are listed below under &lt;a href=&quot;#POSIX-FLAGS&quot;&gt;POSIX FLAGS&lt;/a&gt;. If the second argument is omitted, &lt;code&gt;GLOB_CSH&lt;/code&gt; (or &lt;code&gt;GLOB_CSH|GLOB_NOCASE&lt;/code&gt; on VMS and DOSish systems) is used by default.</source>
          <target state="translated">위에 나열된 두 개의 내보내기 태그에 포함 된이 함수는 하나 또는 두 개의 인수를 사용합니다. 첫 번째는 glob 패턴입니다. 두 번째는 OR로 묶인 플래그 집합입니다. 사용 가능한 플래그는 아래 &lt;a href=&quot;#POSIX-FLAGS&quot;&gt;POSIX FLAGS&lt;/a&gt; 아래에 나열되어 있습니다 . 두 번째 인수를 생략하면 &lt;code&gt;GLOB_CSH&lt;/code&gt; (또는 VMS 및 DOSish 시스템의 &lt;code&gt;GLOB_CSH|GLOB_NOCASE&lt;/code&gt; )가 기본적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7607d86adf25319082630a8f720c18a028dc2b55" translate="yes" xml:space="preserve">
          <source>This functionality is disabled for setuid scripts and for scripts run with &lt;b&gt;-T&lt;/b&gt;.</source>
          <target state="translated">이 기능은 setuid 스크립트 및 &lt;b&gt;-T로&lt;/b&gt; 실행되는 스크립트에서는 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="5e7553b3094129fa58516257b0cce463898fb85b" translate="yes" xml:space="preserve">
          <source>This generates a compile-time error if you access a variable that was neither explicitly declared (using any of &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
vars&lt;/code&gt; ) nor fully qualified. (Because this is to avoid variable suicide problems and subtle dynamic scoping issues, a merely &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; variable isn't good enough.) See &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;, &lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;, &lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;, &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;, and &lt;a href=&quot;vars&quot;&gt;vars&lt;/a&gt;.</source>
          <target state="translated">명시 적으로 선언되지 않은 ( &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용)&lt;/a&gt; 변수가 아닌 정규화 된 변수에 액세스하면 컴파일 타임 오류가 발생합니다 . (이것은 가변 자살 문제와 미묘한 동적 범위 지정 문제를 피하기위한 것이므로 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 변수로는 충분하지 않습니다.) &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; , &lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt; , &lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt; , &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; 및 &lt;a href=&quot;vars&quot;&gt;vars를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f74c9a11ba157a546c0c89330b1cb3bdd1614525" translate="yes" xml:space="preserve">
          <source>This generates a runtime error if you use symbolic references (see &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;).</source>
          <target state="translated">기호 참조를 사용하는 경우 런타임 오류가 발생합니다 ( &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="3b0f601577dbb5896904df9ff737e1fa0298974a" translate="yes" xml:space="preserve">
          <source>This gets interpreted as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70bf742be7e750bec7fa9fb8e4b6fe30ec9b5f65" translate="yes" xml:space="preserve">
          <source>This gives nasty overhead when you are trying to dynamically require modules at runtime, since you will need to change the module notation (&lt;code&gt;Acme::Comment&lt;/code&gt; ) to a file notation fitting the particular platform you are on.</source>
          <target state="translated">모듈 표기법 ( &lt;code&gt;Acme::Comment&lt;/code&gt; )을 현재 사용중인 특정 플랫폼에 맞는 파일 표기법 으로 변경해야하므로 런타임에 동적으로 모듈을 요구하려고하면 과도한 오버 헤드가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="7c019885847002a06e56f60b480505499d5d7585" translate="yes" xml:space="preserve">
          <source>This gives the name of the extension (</source>
          <target state="translated">확장명을 제공합니다 (</target>
        </trans-unit>
        <trans-unit id="6b221eef709fb6d96fbb9db3f118edc097a1ba2d" translate="yes" xml:space="preserve">
          <source>This global modifies the argument given to &lt;code&gt;&lt;a href=&quot;../functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; by &lt;code&gt;Params::Check::check()&lt;/code&gt; and is useful if you have a custom wrapper function around &lt;code&gt;Params::Check::check()&lt;/code&gt; . The value must be an integer, indicating the number of wrapper functions inserted between the real function call and &lt;code&gt;Params::Check::check()&lt;/code&gt; .</source>
          <target state="translated">이 세계에 주어진 인수 수정 &lt;code&gt;&lt;a href=&quot;../functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; 에 의해 &lt;code&gt;Params::Check::check()&lt;/code&gt; 및 주변 기능 래퍼 사용자 지정이있는 경우에 유용 &lt;code&gt;Params::Check::check()&lt;/code&gt; . 값은 정수 여야하며, 실제 함수 호출과 &lt;code&gt;Params::Check::check()&lt;/code&gt; 사이에 삽입 된 랩퍼 함수 수를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="f8923baf9a118df6243078227c2bc3261ab6c170" translate="yes" xml:space="preserve">
          <source>This globally overrides the default behavior of calling &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; inside a thread, and effectively causes such calls to behave the same as &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt; . In other words, with this setting, calling &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; causes only the thread to terminate.</source>
          <target state="translated">이것은 스레드 내에서 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 호출의 기본 동작을 전체적으로 무시 하고 효과적으로 이러한 호출이 &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt; 와 동일하게 작동하도록합니다 . 즉,이 설정으로 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 호출 하면 스레드 만 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="9d1a7a9bddd9acdc92fdc5c3e015da338283422a" translate="yes" xml:space="preserve">
          <source>This guarantees that STDOUT (where the test results appear) and STDERR (where the diagnostics appear) will stay in sync. The harness will display any diagnostics your tests emit on STDERR.</source>
          <target state="translated">이렇게하면 STDOUT (테스트 결과가 나타나는 곳)과 STDERR (진단이 나타나는 곳)가 동기화 상태를 유지하게됩니다. 하네스는 STDERR에서 테스트가 수행 한 모든 진단을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="06edcd446459b13f358d5f7a1e7f44f85855880a" translate="yes" xml:space="preserve">
          <source>This happened because the presence of overloading was checked too early, before any tie()d access was attempted. If the class of the value FETCH()ed from the tied variable does not change, a simple workaround for code that is to run on older Perl versions is to access the value (via &lt;code&gt;() = $foo&lt;/code&gt; or some such) immediately after tie()ing, so that after this call the</source>
          <target state="translated">이는 tie () d 액세스를 시도하기 전에 과부하가 너무 일찍 확인 되었기 때문에 발생했습니다. 연결된 변수에서 FETCH () 값의 클래스가 변경되지 않으면 이전 Perl 버전에서 실행되는 코드에 대한 간단한 해결 방법은 연결 직후에 값을 통해 &lt;code&gt;() = $foo&lt;/code&gt; 또는 이와 같은 방법으로) 액세스하는 것입니다. 이 호출 후</target>
        </trans-unit>
        <trans-unit id="4f907111d1d29806bed6e772fe053aff55cf72f3" translate="yes" xml:space="preserve">
          <source>This happens because Berkeley DB uses dynamic memory to allocate buffers which will subsequently be written to the database file. Being dynamic, the memory could have been used for anything before DB malloced it. As Berkeley DB doesn't clear the memory once it has been allocated, the unused portions will contain random junk. In the case where a Perl script gets written to the database, the random junk will correspond to an area of dynamic memory that happened to be used during the compilation of the script.</source>
          <target state="translated">Berkeley DB는 동적 메모리를 사용하여 버퍼를 할당하고 이후 버퍼를 데이터베이스 파일에 기록하기 때문에 발생합니다. 동적이기 때문에 DB가 메모리를 사용하기 전에 메모리가 무엇이든 사용될 수있었습니다. Berkeley DB는 일단 할당 된 메모리를 지우지 않기 때문에 사용하지 않는 부분에는 임의의 정크가 포함됩니다. Perl 스크립트가 데이터베이스에 기록되는 경우 무작위 정크는 스크립트 컴파일 중에 사용 된 동적 메모리 영역에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="2287d497a37220b85075e14fb44f3c5f11c4109c" translate="yes" xml:space="preserve">
          <source>This happens because you can't really share arbitrary data structures with foreign processes.</source>
          <target state="translated">외부 프로세스와 임의의 데이터 구조를 실제로 공유 할 수 없기 때문에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3663fa9d53c5bc8b1c430a10078b98451ddfbf78" translate="yes" xml:space="preserve">
          <source>This happens only if your perl is compiled to use stdio instead of perlio, which is the default. Some (maybe all?) stdios set error and eof flags that you may need to clear. The &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module defines &lt;code&gt;clearerr()&lt;/code&gt; that you can use. That is the technically correct way to do it. Here are some less reliable workarounds:</source>
          <target state="translated">이는 perl이 perlio 대신 stdio를 사용하도록 컴파일 된 경우에만 발생하며 이것이 기본값입니다. 일부 (아마도?) stdios는 오류와 eof 플래그를 설정해야합니다. &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; 모듈을 정의 &lt;code&gt;clearerr()&lt;/code&gt; 사용할 수있다. 그것이 기술적으로 올바른 방법입니다. 신뢰할 수없는 해결 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="40e2474ab2464f5a6d8b366f637789f861001327" translate="yes" xml:space="preserve">
          <source>This happens to avoid shell interpolation problems when whitespace is present in directory names.</source>
          <target state="translated">이것은 디렉토리 이름에 공백이있을 때 쉘 보간 문제를 피하기 위해 발생합니다.</target>
        </trans-unit>
        <trans-unit id="76f62e127c6c53c05eb19f5eae3fcd84ce29184a" translate="yes" xml:space="preserve">
          <source>This has a significant advantage in space over reading the whole file in. You can find a proof of this method in</source>
          <target state="translated">이것은 전체 파일을 읽는 것보다 공간에서 중요한 이점이 있습니다.이 방법에 대한 증거는</target>
        </trans-unit>
        <trans-unit id="a19e57e2a77c7fc3b4122f04d13e6469dce9f91c" translate="yes" xml:space="preserve">
          <source>This has been recorded in &lt;a href=&quot;http://search.cpan.org/perldoc/rt.cpan.org&quot;&gt;rt.cpan.org&lt;/a&gt; as bug #37532: Unable to interleave STDOUT and STDERR.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/rt.cpan.org&quot;&gt;rt.cpan.org&lt;/a&gt; 에 버그 # 37532 : STDOUT 및 STDERR을 인터리브 할 수 없음 으로 기록되었습니다 .</target>
        </trans-unit>
        <trans-unit id="f52d89b3c166d4a363c55e83875dec4c4067987e" translate="yes" xml:space="preserve">
          <source>This has several advantages. Accessors make it easier to change the implementation of an object later while still preserving the original API.</source>
          <target state="translated">이것은 몇 가지 장점이 있습니다. 접근자는 나중에 원래 API를 유지하면서 객체의 구현을 더 쉽게 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34b1eddfb5655aec91f3e8e1f2978f9657ae01a0" translate="yes" xml:space="preserve">
          <source>This has the effect of storing the cache in a &lt;code&gt;DB_File&lt;/code&gt; database whose name is in &lt;code&gt;$filename&lt;/code&gt; . The cache will persist after the program has exited. Next time the program runs, it will find the cache already populated from the previous run of the program. Or you can forcibly populate the cache by constructing a batch program that runs in the background and populates the cache file. Then when you come to run your real program the memoized function will be fast because all its results have been precomputed.</source>
          <target state="translated">이는 이름이 &lt;code&gt;$filename&lt;/code&gt; 인 &lt;code&gt;DB_File&lt;/code&gt; 데이터베이스에 캐시를 저장하는 효과가 있습니다. 캐시는 프로그램이 종료 된 후에도 지속됩니다. 다음에 프로그램이 실행되면 프로그램의 이전 실행에서 이미 채워진 캐시를 찾습니다. 또는 백그라운드에서 실행되고 캐시 파일을 채우는 배치 프로그램을 구성하여 캐시를 강제로 채울 수 있습니다. 그런 다음 실제 프로그램을 실행하면 모든 결과가 사전 계산되어 메모리 기능이 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="4f55042605688b1e566dc7078adcb80b2ae71090" translate="yes" xml:space="preserve">
          <source>This has the interesting effect of creating a function local to another function, something not normally supported in Perl.</source>
          <target state="translated">이것은 Perl에서 일반적으로 지원되지 않는 다른 함수의 로컬 함수를 만드는 흥미로운 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1797c70a1d197e558ba86167569174dbeb96a8a" translate="yes" xml:space="preserve">
          <source>This hash should map POD files (or scripts containing POD) to the man file names under the &lt;code&gt;blib/man1/&lt;/code&gt; directory, as in the following example:</source>
          <target state="translated">이 해시는 다음 예제와 같이 POD 파일 (또는 POD를 포함하는 스크립트)을 &lt;code&gt;blib/man1/&lt;/code&gt; 디렉토리 의 man 파일 이름에 매핑해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e9df8c379bbf80ee5fdd7c982a32f28e6ec7e7ad" translate="yes" xml:space="preserve">
          <source>This holds a hash-of-lists. Each list contains the functions in the category the key denotes.</source>
          <target state="translated">이것은리스트의 해시를 보유합니다. 각 목록에는 키가 나타내는 범주의 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="80d4d81772f7d6d67760a370f3b5798c816acf17" translate="yes" xml:space="preserve">
          <source>This holds a string of the last error that happened during a call to &lt;code&gt;can_load&lt;/code&gt; . It is useful to inspect this when &lt;code&gt;can_load&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;can_load&lt;/code&gt; 호출 중에 발생한 마지막 오류의 문자열을 보유합니다 . &lt;code&gt;can_load&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 리턴 할 때 이를 점검하는 것이 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="807ff9f1a614524ec64299d0ff11753e548d2db4" translate="yes" xml:space="preserve">
          <source>This holds the cache of the &lt;code&gt;can_load&lt;/code&gt; function. If you explicitly want to remove the current cache, you can set this variable to &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">이것은 &lt;code&gt;can_load&lt;/code&gt; 함수 의 캐시를 보유합니다 . 현재 캐시를 명시 적으로 제거하려면이 변수를 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 로 설정할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0ab611b7e6d978fe2070f07754881b8d06390403" translate="yes" xml:space="preserve">
          <source>This identical to the numerical values of the &lt;code&gt;$!&lt;/code&gt; , see &lt;a href=&quot;perlvar#%24ERRNO&quot;&gt;$ERRNO in perlvar&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;$!&lt;/code&gt; 의 숫자 값과 동일합니다 . &lt;a href=&quot;perlvar#%24ERRNO&quot;&gt;perlvar의 $ ERRNO를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eebbc38db38088437ee3de434676f2c9849a55f6" translate="yes" xml:space="preserve">
          <source>This implementation never has to fetch the context using a function call, since it is always passed as an extra argument. Depending on your needs for simplicity or efficiency, you may mix the previous two approaches freely.</source>
          <target state="translated">이 구현은 항상 추가 인수로 전달되므로 함수 호출을 사용하여 컨텍스트를 가져올 필요가 없습니다. 단순성 또는 효율성에 대한 요구에 따라 앞의 두 가지 접근 방식을 자유롭게 혼합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b6dd1dd5bc3b526c6e18c4c4cf7662fc526f6c1" translate="yes" xml:space="preserve">
          <source>This implements the C library function of the same name, which on most systems returns the current login from</source>
          <target state="translated">이것은 대부분의 시스템에서 현재 로그인을 반환하는 동일한 이름의 C 라이브러리 함수를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="9b00dbaf392453f8a0c495715d87f8a967ac3280" translate="yes" xml:space="preserve">
          <source>This implicit use of &lt;code&gt;$_&lt;/code&gt; greatly simplifies the filter.</source>
          <target state="translated">이 &lt;code&gt;$_&lt;/code&gt; 의 암시 적 사용은 필터를 크게 단순화합니다.</target>
        </trans-unit>
        <trans-unit id="5b50085de4def35b6bdec8ddfe646e562a42bf85" translate="yes" xml:space="preserve">
          <source>This implicitly turns on &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; .</source>
          <target state="translated">이는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용을&lt;/a&gt; 암시 적으로 설정 합니다 .</target>
        </trans-unit>
        <trans-unit id="1913f881cf8f6c8733392373df598260e9eff553" translate="yes" xml:space="preserve">
          <source>This implies, among other things, that any magic eventually carried by those variables is locally lost. In other words, saying &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; */&lt;/code&gt; will not have any effect on the internal value of the input record separator.</source>
          <target state="translated">이는 무엇보다도 이러한 변수에 의해 수행되는 모든 마법이 로컬에서 손실된다는 것을 의미합니다. 즉, &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; */&lt;/code&gt; 을 말하는 것은 입력 레코드 구분 기호의 내부 값에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="853b46dcbc0a00c897209b2e5eda11d1bef5190a" translate="yes" xml:space="preserve">
          <source>This imports all the symbols from YourModule's &lt;code&gt;@EXPORT&lt;/code&gt; into the namespace of the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement.</source>
          <target state="translated">그러면 YourModule &lt;code&gt;@EXPORT&lt;/code&gt; 의 모든 기호 가 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 문의 네임 스페이스로 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="cc30f208dc0886e9e09f0ad72a7741fdb1114419" translate="yes" xml:space="preserve">
          <source>This imports only the symbols listed by the caller into their namespace. All listed symbols must be in your &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt; , else an error occurs. The advanced export features of Exporter are accessed like this, but with list entries that are syntactically distinct from symbol names.</source>
          <target state="translated">호출자가 나열한 기호 만 해당 네임 스페이스로 가져옵니다. 모든 상장 기호는 당신에 있어야합니다 &lt;code&gt;@EXPORT&lt;/code&gt; 또는 &lt;code&gt;@EXPORT_OK&lt;/code&gt; , 다른 오류가 발생합니다. Exporter의 고급 내보내기 기능은 이와 같이 액세스되지만 기호 이름과 구문 상 구분되는 목록 항목이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f54334948064b9890996f54ddad24e2c8dcfde1a" translate="yes" xml:space="preserve">
          <source>This incantation is a bit much to remember, but Perl will display it for you if you say &lt;code&gt;perl &quot;-V:startperl&quot;&lt;/code&gt; .</source>
          <target state="translated">이 주문은 기억해야 할 것이 &lt;code&gt;perl &quot;-V:startperl&quot;&lt;/code&gt; 이라고 말하면 Perl이 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="5270d55bdd99c39c88df6b66aa86ef8a427ec941" translate="yes" xml:space="preserve">
          <source>This includes everything before the &amp;lt;title&amp;gt; opening tag including the Document type and including the opening &amp;lt;title&amp;gt; tag. The following call will set it to be a simple HTML file:</source>
          <target state="translated">여기에는 문서 유형을 포함하고 여는 &amp;lt;title&amp;gt; 태그를 포함하여 &amp;lt;title&amp;gt; 여는 태그 앞의 모든 것이 포함됩니다. 다음 호출은 간단한 HTML 파일로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="5e4643de8eedeed9698ffe2974d9db63ab9e6ea1" translate="yes" xml:space="preserve">
          <source>This indicates how numbers should be formatted for human readability, for example the character used as the decimal point.</source>
          <target state="translated">이것은 사람이 읽을 수 있도록 숫자를 형식화하는 방법을 나타냅니다 (예 : 소수점으로 사용되는 문자).</target>
        </trans-unit>
        <trans-unit id="6005230475219b0a5021d5218cbbce15d92f7c81" translate="yes" xml:space="preserve">
          <source>This indicates that Configure is being run with a broken Korn shell (even though you think you are using a Bourne shell by using &quot;sh Configure&quot; or &quot;./Configure&quot;). The Korn shell bug has been reported to Compaq as of February 1999 but in the meanwhile, the reason ksh is being used is that you have the environment variable BIN_SH set to 'xpg4'. This causes /bin/sh to delegate its duties to /bin/posix/sh (a ksh). Unset the environment variable and rerun Configure.</source>
          <target state="translated">이는 &quot;sh Configure&quot;또는 &quot;./Configure&quot;를 사용하여 Bourne 쉘을 사용한다고 생각하더라도 깨진 Korn 쉘로 구성이 실행 중임을 나타냅니다. Korn 쉘 버그는 1999 년 2 월 현재 Compaq에보고되었지만 ksh를 사용하는 이유는 환경 변수 BIN_SH가 'xpg4'로 설정되어 있기 때문입니다. 이로 인해 / bin / sh는 / bin / posix / sh (ksh)에 의무를 위임합니다. 환경 변수를 설정 해제하고 구성을 다시 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="062f44d9692db42f54456303d55718a170b1e245" translate="yes" xml:space="preserve">
          <source>This indicates the ordering of letters for comparison and sorting. In Latin alphabets, for example, &quot;b&quot;, generally follows &quot;a&quot;.</source>
          <target state="translated">비교 및 정렬을위한 문자 순서를 나타냅니다. 라틴 알파벳에서, 예를 들어 &quot;b&quot;는 일반적으로 &quot;a&quot;를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="e6751de1d4a71c579b34f21fa42d3fbd6eb68764" translate="yes" xml:space="preserve">
          <source>This indicates, for example if a character is an uppercase letter.</source>
          <target state="translated">예를 들어 문자가 대문자 인 경우를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f1ba19f7444dcdb1f5fd5e30a3ff4c300dd9b51b" translate="yes" xml:space="preserve">
          <source>This information should not be considered complete; it includes possibly transient information about idiosyncrasies of some of the ports, almost all of which are in a state of constant evolution. Thus, this material should be considered a perpetual work in progress (&lt;code&gt;&amp;lt;IMG SRC=&quot;yellow_sign.gif&quot; ALT=&quot;Under Construction&quot;&amp;gt;&lt;/code&gt; ).</source>
          <target state="translated">이 정보는 완전한 것으로 간주되어서는 안됩니다. 여기에는 일부 포트의 특유성에 대한 일시적인 정보가 포함되며 거의 모든 포트가 지속적으로 진화하는 상태입니다. 따라서이 자료는 지속적으로 진행되는 작업으로 간주되어야합니다 ( &lt;code&gt;&amp;lt;IMG SRC=&quot;yellow_sign.gif&quot; ALT=&quot;Under Construction&quot;&amp;gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1f308a14f85f6b55bddba54f6f0dccb1fe994f0d" translate="yes" xml:space="preserve">
          <source>This inserts the contents of the default MANIFEST.SKIP file</source>
          <target state="translated">기본 MANIFEST.SKIP 파일의 내용이 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="a183a2a7c1e850deb76aa146e5c8c7d75a1d8b67" translate="yes" xml:space="preserve">
          <source>This inserts the contents of the specified external file</source>
          <target state="translated">지정된 외부 파일의 내용을 삽입합니다</target>
        </trans-unit>
        <trans-unit id="710127152df45ef23f215433723e52cbd88020a4" translate="yes" xml:space="preserve">
          <source>This install method only has the power to install the distribution if there are no dependencies in the way. To install an object along with all its dependencies, use CPAN::Shell-&amp;gt;install.</source>
          <target state="translated">이 설치 방법에는 종속성이없는 경우 분배를 설치할 수있는 기능 만 있습니다. 모든 종속 항목과 함께 오브젝트를 설치하려면 CPAN :: Shell-&amp;gt; install을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="081204399b94282349e76c93ee84e633b6e3ee15" translate="yes" xml:space="preserve">
          <source>This instance of this layer supports the &quot;fast &lt;code&gt;gets&lt;/code&gt; &quot; interface. Normally set based on &lt;code&gt;PERLIO_K_FASTGETS&lt;/code&gt; for the class and by the existence of the function(s) in the table. However a class that normally provides that interface may need to avoid it on a particular instance. The &quot;pending&quot; layer needs to do this when it is pushed above a layer which does not support the interface. (Perl's &lt;code&gt;sv_gets()&lt;/code&gt; does not expect the streams fast &lt;code&gt;gets&lt;/code&gt; behaviour to change during one &quot;get&quot;.)</source>
          <target state="translated">이 계층의 인스턴스는 &quot;fast &lt;code&gt;gets&lt;/code&gt; &quot;인터페이스를 지원합니다 . 일반적으로 클래스의 &lt;code&gt;PERLIO_K_FASTGETS&lt;/code&gt; 및 테이블에 함수의 존재에 따라 설정됩니다. 그러나 일반적으로 해당 인터페이스를 제공하는 클래스는 특정 인스턴스에서 해당 인터페이스를 피해야 할 수도 있습니다. &quot;보류 중&quot;레이어는 인터페이스를 지원하지 않는 레이어 위로 눌렀을 때이 작업을 수행해야합니다. (펄의 &lt;code&gt;sv_gets()&lt;/code&gt; 빨리 스트림을 기대하지 않습니다 &lt;code&gt;gets&lt;/code&gt; &quot;GET&quot;한 동안 변화에 대한 행동을.)</target>
        </trans-unit>
        <trans-unit id="7a3d641c3fb98c37692677f17bfddfa4c0c2f88d" translate="yes" xml:space="preserve">
          <source>This integer normally starts off at a value of &lt;code&gt;1&lt;/code&gt; when a package stash is instantiated. Calling it on packages whose stashes do not exist at all will return &lt;code&gt;0&lt;/code&gt; . If a package stash is completely deleted (not a normal occurrence, but it can happen if someone does something like &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; %PkgName::&lt;/code&gt; ), the number will be reset to either &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt; , depending on how completely the package was wiped out.</source>
          <target state="translated">이 정수는 일반적으로 패키지 숨김이 인스턴스화 될 때 값 &lt;code&gt;1&lt;/code&gt; 에서 시작합니다 . 숨김이 전혀없는 패키지에서 호출하면 &lt;code&gt;0&lt;/code&gt; 이 반환 됩니다. 패키지 숨김이 완전히 삭제 된 경우 (정상 발생하지 않지만 누군가 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; %PkgName::&lt;/code&gt; 와 같은 작업을 수행하는 경우 발생할 수 있음 ) 패키지가 완전히 지워진 정도에 따라 숫자가 &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;1&lt;/code&gt; 로 재설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="737a7a5efcfd42959d110feeee676008fd682bf1" translate="yes" xml:space="preserve">
          <source>This interface allows sequential retrieval from the database. See &lt;a href=&quot;http://search.cpan.org/perldoc/dbopen&quot;&gt;dbopen&lt;/a&gt; for full details.</source>
          <target state="translated">이 인터페이스는 데이터베이스에서 순차적 검색을 허용합니다. 자세한 내용은 &lt;a href=&quot;http://search.cpan.org/perldoc/dbopen&quot;&gt;dbopen&lt;/a&gt; 을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="cd749bb331e8a5d590f7e5603f780fdc41010317" translate="yes" xml:space="preserve">
          <source>This interface is based on the work and comments of (in no particular order): Larry Wall, Robert Sanders, Dean Roehrich, Jeff Okamoto, Anno Siegel, Thomas Neumann, Paul Marquess, Charles Bailey, myself and others.</source>
          <target state="translated">이 인터페이스는 Larry Wall, Robert Sanders, Dean Roehrich, Jeff Okamoto, Anno Siegel, Thomas Neumann, Paul Marquess, Charles Bailey, 나 자신과 다른 사람들의 작업과 의견을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="491fa4fd719b046d8f39f03410b7b5fb6254dca4" translate="yes" xml:space="preserve">
          <source>This interface is handled slightly differently in &lt;b&gt;DB_File&lt;/b&gt;. Here is an equivalent call using &lt;b&gt;DB_File&lt;/b&gt;:</source>
          <target state="translated">이 인터페이스는 &lt;b&gt;DB_File&lt;/b&gt; 에서 약간 다르게 처리 됩니다. 다음은 &lt;b&gt;DB_File을&lt;/b&gt; 사용하는 동등한 호출입니다 .</target>
        </trans-unit>
        <trans-unit id="49d69eea5115951977bf6e8780a64dd29c4226c4" translate="yes" xml:space="preserve">
          <source>This interpolation combines with the facts that the opening and closing parentheses are optional (except when necessary for precedence) and lists may end with an optional comma to mean that multiple commas within lists are legal syntax. The list &lt;code&gt;1,,3&lt;/code&gt; is a concatenation of two lists, &lt;code&gt;1,&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; , the first of which ends with that optional comma. &lt;code&gt;1,,3&lt;/code&gt; is &lt;code&gt;(1,),(3)&lt;/code&gt; is &lt;code&gt;1,3&lt;/code&gt; (And similarly for &lt;code&gt;1,,,3&lt;/code&gt; is &lt;code&gt;(1,),(,),3&lt;/code&gt; is &lt;code&gt;1,3&lt;/code&gt; and so on.) Not that we'd advise you to use this obfuscation.</source>
          <target state="translated">이 보간은 여는 괄호와 닫는 괄호가 선택 사항이며 (우선 순위에 필요한 경우 제외) 목록 내의 여러 쉼표가 합법적 인 구문임을 의미하는 쉼표로 끝날 수 있습니다. 리스트 &lt;code&gt;1,,3&lt;/code&gt; 개의리스트의 연결 인 &lt;code&gt;1,&lt;/code&gt; 및 &lt;code&gt;3&lt;/code&gt; , 즉 선택적 쉼표되는 단부의 제. &lt;code&gt;1,,3&lt;/code&gt; 은 &lt;code&gt;(1,),(3)&lt;/code&gt; 은 &lt;code&gt;1,3&lt;/code&gt; 입니다 ( &lt;code&gt;1,,,3&lt;/code&gt; 은 &lt;code&gt;(1,),(,),3&lt;/code&gt; 은 &lt;code&gt;1,3&lt;/code&gt; 등입니다). d이 난독 처리를 사용하도록 권장합니다.</target>
        </trans-unit>
        <trans-unit id="ff7fca560bcccd2ead2613d40d2441ab2644441f" translate="yes" xml:space="preserve">
          <source>This introduces another problem: what if you just know that your data is UTF-16, but you don't know which endianness? Byte Order Marks, or &lt;code&gt;BOM&lt;/code&gt; 's, are a solution to this. A special character has been reserved in Unicode to function as a byte order marker: the character with the code point &lt;code&gt;U+FEFF&lt;/code&gt; is the &lt;code&gt;BOM&lt;/code&gt; .</source>
          <target state="translated">이것은 또 다른 문제를 일으킨다 : 만약 당신의 데이터가 UTF-16이라는 것을 알고 있지만 어떤 엔디안을 모른다면? 바이트 주문 마크 또는 &lt;code&gt;BOM&lt;/code&gt; 이 이에 대한 솔루션입니다. 바이트 순서 표시 자로 기능하기 위해 특수 문자가 유니 코드로 예약되어 있습니다. 코드 포인트 &lt;code&gt;U+FEFF&lt;/code&gt; 가있는 문자 는 &lt;code&gt;BOM&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3d98b577e394b09ee4f02d9918217111200cab8f" translate="yes" xml:space="preserve">
          <source>This introductory document does not aim to be complete. It does not even aim to be entirely accurate. In some cases perfection has been sacrificed in the goal of getting the general idea across. You are</source>
          <target state="translated">이 입문서는 완전한 것이 아닙니다. 심지어 완전히 정확하지는 않습니다. 어떤 경우에는 일반적인 아이디어를 얻는 목표에서 완벽 함이 희생되었습니다. 너는</target>
        </trans-unit>
        <trans-unit id="2b646e06b5c6dfedf386d47b899ec3f8734e765d" translate="yes" xml:space="preserve">
          <source>This is &lt;b&gt;not&lt;/b&gt; the reverse of PerlIO_exportFILE().</source>
          <target state="translated">이것은 PerlIO_exportFILE ()의 반대 가 &lt;b&gt;아닙니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="a5d69879cdfbe586062188f3d7ff676e78424d35" translate="yes" xml:space="preserve">
          <source>This is &lt;b&gt;very&lt;/b&gt; similar to previous, only the first two ops differ. This subroutine rendering is more representative, insofar as a single main program will have many subs.</source>
          <target state="translated">이것은 이전과 &lt;b&gt;매우&lt;/b&gt; 유사하며 처음 두 작업 만 다릅니다. 이 서브 루틴 렌더링은 하나의 메인 프로그램에 많은 서브가있는 한 더 대표적입니다.</target>
        </trans-unit>
        <trans-unit id="13a9fc12865137f8c322a100d88693c3b3008c0d" translate="yes" xml:space="preserve">
          <source>This is Perl, so it does the exact right thing. It sees that you want to push &lt;code&gt;Athens&lt;/code&gt; onto an array that doesn't exist, so it helpfully makes a new, empty, anonymous array for you, installs it into &lt;code&gt;%table&lt;/code&gt; , and then pushes &lt;code&gt;Athens&lt;/code&gt; onto it. This is called 'autovivification'--bringing things to life automatically. Perl saw that the key wasn't in the hash, so it created a new hash entry automatically. Perl saw that you wanted to use the hash value as an array, so it created a new empty array and installed a reference to it in the hash automatically. And as usual, Perl made the array one element longer to hold the new city name.</source>
          <target state="translated">이것은 Perl이므로 정확한 일을합니다. 존재하지 않는 배열로 &lt;code&gt;Athens&lt;/code&gt; 를 푸시하려고한다는 것을 알았으므로 유용하고 비어있는 익명의 배열을 유용하게 만들고 &lt;code&gt;%table&lt;/code&gt; 설치 한 다음 &lt;code&gt;Athens&lt;/code&gt; 를 밀어 넣습니다. 이것을 '자동화'라고하며, 사물을 자동으로 구현합니다. Perl은 키가 해시에없는 것을 확인하여 새 해시 항목을 자동으로 만들었습니다. Perl은 해시 값을 배열로 사용하려고하므로 빈 배열을 새로 만들어 해시에 참조를 자동으로 설치했습니다. 그리고 평소처럼 Perl은 새로운 도시 이름을 유지하기 위해 배열을 한 요소 더 길게 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="d199012301aebd153320803c30f339cb29b9c3f4" translate="yes" xml:space="preserve">
          <source>This is TRUE if the image store data in network order. This means that it was created with nstore() or similar.</source>
          <target state="translated">이미지가 네트워크 순서로 데이터를 저장하는 경우 TRUE입니다. 이것은 nstore () 또는 이와 유사한 것으로 작성되었음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="701541b651d14d9ce17a8309970ae17dc9d55c05" translate="yes" xml:space="preserve">
          <source>This is a &quot;plug-in&quot; class that allows Perldoc to display Pod source as itself! Pretty Zen, huh?</source>
          <target state="translated">이것은 &quot;플러그인&quot;클래스로 Perldoc이 포드 소스 자체를 표시 할 수있게합니다! 예쁜 선, 응?</target>
        </trans-unit>
        <trans-unit id="a75770ef9b0c598ca7fde366202ade0c04715297" translate="yes" xml:space="preserve">
          <source>This is a &quot;plug-in&quot; class that allows Perldoc to use Pod::Man and &lt;code&gt;groff&lt;/code&gt; for reading Pod pages.</source>
          <target state="translated">이것은 &quot;플러그인&quot;클래스로 Perldoc이 Pod :: Man 및 &lt;code&gt;groff&lt;/code&gt; 를 사용하여 Pod 페이지를 읽을 수 있도록 합니다.</target>
        </trans-unit>
        <trans-unit id="81393ce7a71c653a02bafc9503ad7f009bece819" translate="yes" xml:space="preserve">
          <source>This is a &quot;plug-in&quot; class that allows Perldoc to use Pod::Man as a formatter class.</source>
          <target state="translated">이것은 Perldoc이 Pod :: Man을 포맷터 클래스로 사용할 수있게하는 &quot;플러그인&quot;클래스입니다.</target>
        </trans-unit>
        <trans-unit id="62907aa2e6a91bf9a0b7a6c6e963db493d7938e3" translate="yes" xml:space="preserve">
          <source>This is a &quot;plug-in&quot; class that allows Perldoc to use Pod::Simple::Checker as a &quot;formatter&quot; class (or if that is not available, then Pod::Checker), to check for errors in a given Pod file.</source>
          <target state="translated">이것은 &quot;플러그인&quot;클래스로 Perldoc이 Pod :: Simple :: Checker를 &quot;포매터&quot;클래스 (또는 사용할 수없는 경우에는 Pod :: Checker)로 사용하여 지정된 포드의 오류를 확인할 수 있습니다. 파일.</target>
        </trans-unit>
        <trans-unit id="55e3a501ab6032afe89831dc532a3a24c547307d" translate="yes" xml:space="preserve">
          <source>This is a &quot;plug-in&quot; class that allows Perldoc to use Pod::Simple::RTF as a formatter class.</source>
          <target state="translated">이것은 Perldoc이 Pod :: Simple :: RTF를 포맷터 클래스로 사용할 수있게하는 &quot;플러그인&quot;클래스입니다.</target>
        </trans-unit>
        <trans-unit id="68678eb1c55adc089ba0d404634d06ee4b438a50" translate="yes" xml:space="preserve">
          <source>This is a &quot;plug-in&quot; class that allows Perldoc to use Pod::Simple::XMLOutStream as a formatter class.</source>
          <target state="translated">이것은 Perldoc이 Pod :: Simple :: XMLOutStream을 포맷터 클래스로 사용할 수있게하는 &quot;플러그인&quot;클래스입니다.</target>
        </trans-unit>
        <trans-unit id="e1aa800043dc8a94d0d283dacfd5ba2b12a78539" translate="yes" xml:space="preserve">
          <source>This is a &quot;plug-in&quot; class that allows Perldoc to use Pod::Text as a formatter class.</source>
          <target state="translated">이것은 Perldoc이 Pod :: Text를 포맷터 클래스로 사용할 수있게하는 &quot;플러그인&quot;클래스입니다.</target>
        </trans-unit>
        <trans-unit id="dddce66063ab47a1230107d6a866110ade33c3fe" translate="yes" xml:space="preserve">
          <source>This is a &quot;plug-in&quot; class that allows Perldoc to use Tk::Pod as a formatter class.</source>
          <target state="translated">이것은 Perldoc이 Tk :: Pod를 포맷터 클래스로 사용할 수있게하는 &quot;플러그인&quot;클래스입니다.</target>
        </trans-unit>
        <trans-unit id="4275fe3ef141a55b62b40502070bf737ec2ea8ca" translate="yes" xml:space="preserve">
          <source>This is a &quot;postponed&quot; regular subexpression. It behaves in</source>
          <target state="translated">&quot;지연된&quot;정규 하위 표현입니다. 그것은 행동</target>
        </trans-unit>
        <trans-unit id="a9ec1e3198488308c3643ad69f8d075d9b8f92de" translate="yes" xml:space="preserve">
          <source>This is a 'catch-all' method which returns true if any tests have currently failed, any TODO tests unexpectedly succeeded, or any parse errors occurred.</source>
          <target state="translated">테스트가 현재 실패했거나 TODO 테스트가 예기치 않게 성공했거나 구문 분석 오류가 발생한 경우 true를 리턴하는 'catch-all'메소드입니다.</target>
        </trans-unit>
        <trans-unit id="f9b6bdcb215a6cedd90d3fc776185364f2309aa9" translate="yes" xml:space="preserve">
          <source>This is a CPAN module that has better error handling and more facilities than Open3.</source>
          <target state="translated">이것은 Open3보다 더 나은 오류 처리 기능과 더 많은 기능을 가진 CPAN 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="b7d2a521ae98c293152277e05794dfa3dbb364fa" translate="yes" xml:space="preserve">
          <source>This is a Perl binding for the cross-platform wxWidgets toolkit ( &lt;a href=&quot;http://www.wxwidgets.org&quot;&gt;http://www.wxwidgets.org&lt;/a&gt; ). It works under Unix, Win32 and Mac OS X, using native widgets (Gtk under Unix). The interface follows the C++ interface closely, but the documentation is a little sparse for someone who doesn't know the library, mostly just referring you to the C++ documentation.</source>
          <target state="translated">이것은 크로스 플랫폼 wxWidgets 툴킷 ( &lt;a href=&quot;http://www.wxwidgets.org&quot;&gt;http://www.wxwidgets.org&lt;/a&gt; )에 대한 Perl 바인딩입니다 . 네이티브 위젯 (Unix에서 Gtk)을 사용하여 Unix, Win32 및 Mac OS X에서 작동합니다. 인터페이스는 C ++ 인터페이스를 밀접하게 따르지만 설명서는 라이브러리를 모르는 사람에게는 약간 희박합니다. 대부분 C ++ 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="64369b0966513691c61b8897fc5c7b37a7f32789" translate="yes" xml:space="preserve">
          <source>This is a big step forward, and can give a threaded program quite a performance boost over non-threaded programs. Threads that block performing I/O, for example, won't block threads that are doing other things. Each process still has only one thread running at once, though, regardless of how many CPUs a system might have.</source>
          <target state="translated">이것은 큰 발전이며, 스레드 프로그램이 스레드가 아닌 프로그램보다 성능을 크게 향상시킬 수 있습니다. 예를 들어 I / O 수행을 차단하는 스레드는 다른 작업을 수행하는 스레드를 차단하지 않습니다. 그러나 각 프로세스에는 시스템의 CPU 수에 관계없이 한 번에 하나의 스레드 만 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="e1c71251d2a2ccec8dd46781a0eb70dbaafe4b05" translate="yes" xml:space="preserve">
          <source>This is a bit tricky. You can't simply write the command like this:</source>
          <target state="translated">조금 까다 롭습니다. 다음과 같이 간단히 명령을 작성할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9d5816967d821cb6be38c83ea72dd77eb458d174" translate="yes" xml:space="preserve">
          <source>This is a case of convergent evolution with Joshua Pritikin's &lt;a href=&quot;../test&quot;&gt;Test&lt;/a&gt; module. I was largely unaware of its existence when I'd first written my own &lt;code&gt;ok()&lt;/code&gt; routines. This module exists because I can't figure out how to easily wedge test names into Test's interface (along with a few other problems).</source>
          <target state="translated">이것은 Joshua Pritikin의 &lt;a href=&quot;../test&quot;&gt;Test&lt;/a&gt; 모듈 과 함께 수렴 된 진화의 경우입니다 . 나는 내 자신의 &lt;code&gt;ok()&lt;/code&gt; 루틴을 처음 작성할 때 그 존재를 거의 알지 못했습니다 . 이 모듈은 테스트 이름을 Test 인터페이스에 쉽게 쐐기 화하는 방법을 알 수 없기 때문에 존재합니다 (몇 가지 다른 문제와 함께).</target>
        </trans-unit>
        <trans-unit id="97fc5a87a825ec27b25306a412b0a1048b673845" translate="yes" xml:space="preserve">
          <source>This is a class method that constructs a &lt;code&gt;Pod::InteriorSequence&lt;/code&gt; object and returns a reference to the new interior sequence object. It should be given two keyword arguments. The &lt;code&gt;-ldelim&lt;/code&gt; keyword indicates the corresponding left-delimiter of the interior sequence (e.g. '&amp;lt;'). The &lt;code&gt;-name&lt;/code&gt; keyword indicates the name of the corresponding interior sequence command, such as &lt;code&gt;I&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt; or &lt;code&gt;C&lt;/code&gt; . The &lt;code&gt;-file&lt;/code&gt; and &lt;code&gt;-line&lt;/code&gt; keywords indicate the filename and line number corresponding to the beginning of the interior sequence. If the &lt;code&gt;$ptree&lt;/code&gt; argument is given, it must be the last argument, and it must be either string, or else an array-ref suitable for passing to &lt;b&gt;Pod::ParseTree::new&lt;/b&gt; (or it may be a reference to a Pod::ParseTree object).</source>
          <target state="translated">이것은 &lt;code&gt;Pod::InteriorSequence&lt;/code&gt; 객체를 구성하고 새 내부 시퀀스 객체에 대한 참조를 반환 하는 클래스 메서드입니다 . 두 개의 키워드 인수가 제공되어야합니다. &lt;code&gt;-ldelim&lt;/code&gt; 키워드 내부 시퀀스의 대응하는 좌측 분리 (예 : '&amp;lt;')를 나타낸다. &lt;code&gt;-name&lt;/code&gt; 키워드 등 해당 내부 시퀀스 명령의 이름을 나타내는 &lt;code&gt;I&lt;/code&gt; 또는 &lt;code&gt;B&lt;/code&gt; 또는 &lt;code&gt;C&lt;/code&gt; 를 . &lt;code&gt;-file&lt;/code&gt; 와 &lt;code&gt;-line&lt;/code&gt; 키워드는 내부 시퀀스의 시작에 해당하는 파일 이름과 라인 수를 나타냅니다. 만약 &lt;code&gt;$ptree&lt;/code&gt; 인수가 주어지면 마지막 인수 여야하며 문자열이거나 &lt;b&gt;Pod :: ParseTree :: new&lt;/b&gt; 에 전달하기에 적합한 배열 참조 &lt;b&gt;여야합니다&lt;/b&gt; (또는 Pod :: ParseTree 객체에 대한 참조 일 수 있음). .</target>
        </trans-unit>
        <trans-unit id="29f55cb5b171aa91fa3174d7342b227ed1f417e9" translate="yes" xml:space="preserve">
          <source>This is a class method that constructs a &lt;code&gt;Pod::Paragraph&lt;/code&gt; object and returns a reference to the new paragraph object. It may be given one or two keyword arguments. The &lt;code&gt;-text&lt;/code&gt; keyword indicates the corresponding text of the POD paragraph. The &lt;code&gt;-name&lt;/code&gt; keyword indicates the name of the corresponding POD command, such as &lt;code&gt;head1&lt;/code&gt; or &lt;code&gt;item&lt;/code&gt; (it should</source>
          <target state="translated">이것은 &lt;code&gt;Pod::Paragraph&lt;/code&gt; 객체를 구성하고 새 단락 객체에 대한 참조를 반환 하는 클래스 메서드입니다 . 하나 또는 두 개의 키워드 인수가 제공 될 수 있습니다. &lt;code&gt;-text&lt;/code&gt; 키워드는 POD 단락의 해당 텍스트를 나타냅니다. &lt;code&gt;-name&lt;/code&gt; 키워드는 다음과 같은 해당 POD 명령의 이름을 나타냅니다 &lt;code&gt;head1&lt;/code&gt; 또는 &lt;code&gt;item&lt;/code&gt; 이해야한다 (</target>
        </trans-unit>
        <trans-unit id="331988b0033be159e38f1f3db9e7086fd5ac78d2" translate="yes" xml:space="preserve">
          <source>This is a class method that constructs a &lt;code&gt;Pod::Parse_tree&lt;/code&gt; object and returns a reference to the new parse-tree. If a single-argument is given, it must be a reference to an array, and is used to initialize the root (top) of the parse tree.</source>
          <target state="translated">이것은 &lt;code&gt;Pod::Parse_tree&lt;/code&gt; 객체를 생성하고 새로운 구문 분석 트리에 대한 참조를 반환 하는 클래스 메소드 입니다. 단일 인수가 제공되면 배열에 대한 참조 여야하며 구문 분석 트리의 루트 (상단)를 초기화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="135e61a3e6ed1b5dcdd255926dda22779c807d83" translate="yes" xml:space="preserve">
          <source>This is a classic race condition: you take two steps to do something which must be done in one. That's why computer hardware provides an atomic test-and-set instruction. In theory, this &quot;ought&quot; to work:</source>
          <target state="translated">이것은 고전적인 경쟁 조건입니다. 한 번에 수행해야하는 작업을 수행하려면 두 단계를 수행하십시오. 이것이 바로 컴퓨터 하드웨어가 원자 테스트 및 설정 명령을 제공하는 이유입니다. 이론적으로 이것은 &quot;작동해야한다&quot;:</target>
        </trans-unit>
        <trans-unit id="06ed0aa0bcc2d08b1ae41c2e1fbf2ac9199a80b7" translate="yes" xml:space="preserve">
          <source>This is a cleanup variable for try test programs. Internal Configure use only.</source>
          <target state="translated">시험 테스트 프로그램을위한 정리 변수입니다. 내부 구성 만 사용합니다.</target>
        </trans-unit>
        <trans-unit id="15d31d32837b2199fecd9abd8b0259d5c2027995" translate="yes" xml:space="preserve">
          <source>This is a collection of words of wisdom for a Perl porter; some of it is only useful to the pumpkin holder, but most of it applies to anyone wanting to go about Perl development.</source>
          <target state="translated">이것은 Perl 포터를위한 지혜의 단어 모음입니다. 일부는 호박 홀더에만 유용하지만 대부분 Perl 개발에 관심이있는 사람에게 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="78a03e08bc2123708a34ec2db4804cf0d2100751" translate="yes" xml:space="preserve">
          <source>This is a common error when trying to build perl on Solaris 2.6 with a gcc installation from Solaris 2.5 or 2.5.1. The Solaris header files changed, so you need to update your gcc installation. You can either rerun the fixincludes script from gcc or take the opportunity to update your gcc installation.</source>
          <target state="translated">Solaris 2.5 또는 2.5.1의 gcc 설치로 Solaris 2.6에서 perl을 빌드하려고 할 때 발생하는 일반적인 오류입니다. Solaris 헤더 파일이 변경되었으므로 gcc 설치를 업데이트해야합니다. gcc에서 fixincludes 스크립트를 다시 실행하거나 gcc 설치를 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff129a99820711b57abb25f1b58ba7136b7e8cde" translate="yes" xml:space="preserve">
          <source>This is a difficult question to answer, and the best answer is only a guess.</source>
          <target state="translated">이것은 대답하기 어려운 질문이며 최선의 대답은 추측 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="999f0dc4cf91e26f969aecc31f8b8b85ae8a6af3" translate="yes" xml:space="preserve">
          <source>This is a factory class that takes a &lt;a href=&quot;source&quot;&gt;TAP::Parser::Source&lt;/a&gt; and runs it through all the registered &lt;a href=&quot;sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;s to see which one should handle the source.</source>
          <target state="translated">이것은 &lt;a href=&quot;source&quot;&gt;TAP :: Parser :: Source를 가져&lt;/a&gt; 오고 등록 된 모든 &lt;a href=&quot;sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt; 를 통해 소스를 처리해야하는 팩토리 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="c43e76a8b7a7a6439251d5db4f28f61ba4f7ca79" translate="yes" xml:space="preserve">
          <source>This is a fancy bracketed character class that can be used for more readable and less error-prone classes, and to perform set operations, such as intersection. An example is</source>
          <target state="translated">이 클래스는보다 읽기 쉽고 오류가 적은 클래스에 사용하고 교차점과 같은 세트 작업을 수행하는 데 사용할 수있는 멋진 괄호 문자 클래스입니다. 예를 들면</target>
        </trans-unit>
        <trans-unit id="bd5b0b089eff91377cede66c47419fc9845c1784" translate="yes" xml:space="preserve">
          <source>This is a fixed variant of T_HVREF that decrements the refcount appropriately when returning an HV*. Introduced in perl 5.15.4.</source>
          <target state="translated">이것은 HV *를 반환 할 때 refcount를 적절하게 감소시키는 T_HVREF의 고정 변형입니다. perl 5.15.4에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="926e4c62112da36d18d2c1c89330bc60c9162eb2" translate="yes" xml:space="preserve">
          <source>This is a fully ported Perl for OS/390 Version 2 Release 3, 5, 6, 7, 8, and 9. It may work on other versions or releases, but those are the ones we've tested it on.</source>
          <target state="translated">OS / 390 버전 2 릴리스 3, 5, 6, 7, 8 및 9 용으로 완전히 포팅 된 Perl입니다. 다른 버전이나 릴리스에서는 작동하지만 테스트 한 버전입니다.</target>
        </trans-unit>
        <trans-unit id="372ffff7fde6d07d99e54e14755b9d58626070f2" translate="yes" xml:space="preserve">
          <source>This is a function which adds a string, &lt;code&gt;ptr&lt;/code&gt; , of length &lt;code&gt;len&lt;/code&gt; onto the end of the PV stored in &lt;code&gt;sv&lt;/code&gt; . The first thing we do in line 6 is make sure that the SV &lt;b&gt;has&lt;/b&gt; a valid PV, by calling the &lt;code&gt;SvPV_force&lt;/code&gt; macro to force a PV. As a side effect, &lt;code&gt;tlen&lt;/code&gt; gets set to the current value of the PV, and the PV itself is returned to &lt;code&gt;junk&lt;/code&gt; .</source>
          <target state="translated">이것은 &lt;code&gt;sv&lt;/code&gt; 에 저장된 PV의 끝에 &lt;code&gt;len&lt;/code&gt; 길이 의 문자열 &lt;code&gt;ptr&lt;/code&gt; 을 추가하는 함수입니다 . 6 행에서 가장 먼저해야 할 일은 &lt;code&gt;SvPV_force&lt;/code&gt; 매크로를 호출하여 PV를 강제 실행 하여 SV 에 유효한 PV &lt;b&gt;가&lt;/b&gt; 있는지 확인하는 것 입니다. 부작용으로 &lt;code&gt;tlen&lt;/code&gt; 은 PV의 현재 값으로 설정되고 PV 자체는 &lt;code&gt;junk&lt;/code&gt; 로 반환됩니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2774055b00e3419620eb5d95ca0978a88958d21c" translate="yes" xml:space="preserve">
          <source>This is a fundamental limitation of the way hashes are constructed in Perl. The error messages produced when this happens will often be quite cryptic -- in the worst case there may be none at all, and you'll only later find that something is broken.</source>
          <target state="translated">이것은 Perl에서 해시가 구성되는 방식의 근본적인 한계입니다. 이런 일이 발생했을 때 생성되는 오류 메시지는 종종 매우 비밀 스러울 것입니다. 최악의 경우 전혀 없을 수도 있으며 나중에 무언가가 깨 졌음을 알게 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="5634f9ec91b3e104474c739e05fd80458193ebf9" translate="yes" xml:space="preserve">
          <source>This is a get-or-set method for the compartment's operator mask.</source>
          <target state="translated">구획의 작업자 마스크에 대한 get-or-set 방법입니다.</target>
        </trans-unit>
        <trans-unit id="e894d85c5e9df5228e61b20283457ef4058bfbeb" translate="yes" xml:space="preserve">
          <source>This is a good introduction and will direct you towards other man pages that may interest you.</source>
          <target state="translated">이것은 좋은 소개이며 관심있는 다른 매뉴얼 페이지로 안내합니다.</target>
        </trans-unit>
        <trans-unit id="8c7d928409a2a83d36eb046953e31000e8fced30" translate="yes" xml:space="preserve">
          <source>This is a hash reference which contains a template as explained in the &lt;code&gt;SYNOPSIS&lt;/code&gt; and &lt;code&gt;Template&lt;/code&gt; section.</source>
          <target state="translated">이것은 &lt;code&gt;SYNOPSIS&lt;/code&gt; 및 &lt;code&gt;Template&lt;/code&gt; 섹션에 설명 된 템플릿을 포함하는 해시 참조입니다 .</target>
        </trans-unit>
        <trans-unit id="abdb64e67c36b80a4a66af77ecfc2b1aa4e68e20" translate="yes" xml:space="preserve">
          <source>This is a hash used internally to track named capture groups and their offsets. The keys are the names of the buffers the values are dualvars, with the IV slot holding the number of buffers with the given name and the pv being an embedded array of I32. The values may also be contained independently in the data array in cases where named backreferences are used.</source>
          <target state="translated">명명 된 캡처 그룹 및 해당 오프셋을 추적하기 위해 내부적으로 사용되는 해시입니다. 키는 값이 이중 변수 인 버퍼의 이름이며, IV 슬롯에는 지정된 이름의 버퍼 수가 있고 pv는 I32의 임베디드 배열입니다. 명명 된 역 참조가 사용되는 경우 데이터 배열에 값이 독립적으로 포함될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee128cd6218c9f00f0c878c04ed7c1d2ba1c0dcc" translate="yes" xml:space="preserve">
          <source>This is a hashref of module/version pairs. The version indicates the minimum version to load. If no version is provided, any version is assumed to be good enough.</source>
          <target state="translated">이것은 모듈 / 버전 쌍의 해시 참조입니다. 버전은로드 할 최소 버전을 나타냅니다. 버전이 제공되지 않으면 모든 버전이 충분하다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="ea245b58697360367e48479db117e287399d341e" translate="yes" xml:space="preserve">
          <source>This is a hashref registering what modules/utilities were known to fail for fetching files (mostly because they weren't installed).</source>
          <target state="translated">파일 가져 오기에 실패한 것으로 알려진 모듈 / 유틸리티를 등록하는 해시 참조입니다 (주로 설치되지 않았기 때문).</target>
        </trans-unit>
        <trans-unit id="9eb7a0a93db9a83c1c6303ceaf2e042280cc43c1" translate="yes" xml:space="preserve">
          <source>This is a list of questions and answers about Unicode in Perl, intended to be read after &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; 다음에 읽히 도록 의도 된 Perl의 유니 코드에 대한 질문 및 답변 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="36d9a4f8cf6a08db2c492aa7d56c16aa12a7c5d3" translate="yes" xml:space="preserve">
          <source>This is a little bit more complex in the case of UTF-8, see what &lt;code&gt;Perl_reg_numbered_buff_length&lt;/code&gt; does with &lt;a href=&quot;perlapi#is_utf8_string_loclen&quot;&gt;is_utf8_string_loclen&lt;/a&gt;.</source>
          <target state="translated">UTF-8의 경우 조금 더 복잡합니다 . &lt;code&gt;Perl_reg_numbered_buff_length&lt;/code&gt; 가 is_utf8_string_loclen으로 수행하는 &lt;a href=&quot;perlapi#is_utf8_string_loclen&quot;&gt;작업을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f2ee3c54bcb807a66fe7b80e3caf8861bbb44a5c" translate="yes" xml:space="preserve">
          <source>This is a message from your shell telling you that the command 'ar' was not found. You need to check your PATH environment variable to make sure that it includes the directory with the 'ar' command. This is a common problem on Solaris, where 'ar' is in the /usr/ccs/bin/ directory.</source>
          <target state="translated">셸에서 'ar'명령을 찾을 수 없다는 메시지입니다. PATH 환경 변수에 'ar'명령이있는 디렉토리가 포함되어 있는지 확인해야합니다. 이는 'ar'이 / usr / ccs / bin / 디렉토리에있는 Solaris의 일반적인 문제입니다.</target>
        </trans-unit>
        <trans-unit id="7be9582165bd5c245d33269d0775adef5b86c2d1" translate="yes" xml:space="preserve">
          <source>This is a misleadingly-named synonym for &lt;a href=&quot;#is_invariant_string&quot;&gt;is_invariant_string&lt;/a&gt;. On ASCII-ish platforms, the name isn't misleading: the ASCII-range characters are exactly the UTF-8 invariants. But EBCDIC machines have more invariants than just the ASCII characters, so &lt;code&gt;is_invariant_string&lt;/code&gt; is preferred.</source>
          <target state="translated">이것은 &lt;a href=&quot;#is_invariant_string&quot;&gt;is_invariant_string과 동일하게&lt;/a&gt; 잘못 명명 된 동의어입니다 . ASCII-ish 플랫폼에서 이름은 오해의 소지가 없습니다. ASCII 범위 문자는 정확히 UTF-8 불변입니다. 그러나 EBCDIC 시스템은 ASCII 문자보다 더 많은 불변을 가지므로 &lt;code&gt;is_invariant_string&lt;/code&gt; 이 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="de824f4204bca39b6173554bd682eeaf59e1fe59" translate="yes" xml:space="preserve">
          <source>This is a no-op on Win32.</source>
          <target state="translated">이것은 Win32에서 no-op입니다.</target>
        </trans-unit>
        <trans-unit id="7c97b390951ae9bd8a25bf05c714cdf4d686ebf3" translate="yes" xml:space="preserve">
          <source>This is a noop provided for completeness.</source>
          <target state="translated">완전성을 위해 제공되는 스눕입니다.</target>
        </trans-unit>
        <trans-unit id="09b98a2fdc86ae4c3444a314c0304e18f2968e2d" translate="yes" xml:space="preserve">
          <source>This is a placeholder option.</source>
          <target state="translated">자리 표시 자 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="309f4be6a68d1ca1ce9f563923f5229fee286990" translate="yes" xml:space="preserve">
          <source>This is a ported perl for the POSIX subsystem in BS2000 VERSION OSD V3.1A or later. It may work on other versions, but we started porting and testing it with 3.1A and are currently using Version V4.0A.</source>
          <target state="translated">이것은 BS2000 VERSION OSD V3.1A 이상의 POSIX 서브 시스템에 대한 포트 펄입니다. 다른 버전에서도 작동 할 수 있지만 3.1A로 포팅 및 테스트를 시작했으며 현재 버전 V4.0A를 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="639c8df7e83fc87480520c466044037ac91d5b6f" translate="yes" xml:space="preserve">
          <source>This is a protocol used by some firewall ftp proxies. It is used to authorise the user to send data out. If both arguments are not specified then &lt;code&gt;authorize&lt;/code&gt; uses &lt;code&gt;Net::Netrc&lt;/code&gt; to do a lookup.</source>
          <target state="translated">일부 방화벽 ftp 프록시에서 사용되는 프로토콜입니다. 사용자에게 데이터를 보내도록 권한을 부여하는 데 사용됩니다. 두 인수를 모두 지정하지 않으면 &lt;code&gt;authorize&lt;/code&gt; 는 &lt;code&gt;Net::Netrc&lt;/code&gt; 를 사용 하여 조회를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="35b9db060b8091b2af5afc80f2eb9e19755899c4" translate="yes" xml:space="preserve">
          <source>This is a quick reference to Perl's regular expressions. For full information see &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; and &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;, as well as the &lt;a href=&quot;#SEE-ALSO&quot;&gt;SEE ALSO&lt;/a&gt; section in this document.</source>
          <target state="translated">이것은 Perl의 정규 표현식에 대한 빠른 참조입니다. 자세한 내용은 &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; 및 &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 과이 문서 의 &lt;a href=&quot;#SEE-ALSO&quot;&gt;SEE ALSO&lt;/a&gt; 섹션을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="d47823b6d4d1bf90c0ec374b8fb409bfdb682e4b" translate="yes" xml:space="preserve">
          <source>This is a re-implementation of stdio-like buffering written as a PerlIO layer. As such it will call whatever layer is below it for its operations, typically &lt;code&gt;:unix&lt;/code&gt; .</source>
          <target state="translated">이것은 PerlIO 레이어로 작성된 stdio와 같은 버퍼링을 다시 구현 한 것입니다. 따라서 작업을 위해 아래에있는 모든 레이어, 일반적으로 &lt;code&gt;:unix&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="f72833b07fdaaa27353877ad8c40f0425a069181" translate="yes" xml:space="preserve">
          <source>This is a reference card for people who are familiar with the C library and who want to do things the Perl way; to tell them which functions they ought to use instead of the more normal C functions.</source>
          <target state="translated">이것은 C 라이브러리에 익숙하고 Perl 방식으로 일을하고 싶은 사람들을위한 참조 카드입니다. 더 일반적인 C 함수 대신 어떤 함수를 사용해야하는지 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="c471b4ac155563a00fba4ae9a0887cfc3abb5085" translate="yes" xml:space="preserve">
          <source>This is a reference to a hash of named arguments which need checking.</source>
          <target state="translated">이것은 검사가 필요한 명명 된 인수의 해시에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="3afd1b8fae5b72ccc5141dfe79c691921d5825d2" translate="yes" xml:space="preserve">
          <source>This is a replacement for an earlier Pod::Text module written by Tom Christiansen. It has a revamped interface, since it now uses Pod::Parser, but an interface roughly compatible with the old Pod::Text::pod2text() function is still available. Please change to the new calling convention, though.</source>
          <target state="translated">Tom Christiansen이 작성한 이전 포드 :: 텍스트 모듈을 대체합니다. 이제 Pod :: Parser를 사용하기 때문에 인터페이스가 개선되었지만 이전 Pod :: Text :: pod2text () 함수와 거의 호환되는 인터페이스를 계속 사용할 수 있습니다. 그래도 새로운 통화 규칙으로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="c47cbb12fb76c06a9104b6dcce71cb1371c44a36" translate="yes" xml:space="preserve">
          <source>This is a replacement for an earlier Pod::Text module written by Tom Christiansen. It has a revamped interface, since it now uses Pod::Simple, but an interface roughly compatible with the old Pod::Text::pod2text() function is still available. Please change to the new calling convention, though.</source>
          <target state="translated">Tom Christiansen이 작성한 이전 포드 :: 텍스트 모듈을 대체합니다. 이제 Pod :: Simple을 사용하므로 인터페이스가 개선되었지만 이전 Pod :: Text :: pod2text () 함수와 거의 호환되는 인터페이스를 계속 사용할 수 있습니다. 그래도 새로운 통화 규칙으로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="3b47b707c5aa2685e694887a6a732f13742fa45a" translate="yes" xml:space="preserve">
          <source>This is a runtime equivalent to &lt;code&gt;\N{...}&lt;/code&gt; .</source>
          <target state="translated">이것은 &lt;code&gt;\N{...}&lt;/code&gt; 해당하는 런타임 입니다.</target>
        </trans-unit>
        <trans-unit id="f7a879136a0009e169d98349a2353c9b002b70d9" translate="yes" xml:space="preserve">
          <source>This is a set of four-letter (capitalized) codes from ISO 15924 such as 'Phnx' for Phoenician. It also includes additions to this set included in the IANA language registry.</source>
          <target state="translated">페니키아 (Phoenician)의 경우 'Phnx'와 같은 ISO 15924의 4 자리 (자본) 코드 세트입니다. 또한 IANA 언어 레지스트리에 포함 된이 세트에 대한 추가 사항도 포함합니다.</target>
        </trans-unit>
        <trans-unit id="6ef813cd850a9f27ba1c4663d4e71f25b5053fb3" translate="yes" xml:space="preserve">
          <source>This is a set of three-digit numeric codes from ISO 15924 such as 115 for Phoenician.</source>
          <target state="translated">페니키아 (Phoenician)의 경우 115와 같은 ISO 15924의 3 자리 숫자 코드 세트입니다.</target>
        </trans-unit>
        <trans-unit id="349f283b1feb640d3ec35d62b03e25d6ddada207" translate="yes" xml:space="preserve">
          <source>This is a set of three-letter (uppercase) codes from ISO 4217 such as EUR for Euro.</source>
          <target state="translated">이것은 유로에 대한 EUR와 같은 ISO 4217의 3 문자 (대문자) 코드 세트입니다.</target>
        </trans-unit>
        <trans-unit id="6241a7679be2105aef445a1326e4d5af9e0ed08e" translate="yes" xml:space="preserve">
          <source>This is a short tutorial on writing a simple module with MakeMaker. It's really not that hard.</source>
          <target state="translated">MakeMaker로 간단한 모듈을 작성하는 방법에 대한 간단한 튜토리얼입니다. 정말 그렇게 어렵지 않습니다.</target>
        </trans-unit>
        <trans-unit id="53100bf0748f5ba489bc4dc460d2dfa8f3afc641" translate="yes" xml:space="preserve">
          <source>This is a short way of setting &lt;code&gt;gnu_compat&lt;/code&gt;&lt;code&gt;bundling&lt;/code&gt;&lt;code&gt;permute&lt;/code&gt;&lt;code&gt;no_getopt_compat&lt;/code&gt; . With &lt;code&gt;gnu_getopt&lt;/code&gt; , command line handling should be fully compatible with GNU getopt_long().</source>
          <target state="translated">이것은 &lt;code&gt;gnu_compat&lt;/code&gt; &lt;code&gt;bundling&lt;/code&gt; &lt;code&gt;permute&lt;/code&gt; &lt;code&gt;no_getopt_compat&lt;/code&gt; 를 설정하는 간단한 방법입니다 . &lt;code&gt;gnu_getopt&lt;/code&gt; 를 사용하면 명령 행 처리가 GNU getopt_long ()과 완전히 호환되어야합니다.</target>
        </trans-unit>
        <trans-unit id="7af9997becadfe87d824ab8762ffccd7719bb2b4" translate="yes" xml:space="preserve">
          <source>This is a shortcut for &lt;code&gt;$token-&amp;gt;type() eq &quot;end&quot;&lt;/code&gt;</source>
          <target state="translated">이것은 &lt;code&gt;$token-&amp;gt;type() eq &quot;end&quot;&lt;/code&gt; 의 지름길입니다.</target>
        </trans-unit>
        <trans-unit id="588934f1b5f409b7ed4ee0102675e3e7a80e417d" translate="yes" xml:space="preserve">
          <source>This is a shortcut for &lt;code&gt;$token-&amp;gt;type() eq &quot;start&quot;&lt;/code&gt;</source>
          <target state="translated">이것은 &lt;code&gt;$token-&amp;gt;type() eq &quot;start&quot;&lt;/code&gt; 의 지름길입니다.</target>
        </trans-unit>
        <trans-unit id="cf3172ad5af1d75bb916c8179d00c2eb32b1726b" translate="yes" xml:space="preserve">
          <source>This is a shortcut for &lt;code&gt;$token-&amp;gt;type() eq &quot;text&quot;&lt;/code&gt;</source>
          <target state="translated">이것은 &lt;code&gt;$token-&amp;gt;type() eq &quot;text&quot;&lt;/code&gt; 의 바로 가기입니다.</target>
        </trans-unit>
        <trans-unit id="14414929d404b298096e05330ae3a552582cc596" translate="yes" xml:space="preserve">
          <source>This is a shortcut method for creating a new parser object, setting the output handle to STDOUT, and then processing the specified file (or filehandle, or in-memory document). This is handy for one-liners like this:</source>
          <target state="translated">새 파서 객체를 생성하고 출력 핸들을 STDOUT으로 설정 한 다음 지정된 파일 (또는 파일 핸들 또는 인 메모리 문서)을 처리하는 바로 가기 방법입니다. 이것은 다음과 같이 한 줄짜리 사람에게 편리합니다.</target>
        </trans-unit>
        <trans-unit id="dcc6d2562c6f7206f328c3550bdc5e8e52460de3" translate="yes" xml:space="preserve">
          <source>This is a side-effect of &lt;code&gt;$^W&lt;/code&gt; being dynamically scoped.</source>
          <target state="translated">이것은 &lt;code&gt;$^W&lt;/code&gt; 가 동적으로 범위가 지정되는 부작용입니다 .</target>
        </trans-unit>
        <trans-unit id="8fa6df25c130c949bab77362ff50f938867d104d" translate="yes" xml:space="preserve">
          <source>This is a simple base class used by &lt;a href=&quot;../parser&quot;&gt;TAP::Parser&lt;/a&gt; to store objects that represent the current bit of test output data from TAP (usually a single line). Unless you're subclassing, you probably won't need to use this module directly.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;../parser&quot;&gt;TAP :: Parser&lt;/a&gt; 에서 TAP (일반적으로 한 줄)의 현재 테스트 출력 데이터 비트를 나타내는 개체를 저장 하는 데 사용하는 간단한 기본 클래스 입니다. 서브 클래 싱하지 않는 한이 모듈을 직접 사용할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="5a6a517a000eee7c9d8650e790b06bace86ece1d" translate="yes" xml:space="preserve">
          <source>This is a simple factory class which returns a &lt;a href=&quot;result&quot;&gt;TAP::Parser::Result&lt;/a&gt; subclass representing the current bit of test data from TAP (usually a single line). It is used primarily by &lt;a href=&quot;grammar&quot;&gt;TAP::Parser::Grammar&lt;/a&gt;. Unless you're subclassing, you probably won't need to use this module directly.</source>
          <target state="translated">&lt;a href=&quot;result&quot;&gt;TAP&lt;/a&gt; 에서 테스트 데이터의 현재 비트를 나타내는 TAP :: Parser :: Result 서브 클래스 (보통 단일 행) 를 리턴하는 간단한 팩토리 클래스입니다 . 주로 &lt;a href=&quot;grammar&quot;&gt;TAP :: Parser :: Grammar에&lt;/a&gt; 의해 사용됩니다 . 서브 클래 싱하지 않는 한이 모듈을 직접 사용할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="ae7e075e46130a389abcce2b8eca77b2b0799334" translate="yes" xml:space="preserve">
          <source>This is a simple iterator base class that defines &lt;a href=&quot;../parser&quot;&gt;TAP::Parser&lt;/a&gt;'s iterator API. Iterators are typically created from &lt;a href=&quot;sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;s.</source>
          <target state="translated">이것은 &lt;a href=&quot;../parser&quot;&gt;TAP :: Parser&lt;/a&gt; 의 반복자 API 를 정의하는 간단한 반복자 기본 클래스입니다 . 반복자는 일반적으로 &lt;a href=&quot;sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt; 에서 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="3ef2b28fd5eff705f1f406ac6e66e9bba64a8d81" translate="yes" xml:space="preserve">
          <source>This is a simple iterator wrapper for arrays of scalar content, used by &lt;a href=&quot;../../parser&quot;&gt;TAP::Parser&lt;/a&gt;. Unless you're writing a plugin or subclassing, you probably won't need to use this module directly.</source>
          <target state="translated">이것은 &lt;a href=&quot;../../parser&quot;&gt;TAP :: Parser에&lt;/a&gt; 의해 사용되는 스칼라 내용의 배열을위한 간단한 반복자 래퍼입니다 . 플러그인이나 서브 클래 싱을 작성하지 않는 한이 모듈을 직접 사용할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="6211175f40b02f3bcb25615dc63d424f5b04b85e" translate="yes" xml:space="preserve">
          <source>This is a simple iterator wrapper for executing external processes, used by &lt;a href=&quot;../../parser&quot;&gt;TAP::Parser&lt;/a&gt;. Unless you're writing a plugin or subclassing, you probably won't need to use this module directly.</source>
          <target state="translated">&lt;a href=&quot;../../parser&quot;&gt;TAP :: Parser가&lt;/a&gt; 사용하는 외부 프로세스를 실행하기위한 간단한 반복자 래퍼입니다 . 플러그인이나 서브 클래 싱을 작성하지 않는 한이 모듈을 직접 사용할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="08f74f820359ec13407ecd95ebc00861df2faa4a" translate="yes" xml:space="preserve">
          <source>This is a simple iterator wrapper for reading from filehandles, used by &lt;a href=&quot;../../parser&quot;&gt;TAP::Parser&lt;/a&gt;. Unless you're writing a plugin or subclassing, you probably won't need to use this module directly.</source>
          <target state="translated">이것은 &lt;a href=&quot;../../parser&quot;&gt;TAP :: Parser가&lt;/a&gt; 사용하는 파일 핸들에서 읽기위한 간단한 반복자 래퍼입니다 . 플러그인이나 서브 클래 싱을 작성하지 않는 한이 모듈을 직접 사용할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="fb6d528be7b9b50f443385c12d7c3581d3c5b271" translate="yes" xml:space="preserve">
          <source>This is a simple test harness which allows tests to be run and results automatically aggregated and output to STDOUT.</source>
          <target state="translated">이것은 테스트를 실행하고 결과를 자동으로 집계하여 STDOUT에 출력 할 수있는 간단한 테스트 하네스입니다.</target>
        </trans-unit>
        <trans-unit id="94c2e1c3d42721757938806d86cea256f2130297" translate="yes" xml:space="preserve">
          <source>This is a small simple module which simplifies the manipulation of @INC at compile time.</source>
          <target state="translated">이것은 컴파일 타임에 @INC의 조작을 단순화하는 작은 간단한 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="ed45414649005cf46b9b142e78787c7d0efdd654" translate="yes" xml:space="preserve">
          <source>This is a standard message issued by OS/2 applications. *nix applications die in silence. It is considered to be a feature. One can easily disable this by appropriate sighandlers.</source>
          <target state="translated">이것은 OS / 2 어플리케이션이 발행 한 표준 메시지입니다. * nix 애플리케이션은 조용히 죽습니다. 기능으로 간주됩니다. 적절한 sighandler에 의해이를 쉽게 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae30c10c2c1eb9a5c4373e69ebda02e4f56fd6ac" translate="yes" xml:space="preserve">
          <source>This is a static function and is defined as &lt;code&gt;STATIC S_whatever&lt;/code&gt; , and usually called within the sources as &lt;code&gt;whatever(...)&lt;/code&gt; .</source>
          <target state="translated">이것은 정적 함수이며 &lt;code&gt;STATIC S_whatever&lt;/code&gt; 로 정의되며 일반적으로 소스 내에서 &lt;code&gt;whatever(...)&lt;/code&gt; 로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="93db2ec99a46178540e6d933d3db3e813cba4109" translate="yes" xml:space="preserve">
          <source>This is a statically linked &lt;code&gt;a.out&lt;/code&gt; -style executable. It cannot load dynamic Perl extensions. The executable supplied in binary distributions has a lot of extensions prebuilt, thus the above restriction is important only if you use custom-built extensions. This executable is a VIO application.</source>
          <target state="translated">이것은 정적으로 링크 된 &lt;code&gt;a.out&lt;/code&gt; 스타일 실행 파일입니다. 동적 Perl 확장을로드 할 수 없습니다. 바이너리 배포판에 제공된 실행 파일에는 많은 확장이 사전 빌드되어 있으므로 사용자 정의 빌드 확장을 사용하는 경우에만 위의 제한 사항이 중요합니다. 이 실행 파일은 VIO 응용 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="fc094e72af8b9d6622201511120df9125d5e32ff" translate="yes" xml:space="preserve">
          <source>This is a string combining version, subversion and perl_patchlevel (if perl_patchlevel is non-zero). It is typically something like 'version 7 subversion 1' or 'version 7 subversion 1 patchlevel 11224' It is computed here to avoid duplication of code in</source>
          <target state="translated">버전, subversion 및 perl_patchlevel을 결합하는 문자열입니다 (perl_patchlevel이 0이 아닌 경우). 일반적으로 'version 7 subversion 1'또는 'version 7 subversion 1 patchlevel 11224'와 같습니다. 코드 중복을 피하기 위해 여기에서 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="344924719b1bae83eead5b685f2904260f7cb31e" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;../result&quot;&gt;TAP::Parser::Result&lt;/a&gt;. A token of this class will be returned if a YAML block is encountered.</source>
          <target state="translated">이것은 &lt;a href=&quot;../result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; 의 서브 클래스입니다 . YAML 블록이 발생하면이 클래스의 토큰이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cf06d3cd2a668f16a1a9ea1434ebed8459984ced" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;../result&quot;&gt;TAP::Parser::Result&lt;/a&gt;. A token of this class will be returned if a bail out line is encountered.</source>
          <target state="translated">이것은 &lt;a href=&quot;../result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; 의 서브 클래스입니다 . 이 클래스의 토큰은 구제 금융 라인이 발생하면 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1c79fb77a91aa29bad4fe0d58e746157c12b1af2" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;../result&quot;&gt;TAP::Parser::Result&lt;/a&gt;. A token of this class will be returned if a comment line is encountered.</source>
          <target state="translated">이것은 &lt;a href=&quot;../result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; 의 서브 클래스입니다 . 주석 행이 발견되면이 클래스의 토큰이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f5e73059f9980ac5f029fc80717ab9da6cff6341" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;../result&quot;&gt;TAP::Parser::Result&lt;/a&gt;. A token of this class will be returned if a plan line is encountered.</source>
          <target state="translated">이것은 &lt;a href=&quot;../result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; 의 서브 클래스입니다 . 계획 라인이 발견되면이 클래스의 토큰이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="dc05d4de16b8c5b025bf96846c216318ce2e7788" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;../result&quot;&gt;TAP::Parser::Result&lt;/a&gt;. A token of this class will be returned if a pragma is encountered.</source>
          <target state="translated">이것은 &lt;a href=&quot;../result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; 의 서브 클래스입니다 . pragma가 발생하면이 클래스의 토큰이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="173909c91c915dbe5ae4e1761f6ce3015f27ac8e" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;../result&quot;&gt;TAP::Parser::Result&lt;/a&gt;. A token of this class will be returned if a test line is encountered.</source>
          <target state="translated">이것은 &lt;a href=&quot;../result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; 의 서브 클래스입니다 . 테스트 라인이 발견되면이 클래스의 토큰이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d99a6f5c44525e8196b8a9f8f432a4c8297fe174" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;../result&quot;&gt;TAP::Parser::Result&lt;/a&gt;. A token of this class will be returned if a version line is encountered.</source>
          <target state="translated">이것은 &lt;a href=&quot;../result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; 의 서브 클래스입니다 . 버전 줄이 발견되면이 클래스의 토큰이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f9dc0dfab2b15f7dcded6106f389d289ed7b45a8" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;../result&quot;&gt;TAP::Parser::Result&lt;/a&gt;. A token of this class will be returned if the parser does not recognize the token line. For example:</source>
          <target state="translated">이것은 &lt;a href=&quot;../result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; 의 서브 클래스입니다 . 파서가 토큰 라인을 인식하지 못하면이 클래스의 토큰이 반환됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ed4cd1012a41fb5a1a7060605167f8be93252008" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;../simple&quot;&gt;Pod::Simple&lt;/a&gt; and inherits all its methods.</source>
          <target state="translated">이것은 &lt;a href=&quot;../simple&quot;&gt;Pod :: Simple&lt;/a&gt; 의 서브 클래스이며 모든 메소드를 상속합니다.</target>
        </trans-unit>
        <trans-unit id="81afca9fe5e8caf5fd548b6ee9f92134f9dc21dc" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;methody&quot;&gt;Pod::Simple::Methody&lt;/a&gt; and inherits all its methods. The implementation is entirely different than &lt;a href=&quot;html&quot;&gt;Pod::Simple::HTML&lt;/a&gt;, but it largely preserves the same interface.</source>
          <target state="translated">이것은 &lt;a href=&quot;methody&quot;&gt;Pod :: Simple :: Methody&lt;/a&gt; 의 서브 클래스이며 모든 메소드를 상속합니다. 구현은 &lt;a href=&quot;html&quot;&gt;Pod :: Simple :: HTML&lt;/a&gt; 과 완전히 다르지만 대부분 동일한 인터페이스를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="5a42087b4a78a20207066122ca4141600c24be72" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;pullparser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt; and inherits all its methods (and options).</source>
          <target state="translated">이것은 &lt;a href=&quot;pullparser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt; 의 서브 클래스이며 모든 메소드와 옵션을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="ea32c34eae791ae221ac4a3cce2869532666d30e" translate="yes" xml:space="preserve">
          <source>This is a subclass of &lt;a href=&quot;pullparsertoken&quot;&gt;Pod::Simple::PullParserToken&lt;/a&gt; and inherits all its methods, and adds these methods:</source>
          <target state="translated">이것은 &lt;a href=&quot;pullparsertoken&quot;&gt;Pod :: Simple :: PullParserToken&lt;/a&gt; 의 서브 클래스이며 모든 메소드를 상속하며 다음 메소드를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="aa9cce04d90d56b725964eab73e0fca5ac743d29" translate="yes" xml:space="preserve">
          <source>This is a subclass of ExtUtils::MM_Unix which contains functionality for AIX.</source>
          <target state="translated">이것은 AIX 기능을 포함하는 ExtUtils :: MM_Unix의 서브 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="0d4a1a4cfdafa1cb09a4fb89fe42af2c7616286a" translate="yes" xml:space="preserve">
          <source>This is a subclass of ExtUtils::MM_Unix which contains functionality for DOS.</source>
          <target state="translated">이것은 ExtUtils :: MM_Unix의 서브 클래스이며 DOS 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1586bedfb51abdc0ca225f9c3db5c388bf3fe7c7" translate="yes" xml:space="preserve">
          <source>This is a subclass of ExtUtils::MM_Unix which contains functionality for QNX.</source>
          <target state="translated">이것은 QNX 기능을 포함하는 ExtUtils :: MM_Unix의 서브 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="c6edbaa56530abda8144785f91c81fc02ebf9b90" translate="yes" xml:space="preserve">
          <source>This is a subclass of ExtUtils::MM_Unix which contains functionality for VOS.</source>
          <target state="translated">이것은 VOS 용 기능을 포함하는 ExtUtils :: MM_Unix의 서브 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="2e5c7251645932dc8d1dc7c962cbf2e45c3f4094" translate="yes" xml:space="preserve">
          <source>This is a subclass of ExtUtils::MM_Unix which contains functionality for the AT&amp;amp;T U/WIN UNIX on Windows environment.</source>
          <target state="translated">이것은 ExtUtils :: MM_Unix의 서브 클래스이며 Windows 환경의 AT &amp;amp; T U / WIN UNIX에 대한 기능을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="93a42e55d1097c11d0072e86d7f542b3230e6bcf" translate="yes" xml:space="preserve">
          <source>This is a subclass of ExtUtils::MM_Win32 containing changes necessary to get MakeMaker playing nice with command.com and other Win9Xisms.</source>
          <target state="translated">이것은 ExtUtils :: MM_Win32의 서브 클래스로, makeMaker가 command.com 및 기타 Win9Xism과 잘 작동하는 데 필요한 변경 사항을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="fb8a82ae7e4bcc23be8b85858941e5009748ca04" translate="yes" xml:space="preserve">
          <source>This is a suggestion to the OS to let this thread yield CPU time to other threads. What actually happens is highly dependent upon the underlying thread implementation.</source>
          <target state="translated">이것은이 스레드가 다른 스레드에 CPU 시간을 양보하도록 OS에 대한 제안입니다. 실제로 발생하는 것은 기본 스레드 구현에 따라 크게 달라집니다.</target>
        </trans-unit>
        <trans-unit id="a6edb8217d2751ef4a763256a458a4449c4b36b5" translate="yes" xml:space="preserve">
          <source>This is a superclass for &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt;-based modules. It provides a handful of common functionality and a method of getting at the underlying &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; object.</source>
          <target state="translated">이것은 &lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt; 기반 모듈 의 수퍼 클래스입니다 . 몇 가지 일반적인 기능과 기본 &lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt; 객체 를 얻는 방법을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="55903e986f0ab6ec743472dc06cf20bffa759a05" translate="yes" xml:space="preserve">
          <source>This is a synonym for (! foldEQ())</source>
          <target state="translated">이것은 (! foldEQ ())의 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="53444e6b25598bcd7a21f4559d1c88a0a3357fc9" translate="yes" xml:space="preserve">
          <source>This is a synonym for (! foldEQ_locale())</source>
          <target state="translated">이것은 (! foldEQ_locale ())의 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="0fc9211f34524643d77b88ccf3fbe69c0926ca68" translate="yes" xml:space="preserve">
          <source>This is a synonym for &lt;code&gt;\p{Present_In=*}&lt;/code&gt;</source>
          <target state="translated">이것은 &lt;code&gt;\p{Present_In=*}&lt;/code&gt; 의 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="ef2cd0a3571852b5da355e5994ba81184e031c06" translate="yes" xml:space="preserve">
          <source>This is a template for a function suitable for the &lt;code&gt;uf_val&lt;/code&gt; field in a &lt;code&gt;ufuncs&lt;/code&gt; structure for this call. The &lt;code&gt;uf_set&lt;/code&gt; and &lt;code&gt;uf_index&lt;/code&gt; fields are irrelevant.</source>
          <target state="translated">이 호출 에 대한 &lt;code&gt;ufuncs&lt;/code&gt; 구조 의 &lt;code&gt;uf_val&lt;/code&gt; 필드에 적합한 함수의 템플리트입니다 . &lt;code&gt;uf_set&lt;/code&gt; 및 &lt;code&gt;uf_index&lt;/code&gt; 필드는 무관하다.</target>
        </trans-unit>
        <trans-unit id="9a3d72bf731a4c00183b3bacd2aaed590afe1490" translate="yes" xml:space="preserve">
          <source>This is a term used for characters occupying more than one byte.</source>
          <target state="translated">이것은 2 바이트 이상을 차지하는 문자에 사용되는 용어입니다.</target>
        </trans-unit>
        <trans-unit id="da67b166e535d5aab2dfd4a4bef7fa2c7dc18440" translate="yes" xml:space="preserve">
          <source>This is a useful alternative to the &lt;code&gt;verbose&lt;/code&gt; key.</source>
          <target state="translated">이것은 &lt;code&gt;verbose&lt;/code&gt; 키에 대한 유용한 대안 입니다.</target>
        </trans-unit>
        <trans-unit id="618f9f0ef250e390bb1ce0844593906ed698aa6a" translate="yes" xml:space="preserve">
          <source>This is a user-pragma. If you're very lucky some code you're using will know that you asked for less CPU usage or ram or fat or... we just can't know. Consult your documentation on everything you're currently using.</source>
          <target state="translated">이것은 사용자 프 래그 마입니다. 운이 좋으면 사용중인 코드 중 CPU 사용량이나 램 또는 지방을 적게 요청했음을 알 수 있습니다 ... 우리는 알 수 없습니다. 현재 사용중인 모든 것에 대한 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e65d4664502f4836edff6c3f42d466dce62c114e" translate="yes" xml:space="preserve">
          <source>This is achieved by creating separate watchdog process which spawns the specified program in a separate process session and supervises it: optionally feeds it with input, stores its exit code, stdout and stderr, terminates it in case it runs longer than specified.</source>
          <target state="translated">이는 별도의 프로세스 세션에서 지정된 프로그램을 생성하고이를 감시하는 별도의 감시 프로세스를 생성하여 수행됩니다. 선택적으로 입력을 통해 피드를 제공하고 종료 코드, stdout 및 stderr을 저장하고 지정된 것보다 오래 실행될 경우 종료합니다.</target>
        </trans-unit>
        <trans-unit id="bb7efcdf0700fbaadbdc0f648a8badbdf9664612" translate="yes" xml:space="preserve">
          <source>This is actually a Pod::Simple::Checker (or Pod::Checker) subclass, and inherits all its options.</source>
          <target state="translated">이것은 실제로 Pod :: Simple :: Checker (또는 Pod :: Checker) 서브 클래스이며 모든 옵션을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="e4a943560ee56b7076fa64d64bd3da44e85a30ca" translate="yes" xml:space="preserve">
          <source>This is actually a Pod::Simple::RTF subclass, and inherits all its options.</source>
          <target state="translated">이것은 실제로 Pod :: Simple :: RTF 서브 클래스이며 모든 옵션을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="92b8d72a94a8da6c54d9f33ab092eb620ca878de" translate="yes" xml:space="preserve">
          <source>This is actually a Pod::Simple::XMLOutStream subclass, and inherits all its options.</source>
          <target state="translated">이것은 실제로 Pod :: Simple :: XMLOutStream 서브 클래스이며 모든 옵션을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="8eda3362231deb25dfd89db58202611c06a3d40c" translate="yes" xml:space="preserve">
          <source>This is all very powerful, of course, and should be used only in moderation to make the world a better place.</source>
          <target state="translated">물론 이것은 매우 강력하며 세상을 더 나은 곳으로 만들기 위해 적당히 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="a0a76465b05604833b1a2e0c25409dcb3ddad85c" translate="yes" xml:space="preserve">
          <source>This is also a no-op on Win32.</source>
          <target state="translated">이것은 또한 Win32에서 no-op입니다.</target>
        </trans-unit>
        <trans-unit id="a906c4fc08f6c0cd00609aae3ea9167c7850d130" translate="yes" xml:space="preserve">
          <source>This is also helpful for the case where a package lives within a differently named file:</source>
          <target state="translated">패키지가 다른 이름의 파일 내에있는 경우에도 유용합니다.</target>
        </trans-unit>
        <trans-unit id="783e4cc092057905b6553d7a8d798ecf7ac0db31" translate="yes" xml:space="preserve">
          <source>This is also invalid:</source>
          <target state="translated">이것은 또한 유효하지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="c1d7e1e2839d2377297de367eca0902f0ba00891" translate="yes" xml:space="preserve">
          <source>This is also the logical inverse of Perl_isfinite().</source>
          <target state="translated">이것은 또한 Perl_isfinite ()의 논리적 역수입니다.</target>
        </trans-unit>
        <trans-unit id="c778320b203a5e38261d5a20fb7ed1b70340a749" translate="yes" xml:space="preserve">
          <source>This is also used to store the name of an autoloaded subroutine in an XS AUTOLOAD routine. See &lt;a href=&quot;perlguts#Autoloading-with-XSUBs&quot;&gt;Autoloading with XSUBs in perlguts&lt;/a&gt;.</source>
          <target state="translated">XS AUTOLOAD 루틴에서 자동로드 서브 루틴의 이름을 저장하는 데에도 사용됩니다. &lt;a href=&quot;perlguts#Autoloading-with-XSUBs&quot;&gt;perlguts에서 XSUB로 자동로드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6dda58eafcf63f43293998602056ada9565deb26" translate="yes" xml:space="preserve">
          <source>This is also useful for applications emulating &lt;code&gt;tail -f&lt;/code&gt; . Once you hit EOF on your read and then sleep for a while, you (probably) have to stick in a dummy seek() to reset things. The &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; doesn't change the position, but it</source>
          <target state="translated">또한 &lt;code&gt;tail -f&lt;/code&gt; 를 에뮬레이트하는 응용 프로그램에도 유용합니다 . 읽기에서 EOF를 누른 다음 잠시 잠을 자면 (아마) 더미 seek ()를 사용하여 재설정해야합니다. 가 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 위치를 변경하지 않지만, 그것을</target>
        </trans-unit>
        <trans-unit id="545e9279207dbe359d514df130705d9c342445f3" translate="yes" xml:space="preserve">
          <source>This is also useful for applications emulating &lt;code&gt;tail -f&lt;/code&gt; . Once you hit EOF on your read and then sleep for a while, you (probably) have to stick in a dummy seek() to reset things. The &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; doesn't change the position, but it</source>
          <target state="translated">또한 &lt;code&gt;tail -f&lt;/code&gt; 를 에뮬레이트하는 응용 프로그램에도 유용합니다 . 읽기에서 EOF를 누른 다음 잠시 잠을 자면 (아마) 더미 seek ()를 사용하여 재설정해야합니다. 가 &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 위치를 변경하지 않지만, 그것을</target>
        </trans-unit>
        <trans-unit id="3a6f47fb722d0ea7678e717327e932adc89f5068" translate="yes" xml:space="preserve">
          <source>This is an &lt;code&gt;omf&lt;/code&gt; -style executable which is dynamically linked to</source>
          <target state="translated">이것은 동적으로 연결된 &lt;code&gt;omf&lt;/code&gt; 스타일 실행 파일입니다.</target>
        </trans-unit>
        <trans-unit id="8d756c24376672373a010de25a2097378db4129a" translate="yes" xml:space="preserve">
          <source>This is an XS interface to Perl's &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">이것은 Perl의 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 기능에 대한 XS 인터페이스 입니다.</target>
        </trans-unit>
        <trans-unit id="af496b01592b41744cf75154ff216cf0d89995f5" translate="yes" xml:space="preserve">
          <source>This is an XS interface to Perl's &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">이것은 Perl의 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; 기능에 대한 XS 인터페이스 입니다.</target>
        </trans-unit>
        <trans-unit id="3e6cd5c9b47acd371c49a0cb03b008b70d97eb82" translate="yes" xml:space="preserve">
          <source>This is an advisory and may not be called in the case where tests are being supplied to Test::Harness by an iterator.</source>
          <target state="translated">이것은 권고이며 반복자에 의해 Test :: Harness에 테스트가 제공되는 경우에는 호출되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e308dd432d69b5157566a6a8a06cea4450cd898c" translate="yes" xml:space="preserve">
          <source>This is an architecture-independent macro to copy one structure to another.</source>
          <target state="translated">하나의 구조를 다른 구조로 복사하기위한 아키텍처 독립적 매크로입니다.</target>
        </trans-unit>
        <trans-unit id="142891d3e046c25d09b04f0976a954076a30931f" translate="yes" xml:space="preserve">
          <source>This is an array ref holding blacklisted modules/utilities for fetching files with.</source>
          <target state="translated">이것은 파일을 가져 오기위한 블랙리스트 모듈 / 유틸리티를 보유하는 배열 참조입니다.</target>
        </trans-unit>
        <trans-unit id="df12371f4d4ec63415fcab8f4e275a767f08fe3d" translate="yes" xml:space="preserve">
          <source>This is an array reference containing all the output sent to STDOUT the command generated. The notes from &lt;a href=&quot;#full_buffer&quot;&gt;full_buffer&lt;/a&gt; apply.</source>
          <target state="translated">이것은 생성 된 명령으로 STDOUT에 전송 된 모든 출력을 포함하는 배열 참조입니다. &lt;a href=&quot;#full_buffer&quot;&gt;full_buffer&lt;/a&gt; 의 메모가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="5d8a9ac748db8e604ab1a3be03c2cd4ff11d70fa" translate="yes" xml:space="preserve">
          <source>This is an array reference containing all the output the command generated. Note that buffers are only available if you have &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::Run&quot;&gt;IPC::Run&lt;/a&gt; installed, or if your system is able to work with &lt;a href=&quot;open3&quot;&gt;IPC::Open3&lt;/a&gt; -- see below). Otherwise, this element will be &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">명령이 생성 한 모든 출력을 포함하는 배열 참조입니다. 버퍼는 &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::Run&quot;&gt;IPC :: Run이&lt;/a&gt; 설치되어 있거나 시스템이 &lt;a href=&quot;open3&quot;&gt;IPC :: Open3&lt;/a&gt; 에서 작동 할 수 있는 경우에만 사용할 수 있습니다 (아래 참조). 그렇지 않으면이 요소는 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c18758c49f12c582c5080bf3c3ccaff6f97f99da" translate="yes" xml:space="preserve">
          <source>This is an arrayreference containing all the output sent to STDERR the command generated. The notes from &lt;a href=&quot;#full_buffer&quot;&gt;full_buffer&lt;/a&gt; apply.</source>
          <target state="translated">이것은 명령이 생성 한 STDERR에 전송 된 모든 출력을 포함하는 배열 참조입니다. &lt;a href=&quot;#full_buffer&quot;&gt;full_buffer&lt;/a&gt; 의 메모가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="35261ed11f8f6da05d71e00af479e064b704d1d3" translate="yes" xml:space="preserve">
          <source>This is an error because the region is opened by &quot;thing&quot;, and the &quot;=end&quot; tries to close &quot;hting&quot; [sic].</source>
          <target state="translated">&quot;thing&quot;에 의해 영역이 열리고 &quot;= end&quot;가 &quot;hting&quot;[sic]을 닫으려고하기 때문에 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b79a05e5e946ef4d9b0147040712489ddfe70bec" translate="yes" xml:space="preserve">
          <source>This is an experimental feature and the interface may change.</source>
          <target state="translated">이것은 실험적인 기능이며 인터페이스가 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="038057198b05cf435f922989a902c34a0ad8bec5" translate="yes" xml:space="preserve">
          <source>This is an experimental feature available starting in 5.18, and is subject to change as we gain field experience with it. Any attempt to use it will raise a warning, unless disabled via</source>
          <target state="translated">이것은 5.18부터 사용할 수있는 실험적인 기능으로 현장 경험을 쌓으면 변경 될 수 있습니다. 사용하지 않으면 경고 메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="52d334621bd62974acc022322ae25fb3c75cd6d1" translate="yes" xml:space="preserve">
          <source>This is an extremely simple, extremely basic module for writing tests suitable for CPAN modules and other pursuits. If you wish to do more complicated testing, use the Test::More module (a drop-in replacement for this one).</source>
          <target state="translated">CPAN 모듈 및 기타 목적에 적합한 테스트 작성을위한 매우 단순하고 매우 기본적인 모듈입니다. 보다 복잡한 테스트를 수행하려면 Test :: More 모듈 (이 모듈을 대체하는 대체품)을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fc193a250bf3f7bae0644ab68952c14087e27f56" translate="yes" xml:space="preserve">
          <source>This is an internal function used by &lt;code&gt;&lt;a href=&quot;format&quot;&gt;format&lt;/a&gt;&lt;/code&gt;s, though you may call it, too. It formats (see &lt;a href=&quot;../perlform&quot;&gt;perlform&lt;/a&gt;) a list of values according to the contents of PICTURE, placing the output into the format output accumulator, &lt;code&gt;$^A&lt;/code&gt; (or &lt;code&gt;$ACCUMULATOR&lt;/code&gt; in English). Eventually, when a &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; is done, the contents of &lt;code&gt;$^A&lt;/code&gt; are written to some filehandle. You could also read &lt;code&gt;$^A&lt;/code&gt; and then set &lt;code&gt;$^A&lt;/code&gt; back to &lt;code&gt;&quot;&quot;&lt;/code&gt; . Note that a format typically does one &lt;code&gt;&lt;a href=&quot;formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; per line of form, but the &lt;code&gt;&lt;a href=&quot;formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; function itself doesn't care how many newlines are embedded in the PICTURE. This means that the &lt;code&gt;~&lt;/code&gt; and &lt;code&gt;~~&lt;/code&gt; tokens treat the entire PICTURE as a single line. You may therefore need to use multiple formlines to implement a single record format, just like the &lt;code&gt;&lt;a href=&quot;format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; compiler.</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; s에서 사용하는 내부 함수 이지만 호출 할 수도 있습니다. PICTURE의 내용에 따라 값 목록을 형식화하고 ( &lt;a href=&quot;../perlform&quot;&gt;perlform&lt;/a&gt; 참조 ) 출력을 형식 출력 누산기 &lt;code&gt;$^A&lt;/code&gt; (또는 영어의 &lt;code&gt;$ACCUMULATOR&lt;/code&gt; )에 배치합니다. 결국, &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 가 완료되면 &lt;code&gt;$^A&lt;/code&gt; 의 내용이 일부 파일 핸들에 기록됩니다. &lt;code&gt;$^A&lt;/code&gt; 읽은 다음 &lt;code&gt;$^A&lt;/code&gt; 를 &lt;code&gt;&quot;&quot;&lt;/code&gt; 로 다시 설정할 수도 있습니다 . 주 형식은 일반적으로 일한다는 것을 &lt;code&gt;&lt;a href=&quot;formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; 형태의 라인 당하지만 &lt;code&gt;&lt;a href=&quot;formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; 을함수 자체는 얼마나 많은 줄 바꿈이 PICTURE에 포함되어 있는지 상관하지 않습니다. 이것은 &lt;code&gt;~&lt;/code&gt; 및 &lt;code&gt;~~&lt;/code&gt; 토큰이 전체 PICTURE를 한 줄로 취급 한다는 것을 의미합니다 . 따라서 &lt;code&gt;&lt;a href=&quot;format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; 컴파일러 와 마찬가지로 단일 레코드 형식을 구현하기 위해 여러 양식을 사용해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cd310f7276a510d01ce03cf67c2975df5756cafc" translate="yes" xml:space="preserve">
          <source>This is an internal function used by &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt;s, though you may call it, too. It formats (see &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt;) a list of values according to the contents of PICTURE, placing the output into the format output accumulator, &lt;code&gt;$^A&lt;/code&gt; (or &lt;code&gt;$ACCUMULATOR&lt;/code&gt; in English). Eventually, when a &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; is done, the contents of &lt;code&gt;$^A&lt;/code&gt; are written to some filehandle. You could also read &lt;code&gt;$^A&lt;/code&gt; and then set &lt;code&gt;$^A&lt;/code&gt; back to &lt;code&gt;&quot;&quot;&lt;/code&gt; . Note that a format typically does one &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; per line of form, but the &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; function itself doesn't care how many newlines are embedded in the PICTURE. This means that the &lt;code&gt;~&lt;/code&gt; and &lt;code&gt;~~&lt;/code&gt; tokens treat the entire PICTURE as a single line. You may therefore need to use multiple formlines to implement a single record format, just like the &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; compiler.</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; s에서 사용하는 내부 함수 이지만 호출 할 수도 있습니다. PICTURE의 내용에 따라 값 목록을 형식화하고 ( &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; 참조 ) 출력을 형식 출력 누산기 &lt;code&gt;$^A&lt;/code&gt; (또는 영어의 &lt;code&gt;$ACCUMULATOR&lt;/code&gt; )에 배치합니다. 결국, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 가 완료되면 &lt;code&gt;$^A&lt;/code&gt; 의 내용이 일부 파일 핸들에 기록됩니다. &lt;code&gt;$^A&lt;/code&gt; 읽은 다음 &lt;code&gt;$^A&lt;/code&gt; 를 &lt;code&gt;&quot;&quot;&lt;/code&gt; 로 다시 설정할 수도 있습니다 . 주 형식은 일반적으로 일한다는 것을 &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; 형태의 라인 당하지만 &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; 을함수 자체는 얼마나 많은 줄 바꿈이 PICTURE에 포함되어 있는지 상관하지 않습니다. 이것은 &lt;code&gt;~&lt;/code&gt; 및 &lt;code&gt;~~&lt;/code&gt; 토큰이 전체 PICTURE를 한 줄로 취급 한다는 것을 의미합니다 . 따라서 &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; 컴파일러 와 마찬가지로 단일 레코드 형식을 구현하기 위해 여러 양식을 사용해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="10fae8cad46b6999dd334a3e0cee274316414176" translate="yes" xml:space="preserve">
          <source>This is an internal module for controlling the debug level (a.k.a. trace level) of Pod::Simple. This is of interest only to Pod::Simple developers.</source>
          <target state="translated">Pod :: Simple의 디버그 수준 (일명 추적 수준)을 제어하기위한 내부 모듈입니다. 이것은 Pod :: Simple 개발자에게만 관심이 있습니다.</target>
        </trans-unit>
        <trans-unit id="91ad54ddf5b339889a4d7e36baa90c6c5e3e7226" translate="yes" xml:space="preserve">
          <source>This is an internal routine that turns scalars into objects.</source>
          <target state="translated">이것은 스칼라를 객체로 바꾸는 내부 루틴입니다.</target>
        </trans-unit>
        <trans-unit id="8cdba91d1ae6fc951cd637b385ae75d511979603" translate="yes" xml:space="preserve">
          <source>This is an introduction to the use of performance and optimization techniques which can be used with particular reference to perl programs. While many perl developers have come from other languages, and can use their prior knowledge where appropriate, there are many other people who might benefit from a few perl specific pointers. If you want the condensed version, perhaps the best advice comes from the renowned Japanese Samurai, Miyamoto Musashi, who said:</source>
          <target state="translated">이것은 perl 프로그램을 특별히 참조하여 사용할 수있는 성능 및 최적화 기술 사용에 대한 소개입니다. 많은 perl 개발자들이 다른 언어에서 왔으며 적절한 경우 사전 지식을 사용할 수 있지만 perl 특정 포인터로 혜택을 볼 수있는 다른 사람들이 많이 있습니다. 압축 버전을 원한다면 가장 유명한 조언은 유명한 일본 사무라이 미야모토 무사시 (Miyamoto Musashi)의 조언입니다.</target>
        </trans-unit>
        <trans-unit id="1366a76cfef4230c6beae74ce2285fa6d6be94b2" translate="yes" xml:space="preserve">
          <source>This is an old synonym for _a.</source>
          <target state="translated">이것은 _a의 오래된 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="18fb271daf0d1e76d3278d9f0bd4670eecfaa747" translate="yes" xml:space="preserve">
          <source>This is an old synonym for _exe.</source>
          <target state="translated">이것은 _exe의 오래된 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="e951b381a4c4d96fa5592d033afe7d8fa718b152" translate="yes" xml:space="preserve">
          <source>This is an old synonym for _o.</source>
          <target state="translated">이것은 _o의 오래된 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="cb104080e92edd7dc3925f96e9fda2c7d309ad5a" translate="yes" xml:space="preserve">
          <source>This is an old synonym for p_ in</source>
          <target state="translated">이것은 p_에 대한 오래된 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="f5d749cd3a1da6fa9f5e91de2edcf596acd57750" translate="yes" xml:space="preserve">
          <source>This is an upper limit on the amount of memory that &lt;code&gt;Tie::File&lt;/code&gt; will consume at any time while managing the file. This is used for two things: managing the</source>
          <target state="translated">이것은 &lt;code&gt;Tie::File&lt;/code&gt; 이 파일 을 관리하는 동안 언제든지 사용하는 메모리 양의 상한입니다 . 이것은 두 가지 용도로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="50601fd9eec31dfdb13471caa9bb11bc5c6a291d" translate="yes" xml:space="preserve">
          <source>This is another step where the presence of the &lt;code&gt;/x&lt;/code&gt; modifier is relevant. The RE engine scans the string from left to right and converts it into a finite automaton.</source>
          <target state="translated">이것은 &lt;code&gt;/x&lt;/code&gt; 수정 자의 존재와 관련된 또 다른 단계 입니다. RE 엔진은 문자열을 왼쪽에서 오른쪽으로 스캔하여 유한 오토 마톤으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="6bc6e3e8d1b2d61b10ef0d4362b29339c92de71f" translate="yes" xml:space="preserve">
          <source>This is bad because splice is already O(N), and since you do it N times, you just invented a quadratic algorithm; that is, O(N**2). This does not scale, although Perl is so efficient that you probably won't notice this until you have rather largish arrays.</source>
          <target state="translated">스플 라이스는 이미 O (N)이기 때문에 나쁘고 N 번 수행하기 때문에 2 차 알고리즘을 발명했습니다. 즉, O (N ** 2)입니다. Perl이 너무 효율적이기 때문에 확장 성이 떨어지지 만 배열이 다소 지연 될 때까지이를 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3c8339d12c8a36725299f222df00f24cfd8f69bf" translate="yes" xml:space="preserve">
          <source>This is basically shorthand for saying:</source>
          <target state="translated">이것은 기본적으로 다음과 같이 말합니다.</target>
        </trans-unit>
        <trans-unit id="df105f720cfd558cf78bf5414610fa1937dfed89" translate="yes" xml:space="preserve">
          <source>This is because math with overloaded operators follows the first (dominating) operand, and the operation of that is called and returns thus the result. So, Math::BigInt::bdiv() will always return a Math::BigInt, regardless whether the result should be a Math::BigFloat or the second operant is one.</source>
          <target state="translated">오버로드 된 연산자가있는 수학은 첫 번째 (주요) 피연산자를 따르고 그 연산이 호출되어 결과를 반환하기 때문입니다. 따라서 Math :: BigInt :: bdiv ()는 결과가 Math :: BigFloat 여야하는지 아니면 두 번째 피연산자가 1인지에 관계없이 항상 Math :: BigInt를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9d0c7a7cdf189de0cf4679b172df320157dc1c04" translate="yes" xml:space="preserve">
          <source>This is because named subroutines are created at compile time so their lexical variables get assigned to the parent lexicals from the first execution of the parent block. If a parent scope is entered a second time, its lexicals are created again, while the nested subs still reference the old ones.</source>
          <target state="translated">이는 명명 된 서브 루틴이 컴파일시 작성되므로 해당 어휘 변수가 상위 블록의 첫 번째 실행에서 상위 어휘에 할당되기 때문입니다. 상위 범위를 두 번 입력하면 해당 어휘가 다시 작성되고 중첩 된 하위는 여전히 이전 하위를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="c5db892d6d5c6549aeb31514ada7ecd4f892effe" translate="yes" xml:space="preserve">
          <source>This is best demonstrated by example. Normally copy-on-write will prevent the substitution from operator from using this hack, but if you can craft a string for which copy-on-write is not possible, you can see it in play. In the current implementation, the final byte of a string buffer is used as a copy-on-write reference count. If the buffer is not big enough, then copy-on-write is skipped. First have a look at an empty string:</source>
          <target state="translated">이것은 예를 통해 가장 잘 설명됩니다. 일반적으로 write-on-write는 운영자가이 해킹을 사용하지 못하도록 막아 주지만, copy-on-write가 불가능한 문자열을 만들 수 있다면이를 볼 수 있습니다. 현재 구현에서 문자열 버퍼의 마지막 바이트는 COW (Copy-On-Write) 참조 카운트로 사용됩니다. 버퍼가 충분히 크지 않으면 기록 중 복사를 건너 뜁니다. 먼저 빈 문자열을 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="110ec42eab0899b77be520515c85d69e76f3210b" translate="yes" xml:space="preserve">
          <source>This is best explained using the following example:</source>
          <target state="translated">이것은 다음 예제를 사용하여 가장 잘 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="5ccb22d8b75566be2249f3211df19f165abb3a07" translate="yes" xml:space="preserve">
          <source>This is called an &quot;array slice&quot;.</source>
          <target state="translated">이것을 &quot;배열 슬라이스&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="891aecbf1a8602556b6b3c6e2627cb164d6eebbc" translate="yes" xml:space="preserve">
          <source>This is called at the end of a lexical scope, just after unwinding the stack.</source>
          <target state="translated">이것은 스택을 풀고 난 직후 어휘 범위의 끝에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="7256e74371eb8bec49de48cf27c3c7d965b76d10" translate="yes" xml:space="preserve">
          <source>This is called at the end of a lexical scope, just before unwinding the stack.</source>
          <target state="translated">이것은 스택을 풀기 직전에 어휘 범위의 끝에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="39c51821499fb79c1bf1a7b16255cbfad901f488" translate="yes" xml:space="preserve">
          <source>This is called by -&amp;gt;new to initialize newly-constructed language handles. If you define an init method in your class, remember that it's usually considered a good idea to call $lh-&amp;gt;SUPER::init in it (presumably at the beginning), so that all classes get a chance to initialize a new object however they see fit.</source>
          <target state="translated">이것은 새로 생성 된 언어 핸들을 초기화하기 위해-&amp;gt; new에 의해 호출됩니다. 클래스에서 init 메소드를 정의하는 경우 일반적으로 $ lh-&amp;gt; SUPER :: init을 호출하는 것이 좋습니다 (아마도 처음에). 그러나 모든 클래스가 새 객체를 초기화 할 수있는 기회를 얻습니다. 그들은 적합하다고 본다.</target>
        </trans-unit>
        <trans-unit id="0f9664c006f22f51b95f420aa8dd1316340a796c" translate="yes" xml:space="preserve">
          <source>This is called just after starting a new lexical scope. Note that Perl code like</source>
          <target state="translated">이것은 새로운 어휘 범위를 시작한 직후에 호출됩니다. 펄 코드는</target>
        </trans-unit>
        <trans-unit id="1b4b72a19d24ff4c03ca59dfaf92e37705fe82d9" translate="yes" xml:space="preserve">
          <source>This is called just before starting to compile an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; STRING&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;
FILE&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;, after the eval has been set up.</source>
          <target state="translated">이것은 단지 컴파일을 시작하기 전에이라고 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; STRING&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; FILE&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 평가 후면을 설정 한 후,.</target>
        </trans-unit>
        <trans-unit id="63bc4c621adbf8f868c20e693d52ccd14e7f8bee" translate="yes" xml:space="preserve">
          <source>This is called just like any other method, with the object as the first argument. It does not receive any additional arguments. However, the &lt;code&gt;$_[0]&lt;/code&gt; variable will be read-only in the destructor, so you cannot assign a value to it.</source>
          <target state="translated">이것은 객체를 첫 번째 인수로 사용하여 다른 방법과 마찬가지로 호출됩니다. 추가 인수를받지 않습니다. 그러나 &lt;code&gt;$_[0]&lt;/code&gt; 변수는 소멸자에서 읽기 전용이므로 값을 할당 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a2a0ca9ad6271402577255f9f1a63a32921a68ca" translate="yes" xml:space="preserve">
          <source>This is called when &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; occurs. See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;The untie Gotcha&lt;/a&gt; below.</source>
          <target state="translated">때 호출 &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; 발생합니다. 아래 &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;의 Untie Gotcha를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="85277e9fbb24fb6a920480ff94a71d2b7d6a947a" translate="yes" xml:space="preserve">
          <source>This is called when a stash is assigned to a new location in the symbol table.</source>
          <target state="translated">이것은 기호 테이블의 새 위치에 숨김이 지정 될 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="89a93e1f017cbb5b7b2446a6eb7bdd8163601a7e" translate="yes" xml:space="preserve">
          <source>This is called when a stash is deleted from the symbol table.</source>
          <target state="translated">이것은 기호 테이블에서 숨김이 삭제 될 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="92909fe70994d8eb483f136285b4a0530d9ad33d" translate="yes" xml:space="preserve">
          <source>This is called when the hash is evaluated in scalar context. In order to mimic the behaviour of untied hashes, this method should return a false value when the tied hash is considered empty. If this method does not exist, perl will make some educated guesses and return true when the hash is inside an iteration. If this isn't the case, FIRSTKEY is called, and the result will be a false value if FIRSTKEY returns the empty list, true otherwise.</source>
          <target state="translated">스칼라 컨텍스트에서 해시가 평가 될 때 호출됩니다. 묶이지 않은 해시의 동작을 모방하기 위해이 메서드는 연결된 해시가 비어있는 것으로 간주 될 때 false 값을 반환해야합니다. 이 메소드가 존재하지 않으면, perl은 약간의 추측 된 추측을하고 해시가 반복 내에있을 때 true를 리턴합니다. 그렇지 않은 경우 FIRSTKEY가 호출되고 FIRSTKEY가 빈 목록을 반환하면 결과가 false가되고 그렇지 않으면 true가됩니다.</target>
        </trans-unit>
        <trans-unit id="43b19ffb80b780fe42418c60b4b551943190ef11" translate="yes" xml:space="preserve">
          <source>This is caused by the fact that a block by itself acts as a loop that executes once, see &lt;a href=&quot;#Basic-BLOCKs&quot;&gt;Basic BLOCKs&lt;/a&gt;.</source>
          <target state="translated">이것은 그 자체로 블록이 실행 한 번 참조하는 루프로서 작용한다는 사실에 의해 야기되는 &lt;a href=&quot;#Basic-BLOCKs&quot;&gt;기본 블록&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="52af186e7022d7cef4d799cfdb6b5d984aef07fe" translate="yes" xml:space="preserve">
          <source>This is commonly used to suppress the creation of man pages. MAN3PODS takes a hash ref not a string, but the above worked by accident in old versions of MakeMaker.</source>
          <target state="translated">이것은 일반적으로 매뉴얼 페이지 작성을 억제하는 데 사용됩니다. MAN3PODS는 문자열이 아닌 해시 참조를 사용하지만 이전 버전의 MakeMaker에서는 실수로 위의 작업을 수행했습니다.</target>
        </trans-unit>
        <trans-unit id="e5f528c0702057989be1850bcd519b0dfbd35566" translate="yes" xml:space="preserve">
          <source>This is complete documentation about all aspects of references. For a shorter, tutorial introduction to just the essential features, see &lt;a href=&quot;perlreftut&quot;&gt;perlreftut&lt;/a&gt;.</source>
          <target state="translated">이것은 참조의 모든 측면에 대한 완전한 문서입니다. 필수 기능에 대한 짧은 자습서 소개는 &lt;a href=&quot;perlreftut&quot;&gt;perlreftut를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="49ca539e3859d247b8a2739f333e60f8db59abef" translate="yes" xml:space="preserve">
          <source>This is completely general, but the most computationally expensive strategy. Choose one or the other character set and transform to that for every sort comparision. Here's a complete example that transforms to ASCII sort order:</source>
          <target state="translated">이것은 완전히 일반적이지만 가장 계산 비용이 많이 드는 전략입니다. 하나 이상의 문자 세트를 선택하고 모든 정렬 비교에 대해 해당 문자 세트로 변환하십시오. 다음은 ASCII 정렬 순서로 변환하는 완전한 예입니다.</target>
        </trans-unit>
        <trans-unit id="94195eae88e55c65702824bf560045165c39578d" translate="yes" xml:space="preserve">
          <source>This is converted to a tree similar to this one:</source>
          <target state="translated">이것은 다음과 비슷한 트리로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="6748d7a69c27bb3281328ef679799289a62c1105" translate="yes" xml:space="preserve">
          <source>This is currently supported by pod2text (Pod::Text), pod2man (Pod::Man), and any other pod2xxx or Pod::Xxxx translators that use Pod::Parser 1.093 or later, or Pod::Tree 1.02 or later.</source>
          <target state="translated">현재 pod2text (Pod :: Text), pod2man (Pod :: Man) 및 Pod :: Parser 1.093 이상 또는 Pod :: Tree 1.02 이상을 사용하는 다른 pod2xxx 또는 Pod :: Xxxx 변환기에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="593812f69db240f293446ffb5751455ff8815826" translate="yes" xml:space="preserve">
          <source>This is different from finding out the package an object is blessed into, which might not be the current package. For that, use &lt;code&gt;blessed&lt;/code&gt; from &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt;, part of the Standard Library since Perl 5.8:</source>
          <target state="translated">이것은 개체가 축복받은 패키지를 찾는 것과 다릅니다. 현재 패키지가 아닐 수도 있습니다. 이를 위해, 사용 &lt;code&gt;blessed&lt;/code&gt; 에서 &lt;a href=&quot;scalar/util&quot;&gt;스칼라 :: 백분율&lt;/a&gt; , 펄 5.8 이후의 표준 라이브러리의 일부 :</target>
        </trans-unit>
        <trans-unit id="fb97ecda4c6d5be858b3ffd4a4b01f62707feb1c" translate="yes" xml:space="preserve">
          <source>This is different than printing the array without the interpolation:</source>
          <target state="translated">보간없이 배열을 인쇄하는 것과는 다릅니다.</target>
        </trans-unit>
        <trans-unit id="2e89efe08d07d2fc445ecb0a49388c2db1540bc9" translate="yes" xml:space="preserve">
          <source>This is disabled by default.</source>
          <target state="translated">기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9b83c7f438982c73dfeaa8ce24f6687d2ff66f7" translate="yes" xml:space="preserve">
          <source>This is discussed in more detail in &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;; see the entry on</source>
          <target state="translated">이것은 &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt; 에서 더 자세히 논의됩니다 . 에 항목을 참조하십시오</target>
        </trans-unit>
        <trans-unit id="76fae6a858b50aa10f361d29a97f6c807c02664b" translate="yes" xml:space="preserve">
          <source>This is documented in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;, and although it's not the easiest thing to read, it does work. In each of these examples, we call the function inside the braces used to dereference a reference. If we have more than one return value, we can construct and dereference an anonymous array. In this case, we call the function in list context.</source>
          <target state="translated">이것은 &lt;a href=&quot;perlref&quot;&gt;perlref에&lt;/a&gt; 문서화되어 있으며 가장 쉬운 것은 아니지만 작동합니다. 이러한 각 예에서 참조를 역 참조하는 데 사용되는 중괄호 안의 함수를 호출합니다. 반환 값이 둘 이상인 경우 익명 배열을 구성하고 역 참조 할 수 있습니다. 이 경우 목록 컨텍스트에서 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="cc9f74e233591efd345d524b870503e793053031" translate="yes" xml:space="preserve">
          <source>This is done by using hostname lookup and the &lt;code&gt;local_netmask&lt;/code&gt; entry in the configuration data.</source>
          <target state="translated">이는 구성 데이터에서 호스트 이름 조회 및 &lt;code&gt;local_netmask&lt;/code&gt; 항목 을 사용하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="454855df818209bc8493bdfbab3f2ca7ae6dfdc7" translate="yes" xml:space="preserve">
          <source>This is done for a breakpoint in the current file.</source>
          <target state="translated">이것은 현재 파일의 중단 점에 대해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="4a47be7db788c450b66cdea2d395c9b71203ef53" translate="yes" xml:space="preserve">
          <source>This is due to a bug in the C library's printf routine. printf(&quot;'%e'&quot;, 0. ) produces '0.000000e+0', but ANSI requires '0.000000e+00'. QNX has acknowledged the bug.</source>
          <target state="translated">이것은 C 라이브러리의 printf 루틴의 버그로 인한 것입니다. printf ( &quot; '% e'&quot;, 0.)는 '0.000000e + 0'을 생성하지만 ANSI에는 '0.000000e + 00'이 필요합니다. QNX는 버그를 인정했습니다.</target>
        </trans-unit>
        <trans-unit id="71e4fa6fb5f00ffdde6cecd71fb22bb161db5777" translate="yes" xml:space="preserve">
          <source>This is due to the performance optimisation of using &lt;code&gt;MULTICALL&lt;/code&gt; for the code block, which means that fresh SVs do not get allocated for each call to the block. Instead, the same SV is re-assigned for each iteration, and all the closures will share the value seen on the final iteration.</source>
          <target state="translated">이는 코드 블록에 &lt;code&gt;MULTICALL&lt;/code&gt; 을 사용하는 성능 최적화 때문 입니다. 즉, 새로운 SV는 블록에 대한 각 호출에 할당되지 않습니다. 대신 각 반복에 대해 동일한 SV가 재 할당되며 모든 클로저는 최종 반복에 표시된 값을 공유합니다.</target>
        </trans-unit>
        <trans-unit id="447f198b012c8346529f18f6ac62c32d7efbbdb9" translate="yes" xml:space="preserve">
          <source>This is elaborately and painstakingly described in the</source>
          <target state="translated">이것은 정교하고 힘들게 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="821291d0776e9b5b0d39c1a20f26c0a1d006ccf3" translate="yes" xml:space="preserve">
          <source>This is enabled by default.</source>
          <target state="translated">기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="05dc6a6637a3cd1c406048840a442a226332304e" translate="yes" xml:space="preserve">
          <source>This is equivalent to putting &lt;code&gt;?:&lt;/code&gt; at the beginning of every capturing group:</source>
          <target state="translated">이것은 모든 캡처 그룹의 시작 부분에 &lt;code&gt;?:&lt;/code&gt; 를 넣는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="8b27aed9ee162e49847966b3b51b71c4860ae778" translate="yes" xml:space="preserve">
          <source>This is equivalent to the following code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db66d69de876b62af8e4e583ee35fa7336ce738e" translate="yes" xml:space="preserve">
          <source>This is especially handy for the handles that Perl has already opened for you.</source>
          <target state="translated">이것은 Perl이 이미 열어 놓은 핸들에 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f8d05739ccb676f898da1bfecdf838eee060521a" translate="yes" xml:space="preserve">
          <source>This is especially noticeable in scripts like Makefiles and test suites, which often assume &lt;code&gt;/&lt;/code&gt; as a path separator for subdirectories.</source>
          <target state="translated">이는 Makefile 및 테스트 스위트와 같은 스크립트에서 특히 두드러지며 하위 디렉토리의 경로 구분 기호로 종종 &lt;code&gt;/&lt;/code&gt; 를 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="f527eac137b06210e13666ef8269894d061c4071" translate="yes" xml:space="preserve">
          <source>This is especially significant, given that &lt;code&gt;__DIE__&lt;/code&gt; hooks can call &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; again, which has the effect of changing their error messages:</source>
          <target state="translated">&lt;code&gt;__DIE__&lt;/code&gt; 후크가 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 를 다시 호출 하여 오류 메시지를 변경하는 효과가 있다는 점을 고려하면 이는 특히 중요 합니다.</target>
        </trans-unit>
        <trans-unit id="e72ff779e72b05ba7f524c22b987a33b6ce734c7" translate="yes" xml:space="preserve">
          <source>This is especially significant, given that &lt;code&gt;__DIE__&lt;/code&gt; hooks can call &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; again, which has the effect of changing their error messages:</source>
          <target state="translated">&lt;code&gt;__DIE__&lt;/code&gt; 후크가 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 를 다시 호출 하여 오류 메시지를 변경하는 효과가 있다는 점을 고려하면 이는 특히 중요 합니다.</target>
        </trans-unit>
        <trans-unit id="818858cb9601e6ed62390539756668bab6bf2c4d" translate="yes" xml:space="preserve">
          <source>This is especially true if trying to catch &lt;code&gt;SIGALRM&lt;/code&gt; in a thread. To handle alarms in threads, set up a signal handler in the main thread, and then use &lt;a href=&quot;#THREAD-SIGNALLING&quot;&gt;THREAD SIGNALLING&lt;/a&gt; to relay the signal to the thread:</source>
          <target state="translated">스레드에서 &lt;code&gt;SIGALRM&lt;/code&gt; 을 잡으려는 경우 특히 그렇습니다 . 스레드에서 알람을 처리하려면 메인 스레드에서 신호 처리기를 설정 한 다음 &lt;a href=&quot;#THREAD-SIGNALLING&quot;&gt;스레드 신호&lt;/a&gt; 를 사용 하여 신호를 스레드에 릴레이합니다.</target>
        </trans-unit>
        <trans-unit id="fd6dde33455dcaab484709ef3e2e047ba6858d2a" translate="yes" xml:space="preserve">
          <source>This is essentially a linear encoding of a nondeterministic finite-state machine (aka syntax charts or &quot;railroad normal form&quot; in parsing technology).</source>
          <target state="translated">이것은 본질적으로 비 결정적 유한 상태 머신 (구문 분석에서 구문 도표 또는 &quot;철도 정규 형식&quot;)의 선형 인코딩입니다.</target>
        </trans-unit>
        <trans-unit id="c2c33667b47416ed635e9db2747270d43c9fb79e" translate="yes" xml:space="preserve">
          <source>This is exactly equivalent to</source>
          <target state="translated">이것은 정확히</target>
        </trans-unit>
        <trans-unit id="2888d5ca02740e184f93a1ad103d7f0d59cf4bf3" translate="yes" xml:space="preserve">
          <source>This is exactly equivalent to writing &lt;code&gt;$sub-&amp;gt;($file)&lt;/code&gt; . You may see this idiom in the wild combined with a call to &lt;code&gt;can&lt;/code&gt; :</source>
          <target state="translated">이것은 &lt;code&gt;$sub-&amp;gt;($file)&lt;/code&gt; 작성과 정확히 동일합니다 . 이 관용구는 야생에서 &lt;code&gt;can&lt;/code&gt; 에 대한 호출과 결합하여 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc0020f4d9923684685bbbcf57921ec11fb0aac1" translate="yes" xml:space="preserve">
          <source>This is exactly the problem the</source>
          <target state="translated">이것은 정확히 문제입니다</target>
        </trans-unit>
        <trans-unit id="1323ae3621b03444ef40592d920a99e3788e04fe" translate="yes" xml:space="preserve">
          <source>This is exactly the same as:</source>
          <target state="translated">이것은 정확히 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="5350516b52a22254c5df97eb2c2d9b4520e43a69" translate="yes" xml:space="preserve">
          <source>This is fairly secure because &lt;code&gt;/\w+/&lt;/code&gt; doesn't normally match shell metacharacters, nor are dot, dash, or at going to mean something special to the shell. Use of &lt;code&gt;/.+/&lt;/code&gt; would have been insecure in theory because it lets everything through, but Perl doesn't check for that. The lesson is that when untainting, you must be exceedingly careful with your patterns. Laundering data using regular expression is the</source>
          <target state="translated">&lt;code&gt;/\w+/&lt;/code&gt; 는 일반적으로 쉘 메타 문자와 일치하지 않으며 도트, 대시 또는 쉘에 특별한 의미가 없기 때문에 상당히 안전 합니다. &lt;code&gt;/.+/&lt;/code&gt; 의 사용은 모든 것을 통과시킬 수 있기 때문에 이론상 안전하지 못했을 것입니다. 그러나 Perl 은이를 확인하지 않습니다. 교훈은 오염을 풀 때 패턴에 매우주의를 기울여야한다는 것입니다. 정규식을 사용한 세탁 데이터는</target>
        </trans-unit>
        <trans-unit id="4d2e8c2e8c603b9443a2fa3515b87175734dfedd" translate="yes" xml:space="preserve">
          <source>This is faster than using the &lt;b&gt;-exec&lt;/b&gt; switch of</source>
          <target state="translated">이것은 &lt;b&gt;-exec&lt;/b&gt; 스위치를 사용하는 것보다 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="1aa28f8ff665fed944de016ad1db63136902800f" translate="yes" xml:space="preserve">
          <source>This is fine for systems programming when sendmail is known to be available. But it is not fine for many non-Unix systems, and even some Unix systems that may not have sendmail installed. If a portable solution is needed, see the various distributions on CPAN that deal with it. &lt;code&gt;Mail::Mailer&lt;/code&gt; and &lt;code&gt;Mail::Send&lt;/code&gt; in the &lt;code&gt;MailTools&lt;/code&gt; distribution are commonly used, and provide several mailing methods, including &lt;code&gt;mail&lt;/code&gt; , &lt;code&gt;sendmail&lt;/code&gt; , and direct SMTP (via &lt;code&gt;Net::SMTP&lt;/code&gt; ) if a mail transfer agent is not available. &lt;code&gt;Mail::Sendmail&lt;/code&gt; is a standalone module that provides simple, platform-independent mailing.</source>
          <target state="translated">sendmail을 사용할 수있는 경우 시스템 프로그래밍에 적합합니다. 그러나 많은 비 유닉스 시스템, 심지어 sendmail이 설치되지 않은 일부 유닉스 시스템에는 적합하지 않습니다. 휴대용 솔루션이 필요한 경우 CPAN의 다양한 배포판을 참조하십시오. &lt;code&gt;MailTools&lt;/code&gt; 배포 에서 &lt;code&gt;Mail::Mailer&lt;/code&gt; 및 &lt;code&gt;Mail::Send&lt;/code&gt; 가 일반적으로 사용되며, 메일 전송 에이전트를 사용할 수없는 경우 &lt;code&gt;mail&lt;/code&gt; , &lt;code&gt;sendmail&lt;/code&gt; 및 직접 SMTP ( &lt;code&gt;Net::SMTP&lt;/code&gt; ) 를 포함한 여러 가지 메일 방법을 제공 합니다. &lt;code&gt;Mail::Sendmail&lt;/code&gt; 은 플랫폼 독립적 인 간단한 메일 링을 제공하는 독립형 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="3aabced6833bcc3911383da0e252138fb5ec6985" translate="yes" xml:space="preserve">
          <source>This is fine if you are just looking for a single character. However, if you are trying to count multiple character substrings within a larger string, &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; won't work. What you can do is wrap a while() loop around a global pattern match. For example, let's count negative integers:</source>
          <target state="translated">단일 문자를 찾고 있다면 괜찮습니다. 그러나 더 큰 문자열 내에서 여러 문자 하위 문자열을 계산하려고하면 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 가 작동하지 않습니다. 전역 패턴 일치에 while () 루프를 래핑하는 것이 가능합니다. 예를 들어, 음의 정수를 세어 봅시다 :</target>
        </trans-unit>
        <trans-unit id="9cfd669832389228af06dec1239a8521733d9cc4" translate="yes" xml:space="preserve">
          <source>This is for backwards compatibility, and may be deprecated in the future.</source>
          <target state="translated">이는 이전 버전과의 호환성을위한 것으로 향후 사용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e1feb67b0818a9b1deb572f5e23a9f9edab3c53" translate="yes" xml:space="preserve">
          <source>This is for clustering, not capturing; it groups subexpressions like &quot;()&quot;, but doesn't make backreferences as &quot;()&quot; does. So</source>
          <target state="translated">이는 캡처가 아니라 클러스터링을위한 것입니다. 하위 표현식을 &quot;()&quot;과 같이 그룹화하지만 &quot;()&quot;과 같이 역 참조를하지 않습니다. 그래서</target>
        </trans-unit>
        <trans-unit id="fd0c739b12ea8f303fae64c2fc3f585b7a17c56e" translate="yes" xml:space="preserve">
          <source>This is for heuristics which attempt to create directory structures that mirror those of the installed perl.</source>
          <target state="translated">이것은 설치된 perl의 구조를 반영하는 디렉토리 구조를 작성하려는 휴리스틱을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="f8b7de1b28f0c9aa17d5f75d5f2141f8c81f40ef" translate="yes" xml:space="preserve">
          <source>This is for unsigned integers. It is equivalent to using T_UV but explicitly casts the variable to type &lt;code&gt;unsigned &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; . The default type for &lt;code&gt;unsigned &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; is T_UV.</source>
          <target state="translated">부호없는 정수를위한 것입니다. T_UV를 사용하는 것과 동일하지만 변수를 &lt;code&gt;unsigned &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 유형으로 명시 적으로 캐스팅합니다 . &lt;code&gt;unsigned &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 의 기본 유형 은 T_UV입니다.</target>
        </trans-unit>
        <trans-unit id="223ca8fc8e06498b8700fcaf3a5b924a9287e801" translate="yes" xml:space="preserve">
          <source>This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5 programming language system itself.</source>
          <target state="translated">이것은 무료 소프트웨어입니다. Perl 5 프로그래밍 언어 시스템 자체와 동일한 용어로 재배포 및 / 또는 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b876192e43b0c3f007bf98e622b2f335f00b0f03" translate="yes" xml:space="preserve">
          <source>This is functionally identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep()&lt;/a&gt;&lt;/code&gt; function for suspending the execution of the current for process for certain number of seconds, see &lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;. There is one significant difference, however: &lt;code&gt;POSIX::sleep()&lt;/code&gt; returns the number of &lt;b&gt;unslept&lt;/b&gt; seconds, while the &lt;code&gt;CORE::sleep()&lt;/code&gt; returns the number of slept seconds.</source>
          <target state="translated">이것은 특정 시간 (초) 동안 프로세스에 대한 전류 실행을 일시 중단하는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep()&lt;/a&gt;&lt;/code&gt; 함수와 기능적으로 동일합니다 (&lt;a href=&quot;functions/sleep&quot;&gt; sleep&lt;/a&gt; 참조) . 그러나 한 가지 중요한 차이점이 있습니다. &lt;code&gt;POSIX::sleep()&lt;/code&gt; 은 &lt;b&gt;잠자 지 않은&lt;/b&gt; 시간 (초 &lt;code&gt;CORE::sleep()&lt;/code&gt; 반환하고 CORE :: sleep () 은 잠은 시간 (초 )을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4fb4b681258fa0233585a271cede9e357d7bbce9" translate="yes" xml:space="preserve">
          <source>This is generally meant to be called from inside Bracket Notation (which is discussed later), as in</source>
          <target state="translated">이것은 일반적으로 다음과 같이 브라켓 표기법 (나중에 설명 함)에서 호출하도록되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="487a457dae8e51eb07ff40b59ced8f82c47ea01f" translate="yes" xml:space="preserve">
          <source>This is generally not recommended, but large testing systems often have weird internal needs.</source>
          <target state="translated">이것은 일반적으로 권장되지 않지만 대규모 테스트 시스템에는 종종 내부 요구가 이상합니다.</target>
        </trans-unit>
        <trans-unit id="abeb233860c7acca6119cb787cba71a4bde24872" translate="yes" xml:space="preserve">
          <source>This is grandfathered (for \1 to \9) for the RHS of a substitute to avoid shocking the &lt;b&gt;sed&lt;/b&gt; addicts, but it's a dirty habit to get into. That's because in PerlThink, the righthand side of an &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; is a double-quoted string. &lt;code&gt;\1&lt;/code&gt; in the usual double-quoted string means a control-A. The customary Unix meaning of &lt;code&gt;\1&lt;/code&gt; is kludged in for &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;. However, if you get into the habit of doing that, you get yourself into trouble if you then add an &lt;code&gt;/e&lt;/code&gt; modifier.</source>
          <target state="translated">이것은 &lt;b&gt;sed&lt;/b&gt; 중독자 에게 충격을주는 것을 피하기 위해 RHS 대신에 할아버지를 대상으로합니다 (\ 1에서 \ 9까지) . 그러나 들어가는 것은 더러운 습관입니다. PerlThink에서 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 의 오른쪽 이 큰 따옴표로 묶인 문자열 이기 때문입니다 . 일반적인 큰 따옴표로 묶인 문자열에서 &lt;code&gt;\1&lt;/code&gt; 은 control-A를 의미합니다. &lt;code&gt;\1&lt;/code&gt; 의 관습적인 유닉스 의미는 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 에 대해 잘 알려져 있습니다. 그러나 그렇게하는 습관을들이는 경우, &lt;code&gt;/e&lt;/code&gt; 수정자를 추가하면 문제가 생길 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a33e8e516c4662a8793090c4f24cce78089ad98d" translate="yes" xml:space="preserve">
          <source>This is handy when you want to do a list assignment in a Boolean context, because most list functions return a null list when finished, which when assigned produces a 0, which is interpreted as FALSE.</source>
          <target state="translated">부울 컨텍스트에서 목록 할당을 수행하려고 할 때 유용합니다. 대부분의 목록 함수는 완료되면 null 목록을 반환하므로 할당되면 0을 생성하므로 FALSE로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="8c2cfb1906a45c414c7c96fc609271f7955af896" translate="yes" xml:space="preserve">
          <source>This is how it works now:</source>
          <target state="translated">이것이 지금 작동하는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="7dbdb31e7c27bacbcb7fe1d4ef14ea6d653940f1" translate="yes" xml:space="preserve">
          <source>This is identical in operation to directories(), except that it includes all the intermediate directories back up to the specified directories.</source>
          <target state="translated">지정된 디렉토리로 백업되는 모든 중간 디렉토리를 포함한다는 점을 제외하고는 directory ()와 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e351930a2f0204ac9b6b12368a795bebdda09c11" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs()&lt;/a&gt;&lt;/code&gt; function for returning the absolute value of the numerical argument, see &lt;a href=&quot;functions/abs&quot;&gt;abs&lt;/a&gt;.</source>
          <target state="translated">이것은 숫자 인수의 절대 값을 반환하는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 (&lt;a href=&quot;functions/abs&quot;&gt; abs&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="695d548bdbb7db69858dd0c63a58915988364e1a" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs()&lt;/a&gt;&lt;/code&gt; function, returning the absolute value of its numerical argument.</source>
          <target state="translated">이것은 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs()&lt;/a&gt;&lt;/code&gt; 함수와 동일 하며 숫자 인수의 절대 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f9120a2adefbe5ba2e37ba001760405e7d0a7dbe" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; function, either for arming or disarming the &lt;code&gt;SIGARLM&lt;/code&gt; timer.</source>
          <target state="translated">이는 &lt;code&gt;SIGARLM&lt;/code&gt; 타이머 를 활성화하거나 해제하는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; 함수와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="48a476413067dd99ab4121abaa36c23eb2d9f153" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2()&lt;/a&gt;&lt;/code&gt; function, returning the arcus tangent defined by its two numerical arguments, the</source>
          <target state="translated">이것은 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2()&lt;/a&gt;&lt;/code&gt; 함수와 동일 하며 두 개의 숫자 인수로 정의 된 아크 러스 탄젠트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a05756bd65e3a6ef14f82f8385fe7e460811d0b5" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; function, allowing one to change the working (default) directory, see &lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;.</source>
          <target state="translated">이것은 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; 함수와 동일하며 , 작동하는 (기본) 디렉토리를 변경할 수 있습니다 ( &lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="e888ff11c427adcd230a49c55dda839ea4139d83" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod()&lt;/a&gt;&lt;/code&gt; function, allowing one to change file and directory permissions, see &lt;a href=&quot;functions/chmod&quot;&gt;chmod&lt;/a&gt;.</source>
          <target state="translated">이것은 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod()&lt;/a&gt;&lt;/code&gt; 함수와 동일하므로 파일 및 디렉토리 권한을 변경할 수 있습니다 ( &lt;a href=&quot;functions/chmod&quot;&gt;chmod&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="43527baa97f98b6bb9f0a7d166453b7ea32ff963" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; function, allowing one to change file and directory owners and groups, see &lt;a href=&quot;functions/chown&quot;&gt;chown&lt;/a&gt;.</source>
          <target state="translated">이것은 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; 함수와 동일하므로 파일 및 디렉토리 소유자 및 그룹을 변경할 수 있습니다 ( &lt;a href=&quot;functions/chown&quot;&gt;chown&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="137a34ed8adb7ab17d656d13fbf0961186414eb0" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/closedir&quot;&gt;closedir()&lt;/a&gt;&lt;/code&gt; function for closing a directory handle, see &lt;a href=&quot;functions/closedir&quot;&gt;closedir&lt;/a&gt;.</source>
          <target state="translated">이것은 디렉토리 핸들을 닫는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/closedir&quot;&gt;closedir()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 (&lt;a href=&quot;functions/closedir&quot;&gt; closedir&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="e039818d97c69012826d73ac04fb7fe2694eb5b3" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/cos&quot;&gt;cos()&lt;/a&gt;&lt;/code&gt; function, for returning the cosine of its numerical argument, see &lt;a href=&quot;functions/cos&quot;&gt;cos&lt;/a&gt;. See also &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">이는 숫자 인수의 코사인을 반환하는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/cos&quot;&gt;cos()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 . &lt;a href=&quot;functions/cos&quot;&gt;cos를&lt;/a&gt; 참조하십시오 . &lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b7986353e4fd90f34533ad5983c9c0772e03e142" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; function for exiting the program, see &lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;.</source>
          <target state="translated">이것은 프로그램을 종료하기위한 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 . &lt;a href=&quot;functions/exit&quot;&gt;exit를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d2c5c838eac2ca99b87036128b4be02041ba664e" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/exp&quot;&gt;exp()&lt;/a&gt;&lt;/code&gt; function for returning the exponent (</source>
          <target state="translated">이것은 지수를 반환하는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/exp&quot;&gt;exp()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="0f8afa6cc9b9bce42a0f876c4312c43a9b501d34" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl()&lt;/a&gt;&lt;/code&gt; function, see &lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;.</source>
          <target state="translated">이것은 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 (&lt;a href=&quot;functions/fcntl&quot;&gt; fcntl&lt;/a&gt; 참조 ) .</target>
        </trans-unit>
        <trans-unit id="0526f440f4487b3f67fbf7e27396c04e1d2573cc" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; function for duplicating the current process, see &lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt; and &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt; if you are in Windows.</source>
          <target state="translated">이것은 현재 프로세스를 복제하는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 함수 와 &lt;a href=&quot;perlfork&quot;&gt;동일&lt;/a&gt; 합니다. Windows에있는 경우 &lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt; 및 perlfork를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f40ae5570bc527bc5a1dd6d93c31c6aa0f593934" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/getc&quot;&gt;getc()&lt;/a&gt;&lt;/code&gt; function, see &lt;a href=&quot;functions/getc&quot;&gt;getc&lt;/a&gt;.</source>
          <target state="translated">이것은 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/getc&quot;&gt;getc()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 (&lt;a href=&quot;functions/getc&quot;&gt; getc&lt;/a&gt; 참조 ) .</target>
        </trans-unit>
        <trans-unit id="35d7514c028c77e7ca42538761981fea1a5e7fde" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/getgrgid&quot;&gt;getgrgid()&lt;/a&gt;&lt;/code&gt; function for returning group entries by group identifiers, see &lt;a href=&quot;functions/getgrgid&quot;&gt;getgrgid&lt;/a&gt;.</source>
          <target state="translated">이는 그룹 식별자로 그룹 항목을 리턴 하는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/getgrgid&quot;&gt;getgrgid()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 (&lt;a href=&quot;functions/getgrgid&quot;&gt; getgrgid&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="60e26e2d8720ed0149b7b87c377d73417035968a" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/getgrnam&quot;&gt;getgrnam()&lt;/a&gt;&lt;/code&gt; function for returning group entries by group names, see &lt;a href=&quot;functions/getgrnam&quot;&gt;getgrnam&lt;/a&gt;.</source>
          <target state="translated">이는 그룹 이름으로 그룹 항목을 리턴 하는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/getgrnam&quot;&gt;getgrnam()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 (&lt;a href=&quot;functions/getgrnam&quot;&gt; getgrnam&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="d15624acd39757d16036f7262ed6bcece3061f3a" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/getlogin&quot;&gt;getlogin()&lt;/a&gt;&lt;/code&gt; function for returning the user name associated with the current session, see &lt;a href=&quot;functions/getlogin&quot;&gt;getlogin&lt;/a&gt;.</source>
          <target state="translated">이것은 현재 세션과 연관된 사용자 이름을 리턴하는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/getlogin&quot;&gt;getlogin()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 . &lt;a href=&quot;functions/getlogin&quot;&gt;getlogin을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="186fcd1d3a57037edb361be5db32f5f007ca9211" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/getpgrp&quot;&gt;getpgrp()&lt;/a&gt;&lt;/code&gt; function for returning the process group identifier of the current process, see &lt;a href=&quot;functions/getpgrp&quot;&gt;getpgrp&lt;/a&gt;.</source>
          <target state="translated">이것은 현재 프로세스의 프로세스 그룹 식별자를 반환하는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/getpgrp&quot;&gt;getpgrp()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 (&lt;a href=&quot;functions/getpgrp&quot;&gt; getpgrp&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="e1809496150480256c93f1aafd87f931437ce086" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/getppid&quot;&gt;getppid()&lt;/a&gt;&lt;/code&gt; function for returning the process identifier of the parent process of the current process , see &lt;a href=&quot;functions/getppid&quot;&gt;getppid&lt;/a&gt;.</source>
          <target state="translated">이것은 현재 프로세스의 부모 프로세스의 프로세스 식별자를 반환하는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/getppid&quot;&gt;getppid()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 (&lt;a href=&quot;functions/getppid&quot;&gt; getppid&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="457ce51591f9cb379a5adb26605bff1ac3f4ef40" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/getpwnam&quot;&gt;getpwnam()&lt;/a&gt;&lt;/code&gt; function for returning user entries by user names, see &lt;a href=&quot;functions/getpwnam&quot;&gt;getpwnam&lt;/a&gt;.</source>
          <target state="translated">이것은 사용자 이름으로 사용자 항목을 리턴 하는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/getpwnam&quot;&gt;getpwnam()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 (&lt;a href=&quot;functions/getpwnam&quot;&gt; getpwnam&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="099bdffd8de12dde36332facd7fd521fe7604dc8" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/getpwuid&quot;&gt;getpwuid()&lt;/a&gt;&lt;/code&gt; function for returning user entries by user identifiers, see &lt;a href=&quot;functions/getpwuid&quot;&gt;getpwuid&lt;/a&gt;.</source>
          <target state="translated">이는 사용자 식별자로 사용자 항목을 리턴 하는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/getpwuid&quot;&gt;getpwuid()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 (&lt;a href=&quot;functions/getpwuid&quot;&gt; getpwuid&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="f2f87263d58fd06391e632ecc597293fca726096" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; function for converting seconds since the epoch to a date in Greenwich Mean Time, see &lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;.</source>
          <target state="translated">이것은 신기원 이후의 초를 그리니치 표준시의 날짜로 변환 하는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 (&lt;a href=&quot;functions/gmtime&quot;&gt; gmtime&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="f3c0f6e328c0a9e84f4089fb4367baf98b6b1c72" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index()&lt;/a&gt;&lt;/code&gt; function, see &lt;a href=&quot;functions/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">이것은 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 (&lt;a href=&quot;functions/index&quot;&gt; index&lt;/a&gt; 참조 ) .</target>
        </trans-unit>
        <trans-unit id="b121ee200825f5ba836e4ff9ea046596d9a0669c" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill()&lt;/a&gt;&lt;/code&gt; function for sending signals to processes (often to terminate them), see &lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;.</source>
          <target state="translated">이는 프로세스에 신호를 보내는 (종종 종료하는) Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill()&lt;/a&gt;&lt;/code&gt; 함수와 동일 합니다 ( &lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="b81f62db22691a94ae2b3fa4ba9674d2bf0b3fd0" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/link&quot;&gt;link()&lt;/a&gt;&lt;/code&gt; function for creating hard links into files, see &lt;a href=&quot;functions/link&quot;&gt;link&lt;/a&gt;.</source>
          <target state="translated">이것은 파일에 하드 링크를 만드는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/link&quot;&gt;link()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 (&lt;a href=&quot;functions/link&quot;&gt; link&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="44d5f3c7d27301e5eb1acf76c204cabece604701" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; function for converting seconds since the epoch to a date see &lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;.</source>
          <target state="translated">이 펄 내장 된 동일 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 날짜보기로 에포크 이후 초 변환 함수 &lt;a href=&quot;functions/localtime&quot;&gt;의 현지&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9e0909781f3283ef9c3e20db724f85b91f439d90" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/log&quot;&gt;log()&lt;/a&gt;&lt;/code&gt; function, returning the natural (</source>
          <target state="translated">이것은 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/log&quot;&gt;log()&lt;/a&gt;&lt;/code&gt; 함수와 동일하며 , 자연 (</target>
        </trans-unit>
        <trans-unit id="e971f99436b45984924e279dba0a0153fd2a323c" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/mkdir&quot;&gt;mkdir()&lt;/a&gt;&lt;/code&gt; function for creating directories, see &lt;a href=&quot;functions/mkdir&quot;&gt;mkdir&lt;/a&gt;.</source>
          <target state="translated">이것은 디렉토리 작성을위한 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/mkdir&quot;&gt;mkdir()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 (&lt;a href=&quot;functions/mkdir&quot;&gt; mkdir&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="b41549ebc9ad587ccb819b0a3ec0f8792362c7d3" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; function for reading directory entries, see &lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;.</source>
          <target state="translated">이것은 디렉토리 항목을 읽는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 (&lt;a href=&quot;functions/readdir&quot;&gt; readdir&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="35438e0216a544df5038b4544cbb587885a54611" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; function for renaming files, see &lt;a href=&quot;functions/rename&quot;&gt;rename&lt;/a&gt;.</source>
          <target state="translated">이것은 파일 이름 바꾸기를위한 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 . &lt;a href=&quot;functions/rename&quot;&gt;rename을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5d513c94dc874928c142ca043089cff6c9b7ef0" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir()&lt;/a&gt;&lt;/code&gt; function for rewinding directory entry streams, see &lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir&lt;/a&gt;.</source>
          <target state="translated">이는 디렉토리 항목 스트림을 되감기위한 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 (&lt;a href=&quot;functions/rewinddir&quot;&gt; rewinddir&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="cb204757196695331f28a45173a4730e85e7f0fb" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/rmdir&quot;&gt;rmdir()&lt;/a&gt;&lt;/code&gt; function for removing (empty) directories, see &lt;a href=&quot;functions/rmdir&quot;&gt;rmdir&lt;/a&gt;.</source>
          <target state="translated">이것은 (빈) 디렉토리를 제거하는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/rmdir&quot;&gt;rmdir()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 (&lt;a href=&quot;functions/rmdir&quot;&gt; rmdir&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="f5d85ea0b853465bcc33fe450ea49c14a87d8b77" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/sin&quot;&gt;sin()&lt;/a&gt;&lt;/code&gt; function for returning the sine of the numerical argument, see &lt;a href=&quot;functions/sin&quot;&gt;sin&lt;/a&gt;. See also &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">이것은 숫자 인수의 사인을 반환하는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/sin&quot;&gt;sin()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 . &lt;a href=&quot;functions/sin&quot;&gt;sin&lt;/a&gt; 참조하십시오 . &lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="919e7a21c6ecbb020823d058dd90c7b0a9eb3a55" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/sqrt&quot;&gt;sqrt()&lt;/a&gt;&lt;/code&gt; function. for returning the square root of the numerical argument, see &lt;a href=&quot;functions/sqrt&quot;&gt;sqrt&lt;/a&gt;.</source>
          <target state="translated">이것은 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/sqrt&quot;&gt;sqrt()&lt;/a&gt;&lt;/code&gt; 함수와 동일 합니다. 숫자 인수의 제곱근을 반환하려면 &lt;a href=&quot;functions/sqrt&quot;&gt;sqrt를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0eaf8f167427908f7febf3b312f3b5eb7b5e1919" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; function for returning information about files and directories.</source>
          <target state="translated">이것은 파일과 디렉토리에 대한 정보를 반환 하는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="41d6fd8cbb0b29357e5142e667be5a61001f2978" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; function, see &lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;.</source>
          <target state="translated">이것은 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 함수와 동일 합니다 (&lt;a href=&quot;functions/system&quot;&gt; system&lt;/a&gt; 참조 ) .</target>
        </trans-unit>
        <trans-unit id="3273b4b3b0615a180eb23eebf260bd07416587ce" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; function for returning the number of seconds since the epoch (whatever it is for the system), see &lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;.</source>
          <target state="translated">이것은 epoch (시스템에 관계없이) 이후의 초 수를 반환하는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 . &lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c38ab013e5c6afb6168a48634dc91f08bf30d4f9" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask()&lt;/a&gt;&lt;/code&gt; function for setting (and querying) the file creation permission mask, see &lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;.</source>
          <target state="translated">이것은 파일 작성 권한 마스크를 설정 (및 조회)하는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 ( &lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="88df1d410534e354bba714dca11791a1312464a8" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink()&lt;/a&gt;&lt;/code&gt; function for removing files, see &lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;.</source>
          <target state="translated">이것은 파일을 제거하는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 (&lt;a href=&quot;functions/unlink&quot;&gt; unlink&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="5cb3ad24016b3eaa5941feee2fcd750ab1532552" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/utime&quot;&gt;utime()&lt;/a&gt;&lt;/code&gt; function for changing the time stamps of files and directories, see &lt;a href=&quot;functions/utime&quot;&gt;utime&lt;/a&gt;.</source>
          <target state="translated">이것은 파일 및 디렉토리의 타임 스탬프를 변경하는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/utime&quot;&gt;utime()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 (&lt;a href=&quot;functions/utime&quot;&gt; utime&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="c2c58755bc175c3890516b5d42561515cbd4c528" translate="yes" xml:space="preserve">
          <source>This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; function, see &lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;.</source>
          <target state="translated">이것은 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 . &lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="c33a2624a3bac1d7979963b70993ae442f03646c" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;_exit()&lt;/code&gt; . It exits the program immediately which means among other things buffered I/O is &lt;b&gt;not&lt;/b&gt; flushed.</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;_exit()&lt;/code&gt; 동일합니다 . 버퍼 된 I / O가 플러시 &lt;b&gt;되지 않는&lt;/b&gt; 것을 의미하는 즉시 프로그램을 종료합니다 .</target>
        </trans-unit>
        <trans-unit id="f80c449f3b57bbebcb07635c9eb453473b86c188" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;abort()&lt;/code&gt; . It terminates the process with a &lt;code&gt;SIGABRT&lt;/code&gt; signal unless caught by a signal handler or if the handler does not return normally (it e.g. does a &lt;code&gt;longjmp&lt;/code&gt; ).</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;abort()&lt;/code&gt; 동일합니다 . 신호 처리기에 의해 포착되지 않거나 처리기가 정상적으로 반환되지 않으면 (예 : &lt;code&gt;longjmp&lt;/code&gt; 수행 ) &lt;code&gt;SIGABRT&lt;/code&gt; 신호로 프로세스를 종료합니다 .</target>
        </trans-unit>
        <trans-unit id="d259a90ce3ab2f4e634cfbde2a7c2b688963f261" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;acos()&lt;/code&gt; , returning the arcus cosine of its numerical argument. See also &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;acos()&lt;/code&gt; 와 동일 하며 숫자 인수의 아크 코사인을 반환합니다. &lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ccee1e25346b17fb481ba7f4de4b0b4f50758bcf" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;acosh()&lt;/code&gt; , returning the hyperbolic arcus cosine of its numerical argument [C99]. See also &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;acosh()&lt;/code&gt; 와 동일 하며 숫자 인수 [C99]의 쌍곡선 아크 사인을 반환합니다. &lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8333095da54e7a945d4144cea8a756431c8956dd" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;asctime()&lt;/code&gt; . It returns a string of the form</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;asctime()&lt;/code&gt; 동일합니다 . 그것은 형식의 문자열을 반환</target>
        </trans-unit>
        <trans-unit id="83275b8475bd60ebbcd493cefc6cdd7a1783a9d1" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;asin()&lt;/code&gt; , returning the arcus sine of its numerical argument. See also &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;asin()&lt;/code&gt; 과 동일 하며 숫자 인수의 아크 사인을 반환합니다. &lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="35c416500eafa9e5a5d6b613f8969a9c043a063d" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;asinh()&lt;/code&gt; , returning the hyperbolic arcus sine of its numerical argument [C99]. See also &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;asinh()&lt;/code&gt; 와 동일 하며 숫자 인수 [C99]의 쌍곡선 아크 사인을 반환합니다. &lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a1e5aa7da9f697f4c8ff8dc1fb698909d946bb08" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;atan()&lt;/code&gt; , returning the arcus tangent of its numerical argument. See also &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">이는 C 함수 &lt;code&gt;atan()&lt;/code&gt; 과 동일 하며 숫자 인수의 아크 탄젠트를 반환합니다. &lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="11f0cbd1a192e343ff198d459f44a118616c801d" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;atanh()&lt;/code&gt; , returning the hyperbolic arcus tangent of its numerical argument [C99]. See also &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;atanh()&lt;/code&gt; 와 동일 하며 숫자 인수 [C99]의 쌍곡선 아크 탄젠트를 반환합니다. &lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a1019f8f1ad013c7cb1f6add559add30196a2727" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;ceil()&lt;/code&gt; , returning the smallest integer value greater than or equal to the given numerical argument.</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;ceil()&lt;/code&gt; 과 동일하며 주어진 숫자 인수보다 크거나 같은 가장 작은 정수 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d09fd6d4a60edcd6b29ae2efeeb92f7f1a3032dc" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;clock()&lt;/code&gt; , returning the amount of spent processor time in microseconds.</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;clock()&lt;/code&gt; 과 동일하며 소비 된 프로세서 시간을 마이크로 초 단위로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ed50101b37aabb6ccd0f72bf1cd12dc057e125c6" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;cosh()&lt;/code&gt; , for returning the hyperbolic cosine of its numeric argument. See also &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">이것은 숫자 인수의 쌍곡 코사인을 반환 하는 C 함수 &lt;code&gt;cosh()&lt;/code&gt; 와 동일합니다 . &lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6f87a9c64391c986e35e0df3a461ddde69989f77" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;ctime()&lt;/code&gt; and equivalent to &lt;code&gt;asctime(&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;(...))&lt;/code&gt; , see &lt;a href=&quot;#asctime&quot;&gt;asctime&lt;/a&gt; and &lt;a href=&quot;#localtime&quot;&gt;localtime&lt;/a&gt;.</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;ctime()&lt;/code&gt; 과 동일하며 &lt;code&gt;asctime(&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;(...))&lt;/code&gt; 과 동일합니다 . &lt;a href=&quot;#asctime&quot;&gt;asctime&lt;/a&gt; 및 &lt;a href=&quot;#localtime&quot;&gt;localtime을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="98a7a8b5298975e8b4638f6e08f625101ddd94f1" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;difftime()&lt;/code&gt; , for returning the time difference (in seconds) between two times (as returned by &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt;), see &lt;a href=&quot;#time&quot;&gt;time&lt;/a&gt;.</source>
          <target state="translated">이것은 C 함수 동일 &lt;code&gt;difftime()&lt;/code&gt; 두 시간 사이에 시간 (초)의 차이를 복귀 (의해 반환 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; ) 참조 &lt;a href=&quot;#time&quot;&gt;시간&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3400f6cf25b03ffea13db374eb3a67b922b12f5c" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;floor()&lt;/code&gt; , returning the largest integer value less than or equal to the numerical argument.</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;floor()&lt;/code&gt; 와 동일하며 숫자 인수보다 작거나 같은 가장 큰 정수 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b40ee9ab2883fdc4ea6712b24d8986ecec5f39fc" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;fmod()&lt;/code&gt; .</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;fmod()&lt;/code&gt; 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="7b7a8f7914876d99686857a5b212ffa67a406bf2" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;ldexp()&lt;/code&gt; for multiplying floating point numbers with powers of two.</source>
          <target state="translated">이것은 부동 소수점 숫자에 2의 거듭 제곱을 곱하는 C 함수 &lt;code&gt;ldexp()&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="5967c218ae5e6977bcfb278510b90089a48661b4" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;log10()&lt;/code&gt; , returning the 10-base logarithm of the numerical argument. You can also use</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;log10()&lt;/code&gt; 과 동일 하며 숫자 인수의 10-베이스 로그를 반환합니다. 당신은 또한 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="d960a256a04c197a9681bc6a5b2df4621c6abcef" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;mblen()&lt;/code&gt; .</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;mblen()&lt;/code&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="72da259370ed7368b03117d248a4d69905a2aec8" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;mbstowcs()&lt;/code&gt; .</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;mbstowcs()&lt;/code&gt; 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="e9cb9e5092c37fe36ba32ebf9a50fb911920ee05" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;mbtowc()&lt;/code&gt; .</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;mbtowc()&lt;/code&gt; 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="34c30fa04962ce474f9dd2f58f200b70edfa44f9" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;perror()&lt;/code&gt; , which outputs to the standard error stream the specified message followed by &lt;code&gt;&quot;: &quot;&lt;/code&gt; and the current error string. Use the &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn()&lt;/a&gt;&lt;/code&gt; function and the &lt;code&gt;$!&lt;/code&gt; variable instead, see &lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt; and &lt;a href=&quot;perlvar#%24ERRNO&quot;&gt;$ERRNO in perlvar&lt;/a&gt;.</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;perror()&lt;/code&gt; 와 동일합니다.이 함수 는 지정된 메시지 뒤에 &lt;code&gt;&quot;: &quot;&lt;/code&gt; 및 현재 오류 문자열이 오는 표준 오류 스트림으로 출력 합니다. 사용 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn()&lt;/a&gt;&lt;/code&gt; 함수와 &lt;code&gt;$!&lt;/code&gt; 변수 대신 &lt;a href=&quot;perlvar#%24ERRNO&quot;&gt;perlvar의 &lt;/a&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt; 및 $ ERRNO를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8cc1118a61c7aca10633514f234f4da1ee0e5bc3" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;setsid()&lt;/code&gt; for setting the session identifier of the current process.</source>
          <target state="translated">이것은 현재 프로세스의 세션 식별자를 설정 하는 C 함수 &lt;code&gt;setsid()&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="a8b9a9e6d01fce018b50fa102ad5992e876d6995" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;sinh()&lt;/code&gt; for returning the hyperbolic sine of the numerical argument. See also &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">이것은 숫자 인수의 쌍곡 사인을 리턴 하는 C 함수 &lt;code&gt;sinh()&lt;/code&gt; 와 동일합니다 . &lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5620e4c58d5e806939f06354c891f33af057e241" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;strcoll()&lt;/code&gt; for collating (comparing) strings transformed using the &lt;code&gt;strxfrm()&lt;/code&gt; function. Not really needed since Perl can do this transparently, see &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="translated">이는 &lt;code&gt;strxfrm()&lt;/code&gt; 함수를 사용하여 변환 된 문자열을 대조 하는 C 함수 &lt;code&gt;strcoll()&lt;/code&gt; 과 동일 합니다. Perl이 투명하게 할 수 있기 때문에 실제로는 필요하지 않습니다 . &lt;a href=&quot;perllocale&quot;&gt;perllocale을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1c1de6e40d16de1b4908183780ee818a15a66a41" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;tan()&lt;/code&gt; , returning the tangent of the numerical argument. See also &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;tan()&lt;/code&gt; 과 동일 하며 숫자 인수의 탄젠트를 반환합니다. &lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d53070d8b102022984bacaa431429b0ea23b53bf" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;tanh()&lt;/code&gt; , returning the hyperbolic tangent of the numerical argument. See also &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt;.</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;tanh()&lt;/code&gt; 와 동일 하며 숫자 인수의 쌍곡 탄젠트를 반환합니다. &lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4339b3026b6818ba331f4b8dad83033d79b015ba" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;tcgetpgrp()&lt;/code&gt; for returning the process group identifier of the foreground process group of the controlling terminal.</source>
          <target state="translated">이것은 제어 터미널의 포 그라운드 프로세스 그룹의 프로세스 그룹 식별자를 반환 하는 C 함수 &lt;code&gt;tcgetpgrp()&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="10385672619fbe5424be8d41f4c81323dffb2c77" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;ttyname()&lt;/code&gt; for returning the name of the current terminal.</source>
          <target state="translated">이것은 현재 터미널의 이름을 반환하는 C 함수 &lt;code&gt;ttyname()&lt;/code&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="61c4adb4504ab133429c5dcca9e634dda0234fa4" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;tzset()&lt;/code&gt; for setting the current timezone based on the environment variable &lt;code&gt;TZ&lt;/code&gt; , to be used by &lt;code&gt;ctime()&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;mktime()&lt;/code&gt; , and &lt;code&gt;strftime()&lt;/code&gt; functions.</source>
          <target state="translated">이는 &lt;code&gt;ctime()&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;mktime()&lt;/code&gt; 및 &lt;code&gt;strftime()&lt;/code&gt; 함수에서 사용되는 환경 변수 &lt;code&gt;TZ&lt;/code&gt; 를 기반으로 현재 시간대를 설정 하는 C 함수 &lt;code&gt;tzset()&lt;/code&gt; 과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="6eac2e9b93151c25128e8b44336e559f1ca26691" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;wcstombs()&lt;/code&gt; .</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;wcstombs()&lt;/code&gt; 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="6531eaab1a3fcd3d02f83fe194ba892352425032" translate="yes" xml:space="preserve">
          <source>This is identical to the C function &lt;code&gt;wctomb()&lt;/code&gt; .</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;wctomb()&lt;/code&gt; 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="2b638e3d48a14e811a63d8a3b93348f1843f5897" translate="yes" xml:space="preserve">
          <source>This is identical to the C function, except that it can apply to a single character or to a whole string, and currently operates as if the locale always is &quot;C&quot;. Consider using the &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt; function, see &lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;, see &lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;, or the equivalent &lt;code&gt;\L&lt;/code&gt; operator inside doublequotish strings.</source>
          <target state="translated">이는 단일 문자 또는 전체 문자열에 적용 할 수 있다는 점을 제외하고 C 함수와 동일하며 현재 로케일이 항상 &quot;C&quot;인 것처럼 작동합니다. &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt; 함수 사용을 고려 하십시오. &lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt; 참조, &lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt; 참조 또는 큰 따옴표 안에 있는 동등한 &lt;code&gt;\L&lt;/code&gt; 연산자.</target>
        </trans-unit>
        <trans-unit id="30976c7fff7754f905b7e098aaebc37d849842e9" translate="yes" xml:space="preserve">
          <source>This is identical to the C function, except the order of arguments is consistent with Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; with the added restriction of only one path, not a list of paths. Does the same thing as the &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; function but changes the owner of a symbolic link instead of the file the symbolic link points to.</source>
          <target state="translated">인수 순서가 경로 목록이 아닌 하나의 경로 만 추가 된 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; 과 일치한다는 점을 제외하면 C 함수와 동일합니다 . &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; 함수 와 동일 하지만 심볼릭 링크가 가리키는 파일 대신 심볼릭 링크의 소유자를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="cec15e827312e3918cb71e034a41abdc4f73a598" translate="yes" xml:space="preserve">
          <source>This is identical to the DL_FUNCS attribute available via MakeMaker, from which it is usually taken. Its value is a reference to an associative array, in which each key is the name of a package, and each value is an a reference to an array of function names which should be exported by the extension. For instance, one might say &lt;code&gt;DL_FUNCS =&amp;gt; { Homer::Iliad =&amp;gt; [ qw(trojans greeks) ],
Homer::Odyssey =&amp;gt; [ qw(travellers family suitors) ] }&lt;/code&gt; . The function names should be identical to those in the XSUB code; &lt;code&gt;Mksymlists&lt;/code&gt; will alter the names written to the linker option file to match the changes made by</source>
          <target state="translated">이것은 일반적으로 사용되는 MakeMaker를 통해 사용 가능한 DL_FUNCS 속성과 동일합니다. 값은 연관 배열에 대한 참조이며, 각 키는 패키지의 이름이고, 각 값은 확장에 의해 내 보내야하는 함수 이름의 배열에 대한 참조입니다. 예를 들어 &lt;code&gt;DL_FUNCS =&amp;gt; { Homer::Iliad =&amp;gt; [ qw(trojans greeks) ], Homer::Odyssey =&amp;gt; [ qw(travellers family suitors) ] }&lt;/code&gt; 라고 말할 수 있습니다 . 함수 이름은 XSUB 코드와 동일해야합니다. &lt;code&gt;Mksymlists&lt;/code&gt; 는 링커 옵션 파일에 작성된 이름을 변경하여</target>
        </trans-unit>
        <trans-unit id="310f96db114f72f372da9166d69a4cc6f2cae9b1" translate="yes" xml:space="preserve">
          <source>This is identical to the DL_VARS attribute available via MakeMaker, and, like DL_FUNCS, it is usually specified via MakeMaker. Its value is a reference to an array of variable names which should be exported by the extension.</source>
          <target state="translated">이는 MakeMaker를 통해 사용 가능한 DL_VARS 속성과 동일하며 DL_FUNCS와 마찬가지로 일반적으로 MakeMaker를 통해 지정됩니다. 그 값은 확장명이 내 보내야하는 변수 이름의 배열에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="b412f9ab149e41469d7ba2eef653a9c88721e439" translate="yes" xml:space="preserve">
          <source>This is identical to the macro &lt;a href=&quot;#isUTF8_CHAR&quot;&gt;isUTF8_CHAR&lt;/a&gt;.</source>
          <target state="translated">매크로 &lt;a href=&quot;#isUTF8_CHAR&quot;&gt;isUTF8_CHAR&lt;/a&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="6cee0007e2daab07905e6dc7537e69cd21d5b2ba" translate="yes" xml:space="preserve">
          <source>This is ignored by most formatters, but some may use it for building indexes. It always renders as empty-string. Example: &lt;code&gt;X&amp;lt;absolutizing relative URLs&amp;gt;&lt;/code&gt;</source>
          <target state="translated">대부분의 포맷터에서는이를 무시하지만 일부는 인덱스 작성에 사용할 수 있습니다. 항상 빈 문자열로 렌더링됩니다. 예 : &lt;code&gt;X&amp;lt;absolutizing relative URLs&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="be9929994c9a23587b60ac75552db3fe41c07468" translate="yes" xml:space="preserve">
          <source>This is implemented as a macro.</source>
          <target state="translated">이것은 매크로로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="667c85db18e1907f43da9d70ad90da9e90ed961a" translate="yes" xml:space="preserve">
          <source>This is important because miniperl, used to build XS modules in the core, can not load XS.</source>
          <target state="translated">코어에 XS 모듈을 빌드하는 데 사용되는 miniperl이 XS를로드 할 수 없기 때문에 이것은 중요합니다.</target>
        </trans-unit>
        <trans-unit id="144222a27e6ef028e4173cd0825a23a1090abbf3" translate="yes" xml:space="preserve">
          <source>This is in contrast to many other dynamic languages, where the operation is determined by the type of the first argument. It also means that Perl has two versions of some operators, one for numeric and one for string comparison. For example &lt;code&gt;$x == $y&lt;/code&gt; compares two numbers for equality, and &lt;code&gt;$x &lt;a href=&quot;functions/eq&quot;&gt;eq&lt;/a&gt; $y&lt;/code&gt; compares two strings.</source>
          <target state="translated">이것은 다른 많은 동적 언어와 대조적으로 작동이 첫 번째 인수의 유형에 의해 결정됩니다. 또한 Perl에는 숫자와 문자열 비교를위한 두 가지 버전의 일부 연산자가 있음을 의미합니다. 예를 들어 &lt;code&gt;$x == $y&lt;/code&gt; 는 두 숫자가 같은지 비교하고 &lt;code&gt;$x &lt;a href=&quot;functions/eq&quot;&gt;eq&lt;/a&gt; $y&lt;/code&gt; 는 두 문자열을 비교합니다.</target>
        </trans-unit>
        <trans-unit id="17fded423d74ecd2cac30cc09f0fef74a562c96a" translate="yes" xml:space="preserve">
          <source>This is intended for authors of modules which do lots of class introspection, as it allows them to very quickly check if anything important about the local properties of a given class have changed since the last time they looked. It does not increment on method/&lt;code&gt;@ISA&lt;/code&gt; changes in superclasses.</source>
          <target state="translated">이것은 많은 클래스 내부 검사를 수행하는 모듈 작성자를 대상으로합니다. 마지막으로 본 이후 지정된 클래스의 로컬 속성에 중요한 것이 변경되었는지 매우 빠르게 확인할 수 있기 때문입니다. 수퍼 클래스 에서 메소드 / &lt;code&gt;@ISA&lt;/code&gt; 변경시 증가하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8048e3a62929d8c0b743c4d8a83b98f6eb0f81fb" translate="yes" xml:space="preserve">
          <source>This is intended to largely replace the deprecated pseudo-hashes.</source>
          <target state="translated">이것은 더 이상 사용되지 않는 의사 해시를 대체하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="db4b800255fcc3a17f2b811fc2b88aebde232685" translate="yes" xml:space="preserve">
          <source>This is invalid because every &quot;=end&quot; command must have a formatname parameter.</source>
          <target state="translated">모든 &quot;= end&quot;명령에 formatname 매개 변수가 있어야하므로 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="61a2277b2bd23db81a91f83c4d1f3dd9feb9a041" translate="yes" xml:space="preserve">
          <source>This is just a basic proof of concept. It should be seriously expanded to support configurable coloration via options passed to the constructor, and &lt;b&gt;pod2text&lt;/b&gt; should be taught about those.</source>
          <target state="translated">이것은 단지 기본 개념 증명입니다. 생성자에게 전달 된 옵션을 통해 구성 가능한 채색을 지원하도록 심각하게 확장 되어야하며 &lt;b&gt;pod2text&lt;/b&gt; 에 대해 &lt;b&gt;알려야&lt;/b&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="68c9d184917794ed93e7fda1e4971f91e0c45375" translate="yes" xml:space="preserve">
          <source>This is just a beta release -- there are a good number of things still left to do. Notably, support for EBCDIC platforms is still half-done, an untested.</source>
          <target state="translated">이것은 베타 버전 일뿐입니다. 아직해야 할 일이 많습니다. 특히 EBCDIC 플랫폼에 대한 지원은 아직 완료되지 않았으며 아직 테스트되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="219ed1315313e10e560072058c3673015172eb8a" translate="yes" xml:space="preserve">
          <source>This is just a quick start guide. For a more in-depth tutorial on regexes, see &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt; and for the reference page, see &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">이것은 빠른 시작 안내서 일뿐입니다. &lt;a href=&quot;perlretut&quot;&gt;정규 표현식&lt;/a&gt; 에 대한 자세한 자습서는 perlretut 를 참조하고 참조 페이지는 &lt;a href=&quot;perlre&quot;&gt;perlre를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="285e57010c635f262d70613679ce183fe2c1fc6d" translate="yes" xml:space="preserve">
          <source>This is just a restatement of the previous section. Unless you are completely certain you know what you are doing, avoid mixing filtered &amp;amp; non-filtered data.</source>
          <target state="translated">이것은 이전 섹션의 설명입니다. 자신이하고있는 일을 완전히 확신하지 않는 한 필터링 된 데이터와 필터링되지 않은 데이터를 혼합하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="0eb6c125a87601bb415e7dd8ac4261d5f4ccd383" translate="yes" xml:space="preserve">
          <source>This is just a shorthand for a typeglob assignment at compile time:</source>
          <target state="translated">이것은 컴파일 타임에 타입 글로브 할당의 약어입니다.</target>
        </trans-unit>
        <trans-unit id="15b35232b5a8087ae488ff75565de5703f14864d" translate="yes" xml:space="preserve">
          <source>This is just a tutorial. For the full story on Perl regular expressions, see the &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; regular expressions reference page.</source>
          <target state="translated">이것은 단지 튜토리얼입니다. Perl 정규 표현식에 대한 전체 내용은 &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; 정규 표현식 참조 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9456d5890fbed572d26379cc56324c8cfe828e36" translate="yes" xml:space="preserve">
          <source>This is just a wrapper around Perl's normal &lt;code&gt;&lt;a href=&quot;../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; function. It's provided so that you can use &quot;sprintf&quot; in Bracket Notation:</source>
          <target state="translated">이것은 Perl의 일반적인 &lt;code&gt;&lt;a href=&quot;../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 함수를 둘러싼 래퍼 입니다. 대괄호 표기법에서 &quot;sprintf&quot;를 사용할 수 있도록 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="77266324e65b81993bcee36043a748db86e77bf5" translate="yes" xml:space="preserve">
          <source>This is just an alias for $ctx-&amp;gt;new.</source>
          <target state="translated">이것은 $ ctx-&amp;gt; new의 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="4341fe03623ad4301c3243c214057adf6cd69228" translate="yes" xml:space="preserve">
          <source>This is just an alias for $md5-&amp;gt;new.</source>
          <target state="translated">이것은 $ md5-&amp;gt; new의 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="abb98ec9f418273dc2ca6cd9acdcab91a8675d3b" translate="yes" xml:space="preserve">
          <source>This is just like get_title, except that it returns just the modulename, if the title seems to be of the form &quot;SomeModuleName -- description&quot;.</source>
          <target state="translated">제목이 &quot;SomeModuleName-description&quot;형식 인 경우 모듈 이름 만 반환한다는 점을 제외하면 get_title과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3efe951774b37c8f5ed5c70b61d80e43335a5d14" translate="yes" xml:space="preserve">
          <source>This is just like the &lt;code&gt;m/&lt;i&gt;PATTERN&lt;/i&gt;/&lt;/code&gt; search, except that it matches only once between calls to the &lt;code&gt;&lt;a href=&quot;functions/reset&quot;&gt;reset()&lt;/a&gt;&lt;/code&gt; operator. This is a useful optimization when you want to see only the first occurrence of something in each file of a set of files, for instance. Only &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m??&lt;/a&gt;&lt;/code&gt; patterns local to the current package are reset.</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;functions/reset&quot;&gt;reset()&lt;/a&gt;&lt;/code&gt; 연산자 호출 사이에 한 번만 일치한다는 점을 제외 하면 &lt;code&gt;m/&lt;i&gt;PATTERN&lt;/i&gt;/&lt;/code&gt; search 와 같습니다 . 예를 들어 파일 세트의 각 파일에서 처음 나타나는 항목 만 보려는 경우 유용한 최적화입니다. 오직 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m??&lt;/a&gt;&lt;/code&gt; 현재 패키지에 로컬 인 패턴이 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="d1f273b15a0cb3300a978b7939f344dd1d08639d" translate="yes" xml:space="preserve">
          <source>This is like &lt;code&gt;&quot;a&quot;&lt;/code&gt; , but some elements are the empty string, and should not be adjusted. The one internal Perl property accessible by &lt;code&gt;prop_invmap&lt;/code&gt; is of this type: &quot;Perl_Decimal_Digit&quot; returns an inversion map which gives the numeric values that are represented by the Unicode decimal digit characters. Characters that don't represent decimal digits map to the empty string, like so:</source>
          <target state="translated">이것은 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 와 같지만 일부 요소는 빈 문자열이므로 조정할 수 없습니다. &lt;code&gt;prop_invmap&lt;/code&gt; 으로 액세스 할 수있는 내부 Perl 특성 중 하나 는이 유형입니다. &quot;Perl_Decimal_Digit&quot;는 유니 코드 10 진수 문자로 표시되는 숫자 값을 제공하는 반전 맵을 리턴합니다. 10 진수를 나타내지 않는 문자는 다음과 같이 빈 문자열에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="4c2c127a4acabd567283fc3055323b13e8a32015" translate="yes" xml:space="preserve">
          <source>This is like the SMTP transport, but uses TLS security. You can authenticate with this module as well, using any mechanisms your server supports after STARTTLS.</source>
          <target state="translated">이것은 SMTP 전송과 비슷하지만 TLS 보안을 사용합니다. STARTTLS 이후 서버가 지원하는 메커니즘을 사용하여이 모듈로 인증 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee19061e56d9213c77400710440b7c20343ebe03" translate="yes" xml:space="preserve">
          <source>This is mainly useful for constructing bitmaps for &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; and low-level POSIX tty-handling operations. If FILEHANDLE is an expression, the value is taken as an indirect filehandle, generally its name.</source>
          <target state="translated">이는 주로 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 및 저수준 POSIX tty 처리 작업을 위한 비트 맵을 구성하는 데 유용 합니다. FILEHANDLE이 표현식 인 경우 값은 간접 파일 핸들 (일반적으로 이름)로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4451800d0e0114802550054b61665e033a2b00a5" translate="yes" xml:space="preserve">
          <source>This is mainly useful for constructing bitmaps for &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; and low-level POSIX tty-handling operations. If FILEHANDLE is an expression, the value is taken as an indirect filehandle, generally its name.</source>
          <target state="translated">이는 주로 &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 및 저수준 POSIX tty 처리 작업을 위한 비트 맵을 구성하는 데 유용 합니다. FILEHANDLE이 표현식 인 경우 값은 간접 파일 핸들 (일반적으로 이름)로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="37ce9a12e2723922e8bd944d2d5d67e411bc7f1f" translate="yes" xml:space="preserve">
          <source>This is merely a synonym for &lt;code&gt;as_string&lt;/code&gt; .</source>
          <target state="translated">이것은 &lt;code&gt;as_string&lt;/code&gt; 과 동의어 일뿐 입니다.</target>
        </trans-unit>
        <trans-unit id="4dab1c8c1fba88ee26cb0159afceae84eeab9c5c" translate="yes" xml:space="preserve">
          <source>This is more portable than the raw &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt;, but not as illustrative:</source>
          <target state="translated">이것은 원시 &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; 보다 이식성이 뛰어나지 만 실례는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e4ef392975ecd504b3ac95743d2709331ec1fc38" translate="yes" xml:space="preserve">
          <source>This is neither a specimen of simplicity nor a paragon of portability but it illustrates the point: We are able to sneak behind the scenes and access Perl's otherwise well-guarded memory! (Important note: Perl's &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; does</source>
          <target state="translated">이것은 단순성의 표본이나 이식성의 모범이 아니지만 요점을 보여줍니다. 우리는 무대 뒤에서 몰래 들어와 Perl의 잘 보호 된 기억에 접근 할 수 있습니다! (중요한 메모 : Perl의 &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="10ebf1cbe04784f38db52da63b8ec5a60455457d" translate="yes" xml:space="preserve">
          <source>This is normally all you need to know. However, many options are available:</source>
          <target state="translated">이것은 일반적으로 당신이 알아야 할 전부입니다. 그러나 많은 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d00bfe25391751730fea233731dd8b0f5f6ab569" translate="yes" xml:space="preserve">
          <source>This is not &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;, which tells you how to use the debugger. This manpage describes low-level details concerning the debugger's internals, which range from difficult to impossible to understand for anyone who isn't incredibly intimate with Perl's guts. Caveat lector.</source>
          <target state="translated">이것은 &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt; 가 아니며 디버거 사용 방법을 알려줍니다. 이 맨 페이지는 디버거의 내부에 관한 저수준의 세부 사항을 설명합니다. Perl의 내장에 굉장히 친밀하지 않은 사람에게는 이해하기 어렵거나 불가능합니다. 주의 사항 강사.</target>
        </trans-unit>
        <trans-unit id="f404a9e2e0db79bb4f43c8d7bbb05496d430ba62" translate="yes" xml:space="preserve">
          <source>This is not a general purpose Unicode to byte encoding interface: use the Encode extension for that.</source>
          <target state="translated">이것은 일반적인 유니 코드에서 바이트 인코딩 인터페이스가 아닙니다.이를 위해 Encode 확장을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7457d8ee09385437d0b615e7e131b4e9c0b973a9" translate="yes" xml:space="preserve">
          <source>This is not a general purpose byte encoding to Unicode interface: use the Encode extension for that.</source>
          <target state="translated">이것은 유니 코드 인터페이스에 대한 범용 바이트 인코딩이 아닙니다.이를 위해 Encode 확장을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d116bb6d0c3c84c2243b689bc93fe4a6155eb5cb" translate="yes" xml:space="preserve">
          <source>This is not as short as before, but it makes it more obvious that we intend to have little-endian byte-order for a whole group, not only for individual template codes. It can also be more readable and easier to maintain.</source>
          <target state="translated">이것은 이전만큼 짧지는 않지만 개별 템플릿 코드뿐만 아니라 전체 그룹에 리틀 엔디안 바이트 순서를 가지고 있음을 더 분명하게합니다. 또한 더 읽기 쉽고 유지 관리하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="21c82389f9ec1dc190c296dba01242b89223a846" translate="yes" xml:space="preserve">
          <source>This is not ideal, but it seems to be the best compromise. If it doesn't work for you, please let me know the details of how it broke.</source>
          <target state="translated">이것은 이상적이지는 않지만 최선의 절충안 인 것 같습니다. 그래도 문제가 해결되지 않으면 어떻게 파산했는지 자세히 알려주십시오.</target>
        </trans-unit>
        <trans-unit id="a8f2331f9105fa67d4e126b8930145be58fae503" translate="yes" xml:space="preserve">
          <source>This is not ok:</source>
          <target state="translated">이것은 좋지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="909f3f0de148a4f0a784930ff89af77cea3c7576" translate="yes" xml:space="preserve">
          <source>This is not really a &quot;severe&quot; error, but it is supposed to be raised by default even if warnings are not enabled, and currently the only way to do that in Perl is to mark it as serious.</source>
          <target state="translated">이 오류는 실제로 &quot;심각한&quot;오류는 아니지만 경고를 사용하지 않는 경우에도 기본적으로 발생해야하며 현재 Perl에서이를 수행하는 유일한 방법은 오류로 심각하게 표시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="197111743c19bce55304223ee2f18830ead89426" translate="yes" xml:space="preserve">
          <source>This is not the normal way to consume lexed text. For that, use &lt;a href=&quot;#lex_read_to&quot;&gt;lex_read_to&lt;/a&gt;.</source>
          <target state="translated">이것은 어휘 텍스트를 소비하는 일반적인 방법이 아닙니다. 이를 위해 &lt;a href=&quot;#lex_read_to&quot;&gt;lex_read_to를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3f9e6c0b666a1af0815bd174af9f121c2162997f" translate="yes" xml:space="preserve">
          <source>This is not the right answer at all, but the sum looks correct. I wonder if it's anything to do with operator precedence? We'll try a couple of other possibilities with our sum:</source>
          <target state="translated">이것은 정답이 아니지만 합계는 정확 해 보입니다. 연산자 우선 순위와 관련이 있는지 궁금합니다. 우리는 우리의 합으로 몇 가지 다른 가능성을 시도 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="8a04fbe62aa8087e67610ad69a72c7364e385eaa" translate="yes" xml:space="preserve">
          <source>This is not the sigil you use in front of an array name to get the last index, like &lt;code&gt;$#array&lt;/code&gt; . That's still how you get the last index of an array in Perl. The two have nothing to do with each other.</source>
          <target state="translated">&lt;code&gt;$#array&lt;/code&gt; 와 같이 마지막 색인을 얻기 위해 배열 이름 앞에서 사용하는 시일이 아닙니다 . 이것이 여전히 Perl에서 배열의 마지막 인덱스를 얻는 방법입니다. 두 사람은 서로 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="a71eefb6bc615d22ea75cd4d866e05c590f48f94" translate="yes" xml:space="preserve">
          <source>This is not to say that Perl threads are completely different from everything that's ever come before. They're not. Perl's threading model owes a lot to other thread models, especially POSIX. Just as Perl is not C, though, Perl threads are not POSIX threads. So if you find yourself looking for mutexes, or thread priorities, it's time to step back a bit and think about what you want to do and how Perl can do it.</source>
          <target state="translated">이것은 Perl 스레드가 이전의 모든 것과 완전히 다르다는 것을 말하는 것은 아닙니다. 그들은 아니다. Perl의 스레딩 모델은 다른 스레드 모델, 특히 POSIX에 많이 의존합니다. Perl이 C가 아닌 것처럼 Perl 스레드는 POSIX 스레드가 아닙니다. 따라서 뮤텍스 또는 스레드 우선 순위를 찾고 있다면 조금 뒤로 물러서서 원하는 작업과 펄이 어떻게 할 수 있는지 생각할 때입니다.</target>
        </trans-unit>
        <trans-unit id="1490fa72c1eafb91d46399cb68efda52398b105d" translate="yes" xml:space="preserve">
          <source>This is not very useful, and perl currently optimizes this away.</source>
          <target state="translated">이것은별로 유용하지 않으며 perl은 현재이를 최적화합니다.</target>
        </trans-unit>
        <trans-unit id="719ad110f9ecd2d06449f518fe559ae60b466e21" translate="yes" xml:space="preserve">
          <source>This is now the recommended interface to install().</source>
          <target state="translated">이것은 현재 install ()에 권장되는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="8dd3c5aefc65986cd4924a120675ce7dc9b1881f" translate="yes" xml:space="preserve">
          <source>This is of paramount importance, since it's the documentation of what goes where in the Perl source. Read it over a couple of times and it might start to make sense - don't worry if it doesn't yet, because the best way to study it is to read it in conjunction with poking at Perl source, and we'll do that later on.</source>
          <target state="translated">이것은 Perl 소스에서 어디로 가는지에 대한 문서이므로 가장 중요합니다. 몇 번에 걸쳐 읽으면 이해하기 시작합니다. 아직 이해가되지 않더라도 걱정하지 마십시오. 공부하는 가장 좋은 방법은 Perl 소스의 파킹과 함께 읽는 것이므로 우리는 할 것입니다. 나중에.</target>
        </trans-unit>
        <trans-unit id="fadd54f30e37dbf502c0a6893df00ea6b04ab979" translate="yes" xml:space="preserve">
          <source>This is often useful if you need to check the current Perl version before &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;ing library modules that won't work with older versions of Perl. (We try not to do this more than we have to.)</source>
          <target state="translated">이전 버전의 Perl에서 작동하지 않는 라이브러리 모듈을 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 하기 전에 현재 Perl 버전을 확인해야하는 경우에 유용합니다 . (우리는 이보다 더 많은 일을하지 않기 위해 노력합니다.)</target>
        </trans-unit>
        <trans-unit id="96345383ecfecda78d417eea671d77452c1d163e" translate="yes" xml:space="preserve">
          <source>This is often useful if you need to check the current Perl version before &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;ing library modules that won't work with older versions of Perl. (We try not to do this more than we have to.)</source>
          <target state="translated">이전 버전의 Perl에서 작동하지 않는 라이브러리 모듈을 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 하기 전에 현재 Perl 버전을 확인해야하는 경우에 유용합니다 . (우리는 이보다 더 많은 일을하지 않기 위해 노력합니다.)</target>
        </trans-unit>
        <trans-unit id="b7065d0815c75fb916f5ccef644a97fc5f9a5ab5" translate="yes" xml:space="preserve">
          <source>This is one of the cases we mentioned earlier in which references could spring into existence when in an lvalue context. Before this statement, &lt;code&gt;$array[$x]&lt;/code&gt; may have been undefined. If so, it's automatically defined with a hash reference so that we can look up &lt;code&gt;{&quot;foo&quot;}&lt;/code&gt; in it. Likewise &lt;code&gt;$array[$x]-&amp;gt;{&quot;foo&quot;}&lt;/code&gt; will automatically get defined with an array reference so that we can look up &lt;code&gt;[0]&lt;/code&gt; in it. This process is called</source>
          <target state="translated">이것은 lvalue 컨텍스트에서 참조가 생길 수있는 앞에서 언급 한 사례 중 하나입니다. 이 문장 이전에 &lt;code&gt;$array[$x]&lt;/code&gt; 가 정의되지 않았을 수 있습니다. 그렇다면 해시 참조로 자동 정의되므로 &lt;code&gt;{&quot;foo&quot;}&lt;/code&gt; 를 찾을 수 있습니다. 마찬가지로 &lt;code&gt;$array[$x]-&amp;gt;{&quot;foo&quot;}&lt;/code&gt; 는 배열 참조로 자동 정의되어 &lt;code&gt;[0]&lt;/code&gt; 을 찾을 수 있습니다. 이 과정을</target>
        </trans-unit>
        <trans-unit id="6a3344e74e174252dc0aef67360fb712feea83d3" translate="yes" xml:space="preserve">
          <source>This is one of the only places where giving a prototype to a closure makes much sense. If you wanted to impose scalar context on the arguments of these functions (probably not a wise idea for this particular example), you could have written it this way instead:</source>
          <target state="translated">클로저에 프로토 타입을 제공하는 것이 의미가있는 유일한 곳 중 하나입니다. 이 함수의 인수에 스칼라 컨텍스트를 적용하려면 (이 특정 예제에서는 현명한 아이디어는 아닐 것입니다) 대신 다음과 같이 작성했을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8815273ee560d0448d9c01c105592b19a9f70fd8" translate="yes" xml:space="preserve">
          <source>This is only present when &lt;code&gt;netorder&lt;/code&gt; is FALSE. It is the $Config{byteorder} string of the perl that created this image. It is a string like &quot;1234&quot; (32 bit little endian) or &quot;87654321&quot; (64 bit big endian). This must match the current perl for the image to be readable by Storable.</source>
          <target state="translated">&lt;code&gt;netorder&lt;/code&gt; 가 FALSE 인 경우에만 존재 합니다. 이 이미지를 작성한 것은 perl의 $ Config {byteorder} 문자열입니다. &quot;1234&quot;(32 비트 리틀 엔디안) 또는 &quot;87654321&quot;(64 비트 빅 엔디안)과 같은 문자열입니다. Storable이 이미지를 읽을 수있게하려면 현재 perl과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="84ff724c95d2598efdb8d7d443f2851d8e9c24b5" translate="yes" xml:space="preserve">
          <source>This is only required on some platforms which do not handle dependent libraries automatically. For example the Socket Perl extension library (</source>
          <target state="translated">종속 라이브러리를 자동으로 처리하지 않는 일부 플랫폼에서만 필요합니다. 예를 들어 Socket Perl 확장 라이브러리 (</target>
        </trans-unit>
        <trans-unit id="3167fd37c36e8874785bfe9f3f3013cce7f288bd" translate="yes" xml:space="preserve">
          <source>This is open source software. The code repository is available for public review and contribution under the terms of the license.</source>
          <target state="translated">이것은 오픈 소스 소프트웨어입니다. 코드 저장소는 라이센스 조건에 따라 공개 검토 및 기고가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="bcfe5a91a20366b07a20b45c08c83d2cb3335747" translate="yes" xml:space="preserve">
          <source>This is our final regexp. To recap, we built a regexp by</source>
          <target state="translated">이것이 최종 정규 표현식입니다. 요약하자면, 우리는 정규 표현식을</target>
        </trans-unit>
        <trans-unit id="55cbe19c15cda5405c9b99032930566aa6e4cd4b" translate="yes" xml:space="preserve">
          <source>This is parsed as:</source>
          <target state="translated">이것은 다음과 같이 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="4f7853da7a16df56ba94a3f89eeeb6c41db7cabc" translate="yes" xml:space="preserve">
          <source>This is partially implemented now.</source>
          <target state="translated">이것은 부분적으로 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="2a6f22dd0203804895067e4cd94d48784411f916" translate="yes" xml:space="preserve">
          <source>This is particularly useful for dynamic patterns, such as those read in from a configuration file, taken from an argument, or specified in a table somewhere. Consider the case where some patterns want to be case-sensitive and some do not: The case-insensitive ones merely need to include &lt;code&gt;(?i)&lt;/code&gt; at the front of the pattern. For example:</source>
          <target state="translated">이것은 구성 파일에서 읽거나, 인수에서 가져 오거나, 어딘가에 테이블에 지정된 것과 같은 동적 패턴에 특히 유용합니다. 대소 문자를 구분하지 않고 일부 패턴은 대소 문자를 구분하지 않으려는 경우를 고려하십시오. 대소 문자를 구분하지 않는 패턴은 패턴 앞에 &lt;code&gt;(?i)&lt;/code&gt; 만 포함 하면됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aaa59114ea7716b61a1b0ecf212fbfdac38cd5ec" translate="yes" xml:space="preserve">
          <source>This is particularly useful if you have More Than One Way (tm) to solve a problem in a program, and only wish to continue down a path if all modules could be loaded, and not load them if they couldn't.</source>
          <target state="translated">프로그램에서 문제를 해결하기 위해 여러 가지 방법 (tm)을 사용하고 모든 모듈을로드 할 수있는 경우 경로를 계속 진행하고로드 할 수없는 경우로드하지 않으려는 경우 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7f5141125aa28c42d6dec636c32fcbaa85fe78c3" translate="yes" xml:space="preserve">
          <source>This is particularly useful when applied to code references returned from reval().</source>
          <target state="translated">reval ()에서 반환 된 코드 참조에 적용 할 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="3afdcef939cf6d1f8b0ef2be038cdb0c7d7984fa" translate="yes" xml:space="preserve">
          <source>This is powerful, and slightly dangerous, in that it's possible to intend (with the utmost sincerity) to use a hard reference, and accidentally use a symbolic reference instead. To protect against that, you can say</source>
          <target state="translated">이것은 강력하고 약간 위험합니다. (최대한 성실로) 단단한 참조를 사용하고 실수로 기호 참조를 사용하는 것이 가능합니다. 그것을 막기 위해, 당신은 말할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="1d61b3fe5532441244041a6185a4d7b90b80ec48" translate="yes" xml:space="preserve">
          <source>This is primarily meant for the use of modules such as FTP where passwords are sent, but we do not want to display them in the debugging information.</source>
          <target state="translated">이것은 주로 암호가 전송되는 FTP와 같은 모듈을 사용하기위한 것이지만 디버깅 정보에는 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="01c91853268ed50e9d0a33c6896652af44de4d99" translate="yes" xml:space="preserve">
          <source>This is primarily of use for people who repackage Perl modules.</source>
          <target state="translated">이것은 주로 Perl 모듈을 다시 포장하는 사람들에게 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="831dab0bf255edc5ba7e605462344bdbe78142e8" translate="yes" xml:space="preserve">
          <source>This is primarily used inside &lt;code&gt;(?{...})&lt;/code&gt; blocks for examining text recently matched. For example, to effectively capture text to a variable (in addition to &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , etc.), replace &lt;code&gt;(...)&lt;/code&gt; with</source>
          <target state="translated">이것은 최근에 일치 한 텍스트를 검사하기 위해 &lt;code&gt;(?{...})&lt;/code&gt; 블록 내부에서 주로 사용됩니다 . 예를 들어, &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; 등 의 변수에 텍스트를 효과적으로 캡처하려면 &lt;code&gt;(...)&lt;/code&gt; 를</target>
        </trans-unit>
        <trans-unit id="43405231d7a3fc726c046090388674dddde66ec5" translate="yes" xml:space="preserve">
          <source>This is primarily useful for install scripts.</source>
          <target state="translated">이것은 주로 설치 스크립트에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="71555351eedbd86160cbba934f94d326494c3535" translate="yes" xml:space="preserve">
          <source>This is printf() equivalent. printf is #defined to this function, so it is (currently) legal to use &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf(fmt,...)&lt;/a&gt;&lt;/code&gt; in perl sources.</source>
          <target state="translated">이것은 printf ()와 동일합니다. printf는이 함수에 # 정의되어 있으므로, 현재 perl 소스에서 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf(fmt,...)&lt;/a&gt;&lt;/code&gt; 를 사용하는 것이 합법적 입니다.</target>
        </trans-unit>
        <trans-unit id="4ea35349c6ed8d6a98b7de634d09f57721480861" translate="yes" xml:space="preserve">
          <source>This is private to the Perl core and subject to change. Should be left null.</source>
          <target state="translated">이것은 Perl 코어 전용이며 변경 될 수 있습니다. null로 남겨 두어야합니다.</target>
        </trans-unit>
        <trans-unit id="98fa02440d9fac9b73c470e7ca881854b6795009" translate="yes" xml:space="preserve">
          <source>This is probably not what you want to use, you probably wanted &lt;a href=&quot;#sv_usepvn_flags&quot;&gt;sv_usepvn_flags&lt;/a&gt; or &lt;a href=&quot;#sv_setpvn&quot;&gt;sv_setpvn&lt;/a&gt; or &lt;a href=&quot;#sv_setpvs&quot;&gt;sv_setpvs&lt;/a&gt;.</source>
          <target state="translated">이것은 아마도 당신이 사용하려는 것이 아니며, 아마도 &lt;a href=&quot;#sv_usepvn_flags&quot;&gt;sv_usepvn_flags&lt;/a&gt; 또는 &lt;a href=&quot;#sv_setpvn&quot;&gt;sv_setpvn&lt;/a&gt; 또는 &lt;a href=&quot;#sv_setpvs&quot;&gt;sv_setpvs를 원했을 것&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="697287005f5cb5ed6d011d9e5061126f21f55b05" translate="yes" xml:space="preserve">
          <source>This is provided as a more readable version of &lt;code&gt;if (!&lt;i&gt;condition&lt;/i&gt;)&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;if (!&lt;i&gt;condition&lt;/i&gt;)&lt;/code&gt; 의보다 읽기 쉬운 버전으로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="4cabb9b2376d3134de9c8bd807fc2548baba2fca" translate="yes" xml:space="preserve">
          <source>This is quite different, however, from not even trusting the writer of the code not to try to do something evil. That's the kind of trust needed when someone hands you a program you've never seen before and says, &quot;Here, run this.&quot; For that kind of safety, you might want to check out the Safe module, included standard in the Perl distribution. This module allows the programmer to set up special compartments in which all system operations are trapped and namespace access is carefully controlled. Safe should not be considered bullet-proof, though: it will not prevent the foreign code to set up infinite loops, allocate gigabytes of memory, or even abusing perl bugs to make the host interpreter crash or behave in unpredictable ways. In any case it's better avoided completely if you're really concerned about security.</source>
          <target state="translated">그러나 이것은 악의적 인 일을하지 않기 위해 코드 작성자를 신뢰하지 않는 것과는 상당히 다릅니다. 그것은 당신이 전에 보지 못했던 프로그램을 누군가가 당신에게 건네 줄 때 필요한 신뢰입니다. &quot;여기, 이것을 실행하십시오.&quot; 이러한 종류의 안전을 위해 Perl 배포에 표준이 포함 된 안전 모듈을 확인하십시오. 이 모듈을 사용하면 프로그래머가 모든 시스템 작업이 트랩되고 네임 스페이스 액세스가 신중하게 제어되는 특수 구획을 설정할 수 있습니다. 안전은 방탄으로 간주되어서는 안됩니다. 외부 코드가 무한 루프를 설정하거나 기가 바이트의 메모리를 할당하거나 펄 버그를 학대하여 호스트 인터프리터가 충돌하거나 예측할 수없는 방식으로 작동하지 못하게하지는 않습니다. 어쨌든 보안에 정말로 관심이 있다면 완전히 피하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fc844a09760bd8a2dc9b577b36da09548b575605" translate="yes" xml:space="preserve">
          <source>This is quite typical for .xs files: usually the .xs file provides an interface to an existing C function. Then this C function is defined somewhere (either in an external library, or in the first part of .xs file), and a Perl interface to this function (i.e. &quot;Perl glue&quot;) is described in the second part of .xs file. The situation in &lt;a href=&quot;#EXAMPLE-1&quot;&gt;EXAMPLE 1&lt;/a&gt;, &lt;a href=&quot;#EXAMPLE-2&quot;&gt;EXAMPLE 2&lt;/a&gt;, and &lt;a href=&quot;#EXAMPLE-3&quot;&gt;EXAMPLE 3&lt;/a&gt;, when all the work is done inside the &quot;Perl glue&quot;, is somewhat of an exception rather than the rule.</source>
          <target state="translated">이것은 .xs 파일의 경우 매우 일반적입니다. 일반적으로 .xs 파일은 기존 C 함수에 대한 인터페이스를 제공합니다. 그런 다음이 C 함수는 외부 라이브러리 또는 .xs 파일의 첫 부분에 정의되어 있으며이 함수에 대한 Perl 인터페이스 (예 : &quot;Perl glue&quot;)는 .xs 파일의 두 번째 부분에 설명되어 있습니다. &quot;Perl glue&quot;내에서 모든 작업이 수행 되는 &lt;a href=&quot;#EXAMPLE-1&quot;&gt;예 1&lt;/a&gt; , &lt;a href=&quot;#EXAMPLE-2&quot;&gt;예 2&lt;/a&gt; 및 &lt;a href=&quot;#EXAMPLE-3&quot;&gt;예 3&lt;/a&gt; 의 상황은 규칙이 아닌 다소 예외입니다.</target>
        </trans-unit>
        <trans-unit id="c3a982ed6685f74bf9f57db540f3caed5035dcd6" translate="yes" xml:space="preserve">
          <source>This is quite useful as it usually improves readability. While this works fine for an &lt;code&gt;SV *&lt;/code&gt; , it's unfortunately not as easy to have &lt;code&gt;AV *&lt;/code&gt; or &lt;code&gt;HV *&lt;/code&gt; as a return value. You</source>
          <target state="translated">이것은 일반적으로 가독성을 향상시키기 때문에 매우 유용합니다. 이것은 &lt;code&gt;SV *&lt;/code&gt; 에 잘 작동하지만 불행히도 &lt;code&gt;AV *&lt;/code&gt; 또는 &lt;code&gt;HV *&lt;/code&gt; 를 반환 값으로 갖는 것은 쉽지 않습니다 . 당신</target>
        </trans-unit>
        <trans-unit id="df9aa2c2c409f58ba99139ca42f157f4afdf7a29" translate="yes" xml:space="preserve">
          <source>This is rarely used. It's one way to get around using an E&amp;lt;...&amp;gt; code sometimes. For example, instead of &quot;&lt;code&gt;NE&amp;lt;lt&amp;gt;3&lt;/code&gt;&quot; (for &quot;N&amp;lt;3&quot;) you could write &quot;&lt;code&gt;NZ&amp;lt;&amp;gt;&amp;lt;3&lt;/code&gt; &quot; (the &quot;Z&amp;lt;&amp;gt;&quot; breaks up the &quot;N&quot; and the &quot;&amp;lt;&quot; so they can't be considered the part of a (fictitious) &quot;N&amp;lt;...&amp;gt;&quot; code).</source>
          <target state="translated">이것은 거의 사용되지 않습니다. 때로는 E &amp;lt;...&amp;gt; 코드를 사용하여 돌아 다니는 한 가지 방법입니다. 예를 들어 &quot;N &amp;lt;3 &lt;code&gt;NE&amp;lt;lt&amp;gt;3&lt;/code&gt; &quot;( &quot;N &amp;lt;3&quot;의 경우) 대신 &quot; &lt;code&gt;NZ&amp;lt;&amp;gt;&amp;lt;3&lt;/code&gt; &quot;( &quot;Z &amp;lt;&amp;gt;&quot;은 &quot;N&quot;과 &quot;&amp;lt;&quot;을 구분하므로 (가상) &quot;N &amp;lt;...&amp;gt;&quot;코드의 일부로 간주 될 수 없음).</target>
        </trans-unit>
        <trans-unit id="5c569493cb06e371332b5d2d180bdd4a7a876b1d" translate="yes" xml:space="preserve">
          <source>This is required by some servers. For example if you are connecting to an INN server and you have transfer permission your connection will be connected to the transfer daemon, not the NNTP daemon. Issuing this command will cause the transfer daemon to hand over control to the NNTP daemon.</source>
          <target state="translated">이것은 일부 서버에서 필요합니다. 예를 들어, INN 서버에 연결 중이고 전송 권한이 있으면 연결이 NNTP 데몬이 아닌 전송 데몬에 연결됩니다. 이 명령을 실행하면 전송 데몬이 제어를 NNTP 데몬으로 넘겨줍니다.</target>
        </trans-unit>
        <trans-unit id="1aba726220151e0bdd8e20f672a38f3cb853c543" translate="yes" xml:space="preserve">
          <source>This is required since on many unix systems C is not owned by root.</source>
          <target state="translated">많은 유닉스 시스템에서 C는 루트가 소유하지 않기 때문에 이것은 필수입니다.</target>
        </trans-unit>
        <trans-unit id="53e759494f9bf8d7efd9149cfc161ebbf71db524" translate="yes" xml:space="preserve">
          <source>This is safer than and replaces the &quot;no_plan&quot; plan.</source>
          <target state="translated">이것은 &quot;no_plan&quot;계획보다 안전하며이를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="c7ebcb8463dd98d519e70a00c26fec5b1949c87c" translate="yes" xml:space="preserve">
          <source>This is seldom necessary, though, because this is done automatically, like when you access an array:</source>
          <target state="translated">그러나 배열에 액세스 할 때와 같이 자동으로 수행되므로 거의 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5b39df7c425593c524473bd917a5316f755e7f35" translate="yes" xml:space="preserve">
          <source>This is set to &lt;code&gt;true&lt;/code&gt; in</source>
          <target state="translated">이것은 &lt;code&gt;true&lt;/code&gt; 로 설정되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bda100b399c447a02432db64ae424bebb5a77bb3" translate="yes" xml:space="preserve">
          <source>This is set to a true value. It allows the tests to determine if they are being executed through the harness or by any other means.</source>
          <target state="translated">이것은 실제 값으로 설정됩니다. 테스트를 통해 하네스 또는 다른 수단으로 실행되고 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8825b383410611d9ab88c7c6da41a37ab67b7bd2" translate="yes" xml:space="preserve">
          <source>This is similar in spirit to, but not the same as, grep(1) and its relatives. In particular, it is not limited to using regular expressions.</source>
          <target state="translated">이것은 grep (1) 및 친척과 동일하지만 동일하지는 않습니다. 특히 정규식을 사용하는 것으로 제한되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="031672016e4d502c018309428e47661800aac1a9" translate="yes" xml:space="preserve">
          <source>This is similar to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e6ba00cc4274369aaec7e06e964eb77cd40c12d" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;$&amp;amp;&lt;/code&gt; (&lt;code&gt;$MATCH&lt;/code&gt; ) except that it does not incur the performance penalty associated with that variable.</source>
          <target state="translated">이는 해당 변수와 관련된 성능 저하가 발생하지 않는다는 점을 제외하고 &lt;code&gt;$&amp;amp;&lt;/code&gt; ( &lt;code&gt;$MATCH&lt;/code&gt; ) 와 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="95e9006abb746eec00ddbe6c7b21cfe4ec62c97b" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;$'&lt;/code&gt; (&lt;code&gt;$POSTMATCH&lt;/code&gt; ) except that it does not incur the performance penalty associated with that variable.</source>
          <target state="translated">이는 해당 변수와 관련된 성능 저하가 발생하지 않는다는 점을 제외하고 &lt;code&gt;$'&lt;/code&gt; ( &lt;code&gt;$POSTMATCH&lt;/code&gt; ) 와 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="62e38c00b725c5a13563494b1438770078513b03" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;$`&lt;/code&gt; ($PREMATCH) except that it does not incur the performance penalty associated with that variable.</source>
          <target state="translated">이는 해당 변수와 관련된 성능 저하가 발생하지 않는다는 점을 제외하고 &lt;code&gt;$`&lt;/code&gt; ($ PREMATCH) 와 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="b7b04635104076e8869c03a97df7510eda62d809" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt;, but just returns either a code reference or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; to indicate that no further methods of this name exist.</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; 와 유사 하지만 이 이름의 메소드가 더 이상 존재하지 않음을 나타 내기 위해 코드 참조 또는 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="f73fed07cf9661cd5a76d43367f7870e1dfd1e63" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;string_vianame&lt;/code&gt; . The main difference is that under most circumstances, &lt;code&gt;vianame&lt;/code&gt; returns an ordinal code point, whereas &lt;code&gt;string_vianame&lt;/code&gt; returns a string. For example,</source>
          <target state="translated">이것은 &lt;code&gt;string_vianame&lt;/code&gt; 과 유사합니다 . 가장 큰 차이점은 대부분의 상황에서,이다 &lt;code&gt;vianame&lt;/code&gt; 는 반면, 서수 코드 포인트를 반환 &lt;code&gt;string_vianame&lt;/code&gt; 의 반환 문자열. 예를 들어</target>
        </trans-unit>
        <trans-unit id="82735301d82a0dc4313bb1d53ad031d27f023c2f" translate="yes" xml:space="preserve">
          <source>This is similar to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; function for returning a string that has the arguments formatted as requested, see &lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;.</source>
          <target state="translated">이것은 요청에 따라 형식이 지정된 인수를 가진 문자열을 반환하는 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; 함수 와 유사합니다 (&lt;a href=&quot;functions/sprintf&quot;&gt; sprintf&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="eb9fc002d8f7d1fdb8d39dcb8cc96f69462055b3" translate="yes" xml:space="preserve">
          <source>This is similar to calling the &lt;code&gt;x&lt;/code&gt; command on each applicable var.</source>
          <target state="translated">이것은 적용 가능한 각 var 에서 &lt;code&gt;x&lt;/code&gt; 명령 을 호출하는 것과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="c882c2e2c2f32205e6402773c4c5a8648cf274ab" translate="yes" xml:space="preserve">
          <source>This is similar to the &quot;cut group&quot; operator &lt;code&gt;::&lt;/code&gt; from Perl 6. Like &lt;code&gt;(*PRUNE)&lt;/code&gt; , this verb always matches, and when backtracked into on failure, it causes the regex engine to try the next alternation in the innermost enclosing group (capturing or otherwise) that has alternations. The two branches of a &lt;code&gt;(?(condition)yes-pattern|no-pattern)&lt;/code&gt; do not count as an alternation, as far as &lt;code&gt;(*THEN)&lt;/code&gt; is concerned.</source>
          <target state="translated">이것은 Perl 6 의 &quot;cut group&quot;연산자 &lt;code&gt;::&lt;/code&gt; 와 유사합니다. &lt;code&gt;(*PRUNE)&lt;/code&gt; 처럼 ,이 동사는 항상 일치하며, 실패시 역 추적 할 때 정규식 엔진이 가장 안쪽의 묶음 그룹에서 다음 번 대체를 시도합니다 ( 교체 또는 다른 방법). &lt;code&gt;(*THEN)&lt;/code&gt; 에 관한 한, &lt;code&gt;(?(condition)yes-pattern|no-pattern)&lt;/code&gt; 의 2 개의 분기 는 교대로 간주되지 않는다 .</target>
        </trans-unit>
        <trans-unit id="5b23340a8a44f500f9fdd2f514353aafef1f1600" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;dup()&lt;/code&gt; , for duplicating a file descriptor.</source>
          <target state="translated">이것은 파일 기술자를 복제하는 C 함수 &lt;code&gt;dup()&lt;/code&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="bc59e25f670eb40f71d53b45961566d88e8da8a1" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;dup2()&lt;/code&gt; , for duplicating a file descriptor to an another known file descriptor.</source>
          <target state="translated">이것은 다른 알려진 파일 디스크립터에 파일 디스크립터를 복제하기위한 C 함수 &lt;code&gt;dup2()&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="f3ae23dd5fc0059c09ec24ea0c5ef5acb6d58fa1" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;mkfifo()&lt;/code&gt; for creating FIFO special files.</source>
          <target state="translated">이것은 FIFO 특수 파일 작성을위한 C 함수 &lt;code&gt;mkfifo()&lt;/code&gt; 와 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="cb82e089ae466005cc0dc383a964501667069da5" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;nice()&lt;/code&gt; , for changing the scheduling preference of the current process. Positive arguments mean a more polite process, negative values a more needy process. Normal (non-root) user processes can only change towards being more polite.</source>
          <target state="translated">이것은 현재 프로세스의 스케줄링 환경 설정을 변경 하는 C 함수 &lt;code&gt;nice()&lt;/code&gt; 와 유사합니다 . 긍정적 인 주장은 더 정중 한 과정을 의미하고, 부정적인 가치는 더 필요한 과정을 의미합니다. 루트가 아닌 일반 사용자 프로세스는 더 정중 한 방향으로 만 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="458e14f71182f02f4a806b4f96c30f94a69e2f5d" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;pause()&lt;/code&gt; , which suspends the execution of the current process until a signal is received.</source>
          <target state="translated">이것은 C 함수 &lt;code&gt;pause()&lt;/code&gt; 와 유사합니다.이 함수 는 신호가 수신 될 때까지 현재 프로세스의 실행을 일시 중단합니다.</target>
        </trans-unit>
        <trans-unit id="b5c0406fc055d4e959d81bed9920f88092d08404" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;setpgid()&lt;/code&gt; for setting the process group identifier of the current process.</source>
          <target state="translated">이것은 현재 프로세스의 프로세스 그룹 식별자를 설정 하는 C 함수 &lt;code&gt;setpgid()&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="b56c5c880f143b4a031f787b44269acb561de2d9" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;tcdrain()&lt;/code&gt; for draining the output queue of its argument stream.</source>
          <target state="translated">이는 인수 스트림의 출력 큐를 &lt;code&gt;tcdrain()&lt;/code&gt; 위한 C 함수 tcdrain () 과 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="fba332acc7267461256bd4bbecd53d5cd07ab313" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;tcflow()&lt;/code&gt; for controlling the flow of its argument stream.</source>
          <target state="translated">이것은 인수 스트림의 흐름을 제어하는 C 함수 &lt;code&gt;tcflow()&lt;/code&gt; 와 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="2235c85d6f3847cd44159a3753a652d29703f3f5" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;tcflush()&lt;/code&gt; for flushing the I/O buffers of its argument stream.</source>
          <target state="translated">이것은 인수 스트림의 I / O 버퍼를 플러시하기위한 C 함수 &lt;code&gt;tcflush()&lt;/code&gt; 와 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="32c5db3dfe196b930ba8a6acd29334ab37d33b0e" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;tcsendbreak()&lt;/code&gt; for sending a break on its argument stream.</source>
          <target state="translated">이는 인수 스트림에서 중단을 보내는 C 함수 &lt;code&gt;tcsendbreak()&lt;/code&gt; 와 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="d51d66ac3fd31e0526e015560112bf7a83d1d7e3" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;tcsetpgrp()&lt;/code&gt; for setting the process group identifier of the foreground process group of the controlling terminal.</source>
          <target state="translated">이것은 제어 터미널의 포 그라운드 프로세스 그룹의 프로세스 그룹 식별자를 설정 하는 C 함수 &lt;code&gt;tcsetpgrp()&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="66ffda00414691432da9fbf5e0758036abbf4c87" translate="yes" xml:space="preserve">
          <source>This is similar to the C function, except that it can apply to a single character or to a whole string, and currently operates as if the locale always is &quot;C&quot;. Consider using the &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt; function, see &lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;, or the equivalent &lt;code&gt;\U&lt;/code&gt; operator inside doublequotish strings.</source>
          <target state="translated">이는 단일 문자 또는 전체 문자열에 적용 할 수 있다는 점을 제외하고 C 함수와 유사하며 현재 로케일이 항상 &quot;C&quot;인 것처럼 작동합니다. &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt; 함수 사용을 고려 하십시오. &lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt; 또는 큰 따옴표 문자열 내 에서 동등한 &lt;code&gt;\U&lt;/code&gt; 연산자를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8eda6f0f736dfb783b722b66835ba379ce58a17f" translate="yes" xml:space="preserve">
          <source>This is similar to using T_OPAQUEPTR but can be used to process more than one element.</source>
          <target state="translated">이것은 T_OPAQUEPTR을 사용하는 것과 유사하지만 둘 이상의 요소를 처리하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a070e7d29b17578c9c82db6eb47bc8205a22821e" translate="yes" xml:space="preserve">
          <source>This is so that you can write loops like:</source>
          <target state="translated">이것은 다음과 같은 루프를 작성할 수 있도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="5bb4dbbe89d426f58f9d96c7270c7af2e03e5d56" translate="yes" xml:space="preserve">
          <source>This is something you, the programmer, has to keep track of; sorry. You could consider adopting a kind of &quot;Hungarian notation&quot; to help with this.</source>
          <target state="translated">이것은 프로그래머가 추적해야 할 사항입니다. 죄송합니다. 이를 돕기 위해 일종의 &quot;헝가리어 표기법&quot;을 채택하는 것을 고려할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f62086875f698e88f1673ff191123d1ebe166ce0" translate="yes" xml:space="preserve">
          <source>This is somewhat equivalent to the C-style switch statement's fallthrough functionality (not to be confused with</source>
          <target state="translated">이것은 C 스타일 switch 문의 폴 스루 기능과 다소 동일합니다.</target>
        </trans-unit>
        <trans-unit id="7039ef5c59f1a390b0357d66a81e16efc5deefb4" translate="yes" xml:space="preserve">
          <source>This is somewhat like &lt;code&gt;SUPER&lt;/code&gt; , but it uses the C3 method resolution order to get better consistency in multiple inheritance situations. Note that while inheritance in general follows whichever MRO is in effect for the given class, &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; only uses the C3 MRO.</source>
          <target state="translated">이것은 &lt;code&gt;SUPER&lt;/code&gt; 와 비슷하지만 C3 메서드 확인 순서를 사용하여 여러 상속 상황에서 일관성을 향상시킵니다. 상속은 일반적으로 주어진 클래스에 적용되는 MRO를 따르지만 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; 는 C3 MRO 만 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a6e2c8909db8a95dab398add127a82ec5182c9bc" translate="yes" xml:space="preserve">
          <source>This is still a symbolic reference, and is still saddled with the problems enumerated above. It would be far better to write:</source>
          <target state="translated">이것은 여전히 ​​상징적 참조이며 위에 열거 된 문제로 여전히 안장되어 있습니다. 작성하는 것이 훨씬 낫습니다.</target>
        </trans-unit>
        <trans-unit id="dc230bd2bfa305e90c52714b5b02997ea62329f3" translate="yes" xml:space="preserve">
          <source>This is subroutine definition, not a real function</source>
          <target state="translated">이것은 실제 함수가 아닌 서브 루틴 정의입니다.</target>
        </trans-unit>
        <trans-unit id="b1e77ff60ef4ac8debe40c75ba809e724ed8905b" translate="yes" xml:space="preserve">
          <source>This is substantially different than the behavior of &lt;code&gt;SUPER&lt;/code&gt; under complex multiple inheritance. (This becomes obvious when one realizes that the common superclasses in the C3 linearizations of a given class and one of its parents will not always be ordered the same for both.)</source>
          <target state="translated">이것은 복잡한 다중 상속 에서 &lt;code&gt;SUPER&lt;/code&gt; 의 동작과 실질적으로 다릅니다 . (이것은 주어진 클래스와 그 부모 중 하나의 C3 선형화에서 공통 수퍼 클래스가 둘 다에 대해 항상 동일하게 주문되지는 않는다는 것을 알면 분명해진다.)</target>
        </trans-unit>
        <trans-unit id="23e17e01cd60708587cb31d9ff8b363ecd66c020" translate="yes" xml:space="preserve">
          <source>This is sufficient because non-XS modules install only &quot;.pm&quot; files and (sometimes) pod and/or man documentation. No re-linking of the perl binary is needed to build, install or use non-XS modules.</source>
          <target state="translated">비 XS 모듈은 &quot;.pm&quot;파일과 포드 및 / 또는 설명서를 설치하기 때문에 충분합니다. 비 XS 모듈을 빌드, 설치 또는 사용하기 위해 perl 바이너리를 다시 연결할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="0c58a399144492e3d85b2b92893dc4441d4f1a4b" translate="yes" xml:space="preserve">
          <source>This is synonymous with:</source>
          <target state="translated">이것은 다음과 동의어입니다 :</target>
        </trans-unit>
        <trans-unit id="f36d5338bbc7b7f385e72503a212aefb9d4b21f2" translate="yes" xml:space="preserve">
          <source>This is the &quot;branch reset&quot; pattern, which has the special property that the capture groups are numbered from the same starting point in each alternation branch. It is available starting from perl 5.10.0.</source>
          <target state="translated">이는 &quot;분기 재설정&quot;패턴으로, 각 대체 분기에서 동일한 시작점에서 캡처 그룹의 번호가 지정되는 특수 특성을 갖습니다. perl 5.10.0부터 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19421af57fe146a06eb56f9f30349ebe8341f96d" translate="yes" xml:space="preserve">
          <source>This is the &quot;make test&quot; result from the said combination:</source>
          <target state="translated">이것은 상기 조합의 &quot;테스트 테스트&quot;결과입니다.</target>
        </trans-unit>
        <trans-unit id="62ca18cb3607997061d57b9fd320ab0f041516b6" translate="yes" xml:space="preserve">
          <source>This is the &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; SV. Always refer to this as &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; .</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; SV입니다. 항상 이것을 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; 로 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f4760f68814e5682fe3f5f10b06ed0b34903e395" translate="yes" xml:space="preserve">
          <source>This is the &lt;code&gt;false&lt;/code&gt; SV. See &lt;code&gt;PL_sv_yes&lt;/code&gt; . Always refer to this as &lt;code&gt;&amp;amp;PL_sv_no&lt;/code&gt; .</source>
          <target state="translated">이것은 &lt;code&gt;false&lt;/code&gt; SV입니다. &lt;code&gt;PL_sv_yes&lt;/code&gt; 를 참조하십시오 . 항상 이것을 &lt;code&gt;&amp;amp;PL_sv_no&lt;/code&gt; 로 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="69477e80b4da6549c4778882346d8c2f1a054a61" translate="yes" xml:space="preserve">
          <source>This is the &lt;code&gt;true&lt;/code&gt; SV. See &lt;code&gt;PL_sv_no&lt;/code&gt; . Always refer to this as &lt;code&gt;&amp;amp;PL_sv_yes&lt;/code&gt; .</source>
          <target state="translated">이것이 &lt;code&gt;true&lt;/code&gt; SV입니다. &lt;code&gt;PL_sv_no&lt;/code&gt; 를 참조하십시오 . 항상 이것을 &lt;code&gt;&amp;amp;PL_sv_yes&lt;/code&gt; 로 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7194017d84a1b8d81ca4290d44c59af66198e5c2" translate="yes" xml:space="preserve">
          <source>This is the Perl 6 &quot;commit pattern&quot; &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; or &lt;code&gt;:::&lt;/code&gt;. It's a zero-width pattern similar to &lt;code&gt;(*SKIP)&lt;/code&gt; , except that when backtracked into on failure it causes the match to fail outright. No further attempts to find a valid match by advancing the start pointer will occur again. For example,</source>
          <target state="translated">이것은 Perl 6 &quot;커밋 패턴&quot; &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;:::&lt;/code&gt; 입니다. &lt;code&gt;(*SKIP)&lt;/code&gt; 와 비슷한 폭이 0 인 패턴입니다 . 단, 실패시 역 추적 할 경우 일치가 완전히 실패합니다. 더 이상 시작 포인터를 진행하여 올바른 일치를 찾으려고 시도하지 않습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="6d8e4baf0d85adfeec247ab733be39725f479200" translate="yes" xml:space="preserve">
          <source>This is the Perl patch level, a numeric change identifier, as defined by whichever source code maintenance system is used to maintain the patches; currently Perforce. It does not correlate with the Perl version numbers or the maintenance versus development dichotomy except by also being increasing.</source>
          <target state="translated">이것은 패치를 유지하는 데 사용되는 소스 코드 유지 보수 시스템에 의해 정의 된 숫자 변경 식별자 인 Perl 패치 레벨입니다. 현재 Perforce. 또한 Perl 버전 번호 또는 유지 관리 대 이분법과도 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="0eaf16c26ce67bf186071a739f6615eb11610fd4" translate="yes" xml:space="preserve">
          <source>This is the SV to be matched against. Note that the actual char array to be matched against is supplied by the arguments described below; the SV is just used to determine UTF8ness, &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; etc.</source>
          <target state="translated">일치하는 SV입니다. 일치시킬 실제 문자 배열은 아래 설명 된 인수에 의해 제공됩니다. SV는 UTF8ness, &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 등 을 결정하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4d720b4f15a9201913736e953c720d9b63d81ea0" translate="yes" xml:space="preserve">
          <source>This is the Unicode-aware way of saying</source>
          <target state="translated">이것은 유니 코드를 인식하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="455ede6174f3d5161f6c2d4aa6425c94536894ca" translate="yes" xml:space="preserve">
          <source>This is the basic function to generate temporary files. The behaviour of the file can be changed using various options:</source>
          <target state="translated">임시 파일을 생성하는 기본 기능입니다. 파일의 동작은 다양한 옵션을 사용하여 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a05b57eee11f052b052017c3ff384fae39edc53f" translate="yes" xml:space="preserve">
          <source>This is the command to execute. It may be either a string or an array reference. This is a required argument.</source>
          <target state="translated">실행할 명령입니다. 문자열 또는 배열 참조 일 수 있습니다. 이것은 필수 인수입니다.</target>
        </trans-unit>
        <trans-unit id="78880bb496bf709fa9881c622c08f3137e6dd8f7" translate="yes" xml:space="preserve">
          <source>This is the constructor for &lt;b&gt;Pod::Parser&lt;/b&gt; and its subclasses. You</source>
          <target state="translated">이것은 &lt;b&gt;Pod :: Parser&lt;/b&gt; 및 해당 서브 클래스 의 생성자입니다 . 당신</target>
        </trans-unit>
        <trans-unit id="3d8bf5bd14f4dda830975aad7d7af3e9d034509f" translate="yes" xml:space="preserve">
          <source>This is the constructor for a new Net::FTP object. &lt;code&gt;HOST&lt;/code&gt; is the name of the remote host to which an FTP connection is required.</source>
          <target state="translated">이것은 새로운 Net :: FTP 객체의 생성자입니다. &lt;code&gt;HOST&lt;/code&gt; 는 FTP 연결이 필요한 원격 호스트의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="d79a978a5e7757a479b9fe30cd0cc290698241af" translate="yes" xml:space="preserve">
          <source>This is the constructor for a new Net::NNTP object. &lt;code&gt;HOST&lt;/code&gt; is the name of the remote host to which a NNTP connection is required. If not given then it may be passed as the &lt;code&gt;Host&lt;/code&gt; option described below. If no host is passed then two environment variables are checked, first &lt;code&gt;NNTPSERVER&lt;/code&gt; then &lt;code&gt;NEWSHOST&lt;/code&gt; , then &lt;code&gt;Net::Config&lt;/code&gt; is checked, and if a host is not found then &lt;code&gt;news&lt;/code&gt; is used.</source>
          <target state="translated">이것은 새로운 Net :: NNTP 객체의 생성자입니다. &lt;code&gt;HOST&lt;/code&gt; 는 NNTP 연결이 필요한 원격 호스트의 이름입니다. 지정하지 않으면 아래에 설명 된 &lt;code&gt;Host&lt;/code&gt; 옵션 으로 전달 될 수 있습니다 . 호스트가 전달되지 않으면 두 개의 환경 변수가 먼저 확인되고, 먼저 &lt;code&gt;NNTPSERVER&lt;/code&gt; , &lt;code&gt;NEWSHOST&lt;/code&gt; , &lt;code&gt;Net::Config&lt;/code&gt; 가 확인되고 호스트가 없으면 &lt;code&gt;news&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3a1411000dcca44bd6224ab398773d981b55ca56" translate="yes" xml:space="preserve">
          <source>This is the constructor for a new Net::POP3 object. &lt;code&gt;HOST&lt;/code&gt; is the name of the remote host to which an POP3 connection is required.</source>
          <target state="translated">이것은 새로운 Net :: POP3 객체의 생성자입니다. &lt;code&gt;HOST&lt;/code&gt; 는 POP3 연결이 필요한 원격 호스트의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="b5e150d75dbb5f649a71e256e018f3d6ee5d68ad" translate="yes" xml:space="preserve">
          <source>This is the constructor for a new Net::SMTP object. &lt;code&gt;HOST&lt;/code&gt; is the name of the remote host to which an SMTP connection is required.</source>
          <target state="translated">이것은 새로운 Net :: SMTP 객체의 생성자입니다. &lt;code&gt;HOST&lt;/code&gt; 는 SMTP 연결이 필요한 원격 호스트의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="3dcdb98a1ad7340bd49db77b64b7ed1e7e6ac7fa" translate="yes" xml:space="preserve">
          <source>This is the constructor for the class. That means it is expected to return a blessed reference of some sort. The reference can be used to hold some internal information.</source>
          <target state="translated">이것은 클래스의 생성자입니다. 그것은 어떤 종류의 복된 참조를 돌려 주어야한다는 것을 의미합니다. 참조는 일부 내부 정보를 보유하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f8efcba15ad2c7fb65b185c0d87e50ef7c7af8b" translate="yes" xml:space="preserve">
          <source>This is the constructor for the class. That means it is expected to return a blessed reference through which the new array (probably an anonymous ARRAY ref) will be accessed.</source>
          <target state="translated">이것은 클래스의 생성자입니다. 즉, 새로운 배열 (아마 익명의 ARRAY 참조)에 액세스 할 수있는 유용한 참조를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="4ddd75a12229b0af35fd3f3217e95a18f27831c9" translate="yes" xml:space="preserve">
          <source>This is the constructor for the class. That means it is expected to return a blessed reference through which the new object (probably but not necessarily an anonymous hash) will be accessed.</source>
          <target state="translated">이것은 클래스의 생성자입니다. 즉, 새 개체 (아마도 익명 해시 일 필요는 없음)에 액세스 할 수있는 축복 된 참조를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="c3ca80029525d0505c9c19a25619277e596ad6ff" translate="yes" xml:space="preserve">
          <source>This is the constructor for the class. That means it is expected to return a blessed reference to a new scalar (probably anonymous) that it's creating. For example:</source>
          <target state="translated">이것은 클래스의 생성자입니다. 그것은 그것이 만들어내는 새로운 스칼라 (아마 익명)에 대한 축복 된 참조를 반환 할 것으로 예상된다는 것을 의미합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="97c7d16dbe44cbd95a833f47b94f50f6214ea17d" translate="yes" xml:space="preserve">
          <source>This is the default code set.</source>
          <target state="translated">이것이 기본 코드 세트입니다.</target>
        </trans-unit>
        <trans-unit id="f42f9d3bfdedb4c34f927c70a8b84d5ca486809d" translate="yes" xml:space="preserve">
          <source>This is the default value if none was provided by the user. This is also the type &lt;code&gt;strict_type&lt;/code&gt; will look at when checking type integrity (see below).</source>
          <target state="translated">사용자가 제공하지 않은 경우 기본값입니다. 이것은 또한 유형 무결성을 검사 할 때 &lt;code&gt;strict_type&lt;/code&gt; 유형 에서 확인합니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="60c4aeb1d9a588518e8c401cb7140416c2986e58" translate="yes" xml:space="preserve">
          <source>This is the default. If you can use the</source>
          <target state="translated">이것이 기본값입니다. 당신이 사용할 수있는 경우</target>
        </trans-unit>
        <trans-unit id="2b115e2483ec3abaacaac1f9ae2d4e5dce2387c0" translate="yes" xml:space="preserve">
          <source>This is the directory where the .pm and .pod files you wish to have installed go. They are laid out according to namespace. So Foo::Bar is</source>
          <target state="translated">이것은 설치하려는 .pm 및 .pod 파일이있는 디렉토리입니다. 네임 스페이스에 따라 배치됩니다. Foo :: Bar는</target>
        </trans-unit>
        <trans-unit id="d930a14451f27529d05daafcbdbe065ab4700f11" translate="yes" xml:space="preserve">
          <source>This is the documentation of version 0.33</source>
          <target state="translated">이것은 0.33 버전의 문서입니다</target>
        </trans-unit>
        <trans-unit id="412a728d73be865262b84817f05ddc7c35324cf4" translate="yes" xml:space="preserve">
          <source>This is the easiest way to implement threads, and the way most OSes start. The big disadvantage is that, since the OS knows nothing about threads, if one thread blocks they all do. Typical blocking activities include most system calls, most I/O, and things like &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 스레드를 구현하는 가장 쉬운 방법이며 대부분의 OS가 시작되는 방법입니다. 큰 단점은 OS가 스레드에 대해 아무것도 알지 못하기 때문에 하나의 스레드가 모두 스레드를 차단한다는 것입니다. 일반적인 차단 활동에는 대부분의 시스템 호출, 대부분의 I / O 및 &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep()&lt;/a&gt;&lt;/code&gt; 과 같은 것들이 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="9c6f35e7150b834f9f05080f6b4f16bfc1d90561" translate="yes" xml:space="preserve">
          <source>This is the email address that will be sent as your anonymous ftp password.</source>
          <target state="translated">이것은 익명 ftp 비밀번호로 발송 될 이메일 주소입니다.</target>
        </trans-unit>
        <trans-unit id="03a8ad8de2657fbb598356bba52fec61dbe4557b" translate="yes" xml:space="preserve">
          <source>This is the existing flag. If the lexical warnings pragma is &lt;b&gt;not&lt;/b&gt; used in any of you code, or any of the modules that you use, this flag will enable warnings everywhere. See &lt;a href=&quot;#Backward-Compatibility&quot;&gt;Backward Compatibility&lt;/a&gt; for details of how this flag interacts with lexical warnings.</source>
          <target state="translated">기존 플래그입니다. 어휘 경고 pragma가 사용자 코드 또는 사용하는 모듈에서 사용 &lt;b&gt;되지 않는&lt;/b&gt; 경우이 플래그는 모든 곳에서 경고를 활성화합니다. 이 플래그가 어휘 경고와 상호 작용하는 방법에 대한 자세한 내용은 &lt;a href=&quot;#Backward-Compatibility&quot;&gt;이전 버전과의 호환성&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb41b10f4355a8511d19503b44266dfd63767081" translate="yes" xml:space="preserve">
          <source>This is the full Uppercase_Mapping property (as opposed to the Simple_Uppercase_Mapping given in the example for format &lt;code&gt;&quot;a&quot;&lt;/code&gt; ). The only difference between the two in the ranges shown is that the code point at 0x0149 (LATIN SMALL LETTER N PRECEDED BY APOSTROPHE) maps to a string of two characters, 0x02BC (MODIFIER LETTER APOSTROPHE) followed by 0x004E (LATIN CAPITAL LETTER N).</source>
          <target state="translated">&lt;code&gt;&quot;a&quot;&lt;/code&gt; 형식의 예에서 제공된 Simple_Uppercase_Mapping과 달리 전체 Uppercase_Mapping 속성 입니다. 표시된 범위에서 둘 사이의 유일한 차이점은 0x0149의 코드 포인트 (APOSTROPHE가 선행하는 작은 문자 N)가 0x02BC (MODIFIER LETTER APOSTROPHE)의 두 문자로 된 문자열과 0x004E (라틴 대문자 L)로 매핑된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="871175ae8bd1e88a96090e3ee5d094a4a3c823c8" translate="yes" xml:space="preserve">
          <source>This is the function that does the real work. It should use the current values of @dl_require_symbols and @dl_resolve_using if required.</source>
          <target state="translated">이것이 실제 작업을 수행하는 기능입니다. 필요한 경우 현재 @dl_require_symbols 및 @dl_resolve_using 값을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="0f9cd536958034f18b34b73afd163424db233b70" translate="yes" xml:space="preserve">
          <source>This is the global compile-time. That includes, basically, every &lt;code&gt;BEGIN&lt;/code&gt; block executed directly or indirectly from during the compile-time of the top-level program.</source>
          <target state="translated">이것이 전역 컴파일 타임입니다. 여기에는 기본적으로 최상위 프로그램의 컴파일 타임 동안 직접 또는 간접적으로 실행되는 모든 &lt;code&gt;BEGIN&lt;/code&gt; 블록 이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="394f7937653a5d479f930b2ee200056fdee9eaa3" translate="yes" xml:space="preserve">
          <source>This is the highest UID on the current system that refers to a root UID. This is used to make sure that the temporary directory is owned by a system UID (C</source>
          <target state="translated">루트 UID를 나타내는 현재 시스템에서 가장 높은 UID입니다. 시스템 UID (C가 임시 디렉토리를 소유하는지 확인하는 데 사용됨)</target>
        </trans-unit>
        <trans-unit id="6328f4bdaf24cfea2076758e63c586a6679bf323" translate="yes" xml:space="preserve">
          <source>This is the internal function implementing the &lt;code&gt;&amp;lt;EXPR&amp;gt;&lt;/code&gt; operator, but you can use it directly. The &lt;code&gt;&amp;lt;EXPR&amp;gt;&lt;/code&gt; operator is discussed in more detail in &lt;a href=&quot;../perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;&amp;lt;EXPR&amp;gt;&lt;/code&gt; 연산자를 구현하는 내부 함수 이지만 직접 사용할 수 있습니다. &lt;code&gt;&amp;lt;EXPR&amp;gt;&lt;/code&gt; 오퍼레이터에 자세히 설명되어 &lt;a href=&quot;../perlop#I%2fO-Operators&quot;&gt;perlop에서 I / O 연산자&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f2a5b446b2d0ba2a35085618db8046fb9068c0dc" translate="yes" xml:space="preserve">
          <source>This is the internal function implementing the &lt;code&gt;&amp;lt;EXPR&amp;gt;&lt;/code&gt; operator, but you can use it directly. The &lt;code&gt;&amp;lt;EXPR&amp;gt;&lt;/code&gt; operator is discussed in more detail in &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;&amp;lt;EXPR&amp;gt;&lt;/code&gt; 연산자를 구현하는 내부 함수 이지만 직접 사용할 수 있습니다. &lt;code&gt;&amp;lt;EXPR&amp;gt;&lt;/code&gt; 오퍼레이터에 자세히 설명되어 &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;perlop에서 I / O 연산자&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c755425aff2265b37f84fd527f7d77c0d4f14125" translate="yes" xml:space="preserve">
          <source>This is the inverse of the &lt;code&gt;:utf8&lt;/code&gt; layer. It turns off the flag on the layer below so that data read from it is considered to be &quot;octets&quot; i.e. characters in the range 0..255 only. Likewise on output perl will warn if a &quot;wide&quot; character is written to a such a stream.</source>
          <target state="translated">이것은 &lt;code&gt;:utf8&lt;/code&gt; 레이어 와 반대입니다 . 아래 계층에서 플래그를 해제하여 읽은 데이터가 &quot;옥텟&quot;으로 간주됩니다 (예 : 0..255 범위의 문자 만). 마찬가지로 출력 펄은 &quot;와이드&quot;문자가 그러한 스트림에 기록되면 경고합니다.</target>
        </trans-unit>
        <trans-unit id="05a7690a54b93d5cbfbc43460dc86928e9ff4860" translate="yes" xml:space="preserve">
          <source>This is the least computationally expensive strategy. It may require some user education.</source>
          <target state="translated">이것은 계산 비용이 가장 저렴한 전략입니다. 일부 사용자 교육이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fe99eed7290a54a82a6a3a3aa2c3b4a2bb07743" translate="yes" xml:space="preserve">
          <source>This is the level of HTML &quot;Hn&quot; element to which a Pod &quot;head1&quot; corresponds. For example, if &lt;code&gt;html_h_level&lt;/code&gt; is set to 2, a head1 will produce an H2, a head2 will produce an H3, and so on.</source>
          <target state="translated">이것은 포드 &quot;head1&quot;에 해당하는 HTML &quot;Hn&quot;요소의 레벨입니다. 예를 들어, &lt;code&gt;html_h_level&lt;/code&gt; 이 2로 설정 되면 head1은 H2를 생성하고 head2는 H3을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="dbf2d95bd6e71bbc931d90912ac4916f4a329b66" translate="yes" xml:space="preserve">
          <source>This is the lower layer of the Perl parser, managing characters and tokens.</source>
          <target state="translated">캐릭터와 토큰을 관리하는 Perl 파서의 하위 계층입니다.</target>
        </trans-unit>
        <trans-unit id="12044b247d0e34184da8c4d82be7f35e7cce2add" translate="yes" xml:space="preserve">
          <source>This is the module that is used as a frontend to the Perl Compiler.</source>
          <target state="translated">Perl Compiler의 프론트 엔드로 사용되는 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="d48b3bc5add16b69ab6764e7aa4a54509b451c2e" translate="yes" xml:space="preserve">
          <source>This is the most compact form, but it is not well suited for printing or embedding in places that can't handle arbitrary data.</source>
          <target state="translated">이 형식은 가장 간결한 형식이지만 임의의 데이터를 처리 할 수없는 장소에 인쇄하거나 포함하는 데 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6f4b6501db089524291430841e3e59e649fd1a7f" translate="yes" xml:space="preserve">
          <source>This is the most important method in Locale::Maketext:</source>
          <target state="translated">이것은 Locale :: Maketext에서 가장 중요한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="d28b3b2c303cf9fffc3f2cf8865a24397d2fa229" translate="yes" xml:space="preserve">
          <source>This is the most serious problem in Perl 5.20 and earlier. Fixing this required internal changes in Perl 5.22.</source>
          <target state="translated">이것은 Perl 5.20 및 이전 버전에서 가장 심각한 문제입니다. Perl 5.22에서이 내부 변경 사항을 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="cb5f568d5745a8f721d4963249e63f161fe9a2ef" translate="yes" xml:space="preserve">
          <source>This is the name or Internet address of the remote host the server is running on. We could have specified a longer name like &lt;code&gt;&quot;www.perl.com&quot;&lt;/code&gt; , or an address like &lt;code&gt;&quot;207.171.7.72&quot;&lt;/code&gt; . For demonstration purposes, we've used the special hostname &lt;code&gt;&quot;localhost&quot;&lt;/code&gt; , which should always mean the current machine you're running on. The corresponding Internet address for localhost is &lt;code&gt;&quot;127.0.0.1&quot;&lt;/code&gt; , if you'd rather use that.</source>
          <target state="translated">서버가 실행중인 원격 호스트의 이름 또는 인터넷 주소입니다. 우리는 같은 긴 이름을 지정한 수 있었다 &lt;code&gt;&quot;www.perl.com&quot;&lt;/code&gt; , 또는 같은 주소 &lt;code&gt;&quot;207.171.7.72&quot;&lt;/code&gt; . 데모 목적으로 특수 호스트 이름 &lt;code&gt;&quot;localhost&quot;&lt;/code&gt; 를 사용했습니다 . 이는 항상 현재 실행중인 시스템을 의미해야합니다. localhost에 해당하는 인터넷 주소는 &lt;code&gt;&quot;127.0.0.1&quot;&lt;/code&gt; 입니다 ( 대신 사용하려는 경우).</target>
        </trans-unit>
        <trans-unit id="b0d786852f1a6c1dea1d6a765cf9070b49db2732" translate="yes" xml:space="preserve">
          <source>This is the normal entry point for automatic dynamic loading in Perl.</source>
          <target state="translated">이것은 Perl에서 자동 동적 로딩을위한 일반적인 진입 점입니다.</target>
        </trans-unit>
        <trans-unit id="26340ea40f200c2c1e1dfe6e82669d9feb0fd306" translate="yes" xml:space="preserve">
          <source>This is the normal operation. It translates various literals encountered in the Perl source file from the encoding</source>
          <target state="translated">이것은 정상적인 작동입니다. Perl 소스 파일에서 발견 된 다양한 리터럴을 인코딩에서 번역합니다.</target>
        </trans-unit>
        <trans-unit id="a889101131356644debee9dab9979e5406fc98f2" translate="yes" xml:space="preserve">
          <source>This is the old form of &lt;a href=&quot;#gv_fetchmeth_pvn_autoload&quot;&gt;gv_fetchmeth_pvn_autoload&lt;/a&gt;, which has no flags parameter.</source>
          <target state="translated">플래그 매개 변수가없는 &lt;a href=&quot;#gv_fetchmeth_pvn_autoload&quot;&gt;gv_fetchmeth_pvn_autoload&lt;/a&gt; 의 이전 형식입니다 .</target>
        </trans-unit>
        <trans-unit id="230f7f138d64e36f52758c07316eb9c1eee4e053" translate="yes" xml:space="preserve">
          <source>This is the only executable with does not require OS/2.</source>
          <target state="translated">OS / 2가 필요없는 유일한 실행 파일입니다.</target>
        </trans-unit>
        <trans-unit id="46297865ee1d382d368720a50d5f077d38b59862" translate="yes" xml:space="preserve">
          <source>This is the only form of quoting in perl where there is no need to worry about escaping content, something that code generators can and do make good use of.</source>
          <target state="translated">이것은 코드 생성기가 사용할 수 있고 잘 활용할 수있는 콘텐츠 탈출에 대해 걱정할 필요가없는 유일한 perl 인용 형식입니다.</target>
        </trans-unit>
        <trans-unit id="346faabc7115374b4309ef76fa20a9a155ac4597" translate="yes" xml:space="preserve">
          <source>This is the only implementation for which &lt;code&gt;PerlIO_apply_layers()&lt;/code&gt; does anything &quot;interesting&quot;.</source>
          <target state="translated">이것은 &lt;code&gt;PerlIO_apply_layers()&lt;/code&gt; 가 &quot;흥미로운&quot;것을 하는 유일한 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="60f1241a31b62b7745507b52788f2eba7d4fd0c6" translate="yes" xml:space="preserve">
          <source>This is the only way you can create a custom named sequence of code points.</source>
          <target state="translated">이것은 사용자 지정 명명 된 코드 포인트 시퀀스를 만들 수있는 유일한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="78dcaca387707f29d8cc3a2585a362d39b2766bf" translate="yes" xml:space="preserve">
          <source>This is the output when it is executed:</source>
          <target state="translated">이것이 실행될 때의 출력입니다.</target>
        </trans-unit>
        <trans-unit id="e716423e3a6c7217437c06867a38499b8c6c05ea" translate="yes" xml:space="preserve">
          <source>This is the preferred method of passing input to the constructor.</source>
          <target state="translated">이것은 생성자에게 입력을 전달하는 기본 방법입니다.</target>
        </trans-unit>
        <trans-unit id="3f3e131dd809784965b27d16458f5818d1df8c11" translate="yes" xml:space="preserve">
          <source>This is the preferred way to get the &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; object. You should</source>
          <target state="translated">이것은 &lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt; 객체 를 얻는 데 선호되는 방법 입니다. 당신은해야</target>
        </trans-unit>
        <trans-unit id="cf4eba93f23876936daa22cc2fcf49ea7ecb8e5d" translate="yes" xml:space="preserve">
          <source>This is the primary function for copying scalars, and most other copy-ish functions and macros use this underneath.</source>
          <target state="translated">이것은 스칼라 복사를위한 기본 기능이며 대부분의 다른 복사 기능과 매크로는이 기능을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d281635f40f0f24e55d7183cb71173555b3719a4" translate="yes" xml:space="preserve">
          <source>This is the primary interface for interacting with C&amp;lt;:temp&amp;gt;. Using the OO interface a temporary file can be created when the object is constructed and the file can be removed when the object is no longer required.</source>
          <target state="translated">이것은 C &amp;lt;: temp&amp;gt;와 상호 작용하기위한 기본 인터페이스입니다. OO 인터페이스를 사용하면 객체가 생성 될 때 임시 파일을 생성 할 수 있으며 객체가 더 이상 필요하지 않으면 파일을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05f4f2b81da1e7eb80147e0a0e24d6cb8a7b101e" translate="yes" xml:space="preserve">
          <source>This is the purpose of</source>
          <target state="translated">이것이 목적입니다</target>
        </trans-unit>
        <trans-unit id="c0f05eba3f3af5d5e22733e34a51cbbb4cab705c" translate="yes" xml:space="preserve">
          <source>This is the recommended interface for creation of temporary directories. By default the directory will not be removed on exit (that is, it won't be temporary; this behaviour can not be changed because of issues with backwards compatibility). To enable removal either use the CLEANUP option which will trigger removal on program exit, or consider using the &quot;newdir&quot; method in the object interface which will allow the directory to be cleaned up when the object goes out of scope.</source>
          <target state="translated">임시 디렉토리 작성에 권장되는 인터페이스입니다. 기본적으로 디렉토리는 종료시 제거되지 않습니다 (즉, 일시적이지 않습니다. 이전 버전과의 호환성 문제로 인해이 동작을 변경할 수 없음). 제거를 가능하게하려면 프로그램 종료시 제거를 트리거하는 CLEANUP 옵션을 사용하거나 오브젝트가 범위를 벗어날 때 디렉토리를 정리할 수있는 오브젝트 인터페이스에서 &quot;newdir&quot;메소드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bd97525cca1b83f38306d58e91365a2fad99fcd5" translate="yes" xml:space="preserve">
          <source>This is the root directory into which the code will be installed. It</source>
          <target state="translated">이것은 코드가 설치 될 루트 디렉토리입니다. 그것</target>
        </trans-unit>
        <trans-unit id="bc652aaf1adcdf8a4d8dd86919935233000111ae" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;simple&quot;&gt;Test::Simple&lt;/a&gt;'s &lt;code&gt;ok()&lt;/code&gt; routine.</source>
          <target state="translated">이것은 &lt;a href=&quot;simple&quot;&gt;Test :: Simple&lt;/a&gt; 의 &lt;code&gt;ok()&lt;/code&gt; 루틴과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="c649411547df265abe7a680926ab24280bdd17cc" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;FB_QUIET&lt;/code&gt; above, except that instead of being silent on errors, it issues a warning. This is handy for when you are debugging.</source>
          <target state="translated">이것은과 동일 &lt;code&gt;FB_QUIET&lt;/code&gt; 그 대신 오류에 침묵하는 것, 그것은이 경고를 제외하고, 위. 디버깅 할 때 편리합니다.</target>
        </trans-unit>
        <trans-unit id="0ae700aa87900b468f3878348b89397f03c7e04f" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;\h&lt;/code&gt; and &lt;code&gt;\p{Blank}&lt;/code&gt; : a character that changes the spacing horizontally.</source>
          <target state="translated">이것은 &lt;code&gt;\h&lt;/code&gt; 및 &lt;code&gt;\p{Blank}&lt;/code&gt; 같습니다. 간격을 가로로 변경하는 문자입니다.</target>
        </trans-unit>
        <trans-unit id="fbc09138370cb171c094bfc6c30b8f2a18097f95" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;\h&lt;/code&gt; and &lt;code&gt;\p{HorizSpace}&lt;/code&gt; : A character that changes the spacing horizontally.</source>
          <target state="translated">이것은 &lt;code&gt;\h&lt;/code&gt; 및 &lt;code&gt;\p{HorizSpace}&lt;/code&gt; 같습니다. 간격을 가로로 변경하는 문자입니다.</target>
        </trans-unit>
        <trans-unit id="7b5f883b8c3b129477e8adf6ce3d17842b4509c9" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;\s&lt;/code&gt;, including beyond ASCII.</source>
          <target state="translated">이것은 ASCII 이외 &lt;code&gt;\s&lt;/code&gt; 것을 포함하여 \ s 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="7e9dbff8b446293a154a68b17c80ce2409d2cfe1" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;\s&lt;/code&gt;, restricted to ASCII, namely &lt;code&gt;[ \f\n\r\t]&lt;/code&gt; and starting in Perl v5.18, a vertical tab.</source>
          <target state="translated">이것은 &lt;code&gt;\s&lt;/code&gt; 와 동일하며 ASCII로 제한됩니다. 즉 &lt;code&gt;[ \f\n\r\t]&lt;/code&gt; 수직 탭인 Perl v5.18부터 시작합니다.</target>
        </trans-unit>
        <trans-unit id="6256409cd33d9cdf7337e20319de658ce6caee15" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;\v&lt;/code&gt; : A character that changes the spacing vertically.</source>
          <target state="translated">이것은 &lt;code&gt;\v&lt;/code&gt; 와 동일 합니다. 간격을 세로로 변경하는 문자입니다.</target>
        </trans-unit>
        <trans-unit id="4da601bf04f15ab42ea7eb6f0e3d60619c539d79" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;\w&lt;/code&gt; , including over 100_000 characters beyond ASCII.</source>
          <target state="translated">이것은 ASCII를 넘어 100_000자를 초과하는 것을 포함하여 &lt;code&gt;\w&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="f93b7dea9a5c9d0ac4b1d3dcf4d8d34138603086" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;\w&lt;/code&gt; , restricted to ASCII, namely &lt;code&gt;[A-Za-z0-9_]&lt;/code&gt;</source>
          <target state="translated">이것은 &lt;code&gt;\w&lt;/code&gt; 와 동일하며 ASCII로 제한됩니다. 즉 &lt;code&gt;[A-Za-z0-9_]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8213b0c400904773c8fb4aa6534b5c57f7c89c7f" translate="yes" xml:space="preserve">
          <source>This is the same as machine name except that default matches any name. There can be only one default token, and it must be after all machine tokens. This is normally used as:</source>
          <target state="translated">기본값은 모든 이름과 일치한다는 점을 제외하면 시스템 이름과 동일합니다. 기본 토큰은 하나만있을 수 있으며 모든 머신 토큰 뒤에 있어야합니다. 일반적으로 다음과 같이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="941bd502236d1dea3c975471a03ebbb873d56ae1" translate="yes" xml:space="preserve">
          <source>This is the same as the bin variable, but is filename expanded at configuration time, for use in your makefiles.</source>
          <target state="translated">이것은 bin 변수와 동일하지만 makefile에서 사용하기 위해 구성시 파일 이름이 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="c486c8726e0003d1e95bb96e015320afb3b6dfa4" translate="yes" xml:space="preserve">
          <source>This is the same as the sitebin variable, but is filename expanded at configuration time, for use in your makefiles.</source>
          <target state="translated">이것은 sitebin 변수와 동일하지만 makefile에서 사용하기 위해 구성시 파일 이름이 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="cdc9f1e5725bf6d120b1c425b6dcc03a53feac1e" translate="yes" xml:space="preserve">
          <source>This is the same as the sitescript variable, but is filename expanded at configuration time, for use in your makefiles.</source>
          <target state="translated">이것은 sitescript 변수와 동일하지만 makefile에서 사용하기 위해 구성시 파일 이름이 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="43bee717903e4bfa25fa311f06b4356fc3deab92" translate="yes" xml:space="preserve">
          <source>This is the same executable as</source>
          <target state="translated">이것은 다음과 같은 실행 파일입니다</target>
        </trans-unit>
        <trans-unit id="9b93eb63da42a6ae191e4cb65dbdf73df302acbd" translate="yes" xml:space="preserve">
          <source>This is the same facility used by the ANSI_COLORS_ALIASES environment variable (see &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt; below) but can be used at runtime, not just when the module is loaded.</source>
          <target state="translated">이는 ANSI_COLORS_ALIASES 환경 변수 (아래 &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt; 참조)에서 사용하는 것과 동일한 기능 이지만 모듈을로드 할 때뿐만 아니라 런타임에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08be885869480e470d72f31729368e83f4f891ce" translate="yes" xml:space="preserve">
          <source>This is the semaphore &quot;P operation&quot; (the name derives from the Dutch word &quot;pak&quot;, which means &quot;capture&quot; -- the semaphore operations were named by the late Dijkstra, who was Dutch).</source>
          <target state="translated">이것은 세마포어 &quot;P operation&quot;(네덜란드어 단어 &quot;pak&quot;에서 유래 한 것으로 &quot;캡처&quot;를 의미합니다. 세마포어 조작은 네덜란드 인 Dijkstra 후기에 의해 명명되었습니다).</target>
        </trans-unit>
        <trans-unit id="2f98c90508409620ac27064f1b688373cf5874e7" translate="yes" xml:space="preserve">
          <source>This is the semaphore &quot;V operation&quot; (the name derives from the Dutch word &quot;vrij&quot;, which means &quot;release&quot;).</source>
          <target state="translated">이것은 세마포어 &quot;V operation&quot;(네덜란드어 단어 &quot;vrij&quot;에서 파생 된 &quot;release&quot;를 의미 함)입니다.</target>
        </trans-unit>
        <trans-unit id="a276cc3b822e5fb68d4f30cd1b14facc89497c26" translate="yes" xml:space="preserve">
          <source>This is the service name or port number we'd like to connect to. We could have gotten away with using just &lt;code&gt;&quot;daytime&quot;&lt;/code&gt; on systems with a well-configured system services file,[FOOTNOTE: The system services file is found in</source>
          <target state="translated">연결하고자하는 서비스 이름 또는 포트 번호입니다. 잘 구성된 시스템 서비스 파일이있는 시스템에서 &lt;code&gt;&quot;daytime&quot;&lt;/code&gt; 만 사용 하면됩니다. [FOOTNOTE : 시스템 서비스 파일은 다음 위치에 있습니다.</target>
        </trans-unit>
        <trans-unit id="55fdeec4b425af4c4fa8e9a6591ac8f8843fb073" translate="yes" xml:space="preserve">
          <source>This is the set of three-digit numeric codes from ISO 3166-1, such as 064 for Bhutan. These codes are actually defined and maintained by the U.N. Statistics division.</source>
          <target state="translated">Bhutan의 경우 064와 같이 ISO 3166-1의 3 자리 숫자 코드 세트입니다. 이 코드는 실제로 UN 통계 부서에서 정의하고 유지 관리합니다.</target>
        </trans-unit>
        <trans-unit id="233002d6fef285c425f811c11a49106685a1ea36" translate="yes" xml:space="preserve">
          <source>This is the set of three-digit numeric codes from ISO 4217.</source>
          <target state="translated">ISO 4217의 3 자리 숫자 코드 세트입니다.</target>
        </trans-unit>
        <trans-unit id="bfc22c533358da5232ffaf0870e72df120463375" translate="yes" xml:space="preserve">
          <source>This is the set of three-letter (lowercase) bibliographic codes from ISO 639-2 and 639-5, such as 'heb' for Hebrew. It also includes additions to this set included in the IANA language registry.</source>
          <target state="translated">이것은 히브리어의 경우 'heb'와 같이 ISO 639-2 및 639-5의 3 글자 (소문자) 서지 코드 세트입니다. 또한 IANA 언어 레지스트리에 포함 된이 세트에 대한 추가 사항도 포함합니다.</target>
        </trans-unit>
        <trans-unit id="b92c48de1f053f976481719f4f81fdeafd62c023" translate="yes" xml:space="preserve">
          <source>This is the set of three-letter (lowercase) codes from ISO 3166-1, such as 'brb' for Barbados. These codes are actually defined and maintained by the U.N. Statistics division.</source>
          <target state="translated">이것은 바베이도스의 경우 'brb'와 같이 ISO 3166-1의 3 문자 (소문자) 코드 세트입니다. 이 코드는 실제로 UN 통계 부서에서 정의하고 유지 관리합니다.</target>
        </trans-unit>
        <trans-unit id="fc3ae49739721f6f95ec3491951800d9f83ab84d" translate="yes" xml:space="preserve">
          <source>This is the set of three-letter (lowercase) terminologic codes from ISO 639.</source>
          <target state="translated">ISO 639의 3 글자 (소문자) 용어 코드 세트입니다.</target>
        </trans-unit>
        <trans-unit id="e6807d4fe48e31222818be49432ee24ba40f6e11" translate="yes" xml:space="preserve">
          <source>This is the set of two-letter (lowercase) codes from ISO 3166-1, such as 'tv' for Tuvalu.</source>
          <target state="translated">이것은 투발루의 경우 'tv'와 같이 ISO 3166-1의 2 자리 (소문자) 코드 세트입니다.</target>
        </trans-unit>
        <trans-unit id="acd74dadb16fbf234cd8906af18d327510923daf" translate="yes" xml:space="preserve">
          <source>This is the set of two-letter (lowercase) codes from ISO 639-1, such as 'he' for Hebrew. It also includes additions to this set included in the IANA language registry.</source>
          <target state="translated">이것은 히브리어에 대한 'he'와 같이 ISO 639-1의 두 문자 (소문자) 코드 세트입니다. 또한 IANA 언어 레지스트리에 포함 된이 세트에 대한 추가 사항도 포함합니다.</target>
        </trans-unit>
        <trans-unit id="94c349798d0090117d6582dfd31da6381fa814e6" translate="yes" xml:space="preserve">
          <source>This is the standard unix library builder. We use wlib. With Watcom 10.6, when wlib is linked as &quot;ar&quot;, it behaves like ar and all is fine. Under 9.5, a cover is required. One is included in ../qnx</source>
          <target state="translated">이것은 표준 유닉스 라이브러리 빌더입니다. 우리는 wlib를 사용합니다. Watcom 10.6에서 wlib가 &quot;ar&quot;로 연결되면 ar처럼 동작하며 모두 정상입니다. 9.5 미만에서는 커버가 필요합니다. 하나는 ../qnx에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e58e7a91164b2c61f4741d28ff686a23ffe5c5eb" translate="yes" xml:space="preserve">
          <source>This is the useragent as &lt;code&gt;LWP&lt;/code&gt; will report it.</source>
          <target state="translated">&lt;code&gt;LWP&lt;/code&gt; 가보고 할 때 이것이 useragent 입니다.</target>
        </trans-unit>
        <trans-unit id="15261bed556ba490ce02abc9f071087b0df0d036" translate="yes" xml:space="preserve">
          <source>This is the version of &lt;code&gt;Test::Harness&lt;/code&gt; .</source>
          <target state="translated">이것은 &lt;code&gt;Test::Harness&lt;/code&gt; 의 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="6a22ff202852862487c229ecb92eca4a84e51119" translate="yes" xml:space="preserve">
          <source>This is to prevent the problem of one module changing the array base out from under another module inadvertently. See &lt;a href=&quot;perlvar#%24%5b&quot;&gt;$[ in perlvar&lt;/a&gt; and &lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt;.</source>
          <target state="translated">이는 한 모듈이 다른 모듈 아래에서 어레이베이스를 실수로 변경하는 문제를 방지하기위한 것입니다. &lt;a href=&quot;perlvar#%24%5b&quot;&gt;perlvar&lt;/a&gt; 및 &lt;a href=&quot;arybase&quot;&gt;arybase의 &lt;/a&gt;$ [를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bd68c145924ef1010d3fbbd465d445886b4ed770" translate="yes" xml:space="preserve">
          <source>This is tremendously more efficient than reading the entire file into memory as an array of lines and then processing it one element at a time, which is often--if not almost always--the wrong approach. Whenever you see someone do this:</source>
          <target state="translated">이것은 전체 파일을 메모리에 행 배열로 읽어서 한 번에 한 요소 씩 처리하는 것보다 훨씬 더 효율적입니다. 누군가가 이것을 볼 때마다 :</target>
        </trans-unit>
        <trans-unit id="a35e6506a9b88f457b9f4a865f1ac711f7750ab3" translate="yes" xml:space="preserve">
          <source>This is true for all numeric template codes. But don't expect miracles: if the packed value exceeds the allotted byte capacity, high order bits are silently discarded, and unpack certainly won't be able to pull them back out of some magic hat. And, when you pack using a signed template code such as &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, an excess value may result in the sign bit getting set, and unpacking this will smartly return a negative value.</source>
          <target state="translated">이것은 모든 숫자 템플릿 코드에 적용됩니다. 그러나 기적을 기대하지 마십시오. 패킹 된 값이 할당 된 바이트 용량을 초과하면 상위 비트는 자동으로 버려지고 팩을 풀면 마술 모자에서 빼낼 수 없습니다. 또한 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 와 같은 서명 된 템플릿 코드를 사용하여 압축하면 초과 값으로 인해 부호 비트가 설정 될 수 있으며, 포장을 풀면 음수 값이 스마트하게 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e7272df8729202c7ff033cb7fabd9d5f450b6676" translate="yes" xml:space="preserve">
          <source>This is true on Unix, where &lt;code&gt;catdir(&quot;&quot;,&quot;a&quot;,&quot;b&quot;)&lt;/code&gt; yields &quot;/a/b&quot; and &lt;code&gt;rootdir()&lt;/code&gt; is &quot;/&quot;. Note that &lt;code&gt;rootdir()&lt;/code&gt; on Mac OS is the startup volume, which is the closest in concept to Unix' &quot;/&quot;. This should help to run existing scripts originally written for Unix.</source>
          <target state="translated">&lt;code&gt;catdir(&quot;&quot;,&quot;a&quot;,&quot;b&quot;)&lt;/code&gt; 가 &quot;/ a / b&quot;를 생성하고 &lt;code&gt;rootdir()&lt;/code&gt; 이 &quot;/&quot;인 Unix에서 마찬가지 입니다. 참고 &lt;code&gt;rootdir()&lt;/code&gt; 맥 OS에 대한 것은 &quot;/&quot; '유닉스 개념에 가장 가까운 시동 볼륨입니다. 이것은 원래 유닉스 용으로 작성된 기존 스크립트를 실행하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="397412f4d7a6d97f2f133b4c7f78e290d9cd2f84" translate="yes" xml:space="preserve">
          <source>This is typically used when testing cannot continue such as a critical module failing to compile or a necessary external utility not being available such as a database connection failing.</source>
          <target state="translated">이는 일반적으로 컴파일에 실패한 중요 모듈 또는 데이터베이스 연결 실패와 같은 필요한 외부 유틸리티를 사용할 수없는 등 테스트를 계속할 수 없을 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bb1c3b06955402418f9a1645b31426cf2675075b" translate="yes" xml:space="preserve">
          <source>This is ugly. As of Perl 5.9.2, there's a much nicer way to express your desire for a certain byte-order: the &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt; modifiers. &lt;code&gt;&amp;gt;&lt;/code&gt; is the big-endian modifier, while &lt;code&gt;&amp;lt;&lt;/code&gt; is the little-endian modifier. Using them, we could rewrite the above code as:</source>
          <target state="translated">이것은 추악합니다. Perl 5.9.2부터는 특정 바이트 순서에 대한 욕구를 표현하는 더 좋은 방법이 있습니다 : &lt;code&gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;&lt;/code&gt; 수정 자. &lt;code&gt;&amp;gt;&lt;/code&gt; 는 빅 엔디안 수정 자이고 &lt;code&gt;&amp;lt;&lt;/code&gt; 는 리틀 엔디안 수정 자입니다. 이를 사용하여 위 코드를 다음과 같이 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f64a4511ee072e665d5896089985a46b9305c064" translate="yes" xml:space="preserve">
          <source>This is used (optionally) by configure to list the contents of libraries. I will generate a cover function on the fly in the UU directory.</source>
          <target state="translated">라이브러리의 내용을 나열하도록 구성하여 선택적으로 사용됩니다. UU 디렉토리에서 즉시 표지 기능을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e13da45b8fdb5dfbf619cb00d77540e51b9f0de1" translate="yes" xml:space="preserve">
          <source>This is used by Perl itself only for accessing operating system error messages via &lt;a href=&quot;perlvar#%24ERRNO&quot;&gt;$!&lt;/a&gt; and &lt;a href=&quot;perlvar#%24EXTENDED_OS_ERROR&quot;&gt;$^E&lt;/a&gt;.</source>
          <target state="translated">이것은 Perl 자체에서 &lt;a href=&quot;perlvar#%24ERRNO&quot;&gt;$!&lt;/a&gt; 를 통해 운영 체제 오류 메시지에 액세스하는 데만 사용됩니다 . 그리고 &lt;a href=&quot;perlvar#%24EXTENDED_OS_ERROR&quot;&gt;$ ^ E&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="685a67efb688fb26fb65af406110717f25e2b745" translate="yes" xml:space="preserve">
          <source>This is used by XS code that that is &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale-aware to force the locale for category &lt;code&gt;LC_NUMERIC&lt;/code&gt; to be what perl thinks is the current underlying locale. (The perl interpreter could be wrong about what the underlying locale actually is if some C or XS code has called the C library function</source>
          <target state="translated">XS 코드에서 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 로케일을 인식하여 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 카테고리의 로케일이 펄이 현재 기본 로케일이라고 생각하는 것으로 강제합니다 . (C 또는 XS 코드가 C 라이브러리 함수를 호출 한 경우 기본 로케일이 실제로 무엇인지 Perl 인터프리터가 잘못되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e065e9419827f7c0624c9591e7e2d9d64727710" translate="yes" xml:space="preserve">
          <source>This is used by perl to run external commands which explicitly require shell, like the commands using</source>
          <target state="translated">이것은 perl에서 사용하는 명령과 같이 명시 적으로 쉘이 필요한 외부 명령을 실행하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="64698930b8cfe161fa438c57b55293be0ad5eced" translate="yes" xml:space="preserve">
          <source>This is used by the &lt;code&gt;perldoc&lt;/code&gt; program (see &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt;), and may be used to generate HTML documentation usable by WWW browsers, and documentation in zillions of other formats: &lt;code&gt;info&lt;/code&gt; , &lt;code&gt;LaTeX&lt;/code&gt; , &lt;code&gt;Acrobat&lt;/code&gt; , &lt;code&gt;FrameMaker&lt;/code&gt; and so on. [Use programs such as</source>
          <target state="translated">이것은 &lt;code&gt;perldoc&lt;/code&gt; 프로그램에 의해 사용되며 ( &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt; 참조 ) WWW 브라우저에서 사용할 수있는 HTML 문서 및 &lt;code&gt;info&lt;/code&gt; , &lt;code&gt;LaTeX&lt;/code&gt; , &lt;code&gt;Acrobat&lt;/code&gt; , &lt;code&gt;FrameMaker&lt;/code&gt; 등 다른 형식의 문서를 생성하는 데 사용될 수 있습니다 . [다음과 같은 프로그램 사용</target>
        </trans-unit>
        <trans-unit id="938e99644f7869851b92cffce88c437cad0e1198" translate="yes" xml:space="preserve">
          <source>This is used for instance by &lt;a href=&quot;http://search.cpan.org/perldoc/Math::BigInt::Constant&quot;&gt;Math::BigInt::Constant&lt;/a&gt;.</source>
          <target state="translated">예를 들어 &lt;a href=&quot;http://search.cpan.org/perldoc/Math::BigInt::Constant&quot;&gt;Math :: BigInt :: Constant에&lt;/a&gt; 의해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="89a92812a074e6032ec40db97f0e02dae0db9d29" translate="yes" xml:space="preserve">
          <source>This is used for passing perl filehandles to and from C using &lt;code&gt;FILE *&lt;/code&gt; structures.</source>
          <target state="translated">이것은 &lt;code&gt;FILE *&lt;/code&gt; 구조를 사용하여 perl 파일 핸들을 C와주고받습니다 .</target>
        </trans-unit>
        <trans-unit id="e990faa3bfbeb576a41b956da185db53775fca9a" translate="yes" xml:space="preserve">
          <source>This is used for passing perl filehandles to and from C using &lt;code&gt;PerlIO *&lt;/code&gt; structures. The file handle can used for reading and writing. This corresponds to the &lt;code&gt;+&amp;lt;&lt;/code&gt; mode, see also T_IN and T_OUT.</source>
          <target state="translated">이것은 &lt;code&gt;PerlIO *&lt;/code&gt; 구조를 사용하여 perl 파일 핸들을 C와주고받는 데 사용됩니다 . 파일 핸들은 읽고 쓰는 데 사용할 수 있습니다. 이것은 &lt;code&gt;+&amp;lt;&lt;/code&gt; 모드에 해당합니다 ( T_IN 및 T_OUT 참조).</target>
        </trans-unit>
        <trans-unit id="45afb2cb863a986ba92ff0947755735a5e6d66a7" translate="yes" xml:space="preserve">
          <source>This is used for tests that under some conditions can be skipped. It's basically equivalent to:</source>
          <target state="translated">일부 조건에서 건너 뛸 수있는 테스트에 사용됩니다. 기본적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9e0a9f53f8706ee02f00b4b66258c8d781bdebc5" translate="yes" xml:space="preserve">
          <source>This is used heavily by Configure and then by perl itself. QNX4's version is fine, but Configure will choke on the 16-bit version, so if you are running QNX 4.22, link /bin/sh to /bin32/ksh</source>
          <target state="translated">이것은 Configure와 perl 자체에 의해 많이 사용됩니다. QNX4의 버전은 정상이지만 구성은 16 비트 버전에서 질식하므로 QNX 4.22를 실행중인 경우 / bin / sh를 / bin32 / ksh에 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="88552389c076b1697dd901849fcd278da90bf901" translate="yes" xml:space="preserve">
          <source>This is used in conjunction with one of the macros &lt;a href=&quot;#STORE_LC_NUMERIC_SET_TO_NEEDED&quot;&gt;STORE_LC_NUMERIC_SET_TO_NEEDED&lt;/a&gt; and &lt;a href=&quot;#STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&quot;&gt;STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&lt;/a&gt;</source>
          <target state="translated">매크로 &lt;a href=&quot;#STORE_LC_NUMERIC_SET_TO_NEEDED&quot;&gt;STORE_LC_NUMERIC_SET_TO_NEEDED&lt;/a&gt; 및 &lt;a href=&quot;#STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&quot;&gt;STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&lt;/a&gt; 매크로 중 하나와 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="51b114b6070b2dbbb4c5faa25f40aadc4f1bf209" translate="yes" xml:space="preserve">
          <source>This is used internally by various sv-modifying functions, such as sv_setsv, sv_setiv and sv_pvn_force.</source>
          <target state="translated">이것은 sv_setsv, sv_setiv 및 sv_pvn_force와 같은 다양한 sv 수정 기능에 의해 내부적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2674017b922020ed58a1ae38d38243bb158c698b" translate="yes" xml:space="preserve">
          <source>This is used to convert the perl argument list to a C array and for pushing the contents of a C array onto the perl argument stack.</source>
          <target state="translated">이것은 perl 인수 목록을 C 배열로 변환하고 C 배열의 내용을 perl 인수 스택으로 푸시하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1dfca62a32b70d4bff67e06bed578f950673ab61" translate="yes" xml:space="preserve">
          <source>This is used to help wrap XS or C code that that is &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale-aware. This locale category is generally kept set to the C locale by Perl for backwards compatibility, and because most XS code that reads floating point values can cope only with the decimal radix character being a dot.</source>
          <target state="translated">&lt;code&gt;LC_NUMERIC&lt;/code&gt; 로케일을 인식 하는 XS 또는 C 코드를 래핑하는 데 사용됩니다 . 이 로케일 범주는 일반적으로 이전 버전과의 호환성을 위해 Perl에 의해 C 로케일로 설정되며, 부동 소수점 값을 읽는 대부분의 XS 코드는 10 진수 기수 문자 만 점으로 처리 할 수 ​​있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="61ffe3ce8492ad29999613fc31942e00c100ad7a" translate="yes" xml:space="preserve">
          <source>This is used to set the build type to debug or release. Change the build type only after executing SetNWBld.bat</source>
          <target state="translated">빌드 유형을 디버그 또는 릴리스로 설정하는 데 사용됩니다. SetNWBld.bat를 실행 한 후에 만 ​​빌드 유형을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="33295dd981a7660fbc204da5e0a0ad1772d342a0" translate="yes" xml:space="preserve">
          <source>This is used to track which tests unexpectedly succeeded.</source>
          <target state="translated">예기치 않은 테스트 결과를 추적하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="717574ff9403ecd69bea9a30328bf1a90f831842" translate="yes" xml:space="preserve">
          <source>This is used to write code for styles of operating system. See os_flavor_is() for use.</source>
          <target state="translated">운영 체제 스타일에 대한 코드를 작성하는 데 사용됩니다. 사용하려면 os_flavor_is ()를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a64fac67cd72a00814ab828e9c9bd92a6463973e" translate="yes" xml:space="preserve">
          <source>This is useful for code like:</source>
          <target state="translated">이것은 다음과 같은 코드에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="0a2bc63942e3a80b89ce25e1ac1f8a32f3bda215" translate="yes" xml:space="preserve">
          <source>This is useful for keeping copies of references, but you don't want to prevent the object being DESTROY-ed at its usual time.</source>
          <target state="translated">이것은 참조 사본을 유지하는 데 유용하지만 일반적인 시간에 오브젝트가 삭제되는 것을 막고 싶지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="42a4e9a54829e179cb44fc85ba544f789e1c2e15" translate="yes" xml:space="preserve">
          <source>This is useful if you want to report then some other way than &lt;code&gt;carp&lt;/code&gt; 'ing when the verbose flag is on.</source>
          <target state="translated">상세 플래그가 켜져있을 때 &lt;code&gt;carp&lt;/code&gt; 'ing 이외의 다른 방법으로보고하려는 경우 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="3180e175adf2fd8ff88aab37691cd4b1c546dfea" translate="yes" xml:space="preserve">
          <source>This is useful to avoid a CODE: block for a C function which takes a parameter by reference. Typically, the parameter should be not a pointer type (an &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;long&lt;/code&gt; but not an &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int*&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;long*&lt;/code&gt; ).</source>
          <target state="translated">이것은 참조로 매개 변수를 취하는 C 함수에 대한 CODE : 블록을 피하는 데 유용합니다. 일반적으로 매개 변수는 포인터 유형이 아니어야합니다 ( &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;long&lt;/code&gt; 이지만 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int*&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;long*&lt;/code&gt; 아님).</target>
        </trans-unit>
        <trans-unit id="9e13765136cecd81d6e3522084679384fb85c0ae" translate="yes" xml:space="preserve">
          <source>This is useful when calculating checksum for files:</source>
          <target state="translated">파일의 체크섬을 계산할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="61dbd2c8b8aff05e41e7c5996e136b2e52680ad0" translate="yes" xml:space="preserve">
          <source>This is useful with sockets when you want to tell the other side you're done writing but not done reading, or vice versa. It's also a more insistent form of close because it also disables the file descriptor in any forked copies in other processes.</source>
          <target state="translated">이것은 당신이 다른쪽에 당신이 글을 다 읽었지만 읽지 않았다고 말하고 싶거나 반대의 경우를 말하고 싶을 때 소켓에 유용합니다. 또한 다른 프로세스의 분기 사본에서 파일 디스크립터를 사용하지 않기 때문에보다 일관된 닫기 양식입니다.</target>
        </trans-unit>
        <trans-unit id="f513c390b6f7958ee20cf98d8560715b5f8df7bb" translate="yes" xml:space="preserve">
          <source>This is variable gets set in various places to tell i_fcntl that &amp;lt;fcntl.h&amp;gt; should be included.</source>
          <target state="translated">이 변수는 i_fcntl에게 &amp;lt;fcntl.h&amp;gt;가 포함되어야한다는 것을 알리기 위해 다양한 곳에서 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a219720ed763ff153bf9c4206e6fc4962fcc28fa" translate="yes" xml:space="preserve">
          <source>This is variable gets set in various places to tell i_sys_file that &amp;lt;sys/file.h&amp;gt; should be included.</source>
          <target state="translated">이 변수는 i_sys_file에 &amp;lt;sys / file.h&amp;gt;가 포함되어야 함을 알리기 위해 다양한 위치에 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="c6c48e550cd9137be036063a2bb992fbdc655583" translate="yes" xml:space="preserve">
          <source>This is very dangerous, as you may block forever. It assumes it's going to talk to something like &lt;b&gt;bc&lt;/b&gt;, both writing to it and reading from it. This is presumably safe because you &quot;know&quot; that commands like &lt;b&gt;bc&lt;/b&gt; will read a line at a time and output a line at a time. Programs like &lt;b&gt;sort&lt;/b&gt; that read their entire input stream first, however, are quite apt to cause deadlock.</source>
          <target state="translated">당신은 영원히 차단할 수 있기 때문에 이것은 매우 위험합니다. 그것은 쓰기와 읽기 모두에서 &lt;b&gt;bc&lt;/b&gt; 와 같은 것으로 이야기 할 것이라고 가정 합니다. 이것은 &lt;b&gt;bc&lt;/b&gt; 와 같은 명령이 한 번에 한 줄을 읽고 한 번에 한 줄을 출력 한다는 것을 &quot;알기&quot;때문에 아마도 안전합니다 . 그러나 전체 입력 스트림을 먼저 읽는 &lt;b&gt;정렬&lt;/b&gt; 과 &lt;b&gt;같은&lt;/b&gt; 프로그램은 교착 상태가 발생하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="4d27e7008a46081de6bf70cf35ea9983d5762e5e" translate="yes" xml:space="preserve">
          <source>This is very similar to &quot;How do I process an entire hash?&quot;, also in &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt;, but a bit simpler in the common cases.</source>
          <target state="translated">이것은 &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt; 에서도 &quot;전체 해시를 어떻게 처리합니까?&quot;와 매우 유사 하지만 일반적인 경우에는 조금 더 단순합니다.</target>
        </trans-unit>
        <trans-unit id="e597cd56d56a437656a2f431e5a405bb225ea80c" translate="yes" xml:space="preserve">
          <source>This is very useful if you insist on taking an array reference as argument for example.</source>
          <target state="translated">예를 들어 배열 참조를 인수로 사용하려는 경우 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="9ecc6a74af1d686f96a51556930a084f0975a2d7" translate="yes" xml:space="preserve">
          <source>This is what APPNOTE.TXT has to say on what should be stored in the zip filename header field.</source>
          <target state="translated">이것이 APPNOTE.TXT가 zip 파일 이름 헤더 필드에 저장해야 할 내용에 대한 내용입니다.</target>
        </trans-unit>
        <trans-unit id="ccdaae868b02e396a128e9209508dfb651981fc3" translate="yes" xml:space="preserve">
          <source>This is what system() (see &lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;), &lt;code&gt;``&lt;/code&gt; (see &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;), and</source>
          <target state="translated">이것은 system () ( &lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; 참조 ), &lt;code&gt;``&lt;/code&gt; ( &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;perlop의 I / O 연산자&lt;/a&gt; 참조 ) 및</target>
        </trans-unit>
        <trans-unit id="57e5ac17ec3c4ac0ba4b990c6d906bee2bbc734b" translate="yes" xml:space="preserve">
          <source>This is what you really need to know as an XS programmer, of course. When an XSUB returns a pointer to a C structure that pointer is stored in an SV and a reference to that SV is placed on the XSUB stack. So the output from an XSUB which uses something like the T_PTROBJ map might look something like this:</source>
          <target state="translated">이것은 물론 XS 프로그래머로서 알아야 할 것입니다. XSUB가 C 구조에 대한 포인터를 반환하면 해당 포인터는 SV에 저장되고 해당 SV에 대한 참조는 XSUB 스택에 배치됩니다. 따라서 T_PTROBJ 맵과 같은 것을 사용하는 XSUB의 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4310f6ad3f6095c3049af8ec37cf9d1c7e8bca42" translate="yes" xml:space="preserve">
          <source>This is when the firewall implemented in the kernel (via NAT, or networking address translation), it allows you to hide a complete network behind one IP address. With this firewall no special compiling is needed as you can access hosts directly.</source>
          <target state="translated">방화벽에서 NAT로 구현 된 방화벽 (NAT 또는 네트워킹 주소 변환)을 사용하면 하나의 IP 주소 뒤에 완전한 네트워크를 숨길 수 있습니다. 이 방화벽을 사용하면 호스트에 직접 액세스 할 수 있으므로 특별한 컴파일이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fb3eba7f97ab07f3173100c09ae1ea0eedcc95ab" translate="yes" xml:space="preserve">
          <source>This is when the firewall machine runs a web server, and to access the outside world, you must do so via that web server. If you set environment variables like http_proxy or ftp_proxy to values beginning with http://, or in your web browser you've proxy information set, then you know you are running behind an http firewall.</source>
          <target state="translated">방화벽 시스템이 웹 서버를 실행하고 외부 세계에 액세스하려면 해당 웹 서버를 통해이를 수행해야합니다. http_proxy 또는 ftp_proxy와 같은 환경 변수를 http : //로 시작하는 값으로 설정하거나 웹 브라우저에서 프록시 정보를 설정 한 경우 http 방화벽 뒤에서 실행중인 것입니다.</target>
        </trans-unit>
        <trans-unit id="75c3d5cffa21770fa5fe6937e649710847afafb8" translate="yes" xml:space="preserve">
          <source>This is when you see something like:</source>
          <target state="translated">이것은 다음과 같은 것을 볼 때입니다.</target>
        </trans-unit>
        <trans-unit id="2ad104027af291dcad88bf06901ecbc700b85cc1" translate="yes" xml:space="preserve">
          <source>This is where roles come in. It makes a lot of sense to create a &lt;code&gt;HasOnOffSwitch&lt;/code&gt; role and apply it to both classes. This role would define a known API like providing &lt;code&gt;turn_on()&lt;/code&gt; and &lt;code&gt;turn_off()&lt;/code&gt; methods.</source>
          <target state="translated">역할이 들어오는 곳입니다. &lt;code&gt;HasOnOffSwitch&lt;/code&gt; 역할 을 만들어 두 클래스에 모두 적용하는 것이 좋습니다. 이 역할은 &lt;code&gt;turn_on()&lt;/code&gt; 및 &lt;code&gt;turn_off()&lt;/code&gt; 메소드 제공과 같은 알려진 API를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="4320c9ea9a75ef79b1c739e5fcf494dc9cfb50f4" translate="yes" xml:space="preserve">
          <source>This is which protocol to use. In this case, the socket handle returned will be connected to a TCP socket, because we want a stream-oriented connection, that is, one that acts pretty much like a plain old file. Not all sockets are this of this type. For example, the UDP protocol can be used to make a datagram socket, used for message-passing.</source>
          <target state="translated">사용할 프로토콜입니다. 이 경우 반환 된 소켓 핸들은 TCP 소켓에 연결됩니다. 스트림 지향 연결, 즉 평범한 오래된 파일과 매우 유사한 연결을 원하기 때문입니다. 모든 소켓이이 유형의 것은 아닙니다. 예를 들어 UDP 프로토콜을 사용하여 메시지 전달에 사용되는 데이터 그램 소켓을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30ceb66515d4a53e1d2f25ce989ec733d96ff6db" translate="yes" xml:space="preserve">
          <source>This is which protocol to use. Like our clients, we'll still specify &lt;code&gt;&quot;tcp&quot;&lt;/code&gt; here.</source>
          <target state="translated">사용할 프로토콜입니다. 고객과 마찬가지로 여기에도 &lt;code&gt;&quot;tcp&quot;&lt;/code&gt; 를 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="04d23d996b25b2c2795e313433104ffdca7710c6" translate="yes" xml:space="preserve">
          <source>This is, I hope, a natural term given the implementation, and should avoid connotations that are inherent in earlier uses of &quot;discipline&quot; for things which are rather different.</source>
          <target state="translated">이것은 구현이 주어 졌을 때의 자연스러운 용어이므로, 다소 다른 것들에 대한 &quot;징계&quot;의 초기 사용에 내재 된 의미를 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="921e3efa52591567d6779d551efd563ccc94a973" translate="yes" xml:space="preserve">
          <source>This isn't as simple a question as it sounds. There are two parts:</source>
          <target state="translated">이것은 단순한 질문이 아닙니다. 두 부분이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="033f6ccbcb480bbc0ac7d9079cba07009a6cd094" translate="yes" xml:space="preserve">
          <source>This item specifies the name by which the linker knows the extension, which may be different from the name of the extension itself (for instance, some linkers add an '_' to the name of the extension). If it is not specified, it is derived from the NAME attribute. It is presently used only by OS2 and Win32.</source>
          <target state="translated">이 항목은 링커가 확장명을 알고있는 이름을 지정하며, 이는 확장명 자체와 다를 수 있습니다 (예를 들어, 일부 링커는 확장명에 '_'를 추가 함). 지정하지 않으면 NAME 속성에서 파생됩니다. 현재 OS2 및 Win32에서만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d17e4bc352cfe7c72913c884191bd7c2a2036595" translate="yes" xml:space="preserve">
          <source>This key allows for variable weighting of variable collation elements, which are marked with an ASTERISK in the table (NOTE: Many punctuation marks and symbols are variable in</source>
          <target state="translated">이 키를 사용하면 표에서 별표로 표시된 가변 데이터 정렬 요소의 가변 가중치를 사용할 수 있습니다 (참고 : 많은 문장 부호 및 기호는</target>
        </trans-unit>
        <trans-unit id="cb089e180f4d1e1151abdbf8ed66a17ba5f2e56e" translate="yes" xml:space="preserve">
          <source>This key can be used to specify the name of the linker option file (minus the OS-specific extension), if for some reason you do not want to use the default value, which is the last word of the NAME attribute (</source>
          <target state="translated">어떤 이유로 든 NAME 속성의 마지막 단어 인 기본값을 사용하지 않으려는 경우이 키를 사용하여 링커 옵션 파일의 이름 (OS 별 확장자 제외)을 지정할 수 있습니다 (</target>
        </trans-unit>
        <trans-unit id="6dc6a49c5fb309cc8a7f7ab658d2498baeeb643a" translate="yes" xml:space="preserve">
          <source>This keyword allows one to define an INTERFACE using a different way to extract a function pointer from an XSUB. The text which follows this keyword should give the name of macros which would extract/set a function pointer. The extractor macro is given return type, &lt;code&gt;CV*&lt;/code&gt; , and &lt;code&gt;XSANY.any_dptr&lt;/code&gt; for this &lt;code&gt;CV*&lt;/code&gt; . The setter macro is given cv, and the function pointer.</source>
          <target state="translated">이 키워드를 사용하면 XSUB에서 함수 포인터를 추출하는 다른 방법을 사용하여 인터페이스를 정의 할 수 있습니다. 이 키워드 다음에 나오는 텍스트는 함수 포인터를 추출 / 설정할 매크로의 이름을 제공해야합니다. 추출기 매크로에는 이 &lt;code&gt;CV*&lt;/code&gt; 대한 리턴 유형 &lt;code&gt;CV*&lt;/code&gt; 및 &lt;code&gt;XSANY.any_dptr&lt;/code&gt; 이 제공 됩니다. setter 매크로에는 cv와 함수 포인터가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="2eb4e29be94617115ad887f08c53a3d0726b0bcf" translate="yes" xml:space="preserve">
          <source>This keyword can be used to pull other files into the XS module. The other files may have XS code. INCLUDE: can also be used to run a command to generate the XS code to be pulled into the module.</source>
          <target state="translated">이 키워드는 다른 파일을 XS 모듈로 가져 오는 데 사용할 수 있습니다. 다른 파일에는 XS 코드가있을 수 있습니다. INCLUDE : 명령을 실행하여 모듈로 가져올 XS 코드를 생성 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ed11759f14ddd60bb197c65bf243efdd708cc88" translate="yes" xml:space="preserve">
          <source>This keyword can be used when an XSUB requires special cleanup procedures before it terminates. When the CLEANUP: keyword is used it must follow any CODE:, or OUTPUT: blocks which are present in the XSUB. The code specified for the cleanup block will be added as the last statements in the XSUB.</source>
          <target state="translated">XSUB가 종료되기 전에 특별한 정리 절차가 필요한 경우이 키워드를 사용할 수 있습니다. CLEANUP : 키워드를 사용하는 경우 XSUB에있는 CODE : 또는 OUTPUT : 블록을 따라야합니다. 정리 블록에 지정된 코드가 XSUB의 마지막 명령문으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="7ea24ab5d7dbe276068f1e0046e6f8d0e31be74b" translate="yes" xml:space="preserve">
          <source>This keyword can be used when an XSUB requires special procedures executed after the C subroutine call is performed. When the POSTCALL: keyword is used it must precede OUTPUT: and CLEANUP: blocks which are present in the XSUB.</source>
          <target state="translated">이 키워드는 XSUB에 C 서브 루틴 호출이 수행 된 후 실행되는 특수 프로 시저가 필요할 때 사용할 수 있습니다. POSTCALL : 키워드를 사용하는 경우 XSUB에있는 OUTPUT : 및 CLEANUP : 블록 앞에 와야합니다.</target>
        </trans-unit>
        <trans-unit id="ae2e5d68051ec8479ea84ba54d17bcf4606d62cb" translate="yes" xml:space="preserve">
          <source>This keyword declares the current XSUB as a keeper of the given calling signature. If some text follows this keyword, it is considered as a list of functions which have this signature, and should be attached to the current XSUB.</source>
          <target state="translated">이 키워드는 현재 XSUB를 지정된 호출 서명의 키퍼로 선언합니다. 이 키워드 뒤에 일부 텍스트가있는 경우이 키워드가있는 함수 목록으로 간주되며 현재 XSUB에 첨부되어야합니다.</target>
        </trans-unit>
        <trans-unit id="58666c3be919a203268b54d032b3c1bf1338cbb5" translate="yes" xml:space="preserve">
          <source>This keyword is available only when the &lt;code&gt;&quot;fc&quot;&lt;/code&gt; feature is enabled, or when prefixed with &lt;code&gt;CORE::&lt;/code&gt; ; See &lt;a href=&quot;../feature&quot;&gt;feature&lt;/a&gt;. Alternately, include a &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; or later to the current scope.</source>
          <target state="translated">이 키워드는 &lt;code&gt;&quot;fc&quot;&lt;/code&gt; 기능을 사용하거나 &lt;code&gt;CORE::&lt;/code&gt; 접두사 가있는 경우에만 사용할 수 있습니다 . &lt;a href=&quot;../feature&quot;&gt;기능을&lt;/a&gt; 참조하십시오 . 또는 현재 범위에 대한 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; 이상을 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="42d2aecd2684fd64241ade61155e375dd422775d" translate="yes" xml:space="preserve">
          <source>This keyword is available only when the &lt;code&gt;&quot;fc&quot;&lt;/code&gt; feature is enabled, or when prefixed with &lt;code&gt;CORE::&lt;/code&gt; ; See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;. Alternately, include a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; or later to the current scope.</source>
          <target state="translated">이 키워드는 &lt;code&gt;&quot;fc&quot;&lt;/code&gt; 기능을 사용하거나 &lt;code&gt;CORE::&lt;/code&gt; 접두사 가있는 경우에만 사용할 수 있습니다 . &lt;a href=&quot;feature&quot;&gt;기능을&lt;/a&gt; 참조하십시오 . 또는 현재 범위에 대한 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; 이상을 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="f176175c36b805a68ac4fb3277c81ce3879ff21b" translate="yes" xml:space="preserve">
          <source>This keyword is available only when the &lt;code&gt;&quot;say&quot;&lt;/code&gt; feature is enabled, or when prefixed with &lt;code&gt;CORE::&lt;/code&gt; ; see &lt;a href=&quot;../feature&quot;&gt;feature&lt;/a&gt;. Alternately, include a &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.10&lt;/code&gt; or later to the current scope.</source>
          <target state="translated">이 키워드는 &lt;code&gt;&quot;say&quot;&lt;/code&gt; 기능이 활성화되어 있거나 &lt;code&gt;CORE::&lt;/code&gt; 접두사가 붙은 경우 에만 사용할 수 있습니다 . &lt;a href=&quot;../feature&quot;&gt;기능을&lt;/a&gt; 참조하십시오 . 또는 현재 범위에 대한 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.10&lt;/code&gt; 이상을 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="7248453615df5e8da2ccdbead940326c86edd409" translate="yes" xml:space="preserve">
          <source>This keyword is available only when the &lt;code&gt;&quot;say&quot;&lt;/code&gt; feature is enabled, or when prefixed with &lt;code&gt;CORE::&lt;/code&gt; ; see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;. Alternately, include a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.10&lt;/code&gt; or later to the current scope.</source>
          <target state="translated">이 키워드는 &lt;code&gt;&quot;say&quot;&lt;/code&gt; 기능이 활성화되어 있거나 &lt;code&gt;CORE::&lt;/code&gt; 접두사가 붙은 경우 에만 사용할 수 있습니다 . &lt;a href=&quot;feature&quot;&gt;기능을&lt;/a&gt; 참조하십시오 . 또는 현재 범위에 대한 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.10&lt;/code&gt; 이상을 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="4ef9d8d4891aa770100745063fafba75dd87bbdc" translate="yes" xml:space="preserve">
          <source>This keyword is documented in &lt;a href=&quot;../perlsub#Autoloading&quot;&gt;Autoloading in perlsub&lt;/a&gt;.</source>
          <target state="translated">이 키워드는 &lt;a href=&quot;../perlsub#Autoloading&quot;&gt;perlsub의 자동로드에 설명되어&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="017edb25f20d66cd7958f76d9e8eba1497b2b334" translate="yes" xml:space="preserve">
          <source>This keyword is documented in &lt;a href=&quot;perlsub#Autoloading&quot;&gt;Autoloading in perlsub&lt;/a&gt;.</source>
          <target state="translated">이 키워드는 &lt;a href=&quot;perlsub#Autoloading&quot;&gt;perlsub의 자동로드에 설명되어&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7b17b66d48631c7667c9941d17b69ddf9ef0b49" translate="yes" xml:space="preserve">
          <source>This keyword is enabled by the &lt;code&gt;&quot;switch&quot;&lt;/code&gt; feature; see &lt;a href=&quot;../feature&quot;&gt;feature&lt;/a&gt; for more information on &lt;code&gt;&quot;switch&quot;&lt;/code&gt; . You can also access it by prefixing it with &lt;code&gt;CORE::&lt;/code&gt; . Alternatively, include a &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.10&lt;/code&gt; or later to the current scope.</source>
          <target state="translated">이 키워드는 &lt;code&gt;&quot;switch&quot;&lt;/code&gt; 기능으로 활성화됩니다 . &lt;code&gt;&quot;switch&quot;&lt;/code&gt; 에 대한 자세한 내용 은 &lt;a href=&quot;../feature&quot;&gt;기능&lt;/a&gt; 을 참조하십시오 . 접두사 &lt;code&gt;CORE::&lt;/code&gt; 사용하여 액세스 할 수도 있습니다 . 또는 현재 범위에 대한 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.10&lt;/code&gt; v5.10 이상을 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="bcf1ac4839e0d0322a8d99444375f29015dd872d" translate="yes" xml:space="preserve">
          <source>This keyword is enabled by the &lt;code&gt;&quot;switch&quot;&lt;/code&gt; feature; see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; for more information on &lt;code&gt;&quot;switch&quot;&lt;/code&gt; . You can also access it by prefixing it with &lt;code&gt;CORE::&lt;/code&gt; . Alternatively, include a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.10&lt;/code&gt; or later to the current scope.</source>
          <target state="translated">이 키워드는 &lt;code&gt;&quot;switch&quot;&lt;/code&gt; 기능으로 활성화됩니다 . &lt;code&gt;&quot;switch&quot;&lt;/code&gt; 에 대한 자세한 내용 은 &lt;a href=&quot;feature&quot;&gt;기능&lt;/a&gt; 을 참조하십시오 . 접두사 &lt;code&gt;CORE::&lt;/code&gt; 사용하여 액세스 할 수도 있습니다 . 또는 현재 범위에 대한 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.10&lt;/code&gt; v5.10 이상을 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="29762772c48cba2696e2ebbb42e9c2d4888e7318" translate="yes" xml:space="preserve">
          <source>This keyword is similar to the PROTOTYPES: keyword above but can be used to force &lt;b&gt;xsubpp&lt;/b&gt; to use a specific prototype for the XSUB. This keyword overrides all other prototype options and keywords but affects only the current XSUB. Consult &lt;a href=&quot;perlsub#Prototypes&quot;&gt;Prototypes in perlsub&lt;/a&gt; for information about Perl prototypes.</source>
          <target state="translated">이 키워드는 위의 PROTOTYPES : 키워드와 유사하지만 &lt;b&gt;xsubpp&lt;/b&gt; 가 XSUB에 특정 프로토 타입을 사용하도록 강제하는 데 사용할 수 있습니다 . 이 키워드는 다른 모든 프로토 타입 옵션 및 키워드를 무시하지만 현재 XSUB에만 영향을줍니다. Perl 프로토 타입에 대한 정보 &lt;a href=&quot;perlsub#Prototypes&quot;&gt;는 perlsub의 프로토 타입을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="85b8915eb7407eed5e4863e8fa3af3a2f3aafc0d" translate="yes" xml:space="preserve">
          <source>This keyword is used in more complicated XSUBs which require special handling for the C function. The RETVAL variable is still declared, but it will not be returned unless it is specified in the OUTPUT: section.</source>
          <target state="translated">이 키워드는 C 함수를 특수하게 처리해야하는보다 복잡한 XSUB에서 사용됩니다. RETVAL 변수는 여전히 선언되어 있지만 OUTPUT : 섹션에 지정되어 있지 않으면 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aa7963343b84df8b23c604395808970c0e2420a5" translate="yes" xml:space="preserve">
          <source>This keyword makes sense only if &lt;code&gt;RETVAL&lt;/code&gt; is going to be accessed by the user-supplied code. It is especially useful to make a function interface more Perl-like, especially when the C return value is just an error condition indicator. For example,</source>
          <target state="translated">이 키워드는 &lt;code&gt;RETVAL&lt;/code&gt; 이 사용자 제공 코드에 의해 액세스 될 경우에만 의미 가 있습니다. 특히 C 리턴 값이 오류 조건 표시 기일 때 함수 인터페이스를 Perl과 유사하게 만드는 것이 특히 유용합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="b1b52e23340e03d5e2d9ec935c2b222b8a59f7e3" translate="yes" xml:space="preserve">
          <source>This keyword may be used any time after the first MODULE keyword and should appear on a line by itself. The first blank line after the keyword will terminate the code block.</source>
          <target state="translated">이 키워드는 첫 번째 MODULE 키워드 다음에 언제든지 사용할 수 있으며 한 줄에 나타나야합니다. 키워드 다음의 첫 번째 빈 줄은 코드 블록을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="8c3c885b0fa12332744123cf10bb6f10b80fe29e" translate="yes" xml:space="preserve">
          <source>This keyword should follow the PACKAGE keyword when used. If PACKAGE is not used then PREFIX should follow the MODULE keyword.</source>
          <target state="translated">이 키워드는 사용될 때 PACKAGE 키워드 뒤에 와야합니다. PACKAGE를 사용하지 않으면 PREFIX는 MODULE 키워드를 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="febcd526951ded918c85fd19d9088e687e73cc02" translate="yes" xml:space="preserve">
          <source>This keyword will normally be used to complement the CODE: keyword. The RETVAL variable is not recognized as an output variable when the CODE: keyword is present. The OUTPUT: keyword is used in this situation to tell the compiler that RETVAL really is an output variable.</source>
          <target state="translated">이 키워드는 일반적으로 CODE : 키워드를 보완하는 데 사용됩니다. CODE : 키워드가 있으면 RETVAL 변수가 출력 변수로 인식되지 않습니다. 이 상황에서는 OUTPUT : 키워드를 사용하여 RETVAL이 실제로 출력 변수임을 컴파일러에 알립니다.</target>
        </trans-unit>
        <trans-unit id="cb6c35b047be04a4c7f82192e6412bfe49f97ba3" translate="yes" xml:space="preserve">
          <source>This last example is purely for purposes of completeness. You should not be trying to mess with the attributes of something in a package that's not your own.</source>
          <target state="translated">이 마지막 예는 순수성을위한 것입니다. 자신의 패키지가 아닌 패키지의 속성을 엉망으로 만들려고하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="862d993f36bd27f44699b4c5102357c5ca816339" translate="yes" xml:space="preserve">
          <source>This last example shows the use of this construct to specify an ordinary bracketed character class without additional set operations. Note the white space within it; &lt;code&gt;/x&lt;/code&gt; is turned on even within bracketed character classes, except you can't have comments inside them. Hence,</source>
          <target state="translated">이 마지막 예는이 설정을 사용하여 추가 세트 조작없이 일반 대괄호 문자 클래스를 지정하는 방법을 보여줍니다. 그 안에 공백이 있습니다. &lt;code&gt;/x&lt;/code&gt; 는 대괄호로 묶은 문자 클래스 내에서도 켜져 있으며 주석을 포함 할 수 없습니다. 그 후,</target>
        </trans-unit>
        <trans-unit id="9220dfc1805deb030c183292c9d16a65be2d81b4" translate="yes" xml:space="preserve">
          <source>This last example splits &lt;code&gt;$foo&lt;/code&gt; into the first two words and the remainder of the line, and assigns those three fields to &lt;code&gt;$F1&lt;/code&gt; , &lt;code&gt;$F2&lt;/code&gt; , and &lt;code&gt;$Etc&lt;/code&gt; . The conditional is true if any variables were assigned; that is, if the pattern matched.</source>
          <target state="translated">이 마지막 예는 &lt;code&gt;$foo&lt;/code&gt; 를 처음 두 단어와 나머지 행으로 나누고이 세 필드를 &lt;code&gt;$F1&lt;/code&gt; , &lt;code&gt;$F2&lt;/code&gt; 및 &lt;code&gt;$Etc&lt;/code&gt; 할당합니다 . 변수가 할당 된 경우 조건부 참입니다. 즉, 패턴이 일치하는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="b0e7606501a4d8dcdc827582f8772dc7d2f7c727" translate="yes" xml:space="preserve">
          <source>This last one is present only in perl 5.22.0 and higher.</source>
          <target state="translated">이 마지막 것은 perl 5.22.0 이상에서만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="71d99570ae143a5a3edf0f9d507ad7328c03cf89" translate="yes" xml:space="preserve">
          <source>This latter is improper because when the &quot;=end outer&quot; command is seen, the currently open region has the formatname &quot;inner&quot;, not &quot;outer&quot;. (It just happens that &quot;outer&quot; is the format name of a higher-up region.) This is an error. Processors must by default report this as an error, and may halt processing the document containing that error. A corollary of this is that regions cannot &quot;overlap&quot;. That is, the latter block above does not represent a region called &quot;outer&quot; which contains X and Y, overlapping a region called &quot;inner&quot; which contains Y and Z. But because it is invalid (as all apparently overlapping regions would be), it doesn't represent that, or anything at all.</source>
          <target state="translated">&quot;= end outer&quot;명령이 표시 될 때 현재 열려있는 영역의 형식 이름은 &quot;outer&quot;가 아니라 &quot;inner&quot;이므로이 후자는 올바르지 않습니다. ( &quot;외부&quot;가 상위 영역의 형식 이름 인 경우에만 발생합니다.) 이것은 오류입니다. 프로세서는 기본적으로이 오류를 오류로보고해야하며 해당 오류가 포함 된 문서 처리를 중단 할 수 있습니다. 이것의 결과는 지역이 &quot;중복&quot;될 수 없다는 것입니다. 즉, 위의 후자의 블록은 X와 Y를 포함하는 &quot;외부&quot;라는 영역을 나타내지 않고 Y와 Z를 포함하는 &quot;내부&quot;라는 영역과 겹칩니다. 그러나 유효하지 않기 때문에 (모두 겹치는 영역처럼) 그것은 그 어떤 것도 나타내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a8db66183eb60025ea9a2964bbf14f04f11348c" translate="yes" xml:space="preserve">
          <source>This layer provides a PerlIO interface by wrapping system's ANSI C &quot;stdio&quot; library calls. The layer provides both buffering and IO. Note that the &lt;code&gt;:stdio&lt;/code&gt; layer does</source>
          <target state="translated">이 계층은 시스템의 ANSI C &quot;stdio&quot;라이브러리 호출을 래핑하여 PerlIO 인터페이스를 제공합니다. 이 계층은 버퍼링과 IO를 모두 제공합니다. 있습니다 &lt;code&gt;:stdio&lt;/code&gt; 층 않습니다</target>
        </trans-unit>
        <trans-unit id="b630c4528c6aff17852e4e3ca55c2d5a2c70831c" translate="yes" xml:space="preserve">
          <source>This leads to the other two differences. Since a single code point is returned, the function can't handle named character sequences, as these are composed of multiple characters (it returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for these. And, the code point can be that of any character, even ones that aren't legal under the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; pragma,</source>
          <target state="translated">이것은 다른 두 가지 차이점으로 이어집니다. 단일 코드 포인트가 반환되므로이 함수는 명명 된 문자 시퀀스를 처리 할 수 ​​없습니다. 명명 된 문자 시퀀스는 여러 문자로 구성되어 있기 때문에 (이에 대해 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환합니다 . 그리고 코드 포인트는 모든 문자의 코드 포인트가 될 수 있음) &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; pragma에 따라 합법적 이며,</target>
        </trans-unit>
        <trans-unit id="d60f65e26f1f4e74963a10d1932144990bf5f1a5" translate="yes" xml:space="preserve">
          <source>This lets you override an existing type with your own custom type, or register a completely new type, eg:</source>
          <target state="translated">이를 통해 기존 유형을 사용자 정의 유형으로 대체하거나 다음과 같이 완전히 새로운 유형을 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3afaf78f703df78ea1b2a3a94074c1f6af7d070b" translate="yes" xml:space="preserve">
          <source>This level of sophistication puts filtering out of the reach of many programmers.</source>
          <target state="translated">이러한 수준의 정교함은 많은 프로그래머의 손이 닿지 않는 범위에서 필터링을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="96b38d379d8ea7799ed19600bd96b2cf3c932e45" translate="yes" xml:space="preserve">
          <source>This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</source>
          <target state="translated">이 라이브러리는 유용 할 것이라는 희망으로 배포되었지만 어떠한 보증도하지 않습니다. 상품성 또는 특정 목적에의 적합성에 대한 묵시적 보증조차 포함하지 않습니다. 자세한 내용은 GNU General Public License를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5235941a62b852074a7c3e9fc51537a52e5be7a3" translate="yes" xml:space="preserve">
          <source>This library is free software. You can redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">이 라이브러리는 무료 소프트웨어입니다. Perl과 동일한 용어로 재배포 및 / 또는 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f877037944f8c1888cbf64249275515c89dec317" translate="yes" xml:space="preserve">
          <source>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself, either Perl version 5.8.7 or, at your option, any later version of Perl 5 you may have available.</source>
          <target state="translated">이 라이브러리는 무료 소프트웨어입니다. Perl 자체와 동일한 용어로 Perl 버전 5.8.7 또는 선택에 따라 사용 가능한 이후 버전의 Perl 5를 재배포 및 / 또는 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59869bc853c079c70b9f3b6879026f6cde3bb8df" translate="yes" xml:space="preserve">
          <source>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">이 라이브러리는 무료 소프트웨어입니다. Perl과 동일한 용어로 재배포 및 / 또는 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95bf2cec5fb49eb84ad57753eb4accbc37f2ba0f" translate="yes" xml:space="preserve">
          <source>This library is free software; you may redistribute and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">이 라이브러리는 무료 소프트웨어입니다. 귀하는 Perl 자체와 동일한 용어로 재배포 및 / 또는 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5912c0244d5e6338722acbdad50efbccb8883b11" translate="yes" xml:space="preserve">
          <source>This library is free software; you may redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">이 라이브러리는 무료 소프트웨어입니다. Perl 자체와 동일한 용어로 재배포 및 / 또는 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f410cd597bbeaeb5f199c6d8d09628b5554744f" translate="yes" xml:space="preserve">
          <source>This library is useful for the &lt;code&gt;find2perl&lt;/code&gt; tool, which when fed,</source>
          <target state="translated">이 라이브러리는 &lt;code&gt;find2perl&lt;/code&gt; 도구에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c0bf3b785ab345744e2dfb1b0071fc64c2b599fe" translate="yes" xml:space="preserve">
          <source>This library provides functions for common tasks involving language tags as they are needed in a variety of protocols and applications.</source>
          <target state="translated">이 라이브러리는 다양한 프로토콜 및 응용 프로그램에 필요한 언어 태그와 관련된 일반적인 작업을위한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0c8a7928010093d74c8591010b017561f0beda8e" translate="yes" xml:space="preserve">
          <source>This library provides support for big integer calculations. It is not intended to be used by other modules. Other modules which support the same API (see below) can also be used to support Math::BigInt, like Math::BigInt::GMP and Math::BigInt::Pari.</source>
          <target state="translated">이 라이브러리는 큰 정수 계산을 지원합니다. 다른 모듈에서는 사용하지 않습니다. 동일한 API를 지원하는 다른 모듈 (아래 참조)을 사용하여 Math :: BigInt :: GMP 및 Math :: BigInt :: Pari와 같은 Math :: BigInt를 지원할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3eb497d536b5c644bfd0b5d3e8c9055b4a9a57d" translate="yes" xml:space="preserve">
          <source>This limitation arises from fundamental technical difficulties in cloning and restarting the stacks used by the Perl parser in the middle of a parse.</source>
          <target state="translated">이 제한은 구문 분석 중에 Perl 구문 분석기가 사용하는 스택을 복제하고 다시 시작하는 데있어 근본적인 기술적 어려움으로 인해 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5fe79b21d14490122d11b41cbba492989dbd2358" translate="yes" xml:space="preserve">
          <source>This limitation might be removed in a future version of perl.</source>
          <target state="translated">이 제한 사항은 이후 버전의 perl에서 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68a6939633ab7f637a699e2abcb07f19152f1003" translate="yes" xml:space="preserve">
          <source>This line is taken from &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Soundex&quot;&gt;Text::Soundex&lt;/a&gt; 3.04, and marks it as deprecated beyond Perl 5.16. If you &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Text::Soundex&lt;/code&gt; in Perl 5.18, for example, and you have used &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;, then you'll get a warning message (the deprecate module looks to see whether the calling module was &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;'d from a core library directory, and if so, generates a warning), unless you've installed a more recent version of &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Soundex&quot;&gt;Text::Soundex&lt;/a&gt; from CPAN.</source>
          <target state="translated">이 줄은 &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Soundex&quot;&gt;Text :: Soundex&lt;/a&gt; 3.04 에서 가져 왔으며 Perl 5.16 이후에는 더 이상 사용되지 않는 것으로 표시됩니다. 당신이 경우에 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Text::Soundex&lt;/code&gt; 펄 5.18, 예를 들어에, 당신은 사용이 &lt;a href=&quot;warnings&quot;&gt;경고를&lt;/a&gt; , 당신은 호출 모듈이 있었다 여부를 확인하기 위해 경고 메시지합니다 (지원 중단 모듈 외모를 얻을 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 핵심 라이브러리 디렉토리에서 'D 및 CPAN에서 최신 버전의 &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Soundex&quot;&gt;Text :: Soundex&lt;/a&gt; 를 설치하지 않은 경우 경고가 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="9d4d9656ee66f6221eea8c2856144cdf8d5022fd" translate="yes" xml:space="preserve">
          <source>This list includes architecture-dependent directories back to version $api_versionstring (e.g. 5.5.640) and architecture-independent directories all the way back to 5.005.</source>
          <target state="translated">이 목록에는 $ api_versionstring 버전으로 돌아가는 아키텍처 종속 디렉토리 (예 : 5.5.640)와 5.005로 돌아가는 아키텍처 독립적 디렉토리가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2a2fc6936d401079e1014279fe24282359b2ced4" translate="yes" xml:space="preserve">
          <source>This list is in alphabetical order by English name of the language.</source>
          <target state="translated">이 목록은 영어 이름의 알파벳순으로되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbc78c3347e34ef8b4193dfb718a45521c4ab8d4" translate="yes" xml:space="preserve">
          <source>This list of categories is used to produce the same order as the &lt;a href=&quot;../perlfunc#Perl-Functions-by-Category&quot;&gt;Perl Functions by Category in perlfunc&lt;/a&gt; section.</source>
          <target state="translated">이 카테고리 목록은 &lt;a href=&quot;../perlfunc#Perl-Functions-by-Category&quot;&gt;perlfunc&lt;/a&gt; 섹션의 카테고리 별 Perl 함수 와 동일한 순서를 생성하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="b0d8392d22aa3f9f1cc5418d2f71d3d9b55240c2" translate="yes" xml:space="preserve">
          <source>This list used to contain :base_io prior to Opcode 1.07.</source>
          <target state="translated">이 목록에는 Opcode 1.07 이전에 : base_io가 포함되어있었습니다.</target>
        </trans-unit>
        <trans-unit id="f6d74c66919ae745b2d3650dc11a98193dcd5f79" translate="yes" xml:space="preserve">
          <source>This load time hit can be a problem when startup speed is important, such as with a command-line script or a &quot;plain vanilla&quot; CGI script that must be loaded each time it is executed.</source>
          <target state="translated">이로드 시간 적중은 명령 행 스크립트 또는 실행될 때마다로드되어야하는 &quot;일반 바닐라&quot;CGI 스크립트와 같이 시작 속도가 중요한 경우 문제가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f016e1379d18764668778064a6a84ece9741d1da" translate="yes" xml:space="preserve">
          <source>This logical name must be defined before Perl is started.</source>
          <target state="translated">Perl을 시작하기 전에이 논리 이름을 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="2da9ead2fb770925df3e972a0efa2a82cbbd6ec6" translate="yes" xml:space="preserve">
          <source>This looks in the %Lexicon of the language handle $lh and all its superclasses, looking for an entry whose key is the string</source>
          <target state="translated">이것은 언어 핸들 % lh와 모든 수퍼 클래스의 % Lexicon에서 키가 문자열 인 항목을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="6b4001bd2a1ae040dc8e95119817ede264954c05" translate="yes" xml:space="preserve">
          <source>This loses precision, to avoid this use &lt;a href=&quot;#as_int()%2fas_number()&quot;&gt;as_int()&lt;/a&gt; instead.</source>
          <target state="translated">대신 &lt;a href=&quot;#as_int()%2fas_number()&quot;&gt;as_int ()&lt;/a&gt; 사용을 피하기 위해 정밀도가 떨어 집니다.</target>
        </trans-unit>
        <trans-unit id="2cb2a7c80cbcd1bcc850e8fe88a609a4116cf1c4" translate="yes" xml:space="preserve">
          <source>This machine-native collation (which is what you get unless &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
locale&lt;/code&gt; has appeared earlier in the same block) must be used for sorting raw binary data, whereas the locale-dependent collation of the first example is useful for natural text.</source>
          <target state="translated">원시 이진 데이터를 정렬 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 기본 데이터 정렬 ( 로케일 사용 이 동일한 블록에서 이전에 표시 되지 않은 경우 )을 사용해야합니다. 첫 번째 예제의 로케일 종속 데이터 정렬은 자연 텍스트에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="fe9b1418e4cf2456d34c78acbb912d03460323b0" translate="yes" xml:space="preserve">
          <source>This macro automatically adjusts the stack for you, if needed. Thus, you do not need to call &lt;code&gt;EXTEND&lt;/code&gt; to extend the stack.</source>
          <target state="translated">이 매크로는 필요한 경우 자동으로 스택을 조정합니다. 따라서 스택을 확장하기 위해 &lt;code&gt;EXTEND&lt;/code&gt; 를 호출 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="28984ae179e05c5bf9916303fc08d37c02058ac5" translate="yes" xml:space="preserve">
          <source>This macro is only used by sv_true() or its macro equivalent, and only if the latter's argument is neither SvPOK, SvIOK nor SvNOK. It calls sv_2bool_flags with the SV_GMAGIC flag.</source>
          <target state="translated">이 매크로는 sv_true () 또는 그와 동등한 매크로에서만 사용되며 후자의 인수가 SvPOK, SvIOK 또는 SvNOK가 아닌 경우에만 사용됩니다. SV_GMAGIC 플래그와 함께 sv_2bool_flags를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="e10545c4894740426ee72f48ac1e29d7b762c0e6" translate="yes" xml:space="preserve">
          <source>This macro is the start of wrapping the C or XS code; the wrap ending is done by calling the &lt;a href=&quot;#RESTORE_LC_NUMERIC&quot;&gt;RESTORE_LC_NUMERIC&lt;/a&gt; macro after the operation. Otherwise the state can be changed that will adversely affect other XS code.</source>
          <target state="translated">이 매크로는 C 또는 XS 코드를 래핑하기 시작합니다. 랩 종료는 조작 후 &lt;a href=&quot;#RESTORE_LC_NUMERIC&quot;&gt;RESTORE_LC_NUMERIC&lt;/a&gt; 매크로 를 호출하여 수행됩니다 . 그렇지 않으면 다른 XS 코드에 부정적인 영향을주는 상태를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="108576184697c52b594b5fe191807eddc07365bd" translate="yes" xml:space="preserve">
          <source>This macro is used to define a unique key to refer to the static data for an XS module. The suggested naming scheme, as used by h2xs, is to use a string that consists of the module name, the string &quot;::_guts&quot; and the module version number.</source>
          <target state="translated">이 매크로는 XS 모듈의 정적 데이터를 나타내는 고유 키를 정의하는 데 사용됩니다. h2xs에서 사용되는 제안 된 이름 지정 체계는 모듈 이름, 문자열 &quot;:: _ guts&quot;및 모듈 버전 번호로 구성된 문자열을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c6d4c1493bd7a58de9fad441658972687cd16b89" translate="yes" xml:space="preserve">
          <source>This macro makes sure the current &lt;code&gt;LC_NUMERIC&lt;/code&gt; state is set properly, to be aware of locale if the call to the XS or C code from the Perl program is from within the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; ; or to ignore locale if the call is instead from outside such scope.</source>
          <target state="translated">이 매크로는 Perl 프로그램에서 XS 또는 C 코드로의 호출이 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 로케일 범위 내에있는 경우 로케일을 인식하기 위해 현재 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 상태가 올바르게 설정되었는지 확인합니다 . 호출이 해당 범위를 벗어난 경우 로케일을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="a92648c32efc9502af17e5ceb0078f95c4ee774c" translate="yes" xml:space="preserve">
          <source>This macro should be used as a statement. It declares a private variable (whose name begins with an underscore) that is needed by the other macros in this section. Failing to include this correctly should lead to a syntax error. For compatibility with C89 C compilers it should be placed in a block before any executable statements.</source>
          <target state="translated">이 매크로는 명령문으로 사용해야합니다. 이 섹션의 다른 매크로에 필요한 개인 변수 (이름은 밑줄로 시작)를 선언합니다. 이것을 올바르게 포함하지 않으면 구문 오류가 발생합니다. C89 C 컴파일러와의 호환성을 위해 실행 문 앞에 블록에 배치해야합니다.</target>
        </trans-unit>
        <trans-unit id="b90726f024761758381d53bc05e127149501c3cd" translate="yes" xml:space="preserve">
          <source>This makes &lt;code&gt;$?&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; return the native VMS exit status instead of emulating the POSIX exit status.</source>
          <target state="translated">이것은 &lt;code&gt;$?&lt;/code&gt; 만든다 ? 및 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; POSIX의 종료 상태를 모방 대신 기본 VMS의 종료 상태를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8a2c6d4ff2fd838d04decac262a17dd105743f47" translate="yes" xml:space="preserve">
          <source>This makes &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt; 1&lt;/code&gt; produce a successful exit (with status SS$_NORMAL), instead of emulating UNIX exit(), which considers &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt; 1&lt;/code&gt; to indicate an error. As with the CRTL's exit() function, &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt; 0&lt;/code&gt; is also mapped to an exit status of SS$_NORMAL, and any other argument to exit() is used directly as Perl's exit status.</source>
          <target state="translated">이는하게 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt; 1&lt;/code&gt; 대신 고려 UNIX 출구 (), 모방, 생산 (상태 SS $ _NORMAL에) 성공적으로 종료 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt; 1&lt;/code&gt; 오류를 표시 할 수 있습니다. CRTL의 exit () 함수와 마찬가지로 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt; 0&lt;/code&gt; 도 SS $ _NORMAL의 종료 상태에 맵핑되며 exit ()에 대한 다른 인수는 Perl의 종료 상태로 직접 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7bf5212d7d68fd2597a5ccb3dac44a0ec0acbc33" translate="yes" xml:space="preserve">
          <source>This makes all times relative to the local time zone, instead of the default of Universal Time (a.k.a Greenwich Mean Time, or GMT).</source>
          <target state="translated">이렇게하면 기본 시간 인 그리니치 표준시 (GMT) 대신 현지 시간대를 기준으로 모든 시간이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="9babc5bd4d4d8fad4e1a1114788e7c9d9589298f" translate="yes" xml:space="preserve">
          <source>This makes it easy for people to use your module with Perl. Note that this licensing example is neither an endorsement or a requirement, you are of course free to choose any licensing.</source>
          <target state="translated">따라서 사람들이 Perl과 함께 모듈을 쉽게 사용할 수 있습니다. 이 라이센스 예제는 보증 또는 요구 사항이 아니며 라이센스를 자유롭게 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6b677bb7d54149dada8aa52108296cc95f7e885" translate="yes" xml:space="preserve">
          <source>This makes it easy to turn memoizing on and off.</source>
          <target state="translated">이를 통해 메모를 쉽게 켜고 끌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84c2faa4aab99c70a3db865e9bc75342b3b56a52" translate="yes" xml:space="preserve">
          <source>This makes it easy to write loops that terminate when a null list is returned:</source>
          <target state="translated">따라서 null 목록이 반환 될 때 종료되는 루프를 쉽게 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef9cd0d8fba7947707aa196a6028ecbb8adf2cd7" translate="yes" xml:space="preserve">
          <source>This makes it possible for you to have a single point of configuring what subclasses should be used, which means that in many cases you'll find you only need to sub-class one of the parser's components.</source>
          <target state="translated">이를 통해 어떤 서브 클래스를 구성해야하는지 단일 지점을 가질 수 있습니다. 이는 대부분의 경우 파서 구성 요소 중 하나만 서브 클래스해야한다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="80334a3bb6611cb20a20615249beb172fdbc5b91" translate="yes" xml:space="preserve">
          <source>This makes it possible to mix arguments of different classes (as in 2.5 + 2) as well es preserve accuracy (as in sqrt(3)).</source>
          <target state="translated">이것은 다른 클래스 (2.5 + 2에서와 같이)의 인수를 혼합 할 수있을뿐만 아니라 (sqrt (3)에서와 같이) 정확성을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="304f656ae607b7cf896345e4cfc56ab064cd5820" translate="yes" xml:space="preserve">
          <source>This makes it possible to write a constructor like this:</source>
          <target state="translated">이를 통해 다음과 같은 생성자를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08c53718a75ad3b112dec7a9bbaa9b39968746d5" translate="yes" xml:space="preserve">
          <source>This makes sure that &lt;code&gt;foo bar&lt;/code&gt; is treated as a string, rather than two separate arguments to the &lt;code&gt;echo&lt;/code&gt; function.</source>
          <target state="translated">이렇게하면 &lt;code&gt;foo bar&lt;/code&gt; 가 &lt;code&gt;echo&lt;/code&gt; 함수 에 대한 두 개의 개별 인수가 아닌 문자열로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="d11f54f9813ffdcb8a603cf0a760fa85bee8c0f3" translate="yes" xml:space="preserve">
          <source>This makes the four standard bitwise operators (&lt;code&gt;&amp;amp; | ^ ~&lt;/code&gt; ) treat their operands consistently as numbers, and introduces four new dotted operators (&lt;code&gt;&amp;amp;. |. ^. ~.&lt;/code&gt; ) that treat their operands consistently as strings. The same applies to the assignment variants (&lt;code&gt;&amp;amp;= |= ^= &amp;amp;.= |.= ^.=&lt;/code&gt; ).</source>
          <target state="translated">이렇게하면 4 개의 표준 비트 연산자 ( &lt;code&gt;&amp;amp; | ^ ~&lt;/code&gt; )가 피연산자를 숫자로 일관되게 처리하고 피연산자를 문자열로 일관되게 처리하는 4 개의 새로운 점 연산자 ( &lt;code&gt;&amp;amp;. |. ^. ~.&lt;/code&gt; )를 도입합니다. 할당 변형 ( &lt;code&gt;&amp;amp;= |= ^= &amp;amp;.= |.= ^.=&lt;/code&gt; ) 에도 동일하게 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="168408e4eda2afd55c396c633b53aaec0eb729d4" translate="yes" xml:space="preserve">
          <source>This makes this XSUB look similar to an ANSI C declaration. An optional semicolon is allowed after the argument list, as in</source>
          <target state="translated">이것은이 XSUB를 ANSI C 선언과 유사하게 만듭니다. 선택적 세미콜론은 다음과 같이 인수 목록 뒤에 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="2eced7035bcf730659e224115fc20b5232c60142" translate="yes" xml:space="preserve">
          <source>This man page is for the version for modern perls and so that's probably what you've got.</source>
          <target state="translated">이 매뉴얼 페이지는 현대적인 perls 용 버전이므로 아마도 당신이 가진 것입니다.</target>
        </trans-unit>
        <trans-unit id="b1f55a347ef2e9626ef51c086b431d8a172c3d1b" translate="yes" xml:space="preserve">
          <source>This manpage contains short recipes demonstrating how to handle common Unicode operations in Perl, plus one complete program at the end. Any undeclared variables in individual recipes are assumed to have a previous appropriate value in them.</source>
          <target state="translated">이 맨 페이지에는 Perl에서 일반적인 유니 코드 작업을 처리하는 방법을 보여주는 간단한 레시피와 마지막에 하나의 완전한 프로그램이 포함되어 있습니다. 개별 레시피에서 선언되지 않은 변수는 이전에 적절한 값을 가지고 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="aa682f1e123b444504fdfffff8f8767942781c1e" translate="yes" xml:space="preserve">
          <source>This manual page discusses the syntax and use of character classes in Perl regular expressions.</source>
          <target state="translated">이 매뉴얼 페이지에서는 Perl 정규식에서 문자 클래스의 구문과 사용법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="3369a77e4e9693acaaa9351801ed7f0c5ee8faea" translate="yes" xml:space="preserve">
          <source>This maps from US-ASCII codes (like 32) to the corresponding character (like space, for 32). Only characters 32 to 126 are defined. This is meant for use by &lt;code&gt;e2char($x)&lt;/code&gt; when it senses that it's running on a non-ASCII platform (where chr(32) doesn't get you a space -- but $Code2USASCII{32} will). It's documented here just in case you might find it useful.</source>
          <target state="translated">이것은 US-ASCII 코드 (32와 같은)에서 해당 문자 (32와 같은 공백)에 매핑됩니다. 32 ~ 126 문자 만 정의됩니다. 이것은 비 ASCII 플랫폼에서 실행되고 있음을 감지 할 때 &lt;code&gt;e2char($x)&lt;/code&gt; 에서 사용하기위한 것 입니다 (chr (32)는 공간을 확보하지 못하지만 $ Code2USASCII {32}는 사용합니다). 유용하다고 생각되는 경우를 대비하여 여기에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb4d3919cb732684c195097b0bb170a903bf1284" translate="yes" xml:space="preserve">
          <source>This marks the end of the region opened by the matching &quot;=begin formatname&quot; region. If &quot;formatname&quot; is not the formatname of the most recent open &quot;=begin formatname&quot; region, then this is an error, and must generate an error message. This is discussed in detail in the section &lt;a href=&quot;#About-Data-Paragraphs-and-%22%3dbegin%2f%3dend%22-Regions&quot;&gt;About Data Paragraphs and =begin/=end Regions&lt;/a&gt;.</source>
          <target state="translated">일치하는 &quot;= begin formatname&quot;영역으로 열린 영역의 끝을 표시합니다. &quot;formatname&quot;이 가장 최근에 열린 &quot;= begin formatname&quot;영역의 formatname이 아닌 경우 이는 오류이며 오류 메시지를 생성해야합니다. 이에 대해서는 &lt;a href=&quot;#About-Data-Paragraphs-and-%22%3dbegin%2f%3dend%22-Regions&quot;&gt;데이터 단락 및 = begin / = 종료 정보&lt;/a&gt; 섹션에서 자세히 설명 합니다 .</target>
        </trans-unit>
        <trans-unit id="5f3eb630ccbc8c1b4b4ea62b60c2f17bbd2e13b1" translate="yes" xml:space="preserve">
          <source>This marks the following paragraphs (until the matching &quot;=end formatname&quot;) as being for some special kind of processing. Unless &quot;formatname&quot; begins with a colon, the contained non-command paragraphs are data paragraphs. But if &quot;formatname&quot;</source>
          <target state="translated">이것은 다음의 단락들 (일치하는 &quot;= end formatname&quot;까지)을 특별한 종류의 처리를위한 것으로 표시합니다. &quot;formatname&quot;이 콜론으로 시작하지 않는 한 포함 된 비 명령문은 데이터 단락입니다. 그러나 &quot;formatname&quot;</target>
        </trans-unit>
        <trans-unit id="199ca4d2282805128a713cd4c31b353ecaf62285" translate="yes" xml:space="preserve">
          <source>This matches a Unicode</source>
          <target state="translated">이것은 유니 코드와 일치합니다</target>
        </trans-unit>
        <trans-unit id="7a2285705bf65a5f3a4137269fb669e26419a225" translate="yes" xml:space="preserve">
          <source>This matches a Unicode &quot;Grapheme Cluster Boundary&quot;. (Actually Perl always uses the improved &quot;extended&quot; grapheme cluster&quot;). These are explained below under &lt;a href=&quot;#%5cX&quot;&gt;\X&lt;/a&gt;. In fact, &lt;code&gt;\X&lt;/code&gt; is another way to get the same functionality. It is equivalent to &lt;code&gt;/.+?\b{gcb}/&lt;/code&gt; . Use whichever is most convenient for your situation.</source>
          <target state="translated">이것은 유니 코드 &quot;Grapheme Cluster Boundary&quot;와 일치합니다. (실제로 Perl은 항상 개선 된 &quot;확장 된&quot;grapheme 클러스터 &quot;를 사용합니다.) 이것들은 아래 &lt;a href=&quot;#%5cX&quot;&gt;\ X에&lt;/a&gt; 설명되어 있습니다. 실제로 &lt;code&gt;\X&lt;/code&gt; 는 동일한 기능을 얻는 또 다른 방법입니다. &lt;code&gt;/.+?\b{gcb}/&lt;/code&gt; 와 같습니다. / . 상황에 가장 편리한 것을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="43a174e3acf9fe3da094fe1e29ca009a0ac07471" translate="yes" xml:space="preserve">
          <source>This matches a Unicode &quot;Sentence Boundary&quot;. This is an aid to parsing natural language sentences. It gives good, but imperfect results. For example, it thinks that &quot;Mr. Smith&quot; is two sentences. More details are at &lt;a href=&quot;http://www.unicode.org/reports/tr29/&quot;&gt;http://www.unicode.org/reports/tr29/&lt;/a&gt;. Note also that it thinks that anything matching &lt;a href=&quot;#%5cR&quot;&gt;\R&lt;/a&gt; (except form feed and vertical tab) is a sentence boundary. &lt;code&gt;\b{sb}&lt;/code&gt; works with text designed for word-processors which wrap lines automatically for display, but hard-coded line boundaries are considered to be essentially the ends of text blocks (paragraphs really), and hence the ends of sententces. &lt;code&gt;\b{sb}&lt;/code&gt; doesn't do well with text containing embedded newlines, like the source text of the document you are reading. Such text needs to be preprocessed to get rid of the line separators before looking for sentence boundaries. Some people view this as a bug in the Unicode standard, and this behavior is quite subject to change in future Perl versions.</source>
          <target state="translated">이것은 유니 코드 &quot;문장 경계&quot;와 일치합니다. 자연어 문장을 파싱하는 데 도움이됩니다. 훌륭하지만 불완전한 결과를 제공합니다. 예를 들어 &quot;미스터 스미스&quot;는 두 문장이라고 생각합니다. 자세한 내용은 &lt;a href=&quot;http://www.unicode.org/reports/tr29/&quot;&gt;http://www.unicode.org/reports/tr29/에&lt;/a&gt; 있습니다. 또한 &lt;a href=&quot;#%5cR&quot;&gt;\ R&lt;/a&gt; (양식 공급 및 세로 탭 제외)과 일치하는 것은 문장 경계 라고 생각합니다 . &lt;code&gt;\b{sb}&lt;/code&gt; 는 자동으로 줄을 표시하여 표시하기 위해 워드 프로세서 용으로 설계된 텍스트와 함께 작동하지만 하드 코드 된 선 경계는 본질적으로 텍스트 블록의 끝 (실제 단락)으로 간주되므로 문장의 끝으로 간주됩니다. &lt;code&gt;\b{sb}&lt;/code&gt; 읽고있는 문서의 소스 텍스트와 같이 개행 문자가 포함 된 텍스트에는 적합하지 않습니다. 문장 경계를 찾기 전에 줄 구분 기호를 제거하려면 이러한 텍스트를 사전 처리해야합니다. 일부 사람들은 이것을 유니 코드 표준의 버그로보고 있으며,이 동작은 향후 Perl 버전에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="862d390cde50da1c3067a4f5bf13a23004164fc2" translate="yes" xml:space="preserve">
          <source>This matches a Unicode &quot;Word Boundary&quot;. This gives better (though not perfect) results for natural language processing than plain &lt;code&gt;\b&lt;/code&gt; (without braces) does. For example, it understands that apostrophes can be in the middle of words and that parentheses aren't (see the examples below). More details are at &lt;a href=&quot;http://www.unicode.org/reports/tr29/&quot;&gt;http://www.unicode.org/reports/tr29/&lt;/a&gt;.</source>
          <target state="translated">이것은 유니 코드 &quot;워드 경계&quot;와 일치합니다. 이것은 평범한 &lt;code&gt;\b&lt;/code&gt; (중괄호가없는) 보다 자연 언어 처리에 대한 더 나은 (완벽하지는 않지만) 결과를 제공합니다 . 예를 들어, 아포스트로피는 단어 중간에있을 수 있으며 괄호는 그렇지 않다는 것을 이해합니다 (아래 예 참조). 자세한 내용은 &lt;a href=&quot;http://www.unicode.org/reports/tr29/&quot;&gt;http://www.unicode.org/reports/tr29/에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="46f9c4b6a0133a2ba4a4536268bb4388e6462d37" translate="yes" xml:space="preserve">
          <source>This matches any &lt;code&gt;\p{Alphabetic}&lt;/code&gt; or &lt;code&gt;\p{Decimal_Number}&lt;/code&gt; character.</source>
          <target state="translated">이것은 &lt;code&gt;\p{Alphabetic}&lt;/code&gt; 또는 &lt;code&gt;\p{Decimal_Number}&lt;/code&gt; 문자 와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="1368a197a87ba6ed14500f8908565c9ada6f62ff" translate="yes" xml:space="preserve">
          <source>This matches any assigned code point; that is, any code point whose &lt;a href=&quot;#General_Category&quot;&gt;general category&lt;/a&gt; is not &lt;code&gt;Unassigned&lt;/code&gt; (or equivalently, not &lt;code&gt;Cn&lt;/code&gt; ).</source>
          <target state="translated">할당 된 코드 포인트와 일치합니다. 즉, &lt;a href=&quot;#General_Category&quot;&gt;일반 범주&lt;/a&gt; 가 &lt;code&gt;Unassigned&lt;/code&gt; 되지 않은 (또는 &lt;code&gt;Cn&lt;/code&gt; 이 아닌) 코드 포인트입니다 .</target>
        </trans-unit>
        <trans-unit id="a2970fcf592bf526b7624da46ffe2c2926bcdb66" translate="yes" xml:space="preserve">
          <source>This matches any character that is graphical or blank, except controls.</source>
          <target state="translated">컨트롤을 제외하고 그래픽이거나 공백 인 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="9dcbf046b8bea0226e813051a826c67a230a6bfb" translate="yes" xml:space="preserve">
          <source>This matches any of the 128 characters in the US-ASCII character set, which is a subset of Unicode.</source>
          <target state="translated">이는 US-ASCII 문자 세트의 128 자 (유니 코드의 서브 세트)와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="6f971eb914dae58555e5f55db125c34d663d6429" translate="yes" xml:space="preserve">
          <source>This matches any of the 1_114_112 Unicode code points. &lt;code&gt;\p{Any}&lt;/code&gt; .</source>
          <target state="translated">이것은 1_114_112 유니 코드 코드 포인트와 일치합니다. &lt;code&gt;\p{Any}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50e5a95f3a6d3f1afad03782326f2e0e7b9c9ed7" translate="yes" xml:space="preserve">
          <source>This matches any of the 1_114_112 Unicode code points. It is a synonym for &lt;code&gt;\p{Unicode}&lt;/code&gt; .</source>
          <target state="translated">이것은 1_114_112 유니 코드 코드 포인트와 일치합니다. &lt;code&gt;\p{Unicode}&lt;/code&gt; 와 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="1ddbc160eb4c94b6ef293222be013d55a26c3ebd" translate="yes" xml:space="preserve">
          <source>This matches digits that are in either the Thai or Laotian scripts.</source>
          <target state="translated">이것은 태국어 또는 라오스 어 스크립트에있는 숫자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="bed0a3d92b78eec58ff8b7c04af52fb9a269486e" translate="yes" xml:space="preserve">
          <source>This matches every possible code point. It is equivalent to &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/./s&lt;/a&gt;&lt;/code&gt;. Unlike all the other non-user-defined &lt;code&gt;\p{}&lt;/code&gt; property matches, no warning is ever generated if this is property is matched against a non-Unicode code point (see &lt;a href=&quot;#Beyond-Unicode-code-points&quot;&gt;Beyond Unicode code points&lt;/a&gt; below).</source>
          <target state="translated">가능한 모든 코드 포인트와 일치합니다. &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/./s&lt;/a&gt;&lt;/code&gt; 와 같습니다 . 사용자 정의되지 않은 다른 모든 &lt;code&gt;\p{}&lt;/code&gt; 속성 일치 와 달리이 속성이 유니 코드가 아닌 코드 포인트와 일치하는 경우 경고가 생성되지 않습니다 ( 아래의 &lt;a href=&quot;#Beyond-Unicode-code-points&quot;&gt;유니 코드 코드 포인트를 넘어서&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="e5af876b8e44759fbc1c5f4ebb39fe615bb29e7e" translate="yes" xml:space="preserve">
          <source>This matches the English vowels plus the SPACE character. All the other escapes accepted by normal bracketed character classes are accepted here as well; but unrecognized escapes that generate warnings in normal classes are fatal errors here.</source>
          <target state="translated">영어 모음과 SPACE 문자가 일치합니다. 일반적인 대괄호로 사용되는 다른 모든 이스케이프도 여기에서 허용됩니다. 그러나 정상적인 클래스에서 경고를 생성하는 인식 할 수없는 탈출은 치명적인 오류입니다.</target>
        </trans-unit>
        <trans-unit id="6fe0bd3d52f9526a3bdbdf0fb7b2272dd4226b2a" translate="yes" xml:space="preserve">
          <source>This may a variant of just &lt;a href=&quot;#I-cannot-run-external-programs&quot;&gt;I cannot run external programs&lt;/a&gt;, or a deeper problem. Basically: you</source>
          <target state="translated">이것은 &lt;a href=&quot;#I-cannot-run-external-programs&quot;&gt;외부 프로그램을 실행할 수 없거나&lt;/a&gt; 더 깊은 문제 의 변형 일 수 있습니다 . 기본적으로 : 당신</target>
        </trans-unit>
        <trans-unit id="3c2e6cadd45bf9050033dd0f02dee64c1cb36e02" translate="yes" xml:space="preserve">
          <source>This may also be a good time to ensure that your /etc/protocol file and either your /etc/resolv.conf or /etc/hosts files are in place. The IBM document that described such USS system setup issues was SC28-1890-07 &quot;OS/390 UNIX System Services Planning&quot;, in particular Chapter 6 on customizing the OE shell.</source>
          <target state="translated">또한 / etc / protocol 파일과 /etc/resolv.conf 또는 / etc / hosts 파일이 있는지 확인하는 것이 좋습니다. 이러한 USS 시스템 설정 문제를 설명하는 IBM 문서는 SC28-1890-07 &quot;OS / 390 UNIX 시스템 서비스 계획&quot;, 특히 6 장 OE 쉘 사용자 정의에 관한 것입니다.</target>
        </trans-unit>
        <trans-unit id="1206b674e03199df25ca78fd2210a65fd2a21ff2" translate="yes" xml:space="preserve">
          <source>This may also be set to the special value &lt;code&gt;none&lt;/code&gt; , in which case no quote marks are added around C&amp;lt;&amp;gt; text (but the font is still changed for troff output).</source>
          <target state="translated">이것은 또한 특수 값 &lt;code&gt;none&lt;/code&gt; 으로 설정 될 수 있으며 ,이 경우 C &amp;lt;&amp;gt; 텍스트 주위에 따옴표가 추가되지 않습니다 (그러나 글꼴은 여전히 ​​troff 출력으로 변경됩니다).</target>
        </trans-unit>
        <trans-unit id="345f8ac7fec5019dbde30571fee3e63e792fb3cf" translate="yes" xml:space="preserve">
          <source>This may also be set to the special value &lt;code&gt;none&lt;/code&gt; , in which case no quote marks are added around C&amp;lt;&amp;gt; text.</source>
          <target state="translated">이것은 또한 특수 값 &lt;code&gt;none&lt;/code&gt; 으로 설정 될 수 있으며 ,이 경우 C &amp;lt;&amp;gt; 텍스트 주위에 따옴표가 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a4b045aef9d01569a459e4507e2bf0dbcc4d078d" translate="yes" xml:space="preserve">
          <source>This may be less obvious in other situations, such as &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt;, for instance when grepping through a list of weakened references to objects that may have been destroyed already:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt; 과 같은 다른 상황에서는 이미 소멸되었을 수있는 객체에 대한 약한 참조 목록을 grepping 할 때이 점이 명확하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9b6b611a35aea5e6cbfaa34dfad89779e54d15a6" translate="yes" xml:space="preserve">
          <source>This may be useful if other modules expect this module to be</source>
          <target state="translated">다른 모듈이이 모듈을 기대할 경우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb1bd20d64f2ccdce3f2cc8fcef954e7c80b5a33" translate="yes" xml:space="preserve">
          <source>This may be useful since, say, types which are &lt;code&gt;typedef&lt;/code&gt; -equivalent to integers may represent OS-related handles, and one may want to work with these handles in OO-way, as in &lt;code&gt;$handle-&amp;gt;do_something()&lt;/code&gt; . Use &lt;code&gt;-o .&lt;/code&gt; if you want to handle all the &lt;code&gt;typedef&lt;/code&gt; ed types as opaque types.</source>
          <target state="translated">예 를 들어 정수와 &lt;code&gt;typedef&lt;/code&gt; 와 같은 유형 은 OS 관련 핸들을 나타낼 수 있고 &lt;code&gt;$handle-&amp;gt;do_something()&lt;/code&gt; 에서와 같이 OO-way에서 이러한 핸들로 작업하기를 원할 수 있기 때문에 유용 할 수 있습니다 . &lt;code&gt;-o .&lt;/code&gt; 사용하십시오 . 모든 &lt;code&gt;typedef&lt;/code&gt; ed 유형을 불투명 유형 으로 처리하려는 경우 .</target>
        </trans-unit>
        <trans-unit id="219180c7e012f10d4f7a83d42d7e8f2690484f40" translate="yes" xml:space="preserve">
          <source>This may break in two ways:</source>
          <target state="translated">두 가지 방법으로 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c894611388eb78ec067fed71d079c9e5816ca7b5" translate="yes" xml:space="preserve">
          <source>This may cause problems:</source>
          <target state="translated">이로 인해 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b07568535355dc79492449b01ec4948cfdc2343" translate="yes" xml:space="preserve">
          <source>This may expect the C</source>
          <target state="translated">이것은 C를 기대할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="03f2543e21cbd92a7ee1ca79827f8f9611eefa56" translate="yes" xml:space="preserve">
          <source>This may later be extended to include other information, so be careful with pattern-matching on the results.</source>
          <target state="translated">나중에 다른 정보를 포함하도록 확장 될 수 있으므로 결과에서 패턴 일치에주의하십시오.</target>
        </trans-unit>
        <trans-unit id="e21dadcda575196402392ef6ce13a8923c3356bf" translate="yes" xml:space="preserve">
          <source>This may lead to problems later in case the socket is accessed via the &quot;usual&quot; file-system calls using the &quot;initial&quot; name.</source>
          <target state="translated">&quot;초기&quot;이름을 사용하여 &quot;일반&quot;파일 시스템 호출을 통해 소켓에 액세스하는 경우 나중에 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6110636ef5b993e8ba32881ebb3b6bb734669e0b" translate="yes" xml:space="preserve">
          <source>This may take a couple of hours on 1GHz processor (when run the first time). And this should not be necessarily a smooth procedure. Some modules may not specify required dependencies, so one may need to repeat this procedure several times until the results stabilize.</source>
          <target state="translated">1GHz 프로세서에서 처음 실행하는 데 몇 시간이 걸릴 수 있습니다. 그리고 이것은 반드시 매끄러운 절차는 아닙니다. 일부 모듈은 필요한 종속성을 지정하지 않을 수 있으므로 결과가 안정화 될 때까지이 절차를 여러 번 반복해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="21e8b83f4a4668675b959f09a3dddc3f913b92a2" translate="yes" xml:space="preserve">
          <source>This means integer values like 1.01E2 or even 1000E-2 are also accepted. Non-integer values result in NaN.</source>
          <target state="translated">이는 1.01E2 또는 1000E-2와 같은 정수 값도 허용됨을 의미합니다. 정수가 아닌 값은 NaN이됩니다.</target>
        </trans-unit>
        <trans-unit id="0df399dd4c0ebd437b2b092068503ec57072d7a4" translate="yes" xml:space="preserve">
          <source>This means somewhere a routine got a BigFloat/Lite but expected a BigInt (or vice versa) and the upgrade/downgrad path was missing. This is a bug, please report it so that we can fix it.</source>
          <target state="translated">이것은 루틴이 BigFloat / Lite를 얻었지만 BigInt (또는 그 반대)를 예상하고 업그레이드 / 다운 그레이드 경로가 누락 된 곳을 의미합니다. 이것은 버그입니다. 문제를 해결하기 위해보고하십시오.</target>
        </trans-unit>
        <trans-unit id="14a58ee32b8ae7bdc388a529d03ef7e5871a7f4e" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;catdir()&lt;/code&gt; is called only when there are two or more arguments, as one might expect.</source>
          <target state="translated">이는 &lt;code&gt;catdir()&lt;/code&gt; 이 예상 한대로 둘 이상의 인수가있는 경우에만 호출 됨을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="578c842326a0346c93813339f663f40295cced47" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;prop_invmap&lt;/code&gt; returns a 4 element list. For example,</source>
          <target state="translated">이는 &lt;code&gt;prop_invmap&lt;/code&gt; 이 4 개의 요소 목록을 반환 함을 의미 합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="38b6532eaf6e68ec76d8a337e1c024ccfeab03a8" translate="yes" xml:space="preserve">
          <source>This means that arithmetic involving only string values or string literals will be performed using Perl's built-in operators.</source>
          <target state="translated">이는 문자열 값 또는 문자열 리터럴 만 포함하는 산술이 Perl의 내장 연산자를 사용하여 수행됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="01006b71ced49944419d9cf9ecdab2df41a8f161" translate="yes" xml:space="preserve">
          <source>This means that if a developer only needs a module for the BAR standard, they should not be forced to install libraries for FOO as well.</source>
          <target state="translated">즉, 개발자가 BAR 표준 용 모듈 만 필요한 경우 FOO 용 라이브러리를 강제로 설치해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="a939b578ee66e30d68a1cb74f87d0079e5aa7b9c" translate="yes" xml:space="preserve">
          <source>This means that it short-circuits: the right expression is evaluated only if the left expression is false. Due to its precedence, you must be careful to avoid using it as replacement for the &lt;code&gt;||&lt;/code&gt; operator. It usually works out better for flow control than in assignments:</source>
          <target state="translated">이것은 단락을 의미합니다. 올바른 표현은 왼쪽 표현이 거짓 인 경우에만 평가됩니다. 우선 순위로 인해 &lt;code&gt;||&lt;/code&gt; 의 대체로 사용하지 않도록주의해야합니다. 운영자. 일반적으로 할당보다 흐름 제어에 더 좋습니다.</target>
        </trans-unit>
        <trans-unit id="be9154072eb271aa42c51fcc713d07f839133a3a" translate="yes" xml:space="preserve">
          <source>This means that the code points from 0 to 0x2F do not represent decimal digits; the code point 0x30 (DIGIT ZERO) represents 0; code point 0x31, (DIGIT ONE), represents 0+1-0 = 1; ... code point 0x39, (DIGIT NINE), represents 0+9-0 = 9; ... code points 0x3A through 0x65F do not represent decimal digits; 0x660 (ARABIC-INDIC DIGIT ZERO), represents 0; ... 0x07C1 (NKO DIGIT ONE), represents 0+1-0 = 1 ...</source>
          <target state="translated">이것은 0에서 0x2F까지의 코드 포인트가 10 진수를 나타내지 않음을 의미합니다. 코드 포인트 0x30 (DIGIT ZERO)은 0을 나타내고; 코드 포인트 0x31 (DIGIT ONE)은 0 + 1-0 = 1을 나타내고; ... 코드 포인트 0x39 (DIGIT NINE)는 0 + 9-0 = 9를 나타냅니다. ... 코드 포인트 0x3A ~ 0x65F는 십진수를 나타내지 않습니다. 0x660 (ARABIC-INDIC DIGIT ZERO)은 0을 나타내고; ... 0x07C1 (NKO DIGIT ONE)은 0 + 1-0 = 1을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="53a7571a93760445ebdaebf443e990e621523e20" translate="yes" xml:space="preserve">
          <source>This means that the example in the synopsis could be rewritten more simply as:</source>
          <target state="translated">이것은 시놉시스의 예제가 다음과 같이 더 간단하게 다시 쓰여질 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a1f3ea2c657f7b7f7d19db3a4421f880ee25efe3" translate="yes" xml:space="preserve">
          <source>This means that the space in the middle of the visible link text must not be broken across lines. In other words, it's the same as this:</source>
          <target state="translated">즉, 보이는 링크 텍스트 중간에 공백이 줄을 넘지 않아야합니다. 다시 말해, 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="64c7de2c5fffc581047d71755a716f6efa16c586" translate="yes" xml:space="preserve">
          <source>This means that the words in</source>
          <target state="translated">이것은</target>
        </trans-unit>
        <trans-unit id="f1569c4431f8fc6543e767edacb7a758da5a6960" translate="yes" xml:space="preserve">
          <source>This means that when &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; is in effect, &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; lets you use a package variable without qualifying it with the package name, but only within the lexical scope of the &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration. This applies immediately--even within the same statement.</source>
          <target state="translated">때이 방법 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; 효과에있다가, &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 당신 만의 어휘 범위 내에서, 패키지 이름으로 자격을하지 않고 패키지 변수를 사용할 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 선언. 이것은 심지어 같은 진술 내에서도 즉시 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="f586cceadb03a1ba8357cc824f5f5d4e8015da6f" translate="yes" xml:space="preserve">
          <source>This means that when &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; is in effect, &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; lets you use a package variable without qualifying it with the package name, but only within the lexical scope of the &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration. This applies immediately--even within the same statement.</source>
          <target state="translated">때이 방법 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; 효과에있다가, &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 당신 만의 어휘 범위 내에서, 패키지 이름으로 자격을하지 않고 패키지 변수를 사용할 수 있습니다 &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 선언. 이것은 심지어 같은 진술 내에서도 즉시 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b81785772e2cebea14c023690b3e80231bc941d4" translate="yes" xml:space="preserve">
          <source>This means that you can embed Perl code in your typemap (C) code using constructs such as &lt;code&gt;${ perl code that evaluates to &lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt; reference here }&lt;/code&gt; . A common use case is to generate error messages that refer to the true function name even when using the ALIAS XS feature:</source>
          <target state="translated">이는 &lt;code&gt;${ perl code that evaluates to &lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt; reference here }&lt;/code&gt; 참조로 평가 되는 $ {perl code } 와 같은 구문을 사용하여 typemap (C) 코드에 Perl 코드를 포함시킬 수 있음을 의미합니다 . 일반적인 사용 사례는 ALIAS XS 기능을 사용할 때도 실제 기능 이름을 나타내는 오류 메시지를 생성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fae397e13ee74537dfbe00fc3647b75575531d38" translate="yes" xml:space="preserve">
          <source>This means that you can pass back or save away references to lexical variables, whereas to return a pointer to a C auto is a grave error. It also gives us a way to simulate C's function statics. Here's a mechanism for giving a function private variables with both lexical scoping and a static lifetime. If you do want to create something like C's static variables, just enclose the whole function in an extra block, and put the static variable outside the function but in the block.</source>
          <target state="translated">이는 어휘 변수에 대한 참조를 다시 전달하거나 저장할 수있는 반면 C auto에 대한 포인터를 리턴하는 것은 심각한 오류입니다. 또한 C의 함수 정적을 시뮬레이트하는 방법도 제공합니다. 다음은 어휘 범위와 정적 수명이 모두있는 함수 전용 변수를 제공하는 메커니즘입니다. C의 정적 변수와 같은 것을 만들려면 전체 함수를 여분의 블록으로 묶고 정적 변수를 함수 외부의 블록에 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="ba95400be83f3e213b12cd9a0fd5821a87880672" translate="yes" xml:space="preserve">
          <source>This means that your locale settings had &lt;code&gt;LC_ALL&lt;/code&gt; set to &quot;En_US&quot; and LANG exists but has no value. Perl tried to believe you but could not. Instead, Perl gave up and fell back to the &quot;C&quot; locale, the default locale that is supposed to work no matter what. (On Windows, it first tries falling back to the system default locale.) This usually means your locale settings were wrong, they mention locales your system has never heard of, or the locale installation in your system has problems (for example, some system files are broken or missing). There are quick and temporary fixes to these problems, as well as more thorough and lasting fixes.</source>
          <target state="translated">이는 로케일 설정에 &lt;code&gt;LC_ALL&lt;/code&gt; 이 &quot;En_US&quot;로 설정되어 있고 LANG가 존재하지만 값이 없음을 의미합니다. 펄은 당신을 믿으려고했지만 실패했습니다. 대신, Perl은 포기하고 &quot;C&quot;로케일로 넘어갔습니다. 기본 로케일은 무엇이든 상관 없습니다. (Windows에서는 먼저 시스템 기본 로케일로 돌아 가려고 시도합니다.) 이는 일반적으로 로케일 설정이 잘못되었거나 시스템에서 들어 본 적이없는 로케일을 언급하거나 시스템의 로케일 설치에 문제점이 있음을 의미합니다 (예 : 일부 시스템). 파일이 손상되었거나 누락되었습니다). 이러한 문제에 대한 신속하고 임시적인 수정뿐만 아니라보다 철저하고 지속적인 수정이 있습니다.</target>
        </trans-unit>
        <trans-unit id="935bdf240cb07ad1d6c61c4ce332cb8c8c8bea3f" translate="yes" xml:space="preserve">
          <source>This means the hook can be inherited like any other method, and that</source>
          <target state="translated">즉, 후크는 다른 방법과 마찬가지로 상속 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2829080b86855df25144fdad5ccaac91d3e22b76" translate="yes" xml:space="preserve">
          <source>This means the same thing as the above &quot;=begin html&quot; ... &quot;=end html&quot; region.</source>
          <target state="translated">이것은 위의 &quot;= begin html&quot;... &quot;= end html&quot;영역과 같은 의미입니다.</target>
        </trans-unit>
        <trans-unit id="44c698371a2bc8c8f85a78f7834202f417a26f2b" translate="yes" xml:space="preserve">
          <source>This means you would have to be very careful of the load order:</source>
          <target state="translated">이는로드 순서에 매우주의해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="cff2ec52af1291aa43e3a1c0cb12356c3eeef13f" translate="yes" xml:space="preserve">
          <source>This member is of type &lt;code&gt;Perl_cpeep_t&lt;/code&gt; , which expands to &lt;code&gt;void
(*Perl_cpeep_t)(aTHX_ OP *o, OP *oldop)&lt;/code&gt; . If it is set, this function will be called from &lt;code&gt;Perl_rpeep&lt;/code&gt; when ops of this type are encountered by the peephole optimizer.</source>
          <target state="translated">이 멤버 형인 &lt;code&gt;Perl_cpeep_t&lt;/code&gt; 로 확장, &lt;code&gt;void (*Perl_cpeep_t)(aTHX_ OP *o, OP *oldop)&lt;/code&gt; . 설정된 경우이 기능은 틈 구멍 최적화 장치에서이 유형의 작동이 발견 될 때 &lt;code&gt;Perl_rpeep&lt;/code&gt; 에서 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="4f15c1dce331d08d1c4dfe4e281cc0a0a4b34f0a" translate="yes" xml:space="preserve">
          <source>This message can be seen quite often with DB_File on systems with &quot;hard&quot; dynamic linking, like &lt;code&gt;AIX&lt;/code&gt; and &lt;code&gt;OS/2&lt;/code&gt; . It is a bug of &lt;code&gt;Berkeley DB&lt;/code&gt; which is left unnoticed if &lt;code&gt;DB&lt;/code&gt; uses</source>
          <target state="translated">이 메시지는 &lt;code&gt;AIX&lt;/code&gt; 및 &lt;code&gt;OS/2&lt;/code&gt; 와 같이 &quot;하드&quot;동적 링크가있는 시스템의 DB_File에서 자주 볼 수 있습니다 . &lt;code&gt;Berkeley DB&lt;/code&gt; 의 버그로 &lt;code&gt;DB&lt;/code&gt; 가 사용하는 경우 눈에 띄지 않습니다.</target>
        </trans-unit>
        <trans-unit id="23eb60fb126cb22151d73766a234b7a419df8dc7" translate="yes" xml:space="preserve">
          <source>This message is output once each time a bad locale is switched into within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , or on the first possibly-affected operation if the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; inherits a bad one. It is not raised for any operations from the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module.</source>
          <target state="translated">이 메시지는 잘못된 로케일이 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 범위 locale 내 에서 또는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 이 잘못된 로컬을 상속하는 경우 영향을받는 첫 번째 조작 으로 전환 될 때마다 한 번씩 출력 됩니다 . &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; 모듈의 조작에 대해서는 발생하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9f1e56024310d1748ef48e25b309befac60c3c39" translate="yes" xml:space="preserve">
          <source>This message is suppressed (unless it has been made fatal) if it is immaterial to the results of the match if the code point is Unicode or not. For example, the property &lt;code&gt;\p{ASCII_Hex_Digit}&lt;/code&gt; only can match the 22 characters &lt;code&gt;[0-9A-Fa-f]&lt;/code&gt; , so obviously all other code points, Unicode or not, won't match it. (And &lt;code&gt;\P{ASCII_Hex_Digit}&lt;/code&gt; will match every code point except these 22.)</source>
          <target state="translated">코드 포인트가 유니 코드인지 여부에 관계없이 일치 결과에 중요하지 않은 경우이 메시지는 표시되지 않습니다 (치명적이지 않은 경우 제외). 예를 들어, &lt;code&gt;\p{ASCII_Hex_Digit}&lt;/code&gt; 속성 은 22 자 &lt;code&gt;[0-9A-Fa-f]&lt;/code&gt; 와만 일치 할 수 있으므로 다른 모든 코드 포인트 (유니 코드 여부에 관계없이)는 일치하지 않습니다. (그리고 &lt;code&gt;\P{ASCII_Hex_Digit}&lt;/code&gt; 는이 22를 제외한 모든 코드 포인트와 일치합니다.)</target>
        </trans-unit>
        <trans-unit id="7bb0745c94a8675163fb7cf1b6b4c0dfe9dfc2a4" translate="yes" xml:space="preserve">
          <source>This method (by having it return the name of a language-tag that has an existing language class) can be used for making sure that &lt;code&gt;get_handle&lt;/code&gt; will always manage to construct a language handle (assuming your language classes are in an appropriate @INC directory). Or you can use the next method:</source>
          <target state="translated">이 메소드 (기존 언어 클래스가있는 언어 태그의 이름을 리턴 함)를 사용하여 &lt;code&gt;get_handle&lt;/code&gt; 이 항상 언어 핸들을 구성하도록 관리 할 수 ​​있습니다 (언어 클래스가 적절한 @INC 디렉토리에 있다고 가정). . 또는 다음 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43b19e8a9632f033ee0217cf824970a6266507f4" translate="yes" xml:space="preserve">
          <source>This method &lt;b&gt;only&lt;/b&gt; recurses into hashes that are referenced by another hash. Thus a Hash of Hashes (HoH) will all be restricted, but a Hash of Arrays of Hashes (HoAoH) will only have the top hash restricted.</source>
          <target state="translated">이 메소드 는 다른 해시에서 참조하는 해시 &lt;b&gt;로만&lt;/b&gt; 반복됩니다. 따라서 해시 해시 (HoH)는 모두 제한되지만 해시 어레이 해시 (HoAoH)는 최상위 해시 만 제한합니다.</target>
        </trans-unit>
        <trans-unit id="a9adaf0f299fbd1e9f3a618dc3103eaac097e023" translate="yes" xml:space="preserve">
          <source>This method allows you declare all subsequent tests as TODO tests, up until the &lt;code&gt;todo_end&lt;/code&gt; method has been called.</source>
          <target state="translated">이 메소드를 사용하면 &lt;code&gt;todo_end&lt;/code&gt; 메소드가 호출 될 때까지 모든 후속 테스트를 TODO 테스트로 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="730814a3d72347a8011b0b6b58b63dc1cbc1cb75" translate="yes" xml:space="preserve">
          <source>This method always returns &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when compressing.</source>
          <target state="translated">이 메소드는 압축 할 때 항상 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="6afef23ef81e88b5f94163ca10a11464e31ea48f" translate="yes" xml:space="preserve">
          <source>This method appends the given text or parse-tree to the current parse-tree. If the last item on the parse-tree is text and the argument is also text, then the text is appended to the last item (not added as a separate string). Otherwise the argument is added as a new string or parse-tree</source>
          <target state="translated">이 메소드는 지정된 텍스트 또는 구문 분석 트리를 현재 구문 분석 트리에 추가합니다. 구문 분석 트리의 마지막 항목이 텍스트이고 인수도 텍스트 인 경우 텍스트는 마지막 항목에 추가됩니다 (별도의 문자열로 추가되지 않음). 그렇지 않으면 인수가 새 문자열 또는 구문 분석 트리로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="ea9b54b0560b3ed55c0cd396158f6152d9f5e42b" translate="yes" xml:space="preserve">
          <source>This method behaves like &lt;code&gt;accept_targets_as_text&lt;/code&gt; , but also marks the region as one whose content should be emitted literally, without HTML entity escaping or wrapping in a &lt;code&gt;div&lt;/code&gt; element.</source>
          <target state="translated">이 메소드는 &lt;code&gt;accept_targets_as_text&lt;/code&gt; 와 같이 작동 하지만 HTML 엔티티가 이스케이프되거나 &lt;code&gt;div&lt;/code&gt; 요소로 줄 바꿈되지 않고 콘텐츠가 문자 그대로 방출되어야하는 영역으로 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="366bdf6f4cd4331574bef09ad73e8fc1d9c85442" translate="yes" xml:space="preserve">
          <source>This method can also be called as a</source>
          <target state="translated">이 방법은</target>
        </trans-unit>
        <trans-unit id="715fe7c265d92fe58819e384722c797c228ac231" translate="yes" xml:space="preserve">
          <source>This method can be used to (re)parse a (new) hyperlink, i.e. the contents of a &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; sequence. The result is stored in the current object. Warnings are stored in the &lt;b&gt;warnings&lt;/b&gt; property. E.g. sections like &lt;code&gt;L&amp;lt;open(2)&amp;gt;&lt;/code&gt; are deprecated, as they do not point to Perl documents. &lt;code&gt;L&amp;lt;DBI::foo(3p)&amp;gt;&lt;/code&gt; is wrong as well, the manpage section can simply be dropped.</source>
          <target state="translated">이 방법은 (새로운) 하이퍼 링크, 즉 &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; 시퀀스 의 내용을 (재) 파싱하는데 사용될 수있다 . 결과는 현재 객체에 저장됩니다. 경고는 &lt;b&gt;경고&lt;/b&gt; 속성에 저장됩니다 . 예를 들어 &lt;code&gt;L&amp;lt;open(2)&amp;gt;&lt;/code&gt; 와 같은 섹션은 Perl 문서를 가리 키지 않으므로 더 이상 사용되지 않습니다. &lt;code&gt;L&amp;lt;DBI::foo(3p)&amp;gt;&lt;/code&gt; 도 잘못되었습니다. 맨 페이지 섹션을 간단히 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1f35fb67080240d23f2eac011ae3670c8591965" translate="yes" xml:space="preserve">
          <source>This method can be used to attempt to recover good data from a compressed data stream that is partially corrupt. It scans &lt;code&gt;$input&lt;/code&gt; until it reaches either a</source>
          <target state="translated">이 방법을 사용하면 부분적으로 손상된 압축 데이터 스트림에서 올바른 데이터를 복구 할 수 있습니다. 그것은 하나에 도달 할 때까지 &lt;code&gt;$input&lt;/code&gt; 스캔 합니다.</target>
        </trans-unit>
        <trans-unit id="90ddd0ac6657449db229f14a03b758f7e485db52" translate="yes" xml:space="preserve">
          <source>This method can be used to wait for a transfer to complete between a passive server and a non-passive server. The method should be called on the passive server with the &lt;code&gt;Net::FTP&lt;/code&gt; object for the non-passive server passed as an argument.</source>
          <target state="translated">이 방법은 수동 서버와 비 수동 서버 사이에서 전송이 완료되기를 기다리는 데 사용할 수 있습니다. 비 수동 서버에 대한 &lt;code&gt;Net::FTP&lt;/code&gt; 객체를 인수로 전달 하여 패시브 서버에서이 메소드를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ef82cc525f992d173e6595484cbecf34f240de62" translate="yes" xml:space="preserve">
          <source>This method checks for the existence of a specific key/value pair. If the pair exists, the cursor is left pointing to the pair and the method returns 0. Otherwise the method returns a non-zero value.</source>
          <target state="translated">이 방법은 특정 키 / 값 쌍이 있는지 확인합니다. 쌍이 존재하면 커서는 쌍을 가리키고 왼쪽은 0을 반환합니다. 그렇지 않으면 0이 아닌 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="082e97019fd385ec77aeb826bdad258d6d406921" translate="yes" xml:space="preserve">
          <source>This method deletes a specific key/value pair. It returns 0 if they exist and have been deleted successfully. Otherwise the method returns a non-zero value.</source>
          <target state="translated">이 방법은 특정 키 / 값 쌍을 삭제합니다. 존재하고 성공적으로 삭제 된 경우 0을 리턴합니다. 그렇지 않으면이 메서드는 0이 아닌 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f513febb40f0a4c26460c04fb3a509ae4b426b01" translate="yes" xml:space="preserve">
          <source>This method deserializes the given string of JSON and the result. If the source was UTF-8 encoded, the string must be decoded before calling &lt;code&gt;load_json_string&lt;/code&gt; .</source>
          <target state="translated">이 메소드는 주어진 JSON 문자열과 결과를 deserialize합니다. 소스가 UTF-8로 인코딩 된 경우 &lt;code&gt;load_json_string&lt;/code&gt; 을 호출하기 전에 문자열을 디코딩해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f96e67c98ce1447f296a5e844322e09f6dd910a8" translate="yes" xml:space="preserve">
          <source>This method deserializes the given string of YAML and returns the first document in it. (CPAN metadata files should always have only one document.) If the source was UTF-8 encoded, the string must be decoded before calling &lt;code&gt;load_yaml_string&lt;/code&gt; .</source>
          <target state="translated">이 메소드는 주어진 YAML 문자열을 deserialize하고 그 안의 첫 번째 문서를 반환합니다. (CPAN 메타 데이터 파일에는 항상 하나의 문서 만 있어야합니다.) 소스가 UTF-8로 인코딩 된 경우 &lt;code&gt;load_yaml_string&lt;/code&gt; 을 호출하기 전에 문자열을 디코딩해야합니다 .</target>
        </trans-unit>
        <trans-unit id="34a514b4f19b9ac86f842d6404bf8e89dd74c0e2" translate="yes" xml:space="preserve">
          <source>This method does</source>
          <target state="translated">이 방법은</target>
        </trans-unit>
        <trans-unit id="54d18cd2ca68c9792cf6431fafe4da3a6cbdd8dc" translate="yes" xml:space="preserve">
          <source>This method does not implement a complete YAML dumper, being limited to dump a hash with values which are strings, undef's or nested hashes and arrays of strings. No quoting/escaping is done.</source>
          <target state="translated">이 방법은 완전한 YAML 덤퍼를 구현하지 않으며, 문자열, undef 또는 중첩 해시 및 문자열 배열 인 값으로 해시를 덤프하도록 제한됩니다. 인용 / 탈출이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bf3b86793c28703b24d0cd86f4cd0ebea05c47fa" translate="yes" xml:space="preserve">
          <source>This method fully supports the use of the variable &lt;code&gt;$/&lt;/code&gt; (or &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; or &lt;code&gt;$RS&lt;/code&gt; when &lt;code&gt;English&lt;/code&gt; is in use) to determine what constitutes an end of line. Paragraph mode, record mode and file slurp mode are all supported.</source>
          <target state="translated">이 방법은 변수 &lt;code&gt;$/&lt;/code&gt; (또는 &lt;code&gt;English&lt;/code&gt; 를 사용하는 경우 &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; 또는 &lt;code&gt;$RS&lt;/code&gt; )를 사용하여 줄 끝을 구성하는 것을 완전히 지원합니다 . 단락 모드, 레코드 모드 및 파일 슬러 프 모드가 모두 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="7abd31a42f5dc198423e7bfa2a6a7d4410aa53a3" translate="yes" xml:space="preserve">
          <source>This method gets faster the more sparse the bit vector is. (Courtesy of Tim Bunce and Winfried Koenig.)</source>
          <target state="translated">이 방법은 비트 벡터가 많을수록 더 빠릅니다. (팀 번체와 윈프리 드 코니 그 제공)</target>
        </trans-unit>
        <trans-unit id="5106fbdd40086fe1994d026f8235d7c19445b51f" translate="yes" xml:space="preserve">
          <source>This method gets triggered during a keys() or each() iteration. It has a second argument which is the last key that had been accessed. This is useful if you're carrying about ordering or calling the iterator from more than one sequence, or not really storing things in a hash anywhere.</source>
          <target state="translated">이 메소드는 keys () 또는 each () 반복 중에 트리거됩니다. 마지막으로 액세스 한 키인 두 번째 인수가 있습니다. 이것은 하나 이상의 시퀀스에서 반복자를 주문하거나 호출하거나 실제로 해시에 물건을 저장하지 않는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="2b32b03e834069c38c85e8165c3d6300a8ef2db8" translate="yes" xml:space="preserve">
          <source>This method gets/sets the children of the top node in the parse-tree. If no arguments are given, it returns the list (array) of children (each of which should be either a string or a &lt;b&gt;Pod::InteriorSequence&lt;/b&gt;. Otherwise, if arguments are given, they are treated as the new list of children for the top node.</source>
          <target state="translated">이 메소드는 구문 분석 트리에서 최상위 노드의 자식을 가져 오거나 설정합니다. 인수가 제공되지 않으면 하위 목록 (배열)을 리턴합니다 (각각 문자열 또는 &lt;b&gt;Pod :: InteriorSequence&lt;/b&gt; 여야 함) . 그렇지 않으면 인수가 제공되면 상위의 하위 목록으로 처리됩니다. 마디.</target>
        </trans-unit>
        <trans-unit id="b46a6ad296dd61f630d70737a71545994d0ce79d" translate="yes" xml:space="preserve">
          <source>This method gets/sets the top node of the parse-tree. If no arguments are given, it returns the topmost node in the tree (the root), which is also a &lt;b&gt;Pod::ParseTree&lt;/b&gt;. If it is given a single argument that is a reference, then the reference is assumed to a parse-tree and becomes the new top node. Otherwise, if arguments are given, they are treated as the new list of children for the top node.</source>
          <target state="translated">이 메소드는 구문 분석 트리의 최상위 노드를 가져 오거나 설정합니다. 인수가 제공되지 않으면 트리에서 최상위 노드 (루트)를 반환 &lt;b&gt;하며이 노드&lt;/b&gt; 는 &lt;b&gt;Pod :: ParseTree이기도&lt;/b&gt; 합니다. 참조 인 단일 인수가 제공되면 해당 참조는 구문 분석 트리로 간주되어 새 최상위 노드가됩니다. 그렇지 않으면 인수가 제공되면 상위 노드의 새 하위 목록으로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="59076bbdbb5b4ddcc87d5e0b9c9e7bca5153b33d" translate="yes" xml:space="preserve">
          <source>This method handles the body of text that is marked up to be code. You might for instance override this to plug in a syntax highlighter. The base implementation just escapes the text.</source>
          <target state="translated">이 메소드는 코드로 표시되는 텍스트 본문을 처리합니다. 예를 들어 구문 형광펜을 연결하기 위해이를 재정의 할 수 있습니다. 기본 구현은 텍스트를 이스케이프합니다.</target>
        </trans-unit>
        <trans-unit id="7f7d4c41920dd2575a0ef9de52d6dfd4b083b3af" translate="yes" xml:space="preserve">
          <source>This method handles the body of text within any element: it's the body of a paragraph, or everything between a &quot;=begin&quot; tag and the corresponding &quot;=end&quot; tag, or the text within an L entity, etc. You would want to override this if you are adding a custom element type that does more than just display formatted text. Perhaps adding a way to generate HTML tables from an extended version of POD.</source>
          <target state="translated">이 메소드는 모든 요소 내에서 텍스트 본문을 처리합니다. 단락 본문 또는 &quot;= begin&quot;태그와 해당 &quot;= end&quot;태그 사이의 모든 항목 또는 L 엔터티 내의 텍스트 등입니다. 형식이 지정된 텍스트 만 표시하는 것 이상의 사용자 정의 요소 유형을 추가하는 경우이 옵션을 대체하십시오. 확장 버전의 POD에서 HTML 테이블을 생성하는 방법을 추가했을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0712996dc1b8ffb7aa50e7d069711d277d763268" translate="yes" xml:space="preserve">
          <source>This method has exactly the same effect as</source>
          <target state="translated">이 방법은</target>
        </trans-unit>
        <trans-unit id="065b0a15e17527d35032fe1e6828915d084d4b0d" translate="yes" xml:space="preserve">
          <source>This method is a synonym for &lt;code&gt;actual_passed&lt;/code&gt; .</source>
          <target state="translated">이 메소드는 &lt;code&gt;actual_passed&lt;/code&gt; 와 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="a3a66a71f2968f9c82df6782744ec138e9c54cf9" translate="yes" xml:space="preserve">
          <source>This method is called automatically when the object is used as a string.</source>
          <target state="translated">이 메소드는 객체가 문자열로 사용될 때 자동으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a819fa8543b1fdd50426768934ef9b1f1b767855" translate="yes" xml:space="preserve">
          <source>This method is called automatically when the object is used in string context.</source>
          <target state="translated">이 메소드는 객체가 문자열 컨텍스트에서 사용될 때 자동으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="ac138a74ffc74278892e510893352f2e36c5d5e7" translate="yes" xml:space="preserve">
          <source>This method is called by &lt;code&gt;response&lt;/code&gt; as a method with one argument. It should return an array of 2 values, the 3-digit status code and a flag which is true when this is part of a multi-line response and this line is not the last.</source>
          <target state="translated">이 메소드는 하나의 인수가있는 메소드로서 &lt;code&gt;response&lt;/code&gt; 의해 호출됩니다 . 두 줄의 값, 3 자리 상태 코드 및 이것이 여러 줄 응답의 일부이고이 줄이 마지막이 아닌 경우 true 인 플래그를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="caa6afaab7cedc695e3c6f58f69b2ab8274688f3" translate="yes" xml:space="preserve">
          <source>This method is called during construction by &lt;code&gt;IO::Pipe::new&lt;/code&gt; on the newly created &lt;code&gt;IO::Pipe&lt;/code&gt; object. It returns an array of two objects blessed into &lt;code&gt;IO::Pipe::End&lt;/code&gt; , or a subclass thereof.</source>
          <target state="translated">이 메소드는 새로 작성된 &lt;code&gt;IO::Pipe&lt;/code&gt; 오브젝트 에서 &lt;code&gt;IO::Pipe::new&lt;/code&gt; 에 의해 구성 중에 호출됩니다 . &lt;code&gt;IO::Pipe::End&lt;/code&gt; 또는 그 서브 클래스에 축복 된 두 객체의 배열을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="5287b2e5ba98e503e67859e5f2d01d79cbfa6c5e" translate="yes" xml:space="preserve">
          <source>This method is called to print debugging information. TEXT is the text being sent. The method should return the text to be printed.</source>
          <target state="translated">이 메소드는 디버깅 정보를 인쇄하기 위해 호출됩니다. TEXT는 전송되는 텍스트입니다. 이 메소드는 인쇄 할 텍스트를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="f167b29ab442c8210c9356c7997b2fd2247776b0" translate="yes" xml:space="preserve">
          <source>This method is called when the handle is read via &lt;code&gt;&amp;lt;HANDLE&amp;gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt; HANDLE&lt;/code&gt; .</source>
          <target state="translated">이 메소드는 &lt;code&gt;&amp;lt;HANDLE&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt; HANDLE&lt;/code&gt; 을 통해 핸들을 읽을 때 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="c6629dc17ac853da211380c0f404bf1fca26aed1" translate="yes" xml:space="preserve">
          <source>This method is called with two arguments: the relevant package name, and a reference to a variable or subroutine for which package-defined attributes are desired. The expected return value is a list of associated attributes. This list may be empty.</source>
          <target state="translated">이 메소드는 관련 패키지 이름과 패키지 정의 속성이 필요한 변수 또는 서브 루틴에 대한 참조라는 두 개의 인수와 함께 호출됩니다. 예상되는 반환 값은 관련 속성 목록입니다. 이 목록은 비어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45320fc2f3e3a4eca2479ec9f217dfab3504ebe5" translate="yes" xml:space="preserve">
          <source>This method is called with two fixed arguments, followed by the list of attributes from the relevant declaration. The two fixed arguments are the relevant package name and a reference to the declared subroutine or variable. The expected return value is a list of attributes which were not recognized by this handler. Note that this allows for a derived class to delegate a call to its base class, and then only examine the attributes which the base class didn't already handle for it.</source>
          <target state="translated">이 메소드는 두 개의 고정 인수와 관련 선언의 속성 목록으로 호출됩니다. 두 개의 고정 인수는 관련 패키지 이름과 선언 된 서브 루틴 또는 변수에 대한 참조입니다. 예상 리턴 값은이 핸들러가 인식하지 못한 속성 목록입니다. 이렇게하면 파생 클래스가 기본 클래스에 대한 호출을 위임 한 다음 기본 클래스가 아직 처리하지 않은 특성 만 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6abefc963006076df05b84dfc6d2811ce9f6040b" translate="yes" xml:space="preserve">
          <source>This method is deprecated if running under Perl 5.8, and is no longer present if running under Perl 5.9</source>
          <target state="translated">이 방법은 Perl 5.8에서 실행되는 경우 더 이상 사용되지 않으며 Perl 5.9에서 실행되는 경우 더 이상 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c663722b6a1ec14ffe0820b635acf25e140b2e8" translate="yes" xml:space="preserve">
          <source>This method is invoked after gathering up all the lines in a paragraph and after determining the cutting state of the paragraph, but before trying to further parse or interpret them. After &lt;b&gt;preprocess_paragraph()&lt;/b&gt; returns, the current cutting state (which is returned by &lt;code&gt;$self-&amp;gt;cutting()&lt;/code&gt; ) is examined. If it evaluates to true then input text (including the given &lt;code&gt;$text&lt;/code&gt; ) is cut (not processed) until the next POD directive is encountered.</source>
          <target state="translated">이 메소드는 단락의 모든 행을 수집 한 후 단락의 절단 상태를 판별 한 후 추가 구문 분석 또는 해석을 시도하기 전에 호출됩니다. &lt;b&gt;preprocess_paragraph ()가&lt;/b&gt; 리턴 된 후 현재 절단 상태 ( &lt;code&gt;$self-&amp;gt;cutting()&lt;/code&gt; 의해 리턴 됨 )가 검사됩니다. true로 평가 되면 다음 POD 지시어가 나타날 때까지 입력 텍스트 (주어진 &lt;code&gt;$text&lt;/code&gt; )가 잘립니다 (처리되지 않음).</target>
        </trans-unit>
        <trans-unit id="10379a9139313cde9e23b44b9d3191ab35fe83cb" translate="yes" xml:space="preserve">
          <source>This method is invoked at the beginning of processing for each POD document that is encountered in the input. Subclasses should override this method to perform any per-document initialization.</source>
          <target state="translated">이 메소드는 입력에서 발견 된 각 POD 문서에 대한 처리가 시작될 때 호출됩니다. 서브 클래스는 문서마다 초기화를 수행하기 위해이 메소드를 대체해야합니다.</target>
        </trans-unit>
        <trans-unit id="413604196761a8f6291ef93425b6ff6c449d0805" translate="yes" xml:space="preserve">
          <source>This method is invoked at the end of processing for each POD document that is encountered in the input. Subclasses should override this method to perform any per-document finalization.</source>
          <target state="translated">이 메소드는 입력에서 발견 된 각 POD 문서에 대한 처리가 끝날 때 호출됩니다. 서브 클래스는 문서 당 마무리를 수행하기 위해이 메소드를 대체해야합니다.</target>
        </trans-unit>
        <trans-unit id="c39c6b3f4be6d469d8afebc0b47e837d73cf3993" translate="yes" xml:space="preserve">
          <source>This method is invoked by &lt;b&gt;parse_from_filehandle()&lt;/b&gt; immediately</source>
          <target state="translated">이 메소드는 &lt;b&gt;parse_from_filehandle ()에&lt;/b&gt; 의해 즉시 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="6747dae8cbf5615de1cf353ad79e0a07cee8a900" translate="yes" xml:space="preserve">
          <source>This method is less often useful. It assumes that the string stored in the struct is null-terminated, and disregards the length information.</source>
          <target state="translated">이 방법은 덜 유용합니다. 구조체에 저장된 문자열이 null로 끝나고 길이 정보를 무시한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="c79ad557d9b0fbcd0831200e697c308d8d3ffa30" translate="yes" xml:space="preserve">
          <source>This method is non-blocking, and will return only as many items as are available to fulfill the request:</source>
          <target state="translated">이 방법은 차단되지 않으며 요청을 처리하는 데 사용할 수있는 항목 수만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6fb78fde591144d3983cff09b4ae34dcd5c3fb9d" translate="yes" xml:space="preserve">
          <source>This method is not present if running under Perl 5.9, as the PMROOT information is no longer stored directly in the hash.</source>
          <target state="translated">PMROOT 정보가 더 이상 해시에 직접 저장되지 않으므로 Perl 5.9에서 실행하는 경우이 방법이 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f1244eb4316f69131f6963e6774a849bda60f19c" translate="yes" xml:space="preserve">
          <source>This method is of no use for general Perl threads programming. Its intent is to provide other (XS-based) thread modules with the capability to access, and possibly manipulate, the underlying thread structure associated with a Perl thread.</source>
          <target state="translated">이 방법은 일반적인 Perl 스레드 프로그래밍에는 사용되지 않습니다. 그 목적은 다른 (XS 기반) 스레드 모듈에 Perl 스레드와 연관된 기본 스레드 구조에 액세스하고 조작 할 수있는 기능을 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="21dc78ea221a1896dd75e4ea5a218dfbc7c4df02" translate="yes" xml:space="preserve">
          <source>This method is protected and not intended to be called outside of MakeMaker.</source>
          <target state="translated">이 방법은 보호되어 있으며 MakeMaker 외부에서 호출하도록되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e5a20cfe7a533839e6244ee0ceb882a48e01de5e" translate="yes" xml:space="preserve">
          <source>This method is similar to share() but allows you to explicitly name the package that symbols should be shared from. The symbol names (including type characters) are supplied as an array reference.</source>
          <target state="translated">이 메소드는 share ()와 유사하지만 심볼을 공유 할 패키지의 이름을 명시 적으로 지정할 수 있습니다. 기호 이름 (유형 문자 포함)은 배열 참조로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="f5a57d1e0f15bd04707c86271032904c47bf2e9b" translate="yes" xml:space="preserve">
          <source>This method is the one you usually want. It constructs a string using the length and offset information in the struct: for ordinary scalars it will return the string that you'd see from Perl, even if it contains null characters.</source>
          <target state="translated">이 방법은 일반적으로 원하는 방법입니다. 구조체의 길이와 오프셋 정보를 사용하여 문자열을 구성합니다. 일반 스칼라의 경우 null 문자가 포함되어 있어도 Perl에서 볼 수있는 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="01115bf69ddf4deb1227d201ea74e47486095d25" translate="yes" xml:space="preserve">
          <source>This method is triggered when a tied hash is about to go out of scope. You don't really need it unless you're trying to add debugging or have auxiliary state to clean up. Here's a very simple function:</source>
          <target state="translated">이 방법은 연결된 해시가 범위를 벗어나려고 할 때 트리거됩니다. 디버깅을 추가하거나 정리할 보조 상태가 아닌 한 실제로 필요하지 않습니다. 매우 간단한 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2987f28dec8ef9effc2010b2cf05de3e78ff66c2" translate="yes" xml:space="preserve">
          <source>This method is triggered when the user uses the exists() function on a particular hash. In our example, we'll look at the &lt;code&gt;{LIST}&lt;/code&gt; hash element for this:</source>
          <target state="translated">이 메소드는 사용자가 특정 해시에서 exist () 함수를 사용할 때 트리거됩니다. 이 예에서는 &lt;code&gt;{LIST}&lt;/code&gt; 해시 요소를 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="642b5a68b22f43aa4631e9ecbebcec5f49cf6aa8" translate="yes" xml:space="preserve">
          <source>This method is triggered when the whole hash is to be cleared, usually by assigning the empty list to it.</source>
          <target state="translated">이 메소드는 일반적으로 빈 목록을 지정하여 전체 해시를 지울 때 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="b7c5e76fa8c5d820b269407c2691745bfe513299" translate="yes" xml:space="preserve">
          <source>This method is triggered when we remove an element from the hash, typically by using the delete() function. Again, we'll be careful to check whether they really want to clobber files.</source>
          <target state="translated">이 메소드는 일반적으로 delete () 함수를 사용하여 해시에서 요소를 제거 할 때 트리거됩니다. 다시, 우리는 그들이 파일을 클로버하기를 원하는지주의해서 검사 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="d44b267a60e501cab8cef2efaa122beb61916cef" translate="yes" xml:space="preserve">
          <source>This method is used to add to the currently selected sections and subsections of POD documentation that are to be printed and/or processed. See &amp;lt;select()&amp;gt; for replacing the currently selected sections.</source>
          <target state="translated">이 방법은 인쇄 및 / 또는 처리 될 POD 문서의 현재 선택된 섹션 및 하위 섹션에 추가하는 데 사용됩니다. 현재 선택된 섹션을 바꾸려면 &amp;lt;select ()&amp;gt;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="79298df7a94b5d243fe4caa12d96cacff3087b81" translate="yes" xml:space="preserve">
          <source>This method is used to determine if the block of text given in &lt;code&gt;$paragraph&lt;/code&gt; falls within the currently selected set of POD sections and subsections to be printed or processed. This method is also responsible for keeping track of the current input section and subsections. It is assumed that &lt;code&gt;$paragraph&lt;/code&gt; is the most recently read (but not yet processed) input paragraph.</source>
          <target state="translated">이 방법은 &lt;code&gt;$paragraph&lt;/code&gt; 주어진 텍스트 블록 이 인쇄 또는 처리 될 현재 선택된 POD 섹션 및 서브 섹션 세트에 속하는지 여부를 판별하는 데 사용 됩니다. 이 방법은 또한 현재 입력 섹션과 하위 섹션을 추적합니다. &lt;code&gt;$paragraph&lt;/code&gt; 는 가장 최근에 읽은 (그러나 아직 처리되지 않은) 입력 단락 이라고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="bbbe3e628f204e314a28a9c25f8f03f14e0f6464" translate="yes" xml:space="preserve">
          <source>This method is used to select the particular sections and subsections of POD documentation that are to be printed and/or processed. The existing set of selected sections is</source>
          <target state="translated">이 방법은 인쇄 및 / 또는 처리 될 POD 문서의 특정 섹션과 하위 섹션을 선택하는 데 사용됩니다. 선택된 섹션의 기존 세트는</target>
        </trans-unit>
        <trans-unit id="bef747284ac03954e21b22973b38b9cf4e4e7f3d" translate="yes" xml:space="preserve">
          <source>This method is useful if you need to perform your own interpolation of interior sequences and can't rely upon &lt;b&gt;interpolate&lt;/b&gt; to expand them in simple bottom-up order.</source>
          <target state="translated">이 방법은 내부 시퀀스의 자체 보간을 수행해야하며 &lt;b&gt;보간&lt;/b&gt; 에 의존하여 간단한 상향식 순서로 확장 할 수없는 경우에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="49a58cbb089494a695c730a567717e544a3c0dd9" translate="yes" xml:space="preserve">
          <source>This method isn't terribly useful since modules which share the same Test::Builder object might get exported to different packages and only the last one will be honored.</source>
          <target state="translated">동일한 Test :: Builder 객체를 공유하는 모듈이 다른 패키지로 내보내 져서 마지막 패키지 만 적용되므로이 방법은별로 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6554ac6945a5df20c377de63d8de44dbce743773" translate="yes" xml:space="preserve">
          <source>This method keyword is documented in &lt;a href=&quot;../perlobj#Destructors&quot;&gt;Destructors in perlobj&lt;/a&gt;.</source>
          <target state="translated">이 메소드 키워드는 &lt;a href=&quot;../perlobj#Destructors&quot;&gt;perlobj의 소멸자에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e359554a4d991920df0d798d38cb8b6bf47ec29" translate="yes" xml:space="preserve">
          <source>This method keyword is documented in &lt;a href=&quot;perlobj#Destructors&quot;&gt;Destructors in perlobj&lt;/a&gt;.</source>
          <target state="translated">이 메소드 키워드는 &lt;a href=&quot;perlobj#Destructors&quot;&gt;perlobj의 소멸자에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c21da25dd954f9e366c6cef85d1af33e75fddf8f" translate="yes" xml:space="preserve">
          <source>This method lets you know which (or how many) tests actually failed, regardless of whether or not a TODO directive was found.</source>
          <target state="translated">이 방법을 사용하면 TODO 지시문의 발견 여부에 관계없이 실제로 실패한 테스트 (또는 몇 개)를 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2b6c5d7eeef2dcb58cd2d68cdfe40caf21f8820" translate="yes" xml:space="preserve">
          <source>This method lets you know which (or how many) tests actually passed but were declared as &quot;TODO&quot; tests.</source>
          <target state="translated">이 방법을 사용하면 실제로 통과했지만 &quot;TODO&quot;테스트로 선언 된 테스트 (또는 몇 개)를 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08a5db262046c866f7d810a5b71d8ec989df7d80" translate="yes" xml:space="preserve">
          <source>This method lets you know which (or how many) tests actually passed, regardless of whether or not a TODO directive was found.</source>
          <target state="translated">이 방법을 사용하면 TODO 지시어의 발견 여부에 관계없이 실제로 통과 한 테스트 (또는 몇 개)를 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7562f7ac693aec459c0c9b344acb705680f1f7f7" translate="yes" xml:space="preserve">
          <source>This method lets you know which (or how many) tests failed. If a test passed but had a TODO directive, it will &lt;b&gt;NOT&lt;/b&gt; be counted as a failed test.</source>
          <target state="translated">이 방법을 통해 어떤 테스트가 실패했는지 알 수 있습니다. 테스트에 통과했지만 TODO 지시문이 있으면 실패한 테스트로 계산 &lt;b&gt;되지 않습니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="b1956c9e443594eef5939e2522e06e528138f73a" translate="yes" xml:space="preserve">
          <source>This method lets you know which (or how many) tests had SKIP directives.</source>
          <target state="translated">이 방법을 사용하면 SKIP 지시문이있는 테스트 (또는 몇 개)를 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d552dee0411d16f26c2347ec73027455bcd691a0" translate="yes" xml:space="preserve">
          <source>This method lets you know which (or how many) tests had TODO directives.</source>
          <target state="translated">이 방법을 사용하면 TODO 지시문이있는 테스트 (또는 몇 개)를 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62d19246ed330e746e1fe150131f18c164bb14d2" translate="yes" xml:space="preserve">
          <source>This method lets you know which (or how many) tests passed. If a test failed but had a TODO directive, it will be counted as a passed test.</source>
          <target state="translated">이 방법을 통해 어떤 테스트가 통과했는지 알 수 있습니다. 테스트에 실패했지만 TODO 지시문이 있으면 통과 된 테스트로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="cc582265ee4f696fc9e8e3fad6147cf5023780c3" translate="yes" xml:space="preserve">
          <source>This method may be overridden by subclasses to take the appropriate action when a block of verbatim text is encountered. It is passed the following parameters:</source>
          <target state="translated">이 메소드는 서브 클래스에 의해 대체되어 완전한 텍스트 블록이있을 때 적절한 조치를 취할 수 있습니다. 다음 매개 변수가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="2ef97fe79f3074bd51a79fd7f9a20c0d8326e891" translate="yes" xml:space="preserve">
          <source>This method may be overridden by subclasses to take the appropriate action when a normal block of POD text is encountered (although the base class method will usually do what you want). It is passed the following parameters:</source>
          <target state="translated">이 메소드는 일반적인 POD 텍스트 블록이 발견 될 때 적절한 조치를 취하기 위해 서브 클래스에 의해 대체 될 수 있습니다 (기본 클래스 메소드는 일반적으로 원하는 작업을 수행하지만). 다음 매개 변수가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="f193021bd1e2803e8135ddd336589fd3fdb1031b" translate="yes" xml:space="preserve">
          <source>This method merely runs the parser and parses all of the TAP.</source>
          <target state="translated">이 방법은 파서를 실행하고 모든 TAP를 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="d5b810a222612f34da5ba09951a3a157e593734d" translate="yes" xml:space="preserve">
          <source>This method only works on Perl v5.9.4 or later.</source>
          <target state="translated">이 방법은 Perl v5.9.4 이상에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="3eb04a70399efe3a3bc64926ce7a5f07e9940d0a" translate="yes" xml:space="preserve">
          <source>This method performs any necessary cleanup for the interior-sequence. If you override this method then it is &lt;b&gt;imperative&lt;/b&gt; that you invoke the parent method from within your own method, otherwise</source>
          <target state="translated">이 방법은 내부 순서에 필요한 정리를 수행합니다. 당신이이 메소드를 오버라이드 (override)하는 경우가있다 &lt;b&gt;필수적&lt;/b&gt; 그렇지 않으면, 당신이 당신의 자신의 방법 내에서 부모의 메소드를 호출하는 것이</target>
        </trans-unit>
        <trans-unit id="714dcc55d92cf752f4b4184074298408c801245b" translate="yes" xml:space="preserve">
          <source>This method performs any necessary cleanup for the parse-tree. If you override this method then it is &lt;b&gt;imperative&lt;/b&gt; that you invoke the parent method from within your own method, otherwise</source>
          <target state="translated">이 메소드는 구문 분석 트리에 필요한 정리를 수행합니다. 당신이이 메소드를 오버라이드 (override)하는 경우가있다 &lt;b&gt;필수적&lt;/b&gt; 그렇지 않으면, 당신이 당신의 자신의 방법 내에서 부모의 메소드를 호출하는 것이</target>
        </trans-unit>
        <trans-unit id="094b13118759d86cdc1f33cdf2b7a72869820716" translate="yes" xml:space="preserve">
          <source>This method performs any necessary object initialization. It takes no arguments (other than the object instance of course, which is typically copied to a local variable named &lt;code&gt;$self&lt;/code&gt; ). If subclasses override this method then they</source>
          <target state="translated">이 방법은 필요한 객체 초기화를 수행합니다. 인수는 필요하지 않습니다 (물론 객체 인스턴스는 제외하고 일반적으로 &lt;code&gt;$self&lt;/code&gt; 라는 로컬 변수에 복사됩니다 ). 서브 클래스가이 메소드를 대체하는 경우</target>
        </trans-unit>
        <trans-unit id="1b4637e9cdcc1db5f14b9635de49858c878c102c" translate="yes" xml:space="preserve">
          <source>This method prepends the given text or parse-tree to the current parse-tree. If the first item on the parse-tree is text and the argument is also text, then the text is prepended to the first item (not added as a separate string). Otherwise the argument is added as a new string or parse-tree</source>
          <target state="translated">이 메소드는 지정된 텍스트 또는 구문 분석 트리를 현재 구문 분석 트리 앞에 추가합니다. 구문 분석 트리의 첫 번째 항목이 텍스트이고 인수도 텍스트 인 경우 텍스트는 첫 번째 항목 앞에 추가됩니다 (별도의 문자열로 추가되지 않음). 그렇지 않으면 인수가 새 문자열 또는 구문 분석 트리로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="843c78718fa264afa1695d6f64c3d712c49fd84a" translate="yes" xml:space="preserve">
          <source>This method prints the test as a string. It will probably be similar, but not necessarily identical, to the original test line. Directives are capitalized, some whitespace may be trimmed and a test number will be added if it was not present in the original line. If you need the original text of the test line, use the &lt;code&gt;raw&lt;/code&gt; method.</source>
          <target state="translated">이 방법은 테스트를 문자열로 인쇄합니다. 아마도 원래 테스트 라인과 유사하지만 반드시 동일 할 필요는 없습니다. 지시문은 대문자로 표시되고 일부 공백은 잘릴 수 있으며 원래 줄에없는 경우 테스트 번호가 추가됩니다. 테스트 라인의 원본 텍스트가 필요한 경우 &lt;code&gt;raw&lt;/code&gt; 방법을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c461db5fa5d2d546751540785c1da918e27ef9ee" translate="yes" xml:space="preserve">
          <source>This method processes an XS file and sends output to a C file. The method may be called as a function (this is the legacy interface) and will then use a singleton as invocant.</source>
          <target state="translated">이 방법은 XS 파일을 처리하고 출력을 C 파일로 보냅니다. 이 메소드는 함수 (이것은 레거시 인터페이스 임)로 호출 될 수 있으며 단일 톤을 호출자로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="443a8a4abd0996a8f53eec3622235de842b5198f" translate="yes" xml:space="preserve">
          <source>This method reconstructs the encoding object if necessary. If you need to store the state during encoding, this is where you clone your object.</source>
          <target state="translated">이 메소드는 필요한 경우 인코딩 오브젝트를 재구성합니다. 인코딩하는 동안 상태를 저장해야하는 경우 여기에서 객체를 복제합니다.</target>
        </trans-unit>
        <trans-unit id="4be2e04731b97866ee5b4ac0d1bde14c1df759bd" translate="yes" xml:space="preserve">
          <source>This method returns 0 if the object can be modified with the given operation, or 1 if not.</source>
          <target state="translated">이 메소드는 지정된 조작으로 오브젝트를 수정할 수 있으면 0을 리턴하고 그렇지 않으면 1을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="3441f0af9f59d5dc45617aeb66969ab6a0963d73" translate="yes" xml:space="preserve">
          <source>This method returns TRUE if the GP field of the GV is NULL.</source>
          <target state="translated">이 메소드는 GV의 GP 필드가 NULL 인 경우 TRUE를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d7b58df6d5a2c18121bb505720d0e804af99a7dd" translate="yes" xml:space="preserve">
          <source>This method returns a list of the currently active section headings and subheadings in the document being parsed. The list of headings returned corresponds to the most recently parsed paragraph of the input.</source>
          <target state="translated">이 메소드는 구문 분석중인 문서에서 현재 활성화 된 섹션 표제 및 하위 표제 목록을 리턴합니다. 리턴 된 표제 목록은 가장 최근에 구문 분석 된 입력의 단락에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="dfd6da7f680f7708aaaafbe88d4fbd81537fbb12" translate="yes" xml:space="preserve">
          <source>This method returns either a hash reference (in scalar context) or a list or hash references (in array context) that contains information about each of the header fields in the compressed data stream(s).</source>
          <target state="translated">이 메소드는 압축 데이터 스트림의 각 헤더 필드에 대한 정보를 포함하는 해시 참조 (스칼라 컨텍스트) 또는 목록 또는 해시 참조 (배열 컨텍스트)를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5613e8d87481a66c6331ffba3f17e879703b23af" translate="yes" xml:space="preserve">
          <source>This method returns the &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; object associated with Your::Class. It is not a constructor so you can call it as often as you like.</source>
          <target state="translated">이 메소드는 Your :: Class와 연관된 &lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt; 오브젝트를 리턴합니다 . 생성자가 아니므로 원하는만큼 자주 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6ed5af13a1529fb7b65c36511f205e560c0e629" translate="yes" xml:space="preserve">
          <source>This method returns the AV specific flags. In Perl 5.9 these are now stored in with the main SV flags, so this method is no longer present.</source>
          <target state="translated">이 메소드는 AV 특정 플래그를 리턴합니다. Perl 5.9에서는 이제 기본 SV 플래그와 함께 저장되므로이 방법은 더 이상 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="230f2b0705cb9c1bd36492ae8437541d92944923" translate="yes" xml:space="preserve">
          <source>This method returns the byte offset of the start of the &lt;code&gt;$n&lt;/code&gt; th record in the file. If there is no such record, it returns an undefined value.</source>
          <target state="translated">이 메소드는 파일에서 &lt;code&gt;$n&lt;/code&gt; 번째 레코드 시작의 바이트 오프셋을 리턴 합니다. 그러한 레코드가 없으면 정의되지 않은 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cda1e7a80b8c4ff8a50d7193bfa7f2353fb0bb3a" translate="yes" xml:space="preserve">
          <source>This method returns the internal length field, which consists of the number of internal bytes, not necessarily the number of logical characters.</source>
          <target state="translated">이 메소드는 논리 길이가 아닌 내부 바이트 수로 구성되는 내부 길이 필드를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="3195470feffd08399489b4ea58a94cbd49fb15f2" translate="yes" xml:space="preserve">
          <source>This method returns the name of the glob, but if the first character of the name is a control character, then it converts it to ^X first, so that *^G would return &quot;^G&quot; rather than &quot;\cG&quot;.</source>
          <target state="translated">이 메소드는 glob의 이름을 리턴하지만 이름의 첫 문자가 제어 문자 인 경우, ^^를 먼저 변환하여 * ^ G가 &quot;\ cG&quot;가 아닌 &quot;^ G&quot;를 리턴하도록합니다.</target>
        </trans-unit>
        <trans-unit id="d436f65e4ac4dfd0f8045b3c54271c25339bbf38" translate="yes" xml:space="preserve">
          <source>This method returns the name of the package that is the root of the compartment's namespace.</source>
          <target state="translated">이 메서드는 구획 네임 스페이스의 루트 인 패키지 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b1039ff3465ca6dc27db9b5d11bc6e35d5848fc0" translate="yes" xml:space="preserve">
          <source>This method returns the number of [a certain kind of] errors encountered during processing of the XS file.</source>
          <target state="translated">이 메소드는 XS 파일 처리 중에 발생한 [특정 종류] 오류 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="0d20c8d8462990e4c532228bf94cacc069885810" translate="yes" xml:space="preserve">
          <source>This method returns the number of bytes allocated (via malloc) for storing the string. This is 0 if the scalar does not &quot;own&quot; the string.</source>
          <target state="translated">이 메소드는 문자열을 저장하기 위해 malloc을 통해 할당 된 바이트 수를 리턴합니다. 스칼라가 문자열을 &quot;소유&quot;하지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="dc49b5d5eff536554a52d021b3411834001a3a6e" translate="yes" xml:space="preserve">
          <source>This method returns the results of the parsing, one result at a time. Note that it is destructive. You can't rewind and examine previous results.</source>
          <target state="translated">이 메소드는 구문 분석 결과를 한 번에 하나씩 결과를 리턴합니다. 파괴적입니다. 이전 결과를 되 감고 검사 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0ab9ad920897cda27f5f563bb7197ba468b33916" translate="yes" xml:space="preserve">
          <source>This method returns the textual representation of the hyperlink as above, but without markers (read only). Depending on the link type this is one of the following alternatives (the + and * denote the portions of the text that are marked up):</source>
          <target state="translated">이 메서드는 위와 같이 하이퍼 링크의 텍스트 표현을 반환하지만 마커는 없습니다 (읽기 전용). 링크 유형에 따라 다음 대안 중 하나입니다 (+ 및 *는 표시되는 텍스트 부분을 나타냄).</target>
        </trans-unit>
        <trans-unit id="59c2ab7b96065dfd63ce37b4f21c2d16dce7d68c" translate="yes" xml:space="preserve">
          <source>This method returns the value of the IV as an integer. It differs from &lt;code&gt;IV&lt;/code&gt; in that it returns the correct value regardless of whether it's stored signed or unsigned.</source>
          <target state="translated">이 메소드는 IV의 값을 정수로 리턴합니다. 서명 여부에 관계없이 올바른 값을 반환한다는 점에서 &lt;code&gt;IV&lt;/code&gt; 와 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="1569bccb9cee6a2175f9b489178e6d0824ba382b" translate="yes" xml:space="preserve">
          <source>This method sets or returns the POD page this link points to.</source>
          <target state="translated">이 메소드는이 링크가 가리키는 POD 페이지를 설정하거나 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5626475bc6df98d403b9b1a4c6d8bd8eead196ba" translate="yes" xml:space="preserve">
          <source>This method sets the size (in half-points, like 15 for 7.5-point) that the header on each page will appear in. The header is usually just &quot;</source>
          <target state="translated">이 방법은 각 페이지의 헤더가 나타날 크기 (반점, 15- 포인트는 7.5)를 설정합니다. 헤더는 일반적으로 &quot;</target>
        </trans-unit>
        <trans-unit id="49562bbb9cccfd05b2f9dd5f5c25626dc9296a99" translate="yes" xml:space="preserve">
          <source>This method sets the size (in half-points, like 21 for 10.5-point) that codeblocks (&quot;verbatim sections&quot;) will appear as.</source>
          <target state="translated">이 방법은 코드 블록 ( &quot;verbatim section&quot;)이 표시 될 크기 (10.5 포인트의 경우 21과 같은 반 포인트 단위)를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="b751a506f13c7e1535b7f83c798a478f8a346484" translate="yes" xml:space="preserve">
          <source>This method sets the size (in half-points, like 26 for 13-point) that normal paragraphic text will appear in.</source>
          <target state="translated">이 방법은 일반 단락 텍스트가 표시 될 크기 (13 포인트의 경우 26과 같은 반 포인트)를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="4a47dc314786b539ecdca5143ef23b8e1941b547" translate="yes" xml:space="preserve">
          <source>This method should</source>
          <target state="translated">이 방법은</target>
        </trans-unit>
        <trans-unit id="a1c0bdcb0359edd01294194cece7860e3da71acb" translate="yes" xml:space="preserve">
          <source>This method should be overridden by subclasses that wish to perform any kind of preprocessing for each</source>
          <target state="translated">이 메소드는 각각에 대해 모든 종류의 사전 처리를 수행하려는 서브 클래스로 대체되어야합니다.</target>
        </trans-unit>
        <trans-unit id="4045b5b845e6b96a3e7f9e9b3149fb374504376e" translate="yes" xml:space="preserve">
          <source>This method should be overridden by subclasses that wish to perform any kind of preprocessing for each block (paragraph) of POD documentation that appears in the input stream. The parameter &lt;code&gt;$text&lt;/code&gt; is the POD paragraph from the input file; and the parameter &lt;code&gt;$line_num&lt;/code&gt; is the line number for the beginning of the corresponding paragraph.</source>
          <target state="translated">이 메소드는 입력 스트림에 나타나는 POD 문서의 각 블록 (단락)에 대해 모든 종류의 사전 처리를 수행하려는 서브 클래스로 대체되어야합니다. &lt;code&gt;$text&lt;/code&gt; 매개 변수 는 입력 파일의 POD 단락입니다. &lt;code&gt;$line_num&lt;/code&gt; 매개 변수 는 해당 단락의 시작 부분에 대한 행 번호입니다.</target>
        </trans-unit>
        <trans-unit id="517b86d5501e13cc5ca0478526d9e56418238e3c" translate="yes" xml:space="preserve">
          <source>This method should be overridden by subclasses to take the appropriate action when a POD command paragraph (denoted by a line beginning with &quot;=&quot;) is encountered. When such a POD directive is seen in the input, this method is called and is passed:</source>
          <target state="translated">이 메소드는 POD 명령 단락 ( &quot;=&quot;으로 시작하는 행으로 표시됨)이 발견 될 때 적절한 조치를 취하기 위해 서브 클래스에 의해 대체되어야합니다. 이러한 POD 지시문이 입력에 표시되면이 메소드가 호출되고 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="4057fa0aee2966d0f3fb518e4370c12ff228c00a" translate="yes" xml:space="preserve">
          <source>This method should be overridden by subclasses to take the appropriate action when an interior sequence is encountered. An interior sequence is an embedded command within a block of text which appears as a command name (usually a single uppercase character) followed immediately by a string of text which is enclosed in angle brackets. This method is passed the sequence command &lt;code&gt;$seq_cmd&lt;/code&gt; and the corresponding text &lt;code&gt;$seq_arg&lt;/code&gt; . It is invoked by the &lt;b&gt;interpolate()&lt;/b&gt; method for each interior sequence that occurs in the string that it is passed. It should return the desired text string to be used in place of the interior sequence. The &lt;code&gt;$pod_seq&lt;/code&gt; argument is a reference to a &lt;code&gt;Pod::InteriorSequence&lt;/code&gt; object which contains further information about the interior sequence. Please see &lt;a href=&quot;inputobjects&quot;&gt;Pod::InputObjects&lt;/a&gt; for details if you need to access this additional information.</source>
          <target state="translated">내부 시퀀스가 ​​발생할 때 적절한 조치를 취하려면 서브 클래스로이 메소드를 대체해야합니다. 내부 시퀀스는 텍스트 블록 내에 포함 된 명령으로, 명령 이름 (대개 단일 대문자)으로 표시되고 그 뒤에 꺾쇠 괄호로 묶인 텍스트 문자열이 나타납니다. 이 메소드에는 시퀀스 명령 &lt;code&gt;$seq_cmd&lt;/code&gt; 및 해당 텍스트 &lt;code&gt;$seq_arg&lt;/code&gt; 됩니다. 전달 된 문자열에서 발생하는 각 내부 시퀀스에 대해 &lt;b&gt;interpolate ()&lt;/b&gt; 메소드에 의해 호출됩니다 . 내부 시퀀스 대신 사용할 원하는 텍스트 문자열을 반환해야합니다. &lt;code&gt;$pod_seq&lt;/code&gt; 인수는에 대한 참조입니다 &lt;code&gt;Pod::InteriorSequence&lt;/code&gt; 내부 시퀀스에 대한 추가 정보가 들어있는 객체. 이 추가 정보에 액세스해야하는 경우 자세한 내용 은 &lt;a href=&quot;inputobjects&quot;&gt;Pod :: InputObjects&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="429d3f42da5b40589bd5bfe3cdeaeea4b58f3cb7" translate="yes" xml:space="preserve">
          <source>This method takes a filename and does the following:</source>
          <target state="translated">이 방법은 파일 이름을 사용하며 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="7d455696794a1091f3f69965ce8778b043cee526" translate="yes" xml:space="preserve">
          <source>This method takes an input filehandle (which is assumed to already be opened for reading) and reads the entire input stream looking for blocks (paragraphs) of POD documentation to be processed. If no first argument is given the default input filehandle &lt;code&gt;STDIN&lt;/code&gt; is used.</source>
          <target state="translated">이 메소드는 입력 파일 핸들 (이미 읽기 위해 열린 것으로 가정)을 처리하고 처리 할 POD 문서의 블록 (단락)을 찾기 위해 전체 입력 스트림을 읽습니다. 첫 번째 인수가 제공되지 않으면 기본 입력 파일 핸들 &lt;code&gt;STDIN&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5d21cbfa9655bea409751abece40beb185c2a106" translate="yes" xml:space="preserve">
          <source>This method takes an optional parameter, &lt;code&gt;$flush_type&lt;/code&gt; , that controls how the flushing will be carried out. By default the &lt;code&gt;$flush_type&lt;/code&gt; used is &lt;code&gt;Z_FINISH&lt;/code&gt; . Other valid values for &lt;code&gt;$flush_type&lt;/code&gt; are &lt;code&gt;Z_NO_FLUSH&lt;/code&gt; , &lt;code&gt;Z_SYNC_FLUSH&lt;/code&gt; , &lt;code&gt;Z_FULL_FLUSH&lt;/code&gt; and &lt;code&gt;Z_BLOCK&lt;/code&gt; . It is strongly recommended that you only set the &lt;code&gt;flush_type&lt;/code&gt; parameter if you fully understand the implications of what it does - overuse of &lt;code&gt;flush&lt;/code&gt; can seriously degrade the level of compression achieved. See the &lt;code&gt;zlib&lt;/code&gt; documentation for details.</source>
          <target state="translated">이 메소드는 플러시 수행 방법을 제어하는 선택적 매개 변수 &lt;code&gt;$flush_type&lt;/code&gt; 을 사용합니다. 기본적으로 사용되는 &lt;code&gt;$flush_type&lt;/code&gt; 은 &lt;code&gt;Z_FINISH&lt;/code&gt; 입니다. &lt;code&gt;$flush_type&lt;/code&gt; 다른 유효한 값 은 &lt;code&gt;Z_NO_FLUSH&lt;/code&gt; , &lt;code&gt;Z_SYNC_FLUSH&lt;/code&gt; , &lt;code&gt;Z_FULL_FLUSH&lt;/code&gt; 및 &lt;code&gt;Z_BLOCK&lt;/code&gt; 입니다. &lt;code&gt;flush_type&lt;/code&gt; 매개 변수의 의미를 완전히 이해 한 경우 에만 flush_type 매개 변수를 설정하는 것이 좋습니다. &lt;code&gt;flush&lt;/code&gt; 과도 하게 사용하면 달성되는 압축 수준이 심각하게 저하 될 수 있습니다. 자세한 내용은 &lt;code&gt;zlib&lt;/code&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9a36ff48f2f3559090075d4ecd3d184fea06bced" translate="yes" xml:space="preserve">
          <source>This method takes no arguments, it has the exact same effect as invoking &amp;lt;select()&amp;gt; with no arguments.</source>
          <target state="translated">이 메소드는 인수를 사용하지 않으며 인수없이 &amp;lt;select ()&amp;gt;를 호출하는 것과 동일한 효과를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="21a6dff8df6ddbca7896a9686976cc84571da4fe" translate="yes" xml:space="preserve">
          <source>This method translates all text (including any embedded interior sequences) in the given text string &lt;code&gt;$text&lt;/code&gt; and returns the interpolated result. The parameter &lt;code&gt;$line_num&lt;/code&gt; is the line number corresponding to the beginning of &lt;code&gt;$text&lt;/code&gt; .</source>
          <target state="translated">이 메소드는 주어진 텍스트 문자열 &lt;code&gt;$text&lt;/code&gt; 모든 텍스트 (내장 된 내부 시퀀스 포함)를 번역 하고 보간 된 결과를 반환합니다. &lt;code&gt;$line_num&lt;/code&gt; 매개 변수 는 &lt;code&gt;$text&lt;/code&gt; 시작 부분에 해당하는 줄 번호 입니다.</target>
        </trans-unit>
        <trans-unit id="d98885f1731321cbbe841c4174d52925fb86ae4c" translate="yes" xml:space="preserve">
          <source>This method turns an arbitrary string into a valid XHTML ID attribute value. The rules enforced, following &lt;a href=&quot;http://webdesign.about.com/od/htmltags/a/aa031707.htm&quot;&gt;http://webdesign.about.com/od/htmltags/a/aa031707.htm&lt;/a&gt;, are:</source>
          <target state="translated">이 메소드는 임의의 문자열을 유효한 XHTML ID 속성 값으로 바꿉니다. &lt;a href=&quot;http://webdesign.about.com/od/htmltags/a/aa031707.htm&quot;&gt;http://webdesign.about.com/od/htmltags/a/aa031707.htm에&lt;/a&gt; 따라 시행되는 규칙 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5d3c6a2354f8ed5d57f49370abc6615f8bbe3512" translate="yes" xml:space="preserve">
          <source>This method used to be useful back when Test::Builder worked on Perls before 5.6 which didn't have qr//. Now its pretty useless.</source>
          <target state="translated">이 방법은 Test :: Builder가 qr //가없는 5.6 이전의 Perls에서 작동했을 때 유용했습니다. 이제는 쓸모가 없습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
