<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="b3c1ad83c7446d82ad768f4c14cbc6cf2bb28a0e" translate="yes" xml:space="preserve">
          <source>Note also that the whole range idea is rather unportable between character sets--and even within character sets they may cause results you probably didn't expect. A sound principle is to use only ranges that begin from and end at either alphabets of equal case (a-e, A-E), or digits (0-4). Anything else is unsafe. If in doubt, spell out the character sets in full.</source>
          <target state="translated">또한 전체 범위 아이디어는 문자 세트간에 이식하기가 쉽지 않으며 심지어 문자 세트에서도 예상하지 못한 결과를 초래할 수 있습니다. 올바른 원칙은 동일한 대소 문자 (ae, AE) 또는 숫자 (0-4)의 알파벳으로 시작하고 끝나는 범위 만 사용하는 것입니다. 다른 것은 안전하지 않습니다. 확실하지 않은 경우 문자 세트를 완전히 철자하십시오.</target>
        </trans-unit>
        <trans-unit id="e91fc700eef8c024136a19a3d1a25e4a4aec8312" translate="yes" xml:space="preserve">
          <source>Note also that there are some basic rules to using &quot;=over&quot; ... &quot;=back&quot; regions:</source>
          <target state="translated">&quot;= over&quot;... &quot;= back&quot;영역을 사용하기위한 몇 가지 기본 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f240a6fbb992211509f6bddbfc9324c218ab462f" translate="yes" xml:space="preserve">
          <source>Note also that this is a minimum setup; you might want to add other packages of &lt;b&gt;ADE&lt;/b&gt; (the</source>
          <target state="translated">또한 이것은 최소 설정입니다. &lt;b&gt;ADE의&lt;/b&gt; 다른 패키지를 추가 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f0a8f1a21849e70b5e894c297b75fbda2be2da8" translate="yes" xml:space="preserve">
          <source>Note also that you &lt;b&gt;must&lt;/b&gt; consider the encoded value as atomic; i.e., you should not consider it as anything but an opaque, unanalysable string value. (The internals of the encoding method may change in future versions, as the language tagging standard changes over time.)</source>
          <target state="translated">당신이 것 또한주의 &lt;b&gt;해야한다&lt;/b&gt; 원자로 인코딩 된 값을 고려; 즉, 불투명하고 분석 할 수없는 문자열 값 이외의 것으로 간주해서는 안됩니다. 언어 태그 지정 표준이 시간이 지남에 따라 변경되므로 인코딩 방법의 내부가 이후 버전에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bce497daf670728bb21a4272ea4f02098c78b3e" translate="yes" xml:space="preserve">
          <source>Note also the existence of &lt;code&gt;sv_catpvf&lt;/code&gt; and &lt;code&gt;sv_vcatpvfn&lt;/code&gt; , combining concatenation with formatting.</source>
          <target state="translated">연결과 형식화를 결합한 &lt;code&gt;sv_catpvf&lt;/code&gt; 및 &lt;code&gt;sv_vcatpvfn&lt;/code&gt; 의 존재에 유의하십시오 .</target>
        </trans-unit>
        <trans-unit id="2c03a1bb63438d075c735c239a360c45cd5c5f8e" translate="yes" xml:space="preserve">
          <source>Note especially that &lt;code&gt;$cref-&amp;gt;&amp;amp;*&lt;/code&gt; is</source>
          <target state="translated">특히 &lt;code&gt;$cref-&amp;gt;&amp;amp;*&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="329f3fa12538d44b63cb4bc769615094799f44fc" translate="yes" xml:space="preserve">
          <source>Note for BSD users: setting &lt;code&gt;$0&lt;/code&gt; does not completely remove &quot;perl&quot; from the ps(1) output. For example, setting &lt;code&gt;$0&lt;/code&gt; to &lt;code&gt;&quot;foobar&quot;&lt;/code&gt; may result in &lt;code&gt;&quot;perl: foobar (perl)&quot;&lt;/code&gt; (whether both the &lt;code&gt;&quot;perl: &quot;&lt;/code&gt; prefix and the &quot; (perl)&quot; suffix are shown depends on your exact BSD variant and version). This is an operating system feature, Perl cannot help it.</source>
          <target state="translated">BSD 사용자 참고 사항 : &lt;code&gt;$0&lt;/code&gt; 설정해도 ps (1) 출력에서 ​​&quot;perl&quot;이 완전히 제거되지는 않습니다. 예를 들어, &lt;code&gt;$0&lt;/code&gt; 을 &lt;code&gt;&quot;foobar&quot;&lt;/code&gt; 로 설정 하면 &lt;code&gt;&quot;perl: foobar (perl)&quot;&lt;/code&gt; &quot; 이 발생할 수 있습니다 ( &lt;code&gt;&quot;perl: &quot;&lt;/code&gt; 접두사와 &quot;(perl)&quot;접미사 표시 여부는 정확한 BSD 변형 및 버전에 따라 다름). 이것은 운영 체제 기능이며 Perl이이를 도울 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7293fa6262cc45f7e2dbf5481215c1d362820f1d" translate="yes" xml:space="preserve">
          <source>Note for Linux and Debian GNU/kFreeBSD users: Before Perl v5.16.0 perl would emulate POSIX semantics on Linux systems using LinuxThreads, a partial implementation of POSIX Threads that has since been superseded by the Native POSIX Thread Library (NPTL).</source>
          <target state="translated">Linux 및 Debian GNU / kFreeBSD 사용자를위한 참고 사항 : Perl v5.16.0 이전에는 perl이 NPTL (Native POSIX Thread Library)로 대체 된 POSIX 스레드의 부분 구현 인 LinuxThreads를 사용하여 Linux 시스템에서 POSIX 시맨틱을 에뮬레이트했습니다.</target>
        </trans-unit>
        <trans-unit id="7aea9b8c7cfe32358e543467b0f84f66f59444bc" translate="yes" xml:space="preserve">
          <source>Note for Linux users: Between v5.8.1 and v5.16.0 Perl would work around non-POSIX thread semantics the minority of Linux systems (and Debian GNU/kFreeBSD systems) that used LinuxThreads, this emulation has since been removed. See the documentation for &lt;a href=&quot;../perlvar#%24%24&quot;&gt;$$&lt;/a&gt; for details.</source>
          <target state="translated">Linux 사용자를위한 참고 사항 : v5.8.1과 v5.16.0 사이에서 Perl은 POSIX 이외의 스레드 의미 체계에서 LinuxThreads를 사용하는 소수의 Linux 시스템 (및 데비안 GNU / kFreeBSD 시스템)을 처리하므로이 에뮬레이션이 제거되었습니다. 자세한 내용은 &lt;a href=&quot;../perlvar#%24%24&quot;&gt;$$&lt;/a&gt; 설명서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="cbdce38416b294a5283ce0536b64d8889c65db49" translate="yes" xml:space="preserve">
          <source>Note for Linux users: Between v5.8.1 and v5.16.0 Perl would work around non-POSIX thread semantics the minority of Linux systems (and Debian GNU/kFreeBSD systems) that used LinuxThreads, this emulation has since been removed. See the documentation for &lt;a href=&quot;perlvar#%24%24&quot;&gt;$$&lt;/a&gt; for details.</source>
          <target state="translated">Linux 사용자를위한 참고 사항 : v5.8.1과 v5.16.0 사이에서 Perl은 POSIX 이외의 스레드 의미 체계에서 LinuxThreads를 사용하는 소수의 Linux 시스템 (및 데비안 GNU / kFreeBSD 시스템)을 처리하므로이 에뮬레이션이 제거되었습니다. 자세한 내용은 &lt;a href=&quot;perlvar#%24%24&quot;&gt;$$&lt;/a&gt; 설명서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="eb69bfe72361defc6ffb1f69be5dc9409ce2ae2e" translate="yes" xml:space="preserve">
          <source>Note how the first and last entries are protected by quotes in order to protect the spaces.</source>
          <target state="translated">공백을 보호하기 위해 첫 번째 항목과 마지막 항목을 따옴표로 보호하는 방법에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="b9400fb5715aebae33791834189bda7b7f0594aa" translate="yes" xml:space="preserve">
          <source>Note how the last three examples in the table above are treated specially by the parser. &lt;code&gt;mygrep()&lt;/code&gt; is parsed as a true list operator, &lt;code&gt;myrand()&lt;/code&gt; is parsed as a true unary operator with unary precedence the same as &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;mytime()&lt;/code&gt; is truly without arguments, just like &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt;. That is, if you say</source>
          <target state="translated">위 표의 마지막 세 가지 예가 구문 분석기에 의해 특별히 처리되는 방식에 유의하십시오. &lt;code&gt;mygrep()&lt;/code&gt; 실제리스트 연산자로 구문 분석, &lt;code&gt;myrand()&lt;/code&gt; 단항 우선 순위와 같은과 진정한 단항 연산자로 해석됩니다 &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; ,과 &lt;code&gt;mytime()&lt;/code&gt; 단지 같은 인수없이 진정으로 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; . 즉, 당신이 말하면</target>
        </trans-unit>
        <trans-unit id="32d61faf03809511f3cea1cbe82aa61f0b9ca92a" translate="yes" xml:space="preserve">
          <source>Note how we load the user pragma &lt;code&gt;myint&lt;/code&gt; with an empty list &lt;code&gt;()&lt;/code&gt; to prevent its &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; being called.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 가 호출 되지 않도록 사용자 pragma &lt;code&gt;myint&lt;/code&gt; 를 빈 목록 &lt;code&gt;()&lt;/code&gt; 으로 로드하는 방법에 유의하십시오 .</target>
        </trans-unit>
        <trans-unit id="25c06a27ee940fb1ce392065b6dccdd03fd73088" translate="yes" xml:space="preserve">
          <source>Note however that some built-ins can't have their syntax expressed by a prototype (such as &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt;). If you override them you won't be able to fully mimic their original syntax.</source>
          <target state="translated">그러나 일부 내장 기능은 프로토 타입 ( &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt; 등)으로 표현 된 구문을 가질 수 없습니다 . 그것들을 재정의하면 원래 구문을 완전히 모방 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="210da70db6283ccd39e5584b10f4c87c0f89d9d6" translate="yes" xml:space="preserve">
          <source>Note however that to use some of these operators you need to have a sh-syntax shell installed (see &lt;a href=&quot;#Pdksh&quot;&gt;Pdksh&lt;/a&gt;, &lt;a href=&quot;#Frequently-asked-questions&quot;&gt;Frequently asked questions&lt;/a&gt;), and perl should be able to find it (see &lt;a href=&quot;#PERL_SH_DIR&quot;&gt;PERL_SH_DIR&lt;/a&gt;).</source>
          <target state="translated">그러나이 연산자 중 일부를 사용하려면 sh-syntax shell이 ​​설치되어 있어야하고 ( &lt;a href=&quot;#Pdksh&quot;&gt;Pdksh&lt;/a&gt; , &lt;a href=&quot;#Frequently-asked-questions&quot;&gt;자주 묻는 질문 참조&lt;/a&gt; ) perl &lt;a href=&quot;#PERL_SH_DIR&quot;&gt;이이&lt;/a&gt; 를 찾을 수 있어야합니다 ( PERL_SH_DIR 참조 ).</target>
        </trans-unit>
        <trans-unit id="6cd6d4fe1827d7816f9b8f3e1b0034bce7c56311" translate="yes" xml:space="preserve">
          <source>Note however, that this function does an exact match using &lt;code&gt;eq&lt;/code&gt; on the full path. So it cannot compensate for case-insensitive file- systems or compare 2 paths to see if they would point to the same underlying file.</source>
          <target state="translated">그러나이 함수는 전체 경로에서 &lt;code&gt;eq&lt;/code&gt; 를 사용하여 정확하게 일치 합니다. 따라서 대소 문자를 구분하지 않는 파일 시스템을 보완하거나 2 개의 경로를 비교하여 동일한 기본 파일을 가리키는 지 확인할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e19273a97b7ee5052886f577d9a46a4421684819" translate="yes" xml:space="preserve">
          <source>Note however, that you need to have</source>
          <target state="translated">그러나, 당신은 가지고 있어야합니다</target>
        </trans-unit>
        <trans-unit id="507e6816311ba5923485459a746f4c205372d3f9" translate="yes" xml:space="preserve">
          <source>Note if you specify &lt;code&gt;-&lt;/code&gt; as the command, in an analogous fashion to &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;(FOO, &quot;-|&quot;)&lt;/code&gt; the child process will just be the forked Perl process rather than an external command. This feature isn't yet supported on Win32 platforms.</source>
          <target state="translated">지정하면 주 &lt;code&gt;-&lt;/code&gt; 명령으로, 유사한 방식으로 &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;(FOO, &quot;-|&quot;)&lt;/code&gt; 자식 프로세스 그냥 갈래 펄 처리가 아닌 외부 명령이 될 것입니다. 이 기능은 아직 Win32 플랫폼에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="da9342b413d4bbcd1dc6fe59e3ee28645b823224" translate="yes" xml:space="preserve">
          <source>Note in the last example, the end of the string is considered a word boundary.</source>
          <target state="translated">마지막 예에서 문자열의 끝은 단어 경계로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="07e19a6ca0b876d2709ab0ec0dfc79383c491dc1" translate="yes" xml:space="preserve">
          <source>Note on ISO-2022-JP(-1)?</source>
          <target state="translated">ISO-2022-JP (-1)에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="b88ed054c638a5f7768e2dd282a5e1b35bab783a" translate="yes" xml:space="preserve">
          <source>Note on Step 7: some operators have a different semantic depending on the type of their operands. As there is no way to instruct Perl to treat the operands as, e.g., numbers instead of strings, the result here may not be what you expect. See &lt;a href=&quot;#BUGS-AND-PITFALLS&quot;&gt;BUGS AND PITFALLS&lt;/a&gt;.</source>
          <target state="translated">7 단계 참고 사항 : 일부 연산자는 피연산자의 유형에 따라 다른 의미를 갖습니다. 예를 들어 문자열 대신 숫자로 피연산자를 처리하도록 Perl에 지시 할 수있는 방법이 없으므로 여기서 결과가 예상과 다를 수 있습니다. &lt;a href=&quot;#BUGS-AND-PITFALLS&quot;&gt;버그와 함정을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="15bc1023efea2381a2db802c419cf3e98569e03f" translate="yes" xml:space="preserve">
          <source>Note on the format of the urllist parameter</source>
          <target state="translated">urllist 매개 변수의 형식에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="cc738b8cb2fe5493887c63f096423e4e822a4785" translate="yes" xml:space="preserve">
          <source>Note particularly that $x continues to refer to the value passed into newprint()</source>
          <target state="translated">특히 $ x는 newprint ()에 전달 된 값을 계속 참조합니다.</target>
        </trans-unit>
        <trans-unit id="977ff75717e2ad5549c27c1fec3fb1a8727cd2e9" translate="yes" xml:space="preserve">
          <source>Note several important features of this example. First of all, the</source>
          <target state="translated">이 예제의 몇 가지 중요한 기능에 유의하십시오. 우선,</target>
        </trans-unit>
        <trans-unit id="99e506d24bb1d2d8c0953ced78837622f6175e3d" translate="yes" xml:space="preserve">
          <source>Note that &quot;&amp;lt;&amp;amp;STDIN&quot; makes a copy, but &quot;&amp;lt;&amp;amp;=STDIN&quot; makes an alias. That means if you close an aliased handle, all aliases become inaccessible. This is not true with a copied one.</source>
          <target state="translated">&quot;&amp;lt;&amp;amp; STDIN&quot;은 복사본을 만들지 만 &quot;&amp;lt;&amp;amp; = STDIN&quot;은 별칭을 만듭니다. 즉, 별칭 처리 된 핸들을 닫으면 모든 별칭에 액세스 할 수 없게됩니다. 이것은 복사 된 것은 사실이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="760e35c71509b97a49875e6fc164a9d4be791312" translate="yes" xml:space="preserve">
          <source>Note that $x is still printed as having its true non-integer value of 5.8 since it wasn't operated on. And note too the wrap-around from the largest positive integer to the largest negative one. Also, arguments passed to functions and the values returned by them are &lt;b&gt;not&lt;/b&gt; affected by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; . E.g.,</source>
          <target state="translated">$ x는 여전히 정수가 아닌 5.8의 값으로 작동하지 않았으므로 여전히 인쇄됩니다. 그리고 가장 큰 양의 정수에서 가장 큰 음의 정수로의 랩 어라운드도 주목하십시오. 또한 함수에 전달 된 인수와 그에 의해 반환되는 값은 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용의&lt;/a&gt; 영향을받지 &lt;b&gt;않습니다 &lt;/b&gt;. . 예 :</target>
        </trans-unit>
        <trans-unit id="e599f385e86c967c815cb5ac633fbf5c8b743e32" translate="yes" xml:space="preserve">
          <source>Note that &amp;lt;FILE&amp;gt; is</source>
          <target state="translated">&amp;lt;FILE&amp;gt;은</target>
        </trans-unit>
        <trans-unit id="f28b0b3d67592306ce241a091fd7fa4b9b9390b5" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#make_iterator&quot;&gt;make_iterator&lt;/a&gt; has been</source>
          <target state="translated">참고 &lt;a href=&quot;#make_iterator&quot;&gt;make_iterator가&lt;/a&gt; 있다</target>
        </trans-unit>
        <trans-unit id="d5449cbba5d5e7a82db88f55e4440d98e4342ea0" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../dynaloader&quot;&gt;DynaLoader&lt;/a&gt; is a special case where it must call &lt;code&gt;boot_DynaLoader&lt;/code&gt; directly.</source>
          <target state="translated">참고 것을 &lt;a href=&quot;../dynaloader&quot;&gt;DynaLoader는&lt;/a&gt; 그것을 호출해야합니다 특별한 케이스입니다 &lt;code&gt;boot_DynaLoader&lt;/code&gt; 을 직접.</target>
        </trans-unit>
        <trans-unit id="d2b414b3045e4a13e62684509b81beee13f1a03b" translate="yes" xml:space="preserve">
          <source>Note that &lt;b&gt;-S&lt;/b&gt; switch supports scripts with additional extensions</source>
          <target state="translated">참고 &lt;b&gt;-S&lt;/b&gt; 추가 확장과 스위치가 지원하는 스크립트</target>
        </trans-unit>
        <trans-unit id="df5cabe56a3fab1a8dfd7142a90c482f8fae0efd" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; has lower priority than relational operators, so for example the parentheses are essential in a test like</source>
          <target state="translated">하는 것으로는 &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; 그래서 예를 들어 괄호 같은 시험에 필수적이다, 관계 연산자보다 우선 순위가</target>
        </trans-unit>
        <trans-unit id="522782427bfce1d8f14995dfc30aaa97199ffa5d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&quot;ADFS::HardDisk.$.File&quot; ne 'ADFS::HardDisk.$.File'&lt;/code&gt; and that the second stage of &lt;code&gt;$&lt;/code&gt; interpolation in regular expressions will fall foul of the &lt;code&gt;$.&lt;/code&gt; if scripts are not careful.</source>
          <target state="translated">참고 &lt;code&gt;&quot;ADFS::HardDisk.$.File&quot; ne 'ADFS::HardDisk.$.File'&lt;/code&gt; 과의 두 번째 단계 것을 &lt;code&gt;$&lt;/code&gt; 정규식에서 보간 파울의 떨어질 것이다 &lt;code&gt;$.&lt;/code&gt; 스크립트가주의하지 않으면</target>
        </trans-unit>
        <trans-unit id="12ecea42a6af74c63b7121532319090437ea634b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&quot;|&quot;&lt;/code&gt; and &lt;code&gt;&quot;^&quot;&lt;/code&gt; have lower priority than relational operators, so for example the parentheses are essential in a test like</source>
          <target state="translated">참고 &lt;code&gt;&quot;|&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;^&quot;&lt;/code&gt; 그래서 예를 들어 괄호 같은 시험에 필수적이다, 관계 연산자보다 우선 순위가</target>
        </trans-unit>
        <trans-unit id="79eafdbed824b09455353e30518fbddb877197c5" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$_&lt;/code&gt; is an alias to the list value, so it can be used to modify the elements of the LIST. While this is useful and supported, it can cause bizarre results if the elements of LIST are not variables. Similarly, grep returns aliases into the original list, much as a for loop's index variable aliases the list elements. That is, modifying an element of a list returned by grep (for example, in a &lt;code&gt;foreach&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; or another &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt;) actually modifies the element in the original list. This is usually something to be avoided when writing clear code.</source>
          <target state="translated">참고 것을 &lt;code&gt;$_&lt;/code&gt; 이 목록의 요소를 수정하는 데 사용할 수 있도록 목록 값의 별칭입니다. 이것이 유용하고 지원되지만 LIST의 요소가 변수가 아닌 경우 기괴한 결과가 발생할 수 있습니다. 마찬가지로 grep은 for 루프의 인덱스 변수가 목록 요소를 별칭으로 지정하는 것처럼 별칭을 원래 목록으로 반환합니다. 즉, grep에서 리턴 한 목록의 요소 (예 : &lt;code&gt;foreach&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 또는 다른 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; )를 수정하면 실제로 원래 목록의 요소가 수정됩니다. 이것은 일반적으로 명확한 코드를 작성할 때 피해야 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="922c04cd95d993e5139c2b97058698400e67f636" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$_&lt;/code&gt; is an alias to the list value, so it can be used to modify the elements of the LIST. While this is useful and supported, it can cause bizarre results if the elements of LIST are not variables. Similarly, grep returns aliases into the original list, much as a for loop's index variable aliases the list elements. That is, modifying an element of a list returned by grep (for example, in a &lt;code&gt;foreach&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; or another &lt;code&gt;&lt;a href=&quot;grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt;) actually modifies the element in the original list. This is usually something to be avoided when writing clear code.</source>
          <target state="translated">참고 것을 &lt;code&gt;$_&lt;/code&gt; 이 목록의 요소를 수정하는 데 사용할 수 있도록 목록 값의 별칭입니다. 이것이 유용하고 지원되지만 LIST의 요소가 변수가 아닌 경우 기괴한 결과가 발생할 수 있습니다. 마찬가지로 grep은 for 루프의 인덱스 변수가 목록 요소를 별칭으로 지정하는 것처럼 별칭을 원래 목록으로 반환합니다. 즉, grep에서 리턴 한 목록의 요소 (예 : &lt;code&gt;foreach&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 또는 다른 &lt;code&gt;&lt;a href=&quot;grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; )를 수정하면 실제로 원래 목록의 요소가 수정됩니다. 이것은 일반적으로 명확한 코드를 작성할 때 피해야 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="ea689de74e82f416fbcbf4ee9e4cea8733686d01" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$_&lt;/code&gt; is an alias to the list value, so it can be used to modify the elements of the LIST. While this is useful and supported, it can cause bizarre results if the elements of LIST are not variables. Using a regular &lt;code&gt;foreach&lt;/code&gt; loop for this purpose would be clearer in most cases. See also &lt;a href=&quot;#grep&quot;&gt;grep&lt;/a&gt; for an array composed of those items of the original list for which the BLOCK or EXPR evaluates to true.</source>
          <target state="translated">참고 것을 &lt;code&gt;$_&lt;/code&gt; 이 목록의 요소를 수정하는 데 사용할 수 있도록 목록 값의 별칭입니다. 이것이 유용하고 지원되지만 LIST의 요소가 변수가 아닌 경우 기괴한 결과가 발생할 수 있습니다. 이 목적 으로 규칙적인 &lt;code&gt;foreach&lt;/code&gt; 루프를 사용하는 것이 대부분 더 명확합니다. BLOCK 또는 EXPR이 true로 평가되는 원래 목록의 해당 항목으로 구성된 배열에 대해서는 &lt;a href=&quot;#grep&quot;&gt;grep&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e54794d0f40f1a8695668c788a3a5c6d8b245de4" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$_&lt;/code&gt; is an alias to the list value, so it can be used to modify the elements of the LIST. While this is useful and supported, it can cause bizarre results if the elements of LIST are not variables. Using a regular &lt;code&gt;foreach&lt;/code&gt; loop for this purpose would be clearer in most cases. See also &lt;a href=&quot;grep&quot;&gt;grep&lt;/a&gt; for an array composed of those items of the original list for which the BLOCK or EXPR evaluates to true.</source>
          <target state="translated">참고 것을 &lt;code&gt;$_&lt;/code&gt; 이 목록의 요소를 수정하는 데 사용할 수 있도록 목록 값의 별칭입니다. 이것이 유용하고 지원되지만 LIST의 요소가 변수가 아닌 경우 기괴한 결과가 발생할 수 있습니다. 이 목적 으로 규칙적인 &lt;code&gt;foreach&lt;/code&gt; 루프를 사용하는 것이 대부분 더 명확합니다. BLOCK 또는 EXPR이 true로 평가되는 원래 목록의 해당 항목으로 구성된 배열에 대해서는 &lt;a href=&quot;grep&quot;&gt;grep&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff224648e7f90554d343ed0de97c9efcc8456e37" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$processed&lt;/code&gt; may be empty (when &lt;code&gt;$normalized&lt;/code&gt; contains no starter or starts with the last starter), and then &lt;code&gt;$unprocessed&lt;/code&gt; should be equal to the entire &lt;code&gt;$normalized&lt;/code&gt; .</source>
          <target state="translated">참고 &lt;code&gt;$processed&lt;/code&gt; (비어있을 수있다 &lt;code&gt;$normalized&lt;/code&gt; 후, 마지막에는 스타터 시동 또는 시작을 포함하지 않는다), 및 &lt;code&gt;$unprocessed&lt;/code&gt; 전체 같아야 &lt;code&gt;$normalized&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd002d9c23fd4dcc51fd0e853c891c09f321ec46" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;-s/a/b/&lt;/code&gt; does not do a negated substitution. Saying &lt;code&gt;-&lt;a href=&quot;exp&quot;&gt;exp&lt;/a&gt;($foo)&lt;/code&gt; still works as expected, however: only single letters following a minus are interpreted as file tests.</source>
          <target state="translated">참고 &lt;code&gt;-s/a/b/&lt;/code&gt; 부정 된 대체하지 않습니다. 말하는 &lt;code&gt;-&lt;a href=&quot;exp&quot;&gt;exp&lt;/a&gt;($foo)&lt;/code&gt; 예상대로 여전히 작동하지만 : 마이너스를 다음 단 하나의 문자가 파일 테스트로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="dd375a04334c45f998942d7896c30f702e8152ff" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;-s/a/b/&lt;/code&gt; does not do a negated substitution. Saying &lt;code&gt;-&lt;a href=&quot;functions/exp&quot;&gt;exp&lt;/a&gt;($foo)&lt;/code&gt; still works as expected, however: only single letters following a minus are interpreted as file tests.</source>
          <target state="translated">참고 &lt;code&gt;-s/a/b/&lt;/code&gt; 부정 된 대체하지 않습니다. 말하는 &lt;code&gt;-&lt;a href=&quot;functions/exp&quot;&gt;exp&lt;/a&gt;($foo)&lt;/code&gt; 예상대로 여전히 작동하지만 : 마이너스를 다음 단 하나의 문자가 파일 테스트로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="48bc3a755225cb163af628efdd36b7e99bf599a7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;:constants256&lt;/code&gt; does not include the other constants, so if you want to mix both, you need to include &lt;code&gt;:constants&lt;/code&gt; as well. You may want to explicitly import at least &lt;code&gt;RESET&lt;/code&gt; , as in:</source>
          <target state="translated">참고 &lt;code&gt;:constants256&lt;/code&gt; 당신이 둘을 혼합하려는 경우 그래서, 당신은 포함해야, 다른 상수를 포함하지 않는 &lt;code&gt;:constants&lt;/code&gt; 물론. 다음 과 같이 명시 적으로 적어도 &lt;code&gt;RESET&lt;/code&gt; 을 가져와야 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f3a3c31d64bd9d3852dee2165f0cdbe3c7fd1617" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;../../functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; are the totals of the wait and exit statuses of each of the tests. These values are totalled only to provide a true value if any of them are non-zero.</source>
          <target state="translated">하는 것으로 &lt;code&gt;&lt;a href=&quot;../../functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../../functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; 각 테스트의 대기 종료 상태의 합계입니다. 이 값은 0이 아닌 경우에만 실제 값을 제공하기 위해 합계됩니다.</target>
        </trans-unit>
        <trans-unit id="9173a2f0f306c97db5af943fc6a5b25c88ebded1" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; are not listed above. If called as methods on a Time::Piece object, they act as constructors, returning a new Time::Piece object for the current time. In other words: they're not useful as methods.</source>
          <target state="translated">주의 &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 하고 &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; 은 위에 나열되지 않습니다. Time :: Piece 객체에서 메서드로 호출되면 생성자 역할을하여 현재 시간에 대한 새로운 Time :: Piece 객체를 반환합니다. 다시 말해, 그들은 방법으로 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9ce1c937ab3425a64de9dbc02778e5245a104b13" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; returns the last character. To return all but the last character, use &lt;code&gt;&lt;a href=&quot;substr&quot;&gt;substr&lt;/a&gt;($string, 0, -1)&lt;/code&gt; .</source>
          <target state="translated">참고 &lt;code&gt;&lt;a href=&quot;chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; 반환에게 마지막 문자를. 마지막 문자를 제외한 모든 문자를 반환하려면 &lt;code&gt;&lt;a href=&quot;substr&quot;&gt;substr&lt;/a&gt;($string, 0, -1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37ddc1b7985e6cde1bfecc807084dd2439da4505" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; will not call your &lt;code&gt;END&lt;/code&gt; blocks, nor will it invoke &lt;code&gt;DESTROY&lt;/code&gt; methods on your objects.</source>
          <target state="translated">참고 &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 당신의 전화를하지 않습니다 &lt;code&gt;END&lt;/code&gt; 의 블록 않으며 호출합니다 &lt;code&gt;DESTROY&lt;/code&gt; 의 오브젝트의 메소드를.</target>
        </trans-unit>
        <trans-unit id="a60dfdd6e65097f6c305737073a8bc35fe255a7e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; raises an exception if used on a machine that doesn't implement fcntl(2). See the Fcntl module or your fcntl(2) manpage to learn what functions are available on your system.</source>
          <target state="translated">양해 &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; 은 fcntl (2)를 구현하지 않는 컴퓨터에서 사용하는 경우 예외를 발생시킵니다. 시스템에서 어떤 기능을 사용할 수 있는지 알아 보려면 Fcntl 모듈 또는 fcntl (2) 맨 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="dfb2038f7135091071546cb9a6d373bb9a56e94d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; is generally not necessary when using normal filehandles; it is provided so that you can control I/O to existing record-structured files when necessary. You can also use the &lt;code&gt;vmsfopen&lt;/code&gt; function in the VMS::Stdio extension to gain finer control of I/O to files and devices with different record structures.</source>
          <target state="translated">참고 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 정상 파일 핸들을 사용하는 경우 일반적으로 필요하지 않습니다; 필요한 경우 기존 레코드 구조 파일에 대한 I / O를 제어 할 수 있도록 제공됩니다. VMS :: Stdio 확장에서 &lt;code&gt;vmsfopen&lt;/code&gt; 기능을 사용하여 레코드 구조가 다른 파일 및 장치에 대한 I / O를보다 세밀하게 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb9b28a9d5d46f3c748ef4753fd4b0b26da11633" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; returns the last character. To return all but the last character, use &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;($string, 0, -1)&lt;/code&gt; .</source>
          <target state="translated">참고 &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; 반환에게 마지막 문자를. 마지막 문자를 제외한 모든 문자를 반환하려면 &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;($string, 0, -1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2886ca2fd4621ed375e17bc5caf418ae86a77d6" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; will not call your &lt;code&gt;END&lt;/code&gt; blocks, nor will it invoke &lt;code&gt;DESTROY&lt;/code&gt; methods on your objects.</source>
          <target state="translated">참고 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 당신의 전화를하지 않습니다 &lt;code&gt;END&lt;/code&gt; 의 블록 않으며 호출합니다 &lt;code&gt;DESTROY&lt;/code&gt; 의 오브젝트의 메소드를.</target>
        </trans-unit>
        <trans-unit id="f249c4d8b204567737cd31f8ec07948c8d5ac294" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; raises an exception if used on a machine that doesn't implement fcntl(2). See the Fcntl module or your fcntl(2) manpage to learn what functions are available on your system.</source>
          <target state="translated">양해 &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; 은 fcntl (2)를 구현하지 않는 컴퓨터에서 사용하는 경우 예외를 발생시킵니다. 시스템에서 어떤 기능을 사용할 수 있는지 알아 보려면 Fcntl 모듈 또는 fcntl (2) 맨 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d7d9c1784c1fe9a279665a4571e3c21c04751dcb" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; splits its arguments on whitespace and treats each segment as separate pattern. As such, &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;(&quot;*.c *.h&quot;)&lt;/code&gt; matches all files with a</source>
          <target state="translated">참고 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 공백 및 취급에 별도의 패턴으로 각 세그먼트를 인수 분할합니다. 따라서 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;(&quot;*.c *.h&quot;)&lt;/code&gt; 는 모든 파일과 a</target>
        </trans-unit>
        <trans-unit id="dd0f76b7382c19ee434e95709a48f61a31e19d7a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -9&lt;/code&gt; does not work with the current version of EMX.</source>
          <target state="translated">참고 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -9&lt;/code&gt; EMX의 현재 버전에서 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d132135000cd2c7bd9f4aab4e6bdef7ae41bf7a4" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; depends on the fdopen() C library function. On many Unix systems, fdopen() is known to fail when file descriptors exceed a certain value, typically 255. If you need more file descriptors than that, consider using the POSIX::open() function.</source>
          <target state="translated">참고 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 가 fdopen () C 라이브러리 기능에 따라 달라집니다. 많은 Unix 시스템에서 파일 디스크립터가 특정 값 (일반적으로 255)을 초과하면 fdopen ()이 실패하는 것으로 알려져 있습니다. 그보다 많은 파일 디스크립터가 필요한 경우 POSIX :: open () 함수 사용을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="967dccf72de487894a0bc580911ae2819ad24053" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; does &lt;b&gt;not&lt;/b&gt; do regular expression character classes such as &lt;code&gt;\d&lt;/code&gt; or &lt;code&gt;\pL&lt;/code&gt; . The &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; operator is not equivalent to the &lt;code&gt;&lt;i&gt;tr(1)&lt;/i&gt;&lt;/code&gt; utility. If you want to map strings between lower/upper cases, see &lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt; and &lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;, and in general consider using the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; operator if you need regular expressions. The &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , and &lt;code&gt;\l&lt;/code&gt; string-interpolation escapes on the right side of a substitution operator will perform correct case-mappings, but &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr[a-z][A-Z]&lt;/a&gt;&lt;/code&gt; will not (except sometimes on legacy 7-bit data).</source>
          <target state="translated">참고 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; 않습니다 &lt;b&gt;하지&lt;/b&gt; 같은 정규 표현식 문자 클래스를 할 &lt;code&gt;\d&lt;/code&gt; 또는 &lt;code&gt;\pL&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; 운영자는 일치하지 않는 &lt;code&gt;&lt;i&gt;tr(1)&lt;/i&gt;&lt;/code&gt; 유틸리티. 소문자 / 대문자간에 문자열을 매핑하려면 &lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt; 및 &lt;a href=&quot;functions/uc&quot;&gt;uc를&lt;/a&gt; 참조 하고 일반적 으로 정규식이 필요한 경우 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 연산자 사용을 고려하십시오 . &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; 및 &lt;code&gt;\l&lt;/code&gt; 치환 연산자 오른쪽 문자열 보간 탈출 정확한 대소 매핑을 수행 할 것이지만 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr[a-z][A-Z]&lt;/a&gt;&lt;/code&gt; 레거시 7 비트 데이터를 제외하고는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a25e1352e6c84bdaa3b67f15d7d22519e3dc2fd" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;\U&lt;/code&gt; in interpolated strings, translates to uppercase, while &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;\u&lt;/code&gt; in interpolated strings, translates to titlecase in languages that make the distinction (which is equivalent to uppercase in languages without the distinction).</source>
          <target state="translated">참고는 &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;\U&lt;/code&gt; 보간 문자열에가 대문자로 변환 한 상태 &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;\u&lt;/code&gt; 보간 된 문자열의 (구별없이 언어 자로 상당)을 구분하는 언어는 타이틀 케이스로 변환한다.</target>
        </trans-unit>
        <trans-unit id="f7309bf49e0287f1d8c15ab22ef310f10a5d4bd7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; splits its arguments on whitespace and treats each segment as separate pattern. As such, &lt;code&gt;&lt;a href=&quot;glob&quot;&gt;glob&lt;/a&gt;(&quot;*.c *.h&quot;)&lt;/code&gt; matches all files with a</source>
          <target state="translated">참고 &lt;code&gt;&lt;a href=&quot;glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 공백 및 취급에 별도의 패턴으로 각 세그먼트를 인수 분할합니다. 따라서 &lt;code&gt;&lt;a href=&quot;glob&quot;&gt;glob&lt;/a&gt;(&quot;*.c *.h&quot;)&lt;/code&gt; 는 모든 파일과 a</target>
        </trans-unit>
        <trans-unit id="986549b394dff5a5a4195bbc3a0e0761106da86b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; depends on the fdopen() C library function. On many Unix systems, fdopen() is known to fail when file descriptors exceed a certain value, typically 255. If you need more file descriptors than that, consider using the POSIX::open() function.</source>
          <target state="translated">참고 &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 가 fdopen () C 라이브러리 기능에 따라 달라집니다. 많은 Unix 시스템에서 파일 디스크립터가 특정 값 (일반적으로 255)을 초과하면 fdopen ()이 실패하는 것으로 알려져 있습니다. 그보다 많은 파일 디스크립터가 필요한 경우 POSIX :: open () 함수 사용을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="79f5400ae4c62646c847435cddda21b4c40e3a93" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Dump&lt;/code&gt; will not report</source>
          <target state="translated">참고 &lt;code&gt;Dump&lt;/code&gt; 보고하지 않습니다</target>
        </trans-unit>
        <trans-unit id="14efce4f98a6d3ded52ecf9f7ef2c0c61f9e5d1c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;END&lt;/code&gt; code blocks are &lt;b&gt;not&lt;/b&gt; executed at the end of a string &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;: if any &lt;code&gt;END&lt;/code&gt; code blocks are created in a string &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;, they will be executed just as any other &lt;code&gt;END&lt;/code&gt; code block of that package in LIFO order just before the interpreter is being exited.</source>
          <target state="translated">참고 &lt;code&gt;END&lt;/code&gt; 의 코드 블록이되어 &lt;b&gt;있지&lt;/b&gt; 문자열의 끝에서 실행 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; : 어떤 경우 &lt;code&gt;END&lt;/code&gt; 의 코드 블록은 문자열에서 만든 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; , 그들은 다른처럼 실행됩니다 &lt;code&gt;END&lt;/code&gt; LIFO 순서 그냥 해당 패키지의 코드 블록 통역사가 종료되기 전에.</target>
        </trans-unit>
        <trans-unit id="6b4c9a20647174655acdade54ceb924854974320" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Math::BigFloat-&amp;gt;accuracy()&lt;/code&gt; and &lt;code&gt;Math::BigFloat-&amp;gt;precision()&lt;/code&gt; set the global variables, and thus &lt;b&gt;any&lt;/b&gt; newly created number will be subject to the global rounding &lt;b&gt;immediately&lt;/b&gt;. This means that in the examples above, the &lt;code&gt;3&lt;/code&gt; as argument to &lt;code&gt;bdiv()&lt;/code&gt; will also get an accuracy of &lt;b&gt;5&lt;/b&gt;.</source>
          <target state="translated">참고 &lt;code&gt;Math::BigFloat-&amp;gt;accuracy()&lt;/code&gt; 및 &lt;code&gt;Math::BigFloat-&amp;gt;precision()&lt;/code&gt; 전역 변수를 설정하고, 따라서 &lt;b&gt;어떤&lt;/b&gt; 새로 생성 된 번호가 글로벌 반올림 대상이 될 것입니다 &lt;b&gt;즉시&lt;/b&gt; . 이것은 위의 예제 에서 &lt;code&gt;bdiv()&lt;/code&gt; 인수 인 &lt;code&gt;3&lt;/code&gt; 도 &lt;b&gt;5&lt;/b&gt; 의 정확도를 얻음을 의미합니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d2356c11b794082befde64b563384a96e7b0173c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;NULL&lt;/code&gt; is a valid &lt;code&gt;proto&lt;/code&gt; and will always return &lt;code&gt;true&lt;/code&gt; .</source>
          <target state="translated">참고 &lt;code&gt;NULL&lt;/code&gt; 이 유효하다 &lt;code&gt;proto&lt;/code&gt; 항상 반환 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb94a8fcace7106b0c7ce3250a66c0e461c261b7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;STDERR&lt;/code&gt; WILL NOT be changed, regardless.</source>
          <target state="translated">참고 &lt;code&gt;STDERR&lt;/code&gt; 는 관계없이 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3dc8a38e3cc3af9d760a1ed60a8a353aa279d10b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;TAP::Parser&lt;/code&gt; is designed to be the central &quot;maker&quot; - ie: it is responsible for creating most new objects in the &lt;code&gt;TAP::Parser::*&lt;/code&gt; namespace.</source>
          <target state="translated">참고 &lt;code&gt;TAP::Parser&lt;/code&gt; 는 대부분의 새로운 개체를 만드는 책임이있다 : 즉, - 중앙 &quot;메이커&quot;를 수 있도록 설계되었습니다 &lt;code&gt;TAP::Parser::*&lt;/code&gt; 네임 스페이스.</target>
        </trans-unit>
        <trans-unit id="e4f8d4428f9f4403397e153eb6c9a469d63599ed" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;UNIVERSAL&lt;/code&gt; (and any members of &lt;code&gt;UNIVERSAL&lt;/code&gt; 's MRO) are not part of the MRO of a class, even though all classes implicitly inherit methods from &lt;code&gt;UNIVERSAL&lt;/code&gt; and its parents.</source>
          <target state="translated">참고 &lt;code&gt;UNIVERSAL&lt;/code&gt; (그리고 모든 회원 &lt;code&gt;UNIVERSAL&lt;/code&gt; 의 MRO)이, 클래스의 MRO의 일부가 아닌 경우에도 암시 적으로 모든 클래스에서 상속 방법하지만 &lt;code&gt;UNIVERSAL&lt;/code&gt; 과 그 부모.</target>
        </trans-unit>
        <trans-unit id="40891c11dca9d7b7c3291116c4d74a2cf45b3046" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\N&lt;/code&gt; has two meanings. When of the form &lt;code&gt;\N{NAME}&lt;/code&gt; , it matches the character or character sequence whose name is &lt;code&gt;NAME&lt;/code&gt; ; and similarly when of the form &lt;code&gt;\N{U+&lt;i&gt;hex&lt;/i&gt;}&lt;/code&gt;, it matches the character whose Unicode code point is</source>
          <target state="translated">참고 &lt;code&gt;\N&lt;/code&gt; 두 가지 의미를 갖는다. &lt;code&gt;\N{NAME}&lt;/code&gt; 형식 인 경우 이름이 &lt;code&gt;NAME&lt;/code&gt; 인 문자 또는 문자 시퀀스와 일치합니다 . 마찬가지로 &lt;code&gt;\N{U+&lt;i&gt;hex&lt;/i&gt;}&lt;/code&gt; 형식 인 경우 유니 코드 코드 포인트가 문자 인 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="6fec90a9c83208c9ab833401f72e3ba22b8885c3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\N{...}&lt;/code&gt; can mean a &lt;a href=&quot;#Named-or-numbered-characters-and-character-sequences&quot;&gt;named or numbered character &lt;/a&gt;.</source>
          <target state="translated">참고 것을 &lt;code&gt;\N{...}&lt;/code&gt; 비열한 수있는 &lt;a href=&quot;#Named-or-numbered-characters-and-character-sequences&quot;&gt;이름 또는 번호 문자&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c272dee08a4ec0d279e74b44ce54c8507ca63ec0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\N{...}&lt;/code&gt; is compile-time; it's a special form of string constant used inside double-quotish strings; this means that you cannot use variables inside the &lt;code&gt;\N{...}&lt;/code&gt; . If you want similar run-time functionality, use &lt;a href=&quot;#charnames%3a%3astring_vianame(name)&quot;&gt;charnames::string_vianame()&lt;/a&gt;.</source>
          <target state="translated">참고 &lt;code&gt;\N{...}&lt;/code&gt; 컴파일 시간; 큰 따옴표 문자열 안에 사용되는 특수한 형식의 문자열 상수입니다. 이는 &lt;code&gt;\N{...}&lt;/code&gt; 내부에서 변수를 사용할 수 없음을 의미합니다 . 비슷한 런타임 기능을 원하면 &lt;a href=&quot;#charnames%3a%3astring_vianame(name)&quot;&gt;charnames :: string_vianame ()을 사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0fd4812fc895b96b92cb32be1e45c1db5eaf35e8" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\N{U+&lt;i&gt;...&lt;/i&gt;}&lt;/code&gt;, where the</source>
          <target state="translated">참고 &lt;code&gt;\N{U+&lt;i&gt;...&lt;/i&gt;}&lt;/code&gt; , 어디</target>
        </trans-unit>
        <trans-unit id="591330d2defbab5242891eb86fdca8e3950ac9ed" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\c\&lt;/code&gt; alone at the end of a regular expression (or doubled-quoted string) is not valid. The backslash must be followed by another character. That is, &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; means &lt;code&gt;chr(28) . '&lt;i&gt;X&lt;/i&gt;'&lt;/code&gt; for all characters</source>
          <target state="translated">참고 &lt;code&gt;\c\&lt;/code&gt; 정규 표현식 (또는 두 배 인용 문자열)의 끝에 혼자가 유효하지 않습니다. 백 슬래시 뒤에 다른 문자가 와야합니다. 즉, &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; 는 &lt;code&gt;chr(28) . '&lt;i&gt;X&lt;/i&gt;'&lt;/code&gt; 의미 합니다. 모든 문자에 대해 ' &lt;i&gt;X&lt;/i&gt; '</target>
        </trans-unit>
        <trans-unit id="0564917393e190d68550cf153ec3fa749f8ef1c2" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;blessed($thing)&lt;/code&gt; will also return false if &lt;code&gt;$thing&lt;/code&gt; has been blessed into a class named &quot;0&quot;. This is a possible, but quite pathological. Don't create a class named &quot;0&quot; unless you know what you're doing.</source>
          <target state="translated">참고 &lt;code&gt;blessed($thing)&lt;/code&gt; 경우도 false를 반환합니다 &lt;code&gt;$thing&lt;/code&gt; &quot;0&quot;라는 이름의 클래스로 축복하고있다. 이것은 가능하지만 병리학 적입니다. 수행중인 작업을 모르면 &quot;0&quot;이라는 클래스를 만들지 마십시오.</target>
        </trans-unit>
        <trans-unit id="a119dbc9113a7d44b6376d76a949b8d8575c309d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;gen_delimited_pat&lt;/code&gt; was previously called &lt;code&gt;delimited_pat&lt;/code&gt; . That name may still be used, but is now deprecated.</source>
          <target state="translated">참고 &lt;code&gt;gen_delimited_pat&lt;/code&gt; 가 이전에 불려 &lt;code&gt;delimited_pat&lt;/code&gt; . 해당 이름은 계속 사용할 수 있지만 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c0da4f2ba6d0cf36f2dd51c6be576bdda729bf43" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;make_source&lt;/code&gt; &amp;amp; &lt;code&gt;make_perl_source&lt;/code&gt; have been</source>
          <target state="translated">참고 &lt;code&gt;make_source&lt;/code&gt; 및 &lt;code&gt;make_perl_source&lt;/code&gt; 가 왔다</target>
        </trans-unit>
        <trans-unit id="cb4cf0c7c42248024c78a0bb26a98cce7a24f07e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;openlog()&lt;/code&gt; now takes three arguments, just like &lt;code&gt;openlog(3)&lt;/code&gt; .</source>
          <target state="translated">그 주 &lt;code&gt;openlog()&lt;/code&gt; 지금처럼 세 개의 인수를 &lt;code&gt;openlog(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3174509a7760d68363f8a3d59612b5b0d75c608" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;size&lt;/code&gt; is the full size of the destination buffer and the result is guaranteed to be &lt;code&gt;NUL&lt;/code&gt; -terminated if there is room. Note that room for the &lt;code&gt;NUL&lt;/code&gt; should be included in &lt;code&gt;size&lt;/code&gt; .</source>
          <target state="translated">참고 &lt;code&gt;size&lt;/code&gt; 대상 버퍼의 전체 크기이며, 결과가 보장되는 &lt;code&gt;NUL&lt;/code&gt; 은 공간이있는 경우로 끝나는. &lt;code&gt;NUL&lt;/code&gt; 을 위한 공간 은 &lt;code&gt;size&lt;/code&gt; 포함되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="e1ee97366e8a29ba82d524849876bc9dc36688aa" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;source&lt;/code&gt; , &lt;code&gt;tap&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; are</source>
          <target state="translated">참고 &lt;code&gt;source&lt;/code&gt; , &lt;code&gt;tap&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 있습니다</target>
        </trans-unit>
        <trans-unit id="a8a3ab354ef3e6d59f72d20cd807dd1f627a195f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;sv_magicext&lt;/code&gt; will allow things that &lt;code&gt;sv_magic&lt;/code&gt; will not. In particular, you can add magic to SvREADONLY SVs, and add more than one instance of the same 'how'.</source>
          <target state="translated">참고 &lt;code&gt;sv_magicext&lt;/code&gt; 가 이 일 수 &lt;code&gt;sv_magic&lt;/code&gt; 는 하지 않습니다를. 특히 SvREADONLY SV에 마법을 추가하고 동일한 '방법'의 인스턴스를 두 개 이상 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d17fdc7c9d347932f15c81a113739f79e8f9e848" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;sv_setref_pv&lt;/code&gt; copies the pointer while this copies the string.</source>
          <target state="translated">참고 &lt;code&gt;sv_setref_pv&lt;/code&gt; 의 복사본을 포인터이 복사하는 동안 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="5b6169277ca527d5391cec9228283f0ee301bda5" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;sv_setref_pvn&lt;/code&gt; copies the string while this copies the pointer.</source>
          <target state="translated">참고 &lt;code&gt;sv_setref_pvn&lt;/code&gt; 에 복사합니다 문자열이 복사하는 동안 포인터를.</target>
        </trans-unit>
        <trans-unit id="c8b9e5c8595e30b3314518789be3e0f347c198b7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;utf8::downgrade()&lt;/code&gt; can fail if the string contains characters that don't fit into a byte.</source>
          <target state="translated">참고 &lt;code&gt;utf8::downgrade()&lt;/code&gt; 문자열 바이트에 맞지 않는 문자가 포함 된 경우 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa060ed1a78be536ec85c38f0f18576d3c573522" translate="yes" xml:space="preserve">
          <source>Note that =end commands must match the currently open =begin command. That is, they must properly nest. For example, this is valid:</source>
          <target state="translated">= end 명령은 현재 열려있는 = begin 명령과 일치해야합니다. 즉, 제대로 중첩되어야합니다. 예를 들어, 이것은 유효합니다 :</target>
        </trans-unit>
        <trans-unit id="29f1f8d502ed33af80a815e01f2ba72fc747d301" translate="yes" xml:space="preserve">
          <source>Note that ASCII characters that don't map to control characters are discouraged, and will generate the warning (when enabled) &lt;a href=&quot;#%5cc%25c%22-is-more-clearly-written-simply-as-%22%25s&quot;&gt;\c%c is more clearly written simply as %s&lt;/a&gt;.</source>
          <target state="translated">제어 문자에 맵핑되지 않은 ASCII 문자는 사용하지 않는 것이 좋으며 경고를 생성합니다 (활성화 된 경우). &lt;a href=&quot;#%5cc%25c%22-is-more-clearly-written-simply-as-%22%25s&quot;&gt;\ c % c는 더 명확하게 % s로 작성됩니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7f696f805b3c072e83294d03b83db4d7aa8d5f2f" translate="yes" xml:space="preserve">
          <source>Note that E&amp;lt;number&amp;gt;</source>
          <target state="translated">E &amp;lt;번호&amp;gt;</target>
        </trans-unit>
        <trans-unit id="0b2805b17d2c93e101d429684bf1e4cc0ec6e9bf" translate="yes" xml:space="preserve">
          <source>Note that GNU tar earlier than version 1.14 does not cope well with the &lt;code&gt;POSIX header prefix&lt;/code&gt; . If you use such a version, consider setting the &lt;code&gt;$Archive::Tar::DO_NOT_USE_PREFIX&lt;/code&gt; variable to &lt;code&gt;true&lt;/code&gt; .</source>
          <target state="translated">1.14 이전의 GNU tar는 &lt;code&gt;POSIX header prefix&lt;/code&gt; 잘 맞지 않습니다 . 이러한 버전을 사용하는 경우 &lt;code&gt;$Archive::Tar::DO_NOT_USE_PREFIX&lt;/code&gt; 변수를 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="41555ab0bf65d38958a3f14aeb7171b1e0133dfc" translate="yes" xml:space="preserve">
          <source>Note that GNU's gzip/gunzip is not the same as Info-ZIP's zip/unzip package. The former is a simple compression tool; the latter permits creation of multi-file archives.</source>
          <target state="translated">GNU의 gzip / gunzip은 Info-ZIP의 zip / unzip 패키지와 다릅니다. 전자는 간단한 압축 도구입니다. 후자는 다중 파일 아카이브를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="622ccc1f7f386f33bcd0fe7e88ec0737a974a63d" translate="yes" xml:space="preserve">
          <source>Note that Hash Quality Score would be 1 for an ideal hash, numbers close to and below 1 indicate good hashing, and number significantly above indicate a poor score. In practice it should be around 0.95 to 1.05. It is defined as:</source>
          <target state="translated">이상적인 해시의 경우 해시 품질 평가 점수가 1이고, 1 이하의 숫자는 좋은 해싱을 나타내고, 위의 숫자는 점수가 좋지 않은 것을 나타냅니다. 실제로는 0.95에서 1.05 사이 여야합니다. 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="5a0bd34cdc923419eb75f34bbc27c1a38f42a083" translate="yes" xml:space="preserve">
          <source>Note that META files are expected to be in UTF-8 encoding, only. When converted string data, it must first be decoded from UTF-8.</source>
          <target state="translated">META 파일은 UTF-8 인코딩으로 만 예상됩니다. 문자열 데이터를 변환 할 때는 먼저 UTF-8에서 디코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="9d701eb861ec485b89d355a1ef6df2a9826d0960" translate="yes" xml:space="preserve">
          <source>Note that MakeMaker actually emits makefiles with different syntax depending on what 'make' it thinks you are using. Therefore, it is important that one of the following values appears in Config.pm:</source>
          <target state="translated">MakeMaker는 실제로 사용중인 'make'에 따라 다른 구문으로 makefile을 생성합니다. 따라서 Config.pm에 다음 값 중 하나가 나타나는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="e57e92f05abaff6b44fad917e7a4948606c4c50b" translate="yes" xml:space="preserve">
          <source>Note that Perl can be compiled and run under either ASCII or EBCDIC (See &lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt;). Most of the documentation (and even comments in the code) ignore the EBCDIC possibility. For almost all purposes the differences are transparent. As an example, under EBCDIC, instead of UTF-8, UTF-EBCDIC is used to encode Unicode strings, and so whenever this documentation refers to &lt;code&gt;utf8&lt;/code&gt; (and variants of that name, including in function names), it also (essentially transparently) means &lt;code&gt;UTF-EBCDIC&lt;/code&gt; . But the ordinals of characters differ between ASCII, EBCDIC, and the UTF- encodings, and a string encoded in UTF-EBCDIC may occupy more bytes than in UTF-8.</source>
          <target state="translated">Perl은 ASCII 또는 EBCDIC에서 컴파일되고 실행될 수 있습니다 ( &lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt; 참조 ). 대부분의 문서 (및 코드의 주석도)는 EBCDIC 가능성을 무시합니다. 거의 모든 목적을 위해 차이점이 투명합니다. 예를 들어, UTF-8 대신 EBCDIC에서 UTF-EBCDIC는 유니 코드 문자열을 인코딩하는 데 사용 &lt;code&gt;utf8&lt;/code&gt; 문서가 utf8 (및 함수 이름을 포함하여 해당 이름의 변형)을 참조 할 때마다 (기본적으로 투명하게) &lt;code&gt;UTF-EBCDIC&lt;/code&gt; 을 의미합니다 . 그러나 문자 순서는 ASCII, EBCDIC 및 UTF- 인코딩간에 다르며 UTF-EBCDIC로 인코딩 된 문자열은 UTF-8보다 많은 바이트를 차지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18cd527588221d4d537c9d16a7ea7760668b37e5" translate="yes" xml:space="preserve">
          <source>Note that Perl considers grapheme clusters to be separate characters, so for example</source>
          <target state="translated">Perl은 grapheme 클러스터를 별도의 문자로 간주하므로</target>
        </trans-unit>
        <trans-unit id="eab78c95236503996e3835788eca975544654d36" translate="yes" xml:space="preserve">
          <source>Note that Perl doesn't use COMSPEC for this purpose because COMSPEC has a high degree of variability among users, leading to portability concerns. Besides, Perl can use a shell that may not be fit for interactive use, and setting COMSPEC to such a shell may interfere with the proper functioning of other programs (which usually look in COMSPEC to find a shell fit for interactive use).</source>
          <target state="translated">COMSPEC은 사용자간에 변동성이 높기 때문에 Perl은 이러한 목적으로 COMSPEC을 사용하지 않으므로 이식성 문제가 발생합니다. 또한 Perl은 대화식으로 사용하기에 적합하지 않은 쉘을 사용할 수 있으며 COMSPEC을 그러한 쉘로 설정하면 다른 프로그램 (일반적으로 COMSPEC에서 대화식 사용에 적합한 쉘을 찾음)의 올바른 기능을 방해 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b9723f4ea6f4a0b6aceb296908b35e0318ba34c" translate="yes" xml:space="preserve">
          <source>Note that Perl supports passing of up to only 14 arguments to your syscall, which in practice should (usually) suffice.</source>
          <target state="translated">Perl은 syscall에 최대 14 개의 인수 만 전달할 수 있습니다. 실제로는 일반적으로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="fc038a57f3e25b6eadeaf90180f1c3439e440f0b" translate="yes" xml:space="preserve">
          <source>Note that Perl will start to look for scripts only if OS/2 cannot start the specified application, thus &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; 'blah'&lt;/code&gt; will not look for a script if there is an executable file</source>
          <target state="translated">Perl은 OS / 2가 지정된 응용 프로그램을 시작할 수없는 경우에만 스크립트를 찾기 시작하므로 실행 파일이있는 경우 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; 'blah'&lt;/code&gt; 는 스크립트를 찾지 않습니다.</target>
        </trans-unit>
        <trans-unit id="91fa96b82144dedf82260fa9f38047e79dd27888" translate="yes" xml:space="preserve">
          <source>Note that Pod authors may use formatting codes inside the &quot;text&quot; part of &quot;L&amp;lt;text|name&amp;gt;&quot; (and so on for L&amp;lt;text|/&quot;sec&quot;&amp;gt;).</source>
          <target state="translated">포드 작성자는 &quot;L &amp;lt;text | name&amp;gt;&quot;의 &quot;text&quot;부분 내에서 형식 코드를 사용할 수 있습니다 (L &amp;lt;text | / &quot;sec&quot;&amp;gt; 등).</target>
        </trans-unit>
        <trans-unit id="e78fad76e523eb715d0d0985d903052e1c5e94f3" translate="yes" xml:space="preserve">
          <source>Note that RFC 1951 data is not a good choice of compression format to use in isolation, especially if you want to auto-detect it.</source>
          <target state="translated">RFC 1951 데이터는 특히 자동 감지하려는 경우 압축 형식을 선택하는 데 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9c1a2afa5425cbbe8c2645f8ed66553e6e705923" translate="yes" xml:space="preserve">
          <source>Note that SHA-1 and SHA-2 use</source>
          <target state="translated">SHA-1과 SHA-2는</target>
        </trans-unit>
        <trans-unit id="5e739101966d2d75e1e2a13b96e1acfc17a54320" translate="yes" xml:space="preserve">
          <source>Note that TODO tests</source>
          <target state="translated">TODO 테스트</target>
        </trans-unit>
        <trans-unit id="adf90b14f7079e4b164d5f4781cb0955f5b8199b" translate="yes" xml:space="preserve">
          <source>Note that Tie::File will only close any filehandles that it opened internally. If you passed it a filehandle as above, you &quot;own&quot; the filehandle, and are responsible for closing it after you have untied the @array.</source>
          <target state="translated">Tie :: File은 내부적으로 열린 파일 핸들 만 닫습니다. 위와 같이 파일 핸들을 전달한 경우, 파일 핸들을 &quot;소유&quot;하고 @array를 풀고 닫을 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4afe4a651bf63522c9809fb7b99b7a958e429b1d" translate="yes" xml:space="preserve">
          <source>Note that a &quot;=begin</source>
          <target state="translated">&quot;= 시작</target>
        </trans-unit>
        <trans-unit id="8b724b26e18550406b5e1585fe304e6c44d42b0e" translate="yes" xml:space="preserve">
          <source>Note that a blank line must have no blanks in it. Thus &lt;code&gt;&quot;fred\n \nstuff\n\n&quot;&lt;/code&gt; is one paragraph, but &lt;code&gt;&quot;fred\n\nstuff\n\n&quot;&lt;/code&gt; is two.</source>
          <target state="translated">빈 줄에는 공백이 없어야합니다. 따라서 &lt;code&gt;&quot;fred\n \nstuff\n\n&quot;&lt;/code&gt; 은 한 단락이지만 &lt;code&gt;&quot;fred\n\nstuff\n\n&quot;&lt;/code&gt; 은 두 단락 입니다.</target>
        </trans-unit>
        <trans-unit id="488f211edef26ffffb5b05c7e2b69aaf3b6426c8" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; can be used to effect an early exit out of such a block.</source>
          <target state="translated">블록 자체는 의미 적으로 한 번 실행되는 루프와 동일합니다. 따라서 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 는 그러한 블록에서 조기에 빠져 나오는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca2f98d2c44647b8c6e794a001b57317b63f04d1" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; will exit such a block early.</source>
          <target state="translated">블록 자체는 의미 적으로 한 번 실행되는 루프와 동일합니다. 따라서 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 은 그러한 블록을 일찍 종료합니다.</target>
        </trans-unit>
        <trans-unit id="d2013e8e837998ea5b5ded0d68af26e9b66d75ac" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; inside such a block will effectively turn it into a looping construct.</source>
          <target state="translated">블록 자체는 의미 적으로 한 번 실행되는 루프와 동일합니다. 따라서 이러한 블록 내부에서 &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; 하면 효과적으로 블록을 구성으로 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69d8a2b47ed12c267af9de16d301feaa50d0b140" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; can be used to effect an early exit out of such a block.</source>
          <target state="translated">블록 자체는 의미 적으로 한 번 실행되는 루프와 동일합니다. 따라서 &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 는 그러한 블록에서 조기에 빠져 나오는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7cf9f9549146f3e33d4f74b132eb49835f491f8" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; will exit such a block early.</source>
          <target state="translated">블록 자체는 의미 적으로 한 번 실행되는 루프와 동일합니다. 따라서 &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 은 그러한 블록을 일찍 종료합니다.</target>
        </trans-unit>
        <trans-unit id="0597bd4ffb228a1e2d68cc747265b06bb6260752" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; inside such a block will effectively turn it into a looping construct.</source>
          <target state="translated">블록 자체는 의미 적으로 한 번 실행되는 루프와 동일합니다. 따라서 이러한 블록 내부에서 &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; 하면 효과적으로 블록을 구성으로 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3807425ae34b529f2149724bf4de6b8be9e97ec8" translate="yes" xml:space="preserve">
          <source>Note that a character expressed as an octal escape is considered a character without special meaning by the regex engine, and will match &quot;as is&quot;.</source>
          <target state="translated">8 진 이스케이프로 표현 된 문자는 정규식 엔진에서 특별한 의미가없는 문자로 간주되며 &quot;있는 그대로&quot;일치합니다.</target>
        </trans-unit>
        <trans-unit id="45cc111c1e3b21172f0f2335e1ae7306a7eb5e16" translate="yes" xml:space="preserve">
          <source>Note that a character expressed as one of these escapes is considered a character without special meaning by the regex engine, and will match &quot;as is&quot;.</source>
          <target state="translated">이 이스케이프 중 하나로 표현 된 문자는 정규식 엔진에서 특별한 의미가없는 문자로 간주되며 &quot;있는 그대로&quot;일치합니다.</target>
        </trans-unit>
        <trans-unit id="093e11c1b10d3b91cf6120aba258f5fb6f25eb07" translate="yes" xml:space="preserve">
          <source>Note that a character or character sequence expressed as a named or numbered character is considered a character without special meaning by the regex engine, and will match &quot;as is&quot;.</source>
          <target state="translated">명명 된 또는 번호가 매겨진 문자로 표현 된 문자 또는 문자 시퀀스는 정규식 엔진에 의해 특별한 의미가없는 문자로 간주되며 &quot;있는 그대로&quot;일치합니다.</target>
        </trans-unit>
        <trans-unit id="5b8eb289741baff1763a39069ed3ea0111511da4" translate="yes" xml:space="preserve">
          <source>Note that a format begins with the letter &quot;a&quot; if and only the property it is for requires adjustments by adding the offsets in multi-element ranges. For all these properties, an entry should be adjusted only if the map is a scalar which is an integer. That is, it must match the regular expression:</source>
          <target state="translated">여러 요소 범위의 오프셋을 추가하여 해당 속성 만 조정해야하는 경우 형식은 문자 &quot;a&quot;로 시작합니다. 이러한 모든 특성에 대해 맵이 정수인 스칼라 인 경우에만 항목을 조정해야합니다. 즉, 정규식과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="277e9c9ef26afafa8762a7902fac38086141ef72" translate="yes" xml:space="preserve">
          <source>Note that a scalar can be made to have both string and numeric content through numeric operations:</source>
          <target state="translated">숫자 연산을 통해 스칼라에 문자열 및 숫자 내용을 모두 갖도록 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ba4f70f6b75455ad6abeb4c11f3ab4b74ce3ab3" translate="yes" xml:space="preserve">
          <source>Note that a shared variable guarantees that if two or more threads try to modify it at the same time, the internal state of the variable will not become corrupted. However, there are no guarantees beyond this, as explained in the next section.</source>
          <target state="translated">공유 변수는 둘 이상의 스레드가 동시에이를 수정하려고 할 때 변수의 내부 상태가 손상되지 않도록합니다. 그러나 다음 섹션에서 설명하는 것처럼이 이상의 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="cbf633a93711ea65ac990e0ec5a96e4eb2db906d" translate="yes" xml:space="preserve">
          <source>Note that a side-effect of the above is that &lt;code&gt;mkpath&lt;/code&gt; and &lt;code&gt;rmtree&lt;/code&gt; are no longer exported at all. This is due to the way the &lt;code&gt;Exporter&lt;/code&gt; module works. If you are migrating a codebase to use the new interface, you will have to list everything explicitly. But that's just good practice anyway.</source>
          <target state="translated">위의 부작용은 &lt;code&gt;mkpath&lt;/code&gt; 와 &lt;code&gt;rmtree&lt;/code&gt; 가 더 이상 내보내지지 않는다는 것입니다. &lt;code&gt;Exporter&lt;/code&gt; 모듈이 작동 하는 방식 때문 입니다. 새 인터페이스를 사용하기 위해 코드베이스를 마이그레이션하는 경우 모든 것을 명시 적으로 나열해야합니다. 그러나 그것은 어쨌든 좋은 습관입니다.</target>
        </trans-unit>
        <trans-unit id="fabccca2b124b57df72b15874578f07ff3f430bb" translate="yes" xml:space="preserve">
          <source>Note that according to the POSIX 1003.1-1996 the FILENAME may have any number of trailing slashes. Some operating and filesystems do not get this right, so Perl automatically removes all trailing slashes to keep everyone happy.</source>
          <target state="translated">POSIX 1003.1-1996에 따라 FILENAME에는 여러 개의 후행 슬래시가있을 수 있습니다. 일부 운영 및 파일 시스템은이 권한을 얻지 못하므로 Perl은 모든 슬래시를 자동으로 제거하여 모든 사람을 만족시킵니다.</target>
        </trans-unit>
        <trans-unit id="83be315fcf65b1854e9827d37b7aa0e643910e0c" translate="yes" xml:space="preserve">
          <source>Note that all C programs (including the perl interpreter, which is written in C) always have an underlying locale. That locale is the &quot;C&quot; locale unless changed by a call to &lt;a href=&quot;#The-setlocale-function&quot;&gt;setlocale()&lt;/a&gt;. When Perl starts up, it changes the underlying locale to the one which is indicated by the &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt;. When using the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module or writing XS code, it is important to keep in mind that the underlying locale may be something other than &quot;C&quot;, even if the program hasn't explicitly changed it.</source>
          <target state="translated">모든 C 프로그램 (C로 작성된 perl 인터프리터 포함)에는 항상 기본 로케일이 있습니다. &lt;a href=&quot;#The-setlocale-function&quot;&gt;setlocale ()&lt;/a&gt; 호출로 변경되지 않는 한 해당 로케일은 &quot;C&quot;로케일 입니다. Perl은 시작할 때 기본 로케일을 &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt; 로 표시된 로케일로 변경합니다 . 사용하는 경우 &lt;a href=&quot;posix&quot;&gt;POSIX의&lt;/a&gt; 모듈 또는 XS 코드를 작성, 기본 로케일이 프로그램이 명시 적으로 변경되지 않은 경우에도, &quot;C&quot;가 아닌 다른 것이 될 수 있다는 것을 명심하는 것이 중요하다.</target>
        </trans-unit>
        <trans-unit id="9ab24412bb95107f3eb55078583c0a90d9214b85" translate="yes" xml:space="preserve">
          <source>Note that all Perl API global variables must be referenced with the &lt;code&gt;PL_&lt;/code&gt; prefix. Again, those not listed here are not to be used by extension writers, and can be changed or removed without notice; same with macros. Some macros are provided for compatibility with the older, unadorned names, but this support may be disabled in a future release.</source>
          <target state="translated">모든 Perl API 전역 변수는 &lt;code&gt;PL_&lt;/code&gt; 접두사 로 참조해야합니다 . 다시, 여기에 나열되지 않은 것은 확장 기능 작성자가 사용하지 않으며 통지없이 변경하거나 제거 할 수 있습니다. 매크로와 동일합니다. 오래된 매크로 이름과의 호환성을 위해 일부 매크로가 제공되지만 이후 릴리스에서는이 지원이 비활성화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89aa7734c4b74b60a4c1310b623d823298b487c6" translate="yes" xml:space="preserve">
          <source>Note that all access is read-only. You cannot modify the internals by using this module. Also, note that the B::OP and B::SV objects created by this module are only valid for as long as the underlying objects exist; their creation doesn't increase the reference counts of the underlying objects. Trying to access the fields of a freed object will give incomprehensible results, or worse.</source>
          <target state="translated">모든 액세스는 읽기 전용입니다. 이 모듈을 사용하여 내부를 수정할 수 없습니다. 또한이 모듈에 의해 생성 된 B :: OP 및 B :: SV 객체는 기본 객체가 존재하는 한 유효합니다. 그들의 생성은 기본 객체의 참조 카운트를 증가시키지 않습니다. 해제 된 객체의 필드에 액세스하려고하면 이해할 수없는 결과가 발생하거나 더 악화됩니다.</target>
        </trans-unit>
        <trans-unit id="8decf89662be3764b31363ba5ddb1483e12ddabb" translate="yes" xml:space="preserve">
          <source>Note that all non-essential underscores are removed in the display of the short names below.</source>
          <target state="translated">필수적이지 않은 모든 밑줄은 아래의 짧은 이름 표시에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="cbd6c5b0c5e74d46b9b73ec517d66ec65461aeb4" translate="yes" xml:space="preserve">
          <source>Note that all of the above are overridden within the scope of &lt;code&gt;&lt;a href=&quot;bytes&quot;&gt;use bytes&lt;/a&gt;&lt;/code&gt;; but you should be using this pragma only for debugging.</source>
          <target state="translated">위의 모든 것은 &lt;code&gt;&lt;a href=&quot;bytes&quot;&gt;use bytes&lt;/a&gt;&lt;/code&gt; 범위 내에서 재정의된다는 점에 유의하십시오 . 그러나이 pragma는 디버깅에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="205ec32f1130d522301c48a5f23e3282ae5c3cdd" translate="yes" xml:space="preserve">
          <source>Note that all updates of the %result are additive, the hash will not be cleared before use, thus allowing status results of many installs to be easily aggregated.</source>
          <target state="translated">% result의 모든 업데이트는 추가 적이므로 해시는 사용 전에 지워지지 않으므로 많은 설치 상태 결과를 쉽게 집계 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36cc92c47c9f292a67886537ca085ec97a646fe9" translate="yes" xml:space="preserve">
          <source>Note that all we have described here in this quick overview is the simplest most straightforward use of &lt;b&gt;Pod::Parser&lt;/b&gt; to do stream-based parsing. It is also possible to use the &lt;b&gt;Pod::Parser::parse_text&lt;/b&gt; function to do more sophisticated tree-based parsing. See &lt;a href=&quot;#TREE-BASED-PARSING&quot;&gt;TREE-BASED PARSING&lt;/a&gt;.</source>
          <target state="translated">이 빠른 개요에서 여기에 설명 된 모든 것은 &lt;b&gt;Pod :: Parser&lt;/b&gt; 를 스트림 기반 구문 분석을 수행 하는 가장 단순하고 간단한 방법 입니다. 보다 정교한 트리 기반 구문 분석을 수행 하기 위해 &lt;b&gt;Pod :: Parser :: parse_text&lt;/b&gt; 함수 를 사용할 수도 있습니다 . &lt;a href=&quot;#TREE-BASED-PARSING&quot;&gt;트리 기반 패링을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b40f1346b332774a6bbe4756105b2451b5aa080" translate="yes" xml:space="preserve">
          <source>Note that almost all properties are immune to case-insensitive matching. That is, adding a &lt;code&gt;/i&lt;/code&gt; regular expression modifier does not change what they match. There are two sets that are affected. The first set is &lt;code&gt;Uppercase_Letter&lt;/code&gt; , &lt;code&gt;Lowercase_Letter&lt;/code&gt; , and &lt;code&gt;Titlecase_Letter&lt;/code&gt; , all of which match &lt;code&gt;Cased_Letter&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; matching. The second set is &lt;code&gt;Uppercase&lt;/code&gt; , &lt;code&gt;Lowercase&lt;/code&gt; , and &lt;code&gt;Titlecase&lt;/code&gt; , all of which match &lt;code&gt;Cased&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; matching. (The difference between these sets is that some things, such as Roman numerals, come in both upper and lower case, so they are &lt;code&gt;Cased&lt;/code&gt; , but aren't considered to be letters, so they aren't &lt;code&gt;Cased_Letter&lt;/code&gt; s. They're actually &lt;code&gt;Letter_Number&lt;/code&gt; s.) This set also includes its subsets &lt;code&gt;PosixUpper&lt;/code&gt; and &lt;code&gt;PosixLower&lt;/code&gt; , both of which under &lt;code&gt;/i&lt;/code&gt; match &lt;code&gt;PosixAlpha&lt;/code&gt; .</source>
          <target state="translated">거의 모든 속성은 대소 문자를 구분하지 않습니다. 즉, &lt;code&gt;/i&lt;/code&gt; 정규식 수정자를 추가해도 일치하는 내용은 변경되지 않습니다. 영향을받는 두 세트가 있습니다. 첫 번째 세트는 &lt;code&gt;Uppercase_Letter&lt;/code&gt; , &lt;code&gt;Lowercase_Letter&lt;/code&gt; 및 &lt;code&gt;Titlecase_Letter&lt;/code&gt; 일치, 모두 &lt;code&gt;Cased_Letter&lt;/code&gt; 를 아래 &lt;code&gt;/i&lt;/code&gt; 정합. 두 번째 세트는 &lt;code&gt;Uppercase&lt;/code&gt; , &lt;code&gt;Lowercase&lt;/code&gt; 및 &lt;code&gt;Titlecase&lt;/code&gt; 모두 매치 그중 &lt;code&gt;Cased&lt;/code&gt; 아래 &lt;code&gt;/i&lt;/code&gt; 정합. (이 세트의 차이점은 로마 숫자와 같은 일부는 대문자와 소문자로 표시되므로 &lt;code&gt;Cased&lt;/code&gt; 하지만이되지 않도록, 문자로 간주되지 않습니다 &lt;code&gt;Cased_Letter&lt;/code&gt; 들. 실제로는 &lt;code&gt;Letter_Number&lt;/code&gt; s 입니다.)이 세트에는 &lt;code&gt;/i&lt;/code&gt; 아래 &lt;code&gt;PosixAlpha&lt;/code&gt; 와 일치 하는 &lt;code&gt;PosixUpper&lt;/code&gt; 및 &lt;code&gt;PosixLower&lt;/code&gt; 하위 세트도 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="bd7c4807ae2f9f37a6e187d7bd38a50b276ee8ea" translate="yes" xml:space="preserve">
          <source>Note that although &lt;code&gt;$!&lt;/code&gt; appears to be dual-valued variable, it is actually implemented using a tied scalar:</source>
          <target state="translated">비록 &lt;code&gt;$!&lt;/code&gt; 이중 값 변수 인 것처럼 보이며 실제로는 스칼라를 사용하여 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="606458ff6017524382f12a8fd94125b35d1b63bc" translate="yes" xml:space="preserve">
          <source>Note that an &quot;=over&quot; ... &quot;=back&quot; region should have some content. That is, authors should not have an empty region like this:</source>
          <target state="translated">&quot;= over&quot;... &quot;= back&quot;영역에는 일부 내용이 있어야합니다. 즉, 저자는 다음과 같이 빈 영역이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="8f873ccce2134d828b1fb4400b87f6f3fdbeb512" translate="yes" xml:space="preserve">
          <source>Note that an INVARIANT character (i.e. ASCII on non-EBCDIC machines) is a valid UTF-8 character.</source>
          <target state="translated">INVARIANT 문자 (예 : 비 EBCDIC 시스템의 ASCII)는 유효한 UTF-8 문자입니다.</target>
        </trans-unit>
        <trans-unit id="587e23eccc6cff27f015e2a6ec6c9aa159cb0d1a" translate="yes" xml:space="preserve">
          <source>Note that an exit() or die() that is compiled 'hushed' because of &quot;use vmsish&quot; is not un-hushed by calling vmsish::hushed(0) at runtime.</source>
          <target state="translated">&quot;use vmsish&quot;로 인해 'hushed'로 컴파일 된 exit () 또는 die ()는 런타임에 vmsish :: hushed (0)을 호출하여 숨겨지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b2477a9523ad15c5452b9aa241b6f568c4bd6177" translate="yes" xml:space="preserve">
          <source>Note that any variables and functions that are not documented in this document (or in &lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt;) are considered for internal use only, and as such are subject to change without notice.</source>
          <target state="translated">이 문서 (또는 &lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt; ) 에 문서화되어 있지 않은 모든 변수와 함수는 내부 용으로 만 고려되며 사전 통지없이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6b66f44f204ce59d376598daa611217f2bbd286" translate="yes" xml:space="preserve">
          <source>Note that any variables and functions that are not documented in this manpages (or in &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;) are considered for internal use only, and as such are subject to change without notice.</source>
          <target state="translated">이 맨 페이지 (또는 &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt; ) 에 설명되어 있지 않은 모든 변수와 함수는 내부 용으로 만 간주되며 예고없이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce41211a36e2b403696bfe4a4b1fe54c951c0f65" translate="yes" xml:space="preserve">
          <source>Note that anything inside a &lt;code&gt;\Q...\E&lt;/code&gt; stays unaffected by &lt;code&gt;/x&lt;/code&gt;. And note that &lt;code&gt;/x&lt;/code&gt; doesn't affect space interpretation within a single multi-character construct. For example in &lt;code&gt;\x{...}&lt;/code&gt; , regardless of the &lt;code&gt;/x&lt;/code&gt; modifier, there can be no spaces. Same for a &lt;a href=&quot;#Quantifiers&quot;&gt;quantifier&lt;/a&gt; such as &lt;code&gt;{3}&lt;/code&gt; or &lt;code&gt;{5,}&lt;/code&gt; . Similarly, &lt;code&gt;(?:...)&lt;/code&gt; can't have a space between the &lt;code&gt;(&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;, and &lt;code&gt;:&lt;/code&gt; . Within any delimiters for such a construct, allowed spaces are not affected by &lt;code&gt;/x&lt;/code&gt;, and depend on the construct. For example, &lt;code&gt;\x{...}&lt;/code&gt; can't have spaces because hexadecimal numbers don't have spaces in them. But, Unicode properties can have spaces, so in &lt;code&gt;\p{...}&lt;/code&gt; there can be spaces that follow the Unicode rules, for which see &lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;Properties accessible through \p{} and \P{} in perluniprops&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;\Q...\E&lt;/code&gt; 내부의 모든 내용 은 &lt;code&gt;/x&lt;/code&gt; 의 영향을받지 않습니다 . 그리고 &lt;code&gt;/x&lt;/code&gt; 는 단일 다중 문자 구성 내에서 공간 해석에 영향을 미치지 않습니다. 예를 들어 &lt;code&gt;\x{...}&lt;/code&gt; 에서 &lt;code&gt;/x&lt;/code&gt; 수정 자에 관계없이 공백이 없어야합니다. &lt;code&gt;{3}&lt;/code&gt; 또는 &lt;code&gt;{5,}&lt;/code&gt; 와 같은 &lt;a href=&quot;#Quantifiers&quot;&gt;수량 자에&lt;/a&gt; 대해서도 동일합니다 . 마찬가지로 &lt;code&gt;(?:...)&lt;/code&gt; 은 &lt;code&gt;(&lt;/code&gt; , &lt;code&gt;?&lt;/code&gt; , &lt;code&gt;:&lt;/code&gt; 사이에 공백을 사용할 수 없습니다 . 이러한 구문의 구분 기호 내에서 허용 된 공백은 &lt;code&gt;/x&lt;/code&gt; 의 영향을받지 않으며 구문에 따라 다릅니다. &lt;code&gt;\x{...}&lt;/code&gt; 16 진수에는 공백이 없기 때문에 공백을 사용할 수 없습니다. 그러나 유니 코드 속성에는 공백 이있을 수 있으므로 &lt;code&gt;\p{...}&lt;/code&gt; 에는 유니 코드 규칙을 따르는 공백이있을 수 있습니다 . 이에 &lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;대해서는 perluniprops의 \ p {} 및 \ P {}를 통해 액세스 할 수&lt;/a&gt; 있는 속성 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0fdc0e788793ca02998116be1ca2d6034cbab69c" translate="yes" xml:space="preserve">
          <source>Note that as of Perl 5.14, &lt;code&gt;\N{KATAKANA LETTER AINU P}&lt;/code&gt; will insert the named sequence into double-quoted strings, and &lt;code&gt;charnames::string_vianame(&quot;KATAKANA
LETTER AINU P&quot;)&lt;/code&gt; will return the same string this function does, but will also operate on character names that aren't named sequences, without you having to know which are which. See &lt;a href=&quot;../charnames&quot;&gt;charnames&lt;/a&gt;.</source>
          <target state="translated">Perl 5.14부터 &lt;code&gt;\N{KATAKANA LETTER AINU P}&lt;/code&gt; 는 명명 된 시퀀스를 큰 따옴표로 묶은 문자열에 삽입하고 &lt;code&gt;charnames::string_vianame(&quot;KATAKANA LETTER AINU P&quot;)&lt;/code&gt; 는이 함수와 동일한 문자열을 반환하지만 또한 시퀀스 이름이 아닌 문자 이름에 대해 작동합니다. &lt;a href=&quot;../charnames&quot;&gt;charnames를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e472cfdb1b217c8839b9da7d68aebc2ef451ccc9" translate="yes" xml:space="preserve">
          <source>Note that as of Perl 5.20, literal control characters in variable names are deprecated; and as of Perl 5.22, any other non-graphic characters are also deprecated.</source>
          <target state="translated">Perl 5.20부터 변수 이름의 리터럴 제어 문자는 더 이상 사용되지 않습니다. Perl 5.22부터는 그래픽이 아닌 다른 문자도 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4a675b15092aa8c87c6f30bd02df31fd70694188" translate="yes" xml:space="preserve">
          <source>Note that atan2(0, 0) is not well-defined.</source>
          <target state="translated">atan2 (0, 0)은 잘 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8fbf5b8aea29a3936ba6fef9526fd98f6b5784c6" translate="yes" xml:space="preserve">
          <source>Note that attribute handlers that are scheduled for the &lt;code&gt;BEGIN&lt;/code&gt; phase are handled as soon as the attribute is detected (i.e. before any subsequently defined &lt;code&gt;BEGIN&lt;/code&gt; blocks are executed).</source>
          <target state="translated">&lt;code&gt;BEGIN&lt;/code&gt; 단계에 대해 스케줄 된 속성 핸들러 는 속성이 감지되는 즉시 (즉, 이후에 정의 된 &lt;code&gt;BEGIN&lt;/code&gt; 블록이 실행 되기 전에 ) 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="0f24e592f4d8a1a531dda62544ac7d2f7b1bf174" translate="yes" xml:space="preserve">
          <source>Note that because &lt;b&gt;-i&lt;/b&gt; renames or deletes the original file before creating a new file of the same name, Unix-style soft and hard links will not be preserved.</source>
          <target state="translated">그 때문에주의 &lt;b&gt;-i&lt;/b&gt; 이름 바꾸기 또는 동일한 이름의 새 파일을 작성하기 전에 원본 파일을 삭제, 유닉스 스타일의 소프트 및 하드 링크가 유지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="49723b78c25f9f94694a955ddf0fb169c3bb02b1" translate="yes" xml:space="preserve">
          <source>Note that because multiple extensions may be using &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; or &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; magic, it is important for extensions to take extra care to avoid conflict. Typically only using the magic on objects blessed into the same class as the extension is sufficient. For &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; magic, it is usually a good idea to define an &lt;code&gt;MGVTBL&lt;/code&gt; , even if all its fields will be &lt;code&gt;0&lt;/code&gt; , so that individual &lt;code&gt;MAGIC&lt;/code&gt; pointers can be identified as a particular kind of magic using their magic virtual table. &lt;code&gt;mg_findext&lt;/code&gt; provides an easy way to do that:</source>
          <target state="translated">여러 확장 프로그램에서 &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; 또는 &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; 매직을 사용하고있을 수 있으므로 확장 프로그램이 충돌을 피하기 위해 특별한주의를 기울여야합니다. 일반적으로 확장과 같은 클래스에 축복받은 물건에 마법을 사용하는 것으로 충분합니다. 들어 &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; 의 마법, 일반적으로 정의하는 좋은 아이디어입니다 &lt;code&gt;MGVTBL&lt;/code&gt; 를 모든 분야가 될 것입니다 경우에도 &lt;code&gt;0&lt;/code&gt; 을 개별 그래서, &lt;code&gt;MAGIC&lt;/code&gt; 포인터가 마법 가상 테이블을 사용하여 마법의 특별한 종류로 식별 할 수 있습니다. &lt;code&gt;mg_findext&lt;/code&gt; 는 다음과 같은 쉬운 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2432f753e906c1dd9f81b56a7cfbeac9aa989c16" translate="yes" xml:space="preserve">
          <source>Note that because of stupid OS/2 limitations the full path of the perl script is not available when you use &lt;code&gt;extproc&lt;/code&gt; , thus you are forced to use &lt;code&gt;-S&lt;/code&gt; perl switch, and your script should be on the &lt;code&gt;PATH&lt;/code&gt; . As a plus side, if you know a full path to your script, you may still start it with</source>
          <target state="translated">어리석은 OS / 2 제한 사항으로 인해 &lt;code&gt;extproc&lt;/code&gt; 을 사용할 때 perl 스크립트의 전체 경로를 사용할 수 없으므로 &lt;code&gt;-S&lt;/code&gt; perl 스위치를 사용해야하며 스크립트가 &lt;code&gt;PATH&lt;/code&gt; 에 있어야합니다 . 좋은 점은 스크립트의 전체 경로를 알고 있다면 다음과 같이 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad5dd4afa174c9cef5b24c559737823b7753c820" translate="yes" xml:space="preserve">
          <source>Note that because this rendering was done on a non-threaded perl, the PADOPs in the previous examples are now SVOPs, and some (but not all) of the square brackets have been replaced by round ones. This is a subtle feature to provide some visual distinction between renderings on threaded and un-threaded perls.</source>
          <target state="translated">이 렌더링은 스레드되지 않은 펄에서 수행되었으므로 이전 예제의 PADOP는 이제 SVOP이며 일부 (대부분은 아님) 대괄호는 둥근 대괄호로 대체되었습니다. 이것은 스레드 및 스레드되지 않은 perls의 렌더링을 시각적으로 구분하기위한 미묘한 기능입니다.</target>
        </trans-unit>
        <trans-unit id="e6d44ccabe09fa1f4e596936119e58147bb0fd41" translate="yes" xml:space="preserve">
          <source>Note that because we are operating on approximations of real numbers, these errors can happen when merely `too close' to the singularities listed above.</source>
          <target state="translated">우리는 실수의 근사값으로 작업하기 때문에, 위에서 언급 한 특이점에 너무 근접 할 때 이러한 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cac802226be8e6c597ab4225af3fcdf654d037f" translate="yes" xml:space="preserve">
          <source>Note that both &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; in Perl are implemented directly using &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; in C. If &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; (see &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;) is in force then signed C integers are used, else unsigned C integers are used. Either way, the implementation isn't going to generate results larger than the size of the integer type Perl was built with (32 bits or 64 bits).</source>
          <target state="translated">모두 유의 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 와 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 펄을 사용하여 직접 구현 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 와 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; C. 경우의에 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; (참조 &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;정수 산술&lt;/a&gt; ) C 정수를 사용하는 다음 서명 힘이고, 다른 부호 C의 정수를 사용한다. 어느 쪽이든, 구현은 Perl이 빌드 한 정수형의 크기 (32 비트 또는 64 비트)보다 큰 결과를 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="04cf68d9424884dadb0aa2996784eb6ff505962d" translate="yes" xml:space="preserve">
          <source>Note that both &lt;code&gt;hv_store&lt;/code&gt; and &lt;code&gt;hv_store_ent&lt;/code&gt; do not increment the reference count of the stored &lt;code&gt;val&lt;/code&gt; , which is the caller's responsibility. If these functions return a NULL value, the caller will usually have to decrement the reference count of &lt;code&gt;val&lt;/code&gt; to avoid a memory leak.</source>
          <target state="translated">참고 둘 것을 &lt;code&gt;hv_store&lt;/code&gt; 및 &lt;code&gt;hv_store_ent&lt;/code&gt; 는 저장된의 참조 횟수가 증가하지 않는 &lt;code&gt;val&lt;/code&gt; 호출자의 책임입니다. 이러한 함수가 NULL 값을 반환하면 호출자는 일반적으로 메모리 누수를 피하기 위해 &lt;code&gt;val&lt;/code&gt; 의 참조 카운트를 줄여야합니다 .</target>
        </trans-unit>
        <trans-unit id="74a9256e12aa22e857528719131785d55699987c" translate="yes" xml:space="preserve">
          <source>Note that both paths are assumed to have a notation that distinguishes a directory path (with trailing ':') from a file path (without trailing ':').</source>
          <target state="translated">두 경로 모두 디렉토리 경로 (후행 ':')와 파일 경로 (후행 ':'없음)를 구별하는 표기법이있는 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="0e8fd56db9f2f95bb2076209ba3c59af9c411003" translate="yes" xml:space="preserve">
          <source>Note that both the &lt;code&gt;CanonicalName&lt;/code&gt; and &lt;code&gt;FilterName&lt;/code&gt; options can modify the value used for the zip filename header field.</source>
          <target state="translated">&lt;code&gt;CanonicalName&lt;/code&gt; 및 &lt;code&gt;FilterName&lt;/code&gt; 옵션 모두 zip 파일 이름 헤더 필드에 사용 된 값을 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4c874fe97ef7da4bd4b4b5db7330a5fe9438bed" translate="yes" xml:space="preserve">
          <source>Note that bsd_glob() deviates from POSIX and FreeBSD glob(3) behaviour by not considering &lt;code&gt;ENOENT&lt;/code&gt; and &lt;code&gt;ENOTDIR&lt;/code&gt; as errors - bsd_glob() will continue processing despite those errors, unless the &lt;code&gt;GLOB_ERR&lt;/code&gt; flag is set.</source>
          <target state="translated">bsd_glob ()는 &lt;code&gt;ENOENT&lt;/code&gt; 및 &lt;code&gt;ENOTDIR&lt;/code&gt; 을 오류로 간주하지 않음으로써 POSIX 및 FreeBSD glob (3) 동작에서 벗어납니다 . &lt;code&gt;GLOB_ERR&lt;/code&gt; 플래그가 설정되어 있지 않으면 bsd_glob ()는 이러한 오류에도 불구하고 처리를 계속 합니다.</target>
        </trans-unit>
        <trans-unit id="a4b82a298fa226e67135978079ffa22b87e99940" translate="yes" xml:space="preserve">
          <source>Note that capture groups matched inside of recursion are not accessible after the recursion returns, so the extra layer of capturing groups is necessary. Thus &lt;code&gt;$+{NAME_PAT}&lt;/code&gt; would not be defined even though &lt;code&gt;$+{NAME}&lt;/code&gt; would be.</source>
          <target state="translated">재귀 내부에서 일치하는 캡처 그룹은 재귀가 반환 된 후에 액세스 할 수 없으므로 추가 캡처 그룹 계층이 필요합니다. 따라서 &lt;code&gt;$+{NAME_PAT}&lt;/code&gt; &lt;code&gt;$+{NAME}&lt;/code&gt; 이 (가)있을 지라도 $ + {NAME_PAT} 이 (가) 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="bc76dc97a1c19045dc8a76b9a6b2095a51024d2b" translate="yes" xml:space="preserve">
          <source>Note that certain exponentiation expressions are ill-defined: these include &lt;code&gt;0**0&lt;/code&gt; , &lt;code&gt;1**Inf&lt;/code&gt; , and &lt;code&gt;Inf**0&lt;/code&gt; . Do not expect any particular results from these special cases, the results are platform-dependent.</source>
          <target state="translated">특정 지수 표현식은 잘못 정의되어 있습니다. 여기에는 &lt;code&gt;0**0&lt;/code&gt; , &lt;code&gt;1**Inf&lt;/code&gt; 및 &lt;code&gt;Inf**0&lt;/code&gt; 됩니다. 이 특별한 경우의 특정 결과를 기대하지 마십시오. 결과는 플랫폼에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="ae568ca1008d1cccb4f94c7517bbb753d06bd905" translate="yes" xml:space="preserve">
          <source>Note that characters from 128 to 255 (inclusive) are by default internally not encoded as UTF-8 for backward compatibility reasons.</source>
          <target state="translated">128 ~ 255 (포함)의 문자는 기본적으로 이전 버전과의 호환성을 위해 내부적으로 UTF-8로 인코딩되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="20fe49f9b13e959950bbe4e0a6e4e652aef94a09" translate="yes" xml:space="preserve">
          <source>Note that clients who do not support the &lt;code&gt;GNU Extended Header&lt;/code&gt; feature will not be able to read these archives. Such clients include tars on &lt;code&gt;Solaris&lt;/code&gt; , &lt;code&gt;Irix&lt;/code&gt; and &lt;code&gt;AIX&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;GNU Extended Header&lt;/code&gt; 기능을 지원하지 않는 클라이언트 는이 아카이브를 읽을 수 없습니다. 이러한 클라이언트에는 &lt;code&gt;Solaris&lt;/code&gt; , &lt;code&gt;Irix&lt;/code&gt; 및 &lt;code&gt;AIX&lt;/code&gt; 의 tar가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="1fce890d3f4b569eee4d4fb3d808316a6c987e62" translate="yes" xml:space="preserve">
          <source>Note that codes 6 (rapid blink) and 9 (strike-through) are specified in ANSI X3.64 and ECMA-048 but are not commonly supported by most displays and emulators and therefore aren't supported by this module at the present time. ECMA-048 also specifies a large number of other attributes, including a sequence of attributes for font changes, Fraktur characters, double-underlining, framing, circling, and overlining. As none of these attributes are widely supported or useful, they also aren't currently supported by this module.</source>
          <target state="translated">코드 6 (빠른 깜박임) 및 9 (스트라이크 스루)는 ANSI X3.64 및 ECMA-048에 지정되어 있지만 대부분의 디스플레이 및 에뮬레이터에서 일반적으로 지원되지 않으므로 현재이 모듈에서는 지원되지 않습니다. ECMA-048은 글꼴 변경, Fraktur 문자, 이중 밑줄, 프레이밍, 순환 및 오버 라이닝에 대한 일련의 속성을 포함하여 많은 다른 속성도 지정합니다. 이러한 속성 중 어느 것도 광범위하게 지원되거나 유용하지 않으므로 현재이 모듈에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="701f822191abdf1e19724503033550d3adb9a3d3" translate="yes" xml:space="preserve">
          <source>Note that coercing an arbitrary scalar into a plain PV will potentially strip useful data from it. For example if the SV was &lt;code&gt;SvROK&lt;/code&gt; , then the referent will have its reference count decremented, and the SV itself may be converted to an &lt;code&gt;SvPOK&lt;/code&gt; scalar with a string buffer containing a value such as &lt;code&gt;&quot;ARRAY(0x1234)&quot;&lt;/code&gt; .</source>
          <target state="translated">임의의 스칼라를 일반 PV로 강제 변환하면 유용한 데이터가 제거 될 수 있습니다. 예를 들어, SV가 &lt;code&gt;SvROK&lt;/code&gt; 이면 참조자는 참조 카운트가 감소하고 SV 자체는 &lt;code&gt;&quot;ARRAY(0x1234)&quot;&lt;/code&gt; 와 같은 값을 포함하는 문자열 버퍼 를 사용하여 &lt;code&gt;SvPOK&lt;/code&gt; 스칼라 로 변환 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c860f546e898e4ab8af10e9688384776e80d8690" translate="yes" xml:space="preserve">
          <source>Note that connected() considers a half-open TCP socket to be &quot;in a connected state&quot;. Specifically, connected() does not distinguish between the &lt;b&gt;ESTABLISHED&lt;/b&gt; and &lt;b&gt;CLOSE-WAIT&lt;/b&gt; TCP states; it returns the peer address, rather than undef, in either case. Thus, in general, connected() cannot be used to reliably learn whether the peer has initiated a graceful shutdown because in most cases (see below) the local TCP state machine remains in &lt;b&gt;CLOSE-WAIT&lt;/b&gt; until the local application calls shutdown() or close(); only at that point does connected() return undef.</source>
          <target state="translated">connected ()는 반 열린 TCP 소켓을 &quot;연결된 상태&quot;로 간주합니다. 특히 connected ()는 &lt;b&gt;ESTABLISHED&lt;/b&gt; 와 &lt;b&gt;CLOSE-WAIT&lt;/b&gt; TCP 상태를 구분하지 않습니다 . 두 경우 모두 undef가 아닌 peer 주소를 반환합니다. 따라서 일반적으로 connected ()를 사용하면 대부분의 경우 (아래 참조) 로컬 응용 프로그램이 shutdown ()을 호출하거나 닫을 때까지 로컬 TCP 상태 시스템이 &lt;b&gt;CLOSE-WAIT&lt;/b&gt; 상태로 유지되므로 피어가 정상적으로 종료를 시작했는지 여부를 확실하게 알 수 없습니다. (); 그 시점에서만 connected ()가 undef를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4c163cf186643a94245d42938672412776fa5e48" translate="yes" xml:space="preserve">
          <source>Note that currently some test scripts may fail when run in parallel (most notably</source>
          <target state="translated">현재 일부 테스트 스크립트는 병렬로 실행할 때 실패 할 수 있습니다 (주로</target>
        </trans-unit>
        <trans-unit id="fab55f641e790811b170e8b9128a927c617d8c7b" translate="yes" xml:space="preserve">
          <source>Note that define_alias() will not be able to override the canonical name of encodings. Encodings are first looked up by canonical name before potential aliases are tried.</source>
          <target state="translated">define_alias ()는 표준 인코딩 이름을 무시할 수 없습니다. 잠재적 인 별명을 시도하기 전에 먼저 표준 이름으로 인코딩을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="da1de0e37193fb693b5c5e6bff7827d4423ee163" translate="yes" xml:space="preserve">
          <source>Note that despite the existence of this optag a memory resource attack may still be possible using only :base_core ops.</source>
          <target state="translated">이 optag의 존재에도 불구하고 : base_core ops 만 사용하여 메모리 리소스 공격이 여전히 가능할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8256313554b42c8373b7bc367151c3b74d8cc5fc" translate="yes" xml:space="preserve">
          <source>Note that dot (</source>
          <target state="translated">점 (</target>
        </trans-unit>
        <trans-unit id="765abb42fa3dbbf2af93a7f1e80231e5f09ac37f" translate="yes" xml:space="preserve">
          <source>Note that due to excessive paranoia, if $Getopt::Std::STANDARD_HELP_VERSION isn't true (the default is false), then the messages are printed on STDERR, and the processing continues after the messages are printed. This being the opposite of the standard-conforming behaviour, it is strongly recommended to set $Getopt::Std::STANDARD_HELP_VERSION to true.</source>
          <target state="translated">과도한 편집증으로 인해 $ Getopt :: Std :: STANDARD_HELP_VERSION이 true가 아닌 경우 (기본값은 false), 메시지가 STDERR에 인쇄되고 메시지가 인쇄 된 후에 처리가 계속됩니다. 이는 표준을 따르는 동작과 반대이므로 $ Getopt :: Std :: STANDARD_HELP_VERSION을 true로 설정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1bbc11a7c1c533941b49be5f36414035e1261338" translate="yes" xml:space="preserve">
          <source>Note that each &lt;code&gt;pp_&lt;/code&gt; function is expected to return a pointer to the next op. Calls to perl subs (and eval blocks) are handled within the same runops loop, and do not consume extra space on the C stack. For example, &lt;code&gt;pp_entersub&lt;/code&gt; and &lt;code&gt;pp_entertry&lt;/code&gt; just push a &lt;code&gt;CxSUB&lt;/code&gt; or &lt;code&gt;CxEVAL&lt;/code&gt; block struct onto the context stack which contain the address of the op following the sub call or eval. They then return the first op of that sub or eval block, and so execution continues of that sub or block. Later, a &lt;code&gt;pp_leavesub&lt;/code&gt; or &lt;code&gt;pp_leavetry&lt;/code&gt; op pops the &lt;code&gt;CxSUB&lt;/code&gt; or &lt;code&gt;CxEVAL&lt;/code&gt; , retrieves the return op from it, and returns it.</source>
          <target state="translated">각 &lt;code&gt;pp_&lt;/code&gt; 함수는 다음 op에 대한 포인터를 반환해야합니다. perl 서브 (및 평가 블록)에 대한 호출은 동일한 runops 루프 내에서 처리되며 C 스택에서 추가 공간을 소비하지 않습니다. 예를 들어, &lt;code&gt;pp_entersub&lt;/code&gt; 및 &lt;code&gt;pp_entertry&lt;/code&gt; 는 &lt;code&gt;CxSUB&lt;/code&gt; 또는 &lt;code&gt;CxEVAL&lt;/code&gt; 블록 구조를 컨텍스트 호출로 푸시합니다. 여기에는 서브 호출 또는 평가 다음에 op의 주소가 포함됩니다. 그런 다음 해당 하위 또는 평가 블록의 첫 번째 op를 반환하므로 해당 하위 또는 블록의 실행이 계속됩니다. 나중에하는 &lt;code&gt;pp_leavesub&lt;/code&gt; 또는 &lt;code&gt;pp_leavetry&lt;/code&gt; 영업 이익은 팝업 &lt;code&gt;CxSUB&lt;/code&gt; 또는 &lt;code&gt;CxEVAL&lt;/code&gt; 를 , 그것에서 반환 연산을 검색하고 반환 그것.</target>
        </trans-unit>
        <trans-unit id="420d7847072074bbd6eaf28b4c7884f7445e96dd" translate="yes" xml:space="preserve">
          <source>Note that each of these return &lt;code&gt;$self&lt;/code&gt; when you call them as &lt;code&gt;$self-&amp;gt;&lt;i&gt;whatever(value)&lt;/i&gt;&lt;/code&gt;. That's so that you can chain together set-attribute calls like this:</source>
          <target state="translated">&lt;code&gt;$self-&amp;gt;&lt;i&gt;whatever(value)&lt;/i&gt;&lt;/code&gt; &lt;i&gt;whatever (value)&lt;/i&gt; 로 호출하면 각각 &lt;code&gt;$self&lt;/code&gt; 반환 합니다 . 이렇게하면 집합 속성 호출을 다음과 같이 연결할 수 있습니다.&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="51d2022d4221c4239f7b2040e5d01a22869c3e3c" translate="yes" xml:space="preserve">
          <source>Note that even though SunOS and Solaris are binary compatible, these values are different. Go figure.</source>
          <target state="translated">SunOS 및 Solaris가 이진 호환 가능하더라도이 값은 다릅니다. 그림을 이동.</target>
        </trans-unit>
        <trans-unit id="8c3fc5526126d228e7dc152e5bae2056ec1d2dd9" translate="yes" xml:space="preserve">
          <source>Note that failed case-changing operations done as a result of case-insensitive &lt;code&gt;/i&lt;/code&gt; regular expression matching will show up in this warning as having the &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; operation (as that is what the regular expression engine calls behind the scenes.)</source>
          <target state="translated">대소 문자를 구분하지 않는 &lt;code&gt;/i&lt;/code&gt; 정규 표현식 일치 의 결과로 실패한 대 / 소문자 변경 작업 은이 경고에서 &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; 작업 이있는 것으로 표시됩니다 (정규 표현식 엔진이 비하인드 스토리 뒤에 있음).</target>
        </trans-unit>
        <trans-unit id="8661f786e43fee3fd71c6daeb5a91a3c5f42f424" translate="yes" xml:space="preserve">
          <source>Note that flushing can seriously degrade the compression ratio, so it should only be used to terminate a decompression (using &lt;code&gt;Z_FINISH&lt;/code&gt; ) or when you want to create a</source>
          <target state="translated">플러싱은 압축 비율을 심각하게 저하시킬 수 있으므로 압축 해제를 종료하는 경우 ( &lt;code&gt;Z_FINISH&lt;/code&gt; 사용 ) 또는 생성하려는 경우 에만 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a95fd032f7a2402cab6502921fb63c15d3283b35" translate="yes" xml:space="preserve">
          <source>Note that for control characters (&lt;code&gt;Gc=cc&lt;/code&gt; ), Unicode's data files have the string &quot;&lt;code&gt;&amp;lt;control&amp;gt;&lt;/code&gt; &quot;, but the real name of each of these characters is the empty string. This function returns that real name, the empty string. (There are names for these characters, but they are considered aliases, not the Name property name, and are contained in the &lt;code&gt;Name_Alias&lt;/code&gt; property.)</source>
          <target state="translated">제어 문자 ( &lt;code&gt;Gc=cc&lt;/code&gt; )의 경우 유니 코드 데이터 파일의 문자열은 &quot; &lt;code&gt;&amp;lt;control&amp;gt;&lt;/code&gt; &quot;이지만 이러한 각 문자의 실제 이름은 빈 문자열입니다. 이 함수는 실제 이름 인 빈 문자열을 반환합니다. 이러한 문자의 이름이 있지만 이름 특성 이름이 아닌 별명으로 간주되며 &lt;code&gt;Name_Alias&lt;/code&gt; 특성에 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="d3b4cbb1ed8f855f79ca32bff7fc152fc5c21ab5" translate="yes" xml:space="preserve">
          <source>Note that for larger bit-strings, it's more efficient to use the two-argument version</source>
          <target state="translated">비트 열이 클수록 2 인수 버전을 사용하는 것이 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="a191f82c0a0eecf7bccec0288b197819c9c21ed4" translate="yes" xml:space="preserve">
          <source>Note that for simpler testing requirements it will often be possible to replace the above code with a single call to &lt;code&gt;runtests&lt;/code&gt; .</source>
          <target state="translated">간단한 테스트 요구 사항에 대해서는 종종 위의 코드를 단일 &lt;code&gt;runtests&lt;/code&gt; 호출로 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ff6a50ca77c83bd7639e6227860f0a0332790a2f" translate="yes" xml:space="preserve">
          <source>Note that for the &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; (infinity and not-a-number) the definition of &quot;numeric&quot; is somewhat unusual: the strings themselves (like &quot;Inf&quot;) are considered numeric, and anything following them is considered non-numeric.</source>
          <target state="translated">참고를위한 것으로 &lt;code&gt;Inf&lt;/code&gt; 를 하고 &lt;code&gt;NaN&lt;/code&gt; 이 (무한대 숫자가 아닌 값) &quot;숫자&quot;의 정의 다소 특이한 경우 : ( &quot;Inf를&quot;같은) 자체는 숫자로 간주되는 문자열, 그들은 숫자가 아닌 것으로 간주됩니다 다음 아무것도.</target>
        </trans-unit>
        <trans-unit id="de25d3b42b2818ebeccffadf90f915562d81e76b" translate="yes" xml:space="preserve">
          <source>Note that formats are treated as anon subs, and are cloned each time write is called (if necessary).</source>
          <target state="translated">형식은 anon 서브로 취급되며 쓰기가 필요할 때마다 복제됩니다 (필요한 경우).</target>
        </trans-unit>
        <trans-unit id="be9d64d44ec51b213716f420b24aa9198bccd3c7" translate="yes" xml:space="preserve">
          <source>Note that freezing an object structure and immediately thawing it actually achieves a deep cloning of that structure:</source>
          <target state="translated">객체 구조를 고정하고 즉시 해동하면 실제로 해당 구조를 심도있게 복제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="692f49a79ca8c218f709da74928c335686702cff" translate="yes" xml:space="preserve">
          <source>Note that from &lt;a href=&quot;../bigint&quot;&gt;Math::BigInt&lt;/a&gt; v1.76 onwards, FastCalc will be loaded automatically, if possible.</source>
          <target state="translated">에서 유의 &lt;a href=&quot;../bigint&quot;&gt;수학 ::에서 BigInt는&lt;/a&gt; 이후 v1.76 가능하면 FastCalc가 자동으로로드됩니다.</target>
        </trans-unit>
        <trans-unit id="f6a562b762d80b1c79a4a2e57ae06efed1d20b20" translate="yes" xml:space="preserve">
          <source>Note that functions such as &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; may return huge lists when used on large DBM files. You may prefer to use the &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; function to iterate over large DBM files. Example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 과 같은 기능 은 큰 DBM 파일에서 사용될 때 큰 목록을 반환 할 수 있습니다. 당신은 사용하는 것이 좋습니다 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 큰 DBM 파일을 반복하는 기능. 예:</target>
        </trans-unit>
        <trans-unit id="744885e641d2306d4fbe957365af5d32ac0b76f3" translate="yes" xml:space="preserve">
          <source>Note that functions such as &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; may return huge lists when used on large objects, like DBM files. You may prefer to use the &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; function to iterate over such. Example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 과 같은 기능 은 DBM 파일과 같은 큰 객체에서 사용될 때 큰 목록을 반환 할 수 있습니다. &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 반복 하는 것을 선호 할 수 있습니다 . 예:</target>
        </trans-unit>
        <trans-unit id="72ffa6aa03e0b04398c1553e4a97b08735d3745c" translate="yes" xml:space="preserve">
          <source>Note that functions such as &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; may return huge lists when used on large DBM files. You may prefer to use the &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; function to iterate over large DBM files. Example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 과 같은 기능 은 큰 DBM 파일에서 사용될 때 큰 목록을 반환 할 수 있습니다. 당신은 사용하는 것이 좋습니다 &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 큰 DBM 파일을 반복하는 기능. 예:</target>
        </trans-unit>
        <trans-unit id="a1b483511502689b9e22b000546db0922817c2d1" translate="yes" xml:space="preserve">
          <source>Note that functions such as &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; may return huge lists when used on large objects, like DBM files. You may prefer to use the &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; function to iterate over such. Example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 과 같은 기능 은 DBM 파일과 같은 큰 객체에서 사용될 때 큰 목록을 반환 할 수 있습니다. &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 반복 하는 것을 선호 할 수 있습니다 . 예:</target>
        </trans-unit>
        <trans-unit id="ae8752600c3751f3c52b44262525865199cca383" translate="yes" xml:space="preserve">
          <source>Note that functions such as keys() and values() may return huge lists when used on large objects, like DBM files. You may prefer to use the each() function to iterate over such. Example:</source>
          <target state="translated">keys () 및 values ​​()와 같은 함수는 DBM 파일과 같은 큰 객체에서 사용될 때 큰 목록을 반환 할 수 있습니다. 이러한 반복을 위해 each () 함수를 사용하는 것이 좋습니다. 예:</target>
        </trans-unit>
        <trans-unit id="d8b624d4598897ef720d34e8f550c09e63657b83" translate="yes" xml:space="preserve">
          <source>Note that glibc &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt;, etc. are buggy before glibc version 2.17. They won't allow a &lt;code&gt;%.s&lt;/code&gt; format with a precision to create a string that isn't valid UTF-8 if the current underlying locale of the program is UTF-8. What happens is that the &lt;code&gt;%s&lt;/code&gt; and its operand are simply skipped without any notice. &lt;a href=&quot;https://sourceware.org/bugzilla/show_bug.cgi?id=6530&quot;&gt;https://sourceware.org/bugzilla/show_bug.cgi?id=6530&lt;/a&gt;.</source>
          <target state="translated">glibc &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; 등은 glibc 버전 2.17 이전에는 버그가 있습니다. 프로그램의 현재 기본 로케일이 UTF-8 인 경우 UTF-8 형식이 아닌 문자열을 정확하게 작성할 수있는 &lt;code&gt;%.s&lt;/code&gt; 형식을 허용 하지 않습니다. 결과는 &lt;code&gt;%s&lt;/code&gt; 와 피연산자가 예고없이 간단히 건너 뜁니다. &lt;a href=&quot;https://sourceware.org/bugzilla/show_bug.cgi?id=6530&quot;&gt;https://sourceware.org/bugzilla/show_bug.cgi?id=6530&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="622115f32e89cdb0d30c0373c6c70d90996631c4" translate="yes" xml:space="preserve">
          <source>Note that globbing only lists directories explicitly asked for, for example FOO/* will not list FOO/bar/Acme-Sthg-n.nn.tar.gz. This may be regarded as a bug that may be changed in some future version.</source>
          <target state="translated">globbing은 명시 적으로 요청 된 디렉토리 만 나열합니다. 예를 들어 FOO / *는 FOO / bar / Acme-Sthg-n.nn.tar.gz를 나열하지 않습니다. 이것은 향후 버전에서 변경 될 수있는 버그로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="608b43e88fa71f94e1e6a28718931116afacd602" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; needs external data for it to work, no subroutine call is possible without it. As an example, the standard debugger's &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; depends on the &lt;code&gt;$DB::deep&lt;/code&gt; variable (it defines how many levels of recursion deep into the debugger you can go before a mandatory break). If &lt;code&gt;$DB::deep&lt;/code&gt; is not defined, subroutine calls are not possible, even though &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; exists.</source>
          <target state="translated">경우주의 &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; 작업에 대한 외부 데이터를 필요로 어떤 서브 루틴 호출이 없이는 불가능합니다. 예를 들어, 표준 디버거의 &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; 는 &lt;code&gt;$DB::deep&lt;/code&gt; 변수 에 의존 합니다 (필수 중단 전에 갈 수있는 디버거 깊이의 재귀 수준을 정의합니다). 경우 &lt;code&gt;$DB::deep&lt;/code&gt; 정의되지 않은, 서브 루틴 호출에도 불구하고, 불가능 &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; 존재한다.</target>
        </trans-unit>
        <trans-unit id="ac18f8ca65d2ef342faed7220894d625a0f93e79" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;CanonicalName&lt;/code&gt; is enabled, a normalized filename will be passed to the sub.</source>
          <target state="translated">&lt;code&gt;CanonicalName&lt;/code&gt; 이 활성화 된 경우 정규화 된 파일 이름이 하위로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="5f3c24624d3659de7e4c912e62eae398eab95882" translate="yes" xml:space="preserve">
          <source>Note that if a pattern compiled within &lt;code&gt;'strict'&lt;/code&gt; is recompiled, say by interpolating into another pattern, outside of &lt;code&gt;'strict'&lt;/code&gt; , it is not checked again for strictness. This is because if it works under strict it must work under non-strict.</source>
          <target state="translated">&lt;code&gt;'strict'&lt;/code&gt; 내에서 컴파일 된 패턴 이 다시 컴파일되면 ( &lt;code&gt;'strict'&lt;/code&gt; 외부의 다른 패턴으로 보간하여) 엄격 성을 다시 확인하지 않습니다. 엄격하게 작동하는 경우 엄격하지 않은 상태에서 작동해야하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="308556457296cab4f486eee25acd00edabad2290" translate="yes" xml:space="preserve">
          <source>Note that if a string argument starts with &lt;code&gt;-&lt;/code&gt; or &lt;code&gt;--&lt;/code&gt; , it will be considered an option on itself.</source>
          <target state="translated">문자열 인수가 &lt;code&gt;-&lt;/code&gt; 또는 &lt;code&gt;--&lt;/code&gt; 시작하면 자체 옵션으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="8c44aba0e7ff586bf06544855993dee92b7ebfb4" translate="yes" xml:space="preserve">
          <source>Note that if a tainted string is added to &lt;code&gt;@INC&lt;/code&gt; , the following problem will be reported:</source>
          <target state="translated">오염 된 문자열이 &lt;code&gt;@INC&lt;/code&gt; 에 추가 되면 다음과 같은 문제가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="9afccffdaaa8763c6bff65d340b0383eec4b2bf1" translate="yes" xml:space="preserve">
          <source>Note that if a temp directory is your current directory, it cannot be removed. C</source>
          <target state="translated">임시 디렉토리가 현재 디렉토리 인 경우 제거 할 수 없습니다. 씨</target>
        </trans-unit>
        <trans-unit id="e3273fcdfd70332486252bf4b49416cc8786a3a4" translate="yes" xml:space="preserve">
          <source>Note that if an initialized scalar variable is used instead the result is different: &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $fh='zzz'; &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;($fh, ...)&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;( *{'zzz'}, ...)&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'refs'&lt;/code&gt; forbids such practice.</source>
          <target state="translated">초기화 된 스칼라 변수를 대신 사용하면 결과가 다릅니다. &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $fh='zzz'; &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;($fh, ...)&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;( *{'zzz'}, ...)&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'refs'&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용하면&lt;/a&gt; 그러한 관행을 금합니다.</target>
        </trans-unit>
        <trans-unit id="6fd8bc012a0b5fd862eb29b81c0bd7a1843836fc" translate="yes" xml:space="preserve">
          <source>Note that if multiple files are parsed for a single POD document (perhaps the result of some future &lt;code&gt;=include&lt;/code&gt; directive) this method is invoked for every file that is parsed. If you wish to perform certain initializations once per document, then you should use &lt;b&gt;begin_pod()&lt;/b&gt;.</source>
          <target state="translated">단일 POD 문서 (아마도 미래 &lt;code&gt;=include&lt;/code&gt; 지시문 의 결과)에 대해 여러 파일이 구문 분석되는 경우 구문 분석 된 모든 파일에 대해이 메소드가 호출됩니다. 문서 당 한 번 특정 초기화를 수행하려면 &lt;b&gt;begin_pod ()&lt;/b&gt; 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="826d10bf58e0edead500c1a2f5a6d8c68eb347e0" translate="yes" xml:space="preserve">
          <source>Note that if no errors are encountered, &lt;code&gt;$err&lt;/code&gt; will reference an empty array. This means that &lt;code&gt;$err&lt;/code&gt; will always end up TRUE; so you need to test &lt;code&gt;@$err&lt;/code&gt; to determine if errors occured.</source>
          <target state="translated">오류가 발생하지 않으면 &lt;code&gt;$err&lt;/code&gt; 는 빈 배열을 참조합니다. 이것은 &lt;code&gt;$err&lt;/code&gt; 가 항상 TRUE가 된다는 것을 의미 합니다. 따라서 &lt;code&gt;@$err&lt;/code&gt; 를 테스트 하여 오류가 발생했는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="1324e5c55e1f48c00e9179366ddca7ad4be15ea2" translate="yes" xml:space="preserve">
          <source>Note that if tests have a trailing plan, it is not possible to set this property for unplanned tests as we do not know it's unplanned until the plan is reached:</source>
          <target state="translated">테스트에 후행 계획이있는 경우 계획에 도달 할 때까지 계획되지 않은 것으로 알 수 없으므로 계획되지 않은 테스트에 대해이 속성을 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="58bd8c74c7de485d278dd761f4ec5c815966b6fe" translate="yes" xml:space="preserve">
          <source>Note that if the cache is a tied hash, &lt;code&gt;flush_cache&lt;/code&gt; will attempt to invoke the &lt;code&gt;CLEAR&lt;/code&gt; method on the hash. If there is no &lt;code&gt;CLEAR&lt;/code&gt; method, this will cause a run-time error.</source>
          <target state="translated">캐시가 연결 해시 인 경우 &lt;code&gt;flush_cache&lt;/code&gt; 는 해시 에서 &lt;code&gt;CLEAR&lt;/code&gt; 메소드 를 호출하려고 시도합니다 . &lt;code&gt;CLEAR&lt;/code&gt; 방법 이 없으면 런타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9c084f4d82be664fcc79d00bcef732fc1be8ca28" translate="yes" xml:space="preserve">
          <source>Note that if the filehandle has been marked as &lt;code&gt;:utf8&lt;/code&gt; Unicode characters are read instead of bytes (the LENGTH, OFFSET, and the return value of sysread() are in Unicode characters). The &lt;code&gt;:encoding(...)&lt;/code&gt; layer implicitly introduces the &lt;code&gt;:utf8&lt;/code&gt; layer. See &lt;a href=&quot;#binmode&quot;&gt;binmode&lt;/a&gt;, &lt;a href=&quot;#open&quot;&gt;open&lt;/a&gt;, and the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma, &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;.</source>
          <target state="translated">파일 핸들이 &lt;code&gt;:utf8&lt;/code&gt; 로 표시되면 바이트 대신 유니 코드 문자를 읽습니다 (LENGTH, OFFSET 및 sysread ()의 반환 값은 유니 코드 문자 임). &lt;code&gt;:encoding(...)&lt;/code&gt; 층 내재적 도입 &lt;code&gt;:utf8&lt;/code&gt; 층. &lt;a href=&quot;#binmode&quot;&gt;binmode&lt;/a&gt; , &lt;a href=&quot;#open&quot;&gt;open&lt;/a&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma, &lt;a href=&quot;open&quot;&gt;open을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6a528a8e216af2d3ed813e217add7c3fe0518eef" translate="yes" xml:space="preserve">
          <source>Note that if the filehandle has been marked as &lt;code&gt;:utf8&lt;/code&gt; Unicode characters are read instead of bytes (the LENGTH, OFFSET, and the return value of sysread() are in Unicode characters). The &lt;code&gt;:encoding(...)&lt;/code&gt; layer implicitly introduces the &lt;code&gt;:utf8&lt;/code&gt; layer. See &lt;a href=&quot;binmode&quot;&gt;binmode&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;, and the &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma, &lt;a href=&quot;../open&quot;&gt;open&lt;/a&gt;.</source>
          <target state="translated">파일 핸들이 &lt;code&gt;:utf8&lt;/code&gt; 로 표시되면 바이트 대신 유니 코드 문자를 읽습니다 (LENGTH, OFFSET 및 sysread ()의 반환 값은 유니 코드 문자 임). &lt;code&gt;:encoding(...)&lt;/code&gt; 층 내재적 도입 &lt;code&gt;:utf8&lt;/code&gt; 층. &lt;a href=&quot;binmode&quot;&gt;binmode&lt;/a&gt; , &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; 및 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma, &lt;a href=&quot;../open&quot;&gt;open을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0908e03d8ce40c7005e83d17332e47cd6f9ef387" translate="yes" xml:space="preserve">
          <source>Note that if the input text is a read-only string (i.e. a literal), no attempt is made to remove the extracted text.</source>
          <target state="translated">입력 텍스트가 읽기 전용 문자열 인 경우 (예 : 리터럴) 추출 된 텍스트를 제거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="34c9b253a358e643fbf719eebaacbe9ee361bc74" translate="yes" xml:space="preserve">
          <source>Note that if the platform doesn't have &lt;code&gt;LC_NUMERIC&lt;/code&gt; and/or &lt;code&gt;LC_MONETARY&lt;/code&gt; available or enabled, the corresponding elements of the hash will be missing.</source>
          <target state="translated">플랫폼에 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 및 / 또는 &lt;code&gt;LC_MONETARY&lt;/code&gt; 를 사용할 수 없거나 활성화 하지 않은 경우 해시의 해당 요소가 누락됩니다.</target>
        </trans-unit>
        <trans-unit id="c9c7ab75927f08e77cc4898e73b8aeda27cc0c9a" translate="yes" xml:space="preserve">
          <source>Note that if the regular expression is tainted, then Perl will die rather than calling the subroutine when the name of the subroutine is determined by the tainted data.</source>
          <target state="translated">정규식이 오염 된 경우 서브 루틴의 이름이 오염 된 데이터에 의해 결정될 때 서브 루틴을 호출하는 대신 Perl이 죽습니다.</target>
        </trans-unit>
        <trans-unit id="2b2dc5e51258adfa883882440e13a3cae6f294a4" translate="yes" xml:space="preserve">
          <source>Note that if the version of the PM module is an NV (a floating point number), it will be stringified with a possible loss of precision (currently chopping to nine decimal places) so that it may not match the version of the XS module anymore. Quoting the $VERSION declaration to make it a string is recommended if long version numbers are used.</source>
          <target state="translated">PM 모듈의 버전이 NV (부동 소수점 수) 인 경우, 더 이상 XS 모듈의 버전과 일치하지 않도록 가능한 정밀도 손실 (현재는 소수점 이하 9 자리까지 잘림)로 문자열 화됩니다. . 긴 버전 번호를 사용하는 경우 $ VERSION 선언을 인용하여 문자열로 만드는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6c6048c09fbd601d5bded4c49f7b53cc961721c5" translate="yes" xml:space="preserve">
          <source>Note that if there was a subroutine call between us and line 29, and we wanted to &lt;b&gt;single-step&lt;/b&gt; through it, we could use the '&lt;b&gt;s&lt;/b&gt;' command, and to step over it we would use '&lt;b&gt;n&lt;/b&gt;' which would execute the sub, but not descend into it for inspection. In this case though, we simply continue down to line 29:</source>
          <target state="translated">우리와 29 행 사이에 서브 루틴 호출이 있고, 이를 통해 &lt;b&gt;단일 단계&lt;/b&gt; 를 &lt;b&gt;수행&lt;/b&gt; 하고자 한다면 ' &lt;b&gt;s&lt;/b&gt; '명령을 사용할 수 있고, 그 단계를 넘어 서기 위해 서브를 실행하는 ' &lt;b&gt;n&lt;/b&gt; '을 사용할 것입니다. 검사를 위해 내려 가지 않습니다. 이 경우, 우리는 단순히 29 행까지 계속합니다 :</target>
        </trans-unit>
        <trans-unit id="9f3dd1e37239e5e6990e5357970b72eac4a59098" translate="yes" xml:space="preserve">
          <source>Note that if there were a &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block on the above, it would get executed even on discarded lines. If LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; EXPR&lt;/code&gt; form, available as of Perl 5.18.0, allows a label name to be computed at run time, being otherwise identical to &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; LABEL&lt;/code&gt; .</source>
          <target state="translated">위 의 &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 블록 이 있으면 버려진 행에서도 실행됩니다. LABEL을 생략하면 명령은 가장 안쪽의 루프를 나타냅니다. &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; EXPR&lt;/code&gt; 펄 5.18.0의로 제공 형태는, 레이블 이름을 달리 동일한되고, 런타임에 계산 될 수 있도록 &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; LABEL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60ee3cf42536d2e0cc61b8039c6f1a0a75072a6a" translate="yes" xml:space="preserve">
          <source>Note that if there were a &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block on the above code, it would get executed only on lines discarded by the regex (since redo skips the continue block). A continue block is often used to reset line counters or &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m?pat?&lt;/a&gt;&lt;/code&gt; one-time matches:</source>
          <target state="translated">위의 코드에 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 블록 이 있으면 , redex가 continue 블록을 건너 뛰기 때문에 정규식에 의해 삭제 된 행에서만 실행됩니다. 연속 블록은 종종 라인 카운터 또는 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m?pat?&lt;/a&gt;&lt;/code&gt; 일회성 일치 :</target>
        </trans-unit>
        <trans-unit id="03cca16cecaf26d400e510c53bbfbaac8d0326bf" translate="yes" xml:space="preserve">
          <source>Note that if there were a &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block on the above, it would get executed even on discarded lines. If LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; EXPR&lt;/code&gt; form, available as of Perl 5.18.0, allows a label name to be computed at run time, being otherwise identical to &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; LABEL&lt;/code&gt; .</source>
          <target state="translated">위 의 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 블록 이 있으면 버려진 행에서도 실행됩니다. LABEL을 생략하면 명령은 가장 안쪽의 루프를 나타냅니다. &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; EXPR&lt;/code&gt; 펄 5.18.0의로 제공 형태는, 레이블 이름을 달리 동일한되고, 런타임에 계산 될 수 있도록 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; LABEL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d19c5d18d3d9efa0c0b12037ddf03239e4ec1d14" translate="yes" xml:space="preserve">
          <source>Note that if this module is imported when &lt;a href=&quot;../threads&quot;&gt;threads&lt;/a&gt; has not yet been loaded, then these functions all become no-ops. This makes it possible to write modules that will work in both threaded and non-threaded environments.</source>
          <target state="translated">&lt;a href=&quot;../threads&quot;&gt;스레드&lt;/a&gt; 가 아직로드되지 않은 상태 에서이 모듈을 가져 오면 이러한 기능이 모두 작동하지 않습니다. 이를 통해 스레드 환경과 스레드되지 않은 환경 모두에서 작동하는 모듈을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a67c2908702a6cdf59ca28b987d8e4a389fc1fa9" translate="yes" xml:space="preserve">
          <source>Note that if this operator is used and NOT inside of an alternation then it acts exactly like the &lt;code&gt;(*PRUNE)&lt;/code&gt; operator.</source>
          <target state="translated">이 연산자를 교대로 사용하지 않고 사용하면 &lt;code&gt;(*PRUNE)&lt;/code&gt; 연산자 와 똑같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="fdc2bfbf6748eacea8c87035966d754d0f68c5a3" translate="yes" xml:space="preserve">
          <source>Note that if using gcc, starting from Perl 5.9.5 the Perl core source code files (the ones at the top level of the source code distribution, but not e.g. the extensions under ext/) are automatically compiled with as many as possible of the &lt;code&gt;-std=c89&lt;/code&gt; , &lt;code&gt;-ansi&lt;/code&gt; , &lt;code&gt;-pedantic&lt;/code&gt; , and a selection of &lt;code&gt;-W&lt;/code&gt; flags (see cflags.SH).</source>
          <target state="translated">gcc를 사용하는 경우 Perl 5.9.5부터 Perl 코어 소스 코드 파일 (소스 코드 배포의 최상위 레벨에 있지만 ext / 아래의 확장자는 아님)은 가능한 한 많은 파일로 자동 컴파일됩니다. &lt;code&gt;-std=c89&lt;/code&gt; , &lt;code&gt;-ansi&lt;/code&gt; , &lt;code&gt;-pedantic&lt;/code&gt; 및 &lt;code&gt;-W&lt;/code&gt; 플래그 선택 (cflags.SH 참조)</target>
        </trans-unit>
        <trans-unit id="dfe5b081a33f6efff2f505814c3590456b24ec50" translate="yes" xml:space="preserve">
          <source>Note that if you do not have Module::Signature installed, no signature checks will be performed at all.</source>
          <target state="translated">Module :: Signature가 설치되어 있지 않으면 서명 확인이 전혀 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7890360c193f0760d43a2add9be2d600e6cb6a32" translate="yes" xml:space="preserve">
          <source>Note that if you do not plan to build the perl itself, it may be possible to fool EMX to truncate file names. This is not supported, read EMX docs to see how to do it.</source>
          <target state="translated">perl 자체를 빌드하지 않으려는 경우 EMX를 속여서 파일 이름을자를 수 있습니다. 이 기능은 지원되지 않습니다. EMX 문서를 읽고 방법을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="7074505ed79917df5e0904da32c456ed53b1b35d" translate="yes" xml:space="preserve">
          <source>Note that if you have</source>
          <target state="translated">가지고 있다면</target>
        </trans-unit>
        <trans-unit id="16452a0ac87813870c05c7095ba75ee11a8d9c6d" translate="yes" xml:space="preserve">
          <source>Note that if you have bytes with the eighth bit on in your script (for example embedded Latin-1 in your string literals), &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; will be unhappy since the bytes are most probably not well-formed UTF-X. If you want to have such bytes under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; , you can disable this pragma until the end the block (or file, if at top level) by &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; utf8;&lt;/code&gt; .</source>
          <target state="translated">스크립트에 8 번째 비트가있는 바이트가있는 경우 (예 : 문자열 리터럴에 Latin-1이 포함 된 경우) 바이트가 제대로 구성되지 않은 UTF-X이므로 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 을 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하면 불행합니다. 당신이 아래 같은 바이트 갖고 싶어 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; , 당신은 (또는 파일 최상위 레벨에있는 경우) 마지막 블록까지이 pragma를 사용하지 않도록 설정할 수 있습니다하여 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; utf8;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c4aa42b29cc2c2cbee7d6400738523e5bb46393" translate="yes" xml:space="preserve">
          <source>Note that if you have chdir'ed into the temporary directory and it is subsequently cleaned up (either in the END block or as part of object destruction), then you will get a warning from File::Path::rmtree().</source>
          <target state="translated">임시 디렉토리에 chdir을했고 그 후에 END 블록에서 또는 오브젝트 삭제의 일부로 정리 된 경우 File :: Path :: rmtree ()에서 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f635910faf20c1937408464313d28376fda868a1" translate="yes" xml:space="preserve">
          <source>Note that if you have to look for strings that you don't know till runtime, you can build an entire loop as a string and &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; that to avoid recompiling all your patterns all the time. Together with undefining &lt;code&gt;$/&lt;/code&gt; to input entire files as one record, this can be quite fast, often faster than specialized programs like fgrep(1). The following scans a list of files (&lt;code&gt;@files&lt;/code&gt; ) for a list of words (&lt;code&gt;@words&lt;/code&gt; ), and prints out the names of those files that contain a match:</source>
          <target state="translated">런타임까지 모르는 문자열을 찾아야하는 경우 모든 패턴을 항상 다시 컴파일하지 않도록 전체 루프를 문자열과 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 로 빌드 할 수 있습니다 . &lt;code&gt;$/&lt;/code&gt; 를 정의하지 않고 전체 파일을 하나의 레코드로 입력하면 fgrep (1)과 같은 특수 프로그램보다 훨씬 빠릅니다. 다음은 파일 목록 ( &lt;code&gt;@files&lt;/code&gt; )에서 단어 목록 ( &lt;code&gt;@words&lt;/code&gt; )을 검색하고 일치하는 파일이있는 파일의 이름을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="563eabb7ceca135c66cd9da9fa7638ecd48fe576" translate="yes" xml:space="preserve">
          <source>Note that if you have to look for strings that you don't know till runtime, you can build an entire loop as a string and &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; that to avoid recompiling all your patterns all the time. Together with undefining &lt;code&gt;$/&lt;/code&gt; to input entire files as one record, this can be quite fast, often faster than specialized programs like fgrep(1). The following scans a list of files (&lt;code&gt;@files&lt;/code&gt; ) for a list of words (&lt;code&gt;@words&lt;/code&gt; ), and prints out the names of those files that contain a match:</source>
          <target state="translated">런타임까지 모르는 문자열을 찾아야하는 경우 모든 패턴을 항상 다시 컴파일하지 않도록 전체 루프를 문자열과 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 로 빌드 할 수 있습니다 . &lt;code&gt;$/&lt;/code&gt; 를 정의하지 않고 전체 파일을 하나의 레코드로 입력하면 fgrep (1)과 같은 특수 프로그램보다 훨씬 빠릅니다. 다음은 파일 목록 ( &lt;code&gt;@files&lt;/code&gt; )에서 단어 목록 ( &lt;code&gt;@words&lt;/code&gt; )을 검색하고 일치하는 파일이있는 파일의 이름을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="472f29cb35dcdd9e0bdaee6718ec77f646cf840a" translate="yes" xml:space="preserve">
          <source>Note that if you take a copy of a scalar with a weakened reference, the copy will be a strong reference.</source>
          <target state="translated">참조가 약한 스칼라 사본을 가져 오면 사본이 강력하게 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="c4a0c1fef1effc8f82cf7edc96e6b440867de0be" translate="yes" xml:space="preserve">
          <source>Note that if you want to do a batch conversion of a lot of Pod documents to HTML, you should see the module &lt;a href=&quot;htmlbatch&quot;&gt;Pod::Simple::HTMLBatch&lt;/a&gt;.</source>
          <target state="translated">많은 포드 문서를 HTML로 일괄 변환하려면 &lt;a href=&quot;htmlbatch&quot;&gt;Pod :: Simple :: HTMLBatch&lt;/a&gt; 모듈이 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="bef8dc28c2922471f2bbf667ac531cc355fd0094" translate="yes" xml:space="preserve">
          <source>Note that if you want to enable a warnings category registered by a module (e.g. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'File::Find'&lt;/code&gt; ), you must have loaded this module first.</source>
          <target state="translated">모듈에 의해 등록 된 경고 범주를 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'File::Find'&lt;/code&gt; (예 : 경고 'File :: Find'사용 )이 모듈을 먼저로드해야합니다.</target>
        </trans-unit>
        <trans-unit id="5645d5d10ea8883aafab68e6dc7420fa5396f224" translate="yes" xml:space="preserve">
          <source>Note that if you want to pass on any elements of the C-local environ array to a subprocess which isn't started by fork/exec, or isn't running a C program, you can &quot;promote&quot; them to logical names in the current process, which will then be inherited by all subprocesses, by saying</source>
          <target state="translated">C-local environ 배열의 요소를 fork / exec로 시작하지 않거나 C 프로그램을 실행하지 않는 서브 프로세스로 전달하려는 경우, 이들을 논리 이름으로 &quot;승격&quot;할 수 있습니다. 현재 프로세스는 모든 하위 프로세스에 의해 다음과 같이 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="438e992f414c0fb7d0ae67132225f8fb511bf800" translate="yes" xml:space="preserve">
          <source>Note that if you're using Windows, no solution to this vexing issue is even possible. Even though Perl emulates &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt;, you'll still be stuck, because Windows does not have an argc/argv-style API.</source>
          <target state="translated">Windows를 사용하는 경우이 문제에 대한 해결책은 없습니다. Perl이 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 에뮬레이트하더라도 Windows에는 argc / argv 스타일 API가 없기 때문에 여전히 멈출 것입니다.</target>
        </trans-unit>
        <trans-unit id="631593fdac38ac18af70717272a4671c53190f39" translate="yes" xml:space="preserve">
          <source>Note that if your forked child inherits system file descriptors like STDIN and STDOUT that are actually connected by a pipe or socket, even if you exit, then the remote server (such as, say, a CGI script or a backgrounded job launched from a remote shell) won't think you're done. You should reopen those to</source>
          <target state="translated">분기 된 자식이 파이프 나 소켓으로 실제로 연결된 STDIN 및 STDOUT과 같은 시스템 파일 설명자를 상속하는 경우 종료하더라도 원격 서버 (예 : CGI 스크립트 또는 원격에서 실행 된 백그라운드 작업) 쉘) 당신이 끝났다고 생각하지 않습니다. 당신은 그들을 다시 열어야합니다</target>
        </trans-unit>
        <trans-unit id="70eb4fc52446e8c7cd71ef0fc3bcc0bd68008c67" translate="yes" xml:space="preserve">
          <source>Note that in Perl 5.17.3 and earlier, the last three constants were also used for the caret variants of the variables.</source>
          <target state="translated">Perl 5.17.3 및 이전 버전에서는 마지막 세 상수가 변수의 캐럿 변형에도 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="8b6ec9401ff25a7e7f20f8f508c8e573ab6cef28" translate="yes" xml:space="preserve">
          <source>Note that in Perl version prior to 5.18 inheritance of the &lt;code&gt;fallback&lt;/code&gt; key was not governed by the above rules. The value of &lt;code&gt;fallback&lt;/code&gt; in the first overloaded ancestor was used. This was fixed in 5.18 to follow the usual rules of inheritance.</source>
          <target state="translated">5.18 이전의 Perl 버전에서 &lt;code&gt;fallback&lt;/code&gt; 키의 상속은 위의 규칙에 의해 통제되지 않았습니다. 오버로드 된 첫 번째 조상 의 &lt;code&gt;fallback&lt;/code&gt; 값 이 사용되었습니다. 이것은 일반적인 상속 규칙을 따르기 위해 5.18에서 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="7dadc679f5466d79da0156797f6b8d65ca1758f1" translate="yes" xml:space="preserve">
          <source>Note that in a few cases this translation can't be perfectly carried back into the source code -- if the loop's initializer declares a my variable, for instance, it won't have the correct scope outside of the loop.</source>
          <target state="translated">경우에 따라이 변환을 소스 코드로 완벽하게 다시 전달할 수 없습니다. 예를 들어 루프의 이니셜 라이저가 내 변수를 선언하면 루프 외부에 올바른 범위가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5bedfdd7af45ab7b673c4a8860ff4cc65683c959" translate="yes" xml:space="preserve">
          <source>Note that in a list context, the contents of the original input text (the first argument) are not modified in any way.</source>
          <target state="translated">목록 컨텍스트에서 원래 입력 텍스트 (첫 번째 인수)의 내용은 어떤 식 으로든 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="19da40726b3583f6544a1c2e542496723da7a424" translate="yes" xml:space="preserve">
          <source>Note that in all cases of &quot;E&amp;lt;whatever&amp;gt;&quot;,</source>
          <target state="translated">&quot;E &amp;lt;whatever&amp;gt;&quot;의 모든 경우에</target>
        </trans-unit>
        <trans-unit id="9e72d3882d1c9bd4efe9fc3533a3f5c9da90ccbc" translate="yes" xml:space="preserve">
          <source>Note that in contrast with &lt;a href=&quot;#EXAMPLE-1&quot;&gt;EXAMPLE 1&lt;/a&gt;, &lt;a href=&quot;#EXAMPLE-2&quot;&gt;EXAMPLE 2&lt;/a&gt; and &lt;a href=&quot;#EXAMPLE-3&quot;&gt;EXAMPLE 3&lt;/a&gt;, this description does not contain the actual</source>
          <target state="translated">대조적으로 참고 &lt;a href=&quot;#EXAMPLE-1&quot;&gt;예 1&lt;/a&gt; , &lt;a href=&quot;#EXAMPLE-2&quot;&gt;실시 예 2&lt;/a&gt; 및 &lt;a href=&quot;#EXAMPLE-3&quot;&gt;실시 예 3은&lt;/a&gt; , 이러한 설명은 실제가 포함되지 않은</target>
        </trans-unit>
        <trans-unit id="cc47544345a2ab281008488b23e05567f0a20d81" translate="yes" xml:space="preserve">
          <source>Note that in older versions of this module, the &lt;code&gt;error()&lt;/code&gt; method would return an effectively global value even when called an instance method as above. This has since been fixed, and multiple instances of &lt;code&gt;Archive::Tar&lt;/code&gt; now have separate error strings.</source>
          <target state="translated">이 모듈의 이전 버전에서 &lt;code&gt;error()&lt;/code&gt; 메소드는 위와 같이 인스턴스 메소드를 호출하더라도 효과적으로 글로벌 값을 리턴합니다. 그 이후 &lt;code&gt;Archive::Tar&lt;/code&gt; 되었으며 이제 여러 개의 Archive :: Tar 인스턴스에 별도의 오류 문자열이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8bd3a3217fec8f830ea11bdf3eeaefb81cab80f" translate="yes" xml:space="preserve">
          <source>Note that in scalar and void contexts the value of this argument is automatically reset to 1 (under &lt;code&gt;-w&lt;/code&gt; , a warning is issued if the argument has to be reset).</source>
          <target state="translated">스칼라 및 void 컨텍스트에서이 인수의 값은 자동으로 1로 재설정됩니다 ( &lt;code&gt;-w&lt;/code&gt; 에서 인수를 재설정해야하는 경우 경고가 발행 됨).</target>
        </trans-unit>
        <trans-unit id="41929543f660fb86d6970d86dc2f5cfae1674011" translate="yes" xml:space="preserve">
          <source>Note that in the above cases, &lt;code&gt;thing($foo)&lt;/code&gt; and &lt;code&gt;thing($bar)&lt;/code&gt;</source>
          <target state="translated">위의 경우, &lt;code&gt;thing($foo)&lt;/code&gt; 및 &lt;code&gt;thing($bar)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2e34b6badd14d9162b8051b5a13e0d935b53fb3b" translate="yes" xml:space="preserve">
          <source>Note that install() gives no meaningful return value. See uptodate().</source>
          <target state="translated">install ()은 의미있는 반환 값을 제공하지 않습니다. uptodate ()를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5f8451b3868737fe3b564168fce4efa0bb98f6a4" translate="yes" xml:space="preserve">
          <source>Note that it is a fatal error for any method (including &lt;code&gt;AUTOLOAD&lt;/code&gt; ) to attempt to redispatch any method that does not have the same name. For example:</source>
          <target state="translated">모든 메소드 ( &lt;code&gt;AUTOLOAD&lt;/code&gt; 포함 )가 동일한 이름을 갖지 않는 메소드를 재발송하려고 하면 치명적인 오류입니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="01d339e0f582d233719162f7a04439bf08b5fc04" translate="yes" xml:space="preserve">
          <source>Note that it is generally not a good idea to try to build a perl with INST_DRV and INST_TOP set to a path that already exists from a previous build. In particular, this may cause problems with the lib/ExtUtils/t/Embed.t test, which attempts to build a test program and may end up building against the installed perl's lib/CORE directory rather than the one being tested.</source>
          <target state="translated">INST_DRV 및 INST_TOP을 이전 빌드에서 이미 존재하는 경로로 설정하여 perl을 빌드하는 것은 일반적으로 좋지 않습니다. 특히, 이로 인해 lib / ExtUtils / t / Embed.t 테스트에 문제가 발생하여 테스트 프로그램을 빌드하려고 시도하고 테스트중인 디렉토리가 아닌 설치된 perl의 lib / CORE 디렉토리에 대해 빌드를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="399a43994f597fec22280e4ffa2bc677a89fdfb6" translate="yes" xml:space="preserve">
          <source>Note that it is important to quote the __CALLER__::Roo identifier because a bug in perl 5.8 will refuse to parse it and cause an unknown error.</source>
          <target state="translated">perl 5.8의 버그는 구문 분석을 거부하고 알 수없는 오류가 발생하기 때문에 __CALLER __ :: Roo 식별자를 인용하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="7affed7382c3656cc0a49bfbc4f14899cf69001a" translate="yes" xml:space="preserve">
          <source>Note that it is not advisable to access a file handle within a signal handler where that signal has interrupted an I/O operation on that same handle. While perl will at least try hard not to crash, there are no guarantees of data integrity; for example, some data might get dropped or written twice.</source>
          <target state="translated">신호가 동일한 핸들에서 I / O 조작을 인터럽트 한 신호 핸들러 내에서 파일 핸들에 액세스하는 것은 권장되지 않습니다. perl은 최소한 충돌하지 않도록 노력하지만 데이터 무결성을 보장하지는 않습니다. 예를 들어 일부 데이터는 삭제되거나 두 번 쓰여질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d3396c1176b4f12172442de7b35ea46ac2562aa" translate="yes" xml:space="preserve">
          <source>Note that it is not necessary to call &lt;code&gt;PUSHMARK&lt;/code&gt; in this instance. This is because</source>
          <target state="translated">이 경우 &lt;code&gt;PUSHMARK&lt;/code&gt; 를 호출 할 필요는 없습니다 . 이 때문입니다</target>
        </trans-unit>
        <trans-unit id="2b288b308a1bd032de8fa4a9b9c0a2a922d5b4a8" translate="yes" xml:space="preserve">
          <source>Note that it is okay to create a library which contains a dependent library that is already linked into perl.</source>
          <target state="translated">이미 perl에 링크 된 종속 라이브러리를 포함하는 라이브러리를 작성해도됩니다.</target>
        </trans-unit>
        <trans-unit id="020e05231aab23e5af6e78f2d08d9849390e5ac0" translate="yes" xml:space="preserve">
          <source>Note that it is possible to have &lt;code&gt;__DATA__&lt;/code&gt; tokens in the same package in multiple files, and that the last &lt;code&gt;__DATA__&lt;/code&gt; token in a given package that is encountered by the compiler is the one accessible by the filehandle. This also applies to &lt;code&gt;__END__&lt;/code&gt; and main, i.e. if the 'main' program has an &lt;code&gt;__END__&lt;/code&gt; , but a module 'require'd (_not_ 'use'd) by that program has a 'package main;' declaration followed by an '&lt;code&gt;__DATA__&lt;/code&gt; ', then the &lt;code&gt;DATA&lt;/code&gt; filehandle is set to access the data after the &lt;code&gt;__DATA__&lt;/code&gt; in the module, _not_ the data after the &lt;code&gt;__END__&lt;/code&gt; token in the 'main' program, since the compiler encounters the 'require'd file later.</source>
          <target state="translated">여러 파일의 동일한 패키지에 &lt;code&gt;__DATA__&lt;/code&gt; 토큰 을 보유 할 수 있으며 컴파일러에서 발생하는 지정된 패키지 의 마지막 &lt;code&gt;__DATA__&lt;/code&gt; 토큰은 파일 핸들로 액세스 할 수있는 토큰입니다. 이는 &lt;code&gt;__END__&lt;/code&gt; 및 main 에도 적용됩니다 . 즉, 'main'프로그램에 &lt;code&gt;__END__&lt;/code&gt; 가 있지만 해당 프로그램에서 '필수'(_not_ 'use'd) 한 모듈에'package main; '이있는 경우 선언은 &quot;다음 &lt;code&gt;__DATA__&lt;/code&gt; '이면, &lt;code&gt;DATA&lt;/code&gt; 의 핸들이 데이터 후의 액세스로 설정 &lt;code&gt;__DATA__&lt;/code&gt; 애프터 데이터 들여지지 모듈에 &lt;code&gt;__END__&lt;/code&gt; 컴파일러가&quot;필요 &quot;가 발생하기 때문에,&quot;메인 &quot;프로그램 토큰d 나중에 파일.</target>
        </trans-unit>
        <trans-unit id="e02a747b9a7a24aeffcddaceb1b0a554d3946c9f" translate="yes" xml:space="preserve">
          <source>Note that it is possible to write portable code for these by specifying things in Unicode numbers, and using a conversion function:</source>
          <target state="translated">유니 코드 숫자로 항목을 지정하고 변환 함수를 사용하여 이식 가능한 코드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="597951c8ec638d515f08de4fa8f2ce8a96e0a9a0" translate="yes" xml:space="preserve">
          <source>Note that it is probably meaningless to call the functions overload::constant() and overload::remove_constant() from anywhere but import() and unimport() methods. From these methods they may be called as</source>
          <target state="translated">import () 및 unimport () 메소드가 아닌 어디에서나 함수 overload :: constant () 및 overload :: remove_constant ()를 호출하는 것은 의미가 없습니다. 이 방법들로부터 그것들은</target>
        </trans-unit>
        <trans-unit id="b593f41651d7a872851c870e53e6652c0659531a" translate="yes" xml:space="preserve">
          <source>Note that it isn't a good idea to specify these types of ranges anyway.</source>
          <target state="translated">어쨌든 이러한 유형의 범위를 지정하는 것은 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5dd80f85677999c53d6b25deeca079eeb865515a" translate="yes" xml:space="preserve">
          <source>Note that it only confirms the bare minimum structure (so as not to get confused by derived classes which may contain additional hash entries):</source>
          <target state="translated">추가 해시 항목이 포함될 수있는 파생 클래스에 의해 혼동되지 않도록 최소한의 구조 만 확인합니다.</target>
        </trans-unit>
        <trans-unit id="e50d411d2523ee4ff5b0357ec19f1bfed82fa0ca" translate="yes" xml:space="preserve">
          <source>Note that it's perfectly acceptable for some lines to have test numbers and others to not have them. However, when a test number is found, it must be in sequence. The following is also an error:</source>
          <target state="translated">일부 라인에는 테스트 번호가 있고 다른 라인에는 테스트 번호가 없어도됩니다. 그러나 테스트 번호가 발견되면 순서대로 표시되어야합니다. 다음도 오류입니다.</target>
        </trans-unit>
        <trans-unit id="9a913045922e1a369e32f6e9094b0a8adfbe43e8" translate="yes" xml:space="preserve">
          <source>Note that it's possible to confuse Perl into thinking &lt;code&gt;//&lt;/code&gt; (the empty regex) is really &lt;code&gt;//&lt;/code&gt; (the defined-or operator). Perl is usually pretty good about this, but some pathological cases might trigger this, such as &lt;code&gt;$x///&lt;/code&gt; (is that &lt;code&gt;($x) / (//)&lt;/code&gt; or &lt;code&gt;$x // /&lt;/code&gt; ?) and &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; $fh //&lt;/code&gt; (&lt;code&gt;print $fh(//&lt;/code&gt; or &lt;code&gt;print($fh //&lt;/code&gt;?). In all of these examples, Perl will assume you meant defined-or. If you meant the empty regex, just use parentheses or spaces to disambiguate, or even prefix the empty regex with an &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; (so &lt;code&gt;//&lt;/code&gt; becomes &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;//&lt;/code&gt; (빈 정규식)은 실제로 &lt;code&gt;//&lt;/code&gt; (정의 된 또는 연산자) 라는 생각으로 Perl을 혼동 할 수 있습니다 . 펄은 일반적으로 이것에 대해 꽤 좋은,하지만 몇 가지 병적 인 경우는 같은이를 트리거 할 수 &lt;code&gt;$x///&lt;/code&gt; (입니다 &lt;code&gt;($x) / (//)&lt;/code&gt; 또는 &lt;code&gt;$x // /&lt;/code&gt; ?) 및 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; $fh //&lt;/code&gt; ( &lt;code&gt;print $fh(//&lt;/code&gt; or &lt;code&gt;print($fh //&lt;/code&gt; ?).이 모든 예에서 Perl은 정의 된 것으로 가정하거나 빈 정규식을 의미하는 경우 괄호 나 공백을 사용하여 명확하게하거나 접두사를 붙입니다. 빈 정규 표현식은 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 으로 (따라서 &lt;code&gt;//&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="830a684c09bf9bdd212ea3a74c23e24fe820c679" translate="yes" xml:space="preserve">
          <source>Note that just as in C, Perl doesn't define &lt;b&gt;when&lt;/b&gt; the variable is incremented or decremented. You just know it will be done sometime before or after the value is returned. This also means that modifying a variable twice in the same statement will lead to undefined behavior. Avoid statements like:</source>
          <target state="translated">C에서와 마찬가지로 Perl은 변수가 증가 또는 감소되는 &lt;b&gt;시기를&lt;/b&gt; 정의하지 않습니다 . 값이 반환되기 전이나 후에 언젠가 수행 될 것입니다. 이는 또한 동일한 명령문에서 변수를 두 번 수정하면 정의되지 않은 동작이 발생 함을 의미합니다. 다음과 같은 진술을 피하십시오.</target>
        </trans-unit>
        <trans-unit id="a43f2c8c90c96b6a2393740d3a2acc243f34fc78" translate="yes" xml:space="preserve">
          <source>Note that just because a hash is initialized in that order doesn't mean that it comes out in that order. See &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt; for examples of how to arrange for an output ordering.</source>
          <target state="translated">해시가 그 순서대로 초기화되었다고해서 그 순서대로 나오는 것은 아닙니다. 출력 순서를 정렬하는 방법에 대한 예는 &lt;a href=&quot;functions/sort&quot;&gt;정렬&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c24181c497b3bc3da696d72d56d3b63ee4e8b425" translate="yes" xml:space="preserve">
          <source>Note that like all the punctuation variables, you cannot currently use my() on &lt;code&gt;$^W&lt;/code&gt; , only local().</source>
          <target state="translated">모든 문장 부호 변수와 마찬가지로 현재 &lt;code&gt;$^W&lt;/code&gt; 에서 my ()를 사용할 수 없으며 local () 만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="065e7735efe282ba9a9b62697058bf416b3fcc20" translate="yes" xml:space="preserve">
          <source>Note that macros &lt;code&gt;ST(i)&lt;/code&gt; , &lt;code&gt;XST_m*()&lt;/code&gt; and &lt;code&gt;XSRETURN*()&lt;/code&gt; work equally well in CODE: sections and PPCODE: sections.</source>
          <target state="translated">매크로 &lt;code&gt;ST(i)&lt;/code&gt; , &lt;code&gt;XST_m*()&lt;/code&gt; 및 &lt;code&gt;XSRETURN*()&lt;/code&gt; 은 CODE : 섹션 및 PPCODE : 섹션에서 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c14a124574e395835da21cb4f1ebabcb93935e43" translate="yes" xml:space="preserve">
          <source>Note that most Unicode characters don't have a decomposition, so their decomposition type is &lt;code&gt;&quot;None&quot;&lt;/code&gt; .</source>
          <target state="translated">대부분의 유니 코드 문자에는 분해가 없으므로 분해 유형은 &lt;code&gt;&quot;None&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="de00dbea9481bda931fa7e30e09096749bd42bf3" translate="yes" xml:space="preserve">
          <source>Note that multiple &quot;front-ends&quot; can latch into this debugging API simultaneously. This is intended to facilitate things like debugging with a command line and GUI at the same time, debugging debuggers etc. [Sounds nice, but this needs some serious support -- GSAR]</source>
          <target state="translated">여러 &quot;프론트 엔드&quot;가이 디버깅 API에 동시에 래치 될 수 있습니다. 이것은 명령 행과 GUI를 이용한 디버깅, 디버거 디버깅 등을 용이하게하기위한 것입니다. [소리가 좋긴하지만, 심각한 지원이 필요합니다-GSAR]</target>
        </trans-unit>
        <trans-unit id="e6f8eb704c4d9544e078aafe993c9c4db8549a7e" translate="yes" xml:space="preserve">
          <source>Note that neither the &lt;b&gt;-w&lt;/b&gt; flag or the &lt;code&gt;$^W&lt;/code&gt; can be used to disable/enable default warnings. They are still mandatory in this case.</source>
          <target state="translated">참고도 있음을 &lt;b&gt;-w&lt;/b&gt; 플래그 또는 &lt;code&gt;$^W&lt;/code&gt; 비활성화하는 데 사용 될 수 / 기본 경고를 할 수 있습니다. 이 경우에는 여전히 필수입니다.</target>
        </trans-unit>
        <trans-unit id="1452a217985729ac34f931918ed05a2f231bb7c5" translate="yes" xml:space="preserve">
          <source>Note that not all &lt;code&gt;siginfo&lt;/code&gt; values make sense simultaneously (some are valid only for certain signals, for example), and not all values make sense from Perl perspective, you should to consult your system's &lt;code&gt;sigaction&lt;/code&gt; and possibly also &lt;code&gt;siginfo&lt;/code&gt; documentation.</source>
          <target state="translated">모든 &lt;code&gt;siginfo&lt;/code&gt; 값이 동시에 의미가있는 것은 아니며 (일부 신호는 특정 신호에만 유효 함) Perl의 관점에서 모든 값이 의미가있는 것은 아닙니다. 시스템의 &lt;code&gt;sigaction&lt;/code&gt; 및 &lt;code&gt;siginfo&lt;/code&gt; 문서 를 참조해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7821dfbc405ad5ec367d208589dca3baa4ef11c2" translate="yes" xml:space="preserve">
          <source>Note that not all attributes are supported by all terminal types, and some terminals may not support any of these sequences. Dark and faint, italic, blink, and concealed in particular are frequently not implemented.</source>
          <target state="translated">모든 속성이 모든 터미널 유형에서 지원되는 것은 아니며 일부 터미널은 이러한 시퀀스를 지원하지 않을 수도 있습니다. 어둡고 희미한, 기울임 꼴, 깜박임 및 은폐는 종종 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dd77ba7655fe65f19331164b0a905a5ad5a97693" translate="yes" xml:space="preserve">
          <source>Note that not all displays are ISO 6429-compliant, or even X3.64-compliant (or are even attempting to be so). This module will not work as expected on displays that do not honor these escape sequences, such as cmd.exe, 4nt.exe, and command.com under either Windows NT or Windows 2000. They may just be ignored, or they may display as an ESC character followed by some apparent garbage.</source>
          <target state="translated">모든 디스플레이가 ISO 6429와 호환되거나 X3.64와 호환되는 것은 아닙니다 (또는 그렇게 시도하고 있음). 이 모듈은 Windows NT 또는 Windows 2000의 cmd.exe, 4nt.exe 및 command.com과 같은 이스케이프 시퀀스를 따르지 않는 디스플레이에서는 예상대로 작동하지 않습니다. 무시되거나 다음과 같이 표시 될 수 있습니다. 명백한 쓰레기가 뒤 따르는 ESC 문자.</target>
        </trans-unit>
        <trans-unit id="9d7626cfa2c8cb10194e8906a42cfb46307be1b7" translate="yes" xml:space="preserve">
          <source>Note that not all features of Perl are available under these environments. This depends on the features the</source>
          <target state="translated">이러한 환경에서 Perl의 모든 기능을 사용할 수있는 것은 아닙니다. 이것은 기능에 따라 다릅니다</target>
        </trans-unit>
        <trans-unit id="6d4d9996a72da721566e95c9b8f64cec116b411b" translate="yes" xml:space="preserve">
          <source>Note that not all incompatibilities are found.</source>
          <target state="translated">모든 비 호환성이 발견되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e354090ffbf1edbb380e0fa597ae3be4af6cb16d" translate="yes" xml:space="preserve">
          <source>Note that not all modules will work with on all platforms. See &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for more information on portability issues. Read the documentation to see if the module will work on your system. There are basically three categories of modules that will not work &quot;out of the box&quot; with all platforms (with some possibility of overlap):</source>
          <target state="translated">모든 모듈이 모든 플랫폼에서 작동하는 것은 아닙니다. 이식성 문제에 대한 자세한 내용 은 &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; 를 참조하십시오 . 설명서를 읽고 시스템에서 모듈이 작동하는지 확인하십시오. 기본적으로 모든 플랫폼에서 &quot;바로&quot;작동하지 않는 세 가지 범주의 모듈이 있습니다 (일부 중복 가능성).</target>
        </trans-unit>
        <trans-unit id="8d15a25a2ad944379a4980717687047ae9148ec3" translate="yes" xml:space="preserve">
          <source>Note that not all of the extensions available from CPAN may work in the Windows environment; you should check the information at &lt;a href=&quot;http://www.cpantesters.org/&quot;&gt;http://www.cpantesters.org/&lt;/a&gt; before investing too much effort into porting modules that don't readily build.</source>
          <target state="translated">CPAN에서 사용 가능한 모든 확장이 Windows 환경에서 작동하지는 않습니다. 쉽게 구축되지 않는 모듈을 포팅하는 데 너무 많은 노력을 기울이기 전에 &lt;a href=&quot;http://www.cpantesters.org/&quot;&gt;http://www.cpantesters.org/&lt;/a&gt; 에서 정보를 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="814895e1fc7075770faad339ecd10e73c24fbc5f" translate="yes" xml:space="preserve">
          <source>Note that numf is called by quant for stringifying all quantifying numbers.</source>
          <target state="translated">numf는 모든 정량화 숫자를 문자열 화하기 위해 quant에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="f0564c5fce02fbef6630b978932f6aa1e763b70b" translate="yes" xml:space="preserve">
          <source>Note that older Pod formatters might not recognize octal or hex numeric escapes, and that many formatters cannot reliably render characters above 255. (Some formatters may even have to use compromised renderings of Latin-1/CP-1252 characters, like rendering &lt;code&gt;E&amp;lt;eacute&amp;gt;&lt;/code&gt; as just a plain &quot;e&quot;.)</source>
          <target state="translated">구형 포드 포맷터는 8 진수 또는 16 진수 이스케이프를 인식하지 못할 수 있으며 많은 포맷터는 255 이상의 문자를 안정적으로 렌더링 할 수 없습니다. (일부 포맷터는 &lt;code&gt;E&amp;lt;eacute&amp;gt;&lt;/code&gt; 렌더링과 같은 라틴 -1 / CP-1252 캐릭터의 손상된 렌더링을 사용해야 할 수도 있습니다. &amp;gt; 그냥 평범한 &quot;e&quot;로.)</target>
        </trans-unit>
        <trans-unit id="4fe6034079ad6a013e5f8b58c3a64f050566c116" translate="yes" xml:space="preserve">
          <source>Note that on Windows, address space allocation granularity is 64 KB, therefore, setting the stack smaller than that on Win32 Perl will not save any more memory.</source>
          <target state="translated">Windows에서 주소 공간 할당 단위는 64KB이므로 스택을 Win32 Perl보다 작게 설정하면 더 이상 메모리가 절약되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9b131d252a3bfc8b5c8ad8d09c7187e733df7c40" translate="yes" xml:space="preserve">
          <source>Note that on input (string to number) Perl accepts &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; in many forms. Case is ignored, and the Win32-specific forms like &lt;code&gt;1.#INF&lt;/code&gt; are understood, but on output the values are normalized to &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; .</source>
          <target state="translated">입력시 (문자열에서 숫자로) Perl은 여러 형식으로 &lt;code&gt;Inf&lt;/code&gt; 및 &lt;code&gt;NaN&lt;/code&gt; 을 허용 합니다. 대소 문자는 무시되고 &lt;code&gt;1.#INF&lt;/code&gt; 와 같은 Win32 특정 형식 은 이해되지만 출력시 값은 &lt;code&gt;Inf&lt;/code&gt; 및 &lt;code&gt;NaN&lt;/code&gt; 으로 정규화됩니다 .</target>
        </trans-unit>
        <trans-unit id="eb6ba392df3d7fde91ed08ef1f5b7c759eb9d39f" translate="yes" xml:space="preserve">
          <source>Note that on some systems, a return value of &lt;code&gt;-1&lt;/code&gt; could mean that child processes are being automatically reaped. See &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt; for details, and for other examples.</source>
          <target state="translated">일부 시스템에서 리턴 값 &lt;code&gt;-1&lt;/code&gt; 은 하위 프로세스가 자동으로 수확됨을 의미 할 수 있습니다. 자세한 내용 및 기타 예는 &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="abc04d7473c212695d1b705a8da3b88080d0bbab" translate="yes" xml:space="preserve">
          <source>Note that on some systems, a return value of &lt;code&gt;-1&lt;/code&gt; could mean that child processes are being automatically reaped. See &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for details, and for other examples.</source>
          <target state="translated">일부 시스템에서 리턴 값 &lt;code&gt;-1&lt;/code&gt; 은 하위 프로세스가 자동으로 수확됨을 의미 할 수 있습니다. 자세한 내용 및 기타 예는 &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="baef8826a89d43d1f8e9e1ff1d1484160a339674" translate="yes" xml:space="preserve">
          <source>Note that only localized variable changes are undone. Other side effects of code expression execution are permanent. Thus</source>
          <target state="translated">지역화 된 변수 변경 만 취소됩니다. 코드 표현식 실행의 다른 부작용은 영구적입니다. 그러므로</target>
        </trans-unit>
        <trans-unit id="9e8b3ca63f560a2fa0e18c2ef188ef76edc6e881" translate="yes" xml:space="preserve">
          <source>Note that only perl can truly parse Perl, so all such CASE tools fall somewhat short of the mark, especially if you don't program your Perl as a C programmer might.</source>
          <target state="translated">Perl만이 진정으로 Perl을 구문 분석 할 수 있으므로 모든 CASE 도구는 특히 Perl을 C 프로그래머로 프로그래밍하지 않는 경우에는 다소 부족합니다.</target>
        </trans-unit>
        <trans-unit id="32ee21a94e6bacfd587283dcf64796ed246e6431" translate="yes" xml:space="preserve">
          <source>Note that op_next is not manipulated, and nodes are not freed; that is the responsibility of the caller. It also won't create a new list op for an empty list etc; use higher-level functions like op_append_elem() for that.</source>
          <target state="translated">op_next는 조작되지 않으며 노드는 해제되지 않습니다. 그것이 발신자의 책임입니다. 또한 빈 목록 등에 대한 새 목록 op를 만들지 않습니다. 이를 위해 op_append_elem ()과 같은 고급 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="54c807dda3550fe223a1b1c55cd9bed9ee48d31f" translate="yes" xml:space="preserve">
          <source>Note that pad_findlex() is recursive; it recurses up the chain of CVs, then comes back down, adding fake entries as it goes. It has to be this way because fake names in anon protoypes have to store in xlow the index into the parent pad.</source>
          <target state="translated">pad_findlex ()는 재귀 적입니다. CV 체인을 되풀이 한 다음 다시 내려 가면서 가짜 항목을 추가합니다. anon protoypes의 가짜 이름은 xlow에 색인을 부모 패드에 저장해야하기 때문에 이런 식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="131b045dcad1d95b29a85c93d3a6715d69d24db9" translate="yes" xml:space="preserve">
          <source>Note that parentheses are necessary when you're chomping anything that is not a simple variable. This is because &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $cwd = `pwd`;&lt;/code&gt; is interpreted as &lt;code&gt;(&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $cwd) = `pwd`;&lt;/code&gt; , rather than as &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;( $cwd = `pwd` )&lt;/code&gt; which you might expect. Similarly, &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $a, $b&lt;/code&gt; is interpreted as &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;($a), $b&lt;/code&gt; rather than as &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;($a, $b)&lt;/code&gt; .</source>
          <target state="translated">간단한 변수가 아닌 것을 숨길 때는 괄호가 필요합니다. &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $cwd = `pwd`;&lt;/code&gt; 때문입니다 . &lt;code&gt;(&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $cwd) = `pwd`;&lt;/code&gt; 로 해석됩니다 ; 예상 보다 &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;( $cwd = `pwd` )&lt;/code&gt; 보다는 . 마찬가지로, &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $a, $b&lt;/code&gt; 로 해석 &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;($a), $b&lt;/code&gt; 대신 것과는 &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;($a, $b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="346dbcf702d3c4fdb72e5c159c8678dc946b771c" translate="yes" xml:space="preserve">
          <source>Note that parentheses are necessary when you're chomping anything that is not a simple variable. This is because &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $cwd = `pwd`;&lt;/code&gt; is interpreted as &lt;code&gt;(&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $cwd) = `pwd`;&lt;/code&gt; , rather than as &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;( $cwd = `pwd` )&lt;/code&gt; which you might expect. Similarly, &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $a, $b&lt;/code&gt; is interpreted as &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;($a), $b&lt;/code&gt; rather than as &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;($a, $b)&lt;/code&gt; .</source>
          <target state="translated">간단한 변수가 아닌 것을 숨길 때는 괄호가 필요합니다. &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $cwd = `pwd`;&lt;/code&gt; 때문입니다 . &lt;code&gt;(&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $cwd) = `pwd`;&lt;/code&gt; 로 해석됩니다 ; 예상 보다 &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;( $cwd = `pwd` )&lt;/code&gt; 보다는 . 마찬가지로, &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $a, $b&lt;/code&gt; 로 해석 &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;($a), $b&lt;/code&gt; 대신 것과는 &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;($a, $b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61028061478cb52a55b53cfd7830a40515024150" translate="yes" xml:space="preserve">
          <source>Note that parts of this code were derived from &lt;a href=&quot;http://search.cpan.org/perldoc/YAML::Tiny&quot;&gt;YAML::Tiny&lt;/a&gt; with the permission of Adam Kennedy.</source>
          <target state="translated">이 코드의 일부 는 Adam Kennedy의 허락하에 &lt;a href=&quot;http://search.cpan.org/perldoc/YAML::Tiny&quot;&gt;YAML :: Tiny&lt;/a&gt; 에서 파생되었습니다 .</target>
        </trans-unit>
        <trans-unit id="b192f3ab8b3b79b49c3da2be5c05a7696156013b" translate="yes" xml:space="preserve">
          <source>Note that pod translators should look at only paragraphs beginning with a pod directive (it makes parsing easier), whereas the compiler actually knows to look for pod escapes even in the middle of a paragraph. This means that the following secret stuff will be ignored by both the compiler and the translators.</source>
          <target state="translated">포드 번역기는 포드 지시어로 시작하는 단락 만 분석해야합니다 (파싱이 더 쉬워집니다). 반면 컴파일러는 실제로 단락 중간에서도 포드 이스케이프를 찾는 것을 알고 있습니다. 이것은 컴파일러와 번역가 모두 다음과 같은 비밀을 무시한다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ff72d3ac5b8dd647a96a960672acd7ebcc2f3ccc" translate="yes" xml:space="preserve">
          <source>Note that reports about bugs in old versions of Perl, especially those which indicate you haven't also tested the current stable release of Perl, are likely to receive less attention from the volunteers who build and maintain Perl than reports about bugs in the current release.</source>
          <target state="translated">이전 버전의 Perl의 버그, 특히 현재 Perl의 안정적인 릴리스를 테스트하지 않았 음을 나타내는 버그에 대한 보고서는 현재 릴리스의 버그에 대한 보고서보다 Perl을 빌드하고 유지 관리하는 자원 봉사자의 관심이 적습니다. .</target>
        </trans-unit>
        <trans-unit id="c75bcf48cfe25108045a83673fe9bf46dbdb6cb7" translate="yes" xml:space="preserve">
          <source>Note that reversing an array to itself (as in &lt;code&gt;@a = &lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt; @a&lt;/code&gt; ) will preserve non-existent elements whenever possible; i.e., for non-magical arrays or for tied arrays with &lt;code&gt;EXISTS&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; methods.</source>
          <target state="translated">&lt;code&gt;@a = &lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt; @a&lt;/code&gt; 에서와 같이 배열을 자신으로 되 돌리면 가능할 때마다 존재하지 않는 요소를 보존합니다. 즉, 마술이 아닌 배열 또는 &lt;code&gt;EXISTS&lt;/code&gt; 및 &lt;code&gt;DELETE&lt;/code&gt; 방법 을 사용하는 연결 배열의 경우 .</target>
        </trans-unit>
        <trans-unit id="3279ef396cd3fe9ed1f5c93958f688b3a02be9e7" translate="yes" xml:space="preserve">
          <source>Note that reversing an array to itself (as in &lt;code&gt;@a = &lt;a href=&quot;reverse&quot;&gt;reverse&lt;/a&gt; @a&lt;/code&gt; ) will preserve non-existent elements whenever possible; i.e., for non-magical arrays or for tied arrays with &lt;code&gt;EXISTS&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; methods.</source>
          <target state="translated">&lt;code&gt;@a = &lt;a href=&quot;reverse&quot;&gt;reverse&lt;/a&gt; @a&lt;/code&gt; 에서와 같이 배열을 자신으로 되 돌리면 가능할 때마다 존재하지 않는 요소를 보존합니다. 즉, 마술이 아닌 배열 또는 &lt;code&gt;EXISTS&lt;/code&gt; 및 &lt;code&gt;DELETE&lt;/code&gt; 방법 을 사용하는 연결 배열의 경우 .</target>
        </trans-unit>
        <trans-unit id="a0bebc4223d6e9d86efc4ab961e85c3b37f4d12a" translate="yes" xml:space="preserve">
          <source>Note that rewinddir() has a similar limitation on Windows and will not force readdir() to read the directory again either. Only a newly opened directory handle will reflect changes to the directory.</source>
          <target state="translated">rewinddir ()은 Windows에서 비슷한 제한 사항이 있으므로 readdir ()이 디렉토리를 다시 읽도록 강제하지 않습니다. 새로 열린 디렉토리 핸들 만 디렉토리의 변경 사항을 반영합니다.</target>
        </trans-unit>
        <trans-unit id="ac3e7d8ec9774f1fc514c0a850fb3669a2dac43e" translate="yes" xml:space="preserve">
          <source>Note that section names might contain markup. I.e., if a section starts with:</source>
          <target state="translated">섹션 이름에 마크 업이 포함될 수 있습니다. 즉, 섹션이 다음으로 시작하는 경우 :</target>
        </trans-unit>
        <trans-unit id="5cd547b6f9a21623648f43fd2d180495971977d8" translate="yes" xml:space="preserve">
          <source>Note that setting precision and accuracy at the same time is not possible.</source>
          <target state="translated">정밀도와 정확도를 동시에 설정하는 것은 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="2489b5c14780b59ec0536b9418bfecf1ef230d00" translate="yes" xml:space="preserve">
          <source>Note that since Perl 5.10.0 a // can also be the</source>
          <target state="translated">Perl 5.10.0 이후로 //</target>
        </trans-unit>
        <trans-unit id="f4f6bc0bb0b72e537a474e9d5b08d81afb1f9c79" translate="yes" xml:space="preserve">
          <source>Note that since Perl 5.8.1 the single-number v-strings (like &lt;code&gt;v65&lt;/code&gt; ) are not v-strings before the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator (which is usually used to separate a hash key from a hash value); instead they are interpreted as literal strings ('v65'). They were v-strings from Perl 5.6.0 to Perl 5.8.0, but that caused more confusion and breakage than good. Multi-number v-strings like &lt;code&gt;v65.66&lt;/code&gt; and &lt;code&gt;65.66.67&lt;/code&gt; continue to be v-strings always.</source>
          <target state="translated">Perl 5.8.1부터 &lt;code&gt;v65&lt;/code&gt; 와 같은 단일 숫자 v- 문자열 은 &lt;code&gt;=&amp;gt;&lt;/code&gt; 연산자 앞의 v- 문자열이 아닙니다 (일반적으로 해시 키와 해시 값을 분리하는 데 사용됨). 대신 리터럴 문자열 ( 'v65')로 해석됩니다. 그것들은 Perl 5.6.0에서 Perl 5.8.0까지의 v- 문자열 이었지만, 그것은 좋은 것보다 더 많은 혼란과 파손을 야기했습니다. &lt;code&gt;v65.66&lt;/code&gt; 및 &lt;code&gt;65.66.67&lt;/code&gt; 과 같은 다중 숫자 v- 문자열은 항상 v- 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="19ef149a186b458f11686fd9d31157ce1f5a0ebd" translate="yes" xml:space="preserve">
          <source>Note that since Perl version 5.16 this function has been a no-op, but this might change in a future release.</source>
          <target state="translated">Perl 버전 5.16부터이 기능은 작동하지 않았지만 향후 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c5b88d706c28965b53567c8427b594ad63f74e3" translate="yes" xml:space="preserve">
          <source>Note that skipping white space applies only to the interior of this construct. There must not be any space between any of the characters that form the initial &lt;code&gt;(?[&lt;/code&gt; . Nor may there be space between the closing &lt;code&gt;])&lt;/code&gt; characters.</source>
          <target state="translated">공백을 건너 뛰면이 구문의 내부에만 적용됩니다. 초기 문자 &lt;code&gt;(?[&lt;/code&gt; . 닫는 &lt;code&gt;])&lt;/code&gt; 사이에는 공백 이 없어야 함) 사이에 공백이 없어야합니다 .</target>
        </trans-unit>
        <trans-unit id="1c060aa4bbf33c5b1f0215edf2ae5f526f55cd18" translate="yes" xml:space="preserve">
          <source>Note that some URLs have hexadecimal ASCII code points in them in an attempt to overcome character or protocol limitation issues. For example the tilde character is not on every keyboard hence a URL of the form:</source>
          <target state="translated">문자 또는 프로토콜 제한 문제를 극복하기 위해 일부 URL에는 16 진 ASCII 코드 포인트가 있습니다. 예를 들어 물결표 문자가 모든 키보드에있는 것은 아니므로 다음 형식의 URL입니다.</target>
        </trans-unit>
        <trans-unit id="96757558cf943b3af9fec33e5de374cf8022a75a" translate="yes" xml:space="preserve">
          <source>Note that some types of arguments/return-values for functions may result in XSUB-declarations/typemap-entries which need hand-editing. Such may be objects which cannot be converted from/to a pointer (like &lt;code&gt;long long&lt;/code&gt; ), pointers to functions, or arrays. See also the section on &lt;a href=&quot;#LIMITATIONS-of--x&quot;&gt;LIMITATIONS of -x&lt;/a&gt;.</source>
          <target state="translated">함수에 대한 일부 유형의 인수 / 반환 값은 XSUB 선언 / 유형 맵 항목을 생성 할 수 있으며 이로 인해 수동 편집이 필요합니다. &lt;code&gt;long long&lt;/code&gt; 과 같은 포인터, 함수에 대한 포인터 또는 배열 로 변환 할 수없는 객체 일 수 있습니다 . &lt;a href=&quot;#LIMITATIONS-of--x&quot;&gt;-x 제한에&lt;/a&gt; 대한 섹션도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fcd18b02b9dc35274d6564c64032ca709a95c4f6" translate="yes" xml:space="preserve">
          <source>Note that spaces in the format argument to &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; do not denote literal spaces. If you have space separated data, you may want &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 위해 format 인수의 공백은 리터럴 공백을 나타내지 않습니다. 공백으로 구분 된 데이터가있는 경우 대신 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 을 원할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a2b6650d0cfdddfa7918a6366723469de7b3aca7" translate="yes" xml:space="preserve">
          <source>Note that splitting an EXPR that evaluates to the empty string always produces zero fields, regardless of the LIMIT specified.</source>
          <target state="translated">빈 문자열로 평가되는 EXPR을 분할하면 지정된 LIMIT에 관계없이 항상 0 개의 필드가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="77e878278c2299b62e83869de869a2f9253eaf40" translate="yes" xml:space="preserve">
          <source>Note that starting from Perl 5.7.2 (and consequently 5.8.0) and AIX 4.3 or newer Perl uses the AIX native dynamic loading interface in the so called runtime linking mode instead of the emulated interface that was used in Perl releases 5.6.1 and earlier or, for AIX releases 4.2 and earlier. This change does break backward compatibility with compiled modules from earlier Perl releases. The change was made to make Perl more compliant with other applications like Apache/mod_perl which are using the AIX native interface. This change also enables the use of C++ code with static constructors and destructors in Perl extensions, which was not possible using the emulated interface.</source>
          <target state="translated">Perl 5.7.2 (및 결과적으로 5.8.0)부터 AIX 4.3 이상에서 Perl 릴리스 5.6.1 및 5.3에서 사용 된 에뮬레이트 된 인터페이스 대신 이른바 런타임 링크 모드에서 AIX 기본 동적로드 인터페이스를 사용합니다. 이전 또는 AIX 릴리스 4.2 이전. 이 변경은 이전 Perl 릴리스에서 컴파일 된 모듈과의 호환성을 손상시킵니다. Perl이 AIX 기본 인터페이스를 사용하는 Apache / mod_perl과 같은 다른 응용 프로그램과 호환되도록 변경되었습니다. 이 변경으로 인해 Perl 확장에서 정적 생성자 및 소멸자와 함께 C ++ 코드를 사용할 수 있었지만 에뮬레이트 된 인터페이스로는 불가능했습니다.</target>
        </trans-unit>
        <trans-unit id="e00838249311f81e98bfc06fb08536fb7ec9966f" translate="yes" xml:space="preserve">
          <source>Note that starting in Unicode 6.1, many of the block names have shorter synonyms. These are always given in the new style.</source>
          <target state="translated">유니 코드 6.1부터 많은 블록 이름의 동의어가 더 짧습니다. 이들은 항상 새로운 스타일로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="2ad7004d8cad106c4c2f0c2a7d60864d3c8b1736" translate="yes" xml:space="preserve">
          <source>Note that strtol() and strtoul() may be disguised as Strtol(), Strtoul(), Atol(), Atoul(). Avoid those, too.</source>
          <target state="translated">strtol () 및 strtoul ()은 Strtol (), Strtoul (), Atol (), Atoul ()로 위장 될 수 있습니다. 그것들도 피하십시오.</target>
        </trans-unit>
        <trans-unit id="643a90b7cc572aa8f24a2a4aeec18309319e74d7" translate="yes" xml:space="preserve">
          <source>Note that the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a13e460ac63aeef5172c4e67fabd8f175a93e35" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;%a&lt;/code&gt; and &lt;code&gt;%b&lt;/code&gt; , the short forms of the day of the week and the month of the year, may not necessarily be three characters wide.</source>
          <target state="translated">있습니다 &lt;code&gt;%a&lt;/code&gt; 및 &lt;code&gt;%b&lt;/code&gt; , 요일과 올해의 달의 짧은 형태, 반드시 넓은 세 문자하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c990c52d20bce03cc1931306413c2445b6287df4" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;-L&lt;/code&gt; and &lt;code&gt;-l&lt;/code&gt; prefixes are &lt;b&gt;not required&lt;/b&gt;, but authors who wish their extensions to be portable to Unix or OS/2 should use the prefixes, since the Unix-OS/2 version of ext() requires them.</source>
          <target state="translated">참고 것을 &lt;code&gt;-L&lt;/code&gt; 및 &lt;code&gt;-l&lt;/code&gt; 접두사가되어 &lt;b&gt;필요하지&lt;/b&gt; 만, 내선의 유닉스 OS / 2 버전은 ()을 필요로하기 때문에 자신의 확장을하고자하는 저자는, 접두사를 사용해야 유닉스 또는 OS / 2에 이식 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fb35d0c6e79a4294b3591fc47c05224b1801d3d" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt; FILEHANDLE&lt;/code&gt; form is generally portable.</source>
          <target state="translated">합니다 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt; FILEHANDLE&lt;/code&gt; 형태는 일반적으로 휴대용이다.</target>
        </trans-unit>
        <trans-unit id="9806508e6a2529870cc2037f1710d22cb6ace5d5" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;XSOPT&lt;/code&gt; MakeMaker option may be used to add these options to any makefiles generated by MakeMaker.</source>
          <target state="translated">있습니다 &lt;code&gt;XSOPT&lt;/code&gt; MakeMaker 옵션 MakeMaker에 의해 생성 된 메이크 파일에 이러한 옵션을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86802402b451982daee5eec807ff6ea5529eaefd" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;d&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;p&lt;/code&gt; , and &lt;code&gt;u&lt;/code&gt; modifiers are special in that they can only be enabled, not disabled, and the &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;d&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , and &lt;code&gt;u&lt;/code&gt; modifiers are mutually exclusive: specifying one de-specifies the others, and a maximum of one (or two &lt;code&gt;a&lt;/code&gt; 's) may appear in the construct. Thus, for example, &lt;code&gt;(?-p)&lt;/code&gt; will warn when compiled under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; ; &lt;code&gt;(?-d:...)&lt;/code&gt; and &lt;code&gt;(?dl:...)&lt;/code&gt; are fatal errors.</source>
          <target state="translated">참고 그 , &lt;code&gt;d&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;p&lt;/code&gt; , 및 &lt;code&gt;u&lt;/code&gt; 수정은 그들이 단지 활성화 될 수 있다는 사용할 수없는 특수, 그리고 , &lt;code&gt;d&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , 및 &lt;code&gt;u&lt;/code&gt; 수정이 상호 배타적 인 하나 드 지정 다른 사람을 지정, 하나의 (또는 두 개의 최대 의)은 구조물에 표시 할 수있다. 따라서, 예를 들어, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 경고에서 컴파일 될 때 &lt;code&gt;(?-p)&lt;/code&gt; 는 경고합니다 . &lt;code&gt;(?-d:...)&lt;/code&gt; 및 &lt;code&gt;(?dl:...)&lt;/code&gt; 은 치명적인 오류입니다. &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b75233b2e52c1643f13c545ab5448e1216afde19" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;digest&lt;/code&gt; operation is effectively a destructive, read-once operation. Once it has been performed, the $ctx object is automatically &lt;code&gt;&lt;a href=&quot;functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; and can be used to calculate another digest value. Call $ctx-&amp;gt;clone-&amp;gt;digest if you want to calculate the digest without resetting the digest state.</source>
          <target state="translated">점을 유의 &lt;code&gt;digest&lt;/code&gt; 작업이 효과적으로 파괴 판독 회 동작이다. 일단 수행되면 $ ctx 객체가 자동으로 &lt;code&gt;&lt;a href=&quot;functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; 되고 다른 다이제스트 값을 계산하는 데 사용할 수 있습니다. 다이제스트 상태를 재설정하지 않고 다이제스트를 계산하려면 $ ctx-&amp;gt; clone-&amp;gt; 다이제스트를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="2e408b4bb22ad308085742938ea428bf4e618d3e" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;digest&lt;/code&gt; operation is effectively a destructive, read-once operation. Once it has been performed, the &lt;code&gt;Digest::MD5&lt;/code&gt; object is automatically &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; and can be used to calculate another digest value. Call $md5-&amp;gt;clone-&amp;gt;digest if you want to calculate the digest without resetting the digest state.</source>
          <target state="translated">점을 유의 &lt;code&gt;digest&lt;/code&gt; 작업이 효과적으로 파괴 판독 회 동작이다. 일단 수행되면 &lt;code&gt;Digest::MD5&lt;/code&gt; 개체가 자동으로 &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; 되고 다른 다이제스트 값을 계산하는 데 사용할 수 있습니다. 요약 상태를 재설정하지 않고 요약을 계산하려면 $ md5-&amp;gt; clone-&amp;gt; digest를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="d24eeff32ed6f4a19c0009f5d0e023c636e7a94e" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;&lt;/code&gt; and &lt;code&gt;to&lt;i&gt;FOO&lt;/i&gt;&lt;/code&gt; macros in</source>
          <target state="translated">(가) 있습니다 &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;&lt;/code&gt; 와 &lt;code&gt;to&lt;i&gt;FOO&lt;/i&gt;&lt;/code&gt; 매크로에</target>
        </trans-unit>
        <trans-unit id="a2d5c53bebb44c78258b20f3af06f6f909ee7256" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;use Pod::Simple::Debug (\$x, &lt;i&gt;somenum&lt;/i&gt;)&lt;/code&gt; mode will make Pod::Simple (et al) run rather slower, since &amp;amp;Pod::Simple::DEBUG won't be a constant sub anymore, and so Pod::Simple (et al) won't compile with constant-folding.</source>
          <target state="translated">있습니다 &lt;code&gt;use Pod::Simple::Debug (\$x, &lt;i&gt;somenum&lt;/i&gt;)&lt;/code&gt; 모드는 포드 :: 간단한 만들 것 (등)은, 이후 및 포드는 :: 간단한 :: DEBUG가 일정한 하위되지 않습니다 더 이상, 오히려 느리게 실행 따라서 포드 : : 단순 (et al)은 상수 폴딩으로 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9551d033cb29a27fd5d6bf1fe4833c6cf7eaf2fe" translate="yes" xml:space="preserve">
          <source>Note that the CPU seconds is the &lt;b&gt;minimum&lt;/b&gt; time: CPU scheduling and other operating system factors may complicate the attempt so that a little bit more time is spent. The benchmark output will, however, also tell the number of &lt;code&gt;$code&lt;/code&gt; runs/second, which should be a more interesting number than the actually spent seconds.</source>
          <target state="translated">CPU 초는 &lt;b&gt;최소&lt;/b&gt; 시간입니다. CPU 스케줄링 및 기타 운영 체제 요인으로 인해 시간이 조금 더 소요될 수 있습니다. 그러나 벤치 마크 결과는 초당 &lt;code&gt;$code&lt;/code&gt; run 의 수를 나타내며 이는 실제로 소요 된 시간보다 더 흥미로운 숫자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="28d680a1e0dab71002ed6eded256a885c900ba34" translate="yes" xml:space="preserve">
          <source>Note that the EXPR can be arbitrarily complicated as long as the final operation is a hash or array key lookup or subroutine name:</source>
          <target state="translated">최종 작업이 해시 또는 배열 키 조회 또는 서브 루틴 이름 인 경우 EXPR은 임의로 복잡 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afc125ebc0373a09cca375f9b07fbcd59b2c703e" translate="yes" xml:space="preserve">
          <source>Note that the G_KEEPERR flag does not propagate into inner evals; these may still set &lt;code&gt;$@&lt;/code&gt; .</source>
          <target state="translated">G_KEEPERR 플래그는 내부 에바로 전파되지 않습니다. 이것들은 여전히 &lt;code&gt;$@&lt;/code&gt; 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1f14f1b3c2ecac55af54ec64471c279be4e1559f" translate="yes" xml:space="preserve">
          <source>Note that the MAP_TARGET value *must* have the &quot;.exe&quot; extension or you will not create a &quot;perl.exe&quot; to replace the one in &lt;code&gt;($DJDIR)/bin&lt;/code&gt; .</source>
          <target state="translated">MAP_TARGET 값 * must *의 확장자는 &quot;.exe&quot;이거나 &lt;code&gt;($DJDIR)/bin&lt;/code&gt; 을 대체하기 위해 &quot;perl.exe&quot;를 작성하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="54136d6700549a5defbb3ceccf1ce74752ff9160" translate="yes" xml:space="preserve">
          <source>Note that the MD5 algorithm is not as strong as it used to be. It has since 2005 been easy to generate different messages that produce the same MD5 digest. It still seems hard to generate messages that produce a given digest, but it is probably wise to move to stronger algorithms for applications that depend on the digest to uniquely identify a message.</source>
          <target state="translated">MD5 알고리즘은 예전처럼 강력하지 않습니다. 2005 년 이후 동일한 MD5 다이제스트를 생성하는 다른 메시지를 쉽게 생성 할 수있었습니다. 주어진 다이제스트를 생성하는 메시지를 생성하는 것은 여전히 ​​어려운 것처럼 보이지만 다이제스트에 의존하여 메시지를 고유하게 식별하는 응용 프로그램에 대해 더 강력한 알고리즘으로 이동하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="09f5d2315ce8efb902a4b01848317f36e6d46300" translate="yes" xml:space="preserve">
          <source>Note that the PerlIO equivalents of &lt;code&gt;fread&lt;/code&gt; and &lt;code&gt;fwrite&lt;/code&gt; are slightly different from their C library counterparts:</source>
          <target state="translated">&lt;code&gt;fread&lt;/code&gt; 및 &lt;code&gt;fwrite&lt;/code&gt; 와 동등한 PerlIO 는 C 라이브러리 와 약간 다릅니다.</target>
        </trans-unit>
        <trans-unit id="c898fd225c811d3b33264eb9a5dd3fac5a9a201b" translate="yes" xml:space="preserve">
          <source>Note that the Symbian filesystem is very picky: it strongly prefers the \ instead of the /.</source>
          <target state="translated">Symbian 파일 시스템은 매우 까다 롭습니다. / 대신 \를 강력하게 선호합니다.</target>
        </trans-unit>
        <trans-unit id="f053db6da6e575d7b066a2e19e4c949dfd7c2c0f" translate="yes" xml:space="preserve">
          <source>Note that the above implementation shuffles an array in place, unlike the &lt;code&gt;List::Util::shuffle()&lt;/code&gt; which takes a list and returns a new shuffled list.</source>
          <target state="translated">위의 구현은 &lt;code&gt;List::Util::shuffle()&lt;/code&gt; 과 달리 배열을 순서대로 섞은 다음 목록을 가져 와서 새로운 순서 섞은 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b065a3ad25b4fc5b70a8b34ad20e23ed1b7c3cb3" translate="yes" xml:space="preserve">
          <source>Note that the above two invocations will be very verbose as reachable memory and leak-checking is enabled by default. If you want to just see pure errors, try:</source>
          <target state="translated">위의 두 호출은 도달 가능한 메모리 및 누출 검사가 기본적으로 활성화되어 있기 때문에 매우 장황합니다. 순수한 오류를 보려면 다음을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="64532abb5f09f86d92c621e51038db0bcc100d92" translate="yes" xml:space="preserve">
          <source>Note that the actual meanings of the various fields are not that well standardized, do not expect any great portability. The &lt;code&gt;$sysname&lt;/code&gt; might be the name of the operating system, the &lt;code&gt;$nodename&lt;/code&gt; might be the name of the host, the &lt;code&gt;$release&lt;/code&gt; might be the (major) release number of the operating system, the &lt;code&gt;$version&lt;/code&gt; might be the (minor) release number of the operating system, and the &lt;code&gt;$machine&lt;/code&gt; might be a hardware identifier. Maybe.</source>
          <target state="translated">다양한 필드의 실제 의미가 제대로 표준화되지 않았으므로 이식성이 뛰어나지 않습니다. &lt;code&gt;$sysname&lt;/code&gt; 운영 체제의 이름의 수 있습니다 &lt;code&gt;$nodename&lt;/code&gt; 의 호스트의 이름을들 수 있습니다 &lt;code&gt;$release&lt;/code&gt; 의 운영 체제의 (주) 릴리스 번호 수 있습니다 &lt;code&gt;$version&lt;/code&gt; (작은) 릴리스 번호 수 있습니다 운영 체제의, 그리고 &lt;code&gt;$machine&lt;/code&gt; 하드웨어 식별자 수 있습니다. 아마도.</target>
        </trans-unit>
        <trans-unit id="f2424ff844845a48b6b1b2cd57585ba63cec58ff" translate="yes" xml:space="preserve">
          <source>Note that the alias EU_ALWAYS_COPY will be supported if EU_INSTALL_ALWAYS_COPY is not defined until at least the 1.50 release. Please ensure you use the correct EU_INSTALL_ALWAYS_COPY.</source>
          <target state="translated">EU_INSTALL_ALWAYS_COPY가 최소 1.50 릴리스까지 정의되지 않은 경우 별명 EU_ALWAYS_COPY가 지원됩니다. 올바른 EU_INSTALL_ALWAYS_COPY를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="26b36cb20c7dae889459ec2f6f9db24992abdb43" translate="yes" xml:space="preserve">
          <source>Note that the assignment &lt;code&gt;$\ = $/&lt;/code&gt; is done when the switch is processed, so the input record separator can be different than the output record separator if the &lt;b&gt;-l&lt;/b&gt; switch is followed by a &lt;b&gt;-0&lt;/b&gt; switch:</source>
          <target state="translated">할당이 &lt;code&gt;$\ = $/&lt;/code&gt; 이면 스위치가 처리 될 때 수행되므로 &lt;b&gt;-l&lt;/b&gt; 스위치 뒤에 &lt;b&gt;-0&lt;/b&gt; 스위치 가 있으면 입력 레코드 구분 기호가 출력 레코드 구분 기호와 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c00bf502c45bde6ba2060e9d911a339007fd5405" translate="yes" xml:space="preserve">
          <source>Note that the backslash itself is special; if you want to match a backslash, you have to escape the backslash with a backslash: &lt;code&gt;/\\/&lt;/code&gt; matches a single backslash.</source>
          <target state="translated">백 슬래시 자체는 특별합니다. 백 슬래시를 일치 시키려면 백 슬래시로 백 슬래시를 이스케이프해야합니다. &lt;code&gt;/\\/&lt;/code&gt; 는 단일 백 슬래시와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="f6ebed0705c42d69729c70593af8e15098cbc1e9" translate="yes" xml:space="preserve">
          <source>Note that the base64 encoded string returned is not padded to be a multiple of 4 bytes long. If you want interoperability with other base64 encoded md5 digests you might want to append the redundant string &quot;==&quot; to the result.</source>
          <target state="translated">반환 된 base64 인코딩 문자열은 4 바이트의 배수로 채워지지 않습니다. 다른 base64로 인코딩 된 md5 다이제스트와 상호 운용성을 원할 경우 중복 문자열 &quot;==&quot;을 결과에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="772992efab68f2396f54e27fdd4bb3868704a8b7" translate="yes" xml:space="preserve">
          <source>Note that the braces are required in Perl, even if you've only got one line in the block. However, there is a clever way of making your one-line conditional blocks more English like:</source>
          <target state="translated">블록에 한 줄만 있어도 Perl에는 중괄호가 필요합니다. 그러나 한 줄 조건부 블록을 영어와 같이 영어로 만드는 영리한 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f7f794be85b20ad885b31b3bd4e8712126125c7" translate="yes" xml:space="preserve">
          <source>Note that the caller is responsible for suitably incrementing the reference count of &lt;code&gt;val&lt;/code&gt; before the call, and decrementing it if the function returned NULL.</source>
          <target state="translated">호출자는 호출 전에 &lt;code&gt;val&lt;/code&gt; 의 참조 카운트를 적절하게 증가 시키고 함수가 NULL을 리턴하면 감소시킵니다.</target>
        </trans-unit>
        <trans-unit id="4f5d7bcf37a5b2a38715b73f67483220347ce0f3" translate="yes" xml:space="preserve">
          <source>Note that the code might be broken into multiple segments if there are nested formatting codes inside a &lt;code&gt;C&amp;lt;...&amp;gt;&lt;/code&gt; sequence. In between the calls to &lt;code&gt;handle_code&lt;/code&gt; other markup tags might have been emitted in that case. The same is true for verbatim sections if the &lt;code&gt;codes_in_verbatim&lt;/code&gt; option is turned on.</source>
          <target state="translated">&lt;code&gt;C&amp;lt;...&amp;gt;&lt;/code&gt; 시퀀스 내에 중첩 된 형식화 코드가있는 경우 코드가 여러 세그먼트로 나 might 수 있습니다 . 이 경우 &lt;code&gt;handle_code&lt;/code&gt; 호출 사이에 다른 마크 업 태그가 생성되었을 수 있습니다. &lt;code&gt;codes_in_verbatim&lt;/code&gt; 옵션이 설정 되어 있으면 그대로 사용하는 섹션에 대해서도 마찬가지입니다 .</target>
        </trans-unit>
        <trans-unit id="8cd0e4a20a7367cc4b5ead8187ea067b769ad671" translate="yes" xml:space="preserve">
          <source>Note that the effect is compile-time and immutable once defined. However, the subroutines are passed a single parameter, which is 0 if case-sensitive matching is in effect and non-zero if caseless matching is in effect. The subroutine may return different values depending on the value of the flag, and one set of values will immutably be in effect for all case-sensitive matches, and the other set for all case-insensitive matches.</source>
          <target state="translated">효과는 컴파일 타임이며 일단 정의되면 변경할 수 없습니다. 그러나 서브 루틴에는 단일 매개 변수가 전달되는데, 대소 문자 구분 일치가 적용되면 0이고 대소 문자 구분 일치가 적용되면 0이 아닙니다. 서브 루틴은 플래그 값에 따라 다른 값을 리턴 할 수 있으며 한 세트의 값은 대소 문자를 구분하는 모든 일치에 대해 유효하며 다른 세트는 대소 문자를 구분하지 않는 모든 일치에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="83d0991fa33934053d27ec9e77b0dcc73eda0b3d" translate="yes" xml:space="preserve">
          <source>Note that the embedded single-quotes in the string don't help in this case, since they have not been specified as acceptable delimiters and are therefore treated as non-delimiter characters (and ignored).</source>
          <target state="translated">문자열에 포함 된 작은 따옴표는 허용되는 분리 문자로 지정되지 않았으므로 분리 문자가 아닌 문자로 취급되므로 무시되므로이 경우 도움이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1eb58ec9da82570c29bbbb5325581cb00b947ded" translate="yes" xml:space="preserve">
          <source>Note that the emulation built with lockf(3) doesn't provide shared locks, and it requires that FILEHANDLE be open with write intent. These are the semantics that lockf(3) implements. Most if not all systems implement lockf(3) in terms of fcntl(2) locking, though, so the differing semantics shouldn't bite too many people.</source>
          <target state="translated">lockf (3)으로 빌드 된 에뮬레이션은 공유 잠금을 제공하지 않으며 쓰기 의도로 FILEHANDLE을 열어야합니다. 이들은 lockf (3)가 구현하는 의미론입니다. 그러나 대부분의 시스템이 fcntl (2) 잠금의 관점에서 lockf (3)을 구현하는 것은 아니지만, 다른 시맨틱은 너무 많은 사람들을 물지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="07238884ca9ae6e9d1b98c9eab9e8272e50d79b1" translate="yes" xml:space="preserve">
          <source>Note that the encoding itself is &lt;b&gt;not&lt;/b&gt; a formally valid language tag. Note also that you cannot, currently, go from an encoding back to a language tag that it's an encoding of.</source>
          <target state="translated">인코딩 자체는 공식적으로 유효한 언어 태그 가 &lt;b&gt;아닙니다&lt;/b&gt; . 또한 현재 인코딩에서 인코딩 된 언어 태그로 다시 이동할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5a48ddc9bb68bd34263110aaa842399866ebadf6" translate="yes" xml:space="preserve">
          <source>Note that the expanded form represents the way perl handles such constructions internally -- this option actually turns off the reverse translation that B::Deparse usually does. On the other hand, note that &lt;code&gt;$x = &quot;$y&quot;&lt;/code&gt; is not the same as &lt;code&gt;$x = $y&lt;/code&gt; : the former makes the value of $y into a string before doing the assignment.</source>
          <target state="translated">확장 된 형태는 펄이 그러한 구조를 내부적으로 처리하는 방식을 나타냅니다.이 옵션은 실제로 B :: Deparse가 일반적으로하는 역변환을 끕니다. 반면에 &lt;code&gt;$x = &quot;$y&quot;&lt;/code&gt; 는 &lt;code&gt;$x = $y&lt;/code&gt; 와 같지 않습니다 . 전자는 할당을 수행하기 전에 $ y의 값을 문자열로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="ce6c91a770707b555d66e4a287e39136a3141726" translate="yes" xml:space="preserve">
          <source>Note that the extraction with the stored paths is still necessary (default with unzip, specify &lt;code&gt;-d&lt;/code&gt; to pkunzip). However, you need to know where to extract the files. You need also to manually change entries in</source>
          <target state="translated">저장된 경로를 사용한 추출이 여전히 필요하다는 점에 유의하십시오 (기본값은 unzip, &lt;code&gt;-d&lt;/code&gt; 를 pkunzip으로 지정 ). 그러나 파일을 추출 할 위치를 알아야합니다. 또한 수동으로 항목을 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="fd97b7e25cb09157d47ba2c7b978a7930b9606b8" translate="yes" xml:space="preserve">
          <source>Note that the fcntl(2) emulation of flock(3) requires that FILEHANDLE be open with read intent to use LOCK_SH and requires that it be open with write intent to use LOCK_EX.</source>
          <target state="translated">flock (3)의 fcntl (2) 에뮬레이션에서는 LOCK_SH를 사용하려면 FILEHANDLE을 읽기 의도로 열어야하고 LOCK_EX를 사용하려면 쓰기 의도로 열어야합니다.</target>
        </trans-unit>
        <trans-unit id="fe144eb2f290a0a193386ccafda07da2ebb33808" translate="yes" xml:space="preserve">
          <source>Note that the file will not be included twice under the same specified name.</source>
          <target state="translated">파일은 지정된 동일한 이름으로 두 번 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a13c6488a9b380a268109737c1af44124fc53ff" translate="yes" xml:space="preserve">
          <source>Note that the final string may be up to 7 chars longer than pvlim.</source>
          <target state="translated">최종 문자열은 pvlim보다 최대 7 자 더 길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="772ece35cdf290101677cb798018640a9adccf19" translate="yes" xml:space="preserve">
          <source>Note that the first argument is required. The section number will be parsed from it, and if it's missing will default to 1. The second argument is currently ignored, as &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fman.he.net&quot;&gt;man.he.net&lt;/a&gt; does not currently include linkable IDs or anchor names in its pages. Subclass to link to a different man page HTTP server.</source>
          <target state="translated">첫 번째 인수가 필요합니다. 섹션 번호는 섹션 번호에서 구문 분석되며 누락 된 경우 기본값은 1로 설정됩니다. &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fman.he.net&quot;&gt;man.he.net&lt;/a&gt; 은 현재 해당 페이지에 링크 가능한 ID 또는 앵커 이름을 포함하지 않으므로 두 번째 인수는 현재 무시됩니다 . 다른 매뉴얼 페이지 HTTP 서버에 링크하기위한 서브 클래스.</target>
        </trans-unit>
        <trans-unit id="0926e8149e0f9908feb624f3205e6ac6e35159d1" translate="yes" xml:space="preserve">
          <source>Note that the first of the above returns a Time::Seconds object, so while examining the object will print the number of seconds (because of the overloading), you can also get the number of minutes, hours, days, weeks and years in that delta, using the Time::Seconds API.</source>
          <target state="translated">위의 첫 번째는 Time :: Seconds 객체를 반환하므로 객체를 검사하는 동안 (오버로드로 인해) 초 수를 인쇄하지만 분, 시간, 일, 주 및 년 수를 얻을 수도 있습니다. Time :: Seconds API를 사용하여 해당 델타.</target>
        </trans-unit>
        <trans-unit id="533bf74078da55d39eeb6299ea8805b9073e8050" translate="yes" xml:space="preserve">
          <source>Note that the general pattern here is that the accessor-methods read the attribute's value with &lt;code&gt;$value = $parser-&amp;gt;&lt;i&gt;attribute&lt;/i&gt;&lt;/code&gt; and set the attribute's value with &lt;code&gt;$parser-&amp;gt;&lt;i&gt;attribute&lt;/i&gt;(&lt;i&gt;newvalue&lt;/i&gt;)&lt;/code&gt;. For each accessor, I typically only mention one syntax or another, based on which I think you are actually most likely to use.</source>
          <target state="translated">여기서 일반적인 패턴은 접근 자 메소드가 &lt;code&gt;$value = $parser-&amp;gt;&lt;i&gt;attribute&lt;/i&gt;&lt;/code&gt; 값을 &lt;code&gt;$parser-&amp;gt;&lt;i&gt;attribute&lt;/i&gt;(&lt;i&gt;newvalue&lt;/i&gt;)&lt;/code&gt; 값을 설정한다는 것 입니다. 각 접근 자에 대해 일반적으로 실제로 가장 많이 사용한다고 생각하는 구문을 하나만 언급합니다.</target>
        </trans-unit>
        <trans-unit id="9c62e8291c3969aab5799ff59674523f531fd071" translate="yes" xml:space="preserve">
          <source>Note that the global variable &lt;code&gt;$B::OP::does_parent&lt;/code&gt; is undefined on older perls that don't support the &lt;code&gt;parent&lt;/code&gt; method, is defined but false on perls that support the method but were built without &lt;code&gt;-DPERL_OP_PARENT&lt;/code&gt; , and is true otherwise.</source>
          <target state="translated">전역 변수 &lt;code&gt;$B::OP::does_parent&lt;/code&gt; 는 &lt;code&gt;parent&lt;/code&gt; 메소드를 지원하지 않는 이전 perls에서 정의되지 않고 정의되었지만 메소드를 지원하지만 &lt;code&gt;-DPERL_OP_PARENT&lt;/code&gt; 없이 빌드 된 perls에서는 false 이며 그렇지 않은 경우 true입니다.</target>
        </trans-unit>
        <trans-unit id="255f1a96146684091b1e9cb0690908a053fe1866" translate="yes" xml:space="preserve">
          <source>Note that the implementation of &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; in this module does not provide true random access to a compressed file/buffer. It works by uncompressing data from the current offset in the file/buffer until it reaches the uncompressed offset specified in the parameters to &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;. For very small files this may be acceptable behaviour. For large files it may cause an unacceptable delay.</source>
          <target state="translated">이 모듈에서 &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 을 구현 한다고해서 압축 파일 / 버퍼에 대한 임의의 랜덤 액세스는 제공하지 않습니다. &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 할 매개 변수에 지정된 압축되지 않은 오프셋에 도달 할 때까지 파일 / 버퍼의 현재 오프셋에서 데이터를 압축 해제하여 작동합니다 . 아주 작은 파일의 경우 허용되는 동작 일 수 있습니다. 큰 파일의 경우 허용되지 않는 지연이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f257e1d0eedfe176e0664704a0289bfea4406fc3" translate="yes" xml:space="preserve">
          <source>Note that the initializer for a nested class may be specified as an object of that class, or as a reference to a hash of initializers that are passed on to the nested struct's constructor.</source>
          <target state="translated">중첩 클래스의 이니셜 라이저는 해당 클래스의 객체 또는 중첩 된 구조체의 생성자에 전달 된 이니셜 라이저의 해시에 대한 참조로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80804b39a5da75cc855890b4a2fe869234b33d17" translate="yes" xml:space="preserve">
          <source>Note that the interaction between alarms and sleeps is unspecified.</source>
          <target state="translated">알람과 슬립 간의 상호 작용은 지정되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e8783b348067a3189a0f06125d399031ed3fee39" translate="yes" xml:space="preserve">
          <source>Note that the inversion lists returned by this function can possibly include non-Unicode code points, that is anything above 0x10FFFF. Unicode properties are not defined on such code points. You might wish to change the output to not include these. Simply add 0x110000 at the end of the non-empty returned list if it isn't already that value; and pop that value if it is; like:</source>
          <target state="translated">이 함수에 의해 반환 된 반전리스트는 비 유니 코드 코드 포인트를 포함 할 수 있습니다. 이러한 코드 포인트에는 유니 코드 속성이 정의되어 있지 않습니다. 이를 포함하지 않도록 출력을 변경하고자 할 수 있습니다. 비어 있지 않은 반환 목록의 끝에 0x110000을 추가하십시오 (아직 해당 값이 아닌 경우). 그 값이 있다면 그 값을 팝; 처럼:</target>
        </trans-unit>
        <trans-unit id="634311f4edf03951c04e577294ff3bbf805ec5ba" translate="yes" xml:space="preserve">
          <source>Note that the inversion maps returned for the &lt;code&gt;Case_Folding&lt;/code&gt; and &lt;code&gt;Simple_Case_Folding&lt;/code&gt; properties do not include the Turkic-locale mappings. Use &lt;a href=&quot;#casefold()&quot;&gt;casefold()&lt;/a&gt; for these.</source>
          <target state="translated">&lt;code&gt;Case_Folding&lt;/code&gt; 및 &lt;code&gt;Simple_Case_Folding&lt;/code&gt; 특성에 대해 리턴 된 반전 맵 에는 Turkic-locale 맵핑이 포함되지 않습니다. 이를 위해 &lt;a href=&quot;#casefold()&quot;&gt;casefold ()&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="31c86684655a1972f5965e0709faf4f9dbe8bb6a" translate="yes" xml:space="preserve">
          <source>Note that the largest code point in Unicode is U+10FFFF.</source>
          <target state="translated">유니 코드에서 가장 큰 코드 포인트는 U + 10FFFF입니다.</target>
        </trans-unit>
        <trans-unit id="19d81e07df642a7406f056019f52ad26601c1b9e" translate="yes" xml:space="preserve">
          <source>Note that the last two of these are actually competing projects both delivering complete gcc toolchain for MS Windows:</source>
          <target state="translated">이들 중 마지막 두 가지는 실제로 MS Windows 용 완전한 gcc 툴체인을 제공하는 경쟁 프로젝트입니다.</target>
        </trans-unit>
        <trans-unit id="b9b9a1c26be88f08471aaa216414e6d8395e1d57" translate="yes" xml:space="preserve">
          <source>Note that the leading &quot;:&quot; is removed from the filename, so that</source>
          <target state="translated">파일 이름에서 선행 &quot;:&quot;이 제거되므로</target>
        </trans-unit>
        <trans-unit id="df9faf2f3be99fd79d6a15587ce23e5766dfe648" translate="yes" xml:space="preserve">
          <source>Note that the like ordinary associative arrays, the order of the keys retrieved is in an apparently random order.</source>
          <target state="translated">일반적인 연관 배열과 마찬가지로 검색된 키의 순서는 명백하게 임의의 순서입니다.</target>
        </trans-unit>
        <trans-unit id="b92b7a5bb51e663f2e21cacb04a99284891d33e2" translate="yes" xml:space="preserve">
          <source>Note that the lines are not printed by default. See &lt;a href=&quot;#-p&quot;&gt;-p&lt;/a&gt; to have lines printed. If a file named by an argument cannot be opened for some reason, Perl warns you about it and moves on to the next file.</source>
          <target state="translated">줄은 기본적으로 인쇄되지 않습니다. 줄을 인쇄하려면 &lt;a href=&quot;#-p&quot;&gt;-p&lt;/a&gt; 를 참조하십시오 . 어떤 이유로 인수로 명명 된 파일을 열 수없는 경우 Perl은 이에 대해 경고하고 다음 파일로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="04e826f7fe166da89c0048f458c19e7bf2982a08" translate="yes" xml:space="preserve">
          <source>Note that the list is not sorted.</source>
          <target state="translated">목록은 정렬되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="5f163f86087018a673bf93b42c4a0a6c49b0abc8" translate="yes" xml:space="preserve">
          <source>Note that the lvalue returned by the three-argument version of substr() acts as a 'magic bullet'; each time it is assigned to, it remembers which part of the original string is being modified; for example:</source>
          <target state="translated">substr ()의 3 인수 버전에서 반환 된 lvalue는 '마법의 탄환'역할을합니다. 할당 될 때마다 원래 문자열의 어떤 부분이 수정되고 있는지 기억합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="30652accd17648a773c7cfc6b99b87e2f00a6b4d" translate="yes" xml:space="preserve">
          <source>Note that the mapping is the one that is specified in the Unicode data files, and to get the final decomposition, it may need to be applied recursively.</source>
          <target state="translated">맵핑은 유니 코드 데이터 파일에 지정된 맵핑이며 최종 분해를 얻으려면 재귀 적으로 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="a840d21a1adb331df5f502ec5cce875d624189ca" translate="yes" xml:space="preserve">
          <source>Note that the minimal matching quantifiers, &lt;code&gt;*?&lt;/code&gt; , &lt;code&gt;+?&lt;/code&gt;, and &lt;code&gt;??&lt;/code&gt; appear to be nested quantifiers, but aren't. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">최소 일치 수량자는 &lt;code&gt;*?&lt;/code&gt; , &lt;code&gt;+?&lt;/code&gt; , &lt;code&gt;??&lt;/code&gt; 중첩 된 한정자 인 것처럼 보이지만 그렇지 않습니다. &lt;a href=&quot;perlre&quot;&gt;perlre를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4c2a0ab30039f9b1189b998b4a9e776dc39a1982" translate="yes" xml:space="preserve">
          <source>Note that the number of exponent digits in the scientific notation produced by &lt;code&gt;%e&lt;/code&gt; , &lt;code&gt;%E&lt;/code&gt; , &lt;code&gt;%g&lt;/code&gt; and &lt;code&gt;%G&lt;/code&gt; for numbers with the modulus of the exponent less than 100 is system-dependent: it may be three or less (zero-padded as necessary). In other words, 1.23 times ten to the 99th may be either &quot;1.23e99&quot; or &quot;1.23e099&quot;. Similarly for &lt;code&gt;%a&lt;/code&gt; and &lt;code&gt;%A&lt;/code&gt; : the exponent or the hexadecimal digits may float: especially the &quot;long doubles&quot; Perl configuration option may cause surprises.</source>
          <target state="translated">지수 계수가 100보다 작은 숫자에 대해 &lt;code&gt;%e&lt;/code&gt; , &lt;code&gt;%E&lt;/code&gt; , &lt;code&gt;%g&lt;/code&gt; 및 &lt;code&gt;%G&lt;/code&gt; 에 의해 생성 된 과학적 표기법의 지수 자릿수 는 시스템에 따라 다릅니다. 필요에 따라). 즉, 1.23 곱하기 10에서 99까지는 &quot;1.23e99&quot;또는 &quot;1.23e099&quot;일 수 있습니다. &lt;code&gt;%a&lt;/code&gt; 및 &lt;code&gt;%A&lt;/code&gt; 와 유사하게 지수 또는 16 진수가 부동 될 수 있습니다. 특히 &quot;long doubles&quot;Perl 구성 옵션은 놀라움을 유발할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7eeec0bff7c89a12579e992fcf86b0716b7245b" translate="yes" xml:space="preserve">
          <source>Note that the only two changes from the normal way of writing an extension is the addition of a &lt;code&gt;#define PERL_NO_GET_CONTEXT&lt;/code&gt; before including the Perl headers, followed by a &lt;code&gt;dTHX;&lt;/code&gt; declaration at the start of every function that will call the Perl API. (You'll know which functions need this, because the C compiler will complain that there's an undeclared identifier in those functions.) No changes are needed for the XSUBs themselves, because the XS() macro is correctly defined to pass in the implicit context if needed.</source>
          <target state="translated">확장 기능을 작성하는 일반적인 방법에서 변경된 두 가지 사항 은 Perl 헤더를 포함하기 전에 &lt;code&gt;#define PERL_NO_GET_CONTEXT&lt;/code&gt; 를 추가 한 다음 dTHX 를 추가하는 것입니다 &lt;code&gt;dTHX;&lt;/code&gt; Perl API를 호출 할 모든 함수 시작시 선언 (C 컴파일러가 해당 함수에 선언되지 않은 식별자가 있다고 불평하기 때문에 어떤 함수가 필요한지 알 수 있습니다.) XS () 매크로가 암시 적 컨텍스트로 전달되도록 올바르게 정의되어 있으므로 XSUB 자체에는 변경이 필요하지 않습니다. 필요한 경우.</target>
        </trans-unit>
        <trans-unit id="81cafeed743ff4607118970eeb67b7b39cfee366" translate="yes" xml:space="preserve">
          <source>Note that the opmask doesn't affect the already compiled code, it only affects any</source>
          <target state="translated">opmask는 이미 컴파일 된 코드에는 영향을 미치지 않으며, 오직 어떤 코드에도 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="50380a5708cf00fd178289610d3bed5ed2c8b5b4" translate="yes" xml:space="preserve">
          <source>Note that the options terminator (default &lt;code&gt;--&lt;/code&gt; ), if present, will also be passed through in &lt;code&gt;@ARGV&lt;/code&gt; .</source>
          <target state="translated">옵션 종료 자 (기본값 &lt;code&gt;--&lt;/code&gt; )도있는 경우 &lt;code&gt;@ARGV&lt;/code&gt; 에도 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="34344d5bf3d39aec43cee250c8b0f5cab594ad8e" translate="yes" xml:space="preserve">
          <source>Note that the parentheses in &lt;code&gt;(?=regexp)&lt;/code&gt; and &lt;code&gt;(?&amp;lt;=regexp)&lt;/code&gt; are non-capturing, since these are zero-width assertions. Thus in the second regexp, the substrings captured are those of the whole regexp itself. Lookahead &lt;code&gt;(?=regexp)&lt;/code&gt; can match arbitrary regexps, but lookbehind &lt;code&gt;(?&amp;lt;=fixed-regexp)&lt;/code&gt; only works for regexps of fixed width, i.e., a fixed number of characters long. Thus &lt;code&gt;(?&amp;lt;=(ab|bc))&lt;/code&gt; is fine, but &lt;code&gt;(?&amp;lt;=(ab)*)&lt;/code&gt; is not. The negated versions of the lookahead and lookbehind assertions are denoted by &lt;code&gt;(?!regexp)&lt;/code&gt; and &lt;code&gt;(?&amp;lt;!fixed-regexp)&lt;/code&gt; respectively. They evaluate true if the regexps do</source>
          <target state="translated">&lt;code&gt;(?=regexp)&lt;/code&gt; 및 &lt;code&gt;(?&amp;lt;=regexp)&lt;/code&gt; 의 괄호는 폭이 0 인 어설 션이므로 캡처되지 않습니다. 따라서 두 번째 정규 표현식에서 캡처 된 하위 문자열은 전체 정규 표현식 자체의 하위 문자열입니다. Lookahead &lt;code&gt;(?=regexp)&lt;/code&gt; 는 임의의 정규 표현식 과 일치 할 수 있지만 lookbehind &lt;code&gt;(?&amp;lt;=fixed-regexp)&lt;/code&gt; 는 고정 너비의 정규 표현식 , 즉 고정 된 수의 문자 길이에 대해서만 작동합니다. 따라서 &lt;code&gt;(?&amp;lt;=(ab|bc))&lt;/code&gt; 는 괜찮지 만 &lt;code&gt;(?&amp;lt;=(ab)*)&lt;/code&gt; 는 그렇지 않습니다. lookahead 및 lookbehind 어설 션의 부정 버전은 각각 &lt;code&gt;(?!regexp)&lt;/code&gt; 및 &lt;code&gt;(?&amp;lt;!fixed-regexp)&lt;/code&gt; 됩니다. 정규 표현식이 수행하면 true로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="69b12314d048529314e48e1e307c0f68902915bd" translate="yes" xml:space="preserve">
          <source>Note that the perl-mode of emacs will have fits with &lt;code&gt;&quot;main'foo&quot;&lt;/code&gt; (single quote), and mess up the indentation and highlighting. You are probably using &lt;code&gt;&quot;main::foo&quot;&lt;/code&gt; in new Perl code anyway, so this shouldn't be an issue.</source>
          <target state="translated">emacs의 펄 모드는 &lt;code&gt;&quot;main'foo&quot;&lt;/code&gt; (작은 따옴표) 와 맞고 들여 쓰기와 강조 표시를 망칠 것 입니다. 어쨌든 새로운 Perl 코드에서 &lt;code&gt;&quot;main::foo&quot;&lt;/code&gt; 를 사용하고있을 것이므로 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f5ca7725b131e21f49d7345fcb2f0711a2a47f63" translate="yes" xml:space="preserve">
          <source>Note that the possessive quantifier modifier can not be be combined with the non-greedy modifier. This is because it would make no sense. Consider the follow equivalency table:</source>
          <target state="translated">소유량 한정자 수정자를 비욕 심적 수정 자와 결합 할 수 없습니다. 이것은 말이되지 않기 때문입니다. 다음 동등성 테이블을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="2853371a63417bfadde728879823337ed5a4d700" translate="yes" xml:space="preserve">
          <source>Note that the process will continue to grow for each file that it uses. In addition, there might be &lt;code&gt;AUTOLOAD&lt;/code&gt; ed subroutines and other conditions that cause Perl's symbol table to grow. You might want to add some logic that keeps track of the process size, or restarts itself after a certain number of requests, to ensure that memory consumption is minimized. You'll also want to scope your variables with &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; whenever possible.</source>
          <target state="translated">프로세스는 사용하는 각 파일에 대해 계속 증가합니다. 또한 &lt;code&gt;AUTOLOAD&lt;/code&gt; ed 서브 루틴 및 Perl의 기호 테이블이 커지는 기타 조건이 있을 수 있습니다 . 메모리 소비를 최소화하기 위해 프로세스 크기를 추적하거나 특정 횟수의 요청 후에 다시 시작하는 논리를 추가 할 수 있습니다. 또한와 범위 당신의 변수를 원하는 것 &lt;a href=&quot;functions/my&quot;&gt;내&lt;/a&gt; 보입니다.</target>
        </trans-unit>
        <trans-unit id="1b2e6d6d10b83461736cd9723d9f047ffdd975d1" translate="yes" xml:space="preserve">
          <source>Note that the properties of the algorithms change over time, as the algorithms are analyzed and machines grow faster. If your application for instance depends on it being &quot;impossible&quot; to generate the same digest for a different message it is wise to make it easy to plug in stronger algorithms as the one used grow weaker. Using the interface documented here should make it easy to change algorithms later.</source>
          <target state="translated">알고리즘이 분석되고 기계가 더 빨리 성장함에 따라 알고리즘의 속성은 시간이 지남에 따라 변경됩니다. 예를 들어 응용 프로그램이 다른 메시지에 대해 동일한 다이제스트를 생성하는 것이 &quot;불가능한&quot;방법에 의존하는 경우 사용되는 알고리즘이 약해질수록 더 강력한 알고리즘을 쉽게 연결할 수 있습니다. 여기에 설명 된 인터페이스를 사용하면 나중에 알고리즘을 쉽게 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94680bef919b3e58595e50dc2cef254eecd344d5" translate="yes" xml:space="preserve">
          <source>Note that the reason that keys that start with &quot;_&quot; are immune to _AUTO isn't anything generally magical about the underscore character -- I just wanted a way to have most lexicon keys be autoable, except for possibly a few, and I arbitrarily decided to use a leading underscore as a signal to distinguish those few.</source>
          <target state="translated">&quot;_&quot;로 시작하는 키가 _AUTO에 영향을 미치지 않는 이유는 일반적으로 밑줄 문자에 대해 마술이 아닙니다. 필자는 대부분의 어휘 키를 자동화 할 수있는 방법을 원했습니다. 소수를 구별하기위한 신호로 선행 밑줄을 사용하기로 결정했습니다.</target>
        </trans-unit>
        <trans-unit id="c52f10e051f2461220787b7a728deb5d7e62b4bd" translate="yes" xml:space="preserve">
          <source>Note that the said &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; is bound by an implicit scope. As a result any newly introduced lexical variable or any modified capture buffer content is lost after the eval. The debugger is a nice environment to learn Perl, but if you interactively experiment using material which should be in the same scope, stuff it in one line.</source>
          <target state="translated">상기 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 는 암시 적 범위에 의해 구속 된다는 점에 유의한다 . 결과적으로 새로 도입 된 어휘 변수 또는 수정 된 캡처 버퍼 내용은 평가 후에 유실됩니다. 디버거는 Perl을 배우기에 좋은 환경이지만, 같은 범위에있는 재료를 사용하여 대화식으로 실험하는 경우 한 줄에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="55c5f596ab4d97752de506fd4873b64dd76c61e3" translate="yes" xml:space="preserve">
          <source>Note that the single parameter passed to the</source>
          <target state="translated">단일 매개 변수는</target>
        </trans-unit>
        <trans-unit id="a34d0fde03ac911613a011adde756943693a9a07" translate="yes" xml:space="preserve">
          <source>Note that the source code is passed as a single string, so any regex that uses &lt;code&gt;^&lt;/code&gt; or &lt;code&gt;$&lt;/code&gt; to detect line boundaries will need the &lt;code&gt;/m&lt;/code&gt; flag.</source>
          <target state="translated">소스 코드는 단일 문자열로 전달되므로 &lt;code&gt;^&lt;/code&gt; 또는 &lt;code&gt;$&lt;/code&gt; 를 사용하여 행 경계를 감지 하는 모든 정규식 에는 &lt;code&gt;/m&lt;/code&gt; 플래그 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="edfabff4ba4038a16af2c755df720dc69793c8b2" translate="yes" xml:space="preserve">
          <source>Note that the special variable &lt;code&gt;$^N&lt;/code&gt; is particularly useful with code blocks to capture the results of submatches in variables without having to keep track of the number of nested parentheses. For example:</source>
          <target state="translated">특수 변수 &lt;code&gt;$^N&lt;/code&gt; 은 중첩 괄호 수를 추적하지 않고도 변수의 부분 일치 결과를 캡처하는 코드 블록에 특히 유용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="320c096bf4918e52d7bd0e618c2e6a5bc9e4bbc3" translate="yes" xml:space="preserve">
          <source>Note that the specified &lt;code&gt;fail&lt;/code&gt; behaviour applies to nested tags as well.</source>
          <target state="translated">지정된 &lt;code&gt;fail&lt;/code&gt; 동작은 중첩 된 태그에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="580a625682b8e1814baa151c5f0f7dc24aff6bf1" translate="yes" xml:space="preserve">
          <source>Note that the specified delimiters are automatically quotemeta'd.</source>
          <target state="translated">지정된 구분 기호는 자동으로 인용됩니다.</target>
        </trans-unit>
        <trans-unit id="1f961077ad91e1f5e608c0720760840050533641" translate="yes" xml:space="preserve">
          <source>Note that the stack is popped using &lt;code&gt;POPs&lt;/code&gt; in the block where &lt;code&gt;SvTRUE(ERRSV)&lt;/code&gt; is true. This is necessary because whenever a</source>
          <target state="translated">스택은 &lt;code&gt;SvTRUE(ERRSV)&lt;/code&gt; 가 true 인 블록에서 &lt;code&gt;POPs&lt;/code&gt; 를 사용하여 팝됩니다 . 이것은 항상 필요하기 때문에</target>
        </trans-unit>
        <trans-unit id="6462eb454e096d8a1746fdc113a16165357f8c5b" translate="yes" xml:space="preserve">
          <source>Note that the stringified form of infinity varies between platforms: it can be for example any of</source>
          <target state="translated">무한대의 문자열 형식은 플랫폼마다 다릅니다. 예를 들어 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3205ecbbb1a9fb55e62eda6514162f94f7163bfc" translate="yes" xml:space="preserve">
          <source>Note that the syntax here is &lt;code&gt;(?(?{...})yes-regexp|no-regexp)&lt;/code&gt;, not &lt;code&gt;(?((?{...}))yes-regexp|no-regexp)&lt;/code&gt;. In other words, in the case of a code expression, we don't need the extra parentheses around the conditional.</source>
          <target state="translated">여기서 구문은 &lt;code&gt;(?(?{...})yes-regexp|no-regexp)&lt;/code&gt; 가 아니라 &lt;code&gt;(?((?{...}))yes-regexp|no-regexp)&lt;/code&gt; 입니다. 즉, 코드 표현식의 경우 조건부 주위에 추가 괄호가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="56d5a14355f9ba6fa06dc53e561fc21f5fed300e" translate="yes" xml:space="preserve">
          <source>Note that the tag names in &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; don't have the leading ':'.</source>
          <target state="translated">&lt;code&gt;%EXPORT_TAGS&lt;/code&gt; 의 태그 이름 에는 선행 ':'이 없습니다.</target>
        </trans-unit>
        <trans-unit id="0d43c895066c9d58f40f202a5d66994671522d5e" translate="yes" xml:space="preserve">
          <source>Note that the trailing slash is required. This will result in some harmless warnings as Configure is run:</source>
          <target state="translated">후행 슬래시가 필요합니다. 그러면 Configure가 실행될 때 몇 가지 무해한 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="4c26505297a31083f6416749d3b93a6af60fd352" translate="yes" xml:space="preserve">
          <source>Note that the trapping of the restricted operations is not atomic: for example</source>
          <target state="translated">제한된 작업의 트래핑은 원자 적이 지 않습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="ec116afd50e96fd07d539738d536a8676b15709b" translate="yes" xml:space="preserve">
          <source>Note that the two characters on either side of the hyphen are not necessarily both letters or both digits. Any character is possible, although not advisable. &lt;code&gt;['-?]&lt;/code&gt; contains a range of characters, but most people will not know which characters that means. Furthermore, such ranges may lead to portability problems if the code has to run on a platform that uses a different character set, such as EBCDIC.</source>
          <target state="translated">하이픈의 양쪽에있는 두 문자가 반드시 문자 나 숫자가 아닌 것은 아닙니다. 권장되지는 않지만 모든 문자가 가능합니다. &lt;code&gt;['-?]&lt;/code&gt; 에는 다양한 문자가 포함되어 있지만 대부분의 사람들은 어떤 문자를 의미하는지 알지 못합니다. 또한 EBCDIC와 같은 다른 문자 집합을 사용하는 플랫폼에서 코드를 실행해야하는 경우 이러한 범위로 인해 이식성 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f3b0de1587236bfef6be06a1e0b5de9990d1475" translate="yes" xml:space="preserve">
          <source>Note that the user's arguments are also passed to your plugin's &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; function as a list, eg:</source>
          <target state="translated">사용자의 인수도 플러그인의 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; 함수에 목록으로 전달됩니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1a9f0c91ad407486da2a0bb856a821fce00b3309" translate="yes" xml:space="preserve">
          <source>Note that the value is parsed every time the &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; executes. If EXPR is omitted, evaluates &lt;code&gt;$_&lt;/code&gt; . This form is typically used to delay parsing and subsequent execution of the text of EXPR until run time.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 이 실행될 때마다 값이 구문 분석됩니다 . EXPR을 생략하면 &lt;code&gt;$_&lt;/code&gt; 평가 됩니다. 이 양식은 일반적으로 런타임까지 EXPR 텍스트의 구문 분석 및 후속 실행을 지연시키는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="80c8be42c3096c6bc305f155cfa7b7681593f345" translate="yes" xml:space="preserve">
          <source>Note that the value is parsed every time the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; executes. If EXPR is omitted, evaluates &lt;code&gt;$_&lt;/code&gt; . This form is typically used to delay parsing and subsequent execution of the text of EXPR until run time.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 이 실행될 때마다 값이 구문 분석됩니다 . EXPR을 생략하면 &lt;code&gt;$_&lt;/code&gt; 평가 됩니다. 이 양식은 일반적으로 런타임까지 EXPR 텍스트의 구문 분석 및 후속 실행을 지연시키는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2890675e6e5968cd2291073021c2fb93c7f31c50" translate="yes" xml:space="preserve">
          <source>Note that the value of &lt;code&gt;RV&lt;/code&gt; coincides with the numbers we see when we stringify $b. The addresses inside IV() are addresses of &lt;code&gt;X***&lt;/code&gt; structures which hold the current state of an &lt;code&gt;SV&lt;/code&gt; . This address may change during lifetime of an SV.</source>
          <target state="translated">&lt;code&gt;RV&lt;/code&gt; 의 가치는 우리가 $ b를 묶을 때 보이는 숫자와 일치합니다. IV () 내부의 주소 는 &lt;code&gt;SV&lt;/code&gt; 의 현재 상태를 유지하는 &lt;code&gt;X***&lt;/code&gt; 구조의 주소입니다 . 이 주소는 SV 수명 동안 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ef677d9c2b3cc466ca9bce864166dbad6ce21bf" translate="yes" xml:space="preserve">
          <source>Note that the values are not copied, which means modifying them will modify the contents of the hash:</source>
          <target state="translated">값은 복사되지 않으므로 값을 수정하면 해시의 내용이 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="fa78261a427d9e6af662bdbde0ef46d033f442ef" translate="yes" xml:space="preserve">
          <source>Note that the variables &lt;code&gt;$z0&lt;/code&gt; and &lt;code&gt;$z1&lt;/code&gt; are not substituted when the regexp is compiled, as happens for ordinary variables outside a code expression. Rather, the whole code block is parsed as perl code at the same time as perl is compiling the code containing the literal regexp pattern.</source>
          <target state="translated">코드 표현식 외부의 일반 변수와 마찬가지로 regexp가 컴파일 될 때 변수 &lt;code&gt;$z0&lt;/code&gt; 및 &lt;code&gt;$z1&lt;/code&gt; 은 대체되지 않습니다. 오히려 전체 코드 블록은 perl이 리터럴 regexp 패턴을 포함하는 코드를 컴파일하는 것과 동시에 perl 코드로 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="1fe8cdc1e68ec1c1124569f21bcd3994f60be55b" translate="yes" xml:space="preserve">
          <source>Note that there are different &quot;long doubles&quot;: Perl will use whatever the compiler has.</source>
          <target state="translated">다른 &quot;long doubles&quot;가 있습니다 : Perl은 컴파일러가 가진 것을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="40ec796a3ab0ba742755eb67dcef2d941aab9225" translate="yes" xml:space="preserve">
          <source>Note that there are platform-specific limitations on the maximum length of &lt;code&gt;$0&lt;/code&gt; . In the most extreme case it may be limited to the space occupied by the original &lt;code&gt;$0&lt;/code&gt; .</source>
          <target state="translated">최대 길이 &lt;code&gt;$0&lt;/code&gt; 에는 플랫폼 별 제한이 있습니다 . 가장 극단적 인 경우에는 원래 &lt;code&gt;$0&lt;/code&gt; 차지하는 공간으로 제한 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5f16f6cc7a1d32290bc8fbd0609f6f10bfa51e1b" translate="yes" xml:space="preserve">
          <source>Note that there are quite a few things that are unaffected by the current locale. Any literal character is the native character for the given platform. Hence 'A' means the character at code point 65 on ASCII platforms, and 193 on EBCDIC. That may or may not be an 'A' in the current locale, if that locale even has an 'A'. Similarly, all the escape sequences for particular characters, &lt;code&gt;\n&lt;/code&gt; for example, always mean the platform's native one. This means, for example, that &lt;code&gt;\N&lt;/code&gt; in regular expressions (every character but new-line) works on the platform character set.</source>
          <target state="translated">현재 로케일의 영향을받지 않는 것이 몇 가지 있습니다. 모든 리터럴 문자는 주어진 플랫폼의 기본 문자입니다. 따라서 'A'는 ASCII 플랫폼의 코드 포인트 65와 EBCDIC의 193을 의미합니다. 해당 로케일에 'A'가있는 경우 현재 로케일에서 'A'일 수도 있고 아닐 수도 있습니다. 마찬가지로 특정 문자에 대한 모든 이스케이프 시퀀스 ( 예 : &lt;code&gt;\n&lt;/code&gt; 는 항상 플랫폼의 기본 이스케이프 문자를 의미합니다. 예를 들어, 정규식 (모든 문자이지만 개행 문자)의 &lt;code&gt;\N&lt;/code&gt; 은 플랫폼 문자 세트에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="fcd641de5265b4e5cb187918ec80acbf65468caa" translate="yes" xml:space="preserve">
          <source>Note that there is no &lt;code&gt;unlock()&lt;/code&gt; function - the only way to unlock a variable is to allow it to go out of scope.</source>
          <target state="translated">&lt;code&gt;unlock()&lt;/code&gt; 함수 는 없습니다 . 변수를 잠금 해제하는 유일한 방법은 범위를 벗어나는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ee4f05af5f26db870953ddb10f74cf79c107ad1e" translate="yes" xml:space="preserve">
          <source>Note that there is no guarantee that the return value of &lt;code&gt;SvPV()&lt;/code&gt; is equal to &lt;code&gt;SvPVX(sv)&lt;/code&gt; , or that &lt;code&gt;SvPVX(sv)&lt;/code&gt; contains valid data, or that successive calls to &lt;code&gt;SvPV(sv)&lt;/code&gt; will return the same pointer value each time. This is due to the way that things like overloading and Copy-On-Write are handled. In these cases, the return value may point to a temporary buffer or similar. If you absolutely need the SvPVX field to be valid (for example, if you intend to write to it), then see &lt;a href=&quot;#SvPV_force&quot;&gt;SvPV_force&lt;/a&gt;.</source>
          <target state="translated">주의 반환 값된다는 보장이 없다는 것을 &lt;code&gt;SvPV()&lt;/code&gt; 와 같다 &lt;code&gt;SvPVX(sv)&lt;/code&gt; , 또는 &lt;code&gt;SvPVX(sv)&lt;/code&gt; 유효한 데이터 또는 해당 연속 호출을 포함 &lt;code&gt;SvPV(sv)&lt;/code&gt; 같은 포인터 값을 매번 반환합니다. 이는 과부하 및 쓰기시 복사와 같은 것들이 처리되는 방식 때문입니다. 이 경우 반환 값은 임시 버퍼 또는 이와 유사한 것을 가리킬 수 있습니다. SvPVX 필드가 유효해야하는 경우 (예 : 필드에 쓰려는 경우) &lt;a href=&quot;#SvPV_force&quot;&gt;SvPV_force&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="61e6ff314bcdd26836be58f3e6e1baf7a7a0e0d1" translate="yes" xml:space="preserve">
          <source>Note that there is no longer any need to import the Tie::Cycle module -- Attribute::Handlers takes care of that automagically. You can even pass arguments to the module's &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine, by appending them to the class name. For example:</source>
          <target state="translated">더 이상 Tie :: Cycle 모듈을 가져올 필요가 없습니다. Attribute :: Handlers가이를 자동으로 처리합니다. 클래스 이름에 인수를 추가하여 모듈의 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 서브 루틴에 인수를 전달할 수도 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="371ae6320cc7816e3fbef9a78451aa3acb900b80" translate="yes" xml:space="preserve">
          <source>Note that there is no method to obtain the filehandle from the C&amp;lt;:temp&amp;gt; object. The object itself acts as a filehandle. The object isa C&amp;lt;:handle&amp;gt; and isa C&amp;lt;:seekable&amp;gt; so all those methods are available.</source>
          <target state="translated">C &amp;lt;: temp&amp;gt; 객체에서 파일 핸들을 얻는 방법은 없습니다. 객체 자체는 파일 핸들 역할을합니다. 객체는 C &amp;lt;: handle&amp;gt; 및 isa C &amp;lt;: seekable&amp;gt;이므로 모든 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8cf101c922aec42258fb611024af08532a1bd0f" translate="yes" xml:space="preserve">
          <source>Note that there's nothing wrong with defining multiple subclasses of a given class. This is both common and safe. For example, we might define &lt;code&gt;File::MP3::FixedBitrate&lt;/code&gt; and &lt;code&gt;File::MP3::VariableBitrate&lt;/code&gt; classes to distinguish between different types of mp3 file.</source>
          <target state="translated">주어진 클래스의 여러 서브 클래스를 정의하는 데 아무런 문제가 없습니다. 이것은 일반적이며 안전합니다. 예를 들어, 다른 유형의 mp3 파일을 구분하기 위해 &lt;code&gt;File::MP3::FixedBitrate&lt;/code&gt; 및 &lt;code&gt;File::MP3::VariableBitrate&lt;/code&gt; 클래스를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cea78bd68a577c917916111e5f8f914537b91ae3" translate="yes" xml:space="preserve">
          <source>Note that these configuration options are only used for generating</source>
          <target state="translated">이 구성 옵션은 생성에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cf6c8c42d064a6c3523dfd07c74fecf239c950de" translate="yes" xml:space="preserve">
          <source>Note that these functions are compatible with *nix, not with the older ports of '94 - 95. The priorities are absolute, go from 32 to -95, lower is quicker. 0 is the default priority.</source>
          <target state="translated">이 기능은 '94-95의 이전 포트가 아닌 * nix와 호환됩니다. 우선 순위는 절대적이며 32에서 -95 사이이며 낮을수록 빠릅니다. 기본 우선 순위는 0입니다.</target>
        </trans-unit>
        <trans-unit id="d791cddf7ffd40104e97e407e1f26e145041f7de" translate="yes" xml:space="preserve">
          <source>Note that these functions take &lt;code&gt;SV*&lt;/code&gt; keys, which simplifies writing of extension code that deals with hash structures. These functions also allow passing of &lt;code&gt;SV*&lt;/code&gt; keys to &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; functions without forcing you to stringify the keys (unlike the previous set of functions).</source>
          <target state="translated">이 함수는 &lt;code&gt;SV*&lt;/code&gt; 키를 사용하므로 해시 구조를 처리하는 확장 코드 작성이 간단 해집니다. 이 기능은 또한의 통과 허용 &lt;code&gt;SV*&lt;/code&gt; 하는 키를 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; (기능의 이전 세트와 달리) 키를 캐릭터 라인 화 할 시작하지 않고 기능을.</target>
        </trans-unit>
        <trans-unit id="ac690cbf2993a60c5814d129da8fb3bc08b59629" translate="yes" xml:space="preserve">
          <source>Note that these macros will only work together within the</source>
          <target state="translated">이 매크로는</target>
        </trans-unit>
        <trans-unit id="8a5f32d79f24485d8dc52ccd8880da69d87a4d12" translate="yes" xml:space="preserve">
          <source>Note that these problems should not discourage experimenting, since they have a low probability of affecting small programs.</source>
          <target state="translated">이러한 문제는 작은 프로그램에 영향을 줄 가능성이 낮으므로 실험을 방해해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="0f02b1ce704f868a5bd6cbc730f85ed167d3d361" translate="yes" xml:space="preserve">
          <source>Note that these routines are</source>
          <target state="translated">이 루틴은</target>
        </trans-unit>
        <trans-unit id="5e158a627cf25fb028df016dfe1afff14abe8a74" translate="yes" xml:space="preserve">
          <source>Note that these statistics are summary only. Actual performance will depend on real hit/miss ratios accessing the hash. If you are concerned by hit ratios you are recommended to &quot;oversize&quot; your hash by using something like:</source>
          <target state="translated">이 통계는 요약 일뿐입니다. 실제 성능은 해시에 액세스하는 실제 히트 / 미스 비율에 따라 다릅니다. 적중률에 관심이있는 경우 다음과 같은 방법으로 해시를 &quot;대용량&quot;하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="73ba985ffd1a15a231f5d43e3ffb4a26ab7bba75" translate="yes" xml:space="preserve">
          <source>Note that this API requires disambiguation between successful decoding a &lt;code&gt;NUL&lt;/code&gt; character, and an error return (unless the UTF8_CHECK_ONLY flag is set), as in both cases, 0 is returned. To disambiguate, upon a zero return, see if the first byte of &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; is 0 as well. If so, the input was a &lt;code&gt;NUL&lt;/code&gt; ; if not, the input had an error.</source>
          <target state="translated">이 API는 &lt;code&gt;NUL&lt;/code&gt; 문자의 성공적인 디코딩 과 오류 리턴 (UTF8_CHECK_ONLY 플래그가 설정되지 않은 경우) 사이에 명확성을 요구합니다 . 두 경우 모두 0이 리턴됩니다. 명확하게하기 위해, 0 리턴시, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 의 첫 바이트 도 0 인지 확인하십시오 . 그렇다면 입력은 &lt;code&gt;NUL&lt;/code&gt; 입니다 . 그렇지 않으면 입력에 오류가있었습니다.</target>
        </trans-unit>
        <trans-unit id="9e7c1fe94057690a3e15fba2814e3a5b075195c1" translate="yes" xml:space="preserve">
          <source>Note that this a lesser issue now when we do not spawn</source>
          <target state="translated">스폰하지 않을 때이 문제는 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="b5ca0aab168c321c8270a6107199325edc3cbbd7" translate="yes" xml:space="preserve">
          <source>Note that this behaviour differs from version 1.00 of the Safe module where the root module could be used to change the namespace. That functionality has been withdrawn pending deeper consideration.</source>
          <target state="translated">이 동작은 네임 스페이스를 변경하는 데 루트 모듈을 사용할 수있는 안전 모듈 버전 1.00과 다릅니다. 그 기능은 더 깊이 고려되어 철회되었습니다.</target>
        </trans-unit>
        <trans-unit id="886c9a49ed86dcbe7c33a66300a271b1c555293b" translate="yes" xml:space="preserve">
          <source>Note that this business of escaping a newline is specific to interactive commands typed into the debugger.</source>
          <target state="translated">개행을 피하는이 사업은 디버거에 입력 된 대화식 명령에만 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="d9af4c6dbd50132dd9aa57c1076bfc7d75c87275" translate="yes" xml:space="preserve">
          <source>Note that this class also provides (but does not export) the function Pod::Simple::HTMLBatch::go. This is basically just a shortcut for &lt;code&gt;Pod::Simple::HTMLBatch-&amp;gt;batch_convert(@ARGV)&lt;/code&gt; . It's meant to be handy for calling from the command line.</source>
          <target state="translated">이 클래스는 또한 Pod :: Simple :: HTMLBatch :: go 함수를 제공하지만 내보내지는 않습니다. 이것은 기본적으로 &lt;code&gt;Pod::Simple::HTMLBatch-&amp;gt;batch_convert(@ARGV)&lt;/code&gt; 의 바로 가기입니다 . 명령 행에서 호출하기에 편리합니다.</target>
        </trans-unit>
        <trans-unit id="cbd3cc83f76f664edbfed1f74f0bb7a74cadfcdb" translate="yes" xml:space="preserve">
          <source>Note that this does *not* collapse</source>
          <target state="translated">이것은 축소되지 * 않습니다 *</target>
        </trans-unit>
        <trans-unit id="00224048b57a554f368bf0ab411d2ec7b380142b" translate="yes" xml:space="preserve">
          <source>Note that this does not respect any locale that might be in effect; it matches according to the platform's native character set.</source>
          <target state="translated">이것은 유효한 로케일을 존중하지 않습니다. 플랫폼의 고유 문자 세트에 따라 일치합니다.</target>
        </trans-unit>
        <trans-unit id="c41629303d26db24c4cf7e890ae9d3b978c9901b" translate="yes" xml:space="preserve">
          <source>Note that this example shows the values of the lexicals, whereas the other examples did not (as they're compile-time only).</source>
          <target state="translated">이 예제는 어휘의 값을 보여 주지만 다른 예제는 그렇지 않습니다 (컴파일 타임 일 뿐이므로).</target>
        </trans-unit>
        <trans-unit id="fa65d225bcb30ebd19ec0f94b22dc45327203c89" translate="yes" xml:space="preserve">
          <source>Note that this function does</source>
          <target state="translated">이 기능은</target>
        </trans-unit>
        <trans-unit id="383a0ca4f40d5e081bc8cd1b9b45b6acddf8c873" translate="yes" xml:space="preserve">
          <source>Note that this harness is</source>
          <target state="translated">이 하네스는</target>
        </trans-unit>
        <trans-unit id="26765a3c9e68c0777ae5d0fb4a579c61611c0dca" translate="yes" xml:space="preserve">
          <source>Note that this hash does not include numerics (like &quot;64&quot; or &quot;x981c&quot;).</source>
          <target state="translated">이 해시는 숫자 (예 : &quot;64&quot;또는 &quot;x981c&quot;)를 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d9c356ba63dd81b549b024d31174e2c723d0a6c7" translate="yes" xml:space="preserve">
          <source>Note that this is a backwards incompatible change from version &lt;code&gt;1.36&lt;/code&gt; and before.</source>
          <target state="translated">이것은 버전 &lt;code&gt;1.36&lt;/code&gt; 과 이전 버전 과 호환되지 않는 변경 사항입니다 .</target>
        </trans-unit>
        <trans-unit id="d089b782c3356f4400063cd34b72b66e78bb2e56" translate="yes" xml:space="preserve">
          <source>Note that this is a unary operator, not a list operator.</source>
          <target state="translated">이것은리스트 연산자가 아닌 단항 연산자입니다.</target>
        </trans-unit>
        <trans-unit id="dcb3c6a57a75c99d73d6d08c842005a53c2cad92" translate="yes" xml:space="preserve">
          <source>Note that this is an experimental feature which may be changed or removed in a future Perl release.</source>
          <target state="translated">이는 향후 Perl 릴리스에서 변경되거나 제거 될 수있는 실험적인 기능입니다.</target>
        </trans-unit>
        <trans-unit id="504d8cb8d0a49d57ae71301eeedf5cb16096e2bb" translate="yes" xml:space="preserve">
          <source>Note that this is not in general possible in shells of more dubious heritage, as the theoretical</source>
          <target state="translated">이것은 이론적으로 더 모호한 유산의 껍질에서는 일반적으로 가능하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9b1de500fa4baebd7c567a7a827d4c48d84fe735" translate="yes" xml:space="preserve">
          <source>Note that this is not the same thing as &lt;code&gt;$self-&amp;gt;SUPER::m()&lt;/code&gt; , which begins a new dispatch that is restricted to searching the ancestors of the current class. &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt; can backtrack past the current class -- to look for a suitable method in other ancestors of &lt;code&gt;$self&lt;/code&gt; -- whereas &lt;code&gt;$self-&amp;gt;SUPER::m()&lt;/code&gt; cannot.</source>
          <target state="translated">이것은 &lt;code&gt;$self-&amp;gt;SUPER::m()&lt;/code&gt; 과 동일하지 않으므로 현재 클래스의 조상을 검색하는 것으로 제한되는 새 디스패치를 ​​시작합니다. &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt; 은 현재 클래스를 역 추적하여 &lt;code&gt;$self&lt;/code&gt; 의 다른 조상에서 적합한 메소드를 찾을 수 있지만 &lt;code&gt;$self-&amp;gt;SUPER::m()&lt;/code&gt; 은 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fb474ba009e8c7c8d7bdb3779c16f4d2c9b0cba8" translate="yes" xml:space="preserve">
          <source>Note that this is one of the rare cases where you cannot use the same template for &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; because &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; can't determine a repeat count for a &lt;code&gt;()&lt;/code&gt; -group.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;()&lt;/code&gt; - 그룹 의 반복 횟수를 결정할 수 없기 때문에 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 에 동일한 템플릿을 사용할 수없는 드문 경우 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="37d289726dbf38f52d7d747a6f498b593946b256" translate="yes" xml:space="preserve">
          <source>Note that this is the</source>
          <target state="translated">이것은</target>
        </trans-unit>
        <trans-unit id="051c395ae34aa1a11e3b94b0cb470642628b722b" translate="yes" xml:space="preserve">
          <source>Note that this isn't really a word in the English sense; it's just chunks of consecutive non-whitespace characters.</source>
          <target state="translated">이것은 실제로 영어의 단어가 아닙니다. 공백이 아닌 연속 된 문자 덩어리입니다.</target>
        </trans-unit>
        <trans-unit id="f98a99684b1c3e2bccd26b3c2631a053bdfaf9be" translate="yes" xml:space="preserve">
          <source>Note that this issue precludes the building of many Macintosh-specific CPAN modules (&lt;code&gt;Mac::*&lt;/code&gt; ), as the required Apple frameworks do not provide PPC64 support. Similarly, downloads from Fink or Darwinports are unlikely to provide 64-bit support; the libraries must be rebuilt from source with the appropriate compiler and linker flags. For further information, see Apple's</source>
          <target state="translated">필요한 Apple 프레임 워크가 PPC64 지원을 제공하지 않기 때문에이 문제로 많은 Macintosh 특정 CPAN 모듈 ( &lt;code&gt;Mac::*&lt;/code&gt; )을 구축 할 수 없습니다. 마찬가지로 Fink 또는 Darwinports에서 다운로드 한 파일은 64 비트 지원을 제공하지 않을 것입니다. 라이브러리는 적절한 컴파일러 및 링커 플래그를 사용하여 소스에서 다시 작성해야합니다. 자세한 내용은 Apple의</target>
        </trans-unit>
        <trans-unit id="3cf9c28e72f601c60b3c701ee74ca406285e72fe" translate="yes" xml:space="preserve">
          <source>Note that this last example is</source>
          <target state="translated">이 마지막 예는</target>
        </trans-unit>
        <trans-unit id="d42f0b82dfd8478b8b9451848cff1ed7d60be50b" translate="yes" xml:space="preserve">
          <source>Note that this means that Perl expects other software to work the same way: if Perl has been led to believe that STDIN should be UTF-8, but then STDIN coming in from another command is not UTF-8, Perl will likely complain about the malformed UTF-8.</source>
          <target state="translated">이는 Perl이 다른 소프트웨어가 동일한 방식으로 작동 할 것으로 예상한다는 것을 의미합니다. Perl이 STDIN이 UTF-8이어야한다고 믿게되었지만 다른 명령에서 들어오는 STDIN이 UTF-8이 아니라면 Perl은 잘못된 UTF-8.</target>
        </trans-unit>
        <trans-unit id="eb14855fa34c491b4e9b69501367a6f35eac94cc" translate="yes" xml:space="preserve">
          <source>Note that this means that there is no way for the inner pattern to refer to a capture group defined outside. (The code block itself can use &lt;code&gt;$1&lt;/code&gt; , etc., to refer to the enclosing pattern's capture groups.) Thus, although</source>
          <target state="translated">이는 내부 패턴이 외부에 정의 된 캡처 그룹을 참조 할 방법이 없음을 의미합니다. (코드 블록 자체는 &lt;code&gt;$1&lt;/code&gt; 등을 사용하여 둘러싸는 패턴의 캡처 그룹을 참조 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="cb2f7fa1807b6ef282836388add7c29032688f86" translate="yes" xml:space="preserve">
          <source>Note that this method does not write &lt;code&gt;on the fly&lt;/code&gt; as it were; it still reads all the files into memory before writing out the archive. Consult the FAQ below if this is a problem.</source>
          <target state="translated">이 방법은 쓰지 않습니다 &lt;code&gt;on the fly&lt;/code&gt; 말하자면, 아카이브를 작성하기 전에 여전히 모든 파일을 메모리로 읽습니다. 문제가있는 경우 아래 FAQ를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9ebf1673f6d5cc53332f54347212529a0a096746" translate="yes" xml:space="preserve">
          <source>Note that this method merely returns the comment preceded by a '# '.</source>
          <target state="translated">이 메소드는 주석 앞에 '#'이 오는 주석 만 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="e4bf33faadadb73f5033c17a03e0a21d5d47bf67" translate="yes" xml:space="preserve">
          <source>Note that this only affects how most of the arithmetic and relational &lt;b&gt;operators&lt;/b&gt; handle their operands and results, and &lt;b&gt;not&lt;/b&gt; how all numbers everywhere are treated. Specifically, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; has the effect that before computing the results of the arithmetic operators (+, -, *, /, %, +=, -=, *=, /=, %=, and unary minus), the comparison operators (&amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, ==, !=, &amp;lt;=&amp;gt;), and the bitwise operators (|, &amp;amp;, ^, &amp;lt;&amp;lt;,&amp;gt;&amp;gt;, |=, &amp;amp;=, ^=, &amp;lt;&amp;lt;=,&amp;gt;&amp;gt;=), the operands have their fractional portions truncated (or floored), and the result will have its fractional portion truncated as well. In addition, the range of operands and results is restricted to that of familiar two's complement integers, i.e., -(2**31) .. (2**31-1) on 32-bit architectures, and -(2**63) .. (2**63-1) on 64-bit architectures. For example, this code</source>
          <target state="translated">이것은 모든 산술 및 관계 &lt;b&gt;연산자&lt;/b&gt; 가 피연산자와 결과를 처리 하는 방식에만 영향을 미치며 모든 숫자가 처리되는 방식 에는 영향을 &lt;b&gt;주지 않습니다&lt;/b&gt; . 특히 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용하십시오&lt;/a&gt; .산술 연산자 (+,-, *, /, %, + =,-=, * =, / =, % = 및 단항 빼기)의 결과를 계산하기 전에 비교 연산자 (&amp;lt;, &amp;lt; =,&amp;gt;,&amp;gt; =, ==,! =, &amp;lt;=&amp;gt;) 및 비트 연산자 (|, &amp;amp;, ^, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, | =, &amp;amp; =, ^ =, &amp;lt;&amp;lt; =, &amp;gt;&amp;gt; =), 피연산자에는 분수 부분이 잘 리거나 바닥이 있으며 결과에도 분수 부분이 잘립니다. 또한 피연산자와 결과 범위는 익숙한 2의 보수 정수, 즉-(2 ** 31) .. (2 ** 31-1) (32 비트 아키텍처) 및-(2 **)의 범위로 제한됩니다. 63) .. (2 ** 63-1) 64 비트 아키텍처. 예를 들어,이 코드</target>
        </trans-unit>
        <trans-unit id="641efca71748ee43843d8c870296735b58cb247a" translate="yes" xml:space="preserve">
          <source>Note that this option is probably not useful when converting multiple POD files at once. The convention for Unix man pages for commands is for the man page title to be in all-uppercase even if the command isn't.</source>
          <target state="translated">이 옵션은 여러 POD 파일을 한 번에 변환 할 때 유용하지 않을 수 있습니다. 명령에 대한 Unix 매뉴얼 페이지의 규칙은 명령이 아닌 경우에도 매뉴얼 페이지 제목이 모두 대문자가되도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="650a0cb19795021c90db4bffb31d952d9b4b0616" translate="yes" xml:space="preserve">
          <source>Note that this typemap does not decrement the reference count when returning an AV*. See also: T_AVREF_REFCOUNT_FIXED</source>
          <target state="translated">이 타입 맵은 AV *를 반환 할 때 참조 카운트를 감소시키지 않습니다. 참조 : T_AVREF_REFCOUNT_FIXED</target>
        </trans-unit>
        <trans-unit id="75948654033e1807460f39019ce055bccbe6d14b" translate="yes" xml:space="preserve">
          <source>Note that this typemap does not decrement the reference count when returning an HV*. See also: T_HVREF_REFCOUNT_FIXED</source>
          <target state="translated">이 타입 맵은 HV *를 반환 할 때 참조 카운트를 감소시키지 않습니다. 참조 : T_HVREF_REFCOUNT_FIXED</target>
        </trans-unit>
        <trans-unit id="4c5b3cb2ecd59af3fa9332d1a075ffadbd08c0cb" translate="yes" xml:space="preserve">
          <source>Note that this typemap does not decrement the reference count when returning the reference to an SV*. See also: T_SVREF_REFCOUNT_FIXED</source>
          <target state="translated">이 타입 맵은 SV *에 참조를 반환 할 때 참조 카운트를 감소시키지 않습니다. 참조 : T_SVREF_REFCOUNT_FIXED</target>
        </trans-unit>
        <trans-unit id="fdb88d672a97dbd887a0e264f45a135e237c14a4" translate="yes" xml:space="preserve">
          <source>Note that this variable was added in Perl 5.14.0. If you want to detect the global destruction phase on older versions of Perl, you can use the &lt;code&gt;Devel::GlobalDestruction&lt;/code&gt; module on CPAN.</source>
          <target state="translated">이 변수는 Perl 5.14.0에서 추가되었습니다. 이전 버전의 Perl에서 글로벌 폐기 단계를 감지하려면 CPAN 에서 &lt;code&gt;Devel::GlobalDestruction&lt;/code&gt; 모듈을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="79cbc4907067b711c2733dabb85b47c17c625682" translate="yes" xml:space="preserve">
          <source>Note that this version number is not the same as the version number of the Storable module itself. For instance Storable v0.7 create files in format v2.0 and Storable v2.15 create files in format v2.7. The file format version number only increment when additional features that would confuse older versions of the module are added.</source>
          <target state="translated">이 버전 번호는 Storable 모듈 자체의 버전 번호와 동일하지 않습니다. 예를 들어 Storable v0.7은 v2.0 형식의 파일을 작성하고 Storable v2.15는 v2.7 형식의 파일을 작성합니다. 파일 형식 버전 번호는 이전 버전의 모듈을 혼동시키는 추가 기능이 추가 된 경우에만 증가합니다.</target>
        </trans-unit>
        <trans-unit id="c30cc57c265bdbcc01b87c7faff90971cd8cbcd5" translate="yes" xml:space="preserve">
          <source>Note that this will not apply to distributions that failed tests because of missing dependencies. Also, tests can be run regardless of the history using &quot;force&quot;.</source>
          <target state="translated">종속성 누락으로 인해 테스트에 실패한 배포에는 적용되지 않습니다. 또한 &quot;force&quot;를 사용하여 기록에 관계없이 테스트를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="129dbf47ba2ec65b5d9ac83fd612d686af9cd750" translate="yes" xml:space="preserve">
          <source>Note that this will produce something similar, but it's much harder to read:</source>
          <target state="translated">이렇게하면 비슷한 내용이 나오지만 읽기가 훨씬 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="76667870087c43a89a0c134d31da84f873df4c85" translate="yes" xml:space="preserve">
          <source>Note that to create Bzip2 content, the module &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; must be installed.</source>
          <target state="translated">Bzip2 컨텐츠를 작성하려면 모듈 &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; 가 설치되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c112c0c0f309f422ad0d8ea094e2f892edb8359d" translate="yes" xml:space="preserve">
          <source>Note that to create Bzip2 content, the module &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; must be installed. A fatal error will be thrown if you attempt to create Bzip2 content when &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; is not available.</source>
          <target state="translated">Bzip2 컨텐츠를 작성하려면 모듈 &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; 가 설치되어 있어야합니다. &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; 를 사용할 수 없을 때 Bzip2 컨텐츠를 작성하려고하면 치명적인 오류가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="91dea059c3c6adecb3e060a72157c015c80d8709" translate="yes" xml:space="preserve">
          <source>Note that to create LZMA content, the module &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; must be installed.</source>
          <target state="translated">LZMA 컨텐츠를 작성하려면 모듈 &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; 가 설치되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="9d4a2616c449298e5f9b3c703f0555b52ba58730" translate="yes" xml:space="preserve">
          <source>Note that to create Lzma content, the module &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; must be installed. A fatal error will be thrown if you attempt to create Lzma content when &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; is not available.</source>
          <target state="translated">Lzma 컨텐츠를 작성하려면 모듈 &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; 가 설치되어 있어야합니다. &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; 를 사용할 수 없을 때 Lzma 컨텐츠를 작성하려고하면 치명적인 오류가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="59026c8cb18df6e69670873afd609b7b5991b245" translate="yes" xml:space="preserve">
          <source>Note that to delete a breakpoint you use 'B'.</source>
          <target state="translated">중단 점을 삭제하려면 'B'를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ccec21a98f6b093bde7ead086f9b2aa6d9fa5cbe" translate="yes" xml:space="preserve">
          <source>Note that to terminate options processing still requires a double dash &lt;code&gt;--&lt;/code&gt; .</source>
          <target state="translated">옵션 처리를 종료하려면 여전히 이중 대시 ( &lt;code&gt;--&lt;/code&gt; 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="3f1f1b6c5624a2d3ed9722ba6d811a877dbe016a" translate="yes" xml:space="preserve">
          <source>Note that turning this attribute to true won't suppress one or two kinds of complaints about rarely occurring unrecoverable errors.</source>
          <target state="translated">이 속성을 true로 설정해도 복구 할 수없는 오류가 거의 발생하지 않는다는 한 가지 또는 두 가지 유형의 불만은 억제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6db90d2a3a43a0d1ae1c73a0ecadf4c50a061235" translate="yes" xml:space="preserve">
          <source>Note that under Perls older than 5.8.0, Perl uses the standard C library's' fdopen() to implement the &lt;code&gt;=&lt;/code&gt; functionality. On many Unix systems, fdopen() fails when file descriptors exceed a certain value, typically 255. For Perls 5.8.0 and later, PerlIO is (most often) the default.</source>
          <target state="translated">5.8.0 이전의 Perls에서 Perl은 표준 C 라이브러리의 fdopen ()을 사용하여 &lt;code&gt;=&lt;/code&gt; 기능 을 구현합니다 . 많은 Unix 시스템에서 파일 디스크립터가 특정 값 (일반적으로 255)을 초과하면 fdopen ()이 실패합니다. Perls 5.8.0 이상에서는 PerlIO가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="ab1035410dccd2a93f4a5e17c32c7a15d00a2658" translate="yes" xml:space="preserve">
          <source>Note that under Win32</source>
          <target state="translated">Win32에서</target>
        </trans-unit>
        <trans-unit id="914bcfd8302ee9c0b531fac815eb7bd7d964c235" translate="yes" xml:space="preserve">
          <source>Note that under bigint, the result is truncated to an integer.</source>
          <target state="translated">bigint에서 결과는 정수로 잘립니다.</target>
        </trans-unit>
        <trans-unit id="57f113ec30505dad704cf4b4934d930e547970b7" translate="yes" xml:space="preserve">
          <source>Note that under some systems, like OS/2, there may be different flavors of Perl executables, some of which may support fork, some not. Try changing the name you call Perl by to &lt;code&gt;perl_&lt;/code&gt; , &lt;code&gt;perl__&lt;/code&gt; , and so on.</source>
          <target state="translated">OS / 2와 같은 일부 시스템에서는 다양한 Perl 실행 파일이있을 수 있으며, 일부는 포크를 지원할 수 있지만 일부는 지원하지 않을 수 있습니다. Perl이라고 부르는 이름을 &lt;code&gt;perl_&lt;/code&gt; , &lt;code&gt;perl__&lt;/code&gt; 등으로 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="6c3fb4d37b79c5b47a3b48e544166fc16ead2f30" translate="yes" xml:space="preserve">
          <source>Note that unfortunately none of the above constants are guaranteed to be available on a particular platform. To be on the safe side you can wrap the import in an eval like this:</source>
          <target state="translated">불행히도 위의 상수 중 어느 것도 특정 플랫폼에서 사용 가능한 것은 아닙니다. 안전을 위해 다음과 같이 평가판을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b70409449e4cf24aa93c5134b0fc7650b311f3ce" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;code&gt;\s&lt;/code&gt; (and &lt;code&gt;\d&lt;/code&gt; and &lt;code&gt;\w&lt;/code&gt; ), &lt;code&gt;\h&lt;/code&gt; and &lt;code&gt;\v&lt;/code&gt; always match the same characters, without regard to other factors, such as the active locale or whether the source string is in UTF-8 format.</source>
          <target state="translated">&lt;code&gt;\s&lt;/code&gt; (및 &lt;code&gt;\d&lt;/code&gt; 및 &lt;code&gt;\w&lt;/code&gt; ) 와 달리 \ &lt;code&gt;\h&lt;/code&gt; 및 &lt;code&gt;\v&lt;/code&gt; 는 활성 로캘과 같은 다른 요인이나 소스 문자열이 UTF-8 형식인지 여부에 관계없이 항상 동일한 문자를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="4e3b99648e034c07d6ccefb2454f1a213adb3a01" translate="yes" xml:space="preserve">
          <source>Note that version 1.00 of the Safe module supported a second optional parameter, MASK. That functionality has been withdrawn pending deeper consideration. Use the permit and deny methods described below.</source>
          <target state="translated">안전 모듈 1.00 버전은 두 번째 선택적 매개 변수 인 MASK를 지원했습니다. 그 기능은 더 깊이 고려되어 철회되었습니다. 아래 설명 된 허가 및 거부 방법을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c573631a77e48c40f9d95496d1ab64657ba98bf8" translate="yes" xml:space="preserve">
          <source>Note that we now have to pass the cycling values as an array reference, since the &lt;code&gt;autotie&lt;/code&gt; mechanism passes &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; a list of arguments as a list (as in the Tie::Whatever example),</source>
          <target state="translated">&lt;code&gt;autotie&lt;/code&gt; 메커니즘이 인수 목록을 목록으로 &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 때문에 (Tie :: Whatever 예제에서 와 같이) 사이클링 값을 배열 참조로 전달해야합니다 .</target>
        </trans-unit>
        <trans-unit id="97433e963bcde523d9d0fce2f4cd1302dfe4a201" translate="yes" xml:space="preserve">
          <source>Note that when a form of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; that doesn't include all categories is specified, Perl ignores the excluded categories.</source>
          <target state="translated">모든 카테고리를 포함하지 않는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 형식 이 지정되면 Perl은 제외 된 카테고리를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="d5903fec6aa5f11cb69596fd7a3ca663ff0e5fa7" translate="yes" xml:space="preserve">
          <source>Note that when outputting to a file with streaming mode disabled (&lt;code&gt;Stream&lt;/code&gt; is 0), the output file must be seekable.</source>
          <target state="translated">스트리밍 모드가 비활성화 된 상태에서 ( &lt;code&gt;Stream&lt;/code&gt; is 0) 파일로 출력 할 때는 출력 파일을 찾을 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="7344bc816db754cd590cf06e917e5573598a9b73" translate="yes" xml:space="preserve">
          <source>Note that when the zlib sources are built along with this module the &lt;code&gt;&lt;a href=&quot;../../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; flags (bits 24, 25 and 26) should be ignored.</source>
          <target state="translated">zlib 소스가이 모듈과 함께 빌드 될 때 &lt;code&gt;&lt;a href=&quot;../../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 플래그 (비트 24, 25 및 26)는 무시해야합니다.</target>
        </trans-unit>
        <trans-unit id="9c5df280c1345062d47399d4030c040fff592e61" translate="yes" xml:space="preserve">
          <source>Note that when there is only a section argument the URL will simply be a link to a section in the current document.</source>
          <target state="translated">섹션 인수 만있는 경우 URL은 단순히 현재 문서의 섹션에 대한 링크 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="71260102fd6d68816796fad6d6c8b41eba351c69" translate="yes" xml:space="preserve">
          <source>Note that when using perl in the default build configuration on Win32 (specifically, when perl is built with PERL_IMPLICIT_SYS), each perl interpreter maintains its own copy of the environment and only the main interpreter will update the process environment seen by strftime.</source>
          <target state="translated">Win32의 기본 빌드 구성에서 perl을 사용할 때 (특히 perl_IMPLICIT_SYS를 사용하여 perl을 빌드 할 때) perl 인터프리터는 자체 환경 사본을 유지하며 기본 인터프리터 만 strftime에 표시된 프로세스 환경을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="2effebabf11283b202bbac0c8af96deb9da5f75f" translate="yes" xml:space="preserve">
          <source>Note that when using threads and in Linux this is &lt;b&gt;not&lt;/b&gt; a good way to exit a thread because in Linux processes and threads are kind of the same thing (Note: while this is the situation in early 2003 there are projects under way to have threads with more POSIXly semantics in Linux). If you want not to return from a thread, detach the thread.</source>
          <target state="translated">스레드와 Linux를 사용할 때 Linux 프로세스와 스레드는 같은 종류이기 때문에 스레드를 종료하는 좋은 방법 이 &lt;b&gt;아닙니다&lt;/b&gt; . (참고 : 2003 년 초의 상황이지만 스레드가있는 프로젝트가 진행 중입니다. 리눅스에서 더 POSIXly 의미론). 실에서 돌아 가지 않으려면 실을 분리하십시오.</target>
        </trans-unit>
        <trans-unit id="4736a205597baa102d5326de4253133a227c54d5" translate="yes" xml:space="preserve">
          <source>Note that when you pass in a filehandle, the compression argument is ignored, as all files are printed verbatim to your filehandle. If you wish to enable compression with filehandles, use an &lt;code&gt;IO::Zlib&lt;/code&gt; or &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; filehandle instead.</source>
          <target state="translated">파일 핸들을 전달하면 모든 파일이 파일 핸들에 그대로 인쇄되므로 압축 인수가 무시됩니다. 파일 핸들로 압축을 사용하려면 &lt;code&gt;IO::Zlib&lt;/code&gt; 또는 &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; 파일 핸들을 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fec466d7589681ffa02822a2ed4bde47bc9a77f7" translate="yes" xml:space="preserve">
          <source>Note that whether &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; gets restarted after signals (say, SIGALRM) is implementation-dependent. See also &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for notes on the portability of &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">신호 (SIGALRM) 후에 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 가 다시 시작 되는지 여부 는 구현에 따라 다릅니다. &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 의 이식성에 대한 참고 사항 은 &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="948671b067e6b6895231193e86d7353898979d1b" translate="yes" xml:space="preserve">
          <source>Note that whether &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; gets restarted after signals (say, SIGALRM) is implementation-dependent. See also &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt; for notes on the portability of &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">신호 (SIGALRM) 후에 &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 가 다시 시작 되는지 여부 는 구현에 따라 다릅니다. &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 의 이식성에 대한 참고 사항 은 &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ffc7e69e46e535688eedc16caabf4a74055bdca" translate="yes" xml:space="preserve">
          <source>Note that while &lt;code&gt;prove&lt;/code&gt; accepts a list of tests (or things to be tested), &lt;code&gt;new&lt;/code&gt; has a fairly rich set of arguments. You'll probably want to read over this code carefully to see how all of them are being used.</source>
          <target state="translated">동안 참고 &lt;code&gt;prove&lt;/code&gt; 시험의 목록을 받아 (또는 물건을 테스트 할은), &lt;code&gt;new&lt;/code&gt; 인수 상당히 풍부한 있습니다. 모든 코드가 어떻게 사용되는지 확인하려면이 코드를주의 깊게 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="50e7deab8f4fd86f8154084a7e3b56909e616473" translate="yes" xml:space="preserve">
          <source>Note that while the above category system is presently a strict hierarchy, this should not be assumed.</source>
          <target state="translated">위의 범주 시스템은 현재 엄격한 계층 구조이지만이를 가정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="bc9931d84d19856544f694976f9d6846875a28cb" translate="yes" xml:space="preserve">
          <source>Note that while threads themselves are separate execution threads and Perl data is thread-private unless explicitly shared, the threads can affect process-scope state, affecting all the threads.</source>
          <target state="translated">스레드 자체는 별도의 실행 스레드이고 Perl 데이터는 명시 적으로 공유하지 않는 한 스레드 전용이지만 스레드는 프로세스 범위 상태에 영향을 미쳐 모든 스레드에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1aeee605f9778048bf8180ea5497c85eb816a43f" translate="yes" xml:space="preserve">
          <source>Note that while we obtained this value using a nice little script, there is no simple way to</source>
          <target state="translated">멋진 작은 스크립트를 사용하여이 값을 얻었지만 간단한 방법은 없습니다.</target>
        </trans-unit>
        <trans-unit id="7977096f1b31f6699d5f208fb012da3a5261f7ca" translate="yes" xml:space="preserve">
          <source>Note that with a parenthesised list, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; can be used as a dummy placeholder, for example to skip assignment of initial values:</source>
          <target state="translated">괄호로 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 목록을 사용하면 undef 를 더미 자리 표시 자로 사용하여 초기 값 할당을 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f05ed1d19fb4f3d163934a654b623969a521af79" translate="yes" xml:space="preserve">
          <source>Note that with a parenthesised list, &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; can be used as a dummy placeholder, for example to skip assignment of initial values:</source>
          <target state="translated">괄호로 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 목록을 사용하면 undef 를 더미 자리 표시 자로 사용하여 초기 값 할당을 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f837139e0f9184e4fee4005308a9ebc6c5173a19" translate="yes" xml:space="preserve">
          <source>Note that with all the above cases, you can determine which type of &quot;=over&quot; ... &quot;=back&quot; you have, by examining the first (non-&quot;=cut&quot;, non-&quot;=pod&quot;) Pod paragraph after the &quot;=over&quot; command.</source>
          <target state="translated">위의 모든 경우에서 첫 번째 ( &quot;-cut&quot;, &quot;-&quot;pod &quot;) 포드 단락을 검사하여&quot;= over &quot;...&quot;= back &quot;유형을 결정할 수 있습니다. &quot;= over&quot;명령.</target>
        </trans-unit>
        <trans-unit id="47d723b6fa427f34bf483595a539dcd989378967" translate="yes" xml:space="preserve">
          <source>Note that write is</source>
          <target state="translated">쓰기는</target>
        </trans-unit>
        <trans-unit id="83605b35f7f66a38c8e887a3f52c350d6d00fd1c" translate="yes" xml:space="preserve">
          <source>Note that you</source>
          <target state="translated">당신이</target>
        </trans-unit>
        <trans-unit id="4c6cd8d5f09bd8fe8bd4f6cd6ec9d1cc03592811" translate="yes" xml:space="preserve">
          <source>Note that you always have to rethrow an exception that has been caught. Using these macros, it is not possible to just catch the exception and ignore it. If you have to ignore the exception, you have to use the &lt;code&gt;call_*&lt;/code&gt; function.</source>
          <target state="translated">잡은 예외는 항상 다시 발생시켜야합니다. 이러한 매크로를 사용하면 예외를 잡아 무시할 수 없습니다. 예외를 무시 &lt;code&gt;call_*&lt;/code&gt; 경우 call_ * 함수 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="294ab6e75ddb8b55c12bca78ca4c1964234fee2f" translate="yes" xml:space="preserve">
          <source>Note that you can also apply two or more of the same type of filter in a single &lt;code&gt;FILTER_ONLY&lt;/code&gt; . For example, here's a simple macro-preprocessor that is only applied within regexes, with a final debugging pass that prints the resulting source code:</source>
          <target state="translated">단일 &lt;code&gt;FILTER_ONLY&lt;/code&gt; 에 동일한 유형의 필터를 두 개 이상 적용 할 수도 있습니다 . 예를 들어 다음은 정규 매크로에만 적용되는 간단한 매크로 프리 프로세서이며 최종 소스 코드를 출력하는 최종 디버깅 패스입니다.</target>
        </trans-unit>
        <trans-unit id="2c7b682995e33f0fbc55867b39c415016eb6e0ab" translate="yes" xml:space="preserve">
          <source>Note that you can also call &lt;code&gt;batch_convert&lt;/code&gt; as a class method, like so:</source>
          <target state="translated">&lt;code&gt;batch_convert&lt;/code&gt; 과 같이 batch_convert 를 클래스 메소드로 호출 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd91cd131ba58a9a28d1ab6ce3c7b99f825d3515" translate="yes" xml:space="preserve">
          <source>Note that you can also use:</source>
          <target state="translated">다음을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f681263fb98ec8c6eb8d4798ad8027fd4826097" translate="yes" xml:space="preserve">
          <source>Note that you can currently &lt;b&gt;not&lt;/b&gt; pass a &lt;code&gt;gzip&lt;/code&gt; compressed filehandle, which is not opened with &lt;code&gt;IO::Zlib&lt;/code&gt; , a &lt;code&gt;bzip2&lt;/code&gt; compressed filehandle, which is not opened with &lt;code&gt;IO::Uncompress::Bunzip2&lt;/code&gt; , nor a string containing the full archive information (either compressed or uncompressed). These are worth while features, but not currently implemented. See the &lt;code&gt;TODO&lt;/code&gt; section.</source>
          <target state="translated">참고 현재 수 &lt;b&gt;없는&lt;/b&gt; 패스 &lt;code&gt;gzip&lt;/code&gt; 을 함께 열려 있지 압축 파일 핸들, &lt;code&gt;IO::Zlib&lt;/code&gt; 하는 &lt;code&gt;bzip2&lt;/code&gt; 에 와 열려 있지 압축 파일 핸들, &lt;code&gt;IO::Uncompress::Bunzip2&lt;/code&gt; 하나 (도 전체 아카이브 정보를 포함하는 문자열을 압축 또는 비 압축). 이것들은 가치가 있지만 현재 구현되어 있지는 않지만 가치가 있습니다. &lt;code&gt;TODO&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b5e3d8e2902a442515aac1df82a9b27598246cd6" translate="yes" xml:space="preserve">
          <source>Note that you can define your own properties; see &lt;a href=&quot;perlunicode#User-Defined-Character-Properties&quot;&gt;User-Defined Character Properties in perlunicode&lt;/a&gt;.</source>
          <target state="translated">자신의 속성을 정의 할 수 있습니다. &lt;a href=&quot;perlunicode#User-Defined-Character-Properties&quot;&gt;perlunicode의 사용자 정의 문자 특성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="78e5ead015db87b26d2638e6d6d6c409fabb1756" translate="yes" xml:space="preserve">
          <source>Note that you can distinguish URL-links from anything else by the fact that they match &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A\w+:[^:\s]\S*\z/&lt;/a&gt;&lt;/code&gt;. So &lt;code&gt;L&amp;lt;&lt;a href=&quot;http://www.perl.com&quot;&gt;http://www.perl.com&lt;/a&gt;&amp;gt;&lt;/code&gt; is a URL, but &lt;code&gt;L&amp;lt;HTTP::Response&amp;gt;&lt;/code&gt; isn't.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A\w+:[^:\s]\S*\z/&lt;/a&gt;&lt;/code&gt; 와 일치한다는 점에서 URL 링크를 다른 것과 구별 할 수 있습니다 . 따라서 &lt;code&gt;L&amp;lt;&lt;a href=&quot;http://www.perl.com&quot;&gt;http://www.perl.com&lt;/a&gt;&amp;gt;&lt;/code&gt; 은 URL이지만 &lt;code&gt;L&amp;lt;HTTP::Response&amp;gt;&lt;/code&gt; 는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7fe488ce16efed40af87572587352aab8acda941" translate="yes" xml:space="preserve">
          <source>Note that you can modify the encoding of a file opened by File::Temp also by using C</source>
          <target state="translated">File :: Temp에서 연 파일의 인코딩을 C를 사용하여 수정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="11456d05bc1241402ca1d0ee0660f0d072ab6bd4" translate="yes" xml:space="preserve">
          <source>Note that you can use the &lt;code&gt;ls&lt;/code&gt; command to get this path listed.</source>
          <target state="translated">&lt;code&gt;ls&lt;/code&gt; 명령을 사용 하여이 경로를 나열 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a185692d5c427a3444515426bf12dadcf9d46376" translate="yes" xml:space="preserve">
          <source>Note that you can use this to nest &quot;todo&quot; tests</source>
          <target state="translated">이것을 사용하여 &quot;todo&quot;테스트를 중첩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47332c504fbc5ef10c78203997d49e50906b8018" translate="yes" xml:space="preserve">
          <source>Note that you can't reliably block or unblock a signal from its own signal handler if you're using safe signals. Other signals can be blocked or unblocked reliably.</source>
          <target state="translated">안전 신호를 사용하는 경우 자체 신호 처리기에서 신호를 안정적으로 차단하거나 차단 해제 할 수 없습니다. 다른 신호는 안정적으로 차단 또는 차단 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6eb3e27a2f3b6ca32cee54a3ce38dc4afb062aed" translate="yes" xml:space="preserve">
          <source>Note that you cannot do (de)composition and casing based solely on the</source>
          <target state="translated">(디) 조립 및 케이싱은</target>
        </trans-unit>
        <trans-unit id="87645c57d8e0d5210e8d3327ae60dc3fe4c988b7" translate="yes" xml:space="preserve">
          <source>Note that you cannot explicitly unlock a variable; you can only wait for the lock to go out of scope. This is most easily accomplished by locking the variable inside a block.</source>
          <target state="translated">변수를 명시 적으로 잠금 해제 할 수는 없습니다. 잠금이 범위를 벗어날 때까지만 기다릴 수 있습니다. 이것은 블록 안에서 변수를 잠그면 가장 쉽게 달성됩니다.</target>
        </trans-unit>
        <trans-unit id="34d896b03c45dc20f0fdc261eccf832e601b1f41" translate="yes" xml:space="preserve">
          <source>Note that you cannot test for &quot;&lt;code&gt;NaN&lt;/code&gt; -ness&quot; with</source>
          <target state="translated">&quot; &lt;code&gt;NaN&lt;/code&gt; -ness&quot;는 다음과 같이 테스트 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5b60fe993473449a8705a6ef4eab6f9f10003061" translate="yes" xml:space="preserve">
          <source>Note that you cannot use tags in @EXPORT or @EXPORT_OK.</source>
          <target state="translated">@EXPORT 또는 @EXPORT_OK에서는 태그를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cfbfbe6c89dd9e56f5bfaf163b06f453c16310bb" translate="yes" xml:space="preserve">
          <source>Note that you don't (re-)specify the method name. It forces you to always use the same method name as the method you started in.</source>
          <target state="translated">메소드 이름을 (재) 지정하지 마십시오. 항상 시작한 메소드와 동일한 메소드 이름을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="765ef1a0a25cf74eb1b9c1fc6e25a760175b0c75" translate="yes" xml:space="preserve">
          <source>Note that you have can't handle &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; errors that way with the &lt;code&gt;ARGV&lt;/code&gt; filehandle. In that case, you have to open each element of &lt;code&gt;@ARGV&lt;/code&gt; yourself since &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; handles &lt;code&gt;ARGV&lt;/code&gt; differently.</source>
          <target state="translated">&lt;code&gt;ARGV&lt;/code&gt; 파일 핸들을 사용 하는 방식으로 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 오류를 처리 할 수 ​​없습니다 . 이 경우 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;ARGV&lt;/code&gt; 를 다르게 처리 하므로 &lt;code&gt;@ARGV&lt;/code&gt; 의 각 요소를 직접 열어야합니다 .</target>
        </trans-unit>
        <trans-unit id="1d0c63b615c2a51e338a797bd40525e8af9c8f78" translate="yes" xml:space="preserve">
          <source>Note that you have can't handle &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; errors that way with the &lt;code&gt;ARGV&lt;/code&gt; filehandle. In that case, you have to open each element of &lt;code&gt;@ARGV&lt;/code&gt; yourself since &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; handles &lt;code&gt;ARGV&lt;/code&gt; differently.</source>
          <target state="translated">&lt;code&gt;ARGV&lt;/code&gt; 파일 핸들을 사용 하는 방식으로 &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 오류를 처리 할 수 ​​없습니다 . 이 경우 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;ARGV&lt;/code&gt; 를 다르게 처리 하므로 &lt;code&gt;@ARGV&lt;/code&gt; 의 각 요소를 직접 열어야합니다 .</target>
        </trans-unit>
        <trans-unit id="ef1cce341436113e5004762f8ac2a05ec7a6cdad" translate="yes" xml:space="preserve">
          <source>Note that you may have things stored in a lexicon besides just phrases for output: for example, if your program takes input from the keyboard, asking a &quot;(Y/N)&quot; question, you probably need to know what the equivalent of &quot;Y[es]/N[o]&quot; is in whatever language. You probably also need to know what the equivalents of the answers &quot;y&quot; and &quot;n&quot; are. You can store that information in the lexicon (say, under the keys &quot;~answer_y&quot; and &quot;~answer_n&quot;, and the long forms as &quot;~answer_yes&quot; and &quot;~answer_no&quot;, where &quot;~&quot; is just an ad-hoc character meant to indicate to programmers/translators that these are not phrases for output).</source>
          <target state="translated">예를 들어, 프로그램이 키보드에서 입력을 받아 &quot;(Y / N)&quot;질문을하는 경우 어휘집에 저장되어있을 수 있습니다. 예를 들어, &quot;Y&quot;에 해당하는 것이 무엇인지 알아야합니다. [es] / N [o] &quot;는 모든 언어로되어 있습니다. &quot;y&quot;와 &quot;n&quot;의 대답이 무엇인지 알아야 할 수도 있습니다. 어휘집에 해당 정보를 저장할 수 있습니다 (예 : &quot;~ answer_y&quot;및 &quot;~ answer_n&quot;키 아래에 긴 형식은 &quot;~ answer_yes&quot;및 &quot;~ answer_no&quot;). 여기서 &quot;~&quot;는 임시 문자입니다. 프로그래머 / 번역가에게 출력용 문구가 아님을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f229bb516b77586e7a9a248bf3e0f062f311444b" translate="yes" xml:space="preserve">
          <source>Note that you may mix directories and (non-directory) files in the list of directories to be searched by the &lt;code&gt;wanted()&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;wanted()&lt;/code&gt; 함수 로 검색 할 디렉토리 목록에서 디렉토리와 (비 디렉토리가 아닌) 파일을 혼합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cfd4a087008bc37d07992fd270addb262fb108e" translate="yes" xml:space="preserve">
          <source>Note that you might find it useful in some cases to override the &lt;code&gt;maketext&lt;/code&gt; method with an &quot;after method&quot;, if you want to translate encodings, or even scripts:</source>
          <target state="translated">인코딩 또는 스크립트를 번역하려는 경우 경우에 따라 &lt;code&gt;maketext&lt;/code&gt; 메서드를 &quot;after method&quot; 로 재정의하는 것이 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="253cba6289667637c7fd05a73ad1fdc58ca96c20" translate="yes" xml:space="preserve">
          <source>Note that you must specify a Unix path for $new_name, since per tar standard, all files in the archive must be Unix paths.</source>
          <target state="translated">tar 표준에 따라 아카이브의 모든 파일은 Unix 경로 여야하므로 $ new_name에 Unix 경로를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="af5d3ffce4bc0322633d2e85550797429ad732a8" translate="yes" xml:space="preserve">
          <source>Note that you need to install the Module::Signature module to perform this operation.</source>
          <target state="translated">이 작업을 수행하려면 Module :: Signature 모듈을 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="349c9f55c28f43dcb8274d29802632751096cca6" translate="yes" xml:space="preserve">
          <source>Note that you should load this module</source>
          <target state="translated">이 모듈을로드해야합니다.</target>
        </trans-unit>
        <trans-unit id="50670d23899cdfce7f241f0aebbebf124020da97" translate="yes" xml:space="preserve">
          <source>Note that, because &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; traps otherwise-fatal errors, it is useful for determining whether a particular feature (such as &lt;code&gt;&lt;a href=&quot;socket&quot;&gt;socket&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt;) is implemented. It is also Perl's exception-trapping mechanism, where the die operator is used to raise exceptions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 은 치명적이지 않은 오류를 포착 하므로 특정 기능 (예 : &lt;code&gt;&lt;a href=&quot;socket&quot;&gt;socket&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt; )이 구현 되는지 여부를 판별하는 데 유용합니다 . 또한 다이 연산자가 예외를 발생시키는 데 사용되는 Perl의 예외 트래핑 메커니즘이기도합니다.</target>
        </trans-unit>
        <trans-unit id="b4ffd3921a8026663ffc09712b83a83c559f1527" translate="yes" xml:space="preserve">
          <source>Note that, because &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; traps otherwise-fatal errors, it is useful for determining whether a particular feature (such as &lt;code&gt;&lt;a href=&quot;functions/socket&quot;&gt;socket&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt;) is implemented. It is also Perl's exception-trapping mechanism, where the die operator is used to raise exceptions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 은 치명적이지 않은 오류를 포착 하므로 특정 기능 (예 : &lt;code&gt;&lt;a href=&quot;functions/socket&quot;&gt;socket&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt; )이 구현 되는지 여부를 판별하는 데 유용합니다 . 또한 다이 연산자가 예외를 발생시키는 데 사용되는 Perl의 예외 트래핑 메커니즘이기도합니다.</target>
        </trans-unit>
        <trans-unit id="5209cab95dd7fa5e49fd362ada61a9529eae4cb7" translate="yes" xml:space="preserve">
          <source>Note that, because the &lt;code&gt;Cycle&lt;/code&gt; attribute receives its arguments in the &lt;code&gt;$data&lt;/code&gt; variable, if the attribute is given a list of arguments, &lt;code&gt;$data&lt;/code&gt; will consist of a single array reference; otherwise, it will consist of the single argument directly. Since Tie::Cycle requires its cycling values to be passed as an array reference, this means that we need to wrap non-array-reference arguments in an array constructor:</source>
          <target state="translated">때문에, 그 주 &lt;code&gt;Cycle&lt;/code&gt; 특성은 그것의 주장을 수신 &lt;code&gt;$data&lt;/code&gt; 속성이 인수의 목록이 제공되면, 변수 &lt;code&gt;$data&lt;/code&gt; 하나의 어레이 구성을 참조한다; 그렇지 않으면 단일 인수로 직접 구성됩니다. Tie :: Cycle은 사이클링 값을 배열 참조로 전달해야하므로 배열 생성자에서 비 배열 참조 인수를 래핑해야합니다.</target>
        </trans-unit>
        <trans-unit id="634d31438b7b96505dfbaf20bfb6d24a32edebe9" translate="yes" xml:space="preserve">
          <source>Note that, for historical compatibility, you can also use &lt;code&gt;NEXT::UNSEEN&lt;/code&gt; instead of &lt;code&gt;NEXT::DISTINCT&lt;/code&gt; .</source>
          <target state="translated">기록 호환성을 위해 &lt;code&gt;NEXT::DISTINCT&lt;/code&gt; 대신 &lt;code&gt;NEXT::UNSEEN&lt;/code&gt; 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cc33ef9021f54e035b56392220cb3acd2d2873be" translate="yes" xml:space="preserve">
          <source>Note that, if you have options &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; and &lt;code&gt;all&lt;/code&gt; , and auto_abbrev enabled, possible arguments and option settings are:</source>
          <target state="translated">옵션 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; 및 &lt;code&gt;all&lt;/code&gt; 및 auto_abbrev가 사용 가능한 경우 가능한 인수 및 옵션 설정은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="35db5062a8071a77478be258b823dc93b2df8d08" translate="yes" xml:space="preserve">
          <source>Note that, if you wish to run Configure non-interactively (see the INSTALL document for details), to have it select the correct hint file, you'll need to provide the argument -Dhintfile=riscos on the Configure command-line.</source>
          <target state="translated">비 대화식으로 구성을 실행하려면 (자세한 내용은 INSTALL 문서 참조) 올바른 힌트 파일을 선택하려면 Configure 명령 행에 -Dhintfile = riscos 인수를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="8223fdc89d45104614b40e3adc04b113ea1e11a1" translate="yes" xml:space="preserve">
          <source>Note that, if your code is running under the recommended &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; strict
vars&lt;/code&gt; pragma, you will need to declare these package variables with &lt;code&gt;&lt;a href=&quot;../functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">코드가 권장에서 실행되는 경우, 그 주 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; strict vars&lt;/code&gt; 프라그를, 당신은 이러한 패키지 변수를 선언해야합니다 &lt;code&gt;&lt;a href=&quot;../functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b910d090e427c58d2dd17debf4a1b8bec005d534" translate="yes" xml:space="preserve">
          <source>Note that, unlike &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;unless&lt;/code&gt; , failed &lt;code&gt;when&lt;/code&gt; statements always evaluate to an empty list.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 및 &lt;code&gt;unless&lt;/code&gt; 과 달리 명령문이 항상 빈 목록으로 평가 &lt;code&gt;when&lt;/code&gt; 실패했습니다 .</target>
        </trans-unit>
        <trans-unit id="7888ceb1fb70ed4eb88480b31893c674d725b49f" translate="yes" xml:space="preserve">
          <source>Note the</source>
          <target state="translated">참고</target>
        </trans-unit>
        <trans-unit id="b803d84dee50e438348a270e8179c619e96897b0" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;!&lt;/code&gt; after &lt;code&gt;l&lt;/code&gt; : We want to make sure that we pack a long integer as it is compiled by our C compiler. And even now, it will only work for the platforms where the compiler aligns things as above. And somebody somewhere has a platform where it doesn't. [Probably a Cray, where &lt;code&gt;short&lt;/code&gt; s, &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;s and &lt;code&gt;long&lt;/code&gt; s are all 8 bytes. :-)]</source>
          <target state="translated">참고하십시오 &lt;code&gt;!&lt;/code&gt; after &lt;code&gt;l&lt;/code&gt; : C 컴파일러가 컴파일 할 때 긴 정수를 패킹하고 싶습니다. 그리고 지금까지도 컴파일러가 위와 같이 정렬하는 플랫폼에서만 작동합니다. 그리고 누군가 어딘가에 플랫폼이 없습니다. [ &lt;code&gt;short&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;long&lt;/code&gt; 이 모두 8 바이트 인 Cray 일 수 있습니다. :-)]</target>
        </trans-unit>
        <trans-unit id="5b281c2225ddfa8f6c2dd45449bba50edd2d3238" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;$]&lt;/code&gt; in the above is not literal. Substitute whatever version of perl you want to honor that entry, e.g. &lt;code&gt;5.6.0&lt;/code&gt; . Paths must be separated with semicolons, as usual on Windows.</source>
          <target state="translated">위 의 &lt;code&gt;$]&lt;/code&gt; 는 리터럴이 아닙니다. 해당 항목을 존중하려는 모든 버전의 perl을 대체하십시오 (예 : &lt;code&gt;5.6.0&lt;/code&gt; ) . Windows에서와 같이 경로는 세미콜론으로 구분해야합니다.</target>
        </trans-unit>
        <trans-unit id="b760e9a6cdd73c2d052d5f85b1252a43b431d01a" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr//&lt;/a&gt;&lt;/code&gt; expression is surrounded by &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq{}&lt;/a&gt;&lt;/code&gt;. The idea behind this is the same as the classic idiom that makes &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 'interpolate':</source>
          <target state="translated">노트 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr//&lt;/a&gt;&lt;/code&gt; 발현에 의해 둘러싸여 &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq{}&lt;/a&gt;&lt;/code&gt; . 이것에 대한 아이디어는 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 'interpolate' 를 만드는 고전적인 관용구와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="d4596391d7dda5f4358c63110663675e031494da" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;s: where autogeneration results in the method for a standard operator which does not change either of its operands, such as &lt;code&gt;-&lt;/code&gt; , being used to implement an operator which changes the operand (&quot;mutators&quot;: here, &lt;code&gt;--&lt;/code&gt; and &lt;code&gt;-=&lt;/code&gt; ), Perl passes undef as the third argument. This still evaluates as FALSE, consistent with the fact that the operands have not been swapped, but gives the subroutine a chance to alter its behaviour in these cases.</source>
          <target state="translated">메모 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 들 : 같은 피연산자 중 하나 변하지 않는 표준 조작 방법에서는 여기서 자동 생성 결과 &lt;code&gt;-&lt;/code&gt; ( &quot;뮤 테이터&quot;피연산자 변경 연산자 구현하는데 이용되는 여기를 &lt;code&gt;--&lt;/code&gt; 및 &lt;code&gt;-=&lt;/code&gt; ), Perl은 undef를 세 번째 인수로 전달합니다. 피연산자가 교체되지 않았지만 서브 루틴이 이러한 경우 동작을 변경할 수있는 기회를 제공한다는 사실과 일치하지만 여전히 FALSE로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="19e6d5e5eedfcc869e45b8ad3dc4833107e51623" translate="yes" xml:space="preserve">
          <source>Note the LIST is prepended whole, not one element at a time, so the prepended elements stay in the same order. Use &lt;code&gt;&lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; to do the reverse.</source>
          <target state="translated">LIST는 한 번에 하나의 요소가 아닌 전체가 앞에 붙어 있으므로 앞에 붙은 요소는 동일한 순서로 유지됩니다. &lt;code&gt;&lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; 를 사용하여 반대 를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="0964c138a8a06a965bf091caaa6b9ea018efcb97" translate="yes" xml:space="preserve">
          <source>Note the LIST is prepended whole, not one element at a time, so the prepended elements stay in the same order. Use &lt;code&gt;&lt;a href=&quot;reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; to do the reverse.</source>
          <target state="translated">LIST는 한 번에 하나의 요소가 아닌 전체가 앞에 붙어 있으므로 앞에 붙은 요소는 동일한 순서로 유지됩니다. &lt;code&gt;&lt;a href=&quot;reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; 를 사용하여 반대 를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="ddf2e42d261d53e754661957b5687c8859030118" translate="yes" xml:space="preserve">
          <source>Note the calls to PERL_SET_CONTEXT(). These are necessary to initialize the global state that tracks which interpreter is the &quot;current&quot; one on the particular process or thread that may be running it. It should always be used if you have more than one interpreter and are making perl API calls on both interpreters in an interleaved fashion.</source>
          <target state="translated">PERL_SET_CONTEXT () 호출에 유의하십시오. 이들은 어떤 인터프리터가 특정 프로세스 나 스레드에서 &quot;현재&quot;인터프리터인지 추적하는 전역 상태를 초기화하는 데 필요합니다. 둘 이상의 인터프리터가 있고 인터리브 방식으로 두 인터프리터 모두에서 perl API 호출을 수행하는 경우 항상 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7596eda7b71ff20655d3bc34a84787b053200c0e" translate="yes" xml:space="preserve">
          <source>Note the gaps marked by &quot;*&quot; before several of the byte entries above. These are caused by legal UTF-8 avoiding non-shortest encodings: it is technically possible to UTF-8-encode a single code point in different ways, but that is explicitly forbidden, and the shortest possible encoding should always be used (and that is what Perl does).</source>
          <target state="translated">위의 여러 바이트 항목 앞에 &quot;*&quot;로 표시된 간격을 확인하십시오. 가장 짧은 인코딩을 피하는 합법적 인 UTF-8로 인해 발생합니다. 기술적으로 단일 코드 포인트를 다른 방식으로 UTF-8로 인코딩하는 것이 가능하지만 명시 적으로 금지되며 가능한 가장 짧은 인코딩을 항상 사용해야합니다 (그리고 펄이하는 일입니다).</target>
        </trans-unit>
        <trans-unit id="924291c98e268b7826585c54d3c30b3f0159b622" translate="yes" xml:space="preserve">
          <source>Note the semicolon. Except for the code inside not being immediately executed, a &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; is not so much a declaration as it is an operator, like &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do{}&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt;. (However, no matter how many times you execute that particular line (unless you're in an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval(&quot;...&quot;)&lt;/a&gt;&lt;/code&gt;), $coderef will still have a reference to the</source>
          <target state="translated">세미콜론에 유의하십시오. 내부에서 코드가 즉시 실행되지 않는 것을 제외하고 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do{}&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; 과 같은 연산자만큼 선언이 아닙니다 . (그러나 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval(&quot;...&quot;)&lt;/a&gt;&lt;/code&gt; 에 있지 않는 한 특정 행을 몇 번이나 실행하더라도 $ coderef는 여전히</target>
        </trans-unit>
        <trans-unit id="245f27d09730a3956ebd88bb73ed91d5802f1f14" translate="yes" xml:space="preserve">
          <source>Note the two following forms:</source>
          <target state="translated">다음 두 가지 형태에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="08a39ac9f8eb20d1bc0ac7dda6dd75ffb57ed8d8" translate="yes" xml:space="preserve">
          <source>Note the use of &lt;code&gt;$&lt;/code&gt; instead of &lt;code&gt;\&lt;/code&gt; in the last example. Unlike &lt;b&gt;sed&lt;/b&gt;, we use the \&amp;lt;</source>
          <target state="translated">마지막 예에서 &lt;code&gt;\&lt;/code&gt; 대신 &lt;code&gt;$&lt;/code&gt; 를 사용하십시오 . &lt;b&gt;sed&lt;/b&gt; 와는 달리 , 우리는 \ &amp;lt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="845bd8d10b7b2e89645294c110cfa223e574f5d5" translate="yes" xml:space="preserve">
          <source>Note there are two distinct steps there: 1) You'll have to create Wild.pm and put it in your perl lib directory. 2) You'll need to set the PERL5OPT environment variable. If you want argv expansion to be the default, just set PERL5OPT in your default startup environment.</source>
          <target state="translated">여기에는 두 가지 단계가 있습니다. 1) Wild.pm을 만들어 perl lib 디렉토리에 저장해야합니다. 2) PERL5OPT 환경 변수를 설정해야합니다. argv 확장을 기본값으로 설정하려면 기본 시작 환경에서 PERL5OPT를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="44c0c7dc0dc0ee1847fe2547270344fd07547c80" translate="yes" xml:space="preserve">
          <source>Note this interface is strongly preferred over &lt;code&gt;gv_stashpvn&lt;/code&gt; for performance reasons.</source>
          <target state="translated">성능상의 이유로이 인터페이스는 &lt;code&gt;gv_stashpvn&lt;/code&gt; 보다 선호 됩니다.</target>
        </trans-unit>
        <trans-unit id="3299aefdb3ce5c9a7bffd6e8e1b69e10b1bc969e" translate="yes" xml:space="preserve">
          <source>Note this is current as of patchlevel 0, and could change at any time.</source>
          <target state="translated">이는 패치 수준 0부터 최신 상태이며 언제든지 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43dee313ad9b91211c8c801e413c783a1b1c90d4" translate="yes" xml:space="preserve">
          <source>Note this may be also triggered for constructs like:</source>
          <target state="translated">다음과 같은 구문에서도 트리거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="479333dc136e44b8ccb0606732973018c80236a3" translate="yes" xml:space="preserve">
          <source>Note this move has made \x{D800}-\x{DFFF} into a forbidden zone but perl does not prohibit the use of characters within this range. To perl, every one of \x{0000_0000} up to \x{ffff_ffff} (*) is</source>
          <target state="translated">이 이동은 \ x {D800}-\ x {DFFF}를 금지 구역으로 만들었지 만 perl은이 범위 내의 문자 사용을 금지하지 않습니다. 펄하기 위해, \ x {0000_0000}의 모든 것은 최대 \ x {ffff_ffff} (*)입니다.</target>
        </trans-unit>
        <trans-unit id="64c26fc0bfdd3e67c9ece7008879dc6d1a01b402" translate="yes" xml:space="preserve">
          <source>Note to those still using Perl 5.18 or earlier: The use of &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; or &lt;code&gt;$'&lt;/code&gt; will slow down &lt;b&gt;all&lt;/b&gt; regex use within your program. Consult &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for &lt;code&gt;@-&lt;/code&gt; to see equivalent expressions that won't cause slow down. See also &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::SawAmpersand&quot;&gt;Devel::SawAmpersand&lt;/a&gt;. Starting with Perl 5.10, you can also use the equivalent variables &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; , but for them to be defined, you have to specify the &lt;code&gt;/p&lt;/code&gt; (preserve) modifier on your regular expression. In Perl 5.20, the use of &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt; makes no speed difference.</source>
          <target state="translated">여전히 Perl 5.18 또는 이전 버전을 사용하는 사람들을 참고하십시오 : &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; 또는 &lt;code&gt;$'&lt;/code&gt; 을 사용하면 프로그램 내의 &lt;b&gt;모든&lt;/b&gt; 정규식 사용 이 느려집니다 . 문의 &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; 에 대한 &lt;code&gt;@-&lt;/code&gt; 그 속도가 느려지지 아래의 원인이됩니다 상응하는 표현을 볼 수 있습니다. &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::SawAmpersand&quot;&gt;Devel :: SawAmpersand&lt;/a&gt; 도 참조하십시오 . Perl 5.10부터는 등가 변수 &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; 및 &lt;code&gt;${^POSTMATCH}&lt;/code&gt; 를 사용할 수도 있지만, 정의하려면 &lt;code&gt;/p&lt;/code&gt; (preserve) 수정자를 지정해야 합니다. 정규식. Perl 5.20에서 &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; 및 &lt;code&gt;$'&lt;/code&gt; 속도 차이가 없습니다.</target>
        </trans-unit>
        <trans-unit id="075a00b6d348d2bde80b54d266bd24c03289e88d" translate="yes" xml:space="preserve">
          <source>Note too that, when using the /x modifier on a regex, any comment containing the current pattern delimiter will cause the regex to be immediately terminated. In other words:</source>
          <target state="translated">정규 표현식에서 / x 수정자를 사용할 때 현재 패턴 구분자를 포함하는 주석은 정규 표현식을 즉시 종료시킵니다. 다시 말해:</target>
        </trans-unit>
        <trans-unit id="a9418a9be85583539aad52da154ad55780878583" translate="yes" xml:space="preserve">
          <source>Note, however, a &quot;=begin</source>
          <target state="translated">그러나 &quot;= 시작됨에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="6dfa7aab0d54b245f769489b5d31604d4926ff66" translate="yes" xml:space="preserve">
          <source>Note, however, that (unlike most other OO languages) Perl does not ensure or enforce encapsulation in any way. If you want objects to actually</source>
          <target state="translated">그러나 (대부분의 다른 OO 언어와 달리) Perl은 어떤 식 으로든 캡슐화를 보장하거나 시행하지 않습니다. 실제로 객체를 원한다면</target>
        </trans-unit>
        <trans-unit id="9ee559bf7555e3380e5d318f57cb372ff9af8802" translate="yes" xml:space="preserve">
          <source>Note, however, that formatting codes and Z&amp;lt;&amp;gt;'s can occur in any and all parts of an L&amp;lt;...&amp;gt; (i.e., in</source>
          <target state="translated">그러나 서식 코드와 Z &amp;lt;&amp;gt;는 L &amp;lt;...&amp;gt;의 모든 부분에서 발생할 수 있습니다 (예 :</target>
        </trans-unit>
        <trans-unit id="9e68e1c2898e4995bc610c38829131cae377e27c" translate="yes" xml:space="preserve">
          <source>Note, however, that this does not always work for quoting Perl code:</source>
          <target state="translated">그러나 이것이 Perl 코드를 인용 할 때 항상 작동하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="daa40807202515240a11e4305fe2938d02dab24c" translate="yes" xml:space="preserve">
          <source>Note, however, that this restricts localization of some values ; for example, the following statement dies, as of perl 5.10.0, with an error</source>
          <target state="translated">그러나 이로 인해 일부 값의 지역화가 제한됩니다. 예를 들어, 다음 명령문은 perl 5.10.0에서 오류와 함께 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="1d6b51a1f71c0a1abcbedef9280d1a614610364d" translate="yes" xml:space="preserve">
          <source>Note, incidentally, that items in each group are comma-separated, not &lt;code&gt;/\s*,\s*/&lt;/code&gt; -separated. That is, you might expect that this bracket group:</source>
          <target state="translated">실수로 각 그룹의 항목은 &lt;code&gt;/\s*,\s*/&lt;/code&gt; -separated가 아니라 쉼표로 구분됩니다 . 즉,이 대괄호 그룹은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="328da3257aa2be232f47d8215b8ce26d82b79a88" translate="yes" xml:space="preserve">
          <source>Note, it is possible for the version of a module to be unspecified, whereby the value is &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, so use &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt; $version{$foo}{$bar}&lt;/code&gt; if that's what you're testing for.</source>
          <target state="translated">참고,이 값이 이에 모듈의 버전이 지정되지 않은 것으로 가능하다 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 사용하므로, &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt; $version{$foo}{$bar}&lt;/code&gt; 그 무엇 당신에게있는 거 테스트의 경우.</target>
        </trans-unit>
        <trans-unit id="59b95364ddb70e31cf0aeb6a61be710b24d1414c" translate="yes" xml:space="preserve">
          <source>Note, starting in Perl 5.18, the name &lt;code&gt;BELL&lt;/code&gt; refers to the Unicode character U+1F514, instead of the traditional U+0007. For the latter, use &lt;code&gt;ALERT&lt;/code&gt; or &lt;code&gt;BEL&lt;/code&gt; .</source>
          <target state="translated">Perl 5.18부터 &lt;code&gt;BELL&lt;/code&gt; 이라는 이름 은 기존 U + 0007 대신 유니 코드 문자 U + 1F514를 나타냅니다. 후자의 경우 &lt;code&gt;ALERT&lt;/code&gt; 또는 &lt;code&gt;BEL&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bca239c5c2f598100f4661bdcb782662394e6f1d" translate="yes" xml:space="preserve">
          <source>Note, that in both cases the tilde expansion is done by MakeMaker, not by perl by default, nor by make.</source>
          <target state="translated">두 경우 모두 물결표 확장은 기본적으로 perl 또는 make가 아닌 MakeMaker에 의해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="2f4993e4338094ef439d0737bf034f424a4d5b79" translate="yes" xml:space="preserve">
          <source>Note, these constants are not imported by &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; by default.</source>
          <target state="translated">이 상수는 기본적 으로 &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; 가져 오지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="36fe78df4850fd37cfbf75f0174f722ec0a6341e" translate="yes" xml:space="preserve">
          <source>Note, these constants are not imported by &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; by default.</source>
          <target state="translated">이 상수는 기본적 으로 &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; 으로 가져 오지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d62d5837f1b088899c2335c24b7fb00237a5b01e" translate="yes" xml:space="preserve">
          <source>Note, these constants are not imported by &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; by default.</source>
          <target state="translated">이 상수는 기본적 으로 &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; 의해 가져 오지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d3aba16133e84e8f9cf404e250371714dd197ffd" translate="yes" xml:space="preserve">
          <source>Note, these constants are not imported by &lt;code&gt;IO::Compress::Zip&lt;/code&gt; by default.</source>
          <target state="translated">이 상수는 기본적 으로 &lt;code&gt;IO::Compress::Zip&lt;/code&gt; 가져 오지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d20abe192a9c5b05ecdd8b5a009dcb0d1cc347b5" translate="yes" xml:space="preserve">
          <source>Note, use of &lt;code&gt;gv_stashsv&lt;/code&gt; instead of &lt;code&gt;gv_stashpvn&lt;/code&gt; where possible is strongly recommended for performance reasons.</source>
          <target state="translated">참고 사용 &lt;code&gt;gv_stashsv&lt;/code&gt; 대신 &lt;code&gt;gv_stashpvn&lt;/code&gt; 강하게 성능상의 이유로 추천 가능.</target>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">Note:</target>
        </trans-unit>
        <trans-unit id="858564b8eb505f163537f56838925cbe62eeb857" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; will not attempt to delete directories unless you are superuser and the &lt;b&gt;-U&lt;/b&gt; flag is supplied to Perl. Even if these conditions are met, be warned that unlinking a directory can inflict damage on your filesystem. Finally, using &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; on directories is not supported on many operating systems. Use &lt;code&gt;&lt;a href=&quot;functions/rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">참고 : 수퍼 유저이고 &lt;b&gt;-U&lt;/b&gt; 플래그가 Perl에 제공 되지 않으면 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 는 디렉토리 삭제를 시도하지 않습니다 . 이러한 조건이 충족 되더라도 디렉토리를 연결 해제하면 파일 시스템이 손상 될 수 있다는 경고가 표시됩니다. 마지막으로 많은 운영 체제에서 디렉토리에서 링크 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 를 사용하는 것은 지원되지 않습니다. 대신 &lt;code&gt;&lt;a href=&quot;functions/rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5634cda13018c382b3c15c0bf989c4dea07045c1" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; isn't needed in this example: &lt;code&gt;strftime()&lt;/code&gt; is a POSIX function which uses the standard system-supplied &lt;code&gt;libc&lt;/code&gt; function that always obeys the current &lt;code&gt;LC_TIME&lt;/code&gt; locale.</source>
          <target state="translated">참고 : 이 예제 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 이 필요하지 않습니다. &lt;code&gt;strftime()&lt;/code&gt; 은 항상 현재 &lt;code&gt;LC_TIME&lt;/code&gt; 로케일을 따르는 표준 시스템 제공 &lt;code&gt;libc&lt;/code&gt; 함수를 사용하는 POSIX 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="bd71952aea843bf37c94c0e84aec5e1493d8dd4a" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; isn't shown in some of these examples because it isn't needed: &lt;code&gt;strcoll()&lt;/code&gt; and &lt;code&gt;strxfrm()&lt;/code&gt; are POSIX functions which use the standard system-supplied &lt;code&gt;libc&lt;/code&gt; functions that always obey the current &lt;code&gt;LC_COLLATE&lt;/code&gt; locale.</source>
          <target state="translated">참고 : 이 예제 중 일부에서는 필요하지 않으므로 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 이 표시되지 않습니다. &lt;code&gt;strcoll()&lt;/code&gt; 및 &lt;code&gt;strxfrm()&lt;/code&gt; 은 항상 현재 &lt;code&gt;LC_COLLATE&lt;/code&gt; 로케일을 따르는 표준 시스템 제공 &lt;code&gt;libc&lt;/code&gt; 함수를 사용하는 POSIX 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="89c514c1b9de7057dea402c8d0f5122402a932ba" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; will not attempt to delete directories unless you are superuser and the &lt;b&gt;-U&lt;/b&gt; flag is supplied to Perl. Even if these conditions are met, be warned that unlinking a directory can inflict damage on your filesystem. Finally, using &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; on directories is not supported on many operating systems. Use &lt;code&gt;&lt;a href=&quot;rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">참고 : 수퍼 유저이고 &lt;b&gt;-U&lt;/b&gt; 플래그가 Perl에 제공 되지 않으면 &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 는 디렉토리 삭제를 시도하지 않습니다 . 이러한 조건이 충족 되더라도 디렉토리를 연결 해제하면 파일 시스템이 손상 될 수 있다는 경고가 표시됩니다. 마지막으로 많은 운영 체제에서 디렉토리에서 링크 &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 를 사용하는 것은 지원되지 않습니다. 대신 &lt;code&gt;&lt;a href=&quot;rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; 을 사용하십시오 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="07397ae9451cf5a436657d9cabd9f8d4563f40ae" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;PerlIO_findFILE()&lt;/code&gt; will search the layers for a stdio layer. If it can't find one, it will call &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; to generate a new stdio &lt;code&gt;FILE&lt;/code&gt; . Please only call &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; if you want a</source>
          <target state="translated">참고 : &lt;code&gt;PerlIO_findFILE()&lt;/code&gt; 은 stdio 레이어의 레이어를 검색합니다. 찾지 못하면 &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; 을 호출 하여 새 stdio &lt;code&gt;FILE&lt;/code&gt; 을 생성합니다 . 원하는 경우 &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; 만 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="f614956265c278721bb12432048ff10b5826efd9" translate="yes" xml:space="preserve">
          <source>Note: Be careful not to modify &lt;code&gt;@_&lt;/code&gt; at all before you call export_to_level - or people using your package will get very unexplained results!</source>
          <target state="translated">참고 : export_to_level을 호출하기 전에 &lt;code&gt;@_&lt;/code&gt; 을 전혀 수정하지 않도록주의하십시오. 그렇지 않으면 패키지를 사용하는 사람들이 설명 할 수없는 결과를 얻을 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="fadfe11234c608cf2899bd38b718e46fd2406590" translate="yes" xml:space="preserve">
          <source>Note: Before 5.21.0, the &quot;missing&quot; lexical warnings category was internally defined to be the same as the &quot;uninitialized&quot; category. It is now a top-level category in its own right.</source>
          <target state="translated">참고 : 5.21.0 이전에는 &quot;누락 된&quot;어휘 경고 범주가 내부적으로 &quot;초기화되지 않은&quot;범주와 동일하도록 정의되었습니다. 이제는 그 자체로 최상위 카테고리입니다.</target>
        </trans-unit>
        <trans-unit id="78023e67525e4c7a613335c235fa22e549b34845" translate="yes" xml:space="preserve">
          <source>Note: Before Perl 5.8.0, the lexical warnings category &quot;deprecated&quot; was a sub-category of the &quot;syntax&quot; category. It is now a top-level category in its own right.</source>
          <target state="translated">참고 : Perl 5.8.0 이전의 어휘 경고 범주 &quot;더 이상 사용되지 않음&quot;은 &quot;구문&quot;범주의 하위 범주였습니다. 이제는 그 자체로 최상위 카테고리입니다.</target>
        </trans-unit>
        <trans-unit id="5227b82d031bced3044e91e5933630d59be9bc12" translate="yes" xml:space="preserve">
          <source>Note: Do not use a floating point nor a negative sign in &lt;code&gt;$code_point&lt;/code&gt; .</source>
          <target state="translated">참고 : &lt;code&gt;$code_point&lt;/code&gt; 에 부동 소수점이나 음수 부호를 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="83d9951c1347109cd3bedbb4bb7306286ad1d212" translate="yes" xml:space="preserve">
          <source>Note: FCC is unique, as well as four normalization forms (NF*).</source>
          <target state="translated">참고 : FCC는 4 가지 정규화 형식 (NF *)뿐만 아니라 고유합니다.</target>
        </trans-unit>
        <trans-unit id="2bf5a1f9c5d972054186d3e42a82b7b324805893" translate="yes" xml:space="preserve">
          <source>Note: FCD is not always unique, then plural forms may be equivalent each other. &lt;code&gt;FCD()&lt;/code&gt; will return one of these equivalent forms.</source>
          <target state="translated">참고 : FCD는 항상 고유하지는 않으며 복수 형식은 서로 동일 할 수 있습니다. &lt;code&gt;FCD()&lt;/code&gt; 는 이와 동등한 형식 중 하나를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="56040f615b41a7064a5ef1844f423d8b9a40f330" translate="yes" xml:space="preserve">
          <source>Note: For some extensions, Dave Beazley's SWIG system may provide a significantly more convenient mechanism for creating the extension glue code. See &lt;a href=&quot;http://www.swig.org/&quot;&gt;http://www.swig.org/&lt;/a&gt; for more information.</source>
          <target state="translated">참고 : 일부 확장의 경우 Dave Beazley의 SWIG 시스템이 확장 글루 코드를 작성하는 데 훨씬 더 편리한 메커니즘을 제공 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;http://www.swig.org/&quot;&gt;http://www.swig.org/&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b1211fe58a903b5165f5edc276c715ceb521df1e" translate="yes" xml:space="preserve">
          <source>Note: From Mac OS X 10.6 &quot;Snow Leopard&quot; onwards, Apple only supports Intel-based hardware. This means you can safely skip this section unless you have an older Apple computer running on ppc or wish to create a perl binary with backwards compatibility.</source>
          <target state="translated">참고 : Mac OS X 10.6 &quot;Snow Leopard&quot;부터 Apple은 Intel 기반 하드웨어 만 지원합니다. 즉, 이전 Apple 컴퓨터가 ppc에서 실행 중이거나 이전 버전과 호환되는 perl 바이너리를 만들지 않는 한이 섹션을 건너 뛰어도됩니다.</target>
        </trans-unit>
        <trans-unit id="743600644f11d3e8a913feb2e46d0252bdc64043" translate="yes" xml:space="preserve">
          <source>Note: If a string is not in FCD, it must not be in FCC. So &lt;code&gt;checkFCC($not_FCD_string)&lt;/code&gt; should return &lt;code&gt;NO&lt;/code&gt; .</source>
          <target state="translated">참고 : 문자열이 FCD에 없으면 FCC에 있으면 안됩니다. 따라서 &lt;code&gt;checkFCC($not_FCD_string)&lt;/code&gt; 은 &lt;code&gt;NO&lt;/code&gt; 를 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9b01b3e05bd18ecfe427fbadc48a1cf9f4918f8c" translate="yes" xml:space="preserve">
          <source>Note: If you turn on &lt;code&gt;Sparseseen&lt;/code&gt; , then you must not rely on the content of the seen hash since its contents will be an implementation detail!</source>
          <target state="translated">참고 : &lt;code&gt;Sparseseen&lt;/code&gt; 을 켜면 본 해시의 내용에 의존해서는 안됩니다. 내용은 구현 세부 사항이므로!</target>
        </trans-unit>
        <trans-unit id="a3278502ab348386cdc09a185533e7816e62b07e" translate="yes" xml:space="preserve">
          <source>Note: Many folks tend to overuse &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; and are then surprised to discover that the number &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;&quot;&quot;&lt;/code&gt; (the zero-length string) are, in fact, defined values. For example, if you say</source>
          <target state="translated">참고 : 많은 사람들이 &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 를 과도하게 사용하는 경향 이 있으며 숫자 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;&quot;&quot;&lt;/code&gt; (길이가 0 인 문자열)가 실제로 정의 된 값이라는 것을 알게되면 놀랍니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="72cf554b1f74abf911508263cf2a354d76fd9f1a" translate="yes" xml:space="preserve">
          <source>Note: Many folks tend to overuse &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; and are then surprised to discover that the number &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;&quot;&quot;&lt;/code&gt; (the zero-length string) are, in fact, defined values. For example, if you say</source>
          <target state="translated">참고 : 많은 사람들이 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 를 과도하게 사용하는 경향 이 있으며 숫자 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;&quot;&quot;&lt;/code&gt; (길이가 0 인 문자열)가 실제로 정의 된 값이라는 것을 알게되면 놀랍니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="a4c4e917877757fb6fc83b2e0f19ffc51d5f6fc8" translate="yes" xml:space="preserve">
          <source>Note: Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times()&lt;/a&gt;&lt;/code&gt; function returns four values, measured in seconds.</source>
          <target state="translated">참고 : Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times()&lt;/a&gt;&lt;/code&gt; 함수는 초 단위로 측정 된 4 개의 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="193ad56c42c8c5022f417eca20124d2510809ef1" translate="yes" xml:space="preserve">
          <source>Note: Some folks colloquially refer to this bit of punctuation as a &quot;yada-yada&quot; or &quot;triple-dot&quot;, but its true name is actually an ellipsis.</source>
          <target state="translated">참고 : 일부 사람들은 구어체로이 문장 부호를 &quot;yada-yada&quot;또는 &quot;triple-dot&quot;라고하지만 실제 이름은 실제로 줄임표입니다.</target>
        </trans-unit>
        <trans-unit id="c9a4ed3733a9eeadde05bd081437b7ba9d5fa627" translate="yes" xml:space="preserve">
          <source>Note: Some modules downloaded from CPAN may require NetWare related API in order to build on NetWare. Other modules may however build smoothly with or without minor changes depending on the type of module.</source>
          <target state="translated">참고 : CPAN에서 다운로드 한 일부 모듈은 NetWare에서 빌드하기 위해 NetWare 관련 API가 필요할 수 있습니다. 그러나 다른 모듈은 모듈 유형에 따라 약간만 변경하거나 변경하지 않고 원활하게 빌드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e33603b6b52bf5831bfb6cf75b5a9f26f72dc686" translate="yes" xml:space="preserve">
          <source>Note: Some sites have reported problems when using the file-access tests (&lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , and &lt;code&gt;-x&lt;/code&gt; ) on files accessed via DEC's DFS. Specifically, since DFS does not currently provide access to the extended file header of files on remote volumes, attempts to examine the ACL fail, and the file tests will return false, with &lt;code&gt;$!&lt;/code&gt; indicating that the file does not exist. You can use &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; on these files, since that checks UIC-based protection only, and then manually check the appropriate bits, as defined by your C compiler's</source>
          <target state="translated">참고 : 일부 사이트는 DEC의 DFS를 통해 액세스 한 파일에서 파일 액세스 테스트 ( &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; 및 &lt;code&gt;-x&lt;/code&gt; )를 사용할 때 문제점을보고했습니다 . 특히, DFS는 현재 원격 볼륨에있는 파일의 확장 파일 헤더에 대한 액세스를 제공하지 않기 때문에 ACL 검사 시도가 실패하고 파일 테스트는 &lt;code&gt;$!&lt;/code&gt; 파일이 존재하지 않음을 나타냅니다. UIC 기반 보호 만 검사 한 다음 C 컴파일러에서 정의한대로 적절한 비트를 수동으로 검사하므로이 파일에 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b6f6c7fe8a37aa2c65de3e3c606a0b439080ba4" translate="yes" xml:space="preserve">
          <source>Note: Some vendors supply &lt;code&gt;strtod()&lt;/code&gt; and &lt;code&gt;strtol()&lt;/code&gt; but not &lt;code&gt;strtoul()&lt;/code&gt; . Other vendors that do supply &lt;code&gt;strtoul()&lt;/code&gt; parse &quot;-1&quot; as a valid value.</source>
          <target state="translated">참고 : 일부 공급 업체는 &lt;code&gt;strtod()&lt;/code&gt; 및 &lt;code&gt;strtol()&lt;/code&gt; 하지만 &lt;code&gt;strtoul()&lt;/code&gt; 하지 않습니다 . &lt;code&gt;strtoul()&lt;/code&gt; 제공하는 다른 공급 업체는 &quot;-1&quot;을 유효한 값으로 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="e2d1626493358bc3d857173bc6af6ddd2a5fc2da" translate="yes" xml:space="preserve">
          <source>Note: The iterator (&lt;code&gt;'&amp;lt;&amp;gt;'&lt;/code&gt; ) and file test (&lt;code&gt;'-X'&lt;/code&gt; ) operators work as normal: if the operand is not a blessed glob or IO reference then it is converted to a string (using the method for &lt;code&gt;'&quot;&quot;'&lt;/code&gt; , &lt;code&gt;'0+'&lt;/code&gt; , or &lt;code&gt;'bool'&lt;/code&gt; ) to be interpreted as a glob or filename.</source>
          <target state="translated">참고 : 반복자 ( &lt;code&gt;'&amp;lt;&amp;gt;'&lt;/code&gt; ) 및 파일 테스트 ( &lt;code&gt;'-X'&lt;/code&gt; ) 연산자는 정상적으로 작동합니다. 피연산자가 축복 된 glob 또는 IO 참조가 아닌 경우 문자열로 변환됩니다 ( &lt;code&gt;'&quot;&quot;'&lt;/code&gt; , &lt;code&gt;'0+'&lt;/code&gt; 또는 &lt;code&gt;'bool'&lt;/code&gt; )은 glob 또는 파일 이름으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="9a7724723655fcca925e8e2780cbc470ea823e12" translate="yes" xml:space="preserve">
          <source>Note: The keyword 'lib' will warn when the requested library could not be loaded. To suppress the warning use 'try' instead:</source>
          <target state="translated">참고 : 요청한 라이브러리를로드 할 수 없으면 키워드 'lib'가 경고합니다. 경고를 표시하지 않으려면 대신 'try'를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7834aa58e75e083860df15db52ef81cbd8591c51" translate="yes" xml:space="preserve">
          <source>Note: The list &lt;code&gt;&lt;a href=&quot;../../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; returns has originated from your current perl and your current install.</source>
          <target state="translated">참고 : 리턴이 &lt;code&gt;&lt;a href=&quot;../../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 목록 은 현재 perl 및 현재 설치에서 시작되었습니다.</target>
        </trans-unit>
        <trans-unit id="9e555e53c6f7ef659bcb517427e72585e148bddc" translate="yes" xml:space="preserve">
          <source>Note: The policy of using locale rules for code points that can fit in a byte, and Unicode rules for those that can't is not uniformly applied. Pre-v5.12, it was somewhat haphazard; in v5.12 it was applied fairly consistently to regular expression matching except for bracketed character classes; in v5.14 it was extended to all regex matches; and in v5.16 to the casing operations such as &lt;code&gt;\L&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt;. For collation, in all releases so far, the system's &lt;code&gt;strxfrm()&lt;/code&gt; function is called, and whatever it does is what you get.</source>
          <target state="translated">참고 : 바이트에 맞는 코드 포인트에는 로캘 규칙을 사용하는 정책과 균일하지 않은 코드 포인트에는 유니 코드 규칙을 사용하는 정책이 있습니다. v5.12 이전에는 다소 우연이 있었다. v5.12에서는 대괄호로 묶은 문자 클래스를 제외하고 정규 표현식 일치에 상당히 일관되게 적용되었습니다. v5.14에서는 모든 정규식 일치로 확장되었습니다. v5.16에서는 &lt;code&gt;\L&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt; 와 같은 케이싱 작업을 수행 합니다. 데이터 정렬의 경우, 지금까지의 모든 릴리스에서 시스템의 &lt;code&gt;strxfrm()&lt;/code&gt; 함수가 호출되며 그 기능은 무엇이든 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f932c6f37410ce4ebff00172ee521c9f04d25563" translate="yes" xml:space="preserve">
          <source>Note: This feature was introduced in version 5.57 of Exporter, released with perl 5.8.3.</source>
          <target state="translated">참고 :이 기능은 perl 5.8.3과 함께 릴리스 된 Exporter 버전 5.57에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="cd489e52bffb55133a04f9392b0cef79b71a84a0" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;(entry =&amp;gt; 'FFFE ; [.0001.0020.0005.FFFE]')&lt;/code&gt; . Any other character than &lt;code&gt;U+FFFE&lt;/code&gt; can be tailored by &lt;code&gt;entry&lt;/code&gt; .</source>
          <target state="translated">참고 : 이것은 &lt;code&gt;(entry =&amp;gt; 'FFFE ; [.0001.0020.0005.FFFE]')&lt;/code&gt; . &lt;code&gt;U+FFFE&lt;/code&gt; 이외의 다른 문자는 &lt;code&gt;entry&lt;/code&gt; 별로 조정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e524e8ba90f8c2eceff3ee2b4fe18bbc36f721be" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;(entry =&amp;gt; 'FFFF ; [.FFFE.0020.0005.FFFF]')&lt;/code&gt; . Any other character than &lt;code&gt;U+FFFF&lt;/code&gt; can be tailored by &lt;code&gt;entry&lt;/code&gt; .</source>
          <target state="translated">참고 : 이것은 &lt;code&gt;(entry =&amp;gt; 'FFFF ; [.FFFE.0020.0005.FFFF]')&lt;/code&gt; . &lt;code&gt;U+FFFF&lt;/code&gt; 이외의 다른 문자는 &lt;code&gt;entry&lt;/code&gt; 별로 조정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0455de4d41cf68eed0be49449f753fd507ce98c3" translate="yes" xml:space="preserve">
          <source>Note: This method is only available if you are running zlib 1.0.6 or better.</source>
          <target state="translated">참고 :이 방법은 zlib 1.0.6 이상을 실행중인 경우에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d780f7fe644c15c8098f2ec3e635333d65dac99d" translate="yes" xml:space="preserve">
          <source>Note: This method was required from Math::BigInt version 1.78, but the required API version number was not incremented, so there are older libraries that support API version 1, but do not support &lt;code&gt;_as_oct()&lt;/code&gt; .</source>
          <target state="translated">참고 :이 메소드는 Math :: BigInt 버전 1.78에서 필요했지만 필요한 API 버전 번호가 증가하지 않았으므로 API 버전 1을 지원하지만 &lt;code&gt;_as_oct()&lt;/code&gt; 지원하지 않는 이전 라이브러리가 있습니다.</target>
        </trans-unit>
        <trans-unit id="274ea739a039d51482491c2164a8ca995639e789" translate="yes" xml:space="preserve">
          <source>Note: This needs Math::BigInt::GMP installed.</source>
          <target state="translated">참고 : Math :: BigInt :: GMP가 설치되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="4599f377b1aba694d82426f6489f702538a8bb33" translate="yes" xml:space="preserve">
          <source>Note: When $FTP_PASSIVE is true, &lt;code&gt;ncftp&lt;/code&gt; will not be used to fetch files, since passive mode can only be set interactively for this binary</source>
          <target state="translated">참고 : $ FTP_PASSIVE가 true 인 경우 수동 모드는이 바이너리에 대해서만 대화식으로 만 설정할 수 있으므로 &lt;code&gt;ncftp&lt;/code&gt; 는 파일을 가져 오는 데 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="44108fdd62b6b987695d83d0e866909c28a68c2f" translate="yes" xml:space="preserve">
          <source>Note: When called in list context, $isdst, the last value returned by gmtime, is always &lt;code&gt;0&lt;/code&gt; . There is no Daylight Saving Time in GMT.</source>
          <target state="translated">참고 : 목록 컨텍스트에서 호출 될 때 gmtime이 마지막으로 반환 한 $ isdst는 항상 &lt;code&gt;0&lt;/code&gt; 입니다. GMT에는 일광 절약 시간 제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="326b015af2e44c2db6ac3ed72580a47dac6e9403" translate="yes" xml:space="preserve">
          <source>Note: Works also for subclasses like &lt;a href=&quot;bigfloat&quot;&gt;Math::BigFloat&lt;/a&gt;. Each class has its own globals separated from Math::BigInt, but it is possible to subclass Math::BigInt and make the globals of the subclass aliases to the ones from Math::BigInt.</source>
          <target state="translated">참고 : &lt;a href=&quot;bigfloat&quot;&gt;Math :: BigFloat&lt;/a&gt; 와 같은 하위 클래스에서도 작동 합니다. 각 클래스에는 Math :: BigInt와 분리 된 자체 전역이 있지만 Math :: BigInt를 서브 클래 싱하고 하위 클래스 별칭의 전역을 Math :: BigInt의 전역으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f017c3d2e2508b08d7d59dc7727c02f156768d30" translate="yes" xml:space="preserve">
          <source>Note: Works also for subclasses like Math::BigFloat. Each class has it's own globals separated from Math::BigInt, but it is possible to subclass Math::BigInt and make the globals of the subclass aliases to the ones from Math::BigInt.</source>
          <target state="translated">참고 : Math :: BigFloat와 같은 서브 클래스에서도 작동합니다. 각 클래스에는 Math :: BigInt와 분리 된 자체 전역이 있지만 Math :: BigInt를 서브 클래 싱하고 하위 클래스 별칭의 전역을 Math :: BigInt의 전역으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb7b6e328c4f81408ff1a139ac8eaf2a380ca671" translate="yes" xml:space="preserve">
          <source>Note: You have to modify your man.conf file to search for manpages in the /ade/lib/perl5/man/man3 directory, or the man pages for the perl library will not be found.</source>
          <target state="translated">참고 : / ade / lib / perl5 / man / man3 디렉토리에서 맨 페이지를 검색하려면 man.conf 파일을 수정해야합니다. 그렇지 않으면 perl 라이브러리의 맨 페이지를 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1e7dc83f4d6c9a8b0d3c0b5924caf0806f95cf13" translate="yes" xml:space="preserve">
          <source>Note: You probably want to use &lt;a href=&quot;#accuracy()&quot;&gt;accuracy()&lt;/a&gt; instead. With &lt;a href=&quot;#accuracy()&quot;&gt;accuracy()&lt;/a&gt; you set the number of digits each result should have, with &lt;a href=&quot;#precision()&quot;&gt;precision()&lt;/a&gt; you set the place where to round!</source>
          <target state="translated">참고 : 아마도 &lt;a href=&quot;#accuracy()&quot;&gt;정확도 ()를&lt;/a&gt; 대신 사용하려고합니다 . 와 &lt;a href=&quot;#accuracy()&quot;&gt;정확성 ()&lt;/a&gt; 당신과 함께, 각각의 결과가 있어야한다 자릿수를 설정 &lt;a href=&quot;#precision()&quot;&gt;() 정밀&lt;/a&gt; 어디 라운드에 장소를 설정!</target>
        </trans-unit>
        <trans-unit id="e2e12b5547fb4733f2385741dc84813859d3dd2e" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;bundling&lt;/code&gt; also disables &lt;code&gt;bundling_override&lt;/code&gt; .</source>
          <target state="translated">참고 : &lt;code&gt;bundling&lt;/code&gt; 을 비활성화하면 &lt;code&gt;bundling_override&lt;/code&gt; 도 비활성화 됩니다.</target>
        </trans-unit>
        <trans-unit id="2dd410d2fbf3af306729dd64454481dab1a79d72" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;bundling_override&lt;/code&gt; also disables &lt;code&gt;bundling&lt;/code&gt; .</source>
          <target state="translated">참고 : &lt;code&gt;bundling_override&lt;/code&gt; 를 비활성화하면 &lt;code&gt;bundling&lt;/code&gt; 도 비활성화 됩니다.</target>
        </trans-unit>
        <trans-unit id="d840b005bb09f5240a311bf0713bd815028ba795" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;ignore_case&lt;/code&gt; also disables &lt;code&gt;ignore_case_always&lt;/code&gt; .</source>
          <target state="translated">참고 : &lt;code&gt;ignore_case&lt;/code&gt; 를 비활성화하면 &lt;code&gt;ignore_case_always&lt;/code&gt; 도 비활성화 됩니다 .</target>
        </trans-unit>
        <trans-unit id="0642b203ace91a0c6c6c1c85ec87408d95d51b9c" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;ignore_case_always&lt;/code&gt; also disables &lt;code&gt;ignore_case&lt;/code&gt; .</source>
          <target state="translated">참고 : &lt;code&gt;ignore_case_always&lt;/code&gt; 를 비활성화하면 &lt;code&gt;ignore_case&lt;/code&gt; 도 비활성화 됩니다 .</target>
        </trans-unit>
        <trans-unit id="cc88cd76d85c82ca33031114b858a78699d8dccf" translate="yes" xml:space="preserve">
          <source>Note: if the &lt;code&gt;applypatch&lt;/code&gt; program is installed and &lt;code&gt;CPAN::Config&lt;/code&gt; knows about it &lt;b&gt;and&lt;/b&gt; a patch is written by the &lt;code&gt;makepatch&lt;/code&gt; program, then &lt;code&gt;CPAN.pm&lt;/code&gt; lets &lt;code&gt;applypatch&lt;/code&gt; apply the patch. Both &lt;code&gt;makepatch&lt;/code&gt; and &lt;code&gt;applypatch&lt;/code&gt; are available from CPAN in the &lt;code&gt;JV/makepatch-*&lt;/code&gt; distribution.</source>
          <target state="translated">참고 : 경우 &lt;code&gt;applypatch&lt;/code&gt; 의 프로그램이 설치되어 있고 &lt;code&gt;CPAN::Config&lt;/code&gt; 그것에 대해 알고 &lt;b&gt;및&lt;/b&gt; 패치가에 의해 작성 &lt;code&gt;makepatch&lt;/code&gt; 의 프로그램, 다음 &lt;code&gt;CPAN.pm&lt;/code&gt; 는 할 수 &lt;code&gt;applypatch&lt;/code&gt; 패치를 적용합니다. &lt;code&gt;makepatch&lt;/code&gt; 와 &lt;code&gt;applypatch&lt;/code&gt; 는 모두 CPAN에서 &lt;code&gt;JV/makepatch-*&lt;/code&gt; 배포판으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="22e2016ea85ed84ee62e9e8de3756c81d1bdf26a" translate="yes" xml:space="preserve">
          <source>Note: if the computation is expensive or the hash has many elements, you may want to look at the Schwartzian Transform to cache the computation results.</source>
          <target state="translated">참고 : 계산이 비싸거나 해시에 많은 요소가있는 경우 Schwartzian Transform을보고 계산 결과를 캐시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a9aff6bff93b9cbae48137737db8e4d2881dc6a" translate="yes" xml:space="preserve">
          <source>Note: in most cases, particularly the &lt;a href=&quot;#Copy-Constructor&quot;&gt;Copy Constructor&lt;/a&gt;, this is unlikely to be appropriate behaviour.</source>
          <target state="translated">참고 : 대부분의 경우, 특히 &lt;a href=&quot;#Copy-Constructor&quot;&gt;Copy Constructor&lt;/a&gt; 는 적절한 동작이 아닐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9947057045b064f583a71d886808757ed0fa7848" translate="yes" xml:space="preserve">
          <source>Note: the behaviour described in this section can be disabled by setting &lt;code&gt;fallback&lt;/code&gt; to FALSE (see &lt;a href=&quot;#fallback&quot;&gt;fallback&lt;/a&gt;).</source>
          <target state="translated">참고 : &lt;code&gt;fallback&lt;/code&gt; 을 FALSE 로 설정하여이 섹션에서 설명 된 동작을 비활성화 할 수 있습니다 ( &lt;a href=&quot;#fallback&quot;&gt;폴백&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="ac4c5c965d1db592391a1881313b9980c7ebcd67" translate="yes" xml:space="preserve">
          <source>Note: the preceding paragraph describes what happens when Perl autogenerates the copy constructor for an object based on a scalar. For other cases, see &lt;a href=&quot;#Copy-Constructor&quot;&gt;Copy Constructor&lt;/a&gt;.</source>
          <target state="translated">참고 : 이전 단락에서는 Perl이 스칼라를 기반으로 객체의 복사 생성자를 자동 생성 할 때 발생하는 상황에 대해 설명합니다. 다른 경우에는 &lt;a href=&quot;#Copy-Constructor&quot;&gt;생성자 복사를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7c92c751ce0bf80febdd6e38233f67cab09e15ef" translate="yes" xml:space="preserve">
          <source>Note: this config variable is deprecated and will be removed in a future version of CPAN.pm. It will be replaced with the conventions around the family of $LANG and $LC_* environment variables.</source>
          <target state="translated">참고 :이 구성 변수는 더 이상 사용되지 않으며 이후 버전의 CPAN.pm에서 제거됩니다. $ LANG 및 $ LC_ * 환경 변수 패밀리 주위의 규칙으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="f59653e6422c3ee295a49f06549f34191c33d033" translate="yes" xml:space="preserve">
          <source>Note: this feature is still in alpha state and may change in future versions of CPAN.pm</source>
          <target state="translated">참고 :이 기능은 여전히 ​​알파 상태이며 CPAN.pm의 이후 버전에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a8ebc616c42eb9b0dd9d07b466e6d2d32bcecea" translate="yes" xml:space="preserve">
          <source>Note: this is a reasonably new addition to the family of socket functions, so all systems may not support this yet. If it is unsupported by the system, an attempt to use this method will abort the program.</source>
          <target state="translated">참고 : 이것은 소켓 기능 군에 새로 추가 된 것이므로 모든 시스템이 아직이를 지원하지 않을 수 있습니다. 시스템에서 지원하지 않는 경우이 방법을 사용하면 프로그램이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="b27494dc8cf34b92a043ab41a4f74f0c9f2a3ea4" translate="yes" xml:space="preserve">
          <source>Note: this mechanism is not used when use_sqlite is on and SQLLite is running.</source>
          <target state="translated">참고 : use_sqlite가 켜져 있고 SQLLite가 실행 중이면이 메커니즘이 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="13c903538586e11c4ad7bb5502c59a872fdcc9eb" translate="yes" xml:space="preserve">
          <source>Note: this method of setting config variables often provides more explanation about the functioning of a variable than the manpage.</source>
          <target state="translated">참고 :이 구성 변수 설정 방법은 맨 페이지보다 변수의 기능에 대한 자세한 설명을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="20d6330232e8dab848178ce084694142fca2d628" translate="yes" xml:space="preserve">
          <source>Note: you can define up to 20 conversion shortcuts in the gdb section.</source>
          <target state="translated">참고 : gdb 섹션에서 최대 20 개의 변환 바로 가기를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="87cfdde76898dd31c7d07ddb886016189457f68b" translate="yes" xml:space="preserve">
          <source>Notes for users of Compress::Zlib version 1</source>
          <target state="translated">Compress :: Zlib 버전 1 사용자를위한 참고 사항</target>
        </trans-unit>
        <trans-unit id="d65415edefc0ebcdd623f3ba5f7c329eeb91e917" translate="yes" xml:space="preserve">
          <source>Notes on Implementing Pod Processors</source>
          <target state="translated">포드 프로세서 구현에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="25796957df5d5e9f79fe37e61f8cb9ca4c5a759a" translate="yes" xml:space="preserve">
          <source>Nothing in void context (obviously).</source>
          <target state="translated">공허한 맥락에는 아무것도 없습니다 (분명히).</target>
        </trans-unit>
        <trans-unit id="945c9d82ead4c25705962fc07336d3f2e51d1d62" translate="yes" xml:space="preserve">
          <source>Nothing is documented.</source>
          <target state="translated">아무것도 기록되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ab9e54f52e7f7c5402697de9fbd9467e290f0479" translate="yes" xml:space="preserve">
          <source>Nothing too unusual here. You can easily do this if you have a cross-compiler available; A usual Configure invocation when targetting a Solaris x86 looks something like this:</source>
          <target state="translated">여기서 너무 특이한 것은 없습니다. 사용 가능한 크로스 컴파일러가있는 경우이를 쉽게 수행 할 수 있습니다. Solaris x86을 대상으로 할 때 일반적인 구성 호출은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a7b38ed2457b5a248dfea4058e6120cef0a01220" translate="yes" xml:space="preserve">
          <source>Nothing worked - die.</source>
          <target state="translated">아무것도 작동하지 않습니다-죽습니다.</target>
        </trans-unit>
        <trans-unit id="1b3f141ab87179d0755abc1d4da67f0c04e3ab7c" translate="yes" xml:space="preserve">
          <source>Nothing.</source>
          <target state="translated">Nothing.</target>
        </trans-unit>
        <trans-unit id="df845adff4c3af8c8d0292f7522181ec1444d9f8" translate="yes" xml:space="preserve">
          <source>Notice also that the warning is reported at the line where the object is first used.</source>
          <target state="translated">또한 개체가 처음 사용 된 줄에 경고가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="45dd83b2a71782cbd9802b63f62a266f8d43184c" translate="yes" xml:space="preserve">
          <source>Notice also the &lt;code&gt;grok_bin&lt;/code&gt; , &lt;code&gt;grok_hex&lt;/code&gt; , and &lt;code&gt;grok_oct&lt;/code&gt; functions in</source>
          <target state="translated">&lt;code&gt;grok_bin&lt;/code&gt; , &lt;code&gt;grok_hex&lt;/code&gt; 및 &lt;code&gt;grok_oct&lt;/code&gt; 함수 도 주목하십시오 .</target>
        </trans-unit>
        <trans-unit id="b0adcbd1247e60edf664089189052bb3a50dcbe1" translate="yes" xml:space="preserve">
          <source>Notice here the LEN is 10. (It may differ on your platform.) Extend the length of the string to one less than 10, and do a substitution:</source>
          <target state="translated">여기서 LEN은 10입니다. (플랫폼에 따라 다를 수 있습니다.) 문자열의 길이를 10 미만으로 확장하고 대체를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="4c9ef71a088f9de85175aa974029dc0d63466c4b" translate="yes" xml:space="preserve">
          <source>Notice how at no point does the value &quot;private&quot; get printed. That's because $var only has that value within the block of the lexical() function, and it is hidden from the called subroutine.</source>
          <target state="translated">&quot;private&quot;값이 인쇄되는 시점은 없습니다. $ var은 lexical () 함수의 블록 내에서만 해당 값을 가지며 호출 된 서브 루틴에서 숨겨지기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="77c47c9daa0e34a0be8b051a194ec532aabac71d" translate="yes" xml:space="preserve">
          <source>Notice how both parameters to &lt;code&gt;globmap&lt;/code&gt; are strings that are delimited by &amp;lt;&amp;gt;. This is done to make them look more like file globs - it is just syntactic sugar, but it can be handy when you want the strings to be visually distinctive. The enclosing &amp;lt;&amp;gt; are optional, so you don't have to use them - in fact the first thing globmap will do is remove these delimiters if they are present.</source>
          <target state="translated">&lt;code&gt;globmap&lt;/code&gt; 에 대한 두 매개 변수 가 &amp;lt;&amp;gt;로 구분 된 문자열 인 방법에 주목하십시오 . 이것은 파일 글로브처럼 보이게하기 위해 수행됩니다-그것은 단지 구문 설탕이지만 문자열을 시각적으로 독특하게 만들고 싶을 때 편리 할 수 ​​있습니다. 묶는 &amp;lt;&amp;gt;는 선택 사항이므로 사용할 필요가 없습니다. 실제로 글로브 맵에서 가장 먼저 할 일은 이러한 구분 기호가 있으면 제거하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ad17ed98712f08fde401be783e01fddfe4c94277" translate="yes" xml:space="preserve">
          <source>Notice how the return value from the &lt;code&gt;new&lt;/code&gt; constructor is used as a filehandle in the &lt;code&gt;while&lt;/code&gt; loop? That's what's called an</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 생성자 의 반환 값 이 &lt;code&gt;while&lt;/code&gt; 루프 에서 파일 핸들로 어떻게 사용되는지 확인하십시오 . 그게 소위</target>
        </trans-unit>
        <trans-unit id="ca8aa6acc2aa1f6723f38ec594c204d602c7b4d3" translate="yes" xml:space="preserve">
          <source>Notice how the second substitution stopped matching as soon as it encountered &quot;y &quot;. The &lt;code&gt;*?&lt;/code&gt; quantifier effectively tells the regular expression engine to find a match as quickly as possible and pass control on to whatever is next in line, as you would if you were playing hot potato.</source>
          <target state="translated">&quot;y&quot;가 발생하자마자 두 번째 대체가 일치하는 것을 중지했습니다. &lt;code&gt;*?&lt;/code&gt; 한정자는 효과적으로 정규식 엔진에 가능한 빨리 일치하는 것을 찾고 핫 포테이토 게임을 할 때와 마찬가지로 다음 라인에 제어를 전달하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="fa6e91727e4ee365f7ee9460c080c792faaad3e9" translate="yes" xml:space="preserve">
          <source>Notice how this (unprototyped) function doesn't care whether it was passed real scalars or arrays. Perl sees all arguments as one big, long, flat parameter list in &lt;code&gt;@_&lt;/code&gt; . This is one area where Perl's simple argument-passing style shines. The &lt;code&gt;upcase()&lt;/code&gt; function would work perfectly well without changing the &lt;code&gt;upcase()&lt;/code&gt; definition even if we fed it things like this:</source>
          <target state="translated">이 (프로토 타입이 지정되지 않은) 함수가 실제 스칼라 또는 배열로 전달되었는지 여부를 신경 쓰지 않는 것에 주목하십시오. Perl은 모든 인수를 &lt;code&gt;@_&lt;/code&gt; 에서 하나의 크고 길고 평평한 매개 변수 목록으로 간주합니다 . 이것은 Perl의 간단한 인수 전달 스타일이 빛나는 영역입니다. &lt;code&gt;upcase()&lt;/code&gt; 함수는 변경하지 않고 완벽하게 잘 작동합니다 &lt;code&gt;upcase()&lt;/code&gt; 우리는이 같은 물건을 공급하는 경우에도 정의 :</target>
        </trans-unit>
        <trans-unit id="4444833b9992f40fcab9e968725d8711a413e3d2" translate="yes" xml:space="preserve">
          <source>Notice that &quot;hello&quot; is only printed once, as when Perl sees that the sixth iteration of the outermost &lt;code&gt;(?:)*&lt;/code&gt; matches a zero-length string, it stops the &lt;code&gt;*&lt;/code&gt; .</source>
          <target state="translated">&quot;hello&quot;는 Perl이 가장 바깥 쪽 &lt;code&gt;(?:)*&lt;/code&gt; :) * 의 여섯 번째 반복이 길이가 0 인 문자열과 일치하는 것을 볼 때 &lt;code&gt;*&lt;/code&gt; 를 중지하므로 한 번만 인쇄 됩니다 .</target>
        </trans-unit>
        <trans-unit id="64a5ba33762b8a3df62c02415bc8d0abd71b566d" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;Dump()&lt;/code&gt; prints only elements 10 through 13 in the above code. The following code will print all of the elements.</source>
          <target state="translated">알 &lt;code&gt;Dump()&lt;/code&gt; , 상기 코드 (13)를 통해서만 소자 (10)를 출력한다. 다음 코드는 모든 요소를 ​​인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="e23423f7c29d56c0d20fc2f34471adb3aea96e69" translate="yes" xml:space="preserve">
          <source>Notice that a file glob pattern &lt;code&gt;*.tar.gz&lt;/code&gt; was used to match the &lt;code&gt;.tar.gz&lt;/code&gt; files, then a fairly similar regular expression was used in the substitute to allow the new filename to be created.</source>
          <target state="translated">파일 글로브 패턴 &lt;code&gt;*.tar.gz&lt;/code&gt; 가 &lt;code&gt;.tar.gz&lt;/code&gt; 파일 과 일치하는 데 사용 된 후 새 파일 이름을 작성할 수 있도록 대체적으로 유사한 정규식이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="309a93ea449f47318d5d11f1a3d425f1bac00a22" translate="yes" xml:space="preserve">
          <source>Notice that because of the default behaviour of not doing any conversion upon input if there is no default layer, it is easy to mistakenly write code that keeps on expanding a file by repeatedly encoding the data:</source>
          <target state="translated">기본 계층이없는 경우 입력시 변환을 수행하지 않는 기본 동작으로 인해 데이터를 반복적으로 인코딩하여 파일 확장을 유지하는 코드를 실수로 쉽게 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45e2138036f16fd01c487cf4e8627bd64352166d" translate="yes" xml:space="preserve">
          <source>Notice that both times the &lt;code&gt;put&lt;/code&gt; method was used the record index was specified using a variable, &lt;code&gt;$i&lt;/code&gt; , rather than the literal value itself. This is because &lt;code&gt;put&lt;/code&gt; will return the record number of the inserted line via that parameter.</source>
          <target state="translated">&lt;code&gt;put&lt;/code&gt; 메소드가 사용 된 두 번 레코드 레코드 는 리터럴 값 자체가 아닌 &lt;code&gt;$i&lt;/code&gt; 변수를 사용하여 지정 되었습니다. &lt;code&gt;put&lt;/code&gt; 은 해당 매개 변수를 통해 삽입 된 행의 레코드 번호를 리턴 하기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="d32eeef01ddef5893487334cb249c7d79c61492e" translate="yes" xml:space="preserve">
          <source>Notice that in these new test cases, the argument passed to round was a scalar variable. You might be wondering if you can round a constant or literal. To see what happens, temporarily add the following line to Mytest.t:</source>
          <target state="translated">이 새로운 테스트 사례에서 round에 전달 된 인수는 스칼라 변수였습니다. 상수 또는 리터럴을 반올림 할 수 있는지 궁금 할 것입니다. 어떻게되는지 확인하려면 Mytest.t에 다음 줄을 임시로 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="dc0dc28dfd6b3af28d5f3f343ec14d50dc738990" translate="yes" xml:space="preserve">
          <source>Notice that it was necessary to define the variable &lt;code&gt;ax&lt;/code&gt; . This is because the &lt;code&gt;ST&lt;/code&gt; macro expects it to exist. If we were in an XSUB it would not be necessary to define &lt;code&gt;ax&lt;/code&gt; as it is already defined for us.</source>
          <target state="translated">변수 &lt;code&gt;ax&lt;/code&gt; 를 정의해야합니다 . &lt;code&gt;ST&lt;/code&gt; 매크로가 존재하기를 기대 하기 때문 입니다. 우리가 XSUB에 있다면 &lt;code&gt;ax&lt;/code&gt; 는 이미 정의되어 있으므로 ax 를 정의 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="4559301041ec62ea61a8a1fd68eda86e54b3ac68" translate="yes" xml:space="preserve">
          <source>Notice that only literals (string or regular expression) having only legacy code points are affected: if you mix data like this</source>
          <target state="translated">레거시 코드 포인트 만있는 리터럴 (문자열 또는 정규식) 만 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="c0f86b253bff23ee24ee05dba74dabc635ca28ee" translate="yes" xml:space="preserve">
          <source>Notice that the core &lt;code&gt;&lt;a href=&quot;../functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; maybe rounding rather than truncating. What this means is that the core &lt;code&gt;&lt;a href=&quot;../functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; may be reporting the time as one second later than &lt;code&gt;gettimeofday()&lt;/code&gt; and &lt;code&gt;Time::HiRes::time()&lt;/code&gt; .</source>
          <target state="translated">코어 &lt;code&gt;&lt;a href=&quot;../functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; 이 잘리지 않고 반올림 될 수 있습니다. 이것이 의미하는 바는 핵심 &lt;code&gt;&lt;a href=&quot;../functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;gettimeofday()&lt;/code&gt; 및 &lt;code&gt;Time::HiRes::time()&lt;/code&gt; 보다 1 초 늦게 시간을보고 할 수 있다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="6ed987720b9a7557460b46e7f6aeb89459c4da26" translate="yes" xml:space="preserve">
          <source>Notice that the final match matched &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;p&lt;/code&gt; , which a match without the &lt;code&gt;\G&lt;/code&gt; anchor would have done. Also note that the final match did not update &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; is only updated on a &lt;code&gt;/g&lt;/code&gt; match. If the final match did indeed match &lt;code&gt;p&lt;/code&gt; , it's a good bet that you're running a very old (pre-5.6.0) version of Perl.</source>
          <target state="translated">최종 일치 는 &lt;code&gt;p&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; 와 일치 하며 &lt;code&gt;\G&lt;/code&gt; 앵커가 없는 일치 는 수행합니다. 또한 최종 경기는 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 를 업데이트하지 않았습니다 . &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;/g&lt;/code&gt; 일치 에서만 업데이트됩니다 . 마지막 경기가 실제로 &lt;code&gt;p&lt;/code&gt; 와 일치했다면 아주 오래된 (5.6.0 이전) 버전의 Perl을 실행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="11b14f084bcfbcc93f4c728dc8c7063e0ac84985" translate="yes" xml:space="preserve">
          <source>Notice that the outer bracket type has changed, and so our access syntax has also changed. That's because unlike C, in perl you can't freely interchange arrays and references thereto. $ref_to_AoA is a reference to an array, whereas @AoA is an array proper. Likewise, &lt;code&gt;$AoA[2]&lt;/code&gt; is not an array, but an array ref. So how come you can write these:</source>
          <target state="translated">외부 괄호 유형이 변경되었으므로 액세스 구문도 변경되었습니다. C와 달리 펄에서는 배열과 참조를 자유롭게 교환 할 수 없기 때문입니다. $ ref_to_AoA는 배열에 대한 참조 인 반면 @AoA는 적절한 배열입니다. 마찬가지로 &lt;code&gt;$AoA[2]&lt;/code&gt; 는 배열이 아니라 배열 참조입니다. 그래서 어떻게 쓸 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="4b4bf711776ec92640c01168664a95c86695d9a1" translate="yes" xml:space="preserve">
          <source>Notice that the programmer must supply the C code necessary to have the real rpcb_gettime() function called and to have the return values properly placed on the argument stack.</source>
          <target state="translated">프로그래머는 실제 rpcb_gettime () 함수를 호출하고 리턴 값을 인수 스택에 올바르게 배치하는 데 필요한 C 코드를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="40afcceb911c695d77d20dfe27b09ee506961834" translate="yes" xml:space="preserve">
          <source>Notice that the resulting directions might be somewhat surprising if you are looking at a flat worldmap: in such map projections the great circles quite often do not look like the shortest routes -- but for example the shortest possible routes from Europe or North America to Asia do often cross the polar regions. (The common Mercator projection does &lt;b&gt;not&lt;/b&gt; show great circles as straight lines: straight lines in the Mercator projection are lines of constant bearing.)</source>
          <target state="translated">평평한 세계지도를 보면 결과 방향이 다소 놀랍습니다. 그러한지도 투영에서 큰 원은 가장 짧은 경로처럼 보이지 않지만 유럽이나 북미에서 아시아까지 가능한 가장 짧은 경로처럼 보입니다. 종종 극지방을 교차합니다. 일반적인 Mercator 투영은 큰 원을 직선으로 표시 하지 &lt;b&gt;않습니다&lt;/b&gt; . Mercator 투영의 직선은 일정한 베어링 선입니다.</target>
        </trans-unit>
        <trans-unit id="cf6655a31d0fb590f3023635e120ce3082cf0511" translate="yes" xml:space="preserve">
          <source>Notice that this affects also the return values of the &lt;code&gt;display_format&lt;/code&gt; methods: in list context the whole parameter hash will be returned, as opposed to only the style parameter value. This is a potential incompatibility with earlier versions if you have been calling the &lt;code&gt;display_format&lt;/code&gt; method in list context.</source>
          <target state="translated">이는 &lt;code&gt;display_format&lt;/code&gt; 메소드 의 반환 값에도 영향을 미칩니다 . 목록 컨텍스트에서 전체 매개 변수 해시가 반환됩니다 (스타일 매개 변수 값만 반대). 목록 컨텍스트에서 &lt;code&gt;display_format&lt;/code&gt; 메소드를 호출 한 경우 이전 버전과의 비 호환 가능성이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7d79b02a2f56a81b2e831febdf1350cedb3c1a70" translate="yes" xml:space="preserve">
          <source>Notice that this example differs from the previous example only in its reference count. Compare this to the next example, where we dump &lt;code&gt;$b&lt;/code&gt; instead of &lt;code&gt;$a&lt;/code&gt; .</source>
          <target state="translated">이 예는 참조 횟수면에서만 이전 예와 다릅니다. 우리는 덤프 다음 예,이 비교 &lt;code&gt;$b&lt;/code&gt; 대신 &lt;code&gt;$a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="666303811970a38b268d6ae06ec62a57190a710e" translate="yes" xml:space="preserve">
          <source>Notice that we don't use the &lt;code&gt;env&lt;/code&gt; pointer. Normally handed to &lt;code&gt;perl_parse&lt;/code&gt; as its final argument, &lt;code&gt;env&lt;/code&gt; here is replaced by &lt;code&gt;NULL&lt;/code&gt; , which means that the current environment will be used.</source>
          <target state="translated">우리는 &lt;code&gt;env&lt;/code&gt; 포인터를 사용하지 않습니다 . 일반적으로 최종 인수 로 &lt;code&gt;perl_parse&lt;/code&gt; 를 전달하면 &lt;code&gt;env&lt;/code&gt; here는 &lt;code&gt;NULL&lt;/code&gt; 로 바뀌 므로 현재 환경이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="14ecce29919a6e670ddbfce3528fa1f7984fab4d" translate="yes" xml:space="preserve">
          <source>Notice that when &lt;code&gt;$z&lt;/code&gt; is not 0 &lt;code&gt;$rho_c&lt;/code&gt; is not equal to &lt;code&gt;$rho_s&lt;/code&gt; .</source>
          <target state="translated">알 때 &lt;code&gt;$z&lt;/code&gt; 아닌 0 &lt;code&gt;$rho_c&lt;/code&gt; 동일하지 &lt;code&gt;$rho_s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31ec88b4a9dbb1f747340d0b910dcdd339c4815c" translate="yes" xml:space="preserve">
          <source>Notice that when &lt;code&gt;$z&lt;/code&gt; is not 0 &lt;code&gt;$rho_s&lt;/code&gt; is not equal to &lt;code&gt;$rho_c&lt;/code&gt; .</source>
          <target state="translated">알 때 &lt;code&gt;$z&lt;/code&gt; 아닌 0 &lt;code&gt;$rho_s&lt;/code&gt; 동일하지 &lt;code&gt;$rho_c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d590cf6b82e4392a2e3299e1af99133b75ac011" translate="yes" xml:space="preserve">
          <source>Notice that you can choose to specify the length of the string to be assigned by using &lt;code&gt;sv_setpvn&lt;/code&gt; , &lt;code&gt;newSVpvn&lt;/code&gt; , or &lt;code&gt;newSVpv&lt;/code&gt; , or you may allow Perl to calculate the length by using &lt;code&gt;sv_setpv&lt;/code&gt; or by specifying 0 as the second argument to &lt;code&gt;newSVpv&lt;/code&gt; . Be warned, though, that Perl will determine the string's length by using &lt;code&gt;strlen&lt;/code&gt; , which depends on the string terminating with a &lt;code&gt;NUL&lt;/code&gt; character, and not otherwise containing NULs.</source>
          <target state="translated">당신은 문자열의 길이를 지정하기 위해 선택할 수있는 사항은 사용하여 할당 할 &lt;code&gt;sv_setpvn&lt;/code&gt; , &lt;code&gt;newSVpvn&lt;/code&gt; , 또는 &lt;code&gt;newSVpv&lt;/code&gt; 을 하거나 펄을 사용하여 길이를 계산할 수 있습니다 &lt;code&gt;sv_setpv&lt;/code&gt; 을 나에게 두 번째 인수로 0을 지정하여 &lt;code&gt;newSVpv&lt;/code&gt; . 그러나 Perl은 &lt;code&gt;strlen&lt;/code&gt; 을 사용하여 문자열 길이를 결정할 것입니다. strlen 을 사용 하면 문자열이 &lt;code&gt;NUL&lt;/code&gt; 문자로 끝나고 NUL을 포함하지 않는 문자열에 의존합니다 .</target>
        </trans-unit>
        <trans-unit id="870ccbb59c66300e9b3ea8f52b5a5f559b3dde16" translate="yes" xml:space="preserve">
          <source>Notice the &lt;code&gt;OBJECT&lt;/code&gt; attribute. MakeMaker generates the following variables in</source>
          <target state="translated">통지 &lt;code&gt;OBJECT&lt;/code&gt; 의 속성을. MakeMaker는 다음 변수를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f8aba368fbb68d7c50d7b29b9babed1e8eb186e8" translate="yes" xml:space="preserve">
          <source>Notice the &lt;code&gt;_&lt;/code&gt; in the above &lt;code&gt;&lt;a href=&quot;../functions/int&quot;&gt;int&lt;/a&gt;(-M _)&lt;/code&gt; : the &lt;code&gt;_&lt;/code&gt; is a magical filehandle that caches the information from the preceding &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/lstat&quot;&gt;lstat()&lt;/a&gt;&lt;/code&gt;, or filetest.</source>
          <target state="translated">차리는 &lt;code&gt;_&lt;/code&gt; 위에서 &lt;code&gt;&lt;a href=&quot;../functions/int&quot;&gt;int&lt;/a&gt;(-M _)&lt;/code&gt; 다음은 &lt;code&gt;_&lt;/code&gt; 앞의 정보 캐시 마법 핸들이다 &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/lstat&quot;&gt;lstat()&lt;/a&gt;&lt;/code&gt; , 또는 파일 테스트한다.</target>
        </trans-unit>
        <trans-unit id="4bb3a64dceeceb885b9680e4902401cdf9dc4f74" translate="yes" xml:space="preserve">
          <source>Notice the different order of arguments to &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Move&lt;/code&gt; than used in &lt;code&gt;memcpy&lt;/code&gt; and &lt;code&gt;memmove&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;memcpy&lt;/code&gt; 및 &lt;code&gt;memmove&lt;/code&gt; 에 사용 된 것과는 다른 &lt;code&gt;Copy&lt;/code&gt; 및 &lt;code&gt;Move&lt;/code&gt; 인수 순서를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="679c7845eb58a7c2d0b2d8985266c244821c6fe5" translate="yes" xml:space="preserve">
          <source>Notice the last two: you have an undef value, but a defined key!</source>
          <target state="translated">마지막 두 개에 주목하십시오. undef 값이지만 정의 된 키가 있습니다!</target>
        </trans-unit>
        <trans-unit id="448c7dc3dc98fc3fc0f5933ff2892ce9313d9152" translate="yes" xml:space="preserve">
          <source>Notice the two lines commented with &quot;XXXXX&quot;. If you check the first part of the typemap file (or section), you'll see that doubles are of type T_DOUBLE. In the INPUT part of the typemap, an argument that is T_DOUBLE is assigned to the variable arg by calling the routine SvNV on something, then casting it to double, then assigned to the variable arg. Similarly, in the OUTPUT section, once arg has its final value, it is passed to the sv_setnv function to be passed back to the calling subroutine. These two functions are explained in &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;; we'll talk more later about what that &quot;ST(0)&quot; means in the section on the argument stack.</source>
          <target state="translated">&quot;XXXXX&quot;로 주석 처리 된 두 줄에 주목하십시오. typemap 파일 (또는 섹션)의 첫 번째 부분을 확인하면 double이 T_DOUBLE 유형임을 알 수 있습니다. 타입 맵의 INPUT 부분에서 T_DOUBLE 인 인수는 루틴 SvNV를 호출하여 변수 arg에 할당 한 다음이를 double로 캐스팅 한 다음 변수 arg에 할당합니다. 마찬가지로, OUTPUT 섹션에서 arg가 최종 값을 갖 으면 sv_setnv 함수로 전달되어 호출 서브 루틴으로 다시 전달됩니다. 이 두 기능은 &lt;a href=&quot;perlguts&quot;&gt;perlguts에&lt;/a&gt; 설명되어 있습니다 . 나중에 인수 스택 섹션에서 &quot;ST (0)&quot;의 의미에 대해 자세히 설명하겠습니다.</target>
        </trans-unit>
        <trans-unit id="d783d11df518bc5c15566c5aca0ab336d7d1805f" translate="yes" xml:space="preserve">
          <source>Notice the use of GV_ADD as the second parameter. The new variable can now be set, using the routines appropriate to the data type.</source>
          <target state="translated">두 번째 매개 변수로 GV_ADD를 사용하십시오. 이제 데이터 유형에 적합한 루틴을 사용하여 새 변수를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08b42440fb285e46d8dc9159db458556192da3bc" translate="yes" xml:space="preserve">
          <source>Notice the white space in these examples. This construct always has the &lt;code&gt;/x&lt;/code&gt; modifier turned on within it.</source>
          <target state="translated">이 예제에서 공백을 확인하십시오. 이 구문에는 항상 &lt;code&gt;/x&lt;/code&gt; 수정자가 켜져 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf19896e6984078f566d31f89bc10d28920f05df" translate="yes" xml:space="preserve">
          <source>Notice we use &lt;code&gt;Perl_pp_add&lt;/code&gt; and not &lt;code&gt;pp_add&lt;/code&gt; - see &lt;a href=&quot;perlguts#Internal-Functions&quot;&gt;Internal Functions in perlguts&lt;/a&gt;. With the breakpoint in place, we can run our program:</source>
          <target state="translated">&lt;code&gt;Perl_pp_add&lt;/code&gt; 가 아닌 &lt;code&gt;pp_add&lt;/code&gt; 사용하는 것에 주목 하십시오 . &lt;a href=&quot;perlguts#Internal-Functions&quot;&gt;perlguts의 내부 함수를보십시오&lt;/a&gt; . 중단 점이 있으면 프로그램을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02cb5b7c921fb7ebbe36d3e0607902dde126730c" translate="yes" xml:space="preserve">
          <source>Notify is used to request Delivery Status Notifications (DSNs), but your SMTP/ESMTP service may not respect this request depending upon its version and your site's SMTP configuration.</source>
          <target state="translated">알림은 DSN (배달 상태 알림)을 요청하는 데 사용되지만 SMTP / ESMTP 서비스는 버전 및 사이트의 SMTP 구성에 따라이 요청을 존중하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da17090b524f51c10e88d0ac9b7049f8740a008e" translate="yes" xml:space="preserve">
          <source>Notify the server that the current message should be sent to all of the addresses given. Each address is sent as a separate command to the server. Should the sending of any address result in a failure then the process is aborted and a</source>
          <target state="translated">주어진 모든 주소로 현재 메시지를 보내야한다는 것을 서버에 알립니다. 각 주소는 별도의 명령으로 서버에 전송됩니다. 주소를 보내면 오류가 발생하면 프로세스가 중단되고</target>
        </trans-unit>
        <trans-unit id="9cbb4030243333159ba8734d1c5fd629386f77ad" translate="yes" xml:space="preserve">
          <source>Novell NetWare inherits its File::Spec behaviour from File::Spec::Win32.</source>
          <target state="translated">Novell NetWare는 File :: Spec :: Win32에서 File :: Spec 동작을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="dd6807acb122cd8525edb3b470a139acef9bafbd" translate="yes" xml:space="preserve">
          <source>November, 2007; by Christophe Grosjean: make cmpthese and timestr compute time consistently with style argument, default is 'all' not 'noc' any more.</source>
          <target state="translated">2007 년 11 월; 크리스토프 그로스 jean (CChristophe Grosjean) : cmpthese와 timestr이 스타일 인수와 일관되게 시간을 계산하도록하고, 기본값은 더 이상 'noc'가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e3b82040565bb4be6b11f778a2e3df327ed20a3b" translate="yes" xml:space="preserve">
          <source>Now</source>
          <target state="translated">Now</target>
        </trans-unit>
        <trans-unit id="c93d8b194f0c7fe984e291581c08b1052c5f3a15" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;$f1-&amp;gt;($n)&lt;/code&gt; is always 20 plus whatever $n you pass in, whereas &lt;code&gt;$f2-&amp;gt;($n)&lt;/code&gt; is always 555 plus whatever $n you pass in. The $addpiece in the closure sticks around.</source>
          <target state="translated">이제 &lt;code&gt;$f1-&amp;gt;($n)&lt;/code&gt; 은 항상 $ n을 더한 금액에 20을 더한 반면 $ f2- &lt;code&gt;$f2-&amp;gt;($n)&lt;/code&gt; 은 항상 555를 더한 금액에 $ n을 더한 금액입니다.</target>
        </trans-unit>
        <trans-unit id="f44dcb817094334da756769457dbdcc2f78729c5" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; customre&lt;/code&gt; enables the new escape in constant regular expressions, i.e., those without any runtime variable interpolations. As documented in &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt;, this conversion will work only over literal parts of regular expressions. For &lt;code&gt;\Y|$re\Y|&lt;/code&gt; the variable part of this regular expression needs to be converted explicitly (but only if the special meaning of &lt;code&gt;\Y|&lt;/code&gt; should be enabled inside $re):</source>
          <target state="translated">이제 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; customre&lt;/code&gt; 사용하면 상수 정규 표현식, 즉 런타임 변수 보간이없는 정규 표현식에서 새 이스케이프를 &lt;a href=&quot;functions/use&quot;&gt;사용할&lt;/a&gt; 수 있습니다. &lt;a href=&quot;overload&quot;&gt;overload에&lt;/a&gt; 설명 된 대로이 변환은 정규 표현식의 리터럴 부분에서만 작동합니다. 를 들어 &lt;code&gt;\Y|$re\Y|&lt;/code&gt; 이 정규 표현식의 변수 부분은 명시 적으로 변환되어야합니다 (그러나 &lt;code&gt;\Y|&lt;/code&gt; 의 특별한 의미가 $ re 내에서 활성화되어야 하는 경우에만 ).</target>
        </trans-unit>
        <trans-unit id="e5baf71e7fbf158fd008d8c03a7a8fa212d5b45f" translate="yes" xml:space="preserve">
          <source>Now I'll create a C program,</source>
          <target state="translated">이제 C 프로그램을 만들겠습니다.</target>
        </trans-unit>
        <trans-unit id="2b1360bf75473ee9266121d81e1a06dd9911acef" translate="yes" xml:space="preserve">
          <source>Now all those different functions appear to exist independently. You can call red(), RED(), blue(), BLUE(), green(), etc. This technique saves on both compile time and memory use, and is less error-prone as well, since syntax checks happen at compile time. It's critical that any variables in the anonymous subroutine be lexicals in order to create a proper closure. That's the reasons for the &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; on the loop iteration variable.</source>
          <target state="translated">이제 모든 다른 기능들이 독립적으로 존재하는 것으로 보입니다. red (), RED (), blue (), BLUE (), green () 등을 호출 할 수 있습니다.이 기술은 컴파일 시간과 메모리 사용을 절약하고 구문 검사가 발생하기 때문에 오류가 덜 발생합니다. 컴파일 시간. 익명 서브 루틴의 변수는 적절한 클로저를 만들기 위해 어휘이어야합니다. 이것이 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; on 루프 반복 변수 의 이유입니다 .</target>
        </trans-unit>
        <trans-unit id="4fd34829b18de1627725a95c603c191742b917e4" translate="yes" xml:space="preserve">
          <source>Now all you have to do is make.</source>
          <target state="translated">이제 당신이해야 할 일은 확인입니다.</target>
        </trans-unit>
        <trans-unit id="49b5690000abd466cabd2983e572f96822c8ad4b" translate="yes" xml:space="preserve">
          <source>Now an example using G_EVAL. Below is a Perl subroutine which computes the difference of its 2 parameters. If this would result in a negative result, the subroutine calls</source>
          <target state="translated">이제 G_EVAL을 사용하는 예입니다. 아래는 2 개의 매개 변수의 차이를 계산하는 Perl 서브 루틴입니다. 이것이 부정적인 결과를 초래하면, 서브 루틴 호출</target>
        </trans-unit>
        <trans-unit id="0107493cf3f67fc1eae2d61845bafd402e29a874" translate="yes" xml:space="preserve">
          <source>Now being maintained by Neil Bowers &amp;lt;neilb@cpan.org&amp;gt;</source>
          <target state="translated">현재 Neil Bowers가 관리하고 있습니다 &amp;lt;neilb@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d0a0f59849b2d6f78aa32cc04ac0bc8777dc3df0" translate="yes" xml:space="preserve">
          <source>Now build an on-the-fly object over a couple of lines (note the backslash):</source>
          <target state="translated">이제 몇 줄에 즉석 객체를 만듭니다 (백 슬래시 참고).</target>
        </trans-unit>
        <trans-unit id="b18a77ba9bd692a2de2351fc4472b7905512dae7" translate="yes" xml:space="preserve">
          <source>Now change that to call a Perl subroutine instead</source>
          <target state="translated">이제 Perl 서브 루틴을 대신 호출하도록 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="5eed8faf15fe7e07bcc558e5fbc255c10a771276" translate="yes" xml:space="preserve">
          <source>Now check whether &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec($read,$n,1)&lt;/a&gt;&lt;/code&gt; is true for some &lt;code&gt;$n&lt;/code&gt; .</source>
          <target state="translated">이제 일부 &lt;code&gt;$n&lt;/code&gt; 대해 &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec($read,$n,1)&lt;/a&gt;&lt;/code&gt; 이 true 인지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="35cab876c88e9037a6396981d2ddc61575d5495f" translate="yes" xml:space="preserve">
          <source>Now comes the clever bit. Lines in our ledger which are just income and not expenditure might end at column 46. Hence, we don't want to tell our &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; pattern that we &lt;b&gt;need&lt;/b&gt; to find another 12 characters; we'll just say &quot;if there's anything left, take it&quot;. As you might guess from regular expressions, that's what the &lt;code&gt;*&lt;/code&gt; means: &quot;use everything remaining&quot;.</source>
          <target state="translated">이제 영리한 비트가 온다. 다만 소득과 우리의 원장 라인하지 지출, 우리가 말하고 싶어하지 않는 따라서 열 (46)에 끝낼 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 우리가 그 패턴을 &lt;b&gt;필요로&lt;/b&gt; 또 다른 12 개 문자를 찾기 위해; 그냥 &quot;남은 것이 있으면 가져 가라&quot;고 말할 것입니다. 정규 표현식에서 짐작할 수 있듯이 &lt;code&gt;*&lt;/code&gt; 는 &quot;남은 모든 것을 사용하십시오&quot;라는 의미입니다.</target>
        </trans-unit>
        <trans-unit id="a13bda202e6718f6f18d21a1e47f52cfb3879053" translate="yes" xml:space="preserve">
          <source>Now compile this program (I'll call it</source>
          <target state="translated">이제이 프로그램을 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="c57d72b147b5753e6d9e423d3502ca9248d5f07f" translate="yes" xml:space="preserve">
          <source>Now compile:</source>
          <target state="translated">이제 컴파일하십시오 :</target>
        </trans-unit>
        <trans-unit id="f3d2e76534a9f4dbbaafe0b2d7b2922184fb31d5" translate="yes" xml:space="preserve">
          <source>Now consider floating point numbers with exponents. The key observation here is that</source>
          <target state="translated">이제 지수가있는 부동 소수점 숫자를 고려하십시오. 여기서 중요한 것은</target>
        </trans-unit>
        <trans-unit id="ff2a183c3b41e6c536df243f1dce108cb53ffa0f" translate="yes" xml:space="preserve">
          <source>Now edit the Mytest2.t script and change the number of tests to &quot;4&quot;, and add the following lines to the end of the script:</source>
          <target state="translated">이제 Mytest2.t 스크립트를 편집하고 테스트 수를 &quot;4&quot;로 변경하고 스크립트 끝에 다음 줄을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="2953f00009a89200e277b692ef57868b268aff69" translate="yes" xml:space="preserve">
          <source>Now for an example of dealing with the items returned from a Perl subroutine.</source>
          <target state="translated">이제 Perl 서브 루틴에서 리턴 된 항목을 다루는 예를 들어 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="0be3c2c5225baac76521af82d8668e34f7dced50" translate="yes" xml:space="preserve">
          <source>Now for something much more complex: &lt;code&gt;/x(?:foo*|b[a][rR])(foo|bar)$/&lt;/code&gt;</source>
          <target state="translated">더 복잡한 무언가를 위해 : &lt;code&gt;/x(?:foo*|b[a][rR])(foo|bar)$/&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92162dfafb815308e37a13a29bc3866c727f49ac" translate="yes" xml:space="preserve">
          <source>Now if $baz is overloaded like this, then &lt;code&gt;$baz&lt;/code&gt; is a reference to a reference to the intermediate array, which keeps a reference to an actual array, and the access hash. The tie()ing object for the access hash is a reference to a reference to the actual array, so</source>
          <target state="translated">$ 바즈이 같은 과부하되면 이제 다음 &lt;code&gt;$baz&lt;/code&gt; 실제 배열에 대한 참조를 유지 중간 어레이, 및 상기 액세스 해시 참조에 대한 참조이다. 액세스 해시의 tie () 객체는 실제 배열에 대한 참조에 대한 참조이므로</target>
        </trans-unit>
        <trans-unit id="442765a41777ec67298b58abdc70ce2f732fb2a5" translate="yes" xml:space="preserve">
          <source>Now if we see a &lt;code&gt;U&lt;/code&gt; which was at the start of the string, we turn on the &lt;code&gt;UTF8&lt;/code&gt; flag for the output SV, &lt;code&gt;cat&lt;/code&gt; :</source>
          <target state="translated">문자열의 시작 부분에 &lt;code&gt;U&lt;/code&gt; 가 표시 되면 출력 SV &lt;code&gt;cat&lt;/code&gt; 에 대해 &lt;code&gt;UTF8&lt;/code&gt; 플래그를 켭니다 .</target>
        </trans-unit>
        <trans-unit id="9aa71504ceae318c2af66092e17c9a82a7deb8c3" translate="yes" xml:space="preserve">
          <source>Now inner() can only be called from within outer(), because of the temporary assignments of the anonymous subroutine. But when it does, it has normal access to the lexical variable $x from the scope of outer() at the time outer is invoked.</source>
          <target state="translated">이제 익명 서브 루틴의 임시 할당으로 인해 inner ()는 outer () 내에서만 호출 할 수 있습니다. 그러나 그렇게하면 outer가 호출 될 때 outer ()의 범위에서 어휘 변수 $ x에 정상적으로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0dd64db78144735f7994758b886eab3a665aa14" translate="yes" xml:space="preserve">
          <source>Now is the time to build statically linked executable</source>
          <target state="translated">이제 정적으로 링크 된 실행 파일을 빌드 할 때입니다</target>
        </trans-unit>
        <trans-unit id="56e8b027d2534e474052d61aa156186a15f1e672" translate="yes" xml:space="preserve">
          <source>Now issue a command all Perl Mongers love:</source>
          <target state="translated">이제 모든 Perl Mongers가 좋아하는 명령을 발행하십시오.</target>
        </trans-unit>
        <trans-unit id="a8a1925328e3fa40f64265288667627705914e38" translate="yes" xml:space="preserve">
          <source>Now it really looks like two-dimensional arrays!</source>
          <target state="translated">이제는 2 차원 배열처럼 보입니다!</target>
        </trans-unit>
        <trans-unit id="6e306ced46a050d218e4778907f520f756de263d" translate="yes" xml:space="preserve">
          <source>Now it's time to print your data structure out. How are you going to do that? Well, if you want only one of the elements, it's trivial:</source>
          <target state="translated">이제 데이터 구조를 인쇄 할 차례입니다. 어떻게 하시겠습니까? 글쎄, 당신이 하나의 요소만을 원한다면, 그것은 사소한 것입니다 :</target>
        </trans-unit>
        <trans-unit id="54ce2aa34a908b75653982fdea46ab158bc6415a" translate="yes" xml:space="preserve">
          <source>Now just type in any legal Perl code, and it will be immediately evaluated. You can also examine the symbol table, get stack backtraces, check variable values, set breakpoints, and other operations typically found in symbolic debuggers.</source>
          <target state="translated">이제 합법적 인 Perl 코드를 입력하면 즉시 평가됩니다. 또한 심볼 테이블을 검사하고, 스택 역 추적을 얻고, 변수 값을 확인하고, 중단 점을 설정하고, 일반적으로 심볼릭 디버거에서 발견되는 기타 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71eab03d0589285d163e163d02feef9a891122b5" translate="yes" xml:space="preserve">
          <source>Now let's add to our extension a subroutine that will take a single numeric argument as input and return 1 if the number is even or 0 if the number is odd.</source>
          <target state="translated">이제 확장에 단일 숫자 인수를 입력으로 취하고 숫자가 짝수이면 1을 리턴하고 숫자가 홀수이면 0을 리턴하는 서브 루틴을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="b25fbca1c3ebbbe365fafa21da05b0bf381c9042" translate="yes" xml:space="preserve">
          <source>Now let's go on with the show!</source>
          <target state="translated">이제 쇼를 계속하자!</target>
        </trans-unit>
        <trans-unit id="56c9d0bafceed9745ea4a5c37d241ab5110ecbe0" translate="yes" xml:space="preserve">
          <source>Now let's look over &lt;code&gt;pp_pack&lt;/code&gt; : we take a pattern into &lt;code&gt;pat&lt;/code&gt; , and then loop over the pattern, taking each format character in turn into &lt;code&gt;datum_type&lt;/code&gt; . Then for each possible format character, we swallow up the other arguments in the pattern (a field width, an asterisk, and so on) and convert the next chunk input into the specified format, adding it onto the output SV &lt;code&gt;cat&lt;/code&gt; .</source>
          <target state="translated">이제 &lt;code&gt;pp_pack&lt;/code&gt; 을 살펴 봅시다 : 패턴을 &lt;code&gt;pat&lt;/code&gt; 에 넣은 다음 패턴을 반복하여 각 형식 문자를 &lt;code&gt;datum_type&lt;/code&gt; 으로 바꿉니다 . 그런 다음 가능한 각 형식 문자에 대해 패턴의 다른 인수 (필드 너비, 별표 등)를 삼켜 다음 청크 입력을 지정된 형식으로 변환하여 출력 SV &lt;code&gt;cat&lt;/code&gt; 에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="19bfc0dd7ed8b536789ace2adf6482eed3ae9d5d" translate="yes" xml:space="preserve">
          <source>Now let's make a slightly more complex example. This time we want to call a Perl subroutine, &lt;code&gt;LeftString&lt;/code&gt; , which will take 2 parameters--a string ($s) and an integer ($n). The subroutine will simply print the first $n characters of the string.</source>
          <target state="translated">이제 좀 더 복잡한 예를 만들어 봅시다. 이번에 는 문자열 ($ s)과 정수 ($ n)의 두 매개 변수를 사용 하는 Perl 서브 루틴 &lt;code&gt;LeftString&lt;/code&gt; 을 호출하려고합니다 . 서브 루틴은 단순히 문자열의 첫 $ n 문자를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="6354d1ac356f03ba53418ed6480c6b835c8d11e3" translate="yes" xml:space="preserve">
          <source>Now let's try a harder pattern. We will add a quantifier, so now we have the pattern &lt;code&gt;/foo+/&lt;/code&gt; . We will see that &lt;code&gt;regbranch()&lt;/code&gt; calls &lt;code&gt;regpiece()&lt;/code&gt; twice.</source>
          <target state="translated">이제 더 어려운 패턴을 시도해 봅시다. 우리는 한정자를 추가 할 것이므로, 이제 &lt;code&gt;/foo+/&lt;/code&gt; 패턴이 있습니다. &lt;code&gt;regbranch()&lt;/code&gt; 가 &lt;code&gt;regpiece()&lt;/code&gt; 두 번 호출 한다는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="889bc56f5635509a3bf0cc79dcaae69476badde9" translate="yes" xml:space="preserve">
          <source>Now maintained by Perl5 Porters.</source>
          <target state="translated">이제 Perl5 Porters가 유지 보수합니다.</target>
        </trans-unit>
        <trans-unit id="2038fc7801848170606c108e5b8808a37af01abf" translate="yes" xml:space="preserve">
          <source>Now numeric value of $c is 5. After &lt;code&gt;$a = 12; $b = 5&lt;/code&gt; the numeric value of $c becomes 13. To insulate the user of the module add a method</source>
          <target state="translated">이제 $ c의 숫자 값은 5입니다. &lt;code&gt;$a = 12; $b = 5&lt;/code&gt; 이후 ; $ b = 5 $ c의 숫자 값은 13이됩니다. 모듈의 사용자를 격리시키기 위해 메소드를 추가하십시오</target>
        </trans-unit>
        <trans-unit id="8af21af6d9d9b5497a4644877b2f52927ff73040" translate="yes" xml:space="preserve">
          <source>Now one can access an object using both the array and hash syntax:</source>
          <target state="translated">이제 배열과 해시 구문을 모두 사용하여 객체에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d5501fb3c867cabba9520f061ccb7181169320a" translate="yes" xml:space="preserve">
          <source>Now one can change the last line of the script to</source>
          <target state="translated">이제 스크립트의 마지막 줄을</target>
        </trans-unit>
        <trans-unit id="36a34b3fdc67a4c118c486e51977f9c88c24fbb9" translate="yes" xml:space="preserve">
          <source>Now one can finish the script by</source>
          <target state="translated">이제 스크립트를 완성 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="fb12351c6667dd534972c89f66e0ea83ea3b515d" translate="yes" xml:space="preserve">
          <source>Now perform the same steps as before, generating a Makefile from the Makefile.PL file, and running make.</source>
          <target state="translated">이제 이전과 동일한 단계를 수행하고 Makefile.PL 파일에서 Makefile을 생성하고 make를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="176a110722147c376bebc4313178934ce4ec0c61" translate="yes" xml:space="preserve">
          <source>Now process &quot;A&quot; updates the database and happens to change some of the data held in the initial buffer. Process &quot;A&quot; terminates, flushing all cached data to disk and releasing the database lock. At this point the database on disk will correctly reflect the changes made by process &quot;A&quot;.</source>
          <target state="translated">이제 프로세스 &quot;A&quot;는 데이터베이스를 업데이트하고 초기 버퍼에 보유 된 일부 데이터를 변경합니다. &quot;A&quot;프로세스가 종료되어 캐시 된 모든 데이터를 디스크로 플러시하고 데이터베이스 잠금을 해제합니다. 이 시점에서 디스크의 데이터베이스는 프로세스 &quot;A&quot;의 변경 사항을 올바르게 반영합니다.</target>
        </trans-unit>
        <trans-unit id="ef78e970daca9bfe36844c130043d8db552b721e" translate="yes" xml:space="preserve">
          <source>Now re-run make to rebuild our new shared library.</source>
          <target state="translated">이제 make를 다시 실행하여 새 공유 라이브러리를 다시 빌드하십시오.</target>
        </trans-unit>
        <trans-unit id="b502363c9d43a3258b18dcc28321bf168995d38c" translate="yes" xml:space="preserve">
          <source>Now run</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43d39e890e8ba24fba8997c278066f474d3fd060" translate="yes" xml:space="preserve">
          <source>Now run perl on the top-level Makefile.PL. Notice that it also created a Makefile in the mylib directory. Run make and watch that it does cd into the mylib directory and run make in there as well.</source>
          <target state="translated">이제 최상위 Makefile.PL에서 perl을 실행하십시오. 또한 mylib 디렉토리에 Makefile을 작성했습니다. make를 실행하고 mylib 디렉토리로 cd하고 make도 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="9680a56da8828aa80b4fe46f2d0d313dfaabb116" translate="yes" xml:space="preserve">
          <source>Now run:</source>
          <target state="translated">이제 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="431a120b5d4a3c45e45ae8e764d0243bae7f6294" translate="yes" xml:space="preserve">
          <source>Now suppose we have more than one interpreter instance running at the same time. This is feasible, but only if you used the Configure option &lt;code&gt;-Dusemultiplicity&lt;/code&gt; or the options &lt;code&gt;-Dusethreads -Duseithreads&lt;/code&gt; when building perl. By default, enabling one of these Configure options sets the per-interpreter global variable &lt;code&gt;PL_perl_destruct_level&lt;/code&gt; to &lt;code&gt;1&lt;/code&gt; , so that thorough cleaning is automatic and interpreter variables are initialized correctly. Even if you don't intend to run two or more interpreters at the same time, but to run them sequentially, like in the above example, it is recommended to build perl with the &lt;code&gt;-Dusemultiplicity&lt;/code&gt; option otherwise some interpreter variables may not be initialized correctly between consecutive runs and your application may crash.</source>
          <target state="translated">이제 하나 이상의 인터프리터 인스턴스가 동시에 실행되고 있다고 가정합니다. 이것은 가능하지만 perl을 &lt;code&gt;-Dusethreads -Duseithreads&lt;/code&gt; 할 때 Configure 옵션 &lt;code&gt;-Dusemultiplicity&lt;/code&gt; 또는 -Dusethreads -Duseithreads 옵션을 사용한 경우에만 가능합니다 . 기본적으로 이러한 구성 옵션 중 하나를 사용하면 인터프리터 당 글로벌 변수 &lt;code&gt;PL_perl_destruct_level&lt;/code&gt; 을 &lt;code&gt;1&lt;/code&gt; 로 설정하여 철저한 정리가 자동으로 수행되고 인터프리터 변수가 올바르게 초기화됩니다. 두 개 이상의 인터프리터를 동시에 실행하지 않으려는 경우에도 위의 예와 같이 순차적으로 실행하려면 &lt;code&gt;-Dusemultiplicity&lt;/code&gt; 를 사용하여 perl을 빌드하는 것이 좋습니다. 그렇지 않으면 연속 실행간에 일부 인터프리터 변수가 올바르게 초기화되지 않아 응용 프로그램이 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e1ba3c5bd850f498e4d354eafd68e49756fd894" translate="yes" xml:space="preserve">
          <source>Now take a look at your current directory. It should look like this.</source>
          <target state="translated">이제 현재 디렉토리를 살펴보십시오. 이렇게 보일 것입니다.</target>
        </trans-unit>
        <trans-unit id="afb0ec981d97896d9a67b5f9341746480fee45ab" translate="yes" xml:space="preserve">
          <source>Now that UNTIE exists the class designer can decide which parts of the class functionality are really associated with &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; and which with the object being destroyed. What makes sense for a given class depends on whether the inner references are being kept so that non-tie-related methods can be called on the object. But in most cases it probably makes sense to move the functionality that would have been in DESTROY to the UNTIE method.</source>
          <target state="translated">이제 풀어가 존재하는 클래스 디자이너는 급 기능의 일부가 정말과 관련된 결정할 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; 과 개체와 파괴되고있다. 주어진 클래스에 적합한 것은 내부 참조가 유지되는지 여부에 따라 넥타이와 관련되지 않은 메소드가 오브젝트에서 호출 될 수 있습니다. 그러나 대부분의 경우 DESTROY에 있었던 기능을 UNTIE 방법으로 옮기는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e6856d572f5c42bc67bf2b06905ca5effd5d4772" translate="yes" xml:space="preserve">
          <source>Now that basic require() and subroutines are tested, you can use the</source>
          <target state="translated">이제 기본 require () 및 서브 루틴이 테스트되었으므로</target>
        </trans-unit>
        <trans-unit id="efac8814e4d76977800b30df75313c1fb6bb539a" translate="yes" xml:space="preserve">
          <source>Now that the &quot;native&quot; mechanism is supported by &lt;code&gt;Sys::Syslog&lt;/code&gt; and selected by default, the use of the &lt;code&gt;setlogsock()&lt;/code&gt; function is discouraged because other mechanisms are less portable across operating systems. Authors of modules and programs that use this function, especially its cargo-cult form &lt;code&gt;setlogsock(&quot;unix&quot;)&lt;/code&gt; , are advised to remove any occurrence of it unless they specifically want to use a given mechanism (like TCP or UDP to connect to a remote host).</source>
          <target state="translated">&quot;기본&quot;메커니즘이 &lt;code&gt;Sys::Syslog&lt;/code&gt; 지원되고 기본적으로 선택 &lt;code&gt;setlogsock()&lt;/code&gt; 다른 메커니즘은 운영 체제에서 이식성이 떨어 지므로 setlogsock () 함수를 사용하지 않는 것이 좋습니다. 이 기능을 사용하는 모듈 및 프로그램, 특히화물 컬트 형식 &lt;code&gt;setlogsock(&quot;unix&quot;)&lt;/code&gt; 의 작성자 는 특정 메커니즘 (예 : TCP 또는 UDP 등을 사용하여 원격에 연결하지 않는 한)에서 발생을 제거하는 것이 좋습니다. 주최자).</target>
        </trans-unit>
        <trans-unit id="2001533940f7a7dc78b5938ec0ecf76cf899fefd" translate="yes" xml:space="preserve">
          <source>Now that the core of Perl is tested, &lt;a href=&quot;test/more&quot;&gt;Test::More&lt;/a&gt; can and should be used. You can also use the full suite of core modules in the tests.</source>
          <target state="translated">이제 Perl의 핵심을 &lt;a href=&quot;test/more&quot;&gt;테스트 했으므로 Test :: More를&lt;/a&gt; 사용할 수 있고 사용해야합니다. 테스트에서 전체 핵심 모듈 제품군을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7692728e97a21b18614fd5385fcbfb77d3648e29" translate="yes" xml:space="preserve">
          <source>Now that there is room on the stack, values can be pushed on it using &lt;code&gt;PUSHs&lt;/code&gt; macro. The pushed values will often need to be &quot;mortal&quot; (See &lt;a href=&quot;#Reference-Counts-and-Mortality&quot;&gt;Reference Counts and Mortality&lt;/a&gt;):</source>
          <target state="translated">이제 스택에 공간이 있으므로 &lt;code&gt;PUSHs&lt;/code&gt; 매크로를 사용하여 값을 푸시 할 수 있습니다 . 푸시 된 값은 종종 &quot;치명적&quot;이어야합니다 ( &lt;a href=&quot;#Reference-Counts-and-Mortality&quot;&gt;참조 횟수 및 사망률 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="30355dc46fa236bc2762d6b874a869adc19e6693" translate="yes" xml:space="preserve">
          <source>Now that we have seen &lt;code&gt;P&lt;/code&gt; at work, we might as well give &lt;code&gt;p&lt;/code&gt; a whirl. Why do we need a second template code for packing pointers at all? The answer lies behind the simple fact that an &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;p&lt;/code&gt; promises a null-terminated string starting at the address taken from the buffer, and that implies a length for the data item to be returned:</source>
          <target state="translated">이제 직장에서 &lt;code&gt;P&lt;/code&gt; 를 보았 으므로 &lt;code&gt;p&lt;/code&gt; 에 소용돌이를 줄 수도 있습니다 . 포인터를 패킹하기 위해 두 번째 템플릿 코드가 필요한 이유는 무엇입니까? 답은 &lt;code&gt;p&lt;/code&gt; 로 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 가 버퍼에서 가져온 주소에서 시작하여 null로 끝나는 문자열을 약속하며 데이터 항목이 반환되는 길이를 암시한다는 간단한 사실 뒤에 있습니다.</target>
        </trans-unit>
        <trans-unit id="3289c147e35201c5816ca81ac2c53e6c21248267" translate="yes" xml:space="preserve">
          <source>Now that we have the &lt;code&gt;*foo{THING}&lt;/code&gt; notation, typeglobs aren't used as much for filehandle manipulations, although they're still needed to pass brand new file and directory handles into or out of functions. That's because &lt;code&gt;*HANDLE{IO}&lt;/code&gt; only works if HANDLE has already been used as a handle. In other words, &lt;code&gt;*FH&lt;/code&gt; must be used to create new symbol table entries; &lt;code&gt;*foo{THING}&lt;/code&gt; cannot. When in doubt, use &lt;code&gt;*FH&lt;/code&gt; .</source>
          <target state="translated">이제 우리는 &lt;code&gt;*foo{THING}&lt;/code&gt; 표기법 을 가지므로 , typeglobs는 여전히 새로운 파일과 디렉토리 핸들을 함수 안팎으로 전달해야하지만 파일 핸들 조작에는 많이 사용되지 않습니다. HANDLE이 이미 핸들로 사용 된 경우에만 &lt;code&gt;*HANDLE{IO}&lt;/code&gt; 작동 하기 때문 입니다. 다시 말해, &lt;code&gt;*FH&lt;/code&gt; 를 사용하여 새 기호 테이블 항목을 작성해야합니다. &lt;code&gt;*foo{THING}&lt;/code&gt; 은 할 수 없습니다. &lt;code&gt;*FH&lt;/code&gt; 경우 * FH를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="94fb438178c3f179a69d1380f1c008b5fe2d33bb" translate="yes" xml:space="preserve">
          <source>Now that we have this pattern stored as a handy string, we might feel tempted to use it as a part of some other pattern:</source>
          <target state="translated">이 패턴을 편리한 문자열로 저장 했으므로 다른 패턴의 일부로 사용하려는 유혹을 느낄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c183105c83816c48c77d4c827336e4e813e84f27" translate="yes" xml:space="preserve">
          <source>Now that we've covered the basics of threads, it's time for our next topic: Data. Threading introduces a couple of complications to data access that non-threaded programs never need to worry about.</source>
          <target state="translated">이제 스레드의 기본 사항을 다루었으므로 이제 다음 주제 인 데이터를 살펴 보겠습니다. 스레딩은 스레드가 아닌 프로그램이 걱정할 필요가없는 데이터 액세스에 몇 가지 복잡한 문제를 야기합니다.</target>
        </trans-unit>
        <trans-unit id="17f47b8aedf9a1b8e0f108087ca6f763b020db20" translate="yes" xml:space="preserve">
          <source>Now that you know what the problem is, what can you do to avoid it? Prior to the introduction of the optional UNTIE method the only way was the good old &lt;code&gt;-w&lt;/code&gt; flag. Which will spot any instances where you call untie() and there are still valid references to the tied object. If the second script above this near the top &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'untie'&lt;/code&gt; or was run with the &lt;code&gt;-w&lt;/code&gt; flag, Perl prints this warning message:</source>
          <target state="translated">이제 문제가 무엇인지 알았으므로이를 피하기 위해 무엇을 할 수 있습니까? 선택적 UNTIE 방법을 도입하기 전에 유일한 유일한 방법은 good old &lt;code&gt;-w&lt;/code&gt; 플래그였습니다. untie ()를 호출하고 연결된 객체에 대한 유효한 참조가 여전히있는 인스턴스를 발견합니다. 만약 근처에서이 위의 두 번째 스크립트 상단 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'untie'&lt;/code&gt; 또는 실행 된 &lt;code&gt;-w&lt;/code&gt; 플래그, 펄이 경고 메시지를 출력합니다 :</target>
        </trans-unit>
        <trans-unit id="022bdd2be74a4d788e977f99278118a67ba2ad8d" translate="yes" xml:space="preserve">
          <source>Now that you understand how &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; looks for files with a bareword argument, there is a little extra functionality going on behind the scenes. Before &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; looks for a &quot;</source>
          <target state="translated">bare 인수로 파일을 찾는 방법이 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 하다는 것을 이해 했으므로 배경 뒤에 약간의 추가 기능이 있습니다. 전에 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; &quot;A의 모습을</target>
        </trans-unit>
        <trans-unit id="597f8013d78df265fd55b188a128a0c6cbbf532e" translate="yes" xml:space="preserve">
          <source>Now that you understand how &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; looks for files with a bareword argument, there is a little extra functionality going on behind the scenes. Before &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; looks for a &quot;</source>
          <target state="translated">bare 인수로 파일을 찾는 방법이 &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 하다는 것을 이해 했으므로 배경 뒤에 약간의 추가 기능이 있습니다. 전에 &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; &quot;A의 모습을</target>
        </trans-unit>
        <trans-unit id="b76e84f2c33cd5c972aa524cad0960f89f22f060" translate="yes" xml:space="preserve">
          <source>Now the command line may look like:</source>
          <target state="translated">이제 명령 행은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b70b0be20fc0cb8a073d7d288b92a6e5925d77b2" translate="yes" xml:space="preserve">
          <source>Now the output doesn't have the spaces between the elements because the elements of &lt;code&gt;@animals&lt;/code&gt; simply become part of the list to &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;@animals&lt;/code&gt; 의 요소가 단순히 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 목록의 일부가되기 때문에 출력에 요소 사이에 공백이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="3c3e5717f93544ac6beb2dcf88b8c55f969febc1" translate="yes" xml:space="preserve">
          <source>Now the output shows that &lt;code&gt;foo&lt;/code&gt; doesn't get the &lt;code&gt;@_&lt;/code&gt; from its caller.</source>
          <target state="translated">이제 출력은 &lt;code&gt;foo&lt;/code&gt; 가 호출자로부터 &lt;code&gt;@_&lt;/code&gt; 를 얻지 못함을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="3fcb9eb262daa67d00f7dccd8fa99c81f713a40e" translate="yes" xml:space="preserve">
          <source>Now the parsing stage is complete, and the finished tree represents the operations that the Perl interpreter needs to perform to execute our program. Next, Perl does a dry run over the tree looking for optimisations: constant expressions such as &lt;code&gt;3 + 4&lt;/code&gt; will be computed now, and the optimizer will also see if any multiple operations can be replaced with a single one. For instance, to fetch the variable &lt;code&gt;$foo&lt;/code&gt; , instead of grabbing the glob &lt;code&gt;*foo&lt;/code&gt; and looking at the scalar component, the optimizer fiddles the op tree to use a function which directly looks up the scalar in question. The main optimizer is &lt;code&gt;peep&lt;/code&gt; in</source>
          <target state="translated">이제 파싱 단계가 완료되었으며 완성 된 트리는 Perl 인터프리터가 프로그램을 실행하기 위해 수행해야하는 작업을 나타냅니다. 다음으로 Perl은 트리에서 드라 이런을 수행하여 최적화를 찾습니다. 이제 &lt;code&gt;3 + 4&lt;/code&gt; 와 같은 상수 표현식 이 계산되고 옵티마이 저는 여러 연산이 단일 연산으로 대체 될 수 있는지 확인합니다. 예를 들어, 변수 &lt;code&gt;$foo&lt;/code&gt; 를 가져 오기 위해 glob &lt;code&gt;*foo&lt;/code&gt; 를 잡고 스칼라 구성 요소를 보는 대신 옵티마이 저는 op 트리를 피킹하여 해당 스칼라를 직접 찾는 함수를 사용합니다. 주요 최적화는 &lt;code&gt;peep&lt;/code&gt; 에</target>
        </trans-unit>
        <trans-unit id="0b0d2c80b383fda949460859c7cc860ad47a12c4" translate="yes" xml:space="preserve">
          <source>Now the rpcb_gettime() function can be used from Perl with the following statement.</source>
          <target state="translated">이제 rpcb_gettime () 함수를 다음 명령문으로 Perl에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b44a2219a59e7204e7ee350a2cc75af078d1e4b" translate="yes" xml:space="preserve">
          <source>Now think about</source>
          <target state="translated">이제 생각 해봐</target>
        </trans-unit>
        <trans-unit id="c30cd0c985054472ce92540629db69d82b31ed97" translate="yes" xml:space="preserve">
          <source>Now think of each logical connection between the Perl parser and an individual file as a</source>
          <target state="translated">이제 Perl 파서와 개별 파일 간의 각 논리적 연결을</target>
        </trans-unit>
        <trans-unit id="63aed2505c6485cbd9c4824f7162c565df48aa33" translate="yes" xml:space="preserve">
          <source>Now type</source>
          <target state="translated">이제 입력</target>
        </trans-unit>
        <trans-unit id="69d98bfb814f8df94eddba674df944be471dcc9f" translate="yes" xml:space="preserve">
          <source>Now we also need to create a typemap because the default Perl doesn't currently support the &lt;code&gt;const char *&lt;/code&gt; type. Include a new TYPEMAP section in your XS code before the above function:</source>
          <target state="translated">이제 기본 Perl은 &lt;code&gt;const char *&lt;/code&gt; 유형을 지원하지 않기 때문에 타입 맵을 만들어야합니다 . 위 함수 전에 XS 코드에 새로운 TYPEMAP 섹션을 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="ac3c0b8b639b2123b87b956629756b446c6934e9" translate="yes" xml:space="preserve">
          <source>Now we can have a look at that first ($key) variable:</source>
          <target state="translated">이제 첫 번째 ($ 키) 변수를 살펴볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="185a7b552e431f4b4b46cbef152d792a78593a6f" translate="yes" xml:space="preserve">
          <source>Now we can match the 'a' and the 't'.</source>
          <target state="translated">이제 'a'와 't'를 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bd64428bd387110ec5af71e395507d7b42d715c" translate="yes" xml:space="preserve">
          <source>Now we can use the subroutine just as any other built-in function:</source>
          <target state="translated">이제 다른 내장 함수와 마찬가지로 서브 루틴을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5dd4060fc442a49be75b77cb5ad37ebb6eff79fc" translate="yes" xml:space="preserve">
          <source>Now we have a special case. The &lt;code&gt;EXACT&lt;/code&gt; regop has a &lt;code&gt;regnext&lt;/code&gt; of 0. This is because if it matches it should try to match itself again. The &lt;code&gt;PLUS&lt;/code&gt; regop handles the actual failure of the &lt;code&gt;EXACT&lt;/code&gt; regop and acts appropriately (going to regnode 6 if the &lt;code&gt;EXACT&lt;/code&gt; matched at least once, or failing if it didn't).</source>
          <target state="translated">이제 특별한 경우가 있습니다. &lt;code&gt;EXACT&lt;/code&gt; regop는이 &lt;code&gt;regnext&lt;/code&gt; 일치하는 경우 다시 자신을 일치하도록 시도해야하기 때문입니다 0의를. &lt;code&gt;PLUS&lt;/code&gt; 의 regop는 실제 고장 처리 &lt;code&gt;EXACT&lt;/code&gt; regop를 적절히 작용합니다 (이 경우 6 regnode가는 &lt;code&gt;EXACT&lt;/code&gt; 번 적어도 일치하거나, 그렇지 않다면 실패).</target>
        </trans-unit>
        <trans-unit id="9e8623792298834d51348eb8a4e63d54b4322603" translate="yes" xml:space="preserve">
          <source>Now we make the script executable (&lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod&lt;/a&gt; +x hello&lt;/code&gt; ), run the script and we should see the following output:</source>
          <target state="translated">이제 스크립트 실행 파일 ( &lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod&lt;/a&gt; +x hello&lt;/code&gt; ) 을 만들고 스크립트를 실행 하면 다음 출력이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="27be17fcef7387e3ac6e2da3084db2de80fc9a40" translate="yes" xml:space="preserve">
          <source>Now we pass Perl the command line options, and tell it to go:</source>
          <target state="translated">이제 Perl에 명령 행 옵션을 전달하고 다음과 같이 지시합니다.</target>
        </trans-unit>
        <trans-unit id="619205ae318e9243260c596997993412134beb8d" translate="yes" xml:space="preserve">
          <source>Now we skip another character and pick up the next 7 characters:</source>
          <target state="translated">이제 다른 캐릭터를 건너 뛰고 다음 7 개의 캐릭터를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="00d5b0ef9c96351760d2c5c765c6707b0214ca3c" translate="yes" xml:space="preserve">
          <source>Now we'll continue down into our subroutine, this time rather than by line number, we'll use the subroutine name, followed by the now familiar 'v':</source>
          <target state="translated">이제 우리는 서브 루틴으로 계속 진행할 것입니다. 이번에는 줄 번호가 아닌 서브 루틴 이름을 사용하고 이제는 익숙한 'v'를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="cb9e80e524c6f9e9ce8a182f0f81c0eb761fa3d6" translate="yes" xml:space="preserve">
          <source>Now we'll run &quot;&lt;code&gt;perl Makefile.PL&lt;/code&gt; &quot;. This will create a real Makefile, which make needs. Its output looks something like:</source>
          <target state="translated">이제 &quot; &lt;code&gt;perl Makefile.PL&lt;/code&gt; &quot;을 실행하겠습니다 . 이렇게하면 실제 Makefile이 만들어져 필요합니다. 출력 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2de2aee884a419878e3de43e61bda1852424c1b9" translate="yes" xml:space="preserve">
          <source>Now we'll test that we got that space-at-the-beginning business right:</source>
          <target state="translated">이제 우리는 우리가 시작한 우주 사업을 올바르게 수행했는지 테스트 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="ee9f66c8ea145e68aa8eae836da50bbcb17dec57" translate="yes" xml:space="preserve">
          <source>Now we're finally ready to go: we have compiled Perl byte code, and all that's left to do is run it. The actual execution is done by the &lt;code&gt;runops_standard&lt;/code&gt; function in</source>
          <target state="translated">이제 우리는 갈 준비가되었습니다 : 우리는 Perl 바이트 코드를 컴파일했고 남은 것은 그것을 실행하는 것입니다. 실제 실행은 &lt;code&gt;runops_standard&lt;/code&gt; 함수에 의해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="952f473e58faf0d44b6ff273d0893bc5ac586a94" translate="yes" xml:space="preserve">
          <source>Now when you run it, perl complains about the 3 undeclared variables and we get four error messages because one variable is referenced twice:</source>
          <target state="translated">이제 실행할 때 perl은 선언되지 않은 3 개의 변수에 대해 불평하고 하나의 변수가 두 번 참조되므로 4 개의 오류 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0876df351c2b288f71557a0b6c1ab72f84bc0972" translate="yes" xml:space="preserve">
          <source>Now you can add new rows. What about adding new columns? If you're dealing with just matrices, it's often easiest to use simple assignment:</source>
          <target state="translated">이제 새 행을 추가 할 수 있습니다. 새 열을 추가하는 것은 어떻습니까? 행렬 만 다루는 경우 간단한 할당을 사용하는 것이 가장 쉬운 경우가 많습니다.</target>
        </trans-unit>
        <trans-unit id="2be97d39881315756923220b5afaca5ad300443e" translate="yes" xml:space="preserve">
          <source>Now you can check whether &lt;code&gt;$is_blue{$some_color}&lt;/code&gt; . It might have been a good idea to keep the blues all in a hash in the first place.</source>
          <target state="translated">이제 &lt;code&gt;$is_blue{$some_color}&lt;/code&gt; 여부를 확인할 수 있습니다 . 우선 블루스를 모두 해시로 유지하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1ee59fdf448204f1b7cf0a44d5a105acb3af778e" translate="yes" xml:space="preserve">
          <source>Now you can compile Perl. Type:</source>
          <target state="translated">이제 Perl을 컴파일 할 수 있습니다. 유형:</target>
        </trans-unit>
        <trans-unit id="dc97bf08f7c15142a6f3d523c401171e1e4e28c7" translate="yes" xml:space="preserve">
          <source>Now you can generate the binary distribution. This is done by running the test of the CPAN distribution &lt;code&gt;OS2::SoftInstaller&lt;/code&gt; . Tune up the file</source>
          <target state="translated">이제 바이너리 배포판을 생성 할 수 있습니다. 이는 CPAN 분배 &lt;code&gt;OS2::SoftInstaller&lt;/code&gt; 테스트를 실행하여 수행됩니다 . 파일 조정</target>
        </trans-unit>
        <trans-unit id="b5488e33f64416e81673146fac575b55bb707541" translate="yes" xml:space="preserve">
          <source>Now you can rename the file</source>
          <target state="translated">이제 파일 이름을 바꿀 수 있습니다</target>
        </trans-unit>
        <trans-unit id="b4dfea4420493c8513c6f853fcbb48064d4dcaa8" translate="yes" xml:space="preserve">
          <source>Now you can start it with the following (SDF) command:</source>
          <target state="translated">이제 다음 (SDF) 명령으로 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e91ff17e6547bed1e530a38f7ea777276f8d4972" translate="yes" xml:space="preserve">
          <source>Now you can write</source>
          <target state="translated">이제 쓸 수 있습니다</target>
        </trans-unit>
        <trans-unit id="6e8bd31d0e13ce896668841f465f0182170d2759" translate="yes" xml:space="preserve">
          <source>Now you can write to that filehandle using any of &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이제 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; 중 하나를 사용하여 해당 파일 핸들에 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bdb28492c5cef9c671966ba77fa7de09ce89c81d" translate="yes" xml:space="preserve">
          <source>Now you can.</source>
          <target state="translated">이제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a87b9f63332f9de75bca22552a19ed7ae7967b2" translate="yes" xml:space="preserve">
          <source>Now you cannot alter &lt;code&gt;$PI&lt;/code&gt; , which is probably a good thing all in all. This isn't the same as a constant subroutine, which is subject to optimization at compile-time. A constant subroutine is one prototyped to take no arguments and to return a constant expression. See &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt; for details on these. The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; pragma is a convenient shorthand for these.</source>
          <target state="translated">이제 &lt;code&gt;$PI&lt;/code&gt; 변경할 수 없습니다. 아마도 좋은 일입니다. 이것은 상수 서브 루틴과 같지 않으며 컴파일 타임에 최적화됩니다. 상수 서브 루틴은 인수를 취하지 않고 상수 표현식을 리턴하도록 프로토 타입 된 것입니다. &lt;a href=&quot;perlsub&quot;&gt;이에&lt;/a&gt; 대한 자세한 내용 은 perlsub 를 참조하십시오 . &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; pragma는 이러한 편리한 속기이다.</target>
        </trans-unit>
        <trans-unit id="c321db61248ffe9e9cd3c5b03c9c5342de8be25b" translate="yes" xml:space="preserve">
          <source>Now you check whether $is_tiny_prime[$some_number].</source>
          <target state="translated">이제 $ is_tiny_prime [$ some_number]인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="83fe5a64ce5d7ca3309f06409d39b88da08832f7" translate="yes" xml:space="preserve">
          <source>Now you have all the necessary</source>
          <target state="translated">이제 필요한 모든 것이 있습니다</target>
        </trans-unit>
        <trans-unit id="8fc27d587ac3ae46eb6cab078485ce4e120d86fc" translate="yes" xml:space="preserve">
          <source>Now you have the entire POD document as one great big parse-tree. You can even use the &lt;b&gt;-expand_seq&lt;/b&gt; option to &lt;b&gt;parse_text&lt;/b&gt; to insert whole different kinds of objects. Just don't expect &lt;b&gt;Pod::Parser&lt;/b&gt; to know what to do with them after that. That will need to be in your code. Or, alternatively, you can insert any object you like so long as it conforms to the &lt;b&gt;Pod::ParseTree&lt;/b&gt; interface.</source>
          <target state="translated">이제 전체 POD 문서를 하나의 큰 파싱 트리로 만들었습니다. 당신도 사용할 수 있습니다 &lt;b&gt;-expand_seq&lt;/b&gt; 에 옵션을 &lt;b&gt;parse_text&lt;/b&gt; 객체의 완전히 다른 종류를 삽입 할 수 있습니다. &lt;b&gt;Pod :: Parser&lt;/b&gt; 가 그 이후에 그들과 어떻게해야할지 알 필요는 없습니다 . 그것은 당신의 코드에 있어야합니다. 또는 &lt;b&gt;Pod :: ParseTree&lt;/b&gt; 인터페이스를 준수하는 한 원하는 객체를 삽입 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eb427c950b9b31bacabe117fb02e576d6e7f4125" translate="yes" xml:space="preserve">
          <source>Now you may use functions like &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getc&quot;&gt;getc&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; on that handle. Probably the most common input function is the one that looks like an operator:</source>
          <target state="translated">이제 해당 핸들에서 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/getc&quot;&gt;getc&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; 와 같은 함수를 사용할 수 있습니다 . 아마도 가장 일반적인 입력 기능은 연산자처럼 보이는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6e6caee9b93719c7443bbaefae78111aa87180e8" translate="yes" xml:space="preserve">
          <source>Now you should be very careful that the outer bracket type is a round one, that is, a parenthesis. That's because you're assigning to an @array, so you need parentheses. If you wanted there</source>
          <target state="translated">이제 외부 브래킷 유형이 둥근 유형, 즉 괄호인지 확인해야합니다. @array에 할당하기 때문에 괄호가 필요합니다. 당신이 원한다면</target>
        </trans-unit>
        <trans-unit id="62389bcb5052013362af7bc38fbef11d7810e62d" translate="yes" xml:space="preserve">
          <source>Now you're ready to build:</source>
          <target state="translated">이제 빌드 할 준비가되었습니다 :</target>
        </trans-unit>
        <trans-unit id="3894685c626d75138daa573dc3cd4fad72278a40" translate="yes" xml:space="preserve">
          <source>Now your IO would be ASCII on ASCII partitions and EBCDIC on EBCDIC partitions. See the documentation of PerlIO (without &lt;code&gt;Encode::&lt;/code&gt; !) for further possibilities.</source>
          <target state="translated">이제 IO는 ASCII 파티션의 ASCII이고 EBCDIC 파티션의 EBCDIC입니다. 추가 가능성 은 PerlIO 설명서 ( &lt;code&gt;Encode::&lt;/code&gt; ! 제외)를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4c0c77aa49899b95cf7b7a3e733f8b2e46061080" translate="yes" xml:space="preserve">
          <source>Now!</source>
          <target state="translated">Now!</target>
        </trans-unit>
        <trans-unit id="09be148c7c1b618a5b7b7231898ec72cf009f060" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;-h24&lt;/code&gt; will set the option &lt;code&gt;h&lt;/code&gt; to &lt;code&gt;24&lt;/code&gt; , but option bundles like &lt;code&gt;-vxa&lt;/code&gt; and &lt;code&gt;-h24w80&lt;/code&gt; are flagged as errors.</source>
          <target state="translated">이제 &lt;code&gt;-h24&lt;/code&gt; 는 옵션 &lt;code&gt;h&lt;/code&gt; 를 &lt;code&gt;24&lt;/code&gt; 로 설정하지만 &lt;code&gt;-vxa&lt;/code&gt; 및 &lt;code&gt;-h24w80&lt;/code&gt; 과 같은 옵션 번들 은 오류로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7064702c1fdf6342dfeda7047d72edc982aef863" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;-vax&lt;/code&gt; will set the option &lt;code&gt;vax&lt;/code&gt; .</source>
          <target state="translated">이제 &lt;code&gt;-vax&lt;/code&gt; 는 &lt;code&gt;vax&lt;/code&gt; 옵션을 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="02476416df4a3a9b63bb6cb2d8be8955b7c384a2" translate="yes" xml:space="preserve">
          <source>Now, as to what you may want to do with these handlers: Maybe you'd want to log what key failed for what class, and then die. Maybe you don't like &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; and instead you want to send the error message to STDOUT (or wherever) and then merely &lt;code&gt;&lt;a href=&quot;../functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 핸들러로 무엇을하고 싶을까 : 어떤 클래스에서 어떤 키가 실패했는지 기록하고 죽을 수도 있습니다. 어쩌면 &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 를 좋아하지 않고 대신 STDOUT (또는 어디에나)에 오류 메시지를 보내고 나서 &lt;code&gt;&lt;a href=&quot;../functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 을 보내려고합니다 .</target>
        </trans-unit>
        <trans-unit id="dd735cb44e720407db2d25db6e1b3a8402f3fbeb" translate="yes" xml:space="preserve">
          <source>Now, because the top level contains only references, if you try to print out your array in with a simple print() function, you'll get something that doesn't look very nice, like this:</source>
          <target state="translated">이제 최상위 레벨에는 참조 만 포함되어 있으므로 간단한 print () 함수로 배열을 인쇄하려고하면 다음과 같이보기에 좋지 않은 것을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f590569b440fce72262993e0bb83b771d091b6a" translate="yes" xml:space="preserve">
          <source>Now, consider this:</source>
          <target state="translated">이제 이것을 고려하십시오 :</target>
        </trans-unit>
        <trans-unit id="0caa48ba5eb7d274e599b06285edb5dacdee51ca" translate="yes" xml:space="preserve">
          <source>Now, even &lt;code&gt;[0-9]&lt;/code&gt; can be a bother to write multiple times, so in the interest of saving keystrokes and making regexps more readable, Perl has several abbreviations for common character classes, as shown below. Since the introduction of Unicode, unless the &lt;code&gt;//a&lt;/code&gt; modifier is in effect, these character classes match more than just a few characters in the ASCII range.</source>
          <target state="translated">이제 &lt;code&gt;[0-9]&lt;/code&gt; 조차도 여러 번 쓰는 것이 귀찮을 수 있으므로 키 입력을 줄이고 정규 표현식을 더 읽기 쉽게 만들기 위해 Perl은 아래와 같이 일반적인 문자 클래스에 대한 몇 가지 약어를 사용합니다. 유니 코드가 도입 된 이후로 &lt;code&gt;//a&lt;/code&gt; 수정자가 적용 되지 않는 한 이러한 문자 클래스는 ASCII 범위의 몇 문자 이상과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="fd3c643f4f95c9c07182bc1371cc9ce99bbbace4" translate="yes" xml:space="preserve">
          <source>Now, if &lt;code&gt;junk&lt;/code&gt; is the same as the string we're trying to add, we can grab the string directly from the SV; &lt;code&gt;SvPVX&lt;/code&gt; is the address of the PV in the SV.</source>
          <target state="translated">지금, 만약 &lt;code&gt;junk&lt;/code&gt; 우리가 추가하려는 문자열과 동일, 우리는 SV에서 직접 문자열을 잡을 수있다; &lt;code&gt;SvPVX&lt;/code&gt; 는 SV에서 PV의 주소입니다.</target>
        </trans-unit>
        <trans-unit id="22a7c67c64c0df3c947439ef09bc7a1a5018552e" translate="yes" xml:space="preserve">
          <source>Now, imagine that we want to pack the data for a machine with a different byte-order. First, we'll have to figure out how big the data types on the target machine really are. Let's assume that the longs are 32 bits wide and the shorts are 16 bits wide. You can then rewrite the template as:</source>
          <target state="translated">이제 바이트 순서가 다른 머신의 데이터를 패킹한다고 가정합니다. 먼저, 대상 머신의 데이터 유형이 실제로 얼마나 큰지 알아 내야합니다. long의 길이가 32 비트이고 short의 길이가 16 비트라고 가정합니다. 그런 다음 템플릿을 다음과 같이 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4997e53db961cf2c8c2533b9ab14d20123173fb" translate="yes" xml:space="preserve">
          <source>Now, let's extend the previous example to return both the sum of the parameters and the difference.</source>
          <target state="translated">이제 이전 예제를 확장하여 매개 변수의 합계와 차이를 모두 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8f4d4098c9d3e30a9e536d0fed12c873a45201c2" translate="yes" xml:space="preserve">
          <source>Now, quite a few people have the Acme Transmogrifier, and you've had to write something to talk the protocol from scratch - you'd almost certainly want to make that into a module. The level at which you pitch it is up to you: you might want protocol-level modules analogous to &lt;a href=&quot;net/smtp&quot;&gt;Net::SMTP&lt;/a&gt; which then talk to higher level modules analogous to &lt;a href=&quot;http://search.cpan.org/perldoc/Mail::Send&quot;&gt;Mail::Send&lt;/a&gt;. The choice is yours, but you do want to get a module out for that server protocol.</source>
          <target state="translated">지금, 꽤 많은 사람들이 Acme Transmogrifier를 가지고 있으며, 프로토콜을 처음부터 다시 이야기 할 무언가를 작성해야했습니다. 거의 확실하게 모듈로 만들고 싶을 것입니다. 수준은되는 당신은 당신에게 달려 피치 : 당신이 유사한 프로토콜 수준의 모듈 할 수 있습니다 &lt;a href=&quot;net/smtp&quot;&gt;순 :: SMTP&lt;/a&gt; 다음과 유사한 높은 수준의 모듈 얘기 &lt;a href=&quot;http://search.cpan.org/perldoc/Mail::Send&quot;&gt;메일 :: 보내기&lt;/a&gt; . 선택은 당신의 것이지만, 당신은 그 서버 프로토콜에 대한 모듈을 꺼내고 싶어합니다.</target>
        </trans-unit>
        <trans-unit id="f84215108517a61b97d5bb763774a7b31e4947af" translate="yes" xml:space="preserve">
          <source>Now, right after you've just written the above lines, you'd normally have to go open the file ThisProject/I18N/en.pm, and immediately add an entry:</source>
          <target state="translated">이제 위의 줄을 작성한 직후에는 보통 ThisProject / I18N / en.pm 파일을 열고 즉시 항목을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="1401c823810e265e57226845c8cc3ee51b8e87e5" translate="yes" xml:space="preserve">
          <source>Now, running make will produce output that looks something like this (some long lines have been shortened for clarity and some extraneous lines have been deleted):</source>
          <target state="translated">이제 make를 실행하면 다음과 같은 출력이 생성됩니다 (명확성을 위해 일부 긴 줄이 짧아졌고 일부 불필요한 줄이 삭제되었습니다).</target>
        </trans-unit>
        <trans-unit id="6e07caa5beb0db9ce775e3579183bc779cf639f4" translate="yes" xml:space="preserve">
          <source>Now, say you want to search for the single character &lt;code&gt;/GX/&lt;/code&gt; . Perl doesn't know about Martian, so it'll find the two bytes &quot;GX&quot; in the &quot;I am CVSGXX!&quot; string, even though that character isn't there: it just looks like it is because &quot;SG&quot; is next to &quot;XX&quot;, but there's no real &quot;GX&quot;. This is a big problem.</source>
          <target state="translated">이제 단일 문자 &lt;code&gt;/GX/&lt;/code&gt; 를 검색한다고 가정 하겠습니다 . Perl은 화성에 대해 알지 못하므로 &quot;I CVSGXX입니다!&quot;에서 2 바이트 &quot;GX&quot;를 찾을 수 있습니다. 문자열은 해당 문자가 없더라도 &quot;SG&quot;가 &quot;XX&quot;옆에 있기 때문에 실제 &quot;GX&quot;가 없기 때문입니다. 이것은 큰 문제입니다.</target>
        </trans-unit>
        <trans-unit id="8bf6d464fd8f7b3ee530f1f0a89b5dfa201b3c0c" translate="yes" xml:space="preserve">
          <source>Now, suppose you want to use perlio layers in your XS. We'll use the perlio &lt;code&gt;PerlIO_puts()&lt;/code&gt; function as an example.</source>
          <target state="translated">이제 XS에서 perlio 레이어를 사용한다고 가정합니다. perlio &lt;code&gt;PerlIO_puts()&lt;/code&gt; 함수를 예로 사용하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="8e40eda745c5999056a9033823cfa2202510fb44" translate="yes" xml:space="preserve">
          <source>Now, that's our data parsed. I suppose what we might want to do now is total up our income and expenditure, and add another line to the end of our ledger - in the same format - saying how much we've brought in and how much we've spent:</source>
          <target state="translated">이제 우리의 데이터가 파싱되었습니다. 우리가 지금하고 싶은 것은 수입과 지출을 모두 합한 것으로, 원장 끝에 또 다른 줄을 같은 형식으로 추가하여 수입 한 금액과 지출 한 금액을 말합니다.</target>
        </trans-unit>
        <trans-unit id="fcbc9f96a1673b30ff5469c8a5fcf6cbd912ecbd" translate="yes" xml:space="preserve">
          <source>Now, the following calls to your function are all completely equivalent:</source>
          <target state="translated">이제 함수에 대한 다음 호출은 모두 완전히 동일합니다.</target>
        </trans-unit>
        <trans-unit id="54e7adec8d59750fec2768d3623709e37ef7d868" translate="yes" xml:space="preserve">
          <source>Now, using &lt;code&gt;--verbose&lt;/code&gt; on the command line will enable &lt;code&gt;$verbose&lt;/code&gt; , as expected. But it is also allowed to use &lt;code&gt;--noverbose&lt;/code&gt; , which will disable &lt;code&gt;$verbose&lt;/code&gt; by setting its value to &lt;code&gt;0&lt;/code&gt; . Using a suitable default value, the program can find out whether &lt;code&gt;$verbose&lt;/code&gt; is false by default, or disabled by using &lt;code&gt;--noverbose&lt;/code&gt; .</source>
          <target state="translated">이제 명령 행에서 &lt;code&gt;--verbose&lt;/code&gt; 를 사용 하면 예상대로 &lt;code&gt;$verbose&lt;/code&gt; 가 활성화 됩니다. 그러나 &lt;code&gt;--noverbose&lt;/code&gt; 를 사용할 수도 있습니다 . 이 값은 값을 &lt;code&gt;0&lt;/code&gt; 으로 설정하여 &lt;code&gt;$verbose&lt;/code&gt; 를 비활성화 합니다. 프로그램은 적절한 기본값을 사용하여 &lt;code&gt;$verbose&lt;/code&gt; 가 기본적으로 false 인지 또는 &lt;code&gt;--noverbose&lt;/code&gt; 를 사용하여 비활성화 되었는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="992feec99ff4aecbf2aadccfe96942e35ec305c6" translate="yes" xml:space="preserve">
          <source>Now, we know that in scalar context, &lt;code&gt;$time =~ /(\d\d):(\d\d):(\d\d)/&lt;/code&gt; returns a true or false value. In list context, however, it returns the list of matched values &lt;code&gt;($1,$2,$3)&lt;/code&gt; . So we could write the code more compactly as</source>
          <target state="translated">이제 우리는 스칼라 문맥에서 &lt;code&gt;$time =~ /(\d\d):(\d\d):(\d\d)/&lt;/code&gt; 가 true 또는 false 값을 반환 한다는 것을 알고 있습니다. 그러나 목록 컨텍스트에서는 일치하는 값 목록 &lt;code&gt;($1,$2,$3)&lt;/code&gt; 반환합니다 . 따라서 코드를보다 간결하게 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4be0b7f8c6b8fc26bdc74884bb876598542c7964" translate="yes" xml:space="preserve">
          <source>Now, what if you don't want to capitalize that &quot;and&quot;? Just use &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Autoformat&quot;&gt;Text::Autoformat&lt;/a&gt; and get on with the next problem. :)</source>
          <target state="translated">이제 &quot;and&quot;를 대문자로 사용하지 않으려면 어떻게해야합니까? 그냥 사용 &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Autoformat&quot;&gt;텍스트 : 자동 서식&lt;/a&gt; 및 다음 문제에 얻을. :)</target>
        </trans-unit>
        <trans-unit id="8949eed359cb576e341a415acaa483f999c583a5" translate="yes" xml:space="preserve">
          <source>Now, what we've done here is to launch the built-in perl debugger on our script. It's stopped at the first line of executable code and is waiting for input.</source>
          <target state="translated">이제 우리가 한 일은 스크립트에서 내장 펄 디버거를 시작하는 것입니다. 실행 코드의 첫 번째 줄에서 중지되었으며 입력을 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe56adc9244a6c6d673f2a408e82ab0b02f6ba4d" translate="yes" xml:space="preserve">
          <source>Now, what's this about?</source>
          <target state="translated">자, 이것에 대해 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="c09652f2cdfd968ba019444826ddffee8c37ace4" translate="yes" xml:space="preserve">
          <source>Null AV pointer.</source>
          <target state="translated">널 AV 포인터.</target>
        </trans-unit>
        <trans-unit id="449c4d119d699360473af11bb566b4e5b4167f76" translate="yes" xml:space="preserve">
          <source>Null CV pointer.</source>
          <target state="translated">널 CV 포인터.</target>
        </trans-unit>
        <trans-unit id="91a48ce7cb8839ea533848a64134cf5805e52ca4" translate="yes" xml:space="preserve">
          <source>Null HV pointer.</source>
          <target state="translated">널 HV 포인터.</target>
        </trans-unit>
        <trans-unit id="d7c8d520f057dea587bf4d58fd9c051240f622ed" translate="yes" xml:space="preserve">
          <source>Null SV pointer. (No longer available when &lt;code&gt;PERL_CORE&lt;/code&gt; is defined.)</source>
          <target state="translated">널 SV 포인터. &lt;code&gt;PERL_CORE&lt;/code&gt; 가 정의 되면 더 이상 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="ae2f5f2d47b6cb2ea376cf5cd766fe09fd6a57af" translate="yes" xml:space="preserve">
          <source>Null character pointer. (No longer available when &lt;code&gt;PERL_CORE&lt;/code&gt; is defined.)</source>
          <target state="translated">널 문자 포인터. &lt;code&gt;PERL_CORE&lt;/code&gt; 가 정의 되면 더 이상 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="38b0ef271640da14cdf67cd20db21125619c6b53" translate="yes" xml:space="preserve">
          <source>Nullops appear as &lt;code&gt;ex-opname&lt;/code&gt; , where</source>
          <target state="translated">Nullops는 &lt;code&gt;ex-opname&lt;/code&gt; 으로 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="c9d82135ee15642aa7ae8817dc570334ab80622b" translate="yes" xml:space="preserve">
          <source>Number of iterations run.</source>
          <target state="translated">반복 횟수</target>
        </trans-unit>
        <trans-unit id="78e655a3cb9b2e5174023b5b4b515e74ae0fcc89" translate="yes" xml:space="preserve">
          <source>Number of lines to save?</source>
          <target state="translated">저장할 줄 수?</target>
        </trans-unit>
        <trans-unit id="3230c13d5bd80dac7aacde117d72a74866ed2d4e" translate="yes" xml:space="preserve">
          <source>Number of significant digits. Leading zeros are not counted. A number may have an accuracy greater than the non-zero digits when there are zeros in it or trailing zeros. For example, 123.456 has A of 6, 10203 has 5, 123.0506 has 7, 123.450000 has 8 and 0.000123 has 3.</source>
          <target state="translated">유효 자릿수 선행 0은 계산되지 않습니다. 숫자가 0이거나 뒤에 0이 있으면 숫자가 0이 아닌 숫자보다 큰 정확도를 가질 수 있습니다. 예를 들어, 123.456의 A는 6, 10203의 5, 123.0506의 7, 123.450000의 8, 0.000123의 3입니다.</target>
        </trans-unit>
        <trans-unit id="6588ae11e1dcdc853623ae99d37042a891fc6f6e" translate="yes" xml:space="preserve">
          <source>Number-of-uses is stored as a 16-bit unsigned integer, so can't exceed 65535.</source>
          <target state="translated">사용 횟수는 16 비트 부호없는 정수로 저장되므로 65535를 초과 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="86074e1eaaba5bdf1182fbfd1a5e5a087cf06d78" translate="yes" xml:space="preserve">
          <source>Numbered capture callbacks</source>
          <target state="translated">번호가 매겨진 캡처 콜백</target>
        </trans-unit>
        <trans-unit id="7a23d9255bf80cf55daa9a73c5c3503075a5fb9f" translate="yes" xml:space="preserve">
          <source>Numbers don't need quotes around them:</source>
          <target state="translated">숫자는 주위에 따옴표가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="93fc21b9cdd7d3eceb58c305ecfc300113f08a16" translate="yes" xml:space="preserve">
          <source>Numbers endianness and Width</source>
          <target state="translated">엔디안과 너비</target>
        </trans-unit>
        <trans-unit id="a356a38fbf19c9a7a85fc1034cb6b13b5959c015" translate="yes" xml:space="preserve">
          <source>Numbers in (parentheses) indicate the total number of Unicode code points matched by the property. For emphasis, those properties that match no code points at all are listed as well in a separate section following the table.</source>
          <target state="translated">숫자 (괄호)는 속성과 일치하는 총 유니 코드 코드 포인트 수를 나타냅니다. 강조하기 위해 코드 포인트와 전혀 일치하지 않는 속성은 표 다음에 별도 섹션에 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="56e0145e1d23363006c456eb88791d281e2a1493" translate="yes" xml:space="preserve">
          <source>Numbers in the range 160-255 refer to Latin-1 characters (also defined there by Unicode, with the same meaning). Numbers above 255 should be understood to refer to Unicode characters.</source>
          <target state="translated">160-255 범위의 숫자는 라틴 -1 문자를 나타냅니다 (유일한 의미로 유니 코드로 정의 됨). 255보다 큰 숫자는 유니 코드 문자를 나타내는 것으로 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="bdfe233d649ccb45ebc573d4ee247d96a2053e8c" translate="yes" xml:space="preserve">
          <source>Numeric Fields</source>
          <target state="translated">숫자 필드</target>
        </trans-unit>
        <trans-unit id="6101250ca1afcc59baf36ca28be6209c3291e540" translate="yes" xml:space="preserve">
          <source>Numeric conversion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="231f4ec720e19f9416599261f4322593a7b1d213" translate="yes" xml:space="preserve">
          <source>Numeric functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="684a5952f400383c4099f6088a711c758da11a61" translate="yes" xml:space="preserve">
          <source>Numeric literals are specified in any of the following floating point or integer formats:</source>
          <target state="translated">숫자 리터럴은 다음 부동 소수점 또는 정수 형식으로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="a4e50290598ea70f1c5580bbcbcb1b35364e36b2" translate="yes" xml:space="preserve">
          <source>Numeric operators and numeric conversions</source>
          <target state="translated">숫자 연산자 및 숫자 변환</target>
        </trans-unit>
        <trans-unit id="0524b0c0ac8bde27b90181fe29d1e0ee87d85606" translate="yes" xml:space="preserve">
          <source>Numification</source>
          <target state="translated">Numification</target>
        </trans-unit>
        <trans-unit id="9070f7ffe825f6632ea9c8c8c4cb452e5ea710fb" translate="yes" xml:space="preserve">
          <source>Numify returns the number of bytes in the instance data.</source>
          <target state="translated">Numify는 인스턴스 데이터의 바이트 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="08a914cde05039694ef0194d9ee79ff9a79dde33" translate="yes" xml:space="preserve">
          <source>O</source>
          <target state="translated">O</target>
        </trans-unit>
        <trans-unit id="54d43a5ef4e27b9c279536a9f91a0f278f1c11b7" translate="yes" xml:space="preserve">
          <source>O - Generic interface to Perl Compiler backends</source>
          <target state="translated">O-Perl Compiler 백엔드에 대한 일반 인터페이스</target>
        </trans-unit>
        <trans-unit id="2f1e5004dfcf9dde92d5fd30ce523548742521cc" translate="yes" xml:space="preserve">
          <source>OBJ</source>
          <target state="translated">OBJ</target>
        </trans-unit>
        <trans-unit id="886bca430376624f1fa6be07dffa149e06727c43" translate="yes" xml:space="preserve">
          <source>OBJECT METHODS</source>
          <target state="translated">목표 방법</target>
        </trans-unit>
        <trans-unit id="3d6faefbb52c9934839e9dcd31987ac3958fd8ae" translate="yes" xml:space="preserve">
          <source>OBJECT-ORIENTED FUNDAMENTALS</source>
          <target state="translated">목표 지향적 인 기초</target>
        </trans-unit>
        <trans-unit id="edf9874a257ef8b1a94138e136d570010b98cb88" translate="yes" xml:space="preserve">
          <source>OBJECT-ORIENTED INTERFACE</source>
          <target state="translated">객체 지향 인터페이스</target>
        </trans-unit>
        <trans-unit id="83ccf14b6fc5001c270b87a25f6dbd0dd2dbdb90" translate="yes" xml:space="preserve">
          <source>OBJECTS</source>
          <target state="translated">OBJECTS</target>
        </trans-unit>
        <trans-unit id="74d964f379ca5f7a63963447b2e66da24098ac03" translate="yes" xml:space="preserve">
          <source>OCTETS</source>
          <target state="translated">OCTETS</target>
        </trans-unit>
        <trans-unit id="20e099ce66f09623331e4f7ac57998439d896891" translate="yes" xml:space="preserve">
          <source>OK (say, this system-dependent module builds in a subdirectory of some other distribution, or is listed as a dependency in a CPAN::Bundle, but the functionality is supported by different means on the current architecture).</source>
          <target state="translated">OK (즉,이 시스템 종속 모듈은 다른 배포판의 하위 디렉토리에 빌드되거나 CPAN :: Bundle에 종속 항목으로 표시되지만 기능은 현재 아키텍처에서 다른 방법으로 지원됩니다).</target>
        </trans-unit>
        <trans-unit id="01ac8af6582beb05b51e97a2306cc05bed91ec81" translate="yes" xml:space="preserve">
          <source>OK, as opposed to</source>
          <target state="translated">OK와 반대로</target>
        </trans-unit>
        <trans-unit id="42c8e2f5d8fdbf542c870810fe22e5463fc2fa22" translate="yes" xml:space="preserve">
          <source>OK, it's a start, but what happened to the spaces? We put &lt;code&gt;x&lt;/code&gt; , didn't we? Shouldn't it skip forward? Let's look at what &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; says:</source>
          <target state="translated">좋아, 시작이야.하지만 우주는 어떻게 된거 야? 우리는 &lt;code&gt;x&lt;/code&gt; 를 넣지 않습니까? 앞으로 건너 뛰지 않아야합니까? &lt;a href=&quot;functions/pack&quot;&gt;팩&lt;/a&gt; 의 내용을 살펴 보자 .</target>
        </trans-unit>
        <trans-unit id="2244411f280d2b7d311acac7ca58215079a5a39f" translate="yes" xml:space="preserve">
          <source>OK, let's have a look at some of our data again; in fact, we'll include the headers, and a handy ruler so we can keep track of where we are.</source>
          <target state="translated">자, 우리의 데이터 중 일부를 다시 살펴 봅시다. 실제로 헤더와 편리한 눈금자를 포함하여 현재 위치를 추적 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02b9f4d433d48fd34c45be1068128628f753ca51" translate="yes" xml:space="preserve">
          <source>OK, so let's bite the bullet. Here's one way to get the alignment right by inserting template codes &lt;code&gt;x&lt;/code&gt; , which don't take a corresponding item from the list:</source>
          <target state="translated">좋아, 총알을 물자 템플릿 코드 &lt;code&gt;x&lt;/code&gt; 를 삽입하여 올바른 정렬을 얻는 한 가지 방법은 다음과 같습니다 .리스트에서 해당 항목을 가져 오지 않습니다.</target>
        </trans-unit>
        <trans-unit id="55cced79fbf573273c9277ae4c911cbf530c88fb" translate="yes" xml:space="preserve">
          <source>OK, the last one was actually an Obfuscated Perl Contest entry. :-)</source>
          <target state="translated">마지막은 실제로 난독 화 된 펄 콘테스트 출품작입니다. :-)</target>
        </trans-unit>
        <trans-unit id="57ecc84fea778a647ea6d7f2310ef9bca45201e0" translate="yes" xml:space="preserve">
          <source>OK, what's next? Between the date and the description is a blank column; we want to skip over that. The &lt;code&gt;x&lt;/code&gt; template means &quot;skip forward&quot;, so we want one of those. Next, we have another batch of characters, from 12 to 38. That's 27 more characters, hence &lt;code&gt;A27&lt;/code&gt; . (Don't make the fencepost error - there are 27 characters between 12 and 38, not 26. Count 'em!)</source>
          <target state="translated">다음은 무엇입니까? 날짜와 설명 사이에는 빈 열이 있습니다. 우리는 그것을 건너 뛰고 싶습니다. &lt;code&gt;x&lt;/code&gt; 우리가 그 중 하나를 할 수 있도록 템플릿 수단은, &quot;앞으로 건너 뛰기&quot;. 다음으로, 12에서 38 사이의 다른 문자 배치가 있습니다. 27 자 이상이므로 &lt;code&gt;A27&lt;/code&gt; 입니다. (펜스 포스트 오류를 ​​만들지 마십시오-26이 아닌 12와 38 사이에 27 문자가 있습니다. Count 'em!)</target>
        </trans-unit>
        <trans-unit id="8f26553401469ee2b31b15d3391338fc7e46d2bc" translate="yes" xml:space="preserve">
          <source>OK, you know the basics of regexps and you want to know more. If matching regular expressions is analogous to a walk in the woods, then the tools discussed in Part 1 are analogous to topo maps and a compass, basic tools we use all the time. Most of the tools in part 2 are analogous to flare guns and satellite phones. They aren't used too often on a hike, but when we are stuck, they can be invaluable.</source>
          <target state="translated">좋아, 정규 표현식의 기본 사항을 알고 더 알고 싶습니다. 정규식과 일치하는 것이 숲 속을 걷는 것과 유사하다면, Part 1에서 논의 된 도구는 우리가 항상 사용하는 topo map과 나침반, 기본 도구와 유사합니다. 파트 2에있는 대부분의 도구는 플레어 건 및 위성 전화기와 유사합니다. 그들은 하이킹에 너무 자주 사용되지 않지만, 우리가 붙어있을 때, 그들은 귀중 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2171105911206b856b529e816e5973ea3d92c2e5" translate="yes" xml:space="preserve">
          <source>OK. That's the C part done. Now we must do two additional things before this patch is ready to go: we've changed the behaviour of Perl, and so we must document that change. We must also provide some more regression tests to make sure our patch works and doesn't create a bug somewhere else along the line.</source>
          <target state="translated">확인. 이것이 C 부분입니다. 이제이 패치를 적용하기 전에 두 가지 추가 작업을 수행해야합니다. Perl의 동작을 변경 했으므로 해당 변경 사항을 문서화해야합니다. 또한 패치가 작동하고 라인 어딘가에 버그를 생성하지 않도록 회귀 테스트를 더 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="52e443591494f06d89603d027dbcc15ec5f21ac5" translate="yes" xml:space="preserve">
          <source>OLD BUILD INSTRUCTIONS</source>
          <target state="translated">오래된 건물 지침</target>
        </trans-unit>
        <trans-unit id="1b8244806f0fe85fbdfb28350aa4197cefa6d7d6" translate="yes" xml:space="preserve">
          <source>OLD PERL VERSIONS</source>
          <target state="translated">이전 펄 버전</target>
        </trans-unit>
        <trans-unit id="b25c8ed636326794258081a0a80bab33a84b2f10" translate="yes" xml:space="preserve">
          <source>ONE STEP FORWARD</source>
          <target state="translated">한 단계 앞으로</target>
        </trans-unit>
        <trans-unit id="3265add34ef90b3d5d5f9d59898e2a3656834e0f" translate="yes" xml:space="preserve">
          <source>ONE STEP SIDEWAYS</source>
          <target state="translated">한 단계 옆으로</target>
        </trans-unit>
        <trans-unit id="3b12b54c6a3deda565624403d547e7ef70be9c7d" translate="yes" xml:space="preserve">
          <source>ONFAIL</source>
          <target state="translated">ONFAIL</target>
        </trans-unit>
        <trans-unit id="b144599df5b9973435563870d7ba296904ec1710" translate="yes" xml:space="preserve">
          <source>ONLY</source>
          <target state="translated">ONLY</target>
        </trans-unit>
        <trans-unit id="e3c4c3d0eba1879f6f92c682389bed6ffbf94f06" translate="yes" xml:space="preserve">
          <source>OO INTERFACE</source>
          <target state="translated">OO 인터페이스</target>
        </trans-unit>
        <trans-unit id="1433bf1bd15078b056fe76d6547c4bb2a283c920" translate="yes" xml:space="preserve">
          <source>OO Interface</source>
          <target state="translated">OO 인터페이스</target>
        </trans-unit>
        <trans-unit id="e9a2811eef61d81b9e5a20155aec53e34b502e28" translate="yes" xml:space="preserve">
          <source>OO Perl</source>
          <target state="translated">OO 펄</target>
        </trans-unit>
        <trans-unit id="3615e232deb829e0d1569b8035de6913840b260b" translate="yes" xml:space="preserve">
          <source>OO Perl is relatively simple and is implemented using references which know what sort of object they are based on Perl's concept of packages. However, OO Perl is largely beyond the scope of this document. Read &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; and &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="translated">OO Perl은 비교적 단순하며 Perl의 패키지 개념에 기반한 객체를 알고있는 참조를 사용하여 구현됩니다. 그러나 OO Perl은이 문서에서 다루지 않습니다. &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; 및 &lt;a href=&quot;perlobj&quot;&gt;perlobj를&lt;/a&gt; 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="2141f42c40de947ddd0e477a1e88d39467ae8b5d" translate="yes" xml:space="preserve">
          <source>OO System Summary</source>
          <target state="translated">OO 시스템 요약</target>
        </trans-unit>
        <trans-unit id="e22cbd43f54a4419ac3832ce3ab610e1f892e4aa" translate="yes" xml:space="preserve">
          <source>OO interface to the select system call</source>
          <target state="translated">선택 시스템 호출에 대한 OO 인터페이스</target>
        </trans-unit>
        <trans-unit id="50841444197610a772ed0bf8061ebbec3fb69d4e" translate="yes" xml:space="preserve">
          <source>OO interface to users netrc file</source>
          <target state="translated">사용자 netrc 파일에 대한 OO 인터페이스</target>
        </trans-unit>
        <trans-unit id="e5646c2e78bf00bf2def681a7c47f39c5c233aee" translate="yes" xml:space="preserve">
          <source>OOP style</source>
          <target state="translated">OOP 스타일</target>
        </trans-unit>
        <trans-unit id="01de497f472a97643f711e0af439f57cbf98b7cc" translate="yes" xml:space="preserve">
          <source>OP TREES</source>
          <target state="translated">OP 트리</target>
        </trans-unit>
        <trans-unit id="d97b094405ac341f25845d574d3003452633970d" translate="yes" xml:space="preserve">
          <source>OP class abbreviations</source>
          <target state="translated">OP 클래스 약어</target>
        </trans-unit>
        <trans-unit id="e5a964607f5e2d840aa946796053a87561ef64ff" translate="yes" xml:space="preserve">
          <source>OP flags abbreviations</source>
          <target state="translated">OP 플래그 약어</target>
        </trans-unit>
        <trans-unit id="c0c894eca9e57589b7dd798f6fc13ef59d8fced2" translate="yes" xml:space="preserve">
          <source>OP flags are either public or private. The public flags alter the behavior of each opcode in consistent ways, and are represented by 0 or more single characters.</source>
          <target state="translated">OP 플래그는 공개 또는 비공개입니다. 공개 플래그는 각 opcode의 동작을 일관된 방식으로 변경하며 0 개 이상의 단일 문자로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="4bddb20f13d7f760a35db0afa01405e65b1c65f3" translate="yes" xml:space="preserve">
          <source>OP-RELATED CLASSES</source>
          <target state="translated">관련 클래스</target>
        </trans-unit>
        <trans-unit id="9931dad0f7eb6ff4da51ab9c192c2a065a7d0255" translate="yes" xml:space="preserve">
          <source>OPERATION is one of LOCK_SH, LOCK_EX, or LOCK_UN, possibly combined with LOCK_NB. These constants are traditionally valued 1, 2, 8 and 4, but you can use the symbolic names if you import them from the &lt;a href=&quot;../fcntl&quot;&gt;Fcntl&lt;/a&gt; module, either individually, or as a group using the &lt;code&gt;:&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; tag. LOCK_SH requests a shared lock, LOCK_EX requests an exclusive lock, and LOCK_UN releases a previously requested lock. If LOCK_NB is bitwise-or'ed with LOCK_SH or LOCK_EX, then &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; returns immediately rather than blocking waiting for the lock; check the return status to see if you got it.</source>
          <target state="translated">OPERATION은 LOCK_SH, LOCK_EX 또는 LOCK_UN 중 하나이며 LOCK_NB와 결합 될 수 있습니다. 이러한 상수는 일반적으로 1, 2, 8 및 4의 값이지만 &lt;a href=&quot;../fcntl&quot;&gt;Fcntl&lt;/a&gt; 모듈에서 개별적으로 또는 &lt;code&gt;:&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 태그를 사용하여 그룹으로 가져올 경우 기호 이름을 사용할 수 있습니다 . LOCK_SH는 공유 잠금을 요청하고 LOCK_EX는 독점 잠금을 요청하며 LOCK_UN은 이전에 요청 된 잠금을 해제합니다. LOCK_NB에 LOCK_SH 또는 LOCK_EX를 사용하여 비트 단위 또는 비트 를 사용하면 잠금 대기를 차단하지 않고 &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 이 즉시 반환합니다. 반품 상태를 확인하여 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="5806c98abb4bc38de2885393f139558efaa4744b" translate="yes" xml:space="preserve">
          <source>OPERATION is one of LOCK_SH, LOCK_EX, or LOCK_UN, possibly combined with LOCK_NB. These constants are traditionally valued 1, 2, 8 and 4, but you can use the symbolic names if you import them from the &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; module, either individually, or as a group using the &lt;code&gt;:&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; tag. LOCK_SH requests a shared lock, LOCK_EX requests an exclusive lock, and LOCK_UN releases a previously requested lock. If LOCK_NB is bitwise-or'ed with LOCK_SH or LOCK_EX, then &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; returns immediately rather than blocking waiting for the lock; check the return status to see if you got it.</source>
          <target state="translated">OPERATION은 LOCK_SH, LOCK_EX 또는 LOCK_UN 중 하나이며 LOCK_NB와 결합 될 수 있습니다. 이러한 상수는 일반적으로 1, 2, 8 및 4의 값이지만 &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; 모듈에서 개별적으로 또는 &lt;code&gt;:&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 태그를 사용하여 그룹으로 가져올 경우 기호 이름을 사용할 수 있습니다 . LOCK_SH는 공유 잠금을 요청하고 LOCK_EX는 독점 잠금을 요청하며 LOCK_UN은 이전에 요청 된 잠금을 해제합니다. LOCK_NB에 LOCK_SH 또는 LOCK_EX를 사용하여 비트 단위 또는 비트 를 사용하면 잠금 대기를 차단하지 않고 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 이 즉시 반환합니다. 반품 상태를 확인하여 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="277a5e5c068658adb7eeea0e8ac338b111cfff2f" translate="yes" xml:space="preserve">
          <source>OPERATIONS</source>
          <target state="translated">OPERATIONS</target>
        </trans-unit>
        <trans-unit id="ae6eaba46b51b460ad70f762d13737864d558ddb" translate="yes" xml:space="preserve">
          <source>OPERATOR DIFFERENCES</source>
          <target state="translated">운영자 차이</target>
        </trans-unit>
        <trans-unit id="3b9833465b980fc8907d152fbd1be4ed82789a85" translate="yes" xml:space="preserve">
          <source>OPERATORS</source>
          <target state="translated">OPERATORS</target>
        </trans-unit>
        <trans-unit id="2d0b2762a37fa9b498b0ef0041758a02e1b217bd" translate="yes" xml:space="preserve">
          <source>OPTIONAL SUBROUTINE/METHOD OVERRIDES</source>
          <target state="translated">선택적 술병 / 방법 오버라이드</target>
        </trans-unit>
        <trans-unit id="3c86eca6569badf198a635b289a628e0713ed7b0" translate="yes" xml:space="preserve">
          <source>OPTIONAL-INFO</source>
          <target state="translated">OPTIONAL-INFO</target>
        </trans-unit>
        <trans-unit id="39dd320e8c4e9f06b35e0be0b4942ac2022fb9c1" translate="yes" xml:space="preserve">
          <source>OPTIONS</source>
          <target state="translated">OPTIONS</target>
        </trans-unit>
        <trans-unit id="cfee3b3e47c3ccac4481ec3d455bf43de1a65fd1" translate="yes" xml:space="preserve">
          <source>OPTIONS AND ARGUMENTS</source>
          <target state="translated">옵션과 인수</target>
        </trans-unit>
        <trans-unit id="6409ae0433181a6f096278e81922ef91fcf094d5" translate="yes" xml:space="preserve">
          <source>OPTIONS/ARGUMENTS</source>
          <target state="translated">OPTIONS/ARGUMENTS</target>
        </trans-unit>
        <trans-unit id="d02651d637b66f91c995f98ff893920c6613a814" translate="yes" xml:space="preserve">
          <source>OPTS consists of any of the options that are available when creating the &lt;code&gt;$z&lt;/code&gt; object.</source>
          <target state="translated">OPTS는 &lt;code&gt;$z&lt;/code&gt; 객체를 만들 때 사용할 수있는 옵션으로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="34e983dffbba74010d0b834918e8b9de427ff5bf" translate="yes" xml:space="preserve">
          <source>OPTS is a combination of the following options:</source>
          <target state="translated">OPTS는 다음 옵션의 조합입니다.</target>
        </trans-unit>
        <trans-unit id="6b6a53f5c91030f120c92b395563cf165ba2b731" translate="yes" xml:space="preserve">
          <source>ORcpt is also part of the SMTP DSN extension according to RFC3461. It is used to pass along the original recipient that the mail was first sent to. The machine that generates a DSN will use this address to inform the sender, because he can't know if recipients get rewritten by mail servers. It is expected to be in a format as required by RFC3461, xtext-encoded.</source>
          <target state="translated">ORcpt는 RFC3461에 따른 SMTP DSN 확장의 일부이기도합니다. 메일을 처음 보낸 원래 수신자에게 전달하는 데 사용됩니다. DSN을 생성하는 시스템은이 주소를 사용하여 발신인에게 알립니다. 수신자가 메일 서버로 다시 작성되는지 알 수 없기 때문입니다. xtext 인코딩 된 RFC3461에 필요한 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="3e55c8accb9b59a4e2e3860b73d18e283bd63d08" translate="yes" xml:space="preserve">
          <source>OS ISSUES</source>
          <target state="translated">OS 문제</target>
        </trans-unit>
        <trans-unit id="ca7db916096936ab02b469184b00a31ffb7e99f9" translate="yes" xml:space="preserve">
          <source>OS adjusted ExtUtils::MakeMaker subclass</source>
          <target state="translated">OS 조정 ExtUtils :: MakeMaker 서브 클래스</target>
        </trans-unit>
        <trans-unit id="a507b0570eef10c513490b530ff7cffb662e9519" translate="yes" xml:space="preserve">
          <source>OS level</source>
          <target state="translated">OS 레벨</target>
        </trans-unit>
        <trans-unit id="53b5eb00477f53acb0522cf8349b912973394461" translate="yes" xml:space="preserve">
          <source>OS-Related References</source>
          <target state="translated">OS 관련 참조</target>
        </trans-unit>
        <trans-unit id="49f5479219ce3d4b44c672d19081b527acbff3f8" translate="yes" xml:space="preserve">
          <source>OS/2</source>
          <target state="translated">OS/2</target>
        </trans-unit>
        <trans-unit id="c2ee378ae6f39b56008cc84e4ccbbff11e3e4428" translate="yes" xml:space="preserve">
          <source>OS/2 _.INF_ file</source>
          <target state="translated">OS / 2 _.INF_ 파일</target>
        </trans-unit>
        <trans-unit id="8170ede7c45b17e28c246c077e40c6bb259a2169" translate="yes" xml:space="preserve">
          <source>OS/2 is OS/2</source>
          <target state="translated">OS / 2는 OS / 2입니다</target>
        </trans-unit>
        <trans-unit id="9f2b9449bdc8f69e4d1ebfaee7720b50c48e466a" translate="yes" xml:space="preserve">
          <source>OS/2 toolkit</source>
          <target state="translated">OS / 2 툴킷</target>
        </trans-unit>
        <trans-unit id="1adfaba1d7ff8cc9090d93cbfe1b050db4768533" translate="yes" xml:space="preserve">
          <source>OS/390 will support the &lt;code&gt;#!&lt;/code&gt; shebang trick in release 2.8 and beyond. Calls to &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; and backticks can use POSIX shell syntax on all S/390 systems.</source>
          <target state="translated">OS / 390은 &lt;code&gt;#!&lt;/code&gt; 릴리스 2.8 이상의 Shebang 트릭. &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 및 백틱에 대한 호출 은 모든 S / 390 시스템에서 POSIX 쉘 구문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d34b2e0115c599698c2eaf50db89fcc832b02bf" translate="yes" xml:space="preserve">
          <source>OS/390, z/OS</source>
          <target state="translated">OS / 390, z / OS</target>
        </trans-unit>
        <trans-unit id="0a302d149142b54ba805c25c7803eba208bb0727" translate="yes" xml:space="preserve">
          <source>OS/400</source>
          <target state="translated">OS/400</target>
        </trans-unit>
        <trans-unit id="7ffcc4aa191d7c21c744cd8b5d4c95af4f197345" translate="yes" xml:space="preserve">
          <source>OSPEED</source>
          <target state="translated">OSPEED</target>
        </trans-unit>
        <trans-unit id="957c024b38ce820878f03177ce3d2b83c26a82d0" translate="yes" xml:space="preserve">
          <source>OTHER</source>
          <target state="translated">OTHER</target>
        </trans-unit>
        <trans-unit id="5d6ab2bf42c29199bc2595a18bf166b2ca9d58db" translate="yes" xml:space="preserve">
          <source>OTHER COMPONENTS</source>
          <target state="translated">다른 구성 요소</target>
        </trans-unit>
        <trans-unit id="f6c2b40e6c72a2bb0b41071005914975b421d2b3" translate="yes" xml:space="preserve">
          <source>OTHER FACILITIES</source>
          <target state="translated">다른 시설</target>
        </trans-unit>
        <trans-unit id="b9ed1fc6bda9c1de960a484858190276f8547802" translate="yes" xml:space="preserve">
          <source>OTHER FUNCTIONS</source>
          <target state="translated">다른 기능들</target>
        </trans-unit>
        <trans-unit id="cf1596fa6b124742caf502c819fa40b64395f706" translate="yes" xml:space="preserve">
          <source>OUTPUT TIPS</source>
          <target state="translated">출력 팁</target>
        </trans-unit>
        <trans-unit id="a32824f28f79811519a5acdabe1d4b373c40ef62" translate="yes" xml:space="preserve">
          <source>OVERRIDDEN METHODS</source>
          <target state="translated">과장된 방법</target>
        </trans-unit>
        <trans-unit id="bf6107f87a0ec04cb2b618d76df7646acae50937" translate="yes" xml:space="preserve">
          <source>OVERRIDES</source>
          <target state="translated">OVERRIDES</target>
        </trans-unit>
        <trans-unit id="be5d4c45f4cd36cced53ba6c4c1d80a8493a95f3" translate="yes" xml:space="preserve">
          <source>OVERRIDING CORE FUNCTIONS</source>
          <target state="translated">대체 핵심 기능</target>
        </trans-unit>
        <trans-unit id="f275fdb83760cf7f81c0389520bf2b7351b38004" translate="yes" xml:space="preserve">
          <source>OVERVIEW</source>
          <target state="translated">OVERVIEW</target>
        </trans-unit>
        <trans-unit id="fe6d13a6636d2e856ee66d1e674b0c568eee0ba0" translate="yes" xml:space="preserve">
          <source>OVERVIEW OF CLASSES</source>
          <target state="translated">수업 개요</target>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="f0e2a5cc2614159a14f8d24f77aff8cedbb91395" translate="yes" xml:space="preserve">
          <source>Object Methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a403b426b3138de1314edbedb502e24fe00906c" translate="yes" xml:space="preserve">
          <source>Object Orientation is not the best solution to every problem. In</source>
          <target state="translated">객체 지향이 모든 문제에 대한 최상의 솔루션은 아닙니다. 에</target>
        </trans-unit>
        <trans-unit id="0576faceb2bc930743ea41920355c65b4ff2f401" translate="yes" xml:space="preserve">
          <source>Object Oriented Encoder</source>
          <target state="translated">객체 지향 인코더</target>
        </trans-unit>
        <trans-unit id="1328c7cddf5e1741e60ae0ea7e9cd25feb10a44d" translate="yes" xml:space="preserve">
          <source>Object Oriented time objects</source>
          <target state="translated">객체 지향 시간 객체</target>
        </trans-unit>
        <trans-unit id="c2554e1cb290677a2fc70d0a43154bdf1c0148ab" translate="yes" xml:space="preserve">
          <source>Object interface for AF_INET domain sockets</source>
          <target state="translated">AF_INET 도메인 소켓을위한 객체 인터페이스</target>
        </trans-unit>
        <trans-unit id="93e56d8e38067f0fd87b11c1619713b42509ffd1" translate="yes" xml:space="preserve">
          <source>Object interface for AF_UNIX domain sockets</source>
          <target state="translated">AF_UNIX 도메인 소켓을위한 객체 인터페이스</target>
        </trans-unit>
        <trans-unit id="3d662b2d2b28e92fa294d9f80685e9709d96e1ab" translate="yes" xml:space="preserve">
          <source>Object interface to socket communications</source>
          <target state="translated">소켓 통신을위한 객체 인터페이스</target>
        </trans-unit>
        <trans-unit id="c9adffadbed4d834ac5b856b003595a5f887d57f" translate="yes" xml:space="preserve">
          <source>Object interface to system poll call</source>
          <target state="translated">시스템 폴 호출에 대한 객체 인터페이스</target>
        </trans-unit>
        <trans-unit id="cc8d552e462d1eb5f26cd8f9fdf1f0a8654a0735" translate="yes" xml:space="preserve">
          <source>Object interface:</source>
          <target state="translated">객체 인터페이스 :</target>
        </trans-unit>
        <trans-unit id="a4fd25b923092435b59d8ba7f9a4eeafbcc983ac" translate="yes" xml:space="preserve">
          <source>Object oriented interface</source>
          <target state="translated">객체 지향 인터페이스</target>
        </trans-unit>
        <trans-unit id="e5fa350c821e5eff6e8a902ebb2f0731d1bbc634" translate="yes" xml:space="preserve">
          <source>Object registry is best done when the object is initialized for use with a class. That way, garbage collection and thread safety are established for every object and every field that is initialized.</source>
          <target state="translated">객체 레지스트리는 클래스와 함께 사용하기 위해 객체가 초기화 될 때 가장 잘 수행됩니다. 이렇게하면 모든 객체와 초기화 된 모든 필드에 대해 가비지 수집 및 스레드 안전성이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="00830e1926297b7c355fe1aa06dab72200595135" translate="yes" xml:space="preserve">
          <source>Object status (i.e., the class an object is blessed into) is also cloned.</source>
          <target state="translated">객체 상태 (즉, 객체가 축복받은 클래스)도 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="88749641a0e24498fbd33e53d44467f3c2c5fba0" translate="yes" xml:space="preserve">
          <source>Objects Are Blessed; Variables Are Not</source>
          <target state="translated">축복받은 대상; 변수가 아닙니다</target>
        </trans-unit>
        <trans-unit id="e56ad09ee25c724ca5817035af9f32f714eaf7e7" translate="yes" xml:space="preserve">
          <source>Objects representing POD input paragraphs, commands, etc.</source>
          <target state="translated">POD 입력 단락, 명령 등을 나타내는 객체</target>
        </trans-unit>
        <trans-unit id="1ad3969f34af62c08d92133f049673d28c2645d6" translate="yes" xml:space="preserve">
          <source>Obscure - set count of bytes in the buffer. Deprecated. Only usable if PerlIO_canset_cnt() returns true. Currently used in only doio.c to force count less than -1 to -1. Perhaps should be PerlIO_set_empty or similar. This call may actually do nothing if &quot;count&quot; is deduced from pointer and a &quot;limit&quot;. Do not use this - use PerlIO_set_ptrcnt().</source>
          <target state="translated">애매-버퍼의 바이트 수를 설정합니다. 더 이상 사용되지 않습니다. PerlIO_canset_cnt ()가 true를 반환하는 경우에만 사용할 수 있습니다. 현재 카운트를 -1에서 -1보다 작게하기 위해 doio.c에서만 사용됩니다. 아마도 PerlIO_set_empty 또는 유사해야합니다. 이 호출은 포인터와 &quot;제한&quot;에서 &quot;count&quot;가 추론 된 경우 실제로 아무 작업도 수행하지 않을 수 있습니다. 이것을 사용하지 마십시오-PerlIO_set_ptrcnt ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e6bd238b055b51008fa691962e5504d6a4300b6b" translate="yes" xml:space="preserve">
          <source>Obsolete backwards compatibility functions</source>
          <target state="translated">이전 버전과의 호환성 기능</target>
        </trans-unit>
        <trans-unit id="242a752af236cef2e4f67eafc9e86420fe839b22" translate="yes" xml:space="preserve">
          <source>Obsolete, deprecated method. Not used since Version 5.21.</source>
          <target state="translated">더 이상 사용되지 않는 방법입니다. 버전 5.21부터 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae05a67e6b1bdd3a5722aeecd922515ab6353aa5" translate="yes" xml:space="preserve">
          <source>Obsolete. All code points previously matched by this have been moved to &quot;Script=Common&quot;. Consider instead using &quot;Script_Extensions=Katakana&quot; or &quot;Script_Extensions=Hiragana&quot; (or both)</source>
          <target state="translated">더 이상 사용되지 않습니다. 이전에이 코드와 일치하는 모든 코드 포인트가 &quot;Script = Common&quot;으로 이동되었습니다. 대신 &quot;Script_Extensions = Katakana&quot;또는 &quot;Script_Extensions = Hiragana&quot;(또는 둘 다)를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="2fc29852a42ef2fda895989b8798adc19e9d7e6c" translate="yes" xml:space="preserve">
          <source>Obtain a response from the server. Upon success the most significant digit of the status code is returned. Upon failure, timeout etc.,</source>
          <target state="translated">서버에서 응답을 얻습니다. 성공하면 상태 코드의 최상위 숫자가 반환됩니다. 실패, 타임 아웃 등</target>
        </trans-unit>
        <trans-unit id="c69d89c90bc0675bccad1c0dfa062843dd612b7a" translate="yes" xml:space="preserve">
          <source>Obtain information about all the active newsgroups. The results is a reference to a hash where the key is a group name and each value is a reference to an array. The elements in this array are:- the last article number in the group, the first article number in the group and any information flags about the group.</source>
          <target state="translated">모든 활성 뉴스 그룹에 대한 정보를 얻습니다. 결과는 키가 그룹 이름이고 각 값이 배열에 대한 참조 인 해시에 대한 참조입니다. 이 배열의 요소는 다음과 같습니다 .- 그룹의 마지막 기사 번호, 그룹의 첫 번째 기사 번호 및 그룹에 대한 정보 플래그.</target>
        </trans-unit>
        <trans-unit id="51850565c0039917e1d7c30526e1aece9dd14aed" translate="yes" xml:space="preserve">
          <source>Obtain the attributes for &lt;code&gt;stdin&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;stdin&lt;/code&gt; 의 속성을 확보하십시오 .</target>
        </trans-unit>
        <trans-unit id="4897259e0b2ea144f76021c4fb5eb538871e32ce" translate="yes" xml:space="preserve">
          <source>Obtain the attributes for stdout.</source>
          <target state="translated">stdout의 속성을 확보하십시오.</target>
        </trans-unit>
        <trans-unit id="12526129b1b52b63050b51bbb32341d9a8cd1a04" translate="yes" xml:space="preserve">
          <source>Obtain the header field &lt;code&gt;HEADER&lt;/code&gt; for all the messages specified.</source>
          <target state="translated">지정된 모든 메시지에 대한 헤더 필드 &lt;code&gt;HEADER&lt;/code&gt; 를 확보하십시오 .</target>
        </trans-unit>
        <trans-unit id="ec15ee25f6bbd0b55463ebbf3ac8647c1d12711a" translate="yes" xml:space="preserve">
          <source>Obtain the time on &lt;code&gt;HOST&lt;/code&gt; , or some default host if &lt;code&gt;HOST&lt;/code&gt; is not given or not defined, using the protocol as defined in RFC867. The optional argument &lt;code&gt;PROTOCOL&lt;/code&gt; should define the protocol to use, either &lt;code&gt;tcp&lt;/code&gt; or &lt;code&gt;udp&lt;/code&gt; . The result will be an ASCII string or</source>
          <target state="translated">의 시간을 확보 &lt;code&gt;HOST&lt;/code&gt; 경우, 또는 기본 호스트 &lt;code&gt;HOST&lt;/code&gt; 가 RFC867에 정의 된 프로토콜을 사용하여, 주어진하지 않거나 정의되지 않았습니다. 선택적 인수 &lt;code&gt;PROTOCOL&lt;/code&gt; 은 사용할 프로토콜 ( &lt;code&gt;tcp&lt;/code&gt; 또는 &lt;code&gt;udp&lt;/code&gt; ) 을 정의해야합니다 . 결과는 ASCII 문자열이거나</target>
        </trans-unit>
        <trans-unit id="99f41f8f4a19b089d2fd1f49ca16ff7053ef6795" translate="yes" xml:space="preserve">
          <source>Obtain the time on &lt;code&gt;HOST&lt;/code&gt; , or some default host if &lt;code&gt;HOST&lt;/code&gt; is not given or not defined, using the protocol as defined in RFC868. The optional argument &lt;code&gt;PROTOCOL&lt;/code&gt; should define the protocol to use, either &lt;code&gt;tcp&lt;/code&gt; or &lt;code&gt;udp&lt;/code&gt; . The result will be a time value in the same units as returned by time() or</source>
          <target state="translated">의 시간을 확보 &lt;code&gt;HOST&lt;/code&gt; 경우, 또는 기본 호스트 &lt;code&gt;HOST&lt;/code&gt; 가 RFC868에 정의 된 프로토콜을 사용하여, 주어진하지 않거나 정의되지 않았습니다. 선택적 인수 &lt;code&gt;PROTOCOL&lt;/code&gt; 은 사용할 프로토콜 ( &lt;code&gt;tcp&lt;/code&gt; 또는 &lt;code&gt;udp&lt;/code&gt; ) 을 정의해야합니다 . 결과는 time () 또는</target>
        </trans-unit>
        <trans-unit id="da382120051949707a0c7beb67aab96ce623a328" translate="yes" xml:space="preserve">
          <source>Obviously the first of these will fail to distinguish most ASCII platforms from either a CCSID 0037, a 1047, or a POSIX-BC EBCDIC platform since &lt;code&gt;&quot;\r&quot; &lt;a href=&quot;functions/eq&quot;&gt;eq&lt;/a&gt; &lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(13)&lt;/code&gt; under all of those coded character sets. But note too that because &lt;code&gt;&quot;\n&quot;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(13)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&quot;\r&quot;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(10)&lt;/a&gt;&lt;/code&gt; on old Macintosh (which is an ASCII platform) the second &lt;code&gt;$is_ascii&lt;/code&gt; test will lead to trouble there.</source>
          <target state="translated">분명히 이들 중 첫 번째는 모든 ASCII 문자 플랫폼에서 &lt;code&gt;&quot;\r&quot; &lt;a href=&quot;functions/eq&quot;&gt;eq&lt;/a&gt; &lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(13)&lt;/code&gt; 이후 대부분의 ASCII 플랫폼을 CCSID 0037, 1047 또는 POSIX-BC EBCDIC 플랫폼과 구별하지 못합니다 . 그러나 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(13)&lt;/a&gt;&lt;/code&gt; 이고 &lt;code&gt;&quot;\r&quot;&lt;/code&gt; 은 이전 Macintosh (ASCII 플랫폼)에서 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(10)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;$is_ascii&lt;/code&gt; 두 번째 $ is_ascii 테스트는 문제를 일으 킵니다 .</target>
        </trans-unit>
        <trans-unit id="bfc9e42e3d47c901ceac3b16df8f05113274fcf2" translate="yes" xml:space="preserve">
          <source>Obviously this assumes that it is possible to typecast a pointer to an unsigned long and vice versa, which frequently works but should not be taken as a universal law. - Now that we have this pointer the next question is: How can we put it to good use? We need a call to some C function where a pointer is expected. The read(2) system call comes to mind:</source>
          <target state="translated">분명히 이것은 서명되지 않은 long에 대한 포인터를 타입 캐스팅 할 수 있다고 가정하고, 그 반대의 경우도 자주 작동하지만 보편적 법으로 취해서는 안됩니다. -이제 우리는이 포인터를 가지게되었습니다. 다음 질문은 : 어떻게 잘 사용할 수 있습니까? 포인터가 필요한 C 함수를 호출해야합니다. read (2) 시스템 호출이 떠 오릅니다.</target>
        </trans-unit>
        <trans-unit id="8622bcf5480e2dcfc1e93eb63bd84e889a59eca8" translate="yes" xml:space="preserve">
          <source>Obviously, bugs which include patches are best. If you prefer, you can patch against bleed by via anonymous checkout of the latest version:</source>
          <target state="translated">분명히 패치를 포함하는 버그가 가장 좋습니다. 원하는 경우 최신 버전의 익명 체크 아웃을 통해 출혈에 대해 패치를 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ad2def711f61d8bfaa27f7b29de908193ec9688" translate="yes" xml:space="preserve">
          <source>Obviously, in the situation of the last type of the signature of an OS/2 API, it is must more convenient for the users if the failure is indicated by die()ing: one does not need to check $^E to know that something went wrong. If, however, this solution is not desirable by some reason, the code in question should reset $^E to 0 before making this OS/2 API call, so that the caller of this Perl-accessible function has a chance to distinguish a success-but-0-return value from a failure. (One may return undef as an alternative way of reporting an error.)</source>
          <target state="translated">분명히, OS / 2 API 서명의 마지막 유형의 상황에서 die () ing으로 실패가 표시되면 사용자가 더 편리해야합니다. $ ^ E를 확인할 필요가 없다는 것을 알 수 있습니다. 문제가 발생했습니다. 그러나 어떤 이유로이 솔루션이 바람직하지 않은 경우 해당 OS / 2 API 호출을 수행하기 전에 해당 코드가 $ ^ E를 0으로 재설정해야합니다. 따라서이 Perl 액세스 가능 함수의 호출자는 성공을 구별 할 수 있습니다. -but-0- 실패에서 값을 반환합니다. (오류를보고하는 다른 방법으로 undef를 반환 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="d64ac810883d44e27969b0774d70505e74b53a16" translate="yes" xml:space="preserve">
          <source>Obviously, the second call to &lt;code&gt;complicated&lt;/code&gt; is a waste of time, and storing its return value is a waste of space. Specifying &lt;code&gt;LIST_CACHE
=&amp;gt; MERGE&lt;/code&gt; will make &lt;code&gt;memoize&lt;/code&gt; use the same cache for scalar and list context return values, so that the second call uses the scalar cache that was populated by the first call. &lt;code&gt;complicated&lt;/code&gt; ends up being called only once, and both subsequent calls return &lt;code&gt;3&lt;/code&gt; from the cache, regardless of the calling context.</source>
          <target state="translated">분명히 두 번째로 &lt;code&gt;complicated&lt;/code&gt; 호출 은 시간 낭비이며 반환 값을 저장하는 것은 공간 낭비입니다. 지정 &lt;code&gt;LIST_CACHE =&amp;gt; MERGE&lt;/code&gt; 것 &lt;code&gt;memoize&lt;/code&gt; 는 두 번째 전화가 첫 번째 통화로 채워진 스칼라 캐시를 사용되도록, 스칼라 및 목록 컨텍스트 값에 대한 동일한 캐시를 사용한다. &lt;code&gt;complicated&lt;/code&gt; 는 한 번만 호출되며 호출 컨텍스트에 관계없이 두 후속 호출 모두 캐시에서 &lt;code&gt;3&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="a86730e802eb4eb4e4acf92e33bec8c9303fc96c" translate="yes" xml:space="preserve">
          <source>Occasionally it is important to pass a reference to the object being tied to the TIESCALAR, TIEHASH, etc. that ties it.</source>
          <target state="translated">때로는 TIESCALAR, TIEHASH 등에 묶여있는 객체에 대한 참조를 전달하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="5cb8a483e38416f865c96e1886ae8adceb1b5292" translate="yes" xml:space="preserve">
          <source>Occasionally the programmer will want to return simply &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; or an empty list if a function fails rather than a separate status value. The rpcb_gettime() function offers just this situation. If the function succeeds we would like to have it return the time and if it fails we would like to have undef returned. In the following Perl code the value of $timep will either be undef or it will be a valid time.</source>
          <target state="translated">때로는 프로그래머가 별도의 상태 값이 아닌 함수가 실패하면 단순히 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 또는 빈 목록 을 반환하려고 할 것 입니다. rpcb_gettime () 함수는이 상황을 제공합니다. 함수가 성공하면 시간을 반환하고 실패하면 undef를 반환하려고합니다. 다음 Perl 코드에서 $ timep의 값은 undef이거나 유효한 시간입니다.</target>
        </trans-unit>
        <trans-unit id="fca6836d0056140d86bcc04d81edeb7b7f85d973" translate="yes" xml:space="preserve">
          <source>Occasionally the strenuous efforts Attribute::Handlers makes to convert the data argument (&lt;code&gt;$_[4]&lt;/code&gt; ) to a usable form before passing it to the handler get in the way.</source>
          <target state="translated">때때로 어려운 노력 Attribute :: Handlers는 처리기에 전달하기 전에 데이터 인수 ( &lt;code&gt;$_[4]&lt;/code&gt; )를 사용 가능한 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="3a1a8a18cac1b8ec9d036c1e95c86caa06823297" translate="yes" xml:space="preserve">
          <source>Occasionally, you can't use just a &lt;code&gt;/g&lt;/code&gt; to get all the changes to occur that you might want. Here are two common cases:</source>
          <target state="translated">간혹, &lt;code&gt;/g&lt;/code&gt; 만 사용 하여 원하는 모든 변경 사항을 얻을 수는 없습니다 . 일반적인 두 가지 경우는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3642950c84185b95fade3aa22cda9a0e1954ee82" translate="yes" xml:space="preserve">
          <source>Oceania</source>
          <target state="translated">Oceania</target>
        </trans-unit>
        <trans-unit id="b5befcf80da75ec699a5c983fc36244ec375a0c0" translate="yes" xml:space="preserve">
          <source>Octal escapes</source>
          <target state="translated">8 진 탈출</target>
        </trans-unit>
        <trans-unit id="6d3bc0d39ae545ee26be05b556b7a8cf4ddc990b" translate="yes" xml:space="preserve">
          <source>Octal escapes of the &lt;code&gt;\000&lt;/code&gt; form outside of bracketed character classes potentially clash with old-style backreferences (see &lt;a href=&quot;#Absolute-referencing&quot;&gt;Absolute referencing&lt;/a&gt; below). They both consist of a backslash followed by numbers. So Perl has to use heuristics to determine whether it is a backreference or an octal escape. Perl uses the following rules to disambiguate:</source>
          <target state="translated">대괄호로 묶은 문자 클래스 외부 에서 &lt;code&gt;\000&lt;/code&gt; 형식 의 8 진수 이스케이프는 이전 스타일 역 참조와 충돌 할 가능성이 있습니다 (아래 &lt;a href=&quot;#Absolute-referencing&quot;&gt;절대 참조&lt;/a&gt; 참조). 둘 다 백 슬래시와 숫자로 구성됩니다. 따라서 Perl은 휴리스틱을 사용하여 역 참조인지 8 진 탈출인지를 결정해야합니다. Perl은 다음 규칙을 사용하여 명확하게합니다.</target>
        </trans-unit>
        <trans-unit id="001ed8e6a266e94752602c2df86a674e88e19c2d" translate="yes" xml:space="preserve">
          <source>Of course &lt;a href=&quot;http://search.cpan.org/perldoc/CGI&quot;&gt;CGI&lt;/a&gt; and &lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt; will tell you more.</source>
          <target state="translated">물론 &lt;a href=&quot;http://search.cpan.org/perldoc/CGI&quot;&gt;CGI&lt;/a&gt; 와 &lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt; 가 더 많은 정보 를 알려줄 것입니다.</target>
        </trans-unit>
        <trans-unit id="814879db219b87492dd375dcf6f869266e936b99" translate="yes" xml:space="preserve">
          <source>Of course, &lt;code&gt;Moose&lt;/code&gt; isn't perfect.</source>
          <target state="translated">물론 &lt;code&gt;Moose&lt;/code&gt; 는 완벽하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="733d5b43433c0be3dd395c3e52526830c10b5e3c" translate="yes" xml:space="preserve">
          <source>Of course, &lt;code&gt;vianame&lt;/code&gt; , &lt;code&gt;viacode&lt;/code&gt; , and &lt;code&gt;string_vianame&lt;/code&gt; would need to be overridden as well.</source>
          <target state="translated">물론, &lt;code&gt;vianame&lt;/code&gt; , &lt;code&gt;viacode&lt;/code&gt; 및 &lt;code&gt;string_vianame&lt;/code&gt; 은 물론 오버라이드 (override) 할 필요가있다.</target>
        </trans-unit>
        <trans-unit id="03c6e1d7d58bd1d130be768a05a694a94d3aba2b" translate="yes" xml:space="preserve">
          <source>Of course, here too, Filter::Simple has to know you're using Exporter before it applies the filter. That's almost never a problem, but if you're nervous about it, you can guarantee that things will work correctly by ensuring that your &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; base Exporter&lt;/code&gt; always precedes your &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Filter::Simple&lt;/code&gt; .</source>
          <target state="translated">물론 여기에서도 Filter :: Simple은 필터를 적용하기 전에 내보내기를 사용하고 있음을 알아야합니다. 그것은 거의 문제가되지 않지만, 신경이 쓰이는 경우, &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; base Exporter&lt;/code&gt; 항상 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Filter::Simple&lt;/code&gt; 보다 우선 하도록하여 일이 올바르게 작동하도록 보장 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ab33e7ed924208df5f517b6f58635c94da06be71" translate="yes" xml:space="preserve">
          <source>Of course, if &lt;code&gt;@ISA&lt;/code&gt; contained only &lt;code&gt;DynaLoader&lt;/code&gt; , there is no need to have the &lt;code&gt;@ISA&lt;/code&gt; assignment at all; moreover, if instead of &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; one uses the more backward-compatible</source>
          <target state="translated">물론 &lt;code&gt;@ISA&lt;/code&gt; 에 &lt;code&gt;DynaLoader&lt;/code&gt; 만 포함 된 경우 &lt;code&gt;@ISA&lt;/code&gt; 할당 이 전혀 필요하지 않습니다 . 또한, &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 대신에 이전 버전과 호환되는</target>
        </trans-unit>
        <trans-unit id="5fe9b52519ed5e683419d8b8de5fb62a2cea4185" translate="yes" xml:space="preserve">
          <source>Of course, if the class name is in a scalar Perl will do the right thing as well:</source>
          <target state="translated">물론 클래스 이름이 스칼라 인 경우 Perl도 올바른 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d886edfc3d346b2f618c821d88c4f77af2ec29fb" translate="yes" xml:space="preserve">
          <source>Of course, if you simply follow the guidelines in &lt;a href=&quot;perlstyle&quot;&gt;perlstyle&lt;/a&gt;, you shouldn't need to reformat. The habit of formatting your code as you write it will help prevent bugs. Your editor can and should help you with this. The perl-mode or newer cperl-mode for emacs can provide remarkable amounts of help with most (but not all) code, and even less programmable editors can provide significant assistance. Tom Christiansen and many other VI users swear by the following settings in vi and its clones:</source>
          <target state="translated">물론 &lt;a href=&quot;perlstyle&quot;&gt;perlstyle&lt;/a&gt; 의 지침을 따르기 만하면 다시 포맷 할 필요가 없습니다. 코드를 작성할 때 코드를 작성하는 습관은 버그를 예방하는 데 도움이됩니다. 편집자가이를 도와 줄 수 있습니다. emacs를위한 perl-mode 또는 새로운 cperl-mode는 대부분의 (전부는 아님) 코드에 대해 상당한 양의 도움말을 제공 할 수 있으며, 프로그래밍이 덜 된 편집기에서도 훨씬 큰 도움을 줄 수 있습니다. Tom Christiansen과 다른 많은 VI 사용자는 vi와 그 클론에서 다음 설정으로 맹세합니다.</target>
        </trans-unit>
        <trans-unit id="abb07ecb376ea8ffb38769be127701645f4d0359" translate="yes" xml:space="preserve">
          <source>Of course, in contexts like, for example, &lt;code&gt;$obj + 1&lt;/code&gt; , Perl will invoke &lt;code&gt;$obj&lt;/code&gt; 's implementation of &lt;code&gt;+&lt;/code&gt; rather than (in this example) converting &lt;code&gt;$obj&lt;/code&gt; to a number using the numify method &lt;code&gt;'0+'&lt;/code&gt; (an exception to this is when no method has been provided for &lt;code&gt;'+'&lt;/code&gt; and &lt;a href=&quot;#fallback&quot;&gt;fallback&lt;/a&gt; is set to TRUE).</source>
          <target state="translated">물론, 예를 들어 &lt;code&gt;$obj + 1&lt;/code&gt; 과 같은 상황 에서 Perl은 (이 예제에서는) numify 메소드 &lt;code&gt;'0+'&lt;/code&gt; 를 사용하여 &lt;code&gt;$obj&lt;/code&gt; 를 숫자 로 변환하는 대신 &lt;code&gt;+&lt;/code&gt; 의 &lt;code&gt;$obj&lt;/code&gt; 구현을 호출 합니다 어떤 방법이 제공되어 있지 않은 경우는 &lt;code&gt;'+'&lt;/code&gt; 및 &lt;a href=&quot;#fallback&quot;&gt;대체&lt;/a&gt; ) TRUE로 설정된다.</target>
        </trans-unit>
        <trans-unit id="837c1a0c6d4394993c9260f47b27824bf6031d2f" translate="yes" xml:space="preserve">
          <source>Of course, in the case of a literal string, one could just as easily use the string comparison &lt;code&gt;$string eq 'bert'&lt;/code&gt; and it would be more efficient. The &lt;code&gt;^...$&lt;/code&gt; regexp really becomes useful when we add in the more powerful regexp tools below.</source>
          <target state="translated">물론 리터럴 문자열의 경우 문자열 비교 &lt;code&gt;$string eq 'bert'&lt;/code&gt; 를 쉽게 사용할 수 있으며 더 효율적입니다. &lt;code&gt;^...$&lt;/code&gt; 우리가 아래 더 강력한 정규 표현식 도구에 추가 할 때 정규 표현식은 정말 유용하게된다.</target>
        </trans-unit>
        <trans-unit id="27457c444325a83774ce245c93383c8862b5cc3d" translate="yes" xml:space="preserve">
          <source>Of course, in this module-author's humble opinion, I'd be more inclined to use the existing &lt;b&gt;Pod::ParseTree&lt;/b&gt; object than a simple array. That way everything in it, paragraphs and sequences, all respond to the same core interface for all parse-tree nodes. The result would look something like:</source>
          <target state="translated">물론,이 모듈 저자의 겸손한 견해로 는 간단한 배열보다 기존 &lt;b&gt;Pod :: ParseTree&lt;/b&gt; 객체 를 사용하는 경향이 더 &lt;b&gt;큽니다&lt;/b&gt; . 그렇게하면 단락 및 시퀀스의 모든 항목이 모든 구문 분석 트리 노드에 대해 동일한 핵심 인터페이스에 응답합니다. 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="11fde9a92a2449ce2e35bf1f4b5fe24a02e9e7d2" translate="yes" xml:space="preserve">
          <source>Of course, it is important to choose the right separator string for each purpose.</source>
          <target state="translated">물론 각 용도에 맞는 구분 기호 문자열을 선택하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="dc54d65f65f6922d956316c79b1323c206e201c5" translate="yes" xml:space="preserve">
          <source>Of course, it's up to you to decide whether or not to ignore them.</source>
          <target state="translated">물론, 무시할지 여부를 결정하는 것은 당신에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="d78604b940d2c66d71607feff9316d4ae5a87f26" translate="yes" xml:space="preserve">
          <source>Of course, one could write such glue code directly in C. However, this would be a tedious task, especially if one needs to write glue for multiple C functions, and/or one is not familiar enough with the Perl stack discipline and other such arcana. XS comes to the rescue here: instead of writing this glue C code in long-hand, one can write a more concise short-hand</source>
          <target state="translated">물론 C에서 직접 이러한 접착제 코드를 작성할 수 있습니다. 그러나 특히 여러 C 함수에 대한 접착제를 작성해야하거나 Perl 스택 분야 및 기타에 익숙하지 않은 경우에는 지루한 작업입니다. 아르카나. XS는 구출에 이르렀습니다.이 접착제 C 코드를 긴 손으로 쓰는 대신 더 간결한 속기를 쓸 수 있습니다</target>
        </trans-unit>
        <trans-unit id="77c72cea76e3d8ea1cda06ed844191d48368487d" translate="yes" xml:space="preserve">
          <source>Of course, test #1 is $tests[0], etc...</source>
          <target state="translated">물론, 테스트 # 1은 $ tests [0] 등입니다.</target>
        </trans-unit>
        <trans-unit id="de9f73990ad276e504276095781c4201fd0583f9" translate="yes" xml:space="preserve">
          <source>Of course, the best way to save memory is to not do anything to waste it in the first place. Good programming practices can go a long way toward this:</source>
          <target state="translated">물론, 메모리를 절약하는 가장 좋은 방법은 처음에는 메모리를 낭비하지 않는 것입니다. 좋은 프로그래밍 방법은 다음과 같이 먼 길을 갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b974b206a7b1862c93ebd148bc1b83add3324aa2" translate="yes" xml:space="preserve">
          <source>Of course, this</source>
          <target state="translated">물론이</target>
        </trans-unit>
        <trans-unit id="5788145c5ae3423e71b1d5b7f96f5fcb341edfab" translate="yes" xml:space="preserve">
          <source>Of course, this requires that the underlying call supports buffers. See the note on buffers above.</source>
          <target state="translated">물론 이것은 기본 호출이 버퍼를 지원해야합니다. 위의 버퍼에 대한 참고 사항을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="357e4c4fc94af540a4f74537a6571078de606e56" translate="yes" xml:space="preserve">
          <source>Of course, typing in your own password to whoever asks you for it is unwise.</source>
          <target state="translated">물론, 암호를 묻는 사람에게 자신의 암호를 입력하는 것은 현명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aaa47fc8bd024bc87e7c8490eb46dddef3e8914d" translate="yes" xml:space="preserve">
          <source>Of course, unless you know the number of elements in the &lt;code&gt;sometype **&lt;/code&gt; C array, within your XSUB, the return value from &lt;code&gt;foo_t ** XS_unpack_foo_tPtrPtr(...)&lt;/code&gt; will be hard to decipher. Since the details are all up to the XS author (the typemap user), there are several solutions, none of which particularly elegant. The most commonly seen solution has been to allocate memory for N+1 pointers and assign &lt;code&gt;NULL&lt;/code&gt; to the (N+1)th to facilitate iteration.</source>
          <target state="translated">물론 XSUB 내 에서 &lt;code&gt;sometype **&lt;/code&gt; C 배열 의 요소 수를 알지 &lt;code&gt;foo_t ** XS_unpack_foo_tPtrPtr(...)&lt;/code&gt; 의 반환 값 을 해독하기가 어렵습니다. 세부 사항은 모두 XS 작성자 (유형 맵 사용자)에게 달려 있기 때문에 여러 가지 솔루션이 있지만 그 중에서도 특히 우아하지는 않습니다. 가장 일반적으로 보이는 해결책은 N + 1 포인터에 메모리를 할당 하고 반복을 용이하게하기 위해 &lt;code&gt;NULL&lt;/code&gt; 을 (N + 1) 번째에 할당 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="edd8408b88d74e19ec1265ebd83f3cd07501b352" translate="yes" xml:space="preserve">
          <source>Of course, unless your OS does not implement access(), in which case the pragma is simply ignored. Best not to use &lt;code&gt;_&lt;/code&gt; at all in a file where the filetest pragma is active!</source>
          <target state="translated">물론, OS가 access ()를 구현하지 않으면 pragma는 무시됩니다. filetest pragma가 활성화 된 파일에서 &lt;code&gt;_&lt;/code&gt; 를 전혀 사용하지 않는 것이 가장 좋습니다 !</target>
        </trans-unit>
        <trans-unit id="f9a595714c023a195e48ee401212d01b31493781" translate="yes" xml:space="preserve">
          <source>Of course, you don't need the temporary array to have a name at all:</source>
          <target state="translated">물론 이름을 갖기 위해 임시 배열이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fb6f67a6165dc8bfd66e5ae946dbcf7584578eef" translate="yes" xml:space="preserve">
          <source>Of the conversions, only one of string, boolean or numeric is needed because each can be generated from either of the other two.</source>
          <target state="translated">변환 중 문자열, 부울 또는 숫자 중 하나만 필요합니다. 각각은 다른 두 가지 중 하나에서 생성 될 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="f521e0762b4294067b640a105aa4f9fd48ea8238" translate="yes" xml:space="preserve">
          <source>Of these properties, the two important ones are Pattern_Syntax and Pattern_White_Space. They have been set up by Unicode for exactly this purpose of deciding which characters in a regular expression pattern should be quoted. No character that can be in an identifier has these properties.</source>
          <target state="translated">이러한 속성 중 두 가지 중요한 속성은 Pattern_Syntax 및 Pattern_White_Space입니다. 정규 표현식 패턴에서 인용해야 할 문자를 결정하기 위해 유니 코드에 의해 정확하게 설정되었습니다. 식별자에있을 수있는 문자에는 이러한 속성이 없습니다.</target>
        </trans-unit>
        <trans-unit id="c77879f95662f28e94653e74a629782adc3eeac4" translate="yes" xml:space="preserve">
          <source>Official home page for the ISO 3166 maintenance agency.</source>
          <target state="translated">ISO 3166 유지 관리 기관의 공식 홈페이지.</target>
        </trans-unit>
        <trans-unit id="967fc19002ed71d08a174f5ecc4259363a549385" translate="yes" xml:space="preserve">
          <source>Official source of the top-level domain names.</source>
          <target state="translated">최상위 도메인 이름의 공식 소스.</target>
        </trans-unit>
        <trans-unit id="20daff2f32d6074bbb2255376c7a89b965519ab3" translate="yes" xml:space="preserve">
          <source>Offsets</source>
          <target state="translated">Offsets</target>
        </trans-unit>
        <trans-unit id="6a7926e00c1d5044bed78664357be7137c40f3e0" translate="yes" xml:space="preserve">
          <source>Offsets holds a mapping of offset in the &lt;code&gt;program&lt;/code&gt; to offset in the &lt;code&gt;precomp&lt;/code&gt; string. This is only used by ActiveState's visual regex debugger.</source>
          <target state="translated">오프셋은 사전 &lt;code&gt;precomp&lt;/code&gt; 문자열 에서 오프셋하기 위해 &lt;code&gt;program&lt;/code&gt; 에서 오프셋 의 매핑을 유지 합니다. 이것은 ActiveState의 시각적 정규식 디버거에서만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="43d26f6f08e88e91bca4bafe94301f7c42d03d67" translate="yes" xml:space="preserve">
          <source>Often it is useful to allow comma-separated lists of values as well as multiple occurrences of the options. This is easy using Perl's split() and join() operators:</source>
          <target state="translated">쉼표로 구분 된 값 목록과 여러 옵션이 허용되는 경우가 종종 있습니다. 이것은 Perl의 split () 및 join () 연산자를 사용하면 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="632c3362322ab6672e961b19c05b72785cd26d84" translate="yes" xml:space="preserve">
          <source>Often it is user friendly to supply alternate mnemonic names for options. For example &lt;code&gt;--height&lt;/code&gt; could be an alternate name for &lt;code&gt;--&lt;a href=&quot;../functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; . Alternate names can be included in the option specification, separated by vertical bar &lt;code&gt;|&lt;/code&gt; characters. To implement the above example:</source>
          <target state="translated">옵션에 대체 니모닉 이름을 제공하는 것이 사용자에게 친숙한 경우가 많습니다. 예를 들어 &lt;code&gt;--height&lt;/code&gt; 가 의 대체 이름이 될 수 &lt;code&gt;--&lt;a href=&quot;../functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; . 옵션 이름에 대체 이름을 세로 막대 &lt;code&gt;|&lt;/code&gt; 문자. 위 예제를 구현하려면</target>
        </trans-unit>
        <trans-unit id="413285a912f30dbf718e8f5cd58feece5f266f30" translate="yes" xml:space="preserve">
          <source>Often there will be another error message associated with the syntax error giving more information. (Sometimes it helps to turn on &lt;b&gt;-w&lt;/b&gt;.) The error message itself often tells you where it was in the line when it decided to give up. Sometimes the actual error is several tokens before this, because Perl is good at understanding random input. Occasionally the line number may be misleading, and once in a blue moon the only way to figure out what's triggering the error is to call &lt;code&gt;perl -c&lt;/code&gt; repeatedly, chopping away half the program each time to see if the error went away. Sort of the cybernetic version of 20 questions.</source>
          <target state="translated">더 많은 정보를 제공하는 구문 오류와 관련된 다른 오류 메시지가 종종 있습니다. (때로는 &lt;b&gt;-w&lt;/b&gt; 를 켜는 데 도움이됩니다 .) 오류 메시지 자체는 종종 포기하기로 결정했을 때 오류가 발생한 위치를 알려줍니다. Perl이 임의의 입력을 이해하는 데 능숙하기 때문에 실제 오류는이 전에 여러 토큰입니다. 때때로 줄 번호가 오해의 소지가있을 수 있으며, 블루 문에서 오류를 일으키는 원인을 알아내는 유일한 방법은 &lt;code&gt;perl -c&lt;/code&gt; 를 반복해서 호출 하여 오류가 사라 졌는지 확인할 때마다 프로그램의 절반을 잘라내는 것입니다. 20 질문의 자동 제어 버전의 종류.</target>
        </trans-unit>
        <trans-unit id="fe51516899ec526908e4919457333ab9ef798f50" translate="yes" xml:space="preserve">
          <source>Often you want to manually set the $VERSION in the main module distribution because this is the version that everybody sees on CPAN and maybe you want to customize it a bit. But for all the other modules in your dist, $VERSION is really just bookkeeping and all that's important is it goes up every time the module is changed. Doing this by hand is a pain and you often forget.</source>
          <target state="translated">모든 사용자가 CPAN에서 볼 수있는 버전이기 때문에 기본 모듈 배포에서 $ VERSION을 수동으로 설정하려는 경우가 있으며이를 약간 사용자 정의 할 수도 있습니다. 그러나 dist에있는 다른 모든 모듈의 경우 $ VERSION은 실제로 부기입니다. 중요한 것은 모듈이 변경 될 때마다 올라가는 것입니다. 이것을 손으로하는 것은 고통스럽고 종종 잊어 버립니다.</target>
        </trans-unit>
        <trans-unit id="a8e3c059f398572879c5f613bbb88d9e476377a9" translate="yes" xml:space="preserve">
          <source>Oh, hmm. That didn't quite work. Let's see what happened:</source>
          <target state="translated">흠. 그것은 효과가 없었습니다. 무슨 일이 있었는지 보자 :</target>
        </trans-unit>
        <trans-unit id="2c053114f243927de5bf7cd77c45af1c27a14806" translate="yes" xml:space="preserve">
          <source>Oh, one final bit of advice: take &lt;a href=&quot;../perlguts&quot;&gt;perlguts&lt;/a&gt; with you. When you return we expect to see it well-thumbed.</source>
          <target state="translated">오, 마지막 조언 하나 : &lt;a href=&quot;../perlguts&quot;&gt;perlguts&lt;/a&gt; 를 가지고 가십시오 . 당신이 돌아올 때 우리는 그것을 잘 보여줄 것으로 기대합니다.</target>
        </trans-unit>
        <trans-unit id="8773501dbe9f64eda9a34f3bd611a37f1791691b" translate="yes" xml:space="preserve">
          <source>Ok, but how about when you want to really see your data, what's in that dynamic variable, just before using it?</source>
          <target state="translated">그러나 데이터를 실제로보고 싶을 때 동적 변수가 무엇입니까? 사용하기 직전에?</target>
        </trans-unit>
        <trans-unit id="94213f220b40a7c6524e04580b008b30cdf470cf" translate="yes" xml:space="preserve">
          <source>Ok, so that's not very interesting, because it didn't find that particular document. But a long response wouldn't have fit on this page.</source>
          <target state="translated">좋아, 그래서 그것은 특정 문서를 찾지 못했기 때문에 그리 흥미롭지 않습니다. 그러나 긴 응답은이 페이지에 맞지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="98a944759b5b6a428ccfa37e9a4506cd2b44afa1" translate="yes" xml:space="preserve">
          <source>Ok, so there can be more than one Test::Builder object and this is how you get it. You might use this instead of &lt;code&gt;new()&lt;/code&gt; if you're testing a Test::Builder based module, but otherwise you probably want &lt;code&gt;new&lt;/code&gt; .</source>
          <target state="translated">자, Test :: Builder 객체가 둘 이상있을 수 있으며 이것이 바로 그 방법입니다. Test :: Builder 기반 모듈을 테스트하는 경우 &lt;code&gt;new()&lt;/code&gt; 대신 이것을 사용할 수 있지만 그렇지 않으면 &lt;code&gt;new&lt;/code&gt; 를 원할 것입니다 .</target>
        </trans-unit>
        <trans-unit id="f313a2347a7e1b7519ec6e24bd0468d6b0162bc3" translate="yes" xml:space="preserve">
          <source>Okay, if you insist: the &quot;internal format&quot; is utf8, not UTF-8. (When it's not some other encoding.)</source>
          <target state="translated">당신이 주장한다면 : &quot;내부 형식&quot;은 UTF-8이 아닌 utf8입니다. (다른 인코딩이 아닌 경우)</target>
        </trans-unit>
        <trans-unit id="a1f111382df51fd175ea0dd918cefd5d91a357cd" translate="yes" xml:space="preserve">
          <source>Old byte-oriented programs should magically start working on the new character-oriented data when appropriate.</source>
          <target state="translated">오래된 바이트 지향 프로그램은 적절한 경우 새 문자 지향 데이터 작업을 마술처럼 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="484e0a4f10a1f76d63b7cbe120323d7095b0f174" translate="yes" xml:space="preserve">
          <source>Old byte-oriented programs should not spontaneously break on the old byte-oriented data they used to work on.</source>
          <target state="translated">이전 바이트 지향 프로그램은 작업에 사용했던 이전 바이트 지향 데이터를 자발적으로 중단해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="ae5d8d02aa4909a49747784b849d74c7097909f2" translate="yes" xml:space="preserve">
          <source>Old perl executable is started when a new executable is running has loaded an extension compiled for the old executable (ouph!). In this case the old executable will get a forwarder DLL instead of the old perl DLL, so would link with the new perl DLL. While not directly fatal, it will behave the same as new executable. This beats the whole purpose of explicitly starting an old executable.</source>
          <target state="translated">새 실행 파일이 실행 중일 때 이전 perl 실행 파일이 시작되었습니다. 이전 실행 파일 (ouph!) 용으로 컴파일 된 확장자가로드되었습니다. 이 경우 이전 실행 파일은 이전 perl DLL 대신 전달자 DLL을 가져 오므로 새 perl DLL과 연결됩니다. 직접 치명적이지는 않지만 새 실행 파일과 동일하게 작동합니다. 이것은 이전 실행 파일을 명시 적으로 시작하는 전체 목적을 능가합니다.</target>
        </trans-unit>
        <trans-unit id="b4065d89a2f43100a5cf55aa7a52797bb4059e14" translate="yes" xml:space="preserve">
          <source>Old-style versus new-style block names</source>
          <target state="translated">구식 대 신식 블록 이름</target>
        </trans-unit>
        <trans-unit id="69d1a0ab771940cdc9cc69797ad23f167d7d2a58" translate="yes" xml:space="preserve">
          <source>Oldconfig.U</source>
          <target state="translated">Oldconfig.U</target>
        </trans-unit>
        <trans-unit id="0f656bb21c786456d378ff0e1756c02c791362d3" translate="yes" xml:space="preserve">
          <source>Older documentation (and some CPAN modules) encouraged this syntax, particularly for constructors, so you may still find it in the wild. However, we encourage you to avoid using it in new code.</source>
          <target state="translated">오래된 문서 (및 일부 CPAN 모듈)는 특히 구문 생성자를 위해이 구문을 권장했기 때문에 여전히 야생에서 찾을 수 있습니다. 그러나 새 코드에서는 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="845ea4ddc5e221b527b9b5fd418aec5c3f3db57a" translate="yes" xml:space="preserve">
          <source>Older releases of VOS (prior to OpenVOS Release 17.0) limit file names to 32 or fewer characters, prohibit file names from starting with a &lt;code&gt;-&lt;/code&gt; character, and prohibit file names from containing any character matching &lt;code&gt;tr/ !#%&amp;amp;'()*;&amp;lt;=&amp;gt;?//&lt;/code&gt; .</source>
          <target state="translated">VOS의 이전 릴리스 (OpenVOS 릴리스 17.0 이전)는 파일 이름을 32 자 이하로 제한하고 파일 이름이 &lt;code&gt;-&lt;/code&gt; 문자로 시작하는 것을 금지하고 파일 이름이 문자와 일치하는 문자를 포함하지 못하게합니다 &lt;code&gt;tr/ !#%&amp;amp;'()*;&amp;lt;=&amp;gt;?//&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4148117b640e73f6a46898d2260720a46ef03ff" translate="yes" xml:space="preserve">
          <source>Older translators might add wording around an L&amp;lt;&amp;gt; link, so that &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; may become &quot;the Foo::Bar manpage&quot;, for example. So you shouldn't write things like &lt;code&gt;the L&amp;lt;foo&amp;gt;
documentation&lt;/code&gt;, if you want the translated document to read sensibly. Instead, write &lt;code&gt;the L&amp;lt;Foo::Bar|Foo::Bar&amp;gt; documentation&lt;/code&gt; or &lt;code&gt;L&amp;lt;the Foo::Bar documentation|Foo::Bar&amp;gt;&lt;/code&gt; , to control how the link comes out.</source>
          <target state="translated">예를 들어, 오래된 번역가는 L &amp;lt;&amp;gt; 링크 주위에 단어를 추가하여 L &amp;lt; &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; 가 &quot;Foo :: Bar 맨 페이지&quot;가 ​​될 수 있습니다. 따라서 번역 된 문서를 현명하게 읽으려면 &lt;code&gt;the L&amp;lt;foo&amp;gt; documentation&lt;/code&gt; 과 같은 것을 쓰면 안됩니다 . 대신 &lt;code&gt;the L&amp;lt;Foo::Bar|Foo::Bar&amp;gt; documentation&lt;/code&gt; 또는 &lt;code&gt;L&amp;lt;the Foo::Bar documentation|Foo::Bar&amp;gt;&lt;/code&gt; 를 작성하여 링크가 어떻게 나오는지 제어하십시오.</target>
        </trans-unit>
        <trans-unit id="74cfdc9feb194af111f83545c6d1330ca4e4400c" translate="yes" xml:space="preserve">
          <source>Older versions of CPAN.pm had the original root directory of all tarballs in the build directory. Now there are always random characters appended to these directory names. Why was this done?</source>
          <target state="translated">CPAN.pm의 이전 버전은 빌드 디렉토리에있는 모든 tarball의 원래 루트 디렉토리를 가졌습니다. 이제이 디렉토리 이름에 항상 임의의 문자가 추가됩니다. 왜 이렇게 되었습니까?</target>
        </trans-unit>
        <trans-unit id="aa508d12280c1adaeb775241c86d759189c3c71c" translate="yes" xml:space="preserve">
          <source>Older versions of this document recommended to use &lt;code&gt;void&lt;/code&gt; return value in such cases. It was discovered that this could lead to segfaults in cases when XSUB was</source>
          <target state="translated">이 문서의 이전 버전 에서는 이러한 경우에 &lt;code&gt;void&lt;/code&gt; 반환 값 을 사용하는 것이 좋습니다 . 이로 인해 XSUB가 발생한 경우 segfault가 발생할 수 있음이 밝혀졌습니다.</target>
        </trans-unit>
        <trans-unit id="7dc06c5173c26db9fe80a519eb5a6ebe90623816" translate="yes" xml:space="preserve">
          <source>Oldsyms.U</source>
          <target state="translated">Oldsyms.U</target>
        </trans-unit>
        <trans-unit id="9cf87efb8c04dd4dc674e0b0506f97a5eb0660ea" translate="yes" xml:space="preserve">
          <source>Olivier Mengue</source>
          <target state="translated">올리비에 멘그</target>
        </trans-unit>
        <trans-unit id="f3ed24c21f5dd18b200f0c25095d7a6774573e1a" translate="yes" xml:space="preserve">
          <source>Omit &lt;code&gt;constant()&lt;/code&gt; from the .xs file and corresponding specialised &lt;code&gt;AUTOLOAD&lt;/code&gt; from the .pm file.</source>
          <target state="translated">.xs 파일에서 &lt;code&gt;constant()&lt;/code&gt; 를 생략 하고 .pm 파일에서 해당하는 특수 &lt;code&gt;AUTOLOAD&lt;/code&gt; 를 생략 하십시오.</target>
        </trans-unit>
        <trans-unit id="9c4aa09aebc98ad6e647cac1f8fffb08291cde09" translate="yes" xml:space="preserve">
          <source>Omit all autoload facilities. This is the same as &lt;b&gt;-c&lt;/b&gt; but also removes the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader&lt;/code&gt; statement from the .pm file.</source>
          <target state="translated">모든 자동로드 기능을 생략하십시오. 이것은 &lt;b&gt;-c&lt;/b&gt; 와 동일 하지만 .pm 파일에서 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader&lt;/code&gt; 문을 제거 합니다.</target>
        </trans-unit>
        <trans-unit id="c89bf96a83d88777c4a53a3cada5e03b11bfab80" translate="yes" xml:space="preserve">
          <source>Omit redundant punctuation as long as clarity doesn't suffer.</source>
          <target state="translated">명확성이 손상되지 않는 한 중복 구두점을 생략하십시오.</target>
        </trans-unit>
        <trans-unit id="5939f2980c3053a7b35d91579e70755fbf358beb" translate="yes" xml:space="preserve">
          <source>Omit the XS portion. Used to generate a skeleton pure Perl module. &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-f&lt;/code&gt; are implicitly enabled.</source>
          <target state="translated">XS 부분을 생략하십시오. 스켈레톤 순수 Perl 모듈을 생성하는 데 사용됩니다. &lt;code&gt;-c&lt;/code&gt; 및 &lt;code&gt;-f&lt;/code&gt; 는 내재적으로 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="ab66b48afb255f3fa8074752a39b329797b5aa56" translate="yes" xml:space="preserve">
          <source>Omit the autogenerated stub POD section.</source>
          <target state="translated">자동 생성 된 스텁 POD 섹션을 생략하십시오.</target>
        </trans-unit>
        <trans-unit id="aef75bc39700a2d7f9ba2d4fcc4c938989654f2d" translate="yes" xml:space="preserve">
          <source>Omits creation of the</source>
          <target state="translated">의 생성을 생략</target>
        </trans-unit>
        <trans-unit id="ce977cba7ea14f47b6252159a9ce77942da917fb" translate="yes" xml:space="preserve">
          <source>Omitting the &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; section is equivalent to using an empty one, logically enough, so &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; goes directly back to check the condition at the top of the loop.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 섹션을 생략하는 것은 논리적으로 충분한 빈 섹션을 사용하는 것과 동일하므로 &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 은 루프 맨 위에서 조건을 확인하기 위해 직접 되돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="648601245d456cf14017862c18156a366b17d689" translate="yes" xml:space="preserve">
          <source>Omitting the &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; section is equivalent to using an empty one, logically enough, so &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; goes directly back to check the condition at the top of the loop.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 섹션을 생략하는 것은 논리적으로 충분한 빈 섹션을 사용하는 것과 동일하므로 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 은 루프 맨 위에서 조건을 확인하기 위해 직접 되돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="2170721cf53167c035658d5db7e3986d2f62f2d5" translate="yes" xml:space="preserve">
          <source>Omitting the first argument (input text) means process &lt;code&gt;$_&lt;/code&gt; instead. Omitting the second argument (delimiter brackets) indicates that only &lt;code&gt;'{'&lt;/code&gt; is to be used. Omitting the third argument (prefix argument) implies optional whitespace at the start. Omitting the fourth argument (outermost delimiter brackets) indicates that the value of the second argument is to be used for the outermost delimiters.</source>
          <target state="translated">첫 번째 인수 (입력 텍스트)를 생략하면 프로세스 &lt;code&gt;$_&lt;/code&gt; 대신됩니다. 두 번째 인수 (구분 기호 괄호)를 생략하면 &lt;code&gt;'{'&lt;/code&gt; 만 사용됨을 나타냅니다 . 세 번째 인수 (접두사 인수)를 생략하면 시작시 선택적 공백이 나타납니다. 네 번째 인수 (가장 큰 구분 기호 괄호)를 생략하면 두 번째 인수의 값이 가장 바깥 쪽 구분 기호에 사용됨을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d19163591bedfb142adf27e96746ef3cf121a26f" translate="yes" xml:space="preserve">
          <source>On AIX 4.2 using xlC, we continue:</source>
          <target state="translated">xlC를 사용하는 AIX 4.2에서는 다음을 계속합니다.</target>
        </trans-unit>
        <trans-unit id="b7bebcc7500e38fa33da9de2419b5d4507654e3f" translate="yes" xml:space="preserve">
          <source>On AIX 4.3 using vac, we continue:</source>
          <target state="translated">vac을 사용하는 AIX 4.3에서는 다음을 계속합니다.</target>
        </trans-unit>
        <trans-unit id="164f1a22c1ddad7a43b51fc0e97d9cc8c54ba4c2" translate="yes" xml:space="preserve">
          <source>On ASCII platforms, the resulting characters from the list above are the complete set of ASCII controls. This isn't the case on EBCDIC platforms; see &lt;a href=&quot;perlebcdic#OPERATOR-DIFFERENCES&quot;&gt;OPERATOR DIFFERENCES in perlebcdic&lt;/a&gt; for a full discussion of the differences between these for ASCII versus EBCDIC platforms.</source>
          <target state="translated">ASCII 플랫폼에서 위 목록의 결과 문자는 완전한 ASCII 컨트롤 세트입니다. EBCDIC 플랫폼에서는 그렇지 않습니다. ASCII와 EBCDIC 플랫폼의 차이점에 대한 자세한 내용은 &lt;a href=&quot;perlebcdic#OPERATOR-DIFFERENCES&quot;&gt;perlebcdic의 운영자 차이점&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e4ce9df615081837a49ff8902adf19d0bea73069" translate="yes" xml:space="preserve">
          <source>On ASCII-encoded platforms it is possible to strip characters outside of the printable set using:</source>
          <target state="translated">ASCII로 인코딩 된 플랫폼에서 다음을 사용하여 인쇄 가능 세트 외부의 문자를 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f524bd580ae58f0c6ff9d83f9b34774b97e1a12f" translate="yes" xml:space="preserve">
          <source>On DOS-like platforms, if the program does not contain directory separators, it will first be searched for in the current directory before being searched for on the PATH. On Unix platforms, the program will be searched for strictly on the PATH.</source>
          <target state="translated">DOS와 유사한 플랫폼에서 프로그램에 디렉토리 구분 기호가 없으면 PATH에서 검색하기 전에 현재 디렉토리에서 먼저 검색됩니다. 유닉스 플랫폼에서 프로그램은 PATH에서 엄격하게 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="1cac4dfb85f7858cf9af4b4f306e4164c94a071a" translate="yes" xml:space="preserve">
          <source>On DOSISH systems, backslash is a valid directory separator character. In this case, use of backslash as a quoting character (via GLOB_QUOTE) interferes with the use of backslash as a directory separator. The best (simplest, most portable) solution is to use forward slashes for directory separators, and backslashes for quoting. However, this does not match &quot;normal practice&quot; on these systems. As a concession to user expectation, therefore, backslashes (under GLOB_QUOTE) only quote the glob metacharacters '[', ']', '{', '}', '-', '~', and backslash itself. All other backslashes are passed through unchanged.</source>
          <target state="translated">DOSISH 시스템에서 백 슬래시는 유효한 디렉토리 구분 문자입니다. 이 경우, GLOB_QUOTE를 통해 인용 문자로 백 슬래시를 사용하면 디렉토리 분리 자로 백 슬래시를 사용하는 데 방해가됩니다. 가장 간단하고 이식성이 좋은 솔루션은 디렉토리 구분 기호에 슬래시를 사용하고 인용에 백 슬래시를 사용하는 것입니다. 그러나이 시스템에서 &quot;일반적인 방법&quot;과 일치하지 않습니다. 따라서 사용자 기대에 대한 양보로 백 슬래시 (GLOB_QUOTE 하에서)는 glob 메타 문자 '[', ']', '{', '}', '-', '~'및 백 슬래시 자체 만 인용합니다. 다른 모든 백 슬래시는 변경되지 않은 채 통과합니다.</target>
        </trans-unit>
        <trans-unit id="bc353a101a732e619259516d5005fd73e9056d46" translate="yes" xml:space="preserve">
          <source>On EBCDIC platforms characters in the Latin 1 character set are treated as being part of a literal UTF-EBCDIC character.</source>
          <target state="translated">EBCDIC 플랫폼에서 라틴 1 문자 세트의 문자는 리터럴 UTF-EBCDIC 문자의 일부로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="05835a5188ac319110e1d4a7bb82d82adb8499ed" translate="yes" xml:space="preserve">
          <source>On EBCDIC platforms, prior to v5.22, using &lt;code&gt;\N{U+...}&lt;/code&gt; doesn't work properly.</source>
          <target state="translated">v5.22 이전의 EBCDIC 플랫폼에서 &lt;code&gt;\N{U+...}&lt;/code&gt; 사용하면 제대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="79296614d9a9f53308ccee5fcf367fe461dcdb98" translate="yes" xml:space="preserve">
          <source>On EBCDIC platforms, the internal Unicode encoding form is UTF-EBCDIC instead of UTF-8. The difference is that as UTF-8 is &quot;ASCII-safe&quot; in that ASCII characters encode to UTF-8 as-is, while UTF-EBCDIC is &quot;EBCDIC-safe&quot;, in that all the basic characters (which includes all those that have ASCII equivalents (like &lt;code&gt;&quot;A&quot;&lt;/code&gt; , &lt;code&gt;&quot;0&quot;&lt;/code&gt; , &lt;code&gt;&quot;%&quot;&lt;/code&gt; ,</source>
          <target state="translated">EBCDIC 플랫폼에서 내부 유니 코드 인코딩 양식은 UTF-8 대신 UTF-EBCDIC입니다. 차이점은 ASCII 문자는 그대로 UTF-8로 인코딩한다는 점에서 UTF-8은 &quot;ASCII-safe&quot;이므로 UTF-EBCDIC는 &quot;EBCDIC-safe&quot;이며 모든 기본 문자 (모든 문자 포함)는 ASCII 등가 (예 : &lt;code&gt;&quot;A&quot;&lt;/code&gt; , &lt;code&gt;&quot;0&quot;&lt;/code&gt; , &lt;code&gt;&quot;%&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="24eed6474921c436fc7017c3e9ee9fd9b18bd251" translate="yes" xml:space="preserve">
          <source>On Linux as of perl v5.14.0 the legacy process name will be set with &lt;code&gt;prctl(2)&lt;/code&gt; , in addition to altering the POSIX name via &lt;code&gt;argv[0]&lt;/code&gt; as perl has done since version 4.000. Now system utilities that read the legacy process name such as ps, top and killall will recognize the name you set when assigning to &lt;code&gt;$0&lt;/code&gt; . The string you supply will be cut off at 16 bytes, this is a limitation imposed by Linux.</source>
          <target state="translated">Linux에서 perl v5.14.0부터 레거시 프로세스 이름은 &lt;code&gt;prctl(2)&lt;/code&gt; 로 설정되며 , perl이 4.000 이후로 수행 된 것처럼 &lt;code&gt;argv[0]&lt;/code&gt; 을 통해 POSIX 이름을 변경합니다 . 이제 ps, top 및 killall과 같은 레거시 프로세스 이름을 읽는 시스템 유틸리티는 &lt;code&gt;$0&lt;/code&gt; 할당 할 때 설정 한 이름을 인식합니다 . 제공하는 문자열은 16 바이트에서 잘립니다. 이는 Linux에서 부과하는 제한 사항입니다.</target>
        </trans-unit>
        <trans-unit id="acdfac3cee0fd1507f95a5dcb4019d7d46aa51e5" translate="yes" xml:space="preserve">
          <source>On MSWin32, each thread maintains its own set of environment variables.</source>
          <target state="translated">MSWin32에서 각 스레드는 자체 환경 변수 집합을 유지 관리합니다.</target>
        </trans-unit>
        <trans-unit id="07fed63ea1db8f306a3fcf956ae30aa0f5f797ab" translate="yes" xml:space="preserve">
          <source>On MSWin32, each thread maintains its own the current working directory setting.</source>
          <target state="translated">MSWin32에서 각 스레드는 고유 한 현재 작업 디렉토리 설정을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="fc9baea2d4ac629b8f41cbaaf2320e912f58f4e6" translate="yes" xml:space="preserve">
          <source>On Mac OS, assumes that the last part of the path is a filename unless $no_file is true or a trailing separator &quot;:&quot; is present.</source>
          <target state="translated">Mac OS에서 $ no_file이 true이거나 후미 구분 기호 &quot;:&quot;가 없으면 경로의 마지막 부분은 파일 이름 인 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="2c8cbf9feb69a54cf112ddb280be3a352f96b397" translate="yes" xml:space="preserve">
          <source>On Mac OS, there's nothing to be done. Returns what it's given.</source>
          <target state="translated">Mac OS에서는 수행 할 작업이 없습니다. 주어진 것을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1110960c59d5ed71b666c1e4c9c495538ef1f179" translate="yes" xml:space="preserve">
          <source>On OS/390 or z/OS see the</source>
          <target state="translated">OS / 390 또는 z / OS에서</target>
        </trans-unit>
        <trans-unit id="d3d05f25204078cfb6759aed14497988db83abc4" translate="yes" xml:space="preserve">
          <source>On OSes where temp files are automatically removed when the temp file is closed, calling this function will have no effect other than to remove temporary directories (which may include temporary files).</source>
          <target state="translated">임시 파일을 닫을 때 임시 파일이 자동으로 제거되는 OS에서이 함수를 호출하면 임시 디렉토리 (임시 파일을 포함 할 수 있음)를 제거하는 것 외에 다른 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="d375d4a0af7ab518303234b7c17d1169f40e9bcc" translate="yes" xml:space="preserve">
          <source>On PA-RISC you need a different compiler for 32-bit applications and for 64-bit applications. On PA-RISC, 32-bit objects and 64-bit objects do not mix. Period. There is no different behaviour for HP C-ANSI-C or GNU gcc. So if you require your perl binary to use 64-bit libraries, like Oracle-64bit, you MUST build a 64-bit perl.</source>
          <target state="translated">PA-RISC에서는 32 비트 응용 프로그램과 64 비트 응용 프로그램을위한 다른 컴파일러가 필요합니다. PA-RISC에서 32 비트 개체와 64 비트 개체는 혼합되지 않습니다. 기간. HP C-ANSI-C 또는 GNU gcc에는 다른 동작이 없습니다. 따라서 Oracle 64 비트와 같은 64 비트 라이브러리를 사용하기 위해 perl 바이너리가 필요한 경우 64 비트 perl을 빌드해야합니다.</target>
        </trans-unit>
        <trans-unit id="92d7a8c18ee051a4b37ffd21066565b5d3a9d46d" translate="yes" xml:space="preserve">
          <source>On POSIX systems, that program will likely be GNU Make; on Microsoft Windows, it will be either Microsoft NMake, DMake or GNU Make. See the section on the &lt;a href=&quot;#MAKE&quot;&gt;MAKE&lt;/a&gt; parameter for details.</source>
          <target state="translated">POSIX 시스템에서 해당 프로그램은 GNU Make 일 것입니다. Microsoft Windows에서는 Microsoft NMake, DMake 또는 GNU Make입니다. 자세한 내용은 &lt;a href=&quot;#MAKE&quot;&gt;MAKE&lt;/a&gt; 매개 변수 섹션을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="ec792d74700736cdfd9a5c7544b143a95c42354e" translate="yes" xml:space="preserve">
          <source>On Perl versions before 5.7, Unicode characters with a value over 255 (like lambda or emdash) can't be conveyed. This module does work under such early Perl versions, but in the place of each such character, you get a &quot;?&quot;. Latin-1 characters (characters 160-255) are unaffected.</source>
          <target state="translated">5.7 이전의 Perl 버전에서는 255 이상의 값을 가진 유니 코드 문자 (예 : 람다 또는 엠 대시)를 전달할 수 없습니다. 이 모듈은 초기 Perl 버전에서 작동하지만 이러한 각 문자 대신 &quot;?&quot;가 표시됩니다. 라틴 -1 문자 (문자 160-255)는 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1b4fd9509076b696b649edffe06b6748d3a6e8fc" translate="yes" xml:space="preserve">
          <source>On The Road</source>
          <target state="translated">길에서</target>
        </trans-unit>
        <trans-unit id="3f5f166131dd85ac983f4decac309eb76b2240b2" translate="yes" xml:space="preserve">
          <source>On Unix these calls probably have no effect whatsoever. Elsewhere they alter &quot;\n&quot; to CR,LF translation and possibly cause a special text &quot;end of file&quot; indicator to be written or honoured on read. The effect of making the call after doing any IO to the handle depends on the implementation. (It may be ignored, affect any data which is already buffered as well, or only apply to subsequent data.)</source>
          <target state="translated">유닉스에서는 이러한 호출이 아무 효과가 없습니다. 다른 곳에서는 &quot;\ n&quot;을 CR, LF 변환으로 변경하고 특수한 텍스트 &quot;파일 끝&quot;표시기를 읽거나 읽을 때 표시 될 수 있습니다. 핸들에 IO를 수행 한 후 호출하는 효과는 구현에 따라 다릅니다. (이는 무시되거나 이미 버퍼링 된 데이터에 영향을 주거나 후속 데이터에만 적용됩니다.)</target>
        </trans-unit>
        <trans-unit id="86c676209565e2d780081a941df86b84b21d9627" translate="yes" xml:space="preserve">
          <source>On Unix,</source>
          <target state="translated">유닉스에서는</target>
        </trans-unit>
        <trans-unit id="88e8f2f2ac45a9bfa4ec12f4ed8e00688059ccf6" translate="yes" xml:space="preserve">
          <source>On VMS by default, changes to the %ENV hash persist after perl exits. Subsequent invocations of perl in the same process can inadvertently inherit environment settings that were meant to be temporary.</source>
          <target state="translated">기본적으로 VMS에서 펄이 종료 된 후에도 % ENV 해시에 대한 변경 사항이 유지됩니다. 동일한 프로세스에서 이후에 perl을 호출하면 일시적인 환경 설정을 실수로 상속 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a45916e3343efd4a31048a877153354c7f3a445" translate="yes" xml:space="preserve">
          <source>On VMS only, record reads bypass PerlIO layers and any associated buffering, so you must not mix record and non-record reads on the same filehandle. Record mode mixes with line mode only when the same buffering layer is in use for both modes.</source>
          <target state="translated">VMS에서만 레코드 읽기가 PerlIO 계층 및 연관된 버퍼링을 무시하므로 동일한 파일 핸들에서 레코드 및 비 레코드 읽기를 혼합해서는 안됩니다. 레코드 모드는 동일한 버퍼링 레이어가 두 모드에 모두 사용중인 경우에만 라인 모드와 혼합됩니다.</target>
        </trans-unit>
        <trans-unit id="9795304d9e947203c83b021d72efea5ba3031bdc" translate="yes" xml:space="preserve">
          <source>On VMS systems, arrays tied to environment variables are read-only. Attempting to change anything will cause a warning.</source>
          <target state="translated">VMS 시스템에서 환경 변수에 연결된 어레이는 읽기 전용입니다. 무엇이든 변경하려고하면 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="81ce16b2de32a17abe516725e03bc48e7d14b744" translate="yes" xml:space="preserve">
          <source>On VMS, perl determines the UTC offset from the &lt;code&gt;SYS$TIMEZONE_DIFFERENTIAL&lt;/code&gt; logical name. Although the VMS epoch began at 17-NOV-1858 00:00:00.00, calls to &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; are adjusted to count offsets from 01-JAN-1970 00:00:00.00, just like Unix.</source>
          <target state="translated">VMS에서 perl은 &lt;code&gt;SYS$TIMEZONE_DIFFERENTIAL&lt;/code&gt; 논리 이름 으로부터 UTC 오프셋을 결정합니다 . VMS 시대는 17-NOV-1858 00 : 00 : 00.00에 시작되었지만 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 으로의 호출 은 Unix와 마찬가지로 01-JAN-1970 00 : 00 : 00.00부터 오프셋을 계산하도록 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="4640e9f8e338d51c98fb597af9efcb27c56ecf3e" translate="yes" xml:space="preserve">
          <source>On VMS, some entries in the &lt;code&gt;%ENV&lt;/code&gt; hash are dynamically created when their key is used on a read if they did not previously exist. The values for &lt;code&gt;$ENV{HOME}&lt;/code&gt; , &lt;code&gt;$ENV{TERM}&lt;/code&gt; , &lt;code&gt;$ENV{PATH}&lt;/code&gt; , and &lt;code&gt;$ENV{USER}&lt;/code&gt; , are known to be dynamically generated. The specific names that are dynamically generated may vary with the version of the C library on VMS, and more may exist than are documented.</source>
          <target state="translated">VMS에서 &lt;code&gt;%ENV&lt;/code&gt; 해시 의 일부 항목은 키가 이전에 존재하지 않은 경우 읽기에 사용될 때 동적으로 작성됩니다. 에 대한 값 &lt;code&gt;$ENV{HOME}&lt;/code&gt; , &lt;code&gt;$ENV{TERM}&lt;/code&gt; , &lt;code&gt;$ENV{PATH}&lt;/code&gt; 및 &lt;code&gt;$ENV{USER}&lt;/code&gt; , 동적으로 생성되는 것으로 알려져있다. 동적으로 생성되는 특정 이름은 VMS의 C 라이브러리 버전에 따라 다를 수 있으며 문서화 된 것보다 더 많이 존재할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00ea6af97bd8140ce5328dca64213948bcea1edc" translate="yes" xml:space="preserve">
          <source>On VMS, which has a volume concept, this field will be empty because VMS file specifications are converted to absolute UNIX format and the volume information is transparently included.</source>
          <target state="translated">볼륨 개념이있는 VMS에서 VMS 파일 스펙이 절대 UNIX 형식으로 변환되고 볼륨 정보가 투명하게 포함되므로이 필드는 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7181afce3600b3de6f4aeeecdb2753ed0ec50123" translate="yes" xml:space="preserve">
          <source>On VOS, time values are 32-bit quantities.</source>
          <target state="translated">VOS에서 시간 값은 32 비트 수량입니다.</target>
        </trans-unit>
        <trans-unit id="260fa2754bf084766a1e3d1258ce83d5b5d3b0dc" translate="yes" xml:space="preserve">
          <source>On Win32 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; needs to open the file to determine the link count and update attributes that may have been changed through hard links. Setting &lt;code&gt;${^WIN32_SLOPPY_STAT}&lt;/code&gt; to a true value speeds up &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; by not performing this operation. (Win32)</source>
          <target state="translated">Win32에서 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; 는 파일을 열어서 링크 수를 결정하고 하드 링크를 통해 변경되었을 수있는 속성을 업데이트해야합니다. &lt;code&gt;${^WIN32_SLOPPY_STAT}&lt;/code&gt; 을 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; true 값으로 설정하면 이 작업을 수행하지 않아 stat () 속도가 빨라집니다 . (Win32)</target>
        </trans-unit>
        <trans-unit id="43527614576e6873bffe9e01120e3463ca7900ba" translate="yes" xml:space="preserve">
          <source>On Win32 platforms this</source>
          <target state="translated">Win32 플랫폼에서</target>
        </trans-unit>
        <trans-unit id="82880baf8efa4ec11213dbe5173474c89dad4fe5" translate="yes" xml:space="preserve">
          <source>On Win32 ports only, may be set to an alternative shell that Perl must use internally for executing &quot;backtick&quot; commands or system(). Default is &lt;code&gt;cmd.exe /x/d/c&lt;/code&gt; on WindowsNT and &lt;code&gt;command.com /c&lt;/code&gt; on Windows95. The value is considered space-separated. Precede any character that needs to be protected, like a space or backslash, with another backslash.</source>
          <target state="translated">Win32 포트에서만 Perl이 &quot;backtick&quot;명령 또는 system ()을 실행하기 위해 내부적으로 사용해야하는 대체 쉘로 설정 될 수 있습니다. WindowsNT의 경우 기본값은 &lt;code&gt;cmd.exe /x/d/c&lt;/code&gt; 이고 Windows95의 경우 &lt;code&gt;command.com /c&lt;/code&gt; 입니다. 값은 공백으로 분리 된 것으로 간주됩니다. 공백이나 백 슬래시와 같이 보호해야하는 모든 문자 앞에 다른 백 슬래시를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9e2fd429fcf5069c4431ad927b87b339316ae6b1" translate="yes" xml:space="preserve">
          <source>On Win32 the default in this release (5.14) is &quot;unix crlf&quot;. Win32's &quot;stdio&quot; has a number of bugs/mis-features for Perl IO which are somewhat depending on the version and vendor of the C compiler. Using our own &lt;code&gt;crlf&lt;/code&gt; layer as the buffer avoids those issues and makes things more uniform. The &lt;code&gt;crlf&lt;/code&gt; layer provides CRLF conversion as well as buffering.</source>
          <target state="translated">Win32에서이 릴리스 (5.14)의 기본값은 &quot;unix crlf&quot;입니다. Win32의 &quot;stdio&quot;는 C 컴파일러의 버전과 벤더에 따라 다소 다른 Perl IO에 대한 많은 버그 / 미스 기능을 가지고 있습니다. 버퍼로 자체 &lt;code&gt;crlf&lt;/code&gt; 레이어를 사용 하면 이러한 문제를 피하고 일을 더 균일하게 만듭니다. &lt;code&gt;crlf&lt;/code&gt; 층도 버퍼링 CRLF로 변환을 제공한다.</target>
        </trans-unit>
        <trans-unit id="c661dbe60c2c9116c9b6dd06327729491426c6d8" translate="yes" xml:space="preserve">
          <source>On WinNT &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; can change a file's user and group IDs. On Win9x &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; is a no-op, although this is appropriate since there is no security model.</source>
          <target state="translated">WinNT에서 &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; 은 파일의 사용자 및 그룹 ID를 변경할 수 있습니다. 보안 모델이 없기 때문에 Win9x에서 &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; 은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="691092ab9995db74d07e64291684fba5bdc303c2" translate="yes" xml:space="preserve">
          <source>On Windows this value may be empty if the uri is to a network share, in which case the 'share' property will be defined. Additionally, volume specifications that use '|' as ':' will be converted on read to use ':'.</source>
          <target state="translated">Windows에서 URI가 네트워크 공유 인 경우이 값은 비어있을 수 있으며이 경우 'share'속성이 정의됩니다. 또한 '|'를 사용하는 볼륨 사양 ':'을 사용하도록 ':'을 읽을 때 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="8d5fbf1c54f4cbef1a178b46ad87cba27e8e2dbd" translate="yes" xml:space="preserve">
          <source>On Windows, if &lt;code&gt;make_path&lt;/code&gt; gives you this warning, it may mean that you have exceeded your filesystem's maximum path length.</source>
          <target state="translated">Windows에서 &lt;code&gt;make_path&lt;/code&gt; 가이 경고를 표시하면 파일 시스템의 최대 경로 길이를 초과했음을 의미 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c8b57e0402fd5a94f4f0f14b11ffcf0d1fe5e8c" translate="yes" xml:space="preserve">
          <source>On Windows, only the &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; indirect object syntax will reliably avoid using the shell; &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; LIST&lt;/code&gt; , even with more than one element, will fall back to the shell if the first spawn fails.</source>
          <target state="translated">Windows에서는 &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; 간접 오브젝트 구문 만 쉘 사용을 확실하게 피할 수 있습니다. &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; LIST&lt;/code&gt; 는 하나 이상의 요소가 있더라도 첫 번째 스폰이 실패하면 쉘로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="3489286293a7a904918509c734ebd323e4463d4f" translate="yes" xml:space="preserve">
          <source>On Windows, only the &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; indirect object syntax will reliably avoid using the shell; &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; LIST&lt;/code&gt; , even with more than one element, will fall back to the shell if the first spawn fails.</source>
          <target state="translated">Windows에서는 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; 간접 오브젝트 구문 만 쉘 사용을 확실하게 피할 수 있습니다. &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; LIST&lt;/code&gt; 는 하나 이상의 요소가 있더라도 첫 번째 스폰이 실패하면 쉘로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="1feb74b008066b7c35338a20235da8f4be77079d" translate="yes" xml:space="preserve">
          <source>On Windows, you can use the &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Console&quot;&gt;Win32::Console&lt;/a&gt; module. After creating an object for the output filehandle you want to affect, call the &lt;code&gt;Cls&lt;/code&gt; method:</source>
          <target state="translated">Windows에서는 &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Console&quot;&gt;Win32 :: Console&lt;/a&gt; 모듈을 사용할 수 있습니다 . 영향을 줄 출력 파일 핸들에 대한 객체를 만든 후 &lt;code&gt;Cls&lt;/code&gt; 메서드를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="868e4a545e3b36ea0e0005a952326d136f092bcb" translate="yes" xml:space="preserve">
          <source>On a 64-bit &lt;code&gt;perl&lt;/code&gt; , you can get even larger dates for those really long running projects:</source>
          <target state="translated">64 비트 &lt;code&gt;perl&lt;/code&gt; 에서는 실제로 오래 실행되는 프로젝트에 대해 더 큰 날짜를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c8e386d10b1658b7fab41743c4a6c61db5c0bb8" translate="yes" xml:space="preserve">
          <source>On a Unix-like system, these documentation files will usually also be available as manpages for use with the</source>
          <target state="translated">유닉스 계열 시스템에서 이러한 문서 파일은 일반적으로 맨 페이지로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="660953bc195f4695e40bafcb35d1864a5ea40fb9" translate="yes" xml:space="preserve">
          <source>On a binary string, you would do things like:</source>
          <target state="translated">이진 문자열에서는 다음과 같은 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="c2fd3df54f8bb812f03e4f16967bb0e0784afad2" translate="yes" xml:space="preserve">
          <source>On a new install it is &quot;C:\Windows CE Tools&quot;. Goto &quot;C:\Windows CE Tools&quot; in a file manager and see if &quot;C:\Windows CE Tools\wce400\STANDARDSDK\Include\Armv4&quot; exists on your disk. If not the SDKROOT need to be changed to &quot;C:\Program Files\Windows CE Tools&quot;.</source>
          <target state="translated">새로 설치하는 경우 &quot;C : \ Windows CE Tools&quot;입니다. 파일 관리자에서 &quot;C : \ Windows CE Tools&quot;로 이동하여 디스크에 &quot;C : \ Windows CE Tools \ wce400 \ STANDARDSDK \ Include \ Armv4&quot;가 있는지 확인하십시오. 그렇지 않으면 SDKROOT를 &quot;C : \ Program Files \ Windows CE Tools&quot;로 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="299062bf85cb6925da5e4883a42054b0da9f24d7" translate="yes" xml:space="preserve">
          <source>On a related note, if you do use &lt;code&gt;(X)PUSH[iunp]&lt;/code&gt;, then you're going to need a &lt;code&gt;dTARG&lt;/code&gt; in your variable declarations so that the &lt;code&gt;*PUSH*&lt;/code&gt; macros can make use of the local variable &lt;code&gt;TARG&lt;/code&gt; . See also &lt;code&gt;dTARGET&lt;/code&gt; and &lt;code&gt;dXSTARG&lt;/code&gt; .</source>
          <target state="translated">관련 메모에서 &lt;code&gt;(X)PUSH[iunp]&lt;/code&gt; 하는 경우 &lt;code&gt;*PUSH*&lt;/code&gt; 매크로가 로컬 변수 &lt;code&gt;TARG&lt;/code&gt; 를 사용할 수 있도록 변수 선언에 &lt;code&gt;dTARG&lt;/code&gt; 가 필요합니다 . &lt;code&gt;dTARGET&lt;/code&gt; 및 &lt;code&gt;dXSTARG&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d381c7864f9bd0c496e832a74c2bc6e826af96f2" translate="yes" xml:space="preserve">
          <source>On a successful match, the &lt;code&gt;$REGERROR&lt;/code&gt; variable will be set to FALSE, and the &lt;code&gt;$REGMARK&lt;/code&gt; variable will be set to the name of the last &lt;code&gt;(*MARK:NAME)&lt;/code&gt; pattern executed. See the explanation for the &lt;code&gt;(*MARK:NAME)&lt;/code&gt; verb below for more details.</source>
          <target state="translated">성공적으로 일치하면 &lt;code&gt;$REGERROR&lt;/code&gt; 변수는 FALSE로 설정되고 &lt;code&gt;$REGMARK&lt;/code&gt; 변수는 마지막으로 실행 된 &lt;code&gt;(*MARK:NAME)&lt;/code&gt; 패턴 의 이름으로 설정됩니다 . 자세한 내용은 아래 &lt;code&gt;(*MARK:NAME)&lt;/code&gt; 동사에 대한 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="df6a4ca6e213ccefa4b99c6f895a6d3c5870376c" translate="yes" xml:space="preserve">
          <source>On a text string, you would do things like:</source>
          <target state="translated">텍스트 문자열에서 다음과 같은 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="16575e035ca925e5fa5bb99a005281cd0246209f" translate="yes" xml:space="preserve">
          <source>On all platforms except MSWin32, the setting for the current working directory is shared among all threads such that changing it in one thread (e.g., using &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt;) will affect all the threads in the application.</source>
          <target state="translated">MSWin32를 제외한 모든 플랫폼에서 현재 작업 디렉토리에 대한 설정은 모든 스레드간에 공유되므로 한 스레드에서 변경 (예 : &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; )하면 응용 프로그램의 모든 스레드에 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="986faea7525ededb053c5e26524df4fe094d07f8" translate="yes" xml:space="preserve">
          <source>On all the released versions of Solaris (8, 9 and 10) you need to make sure the following packages are installed (this info is extracted from the Solaris FAQ):</source>
          <target state="translated">릴리스 된 모든 Solaris (8, 9 및 10) 버전에서 다음 패키지가 설치되어 있는지 확인해야합니다 (이 정보는 Solaris FAQ에서 추출 됨).</target>
        </trans-unit>
        <trans-unit id="7579bfbb9367171f6983e33cf0c36d410d39ce7e" translate="yes" xml:space="preserve">
          <source>On certain platforms like Win32, OS/2, VMS, and AIX, it is necessary to perform some actions before invoking the linker. The &lt;code&gt;ExtUtils::Mksymlists&lt;/code&gt; module does this, writing files used by the linker during the creation of shared libraries for dynamic extensions. The names of any files written will be returned as a list.</source>
          <target state="translated">Win32, OS / 2, VMS 및 AIX와 같은 특정 플랫폼에서는 링커를 호출하기 전에 몇 가지 조치를 수행해야합니다. &lt;code&gt;ExtUtils::Mksymlists&lt;/code&gt; 모듈은이 작업을 수행, 동적 확장을위한 공유 라이브러리를 작성하는 동안 링커가 사용하는 파일을 작성. 작성된 파일 이름은 목록으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="48eee9c0d3be3641023bdfbc12b873ba074e7d8a" translate="yes" xml:space="preserve">
          <source>On certain platforms, for example Windows, not all the fields returned by stat() can be compared. For example, the C</source>
          <target state="translated">Windows와 같은 특정 플랫폼에서 stat ()에 의해 반환 된 모든 필드를 비교할 수있는 것은 아닙니다. 예를 들어 C</target>
        </trans-unit>
        <trans-unit id="0337022749da68904dc67bf7ba7a67afde209ea2" translate="yes" xml:space="preserve">
          <source>On creation of a new message queue &lt;code&gt;FLAGS&lt;/code&gt; is used to set the permissions. Be careful not to set any flags that the Sys V IPC implementation does not allow: in some systems setting execute bits makes the operations fail.</source>
          <target state="translated">새 메시지 대기열을 만들 때 &lt;code&gt;FLAGS&lt;/code&gt; 를 사용하여 권한을 설정합니다. Sys V IPC 구현에서 허용하지 않는 플래그를 설정하지 않도록주의하십시오. 일부 시스템에서는 실행 비트를 설정하면 작업이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="82a6576fe44e35482e50d08d072f3b166203f73f" translate="yes" xml:space="preserve">
          <source>On creation of a new semaphore set &lt;code&gt;FLAGS&lt;/code&gt; is used to set the permissions. Be careful not to set any flags that the Sys V IPC implementation does not allow: in some systems setting execute bits makes the operations fail.</source>
          <target state="translated">새 세마포어 세트를 작성할 때 &lt;code&gt;FLAGS&lt;/code&gt; 는 권한을 설정하는 데 사용됩니다. Sys V IPC 구현에서 허용하지 않는 플래그를 설정하지 않도록주의하십시오. 일부 시스템에서는 실행 비트를 설정하면 작업이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="2a590d182300640c7833d62b48486238fd75ebb4" translate="yes" xml:space="preserve">
          <source>On creation of a new shared memory segment &lt;code&gt;FLAGS&lt;/code&gt; is used to set the permissions. Be careful not to set any flags that the Sys V IPC implementation does not allow: in some systems setting execute bits makes the operations fail.</source>
          <target state="translated">새로운 공유 메모리 세그먼트를 만들 때 &lt;code&gt;FLAGS&lt;/code&gt; 를 사용하여 권한을 설정합니다. Sys V IPC 구현에서 허용하지 않는 플래그를 설정하지 않도록주의하십시오. 일부 시스템에서는 실행 비트를 설정하면 작업이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="475139521c9cdabb77d7980af3eb2a8b5f2f65f2" translate="yes" xml:space="preserve">
          <source>On demand loader for PerlIO layers and root of PerlIO::* name space</source>
          <target state="translated">PerlIO 레이어 및 PerlIO의 루트 온 디맨드 로더 :: * 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="f2bd0e6ad9c12f3371f3ea04fa2670eb6d77c58f" translate="yes" xml:space="preserve">
          <source>On each line are two expressions that do the same thing. The left-hand versions operate on the array &lt;code&gt;@a&lt;/code&gt; . The right-hand versions operate on the array that is referred to by &lt;code&gt;$aref&lt;/code&gt; . Once they find the array they're operating on, both versions do the same things to the arrays.</source>
          <target state="translated">각 줄에는 같은 일을하는 두 가지 표현이 있습니다. 왼쪽 버전은 &lt;code&gt;@a&lt;/code&gt; 배열에서 작동합니다 . 오른쪽 버전은 &lt;code&gt;$aref&lt;/code&gt; 참조되는 배열에서 작동합니다 . 그들이 작동하는 어레이를 찾으면 두 버전 모두 어레이와 동일한 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="9b2fc3f2e5f903dbf2df61622a774607772dffe7" translate="yes" xml:space="preserve">
          <source>On entry</source>
          <target state="translated">입국시</target>
        </trans-unit>
        <trans-unit id="d373dfecfc1b40b4191bc53322c596729a91c216" translate="yes" xml:space="preserve">
          <source>On error, &lt;code&gt;$out&lt;/code&gt; will be</source>
          <target state="translated">오류가 발생하면 &lt;code&gt;$out&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="6d9c828155c10075b78663a197d9675f7b0c4a6f" translate="yes" xml:space="preserve">
          <source>On error, &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; behaves just like select(2): it returns -1 and sets &lt;code&gt;$!&lt;/code&gt; .</source>
          <target state="translated">오류가 발생하면 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 는 select (2)와 같이 동작합니다. -1을 반환하고 &lt;code&gt;$!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="44a9825ad010a78ae9dfacedfc100780572dc5b3" translate="yes" xml:space="preserve">
          <source>On error, &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; will not tell you which files it could not remove. If you want to know which files you could not remove, try them one at a time:</source>
          <target state="translated">오류가 발생하면 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 하면 제거 할 수없는 파일이 표시되지 않습니다. 제거 할 수없는 파일을 알려면 한 번에 하나씩 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="819a867a035e72ad9106196135c7d9f4e3277f0c" translate="yes" xml:space="preserve">
          <source>On error, &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; behaves just like select(2): it returns -1 and sets &lt;code&gt;$!&lt;/code&gt; .</source>
          <target state="translated">오류가 발생하면 &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 는 select (2)와 같이 동작합니다. -1을 반환하고 &lt;code&gt;$!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a02d8cd61d158290b01862aca1060c57ef007153" translate="yes" xml:space="preserve">
          <source>On error, &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; will not tell you which files it could not remove. If you want to know which files you could not remove, try them one at a time:</source>
          <target state="translated">오류가 발생하면 &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 하면 제거 할 수없는 파일이 표시되지 않습니다. 제거 할 수없는 파일을 알려면 한 번에 하나씩 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="45e73f10ec8215e1c14a06d24df3320696729415" translate="yes" xml:space="preserve">
          <source>On error, it returns a</source>
          <target state="translated">오류가 발생하면</target>
        </trans-unit>
        <trans-unit id="18136bfa0b529aa75c0ac9c1c7bf6a9d9e72f925" translate="yes" xml:space="preserve">
          <source>On failure &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be returned and &lt;code&gt;$@&lt;/code&gt; will contain the reason for the failure.</source>
          <target state="translated">실패시 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 리턴되고 &lt;code&gt;$@&lt;/code&gt; 에 실패 이유가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="42061a94fa2069016ce15d6e815f1341a1d2cabd" translate="yes" xml:space="preserve">
          <source>On failure, $decoder now contains an error message so the whole thing would be as follows;</source>
          <target state="translated">실패시 $ decoder는 이제 오류 메시지를 포함하므로 전체 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4946878f668a0186d10fe06797278b27abd1a3bc" translate="yes" xml:space="preserve">
          <source>On failure, all of these values (except the remaining text) are &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">실패하면,이 모든 값 (나머지 텍스트 제외)은 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e0a91a2a84ece7b39d4d347acdd9155aefa71bb9" translate="yes" xml:space="preserve">
          <source>On failure, the &lt;code&gt;$REGERROR&lt;/code&gt; variable will be set to the ARG value of the verb pattern, if the verb was involved in the failure of the match. If the ARG part of the pattern was omitted, then &lt;code&gt;$REGERROR&lt;/code&gt; will be set to the name of the last &lt;code&gt;(*MARK:NAME)&lt;/code&gt; pattern executed, or to TRUE if there was none. Also, the &lt;code&gt;$REGMARK&lt;/code&gt; variable will be set to FALSE.</source>
          <target state="translated">실패시 &lt;code&gt;$REGERROR&lt;/code&gt; 변수는 동사가 일치 실패와 관련이있는 경우 동사 패턴의 ARG 값으로 설정됩니다. 패턴의 ARG 부분이 생략 된 경우, &lt;code&gt;$REGERROR&lt;/code&gt; 는 마지막으로 실행 된 &lt;code&gt;(*MARK:NAME)&lt;/code&gt; 패턴 의 이름으로 설정 되거나,없는 경우 TRUE로 설정됩니다. 또한 &lt;code&gt;$REGMARK&lt;/code&gt; 변수는 FALSE로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="5064a047349d10718c6c646e1984f32902ee6b9f" translate="yes" xml:space="preserve">
          <source>On failure, the &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call returns an undefined value and probably sets &lt;code&gt;$!&lt;/code&gt; to contain the reason the file could not be tied.</source>
          <target state="translated">실패시, &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 호출은 정의되지 않은 값을 반환하고 아마도 &lt;code&gt;$!&lt;/code&gt; 파일을 묶을 수없는 이유를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="6499c88e3c2522e878e6f7bffd23feb1b280e5ce" translate="yes" xml:space="preserve">
          <source>On input, it converts the bytes expected to be in the specified character set and encoding to Perl string data (Unicode and Perl's internal Unicode encoding, UTF-8). On output, it converts Perl string data into the specified character set and encoding.</source>
          <target state="translated">입력시, 지정된 문자 세트 및 인코딩에있을 것으로 예상되는 바이트를 Perl 문자열 데이터 (유니 코드 및 Perl의 내부 유니 코드 인코딩, UTF-8)로 변환합니다. 출력시, Perl 문자열 데이터를 지정된 문자 세트 및 인코딩으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="a604823a1a15074f7b145c1cca70f834c1350b88" translate="yes" xml:space="preserve">
          <source>On most Unix platforms, the &lt;code&gt;CHLD&lt;/code&gt; (sometimes also known as &lt;code&gt;CLD&lt;/code&gt; ) signal has special behavior with respect to a value of &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; . Setting &lt;code&gt;$SIG{CHLD}&lt;/code&gt; to &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; on such a platform has the effect of not creating zombie processes when the parent process fails to &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; on its child processes (i.e., child processes are automatically reaped). Calling &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;$SIG{CHLD}&lt;/code&gt; set to &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; usually returns &lt;code&gt;-1&lt;/code&gt; on such platforms.</source>
          <target state="translated">대부분의 Unix 플랫폼에서 &lt;code&gt;CHLD&lt;/code&gt; (때로는 &lt;code&gt;CLD&lt;/code&gt; 라고도 함 ) 신호는 &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; 값과 관련하여 특별한 동작을합니다 . 설정 &lt;code&gt;$SIG{CHLD}&lt;/code&gt; 에 &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; 부모 프로세스가 실패 할 때와 같은 플랫폼에서하는 좀비 프로세스를 생성하지 않는 효과가있다 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; 자식 프로세스에 (즉, 자식 프로세스가 자동으로 수확된다). &lt;code&gt;$SIG{CHLD}&lt;/code&gt; 가 &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; 로 설정된 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; 를 호출 &lt;code&gt;-1&lt;/code&gt; 일반적 으로 이러한 플랫폼에서 -1이 리턴 됩니다.</target>
        </trans-unit>
        <trans-unit id="42bca4f6aa51b9c47b8c54f57cf475cd9eb5d60c" translate="yes" xml:space="preserve">
          <source>On most operating systems, memory allocated to a program can never be returned to the system. That's why long-running programs sometimes re- exec themselves. Some operating systems (notably, systems that use mmap(2) for allocating large chunks of memory) can reclaim memory that is no longer used, but on such systems, perl must be configured and compiled to use the OS's malloc, not perl's.</source>
          <target state="translated">대부분의 운영 체제에서 프로그램에 할당 된 메모리는 시스템으로 반환 될 수 없습니다. 그렇기 때문에 장기 실행 프로그램이 때때로 스스로 실행됩니다. 일부 운영 체제 (특히 대용량 메모리 할당에 mmap (2)를 사용하는 시스템)는 더 이상 사용되지 않는 메모리를 회수 할 수 있지만 이러한 시스템에서는 perl이 아닌 OS malloc을 사용하도록 perl을 구성하고 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="b3a71ab0d471330a25bbd4385691ed243516aede" translate="yes" xml:space="preserve">
          <source>On most systems, frequent and continual creation and destruction of threads can lead to ever-increasing growth in the memory footprint of the Perl interpreter. While it is simple to just launch threads and then &lt;code&gt;-&amp;gt;join()&lt;/code&gt; or &lt;code&gt;-&amp;gt;detach()&lt;/code&gt; them, for long-lived applications, it is better to maintain a pool of threads, and to reuse them for the work needed, using &lt;a href=&quot;thread/queue&quot;&gt;queues&lt;/a&gt; to notify threads of pending work. The CPAN distribution of this module contains a simple example (</source>
          <target state="translated">대부분의 시스템에서 스레드를 빈번하고 지속적으로 작성 및 제거하면 Perl 인터프리터의 메모리 사용량이 계속 증가 할 수 있습니다. 스레드를 시작한 다음 &lt;code&gt;-&amp;gt;join()&lt;/code&gt; 또는 &lt;code&gt;-&amp;gt;detach()&lt;/code&gt; 하는 것이 간단하지만 수명이 긴 응용 프로그램의 경우 스레드 풀을 유지 관리하고 &lt;a href=&quot;thread/queue&quot;&gt;대기열을&lt;/a&gt; 사용하여 필요한 작업에 재사용하는 것이 좋습니다 스레드에 보류중인 작업을 통지합니다. 이 모듈의 CPAN 배포는 간단한 예를 포함합니다 (</target>
        </trans-unit>
        <trans-unit id="09b3ddc53760535691fb4b1738d8256a44f591bc" translate="yes" xml:space="preserve">
          <source>On most systems, you are not allowed to change the ownership of the file unless you're the superuser, although you should be able to change the group to any of your secondary groups. On insecure systems, these restrictions may be relaxed, but this is not a portable assumption. On POSIX systems, you can detect this condition this way:</source>
          <target state="translated">대부분의 시스템에서 수퍼 유저가 아닌 경우 파일의 소유권을 변경할 수는 없지만 그룹을 보조 그룹으로 변경할 수는 있습니다. 안전하지 않은 시스템에서는 이러한 제한이 완화 될 수 있지만 이는 이식 가능한 가정이 아닙니다. POSIX 시스템에서는 다음과 같은 방법으로이 조건을 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cfd993657bc1e027b5466df69e07a3c252bb4a5" translate="yes" xml:space="preserve">
          <source>On newer 64 bit versions of OpenVMS, a process setting now controls if the quoting is needed to preserve the case of command line arguments.</source>
          <target state="translated">최신 64 비트 버전의 OpenVMS에서 이제 프로세스 설정은 명령 행 인수의 대소 문자를 보존하기 위해 인용이 필요한지 여부를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="d67a298149fc32636cbc2cf9ffd43cf9447cc565" translate="yes" xml:space="preserve">
          <source>On older versions of perl, negative epoch (&lt;code&gt;time_t&lt;/code&gt; ) values, which are not officially supported by the POSIX standards, are known not to work on some systems. These include MacOS (pre-OSX) and Win32.</source>
          <target state="translated">이전 버전의 perl에서는 POSIX 표준에서 공식적으로 지원하지 않는 음의 에포크 ( &lt;code&gt;time_t&lt;/code&gt; ) 값이 일부 시스템에서 작동하지 않는 것으로 알려져 있습니다. 여기에는 MacOS (pre-OSX) 및 Win32가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b2a99aa4e31ced8b38922d7821d5fd751e2740ad" translate="yes" xml:space="preserve">
          <source>On operating systems with the concept of a volume the second element of a file:// is considered to the be volume specification for the file. Thus on Win32 this routine returns the volume, on other operating systems this returns nothing.</source>
          <target state="translated">볼륨 개념이있는 운영 체제에서 file : //의 두 번째 요소는 파일의 볼륨 스펙으로 간주됩니다. 따라서 Win32에서이 루틴은 볼륨을 반환하고 다른 운영 체제에서는 아무것도 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4f2532376ddc057f764de9bec478db299bbe8f82" translate="yes" xml:space="preserve">
          <source>On perl version 5.12.0 and newer, negative epoch values are fully supported.</source>
          <target state="translated">perl 버전 5.12.0 이상에서는 음의 에포크 값이 완전히 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="134a9f11ec0d2ae5a78490a1f61d61a762f1fd76" translate="yes" xml:space="preserve">
          <source>On perl versions older than 5.12.0, the range of dates that can be actually be handled depends on the size of &lt;code&gt;time_t&lt;/code&gt; (usually a signed integer) on the given platform. Currently, this is 32 bits for most systems, yielding an approximate range from Dec 1901 to Jan 2038.</source>
          <target state="translated">5.12.0 이전의 perl 버전에서 실제로 처리 할 수있는 날짜 범위 는 주어진 플랫폼 의 &lt;code&gt;time_t&lt;/code&gt; (일반적으로 부호있는 정수) 의 크기에 따라 다릅니다 . 현재 이것은 대부분의 시스템에서 32 비트이며 1901 년 12 월부터 2038 년 1 월까지의 대략적인 범위를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6022d860b9d735662ef67778672104ce7f7a553c" translate="yes" xml:space="preserve">
          <source>On platforms where &lt;code&gt;need_prelink()&lt;/code&gt; returns true, &lt;code&gt;prelink()&lt;/code&gt; will be called automatically.</source>
          <target state="translated">&lt;code&gt;need_prelink()&lt;/code&gt; 가 true를 반환하는 플랫폼에서는 &lt;code&gt;prelink()&lt;/code&gt; 가 자동으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d4f25eb75f8ca9d9043202ca7699535809aaaa12" translate="yes" xml:space="preserve">
          <source>On platforms where it matters, be sure to call &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; on the descriptors that you pass to Storable functions.</source>
          <target state="translated">중요한 플랫폼에서는 Storable 함수에 전달하는 설명자에서 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; 를 호출해야 합니다.</target>
        </trans-unit>
        <trans-unit id="741623a3d6fbed74253acab5fef8f32b395ea643" translate="yes" xml:space="preserve">
          <source>On pre-C99 compilers, &lt;code&gt;bool&lt;/code&gt; is defined as equivalent to &lt;code&gt;char&lt;/code&gt; . Consequently assignment of any larger type to a &lt;code&gt;bool&lt;/code&gt; is unsafe and may be truncated. The &lt;code&gt;cBOOL&lt;/code&gt; macro exists to cast it correctly.</source>
          <target state="translated">C99 이전의 컴파일러에서 &lt;code&gt;bool&lt;/code&gt; 은 &lt;code&gt;char&lt;/code&gt; 와 동등한 것으로 정의됩니다 . 따라서 더 큰 유형의 &lt;code&gt;bool&lt;/code&gt; 할당하는 것은 안전하지 않으며 잘릴 수 있습니다. &lt;code&gt;cBOOL&lt;/code&gt; 의 매크로 제대로 캐스팅 존재한다.</target>
        </trans-unit>
        <trans-unit id="2c58ed64b6e077e0a2ecc28338446ee744bcc90f" translate="yes" xml:space="preserve">
          <source>On rare occasion, such as a database read, you may be given encoded text you need to decode.</source>
          <target state="translated">드문 경우이지만 데이터베이스 읽기와 같이 디코딩해야하는 인코딩 된 텍스트가 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2d3547ac3050c26cb1992ceb42fa15fd067f32b" translate="yes" xml:space="preserve">
          <source>On return, the reference will overwrite the hash slot in the symbol table specified by the *some_hash typeglob. This is a somewhat tricky way of passing around references cheaply when you don't want to have to remember to dereference variables explicitly.</source>
          <target state="translated">리턴시 참조는 * some_hash typeglob에 의해 지정된 기호 테이블의 해시 슬롯을 겹쳐 씁니다. 변수를 명시 적으로 역 참조하는 것을 기억하고 싶지 않을 때 참조를 저렴하게 전달하는 다소 까다로운 방법입니다.</target>
        </trans-unit>
        <trans-unit id="aca1e4ba9558a35891aca8fc5a87a5dbef0654bd" translate="yes" xml:space="preserve">
          <source>On simple groups, such as the pattern &lt;code&gt;(?&amp;gt; [^()]+ )&lt;/code&gt;, a comparable effect may be achieved by negative look-ahead, as in &lt;code&gt;[^()]+ (?! [^()] )&lt;/code&gt;. This was only 4 times slower on a string with 1000000 &lt;code&gt;a&lt;/code&gt; s.</source>
          <target state="translated">패턴 &lt;code&gt;(?&amp;gt; [^()]+ )&lt;/code&gt; 과 같은 간단한 그룹에서는 &lt;code&gt;[^()]+ (?! [^()] )&lt;/code&gt; 와 같이 부정적인 미리보기로 비슷한 효과를 얻을 수 있습니다 . 이것은 1000000 &lt;code&gt;a&lt;/code&gt; 의 문자열에서 단지 4 배 느 렸습니다 .</target>
        </trans-unit>
        <trans-unit id="85e1720394957ce5ba2b00bf5b14ca83e7b1f8cb" translate="yes" xml:space="preserve">
          <source>On some (but not all) operating systems assigning to &lt;code&gt;$0&lt;/code&gt; modifies the argument area that the &lt;code&gt;ps&lt;/code&gt; program sees. On some platforms you may have to use special &lt;code&gt;ps&lt;/code&gt; options or a different &lt;code&gt;ps&lt;/code&gt; to see the changes. Modifying the &lt;code&gt;$0&lt;/code&gt; is more useful as a way of indicating the current program state than it is for hiding the program you're running.</source>
          <target state="translated">일부 운영 체제 (모두는 아님)에서 &lt;code&gt;$0&lt;/code&gt; 할당 하면 &lt;code&gt;ps&lt;/code&gt; 프로그램이 보는 인수 영역이 수정 됩니다. 일부 플랫폼 에서는 변경 사항을 확인 하기 위해 특별한 &lt;code&gt;ps&lt;/code&gt; 옵션이나 다른 &lt;code&gt;ps&lt;/code&gt; 를 사용해야 할 수도 있습니다 . &lt;code&gt;$0&lt;/code&gt; 수정하면 실행중인 프로그램을 숨기는 것보다 현재 프로그램 상태를 나타내는 방법으로 더 유용합니다.</target>
        </trans-unit>
        <trans-unit id="84e7fe0a4e81ece19af2adc12a430c2ffe84e1ae" translate="yes" xml:space="preserve">
          <source>On some OS's where . has special meaning VERSION_SYM may be used in place of VERSION.</source>
          <target state="translated">일부 OS의 경우. VERSION_SYM 대신 VERSION 대신 사용할 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
