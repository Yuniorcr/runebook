<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="b39e88e61083334da27e22ac3304f5322910c7a2" translate="yes" xml:space="preserve">
          <source>Single-letter properties match all characters in any of the two-letter sub-properties starting with the same letter. &lt;code&gt;LC&lt;/code&gt; and &lt;code&gt;L&amp;amp;&lt;/code&gt; are special: both are aliases for the set consisting of everything matched by &lt;code&gt;Ll&lt;/code&gt; , &lt;code&gt;Lu&lt;/code&gt; , and &lt;code&gt;Lt&lt;/code&gt; .</source>
          <target state="translated">단일 문자 특성은 동일한 문자로 시작하는 두 문자 하위 특성의 모든 문자와 일치합니다. &lt;code&gt;LC&lt;/code&gt; 와 &lt;code&gt;L&amp;amp;&lt;/code&gt; 는 특별합니다. 둘 다 &lt;code&gt;Ll&lt;/code&gt; , &lt;code&gt;Lu&lt;/code&gt; 및 &lt;code&gt;Lt&lt;/code&gt; 와 일치하는 모든 항목으로 구성된 세트의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="47784ae534e76f07f938e74b6b49c2e04c524d60" translate="yes" xml:space="preserve">
          <source>Single-step flag. Will be true if the API will stop at the next statement.</source>
          <target state="translated">단일 단계 플래그. 다음 명령문에서 API가 중지되면 true입니다.</target>
        </trans-unit>
        <trans-unit id="3fd72cbf421902beaf4893343701c7e9f292181e" translate="yes" xml:space="preserve">
          <source>Sinograms like &amp;ldquo;東京&amp;rdquo; come back with character names of &lt;code&gt;CJK UNIFIED IDEOGRAPH-6771&lt;/code&gt; and &lt;code&gt;CJK UNIFIED IDEOGRAPH-4EAC&lt;/code&gt; , because their &amp;ldquo;names&amp;rdquo; vary. The CPAN &lt;code&gt;Unicode::Unihan&lt;/code&gt; module has a large database for decoding these (and a whole lot more), provided you know how to understand its output.</source>
          <target state="translated">&amp;ldquo;東京&amp;rdquo;과 같은 사이 &lt;code&gt;CJK UNIFIED IDEOGRAPH-4EAC&lt;/code&gt; 은&amp;ldquo;이름&amp;rdquo;이 다르기 때문에 &lt;code&gt;CJK UNIFIED IDEOGRAPH-6771&lt;/code&gt; 및 CJK UNIFIED IDEOGRAPH-4EAC 의 문자 이름으로 돌아옵니다 . CPAN &lt;code&gt;Unicode::Unihan&lt;/code&gt; 모듈에는 출력을 이해하는 방법을 알고있는 경우이를 디코딩하기위한 큰 데이터베이스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="28e8fd907b0e11131190209772e747eaed820c59" translate="yes" xml:space="preserve">
          <source>Site-specific perl extensions and modules can be installed in one of two places. Put architecture-independent files into:</source>
          <target state="translated">사이트 별 perl 확장 및 모듈은 두 위치 중 하나에 설치할 수 있습니다. 아키텍처 독립적 인 파일을 다음에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="00832815e260edfba2e83c2f4b5a6a35db1c2d1c" translate="yes" xml:space="preserve">
          <source>Six such conversions are possible:</source>
          <target state="translated">6 가지 변환이 가능합니다 :</target>
        </trans-unit>
        <trans-unit id="43701334f4b3da3fdeb3363278217ac0f215873d" translate="yes" xml:space="preserve">
          <source>Size of the function table. This is compared against the value PerlIO code &quot;knows&quot; as a compatibility check. Future versions</source>
          <target state="translated">기능 테이블의 크기. 이것은 PerlIO 코드 값과 호환성 검사로 &quot;알고&quot;비교됩니다. 향후 버전</target>
        </trans-unit>
        <trans-unit id="936d52e1c615ea7024397f6ff1aeb7c89ebd5bad" translate="yes" xml:space="preserve">
          <source>Size, Endianness, and BOM</source>
          <target state="translated">크기, 엔디안 및 BOM</target>
        </trans-unit>
        <trans-unit id="0ec62bfb6670c34f50ed4190d4e6017dc34d76d5" translate="yes" xml:space="preserve">
          <source>Skip a package when throwing autodie exceptions</source>
          <target state="translated">Autodie 예외가 발생할 때 패키지 건너 뛰기</target>
        </trans-unit>
        <trans-unit id="57a18bbc33fb3b107b0f37ec04073b6f8f1aa7be" translate="yes" xml:space="preserve">
          <source>Skip sub-char mapping should there be no code point.</source>
          <target state="translated">코드 포인트가 없으면 하위 문자 매핑을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="fa22bcdeb4f395bdc09dc2fd5b11b93a885994fb" translate="yes" xml:space="preserve">
          <source>Skip the real Pod formatting, and just show the raw Pod source (&lt;b&gt;U&lt;/b&gt;nformatted)</source>
          <target state="translated">실제 포드 형식을 건너 뛰고 원시 포드 소스 만 표시하십시오 ( &lt;b&gt;U&lt;/b&gt; nformatted).</target>
        </trans-unit>
        <trans-unit id="3e59adfb26a9113df0d5c476d39a18d0087952f5" translate="yes" xml:space="preserve">
          <source>Skip this section if the XSUB functions are supposed to be called from other modules only; read it only if you call your XSUBs from the code in your module, or have a &lt;code&gt;BOOT:&lt;/code&gt; section in your XS file (see &lt;a href=&quot;perlxs#The-BOOT%3a-Keyword&quot;&gt;The BOOT: Keyword in perlxs&lt;/a&gt;). What is described here is equally applicable to the &lt;a href=&quot;dynaloader&quot;&gt;DynaLoader&lt;/a&gt; interface.</source>
          <target state="translated">XSUB 함수가 다른 모듈에서만 호출되어야하는 경우이 섹션을 건너 뛰십시오. 모듈의 코드에서 XSUB를 호출하거나 XS 파일에 &lt;code&gt;BOOT:&lt;/code&gt; 섹션 이있는 경우에만 읽으십시오 ( &lt;a href=&quot;perlxs#The-BOOT%3a-Keyword&quot;&gt;BOOT : perlxs의 키워드&lt;/a&gt; 참조 ). 여기에 설명 된 내용은 &lt;a href=&quot;dynaloader&quot;&gt;DynaLoader&lt;/a&gt; 인터페이스 에도 동일하게 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="54ab6781ff6514e41583039acc42db3e0f3c9201" translate="yes" xml:space="preserve">
          <source>Skips all the tests, using the given &lt;code&gt;$reason&lt;/code&gt; . Exits immediately with 0.</source>
          <target state="translated">주어진 &lt;code&gt;$reason&lt;/code&gt; 사용하여 모든 테스트를 건너 뜁니다 . 0으로 즉시 종료합니다.</target>
        </trans-unit>
        <trans-unit id="563adc0d862d00d2bcc7549833d1039985aead2a" translate="yes" xml:space="preserve">
          <source>Skips the current test, reporting &lt;code&gt;$why&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$why&lt;/code&gt; 보고하여 현재 테스트를 건너 뜁니다 .</target>
        </trans-unit>
        <trans-unit id="ca1ac1071abc2c48fe8c683c23437c17bcd0e5ba" translate="yes" xml:space="preserve">
          <source>Skips to the next compressed data stream in the input file/buffer. If a new compressed data stream is found, the eof marker will be cleared and &lt;code&gt;$.&lt;/code&gt; will be reset to 0.</source>
          <target state="translated">입력 파일 / 버퍼에서 다음 압축 데이터 스트림으로 건너 뜁니다. 새로운 압축 데이터 스트림이 발견되면 eof 마커가 지워지고 &lt;code&gt;$.&lt;/code&gt; 0으로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="e59d0602eb0550fd0dbf5d82907d6271ae4af6ea" translate="yes" xml:space="preserve">
          <source>Sleeps for the number of microseconds (millionths of a second) specified. Returns the number of microseconds actually slept. Can sleep for more than one second, unlike the &lt;code&gt;usleep&lt;/code&gt; system call. Can also sleep for zero seconds, which often works like a</source>
          <target state="translated">지정된 마이크로 초 (밀리 초) 동안 대기합니다. 실제로 잠든 시간 (마이크로 초)을 반환합니다. &lt;code&gt;usleep&lt;/code&gt; 시스템 호출 과 달리 1 초 이상 잠을 잘 수 있습니다. 0 초 동안 절전 모드로 전환 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7c111ccc19a7463efac9caa48bfd176015106c5" translate="yes" xml:space="preserve">
          <source>Sleeps for the number of nanoseconds (1e9ths of a second) specified. Returns the number of nanoseconds actually slept (accurate only to microseconds, the nearest thousand of them). Can sleep for more than one second. Can also sleep for zero seconds, which often works like a</source>
          <target state="translated">지정된 나노초 (1e9 초) 동안 대기합니다. 실제로 잠든 나노초의 수를 반환합니다 (마이크로 초, 가장 가까운 천 단위). 1 초 이상 잠을 잘 수 있습니다. 0 초 동안 절전 모드로 전환 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="858360f4742bec3dbad2b4b1586f95ca8cfce48d" translate="yes" xml:space="preserve">
          <source>Sleeps for the number of nanoseconds (1e9ths of a second) specified. Returns the number of nanoseconds actually slept. The $which is the &quot;clock id&quot;, as with clock_gettime() and clock_getres(). The flags default to zero but &lt;code&gt;TIMER_ABSTIME&lt;/code&gt; can specified (must be exported explicitly) which means that &lt;code&gt;$nanoseconds&lt;/code&gt; is not a time interval (as is the default) but instead an absolute time. Can sleep for more than one second. Can also sleep for zero seconds, which often works like a</source>
          <target state="translated">지정된 나노초 (1e9 초) 동안 대기합니다. 실제로 잠든 나노초 수를 반환합니다. clock_gettime () 및 clock_getres ()와 같이 &quot;클럭 ID&quot;인 $입니다. 플래그는 기본적으로 0이지만 &lt;code&gt;TIMER_ABSTIME&lt;/code&gt; 을 지정할 수 있습니다 (명시 적으로 내 보내야 함). 이는 &lt;code&gt;$nanoseconds&lt;/code&gt; 가 시간 간격 (기본값)이 아니라 절대 시간 임을 의미합니다 . 1 초 이상 잠을 잘 수 있습니다. 0 초 동안 절전 모드로 전환 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfc9358c36664745e87042ffeea926ba49acc8f0" translate="yes" xml:space="preserve">
          <source>Sleeps for the specified amount of seconds. Returns the number of seconds actually slept (a floating point value). This function can be imported, resulting in a nice drop-in replacement for the &lt;code&gt;&lt;a href=&quot;../functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; provided with perl, see the &lt;a href=&quot;#EXAMPLES&quot;&gt;EXAMPLES&lt;/a&gt; below.</source>
          <target state="translated">지정된 시간 (초) 동안 대기합니다. 실제로 잠은 시간 (초)을 반환합니다 (부동 소수점 값). 이 기능을 가져 와서 perl과 함께 제공 되는 &lt;code&gt;&lt;a href=&quot;../functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 를 대체 할 수 있습니다 ( 아래 &lt;a href=&quot;#EXAMPLES&quot;&gt;예&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="a455933ba1827ec6d2d6cea6cb61c05bd3954351" translate="yes" xml:space="preserve">
          <source>Slices</source>
          <target state="translated">Slices</target>
        </trans-unit>
        <trans-unit id="de97696f04df2d455746fc0459c7a0334ac08b94" translate="yes" xml:space="preserve">
          <source>Slices in scalar context return the last item of the slice.</source>
          <target state="translated">스칼라 컨텍스트의 조각은 조각의 마지막 항목을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fade4867f2281855741bb2fdfae6ec6bfe669774" translate="yes" xml:space="preserve">
          <source>Slicing operations and parentheses cause the right-hand side to be evaluated in list context:</source>
          <target state="translated">슬라이싱 작업과 괄호로 인해 목록 컨텍스트에서 오른쪽이 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="71625e10c96350176b8faecaf24d1d897cf6efce" translate="yes" xml:space="preserve">
          <source>Slightly modified by Arthur Bergman to fit the new thread model/module.</source>
          <target state="translated">새로운 스레드 모델 / 모듈에 맞게 Arthur Bergman이 약간 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="c05c92e1201b3c7a99b14a3196c426c41067b9ce" translate="yes" xml:space="preserve">
          <source>Smartmatch Operator</source>
          <target state="translated">스마트 매치 연산자</target>
        </trans-unit>
        <trans-unit id="e4adce585ab904a3b57996c9eacd1526a8856e59" translate="yes" xml:space="preserve">
          <source>Smartmatching of Objects</source>
          <target state="translated">객체의 스마트 매칭</target>
        </trans-unit>
        <trans-unit id="fcef3abf224b18a1a9539b5cd1a74a21f40eb21d" translate="yes" xml:space="preserve">
          <source>Smartmatching one hash against another reports whether both contain the same keys, no more and no less. This could be used to see whether two records have the same field names, without caring what values those fields might have. For example:</source>
          <target state="translated">하나의 해시를 다른 해시에 스마트 매칭하면 둘 다 동일한 키를 포함하는지 여부를보고합니다. 이를 통해 두 필드가 어떤 값을 가질 지 신경 쓰지 않고 두 레코드가 동일한 필드 이름을 갖는지 여부를 확인할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4460e52ce30ee2f7dab472f65e7bc2c1c88dffad" translate="yes" xml:space="preserve">
          <source>So I got smart: I decided to be lazy and let the C compiler parse the C, which would spit out debugger stabs for me to read. These were much easier to parse. It's still not a pretty program, but at least it's more robust.</source>
          <target state="translated">그래서 나는 똑똑해졌다 : 나는 게으 르기로 결정하고 C 컴파일러가 C를 파싱하게하여 디버거 스테 이브를 읽을 수있게했다. 이것들은 파싱하기가 훨씬 쉬웠습니다. 그것은 여전히 ​​예쁜 프로그램은 아니지만 적어도 더 강력합니다.</target>
        </trans-unit>
        <trans-unit id="a1f5ce193c65cebf4de4614792ca39a016541f36" translate="yes" xml:space="preserve">
          <source>So a typical call to check would look like this:</source>
          <target state="translated">따라서 일반적인 확인 호출은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="32bf3b4ebf1dd24fdccf516f7c267bd10f4fed6f" translate="yes" xml:space="preserve">
          <source>So assuming the database created above, we can use &lt;code&gt;get_dup&lt;/code&gt; like this:</source>
          <target state="translated">위에서 생성 한 데이터베이스를 가정하면 다음 과 같이 &lt;code&gt;get_dup&lt;/code&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9531481e3958e36f87e15fe09a502608d674e17a" translate="yes" xml:space="preserve">
          <source>So called because of a similar construct in &lt;b&gt;shells&lt;/b&gt; that pretends that the &lt;b&gt;lines&lt;/b&gt; following the &lt;b&gt;command&lt;/b&gt; are a separate &lt;b&gt;file&lt;/b&gt; to be fed to the command, up to some terminating string. In Perl, however, it&amp;rsquo;s just a fancy form of quoting.</source>
          <target state="translated">그래서 때문에 비슷한 구조의라는 &lt;b&gt;쉘&lt;/b&gt; 그 척 것을 &lt;b&gt;선&lt;/b&gt; 다음 &lt;b&gt;명령은&lt;/b&gt; 별도입니다 &lt;b&gt;파일&lt;/b&gt; 일부 종료 문자열로 명령에 공급되는 최대. 그러나 Perl에서는 단지 멋진 인용 형식 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="93e9a6ece24ada54b55dc7612c9389e7a638c36b" translate="yes" xml:space="preserve">
          <source>So each subroutine is born with an array of scratchpads (of length 1). On each entry to the subroutine it is checked that the current depth of the recursion is not more than the length of this array, and if it is, new scratchpad is created and pushed into the array.</source>
          <target state="translated">따라서 각 서브 루틴은 길이가 1 인 스크래치 패드 배열로 생성됩니다. 서브 루틴의 각 항목에서 재귀의 현재 깊이가이 배열의 길이보다 크지 않은지 확인하고, 새 스크래치 패드가 작성되어 배열로 푸시됩니다.</target>
        </trans-unit>
        <trans-unit id="bfd2a2cfe6e08c35c8f0019242b9920756d8258f" translate="yes" xml:space="preserve">
          <source>So far so good. But suppose the way you're implementing this is:</source>
          <target state="translated">여태까지는 그런대로 잘됐다. 그러나 이것을 구현하는 방법이 다음과 같다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="99d938c6031e3ad535ec502cea56c5d218d4389a" translate="yes" xml:space="preserve">
          <source>So far so good. Those of you who have been paying attention will have spotted that the tied object hasn't been used so far. So lets add an extra method to the Remember class to allow comments to be included in the file; say, something like this:</source>
          <target state="translated">여태까지는 그런대로 잘됐다. 주의를 기울인 사람들은 지금까지 묶인 물체가 사용되지 않았 음을 발견했을 것입니다. 주석을 파일에 포함 할 수 있도록 Remember 클래스에 추가 메소드를 추가하십시오. 다음과 같이 말하십시오.</target>
        </trans-unit>
        <trans-unit id="438b9b4e31229df657e054c261ee9d298ca8b103" translate="yes" xml:space="preserve">
          <source>So far we've merely tried to find and list the experimental features and infer their inception, versions, etc. There's a lot of speculation here.</source>
          <target state="translated">지금까지 우리는 단지 실험적인 특징을 찾아서 나열하고 그것들의 시작, 버전 등을 추론하려고 시도했습니다. 여기에는 많은 추측이 있습니다.</target>
        </trans-unit>
        <trans-unit id="10bc3a4c124b48037408d12298d27779d339f321" translate="yes" xml:space="preserve">
          <source>So far, so good. With the knowledge above you can already perform searches with just about any literal string regexp you can dream up. Here is a</source>
          <target state="translated">여태까지는 그런대로 잘됐다. 위의 지식을 사용하면 상상할 수있는 리터럴 문자열 정규 표현식으로 이미 검색을 수행 할 수 있습니다. 여기에</target>
        </trans-unit>
        <trans-unit id="8af65d96d3224572aaaeff6426ae992e0bd5b192" translate="yes" xml:space="preserve">
          <source>So far, we're using just the normal list return mechanism. What happens if you want to pass or return a hash? Well, if you're using only one of them, or you don't mind them concatenating, then the normal calling convention is ok, although a little expensive.</source>
          <target state="translated">지금까지는 일반적인 목록 반환 메커니즘 만 사용하고 있습니다. 해시를 전달하거나 반환하려는 경우 어떻게됩니까? 글쎄, 당신이 그들 중 하나만 사용하거나 연결을 신경 쓰지 않는다면, 약간의 비싸지 만 정상적인 호출 규칙은 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="6a1a83e9f4437f40c54f1506b859ac7294d0d128" translate="yes" xml:space="preserve">
          <source>So far, we've seen literals used as templates. If the list of pack items doesn't have fixed length, an expression constructing the template is required (whenever, for some reason, &lt;code&gt;()*&lt;/code&gt; cannot be used). Here's an example: To store named string values in a way that can be conveniently parsed by a C program, we create a sequence of names and null terminated ASCII strings, with &lt;code&gt;=&lt;/code&gt; between the name and the value, followed by an additional delimiting null byte. Here's how:</source>
          <target state="translated">지금까지 템플릿으로 사용 된 리터럴을 보았습니다. 팩 항목 목록의 길이가 고정되어 있지 않으면 템플릿을 구성하는식이 필요합니다 (어떤 이유로 든 &lt;code&gt;()*&lt;/code&gt; 를 사용할 수없는 경우). 예를 들면 다음과 같습니다. C 프로그램에서 편리하게 구문 분석 할 수있는 방식으로 명명 된 문자열 값을 저장하기 위해 이름과 값 사이에 &lt;code&gt;=&lt;/code&gt; 가 포함 된 일련의 이름과 null로 끝나는 ASCII 문자열을 만든 다음 추가로 구분되는 null 바이트 . 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7a5692420708108a4d7ad47094be88b57cf9bf66" translate="yes" xml:space="preserve">
          <source>So for English (with Bracket Notation) &lt;code&gt;&quot;...[quant,_1,file]...&quot;&lt;/code&gt; is fine (for 0 it returns &quot;0 files&quot;, for 1 it returns &quot;1 file&quot;, and for more it returns &quot;2 files&quot;, etc.)</source>
          <target state="translated">따라서 영어 (대괄호 표기법 사용)의 경우 &lt;code&gt;&quot;...[quant,_1,file]...&quot;&lt;/code&gt; 은 괜찮습니다 (0의 경우 &quot;0 파일&quot;을 반환하고 1의 경우 &quot;1 파일&quot;을 반환 함). 2 개 파일 &quot;등)</target>
        </trans-unit>
        <trans-unit id="8477c048b776b6250b8d3a6b206bd8a95a79a9ff" translate="yes" xml:space="preserve">
          <source>So for example, instead of using:</source>
          <target state="translated">예를 들어 다음을 사용하는 대신</target>
        </trans-unit>
        <trans-unit id="23a15c81788a2c5aff56ccaef77af7e0b8ce44eb" translate="yes" xml:space="preserve">
          <source>So given the diagram above, Perl will search &lt;code&gt;Child&lt;/code&gt; , &lt;code&gt;Father&lt;/code&gt; , &lt;code&gt;PaternalGrandparent&lt;/code&gt; , &lt;code&gt;SharedGreatGrandParent&lt;/code&gt; , &lt;code&gt;Mother&lt;/code&gt; , and finally &lt;code&gt;MaternalGrandparent&lt;/code&gt; . This may be a problem because now we're looking in &lt;code&gt;SharedGreatGrandParent&lt;/code&gt;</source>
          <target state="translated">따라서 위의 다이어그램에서 Perl은 &lt;code&gt;Child&lt;/code&gt; , &lt;code&gt;Father&lt;/code&gt; , &lt;code&gt;PaternalGrandparent&lt;/code&gt; , &lt;code&gt;SharedGreatGrandParent&lt;/code&gt; , &lt;code&gt;Mother&lt;/code&gt; 및 &lt;code&gt;MaternalGrandparent&lt;/code&gt; 검색 합니다. 이것은 우리가 &lt;code&gt;SharedGreatGrandParent&lt;/code&gt; 를 보고 있기 때문에 문제가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91f4e47cc018c4b1c4ca9fc78408994ad8035bd1" translate="yes" xml:space="preserve">
          <source>So here is the bottom line--if you are sure that control will revert back to the enclosing Perl scope fairly quickly after the end of your callback, then it isn't absolutely necessary to dispose explicitly of any temporaries you may have created. Mind you, if you are at all uncertain about what to do, it doesn't do any harm to tidy up anyway.</source>
          <target state="translated">결론은 다음과 같습니다. 콜백이 끝난 후 컨트롤이 엔 클로징 Perl 스코프로 상당히 빨리 되돌아 갈 것이라고 확신한다면 생성 한 임시 파일을 명시 적으로 폐기 할 필요는 없습니다. 당신이 무엇을 해야할지 전혀 확실하지 않다면 어쨌든 정리해도 아무런 해를 끼치 지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4443d502fbd614fe670f624b7a8d6e87d74c5b32" translate="yes" xml:space="preserve">
          <source>So hopefully you've now got a few ideas about what's good to modularise. Let's now see how it's done.</source>
          <target state="translated">이제 모듈화하기에 좋은 아이디어가 생겼기를 바랍니다. 이제 어떻게되는지 보자.</target>
        </trans-unit>
        <trans-unit id="6d3a27421600e7d4abecd702bd20845b8466123d" translate="yes" xml:space="preserve">
          <source>So how do I use a proxy with File::Fetch?</source>
          <target state="translated">그렇다면 File :: Fetch와 함께 프록시를 어떻게 사용합니까?</target>
        </trans-unit>
        <trans-unit id="9d00ee45ac1982b7db0dbf721dd3e3787ed6d62f" translate="yes" xml:space="preserve">
          <source>So how do you use a source filter in a Perl script? Above, I said that a source filter is just a special kind of module. Like all Perl modules, a source filter is invoked with a use statement.</source>
          <target state="translated">그렇다면 Perl 스크립트에서 소스 필터를 어떻게 사용합니까? 위에서 소스 필터는 특별한 종류의 모듈이라고 말했습니다. 모든 Perl 모듈과 마찬가지로 소스 필터는 use 문으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="6cca2cb75a50d0827a566440232066af85d09fbe" translate="yes" xml:space="preserve">
          <source>So how does it work?</source>
          <target state="translated">어떻게 작동합니까?</target>
        </trans-unit>
        <trans-unit id="9612f816ae3d1d599129006ddc23ec570699e275" translate="yes" xml:space="preserve">
          <source>So if you take for example the shell command</source>
          <target state="translated">예를 들어 쉘 명령을 사용하면</target>
        </trans-unit>
        <trans-unit id="557e6fd5bed4c1d07e89cc778dd5ffa04e712afb" translate="yes" xml:space="preserve">
          <source>So if you want to check the validity of the encoding, surround the expression with &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; block as follows;</source>
          <target state="translated">따라서 인코딩의 유효성을 확인하려면 다음과 같이 식을 &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; 블록으로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="d7e30a7ebf49e6593b8da91cf7504894e9cfa473" translate="yes" xml:space="preserve">
          <source>So if you were to supply a new, complete, top-level source file to add to Perl, you should conform to this peculiar practice by yourself selecting an appropriate quotation from Tolkien, retaining the original spelling and punctuation and using the same format the rest of the quotes are in. Indirect and oblique is just fine; remember, it's a metaphor, so being meta is, after all, what it's for.</source>
          <target state="translated">따라서 Perl에 추가 할 새롭고 완전한 최상위 소스 파일을 제공하려면 Tolkien에서 적절한 견적을 선택하고 원래 철자와 구두점을 그대로 유지하고 나머지 형식과 동일한 형식을 사용하여이 고유 한 관행을 준수해야합니다 인용 부호가있다. 간접적이고 비스듬한 것은 괜찮다. 메타포는 메타포라는 사실을 기억하십시오. 결국 메타라는 것은 그 목적을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="02bb4252af15d73e7777da1a95cce444353d918a" translate="yes" xml:space="preserve">
          <source>So if you're working with Unicode data, consult the documentation of every module you're using if there are any issues with Unicode data exchange. If the documentation does not talk about Unicode at all, suspect the worst and probably look at the source to learn how the module is implemented. Modules written completely in Perl shouldn't cause problems. Modules that directly or indirectly access code written in other programming languages are at risk.</source>
          <target state="translated">따라서 유니 코드 데이터로 작업하는 경우 유니 코드 데이터 교환에 문제가있는 경우 사용중인 모든 모듈의 설명서를 참조하십시오. 문서가 유니 코드에 대해 전혀 이야기하지 않는다면 최악의 상황을 의심하고 소스를보고 모듈이 어떻게 구현되는지 알아보십시오. Perl로 완전히 작성된 모듈은 문제를 일으키지 않아야합니다. 다른 프로그래밍 언어로 작성된 코드에 직접 또는 간접적으로 액세스하는 모듈이 위험합니다.</target>
        </trans-unit>
        <trans-unit id="e319523cadbb2780f0ef0af26ce5a7a559c73594" translate="yes" xml:space="preserve">
          <source>So in VMS its pm_to_blib.ts.</source>
          <target state="translated">VMS에서는 pm_to_blib.ts입니다.</target>
        </trans-unit>
        <trans-unit id="3bce9b15392a6c8658669f57b4a2decac3558eb6" translate="yes" xml:space="preserve">
          <source>So instead you'll want to do something like this:</source>
          <target state="translated">대신 다음과 같은 작업을 원할 것입니다.</target>
        </trans-unit>
        <trans-unit id="6161c23b3048d528f32556aeffc6deb23d6328c9" translate="yes" xml:space="preserve">
          <source>So it is round-trip safe for \xF9\xF9. But if the line above is upside down, here is what happens.</source>
          <target state="translated">따라서 \ xF9 \ xF9에 대해 왕복 안전합니다. 그러나 위의 줄이 거꾸로되어 있으면 다음과 같이됩니다.</target>
        </trans-unit>
        <trans-unit id="c06ae4675003e825258b16549181d9f72cc7560a" translate="yes" xml:space="preserve">
          <source>So it's clearer and best to use the compound form when specifying blocks. And be sure that is what you really really want to do. In most cases scripts are what you want instead.</source>
          <target state="translated">따라서 블록을 지정할 때 복합 형식을 사용하는 것이 더 명확하고 가장 좋습니다. 그리고 그것이 당신이 정말로하고 싶은 일인지 확인하십시오. 대부분의 경우 스크립트가 대신 원하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3007e0313fdaf4be553a40db748fe3ab3979d2d6" translate="yes" xml:space="preserve">
          <source>So just remember always to use the array or hash constructors with &lt;code&gt;[]&lt;/code&gt; or &lt;code&gt;{}&lt;/code&gt; , and you'll be fine, although it's not always optimally efficient.</source>
          <target state="translated">따라서 항상 &lt;code&gt;[]&lt;/code&gt; 또는 &lt;code&gt;{}&lt;/code&gt; 과 함께 배열 또는 해시 생성자를 사용하는 것을 잊지 마십시오. 항상 최적의 효율성은 아니지만 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="28f6b3059bd71a14d4d6430ebaa792ae77f9b5ae" translate="yes" xml:space="preserve">
          <source>So much for textual data. Let's get onto the meaty stuff that &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; are best at: handling binary formats for numbers. There is, of course, not just one binary format - life would be too simple - but Perl will do all the finicky labor for you.</source>
          <target state="translated">텍스트 데이터의 경우 너무 많습니다. 이제 그 고기 물건에하자 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 숫자 바이너리 형식을 처리 :에 최고입니다. 물론 이진 형식은 하나뿐입니다. 인생은 너무 단순 할 것입니다. 그러나 Perl은 모든 까다로운 작업을 수행 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="19e5670a7ba385b708ff4bcfadcd36a0825afece" translate="yes" xml:space="preserve">
          <source>So now this code would be written:</source>
          <target state="translated">이제이 코드가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="7ec657e348cc94be548b290696e0a818e7f982d5" translate="yes" xml:space="preserve">
          <source>So now you have a file ending in .tar.gz (or, less often, .zip). You know there's a tasty module inside. There are four steps you must now take:</source>
          <target state="translated">이제 .tar.gz (또는 .zip)로 끝나는 파일이 있습니다. 당신은 내부에 맛있는 모듈이 있다는 것을 알고 있습니다. 이제 네 단계를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="9f7f09ef2fcd4d20ffdab1795e6c221c8b2cdf50" translate="yes" xml:space="preserve">
          <source>So please select carefully what library you want to use.</source>
          <target state="translated">사용할 라이브러리를 신중하게 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="fc4d504736579a86ac1ba1abd47d391cec08a768" translate="yes" xml:space="preserve">
          <source>So put in parentheses to say what you really mean.</source>
          <target state="translated">괄호로 묶어 실제로 의미하는 바를 말하십시오.</target>
        </trans-unit>
        <trans-unit id="291a379872204cd90f4de2f2a608af9f0d7dabed" translate="yes" xml:space="preserve">
          <source>So specifically, autoloaded functions cannot see package lexicals (this applies to both the &lt;b&gt;SelfLoader&lt;/b&gt; and the Autoloader). The &lt;code&gt;vars&lt;/code&gt; pragma provides an alternative to defining package-level globals that will be visible to autoloaded routines. See the documentation on &lt;b&gt;vars&lt;/b&gt; in the pragma section of &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;.</source>
          <target state="translated">따라서 자동로드 된 함수는 패키지 어휘를 볼 수 없습니다 (이는 &lt;b&gt;SelfLoader&lt;/b&gt; 및 Autoloader 모두에 적용됨 ). 은 &lt;code&gt;vars&lt;/code&gt; 프라그가 자동으로 적재 루틴 표시되는 패키지 레벨의 전역을 정의의 대안을 제공한다. &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; 의 pragma 섹션 에서 &lt;b&gt;vars&lt;/b&gt; 에 대한 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="178e0296c43b2c22ca3149a0d363aa4b6a82de7c" translate="yes" xml:space="preserve">
          <source>So that's how we consume and produce fixed-width data. Let's recap what we've seen of &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; so far:</source>
          <target state="translated">이것이 우리가 고정 폭 데이터를 소비하고 생산하는 방법입니다. 우리가 무엇을 본 적이하자 정리해 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 지금까지 :</target>
        </trans-unit>
        <trans-unit id="da5a5de8356ec781cae3674738f4fa4085230f11" translate="yes" xml:space="preserve">
          <source>So the Perl interface would look like this</source>
          <target state="translated">따라서 Perl 인터페이스는 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="eb361df349469f52fd13dc7f637fd6d3f4002c01" translate="yes" xml:space="preserve">
          <source>So the Perl subroutine would look like this:</source>
          <target state="translated">따라서 Perl 서브 루틴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f9e5e29abec6c42a24502ee051f01eb881622a3a" translate="yes" xml:space="preserve">
          <source>So the exit codes are...</source>
          <target state="translated">종료 코드는 ...</target>
        </trans-unit>
        <trans-unit id="ecdcbf5b6eec0983bdba576e908b1b991d7bdaa0" translate="yes" xml:space="preserve">
          <source>So the methods &lt;code&gt;PrintID&lt;/code&gt; and &lt;code&gt;Display&lt;/code&gt; can be invoked like this:</source>
          <target state="translated">따라서 &lt;code&gt;PrintID&lt;/code&gt; 및 &lt;code&gt;Display&lt;/code&gt; 메소드를 다음 과 같이 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="050bc5740a1b6bb30a161c3c46fabef260c75737" translate="yes" xml:space="preserve">
          <source>So this:</source>
          <target state="translated">그래서 이거:</target>
        </trans-unit>
        <trans-unit id="65f64a88a88a2a42947aa812e415dc968ce4fc3b" translate="yes" xml:space="preserve">
          <source>So to repeat always use SvOK() to check whether an sv is defined.</source>
          <target state="translated">따라서 반복하려면 항상 SvOK ()를 사용하여 sv가 정의되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="ec007077340f2b45239679ca4cc61f38315a3433" translate="yes" xml:space="preserve">
          <source>So what happened to dTHR?</source>
          <target state="translated">dTHR은 어떻게 되었습니까?</target>
        </trans-unit>
        <trans-unit id="dd71b3066f2c37ca89d49c13416a448baf2ad1f1" translate="yes" xml:space="preserve">
          <source>So what has this got to do with &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;? Well, if you want to compose a Unicode string (that is internally encoded as UTF-8), you can do so by using template code &lt;code&gt;U&lt;/code&gt; . As an example, let's produce the Euro currency symbol (code number 0x20AC):</source>
          <target state="translated">이것이 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 과 어떤 관련이 있습니까? 내부적으로 UTF-8로 인코딩 된 유니 코드 문자열을 작성하려면 템플릿 코드 &lt;code&gt;U&lt;/code&gt; 를 사용하면됩니다 . 예를 들어, 유로화 기호 (코드 번호 0x20AC)를 만들어 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="76db05e5ac37110bc4537d598a8e57f24d0e7d58" translate="yes" xml:space="preserve">
          <source>So what is the big problem? Well, if you are expecting Perl to tidy up those temporaries for you, you might be in for a long wait. For Perl to dispose of your temporaries, control must drop back to the enclosing scope at some stage. In the event driven scenario that may never happen. This means that, as time goes on, your program will create more and more temporaries, none of which will ever be freed. As each of these temporaries consumes some memory your program will eventually consume all the available memory in your system--kapow!</source>
          <target state="translated">그렇다면 큰 문제는 무엇입니까? 글쎄, 만약 당신이 Perl이 당신을 위해 그 임시적인 것들을 정리할 것을 기대한다면, 당신은 오래 기다려야 할 것입니다. Perl이 임시를 처리하려면 제어가 어떤 단계에서 둘러싸는 범위로 되돌아 가야합니다. 발생하지 않는 이벤트 중심 시나리오에서. 이것은 시간이 지남에 따라 프로그램이 점점 더 많은 임시를 만들며 그 어느 것도 해방되지 않을 것임을 의미합니다. 이러한 각 임시 메모리가 약간의 메모리를 소비함에 따라 프로그램은 결국 시스템에서 사용 가능한 모든 메모리 인 kapow를 소비하게됩니다!</target>
        </trans-unit>
        <trans-unit id="49dd0c06fd8f279176f457e7dd90bd0af2090341" translate="yes" xml:space="preserve">
          <source>So what's new?</source>
          <target state="translated">새로운 소식있어?</target>
        </trans-unit>
        <trans-unit id="8be287051544a93972a5fe33ce5f2eed6334bad0" translate="yes" xml:space="preserve">
          <source>So when the output is a filehandle it will carry out a seek to the eof before writing any compressed data. If the output is a filename, it will be opened for appending. If the output is a buffer, all compressed data will be appended to the existing buffer.</source>
          <target state="translated">따라서 출력이 파일 핸들 인 경우 압축 된 데이터를 쓰기 전에 eof를 검색합니다. 출력이 파일 이름이면 추가를 위해 열립니다. 출력이 버퍼 인 경우 모든 압축 된 데이터가 기존 버퍼에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="2b16151fbc25d8d9908507f5cf41dca81006fcb5" translate="yes" xml:space="preserve">
          <source>So when the output is a filehandle it will carry out a seek to the eof before writing any uncompressed data. If the output is a filename, it will be opened for appending. If the output is a buffer, all uncompressed data will be appended to the existing buffer.</source>
          <target state="translated">따라서 출력이 파일 핸들 인 경우 압축되지 않은 데이터를 쓰기 전에 eof를 검색합니다. 출력이 파일 이름이면 추가를 위해 열립니다. 출력이 버퍼 인 경우 압축되지 않은 모든 데이터가 기존 버퍼에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="faf320f95dede4954f64d637d17b4ef0ec2ac56b" translate="yes" xml:space="preserve">
          <source>So when we parse &lt;code&gt;/foo/&lt;/code&gt; we see something like the following table. The left shows what is being parsed, and the number indicates where the next regop would go. The stuff on the right is the trace output of the graph. The names are chosen to be short to make it less dense on the screen. 'tsdy' is a special form of &lt;code&gt;regtail()&lt;/code&gt; which does some extra analysis.</source>
          <target state="translated">따라서 &lt;code&gt;/foo/&lt;/code&gt; 파싱 하면 다음 표와 같은 것이 보입니다. 왼쪽은 구문 분석중인 내용을 나타내고 숫자는 다음 regop의 위치를 ​​나타냅니다. 오른쪽에있는 것은 그래프의 트레이스 출력입니다. 이름은 화면에서 밀도가 떨어지도록 짧게 선택됩니다. 'tsdy'는 추가적인 분석을 수행 하는 특별한 형태의 &lt;code&gt;regtail()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4ca42b2545bb9f74c7dfcf26ad336456861738d0" translate="yes" xml:space="preserve">
          <source>So why is UNINST=1 not the default?</source>
          <target state="translated">그렇다면 UNINST = 1이 기본값이 아닌 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="5764d39b6b45dd4fdf0407e6dadfbf8730c1c2c3" translate="yes" xml:space="preserve">
          <source>So why use these? They produce better diagnostics on failure. &lt;code&gt;ok()&lt;/code&gt; cannot know what you are testing for (beyond the name), but &lt;code&gt;is()&lt;/code&gt; and &lt;code&gt;isnt()&lt;/code&gt; know what the test was and why it failed. For example this test:</source>
          <target state="translated">왜 이것을 사용합니까? 고장에 대한 진단이 향상됩니다. &lt;code&gt;ok()&lt;/code&gt; 는 (이름을 넘어서) 무엇을 테스트하고 있는지 알 수 없지만 &lt;code&gt;is()&lt;/code&gt; 와 &lt;code&gt;isnt()&lt;/code&gt; 는 테스트가 무엇이며 실패한 이유를 알고 있습니다. 예를 들어이 테스트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0723871c8efb4af11337b70788bc11e5f341de34" translate="yes" xml:space="preserve">
          <source>So why would you ever want to use a Unix domain socket instead of a simpler named pipe? Because a named pipe doesn't give you sessions. You can't tell one process's data from another's. With socket programming, you get a separate session for each client; that's why accept() takes two arguments.</source>
          <target state="translated">그렇다면 왜 단순한 파이프 대신에 유닉스 도메인 소켓을 사용하고 싶습니까? 명명 된 파이프는 세션을 제공하지 않기 때문입니다. 한 프로세스의 데이터를 다른 프로세스의 데이터로 알 수 없습니다. 소켓 프로그래밍을 사용하면 각 클라이언트마다 별도의 세션이 있습니다. 따라서 accept ()는 두 개의 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="907dfd8f705f1e1d725ffd018f44b3318d9e84e1" translate="yes" xml:space="preserve">
          <source>So you can figure out what went wrong without rerunning the test.</source>
          <target state="translated">따라서 테스트를 다시 실행하지 않고 무엇이 잘못되었는지 파악할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85a109f19c85f2e155b7bae45252c43e85217d92" translate="yes" xml:space="preserve">
          <source>So you should instead try this;</source>
          <target state="translated">따라서 대신 이것을 시도해야합니다.</target>
        </trans-unit>
        <trans-unit id="99368e21d7e985fc9382de7cbad3270d6b572550" translate="yes" xml:space="preserve">
          <source>So you want to know what &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; actually does?</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 실제로 무엇을하는지 알고 싶 습니까?</target>
        </trans-unit>
        <trans-unit id="d98457d69f47757522cf080b8cba6d90757ec58b" translate="yes" xml:space="preserve">
          <source>So, beside calls like</source>
          <target state="translated">그래서, 같은 통화 옆에</target>
        </trans-unit>
        <trans-unit id="8b676466aa2043751e164c60e8f768fad4f2409b" translate="yes" xml:space="preserve">
          <source>So, for classes and subclasses to have inheritance correctly work with autoloading, you need to ensure stubs are loaded.</source>
          <target state="translated">따라서 클래스와 서브 클래스에서 상속이 자동로드와 올바르게 작동하도록하려면 스텁이로드되어 있는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="3fdc850c88acfeea0034b4d0a5ecf1cbe8955116" translate="yes" xml:space="preserve">
          <source>So, for example, &quot;wb9&quot; means open for writing with the maximum compression using the default strategy and &quot;wb4R&quot; means open for writing with compression level 4 and run-length encoding.</source>
          <target state="translated">예를 들어, &quot;wb9&quot;는 기본 전략을 사용하여 최대 압축으로 쓰기 위해 열기를 의미하고 &quot;wb4R&quot;은 압축 수준 4 및 실행 길이 인코딩으로 쓰기 위해 열려 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="98d3c65256a4087c70ab29c5923eefef7208b53e" translate="yes" xml:space="preserve">
          <source>So, for instance, to pack 20302 to a signed 16 bit integer in your computer's representation you write</source>
          <target state="translated">예를 들어, 컴퓨터 표현에서 부호있는 16 비트 정수로 20302를 패킹하려면</target>
        </trans-unit>
        <trans-unit id="5a026df42e6a15ca497ded704c00f477c0e8e518" translate="yes" xml:space="preserve">
          <source>So, if you see two terms with an &lt;code&gt;=&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt; , between them, you can turn them into a single expression. When you do this, you execute the code in the block on the next line: if you see &lt;code&gt;=&lt;/code&gt; , you'll do the code in line 2. If you see &lt;code&gt;+&lt;/code&gt; , you'll do the code in line 4. It's this code which contributes to the op tree.</source>
          <target state="translated">따라서 &lt;code&gt;=&lt;/code&gt; 또는 &lt;code&gt;+&lt;/code&gt; 가 포함 된 두 개의 용어가 있으면 그 용어를 하나의 표현식으로 바꿀 수 있습니다. 이 작업을 수행 할 때 다음 행의 블록에서 코드를 실행합니다. &lt;code&gt;=&lt;/code&gt; 가 표시 되면 2 행에서 코드를 수행합니다. &lt;code&gt;+&lt;/code&gt; 가 표시되면 4 행에서 코드를 수행하는 것입니다.이 코드입니다 op 트리에 기여합니다.</target>
        </trans-unit>
        <trans-unit id="f012b7bad59a01daf6da8ed100b9c040ae573c55" translate="yes" xml:space="preserve">
          <source>So, if you want to collect memory info in a cycle, you may call</source>
          <target state="translated">따라서주기마다 메모리 정보를 수집하려는 경우</target>
        </trans-unit>
        <trans-unit id="f33ef09895b9595e58c40994534996d41b9b84f6" translate="yes" xml:space="preserve">
          <source>So, in general, &quot;state&quot; subroutines are faster. But &quot;my&quot; subs are necessary if you want to create closures:</source>
          <target state="translated">따라서 일반적으로 &quot;상태&quot;서브 루틴이 더 빠릅니다. 그러나 클로저를 만들려면 &quot;my&quot;하위가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b92446e0fc5150a550f9b239a78e7589775be2a5" translate="yes" xml:space="preserve">
          <source>So, let's say you want to add a custom element called 'foo'. In your subclass's &lt;code&gt;new&lt;/code&gt; method, after calling &lt;code&gt;SUPER::new&lt;/code&gt; you'd call:</source>
          <target state="translated">'foo'라는 사용자 정의 요소를 추가한다고 가정 해 봅시다. 서브 클래스의 &lt;code&gt;new&lt;/code&gt; 메소드에서 &lt;code&gt;SUPER::new&lt;/code&gt; 를 호출 한 후 다음을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="04546d861006181e7076b52be007eeaf163f592b" translate="yes" xml:space="preserve">
          <source>So, rather than having to say:</source>
          <target state="translated">따라서 말하기보다는</target>
        </trans-unit>
        <trans-unit id="ce7cf438ffd137d4b9ae434030e4dd1bac347bb0" translate="yes" xml:space="preserve">
          <source>So, saying &lt;code&gt;11 &amp;amp; 3&lt;/code&gt; performs the &quot;and&quot; operation on numbers (yielding &lt;code&gt;3&lt;/code&gt; ). Saying &lt;code&gt;&quot;11&quot; &amp;amp; &quot;3&quot;&lt;/code&gt; performs the &quot;and&quot; operation on strings (yielding &lt;code&gt;&quot;1&quot;&lt;/code&gt; ).</source>
          <target state="translated">따라서 &lt;code&gt;11 &amp;amp; 3&lt;/code&gt; 은 숫자에 대해 &quot;and&quot;연산을 수행합니다 (수량 &lt;code&gt;3&lt;/code&gt; ). 말하는 &lt;code&gt;&quot;11&quot; &amp;amp; &quot;3&quot;&lt;/code&gt; 을 수행 문자열에서 &quot;및&quot;동작 (항복 &lt;code&gt;&quot;1&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4a687b4464c81c65ad71b0b242c9a17889c06be5" translate="yes" xml:space="preserve">
          <source>So, sometimes you might want to use symbolic references to manipulate the symbol table directly. This doesn't matter for formats, handles, and subroutines, because they are always global--you can't use my() on them. For scalars, arrays, and hashes, though--and usually for subroutines-- you probably only want to use hard references.</source>
          <target state="translated">따라서 때로는 기호 참조를 사용하여 기호 테이블을 직접 조작 할 수도 있습니다. 형식, 핸들 및 서브 루틴은 중요하므로 항상 전역 적이므로 my ()를 사용할 수 없습니다. 스칼라, 배열 및 해시 (보통 서브 루틴의 경우)의 경우 하드 참조 만 사용하려고합니다.</target>
        </trans-unit>
        <trans-unit id="8b62c1a83484ac0f80542a2de9bd04874ec15952" translate="yes" xml:space="preserve">
          <source>So, the following examples will now work all as expected:</source>
          <target state="translated">따라서 다음 예제는 이제 예상대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b83b5043b490e39d23dba00f7ce754a2ed020ba9" translate="yes" xml:space="preserve">
          <source>So, the following line:</source>
          <target state="translated">따라서 다음 줄은</target>
        </trans-unit>
        <trans-unit id="e43264c4b337b0feb1da1b34ab4669d9bfde22ae" translate="yes" xml:space="preserve">
          <source>So, the following two statements do the same thing:</source>
          <target state="translated">따라서 다음 두 문장은 같은 일을합니다.</target>
        </trans-unit>
        <trans-unit id="0f5b24deb12867f441d62aa11cf38e02b6693a70" translate="yes" xml:space="preserve">
          <source>So, the string of Martian &quot;I am CVSGXX!&quot; uses 12 bytes to encode the nine characters 'I', ' ', 'a', 'm', ' ', 'CV', 'SG', 'XX', '!'.</source>
          <target state="translated">그래서 화성의 문자열 &quot;나는 CVSGXX입니다!&quot; 12 바이트를 사용하여 9 개의 문자 'I', '', 'a', 'm', '', 'CV', 'SG', 'XX', '!'를 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="666f233dad00e2e027af2bcddbc736103b174459" translate="yes" xml:space="preserve">
          <source>So, what's the big problem with that? It looks right, doesn't it? After all, I just told you that you need an array of references, so by golly, you've made me one!</source>
          <target state="translated">그렇다면 큰 문제는 무엇입니까? 맞아 보이죠? 결국, 나는 단지 당신에게 일련의 참조가 필요하다고 말했기 때문에, 당신은 나에게 하나를 만들었습니다!</target>
        </trans-unit>
        <trans-unit id="14b8aecd3aaaa33e35d9724dfec4e61ddcb14189" translate="yes" xml:space="preserve">
          <source>So:</source>
          <target state="translated">So:</target>
        </trans-unit>
        <trans-unit id="93c6a1f183694628e37ced41591147bfc0da1908" translate="yes" xml:space="preserve">
          <source>Socket</source>
          <target state="translated">Socket</target>
        </trans-unit>
        <trans-unit id="1a669dbe9f824af2034872bc98a2b6823a4c09af" translate="yes" xml:space="preserve">
          <source>Socket option level constant for setsockopt() and getsockopt().</source>
          <target state="translated">setsockopt () 및 getsockopt ()에 대한 소켓 옵션 레벨 상수.</target>
        </trans-unit>
        <trans-unit id="e89a311c363b4ef4dc4be93eaeb6560498486275" translate="yes" xml:space="preserve">
          <source>Socket option name constants for IPv4 socket options at the &lt;code&gt;IPPROTO_IP&lt;/code&gt; level.</source>
          <target state="translated">&lt;code&gt;IPPROTO_IP&lt;/code&gt; 레벨 의 IPv4 소켓 옵션에 대한 소켓 옵션 이름 상수 .</target>
        </trans-unit>
        <trans-unit id="d741b5bebfd867658e744ca3a901afeae953cecf" translate="yes" xml:space="preserve">
          <source>Socket option name constants for IPv6 socket options at the &lt;code&gt;IPPROTO_IPV6&lt;/code&gt; level.</source>
          <target state="translated">&lt;code&gt;IPPROTO_IPV6&lt;/code&gt; 레벨 의 IPv6 소켓 옵션에 대한 소켓 옵션 이름 상수 .</target>
        </trans-unit>
        <trans-unit id="1bea3c52b1b205afb6610aaf669b9a46fdff261d" translate="yes" xml:space="preserve">
          <source>Socket option name constants for TCP socket options at the &lt;code&gt;IPPROTO_TCP&lt;/code&gt; level.</source>
          <target state="translated">&lt;code&gt;IPPROTO_TCP&lt;/code&gt; 레벨 의 TCP 소켓 옵션에 대한 소켓 옵션 이름 상수 .</target>
        </trans-unit>
        <trans-unit id="8943cecdeb64eeb6c75caac188d81a6e580de3c7" translate="yes" xml:space="preserve">
          <source>Socket option name constants for setsockopt() and getsockopt() at the &lt;code&gt;SOL_SOCKET&lt;/code&gt; level.</source>
          <target state="translated">&lt;code&gt;SOL_SOCKET&lt;/code&gt; 레벨의 setsockopt () 및 getsockopt ()에 대한 소켓 옵션 이름 상수 .</target>
        </trans-unit>
        <trans-unit id="8a16f3d4e350888989be5c310a53b83649d06948" translate="yes" xml:space="preserve">
          <source>Socket option value constants for &lt;code&gt;IP_TOS&lt;/code&gt; socket option.</source>
          <target state="translated">&lt;code&gt;IP_TOS&lt;/code&gt; 소켓 옵션의 소켓 옵션 값 상수</target>
        </trans-unit>
        <trans-unit id="734337896e45cc2ebeff48479a66b46bdd05ddb4" translate="yes" xml:space="preserve">
          <source>Socket type constants to use as the second argument to socket(), or the value of the &lt;code&gt;SO_TYPE&lt;/code&gt; socket option.</source>
          <target state="translated">socket ()의 두 번째 인수 또는 &lt;code&gt;SO_TYPE&lt;/code&gt; 소켓 옵션 의 값으로 사용할 소켓 유형 상수 .</target>
        </trans-unit>
        <trans-unit id="5bedda872ecdb70c2a2d140ada477f5b294eb6f0" translate="yes" xml:space="preserve">
          <source>Socket.</source>
          <target state="translated">Socket.</target>
        </trans-unit>
        <trans-unit id="ebe92a08483968e414740930bf0a0a08483ad931" translate="yes" xml:space="preserve">
          <source>Socket.a</source>
          <target state="translated">Socket.a</target>
        </trans-unit>
        <trans-unit id="848572346180cfeef643ccd7fddcc1762d26f13a" translate="yes" xml:space="preserve">
          <source>Sockets: Client/Server Communication</source>
          <target state="translated">소켓 : 클라이언트 / 서버 통신</target>
        </trans-unit>
        <trans-unit id="bbfadcc007c702d16ecd0e6f6d3baeefff3d72aa" translate="yes" xml:space="preserve">
          <source>Solaris 10 documentation on syslog, &lt;a href=&quot;http://docs.sun.com/app/docs/doc/816-5168/syslog-3c?a=view&quot;&gt;http://docs.sun.com/app/docs/doc/816-5168/syslog-3c?a=view&lt;/a&gt;</source>
          <target state="translated">syslog에 대한 Solaris 10 설명서, &lt;a href=&quot;http://docs.sun.com/app/docs/doc/816-5168/syslog-3c?a=view&quot;&gt;http://docs.sun.com/app/docs/doc/816-5168/syslog-3c?a=view&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="98fa552d1b28be69cf1da96419b8a90307162871" translate="yes" xml:space="preserve">
          <source>Solaris 7 and above will run in either 32 bit or 64 bit mode on SPARC CPUs, via a reboot. You can build 64 bit apps whilst running 32 bit mode and vice-versa. 32 bit apps will run under Solaris running in either 32 or 64 bit mode. 64 bit apps require Solaris to be running 64 bit mode.</source>
          <target state="translated">Solaris 7 이상은 재부팅을 통해 SPARC CPU에서 32 비트 또는 64 비트 모드로 실행됩니다. 32 비트 모드를 실행하거나 그 반대로 64 비트 앱을 빌드 할 수 있습니다. 32 비트 앱은 32 비트 또는 64 비트 모드로 실행되는 Solaris에서 실행됩니다. 64 비트 응용 프로그램에서는 Solaris에서 64 비트 모드를 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="6ef2766b707c501497b46c746afec2754f6fc860" translate="yes" xml:space="preserve">
          <source>Solaris Version Numbers.</source>
          <target state="translated">Solaris 버전 번호.</target>
        </trans-unit>
        <trans-unit id="cc61dfb91810e5a0313350199a1b65c0af136cfa" translate="yes" xml:space="preserve">
          <source>Solaris global loading added by Nick Ing-Simmons with design/coding assistance from Tim Bunce, January 1996.</source>
          <target state="translated">1996 년 1 월 Tim Bunce의 설계 / 코딩 지원으로 Nick Ing-Simmons에 의해 Solaris 전역로드가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="708154fc528413c51483abd6933e68d503e36bdc" translate="yes" xml:space="preserve">
          <source>Solaris may include two versions of perl, e.g. Solaris 9 includes both 5.005_03 and 5.6.1. This is to provide stability across Solaris releases, in cases where a later perl version has incompatibilities with the version included in the preceding Solaris release. The default perl version will always be the most recent, and in general the old version will only be retained for one Solaris release. Note also that the default perl will NOT be configured to search for modules in the older version, again due to compatibility/stability concerns. As a consequence if you upgrade Solaris, you will have to rebuild/reinstall any additional CPAN modules that you installed for the previous Solaris version. See the CPAN manpage under 'autobundle' for a quick way of doing this.</source>
          <target state="translated">Solaris에는 두 가지 버전의 perl이 포함될 수 있습니다. 예를 들어 Solaris 9에는 5.005_03과 5.6.1이 모두 포함됩니다. 이는 이후의 perl 버전이 이전 Solaris 릴리스에 포함 된 버전과 호환되지 않는 경우 Solaris 릴리스간에 안정성을 제공하기위한 것입니다. 기본 perl 버전은 항상 최신 버전이며 일반적으로 이전 버전은 하나의 Solaris 릴리스에 대해서만 유지됩니다. 호환성 / 안정성 문제로 인해 기본 펄은 이전 버전의 모듈을 검색하도록 구성되지 않습니다. 결과적으로 Solaris를 업그레이드하는 경우 이전 Solaris 버전 용으로 설치 한 추가 CPAN 모듈을 다시 빌드 / 다시 설치해야합니다. 이를 수행하는 빠른 방법은 'autobundle'아래 CPAN 맨 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4bfa1cd2c976e4c546cb366d1dac1622384583a6" translate="yes" xml:space="preserve">
          <source>Solaris provides some BSD-compatibility functions in /usr/ucblib/libucb.a. Perl will not build and run correctly if linked against -lucb since it contains routines that are incompatible with the standard Solaris libc. Normally this is not a problem since the solaris hints file prevents Configure from even looking in /usr/ucblib for libraries, and also explicitly omits -lucb.</source>
          <target state="translated">Solaris는 /usr/ucblib/libucb.a에 일부 BSD 호환 기능을 제공합니다. -lucb에 링크 된 경우 표준 Solaris libc와 호환되지 않는 루틴이 포함되어 있으므로 Perl은 올바르게 빌드 및 실행되지 않습니다. solaris hints 파일로 인해 Configure가 라이브러리의 / usr / ucblib를 찾지 못하고 -lucb도 명시 적으로 생략되기 때문에 일반적으로 이것은 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d0c3f51965773ced91efb778a3671a3477592fd4" translate="yes" xml:space="preserve">
          <source>Solaris ships with a range of Solaris-specific modules. If you choose to install your own version of perl you will find the source of many of these modules is available on CPAN under the Sun::Solaris:: namespace.</source>
          <target state="translated">Solaris는 다양한 Solaris 특정 모듈과 함께 제공됩니다. 고유 한 버전의 perl을 설치하도록 선택하면 CPAN에서 Sun :: Solaris :: 네임 스페이스의 여러 모듈 소스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4f91bdb0e1b0e40fff4debcd0fea22f1999f491" translate="yes" xml:space="preserve">
          <source>Solution</source>
          <target state="translated">Solution</target>
        </trans-unit>
        <trans-unit id="05b004a92e5eda3ec6e47516b582fc25b61b35b9" translate="yes" xml:space="preserve">
          <source>Solutions</source>
          <target state="translated">Solutions</target>
        </trans-unit>
        <trans-unit id="00b2aad45d07b70e1b7eefea74316913901b6e42" translate="yes" xml:space="preserve">
          <source>Some</source>
          <target state="translated">Some</target>
        </trans-unit>
        <trans-unit id="5f679f54e4d0cf2197954f773a392f8d165d2696" translate="yes" xml:space="preserve">
          <source>Some (minor) parts copyright 2009 Adam Kennedy.</source>
          <target state="translated">일부 (사소한) 부품은 2009 Adam Kennedy에게 저작권이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a644bfc8b4acacc1b56f8b5a49f0fbd16c47364" translate="yes" xml:space="preserve">
          <source>Some *nix programs use fork() a lot; with the mostly useful flavors of perl for OS/2 (there are several built simultaneously) this is supported; but some flavors do not support this (e.g., when Perl is called from inside REXX). Using fork() after</source>
          <target state="translated">일부 * nix 프로그램은 fork ()를 많이 사용합니다. OS / 2에 가장 유용한 펄의 풍미로 (여러 개가 동시에 구축되어 있음) 이것이 지원됩니다. 그러나 일부 맛은이를 지원하지 않습니다 (예 : Perl이 REXX 내부에서 호출 될 때). 다음에 fork () 사용</target>
        </trans-unit>
        <trans-unit id="6a808c47f9491da438c1507c81067e0d0ad1d610" translate="yes" xml:space="preserve">
          <source>Some / became \ in pdksh.</source>
          <target state="translated">pdksh에서 일부가 \가되었습니다.</target>
        </trans-unit>
        <trans-unit id="2ced2108dbb21d847b539e5bf8d6eae4e6952b9e" translate="yes" xml:space="preserve">
          <source>Some &lt;code&gt;/&lt;/code&gt; became &lt;code&gt;\&lt;/code&gt; in pdksh.</source>
          <target state="translated">일부 &lt;code&gt;/&lt;/code&gt; 가 되었다 &lt;code&gt;\&lt;/code&gt; pdksh 같은 년.</target>
        </trans-unit>
        <trans-unit id="aee5f872bb2cc36da4c3ed1ff4e14aea96b6faa3" translate="yes" xml:space="preserve">
          <source>Some &lt;code&gt;Win*&lt;/code&gt; entry points also overload a &quot;meaningful&quot; return value with the error indicator; having a 0 return value indicates an error. Yet some other &lt;code&gt;Win*&lt;/code&gt; entry points overload things even more, and 0 return value may mean a successful call returning a valid value 0, as well as an error condition; in the case of a 0 return value one should call WinGetLastError() API to distinguish a successful call from a failing one.</source>
          <target state="translated">일부 &lt;code&gt;Win*&lt;/code&gt; 진입 점에는 오류 표시기와 함께 &quot;의미있는&quot;반환 값이 오버로드됩니다. 리턴 값이 0이면 오류를 나타냅니다. 그러나 다른 &lt;code&gt;Win*&lt;/code&gt; 진입 점은 더 많은 것들을 오버로드하며, 반환 값이 0이면 오류 조건뿐만 아니라 유효한 값 0을 반환하는 성공적인 호출을 의미 할 수 있습니다. 리턴 값이 0 인 경우 성공적인 호출과 실패한 호출을 구별하기 위해 WinGetLastError () API를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="7d77130c6b6fd9352c737bed1bb1dcb935bd9ca9" translate="yes" xml:space="preserve">
          <source>Some DLLs are only present in some versions of OS/2, or in some configurations of OS/2. Some exported entry points are present only in DLLs shipped with some versions of OS/2. If these DLLs and entry points were linked directly for a Perl executable/DLL or from a Perl extensions, this binary would work only with the specified versions/setups. Even if these entry points were not needed, the</source>
          <target state="translated">일부 DLL은 일부 OS / 2 버전 또는 일부 OS / 2 구성에만 있습니다. 내 보낸 일부 진입 점은 일부 OS / 2 버전과 함께 제공된 DLL에만 있습니다. 이러한 DLL 및 진입 점이 Perl 실행 파일 / DLL 또는 Perl 확장에서 직접 링크 된 경우이 바이너리는 지정된 버전 / 설정에서만 작동합니다. 이러한 진입 점이 필요하지 않더라도</target>
        </trans-unit>
        <trans-unit id="14adc2a370c74e9f0b7a6eb136961fb44f4e9d5e" translate="yes" xml:space="preserve">
          <source>Some IBM EBCDIC character sets may be known by character code set identification numbers (CCSID numbers) or code page numbers.</source>
          <target state="translated">일부 IBM EBCDIC 문자 세트는 문자 코드 세트 식별 번호 (CCSID 번호) 또는 코드 페이지 번호로 알려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20970d609d169c267b614af470114dc6b026c453" translate="yes" xml:space="preserve">
          <source>Some Irix cc versions, e.g. 7.3.1.1m (try cc -version) have been known to have issues (coredumps) when compiling perl.c. If you've used -OPT:fast_io=ON and this happens, try removing it. If that fails, or you didn't use that, then try adjusting other optimization options (-LNO, -INLINE, -O3 to -O2, etcetera). The compiler bug has been reported to SGI. (Allen Smith &amp;lt;easmith@beatrice.rutgers.edu&amp;gt;)</source>
          <target state="translated">7.3.1.1m (try cc -version)과 같은 일부 Irix cc 버전은 perl.c를 컴파일 할 때 문제 (코어 덤프)가있는 것으로 알려져 있습니다. -OPT : fast_io = ON을 사용한 경우이 문제를 제거하십시오. 실패하거나 사용하지 않은 경우 다른 최적화 옵션 (-LNO, -INLINE, -O3에서 -O2 등)을 조정하십시오. 컴파일러 버그가 SGI에보고되었습니다. (앨런 스미스 &amp;lt;easmith@beatrice.rutgers.edu&amp;gt;)</target>
        </trans-unit>
        <trans-unit id="e270800f9e2c9ef58198c6c9f8463f63bac86a3b" translate="yes" xml:space="preserve">
          <source>Some Linux platforms have a maximum stack size. Setting too large of a stack size will cause thread creation to fail.</source>
          <target state="translated">일부 Linux 플랫폼은 최대 스택 크기를 갖습니다. 스택 크기를 너무 크게 설정하면 스레드 생성이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="bad9f67e1f3cb77c4fe9db59234d0c5d6bb841b2" translate="yes" xml:space="preserve">
          <source>Some OSes do not need these in which case leave it blank.</source>
          <target state="translated">일부 OS는이를 필요로하지 않으며,이 경우 비워 두십시오.</target>
        </trans-unit>
        <trans-unit id="69e7c8fdafb5d76df4c8f736ecf437657f4dc150" translate="yes" xml:space="preserve">
          <source>Some Pod formatters output to formats that implement non-breaking spaces as an individual character (which I'll call &quot;NBSP&quot;), and others output to formats that implement non-breaking spaces just as spaces wrapped in a &quot;don't break this across lines&quot; code. Note that at the level of Pod, both sorts of codes can occur: Pod can contain a NBSP character (whether as a literal, or as a &quot;E&amp;lt;160&amp;gt;&quot; or &quot;E&amp;lt;nbsp&amp;gt;&quot; code); and Pod can contain &quot;S&amp;lt;foo I&amp;lt;bar&amp;gt; baz&amp;gt;&quot; codes, where &quot;mere spaces&quot; (character 32) in such codes are taken to represent non-breaking spaces. Pod parsers should consider supporting the optional parsing of &quot;S&amp;lt;foo I&amp;lt;bar&amp;gt; baz&amp;gt;&quot; as if it were &quot;foo</source>
          <target state="translated">일부 포드 포맷터는 줄 바꿈하지 않는 공백을 개별 문자 ( &quot;NBSP&quot;라고 함)로 구현하는 형식으로 출력하고, 일부 포드 포맷터는 줄 바꿈되지 않은 공백을 &quot;줄 바꿈하지 마십시오. 여러 줄에 걸쳐 &quot;코드. 포드 수준에서 두 종류의 코드가 모두 발생할 수 있습니다. 포드에는 NBSP 문자 (리터럴이든 &quot;E &amp;lt;160&amp;gt;&quot;또는 &quot;E &amp;lt;nbsp&amp;gt;&quot;코드)가 포함될 수 있습니다. 포드는 &quot;S &amp;lt;foo I &amp;lt;bar&amp;gt; baz&amp;gt;&quot;코드를 포함 할 수 있으며, 이러한 코드에서 &quot;단지 공백&quot;(문자 32)은 비 분리 공백을 나타냅니다. 포드 파서는 &quot;S &amp;lt;foo I &amp;lt;bar&amp;gt; baz&amp;gt;&quot;의 선택적 파싱을 &quot;foo&quot;처럼 지원하는 것을 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="f04294d93d5e63f6eed93e1148616595ef1487e2" translate="yes" xml:space="preserve">
          <source>Some Sys-V based systems, notably Solaris 2.X, redefined some of the standard socket constants. Since these were constant across all architectures, they were often hardwired into perl code. The proper way to deal with this is to &quot;use Socket&quot; to get the correct values.</source>
          <target state="translated">일부 Sys-V 기반 시스템, 특히 Solaris 2.X는 일부 표준 소켓 상수를 재정의했습니다. 이것들은 모든 아키텍처에서 일정하기 때문에 종종 펄 코드에 고정되어 있습니다. 이를 처리하는 올바른 방법은 올바른 값을 얻기 위해 &quot;소켓 사용&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="a5a0c5f6bf86975f2c301ba492652230f705bf5a" translate="yes" xml:space="preserve">
          <source>Some Unicode properties have a restricted set of legal values. For example, all binary properties are restricted to just &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; ; and there are only a few dozen possible General Categories.</source>
          <target state="translated">일부 유니 코드 속성에는 제한된 법적 값 집합이 있습니다. 예를 들어 모든 이진 속성은 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 로 제한됩니다 . 수십 개의 가능한 일반 범주 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e6eb6762559c642717c0b35b0e9407b4ea3c431" translate="yes" xml:space="preserve">
          <source>Some Unicode properties have a restricted set of legal values. For example, all binary properties are restricted to just &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; ; and there are only a few dozen possible General Categories. Use &lt;code&gt;prop_values&lt;/code&gt; to find out if a given property is one such, and if so, to get a list of the values:</source>
          <target state="translated">일부 유니 코드 속성에는 제한된 법적 값 집합이 있습니다. 예를 들어 모든 이진 속성은 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 로 제한됩니다 . 수십 개의 가능한 일반 범주 만 있습니다. &lt;code&gt;prop_values&lt;/code&gt; 를 사용 하여 주어진 속성이 그러한 속성인지 확인하고, 그렇다면 속성 목록을 얻으려면 :</target>
        </trans-unit>
        <trans-unit id="abd2e23e9cee0c22d7103f4f9a78d73d761dd3aa" translate="yes" xml:space="preserve">
          <source>Some approximate operating system names and their &lt;code&gt;$^O&lt;/code&gt; values in the &quot;OTHER&quot; category include:</source>
          <target state="translated">&quot;OTHER&quot;범주의 대략적인 운영 체제 이름 및 &lt;code&gt;$^O&lt;/code&gt; 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fc63731ea34f43c4af1c4ec405f7ea69ef1d9704" translate="yes" xml:space="preserve">
          <source>Some authors have strange characters in their names.</source>
          <target state="translated">일부 저자는 이름에 이상한 문자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6877eb2746dbad4bb0e9e27d968022bfea3412f0" translate="yes" xml:space="preserve">
          <source>Some background on thread implementations from the operating system viewpoint. There are three basic categories of threads: user-mode threads, kernel threads, and multiprocessor kernel threads.</source>
          <target state="translated">운영 체제 관점에서의 스레드 구현에 대한 배경 지식. 스레드에는 기본적으로 사용자 모드 스레드, 커널 스레드 및 다중 프로세서 커널 스레드의 세 가지 범주가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc0d6a626635ac5ae4291cc3487e50efd6ae5a14" translate="yes" xml:space="preserve">
          <source>Some bits may be relevant at compile-time only, some at run-time only. This is a new mechanism and the details may change. See also &lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt;.</source>
          <target state="translated">일부 비트는 컴파일 타임에만 관련되고 일부 비트는 런타임에만 관련 될 수 있습니다. 이것은 새로운 메커니즘이며 세부 사항이 변경 될 수 있습니다. &lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fd8e9b1766f0e1e6eaaded7abc870a37e4571ff0" translate="yes" xml:space="preserve">
          <source>Some brief examples:</source>
          <target state="translated">몇 가지 간단한 예 :</target>
        </trans-unit>
        <trans-unit id="61327002f5b3861abd79c62e144ccb79536f4f22" translate="yes" xml:space="preserve">
          <source>Some builtins (e.g. &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt;) has a call signature that cannot completely be representated with a Perl prototype. This means that some valid Perl code will be invalid under autodie. As an example:</source>
          <target state="translated">일부 내장 (예 : &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt; )에는 Perl 프로토 타입으로 완전히 표현할 수없는 호출 서명이 있습니다. 이는 일부 유효한 Perl 코드가 autodie에서 유효하지 않음을 의미합니다. 예로서:</target>
        </trans-unit>
        <trans-unit id="21eaccc7842c81c4d4f8ac981ea6b511271286ba" translate="yes" xml:space="preserve">
          <source>Some calls simply aren't available, real or emulated, on every platform.</source>
          <target state="translated">일부 플랫폼에서는 모든 통화를 실제 통화 또는 에뮬레이션으로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7144ad6e6fa073f902e93d5905df49ebac937d92" translate="yes" xml:space="preserve">
          <source>Some code points also have abbreviated names, such as &quot;LF&quot; or &quot;NL&quot;. &lt;code&gt;viacode&lt;/code&gt; never returns these.</source>
          <target state="translated">일부 코드 포인트에는 &quot;LF&quot;또는 &quot;NL&quot;과 같은 약어 이름이 있습니다. &lt;code&gt;viacode&lt;/code&gt; 는 이것을 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="73ac6d49c092929d2ed08d514c7b1beb64ede02a" translate="yes" xml:space="preserve">
          <source>Some code taken from &lt;a href=&quot;../more&quot;&gt;Test::More&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Catch&quot;&gt;Test::Catch&lt;/a&gt;, written by Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;. Hence, those parts Copyright Micheal G Schwern 2001. Used and distributed with permission.</source>
          <target state="translated">Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;이 작성한 &lt;a href=&quot;../more&quot;&gt;Test :: More&lt;/a&gt; 및 &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Catch&quot;&gt;Test :: Catch&lt;/a&gt; 에서 가져온 일부 코드 입니다. 따라서 해당 부분의 저작권은 Micheal G Schwern 2001에 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1339e50839100723841e8e48747e9f9a1f5bed3" translate="yes" xml:space="preserve">
          <source>Some constants and functions are exported by default by this module; but for backward-compatibility any recently-added symbols are not exported by default and must be requested explicitly. When an import list is provided to the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; line, the default exports are not automatically imported. It is therefore best practice to always to explicitly list all the symbols required.</source>
          <target state="translated">일부 상수 및 함수는이 모듈에서 기본적으로 내보내집니다. 그러나 이전 버전과의 호환성을 위해 최근에 추가 한 모든 심볼은 기본적으로 내보내지지 않으며 명시 적으로 요청해야합니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 행에 가져 오기 목록이 제공 되면 기본 내보내기는 자동으로 가져 오지 않습니다. 따라서 필요한 모든 기호를 항상 명시 적으로 나열하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="078dd465c32a4795a8e3e38bd49c7d92d32009a8" translate="yes" xml:space="preserve">
          <source>Some constants don't print correctly either with or without &lt;b&gt;-d&lt;/b&gt;. For instance, neither B::Deparse nor Data::Dumper know how to print dual-valued scalars correctly, as in:</source>
          <target state="translated">일부 상수는 &lt;b&gt;-d&lt;/b&gt; 를 사용하거나 사용하지 않고 올바르게 인쇄되지 않습니다 . 예를 들어 B :: Deparse와 Data :: Dumper는 다음과 같이 이중 값 스칼라를 올바르게 인쇄하는 방법을 모릅니다.</target>
        </trans-unit>
        <trans-unit id="0e689eba4cf9a38a4acdff5d45d4adaf1f020711" translate="yes" xml:space="preserve">
          <source>Some contexts allow 2 or even 1 digit, but any usage without exactly three digits, the first being a zero, may give unintended results. (For example, in a regular expression it may be confused with a backreference; see &lt;a href=&quot;perlrebackslash#Octal-escapes&quot;&gt;Octal escapes in perlrebackslash&lt;/a&gt;.) Starting in Perl 5.14, you may use &lt;code&gt;\o{}&lt;/code&gt; instead, which avoids all these problems. Otherwise, it is best to use this construct only for ordinals &lt;code&gt;\077&lt;/code&gt; and below, remembering to pad to the left with zeros to make three digits. For larger ordinals, either use &lt;code&gt;\o{}&lt;/code&gt; , or convert to something else, such as to hex and use &lt;code&gt;\N{U+}&lt;/code&gt; (which is portable between platforms with different character sets) or &lt;code&gt;\x{}&lt;/code&gt; instead.</source>
          <target state="translated">일부 컨텍스트는 2 자리 또는 1 자리를 허용하지만 정확히 3 자리가없는 경우 (처음은 0 임) 의도하지 않은 결과를 낳을 수 있습니다. (예를 들어, 정규 표현식에서는 역 참조와 혼동 될 수 있습니다 . &lt;a href=&quot;perlrebackslash#Octal-escapes&quot;&gt;perlrebackslash의 8 진 이스케이프를&lt;/a&gt; 참조하십시오 .) Perl 5.14부터는 &lt;code&gt;\o{}&lt;/code&gt; 대신 사용할 수 있습니다 . 이렇게하면 모든 문제를 피할 수 있습니다. 그렇지 않으면,이 구성은 서수 &lt;code&gt;\077&lt;/code&gt; 이하에 대해서만 사용하는 것이 가장 좋습니다 . 세 자리수를 만들기 위해 왼쪽으로 0을 채우는 것을 기억하십시오. 더 큰 서수의 경우 &lt;code&gt;\o{}&lt;/code&gt; 을 사용하거나 16 진수와 같은 다른 것으로 변환하고 &lt;code&gt;\N{U+}&lt;/code&gt; (다른 문자 집합을 가진 플랫폼간에 이식 가능) 또는 &lt;code&gt;\x{}&lt;/code&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="17469d7643e0741d1ada43cbcada6ad7b4213174" translate="yes" xml:space="preserve">
          <source>Some cool command line examples to impress the Python crowd ;)</source>
          <target state="translated">파이썬 군중에게 감동을주는 멋진 명령 줄 예제;)</target>
        </trans-unit>
        <trans-unit id="4f597c06196db5dfae23debf5b526fce9cd25685" translate="yes" xml:space="preserve">
          <source>Some cool command line examples to impress the Python crowd ;) You might want to compare them to the results under -Mbignum or -Mbigrat:</source>
          <target state="translated">파이썬 군중을 감동시키는 멋진 명령 행 예제;) -Mbignum 또는 -Mbigrat의 결과와 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6746b978d2a5bd75b46a34b757950222f7e2d87" translate="yes" xml:space="preserve">
          <source>Some database drivers for DBI can also automatically encode and decode, but that is sometimes limited to the UTF-8 encoding.</source>
          <target state="translated">DBI 용 일부 데이터베이스 드라이버는 자동으로 인코딩 및 디코딩 할 수 있지만 때때로 UTF-8 인코딩으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="20c968c59a29a0ad6a0ddbad176bb82749120644" translate="yes" xml:space="preserve">
          <source>Some devices will be expecting a &quot;\r&quot; at the end of each line rather than a &quot;\n&quot;. In some ports of perl, &quot;\r&quot; and &quot;\n&quot; are different from their usual (Unix) ASCII values of &quot;\015&quot; and &quot;\012&quot;. You may have to give the numeric values you want directly, using octal (&quot;\015&quot;), hex (&quot;0x0D&quot;), or as a control-character specification (&quot;\cM&quot;).</source>
          <target state="translated">일부 장치는 각 줄 끝에 &quot;\ n&quot;이 아닌 &quot;\ r&quot;을 기대합니다. perl의 일부 포트에서 &quot;\ r&quot;및 &quot;\ n&quot;은 일반적인 &quot;Unix) ASCII 값&quot;\ 015 &quot;및&quot;\ 012 &quot;와 다릅니다. 8 진수 ( &quot;\ 015&quot;), 16 진수 ( &quot;0x0D&quot;) 또는 제어 문자 사양 ( &quot;\ cM&quot;)을 사용하여 원하는 숫자 값을 직접 제공해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b15270299f74ddedc9cb2a27cec0a8d56d430a18" translate="yes" xml:space="preserve">
          <source>Some digits that &lt;code&gt;\d&lt;/code&gt; matches look like some of the [0-9] ones, but have different values. For example, BENGALI DIGIT FOUR (U+09EA) looks very much like an ASCII DIGIT EIGHT (U+0038). An application that is expecting only the ASCII digits might be misled, or if the match is &lt;code&gt;\d+&lt;/code&gt; , the matched string might contain a mixture of digits from different writing systems that look like they signify a number different than they actually do. &lt;a href=&quot;unicode/ucd#num()&quot;&gt;num() in Unicode::UCD&lt;/a&gt; can be used to safely calculate the value, returning &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if the input string contains such a mixture.</source>
          <target state="translated">&lt;code&gt;\d&lt;/code&gt; 와 일치 하는 일부 숫자 는 [0-9] 숫자 중 일부와 비슷하지만 값이 다릅니다. 예를 들어, BENGALI DIGIT FOUR (U + 09EA)는 ASCII DIGIT EIGHT (U + 0038)와 매우 유사합니다. ASCII 숫자 만 예상되는 응용 프로그램이 잘못 표시되거나 일치하는 항목이 &lt;code&gt;\d+&lt;/code&gt; 이면 일치하는 문자열에 실제와는 다른 숫자를 나타내는 것처럼 다른 쓰기 시스템의 숫자가 혼합되어있을 수 있습니다. &lt;a href=&quot;unicode/ucd#num()&quot;&gt;Unicode :: UCD의 num ()을&lt;/a&gt; 사용하여 값을 안전하게 계산 하여 입력 문자열에 이러한 혼합이 포함되어 있으면 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eb6208f023afd54f9f4acc30a7d493bf14dc6378" translate="yes" xml:space="preserve">
          <source>Some distributions may fail some tests, but you may want to install them anyway (as above, or via &lt;code&gt;force install&lt;/code&gt; command of &lt;code&gt;CPAN.pm&lt;/code&gt; shell-mode).</source>
          <target state="translated">일부 배포판은 일부 테스트에 실패 할 수 있지만 어쨌든 (위와 같이 또는 &lt;code&gt;CPAN.pm&lt;/code&gt; 쉘 모드 의 &lt;code&gt;force install&lt;/code&gt; 명령을 통해) 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="673083d85e2bc8b38798cec75fcc0568d074003d" translate="yes" xml:space="preserve">
          <source>Some distributions may need to link to libraries or other third-party code and their build and installation sequences may be more complicated. Check any</source>
          <target state="translated">일부 배포판은 라이브러리 또는 다른 타사 코드에 연결해야 할 수 있으며 빌드 및 설치 순서가 더 복잡 할 수 있습니다. 확인</target>
        </trans-unit>
        <trans-unit id="e14b5226c1b3194a20df87855367bd2962c1e595" translate="yes" xml:space="preserve">
          <source>Some documentation is not available as man pages, so if a cross-reference is not found by man, try it with &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt;. Perldoc can also take you directly to documentation for functions (with the &lt;b&gt;-f&lt;/b&gt; switch). See &lt;code&gt;perldoc --help&lt;/code&gt; (or &lt;code&gt;perldoc perldoc&lt;/code&gt; or &lt;code&gt;man perldoc&lt;/code&gt; ) for other helpful options &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt; has to offer.</source>
          <target state="translated">일부 문서는 매뉴얼 페이지로 제공되지 않으므로 man이 상호 참조를 찾을 수없는 경우 &lt;a href=&quot;perldoc&quot;&gt;perldoc로&lt;/a&gt; 시도하십시오 . Perldoc은 기능에 대한 문서 ( &lt;b&gt;-f&lt;/b&gt; 스위치 사용)로 직접 이동할 수도 있습니다 . &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt; 이 제공하는 다른 유용한 옵션 은 &lt;code&gt;perldoc --help&lt;/code&gt; (또는 &lt;code&gt;perldoc perldoc&lt;/code&gt; 또는 &lt;code&gt;man perldoc&lt;/code&gt; )를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="24f338e775f9d8f25e87916116198ed5fdfd8fac" translate="yes" xml:space="preserve">
          <source>Some earlier versions of this module had docs with some confusing typos in the description of &lt;code&gt;skip(...)&lt;/code&gt; .</source>
          <target state="translated">이 모듈의 일부 이전 버전은 &lt;code&gt;skip(...)&lt;/code&gt; 설명에 혼란스러운 오타가있는 문서가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2d5fff71fc694b06c17e66dad87b134506e2302b" translate="yes" xml:space="preserve">
          <source>Some essentially obsolete locales that aren't supersets of ASCII, mainly those in ISO 646 or other 7-bit locales, such as ASMO 449, can also have problems, depending on what portions of the ASCII character set get changed by the locale and are also used by the program. The warning message lists the determinable conflicting characters.</source>
          <target state="translated">ASCII의 상위 세트가 아닌 일부 기본적으로 사용되지 않는 로케일, 주로 ISO 646 또는 ASMO 449와 같은 기타 7 비트 로케일의 로케일에 따라 ASCII 문자 세트의 일부가 로케일에 의해 변경되어 문제가있을 수 있습니다. 프로그램에서도 사용됩니다. 경고 메시지는 결정 가능한 충돌 문자를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="e8b38cbb77fcb476bf8e2983ccfda5ed33f46a79" translate="yes" xml:space="preserve">
          <source>Some example section specifications follow.</source>
          <target state="translated">다음은 일부 예제 섹션 사양입니다.</target>
        </trans-unit>
        <trans-unit id="6e29ae8ec1bfc30435ce56e5aeb3c20b82d6940f" translate="yes" xml:space="preserve">
          <source>Some examples of lists include:</source>
          <target state="translated">목록의 일부 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ae84b84bf5612613743104cf4d1d3f624e770f5d" translate="yes" xml:space="preserve">
          <source>Some examples of syntactically invalid attribute lists (with annotation):</source>
          <target state="translated">구문 상 유효하지 않은 속성 목록의 몇 가지 예 (주석 포함) :</target>
        </trans-unit>
        <trans-unit id="9c0e82c6c1b276d5dbb162e62c1346aa697136e3" translate="yes" xml:space="preserve">
          <source>Some examples of syntactically valid attribute lists:</source>
          <target state="translated">구문 적으로 유효한 속성 목록의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="01706013cfdbcb0fc543d3c97784f3f4c235d630" translate="yes" xml:space="preserve">
          <source>Some examples:</source>
          <target state="translated">몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="75d23fa0c37e5a03812b09ef6b9c46fbb0fa3389" translate="yes" xml:space="preserve">
          <source>Some extensions provide filters on data entry/exit points, such as &lt;code&gt;DB_File::filter_store_key&lt;/code&gt; and family. Look out for such filters in the documentation of your extensions; they can make the transition to Unicode data much easier.</source>
          <target state="translated">일부 확장은 &lt;code&gt;DB_File::filter_store_key&lt;/code&gt; 및 제품군과 같은 데이터 시작 / 종료 지점에 대한 필터를 제공합니다 . 확장 문서에서 이러한 필터를 찾으십시오. 유니 코드 데이터로 훨씬 쉽게 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ba2d8223f5d5832c6d62c8b546d87c608dd84fc" translate="yes" xml:space="preserve">
          <source>Some extensions, like DB_File and Compress::Zlib use/require prebuilt libraries for the perl extensions/modules to work. If these libraries are built using the default configuration, it might happen that you run into an error like &quot;invalid loader fixup&quot; during load phase. HP is aware of this problem. Search the HP-UX cxx-dev forums for discussions about the subject. The short answer is that &lt;b&gt;everything&lt;/b&gt; (all libraries, everything) must be compiled with &lt;code&gt;+z&lt;/code&gt; or &lt;code&gt;+Z&lt;/code&gt; to be PIC (position independent code). (For gcc, that would be &lt;code&gt;-fpic&lt;/code&gt; or &lt;code&gt;-fPIC&lt;/code&gt; ). In HP-UX 11.00 or newer the linker error message should tell the name of the offending object file.</source>
          <target state="translated">DB_File 및 Compress :: Zlib와 같은 일부 확장자는 perl 확장자 / 모듈이 작동하기 위해 사전 빌드 된 라이브러리를 사용 / 필요합니다. 이러한 라이브러리가 기본 구성을 사용하여 빌드 된 경우로드 단계 중에 &quot;잘못된 로더 수정&quot;과 같은 오류가 발생할 수 있습니다. HP는이 문제를 알고 있습니다. 주제에 대한 토론은 HP-UX cxx-dev 포럼을 검색하십시오. 짧은 대답은 &lt;b&gt;모든 것&lt;/b&gt; (모든 라이브러리, 모든 것)이 &lt;code&gt;+z&lt;/code&gt; 또는 &lt;code&gt;+Z&lt;/code&gt; 로 컴파일되어 PIC (위치 독립적 인 코드)가되어야한다는 것입니다. (gcc의 경우 &lt;code&gt;-fpic&lt;/code&gt; 또는 &lt;code&gt;-fPIC&lt;/code&gt; 입니다 ). HP-UX 11.00 이상에서는 링커 오류 메시지에 문제가있는 객체 파일의 이름이 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="4b7fd53f722062eada03c99c5c0131726fe7cb4c" translate="yes" xml:space="preserve">
          <source>Some features of Storable can lead to security vulnerabilities if you accept Storable documents from untrusted sources. Most obviously, the optional (off by default) CODE reference serialization feature allows transfer of code to the deserializing process. Furthermore, any serialized object will cause Storable to helpfully load the module corresponding to the class of the object in the deserializing module. For manipulated module names, this can load almost arbitrary code. Finally, the deserialized object's destructors will be invoked when the objects get destroyed in the deserializing process. Maliciously crafted Storable documents may put such objects in the value of a hash key that is overridden by another key/value pair in the same hash, thus causing immediate destructor execution.</source>
          <target state="translated">신뢰할 수없는 출처의 저장 가능한 문서를 수락하면 Storable의 일부 기능으로 보안 취약점이 발생할 수 있습니다. 가장 명백하게, 선택적 (기본적으로 해제되어있는) CODE 참조 직렬화 기능을 사용하면 코드를 역 직렬화 프로세스로 전송할 수 있습니다. 또한 직렬화 된 객체는 Storable이 직렬화 해제 모듈의 객체 클래스에 해당하는 모듈을 유용하게로드하게합니다. 조작 된 모듈 이름의 경우 거의 임의의 코드를로드 할 수 있습니다. 마지막으로 역 직렬화 객체의 소멸자는 역 직렬화 프로세스에서 객체가 파괴 될 때 호출됩니다. 악의적으로 제작 된 저장 가능한 문서는 같은 해시의 다른 키 / 값 쌍으로 재정의되는 해시 키 값에 이러한 개체를 넣을 수 있으므로 즉시 소멸자가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="410f15ec6c766d4ad924aef6bed79d8486d14679" translate="yes" xml:space="preserve">
          <source>Some folks are surprised that &lt;code&gt;make distclean&lt;/code&gt; does not delete everything not listed in their MANIFEST (thus making a clean distribution) but only tells them what they need to delete. This is done because it is considered too dangerous. While developing your module you might write a new file, not add it to the MANIFEST, then run a &lt;code&gt;distclean&lt;/code&gt; and be sad because your new work was deleted.</source>
          <target state="translated">일부 사람들은 &lt;code&gt;make distclean&lt;/code&gt; 을 작성하면 MANIFEST에 나열되지 않은 모든 항목을 삭제하지 않고 (그러므로 깨끗하게 배포하는 것) 삭제해야 할 내용 만 알려줍니다. 이것은 너무 위험한 것으로 간주되기 때문에 수행됩니다. 모듈을 개발하는 동안 새 파일을 작성하고 MANIFEST에 추가하지 않은 다음 새 작업이 삭제 되어 &lt;code&gt;distclean&lt;/code&gt; 하지 않고 슬프게 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="278e93ddc6a44b33edbb2aa1b1e3252bdefc68ee" translate="yes" xml:space="preserve">
          <source>Some folks would prefer full alphanumeric prototypes. Alphanumerics have been intentionally left out of prototypes for the express purpose of someday in the future adding named, formal parameters. The current mechanism's main goal is to let module writers provide better diagnostics for module users. Larry feels the notation quite understandable to Perl programmers, and that it will not intrude greatly upon the meat of the module, nor make it harder to read. The line noise is visually encapsulated into a small pill that's easy to swallow.</source>
          <target state="translated">어떤 사람들은 완전한 영숫자 프로토 타입을 선호 할 것입니다. 미래에 언젠가는 명명 된 형식 매개 변수를 추가하는 표현 목적으로 영숫자에서 의도적으로 프로토 타입이 제외되었습니다. 현재 메커니즘의 주요 목표는 모듈 작성자가 모듈 사용자에게 더 나은 진단을 제공 할 수 있도록하는 것입니다. Larry는 Perl 프로그래머에게이 표기법을 이해할 수 있다고 느끼며 모듈의 고기에 크게 침입하거나 읽기가 더 어려워지지 않을 것이라고 생각합니다. 라인 노이즈는 시각적으로 삼키기 쉬운 작은 알약으로 캡슐화됩니다.</target>
        </trans-unit>
        <trans-unit id="97b6babea6d7a1882a7f9edff1a7d1c57e6e6a28" translate="yes" xml:space="preserve">
          <source>Some format names that formatters currently are known to accept include &quot;roff&quot;, &quot;man&quot;, &quot;latex&quot;, &quot;tex&quot;, &quot;text&quot;, and &quot;html&quot;. (Some formatters will treat some of these as synonyms.)</source>
          <target state="translated">포맷터가 현재 허용하는 것으로 알려진 일부 형식 이름에는 &quot;roff&quot;, &quot;man&quot;, &quot;latex&quot;, &quot;tex&quot;, &quot;text&quot;및 &quot;html&quot;이 있습니다. 일부 포매터는이 중 일부를 동의어로 취급합니다.</target>
        </trans-unit>
        <trans-unit id="bae9c58f7596d57c13463eeb374970b17faa09ff" translate="yes" xml:space="preserve">
          <source>Some frequently seen examples:</source>
          <target state="translated">자주 볼 수있는 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="5f63fbe742ecc7df05393f6e705a1b34f98dd874" translate="yes" xml:space="preserve">
          <source>Some functions are provided to simplify customization.</source>
          <target state="translated">사용자 정의를 단순화하기 위해 일부 기능이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="37fca23bc4f77bc45e835fb641ab69a99facbd7e" translate="yes" xml:space="preserve">
          <source>Some functions are slower when working on UTF-8 encoded strings than on byte encoded strings. All functions that need to hop over characters such as &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index()&lt;/a&gt;&lt;/code&gt;, or matching regular expressions can work &lt;b&gt;much&lt;/b&gt; faster when the underlying data are byte-encoded.</source>
          <target state="translated">바이트 인코딩 문자열보다 UTF-8 인코딩 문자열에서 작업 할 때 일부 기능이 느려집니다. 기본 데이터를 바이트 인코딩하면 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index()&lt;/a&gt;&lt;/code&gt; 또는 일치하는 정규 표현식 과 같은 문자를 건너 뛰어야하는 모든 함수가 &lt;b&gt;훨씬&lt;/b&gt; 빠르게 작동 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83116620b210d6b01d6ea586806a731e05a2beb8" translate="yes" xml:space="preserve">
          <source>Some functions available based on the version of VMS. (VMS)</source>
          <target state="translated">VMS 버전에 따라 일부 기능을 사용할 수 있습니다. (VMS)</target>
        </trans-unit>
        <trans-unit id="851bf3122418d781546b0c8256e17049b7be4c91" translate="yes" xml:space="preserve">
          <source>Some languages work directly with the memory addresses of values, but this can be like playing with fire. Perl provides a set of asbestos gloves for handling all memory management. The closest to an address operator in Perl is the backslash operator, but it gives you a &lt;b&gt;hard reference&lt;/b&gt;, which is much safer than a memory address.</source>
          <target state="translated">일부 언어는 값의 메모리 주소와 직접 작동하지만 불을 가지고 노는 것과 같습니다. Perl은 모든 메모리 관리를 처리하기위한 석면 장갑 세트를 제공합니다. Perl에서 주소 연산자와 가장 가까운 것은 백 슬래시 연산자이지만, &lt;b&gt;하드&lt;/b&gt; 주소보다 훨씬 안전한 &lt;b&gt;하드 참조를&lt;/b&gt; 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="f2704cdd835e2ffc2151c5b3e73d345acc2100f0" translate="yes" xml:space="preserve">
          <source>Some locales have special sorting rules.</source>
          <target state="translated">일부 로케일에는 특별한 정렬 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cbad0bcc8b3efd678863ec66e302790409bbb20" translate="yes" xml:space="preserve">
          <source>Some methods take slightly different arguments to those defined in &lt;a href=&quot;../perlfunc&quot;&gt;perlfunc&lt;/a&gt; in attempt to make the interface more flexible. These are</source>
          <target state="translated">일부 메소드 는 인터페이스를보다 유연하게 만들기 위해 &lt;a href=&quot;../perlfunc&quot;&gt;perlfunc&lt;/a&gt; 에 정의 된 것과 약간 다른 인수를 취 합니다. 이것들은</target>
        </trans-unit>
        <trans-unit id="4d5ca2cd44839d0147fa7ed895887914f1a8f96d" translate="yes" xml:space="preserve">
          <source>Some modules have an event loop, waiting for user-input. It is highly unlikely that two such modules would work adequately together in a single Perl application.</source>
          <target state="translated">일부 모듈에는 사용자 입력을 기다리는 이벤트 루프가 있습니다. 이러한 두 모듈이 단일 Perl 응용 프로그램에서 적절하게 함께 작동 할 가능성은 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="99aeed54cc1e7c695f296661c28f743d9f582de7" translate="yes" xml:space="preserve">
          <source>Some modules have validation for particular types of input, such as &lt;a href=&quot;http://search.cpan.org/perldoc/Business::ISBN&quot;&gt;Business::ISBN&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Business::CreditCard&quot;&gt;Business::CreditCard&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Valid&quot;&gt;Email::Valid&lt;/a&gt;, and &lt;a href=&quot;http://search.cpan.org/perldoc/Data::Validate::IP&quot;&gt;Data::Validate::IP&lt;/a&gt;.</source>
          <target state="translated">일부 모듈에는 &lt;a href=&quot;http://search.cpan.org/perldoc/Business::ISBN&quot;&gt;Business :: ISBN&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Business::CreditCard&quot;&gt;Business :: CreditCard&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Valid&quot;&gt;Email :: Valid&lt;/a&gt; 및 &lt;a href=&quot;http://search.cpan.org/perldoc/Data::Validate::IP&quot;&gt;Data :: Validate :: IP&lt;/a&gt; 와 같은 특정 유형의 입력에 대한 유효성 검사가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8896acdebb142a8bf319a25d0ebc467b0372d0f5" translate="yes" xml:space="preserve">
          <source>Some modules live both in the &lt;b&gt;Standard Library&lt;/b&gt; and on &lt;b&gt;CPAN&lt;/b&gt;. These modules might be developed on two tracks as people modify either version. The trend currently is to untangle these situations.</source>
          <target state="translated">일부 모듈은 &lt;b&gt;표준 라이브러리&lt;/b&gt; 와 &lt;b&gt;CPAN에 모두&lt;/b&gt; 있습니다. 이 모듈은 사람들이 두 버전을 수정함에 따라 두 개의 트랙에서 개발 될 수 있습니다. 현재 추세는 이러한 상황을 해결하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2536c5611f03605401087c295c560b8c0a55966f" translate="yes" xml:space="preserve">
          <source>Some modules might have special reporting requirements, such as a Github or Google Code tracking system, so you should check the module documentation too.</source>
          <target state="translated">일부 모듈에는 Github 또는 Google 코드 추적 시스템과 같은 특별한보고 요구 사항이있을 수 있으므로 모듈 설명서도 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="9d3dcbb265761ea263567338345aa34c90c2eea2" translate="yes" xml:space="preserve">
          <source>Some modules, mainly extensions, provide their own AUTOLOAD subroutines. They typically need to check for some special cases (such as constants) and then fallback to &lt;b&gt;AutoLoader&lt;/b&gt;'s AUTOLOAD for the rest.</source>
          <target state="translated">주로 확장 인 일부 모듈은 자체 AUTOLOAD 서브 루틴을 제공합니다. 일반적으로 상수와 같은 특별한 경우를 확인한 다음 나머지는 &lt;b&gt;AutoLoader&lt;/b&gt; 의 AUTOLOAD 로 대체해야 합니다.</target>
        </trans-unit>
        <trans-unit id="2c12ec8767768e2405ac12fa9dd3e5b3e02eaa4d" translate="yes" xml:space="preserve">
          <source>Some names known to &lt;code&gt;\N{...}&lt;/code&gt; refer to a sequence of multiple characters, instead of the usual single character. When one of these is included in the class, the entire sequence is matched. For example,</source>
          <target state="translated">&lt;code&gt;\N{...}&lt;/code&gt; 알려진 일부 이름 은 일반적인 단일 문자 대신 여러 문자 시퀀스를 나타냅니다. 이들 중 하나가 클래스에 포함되면 전체 시퀀스가 ​​일치합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="86874fce71a4882d328a8877cd2a4fc52a6a4fe2" translate="yes" xml:space="preserve">
          <source>Some networking library functions like gethostbyname() are known to have their own implementations of timeouts which may conflict with your timeouts. If you have problems with such functions, try using the POSIX sigaction() function, which bypasses Perl safe signals. Be warned that this does subject you to possible memory corruption, as described above.</source>
          <target state="translated">gethostbyname ()과 같은 일부 네트워킹 라이브러리 함수에는 시간 초과와 충돌 할 수있는 자체 시간 초과 구현이있는 것으로 알려져 있습니다. 이러한 함수에 문제가 있으면 Perl 안전 신호를 무시하는 POSIX sigaction () 함수를 사용해보십시오. 위에 설명 된대로 메모리 손상이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ce6014b84ac6fe075f649ff6034ad219b7b909a" translate="yes" xml:space="preserve">
          <source>Some non-Perl implementations of the Age property may change its meaning to be the same as the Perl &lt;code&gt;Present_In&lt;/code&gt; property; just be aware of that.</source>
          <target state="translated">Age 속성의 일부 Perl 이외의 구현은 Perl &lt;code&gt;Present_In&lt;/code&gt; 속성 과 같은 의미로 변경 될 수 있습니다 . 그냥 알아 둬</target>
        </trans-unit>
        <trans-unit id="020d12e0872ef168546404b52284bd6940ecd187" translate="yes" xml:space="preserve">
          <source>Some non-numeric HTML entity name, such as &lt;code&gt;E&amp;lt;eacute&amp;gt;&lt;/code&gt; , meaning the same thing as &lt;code&gt;&amp;amp;eacute;&lt;/code&gt; in HTML -- i.e., a lowercase e with an acute (/-shaped) accent.</source>
          <target state="translated">같은 일부 숫자가 아닌 HTML 엔티티 이름, &lt;code&gt;E&amp;lt;eacute&amp;gt;&lt;/code&gt; , 같은 일을 의미 &lt;code&gt;&amp;amp;eacute;&lt;/code&gt; HTML에서, 즉 예를 들어, 급성 (/ 모양) 악센트가있는 소문자 e.</target>
        </trans-unit>
        <trans-unit id="742d524f056fc75f1015c7da11070249cb40a21b" translate="yes" xml:space="preserve">
          <source>Some notes about ftp archives: Please use a long descriptive file name that includes the version number. Most incoming directories will not be readable/listable, i.e., you won't be able to see your file after uploading it. Remember to send your email notification message as soon as possible after uploading else your file may get deleted automatically. Allow time for the file to be processed and/or check the file has been processed before announcing its location.</source>
          <target state="translated">ftp 아카이브에 대한 참고 사항 : 버전 번호가 포함 된 긴 설명 파일 이름을 사용하십시오. 대부분의 수신 디렉토리는 읽거나 나열 할 수 없습니다. 즉, 파일을 업로드 한 후에는 파일을 볼 수 없습니다. 업로드 후 가능한 빨리 이메일 알림 메시지를 보내야합니다. 그렇지 않으면 파일이 자동으로 삭제 될 수 있습니다. 파일을 처리 할 시간을 허용하거나 파일 위치를 알리기 전에 파일이 처리되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="cc5039f425d422cec80636f2fe25c7aa8c335808" translate="yes" xml:space="preserve">
          <source>Some of the books we've listed appear almost ancient in internet scale, but we've included those books because they still describe the current way of doing things. Not everything in Perl changes every day. Many of the beginner-level books, too, go over basic features and techniques that are still valid today. In general though, we try to limit this list to books published in the past five years.</source>
          <target state="translated">우리가 나열한 책 중 일부는 인터넷 규모가 거의 고대인 것처럼 보이지만, 현재 진행중인 방식을 설명하기 때문에 해당 책을 포함 시켰습니다. Perl의 모든 것이 매일 바뀌지는 않습니다. 초보자 수준의 많은 책들도 오늘날에도 여전히 유효한 기본 기능과 기술을 살펴 봅니다. 그러나 일반적으로이 목록을 지난 5 년 동안 출판 된 책으로 제한하려고합니다.</target>
        </trans-unit>
        <trans-unit id="ec6365cb89577ea447484ee46de59521b7dffa94" translate="yes" xml:space="preserve">
          <source>Some of the built-in functions do not act exactly as documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;, and a few are not implemented at all. To avoid surprises, particularly if you have had prior exposure to Perl in other operating environments or if you intend to write code that will be portable to other environments, see &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for a reasonably definitive list of these differences.</source>
          <target state="translated">내장 함수 중 일부는 &lt;a href=&quot;perlfunc&quot;&gt;perlfunc에&lt;/a&gt; 설명 된대로 정확하게 작동하지 않으며 일부는 전혀 구현되지 않았습니다. 놀랍게도, 특히 다른 운영 환경에서 Perl에 사전 노출 된 적이 있거나 다른 환경에 이식 가능한 코드를 작성하려는 경우 &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; 에서 이러한 차이점에 대한 합리적인 결정 목록을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0c8239353496c2009cfe543c3292467ce35311ef" translate="yes" xml:space="preserve">
          <source>Some of the configuration files in /etc used by the networking APIs are either missing or have the wrong names. In particular, make sure that there's either an /etc/resolv.conf or an /etc/hosts, so that gethostbyname() works, and make sure that the file /etc/proto has been renamed to /etc/protocol (NOT /etc/protocols, as used by other Unix systems). You may have to look for things like HOSTNAME and DOMAINORIGIN in the &quot;//'SYS1.TCPPARMS(TCPDATA)'&quot; PDS member in order to properly set up your /etc networking files.</source>
          <target state="translated">네트워킹 API가 사용하는 / etc의 일부 구성 파일이 누락되었거나 이름이 잘못되었습니다. 특히, gethostbyname ()이 작동하도록 /etc/resolv.conf 또는 / etc / hosts가 있는지 확인하고 / etc / proto 파일의 이름이 / etc / protocol (NOT / 기타 유닉스 시스템에서 사용되는 기타 / 프로토콜). / etc 네트워킹 파일을 올바르게 설정하기 위해 &quot;//'SYS1.TCPPARMS(TCPDATA) '&quot;PDS 멤버에서 HOSTNAME 및 DOMAINORIGIN과 같은 항목을 찾아야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4c6dd767013c78841ab05e0e012ebcc93f26f14" translate="yes" xml:space="preserve">
          <source>Some of the examples later in &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt; use the &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt; module from CPAN. The reason you might choose &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt; over the perl built-in functions is that it works with numbers of ANY size, that it is optimized for speed on some operations, and for at least some programmers the notation might be familiar.</source>
          <target state="translated">&lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt; 에서 나중에 나오는 일부 예 는 CPAN 의 &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit :: Vector&lt;/a&gt; 모듈을 사용합니다 . perl 내장 함수보다 &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit :: Vector&lt;/a&gt; 를 선택할 수있는 이유 는 모든 크기의 숫자에서 작동하고 일부 작업의 속도에 최적화되어 있으며 적어도 일부 프로그래머에게는 익숙한 표기법이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="b1b52c56fd19edbbc0804a6b9841658fb64d4030" translate="yes" xml:space="preserve">
          <source>Some of the functionality of the debugging code can be achieved using XS modules.</source>
          <target state="translated">디버깅 코드의 일부 기능은 XS 모듈을 사용하여 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="129d9d1e78c142ea547ff6b028cde8ebd0aadf7f" translate="yes" xml:space="preserve">
          <source>Some of the functions are called with a</source>
          <target state="translated">함수 중 일부는</target>
        </trans-unit>
        <trans-unit id="43704b45451eba3bea984abb31f94004f6ecfd41" translate="yes" xml:space="preserve">
          <source>Some of the highlights of &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; 의 주요 특징 중 일부 :</target>
        </trans-unit>
        <trans-unit id="c35b9e6be7b3bf5bc03040d536fb7da8f901aae2" translate="yes" xml:space="preserve">
          <source>Some of the methods defined in &lt;code&gt;Net::FTP&lt;/code&gt; return an object which will be derived from the &lt;code&gt;Net::FTP::dataconn&lt;/code&gt; class. See &lt;a href=&quot;ftp/dataconn&quot;&gt;Net::FTP::dataconn&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;Net::FTP&lt;/code&gt; 정의 된 일부 메소드 는 &lt;code&gt;Net::FTP::dataconn&lt;/code&gt; 클래스 에서 파생 된 오브젝트를 리턴합니다 . 자세한 내용은 &lt;a href=&quot;ftp/dataconn&quot;&gt;Net :: FTP :: dataconn&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="085f62b2598cb482a6875006e876358d6d804f21" translate="yes" xml:space="preserve">
          <source>Some of the methods defined in &lt;code&gt;Net::FTP&lt;/code&gt; return an object which will be derived from this class. The dataconn class itself is derived from the &lt;code&gt;IO::Socket::INET&lt;/code&gt; class, so any normal IO operations can be performed. However the following methods are defined in the dataconn class and IO should be performed using these.</source>
          <target state="translated">&lt;code&gt;Net::FTP&lt;/code&gt; 정의 된 일부 메서드 는이 클래스에서 파생 된 개체를 반환합니다. dataconn 클래스 자체는 &lt;code&gt;IO::Socket::INET&lt;/code&gt; 클래스 에서 파생 되므로 일반적인 IO 작업을 수행 할 수 있습니다. 그러나 다음 메소드는 dataconn 클래스에 정의되어 있으며이를 사용하여 IO를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="312d5ef79ec3abd87646ed6a59f9c68ae862462d" translate="yes" xml:space="preserve">
          <source>Some of the most common mistakes:</source>
          <target state="translated">가장 일반적인 실수 중 일부 :</target>
        </trans-unit>
        <trans-unit id="5796d9bed54a4c270451442098ed19f9f0088003" translate="yes" xml:space="preserve">
          <source>Some of the most common values are &lt;code&gt;O_RDONLY&lt;/code&gt; for opening the file in read-only mode, &lt;code&gt;O_WRONLY&lt;/code&gt; for opening the file in write-only mode, and &lt;code&gt;O_RDWR&lt;/code&gt; for opening the file in read-write mode.</source>
          <target state="translated">가장 일반적인 값 중 일부는 파일을 읽기 전용 모드로 여는 경우 &lt;code&gt;O_RDONLY&lt;/code&gt; , 파일을 쓰기 전용 모드로 여는 경우 &lt;code&gt;O_WRONLY&lt;/code&gt; , 파일을 읽기 / 쓰기 모드로 여는 경우 &lt;code&gt;O_RDWR&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d5f4367d2cd66fe5bca2400a4df459be12cf9924" translate="yes" xml:space="preserve">
          <source>Some of the parser default template files in /samples are needed in /etc. In particular be sure that you at least copy /samples/yyparse.c to /etc before running Perl's Configure. This step ensures successful extraction of EBCDIC versions of parser files such as perly.c and perly.h. This has to be done before running Configure the first time. If you failed to do so then the easiest way to re-Configure Perl is to delete your misconfigured build root and re-extract the source from the tar ball. Then you must ensure that /etc/yyparse.c is properly in place before attempting to re-run Configure.</source>
          <target state="translated">/ samples의 일부 파서 기본 템플릿 파일은 / etc에 필요합니다. 특히 Perl의 Configure를 실행하기 전에 최소한 /samples/yyparse.c를 / etc에 복사해야합니다. 이 단계는 perly.c 및 perly.h와 같은 구문 분석기 파일의 EBCDIC 버전을 성공적으로 추출합니다. 구성을 처음 실행하기 전에 수행해야합니다. 그렇지 않은 경우 Perl을 다시 구성하는 가장 쉬운 방법은 잘못 구성된 빌드 루트를 삭제하고 tar ball에서 소스를 다시 추출하는 것입니다. 그런 다음 Configure를 다시 실행하기 전에 /etc/yyparse.c가 제자리에 있는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="83c0811a95d044951ce0ba50edb2e9cd1f45c8cb" translate="yes" xml:space="preserve">
          <source>Some of the reported info, such as hex addresses, is not particularly valuable. Other information would be more useful for the typical programmer, such as line-numbers, pad-slot reuses, etc.. Given this, -newlex is not a particularly good flag-name.</source>
          <target state="translated">16 진 주소와 같은보고 된 정보 중 일부는 특별히 중요하지 않습니다. 행 번호, 패드 슬롯 재사용 등과 같은 다른 정보는 일반적인 프로그래머에게 더 유용 할 것입니다.이를 감안할 때 -newlex는 특히 좋은 플래그 이름이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="2cdf99bdb0c6c762dab8d358da246b612330e8fa" translate="yes" xml:space="preserve">
          <source>Some of these are also deprecated. You can exclude these from your compiled Perl by adding this option to Configure: &lt;code&gt;-Accflags='-DNO_MATHOMS'&lt;/code&gt;</source>
          <target state="translated">이들 중 일부는 더 이상 사용되지 않습니다. 이 옵션을 구성에 추가하여 컴파일 된 Perl에서이를 제외 할 수 있습니다. &lt;code&gt;-Accflags='-DNO_MATHOMS'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d94da1d47f6dfef189dc9a92fab735da2e9c93d7" translate="yes" xml:space="preserve">
          <source>Some of these books are available as free downloads.</source>
          <target state="translated">이 책들 중 일부는 무료로 다운로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55b425b2a6fe515905b997d3820e2d955eabc2cf" translate="yes" xml:space="preserve">
          <source>Some of these functions also combine dynaloading semantic with the error-propagation semantic discussed above.</source>
          <target state="translated">이러한 기능 중 일부는 또한 위에서 설명한 오류 전파 의미론과 dynaloading 의미론을 결합합니다.</target>
        </trans-unit>
        <trans-unit id="7a3b090758880601b5c97fb9b694e1e73a3369bc" translate="yes" xml:space="preserve">
          <source>Some of these methods might be of interest to general users, as well as of interest to formatter-writers.</source>
          <target state="translated">이러한 방법 중 일부는 일반 사용자뿐만 아니라 포맷터 작성자에게도 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80eb2a0ac01474685656b9eca0e98318c5698b3f" translate="yes" xml:space="preserve">
          <source>Some of these pseudo-modules import semantics into the current block scope (like &lt;code&gt;strict&lt;/code&gt; or &lt;code&gt;integer&lt;/code&gt; , unlike ordinary modules, which import symbols into the current package (which are effective through the end of the file).</source>
          <target state="translated">이러한 의사 모듈 중 일부는 시맨틱을 현재 블록 범위로 가져옵니다 ( 일반 모듈과 달리 &lt;code&gt;strict&lt;/code&gt; 또는 &lt;code&gt;integer&lt;/code&gt; 등). 심볼을 현재 패키지로 가져 오는 (파일 끝까지 유효)</target>
        </trans-unit>
        <trans-unit id="8fc82daea8e525be9f1657205fd39cc94c0720ec" translate="yes" xml:space="preserve">
          <source>Some of these specific cases are shown as examples in other answers in this section of the perlfaq.</source>
          <target state="translated">이러한 특정 사례 중 일부는 perlfaq의이 섹션에서 다른 답변의 예로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7ac7dfacde52b03cada88bb1c11d6be2449d545b" translate="yes" xml:space="preserve">
          <source>Some of this may be confusing. Here's a handy reference to the ASCII CR and LF characters. You can print it out and stick it in your wallet.</source>
          <target state="translated">이 중 일부는 혼란 스러울 수 있습니다. 다음은 ASCII CR 및 LF 문자에 대한 편리한 참조입니다. 인쇄하여 지갑에 붙일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9436ec9fafb3dbaf8b6e8266e0c7a558118556b8" translate="yes" xml:space="preserve">
          <source>Some older Pod translators require paragraphs (including command paragraphs like &quot;=head2 Functions&quot;) to be separated by</source>
          <target state="translated">일부 구형 포드 번역기는 단락 ( &quot;= head2 Functions&quot;와 같은 명령 단락 포함)을 다음과 같이 구분해야합니다.</target>
        </trans-unit>
        <trans-unit id="530312ef21d84b684c5534cd434fe4d79ac602e0" translate="yes" xml:space="preserve">
          <source>Some older versions of Berkeley DB had problems with fixed length records using the RECNO file format. This problem has been fixed since version 1.85 of Berkeley DB.</source>
          <target state="translated">일부 이전 버전의 Berkeley DB는 RECNO 파일 형식을 사용하는 고정 길이 레코드에 문제가있었습니다. 이 문제는 Berkeley DB 버전 1.85부터 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="4c2cd6192ba71ba66f15fbdbb416f6e8ad76580e" translate="yes" xml:space="preserve">
          <source>Some operating systems don't ship the CORE directory with their base perl install. To solve the problem, you likely need to install a perl development package such as perl-devel (CentOS, Fedora and other Redhat systems) or perl (Ubuntu and other Debian systems).</source>
          <target state="translated">일부 운영 체제는 기본 perl 설치와 함께 CORE 디렉토리를 제공하지 않습니다. 이 문제를 해결하려면 perl-devel (CentOS, Fedora 및 기타 Redhat 시스템) 또는 perl (우분투 및 기타 데비안 시스템)과 같은 perl 개발 패키지를 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="a0bcdb116909bbaf782dcc8531648c8104b0144b" translate="yes" xml:space="preserve">
          <source>Some operating systems have bugs in the kernel that make setuid scripts inherently insecure. Perl gives you a number of options (described in &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;) to work around such systems.</source>
          <target state="translated">일부 운영 체제의 커널에는 setuid 스크립트가 본질적으로 안전하지 않은 버그가 있습니다. Perl은 이러한 시스템을 해결하기 위한 많은 옵션 ( &lt;a href=&quot;perlsec&quot;&gt;perlsec에&lt;/a&gt; 설명되어 있음 )을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2250e1a4559063fcac9cec7cc104374f3f26f7ef" translate="yes" xml:space="preserve">
          <source>Some operating systems may perform &lt;code&gt;IO::File::new()&lt;/code&gt; or &lt;code&gt;IO::File::open()&lt;/code&gt; on a directory without errors. This behavior is not portable and not suggested for use. Using &lt;code&gt;&lt;a href=&quot;../functions/opendir&quot;&gt;opendir()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;IO::Dir&lt;/code&gt; are suggested instead.</source>
          <target state="translated">일부 운영 체제는 디렉토리에서 &lt;code&gt;IO::File::new()&lt;/code&gt; 또는 &lt;code&gt;IO::File::open()&lt;/code&gt; 을 오류없이 수행 할 수 있습니다. 이 동작은 이식 ​​가능하지 않으므로 사용하지 않는 것이 좋습니다. 사용 &lt;code&gt;&lt;a href=&quot;../functions/opendir&quot;&gt;opendir()&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;IO::Dir&lt;/code&gt; 대신 제안한다.</target>
        </trans-unit>
        <trans-unit id="39015af4e836c35f8e25b30fad81d0e5afdfce43" translate="yes" xml:space="preserve">
          <source>Some operations may be slower for small numbers, but are significantly faster for big numbers. Other operations are now constant (O(1), like &lt;code&gt;bneg()&lt;/code&gt; , &lt;code&gt;babs()&lt;/code&gt; etc), instead of O(N) and thus nearly always take much less time. These optimizations were done on purpose.</source>
          <target state="translated">작은 숫자의 경우 일부 작업이 느릴 수 있지만 큰 숫자의 경우 훨씬 빠릅니다. 다른 연산은 이제 O (N) 대신 일정 (O (1), &lt;code&gt;bneg()&lt;/code&gt; , &lt;code&gt;babs()&lt;/code&gt; 등)이므로 거의 항상 훨씬 적은 시간이 걸립니다. 이러한 최적화는 일부러 이루어졌습니다.</target>
        </trans-unit>
        <trans-unit id="03ecacb543bf1cb170543843116f3f4c7e881ad8" translate="yes" xml:space="preserve">
          <source>Some other (not completely debugged) situations when FP flags change include some video drivers (?), and some operations related to creation of the windows. People who code &lt;b&gt;OpenGL&lt;/b&gt; may have more experience on this.</source>
          <target state="translated">FP 플래그가 변경 될 때 발생하는 일부 (완전히 디버깅되지 않은) 상황에는 일부 비디오 드라이버 (?) 및 창 생성과 관련된 일부 작업이 포함됩니다. &lt;b&gt;OpenGL&lt;/b&gt; 을 코딩 &lt;b&gt;하는&lt;/b&gt; 사람들 은 이에 대해 더 많은 경험을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="377fbf88a15d635b8d6d486abdf4ac17224b10a7" translate="yes" xml:space="preserve">
          <source>Some other IO modules don't belong to the perl core but can be loaded as well if they have been installed from CPAN. You can discover which ones exist by searching for &quot;^IO::&quot; on &lt;a href=&quot;http://search.cpan.org&quot;&gt;http://search.cpan.org&lt;/a&gt;.</source>
          <target state="translated">다른 IO 모듈은 perl 코어에 속하지 않지만 CPAN에서 설치 한 경우에도로드 할 수 있습니다. &lt;a href=&quot;http://search.cpan.org&quot;&gt;http://search.cpan.org&lt;/a&gt; 에서 &quot;^ IO ::&quot;를 검색하여 존재하는 항목을 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7424cd4ab88fb33b2270b2db7bbe8e04cad5739e" translate="yes" xml:space="preserve">
          <source>Some output formats that do allow rendering &quot;L&amp;lt;...&amp;gt;&quot; codes as hypertext, might not allow the link-text to be formatted; in that case, formatters will have to just ignore that formatting.</source>
          <target state="translated">&quot;L &amp;lt;...&amp;gt;&quot;코드를 하이퍼 텍스트로 렌더링 할 수있는 일부 출력 형식은 링크 텍스트의 형식을 허용하지 않을 수 있습니다. 이 경우 포맷터는 해당 포맷을 무시해야합니다.</target>
        </trans-unit>
        <trans-unit id="e1a79a974eeb026992ad7b1bb5fab50968d6932c" translate="yes" xml:space="preserve">
          <source>Some passes discussed below are performed concurrently, but because their results are the same, we consider them individually. For different quoting constructs, Perl performs different numbers of passes, from one to four, but these passes are always performed in the same order.</source>
          <target state="translated">아래에 설명 된 일부 패스는 동시에 수행되지만 결과가 동일하기 때문에 개별적으로 고려합니다. 다른 인용 구조의 경우, Perl은 1에서 4까지 다른 수의 패스를 수행하지만 이러한 패스는 항상 동일한 순서로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="7ae8fed66b51985370778e2e29c81e03a37d1f13" translate="yes" xml:space="preserve">
          <source>Some people get too used to writing things like:</source>
          <target state="translated">어떤 사람들은 다음과 같은 글을 쓰는 데 너무 익숙합니다.</target>
        </trans-unit>
        <trans-unit id="970ff42e05d0088fd549cac2a995425a1e1eba68" translate="yes" xml:space="preserve">
          <source>Some people have reported encountering &quot;Out of memory!&quot; errors while trying to build Perl using GNU make binaries. If you encounter such trouble then try to download the source code kit and build GNU make from source to eliminate any such trouble. You might also find GNU make (as well as Perl and Apache) in the red-piece/book &quot;Open Source Software for OS/390 UNIX&quot;, SG24-5944-00 from IBM.</source>
          <target state="translated">어떤 사람들은 &quot;메모리 부족!&quot; GNU make 바이너리를 사용하여 Perl을 빌드하는 중에 오류가 발생했습니다. 이러한 문제가 발생하면 소스 코드 키트를 다운로드하고 소스에서 GNU make를 빌드하여 이러한 문제를 해결하십시오. IBM의 레드 피스 / 책 &quot;OS / 390 UNIX 용 오픈 소스 소프트웨어&quot;, SG24-5944-00에서 GNU make (Perl 및 Apache)를 찾을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="98c7c01703d39bcc6345fdf8d617292db8f23d37" translate="yes" xml:space="preserve">
          <source>Some people may be inclined to include an explicit &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; in the above XSUB, rather than letting control fall through to the end. In those situations &lt;code&gt;XSRETURN_EMPTY&lt;/code&gt; should be used, instead. This will ensure that the XSUB stack is properly adjusted. Consult &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for other &lt;code&gt;XSRETURN&lt;/code&gt; macros.</source>
          <target state="translated">어떤 사람들은 통제권을 끝까지 넘어 뜨리지 않고 위의 XSUB에 명시적인 &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 을 포함 시키려는 경향이있을 수 있습니다 . 이러한 상황에서는 대신 &lt;code&gt;XSRETURN_EMPTY&lt;/code&gt; 를 사용해야합니다. 이렇게하면 XSUB 스택이 올바르게 조정됩니다. 다른 &lt;code&gt;XSRETURN&lt;/code&gt; 매크로에 대해서는 &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6b055a6a001cadf9ec7b3e638f2bc15cb8ed85e4" translate="yes" xml:space="preserve">
          <source>Some people may wish to outlaw barewords entirely. If you say</source>
          <target state="translated">일부 사람들은 베어 워드를 완전히 금지하고 싶을 수도 있습니다. 당신이 말하는 경우</target>
        </trans-unit>
        <trans-unit id="bae38a7d38c5d89eb67db6e4b702e604142997e5" translate="yes" xml:space="preserve">
          <source>Some people mistakenly regard this as a security problem. If your program does insecure things, and relies on people not knowing how to exploit those insecurities, it is not secure. It is often possible for someone to determine the insecure things and exploit them without viewing the source. Security through obscurity, the name for hiding your bugs instead of fixing them, is little security indeed.</source>
          <target state="translated">어떤 사람들은 이것을 보안 문제로 잘못 간주합니다. 프로그램이 안전하지 않은 작업을 수행하고 해당 보안 문제를 악용하는 방법을 모르는 사람들에게 의존하는 경우 안전하지 않습니다. 누군가가 불안전 한 것을 결정하고 소스를 보지 않고 악용하는 것이 종종 가능합니다. 버그를 수정하는 대신 숨기는 이름 인 모호함을 통한 보안은 실제로 보안이 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="df10001a5e994bd1a3232bcb5d3f173424f0cd78" translate="yes" xml:space="preserve">
          <source>Some people need this and some people avoid it. For Perl, it&amp;rsquo;s an old way to say &lt;b&gt;I/O layer&lt;/b&gt;.</source>
          <target state="translated">어떤 사람들은 이것을 필요로하고 어떤 사람들은 그것을 피합니다. Perl의 경우 &lt;b&gt;I / O 레이어&lt;/b&gt; 를 말하는 오래된 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="37ecbcdb1f8127ee6539d97d23e8c04d2e848681" translate="yes" xml:space="preserve">
          <source>Some people regard this as a security problem. If your program does insecure things and relies on people not knowing how to exploit those insecurities, it is not secure. It is often possible for someone to determine the insecure things and exploit them without viewing the source. Security through obscurity, the name for hiding your bugs instead of fixing them, is little security indeed.</source>
          <target state="translated">어떤 사람들은 이것을 보안 문제로 간주합니다. 프로그램이 안전하지 않은 작업을 수행하고 해당 보안 문제를 악용하는 방법을 모르는 사람들에게 의존하는 경우 안전하지 않습니다. 누군가가 불안전 한 것을 결정하고 소스를 보지 않고 악용하는 것이 종종 가능합니다. 버그를 수정하는 대신 숨기는 이름 인 모호함을 통한 보안은 실제로 보안이 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="646207c2365abd1daf6b5c56b0451ba2ee5e82de" translate="yes" xml:space="preserve">
          <source>Some platforms (Win32, AIX, VMS, OS/2, to name a few) require any function that is part of the public API (the shared Perl library) to be explicitly marked as exported. See the discussion about</source>
          <target state="translated">일부 플랫폼 (Win32, AIX, VMS, OS / 2)은 공개 API (공유 Perl 라이브러리)의 일부인 기능을 명시 적으로 익스포트 된 것으로 표시해야합니다. 에 대한 토론을 참조하십시오</target>
        </trans-unit>
        <trans-unit id="29e0751f43cf70fa1b809101e7e4735cf3d63955" translate="yes" xml:space="preserve">
          <source>Some platforms can't delete or rename files held open by the system, this limitation may also apply to changing filesystem metainformation like file permissions or owners. Remember to &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; files when you are done with them. Don't &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename&lt;/a&gt;&lt;/code&gt; an open file. Don't &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; a file already tied or opened; &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; it first.</source>
          <target state="translated">일부 플랫폼은 시스템에서 열린 파일을 삭제하거나 이름을 바꿀 수 없습니다.이 제한은 파일 권한 또는 소유자와 같은 파일 시스템 메타 정보 변경에도 적용될 수 있습니다. 작업이 끝나면 파일 을 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 합니다. 열린 파일을 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 하거나 &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename&lt;/a&gt;&lt;/code&gt; 마십시오 . 하지 마십시오 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 이미 연결 또는 열린 파일을; 먼저 &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; 거나 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 십시오.</target>
        </trans-unit>
        <trans-unit id="da26b78199e00ef73fdfb4bbe53a1032367ab8a7" translate="yes" xml:space="preserve">
          <source>Some platforms have a minimum thread stack size. Trying to set the stack size below this value will result in a warning, and the minimum stack size will be used.</source>
          <target state="translated">일부 플랫폼에는 최소 스레드 스택 크기가 있습니다. 스택 크기를이 값 아래로 설정하려고하면 경고가 발생하고 최소 스택 크기가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bcf43713051466cf97d586bae0917d51d61ca30f" translate="yes" xml:space="preserve">
          <source>Some platforms have a minimum thread stack size. Trying to set the stack size below this value will result in the above warning, and the stack size will be set to the minimum.</source>
          <target state="translated">일부 플랫폼에는 최소 스레드 스택 크기가 있습니다. 스택 크기를이 값 아래로 설정하려고하면 위의 경고가 발생하고 스택 크기가 최소로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a11c8787b6044982e680d4ae9bfff407819b6d1c" translate="yes" xml:space="preserve">
          <source>Some platforms have other categories, dealing with such things as measurement units and paper sizes. None of these are used directly by Perl, but outside operations that Perl interacts with may use these. See &lt;a href=&quot;#Not-within-the-scope-of-%22use-locale%22&quot;&gt;Not within the scope of use locale&lt;/a&gt; below.</source>
          <target state="translated">일부 플랫폼에는 측정 단위 및 용지 크기와 같은 항목을 처리하는 다른 범주가 있습니다. 이들 중 어느 것도 Perl에 의해 직접 사용되지는 않지만 Perl과 상호 작용하는 외부 조작에서이를 사용할 수 있습니다. 아래 &lt;a href=&quot;#Not-within-the-scope-of-%22use-locale%22&quot;&gt;의 사용 범위 내에 없음을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="27d67098e269de48eafdad3480b3920c43ba2cb7" translate="yes" xml:space="preserve">
          <source>Some points to note:</source>
          <target state="translated">참고 사항 :</target>
        </trans-unit>
        <trans-unit id="4d3653fc867e65c669e5c29b359dbebb9253c5c0" translate="yes" xml:space="preserve">
          <source>Some possible reasons: your inheritance is getting confused, you've misspelled the method name, or the object is of the wrong type. Check out &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; for details about any of the above cases. You may also use &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; &lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;($object)&lt;/code&gt; to find out the class &lt;code&gt;$object&lt;/code&gt; was blessed into.</source>
          <target state="translated">몇 가지 가능한 이유 : 상속이 혼동되거나 메소드 이름의 철자가 틀리거나 오브젝트의 유형이 잘못되었습니다. 위의 경우에 대한 자세한 내용은 &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; 를 확인하십시오 . &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; &lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;($object)&lt;/code&gt; 를 사용하여 &lt;code&gt;$object&lt;/code&gt; 가 축복받은 클래스를 찾을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b61ffed7b1a69179adefb6f5756bdb1cb79574b" translate="yes" xml:space="preserve">
          <source>Some pragmas are lexically scoped--typically those that affect the &lt;code&gt;$^H&lt;/code&gt; hints variable. Others affect the current package instead, like &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; , which allow you to predeclare a variables or subroutines within a particular</source>
          <target state="translated">일부 pragma는 일반적으로 &lt;code&gt;$^H&lt;/code&gt; hints 변수에 영향을 미치는 어휘 범위 입니다. 처럼 다른 사람들은 대신 현재 패키지에 영향을주는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; 특정 내에서 변수 나 서브 루틴을 미리 선언 할 수 있도록,</target>
        </trans-unit>
        <trans-unit id="ca977f551e014badc60a278bfe97ad872b1a03f5" translate="yes" xml:space="preserve">
          <source>Some problem (forget which ;-)</source>
          <target state="translated">어떤 문제 (어떤 ;-)를 잊어 버려</target>
        </trans-unit>
        <trans-unit id="747d0cb3f2eb2365d2dd72ee766a74de28620e7d" translate="yes" xml:space="preserve">
          <source>Some problems are associated with using temporary files that reside on NFS file systems and it is recommended that a local filesystem is used whenever possible. Some of the security tests will most probably fail when the temp file is not local. Additionally, be aware that the performance of I/O operations over NFS will not be as good as for a local disk.</source>
          <target state="translated">일부 문제는 NFS 파일 시스템에 상주하는 임시 파일 사용과 관련이 있으며 가능할 때마다 로컬 파일 시스템을 사용하는 것이 좋습니다. 임시 파일이 로컬이 아닌 경우 일부 보안 테스트가 실패 할 수 있습니다. 또한 NFS를 통한 I / O 작업의 성능은 로컬 디스크만큼 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="82690c6e6b8e4e473e3f2745d7358e432662fc95" translate="yes" xml:space="preserve">
          <source>Some processors may find that the &lt;code&gt;S&amp;lt;...&amp;gt;&lt;/code&gt; code is easiest to implement by replacing each space in the parse tree under the content of the S, with an NBSP. But note: the replacement should apply</source>
          <target state="translated">일부 프로세서는 &lt;code&gt;S&amp;lt;...&amp;gt;&lt;/code&gt; 코드가 구문 분석 트리의 각 공간을 S의 컨텐츠 아래에있는 NBSP로 대체하여 구현하기가 가장 쉽다 는 것을 알 수 있습니다 . 그러나 참고 : 교체가 적용되어야합니다</target>
        </trans-unit>
        <trans-unit id="229ed6abc320881bbd15c4ddf8619bff82e22293" translate="yes" xml:space="preserve">
          <source>Some programmers choose to use an explicit conversion so as to leave nothing to doubt:</source>
          <target state="translated">일부 프로그래머는 의심 할 여지가 없도록 명시 적 변환을 사용하도록 선택합니다.</target>
        </trans-unit>
        <trans-unit id="76cff92347a8a5dd33b0b88b52afc87676bbe1d1" translate="yes" xml:space="preserve">
          <source>Some programmers may prefer to think of filehandles as objects with methods, preferring to write the last example as:</source>
          <target state="translated">일부 프로그래머는 파일 핸들을 메소드가있는 객체로 생각하고 마지막 예제를 다음과 같이 작성하는 것을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="9293db7d23e9765c2433258535b9e48d3fd5d563" translate="yes" xml:space="preserve">
          <source>Some properties are considered obsolete by Unicode, but still available. There are several varieties of obsolescence:</source>
          <target state="translated">일부 속성은 유니 코드에서 사용되지 않는 것으로 간주되지만 여전히 사용 가능합니다. 몇 가지 종류의 더 이상 사용되지 않는 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e185e2d007b85b8d377436c39a0c68b4b4f4ab1" translate="yes" xml:space="preserve">
          <source>Some rare applications will need to create more than one interpreter during a session. Such an application might sporadically decide to release any resources associated with the interpreter.</source>
          <target state="translated">일부 드문 응용 프로그램은 세션 중에 둘 이상의 인터프리터를 작성해야합니다. 이러한 응용 프로그램은 산발적으로 인터프리터와 관련된 모든 리소스를 해제하기로 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c5ce3e6e9260f74f3afe8318024d986a7fd16de" translate="yes" xml:space="preserve">
          <source>Some regular expressions use identical subpatterns in several places. Starting with Perl 5.10, it is possible to define named subpatterns in a section of the pattern so that they can be called up by name anywhere in the pattern. This syntactic pattern for this definition group is &lt;code&gt;(?(DEFINE)(?&amp;lt;name&amp;gt;pattern)...)&lt;/code&gt;. An insertion of a named pattern is written as &lt;code&gt;(?&amp;amp;name)&lt;/code&gt;.</source>
          <target state="translated">일부 정규식은 여러 곳에서 동일한 하위 패턴을 사용합니다. Perl 5.10부터는 패턴의 섹션에서 이름 지정된 서브 패턴을 정의하여 패턴의 어느 곳에서나 이름으로 호출 할 수 있습니다. 이 정의 그룹의 구문 패턴은 &lt;code&gt;(?(DEFINE)(?&amp;lt;name&amp;gt;pattern)...)&lt;/code&gt; 입니다. 명명 된 패턴의 삽입은 &lt;code&gt;(?&amp;amp;name)&lt;/code&gt; 으로 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="58899e8b736f7c4726449bcec0f3b25df5fc7632" translate="yes" xml:space="preserve">
          <source>Some routines (&lt;code&gt;is_odd()&lt;/code&gt; , &lt;code&gt;is_even()&lt;/code&gt; , &lt;code&gt;is_zero()&lt;/code&gt; , &lt;code&gt;is_one()&lt;/code&gt; , &lt;code&gt;is_nan()&lt;/code&gt; ) return true or false, while others (&lt;code&gt;bcmp()&lt;/code&gt; , &lt;code&gt;bacmp()&lt;/code&gt; ) return either undef, &amp;lt;0, 0 or &amp;gt;0 and are suited for sort.</source>
          <target state="translated">일부 루틴 ( &lt;code&gt;is_odd()&lt;/code&gt; , &lt;code&gt;is_even()&lt;/code&gt; , &lt;code&gt;is_zero()&lt;/code&gt; , &lt;code&gt;is_one()&lt;/code&gt; , &lt;code&gt;is_nan()&lt;/code&gt; )은 true 또는 false를 반환하고 다른 &lt;code&gt;bacmp()&lt;/code&gt; &lt;code&gt;bcmp()&lt;/code&gt; , bacmp () )은 undef, &amp;lt;0, 0 또는&amp;gt; 0을 반환합니다. 정렬에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="834cc437cec84afae22c004e80ee3d6149cb6f55" translate="yes" xml:space="preserve">
          <source>Some routines (&lt;code&gt;is_odd()&lt;/code&gt; , &lt;code&gt;is_even()&lt;/code&gt; , &lt;code&gt;is_zero()&lt;/code&gt; , &lt;code&gt;is_one()&lt;/code&gt; , &lt;code&gt;is_nan()&lt;/code&gt; , etc.) return true or false, while others (&lt;code&gt;bcmp()&lt;/code&gt; , &lt;code&gt;bacmp()&lt;/code&gt; ) return either undef (if NaN is involved), &amp;lt;0, 0 or &amp;gt;0 and are suited for sort.</source>
          <target state="translated">일부 루틴 ( &lt;code&gt;is_odd()&lt;/code&gt; , &lt;code&gt;is_even()&lt;/code&gt; , &lt;code&gt;is_zero()&lt;/code&gt; , &lt;code&gt;is_one()&lt;/code&gt; , &lt;code&gt;is_nan()&lt;/code&gt; 등)은 true 또는 false를 반환하고 다른 &lt;code&gt;bacmp()&lt;/code&gt; &lt;code&gt;bcmp()&lt;/code&gt; , bacmp () )은 undef를 반환합니다 (NaN이 관련된 경우) ), &amp;lt;0, 0 또는&amp;gt; 0이며 정렬에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="b07ef2379b9c2b49ab7fe4b04878c3104f0be76f" translate="yes" xml:space="preserve">
          <source>Some scalar variables contain more than one type of scalar data. For example, the variable &lt;code&gt;$!&lt;/code&gt; contains either the numeric value of &lt;code&gt;errno&lt;/code&gt; or its string equivalent from either &lt;code&gt;strerror&lt;/code&gt; or &lt;code&gt;sys_errlist[]&lt;/code&gt; .</source>
          <target state="translated">일부 스칼라 변수에는 여러 유형의 스칼라 데이터가 포함됩니다. 예를 들어 변수 &lt;code&gt;$!&lt;/code&gt; &lt;code&gt;errno&lt;/code&gt; 의 숫자 값 또는 &lt;code&gt;strerror&lt;/code&gt; 또는 &lt;code&gt;sys_errlist[]&lt;/code&gt; 와 동등한 문자열을 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="b802bf6a4f1848df9acbe46a4e2a4fe02ad51578" translate="yes" xml:space="preserve">
          <source>Some scripts, usually identified with a *.PL extension, are self-configuring and are able to correctly create their own shebang path from config information located in Plan 9 Perl. These you won't need to be worried about.</source>
          <target state="translated">일반적으로 * .PL 확장자로 식별되는 일부 스크립트는 자체 구성되며 Plan 9 Perl에있는 구성 정보에서 자체 Shebang 경로를 올바르게 작성할 수 있습니다. 이것들은 당신이 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="0de1611bc5300339bfc467a34c6fb8f9747fd7ed" translate="yes" xml:space="preserve">
          <source>Some servers are configured to only work in passive mode. If you have one of these you can force &lt;code&gt;Net::FTP&lt;/code&gt; to always transfer in passive mode; when not going via a firewall, by setting &lt;code&gt;ftp_int_passive&lt;/code&gt; to a</source>
          <target state="translated">일부 서버는 수동 모드에서만 작동하도록 구성되어 있습니다. 이 중 하나가 있으면 &lt;code&gt;Net::FTP&lt;/code&gt; 가 항상 수동 모드로 전송되도록 할 수 있습니다 . 방화벽을 통하지 않을 때 &lt;code&gt;ftp_int_passive&lt;/code&gt; 를</target>
        </trans-unit>
        <trans-unit id="ebc3655c5b01cc226f09d2ace7c8e5f430f35ebd" translate="yes" xml:space="preserve">
          <source>Some servers do not understand this command, but issuing it and ignoring the response is harmless.</source>
          <target state="translated">일부 서버는이 명령을 이해하지 못하지만 명령을 실행하고 응답을 무시하는 것은 무해합니다.</target>
        </trans-unit>
        <trans-unit id="c3d7fb888727f4ae5ed3bb068213cd5f194d2bf2" translate="yes" xml:space="preserve">
          <source>Some signals can be neither trapped nor ignored, such as the KILL and STOP (but not the TSTP) signals. Note that ignoring signals makes them disappear. If you only want them blocked temporarily without them getting lost you'll have to use POSIX' sigprocmask.</source>
          <target state="translated">KILL 및 STOP (TSTP는 아님) 신호와 같은 일부 신호는 트랩되거나 무시 될 수 없습니다. 신호를 무시하면 사라집니다. 분실하지 않고 일시적으로 만 차단하려면 POSIX의 sigprocmask를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="2bcba60d06f3c08a852e1ccedb100d4bd2f6af23" translate="yes" xml:space="preserve">
          <source>Some simple style guidelines</source>
          <target state="translated">간단한 스타일 가이드 라인</target>
        </trans-unit>
        <trans-unit id="0a3063c3a46746b861b03ccbf2777db3ca544d44" translate="yes" xml:space="preserve">
          <source>Some simple tricks for determining if you are running on an EBCDIC platform could include any of the following (perhaps all):</source>
          <target state="translated">EBCDIC 플랫폼에서 실행 중인지 확인하기위한 몇 가지 간단한 트릭에는 다음 중 하나가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="038ab8e08e45dcac2b1a2ba44edc5e7ade978952" translate="yes" xml:space="preserve">
          <source>Some source filters use the &lt;code&gt;DATA&lt;/code&gt; handle to read the calling program. When using these source filters you cannot rely on this handle, nor expect any particular kind of behavior when operating on it. Filters based on Filter::Util::Call (and therefore Filter::Simple) do not alter the &lt;code&gt;DATA&lt;/code&gt; filehandle.</source>
          <target state="translated">일부 소스 필터는 &lt;code&gt;DATA&lt;/code&gt; 핸들을 사용 하여 호출 프로그램을 읽습니다. 이러한 소스 필터를 사용할 때이 핸들에 의존하거나 작동 할 때 특정 종류의 동작을 기대할 수 없습니다. Filter :: Util :: Call 기반 필터 (따라서 Filter :: Simple)는 &lt;code&gt;DATA&lt;/code&gt; 파일 핸들을 변경하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5b3ebd295e43b2c81df8bd4b9c3baef266ee5f66" translate="yes" xml:space="preserve">
          <source>Some switches do care if they are processed twice, for instance combinations of &lt;b&gt;-l&lt;/b&gt; and &lt;b&gt;-0&lt;/b&gt;. Either put all the switches after the 32-character boundary (if applicable), or replace the use of &lt;b&gt;-0&lt;/b&gt;</source>
          <target state="translated">일부 스위치는 스위치가 두 번 처리되는지 (예 : &lt;b&gt;-l&lt;/b&gt; 및 &lt;b&gt;-0&lt;/b&gt; 조합)주의합니다 . 모든 스위치를 32 자 경계 뒤에 넣거나 (해당되는 경우) &lt;b&gt;-0을&lt;/b&gt; 대신 사용하십시오.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c346e3627bcf4ba52fad903600add2510035afb4" translate="yes" xml:space="preserve">
          <source>Some systems defined &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; in terms of &lt;code&gt;&lt;a href=&quot;functions/socketpair&quot;&gt;socketpair&lt;/a&gt;&lt;/code&gt;, in which a call to &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;(Rdr, Wtr)&lt;/code&gt; is essentially:</source>
          <target state="translated">정의 된 일부 시스템 &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; 의 측면에서 &lt;code&gt;&lt;a href=&quot;functions/socketpair&quot;&gt;socketpair&lt;/a&gt;&lt;/code&gt; 의 를 호출하는, &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;(Rdr, Wtr)&lt;/code&gt; 본질적으로 :</target>
        </trans-unit>
        <trans-unit id="6fc6b04b810684b6c41fe63810499cab8b09c739" translate="yes" xml:space="preserve">
          <source>Some systems defined &lt;code&gt;&lt;a href=&quot;pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; in terms of &lt;code&gt;&lt;a href=&quot;socketpair&quot;&gt;socketpair&lt;/a&gt;&lt;/code&gt;, in which a call to &lt;code&gt;&lt;a href=&quot;pipe&quot;&gt;pipe&lt;/a&gt;(Rdr, Wtr)&lt;/code&gt; is essentially:</source>
          <target state="translated">정의 된 일부 시스템 &lt;code&gt;&lt;a href=&quot;pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; 의 측면에서 &lt;code&gt;&lt;a href=&quot;socketpair&quot;&gt;socketpair&lt;/a&gt;&lt;/code&gt; 의 를 호출하는, &lt;code&gt;&lt;a href=&quot;pipe&quot;&gt;pipe&lt;/a&gt;(Rdr, Wtr)&lt;/code&gt; 본질적으로 :</target>
        </trans-unit>
        <trans-unit id="ec2cddcb7714cb3145808dbf1959d4cf532d708d" translate="yes" xml:space="preserve">
          <source>Some systems have APIs but not implementations: for example QNX and Haiku have the interval timer APIs but not the functionality.</source>
          <target state="translated">일부 시스템에는 API가 있지만 구현은 없습니다. 예를 들어 QNX 및 Haiku에는 간격 타이머 API가 있지만 기능은 없습니다.</target>
        </trans-unit>
        <trans-unit id="f1b5dcc57517fdbe334dfa953d44b8287e96b48c" translate="yes" xml:space="preserve">
          <source>Some systems may have even weirder byte orders such as</source>
          <target state="translated">일부 시스템은 다음과 같이 더 이상한 바이트 순서를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6223cb44b81823af78522ece7689e7171de5236a" translate="yes" xml:space="preserve">
          <source>Some systems use CONFORMING TO to note conformance to relevant standards and MT-LEVEL to note safeness for use in threaded programs or signal handlers. These headings are primarily useful when documenting parts of a C library.</source>
          <target state="translated">일부 시스템은 CONFORMING TO를 사용하여 관련 표준을 준수하고 MT-LEVEL을 사용하여 스레드 프로그램 또는 신호 처리기에 사용하기위한 안전을 기록합니다. 이 제목은 주로 C 라이브러리의 일부를 문서화 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b5f78f639815d7596cee6bf607be57c18273af36" translate="yes" xml:space="preserve">
          <source>Some test failures may occur if you use a command shell other than the native &quot;cmd.exe&quot;, or if you are building from a path that contains spaces. So don't do that.</source>
          <target state="translated">기본 &quot;cmd.exe&quot;이외의 명령 셸을 사용하거나 공백이 포함 된 경로에서 빌드하는 경우 일부 테스트 실패가 발생할 수 있습니다. 그러지 마</target>
        </trans-unit>
        <trans-unit id="ec70ba84fc671de1bea2095d64f0ecee13115e62" translate="yes" xml:space="preserve">
          <source>Some tests are known to fail:</source>
          <target state="translated">일부 테스트는 실패한 것으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="75d98556687379d0793051b330180895e416a427" translate="yes" xml:space="preserve">
          <source>Some tests may complain under known circumstances.</source>
          <target state="translated">일부 테스트는 알려진 상황에서 불만을 제기 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1340d9e04d7bf928c677a3bd6e8e8121f7021a3" translate="yes" xml:space="preserve">
          <source>Some tests may generate extra messages similar to</source>
          <target state="translated">일부 테스트는 다음과 유사한 추가 메시지를 생성 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="81c36c454152688ffa8f0d5944c5eae241cf584a" translate="yes" xml:space="preserve">
          <source>Some tests will be skipped because they need the fork() function:</source>
          <target state="translated">fork () 함수가 필요하기 때문에 일부 테스트는 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="ae4dfb05b376af0b4aa8499ceeb5ad1587cfc612" translate="yes" xml:space="preserve">
          <source>Some things might not work as you expect them. Below is documented what is known to be troublesome:</source>
          <target state="translated">예상대로 작동하지 않을 수 있습니다. 아래는 성가신 것으로 알려진 문서입니다.</target>
        </trans-unit>
        <trans-unit id="c22086010db6828bca64b97b121f052c5aaeaeec" translate="yes" xml:space="preserve">
          <source>Some time ago I had reports it does not work. Nowadays it is checked in the Perl test suite, so grep</source>
          <target state="translated">얼마 전에 나는 작동하지 않는다고보고했다. 요즘에는 Perl 테스트 스위트에서 확인되므로 grep</target>
        </trans-unit>
        <trans-unit id="729fe9bb5c1721be7b9c47b47d38d0043a1d5be9" translate="yes" xml:space="preserve">
          <source>Some types of lvalues can be localized as well: hash and array elements and slices, conditionals (provided that their result is always localizable), and symbolic references. As for simple variables, this creates new, dynamically scoped values.</source>
          <target state="translated">해시 및 배열 요소와 슬라이스, 조건부 (결과가 항상 지역화 가능한 경우) 및 기호 참조와 같은 일부 유형의 lvalue도 현지화 할 수 있습니다. 간단한 변수에 관해서는 동적으로 범위가 지정된 새로운 값을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="36c279e82d37aef763f2dc425df33d302f2edc2c" translate="yes" xml:space="preserve">
          <source>Some unusual systems, such as VMS, require special filename handling in order to deal with symbolic names for files (i.e., VMS's Logical Names).</source>
          <target state="translated">VMS와 같은 일부 비정상적인 시스템은 파일의 기호 이름 (예 : VMS의 논리 이름)을 처리하기 위해 특별한 파일 이름 처리가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="6a39214b093577878080cd0246589b3e208ffeb5" translate="yes" xml:space="preserve">
          <source>Some user's however may feel that the above &quot;economy of expression&quot; is not particularly readable nor consistent and may instead choose to do something more like the following:</source>
          <target state="translated">그러나 일부 사용자는 위의 &quot;표현의 경제&quot;가 특별히 읽거나 일관성이 없으며 대신 다음과 같은 작업을 수행하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ad295080cd8e985d193a33706aa64c82df7132f" translate="yes" xml:space="preserve">
          <source>Some users have expressed that they think this whole mechanism of having a &quot;fail&quot; attribute at all, seems a rather pointless complication. But I want Locale::Maketext to be usable for software projects of</source>
          <target state="translated">일부 사용자는 &quot;실패&quot;속성을 갖는이 전체 메커니즘이 전혀 무의미한 합병증으로 생각된다고 표현했습니다. 그러나 Locale :: Maketext를 다음과 같은 소프트웨어 프로젝트에 사용할 수 있기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="7ab6d61e44a0f4b38225b697b64d41eb4c216b63" translate="yes" xml:space="preserve">
          <source>Some users may wish to encourage the use of lexically scoped variables. As an aid to catching implicit uses to package variables, which are always global, if you say</source>
          <target state="translated">일부 사용자는 어휘 범위 변수 사용을 권장 할 수 있습니다. 말할 때 항상 전역적인 변수를 패키징하는 암시 적 용도를 잡는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="020ce1178f605ac1782ec8459fa4fa7fd0cf745e" translate="yes" xml:space="preserve">
          <source>Some versions of &lt;code&gt;DB_File&lt;/code&gt; won't let you store data under a key of length 0. That means that if you have a function &lt;code&gt;f&lt;/code&gt; which you memoized and the cache is in a &lt;code&gt;DB_File&lt;/code&gt; database, then the value of &lt;code&gt;f()&lt;/code&gt; (&lt;code&gt;f&lt;/code&gt; called with no arguments) will not be memoized. If this is a big problem, you can supply a normalizer function that prepends &lt;code&gt;&quot;x&quot;&lt;/code&gt; to every key.</source>
          <target state="translated">일부 버전의 &lt;code&gt;DB_File&lt;/code&gt; 을 사용 하면 길이가 0 인 키에 데이터를 저장할 수 없습니다. 즉 , &lt;code&gt;DB_File&lt;/code&gt; 한 함수 &lt;code&gt;f&lt;/code&gt; 가 있고 캐시가 DB_File 데이터베이스에 있으면 &lt;code&gt;f()&lt;/code&gt; 의 값 ( &lt;code&gt;f&lt;/code&gt; 는 인수 없음)이 메모되지 않습니다. 이것이 큰 문제인 경우 모든 키 앞에 &lt;code&gt;&quot;x&quot;&lt;/code&gt; 를 추가하는 노멀 라이저 기능을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8bb4498f94e563a623dff663cd55b4fc862752c4" translate="yes" xml:space="preserve">
          <source>Some versions of &lt;code&gt;make&lt;/code&gt; set the variable &lt;code&gt;MAKE&lt;/code&gt; . Others do not. This variable contains the string to be included in</source>
          <target state="translated">일부 버전의 &lt;code&gt;make&lt;/code&gt; 는 변수 &lt;code&gt;MAKE&lt;/code&gt; 를 설정합니다 . 다른 사람들은 그렇지 않습니다. 이 변수는 포함 할 문자열을 포함합니다</target>
        </trans-unit>
        <trans-unit id="954f7aeec06323e12a6983f37a0846eca84625d3" translate="yes" xml:space="preserve">
          <source>Some versions of flock() can't lock files over a network (e.g. on NFS file systems), so you'd need to force the use of fcntl(2) when you build Perl. But even this is dubious at best. See the flock entry of &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; and the</source>
          <target state="translated">일부 버전의 flock ()은 네트워크 (예 : NFS 파일 시스템)를 통해 파일을 잠글 수 없으므로 Perl을 빌드 할 때 fcntl (2)을 강제로 사용해야합니다. 그러나 이것조차도 모호합니다. &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; 의 무리 입력 및</target>
        </trans-unit>
        <trans-unit id="d311518a6bb3b8613076ce871f73cf8cb1a1e05f" translate="yes" xml:space="preserve">
          <source>Some, but not all, UTF-8 malformations are detected, and in fact, some malformed input could cause reading beyond the end of the input buffer, which is one reason why this function is deprecated. The other is that only in extremely limited circumstances should the Unicode versus native code point be of any interest to you. See &lt;a href=&quot;#utf8_to_uvuni_buf&quot;&gt;utf8_to_uvuni_buf&lt;/a&gt; for alternatives.</source>
          <target state="translated">전부는 아니지만 일부 UTF-8 기형이 감지되고 실제로 일부 기형의 입력이 입력 버퍼의 끝을 넘어 판독을 유발할 수 있으므로이 기능이 더 이상 사용되지 않습니다. 다른 하나는 극도로 제한된 상황에서만 유니 코드와 네이티브 코드 포인트가 관심을 가져야한다는 것입니다. 대안 은 &lt;a href=&quot;#utf8_to_uvuni_buf&quot;&gt;utf8_to_uvuni_buf&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2fc9641c97ef26419e8b09582d42e0230f643449" translate="yes" xml:space="preserve">
          <source>Some, but not all, UTF-8 malformations are detected, and in fact, some malformed input could cause reading beyond the end of the input buffer, which is why this function is deprecated. Use &lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;utf8_to_uvchr_buf&lt;/a&gt; instead.</source>
          <target state="translated">전부는 아니지만 일부 UTF-8 기형이 감지되며 실제로 기형이 잘못된 일부 입력은 입력 버퍼의 끝을 넘어 판독을 유발할 수 있으므로이 기능은 더 이상 사용되지 않습니다. 대신 &lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;utf8_to_uvchr_buf&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d5b99daee126bc167396885e5a173ca7e1b5727f" translate="yes" xml:space="preserve">
          <source>Some, such as &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; aren't provided because the concept does not exist within Plan 9. Others, such as some of the socket-related functions, simply haven't been written yet. Many in the latter category may be supported in the future.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 와 같은 일부 는 개념이 Plan 9에 없기 때문에 제공되지 않습니다. 소켓 관련 기능과 같은 다른 일부는 아직 작성되지 않았습니다. 후자 범주의 많은 사람들이 앞으로 지원 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b529d1f2a1daeac288a5dc3e3f1ad071820c7a2" translate="yes" xml:space="preserve">
          <source>Some/Module.pm</source>
          <target state="translated">Some/Module.pm</target>
        </trans-unit>
        <trans-unit id="75f6f0269318d3e6d862e35e227cdb78f8aa0076" translate="yes" xml:space="preserve">
          <source>Someone like Larry, or one of his peculiar friends. Also refers to the strange prefixes that Perl requires as noun markers on its variables.</source>
          <target state="translated">래리와 같은 누군가 또는 그의 독특한 친구 중 한 사람. 또한 Perl이 변수에서 명사 마커로 요구하는 이상한 접두사를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4645c18015bf5520c386fecd9f2627c0f851f491" translate="yes" xml:space="preserve">
          <source>Someone who &amp;ldquo;carries&amp;rdquo; software from one &lt;b&gt;platform&lt;/b&gt; to another. Porting programs written in platform-dependent languages such as C can be difficult work, but porting programs like Perl is very much worth the agony.</source>
          <target state="translated">한 &lt;b&gt;플랫폼&lt;/b&gt; 에서 다른 &lt;b&gt;플랫폼&lt;/b&gt; 으로 소프트웨어를 &quot;운반&quot; 하는 사람. C와 같은 플랫폼 종속 언어로 작성된 포팅 프로그램은 어려울 수 있지만 Perl과 같은 포팅 프로그램은 매우 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="81901ca358030c454d79961747b435397961631e" translate="yes" xml:space="preserve">
          <source>Someone who breaks security on computer systems. A cracker may be a true &lt;b&gt;hacker&lt;/b&gt; or only a &lt;b&gt;script kiddie&lt;/b&gt;.</source>
          <target state="translated">컴퓨터 시스템의 보안을 깨는 사람. 크래커는 사실 일 수 있습니다 &lt;b&gt;해커&lt;/b&gt; 또는 단지 &lt;b&gt;스크립트 키디&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="1964ccb6039dfc22b78b8e0d35db2a914eb047cc" translate="yes" xml:space="preserve">
          <source>Someone who is brilliantly persistent in solving technical problems, whether these involve golfing, fighting orcs, or programming. Hacker is a neutral term, morally speaking. Good hackers are not to be confused with evil &lt;b&gt;crackers&lt;/b&gt; or clueless &lt;b&gt;script kiddies&lt;/b&gt;. If you confuse them, we will presume that you are either evil or clueless.</source>
          <target state="translated">골프, 오크 싸움, 프로그래밍 등 기술적 인 문제를 해결하는 데 현명한 사람. 해커는 도덕적으로 말하는 중립적 인 용어입니다. 훌륭한 해커는 사악한 &lt;b&gt;크래커&lt;/b&gt; 나 단서가없는 &lt;b&gt;스크립트 키드&lt;/b&gt; 와 혼동되어서는 안됩니다 . 당신이 그들을 혼동한다면, 우리는 당신이 사악하거나 우둔한 것으로 추정 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="a06bdcd2151c9efce6b287181e34780a4956856f" translate="yes" xml:space="preserve">
          <source>Something &amp;ldquo;iffy&amp;rdquo;. See &lt;b&gt;Boolean context&lt;/b&gt;.</source>
          <target state="translated">뭔가 &quot;iffy&quot;입니다. &lt;b&gt;부울 컨텍스트를&lt;/b&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e155f24963deb993057b4c0bc7a9a37afd51cb22" translate="yes" xml:space="preserve">
          <source>Something extra that happens when you evaluate an &lt;b&gt;expression&lt;/b&gt;. Nowadays it can refer to almost anything. For example, evaluating a simple assignment statement typically has the &amp;ldquo;side effect&amp;rdquo; of assigning a value to a variable. (And you thought assigning the value was your primary intent in the first place!) Likewise, assigning a value to the special variable &lt;code&gt;$|&lt;/code&gt; (&lt;code&gt;$AUTOFLUSH&lt;/code&gt; ) has the side effect of forcing a flush after every &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; on the currently selected filehandle.</source>
          <target state="translated">&lt;b&gt;식&lt;/b&gt; 을 평가할 때 발생하는 추가 사항 . 요즘에는 거의 모든 것을 가리킬 수 있습니다. 예를 들어, 간단한 대 입문을 평가하면 일반적으로 변수에 값을 대입하는 &quot;부작용&quot;이 있습니다. (그리고 당신은 값을 할당하는 것이 처음에 주요 의도라고 생각했습니다!) 마찬가지로, 특수 변수 &lt;code&gt;$|&lt;/code&gt; ( &lt;code&gt;$AUTOFLUSH&lt;/code&gt; )는 현재 선택된 파일 핸들에서 모든 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 후 플러시를 강제하는 부작용 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="783e080adee89f0dfad650da0b7f44d322697c43" translate="yes" xml:space="preserve">
          <source>Something is rotten in the state of the program. An attributed subroutine ceased to exist between the point it was declared and the point at which its attribute handler(s) would have been called.</source>
          <target state="translated">프로그램 상태에 문제가 있습니다. 중요한 서브 루틴은 선언 된 시점과 해당 속성 핸들러가 호출 된 시점 사이에 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9119b80c4db3125e0e5d3f36b18c5029258c49c9" translate="yes" xml:space="preserve">
          <source>Something is still amiss: consider the loop variable $cnt of the script. It was a number, not an object. We cannot make this value of type &lt;code&gt;symbolic&lt;/code&gt; , since then the loop will not terminate.</source>
          <target state="translated">여전히 문제가 있습니다. 스크립트의 루프 변수 $ cnt를 고려하십시오. 그것은 객체가 아니라 숫자였습니다. 루프가 종료되지 않기 때문에이 유형의 &lt;code&gt;symbolic&lt;/code&gt; 값을 만들 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b420f56b3a25fc6071dc9a2a0d9e492a4d5a4fac" translate="yes" xml:space="preserve">
          <source>Something like &lt;code&gt;&quot;-DHAVE_UNISTD_H&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;-DHAVE_UNISTD_H&quot;&lt;/code&gt; 와 같은 것</target>
        </trans-unit>
        <trans-unit id="2229723dcea531af53507e7f80155b0032f61e90" translate="yes" xml:space="preserve">
          <source>Something not owned by anybody. Perl is copyrighted and is thus</source>
          <target state="translated">아무도 소유하지 않은 것. Perl은 저작권이 있으며 따라서</target>
        </trans-unit>
        <trans-unit id="63320e06b401dd030b4898741e99304253f96385" translate="yes" xml:space="preserve">
          <source>Something of a hack but it prevents a lot of code duplication between MM_* variants.</source>
          <target state="translated">해킹이 있지만 MM_ * 변형 사이의 많은 코드 복제를 방지합니다.</target>
        </trans-unit>
        <trans-unit id="bbccb8a40149fe00b8fef910fa55b43eced89db6" translate="yes" xml:space="preserve">
          <source>Something similar to the offset hack is performed on AVs to enable efficient shifting and splicing off the beginning of the array; while &lt;code&gt;AvARRAY&lt;/code&gt; points to the first element in the array that is visible from Perl, &lt;code&gt;AvALLOC&lt;/code&gt; points to the real start of the C array. These are usually the same, but a &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; operation can be carried out by increasing &lt;code&gt;AvARRAY&lt;/code&gt; by one and decreasing &lt;code&gt;AvFILL&lt;/code&gt; and &lt;code&gt;AvMAX&lt;/code&gt; . Again, the location of the real start of the C array only comes into play when freeing the array. See &lt;code&gt;av_shift&lt;/code&gt; in</source>
          <target state="translated">오프셋 시작 해킹과 유사한 것이 AV에서 수행되어 어레이의 시작 부분에서 효율적으로 이동 및 스 플라이 싱 할 수 있습니다. 반면 &lt;code&gt;AvARRAY&lt;/code&gt; 는 펄에서 볼 어레이의 첫 번째 요소를 가리키는 &lt;code&gt;AvALLOC&lt;/code&gt; 의 C 어레이의 실제 시작 포인트. 이들은 일반적으로 동일하지만 &lt;code&gt;AvARRAY&lt;/code&gt; 를 1 씩 늘리고 &lt;code&gt;AvFILL&lt;/code&gt; 및 &lt;code&gt;AvMAX&lt;/code&gt; 를 줄이면 &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 작업을 수행 할 수 있습니다 . 다시, C 어레이의 실제 시작 위치는 어레이를 해제 할 때만 작동합니다. 에 &lt;code&gt;av_shift&lt;/code&gt; 를 참조하십시오</target>
        </trans-unit>
        <trans-unit id="4332fef1f22d39fca98466a0536a5b2d1aaa44ee" translate="yes" xml:space="preserve">
          <source>Something that tells your program what sort of variable you&amp;rsquo;d like. Perl doesn&amp;rsquo;t require you to declare variables, but you can use &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; to denote that you want something other than the default.</source>
          <target state="translated">어떤 종류의 변수를 원하는지 프로그램에 알려주는 것. Perl은 변수 선언을 요구하지 않지만, &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 를 사용하여 기본값 이외의 것을 원한다는 것을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ad3b77572daa04075d4890e62387b4b824f1955" translate="yes" xml:space="preserve">
          <source>Something to exclude, prefixed by &lt;code&gt;&quot;-&quot;&lt;/code&gt; : an existing character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ) or a fully qualified (including package name) user-defined character property, to represent all the characters in that property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="translated">접두사 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 로 시작하는 것 : 기존 문자 속성 (접두사 &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; 접두어 ) 또는 정규화 된 (패키지 이름 포함) 사용자 정의 문자 속성으로 해당 속성의 모든 문자를 나타냅니다. 범위에 대한 두 개의 16 진 코드 포인트; 또는 단일 16 진 코드 포인트.</target>
        </trans-unit>
        <trans-unit id="2f7458ff984e1016174a3ccc404733830b1557d4" translate="yes" xml:space="preserve">
          <source>Something to include, prefixed by &lt;code&gt;&quot;+&quot;&lt;/code&gt; : a built-in character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ) or a fully qualified (including package name) user-defined character property, to represent all the characters in that property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="translated">접두사 &lt;code&gt;&quot;+&quot;&lt;/code&gt; 가 포함 된 것 : 내장 문자 속성 (접두사 &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; 접두어 ) 또는 정규화 된 (패키지 이름 포함) 사용자 정의 문자 속성으로 해당 속성의 모든 문자를 나타냅니다. 범위에 대한 두 개의 16 진 코드 포인트; 또는 단일 16 진 코드 포인트.</target>
        </trans-unit>
        <trans-unit id="691cfd6a9c9ef44b73a6c3b1fc2fc7e231422dbe" translate="yes" xml:space="preserve">
          <source>Something to intersect with, prefixed by &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; : an existing character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ) or a fully qualified (including package name) user-defined character property, for all the characters except the characters in the property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="translated">접두사 &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; 가 앞에 붙는 것 : 기존 문자 속성 (접두사 &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; 접두어 ) 또는 정규화 된 (패키지 이름 포함) 사용자 정의 문자 속성 (속성의 문자를 제외한 모든 문자) 범위에 대한 두 개의 16 진 코드 포인트; 또는 단일 16 진 코드 포인트.</target>
        </trans-unit>
        <trans-unit id="6131959027de2eb65107afa87755cfdbae0af220" translate="yes" xml:space="preserve">
          <source>Something to negate, prefixed &lt;code&gt;&quot;!&quot;&lt;/code&gt; : an existing character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ) or a fully qualified (including package name) user-defined character property, to represent all the characters in that property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="translated">부정 할 것, 접두사 &lt;code&gt;&quot;!&quot;&lt;/code&gt; : 기존 문자 특성 ( &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; 접두어 ) 또는 완전한 (패키지 이름 포함) 사용자 정의 문자 특성으로 해당 특성의 모든 문자를 나타냅니다. 범위에 대한 두 개의 16 진 코드 포인트; 또는 단일 16 진 코드 포인트.</target>
        </trans-unit>
        <trans-unit id="b29b35d3b7e27c5736fa04a9d5a9779f7c0d02b4" translate="yes" xml:space="preserve">
          <source>Something we&amp;rsquo;d call a &lt;b&gt;metacharacter&lt;/b&gt; except that it&amp;rsquo;s a sequence of more than one character. Generally, the first character in the sequence must be a true metacharacter to get the other characters in the metasymbol to misbehave along with it.</source>
          <target state="translated">하나 이상의 문자 시퀀스라는 것을 제외하고 &lt;b&gt;메타 문자&lt;/b&gt; 라고 부릅니다 . 일반적으로 시퀀스의 첫 번째 문자는 메타 심볼의 다른 문자가 잘못 작동하도록하려면 실제 메타 문자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="0939ed03ca5713b7d596d517d3a21d567b42a063" translate="yes" xml:space="preserve">
          <source>Something went horribly wrong-- the number of microseconds that cannot become negative just became negative. Maybe your compiler is broken?</source>
          <target state="translated">음이 될 수없는 마이크로 초의 수는 음이되었습니다. 어쩌면 컴파일러가 고장 났습니까?</target>
        </trans-unit>
        <trans-unit id="c59ba282daa2ae9441382d6bdd1d5cbb102eba6e" translate="yes" xml:space="preserve">
          <source>Something you can see from anywhere, usually used of &lt;b&gt;variables&lt;/b&gt; and &lt;b&gt;subroutines&lt;/b&gt; that are visible everywhere in your program. In Perl, only certain special variables are truly global&amp;mdash;most variables (and all subroutines) exist only in the current &lt;b&gt;package&lt;/b&gt;. Global variables can be declared with &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;. See &amp;ldquo;Global Declarations&amp;rdquo; in Camel chapter 4, &amp;ldquo;Statements and Declarations&amp;rdquo;.</source>
          <target state="translated">프로그램의 어느 곳에서나 볼 수있는 &lt;b&gt;변수&lt;/b&gt; 와 &lt;b&gt;서브 루틴에&lt;/b&gt; 사용되는 어디에서나 볼 수있는 것. Perl에서는 특정 특수 변수 만 전역 적으로 사용됩니다. 대부분의 변수 (및 모든 서브 루틴)는 현재 &lt;b&gt;패키지&lt;/b&gt; 에만 존재 &lt;b&gt;합니다&lt;/b&gt; . 전역 변수로 선언 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; . Camel Chapter 4, &quot;Statement and Declarations&quot;의 &quot;Global Declarations&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="07e88fa4cc64647b2e3278d50a97cb8b0618c720" translate="yes" xml:space="preserve">
          <source>Something you do for someone else to make them happy, like giving them the time of day (or of their life). On some machines, well-known services are listed by the &lt;code&gt;&lt;a href=&quot;functions/getservent&quot;&gt;getservent&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">하루 중 시간 (또는 삶의 시간)을주는 것과 같이 다른 사람이 그들을 행복하게하기 위해하는 일. 일부 시스템에서는 잘 알려진 서비스가 &lt;code&gt;&lt;a href=&quot;functions/getservent&quot;&gt;getservent&lt;/a&gt;&lt;/code&gt; 함수 로 나열됩니다 .</target>
        </trans-unit>
        <trans-unit id="457be77433ae10862116d65ca361c913afdc2edf" translate="yes" xml:space="preserve">
          <source>Sometimes (see &lt;a href=&quot;#When-Unicode-Does-Not-Happen&quot;&gt;When Unicode Does Not Happen&lt;/a&gt; or &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;The Unicode Bug&lt;/a&gt;) there are situations where you simply need to force a byte string into UTF-8, or vice versa. The standard module &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; can be used for this, or the low-level calls &lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8::upgrade($bytestring) &lt;/a&gt; and &lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8::downgrade($utf8string[, FAIL_OK]) &lt;/a&gt;.</source>
          <target state="translated">때때로 ( &lt;a href=&quot;#When-Unicode-Does-Not-Happen&quot;&gt;유니 코드가 발생하지 않는 경우&lt;/a&gt; 또는 &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;유니 코드 버그 참조&lt;/a&gt; ) 바이트 문자열을 UTF-8로 강제 변환해야하는 상황이나 그 반대의 경우도 있습니다. 이를 위해 표준 모듈 &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; 또는 저수준 호출 &lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8 :: upgrade ($ bytestring)&lt;/a&gt; 및 &lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8 :: downgrade ($ utf8string [, FAIL_OK])를 사용할 수&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c72f071a765fd3018bc7af5d49df36cbd9aae7b" translate="yes" xml:space="preserve">
          <source>Sometimes greed is not good. At times, we would like quantifiers to match a</source>
          <target state="translated">때로는 탐욕이 좋지 않습니다. 때때로, 우리는 정량자가</target>
        </trans-unit>
        <trans-unit id="0aa27e840004256e29009bb974e009bb34e90abf" translate="yes" xml:space="preserve">
          <source>Sometimes instead of zeroing the allocated heap by using Newxz() you should consider &quot;poisoning&quot; the data. This means writing a bit pattern into it that should be illegal as pointers (and floating point numbers), and also hopefully surprising enough as integers, so that any code attempting to use the data without forethought will break sooner rather than later. Poisoning can be done using the Poison() macros, which have similar arguments to Zero():</source>
          <target state="translated">때때로 Newxz ()를 사용하여 할당 된 힙을 제로화하는 대신 데이터 &quot;중독&quot;을 고려해야합니다. 이것은 포인터 (및 부동 소수점 숫자)로 불법이어야하고 정수로도 놀랍도록 비트 패턴을 작성하는 것을 의미하므로 예측하지 않고 데이터를 사용하려고 시도하는 코드는 나중에보다 빨리 중단됩니다. 중독은 Zero ()와 유사한 인수를 갖는 Poison () 매크로를 사용하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cae5675054ecaa30b3d68d273e86faefe7bf19e0" translate="yes" xml:space="preserve">
          <source>Sometimes it is advantageous to construct a pattern from the</source>
          <target state="translated">때로는 패턴을 구성하는 것이 유리합니다</target>
        </trans-unit>
        <trans-unit id="fa5de12a356ae81ac7e15fb6c4fdf4f42322289c" translate="yes" xml:space="preserve">
          <source>Sometimes it may be necessary to make more than one pass over the input files. If this is the case you have several options. You can make the first pass using &lt;b&gt;Pod::Parser&lt;/b&gt; and override your methods to store the intermediate results in memory somewhere for the &lt;b&gt;end_pod()&lt;/b&gt; method to process. You could use &lt;b&gt;Pod::Parser&lt;/b&gt; for several passes with an appropriate state variable to control the operation for each pass. If your input source can't be reset to start at the beginning, you can store it in some other structure as a string or an array and have that structure implement a &lt;b&gt;getline()&lt;/b&gt; method (which is all that &lt;b&gt;parse_from_filehandle()&lt;/b&gt; uses to read input).</source>
          <target state="translated">때로는 입력 파일을 두 번 이상 통과해야 할 수도 있습니다. 이 경우 몇 가지 옵션이 있습니다. &lt;b&gt;Pod :: Parser를&lt;/b&gt; 사용하여 첫 번째 단계 를 수행하고 &lt;b&gt;end_pod ()&lt;/b&gt; 메서드가 처리 할 중간 위치에 메모리에 중간 결과를 저장하도록 메서드를 재정의 할 수 있습니다. 적절한 상태 변수를 가진 여러 패스에 &lt;b&gt;Pod :: Parser&lt;/b&gt; 를 사용 하여 각 패스에 대한 작업을 제어 할 수 있습니다. 입력 소스를 처음에 시작하도록 재설정 할 수없는 경우이를 다른 구조에 문자열 또는 배열로 저장하고 해당 구조가 &lt;b&gt;getline ()&lt;/b&gt; 메소드 ( &lt;b&gt;parse_from_filehandle ()&lt;/b&gt; 가 읽기 위해 사용하는 전부 &lt;b&gt;)를&lt;/b&gt; 구현하도록 할 수 있습니다 입력).</target>
        </trans-unit>
        <trans-unit id="f6006f7823a5727b8006f191fa888a2e039ea099" translate="yes" xml:space="preserve">
          <source>Sometimes minimal matching can help a lot. Imagine you'd like to match everything between &quot;foo&quot; and &quot;bar&quot;. Initially, you write something like this:</source>
          <target state="translated">때로는 최소한의 일치가 많은 도움이 될 수 있습니다. &quot;foo&quot;와 &quot;bar&quot;사이의 모든 항목을 일치 시키려고한다고 가정하십시오. 처음에는 다음과 같이 작성합니다.</target>
        </trans-unit>
        <trans-unit id="7e0fb1495abd7611e5570cce2cb4d1976ffa0113" translate="yes" xml:space="preserve">
          <source>Sometimes older versions of the module you're installing live in other directories in @INC. Because Perl loads the first version of a module it finds, not the newest, you might accidentally get one of these older versions even after installing a brand new version. To delete</source>
          <target state="translated">때로는 설치하려는 이전 버전의 모듈이 @INC의 다른 디렉토리에 실시간으로 있습니다. Perl은 최신 버전이 아니라 발견 한 첫 번째 버전의 모듈을로드하기 때문에 새 버전을 설치 한 후에도 실수로 이전 버전 중 하나를 얻을 수 있습니다. 지우는 것</target>
        </trans-unit>
        <trans-unit id="eb753520a2d796d4f761ee04ddf336bdbe0915a3" translate="yes" xml:space="preserve">
          <source>Sometimes ops are executed within an inner runops loop, such as tie, sort or overload code. In this case, something like</source>
          <target state="translated">때로는 동점, 정렬 또는 과부하 코드와 같은 내부 runops 루프 내에서 op가 실행됩니다. 이 경우에는</target>
        </trans-unit>
        <trans-unit id="147ec757892c0aed445b0fb45a48e27c978e8a0c" translate="yes" xml:space="preserve">
          <source>Sometimes running a test under certain conditions will cause the test script to die. A certain function or method isn't implemented (such as &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; on MacOS), some resource isn't available (like a net connection) or a module isn't available. In these cases it's necessary to skip tests, or declare that they are supposed to fail but will work in the future (a todo test).</source>
          <target state="translated">때때로 특정 조건에서 테스트를 실행하면 테스트 스크립트가 종료 될 수 있습니다. 특정 함수 또는 메소드가 구현되지 않았거나 (예 : MacOS의 &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; ) 일부 리소스를 사용할 수 없거나 (네트 연결과 같은) 모듈을 사용할 수 없습니다. 이러한 경우 테스트를 건너 뛰거나 실패한다고 가정하지만 향후에는 할 일 (todo 테스트)을 수행 할 것이라고 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="14a525fd22c2b653fcabe0c32c53b3975d5455dc" translate="yes" xml:space="preserve">
          <source>Sometimes the Test::Builder test counter is incremented without it printing any test output, for example, when &lt;code&gt;current_test()&lt;/code&gt; is changed. In these cases, Test::Builder doesn't know the result of the test, so its type is 'unknown'. These details for these tests are filled in. They are considered ok, but the name and actual_ok is left &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우에 따라 test :: Builder 테스트 카운터는 테스트 출력을 인쇄하지 않고 증분됩니다 &lt;code&gt;current_test()&lt;/code&gt; 예 : current_test () 가 변경된 경우). 이 경우 Test :: Builder는 테스트 결과를 알지 못하므로 유형을 '알 수 없음'입니다. 이러한 테스트에 대한 자세한 내용은 채워져 있습니다. 괜찮은 것으로 간주되지만 이름과 actual_ok는 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 로 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c117b85f5735958c8ac918f5819ede8cc1b0ef4" translate="yes" xml:space="preserve">
          <source>Sometimes the Test::More interface isn't quite enough. Fortunately, Test::More is built on top of &lt;a href=&quot;builder&quot;&gt;Test::Builder&lt;/a&gt; which provides a single, unified backend for any test library to use. This means two test libraries which both use &amp;lt;Test::Builder&amp;gt; &lt;b&gt;can&lt;/b&gt; be used together in the same program&amp;gt;.</source>
          <target state="translated">때때로 Test :: More 인터페이스로는 충분하지 않습니다. 다행스럽게도 Test :: More는 &lt;a href=&quot;builder&quot;&gt;Test :: Builder&lt;/a&gt; 위에 구축되어 테스트 라이브러리에서 사용할 수있는 단일 통합 백엔드를 제공합니다. 이것은 &amp;lt;Test :: Builder&amp;gt;를 모두 사용하는 두 개의 테스트 라이브러리가 같은 프로그램에서 함께 사용될 &lt;b&gt;수&lt;/b&gt; 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ff0436b0b7df1e2c343b73c639e499fd807b68f3" translate="yes" xml:space="preserve">
          <source>Sometimes there is some confusion about where &lt;code&gt;todo()&lt;/code&gt; should be looking for the &lt;code&gt;$TODO&lt;/code&gt; variable. If you want to be sure, tell it explicitly what $pack to use.</source>
          <target state="translated">때때로 &lt;code&gt;todo()&lt;/code&gt; 가 &lt;code&gt;$TODO&lt;/code&gt; 변수를 찾아야 할 곳에 혼란 이 있습니다 . 확실하게 사용하려면 $ pack을 사용할 것을 명시 적으로 알려주십시오.</target>
        </trans-unit>
        <trans-unit id="399765aa05845ba02b6fea1a15de4bf746fb4a9e" translate="yes" xml:space="preserve">
          <source>Sometimes we would like our regexp to be able to match different possible words or character strings. This is accomplished by using the</source>
          <target state="translated">때로는 정규 표현식이 가능한 다른 단어 나 문자열과 일치시킬 수 있기를 원합니다. 이것은</target>
        </trans-unit>
        <trans-unit id="c45fdfd630d6939174042d52a2669877eec8162b" translate="yes" xml:space="preserve">
          <source>Sometimes you don't want to pass the value of an array to a subroutine but rather the name of it, so that the subroutine can modify the global copy of it rather than working with a local copy. In perl you can refer to all objects of a particular name by prefixing the name with a star: &lt;code&gt;*foo&lt;/code&gt; . This is often known as a &quot;typeglob&quot;, because the star on the front can be thought of as a wildcard match for all the funny prefix characters on variables and subroutines and such.</source>
          <target state="translated">때때로 서브 루틴이 아닌 서브 루틴에 배열의 값을 전달하기를 원하지 않기 때문에 서브 루틴이 로컬 사본으로 작업하는 대신 서브 루틴의 글로벌 사본을 수정할 수 있습니다. 펄에서 이름 앞에 별표 &lt;code&gt;*foo&lt;/code&gt; 를 붙여 특정 이름의 모든 객체를 참조 할 수 있습니다 . 전면의 별은 변수 및 서브 루틴 등의 모든 재미있는 접두사 문자에 대한 와일드 카드 일치로 생각할 수 있기 때문에 종종 &quot;typeglob&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="3dc7c2918cdb381ad384c3d9167215ff71a8a0da" translate="yes" xml:space="preserve">
          <source>Sometimes you have to store undefined values in AVs or HVs. Although this may be a rare case, it can be tricky. That's because you're used to using &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; if you need an undefined SV.</source>
          <target state="translated">때로는 AV 또는 HV에 정의되지 않은 값을 저장해야합니다. 이 경우는 드물지만 까다로울 수 있습니다. 정의되지 않은 SV가 필요한 경우 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; 를 사용하는 데 익숙하기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="ce5b78669327a1c5203b6d6638f97e91e235e173" translate="yes" xml:space="preserve">
          <source>Sometimes you just want to say that the tests have passed. Usually the case is you've got some complicated condition that is difficult to wedge into an &lt;code&gt;ok()&lt;/code&gt; . In this case, you can simply use &lt;code&gt;pass()&lt;/code&gt; (to declare the test ok) or fail (for not ok). They are synonyms for &lt;code&gt;ok(1)&lt;/code&gt; and &lt;code&gt;ok(0)&lt;/code&gt; .</source>
          <target state="translated">때로는 테스트가 통과되었다고 말하고 싶을 때가 있습니다. 일반적으로 &lt;code&gt;ok()&lt;/code&gt; 로 쐐기가 어려운 복잡한 조건이 있습니다. 이 경우 &lt;code&gt;pass()&lt;/code&gt; 를 사용 하여 (테스트 ok를 선언하거나) 실패 (ok가 아닌)를 사용할 수 있습니다. 그것들은 &lt;code&gt;ok(1)&lt;/code&gt; 과 &lt;code&gt;ok(0)&lt;/code&gt; 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="99ad657b111885cfb86229225ce3dd7e07ab7571" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to truncate an already-existing file. This can be done using the &lt;code&gt;O_TRUNC&lt;/code&gt; flag. The behavior of &lt;code&gt;O_TRUNC&lt;/code&gt; with &lt;code&gt;O_RDONLY&lt;/code&gt; is undefined.</source>
          <target state="translated">때로는 기존 파일을자를 수도 있습니다. 이것은 &lt;code&gt;O_TRUNC&lt;/code&gt; 플래그를 사용하여 수행 할 수 있습니다 . &lt;code&gt;O_RDONLY&lt;/code&gt; 를 사용한 &lt;code&gt;O_TRUNC&lt;/code&gt; 의 동작 은 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d108e62bce7d546642fdcfcda3e786d8361305f7" translate="yes" xml:space="preserve">
          <source>Sometimes you may wish to leave the processes run by CPAN alone without caring about them. Because the Makefile.PL or the Build.PL sometimes contains question you're expected to answer, you can set a timer that will kill a 'perl Makefile.PL' process after the specified time in seconds.</source>
          <target state="translated">때로는 CPAN이 단독으로 실행하는 프로세스를 신경 쓰지 않고 그대로두기를 원할 수도 있습니다. Makefile.PL 또는 Build.PL에 때때로 응답해야하는 질문이 포함되어 있으므로 지정된 시간 (초) 후에 'perl Makefile.PL'프로세스를 종료하는 타이머를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c00f6f509d151b6fb1ea7605fa661bc15fbf5303" translate="yes" xml:space="preserve">
          <source>Sometimes you might really need to know the byte length of a string instead of the character length. For that use either the &lt;code&gt;Encode::encode_utf8()&lt;/code&gt; function or the &lt;code&gt;bytes&lt;/code&gt; pragma and the &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; function:</source>
          <target state="translated">때로는 문자 길이 대신 문자열의 바이트 길이를 알아야 할 수도 있습니다. 이를 위해 &lt;code&gt;Encode::encode_utf8()&lt;/code&gt; 함수 또는 &lt;code&gt;bytes&lt;/code&gt; pragma 및 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="69ca48a72c9601cef59e5c67d6f3681c75e3b061" translate="yes" xml:space="preserve">
          <source>Sometimes you might want to build a statically linked perl although your system supports dynamic loading. In this case you may explicitly set the linktype with the invocation of the Makefile.PL or make:</source>
          <target state="translated">시스템이 동적로드를 지원하더라도 정적으로 링크 된 펄을 빌드하려고 할 수 있습니다. 이 경우 Makefile.PL을 호출하여 링크 유형을 명시 적으로 설정하거나 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d30402c312d3b94f0c6f02a6509532f4e38398dd" translate="yes" xml:space="preserve">
          <source>Sometimes you might want to display Perl scalars containing Unicode as simple ASCII (or EBCDIC) text. The following subroutine converts its argument so that Unicode characters with code points greater than 255 are displayed as &lt;code&gt;\x{...}&lt;/code&gt; , control characters (like &lt;code&gt;\n&lt;/code&gt; ) are displayed as &lt;code&gt;\x..&lt;/code&gt; , and the rest of the characters as themselves:</source>
          <target state="translated">때로는 유니 코드를 포함하는 Perl 스칼라를 간단한 ASCII (또는 EBCDIC) 텍스트로 표시하려고 할 수 있습니다. 다음 서브 루틴은 인수가 255보다 큰 코드 포인트를 갖는 유니 코드 문자가 &lt;code&gt;\x{...}&lt;/code&gt; 로 표시되고 제어 문자 (예 : &lt;code&gt;\n&lt;/code&gt; )가 &lt;code&gt;\x..&lt;/code&gt; 로 표시되고 나머지 문자가 자체로 표시되도록 인수를 변환합니다 . :</target>
        </trans-unit>
        <trans-unit id="93cab2a917ae8f995aa91a73cd34dbac7106cc0f" translate="yes" xml:space="preserve">
          <source>Sometimes you might want to provide some extra methods or subroutines to assist in making the interface between Perl and your extension simpler or easier to understand. These routines should live in the .pm file. Whether they are automatically loaded when the extension itself is loaded or only loaded when called depends on where in the .pm file the subroutine definition is placed. You can also consult &lt;a href=&quot;autoloader&quot;&gt;AutoLoader&lt;/a&gt; for an alternate way to store and load your extra subroutines.</source>
          <target state="translated">때로는 Perl과 확장 사이의 인터페이스를 더 단순하거나 이해하기 쉽게 만드는 데 도움이되는 몇 가지 추가 메소드 또는 서브 루틴을 제공 할 수 있습니다. 이 루틴은 .pm 파일에 있어야합니다. 확장자 자체가로드 될 때 자동으로로드되는지 또는 호출 될 때만로드되는지는 .pm 파일에서 서브 루틴 정의가있는 위치에 따라 다릅니다. 여분의 서브 루틴을 저장하고로드하는 다른 방법은 &lt;a href=&quot;autoloader&quot;&gt;AutoLoader&lt;/a&gt; 에 문의 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d50f25bb7791c3200f165a11a2621c66fc26aa1f" translate="yes" xml:space="preserve">
          <source>Sometimes you need to have two and more XS files in the same package. One way to go is to put them into separate directories, but sometimes this is not the most suitable solution. The following technique allows you to put two (and more) XS files in the same directory.</source>
          <target state="translated">때로는 동일한 패키지에 둘 이상의 XS 파일이 있어야합니다. 한 가지 방법은 별도의 디렉토리에 저장하는 것이지만 때로는 이것이 가장 적합한 솔루션이 아닙니다. 다음 기술을 사용하면 동일한 디렉토리에 두 개 이상의 XS 파일을 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d84ae75a88af76cd17f4e95ee970d0624fc53ec5" translate="yes" xml:space="preserve">
          <source>Sometimes you need to invoke the same subroutine repeatedly. This usually happens with a function that acts on a list of values, such as Perl's built-in sort(). You can pass a comparison function to sort(), which will then be invoked for every pair of values that needs to be compared. The first() and reduce() functions from &lt;a href=&quot;list/util&quot;&gt;List::Util&lt;/a&gt; follow a similar pattern.</source>
          <target state="translated">때로는 동일한 서브 루틴을 반복해서 호출해야합니다. 이것은 일반적으로 Perl의 내장 sort ()와 같은 값 목록에서 작동하는 함수에서 발생합니다. 비교 함수를 sort ()에 전달하면 비교해야하는 모든 값 쌍에 대해 호출됩니다. &lt;a href=&quot;list/util&quot;&gt;List :: Util&lt;/a&gt; 의 first () 및 reduce () 함수 는 비슷한 패턴을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="74631c8a306d075a7cfb9919a67e89afd99fe44c" translate="yes" xml:space="preserve">
          <source>Sometimes you really don't know how many tests were run, or it's too difficult to calculate. In which case you can leave off $number_of_tests_run.</source>
          <target state="translated">때로는 얼마나 많은 테스트가 실행되었는지 알지 못하거나 계산하기가 너무 어렵습니다. 이 경우 $ number_of_tests_run을 남겨 둘 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85a6426e0300f2135b305a518e04a9c8bcb36f5b" translate="yes" xml:space="preserve">
          <source>Sometimes you should change the positions of the constant and the variable. For example, let's say you wanted to test which of many answers you were given, but in a case-insensitive way that also allows abbreviations. You can use the following technique if the strings all start with different characters or if you want to arrange the matches so that one takes precedence over another, as &lt;code&gt;&quot;SEND&quot;&lt;/code&gt; has precedence over &lt;code&gt;&quot;STOP&quot;&lt;/code&gt; here:</source>
          <target state="translated">때로는 상수와 변수의 위치를 ​​변경해야합니다. 예를 들어, 어떤 답변을 받았지만 약어를 허용하는 대소 문자를 구분하지 않는 방식으로 테스트하려고한다고 가정 해 봅시다. 문자열이 모두 다른 문자로 시작하거나 일치 항목을 정렬하여 &lt;code&gt;&quot;SEND&quot;&lt;/code&gt; 가 &lt;code&gt;&quot;STOP&quot;&lt;/code&gt; 보다 우선하므로 일치하는 것을 정렬하려는 경우 다음 기술을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e295d93f5cf54bf6ebaedc8fedd1af1c66b62ba7" translate="yes" xml:space="preserve">
          <source>Sometimes you want to combine the best of hashes and arrays. For example, the command line:</source>
          <target state="translated">때로는 최고의 해시와 배열을 결합하려고합니다. 예를 들어, 명령 행은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eb405d6eff8a4115aee698cb0c98540a6a3fb25a" translate="yes" xml:space="preserve">
          <source>Sometimes you want to test if a module, or a list of modules, can successfully load. For example, you'll often want a first test which simply loads all the modules in the distribution to make sure they work before going on to do more complicated testing.</source>
          <target state="translated">때로는 모듈 또는 모듈 목록이 성공적으로로드 될 수 있는지 테스트하려고합니다. 예를 들어,보다 복잡한 테스트를 진행하기 전에 배포판의 모든 모듈을로드하여 작동하는지 확인하는 첫 번째 테스트를 원할 경우가 종종 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddf8f669e0c9325d3a3aabdd507e3c59589ddd67" translate="yes" xml:space="preserve">
          <source>Sometimes, for example when there are a lot of options, having a separate variable for each of them can be cumbersome. GetOptions() supports, as an alternative mechanism, storing options values in a hash.</source>
          <target state="translated">예를 들어 옵션이 많은 경우 각 옵션마다 별도의 변수를 갖는 것이 번거로울 수 있습니다. GetOptions ()는 대체 메커니즘으로 옵션 값을 해시에 저장하는 기능을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="02fbdd8083e416b0e9b5fb808fb524ba8afb9c15" translate="yes" xml:space="preserve">
          <source>Sometimes, however, linked lists can be useful in situations where you want to &quot;shard&quot; an array so you have many small arrays instead of a single big array. You can keep arrays longer than Perl's largest array index, lock smaller arrays separately in threaded programs, reallocate less memory, or quickly insert elements in the middle of the chain.</source>
          <target state="translated">그러나 때때로 링크 된 목록은 배열을 &quot;샤딩&quot;하려는 경우 큰 단일 배열 대신 작은 배열이 많이있는 경우에 유용 할 수 있습니다. 배열을 Perl의 가장 큰 배열 인덱스보다 길게 유지하고, 더 작은 배열을 스레드 프로그램에서 개별적으로 잠 그거나, 메모리를 다시 할당하거나, 체인 중간에 요소를 빠르게 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97c577b8a14d559ea222f726e98e3c5c96ca2ea7" translate="yes" xml:space="preserve">
          <source>Sometimes, it can be necessary or useful to make sure that a certain function is fully loaded by AutoLoader. This is the case, for example, when you need to wrap a function to inject debugging code. It is also helpful to force early loading of code before forking to make use of copy-on-write as much as possible.</source>
          <target state="translated">때로는 특정 기능이 AutoLoader에 의해 완전히로드되도록하는 것이 필요하거나 유용 할 수 있습니다. 예를 들어 디버깅 코드를 주입하기 위해 함수를 래핑해야하는 경우입니다. 또한 COW (Copy-On-Write)를 최대한 활용하기 전에 코드를 조기에로드하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c69c69258cfab486eea48fb3f2e535b94c5ff785" translate="yes" xml:space="preserve">
          <source>Sometimes, when the extension does not convert data but just stores and retrieves it, you will be able to use the otherwise dangerous &lt;a href=&quot;encode#_utf8_on&quot;&gt;Encode::_utf8_on() &lt;/a&gt; function. Let's say the popular &lt;code&gt;Foo::Bar&lt;/code&gt; extension, written in C, provides a &lt;code&gt;param&lt;/code&gt; method that lets you store and retrieve data according to these prototypes:</source>
          <target state="translated">때로는 확장 프로그램이 데이터를 변환하지 않고 데이터를 저장하고 검색 할 때 위험한 &lt;a href=&quot;encode#_utf8_on&quot;&gt;Encode :: _ utf8_on ()&lt;/a&gt; 함수 를 사용할 수 있습니다. C로 작성된 인기있는 &lt;code&gt;Foo::Bar&lt;/code&gt; 확장은 다음 프로토 타입에 따라 데이터를 저장하고 검색 할 수 있는 &lt;code&gt;param&lt;/code&gt; 메소드를 제공 한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="915dac0cd6a2dc4688c56bcdae8cb3044da9ebd2" translate="yes" xml:space="preserve">
          <source>Sometimes, you might not wish to extract a complete archive, just the files that are relevant to you, based on some criteria.</source>
          <target state="translated">때로는 일부 기준에 따라 전체 아카이브를 추출하지 않고 자신과 관련된 파일 만 추출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d2c8f1aa042b04053bafd03d4559b130a601b41" translate="yes" xml:space="preserve">
          <source>Sort an array, with various options.</source>
          <target state="translated">다양한 옵션으로 배열을 정렬하십시오.</target>
        </trans-unit>
        <trans-unit id="f11b2d382bb4d1812bd22f06feccfbd16f64c011" translate="yes" xml:space="preserve">
          <source>Sort an array. Here is an example:</source>
          <target state="translated">배열을 정렬하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4d31f4a6a4ae686389ba0f01ad7435ce3ff7f965" translate="yes" xml:space="preserve">
          <source>Sort speed and memory use impacts</source>
          <target state="translated">정렬 속도 및 메모리 사용 영향</target>
        </trans-unit>
        <trans-unit id="e86fa3b469953cdb9c0cfc2f27adce6dc70ff6d4" translate="yes" xml:space="preserve">
          <source>Sort your map in Unicode order.</source>
          <target state="translated">유니 코드 순서로 맵을 정렬하십시오.</target>
        </trans-unit>
        <trans-unit id="ba790800e4b9f3d3512c898b0e6088f4dbb30c87" translate="yes" xml:space="preserve">
          <source>Sorting - the quicksort algorithm used in Perls before 5.8.0 to implement the sort() function is very easy to trick into misbehaving so that it consumes a lot of time. Starting from Perl 5.8.0 a different sorting algorithm, mergesort, is used by default. Mergesort cannot misbehave on any input.</source>
          <target state="translated">정렬-sort () 함수를 구현하기 위해 5.8.0 이전의 Perls에서 사용 된 퀵 정렬 알고리즘은 오작동을 속이기 때문에 많은 시간을 소비합니다. Perl 5.8.0부터는 다른 정렬 알고리즘 인 mergesort가 기본적으로 사용됩니다. Mergesort는 모든 입력에서 오작동 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="88a6e89fe9499560d5c7c4f0eba879f0797fcbdf" translate="yes" xml:space="preserve">
          <source>Sorts a list of strings.</source>
          <target state="translated">문자열 목록을 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="89989e7858233b758069d9e36e356e32ea1f4ab9" translate="yes" xml:space="preserve">
          <source>Sounds an awful lot like a process, doesn't it? Well, it should. Threads are one of the pieces of a process. Every process has at least one thread and, up until now, every process running Perl had only one thread. With 5.8, though, you can create extra threads. We're going to show you how, when, and why.</source>
          <target state="translated">프로세스처럼 끔찍하게 들립니다. 글쎄요. 스레드는 프로세스의 한 부분입니다. 모든 프로세스에는 하나 이상의 스레드가 있으며 지금까지 Perl을 실행하는 모든 프로세스에는 스레드가 하나만있었습니다. 그러나 5.8을 사용하면 추가 스레드를 만들 수 있습니다. 방법,시기 및 이유를 보여 드리겠습니다.</target>
        </trans-unit>
        <trans-unit id="7b37110e5b01350732eac4676af2611966b9ccef" translate="yes" xml:space="preserve">
          <source>Source Code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0a8c7951e6c30a3c63c9dfb78486cbdf3df91af" translate="yes" xml:space="preserve">
          <source>Source Documentation</source>
          <target state="translated">소스 문서</target>
        </trans-unit>
        <trans-unit id="c29ede2e39eca25683627a84bf1a76ac20119bd7" translate="yes" xml:space="preserve">
          <source>Source Filters</source>
          <target state="translated">소스 필터</target>
        </trans-unit>
        <trans-unit id="ade8f2661e9afaab2f2ac27ea8394747efc3b4bf" translate="yes" xml:space="preserve">
          <source>Source Handler</source>
          <target state="translated">소스 핸들러</target>
        </trans-unit>
        <trans-unit id="862ba12e5a4342d2fb92f862ee8e26706e1ba4d8" translate="yes" xml:space="preserve">
          <source>Source code locations, even if available, can often be missing or misleading if the compiler has e.g. inlined code. Optimizer can make matching the source code and the object code quite challenging.</source>
          <target state="translated">컴파일러에 인라인 코드가있는 경우 소스 코드 위치가 사용 가능하더라도 종종 누락되거나 오도 될 수 있습니다. 옵티마이 저는 소스 코드와 오브젝트 코드를 일치시키는 것을 매우 어렵게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0272509bdb0dc4d43ea57d6e30f085a388335e1" translate="yes" xml:space="preserve">
          <source>Source documentation is created by putting POD comments into the C source, like this:</source>
          <target state="translated">소스 문서는 다음과 같이 POD 주석을 C 소스에 넣어서 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="4e42a4c9cdabac1017a64b490d8e6fd830b2d27a" translate="yes" xml:space="preserve">
          <source>Source filtering is an immensely powerful feature of recent versions of Perl. It allows one to extend the language itself (e.g. the Switch module), to simplify the language (e.g. Language::Pythonesque), or to completely recast the language (e.g. Lingua::Romana::Perligata). Effectively, it allows one to use the full power of Perl as its own, recursively applied, macro language.</source>
          <target state="translated">소스 필터링은 최신 버전의 Perl에서 엄청나게 강력한 기능입니다. 언어 자체 (예 : 스위치 모듈)를 확장하거나 언어 (예 : Language :: Pythonesque)를 단순화하거나 언어 (예 : Lingua :: Romana :: Perligata)를 완전히 다시 변환 할 수 있습니다. 실제로 Perl의 모든 기능을 자체적으로 재귀 적으로 적용되는 매크로 언어로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83fa9e2aac616eaf300f336da8ba4cb15a670bf8" translate="yes" xml:space="preserve">
          <source>Source filters activated within &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; leak out into whichever</source>
          <target state="translated">내 활성화 소스 필터 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 어느로 누출</target>
        </trans-unit>
        <trans-unit id="23c4984b5ea778bfe1a620b2921096dd64ef1a0a" translate="yes" xml:space="preserve">
          <source>Source filters only work on the string level, thus are highly limited in its ability to change source code on the fly. It cannot detect comments, quoted strings, heredocs, it is no replacement for a real parser. The only stable usage for source filters are encryption, compression, or the byteloader, to translate binary code back to source code.</source>
          <target state="translated">소스 필터는 문자열 수준에서만 작동하므로 소스 코드를 즉시 변경하는 기능이 크게 제한됩니다. 주석, 따옴표 붙은 문자열, heredocs를 감지 할 수 없으며 실제 파서를 대체하지 않습니다. 소스 필터의 유일한 안정적인 사용법은 이진 코드를 다시 소스 코드로 변환하는 암호화, 압축 또는 바이트 로더입니다.</target>
        </trans-unit>
        <trans-unit id="6cf561fd42e8003d80556309fdb07a79bace6a7b" translate="yes" xml:space="preserve">
          <source>Source of the ISO 639-2 codes.</source>
          <target state="translated">ISO 639-2 코드의 출처.</target>
        </trans-unit>
        <trans-unit id="178db77b6a3b9b6df2ef880ae7bdafacae37b3c6" translate="yes" xml:space="preserve">
          <source>Source of the ISO 639-5 codes.</source>
          <target state="translated">ISO 639-5 코드의 출처.</target>
        </trans-unit>
        <trans-unit id="b69498a9aee25a26e6f9b5b4bc9ecc63222abc92" translate="yes" xml:space="preserve">
          <source>SourceHandler</source>
          <target state="translated">SourceHandler</target>
        </trans-unit>
        <trans-unit id="8644212c6ba60e5d4b37bed3eca56024c125205f" translate="yes" xml:space="preserve">
          <source>SourceHandlers</source>
          <target state="translated">SourceHandlers</target>
        </trans-unit>
        <trans-unit id="2eb56be3c2d93cdab0c52e677e3167dfddb30ac5" translate="yes" xml:space="preserve">
          <source>Sources</source>
          <target state="translated">Sources</target>
        </trans-unit>
        <trans-unit id="0933c3d8de99d538b1745c97c9ac4e0808ab779e" translate="yes" xml:space="preserve">
          <source>Sources of further information</source>
          <target state="translated">추가 정보 출처</target>
        </trans-unit>
        <trans-unit id="b1ffb4c07982ffdd1d32da2ad256d5f400cca0af" translate="yes" xml:space="preserve">
          <source>South America</source>
          <target state="translated">남아메리카</target>
        </trans-unit>
        <trans-unit id="f082fd9f31b253e1bc875b4f98b8b4196b3c96c9" translate="yes" xml:space="preserve">
          <source>Space after each comma.</source>
          <target state="translated">각 쉼표 뒤에 공백이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b842d2b9fb013f376f25c0749d5ad88cdb3e09d2" translate="yes" xml:space="preserve">
          <source>Space after last parenthesis matching on current line.</source>
          <target state="translated">현재 줄에서 마지막 괄호 뒤의 공백.</target>
        </trans-unit>
        <trans-unit id="155b83258e151629b360ae86e49e0abf46f96413" translate="yes" xml:space="preserve">
          <source>Space around a &quot;complex&quot; subscript (inside brackets).</source>
          <target state="translated">&quot;복잡한&quot;첨자 주위 공간 (괄호 안에).</target>
        </trans-unit>
        <trans-unit id="3f9d9d7fddff18fb290d25d4e2d47eb10b024565" translate="yes" xml:space="preserve">
          <source>Space around most operators.</source>
          <target state="translated">대부분의 운영자 주변 공간.</target>
        </trans-unit>
        <trans-unit id="01ea9b6b043a2469906ded26f3a48de8eaf9e6e3" translate="yes" xml:space="preserve">
          <source>Space before the opening curly of a multi-line BLOCK.</source>
          <target state="translated">여러 줄의 블록이 열리기 전의 공간.</target>
        </trans-unit>
        <trans-unit id="1109418eced3ecb23f96484aec5504c863ea2053" translate="yes" xml:space="preserve">
          <source>Spaces in the argument delimit distinct patterns, so &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('*.exe *.dll')&lt;/code&gt; globs all filenames that end in &lt;code&gt;.exe&lt;/code&gt; or &lt;code&gt;.dll&lt;/code&gt;. If you want to put in literal spaces in the glob pattern, you can escape them with either double quotes, or backslashes. e.g. &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('c:/&quot;Program Files&quot;/*/*.dll')&lt;/code&gt; , or &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('c:/Program\ Files/*/*.dll')&lt;/code&gt; . The argument is tokenized using &lt;code&gt;Text::ParseWords::parse_line()&lt;/code&gt; , so see &lt;a href=&quot;../text/parsewords&quot;&gt;Text::ParseWords&lt;/a&gt; for details of the quoting rules used.</source>
          <target state="translated">인수의 공백은 고유 한 패턴을 구분하므로 &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('*.exe *.dll')&lt;/code&gt; 은 &lt;code&gt;.exe&lt;/code&gt; 또는 &lt;code&gt;.dll&lt;/code&gt; 로 끝나는 모든 파일 이름을 붙 입니다. glob 패턴으로 리터럴 공백을 넣으려면 큰 따옴표 또는 백 슬래시로 이스케이프 처리 할 수 ​​있습니다. 예를 들어 &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('c:/&quot;Program Files&quot;/*/*.dll')&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('c:/Program\ Files/*/*.dll')&lt;/code&gt; 입니다. 인수는 &lt;code&gt;Text::ParseWords::parse_line()&lt;/code&gt; 사용하여 토큰 화 되므로 사용 된 인용 규칙에 대한 자세한 내용 은 &lt;a href=&quot;../text/parsewords&quot;&gt;Text :: ParseWords&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="39b253a2d834caa9ad3a83fa215c9eabff3effb2" translate="yes" xml:space="preserve">
          <source>Speaking of debugging, there are several pragmas available to control and debug regexps in Perl. We have already encountered one pragma in the previous section, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval';&lt;/code&gt; , that allows variable interpolation and code expressions to coexist in a regexp. The other pragmas are</source>
          <target state="translated">디버깅에 관해서는 Perl에서 정규 표현식을 제어하고 디버깅하는 데 사용할 수있는 몇 가지 실용성이 있습니다. 우리는 이미 이전 섹션에서 하나 프라그가 발생 한 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval';&lt;/code&gt; 변수 보간 및 코드 표현식이 정규 표현식에 공존 할 수 있습니다. 다른 pragma는</target>
        </trans-unit>
        <trans-unit id="5cdd144975003eba8959b061eba84041ab9e203b" translate="yes" xml:space="preserve">
          <source>Speaking of the build directory. Do I have to clean it up myself?</source>
          <target state="translated">빌드 디렉토리에 대해 말하십시오. 직접 청소해야합니까?</target>
        </trans-unit>
        <trans-unit id="cf16c389cb12320d4c2b7cc5db763c0d5676df4a" translate="yes" xml:space="preserve">
          <source>Speaking of things like &lt;code&gt;@{$AoA[$i]}&lt;/code&gt; , the following are actually the same thing:</source>
          <target state="translated">같은 것들을 말하기 &lt;code&gt;@{$AoA[$i]}&lt;/code&gt; , 다음은 실제로 같은 것입니다 :</target>
        </trans-unit>
        <trans-unit id="735223734da1211964b616a8067d85971e38faaf" translate="yes" xml:space="preserve">
          <source>Special &lt;code&gt;make test&lt;/code&gt; targets</source>
          <target state="translated">특별 &lt;code&gt;make test&lt;/code&gt; 대상</target>
        </trans-unit>
        <trans-unit id="fdfdc56af4901b065f0b9e0022efafcd50dad6b5" translate="yes" xml:space="preserve">
          <source>Special Backtracking Control Verbs</source>
          <target state="translated">특별 역 추적 동사</target>
        </trans-unit>
        <trans-unit id="59f265692e8532f3f9f4cf8098a358d626fbb2eb" translate="yes" xml:space="preserve">
          <source>Special Cases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c09831be5235393e990f8ebc035a5453fef09355" translate="yes" xml:space="preserve">
          <source>Special Characters Inside a Bracketed Character Class</source>
          <target state="translated">대괄호로 묶인 문자 클래스 내의 특수 문자</target>
        </trans-unit>
        <trans-unit id="076a0893de022e884b65708a98aa1abe56ee52c6" translate="yes" xml:space="preserve">
          <source>Special Keys for &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용을&lt;/a&gt; 위한 특수 키</target>
        </trans-unit>
        <trans-unit id="f1bc7b98edc6763e9d6c0abf8b4fa80886e2046f" translate="yes" xml:space="preserve">
          <source>Special Keys for use overload</source>
          <target state="translated">과부하 사용을위한 특수 키</target>
        </trans-unit>
        <trans-unit id="749ad8df41c6024cc71b56ff395f77ccf401c88e" translate="yes" xml:space="preserve">
          <source>Special Literals</source>
          <target state="translated">특수 리터럴</target>
        </trans-unit>
        <trans-unit id="d4cb1cbcc64290386b7c11a130ff81a51320cc9f" translate="yes" xml:space="preserve">
          <source>Special Patterns</source>
          <target state="translated">특수 패턴</target>
        </trans-unit>
        <trans-unit id="f4d1e4b7e421f179bd6711768af6fd760a8db942" translate="yes" xml:space="preserve">
          <source>Special Topics</source>
          <target state="translated">특별 주제</target>
        </trans-unit>
        <trans-unit id="93e61da05b321c91a757c91aeb83a231cf936002" translate="yes" xml:space="preserve">
          <source>Special behaviors for OS X</source>
          <target state="translated">OS X에 대한 특수 동작</target>
        </trans-unit>
        <trans-unit id="e0e39ed69d2c670390ee8a8802b8ef63f9291065" translate="yes" xml:space="preserve">
          <source>Special floating point: infinity (Inf) and not-a-number (NaN)</source>
          <target state="translated">특수 부동 소수점 : 무한대 (Inf) 및 숫자가 아님 (NaN)</target>
        </trans-unit>
        <trans-unit id="ca393fa33bfec26b8152f3f8b37c3b963f3cd851" translate="yes" xml:space="preserve">
          <source>Special make test targets</source>
          <target state="translated">특별 테스트 대상</target>
        </trans-unit>
        <trans-unit id="3bc242af481a6d0584675ca62d67c528336abb44" translate="yes" xml:space="preserve">
          <source>Special note should be made of the return values for a few properties:</source>
          <target state="translated">몇 가지 속성에 대한 반환 값에 특별한주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="b129e56f9be43046b321c79a90495916b0276970" translate="yes" xml:space="preserve">
          <source>Special package variables when using &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt;, see &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;. Because of this specialness &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; don't need to be declared (using &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; , or &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our()&lt;/a&gt;&lt;/code&gt;) even when using the &lt;code&gt;strict 'vars'&lt;/code&gt; pragma. Don't lexicalize them with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $a&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $b&lt;/code&gt; if you want to be able to use them in the &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; comparison block or function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; 사용시 특수 패키지 변수 는 &lt;a href=&quot;functions/sort&quot;&gt;sort를&lt;/a&gt; 참조하십시오 . 이 특수성 때문에 &lt;code&gt;strict 'vars'&lt;/code&gt; 사용할 때에도 &lt;code&gt;$a&lt;/code&gt; 및 &lt;code&gt;$b&lt;/code&gt; 를 선언 할 필요는 없습니다 ( &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our()&lt;/a&gt;&lt;/code&gt; ) . 그들을 lexicalize하지 마십시오 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $a&lt;/code&gt; $ a를 또는 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $b&lt;/code&gt; $ B를 당신이에서 사용할 수 있도록하려면 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; 비교 블록 또는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="c400e57824d764b6a1f1b8ed067b982b5491dad3" translate="yes" xml:space="preserve">
          <source>Special regop that is used by &lt;code&gt;re_intuit_start()&lt;/code&gt; to check if a pattern can match at a certain position. For instance if the regex engine knows that the pattern must start with a 'Z' then it can scan the string until it finds one and then launch the regex engine from there. The routine that handles this is called &lt;code&gt;find_by_class()&lt;/code&gt; . Sometimes this field points at a regop embedded in the program, and sometimes it points at an independent synthetic regop that has been constructed by the optimiser.</source>
          <target state="translated">패턴이 특정 위치에서 일치 할 수 있는지 확인하기 위해 &lt;code&gt;re_intuit_start()&lt;/code&gt; 에서 사용하는 특수 regop입니다 . 예를 들어 정규식 엔진이 패턴이 'Z'로 시작해야한다는 것을 알고 있으면 문자열을 찾을 때까지 문자열을 스캔 한 다음 거기서부터 정규식 엔진을 시작할 수 있습니다. 이를 처리하는 루틴을 &lt;code&gt;find_by_class()&lt;/code&gt; 라고 합니다. 때때로이 필드는 프로그램에 내장 된 regop을 가리키고 때로는 옵티마이 저가 구성한 독립적 인 합성 regop을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="d7c69507b8821a1ac319bfe089337d432b752233" translate="yes" xml:space="preserve">
          <source>Special thanks to Craig Berry and Peter Prymmer (for VMS portability help), Randy Kobes (for Win32 portability help), Clinton Pierce and Autrijus Tang (for heroic eleventh-hour Win32 testing above and beyond the call of duty), Michael G Schwern (for testing advice), and the rest of the CPAN testers (for testing generally).</source>
          <target state="translated">Craig Gru와 Peter Prymmer (VMS 이식성 도움), Randy Kobes (Win32 이식성 도움), Clinton Pierce 및 Autrijus Tang (위의 의무를 뛰어 넘는 11 시간 Win32 테스트 용), Michael G Schwern (Mr. 테스트 조언) 및 나머지 CPAN 테스터 (일반적으로 테스트)</target>
        </trans-unit>
        <trans-unit id="5543458d832e80fa74fffef1fb3a6e0c964fd937" translate="yes" xml:space="preserve">
          <source>Special thanks to Jarkko Hietaniemi, the 5.8.0 pumpking, for including this module in the core and for his patient and helpful guidance during the integration process.</source>
          <target state="translated">이 모듈을 코어에 포함하고 통합 과정에서 환자와 도움을 준 5.5 호박, Jarkko Hietaniemi에게 특별한 감사를드립니다.</target>
        </trans-unit>
        <trans-unit id="bdc349ae3de267bae2e06e8394305bd25b3d697e" translate="yes" xml:space="preserve">
          <source>Special thanks to Tels for suggesting several speed and memory optimizations.</source>
          <target state="translated">여러 속도 및 메모리 최적화를 제안한 Tels에게 특별히 감사드립니다.</target>
        </trans-unit>
        <trans-unit id="58c72ff51f409e740d18b159d1db36db70f1453a" translate="yes" xml:space="preserve">
          <source>Special thanks to the following people who assisted in the creation of the document.</source>
          <target state="translated">문서 작성을 도와 주신 다음 분들께 감사드립니다.</target>
        </trans-unit>
        <trans-unit id="b9982eff3f0e28f25e92903f06ecf866a5e7dab5" translate="yes" xml:space="preserve">
          <source>Special variables that have side effects when you access them or assign to them. For example, in Perl, changing elements of the &lt;code&gt;%ENV&lt;/code&gt; array also changes the corresponding environment variables that subprocesses will use. Reading the &lt;code&gt;$!&lt;/code&gt; variable gives you the current system error number or message.</source>
          <target state="translated">액세스하거나 할당 할 때 부작용이있는 특수 변수. 예를 들어 Perl에서 &lt;code&gt;%ENV&lt;/code&gt; 배열의 요소를 변경하면 하위 프로세스에서 사용할 해당 환경 변수도 변경됩니다. &lt;code&gt;$!&lt;/code&gt; 읽고 ! 변수는 현재 시스템 오류 번호 또는 메시지를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="100bcda8aa4f874878478525651d3bbff5ff7492" translate="yes" xml:space="preserve">
          <source>Specialised Import Lists</source>
          <target state="translated">전문화 된 수입 목록</target>
        </trans-unit>
        <trans-unit id="7b09828591f2a4848f0494348259138540610a11" translate="yes" xml:space="preserve">
          <source>Specific (mis)features of OS/2 port</source>
          <target state="translated">OS / 2 포트의 특정 기능</target>
        </trans-unit>
        <trans-unit id="f1dec8c277f6ad361d73048827b65d45acdb1217" translate="yes" xml:space="preserve">
          <source>Specific features of the Cygwin port</source>
          <target state="translated">Cygwin 포트의 특정 기능</target>
        </trans-unit>
        <trans-unit id="686482526f9ca64e951de751df199a7ac0b21959" translate="yes" xml:space="preserve">
          <source>Specific for EMX port. Gives the directory part of the location for</source>
          <target state="translated">EMX 포트에만 해당됩니다. 위치의 디렉토리 부분을 제공합니다</target>
        </trans-unit>
        <trans-unit id="8719eacadd757c4d532ec01e84ca717f26242d45" translate="yes" xml:space="preserve">
          <source>Specific for EMX port. Should have the form</source>
          <target state="translated">EMX 포트에만 해당됩니다. 양식이 있어야합니다</target>
        </trans-unit>
        <trans-unit id="57a0519d586edded6d90f93d7b49b9ce56048c1e" translate="yes" xml:space="preserve">
          <source>Specific for EMX port. Since</source>
          <target state="translated">EMX 포트에만 해당됩니다. 이후</target>
        </trans-unit>
        <trans-unit id="17684874cc7718b5fa207627bf38a956b3362a43" translate="yes" xml:space="preserve">
          <source>Specific for EMX port. Used as storage place for temporary files.</source>
          <target state="translated">EMX 포트에만 해당됩니다. 임시 파일의 저장 장소로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8ee5fb071a0f4fc5995dbb8fab061746ab818f7e" translate="yes" xml:space="preserve">
          <source>Specifically, we read pathnames one at a time from the input array, and store the results in an output array (results) in the same order. If statfs fails, the element pushed onto the return array is the value of errno after the failure. If statfs succeeds, though, the value pushed onto the return array is a reference to a hash containing some of the information in the statfs structure.</source>
          <target state="translated">특히, 입력 배열에서 한 번에 하나씩 경로 이름을 읽고 결과를 동일한 순서로 출력 배열 (결과)에 저장합니다. statfs가 실패하면 리턴 배열로 푸시 된 요소는 실패 후 errno의 값입니다. statfs가 성공하면 리턴 배열로 푸시 된 값은 statfs 구조의 일부 정보를 포함하는 해시에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="eda3fdece3884b319c275582d4e0949e974b3c68" translate="yes" xml:space="preserve">
          <source>Specifically: Turning on this option will disable the heuristics for seeing only files with Perl-like extensions, omitting subdirectories that are numeric but do</source>
          <target state="translated">구체적으로 :이 옵션을 켜면 Perl과 같은 확장명을 가진 파일 만 볼 수있는 휴리스틱이 비활성화되지만 숫자는 있지만 하위 디렉토리는 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="ed81a4faa05daf1c1be51b7b8fa82d019bf30684" translate="yes" xml:space="preserve">
          <source>Specification for CPAN distribution metadata</source>
          <target state="translated">CPAN 배포 메타 데이터 사양</target>
        </trans-unit>
        <trans-unit id="73a4072f8995fd4faf63509594cc45d51dcda62a" translate="yes" xml:space="preserve">
          <source>Specified line by line via &lt;b&gt;-e&lt;/b&gt; or &lt;b&gt;-E&lt;/b&gt; switches on the command line.</source>
          <target state="translated">명령 행에서 &lt;b&gt;-e&lt;/b&gt; 또는 &lt;b&gt;-E&lt;/b&gt; 스위치를 통해 지정된 행 단위.</target>
        </trans-unit>
        <trans-unit id="acc937be340e9018f067e36d4fbe600f0ca7a48d" translate="yes" xml:space="preserve">
          <source>Specifies a TAP::Harness subclass to be used in place of TAP::Harness.</source>
          <target state="translated">TAP :: Harness 대신 사용할 TAP :: Harness 서브 클래스를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="2ccb38b1ea1946cfb54e7b524ba85568b166e308" translate="yes" xml:space="preserve">
          <source>Specifies a name to be used for the extension, e.g., -n RPC::DCE</source>
          <target state="translated">확장에 사용될 이름을 지정합니다 (예 : -n RPC :: DCE).</target>
        </trans-unit>
        <trans-unit id="fb10437a9b9ee94fe2ef27d29d4fd6290157541f" translate="yes" xml:space="preserve">
          <source>Specifies an encoding to store lexicon entries, instead of utf8-strings. If set to &lt;code&gt;locale&lt;/code&gt; , the encoding from the current locale setting is used. Implies a true value for &lt;code&gt;Decode&lt;/code&gt; .</source>
          <target state="translated">utf8-string 대신 lexicon 항목을 저장하기위한 인코딩을 지정합니다. 세트하는 경우 &lt;code&gt;locale&lt;/code&gt; , 현재 지역 설정의 부호화가 사용된다. &lt;code&gt;Decode&lt;/code&gt; 의 true 값을 나타 냅니다.</target>
        </trans-unit>
        <trans-unit id="5288f1281b330410c08afae34819d7cfc53b87f4" translate="yes" xml:space="preserve">
          <source>Specifies any additional arguments to pass to the compiler. Should be given as a list reference containing the arguments individually, or if this is not possible, as a string containing all the arguments together.</source>
          <target state="translated">컴파일러에 전달할 추가 인수를 지정합니다. 인수를 개별적으로 포함하는 목록 참조 또는 가능하지 않은 경우 모든 인수를 함께 포함하는 문자열로 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="8c0fc5c465acc07c545f1645a7b4737064b57885" translate="yes" xml:space="preserve">
          <source>Specifies any additional directories in which to search for header files. May be given as a string indicating a single directory, or as a list reference indicating multiple directories.</source>
          <target state="translated">헤더 파일을 검색 할 추가 디렉토리를 지정합니다. 단일 디렉토리를 나타내는 문자열 또는 여러 디렉토리를 나타내는 목록 참조로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df5f877cdfce163f364b76c3bfab4e6c5095d6d8" translate="yes" xml:space="preserve">
          <source>Specifies file structure for file to be transferred.</source>
          <target state="translated">전송할 파일의 파일 구조를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="087e5ef636ea46b335e961f7299045a135d4c08f" translate="yes" xml:space="preserve">
          <source>Specifies how much effort bzip2 should take before resorting to a slower fallback compression algorithm.</source>
          <target state="translated">느린 대체 압축 알고리즘을 사용하기 전에 bzip2가 얼마나 많은 노력을 기울여야하는지 지정합니다.</target>
        </trans-unit>
        <trans-unit id="98ed6b009cf98007a6f6d9bd7e33d610c98ad8ec" translate="yes" xml:space="preserve">
          <source>Specifies one or more directories to search for the input file if it was not supplied with an absolute path. Each directory path in the given list should be separated by a ':' on Unix (';' on MSWin32 and DOS).</source>
          <target state="translated">입력 파일에 절대 경로가 제공되지 않은 경우 검색 할 하나 이상의 디렉토리를 지정합니다. 주어진 목록의 각 디렉토리 경로는 Unix에서 ':'(MSWin32 및 DOS에서는 ';')로 구분해야합니다.</target>
        </trans-unit>
        <trans-unit id="1b9774b42720c2ff28dbc21e628ebcd3703ef058" translate="yes" xml:space="preserve">
          <source>Specifies that the source file is a C++ source file and sets appropriate compiler flags</source>
          <target state="translated">소스 파일이 C ++ 소스 파일임을 지정하고 적절한 컴파일러 플래그를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="752f5b793296a2436f0f638671fc26add2789004" translate="yes" xml:space="preserve">
          <source>Specifies that this distribution shall not be processed at all.</source>
          <target state="translated">이 분배가 전혀 처리되지 않도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="27c19b2359d6f4ac0335e1401df42879661c8cd1" translate="yes" xml:space="preserve">
          <source>Specifies the directory to use for the temporary directory. The temporary directory name is derived from an internal template.</source>
          <target state="translated">임시 디렉토리에 사용할 디렉토리를 지정합니다. 임시 디렉토리 이름은 내부 템플릿에서 파생됩니다.</target>
        </trans-unit>
        <trans-unit id="69c1bcd4ebd70c8615309d5b9b715199cd57859f" translate="yes" xml:space="preserve">
          <source>Specifies the encoding you are converting from. Unlike &lt;b&gt;iconv&lt;/b&gt;, this option can be omitted. In such cases, the current locale is used.</source>
          <target state="translated">변환중인 인코딩을 지정합니다. &lt;b&gt;iconv&lt;/b&gt; 와 달리이 옵션은 생략 할 수 있습니다. 이러한 경우 현재 로캘이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b6aabb58f01ed0bc266ebcb530fd5e3060867e4c" translate="yes" xml:space="preserve">
          <source>Specifies the encoding you are converting to. Unlike &lt;b&gt;iconv&lt;/b&gt;, this option can be omitted. In such cases, the current locale is used.</source>
          <target state="translated">변환중인 인코딩을 지정합니다. &lt;b&gt;iconv&lt;/b&gt; 와 달리이 옵션은 생략 할 수 있습니다. 이러한 경우 현재 로캘이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bc14cf57cc1d526c9df38cf39a2a5e11891e51ad" translate="yes" xml:space="preserve">
          <source>Specifies the extension of the module's loadable object. For example:</source>
          <target state="translated">모듈의로드 가능한 객체의 확장을 지정합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="62350db256aee74b2119a37a32d38d1a559bd3c6" translate="yes" xml:space="preserve">
          <source>Specifies the method or subroutine to use when printing error messages about POD syntax. The supplied method/subroutine</source>
          <target state="translated">POD 구문에 대한 오류 메시지를 인쇄 할 때 사용할 메소드 또는 서브 루틴을 지정합니다. 제공된 방법 / 서브 루틴</target>
        </trans-unit>
        <trans-unit id="8490adfe21694bc6560acb4c4b017183f5259a5a" translate="yes" xml:space="preserve">
          <source>Specifies the name of the Perl module that will be created by linking. On platforms that need to do prelinking (Win32, OS/2, etc.) this is a required parameter.</source>
          <target state="translated">링크로 작성 될 Perl 모듈의 이름을 지정합니다. 사전 연결 (Win32, OS / 2 등)을 수행해야하는 플랫폼에서는 필수 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="f6fab30529e40665f8d0178ef7752b76fb583aec" translate="yes" xml:space="preserve">
          <source>Specifies the name of the output executable file to create. Otherwise the &lt;code&gt;exe_file()&lt;/code&gt; method will be consulted, passing it the name of the first entry in &lt;code&gt;objects&lt;/code&gt; .</source>
          <target state="translated">작성할 출력 실행 파일의 이름을 지정합니다. 그렇지 않으면 &lt;code&gt;exe_file()&lt;/code&gt; 메소드를 참조하여 &lt;code&gt;objects&lt;/code&gt; 의 첫 번째 항목 이름을 전달 합니다 .</target>
        </trans-unit>
        <trans-unit id="712c7b0a7198fb19bf2fcbbf1b68671ab3789d42" translate="yes" xml:space="preserve">
          <source>Specifies the name of the output file to create. Otherwise the &lt;code&gt;object_file()&lt;/code&gt; method will be consulted, passing it the name of the &lt;code&gt;source&lt;/code&gt; file.</source>
          <target state="translated">작성할 출력 파일의 이름을 지정합니다. 그렇지 않으면 &lt;code&gt;object_file()&lt;/code&gt; 메소드를 참조하여 &lt;code&gt;source&lt;/code&gt; 파일 의 이름을 전달 합니다.</target>
        </trans-unit>
        <trans-unit id="0ea5fb9dc13c7dfd946c4f0ec1f502d959136293" translate="yes" xml:space="preserve">
          <source>Specifies the name of the output file to generate. If no file is specified, output will be written to standard output.</source>
          <target state="translated">생성 할 출력 파일의 이름을 지정합니다. 파일을 지정하지 않으면 출력이 표준 출력에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="95eb37279bd4905df986dc0709bc7910f0b3037c" translate="yes" xml:space="preserve">
          <source>Specifies the name of the output library file to create. Otherwise the &lt;code&gt;lib_file()&lt;/code&gt; method will be consulted, passing it the name of the first entry in &lt;code&gt;objects&lt;/code&gt; .</source>
          <target state="translated">작성할 출력 라이브러리 파일의 이름을 지정합니다. 그렇지 않으면 &lt;code&gt;lib_file()&lt;/code&gt; 메소드를 참조하여 &lt;code&gt;objects&lt;/code&gt; 의 첫 번째 항목 이름을 전달 합니다 .</target>
        </trans-unit>
        <trans-unit id="9fc8b469ff5b98736322a31c19a8ffad03de9557" translate="yes" xml:space="preserve">
          <source>Specifies the string that will be prefixed to every line of the output. Empty string by default.</source>
          <target state="translated">출력의 모든 행에 접두사가 붙을 문자열을 지정합니다. 기본적으로 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="969aa343df55e9a403d592d5b7e666d694e7c272" translate="yes" xml:space="preserve">
          <source>Specifies transfer mode (stream, block or compressed) for file to be transferred.</source>
          <target state="translated">전송할 파일의 전송 모드 (스트림, 블록 또는 압축)를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="9e50a3555457e006ff9201a0e994fbe18d143981" translate="yes" xml:space="preserve">
          <source>Specify Perl version requirements with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; Perl 버전 요구 사항 지정</target>
        </trans-unit>
        <trans-unit id="7a389cd0788a594b00d81ac38b0d5b58f982bb23" translate="yes" xml:space="preserve">
          <source>Specify a collation strength of level 1 to ignore case and diacritics, only looking at the basic character.</source>
          <target state="translated">기본 문자 만보고 대소 문자와 분음 부호를 무시하려면 데이터 정렬 수준을 1로 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="fd9decfe42c6333527f5da43637561403cd51753" translate="yes" xml:space="preserve">
          <source>Specify a prefix which should be removed from the Perl function names, e.g., -p sec_rgy_ This sets up the XS &lt;b&gt;PREFIX&lt;/b&gt; keyword and removes the prefix from functions that are autoloaded via the &lt;code&gt;constant()&lt;/code&gt; mechanism.</source>
          <target state="translated">Perl 함수 이름에서 제거해야하는 접 두부를 지정하십시오 (예 : -p sec_rgy_). XS &lt;b&gt;PREFIX&lt;/b&gt; 키워드를 설정하고 &lt;code&gt;constant()&lt;/code&gt; 메커니즘을 통해 자동로드되는 함수에서 접 두부를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="8c37cb69f6acc79919a59db7bb047596246ded37" translate="yes" xml:space="preserve">
          <source>Specify a section to include in the output. See &lt;a href=&quot;pod/parser#SECTION-SPECIFICATIONS&quot;&gt;SECTION SPECIFICATIONS in Pod::Parser&lt;/a&gt; for the format to use for</source>
          <target state="translated">출력에 포함 할 섹션을 지정하십시오. 사용할 형식에 대해서는 &lt;a href=&quot;pod/parser#SECTION-SPECIFICATIONS&quot;&gt;포드 :: 파서의 섹션 사양을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c842e0100e27043e97262bc2a56a8695e0228b4b" translate="yes" xml:space="preserve">
          <source>Specify a version number for this extension. This version number is added to the templates. The default is 0.01, or 0.00_01 if &lt;code&gt;-B&lt;/code&gt; is specified. The version specified should be numeric.</source>
          <target state="translated">이 확장의 버전 번호를 지정하십시오. 이 버전 번호가 템플릿에 추가됩니다. 기본값은 0.01 또는 &lt;code&gt;-B&lt;/code&gt; 가 지정된 경우 0.00_01 입니다. 지정된 버전은 숫자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="e7f58f2c2dcff1260c061c4b22f076c9afef1f52" translate="yes" xml:space="preserve">
          <source>Specify content is binary</source>
          <target state="translated">내용을 이진으로 지정</target>
        </trans-unit>
        <trans-unit id="196ff6b62a23b7ba506c7490495c47cea5d35955" translate="yes" xml:space="preserve">
          <source>Specify in seconds how long to run the command before it is killed with SIG_KILL (9), which effectively terminates it and all of its children (direct or indirect).</source>
          <target state="translated">SIG_KILL (9)로 명령을 종료하기 전에 명령을 실행하는 시간을 초 단위로 지정하십시오. 그러면 명령 및 모든 하위 (직접 또는 간접)가 효과적으로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="e42f9f14e720a274b615a5fad1a17e292745c606" translate="yes" xml:space="preserve">
          <source>Specify pre-requisites in Makefile.PL or Build.PL</source>
          <target state="translated">Makefile.PL 또는 Build.PL에서 전제 조건 지정</target>
        </trans-unit>
        <trans-unit id="1a3e3b8941c020b4dead165334a6a7f6f39e0c5c" translate="yes" xml:space="preserve">
          <source>Specify replacement for groff</source>
          <target state="translated">groff 대체품 지정</target>
        </trans-unit>
        <trans-unit id="82792121ccf914c52ccf31c689a51331bdf9896b" translate="yes" xml:space="preserve">
          <source>Specify some text that will be passed into the &lt;code&gt;STDIN&lt;/code&gt; of the executed program.</source>
          <target state="translated">실행 된 프로그램 의 &lt;code&gt;STDIN&lt;/code&gt; 으로 전달 될 텍스트를 지정 하십시오.</target>
        </trans-unit>
        <trans-unit id="e4f8120097eb5801ad49966dad7112d6c8bcad54" translate="yes" xml:space="preserve">
          <source>Specify stream encoding. This is the normal way to deal with encoded text, not by calling low-level functions.</source>
          <target state="translated">스트림 인코딩을 지정하십시오. 이것은 저수준 함수를 호출하는 것이 아니라 인코딩 된 텍스트를 처리하는 일반적인 방법입니다.</target>
        </trans-unit>
        <trans-unit id="8473cee86e4b03ee43a6c19c0f0dc45619e13394" translate="yes" xml:space="preserve">
          <source>Specify the HTML file to create. Output goes to STDOUT if no outfile is specified.</source>
          <target state="translated">작성할 HTML 파일을 지정하십시오. 출력 파일이 지정되지 않은 경우 출력은 STDOUT으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="2deadb9e68c32c96f8a837b13d5dc23a9778d417" translate="yes" xml:space="preserve">
          <source>Specify the URL of a cascading style sheet. Also disables all HTML/CSS &lt;code&gt;style&lt;/code&gt; attributes that are output by default (to avoid conflicts).</source>
          <target state="translated">계단식 스타일 시트의 URL을 지정하십시오. 또한 충돌을 피하기 위해 기본적으로 출력되는 모든 HTML / CSS &lt;code&gt;style&lt;/code&gt; 속성을 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="4aa99f54409387b7146f47653777c920418ff10b" translate="yes" xml:space="preserve">
          <source>Specify the URL of cascading style sheet to link from resulting HTML file. Default is none style sheet.</source>
          <target state="translated">결과 HTML 파일에서 링크 할 CSS (Cascading Style Sheet)의 URL을 지정하십시오. 기본값은 스타일 시트 없음입니다.</target>
        </trans-unit>
        <trans-unit id="9afcf7f83edb719a030bfbfd6d7f5c91cf7f8d6b" translate="yes" xml:space="preserve">
          <source>Specify the base directory for finding library pods.</source>
          <target state="translated">라이브러리 포드를 찾기위한 기본 디렉토리를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="44291a4ec495223a1da4f1839ae4e831f5a3c791" translate="yes" xml:space="preserve">
          <source>Specify the base directory for finding library pods. Default is the current working directory.</source>
          <target state="translated">라이브러리 포드를 찾기위한 기본 디렉토리를 지정하십시오. 기본값은 현재 작업 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="bc5534a64aa32340e65ed43e45968b60d705f9fc" translate="yes" xml:space="preserve">
          <source>Specify the internal type that the constant() mechanism uses for macros. The default is IV (signed integer). Currently all macros found during the header scanning process will be assumed to have this type. Future versions of &lt;code&gt;h2xs&lt;/code&gt; may gain the ability to make educated guesses.</source>
          <target state="translated">constant () 메커니즘이 매크로에 사용하는 내부 유형을 지정하십시오. 기본값은 IV (부호있는 정수)입니다. 현재 헤더 스캐닝 과정에서 발견 된 모든 매크로는이 유형을 가지고 있다고 가정합니다. 미래 버전의 &lt;code&gt;h2xs&lt;/code&gt; 는 교육받은 추측을 할 수있는 능력을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a20b2619004bea1e14f0e7f2949d240b1952dd51" translate="yes" xml:space="preserve">
          <source>Specify the number of 100K blocks bzip2 uses during compression.</source>
          <target state="translated">압축 중 bzip2가 사용하는 100K 블록 수를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="1d869ecbc9c626d4a96da51d8e392c8fcdb22cdc" translate="yes" xml:space="preserve">
          <source>Specify the pod file to convert. Input is taken from STDIN if no infile is specified.</source>
          <target state="translated">변환 할 포드 파일을 지정하십시오. 파일이 지정되지 않은 경우 STDIN에서 입력이 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="2bed91a5a620b4aae10dcfd8cbca6e35a0ef51dd" translate="yes" xml:space="preserve">
          <source>Specify the targets for testing.</source>
          <target state="translated">테스트 대상을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="21bb885000d067ff7c549508e4dd3407f52920a2" translate="yes" xml:space="preserve">
          <source>Specify the title of the resulting HTML file.</source>
          <target state="translated">결과 HTML 파일의 제목을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="46f23c724776424563c656a058b3155bcce7e71b" translate="yes" xml:space="preserve">
          <source>Specify version requirements for other Perl modules in the pre-requisites in your Makefile.PL or Build.PL.</source>
          <target state="translated">Makefile.PL 또는 Build.PL의 전제 조건에서 다른 Perl 모듈의 버전 요구 사항을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="8bd129aeb5d58a2d4cd81a32d015c916c4dfff29" translate="yes" xml:space="preserve">
          <source>Specify which directory is used for storing cache. Default directory is the current working directory.</source>
          <target state="translated">캐시 저장에 사용되는 디렉토리를 지정하십시오. 기본 디렉토리는 현재 작업 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="c06413cd34d05ffad8b760e0ccbb2a8039560c0e" translate="yes" xml:space="preserve">
          <source>Specify which subdirectories of the podroot contain pod files whose HTML converted forms can be linked to in cross references.</source>
          <target state="translated">podroot의 어떤 서브 디렉토리에 HTML 변환 양식이 상호 참조로 링크 될 수있는 pod 파일이 들어 있는지 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="4ed9289cec9db507a9bd1e2cf8a443192d39f482" translate="yes" xml:space="preserve">
          <source>Specify which subdirectories of the podroot contain pod files whose HTML converted forms can be linked-to in cross-references.</source>
          <target state="translated">podroot의 어떤 서브 디렉토리에 HTML 변환 양식이 상호 참조로 링크 될 수있는 pod 파일이 들어 있는지 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="cda870361643b1e3b5ceca1a143c1054b6477609" translate="yes" xml:space="preserve">
          <source>Specifying VERSION as a literal of the form v5.6.1 should generally be avoided, because it leads to misleading error messages under earlier versions of Perl (that is, prior to 5.6.0) that do not support this syntax. The equivalent numeric version should be used instead.</source>
          <target state="translated">v5.6.1 형식의 리터럴로 VERSION을 지정하면이 구문을 지원하지 않는 이전 버전의 Perl (즉, 5.6.0 이전)에서 오도를 유발하는 오류 메시지가 발생하므로 일반적으로 피해야합니다. 대신 동일한 숫자 버전을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="4cc4c6ab0a0e40b55ad8e487edeab38628dd47f2" translate="yes" xml:space="preserve">
          <source>Specifying VERSION as a literal of the form v5.6.1 should generally be avoided, because it leads to misleading error messages under earlier versions of Perl that do not support this syntax. The equivalent numeric version should be used instead.</source>
          <target state="translated">v5.6.1 형식의 리터럴로 VERSION을 지정하면이 구문을 지원하지 않는 이전 버전의 Perl에서 오해를 유발하는 오류 메시지가 발생하므로 일반적으로 피해야합니다. 대신 동일한 숫자 버전을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="105a66a84ae1308320a2e6185af2d7c0f4640974" translate="yes" xml:space="preserve">
          <source>Specifying Values</source>
          <target state="translated">값 지정</target>
        </trans-unit>
        <trans-unit id="6ddacaf845437713514dee82096d8d2996a0782a" translate="yes" xml:space="preserve">
          <source>Specifying a compatibility version higher than the version of perl you are using to run h2xs will have no effect. If unspecified h2xs will default to compatibility with the version of perl you are using to run h2xs.</source>
          <target state="translated">h2x를 실행하는 데 사용하는 perl 버전보다 높은 호환성 버전을 지정해도 효과가 없습니다. 지정되지 않은 h2x가 기본적으로 h2x를 실행하는 데 사용하는 perl 버전과 호환되는 경우.</target>
        </trans-unit>
        <trans-unit id="b9ac38be3885e820db907e52feea151509c97c14" translate="yes" xml:space="preserve">
          <source>Specifying a negative flag after the caret is an error, as the flag is redundant.</source>
          <target state="translated">플래그가 중복되므로 캐럿 뒤에 음수 플래그를 지정하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fcb93594508dd14f6f183606eef58af67f897bab" translate="yes" xml:space="preserve">
          <source>Specifying a negative index position greater than the number of items in the queue adds the list to the head of the queue.</source>
          <target state="translated">큐의 항목 수보다 큰 음수 인덱스 위치를 지정하면 큐의 헤드에 목록이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="90e80e764794a3f53d9bd22d3f4959b3c3e8e8c0" translate="yes" xml:space="preserve">
          <source>Specifying an index position greater than the number of items in the queue just adds the list to the end.</source>
          <target state="translated">대기열의 항목 수보다 큰 색인 위치를 지정하면 목록이 끝에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="9c224eb1496ab5698ab91d2a22838e04eaf02d0d" translate="yes" xml:space="preserve">
          <source>Specifying an index position greater than the number of items in the queue results in &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; or an empty list being returned.</source>
          <target state="translated">큐의 항목 수보다 큰 인덱스 위치를 지정하면 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 또는 빈 목록이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="8b369061e994be9b95b9b52fd041d04e9eccbbae" translate="yes" xml:space="preserve">
          <source>Specifying sub-versions such as the &lt;code&gt;0&lt;/code&gt; in &lt;code&gt;5.14.0&lt;/code&gt; in feature bundles has no effect. Feature bundles are guaranteed to be the same for all sub-versions.</source>
          <target state="translated">기능 번들 에서 &lt;code&gt;5.14.0&lt;/code&gt; 의 &lt;code&gt;0&lt;/code&gt; 과 같은 하위 버전 을 지정해 도 효과가 없습니다. 기능 번들은 모든 하위 버전에서 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="79a6f96c957e7feef1314dc46564cc00f5833bc6" translate="yes" xml:space="preserve">
          <source>Specifying the &quot;udp&quot; protocol causes the ping() method to send a udp packet to the remote host's echo port. If the echoed packet is received from the remote host and the received packet contains the same data as the packet that was sent, the remote host is considered reachable. This protocol does not require any special privileges. It should be borne in mind that, for a udp ping, a host will be reported as unreachable if it is not running the appropriate echo service. For Unix-like systems see</source>
          <target state="translated">&quot;udp&quot;프로토콜을 지정하면 ping () 메소드가 udp 패킷을 원격 호스트의 에코 포트로 보냅니다. 반향 된 패킷이 원격 호스트에서 수신되고 수신 된 패킷에 전송 된 패킷과 동일한 데이터가 포함 된 경우 원격 호스트는 도달 가능한 것으로 간주됩니다. 이 프로토콜에는 특별한 권한이 필요하지 않습니다. udp ping의 경우 적절한 에코 서비스를 실행하지 않으면 호스트에 연결할 수없는 것으로보고된다는 점을 명심해야합니다. 유닉스 계열 시스템의 경우</target>
        </trans-unit>
        <trans-unit id="2819720e6a0b64709090cd36c99161c9c51d2535" translate="yes" xml:space="preserve">
          <source>Specifying the G_DISCARD flag with</source>
          <target state="translated">다음과 같이 G_DISCARD 플래그 지정</target>
        </trans-unit>
        <trans-unit id="2d2cb022bc3d26bd1407c4aa787d5e46e1ad4c3b" translate="yes" xml:space="preserve">
          <source>Speed</source>
          <target state="translated">Speed</target>
        </trans-unit>
        <trans-unit id="40e5809be52d66c56af4f3807fbc74465fe77f2b" translate="yes" xml:space="preserve">
          <source>Spherical coordinates,</source>
          <target state="translated">구면 좌표,</target>
        </trans-unit>
        <trans-unit id="0bce309883c4786c8f96950f6206dff26186fc2b" translate="yes" xml:space="preserve">
          <source>Split a directory specification into the components.</source>
          <target state="translated">디렉토리 스펙을 구성 요소로 분할하십시오.</target>
        </trans-unit>
        <trans-unit id="0e9eed69886886b90fb3afa01fba40f13ff4d0a7" translate="yes" xml:space="preserve">
          <source>Split a package for autoloading</source>
          <target state="translated">자동 로딩을위한 패키지 분할</target>
        </trans-unit>
        <trans-unit id="0a230284c2746978c6d208e00f352e0d6fb5d918" translate="yes" xml:space="preserve">
          <source>Split out from Safe module version 1, named opcode tags and other changes added by Tim Bunce.</source>
          <target state="translated">안전 모듈 버전 1에서 이름이 지정된 opcode 태그와 Tim Bunce에 의해 추가 된 기타 변경 사항에서 분리합니다.</target>
        </trans-unit>
        <trans-unit id="273ddbe310d23df41c94915a842b407f242c4749" translate="yes" xml:space="preserve">
          <source>Splits a path in to volume, directory, and filename portions. On systems with no concept of volume, returns '' for volume.</source>
          <target state="translated">볼륨을 디렉토리, 디렉토리 및 파일 이름 부분으로 분할합니다. 볼륨 개념이없는 시스템에서는 볼륨에 대해 ''를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="334895ed21abe595a625b2f1658f99e01bbe8d40" translate="yes" xml:space="preserve">
          <source>Splits a path into volume, directory, and filename portions.</source>
          <target state="translated">경로를 볼륨, 디렉토리 및 파일 이름 부분으로 분할합니다.</target>
        </trans-unit>
        <trans-unit id="9683042273a4ecd00e523d0bde1551fc4f8c1380" translate="yes" xml:space="preserve">
          <source>Splits a path into volume, directory, and filename portions. Assumes that the last file is a path unless the path ends in '\\', '\\.', '\\..' or $no_file is true. On Win32 this means that $no_file true makes this return ( $volume, $path, '' ).</source>
          <target state="translated">경로를 볼륨, 디렉토리 및 파일 이름 부분으로 분할합니다. 경로가 '\\', '\\.', '\\ ..'또는 $ no_file로 끝나지 않는 한 마지막 파일이 경로라고 가정합니다. Win32에서 이는 $ no_file true가이 리턴 값 ($ volume, $ path, '')을 작성 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="86fed3cc24e2d19645e7064b9a14b47a5f182fe6" translate="yes" xml:space="preserve">
          <source>Splits a path into volume, directory, and filename portions. On systems with no concept of volume, returns '' for volume.</source>
          <target state="translated">경로를 볼륨, 디렉토리 및 파일 이름 부분으로 분할합니다. 볼륨 개념이없는 시스템에서는 볼륨에 대해 ''를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5d39c4c6b066b235387ae82c04d47c7856f6398b" translate="yes" xml:space="preserve">
          <source>Splits the string EXPR into a list of strings and returns the list in list context, or the size of the list in scalar context.</source>
          <target state="translated">문자열 EXPR을 문자열 목록으로 분할하고 목록 컨텍스트의 목록 또는 스칼라 컨텍스트의 목록 크기를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="250f996321b0ccf8a0a091d8ad8d1f0defcbee6b" translate="yes" xml:space="preserve">
          <source>Splitting up a program text into &lt;b&gt;tokens&lt;/b&gt;. Also known as &amp;ldquo;lexing&amp;rdquo;, in which case you get &amp;ldquo;lexemes&amp;rdquo; instead of tokens.</source>
          <target state="translated">프로그램 텍스트를 &lt;b&gt;토큰&lt;/b&gt; 으로 나누기 . &quot;lexing&quot;이라고도하며,이 경우 토큰 대신 &quot;lexemes&quot;가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="785ca9526809c90e3417966be7d5844fd2a0c5c8" translate="yes" xml:space="preserve">
          <source>Stability</source>
          <target state="translated">Stability</target>
        </trans-unit>
        <trans-unit id="699cbcfa1d2de31b511ffab2c2a0ef9730993e7e" translate="yes" xml:space="preserve">
          <source>Stable CPAN modules</source>
          <target state="translated">안정적인 CPAN 모듈</target>
        </trans-unit>
        <trans-unit id="0c37e4671699616f1b661a8adda9cc25f7e7c380" translate="yes" xml:space="preserve">
          <source>Stable modules should maintain backwards compatibility</source>
          <target state="translated">안정적인 모듈은 이전 버전과의 호환성을 유지해야합니다</target>
        </trans-unit>
        <trans-unit id="e59f32f5132f95bd8522cf0423d93b2b074371e3" translate="yes" xml:space="preserve">
          <source>Stack Manipulation Macros</source>
          <target state="translated">스택 조작 매크로</target>
        </trans-unit>
        <trans-unit id="d3f19bccf79868f3c579b95c4b4aa5c3173cdfc2" translate="yes" xml:space="preserve">
          <source>Stack Overflow is a free question-and-answer site for programmers. It's not focussed solely on Perl, but it does have an active group of users who do their best to help people with their Perl programming questions.</source>
          <target state="translated">스택 오버플로는 프로그래머를위한 무료 질의 응답 사이트입니다. Perl에만 초점을 맞추지는 않았지만 Perl 프로그래밍 질문에 사람들을 돕기 위해 최선을 다하는 적극적인 사용자 그룹이 있습니다.</target>
        </trans-unit>
        <trans-unit id="79c0915aad1c8e4662635799d017c78213056099" translate="yes" xml:space="preserve">
          <source>Stack Trace formatting</source>
          <target state="translated">스택 추적 형식</target>
        </trans-unit>
        <trans-unit id="c32c5432806926c51af3a6d722094d1b8498ee67" translate="yes" xml:space="preserve">
          <source>Stack marker variable for the XSUB. See &lt;code&gt;dMARK&lt;/code&gt; .</source>
          <target state="translated">XSUB의 스택 마커 변수 &lt;code&gt;dMARK&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="abb5c52ccc52723cd1612e07bb13d70407d8e476" translate="yes" xml:space="preserve">
          <source>Stack pointer. This is usually handled by &lt;code&gt;xsubpp&lt;/code&gt; . See &lt;code&gt;dSP&lt;/code&gt; and &lt;code&gt;SPAGAIN&lt;/code&gt; .</source>
          <target state="translated">스택 포인터. 이것은 일반적으로 &lt;code&gt;xsubpp&lt;/code&gt; 에 의해 처리됩니다 . &lt;code&gt;dSP&lt;/code&gt; 및 &lt;code&gt;SPAGAIN&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7eeeffb91b556017b0569617dac90bb982af82c6" translate="yes" xml:space="preserve">
          <source>Stack size discussion: &lt;a href=&quot;http://www.perlmonks.org/?node_id=532956&quot;&gt;http://www.perlmonks.org/?node_id=532956&lt;/a&gt;</source>
          <target state="translated">스택 크기 토론 : &lt;a href=&quot;http://www.perlmonks.org/?node_id=532956&quot;&gt;http://www.perlmonks.org/?node_id=532956&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5972ab200f32099d27f68650121e9738cdd0e0dc" translate="yes" xml:space="preserve">
          <source>Standard Exports</source>
          <target state="translated">표준 수출</target>
        </trans-unit>
        <trans-unit id="615e5b98a32ea52bb60f7df7a2666749db3e59ab" translate="yes" xml:space="preserve">
          <source>Standard I/O functions via VMS extensions</source>
          <target state="translated">VMS 확장을 통한 표준 I / O 기능</target>
        </trans-unit>
        <trans-unit id="fbc014247a90e3e9471cd43027f6ed1dd5022323" translate="yes" xml:space="preserve">
          <source>Standard Modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcb1fc559ce28778664dae993a8bd3c9c1e13c04" translate="yes" xml:space="preserve">
          <source>Standard codes for country identification</source>
          <target state="translated">국가 식별을위한 표준 코드</target>
        </trans-unit>
        <trans-unit id="60f2260734e540712fc0b3a84eed77018b10ca66" translate="yes" xml:space="preserve">
          <source>Standard codes for currency identification</source>
          <target state="translated">통화 식별을위한 표준 코드</target>
        </trans-unit>
        <trans-unit id="b5deda2e5280ead9cecc60bbf30d177abf9ec4ea" translate="yes" xml:space="preserve">
          <source>Standard codes for language extension identification</source>
          <target state="translated">언어 확장 식별을위한 표준 코드</target>
        </trans-unit>
        <trans-unit id="f2ee3631bc2f34f1c73413a9d2061ce03c5ab44f" translate="yes" xml:space="preserve">
          <source>Standard codes for language identification</source>
          <target state="translated">언어 식별을위한 표준 코드</target>
        </trans-unit>
        <trans-unit id="10a16afeaf36afe90baa03b4e90894540cc06be0" translate="yes" xml:space="preserve">
          <source>Standard codes for language variation identification</source>
          <target state="translated">언어 변형 식별을위한 표준 코드</target>
        </trans-unit>
        <trans-unit id="b1589d1520251236f9eb362681e4874ce8c5e9ee" translate="yes" xml:space="preserve">
          <source>Standard codes for script identification</source>
          <target state="translated">스크립트 식별을위한 표준 코드</target>
        </trans-unit>
        <trans-unit id="5d6d11511a070bcf17fa4eb2391ebf6e7a493c05" translate="yes" xml:space="preserve">
          <source>Standard modules with VMS-specific differences</source>
          <target state="translated">VMS 관련 차이점이있는 표준 모듈</target>
        </trans-unit>
        <trans-unit id="de92c20ac3781f514b3f3e2c2c6d7cf3cd1b6af8" translate="yes" xml:space="preserve">
          <source>Standard, bundled modules are all expected to behave in a well-defined manner with respect to namespace pollution because they use the Exporter module. See their own documentation for details.</source>
          <target state="translated">표준 번들 모듈은 모두 내보내기 모듈을 사용하기 때문에 네임 스페이스 오염과 관련하여 잘 정의 된 방식으로 작동합니다. 자세한 내용은 자체 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8e0bc2ae4e7dee6efa427af24dac0f51946576f0" translate="yes" xml:space="preserve">
          <source>StandardizedVariants.txt</source>
          <target state="translated">StandardizedVariants.txt</target>
        </trans-unit>
        <trans-unit id="07142f93c49bc59a674f3cf54cfc45c16742e4f3" translate="yes" xml:space="preserve">
          <source>Stands for &amp;ldquo;Database Management&amp;rdquo; routines, a set of routines that emulate an &lt;b&gt;associative array&lt;/b&gt; using disk files. The routines use a dynamic hashing scheme to locate any entry with only two disk accesses. DBM files allow a Perl program to keep a persistent &lt;b&gt;hash&lt;/b&gt; across multiple invocations. You can &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; your hash variables to various DBM implementations.</source>
          <target state="translated">디스크 파일을 사용하여 &lt;b&gt;연관 배열&lt;/b&gt; 을 에뮬레이트하는 루틴 세트 인 &quot;데이터베이스 관리&quot;루틴을 나타냅니다 . 루틴은 동적 해싱 구성표를 사용하여 두 개의 디스크 액세스 만있는 항목을 찾습니다. DBM 파일을 사용하면 Perl 프로그램이 여러 호출 에서 지속적 &lt;b&gt;해시&lt;/b&gt; 를 유지할 수 있습니다. 당신은 할 수 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 여러 DBM 구현에 해시 변수를.</target>
        </trans-unit>
        <trans-unit id="32e3debe4cf1141c3184e11a9dc572fab1423447" translate="yes" xml:space="preserve">
          <source>Start position and no-match optimisations</source>
          <target state="translated">시작 위치 및 불일치 최적화</target>
        </trans-unit>
        <trans-unit id="db76cc0f3f883ec9a2ed91694d94f4588b9f7245" translate="yes" xml:space="preserve">
          <source>Start up an interval timer: after a certain time, a signal ($which) arrives, and more signals may keep arriving at certain intervals. To disable an &quot;itimer&quot;, use &lt;code&gt;$floating_seconds&lt;/code&gt; of zero. If the &lt;code&gt;$interval_floating_seconds&lt;/code&gt; is set to zero (or unspecified), the timer is disabled &lt;b&gt;after&lt;/b&gt; the next delivered signal.</source>
          <target state="translated">인터벌 타이머를 시작합니다. 특정 시간이 지나면 신호 ($ which)가 도착하고 더 많은 신호가 특정 간격으로 계속 도착할 수 있습니다. &quot;itimer&quot;를 비활성화하려면 &lt;code&gt;$floating_seconds&lt;/code&gt; 의 0을 사용하십시오. 는 IF &lt;code&gt;$interval_floating_seconds&lt;/code&gt; 제로 (또는 지정)로 설정, 타이머가 비활성화되어 &lt;b&gt;후&lt;/b&gt; 다음 전달 된 신호.</target>
        </trans-unit>
        <trans-unit id="bf54d336f01982c7f36b58a5973054d7f918d05e" translate="yes" xml:space="preserve">
          <source>Start with a dummy run of h2xs:</source>
          <target state="translated">h2xs의 더미 실행으로 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="8d112be587c3b58ec2b08ad08b5f28537f049d9b" translate="yes" xml:space="preserve">
          <source>Start with single-step on.</source>
          <target state="translated">단일 단계부터 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="8332767a94ccaf8b2674f5e407c13b8594261e03" translate="yes" xml:space="preserve">
          <source>Start with the first letter in the string 'a'.</source>
          <target state="translated">문자열 'a'의 첫 글자로 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="be46870dc50c93db69a63c772d7b331eea2b204f" translate="yes" xml:space="preserve">
          <source>Start with the first letter in the string 't'.</source>
          <target state="translated">문자열 't'의 첫 글자로 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="e5189aa41c41bf90fef351656e01e6473fbaf249" translate="yes" xml:space="preserve">
          <source>Start your Perl program</source>
          <target state="translated">Perl 프로그램을 시작하십시오</target>
        </trans-unit>
        <trans-unit id="9f05ee38f1d8c4b639d2c05f6f7cb39a8f63ba62" translate="yes" xml:space="preserve">
          <source>Start-tokens from Pod::Simple::PullParser</source>
          <target state="translated">Pod :: Simple :: PullParser의 시작 토큰</target>
        </trans-unit>
        <trans-unit id="bba3dd50f7eb62963e78abd741a6ecb84d7e0e92" translate="yes" xml:space="preserve">
          <source>Starting From Scratch</source>
          <target state="translated">스크래치에서 시작</target>
        </trans-unit>
        <trans-unit id="d9722acfd050423d2f793d245909513d9f792a51" translate="yes" xml:space="preserve">
          <source>Starting OS/2 (and DOS) programs under Perl</source>
          <target state="translated">Perl에서 OS / 2 (및 DOS) 프로그램 시작</target>
        </trans-unit>
        <trans-unit id="6a454cb163d40a3be765256333ed856099e340c6" translate="yes" xml:space="preserve">
          <source>Starting Perl in the VMS debugger may change the program execution profile in a way that such problems are not reproduced.</source>
          <target state="translated">VMS 디버거에서 Perl을 시작하면 이러한 문제가 재현되지 않는 방식으로 프로그램 실행 프로파일이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61b2b3d56b228f00035d9baf98e67307d761a53f" translate="yes" xml:space="preserve">
          <source>Starting Perl programs under AmigaOS</source>
          <target state="translated">AmigaOS에서 Perl 프로그램 시작</target>
        </trans-unit>
        <trans-unit id="c712909317e062b2443119b81f61884099ac7f3f" translate="yes" xml:space="preserve">
          <source>Starting Perl programs under OS/2 (and DOS and...)</source>
          <target state="translated">OS / 2 (및 DOS 및 ...)에서 Perl 프로그램 시작</target>
        </trans-unit>
        <trans-unit id="653f89b4c2f41c0d0134c806e923d3709fc205d1" translate="yes" xml:space="preserve">
          <source>Starting from IO::Zlib version 1.02, IO::Zlib can also use an external</source>
          <target state="translated">IO :: Zlib 버전 1.02부터 IO :: Zlib는 외부를 사용할 수도 있습니다</target>
        </trans-unit>
        <trans-unit id="a508a2e273548a63bb5c0b07719e420fe300b9fd" translate="yes" xml:space="preserve">
          <source>Starting from OS/400 V5R2 the IBM Visual Age compiler is supported on OS/400 PASE, so it is possible to build Perl natively on OS/400. The easier way, however, is to compile in AIX, as just described.</source>
          <target state="translated">OS / 400 V5R2부터 IBM Visual Age 컴파일러는 OS / 400 PASE에서 지원되므로 OS / 400에서 기본적으로 Perl을 빌드 할 수 있습니다. 그러나 가장 쉬운 방법은 방금 설명한대로 AIX에서 컴파일하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5e473385f5209d49f3d6236a23d69b61072e12c5" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.10.1 (well, 5.10.0, but it didn't work right), you can say</source>
          <target state="translated">Perl 5.10.1부터 (5.10.0이지만 제대로 작동하지 않음) 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="213483245e12096ac5558b413cc608887022de0d" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.6 Perl has had some level of multibyte character support. Perl 5.8 or later is recommended. Supported multibyte character repertoires include Unicode, and legacy encodings through the Encode module. See &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;, &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;, and &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;.</source>
          <target state="translated">Perl 5.6부터 Perl은 일정 수준의 멀티 바이트 문자를 지원했습니다. Perl 5.8 이상이 권장됩니다. 지원되는 멀티 바이트 문자 레퍼토리에는 유니 코드 및 인코딩 모듈을 통한 레거시 인코딩이 포함됩니다. &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt; , &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; 및 &lt;a href=&quot;encode&quot;&gt;Encode를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f3401e5a549f724e4569e770d48d8137b822e30b" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.7.2 (and consequently 5.8.x / 5.10.x / 5.12.x) and AIX 4.3 or newer Perl uses the AIX native dynamic loading interface in the so called runtime linking mode instead of the emulated interface that was used in Perl releases 5.6.1 and earlier or, for AIX releases 4.2 and earlier. This change does break backward compatibility with compiled modules from earlier Perl releases. The change was made to make Perl more compliant with other applications like Apache/mod_perl which are using the AIX native interface. This change also enables the use of C++ code with static constructors and destructors in Perl extensions, which was not possible using the emulated interface.</source>
          <target state="translated">Perl 5.7.2 (및 결과적으로 5.8.x / 5.10.x / 5.12.x)부터 AIX 4.3 이상은 Perl에서 사용 된 에뮬레이트 된 인터페이스 대신 런타임 링크 모드에서 AIX 기본 동적로드 인터페이스를 사용합니다. Perl 릴리스 5.6.1 이하 또는 AIX 릴리스 4.2 이하. 이 변경은 이전 Perl 릴리스에서 컴파일 된 모듈과의 호환성을 손상시킵니다. Perl이 AIX 기본 인터페이스를 사용하는 Apache / mod_perl과 같은 다른 응용 프로그램과 호환되도록 변경되었습니다. 이 변경은 또한 Perl 확장에서 정적 생성자와 소멸자와 함께 C ++ 코드를 사용할 수있게했으며 에뮬레이트 된 인터페이스로는 불가능했습니다.</target>
        </trans-unit>
        <trans-unit id="25d510ae8cee14025ed8b7521c9e7b4803c6e585" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.8 Filter::Util::Call (the core part of the Source Filters distribution) is part of the standard Perl distribution. Also included is a friendlier interface called Filter::Simple, by Damian Conway.</source>
          <target state="translated">Perl 5.8부터 시작 Filter :: Util :: Call (소스 필터 배포의 핵심 부분)은 표준 Perl 배포의 일부입니다. Damian Conway의 Filter :: Simple이라는 친숙한 인터페이스도 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="84131be03444ffa9bfcdc4607ace523b2b4abf69" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.8 you can use the standard module Encode to translate from EBCDIC to Latin-1 code points. Encode knows about more EBCDIC character sets than Perl can currently be compiled to run on.</source>
          <target state="translated">Perl 5.8부터 표준 모듈 Encode를 사용하여 EBCDIC에서 Latin-1 코드 포인트로 변환 할 수 있습니다. Encode는 Perl이 현재 실행되도록 컴파일 할 수있는 것보다 많은 EBCDIC 문자 세트에 대해 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="b494835e5e76badb9fdcdcf6ee9b4a757213c9dc" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.8, a source filter module, &lt;code&gt;Switch&lt;/code&gt; , can also be used to get switch and case. Its use is now discouraged, because it's not fully compatible with the native switch of Perl 5.10, and because, as it's implemented as a source filter, it doesn't always work as intended when complex syntax is involved.</source>
          <target state="translated">Perl 5.8부터 소스 필터 모듈 인 &lt;code&gt;Switch&lt;/code&gt; 를 사용하여 스위치와 케이스를 얻을 수도 있습니다. Perl 5.10의 기본 스위치와 완전히 호환되지 않으므로 소스 필터로 구현되므로 복잡한 구문이 필요할 때 항상 의도 한대로 작동하지 않기 때문에 사용을 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a6f4302390c39dc69e8bb4ae56d84681737deb52" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.8, in C/C++ level Perl knows how to wrap system/library interfaces that have thread-aware versions (e.g. getpwent_r()) into frontend macros (e.g. getpwent()) that correctly handle the multithreaded interaction with the Perl interpreter. This will happen transparently, the only thing you need to do is to instantiate a Perl interpreter.</source>
          <target state="translated">Perl 5.8부터 C / C ++ 레벨에서 Perl은 스레드 인식 버전 (예 : getpwent_r ())이있는 시스템 / 라이브러리 인터페이스를 Perl 인터프리터와의 다중 스레드 상호 작용을 올바르게 처리하는 프론트 엔드 매크로 (예 : getpwent ())로 랩핑하는 방법을 알고 있습니다. . 이것은 투명하게 일어날 것입니다. Perl 인터프리터를 인스턴스화하는 것이 유일한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="d0ecdc5671ad43a21bb3ba4b49951928dc27fb67" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.8.1 different runs of Perl will have different ordering of hash keys. The change was done for greater security, see &lt;a href=&quot;../perlsec#Algorithmic-Complexity-Attacks&quot;&gt;Algorithmic Complexity Attacks in perlsec&lt;/a&gt;. This means that different runs of Perl will have different Data::Dumper outputs if the data contains hashes. If you need to have identical Data::Dumper outputs from different runs of Perl, use the environment variable PERL_HASH_SEED, see &lt;a href=&quot;../perlrun#PERL_HASH_SEED&quot;&gt;PERL_HASH_SEED in perlrun&lt;/a&gt;. Using this restores the old (platform-specific) ordering: an even prettier solution might be to use the &lt;code&gt;Sortkeys&lt;/code&gt; filter of Data::Dumper.</source>
          <target state="translated">Perl 5.8.1부터 다른 Perl 실행은 다른 순서의 해시 키를 갖습니다. 보안 강화를 위해 변경되었습니다 . &lt;a href=&quot;../perlsec#Algorithmic-Complexity-Attacks&quot;&gt;perlsec의 알고리즘 복잡성 공격을&lt;/a&gt; 참조하십시오 . 이는 데이터에 해시가 포함 된 경우 다른 Perl 실행에서 다른 Data :: Dumper 출력을 갖게됨을 의미합니다. 다른 Perl 실행에서 동일한 Data :: Dumper 출력이 필요한 경우 환경 변수 PERL_HASH_SEED를 사용하십시오 ( &lt;a href=&quot;../perlrun#PERL_HASH_SEED&quot;&gt;perlrun의 PERL_HASH_SEED&lt;/a&gt; 참조) . 이를 사용하면 기존 (플랫폼 별) 순서가 복원됩니다. 더 좋은 솔루션 은 Data :: Dumper 의 &lt;code&gt;Sortkeys&lt;/code&gt; 필터 를 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="54b73ef5c7c43845a94f049a96a2982af7951ff5" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.9.4 the following extra flags are added:</source>
          <target state="translated">Perl 5.9.4부터 다음과 같은 추가 플래그가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="d0f3b9a37d935e7c453cae03a9fc889658a8b375" translate="yes" xml:space="preserve">
          <source>Starting from Perl v5.6.0, Perl has had the capacity to handle Unicode natively. Perl v5.8.0, however, is the first recommended release for serious Unicode work. The maintenance release 5.6.1 fixed many of the problems of the initial Unicode implementation, but for example regular expressions still do not work with Unicode in 5.6.1. Perl v5.14.0 is the first release where Unicode support is (almost) seamlessly integrable without some gotchas (the exception being some differences in &lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;, and that is fixed starting in Perl 5.16.0). To enable this seamless support, you should &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; (which is automatically selected if you &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; or higher). See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;. (5.14 also fixes a number of bugs and departures from the Unicode standard.)</source>
          <target state="translated">Perl v5.6.0부터 Perl은 기본적으로 유니 코드를 처리 할 수 ​​있습니다. 그러나 Perl v5.8.0은 심각한 유니 코드 작업에 권장되는 첫 번째 릴리스입니다. 유지 관리 릴리스 5.6.1은 초기 유니 코드 구현의 많은 문제를 해결했지만 예를 들어 5.6.1의 정규식은 여전히 ​​유니 코드에서 작동하지 않습니다. 펄 v5.14.0 몇 개는 (예외는 일부 차이없이 원활 적분 유니 코드 지원이 (거의) 인 제 릴리스 &lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt; , 그 펄 5.16.0부터 고정된다). 이 원활한 지원을 활성화하려면 다음을 수행해야 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; (당신이 경우 자동으로 선택되어 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; 이상). &lt;a href=&quot;feature&quot;&gt;기능&lt;/a&gt; 참조. (5.14는 또한 많은 버그를 수정하고 유니 코드 표준에서 벗어났습니다.)</target>
        </trans-unit>
        <trans-unit id="416a20fa36c19a41cf13089d9b7e6cda76a07463" translate="yes" xml:space="preserve">
          <source>Starting from perl 5.7.1 perl uses the Solaris malloc, since the perl malloc breaks when dealing with more than 2GB of memory, and the Solaris malloc also seems to be faster.</source>
          <target state="translated">perl 5.7.1부터 perl은 2GB 이상의 메모리를 처리 할 때 perl malloc이 중단되고 Solaris malloc도 더 빠르기 때문에 Solaris malloc을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e6f60ae2145b9aa31e782db73fe39a61dbb6b373" translate="yes" xml:space="preserve">
          <source>Starting from the beginning of the input string, each 8-tuple of characters is converted to 1 character of output. With format &lt;code&gt;b&lt;/code&gt; , the first character of the 8-tuple determines the least-significant bit of a character; with format &lt;code&gt;B&lt;/code&gt; , it determines the most-significant bit of a character.</source>
          <target state="translated">입력 문자열의 시작 부분부터 각 8- 튜플 문자는 1 문자 출력으로 변환됩니다. 형식 &lt;code&gt;b&lt;/code&gt; 로 , 8- 튜플의 첫번째 문자는 문자의 최하위 비트를 결정합니다. &lt;code&gt;B&lt;/code&gt; 형식 을 사용하면 문자의 가장 중요한 비트를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="bca54402551e7931f104cb3acd73bb3d87fc7a43" translate="yes" xml:space="preserve">
          <source>Starting from the beginning of the template to pack(), each pair of characters is converted to 1 character of output. With format &lt;code&gt;h&lt;/code&gt; , the first character of the pair determines the least-significant nybble of the output character; with format &lt;code&gt;H&lt;/code&gt; , it determines the most-significant nybble.</source>
          <target state="translated">템플릿의 처음부터 pack ()까지, 각 문자 쌍은 1 문자 출력으로 변환됩니다. &lt;code&gt;h&lt;/code&gt; 형식 으로, 쌍의 첫 번째 문자는 출력 문자의 최하위 니블을 결정합니다. 형식 &lt;code&gt;H&lt;/code&gt; 로 가장 중요한 니블을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="e0719e57793beb804762734f954a0430e8236ad0" translate="yes" xml:space="preserve">
          <source>Starting from the top, this says &lt;code&gt;$b&lt;/code&gt; is an SV. The scalar is an IV, which is capable of holding an integer or reference value. It has the &lt;code&gt;ROK&lt;/code&gt; flag set, meaning it is a reference (rather than an integer or string). Notice that Dump follows the reference and shows us what &lt;code&gt;$b&lt;/code&gt; was referencing. We see the same &lt;code&gt;$a&lt;/code&gt; that we found in the previous example.</source>
          <target state="translated">위에서부터 &lt;code&gt;$b&lt;/code&gt; 는 SV입니다. 스칼라는 정수 또는 참조 값을 보유 할 수있는 IV입니다. 이것은 보유 &lt;code&gt;ROK&lt;/code&gt; 이 기준 (아닌 정수 나 문자열)이며 즉, 플래그가 설정. Dump가 참조를 따르고 &lt;code&gt;$b&lt;/code&gt; 가 참조한 것을 보여줍니다 . 앞의 예에서 찾은 것과 동일한 &lt;code&gt;$a&lt;/code&gt; 를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0542c0de06c1b01762ccd40a6fe67b90b3556cde" translate="yes" xml:space="preserve">
          <source>Starting from version 5.8, Perl uses a builtin translation layer for text-mode files. This replaces the efficient well-tested EMX layer by some code which should be best characterized as a &quot;quick hack&quot;.</source>
          <target state="translated">버전 5.8부터 Perl은 텍스트 모드 파일에 내장 변환 레이어를 사용합니다. 이것은 효율적이고 잘 테스트 된 EMX 계층을 &quot;빠른 핵&quot;으로 가장 잘 특징 지워야하는 코드로 대체합니다.</target>
        </trans-unit>
        <trans-unit id="ac77222ae2e654fdac46266902dcc915cb8e811b" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.12.0, &lt;code&gt;\N&lt;/code&gt; also can have an additional meaning (only) in patterns, namely to match a non-newline character. (This is short for &lt;code&gt;[^\n]&lt;/code&gt;, and like &lt;code&gt;.&lt;/code&gt; but is not affected by the &lt;code&gt;/s&lt;/code&gt; regex modifier.)</source>
          <target state="translated">Perl 5.12.0부터, &lt;code&gt;\N&lt;/code&gt; 은 또한 개행 문자와 일치하는 패턴에서 추가 의미 (단지)를 가질 수 있습니다. (이것에 대한 짧은 &lt;code&gt;[^\n]&lt;/code&gt; , 및 등 &lt;code&gt;.&lt;/code&gt; 하지만 영향을받지 않는다 &lt;code&gt;/s&lt;/code&gt; 정규식 개질제).</target>
        </trans-unit>
        <trans-unit id="2859a2d886c0e9aec6c1de9465ceff2207dfb72a" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.14 (and partially in Perl 5.12), just put a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; near the beginning of your program. Within its lexical scope you shouldn't have this problem. It also is automatically enabled under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature ':5.12'&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.12&lt;/code&gt; or using &lt;code&gt;-E&lt;/code&gt; on the command line for Perl 5.12 or higher.</source>
          <target state="translated">Perl 5.14 (및 부분적으로 Perl 5.12) 부터는 프로그램 시작 부분에 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하십시오. 어휘 범위 내에서이 문제가 발생하지 않아야합니다. 또한 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature ':5.12'&lt;/code&gt; 에서 자동으로 활성화 되거나 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.12&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하거나 Perl 5.12 이상의 명령 행에서 &lt;code&gt;-E&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="a8902a856b5fd88514da38f6d1ea437cef45dc91" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.14, a &lt;code&gt;&quot;^&quot;&lt;/code&gt; (caret or circumflex accent) immediately after the &lt;code&gt;&quot;?&quot;&lt;/code&gt; is a shorthand equivalent to &lt;code&gt;d-imsx&lt;/code&gt; . Any positive flags (except &lt;code&gt;&quot;d&quot;&lt;/code&gt; ) may follow the caret, so</source>
          <target state="translated">Perl 5.14부터 &lt;code&gt;&quot;?&quot;&lt;/code&gt; 바로 다음에 &lt;code&gt;&quot;^&quot;&lt;/code&gt; (캐럿 또는 곡절 악센트)가 있습니까? &lt;code&gt;d-imsx&lt;/code&gt; 와 같은 속기 입니다. 모든 양수 플래그 ( &lt;code&gt;&quot;d&quot;&lt;/code&gt; 제외 )는 캐럿을 따를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd982f589d8e87c6c46ce3117db1a952a4a3a29e" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.14, a &lt;code&gt;&quot;^&quot;&lt;/code&gt; (caret or circumflex accent) immediately after the &lt;code&gt;&quot;?&quot;&lt;/code&gt; is a shorthand equivalent to &lt;code&gt;d-imsx&lt;/code&gt; . Flags (except &lt;code&gt;&quot;d&quot;&lt;/code&gt; ) may follow the caret to override it. But a minus sign is not legal with it.</source>
          <target state="translated">Perl 5.14부터 &lt;code&gt;&quot;?&quot;&lt;/code&gt; 바로 다음에 &lt;code&gt;&quot;^&quot;&lt;/code&gt; (캐럿 또는 곡절 악센트)가 있습니까? &lt;code&gt;d-imsx&lt;/code&gt; 와 같은 속기 입니다. 플래그 ( &lt;code&gt;&quot;d&quot;&lt;/code&gt; 제외 )는 캐럿을 따라 재정의 할 수 있습니다. 그러나 빼기 기호는 합법적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f8764da9a2d4e197710fd50d36bbe6c6ef6a3ac9" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.14.0, regular expressions compiled within the scope of &lt;code&gt;unicode_strings&lt;/code&gt; use Unicode rules even when executed or compiled into larger regular expressions outside the scope.</source>
          <target state="translated">Perl 5.14.0부터 &lt;code&gt;unicode_strings&lt;/code&gt; 범위 내에서 컴파일 된 정규식은 범위 외부에서 더 큰 정규 표현식으로 실행되거나 컴파일 될 때에도 유니 코드 규칙을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="69cd047e088fdbefa20b4fff4c70feeb8034d880" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.16.0, consistent quoting rules are used within the scope of &lt;code&gt;unicode_strings&lt;/code&gt; , as described in &lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;. Prior to that, or outside its scope, no code points above 127 are quoted in UTF-8 encoded strings, but in byte encoded strings, code points between 128-255 are always quoted.</source>
          <target state="translated">Perl 5.16.0부터는 &lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta에&lt;/a&gt; 설명 된대로 &lt;code&gt;unicode_strings&lt;/code&gt; 범위 내에서 일관된 인용 규칙이 사용됩니다 . 그 전에 또는 범위를 벗어나면 127을 초과하는 코드 포인트는 UTF-8로 인코딩 된 문자열로 인용되지 않지만 바이트로 인코딩 된 문자열에서는 128-255 사이의 코드 포인트가 항상 인용됩니다.</target>
        </trans-unit>
        <trans-unit id="4f8e157579b8bab3ccd61e698c935bfec29a8f08" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.20, a hash slice operation with the % symbol is a variant of slice operation returning a list of key/value pairs rather than just values:</source>
          <target state="translated">Perl 5.20부터 % 기호가있는 해시 슬라이스 작업은 값이 아닌 키 / 값 쌍의 목록을 반환하는 슬라이스 작업의 변형입니다.</target>
        </trans-unit>
        <trans-unit id="013197011e87f7e0633670e8b800c1024b759400" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.16 in a very limited way, and more generally in v5.22, you can restrict which category or categories are enabled by this particular instance of the pragma by adding parameters to it. For example,</source>
          <target state="translated">Perl v5.16부터는 매우 제한적인 방식으로 시작하고보다 일반적으로 v5.22에서는 매개 변수를 추가하여 pragma의 특정 인스턴스에서 사용 가능한 카테고리를 제한 할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="d7be757a62548668bef82e6fa7932eb10efddb3b" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.16, Perl adopted a Unicode-defined strategy for quoting non-ASCII characters; the quoting of ASCII characters is unchanged.</source>
          <target state="translated">Perl v5.16부터 Perl은 비 ASCII 문자를 인용하기 위해 유니 코드 정의 전략을 채택했습니다. ASCII 문자의 인용은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a75aca801899de40f1e5f4fc3d561cb6af7bcdc4" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.16, any occurrence of &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt; sequences in a double-quotish string automatically loads this module with arguments &lt;code&gt;:full&lt;/code&gt; and &lt;code&gt;:short&lt;/code&gt; (described below) if it hasn't already been loaded with different arguments, in order to compile the named Unicode character into position in the string. Prior to v5.16, an explicit &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; charnames&lt;/code&gt; was required to enable this usage. (However, prior to v5.16, the form &lt;code&gt;&quot;use
charnames ();&quot;&lt;/code&gt; did not enable &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt;.)</source>
          <target state="translated">Perl v5.16부터 큰 따옴표로 묶인 문자열에서 &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt; 시퀀스가 발생 하면 다른 인수와 함께 아직로드되지 않은 경우 &lt;code&gt;:full&lt;/code&gt; 및 &lt;code&gt;:short&lt;/code&gt; (아래 설명) 인수로이 모듈을 자동으로로드합니다 . 명명 된 유니 코드 문자를 문자열의 위치로 컴파일합니다. 이전 v5.16로, 명시 적으로 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; charnames&lt;/code&gt; 이 사용을 활성화하는 데 필요한되었다. 그러나 v5.16 이전에는 &lt;code&gt;&quot;use charnames ();&quot;&lt;/code&gt; 형식으로 &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt; 활성화하지 않았습니다 .)</target>
        </trans-unit>
        <trans-unit id="bc88b853a6a300ebebd43ce48839b53ca6b33945" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.20, UTF-8 locales are supported in Perl, except for &lt;code&gt;LC_COLLATE&lt;/code&gt; (use &lt;a href=&quot;unicode/collate&quot;&gt;Unicode::Collate&lt;/a&gt; instead). If you have Perl v5.16 or v5.18 and can't upgrade, you can use</source>
          <target state="translated">Perl v5.20부터 &lt;code&gt;LC_COLLATE&lt;/code&gt; 를 제외하고 UTF-8 로케일이 Perl에서 지원됩니다 ( 대신 &lt;a href=&quot;unicode/collate&quot;&gt;Unicode :: Collate&lt;/a&gt; 사용). Perl v5.16 또는 v5.18이 있고 업그레이드 할 수없는 경우</target>
        </trans-unit>
        <trans-unit id="24c20bca7982b6c0163573088c845daca9bc60e3" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.22, this applies to ranges in bracketed character classes. If you say, for example, &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/[\N{U+20}-\N{U+7F}]/&lt;/a&gt;&lt;/code&gt;, it means the characters &lt;code&gt;\N{U+20}&lt;/code&gt; , &lt;code&gt;\N{U+21}&lt;/code&gt; , ..., &lt;code&gt;\N{U+7F}&lt;/code&gt; . This range is all the printable characters that the ASCII character set contains.</source>
          <target state="translated">Perl v5.22부터는 대괄호 문자 클래스의 범위에 적용됩니다. 예를 들어 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/[\N{U+20}-\N{U+7F}]/&lt;/a&gt;&lt;/code&gt; 라고하면 &lt;code&gt;\N{U+20}&lt;/code&gt; , &lt;code&gt;\N{U+21}&lt;/code&gt; , .. ., &lt;code&gt;\N{U+7F}&lt;/code&gt; . 이 범위는 ASCII 문자 세트에 포함 된 모든 인쇄 가능한 문자입니다.</target>
        </trans-unit>
        <trans-unit id="b23b660058cb3ee939b11052749bad9b7526e31f" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.22, this is trivially changeable to work portably on both ASCII and EBCDIC platforms.</source>
          <target state="translated">Perl v5.22부터는 ASCII 및 EBCDIC 플랫폼 모두에서 이식 가능하도록 간단하게 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e38118c6920f78946e8d31e17cb36ad4ee8bf0e" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.8.6 (&lt;code&gt;Encode&lt;/code&gt; version 2.0.1),</source>
          <target state="translated">Perl v5.8.6 ( &lt;code&gt;Encode&lt;/code&gt; 버전 2.0.1)부터</target>
        </trans-unit>
        <trans-unit id="474e1944b6ecbc8a507bc2e01a2a550b04aa62eb" translate="yes" xml:space="preserve">
          <source>Starting in Unicode 6.1 and Perl v5.16, Unicode defines many abbreviations and names that were formerly Perl extensions, and some additional ones that Perl did not previously accept. The list is getting too long to reproduce here, but you can get the complete list from the Unicode web site: &lt;a href=&quot;http://www.unicode.org/Public/UNIDATA/NameAliases.txt&quot;&gt;http://www.unicode.org/Public/UNIDATA/NameAliases.txt&lt;/a&gt;.</source>
          <target state="translated">유니 코드 6.1 및 Perl v5.16부터 유니 코드는 이전에 Perl 확장이었던 많은 약어 및 이름과 Perl이 이전에 승인하지 않은 추가 약어를 정의합니다. 목록을 여기에 재현하기에는 시간이 너무 오래 걸리지 만 유니 코드 웹 사이트 ( &lt;a href=&quot;http://www.unicode.org/Public/UNIDATA/NameAliases.txt&quot;&gt;http://www.unicode.org/Public/UNIDATA/NameAliases.txt)&lt;/a&gt; 에서 전체 목록을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="818df47ef2f0fcf2a87de97f12babb967ed1fcfb" translate="yes" xml:space="preserve">
          <source>Starting in v5.20, Perl supports UTF-8 locales for &lt;code&gt;LC_CTYPE&lt;/code&gt; , but otherwise Perl only supports single-byte locales, such as the ISO 8859 series. This means that wide character locales, for example for Asian languages, are not well-supported. (If the platform has the capability for Perl to detect such a locale, starting in Perl v5.22, &lt;a href=&quot;warnings#Category-Hierarchy&quot;&gt;Perl will warn, default enabled&lt;/a&gt;, using the &lt;code&gt;locale&lt;/code&gt; warning category, whenever such a locale is switched into.) The UTF-8 locale support is actually a superset of POSIX locales, because it is really full Unicode behavior as if no &lt;code&gt;LC_CTYPE&lt;/code&gt; locale were in effect at all (except for tainting; see &lt;a href=&quot;#SECURITY&quot;&gt;SECURITY&lt;/a&gt;). POSIX locales, even UTF-8 ones, are lacking certain concepts in Unicode, such as the idea that changing the case of a character could expand to be more than one character. Perl in a UTF-8 locale, will give you that expansion. Prior to v5.20, Perl treated a UTF-8 locale on some platforms like an ISO 8859-1 one, with some restrictions, and on other platforms more like the &quot;C&quot; locale. For releases v5.16 and v5.18, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale 'not_characters&lt;/code&gt; could be used as a workaround for this (see &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;Unicode and UTF-8&lt;/a&gt;).</source>
          <target state="translated">v5.20부터 Perl은 &lt;code&gt;LC_CTYPE&lt;/code&gt; 에 대해 UTF-8 로케일을 지원하지만 그렇지 않으면 Perl은 ISO 8859 시리즈와 같은 1 바이트 로케일 만 지원합니다. 이것은 예를 들어 아시아 언어와 같은 넓은 문자 로케일이 잘 지원되지 않음을 의미합니다. 플랫폼에 Perl v5.22부터 &lt;a href=&quot;warnings#Category-Hierarchy&quot;&gt;Perl이&lt;/a&gt; 이러한 로케일을 감지하는 기능이있는 경우 Perl은 로케일이 전환 될 때마다 &lt;code&gt;locale&lt;/code&gt; 경고 카테고리를 사용하여 기본적으로 경고를 설정 합니다. UTF-8 로케일 지원 &lt;code&gt;LC_CTYPE&lt;/code&gt; 로케일이 전혀 유효하지 않은 것처럼 실제로 완전한 유니 코드 동작이기 때문에 실제로 POSIX 로케일의 상위 세트입니다 (오염을 제외하고; &lt;a href=&quot;#SECURITY&quot;&gt;SECURITY&lt;/a&gt; 참조).). POSIX 로케일, 심지어 UTF-8 로케일에는 문자 대소 문자 변경이 두 개 이상의 문자로 확장 될 수 있다는 아이디어와 같이 유니 코드의 특정 개념이 부족합니다. UTF-8 로케일의 Perl은 확장을 제공합니다. v5.20 이전에 Perl은 ISO 8859-1과 같은 일부 플랫폼에서 일부 제한 사항이 있고 &quot;C&quot;로케일과 같은 다른 플랫폼에서 UTF-8 로케일을 처리했습니다. 릴리스 v5.16 및 v5.18의 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale 'not_characters&lt;/code&gt; 사용하여 이에 대한 임시 해결책으로 사용할 수 있습니다 ( &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;유니 코드 및 UTF-8 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="7c0b3fbd50ff716e496a38d1dbfc0634c6a5772b" translate="yes" xml:space="preserve">
          <source>Starting in v5.20, Perl uses full Unicode rules if the locale is UTF-8. Otherwise, there is a deficiency in this scheme, which is that case changes that cross the 255/256 boundary are not well-defined. For example, the lower case of LATIN CAPITAL LETTER SHARP S (U+1E9E) in Unicode rules is U+00DF (on ASCII platforms). But under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (prior to v5.20 or not a UTF-8 locale), the lower case of U+1E9E is itself, because 0xDF may not be LATIN SMALL LETTER SHARP S in the current locale, and Perl has no way of knowing if that character even exists in the locale, much less what code point it is. Perl returns a result that is above 255 (almost always the input character unchanged, for all instances (and there aren't many) where the 255/256 boundary would otherwise be crossed; and starting in v5.22, it raises a &lt;a href=&quot;perldiag#Can't-do-%25s(%22%25s%22)-on-non-UTF-8-locale%3b-resolved-to-%22%25s%22.&quot;&gt;locale&lt;/a&gt; warning.</source>
          <target state="translated">로케일이 UTF-8 인 경우 v5.20부터 Perl은 완전한 유니 코드 규칙을 사용합니다. 그렇지 않으면이 체계에 결함이 있으며,이 경우 255/256 경계를 넘는 변경 사항은 잘 정의되지 않습니다. 예를 들어, 유니 코드 규칙에서 소문자 대문자 대문자 SHARP S (U + 1E9E)는 U + 00DF (ASCII 플랫폼의 경우)입니다. 그러나 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (v5.20 이전 또는 UTF-8 로케일이 아님) U + 1E9E의 소문자는 현재 로케일에서 0xDF가 작은 문자 샤프 S가 아닐 수 있으며 Perl이 해당 문자를 알 수있는 방법이 없기 때문에 로케일에도 존재하며 코드 포인트가 훨씬 적습니다. Perl은 255/256 경계가 교차되는 모든 인스턴스에 대해 거의 항상 입력 문자가 변경되지 않고 255보다 큰 결과를 반환하며 v5.22부터는 &lt;a href=&quot;perldiag#Can't-do-%25s(%22%25s%22)-on-non-UTF-8-locale%3b-resolved-to-%22%25s%22.&quot;&gt;로케일&lt;/a&gt; 경고를 발생 시킵니다. .</target>
        </trans-unit>
        <trans-unit id="cf1eee1ccf148c85a77132cb28b023038cea490f" translate="yes" xml:space="preserve">
          <source>Starting in v5.20, Perl uses full Unicode rules if the locale is UTF-8. Otherwise, there is a deficiency in this scheme, which is that case changes that cross the 255/256 boundary are not well-defined. For example, the lower case of LATIN CAPITAL LETTER SHARP S (U+1E9E) in Unicode rules is U+00DF (on ASCII platforms). But under &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (prior to v5.20 or not a UTF-8 locale), the lower case of U+1E9E is itself, because 0xDF may not be LATIN SMALL LETTER SHARP S in the current locale, and Perl has no way of knowing if that character even exists in the locale, much less what code point it is. Perl returns a result that is above 255 (almost always the input character unchanged, for all instances (and there aren't many) where the 255/256 boundary would otherwise be crossed; and starting in v5.22, it raises a &lt;a href=&quot;../perldiag#Can't-do-%25s(%22%25s%22)-on-non-UTF-8-locale%3b-resolved-to-%22%25s%22.&quot;&gt;locale&lt;/a&gt; warning.</source>
          <target state="translated">로케일이 UTF-8 인 경우 v5.20부터 Perl은 완전한 유니 코드 규칙을 사용합니다. 그렇지 않으면이 체계에 결함이 있으며,이 경우 255/256 경계를 넘는 변경 사항은 잘 정의되지 않습니다. 예를 들어, 유니 코드 규칙에서 소문자 대문자 대문자 SHARP S (U + 1E9E)는 U + 00DF (ASCII 플랫폼의 경우)입니다. 그러나 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (v5.20 이전 또는 UTF-8 로케일이 아님) U + 1E9E의 소문자는 현재 로케일에서 0xDF가 작은 문자 샤프 S가 아닐 수 있으며 Perl이 해당 문자를 알 수있는 방법이 없기 때문에 로케일에도 존재하며 코드 포인트가 훨씬 적습니다. Perl은 255/256 경계가 교차되는 모든 인스턴스에 대해 거의 항상 입력 문자가 변경되지 않고 255보다 큰 결과를 반환하며 v5.22부터는 &lt;a href=&quot;../perldiag#Can't-do-%25s(%22%25s%22)-on-non-UTF-8-locale%3b-resolved-to-%22%25s%22.&quot;&gt;로케일&lt;/a&gt; 경고를 발생 시킵니다. .</target>
        </trans-unit>
        <trans-unit id="2c762f587a88d06d3ee0d5c6c5c66f9e2aa3c2b6" translate="yes" xml:space="preserve">
          <source>Starting in v5.22, Perl will by default warn when switching into a locale that redefines any ASCII printable character (plus &lt;code&gt;\t&lt;/code&gt; and &lt;code&gt;\n&lt;/code&gt; ) into a different class than expected. This is likely to happen on modern locales only on EBCDIC platforms, where, for example, a CCSID 0037 locale on a CCSID 1047 machine moves &lt;code&gt;&quot;[&quot;&lt;/code&gt; , but it can happen on ASCII platforms with the ISO 646 and other 7-bit locales that are essentially obsolete. Things may still work, depending on what features of Perl are used by the program. For example, in the example from above where &lt;code&gt;&quot;|&quot;&lt;/code&gt; becomes a &lt;code&gt;\w&lt;/code&gt; , and there are no regular expressions where this matters, the program may still work properly. The warning lists all the characters that it can determine could be adversely affected.</source>
          <target state="translated">v5.22부터는 Perl은 ASCII 인쇄 가능 문자 (및 &lt;code&gt;\t&lt;/code&gt; 및 &lt;code&gt;\n&lt;/code&gt; )를 예상과 다른 클래스로 재정의하는 로케일로 전환 할 때 기본적으로 경고 합니다. 이는 예를 들어 CCSID 1047 시스템의 CCSID 0037 로케일이 &lt;code&gt;&quot;[&quot;&lt;/code&gt; 이동하는 EBCDIC 플랫폼의 최신 로케일에서만 발생하지만 ISO 646 및 기타 7 비트 로케일이있는 ASCII 플랫폼에서 발생할 수 있습니다. 본질적으로 더 이상 사용되지 않습니다. 프로그램에서 사용되는 Perl의 기능에 따라 여전히 작동 할 수 있습니다. 예를 들어 위의 예에서 &lt;code&gt;&quot;|&quot;&lt;/code&gt; &lt;code&gt;\w&lt;/code&gt; 가된다이 문제가 발생하면 정규 표현식이 없어도 프로그램이 여전히 제대로 작동 할 수 있습니다. 경고에는 부정적인 영향을 줄 수있는 모든 문자가 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="30ce7d231c27d2be8f1b1d8928ca5c39bf4aed51" translate="yes" xml:space="preserve">
          <source>Starting in v5.22, you can use Unicode code points as the end points of regular expression pattern character ranges, and the range will include all Unicode code points that lie between those end points, inclusive.</source>
          <target state="translated">v5.22부터는 정규 표현식 패턴 문자 범위의 끝점으로 유니 코드 코드 포인트를 사용할 수 있으며 범위에는 해당 엔드 포인트 사이에있는 모든 유니 코드 코드 포인트가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="3cd5e5803935bbb6537a6c17faa83c7fdd9ffba0" translate="yes" xml:space="preserve">
          <source>Starting in v5.8.6, the encoding name may be &lt;code&gt;:locale&lt;/code&gt; . This means that the encoding is taken from the current locale, and not hard-coded by the pragma. Since a script really can only be encoded in exactly one encoding, this option is dangerous. It makes sense only if the script itself is written in ASCII, and all the possible locales that will be in use when the script is executed are supersets of ASCII. That means that the script itself doesn't get changed, but the I/O handles have the specified encoding added, and the operations like &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; use that encoding.</source>
          <target state="translated">v5.8.6부터 인코딩 이름은 &lt;code&gt;:locale&lt;/code&gt; 일 수 있습니다 . 이는 인코딩이 현재 로케일에서 가져오고 pragma에 의해 하드 코딩되지 않았 음을 의미합니다. 스크립트는 실제로 정확히 하나의 인코딩으로 만 인코딩 될 수 있으므로이 옵션은 위험합니다. 스크립트 자체가 ASCII로 작성된 경우에만 의미가 있으며, 스크립트를 실행할 때 사용할 수있는 모든 로케일은 ASCII의 슈퍼 세트입니다. 즉, 스크립트 자체는 변경되지 않지만 I / O 핸들에 지정된 인코딩이 추가되었으며 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; 와 같은 작업이 해당 인코딩을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f8eb72d81f87d6a7a0f9e91198c8aa2adc48dbed" translate="yes" xml:space="preserve">
          <source>Starting in version 5.21.2, perls built with the experimental define &lt;code&gt;-DPERL_OP_PARENT&lt;/code&gt; add an extra boolean flag for each op, &lt;code&gt;op_moresib&lt;/code&gt; . When not set, this indicates that this is the last op in an &lt;code&gt;OpSIBLING&lt;/code&gt; chain. This frees up the &lt;code&gt;op_sibling&lt;/code&gt; field on the last sibling to point back to the parent op. Under this build, that field is also renamed &lt;code&gt;op_sibparent&lt;/code&gt; to reflect its joint role. The macro &lt;code&gt;OpSIBLING(o)&lt;/code&gt; wraps this special behaviour, and always returns NULL on the last sibling. With this build the &lt;code&gt;op_parent(o)&lt;/code&gt; function can be used to find the parent of any op. Thus for forward compatibility, you should always use the &lt;code&gt;OpSIBLING(o)&lt;/code&gt; macro rather than accessing &lt;code&gt;op_sibling&lt;/code&gt; directly.</source>
          <target state="translated">버전 5.21.2 년부터 실험로 구축 perls 정의 &lt;code&gt;-DPERL_OP_PARENT&lt;/code&gt; 각 연산에 대한 추가에게 별도의 부울 플래그를 &lt;code&gt;op_moresib&lt;/code&gt; . 설정되지 않은 경우 &lt;code&gt;OpSIBLING&lt;/code&gt; 체인 의 마지막 op임을 나타냅니다 . 그러면 마지막 형제 에서 &lt;code&gt;op_sibling&lt;/code&gt; 필드가 해제되어 상위 op를 다시 가리 킵니다. 이 빌드에서는 해당 필드의 이름이 &lt;code&gt;op_sibparent&lt;/code&gt; 로 바뀌어 공동 역할을 반영합니다. 매크로 &lt;code&gt;OpSIBLING(o)&lt;/code&gt; 이 특수한 동작을 래핑하고 항상 마지막 형제에서 NULL을 반환합니다. 이 빌드에서는 &lt;code&gt;op_parent(o)&lt;/code&gt; 함수를 사용하여 모든 op의 부모를 찾을 수 있습니다. 따라서 호환성을 위해 항상 &lt;code&gt;OpSIBLING(o)&lt;/code&gt; 사용해야합니다직접 &lt;code&gt;op_sibling&lt;/code&gt; 에 액세스하는 대신 매크로 .</target>
        </trans-unit>
        <trans-unit id="6641cb9032ef109574e28893d667801fcaa3e2c6" translate="yes" xml:space="preserve">
          <source>Starting with 2.10, the special module name &lt;code&gt;Unicode&lt;/code&gt; refers to the version of the Unicode Character Database bundled with Perl.</source>
          <target state="translated">2.10부터 특수 모듈 이름 &lt;code&gt;Unicode&lt;/code&gt; 는 Perl과 함께 번들로 제공되는 유니 코드 문자 데이터베이스의 버전을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="aca846c8be32988d259af2e704c9972784ca9b87" translate="yes" xml:space="preserve">
          <source>Starting with AutoLoader 5.73, you can call the &lt;code&gt;AutoLoader::autoload_sub&lt;/code&gt; function with the fully-qualified name of the function to load from its</source>
          <target state="translated">AutoLoader 5.73부터는 &lt;code&gt;AutoLoader::autoload_sub&lt;/code&gt; 함수를 호출하여 정규화 된 함수 이름으로로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe6dc30d7e458c682ee2ffab73f38deab13b705d" translate="yes" xml:space="preserve">
          <source>Starting with ExtUtils::ParseXS version 3.13_01 (comes with perl 5.16 and better), it is rather easy to share typemap code between multiple CPAN distributions. The general idea is to share it as a module that offers a certain API and have the dependent modules declare that as a built-time requirement and import the typemap into the XS. An example of such a typemap-sharing module on CPAN is &lt;code&gt;ExtUtils::Typemaps::Basic&lt;/code&gt; . Two steps to getting that module's typemaps available in your code:</source>
          <target state="translated">ExtUtils :: ParseXS 버전 3.13_01부터 (perl 5.16 이상이 제공됨) 여러 CPAN 배포간에 유형 맵 코드를 공유하는 것이 다소 쉽습니다. 일반적인 아이디어는 특정 API를 제공하는 모듈로 공유하고 종속 모듈이이를 빌드 요구 사항으로 선언하고 XS로 유형 맵을 가져 오는 것입니다. CPAN에서 이러한 유형 맵 공유 모듈의 예는 &lt;code&gt;ExtUtils::Typemaps::Basic&lt;/code&gt; 입니다. 코드에서 해당 모듈의 타입 맵을 사용할 수있게하는 두 단계 :</target>
        </trans-unit>
        <trans-unit id="f9212af4220a7c7e6998749dd4723a25f0d7eab4" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.10, &lt;a href=&quot;time/piece&quot;&gt;Time::Piece&lt;/a&gt; and &lt;a href=&quot;time/seconds&quot;&gt;Time::Seconds&lt;/a&gt; are part of the standard distribution, so you might think that you could do something like this:</source>
          <target state="translated">Perl 5.10부터 &lt;a href=&quot;time/piece&quot;&gt;Time :: Piece&lt;/a&gt; 및 &lt;a href=&quot;time/seconds&quot;&gt;Time :: Seconds&lt;/a&gt; 는 표준 배포판의 일부이므로 다음과 같이 할 수 있다고 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97eea9254558fb3fd8f17c44c41b369b3648d850" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.10.0, integer and floating-point formats, along with the &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; formats and &lt;code&gt;()&lt;/code&gt; groups, may all be followed by the &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&lt;/code&gt; endianness modifiers to respectively enforce big- or little-endian byte-order. These modifiers are especially useful given how &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; , and &lt;code&gt;V&lt;/code&gt; don't cover signed integers, 64-bit integers, or floating-point values.</source>
          <target state="translated">Perl 5.10.0부터는 &lt;code&gt;p&lt;/code&gt; 및 &lt;code&gt;P&lt;/code&gt; 형식 및 &lt;code&gt;()&lt;/code&gt; 그룹 과 함께 정수 및 부동 소수점 형식 에 각각 &lt;code&gt;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;&lt;/code&gt; 엔디안 수정자를 사용하여 각각 빅 또는 리틀 엔디안 바이트 순서를 적용 할 수 있습니다. 이러한 수정자는 &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; 및 &lt;code&gt;V&lt;/code&gt; 가 부호있는 정수, 64 비트 정수 또는 부동 소수점 값을 다루지 않는 방법에 특히 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="2ee36782903bc57420ba5e155b45524572f22583" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.12, &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; can handle dates past 03:14:08 January 19, 2038, when a 32-bit based time would overflow. You still might get a warning on a 32-bit &lt;code&gt;perl&lt;/code&gt; :</source>
          <target state="translated">Perl 5.12부터 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; 은 32 비트 기반 시간이 오버플로되는 2038 년 1 월 19 일 03:14:08 이후의 날짜를 처리 할 수 ​​있습니다. 여전히 32 비트 &lt;code&gt;perl&lt;/code&gt; 에 경고가 표시 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3547c4def41d12fec193f972e11bcb976215d4c4" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.12, an additional integer parameter will be passed. It will be zero if &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; is called without parameter; &lt;code&gt;1&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; is given a filehandle as a parameter, e.g. &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(FH)&lt;/a&gt;&lt;/code&gt;; and &lt;code&gt;2&lt;/code&gt; in the very special case that the tied filehandle is &lt;code&gt;ARGV&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; is called with an empty parameter list, e.g. &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Perl 5.12부터 추가 정수 매개 변수가 전달됩니다. 매개 변수없이 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 를 호출 하면 0이됩니다 . &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 에 파일 핸들이 매개 변수로 제공되는 경우 &lt;code&gt;1&lt;/code&gt; , 예 : &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(FH)&lt;/a&gt;&lt;/code&gt; ; 그리고 &lt;code&gt;2&lt;/code&gt; 동점 파일 핸들이있는 아주 특별한 경우 &lt;code&gt;ARGV&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 예를 들어, 빈 매개 변수 목록 불려 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3385173ff54b55e840ed45e4ab6e0da31d97fba8" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14 a parent will not wait() automatically for any child that has been signalled with &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;('TERM', ...)&lt;/code&gt; to avoid a deadlock in case the child is blocking on I/O and never receives the signal.</source>
          <target state="translated">Perl 5.14부터는 부모가 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;('TERM', ...)&lt;/code&gt; 신호를받은 아이가 I / O를 차단하고 신호를받지 못하는 경우 교착 상태를 피하기 위해 자동으로 대기하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="90de3712cf0c49e19f3e9d37735c0e97d4b521ae" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed hash or array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">5.14 펄부터 &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 저주받은 해시 또는 어레이에 대한 레퍼런스를 보유해야 스칼라 EXPR를 취할 수있다. 인수는 자동으로 역 참조됩니다. &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 이러한 측면은 매우 실험적인 것으로 간주됩니다. 정확한 동작은 향후 버전의 Perl에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="818e24d28a7aaf2cbc1a6702710734a070d06698" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed hash or array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">5.14 펄부터 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 저주받은 해시 또는 어레이에 대한 레퍼런스를 보유해야 스칼라 EXPR를 취할 수있다. 인수는 자동으로 역 참조됩니다. &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 이러한 측면은 매우 실험적인 것으로 간주됩니다. 정확한 동작은 향후 버전의 Perl에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72fa5cd516760576150d0418affb48e1abda4a5b" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must contain a reference to an unblessed hash or array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Perl 5.14부터 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 는 스칼라 EXPR을 취할 수 있으며, 여기에는 축복되지 않은 해시 또는 배열에 대한 참조가 포함되어야합니다. 인수는 자동으로 역 참조됩니다. &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 이러한 측면은 매우 실험적인 것으로 간주됩니다. 정확한 동작은 향후 버전의 Perl에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2b92aff600824b9c22651f1e75f3d65c35db8ae" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Perl 5.14부터 &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; 은 스칼라 EXPR을 취할 수 있으며, 이는 축복되지 않은 배열에 대한 참조를 보유해야합니다. 인수는 자동으로 역 참조됩니다. &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; 이러한 측면은 매우 실험적인 것으로 간주됩니다. 정확한 동작은 향후 버전의 Perl에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07bb8994fa6804d1b79f779661eabab22fa4d596" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Perl 5.14부터 &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; 는 스칼라 EXPR을 취할 수 있으며, 이는 축복되지 않은 배열에 대한 참조를 보유해야합니다. 인수는 자동으로 역 참조됩니다. &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; 이러한 측면은 매우 실험적인 것으로 간주됩니다. 정확한 동작은 향후 버전의 Perl에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10642e156a8402673021a377c62441722a9d8a63" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Perl 5.14부터 &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 는 스칼라 EXPR을 취할 수 있으며, 이는 축복되지 않은 배열에 대한 참조를 보유해야합니다. 인수는 자동으로 역 참조됩니다. 이러한 &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 측면은 매우 실험적인 것으로 간주됩니다. 정확한 동작은 향후 버전의 Perl에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5169411fd5bf69d929b67dfac03c2c64e43db230" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; can take scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Perl 5.14부터 &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; 는 스칼라 EXPR을 취할 수 있으며, 이는 축복되지 않은 배열에 대한 참조를 보유해야합니다. 인수는 자동으로 역 참조됩니다. &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; 이러한 측면은 매우 실험적인 것으로 간주됩니다. 정확한 동작은 향후 버전의 Perl에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7439a015aa95224d62eb3bbca9a133f540e69f0f" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Perl 5.14부터 &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; 는 스칼라 EXPR을 취할 수 있으며, 이는 축복되지 않은 배열에 대한 참조를 보유해야합니다. 인수는 자동으로 역 참조됩니다. &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; 이러한 측면은 매우 실험적인 것으로 간주됩니다. 정확한 동작은 향후 버전의 Perl에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23e76a783b752b5dc19b6f3c4b3d934de488d5e6" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed hash or array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Perl 5.14부터 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 은 스칼라 EXPR을 취할 수 있으며 ,이 값 은 축복되지 않은 해시 또는 배열에 대한 참조를 보유해야합니다. 인수는 자동으로 역 참조됩니다. &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 이러한 측면은 매우 실험적인 것으로 간주됩니다. 정확한 동작은 향후 버전의 Perl에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47398b3574f050221d9d55302c39ea94e67781b9" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must contain a reference to an unblessed hash or array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Perl 5.14부터 &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 는 스칼라 EXPR을 취할 수 있으며, 여기에는 축복되지 않은 해시 또는 배열에 대한 참조가 포함되어야합니다. 인수는 자동으로 역 참조됩니다. &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 이러한 측면은 매우 실험적인 것으로 간주됩니다. 정확한 동작은 향후 버전의 Perl에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fac0b7eb35a23345be196afebeca8562c183fce3" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Perl 5.14부터 &lt;code&gt;&lt;a href=&quot;pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; 은 스칼라 EXPR을 취할 수 있으며, 이는 축복되지 않은 배열에 대한 참조를 보유해야합니다. 인수는 자동으로 역 참조됩니다. &lt;code&gt;&lt;a href=&quot;pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; 이러한 측면은 매우 실험적인 것으로 간주됩니다. 정확한 동작은 향후 버전의 Perl에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="427fc5d0e35cec380d803ece997f22ba459e7c3c" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Perl 5.14부터 &lt;code&gt;&lt;a href=&quot;push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; 는 스칼라 EXPR을 취할 수 있으며, 이는 축복되지 않은 배열에 대한 참조를 보유해야합니다. 인수는 자동으로 역 참조됩니다. &lt;code&gt;&lt;a href=&quot;push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; 이러한 측면은 매우 실험적인 것으로 간주됩니다. 정확한 동작은 향후 버전의 Perl에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0a12ea19c52c77b676bcf9fb786b8629096b3dc" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Perl 5.14부터 &lt;code&gt;&lt;a href=&quot;shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 는 스칼라 EXPR을 취할 수 있으며, 이는 축복되지 않은 배열에 대한 참조를 보유해야합니다. 인수는 자동으로 역 참조됩니다. 이러한 &lt;code&gt;&lt;a href=&quot;shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 측면은 매우 실험적인 것으로 간주됩니다. 정확한 동작은 향후 버전의 Perl에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3217cf42c0331e4a0cfa6eb7dd493042a8c7e44" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; can take scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Perl 5.14부터 &lt;code&gt;&lt;a href=&quot;splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; 는 스칼라 EXPR을 취할 수 있으며, 이는 축복되지 않은 배열에 대한 참조를 보유해야합니다. 인수는 자동으로 역 참조됩니다. &lt;code&gt;&lt;a href=&quot;splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; 이러한 측면은 매우 실험적인 것으로 간주됩니다. 정확한 동작은 향후 버전의 Perl에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0f153998e2fa782a330b974d3d6a495fc8735ee" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Perl 5.14부터 &lt;code&gt;&lt;a href=&quot;unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; 는 스칼라 EXPR을 취할 수 있으며, 이는 축복되지 않은 배열에 대한 참조를 보유해야합니다. 인수는 자동으로 역 참조됩니다. &lt;code&gt;&lt;a href=&quot;unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; 이러한 측면은 매우 실험적인 것으로 간주됩니다. 정확한 동작은 향후 버전의 Perl에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3eb26fa45077fda36157e3c2cd25a74327fbf5e" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed hash or array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">Perl 5.14부터 &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 은 스칼라 EXPR을 취할 수 있으며 ,이 값 은 축복되지 않은 해시 또는 배열에 대한 참조를 보유해야합니다. 인수는 자동으로 역 참조됩니다. &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 이러한 측면은 매우 실험적인 것으로 간주됩니다. 정확한 동작은 향후 버전의 Perl에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84114b43a4e1c51016947fa39587027a5c42b337" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.16, you can embed typemaps into your XS code instead of or in addition to typemaps in a separate file. Multiple such embedded typemaps will be processed in order of appearance in the XS code and like local typemap files take precedence over the default typemap, the embedded typemaps may overwrite previous definitions of TYPEMAP, INPUT, and OUTPUT stanzas. The syntax for embedded typemaps is</source>
          <target state="translated">Perl 5.16부터는 유형 맵 대신 또는 별도의 파일에 유형 맵을 추가하여 XS 코드에 유형 맵을 포함시킬 수 있습니다. XS 코드에서는 이러한 여러 내장 된 유형 맵이 순서대로 처리되며 로컬 유형 맵 파일이 기본 유형 맵보다 우선하므로 내장 된 유형 맵은 TYPEMAP, INPUT 및 OUTPUT 스탠자의 이전 정의를 겹쳐 쓸 수 있습니다. 임베디드 타입 맵의 문법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ead2268f227644c92e6fae21c9b2bbc1c3977d01" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.8, a macro framework has been defined to allow static data to be safely stored in XS modules that will be accessed from a multi-threaded Perl.</source>
          <target state="translated">Perl 5.8부터는 멀티 스레드 Perl에서 액세스 할 XS 모듈에 정적 데이터를 안전하게 저장할 수 있도록 매크로 프레임 워크가 정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="83f897274d9417a81431b1cfc87771e6f6b3c937" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.8.1 strict is strict about its restrictions: if unknown restrictions are used, the strict pragma will abort with</source>
          <target state="translated">Perl 5.8.1부터 엄격은 제한 사항에 대해 엄격합니다. 알 수없는 제한이 사용되면 엄격한 pragma가 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="4c86c42abf281eff02c433a98ecba5908f6fea66" translate="yes" xml:space="preserve">
          <source>Starting with Solaris 8, perl5.00503 (or higher) is supplied with the operating system, so you might not even need to build a newer version of perl at all. The Sun-supplied version is installed in /usr/perl5 with</source>
          <target state="translated">Solaris 8부터는 perl5.00503 (이상)이 운영 체제와 함께 제공되므로 새로운 버전의 perl을 전혀 구축하지 않아도됩니다. Sun에서 제공 한 버전은 / usr / perl5에</target>
        </trans-unit>
        <trans-unit id="070cbbea94d8e9dec2f41e08f125528dd6a6e9b2" translate="yes" xml:space="preserve">
          <source>Starting with Tiger (Mac OS X 10.4), Apple shipped broken locale files for the eu_ES locale (Basque-Spain). In previous releases of Perl, this resulted in failures in the</source>
          <target state="translated">Tiger (Mac OS X 10.4)부터 Apple은 eu_ES 로켈 (Basque-Spain)에 대한 깨진 로켈 파일을 제공했습니다. 이전 버전의 Perl에서는 이로 인해 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="0811928afaca739fa817229f5f4a0d0397bc7c2a" translate="yes" xml:space="preserve">
          <source>Starting with release 1.23_03, Scalar-List-Util is &lt;b&gt;always&lt;/b&gt; using the XS implementation, but for backwards compatibility, we still ship the &lt;code&gt;List::Util::XS&lt;/code&gt; module which just loads &lt;code&gt;List::Util&lt;/code&gt; .</source>
          <target state="translated">릴리스 1.23_03부터 스칼라 목록 - 백분율입니다 &lt;b&gt;항상&lt;/b&gt; XS를 구현을 사용하지만, 이전 버전과의 호환성을 위해, 우리는 여전히 발송 &lt;code&gt;List::Util::XS&lt;/code&gt; 단지로드 모듈 &lt;code&gt;List::Util&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f31afb43ed5a01839f8ddc750e5dd35f48c3a6c" translate="yes" xml:space="preserve">
          <source>Starting with this section, we will be discussing Perl's set of</source>
          <target state="translated">이 섹션부터는 Perl의</target>
        </trans-unit>
        <trans-unit id="8ef231992030ec09e2d04d1b4b88e1196c802a84" translate="yes" xml:space="preserve">
          <source>Starting with version 2.x, Berkeley DB has internal support for locking. The companion module to this one, &lt;b&gt;BerkeleyDB&lt;/b&gt;, provides an interface to this locking functionality. If you are serious about locking Berkeley DB databases, I strongly recommend using &lt;b&gt;BerkeleyDB&lt;/b&gt;.</source>
          <target state="translated">버전 2.x부터 Berkeley DB는 내부 잠금을 지원합니다. 이것에 대한 동반 모듈 인 &lt;b&gt;BerkeleyDB&lt;/b&gt; 는이 잠금 기능에 대한 인터페이스를 제공합니다. 당신은 버클리 DB 데이터베이스를 잠금에 관하여 심각한 경우에, 나는 강력하게 사용하는 것이 좋습니다 &lt;b&gt;버클리을&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="6f6299a2f62ed0797f2e4ca75150d013801fc49f" translate="yes" xml:space="preserve">
          <source>Starts a try block. See &lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;Exception Handling in perlguts&lt;/a&gt;.</source>
          <target state="translated">try 블록을 시작합니다. &lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;perlguts의 예외 처리를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="79ce33706ca0540aaf9d8ed291d64bf45fad0cd4" translate="yes" xml:space="preserve">
          <source>Startup</source>
          <target state="translated">Startup</target>
        </trans-unit>
        <trans-unit id="6991439e4716de488447c6e2c2f9b1970b90a8e3" translate="yes" xml:space="preserve">
          <source>Stashes and Globs</source>
          <target state="translated">스 태쉬와 글로브</target>
        </trans-unit>
        <trans-unit id="acf91ec4328cf0ba3defd8522962fa33e41a1740" translate="yes" xml:space="preserve">
          <source>State storage for the &lt;code&gt;prove&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;prove&lt;/code&gt; 명령을 위한 상태 저장소 .</target>
        </trans-unit>
        <trans-unit id="ed2cb72d0aaac69d6842c67515cf3bf802a6b33a" translate="yes" xml:space="preserve">
          <source>Statement Modifiers</source>
          <target state="translated">명령문 수정 자</target>
        </trans-unit>
        <trans-unit id="1ddbc09b1ca4e7855762d5787c6c0d7a3595a8af" translate="yes" xml:space="preserve">
          <source>Static Linking of a new Perl Binary</source>
          <target state="translated">새로운 Perl 바이너리의 정적 링크</target>
        </trans-unit>
        <trans-unit id="3c5f15db40f98d51818ecdf0034d37509667528b" translate="yes" xml:space="preserve">
          <source>Static functions might not be visible for the backtrace.</source>
          <target state="translated">역 추적에 정적 기능이 보이지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f8ab9355e9f77bfc04d09779d25ce6944605b91" translate="yes" xml:space="preserve">
          <source>Statistics about downloads are truncated by size and period simultaneously.</source>
          <target state="translated">다운로드 통계는 크기와 기간에 따라 동시에 잘립니다.</target>
        </trans-unit>
        <trans-unit id="5610cd01f9a3d6080e798d67334a100aa1573c90" translate="yes" xml:space="preserve">
          <source>Status 1 overrides status 2. If you want unambiguous results, call &lt;b&gt;podchecker&lt;/b&gt; with one single argument only.</source>
          <target state="translated">상태 1은 상태 2보다 우선합니다. 명확한 결과를 원하면 하나의 인수만으로 &lt;b&gt;podchecker&lt;/b&gt; 를 호출 &lt;b&gt;하십시오&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="187236d960db5eb4ad8363cf8f2f9b1ddb6ac5e1" translate="yes" xml:space="preserve">
          <source>Stdio class buffering options.</source>
          <target state="translated">Stdio 클래스 버퍼링 옵션.</target>
        </trans-unit>
        <trans-unit id="60a9d23beb62cbe40cee43c7f38898ee6c1f97c7" translate="yes" xml:space="preserve">
          <source>Steffen Mueller &amp;lt;smueller@cpan.org&amp;gt;</source>
          <target state="translated">스테 펜 뮬러 &amp;lt;smueller@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="c982c59dd847ba297d8467bd252ba58dd872a85c" translate="yes" xml:space="preserve">
          <source>Steffen Mueller, &amp;lt;smueller@cpan.org&amp;gt;</source>
          <target state="translated">Steffen Mueller, &amp;lt;smueller@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="67aeabbbe7f975f118f5118824dfb5a83bb31c11" translate="yes" xml:space="preserve">
          <source>Step-by-step: Distributing your module</source>
          <target state="translated">단계별 : 모듈 배포</target>
        </trans-unit>
        <trans-unit id="1a565c4552b2edcc3b1a58d76fe5018ccb0e6a32" translate="yes" xml:space="preserve">
          <source>Step-by-step: Making the module</source>
          <target state="translated">단계별 : 모듈 만들기</target>
        </trans-unit>
        <trans-unit id="481a4d002beceae3935eab8245f4c76879540359" translate="yes" xml:space="preserve">
          <source>Step-by-step: Preparing the ground</source>
          <target state="translated">단계별 : 지상 준비</target>
        </trans-unit>
        <trans-unit id="80427e23cbb5abd94ca5e55445014873b52c64b8" translate="yes" xml:space="preserve">
          <source>Stephen McCamant &amp;lt;smcc@CSUA.Berkeley.EDU&amp;gt;, based on an earlier version by Malcolm Beattie &amp;lt;mbeattie@sable.ox.ac.uk&amp;gt;, with contributions from Gisle Aas, James Duncan, Albert Dvornik, Robin Houston, Dave Mitchell, Hugo van der Sanden, Gurusamy Sarathy, Nick Ing-Simmons, and Rafael Garcia-Suarez.</source>
          <target state="translated">Malcolm Beattie &amp;lt;mbeattie@sable.ox.ac.uk&amp;gt;의 이전 버전을 기반으로 한 Stephen McCamant &amp;lt;smcc@CSUA.Berkeley.EDU&amp;gt;, Gisle Aas, James Duncan, Albert Dvornik, Robin Houston, Dave Mitchell, Hugo van der Sanden, Gurusamy Sarathy, Nick Ing-Simmons 및 Rafael Garcia-Suarez.</target>
        </trans-unit>
        <trans-unit id="6a244b340bceacb4b7643a7f28401322b0f43369" translate="yes" xml:space="preserve">
          <source>Stephen McCamant, &amp;lt;smcc@CSUA.Berkeley.EDU&amp;gt;.</source>
          <target state="translated">Stephen McCamant, &amp;lt;smcc@CSUA.Berkeley.EDU&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="406bdac466755debe16970475ad1ba98d0b486e3" translate="yes" xml:space="preserve">
          <source>Stepping through code</source>
          <target state="translated">코드 스테핑</target>
        </trans-unit>
        <trans-unit id="f13a1be70942b94ceb5c4947f5cad9efec256df0" translate="yes" xml:space="preserve">
          <source>Steps through the program a line at a time, without descending into functions.</source>
          <target state="translated">함수로 내려 가지 않고 한 번에 한 줄씩 프로그램을 진행합니다.</target>
        </trans-unit>
        <trans-unit id="67e08e5dee051e0626b0f262d208037e870d3ac2" translate="yes" xml:space="preserve">
          <source>Steps through the program a line at a time.</source>
          <target state="translated">한 번에 한 줄씩 프로그램을 단계별로 진행합니다.</target>
        </trans-unit>
        <trans-unit id="f18c11d1612cf243a4188b75a5a32a4030b759d2" translate="yes" xml:space="preserve">
          <source>Steve Hay &amp;lt;</source>
          <target state="translated">스티브 헤이 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="9d16db78589f14f29e83bbd762e7ffb3c9579828" translate="yes" xml:space="preserve">
          <source>Steve Lembark goes through the details in his YAPC::NA 2009 talk &quot;Perly Linked Lists&quot; ( &lt;a href=&quot;http://www.slideshare.net/lembark/perly-linked-lists&quot;&gt;http://www.slideshare.net/lembark/perly-linked-lists&lt;/a&gt; ), although you can just use his &lt;a href=&quot;http://search.cpan.org/perldoc/LinkedList::Single&quot;&gt;LinkedList::Single&lt;/a&gt; module.</source>
          <target state="translated">Steve Lembark는 자신의 YAPC :: NA 2009 talk &quot;Perly Linked Lists&quot;( &lt;a href=&quot;http://www.slideshare.net/lembark/perly-linked-lists&quot;&gt;http://www.slideshare.net/lembark/perly-linked-lists&lt;/a&gt; ) 에서 세부 사항을 살펴 봅니다. 그의 &lt;a href=&quot;http://search.cpan.org/perldoc/LinkedList::Single&quot;&gt;LinkedList :: Single&lt;/a&gt; 모듈 만 사용할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="09652192134371fdefcd293d5003ff83e32ed6ed" translate="yes" xml:space="preserve">
          <source>Steve Peters &amp;lt;steve@fisharerojo.org&amp;gt;</source>
          <target state="translated">스티브 피터스 &amp;lt;steve@fisharerojo.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7d6ea163d8063bfc57b0256f3178b768eac364c1" translate="yes" xml:space="preserve">
          <source>Steve Purkis</source>
          <target state="translated">스티브 퍼 키스</target>
        </trans-unit>
        <trans-unit id="9efb7766602083380f01f9cadb6f278fbfabf5e5" translate="yes" xml:space="preserve">
          <source>Steve Purkis &amp;lt;spurkis@cpan.org&amp;gt;</source>
          <target state="translated">스티브 퍼 키스 &amp;lt;spurkis@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="2200943829d703ee08a178c2eb1eee2c0a806988" translate="yes" xml:space="preserve">
          <source>Steve Purkis.</source>
          <target state="translated">스티브 퍼 키스.</target>
        </trans-unit>
        <trans-unit id="270c172269bbb0672801106f89223f66575337c6" translate="yes" xml:space="preserve">
          <source>Steven McDougall &amp;lt;swmcd@world.std.com&amp;gt; for his help and patience with re-writing this manpage.</source>
          <target state="translated">이 맨 페이지를 다시 작성하는 데 도움과 인내심을 갖고있는 Steven McDougall &amp;lt;swmcd@world.std.com&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="3a70ee5e8fb61558310f5b5e31b73a3d007c0de0" translate="yes" xml:space="preserve">
          <source>Still another problem is that this approach can lead to two code points meaning the same character. Thus in a Greek locale, both U+03A7 and U+00D7 are GREEK CAPITAL LETTER CHI.</source>
          <target state="translated">또 다른 문제점은이 접근법이 동일한 문자를 의미하는 두 개의 코드 포인트로 이어질 수 있다는 것입니다. 따라서 그리스어 로케일에서 U + 03A7과 U + 00D7은 모두 녹색 대문자입니다.</target>
        </trans-unit>
        <trans-unit id="72bc7a84f86b7c98bba879166a64bc5b045625fd" translate="yes" xml:space="preserve">
          <source>Stops running tests as &quot;TODO&quot; tests. This method is fatal if called without a preceding &lt;code&gt;todo_start&lt;/code&gt; method call.</source>
          <target state="translated">&quot;TODO&quot;테스트로 테스트 실행을 중지합니다. 이 &lt;code&gt;todo_start&lt;/code&gt; 메소드 호출 없이 호출되면이 메소드는 치명적 입니다.</target>
        </trans-unit>
        <trans-unit id="45b0f8b6273dfd6e7997a4038c99b48d40e17dae" translate="yes" xml:space="preserve">
          <source>Storable</source>
          <target state="translated">Storable</target>
        </trans-unit>
        <trans-unit id="46f9f6e335231e1456d3ba18bd5a505213eb74c6" translate="yes" xml:space="preserve">
          <source>Storable - persistence for Perl data structures</source>
          <target state="translated">저장 가능-Perl 데이터 구조에 대한 지속성</target>
        </trans-unit>
        <trans-unit id="1630856d50b3ec9af87960aa33400ccd3dc094bd" translate="yes" xml:space="preserve">
          <source>Storable has now been changed to write out and read in a file header with information about the size of integers. It's impossible to detect whether an old file being read in was written with 32 or 64 bit integers (they have the same header) so it's impossible to automatically switch to a correct backwards compatibility mode. Hence this Storable defaults to the new, correct behaviour.</source>
          <target state="translated">Storable은 이제 정수 크기에 대한 정보가있는 파일 헤더에서 읽고 쓰도록 변경되었습니다. 읽히는 오래된 파일이 32 또는 64 비트 정수 (동일한 헤더를 가짐)로 쓰여 졌는지 감지 할 수 없으므로 올바른 하위 호환성 모드로 자동 전환 할 수 없습니다. 따라서이 Storable의 기본값은 새롭고 올바른 동작입니다.</target>
        </trans-unit>
        <trans-unit id="714a2ccbafbac0389af167e01df326cf6b8a78ff" translate="yes" xml:space="preserve">
          <source>Storable magic</source>
          <target state="translated">저장 가능한 마술</target>
        </trans-unit>
        <trans-unit id="7182df5560db2bb6b5167976e453bb5798e3130f" translate="yes" xml:space="preserve">
          <source>Storable provides you with a &lt;code&gt;dclone&lt;/code&gt; interface which does not create that intermediary scalar but instead freezes the structure in some internal memory space and then immediately thaws it out.</source>
          <target state="translated">Storable은 중간 스칼라를 생성하지 않고 대신 일부 내부 메모리 공간에서 구조를 정지시킨 다음 즉시 해동 시키는 &lt;code&gt;dclone&lt;/code&gt; 인터페이스를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="70fb12ce1748ed7f4a137be836ce41aa365bbd68" translate="yes" xml:space="preserve">
          <source>Storable uses the &quot;exception&quot; paradigm, in that it does not try to workaround failures: if something bad happens, an exception is generated from the caller's perspective (see &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; and &lt;code&gt;croak()&lt;/code&gt; ). Use eval {} to trap those exceptions.</source>
          <target state="translated">Storable은 &quot;예외&quot;패러다임을 사용합니다. 이는 실패 해결 방법을 시도하지 않습니다. 문제가 발생하면 호출자의 관점에서 예외가 생성됩니다 ( &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; and &lt;code&gt;croak()&lt;/code&gt; ). eval {}을 사용하여 해당 예외를 트랩하십시오.</target>
        </trans-unit>
        <trans-unit id="531ca0b8b45f41c9f0b1aa246372790831675baa" translate="yes" xml:space="preserve">
          <source>Storable was written by Raphael Manfredi</source>
          <target state="translated">Storable은 Raphael Manfredi에 의해 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="b7e864254e3dece2f3614748bd8acc66ad85caaa" translate="yes" xml:space="preserve">
          <source>Storable writes a file header which contains the sizes of various C language types for the C compiler that built Storable (when not writing in network order), and will refuse to load files written by a Storable not on the same (or compatible) architecture. This check and a check on machine byteorder is needed because the size of various fields in the file are given by the sizes of the C language types, and so files written on different architectures are incompatible. This is done for increased speed. (When writing in network order, all fields are written out as standard lengths, which allows full interworking, but takes longer to read and write)</source>
          <target state="translated">Storable은 Storable을 빌드 한 (네트워크 순서로 쓰지 않을 때) C 컴파일러에 대한 다양한 C 언어 유형의 크기를 포함하는 파일 헤더를 작성하며 Storable이 작성한 파일을 동일한 (또는 호환 가능한) 아키텍처가 아닌로드하지 않습니다. 파일의 다양한 필드 크기가 C 언어 유형의 크기로 제공되므로 다른 아키텍처에서 작성된 파일이 호환되지 않기 때문에이 검사 및 기계 바이트 순서 검사가 필요합니다. 이것은 속도를 높이기 위해 수행됩니다. (네트워크 순서로 기록 할 때 모든 필드는 표준 길이로 기록되므로 완전한 인터 워킹이 가능하지만 읽고 쓰는 데 시간이 더 걸립니다)</target>
        </trans-unit>
        <trans-unit id="4150d3a5cc43231c993765dececd1a150bb52a3d" translate="yes" xml:space="preserve">
          <source>Store Memoized data in Storable database</source>
          <target state="translated">저장 가능한 데이터베이스에 메모 된 데이터 저장</target>
        </trans-unit>
        <trans-unit id="92a651d3dc16aed75ba857e2f774b7e083ba7965" translate="yes" xml:space="preserve">
          <source>Store and re-use state information about distributions between CPAN.pm sessions?</source>
          <target state="translated">CPAN.pm 세션 간 배포에 대한 상태 정보를 저장하고 재사용합니까?</target>
        </trans-unit>
        <trans-unit id="2c71530924851d1b8827aef4994b16eb515c4e61" translate="yes" xml:space="preserve">
          <source>Store data</source>
          <target state="translated">데이터 저장</target>
        </trans-unit>
        <trans-unit id="b25c722ad4f1fce5bbbe8fc35b0030d7d69ef919" translate="yes" xml:space="preserve">
          <source>Store datum</source>
          <target state="translated">데이텀 저장</target>
        </trans-unit>
        <trans-unit id="8f37eea7a30e3775bbbbb580f43dfdd3bec41576" translate="yes" xml:space="preserve">
          <source>Store the results of a test.</source>
          <target state="translated">테스트 결과를 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="389cd56c2ab90c83d09e93be1e21e43d82460448" translate="yes" xml:space="preserve">
          <source>Stores &lt;code&gt;$value&lt;/code&gt; in the gzip OS header field. A number between 0 and 255 is valid.</source>
          <target state="translated">gzip OS 헤더 필드에 &lt;code&gt;$value&lt;/code&gt; 를 저장 합니다. 0에서 255 사이의 숫자가 유효합니다.</target>
        </trans-unit>
        <trans-unit id="b39d714bdc1e95f53f0e2222e4e3c3755001f302" translate="yes" xml:space="preserve">
          <source>Stores &lt;code&gt;val&lt;/code&gt; in a hash. The hash key is specified as &lt;code&gt;key&lt;/code&gt; . The &lt;code&gt;hash&lt;/code&gt; parameter is the precomputed hash value; if it is zero then Perl will compute it. The return value is the new hash entry so created. It will be NULL if the operation failed or if the value did not need to be actually stored within the hash (as in the case of tied hashes). Otherwise the contents of the return value can be accessed using the &lt;code&gt;He?&lt;/code&gt; macros described here. Note that the caller is responsible for suitably incrementing the reference count of &lt;code&gt;val&lt;/code&gt; before the call, and decrementing it if the function returned NULL. Effectively a successful hv_store_ent takes ownership of one reference to &lt;code&gt;val&lt;/code&gt; . This is usually what you want; a newly created SV has a reference count of one, so if all your code does is create SVs then store them in a hash, hv_store will own the only reference to the new SV, and your code doesn't need to do anything further to tidy up. Note that hv_store_ent only reads the &lt;code&gt;key&lt;/code&gt; ; unlike &lt;code&gt;val&lt;/code&gt; it does not take ownership of it, so maintaining the correct reference count on &lt;code&gt;key&lt;/code&gt; is entirely the caller's responsibility. hv_store is not implemented as a call to hv_store_ent, and does not create a temporary SV for the key, so if your key data is not already in SV form then use hv_store in preference to hv_store_ent.</source>
          <target state="translated">&lt;code&gt;val&lt;/code&gt; 을 해시에 저장합니다 . 해시 키로 지정 &lt;code&gt;key&lt;/code&gt; . &lt;code&gt;hash&lt;/code&gt; 파라미터는 미리 계산 된 해시 값이고; 0이면 Perl이 계산합니다. 리턴 값은 이렇게 작성된 새 해시 항목입니다. 조작이 실패했거나 값이 실제로 해시 내에 저장 될 필요가없는 경우 (연결된 해시의 경우) NULL입니다. 그렇지 않으면 &lt;code&gt;He?&lt;/code&gt; 를 사용하여 반환 값의 내용에 액세스 할 수 있습니다 . 여기에 설명 된 매크로 호출자는 호출 전에 &lt;code&gt;val&lt;/code&gt; 의 참조 카운트를 적절하게 증가 시키고 함수가 NULL을 리턴하면 감소시킵니다. 효과적으로 성공적인 hv_store_ent는 &lt;code&gt;val&lt;/code&gt; 에 대한 하나의 참조 소유권을 갖습니다.. 이것은 일반적으로 원하는 것입니다. 새로 생성 된 SV의 참조 카운트는 1입니다. 따라서 모든 코드에서 SV를 생성 한 다음 해시에 저장하면 hv_store는 새로운 SV에 대한 유일한 참조를 소유하며 코드는 더 이상 수행 할 작업이 없습니다. 치우다. hv_store_ent는 &lt;code&gt;key&lt;/code&gt; 읽습니다 . &lt;code&gt;val&lt;/code&gt; 과는 달리 소유권을 가지지 않으므로 &lt;code&gt;key&lt;/code&gt; 의 올바른 참조 횟수를 유지하는 것은 전적으로 호출자의 책임입니다. hv_store는 hv_store_ent에 대한 호출로 구현되지 않으며 키에 대한 임시 SV를 작성하지 않으므로 키 데이터가 아직 SV 형식이 아닌 경우 hv_store를 기본적으로 hv_store_ent보다 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7e853791e7f610503cb4ac62aa2d38d07104bcbf" translate="yes" xml:space="preserve">
          <source>Stores a value, associated with a key, in the cop hints hash</source>
          <target state="translated">경찰 힌트 해시에 키와 관련된 값을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="5e0142d462eb02b96cf9082ac295203e85636940" translate="yes" xml:space="preserve">
          <source>Stores all unambiguous truncations of each element of LIST as keys in the associative array referenced by &lt;code&gt;$hashref&lt;/code&gt; . The values are the original list elements.</source>
          <target state="translated">LIST의 각 요소에 대한 모호하지 않은 잘림을 &lt;code&gt;$hashref&lt;/code&gt; 참조하는 연관 배열에 키로 저장합니다 . 값은 원래 목록 요소입니다.</target>
        </trans-unit>
        <trans-unit id="4236561c990b7cd479ccb52f08cd5fac9306b818" translate="yes" xml:space="preserve">
          <source>Stores an SV in a hash. The hash key is specified as &lt;code&gt;key&lt;/code&gt; and the absolute value of &lt;code&gt;klen&lt;/code&gt; is the length of the key. If &lt;code&gt;klen&lt;/code&gt; is negative the key is assumed to be in UTF-8-encoded Unicode. The &lt;code&gt;hash&lt;/code&gt; parameter is the precomputed hash value; if it is zero then Perl will compute it.</source>
          <target state="translated">SV를 해시에 저장합니다. 해시 키로서 지정된 &lt;code&gt;key&lt;/code&gt; 와의 절대치 &lt;code&gt;klen&lt;/code&gt; 키의 길이이다. 경우 &lt;code&gt;klen&lt;/code&gt; 키에 있다고 가정 부정 유니 UTF-8 인코딩. &lt;code&gt;hash&lt;/code&gt; 파라미터는 미리 계산 된 해시 값이고; 0이면 Perl이 계산합니다.</target>
        </trans-unit>
        <trans-unit id="d6c29a0065e8b044a53af0ddb9dc3214fa041cf5" translate="yes" xml:space="preserve">
          <source>Stores an SV in an array. The array index is specified as &lt;code&gt;key&lt;/code&gt; . The return value will be NULL if the operation failed or if the value did not need to be actually stored within the array (as in the case of tied arrays). Otherwise, it can be dereferenced to get the &lt;code&gt;SV*&lt;/code&gt; that was stored there (= &lt;code&gt;val&lt;/code&gt; )).</source>
          <target state="translated">SV를 배열에 저장합니다. 배열 인덱스는 &lt;code&gt;key&lt;/code&gt; 로 지정됩니다 . 연산이 실패했거나 값이 실제로 배열 내에 저장 될 필요가없는 경우 (연결 배열의 경우와 같이) 반환 값은 NULL이됩니다. 그렇지 않으면, 저장된 &lt;code&gt;SV*&lt;/code&gt; (= &lt;code&gt;val&lt;/code&gt; ) 를 얻기 위해 역 참조 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7401a972574f8c1665c02fe0802590c81677bf55" translate="yes" xml:space="preserve">
          <source>Stores an alias to a variable in a hash instead of copying the value.</source>
          <target state="translated">값을 복사하는 대신 별칭에 변수에 별칭을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="9f6711f9c55cd1025cf538a50470266deb723a43" translate="yes" xml:space="preserve">
          <source>Stores results for later output, all together.</source>
          <target state="translated">나중에 출력하기위한 결과를 모두 함께 저장합니다.</target>
        </trans-unit>
        <trans-unit id="ced5e829ffc1318c3116b905b84107c1f3b72848" translate="yes" xml:space="preserve">
          <source>Stores the contents of &lt;code&gt;$comment&lt;/code&gt; in the COMMENT field in the gzip header. By default, no comment field is written to the gzip file.</source>
          <target state="translated">gzip 헤더의 COMMENT 필드에 &lt;code&gt;$comment&lt;/code&gt; 의 내용을 저장합니다 . 기본적으로 주석 필드는 gzip 파일에 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="26843a54a3aa3332ec1baa3fb76f8c537a96c327" translate="yes" xml:space="preserve">
          <source>Stores the contents of &lt;code&gt;$comment&lt;/code&gt; in the Central File Header of the zip file.</source>
          <target state="translated">&lt;code&gt;$comment&lt;/code&gt; 의 내용을 zip 파일의 중앙 파일 헤더에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="f6d27852fc3f996b193528d04367b82db064d418" translate="yes" xml:space="preserve">
          <source>Stores the contents of &lt;code&gt;$comment&lt;/code&gt; in the End of Central Directory record of the zip file.</source>
          <target state="translated">zip 파일의 중앙 디렉토리 끝 레코드에 &lt;code&gt;$comment&lt;/code&gt; 의 내용을 저장 합니다.</target>
        </trans-unit>
        <trans-unit id="24042b8640feee28c4f2a0aafea788776423cdd1" translate="yes" xml:space="preserve">
          <source>Stores the contents of &lt;code&gt;$string&lt;/code&gt; in the gzip NAME header field. If &lt;code&gt;Name&lt;/code&gt; is not specified, no gzip NAME field will be created.</source>
          <target state="translated">gzip NAME 헤더 필드 에 &lt;code&gt;$string&lt;/code&gt; 의 내용을 저장합니다 . 경우 &lt;code&gt;Name&lt;/code&gt; 지정되지 않는 경우, GZIP NAME 필드가 작성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1023c335a52babfe2f8c4a04c4f2766471fa8387" translate="yes" xml:space="preserve">
          <source>Stores the contents of &lt;code&gt;$string&lt;/code&gt; in the zip filename header field.</source>
          <target state="translated">zip filename 헤더 필드 에 &lt;code&gt;$string&lt;/code&gt; 의 내용을 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="51541d8a3d93b2d48a376cb2252ed37ed72421ab" translate="yes" xml:space="preserve">
          <source>Stores the key/value pair in the database.</source>
          <target state="translated">키 / 값 쌍을 데이터베이스에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="ab093d23324af52293488a603b3cc3854b181a9e" translate="yes" xml:space="preserve">
          <source>Stores the pad name (which may be null) at the given index, freeing any existing pad name in that slot.</source>
          <target state="translated">주어진 색인에 패드 이름 (널 (NULL) 일 수 있음)을 저장하여 해당 슬롯의 기존 패드 이름을 비 웁니다.</target>
        </trans-unit>
        <trans-unit id="9d70a29a0f92ba96f998b27b0c51d6b21ce2123e" translate="yes" xml:space="preserve">
          <source>Stores the string &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; stringifies to. The Perl engine for example stores &lt;code&gt;(?^:eek)&lt;/code&gt; in the case of &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/eek/&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">문자열 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 문자열로 저장합니다 . 예를 들어 Perl 엔진 은 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/eek/&lt;/a&gt;&lt;/code&gt; 의 경우 &lt;code&gt;(?^:eek)&lt;/code&gt; 를 저장 합니다.</target>
        </trans-unit>
        <trans-unit id="30082107d90ca21e79e8350f2001678a7dc4b25b" translate="yes" xml:space="preserve">
          <source>Storing data canonically that contains large hashes can be significantly slower than storing the same data normally, as temporary arrays to hold the keys for each hash have to be allocated, populated, sorted and freed. Some tests have shown a halving of the speed of storing -- the exact penalty will depend on the complexity of your data. There is no slowdown on retrieval.</source>
          <target state="translated">각 해시의 키를 보유하는 임시 배열을 할당, 채우기, 정렬 및 해제해야하므로 큰 해시를 포함하는 데이터를 정식으로 저장하면 동일한 데이터를 저장하는 것보다 상당히 느릴 수 있습니다. 일부 테스트에서는 저장 속도가 절반으로 감소한 것으로 나타났습니다. 정확한 벌점은 데이터의 복잡성에 따라 다릅니다. 검색 속도가 저하되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2ccce2de5e8ad98636ec0480f8c1e95cb4123766" translate="yes" xml:space="preserve">
          <source>Storing numbers</source>
          <target state="translated">보관 번호</target>
        </trans-unit>
        <trans-unit id="408286a7232f91f660936da7835bac0e8863fd20" translate="yes" xml:space="preserve">
          <source>Storing options values in a hash</source>
          <target state="translated">해시에 옵션 값 저장</target>
        </trans-unit>
        <trans-unit id="5ca11c09231ed950fa4ac2095c30a18383eebf81" translate="yes" xml:space="preserve">
          <source>Storing pre-compiled regexps in an array &lt;code&gt;@compiled&lt;/code&gt; allows us to simply loop through the regexps without any recompilation, thus gaining flexibility without sacrificing speed.</source>
          <target state="translated">사전 컴파일 된 &lt;code&gt;@compiled&lt;/code&gt; 배열에 저장 하면 재 컴파일없이 정규 표현식 을 간단하게 반복 할 수 있으므로 속도를 희생하지 않고도 유연성을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e08b2cdc880eca3b63a251507ea23ebf665def8" translate="yes" xml:space="preserve">
          <source>Straightaway we can see that the number of times each line has been called is identical to the &lt;code&gt;Devel::SmallProf&lt;/code&gt; output, and the sequence is only very slightly different based on the ordering of the amount of time each line took to execute, &lt;code&gt;if ( $debug ) { &lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $message = &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;;&lt;/code&gt; , for example. The differences in the actual times recorded might be in the algorithm used internally, or it could be due to system resource limitations or contention.</source>
          <target state="translated">각 라인이 호출 된 횟수가 &lt;code&gt;Devel::SmallProf&lt;/code&gt; 출력 과 동일 하고 시퀀스가 ​​각 라인이 실행되는 시간의 순서에 따라 매우 약간 다르다는 것을 알 수 있습니다 &lt;code&gt;if ( $debug ) { &lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $message = &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;;&lt;/code&gt; 예를 들어. 실제로 기록 된 시간의 차이는 내부적으로 사용 된 알고리즘에 있거나 시스템 자원 제한 또는 경합으로 인한 것일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf5060e04f34c62382f4c8552c1d1cf9f000d47b" translate="yes" xml:space="preserve">
          <source>Strategies for Storing Callback Context Information</source>
          <target state="translated">콜백 컨텍스트 정보 저장 전략</target>
        </trans-unit>
        <trans-unit id="813265ea56803a78f3b7159d5fee7e20c7133600" translate="yes" xml:space="preserve">
          <source>Stratus Technologies on the web at &lt;a href=&quot;http://www.stratus.com&quot;&gt;http://www.stratus.com&lt;/a&gt;</source>
          <target state="translated">웹의 Stratus Technologies ( &lt;a href=&quot;http://www.stratus.com&quot;&gt;http://www.stratus.com)&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e9e8d1a4aa1f448e22fd91f660943bf3fb47ccc9" translate="yes" xml:space="preserve">
          <source>Stratus VOS 15.1, &lt;a href=&quot;http://stratadoc.stratus.com/vos/15.1.1/r502-01/wwhelp/wwhimpl/js/html/wwhelp.htm?context=r502-01&amp;amp;file=ch5r502-01bi.html&quot;&gt;http://stratadoc.stratus.com/vos/15.1.1/r502-01/wwhelp/wwhimpl/js/html/wwhelp.htm?context=r502-01&amp;amp;file=ch5r502-01bi.html&lt;/a&gt;</source>
          <target state="translated">Stratus VOS 15.1, &lt;a href=&quot;http://stratadoc.stratus.com/vos/15.1.1/r502-01/wwhelp/wwhimpl/js/html/wwhelp.htm?context=r502-01&amp;amp;file=ch5r502-01bi.html&quot;&gt;http://stratadoc.stratus.com/vos/15.1.1/r502-01/wwhelp/wwhimpl/js/html/wwhelp.htm?context=r502-01&amp;amp;file=ch5r502-01bi.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6dac5050cc8d5226a232897b98c67a79066b8e3a" translate="yes" xml:space="preserve">
          <source>Stream TAP from a Perl executable</source>
          <target state="translated">Perl 실행 파일에서 TAP 스트림</target>
        </trans-unit>
        <trans-unit id="411adcb2712346800a739adfeb9ade95333b1abf" translate="yes" xml:space="preserve">
          <source>Stream TAP from a text file.</source>
          <target state="translated">텍스트 파일에서 TAP을 스트리밍합니다.</target>
        </trans-unit>
        <trans-unit id="5517c94f54c087e37e9e39887df00a0c39d682fc" translate="yes" xml:space="preserve">
          <source>Stream TAP from an IO::Handle or a GLOB.</source>
          <target state="translated">IO :: Handle 또는 GLOB에서 TAP을 스트리밍하십시오.</target>
        </trans-unit>
        <trans-unit id="044591cd59e9b7c9396655ff7bb64423112f9b95" translate="yes" xml:space="preserve">
          <source>Stream output from an executable TAP source</source>
          <target state="translated">실행 가능한 TAP 소스의 스트림 출력</target>
        </trans-unit>
        <trans-unit id="137d2933966619b13837102be962efe1a1067d69" translate="yes" xml:space="preserve">
          <source>Stream output from raw TAP in a scalar/array ref.</source>
          <target state="translated">스칼라 / 배열 참조에서 원시 TAP의 스트림 출력.</target>
        </trans-unit>
        <trans-unit id="79d9a52c246461dc0594d29507cd94db89e5088f" translate="yes" xml:space="preserve">
          <source>Stricter rules help to find typos and other errors. Perhaps you didn't even intend a range here, if the &lt;code&gt;&quot;-&quot;&lt;/code&gt; was meant to be some other character, or should have been escaped (like &lt;code&gt;&quot;\-&quot;&lt;/code&gt; ). If you did intend a range, the one that was used is not portable between ASCII and EBCDIC platforms, and doesn't have an obvious meaning to a casual reader.</source>
          <target state="translated">엄격한 규칙은 오타 및 기타 오류를 찾는 데 도움이됩니다. &lt;code&gt;&quot;-&quot;&lt;/code&gt; 가 다른 문자이거나 &lt;code&gt;&quot;\-&quot;&lt;/code&gt; 와 같이 이스케이프 된 경우 범위를 계획하지 않았을 수도 있습니다 . 범위를 의도 한 경우 사용 된 범위는 ASCII와 EBCDIC 플랫폼간에 이식 가능하지 않으며 일반 독자에게는 분명한 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5eda0deef3d3835356e2633ac9dde47a16b13b5d" translate="yes" xml:space="preserve">
          <source>Stricter rules help to find typos and other errors. You included a range, and at least one of the end points is a decimal digit. Under the stricter rules, when this happens, both end points should be digits in the same group of 10 consecutive digits.</source>
          <target state="translated">엄격한 규칙은 오타 및 기타 오류를 찾는 데 도움이됩니다. 범위를 포함 시켰으며 끝점 중 하나 이상이 10 진수입니다. 보다 엄격한 규칙에 따라이 경우 두 끝점은 동일한 연속 10 자리 그룹의 숫자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="0650e0c020aef4abbfbd4bda604f404ed598e991" translate="yes" xml:space="preserve">
          <source>Strictly speaking, a program that munches up another program and spits out yet another file containing the program in a &amp;ldquo;more executable&amp;rdquo; form, typically containing native machine instructions. The</source>
          <target state="translated">엄밀히 말하면, 다른 프로그램을 실행시키고 프로그램을 포함하는 또 다른 파일을 &quot;더 실행 가능한&quot;형식으로, 일반적으로 기본 기계 명령어를 포함하는 다른 파일을 뱉어내는 프로그램입니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="19287d999efabb7aed57bbe8e78bb9475aab4690" translate="yes" xml:space="preserve">
          <source>Strictly speaking, a program that reads a second program and does what the second program says directly without turning the program into a different form first, which is what &lt;b&gt;compilers&lt;/b&gt; do. Perl is not an interpreter by this definition, because it contains a kind of compiler that takes a program and turns it into a more executable form (&lt;b&gt;syntax trees&lt;/b&gt;) within the</source>
          <target state="translated">엄밀히 말하면, 두 번째 프로그램을 읽고 두 번째 프로그램이 다른 형식으로 먼저 전환하지 않고 두 번째 프로그램이 직접 말하는 것을 수행하는 프로그램은 &lt;b&gt;컴파일러&lt;/b&gt; 가하는 일입니다. Perl은 프로그램을 가져 와서 더 실행 가능한 형태 ( &lt;b&gt;구문 트리&lt;/b&gt; ) 로 변환하는 일종의 컴파일러를 포함하기 때문에이 정의에 의해 해석기가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="a6fde2b9f7e959d871c8af08462a6492339f7057" translate="yes" xml:space="preserve">
          <source>Strictly speaking, nothing. Stylistically speaking, it's not a good way to write maintainable code. Perl has several operators for running external commands. Backticks are one; they collect the output from the command for use in your program. The &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; function is another; it doesn't do this.</source>
          <target state="translated">엄밀히 말하면 아무것도 아닙니다. 스타일리쉬하게 말해서, 유지 보수 가능한 코드를 작성하는 좋은 방법은 아닙니다. Perl에는 외부 명령을 실행하기위한 여러 연산자가 있습니다. 백틱은 하나입니다. 프로그램에서 사용하기 위해 명령의 출력을 수집합니다. &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 기능은 다른이고; 이 작업을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="95ea50d3a212d751dc75823785ce8d3fc481176b" translate="yes" xml:space="preserve">
          <source>Strictly speaking, the year should be specified in a form consistent with &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt;, i.e. the offset from 1900. In order to make the interpretation of the year easier for humans, however, who are more accustomed to seeing years as two-digit or four-digit values, the following conventions are followed:</source>
          <target state="translated">엄밀히 말하면, 연도는 &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 과 일치하는 형식으로 , 즉 1900에서 오프셋 으로 지정해야합니다 . 그러나 연도를 더 쉽게 해석하기 위해 연도를 두 자리 또는 네 자리 숫자로 다음 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="5c4b8f90e8599772141d5d74184d3678eb652f81" translate="yes" xml:space="preserve">
          <source>Strictly, the shell&amp;rsquo;s &lt;code&gt;*&lt;/code&gt; character, which will match a &amp;ldquo;glob&amp;rdquo; of characters when you&amp;rsquo;re trying to generate a list of filenames. Loosely, the act of using globs and similar symbols to do pattern matching. See also &lt;b&gt;fileglob&lt;/b&gt; and &lt;b&gt;typeglob&lt;/b&gt;.</source>
          <target state="translated">엄밀히 말해, 쉘의 &lt;code&gt;*&lt;/code&gt; 문자는 파일 이름 목록을 생성하려고 할 때 문자의 &quot;글로브&quot;와 일치합니다. 느슨하게, 패턴 매칭을하기 위해 glob와 유사한 심볼을 사용하는 행위. &lt;b&gt;fileglob&lt;/b&gt; 및 &lt;b&gt;typeglob&lt;/b&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="158127f06e6da3362607fa7cbbba756efc7019b1" translate="yes" xml:space="preserve">
          <source>Strictness and warnings</source>
          <target state="translated">엄격함과 경고</target>
        </trans-unit>
        <trans-unit id="516c0f4e3c92a494342e3cb25a961d2360643bc2" translate="yes" xml:space="preserve">
          <source>String &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;LC_NUMERIC&lt;/code&gt;</source>
          <target state="translated">문자열 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;LC_NUMERIC&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="322644ec18f089375fd934ccac0ee29b7bf9401a" translate="yes" xml:space="preserve">
          <source>String Collation</source>
          <target state="translated">문자열 데이터 정렬</target>
        </trans-unit>
        <trans-unit id="40837ec372cc75f0a51393ed930c1fe017719b97" translate="yes" xml:space="preserve">
          <source>String Equivalence</source>
          <target state="translated">문자열 등가</target>
        </trans-unit>
        <trans-unit id="c0852fa4a49f9a7f054796351af22423733e0ae5" translate="yes" xml:space="preserve">
          <source>String Lengths</source>
          <target state="translated">끈 길이</target>
        </trans-unit>
        <trans-unit id="b231adac90ed5af6e5723df56d210bfd345958ac" translate="yes" xml:space="preserve">
          <source>String Processing, Language Text Processing, Parsing, and Searching</source>
          <target state="translated">문자열 처리, 언어 텍스트 처리, 구문 분석 및 검색</target>
        </trans-unit>
        <trans-unit id="f618ca662dfcc3b16eb26b3a99e8a37d3fd5c229" translate="yes" xml:space="preserve">
          <source>String constants that would normally evaluate to 0 or 1 are warned about.</source>
          <target state="translated">일반적으로 0 또는 1로 평가되는 문자열 상수가 경고됩니다.</target>
        </trans-unit>
        <trans-unit id="6104084e70872a799af75c0c3b3e9c680e29b421" translate="yes" xml:space="preserve">
          <source>String conversion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="597fe8909ca1928228ff982d52d105d13e058f8b" translate="yes" xml:space="preserve">
          <source>String eval and LC_NUMERIC</source>
          <target state="translated">문자열 평가 및 LC_NUMERIC</target>
        </trans-unit>
        <trans-unit id="860dceea01893fc71bff8d83982d93e598606a4e" translate="yes" xml:space="preserve">
          <source>String handling functions, for the most part, continue to operate in terms of characters. &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt;, for example, returns the number of characters in a string, just as before. But that number no longer is necessarily the same as the number of bytes in the string (there may be more bytes than characters). The other such functions include &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/rindex&quot;&gt;rindex()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">문자열 처리 기능은 대부분 문자 측면에서 계속 작동합니다. 예를 들어 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; 는 이전과 마찬가지로 문자열의 문자 수를 반환합니다. 그러나 그 숫자는 더 이상 문자열의 바이트 수와 동일 할 필요는 없습니다 (문자보다 많은 바이트가있을 수 있음). 다른 함수로는 &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/rindex&quot;&gt;rindex()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="c329814ec2d3d4971e2511c74b3273f40003742e" translate="yes" xml:space="preserve">
          <source>String interpolation with case-mapping, as in, say, &lt;code&gt;$dest =
&quot;C:\U$name.$ext&quot;&lt;/code&gt; , may produce dangerous results if a bogus &lt;code&gt;LC_CTYPE&lt;/code&gt; case-mapping table is in effect.</source>
          <target state="translated">&lt;code&gt;$dest = &quot;C:\U$name.$ext&quot;&lt;/code&gt; 와 같이 case-mapping을 사용한 문자열 보간 은 가짜 &lt;code&gt;LC_CTYPE&lt;/code&gt; case-mapping 테이블이 유효한 경우 위험한 결과를 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d6780b9a46b265648d17e144b69c48ee74770992" translate="yes" xml:space="preserve">
          <source>String literals are usually delimited by either single or double quotes. They work much like quotes in the standard Unix shells: double-quoted string literals are subject to backslash and variable substitution; single-quoted strings are not (except for &lt;code&gt;\'&lt;/code&gt; and &lt;code&gt;\\&lt;/code&gt; ). The usual C-style backslash rules apply for making characters such as newline, tab, etc., as well as some more exotic forms. See &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;Quote and Quote-like Operators in perlop&lt;/a&gt; for a list.</source>
          <target state="translated">문자열 리터럴은 일반적으로 작은 따옴표 나 큰 따옴표로 구분됩니다. 표준 Unix 쉘에서 인용 부호와 매우 유사하게 작동합니다. 큰 따옴표로 묶인 문자열 리터럴은 백 슬래시와 변수 대체가 적용됩니다. 작은 따옴표로 묶인 문자열은 없습니다 ( &lt;code&gt;\'&lt;/code&gt; 및 &lt;code&gt;\\&lt;/code&gt; 제외 ). 일반적인 C 스타일 백 슬래시 규칙은 줄 바꿈, 탭 등과 같은 문자와 좀 더 이국적인 형식을 만드는 데 적용됩니다. 목록 &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;은 perlop에서 인용 및 인용 유사 연산자를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b011a78c96a9c16cf6436848fa3f565de97986a2" translate="yes" xml:space="preserve">
          <source>String of options to pass to xsubpp. This might include &lt;code&gt;-C++&lt;/code&gt; or &lt;code&gt;-extern&lt;/code&gt; . Do not include typemaps here; the TYPEMAP parameter exists for that purpose.</source>
          <target state="translated">xsubpp에 전달할 옵션 문자열. 여기에는 &lt;code&gt;-C++&lt;/code&gt; 또는 &lt;code&gt;-extern&lt;/code&gt; 이 포함될 수 있습니다 . 여기에 타입 맵을 포함시키지 마십시오. TYPEMAP 매개 변수는 해당 목적으로 존재합니다.</target>
        </trans-unit>
        <trans-unit id="3fec62342425ec8f81ce629d9250491168e3f930" translate="yes" xml:space="preserve">
          <source>String overloaded objects are compared &lt;b&gt;as strings&lt;/b&gt; (or in &lt;code&gt;cmp_ok()&lt;/code&gt; 's case, strings or numbers as appropriate to the comparison op). This prevents Test::More from piercing an object's interface allowing better blackbox testing. So if a function starts returning overloaded objects instead of bare strings your tests won't notice the difference. This is good.</source>
          <target state="translated">문자열 오버로드 된 객체는 &lt;b&gt;문자열&lt;/b&gt; (또는 비교 op에 적합한 &lt;code&gt;cmp_ok()&lt;/code&gt; 의 경우 문자열 또는 숫자)로 비교됩니다. 이렇게하면 Test :: More가 객체의 인터페이스를 뚫고 더 나은 블랙 박스 테스트를 할 수 없습니다. 따라서 함수가 노출 된 문자열 대신 오버로드 된 객체를 반환하기 시작하면 테스트에서 차이를 인식하지 못합니다. 이거 좋다</target>
        </trans-unit>
        <trans-unit id="0f00ebea06538bbe227ded196b24216fa175546f" translate="yes" xml:space="preserve">
          <source>String that will be included in the compiler call command line between the arguments INC and OPTIMIZE.</source>
          <target state="translated">INC와 OPTIMIZE 인수 사이의 컴파일러 호출 명령 행에 포함될 문자열.</target>
        </trans-unit>
        <trans-unit id="6e526f1a740ace9291b3849106bb71fe9922d6d7" translate="yes" xml:space="preserve">
          <source>String to (long) integer translation. Returns the parsed number and the number of characters in the unparsed portion of the string. Truly POSIX-compliant systems set &lt;code&gt;$!&lt;/code&gt; (&lt;code&gt;$ERRNO&lt;/code&gt; ) to indicate a translation error, so clear &lt;code&gt;$!&lt;/code&gt; before calling &lt;code&gt;strtol&lt;/code&gt; . However, non-POSIX systems may not check for overflow, and therefore will never set &lt;code&gt;$!&lt;/code&gt; .</source>
          <target state="translated">문자열을 (긴) 정수로 변환합니다. 문자열의 구문 분석되지 않은 부분에서 구문 분석 된 수와 문자 수를 리턴합니다. 진정한 POSIX 호환 시스템 세트 &lt;code&gt;$!&lt;/code&gt; ( &lt;code&gt;$ERRNO&lt;/code&gt; )는 번역 오류를 나타내므로 &lt;code&gt;$!&lt;/code&gt; 를 지우십시오 . &lt;code&gt;strtol&lt;/code&gt; 을 호출하기 전에 . 그러나 비 POSIX 시스템은 오버플로를 검사하지 않을 수 있으므로 &lt;code&gt;$!&lt;/code&gt; 설정하지 않습니다 ! .</target>
        </trans-unit>
        <trans-unit id="f8ad43047bd965bdc4d07f5ce2456ad0a02b96c7" translate="yes" xml:space="preserve">
          <source>String to double translation. Returns the parsed number and the number of characters in the unparsed portion of the string. Truly POSIX-compliant systems set &lt;code&gt;$!&lt;/code&gt; (&lt;code&gt;$ERRNO&lt;/code&gt; ) to indicate a translation error, so clear &lt;code&gt;$!&lt;/code&gt; before calling &lt;code&gt;strtod&lt;/code&gt; . However, non-POSIX systems may not check for overflow, and therefore will never set &lt;code&gt;$!&lt;/code&gt; .</source>
          <target state="translated">문자열을 이중으로 변환합니다. 문자열의 구문 분석되지 않은 부분에서 구문 분석 된 수와 문자 수를 리턴합니다. 진정한 POSIX 호환 시스템 세트 &lt;code&gt;$!&lt;/code&gt; ( &lt;code&gt;$ERRNO&lt;/code&gt; )는 번역 오류를 나타내므로 &lt;code&gt;$!&lt;/code&gt; 를 지우십시오 . &lt;code&gt;strtod&lt;/code&gt; 를 호출하기 전에 . 그러나 비 POSIX 시스템은 오버플로를 검사하지 않을 수 있으므로 &lt;code&gt;$!&lt;/code&gt; 설정하지 않습니다 ! .</target>
        </trans-unit>
        <trans-unit id="2abcfc7dcb04cc4aa0bcda4543317ca564702847" translate="yes" xml:space="preserve">
          <source>String to unsigned (long) integer translation. &lt;code&gt;strtoul()&lt;/code&gt; is identical to &lt;code&gt;strtol()&lt;/code&gt; except that &lt;code&gt;strtoul()&lt;/code&gt; only parses unsigned integers. See &lt;a href=&quot;#strtol&quot;&gt;strtol&lt;/a&gt; for details.</source>
          <target state="translated">부호없는 (긴) 정수 변환에 대한 문자열입니다. &lt;code&gt;strtoul()&lt;/code&gt; 동일하다 &lt;code&gt;strtol()&lt;/code&gt; 것을 제외 &lt;code&gt;strtoul()&lt;/code&gt; 만 부호없는 정수를 파싱한다. 자세한 내용은 &lt;a href=&quot;#strtol&quot;&gt;strtol&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0ad6f48bf54709b2ba69a1fce32b7638601bfac7" translate="yes" xml:space="preserve">
          <source>String transformation. Returns the transformed string.</source>
          <target state="translated">문자열 변환. 변환 된 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="095d3b7d7b51ca9267c55a71d96ee740ce9ed714" translate="yes" xml:space="preserve">
          <source>String-To-Number Conversions</source>
          <target state="translated">문자열을 숫자로 변환</target>
        </trans-unit>
        <trans-unit id="89f0c9a299c3800ad98959c29c190d1bc9de23ac" translate="yes" xml:space="preserve">
          <source>String. An arbitrary sequence of characters. It is valid for the argument to start with &lt;code&gt;-&lt;/code&gt; or &lt;code&gt;--&lt;/code&gt; .</source>
          <target state="translated">끈. 임의의 문자 시퀀스 인수가 &lt;code&gt;-&lt;/code&gt; 또는 &lt;code&gt;--&lt;/code&gt; 로 시작하는 것이 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="fafc0f2cb3777e3c850edce9bbb0624fb76d8e93" translate="yes" xml:space="preserve">
          <source>Stringification also destroys arrays.</source>
          <target state="translated">스트링 화는 또한 배열을 파괴합니다.</target>
        </trans-unit>
        <trans-unit id="a96e53fa801a030d61d0b0afb131453e4a3a7511" translate="yes" xml:space="preserve">
          <source>Stringified perl data structures, suitable for both printing and &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">인쇄 및 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 적합한 문자열 화 된 펄 데이터 구조</target>
        </trans-unit>
        <trans-unit id="6bad8926562843b707945e86b277e1f637dc69d2" translate="yes" xml:space="preserve">
          <source>Stringify dumps the data inside the object.</source>
          <target state="translated">Stringify는 객체 내부의 데이터를 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="c5cca40b8e6ab951533c16fbbdd8e8eeb9f0e6f8" translate="yes" xml:space="preserve">
          <source>Strings created with &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; can also be manipulated with the logical operators &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt;, and &lt;code&gt;~&lt;/code&gt; . These operators will assume a bit vector operation is desired when both operands are strings. See &lt;a href=&quot;perlop#Bitwise-String-Operators&quot;&gt;Bitwise String Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">로 만든 문자열 &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; 또한 논리 연산자를 조작 할 수 있습니다 &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; 및 &lt;code&gt;~&lt;/code&gt; . 이 연산자는 두 피연산자가 모두 문자열 인 경우 비트 벡터 연산이 필요하다고 가정합니다. &lt;a href=&quot;perlop#Bitwise-String-Operators&quot;&gt;perlop의 비트 단위 문자열 연산자를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bc0a2fc8d4082ea8e735316dde8d1811abffaf90" translate="yes" xml:space="preserve">
          <source>Strings created with &lt;code&gt;&lt;a href=&quot;vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; can also be manipulated with the logical operators &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt;, and &lt;code&gt;~&lt;/code&gt; . These operators will assume a bit vector operation is desired when both operands are strings. See &lt;a href=&quot;../perlop#Bitwise-String-Operators&quot;&gt;Bitwise String Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">로 만든 문자열 &lt;code&gt;&lt;a href=&quot;vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; 또한 논리 연산자를 조작 할 수 있습니다 &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; 및 &lt;code&gt;~&lt;/code&gt; . 이 연산자는 두 피연산자가 모두 문자열 인 경우 비트 벡터 연산이 필요하다고 가정합니다. &lt;a href=&quot;../perlop#Bitwise-String-Operators&quot;&gt;perlop의 비트 단위 문자열 연산자를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9f7e8a6f87a8a42268a64c6a11af8887059d5680" translate="yes" xml:space="preserve">
          <source>Strings of multiple sub- and superscripts are not recognized as numbers. You can use either of the compatibility decompositions in Unicode::Normalize to change these into digits, and then call &lt;code&gt;num&lt;/code&gt; on the result.</source>
          <target state="translated">여러 첨자 및 위첨자의 문자열은 숫자로 인식되지 않습니다. Unicode :: Normalize의 호환성 분해 중 하나를 사용하여 숫자를 변경 한 다음 결과에서 &lt;code&gt;num&lt;/code&gt; 을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7aaa3eb6eac6d4efb6574a9ba9018939acd1f8cf" translate="yes" xml:space="preserve">
          <source>Strings--including hash keys--and regular expression patterns may contain characters that have ordinal values larger than 255.</source>
          <target state="translated">해시 키를 포함한 문자열 및 정규식 패턴에는 서 수가 255보다 큰 문자가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6348b5c86af8ba2c83c3a187e28bfcf9f1d038b" translate="yes" xml:space="preserve">
          <source>Stripping Perl Binaries on Cygwin</source>
          <target state="translated">Cygwin에서 Perl 바이너리 제거</target>
        </trans-unit>
        <trans-unit id="f9141f854e0e233503d419a0cf18d9153715c039" translate="yes" xml:space="preserve">
          <source>Strongly object-oriented and fully-featured with a long development history and a large community and addon ecosystem. It is excellent for large and complex applications, where you have full control over the server.</source>
          <target state="translated">오랜 개발 역사와 대규모 커뮤니티 및 애드온 생태계로 강력하게 객체 지향적이며 모든 기능을 갖추고 있습니다. 서버를 완전히 제어 할 수있는 크고 복잡한 응용 프로그램에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="f23a884e110f1886cdc16e896ca93598233740f9" translate="yes" xml:space="preserve">
          <source>Structs are required to be aligned to the maximum alignment required by the fields - which for native types is for usually equivalent to sizeof() of the field</source>
          <target state="translated">구조체는 필드에 필요한 최대 정렬에 맞춰 정렬해야합니다. 기본 유형의 경우 일반적으로 필드의 sizeof ()와 같습니다.</target>
        </trans-unit>
        <trans-unit id="eb761c94903285d6515bd20e9cd52538249ae83b" translate="yes" xml:space="preserve">
          <source>Structure of a Regexp Program</source>
          <target state="translated">정규식 프로그램의 구조</target>
        </trans-unit>
        <trans-unit id="cd40698b4bb94e939846994c9f9741e198f30bc1" translate="yes" xml:space="preserve">
          <source>Structured data retrieval of perl -V output</source>
          <target state="translated">Perl -V 출력의 구조화 된 데이터 검색</target>
        </trans-unit>
        <trans-unit id="b8ce54f7f99cf2cca6626a2de77f397b8065d514" translate="yes" xml:space="preserve">
          <source>Stub that provides thread hook for perl_destruct when there are no threads.</source>
          <target state="translated">스레드가 없을 때 perl_destruct에 스레드 후크를 제공하는 스텁.</target>
        </trans-unit>
        <trans-unit id="d8d7cb9c0bd0e5d2e8d74ffc3881bd4b4fc1400b" translate="yes" xml:space="preserve">
          <source>Stubs for Deleted Documents</source>
          <target state="translated">삭제 된 문서에 대한 스텁</target>
        </trans-unit>
        <trans-unit id="4d7dabe926bb346f9396e40dca4282529b230cab" translate="yes" xml:space="preserve">
          <source>Stuff here is really low-priority to optimize, since it is far better to implement the operation in the low-level math library directly, possible even using a call to the native lib.</source>
          <target state="translated">여기에있는 것들은 최적화하기에 우선 순위가 낮습니다. 낮은 수준의 수학 라이브러리에서 직접 작업을 구현하는 것이 훨씬 낫기 때문에 기본 라이브러리에 대한 호출을 사용하더라도 가능합니다.</target>
        </trans-unit>
        <trans-unit id="2869e1f287c823d9d113fb739c0f867918c01e7c" translate="yes" xml:space="preserve">
          <source>Stuffit Expander</source>
          <target state="translated">Stuffit Expander</target>
        </trans-unit>
        <trans-unit id="99a0efc6cfd85d8ff2732a6718140f822cb90472" translate="yes" xml:space="preserve">
          <source>Style</source>
          <target state="translated">Style</target>
        </trans-unit>
        <trans-unit id="6f4fae33d407351a21e057015a8cfce97b1d1d2a" translate="yes" xml:space="preserve">
          <source>Subclass</source>
          <target state="translated">Subclass</target>
        </trans-unit>
        <trans-unit id="873c1d3b114c3c8ca9fa8263d71c270acec87256" translate="yes" xml:space="preserve">
          <source>Subclass &lt;a href=&quot;parser/grammar&quot;&gt;TAP::Parser::Grammar&lt;/a&gt; and customize your parser by setting the &lt;code&gt;grammar_class&lt;/code&gt; parameter. See &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt; for more details.</source>
          <target state="translated">서브 클래스 &lt;a href=&quot;parser/grammar&quot;&gt;TAP :: Parser :: Grammar&lt;/a&gt; 및 &lt;code&gt;grammar_class&lt;/code&gt; 매개 변수 를 설정하여 구문 분석기를 사용자 정의하십시오 . 자세한 내용은 &lt;a href=&quot;#new&quot;&gt;새로운&lt;/a&gt; 내용 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a88a43bb409ce5ce1ef29fd247b1a667d1a95af9" translate="yes" xml:space="preserve">
          <source>Subclass &lt;a href=&quot;parser/result&quot;&gt;TAP::Parser::Result&lt;/a&gt; and register your new result type/class with the default &lt;a href=&quot;parser/resultfactory&quot;&gt;TAP::Parser::ResultFactory&lt;/a&gt;.</source>
          <target state="translated">서브 클래스 &lt;a href=&quot;parser/result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; 및 새로운 결과 유형 / 클래스를 기본 &lt;a href=&quot;parser/resultfactory&quot;&gt;TAP :: Parser :: ResultFactory에&lt;/a&gt; 등록하십시오 .</target>
        </trans-unit>
        <trans-unit id="b9c1095f48c3aca9e5b044be2e9f7d4aebd28ac4" translate="yes" xml:space="preserve">
          <source>Subclass &lt;a href=&quot;parser/resultfactory&quot;&gt;TAP::Parser::ResultFactory&lt;/a&gt; itself and implement your own &lt;a href=&quot;parser/result&quot;&gt;TAP::Parser::Result&lt;/a&gt; creation logic. Then you'll need to customize the class used by your parser by setting the &lt;code&gt;result_factory_class&lt;/code&gt; parameter. See &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;a href=&quot;parser/resultfactory&quot;&gt;TAP :: Parser :: ResultFactory&lt;/a&gt; 자체를 서브 클래스 하고 자신 만의 &lt;a href=&quot;parser/result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; 생성 로직을 구현하십시오 . 그런 다음 &lt;code&gt;result_factory_class&lt;/code&gt; 매개 변수 를 설정하여 구문 분석기가 사용하는 클래스를 사용자 정의해야합니다 . 자세한 내용은 &lt;a href=&quot;#new&quot;&gt;새로운&lt;/a&gt; 내용 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e73f017d1b2756188610b88957a8f09f27806cab" translate="yes" xml:space="preserve">
          <source>Subclass implementations of this method may wish to invoke the &lt;b&gt;nested()&lt;/b&gt; method of &lt;code&gt;$pod_seq&lt;/code&gt; to see if it is nested inside some other interior-sequence (and if so, which kind).</source>
          <target state="translated">이 메소드의 서브 클래스 구현은 &lt;code&gt;$pod_seq&lt;/code&gt; 의 &lt;b&gt;nested ()&lt;/b&gt; 메소드 를 호출하여 그것이 다른 내부 순서 내에 중첩되어 있는지 (그리고 그렇다면 어떤 종류인지) 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="206092a8f1bccf21dc1a96fb2aecc7852ff2c2b3" translate="yes" xml:space="preserve">
          <source>Subclass off of ExtUtils::MM_Any</source>
          <target state="translated">ExtUtils :: MM_Any에서 서브 클래스</target>
        </trans-unit>
        <trans-unit id="c726c3176746b961b1da7788108e104c74c302c2" translate="yes" xml:space="preserve">
          <source>Subclasses will add methods, and will also inherit these methods:</source>
          <target state="translated">서브 클래스는 메소드를 추가하고 다음 메소드도 상속합니다.</target>
        </trans-unit>
        <trans-unit id="f3e2eeeafa90ba07510736c79555f75b3f2683f2" translate="yes" xml:space="preserve">
          <source>Subclassing Math::BigInt</source>
          <target state="translated">서브 클래 싱 수학 :: BigInt</target>
        </trans-unit>
        <trans-unit id="7a1cf3add6a7e4a2dd149344bc26ee4f53a43b6c" translate="yes" xml:space="preserve">
          <source>Subject to include with the message. You will be prompted if you don't supply one on the command line.</source>
          <target state="translated">메시지에 포함되어야합니다. 명령 행에 하나를 제공하지 않으면 프롬프트가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2dacf65959849884a011f36f76a04eebea94c5ea" translate="yes" xml:space="preserve">
          <source>Submit</source>
          <target state="translated">Submit</target>
        </trans-unit>
        <trans-unit id="403bc0e6094ca81cdc2ca6f64a247c639431d231" translate="yes" xml:space="preserve">
          <source>Submit all messages/phrases/etc. to translators.</source>
          <target state="translated">모든 메시지 / 구문 등을 제출하십시오. 번역사에게.</target>
        </trans-unit>
        <trans-unit id="740057b8189ca179a92f1c0babad5e8319eb10b8" translate="yes" xml:space="preserve">
          <source>Submitting patches</source>
          <target state="translated">패치 제출</target>
        </trans-unit>
        <trans-unit id="76ef2c6312acb93997fc9533ac9d5fab3c547483" translate="yes" xml:space="preserve">
          <source>Subroutine Attributes</source>
          <target state="translated">서브 루틴 속성</target>
        </trans-unit>
        <trans-unit id="e505b9988266048dcf61fcc7b04326e41ac00577" translate="yes" xml:space="preserve">
          <source>Subroutine References as Methods</source>
          <target state="translated">메소드로서의 서브 루틴 참조</target>
        </trans-unit>
        <trans-unit id="e0c81de6298b00147539fb1fd776b06104ff3a1b" translate="yes" xml:space="preserve">
          <source>Subroutine Stubs</source>
          <target state="translated">서브 루틴 스텁</target>
        </trans-unit>
        <trans-unit id="ba2c6bab1119398dcc6fbf96d66f3ef433c36e56" translate="yes" xml:space="preserve">
          <source>Subroutine call to a named capture group. Equivalent to &lt;code&gt;(?&amp;amp;NAME)&lt;/code&gt;.</source>
          <target state="translated">명명 된 캡처 그룹에 대한 서브 루틴 호출. &lt;code&gt;(?&amp;amp;NAME)&lt;/code&gt; 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="2db8d18b231e5da42e906ca30c0b2a5d6ae6ff13" translate="yes" xml:space="preserve">
          <source>Subroutine calls and lookups of individual array elements arise often enough that it gets cumbersome to use method 2. As a form of syntactic sugar, the examples for method 2 may be written:</source>
          <target state="translated">개별 배열 요소의 서브 루틴 호출 및 조회는 방법 2를 사용하는 것이 번거로울 정도로 자주 발생합니다. 구문 설탕의 형태로 방법 2의 예를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a4b563566baea0b906bb1fd2aafe77f5b8f15d9" translate="yes" xml:space="preserve">
          <source>Subroutine declarations and definitions may optionally have attribute lists associated with them. (Variable &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; declarations also may, but see the warning below.) Perl handles these declarations by passing some information about the call site and the thing being declared along with the attribute list to this module. In particular, the first example above is equivalent to the following:</source>
          <target state="translated">서브 루틴 선언 및 정의에는 선택적으로 연관된 속성 목록이있을 수 있습니다. ( &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 선언도 다를 수 있지만 아래 경고를 참조하십시오.) Perl은 호출 사이트에 대한 정보와 속성 목록과 함께 선언 된 사항을이 모듈에 전달하여 이러한 선언을 처리합니다. 특히 위의 첫 번째 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1033729ecd127028ccf3e2aa66d4fd8f486f7da3" translate="yes" xml:space="preserve">
          <source>Subroutine defined.</source>
          <target state="translated">서브 루틴이 정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="d9339f9cd00dee3efa9f7f46ee1ed9f5d6e327f1" translate="yes" xml:space="preserve">
          <source>Subroutine definitions (and declarations, for that matter) need not necessarily be situated in the package whose symbol table they occupy. You can define a subroutine outside its package by explicitly qualifying the name of the subroutine:</source>
          <target state="translated">서브 루틴 정의 (및 그 문제에 대한 선언)는 심볼 테이블이 차지하는 패키지에 반드시 위치 할 필요는 없습니다. 서브 루틴 이름을 명시 적으로 규정하여 패키지 외부에서 서브 루틴을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9df428b17a930b0722f07795c93f287fd3afdec" translate="yes" xml:space="preserve">
          <source>Subroutine or method call.</source>
          <target state="translated">서브 루틴 또는 메소드 호출.</target>
        </trans-unit>
        <trans-unit id="e848b12ba1771594d7f90740383f312abe841d15" translate="yes" xml:space="preserve">
          <source>Subroutine references are the simplest case. When the inclusion system walks through @INC and encounters a subroutine, this subroutine gets called with two parameters, the first a reference to itself, and the second the name of the file to be included (e.g., &quot;</source>
          <target state="translated">서브 루틴 참조가 가장 간단한 경우입니다. 포함 시스템이 @INC를 통과하고 서브 루틴을 만나면이 서브 루틴은 두 개의 매개 변수로 호출됩니다. 첫 번째는 자체에 대한 참조이고 두 번째는 포함 할 파일의 이름입니다 (예 : &quot;</target>
        </trans-unit>
        <trans-unit id="b392dcb7d8c01390614814ebacd1c58485fdcd21" translate="yes" xml:space="preserve">
          <source>Subroutines</source>
          <target state="translated">Subroutines</target>
        </trans-unit>
        <trans-unit id="3a9c9397dc48823cce2af70d8aec97a4fb827cbd" translate="yes" xml:space="preserve">
          <source>Subroutines can also return values:</source>
          <target state="translated">서브 루틴은 값을 반환 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cbe2412d3dda1f0b9872899595b0870846f911a" translate="yes" xml:space="preserve">
          <source>Subroutines declarations can also be loaded up with the &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; statement or both loaded and imported into your namespace with a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement. See &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; for details on this.</source>
          <target state="translated">서브 루틴 선언은 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 문으로로드하거나 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 문으로 네임 스페이스로로드 및 가져올 수도 있습니다 . 이에 대한 자세한 내용 은 &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="01b365b15ba275665842a040de4aa6dff221b841" translate="yes" xml:space="preserve">
          <source>Subroutines in multiple packages within the same file are supported - but you should note that this requires exporting the &lt;code&gt;SelfLoader::AUTOLOAD&lt;/code&gt; to every package which requires it. This is done automatically by the &lt;b&gt;SelfLoader&lt;/b&gt; when it first loads the subs into the cache, but you should really specify it in the initialization before the &lt;code&gt;__DATA__&lt;/code&gt; by putting a 'use SelfLoader' statement in each package.</source>
          <target state="translated">동일한 파일 내에서 여러 패키지의 서브 루틴이 지원되지만 &lt;code&gt;SelfLoader::AUTOLOAD&lt;/code&gt; 를 필요한 모든 패키지로 내 보내야 합니다. 이는 서브로드를 캐시에 처음로드 할 때 &lt;b&gt;SelfLoader에&lt;/b&gt; 의해 자동으로 수행 되지만 각 패키지에 'use SelfLoader'문을 넣어 &lt;code&gt;__DATA__&lt;/code&gt; 이전의 초기화에서이를 지정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="908bce63fd3bee1510a99f3549ad888c8938e948" translate="yes" xml:space="preserve">
          <source>Subroutines may be called recursively. If a subroutine is called using the &lt;code&gt;&amp;amp;&lt;/code&gt; form, the argument list is optional, and if omitted, no &lt;code&gt;@_&lt;/code&gt; array is set up for the subroutine: the &lt;code&gt;@_&lt;/code&gt; array at the time of the call is visible to subroutine instead. This is an efficiency mechanism that new users may wish to avoid.</source>
          <target state="translated">서브 루틴은 재귀 적으로 호출 될 수 있습니다. 서브 루틴이 사용하여 호출하는 경우 &lt;code&gt;&amp;amp;&lt;/code&gt; 양식을 인수 목록은 선택 사항입니다, 생략하는 경우에는 &lt;code&gt;@_&lt;/code&gt; 배열이 서브 루틴에 대해 설정된 경우 : &lt;code&gt;@_&lt;/code&gt; 호출시 배열이 대신 서브 루틴 볼 수 있습니다. 이는 새로운 사용자가 피할 수있는 효율성 메커니즘입니다.</target>
        </trans-unit>
        <trans-unit id="cda2b08c81beb1e8e27be40c69e142c7b306247c" translate="yes" xml:space="preserve">
          <source>Subroutines used with ExtUtils::ParseXS</source>
          <target state="translated">ExtUtils :: ParseXS와 함께 사용되는 서브 루틴</target>
        </trans-unit>
        <trans-unit id="3f753412893b86e74de31ef62203854e630f7671" translate="yes" xml:space="preserve">
          <source>Subroutines whose names are in all upper case are reserved to the Perl core, as are modules whose names are in all lower case. A subroutine in all capitals is a loosely-held convention meaning it will be called indirectly by the run-time system itself, usually due to a triggered event. Subroutines whose name start with a left parenthesis are also reserved the same way. The following is a list of some subroutines that currently do special, pre-defined things.</source>
          <target state="translated">이름이 모두 대문자 인 서브 루틴은 이름이 모두 소문자 인 모듈과 마찬가지로 Perl 코어에 예약됩니다. 모든 대문자의 서브 루틴은 느슨하게 유지되는 규칙으로, 일반적으로 트리거 된 이벤트로 인해 런타임 시스템 자체에서 간접적으로 호출됩니다. 이름이 왼쪽 괄호로 시작하는 서브 루틴도 같은 방식으로 예약됩니다. 다음은 현재 사전 정의 된 특수 작업을 수행하는 일부 서브 루틴 목록입니다.</target>
        </trans-unit>
        <trans-unit id="bd995cb059355e488a61a605eadaa870990fb34e" translate="yes" xml:space="preserve">
          <source>Subscribe to perl5-porters, follow the patches and try and understand them; don't be afraid to ask if there's a portion you're not clear on - who knows, you may unearth a bug in the patch...</source>
          <target state="translated">perl5-porter를 구독하고 패치를 따르고 시도하십시오. 명확하지 않은 부분이 있는지 물어 보는 것을 두려워하지 마십시오. 누군가는 패치에서 버그를 발견 할 수 있습니다 ...</target>
        </trans-unit>
        <trans-unit id="a9be04fdf20dd61cb8df7236630151f2b739230f" translate="yes" xml:space="preserve">
          <source>Subscribers to perl5-porters (the porters themselves) come in several flavours. Some are quiet curious lurkers, who rarely pitch in and instead watch the ongoing development to ensure they're forewarned of new changes or features in Perl. Some are representatives of vendors, who are there to make sure that Perl continues to compile and work on their platforms. Some patch any reported bug that they know how to fix, some are actively patching their pet area (threads, Win32, the regexp -engine), while others seem to do nothing but complain. In other words, it's your usual mix of technical people.</source>
          <target state="translated">Perl5 포터 (포터 자체)의 구독자는 여러 가지 맛이 있습니다. 일부는 조용한 호기심이 많은 사람들로, Perl의 새로운 변경 사항이나 기능을 미리 알기 위해 거의 참여하지 않고 지속적인 개발을 지켜보고 있습니다. 일부는 공급 업체의 대표자이며, Perl이 플랫폼에서 계속 컴파일하고 작업 할 수 있도록하는 공급 업체를 대표합니다. 일부는 그들이 고치는 방법을 알고 있다고보고 된 버그를 패치하고, 일부는 그들의 애완 동물 영역 (스레드, Win32, regexp -engine)을 적극적으로 패치하고있는 반면, 다른 것들은 불평하는 것 외에는 아무것도하지 않는 것 같습니다. 다시 말해서, 그것은 당신의 평범한 기술 사람들의 혼합입니다.</target>
        </trans-unit>
        <trans-unit id="4ce7140689363704a8ba85b5261797d063cdadf8" translate="yes" xml:space="preserve">
          <source>Subscripts</source>
          <target state="translated">Subscripts</target>
        </trans-unit>
        <trans-unit id="972581919796c696d3887a640cd0abc4a9d6fe2f" translate="yes" xml:space="preserve">
          <source>Substitute &lt;code&gt;mmk&lt;/code&gt; for &lt;code&gt;mms&lt;/code&gt; above if you're using MMK.</source>
          <target state="translated">MMK를 사용하는 경우 &lt;code&gt;mmk&lt;/code&gt; 를 &lt;code&gt;mms&lt;/code&gt; 로 대체 하십시오 .</target>
        </trans-unit>
        <trans-unit id="014d5a9e6f1c5bae7a50cda20695fb756eee0cc0" translate="yes" xml:space="preserve">
          <source>Substitution of &lt;code&gt;BEGIN { add_100() }&lt;/code&gt; block with:</source>
          <target state="translated">&lt;code&gt;BEGIN { add_100() }&lt;/code&gt; 블록으로 대체 :</target>
        </trans-unit>
        <trans-unit id="821f56dfe7408535081734d464b6578d0a9340e7" translate="yes" xml:space="preserve">
          <source>Substitution-specific modifiers described in</source>
          <target state="translated">에 설명 된 대체 특정 수정 자</target>
        </trans-unit>
        <trans-unit id="a85608dfc0000ff615c1dec302e3be9c2df7837d" translate="yes" xml:space="preserve">
          <source>Substitutions are made with $col and $row in the output string with the following sprintf() line formats:</source>
          <target state="translated">다음 sprintf () 행 형식으로 출력 문자열에서 $ col 및 $ row로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="e9a34939ee76bec97fd549a9a6b322c326e9dbba" translate="yes" xml:space="preserve">
          <source>Substring data about strings that must appear in the final match. This is currently only used internally by Perl's engine, but might be used in the future for all engines for optimisations.</source>
          <target state="translated">마지막으로 일치해야하는 문자열에 대한 부분 문자열 데이터. 이것은 현재 Perl 엔진에서만 내부적으로 사용되지만 향후 모든 엔진에서 최적화를 위해 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3de3a6f2fafae521ea8d2aedc747771ba7ff68a0" translate="yes" xml:space="preserve">
          <source>Subtests were released in Test::More 0.94, which came with Perl 5.12.0. Subtests did not implicitly call &lt;code&gt;done_testing()&lt;/code&gt; until 0.96; the first Perl with that fix was Perl 5.14.0 with 0.98.</source>
          <target state="translated">하위 테스트는 Perl 5.12.0과 함께 제공되는 Test :: More 0.94에서 릴리스되었습니다. 하위 테스트는 0.96까지 내재적으로 &lt;code&gt;done_testing()&lt;/code&gt; 호출하지 않았습니다 . 해당 수정 사항이 포함 된 첫 번째 Perl은 0.98의 Perl 5.14.0입니다.</target>
        </trans-unit>
        <trans-unit id="8a773e71238655167a41521fa50857f3f27293a6" translate="yes" xml:space="preserve">
          <source>Subtleties of this behavior may be platform-dependent and may change in the future.</source>
          <target state="translated">이 동작의 미묘함은 플랫폼에 따라 다를 수 있으며 향후 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae5f61e523ef194692c08eae320b323a03f8bb9b" translate="yes" xml:space="preserve">
          <source>Subtract</source>
          <target state="translated">Subtract</target>
        </trans-unit>
        <trans-unit id="a1c757fe97bd3bdc11456c873d4a95f5772e2115" translate="yes" xml:space="preserve">
          <source>Success results contain:</source>
          <target state="translated">성공 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f918892a0be28ec22ae2148c6c8b20e089383319" translate="yes" xml:space="preserve">
          <source>Successes</source>
          <target state="translated">Successes</target>
        </trans-unit>
        <trans-unit id="9f13946904481800a60a2508acdf81d63816cbc9" translate="yes" xml:space="preserve">
          <source>Successfully tested means that all &quot;make test&quot; runs finish with a result of 100% OK. All tests were conducted with -Duseshrplib set.</source>
          <target state="translated">성공적으로 테스트되었다는 것은 모든 &quot;make test&quot;실행이 100 % OK의 결과로 완료되었음을 의미합니다. 모든 테스트는 -Duseshrplib 세트로 수행되었습니다.</target>
        </trans-unit>
        <trans-unit id="acd9d5af15f64c17e2970ba3b3a2889b142e6fb0" translate="yes" xml:space="preserve">
          <source>Such QP strings can be decoded with:</source>
          <target state="translated">이러한 QP 문자열은 다음을 사용하여 디코딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bd751ae4548def6edde9b711d0020609ff568b3" translate="yes" xml:space="preserve">
          <source>Such code no longer has the desired effect, for two reasons. Firstly, the use of &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; means that the sorting algorithm is not changed until runtime, by which time it's too late to have any effect. Secondly, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort::current&lt;/a&gt;&lt;/code&gt; is also called at run-time, when in fact the compile-time value of &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort::current&lt;/a&gt;&lt;/code&gt; is the one that matters.</source>
          <target state="translated">이러한 코드는 더 이상 두 가지 이유로 원하는 효과가 없습니다. 첫째, &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 한다는 것은 정렬 알고리즘이 런타임까지 변경되지 않아서 효과가 너무 늦다는 것을 의미합니다. 둘째, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort::current&lt;/a&gt;&lt;/code&gt; 는 런타임에 호출되기도합니다. 실제로 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort::current&lt;/a&gt;&lt;/code&gt; 의 컴파일 시간 값 이 중요한 값입니다 .</target>
        </trans-unit>
        <trans-unit id="69ef159fceda5830f0aa82ac39ad009b226aeb52" translate="yes" xml:space="preserve">
          <source>Such combinations can include alternatives, leading to a problem of choice: if we match a regular expression &lt;code&gt;a|ab&lt;/code&gt; against &lt;code&gt;&quot;abc&quot;&lt;/code&gt; , will it match substring &lt;code&gt;&quot;a&quot;&lt;/code&gt; or &lt;code&gt;&quot;ab&quot;&lt;/code&gt; ? One way to describe which substring is actually matched is the concept of backtracking (see &lt;a href=&quot;#Backtracking&quot;&gt;Backtracking&lt;/a&gt;). However, this description is too low-level and makes you think in terms of a particular implementation.</source>
          <target state="translated">이러한 조합은 대안을 포함 할 수 있으며, 선택의 문제가 발생합니다. 정규식 &lt;code&gt;a|ab&lt;/code&gt; 를 &lt;code&gt;&quot;abc&quot;&lt;/code&gt; 와 일치 시키면 하위 문자열 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;ab&quot;&lt;/code&gt; 와 일치 합니까? 실제로 일치하는 문자열을 설명하는 한 가지 방법은 (참조 되돌아의 개념 &lt;a href=&quot;#Backtracking&quot;&gt;역행을&lt;/a&gt; ). 그러나이 설명은 너무 수준이 낮으며 특정 구현 측면에서 생각하게합니다.</target>
        </trans-unit>
        <trans-unit id="54d1b0795c68a81e9549d343de87babe2d5446e2" translate="yes" xml:space="preserve">
          <source>Such commands are explained in the &quot;&lt;a href=&quot;#Formatting-Codes&quot;&gt;Formatting Codes&lt;/a&gt;&quot; section, below.</source>
          <target state="translated">이러한 명령은 아래 의 &quot; &lt;a href=&quot;#Formatting-Codes&quot;&gt;포맷 코드&lt;/a&gt; &quot;섹션에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="610620ff68fcfedc9e4625433127c1fd73d100c6" translate="yes" xml:space="preserve">
          <source>Such constructs are quite frequently used, both because older versions of Perl had no official &lt;code&gt;switch&lt;/code&gt; statement, and also because the new version described immediately below remains experimental and can sometimes be confusing.</source>
          <target state="translated">이러한 구조는 이전 버전의 Perl에 공식적인 &lt;code&gt;switch&lt;/code&gt; 설명 이 없었으며 바로 아래에 설명 된 새 버전이 실험적으로 남아 있고 때로는 혼란 스러울 수 있기 때문에 매우 자주 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="ea3348659ce40b97978cb89e7a2d2a3c12e7d561" translate="yes" xml:space="preserve">
          <source>Such dangers are not peculiar to the locale system: any aspect of an application's environment which may be modified maliciously presents similar challenges. Similarly, they are not specific to Perl: any programming language that allows you to write programs that take account of their environment exposes you to these issues.</source>
          <target state="translated">이러한 위험은 로케일 시스템에만 국한된 것이 아닙니다. 악의적으로 수정 될 수있는 응용 프로그램 환경의 모든 측면에서 비슷한 문제가 발생합니다. 마찬가지로 Perl에만 국한되지는 않습니다. 환경을 고려한 프로그램을 작성할 수있는 프로그래밍 언어는 이러한 문제에 노출됩니다.</target>
        </trans-unit>
        <trans-unit id="92e64e08c8f255e5e8a21829e9acd359d7cc7e25" translate="yes" xml:space="preserve">
          <source>Such literals are accepted by both &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; for doing a version check. Note that using the v-strings for IPv4 addresses is not portable unless you also use the inet_aton()/inet_ntoa() routines of the Socket package.</source>
          <target state="translated">이러한 리터럴은 버전 확인을 수행 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 위해 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 및 use 모두에 의해 허용됩니다 . 소켓 패키지의 inet_aton () / inet_ntoa () 루틴을 사용하지 않으면 IPv4 주소에 v- 문자열을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c45d151cfb183e258e5e363109f24149b1db62ae" translate="yes" xml:space="preserve">
          <source>Such modules should</source>
          <target state="translated">이러한 모듈은</target>
        </trans-unit>
        <trans-unit id="7aa5a2112d8e6f60d9221533518e8ad273984dab" translate="yes" xml:space="preserve">
          <source>Such things aside, you can see that a lot can be achieved with a modest amount of code.</source>
          <target state="translated">이러한 것들을 제외하고는, 적당한 양의 코드로 많은 것을 달성 할 수 있음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="625d4a750d30cd6f4ad0513fdf02b0a356847795" translate="yes" xml:space="preserve">
          <source>Summary Results</source>
          <target state="translated">요약 결과</target>
        </trans-unit>
        <trans-unit id="64d8f92a0739a61061673d891b1afa8db3bbc87d" translate="yes" xml:space="preserve">
          <source>Summary methods</source>
          <target state="translated">요약 방법</target>
        </trans-unit>
        <trans-unit id="bbeaa09c87f3637cdf1095b67ab5a263e83c735c" translate="yes" xml:space="preserve">
          <source>Summary of Option Specifications</source>
          <target state="translated">옵션 사양 요약</target>
        </trans-unit>
        <trans-unit id="90bd8a629095e4d3e067b9ee655f4a7aef77fe44" translate="yes" xml:space="preserve">
          <source>Summary: &lt;code&gt;Configure ... -Dusecbacktrace&lt;/code&gt; and installing the Developer Tools would be good.</source>
          <target state="translated">요약 : &lt;code&gt;Configure ... -Dusecbacktrace&lt;/code&gt; 및 개발자 도구 설치가 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fac6a1b8f230cdc10fcc15f1e97d9ef7d5b8d095" translate="yes" xml:space="preserve">
          <source>Summary: &lt;code&gt;Configure ... -Dusecbacktrace&lt;/code&gt; and you need &lt;code&gt;-lbfd&lt;/code&gt; .</source>
          <target state="translated">요약 : &lt;code&gt;Configure ... -Dusecbacktrace&lt;/code&gt; 이고 &lt;code&gt;-lbfd&lt;/code&gt; 가 필요 합니다 .</target>
        </trans-unit>
        <trans-unit id="7d4dd97ceb3548f78756cbaa9fdb900f6de48597" translate="yes" xml:space="preserve">
          <source>Summing up, Perl numeric values can store only those numbers which have a finite decimal expansion or a &quot;short&quot; binary expansion.</source>
          <target state="translated">요약하자면, Perl 숫자 값은 유한 소수 확장 또는 &quot;짧은&quot;이진 확장을 갖는 숫자 만 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f2aaceda628f6be2c51aa728019480822a4776e" translate="yes" xml:space="preserve">
          <source>Sun Microsystems has released a port of their Sun Studio compilers for Linux. As of November 2005, only an alpha version has been released. Until a release of these compilers is made, support for compiling Perl with these compiler experimental.</source>
          <target state="translated">Sun Microsystems는 Linux 용 Sun Studio 컴파일러의 포트를 출시했습니다. 2005 년 11 월 현재 알파 버전 만 릴리스되었습니다. 이러한 컴파일러가 출시 될 때까지 이러한 컴파일러를 사용하여 Perl을 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c878825d39958359a72cd8a76c4798d5c63452e1" translate="yes" xml:space="preserve">
          <source>Sun and GNU make</source>
          <target state="translated">썬과 GNU make</target>
        </trans-unit>
        <trans-unit id="718d79465fef1629218681af768f2453685f48a1" translate="yes" xml:space="preserve">
          <source>Sun's C Compiler</source>
          <target state="translated">썬의 C 컴파일러</target>
        </trans-unit>
        <trans-unit id="6195b0f6879010bbee2ff42c95d1331cc047feb8" translate="yes" xml:space="preserve">
          <source>SunOS 4.x</source>
          <target state="translated">SunOS 4.x</target>
        </trans-unit>
        <trans-unit id="e16d86479fe3fa44742384e85cda27574322cbc3" translate="yes" xml:space="preserve">
          <source>Supply a comparison function to sort() (described in &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;):</source>
          <target state="translated">정렬을 비교 함수 () (에 기재된 공급 &lt;a href=&quot;functions/sort&quot;&gt;정렬&lt;/a&gt; ) :</target>
        </trans-unit>
        <trans-unit id="de415e5d5000869495451db35dc93df656397ea8" translate="yes" xml:space="preserve">
          <source>Supply a password. If this token is present, the auto-login process will supply the specified string if the remote server requires a password as part of the login process.</source>
          <target state="translated">비밀번호를 입력하십시오. 이 토큰이 있으면 원격 서버에 로그인 프로세스의 일부로 비밀번호가 필요한 경우 자동 로그인 프로세스가 지정된 문자열을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2b5e575cc764d4329007cce80f84811dda7921d8" translate="yes" xml:space="preserve">
          <source>Supply an additional account password. If this token is present, the auto-login process will supply the specified string if the remote server requires an additional account password.</source>
          <target state="translated">추가 계정 비밀번호를 제공하십시오. 이 토큰이 있으면 원격 서버에 추가 계정 암호가 필요한 경우 자동 로그인 프로세스가 지정된 문자열을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="63bb1d0a1fc152b9571b2b05084b5b7573c0a7dc" translate="yes" xml:space="preserve">
          <source>Supply object methods for I/O handles</source>
          <target state="translated">I / O 핸들을위한 공급 오브젝트 메소드</target>
        </trans-unit>
        <trans-unit id="e754d6f0995eab7526c2995e6dd29fc5213bbe9f" translate="yes" xml:space="preserve">
          <source>Supply object methods for directory handles</source>
          <target state="translated">디렉토리 핸들을위한 공급 오브젝트 메소드</target>
        </trans-unit>
        <trans-unit id="9f22ffa5d56d4c5cfa232e27b220356c8959032d" translate="yes" xml:space="preserve">
          <source>Supply object methods for filehandles</source>
          <target state="translated">파일 핸들을위한 공급 객체 메소드</target>
        </trans-unit>
        <trans-unit id="b2a77c0ef03836a7333e41ce4f0c7055106ac057" translate="yes" xml:space="preserve">
          <source>Supply object methods for pipes</source>
          <target state="translated">파이프의 공급 객체 방법</target>
        </trans-unit>
        <trans-unit id="24f8675a681a3fcf0a19ce2f457ac46639a461cc" translate="yes" xml:space="preserve">
          <source>Supply seek based methods for I/O objects</source>
          <target state="translated">I / O 객체에 대한 공급 검색 기반 방법</target>
        </trans-unit>
        <trans-unit id="4577ee52f9d606e12ad2fa9f7ea83ec15081ff52" translate="yes" xml:space="preserve">
          <source>Supplying a count to the</source>
          <target state="translated">에 카운트를 제공</target>
        </trans-unit>
        <trans-unit id="9256abeb61b0e9c2634b93f868b22e3b6be3e559" translate="yes" xml:space="preserve">
          <source>Support for 64-bit Windows added in 5.8 (ActiveState Corp).</source>
          <target state="translated">5.8 (ActiveState Corp)에 64 비트 Windows 지원이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="832ef41556695f42d002862c25aa7f6927ea5c9c" translate="yes" xml:space="preserve">
          <source>Support for 64-bit addressing is experimental: some aspects of Perl may be omitted or buggy. Note the messages output by</source>
          <target state="translated">64 비트 주소 지정 지원은 실험적입니다. Perl의 일부 측면은 생략하거나 버그가있을 수 있습니다. 메시지 출력</target>
        </trans-unit>
        <trans-unit id="dfd649a90bcb497a90c270b395e1aca8e9f13d5a" translate="yes" xml:space="preserve">
          <source>Support for Inside-Out Classes</source>
          <target state="translated">인사이드 아웃 클래스 지원</target>
        </trans-unit>
        <trans-unit id="f74542dacfa191bd88d61863d9855931e106e4c3" translate="yes" xml:space="preserve">
          <source>Support for PERL_OBJECT was added in 5.005 (ActiveState Tool Corp).</source>
          <target state="translated">PERL_OBJECT에 대한 지원이 5.005 (ActiveState Tool Corp)에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="4152d06f964d8c8500926a55fcc080decb5f3944" translate="yes" xml:space="preserve">
          <source>Support for code 3 (italic) is rare and therefore not mentioned in that table. It is not believed to be fully supported by any of the terminals listed, although it's displayed as green in the Linux console, but it is reportedly supported by urxvt.</source>
          <target state="translated">코드 3 (이탈리아)에 대한 지원은 드물기 때문에 해당 표에 언급되어 있지 않습니다. Linux 콘솔에서 녹색으로 표시되지만 urxvt에서 지원되는 것으로 표시되어 있지만 나열된 모든 터미널에서 완벽하게 지원되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="d13a3104d38bfebd2d8edefc71bb43ed89c25719" translate="yes" xml:space="preserve">
          <source>Support for colors 16 through 256 (the &lt;code&gt;ansi&lt;/code&gt; , &lt;code&gt;rgb&lt;/code&gt; , and &lt;code&gt;grey&lt;/code&gt; colors), the &lt;code&gt;:constants256&lt;/code&gt; import tag, the coloralias() function, and support for the ANSI_COLORS_ALIASES environment variable were added in Term::ANSIColor 4.00, included in Perl 5.17.8.</source>
          <target state="translated">16에서 256까지의 색상 ( &lt;code&gt;ansi&lt;/code&gt; , &lt;code&gt;rgb&lt;/code&gt; 및 &lt;code&gt;grey&lt;/code&gt; 색상), &lt;code&gt;:constants256&lt;/code&gt; 가져 오기 태그, coloralias () 함수 및 ANSI_COLORS_ALIASES 환경 변수에 대한 지원이 Perl 5.17에 포함 된 Term :: ANSIColor 4.00에 추가되었습니다. 8.</target>
        </trans-unit>
        <trans-unit id="c9d79655477c957d3ded48d250eed51bd3ecf8ff" translate="yes" xml:space="preserve">
          <source>Support for colors 8 through 15 (the &lt;code&gt;bright_&lt;/code&gt; variants) was added in Term::ANSIColor 3.00, included in Perl 5.13.3.</source>
          <target state="translated">Perl 5.13.3에 포함 된 Term :: ANSIColor 3.00에서 8에서 15까지의 색상 ( &lt;code&gt;bright_&lt;/code&gt; variant)에 대한 지원 이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="3520e7db85802558bb1d2a5a7277d73d6dd7678b" translate="yes" xml:space="preserve">
          <source>Support for concurrent interpreters and the fork() emulation was implemented by ActiveState, with funding from Microsoft Corporation.</source>
          <target state="translated">동시 통역사와 fork () 에뮬레이션에 대한 지원은 Microsoft Corporation의 자금으로 ActiveState에 의해 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="46d9a08c8fe0a5fa65df6f50206b3d6f86276cea" translate="yes" xml:space="preserve">
          <source>Support for dark was added in Term::ANSIColor 1.08, included in Perl 5.8.4.</source>
          <target state="translated">어두운 부분에 대한 지원은 Perl 5.8.4에 포함 된 Term :: ANSIColor 1.08에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="13c3f3679453dc21cf99ba9668b08821dc7c3536" translate="yes" xml:space="preserve">
          <source>Support for external gzip added by Jarkko Hietaniemi &amp;lt;</source>
          <target state="translated">Jarkko Hietaniemi가 추가 한 외부 gzip 지원 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="c1d15c06235a8f38ea6479c09486fef84b83b91c" translate="yes" xml:space="preserve">
          <source>Support for fork() emulation was added in 5.6 (ActiveState Tool Corp).</source>
          <target state="translated">fork () 에뮬레이션에 대한 지원이 5.6 (ActiveState Tool Corp)에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="4da419edd1ac30a4a7b7cbe60b1ff8e03675397f" translate="yes" xml:space="preserve">
          <source>Support for globally overriding glob() (GSAR 3-JUN-98)</source>
          <target state="translated">글로벌 오버라이드 glob () 지원 (GSAR 3-JUN-98)</target>
        </trans-unit>
        <trans-unit id="52d4e9ac29525e6d8e33903392c09e0782a71a40" translate="yes" xml:space="preserve">
          <source>Support for italic was added in Term::ANSIColor 3.02, included in Perl 5.17.1.</source>
          <target state="translated">기울임 꼴 지원은 Perl 5.17.1에 포함 된 Term :: ANSIColor 3.02에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="0fee3b6033badb5f9d6b2ad7b4bd90ed22c35a68" translate="yes" xml:space="preserve">
          <source>Support for swapping real and effective user and group IDs is incomplete. On WinNT Cygwin provides &lt;code&gt;setuid()&lt;/code&gt; , &lt;code&gt;seteuid()&lt;/code&gt; , &lt;code&gt;setgid()&lt;/code&gt; and &lt;code&gt;setegid()&lt;/code&gt; . However, additional Cygwin calls for manipulating WinNT access tokens and security contexts are required.</source>
          <target state="translated">실제적이고 효과적인 사용자 및 그룹 ID 교환에 대한 지원이 불완전합니다. WinNT에서 Cygwin은 &lt;code&gt;setuid()&lt;/code&gt; , &lt;code&gt;seteuid()&lt;/code&gt; , &lt;code&gt;setgid()&lt;/code&gt; 및 &lt;code&gt;setegid()&lt;/code&gt; 합니다. 그러나 WinNT 액세스 토큰 및 보안 컨텍스트 조작을위한 추가 Cygwin 호출이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="112d45f23a800f84de37770824448a89f7d793b8" translate="yes" xml:space="preserve">
          <source>Support for this module is provided via the datetime@perl.org email list. See &lt;a href=&quot;http://lists.perl.org/&quot;&gt;http://lists.perl.org/&lt;/a&gt; for more details.</source>
          <target state="translated">이 모듈에 대한 지원은 datetime@perl.org 이메일 목록을 통해 제공됩니다. 자세한 내용은 &lt;a href=&quot;http://lists.perl.org/&quot;&gt;http://lists.perl.org/&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="75b47c288b94e063b5e848ebb4c141831f2f842b" translate="yes" xml:space="preserve">
          <source>Support for threads extends beyond the code in this module (i.e.,</source>
          <target state="translated">스레드 지원은이 모듈의 코드를 넘어 확장됩니다 (예 :</target>
        </trans-unit>
        <trans-unit id="4ebd54c9803d67645a6bec6e8a530fc77962d822" translate="yes" xml:space="preserve">
          <source>Supported Colors</source>
          <target state="translated">지원되는 색상</target>
        </trans-unit>
        <trans-unit id="a65b7f12a991185f44b505808bc867e90d749e20" translate="yes" xml:space="preserve">
          <source>Supported Compilers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a182e900ad0b28f084dbe30c2f1ab8dc81f123a" translate="yes" xml:space="preserve">
          <source>Supported Platforms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49b953a7424bb44dd08394b0aeda11553bb12089" translate="yes" xml:space="preserve">
          <source>Supported Platforms (Perl 5.8)</source>
          <target state="translated">지원되는 플랫폼 (Perl 5.8)</target>
        </trans-unit>
        <trans-unit id="b1429d26115432e6f40c246dd70a7c60030a0632" translate="yes" xml:space="preserve">
          <source>Supported are: &lt;code&gt;build_requires_install_policy&lt;/code&gt; , &lt;code&gt;check_sigs&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;make_install_make_command&lt;/code&gt; , &lt;code&gt;prefer_installer&lt;/code&gt; , &lt;code&gt;test_report&lt;/code&gt; . Please report as a bug when you need another one supported.</source>
          <target state="translated">지원 : &lt;code&gt;build_requires_install_policy&lt;/code&gt; , &lt;code&gt;check_sigs&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;make_install_make_command&lt;/code&gt; , &lt;code&gt;prefer_installer&lt;/code&gt; , &lt;code&gt;test_report&lt;/code&gt; . 지원되는 다른 버그가 필요할 때 버그로보고하십시오.</target>
        </trans-unit>
        <trans-unit id="fef4367afdb333ca61c98475adcf339702a0de4a" translate="yes" xml:space="preserve">
          <source>Supported arguments are the same as for C</source>
          <target state="translated">지원되는 인수는 C와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="0aee30f240e3b0641c58b8ea19a5ce4e73c13514" translate="yes" xml:space="preserve">
          <source>Supported versions of Perl</source>
          <target state="translated">지원되는 Perl 버전</target>
        </trans-unit>
        <trans-unit id="4ab85bed1d3b1a215699ee5c1c8be8f331ffab56" translate="yes" xml:space="preserve">
          <source>Supports the same options as the C</source>
          <target state="translated">C와 동일한 옵션을 지원합니다</target>
        </trans-unit>
        <trans-unit id="68a10bfa60258c2bbfe38e9f1a7ff60f4694f8f6" translate="yes" xml:space="preserve">
          <source>Suppose instead, that if no matching &quot;/endpara&quot; tag is found, the &quot;/para&quot; tag refers only to the immediately following paragraph:</source>
          <target state="translated">대신, 일치하는 &quot;/ endpara&quot;태그가 없으면 &quot;/ para&quot;태그가 바로 다음 단락 만 참조한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="4a2e98ea3f847f379e1d62458409b455691002c8" translate="yes" xml:space="preserve">
          <source>Suppose that for some strange reason we need a wrapper around the standard C library function &lt;code&gt;fputs()&lt;/code&gt; . This is all we need:</source>
          <target state="translated">이상한 이유로 표준 C 라이브러리 함수 &lt;code&gt;fputs()&lt;/code&gt; 주위에 랩퍼가 필요하다고 가정하십시오 . 이것이 우리에게 필요한 전부입니다.</target>
        </trans-unit>
        <trans-unit id="e9713a66e131c3277390fd2e0a638134463da779" translate="yes" xml:space="preserve">
          <source>Suppose that in the previous example functions pointers for multiply(), divide(), add(), subtract() are kept in a global C array &lt;code&gt;fp[]&lt;/code&gt; with offsets being &lt;code&gt;multiply_off&lt;/code&gt; , &lt;code&gt;divide_off&lt;/code&gt; , &lt;code&gt;add_off&lt;/code&gt; , &lt;code&gt;subtract_off&lt;/code&gt; . Then one can use</source>
          <target state="translated">이전 예제 함수에서 multiply (), divide (), add (), subtract ()에 대한 포인터 가 오프셋이 &lt;code&gt;multiply_off&lt;/code&gt; , &lt;code&gt;divide_off&lt;/code&gt; , &lt;code&gt;add_off&lt;/code&gt; , &lt;code&gt;subtract_off&lt;/code&gt; 인 전역 C 배열 &lt;code&gt;fp[]&lt;/code&gt; 유지 된다고 가정 합니다. 그런 다음 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="f6b728cf8454bb8ebd395d51ef450a37f61ee3df" translate="yes" xml:space="preserve">
          <source>Suppose that we want to enable a new RE escape-sequence &lt;code&gt;\Y|&lt;/code&gt; which matches at a boundary between whitespace characters and non-whitespace characters. Note that &lt;code&gt;(?=\S)(?&amp;lt;!\S)|(?!\S)(?&amp;lt;=\S)&lt;/code&gt; matches exactly at these positions, so we want to have each &lt;code&gt;\Y|&lt;/code&gt; in the place of the more complicated version. We can create a module &lt;code&gt;customre&lt;/code&gt; to do this:</source>
          <target state="translated">새로운 RE 이스케이프 시퀀스를 사용하려고한다고 가정합니다. &lt;code&gt;\Y|&lt;/code&gt; 공백 문자와 공백이 아닌 문자의 경계에서 일치합니다. 하는 것으로는 &lt;code&gt;(?=\S)(?&amp;lt;!\S)|(?!\S)(?&amp;lt;=\S)&lt;/code&gt; 우리가 서로 갖고 싶어, 그래서 정확히이 위치에서 일치 &lt;code&gt;\Y|&lt;/code&gt; 더 복잡한 버전 대신에. &lt;code&gt;customre&lt;/code&gt; 위해 모듈 사용자 정의 를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5ab2eaff078de5c28b462a36a77339cffbb8f320" translate="yes" xml:space="preserve">
          <source>Suppose that you have some C files implementing some functionality, and the corresponding header files. How to create an extension which makes this functionality accessible in Perl? The example below assumes that the header files are</source>
          <target state="translated">일부 기능을 구현하는 C 파일과 해당 헤더 파일이 있다고 가정하십시오. Perl에서이 기능에 액세스 할 수 있도록 확장 기능을 만드는 방법은 무엇입니까? 아래 예제는 헤더 파일이</target>
        </trans-unit>
        <trans-unit id="e38ce69c0f981610bad14796ceb31eadf517ce86" translate="yes" xml:space="preserve">
          <source>Suppose you want to create an object which is accessible as both an array reference and a hash reference.</source>
          <target state="translated">배열 참조와 해시 참조로 액세스 할 수있는 객체를 생성한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="abacd026fc80e9051241fe69f59c13539803bbd4" translate="yes" xml:space="preserve">
          <source>Suppose you want to match all of consecutive pairs of digits in a string like &quot;1122a44&quot; and stop matching when you encounter non-digits. You want to match &lt;code&gt;11&lt;/code&gt; and &lt;code&gt;22&lt;/code&gt; but the letter &amp;lt;a&amp;gt; shows up between &lt;code&gt;22&lt;/code&gt; and &lt;code&gt;44&lt;/code&gt; and you want to stop at &lt;code&gt;a&lt;/code&gt; . Simply matching pairs of digits skips over the &lt;code&gt;a&lt;/code&gt; and still matches &lt;code&gt;44&lt;/code&gt; .</source>
          <target state="translated">&quot;1122a44&quot;와 같은 문자열에서 모든 연속적인 숫자 쌍을 일치시키고 숫자가 아닌 경우 일치를 중지한다고 가정하십시오. &lt;code&gt;11&lt;/code&gt; 과 &lt;code&gt;22&lt;/code&gt; 를 일치 시키려고하지만 &amp;lt;a&amp;gt; 문자가 &lt;code&gt;22&lt;/code&gt; 와 &lt;code&gt;44&lt;/code&gt; 사이에 표시 되고 &lt;code&gt;a&lt;/code&gt; 에서 멈추려 고 합니다 . 단순히 일치하는 숫자 쌍은 &lt;code&gt;a&lt;/code&gt; 를 건너 뛰고 여전히 &lt;code&gt;44&lt;/code&gt; 와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="99f46adab557fd8dab8b4b0b09a159b2654c69a5" translate="yes" xml:space="preserve">
          <source>Suppose you wanted to match only the allocated characters, not the raw block ranges: in other words, you want to remove the unassigned characters:</source>
          <target state="translated">원시 블록 범위가 아닌 할당 된 문자 만 일치 시키려고한다고 가정하십시오. 즉, 할당되지 않은 문자를 제거하려고합니다.</target>
        </trans-unit>
        <trans-unit id="7282725934a73028b4873e419044ca1541b7ef81" translate="yes" xml:space="preserve">
          <source>Suppose your function looks like this:</source>
          <target state="translated">함수가 다음과 같다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="3cdc33b87c0a24861f5653d7a4749ecf4d10599b" translate="yes" xml:space="preserve">
          <source>Suppress statically defined functions from the profile.</source>
          <target state="translated">프로파일에서 정적으로 정의 된 기능을 억제하십시오.</target>
        </trans-unit>
        <trans-unit id="f000eea4b15966462d081470a0dbb8675e040042" translate="yes" xml:space="preserve">
          <source>Suppress the verbose descriptions in the profile.</source>
          <target state="translated">프로파일에서 자세한 설명을 억제하십시오.</target>
        </trans-unit>
        <trans-unit id="fe4ca7a4b62d0d93f13a11c00e6e1ef2ac15f93d" translate="yes" xml:space="preserve">
          <source>Suppressing Lines Where All Fields Are Void</source>
          <target state="translated">모든 필드가 비어있는 라인 억제</target>
        </trans-unit>
        <trans-unit id="f8a4d33a75006d37aaaa326a12ea28f45b06e609" translate="yes" xml:space="preserve">
          <source>Suppressing all output.</source>
          <target state="translated">모든 출력을 억제합니다.</target>
        </trans-unit>
        <trans-unit id="4db0aec339465e45f71592f3d61d3b7d5519b564" translate="yes" xml:space="preserve">
          <source>Suppressing everything but the tests summary.</source>
          <target state="translated">테스트 요약을 제외한 모든 것을 억제합니다.</target>
        </trans-unit>
        <trans-unit id="3118002fe0231bc240b745efda50a51f4811af55" translate="yes" xml:space="preserve">
          <source>Suppressing some test output (mostly failures while tests are running).</source>
          <target state="translated">일부 테스트 출력 억제 (주로 테스트 실행 중 실패)</target>
        </trans-unit>
        <trans-unit id="aaf2f474284f3bb3469459a5f2e282c817445e0a" translate="yes" xml:space="preserve">
          <source>Surprisingly, the following dangerous-looking construct will actually work out fine:</source>
          <target state="translated">놀랍게도 다음과 같은 위험한 구조는 실제로 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="89de18d6062f8f62c80480423d64e1771fc8ce04" translate="yes" xml:space="preserve">
          <source>Surprisingly, the routines to be called are named &lt;code&gt;freeze&lt;/code&gt; and &lt;code&gt;thaw&lt;/code&gt; . If you wish to send out the frozen scalar to another machine, use &lt;code&gt;nfreeze&lt;/code&gt; instead to get a portable image.</source>
          <target state="translated">놀랍게도, 호출 될 루틴의 이름은 &lt;code&gt;freeze&lt;/code&gt; and &lt;code&gt;thaw&lt;/code&gt; 입니다. 고정 된 스칼라를 다른 머신으로 보내 &lt;code&gt;nfreeze&lt;/code&gt; 대신 휴대용 이미지를 얻기 위해 nfreeze 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c6a047875b873f6d1d398e86dbb7108d34705540" translate="yes" xml:space="preserve">
          <source>Surrogate Pairs</source>
          <target state="translated">대리 쌍</target>
        </trans-unit>
        <trans-unit id="07a0eab00168ce9bedc809f5ad8c9eb56cbd1edb" translate="yes" xml:space="preserve">
          <source>Surrogate pairs were born when the Unicode Consortium finally admitted that 16 bits were not big enough to hold all the world's character repertoires. But they already made UCS-2 16-bit. What do we do?</source>
          <target state="translated">유니 코드 컨소시엄이 16 비트가 세계의 모든 문자 레퍼토리를 보유 할만큼 크지 않다는 것을 마침내 인정했을 때 대리 쌍이 탄생했습니다. 그러나 그들은 이미 UCS-2를 16 비트로 만들었습니다. 우리는 무엇을해야합니까?</target>
        </trans-unit>
        <trans-unit id="1eaaa69a37b20a485ea6f0e51d7a77d119e19f29" translate="yes" xml:space="preserve">
          <source>Surrogates are code points set aside to encode the &lt;code&gt;U+10000..U+10FFFF&lt;/code&gt; range of Unicode code points in pairs of 16-bit units. The</source>
          <target state="translated">서로 게이트는 16 비트 단위의 쌍으로 유니 코드 코드 포인트 의 &lt;code&gt;U+10000..U+10FFFF&lt;/code&gt; 범위 를 인코딩하기 위해 별도로 마련된 코드 포인트입니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="856dbe523b5bc18c3ac9b4ef67ed5a73d664d082" translate="yes" xml:space="preserve">
          <source>Surrogates have no meaning in Unicode outside their use in pairs to represent other code points. However, Perl allows them to be represented individually internally, for example by saying &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(0xD801)&lt;/a&gt;&lt;/code&gt;, so that all code points, not just those valid for open interchange, are representable. Unicode does define semantics for them, such as their &lt;code&gt;&lt;a href=&quot;#General_Category&quot;&gt;General_Category&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&quot;Cs&quot;&lt;/code&gt; . But because their use is somewhat dangerous, Perl will warn (using the warning category &lt;code&gt;&quot;surrogate&quot;&lt;/code&gt; , which is a sub-category of &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; ) if an attempt is made to do things like take the lower case of one, or match case-insensitively, or to output them. (But don't try this on Perls before 5.14.)</source>
          <target state="translated">대리자는 다른 코드 포인트를 나타 내기 위해 쌍으로 사용하는 것 외에는 유니 코드에서 의미가 없습니다. 그러나 Perl은 예를 들어 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(0xD801)&lt;/a&gt;&lt;/code&gt; 을 말함으로써 내부적으로 개별적으로 표현 될 수있게하여 오픈 인터체인지에 유효한 것만이 아닌 모든 코드 포인트가 표현 될 수 있도록합니다. 유니 코드는 &lt;code&gt;&lt;a href=&quot;#General_Category&quot;&gt;General_Category&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&quot;Cs&quot;&lt;/code&gt; 와 같이 시맨틱을 정의합니다 . 자신의 사용은 다소 위험하므로 그러나 펄은 (경고 범주 사용하여 경고합니다 &lt;code&gt;&quot;surrogate&quot;&lt;/code&gt; 의 하위 범주입니다, &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; 낮은 한 경우, 또는 일치하는 사건을 맡아 같은 시도가 일을하게되는 경우를) -무감각하게 또는 출력합니다. (그러나 5.14 이전에는 Perls에서 시도하지 마십시오.)</target>
        </trans-unit>
        <trans-unit id="540da7a8cd172c1838160d487b9d7ef0924efc97" translate="yes" xml:space="preserve">
          <source>Suspicious Warnings on Cygwin</source>
          <target state="translated">Cygwin에 대한 의심스러운 경고</target>
        </trans-unit>
        <trans-unit id="1e1cd0c78512c809bc8f82ce5a88755a660fc1dd" translate="yes" xml:space="preserve">
          <source>SvIV()</source>
          <target state="translated">SvIV()</target>
        </trans-unit>
        <trans-unit id="dbc4878fd112ac06a09fc11cde47bb125aee2c3f" translate="yes" xml:space="preserve">
          <source>SvNV()</source>
          <target state="translated">SvNV()</target>
        </trans-unit>
        <trans-unit id="935c09deb58ecb63d6891adc1aabec93c4c8a5b7" translate="yes" xml:space="preserve">
          <source>SvPV()</source>
          <target state="translated">SvPV()</target>
        </trans-unit>
        <trans-unit id="d644182b7fecca2e84a27663743f7d7d1731110e" translate="yes" xml:space="preserve">
          <source>SvTHINKFIRST sometimes produces false positives. In those cases sv_force_normal does nothing.</source>
          <target state="translated">SvTHINKFIRST는 때때로 오 탐지를 생성합니다. 이 경우 sv_force_normal은 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7d140830d04307683300b42c263a4bad9b2b05e6" translate="yes" xml:space="preserve">
          <source>Switch Statements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bd9a48c2b8a06497ad155d8fb2e22e3efb40ec2" translate="yes" xml:space="preserve">
          <source>Switch off optimizations.</source>
          <target state="translated">최적화를 끕니다.</target>
        </trans-unit>
        <trans-unit id="3bb7fa365adb6d9413c8c9a8c7435723660691af" translate="yes" xml:space="preserve">
          <source>Switch to viewing a different file or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; statement. If</source>
          <target state="translated">다른 파일 또는 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 문 보기로 전환하십시오 . 만약</target>
        </trans-unit>
        <trans-unit id="941726dc5468b689bfb5334269ab159c8c5ac044" translate="yes" xml:space="preserve">
          <source>Switches On the &quot;#!&quot; Line</source>
          <target state="translated">&quot;#!&quot;스위치 선</target>
        </trans-unit>
        <trans-unit id="22865b749e47c4f80690e8fbf02747aa53e87248" translate="yes" xml:space="preserve">
          <source>Switches include:</source>
          <target state="translated">스위치에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1a104dee1272b5ea48fa02cf2cd55d0cf5980bda" translate="yes" xml:space="preserve">
          <source>Switches which take an argument don't care whether there is a space between the switch and the argument. If unspecified switches are found on the command-line, the user will be warned that an unknown option was given.</source>
          <target state="translated">인수를 취하는 스위치는 스위치와 인수 사이에 공백이 있는지 여부는 상관하지 않습니다. 명령 줄에 지정되지 않은 스위치가 있으면 알 수없는 옵션이 제공되었다는 경고 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="88a10266365bec895433e46eaf4bb0d9f4319fa6" translate="yes" xml:space="preserve">
          <source>Switching in a loop</source>
          <target state="translated">루프에서 전환</target>
        </trans-unit>
        <trans-unit id="c4833a3fbcd559394f2c58d1f54c950e1415a542" translate="yes" xml:space="preserve">
          <source>Sx is an interface to the Athena widget set which comes with X, but again it appears not to be much used nowadays.</source>
          <target state="translated">Sx는 X와 함께 제공되는 Athena 위젯 세트에 대한 인터페이스이지만 요즘에는 많이 사용되지 않는 것으로 보입니다.</target>
        </trans-unit>
        <trans-unit id="3f84ef531f9db996694ad09a8fdddbca1440577e" translate="yes" xml:space="preserve">
          <source>Symbol</source>
          <target state="translated">Symbol</target>
        </trans-unit>
        <trans-unit id="6f23f00b2c5559251a269c3e95612a03f0fa5304" translate="yes" xml:space="preserve">
          <source>Symbol - manipulate Perl symbols and their names</source>
          <target state="translated">기호-Perl 기호 및 이름 조작</target>
        </trans-unit>
        <trans-unit id="e2434de5e406913ebf6a3ac33e80e10d4a315aea" translate="yes" xml:space="preserve">
          <source>Symbol Encodings</source>
          <target state="translated">심볼 인코딩</target>
        </trans-unit>
        <trans-unit id="d794fc2c3b0c30f40edbe0d808d2368ffeb21d98" translate="yes" xml:space="preserve">
          <source>Symbol Tables</source>
          <target state="translated">심벌 테이블</target>
        </trans-unit>
        <trans-unit id="4b05d7078c77af4d667a4898e87b6c3188ae4b11" translate="yes" xml:space="preserve">
          <source>Symbolic Calculator</source>
          <target state="translated">상징적 인 계산기</target>
        </trans-unit>
        <trans-unit id="37008620b710f26771f72ef684d0d762ce0c312d" translate="yes" xml:space="preserve">
          <source>Symbolic Links</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0a9fa28cc57e07ecbedf349e28f66a417dbd550" translate="yes" xml:space="preserve">
          <source>Symbolic Unary Operators</source>
          <target state="translated">상징적 인 단항 연산자</target>
        </trans-unit>
        <trans-unit id="c85b29041363945d0d38e6dd76ab2012cab61284" translate="yes" xml:space="preserve">
          <source>Symbolic links will be replicated in the destination directory. If &lt;b&gt;-l&lt;/b&gt; is not specified, then links are skipped over.</source>
          <target state="translated">심볼릭 링크는 대상 디렉토리에 복제됩니다. 경우 &lt;b&gt;-l이&lt;/b&gt; 지정되지 않은, 다음 링크를 통해 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="5740fe00b50befc25ecdbfe2ce1dcb268f365ae5" translate="yes" xml:space="preserve">
          <source>Symbolic methods</source>
          <target state="translated">상징적 방법</target>
        </trans-unit>
        <trans-unit id="2ed5a46b240bca78e1ebda87bbf53e151430ff41" translate="yes" xml:space="preserve">
          <source>Symbolic references</source>
          <target state="translated">상징적 참조</target>
        </trans-unit>
        <trans-unit id="11ea83f8147883e582553aebb48729beba5bdaf1" translate="yes" xml:space="preserve">
          <source>Symbolic references are forbidden under the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; pragma. They are not true references and consequently are not reference-counted or garbage-collected.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; pragma 에서는 기호 참조가 금지되어 &lt;a href=&quot;functions/use&quot;&gt;있습니다&lt;/a&gt; . 그것들은 실제 참조가 아니며 결과적으로 참조 수 또는 가비지 수집되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2a3d231a255923086dc7e82179bb6e9c216f886c" translate="yes" xml:space="preserve">
          <source>Symbolic references are names of variables or other objects, just as a symbolic link in a Unix filesystem contains merely the name of a file. The &lt;code&gt;*glob&lt;/code&gt; notation is something of a symbolic reference. (Symbolic references are sometimes called &quot;soft references&quot;, but please don't call them that; references are confusing enough without useless synonyms.)</source>
          <target state="translated">기호 참조는 Unix 파일 시스템의 기호 링크에 파일 이름 만 포함 된 것처럼 변수 또는 다른 객체의 이름입니다. &lt;code&gt;*glob&lt;/code&gt; 표기는 심볼릭 참조의 무언가이다. (심볼 참조는 &quot;소프트 참조&quot;라고도하지만 호출하지 마십시오. 참조는 쓸모없는 동의어없이 충분히 혼란 스럽습니다.)</target>
        </trans-unit>
        <trans-unit id="7eb647835a30e5a1bbf74157fa14f494b596a5c9" translate="yes" xml:space="preserve">
          <source>Symbols representing the concepts &amp;ldquo;and&amp;rdquo;, &amp;ldquo;or&amp;rdquo;, &amp;ldquo;xor&amp;rdquo;, and &amp;ldquo;not&amp;rdquo;.</source>
          <target state="translated">개념 &quot;and&quot;, &quot;or&quot;, &quot;xor&quot;및 &quot;not&quot;을 나타내는 기호</target>
        </trans-unit>
        <trans-unit id="bc32943d7841b88a1cf40309071785aab7d4e9d1" translate="yes" xml:space="preserve">
          <source>Synchronization and control</source>
          <target state="translated">동기화 및 제어</target>
        </trans-unit>
        <trans-unit id="fd6877f381ee0675d5bd925a8ea887b401ae7a51" translate="yes" xml:space="preserve">
          <source>Synonymous options (like both the short and long forms) are separated by a comma and a space on the same &lt;code&gt;=item&lt;/code&gt; line, or optionally listed as their own item with a reference to the canonical name. For example, since &lt;b&gt;--section&lt;/b&gt; can also be written as &lt;b&gt;-s&lt;/b&gt;, the above would be:</source>
          <target state="translated">동의어 옵션 (짧은 형식과 긴 형식 모두)은 동일한 &lt;code&gt;=item&lt;/code&gt; 줄 에 쉼표와 공백으로 구분 되거나 선택적으로 표준 이름을 참조하여 자체 항목으로 나열됩니다. 예를 들어 &lt;b&gt;--section&lt;/b&gt; 을 &lt;b&gt;-s&lt;/b&gt; 로 쓸 수도 있으므로 위의 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fcbf093f7bdc572a445b9a43606c7f7a83836b33" translate="yes" xml:space="preserve">
          <source>Synonyms for &lt;code&gt;recipient&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;recipient&lt;/code&gt; 동의어 .</target>
        </trans-unit>
        <trans-unit id="36c0630a340d2960affa1c4d2360b0e2c06793fb" translate="yes" xml:space="preserve">
          <source>Synopsis</source>
          <target state="translated">Synopsis</target>
        </trans-unit>
        <trans-unit id="af5f0a5e089ff24df87876664a300fc1d94de87c" translate="yes" xml:space="preserve">
          <source>Synopsis:</source>
          <target state="translated">Synopsis:</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="e90738f5d4b2229f3a4c124484c36b1275df5262" translate="yes" xml:space="preserve">
          <source>Syntax for invoking shar, tar and zip differs from that for Unix.</source>
          <target state="translated">shar, tar 및 zip을 호출하는 구문은 Unix의 구문과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="7d8c7607abfe852f9a6ad8648332314d9917e637" translate="yes" xml:space="preserve">
          <source>Syntax of Attribute Lists</source>
          <target state="translated">속성 목록의 구문</target>
        </trans-unit>
        <trans-unit id="1de8dba368e7754dc199c99b017f5c51265ee8dc" translate="yes" xml:space="preserve">
          <source>Syntax:</source>
          <target state="translated">Syntax:</target>
        </trans-unit>
        <trans-unit id="0785d5c2121b7134c4af7c65680f001acb76a92c" translate="yes" xml:space="preserve">
          <source>Sys$Library</source>
          <target state="translated">Sys$Library</target>
        </trans-unit>
        <trans-unit id="65fb3d73b0b7d628e2887a67776fd305bc37b9e6" translate="yes" xml:space="preserve">
          <source>Sys$Share</source>
          <target state="translated">Sys$Share</target>
        </trans-unit>
        <trans-unit id="dbb39438e97d2bc740ddc791cb728708fa6deab2" translate="yes" xml:space="preserve">
          <source>Sys$System:</source>
          <target state="translated">Sys$System:</target>
        </trans-unit>
        <trans-unit id="48fee1621e8e0fbac3a51bb7b722933258b770f4" translate="yes" xml:space="preserve">
          <source>Sys::Hostname</source>
          <target state="translated">Sys::Hostname</target>
        </trans-unit>
        <trans-unit id="2e415aac42b72faad3c72367e40e8717dbc66b3c" translate="yes" xml:space="preserve">
          <source>Sys::Hostname - Try every conceivable way to get hostname</source>
          <target state="translated">Sys :: Hostname-가능한 모든 방법으로 호스트 이름을 얻으십시오</target>
        </trans-unit>
        <trans-unit id="c1e878d92efc49a2e4d7c74bab56ecb4df79e136" translate="yes" xml:space="preserve">
          <source>Sys::Syslog</source>
          <target state="translated">Sys::Syslog</target>
        </trans-unit>
        <trans-unit id="d0e7c26b96f1913c444745d08172cdce4e0c92fa" translate="yes" xml:space="preserve">
          <source>Sys::Syslog - Perl interface to the UNIX syslog(3) calls</source>
          <target state="translated">Sys :: Syslog-UNIX syslog (3) 호출에 대한 Perl 인터페이스</target>
        </trans-unit>
        <trans-unit id="e9c9e6fce8c27f1db38faca8727f60ffbd03b1df" translate="yes" xml:space="preserve">
          <source>SysV IPC</source>
          <target state="translated">SysV IPC</target>
        </trans-unit>
        <trans-unit id="b769fe98988d4570b7169913197897773fb46367" translate="yes" xml:space="preserve">
          <source>SysV Msg IPC object class</source>
          <target state="translated">SysV Msg IPC 객체 클래스</target>
        </trans-unit>
        <trans-unit id="1b5cd833684b7ef6a59dab44ff94b295bccc40b4" translate="yes" xml:space="preserve">
          <source>SysV Semaphore IPC object class</source>
          <target state="translated">SysV 세마포어 IPC 객체 클래스</target>
        </trans-unit>
        <trans-unit id="71c44529ecac23b5c9809ec7a57f43fadf59d867" translate="yes" xml:space="preserve">
          <source>SysV Shared Memory IPC object class</source>
          <target state="translated">SysV 공유 메모리 IPC 객체 클래스</target>
        </trans-unit>
        <trans-unit id="e45e7e358eb9351a96a4b4d44c0db473a81b0bd0" translate="yes" xml:space="preserve">
          <source>Syscall returns whatever value returned by the system call it calls. If the system call fails, &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;-1&lt;/code&gt; and sets &lt;code&gt;$!&lt;/code&gt; (errno). Note that some system calls</source>
          <target state="translated">Syscall은 호출하는 시스템 호출에 의해 반환 된 값을 반환합니다. 시스템 호출이 실패하면 &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;-1&lt;/code&gt; 을 반환 하고 &lt;code&gt;$!&lt;/code&gt; 를 설정합니다 . (errno). 일부 시스템 호출</target>
        </trans-unit>
        <trans-unit id="e0b761d47162708932873aa746a0b31a4af21afe" translate="yes" xml:space="preserve">
          <source>Syscall returns whatever value returned by the system call it calls. If the system call fails, &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;-1&lt;/code&gt; and sets &lt;code&gt;$!&lt;/code&gt; (errno). Note that some system calls</source>
          <target state="translated">Syscall은 호출하는 시스템 호출에 의해 반환 된 값을 반환합니다. 시스템 호출이 실패하면 &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;-1&lt;/code&gt; 을 반환 하고 &lt;code&gt;$!&lt;/code&gt; 를 설정합니다 . (errno). 일부 시스템 호출</target>
        </trans-unit>
        <trans-unit id="53aa71666c5046c70bdb9cfa19d05f3e5e2dbe70" translate="yes" xml:space="preserve">
          <source>Syslogging with Perl</source>
          <target state="translated">Perl로 Syslogging</target>
        </trans-unit>
        <trans-unit id="b9c23727af44d87276c73142b1bbc56acfa2ff99" translate="yes" xml:space="preserve">
          <source>Sysroot.U</source>
          <target state="translated">Sysroot.U</target>
        </trans-unit>
        <trans-unit id="286ad58c359f169cf560ed965ca49713b4161be5" translate="yes" xml:space="preserve">
          <source>System Interaction</source>
          <target state="translated">시스템 상호 작용</target>
        </trans-unit>
        <trans-unit id="a5f5e2adb8b84a09a3496b92bfc8ae6f7818b5f8" translate="yes" xml:space="preserve">
          <source>System Resources</source>
          <target state="translated">시스템 리소스</target>
        </trans-unit>
        <trans-unit id="12920688fafa23a0e3538825316e84488141b30c" translate="yes" xml:space="preserve">
          <source>System Specifics</source>
          <target state="translated">시스템 사양</target>
        </trans-unit>
        <trans-unit id="1c80f9799bbc3cebb5501e8db9a2d073ae25632e" translate="yes" xml:space="preserve">
          <source>System V IPC constants and system calls</source>
          <target state="translated">System V IPC 상수 및 시스템 호출</target>
        </trans-unit>
        <trans-unit id="16956db37d0c77a530acbdbc4b5059785173084f" translate="yes" xml:space="preserve">
          <source>System calls accept either &lt;code&gt;/&lt;/code&gt; or &lt;code&gt;\&lt;/code&gt; as the path separator. However, many command-line utilities of DOS vintage treat &lt;code&gt;/&lt;/code&gt; as the option prefix, so may get confused by filenames containing &lt;code&gt;/&lt;/code&gt;. Aside from calling any external programs, &lt;code&gt;/&lt;/code&gt; will work just fine, and probably better, as it is more consistent with popular usage, and avoids the problem of remembering what to backwhack and what not to.</source>
          <target state="translated">시스템 호출 은 경로 구분자로 &lt;code&gt;/&lt;/code&gt; 또는 &lt;code&gt;\&lt;/code&gt; 를 허용합니다 . 그러나 DOS 빈티지의 많은 명령 줄 유틸리티는 &lt;code&gt;/&lt;/code&gt; 를 옵션 접두어로 취급 하므로 &lt;code&gt;/&lt;/code&gt; 가 포함 된 파일 이름과 혼동 될 수 있습니다 . 외부 프로그램을 호출하는 것 외에도 &lt;code&gt;/&lt;/code&gt; 는 널리 사용되는 것과 더 일관성이 있기 때문에 잘 작동하며 아마도 더 좋을 것입니다. 백킹해야 할 것과 그렇지 않은 것을 기억하는 문제를 피하십시오.</target>
        </trans-unit>
        <trans-unit id="007271cb98a5608fe64c06188e43289d61f1c7bd" translate="yes" xml:space="preserve">
          <source>System calls return -1 on error (setting ERRNO with the reason) and (usually) 0 on success. If the return value is -1 this typemap returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. If the return value is not -1, this typemap translates a 0 (perl false) to &quot;0 but true&quot; (which is perl true) or returns the value itself, to indicate that the command succeeded.</source>
          <target state="translated">시스템 호출은 오류 발생시 -1 (이유로 ERRNO 설정)과 성공시 (보통 0)을 반환합니다. 리턴 값이 -1이면이 유형 맵은 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 리턴합니다 . 리턴 값이 -1이 아닌 경우,이 유형 맵은 0 (perl false)을 &quot;0 but true&quot;(perl true)로 변환하거나 값 자체를 리턴하여 명령이 성공했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="eb78d5fbb36025d1ade73acf0ec1dc017253b7c6" translate="yes" xml:space="preserve">
          <source>System calls such as link(), unlink(), rename(), etc. return nonzero for success, not 0. (system(), however, returns zero for success.)</source>
          <target state="translated">link (), unlink (), rename () 등과 같은 시스템 호출은 성공이 아닌 0이 아닌 0을 반환합니다. (system ()은 성공을 위해 0을 반환합니다.)</target>
        </trans-unit>
        <trans-unit id="a5bfc62972086e83c2f9e4d6647ba3081448737b" translate="yes" xml:space="preserve">
          <source>System errno constants</source>
          <target state="translated">시스템 오류 상수</target>
        </trans-unit>
        <trans-unit id="0464247110efd6dc873ab7d03699ac46391aa089" translate="yes" xml:space="preserve">
          <source>SystemV Interprocess Communications:</source>
          <target state="translated">SystemV 프로세스 간 통신 :</target>
        </trans-unit>
        <trans-unit id="c2c53d66948214258a26ca9ca845d7ac0c17f8e7" translate="yes" xml:space="preserve">
          <source>T</source>
          <target state="translated">T</target>
        </trans-unit>
        <trans-unit id="9f94efb44fe911a9e20566c2b4f9e9743238c25c" translate="yes" xml:space="preserve">
          <source>TABLE OF CONTENTS</source>
          <target state="translated">목차</target>
        </trans-unit>
        <trans-unit id="3b4df05d703541d151d3e3628328bb8fd532308b" translate="yes" xml:space="preserve">
          <source>TAP GRAMMAR</source>
          <target state="translated">탭 문법</target>
        </trans-unit>
        <trans-unit id="1920029d62435d8577df2572dd0096bfaff76178" translate="yes" xml:space="preserve">
          <source>TAP pragma token.</source>
          <target state="translated">TAP 프라 그마 토큰.</target>
        </trans-unit>
        <trans-unit id="a6ad0c7cbda3b41f87bebc3eecd396afa503fee6" translate="yes" xml:space="preserve">
          <source>TAP syntax version token.</source>
          <target state="translated">TAP 구문 버전 토큰.</target>
        </trans-unit>
        <trans-unit id="3876ffd2c762f78e88b10fd7b5ed6b67ff853ed5" translate="yes" xml:space="preserve">
          <source>TAP::Base</source>
          <target state="translated">TAP::Base</target>
        </trans-unit>
        <trans-unit id="393bbdfe5b0291f7582e0a00a859897a43f52662" translate="yes" xml:space="preserve">
          <source>TAP::Base - Base class that provides common functionality to &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt; and &lt;a href=&quot;harness&quot;&gt;TAP::Harness&lt;/a&gt;</source>
          <target state="translated">TAP :: Base- &lt;a href=&quot;parser&quot;&gt;TAP :: Parser&lt;/a&gt; 및 &lt;a href=&quot;harness&quot;&gt;TAP :: Harness에&lt;/a&gt; 공통 기능을 제공하는 기본 클래스</target>
        </trans-unit>
        <trans-unit id="863c519a681845de61f18ccf2d91ed2bae4b3a87" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Base</source>
          <target state="translated">TAP::Formatter::Base</target>
        </trans-unit>
        <trans-unit id="2219301c0e6ab7a0cac653627940a66913b4e00c" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Base - Base class for harness output delegates</source>
          <target state="translated">TAP :: Formatter :: Base-하네스 출력 대리자를위한 기본 클래스</target>
        </trans-unit>
        <trans-unit id="737a5324c5901c02f42ad717687b54b1dafd7c3b" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Color</source>
          <target state="translated">TAP::Formatter::Color</target>
        </trans-unit>
        <trans-unit id="83dc9a13e5e40b4cace713c5d42771d2b5bb47e0" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Color - Run Perl test scripts with color</source>
          <target state="translated">TAP :: Formatter :: Color-색상으로 Perl 테스트 스크립트 실행</target>
        </trans-unit>
        <trans-unit id="de057ff7c6b5e40851d3c50d32e9750e339c5926" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Console</source>
          <target state="translated">TAP::Formatter::Console</target>
        </trans-unit>
        <trans-unit id="e5caa85b06270fe34451b375ee12674e638dd733" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Console - Harness output delegate for default console output</source>
          <target state="translated">TAP :: Formatter :: Console-기본 콘솔 출력용 하네스 출력 대리자</target>
        </trans-unit>
        <trans-unit id="01b7c503e4f8a4af70b89b685b263fa99a7779a7" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Console::ParallelSession</source>
          <target state="translated">TAP::Formatter::Console::ParallelSession</target>
        </trans-unit>
        <trans-unit id="db7bd0c049621f91358c7128fbd5472680ec6d31" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Console::ParallelSession - Harness output delegate for parallel console output</source>
          <target state="translated">TAP :: Formatter :: Console :: ParallelSession-병렬 콘솔 출력용 하네스 출력 대리자</target>
        </trans-unit>
        <trans-unit id="e10aa0877a249858e704e343610555a15b6331f0" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Console::Session</source>
          <target state="translated">TAP::Formatter::Console::Session</target>
        </trans-unit>
        <trans-unit id="617e83a9b0bba0c6a87c6403d55512035b5d4331" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Console::Session - Harness output delegate for default console output</source>
          <target state="translated">TAP :: Formatter :: Console :: Session-기본 콘솔 출력용 하네스 출력 대리자</target>
        </trans-unit>
        <trans-unit id="ebcc51d604eabcfa523d96f91dc1b0eb51dccb7d" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::File</source>
          <target state="translated">TAP::Formatter::File</target>
        </trans-unit>
        <trans-unit id="ce9e5131d6998f180ee6abe8bad4643f869cfb3d" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::File - Harness output delegate for file output</source>
          <target state="translated">TAP :: Formatter :: File-파일 출력용 하네스 출력 대리자</target>
        </trans-unit>
        <trans-unit id="5a53ebb59dd4ba13f5939d6a9f81cddf3e1c6f45" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::File::Session</source>
          <target state="translated">TAP::Formatter::File::Session</target>
        </trans-unit>
        <trans-unit id="360d8f026e4e5483612bf0275831836f9ffb249f" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::File::Session - Harness output delegate for file output</source>
          <target state="translated">TAP :: Formatter :: File :: Session-파일 출력용 하네스 출력 대리자</target>
        </trans-unit>
        <trans-unit id="46af53bbf8c7eee3da8d825fcace74fe474d232b" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Session</source>
          <target state="translated">TAP::Formatter::Session</target>
        </trans-unit>
        <trans-unit id="c2df33c30bd450c40b146c186ea09c6cab11e56c" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Session - Abstract base class for harness output delegate</source>
          <target state="translated">TAP :: Formatter :: Session-하네스 출력 대리자를위한 추상 기본 클래스</target>
        </trans-unit>
        <trans-unit id="93ebad31adfaf596a987126afe3d7a3f18d93c05" translate="yes" xml:space="preserve">
          <source>TAP::Harness</source>
          <target state="translated">TAP::Harness</target>
        </trans-unit>
        <trans-unit id="b7d5d266f7a8edc064e0b8c710521d51a2bc894a" translate="yes" xml:space="preserve">
          <source>TAP::Harness - Run test scripts with statistics</source>
          <target state="translated">TAP :: Harness-통계를 사용하여 테스트 스크립트 실행</target>
        </trans-unit>
        <trans-unit id="7a70a46bfa38bc1216fe94cb04afcea34c7e8685" translate="yes" xml:space="preserve">
          <source>TAP::Object</source>
          <target state="translated">TAP::Object</target>
        </trans-unit>
        <trans-unit id="f09e3a92ac29a0ecd8a4f02097d67c9251bfb4fd" translate="yes" xml:space="preserve">
          <source>TAP::Object - Base class that provides common functionality to all &lt;code&gt;TAP::*&lt;/code&gt; modules</source>
          <target state="translated">TAP :: Object-모든 &lt;code&gt;TAP::*&lt;/code&gt; 모듈에 공통 기능을 제공하는 기본 클래스</target>
        </trans-unit>
        <trans-unit id="73c55e213830c688e72c24e7e2dc38927a8f526e" translate="yes" xml:space="preserve">
          <source>TAP::Parser</source>
          <target state="translated">TAP::Parser</target>
        </trans-unit>
        <trans-unit id="2f07ed865105b4fe8e06f2ed0ef74d2249f0ce1b" translate="yes" xml:space="preserve">
          <source>TAP::Parser - Parse &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::TAP&quot;&gt;TAP&lt;/a&gt; output</source>
          <target state="translated">TAP :: Parser- &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::TAP&quot;&gt;TAP&lt;/a&gt; 출력 구문 분석</target>
        </trans-unit>
        <trans-unit id="7a216f40bfe5d8c4e9f480503b3353a997f25d9e" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Aggregator</source>
          <target state="translated">TAP::Parser::Aggregator</target>
        </trans-unit>
        <trans-unit id="29967243373ff3c2847efa03292cf1394ade91bf" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Aggregator - Aggregate TAP::Parser results</source>
          <target state="translated">TAP :: Parser :: Aggregator-집계 TAP :: Parser 결과</target>
        </trans-unit>
        <trans-unit id="ea252a87adf45624e0915f082cf3a171691e2b87" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Grammar</source>
          <target state="translated">TAP::Parser::Grammar</target>
        </trans-unit>
        <trans-unit id="99d73c9149822b89f098465b0ef15b6e5e432ba4" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Grammar - A grammar for the Test Anything Protocol.</source>
          <target state="translated">TAP :: Parser :: Grammar-Test Anything Protocol의 문법입니다.</target>
        </trans-unit>
        <trans-unit id="f66dcc18cf605bab72f282216bf437fafae85c73" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator</source>
          <target state="translated">TAP::Parser::Iterator</target>
        </trans-unit>
        <trans-unit id="d222e4542e0f93a9f4cabc8a65b724fcc86515cd" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator - Base class for TAP source iterators</source>
          <target state="translated">TAP :: Parser :: Iterator-TAP 소스 반복기의 기본 클래스</target>
        </trans-unit>
        <trans-unit id="599e631b6f320b3fc47ee504d90a3e175b821f4e" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Array</source>
          <target state="translated">TAP::Parser::Iterator::Array</target>
        </trans-unit>
        <trans-unit id="8849b72265bccd1154b20c5bcfd79b6177e1d979" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Array - Iterator for array-based TAP sources</source>
          <target state="translated">TAP :: Parser :: Iterator :: Array-배열 기반 TAP 소스의 반복자</target>
        </trans-unit>
        <trans-unit id="8afb640018f748c7abac8e508f78557fe8689509" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Process</source>
          <target state="translated">TAP::Parser::Iterator::Process</target>
        </trans-unit>
        <trans-unit id="ef61fd1ef2ee2ba4a706833aed0bb08fe84a24ba" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Process - Iterator for process-based TAP sources</source>
          <target state="translated">TAP :: Parser :: Iterator :: Process-프로세스 기반 TAP 소스의 반복자</target>
        </trans-unit>
        <trans-unit id="c97751b26f9e6df1ee3c0a7feabeda4e0d9102c3" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Stream</source>
          <target state="translated">TAP::Parser::Iterator::Stream</target>
        </trans-unit>
        <trans-unit id="be38f68275dc99a67c8ac1d8cfd48bb032de4d4a" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Stream - Iterator for filehandle-based TAP sources</source>
          <target state="translated">TAP :: Parser :: Iterator :: Stream-파일 핸들 기반 TAP 소스의 반복자</target>
        </trans-unit>
        <trans-unit id="d89bed7b6f6d5d165f751cac2ac0a13e2dd7f697" translate="yes" xml:space="preserve">
          <source>TAP::Parser::IteratorFactory</source>
          <target state="translated">TAP::Parser::IteratorFactory</target>
        </trans-unit>
        <trans-unit id="8d39f8677b4d63ea3260e5507a930c994a438d70" translate="yes" xml:space="preserve">
          <source>TAP::Parser::IteratorFactory - Figures out which SourceHandler objects to use for a given Source</source>
          <target state="translated">TAP :: Parser :: IteratorFactory-주어진 소스에 사용할 SourceHandler 객체를 알아냅니다.</target>
        </trans-unit>
        <trans-unit id="6f50fafc730902e3aa24fa13c0c429b89a2cc1ff" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Multiplexer</source>
          <target state="translated">TAP::Parser::Multiplexer</target>
        </trans-unit>
        <trans-unit id="2da48d5d830b8cd9138d15d18237febc28e0b498" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Multiplexer - Multiplex multiple TAP::Parsers</source>
          <target state="translated">TAP :: Parser :: Multiplexer-다중 다중 TAP :: Parsers</target>
        </trans-unit>
        <trans-unit id="3c077c3ce874909f47ae77cbcca2c04344198e5b" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result</source>
          <target state="translated">TAP::Parser::Result</target>
        </trans-unit>
        <trans-unit id="a422082a9e255b156b40569483bd6f50f2d5a284" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result - Base class for TAP::Parser output objects</source>
          <target state="translated">TAP :: Parser :: Result-TAP :: Parser 출력 객체의 기본 클래스</target>
        </trans-unit>
        <trans-unit id="03b8058105031bc1095218a7667a2ea1b2512b1e" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Bailout</source>
          <target state="translated">TAP::Parser::Result::Bailout</target>
        </trans-unit>
        <trans-unit id="00f4b677e9dddb24581e9ed004b7470cf77a617e" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Bailout - Bailout result token.</source>
          <target state="translated">TAP :: Parser :: Result :: Bailout-실패 결과 토큰.</target>
        </trans-unit>
        <trans-unit id="afba56eaac641feaac3daf9f840411e87ecf1e14" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Comment</source>
          <target state="translated">TAP::Parser::Result::Comment</target>
        </trans-unit>
        <trans-unit id="15ac19d49aebc2fdbf7a430ac512a0c55bc03548" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Comment - Comment result token.</source>
          <target state="translated">TAP :: Parser :: Result :: Comment-댓글 결과 토큰.</target>
        </trans-unit>
        <trans-unit id="8028e0720d8ec37d7287bdb1bc7450078b0bf251" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Plan</source>
          <target state="translated">TAP::Parser::Result::Plan</target>
        </trans-unit>
        <trans-unit id="4383859286c921d76add9716628e055668e9e51d" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Plan - Plan result token.</source>
          <target state="translated">TAP :: Parser :: Result :: Plan-계획 결과 토큰.</target>
        </trans-unit>
        <trans-unit id="f69e80305022a26d3e2f7acc2b0ed1b953372499" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Pragma</source>
          <target state="translated">TAP::Parser::Result::Pragma</target>
        </trans-unit>
        <trans-unit id="14e0c88ebea6563cf55ee8c08b3b9ed300f0d20c" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Pragma - TAP pragma token.</source>
          <target state="translated">TAP :: Parser :: Result :: Pragma-TAP 프라 그마 토큰.</target>
        </trans-unit>
        <trans-unit id="2c91344b1f933a9487eebefc220df8812b008445" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Test</source>
          <target state="translated">TAP::Parser::Result::Test</target>
        </trans-unit>
        <trans-unit id="edc9dae5ee4fae6dd91f0295f192573a8fb6a01a" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Test - Test result token.</source>
          <target state="translated">TAP :: Parser :: Result :: Test-테스트 결과 토큰.</target>
        </trans-unit>
        <trans-unit id="44c345b7d9dc9992b3e410debbb02b0d29d66e79" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Unknown</source>
          <target state="translated">TAP::Parser::Result::Unknown</target>
        </trans-unit>
        <trans-unit id="2943117d9510c588ee4451eb94edacf47000ab69" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Unknown - Unknown result token.</source>
          <target state="translated">TAP :: Parser :: Result :: Unknown-알 수없는 결과 토큰입니다.</target>
        </trans-unit>
        <trans-unit id="c6da177c03a14aa64f029674caca24adf3980051" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Version</source>
          <target state="translated">TAP::Parser::Result::Version</target>
        </trans-unit>
        <trans-unit id="57883e95518fac69c11831c9fff6d78815a22b85" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Version - TAP syntax version token.</source>
          <target state="translated">TAP :: Parser :: Result :: Version-TAP 구문 버전 토큰.</target>
        </trans-unit>
        <trans-unit id="0f318e8c966222dedab8b0415294cae97d5f4f64" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::YAML</source>
          <target state="translated">TAP::Parser::Result::YAML</target>
        </trans-unit>
        <trans-unit id="68efbf9d5d727c77c2280206016668c939f6f897" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::YAML - YAML result token.</source>
          <target state="translated">TAP :: Parser :: Result :: YAML-YAML 결과 토큰.</target>
        </trans-unit>
        <trans-unit id="1a3c6d732b12248b1b6d9e14cf320584eb0a7af0" translate="yes" xml:space="preserve">
          <source>TAP::Parser::ResultFactory</source>
          <target state="translated">TAP::Parser::ResultFactory</target>
        </trans-unit>
        <trans-unit id="4f51e316d0426f94634c75bc33e9099d8d304e39" translate="yes" xml:space="preserve">
          <source>TAP::Parser::ResultFactory - Factory for creating TAP::Parser output objects</source>
          <target state="translated">TAP :: Parser :: ResultFactory-TAP :: Parser 출력 오브젝트를 작성하기위한 팩토리</target>
        </trans-unit>
        <trans-unit id="50d7a126914ae0138b7bdc512d9ccd5a5d77784d" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler</source>
          <target state="translated">TAP::Parser::Scheduler</target>
        </trans-unit>
        <trans-unit id="6da57a5308e690ad2cdb39023741e3d016f8b96b" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler - Schedule tests during parallel testing</source>
          <target state="translated">TAP :: Parser :: Scheduler-병렬 테스트 중 스케줄 테스트</target>
        </trans-unit>
        <trans-unit id="81a373608790f502b94224968ea5fc04bfbb7622" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler::Job</source>
          <target state="translated">TAP::Parser::Scheduler::Job</target>
        </trans-unit>
        <trans-unit id="657d2fb895dc4c666b37510d12e2199629196955" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler::Job - A single testing job.</source>
          <target state="translated">TAP :: Parser :: Scheduler :: Job-단일 테스트 작업입니다.</target>
        </trans-unit>
        <trans-unit id="5f18e879edab289da9e626ab0da6617557a360e9" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler::Spinner</source>
          <target state="translated">TAP::Parser::Scheduler::Spinner</target>
        </trans-unit>
        <trans-unit id="73c0394de64be963748b5ce71edfd4ac21a6b40d" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler::Spinner - A no-op job.</source>
          <target state="translated">TAP :: Parser :: Scheduler :: Spinner-작업이 없습니다.</target>
        </trans-unit>
        <trans-unit id="223a37f35fb2a759c5993cb7f97ef9683ee5bef9" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Source</source>
          <target state="translated">TAP::Parser::Source</target>
        </trans-unit>
        <trans-unit id="ba1432bca02f36d9b7eb2dec89d208a92989961b" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Source - a TAP source &amp;amp; meta data about it</source>
          <target state="translated">TAP :: Parser :: Source-TAP 소스 및 메타 데이터</target>
        </trans-unit>
        <trans-unit id="f75366f8757d0c89dc67745e9e30ae921835fc92" translate="yes" xml:space="preserve">
          <source>TAP::Parser::YAMLish::Reader</source>
          <target state="translated">TAP::Parser::YAMLish::Reader</target>
        </trans-unit>
        <trans-unit id="92a795f40e2bb73376fc045a4635f6fcf7d6a7de" translate="yes" xml:space="preserve">
          <source>TAP::Parser::YAMLish::Reader - Read YAMLish data from iterator</source>
          <target state="translated">TAP :: Parser :: YAMLish :: Reader-반복기에서 YAMLish 데이터 읽기</target>
        </trans-unit>
        <trans-unit id="08d78eef616ac71669e623449566134b1c6d4b77" translate="yes" xml:space="preserve">
          <source>TAP::Parser::YAMLish::Writer</source>
          <target state="translated">TAP::Parser::YAMLish::Writer</target>
        </trans-unit>
        <trans-unit id="662f33223b14be1ce958a19abee31b207588ba54" translate="yes" xml:space="preserve">
          <source>TAP::Parser::YAMLish::Writer - Write YAMLish data</source>
          <target state="translated">TAP :: Parser :: YAMLish :: Writer-YAMLish 데이터 쓰기</target>
        </trans-unit>
        <trans-unit id="20a7b118ffa37d6b7bbce47ab0257aa206e6a7b5" translate="yes" xml:space="preserve">
          <source>TBC: Remove the stringified coderef; while it provides a 'cookie' for each function rendered, the cookies used should be 1,2,3.. not a random hex-address. It also complicates string comparison of two different trees.</source>
          <target state="translated">TBC : 문자열 화 된 코드 참조를 제거하십시오. 렌더링 된 각 함수에 대해 '쿠키'를 제공하지만 사용 된 쿠키는 임의의 16 진수 주소가 아닌 1,2,3.이어야합니다. 또한 두 개의 다른 나무의 문자열 비교가 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="75c76515695c04f9554f43d036ad1241bc04ca9e" translate="yes" xml:space="preserve">
          <source>TBC: a hookpoint (and an option to set it) for a user-supplied function to produce a banner appropriate for users needs. It's not ideal, because the rendering-state variables, which are a natural candidate for use in concise.t, are unavailable to the user.</source>
          <target state="translated">TBC : 사용자 제공 기능이 사용자 요구에 적합한 배너를 생성하기위한 후크 포인트 (및 설정 옵션)입니다. concise.t에서 자연스럽게 사용할 수있는 렌더링 상태 변수는 사용자가 사용할 수 없으므로 이상적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ccb92559aac4354578ea22eca45f6544e0875e36" translate="yes" xml:space="preserve">
          <source>TCP Clients with IO::Socket</source>
          <target state="translated">IO :: Socket을 사용하는 TCP 클라이언트</target>
        </trans-unit>
        <trans-unit id="90251fa6420d40cf40e1d413320c56543c05df3d" translate="yes" xml:space="preserve">
          <source>TCP Servers with IO::Socket</source>
          <target state="translated">IO :: Socket이 포함 된 TCP 서버</target>
        </trans-unit>
        <trans-unit id="5f3be0b4f564336745c1f56bb30fefa5d6b55f59" translate="yes" xml:space="preserve">
          <source>TCP32IP</source>
          <target state="translated">TCP32IP</target>
        </trans-unit>
        <trans-unit id="930107c72c67f45aa5652e4a9e00965774f7a294" translate="yes" xml:space="preserve">
          <source>TCP_CORK, TCP_KEEPALIVE, TCP_NODELAY, ...</source>
          <target state="translated">TCP_CORK, TCP_KEEPALIVE, TCP_NODELAY, ...</target>
        </trans-unit>
        <trans-unit id="f903b5ea6b01e57df921d11ccc31344fae1a17ad" translate="yes" xml:space="preserve">
          <source>TECHNICAL NOTES</source>
          <target state="translated">기술 노트</target>
        </trans-unit>
        <trans-unit id="b3db3af9a0e0243f28ed20fcc3b1d5d1faaafbb6" translate="yes" xml:space="preserve">
          <source>TERM</source>
          <target state="translated">TERM</target>
        </trans-unit>
        <trans-unit id="cfc996e2b0441d5f42e4bd8a622b4dd1b2f920a4" translate="yes" xml:space="preserve">
          <source>TERMCAP</source>
          <target state="translated">TERMCAP</target>
        </trans-unit>
        <trans-unit id="4baf6f46b36f22af80f6af8178fa1faa75a5a37d" translate="yes" xml:space="preserve">
          <source>TERMINOLOGY</source>
          <target state="translated">TERMINOLOGY</target>
        </trans-unit>
        <trans-unit id="201ab4b1fe261c4f44a8bfbbdafd62a7606acc46" translate="yes" xml:space="preserve">
          <source>TERMPATH</source>
          <target state="translated">TERMPATH</target>
        </trans-unit>
        <trans-unit id="feb84698a707a37aae3ea67dd9630a278a6ca8f5" translate="yes" xml:space="preserve">
          <source>TERTIARY METHODS</source>
          <target state="translated">차 방법</target>
        </trans-unit>
        <trans-unit id="16731ae62f4aed11f4e128609c52499c94df9c78" translate="yes" xml:space="preserve">
          <source>TEST ON CYGWIN</source>
          <target state="translated">CYGWIN에 대한 테스트</target>
        </trans-unit>
        <trans-unit id="e01006d91764e5a9b5b7e2fa6b5505255129d446" translate="yes" xml:space="preserve">
          <source>TEST STATUS</source>
          <target state="translated">테스트 상태</target>
        </trans-unit>
        <trans-unit id="1aafa503ed48d02972e5772184ca513598703dbe" translate="yes" xml:space="preserve">
          <source>TEST TYPES</source>
          <target state="translated">테스트 유형</target>
        </trans-unit>
        <trans-unit id="cb73eb0155af5a3da3bb4a63646b40201ab650c4" translate="yes" xml:space="preserve">
          <source>TESTING</source>
          <target state="translated">TESTING</target>
        </trans-unit>
        <trans-unit id="942de0a9a9abe9fb219e796c9c0f10b53d3c6b67" translate="yes" xml:space="preserve">
          <source>TESTING FRAMEWORKS</source>
          <target state="translated">테스트 프레임 워크</target>
        </trans-unit>
        <trans-unit id="04209ee7219637d26ee9cd4fa722493ca838116d" translate="yes" xml:space="preserve">
          <source>THANK YOU</source>
          <target state="translated">감사합니다</target>
        </trans-unit>
        <trans-unit id="ffa4516bffdd79480b0ffbea2e99e02675eb3752" translate="yes" xml:space="preserve">
          <source>THANKS</source>
          <target state="translated">THANKS</target>
        </trans-unit>
        <trans-unit id="506d81bed6d3b4fa9b202f8f107ea34d18c6fadf" translate="yes" xml:space="preserve">
          <source>THE .netrc FILE</source>
          <target state="translated">.netrc 파일</target>
        </trans-unit>
        <trans-unit id="2462f7724da7788ea62fc114cce4eab4e3339b38" translate="yes" xml:space="preserve">
          <source>THE API INTERFACE</source>
          <target state="translated">API 인터페이스</target>
        </trans-unit>
        <trans-unit id="eb466ef85e05d613480bb98bc1553047a2722184" translate="yes" xml:space="preserve">
          <source>THE CALL_ FUNCTIONS</source>
          <target state="translated">CALL_ 기능</target>
        </trans-unit>
        <trans-unit id="db00699a00a64bd8eb4f11307ac364af2186b3b7" translate="yes" xml:space="preserve">
          <source>THE Math::BigInt API</source>
          <target state="translated">수학 :: BigInt API</target>
        </trans-unit>
        <trans-unit id="5bf87badf6e989985ca5cde31b10d699fd946122" translate="yes" xml:space="preserve">
          <source>THE PERL ENCODING API</source>
          <target state="translated">펄 인코딩 API</target>
        </trans-unit>
        <trans-unit id="2036c7632dcc8e78c342e25b215c2cd28f8d5b22" translate="yes" xml:space="preserve">
          <source>THE PERL MODULE LIBRARY</source>
          <target state="translated">펄 모듈 라이브러리</target>
        </trans-unit>
        <trans-unit id="a1c725e21d784bf655d9ab26a4cdce89326e975c" translate="yes" xml:space="preserve">
          <source>THE QUESTIONS</source>
          <target state="translated">질문</target>
        </trans-unit>
        <trans-unit id="fb64ef2c36220a9cb84ef2e67b3a1343a0d67d4d" translate="yes" xml:space="preserve">
          <source>THE RULES OF SYS::SYSLOG</source>
          <target state="translated">SYS :: SYSLOG의 규칙</target>
        </trans-unit>
        <trans-unit id="79e66f9682153b1fcc7f947e99f79c4de4e44b30" translate="yes" xml:space="preserve">
          <source>THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</source>
          <target state="translated">본 소프트웨어는 상품성, 특정 목적에의 적합성 및 비 침해에 대한 보증을 포함하되 명시 적이든 묵시적이든 어떠한 종류의 보증없이 &quot;있는 그대로&quot;제공됩니다. 어떠한 경우에도 저자 또는 저작권 소유자는 계약, 불법 행위 또는 기타 행위, 소프트웨어 또는 소프트웨어의 사용 또는 기타 거래와 관련하여 발생하는 모든 청구, 손해 또는 기타 책임에 대해 책임을지지 않습니다. 소프트웨어.</target>
        </trans-unit>
        <trans-unit id="6c98c15d2eefa5232f6a2b60310fc78bdae1017e" translate="yes" xml:space="preserve">
          <source>THE dataconn CLASS</source>
          <target state="translated">데이터 콘 클래스</target>
        </trans-unit>
        <trans-unit id="472f09c67477280b91b7ae79efeb4fde13fbb523" translate="yes" xml:space="preserve">
          <source>THING</source>
          <target state="translated">THING</target>
        </trans-unit>
        <trans-unit id="2360380b4c35fa48f7e3a9f411a80f126b56989e" translate="yes" xml:space="preserve">
          <source>THINGS TO LOOK OUT FOR</source>
          <target state="translated">찾아야 할 것들</target>
        </trans-unit>
        <trans-unit id="584497c8a870243751bafe0429bbe1f5826e0915" translate="yes" xml:space="preserve">
          <source>THIS FUNCTION SHOULD BE USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES. Instead, &lt;b&gt;Almost all code should use &lt;a href=&quot;#uvchr_to_utf8&quot;&gt;uvchr_to_utf8&lt;/a&gt; or &lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;uvchr_to_utf8_flags&lt;/a&gt;&lt;/b&gt;.</source>
          <target state="translated">이 기능은 매우 특수한 환경에서만 사용해야합니다. 대신, &lt;b&gt;거의 모든 코드는 &lt;a href=&quot;#uvchr_to_utf8&quot;&gt;uvchr_to_utf8&lt;/a&gt; 또는 &lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;uvchr_to_utf8_flags를 사용해야&lt;/a&gt;&lt;/b&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="331b8f63effc7e7d25ea524ca1aa92004125d86f" translate="yes" xml:space="preserve">
          <source>THIS FUNCTION SHOULD BE USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES. Most code should use &lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;utf8_to_uvchr_buf&lt;/a&gt;() rather than call this directly.</source>
          <target state="translated">이 기능은 매우 특수한 환경에서만 사용해야합니다. 대부분의 코드는 이것을 직접 호출하지 않고 &lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;utf8_to_uvchr_buf&lt;/a&gt; ()를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="897ebd5219f0c5caa208699bd4713ae3b784c6e0" translate="yes" xml:space="preserve">
          <source>THREAD CONTEXT</source>
          <target state="translated">스레드 컨텍스트</target>
        </trans-unit>
        <trans-unit id="54e59b7bc3a2e96489d360a7b538367313e355dc" translate="yes" xml:space="preserve">
          <source>THREAD SIGNALLING</source>
          <target state="translated">스레드 신호</target>
        </trans-unit>
        <trans-unit id="60b08b8acc7a625b8f0d9d41c7e2c28fbb134428" translate="yes" xml:space="preserve">
          <source>THREAD STACK SIZE</source>
          <target state="translated">스레드 스택 크기</target>
        </trans-unit>
        <trans-unit id="577fa2796ff34704e76d7424a53614775f345523" translate="yes" xml:space="preserve">
          <source>THREAD STATE</source>
          <target state="translated">스레드 상태</target>
        </trans-unit>
        <trans-unit id="bf2767662599be6d02741631f5d4e162d0241086" translate="yes" xml:space="preserve">
          <source>THREAD SUPPORT</source>
          <target state="translated">스레드 지원</target>
        </trans-unit>
        <trans-unit id="f8c7150e13e8ea5e3603e546c189035146b726df" translate="yes" xml:space="preserve">
          <source>THREADS</source>
          <target state="translated">THREADS</target>
        </trans-unit>
        <trans-unit id="f266b9c4765272a11c0ed3c20127bf1d201638dd" translate="yes" xml:space="preserve">
          <source>TIEHANDLE by Sven Verdoolaege &amp;lt;</source>
          <target state="translated">Sie Verdoolaege의 TIEHANDLE &amp;lt;</target>
        </trans-unit>
        <trans-unit id="64269f9bd268bf28815bb69e82601cd7e806a37b" translate="yes" xml:space="preserve">
          <source>TIME</source>
          <target state="translated">TIME</target>
        </trans-unit>
        <trans-unit id="6c2529a2a2e078590190100f8e1c4972e8846bc5" translate="yes" xml:space="preserve">
          <source>TIME is</source>
          <target state="translated">시간은</target>
        </trans-unit>
        <trans-unit id="6409a515d9fc80e579966498117e7281bd8b98a0" translate="yes" xml:space="preserve">
          <source>TMP or TEMP</source>
          <target state="translated">TMP 또는 TEMP</target>
        </trans-unit>
        <trans-unit id="47bd70df0e55aba216736b1db7710c6478ab9cbf" translate="yes" xml:space="preserve">
          <source>TO DO</source>
          <target state="translated">할 것</target>
        </trans-unit>
        <trans-unit id="f8953b7e0e4beba3861ba1d10ca937f8f20fdfee" translate="yes" xml:space="preserve">
          <source>TO DO (maybe)</source>
          <target state="translated">해야 할 일 (아마도)</target>
        </trans-unit>
        <trans-unit id="b698c11e84460ed5999bfeb5cbf25b865c238f3c" translate="yes" xml:space="preserve">
          <source>TODO</source>
          <target state="translated">TODO</target>
        </trans-unit>
        <trans-unit id="14081c923a6df4129e72afd1550fb67ed4989fb1" translate="yes" xml:space="preserve">
          <source>TODO all (most?) accessorized methods</source>
          <target state="translated">TODO all (대부분?) 접근 방법</target>
        </trans-unit>
        <trans-unit id="bac7481b99347a289b8d37ae17bf40d2f44f1514" translate="yes" xml:space="preserve">
          <source>TODO tests are designed for maintaining an &lt;b&gt;executable TODO list&lt;/b&gt;. These tests are</source>
          <target state="translated">TODO 테스트는 &lt;b&gt;실행 가능한 TODO 목록&lt;/b&gt; 을 유지 관리하기 위해 설계되었습니다 . 이 테스트는</target>
        </trans-unit>
        <trans-unit id="fd32d0b7a9d317be835f0befd340eb49cf589cff" translate="yes" xml:space="preserve">
          <source>TODO, see &lt;a href=&quot;http://www.mail-archive.com/perl5-changes@perl.org/msg17328.html&quot;&gt;http://www.mail-archive.com/perl5-changes@perl.org/msg17328.html&lt;/a&gt;</source>
          <target state="translated">TODO, &lt;a href=&quot;http://www.mail-archive.com/perl5-changes@perl.org/msg17328.html&quot;&gt;http://www.mail-archive.com/perl5-changes@perl.org/msg17328.html 참조&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="643a0382045e00a908788587a0d4b6d602741dc9" translate="yes" xml:space="preserve">
          <source>TODO: An example or two of =extend, then point to Pod::Simple::Subclassing</source>
          <target state="translated">TODO : = extend 중 하나 또는 두 개를 가리킨 다음 Pod :: Simple :: Subclassing을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="b95da2f919c7ccb270ebcfb13598d7d2d8b6a01a" translate="yes" xml:space="preserve">
          <source>TODO: Document this</source>
          <target state="translated">TODO : 문서화</target>
        </trans-unit>
        <trans-unit id="26dbb18df63ed25641cd65981a2bd8abf41c6420" translate="yes" xml:space="preserve">
          <source>TODO: Document those cases.</source>
          <target state="translated">TODO : 그러한 경우를 문서화하십시오.</target>
        </trans-unit>
        <trans-unit id="503edd260136cc51f7d583a68da986091421e06f" translate="yes" xml:space="preserve">
          <source>TODO: a corpus of sample Pod input and HTML output? Or common idioms?</source>
          <target state="translated">TODO : 샘플 포드 입력 및 HTML 출력의 모음? 아니면 일반적인 관용구?</target>
        </trans-unit>
        <trans-unit id="767b9b1886f65db5d2c2efe4d311ec16282ddf3e" translate="yes" xml:space="preserve">
          <source>TOTAL RESULTS</source>
          <target state="translated">총 결과</target>
        </trans-unit>
        <trans-unit id="6168d5c87ca259972f2a01ffcfd10f094db6e548" translate="yes" xml:space="preserve">
          <source>TRANSFORMATION FORMATS</source>
          <target state="translated">변환 형식</target>
        </trans-unit>
        <trans-unit id="08e80e877114a02316e2a85c727dc2ec2e8d050b" translate="yes" xml:space="preserve">
          <source>TRANSLATIONS</source>
          <target state="translated">TRANSLATIONS</target>
        </trans-unit>
        <trans-unit id="881efc13a4ce5c9b7f10acdee48bdf35dab16bcd" translate="yes" xml:space="preserve">
          <source>TREE-BASED PARSING</source>
          <target state="translated">트리 기반 패싱</target>
        </trans-unit>
        <trans-unit id="55c5fdc09a5315c1ab2a4b0b8470a49a53936b60" translate="yes" xml:space="preserve">
          <source>TRIGONOMETRIC FUNCTIONS</source>
          <target state="translated">삼각법 함수</target>
        </trans-unit>
        <trans-unit id="d814d3e7d55ad64b9a68fdab60bd5741a6c86453" translate="yes" xml:space="preserve">
          <source>TUTORIAL</source>
          <target state="translated">TUTORIAL</target>
        </trans-unit>
        <trans-unit id="6e9816a8e9d0388eecdb52866188c04e75e4b1b3" translate="yes" xml:space="preserve">
          <source>TYPE</source>
          <target state="translated">TYPE</target>
        </trans-unit>
        <trans-unit id="40ea9041285003e004a8f6fe2dd14ebb07961af2" translate="yes" xml:space="preserve">
          <source>TYPES</source>
          <target state="translated">TYPES</target>
        </trans-unit>
        <trans-unit id="3409e584f0822b2e9f6e17cf539649bef61e2695" translate="yes" xml:space="preserve">
          <source>T_OPAQUE supports input and output of simple types. T_OPAQUEPTR can be used to pass these bytes back into C if a pointer is acceptable.</source>
          <target state="translated">T_OPAQUE는 단순 유형의 입력 및 출력을 지원합니다. 포인터가 허용되는 경우 T_OPAQUEPTR을 사용하여 이러한 바이트를 C로 다시 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2acdc87aba62301b1c46833bbb0d8a2ab24b5d4c" translate="yes" xml:space="preserve">
          <source>T_PACKEDARRAY is similar to T_PACKED. In fact, the &lt;code&gt;INPUT&lt;/code&gt; (Perl to XSUB) typemap is identical, but the &lt;code&gt;OUTPUT&lt;/code&gt; typemap passes an additional argument to the &lt;code&gt;XS_pack_$ntype&lt;/code&gt; function. This third parameter indicates the number of elements in the output so that the function can handle C arrays sanely. The variable needs to be declared by the user and must have the name &lt;code&gt;count_$ntype&lt;/code&gt; where &lt;code&gt;$ntype&lt;/code&gt; is the normalized C type name as explained above. The signature of the function would be for the example above and &lt;code&gt;foo_t **&lt;/code&gt; :</source>
          <target state="translated">T_PACKEDARRAY는 T_PACKED와 유사합니다. 실제로 &lt;code&gt;INPUT&lt;/code&gt; (Perl to XSUB) 유형 맵은 동일하지만 &lt;code&gt;OUTPUT&lt;/code&gt; 유형 맵은 &lt;code&gt;XS_pack_$ntype&lt;/code&gt; 함수에 추가 인수를 전달 합니다. 이 세 번째 매개 변수는 출력에서 ​​요소 수를 나타내므로 함수가 C 배열을 깔끔하게 처리 할 수 ​​있습니다. 변수는 사용자가 선언해야하며 이름은 &lt;code&gt;count_$ntype&lt;/code&gt; 이어야합니다. 여기서 &lt;code&gt;$ntype&lt;/code&gt; ntype 은 위에서 설명한 정규화 된 C 유형 이름입니다. 함수의 서명은 위의 예와 &lt;code&gt;foo_t **&lt;/code&gt; 에 대한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="f31b217f3c82ab68ac7452146830667f22ddb6a9" translate="yes" xml:space="preserve">
          <source>T_U_LONG is used for type &lt;code&gt;U32&lt;/code&gt; in the standard typemap.</source>
          <target state="translated">T_U_LONG은 표준 유형 맵에서 &lt;code&gt;U32&lt;/code&gt; 유형에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="067c0c90742a514deacd491758ccd4ba0e1d9275" translate="yes" xml:space="preserve">
          <source>T_U_SHORT is used for type &lt;code&gt;U16&lt;/code&gt; in the standard typemap.</source>
          <target state="translated">T_U_SHORT는 표준 유형 맵에서 &lt;code&gt;U16&lt;/code&gt; 유형에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="267d7ded4fb1f4fe830b757c69adcb120de3c36c" translate="yes" xml:space="preserve">
          <source>Table in hex, sorted in 1047 order</source>
          <target state="translated">16 진수로 정렬 된 표 (1047 순서로 정렬)</target>
        </trans-unit>
        <trans-unit id="9730d4326a7b8a0d13c2be3b7fe29b80ad152bf6" translate="yes" xml:space="preserve">
          <source>Table of Contents</source>
          <target state="translated">목차</target>
        </trans-unit>
        <trans-unit id="f6f2ebfa1ea92516cffdbcabbc226ad6201fc14f" translate="yes" xml:space="preserve">
          <source>Tag Handling Utility Functions</source>
          <target state="translated">태그 처리 유틸리티 기능</target>
        </trans-unit>
        <trans-unit id="8a6299767c14d608575e773d7c250b1dd1bef09f" translate="yes" xml:space="preserve">
          <source>Tags and names for human languages</source>
          <target state="translated">휴먼 언어의 태그 및 이름</target>
        </trans-unit>
        <trans-unit id="0caddaacf6ffdd3b4a1f2e6c28c9c60f84fe10e3" translate="yes" xml:space="preserve">
          <source>Tags for the Identification of Languages</source>
          <target state="translated">언어 식별을위한 태그</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
