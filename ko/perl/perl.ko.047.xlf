<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="5e82b72795636964d66437770c692b7d03ceb23b" translate="yes" xml:space="preserve">
          <source>To assign a specific &lt;b&gt;network address&lt;/b&gt; to a &lt;b&gt;socket&lt;/b&gt;.</source>
          <target state="translated">특정의 지정하려면 &lt;b&gt;네트워크 주소를&lt;/b&gt; A와 &lt;b&gt;소켓&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="c2c2805d5269d7141c86f56aaf1c2c2a76a26622" translate="yes" xml:space="preserve">
          <source>To assist you &lt;code&gt;test_test&lt;/code&gt; can colour the background of the debug information to disambiguate the different types of output. The debug output will have its background coloured green and red. The green part represents the text which is the same between the executed and actual output, the red shows which part differs.</source>
          <target state="translated">&lt;code&gt;test_test&lt;/code&gt; 를 돕기 위해 디버그 정보의 배경색을 지정하여 다양한 유형의 출력을 명확하게 할 수 있습니다. 디버그 출력의 배경은 녹색과 빨간색으로 표시됩니다. 녹색 부분은 실행 된 출력과 실제 출력간에 동일한 텍스트를 나타내고 빨간색은 어떤 부분이 다른지를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e8e1cbea5e7824434cdf9fc699c75f29c54b93f0" translate="yes" xml:space="preserve">
          <source>To auto-detect and uncompress an RFC 1950 or RFC 1952 data stream (i.e. gzip), set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;WANT_GZIP_OR_ZLIB&lt;/code&gt; .</source>
          <target state="translated">RFC 1950 또는 RFC 1952 데이터 스트림 (예 : gzip)을 자동 감지하고 압축 해제하려면 &lt;code&gt;WindowBits&lt;/code&gt; 를 &lt;code&gt;WANT_GZIP_OR_ZLIB&lt;/code&gt; 로 설정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b525fdc47ff53e260dc0931cfbc7865b5eae8d3" translate="yes" xml:space="preserve">
          <source>To avoid ambiguity, when signatures are enabled the special syntax for prototypes is disabled. There is no attempt to guess whether a parenthesised group was intended to be a prototype or a signature. To give a subroutine a prototype under these circumstances, use a &lt;a href=&quot;attributes#Built-in-Attributes&quot;&gt;prototype attribute&lt;/a&gt;. For example,</source>
          <target state="translated">모호성을 피하기 위해 서명이 활성화되면 프로토 타입에 대한 특수 구문이 비활성화됩니다. 괄호로 묶은 그룹이 프로토 타입인지 서명인지 추측하지 않습니다. 이러한 상황에서 서브 루틴에 프로토 타입을 제공하려면 &lt;a href=&quot;attributes#Built-in-Attributes&quot;&gt;prototype 속성을&lt;/a&gt; 사용하십시오 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="409b9ee9e716af7051876e4ad525c073a4badea1" translate="yes" xml:space="preserve">
          <source>To avoid confusing would-be users of your code who are running earlier versions of Perl with mysterious failures, put this sort of thing at the top of your file to signal that your code will work</source>
          <target state="translated">이전 버전의 Perl을 실행하는 코드 사용자가 신비한 실패로 혼동하지 않도록 코드의 작동을 알리기 위해 이러한 종류의 파일을 파일 맨 위에 놓으십시오.</target>
        </trans-unit>
        <trans-unit id="cdb270b498c0b4af5dad93d34e6e87c778aa6616" translate="yes" xml:space="preserve">
          <source>To avoid confusing would-be users of your code who are running earlier versions of Perl with mysterious syntax errors, put this sort of thing at the top of your file to signal that your code will work</source>
          <target state="translated">신비한 구문 오류로 이전 버전의 Perl을 실행하는 코드 사용자를 혼동하지 않으려면 코드 상단에 이런 종류의 것을 넣어 코드가 작동한다는 신호를 보내십시오</target>
        </trans-unit>
        <trans-unit id="010f767fa3f7758e437e81843e72a2beb1516ec0" translate="yes" xml:space="preserve">
          <source>To avoid confusing would-be users of your code with mysterious syntax errors, put something like this at the top of your script:</source>
          <target state="translated">신비한 구문 오류로 코드 사용자를 혼동하지 않으려면 스크립트 맨 위에 다음과 같이 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="92c9a11d8c00dc701cc8cb47a28dac284fb7ca76" translate="yes" xml:space="preserve">
          <source>To avoid creating a new SV every time &lt;code&gt;SaveSub2&lt;/code&gt; is called, the function first checks to see if it has been called before. If not, then space for a new SV is allocated and the reference to the Perl subroutine &lt;code&gt;name&lt;/code&gt; is copied to the variable &lt;code&gt;keepSub&lt;/code&gt; in one operation using &lt;code&gt;newSVsv&lt;/code&gt; . Thereafter, whenever &lt;code&gt;SaveSub2&lt;/code&gt; is called, the existing SV, &lt;code&gt;keepSub&lt;/code&gt; , is overwritten with the new value using &lt;code&gt;SvSetSV&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;SaveSub2&lt;/code&gt; 가 호출 될 때마다 새 SV가 작성되지 않도록하기 위해이 함수는 먼저 이전에 호출되었는지 확인합니다. 그렇지 않으면 할당되는 새로운 SV에 대한 다음 공간 펄 서브 루틴을 참조 &lt;code&gt;name&lt;/code&gt; 변수에 복사 &lt;code&gt;keepSub&lt;/code&gt; 사용 번의 작업 &lt;code&gt;newSVsv&lt;/code&gt; 를 . 그런 다음 &lt;code&gt;SaveSub2&lt;/code&gt; 가 호출 될 때마다 기존 SV 인 &lt;code&gt;keepSub&lt;/code&gt; 가 &lt;code&gt;SvSetSV&lt;/code&gt; 를 사용하여 새 값으로 겹쳐 씁니다 .</target>
        </trans-unit>
        <trans-unit id="7f1c469efc6b2f6bb3fb09ea0c807689f209337a" translate="yes" xml:space="preserve">
          <source>To avoid memory leaks, all trailing duplicate entries in @INC are removed.</source>
          <target state="translated">메모리 누수를 방지하기 위해 @INC의 모든 후행 중복 항목이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="fe0f91423917e2fcf830eb3362231efceaad6437" translate="yes" xml:space="preserve">
          <source>To avoid relying on an object's underlying representation, if the smartmatch's right operand is an object that doesn't overload &lt;code&gt;~~&lt;/code&gt; , it raises the exception &quot;&lt;code&gt;Smartmatching a non-overloaded object
breaks encapsulation&lt;/code&gt; &quot;. That's because one has no business digging around to see whether something is &quot;in&quot; an object. These are all illegal on objects without a &lt;code&gt;~~&lt;/code&gt; overload:</source>
          <target state="translated">객체의 기본 표현에 의존하지 않기 위해 smartmatch의 오른쪽 피연산자가 &lt;code&gt;~~&lt;/code&gt; 을 오버로드하지 않는 객체 인 경우 &quot; &lt;code&gt;Smartmatching a non-overloaded object breaks encapsulation&lt;/code&gt; &quot;라는 예외 가 발생합니다 . 그 이유는 무엇인가가 물체에 있는지 여부를 확인하기 위해 사업을 파고 들지 않기 때문입니다. 이들은 &lt;code&gt;~~&lt;/code&gt; 과부하가 없는 객체에서 모두 불법입니다 .</target>
        </trans-unit>
        <trans-unit id="4c10393ba7ca423ef6dd3c94a2b581675efc33a8" translate="yes" xml:space="preserve">
          <source>To avoid the possibility of miscoordination, Perl now flushes FILEHANDLE before locking or unlocking it.</source>
          <target state="translated">잘못 조정될 가능성을 방지하기 위해 Perl은 이제 파일을 잠 그거나 잠금 해제하기 전에 FILEHANDLE을 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="5d5d75934a6f7e951fd9357cb74cb7683ab1e280" translate="yes" xml:space="preserve">
          <source>To avoid this problem, either put in extra parentheses or use the super low precedence &lt;code&gt;or&lt;/code&gt; operator:</source>
          <target state="translated">이 문제를 피하려면 추가 괄호를 넣거나 매우 낮은 우선 순위 &lt;code&gt;or&lt;/code&gt; 연산자를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="766d42f164385b7f29a7e92b44d6d78b6d17a595" translate="yes" xml:space="preserve">
          <source>To avoid this problem, when it encounters a here document whilst extracting from a modifiable string, &lt;code&gt;extract_quotelike&lt;/code&gt; silently rearranges the string to an equivalent piece of Perl:</source>
          <target state="translated">이 문제를 피하기 위해 수정 가능한 문자열에서 추출하는 동안 here 문서가 발생하면 &lt;code&gt;extract_quotelike&lt;/code&gt; 는 문자열을 동등한 Perl 조각으로 자동 재 배열합니다.</target>
        </trans-unit>
        <trans-unit id="da9ceee7d2a6a8bd92bf59b8dd4824301848ef6c" translate="yes" xml:space="preserve">
          <source>To avoid this warning and to avoid having different output encodings in a single stream, always specify an encoding explicitly, for example with a PerlIO layer:</source>
          <target state="translated">이 경고를 피하고 단일 스트림에서 다른 출력 인코딩을 사용하지 않으려면 항상 PerlIO 레이어와 같은 인코딩을 명시 적으로 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="35af978891563db2721278dcfd7e8de9b9ef61ce" translate="yes" xml:space="preserve">
          <source>To avoid this, whenever a CV and its associated pad is freed, any &lt;code&gt;&amp;amp;&lt;/code&gt; entries in the pad are explicitly removed from the pad, and if the refcount of the pointed-to anon sub is still positive, then that child's &lt;code&gt;CvOUTSIDE&lt;/code&gt; is set to point to its grandparent. This will only occur in the single specific case of a non-closure anon prototype having one or more active references (such as &lt;code&gt;$a&lt;/code&gt; above).</source>
          <target state="translated">이력서 및 관련 패드가 해제 될 때마다이를 방지하기 위해, 어떤 &lt;code&gt;&amp;amp;&lt;/code&gt; 패드의 항목을 명시 적으로 패드에서 제거하는 경우 익명 서브는 여전히 긍정적 인 지적-, 다음 자녀의 것을의 refcount가 &lt;code&gt;CvOUTSIDE&lt;/code&gt; 가 포인트로 설정 조부모에게. 이는 하나 이상의 활성 참조 (예 : 위의 &lt;code&gt;$a&lt;/code&gt; )를 가진 비 폐쇄 아논 프로토 타입의 경우에만 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="892f516de74c75c59b1eb990ddf92d3f52eefdaf" translate="yes" xml:space="preserve">
          <source>To avoid this, you can force the Makefile to be rebuilt whenever you change the module containing the version number by adding this to your WriteMakefile() arguments.</source>
          <target state="translated">이를 방지하기 위해 WriteMakefile () 인수에 버전 번호를 추가하여 버전 번호가 포함 된 모듈을 변경할 때마다 Makefile을 강제로 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79bc3cfb105613cbe5f2c89b6ab087189a45bded" translate="yes" xml:space="preserve">
          <source>To avoid wasted work when a restart is needed, the sizing pass is abandoned - &lt;code&gt;regatom()&lt;/code&gt; immediately returns NULL, setting the flag &lt;code&gt;RESTART_UTF8&lt;/code&gt; . (This action is encapsulated using the macro &lt;code&gt;REQUIRE_UTF8&lt;/code&gt; .) This restart request is propagated up the call chain in a similar fashion, until it is &quot;caught&quot; in &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; , which marks the pattern as containing Unicode, and restarts the sizing pass. It is also possible for constructions within run-time code blocks to turn out to need Unicode representation., which is signalled by &lt;code&gt;S_compile_runtime_code()&lt;/code&gt; returning false to &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; .</source>
          <target state="translated">다시 시작해야 할 때 낭비되는 작업을 피하기 위해 크기 조정 단계가 취소됩니다. &lt;code&gt;regatom()&lt;/code&gt; 즉시 NULL을 반환하고 플래그 &lt;code&gt;RESTART_UTF8&lt;/code&gt; 을 설정합니다 . 이 조치는 매크로 &lt;code&gt;REQUIRE_UTF8&lt;/code&gt; 을 사용하여 캡슐화됩니다 .이 재시작 요청은 패턴이 유니 코드를 포함하는 것으로 표시하고 사이징 패스를 다시 시작하는 &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; 에서 호출 될 때까지 유사한 방식으로 호출 체인으로 전파됩니다 . 그것은 런타임 코드 블록 내에서 구조 유니 코드 표현을 필요로 판명 할 수있다.,에 의해 신호되는 &lt;code&gt;S_compile_runtime_code()&lt;/code&gt; 로 돌아 거짓을 &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09e124c75c7cbe80f3e4228168f11f802fe412a9" translate="yes" xml:space="preserve">
          <source>To be able to access the two parameters that were pushed onto the stack after they return from</source>
          <target state="translated">스택에서 반환 된 두 매개 변수에 액세스 할 수 있도록</target>
        </trans-unit>
        <trans-unit id="6e3a208559e7fc6775f8912d077235f17cca0135" translate="yes" xml:space="preserve">
          <source>To be announced.</source>
          <target state="translated">발표 될.</target>
        </trans-unit>
        <trans-unit id="161647c06ada22688c122c82ae94e4258d4b89c7" translate="yes" xml:space="preserve">
          <source>To be announced. Or deleted.</source>
          <target state="translated">발표 될. 또는 삭제되었습니다.</target>
        </trans-unit>
        <trans-unit id="1942f94bc444abb1b89482bc04403e0f7a2e9a63" translate="yes" xml:space="preserve">
          <source>To be compatible with .Net regular expressions, &lt;code&gt;\g{name}&lt;/code&gt; may also be written as &lt;code&gt;\k{name}&lt;/code&gt; , &lt;code&gt;\k&amp;lt;name&amp;gt;&lt;/code&gt; or &lt;code&gt;\k'name'&lt;/code&gt;.</source>
          <target state="translated">.Net 정규식과 호환되도록 &lt;code&gt;\g{name}&lt;/code&gt; 을 &lt;code&gt;\k{name}&lt;/code&gt; , &lt;code&gt;\k&amp;lt;name&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;\k'name'&lt;/code&gt; 으로 쓸 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bc3bab69ee4c24015f181f505f714806f55a6a5d" translate="yes" xml:space="preserve">
          <source>To be fully compatible with the Exporter and MakeMaker modules you should store your module's version number in a non-my package variable called $VERSION. This should be a positive floating point number with at least two digits after the decimal (i.e., hundredths, e.g, &lt;code&gt;$VERSION = &quot;0.01&quot;&lt;/code&gt; ). Don't use a &quot;1.3.2&quot; style version. See &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; for details.</source>
          <target state="translated">Exporter 및 MakeMaker 모듈과 완벽하게 호환되도록하려면 모듈의 버전 번호를 $ VERSION이라는 내 패키지가 아닌 변수에 저장해야합니다. 소수점 이하 두 자릿수 이상의 양의 부동 소수점 숫자 여야합니다 (예 : &lt;code&gt;$VERSION = &quot;0.01&quot;&lt;/code&gt; ). &quot;1.3.2&quot;스타일 버전을 사용하지 마십시오. 자세한 내용은 &lt;a href=&quot;exporter&quot;&gt;내보내기&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="781abe7cd10e483cb21c7189d334aa3e4eaca732" translate="yes" xml:space="preserve">
          <source>To be more precise, we will say that a regex program is an encoding of a graph. Each node in the graph corresponds to part of the original regex pattern, such as a literal string or a branch, and has a pointer to the nodes representing the next component to be matched. Since &quot;node&quot; and &quot;opcode&quot; already have other meanings in the perl source, we will call the nodes in a regex program &quot;regops&quot;.</source>
          <target state="translated">더 정확하게 말하면, 정규식 프로그램은 그래프의 인코딩이라고 말할 것입니다. 그래프의 각 노드는 리터럴 문자열 또는 분기와 같은 원래 정규식 패턴의 일부에 해당하며 일치시킬 다음 구성 요소를 나타내는 노드에 대한 포인터를 갖습니다. &quot;node&quot;와 &quot;opcode&quot;는 이미 perl 소스에서 다른 의미를 갖기 때문에 정규식 프로그램 &quot;regops&quot;에서 노드를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="a03a7a550b2afe3393fb820749da17491cf98371" translate="yes" xml:space="preserve">
          <source>To be pedantic, the comparison is actually &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;(EXPR) == &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;(EXPR)&lt;/code&gt; , but that is only an issue if you use a floating point expression; when implicitly using &lt;code&gt;$.&lt;/code&gt; as described in the previous paragraph, the comparison is &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;(EXPR) == &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;($.)&lt;/code&gt; which is only an issue when &lt;code&gt;$.&lt;/code&gt; is set to a floating point value and you are not reading from a file. Furthermore, &lt;code&gt;&quot;span&quot; .. &quot;spat&quot;&lt;/code&gt; or &lt;code&gt;2.18 .. 3.14&lt;/code&gt; will not do what you want in scalar context because each of the operands are evaluated using their integer representation.</source>
          <target state="translated">pedantic하기 위해 비교는 실제로 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;(EXPR) == &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;(EXPR)&lt;/code&gt; 이지만 부동 소수점 표현식을 사용하는 경우에만 문제가됩니다. 암시 적으로 &lt;code&gt;$.&lt;/code&gt; 사용할 때 . 이전 단락에서 설명했듯이 비교는 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;(EXPR) == &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;($.)&lt;/code&gt; 이며 $ 일 때만 발생 &lt;code&gt;$.&lt;/code&gt; 이 부동 소수점 값으로 설정되어 있고 파일에서 읽지 않습니다. 또한 &lt;code&gt;&quot;span&quot; .. &quot;spat&quot;&lt;/code&gt; 또는 &lt;code&gt;2.18 .. 3.14&lt;/code&gt; 는 각 피연산자가 정수 표현을 사용하여 평가되므로 스칼라 컨텍스트에서 원하는 것을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ed53a49e46f6db6479ffd9a906bbff37f48f8995" translate="yes" xml:space="preserve">
          <source>To be polite to other functions wrapping your own you usually want to increment &lt;code&gt;$Level&lt;/code&gt; rather than set it to a constant.</source>
          <target state="translated">자신을 감싸는 다른 함수에 정중하려면 일반적으로 상수를 설정하기보다는 &lt;code&gt;$Level&lt;/code&gt; 을 증가 시키려고합니다.</target>
        </trans-unit>
        <trans-unit id="377966b7899d2c6cc0617addc0bc388cc67a68ae" translate="yes" xml:space="preserve">
          <source>To be portable each component of a module name should be limited to 11 characters. If it might be used on MS-DOS then try to ensure each is unique in the first 8 characters. Nested modules make this easier.</source>
          <target state="translated">이식 가능한 모듈 이름의 각 구성 요소는 11 자로 제한되어야합니다. MS-DOS에서 사용될 수 있으면 처음 8 자에서 고유한지 확인하십시오. 중첩 모듈을 사용하면이 작업이 쉬워집니다.</target>
        </trans-unit>
        <trans-unit id="b076f38e81902902b25d1f17b1608ab8be160484" translate="yes" xml:space="preserve">
          <source>To begin your reading, start with:</source>
          <target state="translated">독서를 시작하려면 다음과 같이 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="a61e1eb5d11062cb9036bb12d10d76fe348be7c1" translate="yes" xml:space="preserve">
          <source>To browse existing Perl bugs and patches, you can use the web interface at &lt;a href=&quot;http://rt.perl.org/&quot;&gt;http://rt.perl.org/&lt;/a&gt;.</source>
          <target state="translated">기존 Perl 버그 및 패치를 찾아 보려면 웹 인터페이스 ( &lt;a href=&quot;http://rt.perl.org/&quot;&gt;http://rt.perl.org/)를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b19b13b7eebea3b4a95edad33fffc49ec225b2e5" translate="yes" xml:space="preserve">
          <source>To build a non-XS module, you can use the standard module-building instructions distributed with perl modules.</source>
          <target state="translated">비 XS 모듈을 구축하려면 perl 모듈과 함께 배포 된 표준 모듈 구축 지침을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c2705e01ac97996d808db8effeb88881961867f" translate="yes" xml:space="preserve">
          <source>To build an XS module, you must use the standard module-building instructions distributed with perl modules *PLUS* three extra instructions specific to the DJGPP &quot;static link&quot; build environment.</source>
          <target state="translated">XS 모듈을 빌드하려면 perl 모듈 * PLUS *와 함께 배포 된 표준 모듈 빌드 명령어를 사용하여 DJGPP &quot;정적 링크&quot;빌드 환경과 관련된 세 가지 추가 명령어를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="d5c2765f0199128d509d1897ee86d4417f4dd8a3" translate="yes" xml:space="preserve">
          <source>To build extensions other than standard extensions, NetWare Perl has to be installed on Windows along with Windows Perl. The Perl for Windows can be either downloaded from the CPAN site and built using the sources, or the binaries can be directly downloaded from the ActiveState site. Installation can be done by invoking</source>
          <target state="translated">표준 확장 이외의 확장을 구축하려면 Windows Perl과 함께 NetWare Perl을 Windows에 설치해야합니다. Windows 용 Perl은 CPAN 사이트에서 다운로드하여 소스를 사용하여 빌드하거나 바이너리를 ActiveState 사이트에서 직접 다운로드 할 수 있습니다. 호출하여 설치 가능</target>
        </trans-unit>
        <trans-unit id="787c86241856156cd077a05b7bdc7004761044c1" translate="yes" xml:space="preserve">
          <source>To build perl from its source code on the Stratus V Series platform you must have OpenVOS Release 17.1.0 or later, GNU Tools Release 3.5 or later, and the C/POSIX Runtime Libraries.</source>
          <target state="translated">Stratus V 시리즈 플랫폼의 소스 코드에서 perl을 빌드하려면 OpenVOS 릴리스 17.1.0 이상, GNU 도구 릴리스 3.5 이상 및 C / POSIX 런타임 라이브러리가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="29d9cfbafe7af9c12fb5ae5d7307a03b50f8bc3e" translate="yes" xml:space="preserve">
          <source>To build perl with AddressSanitizer, your Configure invocation should look like:</source>
          <target state="translated">AddressSanitizer를 사용하여 perl을 빌드하려면 Configure 호출이 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="b12975798f70dc1cb8c9fb59b7af2b4445d07d6d" translate="yes" xml:space="preserve">
          <source>To calculate the digest of an n-bit message where</source>
          <target state="translated">n 비트 메시지의 요약을 계산하려면</target>
        </trans-unit>
        <trans-unit id="0df1e5f84b4694c53717b89d6fb8b89ff7d44718" translate="yes" xml:space="preserve">
          <source>To calculate the distance between London (51.3N 0.5W) and Tokyo (35.7N 139.8E) in kilometers:</source>
          <target state="translated">런던 (51.3N 0.5W)과 도쿄 (35.7N 139.8E) 사이의 거리를 킬로미터로 계산하려면 :</target>
        </trans-unit>
        <trans-unit id="4cea3ec7425389162d89934663cf2df355daf6af" translate="yes" xml:space="preserve">
          <source>To call a function on each element in an array, and collect the results, use:</source>
          <target state="translated">배열의 각 요소에 대해 함수를 호출하고 결과를 수집하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="dbe4aebe356ab30727111304ed5066c2800f1b44" translate="yes" xml:space="preserve">
          <source>To call a function on each element of an array, but ignore the results:</source>
          <target state="translated">배열의 각 요소에서 함수를 호출하지만 결과를 무시하려면</target>
        </trans-unit>
        <trans-unit id="710b700709beaae3a0d7fb3e17148d99cdb1ee11" translate="yes" xml:space="preserve">
          <source>To call a function on each integer in a (small) range, you &lt;b&gt;can&lt;/b&gt; use:</source>
          <target state="translated">(작은) 범위의 각 정수에 대해 함수를 호출하려면 다음 &lt;b&gt;을&lt;/b&gt; 사용할 &lt;b&gt;수&lt;/b&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0c03ca703f3d70571e4ed1a5f4b95eb2f4f7eac" translate="yes" xml:space="preserve">
          <source>To call individual Perl subroutines, you can use any of the &lt;b&gt;call_*&lt;/b&gt; functions documented in &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;. In this example we'll use &lt;code&gt;call_argv&lt;/code&gt; .</source>
          <target state="translated">개별 Perl 서브 루틴을 호출하기 위해 &lt;b&gt;perlcall에&lt;/b&gt; 문서화 된 &lt;a href=&quot;perlcall&quot;&gt;call_ &lt;/a&gt;&lt;b&gt;*&lt;/b&gt; 함수를 사용할 수 있습니다 . 이 예에서는 &lt;code&gt;call_argv&lt;/code&gt; 를 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="f49f3d19c459317781abadc37d2ae6f14022eac3" translate="yes" xml:space="preserve">
          <source>To call subroutines:</source>
          <target state="translated">서브 루틴을 호출하려면</target>
        </trans-unit>
        <trans-unit id="5abcacc2499f97bcbde0588fdd4401b44cc6c01a" translate="yes" xml:space="preserve">
          <source>To capture a command's STDERR but discard its STDOUT (ordering is important here):</source>
          <target state="translated">명령의 STDERR을 캡처하고 STDOUT을 삭제하려면 (순서는 중요합니다) :</target>
        </trans-unit>
        <trans-unit id="891b8754dd37bb2c3dc54aab3a1185e0fd372170" translate="yes" xml:space="preserve">
          <source>To capture a command's STDERR but discard its STDOUT:</source>
          <target state="translated">명령의 STDERR을 캡처하고 해당 STDOUT을 삭제하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="7ddfc050c95c3b76b8561d8851899b023835e01c" translate="yes" xml:space="preserve">
          <source>To capture a command's STDOUT but discard its STDERR:</source>
          <target state="translated">명령의 STDOUT을 캡처하고 해당 STDERR을 삭제하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="459bfbbfb62f196ec5bdfb8f616f754fb8b81d04" translate="yes" xml:space="preserve">
          <source>To capture a program's STDERR, and let its STDOUT go to our own STDERR:</source>
          <target state="translated">프로그램의 STDERR을 캡처하고 STDOUT을 자체 STDERR로 보내려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="5bd52eb04283645c047b422b0b8e0a7d88ad61c6" translate="yes" xml:space="preserve">
          <source>To capture a program's STDERR, but discard its STDOUT:</source>
          <target state="translated">프로그램의 STDERR을 캡처하고 STDOUT을 삭제하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="8a448a300769cb48dfafecf642b7105f4ae83d7b" translate="yes" xml:space="preserve">
          <source>To capture a program's STDOUT, but discard its STDERR:</source>
          <target state="translated">프로그램의 STDOUT을 캡처하고 STDERR을 삭제하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="48535a0ea84ddf99c0ff0191b2ebc7ac2d2965e6" translate="yes" xml:space="preserve">
          <source>To catch this kind of problem, we can force each variable to be declared before use by pulling in the strict module, by putting 'use strict;' after the first line of the script.</source>
          <target state="translated">이런 종류의 문제를 잡기 위해, 우리는 엄격하게 모듈을 잡아 당기고 'use strict; 스크립트의 첫 줄 뒤에.</target>
        </trans-unit>
        <trans-unit id="ee4539dea7c8d87e83fb7b99fbcea7146f28bf41" translate="yes" xml:space="preserve">
          <source>To center a whole line of text, do something like this:</source>
          <target state="translated">전체 텍스트 줄을 가운데에 맞추려면 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="cb50b80c4012bf8864c9070a8feaf64a654c0893" translate="yes" xml:space="preserve">
          <source>To change existing lines, insert the code to modify the lines inside the &lt;code&gt;while&lt;/code&gt; loop. In this case, the code finds all lowercased versions of &quot;perl&quot; and uppercases them. The happens for every line, so be sure that you're supposed to do that on every line!</source>
          <target state="translated">기존 줄을 변경하려면 코드를 삽입하여 &lt;code&gt;while&lt;/code&gt; 루프 내부의 줄을 수정하십시오 . 이 경우 코드는 소문자 &quot;perl&quot;버전을 모두 찾아 대문자를 찾습니다. 모든 라인에서 발생하므로 모든 라인에서 그렇게해야합니다!</target>
        </trans-unit>
        <trans-unit id="3014ba02f0b23a5077d149c5a55186e1b0210812" translate="yes" xml:space="preserve">
          <source>To change one of these elements, just assign to it like this:</source>
          <target state="translated">이러한 요소 중 하나를 변경하려면 다음과 같이 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="0bc26e290e338fd9cb7ec178f79c71f3fe32327a" translate="yes" xml:space="preserve">
          <source>To change only a particular line, the input line number, &lt;code&gt;$.&lt;/code&gt; , is useful. First read and print the lines up to the one you want to change. Next, read the single line you want to change, change it, and print it. After that, read the rest of the lines and print those:</source>
          <target state="translated">특정 행만 입력 행 번호 &lt;code&gt;$.&lt;/code&gt; 유용합니다. 먼저 변경하고자하는 줄을 읽고 인쇄하십시오. 그런 다음 변경하려는 한 줄을 읽고 변경 한 후 인쇄하십시오. 그런 다음 나머지 줄을 읽고 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="f7b3b581f75dc5b407edfb21187704d85ccc3337" translate="yes" xml:space="preserve">
          <source>To change only the fifth line, you can add a test checking &lt;code&gt;$.&lt;/code&gt; , the input line number, then only perform the operation when the test passes:</source>
          <target state="translated">다섯 번째 줄만 변경하려면 &lt;code&gt;$.&lt;/code&gt; 검사하는 테스트를 추가 할 수 있습니다 . , 입력 라인 번호를 입력 한 다음 테스트를 통과 한 경우에만 작업을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="2ac56000e9557456388facc9434e99b2f25c68f2" translate="yes" xml:space="preserve">
          <source>To change part of a string, you can use the optional fourth argument which is the replacement string.</source>
          <target state="translated">문자열의 일부를 변경하려면 대체 문자열 인 선택적 네 번째 인수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="159bf1e2399227a81a68240fcbc4a8d0c4d4386e" translate="yes" xml:space="preserve">
          <source>To change the configuration you will need to use either the &lt;code&gt;-c&lt;/code&gt; or the &lt;code&gt;-d&lt;/code&gt; options.</source>
          <target state="translated">구성을 변경하려면 &lt;code&gt;-c&lt;/code&gt; 또는 &lt;code&gt;-d&lt;/code&gt; 옵션 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="82b774af2b2d757667a119fdffcb3a39066bffc5" translate="yes" xml:space="preserve">
          <source>To change the value of an</source>
          <target state="translated">의 값을 변경하려면</target>
        </trans-unit>
        <trans-unit id="c3243d9e5f9c11b853cdbfbdad7815af406db7ec" translate="yes" xml:space="preserve">
          <source>To check if you've got an object derived from a specific class you have to write:</source>
          <target state="translated">특정 클래스에서 파생 된 객체가 있는지 확인하려면 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="b5f0280c18244571ee821966259aa01905eea140" translate="yes" xml:space="preserve">
          <source>To check that a PerlIO* is valid use PerlIOValid(PerlIO *f). (All this does is really just to check that the pointer is non-NULL and that the pointer behind that is non-NULL.)</source>
          <target state="translated">PerlIO *가 유효한지 확인하려면 PerlIOValid (PerlIO * f)를 사용하십시오. (이 모든 것은 실제로 포인터가 NULL이 아니며 그 뒤에 포인터가 NULL이 아닌지 확인하는 것입니다.)</target>
        </trans-unit>
        <trans-unit id="6efc33cfc9910a60ea4ef9bf5110b124df74dec6" translate="yes" xml:space="preserve">
          <source>To circumvent this, Perl uses two hacks. They help against</source>
          <target state="translated">이를 피하기 위해 Perl은 두 가지 핵을 사용합니다. 그들은 반대</target>
        </trans-unit>
        <trans-unit id="9b687155f88b0a0c7f0b7a50cd6c0fc2a98e0825" translate="yes" xml:space="preserve">
          <source>To clear the screen, you just have to print the special sequence that tells the terminal to clear the screen. Once you have that sequence, output it when you want to clear the screen.</source>
          <target state="translated">화면을 지우려면 터미널에 화면을 지우도록 지시하는 특수 순서를 인쇄하면됩니다. 해당 시퀀스가 ​​있으면 화면을 지우고 싶을 때 출력하십시오.</target>
        </trans-unit>
        <trans-unit id="5339fbdb482ebe20149617c58a946c9025ec4bd2" translate="yes" xml:space="preserve">
          <source>To compare two strings case-insensitively, use &lt;a href=&quot;perlapi#foldEQ_utf8&quot;&gt;foldEQ_utf8() &lt;/a&gt; (the strings don't have to have the same UTF-8ness).</source>
          <target state="translated">대소 문자를 구분하지 않고 두 문자열을 비교하려면 &lt;a href=&quot;perlapi#foldEQ_utf8&quot;&gt;foldEQ_utf8 ()을&lt;/a&gt; 사용 하십시오 ( 문자열의 UTF-8이 같을 필요는 없음).</target>
        </trans-unit>
        <trans-unit id="9ef4437f2da5ad50f0107615b5cd7fb7937669db" translate="yes" xml:space="preserve">
          <source>To compile Perl with threads, add -Dusethreads to the arguments of Configure. Verify that the -D_POSIX_C_SOURCE=199506L compiler flag is automatically added to the list of flags. Also make sure that -lpthread is listed before -lc in the list of libraries to link Perl with. The hints provided for HP-UX during Configure will try very hard to get this right for you.</source>
          <target state="translated">스레드로 Perl을 컴파일하려면 Configure 인수에 -Dusethreads를 추가하십시오. -D_POSIX_C_SOURCE = 199506L 컴파일러 플래그가 플래그 목록에 자동으로 추가되는지 확인하십시오. 또한 Perl을 링크 할 라이브러리 목록에서 -lpthread가 -lc 앞에 나열되어 있는지 확인하십시오. 구성 중에 HP-UX에 제공되는 힌트는이 작업을 올바르게 수행하기 위해 매우 노력합니다.</target>
        </trans-unit>
        <trans-unit id="dca1f2d388460992485bc83958326b4fabbe3a89" translate="yes" xml:space="preserve">
          <source>To compile a 64-bit application on an UltraSparc with a recent Sun Compiler, you need to use the flag &quot;-xarch=v9&quot;. getconf(1) will tell you this, e.g.</source>
          <target state="translated">최신 Sun 컴파일러를 사용하여 UltraSparc에서 64 비트 응용 프로그램을 컴파일하려면 &quot;-xarch = v9&quot;플래그를 사용해야합니다. getconf (1)이이를 알려줄 것입니다. 예 :</target>
        </trans-unit>
        <trans-unit id="87a608f7610a06343062c0a4f15a78987866b679" translate="yes" xml:space="preserve">
          <source>To compress all files in the directory &quot;/my/home&quot; that match &quot;*.txt&quot; and store the compressed data in the same directory</source>
          <target state="translated">&quot;* .txt&quot;와 일치하는 &quot;/ my / home&quot;디렉토리의 모든 파일을 압축하고 압축 된 데이터를 동일한 디렉토리에 저장하려면</target>
        </trans-unit>
        <trans-unit id="e79c6c77e53867aede1a00267dc0d36f666b7950" translate="yes" xml:space="preserve">
          <source>To compress an RFC 1950 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to a positive number between 8 and 15.</source>
          <target state="translated">RFC 1950 데이터 스트림을 압축하려면 &lt;code&gt;WindowBits&lt;/code&gt; 를 8과 15 사이의 양수로 설정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="7421981a167883ab2bc4949efb716b7db4314b6b" translate="yes" xml:space="preserve">
          <source>To compress an RFC 1951 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;-MAX_WBITS&lt;/code&gt; .</source>
          <target state="translated">RFC 1951 데이터 스트림을 압축하려면 &lt;code&gt;WindowBits&lt;/code&gt; 를 &lt;code&gt;-MAX_WBITS&lt;/code&gt; 로 설정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="eb0992d170df6f988844c94c5a16d02581fe60f0" translate="yes" xml:space="preserve">
          <source>To compress an RFC 1952 data stream (i.e. gzip), set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;WANT_GZIP&lt;/code&gt; .</source>
          <target state="translated">RFC 1952 데이터 스트림 (예 : gzip)을 압축하려면 &lt;code&gt;WindowBits&lt;/code&gt; 를 &lt;code&gt;WANT_GZIP&lt;/code&gt; 로 설정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="6c0a5b03c1713572aa7618df4ce2ea31c5f8ea2a" translate="yes" xml:space="preserve">
          <source>To concatenate</source>
          <target state="translated">연결하기</target>
        </trans-unit>
        <trans-unit id="6e6c0c8d29557c5cf786e08230a13bcf9f5a031b" translate="yes" xml:space="preserve">
          <source>To configure the</source>
          <target state="translated">구성하려면</target>
        </trans-unit>
        <trans-unit id="b8324e82632846a0ff4c29dfcce46aaf6bb8f9fb" translate="yes" xml:space="preserve">
          <source>To connect one filehandle to several output filehandles, you can use the &lt;a href=&quot;http://search.cpan.org/perldoc/IO::Tee&quot;&gt;IO::Tee&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/perldoc/Tie::FileHandle::Multiplex&quot;&gt;Tie::FileHandle::Multiplex&lt;/a&gt; modules.</source>
          <target state="translated">하나의 파일 핸들을 여러 출력 파일 핸들에 연결하기 위해 &lt;a href=&quot;http://search.cpan.org/perldoc/IO::Tee&quot;&gt;IO :: Tee&lt;/a&gt; 또는 &lt;a href=&quot;http://search.cpan.org/perldoc/Tie::FileHandle::Multiplex&quot;&gt;Tie :: FileHandle :: Multiplex&lt;/a&gt; 모듈을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d6cbc660d600cd1c4583162826d97d790f4bf63" translate="yes" xml:space="preserve">
          <source>To conserve memory you should have your compiler modules loaded into the Link Pack Area (LPA/ELPA) rather than in a link list or step lib.</source>
          <target state="translated">메모리를 절약하려면 컴파일러 모듈을 링크 목록 또는 단계 lib가 아닌 LPA / ELPA (Link Pack Area)에로드해야합니다.</target>
        </trans-unit>
        <trans-unit id="968a823fad5813dfb21cd46750147776a5611926" translate="yes" xml:space="preserve">
          <source>To considerably speed up the initial CPAN shell startup, it is possible to use Storable to create a cache of metadata. If Storable is not available, the normal index mechanism will be used.</source>
          <target state="translated">초기 CPAN 셸 시작 속도를 상당히 높이기 위해 Storable을 사용하여 메타 데이터 캐시를 생성 할 수 있습니다. 저장 가능을 사용할 수없는 경우 일반 색인 메커니즘이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="20a4b2b8d77aba12d02e264b26db5b4fc2052c4a" translate="yes" xml:space="preserve">
          <source>To contact the author, send email to: &lt;code&gt;mjd-perl-tiefile+@plover.com&lt;/code&gt;</source>
          <target state="translated">저자에게 연락하려면 다음 &lt;code&gt;mjd-perl-tiefile+@plover.com&lt;/code&gt; 로 이메일을 보내십시오 : mjd-perl-tiefile+@plover.com</target>
        </trans-unit>
        <trans-unit id="d4e7d2faeb717445863f554610fdabbf94c812cb" translate="yes" xml:space="preserve">
          <source>To control what text is used for display, you use &quot;&lt;code&gt;L&amp;lt;text|...&amp;gt;&lt;/code&gt;&quot;, as in:</source>
          <target state="translated">표시 할 텍스트를 제어하려면 다음과 같이 &quot; &lt;code&gt;L&amp;lt;text|...&amp;gt;&lt;/code&gt; &quot;를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0f2616580d4b758d8bc7475f582ba3ef32958144" translate="yes" xml:space="preserve">
          <source>To convert &lt;code&gt;$Config{perlpath}&lt;/code&gt; to a file pathname, say:</source>
          <target state="translated">&lt;code&gt;$Config{perlpath}&lt;/code&gt; 를 파일 경로 이름으로 변환하려면 다음과 같이 말합니다.</target>
        </trans-unit>
        <trans-unit id="445d48b4e3ded0561c8b941a914e856d01c116d2" translate="yes" xml:space="preserve">
          <source>To convert &lt;code&gt;$^X&lt;/code&gt; to a file pathname, taking account of the requirements of the various operating system possibilities, say:</source>
          <target state="translated">다양한 운영 체제 요구 사항을 고려하여 &lt;code&gt;$^X&lt;/code&gt; 를 파일 경로 이름으로 변환하려면 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="c00d24e73fce2df83990c0f155f2d36a18a08fc4" translate="yes" xml:space="preserve">
          <source>To convert an octal number, use from_oct();</source>
          <target state="translated">8 진수를 변환하려면 from_oct ();</target>
        </trans-unit>
        <trans-unit id="7d95d35a7d9c8de57b1e556f0a9920a9c8320986" translate="yes" xml:space="preserve">
          <source>To convert from EBCDIC 037 to ASCII just reverse the order of the tr/// arguments like so:</source>
          <target state="translated">EBCDIC 037에서 ASCII로 변환하려면 tr /// 인수의 순서를 반대로 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="e95102da8c741e9ba252adcb490152dec1b8623d" translate="yes" xml:space="preserve">
          <source>To convert from new-style to old-style, follow this recipe:</source>
          <target state="translated">새 스타일에서 이전 스타일로 변환하려면 다음 레시피를 따르십시오.</target>
        </trans-unit>
        <trans-unit id="9fa39707ee5532360879dd87b7e44a99cff8fee0" translate="yes" xml:space="preserve">
          <source>To copy all your .c file to a backup directory</source>
          <target state="translated">모든 .c 파일을 백업 디렉토리로 복사하려면</target>
        </trans-unit>
        <trans-unit id="5ab2f997dcaa14c701c81b93174b6bfe66ee6931" translate="yes" xml:space="preserve">
          <source>To copy the array, use</source>
          <target state="translated">배열을 복사하려면</target>
        </trans-unit>
        <trans-unit id="86582412ddc1c4958ec10cc1409f68b2a052f72a" translate="yes" xml:space="preserve">
          <source>To cover such cases, you can redispatch methods via:</source>
          <target state="translated">이러한 경우를 다루기 위해 다음을 통해 메소드를 다시 배포 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="816db1c262f755f697320a74d5b828dbd17231a2" translate="yes" xml:space="preserve">
          <source>To create Unicode characters in literals, use the &lt;code&gt;\N{...}&lt;/code&gt; notation in double-quoted strings:</source>
          <target state="translated">리터럴로 유니 코드 문자를 만들려면 큰 따옴표로 묶인 문자열에서 &lt;code&gt;\N{...}&lt;/code&gt; 표기법을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c36e175a2f7ac1c4707a3b48724437b649be4b2b" translate="yes" xml:space="preserve">
          <source>To create a POD filter for translating POD documentation into some other format, you create a subclass of &lt;b&gt;Pod::Parser&lt;/b&gt; which typically overrides just the base class implementation for the following methods:</source>
          <target state="translated">POD 문서를 다른 형식으로 변환하기위한 POD 필터를 만들려면 일반적으로 다음 메서드에 대한 기본 클래스 구현 만 재정의하는 &lt;b&gt;Pod :: Parser&lt;/b&gt; 의 하위 클래스를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="3376aadc06d935bc6556cf078e6fff6d6ceed1e6" translate="yes" xml:space="preserve">
          <source>To create a Perl module that implements a PerlIO layer in Perl (as opposed to in C using XS as the interface to Perl), you need to supply some of the following subroutines. It is recommended to create these Perl modules in the PerlIO::via:: namespace, so that they can easily be located on CPAN and use the default namespace feature of the PerlIO::via module itself.</source>
          <target state="translated">Perl의 인터페이스로 XS를 사용하는 C와는 달리 Perl에서 PerlIO 계층을 구현하는 Perl 모듈을 작성하려면 다음 서브 루틴 중 일부를 제공해야합니다. 이러한 Perl 모듈을 PerlIO :: via :: 네임 스페이스에 작성하여 CPAN에 쉽게 위치하고 PerlIO :: via 모듈 자체의 기본 네임 스페이스 기능을 사용할 수 있도록하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="cea82dcc2341d67ceae28cb7f8dd640de30d8fab" translate="yes" xml:space="preserve">
          <source>To create a child &lt;b&gt;process&lt;/b&gt; identical to the parent process at its moment of conception, at least until it gets ideas of its own. A thread with protected memory.</source>
          <target state="translated">최소한 자체 프로세스의 아이디어를 얻을 때까지 상위 프로세스와 동일한 하위 &lt;b&gt;프로세스&lt;/b&gt; 를 작성합니다 . 메모리가 보호 된 스레드</target>
        </trans-unit>
        <trans-unit id="973c5f5d0d37e9d577d7def77212ab83a77d00d7" translate="yes" xml:space="preserve">
          <source>To create a complex number, use either:</source>
          <target state="translated">복소수를 만들려면 다음 중 하나를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2ba00f13d11568a68eea0b9363c1c701b94f3530" translate="yes" xml:space="preserve">
          <source>To create a handler, define it as a subroutine with the same name as the desired attribute, and declare the subroutine itself with the attribute &lt;code&gt;:ATTR&lt;/code&gt; . For example:</source>
          <target state="translated">핸들러를 작성하려면 원하는 속성과 이름이 같은 서브 루틴으로 정의하고 속성 &lt;code&gt;:ATTR&lt;/code&gt; 을 사용하여 서브 루틴 자체를 선언하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0f301595bc4c387e143da9231296df032806e83c" translate="yes" xml:space="preserve">
          <source>To create a mortal variable, use the functions:</source>
          <target state="translated">필사자 변수를 만들려면 다음 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="168d2bd52151b2f88de55aa6a46a9bc34a213502" translate="yes" xml:space="preserve">
          <source>To create a named pipe, use the &lt;code&gt;POSIX::mkfifo()&lt;/code&gt; function.</source>
          <target state="translated">명명 된 파이프를 만들려면 &lt;code&gt;POSIX::mkfifo()&lt;/code&gt; 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fb4519b518bb57bb6e760a3915cac3cb53c117b7" translate="yes" xml:space="preserve">
          <source>To create a new Perl variable with an undef value which can be accessed from your Perl script, use the following routines, depending on the variable type.</source>
          <target state="translated">Perl 스크립트에서 액세스 할 수있는 undef 값으로 새 Perl 변수를 작성하려면 변수 유형에 따라 다음 루틴을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c5e6c240b7113609dabfe56dd41076e1c64fdaed" translate="yes" xml:space="preserve">
          <source>To create a new compartment, use</source>
          <target state="translated">새로운 구획을 만들려면</target>
        </trans-unit>
        <trans-unit id="a2f8f5de503a593a35d422a3d1a1da701a2bb15e" translate="yes" xml:space="preserve">
          <source>To create a reference, use either of the following functions:</source>
          <target state="translated">참조를 작성하려면 다음 기능 중 하나를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3b14234e60346a5da75e272e4ecdc1bcef627a2f" translate="yes" xml:space="preserve">
          <source>To create a reference, we use the &lt;code&gt;newRV&lt;/code&gt; function. Note that you can cast an AV* or an HV* to type SV* in this case (and many others). This allows you to take references to arrays, hashes and scalars with the same function. Conversely, the &lt;code&gt;SvRV&lt;/code&gt; function always returns an SV*, which may need to be cast to the appropriate type if it is something other than a scalar (check with &lt;code&gt;SvTYPE&lt;/code&gt; ).</source>
          <target state="translated">참조를 만들기 위해 &lt;code&gt;newRV&lt;/code&gt; 함수를 사용합니다 . 이 경우 AV * 또는 HV *를 캐스팅하여 SV *를 입력 할 수 있습니다 (및 기타 여러 유형). 이를 통해 동일한 함수를 사용하여 배열, 해시 및 스칼라를 참조 할 수 있습니다. 반대로 &lt;code&gt;SvRV&lt;/code&gt; 함수는 항상 SV *를 반환합니다. SV *는 스칼라가 아닌 다른 유형 인 경우 적절한 유형으로 캐스트해야 할 수도 있습니다 ( &lt;code&gt;SvTYPE&lt;/code&gt; 으로 확인 ).</target>
        </trans-unit>
        <trans-unit id="f750d278ece92b690ce083757a8b99d17e4a1cc6" translate="yes" xml:space="preserve">
          <source>To create a shared library, the following steps must be performed:</source>
          <target state="translated">공유 라이브러리를 작성하려면 다음 단계를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="3c6eb343e88be36bc92d3d97f3219df475d3ded3" translate="yes" xml:space="preserve">
          <source>To create a zip file, &lt;code&gt;output.zip&lt;/code&gt; , that contains the compressed contents of the files &lt;code&gt;alpha.txt&lt;/code&gt; and &lt;code&gt;beta.txt&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;alpha.txt&lt;/code&gt; 및 &lt;code&gt;beta.txt&lt;/code&gt; 파일의 압축 된 내용을 포함 하는 zip 파일 &lt;code&gt;output.zip&lt;/code&gt; 을 만들려면</target>
        </trans-unit>
        <trans-unit id="a8a9c4100fca7c9df2f642138fcef0fc96929592" translate="yes" xml:space="preserve">
          <source>To create an HV, you use the following routine:</source>
          <target state="translated">HV를 작성하려면 다음 루틴을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0094ef6c2580e3be5fb982924088c9990a9a669b" translate="yes" xml:space="preserve">
          <source>To create an RFC 1950 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to a positive number.</source>
          <target state="translated">RFC 1950 데이터 스트림을 작성하려면 &lt;code&gt;WindowBits&lt;/code&gt; 를 양수로 설정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c43fa53c9a4af41c4362a70dd0d3da19011de429" translate="yes" xml:space="preserve">
          <source>To create an RFC 1951 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;-MAX_WBITS&lt;/code&gt; .</source>
          <target state="translated">RFC 1951 데이터 스트림을 작성하려면 &lt;code&gt;WindowBits&lt;/code&gt; 를 &lt;code&gt;-MAX_WBITS&lt;/code&gt; 로 설정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="dbb0b362cb67cdcf254362d24dcd3489205dd8b1" translate="yes" xml:space="preserve">
          <source>To create your own result types you have two options:</source>
          <target state="translated">자신 만의 결과 유형을 만들려면 다음 두 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="948e86a50124d6c16a2bb795d3ad5dd4ba16fd66" translate="yes" xml:space="preserve">
          <source>To deallocate the memory of a &lt;b&gt;referent&lt;/b&gt; (first triggering its &lt;code&gt;DESTROY&lt;/code&gt; method, if it has one).</source>
          <target state="translated">&lt;b&gt;참조&lt;/b&gt; 의 메모리 할당을 해제합니다 (먼저 &lt;code&gt;DESTROY&lt;/code&gt; 메소드가있는 경우 해당 메소드를 트리거 ).</target>
        </trans-unit>
        <trans-unit id="684b7eba474ceeeee203e03efc4972ceab5f4011" translate="yes" xml:space="preserve">
          <source>To declare a file-private variable, you still use a lexical variable. A file is also a scope, so a lexical variable defined in the file cannot be seen from any other file.</source>
          <target state="translated">파일 전용 변수를 선언하기 위해 여전히 어휘 변수를 사용합니다. 파일도 범위이므로 파일에 정의 된 어휘 변수를 다른 파일에서 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="26f359ab42151643a554fcca60e916cbc3b8c6c1" translate="yes" xml:space="preserve">
          <source>To declare multiple parents, you simply need to pass multiple class names to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; parent&lt;/code&gt; :</source>
          <target state="translated">여러 부모를 선언하려면 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; parent&lt;/code&gt; 를 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하기 위해 여러 클래스 이름을 전달하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="195f600c4f130988d6cb960024f570abb452421b" translate="yes" xml:space="preserve">
          <source>To declare subroutines:</source>
          <target state="translated">서브 루틴을 선언하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d689355c5c4c25b69703a4f888325a4f315e40d5" translate="yes" xml:space="preserve">
          <source>To decode the string, use the &lt;code&gt;uri_unescape&lt;/code&gt; function:</source>
          <target state="translated">문자열을 디코딩하려면 &lt;code&gt;uri_unescape&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c00b1b3082eeba042c1321adab39b3572b77ab5f" translate="yes" xml:space="preserve">
          <source>To define a new encoding, use:</source>
          <target state="translated">새로운 인코딩을 정의하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="90539d229e0f3e1882d607e70d036357967dd42b" translate="yes" xml:space="preserve">
          <source>To define an anonymous subroutine at runtime:</source>
          <target state="translated">런타임시 익명 서브 루틴을 정의하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="c9cdf944c5644c128ca4890eae1d815775404ea8" translate="yes" xml:space="preserve">
          <source>To define your own variables, simply add them to the hash, or change existing values if you need to. The level and format are passed in as references to scalars, but it is unlikely that they will need to be changed or even used.</source>
          <target state="translated">고유 한 변수를 정의하려면 해시에 변수를 추가하거나 필요한 경우 기존 값을 변경하십시오. 레벨과 형식은 스칼라에 대한 참조로 전달되지만 변경되거나 사용될 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="663c37fcccd4eb9d16f3753290874adfe0a38adc" translate="yes" xml:space="preserve">
          <source>To delete a filter pass &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; to it.</source>
          <target state="translated">필터 패스를 삭제하려면 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a7282a69c7ceaa80a01f9176cf957edc11cea4de" translate="yes" xml:space="preserve">
          <source>To delete lines, only print the ones that you want.</source>
          <target state="translated">줄을 삭제하려면 원하는 줄만 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="c1469f4d29b40fb0b7ab86c2c4e92578f7c6eb9f" translate="yes" xml:space="preserve">
          <source>To determine at runtime if this capability has been compiled in your perl, you can check the value of &lt;code&gt;$Config{usesitecustomize}&lt;/code&gt; .</source>
          <target state="translated">런타임 &lt;code&gt;$Config{usesitecustomize}&lt;/code&gt; 기능이 perl에 컴파일되었는지 판별하려면 $ Config {usesitecustomize} 값을 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5ce033ec9e41969bd8c16961760514dcb521d365" translate="yes" xml:space="preserve">
          <source>To determine if a module came with your version of Perl, you can install and use the &lt;a href=&quot;module/corelist&quot;&gt;Module::CoreList&lt;/a&gt; module. It has the information about the modules (with their versions) included with each release of Perl.</source>
          <target state="translated">모듈이 Perl 버전과 함께 제공되었는지 확인하려면 &lt;a href=&quot;module/corelist&quot;&gt;Module :: CoreList&lt;/a&gt; 모듈을 설치하고 사용할 수 있습니다 . 여기에는 각 Perl 릴리스에 포함 된 모듈 (버전과 함께)에 대한 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3640814314afd9f7ac9d11a68cf889d6f47fec5" translate="yes" xml:space="preserve">
          <source>To determine if a string is in Unicode, use:</source>
          <target state="translated">문자열이 유니 코드인지 확인하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bca0ec2b6522f981d9c11831a03f1f68a8800f50" translate="yes" xml:space="preserve">
          <source>To determine if an SV is a reference, you can use the following macro:</source>
          <target state="translated">SV가 참조인지 확인하기 위해 다음 매크로를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9936c817f7d3f0a431d8c4cc266d4265437482c" translate="yes" xml:space="preserve">
          <source>To determine if you are running under ASCII or EBCDIC, you can use the return value of &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; to test one or more character values. For example:</source>
          <target state="translated">ASCII 또는 EBCDIC에서 실행 중인지 판별하기 위해 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; 의 리턴 값을 사용하여 하나 이상의 문자 값을 테스트 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="86e75dff4a5cb692b3db4e186257a30b993c598a" translate="yes" xml:space="preserve">
          <source>To determine whether or not perl was built under an EBCDIC code page you can use the Config module like so:</source>
          <target state="translated">perl이 EBCDIC 코드 페이지에서 빌드되었는지 여부를 판별하려면 다음과 같이 구성 모듈을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7ca989a561cc6bb21cb242f3f9a4867fcc2a0a2" translate="yes" xml:space="preserve">
          <source>To determine which category a specific warning has been assigned to see &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt; 를 볼 수 있도록 특정 경고가 할당 된 카테고리를 결정 합니다.</target>
        </trans-unit>
        <trans-unit id="d2650be423c3da22a5978107c38e624c70d0e420" translate="yes" xml:space="preserve">
          <source>To die with a simple string message, the &lt;a href=&quot;#croak&quot;&gt;croak&lt;/a&gt; function may be more convenient.</source>
          <target state="translated">간단한 문자열 메시지로 죽기 위해 &lt;a href=&quot;#croak&quot;&gt;croak&lt;/a&gt; 기능이 더 편리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="347758299b3b52a08c513c37128e636634230c65" translate="yes" xml:space="preserve">
          <source>To disable prototypes:</source>
          <target state="translated">프로토 타입을 비활성화하려면 :</target>
        </trans-unit>
        <trans-unit id="5d0844b4d1a693267fe5fcf752c200ff27d0a20a" translate="yes" xml:space="preserve">
          <source>To disable scoping:</source>
          <target state="translated">범위 지정을 비활성화하려면</target>
        </trans-unit>
        <trans-unit id="6a2e4cf0ee9b26b39ec068b4b4c9bcaa2ebda9e0" translate="yes" xml:space="preserve">
          <source>To disable this check, set this variable to &lt;code&gt;false&lt;/code&gt; .</source>
          <target state="translated">이 검사를 비활성화하려면이 변수를 &lt;code&gt;false&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="b80cbb6c9445e33c66e64e8bbc664c2dc7cb143d" translate="yes" xml:space="preserve">
          <source>To disable this default safe mode, set these values to something higher than 0. At a level of 1, you get backtraces upon receiving any kind of warning (this is often annoying) or exception (this is often valuable). Unfortunately, the debugger cannot discern fatal exceptions from non-fatal ones. If &lt;code&gt;dieLevel&lt;/code&gt; is even 1, then your non-fatal exceptions are also traced and unceremoniously altered if they came from &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval'ed&lt;/a&gt;&lt;/code&gt; strings or from any kind of &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; within modules you're attempting to load. If &lt;code&gt;dieLevel&lt;/code&gt; is 2, the debugger doesn't care where they came from: It usurps your exception handler and prints out a trace, then modifies all exceptions with its own embellishments. This may perhaps be useful for some tracing purposes, but tends to hopelessly destroy any program that takes its exception handling seriously.</source>
          <target state="translated">이 기본 안전 모드를 사용하지 않으려면이 값을 0보다 높은 값으로 설정하십시오. 1 레벨에서는 모든 종류의 경고 (종종 성가시다) 또는 예외 (종종 귀중한 것)를 수신하면 역 추적을받습니다. 불행하게도, 디버거는 치명적인 예외를 치명적이지 않은 예외와 구별 할 수 없습니다. 경우 &lt;code&gt;dieLevel&lt;/code&gt; 는 ,도 1 다음 치명적이지 않은 예외도 추적하고 무례 그들이에서 온 경우 변경 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval'ed&lt;/a&gt;&lt;/code&gt; 문자열이나 어떤 종류에서 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 당신이 부하를 시도하고 모듈 내에서. &lt;code&gt;dieLevel&lt;/code&gt; 인 경우2는 디버거가 어디에서 왔는지 상관하지 않습니다. 예외 처리기를 빼내고 추적을 인쇄 한 다음 자체 예외로 모든 예외를 수정합니다. 이것은 아마도 일부 추적 목적에 유용 할 수 있지만 예외 처리를 심각하게 취하는 프로그램을 절망적으로 파괴하는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d156c08336acd4fd9a2800ec24f479a8112dea4" translate="yes" xml:space="preserve">
          <source>To disable version checking:</source>
          <target state="translated">버전 확인을 비활성화하려면</target>
        </trans-unit>
        <trans-unit id="738a71c259ac0a8afb90292476b05521cb3a2b41" translate="yes" xml:space="preserve">
          <source>To disallow the use of, for example, &lt;code&gt;LWP&lt;/code&gt; and &lt;code&gt;Net::FTP&lt;/code&gt; , you could set $File::Fetch::BLACKLIST to:</source>
          <target state="translated">예를 들어 &lt;code&gt;LWP&lt;/code&gt; 및 &lt;code&gt;Net::FTP&lt;/code&gt; 사용을 허용하지 않으려면 $ File :: Fetch :: BLACKLIST를 다음과 같이 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="80dd5fada40953f3424fd8a183a453e068557bb1" translate="yes" xml:space="preserve">
          <source>To discover what type of value the reference refers to, use the following macro and then check the return value.</source>
          <target state="translated">참조가 참조하는 유형의 값을 찾으려면 다음 매크로를 사용하여 리턴 값을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="8fc94d5f52eb1139b287df828008badfb6c3e089" translate="yes" xml:space="preserve">
          <source>To display and change the libnet configuration run the libnetcfg command.</source>
          <target state="translated">libnet 구성을 표시하고 변경하려면 libnetcfg 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="60ed656a96349b78cdba5a83471f5324d8dd1e87" translate="yes" xml:space="preserve">
          <source>To display the results you use the</source>
          <target state="translated">결과를 표시하려면</target>
        </trans-unit>
        <trans-unit id="ad781551179d37e74d6f0377992b51ea7bdaace0" translate="yes" xml:space="preserve">
          <source>To do it correctly, you can use one of the &lt;code&gt;Date&lt;/code&gt; modules since they work with calendars instead of times. The &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; module makes it simple, and give you the same time of day, only the day before, despite daylight saving time changes:</source>
          <target state="translated">올바르게하려면 &lt;code&gt;Date&lt;/code&gt; 대신 달력 대신 사용할 수있는 날짜 모듈 중 하나를 사용할 수 있습니다 . &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;날짜 시간&lt;/a&gt; 모듈은 일광 절약 시간 변경에도 불구하고, 간단하게, 당신에게 하루 중 같은 시간 전에 만 일을 제공 :</target>
        </trans-unit>
        <trans-unit id="f1d6265a7b40372fb699b2b2f27a1df7b8f80a66" translate="yes" xml:space="preserve">
          <source>To do the equivalent of &lt;code&gt;cp -R&lt;/code&gt; (i.e. copy an entire directory tree recursively) in portable Perl, you'll either need to write something yourself or find a good CPAN module such as &lt;a href=&quot;http://search.cpan.org/perldoc/File::Copy::Recursive&quot;&gt;File::Copy::Recursive&lt;/a&gt;.</source>
          <target state="translated">휴대용 Perl에서 &lt;code&gt;cp -R&lt;/code&gt; 과 동등한 작업을 수행하려면 (즉, 전체 디렉토리 트리를 재귀 적으로 복사), 직접 작성하거나 &lt;a href=&quot;http://search.cpan.org/perldoc/File::Copy::Recursive&quot;&gt;File :: Copy :: Recursive&lt;/a&gt; 와 같은 훌륭한 CPAN 모듈을 찾아야합니다 .</target>
        </trans-unit>
        <trans-unit id="800198c8e77892b2ea37f8a62c33fb5be9843971" translate="yes" xml:space="preserve">
          <source>To do this we need to produce a program by parsing the text. We then need to execute the program to find the point in the string that matches. And we need to do the whole thing efficiently.</source>
          <target state="translated">이렇게하려면 텍스트를 파싱하여 프로그램을 만들어야합니다. 그런 다음 일치하는 문자열에서 포인트를 찾기 위해 프로그램을 실행해야합니다. 그리고 우리는 모든 일을 효율적으로해야합니다.</target>
        </trans-unit>
        <trans-unit id="b3b368d6bf057c7196323316138f2bb623cf857e" translate="yes" xml:space="preserve">
          <source>To do this you need to store a copy of the object returned from the tie.</source>
          <target state="translated">이렇게하려면 넥타이에서 반환 된 객체의 사본을 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="16944f02408f01608a70adc6c00bddd6a6f21c5d" translate="yes" xml:space="preserve">
          <source>To do this, declare the XSUB as</source>
          <target state="translated">이렇게하려면 XSUB를 다음과 같이 선언하십시오.</target>
        </trans-unit>
        <trans-unit id="9ba25feb906f9144f135e56832aaff07eb5da168" translate="yes" xml:space="preserve">
          <source>To do this, simple invoke the redispatch as:</source>
          <target state="translated">이렇게하려면 redispatch를 다음과 같이 간단하게 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="2b963497fc0bd80a2ad6cd72e920bb19d3acf535" translate="yes" xml:space="preserve">
          <source>To do this, you can either extend an existing &lt;a href=&quot;http://search.cpan.org/perldoc/TAP::Formatter&quot;&gt;TAP::Formatter&lt;/a&gt;, or write your own. Writing formatters are a bit more involved than writing a</source>
          <target state="translated">이를 위해 기존 &lt;a href=&quot;http://search.cpan.org/perldoc/TAP::Formatter&quot;&gt;TAP :: Formatter를&lt;/a&gt; 확장 하거나 직접 작성할 수 있습니다. 쓰기 포맷터는 쓰기보다 조금 더 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="4d922248445626035fad600ec3b500e3d07eeccb" translate="yes" xml:space="preserve">
          <source>To do this, you can either extend an existing &lt;a href=&quot;parser/sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;, or write your own. It's a pretty simple API, and they can be loaded and configured using the &lt;code&gt;sources&lt;/code&gt; parameter to &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt;.</source>
          <target state="translated">이를 위해 기존 &lt;a href=&quot;parser/sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt; 를 확장 하거나 직접 작성할 수 있습니다. 꽤 간단한 API이며, &lt;code&gt;sources&lt;/code&gt; 매개 변수를 사용하여 &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt; 로로드 및 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c9af8e6fc2b2d44ed39a720480b5eca952598206" translate="yes" xml:space="preserve">
          <source>To do this, you have to parse out each word in the input stream. We'll pretend that by word you mean chunk of alphabetics, hyphens, or apostrophes, rather than the non-whitespace chunk idea of a word given in the previous question:</source>
          <target state="translated">이렇게하려면 입력 스트림에서 각 단어를 구문 분석해야합니다. 우리는 이전 질문에서 주어진 단어의 공백이 아닌 덩어리 아이디어보다는 단어로 알파벳, 하이픈 또는 아포스트로피를 의미한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="a594dc0644909bfef7173f1f8eb29922809128db" translate="yes" xml:space="preserve">
          <source>To do what you meant properly, you must write:</source>
          <target state="translated">제대로 된 것을하려면 다음과 같이 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="d3e2fbf11b8c81738d92b26c858673a8798bed9d" translate="yes" xml:space="preserve">
          <source>To emphasize that you are operating only on ASCII characters, you can append &lt;code&gt;_A&lt;/code&gt; to each of the macros in the ASCII column: &lt;code&gt;isALPHA_A&lt;/code&gt; , &lt;code&gt;isDIGIT_A&lt;/code&gt; , and so on.</source>
          <target state="translated">ASCII 문자로만 작업하고 있음을 강조하기 위해 ASCII 열의 각 매크로에 &lt;code&gt;_A&lt;/code&gt; 를 추가 할 수 있습니다 ( &lt;code&gt;isALPHA_A&lt;/code&gt; , &lt;code&gt;isDIGIT_A&lt;/code&gt; 등).</target>
        </trans-unit>
        <trans-unit id="e2f50143516f5760cd1414be18dcb711d9b307dd" translate="yes" xml:space="preserve">
          <source>To enable colouring from the command line, you can use the &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Builder::Tester::Color&quot;&gt;Text::Builder::Tester::Color&lt;/a&gt; module like so:</source>
          <target state="translated">명령 행에서 색상을 표시하려면 &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Builder::Tester::Color&quot;&gt;Text :: Builder :: Tester :: Color&lt;/a&gt; 모듈을 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b01967f773567b844b2b023b2a86bde4df70fc34" translate="yes" xml:space="preserve">
          <source>To enable prototypes:</source>
          <target state="translated">프로토 타입을 활성화하려면</target>
        </trans-unit>
        <trans-unit id="5ccde66aca7ada9c8fed76ada1d4a0446a4f8743" translate="yes" xml:space="preserve">
          <source>To enable scoping:</source>
          <target state="translated">범위 지정을 활성화하려면</target>
        </trans-unit>
        <trans-unit id="1484f429016f98a746a3ab26c198f24bb67adaaa" translate="yes" xml:space="preserve">
          <source>To enable version checking:</source>
          <target state="translated">버전 확인을 활성화하려면</target>
        </trans-unit>
        <trans-unit id="270b403e8cadfb40d1d97c0de3bf7642f9c98fb6" translate="yes" xml:space="preserve">
          <source>To encode a string yourself, use the &lt;a href=&quot;http://search.cpan.org/perldoc/URI::Escape&quot;&gt;URI::Escape&lt;/a&gt; module. The &lt;code&gt;uri_escape&lt;/code&gt; function returns the escaped string:</source>
          <target state="translated">문자열을 직접 인코딩하려면 &lt;a href=&quot;http://search.cpan.org/perldoc/URI::Escape&quot;&gt;URI :: Escape&lt;/a&gt; 모듈을 사용하십시오 . &lt;code&gt;uri_escape&lt;/code&gt; 의 기능은 이스케이프 문자열을 반환합니다 :</target>
        </trans-unit>
        <trans-unit id="197383dea9cb9c2b7e4139f047ab7802bc1168de" translate="yes" xml:space="preserve">
          <source>To end a Pod block, use a blank line, then a line beginning with &quot;=cut&quot;, and a blank line after it. This lets Perl (and the Pod formatter) know that this is where Perl code is resuming. (The blank line before the &quot;=cut&quot; is not technically necessary, but many older Pod processors require it.)</source>
          <target state="translated">Pod 블록을 끝내려면 빈 줄을 사용한 다음 &quot;= cut&quot;으로 시작하는 줄과 그 뒤에 빈 줄을 사용하십시오. 이를 통해 Perl (및 포드 포맷터)은 이것이 Perl 코드가 재개되는 위치임을 알 수 있습니다. &quot;= 컷&quot;앞의 빈 줄은 기술적으로 필요하지 않지만 많은 구형 포드 프로세서에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0ae4a1a4ec134ed8922ee208a028b2c3245ebe13" translate="yes" xml:space="preserve">
          <source>To enforce scalar context in this particular case, however, you need merely omit the parentheses:</source>
          <target state="translated">그러나이 특별한 경우에 스칼라 컨텍스트를 적용하려면 괄호를 생략하면됩니다.</target>
        </trans-unit>
        <trans-unit id="5528aa31607b22ee5ba7b25dc9ad20fd957a80a3" translate="yes" xml:space="preserve">
          <source>To ensure your Perl programs can see these newly installed modules, set your &lt;code&gt;PERL5LIB&lt;/code&gt; environment variable to</source>
          <target state="translated">Perl 프로그램이 새로 설치된 모듈을 볼 수있게하려면 &lt;code&gt;PERL5LIB&lt;/code&gt; 환경 변수를</target>
        </trans-unit>
        <trans-unit id="7aa8a6d9b5359d93562881107c4eb01ac8b79421" translate="yes" xml:space="preserve">
          <source>To escape the special meaning of &lt;code&gt;.&lt;/code&gt;, we use &lt;code&gt;\Q&lt;/code&gt; :</source>
          <target state="translated">의 특별한 의미를 피하기 위해 &lt;code&gt;.&lt;/code&gt; , 우리는 &lt;code&gt;\Q&lt;/code&gt; 사용합니다 :</target>
        </trans-unit>
        <trans-unit id="1f8b13457bc503e2905034bca18967c492e5be31" translate="yes" xml:space="preserve">
          <source>To exchange a command's STDOUT and STDERR in order to capture the STDERR but leave its STDOUT to come out our old STDERR:</source>
          <target state="translated">STDERR을 캡처하기 위해 명령의 STDOUT 및 STDERR을 교환하지만 기존 STDERR을 나오도록 STDOUT을 그대로 두려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="f19cbea3f43d914ef5dccac2f20ddb20b0a670bb" translate="yes" xml:space="preserve">
          <source>To exchange a command's STDOUT and STDERR in order to capture the STDERR but leave its STDOUT to come out the old STDERR:</source>
          <target state="translated">STDERR을 캡처하기 위해 명령의 STDOUT 및 STDERR을 교환하지만 기존 STDERR을 나오도록 STDOUT을 그대로 두려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="1e299ba0ecd4337d918ed97321e55b553fe7e0a0" translate="yes" xml:space="preserve">
          <source>To exercise the various implementations the script &lt;a href=&quot;#Example-2&quot;&gt;below&lt;/a&gt; can be used.</source>
          <target state="translated">다양한 구현을 수행하기 위해 &lt;a href=&quot;#Example-2&quot;&gt;아래&lt;/a&gt; 스크립트 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="746a283f2992b56a8070a48ac33ef2cb2b8ab7fb" translate="yes" xml:space="preserve">
          <source>To explain them each in detail:</source>
          <target state="translated">각각에 대해 자세히 설명하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="337ab3fc6e23ee2083bb48006f6530a512cb7265" translate="yes" xml:space="preserve">
          <source>To explicitly turn off a &quot;FATAL&quot; warning you just disable the warning it is associated with. So, for example, to disable the &quot;void&quot; warning in the example above, either of these will do the trick:</source>
          <target state="translated">&quot;FATAL&quot;경고를 명시 적으로 끄려면 관련된 경고를 비활성화하면됩니다. 예를 들어 위의 예에서 &quot;void&quot;경고를 비활성화하려면 다음 중 하나를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d8cfaf574ce10955d44800ed1fb485165bb12d03" translate="yes" xml:space="preserve">
          <source>To extract a comma-delimited list of numbers, use</source>
          <target state="translated">쉼표로 구분 된 숫자 목록을 추출하려면</target>
        </trans-unit>
        <trans-unit id="d086f02213d0494d6662b67a4783c59065f8a170" translate="yes" xml:space="preserve">
          <source>To extract an ASCII tar archive on BS2000 POSIX you need an ASCII filesystem (we used the mountpoint /usr/local/ascii for this). Now you extract the archive in the ASCII filesystem without I/O-conversion:</source>
          <target state="translated">BS2000 POSIX에서 ASCII tar 아카이브를 추출하려면 ASCII 파일 시스템이 필요합니다 (우리는 마운트 포인트 / usr / local / ascii를 사용했습니다). 이제 I / O 변환없이 ASCII 파일 시스템에서 아카이브를 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="c062b7c2a495ae2a5b72a1379e8b1a41239ea1d2" translate="yes" xml:space="preserve">
          <source>To find how to use this module in detail, see &lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt;.</source>
          <target state="translated">이 모듈을 사용하는 방법을 자세히 알아 보려면 &lt;a href=&quot;../encode&quot;&gt;인코딩을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b3930f92a272e8f2e02166feb6d52740dba8a2a7" translate="yes" xml:space="preserve">
          <source>To find out</source>
          <target state="translated">알아 내다</target>
        </trans-unit>
        <trans-unit id="8b9ad1d9bf5e88e70343c9bc73bc8f95e823175e" translate="yes" xml:space="preserve">
          <source>To find out how to use this module in detail, see &lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt;.</source>
          <target state="translated">이 모듈을 사용하는 방법을 자세히 알아 보려면 &lt;a href=&quot;../encode&quot;&gt;인코딩을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8814e60c44afe937889a748a7dc5d647bd329617" translate="yes" xml:space="preserve">
          <source>To find out in detail which encodings are supported by this package, see &lt;a href=&quot;encode/supported&quot;&gt;Encode::Supported&lt;/a&gt;.</source>
          <target state="translated">이 패키지에서 지원되는 인코딩을 자세히 확인하려면 &lt;a href=&quot;encode/supported&quot;&gt;Encode :: Supported를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7957585a16fb8e9f58abff4512426bfd62b9e660" translate="yes" xml:space="preserve">
          <source>To find out where a module's source code is located, use</source>
          <target state="translated">모듈의 소스 코드가있는 곳을 찾으려면</target>
        </trans-unit>
        <trans-unit id="714fa5ade47f6c038c4e5047b338fbf758e5ccc9" translate="yes" xml:space="preserve">
          <source>To find out whether a given string is a valid non-zero number, it's sometimes enough to test it against both numeric 0 and also lexical &quot;0&quot; (although this will cause noises if warnings are on). That's because strings that aren't numbers count as 0, just as they do in &lt;b&gt;awk&lt;/b&gt;:</source>
          <target state="translated">주어진 문자열이 0이 아닌 유효한 숫자인지 확인하려면 숫자 0과 어휘 &quot;0&quot;에 대해 테스트하는 것으로 충분합니다 (경고가 켜져 있으면 소음이 발생하지만). 숫자가 아닌 문자열은 &lt;b&gt;awk&lt;/b&gt; 에서와 같이 0으로 계산되기 때문입니다 .</target>
        </trans-unit>
        <trans-unit id="b365160bfd575c380666252714a7e2191298f003" translate="yes" xml:space="preserve">
          <source>To find out which character encodings your Perl supports, run:</source>
          <target state="translated">Perl이 지원하는 문자 인코딩을 찾으려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="8d0d1d4b42258f044bb86db954a57628e8eecd09" translate="yes" xml:space="preserve">
          <source>To find something between two single characters, a pattern like &lt;code&gt;/x([^x]*)x/&lt;/code&gt; will get the intervening bits in $1. For multiple ones, then something more like &lt;code&gt;/alpha(.*?)omega/&lt;/code&gt; would be needed. For nested patterns and/or balanced expressions, see the so-called &lt;a href=&quot;perlre#(%3fPARNO)-(%3f-PARNO)-(%3f%2bPARNO)-(%3fR)-(%3f0)&quot;&gt;(?PARNO)&lt;/a&gt; construct (available since perl 5.10). The CPAN module &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;Regexp::Common&lt;/a&gt; can help to build such regular expressions (see in particular &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common::balanced&quot;&gt;Regexp::Common::balanced&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common::delimited&quot;&gt;Regexp::Common::delimited&lt;/a&gt;).</source>
          <target state="translated">두 개의 단일 문자 사이에서 무언가를 찾으려면 &lt;code&gt;/x([^x]*)x/&lt;/code&gt; 와 같은 패턴 은 $ 1의 중간 비트를 가져옵니다. 여러 개의 경우에는 &lt;code&gt;/alpha(.*?)omega/&lt;/code&gt; 와 같은 것이 필요합니다. 중첩 패턴 및 / 또는 균형 잡힌 표현에 대해서는 소위 &lt;a href=&quot;perlre#(%3fPARNO)-(%3f-PARNO)-(%3f%2bPARNO)-(%3fR)-(%3f0)&quot;&gt;(? PARNO)&lt;/a&gt; 구문 (perl 5.10부터 사용 가능 )을 참조하십시오 . CPAN 모듈 &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;Regexp :: Common&lt;/a&gt; 은 이러한 정규 표현식을 작성하는 데 도움이 될 수 있습니다 (특히 &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common::balanced&quot;&gt;Regexp :: Common :: balanced&lt;/a&gt; 및 &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common::delimited&quot;&gt;Regexp :: Common :: delimited 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c8886406693c43465a74828d32fde569bd987324" translate="yes" xml:space="preserve">
          <source>To find the first array element which satisfies a condition, you can use the &lt;code&gt;first()&lt;/code&gt; function in the &lt;a href=&quot;list/util&quot;&gt;List::Util&lt;/a&gt; module, which comes with Perl 5.8. This example finds the first element that contains &quot;Perl&quot;.</source>
          <target state="translated">조건을 만족하는 첫 번째 배열 요소를 찾으려면 Perl 5.8과 함께 제공되는 &lt;a href=&quot;list/util&quot;&gt;List :: Util&lt;/a&gt; 모듈 에서 &lt;code&gt;first()&lt;/code&gt; 함수를 사용할 수 있습니다 . 이 예에서는 &quot;Perl&quot;이 포함 된 첫 번째 요소를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="f1ca27f7c9ffaf0873146b4d5569bf1f7dd85f24" translate="yes" xml:space="preserve">
          <source>To find the package you are currently in, use the special literal &lt;code&gt;__PACKAGE__&lt;/code&gt; , as documented in &lt;a href=&quot;perldata&quot;&gt;perldata&lt;/a&gt;. You can only use the special literals as separate tokens, so you can't interpolate them into strings like you can with variables:</source>
          <target state="translated">현재있는 패키지를 찾으려면 &lt;a href=&quot;perldata&quot;&gt;perldata에&lt;/a&gt; 설명 된대로 특수 리터럴 &lt;code&gt;__PACKAGE__&lt;/code&gt; 를 사용하십시오 . 특수 리터럴 만 별도의 토큰으로 사용할 수 있으므로 변수를 사용하는 것처럼 문자열로 보간 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cffcf6d33c52e5caff06e5888e1b1afff8c79cd9" translate="yes" xml:space="preserve">
          <source>To find the synonyms for single-forms, such as &lt;code&gt;\p{Any}&lt;/code&gt; , use &lt;a href=&quot;#prop_aliases()&quot;&gt;prop_aliases()&lt;/a&gt; instead.</source>
          <target state="translated">같은 단일 형태의 동의어 찾으려면 &lt;code&gt;\p{Any}&lt;/code&gt; 를 사용 &lt;a href=&quot;#prop_aliases()&quot;&gt;prop_aliases ()&lt;/a&gt; 대신합니다.</target>
        </trans-unit>
        <trans-unit id="2b4474f5909a02cbe785465728ea131216f023c4" translate="yes" xml:space="preserve">
          <source>To find your local Perl Mongers (or PM as they're commonly abbreviated) group check the international Perl Mongers directory at &lt;a href=&quot;http://www.pm.org/&quot;&gt;http://www.pm.org/&lt;/a&gt;.</source>
          <target state="translated">현지 Perl Mongers (또는 일반적으로 약어 인 PM) 그룹을 찾으려면 국제 Perl Mongers 디렉토리 ( &lt;a href=&quot;http://www.pm.org/&quot;&gt;http://www.pm.org/&lt;/a&gt; )를 확인 하십시오 .</target>
        </trans-unit>
        <trans-unit id="51fa9c8218dc025937f10203b9150ec3a3d4872c" translate="yes" xml:space="preserve">
          <source>To fire up the debugger, type</source>
          <target state="translated">디버거를 시작하려면 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="5061c6729e5e674eb297e87fb65b6e686195258a" translate="yes" xml:space="preserve">
          <source>To fix by applying one, as it were. In the realm of hackerdom, a listing of the differences between two versions of a program as might be applied by the &lt;b&gt;patch&lt;/b&gt;(1) program when you want to fix a bug or upgrade your old version.</source>
          <target state="translated">그대로 적용하여 수정하십시오. 해커 영역에서, 버그를 수정하거나 이전 버전을 업그레이드 할 때 &lt;b&gt;패치&lt;/b&gt; (1) 프로그램 에 의해 적용될 수있는 프로그램의 두 버전 간의 차이점 목록 .</target>
        </trans-unit>
        <trans-unit id="baa8da9e4b55dce6e5a8c524e072f785277c31e7" translate="yes" xml:space="preserve">
          <source>To fix this, some people formed Unicode, Inc. and produced a new character set containing all the characters you can possibly think of and more. There are several ways of representing these characters, and the one Perl uses is called UTF-8. UTF-8 uses a variable number of bytes to represent a character. You can learn more about Unicode and Perl's Unicode model in &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;.</source>
          <target state="translated">이 문제를 해결하기 위해 일부 사람들은 Unicode, Inc.를 구성하고 생각할 수있는 모든 문자 등을 포함하는 새로운 문자 집합을 만들었습니다. 이러한 문자를 나타내는 여러 가지 방법이 있으며 Perl에서 사용하는 방법을 UTF-8이라고합니다. UTF-8은 가변 바이트 수를 사용하여 문자를 나타냅니다. &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; 에서 유니 코드 및 Perl의 유니 코드 모델에 대해 자세히 알아볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a4f76f5a03185d9e714674242e64dfcf1b7f20c4" translate="yes" xml:space="preserve">
          <source>To forbid ASCII/non-ASCII matches (like &quot;k&quot; with &lt;code&gt;\N{KELVIN SIGN}&lt;/code&gt; ), specify the &quot;a&quot; twice, for example &lt;code&gt;/aai&lt;/code&gt; or &lt;code&gt;/aia&lt;/code&gt; . (The first occurrence of &quot;a&quot; restricts the &lt;code&gt;\d&lt;/code&gt; , etc., and the second occurrence adds the &lt;code&gt;/i&lt;/code&gt; restrictions.) But, note that code points outside the ASCII range will use Unicode rules for &lt;code&gt;/i&lt;/code&gt; matching, so the modifier doesn't really restrict things to just ASCII; it just forbids the intermixing of ASCII and non-ASCII.</source>
          <target state="translated">ASCII / 비 ASCII 일치 ( &lt;code&gt;\N{KELVIN SIGN}&lt;/code&gt; &quot;k&quot;)를 금지하려면 &quot;a&quot;를 두 번 지정하십시오 (예 : &lt;code&gt;/aai&lt;/code&gt; 또는 &lt;code&gt;/aia&lt;/code&gt; ) . ( &quot;a&quot;의 첫 번째 발생은 &lt;code&gt;\d&lt;/code&gt; 등을 제한하고 두 번째 발생은 &lt;code&gt;/i&lt;/code&gt; 제한을 추가합니다 .) 그러나 ASCII 범위 밖의 코드 포인트는 &lt;code&gt;/i&lt;/code&gt; 일치에 유니 코드 규칙을 사용 하므로 수정자는 실제로 사물을 ASCII로 제한하지는 않습니다. ASCII와 비 ASCII의 혼합을 금지합니다.</target>
        </trans-unit>
        <trans-unit id="bc2a4c58af25cd402ee36a19ab3abed7cc44071e" translate="yes" xml:space="preserve">
          <source>To force interpretation as a subroutine call, either put an ampersand before the subroutine name, or qualify the name with its package. Alternatively, you can import the subroutine (or pretend that it's imported with the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; pragma).</source>
          <target state="translated">서브 루틴 호출로 해석하려면 서브 루틴 이름 앞에 앰퍼샌드를 넣거나 패키지로 이름을 한정하십시오. 또는 서브 루틴을 가져 오거나 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; pragma를 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하여 가져온 것처럼 가장 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="457433c503b0c64ab575af65985486ef91bd670a" translate="yes" xml:space="preserve">
          <source>To force multiple data values into an SV, you must do two things: use the &lt;code&gt;sv_set*v&lt;/code&gt; routines to add the additional scalar type, then set a flag so that Perl will believe it contains more than one type of data. The four macros to set the flags are:</source>
          <target state="translated">SV에 여러 데이터 값을 강제로 적용하려면 두 가지 작업을 수행해야합니다. &lt;code&gt;sv_set*v&lt;/code&gt; 루틴을 사용하여 추가 스칼라 유형을 추가 한 다음 Perl이 둘 이상의 데이터 유형을 포함하도록 믿도록 플래그를 설정하십시오. 플래그를 설정하는 네 가지 매크로는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e794c449edc7f65a40ec8153981b15f3f2a9b550" translate="yes" xml:space="preserve">
          <source>To free an SV that you've created, call &lt;code&gt;SvREFCNT_dec(SV*)&lt;/code&gt; . Normally this call is not necessary (see &lt;a href=&quot;#Reference-Counts-and-Mortality&quot;&gt;Reference Counts and Mortality&lt;/a&gt;).</source>
          <target state="translated">생성 한 SV를 해제하려면 &lt;code&gt;SvREFCNT_dec(SV*)&lt;/code&gt; 호출 하십시오 . 일반적으로이 호출은 필요하지 않습니다 ( &lt;a href=&quot;#Reference-Counts-and-Mortality&quot;&gt;참조 횟수 및 사망률 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2d1737256e6e8a51ce74a94d85a078c8dd0ab640" translate="yes" xml:space="preserve">
          <source>To gain access to symbols that are exported from another module. See &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo;.</source>
          <target state="translated">다른 모듈에서 내 보낸 심볼에 액세스합니다. Camel 27 장 &quot;기능&quot;에서 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dcb6076af26c9d87b4c92a15d546b5cbbac01e84" translate="yes" xml:space="preserve">
          <source>To generate just the stubs:</source>
          <target state="translated">스텁 만 생성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="535754fb5bff8ed1b444cf7b15654e6f3c7d7a5c" translate="yes" xml:space="preserve">
          <source>To get a Math::BigFloat you either need to call the operation manually, make sure the operands are already of the proper type or casted to that type via Math::BigFloat-&amp;gt;new():</source>
          <target state="translated">Math :: BigFloat를 얻으려면 오퍼레이션을 수동으로 호출하거나 피연산자가 이미 올바른 유형이거나 Math :: BigFloat-&amp;gt; new ()를 통해 해당 유형으로 캐스트되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="482a14b92894717900240dda3533f7f04de8b428" translate="yes" xml:space="preserve">
          <source>To get a binary stream an alternate method is to use:</source>
          <target state="translated">이진 스트림을 얻으려면 다른 방법을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="342926328b3f4e6b863f62ddbfc63ea7184c5807" translate="yes" xml:space="preserve">
          <source>To get a full list of the available sync points:</source>
          <target state="translated">사용 가능한 동기화 지점의 전체 목록을 얻으려면</target>
        </trans-unit>
        <trans-unit id="4a7e3e5cefb00444495078948120515244d3f977" translate="yes" xml:space="preserve">
          <source>To get a random number between two values, you can use the &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; built-in to get a random number between 0 and 1. From there, you shift that into the range that you want.</source>
          <target state="translated">두 값 사이의 난수를 얻으려면 &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; 내장을 사용하여 0과 1 사이의 난수를 얻을 수 있습니다. 거기에서 원하는 범위로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="503a91db6b0ee3a6aaf3799cd04cbf8c2160ee5a" translate="yes" xml:space="preserve">
          <source>To get a real at or caret into the field, do this:</source>
          <target state="translated">현장에서 실제 또는 캐럿을 얻으려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="6546b16387b88ec0ca99336cb1d0e013e452d98c" translate="yes" xml:space="preserve">
          <source>To get all the output from your error log, and not miss any messages via helpful operating system buffering, insert a line like this, at the start of your script:</source>
          <target state="translated">오류 로그에서 모든 출력을 얻고 유용한 운영 체제 버퍼링을 통해 메시지를 놓치지 않으려면 스크립트 시작시 다음과 같은 행을 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="2baf587b399a3c62f41dfcb4f6a76fcf67a09c4b" translate="yes" xml:space="preserve">
          <source>To get an &lt;code&gt;HMQ&lt;/code&gt; , the extension should call &lt;code&gt;hmq = perl_hmq_GET(serve)&lt;/code&gt; in C. After this call is performed, &lt;code&gt;hmq&lt;/code&gt; may be accessed as &lt;code&gt;Perl_hmq&lt;/code&gt; .</source>
          <target state="translated">얻을 &lt;code&gt;HMQ&lt;/code&gt; 를 상기 확장 불러야 &lt;code&gt;hmq = perl_hmq_GET(serve)&lt;/code&gt; 이 호출이 수행 된 후, C.에서 &lt;code&gt;hmq&lt;/code&gt; 은 으로 액세스 될 수있다 &lt;code&gt;Perl_hmq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4fbf979e25bdf63e3a72510bfcc0bebacbf8c90" translate="yes" xml:space="preserve">
          <source>To get an unbuffered stream specify an unbuffered layer (e.g. &lt;code&gt;:unix&lt;/code&gt; ) in the open call:</source>
          <target state="translated">버퍼링되지 않은 스트림을 얻으 려면 공개 호출에서 버퍼되지 않은 레이어 (예 &lt;code&gt;:unix&lt;/code&gt; )를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="4f25553ad923c6b2f304e605c8fcb2af6b398a17" translate="yes" xml:space="preserve">
          <source>To get around the error, place the word &lt;code&gt;DB_File&lt;/code&gt; in either single or double quotes, like this:</source>
          <target state="translated">오류를 해결하려면 다음과 같이 &lt;code&gt;DB_File&lt;/code&gt; 이라는 단어를 작은 따옴표 나 큰 따옴표로 묶으십시오.</target>
        </trans-unit>
        <trans-unit id="e7cc39162825d124202c37827aea79596926f995" translate="yes" xml:space="preserve">
          <source>To get around the security problem, I could also pull the values from a hash instead of evaluating variable names. Using a single &lt;code&gt;/e&lt;/code&gt;, I can check the hash to ensure the value exists, and if it doesn't, I can replace the missing value with a marker, in this case &lt;code&gt;???&lt;/code&gt; to signal that I missed something:</source>
          <target state="translated">보안 문제를 해결하기 위해 변수 이름을 평가하는 대신 해시에서 값을 가져올 수도 있습니다. 단일 &lt;code&gt;/e&lt;/code&gt; 사용 하면 해시를 검사하여 값이 존재하는지 확인할 수 있으며, 존재하지 않으면 누락 된 값을 마커로 바꿀 수 있습니다.이 경우 &lt;code&gt;???&lt;/code&gt; 내가 뭔가를 놓쳤다는 것을 알리기 위해 :</target>
        </trans-unit>
        <trans-unit id="7daccee0149b6b5c023c3105df2756ca16d7041c" translate="yes" xml:space="preserve">
          <source>To get around these problems it is necessary to take a full copy of the SV. The code below shows &lt;code&gt;SaveSub2&lt;/code&gt; modified to do that.</source>
          <target state="translated">이러한 문제를 해결하려면 SV의 전체 사본을 가져와야합니다. 아래 코드는 &lt;code&gt;SaveSub2&lt;/code&gt; 가 수정 되었음을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="e5e782973aff491dec9c851f1733c85508f6c14a" translate="yes" xml:space="preserve">
          <source>To get around this, either upgrade to Perl v5.6.0 or later, do the glob yourself with readdir() and patterns, or use a module like &lt;a href=&quot;file/glob&quot;&gt;File::Glob&lt;/a&gt;, one that doesn't use the shell to do globbing.</source>
          <target state="translated">이 문제를 해결하려면 Perl v5.6.0 이상으로 업그레이드하거나 readdir () 및 패턴을 사용하여 &lt;a href=&quot;file/glob&quot;&gt;글로브&lt;/a&gt; 를 수행하거나, 쉘을 사용하여 글 로빙을 수행하지 않는 File :: Glob 과 같은 모듈을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f6d7c7ba0c3680f1bdd16d6aa20e16ef63f21df2" translate="yes" xml:space="preserve">
          <source>To get around this, you have to unbuffer the output filehandle, in this case, &lt;code&gt;STDOUT&lt;/code&gt; . You can set the special variable &lt;code&gt;$|&lt;/code&gt; to a true value (mnemonic: making your filehandles &quot;piping hot&quot;):</source>
          <target state="translated">이 문제를 해결하려면 출력 파일 핸들 (이 경우 &lt;code&gt;STDOUT&lt;/code&gt; ) 을 버퍼링 해제해야합니다 . 특수 변수 &lt;code&gt;$|&lt;/code&gt; 설정할 수 있습니다 진정한 가치 (니모닉 : 파일 핸들을 &quot;파이핑 핫&quot;으로 만들기) :</target>
        </trans-unit>
        <trans-unit id="a6f34a68c60751e410691b9ae6ddd9f980469ba3" translate="yes" xml:space="preserve">
          <source>To get at hash elements:</source>
          <target state="translated">해시 요소를 얻으려면 :</target>
        </trans-unit>
        <trans-unit id="7f878bb059ecb8cc0e6a947e6d0564b810589ae6" translate="yes" xml:space="preserve">
          <source>To get even more recent perl depots for the whole range of HP-UX, visit H.Merijn Brand's site at &lt;a href=&quot;http://mirrors.develooper.com/hpux/#Perl&quot;&gt;http://mirrors.develooper.com/hpux/#Perl&lt;/a&gt;. Carefully read the notes to see if the available versions suit your needs.</source>
          <target state="translated">HP-UX 전체의 최신 펄 저장소를 얻으려면 H.Merijn 브랜드 사이트 ( &lt;a href=&quot;http://mirrors.develooper.com/hpux/#Perl&quot;&gt;http://mirrors.develooper.com/hpux/#Perl)를&lt;/a&gt; 방문 하십시오 . 사용 가능한 버전이 귀하의 요구에 맞는지 확인하기 위해 참고 사항을주의 깊게 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="76a1d18d8c0d8e0ec36c61f2ab6bce082fca6308" translate="yes" xml:space="preserve">
          <source>To get finer test reports, call</source>
          <target state="translated">더 나은 테스트 보고서를 얻으려면 전화</target>
        </trans-unit>
        <trans-unit id="93d274f25d53139f7087deba04a14a18e5484351" translate="yes" xml:space="preserve">
          <source>To get index entries on &lt;code&gt;STDERR&lt;/code&gt; , turn on the F register, as in:</source>
          <target state="translated">&lt;code&gt;STDERR&lt;/code&gt; 에서 색인 항목을 얻으려면 다음과 같이 F 레지스터를 켜십시오.</target>
        </trans-unit>
        <trans-unit id="8b6b89efcdec932089c6c9c0f91cf90b0d1e52b9" translate="yes" xml:space="preserve">
          <source>To get multiple values from an array:</source>
          <target state="translated">배열에서 여러 값을 가져 오려면</target>
        </trans-unit>
        <trans-unit id="c67d46d6312179612215d6ef23eb3f6db1321700" translate="yes" xml:space="preserve">
          <source>To get platform independent controls, you can use &lt;code&gt;\N{...}&lt;/code&gt; .</source>
          <target state="translated">플랫폼 독립적 인 제어를 얻으려면 &lt;code&gt;\N{...}&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a965832b8b2f81c82888b8327d5081a21e8081aa" translate="yes" xml:space="preserve">
          <source>To get some interesting statistics, it is recommended that &lt;code&gt;randomize_urllist&lt;/code&gt; be set; this introduces some amount of randomness into the URL selection.</source>
          <target state="translated">흥미로운 통계를 얻으려면 &lt;code&gt;randomize_urllist&lt;/code&gt; 를 설정 하는 것이 좋습니다 . 이것은 URL 선택에 어느 정도의 무작위성을 도입합니다.</target>
        </trans-unit>
        <trans-unit id="42f32ff5f8a54ed95afefa260a5241934e3c3cb8" translate="yes" xml:space="preserve">
          <source>To get somewhat similar but locale-dependent date strings, set up your locale environment variables appropriately (please see &lt;a href=&quot;../perllocale&quot;&gt;perllocale&lt;/a&gt;) and try for example:</source>
          <target state="translated">다소 비슷하지만 로케일에 따른 날짜 문자열을 얻으려면 로케일 환경 변수를 적절하게 설정하고 ( &lt;a href=&quot;../perllocale&quot;&gt;perllocale&lt;/a&gt; 참조 ) 다음과 같이 시도 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ab2c259ec21b8fdc7591d4aa060782af6913d852" translate="yes" xml:space="preserve">
          <source>To get somewhat similar but locale-dependent date strings, set up your locale environment variables appropriately (please see &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;) and try for example:</source>
          <target state="translated">다소 비슷하지만 로케일에 따른 날짜 문자열을 얻으려면 로케일 환경 변수를 적절하게 설정하고 ( &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; 참조 ) 다음과 같이 시도 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c33d002d66788db30ed6cc7efa61fd7b3021f5f2" translate="yes" xml:space="preserve">
          <source>To get the 25 traditional lowercase Greek letters, including both sigmas, you could use this instead:</source>
          <target state="translated">두 시그마를 포함하여 25 개의 전통적인 소문자 그리스 문자를 얻으려면 대신 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e85259394ca22644c2c269f73c9d0468d9813a0" translate="yes" xml:space="preserve">
          <source>To get the HAB, the extension should call &lt;code&gt;hab = perl_hab_GET()&lt;/code&gt; in C. After this call is performed, &lt;code&gt;hab&lt;/code&gt; may be accessed as &lt;code&gt;Perl_hab&lt;/code&gt; . There is no need to release the HAB after it is used.</source>
          <target state="translated">HAB를 얻으려면 확장은 C에서 &lt;code&gt;hab = perl_hab_GET()&lt;/code&gt; 을 호출해야합니다 .이 호출이 수행 된 후 &lt;code&gt;hab&lt;/code&gt; 는 &lt;code&gt;Perl_hab&lt;/code&gt; 로 액세스 될 수 있습니다 . HAB를 사용한 후에는 해제 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="35604b07a393cc3fdbf315f40abc25e64114d031" translate="yes" xml:space="preserve">
          <source>To get the IP address, you can use the &lt;code&gt;&lt;a href=&quot;functions/gethostbyname&quot;&gt;gethostbyname&lt;/a&gt;&lt;/code&gt; built-in function to turn the name into a number. To turn that number into the dotted octet form (a.b.c.d) that most people expect, use the &lt;code&gt;inet_ntoa&lt;/code&gt; function from the &lt;a href=&quot;socket&quot;&gt;Socket&lt;/a&gt; module, which also comes with perl.</source>
          <target state="translated">IP 주소를 얻기 위해 &lt;code&gt;&lt;a href=&quot;functions/gethostbyname&quot;&gt;gethostbyname&lt;/a&gt;&lt;/code&gt; 내장 기능을 사용하여 이름을 숫자로 바꿀 수 있습니다. 이 숫자를 대부분의 사람들이 기대하는 점으로 구분 된 8 진수 형식 (abcd)으로 바꾸려면 &lt;a href=&quot;socket&quot;&gt;소켓&lt;/a&gt; 모듈 의 &lt;code&gt;inet_ntoa&lt;/code&gt; 함수를 사용하십시오 ( perl과 함께 제공됨).</target>
        </trans-unit>
        <trans-unit id="aa0526e650783189d8454499d3396cf899e8f521" translate="yes" xml:space="preserve">
          <source>To get the day of year for any date, use &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;'s &lt;code&gt;mktime&lt;/code&gt; to get a time in epoch seconds for the argument to &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">날짜에 상관없이 날짜 를 얻으려면 &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; 의 &lt;code&gt;mktime&lt;/code&gt; 을 사용 하여 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 인수에 대한 시간을 초 단위로 가져 오십시오 .</target>
        </trans-unit>
        <trans-unit id="ffadb121be361a5885303dda8c46c6cf80b68bb1" translate="yes" xml:space="preserve">
          <source>To get the last two digits of the year (e.g., &quot;01&quot; in 2001) do:</source>
          <target state="translated">연도의 마지막 두 자리 (예 : 2001 년 &quot;01&quot;)를 얻으려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="22228c8d3b8e275582e9f34035469fcccc1c47a6" translate="yes" xml:space="preserve">
          <source>To get the script to work properly and silence the warning make sure there are no valid references to the tied object</source>
          <target state="translated">스크립트가 제대로 작동하고 경고를 끄려면 연결된 개체에 대한 유효한 참조가 없는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="3d2c84cce621656fbbd6db23ecc45f9cb65b75f8" translate="yes" xml:space="preserve">
          <source>To get the stash pointer for a particular package, use the function:</source>
          <target state="translated">특정 패키지에 대한 숨김 포인터를 얻으려면 다음 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1496f65198c7ac994d7422ae9ced83ce54781e58" translate="yes" xml:space="preserve">
          <source>To get things going, note that GBARR/Scalar-List-Utils-1.18.tar.gz is compatible with ancient perls and that File::Temp is listed as a prerequisite but CPAN has reasonable workarounds if it is missing.</source>
          <target state="translated">GBARR / Scalar-List-Utils-1.18.tar.gz는 고대 perls와 호환되며 File :: Temp는 전제 조건으로 나열되어 있지만 CPAN이없는 경우 합리적인 해결 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0258f9df35378eac84877d3f62eff75269ae164c" translate="yes" xml:space="preserve">
          <source>To get valgrind and for more information see</source>
          <target state="translated">valgrind를 구하고 자세한 내용은</target>
        </trans-unit>
        <trans-unit id="969efaa9efa953c87797414000140cc60d6a47f5" translate="yes" xml:space="preserve">
          <source>To go through all of the keys, use the &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; function. This extracts all of the keys of the hash and gives them back to you as a list. You can then get the value through the particular key you're processing:</source>
          <target state="translated">모든 키를 살펴 보려면 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 기능을 사용하십시오 . 그러면 해시의 모든 키가 추출되어 목록으로 다시 나타납니다. 그런 다음 처리중인 특정 키를 통해 값을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da7117148549139674b757cf18ceb49ea4e3b714" translate="yes" xml:space="preserve">
          <source>To hack on the Perl guts, you'll need to read the following things:</source>
          <target state="translated">Perl 내장을 해킹하려면 다음 사항을 읽어야합니다.</target>
        </trans-unit>
        <trans-unit id="adcd3970934fc11a2c18b9c7c3e26524958accfd" translate="yes" xml:space="preserve">
          <source>To handle this situation, the PPCODE directive is used and the stack is extended using the macro:</source>
          <target state="translated">이 상황을 처리하기 위해 PPCODE 지시문이 사용되며 매크로를 사용하여 스택이 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="f2c53c3c3d7de6d2315fba06d0366c539cf64b63" translate="yes" xml:space="preserve">
          <source>To have everything installed in your home directory, do the following.</source>
          <target state="translated">모든 것을 홈 디렉토리에 설치하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="ebc28ed79805f971814bf2f23886e1860e904a26" translate="yes" xml:space="preserve">
          <source>To help explain what &lt;code&gt;File::GlobMapper&lt;/code&gt; does, consider what code you would write if you wanted to rename all files in the current directory that ended in &lt;code&gt;.tar.gz&lt;/code&gt; to &lt;code&gt;.tgz&lt;/code&gt;. So say these files are in the current directory</source>
          <target state="translated">&lt;code&gt;File::GlobMapper&lt;/code&gt; 가 수행 하는 작업을 설명하기 위해 현재 디렉토리에서 &lt;code&gt;.tar.gz&lt;/code&gt; 로 끝나는 모든 파일의 이름 을 &lt;code&gt;.tgz&lt;/code&gt; 로 바꾸려면 어떤 코드를 작성해야하는지 고려하십시오 . 이 파일이 현재 디렉토리에 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="2009b3db85976237ffec01f5a479f250593bd279" translate="yes" xml:space="preserve">
          <source>To help understand how to write a Perl source filter we need an example to study. Here is a complete source filter that performs rot13 decoding. (Rot13 is a very simple encryption scheme used in Usenet postings to hide the contents of offensive posts. It moves every letter forward thirteen places, so that A becomes N, B becomes O, and Z becomes M.)</source>
          <target state="translated">Perl 소스 필터를 작성하는 방법을 이해하려면 연구 할 예제가 필요합니다. 다음은 rot13 디코딩을 수행하는 완전한 소스 필터입니다. (Rot13은 유즈넷 게시물에서 불쾌한 게시물의 내용을 숨기기 위해 사용되는 매우 간단한 암호화 체계입니다. 모든 문자를 13 자리 앞으로 이동하여 A가 N, B가 O, Z가 M이되도록합니다.)</target>
        </trans-unit>
        <trans-unit id="b67c3276fc328ee702718e80d3624e6e736f9072" translate="yes" xml:space="preserve">
          <source>To help understand why this can be a real problem first consider how a callback is set up in an all C environment. Typically a C API will provide a function to register a callback. This will expect a pointer to a function as one of its parameters. Below is a call to a hypothetical function &lt;code&gt;register_fatal&lt;/code&gt; which registers the C function to get called when a fatal error occurs.</source>
          <target state="translated">이것이 왜 실제 문제가 될 수 있는지 이해하려면 먼저 모든 C 환경에서 콜백을 설정하는 방법을 고려하십시오. 일반적으로 C API는 콜백을 등록하는 기능을 제공합니다. 이것은 매개 변수 중 하나로 함수에 대한 포인터를 기대합니다. 다음은 치명적 오류가 발생할 때 호출되도록 C 함수를 등록 하는 가상 함수 &lt;code&gt;register_fatal&lt;/code&gt; 에 대한 호출입니다.</target>
        </trans-unit>
        <trans-unit id="6caa11e5f28551bc8c9f71be4abd8c87215d7f26" translate="yes" xml:space="preserve">
          <source>To help you convert legacy programs to more modern Perl, the &lt;a href=&quot;pl2pm&quot;&gt;pl2pm&lt;/a&gt; utility will help you convert old-style Perl 4 libraries to new-style Perl5 modules.</source>
          <target state="translated">레거시 프로그램을보다 현대적인 Perl 로 변환 할 수 있도록 &lt;a href=&quot;pl2pm&quot;&gt;pl2pm&lt;/a&gt; 유틸리티를 사용하면 구식 Perl 4 라이브러리를 새로운 스타일의 Perl5 모듈로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c501d022d8a0fffa65c230084aad7354f866cab9" translate="yes" xml:space="preserve">
          <source>To help you figure out what was undefined, perl will try to tell you the name of the variable (if any) that was undefined. In some cases it cannot do this, so it also tells you what operation you used the undefined value in. Note, however, that perl optimizes your program and the operation displayed in the warning may not necessarily appear literally in your program. For example, &lt;code&gt;&quot;that $foo&quot;&lt;/code&gt; is usually optimized into &lt;code&gt;&quot;that &quot; . $foo&lt;/code&gt; , and the warning will refer to the &lt;code&gt;concatenation (.)&lt;/code&gt; operator, even though there is no &lt;code&gt;.&lt;/code&gt; in your program.</source>
          <target state="translated">정의되지 않은 것을 파악할 수 있도록 perl은 정의되지 않은 변수의 이름 (있는 경우)을 알려줍니다. 어떤 경우에는이를 수행 할 수 없으므로 정의되지 않은 값을 사용한 조작도 알려줍니다. 그러나 perl이 프로그램을 최적화하고 경고에 표시된 조작이 문자 그대로 프로그램에 표시되지 않을 수도 있습니다. 예를 들어, &lt;code&gt;&quot;that $foo&quot;&lt;/code&gt; 는 일반적으로 &lt;code&gt;&quot;that &quot; . $foo&lt;/code&gt; 으로 최적화됩니다 . $ foo 이며 경고 가없는 경우에도 &lt;code&gt;concatenation (.)&lt;/code&gt; 연산자를 나타 &lt;code&gt;.&lt;/code&gt; 당신의 프로그램에서.</target>
        </trans-unit>
        <trans-unit id="77d1efff4e4ad59e580cc05099536ea5f027ae77" translate="yes" xml:space="preserve">
          <source>To hide the rough edges under the hood, provide a tie()d interface to the package &lt;code&gt;symbolic&lt;/code&gt; . Add methods</source>
          <target state="translated">후드 아래의 거친 가장자리를 숨기려면 &lt;code&gt;symbolic&lt;/code&gt; 패키지에 tie () d 인터페이스를 제공하십시오 . 메소드 추가</target>
        </trans-unit>
        <trans-unit id="bb09986ebdb919a3ce53d54257037e7652baac8f" translate="yes" xml:space="preserve">
          <source>To illustrate the differences between these variables, consider the following Perl expression, which uses a single-quoted string. After execution of this statement, perl may have set all four special error variables:</source>
          <target state="translated">이러한 변수의 차이점을 설명하려면 작은 따옴표로 묶인 문자열을 사용하는 다음 Perl 표현식을 고려하십시오. 이 명령문을 실행 한 후 perl은 네 가지 특수 오류 변수를 모두 설정했을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0157186b912ecd3453913b9ba18ef7c370be226" translate="yes" xml:space="preserve">
          <source>To illustrate this feature, we'll design a pattern that matches if a string contains a palindrome. (This is a word or a sentence that, while ignoring spaces, interpunctuation and case, reads the same backwards as forwards. We begin by observing that the empty string or a string containing just one word character is a palindrome. Otherwise it must have a word character up front and the same at its end, with another palindrome in between.</source>
          <target state="translated">이 기능을 설명하기 위해 문자열에 회문이 포함 된 경우 일치하는 패턴을 디자인합니다. (이것은 공백, 문장 부호 및 대소 문자를 무시하면서 앞뒤로 같은 단어를 읽는 단어 또는 문장입니다. 우리는 빈 문자열이나 단어 문자가 하나만 포함 된 문자열이 회문임을 관찰하여 시작합니다. 그렇지 않으면 단어 문자는 앞면과 끝에서 동일하며 다른 회문은 그 사이에 있습니다.</target>
        </trans-unit>
        <trans-unit id="983dc7293d2e1cce05648cd63638e4f7e22fc331" translate="yes" xml:space="preserve">
          <source>To illustrate unpacking for bit strings, we'll decompose a simple status register (a &quot;-&quot; stands for a &quot;reserved&quot; bit):</source>
          <target state="translated">비트 문자열의 압축 풀기를 설명하기 위해 간단한 상태 레지스터를 분해합니다 ( &quot;-&quot;는 &quot;예약 된&quot;비트를 나타냄).</target>
        </trans-unit>
        <trans-unit id="0eeac6bf1837c3892fad2067238a40143aea5c3f" translate="yes" xml:space="preserve">
          <source>To illustrate,</source>
          <target state="translated">설명하기 위해</target>
        </trans-unit>
        <trans-unit id="3f180de5f2359e1c5045cf60151ad16271ecfbd0" translate="yes" xml:space="preserve">
          <source>To implement a copy constructor, add &lt;code&gt;'=' =&amp;gt; \&amp;amp;cpy&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; line, and code (this code assumes that mutators change things one level deep only, so recursive copying is not needed):</source>
          <target state="translated">복사 생성자를 구현하려면 &lt;code&gt;'=' =&amp;gt; \&amp;amp;cpy&lt;/code&gt; 를 추가 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; 라인과 코드를 사용하십시오 (이 코드는 뮤 테이터가 한 단계 깊게 만 변경하므로 재귀 복사는 필요하지 않음).</target>
        </trans-unit>
        <trans-unit id="8240260917b1a03cdad7c5747565fe071f2719a2" translate="yes" xml:space="preserve">
          <source>To implement most arithmetic operations is easy; one should just use the tables of operations, and change the code which fills %subr to</source>
          <target state="translated">대부분의 산술 연산을 구현하는 것은 쉽습니다. 작업 테이블을 사용하고 % subr을 채우는 코드를</target>
        </trans-unit>
        <trans-unit id="81c4d513cec75ad639c29820e8f6fc040826df1f" translate="yes" xml:space="preserve">
          <source>To import subroutines:</source>
          <target state="translated">서브 루틴을 가져 오려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="97177a061d7ff62a243885c9bd4e1efe9ede32f2" translate="yes" xml:space="preserve">
          <source>To increase the value of something by 1 (or by some other number, if so specified).</source>
          <target state="translated">무언가의 가치를 1 씩 증가 시키거나 (지정된 경우 다른 숫자로)</target>
        </trans-unit>
        <trans-unit id="72b80e806b1c83aea2a8c7cd737f1e4bbb0943c8" translate="yes" xml:space="preserve">
          <source>To indicate to rather use commandline tools than modules</source>
          <target state="translated">모듈보다는 명령 줄 도구를 사용함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="75120c587d6fba4a38cc9dc45cf5606751546e6f" translate="yes" xml:space="preserve">
          <source>To insert a line after one already in the file, use the &lt;code&gt;-n&lt;/code&gt; switch. It's just like &lt;code&gt;-p&lt;/code&gt; except that it doesn't print &lt;code&gt;$_&lt;/code&gt; at the end of the loop, so you have to do that yourself. In this case, print &lt;code&gt;$_&lt;/code&gt; first, then print the line that you want to add.</source>
          <target state="translated">파일에 이미 한 줄을 추가하려면 &lt;code&gt;-n&lt;/code&gt; 스위치를 사용하십시오 . 루프가 끝날 때 &lt;code&gt;$_&lt;/code&gt; 를 인쇄하지 않는다는 점을 제외하고는 &lt;code&gt;-p&lt;/code&gt; 와 같습니다 . 따라서 직접해야합니다. 이 경우 &lt;code&gt;$_&lt;/code&gt; 먼저 인쇄 한 다음 추가 할 줄을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="574f86f03c88819ff70bca34830f6be35a8bf5f1" translate="yes" xml:space="preserve">
          <source>To install NetWare Perl onto a NetWare server, first map the Sys volume of a NetWare server to</source>
          <target state="translated">NetWare Perl을 NetWare 서버에 설치하려면 먼저 NetWare 서버의 Sys 볼륨을</target>
        </trans-unit>
        <trans-unit id="a7a520bfb7587900e1cbb96bf573db69af079c5b" translate="yes" xml:space="preserve">
          <source>To iterate over the indices of an array, use &lt;code&gt;&lt;a href=&quot;functions/foreach&quot;&gt;foreach&lt;/a&gt; &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $i (0 .. $#array)
{}&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/foreach&quot;&gt;foreach&lt;/a&gt; &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $v (@array) {}&lt;/code&gt; iterates over the values.</source>
          <target state="translated">배열의 인덱스를 반복하려면 &lt;code&gt;&lt;a href=&quot;functions/foreach&quot;&gt;foreach&lt;/a&gt; &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $i (0 .. $#array) {}&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/foreach&quot;&gt;foreach&lt;/a&gt; &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $v (@array) {}&lt;/code&gt; 값을 반복 할 때입니다.</target>
        </trans-unit>
        <trans-unit id="8f0a51f73b6311fa2b970169a1f0134f7c61aef8" translate="yes" xml:space="preserve">
          <source>To join a mailing list for announcements about &lt;code&gt;Memoize&lt;/code&gt; , send an empty message to &lt;code&gt;mjd-perl-memoize-request@plover.com&lt;/code&gt; . This mailing list is for announcements only and has extremely low traffic---fewer than two messages per year.</source>
          <target state="translated">&lt;code&gt;Memoize&lt;/code&gt; 관련 공지 사항에 대한 메일 링리스트에 참여하려면 &lt;code&gt;mjd-perl-memoize-request@plover.com&lt;/code&gt; 으로 빈 메시지를 보내 십시오 . 이 메일 링리스트는 공지 사항에만 해당되며 트래픽이 매우 적습니다 (연간 두 메시지 미만).</target>
        </trans-unit>
        <trans-unit id="9c7770af2e023d19bb1b24c66498040c02b4d820" translate="yes" xml:space="preserve">
          <source>To join a very low-traffic mailing list for announcements about &lt;code&gt;Memoize&lt;/code&gt; , send an empty note to &lt;code&gt;mjd-perl-memoize-request@plover.com&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;Memoize&lt;/code&gt; 에 대한 공지를 위해 트래픽이 매우 적은 메일 링리스트에 참여하려면 &lt;code&gt;mjd-perl-memoize-request@plover.com&lt;/code&gt; 으로 빈 메모를 보내 십시오 .</target>
        </trans-unit>
        <trans-unit id="30da17ba518ee8896f295021c334b446312ba2d0" translate="yes" xml:space="preserve">
          <source>To just compare two strings for equality/non-equality, you can just use &lt;a href=&quot;perlapi#memEQ&quot;&gt;memEQ() &lt;/a&gt; and &lt;a href=&quot;perlapi#memEQ&quot;&gt;memNE() &lt;/a&gt; as usual, except the strings must be both UTF-8 or not UTF-8 encoded.</source>
          <target state="translated">동일성 / 비 균등성을 위해 두 문자열을 비교하려면 문자열이 UTF-8이거나 UTF-8로 인코딩되지 않아야한다는 점을 제외하고 평소 와 &lt;a href=&quot;perlapi#memEQ&quot;&gt;같이 &lt;/a&gt;&lt;a href=&quot;perlapi#memEQ&quot;&gt;memEQ ()&lt;/a&gt; 및 memNE () 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bfd1d911fc5d8c1a13ece46d4a41278866b326f9" translate="yes" xml:space="preserve">
          <source>To keep our namespace nice and unpolluted, edit the .pm file and change the variable &lt;code&gt;@EXPORT&lt;/code&gt; to &lt;code&gt;@EXPORT_OK&lt;/code&gt; . Finally, in the .xs file, edit the #include line to read:</source>
          <target state="translated">네임 스페이스 를 &lt;code&gt;@EXPORT_OK&lt;/code&gt; 하고 오염되지 않도록하려면 .pm 파일을 편집하고 변수 &lt;code&gt;@EXPORT&lt;/code&gt; 를 @EXPORT_OK 로 변경하십시오 . 마지막으로 .xs 파일에서 #include 행을 편집하여 다음을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="03272788bb4c31073d76ce4d5e5b7d43fa610bff" translate="yes" xml:space="preserve">
          <source>To learn how to install modules you download from CPAN, read &lt;a href=&quot;perlmodinstall&quot;&gt;perlmodinstall&lt;/a&gt;.</source>
          <target state="translated">CPAN에서 다운로드 한 모듈을 설치하는 방법을 배우려면 &lt;a href=&quot;perlmodinstall&quot;&gt;perlmodinstall을&lt;/a&gt; 읽으 십시오 .</target>
        </trans-unit>
        <trans-unit id="6a06d2306514b40b8ba1c92a7641c86fc2fa15b9" translate="yes" xml:space="preserve">
          <source>To learn how to use a particular module, use &lt;code&gt;perldoc &lt;i&gt;Module::Name&lt;/i&gt;&lt;/code&gt;. Typically you will want to &lt;code&gt;use &lt;i&gt;Module::Name&lt;/i&gt;&lt;/code&gt;, which will then give you access to exported functions or an OO interface to the module.</source>
          <target state="translated">특정 모듈을 사용하는 방법을 배우려면 &lt;code&gt;perldoc &lt;i&gt;Module::Name&lt;/i&gt;&lt;/code&gt; 사용 &lt;i&gt;하십시오&lt;/i&gt; . 일반적으로 &lt;code&gt;use &lt;i&gt;Module::Name&lt;/i&gt;&lt;/code&gt; 을 사용&lt;i&gt;&lt;/i&gt; 하면 내 보낸 함수 또는 모듈에 대한 OO 인터페이스에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="085a503b5041562d55123a7fc6e92076974024bc" translate="yes" xml:space="preserve">
          <source>To learn more, just type a bogus option, like &lt;b&gt;-\?&lt;/b&gt;, and a long usage message will be provided. There are a fair number of possibilities.</source>
          <target state="translated">자세히 알아 보려면 &lt;b&gt;-\&lt;/b&gt; 와 같은 가짜 옵션을 입력하십시오 &lt;b&gt;. &lt;/b&gt;긴 사용 메시지가 제공됩니다. 많은 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b660f64338ea03a5a1e256309c3e2566abdfdf76" translate="yes" xml:space="preserve">
          <source>To limit the number of decimal places in your numbers, you can use the &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; function. See &lt;a href=&quot;perlop#Floating-point-Arithmetic&quot;&gt;Floating-point Arithmetic in perlop&lt;/a&gt; for more details.</source>
          <target state="translated">숫자의 소수점 이하 자릿수를 제한하기 위해 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 함수를 사용할 수 있습니다 . 자세한 내용 &lt;a href=&quot;perlop#Floating-point-Arithmetic&quot;&gt;은 perlop의 부동 소수점 산술&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a08be93803c5f2a1dab3670911ed75d37f74ad6a" translate="yes" xml:space="preserve">
          <source>To load &lt;code&gt;TAP::Harness&lt;/code&gt; plugins, you'll need to use the &lt;code&gt;tap_harness_args&lt;/code&gt; parameter to &lt;code&gt;new&lt;/code&gt; , typically from your &lt;code&gt;Build.PL&lt;/code&gt; . For example:</source>
          <target state="translated">&lt;code&gt;TAP::Harness&lt;/code&gt; 플러그인 을로드하려면 일반적으로 &lt;code&gt;Build.PL&lt;/code&gt; 에서 &lt;code&gt;tap_harness_args&lt;/code&gt; 매개 변수를 &lt;code&gt;new&lt;/code&gt; 로 사용해야합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1281377e392724ce754ea5fba63ddbdb0e3e3b86" translate="yes" xml:space="preserve">
          <source>To load on demand. (Also called &amp;ldquo;lazy&amp;rdquo; loading.) Specifically, to call an &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutine on behalf of an undefined subroutine.</source>
          <target state="translated">요청시로드 ( &quot;지연&quot;로딩이라고도 함) 구체적 으로 정의되지 않은 서브 루틴 대신 &lt;code&gt;AUTOLOAD&lt;/code&gt; 서브 루틴 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="c23756075d8a23d3d03df135a356f7c210c8debd" translate="yes" xml:space="preserve">
          <source>To maintain backward compatibility with version 1.x of this module &lt;code&gt;gzreadline&lt;/code&gt; ignores the &lt;code&gt;$/&lt;/code&gt; variable - it</source>
          <target state="translated">이 모듈의 버전 1.x와의 호환성을 유지하기 위해 &lt;code&gt;gzreadline&lt;/code&gt; 은 &lt;code&gt;$/&lt;/code&gt; 변수를 무시 합니다.</target>
        </trans-unit>
        <trans-unit id="abc4743aa98a734da932da278854d69561d0cbfb" translate="yes" xml:space="preserve">
          <source>To make &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; work, we need to implement actual mutators, either directly, or in &lt;code&gt;nomethod&lt;/code&gt; . We continue to do things inside &lt;code&gt;nomethod&lt;/code&gt; , thus add</source>
          <target state="translated">&lt;code&gt;++&lt;/code&gt; 와 &lt;code&gt;--&lt;/code&gt; 작동 시키려면 실제 뮤 테이터를 직접 또는 &lt;code&gt;nomethod&lt;/code&gt; 로 구현해야합니다 . 우리는 &lt;code&gt;nomethod&lt;/code&gt; 내부에서 일을 계속하고 있으므로</target>
        </trans-unit>
        <trans-unit id="91a1c6beb7c38d494fe7c7d801b2befdd4173ffc" translate="yes" xml:space="preserve">
          <source>To make &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; work, there were two changes to</source>
          <target state="translated">&lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; 작동 하도록하기 위해 두 가지 변경 사항이있었습니다.</target>
        </trans-unit>
        <trans-unit id="b87c350e6119d6693a7cb04a8612a5e26f6e647d" translate="yes" xml:space="preserve">
          <source>To make a backup of &lt;code&gt;inFile.txt&lt;/code&gt; , give &lt;code&gt;-i&lt;/code&gt; a file extension to add:</source>
          <target state="translated">백업하려면 &lt;code&gt;inFile.txt&lt;/code&gt; 을 , 제공 &lt;code&gt;-i&lt;/code&gt; 추가 할 파일 확장자를 :</target>
        </trans-unit>
        <trans-unit id="8414b77ccfd34c712fab8c626931679fd71f5d22" translate="yes" xml:space="preserve">
          <source>To make a long story short, you can use the special variables &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; , &lt;code&gt;&amp;amp;PL_sv_yes&lt;/code&gt; and &lt;code&gt;&amp;amp;PL_sv_no&lt;/code&gt; with AVs and HVs, but you have to make sure you know what you're doing.</source>
          <target state="translated">간단히 말해서 AV 및 HV와 함께 특수 변수 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; , &lt;code&gt;&amp;amp;PL_sv_yes&lt;/code&gt; 및 &lt;code&gt;&amp;amp;PL_sv_no&lt;/code&gt; 를 사용할 수 있지만 현재 수행중인 작업을 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="5c0463c040e841ec603e099982e8abee57b683e9" translate="yes" xml:space="preserve">
          <source>To make life easier when dealing with duplicate keys, &lt;b&gt;DB_File&lt;/b&gt; comes with a few utility methods.</source>
          <target state="translated">중복 키를 처리 할 때 편리하게 사용할 수 있도록 &lt;b&gt;DB_File&lt;/b&gt; 에는 몇 가지 유틸리티 메소드가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="5ae2d3fa0128e67ff0e0a2c8bcd480511ed4d982" translate="yes" xml:space="preserve">
          <source>To make proper use of the</source>
          <target state="translated">제대로 사용하려면</target>
        </trans-unit>
        <trans-unit id="c44a199ec9bf1193e7c67a06e66e66c5a73ebf54" translate="yes" xml:space="preserve">
          <source>To make sure we're talking about the same thing when we discuss the removal of features or functionality from the Perl core, we have specific definitions for a few words and phrases.</source>
          <target state="translated">우리가 Perl 코어에서 기능을 제거하는 것에 대해 이야기 할 때 똑같은 것에 대해 이야기하고 있는지 확인하기 위해 몇 가지 단어와 문구에 대한 특정 정의가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5942273fcaa449896c9e37c66cd4e802e9c0964a" translate="yes" xml:space="preserve">
          <source>To make symbols from a &lt;b&gt;module&lt;/b&gt; available for &lt;b&gt;import&lt;/b&gt; by other modules.</source>
          <target state="translated">다른 모듈 에서 &lt;b&gt;모듈의&lt;/b&gt; 심볼 을 &lt;b&gt;가져올&lt;/b&gt; 수 있도록 합니다.</target>
        </trans-unit>
        <trans-unit id="dcd61647f554ce66ac28cd2d49ac0cbdb07ed537" translate="yes" xml:space="preserve">
          <source>To make the field hashes kick in, it is easiest to redefine &lt;code&gt;refaddr&lt;/code&gt; as</source>
          <target state="translated">필드 해시가 시작되도록하려면 &lt;code&gt;refaddr&lt;/code&gt; 를 다음 과 같이 재정의하는 것이 가장 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="ffcdcbe9b2ae0d61ba055686a39957aa53dc38e5" translate="yes" xml:space="preserve">
          <source>To make the interface more useful for older versions of Perl, a number of methods are supplied with &lt;b&gt;DB_File&lt;/b&gt; to simulate the missing array operations. All these methods are accessed via the object returned from the tie call.</source>
          <target state="translated">이전 버전의 Perl에 인터페이스를 더 유용하게 만들기 위해 누락 된 배열 조작을 시뮬레이트하기 위해 &lt;b&gt;DB_File&lt;/b&gt; 과 함께 많은 메소드가 제공 됩니다. 이러한 모든 메소드는 타이 호출에서 리턴 된 오브젝트를 통해 액세스됩니다.</target>
        </trans-unit>
        <trans-unit id="1e1af3e6c47d65824073836d9be72328a9d2a810" translate="yes" xml:space="preserve">
          <source>To make these calls fail</source>
          <target state="translated">이러한 호출을 실패하게하려면</target>
        </trans-unit>
        <trans-unit id="5100ca13c61421986a8b595f7f48745403cf86c2" translate="yes" xml:space="preserve">
          <source>To make things more complicated, the hash may contain references to the actual destinations, for example:</source>
          <target state="translated">보다 복잡한 작업을 위해 해시는 실제 대상에 대한 참조를 포함 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="23271da81593c086fb9f97e8eda36eed5fe8ab37" translate="yes" xml:space="preserve">
          <source>To make use of either of the two filter modules above, place the line below in a Perl source file.</source>
          <target state="translated">위의 두 필터 모듈 중 하나를 사용하려면 아래 행을 Perl 소스 파일에 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="546b84e64be1bb2630d4087e9c7e0aa2ec07fbeb" translate="yes" xml:space="preserve">
          <source>To make use of threading, however, one usually wants the threads to share at least some data between themselves. This is done with the &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt; module and the &lt;code&gt;:shared&lt;/code&gt; attribute:</source>
          <target state="translated">그러나 스레딩을 사용하기 위해 일반적으로 스레드가 적어도 일부 데이터를 공유하려고합니다. 이것은 &lt;a href=&quot;threads/shared&quot;&gt;threads :: shared&lt;/a&gt; 모듈과 &lt;code&gt;:shared&lt;/code&gt; 속성으로 수행됩니다 :</target>
        </trans-unit>
        <trans-unit id="482a24cc09ed210b4be1c7fca66ab517d60e1e62" translate="yes" xml:space="preserve">
          <source>To mark FILEHANDLE as UTF-8, use &lt;code&gt;:utf8&lt;/code&gt; or &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; . &lt;code&gt;:utf8&lt;/code&gt; just marks the data as UTF-8 without further checking, while &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; checks the data for actually being valid UTF-8. More details can be found in &lt;a href=&quot;../perlio/encoding&quot;&gt;PerlIO::encoding&lt;/a&gt;.</source>
          <target state="translated">FILEHANDLE을 UTF-8로 표시하려면 &lt;code&gt;:utf8&lt;/code&gt; 또는 &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; . &lt;code&gt;:utf8&lt;/code&gt; 은 추가 검사없이 데이터를 UTF-8로 표시하는 반면 &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; 은 데이터가 실제로 유효한 UTF-8인지 확인합니다. 자세한 내용은 &lt;a href=&quot;../perlio/encoding&quot;&gt;PerlIO :: encoding&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5274ade94ad24fbd8e1e1d8904bba9bc30f6d6c0" translate="yes" xml:space="preserve">
          <source>To mark FILEHANDLE as UTF-8, use &lt;code&gt;:utf8&lt;/code&gt; or &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; . &lt;code&gt;:utf8&lt;/code&gt; just marks the data as UTF-8 without further checking, while &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; checks the data for actually being valid UTF-8. More details can be found in &lt;a href=&quot;perlio/encoding&quot;&gt;PerlIO::encoding&lt;/a&gt;.</source>
          <target state="translated">FILEHANDLE을 UTF-8로 표시하려면 &lt;code&gt;:utf8&lt;/code&gt; 또는 &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; . &lt;code&gt;:utf8&lt;/code&gt; 은 추가 검사없이 데이터를 UTF-8로 표시하는 반면 &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; 은 데이터가 실제로 유효한 UTF-8인지 확인합니다. 자세한 내용은 &lt;a href=&quot;perlio/encoding&quot;&gt;PerlIO :: encoding&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b4e2df2dd87486f202e752cbd1bc2453ac926173" translate="yes" xml:space="preserve">
          <source>To minimize the number of sbrk(2)s, malloc() asks for more memory. This field gives the size of the yet unused part, which is sbrk(2)ed, but never touched.</source>
          <target state="translated">sbrk (2)의 수를 최소화하기 위해 malloc ()은 더 많은 메모리를 요구합니다. 이 필드는 아직 사용되지 않은 부분의 크기를 제공합니다.이 부분은 sbrk (2)이지만 결코 건드리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c7e29496ccd957aa4492216e45f2282e137e2591" translate="yes" xml:space="preserve">
          <source>To obtain this, a reference to a hash must be passed</source>
          <target state="translated">이를 얻으려면 해시에 대한 참조를 전달해야합니다</target>
        </trans-unit>
        <trans-unit id="76c61aa559d88fae477b92a372d192b3b51d4c5b" translate="yes" xml:space="preserve">
          <source>To open a file without blocking, creating if necessary:</source>
          <target state="translated">차단하지 않고 파일을 열려면 필요한 경우 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="354facfe42bf4e55b171df83905f745324ebd0c9" translate="yes" xml:space="preserve">
          <source>To open file for appending, create if necessary:</source>
          <target state="translated">추가 할 파일을 열려면 필요한 경우 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="1702818d3f57a9131b4035ed033f063e2b07cebf" translate="yes" xml:space="preserve">
          <source>To open file for appending, file must exist:</source>
          <target state="translated">추가 할 파일을 열려면 파일이 존재해야합니다.</target>
        </trans-unit>
        <trans-unit id="4967760590c67e61373186454a8e4a1135dcb6d9" translate="yes" xml:space="preserve">
          <source>To open file for reading:</source>
          <target state="translated">읽을 파일을 열려면 :</target>
        </trans-unit>
        <trans-unit id="cee1bc0ab3a065feee926895157fb947a422ff0d" translate="yes" xml:space="preserve">
          <source>To open file for update, create file if necessary:</source>
          <target state="translated">업데이트 할 파일을 열려면 필요한 경우 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="7c8a25c4e2b2e915deaf352a915d4e6583e2f962" translate="yes" xml:space="preserve">
          <source>To open file for update, file must exist:</source>
          <target state="translated">업데이트 할 파일을 열려면 파일이 존재해야합니다.</target>
        </trans-unit>
        <trans-unit id="b8d1b7a21cb716decbfe05cd44f437ced848a3ac" translate="yes" xml:space="preserve">
          <source>To open file for update, file must not exist:</source>
          <target state="translated">업데이트 할 파일을 열려면 파일이 존재하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="e09916f7ec3e12864e36849354a4ebf1fbb19361" translate="yes" xml:space="preserve">
          <source>To open file for writing, create new file if needed or else truncate old file:</source>
          <target state="translated">쓰기 위해 파일을 열려면 필요한 경우 새 파일을 만들거나 이전 파일을 자릅니다.</target>
        </trans-unit>
        <trans-unit id="290398a666a114bce8d99caa62b27b49c84e4b59" translate="yes" xml:space="preserve">
          <source>To open file for writing, create new file, file must not exist:</source>
          <target state="translated">쓰기 위해 파일을 열려면 새 파일을 만드십시오. 파일이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="6007d31a54fba5ebc4520f06ed8627e89a0d4a2c" translate="yes" xml:space="preserve">
          <source>To output UTF-8, use the &lt;code&gt;:encoding&lt;/code&gt; or &lt;code&gt;:utf8&lt;/code&gt; output layer. Prepending</source>
          <target state="translated">UTF-8을 출력하려면 &lt;code&gt;:encoding&lt;/code&gt; 또는 &lt;code&gt;:utf8&lt;/code&gt; 출력 레이어를 사용하십시오. 선행</target>
        </trans-unit>
        <trans-unit id="3b36e6dcece917ee92e199616190bf7ab5b56187" translate="yes" xml:space="preserve">
          <source>To overcome this limitation, you need to turn on /s matching within the prefix pattern, using the &lt;code&gt;(?s)&lt;/code&gt; directive: '(?s).*?(?=&amp;lt;H1&amp;gt;)'</source>
          <target state="translated">이 제한을 극복하려면 &lt;code&gt;(?s)&lt;/code&gt; 지시문을 사용하여 접두사 패턴 내에서 / s 일치를 설정해야합니다 . '(? s). *? (? = &amp;lt;H1&amp;gt;)'</target>
        </trans-unit>
        <trans-unit id="062f2ac749842e1dd1762ff59d78e1eb660fe9b7" translate="yes" xml:space="preserve">
          <source>To override a Perl built-in routine with your own version, you need to import it at compile-time. This can be conveniently achieved with the &lt;code&gt;subs&lt;/code&gt; pragma. This will affect only the package in which you've imported the said subroutine:</source>
          <target state="translated">고유 한 버전으로 Perl 내장 루틴을 대체하려면 컴파일시이를 가져와야합니다. 이것은 &lt;code&gt;subs&lt;/code&gt; pragma 로 편리하게 달성 할 수 있습니다 . 이것은 상기 서브 루틴을 가져온 패키지에만 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="1aa3f784c17082d78c7fbfe639d471e8c69f8458" translate="yes" xml:space="preserve">
          <source>To override a built-in globally (that is, in all namespaces), you need to import your function into the &lt;code&gt;CORE::GLOBAL&lt;/code&gt; pseudo-namespace at compile time:</source>
          <target state="translated">내장 된 전역 (즉, 모든 네임 스페이스)을 재정의하려면 컴파일시 함수를 &lt;code&gt;CORE::GLOBAL&lt;/code&gt; 의사 이름 공간 으로 가져와야합니다 .</target>
        </trans-unit>
        <trans-unit id="605fcd402b7e1fdc810b4ff2c0f6a15f906ca915" translate="yes" xml:space="preserve">
          <source>To pack dates stored as triplets ( day, month, year ) in an array &lt;code&gt;@dates&lt;/code&gt; into a sequence of byte, byte, short integer we can write</source>
          <target state="translated">&lt;code&gt;@dates&lt;/code&gt; 배열에 트리플렛 (day, month, year)으로 저장된 날짜 를 바이트, 바이트, 짧은 정수 시퀀스로 묶기 위해</target>
        </trans-unit>
        <trans-unit id="1d0cde2eb7df8017d255040c9f5af9796899dd92" translate="yes" xml:space="preserve">
          <source>To parse a string &lt;code&gt;$str&lt;/code&gt; as a floating point number use</source>
          <target state="translated">문자열 &lt;code&gt;$str&lt;/code&gt; 을 부동 소수점 숫자로 구문 분석하려면</target>
        </trans-unit>
        <trans-unit id="61571c195afbee84b0b85796b78595db86b7183b" translate="yes" xml:space="preserve">
          <source>To parse a string &lt;code&gt;$str&lt;/code&gt; as a number in some base &lt;code&gt;$base&lt;/code&gt; use</source>
          <target state="translated">일부 기본 &lt;code&gt;$base&lt;/code&gt; 사용 에서 문자열 &lt;code&gt;$str&lt;/code&gt; 을 숫자로 구문 분석하려면</target>
        </trans-unit>
        <trans-unit id="8c0b000078df0842ed41dd6cf17b93c225c65646" translate="yes" xml:space="preserve">
          <source>To parse this code, Perl uses a heuristic based on what package names it has seen, what subroutines exist in the current package, what barewords it has previously seen, and other input. Needless to say, heuristics can produce very surprising results!</source>
          <target state="translated">이 코드를 구문 분석하기 위해 Perl은 본 패키지 이름, 현재 패키지에 존재하는 서브 루틴, 이전에 본 베어 워드 및 기타 입력에 따라 휴리스틱을 사용합니다. 말할 것도없이, 휴리스틱은 매우 놀라운 결과를 낳을 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="fbca7774c8df9c1e7fff186e61962bc8047a5ac6" translate="yes" xml:space="preserve">
          <source>To pass an object method into a subroutine, you can do this:</source>
          <target state="translated">서브 루틴에 오브젝트 메소드를 전달하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="249caf0f11ba46a1737a888a2cd12f841c024b93" translate="yes" xml:space="preserve">
          <source>To pass supplemental arguments to a program opened with &lt;code&gt; '|-' &lt;/code&gt; or &lt;code&gt; '-|' &lt;/code&gt; append them to the command string as you would system EXPR.</source>
          <target state="translated">&lt;code&gt; '|-' &lt;/code&gt; 또는 &lt;code&gt; '-|' &lt;/code&gt; 으로 열린 프로그램에 보충 인수를 전달하려면 시스템 EXPR과 같이 명령 문자열에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="9bb3f23b2e2cd47ffa049a4b5b8e3297a48bd649" translate="yes" xml:space="preserve">
          <source>To prepare distribution you need to do following:</source>
          <target state="translated">배포를 준비하려면 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="47e04bab26a33f27d49843c62d8c3b7400695e70" translate="yes" xml:space="preserve">
          <source>To prepend lines to the beginning, print those lines before you enter the loop that prints the existing lines.</source>
          <target state="translated">줄을 처음에 추가하려면 기존 줄을 인쇄하는 루프에 들어가기 전에 해당 줄을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="453d8a60ef1b8720b3eb21b0a6becefda886f512" translate="yes" xml:space="preserve">
          <source>To prevent &amp;lt;extract_quotelike&amp;gt; from mucking about with the input in this way (this is the only case where a list-context &lt;code&gt;extract_quotelike&lt;/code&gt; does so), you can pass the input variable as an interpolated literal:</source>
          <target state="translated">&amp;lt;extract_quotelike&amp;gt;가 이런 식으로 입력에 대해 뭉개지는 것을 막기 위해 (리스트 컨텍스트 &lt;code&gt;extract_quotelike&lt;/code&gt; 가 유일하게 사용하는 경우 ) 입력 변수를 보간 리터럴로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="743105860f25b02f06770315902de6783c423895" translate="yes" xml:space="preserve">
          <source>To prevent &lt;code&gt;memoize&lt;/code&gt; from installing the memoized version anywhere, use &lt;code&gt;INSTALL =&amp;gt; &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;memoize&lt;/code&gt; 가 어디서나 memoized 버전을 설치 하지 못하게하려면 &lt;code&gt;INSTALL =&amp;gt; &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9de321857a95078722502ca43a0201a5f6a4b12" translate="yes" xml:space="preserve">
          <source>To prevent any ambiguity,</source>
          <target state="translated">모호성을 방지하기 위해</target>
        </trans-unit>
        <trans-unit id="ac0fc603c0e20ee050f6b1167e08040f2086e70a" translate="yes" xml:space="preserve">
          <source>To prevent the contents of a queue from being modified by another thread while it is being examined and/or changed, &lt;a href=&quot;../threads/shared#lock-VARIABLE&quot;&gt;lock&lt;/a&gt; the queue inside a local block:</source>
          <target state="translated">검사 및 / 또는 변경되는 동안 다른 스레드가 대기열의 내용을 수정하지 못하게하려면 로컬 블록 내부에서 대기열을 &lt;a href=&quot;../threads/shared#lock-VARIABLE&quot;&gt;잠그&lt;/a&gt; 십시오.</target>
        </trans-unit>
        <trans-unit id="521d225cb8b8267bdc9221af420cb3102374b4c5" translate="yes" xml:space="preserve">
          <source>To prevent this, supply a &lt;code&gt;NORMALIZER&lt;/code&gt; function that turns the program arguments into a string in a way that equivalent arguments turn into the same string. A &lt;code&gt;NORMALIZER&lt;/code&gt; function for &lt;code&gt;f&lt;/code&gt; above might look like this:</source>
          <target state="translated">이를 방지하려면 프로그램 인수를 동일한 인수가 동일한 문자열로 바뀌는 방식으로 프로그램 인수를 문자열로 바꾸는 &lt;code&gt;NORMALIZER&lt;/code&gt; 함수를 제공하십시오. 위의 &lt;code&gt;f&lt;/code&gt; 에 대한 &lt;code&gt;NORMALIZER&lt;/code&gt; 함수 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6fa84f786f1f2e361ba53d7582050f707e69605c" translate="yes" xml:space="preserve">
          <source>To produce a perl binary with a different name than &lt;code&gt;perl&lt;/code&gt; , either say</source>
          <target state="translated">보다 다른 이름으로 펄 바이너리를 생산하기 위해 &lt;code&gt;perl&lt;/code&gt; 중 하나를 말하자면,</target>
        </trans-unit>
        <trans-unit id="deeb5ed64d8b8726d03c2a35d8b9a4f9932501dd" translate="yes" xml:space="preserve">
          <source>To prove success on the host machine, run &quot;dumpbin /headers wince-arm-pocket-wce400\perl.exe&quot; from the win32/ folder and look for &quot;machine (ARM)&quot; in the FILE HEADER VALUES and &quot;subsystem (Windows CE GUI)&quot; in the OPTIONAL HEADER VALUES.</source>
          <target state="translated">호스트 시스템에서 성공을 증명하려면 win32 / 폴더에서 &quot;dumpbin / headers wince-arm-pocket-wce400 \ perl.exe&quot;를 실행하고 파일 헤더 값 및 &quot;서브 시스템 (Windows CE)에서&quot;시스템 (ARM) &quot;을 찾으십시오. 옵션 헤더 값에서 GUI) '를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e3f95db7629c92dc13df17dee2376ecae6bd28b4" translate="yes" xml:space="preserve">
          <source>To provide a Perl interface to this library we need to be able to map between the &lt;code&gt;fh&lt;/code&gt; parameter and the Perl subroutine we want called. A hash is a convenient mechanism for storing this mapping. The code below shows a possible implementation</source>
          <target state="translated">이 라이브러리에 Perl 인터페이스를 제공하려면 &lt;code&gt;fh&lt;/code&gt; 매개 변수와 호출하려는 Perl 서브 루틴 사이를 맵핑 할 수 있어야합니다 . 해시는이 매핑을 저장하는 편리한 메커니즘입니다. 아래 코드는 가능한 구현을 보여줍니다</target>
        </trans-unit>
        <trans-unit id="56afd5e1c9ab39b7d24b6a35fc7523124fb4a154" translate="yes" xml:space="preserve">
          <source>To provide an example, let's say the popular &lt;code&gt;Foo::Bar::escape_html&lt;/code&gt; function doesn't deal with Unicode data yet. The wrapper function would convert the argument to raw UTF-8 and convert the result back to Perl's internal representation like so:</source>
          <target state="translated">예를 들어, 인기있는 &lt;code&gt;Foo::Bar::escape_html&lt;/code&gt; 함수가 아직 유니 코드 데이터를 처리하지 않는다고 가정 해 봅시다 . 랩퍼 함수는 인수를 원시 UTF-8로 변환하고 결과를 다음과 같이 Perl의 내부 표현으로 다시 변환합니다.</target>
        </trans-unit>
        <trans-unit id="fe539191c8112058d164cdbdc07c4a313e2ceb71" translate="yes" xml:space="preserve">
          <source>To provide backward compatibility with the previous version of Net::Ping, a pingecho() subroutine is available with the same functionality as before. pingecho() uses the tcp protocol. The return values and parameters are the same as described for the ping() method. This subroutine is obsolete and may be removed in a future version of Net::Ping.</source>
          <target state="translated">이전 버전의 Net :: Ping과 역 호환성을 제공하기 위해 pingecho () 서브 루틴을 이전과 동일한 기능으로 사용할 수 있습니다. pingecho ()는 tcp 프로토콜을 사용합니다. 리턴 값과 매개 변수는 ping () 메소드에 대해 설명한 것과 동일합니다. 이 서브 루틴은 더 이상 사용되지 않으며 향후 Net :: Ping 버전에서 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ece610257b3402f7eea4d17dbc76eda55d9cbb02" translate="yes" xml:space="preserve">
          <source>To provide the capability to set/get class-wide settings, it is best instead to provide accessors as subroutines or class methods instead.</source>
          <target state="translated">클래스 전체 설정을 설정 / 취득하는 기능을 제공하려면 대신 접근자를 서브 루틴 또는 클래스 메소드로 제공하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b8ad3c75e2a9658073e3c75677575371b7b2154a" translate="yes" xml:space="preserve">
          <source>To put the output from any parse method into a string instead of a file handle, call the output_string() method instead of output_fh().</source>
          <target state="translated">구문 분석 메소드의 출력을 파일 핸들 대신 문자열로 넣으려면 output_fh () 대신 output_string () 메소드를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="8d3d8f79e5bb23da5237f2bc4f067b582af08744" translate="yes" xml:space="preserve">
          <source>To quickly check the type of a &lt;code&gt;Archive::Tar::File&lt;/code&gt; object, you can use the following methods:</source>
          <target state="translated">&lt;code&gt;Archive::Tar::File&lt;/code&gt; 객체 의 유형을 빠르게 확인하려면 다음 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffb74a402d25037ed756434b89268f8c6c0f487e" translate="yes" xml:space="preserve">
          <source>To quote the bzip2 documentation</source>
          <target state="translated">bzip2 설명서를 인용하려면</target>
        </trans-unit>
        <trans-unit id="2e030dd198e6e120e9f1df9a82e7575806595a2d" translate="yes" xml:space="preserve">
          <source>To read an entire &lt;b&gt;file&lt;/b&gt; into a &lt;b&gt;string&lt;/b&gt; in one operation.</source>
          <target state="translated">한 번의 작업 으로 전체 &lt;b&gt;파일&lt;/b&gt; 을 &lt;b&gt;문자열&lt;/b&gt; 로 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="d6676802f298dda33ea89ee297e7a4c3b7e4e2ac" translate="yes" xml:space="preserve">
          <source>To read both a command's STDOUT and its STDERR separately, it's easiest to redirect them separately to files, and then read from those files when the program is done:</source>
          <target state="translated">명령의 STDOUT과 STDERR을 별도로 읽으려면 명령을 파일로 개별적으로 리디렉션 한 다음 프로그램이 완료되면 해당 파일에서 읽는 것이 가장 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="441b0a3f043e9d675f24f50e1a3845049a78b701" translate="yes" xml:space="preserve">
          <source>To read both a command's STDOUT and its STDERR separately, you can redirect them to temp files, let the command run, then read the temp files:</source>
          <target state="translated">명령의 STDOUT과 STDERR을 별도로 읽으려면 임시 파일로 리디렉션하고 명령을 실행 한 다음 임시 파일을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5540d6192acd70f39a8ef597e449669bc8ae5ddb" translate="yes" xml:space="preserve">
          <source>To read from an existing Perl filehandle, &lt;code&gt;$input&lt;/code&gt; , and write the compressed data to a buffer, &lt;code&gt;$buffer&lt;/code&gt; .</source>
          <target state="translated">기존 Perl 파일 핸들 &lt;code&gt;$input&lt;/code&gt; 에서 읽고 압축 된 데이터를 &lt;code&gt;$buffer&lt;/code&gt; 버퍼에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="c349b729382da049ab850b286913e925d6fe3968" translate="yes" xml:space="preserve">
          <source>To read from an existing Perl filehandle, &lt;code&gt;$input&lt;/code&gt; , and write the uncompressed data to a buffer, &lt;code&gt;$buffer&lt;/code&gt; .</source>
          <target state="translated">기존 Perl 파일 핸들 &lt;code&gt;$input&lt;/code&gt; 을 읽고 압축되지 않은 데이터를 버퍼 &lt;code&gt;$buffer&lt;/code&gt; 씁니다 .</target>
        </trans-unit>
        <trans-unit id="7482ebcf137b958140c12465f2671a82fcf986b9" translate="yes" xml:space="preserve">
          <source>To read the</source>
          <target state="translated">읽기</target>
        </trans-unit>
        <trans-unit id="87df4beb52a8613330401231fb10bf4839a044e4" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.1950&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;file1.txt.1950&lt;/code&gt; 파일의 내용을 읽고 압축되지 않은 데이터를 &lt;code&gt;file1.txt&lt;/code&gt; 파일에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="5f3af95cfb979c68a078d4244b348eca50284cce" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.1951&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;file1.txt.1951&lt;/code&gt; 파일의 내용을 읽고 압축되지 않은 데이터를 &lt;code&gt;file1.txt&lt;/code&gt; 파일에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="fe87604cf51141fe67b4d7c05185428541881932" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.Compressed&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;file1.txt.Compressed&lt;/code&gt; 파일의 내용을 읽고 압축되지 않은 데이터를 &lt;code&gt;file1.txt&lt;/code&gt; 파일에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="dcd74724ed743479732074df76791b8e4375f0ba" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.bz2&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;file1.txt.bz2&lt;/code&gt; 파일의 내용을 읽고 압축되지 않은 데이터를 &lt;code&gt;file1.txt&lt;/code&gt; 파일에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="d0224a4a1040095275155b56f5f7207fca1c2ad1" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.gz&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;file1.txt.gz&lt;/code&gt; 파일의 내용을 읽고 압축되지 않은 데이터를 &lt;code&gt;file1.txt&lt;/code&gt; 파일에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="62b61bd1daa8a6cb2d7eb96d3ece7209a79b5aec" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.1950&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;file1.txt&lt;/code&gt; 파일의 내용을 읽고 압축 된 데이터를 &lt;code&gt;file1.txt.1950&lt;/code&gt; 파일에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="3e429b7a25235b582c4b383620392f1a750a3bdd" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.1951&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;file1.txt&lt;/code&gt; 파일의 내용을 읽고 압축 된 데이터를 &lt;code&gt;file1.txt.1951&lt;/code&gt; 파일에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="c406d8acaac2a742d676187babe70fbc63a189bd" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.bz2&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;file1.txt&lt;/code&gt; 파일의 내용을 읽고 압축 된 데이터를 &lt;code&gt;file1.txt.bz2&lt;/code&gt; 파일에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="fa350228ff2721777414a685ddb5c4e3af10826c" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.gz&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;file1.txt&lt;/code&gt; 파일의 내용을 읽고 압축 된 데이터를 &lt;code&gt;file1.txt.gz&lt;/code&gt; 파일에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="1253348a31fd66554a6efd5d56c0e22a2ff1b137" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.zip&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;file1.txt&lt;/code&gt; 파일의 내용을 읽고 압축 된 데이터를 &lt;code&gt;file1.txt.zip&lt;/code&gt; 파일에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="7cb0378e48901dddc588a6225fe4a4196884f056" translate="yes" xml:space="preserve">
          <source>To really poke around with Perl, you'll probably want to build Perl for debugging, like this:</source>
          <target state="translated">실제로 Perl을 둘러 보려면 다음과 같이 디버깅을 위해 Perl을 빌드해야 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="224b47d42836cf02b0538bc7324878629aa47a30" translate="yes" xml:space="preserve">
          <source>To receive an announcement whenever a new version of this module is released, send a blank email message to &lt;code&gt;mjd-perl-tiefile-subscribe@plover.com&lt;/code&gt; .</source>
          <target state="translated">이 모듈의 새 버전이 릴리스 될 때마다 알림을 받으려면 빈 이메일 메시지를 &lt;code&gt;mjd-perl-tiefile-subscribe@plover.com&lt;/code&gt; 으로 보내 십시오 .</target>
        </trans-unit>
        <trans-unit id="d3e33fd8f77a0950334d95b2b753813796d2bf20" translate="yes" xml:space="preserve">
          <source>To recursively create a directory structure, look at the &lt;code&gt;make_path&lt;/code&gt; function of the &lt;a href=&quot;../file/path&quot;&gt;File::Path&lt;/a&gt; module.</source>
          <target state="translated">디렉토리 구조를 재귀 적으로 작성하려면 &lt;a href=&quot;../file/path&quot;&gt;File :: Path&lt;/a&gt; 모듈 의 &lt;code&gt;make_path&lt;/code&gt; 함수를 보십시오 .</target>
        </trans-unit>
        <trans-unit id="d93ce0279ba5e733f28599be83e53944021fc924" translate="yes" xml:space="preserve">
          <source>To recursively create a directory structure, look at the &lt;code&gt;make_path&lt;/code&gt; function of the &lt;a href=&quot;file/path&quot;&gt;File::Path&lt;/a&gt; module.</source>
          <target state="translated">디렉토리 구조를 재귀 적으로 작성하려면 &lt;a href=&quot;file/path&quot;&gt;File :: Path&lt;/a&gt; 모듈 의 &lt;code&gt;make_path&lt;/code&gt; 함수를 보십시오 .</target>
        </trans-unit>
        <trans-unit id="b5946d1b5adc8bf79e8d8691892a42663cd834d2" translate="yes" xml:space="preserve">
          <source>To reduce the overhead as much as possible, only one possible location is checked to find the extension DLL (this location is where &lt;code&gt;make install&lt;/code&gt; would put the DLL). If not found, the search for the DLL is transparently delegated to &lt;code&gt;DynaLoader&lt;/code&gt; , which looks for the DLL along the &lt;code&gt;@INC&lt;/code&gt; list.</source>
          <target state="translated">가능한 한 오버 헤드를 줄이려면 확장 DLL을 찾기 위해 가능한 한 위치 만 확인합니다 (이 위치는 &lt;code&gt;make install&lt;/code&gt; 이 DLL을 배치하는 위치입니다 ). 찾을 수없는 경우 DLL 검색은 &lt;code&gt;DynaLoader&lt;/code&gt; 에 투명하게 위임 되며, &lt;code&gt;@INC&lt;/code&gt; 목록 에서 DLL을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="98bed95392f2bd5c21b8012e731bec1f2530889e" translate="yes" xml:space="preserve">
          <source>To remove a directory tree recursively (&lt;code&gt;rm -rf&lt;/code&gt; on Unix) look at the &lt;code&gt;rmtree&lt;/code&gt; function of the &lt;a href=&quot;../file/path&quot;&gt;File::Path&lt;/a&gt; module.</source>
          <target state="translated">디렉토리 트리를 재귀 적으로 제거하려면 ( UNIX의 경우 &lt;code&gt;rm -rf&lt;/code&gt; ) &lt;a href=&quot;../file/path&quot;&gt;File :: Path&lt;/a&gt; 모듈 의 &lt;code&gt;rmtree&lt;/code&gt; 함수를 보십시오 .</target>
        </trans-unit>
        <trans-unit id="4e5b819764f7105a80a7d510f2a867ba675bddec" translate="yes" xml:space="preserve">
          <source>To remove a directory tree recursively (&lt;code&gt;rm -rf&lt;/code&gt; on Unix) look at the &lt;code&gt;rmtree&lt;/code&gt; function of the &lt;a href=&quot;file/path&quot;&gt;File::Path&lt;/a&gt; module.</source>
          <target state="translated">디렉토리 트리를 재귀 적으로 제거하려면 ( UNIX의 경우 &lt;code&gt;rm -rf&lt;/code&gt; ) &lt;a href=&quot;file/path&quot;&gt;File :: Path&lt;/a&gt; 모듈 의 &lt;code&gt;rmtree&lt;/code&gt; 함수를 보십시오 .</target>
        </trans-unit>
        <trans-unit id="e56141f1ebe96f14282b26d571378c274b2244ed" translate="yes" xml:space="preserve">
          <source>To remove a tied environment variable from the environment, assign it the undefined value</source>
          <target state="translated">환경에서 묶인 환경 변수를 제거하려면 정의되지 않은 값을 지정하십시오</target>
        </trans-unit>
        <trans-unit id="06b0ac63c637336d9c539fb315b8373179470836" translate="yes" xml:space="preserve">
          <source>To remove creation of the tied hash on each access, one may an extra level of indirection which allows a non-circular structure of references:</source>
          <target state="translated">각 액세스에서 묶인 해시의 생성을 제거하기 위해 비 원형 참조 구조를 허용하는 추가적인 간접 수준이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="385dafb73da7d1789642356fd78d8d3446310a3d" translate="yes" xml:space="preserve">
          <source>To remove the magic from an SV, call the function sv_unmagic:</source>
          <target state="translated">SV에서 마법을 제거하려면 sv_unmagic 함수를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="ee81225f636096e269a365626b3e0c2212110758" translate="yes" xml:space="preserve">
          <source>To report a new bug, visit:</source>
          <target state="translated">새로운 버그를보고하려면 다음을 방문하십시오.</target>
        </trans-unit>
        <trans-unit id="935323786b12419a7345fc07129055605bd12b91" translate="yes" xml:space="preserve">
          <source>To retrieve data stored to disk, use &lt;code&gt;retrieve&lt;/code&gt; with a file name. The objects stored into that file are recreated into memory for you, and a</source>
          <target state="translated">디스크에 저장된 데이터를 검색하려면 파일 이름과 함께 &lt;code&gt;retrieve&lt;/code&gt; 를 사용 하십시오. 해당 파일에 저장된 객체는 메모리를 위해 다시 생성되며</target>
        </trans-unit>
        <trans-unit id="4f95fbea27e1a9b8ba09786147eb856c1d1f83f4" translate="yes" xml:space="preserve">
          <source>To retrieve the &lt;code&gt;REGEXP&lt;/code&gt; object from the scalar in an XS function use the &lt;code&gt;SvRX&lt;/code&gt; macro, see &lt;a href=&quot;perlapi#REGEXP-Functions&quot;&gt;REGEXP Functions in perlapi&lt;/a&gt;.</source>
          <target state="translated">XS 함수의 스칼라에서 &lt;code&gt;REGEXP&lt;/code&gt; 오브젝트 를 검색하려면 &lt;code&gt;SvRX&lt;/code&gt; 매크로를 사용하십시오 ( perlapi의 &lt;a href=&quot;perlapi#REGEXP-Functions&quot;&gt;REGEXP 함수&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="1231633ff6452d875f890a43a2ae8ede0790e949" translate="yes" xml:space="preserve">
          <source>To return an empty list one must use a PPCODE: block and then not push return values on the stack.</source>
          <target state="translated">빈 목록을 반환하려면 PPCODE : 블록을 사용해야하며 스택에서 반환 값을 푸시하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="c52a15c8b572dc0999ddd7a3d452b4f9cfbf130a" translate="yes" xml:space="preserve">
          <source>To run Perl on DPMI platforms one needs RSX runtime. This is needed under DOS-inside-OS/2, Win0.3*, Win0.95 and WinNT (see &lt;a href=&quot;#Other-OSes&quot;&gt;Other OSes&lt;/a&gt;). RSX would not work with VCPI only, as EMX would, it requires DMPI.</source>
          <target state="translated">DPMI 플랫폼에서 Perl을 실행하려면 RSX 런타임이 필요합니다. 이것은 DOS-inside-OS / 2, Win0.3 *, Win0.95 및 WinNT에서 필요합니다 ( &lt;a href=&quot;#Other-OSes&quot;&gt;기타 OS&lt;/a&gt; 참조 ). RSX는 EMX와 마찬가지로 VCPI에서만 작동하지 않으며 DMPI가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="f4988afc10b11011c01fd1dc8e2d9efa2ca35527" translate="yes" xml:space="preserve">
          <source>To run a &lt;b&gt;program&lt;/b&gt; or &lt;b&gt;subroutine&lt;/b&gt;. (Has nothing to do with the &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; built-in, unless you&amp;rsquo;re trying to run a &lt;b&gt;signal handler&lt;/b&gt;.)</source>
          <target state="translated">&lt;b&gt;프로그램&lt;/b&gt; 또는 &lt;b&gt;서브 루틴&lt;/b&gt; 을 실행합니다 . &lt;b&gt;신호 처리기&lt;/b&gt; 를 실행하지 않는 한 내장 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; 와는 아무런 관련이 없습니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8cf4ac8bbb41685c2ce7804ccdb1791a6e3ce985" translate="yes" xml:space="preserve">
          <source>To run a Perl program from the Unix command line:</source>
          <target state="translated">Unix 명령 행에서 Perl 프로그램을 실행하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="69d193d311b7fdb3c43e19bb64a6bebcfed27d39" translate="yes" xml:space="preserve">
          <source>To run this code, &lt;code&gt;perl_run&lt;/code&gt; is called, which does a &lt;code&gt;JMPENV_PUSH&lt;/code&gt; then enters a runops loop. This loop executes the eval and tie ops on line 1, with the eval pushing a &lt;code&gt;CxEVAL&lt;/code&gt; onto the context stack.</source>
          <target state="translated">이 코드를 실행하기 위해 &lt;code&gt;perl_run&lt;/code&gt; 이 호출되어 &lt;code&gt;JMPENV_PUSH&lt;/code&gt; 를 수행 한 다음 runops 루프를 시작합니다. 이 루프는 라인 1에서 eval 및 tie ops를 실행하고 eval은 &lt;code&gt;CxEVAL&lt;/code&gt; 을 컨텍스트 스택으로 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="46ec5458708076d609a6883cd1bd780e161cc64e" translate="yes" xml:space="preserve">
          <source>To say the least, surrogate pairs were the biggest mistake of the Unicode Consortium. But according to the late Douglas Adams in</source>
          <target state="translated">말하자면 대리 쌍은 유니 코드 컨소시엄의 가장 큰 실수였습니다. 그러나 더글러스 아담스의 말에 따르면</target>
        </trans-unit>
        <trans-unit id="48af12ca119bf709d476507ec2e3aea7bdcd0d97" translate="yes" xml:space="preserve">
          <source>To search the perlfaq question headings:</source>
          <target state="translated">perlfaq 질문 제목을 검색하려면</target>
        </trans-unit>
        <trans-unit id="518862144f077b9ba7e98c4f411c046f6e96affb" translate="yes" xml:space="preserve">
          <source>To see all about your machine, type</source>
          <target state="translated">컴퓨터에 관한 모든 정보를 보려면</target>
        </trans-unit>
        <trans-unit id="5d0d28f6946dedb31c299d2d78aa9802594a8195" translate="yes" xml:space="preserve">
          <source>To see how (un)packing works, we'll start with a simple template code where the conversion is in low gear: between the contents of a byte sequence and a string of hexadecimal digits. Let's use &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;, since this is likely to remind you of a dump program, or some desperate last message unfortunate programs are wont to throw at you before they expire into the wild blue yonder. Assuming that the variable &lt;code&gt;$mem&lt;/code&gt; holds a sequence of bytes that we'd like to inspect without assuming anything about its meaning, we can write</source>
          <target state="translated">(패킹) 작동 방식을 확인하기 위해 바이트 시퀀스의 내용과 16 진 문자열 사이의 변환이 적은 간단한 템플릿 코드부터 시작하겠습니다. &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 을 사용하자. 이것은 덤프 프로그램을 상기 시키거나 불행한 마지막 메시지는 야생의 푸른 저면으로 만료되기 전에 당신에게 던지지 않을 것이다. 변수 &lt;code&gt;$mem&lt;/code&gt; 에 의미에 대해 아무 것도 가정하지 않고 검사하려는 바이트 시퀀스가 ​​있다고 가정하면 다음을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="526ccfeab3729429cc060187cce1bbaba5ac3037" translate="yes" xml:space="preserve">
          <source>To see how this affects &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;, we'll compare these two C structures:</source>
          <target state="translated">이것이 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 에 어떤 영향을 미치는지 알아보기 위해 다음 두 C 구조를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="99fa402c0f19d397a266c609792e7a721baa908f" translate="yes" xml:space="preserve">
          <source>To see if a variable contains a reference, use the &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; function. It returns true if its argument is a reference. Actually it's a little better than that: It returns &lt;code&gt;HASH&lt;/code&gt; for hash references and &lt;code&gt;ARRAY&lt;/code&gt; for array references.</source>
          <target state="translated">변수에 참조가 포함되어 있는지 확인하려면 &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 함수를 사용하십시오 . 인수가 참조 인 경우 true를 리턴합니다. 실제로 그것은 그것보다 조금 낫습니다 : 해시 참조의 경우 &lt;code&gt;HASH&lt;/code&gt; 를 , 배열 참조의 경우 &lt;code&gt;ARRAY&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="960bf2c563408fba71fe24086af2e53cbf0767bd" translate="yes" xml:space="preserve">
          <source>To see if your system is affected by this discrepancy check if &lt;code&gt;getconf GNU_LIBPTHREAD_VERSION | &lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt; -q NPTL&lt;/code&gt; returns a false value. NTPL threads preserve the POSIX semantics.</source>
          <target state="translated">시스템이이 불일치에 의해 영향을 받는지 확인하려면 &lt;code&gt;getconf GNU_LIBPTHREAD_VERSION | &lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt; -q NPTL&lt;/code&gt; 은 잘못된 값을 반환합니다. NTPL 스레드는 POSIX 의미를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="d211374e5db97da1828e5f0a6f84c0b749ec44e8" translate="yes" xml:space="preserve">
          <source>To see it in action, add a method</source>
          <target state="translated">실제로 작동하려면 메소드를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="5e8654d4f5f9129c9cab32750ab5566521abf2dc" translate="yes" xml:space="preserve">
          <source>To see what a state description looks like, just run the following:</source>
          <target state="translated">상태 설명이 어떻게 보이는지 보려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="1afd16a9742f3bb00f5d52a4bea0944a04f89bb4" translate="yes" xml:space="preserve">
          <source>To see what is installed on your system:</source>
          <target state="translated">시스템에 설치된 내용을 보려면</target>
        </trans-unit>
        <trans-unit id="759c7cca5357567d905de52c1b1b6b667aaa23a6" translate="yes" xml:space="preserve">
          <source>To see what version is included on the DVD (assumed here to be mounted on /cdrom), issue this command:</source>
          <target state="translated">DVD에 포함 된 버전 (/ cdrom에 마운트 된 것으로 가정)을 보려면 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="7ad61eadcf1dbdb7c99f44756b97def548456147" translate="yes" xml:space="preserve">
          <source>To see whether you have non-const data you can use a BSD (or GNU) compatible &lt;code&gt;nm&lt;/code&gt; :</source>
          <target state="translated">비 const 데이터가 있는지 확인하려면 BSD (또는 GNU) 호환 &lt;code&gt;nm&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ceecb8953e41093c57b8581763c4bd993092c9bf" translate="yes" xml:space="preserve">
          <source>To see why this is a problem, consider what can happen when two processes, say &quot;A&quot; and &quot;B&quot;, both want to update the same &lt;b&gt;DB_File&lt;/b&gt; database using the locking steps outlined above. Assume process &quot;A&quot; has already opened the database and has a write lock, but it hasn't actually updated the database yet (it has finished step 2, but not started step 3 yet). Now process &quot;B&quot; tries to open the same database - step 1 will succeed, but it will block on step 2 until process &quot;A&quot; releases the lock. The important thing to notice here is that at this point in time both processes will have cached identical initial blocks from the database.</source>
          <target state="translated">이것이 왜 문제인지 확인하려면 &quot;A&quot;및 &quot;B&quot;와 같은 두 프로세스가 위에서 설명한 잠금 단계를 사용하여 동일한 &lt;b&gt;DB_File&lt;/b&gt; 데이터베이스 를 업데이트하려고 할 때 발생할 수있는 상황을 고려 하십시오. &quot;A&quot;프로세스가 이미 데이터베이스를 열고 쓰기 잠금을 가지고 있지만 실제로 데이터베이스를 아직 업데이트하지 않았다고 가정합니다 (2 단계는 완료했지만 3 단계는 아직 시작되지 않음). 이제 프로세스 &quot;B&quot;는 동일한 데이터베이스를 열려고합니다. 1 단계는 성공하지만 &quot;A&quot;프로세스가 잠금을 해제 할 때까지 2 단계에서 차단됩니다. 여기서 주목할 점은이 시점에서 두 프로세스 모두 데이터베이스에서 동일한 초기 블록을 캐시한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="887591ebb547202a2fbb02bece1d9984e9bcdec7" translate="yes" xml:space="preserve">
          <source>To see why, notice how you'll still have an issue on half-way-point alternation:</source>
          <target state="translated">이유를 확인하려면 중간 지점 교대에 여전히 문제가있는 방법에 주목하십시오.</target>
        </trans-unit>
        <trans-unit id="0cddf3be7ebfd9389288691711afdcfed8edf9c1" translate="yes" xml:space="preserve">
          <source>To send a &lt;b&gt;datagram&lt;/b&gt; to multiple destinations simultaneously.</source>
          <target state="translated">여러 대상으로 동시에 &lt;b&gt;데이터 그램&lt;/b&gt; 을 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="8617ca70598e41eabf7c915af7a92af825a55fcd" translate="yes" xml:space="preserve">
          <source>To send something to its correct destination. Often used metaphorically to indicate a transfer of programmatic control to a destination selected algorithmically, often by lookup in a table of function &lt;b&gt;references&lt;/b&gt; or, in the case of object &lt;b&gt;methods&lt;/b&gt;, by traversing the inheritance tree looking for the most specific definition for the method.</source>
          <target state="translated">올바른 목적지로 무언가를 보내기 위해. 종종 함수 &lt;b&gt;참조&lt;/b&gt; 테이블에서 조회 하거나 객체 &lt;b&gt;메소드&lt;/b&gt; 의 경우 &lt;b&gt;메소드&lt;/b&gt; 트리에 대해 가장 구체적인 정의를 찾기 위해 상속 트리를 탐색하여 알고리즘 적으로 선택된 대상으로 프로그래밍 제어의 전송을 표시하기 위해 은유 적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="67e016f9948cc1473ec98e12bd274f9eaa7682bd" translate="yes" xml:space="preserve">
          <source>To set the state of a pragma:</source>
          <target state="translated">pragma의 상태를 설정하려면</target>
        </trans-unit>
        <trans-unit id="4d0f638abe1cc26ab6bbeb03cebb08b40820c287" translate="yes" xml:space="preserve">
          <source>To set your private value, call &lt;code&gt;Perl_mro_set_private_data()&lt;/code&gt; :</source>
          <target state="translated">개인 값을 설정하려면 &lt;code&gt;Perl_mro_set_private_data()&lt;/code&gt; 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="39b42d6c90a6c04419bddc3aa56e776f03e6d4b1" translate="yes" xml:space="preserve">
          <source>To shut off its generation, pass the &lt;code&gt;NO_META&lt;/code&gt; flag to &lt;code&gt;WriteMakefile()&lt;/code&gt; .</source>
          <target state="translated">생성을 종료하려면 &lt;code&gt;NO_META&lt;/code&gt; 플래그를 &lt;code&gt;WriteMakefile()&lt;/code&gt; 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="57cf8244407c213f6cbced635b585a8f402b31ff" translate="yes" xml:space="preserve">
          <source>To signal the semaphore, replace &lt;code&gt;-1&lt;/code&gt; with &lt;code&gt;1&lt;/code&gt; . See also &lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt;, &lt;code&gt;IPC::SysV&lt;/code&gt; , and &lt;code&gt;IPC::SysV::Semaphore&lt;/code&gt; documentation.</source>
          <target state="translated">세마포어에 신호를 보내려면 &lt;code&gt;-1&lt;/code&gt; 을 &lt;code&gt;1&lt;/code&gt; 로 바꾸십시오 . 참조 &lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;시스템 V IPC는 perlipc에서&lt;/a&gt; , &lt;code&gt;IPC::SysV&lt;/code&gt; 및 &lt;code&gt;IPC::SysV::Semaphore&lt;/code&gt; 문서를.</target>
        </trans-unit>
        <trans-unit id="d782cb39a280e66911e6595a3826686b674e633e" translate="yes" xml:space="preserve">
          <source>To signal the semaphore, replace &lt;code&gt;-1&lt;/code&gt; with &lt;code&gt;1&lt;/code&gt; . See also &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt;, &lt;code&gt;IPC::SysV&lt;/code&gt; , and &lt;code&gt;IPC::SysV::Semaphore&lt;/code&gt; documentation.</source>
          <target state="translated">세마포어에 신호를 보내려면 &lt;code&gt;-1&lt;/code&gt; 을 &lt;code&gt;1&lt;/code&gt; 로 바꾸십시오 . 참조 &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;시스템 V IPC는 perlipc에서&lt;/a&gt; , &lt;code&gt;IPC::SysV&lt;/code&gt; 및 &lt;code&gt;IPC::SysV::Semaphore&lt;/code&gt; 문서를.</target>
        </trans-unit>
        <trans-unit id="46e199b8e074ec6e1896ea95f9bad604e453a779" translate="yes" xml:space="preserve">
          <source>To signal to Perl that HMQ is not needed any more, call &lt;code&gt;perl_hmq_UNSET(serve)&lt;/code&gt; . Perl process will automatically morph/unmorph itself into/from a PM process if HMQ is needed/not-needed. Perl will automatically enable/disable &lt;code&gt;WM_QUIT&lt;/code&gt; message during shutdown if the message queue is served/not-served.</source>
          <target state="translated">HMQ가 더 이상 필요하지 않다는 것을 Perl에 알리려면 &lt;code&gt;perl_hmq_UNSET(serve)&lt;/code&gt; 호출 하십시오 . HMQ가 필요하거나 필요하지 않은 경우 Perl 프로세스는 PM 프로세스에서 자동으로 PM 프로세스로 / 변형되지 않습니다. 메시지 큐가 제공 / 제공되지 않으면 펄은 종료 중에 &lt;code&gt;WM_QUIT&lt;/code&gt; 메시지를 자동으로 활성화 / 비활성화 합니다.</target>
        </trans-unit>
        <trans-unit id="3868e3b616a54cb1bab8634fd841ed657adc2c50" translate="yes" xml:space="preserve">
          <source>To silently interpret it as the Perl operator, use the &lt;code&gt;CORE::&lt;/code&gt; prefix on the operator (e.g. &lt;code&gt;CORE::log($x)&lt;/code&gt; ) or declare the subroutine to be an object method (see &lt;a href=&quot;perlsub#Subroutine-Attributes&quot;&gt;Subroutine Attributes in perlsub&lt;/a&gt; or &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt;).</source>
          <target state="translated">이를 Perl 연산자로 자동 해석하려면 연산자에서 &lt;code&gt;CORE::&lt;/code&gt; 접두어를 사용하거나 (예 : &lt;code&gt;CORE::log($x)&lt;/code&gt; ) 서브 루틴을 오브젝트 메소드로 선언하십시오 ( &lt;a href=&quot;perlsub#Subroutine-Attributes&quot;&gt;perlsub&lt;/a&gt; 또는 &lt;a href=&quot;attributes&quot;&gt;attributes의 &lt;/a&gt;서브 루틴 속성 참조 ).</target>
        </trans-unit>
        <trans-unit id="ea26257b4903cfdcc4f9b51c3c53cf94dc5f1003" translate="yes" xml:space="preserve">
          <source>To simplify multi-line substitutions, the &quot;.&quot; character never matches a newline unless you use the &lt;code&gt;/s&lt;/code&gt; modifier, which in effect tells Perl to pretend the string is a single line--even if it isn't.</source>
          <target state="translated">여러 줄 대체를 단순화하려면 &quot;.&quot; &lt;code&gt;/s&lt;/code&gt; 수정자를 사용하지 않으면 문자는 줄 바꿈과 절대 일치 하지 않습니다. 실제로는 문자열이 한 줄이 아닌 경우에도 Perl에게 문자열을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="3dcc0c984ac1c1f3aa01cd10ae020a1e23d2e144" translate="yes" xml:space="preserve">
          <source>To skip lines, use the looping controls. The &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; in this example skips comment lines, and the &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; stops all processing once it encounters either &lt;code&gt;__END__&lt;/code&gt; or &lt;code&gt;__DATA__&lt;/code&gt; .</source>
          <target state="translated">줄을 건너 뛰려면 루핑 컨트롤을 사용하십시오. &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 예 스킵 주석 라인 및 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 은 어느 만나면 모든 처리를 중지 &lt;code&gt;__END__&lt;/code&gt; 또는 &lt;code&gt;__DATA__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cb7cc3fb6917e0db56d0ceef1f6b092afc65ddb" translate="yes" xml:space="preserve">
          <source>To solve this, you must manually use pipe(), fork(), and the form of open() which sets one file descriptor to another, as shown below:</source>
          <target state="translated">이 문제를 해결하려면 다음과 같이 pipe (), fork () 및 open () 형식을 사용하여 한 파일 설명자를 다른 파일 설명 자로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="f205d5425879968b7952a3fb61c2ff97a391a194" translate="yes" xml:space="preserve">
          <source>To sort a hash by value, you'll need to use a &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; function. Here's a descending numeric sort of a hash by its values:</source>
          <target state="translated">값으로 해시를 정렬하려면, 당신은 사용해야합니다 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 기능을. 다음은 값에 따른 내림차순 숫자 해시입니다.</target>
        </trans-unit>
        <trans-unit id="e22346e7b0a650eb196d705609c50726a647e816" translate="yes" xml:space="preserve">
          <source>To sort a hash by value, you'll need to use a &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; function. Here's a descending numeric sort of a hash by its values:</source>
          <target state="translated">값으로 해시를 정렬하려면, 당신은 사용해야합니다 &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 기능을. 다음은 값에 따른 내림차순 숫자 해시입니다.</target>
        </trans-unit>
        <trans-unit id="035b2f73f3e8b156397dc2189e758b10b01a049f" translate="yes" xml:space="preserve">
          <source>To sort a hash, start with the keys. In this example, we give the list of keys to the sort function which then compares them ASCIIbetically (which might be affected by your locale settings). The output list has the keys in ASCIIbetical order. Once we have the keys, we can go through them to create a report which lists the keys in ASCIIbetical order.</source>
          <target state="translated">해시를 정렬하려면 키로 시작하십시오. 이 예에서는 정렬 기능에 키 목록을 제공 한 다음 키를 ASCII 방식으로 비교합니다 (로케일 설정의 영향을받을 수 있음). 출력 목록에는 ASCII 순서의 키가 있습니다. 키가 있으면 키를 ASCII 키 순서로 나열하는 보고서를 작성하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd567593644cab945269478fa56978a3d2bc8799" translate="yes" xml:space="preserve">
          <source>To specify a character by Unicode code point, use the form &lt;code&gt;\N{U+&lt;i&gt;code
point&lt;/i&gt;}&lt;/code&gt;, where</source>
          <target state="translated">유니 코드 코드 포인트로 문자를 지정하려면 &lt;code&gt;\N{U+&lt;i&gt;code point&lt;/i&gt;}&lt;/code&gt; 형식을 사용하십시오 . 여기서</target>
        </trans-unit>
        <trans-unit id="97bdead994a8b1301604dc655e33bb83cb6a1547" translate="yes" xml:space="preserve">
          <source>To specify a compression level when writing, append a digit between 0 and 9 to the mode string -- 0 means no compression and 9 means maximum compression. If no compression level is specified Z_DEFAULT_COMPRESSION is used.</source>
          <target state="translated">쓸 때 압축 수준을 지정하려면 0에서 9 사이의 숫자를 모드 문자열에 추가하십시오. 0은 압축이 없음을 의미하고 9는 최대 압축을 의미합니다. 압축 수준을 지정하지 않으면 Z_DEFAULT_COMPRESSION이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="edce8429b2a3fa7edc3e49d4ca87a0b2294c60e2" translate="yes" xml:space="preserve">
          <source>To specify a particular stack size for any individual thread, call &lt;code&gt;-&amp;gt;create()&lt;/code&gt; with a hash reference as the first argument:</source>
          <target state="translated">개별 스레드에 특정 스택 크기를 지정하려면 첫 번째 인수로 해시 참조를 사용하여 &lt;code&gt;-&amp;gt;create()&lt;/code&gt; 를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="5a3b28c1d56d62a0c685010a78c8616b6f249aaf" translate="yes" xml:space="preserve">
          <source>To specify a real-time timeout, supply the &lt;code&gt;LIFETIME&lt;/code&gt; option with a numeric value. Cached data will expire after this many seconds, and will be looked up afresh when it expires. When a data item is looked up afresh, its lifetime is reset.</source>
          <target state="translated">실시간 시간 초과를 지정하려면 &lt;code&gt;LIFETIME&lt;/code&gt; 옵션에 숫자 값을 제공하십시오. 캐시 된 데이터는 몇 초 후에 만료되며 만료되면 새로 조회됩니다. 데이터 항목을 새로 조회하면 수명이 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="75872cec7b7dae2ec30afbe5f15f62f2ed47906e" translate="yes" xml:space="preserve">
          <source>To specify by name, the name of the character or character sequence goes between the curly braces.</source>
          <target state="translated">이름으로 지정하기 위해 문자 또는 문자 시퀀스의 이름은 중괄호 사이에 있습니다.</target>
        </trans-unit>
        <trans-unit id="e22be0e52c335b1ce8908cd9371ba0e4b96e3022" translate="yes" xml:space="preserve">
          <source>To specify the compression strategy when writing, append 'f' for filtered data, 'h' for Huffman only compression, or 'R' for run-length encoding. If no strategy is specified Z_DEFAULT_STRATEGY is used.</source>
          <target state="translated">쓸 때 압축 전략을 지정하려면 필터링 된 데이터의 경우 'f', 허프만 전용 압축의 경우 'h'또는 실행 길이 인코딩의 경우 'R'을 추가하십시오. 전략을 지정하지 않으면 Z_DEFAULT_STRATEGY가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cb8a391550e8914db81270f773f4523451df8b90" translate="yes" xml:space="preserve">
          <source>To speed things up in complex installation scenarios, CPAN.pm keeps track of what it has already done and refuses to do some things a second time. A &lt;code&gt;get&lt;/code&gt; , a &lt;code&gt;make&lt;/code&gt; , and an &lt;code&gt;install&lt;/code&gt; are not repeated. A &lt;code&gt;test&lt;/code&gt; is repeated only if the previous test was unsuccessful. The diagnostic message when CPAN.pm refuses to do something a second time is one of</source>
          <target state="translated">복잡한 설치 시나리오에서 작업 속도를 높이기 위해 CPAN.pm은 이미 수행 한 작업을 추적하고 두 번째 작업을 거부합니다. &lt;code&gt;get&lt;/code&gt; 하는 &lt;code&gt;make&lt;/code&gt; 가, 그리고 &lt;code&gt;install&lt;/code&gt; 반복되지 않습니다. &lt;code&gt;test&lt;/code&gt; 이전 테스트가 실패한 경우에만 반복됩니다. CPAN.pm이 두 번째로 무언가를 거부하면 진단 메시지는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="ee745e8e1ccd43545cce5d6e1098128c6d2cb42b" translate="yes" xml:space="preserve">
          <source>To split a string automatically, as the</source>
          <target state="translated">다음과 같이 문자열을 자동으로 분할하려면</target>
        </trans-unit>
        <trans-unit id="76a587334bce3d780e4ef5607b4eb7989a44b338" translate="yes" xml:space="preserve">
          <source>To start external programs with complicated command lines (like with pipes in between, and/or quoting of arguments), Perl uses an external shell. With EMX port such shell should be named</source>
          <target state="translated">복잡한 명령 줄을 사용하여 외부 프로그램을 시작하기 위해 (예 : 파이프 사이의 인수 및 / 또는 인수 인용) Perl은 외부 쉘을 사용합니다. EMX 포트를 사용하면 이러한 쉘의 이름을 지정해야합니다</target>
        </trans-unit>
        <trans-unit id="4496b7043de2731c625ff5d9cbb9bfec5778dc82" translate="yes" xml:space="preserve">
          <source>To start perl by clicking on a perl source file, you have to make the according entries in HKCR (see</source>
          <target state="translated">perl 소스 파일을 클릭하여 perl을 시작하려면 HKCR에서 해당 항목을 작성해야합니다 (참조</target>
        </trans-unit>
        <trans-unit id="ed415ca8982026bad9b823bf326a650e9d0848ae" translate="yes" xml:space="preserve">
          <source>To subtract a value from a variable, as in &amp;ldquo;decrement &lt;code&gt;$x&lt;/code&gt; &amp;rdquo; (meaning to remove 1 from its value) or &amp;ldquo;decrement &lt;code&gt;$x&lt;/code&gt; by 3&amp;rdquo;.</source>
          <target state="translated">&amp;ldquo;decrement &lt;code&gt;$x&lt;/code&gt; &amp;rdquo;(값에서 1을 제거하는 것을 의미) 또는&amp;ldquo; &lt;code&gt;$x&lt;/code&gt; by 3을 감소 &amp;rdquo;와 같이 변수에서 값을 빼기 .</target>
        </trans-unit>
        <trans-unit id="c34bd44153421ecb4ee7a84a5cf2f9e94314d16d" translate="yes" xml:space="preserve">
          <source>To summarise:</source>
          <target state="translated">요약하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bdefe539f6f30e5536e03e0dcfcbf06113e55e75" translate="yes" xml:space="preserve">
          <source>To summarize, here are a number of possible methods for you to consider for storing the mapping between C and the Perl callback</source>
          <target state="translated">요약하면, C와 Perl 콜백 사이의 맵핑을 저장하기 위해 고려할 수있는 여러 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="87770a145a86a8f01c504f30ba378126d36ae639" translate="yes" xml:space="preserve">
          <source>To summarize, here's what to expect and how to handle locales in XS code:</source>
          <target state="translated">요약하면 XS 코드에서 로캘을 처리하는 방법과 예상되는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9eda1d19cb3d66414653545444049318272d3717" translate="yes" xml:space="preserve">
          <source>To summarize, the &lt;code&gt;\o{}&lt;/code&gt; form is always safe to use, and the other form is safe to use for code points through \077 when you use exactly three digits to specify them.</source>
          <target state="translated">요약하면, &lt;code&gt;\o{}&lt;/code&gt; 형식은 항상 사용하기에 안전하고 다른 형식은 정확히 세 자리 숫자를 사용하여 지정하는 경우 \ 077까지의 코드 포인트에 사용하기에 안전합니다.</target>
        </trans-unit>
        <trans-unit id="f40c24735c228769cecae3c743dcd1c13b34fed1" translate="yes" xml:space="preserve">
          <source>To summarize, this modifier provides protection for applications that don't wish to be exposed to all of Unicode. Specifying it twice gives added protection.</source>
          <target state="translated">요약하면,이 수정자는 모든 유니 코드에 노출되기를 원하지 않는 응용 프로그램을 보호합니다. 두 번 지정하면 추가 보호 기능이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="8b52f75bf07c40cc3e2dd50eeec591de76cf40c0" translate="yes" xml:space="preserve">
          <source>To support potentially complex type mappings, if a typemap entry used by an XSUB contains a comment like &lt;code&gt;/*scope*/&lt;/code&gt; then scoping will be automatically enabled for that XSUB.</source>
          <target state="translated">잠재적으로 복잡한 유형 매핑을 지원하기 위해 XSUB에서 사용하는 유형 맵 항목에 &lt;code&gt;/*scope*/&lt;/code&gt; 와 같은 주석이 포함되어 있으면 해당 XSUB에 대해 범위 지정이 자동으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="c8462b0ae01f912ec184e35a1a54c294d3db9c0b" translate="yes" xml:space="preserve">
          <source>To support these systems a dl_expandspec() function can be implemented either in the</source>
          <target state="translated">이러한 시스템을 지원하기 위해 dl_expandspec () 함수는</target>
        </trans-unit>
        <trans-unit id="28ae7b79101a8be6ce604e7c61e718194e3e904d" translate="yes" xml:space="preserve">
          <source>To swap pairs of characters in a string (with even length) one could use several techniques. First, let's use &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;X&lt;/code&gt; to skip forward and back:</source>
          <target state="translated">문자열에서 짝수의 문자 쌍을 바꾸려면 여러 가지 기술을 사용할 수 있습니다. 먼저 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;X&lt;/code&gt; 를 사용 하여 앞뒤로 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="52ed4dc484d91fd5d94539987c6af1829eb4d58f" translate="yes" xml:space="preserve">
          <source>To switch back to the default behaviour, use</source>
          <target state="translated">기본 동작으로 다시 전환하려면</target>
        </trans-unit>
        <trans-unit id="9ad4d27e66821295806e39cdf16c87b63c90f1ed" translate="yes" xml:space="preserve">
          <source>To take a closer look at how the engine does optimizations, see the section &lt;a href=&quot;#Pragmas-and-debugging&quot;&gt;Pragmas and debugging&lt;/a&gt; below.</source>
          <target state="translated">엔진이 최적화를 수행하는 방법을 자세히 보려면 아래의 &lt;a href=&quot;#Pragmas-and-debugging&quot;&gt;Pragma 및 디버깅&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f3651fac40bf38f464aae40f7d0973a874e0f3ea" translate="yes" xml:space="preserve">
          <source>To test that your code is behaving correctly and not modifying COW buffers, on systems that support</source>
          <target state="translated">지원하는 시스템에서 코드가 올바르게 작동하고 COW 버퍼를 수정하지 않는지 테스트하려면</target>
        </trans-unit>
        <trans-unit id="8ce0bdd874392ab18a8e9a217e048b7e9971ae31" translate="yes" xml:space="preserve">
          <source>To test whether a variable contains tainted data, and whose use would thus trigger an &quot;Insecure dependency&quot; message, you can use the &lt;code&gt;tainted()&lt;/code&gt; function of the Scalar::Util module, available in your nearby CPAN mirror, and included in Perl starting from the release 5.8.0. Or you may be able to use the following &lt;code&gt;is_tainted()&lt;/code&gt; function.</source>
          <target state="translated">변수에 오염 된 데이터가 포함되어 있고 그 사용으로 인해 &quot;안전하지 않은 종속성&quot;메시지가 트리거되는지 테스트하려면 근처 CPAN 미러에서 사용 가능하고 Perl 시작에 포함 된 Scalar :: Util 모듈 의 &lt;code&gt;tainted()&lt;/code&gt; 함수를 사용할 수 있습니다 릴리스 5.8.0부터. 또는 다음 &lt;code&gt;is_tainted()&lt;/code&gt; 함수 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="521a49c8c35183a9a627a2f63a5d516c8a7cf5ba" translate="yes" xml:space="preserve">
          <source>To the Perl program that called fork(), all this is designed to be transparent. The parent returns from the fork() with a pseudo-process ID that can be subsequently used in any process-manipulation functions; the child returns from the fork() with a value of &lt;code&gt;0&lt;/code&gt; to signify that it is the child pseudo-process.</source>
          <target state="translated">fork ()를 호출 한 Perl 프로그램에는이 모든 것이 투명하게 설계되었습니다. 부모는 모든 프로세스 조작 함수에서 나중에 사용할 수있는 의사 프로세스 ID로 fork ()에서 리턴합니다. 자식은 값이 &lt;code&gt;0&lt;/code&gt; 인 fork ()에서 반환되어 자식 의사 프로세스임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c7e05b4fcf627d6e6c4197f19ffda73a879c664a" translate="yes" xml:space="preserve">
          <source>To the best of our ability, we will attempt to fix critical issues in the two most recent stable 5.x release series. Fixes for the current release series take precedence over fixes for the previous release series.</source>
          <target state="translated">우리의 능력을 최대한 발휘하기 위해 가장 안정적인 두 가지 최신 5.x 릴리스 시리즈에서 중요한 문제를 해결하려고 시도합니다. 현재 릴리스 시리즈의 수정 사항이 이전 릴리스 시리즈의 수정 사항보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="51a0f8c69bc4919eb0f20691df0fe50a577785df" translate="yes" xml:space="preserve">
          <source>To the best of our ability, we will provide &quot;critical&quot; security patches / releases for any major version of Perl whose 5.x.0 release was within the past three years. We can only commit to providing these for the most recent .y release in any 5.x.y series.</source>
          <target state="translated">우리의 능력을 최대한 발휘하기 위해 우리는 5.x.0 릴리스가 지난 3 년 이내 인 모든 주요 Perl 버전에 대해 &quot;중요한&quot;보안 패치 / 릴리스를 제공 할 것입니다. 우리는 5.xy 시리즈에서 가장 최근의 .y 릴리즈에 이것들을 제공 할 것을 약속 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fa12fa0dac95b52f8a74aca03b7455d8e9dea13" translate="yes" xml:space="preserve">
          <source>To throw away the current &lt;b&gt;process&lt;/b&gt;&amp;rsquo;s program and replace it with another, without exiting the process or relinquishing any resources held (apart from the old memory image).</source>
          <target state="translated">현재 &lt;b&gt;프로세스&lt;/b&gt; 의 프로그램 을 버리고 &lt;b&gt;프로세스&lt;/b&gt; 를 종료하거나 기존 메모리 이미지를 제외하고 보유한 리소스를 포기하지 않고 다른 &lt;b&gt;프로세스로&lt;/b&gt; 교체합니다.</target>
        </trans-unit>
        <trans-unit id="448a61a17f3cda496b5d3ba49da88ff7c85062ed" translate="yes" xml:space="preserve">
          <source>To transform a bit vector into a string or list of 0's and 1's, use these:</source>
          <target state="translated">비트 벡터를 문자열 또는 0과 1의 목록으로 변환하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8d6d675a384b336013b57ff889fd3d31ada57c0a" translate="yes" xml:space="preserve">
          <source>To trim trailing newlines from text lines use &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt;. With default settings that function looks for a trailing &lt;code&gt;\n&lt;/code&gt; character and thus trims in a portable way.</source>
          <target state="translated">텍스트 줄에서 줄 바꿈 줄을 자르려면 &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt; . 기본 설정을 사용하면이 기능은 후행 &lt;code&gt;\n&lt;/code&gt; 문자를 찾아 휴대가 용이합니다.</target>
        </trans-unit>
        <trans-unit id="40f27a2565b48c1f61edc1951aa27946b5ec4637" translate="yes" xml:space="preserve">
          <source>To turn a hostname into a human-readable plain IP address use getaddrinfo() to turn the hostname into a list of socket structures, then getnameinfo() on each one to make it a readable IP address again.</source>
          <target state="translated">호스트 이름을 사람이 읽을 수있는 일반 IP 주소로 바꾸려면 getaddrinfo ()를 사용하여 호스트 이름을 소켓 구조 목록으로 바꾸고 각 호스트에서 getnameinfo ()를 사용하여 다시 읽을 수있는 IP 주소로 만드십시오.</target>
        </trans-unit>
        <trans-unit id="f7838aca863be2066e77c33f9ec760e481423363" translate="yes" xml:space="preserve">
          <source>To turn one string representation into another by mapping each character of the source string to its corresponding character in the result string. Not to be confused with translation: for example, Greek</source>
          <target state="translated">소스 문자열의 각 문자를 결과 문자열의 해당 문자에 매핑하여 한 문자열 표현을 다른 문자열 표현으로 변환합니다. 번역과 혼동하지 말 것 : 예 : 그리스어</target>
        </trans-unit>
        <trans-unit id="2796f222a72ab401559f8c49bff573c8aee5f84f" translate="yes" xml:space="preserve">
          <source>To unambiguously refer to the built-in form, precede the built-in name with the special package qualifier &lt;code&gt;CORE::&lt;/code&gt; . For example, saying &lt;code&gt;CORE::open()&lt;/code&gt; always refers to the built-in &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, even if the current package has imported some other subroutine called &lt;code&gt;&amp;amp;open()&lt;/code&gt; from elsewhere. Even though it looks like a regular function call, it isn't: the CORE:: prefix in that case is part of Perl's syntax, and works for any keyword, regardless of what is in the CORE package. Taking a reference to it, that is, &lt;code&gt;\&amp;amp;CORE::open&lt;/code&gt; , only works for some keywords. See &lt;a href=&quot;core&quot;&gt;CORE&lt;/a&gt;.</source>
          <target state="translated">내장 양식을 명확하게 참조하려면 내장 패키지 이름 앞에 특수 패키지 규정 자 &lt;code&gt;CORE::&lt;/code&gt; . 예를 들어, 말 &lt;code&gt;CORE::open()&lt;/code&gt; 항상 참조하는 내장 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; , 현재 패키지라는 다른 서브 루틴 가져올 경우에도 &lt;code&gt;&amp;amp;open()&lt;/code&gt; 다른 곳에서합니다. 일반적인 함수 호출처럼 보이지만 그렇지는 않습니다.이 경우 CORE :: 접두사는 Perl 구문의 일부이며 CORE 패키지의 내용에 관계없이 모든 키워드에 대해 작동합니다. 이를 참조하면 &lt;code&gt;\&amp;amp;CORE::open&lt;/code&gt; 은 일부 키워드에서만 작동합니다. &lt;a href=&quot;core&quot;&gt;핵심을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="248423c43b116b150a001ee976cc646676062436" translate="yes" xml:space="preserve">
          <source>To uncompress</source>
          <target state="translated">압축을 풀려면</target>
        </trans-unit>
        <trans-unit id="218af45982210497e46e853ffef0192283629105" translate="yes" xml:space="preserve">
          <source>To uncompress all files in the directory &quot;/my/home&quot; that match &quot;*.txt.1950&quot; and store the compressed data in the same directory</source>
          <target state="translated">&quot;* .txt.1950&quot;과 일치하는 &quot;/ my / home&quot;디렉토리의 모든 파일을 압축 해제하고 압축 된 데이터를 동일한 디렉토리에 저장하려면</target>
        </trans-unit>
        <trans-unit id="5ddcb357cfd2b7762051e66890c8b84e7d960611" translate="yes" xml:space="preserve">
          <source>To uncompress all files in the directory &quot;/my/home&quot; that match &quot;*.txt.1951&quot; and store the compressed data in the same directory</source>
          <target state="translated">&quot;* .txt.1951&quot;과 일치하는 &quot;/ my / home&quot;디렉토리의 모든 파일을 압축 해제하고 압축 된 데이터를 동일한 디렉토리에 저장하려면</target>
        </trans-unit>
        <trans-unit id="0e932ba5dc24bfd784757a246bd08027f46d4625" translate="yes" xml:space="preserve">
          <source>To uncompress all files in the directory &quot;/my/home&quot; that match &quot;*.txt.Compressed&quot; and store the compressed data in the same directory</source>
          <target state="translated">&quot;* .txt.Compressed&quot;와 일치하는 &quot;/ my / home&quot;디렉토리의 모든 파일을 압축 해제하고 압축 된 데이터를 동일한 디렉토리에 저장하려면</target>
        </trans-unit>
        <trans-unit id="29a087f9cfa51d4e0c2f6a475a11f449e63412aa" translate="yes" xml:space="preserve">
          <source>To uncompress all files in the directory &quot;/my/home&quot; that match &quot;*.txt.bz2&quot; and store the compressed data in the same directory</source>
          <target state="translated">&quot;* .txt.bz2&quot;와 일치하는 &quot;/ my / home&quot;디렉토리의 모든 파일을 압축 해제하고 압축 된 데이터를 동일한 디렉토리에 저장하려면</target>
        </trans-unit>
        <trans-unit id="61aa1a4650d4e1d7c6939abfa456f5aeb3345d9a" translate="yes" xml:space="preserve">
          <source>To uncompress all files in the directory &quot;/my/home&quot; that match &quot;*.txt.gz&quot; and store the compressed data in the same directory</source>
          <target state="translated">&quot;* .txt.gz&quot;와 일치하는 &quot;/ my / home&quot;디렉토리의 모든 파일을 압축 해제하고 압축 된 데이터를 동일한 디렉토리에 저장하려면</target>
        </trans-unit>
        <trans-unit id="2754edb3f14d19ed8eebfcca373f83ac4a3282e7" translate="yes" xml:space="preserve">
          <source>To uncompress an RFC 1950 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to a positive number between 8 and 15.</source>
          <target state="translated">RFC 1950 데이터 스트림을 압축 해제하려면 &lt;code&gt;WindowBits&lt;/code&gt; 를 8과 15 사이의 양수로 설정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="44083e3f2b591fd2c77505655cdb2c8f0aceb349" translate="yes" xml:space="preserve">
          <source>To uncompress an RFC 1950 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to a positive number.</source>
          <target state="translated">RFC 1950 데이터 스트림을 압축 해제하려면 &lt;code&gt;WindowBits&lt;/code&gt; 를 양수로 설정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ceb9d1b68954b1740a461cdcd4976b0e567a28d9" translate="yes" xml:space="preserve">
          <source>To uncompress an RFC 1951 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;-MAX_WBITS&lt;/code&gt; .</source>
          <target state="translated">RFC 1951 데이터 스트림을 압축 해제하려면 &lt;code&gt;WindowBits&lt;/code&gt; 를 &lt;code&gt;-MAX_WBITS&lt;/code&gt; 로 설정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="42e613bd86be8bd3cb751a2f5e9d0b238c337e5e" translate="yes" xml:space="preserve">
          <source>To uncompress an RFC 1952 data stream (i.e. gzip), set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;WANT_GZIP&lt;/code&gt; .</source>
          <target state="translated">RFC 1952 데이터 스트림 (예 : gzip)을 압축 해제하려면 &lt;code&gt;WindowBits&lt;/code&gt; 를 &lt;code&gt;WANT_GZIP&lt;/code&gt; 로 설정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="be309868d7c608c972ac92d2374d84d68bbcff87" translate="yes" xml:space="preserve">
          <source>To understand what kinds of incompatibilities one may expect, and in the rare case that the version of Perl on your machine is older than this document, see the section on &quot;Troubleshooting these Examples&quot; for more information.</source>
          <target state="translated">어떤 종류의 비 호환성을 예상 할 수 있으며 드문 경우이지만 컴퓨터의 Perl 버전이이 문서보다 오래된 경우 자세한 내용은 &quot;이 예제 문제 해결&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6b79315e2daa0488ef5b85ec7b3ded4c1bf9ff5d" translate="yes" xml:space="preserve">
          <source>To understand what the above</source>
          <target state="translated">위의 내용을 이해하려면</target>
        </trans-unit>
        <trans-unit id="84e6e80a4aa5a302f6ddaa79d242cdcf126f821b" translate="yes" xml:space="preserve">
          <source>To uppercase or lowercase several characters, one might want to use &lt;code&gt;\L&lt;/code&gt; or &lt;code&gt;\U&lt;/code&gt; , which will lowercase/uppercase all characters following them, until either the end of the pattern or the next occurrence of &lt;code&gt;\E&lt;/code&gt; , whichever comes first. They provide functionality similar to what the functions &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;&lt;/code&gt; provide.</source>
          <target state="translated">여러 문자를 대문자 또는 소문자로 사용하려면 &lt;code&gt;\L&lt;/code&gt; 또는 &lt;code&gt;\U&lt;/code&gt; 를 사용 하여 패턴의 끝이나 다음에 나오는 &lt;code&gt;\E&lt;/code&gt; 중 가장 먼저 나오는 문자까지 소문자 / 대문자를 사용합니다 . &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;&lt;/code&gt; 기능과 유사한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fd3b3ccd26f316b1795adeb89ffff2bedd268ce6" translate="yes" xml:space="preserve">
          <source>To use 'load_remote' or 'autoload_remote', specify at 'use'.</source>
          <target state="translated">'load_remote'또는 'autoload_remote'를 사용하려면 'use'에 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="8a5610b8c5bc5858528e5c0711e8cd5aeeeaeb22" translate="yes" xml:space="preserve">
          <source>To use &lt;b&gt;AutoLoader&lt;/b&gt;, the author of a module has to place the definitions of subroutines to be autoloaded after an &lt;code&gt;__END__&lt;/code&gt; token. (See &lt;a href=&quot;perldata&quot;&gt;perldata&lt;/a&gt;.) The &lt;b&gt;AutoSplit&lt;/b&gt; module can then be run manually to extract the definitions into individual files</source>
          <target state="translated">&lt;b&gt;AutoLoader&lt;/b&gt; 를 사용하려면 모듈 작성자가 &lt;code&gt;__END__&lt;/code&gt; 토큰 다음에 자동로드 할 서브 루틴의 정의를 배치해야합니다 . ( &lt;a href=&quot;perldata&quot;&gt;perldata&lt;/a&gt; 참조 ) 그런 다음 &lt;b&gt;AutoSplit&lt;/b&gt; 모듈을 수동으로 실행하여 정의를 개별 파일로 추출 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="d246c1b4a8c6fc55969eb14bc150616f75299064" translate="yes" xml:space="preserve">
          <source>To use Getopt::Long from a Perl program, you must include the following line in your Perl program:</source>
          <target state="translated">Perl 프로그램에서 Getopt :: Long을 사용하려면 Perl 프로그램에 다음 행을 포함시켜야합니다.</target>
        </trans-unit>
        <trans-unit id="6a708529644756357339b6bd4e7ce1cb0f6dc3ee" translate="yes" xml:space="preserve">
          <source>To use a here-document to assign an array, one line per element, you might use an approach like this:</source>
          <target state="translated">here-document를 사용하여 요소 당 한 줄씩 배열을 할당하려면 다음과 같은 접근법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d339f8f2813eea011c2650e8b1ed1fdac84e3d1c" translate="yes" xml:space="preserve">
          <source>To use a lexical subroutine from inside the subroutine itself, you must predeclare it. The &lt;code&gt;sub foo {...}&lt;/code&gt; subroutine definition syntax respects any previous &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; &lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;;&lt;/code&gt; or &lt;code&gt;state &lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;;&lt;/code&gt; declaration.</source>
          <target state="translated">서브 루틴 자체 내에서 어휘 서브 루틴을 사용하려면 미리 선언해야합니다. &lt;code&gt;sub foo {...}&lt;/code&gt; 서브 루틴 정의 구문면 이전의 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; &lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;;&lt;/code&gt; 또는 &lt;code&gt;state &lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;;&lt;/code&gt; 선언.</target>
        </trans-unit>
        <trans-unit id="0a6c22616496274a8c0483ef0b81201680edefba" translate="yes" xml:space="preserve">
          <source>To use in your program as a pragma, merely invoke</source>
          <target state="translated">프로그램에서 pragma로 사용하려면 다음을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="c9702d448044d584ba0f08cf12e0416ad038a1b6" translate="yes" xml:space="preserve">
          <source>To use it more practically, you have to give the names of encodings to check (</source>
          <target state="translated">보다 실용적으로 사용하려면 확인할 인코딩 이름을 지정해야합니다 (</target>
        </trans-unit>
        <trans-unit id="22588255917f935bc82a9b5e6907a6c5af5e0773" translate="yes" xml:space="preserve">
          <source>To use the OVERLOAD: keyword, create an XS function which takes three input parameters ( or use the c style '...' definition) like this:</source>
          <target state="translated">OVERLOAD : 키워드를 사용하려면 다음과 같이 3 개의 입력 매개 변수를 사용하거나 c 스타일 '...'정의를 사용하는 XS 함수를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="3dc634fc1f1bc1b5d00fde6bff6b384f2eeb3f97" translate="yes" xml:space="preserve">
          <source>To use the Perl you just installed you will need to add a new entry to your PATH environment variable: &lt;code&gt;$INST_TOP\bin&lt;/code&gt; , e.g.</source>
          <target state="translated">: 펄을 사용하려면 당신은 당신이 당신의 PATH 환경 변수에 새 항목을 추가해야합니다 설치 &lt;code&gt;$INST_TOP\bin&lt;/code&gt; , 예를 들어,</target>
        </trans-unit>
        <trans-unit id="7bc829cf0e8a5c97f97a31b7c617e9428478c19b" translate="yes" xml:space="preserve">
          <source>To use the forked debugger, you need to have the default display set to an X-11 Server and some environment variables set that Unix expects.</source>
          <target state="translated">분기 된 디버거를 사용하려면 기본 디스플레이를 X-11 서버로 설정하고 일부 환경 변수를 Unix에서 예상해야합니다.</target>
        </trans-unit>
        <trans-unit id="fc207fecfdae515e813f72872e49086f5b78c28e" translate="yes" xml:space="preserve">
          <source>To use the module it is necessary to do the following:</source>
          <target state="translated">모듈을 사용하려면 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="dd4bd0185af39ed243608e8976fc475a01dc61d4" translate="yes" xml:space="preserve">
          <source>To use this expiration policy, the user would say</source>
          <target state="translated">이 만료 정책을 사용하기 위해 사용자는</target>
        </trans-unit>
        <trans-unit id="538ca1c3044001d3cfa088cc4be7d0f4954981d6" translate="yes" xml:space="preserve">
          <source>To use this method you must have the Digest::MD5 or the MD5 module installed, otherwise this method will return</source>
          <target state="translated">이 방법을 사용하려면 Digest :: MD5 또는 MD5 모듈이 설치되어 있어야합니다. 그렇지 않으면이 방법이</target>
        </trans-unit>
        <trans-unit id="b3ee11508a4f000324b572266622a1fcc5b08715" translate="yes" xml:space="preserve">
          <source>To use this performance boost, set the current directory via</source>
          <target state="translated">이 성능 향상을 사용하려면 다음을 통해 현재 디렉토리를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="38c026c273aff885d8062765e295cb0676868f0f" translate="yes" xml:space="preserve">
          <source>To warn with a simple string message, the &lt;a href=&quot;#warn&quot;&gt;warn&lt;/a&gt; function may be more convenient.</source>
          <target state="translated">간단한 문자열 메시지로 &lt;a href=&quot;#warn&quot;&gt;경고&lt;/a&gt; 하려면 경고 기능이 더 편리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="be15e0c4892f05af6b92d2d4a6be1a0a5f9a6dcd" translate="yes" xml:space="preserve">
          <source>To watch the tail of a dynamically growing logfile, (from the command line):</source>
          <target state="translated">동적으로 증가하는 로그 파일의 꼬리를 보려면 (명령 줄에서) :</target>
        </trans-unit>
        <trans-unit id="a70297b48e7206cae4fcb0090dd44f6d0f3207a8" translate="yes" xml:space="preserve">
          <source>To work around this bug, surround the code with a second set of braces. This creates an inner block that defeats the &lt;code&gt;MULTICALL&lt;/code&gt; logic, and does get fresh SVs allocated each time:</source>
          <target state="translated">이 버그를 해결하려면 코드를 두 번째 중괄호로 묶습니다. 이것은 &lt;code&gt;MULTICALL&lt;/code&gt; 논리 를 물리 치는 매번 내부 블록을 생성하고 매번 새로운 SV를 할당합니다 :</target>
        </trans-unit>
        <trans-unit id="df77a0e9f9993c56d24066721ca0f8c51a0345d4" translate="yes" xml:space="preserve">
          <source>To work around this, set environment variables as part of the</source>
          <target state="translated">이 문제를 해결하려면 환경 변수를</target>
        </trans-unit>
        <trans-unit id="67bc56a45c2b844733bf04f643db3f4d6359ddb1" translate="yes" xml:space="preserve">
          <source>To work with only alphanumeric sequences (including underscores), you might consider</source>
          <target state="translated">영숫자 시퀀스 (밑줄 포함)로만 작업하려면 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="737fcabd51bb1faacb7059e47b96e0c587be8c5f" translate="yes" xml:space="preserve">
          <source>To write a test for your new (and probably not even done) module, create a new file called</source>
          <target state="translated">새로운 모듈에 대한 테스트를 작성하려면 (아마도 수행되지 않은) 모듈을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="02bfda7919e7b9ec9d9ea9a01639287be236928c" translate="yes" xml:space="preserve">
          <source>To write platform-independent code, you must use &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt; instead, like &lt;code&gt;\N{ESCAPE}&lt;/code&gt; or &lt;code&gt;\N{U+001B}&lt;/code&gt; , see &lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt;.</source>
          <target state="translated">쓰기 플랫폼 독립적 인 코드하려면 사용합니다 &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt; 대신, 같은 &lt;code&gt;\N{ESCAPE}&lt;/code&gt; 또는 &lt;code&gt;\N{U+001B}&lt;/code&gt; 참조 &lt;a href=&quot;charnames&quot;&gt;charnames을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="32379df686c78a3422056dcfb4c9b1da18747d64" translate="yes" xml:space="preserve">
          <source>To yield a usable Perl variable, characters that are not part of the syntax for variables are translated to underscores. For example, &lt;code&gt;--fpp-struct-&lt;a href=&quot;../functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; will set the variable &lt;code&gt;$opt_fpp_struct_return&lt;/code&gt; . Note that this variable resides in the namespace of the calling program, not necessarily &lt;code&gt;main&lt;/code&gt; . For example:</source>
          <target state="translated">사용 가능한 Perl 변수를 생성하기 위해 변수 구문의 일부가 아닌 문자는 밑줄로 변환됩니다. 예를 들어 &lt;code&gt;--fpp-struct-&lt;a href=&quot;../functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;$opt_fpp_struct_return&lt;/code&gt; 변수를 설정합니다 . 이 변수는 반드시 &lt;code&gt;main&lt;/code&gt; 이 아니라 호출 프로그램의 네임 스페이스에 상주합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="33224443be18843a7174975c46578d74787bc749" translate="yes" xml:space="preserve">
          <source>Tobias Brox, tobiasb@tobiasb.funcom.com</source>
          <target state="translated">토비아스 브록 스, tobiasb@tobiasb.funcom.com</target>
        </trans-unit>
        <trans-unit id="ec7a57e5883d57c428d8e15819e5060eeed56435" translate="yes" xml:space="preserve">
          <source>Together, these categories go a long way towards being able to customize a single program to run in many different locations. But there are deficiencies, so keep reading.</source>
          <target state="translated">이러한 범주를 함께 사용하면 단일 프로그램을 여러 위치에서 실행하도록 사용자 정의 할 수 있습니다. 그러나 결함이 있으므로 계속 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="6f1eb05b47fbf56bdd9586b2ff6beeffab4ce59f" translate="yes" xml:space="preserve">
          <source>Together, these two features are intended to replace the historical &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; function, which has (at least) two bugs in it, that cannot easily be fixed without breaking existing programs:</source>
          <target state="translated">이 두 기능은 함께 기존 프로그램을 깨지 않고 쉽게 고칠 수없는 적어도 두 개의 버그가 있는 과거 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 기능 을 대체하기위한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="5379fd6502d08f80951bb93415834c8443e36cd5" translate="yes" xml:space="preserve">
          <source>Toggle trace mode (see also the &lt;code&gt;AutoTrace&lt;/code&gt; option). Optional argument is the maximum number of levels to trace below the current one; anything deeper than that will be silent.</source>
          <target state="translated">추적 모드 토글 (또한 참조 &lt;code&gt;AutoTrace&lt;/code&gt; 옵션을). 선택적 인수는 현재 레벨 아래에서 추적 할 최대 레벨 수입니다. 그보다 더 깊은 것은 침묵 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="f422da5828ccca294dcf6d07ee5efb74761f28a1" translate="yes" xml:space="preserve">
          <source>Tokens from Pod::Simple::PullParser</source>
          <target state="translated">포드 :: Simple :: PullParser의 토큰</target>
        </trans-unit>
        <trans-unit id="685cbbd2434336a1c0d592cb5e469ec23061ee59" translate="yes" xml:space="preserve">
          <source>Tom Christiansen</source>
          <target state="translated">톰 크리스티안 슨</target>
        </trans-unit>
        <trans-unit id="8be2aa955349ba9da124a5ab00db7e6f88ee861a" translate="yes" xml:space="preserve">
          <source>Tom Christiansen &amp;lt;</source>
          <target state="translated">톰 크리스티안 슨 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="5ca9f204e050f14afeeca056eec19f3529541293" translate="yes" xml:space="preserve">
          <source>Tom Christiansen &amp;lt;tchrist@perl.com&amp;gt; wrote this, with occasional kibbitzing from Larry Wall and Jeffrey Friedl in the background.</source>
          <target state="translated">Tom Christiansen &amp;lt;tchrist@perl.com&amp;gt;은 Larry Wall과 Jeffrey Friedl의 백그라운드에서 가끔씩 kibbitzing하여 이것을 썼습니다.</target>
        </trans-unit>
        <trans-unit id="8e134c4a6e79e76b0db622556fcf6a08eb055742" translate="yes" xml:space="preserve">
          <source>Tom Christiansen wrote the original perlfaq then expanded it with the help of Nat Torkington. brian d foy substantially edited and expanded the perlfaq. perlfaq-workers and others have also supplied feedback, patches and corrections over the years.</source>
          <target state="translated">Tom Christiansen은 원래 perlfaq을 작성한 다음 Nat Torkington의 도움으로 확장했습니다. brian d foy는 실질적으로 perlfaq을 편집하고 확장했습니다. perlfaq-workers 및 기타 사람들은 수년 동안 피드백, 패치 및 수정 사항을 제공했습니다.</target>
        </trans-unit>
        <trans-unit id="13f0322dc66b8435d53d03e97ab3bdb9a5e08c67" translate="yes" xml:space="preserve">
          <source>Tom Christiansen wrote the original version of this document. brian d foy &lt;code&gt;&amp;lt;bdfoy@cpan.org&amp;gt;&lt;/code&gt; wrote this version. See the individual perlfaq documents for additional copyright information.</source>
          <target state="translated">Tom Christiansen은이 문서의 원본을 썼습니다. brian d foy &lt;code&gt;&amp;lt;bdfoy@cpan.org&amp;gt;&lt;/code&gt; 가이 버전을 썼습니다. 추가 저작권 정보는 개별 perlfaq 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="594631f752605ca51961fa701a3edb58acb263cd" translate="yes" xml:space="preserve">
          <source>Tom Christiansen, &amp;lt;tchrist@perl.com&amp;gt;.</source>
          <target state="translated">Tom Christiansen, &amp;lt;tchrist@perl.com&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="95a03ceecd01437e5e0609dbfa8dc64983a0ce69" translate="yes" xml:space="preserve">
          <source>Tom Christiansen, with occasional vestiges of Larry Wall's original version and suggestions from the Perl Porters.</source>
          <target state="translated">Tom Christiansen, Larry Wall의 원본 버전과 Perl Porters의 제안을 간혹 제공합니다.</target>
        </trans-unit>
        <trans-unit id="476ccb2f91007a71136d530d51755067de803643" translate="yes" xml:space="preserve">
          <source>Tom Phoenix, &amp;lt;</source>
          <target state="translated">톰 피닉스, &amp;lt;</target>
        </trans-unit>
        <trans-unit id="ba42647932e0b5434947f286f404459ce1a76e83" translate="yes" xml:space="preserve">
          <source>Too few records will be retrieved.</source>
          <target state="translated">검색 할 레코드가 너무 적습니다.</target>
        </trans-unit>
        <trans-unit id="0f85c6fbc6b17f4b329c823a126de114fb51f097" translate="yes" xml:space="preserve">
          <source>Too many will be retrieved.</source>
          <target state="translated">너무 많이 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="4fa8cc860c52b268dc6a3adcde7305e9415db5bb" translate="yes" xml:space="preserve">
          <source>Tools</source>
          <target state="translated">Tools</target>
        </trans-unit>
        <trans-unit id="2f4169d30e0802a9d8a3d39c5549f0963dd393e1" translate="yes" xml:space="preserve">
          <source>Tools &amp;amp; SDK</source>
          <target state="translated">도구 및 SDK</target>
        </trans-unit>
        <trans-unit id="a00a8f35172e2849241ce00e52e7b7a9a0047d25" translate="yes" xml:space="preserve">
          <source>Top of Form Processing</source>
          <target state="translated">양식 처리 상단</target>
        </trans-unit>
        <trans-unit id="ee80479b0fa9a2d2efdf0ff5851a9a2f37c4056d" translate="yes" xml:space="preserve">
          <source>Top of form processing is handled automatically: if there is insufficient room on the current page for the formatted record, the page is advanced by writing a form feed and a special top-of-page format is used to format the new page header before the record is written. By default, the top-of-page format is the name of the filehandle with &quot;_TOP&quot; appended, or &quot;top&quot; in the current package if the former does not exist. This would be a problem with autovivified filehandles, but it may be dynamically set to the format of your choice by assigning the name to the &lt;code&gt;$^&lt;/code&gt; variable while that filehandle is selected. The number of lines remaining on the current page is in variable &lt;code&gt;$-&lt;/code&gt; , which can be set to &lt;code&gt;0&lt;/code&gt; to force a new page.</source>
          <target state="translated">양식 맨 위 처리가 자동으로 처리됩니다. 현재 페이지에 형식화 된 레코드를위한 공간이 부족한 경우 양식 피드를 작성하여 페이지가 진행되고 특수 페이지 맨 위 형식이 새 페이지 머리글을 형식화하기 위해 사용됩니다. 기록이 작성됩니다. 기본적으로 페이지 상단 형식은 &quot;_TOP&quot;가 추가 된 파일 핸들의 이름이거나 전자 패키지가없는 경우 현재 패키지에서 &quot;top&quot;입니다. 이는 자동 활성화 된 파일 핸들에 문제가 될 수 있지만 해당 파일 핸들을 선택한 상태 에서 &lt;code&gt;$^&lt;/code&gt; 변수에 이름을 지정하여 선택한 형식으로 동적으로 설정 될 수 있습니다 . 현재 페이지에 남아있는 줄 수는 변수 &lt;code&gt;$-&lt;/code&gt; 에 있으며 새 페이지를 강제 실행 하기 위해 &lt;code&gt;0&lt;/code&gt; 으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9d8d0feb3edb0eff1e9ffe23486e4f54336c8d4e" translate="yes" xml:space="preserve">
          <source>Top-of-form processing is by default handled by a format with the same name as the current filehandle with &quot;_TOP&quot; concatenated to it. It's triggered at the top of each page. See &lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;.</source>
          <target state="translated">최상위 양식 처리는 기본적으로 &quot;_TOP&quot;이 연결된 현재 파일 핸들과 이름이 같은 형식으로 처리됩니다. 각 페이지 상단에서 트리거됩니다. &lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="855b740deb0e234d1668b8ec10c825eb8a3450f0" translate="yes" xml:space="preserve">
          <source>Total CPU (User + System) of any children processes.</source>
          <target state="translated">모든 하위 프로세스의 총 CPU (사용자 + 시스템)</target>
        </trans-unit>
        <trans-unit id="3481164ed61c4f3a7713de67224c54bcab0e71f6" translate="yes" xml:space="preserve">
          <source>Total CPU (User + System) of the main (parent) process.</source>
          <target state="translated">기본 (부모) 프로세스의 총 CPU (사용자 + 시스템)</target>
        </trans-unit>
        <trans-unit id="1e2c196e8d42960075bf83565f85bd785a488f4c" translate="yes" xml:space="preserve">
          <source>Total CPU of parent and any children processes.</source>
          <target state="translated">상위 및 모든 하위 프로세스의 총 CPU</target>
        </trans-unit>
        <trans-unit id="4b32a7b148f732eb014244c4bbbcbbea6216c149" translate="yes" xml:space="preserve">
          <source>Trace mode (similar to &lt;code&gt;t&lt;/code&gt; command, but can be put into &lt;code&gt;PERLDB_OPTS&lt;/code&gt; ).</source>
          <target state="translated">추적 모드 ( &lt;code&gt;t&lt;/code&gt; 명령 과 유사 하지만 &lt;code&gt;PERLDB_OPTS&lt;/code&gt; 에 넣을 수 있음 )</target>
        </trans-unit>
        <trans-unit id="4d8c4db1a294c0162454110ac7c8472297017033" translate="yes" xml:space="preserve">
          <source>Trace through execution of &lt;code&gt;expr&lt;/code&gt; . Optional first argument is the maximum number of levels to trace below the current one; anything deeper than that will be silent. See &lt;a href=&quot;perldebguts#Frame-Listing-Output-Examples&quot;&gt;Frame Listing Output Examples in perldebguts&lt;/a&gt; for examples.</source>
          <target state="translated">&lt;code&gt;expr&lt;/code&gt; 실행을 통해 추적합니다 . 선택적인 첫 번째 인수는 현재 수준 아래에서 추적 할 최대 수준 수입니다. 그보다 더 깊은 것은 침묵 할 것입니다. &lt;a href=&quot;perldebguts#Frame-Listing-Output-Examples&quot;&gt;예제는 perldebguts의 프레임 목록 출력 예제를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="24be5dbb481a63442832782f4da3ef4f0dc024ff" translate="yes" xml:space="preserve">
          <source>Trace variable used when Perl is run in debugging mode, with the &lt;b&gt;-d&lt;/b&gt; switch. This is the C variable which corresponds to Perl's $DB::trace variable. See &lt;code&gt;PL_DBsingle&lt;/code&gt; .</source>
          <target state="translated">Perl이 &lt;b&gt;-d&lt;/b&gt; 스위치 와 함께 디버깅 모드에서 실행될 때 사용되는 추적 변수 입니다. 이것은 Perl의 $ DB :: trace 변수에 해당하는 C 변수입니다. &lt;code&gt;PL_DBsingle&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="411aea8f76aef96f5e36c8b291c19e9ceb9466d1" translate="yes" xml:space="preserve">
          <source>Traces changes to Perl's interpreter state. You can internalize this as tracing changes to Perl's &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; variable, especially since the values for &lt;code&gt;NEWPHASE&lt;/code&gt; and &lt;code&gt;OLDPHASE&lt;/code&gt; are the strings that &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; reports.</source>
          <target state="translated">Perl의 인터프리터 상태에 대한 변경 사항을 추적합니다. 특히 &lt;code&gt;NEWPHASE&lt;/code&gt; 및 &lt;code&gt;OLDPHASE&lt;/code&gt; 의 값 이 &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; 가보고 하는 문자열 이므로 Perl의 &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; 변수에 대한 변경 내용 추적으로이를 내재화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0786ec1507cde8f738cd5528e03a2b67d40c8c91" translate="yes" xml:space="preserve">
          <source>Traces the entry of any subroutine. Note that all of the variables refer to the subroutine that is being invoked; there is currently no way to get ahold of any information about the subroutine's</source>
          <target state="translated">서브 루틴의 항목을 추적합니다. 모든 변수는 호출되는 서브 루틴을 나타냅니다. 현재 서브 루틴에 대한 정보를 얻을 수있는 방법이 없습니다</target>
        </trans-unit>
        <trans-unit id="9f47af59eb569759ff1e8a42a52da14fba8b1705" translate="yes" xml:space="preserve">
          <source>Traces the execution of each opcode in the Perl runloop. This probe is fired before the opcode is executed. When the Perl debugger is enabled, the DTrace probe is fired</source>
          <target state="translated">Perl runloop에서 각 opcode의 실행을 추적합니다. 이 프로브는 opcode가 실행되기 전에 시작됩니다. Perl 디버거가 활성화되면 DTrace 프로브가 시작됩니다</target>
        </trans-unit>
        <trans-unit id="bbb01fbe6bfaaec090a44633982fb31ae18d0d39" translate="yes" xml:space="preserve">
          <source>Traces the exit of any subroutine. Note that all of the variables refer to the subroutine that is returning; there is currently no way to get ahold of any information about the subroutine's</source>
          <target state="translated">서브 루틴의 종료를 추적합니다. 모든 변수는 리턴되는 서브 루틴을 나타냅니다. 현재 서브 루틴에 대한 정보를 얻을 수있는 방법이 없습니다</target>
        </trans-unit>
        <trans-unit id="469260e080c9b35d7ee5b388f5235f91978c75b9" translate="yes" xml:space="preserve">
          <source>Traditional form:</source>
          <target state="translated">전통적인 형태 :</target>
        </trans-unit>
        <trans-unit id="0ad67b0aa9abbb10a0d4b2ca67f1c4ff5d61a0ed" translate="yes" xml:space="preserve">
          <source>Traditionally END blocks have been executed at the end of the perl_run. This causes problems for applications that never call perl_run. Since perl 5.7.2 you can specify &lt;code&gt;PL_exit_flags |= PERL_EXIT_DESTRUCT_END&lt;/code&gt; to get the new behaviour. This also enables the running of END blocks if the perl_parse fails and &lt;code&gt;perl_destruct&lt;/code&gt; will return the exit value.</source>
          <target state="translated">전통적으로 END 블록은 perl_run의 끝에서 실행되었습니다. perl_run을 호출하지 않는 응용 프로그램에 문제가 발생합니다. perl 5.7.2부터 &lt;code&gt;PL_exit_flags |= PERL_EXIT_DESTRUCT_END&lt;/code&gt; 를 지정 하여 새 동작을 얻을 수 있습니다. 또한 perl_parse가 실패하고 &lt;code&gt;perl_destruct&lt;/code&gt; 가 종료 값을 리턴하는 경우 END 블록을 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0f62d4679a2de6656186513ec5b0145dfd0852c8" translate="yes" xml:space="preserve">
          <source>Traditionally in Perl, any use of any of the three variables &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; or &lt;code&gt;$'&lt;/code&gt; (or their &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; English&lt;/code&gt; equivalents) anywhere in the code, caused all subsequent successful pattern matches to make a copy of the matched string, in case the code might subsequently access one of those variables. This imposed a considerable performance penalty across the whole program, so generally the use of these variables has been discouraged.</source>
          <target state="translated">전통적으로 Perl에서는 코드 어디에서든 세 개의 변수 &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; 또는 &lt;code&gt;$'&lt;/code&gt; (또는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; English&lt;/code&gt; 와 동등한 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; )를 사용 하면 모든 후속 패턴 일치가 일치하는 문자열의 사본을 만들었습니다. 코드는 나중에 해당 변수 중 하나에 액세스 할 수 있습니다. 이로 인해 전체 프로그램에서 상당한 성능 저하가 발생하므로 일반적으로 이러한 변수의 사용을 권장하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="edc1e4ae8cd5bdd4ef52be4cd619be47a1e80306" translate="yes" xml:space="preserve">
          <source>Traditionally the result is a string of 13 bytes: two first bytes of the salt, followed by 11 bytes from the set &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt;, and only the first eight bytes of PLAINTEXT mattered. But alternative hashing schemes (like MD5), higher level security schemes (like C2), and implementations on non-Unix platforms may produce different strings.</source>
          <target state="translated">전통적으로 결과는 13 바이트의 문자열입니다. 소금의 첫 번째 두 바이트, 그 다음에 세트 &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; 에서 11 바이트 , PLAINTEXT의 처음 8 바이트 만 중요합니다. 그러나 MD5와 같은 대체 해싱 구성표, C2와 같은 고급 보안 구성표 및 비 유닉스 플랫폼에서의 구현은 다른 문자열을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="366ba2d0971221ce62e3e700bb5e4027a597313b" translate="yes" xml:space="preserve">
          <source>Traditionally, Perl has captured the value of the variable at that point and turned the subroutine into a constant eligible for inlining. In those cases where the variable can be modified elsewhere, this breaks the behavior of closures, in which the subroutine captures the variable itself, rather than its value, so future changes to the variable are reflected in the subroutine's return value.</source>
          <target state="translated">전통적으로 Perl은 그 시점에서 변수의 가치를 포착하여 서브 루틴을 인라인 할 수있는 상수로 바꿨습니다. 변수를 다른 곳에서 수정할 수있는 경우, 이는 서브 루틴이 값이 아닌 변수 자체를 캡처하는 클로저의 동작을 중단하므로 향후 변수의 변경 사항이 서브 루틴의 리턴 값에 반영됩니다.</target>
        </trans-unit>
        <trans-unit id="77c289ba4e5a8332a82b92e0a687ee8832b65763" translate="yes" xml:space="preserve">
          <source>Traditionally, the Perl function &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; rounds to 0 (see &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;), and so for floating-point-like types one should follow the same semantic.</source>
          <target state="translated">전통적으로 Perl 함수 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 는 0으로 반올림 되므로 ( &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; 참조 ) 부동 소수점 유사 유형의 경우 동일한 의미를 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="b2c93accaaddf881f0426884fd5fb319c6e78ef4" translate="yes" xml:space="preserve">
          <source>Traditionally, the definition of an inside-out class contains a bare block inside which a number of lexical hashes are declared and the basic accessor methods defined, usually through &lt;code&gt;Scalar::Util::refaddr&lt;/code&gt; . Further methods may be defined outside this block. There has to be a DESTROY method and, for thread support, a CLONE method.</source>
          <target state="translated">일반적으로 인사이드 아웃 클래스의 정의에는 다수의 어휘 해시가 선언되는 기본 블록이 포함되어 있으며 일반적으로 &lt;code&gt;Scalar::Util::refaddr&lt;/code&gt; 통해 기본 접근 자 메서드가 정의되어 있습니다. 이 블록 외부에 추가 방법이 정의 될 수 있습니다. 스레드 지원을 위해서는 DESTROY 메소드와 CLONE 메소드가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="56e30fa719825fef87897a9b73f8c643d6e27859" translate="yes" xml:space="preserve">
          <source>Traditionally, typemaps needed to be written to a separate file, conventionally called &lt;code&gt;typemap&lt;/code&gt; in a CPAN distribution. With ExtUtils::ParseXS (the XS compiler) version 3.12 or better which comes with perl 5.16, typemaps can also be embedded directly into XS code using a HERE-doc like syntax:</source>
          <target state="translated">전통적으로 타입 &lt;code&gt;typemap&lt;/code&gt; 은 CPAN 배포에서 타입 맵 이라고하는 별도의 파일에 기록되어야했습니다 . Perl 5.16과 함께 제공되는 ExtUtils :: ParseXS (XS 컴파일러) 버전 3.12 이상에서 다음과 같은 구문을 사용하여 typemap을 XS 코드에 직접 포함시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b116d15c8d0f591aea30acc14d32c8151254d15b" translate="yes" xml:space="preserve">
          <source>Transfer file in ASCII. CRLF translation will be done if required</source>
          <target state="translated">ASCII로 파일을 전송하십시오. 필요한 경우 CRLF 번역이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="19b93b66a9a164099cf4c3e60d4b5f7a2c5a7780" translate="yes" xml:space="preserve">
          <source>Transfer file in binary mode. No transformation will be done.</source>
          <target state="translated">이진 모드로 파일을 전송하십시오. 변환이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="71b54b146f4723aa8db4c8d0ffb0816f4aee31ad" translate="yes" xml:space="preserve">
          <source>Transforms the current application into a PM application and back. The argument true means that a real message loop is going to be served. OS2::MorphPM() returns the PM message queue handle as an integer.</source>
          <target state="translated">현재 응용 프로그램을 PM 응용 프로그램으로 변환합니다. true 인수는 실제 메시지 루프가 제공됨을 의미합니다. OS2 :: MorphPM ()은 PM 메시지 큐 핸들을 정수로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="3ab5267ee01682b79d53eef55a6ec4c6169897d2" translate="yes" xml:space="preserve">
          <source>Translate logical name DCL$PATH as a searchlist, rather than trying to &lt;code&gt;&lt;a href=&quot;../../functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; string value of &lt;code&gt;$ENV{'PATH'}&lt;/code&gt; .</source>
          <target state="translated">문자열 값 &lt;code&gt;$ENV{'PATH'}&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;../../functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 하지 않고 논리 이름 DCL $ PATH를 검색 목록으로 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="4df3684f8e1af9f3d36ff43ec1a39944ea62d252" translate="yes" xml:space="preserve">
          <source>Translates a Windows path to the corresponding cygwin path respecting the current mount points. With a second non-null argument returns an absolute path. Double-byte characters will not be translated.</source>
          <target state="translated">현재 마운트 지점을 기준으로 해당 cygwin 경로로 Windows 경로를 변환합니다. 두 번째 널이 아닌 인수를 사용하면 절대 경로가 리턴됩니다. 더블 바이트 문자는 번역되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="43c8972cdf7cbd4964f60ea0553934fab0c0bfe0" translate="yes" xml:space="preserve">
          <source>Translates a Windows pid to the corresponding cygwin pid (if any).</source>
          <target state="translated">Windows pid를 해당 cygwin pid (있는 경우)로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="582d5dcb01cd3d8be49a7bc9c562cc61d6d3a8c7" translate="yes" xml:space="preserve">
          <source>Translates a cygwin path to the corresponding cygwin path respecting the current mount points. With a second non-null argument returns an absolute path. Double-byte characters will not be translated.</source>
          <target state="translated">cygwin 경로를 현재 마운트 지점을 기준으로 해당 cygwin 경로로 변환합니다. 두 번째 널이 아닌 인수를 사용하면 절대 경로가 리턴됩니다. 더블 바이트 문자는 번역되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d0b7e8b1f9fa64e7df02a610ac8f751cbf79794f" translate="yes" xml:space="preserve">
          <source>Translates a cygwin pid to the corresponding Windows pid (which may or may not be the same).</source>
          <target state="translated">cygwin pid를 해당 Windows pid (동일하거나 동일하지 않음)로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="3cb9f5d38a91da3cb24f8ddc9ee0b78bc3316e7d" translate="yes" xml:space="preserve">
          <source>Translates the template as before except that a directory name is specified.</source>
          <target state="translated">디렉토리 이름이 지정된 것을 제외하고 템플리트를 이전과 같이 변환합니다.</target>
        </trans-unit>
        <trans-unit id="0e0c59b2d3a94d773b16fba8c10f9e6b9a4c8d83" translate="yes" xml:space="preserve">
          <source>Translators are available for converting Pod to various formats like plain text, HTML, man pages, and more.</source>
          <target state="translated">번역기를 사용하여 포드를 일반 텍스트, HTML, 매뉴얼 페이지 등과 같은 다양한 형식으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d02c52d09a4e30f9d862205070306d13e0fd4bf" translate="yes" xml:space="preserve">
          <source>Translators may request clarification of the situation in which a particular phrase is found. For example, in English we are entirely happy saying &quot;</source>
          <target state="translated">번역 사는 특정 문구가 발견 된 상황에 대한 설명을 요청할 수 있습니다. 예를 들어 영어로 &quot;</target>
        </trans-unit>
        <trans-unit id="7cec7716cf837c5d26e64202c8e48b66fd1ee111" translate="yes" xml:space="preserve">
          <source>Transliterate characters missing in encoding to &amp;amp;#NNN; where NNN is the decimal Unicode code point.</source>
          <target state="translated">인코딩 할 때 문자를 &amp;amp; # NNN; 여기서 NNN은 십진 유니 코드 코드 포인트입니다.</target>
        </trans-unit>
        <trans-unit id="4a944de5b3bc5a013582ea0515548fdc64b85e91" translate="yes" xml:space="preserve">
          <source>Transliterate characters missing in encoding to &amp;amp;#xHHHH; where HHHH is the hexadecimal Unicode code point.</source>
          <target state="translated">인코딩 할 때 문자를 &amp;amp; # xHHHH; 여기서 HHHH는 16 진 유니 코드 코드 포인트입니다.</target>
        </trans-unit>
        <trans-unit id="7531ab4c38b927cd6bd26046089b6f931f4b9669" translate="yes" xml:space="preserve">
          <source>Transliterate characters missing in encoding to \x{HHHH} where HHHH is the hexadecimal Unicode code point.</source>
          <target state="translated">인코딩에서 \ x {HHHH}로 음역 문자가 누락되었습니다. 여기서 HHHH는 16 진수 유니 코드 코드 포인트입니다.</target>
        </trans-unit>
        <trans-unit id="778ddecb6dcc9c5eac19efad6822ed838d8cfd37" translate="yes" xml:space="preserve">
          <source>Transliterates all occurrences of the characters found in the search list with the corresponding character in the replacement list. It returns the number of characters replaced or deleted. If no string is specified via the &lt;code&gt;=~&lt;/code&gt; or &lt;code&gt;!~&lt;/code&gt; operator, the &lt;code&gt;$_&lt;/code&gt; string is transliterated.</source>
          <target state="translated">검색 목록에서 찾은 모든 문자를 대체 목록의 해당 문자로 음역합니다. 교체되거나 삭제 된 문자 수를 반환합니다. &lt;code&gt;=~&lt;/code&gt; 또는 &lt;code&gt;!~&lt;/code&gt; 연산자 를 통해 문자열을 지정하지 않으면 &lt;code&gt;$_&lt;/code&gt; 문자열이 음역됩니다.</target>
        </trans-unit>
        <trans-unit id="420a5e0771ab4a0b9e610c4b35eccba70828962b" translate="yes" xml:space="preserve">
          <source>Transparent BigInteger support for Perl</source>
          <target state="translated">Perl에 대한 투명한 BigInteger 지원</target>
        </trans-unit>
        <trans-unit id="7267fd5dd0f2d5cad0d4fdfbc6f406231fbc74c7" translate="yes" xml:space="preserve">
          <source>Transparent BigNumber support for Perl</source>
          <target state="translated">Perl에 대한 투명한 BigNumber 지원</target>
        </trans-unit>
        <trans-unit id="d53f15081d775673dd122d267a0fda505ffa50fe" translate="yes" xml:space="preserve">
          <source>Transparent BigNumber/BigRational support for Perl</source>
          <target state="translated">Perl에 대한 투명한 BigNumber / BigRational 지원</target>
        </trans-unit>
        <trans-unit id="1320fa0059bd04032c977af604f63823046e2bca" translate="yes" xml:space="preserve">
          <source>Trappable errors may be trapped using the eval operator. See &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;. In almost all cases, warnings may be selectively disabled or promoted to fatal errors using the &lt;code&gt;warnings&lt;/code&gt; pragma. See &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">평가 연산자를 사용하면 트래핑 가능한 오류가 발생할 수 있습니다. &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 참조하십시오 . 거의 모든 경우에 &lt;code&gt;warnings&lt;/code&gt; pragma를 사용하여 경고 를 선택적으로 비활성화하거나 치명적 오류로 승격시킬 수 있습니다 . &lt;a href=&quot;warnings&quot;&gt;경고를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7f10d4d7cb6294c3306a64ba2969b74200be2428" translate="yes" xml:space="preserve">
          <source>Traverse a directory tree.</source>
          <target state="translated">디렉토리 트리를 탐색하십시오.</target>
        </trans-unit>
        <trans-unit id="b2a99160c9547d1ab75aaa55623e70b1b8573818" translate="yes" xml:space="preserve">
          <source>Treat string as multiple lines. That is, change &quot;^&quot; and &quot;$&quot; from matching the start of the string's first line and the end of its last line to matching the start and end of each line within the string.</source>
          <target state="translated">문자열을 여러 줄로 취급하십시오. 즉, &quot;^&quot;및 &quot;$&quot;는 문자열의 첫 번째 줄의 시작과 마지막 줄의 끝을 일치시키는 것에서 문자열 내 각 줄의 시작과 끝을 일치시키는 것으로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="93fa15e2fd4bd3f0707530f7f374f8fd00c44547" translate="yes" xml:space="preserve">
          <source>Treat string as single line. That is, change &quot;.&quot; to match any character whatsoever, even a newline, which normally it would not match.</source>
          <target state="translated">문자열을 한 줄로 취급하십시오. 즉, &quot;.&quot;를 변경하십시오. 줄 바꿈과 같은 문자를 찾으려면 일반적으로 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="369a3fe575602256c74f237530b2066156aadc25" translate="yes" xml:space="preserve">
          <source>Treats ARRAY as a stack by appending the values of LIST to the end of ARRAY. The length of ARRAY increases by the length of LIST. Has the same effect as</source>
          <target state="translated">LIST의 값을 ARRAY 끝에 추가하여 ARRAY를 스택으로 취급합니다. ARRAY의 길이는 LIST의 길이만큼 증가합니다. 같은 효과가 있습니다</target>
        </trans-unit>
        <trans-unit id="4c2b22d2044144acb2e177299ffb0546b35d1302" translate="yes" xml:space="preserve">
          <source>Treats the complete zip file/buffer as a single compressed data stream. When reading in multi-stream mode each member of the zip file/buffer will be uncompressed in turn until the end of the file/buffer is encountered.</source>
          <target state="translated">완전한 zip 파일 / 버퍼를 단일 압축 데이터 스트림으로 취급합니다. 멀티 스트림 모드에서 읽을 때 zip 파일 / 버퍼의 각 멤버는 파일 / 버퍼의 끝이 나올 때까지 차례로 압축 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="9170df3df869288dce7be7560494463cb05b5488" translate="yes" xml:space="preserve">
          <source>Treats the return value of the code block as the condition.</source>
          <target state="translated">코드 블록의 반환 값을 조건으로 취급합니다.</target>
        </trans-unit>
        <trans-unit id="076fbc2c1d84c79c360a6aaf693ed414200277af" translate="yes" xml:space="preserve">
          <source>Treats the string in EXPR as a bit vector made up of elements of width BITS and returns the value of the element specified by OFFSET as an unsigned integer. BITS therefore specifies the number of bits that are reserved for each element in the bit vector. This must be a power of two from 1 to 32 (or 64, if your platform supports that).</source>
          <target state="translated">EXPR의 문자열을 너비 BITS의 요소로 구성된 비트 벡터로 취급하고 OFFSET로 지정된 요소의 값을 부호없는 정수로 리턴합니다. 따라서 BITS는 비트 벡터의 각 요소에 예약 된 비트 수를 지정합니다. 1에서 32 사이의 2의 제곱이어야합니다 (또는 플랫폼에서 지원하는 경우 64).</target>
        </trans-unit>
        <trans-unit id="74c726e22e1ef4f0ff5d0f342fa4b671a8d7e3e6" translate="yes" xml:space="preserve">
          <source>Tree Contents</source>
          <target state="translated">나무 내용</target>
        </trans-unit>
        <trans-unit id="bc924ad99a31c83efb674a21a76798fdb63e8535" translate="yes" xml:space="preserve">
          <source>Tries to &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; the given $module or $file. If it loads successfully, the test will pass. Otherwise it fails and displays the load error.</source>
          <target state="translated">주어진 $ module 또는 $ file 을 &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 합니다. 성공적으로로드되면 테스트에 통과합니다. 그렇지 않으면 실패하고로드 오류를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="82437a05f154f78a4ae190392aa21b46338d0c97" translate="yes" xml:space="preserve">
          <source>Tries to uses &lt;a href=&quot;../../../ipc/open3&quot;&gt;IPC::Open3&lt;/a&gt; &amp;amp; &lt;a href=&quot;../../../io/select&quot;&gt;IO::Select&lt;/a&gt; to communicate with the spawned process if they are available. Falls back onto &lt;code&gt;&lt;a href=&quot;../../../functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../ipc/open3&quot;&gt;IPC :: Open3&lt;/a&gt; &amp;amp; &lt;a href=&quot;../../../io/select&quot;&gt;IO ::&lt;/a&gt; 를 사용하려고 시도합니다. 사용 가능한 경우 생성 된 프로세스와 통신하려면 선택하십시오 . &lt;code&gt;&lt;a href=&quot;../../../functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 으로 폴백 합니다.</target>
        </trans-unit>
        <trans-unit id="d0328d99f96d6b6cb2e5370be4979de91fb2ea44" translate="yes" xml:space="preserve">
          <source>Triggered by a delete from %^H, records the key to &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; .</source>
          <target state="translated">% ^ H에서의 삭제에 의해 트리거되어 &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; 의 키를 기록합니다 .</target>
        </trans-unit>
        <trans-unit id="ce25e5857867e6310e792d455213353087781834" translate="yes" xml:space="preserve">
          <source>Triggered by a store to %^H, records the key/value pair to &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; . It is assumed that hints aren't storing anything that would need a deep copy. Maybe we should warn if we find a reference.</source>
          <target state="translated">% ^ H에 대한 상점에 ​​의해 트리거되어 키 / 값 쌍을 &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; 에 기록합니다 . 힌트는 딥 카피가 필요한 것을 저장하지 않는 것으로 가정합니다. 참조를 찾으면 경고해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e62fd5a7239de339d5bd00c0d3006bd6b133b17" translate="yes" xml:space="preserve">
          <source>Triggered by clearing %^H, resets &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; .</source>
          <target state="translated">% ^ H를 지우면 트리거되며 &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; 가 재설정 됩니다 .</target>
        </trans-unit>
        <trans-unit id="b9e4c026492c440bf32166e0789393487d03b254" translate="yes" xml:space="preserve">
          <source>Trigonometric functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce550b5479caa5cd0ed1b0d59ad15c9773c7bcdb" translate="yes" xml:space="preserve">
          <source>Trilogy, &lt;code&gt;In the beginning the
Universe was created. This has made a lot of people very angry and
been widely regarded as a bad move&lt;/code&gt; . Their mistake was not of this magnitude so let's forgive them.</source>
          <target state="translated">3 부작, &lt;code&gt;In the beginning the Universe was created. This has made a lot of people very angry and been widely regarded as a bad move&lt;/code&gt; . 그들의 실수는이 정도가 아니 었으므로 용서합시다.</target>
        </trans-unit>
        <trans-unit id="285ec850c11d78bac10f6bfa31b69a37f1b257c9" translate="yes" xml:space="preserve">
          <source>Troubleshooting</source>
          <target state="translated">Troubleshooting</target>
        </trans-unit>
        <trans-unit id="28e5d7df36d1a6dde25f3c09a31821344957a89c" translate="yes" xml:space="preserve">
          <source>Troubleshooting these Examples</source>
          <target state="translated">이 예제 문제 해결</target>
        </trans-unit>
        <trans-unit id="95a9fcae6cc7c433c5ecb181677d9e65f088ed3c" translate="yes" xml:space="preserve">
          <source>Tru64 5.1 documentation on syslog, &lt;a href=&quot;http://h30097.www3.hp.com/docs/base_doc/DOCUMENTATION/V51_HTML/MAN/MAN3/0193____.HTM&quot;&gt;http://h30097.www3.hp.com/docs/base_doc/DOCUMENTATION/V51_HTML/MAN/MAN3/0193____.HTM&lt;/a&gt;</source>
          <target state="translated">Syslog에 대한 Tru64 5.1 설명서, &lt;a href=&quot;http://h30097.www3.hp.com/docs/base_doc/DOCUMENTATION/V51_HTML/MAN/MAN3/0193____.HTM&quot;&gt;http://h30097.www3.hp.com/docs/base_doc/DOCUMENTATION/V51_HTML/MAN/MAN3/0193____.HTM&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9109071ad135094f2373ecd2b94d8dc48e87efa6" translate="yes" xml:space="preserve">
          <source>True if an external</source>
          <target state="translated">외부인 경우 참</target>
        </trans-unit>
        <trans-unit id="f3a74362a5094d39f2b42a3da4ab4b28a9691928" translate="yes" xml:space="preserve">
          <source>True if on an OS where qx operator (or backticks) can redirect &lt;code&gt;STDERR&lt;/code&gt; onto &lt;code&gt;STDOUT&lt;/code&gt; .</source>
          <target state="translated">qx 연산자 (또는 백틱)가 &lt;code&gt;STDERR&lt;/code&gt; 을 &lt;code&gt;STDOUT&lt;/code&gt; 으로 경로 재 지정할 수있는 OS에서 true 입니다.</target>
        </trans-unit>
        <trans-unit id="52369ee8420cce3f1adcdcc979064876449bf33b" translate="yes" xml:space="preserve">
          <source>True if the socket is currently positioned at the urgent data mark, false otherwise.</source>
          <target state="translated">소켓이 현재 긴급 데이터 표시에 있으면 true이고, 그렇지 않으면 false입니다.</target>
        </trans-unit>
        <trans-unit id="263df4a03022b2922b4599d5befe15e4f094944e" translate="yes" xml:space="preserve">
          <source>True if the source has meta data.</source>
          <target state="translated">소스에 메타 데이터가 있으면 참입니다.</target>
        </trans-unit>
        <trans-unit id="001c945275af8c53e929fc8bb52b9331e9fa2beb" translate="yes" xml:space="preserve">
          <source>True if this op will be the return value of an lvalue subroutine</source>
          <target state="translated">이 op가 lvalue 서브 루틴의 리턴 값이면 참</target>
        </trans-unit>
        <trans-unit id="a225ab817ea7fa5d168aaeda6fa091c3d9bf26a1" translate="yes" xml:space="preserve">
          <source>True is returned if the file name begins with &lt;code&gt;drive_letter:&lt;/code&gt; , and if not, File::Spec::Unix file_name_is_absolute() is called.</source>
          <target state="translated">파일 이름이 &lt;code&gt;drive_letter:&lt;/code&gt; 시작하면 True가 리턴 되고 그렇지 않으면 File :: Spec :: Unix file_name_is_absolute ()가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="714a51854b847f734d4ad3e61a135b245522aeae" translate="yes" xml:space="preserve">
          <source>True while the most recent result was a TODO. Becomes true before the TODO result is returned and stays true until just before the next non- TODO test is returned.</source>
          <target state="translated">가장 최근의 결과는 TODO였습니다. TODO 결과가 리턴되기 전에 true가되고 다음 비 TODO 테스트가 리턴되기 직전까지 true를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="1aceee4ee4f49927d115b3fc82be6c512d7c286c" translate="yes" xml:space="preserve">
          <source>True/false results are never tainted.</source>
          <target state="translated">참 / 거짓 결과는 결코 오염되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f8dc96e0b59ea3e8174d5b669fb89eb4295305d3" translate="yes" xml:space="preserve">
          <source>Truncate $x to an integer value.</source>
          <target state="translated">$ x를 정수 값으로 자릅니다.</target>
        </trans-unit>
        <trans-unit id="11625b03167a879105d56ac5232340fe7c1e8727" translate="yes" xml:space="preserve">
          <source>Truncate file suggested by open mode.</source>
          <target state="translated">열린 모드에서 제안한 파일을 자릅니다.</target>
        </trans-unit>
        <trans-unit id="69983876ff90a7fef773e08a772b817cd9bc808d" translate="yes" xml:space="preserve">
          <source>Truncates the file opened on FILEHANDLE, or named by EXPR, to the specified length. Raises an exception if truncate isn't implemented on your system. Returns true if successful, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error.</source>
          <target state="translated">FILEHANDLE에서 열렸거나 EXPR에 의해 명명 된 파일을 지정된 길이로 자릅니다. 시스템에서 자르기가 구현되지 않은 경우 예외가 발생합니다. 성공하면 true를 반환하고 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 시 오류를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e6b7268dfdb3e49fbc8b9714eadb8dee9d853cfb" translate="yes" xml:space="preserve">
          <source>Truncates the file opened on FILEHANDLE, or named by EXPR, to the specified length. Raises an exception if truncate isn't implemented on your system. Returns true if successful, &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error.</source>
          <target state="translated">FILEHANDLE에서 열렸거나 EXPR에 의해 명명 된 파일을 지정된 길이로 자릅니다. 시스템에서 자르기가 구현되지 않은 경우 예외가 발생합니다. 성공하면 true를 반환하고 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 시 오류를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="2975c0f92fcae4101065548cc1a5e6bfa7744574" translate="yes" xml:space="preserve">
          <source>Truncation to same-or-shorter lengths only. (VOS)</source>
          <target state="translated">동일하거나 짧은 길이로만 잘립니다. (VOS)</target>
        </trans-unit>
        <trans-unit id="07fcbd4e35869ee7c3769699235ad97c3caf7ea4" translate="yes" xml:space="preserve">
          <source>Truth and Falsehood</source>
          <target state="translated">진실과 거짓</target>
        </trans-unit>
        <trans-unit id="0ea36a88c9652f7de32e4b8cdc539660f9c8bb67" translate="yes" xml:space="preserve">
          <source>Truth. (&lt;code&gt;PL_sv_yes&lt;/code&gt; ) The value is not needed (and ignored).</source>
          <target state="translated">진실. ( &lt;code&gt;PL_sv_yes&lt;/code&gt; ) 값이 필요하지 않으며 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="820aa128934b824418f5ca61678f5828e0a9f3f1" translate="yes" xml:space="preserve">
          <source>Try 'which ld' and 'which ld' (or try 'ar --version' and 'ld --version', which work only for the GNU tools, and will announce themselves to be such), and adjust your PATH so that you are consistently using either the native tools or the GNU tools. After fixing your PATH, you should do 'make distclean' and start all the way from running the Configure since you may have quite a confused situation.</source>
          <target state="translated">'which ld'와 'which ld'(또는 GNU 도구에서만 작동하고 그렇게 발표 할 'ar --version'및 'ld --version'을 시도)하고 PATH를 조정하십시오. 기본 도구 또는 GNU 도구를 일관되게 사용하고 있습니다. PATH를 수정 한 후에는 혼란스러운 상황이 발생할 수 있으므로 'make distclean'을 수행하고 Configure 실행을 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="dfec8d0f349c3c42fb9d1815573a589ac82ef522" translate="yes" xml:space="preserve">
          <source>Try and match a closing delimiter bracket. If the bracket was the same species as the last opening bracket, return the substring to that point. If the bracket was mismatched, return an error.</source>
          <target state="translated">닫는 구분 기호 괄호를 사용하십시오. 대괄호가 마지막 여는 대괄호와 같은 종이면 하위 문자열을 해당 지점으로 되돌립니다. 대괄호가 일치하지 않으면 오류를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="3534e8ec8243f82da173a0a961f29a6061ccc5a4" translate="yes" xml:space="preserve">
          <source>Try every conceivable way to get hostname</source>
          <target state="translated">생각할 수있는 모든 방법으로 호스트 이름을 얻으십시오</target>
        </trans-unit>
        <trans-unit id="dfea66ec3b5d472c8a85f9f4143d2c2a2932e7a3" translate="yes" xml:space="preserve">
          <source>Try hard not to exceed 79-columns</source>
          <target state="translated">79 열을 초과하지 않도록 노력하십시오.</target>
        </trans-unit>
        <trans-unit id="71156f6966e318bbb69b3350da865612c3413590" translate="yes" xml:space="preserve">
          <source>Try keeping around the seekpointer and go there, like this:</source>
          <target state="translated">탐색 포인터 주위를 유지하고 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="5ab49ef558819708ac26895c52750c3610705d02" translate="yes" xml:space="preserve">
          <source>Try not to launch headlong into developing your module without spending some time thinking first. A little forethought may save you a vast amount of effort later on.</source>
          <target state="translated">먼저 생각하지 않고 모듈 개발을 시작하지 마십시오. 조금만 생각하면 나중에 많은 노력을 아낄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a2b567df2700cceb3e59d9f8a3eb3ca3092a77c" translate="yes" xml:space="preserve">
          <source>Try the &lt;a href=&quot;net/ftp&quot;&gt;Net::FTP&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/TCP::Client&quot;&gt;TCP::Client&lt;/a&gt;, and &lt;a href=&quot;http://search.cpan.org/perldoc/Net::Telnet&quot;&gt;Net::Telnet&lt;/a&gt; modules (available from CPAN). &lt;a href=&quot;http://www.cpan.org/scripts/netstuff/telnet.emul.shar&quot;&gt;http://www.cpan.org/scripts/netstuff/telnet.emul.shar&lt;/a&gt; will also help for emulating the telnet protocol, but &lt;a href=&quot;http://search.cpan.org/perldoc/Net::Telnet&quot;&gt;Net::Telnet&lt;/a&gt; is quite probably easier to use.</source>
          <target state="translated">&lt;a href=&quot;net/ftp&quot;&gt;Net :: FTP&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/TCP::Client&quot;&gt;TCP :: Client&lt;/a&gt; 및 &lt;a href=&quot;http://search.cpan.org/perldoc/Net::Telnet&quot;&gt;Net :: Telnet&lt;/a&gt; 모듈 (CPAN에서 사용 가능)을 사용해보십시오 . &lt;a href=&quot;http://www.cpan.org/scripts/netstuff/telnet.emul.shar&quot;&gt;http://www.cpan.org/scripts/netstuff/telnet.emul.shar&lt;/a&gt; 도 텔넷 프로토콜을 에뮬레이트하는 데 도움이되지만 &lt;a href=&quot;http://search.cpan.org/perldoc/Net::Telnet&quot;&gt;Net :: Telnet&lt;/a&gt; 이 훨씬 사용하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="87f2df3af873276d11f18dcdfa6067907516ef82" translate="yes" xml:space="preserve">
          <source>Try the first alternative in the first group 'abd'.</source>
          <target state="translated">첫 번째 그룹 'abd'의 첫 번째 대안을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="8fdc9fd893f9837a30290ddcdb863de474cd49f7" translate="yes" xml:space="preserve">
          <source>Try the native, UDP socket then UNIX domain socket mechanisms:</source>
          <target state="translated">기본 UDP 소켓과 UNIX 도메인 소켓 메커니즘을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="6a75e271162bdc3d061e3493d3ce114d627fc256" translate="yes" xml:space="preserve">
          <source>Try the resources in &lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2&lt;/a&gt; 의 리소스를 사용해보십시오 .</target>
        </trans-unit>
        <trans-unit id="aacef041b76d57895de9d7f5cee32482707bd3b3" translate="yes" xml:space="preserve">
          <source>Try to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict qw(...);&lt;/code&gt; ). Remember that you can add &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; strict qw(...);&lt;/code&gt; to individual blocks of code that need less strictness.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; 것을 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하십시오 ; (또는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict qw(...);&lt;/code&gt; ). &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; strict qw(...);&lt;/code&gt; 추가 할 수 &lt;a href=&quot;functions/no&quot;&gt;없음을&lt;/a&gt; 기억하십시오 . 덜 엄격해야하는 개별 코드 블록에.</target>
        </trans-unit>
        <trans-unit id="dbe02bedd5bb36eab5b4bbe32b7d4940cf95d2ec" translate="yes" xml:space="preserve">
          <source>Try to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings;&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings qw(...);&lt;/code&gt; ). Remember that you can add &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings qw(...);&lt;/code&gt; to individual blocks of code that need less warnings.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings;&lt;/code&gt; 를 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하십시오 . (또는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings qw(...);&lt;/code&gt; ). &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings qw(...);&lt;/code&gt; 추가 할 수 &lt;a href=&quot;functions/no&quot;&gt;없습니다.&lt;/a&gt; qw (...); 경고가 덜 필요한 개별 코드 블록에.</target>
        </trans-unit>
        <trans-unit id="1a50d23e31ca789a858a654feff08b918836c974" translate="yes" xml:space="preserve">
          <source>Try to color output. See &lt;a href=&quot;../tap/formatter/base#new&quot;&gt;new in TAP::Formatter::Base&lt;/a&gt;.</source>
          <target state="translated">컬러 출력을 시도하십시오. &lt;a href=&quot;../tap/formatter/base#new&quot;&gt;TAP :: Formatter :: Base의 새로운 기능을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2e97a54a5e20ef4c3c124d4963b017c39c1dad7b" translate="yes" xml:space="preserve">
          <source>Try to design the new module to be easy to extend and reuse.</source>
          <target state="translated">쉽게 확장하고 재사용 할 수 있도록 새 모듈을 설계하십시오.</target>
        </trans-unit>
        <trans-unit id="220ea4d529b6fa37d1fa97bbb19f2fed77ce5e5b" translate="yes" xml:space="preserve">
          <source>Try to determine name of extension being built. We begin with the name of the current directory. Since VMS filenames are case-insensitive, however, we look for a</source>
          <target state="translated">빌드중인 확장명을 결정하십시오. 우리는 현재 디렉토리의 이름으로 시작합니다. 그러나 VMS 파일 이름은 대소 문자를 구분하지 않으므로</target>
        </trans-unit>
        <trans-unit id="909a91fc6d3b48263691b246eef6c09eb4ec3bfc" translate="yes" xml:space="preserve">
          <source>Try to determine the width of the screen and the bold and underline sequences for the terminal from termcap, and use that information in formatting the output. Output will be wrapped at two columns less than the width of your terminal device. Using this option requires that your system have a termcap file somewhere where Term::Cap can find it and requires that your system support termios. With this option, the output of &lt;b&gt;pod2text&lt;/b&gt; will contain terminal control sequences for your current terminal type.</source>
          <target state="translated">termcap에서 화면의 너비와 터미널에 대한 굵은 체와 밑줄 순서를 결정하고 해당 정보를 출력 형식화에 사용하십시오. 출력은 터미널 장치의 너비보다 작은 두 열로 줄 바꿈됩니다. 이 옵션을 사용하려면 시스템에 Term :: Cap에서 찾을 수있는 termcap 파일이 있어야하며 시스템에서 termios를 지원해야합니다. 이 옵션을 사용하면 &lt;b&gt;pod2text&lt;/b&gt; 의 출력에 현재 터미널 유형에 대한 터미널 제어 시퀀스가 ​​포함됩니다.</target>
        </trans-unit>
        <trans-unit id="08f15a05901602892a511e670ab4aa0307df4226" translate="yes" xml:space="preserve">
          <source>Try to document your code and use Pod formatting in a consistent way. Here are commonly expected conventions:</source>
          <target state="translated">코드를 문서화하고 일관된 방식으로 포드 형식을 사용하십시오. 일반적으로 예상되는 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c88c728349f5a2409f402906caa2d933f74c0865" translate="yes" xml:space="preserve">
          <source>Try to match a quote or quotelike operator. If found, call &lt;code&gt;extract_quotelike&lt;/code&gt; to eat it. If &lt;code&gt;extract_quotelike&lt;/code&gt; fails, return the error it returned. Otherwise go back to step 1.</source>
          <target state="translated">따옴표 나 따옴표와 같은 연산자를 일치 시키십시오. 발견되면 &lt;code&gt;extract_quotelike&lt;/code&gt; 를 호출 하여 먹습니다. 경우 &lt;code&gt;extract_quotelike&lt;/code&gt; 이 실패가 반환 된 오류를 반환합니다. 그렇지 않으면 1 단계로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="fed009e07cf40a3bfaccb23b101b1df3951ecefd" translate="yes" xml:space="preserve">
          <source>Try to match an opening delimiter bracket. If found, call &lt;code&gt;extract_codeblock&lt;/code&gt; recursively to eat the embedded block. If the recursive call fails, return an error. Otherwise, go back to step 1.</source>
          <target state="translated">여는 구분 기호를 일치 시키십시오. 발견되면 내장 블록을 먹기 위해 재귀 적으로 &lt;code&gt;extract_codeblock&lt;/code&gt; 을 호출 하십시오. 재귀 호출이 실패하면 오류를 반환하십시오. 그렇지 않으면 1 단계로 돌아가십시오.</target>
        </trans-unit>
        <trans-unit id="1bf160ae95bc79040defdb4258d5fad8caa20a29" translate="yes" xml:space="preserve">
          <source>Try to obtain the latest version of the Windows SDK. Sometimes these packages contain a particular Windows OS version in their name, but actually work on other OS versions too. For example, the &quot;Windows Server 2003 R2 Platform SDK&quot; also runs on Windows XP SP2 and Windows 2000.</source>
          <target state="translated">최신 버전의 Windows SDK를 구하십시오. 때때로 이러한 패키지에는 이름에 특정 Windows OS 버전이 포함되어 있지만 실제로는 다른 OS 버전에서도 작동합니다. 예를 들어 &quot;Windows Server 2003 R2 플랫폼 SDK&quot;는 Windows XP SP2 및 Windows 2000에서도 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="962ca701cc2570a663505435d963dc55f234f4d9" translate="yes" xml:space="preserve">
          <source>Trying to create a new child with a previous child still active (i.e., &lt;code&gt;finalize&lt;/code&gt; not called) will &lt;code&gt;croak&lt;/code&gt; .</source>
          <target state="translated">(즉, 활성 상태 이전의 아이 새 자식 만들려고 &lt;code&gt;finalize&lt;/code&gt; 합니다 호출되지 않습니다) &lt;code&gt;croak&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0c592184c4820418323672dd4337df40c4098b0" translate="yes" xml:space="preserve">
          <source>Trying to do too much</source>
          <target state="translated">너무 많은 일을하려고</target>
        </trans-unit>
        <trans-unit id="44d272c0c6193575553012dfbe62f22573eeb82f" translate="yes" xml:space="preserve">
          <source>Trying to run a test when you have an open child will also &lt;code&gt;croak&lt;/code&gt; and cause the test suite to fail.</source>
          <target state="translated">열린 아이가있을 때 테스트를 실행하려고하면 &lt;code&gt;croak&lt;/code&gt; 테스트 스위트가 실패하게됩니다.</target>
        </trans-unit>
        <trans-unit id="e1251ee8a07b3dea6c343e31961e5913e11f0ce3" translate="yes" xml:space="preserve">
          <source>Tune the internal settings for the deflate object &lt;code&gt;$d&lt;/code&gt; . This option is only available if you are running zlib 1.2.2.3 or better.</source>
          <target state="translated">수축 오브젝트 &lt;code&gt;$d&lt;/code&gt; 의 내부 설정을 조정하십시오 . 이 옵션은 zlib 1.2.2.3 이상을 실행중인 경우에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="008eee580921a65a5e935994d388ebe43c6df0cd" translate="yes" xml:space="preserve">
          <source>Tuning the way RESOLVE_SYMLINK will works</source>
          <target state="translated">RESOLVE_SYMLINK 작동 방식 조정</target>
        </trans-unit>
        <trans-unit id="f7db0bf3a9c02aa40e34f07d8431257fcf327327" translate="yes" xml:space="preserve">
          <source>Turn =head1 directives into links pointing to the top of the HTML file.</source>
          <target state="translated">= head1 지시문을 HTML 파일의 상단을 가리키는 링크로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="33f87dc87ea378d835e56e5bfd248ea1a352c832" translate="yes" xml:space="preserve">
          <source>Turn Pod into XML</source>
          <target state="translated">포드를 XML로 바꾸기</target>
        </trans-unit>
        <trans-unit id="8e7cc74dfcc71c13798fc4a8a0bda3cb164ed4c1" translate="yes" xml:space="preserve">
          <source>Turn Pod::Simple events into method calls</source>
          <target state="translated">Pod :: Simple 이벤트를 메소드 호출로 전환</target>
        </trans-unit>
        <trans-unit id="87a4a4a475f00352f77a10d3ec1fd9eee936c4ee" translate="yes" xml:space="preserve">
          <source>Turn off Apple tar's tendency to copy resource forks as &quot;._foo&quot; files.</source>
          <target state="translated">리소스 포크를 &quot;._foo&quot;파일로 복사하는 Apple tar의 경향을 끕니다.</target>
        </trans-unit>
        <trans-unit id="48d8224908b27731eb611ee5800a332f08bd6efe" translate="yes" xml:space="preserve">
          <source>Turn on colour in Test::Builder::Tester</source>
          <target state="translated">Test :: Builder :: Tester에서 색상 켜기</target>
        </trans-unit>
        <trans-unit id="3aaaf6cc176020f3991943f2032de33eccbdb645" translate="yes" xml:space="preserve">
          <source>Turn on debugging messages.</source>
          <target state="translated">디버깅 메시지를 켭니다.</target>
        </trans-unit>
        <trans-unit id="c5afa3624933dbb94708b864157bd75149a4bc45" translate="yes" xml:space="preserve">
          <source>Turn on the UTF-8 status of an SV (the data is not changed, just the flag). Do not use frivolously.</source>
          <target state="translated">SV의 UTF-8 상태를 켭니다 (데이터는 변경되지 않고 플래그 만). 경박하게 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="9903e627171cb3011421fef7af4a686d6ebc3e08" translate="yes" xml:space="preserve">
          <source>Turn on/off printing of warnings. Repeating &lt;b&gt;-warnings&lt;/b&gt; increases the warning level, i.e. more warnings are printed. Currently increasing to level two causes flagging of unescaped &quot;&amp;lt;,&amp;gt;&quot; characters.</source>
          <target state="translated">경고 인쇄를 켜거나 끕니다. 반복 &lt;b&gt;-warnings 것은&lt;/b&gt; 즉, 경고 수준, 더 경고가 인쇄됩니다 증가합니다. 현재 레벨 2로 증가하면 이스케이프 처리되지 않은 &quot;&amp;lt;,&amp;gt;&quot;문자가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d7dd646019946f4186b2c9415767806d113e6794" translate="yes" xml:space="preserve">
          <source>Turn warnings on/off.</source>
          <target state="translated">경고를 켜거나 끕니다.</target>
        </trans-unit>
        <trans-unit id="4c628137dd54154b5661d62a2c76528177ce2c0e" translate="yes" xml:space="preserve">
          <source>Turning on one of the character set flags with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re&lt;/code&gt; takes precedence over the &lt;code&gt;locale&lt;/code&gt; pragma and the 'unicode_strings' &lt;code&gt;feature&lt;/code&gt; , for regular expressions. Turning off one of these flags when it is active reverts to the behaviour specified by whatever other pragmata are in scope. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re&lt;/code&gt; 를 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하여 문자 세트 플래그 중 하나를 설정 하면 정규 표현식 의 &lt;code&gt;locale&lt;/code&gt; pragma 및 'unicode_strings' &lt;code&gt;feature&lt;/code&gt; 보다 우선 합니다. 활성화 될 때이 플래그 중 하나를 끄면 다른 pragmata가 지정한 범위 내에서 지정한 동작으로 되돌아갑니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1dac2f62695f453fd439059f0a117cf373d1f773" translate="yes" xml:space="preserve">
          <source>Turns every &lt;code&gt;head1&lt;/code&gt; heading into a link back to the top of the page. By default, no backlinks are generated.</source>
          <target state="translated">모든 &lt;code&gt;head1&lt;/code&gt; 제목을 페이지 맨 위로 링크로 바꿉니다 . 기본적으로 백 링크는 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="488b4a24fda23c677bfd758dfeda4e2b3e28ea5b" translate="yes" xml:space="preserve">
          <source>Turns on all &quot;extra&quot; debugging options.</source>
          <target state="translated">모든 &quot;추가&quot;디버깅 옵션을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="8a6abc6af101e3e68b329eb351f149732ea8c3d9" translate="yes" xml:space="preserve">
          <source>Turns on all compile related debug options.</source>
          <target state="translated">모든 컴파일 관련 디버그 옵션을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="377f42734b94211c01fa848b2645c0c159ecedcd" translate="yes" xml:space="preserve">
          <source>Turns on all execute related debug options.</source>
          <target state="translated">모든 관련 디버그 옵션 실행을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="cf78d64b4c15f8d89c3f09aea595a015508f3471" translate="yes" xml:space="preserve">
          <source>Turns on autoflush, print ARGS and then restores the autoflush status of the &lt;code&gt;IO::Handle&lt;/code&gt; object. Returns the return value from print.</source>
          <target state="translated">자동 플러시, 인쇄 ARGS를 켜고 &lt;code&gt;IO::Handle&lt;/code&gt; 개체 의 자동 플러시 상태를 복원 합니다. 인쇄 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2d1676fcc040bdf1deeab307eee1f9a1faa4d87a" translate="yes" xml:space="preserve">
          <source>Turns on debug output related to the process of parsing the pattern.</source>
          <target state="translated">패턴 구문 분석 프로세스와 관련된 디버그 출력을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="80ae89d796a9f5474c9cf55351133039b045499c" translate="yes" xml:space="preserve">
          <source>Turns on debugging</source>
          <target state="translated">디버깅을 켭니다</target>
        </trans-unit>
        <trans-unit id="0b71618ab3c580ced56e12be5afa8ca78d10b841" translate="yes" xml:space="preserve">
          <source>Turns on debugging of the main matching loop.</source>
          <target state="translated">기본 일치 루프의 디버깅을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="0d12b512bcc17c858f7f78847cab2c7f6461efd3" translate="yes" xml:space="preserve">
          <source>Turns on the magical status of an SV. See &lt;code&gt;sv_magic&lt;/code&gt; .</source>
          <target state="translated">SV의 마법 상태를 켭니다. &lt;code&gt;sv_magic&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b5ed69f1e400ca234d376650a653b6521d5c1651" translate="yes" xml:space="preserve">
          <source>Turns the @metadata_pairs into YAML.</source>
          <target state="translated">@metadata_pairs를 YAML로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="606c2af8d67a4d7dc7224ecdbb198b95627a3d18" translate="yes" xml:space="preserve">
          <source>Tutorial on making a new module.</source>
          <target state="translated">새로운 모듈 만들기에 대한 튜토리얼.</target>
        </trans-unit>
        <trans-unit id="654171647baa6be8557a5d627cf35c7075ebb257" translate="yes" xml:space="preserve">
          <source>Tutorials</source>
          <target state="translated">Tutorials</target>
        </trans-unit>
        <trans-unit id="4106aa6fe38782986e71b6df351f9eed9adc1100" translate="yes" xml:space="preserve">
          <source>Tutorials, end-user documentation, research papers, FAQs etc are not appropriate in a module's main documentation. If you really want to write these, include them as sub-documents such as &lt;code&gt;My::Module::Tutorial&lt;/code&gt; or &lt;code&gt;My::Module::FAQ&lt;/code&gt; and provide a link in the SEE ALSO section of the main documentation.</source>
          <target state="translated">모듈의 기본 설명서에는 자습서, 최종 사용자 설명서, 연구 논문, FAQ 등이 적합하지 않습니다. 실제로 작성하려면 &lt;code&gt;My::Module::Tutorial&lt;/code&gt; 또는 &lt;code&gt;My::Module::FAQ&lt;/code&gt; 와 같은 하위 문서로 포함시키고 기본 문서의 SEE ALSO 섹션에 링크를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="d4f6fcebc83fe08414440f2690253120c9bf99c3" translate="yes" xml:space="preserve">
          <source>Tweak the style of B::Deparse's output. The letters should follow directly after the 's', with no space or punctuation. The following options are available:</source>
          <target state="translated">B :: Deparse의 출력 스타일을 조정하십시오. 문자는 공백이나 문장 부호없이 's'바로 뒤에 와야합니다. 다음과 같은 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b77b783948e5ce8fbd237831d47a3e2aa25c8cf" translate="yes" xml:space="preserve">
          <source>Two additional extensions by Andreas Kaiser, &lt;code&gt;OS2::UPM&lt;/code&gt; , and &lt;code&gt;OS2::FTP&lt;/code&gt; , are included into &lt;code&gt;ILYAZ&lt;/code&gt; directory, mirrored on CPAN. Other OS/2-related extensions are available too.</source>
          <target state="translated">Andreas Kaiser의 &lt;code&gt;OS2::UPM&lt;/code&gt; 및 &lt;code&gt;OS2::FTP&lt;/code&gt; 추가 확장이 CPAN에서 미러링 된 &lt;code&gt;ILYAZ&lt;/code&gt; 디렉토리에 포함됩니다 . 다른 OS / 2 관련 확장도 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="225de66ed8612f5eaedcbe3517b9b8a030dd1dfb" translate="yes" xml:space="preserve">
          <source>Two additional fields &lt;code&gt;free&lt;/code&gt; , &lt;code&gt;used&lt;/code&gt; contain array references which provide per-bucket count of free and used chunks. Two other fields &lt;code&gt;mem_size&lt;/code&gt; , &lt;code&gt;available_size&lt;/code&gt; contain array references which provide the information about the allocated size and usable size of chunks in each bucket. Again, see &lt;a href=&quot;../perldebguts#Using-%24ENV%7bPERL_DEBUG_MSTATS%7d&quot;&gt;Using $ENV{PERL_DEBUG_MSTATS} in perldebguts&lt;/a&gt; for details.</source>
          <target state="translated">두 개의 추가 필드 &lt;code&gt;free&lt;/code&gt; , &lt;code&gt;used&lt;/code&gt; 무료로 사용 청크 당 버킷 수를 제공 배열 참조가 포함되어 있습니다. 다른 두 필드 &lt;code&gt;mem_size&lt;/code&gt; , &lt;code&gt;available_size&lt;/code&gt; 에는 각 버킷에서 할당 된 크기 및 사용 가능한 청크 크기에 대한 정보를 제공하는 배열 참조가 포함됩니다. 또, 참조 &lt;a href=&quot;../perldebguts#Using-%24ENV%7bPERL_DEBUG_MSTATS%7d&quot;&gt;perldebguts에서 $ ENV {PERL_DEBUG_MSTATS}를 사용하여&lt;/a&gt; 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="959e1dbe5c03b6bf54bd2c7c42f5c06de670abcf" translate="yes" xml:space="preserve">
          <source>Two arrays smartmatch if each element in the first array smartmatches (that is, is &quot;in&quot;) the corresponding element in the second array, recursively.</source>
          <target state="translated">첫 번째 배열의 각 요소가 두 번째 배열의 해당 요소와 재귀 적으로 일치하는 경우 (즉, &quot;in&quot;) 두 개의 배열이 스마트 일치합니다.</target>
        </trans-unit>
        <trans-unit id="ef9d289482c44cedd928e08a539e06da234c1ea2" translate="yes" xml:space="preserve">
          <source>Two directories</source>
          <target state="translated">두 개의 디렉토리</target>
        </trans-unit>
        <trans-unit id="4932b4ce84c4a3c76d97d8ddc1677ad9583f731a" translate="yes" xml:space="preserve">
          <source>Two exceptions are fseek() and ftell(). 32-bit applications should use fseeko(3C) and ftello(3C). These will get automatically mapped to fseeko64() and ftello64().</source>
          <target state="translated">fseek ()와 ftell ()은 예외입니다. 32 비트 응용 프로그램은 fseeko (3C) 및 ftello (3C)를 사용해야합니다. 이들은 fseeko64 () 및 ftello64 ​​()에 자동으로 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="59e6099a51676c8b357d47058d648615908e9535" translate="yes" xml:space="preserve">
          <source>Two functions are provided by</source>
          <target state="translated">두 가지 기능이 제공됩니다</target>
        </trans-unit>
        <trans-unit id="362495d14b1f3b1a8e9077a2b6d2d038307cf755" translate="yes" xml:space="preserve">
          <source>Two functions are provided to perform in-memory compression/uncompression of RFC 1950 data streams. They are called &lt;code&gt;compress&lt;/code&gt; and &lt;code&gt;uncompress&lt;/code&gt; .</source>
          <target state="translated">RFC 1950 데이터 스트림의 메모리 내 압축 / 압축 해제를 수행하는 두 가지 기능이 제공됩니다. &lt;code&gt;compress&lt;/code&gt; 및 &lt;code&gt;uncompress&lt;/code&gt; 라고 합니다.</target>
        </trans-unit>
        <trans-unit id="a1fae0daa00d9847553b4c2af0e0bfcf15f43ad2" translate="yes" xml:space="preserve">
          <source>Two hexadecimal numbers separated by horizontal whitespace (space or tabular characters) denoting a range of code points to include.</source>
          <target state="translated">포함 할 코드 포인트의 범위를 나타내는 가로 공백 (공백 또는 테이블 문자)으로 구분 된 두 개의 16 진수입니다.</target>
        </trans-unit>
        <trans-unit id="fc8d21d4a74e99aae1a5fc40b83d3fff90123b23" translate="yes" xml:space="preserve">
          <source>Two nested identical markup commands have been found. Generally this does not make sense.</source>
          <target state="translated">두 개의 동일한 동일한 마크 업 명령이 발견되었습니다. 일반적으로 이것은 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5e76b53030582383f7d551a5e77c668c449dbb3b" translate="yes" xml:space="preserve">
          <source>Two of the codes specified by the standard (XTS which is reserved for testing purposes and XXX which is for transactions where no currency is involved) are omitted.</source>
          <target state="translated">표준에 의해 지정된 두 가지 코드 (테스트 목적으로 예약 된 XTS와 통화가없는 거래를위한 XXX)는 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="a1d006aec19b5d26f771c4cb3b1aa7d14cd4a562" translate="yes" xml:space="preserve">
          <source>Two or more suspects remain</source>
          <target state="translated">두 명 이상의 용의자가 남아있다</target>
        </trans-unit>
        <trans-unit id="069f392f8b693bf3f912fa721edb551769786910" translate="yes" xml:space="preserve">
          <source>Two other &quot;encapsulation&quot; macros are the PERL_GLOBAL_STRUCT and PERL_GLOBAL_STRUCT_PRIVATE (the latter turns on the former, and the former turns on MULTIPLICITY.) The PERL_GLOBAL_STRUCT causes all the internal variables of Perl to be wrapped inside a single global struct, struct perl_vars, accessible as (globals) &amp;amp;PL_Vars or PL_VarsPtr or the function Perl_GetVars(). The PERL_GLOBAL_STRUCT_PRIVATE goes one step further, there is still a single struct (allocated in main() either from heap or from stack) but there are no global data symbols pointing to it. In either case the global struct should be initialized as the very first thing in main() using Perl_init_global_struct() and correspondingly tear it down after perl_free() using Perl_free_global_struct(), please see</source>
          <target state="translated">다른 두 개의 &quot;캡슐화&quot;매크로는 PERL_GLOBAL_STRUCT 및 PERL_GLOBAL_STRUCT_PRIVATE입니다 (후자는 전자를 켠 후 전자는 멀티를 켭니다). PERL_GLOBAL_STRUCT는 Perl의 모든 내부 변수가 단일 전역 구조체 내에 래핑되도록합니다. (전역) &amp;amp; PL_Vars 또는 PL_VarsPtr 또는 Perl_GetVars () 함수입니다. PERL_GLOBAL_STRUCT_PRIVATE는 한 걸음 더 나아갑니다. 힙이나 스택에서 main ()에 할당 된 단일 구조체가 있지만이를 가리키는 전역 데이터 기호는 없습니다. 어느 경우 든 전역 구조체는 Perl_init_global_struct ()를 사용하여 main ()에서 가장 먼저 초기화되어야하며, 이에 따라 Perl_free_global_struct ()를 사용하여 perl_free () 다음에 분리해야합니다.</target>
        </trans-unit>
        <trans-unit id="9e4d897b2c15b7e4e4ca9fbaec8aab25f6b14e93" translate="yes" xml:space="preserve">
          <source>Two possible uses (besides ignoring the property) come to mind. A singleton class could be implemented this using the generic object. If necessary, an &lt;code&gt;init()&lt;/code&gt; method could die or ignore calls with actual objects (references), so only the generic object will ever exist.</source>
          <target state="translated">(재산을 무시하는 것 외에) 두 가지 가능한 용도가 떠 오릅니다. 단일 객체 클래스를 일반 객체를 사용하여 구현할 수 있습니다. 필요한 경우, &lt;code&gt;init()&lt;/code&gt; 메소드는 실제 객체 (참조)에 대한 호출을 죽이거나 무시할 수 있으므로 일반 객체 만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="70abff015732d480e204353f739476e826fe7dc6" translate="yes" xml:space="preserve">
          <source>Two potentially non-obvious but traditional &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; semantics are that it waits indefinitely until the lock is granted, and that its locks are &lt;b&gt;merely advisory&lt;/b&gt;. Such discretionary locks are more flexible, but offer fewer guarantees. This means that programs that do not also use &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; may modify files locked with &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt;, your port's specific documentation, and your system-specific local manpages for details. It's best to assume traditional behavior if you're writing portable programs. (But if you're not, you should as always feel perfectly free to write for your own system's idiosyncrasies (sometimes called &quot;features&quot;). Slavish adherence to portability concerns shouldn't get in the way of your getting your job done.)</source>
          <target state="translated">잠재적으로 불명확하지만 전통적인 두 &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 의미론은 잠금이 부여 될 때까지 무기한 대기하고 잠금은 &lt;b&gt;단지 자문이라는 것&lt;/b&gt; 입니다. 이러한 임의 잠금은 더 융통성이 있지만 보장은 적습니다. 이 수단은 사용하지 않는 프로그램 것을 &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 파일을 수정할 수는 잠겨 &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; . &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt; 참조자세한 내용은 포트의 특정 설명서 및 시스템 별 로컬 맨 페이지를 참조하십시오. 휴대용 프로그램을 작성하는 경우 기존의 행동을 가정하는 것이 가장 좋습니다. (그렇지 않으면 항상 자신의 시스템 특질 ( &quot;기능&quot;이라고도 함)에 대해 자유롭게 작성해야합니다. 이식성 문제에 대한 엄격한 준수가 업무를 수행하는 데 방해가되지 않아야합니다.)</target>
        </trans-unit>
        <trans-unit id="3c9f59ec6423987c8c2fe5d0858f160205e3fc59" translate="yes" xml:space="preserve">
          <source>Two potentially non-obvious but traditional &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; semantics are that it waits indefinitely until the lock is granted, and that its locks are &lt;b&gt;merely advisory&lt;/b&gt;. Such discretionary locks are more flexible, but offer fewer guarantees. This means that programs that do not also use &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; may modify files locked with &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;, your port's specific documentation, and your system-specific local manpages for details. It's best to assume traditional behavior if you're writing portable programs. (But if you're not, you should as always feel perfectly free to write for your own system's idiosyncrasies (sometimes called &quot;features&quot;). Slavish adherence to portability concerns shouldn't get in the way of your getting your job done.)</source>
          <target state="translated">잠재적으로 불명확하지만 전통적인 두 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 의미론은 잠금이 부여 될 때까지 무기한 대기하고 잠금은 &lt;b&gt;단지 자문이라는 것&lt;/b&gt; 입니다. 이러한 임의 잠금은 더 융통성이 있지만 보장은 적습니다. 이 수단은 사용하지 않는 프로그램 것을 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 파일을 수정할 수는 잠겨 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; . &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; 참조자세한 내용은 포트의 특정 설명서 및 시스템 별 로컬 맨 페이지를 참조하십시오. 휴대용 프로그램을 작성하는 경우 기존의 행동을 가정하는 것이 가장 좋습니다. (그렇지 않으면 항상 자신의 시스템 특질 ( &quot;기능&quot;이라고도 함)에 대해 자유롭게 작성해야합니다. 이식성 문제에 대한 엄격한 준수가 업무를 수행하는 데 방해가되지 않아야합니다.)</target>
        </trans-unit>
        <trans-unit id="53df84b423920613232d12c96d5eb675ef01a9db" translate="yes" xml:space="preserve">
          <source>Two potentially non-obvious but traditional flock semantics are that it waits indefinitely until the lock is granted, and that its locks are</source>
          <target state="translated">잠재적으로 명확하지 않지만 기존의 두 무리 의미론은 잠금이 부여 될 때까지 무기한 대기하고 잠금이</target>
        </trans-unit>
        <trans-unit id="778a62aee9043b393531476babc83e7e729243c9" translate="yes" xml:space="preserve">
          <source>Two special locales are worth particular mention: &quot;C&quot; and &quot;POSIX&quot;. Currently these are effectively the same locale: the difference is mainly that the first one is defined by the C standard, the second by the POSIX standard. They define the &lt;b&gt;default locale&lt;/b&gt; in which every program starts in the absence of locale information in its environment. (The</source>
          <target state="translated">&quot;C&quot;와 &quot;POSIX&quot;라는 두 가지 특별한 로케일이 특별히 언급 될 가치가 있습니다. 현재 이들은 사실상 동일한 로케일입니다. 차이점은 주로 첫 번째는 C 표준으로, 두 번째는 POSIX 표준으로 정의된다는 것입니다. 환경에 로케일 정보가없는 상태에서 모든 프로그램이 시작되는 &lt;b&gt;기본 로케일&lt;/b&gt; 을 정의 합니다. (그만큼</target>
        </trans-unit>
        <trans-unit id="001ed180b265179aa35dbaf576484db20b8f3115" translate="yes" xml:space="preserve">
          <source>Two special marker lines will bracket debugging code, like this:</source>
          <target state="translated">두 개의 특수 마커 라인은 다음과 같이 디버깅 코드를 표시합니다</target>
        </trans-unit>
        <trans-unit id="fc4c89a57e0f51cea54d0e2e158fcc3083bc5fa2" translate="yes" xml:space="preserve">
          <source>Two threads both access &lt;code&gt;$x&lt;/code&gt; . Each thread can potentially be interrupted at any point, or be executed in any order. At the end, &lt;code&gt;$x&lt;/code&gt; could be 3 or 4, and both &lt;code&gt;$y&lt;/code&gt; and &lt;code&gt;$z&lt;/code&gt; could be 2 or 3.</source>
          <target state="translated">두 개의 스레드가 모두 &lt;code&gt;$x&lt;/code&gt; 액세스 합니다. 각 스레드는 잠재적으로 언제라도 중단되거나 순서에 관계없이 실행될 수 있습니다. 결국 &lt;code&gt;$x&lt;/code&gt; 는 3 또는 4가 될 수 있으며 &lt;code&gt;$y&lt;/code&gt; 와 &lt;code&gt;$z&lt;/code&gt; 는 2 또는 3이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a040608578e9e9c915007f47fc1e5b14ac218a6c" translate="yes" xml:space="preserve">
          <source>Two ways. One is to build the module normally...</source>
          <target state="translated">두 가지 방법. 하나는 모듈을 정상적으로 빌드하는 것입니다 ...</target>
        </trans-unit>
        <trans-unit id="aed361ca9a7b196027b5db9a2f0828216a331df8" translate="yes" xml:space="preserve">
          <source>Two's complement (bitwise not). This is equivalent to</source>
          <target state="translated">2의 보수 (비트 단위는 아님). 이것은</target>
        </trans-unit>
        <trans-unit id="639570380139caf69541c926ba46013c3318dc90" translate="yes" xml:space="preserve">
          <source>Two-face References</source>
          <target state="translated">양면 참조</target>
        </trans-unit>
        <trans-unit id="ae90b2c9e3f2f4b661468b3ddaef859dd9bff8a2" translate="yes" xml:space="preserve">
          <source>Two-face Scalars</source>
          <target state="translated">양면 스칼라</target>
        </trans-unit>
        <trans-unit id="47708aacd7aae4d98506843c2ea25848ad8c524c" translate="yes" xml:space="preserve">
          <source>Tying Arrays</source>
          <target state="translated">배열 묶기</target>
        </trans-unit>
        <trans-unit id="29fe0e127980eab253dd9684cf8924d1439a9c07" translate="yes" xml:space="preserve">
          <source>Tying Arrays by Casey West &amp;lt;</source>
          <target state="translated">Casey West로 배열 묶기 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="1cb864932b4ba6b40040bda147b28500825da685" translate="yes" xml:space="preserve">
          <source>Tying FileHandles</source>
          <target state="translated">파일 핸들링</target>
        </trans-unit>
        <trans-unit id="c44951e9133e5d8875fa8e60d17eb7ca4e5ec846" translate="yes" xml:space="preserve">
          <source>Tying Hashes</source>
          <target state="translated">해시 묶기</target>
        </trans-unit>
        <trans-unit id="c124692dc36c13d6ea9eefe451091514b3053308" translate="yes" xml:space="preserve">
          <source>Tying Scalars</source>
          <target state="translated">스칼라 매기</target>
        </trans-unit>
        <trans-unit id="dd441f6c670bdd175a4a06606b3ade32864a5013" translate="yes" xml:space="preserve">
          <source>Tying to an already-opened filehandle</source>
          <target state="translated">이미 열린 파일 핸들에 연결</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="622fe690390119c9b2836b529615b923c08f64da" translate="yes" xml:space="preserve">
          <source>Type &quot;dmake install&quot; (or &quot;nmake install&quot;). This will put the newly built perl and the libraries under whatever &lt;code&gt;INST_TOP&lt;/code&gt; points to in the Makefile. It will also install the pod documentation under &lt;code&gt;$INST_TOP\$INST_VER\lib\pod&lt;/code&gt; and HTML versions of the same under &lt;code&gt;$INST_TOP\$INST_VER\lib\pod\html&lt;/code&gt; .</source>
          <target state="translated">&quot;dmake install&quot;(또는 &quot;nmake install&quot;)을 입력하십시오. 이렇게하면 새로 구축 된 perl과 라이브러리 가 Makefile에서 가리키는 &lt;code&gt;INST_TOP&lt;/code&gt; 아래에 놓 입니다. 또한 &lt;code&gt;$INST_TOP\$INST_VER\lib\pod&lt;/code&gt; 포드 문서를 설치하고 &lt;code&gt;$INST_TOP\$INST_VER\lib\pod\html&lt;/code&gt; HTML 버전을 설치합니다 .</target>
        </trans-unit>
        <trans-unit id="48996994efbc36adb9197c655f8807f921339671" translate="yes" xml:space="preserve">
          <source>Type &quot;dmake test&quot; (or &quot;nmake test&quot;). This will run most of the tests from the testsuite (many tests will be skipped).</source>
          <target state="translated">&quot;dmake test&quot;(또는 &quot;nmake test&quot;)를 입력하십시오. 테스트 슈트에서 대부분의 테스트가 실행됩니다 (많은 테스트는 건너 뜁니다).</target>
        </trans-unit>
        <trans-unit id="e707f55e50471f8dc7a11eb61a45491656e65c20" translate="yes" xml:space="preserve">
          <source>Type &quot;dmake&quot; (or &quot;nmake&quot; if you are using that make).</source>
          <target state="translated">&quot;dmake&quot;(또는 해당 make를 사용하는 경우 &quot;nmake&quot;)를 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="817cc5b4f0c413465ec1e98078f923e58ba436f8" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;perl -v&lt;/code&gt; at the command line to find out.</source>
          <target state="translated">명령 행에 &lt;code&gt;perl -v&lt;/code&gt; 를 입력 하여 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="470a91ba8a41cc959ff1b12a936c2603408f2a81" translate="yes" xml:space="preserve">
          <source>Type flag for I/O objects. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">I / O 오브젝트의 유형 플래그. &lt;a href=&quot;#svtype&quot;&gt;svtype을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="115e0f5825d2a5e2437586f43a3052a4bc413be2" translate="yes" xml:space="preserve">
          <source>Type flag for arrays. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">배열의 타입 플래그. &lt;a href=&quot;#svtype&quot;&gt;svtype을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5424ebb415da653ce11cbaa80efe5caaa204e71c" translate="yes" xml:space="preserve">
          <source>Type flag for formats. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">형식에 대한 유형 플래그. &lt;a href=&quot;#svtype&quot;&gt;svtype을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="11f3d189f9118d5a6a717d6df4d8bfc5dd5c80fb" translate="yes" xml:space="preserve">
          <source>Type flag for hashes. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">해시에 대한 유형 플래그. &lt;a href=&quot;#svtype&quot;&gt;svtype을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7697ce082ff72de4bd1f6e232aec1e708c3e949b" translate="yes" xml:space="preserve">
          <source>Type flag for regular expressions. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">정규식에 대한 유형 플래그. &lt;a href=&quot;#svtype&quot;&gt;svtype을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8842ec0ce8ceed5f394b670f4b4d43838af8af85" translate="yes" xml:space="preserve">
          <source>Type flag for scalars. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">스칼라에 대한 유형 플래그. &lt;a href=&quot;#svtype&quot;&gt;svtype을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ba6e0906867866e6b4c76c1aa73ce8fb1ddab2a4" translate="yes" xml:space="preserve">
          <source>Type flag for subroutines. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">서브 루틴의 유형 플래그. &lt;a href=&quot;#svtype&quot;&gt;svtype을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5d98af6202cdf505f81d6de89907f306acd604bb" translate="yes" xml:space="preserve">
          <source>Type flag for typeglobs. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">typeglobs의 타입 플래그. &lt;a href=&quot;#svtype&quot;&gt;svtype을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e47d64cc94d0acfc0cdbf0b2c9dd711351e0f339" translate="yes" xml:space="preserve">
          <source>Type of first matching node.</source>
          <target state="translated">첫 번째 일치 노드의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="82be69629fdb03e428153252cb628a3089333b85" translate="yes" xml:space="preserve">
          <source>Type-casting operator.</source>
          <target state="translated">타입 캐스팅 연산자.</target>
        </trans-unit>
        <trans-unit id="3c6b62766a1a668fd13ee2f54c72526e46bdd675" translate="yes" xml:space="preserve">
          <source>Type-specific attribute handlers</source>
          <target state="translated">유형별 속성 핸들러</target>
        </trans-unit>
        <trans-unit id="ee3fb11d05c90c37311491cf33008925b13b487f" translate="yes" xml:space="preserve">
          <source>Type:</source>
          <target state="translated">Type:</target>
        </trans-unit>
        <trans-unit id="dacaa1ce7373acde846ee256ee267058f226c8cb" translate="yes" xml:space="preserve">
          <source>Typed lexicals</source>
          <target state="translated">유형 어휘</target>
        </trans-unit>
        <trans-unit id="35c58169317903405f89e446350d7099fc17650c" translate="yes" xml:space="preserve">
          <source>Typeglobs and Filehandles</source>
          <target state="translated">타입 글롭과 파일 핸들</target>
        </trans-unit>
        <trans-unit id="c93af0f29f506026f9bce190608810109efe41de" translate="yes" xml:space="preserve">
          <source>Typeglobs are also a way to create a local filehandle using the local() operator. These last until their block is exited, but may be passed back. For example:</source>
          <target state="translated">Typeglobs는 local () 연산자를 사용하여 로컬 파일 핸들을 만드는 방법이기도합니다. 블록이 종료 될 때까지 지속되지만 다시 전달 될 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7c854e2c86ed5ebd580cf024fab8796f99c1a0f9" translate="yes" xml:space="preserve">
          <source>Types of Nodes</source>
          <target state="translated">노드의 종류</target>
        </trans-unit>
        <trans-unit id="54a79ea7d31cf3e80acf5e2ca6b3eef126289136" translate="yes" xml:space="preserve">
          <source>Typical frequently used settings:</source>
          <target state="translated">자주 사용되는 설정 :</target>
        </trans-unit>
        <trans-unit id="eeee45f0582f2da790f6df23acb83c5b9ac37e5b" translate="yes" xml:space="preserve">
          <source>Typical usage is just:</source>
          <target state="translated">일반적인 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9f433de3a09f2cf5cd13a827c57725457d725e39" translate="yes" xml:space="preserve">
          <source>Typical usage:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0a20c31caa817cfde9a5903c8d1331d2cc5ddae" translate="yes" xml:space="preserve">
          <source>Typical use is to do range checks on &lt;code&gt;uv&lt;/code&gt; before casting:</source>
          <target state="translated">일반적으로 캐스팅 전에 &lt;code&gt;uv&lt;/code&gt; 에서 범위 검사를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="0f7c555ca8af58d8be6641bce4c54e1f92594d54" translate="yes" xml:space="preserve">
          <source>Typical use of AutoSplit in the perl MakeMaker utility is via the command-line with:</source>
          <target state="translated">perl MakeMaker 유틸리티에서 AutoSplit의 일반적인 사용은 다음과 같은 명령 행을 통해 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="2eb42fd8be2849b836904fd8c0478452015d5021" translate="yes" xml:space="preserve">
          <source>Typically displayed in italics. Example: &quot;&lt;code&gt;F&amp;lt;.cshrc&amp;gt;&lt;/code&gt; &quot;</source>
          <target state="translated">일반적으로 기울임 꼴로 표시됩니다. 예 : &quot; &lt;code&gt;F&amp;lt;.cshrc&amp;gt;&lt;/code&gt; &quot;</target>
        </trans-unit>
        <trans-unit id="0b14febd4050c6e9e7fff1ec1a1e04a32b2411b9" translate="yes" xml:space="preserve">
          <source>Typically render into NFD on input and NFC on output. Using NFKC or NFKD functions improves recall on searches, assuming you've already done to the same text to be searched. Note that this is about much more than just pre- combined compatibility glyphs; it also reorders marks according to their canonical combining classes and weeds out singletons.</source>
          <target state="translated">일반적으로 입력시 NFD로, 출력시 NFC로 렌더링합니다. NFKC 또는 NFKD 기능을 사용하면 검색 할 동일한 텍스트를 이미 수행했다고 가정 할 때 검색시 재 호출이 향상됩니다. 이것은 단지 사전 결합 된 호환성 글리프 이상이 아닙니다. 또한 정식 결합 클래스에 따라 마크를 재정렬하고 싱글 톤을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="b5c564109e8a3afa5be0b031d855d9ae4aa0bbb3" translate="yes" xml:space="preserve">
          <source>Typically this is used to emulate &lt;code&gt;#!&lt;/code&gt; startup on platforms that don't support &lt;code&gt;#!&lt;/code&gt; . It's also convenient when debugging a script that uses &lt;code&gt;#!&lt;/code&gt; , and is thus normally found by the shell's $PATH search mechanism.</source>
          <target state="translated">일반적으로 &lt;code&gt;#!&lt;/code&gt; &lt;code&gt;#!&lt;/code&gt; 지원하지 않는 플랫폼에서 시작 ! . &lt;code&gt;#!&lt;/code&gt; 을 사용하는 스크립트를 디버깅 할 때도 편리합니다 ! 따라서 일반적으로 쉘의 $ PATH 검색 메커니즘에 의해 발견됩니다.</target>
        </trans-unit>
        <trans-unit id="687058d347f26c3b9dcf0508ed2f5930b5b6fa48" translate="yes" xml:space="preserve">
          <source>Typically used to finish the deflation. Any pending output will be returned via &lt;code&gt;$out&lt;/code&gt; . &lt;code&gt;$status&lt;/code&gt; will have a value &lt;code&gt;Z_OK&lt;/code&gt; if successful.</source>
          <target state="translated">일반적으로 수축을 완료하는 데 사용됩니다. 보류중인 출력은 &lt;code&gt;$out&lt;/code&gt; 통해 반환 됩니다 . 성공하면 &lt;code&gt;$status&lt;/code&gt; 의 값은 &lt;code&gt;Z_OK&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="01a46f6fee05faa753caaabc6b43de594c708bd4" translate="yes" xml:space="preserve">
          <source>Typically used to finish the deflation. Any pending output will be written to &lt;code&gt;$output&lt;/code&gt; .</source>
          <target state="translated">일반적으로 수축을 완료하는 데 사용됩니다. 보류중인 출력은 &lt;code&gt;$output&lt;/code&gt; 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="6622b7497b5ad854ceef3d9e6b7f39de4b5a746f" translate="yes" xml:space="preserve">
          <source>Typically will call &lt;code&gt;Fill&lt;/code&gt; and manipulate pointers (possibly via the API). &lt;code&gt;PerlIOBuf_read()&lt;/code&gt; may be suitable for derived classes which provide &quot;fast gets&quot; methods.</source>
          <target state="translated">일반적으로 &lt;code&gt;Fill&lt;/code&gt; 을 호출 하고 포인터를 조작합니다 (API를 통해 가능). &lt;code&gt;PerlIOBuf_read()&lt;/code&gt; 는 &quot;fast gets&quot;메소드를 제공하는 파생 클래스에 적합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb1290094db39111daed12026731de41d874265c" translate="yes" xml:space="preserve">
          <source>Typically you only need to set this if you are using nonstandard prefixes and want some or all of them to have the same semantics as '--' does under normal circumstances.</source>
          <target state="translated">일반적으로 비표준 접두사를 사용하고 일부 또는 모든 접두사가 정상적인 상황에서 '-'와 동일한 의미를 갖기를 원할 경우에만 설정하면됩니다.</target>
        </trans-unit>
        <trans-unit id="bbb5689bb894bcd45bb2427b7ffbb2ba5d9ac28a" translate="yes" xml:space="preserve">
          <source>Typically you use the &lt;code&gt;\G&lt;/code&gt; anchor with the &lt;code&gt;c&lt;/code&gt; flag when you want to try a different match if one fails, such as in a tokenizer. Jeffrey Friedl offers this example which works in 5.004 or later.</source>
          <target state="translated">일반적으로 토크 나이저와 같이 다른 일치 항목이 실패하면 &lt;code&gt;\G&lt;/code&gt; 앵커를 &lt;code&gt;c&lt;/code&gt; 플래그 와 함께 사용합니다 . Jeffrey Friedl은 5.004 이상에서 작동하는이 예제를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="291f2d298dd4e6053c773023592956eee5655566" translate="yes" xml:space="preserve">
          <source>Typically, Perl tests are run through this. However, anything which spits out TAP is fine. You can use this argument to specify the name of the program (and optional switches) to run your tests with:</source>
          <target state="translated">일반적으로 Perl 테스트는이를 통해 실행됩니다. 그러나 TAP를 뱉어내는 것은 괜찮습니다. 이 인수를 사용하여 다음과 같이 테스트를 실행할 프로그램 이름 (및 선택적 스위치)을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc1a3db1817e4391406ea8e4c10b938d812a2baf" translate="yes" xml:space="preserve">
          <source>Typically, a C compiler allocates 12 bytes to a &lt;code&gt;gappy_t&lt;/code&gt; variable, but requires only 8 bytes for a &lt;code&gt;dense_t&lt;/code&gt; . After investigating this further, we can draw memory maps, showing where the extra 4 bytes are hidden:</source>
          <target state="translated">일반적으로, C 컴파일러는 12 바이트를 할당 &lt;code&gt;gappy_t&lt;/code&gt; 의 가변이지만에만 8 바이트 요구 &lt;code&gt;dense_t&lt;/code&gt; 를 . 이것을 더 조사한 후, 여분의 4 바이트가 숨겨지는 곳을 보여주는 메모리 맵을 그릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83c91d2712bb90187ca081aa74ad37d202d5e800" translate="yes" xml:space="preserve">
          <source>Typically, however, things are the other way around: the tieable class expects its arguments as a flattened list, so the attribute looks like:</source>
          <target state="translated">그러나 일반적으로 다른 방법은 다음과 같습니다. 연결 가능한 클래스는 인수를 병합 된 목록으로 예상하므로 속성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a2dcf9e9fce909e6d70f7fd2b928940489e6fad5" translate="yes" xml:space="preserve">
          <source>Typing &quot;buildtype d off&quot; or &quot;buildtype d&quot; at the command prompt causes the buildtype to be set to Debug type with D1 flag set.</source>
          <target state="translated">명령 프롬프트에서 &quot;buildtype d off&quot;또는 &quot;buildtype d&quot;를 입력하면 D1 플래그가 설정된 상태에서 빌드 유형이 디버그 유형으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b2c7510e598f94047792f2e34322c55a1d654ee0" translate="yes" xml:space="preserve">
          <source>Typing &quot;buildtype d on&quot; at the command prompt causes the buildtype to be set to Debug type with D2 flag set.</source>
          <target state="translated">명령 프롬프트에서 &quot;buildtype d on&quot;을 입력하면 빌드 유형이 D2 플래그가 설정된 디버그 유형으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="6127511edf886df0417540a81474ffb3800e60b7" translate="yes" xml:space="preserve">
          <source>Typing &quot;buildtype r&quot; at the command prompt sets it to Release Build type.</source>
          <target state="translated">명령 프롬프트에서 &quot;buildtype r&quot;을 입력하면 Release Build type으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b2c7c0caa10a0cca5ea7d69e54018ae0c0389dd6" translate="yes" xml:space="preserve">
          <source>U</source>
          <target state="translated">U</target>
        </trans-unit>
        <trans-unit id="70ae2f8ea36eac22765cdf44837146969d083d4c" translate="yes" xml:space="preserve">
          <source>U/WIN specific subclass of ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils :: MM_Unix의 U / WIN 특정 서브 클래스</target>
        </trans-unit>
        <trans-unit id="3a333ea8bebfa50b73219f11f7bf0ebbb8c9a863" translate="yes" xml:space="preserve">
          <source>UCA recommends that out-of-range values should not be ignored for security reasons. Say, &lt;code&gt;&quot;pe\x{110000}rl&quot;&lt;/code&gt; should not be equal to &lt;code&gt;&quot;perl&quot;&lt;/code&gt; . However, &lt;code&gt;U+FFFD&lt;/code&gt; is wrongly mapped to a variable collation element in DUCET for Unicode 6.0.0 to 6.2.0, that means out-of-range values will be ignored when &lt;code&gt;variable&lt;/code&gt; isn't &lt;code&gt;Non-ignorable&lt;/code&gt; .</source>
          <target state="translated">UCA는 범위를 벗어난 값은 보안상의 이유로 무시하지 말 것을 권장합니다. 말, &lt;code&gt;&quot;pe\x{110000}rl&quot;&lt;/code&gt; 동일 안된다 &lt;code&gt;&quot;perl&quot;&lt;/code&gt; . 그러나 &lt;code&gt;U+FFFD&lt;/code&gt; 는 유니 코드 6.0.0 ~ 6.2.0 용 DUCET의 변수 데이터 정렬 요소에 잘못 맵핑됩니다. 즉, &lt;code&gt;variable&lt;/code&gt; 가 &lt;code&gt;Non-ignorable&lt;/code&gt; 없는 경우 범위를 벗어난 값은 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="206177d23e4d5ec0abfb5c6b0df396d679742e7c" translate="yes" xml:space="preserve">
          <source>UCS-2 is a fixed-length encoding with each character taking 16 bits. It &lt;b&gt;does not&lt;/b&gt; support</source>
          <target state="translated">UCS-2는 각 문자가 16 비트를 사용하는 고정 길이 인코딩입니다. 그것은 &lt;b&gt;하지 않습니다&lt;/b&gt; 지원</target>
        </trans-unit>
        <trans-unit id="daeba9311089266fcf0acd6d54c9e56ca13a992e" translate="yes" xml:space="preserve">
          <source>UCS-2, UCS-4</source>
          <target state="translated">UCS-2, UCS-4</target>
        </trans-unit>
        <trans-unit id="a392dc8e430c846ca90f8e40c79fda571eef8daf" translate="yes" xml:space="preserve">
          <source>UDP datagrams are</source>
          <target state="translated">UDP 데이터 그램은</target>
        </trans-unit>
        <trans-unit id="0b1ddbe7e9085079ee7967600cb1889fd0b548d1" translate="yes" xml:space="preserve">
          <source>UDP: Message Passing</source>
          <target state="translated">UDP : 메시지 전달</target>
        </trans-unit>
        <trans-unit id="74ff590c1dac1161eec0fbaa8b7d8b3a98fff4d5" translate="yes" xml:space="preserve">
          <source>UNICODE AND SIDE EFFECTS</source>
          <target state="translated">유니 코드 및 부작용</target>
        </trans-unit>
        <trans-unit id="0f9d971f52bdd7a74ebeb786ec5143de4c2935d5" translate="yes" xml:space="preserve">
          <source>UNICODE IN OLDER PERLS</source>
          <target state="translated">오래된 PERLS의 유니 코드</target>
        </trans-unit>
        <trans-unit id="94c5e5979031dbec3b6f240558b2bfaa36f46791" translate="yes" xml:space="preserve">
          <source>UNIMPLEMENTED</source>
          <target state="translated">UNIMPLEMENTED</target>
        </trans-unit>
        <trans-unit id="9392ee60535a3aa7bb3335f263044b78e27554ed" translate="yes" xml:space="preserve">
          <source>UNISTD</source>
          <target state="translated">UNISTD</target>
        </trans-unit>
        <trans-unit id="c070755890afd262edf57a1cfae99ffc017d2459" translate="yes" xml:space="preserve">
          <source>UNITCHECK</source>
          <target state="translated">UNITCHECK</target>
        </trans-unit>
        <trans-unit id="bc192a928ab3fe78a1c74cfa4d1027b44d52c868" translate="yes" xml:space="preserve">
          <source>UNIVERSAL</source>
          <target state="translated">UNIVERSAL</target>
        </trans-unit>
        <trans-unit id="1feda7e9d1b1a232e025eeb903dd53659f7b069c" translate="yes" xml:space="preserve">
          <source>UNIVERSAL - base class for ALL classes (blessed references)</source>
          <target state="translated">UNIVERSAL-모든 클래스의 기본 클래스 (축복 참조)</target>
        </trans-unit>
        <trans-unit id="b23387c60700d885c584c4f2b25855ad58b48b48" translate="yes" xml:space="preserve">
          <source>UNIX and POSIX systems provide an abstract access() operating system call, which should be used to query the read, write, and execute rights. This function hides various distinct approaches in additional operating system specific security features, like Access Control Lists (ACLs)</source>
          <target state="translated">UNIX 및 POSIX 시스템은 읽기, 쓰기 및 실행 권한을 쿼리하는 데 사용해야하는 추상 access () 운영 체제 호출을 제공합니다. 이 기능은 액세스 제어 목록 (ACL)과 같은 추가 운영 체제 별 보안 기능에서 다양한 접근 방식을 숨 깁니다.</target>
        </trans-unit>
        <trans-unit id="fa0c8b9587852cbf0dc08f98bcecbaed53f1e1c0" translate="yes" xml:space="preserve">
          <source>UNIX domain sockets added by Sean Robinson &amp;lt;</source>
          <target state="translated">Sean Robinson이 추가 한 UNIX 도메인 소켓 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="85db2499d39f4696e02fb26511b230add2c1b670" translate="yes" xml:space="preserve">
          <source>UNIX file permissions are based on sets of mode bits for {read,write,execute} for each {user,group,other}. By default Cygwin only tracks the Win32 read-only attribute represented as the UNIX file user write bit (files are always readable, files are executable if they have a</source>
          <target state="translated">UNIX 파일 권한은 각 {user, group, other}에 대한 {read, write, execute}에 대한 모드 비트 세트를 기반으로합니다. 기본적으로 Cygwin은 UNIX 파일 사용자 쓰기 비트로 표시되는 Win32 읽기 전용 속성 만 추적합니다 (파일은 항상 읽을 수 있고 파일은</target>
        </trans-unit>
        <trans-unit id="5b8f1af6e17a29d4f20f56ec6d442f59acfc755d" translate="yes" xml:space="preserve">
          <source>UNSUPPORTED</source>
          <target state="translated">UNSUPPORTED</target>
        </trans-unit>
        <trans-unit id="40cccdd49a4b2f7980664d02999aa7b9e3022b50" translate="yes" xml:space="preserve">
          <source>UNTIE by Nick Ing-Simmons &amp;lt;</source>
          <target state="translated">닉 잉 시몬스의 UNTIE &amp;lt;</target>
        </trans-unit>
        <trans-unit id="41304503568dff57766f35c33ebaca45f5e827b2" translate="yes" xml:space="preserve">
          <source>UNTIE this</source>
          <target state="translated">이것을 풀다</target>
        </trans-unit>
        <trans-unit id="e3bb3273c3d27a35e7a79c09d285ae651319171c" translate="yes" xml:space="preserve">
          <source>UPGRADING</source>
          <target state="translated">UPGRADING</target>
        </trans-unit>
        <trans-unit id="a6b6b187a5dabe1711e09378ba034929cf5397f3" translate="yes" xml:space="preserve">
          <source>UPSTREAM indicates where patches should go. &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; implies that this hasn't been discussed for the module at hand. &lt;code&gt;blead&lt;/code&gt; indicates that the copy of the module in the blead sources is to be considered canonical, &lt;code&gt;cpan&lt;/code&gt; means that the module on CPAN is to be patched first. &lt;code&gt;first-come&lt;/code&gt; means that blead can be patched freely if it is in sync with the latest release on CPAN.</source>
          <target state="translated">UPSTREAM은 패치의 위치를 ​​나타냅니다. &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 는 현재 모듈에 대해서는 논의되지 않았 음을 의미합니다. &lt;code&gt;blead&lt;/code&gt; 는 블리드 소스의 모듈 사본이 정식으로 간주됨을 나타내며 &lt;code&gt;cpan&lt;/code&gt; 은 CPAN의 모듈을 먼저 패치해야 함을 의미합니다. &lt;code&gt;first-come&lt;/code&gt; 은 블리드가 CPAN의 최신 릴리스와 동기화 된 경우 자유롭게 패치 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ba5e5280eb88749f4ed2bd7802c151c1f77cb3d7" translate="yes" xml:space="preserve">
          <source>URL decoding and encoding</source>
          <target state="translated">URL 디코딩 및 인코딩</target>
        </trans-unit>
        <trans-unit id="61aff325c59f0125c7432101521fe8aef2d620f8" translate="yes" xml:space="preserve">
          <source>URLS</source>
          <target state="translated">URLS</target>
        </trans-unit>
        <trans-unit id="cf3bfa9a159c5a5ddc20da1eccd6bbddbdc037e4" translate="yes" xml:space="preserve">
          <source>USAGE</source>
          <target state="translated">USAGE</target>
        </trans-unit>
        <trans-unit id="3ca88d77aca2d323542d2e8f12b83151e0846c19" translate="yes" xml:space="preserve">
          <source>USE EXAMPLES</source>
          <target state="translated">사용 예</target>
        </trans-unit>
        <trans-unit id="045095377d72052bacadc70846f65ba919bc72ee" translate="yes" xml:space="preserve">
          <source>USER METHODS</source>
          <target state="translated">사용자 방법</target>
        </trans-unit>
        <trans-unit id="eff0e1414e1813c02157d57d3f325f32947a8413" translate="yes" xml:space="preserve">
          <source>USE_MULTI &amp;amp; USE_IMP_SYS defined and USE_ITHREADS not defined</source>
          <target state="translated">USE_MULTI &amp;amp; USE_IMP_SYS 정의 및 USE_ITHREADS 정의되지 않음</target>
        </trans-unit>
        <trans-unit id="5e29b7b3b7536de15b46013805cfeb875c7a61d3" translate="yes" xml:space="preserve">
          <source>USE_MULTI, USE_ITHREADS &amp;amp; USE_IMP_SYS defined</source>
          <target state="translated">USE_MULTI, USE_ITHREADS 및 USE_IMP_SYS 정의</target>
        </trans-unit>
        <trans-unit id="227996d58fdfdee97220bd395f44c03336330289" translate="yes" xml:space="preserve">
          <source>USE_PERL_FLOCK</source>
          <target state="translated">USE_PERL_FLOCK</target>
        </trans-unit>
        <trans-unit id="d403f19c30d9dafcf5b6a7bb8666159dacf7697f" translate="yes" xml:space="preserve">
          <source>USING B::Deparse AS A MODULE</source>
          <target state="translated">B :: 모듈로 사용</target>
        </trans-unit>
        <trans-unit id="2efa10816450d527d9e56d3271b7e34ea8c81a61" translate="yes" xml:space="preserve">
          <source>USING CONTEXT: THE DEBUG FILTER</source>
          <target state="translated">컨텍스트 사용하기 : 디버그 필터</target>
        </trans-unit>
        <trans-unit id="5dc41a076ce2820059919cbbf35a7c867770cef6" translate="yes" xml:space="preserve">
          <source>USING FILTERS</source>
          <target state="translated">필터 사용</target>
        </trans-unit>
        <trans-unit id="3d73074a3cddd39278e855bf130287734b3a28e3" translate="yes" xml:space="preserve">
          <source>USING LOCALES</source>
          <target state="translated">로캘 사용</target>
        </trans-unit>
        <trans-unit id="e914e6326e1588417f534e760a668a311b7406cd" translate="yes" xml:space="preserve">
          <source>USING PERL IN OPENVOS</source>
          <target state="translated">OPENVOS에서 PERL 사용</target>
        </trans-unit>
        <trans-unit id="ac35aec57e40ba482f8f9fa734ce439013d2f6b2" translate="yes" xml:space="preserve">
          <source>USING THE EXTERNAL GZIP</source>
          <target state="translated">외부 GZIP 사용</target>
        </trans-unit>
        <trans-unit id="6af50db97d3b4d2d4a30cc3bc98a5ffb4cb39ec7" translate="yes" xml:space="preserve">
          <source>USourceData.txt</source>
          <target state="translated">USourceData.txt</target>
        </trans-unit>
        <trans-unit id="6b28c2250a1cbb7c8f56dfcf0dd9e06201c35f2f" translate="yes" xml:space="preserve">
          <source>UTF stands for &quot;Unicode Transformation Format&quot;. UTF-8 is an encoding of Unicode into a sequence of 8-bit byte chunks, based on ASCII and Latin-1. The length of a sequence required to represent a Unicode code point depends on the ordinal number of that code point, with larger numbers requiring more bytes. UTF-EBCDIC is like UTF-8, but based on EBCDIC. They are enough alike that often, casual usage will conflate the two terms, and use &quot;UTF-8&quot; to mean both the UTF-8 found on ASCII platforms, and the UTF-EBCDIC found on EBCDIC ones.</source>
          <target state="translated">UTF는 &quot;유니 코드 변환 형식&quot;을 나타냅니다. UTF-8은 ASCII 및 Latin-1을 기반으로 유니 코드를 8 비트 바이트 청크 시퀀스로 인코딩 한 것입니다. 유니 코드 코드 포인트를 나타내는 데 필요한 시퀀스 길이는 해당 코드 포인트의 서수에 따라 달라지며 더 큰 숫자는 더 많은 바이트를 필요로합니다. UTF-EBCDIC는 UTF-8과 유사하지만 EBCDIC를 기반으로합니다. 그것들은 종종 일상적인 사용법이 두 용어를 혼동하고 &quot;UTF-8&quot;을 사용하여 ASCII 플랫폼에서 발견되는 UTF-8과 EBCDIC에서 발견되는 UTF-EBCDIC을 모두 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c965e907f9d25c517a8e5bd79aea9417a0714217" translate="yes" xml:space="preserve">
          <source>UTF-16 is almost the same as UCS-2 but it supports</source>
          <target state="translated">UTF-16은 UCS-2와 거의 동일하지만 지원합니다</target>
        </trans-unit>
        <trans-unit id="5222e4ab75ba1ce305284f282ec30a73156a366c" translate="yes" xml:space="preserve">
          <source>UTF-16, UTF-16BE, UTF-16LE, Surrogates, and &lt;code&gt;BOM&lt;/code&gt; 's (Byte Order Marks)</source>
          <target state="translated">UTF-16, UTF-16BE, UTF-16LE, 대리 및 &lt;code&gt;BOM&lt;/code&gt; (바이트 순서 표시)</target>
        </trans-unit>
        <trans-unit id="47a1ff59a1e826be6636526f502c21d7b7b97ead" translate="yes" xml:space="preserve">
          <source>UTF-32 (UCS-4) is a fixed-length encoding with each character taking 32 bits. Since it is 32-bit, there is no need for</source>
          <target state="translated">UTF-32 (UCS-4)는 각 문자가 32 비트를 사용하는 고정 길이 인코딩입니다. 32 비트이므로 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dfd8dce020ef601007001e4289b99a7908444d8a" translate="yes" xml:space="preserve">
          <source>UTF-32, UTF-32BE, UTF-32LE</source>
          <target state="translated">UTF-32, UTF-32BE, UTF-32LE</target>
        </trans-unit>
        <trans-unit id="20e199acc434517cd4a6e5977a48bae6e5af47a4" translate="yes" xml:space="preserve">
          <source>UTF-7</source>
          <target state="translated">UTF-7</target>
        </trans-unit>
        <trans-unit id="4d56cb8e2ad2a50613de9fa7d9d9a0d239c1aca9" translate="yes" xml:space="preserve">
          <source>UTF-7 encoding</source>
          <target state="translated">UTF-7 인코딩</target>
        </trans-unit>
        <trans-unit id="ba8308c0cebaf2cef9e02fb7f26e6c4f56ba6ce0" translate="yes" xml:space="preserve">
          <source>UTF-7 was not supported by Encode until version 1.95 because of that. But Unicode::String, a module by Gisle Aas which adds Unicode supports to non-utf8-savvy perl did support UTF-7, the UTF-7 support was added so Encode can supersede Unicode::String 100%.</source>
          <target state="translated">UTF-1은 버전 1.95까지 Encode에서 지원하지 않았습니다. 그러나 Gisle Aas의 모듈 인 UTF : UTF8이 아닌 perl에 유니 코드 지원을 추가하는 모듈 인 Unicode : : String은 UTF-7을 지원했으며 UTF-7 지원이 추가되어 Encode는 Unicode : : String 100 %를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="663b90c899fa25a111067be0c22ffc64dcf581c2" translate="yes" xml:space="preserve">
          <source>UTF-8</source>
          <target state="translated">UTF-8</target>
        </trans-unit>
        <trans-unit id="e2635de14b396bd81c2a4f587434aea9cfbf99fc" translate="yes" xml:space="preserve">
          <source>UTF-8 and UTF-EBCDIC are two different encodings used to represent Unicode code points as sequences of bytes. Macros with the same names (but different definitions) in</source>
          <target state="translated">UTF-8 및 UTF-EBCDIC는 유니 코드 코드 포인트를 바이트 시퀀스로 나타내는 데 사용되는 두 가지 다른 인코딩입니다. 이름이 같지만 정의가 다른 매크로</target>
        </trans-unit>
        <trans-unit id="8b4fe83acd749a66b827e068556fa7943eee22bb" translate="yes" xml:space="preserve">
          <source>UTF-8 and Unicode FAQ for Unix/Linux</source>
          <target state="translated">Unix / Linux에 대한 UTF-8 및 유니 코드 FAQ</target>
        </trans-unit>
        <trans-unit id="79cdcb7150e1254a38f057938e6f4012fc46b08a" translate="yes" xml:space="preserve">
          <source>UTF-8 is a variable-length (1 to 4 bytes), byte-order independent encoding. In most of Perl's documentation, including elsewhere in this document, the term &quot;UTF-8&quot; means also &quot;UTF-EBCDIC&quot;. But in this section, &quot;UTF-8&quot; refers only to the encoding used on ASCII platforms. It is a superset of 7-bit US-ASCII, so anything encoded in ASCII has the identical representation when encoded in UTF-8.</source>
          <target state="translated">UTF-8은 가변 길이 (1-4 바이트), 바이트 순서 독립적 인코딩입니다. 이 문서의 다른 부분을 포함하여 대부분의 Perl 설명서에서 &quot;UTF-8&quot;이라는 용어는 &quot;UTF-EBCDIC&quot;도 의미합니다. 그러나이 섹션에서 &quot;UTF-8&quot;은 ASCII 플랫폼에서 사용되는 인코딩 만 나타냅니다. 7 비트 US-ASCII의 상위 세트이므로 ASCII로 인코딩 된 것은 UTF-8로 인코딩 될 때 동일한 표현을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="64b07e44d3986db9cf7499225144a4d1d394db97" translate="yes" xml:space="preserve">
          <source>UTF-8 treats the first 128 codepoints, 0..127, the same as ASCII. They take only one byte per character. All other characters are encoded as two to four bytes using a complex scheme. Fortunately, Perl handles this for us, so we don't have to worry about this.</source>
          <target state="translated">UTF-8은 처음 128 개의 코드 포인트 (0..127)를 ASCII와 동일하게 취급합니다. 문자 당 1 바이트 만 사용합니다. 다른 모든 문자는 복잡한 체계를 사용하여 2-4 바이트로 인코딩됩니다. 다행스럽게도 Perl은이를 처리하므로 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7443ec4bd05d2044739a43a92206bcfe32f068b2" translate="yes" xml:space="preserve">
          <source>UTF-8 vs. utf8 vs. UTF8</source>
          <target state="translated">UTF-8 대 utf8 대 UTF8</target>
        </trans-unit>
        <trans-unit id="21357a91ac9a6238516304ecf3d0973befa29dc1" translate="yes" xml:space="preserve">
          <source>UTF-EBCDIC</source>
          <target state="translated">UTF-EBCDIC</target>
        </trans-unit>
        <trans-unit id="54206a5f5bcbb8b5ddd3ceb665085cec48ec6be8" translate="yes" xml:space="preserve">
          <source>UTF-EBCDIC is defined by &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr16&quot;&gt;Unicode Technical Report #16&lt;/a&gt;. It is defined based on CCSID 1047, not allowing for the differences for other code pages. This allows for easy interchange of text between computers running different code pages, but makes it unusable, without adaptation, for Perl on those other code pages.</source>
          <target state="translated">UTF-EBCDIC는 &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr16&quot;&gt;Unicode Technical Report # 16에&lt;/a&gt; 의해 정의됩니다 . CCSID 1047을 기반으로 정의되며 다른 코드 페이지의 차이를 허용하지 않습니다. 이렇게하면 다른 코드 페이지를 실행하는 컴퓨터간에 텍스트를 쉽게 교환 할 수 있지만 다른 코드 페이지의 Perl에서는 적응없이 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fae1061497efd49ee6054c0a3d6e1ce19e05e6be" translate="yes" xml:space="preserve">
          <source>UTF-EBCDIC is used on EBCDIC platforms. The largest Unicode code points take 5 bytes to represent (instead of 4 in UTF-8), and Perl extends it to a maximum of 7 bytes to encode pode points up to what can fit in a 32-bit word (instead of 13 bytes and a 64-bit word in UTF-8).</source>
          <target state="translated">UTF-EBCDIC는 EBCDIC 플랫폼에서 사용됩니다. 가장 큰 유니 코드 코드 포인트는 5 바이트 (UTF-8에서는 4 대신)를 나타내며, Perl은 최대 7 바이트까지 확장하여 32 비트 워드 (13 바이트 대신)에 포드 포인트를 인코딩합니다. UTF-8의 64 비트 단어).</target>
        </trans-unit>
        <trans-unit id="32e4aba336279eb247fca6069de55e692fafce3d" translate="yes" xml:space="preserve">
          <source>UTF-X</source>
          <target state="translated">UTF-X</target>
        </trans-unit>
        <trans-unit id="17562b3d061f2f42586076a6b020ba8eb357a3ff" translate="yes" xml:space="preserve">
          <source>UTILITIES</source>
          <target state="translated">UTILITIES</target>
        </trans-unit>
        <trans-unit id="58bc809d31f639453a46636f9c8ab08c8b78bb44" translate="yes" xml:space="preserve">
          <source>UTILITY FUNCTIONS</source>
          <target state="translated">유틸리티 기능</target>
        </trans-unit>
        <trans-unit id="994023f4756ccee554f76e83b238ef8441ca987c" translate="yes" xml:space="preserve">
          <source>Ultimate control over what should be done when (actually: each time) an option is encountered on the command line can be achieved by designating a reference to a subroutine (or an anonymous subroutine) as the option destination. When GetOptions() encounters the option, it will call the subroutine with two or three arguments. The first argument is the name of the option. (Actually, it is an object that stringifies to the name of the option.) For a scalar or array destination, the second argument is the value to be stored. For a hash destination, the second argument is the key to the hash, and the third argument the value to be stored. It is up to the subroutine to store the value, or do whatever it thinks is appropriate.</source>
          <target state="translated">옵션 행으로 서브 루틴 (또는 익명 서브 루틴)에 대한 참조를 지정하여 명령 행에서 옵션이 발생할 때 (실제로 매번) 수행 할 작업을 궁극적으로 제어 할 수 있습니다. GetOptions ()가 옵션을 만나면 2 개 또는 3 개의 인수로 서브 루틴을 호출합니다. 첫 번째 인수는 옵션의 이름입니다. (실제로, 옵션 이름으로 문자열을 지정하는 객체입니다.) 스칼라 또는 배열 대상의 경우 두 번째 인수는 저장할 값입니다. 해시 대상의 경우 두 번째 인수는 해시의 키이고 세 번째 인수는 저장할 값입니다. 값을 저장하거나 적절하다고 생각되는 것을 수행하는 것은 서브 루틴에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd11761cf7cb6cb9a563ded422bdfc4417516b2a" translate="yes" xml:space="preserve">
          <source>Unacceptable behavior will result in a public and clearly identified warning. Repeated unacceptable behavior will result in removal from the mailing list and revocation of rights to update rt.perl.org. The first removal is for one month. Subsequent removals will double in length. After six months with no warning, a user's ban length is reset. Removals, like warnings, are public.</source>
          <target state="translated">허용되지 않는 행동은 공개적이고 명확하게 식별 된 경고를 초래합니다. 허용되지 않는 동작이 반복되면 메일 링리스트에서 제거되고 rt.perl.org 업데이트 권한이 취소됩니다. 첫 번째 제거는 한 달입니다. 후속 제거 길이가 두 배가됩니다. 6 개월 후 경고없이 사용자의 금지 길이가 재설정됩니다. 경고와 같은 삭제는 공개입니다.</target>
        </trans-unit>
        <trans-unit id="1f8a4652f1c5950bdfb9f442db5f7ff059a9e8ff" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;!&quot;&lt;/code&gt; performs logical negation, that is, &quot;not&quot;. See also &lt;code&gt;not&lt;/code&gt; for a lower precedence version of this.</source>
          <target state="translated">단항 &lt;code&gt;&quot;!&quot;&lt;/code&gt; 논리적 부정, 즉 &quot;not&quot;을 수행합니다. 참조 &lt;code&gt;not&lt;/code&gt; 이것의 우선 순위가 낮은 버전.</target>
        </trans-unit>
        <trans-unit id="975143052b1e27f57ec5fcc07f42eb1c0eae9dc3" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;+&quot;&lt;/code&gt; has no effect whatsoever, even on strings. It is useful syntactically for separating a function name from a parenthesized expression that would otherwise be interpreted as the complete list of function arguments. (See examples above under &lt;a href=&quot;#Terms-and-List-Operators-(Leftward)&quot;&gt;Terms and List Operators (Leftward)&lt;/a&gt;.)</source>
          <target state="translated">단항 &lt;code&gt;&quot;+&quot;&lt;/code&gt; 는 문자열에도 영향을 미치지 않습니다. 함수 인수의 전체 목록으로 해석되는 괄호로 묶은 표현식에서 함수 이름을 분리하는 데 구문 적으로 유용합니다. (위의 &lt;a href=&quot;#Terms-and-List-Operators-(Leftward)&quot;&gt;용어 및 목록 연산자 (왼쪽)&lt;/a&gt; 아래 예 참조 )</target>
        </trans-unit>
        <trans-unit id="cbc2e014fe3be3f69d01617e0a9853fb77867e55" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;-&quot;&lt;/code&gt; performs arithmetic negation if the operand is numeric, including any string that looks like a number. If the operand is an identifier, a string consisting of a minus sign concatenated with the identifier is returned. Otherwise, if the string starts with a plus or minus, a string starting with the opposite sign is returned. One effect of these rules is that &lt;code&gt;-bareword&lt;/code&gt; is equivalent to the string &lt;code&gt;&quot;-bareword&quot;&lt;/code&gt; . If, however, the string begins with a non-alphabetic character (excluding &lt;code&gt;&quot;+&quot;&lt;/code&gt; or &lt;code&gt;&quot;-&quot;&lt;/code&gt; ), Perl will attempt to convert the string to a numeric, and the arithmetic negation is performed. If the string cannot be cleanly converted to a numeric, Perl will give the warning &lt;b&gt;Argument &quot;the string&quot; isn't numeric in negation (-) at ...&lt;/b&gt;.</source>
          <target state="translated">단항 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 는 숫자처럼 보이는 문자열을 포함하여 피연산자가 숫자 인 경우 산술 부정을 수행합니다. 피연산자가 식별자 인 경우 식별자와 연결된 빼기 부호로 구성된 문자열이 반환됩니다. 그렇지 않으면 문자열이 플러스 또는 마이너스로 시작하면 반대 부호로 시작하는 문자열이 반환됩니다. 이러한 규칙의 한 가지 효과는 &lt;code&gt;-bareword&lt;/code&gt; 가 문자열 &lt;code&gt;&quot;-bareword&quot;&lt;/code&gt; 와 동일 하다는 것 입니다. 그러나 문자열이 알파벳이 아닌 문자 ( &lt;code&gt;&quot;+&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 제외 )로 시작하면 Perl은 문자열을 숫자로 변환하려고 시도하며 산술 부정이 수행됩니다. 문자열을 숫자로 깔끔하게 변환 할 수 없으면 Perl에서 경고를 표시합니다&lt;b&gt;인수 &quot;문자열&quot;은 부정 (-)에서 숫자가 아닙니다 (...)&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="75765e3d8911e6ac713c74a3a1fc1d709b9ed2ea" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;\&quot;&lt;/code&gt; creates a reference to whatever follows it. See &lt;a href=&quot;perlreftut&quot;&gt;perlreftut&lt;/a&gt; and &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;. Do not confuse this behavior with the behavior of backslash within a string, although both forms do convey the notion of protecting the next thing from interpolation.</source>
          <target state="translated">단항 &lt;code&gt;&quot;\&quot;&lt;/code&gt; 는 뒤에 오는 모든 것에 대한 참조를 만듭니다. &lt;a href=&quot;perlreftut&quot;&gt;perlreftut&lt;/a&gt; 및 &lt;a href=&quot;perlref&quot;&gt;perlref를&lt;/a&gt; 참조하십시오 . 두 형식이 다음 항목을 보간으로부터 보호한다는 개념을 전달하지만이 동작을 문자열 내 백 슬래시 동작과 혼동하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="a440a050a6ba4df9312abb517ec0cbc1f89e1767" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;not&quot;&lt;/code&gt; returns the logical negation of the expression to its right. It's the equivalent of &lt;code&gt;&quot;!&quot;&lt;/code&gt; except for the very low precedence.</source>
          <target state="translated">단항 &lt;code&gt;&quot;not&quot;&lt;/code&gt; 은 표현식의 논리적 부정을 오른쪽으로 반환합니다. &lt;code&gt;&quot;!&quot;&lt;/code&gt; 와 같습니다 . 우선 순위가 매우 낮습니다.</target>
        </trans-unit>
        <trans-unit id="4dae9b42247425fb7e1e868bc6aec93255104f04" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;~&quot;&lt;/code&gt; performs bitwise negation, that is, 1's complement. For example, &lt;code&gt;0666 &amp;amp; ~027&lt;/code&gt; is 0640. (See also &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt; and &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Bitwise String Operators&lt;/a&gt;.) Note that the width of the result is platform-dependent: &lt;code&gt;~0&lt;/code&gt; is 32 bits wide on a 32-bit platform, but 64 bits wide on a 64-bit platform, so if you are expecting a certain bit width, remember to use the &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; operator to mask off the excess bits.</source>
          <target state="translated">단항 &lt;code&gt;&quot;~&quot;&lt;/code&gt; 는 비트 단위 부정, 즉 1의 보수를 수행합니다. 예를 들어, &lt;code&gt;0666 &amp;amp; ~027&lt;/code&gt; 은 0640입니다 ( &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;정수 산술&lt;/a&gt; 및 &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;비트 문자열 연산자 참조)&lt;/a&gt; . 결과 너비는 플랫폼에 따라 다릅니다. &lt;code&gt;~0&lt;/code&gt; 은 32 비트 플랫폼에서 32 비트 폭이지만 64 비트 폭입니다. 64 비트 플랫폼에서 특정 비트 너비를 예상하는 경우 &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; 연산자를 사용 하여 초과 비트를 마스크하십시오.</target>
        </trans-unit>
        <trans-unit id="121bb514c3415be69016271f5f8950c0aed3f161" translate="yes" xml:space="preserve">
          <source>Unbackslashed prototype characters have special meanings. Any unbackslashed &lt;code&gt;@&lt;/code&gt; or &lt;code&gt;%&lt;/code&gt; eats all remaining arguments, and forces list context. An argument represented by &lt;code&gt;$&lt;/code&gt; forces scalar context. An &lt;code&gt;&amp;amp;&lt;/code&gt; requires an anonymous subroutine, which, if passed as the first argument, does not require the &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; keyword or a subsequent comma.</source>
          <target state="translated">백 슬래시가없는 프로토 타입 문자에는 특별한 의미가 있습니다. 백 슬래시가없는 &lt;code&gt;@&lt;/code&gt; 또는 &lt;code&gt;%&lt;/code&gt; 는 나머지 모든 인수를 먹고 목록 컨텍스트를 강제 실행합니다. &lt;code&gt;$&lt;/code&gt; 로 표시되는 인수는 스칼라 컨텍스트를 강제합니다. &lt;code&gt;&amp;amp;&lt;/code&gt; 은 첫 번째 인수로 전달하는 경우는 필요로하지 않는 익명 서브 루틴이 필요 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 키워드 또는 후속 쉼표.</target>
        </trans-unit>
        <trans-unit id="825c40d18a2a673a59517a26d2876574d355db3e" translate="yes" xml:space="preserve">
          <source>Uncompress gzip, zip, bzip2 or lzop file/buffer</source>
          <target state="translated">gzip, zip, bzip2 또는 lzop 파일 / 버퍼 압축 해제</target>
        </trans-unit>
        <trans-unit id="aed55ac0a8b1616e77c1e8b5f3fc823c056e7f68" translate="yes" xml:space="preserve">
          <source>Uncompress zlib-based (zip, gzip) file/buffer</source>
          <target state="translated">zlib 기반 (zip, gzip) 파일 / 버퍼 압축 해제</target>
        </trans-unit>
        <trans-unit id="5566ebf8e86133343de98e57588751d94f017699" translate="yes" xml:space="preserve">
          <source>Uncompresses &lt;code&gt;$input&lt;/code&gt; and writes the uncompressed data to &lt;code&gt;$output&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$input&lt;/code&gt; 압축 해제 하고 압축되지 않은 데이터를 &lt;code&gt;$output&lt;/code&gt; 씁니다 .</target>
        </trans-unit>
        <trans-unit id="3241d8b84b7531f4c85af8e73c024fd4504975c7" translate="yes" xml:space="preserve">
          <source>Uncompresses &lt;code&gt;$source&lt;/code&gt; . If successful it returns the uncompressed data. Otherwise it returns</source>
          <target state="translated">&lt;code&gt;$source&lt;/code&gt; 압축을 해제 합니다 . 성공하면 압축되지 않은 데이터를 반환합니다. 그렇지 않으면 반환</target>
        </trans-unit>
        <trans-unit id="ac8d3226186ea01833996c8b65de3f2a8379790e" translate="yes" xml:space="preserve">
          <source>Uncompression</source>
          <target state="translated">Uncompression</target>
        </trans-unit>
        <trans-unit id="4189d548d277ce627b98749a55c3556ffc35219e" translate="yes" xml:space="preserve">
          <source>Unconditionally match a bareword or any other single character, and then go back to step 1.</source>
          <target state="translated">무조건 베어나 다른 단일 문자를 무조건 일치시킨 다음 1 단계로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="577343970a5bf9b7cb8738f42c2797ca4589087a" translate="yes" xml:space="preserve">
          <source>Uncuddled elses and &quot;K&amp;amp;R&quot; style for indenting control constructs</source>
          <target state="translated">제어 구조를 들여 쓰기위한 다른 것들과 &quot;K &amp;amp; R&quot;스타일</target>
        </trans-unit>
        <trans-unit id="11c11d31d108dd964ce797e5076b1d8839850791" translate="yes" xml:space="preserve">
          <source>Uncuddled elses.</source>
          <target state="translated">껴안은 다른 사람들.</target>
        </trans-unit>
        <trans-unit id="5cd9e75daaa9152346601595647eb2d9696e6583" translate="yes" xml:space="preserve">
          <source>Undef if an external</source>
          <target state="translated">외부인 경우 undef</target>
        </trans-unit>
        <trans-unit id="b410752a7d8baa31a708ac9e0618b37a2bdd788d" translate="yes" xml:space="preserve">
          <source>Undefined subroutine &amp;amp;main::GetOptions called</source>
          <target state="translated">정의되지 않은 서브 루틴 &amp;amp; main :: GetOptions 호출</target>
        </trans-unit>
        <trans-unit id="4be1ae516287ece8c814ce973af8c8cef754916c" translate="yes" xml:space="preserve">
          <source>Undefines the array. Frees the memory used by the av to store its list of scalars. If any destructors are triggered as a result, the av itself may be freed.</source>
          <target state="translated">배열을 정의 해제합니다. av가 스칼라 목록을 저장하기 위해 사용하는 메모리를 해제합니다. 결과적으로 소멸자가 트리거되면 av 자체가 해제 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="270b863b48b0c13c0b01735bf826d9b654084021" translate="yes" xml:space="preserve">
          <source>Undefines the collation element as if it were unassigned in the &lt;code&gt;table&lt;/code&gt; . This reduces the size of the table. If an unassigned character appears in the string to be collated, the sort key is made from its codepoint as a single-character collation element, as it is greater than any other assigned collation elements (in the codepoint order among the unassigned characters). But, it'd be better to ignore characters unfamiliar to you and maybe never used.</source>
          <target state="translated">데이터 정렬 요소가 마치 &lt;code&gt;table&lt;/code&gt; 에서 할당되지 않은 것처럼 정의 해제 합니다 . 테이블 크기가 줄어 듭니다. 할당되지 않은 문자가 정렬 될 문자열에 나타나면 정렬 키는 할당 된 다른 데이터 정렬 요소 (할당되지 않은 문자 중 코드 포인트 순서)보다 크기 때문에 코드 포인트에서 단일 문자 데이터 정렬 요소로 만들어집니다. 그러나 익숙하지 않은 문자는 무시하고 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7b61a323c52c38306eb024952539f4f8c5a7ffe3" translate="yes" xml:space="preserve">
          <source>Undefines the hash. The XS equivalent of &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef(%hash)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">해시를 정의 해제하십시오. &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef(%hash)&lt;/a&gt;&lt;/code&gt; 와 동일한 XS 입니다.</target>
        </trans-unit>
        <trans-unit id="21918cc87ca44856538ac74361e547848b42b7b4" translate="yes" xml:space="preserve">
          <source>Undefines the value of EXPR, which must be an lvalue. Use only on a scalar value, an array (using &lt;code&gt;@&lt;/code&gt; ), a hash (using &lt;code&gt;%&lt;/code&gt; ), a subroutine (using &lt;code&gt;&amp;amp;&lt;/code&gt; ), or a typeglob (using &lt;code&gt;*&lt;/code&gt; ). Saying &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; $hash{$key}&lt;/code&gt; will probably not do what you expect on most predefined variables or DBM list values, so don't do that; see &lt;a href=&quot;#delete&quot;&gt;delete&lt;/a&gt;. Always returns the undefined value. You can omit the EXPR, in which case nothing is undefined, but you still get an undefined value that you could, for instance, return from a subroutine, assign to a variable, or pass as a parameter. Examples:</source>
          <target state="translated">EXPR의 값을 정의하십시오. 이는 lvalue 여야합니다. 스칼라 값, 배열 ( &lt;code&gt;@&lt;/code&gt; 사용 ), 해시 ( &lt;code&gt;%&lt;/code&gt; 사용 ), 서브 루틴 ( &lt;code&gt;&amp;amp;&lt;/code&gt; 사용 ) 또는 typeglob ( &lt;code&gt;*&lt;/code&gt; 사용)에만 사용하십시오 . &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; $hash{$key}&lt;/code&gt; 라고 말하면 대부분의 사전 정의 된 변수 또는 DBM 목록 값에서 예상 한대로 수행되지 않을 것이므로 그렇게하지 마십시오. &lt;a href=&quot;#delete&quot;&gt;delete를&lt;/a&gt; 참조하십시오 . 항상 정의되지 않은 값을 반환합니다. EXPR을 생략 할 수 있습니다.이 경우 정의되지 않은 것은 없지만, 예를 들어 서브 루틴에서 리턴하거나 변수에 지정하거나 매개 변수로 전달할 수있는 정의되지 않은 값을 얻을 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="12772c94a5d6a3598c32da79f4c1c4affc5b608e" translate="yes" xml:space="preserve">
          <source>Undefines the value of EXPR, which must be an lvalue. Use only on a scalar value, an array (using &lt;code&gt;@&lt;/code&gt; ), a hash (using &lt;code&gt;%&lt;/code&gt; ), a subroutine (using &lt;code&gt;&amp;amp;&lt;/code&gt; ), or a typeglob (using &lt;code&gt;*&lt;/code&gt; ). Saying &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt; $hash{$key}&lt;/code&gt; will probably not do what you expect on most predefined variables or DBM list values, so don't do that; see &lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt;. Always returns the undefined value. You can omit the EXPR, in which case nothing is undefined, but you still get an undefined value that you could, for instance, return from a subroutine, assign to a variable, or pass as a parameter. Examples:</source>
          <target state="translated">EXPR의 값을 정의하십시오. 이는 lvalue 여야합니다. 스칼라 값, 배열 ( &lt;code&gt;@&lt;/code&gt; 사용 ), 해시 ( &lt;code&gt;%&lt;/code&gt; 사용 ), 서브 루틴 ( &lt;code&gt;&amp;amp;&lt;/code&gt; 사용 ) 또는 typeglob ( &lt;code&gt;*&lt;/code&gt; 사용)에만 사용하십시오 . &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt; $hash{$key}&lt;/code&gt; 라고 말하면 대부분의 사전 정의 된 변수 또는 DBM 목록 값에서 예상 한대로 수행되지 않을 것이므로 그렇게하지 마십시오. &lt;a href=&quot;delete&quot;&gt;delete를&lt;/a&gt; 참조하십시오 . 항상 정의되지 않은 값을 반환합니다. EXPR을 생략 할 수 있습니다.이 경우 정의되지 않은 것은 없지만, 예를 들어 서브 루틴에서 리턴하거나 변수에 지정하거나 매개 변수로 전달할 수있는 정의되지 않은 값을 얻을 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="8b42ea56822642513e4f112de38357bed9dd6a64" translate="yes" xml:space="preserve">
          <source>Undefining this symbol disables the PerlIO abstraction. PerlIO is now the default; it is not recommended to disable PerlIO.</source>
          <target state="translated">이 기호를 정의하지 않으면 PerlIO 추상화가 비활성화됩니다. PerlIO가 이제 기본값입니다. PerlIO를 비활성화하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="14931b1ffe46d4f806d87924392ea8d8ba051a3f" translate="yes" xml:space="preserve">
          <source>Undefining this symbol forces Perl to be compiled statically.</source>
          <target state="translated">이 기호를 정의하지 않으면 Perl이 정적으로 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="55d31ccf7c7a9061158740ae0e4ba2a4be4c51d6" translate="yes" xml:space="preserve">
          <source>Under &quot;Classic&quot; MacOS, a perl program will have the appropriate Creator and Type, so that double-clicking them will invoke the MacPerl application. Under Mac OS X, clickable apps can be made from any &lt;code&gt;#!&lt;/code&gt; script using Wil Sanchez' DropScript utility: &lt;a href=&quot;http://www.wsanchez.net/software/&quot;&gt;http://www.wsanchez.net/software/&lt;/a&gt; .</source>
          <target state="translated">&quot;Classic&quot;MacOS에서 perl 프로그램은 적절한 Creator와 Type을 가지므로, 더블 클릭하면 MacPerl 응용 프로그램이 호출됩니다. Mac OS X에서는 클릭 가능한 앱을 &lt;code&gt;#!&lt;/code&gt; 에서 만들 수 있습니다 ! 스크립트를 사용하여 윌 산체스 'DropScript 유틸리티 : &lt;a href=&quot;http://www.wsanchez.net/software/&quot;&gt;http://www.wsanchez.net/software/&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7de147ca0cf42a020c2b34e4934080e8fbf00bba" translate="yes" xml:space="preserve">
          <source>Under &lt;a href=&quot;../test/harness&quot;&gt;Test::Harness&lt;/a&gt;, test number 2 would</source>
          <target state="translated">에서 &lt;a href=&quot;../test/harness&quot;&gt;테스트 : 하네스&lt;/a&gt; , 테스트 번호 2 것</target>
        </trans-unit>
        <trans-unit id="50510298fcc80cb0b2cfe5fcb98eb1382cb9d484" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; , detection step of discontiguous contractions will be skipped.</source>
          <target state="translated">&lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; 아래에서 불연속 수축의 감지 단계를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="da1bc7be7a27894ec56a14e00f77fdf88c07658e" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; , or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; feature &quot;array_base&quot;&lt;/code&gt; , &lt;code&gt;$[&lt;/code&gt; no longer has any effect, and always contains 0. Assigning 0 to it is permitted, but any other value will produce an error.</source>
          <target state="translated">에서 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; , 또는 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; feature &quot;array_base&quot;&lt;/code&gt; , &lt;code&gt;$[&lt;/code&gt; 더 이상 효과가없고, 항상 0이 허용 할당 0을 포함하고 있지만, 다른 값은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bacf555aace53131b41a0f7ef63c9e3e7d03589b" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;unicode_strings&lt;/code&gt; starting in Perl 5.12.0, Unicode rules are generally used. See &lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt; for details on how this works in combination with various other pragmas.</source>
          <target state="translated">아래 &lt;code&gt;unicode_strings&lt;/code&gt; 펄 5.12.0에서 시작, 유니 코드 규칙이 일반적으로 사용된다. 이 방법이 다양한 다른 pragma와 함께 작동하는 방법에 대한 자세한 내용 은 &lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="94fe5caf324bcb104f1845ec70df5cb17cd45071" translate="yes" xml:space="preserve">
          <source>Under Cygwin, $^E is the same as $!. When using &lt;a href=&quot;http://search.cpan.org/perldoc/Win32&quot;&gt;Win32 API Functions&lt;/a&gt;, use &lt;code&gt;Win32::GetLastError()&lt;/code&gt; to get the last Windows error.</source>
          <target state="translated">Cygwin에서 $ ^ E는 $!와 동일합니다. 사용하는 경우 &lt;a href=&quot;http://search.cpan.org/perldoc/Win32&quot;&gt;는 Win32 API 함수를&lt;/a&gt; 사용 &lt;code&gt;Win32::GetLastError()&lt;/code&gt; 마지막으로 Windows 오류를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08490cc0df2a509f16cddc3cf2a4ae40e649767f" translate="yes" xml:space="preserve">
          <source>Under EBCDIC platforms, &lt;code&gt;e2char($n)&lt;/code&gt; may not always be the same as &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr(e2charnum($n))&lt;/a&gt;&lt;/code&gt;, and ditto for &lt;code&gt;$Name2character{$name}&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr($Name2character_number{$name})&lt;/a&gt;&lt;/code&gt;, because the strings are returned as native, and the numbers are returned as Unicode. However, for Perls starting with v5.8, &lt;code&gt;e2char($n)&lt;/code&gt; is the same as &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr(utf8::unicode_to_native(e2charnum($n)))&lt;/a&gt;&lt;/code&gt;, and ditto for &lt;code&gt;$Name2character{$name}&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr(utf8::unicode_to_native($Name2character_number{$name}))&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">EBCDIC 플랫폼에서 &lt;code&gt;e2char($n)&lt;/code&gt; 항상 동일하지 않을 수 있습니다 &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr(e2charnum($n))&lt;/a&gt;&lt;/code&gt; 에 대한, 그리고 저두 &lt;code&gt;$Name2character{$name}&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr($Name2character_number{$name})&lt;/a&gt;&lt;/code&gt; , 문자열이 반환되기 때문에 기본적으로 숫자가 유니 코드로 반환됩니다. 그러나 v5.8로 시작하는 Perls의 경우 &lt;code&gt;e2char($n)&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr(utf8::unicode_to_native(e2charnum($n)))&lt;/a&gt;&lt;/code&gt; 과 동일하며 &lt;code&gt;$Name2character{$name}&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr(utf8::unicode_to_native($Name2character_number{$name}))&lt;/a&gt;&lt;/code&gt; 대한 ditto ($ Name2character_number {$ name})) .</target>
        </trans-unit>
        <trans-unit id="18254acc65d18b7ddbf875f7bfc47db0d75ce39a" translate="yes" xml:space="preserve">
          <source>Under NFS this will use the time of the NFS server, not the time of the local machine. If there is a time synchronization problem, the NFS server and local machine will have different times. The Unix touch(1) command will in fact normally use this form instead of the one shown in the first example.</source>
          <target state="translated">NFS에서는 로컬 시스템의 시간이 아닌 NFS 서버의 시간을 사용합니다. 시간 동기화 문제가있는 경우 NFS 서버와 로컬 시스템의 시간이 다릅니다. Unix touch (1) 명령은 실제로 첫 번째 예제에 표시된 형식 대신이 형식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f3924a4fe96e1e85710f171a0842dfde3423eb52" translate="yes" xml:space="preserve">
          <source>Under OS/2, &lt;code&gt;$^E&lt;/code&gt; is set to the error code of the last call to OS/2 API either via CRT, or directly from perl.</source>
          <target state="translated">OS / 2에서 &lt;code&gt;$^E&lt;/code&gt; 는 CRT를 통해 또는 perl에서 직접 OS / 2 API에 대한 마지막 호출의 오류 코드로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="19dcdc34494760727e410f497dbed91a176d6c5e" translate="yes" xml:space="preserve">
          <source>Under Perl 5.10 only, using a string eval when &lt;code&gt;autodie&lt;/code&gt; is in effect can cause the autodie behaviour to leak into the surrounding scope. This can be worked around by using a &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie&lt;/code&gt; at the end of the scope to explicitly remove autodie's effects, or by avoiding the use of string eval.</source>
          <target state="translated">Perl 5.10에서만 &lt;code&gt;autodie&lt;/code&gt; 가 유효 할 때 문자열 eval을 사용 하면 autodie 동작이 주변 범위로 누출 될 수 있습니다. 스코프 끝에 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie&lt;/code&gt; 를 사용 &lt;a href=&quot;functions/no&quot;&gt;하지 않고&lt;/a&gt; autodie의 효과를 명시 적으로 제거하거나 string eval을 사용하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="1824d549ede70b3449b6bc94fa47857184a96f9f" translate="yes" xml:space="preserve">
          <source>Under Perl 5.18 and later, SvREADONLY only applies to read-only variables, and, under 5.20, copy-on-write scalars can also be read-only, so the above check is incorrect. You just want:</source>
          <target state="translated">Perl 5.18 이상에서 SvREADONLY는 읽기 전용 변수에만 적용되며 5.20에서는 쓰기시 복사 스칼라도 읽기 전용 일 수 있으므로 위의 점검이 올바르지 않습니다. 당신은 단지 원합니다 :</target>
        </trans-unit>
        <trans-unit id="8d107d150b9abd6d04d1d29a993fa6ea829d9209" translate="yes" xml:space="preserve">
          <source>Under Perl 5.8 only, &lt;code&gt;autodie&lt;/code&gt;</source>
          <target state="translated">Perl 5.8에서만 &lt;code&gt;autodie&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e28f5c058f0915564622ac46660d6f84c05ab318" translate="yes" xml:space="preserve">
          <source>Under Perl 5.8, the &lt;code&gt;given/when&lt;/code&gt; structure is not available, so the following structure may be used:</source>
          <target state="translated">Perl 5.8에서는 &lt;code&gt;given/when&lt;/code&gt; 구조를 사용할 수 없으므로 다음 구조를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef993909ab6a97a91baf7e650bc7ce46f77c2516" translate="yes" xml:space="preserve">
          <source>Under QNX 6.2.0 there are still a few tests which fail. See below and hints/qnx.sh for more information.</source>
          <target state="translated">QNX 6.2.0에서는 여전히 실패한 몇 가지 테스트가 있습니다. 자세한 내용은 아래 및 힌트 /qnx.sh를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="66b5ec5cf7fb5924aee8dffa63eba13ccd60d52e" translate="yes" xml:space="preserve">
          <source>Under Unicode rules, there are a few case-insensitive matches that cross the 255/256 boundary. Except for UTF-8 locales in Perls v5.20 and later, these are disallowed under &lt;code&gt;/l&lt;/code&gt; . For example, 0xFF (on ASCII platforms) does not caselessly match the character at 0x178, &lt;code&gt;LATIN
CAPITAL LETTER Y WITH DIAERESIS&lt;/code&gt; , because 0xFF may not be &lt;code&gt;LATIN SMALL
LETTER Y WITH DIAERESIS&lt;/code&gt; in the current locale, and Perl has no way of knowing if that character even exists in the locale, much less what code point it is.</source>
          <target state="translated">유니 코드 규칙에는 255/256 경계를 넘는 대소 문자를 구분하지 않는 일치 항목이 있습니다. Perls v5.20 이상에서 UTF-8 로케일을 제외하고는 &lt;code&gt;/l&lt;/code&gt; 에서 허용되지 않습니다 . 예를 들어, (ASCII 플랫폼)를 0xFF는 caselessly 0x178에있는 문자와 일치하지 않는, &lt;code&gt;LATIN CAPITAL LETTER Y WITH DIAERESIS&lt;/code&gt; , 0xFF로이되지 않을 수 있기 때문에 &lt;code&gt;LATIN SMALL LETTER Y WITH DIAERESIS&lt;/code&gt; 현재 로케일에서, 펄는 경우 알 수있는 방법이 있습니다 문자는 로케일에도 존재하며 코드 포인트가 훨씬 적습니다.</target>
        </trans-unit>
        <trans-unit id="666da3b151d79c3526ad94c74b4a7b5272bc4ad7" translate="yes" xml:space="preserve">
          <source>Under Unicode rules, these upper-Latin1 characters are interpreted as Unicode code points, which means they have the same semantics as Latin-1 (ISO-8859-1) and C1 controls.</source>
          <target state="translated">유니 코드 규칙에서 이러한 상위 라틴 1 문자는 유니 코드 코드 포인트로 해석되므로 Latin-1 (ISO-8859-1) 및 C1 컨트롤과 동일한 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="15d191765263aacd2b7fcad31e78fb6cf886a85b" translate="yes" xml:space="preserve">
          <source>Under VMS this reflects the actual VMS exit status; i.e. it is the same as &lt;code&gt;$?&lt;/code&gt; when the pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; is in effect.</source>
          <target state="translated">VMS에서는 실제 VMS 종료 상태를 반영합니다. 즉, &lt;code&gt;$?&lt;/code&gt; 와 동일 합니까? pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; 가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="737324e93129014d33d4923a010ebe747aa167f7" translate="yes" xml:space="preserve">
          <source>Under VMS, &lt;code&gt;$^E&lt;/code&gt; provides the VMS status value from the last system error. This is more specific information about the last system error than that provided by &lt;code&gt;$!&lt;/code&gt; . This is particularly important when &lt;code&gt;$!&lt;/code&gt; is set to &lt;b&gt;EVMSERR&lt;/b&gt;.</source>
          <target state="translated">VMS에서 &lt;code&gt;$^E&lt;/code&gt; 는 마지막 시스템 오류의 VMS 상태 값을 제공합니다. &lt;code&gt;$!&lt;/code&gt; 에서 제공 한 것보다 마지막 시스템 오류에 대한보다 구체적인 정보입니다 . . &lt;code&gt;$!&lt;/code&gt; 때 특히 중요합니다 ! &lt;b&gt;EVMSERR&lt;/b&gt; 로 설정되었습니다 .</target>
        </trans-unit>
        <trans-unit id="50b3f98ca540bd0c81d34840956f838255c71318" translate="yes" xml:space="preserve">
          <source>Under VMS, if there is no directory information in the $path, then the current default device and directory is used.</source>
          <target state="translated">VMS에서 $ path에 디렉토리 정보가 없으면 현재 기본 장치 및 디렉토리가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3aaae4cddb5ecef27b2c450c8cc4b4b174c7016f" translate="yes" xml:space="preserve">
          <source>Under VMS, the pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; makes &lt;code&gt;$?&lt;/code&gt; reflect the actual VMS exit status, instead of the default emulation of POSIX status; see &lt;a href=&quot;perlvms#%24%3f&quot;&gt;$? in perlvms&lt;/a&gt; for details.</source>
          <target state="translated">VMS에서 pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; 는 &lt;code&gt;$?&lt;/code&gt; POSIX 상태의 기본 에뮬레이션 대신 실제 VMS 종료 상태를 반영합니다. &lt;a href=&quot;perlvms#%24%3f&quot;&gt;$?&lt;/a&gt; 참조 자세한 내용 은 perlvms 에서.</target>
        </trans-unit>
        <trans-unit id="711e7c0754f84b5e7bda634825aa4039a4a70c54" translate="yes" xml:space="preserve">
          <source>Under Win32's &quot;test&quot; target you may use the TEST_SWITCHES and TEST_FILES environment variables to control the behaviour of</source>
          <target state="translated">Win32의 &quot;테스트&quot;대상에서 TEST_SWITCHES 및 TEST_FILES 환경 변수를 사용하여 다음 동작을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53c6d0758bf54648c779157ed9111dd650df9efe" translate="yes" xml:space="preserve">
          <source>Under Win32, &lt;code&gt;$^E&lt;/code&gt; always returns the last error information reported by the Win32 call &lt;code&gt;GetLastError()&lt;/code&gt; which describes the last error from within the Win32 API. Most Win32-specific code will report errors via &lt;code&gt;$^E&lt;/code&gt; . ANSI C and Unix-like calls set &lt;code&gt;errno&lt;/code&gt; and so most portable Perl code will report errors via &lt;code&gt;$!&lt;/code&gt; .</source>
          <target state="translated">Win32에서 &lt;code&gt;$^E&lt;/code&gt; 항상 Win32 API 내에서 마지막 오류를 설명하는 Win32 호출 &lt;code&gt;GetLastError()&lt;/code&gt; 에서보고 한 마지막 오류 정보를 반환합니다 . 대부분의 Win32 특정 코드는 &lt;code&gt;$^E&lt;/code&gt; 를 통해 오류를보고합니다 . ANSI C 및 Unix와 유사한 호출은 &lt;code&gt;errno&lt;/code&gt; 를 설정 하므로 대부분의 휴대용 Perl 코드는 &lt;code&gt;$!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="445377f279bee790252626a9efe4c710c5fb31ec" translate="yes" xml:space="preserve">
          <source>Under Windows and VMS the option file is named</source>
          <target state="translated">Windows 및 VMS에서 옵션 파일 이름은</target>
        </trans-unit>
        <trans-unit id="991af3b0df6455b17cae9de8484aa49771ee9333" translate="yes" xml:space="preserve">
          <source>Under a few operating systems, &lt;code&gt;$^E&lt;/code&gt; may contain a more verbose error indicator, such as in this case, &quot;CDROM tray not closed.&quot; Systems that do not support extended error messages leave &lt;code&gt;$^E&lt;/code&gt; the same as &lt;code&gt;$!&lt;/code&gt; .</source>
          <target state="translated">일부 운영 체제에서는 &lt;code&gt;$^E&lt;/code&gt; 에 &quot;CDROM tray not closed&quot;와 같은보다 자세한 오류 표시기가있을 수 있습니다. 확장 오류 메시지를 지원하지 않는 시스템은 &lt;code&gt;$^E&lt;/code&gt; 를 &lt;code&gt;$!&lt;/code&gt; 와 동일하게 둡니다 . .</target>
        </trans-unit>
        <trans-unit id="b8188d9bfb2c028e78df0c34f466ab12923ca95e" translate="yes" xml:space="preserve">
          <source>Under bignum (or bigint or bigrat), Perl will &quot;upgrade&quot; the numbers appropriately. This means that:</source>
          <target state="translated">bignum (또는 bigint 또는 bigrat)에서 Perl은 숫자를 적절하게 &quot;업그레이드&quot;합니다. 이것은 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="936167913e1d36052a60fe747af5e2acfb71f327" translate="yes" xml:space="preserve">
          <source>Under case-sensitive matching, these both match the same code points as &lt;code&gt;\p{General Category=Titlecase_Letter}&lt;/code&gt; (&lt;code&gt;\p{gc=&lt;a href=&quot;functions/lt&quot;&gt;lt&lt;/a&gt;}&lt;/code&gt; ). The difference is that under &lt;code&gt;/i&lt;/code&gt; caseless matching, these match the same as &lt;code&gt;\p{Cased}&lt;/code&gt; , whereas &lt;code&gt;\p{gc=&lt;a href=&quot;functions/lt&quot;&gt;lt&lt;/a&gt;}&lt;/code&gt; matches &lt;code&gt;\p{Cased_Letter&lt;/code&gt; ).</source>
          <target state="translated">대소 문자를 구분하여 일치하는 경우 둘 다 &lt;code&gt;\p{General Category=Titlecase_Letter}&lt;/code&gt; ( &lt;code&gt;\p{gc=&lt;a href=&quot;functions/lt&quot;&gt;lt&lt;/a&gt;}&lt;/code&gt; ) 와 동일한 코드 포인트와 일치합니다 . 차이점은 아래 &lt;code&gt;/i&lt;/code&gt; 대소 문자 구별 매칭 같은 이러한 매치 &lt;code&gt;\p{Cased}&lt;/code&gt; 반면 &lt;code&gt;\p{gc=&lt;a href=&quot;functions/lt&quot;&gt;lt&lt;/a&gt;}&lt;/code&gt; 일치 &lt;code&gt;\p{Cased_Letter&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="58098e551f5eebaa46d0d3a19d00f14ced3f4d46" translate="yes" xml:space="preserve">
          <source>Under ithreads the optree is read only. If you want to enforce this, to check for write accesses from buggy code, compile with &lt;code&gt;-Accflags=-DPERL_DEBUG_READONLY_OPS&lt;/code&gt; to enable code that allocates op memory via &lt;code&gt;mmap&lt;/code&gt; , and sets it read-only when it is attached to a subroutine. Any write access to an op results in a &lt;code&gt;SIGBUS&lt;/code&gt; and abort.</source>
          <target state="translated">ithreads에서 optree는 읽기 전용입니다. 이를 적용하려면 버그가있는 코드에서 쓰기 액세스를 확인하려면 &lt;code&gt;-Accflags=-DPERL_DEBUG_READONLY_OPS&lt;/code&gt; 로 컴파일하여 &lt;code&gt;mmap&lt;/code&gt; 를 통해 op 메모리를 할당 하고 서브 루틴에 연결될 때 읽기 전용으로 설정하는 코드를 활성화하십시오 . op에 대한 쓰기 권한이 있으면 &lt;code&gt;SIGBUS&lt;/code&gt; 가 중단되고 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="41c5c0dce73b6a45e16e6c80203f13488d40f1dd" translate="yes" xml:space="preserve">
          <source>Under the &quot;switch&quot; feature, Perl gains the experimental keywords &lt;code&gt;given&lt;/code&gt; , &lt;code&gt;when&lt;/code&gt; , &lt;code&gt;default&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;break&lt;/code&gt; . Starting from Perl 5.16, one can prefix the switch keywords with &lt;code&gt;CORE::&lt;/code&gt; to access the feature without a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; statement. The keywords &lt;code&gt;given&lt;/code&gt; and &lt;code&gt;when&lt;/code&gt; are analogous to &lt;code&gt;switch&lt;/code&gt; and &lt;code&gt;case&lt;/code&gt; in other languages, so the code in the previous section could be rewritten as</source>
          <target state="translated">&quot;스위치&quot;기능에서 Perl은 &lt;code&gt;given&lt;/code&gt; , &lt;code&gt;when&lt;/code&gt; , &lt;code&gt;default&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;break&lt;/code&gt; 실험 키워드를 얻 습니다 . 펄 5.16에서 시작, 하나와 스위치 키워드를 앞에 수 &lt;code&gt;CORE::&lt;/code&gt; 없이 기능에 액세스 할 수 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; 문. 키워드는 &lt;code&gt;given&lt;/code&gt; 과 &lt;code&gt;when&lt;/code&gt; 와 유사 &lt;code&gt;switch&lt;/code&gt; 및 &lt;code&gt;case&lt;/code&gt; , 다른 언어 이전 섹션의 코드는 다음과 같이 재 작성 될 수 있도록</target>
        </trans-unit>
        <trans-unit id="3dcedc6c33e9a6ba46a7f82a03dd4b7c259f61b3" translate="yes" xml:space="preserve">
          <source>Under the &lt;code&gt;unicode_eval&lt;/code&gt; feature, Perl's &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; function, when passed a string, will evaluate it as a string of characters, ignoring any &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; declarations. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; exists to declare the encoding of the script, which only makes sense for a stream of bytes, not a string of characters. Source filters are forbidden, as they also really only make sense on strings of bytes. Any attempt to activate a source filter will result in an error.</source>
          <target state="translated">언더 &lt;code&gt;unicode_eval&lt;/code&gt; 기능, 펄의 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 문자열을 통과 할 때 기능은 어떤 무시하고, 문자열로 평가합니다 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 선언을. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하여 스크립트의 인코딩을 선언하십시오. 이는 문자열이 아닌 바이트 스트림에만 적합합니다. 소스 필터는 바이트 문자열에만 적용되므로 금지됩니다. 소스 필터를 활성화하려고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3ed7e8de69faa9a39e5b719579b31e326e5e1ba3" translate="yes" xml:space="preserve">
          <source>Under the Mac, it depends which environment you are using. The MacPerl shell, or MPW, is much like Unix shells in its support for several quoting variants, except that it makes free use of the Mac's non-ASCII characters as control characters.</source>
          <target state="translated">Mac에서는 사용중인 환경에 따라 다릅니다. MacPerl 쉘 (MPW)은 Mac의 비 ASCII 문자를 제어 문자로 자유롭게 사용한다는 점을 제외하고는 몇 가지 인용 변형을 지원한다는 점에서 Unix 쉘과 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="57a69bed4d30aeb2c23df15a4942d2f1bc4e9a99" translate="yes" xml:space="preserve">
          <source>Under the current implementation, the &lt;code&gt;foreach&lt;/code&gt; loop can be anywhere within the &lt;code&gt;when&lt;/code&gt; modifier's dynamic scope, but must be within the &lt;code&gt;given&lt;/code&gt; block's lexical scope. This restricted may be relaxed in a future release. See &lt;a href=&quot;#Switch-Statements&quot;&gt;Switch Statements&lt;/a&gt; below.</source>
          <target state="translated">현재 구현에서, &lt;code&gt;foreach&lt;/code&gt; 루프는 &lt;code&gt;when&lt;/code&gt; 한정자의 동적 범위 내의 어느 곳에 나있을 수 있지만 &lt;code&gt;given&lt;/code&gt; 블록의 어휘 범위 내에 있어야합니다 . 이 제한은 향후 릴리스에서 완화 될 수 있습니다. 아래의 &lt;a href=&quot;#Switch-Statements&quot;&gt;스위치 설명을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e08f959b6899ef90dffb2ee9e0e0a8572c0a7c28" translate="yes" xml:space="preserve">
          <source>Under the hood, Perl filehandles are instances of the &lt;code&gt;IO::Handle&lt;/code&gt; or &lt;code&gt;IO::File&lt;/code&gt; class. Once you have an open filehandle, you can call methods on it. Additionally, you can call methods on the &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; , and &lt;code&gt;STDERR&lt;/code&gt; filehandles.</source>
          <target state="translated">후드 아래에서 Perl 파일 핸들은 &lt;code&gt;IO::Handle&lt;/code&gt; 또는 &lt;code&gt;IO::File&lt;/code&gt; 클래스의 인스턴스입니다 . 열린 파일 핸들이 있으면 메소드를 호출 할 수 있습니다. 또한 &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; 및 &lt;code&gt;STDERR&lt;/code&gt; 파일 핸들 에서 메소드를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="27e7e970c4cb85f5a1a451cbbaa7bb6fdbefed11" translate="yes" xml:space="preserve">
          <source>Underlying implementation for the &lt;code&gt;&lt;a href=&quot;functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; Perl function. Note that the perl-level function is vaguely deprecated.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; Perl 기능 의 기본 구현 . 펄 레벨 함수는 모호하게 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3d53a031b5fe95ac3434bee7e57607b8155a1a48" translate="yes" xml:space="preserve">
          <source>Understand References Today</source>
          <target state="translated">오늘 참조 이해</target>
        </trans-unit>
        <trans-unit id="d2b515bbbe667df83c6f17f27b425a07b052435e" translate="yes" xml:space="preserve">
          <source>Understand that this removes the case-insensitivity feature of this module.</source>
          <target state="translated">이것이이 모듈의 대소 문자 구분 기능을 제거한다는 것을 이해하십시오.</target>
        </trans-unit>
        <trans-unit id="5dff374e163235318e5ce8f7742ec1049ed8b995" translate="yes" xml:space="preserve">
          <source>Understanding the Magic of Tied Hashes and Arrays</source>
          <target state="translated">묶인 해시 및 배열의 ​​마법 이해</target>
        </trans-unit>
        <trans-unit id="4fad51d89f7e0dadc266115be3afc11b52bc9806" translate="yes" xml:space="preserve">
          <source>Undertake to build a new set of Perl images using VMS commands. Since VMS does dynamic loading, it's not necessary to statically link each extension into the Perl image, so this isn't the normal build path. Consequently, it hasn't really been tested, and may well be incomplete.</source>
          <target state="translated">VMS 명령을 사용하여 새로운 Perl 이미지 세트를 빌드하십시오. VMS는 동적 로딩을 수행하므로 각 확장을 Perl 이미지에 정적으로 연결할 필요가 없으므로 일반적인 빌드 경로가 아닙니다. 결과적으로 실제로 테스트되지 않았으며 불완전 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58380a9a71bcafd994016d7b4cb1383592a7215e" translate="yes" xml:space="preserve">
          <source>Undo various types of fakery on an SV, where fakery means &quot;more than&quot; a string: if the PV is a shared string, make a private copy; if we're a ref, stop refing; if we're a glob, downgrade to an xpvmg; if we're a copy-on-write scalar, this is the on-write time when we do the copy, and is also used locally; if this is a vstring, drop the vstring magic. If &lt;code&gt;SV_COW_DROP_PV&lt;/code&gt; is set then a copy-on-write scalar drops its PV buffer (if any) and becomes SvPOK_off rather than making a copy. (Used where this scalar is about to be set to some other value.) In addition, the &lt;code&gt;flags&lt;/code&gt; parameter gets passed to &lt;code&gt;sv_unref_flags()&lt;/code&gt; when unreffing. &lt;code&gt;sv_force_normal&lt;/code&gt; calls this function with flags set to 0.</source>
          <target state="translated">SV에서 다양한 유형의 위조를 실행 취소합니다. 여기에서 위조는 &quot;이상&quot;을 의미합니다. PV가 공유 스트링 인 경우 개인 사본을 만듭니다. 우리가 심판이라면 심판을 그만두십시오. 우리가 글로브라면 xpvmg로 다운 그레이드하십시오. copy-on-write 스칼라 인 경우, 복사 할 때의 쓰기 중 시간이며 로컬에서도 사용됩니다. 이것이 vstring 인 경우 vstring 매직을 삭제하십시오. &lt;code&gt;SV_COW_DROP_PV&lt;/code&gt; 가 설정 되면 쓰기시 복사 스칼라는 PV 버퍼를 삭제하고 (있는 경우) 복사하지 않고 SvPOK_off가됩니다. (이 스칼라가 다른 값으로 설정 &lt;code&gt;sv_unref_flags()&lt;/code&gt; 경우에 사용됩니다 .) 또한 &lt;code&gt;flags&lt;/code&gt; 매개 변수는 unreffing시 sv_unref_flags ()로 전달됩니다 . &lt;code&gt;sv_force_normal&lt;/code&gt; 은 플래그를 0으로 설정하여이 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="2c0043167da52b5a8f43ef5ef3ae847c1d205a64" translate="yes" xml:space="preserve">
          <source>Undo various types of fakery on an SV: if the PV is a shared string, make a private copy; if we're a ref, stop refing; if we're a glob, downgrade to an xpvmg. See also &lt;code&gt;sv_force_normal_flags&lt;/code&gt; .</source>
          <target state="translated">SV에서 다양한 유형의 위조를 실행 취소합니다. PV가 공유 문자열 인 경우 개인 사본을 만듭니다. 우리가 심판이라면 심판을 그만두십시오. 우리가 글로브라면 xpvmg로 다운 그레이드하십시오. &lt;code&gt;sv_force_normal_flags&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f9b219af612756cb93e821fb5ae6c25750a8208b" translate="yes" xml:space="preserve">
          <source>Undocumented functions</source>
          <target state="translated">문서화되지 않은 기능</target>
        </trans-unit>
        <trans-unit id="eed18284023acb946f22279a557b952faac276d4" translate="yes" xml:space="preserve">
          <source>Unfinished Tales</source>
          <target state="translated">미완성 된 이야기</target>
        </trans-unit>
        <trans-unit id="4df58040d6486eaa853729500be20c8509618322" translate="yes" xml:space="preserve">
          <source>Unfortunately it is not that difficult somehow manage to break one's Mac OS X Perl rather severely. If all else fails and you want to really, &lt;b&gt;REALLY&lt;/b&gt;, start from scratch and remove even your Apple Perl installation (which has become corrupted somehow), the following instructions should do it. &lt;b&gt;Please think twice before following these instructions: they are much like conducting brain surgery to yourself. Without anesthesia.&lt;/b&gt; We will &lt;b&gt;not&lt;/b&gt; come to fix your system if you do this.</source>
          <target state="translated">불행히도 어쨌든 Mac OS X Perl을 심하게 손상시키는 것은 어렵지 않습니다. 다른 모든 방법으로 문제가 발생하여 실제로 &lt;b&gt;REALLY&lt;/b&gt; 하려는 경우 처음부터 시작하여 Apple Perl 설치를 제거하십시오 (어떻게 든 손상됨). 다음 지침에 따라야합니다. &lt;b&gt;이 지시 사항을 따르기 전에 두 번 생각하십시오. 그것들은 뇌 수술을하는 것과 매우 흡사합니다. 마취없이. &lt;/b&gt;우리는 할 &lt;b&gt;수 없습니다&lt;/b&gt; 당신이 할 경우 시스템을 해결하기 위해 온다.</target>
        </trans-unit>
        <trans-unit id="29de2b4590451aa9259989dd73cca2f011560c79" translate="yes" xml:space="preserve">
          <source>Unfortunately, I can't differentiate any further.</source>
          <target state="translated">불행히도, 나는 더 이상 구별 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6e14820d498a0bc4a9f36bbc1285250e475a8eba" translate="yes" xml:space="preserve">
          <source>Unfortunately, a note cannot be used with the single argument style of &lt;code&gt;ok()&lt;/code&gt; . That is, if you try &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;note&lt;/i&gt;)&lt;/code&gt;, then &lt;code&gt;Test&lt;/code&gt; will interpret this as &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;arg2&lt;/i&gt;)&lt;/code&gt;, and probably end up testing &lt;code&gt;&lt;i&gt;arg1&lt;/i&gt; eq &lt;i&gt;arg2&lt;/i&gt;&lt;/code&gt; -- and that's not what you want!</source>
          <target state="translated">불행히도, 단일 인수 스타일 &lt;code&gt;ok()&lt;/code&gt; 와 함께 메모를 사용할 수 없습니다 . 당신이 시도하는 경우 즉, &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;note&lt;/i&gt;)&lt;/code&gt; , 다음 &lt;code&gt;Test&lt;/code&gt; 로이 해석됩니다 &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;arg2&lt;/i&gt;)&lt;/code&gt; , 그리고 아마도 테스트 결국 &lt;code&gt;&lt;i&gt;arg1&lt;/i&gt; eq &lt;i&gt;arg2&lt;/i&gt;&lt;/code&gt; - 당신이 원하는 게 아니에요 그!</target>
        </trans-unit>
        <trans-unit id="7f4f5938609da571758adb22fa6ce02f230693d9" translate="yes" xml:space="preserve">
          <source>Unfortunately, interpretation of colors 0 through 7 often depends on whether the emulator supports eight colors or sixteen colors. Emulators that only support eight colors (such as the Linux console) will display colors 0 through 7 with normal brightness and ignore colors 8 through 15, treating them the same as white. Emulators that support 16 colors, such as gnome-terminal, normally display colors 0 through 7 as dim or darker versions and colors 8 through 15 as normal brightness. On such emulators, the &quot;normal&quot; white (color 7) usually is shown as pale grey, requiring bright white (15) to be used to get a real white color. Bright black usually is a dark grey color, although some terminals display it as pure black. Some sixteen-color terminal emulators also treat normal yellow (color 3) as orange or brown, and bright yellow (color 11) as yellow.</source>
          <target state="translated">불행하게도, 0에서 7까지의 색상의 해석은 에뮬레이터가 8 개의 색상을 지원하는지 16 개의 색상을 지원하는지에 따라 달라집니다. Linux 콘솔과 같이 8 가지 색상 만 지원하는 에뮬레이터는 0에서 7까지의 색상을 일반 밝기로 표시하고 8에서 15까지의 색상은 무시하고 흰색과 동일하게 처리합니다. gnome-terminal과 같은 16 가지 색상을 지원하는 에뮬레이터는 일반적으로 0 ~ 7의 색상을 희미하거나 어두운 버전으로, 8 ~ 15의 색상을 일반 밝기로 표시합니다. 이러한 에뮬레이터에서 &quot;일반&quot;흰색 (컬러 7)은 일반적으로 옅은 회색으로 표시되며, 실제 흰색을 얻으려면 밝은 흰색 (15)을 사용해야합니다. 밝은 검은 색은 보통 어두운 회색이지만 일부 터미널은 순수한 검은 색으로 표시됩니다. 일부 16 색 터미널 에뮬레이터도 일반 노란색 (3 색)을 주황색 또는 갈색으로 처리합니다.밝은 노란색 (색상 11)을 노란색으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="d3f96232328f4faede427c8ce3041998253135ab" translate="yes" xml:space="preserve">
          <source>Unfortunately, it may be that encodings are not &lt;code&gt;PerlIO&lt;/code&gt; -savvy. You can check to see whether your encoding is supported by &lt;code&gt;PerlIO&lt;/code&gt; by invoking the &lt;code&gt;perlio_ok&lt;/code&gt; method on it:</source>
          <target state="translated">불행하게도, 인코딩이 &lt;code&gt;PerlIO&lt;/code&gt; 에 정통 하지 않을 수 있습니다 . &lt;code&gt;perlio_ok&lt;/code&gt; 메소드를 호출하여 &lt;code&gt;PerlIO&lt;/code&gt; 가 인코딩을 지원하는지 여부를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fa870b38ba970158ffd4da6159a903c51d8f85af" translate="yes" xml:space="preserve">
          <source>Unfortunately, the original specification of UTF-8 leaves some room for interpretation of how many bytes of encoded output one should generate from one input Unicode character. Strictly speaking, the shortest possible sequence of UTF-8 bytes should be generated, because otherwise there is potential for an input buffer overflow at the receiving end of a UTF-8 connection. Perl always generates the shortest length UTF-8, and with warnings on, Perl will warn about non-shortest length UTF-8 along with other malformations, such as the surrogates, which are not Unicode code points valid for interchange.</source>
          <target state="translated">불행하게도, UTF-8의 원래 사양은 하나의 입력 유니 코드 문자에서 몇 바이트의 인코딩 된 출력을 생성해야 하는지를 해석 할 여지를 남겨둔다. 엄밀히 말하면, UTF-8 연결의 수신 끝에서 입력 버퍼 오버 플로우가 발생할 가능성이 있기 때문에 가능한 가장 짧은 UTF-8 바이트 시퀀스가 ​​생성되어야합니다. Perl은 항상 가장 짧은 길이의 UTF-8을 생성하며 경고가 표시되면 Perl은 가장 짧은 길이가 아닌 UTF-8에 대해 대리자와 같은 다른 기형 (교환에 유효한 유니 코드 코드 포인트가 아님)과 함께 경고합니다.</target>
        </trans-unit>
        <trans-unit id="1170c59a72df3e22ea0a090adf0e9824ff8c0b09" translate="yes" xml:space="preserve">
          <source>Unfortunately, there are quite a few deficiencies with the design (and often, the implementations) of locales. Unicode was invented (see &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; for an introduction to that) in part to address these design deficiencies, and nowadays, there is a series of &quot;UTF-8 locales&quot;, based on Unicode. These are locales whose character set is Unicode, encoded in UTF-8. Starting in v5.20, Perl fully supports UTF-8 locales, except for sorting and string comparisons. (Use &lt;a href=&quot;unicode/collate&quot;&gt;Unicode::Collate&lt;/a&gt; for these.) Perl continues to support the old non UTF-8 locales as well. There are currently no UTF-8 locales for EBCDIC platforms.</source>
          <target state="translated">불행히도 로케일의 디자인 (및 종종 구현)에는 꽤 많은 결함이 있습니다. 이러한 디자인 결함을 해결하기 위해 부분적으로 유니 코드가 개발되었으며 ( 소개에 대해서는 &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; 참조 ), 오늘날에는 유니 코드를 기반으로 일련의 &quot;UTF-8 로켈&quot;이 있습니다. 문자 세트가 유니 코드이며 UTF-8로 인코딩 된 로케일입니다. v5.20부터 Perl은 정렬 및 문자열 비교를 제외하고 UTF-8 로케일을 완전히 지원합니다. (사용 &lt;a href=&quot;unicode/collate&quot;&gt;유니 코드 :: 부씩&lt;/a&gt; 이들에 대한이.) 펄은 물론 기존 비 UTF-8 로케일을 지원하고 있습니다. 현재 EBCDIC 플랫폼에는 UTF-8 로켈이 없습니다.</target>
        </trans-unit>
        <trans-unit id="c8d518114a049f78aefe7090de8efc32eccefc83" translate="yes" xml:space="preserve">
          <source>Unfortunately, this isn't true. In perl 5.18 and earlier, AVs use &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; as a marker for indicating that an array element has not yet been initialized. Thus, &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt; $av[0]&lt;/code&gt; would be true for the above Perl code, but false for the array generated by the XS code. In perl 5.20, storing &amp;amp;PL_sv_undef will create a read-only element, because the scalar &amp;amp;PL_sv_undef itself is stored, not a copy.</source>
          <target state="translated">불행히도, 이것은 사실이 아닙니다. perl 5.18 이하에서 AV 는 배열 요소가 아직 초기화되지 않았 음을 나타내는 마커로 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; 를 사용 합니다. 따라서 위의 Perl 코드의 &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt; $av[0]&lt;/code&gt; 은 true이지만 XS 코드로 생성 된 배열의 경우 false입니다. perl 5.20에서 &amp;amp; PL_sv_undef를 저장하면 스칼라 &amp;amp; PL_sv_undef 자체가 사본이 아니라 저장되므로 읽기 전용 요소가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="5a9b09da1b70d953819b14bad175ad6e8c81c049" translate="yes" xml:space="preserve">
          <source>Unfortunately, while this &lt;code&gt;style&lt;/code&gt; variable is used to set defaults for all three directory hierarchies (core, vendor, and site), there is no guarantee that the same style is actually appropriate for all those directories. For example, $prefix might be</source>
          <target state="translated">불행히도이 &lt;code&gt;style&lt;/code&gt; 변수는 세 가지 디렉토리 계층 (핵심, 공급 업체 및 사이트) 모두에 대한 기본값을 설정하는 데 사용되지만 실제로 모든 해당 디렉토리에 동일한 스타일이 적절하다는 보장은 없습니다. 예를 들어 $ prefix는</target>
        </trans-unit>
        <trans-unit id="87c5d4faa14910842f5557a05819e468661f127e" translate="yes" xml:space="preserve">
          <source>Unfortunately, while this is true, it's still broken. All the references in @AoA refer to the</source>
          <target state="translated">불행히도 이것이 사실이지만 여전히 깨졌습니다. @AoA의 모든 참조는</target>
        </trans-unit>
        <trans-unit id="b3033d12e8c5e48f79875dd4cf162f90c243f353" translate="yes" xml:space="preserve">
          <source>Unfortunately, you may encounter Perl modules that are not</source>
          <target state="translated">불행히도, 그렇지 않은 Perl 모듈이 발생할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="76435dad798e21eb71def4f2d3a46ed9708e4adf" translate="yes" xml:space="preserve">
          <source>Unget a line of text from the server.</source>
          <target state="translated">서버에서 한 줄의 텍스트를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="9ab0bd9a6126ee4b9d7538d5c6cba7aa587f31ed" translate="yes" xml:space="preserve">
          <source>Unicode</source>
          <target state="translated">Unicode</target>
        </trans-unit>
        <trans-unit id="eb802e96fd38e5e550d19f898a4fa941c45d6b21" translate="yes" xml:space="preserve">
          <source>Unicode 7.0 changed the wording so that they are &quot;&lt;b&gt;not recommended&lt;/b&gt; for use in open interchange of Unicode text data&quot;. The 7.0 Standard goes on to say:</source>
          <target state="translated">유니 코드 7.0은 &quot; 유니 코드 텍스트 데이터의 열린 교환에 사용 &lt;b&gt;하지 않는 것이 좋습니다&lt;/b&gt; &quot;라는 문구를 변경했습니다 . 7.0 표준은 다음과 같이 말합니다.</target>
        </trans-unit>
        <trans-unit id="8306b01ff9c220d1ce9274f85cf12d457904d299" translate="yes" xml:space="preserve">
          <source>Unicode Character Properties</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a76af7c10ae9a7945dc677634ff7f287d2f0d66" translate="yes" xml:space="preserve">
          <source>Unicode Collation Algorithm</source>
          <target state="translated">유니 코드 데이터 정렬 알고리즘</target>
        </trans-unit>
        <trans-unit id="8a8a7bf1ba1b9e4c2b07e9ad90fbd26463e5d980" translate="yes" xml:space="preserve">
          <source>Unicode Consortium</source>
          <target state="translated">유니 코드 컨소시엄</target>
        </trans-unit>
        <trans-unit id="b56cce9c1325a6619b09abb29a03b2934dad13be" translate="yes" xml:space="preserve">
          <source>Unicode Encodings</source>
          <target state="translated">유니 코드 인코딩</target>
        </trans-unit>
        <trans-unit id="20d826b4f354ace01634ff9215d461c1d2de2da2" translate="yes" xml:space="preserve">
          <source>Unicode FAQ</source>
          <target state="translated">유니 코드 FAQ</target>
        </trans-unit>
        <trans-unit id="be2c3b070e201b30c780f442801bee53720d3f02" translate="yes" xml:space="preserve">
          <source>Unicode Glossary</source>
          <target state="translated">유니 코드 용어집</target>
        </trans-unit>
        <trans-unit id="c37be50216d5f3d38f1ea9b4becfe8758aaff3f3" translate="yes" xml:space="preserve">
          <source>Unicode I/O</source>
          <target state="translated">유니 코드 I / O</target>
        </trans-unit>
        <trans-unit id="4f977034e8571e3a210188dcc1d8385457a8e9f6" translate="yes" xml:space="preserve">
          <source>Unicode Normalization Forms</source>
          <target state="translated">유니 코드 정규화 양식</target>
        </trans-unit>
        <trans-unit id="775e22294d31686679c1488c3a4e009b588fb93a" translate="yes" xml:space="preserve">
          <source>Unicode Normalization Forms - UAX #15</source>
          <target state="translated">유니 코드 정규화 양식-UAX # 15</target>
        </trans-unit>
        <trans-unit id="41086ae1277eac703b49ed9c64da7c4e1e028776" translate="yes" xml:space="preserve">
          <source>Unicode Properties</source>
          <target state="translated">유니 코드 속성</target>
        </trans-unit>
        <trans-unit id="ecfb52e522a545f9d54db78a273755a7cf69910d" translate="yes" xml:space="preserve">
          <source>Unicode Recommended Reading List</source>
          <target state="translated">유니 코드 권장 읽기 목록</target>
        </trans-unit>
        <trans-unit id="3dc43797a086d2e60b97e26ddbcd0e763ba2be44" translate="yes" xml:space="preserve">
          <source>Unicode Regular Expression Support Level</source>
          <target state="translated">유니 코드 정규식 지원 수준</target>
        </trans-unit>
        <trans-unit id="47be4025952fbf3894ef86d325a9d331d9d77d10" translate="yes" xml:space="preserve">
          <source>Unicode Support</source>
          <target state="translated">유니 코드 지원</target>
        </trans-unit>
        <trans-unit id="3b3c1f4d1dbf76960cd965f0a9ee21a6e35c74bd" translate="yes" xml:space="preserve">
          <source>Unicode Useful Resources</source>
          <target state="translated">유니 코드 유용한 자료</target>
        </trans-unit>
        <trans-unit id="0bd38e8f5dc5fab318029c6a0f6bf740c02237f9" translate="yes" xml:space="preserve">
          <source>Unicode aims to &lt;b&gt;UNI&lt;/b&gt;-fy the en-&lt;b&gt;CODE&lt;/b&gt;-ings of all the world's character sets into a single Standard. For quite a few of the various coding standards that existed when Unicode was first created, converting from each to Unicode essentially meant adding a constant to each code point in the original standard, and converting back meant just subtracting that same constant. For ASCII and ISO-8859-1, the constant is 0. For ISO-8859-5, (Cyrillic) the constant is 864; for Hebrew (ISO-8859-8), it's 1488; Thai (ISO-8859-11), 3424; and so forth. This made it easy to do the conversions, and facilitated the adoption of Unicode.</source>
          <target state="translated">유니 목표 &lt;b&gt;UNI는&lt;/b&gt; 엔 - -fy &lt;b&gt;코드의&lt;/b&gt; 하나의 표준으로 전 세계의 문자 세트의 -ings을. 유니 코드가 처음 만들어 졌을 때 존재했던 다양한 코딩 표준 중 일부에 대해, 각각을 유니 코드로 변환한다는 것은 원래 표준의 각 코드 포인트에 상수를 추가하는 것을 의미했으며, 다시 변환하는 것은 동일한 상수를 빼는 것을 의미했습니다. ASCII 및 ISO-8859-1의 경우 상수는 0입니다. ISO-8859-5의 경우 (키릴 자모) 상수는 864입니다. 히브리어 (ISO-8859-8)의 경우 1488입니다. 태국어 (ISO-8859-11), 3424; 기타 등등. 이로 인해 변환이 쉬워지고 유니 코드 채택이 용이 해졌습니다.</target>
        </trans-unit>
        <trans-unit id="292b5cfbcdb907b6b9b2852bab43a1e41959e1df" translate="yes" xml:space="preserve">
          <source>Unicode also defines various</source>
          <target state="translated">유니 코드는 또한 다양한 정의</target>
        </trans-unit>
        <trans-unit id="bfb017bed191925e52b6029168924ebfe8c5d26c" translate="yes" xml:space="preserve">
          <source>Unicode and EBCDIC</source>
          <target state="translated">유니 코드 및 EBCDIC</target>
        </trans-unit>
        <trans-unit id="e27520c25eb75e7d79e8f990eeb1be4ae1df41df" translate="yes" xml:space="preserve">
          <source>Unicode and ISO/IEC 10646 are coordinated standards that unify almost all other modern character set standards, covering more than 80 writing systems and hundreds of languages, including all commercially-important modern languages. All characters in the largest Chinese, Japanese, and Korean dictionaries are also encoded. The standards will eventually cover almost all characters in more than 250 writing systems and thousands of languages. Unicode 1.0 was released in October 1991, and 6.0 in October 2010.</source>
          <target state="translated">유니 코드 및 ISO / IEC 10646은 상업적으로 중요한 모든 현대 언어를 포함하여 80 개 이상의 필기 시스템과 수백 개의 언어를 포괄하는 거의 모든 다른 현대 문자 집합 표준을 통합하는 조정 된 표준입니다. 가장 큰 중국어, 일본어 및 한국어 사전의 모든 문자도 인코딩됩니다. 이 표준은 결국 250 개 이상의 필기 시스템과 수천 개의 언어로 된 거의 모든 문자를 포괄합니다. 유니 코드 1.0은 1991 년 10 월에, 6.0은 2010 년 10 월에 릴리스되었습니다.</target>
        </trans-unit>
        <trans-unit id="35759c0ae04781f6ce2a8261ef308a0d62267332" translate="yes" xml:space="preserve">
          <source>Unicode and Localisation Support</source>
          <target state="translated">유니 코드 및 현지화 지원</target>
        </trans-unit>
        <trans-unit id="c79347889e0d28fc8f7e3b48dc5c985da6b9c2b3" translate="yes" xml:space="preserve">
          <source>Unicode and Multilingual Support in HTML, Fonts, Web Browsers and Other Applications</source>
          <target state="translated">HTML, 글꼴, 웹 브라우저 및 기타 응용 프로그램에서 유니 코드 및 다국어 지원</target>
        </trans-unit>
        <trans-unit id="aa0a00bb85a8ade7272b8fa2d081ab3abd746b2c" translate="yes" xml:space="preserve">
          <source>Unicode and UTF</source>
          <target state="translated">유니 코드 및 UTF</target>
        </trans-unit>
        <trans-unit id="8e9632880dc5b73eee711bbb8acae51558160af7" translate="yes" xml:space="preserve">
          <source>Unicode and UTF-8</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="814213da4f2b17caa9167081f902458536e3ac5c" translate="yes" xml:space="preserve">
          <source>Unicode casing is very different from ASCII casing.</source>
          <target state="translated">유니 코드 케이싱은 ASCII 케이싱과 매우 다릅니다.</target>
        </trans-unit>
        <trans-unit id="3db087027c1f3fb2dafc91bf1aec8e28ed66555f" translate="yes" xml:space="preserve">
          <source>Unicode character database</source>
          <target state="translated">유니 코드 문자 데이터베이스</target>
        </trans-unit>
        <trans-unit id="90ce74ac0f978040e744ea5f9ee3a9fc0fdd5b56" translate="yes" xml:space="preserve">
          <source>Unicode character properties that are NOT accepted by Perl</source>
          <target state="translated">Perl이 허용하지 않는 유니 코드 문자 특성</target>
        </trans-unit>
        <trans-unit id="131ad96e9210c062a5a91bbff68adb3c52f574b9" translate="yes" xml:space="preserve">
          <source>Unicode characters are assigned to</source>
          <target state="translated">유니 코드 문자는</target>
        </trans-unit>
        <trans-unit id="9cd8bdcde375ab8cc6d64998c61f22e2b1db366b" translate="yes" xml:space="preserve">
          <source>Unicode characters have a Unicode name and numeric code point (ordinal) value. Use the &lt;code&gt;\N{}&lt;/code&gt; construct to specify a character by either of these values. Certain sequences of characters also have names.</source>
          <target state="translated">유니 코드 문자는 유니 코드 이름과 숫자 코드 포인트 (정수) 값을 갖습니다. 이러한 값 중 하나로 문자를 지정 하려면 &lt;code&gt;\N{}&lt;/code&gt; 구문을 사용하십시오. 특정 문자 시퀀스에도 이름이 있습니다.</target>
        </trans-unit>
        <trans-unit id="210080ef48f936087dda80492d9856fe5ec4b9bc" translate="yes" xml:space="preserve">
          <source>Unicode classes</source>
          <target state="translated">유니 코드 클래스</target>
        </trans-unit>
        <trans-unit id="0f01459324a40b9e6a3a0e387cbfebfba5b6c62c" translate="yes" xml:space="preserve">
          <source>Unicode code points versus EBCDIC code points</source>
          <target state="translated">유니 코드 코드 포인트와 EBCDIC 코드 포인트</target>
        </trans-unit>
        <trans-unit id="7625e9ef1dd87171eb4d5354c03dd9be33744a1d" translate="yes" xml:space="preserve">
          <source>Unicode codepoint</source>
          <target state="translated">유니 코드 코드 포인트</target>
        </trans-unit>
        <trans-unit id="106885fd8f00b6d1d3909f50579c6a1e81f50c34" translate="yes" xml:space="preserve">
          <source>Unicode concept which most often is equal to uppercase, but for certain characters like the German &quot;sharp s&quot; there is a difference.</source>
          <target state="translated">대부분 대문자와 같은 유니 코드 개념이지만 독일어 &quot;sharp s&quot;와 같은 특정 문자에는 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d49075f8dbc705f2f67ea7272b64074e286787f2" translate="yes" xml:space="preserve">
          <source>Unicode defines a fourth boundary type, accessible through the &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::LineBreak&quot;&gt;Unicode::LineBreak&lt;/a&gt; module.</source>
          <target state="translated">유니 코드는 &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::LineBreak&quot;&gt;Unicode :: LineBreak&lt;/a&gt; 모듈을 통해 액세스 할 수있는 네 번째 경계 유형을 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="07aa50c4f0010de0db76a15f32c4e153b24a7275" translate="yes" xml:space="preserve">
          <source>Unicode defines all its properties in the compound form, so all single-form properties are Perl extensions. Most of these are just synonyms for the Unicode ones, but some are genuine extensions, including several that are in the compound form. And quite a few of these are actually recommended by Unicode (in &lt;a href=&quot;http://www.unicode.org/reports/tr18&quot;&gt;http://www.unicode.org/reports/tr18&lt;/a&gt;).</source>
          <target state="translated">유니 코드는 모든 속성을 복합 형식으로 정의하므로 모든 단일 양식 속성은 Perl 확장입니다. 이들 중 대부분은 유니 코드와 동의어이지만 일부는 복합 형식의 일부를 포함하여 진정한 확장입니다. 그리고 이들 중 상당수는 실제로 유니 코드 ( &lt;a href=&quot;http://www.unicode.org/reports/tr18&quot;&gt;http://www.unicode.org/reports/tr18&lt;/a&gt; ) 에서 권장합니다 .</target>
        </trans-unit>
        <trans-unit id="8557c4367cf0c9f30d95a470ee521928d669fb7c" translate="yes" xml:space="preserve">
          <source>Unicode defines characters like &lt;code&gt;LATIN CAPITAL LETTER A&lt;/code&gt; or &lt;code&gt;GREEK
SMALL LETTER ALPHA&lt;/code&gt; and unique numbers for the characters, in this case 0x0041 and 0x03B1, respectively. These unique numbers are called</source>
          <target state="translated">유니 코드는 &lt;code&gt;LATIN CAPITAL LETTER A&lt;/code&gt; 또는 &lt;code&gt;GREEK SMALL LETTER ALPHA&lt;/code&gt; 와 같은 문자와 문자의 고유 번호 (이 경우 각각 0x0041 및 0x03B1)를 정의합니다. 이 고유 번호는</target>
        </trans-unit>
        <trans-unit id="66287c5bc6e75d359bae32c20cfc35103e105bf3" translate="yes" xml:space="preserve">
          <source>Unicode does define several other decimal--and numeric--characters besides the familiar 0 to 9, such as the Arabic and Indic digits. Perl does not support string-to-number conversion for digits other than ASCII &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;9&lt;/code&gt; (and ASCII &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;f&lt;/code&gt; for hexadecimal). To get safe conversions from any Unicode string, use &lt;a href=&quot;unicode/ucd#num()&quot;&gt;num() in Unicode::UCD&lt;/a&gt;.</source>
          <target state="translated">유니 코드는 아라비아 숫자 및 인도 숫자와 같이 친숙한 0에서 9까지의 다른 10 진수 및 숫자를 정의합니다. 펄은 ASCII 이외의 숫자에 대한 문자열 - 투 - 수 전환 지원하지 않습니다 &lt;code&gt;0&lt;/code&gt; 으로 &lt;code&gt;9&lt;/code&gt; (및 ASCII 에 &lt;code&gt;f&lt;/code&gt; 진수를 들어). 유니 코드 문자열에서 안전하게 변환하려면 &lt;a href=&quot;unicode/ucd#num()&quot;&gt;Unicode :: UCD에서 num ()을&lt;/a&gt; 사용하십시오 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e0b4309884526bd11fe1ab30cc9fc6ed43648809" translate="yes" xml:space="preserve">
          <source>Unicode form that is useful when comparing strings regardless of case, as certain characters have complex one-to-many case mappings. Primarily a variant of lowercase.</source>
          <target state="translated">특정 문자에는 복잡한 일대 다 사례 매핑이 있으므로 대소 문자와 상관없이 문자열을 비교할 때 유용한 유니 코드 형식입니다. 주로 소문자의 변형입니다.</target>
        </trans-unit>
        <trans-unit id="71079ed61722f43474765527d68998144c7665d4" translate="yes" xml:space="preserve">
          <source>Unicode furnishes the &lt;code&gt;Age&lt;/code&gt; property from which this is derived. The problem with Age is that a strict interpretation of it (which Perl takes) has it matching the precise release a code point's meaning is introduced in. Thus &lt;code&gt;U+0041&lt;/code&gt; would match only 1.1; and &lt;code&gt;U+1EFF&lt;/code&gt; only 5.1. This is not usually what you want.</source>
          <target state="translated">유니 코드 는 이것이 파생 된 &lt;code&gt;Age&lt;/code&gt; 속성을 제공합니다 . Age의 문제점은 (Perl이 취하는) 엄격한 해석이 코드 포인트의 의미가 도입 된 정확한 릴리스와 일치한다는 것입니다. 따라서 &lt;code&gt;U+0041&lt;/code&gt; 은 1.1 과만 일치합니다. 및 &lt;code&gt;U+1EFF&lt;/code&gt; 에만 5.1. 이것은 일반적으로 원하는 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="fd3ab6b6f70f7431b1416e0f9107c1af48c38649" translate="yes" xml:space="preserve">
          <source>Unicode has some property-value pairs that currently don't match anything. This happens generally either because they are obsolete, or they exist for symmetry with other forms, but no language has yet been encoded that uses them. In this version of Unicode, the following match zero code points:</source>
          <target state="translated">유니 코드에는 현재 일치하지 않는 속성-값 쌍이 있습니다. 이것은 일반적으로 더 이상 사용되지 않거나 다른 형식과의 대칭을 위해 존재하지만이를 사용하는 언어는 아직 인코딩되지 않았기 때문에 발생합니다. 이 유니 코드 버전에서 다음은 0 코드 포인트와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="73c49c9d36b230f185c7169c7475e8856ddbd520" translate="yes" xml:space="preserve">
          <source>Unicode in Perl on EBCDIC</source>
          <target state="translated">EBCDIC에서 Perl의 유니 코드</target>
        </trans-unit>
        <trans-unit id="5a2ff10d38459692f18fa8f0d5e12e0027770ead" translate="yes" xml:space="preserve">
          <source>Unicode is a character set standard which plans to codify all of the writing systems of the world, plus many other symbols.</source>
          <target state="translated">유니 코드는 세계의 모든 쓰기 시스템과 기타 여러 기호를 체계화 할 문자 세트 표준입니다.</target>
        </trans-unit>
        <trans-unit id="3bb1c5615f2383d427b4613073ef1ec435b5138c" translate="yes" xml:space="preserve">
          <source>Unicode is a character set that can represent most characters in most of the world's languages, providing room for over one million different characters. Unicode 3.1 specifies 94,140 characters: The Basic Latin characters are assigned to the numbers 0 - 127. The Latin-1 Supplement with characters that are used in several European languages is in the next range, up to 255. After some more Latin extensions we find the character sets from languages using non-Roman alphabets, interspersed with a variety of symbol sets such as currency symbols, Zapf Dingbats or Braille. (You might want to visit &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; for a look at some of them - my personal favourites are Telugu and Kannada.)</source>
          <target state="translated">유니 코드는 전 세계 대부분의 언어에서 대부분의 문자를 나타낼 수있는 문자 집합으로, 백만 가지 이상의 문자를위한 공간을 제공합니다. 유니 코드 3.1은 94,140자를 지정합니다. 기본 라틴 문자는 0-127의 숫자로 지정됩니다. 여러 유럽 언어로 사용되는 문자가 포함 된 Latin-1 Supplement는 다음 범위에 있으며 최대 255 개입니다. 비 로마자 알파벳을 사용하는 언어의 문자 세트는 통화 기호, Zapf Dingbats 또는 점자와 같은 다양한 기호 세트가 산재되어 있습니다. ( &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; 를 방문 하여 그 중 일부를 살펴볼 수도 있습니다. 개인 즐겨 찾기는 Telugu와 Kannada입니다.)</target>
        </trans-unit>
        <trans-unit id="bb4b52a0e0d40f8cd4680e731fa8661db40b7bfb" translate="yes" xml:space="preserve">
          <source>Unicode is a comprehensive standard. It specifies many things outside the scope of Perl, such as how to display sequences of characters. For a full discussion of all aspects of Unicode, see &lt;a href=&quot;http://www.unicode.org&quot;&gt;http://www.unicode.org&lt;/a&gt;.</source>
          <target state="translated">유니 코드는 포괄적 인 표준입니다. 일련의 문자를 표시하는 방법과 같이 Perl 범위 밖에서 많은 것을 지정합니다. 유니 코드의 모든 측면에 대한 자세한 내용은 &lt;a href=&quot;http://www.unicode.org&quot;&gt;http://www.unicode.org를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="38d8bac67762b71e3e301bd389dd5bf647e3a7f7" translate="yes" xml:space="preserve">
          <source>Unicode is a new and complex technology and one may easily overlook certain security pitfalls. See &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt; for an overview and &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; for details, and &lt;a href=&quot;perlunicode#Security-Implications-of-Unicode&quot;&gt;Security Implications of Unicode in perlunicode&lt;/a&gt; for security implications in particular.</source>
          <target state="translated">유니 코드는 새롭고 복잡한 기술이며 특정 보안 위험을 간과 할 수 있습니다. 참조 &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt; 개요와 대한 &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; 자세한 내용 및 &lt;a href=&quot;perlunicode#Security-Implications-of-Unicode&quot;&gt;perlunicode 유니 코드의 보안 문제&lt;/a&gt; , 특히 보안 문제에 대한.</target>
        </trans-unit>
        <trans-unit id="2819bd58737a8580070f8ba307d9387529fe1cef" translate="yes" xml:space="preserve">
          <source>Unicode is encoded using several competing encodings, of which UTF-8 is the most used. In a Unicode encoding, multiple subsequent bytes can be used to store a single code point, or simply: character.</source>
          <target state="translated">유니 코드는 여러 경쟁 인코딩을 사용하여 인코딩되며 그 중 UTF-8이 가장 많이 사용됩니다. 유니 코드 인코딩에서 여러 개의 후속 바이트를 사용하여 단일 코드 포인트를 저장하거나 간단히 문자를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a66fde7942a6271294a3a5979cbe3017c3d5acd" translate="yes" xml:space="preserve">
          <source>Unicode is supported on EBCDIC platforms. See &lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt;.</source>
          <target state="translated">유니 코드는 EBCDIC 플랫폼에서 지원됩니다. &lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="989d0062ad097f9dec3fa95782856724eb6165aa" translate="yes" xml:space="preserve">
          <source>Unicode promises that the set of code points that have these two properties will never change, so something that is not quoted in v5.16 will never need to be quoted in any future Perl release. (Not all the code points that match Pattern_Syntax have actually had characters assigned to them; so there is room to grow, but they are quoted whether assigned or not. Perl, of course, would never use an unassigned code point as an actual metacharacter.)</source>
          <target state="translated">유니 코드는 이러한 두 가지 속성을 가진 코드 포인트 세트가 절대 변경되지 않기 때문에 v5.16에서 인용되지 않은 것은 향후 Perl 릴리스에서 인용 할 필요가 없습니다. (Pattern_Syntax와 일치하는 모든 코드 포인트에 실제로 문자가 할당 된 것은 아니므로 확장 할 여지가 있지만 할당 여부에 따라 인용됩니다. 물론 Perl은 할당되지 않은 코드 포인트를 실제 메타 문자로 사용하지 않습니다. )</target>
        </trans-unit>
        <trans-unit id="fb2ca4e28ea7e22cfa06c89ba6c3b93dca994a19" translate="yes" xml:space="preserve">
          <source>Unicode properties are defined (surprise!) only on Unicode code points. Starting in v5.20, when matching against &lt;code&gt;\p&lt;/code&gt; and &lt;code&gt;\P&lt;/code&gt; , Perl treats non-Unicode code points (those above the legal Unicode maximum of 0x10FFFF) as if they were typical unassigned Unicode code points.</source>
          <target state="translated">유니 코드 속성은 유니 코드 코드 포인트에서만 정의됩니다 (놀람!). v5.20부터 &lt;code&gt;\p&lt;/code&gt; 및 &lt;code&gt;\P&lt;/code&gt; 와 일치하는 경우 Perl은 비 유니 코드 코드 포인트 (법적 유니 코드 최대 값 0x10FFFF 이상)를 일반적인 할당되지 않은 유니 코드 코드 포인트처럼 취급합니다.</target>
        </trans-unit>
        <trans-unit id="139a9bb1fddefbaa23b5411336f2d45c5af1add3" translate="yes" xml:space="preserve">
          <source>Unicode publishes the names of blocks in two different styles, though the two are equivalent under Unicode's loose matching rules.</source>
          <target state="translated">유니 코드는 블록 이름을 서로 다른 두 가지 스타일로 게시하지만 둘은 유니 코드의 느슨한 일치 규칙에서 동일합니다.</target>
        </trans-unit>
        <trans-unit id="38ecc57a7a45e8fa0530ba908225186656979efa" translate="yes" xml:space="preserve">
          <source>Unicode rules are used for the case change.</source>
          <target state="translated">케이스 변경에는 유니 코드 규칙이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7088ba3066aa65d6bcc96771fbb92a42fd96dcd6" translate="yes" xml:space="preserve">
          <source>Unicode support is an extensive requirement. While Perl does not implement the Unicode standard or the accompanying technical reports from cover to cover, Perl does support many Unicode features.</source>
          <target state="translated">유니 코드 지원은 광범위한 요구 사항입니다. Perl은 유니 코드 표준 또는 그에 따른 기술 보고서를 구현하지 않지만 많은 유니 코드 기능을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="b8b243e5f3e426dd36737b42e29d2ec9970a7c1a" translate="yes" xml:space="preserve">
          <source>Unicode, of course, assigns each of those code points a particular meaning (along with ones above 255). To preserve backward compatibility, Perl only uses the Unicode meanings when there is some indication that Unicode is what is intended; otherwise the non-ASCII code points remain treated as if they are unassigned.</source>
          <target state="translated">물론 유니 코드는 이러한 각 코드 포인트에 특정 의미를 부여합니다 (255 이상과 함께). 이전 버전과의 호환성을 유지하기 위해 Perl은 유니 코드가 의도 된 것임을 나타내는 표시가있을 때 유니 코드 의미 만 사용합니다. 그렇지 않으면 비 ASCII 코드 포인트는 할당되지 않은 것처럼 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="21276899f4cb4b0159879360c7526c4fe6c28316" translate="yes" xml:space="preserve">
          <source>Unicode/Collate</source>
          <target state="translated">Unicode/Collate</target>
        </trans-unit>
        <trans-unit id="37148638183749a1c0b03d85014634d4e43c64c4" translate="yes" xml:space="preserve">
          <source>Unicode/Collate/Foo.txt</source>
          <target state="translated">Unicode/Collate/Foo.txt</target>
        </trans-unit>
        <trans-unit id="f77e952a14d870cb3ae7b18f391e8c5f3d325575" translate="yes" xml:space="preserve">
          <source>Unicode::Collate</source>
          <target state="translated">Unicode::Collate</target>
        </trans-unit>
        <trans-unit id="3ff519c896603d01c9e76e4f19191f11d112327a" translate="yes" xml:space="preserve">
          <source>Unicode::Collate - Unicode Collation Algorithm</source>
          <target state="translated">Unicode :: Collate-유니 코드 데이터 정렬 알고리즘</target>
        </trans-unit>
        <trans-unit id="72b47eca97eb095d02921b6571fab1a6dfdb0bc0" translate="yes" xml:space="preserve">
          <source>Unicode::Normalize</source>
          <target state="translated">Unicode::Normalize</target>
        </trans-unit>
        <trans-unit id="2e61bd2963848230702b059b3f915c279424ceeb" translate="yes" xml:space="preserve">
          <source>Unicode::Normalize - Unicode Normalization Forms</source>
          <target state="translated">유니 코드 :: 정규화-유니 코드 정규화 양식</target>
        </trans-unit>
        <trans-unit id="58e1ebb138145877210bc1aaddb6a695f639333f" translate="yes" xml:space="preserve">
          <source>Unicode::UCD</source>
          <target state="translated">Unicode::UCD</target>
        </trans-unit>
        <trans-unit id="878eb3fe5907f3dbbef3993a9d210c838c3bd0a6" translate="yes" xml:space="preserve">
          <source>Unicode::UCD - Unicode character database</source>
          <target state="translated">유니 코드 :: UCD-유니 코드 문자 데이터베이스</target>
        </trans-unit>
        <trans-unit id="b0e10771734c32d2d9e8385457afb6c4bd746163" translate="yes" xml:space="preserve">
          <source>Unicode::UCD::UnicodeVersion</source>
          <target state="translated">Unicode::UCD::UnicodeVersion</target>
        </trans-unit>
        <trans-unit id="c884d01b9429a9f7304a835d13687b8ca5872d3c" translate="yes" xml:space="preserve">
          <source>Unified method to both set and get options in the SOL_SOCKET level. If called with one argument then getsockopt is called, otherwise setsockopt is called.</source>
          <target state="translated">SOL_SOCKET 수준에서 옵션을 설정하고 가져 오는 통합 된 방법. 하나의 인수로 호출하면 getsockopt가 호출되고, 그렇지 않으면 setsockopt가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="238642af65f3add9fa062158d9a8954a0d8cc5fc" translate="yes" xml:space="preserve">
          <source>Unimplemented, but you can use &lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt; and the &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; module to achieve similar things.</source>
          <target state="translated">구현되지 않았지만 &lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt; 와 &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; 모듈을 사용하여 비슷한 것을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6635fe323dcba6e8b8b2d5cdbb340361ce906ed" translate="yes" xml:space="preserve">
          <source>Universal Binary support</source>
          <target state="translated">범용 이진 지원</target>
        </trans-unit>
        <trans-unit id="cecc0d8500754b34f5bd7f11dfabb25c3a770aaf" translate="yes" xml:space="preserve">
          <source>Unix</source>
          <target state="translated">Unix</target>
        </trans-unit>
        <trans-unit id="2fb49d2b5adcca8ced12a532099ac9adce5647b1" translate="yes" xml:space="preserve">
          <source>Unix Network Programming, 2nd Edition, Volume 1</source>
          <target state="translated">유닉스 네트워크 프로그래밍, 2 판, 1 권</target>
        </trans-unit>
        <trans-unit id="b4c5506923f63fcc0ec2a3603b475130b23382af" translate="yes" xml:space="preserve">
          <source>Unix Review</source>
          <target state="translated">유닉스 검토</target>
        </trans-unit>
        <trans-unit id="4b39a128140df62988dc25aafca006880dd71ad2" translate="yes" xml:space="preserve">
          <source>Unix has no need of special linker flags.</source>
          <target state="translated">유닉스에는 특별한 링커 플래그가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="faa3f11d873bf24fcae352a27226c0c2e88d087f" translate="yes" xml:space="preserve">
          <source>Unix's &lt;code&gt;#!&lt;/code&gt; technique can be simulated on other systems:</source>
          <target state="translated">유닉스의 &lt;code&gt;#!&lt;/code&gt; 기술은 다른 시스템에서 시뮬레이션 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f87c004392cd89a556aff5f86328de12b9ca773" translate="yes" xml:space="preserve">
          <source>Unix-Domain TCP Clients and Servers</source>
          <target state="translated">유닉스 도메인 TCP 클라이언트 및 서버</target>
        </trans-unit>
        <trans-unit id="4acfa258fe45e38658aa00a5dfda8b8abeddb8cc" translate="yes" xml:space="preserve">
          <source>Unix-domain sockets on OS/2 live in a pseudo-file-system &lt;code&gt;/sockets/...&lt;/code&gt; . To avoid a failure to create a socket with a name of a different form, &lt;code&gt;&quot;/socket/&quot;&lt;/code&gt; is prepended to the socket name (unless it starts with this already).</source>
          <target state="translated">OS / 2의 유닉스 도메인 소켓은 의사 파일 시스템 &lt;code&gt;/sockets/...&lt;/code&gt; 에 있습니다. 다른 형식의 이름으로 소켓을 작성하는 데 실패하지 않도록 &lt;code&gt;&quot;/socket/&quot;&lt;/code&gt; 이 소켓 이름 앞에 붙습니다 (이미 시작하지 않는 한).</target>
        </trans-unit>
        <trans-unit id="4f3c45c8b86738464ace2f8005c8fbdecfe76366" translate="yes" xml:space="preserve">
          <source>Unix.U</source>
          <target state="translated">Unix.U</target>
        </trans-unit>
        <trans-unit id="516d733c8bf9db439f1f86408315d55784a8e43c" translate="yes" xml:space="preserve">
          <source>Unknown '=xxxx' commands, unknown 'X&amp;lt;...&amp;gt;' interior-sequences, and unterminated interior sequences.</source>
          <target state="translated">알 수없는 '= xxxx'명령, 알 수없는 'X &amp;lt;...&amp;gt;'내부 시퀀스 및 종료되지 않은 내부 시퀀스</target>
        </trans-unit>
        <trans-unit id="48c5c163aa1fa71615dee0d3c90ca77bf54723d6" translate="yes" xml:space="preserve">
          <source>Unknown result token.</source>
          <target state="translated">알 수없는 결과 토큰.</target>
        </trans-unit>
        <trans-unit id="4013e411624fa8892f8200feafb69475d2458d0b" translate="yes" xml:space="preserve">
          <source>Unknowns are &lt;code&gt;&quot;-&quot;&lt;/code&gt; . Unknowns can happen unfortunately quite easily: if the platform doesn't support retrieving the information; if the binary is missing the debug information; if the optimizer has transformed the code by for example inlining.</source>
          <target state="translated">미지수는 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 입니다. 플랫폼이 정보 검색을 지원하지 않는 경우 알 수없는 결과는 불행히도 매우 쉽게 발생할 수 있습니다. 바이너리에 디버그 정보가없는 경우; 옵티마이 저가 예를 들어 인라인으로 코드를 변환 한 경우</target>
        </trans-unit>
        <trans-unit id="ce906b20ea9a7a0bf0bcbae85c1c9421e3de60b2" translate="yes" xml:space="preserve">
          <source>Unless %hash has already been locked the key/value could be deleted regardless of this setting.</source>
          <target state="translated">% hash가 이미 잠겨 있지 않으면이 설정에 관계없이 키 / 값을 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c6af5673dc4ae00136df64bec88a6550bf388e5" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;${^UNICODE}&lt;/code&gt; (available starting in v5.8.2) exists and is non-zero, the PerlIO layers of &lt;code&gt;STDIN&lt;/code&gt; and &lt;code&gt;STDOUT&lt;/code&gt; are set to &quot;&lt;code&gt;:encoding(&lt;i&gt;ENCNAME&lt;/i&gt;)&lt;/code&gt;&quot;. Therefore,</source>
          <target state="translated">않는 &lt;code&gt;${^UNICODE}&lt;/code&gt; (v5.8.2 가능 시작)가 존재하고 비 제로의 층은 PerlIO &lt;code&gt;STDIN&lt;/code&gt; 및 &lt;code&gt;STDOUT&lt;/code&gt; 가 설정된다 &quot; &lt;code&gt;:encoding(&lt;i&gt;ENCNAME&lt;/i&gt;)&lt;/code&gt; &quot;. 따라서,</target>
        </trans-unit>
        <trans-unit id="c4a238cf9ea26a0e7ddfda497c5bf0d771bd8656" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;-DPERL_MEM_LOG_NOIMPL&lt;/code&gt; is also compiled, the logging functions read $ENV{PERL_MEM_LOG} to determine whether to log the event, and if so how:</source>
          <target state="translated">&lt;code&gt;-DPERL_MEM_LOG_NOIMPL&lt;/code&gt; 도 컴파일 되지 않으면 로깅 함수는 $ ENV {PERL_MEM_LOG}를 읽고 이벤트 로그 여부를 판별합니다.</target>
        </trans-unit>
        <trans-unit id="7183c27cf3fecde6bcc64c00a3a891d43f73c77b" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;LIBPATHSTRICT&lt;/code&gt; is set to &lt;code&gt;T&lt;/code&gt; (and the kernel is after 2000/09/01), such DLLs are considered to be global. When loading a global DLL it is first looked in the table of already-loaded global DLLs. Because of this the fact that one executable loaded a DLL from &lt;code&gt;BEGINLIBPATH&lt;/code&gt; and &lt;code&gt;ENDLIBPATH&lt;/code&gt; , or</source>
          <target state="translated">&lt;code&gt;LIBPATHSTRICT&lt;/code&gt; 가 &lt;code&gt;T&lt;/code&gt; 로 설정되어 있지 않으면 (그리고 커널이 2000/09/01 이후), 이러한 DLL은 전역으로 간주됩니다. 전역 DLL을로드 할 때는 먼저 이미로드 된 전역 DLL 테이블에서 확인합니다. 이 때문에 하나의 실행 파일이 &lt;code&gt;BEGINLIBPATH&lt;/code&gt; 및 &lt;code&gt;ENDLIBPATH&lt;/code&gt; 에서 DLL을로드 했거나</target>
        </trans-unit>
        <trans-unit id="025ed2d87cd53899da043f16934d54b56cb767cf" translate="yes" xml:space="preserve">
          <source>Unless ASCII vs. EBCDIC issues are specifically being discussed, references to UTF-8 encoding in this document and elsewhere should be read as meaning UTF-EBCDIC on EBCDIC platforms. See &lt;a href=&quot;perlebcdic#Unicode-and-UTF&quot;&gt;Unicode and UTF in perlebcdic&lt;/a&gt;.</source>
          <target state="translated">ASCII 대 EBCDIC 문제가 구체적으로 논의되지 않는 한,이 문서 및 다른 곳에서 UTF-8 인코딩에 대한 참조는 EBCDIC 플랫폼에서 UTF-EBCDIC를 의미하는 것으로 읽혀 져야합니다. &lt;a href=&quot;perlebcdic#Unicode-and-UTF&quot;&gt;perlebcdic의 유니 코드 및 UTF를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="763e516abf0169c17797549989072db7b3b436d9" translate="yes" xml:space="preserve">
          <source>Unless otherwise noted, functions return 0 on success, or a negative value (usually &lt;code&gt;EOF&lt;/code&gt; which is usually -1) and set &lt;code&gt;errno&lt;/code&gt; on error.</source>
          <target state="translated">달리 명시하지 않는 한, 함수는 성공하면 0을 반환하거나 음수 값 ( 보통 -1 인 &lt;code&gt;EOF&lt;/code&gt; ) 을 반환 하고 오류시 &lt;code&gt;errno&lt;/code&gt; 를 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="843ebacc41e4317d9c7bf3f947fad475a9e1f11b" translate="yes" xml:space="preserve">
          <source>Unless otherwise notes, all examples below require this standard preamble to work correctly, with the &lt;code&gt;#!&lt;/code&gt; adjusted to work on your system:</source>
          <target state="translated">별도의 언급이없는 한, 아래의 모든 예는이 표준 프리앰블이 &lt;code&gt;#!&lt;/code&gt; 시스템에서 작동하도록 조정 :</target>
        </trans-unit>
        <trans-unit id="519ecd12b4838877006c606ab377c9933076da06" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated all methods return either a</source>
          <target state="translated">달리 명시되지 않는 한 모든 메소드는</target>
        </trans-unit>
        <trans-unit id="58c869a304e00ffd24d619f7d44db8d57f44a80c" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated it works just like ExtUtils::MM_Unix</source>
          <target state="translated">달리 명시되지 않는 한 ExtUtils :: MM_Unix와 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="caa9da45012bfbe0b5378d58f4fff0a9abfa58b5" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, it works just like ExtUtils::MM_Unix</source>
          <target state="translated">달리 명시되지 않는 한 ExtUtils :: MM_Unix와 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="42e400a7ab19dec964d9377da14546fab4feb3ec" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;anyinflate&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">아래에 명시되지 않는 한 &lt;code&gt;anyinflate&lt;/code&gt; 의 선택적 매개 변수 인 &lt;code&gt;OPTS&lt;/code&gt; 는 아래 &lt;a href=&quot;#Constructor-Options&quot;&gt;생성자 옵션&lt;/a&gt; 섹션에 정의 된 OO 인터페이스에 사용 된 것과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="47a707f463b0bb3f1b25444c520600dbd6696505" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;anyuncompress&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">아래에 명시하지 않는 한, 대한 선택적 매개 변수 &lt;code&gt;anyuncompress&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; 은 의에 정의 된 OO 인터페이스에 사용 된 것과 동일 &lt;a href=&quot;#Constructor-Options&quot;&gt;생성자 옵션&lt;/a&gt; 아래 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d669d839575081392547a5a9cafaedbd09bec28c" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;bunzip2&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">아래에서 지정하지 않는 한 &lt;code&gt;bunzip2&lt;/code&gt; 에 대한 선택적 매개 변수 인 &lt;code&gt;OPTS&lt;/code&gt; 는 아래 &lt;a href=&quot;#Constructor-Options&quot;&gt;생성자 옵션&lt;/a&gt; 섹션에 정의 된 OO 인터페이스에 사용 된 것과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="5cd0d3bee7135d518d8ccc595535d8b3eccde37f" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;bzip2&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">아래에 지정되지 않은 경우 &lt;code&gt;bzip2&lt;/code&gt; 의 선택적 매개 변수 인 &lt;code&gt;OPTS&lt;/code&gt; 는 아래 &lt;a href=&quot;#Constructor-Options&quot;&gt;생성자 옵션&lt;/a&gt; 섹션에 정의 된 OO 인터페이스에 사용 된 것과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="2d2f8a94031befaa66720968f47bd4dde9da6fcf" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;deflate&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">아래에 명시되지 않는 한 &lt;code&gt;deflate&lt;/code&gt; 의 선택적 매개 변수 인 &lt;code&gt;OPTS&lt;/code&gt; 는 아래 &lt;a href=&quot;#Constructor-Options&quot;&gt;생성자 옵션&lt;/a&gt; 섹션에 정의 된 OO 인터페이스에 사용 된 것과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="f180e51799fa543d0272bd825b3d860097f806c2" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;gunzip&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">아래에 지정되지 않은 경우 &lt;code&gt;gunzip&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; 의 선택적 매개 변수는 아래 &lt;a href=&quot;#Constructor-Options&quot;&gt;생성자 옵션&lt;/a&gt; 섹션에 정의 된 OO 인터페이스에 사용 된 매개 변수 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="43b54de84f56f9f511018d58087cdd33377321ec" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;gzip&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">아래에 지정되지 않은 경우 &lt;code&gt;gzip&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; 의 선택적 매개 변수는 아래 &lt;a href=&quot;#Constructor-Options&quot;&gt;생성자 옵션&lt;/a&gt; 섹션에 정의 된 OO 인터페이스에 사용 된 매개 변수 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="d8c0791fbf600370c86e6ae040e4b2abd896e9ba" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;inflate&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">아래에 명시되지 않는 한, &lt;code&gt;inflate&lt;/code&gt; 에 대한 선택적 매개 변수 인 &lt;code&gt;OPTS&lt;/code&gt; 는 아래 &lt;a href=&quot;#Constructor-Options&quot;&gt;생성자 옵션&lt;/a&gt; 섹션에 정의 된 OO 인터페이스에 사용 된 것과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="e65e4b1379d48c357409defc2e3a088bfcc64051" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;rawdeflate&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">아래에 명시되지 않는 한 &lt;code&gt;rawdeflate&lt;/code&gt; 의 선택적 매개 변수 인 &lt;code&gt;OPTS&lt;/code&gt; 는 아래 &lt;a href=&quot;#Constructor-Options&quot;&gt;생성자 옵션&lt;/a&gt; 섹션에 정의 된 OO 인터페이스에 사용 된 것과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="f9aa434ca385a7cef6abc358c51e5f3189796565" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;rawinflate&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">아래에 명시되지 않는 한 &lt;code&gt;rawinflate&lt;/code&gt; 의 선택적 매개 변수 인 &lt;code&gt;OPTS&lt;/code&gt; 는 아래 의 &lt;a href=&quot;#Constructor-Options&quot;&gt;생성자 옵션&lt;/a&gt; 섹션에 정의 된 OO 인터페이스에 사용 된 것과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="e2285dec1544503fb1e6e19eb0aec81e1f5a9726" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;unzip&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">아래에 명시되지 않는 한 &lt;code&gt;unzip&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; 에 대한 선택적 매개 변수는 아래 &lt;a href=&quot;#Constructor-Options&quot;&gt;생성자 옵션&lt;/a&gt; 섹션에 정의 된 OO 인터페이스에 사용 된 매개 변수 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="f45874d912d180929ebed6cffec516fc7cf2fb97" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;zip&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">아래에서 지정하지 않는 한 &lt;code&gt;zip&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; 의 선택적 매개 변수는 아래 &lt;a href=&quot;#Constructor-Options&quot;&gt;생성자 옵션&lt;/a&gt; 섹션에 정의 된 OO 인터페이스에 사용 된 매개 변수 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="871cfac0f7d812719fa8ee355ce0991623ac4e0b" translate="yes" xml:space="preserve">
          <source>Unless specified otherwise all method can be called as class methods, or as object methods. If called as class methods then the &quot;default&quot; object will be used, and if necessary created using the current processes %Config and @INC. See the 'default' option to new() for details.</source>
          <target state="translated">달리 명시되지 않는 한 모든 메소드는 클래스 메소드 또는 오브젝트 메소드로 호출 될 수 있습니다. 클래스 메소드로 호출되면 &quot;default&quot;오브젝트가 사용되며 필요한 경우 현재 프로세스 % Config 및 @INC를 사용하여 작성됩니다. 자세한 내용은 'default'옵션을 new ()로 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="360b129724fa7c1c8235f3513edf30406e818a7b" translate="yes" xml:space="preserve">
          <source>Unless the &lt;code&gt;/r&lt;/code&gt; option is used, the string specified with &lt;code&gt;=~&lt;/code&gt; must be a scalar variable, an array element, a hash element, or an assignment to one of those; in other words, an lvalue.</source>
          <target state="translated">&lt;code&gt;/r&lt;/code&gt; 옵션을 사용 하지 않으면 &lt;code&gt;=~&lt;/code&gt; 로 지정된 문자열 은 스칼라 변수, 배열 요소, 해시 요소 또는 그 중 하나에 대한 지정이어야합니다. 다시 말해, lvalue입니다.</target>
        </trans-unit>
        <trans-unit id="9ef73743f2ca77d91834c677a3b2a131dd0854b0" translate="yes" xml:space="preserve">
          <source>Unless the above additional feature is enabled, nothing about the backtrace functionality is visible, except for the Perl/XS level.</source>
          <target state="translated">위의 추가 기능을 사용하지 않으면 Perl / XS 레벨을 제외하고 역 추적 기능에 대한 정보가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c2c4cb992d99b0b97748811097f97eea4d2ce81b" translate="yes" xml:space="preserve">
          <source>Unless the operator is an assignment (&lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; , etc.), repeat step (1) in respect of the second operand.</source>
          <target state="translated">연산자가 대입 ( &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; 등) 이 아닌 한 두 번째 피연산자에 대해 단계 (1)을 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="2c6634c0ddc3b2fcdacf253fa92fd7c8403abaf0" translate="yes" xml:space="preserve">
          <source>Unless the pattern or string are encoded in UTF-8, only ASCII characters can match positively.</source>
          <target state="translated">패턴 또는 문자열이 UTF-8로 인코딩되지 않은 경우 ASCII 문자 만 양으로 일치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93f6520e33056598a5ce68e86d15794aa942a8a6" translate="yes" xml:space="preserve">
          <source>Unless they are explicitly specified, the default values for the exit status, verbose level, and output stream to use are determined as follows:</source>
          <target state="translated">명시 적으로 지정하지 않으면 종료 상태, 상세 레벨 및 사용할 출력 스트림의 기본값은 다음과 같이 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="28631a8600ab2d0e4799cb9a021cc0306169b6f9" translate="yes" xml:space="preserve">
          <source>Unless you are accessing the CPAN on your filesystem via a file: URL, CPAN.pm needs to keep the source files it downloads somewhere. Please supply a directory where the downloaded files are to be kept.</source>
          <target state="translated">파일 : URL을 통해 파일 시스템의 CPAN에 액세스하지 않는 한 CPAN.pm은 다운로드 한 소스 파일을 어딘가에 보관해야합니다. 다운로드 한 파일을 보관할 디렉토리를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="6b861eac07037b268358d427fce8707b48f9500e" translate="yes" xml:space="preserve">
          <source>Unless you are using the &lt;code&gt;fields&lt;/code&gt; pragma, consider this module discouraged in favor of the lighter-weight &lt;code&gt;parent&lt;/code&gt; .</source>
          <target state="translated">pragma &lt;code&gt;fields&lt;/code&gt; 사용하지 않는 한이 모듈은 더 가벼운 &lt;code&gt;parent&lt;/code&gt; 를 선호하지 않는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="84f0f4d743460958895c1346a2bcc4ae32486815" translate="yes" xml:space="preserve">
          <source>Unless you don't like the possibility of there being part of your Perl scripts embedded in a database file, this is nothing to worry about.</source>
          <target state="translated">데이터베이스 파일에 Perl 스크립트의 일부가 포함될 가능성이 마음에 들지 않으면 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="078c8b3d64fda031c2ca3a111adc19b05790c7fb" translate="yes" xml:space="preserve">
          <source>Unless you have a particular reason to use the two-argument form you should use the three-argument form of open() which does not treat any characters in the filename as special.</source>
          <target state="translated">두 인수 형식을 사용해야하는 특별한 이유가 없으면 파일 이름의 문자를 특수 문자로 취급하지 않는 open ()의 세 가지 인수 형식을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="bcd145902080112cd3bd3565e1aa0b2eb6698439" translate="yes" xml:space="preserve">
          <source>Unless you have good reasons for using some other format (for example, a format used within your company), the convention is to name your changelog file &lt;code&gt;Changes&lt;/code&gt; , and to follow the simple format described in &lt;a href=&quot;http://search.cpan.org/perldoc/CPAN::Changes::Spec&quot;&gt;CPAN::Changes::Spec&lt;/a&gt;.</source>
          <target state="translated">다른 형식 (예 : 회사 내에서 사용되는 형식)을 사용해야 할 이유가없는 경우 규칙은 변경 로그 파일의 이름을 &lt;code&gt;Changes&lt;/code&gt; 로 지정하고 &lt;a href=&quot;http://search.cpan.org/perldoc/CPAN::Changes::Spec&quot;&gt;CPAN :: Changes :: Spec에&lt;/a&gt; 설명 된 간단한 형식을 따르는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="ba7a1f205e8e2686b0c4b6d39cce725cef83741e" translate="yes" xml:space="preserve">
          <source>Unless you know better, serializing hook should always say:</source>
          <target state="translated">더 잘 알지 못하면 직렬화 후크는 항상 다음과 같이 말해야합니다.</target>
        </trans-unit>
        <trans-unit id="4f5f76f31b82833340ef52081bb4d0e79eab2cc2" translate="yes" xml:space="preserve">
          <source>Unless you know with 100% certainty that quux() is only ever available for the &quot;Foonix&quot; operating system &lt;b&gt;and&lt;/b&gt; that is available &lt;b&gt;and&lt;/b&gt; correctly working for &lt;b&gt;all&lt;/b&gt; past, present, &lt;b&gt;and&lt;/b&gt; future versions of &quot;Foonix&quot;, the above is very wrong. This is more correct (though still not perfect, because the below is a compile-time check):</source>
          <target state="translated">당신이 100 %로 quux ()는 &quot;Foonix&quot;운영 체제에 대해 오직 사용할 수 있음을 확실히 알고하지 않는 한 &lt;b&gt;그리고&lt;/b&gt; 그 사용할 수 &lt;b&gt;와&lt;/b&gt; 제대로 일하는 &lt;b&gt;모든&lt;/b&gt; 과거, 현재, &lt;b&gt;그리고&lt;/b&gt; &quot;Foonix&quot;의 미래 버전, 위에서 언급 한 매우 잘못된 것입니다. 이것은 더 정확합니다 (아래는 컴파일 타임 검사이므로 여전히 완벽하지는 않습니다).</target>
        </trans-unit>
        <trans-unit id="93ff79231a3d36c0c3d8ce3114e701a1baebbf25" translate="yes" xml:space="preserve">
          <source>Unless you set this attribute to a false value, Pod::Search will recurse into subdirectories of the search directories.</source>
          <target state="translated">이 속성을 false로 설정하지 않으면 Pod :: Search는 검색 디렉토리의 하위 디렉토리로 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="17c62f898b45d3be500e6c39bec8d493a60a2715" translate="yes" xml:space="preserve">
          <source>Unless you set this attribute to a true value, Pod::Search will apply Perl-specific heuristics to find the correct module PODs quickly. This attribute's default value is false. You won't normally need to set this to true.</source>
          <target state="translated">이 속성을 true로 설정하지 않으면 Pod :: Search는 Perl 특정 휴리스틱을 적용하여 올바른 모듈 POD를 빠르게 찾습니다. 이 속성의 기본값은 false입니다. 일반적으로 이것을 true로 설정할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="9f9a16887abf4c916f1550cac344cc208f6c0b6b" translate="yes" xml:space="preserve">
          <source>Unless you set this attribute to a true value, Pod::Simple::Search will consider only the first file of a given modulename as it looks thru the specified directories; that is, with this option off, if Pod::Simple::Search has seen a &lt;code&gt;somepathdir/Foo/Bar.pm&lt;/code&gt; already in this search, then it won't bother looking at a &lt;code&gt;somelaterpathdir/Foo/Bar.pm&lt;/code&gt; later on in that search, because that file is merely a &quot;shadow&quot;. But if you turn on &lt;code&gt;$self-&amp;gt;shadows(1)&lt;/code&gt; , then these &quot;shadow&quot; files are inspected too, and are noted in the pathname2podname return hash.</source>
          <target state="translated">이 속성을 true로 설정하지 않으면 Pod :: Simple :: Search는 지정된 디렉토리를 통해 지정된 모듈 이름의 첫 번째 파일 만 고려합니다. 즉,이 옵션이 꺼져 있으면 포드 :: Simple :: Search 가이 검색에서 &lt;code&gt;somepathdir/Foo/Bar.pm&lt;/code&gt; 을 이미 본 경우 나중에 &lt;code&gt;somelaterpathdir/Foo/Bar.pm&lt;/code&gt; 을 보지 않아도 됩니다. 해당 파일은 &quot;그림자&quot;일뿐입니다. 그러나 &lt;code&gt;$self-&amp;gt;shadows(1)&lt;/code&gt; 을 켜면 이러한 &quot;shadow&quot;파일도 검사되며 pathname2podname return hash에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="fa89971032de2d3d226811c31dc2014b63de305b" translate="yes" xml:space="preserve">
          <source>Unless you want to override the defaults, prefer META_MERGE so as to get the advantage of any future defaults.</source>
          <target state="translated">기본값을 무시하지 않는 한, 향후 기본값을 활용하려면 META_MERGE를 선호하십시오.</target>
        </trans-unit>
        <trans-unit id="eb83985aa16dab9a13560a8e8f1159fe638efa8b" translate="yes" xml:space="preserve">
          <source>Unless you want to use its advanced features, this is probably all you need to know to use Exporter.</source>
          <target state="translated">고급 기능을 사용하지 않으려면 Exporter를 사용하기 위해 알아야 할 모든 것입니다.</target>
        </trans-unit>
        <trans-unit id="04c205c66e7bc90d55cfb8afb031ef118a5c83da" translate="yes" xml:space="preserve">
          <source>Unless you&amp;rsquo;ve used &lt;code&gt;/a&lt;/code&gt; or &lt;code&gt;/aa&lt;/code&gt; , &lt;code&gt;\d&lt;/code&gt; matches more than ASCII digits only, but Perl&amp;rsquo;s implicit string-to-number conversion does not current recognize these. Here&amp;rsquo;s how to convert such strings manually.</source>
          <target state="translated">당신이 사용하지 않는 한 &lt;code&gt;/a&lt;/code&gt; 나 &lt;code&gt;/aa&lt;/code&gt; , &lt;code&gt;\d&lt;/code&gt; 경우에만 ASCII 숫자보다 더 많은 경기를하지만, 펄의 암시 적 문자열에 번호 변환이 현재하지 않는 이러한 인식하고 있습니다. 이러한 문자열을 수동으로 변환하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5d5045afa1f26fa3558f3707783d1ac5db1ca1f3" translate="yes" xml:space="preserve">
          <source>Unless you're writing a new &lt;a href=&quot;sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;, a plugin or subclassing &lt;a href=&quot;../parser&quot;&gt;TAP::Parser&lt;/a&gt;, you probably won't need to use this module directly.</source>
          <target state="translated">플러그인 또는 &lt;a href=&quot;../parser&quot;&gt;TAP :: Parser를&lt;/a&gt; 서브 클래 싱 하는 새로운 &lt;a href=&quot;sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler를&lt;/a&gt; 작성하지 않는 한이 모듈을 직접 사용할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="26769d51e7e8546d072ce687409eedaf6bbd7d27" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#charinfo()&quot;&gt;charinfo()&lt;/a&gt;, this does not include the decomposition type. Use the &lt;code&gt;Decomposition_Type&lt;/code&gt; property to get that.</source>
          <target state="translated">&lt;a href=&quot;#charinfo()&quot;&gt;charinfo ()&lt;/a&gt; 와 달리 분해 유형은 포함되지 않습니다. 그것을 얻으려면 &lt;code&gt;Decomposition_Type&lt;/code&gt; 속성을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f7823a1b5c73e2c047f503abcdbc0ee1982c031" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;integer&quot;&gt;integer&lt;/a&gt;, this pragma creates integer constants that are only limited in their size by the available memory and CPU time.</source>
          <target state="translated">&lt;a href=&quot;integer&quot;&gt;integer&lt;/a&gt; 와 달리이 pragma는 사용 가능한 메모리와 CPU 시간에 따라 크기가 제한된 정수 상수를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="ed386882eb03009cdfed1d7cc619e0742b192d68" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;dbmopen&quot;&gt;dbmopen&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; function will not &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; a module for you; you need to do that explicitly yourself. See &lt;a href=&quot;../db_file&quot;&gt;DB_File&lt;/a&gt; or the</source>
          <target state="translated">달리 &lt;code&gt;&lt;a href=&quot;dbmopen&quot;&gt;dbmopen&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 기능을하지 않습니다 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 하거나 &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 당신을위한 모듈; 직접 명시 적으로해야합니다. 참조 &lt;a href=&quot;../db_file&quot;&gt;DB_File&lt;/a&gt; 또는</target>
        </trans-unit>
        <trans-unit id="e6074edfe48b345d15827a75a36946caff143c7a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;functions/dbmopen&quot;&gt;dbmopen&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; function will not &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; a module for you; you need to do that explicitly yourself. See &lt;a href=&quot;db_file&quot;&gt;DB_File&lt;/a&gt; or the</source>
          <target state="translated">달리 &lt;code&gt;&lt;a href=&quot;functions/dbmopen&quot;&gt;dbmopen&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 기능을하지 않습니다 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 하거나 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 당신을위한 모듈; 직접 명시 적으로해야합니다. 참조 &lt;a href=&quot;db_file&quot;&gt;DB_File&lt;/a&gt; 또는</target>
        </trans-unit>
        <trans-unit id="7f221507f852d26a177998f0fca0127e91483ffd" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;functions/for&quot;&gt;for...in&lt;/a&gt;&lt;/code&gt;, Perl's &lt;code&gt;for&lt;/code&gt; (also spelled &lt;code&gt;foreach&lt;/code&gt; ) does not allow the left-hand side to be an arbitrary expression. It must be a variable:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/for&quot;&gt;for...in&lt;/a&gt;&lt;/code&gt; 과 달리 Perl 's &lt;code&gt;for&lt;/code&gt; (또한 철자법 &lt;code&gt;foreach&lt;/code&gt; )는 왼쪽이 임의의 표현이 될 수 없습니다. 변수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="2d1c847135806754dca42b817cb04eaf19cedf87" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; does not do what you probably mean when you pass it an array as your first argument. The array is given scalar context, and instead of using the 0th element of the array as the format, Perl will use the count of elements in the array as the format, which is almost never useful.</source>
          <target state="translated">달리 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 와는 당신이 당신의 첫 번째 인수로 배열을 통과 할 때 아마 당신은 무엇을 의미하지 않습니다. 배열에는 스칼라 컨텍스트가 제공되며 배열의 0 번째 요소를 형식으로 사용하는 대신 Perl은 배열의 요소 수를 형식으로 사용하므로 거의 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="89ae4f74127125a7e7d48317841dc79dfceae6a6" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; does not do what you probably mean when you pass it an array as your first argument. The array is given scalar context, and instead of using the 0th element of the array as the format, Perl will use the count of elements in the array as the format, which is almost never useful.</source>
          <target state="translated">달리 &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 와는 당신이 당신의 첫 번째 인수로 배열을 통과 할 때 아마 당신은 무엇을 의미하지 않습니다. 배열에는 스칼라 컨텍스트가 제공되며 배열의 0 번째 요소를 형식으로 사용하는 대신 Perl은 배열의 요소 수를 형식으로 사용하므로 거의 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9885543c31cf8cf0906d34d4b26f89726d373169" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;which&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; , this function is platform independent and will also work on, for example, Win32.</source>
          <target state="translated">&lt;code&gt;which&lt;/code&gt; 및 &lt;code&gt;type&lt;/code&gt; 과 달리이 기능은 플랫폼 독립적이며 Win32와 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a93ac07922c6fc8a77d40224ee6574380d8e4055" translate="yes" xml:space="preserve">
          <source>Unlike Win32 build, miniperl will not have</source>
          <target state="translated">Win32 빌드와 달리 miniperl은</target>
        </trans-unit>
        <trans-unit id="a7c35c87e2cd92f458c69ed20a29518c1fc60ceb" translate="yes" xml:space="preserve">
          <source>Unlike constants in some languages, these cannot be overridden on the command line or via environment variables.</source>
          <target state="translated">일부 언어의 상수와 달리 명령 행 또는 환경 변수를 통해이를 재정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2e9d61b3ed80ed71e7bbbb9d575bf23b5d77fb98" translate="yes" xml:space="preserve">
          <source>Unlike dbmopen(), the tie() function will not &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; a module for you--you need to do that explicitly yourself.</source>
          <target state="translated">dbmopen ()과 달리 tie () 함수는 모듈을 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 하지 않거나 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 로 하지 않습니다 . 명시 적으로 직접 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="ae7d99bfc8b3205da369ad185c97fc4f2004cc75" translate="yes" xml:space="preserve">
          <source>Unlike dynamic variables created by the &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; operator, lexical variables declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; are totally hidden from the outside world, including any called subroutines. This is true if it's the same subroutine called from itself or elsewhere--every call gets its own copy.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 연산자에 의해 생성 된 동적 변수와 달리 , &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 로 선언 된 어휘 변수는 호출 된 서브 루틴을 포함하여 외부 세계에서 완전히 숨겨져 있습니다. 자체 또는 다른 곳에서 호출 된 동일한 서브 루틴 인 경우에 해당합니다. 모든 호출은 자체 사본을받습니다.</target>
        </trans-unit>
        <trans-unit id="f1d613b9dfee0f458298b76229e47572b9ad09a4" translate="yes" xml:space="preserve">
          <source>Unlike in C and Pascal, in Perl these are all defined in terms of BLOCKs, not statements. This means that the curly brackets are</source>
          <target state="translated">C 및 Pascal과 달리 Perl에서는 명령문이 아니라 BLOCKs로 정의됩니다. 이것은 중괄호가</target>
        </trans-unit>
        <trans-unit id="f21336a91710bef15208089eafb11092016626b2" translate="yes" xml:space="preserve">
          <source>Unlike in C, the scalar assignment operator produces a valid lvalue. Modifying an assignment is equivalent to doing the assignment and then modifying the variable that was assigned to. This is useful for modifying a copy of something, like this:</source>
          <target state="translated">C와 달리 스칼라 대입 연산자는 유효한 lvalue를 생성합니다. 할당을 수정하는 것은 할당을 수행 한 다음 할당 된 변수를 수정하는 것과 같습니다. 이것은 다음과 같이 무언가의 사본을 수정하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5f827eec6110de095ec9210c18c9cbffc634099b" translate="yes" xml:space="preserve">
          <source>Unlike in earlier versions of Perl, &lt;code&gt;:raw&lt;/code&gt; is</source>
          <target state="translated">이전 버전의 Perl과 달리 &lt;code&gt;:raw&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="33bdaa80be75964fba31840d455d3822e7d396b4" translate="yes" xml:space="preserve">
          <source>Unlike just splitting the directories on the separator, empty directory names (&lt;code&gt;&quot;&quot;&lt;/code&gt; ) can be returned. Since &lt;code&gt;catdir()&lt;/code&gt; on Mac OS always appends a trailing colon to distinguish a directory path from a file path, a single trailing colon will be ignored, i.e. there's no empty directory name after it.</source>
          <target state="translated">구분 기호에서 디렉토리를 분할하는 것과 달리 빈 디렉토리 이름 ( &lt;code&gt;&quot;&quot;&lt;/code&gt; )이 리턴 될 수 있습니다. 이후 &lt;code&gt;catdir()&lt;/code&gt; 맥 OS에 항상 파일 경로에서 디렉토리 경로를 구분하기 위해 뒤에 콜론을 추가, 하나의 후행 콜론은 이후 빈 디렉토리 이름이 없다, 즉, 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="54463777f2a5a26bb28578fbecd0a237664559d0" translate="yes" xml:space="preserve">
          <source>Unlike just splitting the directories on the separator, empty directory names (&lt;code&gt;''&lt;/code&gt; ) can be returned, because these are significant on some OSes.</source>
          <target state="translated">구분 기호에서 디렉토리를 분할하는 것과 달리 빈 디렉토리 이름 ( &lt;code&gt;''&lt;/code&gt; )은 일부 OS에서 중요하기 때문에 리턴 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86f74613bf49290364595249fc093a5b0e46c0b1" translate="yes" xml:space="preserve">
          <source>Unlike just splitting the directories on the separator, empty directory names (&lt;code&gt;''&lt;/code&gt; ) can be returned, because these are significant on some OSs.</source>
          <target state="translated">구분 기호에서 디렉토리를 분할하는 것과 달리 빈 디렉토리 이름 ( &lt;code&gt;''&lt;/code&gt; )은 일부 OS에서 중요하기 때문에 리턴 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0601a2027041706b4a215c5ba97b0f2d038f55f" translate="yes" xml:space="preserve">
          <source>Unlike just splitting the directories on the separator, leading empty and trailing directory entries can be returned, because these are significant on some OSs. So,</source>
          <target state="translated">구분 기호에서 디렉토리를 분할하는 것과 달리 선행 OS 및 후행 디렉토리 항목은 일부 OS에서 중요하기 때문에 리턴 될 수 있습니다. 그래서,</target>
        </trans-unit>
        <trans-unit id="7934f43f05e561c630f325debe8a290638569198" translate="yes" xml:space="preserve">
          <source>Unlike local variables in C or C++, Perl's lexical variables don't necessarily get recycled just because their scope has exited. If something more permanent is still aware of the lexical, it will stick around. So long as something else references a lexical, that lexical won't be freed--which is as it should be. You wouldn't want memory being free until you were done using it, or kept around once you were done. Automatic garbage collection takes care of this for you.</source>
          <target state="translated">C 또는 C ++의 로컬 변수와 달리 Perl의 어휘 변수는 해당 범위가 종료되어 반드시 재활용되지는 않습니다. 더 영원한 무언가가 여전히 어휘를 알고 있다면, 그것은 붙어 있습니다. 다른 것이 어휘를 참조하는 한, 어휘는 풀리지 않을 것입니다. 메모리 사용이 끝날 때까지 또는 사용이 끝난 후에는 메모리를 비우기를 원하지 않을 것입니다. 자동 가비지 콜렉션이이를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="61c2bf5d9fb9c4e4b449918bf685b7cd4c575760" translate="yes" xml:space="preserve">
          <source>Unlike many other languages which support object orientation, Perl does not provide any special syntax for constructing an object. Objects are merely Perl data structures (hashes, arrays, scalars, filehandles, etc.) that have been explicitly associated with a particular class.</source>
          <target state="translated">객체 지향을 지원하는 다른 많은 언어와 달리 Perl은 객체 구성을위한 특별한 구문을 제공하지 않습니다. 객체는 단순히 특정 클래스와 명시 적으로 연결된 Perl 데이터 구조 (해시, 배열, 스칼라, 파일 핸들 등)입니다.</target>
        </trans-unit>
        <trans-unit id="96a17407e83fd96732a811a270065f8bf99b9560" translate="yes" xml:space="preserve">
          <source>Unlike most encodings which accept various ways to handle errors, Unicode encodings simply croaks.</source>
          <target state="translated">오류를 처리하는 다양한 방법을 허용하는 대부분의 인코딩과 달리 유니 코드 인코딩은 단순히 삐걱 거립니다.</target>
        </trans-unit>
        <trans-unit id="49b673e0d13d9cc508ff95ef6bf45edac94a0386" translate="yes" xml:space="preserve">
          <source>Unlike most locales, which are specific to a language and country pair, Unicode classifies all the characters that are letters</source>
          <target state="translated">언어 및 국가 쌍에 특정한 대부분의 로캘과 달리 유니 코드는 문자 인 모든 문자를 분류합니다</target>
        </trans-unit>
        <trans-unit id="de28345f4c14a0c66a5513ec93329ba001d9ced5" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;dump&quot;&gt;dump&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">대부분의 명명 된 연산자와 달리 할당과 동일한 우선 순위를 갖습니다. 또한 함수 모양과 같은 규칙에서 제외되므로 &lt;code&gt;&lt;a href=&quot;dump&quot;&gt;dump&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 는 &quot;bar&quot; 가 &lt;code&gt;&lt;a href=&quot;dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt; 인수의 일부가되도록합니다 .</target>
        </trans-unit>
        <trans-unit id="c0d9558dea8e06eb18c291c6122258af13477176" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">대부분의 명명 된 연산자와 달리 할당과 동일한 우선 순위를 갖습니다. 또한 함수 모양과 같은 규칙에서 제외되므로 &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 는 &quot;bar&quot; 가 &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt; 인수의 일부가되도록합니다 .</target>
        </trans-unit>
        <trans-unit id="9b35f8dffb5619dd71375e3734d385be7cc68976" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">대부분의 명명 된 연산자와 달리 할당과 동일한 우선 순위를 갖습니다. 또한 함수 모양과 같은 규칙에서 제외되므로 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 는 &quot;bar&quot; 가 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 인수의 일부가되도록합니다 .</target>
        </trans-unit>
        <trans-unit id="642dec0f5e46307ce9e97ef7e93a9392f0b1f7ab" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">대부분의 명명 된 연산자와 달리 할당과 동일한 우선 순위를 갖습니다. 또한 look-like-a-function 규칙에서 제외되므로 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 는 &quot;bar&quot; 가 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 에 대한 인수의 일부가되도록합니다 .</target>
        </trans-unit>
        <trans-unit id="8e8af66683db3fc2cddaa8cdf32b4f53ebab4445" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">대부분의 명명 된 연산자와 달리 할당과 동일한 우선 순위를 갖습니다. 또한 함수처럼 보이는 규칙에서 제외되므로 &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 는 &quot;bar&quot; 가 &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; 인수의 일부가되도록합니다 .</target>
        </trans-unit>
        <trans-unit id="5bec2254ea41ddda3ef06eefb12b88f8ff1170ba" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">대부분의 명명 된 연산자와 달리 할당과 동일한 우선 순위를 갖습니다. 또한 함수 모양과 같은 규칙에서 제외되므로 &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 는 &quot;bar&quot; 가 &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 인수의 일부가되도록합니다 .</target>
        </trans-unit>
        <trans-unit id="46f28e7c4c55184f01ee0fc59018a927acd8437c" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">대부분의 명명 된 연산자와 달리 할당과 동일한 우선 순위를 갖습니다. 또한 look-like-a-function 규칙에서 제외되므로 &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 는 &quot;bar&quot; 가 &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 에 대한 인수의 일부가되도록합니다 .</target>
        </trans-unit>
        <trans-unit id="fe0bcbfb6300fcbe2507c49b4631d20697de525c" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">대부분의 명명 된 연산자와 달리 할당과 동일한 우선 순위를 갖습니다. 또한 함수처럼 보이는 규칙에서 제외되므로 &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 는 &quot;bar&quot; 가 &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; 인수의 일부가되도록합니다 .</target>
        </trans-unit>
        <trans-unit id="3ee3973cea98d2564d41622c65ad1eadc9b20495" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">대부분의 명명 된 연산자와는 달리, 이는 모양과 유사한 규칙에서 제외되므로 &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 는 &quot;bar&quot; 가 &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 의 인수의 일부가 됩니다.</target>
        </trans-unit>
        <trans-unit id="fd9949db65a27c0400a1254746b3e91b925c452b" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;return&quot;&gt;return&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">대부분의 명명 된 연산자와는 달리, 이는 모양과 유사한 규칙에서 제외되므로 &lt;code&gt;&lt;a href=&quot;return&quot;&gt;return&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; 는 &quot;bar&quot; 가 &lt;code&gt;&lt;a href=&quot;return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 의 인수의 일부가 됩니다.</target>
        </trans-unit>
        <trans-unit id="d21a9fd801c4b5ff299a1a5bef8631136555ebd2" translate="yes" xml:space="preserve">
          <source>Unlike most operators, the smartmatch operator knows to treat &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; specially:</source>
          <target state="translated">대부분의 연산자와 달리 smartmatch 연산자는 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 특별히 처리하는 것을 알고 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c52ae364f54ddc8596b506c3503500a0182fc785" translate="yes" xml:space="preserve">
          <source>Unlike most other encodings, the following always croaks on error for any $chk that evaluates to true.</source>
          <target state="translated">대부분의 다른 인코딩과 달리 다음은 true로 평가되는 $ chk에 대해 항상 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a0be45e558750e70d5ad5d40843ef88fbc85d85e" translate="yes" xml:space="preserve">
          <source>Unlike non-user-defined &lt;code&gt;\p{}&lt;/code&gt; property matches, no warning is ever generated if these properties are matched against a non-Unicode code point (see &lt;a href=&quot;#Beyond-Unicode-code-points&quot;&gt;Beyond Unicode code points&lt;/a&gt; below).</source>
          <target state="translated">사용자가 정의하지 않은 &lt;code&gt;\p{}&lt;/code&gt; 속성 일치 와 달리 이러한 속성이 유니 코드가 아닌 코드 포인트와 일치하는 경우 경고가 생성되지 않습니다 ( 아래의 &lt;a href=&quot;#Beyond-Unicode-code-points&quot;&gt;유니 코드 코드 포인트를 넘어서&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="54d85676113e32968ab38ead192e565266d17ce6" translate="yes" xml:space="preserve">
          <source>Unlike other DJGPP packages, which are normal &quot;zip&quot; files, most CPAN module packages are &quot;gzipped tarballs&quot;. Recent versions of WinZip will safely unpack and expand them, *UNLESS* they have zero-length files. It is a known WinZip bug (as of v7.0) that it will not extract zero-length files.</source>
          <target state="translated">일반 &quot;zip&quot;파일 인 다른 DJGPP 패키지와 달리 대부분의 CPAN 모듈 패키지는 &quot;gzipped tarballs&quot;입니다. 최신 버전의 WinZip은 안전하게 압축을 풀고 확장합니다. * UNLESS *에는 길이가 0 인 파일이 있습니다. 길이가 0 인 파일을 추출하지 않는 것으로 알려진 WinZip 버그 (v7.0 기준)입니다.</target>
        </trans-unit>
        <trans-unit id="83864ffb2b433053a7d93f1893b27cbe33018e20" translate="yes" xml:space="preserve">
          <source>Unlike other encodings where mappings are not one-to-one against Unicode, UTFs are supposed to map 100% against one another. So Encode is more strict on UTFs.</source>
          <target state="translated">유니 코드에 대한 매핑이 일대일이 아닌 다른 인코딩과 달리 UTF는 서로 100 %를 매핑해야합니다. 따라서 인코딩은 UTF에서 더 엄격합니다.</target>
        </trans-unit>
        <trans-unit id="9944da74f109a50432581cc20ef1a61578ffdb1c" translate="yes" xml:space="preserve">
          <source>Unlike other types of quote-like literals, a here document is rarely a contiguous substring. For example, a typical piece of code using here document might look like this:</source>
          <target state="translated">다른 유형의 따옴표와 같은 리터럴과 달리 here 문서는 연속 하위 문자열이 아닙니다. 예를 들어 here 문서를 사용하는 일반적인 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="82bfb2284168959f095690d2be25e5ae6b5a6d2d" translate="yes" xml:space="preserve">
          <source>Unlike pragmas that affect the &lt;code&gt;$^H&lt;/code&gt; hints variable, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; declarations are not BLOCK-scoped. They are thus effective for the entire file in which they appear. You may not rescind such declarations with &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; vars&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; subs&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$^H&lt;/code&gt; 힌트 변수에 영향을주는 pragma와 달리 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; 선언은 BLOCK 범위가 아닙니다. 따라서 표시되는 전체 파일에 효과적입니다. 당신은 선언을 철회하지 않을 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; vars&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; subs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="946dc8e2b9e4dbb1e056eab35da113b4edec1e74" translate="yes" xml:space="preserve">
          <source>Unlike pragmas that affect the &lt;code&gt;$^H&lt;/code&gt; hints variable, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; declarations are not BLOCK-scoped. They are thus effective for the entire package in which they appear. You may not rescind such declarations with &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; vars&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; subs&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$^H&lt;/code&gt; 힌트 변수에 영향을주는 pragma와 달리 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; 선언은 BLOCK 범위가 아닙니다. 따라서 표시되는 전체 패키지에 효과적입니다. 당신은 선언을 철회하지 않을 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; vars&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; subs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a62fc8b32926f79e07e4cd739d192b4db682422d" translate="yes" xml:space="preserve">
          <source>Unlike previous examples, we've now run h2xs on a real include file. This has caused some extra goodies to appear in both the .pm and .xs files.</source>
          <target state="translated">이전 예제와 달리 이제 실제 포함 파일에서 h2x를 실행했습니다. 이로 인해 .pm 및 .xs 파일에 일부 추가 기능이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="82613342b350d8ac2d5e700389b419d73a2e8511" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;Newx&lt;/code&gt; and &lt;code&gt;Newxc&lt;/code&gt; macros, the &lt;code&gt;Newxz&lt;/code&gt; macro calls &lt;code&gt;memzero&lt;/code&gt; to zero out all the newly allocated memory.</source>
          <target state="translated">&lt;code&gt;Newx&lt;/code&gt; 및 &lt;code&gt;Newxc&lt;/code&gt; 매크로 와 달리 &lt;code&gt;Newxz&lt;/code&gt; 매크로는 &lt;code&gt;memzero&lt;/code&gt; 를 호출 하여 새로 할당 된 모든 메모리를 0으로 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="3459d8de61947e832dd8d6cc93a45a157f32fe5d" translate="yes" xml:space="preserve">
          <source>Unlike the GNU programs,</source>
          <target state="translated">GNU 프로그램과 달리</target>
        </trans-unit>
        <trans-unit id="675122bbd6fe9d02ab821cef4f122f1e2fdb7554" translate="yes" xml:space="preserve">
          <source>Unlike the L</source>
          <target state="translated">L과 달리</target>
        </trans-unit>
        <trans-unit id="00946f20f0f39de3fde945a1c4762c9a2eb54a4d" translate="yes" xml:space="preserve">
          <source>Unlike the old Unix fmt(1) utility, this module correctly accounts for any Unicode combining characters (such as diacriticals) that may occur in each line for both expansion and unexpansion. These are overstrike characters that do not increment the logical position. Make sure you have the appropriate Unicode settings enabled.</source>
          <target state="translated">이전 Unix fmt (1) 유틸리티와 달리이 모듈은 확장 및 확장 해제를 위해 각 줄에서 발생할 수있는 모든 유니 코드 결합 문자 (예 : 분음 부호)를 올바르게 설명합니다. 논리적 위치를 증가시키지 않는 초과 스트라이크 문자입니다. 적절한 유니 코드 설정이 활성화되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="0625a7948b2143bf8fa5b94abdec3d975bedca11" translate="yes" xml:space="preserve">
          <source>Unlike the old unix utilities, this module correctly accounts for any Unicode combining characters (such as diacriticals) that may occur in each line for both expansion and unexpansion. These are overstrike characters that do not increment the logical position. Make sure you have the appropriate Unicode settings enabled.</source>
          <target state="translated">이전 유닉스 유틸리티와 달리이 모듈은 확장 및 확장 해제를 위해 각 줄에서 발생할 수있는 모든 유니 코드 결합 문자 (예 : 분음 부호)를 올바르게 설명합니다. 논리적 위치를 증가시키지 않는 초과 스트라이크 문자입니다. 적절한 유니 코드 설정이 활성화되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="bbee11f3129dceedbb755c4927925d533e72e81f" translate="yes" xml:space="preserve">
          <source>Unlike the original coding of this example, the returned values are not accessed in reverse order. So &lt;code&gt;ST(0)&lt;/code&gt; refers to the first value returned by the Perl subroutine and &lt;code&gt;ST(count-1)&lt;/code&gt; refers to the last.</source>
          <target state="translated">이 예제의 원래 코딩과 달리 반환 된 값은 역순으로 액세스되지 않습니다. 따라서 &lt;code&gt;ST(0)&lt;/code&gt; 은 Perl 서브 루틴이 리턴 한 첫 번째 값을 나타내고 &lt;code&gt;ST(count-1)&lt;/code&gt; 은 마지막 값을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="54921bfadbbc4d5488355e38753c36b606db5127" translate="yes" xml:space="preserve">
          <source>Unlike with &lt;a href=&quot;#croak&quot;&gt;croak&lt;/a&gt;, &lt;code&gt;pat&lt;/code&gt; is not permitted to be null.</source>
          <target state="translated">와 달리 &lt;a href=&quot;#croak&quot;&gt;까악 까악 우는 소리&lt;/a&gt; , &lt;code&gt;pat&lt;/code&gt; null이 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8a7070baa0bba9b5c3411b37157873dd12da55ea" translate="yes" xml:space="preserve">
          <source>Unlike with &lt;a href=&quot;#vcroak&quot;&gt;vcroak&lt;/a&gt;, &lt;code&gt;pat&lt;/code&gt; is not permitted to be null.</source>
          <target state="translated">와 달리 &lt;a href=&quot;#vcroak&quot;&gt;vcroak&lt;/a&gt; , &lt;code&gt;pat&lt;/code&gt; null이 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e5cefcdd918640639ca1153770063f61e285104d" translate="yes" xml:space="preserve">
          <source>Unlink any temporary files you create.</source>
          <target state="translated">생성 한 임시 파일을 연결 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="7f2c338fa9bfcccaac25268ab0ef12e64490b19e" translate="yes" xml:space="preserve">
          <source>Unlock and close the database.</source>
          <target state="translated">데이터베이스를 잠금 해제하고 닫으십시오.</target>
        </trans-unit>
        <trans-unit id="3a1b8bde43d6985240bfa75345e6d99d943394fd" translate="yes" xml:space="preserve">
          <source>Unpack the result with</source>
          <target state="translated">로 결과의 압축을 풉니 다</target>
        </trans-unit>
        <trans-unit id="add77c91d022a17024fa5eba373c6e719da883a1" translate="yes" xml:space="preserve">
          <source>Unpack the result with &lt;code&gt;tar -xof yourmodule.tar&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tar -xof yourmodule.tar&lt;/code&gt; 로 결과의 압축을 풉니 다.</target>
        </trans-unit>
        <trans-unit id="ae62392d2b4bc10cbedb53bdaea138dd0c54922e" translate="yes" xml:space="preserve">
          <source>Unpack the source package</source>
          <target state="translated">소스 패키지의 압축을 풉니 다</target>
        </trans-unit>
        <trans-unit id="3ba56861ba0d7e4bf096f38cb19b9bd9d11ad9ab" translate="yes" xml:space="preserve">
          <source>Unpacking CPAN Modules on DOS</source>
          <target state="translated">DOS에서 CPAN 모듈 포장 풀기</target>
        </trans-unit>
        <trans-unit id="a3e58138dfa89b35eb5a0a67e0ceb78fe71fb3cd" translate="yes" xml:space="preserve">
          <source>Unpacking Perl Distribution on BS2000</source>
          <target state="translated">BS2000에서 펄 배포 풀기</target>
        </trans-unit>
        <trans-unit id="1906a11a734d044847362b51bdd5c4ffec722822" translate="yes" xml:space="preserve">
          <source>Unpacking Perl distribution on OS/390</source>
          <target state="translated">OS / 390에서 Perl 분배 풀기</target>
        </trans-unit>
        <trans-unit id="1bfe6e7e13df7f1f795bc2c142ba9f8933ba83d0" translate="yes" xml:space="preserve">
          <source>Unpacking a Stack Frame</source>
          <target state="translated">스택 프레임 포장 풀기</target>
        </trans-unit>
        <trans-unit id="13585670fad4d52485b4ecff204569086b8b8bc7" translate="yes" xml:space="preserve">
          <source>Unpacking this message can be done with the same template:</source>
          <target state="translated">이 메시지의 압축을 풀려면 동일한 템플릿으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65ab97485c132c2a06d23b7d99106c078eeca52f" translate="yes" xml:space="preserve">
          <source>Unpacking using the &lt;code&gt;U&lt;/code&gt; template code also works on UTF-8 encoded byte strings.</source>
          <target state="translated">&lt;code&gt;U&lt;/code&gt; 템플릿 코드를 사용하여 압축을 풀면 UTF-8로 인코딩 된 바이트 문자열에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f5c52c7fb5fb7350d05f5400b468c41971c6a2ea" translate="yes" xml:space="preserve">
          <source>Unsets the IV status of an SV.</source>
          <target state="translated">SV의 IV 상태를 설정 해제합니다.</target>
        </trans-unit>
        <trans-unit id="4b35d98112909417a16d4e204369414a7012a63c" translate="yes" xml:space="preserve">
          <source>Unsets the NV status of an SV.</source>
          <target state="translated">SV의 NV 상태를 설정 해제합니다.</target>
        </trans-unit>
        <trans-unit id="8c346401fde7bad98f35f3a033aefb050144d4e1" translate="yes" xml:space="preserve">
          <source>Unsets the NV/IV status of an SV.</source>
          <target state="translated">SV의 NV / IV 상태를 설정 해제합니다.</target>
        </trans-unit>
        <trans-unit id="b2fe5f61df3d20003f435b822e60a53db4a67fca" translate="yes" xml:space="preserve">
          <source>Unsets the PV status of an SV.</source>
          <target state="translated">SV의 PV 상태를 설정 해제합니다.</target>
        </trans-unit>
        <trans-unit id="2b428943db3814d458253435d21b77a7039ff870" translate="yes" xml:space="preserve">
          <source>Unsets the RV status of an SV.</source>
          <target state="translated">SV의 RV 상태를 설정 해제합니다.</target>
        </trans-unit>
        <trans-unit id="167340ebdf7672f2c96a0ab5594ee87b55416719" translate="yes" xml:space="preserve">
          <source>Unsets the RV status of the SV, and decrements the reference count of whatever was being referenced by the RV. This can almost be thought of as a reversal of &lt;code&gt;newSVrv&lt;/code&gt; . The &lt;code&gt;cflags&lt;/code&gt; argument can contain &lt;code&gt;SV_IMMEDIATE_UNREF&lt;/code&gt; to force the reference count to be decremented (otherwise the decrementing is conditional on the reference count being different from one or the reference being a readonly SV). See &lt;code&gt;SvROK_off&lt;/code&gt; .</source>
          <target state="translated">SV의 RV 상태를 설정 해제하고 RV가 참조하고있는 대상의 참조 횟수를 줄입니다. 이것은 거의 &lt;code&gt;newSVrv&lt;/code&gt; 의 반전으로 생각할 수 있습니다. &lt;code&gt;cflags&lt;/code&gt; 인자가 포함될 수 &lt;code&gt;SV_IMMEDIATE_UNREF&lt;/code&gt; 은 레퍼런스 카운트가 감소되도록 강제 (그렇지 않으면 감소하는 레퍼런스 카운트가 하나 또는 상이한 기준이 판독 전용 인 SV의 조건으로). &lt;code&gt;SvROK_off&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2213e6f5fdeb83ff58d3c894e858b5a7ff9788f0" translate="yes" xml:space="preserve">
          <source>Unsets the RV status of the SV, and decrements the reference count of whatever was being referenced by the RV. This can almost be thought of as a reversal of &lt;code&gt;newSVrv&lt;/code&gt; . This is &lt;code&gt;sv_unref_flags&lt;/code&gt; with the &lt;code&gt;flag&lt;/code&gt; being zero. See &lt;code&gt;SvROK_off&lt;/code&gt; .</source>
          <target state="translated">SV의 RV 상태를 설정 해제하고 RV가 참조하고있는 대상의 참조 횟수를 줄입니다. 이것은 거의 &lt;code&gt;newSVrv&lt;/code&gt; 의 반전으로 생각할 수 있습니다. 이다 &lt;code&gt;sv_unref_flags&lt;/code&gt; 와 &lt;code&gt;flag&lt;/code&gt; 제로가되는. &lt;code&gt;SvROK_off&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fcfacd26d54ec31883bc064dd4f33047f4f7aa58" translate="yes" xml:space="preserve">
          <source>Unsets the UTF-8 status of an SV (the data is not changed, just the flag). Do not use frivolously.</source>
          <target state="translated">SV의 UTF-8 상태를 설정 해제합니다 (데이터는 변경되지 않고 플래그 만). 경박하게 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="d458cc7af0595ce52fa475113c58f925209c55f3" translate="yes" xml:space="preserve">
          <source>Unsets the script encoding. The layers of &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; are reset to &quot;&lt;code&gt;:raw&lt;/code&gt; &quot; (the default unprocessed raw stream of bytes).</source>
          <target state="translated">스크립트 인코딩을 설정 해제합니다. &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; 계층은 &quot; &lt;code&gt;:raw&lt;/code&gt; &quot;(기본 처리되지 않은 원시 바이트 스트림) 로 재설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="f3f886677b52de9f164b2193f280f9e0b4fa4087" translate="yes" xml:space="preserve">
          <source>Unshift the given number of &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; values onto the beginning of the array. The array will grow automatically to accommodate the addition. You must then use &lt;code&gt;av_store&lt;/code&gt; to assign values to these new elements.</source>
          <target state="translated">주어진 수의 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 값을 배열의 시작 부분으로 이동하십시오. 추가를 수용하기 위해 어레이가 자동으로 커집니다. 그런 다음 &lt;code&gt;av_store&lt;/code&gt; 를 사용 하여 이러한 새 요소에 값을 지정 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="56c8806e91e8b07e1c8c5b623b330c5fc17f1e53" translate="yes" xml:space="preserve">
          <source>Unshifts an SV onto the beginning of the array, creating the array if necessary. A small internal helper function to remove a commonly duplicated idiom.</source>
          <target state="translated">SV를 어레이의 시작 부분으로 이동시켜 필요한 경우 어레이를 만듭니다. 자주 복제되는 관용구를 제거하는 작은 내부 도우미 기능입니다.</target>
        </trans-unit>
        <trans-unit id="ee9dd9a34e19860a5fcf0a7ebd745fb02d06f995" translate="yes" xml:space="preserve">
          <source>Unsigned long integers. This is equivalent to T_UV but explicitly casts the return to type &lt;code&gt;unsigned long&lt;/code&gt; . The default typemap for &lt;code&gt;unsigned long&lt;/code&gt; is T_UV.</source>
          <target state="translated">부호없는 긴 정수 이것은 T_UV와 동일하지만 리턴 값을 &lt;code&gt;unsigned long&lt;/code&gt; 유형으로 명시 적으로 캐스트합니다 . &lt;code&gt;unsigned long&lt;/code&gt; 의 기본 유형 맵 은 T_UV입니다.</target>
        </trans-unit>
        <trans-unit id="ef145f774c9c40a970f92057ceb7090d079d49a8" translate="yes" xml:space="preserve">
          <source>Unsigned short integers. This is equivalent to T_UV but explicitly casts the return to type &lt;code&gt;unsigned short&lt;/code&gt; . The default typemap for &lt;code&gt;unsigned short&lt;/code&gt; is T_UV.</source>
          <target state="translated">부호없는 짧은 정수 이것은 T_UV와 동일하지만 리턴 값을 &lt;code&gt;unsigned short&lt;/code&gt; 유형으로 명시 적으로 캐스트합니다 . &lt;code&gt;unsigned short&lt;/code&gt; 의 기본 유형 맵 은 T_UV입니다.</target>
        </trans-unit>
        <trans-unit id="e913109aa138d1120ee92917139364ad0e62c982" translate="yes" xml:space="preserve">
          <source>Unstable CPAN modules</source>
          <target state="translated">불안정한 CPAN 모듈</target>
        </trans-unit>
        <trans-unit id="36af1ae54977c39ffd1ead9641e29d3a83f91f42" translate="yes" xml:space="preserve">
          <source>Untaint an SV. Use &lt;code&gt;SvTAINTED_off&lt;/code&gt; instead.</source>
          <target state="translated">SV를 유지하십시오. 대신 &lt;code&gt;SvTAINTED_off&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bf2cbcc095493f902db2ae40c30ea409c9c066e5" translate="yes" xml:space="preserve">
          <source>Untaints an SV. Be</source>
          <target state="translated">SV를 유지합니다. 있다</target>
        </trans-unit>
        <trans-unit id="dd1c8a6c3311799ae1ea8e9badc636ca33ce5f06" translate="yes" xml:space="preserve">
          <source>Until May 1997, this document was maintained by Jeff Okamoto &amp;lt;okamoto@corp.hp.com&amp;gt;. It is now maintained as part of Perl itself by the Perl 5 Porters &amp;lt;perl5-porters@perl.org&amp;gt;.</source>
          <target state="translated">1997 년 5 월까지이 문서는 Jeff Okamoto &amp;lt;okamoto@corp.hp.com&amp;gt;에서 관리했습니다. 이제 Perl 5 Porters &amp;lt;perl5-porters@perl.org&amp;gt;에 의해 Perl 자체의 일부로 유지 보수됩니다.</target>
        </trans-unit>
        <trans-unit id="1831403e65413acb20ccb5893a29f9432e4a4a0c" translate="yes" xml:space="preserve">
          <source>Until May 1997, this document was maintained by Jeff Okamoto &amp;lt;okamoto@corp.hp.com&amp;gt;. It is now maintained as part of Perl itself.</source>
          <target state="translated">1997 년 5 월까지이 문서는 Jeff Okamoto &amp;lt;okamoto@corp.hp.com&amp;gt;에서 관리했습니다. 이제 Perl 자체의 일부로 유지 보수됩니다.</target>
        </trans-unit>
        <trans-unit id="9377bbae85c5f3f0ba947e70ca82611c37d8697f" translate="yes" xml:space="preserve">
          <source>Until Unicode 6.1, the 4 control characters U+0080, U+0081, U+0084, and U+0099 did not have names nor aliases. To preserve backwards compatibility, any alias you define for these code points will be returned by this function, in preference to the official name.</source>
          <target state="translated">유니 코드 6.1까지 4 개의 제어 문자 U + 0080, U + 0081, U + 0084 및 U + 0099에는 이름이나 별명이 없습니다. 이전 버전과의 호환성을 유지하기 위해이 코드 포인트에 대해 정의한 별칭은 공식 이름보다이 함수에 의해 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1eb5a9bdac4b575070ceef54e56442cbab9b46a4" translate="yes" xml:space="preserve">
          <source>Until Unicode 7.0, the noncharacters were &quot;&lt;b&gt;forbidden&lt;/b&gt; for use in open interchange of Unicode text data&quot;, so that code that processed those streams could use these code points as sentinels that could be mixed in with character data, and would always be distinguishable from that data. (Emphasis above and in the next paragraph are added in this document.)</source>
          <target state="translated">유니 코드 7.0까지, 비문자는 &quot; 유니 코드 텍스트 데이터의 공개 교환에 사용이 &lt;b&gt;금지&lt;/b&gt; 되었습니다&quot;. 따라서 이러한 스트림을 처리 한 코드는이 코드 포인트를 문자 데이터와 혼합 될 수있는 센티넬로 사용할 수 있으며 항상 그 코드와 구별됩니다. 데이터. (이 문서에는 위와 다음 단락의 내용이 추가되어 있습니다.)</target>
        </trans-unit>
        <trans-unit id="39e4b4459c9bb0a70e21b5f9e46e887914c2d11b" translate="yes" xml:space="preserve">
          <source>Until version 1.72 of this module, the recommended technique for locking &lt;b&gt;DB_File&lt;/b&gt; databases was to flock the filehandle returned from the &quot;fd&quot; function. Unfortunately this technique has been shown to be fundamentally flawed (Kudos to David Harris for tracking this down). Use it at your own peril!</source>
          <target state="translated">이 모듈의 버전 1.72까지 &lt;b&gt;DB_File&lt;/b&gt; 데이터베이스 를 잠그는 데 권장되는 기술 은 &quot;fd&quot;함수에서 리턴 된 파일 핸들을 &lt;b&gt;모으는&lt;/b&gt; 것입니다. 불행히도이 기술은 근본적으로 결함이있는 것으로 나타났습니다 (이것을 추적 해 준 David Harris에게 Kudos). 자신의 위험에 따라 사용하십시오!</target>
        </trans-unit>
        <trans-unit id="086839a55d5b993fe1e0e2c06b1920a0c4bb718d" translate="yes" xml:space="preserve">
          <source>Until version 1.88 CPAN.pm never trusted the contents of the build_dir directory between sessions. Since 1.88_58 CPAN.pm has a YAML-based mechanism that makes it possible to share the contents of the build_dir/ directory between different sessions with the same version of perl. People who prefer to test things several days before installing will like this feature because it saves a lot of time.</source>
          <target state="translated">버전 1.88까지 CPAN.pm은 세션 간 build_dir 디렉토리의 내용을 신뢰하지 않았습니다. 1.88_58부터 CPAN.pm에는 YAML 기반 메커니즘이 있으므로 동일한 버전의 perl을 사용하여 다른 세션간에 build_dir / 디렉토리의 내용을 공유 할 수 있습니다. 설치하기 며칠 전에 테스트하는 것을 선호하는 사람들은이 기능을 사용하면 시간을 많이 절약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e8ce03700f57426d42c01b15a7e4b29915f11c3" translate="yes" xml:space="preserve">
          <source>Unused. Left in for compatibility with Perl 5.10.0.</source>
          <target state="translated">미사용. Perl 5.10.0과의 호환성을 위해 남겨졌습니다.</target>
        </trans-unit>
        <trans-unit id="06342bce5c18e1ce2d5790dec4f3e08db46e5f75" translate="yes" xml:space="preserve">
          <source>Unusually, the overloaded implementation of the smart match operator does not get full control of the smart match behaviour. In particular, in the following code:</source>
          <target state="translated">일반적으로 오버로드 된 스마트 일치 연산자 구현은 스마트 일치 동작을 완전히 제어 할 수 없습니다. 특히 다음 코드에서</target>
        </trans-unit>
        <trans-unit id="2e6b69fad267beac964f8da92bb1c2cb8cf51e03" translate="yes" xml:space="preserve">
          <source>Unzipping a complete zip file to disk</source>
          <target state="translated">완전한 zip 파일을 디스크에 압축 해제</target>
        </trans-unit>
        <trans-unit id="3706919ae59d2c2aad143453aa2569b724a8dcba" translate="yes" xml:space="preserve">
          <source>Up to 3.14_05, the switch &lt;b&gt;-v&lt;/b&gt; was used to produce verbose messages of &lt;b&gt;perldoc&lt;/b&gt; operation, which is now enabled by &lt;b&gt;-D&lt;/b&gt;.</source>
          <target state="translated">최대 3.14_05까지 &lt;b&gt;-v&lt;/b&gt; 스위치 는 &lt;b&gt;perldoc&lt;/b&gt; 작업 의 자세한 메시지를 생성하는 데 사용되었으며 이제 &lt;b&gt;-D에&lt;/b&gt; 의해 활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="b37c83dafbe144687e4e64f7705c9303ba945d98" translate="yes" xml:space="preserve">
          <source>Up until Perl 5.18, the actual rules of what a valid identifier was were a bit fuzzy. However, in general, anything defined here should work on previous versions of Perl, while the opposite -- edge cases that work in previous versions, but aren't defined here -- probably won't work on newer versions. As an important side note, please note that the following only applies to bareword identifiers as found in Perl source code, not identifiers introduced through symbolic references, which have much fewer restrictions. If working under the effect of the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8;&lt;/code&gt; pragma, the following rules apply:</source>
          <target state="translated">Perl 5.18까지 유효한 식별자의 실제 규칙은 약간 희미했습니다. 그러나 일반적으로 여기에 정의 된 항목은 이전 버전의 Perl에서 작동해야하지만 반대 버전 (이전 버전에서는 작동하지만 여기서 정의되지 않은 경우)은 최신 버전에서는 작동하지 않을 수 있습니다. 중요한 참고 사항으로 다음은 기호 참조를 통해 도입 된 식별자가 아닌 Perl 소스 코드에있는 베어 워드 식별자에만 적용된다는 점에 유의하십시오. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8;&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 의 영향으로 작업하는 경우 ; pragma에는 다음 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="700db59a01b3167d63908b9389905b718c997451" translate="yes" xml:space="preserve">
          <source>Update the pad compilation state variables on entry to a new block.</source>
          <target state="translated">새 블록에 입력 할 때 패드 컴파일 상태 변수를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="8d41ca4ae9515e795255242cbd01a15b9d2f782f" translate="yes" xml:space="preserve">
          <source>Update the running test count during testing.</source>
          <target state="translated">테스트하는 동안 실행중인 테스트 수를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="ee4df1b22166fed22f195ec39ac5348e1ad4b8f4" translate="yes" xml:space="preserve">
          <source>Updated 12 March 2001 to mention //'SYS1.TCPPARMS(TCPDATA)'.</source>
          <target state="translated">//'SYS1.TCPPARMS(TCPDATA) '를 언급하여 2001 년 3 월 12 일에 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="6a623978ea73cf3eae49fa257cd2b3aa518dc7a5" translate="yes" xml:space="preserve">
          <source>Updated 12 November 2000 for the 5.7.1 release of Perl.</source>
          <target state="translated">Perl 5.7.1 릴리스 용으로 2000 년 11 월 12 일에 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="dd3c1a655a151c3e2de2f2bcc426466b5deb0bf5" translate="yes" xml:space="preserve">
          <source>Updated 15 January 2001 for the 5.7.1 release of Perl.</source>
          <target state="translated">Perl 5.7.1 릴리스 용으로 2001 년 1 월 15 일에 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="5b24aab6b7b4ffb7848dd5c01694221d0200543c" translate="yes" xml:space="preserve">
          <source>Updated 24 January 2001 to mention dynamic loading.</source>
          <target state="translated">동적 로딩을 언급하기 위해 2001 년 1 월 24 일에 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="555d5c68c249342b429101141b4e668ed9316de1" translate="yes" xml:space="preserve">
          <source>Updated 28 November 2001 for broken URLs.</source>
          <target state="translated">깨진 URL에 대해 2001 년 11 월 28 일에 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="e62d7626efdd54a1045fbdd7ab753ad6e883c01e" translate="yes" xml:space="preserve">
          <source>Updated by Kirrily &quot;Skud&quot; Robert, &lt;code&gt;skud@cpan.org&lt;/code&gt;</source>
          <target state="translated">Kirrily &quot;Skud&quot;Robert, &lt;code&gt;skud@cpan.org&lt;/code&gt; 업데이트</target>
        </trans-unit>
        <trans-unit id="8d4259d34b695e49901c9de958534f87265a7f80" translate="yes" xml:space="preserve">
          <source>Updated to be autogenerated from comments in the source by Benjamin Stuhl.</source>
          <target state="translated">Benjamin Stuhl에 의해 소스의 주석에서 자동 생성되도록 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="76fadb0208f83533ce563882faa439aa56b4df27" translate="yes" xml:space="preserve">
          <source>Updates for 5.8.0 by Nicholas Clark &amp;lt;nick@ccl4.org&amp;gt;</source>
          <target state="translated">Nicholas Clark &amp;lt;nick@ccl4.org&amp;gt;의 5.8.0 업데이트</target>
        </trans-unit>
        <trans-unit id="1339cf8af116acbabf9923f4b5f205bd8b4522d5" translate="yes" xml:space="preserve">
          <source>Updates the current digest state by appending bits to it. The return value is the updated object itself.</source>
          <target state="translated">비트를 추가하여 현재 다이제스트 상태를 업데이트합니다. 반환 값은 업데이트 된 객체 자체입니다.</target>
        </trans-unit>
        <trans-unit id="0f2ec1c28ed80b9544a67d730b3a5ce7a7abddfc" translate="yes" xml:space="preserve">
          <source>Updates to dual-life modules should consist of minimal patches to fix crashing bugs or security issues (as above). Any changes made to dual-life modules for which CPAN is canonical should be coordinated with the upstream author.</source>
          <target state="translated">이중 수명 모듈 업데이트는 크래시 버그 또는 보안 문제 (위와 같이)를 수정하기위한 최소 패치로 구성되어야합니다. CPAN이 정식 인 이중 수명 모듈에 대한 모든 변경 사항은 업스트림 작성자와 조정해야합니다.</target>
        </trans-unit>
        <trans-unit id="6308607dfbe53993e815ce31d09f4ea8e48145b7" translate="yes" xml:space="preserve">
          <source>Updating Apple's Perl</source>
          <target state="translated">Apple Perl 업데이트</target>
        </trans-unit>
        <trans-unit id="e1215f678a578a0f9348858eb8435faef2c2b2a9" translate="yes" xml:space="preserve">
          <source>Updating perldelta</source>
          <target state="translated">펄 델타 업데이트</target>
        </trans-unit>
        <trans-unit id="2c9b320c5f351db0fa6eccf0f443242caa105988" translate="yes" xml:space="preserve">
          <source>Upgrade an SV to a more complex form. Generally adds a new body type to the SV, then copies across as much information as possible from the old body. It croaks if the SV is already in a more complex form than requested. You generally want to use the &lt;code&gt;SvUPGRADE&lt;/code&gt; macro wrapper, which checks the type before calling &lt;code&gt;sv_upgrade&lt;/code&gt; , and hence does not croak. See also &lt;code&gt;svtype&lt;/code&gt; .</source>
          <target state="translated">SV를 좀 더 복잡한 형태로 업그레이드하십시오. 일반적으로 SV에 새 바디 유형을 추가 한 다음 이전 바디에서 최대한 많은 정보를 복사합니다. SV가 이미 요청 된 것보다 더 복잡한 형태 인 경우 멈 춥니 다. 일반적으로 &lt;code&gt;SvUPGRADE&lt;/code&gt; 를 호출하기 전에 유형을 확인 하는 SvUPGRADE 매크로 랩퍼 를 사용하려고 하므로 &lt;code&gt;sv_upgrade&lt;/code&gt; 되지 않습니다. &lt;code&gt;svtype&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bf9f028e2ed4c8dda78241c1ef169c062efd613f" translate="yes" xml:space="preserve">
          <source>Upgrade existing plain connection to SSL. Any arguments necessary for SSL must be given in &lt;code&gt;new&lt;/code&gt; already.</source>
          <target state="translated">기존 일반 연결을 SSL로 업그레이드하십시오. SSL에 필요한 모든 인수는 이미 &lt;code&gt;new&lt;/code&gt; 로 제공되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="2e297ad00204348f72b48d82b1764d98805e45e0" translate="yes" xml:space="preserve">
          <source>Upgrade existing plain connection to SSL. The SSL arguments have to be given in &lt;code&gt;new&lt;/code&gt; already because they are needed for data connections too.</source>
          <target state="translated">기존 일반 연결을 SSL로 업그레이드하십시오. SSL 인수는 데이터 연결에도 필요하므로 이미 &lt;code&gt;new&lt;/code&gt; 인수해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1fee598dc67371af303baa6134f7476c80299023" translate="yes" xml:space="preserve">
          <source>Upgrade existing plain connection to SSL. You can use SSL arguments as documented in &lt;a href=&quot;http://search.cpan.org/perldoc/IO::Socket::SSL&quot;&gt;IO::Socket::SSL&lt;/a&gt;, but it will usually use the right arguments already.</source>
          <target state="translated">기존 일반 연결을 SSL로 업그레이드하십시오. &lt;a href=&quot;http://search.cpan.org/perldoc/IO::Socket::SSL&quot;&gt;IO :: Socket :: SSL에&lt;/a&gt; 설명 된대로 SSL 인수를 사용할 수 있지만 일반적으로 올바른 인수를 이미 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bd48bfd47491f661502b2059f5ddd29245e2ae65" translate="yes" xml:space="preserve">
          <source>Upgrade the input stream to handle UTF8.</source>
          <target state="translated">UTF8을 처리하도록 입력 스트림을 업그레이드하십시오.</target>
        </trans-unit>
        <trans-unit id="abc1ecb08d6b6e94555b0616aae01977c29165a2" translate="yes" xml:space="preserve">
          <source>Upon a successful match, if &lt;code&gt;pe1&lt;/code&gt; is non-NULL, it will be set to point to the beginning of the</source>
          <target state="translated">성공적으로 일치하면 &lt;code&gt;pe1&lt;/code&gt; 이 NULL이 아닌 경우 시작 부분을 가리 키도록 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="7931625de6bea30c3520a42f1b48c8c7ccb1cf73" translate="yes" xml:space="preserve">
          <source>Upon the call, the &lt;code&gt;mg_obj&lt;/code&gt; field will hold the hash key to be accessed. Upon return, the &lt;code&gt;SV*&lt;/code&gt; value in &lt;code&gt;mg_obj&lt;/code&gt; will be used in place of the original key in the hash access. The integer index value in the first parameter will be the &lt;code&gt;action&lt;/code&gt; value from &lt;code&gt;hv_fetch_common&lt;/code&gt; , or -1 if the call is from &lt;code&gt;hv_delete_common&lt;/code&gt; .</source>
          <target state="translated">호출시 &lt;code&gt;mg_obj&lt;/code&gt; 필드는 액세스 할 해시 키를 보유합니다. 돌아 왔을 때, &lt;code&gt;mg_obj&lt;/code&gt; 의 &lt;code&gt;SV*&lt;/code&gt; 값 은 해시 액세스의 원래 키 대신 사용됩니다. 첫 번째 매개 변수의 정수 색인 값 은 &lt;code&gt;hv_fetch_common&lt;/code&gt; 의 &lt;code&gt;action&lt;/code&gt; 값 이거나 호출이 &lt;code&gt;hv_delete_common&lt;/code&gt; 의 경우 -1 입니다.</target>
        </trans-unit>
        <trans-unit id="fa70849156e04d235d49fdb3686f0245d179ad8d" translate="yes" xml:space="preserve">
          <source>Upon tying a new hash to this package, the developer must specify the size of the keys that will be used, the size of the value fields that the keys will index, and the size of the overall table (in terms of key-value pairs, not size in hard memory).</source>
          <target state="translated">이 패키지에 새 해시를 연결할 때 개발자는 사용할 키의 크기, 키가 색인 할 값 필드의 크기 및 전체 테이블의 크기 (키-값 쌍으로)를 지정해야합니다. 하드 메모리의 크기가 아님).</target>
        </trans-unit>
        <trans-unit id="187b6d106a78abc992df989626da341b4759f5bf" translate="yes" xml:space="preserve">
          <source>Upper/lower case differences in property names and values are irrelevant; thus &lt;code&gt;\p{Upper}&lt;/code&gt; means the same thing as &lt;code&gt;\p{upper}&lt;/code&gt; or even &lt;code&gt;\p{UpPeR}&lt;/code&gt; . Similarly, you can add or subtract underscores anywhere in the middle of a word, so that these are also equivalent to &lt;code&gt;\p{U_p_p_e_r}&lt;/code&gt; . And white space is irrelevant adjacent to non-word characters, such as the braces and the equals or colon separators, so &lt;code&gt;\p{ Upper }&lt;/code&gt; and &lt;code&gt;\p{ Upper_case : Y }&lt;/code&gt; are equivalent to these as well. In fact, white space and even hyphens can usually be added or deleted anywhere. So even &lt;code&gt;\p{ Up-per case = Yes}&lt;/code&gt; is equivalent. All this is called &quot;loose-matching&quot; by Unicode. The few places where stricter matching is used is in the middle of numbers, and in the Perl extension properties that begin or end with an underscore. Stricter matching cares about white space (except adjacent to non-word characters), hyphens, and non-interior underscores.</source>
          <target state="translated">속성 이름과 값의 대 / 소문자는 관련이 없습니다. 따라서 &lt;code&gt;\p{Upper}&lt;/code&gt; 는 &lt;code&gt;\p{upper}&lt;/code&gt; 또는 &lt;code&gt;\p{UpPeR}&lt;/code&gt; 과 동일한 것을 의미합니다 . 마찬가지로 단어 중간에 밑줄을 추가하거나 빼서 &lt;code&gt;\p{U_p_p_e_r}&lt;/code&gt; 와 동일합니다 . 그리고 공백은 중괄호, 등호 또는 콜론 구분 기호와 같이 단어가 아닌 문자에 인접하지 않으므로 &lt;code&gt;\p{ Upper }&lt;/code&gt; 및 &lt;code&gt;\p{ Upper_case : Y }&lt;/code&gt; 도 이것과 같습니다. 실제로 공백과 하이픈도 일반적으로 어디에서나 추가하거나 삭제할 수 있습니다. 따라서 &lt;code&gt;\p{ Up-per case = Yes}&lt;/code&gt; 동일합니다. 이 모든 것을 유니 코드에 의해 &quot;느슨한 매칭&quot;이라고합니다. 보다 엄격한 일치가 사용되는 소수의 위치는 숫자의 중간과 밑줄로 시작하거나 끝나는 Perl 확장 등록 정보에 있습니다. 보다 엄격하게 일치하면 공백 (단어가 아닌 문자에 인접한 경우 제외), 하이픈 및 비 내부 밑줄이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="46cec56f3412b99de640a0bca5cebcfbc4f533b0" translate="yes" xml:space="preserve">
          <source>Urgh. No wonder. There's a big difference between &quot;a null byte&quot;, character zero, and &quot;a space&quot;, character 32. Perl's put something between the date and the description - but unfortunately, we can't see it!</source>
          <target state="translated">어. 당연하지 &quot;null byte&quot;, 문자 zero, &quot;space&quot;, 문자 32 사이에는 큰 차이가 있습니다. Perl은 날짜와 설명 사이에 무언가를 넣었습니다. 그러나 불행히도, 우리는 그것을 볼 수 없습니다!</target>
        </trans-unit>
        <trans-unit id="da969c82ff05cdc8d49e5dc3d47bc17f0b801a39" translate="yes" xml:space="preserve">
          <source>Urgh. Well, it's a bit better, but - well, would you want to maintain that?</source>
          <target state="translated">어. 글쎄, 그것은 조금 나아지지만-글쎄, 그것을 유지하고 싶습니까?</target>
        </trans-unit>
        <trans-unit id="82706ecdf8b404a3d7af76c38e97c34669646ccc" translate="yes" xml:space="preserve">
          <source>Usage Hints for Perl on OS/390</source>
          <target state="translated">OS / 390에서 Perl에 대한 사용법 힌트</target>
        </trans-unit>
        <trans-unit id="96115201cdc9d452c0fc7c1a0ccadddf5148529a" translate="yes" xml:space="preserve">
          <source>Usage Hints for Perl on Windows</source>
          <target state="translated">Windows에서 Perl에 대한 사용법 힌트</target>
        </trans-unit>
        <trans-unit id="73e902d9c6da4a824d1ebe10f64b85e576698ee7" translate="yes" xml:space="preserve">
          <source>Usage is</source>
          <target state="translated">사용법</target>
        </trans-unit>
        <trans-unit id="b4adcf0ec968acb4f04ec349a0b19258b19ca830" translate="yes" xml:space="preserve">
          <source>Usage messages issued as a result of bad command-line syntax should go to &lt;code&gt;STDERR&lt;/code&gt; . However, usage messages issued due to an explicit request to print usage (like specifying &lt;b&gt;-help&lt;/b&gt; on the command line) should go to &lt;code&gt;STDOUT&lt;/code&gt; , just in case the user wants to pipe the output to a pager (such as &lt;b&gt;more(1)&lt;/b&gt;).</source>
          <target state="translated">잘못된 명령 행 구문의 결과로 발행 된 사용 메시지는 &lt;code&gt;STDERR&lt;/code&gt; 로 이동해야합니다 . 그러나 명시적인 인쇄 사용 요청 (예 : 명령 행에 &lt;b&gt;-help&lt;/b&gt; 지정)으로 인해 사용 된 사용 메시지 는 사용자가 출력을 페이저 (예 : &lt;b&gt;more (1)&lt;/b&gt; ) 로 파이프하려는 경우 를 위해 &lt;code&gt;STDOUT&lt;/code&gt; 으로 이동해야합니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
