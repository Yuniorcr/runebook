<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="a60da6ae1477278e788b56dd12901cf6a9b5b818" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; to the value returned by &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; if you want random integers instead of random fractional numbers. For example,</source>
          <target state="translated">임의의 소수 대신 임의의 정수를 원할 경우 &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; 가 리턴 한 값에 &lt;code&gt;&lt;a href=&quot;int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; 를 적용하십시오 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="974cf6b03d0010e4742b565eeb776443fe41243e" translate="yes" xml:space="preserve">
          <source>Apply Perl-specific heuristics to find the correct PODs. This includes stripping Perl-like extensions, omitting subdirectories that are numeric but do</source>
          <target state="translated">올바른 POD를 찾으려면 Perl 특정 휴리스틱을 적용하십시오. 여기에는 Perl과 유사한 확장을 제거하고 숫자는 있지만 하위 디렉토리는 생략합니다.</target>
        </trans-unit>
        <trans-unit id="baaa234761c2eef7e15c7c661df9bd832e32f420" translate="yes" xml:space="preserve">
          <source>Apply a list of switch options to the state, updating the internal object state as a result. Nothing is returned.</source>
          <target state="translated">스위치 옵션 목록을 상태에 적용하여 결과적으로 내부 개체 상태를 업데이트합니다. 아무것도 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c72c1cee8e4b08228a22dc9c5e025abf27a61b14" translate="yes" xml:space="preserve">
          <source>Applying &lt;code&gt;autodie&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; causes the exotic forms &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; { $cmd } @args &lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; { $cmd } @args&lt;/code&gt; to be considered a syntax error until the end of the lexical scope. If you really need to use the exotic form, you can call &lt;code&gt;CORE::system&lt;/code&gt; or &lt;code&gt;CORE::exec&lt;/code&gt; instead, or use &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie qw(system exec)&lt;/code&gt; before calling the exotic form.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;autodie&lt;/code&gt; 를 적용하면 이국적인 양식 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; { $cmd } @args &lt;/code&gt; {$ cmd} @args 또는 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; { $cmd } @args&lt;/code&gt; {$ cmd} @args 가 어휘 범위가 끝날 때까지 구문 오류로 간주됩니다. 이국적인 양식을 사용해야하는 경우 &lt;code&gt;CORE::system&lt;/code&gt; 또는 &lt;code&gt;CORE::exec&lt;/code&gt; 대신 호출하거나 이국적인 양식을 호출하기 전에 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie qw(system exec)&lt;/code&gt; 를 사용 &lt;a href=&quot;functions/no&quot;&gt;하지&lt;/a&gt; 마십시오 .</target>
        </trans-unit>
        <trans-unit id="7b6bbaf0846e0f6542bb5b50d36df38212d67922" translate="yes" xml:space="preserve">
          <source>Approximate Perl equivalent: &lt;code&gt;$myarray[$key] = $val;&lt;/code&gt; .</source>
          <target state="translated">대략적인 Perl 동등 : &lt;code&gt;$myarray[$key] = $val;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="255706027acb3bbb6c23a2beab5baa7da2561792" translate="yes" xml:space="preserve">
          <source>Approximate Perl equivalent: &lt;code&gt;&amp;amp;{&quot;$sub_name&quot;}(@$argv)&lt;/code&gt; .</source>
          <target state="translated">대략적인 Perl 동등 : &lt;code&gt;&amp;amp;{&quot;$sub_name&quot;}(@$argv)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b7d5efdfeaa09de6b4d853375871c9207032b5a" translate="yes" xml:space="preserve">
          <source>April 04-07th, 1997: by Jarkko Hietaniemi, added the run-for-some-time functionality.</source>
          <target state="translated">1997 년 4 월 4 일 -07 일 : Jarkko Hietaniemi가 때때로 실행 기능을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="5383ba59b7a51b492dcc518df7e4190d4cdf46a1" translate="yes" xml:space="preserve">
          <source>Arbitrary big rational numbers</source>
          <target state="translated">임의의 큰 유리수</target>
        </trans-unit>
        <trans-unit id="d355876ea51e167fe43014294b56e66adbafd342" translate="yes" xml:space="preserve">
          <source>Arbitrary size floating point math package</source>
          <target state="translated">임의의 크기 부동 소수점 수학 패키지</target>
        </trans-unit>
        <trans-unit id="94977ff2a6f2fcf0486458c46c172275ed7d1a6e" translate="yes" xml:space="preserve">
          <source>Arbitrary size integer/float math package</source>
          <target state="translated">임의 크기의 정수 / 부동 수학 패키지</target>
        </trans-unit>
        <trans-unit id="f96ddf323d8050458b6f5da00e7d15254e6e51f7" translate="yes" xml:space="preserve">
          <source>Arch</source>
          <target state="translated">Arch</target>
        </trans-unit>
        <trans-unit id="ba6c5bbd1305838d356b1a16f613e5175253fc77" translate="yes" xml:space="preserve">
          <source>Archive::Tar</source>
          <target state="translated">Archive::Tar</target>
        </trans-unit>
        <trans-unit id="57cc32f42ad2d2bee580d99c3d374961c6559947" translate="yes" xml:space="preserve">
          <source>Archive::Tar - module for manipulations of tar archives</source>
          <target state="translated">Archive :: Tar-tar 아카이브 조작을위한 모듈</target>
        </trans-unit>
        <trans-unit id="987b760cdf9eb8e8f22f82c621b2dbe3ee552aeb" translate="yes" xml:space="preserve">
          <source>Archive::Tar provides an object oriented mechanism for handling tar files. It provides class methods for quick and easy files handling while also allowing for the creation of tar file objects for custom manipulation. If you have the IO::Zlib module installed, Archive::Tar will also support compressed or gzipped tar files.</source>
          <target state="translated">Archive :: Tar은 tar 파일을 처리하기위한 객체 지향 메커니즘을 제공합니다. 빠르고 쉬운 파일 처리를위한 클래스 메소드를 제공하는 동시에 사용자 정의 조작을 위해 tar 파일 오브젝트를 작성할 수 있습니다. IO :: Zlib 모듈을 설치 한 경우 Archive :: Tar는 압축 또는 zip 압축 tar 파일도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="7c0d8b6a96eeaeee2b14e15f99110273c20f8435" translate="yes" xml:space="preserve">
          <source>Archive::Tar will warn if you try to pass a bzip2 compressed file and the IO::Zlib / IO::Uncompress::Bunzip2 modules are not available and simply return.</source>
          <target state="translated">bzip2 압축 파일을 전달하려고하면 IO :: Zlib / IO :: Uncompress :: Bunzip2 모듈을 사용할 수없고 단순히 반환하면 Archive :: Tar가 경고합니다.</target>
        </trans-unit>
        <trans-unit id="ccbf19882dacfbec62ca802f4c207f93b26aac20" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;can_handle_compressed_files</source>
          <target state="translated">Archive::Tar-&amp;gt;can_handle_compressed_files</target>
        </trans-unit>
        <trans-unit id="3b7da738f6421ea5f244ab2a75337cb19a765083" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;create_archive($file, $compressed, @filelist)</source>
          <target state="translated">Archive :: Tar-&amp;gt; create_archive ($ file, $ compressed, @filelist)</target>
        </trans-unit>
        <trans-unit id="1dcbd289acf336b4bc9986937face374b8265d16" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;extract_archive($file, $compressed)</source>
          <target state="translated">아카이브 :: Tar-&amp;gt; extract_archive ($ file, $ compressed)</target>
        </trans-unit>
        <trans-unit id="8336b53d325ea70cb860e4292e999b5eb8ccc20b" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;iter( $filename, [ $compressed, {opt =&amp;gt; $val} ] )</source>
          <target state="translated">Archive :: Tar-&amp;gt; iter ($ filename, [$ compressed, {opt =&amp;gt; $ val}])</target>
        </trans-unit>
        <trans-unit id="7b5db2965e54185ceb8a82cfef6b3bcf83d67256" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;list_archive($file, $compressed, [\@properties])</source>
          <target state="translated">Archive :: Tar-&amp;gt; list_archive ($ file, $ compressed, [\ @properties])</target>
        </trans-unit>
        <trans-unit id="2b89433003c5207f03c7ec11ee01b11e8497bdb8" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;new( [$file, $compressed] )</source>
          <target state="translated">Archive :: Tar-&amp;gt; new ([$ file, $ compressed])</target>
        </trans-unit>
        <trans-unit id="3fdd79ccbef7cb27b73af9645a51c4748537632a" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File</source>
          <target state="translated">Archive::Tar::File</target>
        </trans-unit>
        <trans-unit id="e4450126317363219e2891fd96c92d67bb8fdb14" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File - a subclass for in-memory extracted file from Archive::Tar</source>
          <target state="translated">Archive :: Tar :: File-Archive :: Tar에서 메모리 내 추출 파일의 서브 클래스</target>
        </trans-unit>
        <trans-unit id="9bb643189669555fb8fc9a5ad660a12af02d7c6a" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File-&amp;gt;new( chunk =&amp;gt; $chunk )</source>
          <target state="translated">Archive :: Tar :: File-&amp;gt; new (청크 =&amp;gt; $ chunk)</target>
        </trans-unit>
        <trans-unit id="ba9618dfc7889be15218e3ccacc09c8bf242756f" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File-&amp;gt;new( data =&amp;gt; $path, $data, $opt )</source>
          <target state="translated">아카이브 :: Tar :: File-&amp;gt; new (data =&amp;gt; $ path, $ data, $ opt)</target>
        </trans-unit>
        <trans-unit id="a50e4ac8ad32b339e1eb6dee5ec96a58d21300c3" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File-&amp;gt;new( file =&amp;gt; $path )</source>
          <target state="translated">Archive :: Tar :: File-&amp;gt; new (파일 =&amp;gt; $ path)</target>
        </trans-unit>
        <trans-unit id="752ab891c175e9890243ad0568d1b63da7b75555" translate="yes" xml:space="preserve">
          <source>Archive::Tar::Files provides a neat little object layer for in-memory extracted files. It's mostly used internally in Archive::Tar to tidy up the code, but there's no reason users shouldn't use this API as well.</source>
          <target state="translated">Archive :: Tar :: Files는 메모리 내 추출 파일에 대한 깔끔한 작은 객체 계층을 제공합니다. 코드를 정리하기 위해 주로 Archive :: Tar에서 내부적으로 사용되지만 사용자가이 API를 사용하지 않아야하는 이유는 없습니다.</target>
        </trans-unit>
        <trans-unit id="2fa2e509f071fa28e01ed08cd42d1e6a982c1c93" translate="yes" xml:space="preserve">
          <source>Archiving and Compression</source>
          <target state="translated">보관 및 압축</target>
        </trans-unit>
        <trans-unit id="470ed7908583fc807812b6f6f1c733d168001e41" translate="yes" xml:space="preserve">
          <source>Are Perl regexes DFAs or NFAs? Are they POSIX compliant?</source>
          <target state="translated">Perl은 DFA 또는 NFA입니까? POSIX를 준수합니까?</target>
        </trans-unit>
        <trans-unit id="eb00fa046e6f0e29e318d2fe47833f95b6115931" translate="yes" xml:space="preserve">
          <source>Are These Threads The Same?</source>
          <target state="translated">이 스레드는 동일합니까?</target>
        </trans-unit>
        <trans-unit id="4b1b74d280a485e3d6be58ac5945ac8cbddc5958" translate="yes" xml:space="preserve">
          <source>Are not yet implemented.</source>
          <target state="translated">아직 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="1c7b6fd019a3db8f66c106580e36cbc2e27fdf91" translate="yes" xml:space="preserve">
          <source>Are you running Windows, and did you write</source>
          <target state="translated">Windows를 실행 중이고 작성 했습니까?</target>
        </trans-unit>
        <trans-unit id="9835fff08898bf6d47cdf47b75c3d5a32e54abb7" translate="yes" xml:space="preserve">
          <source>Are you using a really old version of Perl?</source>
          <target state="translated">정말 오래된 버전의 Perl을 사용하고 있습니까?</target>
        </trans-unit>
        <trans-unit id="6fa0e4cab9d0443ef8c9e6c56e4240cbc1230cdb" translate="yes" xml:space="preserve">
          <source>Arguably, these are the only routines you'll ever need to execute snippets of Perl code from within your C program. Your code can be as long as you wish; it can contain multiple statements; it can employ &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;, &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;, and &lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; to include external Perl files.</source>
          <target state="translated">아마도 이것들은 C 프로그램 내에서 Perl 코드 스 니펫을 실행하는 데 필요한 유일한 루틴 일 것입니다. 코드는 원하는 길이만큼 길 수 있습니다. 여러 문장을 포함 할 수 있습니다. 그것은 채택 할 수 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; , &lt;a href=&quot;functions/require&quot;&gt;필요&lt;/a&gt; , 그리고 &lt;a href=&quot;functions/do&quot;&gt;어떻게&lt;/a&gt; 외부 펄 파일을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="068c4f93ca844add9151394d87be6f0eff5098cb" translate="yes" xml:space="preserve">
          <source>Argument callback</source>
          <target state="translated">인수 콜백</target>
        </trans-unit>
        <trans-unit id="becc16f3f9567f706b791b0867003075aa38f700" translate="yes" xml:space="preserve">
          <source>Argument stack</source>
          <target state="translated">인수 스택</target>
        </trans-unit>
        <trans-unit id="9acc1ee24f849a6b6943c3856e23bafeb8ea115e" translate="yes" xml:space="preserve">
          <source>Argument stack manipulation in the core is exactly the same as it is in XSUBs - see &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt;, &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; and &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; for a longer description of the macros used in stack manipulation.</source>
          <target state="translated">코어의 인수 스택 조작은 XSUB 와 &lt;a href=&quot;perlguts&quot;&gt;동일&lt;/a&gt; 합니다. 스택 조작에 사용되는 매크로에 대한 자세한 설명 은 &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; , &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; 및 perlguts 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1e682d21a155016274d4c0edada169602cf2db63" translate="yes" xml:space="preserve">
          <source>Arguments are case insensitive.</source>
          <target state="translated">인수는 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f350823ca978137e84ceb658074c062e77adbc5a" translate="yes" xml:space="preserve">
          <source>Arguments are forced into the integer format if not strings.</source>
          <target state="translated">문자열이 아닌 경우 인수는 정수 형식으로 강제 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="e574a112087c49e835619f8e2053ef81199f3165" translate="yes" xml:space="preserve">
          <source>Arguments are passed to PP code and returned from PP code using the argument stack, &lt;code&gt;ST&lt;/code&gt; . The typical way to handle arguments is to pop them off the stack, deal with them how you wish, and then push the result back onto the stack. This is how, for instance, the cosine operator works:</source>
          <target state="translated">인수는 PP 코드로 전달되고 인수 스택 &lt;code&gt;ST&lt;/code&gt; 를 사용하여 PP 코드에서 반환됩니다 . 인수를 처리하는 일반적인 방법은 스택에서 인수를 꺼내어 원하는 방식으로 처리 한 다음 결과를 스택으로 다시 푸시하는 것입니다. 예를 들어 코사인 연산자의 작동 방식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5fccb02bffe9af13a6b48fc881c2035657ec7bff" translate="yes" xml:space="preserve">
          <source>Arguments are usually formatted to be only as wide as required to display the given value. You can override the width by putting a number here, or get the width from the next argument (with &lt;code&gt;*&lt;/code&gt; ) or from a specified argument (e.g., with &lt;code&gt;*2$&lt;/code&gt;):</source>
          <target state="translated">인수는 일반적으로 주어진 값을 표시하는 데 필요한만큼만 넓게 형식화됩니다. 여기에 숫자를 넣어 너비를 재정의하거나 다음 인수 ( &lt;code&gt;*&lt;/code&gt; 사용 ) 또는 지정된 인수 (예 : &lt;code&gt;*2$&lt;/code&gt; ) 에서 너비를 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4fb3861e253aa9c040fd66d90deafd1a6d71292f" translate="yes" xml:space="preserve">
          <source>Arguments of the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; directive are (key, value) pairs. For the full set of legal keys, see &lt;a href=&quot;#Overloadable-Operations&quot;&gt;Overloadable Operations&lt;/a&gt; below.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; 지시문의 인수 는 (키, 값) 쌍입니다. 법적 키의 전체 세트는 아래의 &lt;a href=&quot;#Overloadable-Operations&quot;&gt;오버로드 가능한 조작을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5141dae339b17f35a7a4380f8f719ce252ef43f8" translate="yes" xml:space="preserve">
          <source>Arguments that don't start with a hyphen are taken to be the names of subroutines or formats to render; if no such functions are specified, the main body of the program (outside any subroutines, and not including use'd or require'd files) is rendered. Passing &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;UNITCHECK&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; , or &lt;code&gt;END&lt;/code&gt; will cause all of the corresponding special blocks to be printed. Arguments must follow options.</source>
          <target state="translated">하이픈으로 시작하지 않는 인수는 렌더링 할 서브 루틴 또는 형식의 이름으로 간주됩니다. 이러한 기능을 지정하지 않으면 프로그램의 본체 (서브 루틴 이외의 파일, 사용 또는 필요 파일 제외)가 렌더링됩니다. 전달 &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;UNITCHECK&lt;/code&gt; 는 , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; , 또는 &lt;code&gt;END&lt;/code&gt; 는 해당 특수 블록의 모든 인쇄하게됩니다. 인수는 옵션을 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="ce73d1bc99ee20ea72fd21908b3617e55e0813cc" translate="yes" xml:space="preserve">
          <source>Arguments to &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; are &lt;b&gt;not&lt;/b&gt; checked for taintedness.</source>
          <target state="translated">인수하는 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; 되어 &lt;b&gt;있지&lt;/b&gt; taintedness 검사.</target>
        </trans-unit>
        <trans-unit id="5b24aafc030974a768212046c7dad5ef0c74d247" translate="yes" xml:space="preserve">
          <source>Arguments to Tests</source>
          <target state="translated">테스트에 대한 인수</target>
        </trans-unit>
        <trans-unit id="253657f116857073367b6474bc4203deb4236cb2" translate="yes" xml:space="preserve">
          <source>Arguments to be added to the command line</source>
          <target state="translated">명령 행에 추가 할 인수</target>
        </trans-unit>
        <trans-unit id="ef74aa3554ce37f3e92c7ca867fc499504f0b195" translate="yes" xml:space="preserve">
          <source>Arguments to these commands are either strings exactly matching the identification string of an object, or regular expressions matched case-insensitively against various attributes of the objects. The parser only recognizes a regular expression when you enclose it with slashes.</source>
          <target state="translated">이 명령에 대한 인수는 객체의 식별 문자열과 정확히 일치하는 문자열이거나 객체의 다양한 속성에 대해 대소 문자를 구분하지 않는 정규식입니다. 파서는 정규식을 슬래시로 묶을 때만 인식합니다.</target>
        </trans-unit>
        <trans-unit id="a0478ca5f4c068ca3ac12f9474f6a15865ce9053" translate="yes" xml:space="preserve">
          <source>Arguments:</source>
          <target state="translated">Arguments:</target>
        </trans-unit>
        <trans-unit id="2007b9d426cd74d2705e9cb985a4b287291d5413" translate="yes" xml:space="preserve">
          <source>Arguments: COUNT is the number of times to run the loop, and CODE is the code to run. CODE may be either a code reference or a string to be eval'd; either way it will be run in the caller's package.</source>
          <target state="translated">인수 : COUNT는 루프를 실행하는 횟수이고 CODE는 실행할 코드입니다. CODE는 코드 참조이거나 평가할 문자열 일 수 있습니다. 어느 쪽이든 호출자의 패키지에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="504073c25d9741031e514c8e9e91bef33965e548" translate="yes" xml:space="preserve">
          <source>Arguments: TIME is the minimum length of time to run CODE for, and CODE is the code to run. CODE may be either a code reference or a string to be eval'd; either way it will be run in the caller's package.</source>
          <target state="translated">인수 : TIME은 CODE를 실행하는 최소 시간 길이이며 CODE는 실행할 코드입니다. CODE는 코드 참조이거나 평가할 문자열 일 수 있습니다. 어느 쪽이든 호출자의 패키지에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="2dd1feda95af0eae16b44852b3e991a7320b9877" translate="yes" xml:space="preserve">
          <source>Arnold, Ken and James Gosling. The Java Programming Language, 2nd ed. Addison-Wesley, 1998, ISBN 0-201-31006-6.</source>
          <target state="translated">아놀드, 켄, 제임스 고슬링 자바 프로그래밍 언어, 제 2 판. 애디슨-웨슬리, 1998, ISBN 0-201-31006-6.</target>
        </trans-unit>
        <trans-unit id="41b85d47773b3148f4f3a1e9d404f9d2d3175fa5" translate="yes" xml:space="preserve">
          <source>Arranges for FILEHANDLE to be read or written in &quot;binary&quot; or &quot;text&quot; mode on systems where the run-time libraries distinguish between binary and text files. If FILEHANDLE is an expression, the value is taken as the name of the filehandle. Returns true on success, otherwise it returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and sets &lt;code&gt;$!&lt;/code&gt; (errno).</source>
          <target state="translated">런타임 라이브러리가 이진 파일과 텍스트 파일을 구별하는 시스템에서 FILEHANDLE을 &quot;이진&quot;또는 &quot;텍스트&quot;모드로 읽거나 쓰도록 정렬합니다. FILEHANDLE이 표현식 인 경우 값은 파일 핸들의 이름으로 사용됩니다. 성공하면 true를 반환하고, 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환 하고 &lt;code&gt;$!&lt;/code&gt; 설정합니다 ! (errno).</target>
        </trans-unit>
        <trans-unit id="1ffbadba9c3dce1044ad3f375a7830b9eb0ed44f" translate="yes" xml:space="preserve">
          <source>Arranges for FILEHANDLE to be read or written in &quot;binary&quot; or &quot;text&quot; mode on systems where the run-time libraries distinguish between binary and text files. If FILEHANDLE is an expression, the value is taken as the name of the filehandle. Returns true on success, otherwise it returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and sets &lt;code&gt;$!&lt;/code&gt; (errno).</source>
          <target state="translated">런타임 라이브러리가 이진 파일과 텍스트 파일을 구별하는 시스템에서 FILEHANDLE을 &quot;이진&quot;또는 &quot;텍스트&quot;모드로 읽거나 쓰도록 정렬합니다. FILEHANDLE이 표현식 인 경우 값은 파일 핸들의 이름으로 사용됩니다. 성공하면 true를 반환하고, 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환 하고 &lt;code&gt;$!&lt;/code&gt; 설정합니다 ! (errno).</target>
        </trans-unit>
        <trans-unit id="343c9f92b2508f5809b499c36c6237ee53dad8e9" translate="yes" xml:space="preserve">
          <source>Arranges for a mutual exclusion lock to be obtained on sv if a suitable module has been loaded.</source>
          <target state="translated">적절한 모듈이로드 된 경우 sv에서 상호 배제 잠금을 얻도록 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="a5173bbe458c53871d9b1f27fa09a96bfb62b86e" translate="yes" xml:space="preserve">
          <source>Arranges for sv to be shared between threads if a suitable module has been loaded.</source>
          <target state="translated">적합한 모듈이로드 된 경우 sv이 스레드간에 공유되도록 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="5e55b4fcd8dbc2fd2ba6c045d961bacb9e292142" translate="yes" xml:space="preserve">
          <source>Arranges to have a SIGALRM delivered to this process after the specified number of wallclock seconds has elapsed. If SECONDS is not specified, the value stored in &lt;code&gt;$_&lt;/code&gt; is used. (On some machines, unfortunately, the elapsed time may be up to one second less or more than you specified because of how seconds are counted, and process scheduling may delay the delivery of the signal even further.)</source>
          <target state="translated">지정된 벽시계 시간 (초)이 경과 한 후이 프로세스에 SIGALRM이 전달되도록 정렬합니다. SECONDS를 지정하지 않으면 &lt;code&gt;$_&lt;/code&gt; 저장된 값 이 사용됩니다. 불행하게도 일부 컴퓨터에서는 경과 시간이 초 계산 방법으로 인해 지정한 시간보다 최대 1 초 이하가 될 수 있으며 프로세스 예약은 신호 전달을 더 지연시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc39e6a09e8f437b433c2957e8745936c343df43" translate="yes" xml:space="preserve">
          <source>Array Interpolation</source>
          <target state="translated">배열 보간</target>
        </trans-unit>
        <trans-unit id="946f892404632d1e1ef312d460522dbcef0e5ca6" translate="yes" xml:space="preserve">
          <source>Array Manipulation Functions</source>
          <target state="translated">배열 조작 함수</target>
        </trans-unit>
        <trans-unit id="e55ce1c88c52594e868f7dcd4b7c1bf4e8ab55e6" translate="yes" xml:space="preserve">
          <source>Array of extension names to be included when doing a static build. MakeMaker will normally build with all of the installed extensions when doing a static build, and that is usually the desired behavior. If INCLUDE_EXT is present then MakeMaker will build only with those extensions which are explicitly mentioned. (e.g. [ qw( Socket POSIX ) ])</source>
          <target state="translated">정적 빌드를 수행 할 때 포함 할 확장 이름의 배열입니다. 정적 빌드를 수행 할 때 MakeMaker는 일반적으로 설치된 모든 확장으로 빌드되며 이는 일반적으로 원하는 동작입니다. INCLUDE_EXT가 있으면 MakeMaker는 명시 적으로 언급 된 확장명으로 만 빌드합니다. (예 : [qw (Socket POSIX)])</target>
        </trans-unit>
        <trans-unit id="1a8fc45517962d9406be17b19c25fe3aa87b4fd8" translate="yes" xml:space="preserve">
          <source>Array of extension names to exclude when doing a static build. This is ignored if INCLUDE_EXT is present. Consult INCLUDE_EXT for more details. (e.g. [ qw( Socket POSIX ) ] )</source>
          <target state="translated">정적 빌드를 수행 할 때 제외 할 확장명 배열입니다. INCLUDE_EXT가 있으면 무시됩니다. 자세한 내용은 INCLUDE_EXT를 참조하십시오. (예 : [qw (Socket POSIX)])</target>
        </trans-unit>
        <trans-unit id="ab0eedcb736c58c9e1bf3d9da5ea7d522b690f73" translate="yes" xml:space="preserve">
          <source>Array of strings containing name (and email address) of package author(s). Is used in CPAN Meta files (META.yml or META.json) and PPD (Perl Package Description) files for PPM (Perl Package Manager).</source>
          <target state="translated">패키지 작성자의 이름 (및 이메일 주소)을 포함하는 문자열 배열. PPM (Perl Package Manager)의 CPAN 메타 파일 (META.yml 또는 META.json) 및 PPD (Perl Package Description) 파일에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c57f3a7023d5d1d3793f2eb3d27a157609936e28" translate="yes" xml:space="preserve">
          <source>Array of symbol names for variables to be made available as universal symbols. Used only under AIX, OS/2, VMS and Win32 at present. Defaults to []. (e.g. [ qw(Foo_version Foo_numstreams Foo_tree ) ])</source>
          <target state="translated">변수를 범용 기호로 사용할 수 있도록하는 기호 이름 배열. 현재 AIX, OS / 2, VMS 및 Win32에서만 사용됩니다. 기본값은 []입니다. (예 : [qw (Foo_version Foo_numstreams Foo_tree)])</target>
        </trans-unit>
        <trans-unit id="9ab44c94b1ea31feff632108e9870b5e1654c616" translate="yes" xml:space="preserve">
          <source>Array operations, which change the scalars, rearrange them, or add or subtract some scalars, only work on arrays. These can't work on a list, which is fixed. Array operations include &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">스칼라를 변경하거나 재정렬하거나 일부 스칼라를 더하거나 빼는 배열 연산은 배열에서만 작동합니다. 이들은 목록에서 작동하지 않으며 고정되어 있습니다. 배열 작업에는 &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; 가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="70c97244599437a3af8dc620ee670c18edb6906b" translate="yes" xml:space="preserve">
          <source>Array size can be obtained by doing:</source>
          <target state="translated">배열 크기는 다음을 수행하여 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4958f544bd9596999a8c5e79c668a1a1962b374e" translate="yes" xml:space="preserve">
          <source>Array, indexed by opcode, of functions that will be called for the &quot;check&quot; phase of optree building during compilation of Perl code. For most (but not all) types of op, once the op has been initially built and populated with child ops it will be filtered through the check function referenced by the appropriate element of this array. The new op is passed in as the sole argument to the check function, and the check function returns the completed op. The check function may (as the name suggests) check the op for validity and signal errors. It may also initialise or modify parts of the ops, or perform more radical surgery such as adding or removing child ops, or even throw the op away and return a different op in its place.</source>
          <target state="translated">Perl 코드를 컴파일하는 동안 optree 작성의 &quot;확인&quot;단계를 위해 호출 될 함수의 배열 (opcode로 색인화 됨). 대부분의 (전부는 아님) 유형의 op의 경우, op가 처음에 하위 op로 빌드되고 채워지면이 배열의 해당 요소에서 참조하는 확인 기능을 통해 필터링됩니다. 새 op는 check 함수에 대한 유일한 인수로 전달되며 check 함수는 완료된 op를 반환합니다. 확인 기능은 (이름에서 알 수 있듯이) 연산의 유효성 및 신호 오류를 확인할 수 있습니다. 또한 작전의 일부를 초기화하거나 수정하거나 하위 작전을 추가하거나 제거하는 등의 과격한 수술을 수행하거나 작전을 버리고 다른 작전을 대신 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7622ad2f459420f8cf1278b446072cfedac9e366" translate="yes" xml:space="preserve">
          <source>Arrayref. E.g. [qw(archname manext)] defines ARCHNAME &amp;amp; MANEXT from config.sh. MakeMaker will add to CONFIG the following values anyway: ar cc cccdlflags ccdlflags dlext dlsrc ld lddlflags ldflags libc lib_ext obj_ext ranlib sitelibexp sitearchexp so</source>
          <target state="translated">Arrayref. 예를 들어 [qw (archname manext)]는 config.sh에서 ARCHNAME &amp;amp; MANEXT를 정의합니다. MakeMaker는 어쨌든 다음 값을 CONFIG에 추가합니다. ar cc cccdlflags ccdlflags dlext dlsrc ld lddlflags ldflags libc lib_ext obj_ext ranlib sitelibexp sitearchexp so</target>
        </trans-unit>
        <trans-unit id="ac3c8cf1aba574321bc1f66afd6baee7d74ccdb5" translate="yes" xml:space="preserve">
          <source>Arrayref. E.g. [qw(name1 name2)] skip (do not write) sections of the Makefile. Caution! Do not use the SKIP attribute for the negligible speedup. It may seriously damage the resulting Makefile. Only use it if you really need it.</source>
          <target state="translated">Arrayref. 예를 들어 [qw (name1 name2)]는 Makefile의 섹션을 건너 뛰십시오 (쓰기 금지). 주의! 무시할만한 속도 향상을 위해 SKIP 속성을 사용하지 마십시오. 결과적인 Makefile이 심각하게 손상 될 수 있습니다. 정말로 필요한 경우에만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="065b62648ae15e66467cb649a0f78784ebc20d69" translate="yes" xml:space="preserve">
          <source>Arrays and slices are interpolated into double-quoted strings by joining the elements with the delimiter specified in the &lt;code&gt;$&quot;&lt;/code&gt; variable (&lt;code&gt;$LIST_SEPARATOR&lt;/code&gt; if &quot;use English;&quot; is specified), space by default. The following are equivalent:</source>
          <target state="translated">배열과 슬라이스는 &lt;code&gt;$LIST_SEPARATOR&lt;/code&gt; &lt;code&gt;$&quot;&lt;/code&gt; 변수 ( &quot;use English; &quot;가 지정된 경우 $ LIST_SEPARATOR)에 지정된 구분 기호로 요소를 결합하여 큰 따옴표로 묶인 문자열로 보간됩니다 . 기본적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="015aea03d19c4f5404b14d2e291f0bb807a559b3" translate="yes" xml:space="preserve">
          <source>Arrays are zero-indexed. Here's how you get at elements in an array:</source>
          <target state="translated">배열은 인덱스가 0입니다. 배열의 요소를 얻는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="62a56f74931523c8c6be523e0f4189cd13f83348" translate="yes" xml:space="preserve">
          <source>Arrays index from 0. Likewise string positions in substr() and index().</source>
          <target state="translated">인덱스는 0부터 배열합니다. 마찬가지로 substr () 및 index ()의 문자열 위치입니다.</target>
        </trans-unit>
        <trans-unit id="c6d4028b66a4b9402be627f34603725a671721e9" translate="yes" xml:space="preserve">
          <source>Arrays:</source>
          <target state="translated">Arrays:</target>
        </trans-unit>
        <trans-unit id="d88829ea9618170c7e2c7635ccc9b881ef3d9e85" translate="yes" xml:space="preserve">
          <source>Arrow Rule</source>
          <target state="translated">화살표 규칙</target>
        </trans-unit>
        <trans-unit id="59f3e01c7f1fff089e4fc72d78498e369ebc8aba" translate="yes" xml:space="preserve">
          <source>Article about software localization</source>
          <target state="translated">소프트웨어 현지화 관련 기사</target>
        </trans-unit>
        <trans-unit id="7c422841b7e3951946583038790545c4ed38481b" translate="yes" xml:space="preserve">
          <source>Articles</source>
          <target state="translated">Articles</target>
        </trans-unit>
        <trans-unit id="c2be5dffac8f664ad6e121cb0e6596d1cc2f8c20" translate="yes" xml:space="preserve">
          <source>Articles that are either about &lt;b&gt;DB_File&lt;/b&gt; or make use of it.</source>
          <target state="translated">&lt;b&gt;DB_File&lt;/b&gt; 관련 기사 또는이를 사용 하는 기사 .</target>
        </trans-unit>
        <trans-unit id="5ec201db4d2d3c7be7bb34f8e626f24de679e0d7" translate="yes" xml:space="preserve">
          <source>Artur Bergman &amp;lt;sky AT crucially DOT net&amp;gt;</source>
          <target state="translated">Artur Bergman &amp;lt;하늘에서 결정적으로 DOT net&amp;gt;</target>
        </trans-unit>
        <trans-unit id="8abf83e588a6f8dbd23df54124d573a8d6e50b02" translate="yes" xml:space="preserve">
          <source>Artur Bergman, &quot;Where Wizards Fear To Tread&quot;, June 11, 2002, &lt;a href=&quot;http://www.perl.com/pub/a/2002/06/11/threads.html&quot;&gt;http://www.perl.com/pub/a/2002/06/11/threads.html&lt;/a&gt;</source>
          <target state="translated">Artur Bergman, &quot;마법사가 두려워하는 곳&quot;, 2002 년 6 월 11 일, &lt;a href=&quot;http://www.perl.com/pub/a/2002/06/11/threads.html&quot;&gt;http://www.perl.com/pub/a/2002/06/11/threads.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9d31985fda87b26d6554bcfbfe7dbc398b51917e" translate="yes" xml:space="preserve">
          <source>As</source>
          <target state="translated">As</target>
        </trans-unit>
        <trans-unit id="47c29ec0c3f7f05bae80de5283a0b030f441a291" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt; or &lt;a href=&quot;../functions/lstat&quot;&gt;lstat&lt;/a&gt; but with the access/modify/change file timestamps in subsecond resolution, if the operating system and the filesystem both support such timestamps. To override the standard stat():</source>
          <target state="translated">으로 &lt;a href=&quot;../functions/stat&quot;&gt;합계&lt;/a&gt; 또는 &lt;a href=&quot;../functions/lstat&quot;&gt;lstat는&lt;/a&gt; 하지만 초 미만 해상도의 액세스 / 수정 / 변경 파일 타임 스탬프와 운영 체제 및 파일 시스템을 모두 지원 등의 타임 스탬프 경우. 표준 stat ()를 재정의하려면</target>
        </trans-unit>
        <trans-unit id="02b2b57eecbbd649395f996ef53060747f75fc9c" translate="yes" xml:space="preserve">
          <source>As &lt;b&gt;-nok&lt;/b&gt; except it will report on older systems.</source>
          <target state="translated">으로 &lt;b&gt;-nok&lt;/b&gt; 은 이전 시스템에보고합니다 제외.</target>
        </trans-unit>
        <trans-unit id="4859922e8f70272693e823f3867ed24a92199eaa" translate="yes" xml:space="preserve">
          <source>As &lt;b&gt;-ok&lt;/b&gt; except it will report on older systems.</source>
          <target state="translated">으로 &lt;b&gt;-ok&lt;/b&gt; 는 이전 시스템에보고합니다 제외.</target>
        </trans-unit>
        <trans-unit id="11468a3ea9b3583c1d2e6860cce82a44a9b04f63" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;$form_name&lt;/code&gt; , one of the following names must be given.</source>
          <target state="translated">으로 &lt;code&gt;$form_name&lt;/code&gt; , 다음 이름 중 하나를 부여해야합니다.</target>
        </trans-unit>
        <trans-unit id="2779b0caf565b7a913bad43d8e6bc994f2a3b086" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;-Dm&lt;/code&gt; is using the PerlIO layer for output, it will by itself allocate quite a bunch of SVs, which are hidden to avoid recursion. You can bypass the PerlIO layer if you use the SV logging provided by &lt;code&gt;-DPERL_MEM_LOG&lt;/code&gt; instead.</source>
          <target state="translated">으로 &lt;code&gt;-Dm&lt;/code&gt; 출력의은 PerlIO 층을 사용하고, 그 자체는 피할 재귀에 숨겨져의 SV 꽤 무리를 할당합니다으로. &lt;code&gt;-DPERL_MEM_LOG&lt;/code&gt; 에서 제공 한 SV 로깅을 대신 사용하면 PerlIO 계층을 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="67afac02f586f9bebcefbfe5f3e2ccc5758a2739" translate="yes" xml:space="preserve">
          <source>As Perl is developed by a global team of volunteers, our documentation often contains spellings which look funny to</source>
          <target state="translated">전 세계 자원 봉사 팀이 Perl을 개발함에 따라, 우리의 문서에는 종종 우스운 철자가 들어 있습니다.</target>
        </trans-unit>
        <trans-unit id="56f06af6196a2958b2b24cc234e03f482b95a8e2" translate="yes" xml:space="preserve">
          <source>As Storable neither knows nor cares about character sets (although it does know that characters may be more than eight bits wide), any difference in the interpretation of character codes between a host and a target system is your problem. In particular, if host and target use different code points to represent the characters used in the text representation of floating-point numbers, you will not be able be able to exchange floating-point data, even with nstore().</source>
          <target state="translated">Storable은 문자 세트를 알거나 신경 쓰지 않기 때문에 (문자 길이가 8 비트를 초과 할 수 있음을 알고 있지만) 호스트와 대상 시스템 간의 문자 코드 해석에 차이가있는 것은 문제입니다. 특히 호스트와 대상이 부동 소수점 숫자의 텍스트 표현에 사용 된 문자를 나타 내기 위해 다른 코드 포인트를 사용하는 경우 nstore ()와 함께 부동 소수점 데이터를 교환 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4eb26264176ff313034cbea4b1e32ac9ca4ff4be" translate="yes" xml:space="preserve">
          <source>As a beginning Perl programmer, your most common use of OO Perl will be in using third-party modules, which are documented below.</source>
          <target state="translated">초창기 Perl 프로그래머로서 OO Perl의 가장 일반적인 사용은 아래에 설명 된 타사 모듈을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c668c33e20c8d7992e509e03d3adf2ab76f6474b" translate="yes" xml:space="preserve">
          <source>As a consequence of the fact that &lt;code&gt;:raw&lt;/code&gt; normally pops layers, it usually only makes sense to have it as the only or first element in a layer specification. When used as the first element it provides a known base on which to build e.g.</source>
          <target state="translated">&lt;code&gt;:raw&lt;/code&gt; 는 일반적으로 레이어를 팝 한다는 사실의 결과로 레이어 사양에서 유일한 요소 또는 첫 번째 요소로 사용하는 것이 좋습니다. 첫 번째 요소로 사용될 때 알려진 기초를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="85a48b10d40e66cd4a8aedc3b80bf9f3898c7f18" translate="yes" xml:space="preserve">
          <source>As a consequence, &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; ignores any number or &lt;code&gt;*&lt;/code&gt; after &lt;code&gt;P&lt;/code&gt; .</source>
          <target state="translated">결과적으로 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;P&lt;/code&gt; 뒤의 숫자 또는 &lt;code&gt;*&lt;/code&gt; 를 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="af58dfe35e68f1702e8805a513e543501b556b2f" translate="yes" xml:space="preserve">
          <source>As a consequence, the behavior of the operator % agrees with the behavior of Perl's built-in % operator (as documented in the perlop manpage), and the equation</source>
          <target state="translated">결과적으로 연산자 %의 동작은 Perlop의 내장 % 연산자 (perlop 맨 페이지에 설명 된대로)의 동작과 방정식에 동의합니다.</target>
        </trans-unit>
        <trans-unit id="8ed20c41e94e838dcaa1f2e890809ac53aaadc11" translate="yes" xml:space="preserve">
          <source>As a convenience, &lt;a href=&quot;io/socket&quot;&gt;IO::Socket&lt;/a&gt;'s setsockopt() method will convert a number into a packed byte buffer, and getsockopt() will unpack a byte buffer of the correct size back into a number.</source>
          <target state="translated">편의상 &lt;a href=&quot;io/socket&quot;&gt;IO :: Socket&lt;/a&gt; 의 setsockopt () 메소드는 숫자를 묶음 바이트 버퍼로 변환하고 getsockopt ()는 올바른 크기의 바이트 버퍼를 다시 숫자로 압축 해제합니다.</target>
        </trans-unit>
        <trans-unit id="39dd3ca26236e47c7f0b84b7220b02b39c4ce6f1" translate="yes" xml:space="preserve">
          <source>As a convenience, if only one argument is passed then this argument is assumed to be the name of the test (as in the above examples.)</source>
          <target state="translated">편의상 하나의 인수 만 전달하면이 인수는 위의 예와 같이 테스트 이름으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="1cb03824a7a51fc71299760a7d72ef70c9f7d1d1" translate="yes" xml:space="preserve">
          <source>As a debugging aid, you can force Carp to treat a croak as a confess and a carp as a cluck across</source>
          <target state="translated">디버깅 보조 도구로, 잉어에게 고백을 고백으로, 잉어를 럭키로 취급하게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5de9c4f1738c3fbc65c8014410d9308c0bceec73" translate="yes" xml:space="preserve">
          <source>As a derived class from Pod::Parser, Pod::PlainText supports the same methods and interfaces. See &lt;a href=&quot;parser&quot;&gt;Pod::Parser&lt;/a&gt; for all the details; briefly, one creates a new parser with &lt;code&gt;Pod::PlainText-&amp;gt;new()&lt;/code&gt; and then calls either parse_from_filehandle() or parse_from_file().</source>
          <target state="translated">Pod :: Parser에서 파생 된 클래스 인 Pod :: PlainText는 동일한 메서드와 인터페이스를 지원합니다. 자세한 내용은 &lt;a href=&quot;parser&quot;&gt;Pod :: Parser&lt;/a&gt; 를 참조 하십시오. 간단히 말해 &lt;code&gt;Pod::PlainText-&amp;gt;new()&lt;/code&gt; 사용하여 새 파서를 만든 다음 parse_from_filehandle () 또는 parse_from_file ()을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="f6ec952fc34afc28085390c8d52daf19e0a80643" translate="yes" xml:space="preserve">
          <source>As a derived class from Pod::Simple, Pod::Man supports the same methods and interfaces. See &lt;a href=&quot;simple&quot;&gt;Pod::Simple&lt;/a&gt; for all the details.</source>
          <target state="translated">Pod :: Simple에서 파생 된 클래스 인 Pod :: Man은 동일한 메소드와 인터페이스를 지원합니다. 자세한 내용은 &lt;a href=&quot;simple&quot;&gt;Pod :: Simple&lt;/a&gt; 을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="3e4fc5bdbe388e6ddf3cda0d8bc20220f607ea7d" translate="yes" xml:space="preserve">
          <source>As a derived class from Pod::Simple, Pod::Text supports the same methods and interfaces. See &lt;a href=&quot;simple&quot;&gt;Pod::Simple&lt;/a&gt; for all the details; briefly, one creates a new parser with &lt;code&gt;Pod::Text-&amp;gt;new()&lt;/code&gt; and then normally calls parse_file().</source>
          <target state="translated">Pod :: Simple에서 파생 된 클래스 인 Pod :: Text는 동일한 메서드와 인터페이스를 지원합니다. 자세한 내용은 &lt;a href=&quot;simple&quot;&gt;포드 :: 단순&lt;/a&gt; 을 참조 하십시오. 간단히 말해서 &lt;code&gt;Pod::Text-&amp;gt;new()&lt;/code&gt; Text- &amp;gt; new ()를 사용하여 새 파서를 만든 다음 일반적으로 parse_file ()을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="b23f74daa8f57475a4ba46fd4485f5b745823a7e" translate="yes" xml:space="preserve">
          <source>As a final remark, note that one can fill %subr by</source>
          <target state="translated">마지막으로, % subr을 다음과 같이 채울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cc64b626e2a5166499114ddf2d5328e019929e3" translate="yes" xml:space="preserve">
          <source>As a final thought, remember that it's not (at the time of writing) possible to produce a useful program which will run in zero or negative time and this basic principle can be written as:</source>
          <target state="translated">마지막으로, 0 또는 음의 시간에 실행되는 유용한 프로그램을 생성 할 수 없으며 작성하는 것이 불가능하며이 기본 원칙은 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c76d7d0ab08773eceae9495e1336acd5bdc1e071" translate="yes" xml:space="preserve">
          <source>As a further example, this means that if you wanted to put these bits of code in &lt;code&gt;C&lt;/code&gt; (code) style:</source>
          <target state="translated">추가 예를 들어,이 코드를 &lt;code&gt;C&lt;/code&gt; (코드) 스타일 로 넣으려면 다음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="a5d5c5dbed3ae73f59f4d512802a9cfe627521f0" translate="yes" xml:space="preserve">
          <source>As a further example: At time of writing, no &quot;biblio&quot; identifier is supported, but suppose some processor were written to recognize it as a way of (say) denoting a bibliographic reference (necessarily containing formatting codes in ordinary paragraphs). The fact that &quot;biblio&quot; paragraphs were meant for ordinary processing would be indicated by prefacing each &quot;biblio&quot; identifier with a colon:</source>
          <target state="translated">추가 예 : 작성시 &quot;biblio&quot;식별자가 지원되지 않지만 일부 프로세서가 서지 참조를 나타내는 방법 (예 : 일반 단락에 형식화 코드를 포함해야 함)으로 인식하도록 작성되었다고 가정하십시오. &quot;biblio&quot;단락이 일반적인 처리를 위해 사용되었다는 사실은 각 &quot;biblio&quot;식별자 앞에 콜론을 붙여서 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="32e712936b7f11c5ab2eb3ed80fcfadcc776b710" translate="yes" xml:space="preserve">
          <source>As a further optimisation, on exit from the eval block in the &lt;code&gt;FETCH&lt;/code&gt; , execution of the code following the block is still carried on in the inner loop. When an exception is raised, &lt;code&gt;docatch&lt;/code&gt; compares the &lt;code&gt;JMPENV&lt;/code&gt; level of the &lt;code&gt;CxEVAL&lt;/code&gt; with &lt;code&gt;PL_top_env&lt;/code&gt; and if they differ, just re-throws the exception. In this way any inner loops get popped.</source>
          <target state="translated">추가 최적화로서, &lt;code&gt;FETCH&lt;/code&gt; 의 평가 블록으로부터 나올 때, 블록 다음의 코드의 실행은 여전히 ​​내부 루프에서 수행된다. 예외가 발생하면 &lt;code&gt;docatch&lt;/code&gt; 는 CxEVAL 의 &lt;code&gt;JMPENV&lt;/code&gt; 레벨을 &lt;code&gt;CxEVAL&lt;/code&gt; 와 &lt;code&gt;PL_top_env&lt;/code&gt; 하고 다른 경우 예외를 다시 발생시킵니다. 이런 식으로 내부 루프가 튀어 나옵니다.</target>
        </trans-unit>
        <trans-unit id="23702715810537d7f01f041b430e67e396dff672" translate="yes" xml:space="preserve">
          <source>As a general rule of thumb, your commit message should help a programmer who knows the Perl core quickly understand what you were trying to do, how you were trying to do it, and why the change matters to Perl.</source>
          <target state="translated">일반적으로 커밋 메시지는 Perl 코어를 아는 프로그래머가 수행하려는 작업, 수행 방법 및 변경이 Perl에 중요한 이유를 신속하게 이해하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="4e47a1601663426f056fd202a23442a94b37a934" translate="yes" xml:space="preserve">
          <source>As a general rule you should</source>
          <target state="translated">일반적으로</target>
        </trans-unit>
        <trans-unit id="f1a7ae8ef2fbb4b6cb7127db887caa429f079e93" translate="yes" xml:space="preserve">
          <source>As a general rule, if the module is trying to be object oriented then export nothing. If it's just a collection of functions then &lt;code&gt;@EXPORT_OK&lt;/code&gt; anything but use &lt;code&gt;@EXPORT&lt;/code&gt; with caution. For function and method names use barewords in preference to names prefixed with ampersands for the export lists.</source>
          <target state="translated">일반적으로 모듈이 객체 지향적이라면 아무것도 내 보내지 않습니다. 함수 모음 인 경우 &lt;code&gt;@EXPORT&lt;/code&gt; _OK &lt;code&gt;@EXPORT_OK&lt;/code&gt; @EXPORT 를 사용하지만 주의해서 사용하십시오. 함수 및 메소드 이름의 경우 내보내기 목록에 앰퍼샌드가 접두어로 붙은 이름보다 기본 단어를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e17549d186f2cd9b2973080585cd98536cba2f89" translate="yes" xml:space="preserve">
          <source>As a general rule, if the module is trying to be object oriented then export nothing. If it's just a collection of functions then @EXPORT_OK anything but use @EXPORT with caution.</source>
          <target state="translated">일반적으로 모듈이 객체 지향적이라면 아무것도 내 보내지 않습니다. 함수 모음 인 경우 @EXPORT_OK 외에 @EXPORT를 사용하지만주의해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="433c99eba76250876af9c971ad06d88a2549474f" translate="yes" xml:space="preserve">
          <source>As a general rule, if the module is trying to be object-oriented then don't export anything. If it's just a collection of functions and variables, then you can export them via another array, called &lt;code&gt;@EXPORT_OK&lt;/code&gt; . This array does not automatically place its subroutine and variable names into the namespace unless the user specifically requests that this be done.</source>
          <target state="translated">일반적으로 모듈이 객체 지향적이라면 아무것도 내 보내지 마십시오. 함수와 변수의 모음 일 경우 &lt;code&gt;@EXPORT_OK&lt;/code&gt; 라는 다른 배열을 통해 내보낼 수 있습니다 . 사용자가 특별히 요청하지 않는 한이 배열은 서브 루틴 및 변수 이름을 네임 스페이스에 자동으로 배치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a207991a7d026174ee51a8481f0b776cbc48b6ea" translate="yes" xml:space="preserve">
          <source>As a last resort, however:</source>
          <target state="translated">그러나 최후의 수단으로 :</target>
        </trans-unit>
        <trans-unit id="3ab2161dda92a73d5893b103484d832131038b70" translate="yes" xml:space="preserve">
          <source>As a last resort, you can use the perl one-liner:</source>
          <target state="translated">최후의 수단으로 펄 원 라이너를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a117b27b5618d5856aaaf26d908e957a310a377" translate="yes" xml:space="preserve">
          <source>As a last resort, you could also use &lt;code&gt;PERL5DB&lt;/code&gt; to customize the debugger by directly setting internal variables or calling debugger functions.</source>
          <target state="translated">최후의 수단으로 &lt;code&gt;PERL5DB&lt;/code&gt; 를 사용 하여 내부 변수를 직접 설정하거나 디버거 함수를 호출하여 디버거를 사용자 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="46efdbcc9fcabaefc1ffd7ba61888d42081d0818" translate="yes" xml:space="preserve">
          <source>As a noun, a piece of syntax made up of smaller pieces. As a transitive verb, to create an &lt;b&gt;object&lt;/b&gt; using a &lt;b&gt;constructor&lt;/b&gt;.</source>
          <target state="translated">명사로서, 작은 조각으로 구성된 구문 조각. 타동사로서, 생성하는 &lt;b&gt;객체&lt;/b&gt; 사용하여 &lt;b&gt;생성자를&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="3f0cb7718076aa901719a5347944ab158c02cce2" translate="yes" xml:space="preserve">
          <source>As a result of these problems, starting in v5.20, what Perl does is to treat non-Unicode code points as just typical unassigned Unicode characters, and matches accordingly. (Note: Unicode has atypical unassigned code points. For example, it has noncharacter code points, and ones that, when they do get assigned, are destined to be written Right-to-left, as Arabic and Hebrew are. Perl assumes that no non-Unicode code point has any atypical properties.)</source>
          <target state="translated">v5.20부터 이러한 문제점의 결과로 Perl이 수행하는 것은 비 유니 코드 코드 포인트를 할당되지 않은 일반적인 유니 코드 문자로 처리하고 이에 따라 일치시키는 것입니다. (참고 : 유니 코드에는 비정형 할당되지 않은 코드 포인트가 있습니다. 예를 들어, 유니 코드가 아닌 코드 포인트가 있으며, 할당 될 때 아랍어와 히브리어와 같이 오른쪽에서 왼쪽으로 쓰여지는 코드 포인트가 있습니다. 비 유니 코드 코드 포인트에는 비정형 속성이 있습니다.)</target>
        </trans-unit>
        <trans-unit id="dd723ff09f0dfd75022fcfe75451c37784da18b7" translate="yes" xml:space="preserve">
          <source>As a result, &lt;code&gt;$?&lt;/code&gt; will always be zero if the subprocess's exit status indicated successful completion, and non-zero if a warning or error occurred or a program compliant with encoding _POSIX_EXIT values was run and set a status.</source>
          <target state="translated">결과적으로 &lt;code&gt;$?&lt;/code&gt; 서브 프로세스의 종료 상태가 성공적으로 완료된 것으로 표시되면 항상 0이되고, 경고 또는 오류가 발생했거나 인코딩 _POSIX_EXIT 값을 준수하는 프로그램이 실행되어 상태를 설정하면 0이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c26b5ebaa65b4ac15b7d233c58e1a9bb61162748" translate="yes" xml:space="preserve">
          <source>As a scalar operator:</source>
          <target state="translated">스칼라 연산자로서 :</target>
        </trans-unit>
        <trans-unit id="8274ec69a734737beb00f3f5313b731efea1dc76" translate="yes" xml:space="preserve">
          <source>As a shortcut &lt;code&gt;(*MARK:NAME)&lt;/code&gt; can be written &lt;code&gt;(*:NAME)&lt;/code&gt;.</source>
          <target state="translated">바로 가기 &lt;code&gt;(*MARK:NAME)&lt;/code&gt; 로 쓸 수 있습니다 &lt;code&gt;(*:NAME)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b9a135b5dd5e3840c9d7b2126bd8f1513618105" translate="yes" xml:space="preserve">
          <source>As a shortcut a one-argument call takes the filename from the global scalar variable of the same name as the filehandle:</source>
          <target state="translated">하나의 인수 호출은 파일 핸들과 같은 이름의 전역 스칼라 변수에서 파일 이름을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="9baecd622ad6ae8ccb368a1f47c6a9f4ae3fac55" translate="yes" xml:space="preserve">
          <source>As a shortcut, you can use the module &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt;:</source>
          <target state="translated">바로 가기로 &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt; 모듈을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5b3e1134bf3b8109ecb5762080e2eff8e1996cc6" translate="yes" xml:space="preserve">
          <source>As a side effect, as &lt;code&gt;_&lt;/code&gt; doesn't work, stacked filetest operators (&lt;code&gt;-f -w $file&lt;/code&gt; ) won't work either.</source>
          <target state="translated">부작용으로 &lt;code&gt;_&lt;/code&gt; 가 작동하지 않기 때문에 스택 &lt;code&gt;-f -w $file&lt;/code&gt; 테스트 연산자 ( -f -w $ file )도 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e67c2575fdaa4cadca39640f540c5c1c25ff2b7b" translate="yes" xml:space="preserve">
          <source>As a side effect, calling keys() resets the internal iterator of the HASH or ARRAY (see &lt;a href=&quot;#each&quot;&gt;each&lt;/a&gt;). In particular, calling keys() in void context resets the iterator with no other overhead.</source>
          <target state="translated">부작용으로 keys ()를 호출하면 HASH 또는 ARRAY의 내부 반복기가 재설정됩니다 ( &lt;a href=&quot;#each&quot;&gt;각&lt;/a&gt; 참조 ). 특히, void 컨텍스트에서 keys ()를 호출하면 다른 오버 헤드없이 반복자가 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="c7b3fa9f58a42d510ccd961956edd3b53e1d0c57" translate="yes" xml:space="preserve">
          <source>As a side effect, calling keys() resets the internal iterator of the HASH or ARRAY (see &lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;). In particular, calling keys() in void context resets the iterator with no other overhead.</source>
          <target state="translated">부작용으로 keys ()를 호출하면 HASH 또는 ARRAY의 내부 반복기가 재설정됩니다 ( &lt;a href=&quot;each&quot;&gt;각&lt;/a&gt; 참조 ). 특히, void 컨텍스트에서 keys ()를 호출하면 다른 오버 헤드없이 반복자가 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="aa184b78eeef36fa29a1577f9bf8458234354229" translate="yes" xml:space="preserve">
          <source>As a side effect, calling values() resets the HASH or ARRAY's internal iterator, see &lt;a href=&quot;#each&quot;&gt;each&lt;/a&gt;. (In particular, calling values() in void context resets the iterator with no other overhead. Apart from resetting the iterator, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; in list context is the same as plain &lt;code&gt;@array&lt;/code&gt; . (We recommend that you use void context &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; for this, but reasoned that taking &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; out would require more documentation than leaving it in.)</source>
          <target state="translated">부작용으로, values ​​()를 호출하면 HASH 또는 ARRAY의 내부 반복자가 재설정됩니다 ( &lt;a href=&quot;#each&quot;&gt;각&lt;/a&gt; 참조) . (특히 void 컨텍스트에서 values ​​()를 호출하면 다른 오버 헤드없이 반복자가 재설정됩니다. 반복자를 재설정하는 것 외에도 목록 컨텍스트의 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; &lt;a href=&quot;functions/values&quot;&gt;값&lt;/a&gt; 은 일반 &lt;code&gt;@array&lt;/code&gt; 와 동일 합니다. (void context &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; 를 사용하는 것이 좋습니다. 이를 위해 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; &lt;a href=&quot;functions/values&quot;&gt;값&lt;/a&gt; 을 가져 가면 그대로 두는 것보다 더 많은 문서가 필요하다고 생각했습니다.)</target>
        </trans-unit>
        <trans-unit id="a91a0923e5abea890fdc2bd22bb84126ade104fe" translate="yes" xml:space="preserve">
          <source>As a side effect, calling values() resets the HASH or ARRAY's internal iterator, see &lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;. (In particular, calling values() in void context resets the iterator with no other overhead. Apart from resetting the iterator, &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; in list context is the same as plain &lt;code&gt;@array&lt;/code&gt; . (We recommend that you use void context &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; for this, but reasoned that taking &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; out would require more documentation than leaving it in.)</source>
          <target state="translated">부작용으로, values ​​()를 호출하면 HASH 또는 ARRAY의 내부 반복자가 재설정됩니다 ( &lt;a href=&quot;each&quot;&gt;각&lt;/a&gt; 참조) . (특히 void 컨텍스트에서 values ​​()를 호출하면 다른 오버 헤드없이 반복자가 재설정됩니다. 반복자를 재설정하는 것 외에도 목록 컨텍스트의 &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; &lt;a href=&quot;values&quot;&gt;값&lt;/a&gt; 은 일반 &lt;code&gt;@array&lt;/code&gt; 와 동일 합니다. (void context &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; 를 사용하는 것이 좋습니다. 이를 위해 &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; &lt;a href=&quot;values&quot;&gt;값&lt;/a&gt; 을 가져 가면 그대로 두는 것보다 더 많은 문서가 필요하다고 생각했습니다.)</target>
        </trans-unit>
        <trans-unit id="e8e57a1c04bdc517b9206bb149b8d52cd1b60750" translate="yes" xml:space="preserve">
          <source>As a special case</source>
          <target state="translated">특별한 경우로</target>
        </trans-unit>
        <trans-unit id="17ea6c6f4727b11c2b48648599d60dd30f72b5e8" translate="yes" xml:space="preserve">
          <source>As a special case for &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;, the empty pattern given in &lt;a href=&quot;perlop#m%2fPATTERN%2fmsixpodualngc&quot;&gt;match operator&lt;/a&gt; syntax (&lt;code&gt;//&lt;/code&gt; ) specifically matches the empty string, which is contrary to its usual interpretation as the last successful match.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 의 특별한 경우로서, &lt;a href=&quot;perlop#m%2fPATTERN%2fmsixpodualngc&quot;&gt;일치 연산자&lt;/a&gt; 구문 ( &lt;code&gt;//&lt;/code&gt; )에 주어진 빈 패턴 은 빈 문자열과 일치합니다. 이는 빈 문자열과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="59db895ceb1feffbf61c972fbfef8ae7b61e3fff" translate="yes" xml:space="preserve">
          <source>As a special case for &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;, the empty pattern given in &lt;a href=&quot;../perlop#m%2fPATTERN%2fmsixpodualngc&quot;&gt;match operator&lt;/a&gt; syntax (&lt;code&gt;//&lt;/code&gt; ) specifically matches the empty string, which is contrary to its usual interpretation as the last successful match.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 의 특별한 경우로서, &lt;a href=&quot;../perlop#m%2fPATTERN%2fmsixpodualngc&quot;&gt;일치 연산자&lt;/a&gt; 구문 ( &lt;code&gt;//&lt;/code&gt; )에 주어진 빈 패턴 은 빈 문자열과 일치합니다. 이는 빈 문자열과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="527a25823c5b741d3ca1303c6cacef3dfa61f467" translate="yes" xml:space="preserve">
          <source>As a special case if the overload returns the object itself then it will be used directly. An overloaded conversion returning the object is probably a bug, because you're likely to get something that looks like &lt;code&gt;YourPackage=HASH(0x8172b34)&lt;/code&gt; .</source>
          <target state="translated">특별한 경우에 과부하가 객체 자체를 반환하면 직접 사용됩니다. &lt;code&gt;YourPackage=HASH(0x8172b34)&lt;/code&gt; 와 같은 것을 얻을 수 있기 때문에 객체를 반환하는 과부하 된 변환은 아마도 버그 일 것입니다 .</target>
        </trans-unit>
        <trans-unit id="898fa8e40ea8bbaf82f7657e12c724a39a6b933a" translate="yes" xml:space="preserve">
          <source>As a special case the three-argument form with a read/write mode and the third argument being &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">특별한 경우 읽기 / 쓰기 모드와 세 번째 인수는 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 인 세 개의 인수 형식입니다 .</target>
        </trans-unit>
        <trans-unit id="bfe8944e96951a5268014155bb5ff3707aad862a" translate="yes" xml:space="preserve">
          <source>As a special case the three-argument form with a read/write mode and the third argument being &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">특별한 경우 읽기 / 쓰기 모드와 세 번째 인수는 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 인 세 개의 인수 형식입니다 .</target>
        </trans-unit>
        <trans-unit id="39d0f95cc62f9b7d251ca80f498d915dd0b1187f" translate="yes" xml:space="preserve">
          <source>As a special case, &lt;code&gt;\(@foo)&lt;/code&gt; returns a list of references to the contents of &lt;code&gt;@foo&lt;/code&gt; , not a reference to &lt;code&gt;@foo&lt;/code&gt; itself. Likewise for &lt;code&gt;%foo&lt;/code&gt; , except that the key references are to copies (since the keys are just strings rather than full-fledged scalars).</source>
          <target state="translated">특별한 경우, &lt;code&gt;\(@foo)&lt;/code&gt; 는 &lt;code&gt;@foo&lt;/code&gt; 자체에 대한 참조가 아니라 &lt;code&gt;@foo&lt;/code&gt; 의 내용에 대한 참조 목록을 반환 합니다. 키 참조가 복사에 대한 것임을 제외하고 &lt;code&gt;%foo&lt;/code&gt; 와 마찬가지로 (키는 완전한 스칼라가 아니라 문자열이기 때문에).</target>
        </trans-unit>
        <trans-unit id="9d3b4ecbd7d509c41643f820908fd45c356bb919" translate="yes" xml:space="preserve">
          <source>As a special case, if the test in the &lt;code&gt;for&lt;/code&gt; loop (or the corresponding &lt;code&gt;while&lt;/code&gt; loop) is empty, it is treated as true. That is, both</source>
          <target state="translated">특별한 경우, &lt;code&gt;for&lt;/code&gt; 루프 (또는 해당하는 &lt;code&gt;while&lt;/code&gt; 루프) 의 테스트 가 비어 있으면 true로 처리됩니다. 즉, 둘 다</target>
        </trans-unit>
        <trans-unit id="07d1fa15ef1af04fe7ac16e1712ceb861430b28a" translate="yes" xml:space="preserve">
          <source>As a special case, if the value of this variable is space-separated, the tail might be used to disable the ornaments by setting the tail to be &lt;code&gt;o=0&lt;/code&gt; or &lt;code&gt;ornaments=0&lt;/code&gt; . The head should be as described above, say</source>
          <target state="translated">특별한 경우로,이 변수의 값이 공백으로 분리 된 경우 꼬리는 &lt;code&gt;o=0&lt;/code&gt; 또는 &lt;code&gt;ornaments=0&lt;/code&gt; 으로 설정하여 꼬리를 사용하여 장식품을 비활성화 할 수 있습니다 . 머리는 위에서 설명한대로해야합니다.</target>
        </trans-unit>
        <trans-unit id="0fde23ad411d5b9ebf1966fbf214f46640cb22f9" translate="yes" xml:space="preserve">
          <source>As a special case, if you specify the module name &lt;code&gt;Unicode&lt;/code&gt; , you'll get the version number of the Unicode Character Database bundled with the requested perl versions.</source>
          <target state="translated">특별한 경우로, 모듈 이름 &lt;code&gt;Unicode&lt;/code&gt; 를 지정 하면 요청 된 perl 버전과 함께 번들로 제공되는 유니 코드 문자 데이터베이스의 버전 번호를 얻게됩니다.</target>
        </trans-unit>
        <trans-unit id="03f58faea796a1077f97500a4e213c983487f04c" translate="yes" xml:space="preserve">
          <source>As a special case, when the accessor is called with a hash reference as the sole argument, this causes an assignment of the whole hash element. The object reference is returned.</source>
          <target state="translated">특별한 경우로, 접근자가 해시 참조를 단독 인수로 사용하여 호출하면 전체 해시 요소가 할당됩니다. 객체 참조가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d80964d39654d27c73a60223b4ebc15d6e6b2f91" translate="yes" xml:space="preserve">
          <source>As a special case, when the accessor is called with an array reference as the sole argument, this causes an assignment of the whole array element. The object reference is returned.</source>
          <target state="translated">특별한 경우로, 접근자를 유일한 인수로 배열 참조와 함께 호출하면 전체 배열 요소가 할당됩니다. 객체 참조가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="261536d85ff532107bd0e6c855c28c78277c6b3c" translate="yes" xml:space="preserve">
          <source>As a special exception, when you slice a list (but not an array or a hash), if the list evaluates to empty, then taking a slice of that empty list will always yield the empty list in turn. Thus:</source>
          <target state="translated">특별한 예외로, 목록을 슬라이스 할 때 (배열이나 해시가 아닌) 목록이 비어있는 것으로 평가되면 해당 빈 목록의 슬라이스를 가져 오면 항상 빈 목록이 생성됩니다. 그러므로:</target>
        </trans-unit>
        <trans-unit id="267a52b216bf364239047183b439e3e80275f9ef" translate="yes" xml:space="preserve">
          <source>As a vendor, you may have a requirement to backport security fixes beyond our 3 year support commitment. We can provide limited support and advice to you as you do so and, where possible will try to apply those patches to the relevant -maint branches in git, though we may or may not choose to make numbered releases or &quot;official&quot; patches available. Contact us at &amp;lt;perl5-security-report@perl.org&amp;gt; to begin that process.</source>
          <target state="translated">공급 업체는 3 년 간의 지원 약속을 넘어 보안 수정 프로그램을 백 포트해야 할 수도 있습니다. 우리는 귀하에게 제한된 지원과 조언을 제공 할 수 있으며, 가능한 경우 git의 관련 maint 브랜치에 해당 패치를 적용하려고 시도하지만 번호가 매겨진 릴리스 또는 &quot;공식&quot;패치를 사용하도록 선택하거나 선택하지 않을 수 있습니다. 해당 프로세스를 시작하려면 &amp;lt;perl5-security-report@perl.org&amp;gt;로 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="6b767e1ab5bdc22f58c69583808a39ce8aa5393a" translate="yes" xml:space="preserve">
          <source>As a volunteer organization, the commitments we make are heavily dependent on the goodwill and hard work of individuals who have no obligation to contribute to Perl.</source>
          <target state="translated">자원 봉사 단체로서 우리가하는 약속은 Perl에 기여할 의무가없는 개인의 선의와 노력에 크게 좌우됩니다.</target>
        </trans-unit>
        <trans-unit id="b55a4625fdc844badd446c13482f0c20c8caa1b5" translate="yes" xml:space="preserve">
          <source>As above, but the destination node text of the link.</source>
          <target state="translated">위와 같지만 링크의 대상 노드 텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="07731660b460e18f03465884e08d802967534966" translate="yes" xml:space="preserve">
          <source>As all values evaluate to true, a simple &lt;code&gt;if&lt;/code&gt; test is good enough to determine whether an extension is present.</source>
          <target state="translated">모든 값이 true로 평가 &lt;code&gt;if&lt;/code&gt; , 확장이 있는지 여부를 판별하기에 충분한 간단한 if 테스트가 적합합니다.</target>
        </trans-unit>
        <trans-unit id="049e8d249c3ad3a2a8b180055568baa12252b047" translate="yes" xml:space="preserve">
          <source>As alluded to earlier you can also declare inlined subs dynamically at BEGIN time if their body consists of a lexically-scoped scalar which has no other references. Only the first example here will be inlined:</source>
          <target state="translated">앞서 언급했듯이 본문이 다른 참조가없는 어휘 범위 스칼라로 구성된 경우 BEGIN 시간에 인라인 서브를 동적으로 선언 할 수도 있습니다. 여기서 첫 번째 예만 인라인됩니다.</target>
        </trans-unit>
        <trans-unit id="40622c1595c0e7b33c82f810ddadd26599013393" translate="yes" xml:space="preserve">
          <source>As alternatives to &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; when used for control flow, Perl provides the &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; operators (see below). The short-circuit behavior is identical. The precedence of &lt;code&gt;&quot;and&quot;&lt;/code&gt; and &lt;code&gt;&quot;or&quot;&lt;/code&gt; is much lower, however, so that you can safely use them after a list operator without the need for parentheses:</source>
          <target state="translated">&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;||&lt;/code&gt; 의 대안으로 제어 흐름에 사용될 때 Perl은 &lt;code&gt;and&lt;/code&gt; 및 &lt;code&gt;or&lt;/code&gt; 연산자를 제공합니다 (아래 참조). 단락 동작은 동일합니다. 그러나 &lt;code&gt;&quot;and&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;or&quot;&lt;/code&gt; 의 우선 순위 는 훨씬 낮아서 괄호없이 목록 연산자 다음에 안전하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c44b3a4add0c470afd83290fbaea5d47d3bf3bcb" translate="yes" xml:space="preserve">
          <source>As always with Perl there is more than one way to do it. Below are a few examples of approaches to making common conversions between number representations. This is intended to be representational rather than exhaustive.</source>
          <target state="translated">항상 Perl과 마찬가지로 여러 가지 방법이 있습니다. 다음은 숫자 표현간에 일반적인 변환을 수행하는 방법의 몇 가지 예입니다. 이것은 철저하지 않고 표현하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="a27e8bc51d6a9b14b4e2235fdc7ebedf28d134bc" translate="yes" xml:space="preserve">
          <source>As always, if any of these are ever officially declared as bugs, they'll be fixed and removed.</source>
          <target state="translated">언제나 그렇듯이 버그가 공식적으로 버그로 선언되면 수정 및 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="43d8cae7f79fc634e42b4fbb6869d40983003e1e" translate="yes" xml:space="preserve">
          <source>As always, setting up a server is little bit more involved than running a client. The model is that the server creates a special kind of socket that does nothing but listen on a particular port for incoming connections. It does this by calling the &lt;code&gt;IO::Socket::INET-&amp;gt;new()&lt;/code&gt; method with slightly different arguments than the client did.</source>
          <target state="translated">항상 그렇듯이 서버 설정은 클라이언트를 실행하는 것보다 조금 더 복잡합니다. 모델은 서버가 들어오는 연결을 위해 특정 포트에서 수신 대기하는 특수한 종류의 소켓을 작성한다는 것입니다. 클라이언트와 약간 다른 인수로 &lt;code&gt;IO::Socket::INET-&amp;gt;new()&lt;/code&gt; 메소드를 호출하여이를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="90ed318055b1f6119d9ba187aa6944aea5c29dbe" translate="yes" xml:space="preserve">
          <source>As an added convenience, the Digest::SHA module offers routines to calculate keyed hashes using the HMAC-SHA-1/224/256/384/512 algorithms. These services exist in functional form only, and mimic the style and behavior of the</source>
          <target state="translated">편의상 Digest :: SHA 모듈은 HMAC-SHA-1 / 224 / 256 / 384 / 512 알고리즘을 사용하여 키 해시를 계산하는 루틴을 제공합니다. 이러한 서비스는 기능적 형태로만 존재하며 서비스의 스타일과 동작을 모방합니다.</target>
        </trans-unit>
        <trans-unit id="d0e4684ebfef4659c7147a264548f0d1e61303df" translate="yes" xml:space="preserve">
          <source>As an aid in resetting colors, colored() takes a scalar as the first argument and any number of attribute strings as the second argument and returns the scalar wrapped in escape codes so that the attributes will be set as requested before the string and reset to normal after the string. Alternately, you can pass a reference to an array as the first argument, and then the contents of that array will be taken as attributes and color codes and the remainder of the arguments as text to colorize.</source>
          <target state="translated">색상을 재설정하는 데 도움을주기 위해 colored ()는 스칼라를 첫 번째 인수로 사용하고 속성 문자열 수를 두 번째 인수로 사용하고 스칼라를 이스케이프 코드로 래핑하여 속성이 문자열 전에 요청 된대로 설정되어 다음으로 재설정되도록합니다. 문자열 뒤에 정상입니다. 또는 배열에 대한 참조를 첫 번째 인수로 전달한 다음 해당 배열의 내용을 속성 및 색상 코드로, 나머지 인수를 텍스트로 채색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c1670ab0bb7042a354367f8f6979cab460d9b35" translate="yes" xml:space="preserve">
          <source>As an alternative to the above, you may prefer to throw exceptions using the Error module.</source>
          <target state="translated">위의 대안으로 Error 모듈을 사용하여 예외를 발생시키는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="782eb5f652231f0fff9e780cbf2fef47e3527def" translate="yes" xml:space="preserve">
          <source>As an alternative, overloaded constants (see &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt;) provide a simple way to extend the functionality of the RE engine, by substituting one pattern for another.</source>
          <target state="translated">대안으로, 과부하 상수 ( &lt;a href=&quot;overload&quot;&gt;과부하&lt;/a&gt; 참조 )는 하나의 패턴을 다른 패턴으로 대체하여 RE 엔진의 기능을 확장하는 간단한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="18772395363d0e88e55df307a43fbfe2be745eba" translate="yes" xml:space="preserve">
          <source>As an alternative, specify a number instead of list of letters (e.g., &lt;b&gt;-D14&lt;/b&gt; is equivalent to &lt;b&gt;-Dtls&lt;/b&gt;):</source>
          <target state="translated">대안으로, 숫자가 아닌 문자 (예,의 목록을 지정 &lt;b&gt;-D14는&lt;/b&gt; 동일합니다 &lt;b&gt;-Dtls&lt;/b&gt; ) :</target>
        </trans-unit>
        <trans-unit id="8f4ba5d9ceee180216d44c33a248904b28bf93a4" translate="yes" xml:space="preserve">
          <source>As an alternative, to keep the case of the replacement word if it is longer than the original, you can use this code, by Jeff Pinyan:</source>
          <target state="translated">대안으로, 원래 단어보다 긴 대체 단어의 경우를 유지하기 위해 Jeff Pinyan의이 코드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edc86b424441622df9f0c07df7eb59f80cab5da3" translate="yes" xml:space="preserve">
          <source>As an example of something that is caught under &lt;code&gt;&quot;strict'&lt;/code&gt; , but not otherwise, is the pattern</source>
          <target state="translated">&lt;code&gt;&quot;strict'&lt;/code&gt; 잡히지 만 그렇지 않은 패턴의 예는</target>
        </trans-unit>
        <trans-unit id="52b1b17f0c5a778dad149ae64ff9d232a5d6120e" translate="yes" xml:space="preserve">
          <source>As an example of this case, this code prints the message &quot;Perl exited with active threads: 2 running and unjoined&quot;:</source>
          <target state="translated">이 예제의 예로,이 코드는 &quot;Perl exits with active threads : 2 running and unjoined&quot;메시지를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="fd8cd6983452bdbcd828fbbb431f9c0eaf4c793d" translate="yes" xml:space="preserve">
          <source>As an example where a possessive quantifier is suitable we consider matching a quoted string, as it appears in several programming languages. The backslash is used as an escape character that indicates that the next character is to be taken literally, as another character for the string. Therefore, after the opening quote, we expect a (possibly empty) sequence of alternatives: either some character except an unescaped quote or backslash or an escaped character.</source>
          <target state="translated">소유 정량화가 적합한 예로, 여러 프로그래밍 언어로 표시되는 인용 문자열을 일치시키는 것을 고려합니다. 백 슬래시는 이스케이프 문자로 사용되어 다음 문자가 문자 그대로 문자열의 다른 문자로 사용됨을 나타냅니다. 따라서 여는 따옴표 뒤에는 이스케이프 처리되지 않은 따옴표 나 백 슬래시를 제외한 일부 문자 또는 이스케이프 처리 된 문자 중 하나 (대체로 비어 있음)가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="82731324b346859b9bccf9603560116021199d53" translate="yes" xml:space="preserve">
          <source>As an example, when Perl sees &lt;code&gt;$x = &lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(400)&lt;/code&gt; , it encodes the character in UTF-8 and stores it in $x. Then it is marked as character data, so, for instance, &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt; $x&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt; . However, in the scope of the &lt;code&gt;bytes&lt;/code&gt; pragma, $x is treated as a series of bytes - the bytes that make up the UTF8 encoding - and &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt; $x&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt; :</source>
          <target state="translated">예를 들어 Perl이 &lt;code&gt;$x = &lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(400)&lt;/code&gt; 이면 문자를 UTF-8로 인코딩하여 $ x에 저장합니다. 그런 다음 문자 데이터로 표시되므로 예를 들어 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt; $x&lt;/code&gt; 는 &lt;code&gt;1&lt;/code&gt; 을 반환합니다 . 그러나 &lt;code&gt;bytes&lt;/code&gt; pragma 의 범위 에서 $ x는 일련의 바이트 (UTF8 인코딩을 구성하는 바이트)로 취급되며 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt; $x&lt;/code&gt; 는 &lt;code&gt;2&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c313609d4ce2bde8a8cf3d1a920bc018f88eebaa" translate="yes" xml:space="preserve">
          <source>As an interim measure, you may either change the #! line of your scripts to specifically refer to the old perl version, e.g. on Solaris 9 use #!/usr/perl5/5.00503/bin/perl to use the perl version that was the default for Solaris 8, or if you have a large number of scripts it may be more convenient to make the old version of perl the default on your system. You can do this by changing the appropriate symlinks under /usr/perl5 as follows (example for Solaris 9):</source>
          <target state="translated">임시 조치로 #을 변경할 수 있습니다! 예를 들어 Solaris 9의 경우 #! / usr / perl5 / 5.00503 / bin / perl을 사용하여 Solaris 8의 기본값 인 perl 버전을 사용하거나 숫자가 큰 경우 스크립트에서 이전 버전의 perl을 시스템의 기본값으로 설정하는 것이 더 편리 할 수 ​​있습니다. 다음과 같이 / usr / perl5에서 적절한 심볼릭 링크를 변경하면됩니다 (Solaris 9의 예).</target>
        </trans-unit>
        <trans-unit id="373576f861e30b7c81e25bff74bee6e23c15298c" translate="yes" xml:space="preserve">
          <source>As an optimization, may not call the command shell specified in &lt;code&gt;$ENV{PERL5SHELL}&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;(1, @args)&lt;/code&gt; spawns an external process and immediately returns its process designator, without waiting for it to terminate. Return value may be used subsequently in &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt;. Failure to &lt;code&gt;spawn()&lt;/code&gt; a subprocess is indicated by setting &lt;code&gt;$?&lt;/code&gt; to &lt;code&gt;&quot;255 &amp;lt;&amp;lt; 8&quot;&lt;/code&gt; . &lt;code&gt;$?&lt;/code&gt; is set in a way compatible with Unix (i.e. the exitstatus of the subprocess is obtained by &lt;code&gt;&quot;$?&lt;/code&gt; 8&quot;&amp;gt;&amp;gt;, as described in the documentation). (Win32)</source>
          <target state="translated">최적화로서 &lt;code&gt;$ENV{PERL5SHELL}&lt;/code&gt; 지정된 명령 쉘을 호출하지 않을 수 있습니다 . &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;(1, @args)&lt;/code&gt; 는 외부 프로세스를 생성하고 프로세스 지정자가 종료되기를 기다리지 않고 즉시 프로세스 지정자를 반환합니다. 리턴 값은 이후 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; 에서 사용될 수 있습니다 . 하위 프로세스 &lt;code&gt;spawn()&lt;/code&gt; 실패 는 &lt;code&gt;$?&lt;/code&gt; 를 설정하여 표시됩니다 . 행 &lt;code&gt;&quot;255 &amp;lt;&amp;lt; 8&quot;&lt;/code&gt; . &lt;code&gt;$?&lt;/code&gt; 는 Unix와 호환되는 방식으로 설정됩니다 (즉, 하위 프로세스의 종료 상태는 설명서에 설명 된대로 &lt;code&gt;&quot;$?&lt;/code&gt; 8&quot;&amp;gt;&amp;gt; 로 얻습니다 ). (Win32)</target>
        </trans-unit>
        <trans-unit id="38474bdd192558dcfa688dfaf6e45817a6f595ea" translate="yes" xml:space="preserve">
          <source>As another special case, &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; emulates the default behavior of the command line tool &lt;b&gt;awk&lt;/b&gt; when the PATTERN is either omitted or a</source>
          <target state="translated">또 다른 특별한 경우로, &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 은 PATTERN이 생략되거나 a 일 때 명령 행 도구 &lt;b&gt;awk&lt;/b&gt; 의 기본 동작을 에뮬레이트합니다</target>
        </trans-unit>
        <trans-unit id="aab9f2eadc04a37e669ffc31217a1ec91df2a94d" translate="yes" xml:space="preserve">
          <source>As another special case, &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; emulates the default behavior of the command line tool &lt;b&gt;awk&lt;/b&gt; when the PATTERN is either omitted or a</source>
          <target state="translated">또 다른 특별한 경우로, &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 은 PATTERN이 생략되거나 a 일 때 명령 행 도구 &lt;b&gt;awk&lt;/b&gt; 의 기본 동작을 에뮬레이트합니다</target>
        </trans-unit>
        <trans-unit id="46ab5c6135652ee2c4d494e00004b3edd1c35481" translate="yes" xml:space="preserve">
          <source>As another workaround for this problem, Perl 5.10.0 introduced &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; , which are equivalent to &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt; , &lt;b&gt;except&lt;/b&gt; that they are only guaranteed to be defined after a successful match that was executed with the &lt;code&gt;/p&lt;/code&gt; (preserve) modifier. The use of these variables incurs no global performance penalty, unlike their punctuation char equivalents, however at the trade-off that you have to tell perl when you want to use them. As of Perl 5.20, these three variables are equivalent to &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt; , and &lt;code&gt;/p&lt;/code&gt; is ignored.</source>
          <target state="translated">이 문제에 대한 또 다른 해결 방법으로 Perl 5.10.0은 &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; 및 &lt;code&gt;${^POSTMATCH}&lt;/code&gt; . 이는 &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; 및 &lt;code&gt;$'&lt;/code&gt; 와 &lt;b&gt;동일&lt;/b&gt; 합니다. &lt;code&gt;/p&lt;/code&gt; (preserve) 수정 자로 실행 된 성공적인 일치 후에 정의됩니다 . 이러한 변수를 사용하면 구두점 문자와 달리 전역 성능 저하가 발생하지 않지만 펄을 사용할 때는 펄에게 알려야합니다. Perl 5.20부터이 세 변수는 &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; 및 &lt;code&gt;$'&lt;/code&gt; 및 &lt;code&gt;/p&lt;/code&gt; 와 같습니다. 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="faf1880e6e4e5e1670571e23b070295ae744c1fc" translate="yes" xml:space="preserve">
          <source>As described &lt;a href=&quot;#Calling-Conventions-and-Magic-Autogeneration&quot;&gt;above&lt;/a&gt;, Perl may call methods for operators like &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;&amp;amp;&lt;/code&gt; in the course of implementing missing operations like &lt;code&gt;++&lt;/code&gt; , &lt;code&gt;+=&lt;/code&gt; , and &lt;code&gt;&amp;amp;=&lt;/code&gt; . While these methods may detect this usage by testing the definedness of the third argument, they should in all cases avoid changing their operands. This is because Perl does not call the copy constructor before invoking these methods.</source>
          <target state="translated">&lt;a href=&quot;#Calling-Conventions-and-Magic-Autogeneration&quot;&gt;위에서&lt;/a&gt; 설명한 것처럼 Perl은 &lt;code&gt;++&lt;/code&gt; , &lt;code&gt;+=&lt;/code&gt; 및 &lt;code&gt;&amp;amp;=&lt;/code&gt; 와 같은 누락 된 작업을 구현하는 과정에서 &lt;code&gt;+&lt;/code&gt; 및 &lt;code&gt;&amp;amp;&lt;/code&gt; 와 같은 연산자에 대한 메서드를 호출 할 수 있습니다 . 이러한 메소드는 세 번째 인수의 정의를 테스트하여이 사용법을 감지 할 수 있지만 모든 경우 피연산자를 변경하지 않아야합니다. Perl은 이러한 메소드를 호출하기 전에 복사 생성자를 호출하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="6ff132deadaac51720c9e117548f044618ad0a39" translate="yes" xml:space="preserve">
          <source>As discussed elsewhere, Perl has one foot (two hooves?) planted in each of two worlds: the old world of ASCII and single-byte locales, and the new world of Unicode, upgrading when necessary. If your legacy code does not explicitly use Unicode, no automatic switch-over to Unicode should happen.</source>
          <target state="translated">다른 곳에서 논의한 바와 같이, Perl은 두 세계 각각에 1 피트 (2 발굽)를 심었습니다. 구세계 ASCII와 1 바이트 로케일, 그리고 새로운 유니 코드 세계는 필요할 때 업그레이드합니다. 레거시 코드에서 명시 적으로 유니 코드를 사용하지 않으면 유니 코드로 자동 전환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3a28f6e945d7b1d8cd9440551fcd17f03dc59837" translate="yes" xml:space="preserve">
          <source>As explained above, an anonymous function with access to the lexical variables visible when that function was compiled, creates a closure. It retains access to those variables even though it doesn't get run until later, such as in a signal handler or a Tk callback.</source>
          <target state="translated">위에서 설명한 것처럼 함수를 컴파일 할 때 표시되는 어휘 변수에 액세스 할 수있는 익명 함수는 클로저를 만듭니다. 신호 처리기 또는 Tk 콜백과 같이 나중에 실행될 때에도 해당 변수에 대한 액세스 권한을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="de6278f8e877d258b1f62760a70228a073ba24fd" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;#ASCII-Rules-versus-Unicode-Rules&quot;&gt;ASCII Rules versus Unicode Rules&lt;/a&gt;, under ASCII rules, they are considered to be unassigned characters.</source>
          <target state="translated">&lt;a href=&quot;#ASCII-Rules-versus-Unicode-Rules&quot;&gt;ASCII 규칙과 유니 코드 규칙에&lt;/a&gt; 설명 된대로 ASCII 규칙에서 할당되지 않은 문자로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="8ffaa22d40c8f644f2c59a68a07b28bdf08a1f8a" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;#prop_invlist()&quot;&gt;prop_invlist()&lt;/a&gt;, whether a code point is in the list or not depends on if the index is even (in) or odd (not in). And as explained in &lt;a href=&quot;#prop_invmap()&quot;&gt;prop_invmap()&lt;/a&gt;, the index is used with the returned parallel array to find the mapping.</source>
          <target state="translated">&lt;a href=&quot;#prop_invlist()&quot;&gt;prop_invlist ()&lt;/a&gt; 에서 설명한 것처럼 코드 포인트가 목록에 있는지 여부는 인덱스가 짝수인지 (인지) 아니면 홀수인지 ( 인지 ) 인지에 따라 다릅니다. &lt;a href=&quot;#prop_invmap()&quot;&gt;prop_invmap ()&lt;/a&gt; 에서 설명한 것처럼 인덱스는 반환 된 병렬 배열과 함께 사용되어 매핑을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="c53e475afb32fdd8296f1c9a917ef2e75b376078" translate="yes" xml:space="preserve">
          <source>As for other operations, the subroutine implementing '=' is passed three arguments, though the last two are always &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;''&lt;/code&gt; .</source>
          <target state="translated">다른 연산의 경우 '='를 구현하는 서브 루틴에는 세 개의 인수가 전달되지만 마지막 두 개는 항상 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;''&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2f54bd3297d1b4b8911e3de6ffd9e1ee35795e3c" translate="yes" xml:space="preserve">
          <source>As if all those classes weren't enough, Perl also defines POSIX-style character classes. These have the form &lt;code&gt;[:name:]&lt;/code&gt;, with &lt;code&gt;name&lt;/code&gt; the name of the POSIX class. The POSIX classes are &lt;code&gt;alpha&lt;/code&gt; , &lt;code&gt;alnum&lt;/code&gt; , &lt;code&gt;ascii&lt;/code&gt; , &lt;code&gt;cntrl&lt;/code&gt; , &lt;code&gt;digit&lt;/code&gt; , &lt;code&gt;graph&lt;/code&gt; , &lt;code&gt;lower&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;punct&lt;/code&gt; , &lt;code&gt;space&lt;/code&gt; , &lt;code&gt;upper&lt;/code&gt; , and &lt;code&gt;xdigit&lt;/code&gt; , and two extensions, &lt;code&gt;word&lt;/code&gt; (a Perl extension to match &lt;code&gt;\w&lt;/code&gt; ), and &lt;code&gt;blank&lt;/code&gt; (a GNU extension). The &lt;code&gt;//a&lt;/code&gt; modifier restricts these to matching just in the ASCII range; otherwise they can match the same as their corresponding Perl Unicode classes: &lt;code&gt;[:upper:]&lt;/code&gt; is the same as &lt;code&gt;\p{IsUpper}&lt;/code&gt; , etc. (There are some exceptions and gotchas with this; see &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt; for a full discussion.) The &lt;code&gt;[:digit:]&lt;/code&gt;, &lt;code&gt;[:word:]&lt;/code&gt;, and &lt;code&gt;[:space:]&lt;/code&gt; correspond to the familiar &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; , and &lt;code&gt;\s&lt;/code&gt; character classes. To negate a POSIX class, put a &lt;code&gt;^&lt;/code&gt; in front of the name, so that, e.g., &lt;code&gt;[:^digit:]&lt;/code&gt; corresponds to &lt;code&gt;\D&lt;/code&gt; and, under Unicode, &lt;code&gt;\P{IsDigit}&lt;/code&gt; . The Unicode and POSIX character classes can be used just like &lt;code&gt;\d&lt;/code&gt; , with the exception that POSIX character classes can only be used inside of a character class:</source>
          <target state="translated">모든 클래스가 충분하지 않은 것처럼 Perl은 POSIX 스타일 문자 클래스도 정의합니다. 이러한 형태가 &lt;code&gt;[:name:]&lt;/code&gt; 함께 &lt;code&gt;name&lt;/code&gt; 는 POSIX 클래스의 이름을. POSIX 클래스는 &lt;code&gt;alpha&lt;/code&gt; , &lt;code&gt;alnum&lt;/code&gt; , &lt;code&gt;ascii&lt;/code&gt; , &lt;code&gt;cntrl&lt;/code&gt; , &lt;code&gt;digit&lt;/code&gt; , &lt;code&gt;graph&lt;/code&gt; , &lt;code&gt;lower&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;punct&lt;/code&gt; , &lt;code&gt;space&lt;/code&gt; , &lt;code&gt;upper&lt;/code&gt; , &lt;code&gt;xdigit&lt;/code&gt; , 두 개의 확장자, &lt;code&gt;word&lt;/code&gt; ( &lt;code&gt;\w&lt;/code&gt; 와 일치하는 Perl 확장자 ) 및 &lt;code&gt;blank&lt;/code&gt; (GNU 확장자)입니다. ). &lt;code&gt;//a&lt;/code&gt; 를수정자는 ASCII 범위에서만 일치하도록 제한합니다. 그렇지 않으면 그에 상응하는 펄 유니 코드 클래스와 동일하게 일치시킬 수 있습니다 : &lt;code&gt;[:upper:]&lt;/code&gt; 과 동일 &lt;code&gt;\p{IsUpper}&lt;/code&gt; 등 (이 일부 예외 망 가지고있다; 참조 &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass을&lt;/a&gt; 상세 논의하십시오.) &lt;code&gt;[:digit:]&lt;/code&gt; , &lt;code&gt;[:word:]&lt;/code&gt; 및 &lt;code&gt;[:space:]&lt;/code&gt; 는 익숙한 &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; 및 &lt;code&gt;\s&lt;/code&gt; 문자 클래스에 해당합니다. POSIX 클래스를 무효화하려면 이름 앞에 &lt;code&gt;^&lt;/code&gt; 를 넣으십시오. 예를 들어 &lt;code&gt;[:^digit:]&lt;/code&gt; 는 &lt;code&gt;\D&lt;/code&gt; 해당하고 유니 코드에서는 &lt;code&gt;\P{IsDigit}&lt;/code&gt; . POSIX 문자 클래스는 문자 클래스 내에서만 사용할 수 있다는 점을 제외하고는 &lt;code&gt;\d&lt;/code&gt; 와 마찬가지로 유니 코드 및 POSIX 문자 클래스를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="460ff6781c9a7b0d42e2f096c304dc01b5296e55" translate="yes" xml:space="preserve">
          <source>As implied above, the environment accessed through &lt;code&gt;%ENV&lt;/code&gt; is global, and the convention is that program specific environment variables are of the form &lt;code&gt;Program$Name&lt;/code&gt; . Each filesystem maintains a current directory, and the current filesystem's current directory is the &lt;b&gt;global&lt;/b&gt; current directory. Consequently, sociable programs don't change the current directory but rely on full pathnames, and programs (and Makefiles) cannot assume that they can spawn a child process which can change the current directory without affecting its parent (and everyone else for that matter).</source>
          <target state="translated">위에서 알 수 있듯이 &lt;code&gt;%ENV&lt;/code&gt; 통해 액세스되는 환경 은 전역 적이며, 프로그램 별 환경 변수는 &lt;code&gt;Program$Name&lt;/code&gt; 형식 입니다. 각 파일 시스템은 현재 디렉토리를 유지 관리하며 현재 파일 시스템의 현재 디렉토리는 &lt;b&gt;전역&lt;/b&gt; 현재 디렉토리입니다. 결과적으로 사교적 인 프로그램은 현재 디렉토리를 변경하지 않고 전체 경로 이름에 의존하며 프로그램 (및 Makefiles)은 부모 (및 그 문제에 대한 다른 모든 사람)에게 영향을 미치지 않고 현재 디렉토리를 변경할 수있는 자식 프로세스를 생성 할 수 있다고 가정 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="9cfe8ec9bce67c19def3a159ea6c0eb1d6dbe31c" translate="yes" xml:space="preserve">
          <source>As in some shells, you can enclose the variable name in braces to disambiguate it from following alphanumerics (and underscores). You must also do this when interpolating a variable into a string to separate the variable name from a following double-colon or an apostrophe, since these would be otherwise treated as a package separator:</source>
          <target state="translated">일부 셸에서와 같이 변수 이름을 중괄호로 묶어 다음의 영숫자 (및 밑줄)를 명확히 할 수 있습니다. 변수를 문자열로 보간 할 때 변수 이름을 다음 이중 콜론 또는 아포스트로피와 구분하기 위해이를 수행해야합니다. 패키지 구분 기호로 처리되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="f260d12b5b1b7a497f5733dde8f966ff0dea7a60" translate="yes" xml:space="preserve">
          <source>As it stands it predates version.pm but has the same goal: make version strings visible and comparable.</source>
          <target state="translated">그것은 그대로 version.pm 이전이지만 동일한 목표를 가지고 있습니다 : 버전 문자열을 보이고 비교할 수있게하십시오.</target>
        </trans-unit>
        <trans-unit id="e22bdaf7af0b55a0257fbf249cc6b2acfdfc9220" translate="yes" xml:space="preserve">
          <source>As its name suggests, if your code tripped a mandatory warning, you would get a warning whether you wanted it or not. For example, the code below would always produce an &lt;code&gt;&quot;isn't numeric&quot;&lt;/code&gt; warning about the &quot;2:&quot;.</source>
          <target state="translated">이름에서 알 수 있듯이 코드에서 필수 경고가 발생하면 원하는지 여부에 관계없이 경고가 표시됩니다. 예를 들어 아래 코드는 항상 &quot;2 :&quot;에 대한 &quot; &lt;code&gt;&quot;isn't numeric&quot;&lt;/code&gt; 경고를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="299f8da88c7d33c41fa9b9da7b25493959ed6b3c" translate="yes" xml:space="preserve">
          <source>As just mentioned, all variables are, by default, thread local. To use shared variables, you need to also load &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt;:</source>
          <target state="translated">방금 언급했듯이 모든 변수는 기본적으로 스레드 로컬입니다. 공유 변수를 사용하려면 &lt;a href=&quot;threads/shared&quot;&gt;threads :: shared도로드&lt;/a&gt; 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1b2545d2ff62a227583262bedb22954e6e8e3fc3" translate="yes" xml:space="preserve">
          <source>As locks are advisory, they do not prevent data access or modification by another thread that does not itself attempt to obtain a lock on the variable.</source>
          <target state="translated">잠금은 권고이므로 변수에 대한 잠금을 얻으려고 시도하지 않는 다른 스레드에 의한 데이터 액세스 또는 수정을 방해하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="81ff74ffe73c98f024294d6b4b3ccdb104adb917" translate="yes" xml:space="preserve">
          <source>As long as all documents processed result in some output, even if that output includes errata (a &lt;code&gt;POD ERRORS&lt;/code&gt; section generated with &lt;code&gt;--errors=pod&lt;/code&gt; ), &lt;b&gt;pod2man&lt;/b&gt; will exit with status 0. If any of the documents being processed do not result in an output document, &lt;b&gt;pod2man&lt;/b&gt; will exit with status 1. If there are syntax errors in a POD document being processed and the error handling style is set to the default of &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, &lt;b&gt;pod2man&lt;/b&gt; will abort immediately with exit status 255.</source>
          <target state="translated">처리 된 모든 문서가 일부 출력을 생성하는 한, 해당 출력에 에라타 ( &lt;code&gt;--errors=pod&lt;/code&gt; 로 생성 된 &lt;code&gt;POD ERRORS&lt;/code&gt; 섹션 )가 포함되어 &lt;b&gt;있어도 pod2man&lt;/b&gt; 은 상태 0으로 종료됩니다. 처리중인 문서가 없으면 출력 문서에서 &lt;b&gt;pod2man&lt;/b&gt; 은 상태 1로 종료됩니다. 처리중인 POD 문서에 구문 오류가 있고 오류 처리 스타일이 기본값 인 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 로 &lt;b&gt;설정된&lt;/b&gt; 경우 &lt;b&gt;pod2man&lt;/b&gt; 은 종료 상태 255로 즉시 중단됩니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="00a3a680bcee6a61521d2a5ef5058ff99a76856b" translate="yes" xml:space="preserve">
          <source>As long as all documents processed result in some output, even if that output includes errata (a &lt;code&gt;POD ERRORS&lt;/code&gt; section generated with &lt;code&gt;--errors=pod&lt;/code&gt; ), &lt;b&gt;pod2text&lt;/b&gt; will exit with status 0. If any of the documents being processed do not result in an output document, &lt;b&gt;pod2text&lt;/b&gt; will exit with status 1. If there are syntax errors in a POD document being processed and the error handling style is set to the default of &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, &lt;b&gt;pod2text&lt;/b&gt; will abort immediately with exit status 255.</source>
          <target state="translated">처리 된 모든 문서가 일부 출력을 생성 하는 한 해당 출력에 정오표 ( &lt;code&gt;--errors=pod&lt;/code&gt; 로 생성 된 &lt;code&gt;POD ERRORS&lt;/code&gt; 섹션 )가 포함되어 &lt;b&gt;있어도 pod2text&lt;/b&gt; 는 상태 0으로 종료됩니다. 처리중인 문서 중 하나라도 출력 문서, &lt;b&gt;pod2text&lt;/b&gt; 는 상태 1로 종료됩니다. 처리중인 POD 문서에 구문 오류가 있고 오류 처리 스타일이 기본값 인 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 로 설정 되면 &lt;b&gt;pod2text&lt;/b&gt; 는 종료 상태 255로 즉시 중단됩니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="95c1aea5304f4de3806c6769617146a8ffc159e5" translate="yes" xml:space="preserve">
          <source>As long as the reference is never returned by any function within the module, no outside module can see the subroutine, because its name is not in any package's symbol table. Remember that it's not</source>
          <target state="translated">참조가 모듈 내의 함수에 의해 리턴되지 않는 한, 외부 모듈은 이름이 패키지의 기호 테이블에 없기 때문에 서브 루틴을 볼 수 없습니다. 그렇지 않다는 것을 기억하십시오</target>
        </trans-unit>
        <trans-unit id="958bb5f65d2f4962aaa4f5dd2b31857927db841a" translate="yes" xml:space="preserve">
          <source>As mentioned &lt;a href=&quot;#Mathemagic%2c-Mutators%2c-and-Copy-Constructors&quot;&gt;above&lt;/a&gt;, this operation is called when a mutator is applied to a reference that shares its object with some other reference. For example, if &lt;code&gt;$b&lt;/code&gt; is mathemagical, and &lt;code&gt;'++'&lt;/code&gt; is overloaded with &lt;code&gt;'incr'&lt;/code&gt; , and &lt;code&gt;'='&lt;/code&gt; is overloaded with &lt;code&gt;'clone'&lt;/code&gt; , then the code</source>
          <target state="translated">언급 한 바와 같이 &lt;a href=&quot;#Mathemagic%2c-Mutators%2c-and-Copy-Constructors&quot;&gt;전술 한&lt;/a&gt; , 이러한 동작들은 테이터는 기준에인가 될 때 다른 호출을 참조하여 주 그 목적이.되고 예를 들어 &lt;code&gt;$b&lt;/code&gt; 가 mathemagical이고 &lt;code&gt;'++'&lt;/code&gt; 에 &lt;code&gt;'incr'&lt;/code&gt; 으로 과부하 되고 &lt;code&gt;'='&lt;/code&gt; 에 &lt;code&gt;'clone'&lt;/code&gt; 으로 과부하 된 경우 코드</target>
        </trans-unit>
        <trans-unit id="6db309618dd0587d20027a36c5759130977518d4" translate="yes" xml:space="preserve">
          <source>As mentioned above under &lt;a href=&quot;#ALIASES&quot;&gt;ALIASES&lt;/a&gt;, Unicode 6.1 defines extra names (synonyms or aliases) for some code points, most of which were already available as Perl extensions. All these are accepted by &lt;code&gt;\N{...}&lt;/code&gt; and the other functions in this module, but &lt;code&gt;viacode&lt;/code&gt; has to choose which one name to return for a given input code point, so it returns the &quot;best&quot; name. To understand how this works, it is helpful to know more about the Unicode name properties. All code points actually have only a single name, which (starting in Unicode 2.0) can never change once a character has been assigned to the code point. But mistakes have been made in assigning names, for example sometimes a clerical error was made during the publishing of the Standard which caused words to be misspelled, and there was no way to correct those. The Name_Alias property was eventually created to handle these situations. If a name was wrong, a corrected synonym would be published for it, using Name_Alias. &lt;code&gt;viacode&lt;/code&gt; will return that corrected synonym as the &quot;best&quot; name for a code point. (It is even possible, though it hasn't happened yet, that the correction itself will need to be corrected, and so another Name_Alias can be created for that code point; &lt;code&gt;viacode&lt;/code&gt; will return the most recent correction.)</source>
          <target state="translated">위에서 &lt;a href=&quot;#ALIASES&quot;&gt;ALIASES&lt;/a&gt; 에서 언급 한 바와 같이 , 유니 코드 6.1은 일부 코드 포인트에 대한 추가 이름 (동의어 또는 별명)을 정의하며 대부분은 이미 Perl 확장으로 사용 가능합니다. 이러한 모든 허용됩니다 &lt;code&gt;\N{...}&lt;/code&gt; 이 모듈의 다른 기능을하지만, &lt;code&gt;viacode&lt;/code&gt; 주어진 입력 코드 포인트에 대해 리턴 할 이름을 선택해야하므로 &quot;최상의&quot;이름을 리턴합니다. 이것이 어떻게 작동하는지 이해하려면 유니 코드 이름 속성에 대해 더 많이 아는 것이 도움이됩니다. 모든 코드 포인트는 실제로 단일 이름 만 가지며, 유니 코드 2.0으로 시작하면 코드 포인트에 문자가 할당 된 후에는 절대로 변경할 수 없습니다. 그러나 이름 지정에 실수가 있었다. 예를 들어, 표준을 출판하는 동안 사무 오류가 발생하여 단어의 철자가 틀 렸으며,이를 수정할 방법이 없었습니다. 이러한 상황을 처리하기 위해 Name_Alias ​​속성이 결국 만들어졌습니다. 이름이 잘못되면 Name_Alias를 사용하여 올바른 동의어가 게시됩니다. &lt;code&gt;viacode&lt;/code&gt; 수정 된 동의어를 코드 포인트의 &quot;최상의&quot;이름으로 반환합니다. (아직 발생하지는 않았지만 수정 자체를 수정해야 할 수 있으므로 해당 코드 포인트에 대해 다른 Name_Alias를 만들 수 있습니다. &lt;code&gt;viacode&lt;/code&gt; 코드 는 가장 최근의 수정을 반환합니다.)</target>
        </trans-unit>
        <trans-unit id="aa5ef151af9bb6073935edbcfff85b0147b33678" translate="yes" xml:space="preserve">
          <source>As mentioned above, UTF-8 uses a variable number of bytes to store a character. Characters with values 0...127 are stored in one byte, just like good ol' ASCII. Character 128 is stored as &lt;code&gt;v194.128&lt;/code&gt; ; this continues up to character 191, which is &lt;code&gt;v194.191&lt;/code&gt; . Now we've run out of bits (191 is binary &lt;code&gt;10111111&lt;/code&gt; ) so we move on; character 192 is &lt;code&gt;v195.128&lt;/code&gt; . And so it goes on, moving to three bytes at character 2048. &lt;a href=&quot;perlunicode#Unicode-Encodings&quot;&gt;Unicode Encodings in perlunicode&lt;/a&gt; has pictures of how this works.</source>
          <target state="translated">위에서 언급했듯이 UTF-8은 가변 바이트 수를 사용하여 문자를 저장합니다. 값이 0 ... 127 인 문자는 좋은 ol 'ASCII처럼 1 바이트에 저장됩니다. 문자 128은 &lt;code&gt;v194.128&lt;/code&gt; 로 저장됩니다 . 이것은 문자 191 ( &lt;code&gt;v194.191&lt;/code&gt; ) 까지 계속됩니다 . 이제 비트가 부족합니다 (191은 이진수 &lt;code&gt;10111111&lt;/code&gt; 입니다 ). 문자 192는 &lt;code&gt;v195.128&lt;/code&gt; 입니다. 따라서 문자 2048에서 3 바이트로 이동합니다. &lt;a href=&quot;perlunicode#Unicode-Encodings&quot;&gt;perlunicode의 유니 코드 인코딩에는 이것이&lt;/a&gt; 어떻게 작동하는지에 대한 그림이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b80f86706a5e778489f2084a741a86389a8e67cd" translate="yes" xml:space="preserve">
          <source>As mentioned above, you can determine the context of the currently executing subroutine in Perl with</source>
          <target state="translated">위에서 언급했듯이 Perl에서 현재 실행중인 서브 루틴의 컨텍스트를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00501a67a82ec0513abc29055abfbad02a55f669" translate="yes" xml:space="preserve">
          <source>As mentioned at the top of this document, if you are having problems with these example extensions, you might see if any of these help you.</source>
          <target state="translated">이 문서의 맨 위에 언급 된 것처럼 이러한 확장 예제에 문제가있는 경우 이러한 확장이 도움이되는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2746f2e141da00d82feca97a110b834cca59fd6d" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, Perl can store a number in any one of three formats, but most operators typically understand only one of those formats. When a numeric value is passed as an argument to such an operator, it will be converted to the format understood by the operator.</source>
          <target state="translated">앞에서 언급했듯이 Perl은 세 가지 형식 중 하나로 숫자를 저장할 수 있지만 대부분의 연산자는 일반적으로 해당 형식 중 하나만 이해합니다. 이러한 연산자에 인수로 숫자 값을 전달하면 연산자가 이해하는 형식으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="77154bb24a38474664192f3ea13c3d83da99f57f" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, a &quot;callback&quot; key may be added to the &lt;code&gt;TAP::Parser&lt;/code&gt; constructor. If present, each callback corresponding to a given result type will be called with the result as the argument if the &lt;code&gt;run&lt;/code&gt; method is used. The callback is expected to be a subroutine reference (or anonymous subroutine) which is invoked with the parser result as its argument.</source>
          <target state="translated">앞에서 언급했듯이 &quot;콜백&quot;키가 &lt;code&gt;TAP::Parser&lt;/code&gt; 생성자에 추가 될 수 있습니다 . 존재하는 경우, 주어진 메소드 유형에 해당하는 각 콜백은 &lt;code&gt;run&lt;/code&gt; 메소드가 사용되는 경우 결과를 인수로 사용하여 호출 됩니다. 콜백은 파서 결과를 인수로 사용하여 호출되는 서브 루틴 참조 (또는 익명 서브 루틴) 여야합니다.</target>
        </trans-unit>
        <trans-unit id="4ebe40c302b03d332e451ead97b5b34c4f2894b9" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, in the case of the default engines, the &lt;code&gt;pprivate&lt;/code&gt; will be a pointer to a regexp_internal structure which holds the compiled program and any additional data that is private to the regex engine implementation.</source>
          <target state="translated">앞에서 언급했듯이 기본 엔진의 경우 &lt;code&gt;pprivate&lt;/code&gt; 는 컴파일 된 프로그램과 정규식 엔진 구현 전용 인 추가 데이터를 보유하는 regexp_internal 구조에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="05bef95fb25bb75da2eac006c647172d0c563725" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt;, encodings are (in the current implementation at least) defined as objects. The mapping of encoding name to object is via the &lt;code&gt;%Encode::Encoding&lt;/code&gt; hash. Though you can directly manipulate this hash, it is strongly encouraged to use this base class module and add encode() and decode() methods.</source>
          <target state="translated">&lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt; 에서 언급했듯이 인코딩은 (적어도 현재 구현에서는) 객체로 정의됩니다. 인코딩 이름과 객체의 매핑은 &lt;code&gt;%Encode::Encoding&lt;/code&gt; 해시를 통해 이루어집니다. 이 해시를 직접 조작 할 수 있지만이 기본 클래스 모듈을 사용하고 encode () 및 decode () 메소드를 추가하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="83fbfdaddc2272e65e0714e5d0f69ab35b42f974" translate="yes" xml:space="preserve">
          <source>As mentioned in the previous item, this still doesn't work when using socket I/O between Unix and Macintosh. You'll need to hard code your line terminators, in that case.</source>
          <target state="translated">이전 항목에서 언급했듯이 Unix와 Macintosh간에 소켓 I / O를 사용할 때는 여전히 작동하지 않습니다. 이 경우 줄 종결자를 하드 코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="ed52abb82f45ac71a451aad1bb7530a654fe2ad3" translate="yes" xml:space="preserve">
          <source>As mentioned previously, dynamic loading isn't currently available nor is MakeMaker. Both are high-priority items.</source>
          <target state="translated">앞에서 언급했듯이 동적 로딩은 현재 사용할 수 없으며 MakeMaker도 아닙니다. 둘 다 우선 순위가 높은 항목입니다.</target>
        </trans-unit>
        <trans-unit id="9fbc47f4ab04b1b192086c459c88acf77887350f" translate="yes" xml:space="preserve">
          <source>As mentioned, the function returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if no name is known for the code point. In Unicode the proper name for these is the empty string, which &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; stringifies to. (If you ask for a code point past the legal Unicode maximum of U+10FFFF that you haven't assigned an alias to, you get &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; plus a warning.)</source>
          <target state="translated">언급 한 바와 같이, 함수는 코드 포인트에 대한 이름이 알려지지 않은 경우 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 리턴 합니다. 유니 코드에서 이것들에 대한 올바른 이름은 빈 문자열이며, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 는 문자열 입니다. 별칭을 할당하지 않은 유효한 유니 코드 최대 U + 10FFFF를 초과하는 코드 포인트를 요청하면 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 와 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="651eca43c6e2d73bc740fcae1016d17e36d82316" translate="yes" xml:space="preserve">
          <source>As most of the remaining expected output to the error stream will be created by &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt;'s &lt;code&gt;diag&lt;/code&gt; function, &lt;a href=&quot;tester&quot;&gt;Test::Builder::Tester&lt;/a&gt; provides a convenience function &lt;code&gt;test_diag&lt;/code&gt; that you can use instead of &lt;code&gt;test_err&lt;/code&gt; .</source>
          <target state="translated">오류 스트림에 남아있는 예상 출력의 대부분에 의해 생성 될 수있는 바와 같이 &lt;a href=&quot;../builder&quot;&gt;테스트 :: 빌더&lt;/a&gt; 의 &lt;code&gt;diag&lt;/code&gt; 기능, &lt;a href=&quot;tester&quot;&gt;테스트 :: 빌더 :: 테스터는&lt;/a&gt; 편리한 기능을 제공합니다 &lt;code&gt;test_diag&lt;/code&gt; 당신이 대신 사용할 수있는 &lt;code&gt;test_err&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="a3938aef953ff6d9fa864efd013ef275f9aaeca4" translate="yes" xml:space="preserve">
          <source>As noted above, if the file does not already exist, then the append-mode open will create it for you. But if the file does already exist, its contents are safe from harm because you will be adding your new text past the end of the old text.</source>
          <target state="translated">위에서 언급했듯이 파일이 존재하지 않으면 추가 모드가 열려 파일을 생성합니다. 그러나 파일이 이미 존재하면 이전 텍스트의 끝을지나 새 텍스트를 추가하기 때문에 파일 내용이 손상되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aa50c7a75f631655fc7d60c7b218e502c8aba3fb" translate="yes" xml:space="preserve">
          <source>As noted earlier in this document, the scalar sense of list assignment is the number of elements on the right-hand side of the assignment. The null list contains no elements, so when the password file is exhausted, the result is 0, not 2.</source>
          <target state="translated">이 문서의 앞부분에서 언급했듯이 스칼라 목록 할당 감각은 할당 오른쪽의 요소 수입니다. 널리스트에는 요소가 없으므로 암호 파일이 소진되면 결과는 2가 아니라 0입니다.</target>
        </trans-unit>
        <trans-unit id="c32dd8a34a2658e1d2e1869aeb4cec0307b6493f" translate="yes" xml:space="preserve">
          <source>As noted in &lt;a href=&quot;#USING-LOCALES&quot;&gt;USING LOCALES&lt;/a&gt;, &lt;code&gt;cmp&lt;/code&gt; compares according to the current collation locale when &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect, but falls back to a char-by-char comparison for strings that the locale says are equal. You can use &lt;code&gt;POSIX::strcoll()&lt;/code&gt; if you don't want this fall-back:</source>
          <target state="translated">에 명시된 바와 같이 &lt;a href=&quot;#USING-LOCALES&quot;&gt;로케일을 사용&lt;/a&gt; , &lt;code&gt;cmp&lt;/code&gt; 때 현재 대조 지역에 따라 비교하여 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 유효하지만, 로케일 동일 말한다 위로 스트링에 대한 문자 별 문자에 비해 떨어진다. 이 폴백을 원하지 않으면 &lt;code&gt;POSIX::strcoll()&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eda06429df1073940e96ea523060e042021aeec8" translate="yes" xml:space="preserve">
          <source>As noted in &lt;a href=&quot;perlhack#TESTING&quot;&gt;TESTING in perlhack&lt;/a&gt;, when writing test scripts, the file</source>
          <target state="translated">&lt;a href=&quot;perlhack#TESTING&quot;&gt;perlhack의 테스트에서&lt;/a&gt; 언급했듯이 테스트 스크립트를 작성할 때 파일</target>
        </trans-unit>
        <trans-unit id="716cc3d3aff35fc6629ccc256677b64774af14df" translate="yes" xml:space="preserve">
          <source>As of 1.37_02 install() supports the use of a list of patterns to filter out files that shouldn't be installed. If $skip is omitted or undefined then install will try to read the list from INSTALL.SKIP in the CWD. This file is a list of regular expressions and is just like the MANIFEST.SKIP file used by &lt;a href=&quot;manifest&quot;&gt;ExtUtils::Manifest&lt;/a&gt;.</source>
          <target state="translated">1.37_02부터 install ()은 설치하지 않아야하는 파일을 필터링하기 위해 패턴 목록 사용을 지원합니다. $ skip이 생략되거나 정의되지 않은 경우 install은 CWD의 INSTALL.SKIP에서 목록을 읽으려고 시도합니다. 이 파일은 정규식 목록이며 &lt;a href=&quot;manifest&quot;&gt;ExtUtils :: Manifest에서&lt;/a&gt; 사용하는 MANIFEST.SKIP 파일과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="0f828a6d861469c7d75db52b836c69689c1760b7" translate="yes" xml:space="preserve">
          <source>As of 3.10, the internal data for all types of codes can be modified.</source>
          <target state="translated">3.10부터 모든 유형의 코드에 대한 내부 데이터를 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d399ef50aa4f86fbc538d8e5d435b672ada57b9" translate="yes" xml:space="preserve">
          <source>As of 5.14, none of these raises an exception if they are not supported on your platform. However, if warnings are enabled, a warning of the &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; warning class is issued on an unsupported conversion flag. Should you instead prefer an exception, do this:</source>
          <target state="translated">5.14부터는 플랫폼에서 지원되지 않는 경우 예외가 발생하지 않습니다. 그러나 경고가 사용 가능한 경우 , 지원되지 않는 변환 플래그에 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 경고 클래스의 경고가 발행됩니다. 대신 예외를 선호하는 경우 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="fd9213ca43980debccb984d13f9caaa2e79748be" translate="yes" xml:space="preserve">
          <source>As of 5.14, none of these raises an exception if they are not supported on your platform. However, if warnings are enabled, a warning of the &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; warning class is issued on an unsupported conversion flag. Should you instead prefer an exception, do this:</source>
          <target state="translated">5.14부터는 플랫폼에서 지원되지 않는 경우 예외가 발생하지 않습니다. 그러나 경고가 사용 가능한 경우 , 지원되지 않는 변환 플래그에 &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 경고 클래스의 경고가 발행됩니다. 대신 예외를 선호하는 경우 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="6791199e3f80fe4bbb43c0eaff9608d527ada74b" translate="yes" xml:space="preserve">
          <source>As of 5.14, that can also be written this way:</source>
          <target state="translated">5.14부터는 다음과 같이 쓸 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b37d45aa3fafa285df8c8611054589c583244ea5" translate="yes" xml:space="preserve">
          <source>As of 5.19.9 setting &lt;code&gt;$/&lt;/code&gt; to any other form of reference will throw a fatal exception. This is in preparation for supporting new ways to set &lt;code&gt;$/&lt;/code&gt; in the future.</source>
          <target state="translated">5.19.9에서 &lt;code&gt;$/&lt;/code&gt; 를 다른 형식의 참조로 설정 하면 치명적인 예외가 발생합니다. 이것은 앞으로 &lt;code&gt;$/&lt;/code&gt; 를 설정하는 새로운 방법을 지원하기위한 준비입니다 .</target>
        </trans-unit>
        <trans-unit id="5090edb4c78c4b281b3a889d093a1c4d0aac43d2" translate="yes" xml:space="preserve">
          <source>As of 5.8.1, long doubles are working if you use the Sun compilers (needed for additional math routines not included in libm).</source>
          <target state="translated">5.8.1 현재 Sun 컴파일러를 사용하면 long doubles가 작동합니다 (libm에 포함되지 않은 추가 수학 루틴이 필요함).</target>
        </trans-unit>
        <trans-unit id="f508ee41697726e1567be3f0dd308006b0a11bbd" translate="yes" xml:space="preserve">
          <source>As of 5.8.1, the &lt;b&gt;-C&lt;/b&gt; can be followed either by a number or a list of option letters. The letters, their numeric values, and effects are as follows; listing the letters is equal to summing the numbers.</source>
          <target state="translated">5.8.1 현재, &lt;b&gt;-C&lt;/b&gt; 뒤에 숫자 또는 옵션 문자 목록이 올 수 있습니다. 글자, 숫자 및 효과는 다음과 같습니다. 문자를 나열하는 것은 숫자를 합산하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="45cfda1b1b7f6423e5dd7ec6647effcbf0d30173" translate="yes" xml:space="preserve">
          <source>As of 5.9.5 the directive &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; and its equivalents are lexically scoped, as are the other directives. However they have both compile-time and run-time effects.</source>
          <target state="translated">5.9.5 현재, 지시문 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; 하고 다른 지시어와 마찬가지로 그 범위는 어휘 범위입니다. 그러나 컴파일 타임 및 런타임 효과가 모두 있습니다.</target>
        </trans-unit>
        <trans-unit id="d51f5d10f6eede269e073b2d28e8411b4b049f81" translate="yes" xml:space="preserve">
          <source>As of 5.9.5 the directive &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; and its equivalents are lexically scoped, as the other directives are. However they have both compile-time and run-time effects.</source>
          <target state="translated">5.9.5 현재, 지시문 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; 하고 다른 지시어와 마찬가지로 그 범위는 어휘 범위입니다. 그러나 컴파일 타임 및 런타임 효과가 모두 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b5a3958e4abf52ef71b991a4f025f997262e7e8" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;Encode&lt;/code&gt; 2.12, &lt;code&gt;CHECK&lt;/code&gt; can also be a code reference which takes the ordinal value of the unmapped character as an argument and returns octets that represent the fallback character. For instance:</source>
          <target state="translated">현재 &lt;code&gt;Encode&lt;/code&gt; 2.12 &lt;code&gt;CHECK&lt;/code&gt; 는 또한 대체 문자를 나타내는 인수 및 반환 진수로 맵핑되지 않은 값의 문자 코드를 취하는 기준이 될 수있다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="b411b3efc2bae2399e243c4103628c18af471dad" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;Encode&lt;/code&gt; version 2.21, a new method &lt;code&gt;mime_name()&lt;/code&gt; is therefore added.</source>
          <target state="translated">현재 &lt;code&gt;Encode&lt;/code&gt; 버전 2.21, 새로운 방법 &lt;code&gt;mime_name()&lt;/code&gt; 따라서 첨가한다.</target>
        </trans-unit>
        <trans-unit id="703e152d6b7fb820f5c3dbc21f352bf9bc7a9e95" translate="yes" xml:space="preserve">
          <source>As of CPAN 1.9463, if you do not have permission to write the default perl library directories, CPAN's configuration process will ask you whether you want to bootstrap &amp;lt;local::lib&amp;gt;, which makes keeping a personal perl library directory easy.</source>
          <target state="translated">CPAN 1.9463부터 기본 perl 라이브러리 디렉토리를 작성할 수있는 권한이없는 경우 CPAN의 구성 프로세스는 &amp;lt;local :: lib&amp;gt;를 부트 스트랩 할 것인지 묻습니다. 이렇게하면 개인 perl 라이브러리 디렉토리를 쉽게 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07aaeb2f2c75fecbde3c90f6c2e907a83c502842" translate="yes" xml:space="preserve">
          <source>As of Encode 1.87, the older form</source>
          <target state="translated">Encode 1.87 기준으로 이전 형식</target>
        </trans-unit>
        <trans-unit id="b09ae12c2db054fb655cbb26f548a82db4c390c0" translate="yes" xml:space="preserve">
          <source>As of July 2002 (the Perl release 5.8.0), the following platforms were able to build Perl from the standard source code distribution available at &lt;a href=&quot;http://www.cpan.org/src/&quot;&gt;http://www.cpan.org/src/&lt;/a&gt;</source>
          <target state="translated">2002 년 7 월 (Perl 릴리스 5.8.0)부터 다음 플랫폼은 &lt;a href=&quot;http://www.cpan.org/src/&quot;&gt;http://www.cpan.org/src/에&lt;/a&gt; 있는 표준 소스 코드 배포에서 Perl을 빌드 할 수있었습니다 .</target>
        </trans-unit>
        <trans-unit id="fcab0673d5c88e7554da234165f977684b228be3" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10, the &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; variables may be used. These are only set if the &lt;code&gt;/p&lt;/code&gt; modifier is present. Consequently they do not penalize the rest of the program. In Perl 5.20, &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; are available whether the &lt;code&gt;/p&lt;/code&gt; has been used or not (the modifier is ignored), and &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$'&lt;/code&gt; and &lt;code&gt;$&amp;amp;&lt;/code&gt; do not cause any speed difference.</source>
          <target state="translated">Perl 5.10부터 &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; 및 &lt;code&gt;${^POSTMATCH}&lt;/code&gt; 변수를 사용할 수 있습니다. &lt;code&gt;/p&lt;/code&gt; 수정자가있는 경우에만 설정됩니다 . 결과적으로 그들은 나머지 프로그램에 불이익을주지 않습니다. 펄 5.20에서 &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; 와 &lt;code&gt;${^POSTMATCH}&lt;/code&gt; 여부를 확인할 수 있습니다 &lt;code&gt;/p&lt;/code&gt; (수정 무시) 사용 여부되었으며, &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$'&lt;/code&gt; 와 &lt;code&gt;$&amp;amp;&lt;/code&gt; 하지 속도 차이가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="eafa84154e8f8c3596803a7b5e3904a497adc460" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10, this pragma is lexically scoped and takes effect at compile time. In earlier versions its effect was global and took effect at run-time; the documentation suggested using &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; to change the behaviour:</source>
          <target state="translated">Perl 5.10부터이 pragma는 어휘 범위가 지정되며 컴파일시 적용됩니다. 이전 버전에서는 그 효과가 전역 적이며 런타임에 적용되었습니다. 설명서는 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 을 사용하여 동작을 변경하도록 제안했습니다 .</target>
        </trans-unit>
        <trans-unit id="86d4d0145ccce27050aa6a59ab5275c8b3a0cdb0" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10, you can match balanced text with regular expressions using recursive patterns. Before Perl 5.10, you had to resort to various tricks such as using Perl code in &lt;code&gt;(??{})&lt;/code&gt; sequences.</source>
          <target state="translated">Perl 5.10부터 재귀 패턴을 사용하여 균형 잡힌 텍스트를 정규식과 일치시킬 수 있습니다. Perl 5.10 이전에는 &lt;code&gt;(??{})&lt;/code&gt; 시퀀스 에서 Perl 코드 사용과 같은 다양한 트릭을 사용해야했습니다 .</target>
        </trans-unit>
        <trans-unit id="eea5149372feb11e1db38e07d50576f276a6c743" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.0, Perl supports several Python/PCRE-specific extensions to the regex syntax. While Perl programmers are encouraged to use the Perl-specific syntax, the following are also accepted:</source>
          <target state="translated">Perl 5.10.0부터 Perl은 정규 표현식 구문에 대한 여러 Python / PCRE 특정 확장을 지원합니다. Perl 프로그래머는 Perl 특정 구문을 사용하도록 권장되지만 다음 사항도 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="793e424fe5bef6967b0c0b6751f2a3b12bcf501f" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.0, as a form of purely syntactic sugar, you can stack file test operators, in a way that &lt;code&gt;-f -w -x $file&lt;/code&gt; is equivalent to &lt;code&gt;-x $file &amp;amp;&amp;amp; -w _ &amp;amp;&amp;amp; -f _&lt;/code&gt; . (This is only fancy syntax: if you use the return value of &lt;code&gt;-f $file&lt;/code&gt; as an argument to another filetest operator, no special magic will happen.)</source>
          <target state="translated">Perl 5.10.0부터 순전히 구문 설탕의 형태로 &lt;code&gt;-f -w -x $file&lt;/code&gt; 이 &lt;code&gt;-x $file &amp;amp;&amp;amp; -w _ &amp;amp;&amp;amp; -f _&lt;/code&gt; 와 같은 방식으로 파일 테스트 연산자를 스택 할 수 있습니다 . (이것은 멋진 구문입니다. &lt;code&gt;-f $file&lt;/code&gt; 의 반환 값 을 다른 파일 테스트 연산자의 인수로 사용하면 특별한 마법이 발생하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="4eb7e07d934fae953d19f8161458d55420e41446" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.0, one can create custom regular expression engines. This is not for the faint of heart, as they have to plug in at the C level. See &lt;a href=&quot;perlreapi&quot;&gt;perlreapi&lt;/a&gt; for more details.</source>
          <target state="translated">Perl 5.10.0부터 사용자 정의 정규식 엔진을 작성할 수 있습니다. C 레벨에서 플러그를 꽂아야하기 때문에 희미한 마음이 아닙니다. 자세한 내용은 &lt;a href=&quot;perlreapi&quot;&gt;perlreapi&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0c7a09399a8f27b12757a6f71f279fa17b42fdfd" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.0, you can also use the &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt; modifiers to force big- or little-endian byte-order. This is useful if you want to store signed integers or 64-bit integers, for example.</source>
          <target state="translated">Perl 5.10.0부터는 &lt;code&gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;&lt;/code&gt; 수정자를 사용하여 빅 엔디안 또는 리틀 엔디안 바이트 순서를 강제 할 수도 있습니다 . 예를 들어 부호있는 정수 또는 64 비트 정수를 저장하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="835734cf27f076a5a1e9340fb76782ceeb1a149b" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.1 there is a new interface for plugging and using method resolution orders other than the default (linear depth first search). The C3 method resolution order added in 5.10.0 has been re-implemented as a plugin, without changing its Perl-space interface.</source>
          <target state="translated">Perl 5.10.1부터는 기본값 (선형 깊이 우선 검색) 이외의 방법 해결 순서를 연결하고 사용하기위한 새로운 인터페이스가 있습니다. 5.10.0에 추가 된 C3 메소드 분석 순서는 Perl-space 인터페이스를 변경하지 않고 플러그인으로 다시 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="4ca2607d4b8da91c9aab14d61ac0b65b288bfff7" translate="yes" xml:space="preserve">
          <source>As of Perl 5.12 you can use a bare &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;code&gt;$_&lt;/code&gt; on every iteration.</source>
          <target state="translated">Perl 5.12 부터는 &lt;code&gt;while&lt;/code&gt; 루프 에서 bare &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; 을 사용할 수 있으며 매 반복마다 &lt;code&gt;$_&lt;/code&gt; 를 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="7ef4b7baf6bbb1a8636644643a30ec84c9a4f514" translate="yes" xml:space="preserve">
          <source>As of Perl 5.12 you can use a bare &lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;code&gt;$_&lt;/code&gt; on every iteration.</source>
          <target state="translated">Perl 5.12 부터는 &lt;code&gt;while&lt;/code&gt; 루프 에서 bare &lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; 을 사용할 수 있으며 매 반복마다 &lt;code&gt;$_&lt;/code&gt; 를 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="9aad368f35112b0ebb60af7e4b6035d03ee10832" translate="yes" xml:space="preserve">
          <source>As of Perl 5.12, deprecated features and modules warn the user as they're used. When a module is deprecated, it will also be made available on CPAN. Installing it from CPAN will silence deprecation warnings for that module.</source>
          <target state="translated">Perl 5.12부터는 더 이상 사용되지 않는 기능 및 모듈이 사용됨에 따라 사용자에게 경고합니다. 더 이상 사용되지 않는 모듈은 CPAN에서도 사용할 수 있습니다. CPAN에서 설치하면 해당 모듈에 대한 지원 중단 경고가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7bc75da6cf8214f9a49a145ca7f1ff6dd1976a38" translate="yes" xml:space="preserve">
          <source>As of Perl 5.18 every hash has its own hash traversal order, and this order changes every time a new element is inserted into the hash. This functionality is provided by maintaining an unsigned integer mask (U32) which is xor'ed with the actual bucket id during a traversal of the hash buckets using keys(), values() or each().</source>
          <target state="translated">Perl 5.18부터 모든 해시는 자체 해시 순회 순서를 가지며이 순서는 새 요소가 해시에 삽입 될 때마다 변경됩니다. 이 기능은 keys (), values ​​() 또는 each ()를 사용하여 해시 버킷을 순회하는 동안 실제 버킷 ID와 xored되는 부호없는 정수 마스크 (U32)를 유지함으로써 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a8b875400d906734f1b4f9f29eb27503d8a35f16" translate="yes" xml:space="preserve">
          <source>As of Perl 5.18 you can use a bare &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;code&gt;$_&lt;/code&gt; on every iteration.</source>
          <target state="translated">펄 5.18의로서 당신은이 베어 사용할 수있는 &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; A의 &lt;code&gt;while&lt;/code&gt; 설정합니다 루프, &lt;code&gt;$_&lt;/code&gt; 모든 반복에.</target>
        </trans-unit>
        <trans-unit id="211e0f721f82a57a3e303b9bd4a37e7c878adb86" translate="yes" xml:space="preserve">
          <source>As of Perl 5.18 you can use a bare &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;code&gt;$_&lt;/code&gt; on every iteration.</source>
          <target state="translated">펄 5.18의로서 당신은이 베어 사용할 수있는 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; A의 &lt;code&gt;while&lt;/code&gt; 설정합니다 루프, &lt;code&gt;$_&lt;/code&gt; 모든 반복에.</target>
        </trans-unit>
        <trans-unit id="c33c32e4c4b133822c39af8f8540bc2360a9b3e1" translate="yes" xml:space="preserve">
          <source>As of Perl 5.20, instead of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings FATAL =&amp;gt; 'all';&lt;/code&gt; you can use:</source>
          <target state="translated">Perl 5.20부터 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings FATAL =&amp;gt; 'all';&lt;/code&gt; 대신 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; FATAL =&amp;gt; 'all'; 당신이 사용할 수있는:</target>
        </trans-unit>
        <trans-unit id="c35a63f8082ff3fbb7b2bded313d23f6fdc3cfd9" translate="yes" xml:space="preserve">
          <source>As of Perl 5.22, there is an experimental variant of this loop that accepts a variable preceded by a backslash for VAR, in which case the items in the LIST must be references. The backslashed variable will become an alias to each referenced item in the LIST, which must be of the correct type. The variable needn't be a scalar in this case, and the backslash may be followed by &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;. To use this form, you must enable the &lt;code&gt;refaliasing&lt;/code&gt; feature via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; . (See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;. See also &lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;Assigning to References in perlref&lt;/a&gt;.)</source>
          <target state="translated">Perl 5.22부터는 VAR에 대한 백 슬래시가 앞에 오는 변수를 허용하는이 루프의 실험적인 변형이 있습니다.이 경우 LIST의 항목은 참조 여야합니다. 백 슬래시 변수는 LIST의 각 참조 항목에 대한 별명이되며 올바른 유형이어야합니다. 이 경우 변수는 스칼라 일 필요가 없으며 백 슬래시 뒤에 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 가 올 수 있습니다 . 이 양식을 사용하려면 활성화해야합니다 &lt;code&gt;refaliasing&lt;/code&gt; 를 통해 기능 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; . (참조 &lt;a href=&quot;feature&quot;&gt;기능을&lt;/a&gt; . 참조 &lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;perlref에 참조로 지정&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="df42579e1cb5e3f110d0c1cf4c3bbc08eda67128" translate="yes" xml:space="preserve">
          <source>As of Perl 5.22, this buggy behavior, while preserved for backward compatibility, is detected and emits a deprecation warning. If you want the subroutine to be inlined (with no warning), make sure the variable is not used in a context where it could be modified aside from where it is declared.</source>
          <target state="translated">Perl 5.22부터는이 버기 동작이 이전 버전과의 호환성을 위해 유지되지만 감지되어 사용 중단 경고가 표시됩니다. 서브 루틴을 경고없이 인라인하려면 변수가 선언 된 위치와 별도로 수정 될 수있는 컨텍스트에서 변수를 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="b18e8f64ae6fd8a43ee4372bec94f73e67d74058" translate="yes" xml:space="preserve">
          <source>As of Perl 5.22, you can also use &lt;code&gt;(&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;)x2&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;, &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . (You can also do &lt;code&gt;($x) x 2&lt;/code&gt; , which is less useful, because it assigns to the same variable twice, clobbering the first value assigned.)</source>
          <target state="translated">Perl 5.22부터 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;, &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; 대신 &lt;code&gt;(&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;)x2&lt;/code&gt; 를 사용할 수도 있습니다 . ( &lt;code&gt;($x) x 2&lt;/code&gt; 수행 할 수도 있습니다.이 변수는 같은 변수에 두 번 할당되어 할당 된 첫 번째 값을 방해하므로 덜 유용합니다.)</target>
        </trans-unit>
        <trans-unit id="6f3aa7e1697ed4bbe63edb4cde5bc634c7d4943e" translate="yes" xml:space="preserve">
          <source>As of Perl 5.6, you can represent filehandles with scalar variables which you treat as any other scalar.</source>
          <target state="translated">Perl 5.6부터는 다른 스칼라로 취급하는 스칼라 변수로 파일 핸들을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90e7536680dcd18ada661ef157609a74a6cebee3" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.0 after using this module you cannot use the implicit &lt;code&gt;$_&lt;/code&gt; or the special filehandle &lt;code&gt;_&lt;/code&gt; with stat() or lstat(), trying to do so leads into strange errors. The workaround is for &lt;code&gt;$_&lt;/code&gt; to be explicit</source>
          <target state="translated">이 모듈을 사용한 후 Perl 5.8.0부터 stat () 또는 lstat ()와 함께 내재적 &lt;code&gt;$_&lt;/code&gt; 또는 특수 파일 핸들 &lt;code&gt;_&lt;/code&gt; 을 사용할 수 없으므로 그렇게하면 이상한 오류가 발생합니다. 해결 방법은 &lt;code&gt;$_&lt;/code&gt; 명시 적입니다.</target>
        </trans-unit>
        <trans-unit id="5fd0a9a99a09c2a713ff60adbdf886450b68308c" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.0, the &quot;Full&quot; case-folding of</source>
          <target state="translated">Perl 5.8.0 기준으로 &quot;Full&quot;case-folding</target>
        </trans-unit>
        <trans-unit id="444326d8d5a5982dc22e2a52147d982ac07eb8e8" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.0, you can use &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; with multiple arguments. Just like the list forms of &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt;, no shell escapes happen.</source>
          <target state="translated">Perl 5.8.0부터 여러 인수와 함께 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 을 사용할 수 있습니다 . &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; 의 목록 형식과 마찬가지로 쉘 이스케이프가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a68a3c591a49e26bfd6e1872f3f7a653d522ef71" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.1 the dynamic loading of libraries (DynaLoader, XSLoader) also seems to have become broken in in SunOS 4.x. Therefore the default is to build Perl statically.</source>
          <target state="translated">Perl 5.8.1부터 라이브러리의 동적 로딩 (DynaLoader, XSLoader)도 SunOS 4.x에서 중단 된 것으로 보입니다. 따라서 기본값은 Perl을 정적으로 빌드하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ef5cb6c37e267f59227533f0250c84c8718b7076" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.1, &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt; also has the &lt;code&gt;utf8::is_utf8&lt;/code&gt; function.</source>
          <target state="translated">Perl 5.8.1부터 &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt; 에는 &lt;code&gt;utf8::is_utf8&lt;/code&gt; 함수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab205322181f94cdf41d5eaaf572850bb63def33" translate="yes" xml:space="preserve">
          <source>As of Perl 5.9.5 there is a new interface for plugging and using regular expression engines other than the default one.</source>
          <target state="translated">Perl 5.9.5부터 기본 엔진 이외의 정규식 엔진을 연결하고 사용하기위한 새로운 인터페이스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="02c3c3ae5c3a1698c2091dbb44ff1c48ff7a71dd" translate="yes" xml:space="preserve">
          <source>As of Perl Symbian port version 0.4.1 any part of Perl's standard regression test suite has not been run on a real Symbian device using the ported Perl, so innumerable bugs may lie in wait. Therefore there is absolutely no warranty.</source>
          <target state="translated">Perl Symbian 포트 버전 0.4.1부터 Perl의 표준 회귀 테스트 스위트 중 일부는 이식 된 Perl을 사용하여 실제 Symbian 장치에서 실행되지 않았으므로 수많은 버그가 대기 중일 수 있습니다. 따라서 보증이 전혀 없습니다.</target>
        </trans-unit>
        <trans-unit id="2a7301a461e47b0be61be125749323ecdfc5a92a" translate="yes" xml:space="preserve">
          <source>As of Perl v5.16.0, it is implemented by the &lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt; module. See &lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt; for more details on its behaviour.</source>
          <target state="translated">Perl v5.16.0 &lt;a href=&quot;arybase&quot;&gt;부터는 arybase&lt;/a&gt; 모듈로 구현됩니다 . 동작에 대한 자세한 내용 은 &lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9f7c19e511eae81348e03d06d3194e0d82d15184" translate="yes" xml:space="preserve">
          <source>As of R2.5 of USS for OS/390 and Version 2.3 of VM/ESA these Unix sub-systems do not support the &lt;code&gt;#!&lt;/code&gt; shebang trick for script invocation. Hence, on OS/390 and VM/ESA Perl scripts can be executed with a header similar to the following simple script:</source>
          <target state="translated">OS / 390 용 USS R2.5 및 VM / ESA 버전 2.3에서이 Unix 서브 시스템은 &lt;code&gt;#!&lt;/code&gt; 스크립트 호출을위한 shebang 트릭. 따라서 OS / 390 및 VM / ESA에서 Perl 스크립트는 다음 간단한 스크립트와 유사한 헤더를 사용하여 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e29546f04e5cfe2122e46676161bb58e8a9f171" translate="yes" xml:space="preserve">
          <source>As of Unicode 6.0, this is always empty.</source>
          <target state="translated">유니 코드 6.0부터는 항상 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6be62dadd6bbd6b8a9fe9bd5f460bd2ea3dfc014" translate="yes" xml:space="preserve">
          <source>As of VERSION 1.18 all IO::Socket objects have autoflush turned on by default. This was not the case with earlier releases.</source>
          <target state="translated">VERSION 1.18부터 모든 IO :: Socket 객체는 기본적으로 자동 플러시 기능을 사용합니다. 이전 릴리스에서는 그렇지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="9b18b6d1424b74e3d0360d9f0334585a766708d3" translate="yes" xml:space="preserve">
          <source>As of db-4.2.x it is no longer needed to do this by hand. Sleepycat has changed the configuration process to add +z on HP-UX automatically.</source>
          <target state="translated">db-4.2.x부터는 더 이상 수동으로이를 수행 할 필요가 없습니다. Sleepycat은 HP-UX에서 + z를 자동으로 추가하도록 구성 프로세스를 변경했습니다.</target>
        </trans-unit>
        <trans-unit id="ddb5b154eee158ecabd0abbac4ff1eab5e92e45f" translate="yes" xml:space="preserve">
          <source>As of perl 5.14 it is possible to hook into the compile-time lexical scope mechanism using &lt;code&gt;Perl_blockhook_register&lt;/code&gt; . This is used like this:</source>
          <target state="translated">perl 5.14부터 &lt;code&gt;Perl_blockhook_register&lt;/code&gt; 를 사용하여 컴파일 타임 어휘 범위 메커니즘에 연결할 수 있습니다. 이것은 다음과 같이 사용됩니다 :</target>
        </trans-unit>
        <trans-unit id="283446be77b5c5650a7aade52dfb5d3e56c4e299" translate="yes" xml:space="preserve">
          <source>As of perl 5.9.5 're' debug contains a number of utility functions that may be optionally exported into the caller's namespace. They are listed below.</source>
          <target state="translated">perl 5.9.5부터 're'디버그에는 호출자의 네임 스페이스로 선택적으로 내보낼 수있는 많은 유틸리티 함수가 포함되어 있습니다. 아래에 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5916c6705e19aa4737c1eaecb1fdda26e7395e63" translate="yes" xml:space="preserve">
          <source>As of perl5.6, open() autovivifies file and directory handles as references if you pass it an uninitialized scalar variable. You can then pass these references just like any other scalar, and use them in the place of named handles.</source>
          <target state="translated">perl5.6에서, open ()은 파일 및 디렉토리 핸들을 초기화되지 않은 스칼라 변수에 전달하면 참조로 자동 활성화합니다. 그런 다음 다른 스칼라와 마찬가지로 이러한 참조를 전달하고 명명 된 핸들 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d06e02fdc69f862d76b045e6be72fc487c78e0b" translate="yes" xml:space="preserve">
          <source>As of perl5.7.2 all tests pass under:</source>
          <target state="translated">perl5.7.2부터 모든 테스트는 다음을 통과합니다.</target>
        </trans-unit>
        <trans-unit id="e7ebc726132cf88aa72c90598602d1b0ee48a664" translate="yes" xml:space="preserve">
          <source>As of perl5.8.1 there is at least one test still failing.</source>
          <target state="translated">perl5.8.1부터는 여전히 하나 이상의 테스트가 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="1b82fd373dbd0883f99d276e806ca9d5f0a6e144" translate="yes" xml:space="preserve">
          <source>As of release 5 of Perl, assignment to &lt;code&gt;$[&lt;/code&gt; is treated as a compiler directive, and cannot influence the behavior of any other file. (That's why you can only assign compile-time constants to it.) Its use is highly discouraged.</source>
          <target state="translated">Perl의 릴리스 5부터 &lt;code&gt;$[&lt;/code&gt; 에 대한 지정은 컴파일러 지시문으로 취급되며 다른 파일의 동작에 영향을 줄 수 없습니다. (따라서 컴파일 타임 상수 만 할당 할 수 있습니다.) 사용을 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1e2bbc98f0506e501d121cbf3463e0bb77e718b4" translate="yes" xml:space="preserve">
          <source>As of release 5.003_01 perl is linked to multithreaded C RTL DLL. If perl itself is not compiled multithread-enabled, so will not be perl's malloc(). However, extensions may use multiple thread on their own risk.</source>
          <target state="translated">릴리스 5.003_01부터 perl은 멀티 스레드 C RTL DLL에 연결됩니다. perl 자체가 멀티 스레드 가능 컴파일되지 않은 경우 perl의 malloc ()이되지 않습니다. 그러나 확장은 자체적으로 여러 스레드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5dbdb753a9581b45c8e16e8caa7ad1fc9cd73184" translate="yes" xml:space="preserve">
          <source>As of right now, this returns 2 if the path is absolute with a volume, 1 if it's absolute with no volume, 0 otherwise.</source>
          <target state="translated">현재 경로가 볼륨에 절대적이면 2를 반환하고, 볼륨이 없으면 절대에 1을, 그렇지 않으면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cedde28f0889c00006609cd1f4e0ab992b6b315c" translate="yes" xml:space="preserve">
          <source>As of the date of this document's last update, the following systems contain PA-RISC 2.0 chips:</source>
          <target state="translated">이 문서의 마지막 업데이트 날짜부터 다음 시스템에는 PA-RISC 2.0 칩이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="361f300829fa013b44d60226e2c65866392ff21f" translate="yes" xml:space="preserve">
          <source>As of the date of this document, Perl is fully 64-bit compliant on HP-UX 11.00 and up for both cc- and gcc builds. If you are about to build a 64-bit perl with GNU gcc, please read the gcc section carefully.</source>
          <target state="translated">이 문서가 작성된 시점에서 Perl은 HP-UX 11.00에서 완전히 64 비트를 준수하며 cc 및 gcc 빌드 모두에 해당합니다. GNU gcc로 64 비트 perl을 만들려고한다면 gcc 섹션을주의 깊게 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="6087654ae9665e2974920201f81ba084c4838564" translate="yes" xml:space="preserve">
          <source>As of the time this document was last revised, the following Perl functions were implemented in the VMS port of Perl (functions marked with * are discussed in more detail below):</source>
          <target state="translated">이 문서가 마지막으로 개정 된 시점에서 다음 Perl 기능은 Perl의 VMS 포트에서 구현되었습니다 (*로 표시된 기능은 아래에서 자세히 설명합니다).</target>
        </trans-unit>
        <trans-unit id="2f434753b82171852395258695f5260796bd3e54" translate="yes" xml:space="preserve">
          <source>As of v5.14, Perl distinguishes three subclasses of UTF‑8 warnings.</source>
          <target state="translated">v5.14부터 Perl은 UTF-8 경고의 세 가지 서브 클래스를 구별합니다.</target>
        </trans-unit>
        <trans-unit id="3687eac7ed0d3e9a3819b6d8b59ffbbce6f96ce7" translate="yes" xml:space="preserve">
          <source>As of v5.18.0, both keys and values stored in &lt;code&gt;%ENV&lt;/code&gt; are stringified.</source>
          <target state="translated">v5.18.0부터는 &lt;code&gt;%ENV&lt;/code&gt; 저장된 키와 값이 모두 문자열 화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="068ae70c04574cc37cc34db842b7ac8d0c145fb6" translate="yes" xml:space="preserve">
          <source>As of version 1.01 of the AutoSplit module it is possible to have multiple packages within a single file. Both of the following cases are supported:</source>
          <target state="translated">AutoSplit 모듈 버전 1.01부터 단일 파일 내에 여러 패키지가있을 수 있습니다. 다음 경우 모두 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4d09237d697a620472d98ca9564ba252e7440a3a" translate="yes" xml:space="preserve">
          <source>As of version 1.02 (provided with perl 5.12) the object provides &lt;code&gt;&quot;-X&quot;&lt;/code&gt; overloading, so you can call filetest operators (&lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; , and so on) on it. It also provides a &lt;code&gt;-&amp;gt;cando&lt;/code&gt; method, called like</source>
          <target state="translated">버전 1.02 (perl 5.12와 함께 제공)부터 객체는 &lt;code&gt;&quot;-X&quot;&lt;/code&gt; 오버로딩을 제공 하므로 파일 테스트 연산자 ( &lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; 등)를 호출 할 수 있습니다 . 또한 &lt;code&gt;-&amp;gt;cando&lt;/code&gt; 메소드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="39c91a8aec6b3b91e09f6a8bd53c1515a32cc61b" translate="yes" xml:space="preserve">
          <source>As of version 1.04 (Perl 5.10), strict verifies that it is used as &quot;strict&quot; to avoid the dreaded Strict trap on case insensitive file systems.</source>
          <target state="translated">버전 1.04 (Perl 5.10)부터는 대소 문자를 구분하지 않는 파일 시스템에서 두려운 엄격한 트랩을 피하기 위해 &quot;strict&quot;로 사용되는지 엄격하게 확인합니다.</target>
        </trans-unit>
        <trans-unit id="5750d09d680a68ca093b8cb502caecf523fc46de" translate="yes" xml:space="preserve">
          <source>As of version 1.32 of this module, constants can be defined in packages other than the caller, by including the package name in the name of the constant:</source>
          <target state="translated">이 모듈의 버전 1.32부터 상수 이름에 패키지 이름을 포함시켜 호출자 이외의 패키지에서 상수를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9966baeb16dc71d9782450ad1960be303770497" translate="yes" xml:space="preserve">
          <source>As of version 1.47 the following additions were made to the install interface. Note that the new argument style and use of the %result hash is recommended.</source>
          <target state="translated">버전 1.47부터 설치 인터페이스에 다음이 추가되었습니다. 새로운 인수 스타일과 % result 해시를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e47319fd89f8639b4c6dc3d1dee645f4e3217716" translate="yes" xml:space="preserve">
          <source>As of version 2.12, &lt;code&gt;Encode&lt;/code&gt; supports coderef values for &lt;code&gt;CHECK&lt;/code&gt; ; see below.</source>
          <target state="translated">버전 2.12부터 &lt;code&gt;Encode&lt;/code&gt; 는 &lt;code&gt;CHECK&lt;/code&gt; 에 대한 코드 참조 값을 지원합니다 . 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="feaefe7da5a3f173789e3bc38d1cc052b48f0697" translate="yes" xml:space="preserve">
          <source>As of version 2.32 Getopt::Long provides auto-help, a quick and easy way to add the options --help and -? to your program, and handle them.</source>
          <target state="translated">버전 2.32 현재 Getopt :: Long은 자동 도움말을 제공하여 옵션 --help 및-?를 빠르고 쉽게 추가 할 수 있습니다. 당신의 프로그램에 그들을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="4961ac95a03fe72cd95305ebd10cd56767e6cd2e" translate="yes" xml:space="preserve">
          <source>As of version 5.00305, OS/2 perl binary distribution comes split into 11 components. Unfortunately, to enable configurable binary installation, the file paths in the zip files are not absolute, but relative to some directory.</source>
          <target state="translated">버전 5.00305부터 OS / 2 perl 이진 배포는 11 개의 구성 요소로 나뉩니다. 불행하게도, 구성 가능한 바이너리 설치를 가능하게하기 위해, zip 파일의 파일 경로는 절대적인 것이 아니라 일부 디렉토리에 상대적입니다.</target>
        </trans-unit>
        <trans-unit id="c5ef8d96f6d787f0f3cc3fb69a33144b75f432e6" translate="yes" xml:space="preserve">
          <source>As of version 5.12.0, perl has stopped using the underlying time library of the operating system it's running on and has its own implementation of those routines with a safe range of at least +/ 2**52 (about 142 million years).</source>
          <target state="translated">버전 5.12.0부터 perl은 운영 체제의 기본 시간 라이브러리 사용을 중단했으며 안전 범위가 최소 + / 2 ** 52 (약 1 억 2 천 6 백만 년) 인 루틴을 자체적으로 구현했습니다.</target>
        </trans-unit>
        <trans-unit id="ede48005eab24777f4cf1c1c51404cc14a546bbe" translate="yes" xml:space="preserve">
          <source>As of writing (2010-09) only the</source>
          <target state="translated">현재 (2010-09)</target>
        </trans-unit>
        <trans-unit id="53d68ae04ea90208ac09617d93481673c81dae0c" translate="yes" xml:space="preserve">
          <source>As per &lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;, in scalar context it should return the next line, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for no more data. In list context it should return all remaining lines, or an empty list for no more data. The strings returned should include the input record separator &lt;code&gt;$/&lt;/code&gt; (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;), unless it is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (which means &quot;slurp&quot; mode).</source>
          <target state="translated">&lt;a href=&quot;functions/readline&quot;&gt;readline에&lt;/a&gt; 따라 스칼라 컨텍스트에서 다음 행을 반환하거나 더 이상 데이터가 없으면 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 해야합니다. 목록 컨텍스트에서 나머지 모든 행을 반환하거나 더 이상 데이터가 없으면 빈 목록을 반환해야합니다. 반환 된 문자열 은 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ( &quot;slurp&quot;모드를 의미 )하지 않는 한 입력 레코드 구분 기호 &lt;code&gt;$/&lt;/code&gt; ( &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; 참조 )를 포함해야합니다 .</target>
        </trans-unit>
        <trans-unit id="35db6e6083bf8853a0d7a773700bfc53f4f3833e" translate="yes" xml:space="preserve">
          <source>As per get(), but returns a tied filehandle. Reading from this filehandle returns the requested message. The filehandle will return EOF at the end of the message and should not be reused.</source>
          <target state="translated">get ()에 따라 묶인 파일 핸들을 반환합니다. 이 파일 핸들을 읽으면 요청 된 메시지가 리턴됩니다. 파일 핸들은 메시지 끝에서 EOF를 리턴하며 재사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="f8d3cabb86865ec30b2f81b742c043bb4dfa0006" translate="yes" xml:space="preserve">
          <source>As perl does not use it, it is not well tested.</source>
          <target state="translated">펄은 그것을 사용하지 않기 때문에 잘 테스트되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="04f2eace94f5ec9fb309f7ef275b1f53f5b18652" translate="yes" xml:space="preserve">
          <source>As pragmata are implemented as modules, like any other module, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; myint;&lt;/code&gt; becomes</source>
          <target state="translated">pragmata가 다른 모듈과 마찬가지로 모듈로 구현되므로 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; myint;&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하십시오. 된다</target>
        </trans-unit>
        <trans-unit id="6ff69505257da499d009f94993a8c36d403bc517" translate="yes" xml:space="preserve">
          <source>As previously mentioned, the &quot;switch&quot; feature is considered highly experimental; it is subject to change with little notice. In particular, &lt;code&gt;when&lt;/code&gt; has tricky behaviours that are expected to change to become less tricky in the future. Do not rely upon its current (mis)implementation. Before Perl 5.18, &lt;code&gt;given&lt;/code&gt; also had tricky behaviours that you should still beware of if your code must run on older versions of Perl.</source>
          <target state="translated">앞에서 언급했듯이 &quot;스위치&quot;기능은 매우 실험적인 것으로 간주됩니다. 별다른 통지없이 변경 될 수 있습니다. 특히 앞으로 까다로워 질 까다로운 행동이 &lt;code&gt;when&lt;/code&gt; . 현재 (오용) 구현에 의존하지 마십시오. 펄 5.18 전에 &lt;code&gt;given&lt;/code&gt; 또한 당신은 여전히 당신의 코드는 펄의 이전 버전에서 실행해야하는 경우를 조심해야한다는 까다로운 행동을했다.</target>
        </trans-unit>
        <trans-unit id="d4ddd43c6028587c10020a05414bb6d70c1790ee" translate="yes" xml:space="preserve">
          <source>As previously noted, individual entries (as opposed to the whole hash) are settable. Perl only cares about Boolean true here, although the values used by</source>
          <target state="translated">앞에서 언급했듯이 개별 항목 (전체 해시와 반대)을 설정할 수 있습니다. Perl은 여기에서 사용되는 값에도 불구하고 Boolean true에만 관심이 있습니다.</target>
        </trans-unit>
        <trans-unit id="40863db850a5e2446412cc32d982d2e85c0c2a70" translate="yes" xml:space="preserve">
          <source>As setup, consider this (admittedly rather contrived) example of a tie; all it does is use a file to keep a log of the values assigned to a scalar.</source>
          <target state="translated">셋업으로서, 타이의이 (구체적으로 결정된) 예를 고려하십시오. 파일을 사용하여 스칼라에 지정된 값의 로그를 유지하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="d5e7901b05cd99e70f1eb4d22405e5ec5c43c73a" translate="yes" xml:space="preserve">
          <source>As shipped, the only command-line history supplied is a simplistic one that checks for leading exclamation points. However, if you install the Term::ReadKey and Term::ReadLine modules from CPAN (such as Term::ReadLine::Gnu, Term::ReadLine::Perl, ...) you will have full editing capabilities much like those GNU</source>
          <target state="translated">제공되는 유일한 명령 줄 기록은 단순한 느낌표를 확인하는 간단한 것입니다. 그러나 CPAN에서 Term :: ReadKey 및 Term :: ReadLine 모듈 (Term :: ReadLine :: Gnu, Term :: ReadLine :: Perl, ...)을 설치하면 다음과 같은 전체 편집 기능을 사용할 수 있습니다. 암소 비슷한 일종의 영양</target>
        </trans-unit>
        <trans-unit id="3c7b29c9acaba84b5dfa9d94a08362e636c880e4" translate="yes" xml:space="preserve">
          <source>As shown above, Perl creates the backup file whether or not any output is actually changed. So this is just a fancy way to copy files:</source>
          <target state="translated">위에 표시된 것처럼 Perl은 출력이 실제로 변경되는지 여부에 관계없이 백업 파일을 작성합니다. 따라서 이것은 파일을 복사하는 멋진 방법입니다.</target>
        </trans-unit>
        <trans-unit id="cf827d39576175b49dc1a1c39fee2ddfa72908f4" translate="yes" xml:space="preserve">
          <source>As shown in this example, &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; is exempt from the &quot;looks like a function&quot; rule. A pair of parentheses following it does not (necessarily) delimit its argument. &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; NEXT&lt;/code&gt; . Also, unlike most named operators, this has the same precedence as assignment.</source>
          <target state="translated">이 예제에서 볼 수 있듯이 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; 은 &quot;함수 모양&quot;규칙에서 제외됩니다. 뒤에 오는 한 쌍의 괄호는 인수를 (필요하게) 구분하지 않습니다. &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; NEXT&lt;/code&gt; 와 같습니다 . 또한 대부분의 명명 된 연산자와 달리 할당과 동일한 우선 순위를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="a246c967f8c44d960de455229b31b368ecdb7f4c" translate="yes" xml:space="preserve">
          <source>As shown in this example, &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; is exempt from the &quot;looks like a function&quot; rule. A pair of parentheses following it does not (necessarily) delimit its argument. &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; NEXT&lt;/code&gt; . Also, unlike most named operators, this has the same precedence as assignment.</source>
          <target state="translated">이 예제에서 볼 수 있듯이 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; 은 &quot;함수 모양&quot;규칙에서 제외됩니다. 뒤에 오는 한 쌍의 괄호는 인수를 (필요하게) 구분하지 않습니다. &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; NEXT&lt;/code&gt; 와 같습니다 . 또한 대부분의 명명 된 연산자와 달리 할당과 동일한 우선 순위를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="6d2e840402d6fc0f9fee1fa99ab3b3ed1f5042e9" translate="yes" xml:space="preserve">
          <source>As such, signals that would normally not be appropriate to use in the &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill()&lt;/a&gt;&lt;/code&gt; command (e.g., &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;('KILL', $$)&lt;/code&gt; ) are okay to use with the &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; method (again, as illustrated above).</source>
          <target state="translated">따라서 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill()&lt;/a&gt;&lt;/code&gt; 명령 에 사용하기에 일반적으로 적합하지 않은 신호 (예 : &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;('KILL', $$)&lt;/code&gt; )는 &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; 메소드 와 함께 사용하는 것이 좋습니다 (위에 설명 된대로) .</target>
        </trans-unit>
        <trans-unit id="a44ff5fd296684850a7eea8453ca8654e5ea2769" translate="yes" xml:space="preserve">
          <source>As system libraries (most notably glibc) are also triggering errors, valgrind allows to suppress such errors using suppression files. The default suppression file that comes with valgrind already catches a lot of them. Some additional suppressions are defined in</source>
          <target state="translated">시스템 라이브러리 (특히 glibc)도 오류를 유발하므로 valgrind는 억제 파일을 사용하여 이러한 오류를 억제 할 수 있습니다. valgrind와 함께 제공되는 기본 억제 파일은 이미 많은 파일을 포착합니다. 일부 추가 억제는</target>
        </trans-unit>
        <trans-unit id="e1a99808d733ec0659b941748add22eaba940233" translate="yes" xml:space="preserve">
          <source>As that is multiple C statements it is quite common so see this idiom instead:</source>
          <target state="translated">그것이 여러 C 문이므로 매우 일반적 이므로이 관용구를 대신 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ac882702a8c758004edc0489caa0c38829169f81" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;'IGNORE'&lt;/code&gt; hook is not supported by &lt;code&gt;__WARN__&lt;/code&gt; , you can disable warnings using the empty subroutine:</source>
          <target state="translated">는 AS &lt;code&gt;'IGNORE'&lt;/code&gt; 훅에 의해 지원되지 않습니다 &lt;code&gt;__WARN__&lt;/code&gt; , 당신은 빈 서브 루틴을 사용하여 경고를 해제 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="481d1ba67f45c383e883a88846da2edc2a1775aa" translate="yes" xml:space="preserve">
          <source>As the Perl interpreter looks at signal flags only when it is about to execute a new opcode, a signal that arrives during a long-running opcode (e.g. a regular expression operation on a very large string) will not be seen until the current opcode completes.</source>
          <target state="translated">Perl 인터프리터는 새 opcode를 실행하려고 할 때만 신호 플래그를 확인하므로 장기 opop 동안 도착하는 신호 (예 : 매우 큰 문자열에서 정규 표현식 작업)는 현재 opcode가 완료 될 때까지 보이지 않습니다. .</target>
        </trans-unit>
        <trans-unit id="f849d9355eec2f51b5cef2814ee106c18c309122" translate="yes" xml:space="preserve">
          <source>As the PerlIO layer uses raw IO (bytes) internally, all this totally ignores things like the type of your filesystem (ASCII or EBCDIC).</source>
          <target state="translated">PerlIO 계층은 내부적으로 원시 IO (바이트)를 사용하므로이 모든 것은 파일 시스템 유형 (ASCII 또는 EBCDIC)과 같은 것을 완전히 무시합니다.</target>
        </trans-unit>
        <trans-unit id="ef5f3ccf5711fff6ab130d18e6106225adf61f56" translate="yes" xml:space="preserve">
          <source>As the PerlIO layer uses raw IO internally, all this totally ignores the type of your filesystem (ASCII or EBCDIC) and the IO_CONVERSION environment variable. If you want to get the old behavior, that the BS2000 IO functions determine conversion depending on the filesystem PerlIO still is your friend. You use IO_CONVERSION as usual and tell Perl, that it should use the native IO layer:</source>
          <target state="translated">PerlIO 계층은 내부에서 원시 IO를 사용하므로이 모든 것은 파일 시스템 유형 (ASCII 또는 EBCDIC)과 IO_CONVERSION 환경 변수를 완전히 무시합니다. 이전 동작을 원한다면 BS2000 IO 함수가 파일 시스템 PerlIO에 따라 변환을 결정한다는 것은 여전히 ​​당신의 친구입니다. 평상시처럼 IO_CONVERSION을 사용하고 Perl에게 네이티브 IO 레이어를 사용해야한다고 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="20b8fc20101f3d438a32270dc2621c0dd14971b3" translate="yes" xml:space="preserve">
          <source>As the comment says, this is not a good way to implement accessors. It's slow and too clever by far. However, you may see this as a way to provide accessors in older Perl code. See &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; for recommendations on OO coding in Perl.</source>
          <target state="translated">의견에서 알 수 있듯이 접근자를 구현하는 좋은 방법은 아닙니다. 훨씬 느리고 영리합니다. 그러나 이전 Perl 코드에서 접근자를 제공하는 방법으로 볼 수 있습니다. Perl의 OO 코딩에 대한 권장 사항 은 &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4fca5f01eab824b22bb6b1905a8d483f37ad2ed6" translate="yes" xml:space="preserve">
          <source>As the example shows, if the second argument is an empty string, the category's locale is returned to the default specified by the corresponding environment variables. Generally, this results in a return to the default that was in force when Perl started up: changes to the environment made by the application after startup may or may not be noticed, depending on your system's C library.</source>
          <target state="translated">예제에서 볼 수 있듯이 두 번째 인수가 빈 문자열이면 범주의 로캘이 해당 환경 변수에 지정된 기본값으로 반환됩니다. 일반적으로 이로 인해 Perl이 시작될 때 적용되었던 기본값으로 돌아갑니다. 시스템의 C 라이브러리에 따라 시작 후 응용 프로그램이 작성한 환경의 변경 사항이 눈에 띄거나 나타나지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a3da7dd18a3b2da7c7f36441b50e2eab858828a" translate="yes" xml:space="preserve">
          <source>As the final two examples above show, you can achieve portablity to non-ASCII platforms by using the &lt;code&gt;\N{...}&lt;/code&gt; form for the range endpoints. These indicate that the specified range is to be interpreted using Unicode values, so &lt;code&gt;[\N{U+27}-\N{U+3F}]&lt;/code&gt; means to match &lt;code&gt;\N{U+27}&lt;/code&gt; , &lt;code&gt;\N{U+28}&lt;/code&gt; , &lt;code&gt;\N{U+29}&lt;/code&gt; , ..., &lt;code&gt;\N{U+3D}&lt;/code&gt; , &lt;code&gt;\N{U+3E}&lt;/code&gt; , and &lt;code&gt;\N{U+3F}&lt;/code&gt; , whatever the native code point versions for those are. These are called &quot;Unicode&quot; ranges. If either end is of the &lt;code&gt;\N{...}&lt;/code&gt; form, the range is considered Unicode. A &lt;code&gt;regexp&lt;/code&gt; warning is raised under &lt;code&gt;&quot;use re 'strict'&quot;&lt;/code&gt; if the other endpoint is specified non-portably:</source>
          <target state="translated">위의 마지막 두 예제에서 알 수 있듯이 범위 끝점에 &lt;code&gt;\N{...}&lt;/code&gt; 양식을 사용하여 비 ASCII 플랫폼으로 이식 할 수 있습니다 . 이는 지정된 범위가 유니 코드 값을 사용하여 해석됨을 나타내므로 &lt;code&gt;[\N{U+27}-\N{U+3F}]&lt;/code&gt; 는 &lt;code&gt;\N{U+27}&lt;/code&gt; , &lt;code&gt;\N{U+28}&lt;/code&gt; 과 일치 함을 의미합니다. , &lt;code&gt;\N{U+29}&lt;/code&gt; , ..., &lt;code&gt;\N{U+3D}&lt;/code&gt; , &lt;code&gt;\N{U+3E}&lt;/code&gt; 및 &lt;code&gt;\N{U+3F}&lt;/code&gt; 은 기본 코드 포인트 버전에 관계없이 적용됩니다. 이를 &quot;유니 코드&quot;범위라고합니다. 양쪽 끝이 &lt;code&gt;\N{...}&lt;/code&gt; 형식이면 범위는 유니 코드로 간주됩니다. &quot; &lt;code&gt;regexp&lt;/code&gt; &lt;code&gt;&quot;use re 'strict'&quot;&lt;/code&gt; 에서 regexp 경고가 발생합니다 다른 엔드 포인트가 이식 불가능하게 지정된 경우 :</target>
        </trans-unit>
        <trans-unit id="17c70cf277254845a8ce88c971a047564a105d87" translate="yes" xml:space="preserve">
          <source>As the last character of a prototype, or just before a semicolon, a &lt;code&gt;@&lt;/code&gt; or a &lt;code&gt;%&lt;/code&gt; , you can use &lt;code&gt;_&lt;/code&gt; in place of &lt;code&gt;$&lt;/code&gt; : if this argument is not provided, &lt;code&gt;$_&lt;/code&gt; will be used instead.</source>
          <target state="translated">프로토 타입의 마지막 문자 또는 세미콜론 ( &lt;code&gt;@&lt;/code&gt; 또는 a &lt;code&gt;%&lt;/code&gt; 직전) 으로 &lt;code&gt;$&lt;/code&gt; 대신 &lt;code&gt;_&lt;/code&gt; 을 사용할 수 있습니다 .이 인수가 제공되지 않으면 &lt;code&gt;$_&lt;/code&gt; 이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4b123b1845e08fc58170e4c4c4ab5952b56ae816" translate="yes" xml:space="preserve">
          <source>As the last example indicates, a handler may be set up to be (re)called in two or more phases. The phase name is passed as the handler's final argument.</source>
          <target state="translated">마지막 예에서 알 수 있듯이 핸들러는 둘 이상의 단계에서 (재) 호출되도록 설정할 수 있습니다. 단계 이름은 핸들러의 최종 인수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="776d16ae4f440b015655f81050641c0ec6c3a0f2" translate="yes" xml:space="preserve">
          <source>As the parser reads the second and subsequent lines from the source stream, it feeds those lines through the &lt;code&gt;cpp&lt;/code&gt; source filter before processing them. The &lt;code&gt;cpp&lt;/code&gt; filter simply passes each line through the real C preprocessor. The output from the C preprocessor is then inserted back into the source stream by the filter.</source>
          <target state="translated">파서는 소스 스트림에서 두 번째 및 후속 라인을 읽을 때 처리하기 전에 &lt;code&gt;cpp&lt;/code&gt; 소스 필터를 통해 해당 라인을 공급 합니다. &lt;code&gt;cpp&lt;/code&gt; 필터가 단순히 실제 C 처리기를 통해 각각의 라인을 통과한다. C 전 처리기의 출력은 필터에 의해 소스 스트림으로 다시 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="b29477c3662cd388380e5f2f7edde392d4aa47d3" translate="yes" xml:space="preserve">
          <source>As the parser understands a Perl program, it builds up a tree of operations for the interpreter to perform during execution. The routines which construct and link together the various operations are to be found in</source>
          <target state="translated">파서는 Perl 프로그램을 이해함에 따라 인터프리터가 실행 중에 수행 할 작업 트리를 구성합니다. 다양한 작업을 구성하고 연결하는 루틴은</target>
        </trans-unit>
        <trans-unit id="059620d29d96cd6f5eb8cd327a9137c1f47169b5" translate="yes" xml:space="preserve">
          <source>As there are various Make programs with incompatible syntax, which use operating system shells, again with incompatible syntax, it is important for users of this module to know which flavour of Make a Makefile has been written for so they'll use the correct one and won't have to face the possibly bewildering errors resulting from using the wrong one.</source>
          <target state="translated">운영 체제 쉘을 사용하는 호환되지 않는 구문을 가진 다양한 Make 프로그램이 있으며, 호환되지 않는 구문을 사용하는 경우에도이 모듈의 사용자는 Makefile의 어떤 풍미가 작성된 것인지 알고 있어야 올바른 것을 사용하게됩니다. 잘못된 오류를 사용하여 발생할 수있는 당황스러운 오류에 직면하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="036fd1e2507560ce47135587c83032ff17f1287e" translate="yes" xml:space="preserve">
          <source>As there is an overlap between the error numbers used by</source>
          <target state="translated">에 의해 사용되는 오류 번호가 겹치므로</target>
        </trans-unit>
        <trans-unit id="c2c40011ac031fbcf62ae0096c0f70fe3f04f6d4" translate="yes" xml:space="preserve">
          <source>As told above, Perl 5.6.1 was still good in AmigaOS, as was 5.7.2. After Perl 5.7.2 (change #11423, see the Changes file, and the file pod/perlhack.pod for how to get the individual changes) Perl dropped its internal support for vfork(), and that was very probably the step that broke AmigaOS (since the ixemul library has only vfork). The build finally fails when the ext/DynaLoader is being built, and PERL ends up as &quot;0&quot; in the produced Makefile, trying to run &quot;0&quot; does not quite work. Also, executing miniperl in backticks seems to generate nothing: very probably related to the (v)fork problems. &lt;b&gt;Fixing the breakage requires someone quite familiar with the ixemul library, and how one is supposed to run external commands in AmigaOS without fork().&lt;/b&gt;</source>
          <target state="translated">위에서 언급 한 것처럼 Perl 5.6.1은 5.7.2와 마찬가지로 AmigaOS에서도 여전히 우수했습니다. Perl 5.7.2 (변경 사항 # 11423, 변경 사항 파일 및 개별 변경 사항을 가져 오는 방법에 대해서는 pod / perlhack.pod 파일 참조) 이후 Perl은 vfork ()에 대한 내부 지원을 중단했으며 이는 아마도 실패한 단계 일 것입니다. AmigaOS (ixemul 라이브러리에는 vfork 만 있기 때문에). ext / DynaLoader가 빌드 될 때 빌드가 실패하고 PERL은 생성 된 Makefile에서 &quot;0&quot;으로 끝나고 &quot;0&quot;을 실행하려고 시도하는 것은 효과가 없습니다. 또한 백틱에서 miniperl을 실행하면 아무 것도 생성하지 않는 것 같습니다. 아마도 (v) 포크 문제와 관련이 있습니다. &lt;b&gt;파손을 해결하려면 ixemul 라이브러리에 익숙한 사람이 있어야하며 fork ()없이 AmigaOS에서 외부 명령을 실행하는 방법이 필요합니다.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7df201bc839d821d3a7ec829e521380838b10cef" translate="yes" xml:space="preserve">
          <source>As usual, &lt;code&gt;PL_restartop&lt;/code&gt; is extracted from the &lt;code&gt;CxEVAL&lt;/code&gt; , and a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; done, which pops the C stack back to the docatch:</source>
          <target state="translated">통상, &lt;code&gt;PL_restartop&lt;/code&gt; 는 로부터 추출 &lt;code&gt;CxEVAL&lt;/code&gt; 및 &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; docatch에 C 스택 위로 팝하는 일 :</target>
        </trans-unit>
        <trans-unit id="43f8dfff8ebd277fcb05688b6c5164a9ecb709ab" translate="yes" xml:space="preserve">
          <source>As usual, run</source>
          <target state="translated">평소처럼</target>
        </trans-unit>
        <trans-unit id="6a12281792622fa54248b5b0512161ae986d73ec" translate="yes" xml:space="preserve">
          <source>As we have seen above, Principle 0 overrides the others. The regexp will be matched as early as possible, with the other principles determining how the regexp matches at that earliest character position.</source>
          <target state="translated">위에서 보았 듯이 원리 0은 다른 것들보다 우선합니다. 정규 표현식은 가능한 한 빨리 일치하며 다른 원칙은 정규 표현식이 가장 빠른 문자 위치에서 어떻게 일치하는지 결정합니다.</target>
        </trans-unit>
        <trans-unit id="f24d0557480129d0bec98f1d07b3bc35225e11b2" translate="yes" xml:space="preserve">
          <source>As we mentioned before, Perl's built-in OO system is very minimal, but also quite flexible. Over the years, many people have developed systems which build on top of Perl's built-in system to provide more features and convenience.</source>
          <target state="translated">앞에서 언급했듯이 Perl의 내장 OO 시스템은 매우 작지만 매우 유연합니다. 수년 동안 많은 사람들이 더 많은 기능과 편리함을 제공하기 위해 Perl의 내장 시스템 위에 구축 된 시스템을 개발했습니다.</target>
        </trans-unit>
        <trans-unit id="09f78df2a986a05b74a05b4840bd77f0745f303d" translate="yes" xml:space="preserve">
          <source>As we mentioned before, roles provide an alternative to inheritance, but Perl does not have any built-in role support. If you choose to use Moose, it comes with a full-fledged role implementation. However, if you use one of our other recommended OO modules, you can still use roles with &lt;a href=&quot;http://search.cpan.org/perldoc/Role::Tiny&quot;&gt;Role::Tiny&lt;/a&gt;</source>
          <target state="translated">앞에서 언급했듯이 역할은 상속에 대한 대안을 제공하지만 Perl에는 기본 제공 역할 지원이 없습니다. Moose를 사용하기로 선택한 경우 본격적인 역할 구현이 제공됩니다. 그러나 다른 권장 OO 모듈 중 하나를 사용하면 &lt;a href=&quot;http://search.cpan.org/perldoc/Role::Tiny&quot;&gt;Role :: Tiny&lt;/a&gt; 와 함께 역할을 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f8a13dd0293aebd2b1466f31d349be90b2e062e" translate="yes" xml:space="preserve">
          <source>As we mentioned earlier, Perl provides no special constructor syntax. This means that a class must implement its own constructor. A constructor is simply a class method that returns a reference to a new object.</source>
          <target state="translated">앞에서 언급했듯이 Perl은 특별한 생성자 구문을 제공하지 않습니다. 이것은 클래스가 자체 생성자를 구현해야 함을 의미합니다. 생성자는 단순히 새 객체에 대한 참조를 반환하는 클래스 메서드입니다.</target>
        </trans-unit>
        <trans-unit id="34cb600e9a3f6e5e075e857de4110b1ef2b3324a" translate="yes" xml:space="preserve">
          <source>As we return an empty list, everything is fine.</source>
          <target state="translated">빈 목록을 반환하면 모든 것이 정상입니다.</target>
        </trans-unit>
        <trans-unit id="1bc0081962e83c9753eb5550755ad42af088433e" translate="yes" xml:space="preserve">
          <source>As we said before, Perl's minimal OO system has led to a profusion of OO systems on CPAN. While you can still drop down to the bare metal and write your classes by hand, there's really no reason to do that with modern Perl.</source>
          <target state="translated">앞에서 언급했듯이 Perl의 최소 OO 시스템은 CPAN에서 OO 시스템의 확산으로 이어졌습니다. 베어 메탈로 내려 가서 직접 수업을 작성할 수는 있지만, 현대 펄에서는 그렇게 할 이유가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7867c988c2c06b2c05fdddd86e23a3f47b3a2862" translate="yes" xml:space="preserve">
          <source>As we said earlier, most Perl objects are hashes, but an object can be an instance of any Perl data type (scalar, array, etc.). Turning a plain data structure into an object is done by &lt;b&gt;blessing&lt;/b&gt; that data structure using Perl's &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">앞에서 언급했듯이 대부분의 Perl 객체는 해시이지만 객체는 모든 Perl 데이터 유형 (스칼라, 배열 등)의 인스턴스 일 수 있습니다. 평범한 데이터 구조를 객체로 바꾸는 것은 Perl의 &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 기능을 사용하여 데이터 구조를 &lt;b&gt;축복&lt;/b&gt; 함으로써 이루어집니다 .</target>
        </trans-unit>
        <trans-unit id="504d4df94aa612d7624624e4944523fc3497d648" translate="yes" xml:space="preserve">
          <source>As we saw earlier, an object is simply a data structure that has been blessed into a class via the &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function. The &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function can take either one or two arguments:</source>
          <target state="translated">앞에서 보았 듯이 객체는 단순히 &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 기능을 통해 클래스에 축복 된 데이터 구조입니다 . 는 &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 기능은 하나 또는 두 개의 인수를 취할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="a1d3a4a5afeb3f9e63b11e0b6c656dbcfa8f18b8" translate="yes" xml:space="preserve">
          <source>As we've already shown, &lt;code&gt;call_sv&lt;/code&gt; can be used to invoke an anonymous subroutine. However, our example showed a Perl script invoking an XSUB to perform this operation. Let's see how it can be done inside our C code:</source>
          <target state="translated">이미 &lt;code&gt;call_sv&lt;/code&gt; 를 사용하여 익명 서브 루틴을 호출 할 수 있습니다. 그러나이 예제는이 작업을 수행하기 위해 XSUB를 호출하는 Perl 스크립트를 보여줍니다. C 코드 내에서 어떻게 수행되는지 봅시다 :</target>
        </trans-unit>
        <trans-unit id="96d58f32e93788e5dbef34c03d0df80dbd089dab" translate="yes" xml:space="preserve">
          <source>As well as accessing Berkeley DB using a tied hash or array, it is also possible to make direct use of most of the API functions defined in the Berkeley DB documentation.</source>
          <target state="translated">연결된 해시 또는 배열을 사용하여 Berkeley DB에 액세스 할뿐만 아니라 Berkeley DB 설명서에 정의 된 대부분의 API 함수를 직접 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="749b97b56149a492eb18a4cb65f04d306a596132" translate="yes" xml:space="preserve">
          <source>As well as freeing all the elements of the hash (like hv_clear()), this also frees any auxiliary data and storage associated with the hash.</source>
          <target state="translated">해시의 모든 요소 (예 : hv_clear ())를 비우는 것뿐만 아니라 해시와 관련된 보조 데이터 및 스토리지도 비 웁니다.</target>
        </trans-unit>
        <trans-unit id="2e0710bbe12c8de0ee3e47fce586245cf49652f2" translate="yes" xml:space="preserve">
          <source>As well as grouping, parentheses serve a second purpose. They can be used to capture the results of parts of the regexp match for later use. The results end up in &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; and so on.</source>
          <target state="translated">그룹화뿐만 아니라 괄호는 두 번째 목적을 제공합니다. 그것들은 나중에 사용하기 위해 정규 표현식 부분의 결과를 캡처하는 데 사용될 수 있습니다. 결과는 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; 등이됩니다.</target>
        </trans-unit>
        <trans-unit id="7365f5053276b5ccb78d102d8d65d8a7cbb5a47c" translate="yes" xml:space="preserve">
          <source>As well as these two, there is another converter:</source>
          <target state="translated">이 두 가지 외에도 다른 변환기가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f09c013a494b22fb2c5704b9b33f8690cdb78ae" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairfirst&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 별명 지정 &lt;code&gt;$_&lt;/code&gt; 와 마찬가지로 요소를 나열하기 위해 &lt;code&gt;pairfirst&lt;/code&gt; 별명 &lt;code&gt;$a&lt;/code&gt; 및 &lt;code&gt;$b&lt;/code&gt; 를 주어진 목록의 요소에 쌍으로 지정하십시오. 코드 블록에 의해 수정 된 내용은 호출자가 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ccb264713980d688f5b35e3f78e5d8bcc1b34f2" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairgrep&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="translated">와 같이 &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 에일리어싱 &lt;code&gt;$_&lt;/code&gt; 리스트 요소에 &lt;code&gt;pairgrep&lt;/code&gt; 별명 &lt;code&gt;$a&lt;/code&gt; 및 &lt;code&gt;$b&lt;/code&gt; 주어진리스트의 요소. 코드 블록에 의해 수정 된 내용은 호출자가 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e0ea04c8e6030abec75f8b13970784d2a0b7c8f" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;../functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairmap&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="translated">와 마찬가지로 &lt;code&gt;&lt;a href=&quot;../functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 앨리어싱 &lt;code&gt;$_&lt;/code&gt; 리스트 요소에 대한 &lt;code&gt;pairmap&lt;/code&gt; 별칭 &lt;code&gt;$a&lt;/code&gt; 와 &lt;code&gt;$b&lt;/code&gt; 주어진 목록의 요소. 코드 블록에 의해 수정 된 내용은 호출자가 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="852273f60001fb5cfcfc3f59c366b8a418d217ac" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;gzerror()&lt;/code&gt; it returns an error number in numeric context and an error message in string context. Unlike &lt;code&gt;gzerror()&lt;/code&gt; though, the error message will correspond to the</source>
          <target state="translated">&lt;code&gt;gzerror()&lt;/code&gt; 와 마찬가지로 숫자 컨텍스트에서는 오류 번호를, 문자열 컨텍스트에서는 오류 메시지를 반환합니다. &lt;code&gt;gzerror()&lt;/code&gt; 와 달리 오류 메시지는</target>
        </trans-unit>
        <trans-unit id="89fce7a719c0828fb9010451c52ebed3b12f2d8d" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;mro::get_linear_isa&lt;/code&gt; above, &lt;code&gt;UNIVERSAL&lt;/code&gt; is special. &lt;code&gt;UNIVERSAL&lt;/code&gt; (and parents') isarev lists do not include every class in existence, even though all classes are effectively descendants for method inheritance purposes.</source>
          <target state="translated">와 마찬가지로 &lt;code&gt;mro::get_linear_isa&lt;/code&gt; 위, &lt;code&gt;UNIVERSAL&lt;/code&gt; 은 특별하다. &lt;code&gt;UNIVERSAL&lt;/code&gt; (및 부모)의 isarev 목록은 모든 클래스가 메소드 상속 목적으로 효과적으로 후손이더라도 존재하는 모든 클래스를 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1bfc8628cde1b50356023884cf039103db9706d2" translate="yes" xml:space="preserve">
          <source>As with G_SCALAR, this flag has 2 effects:</source>
          <target state="translated">G_SCALAR와 마찬가지로이 플래그에는 두 가지 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="56fcac1f27b0d72bf38ecab8e2bf923c1135ad6d" translate="yes" xml:space="preserve">
          <source>As with GetOptionsFromArray, a first argument hash reference now becomes the second argument.</source>
          <target state="translated">GetOptionsFromArray와 마찬가지로 첫 번째 인수 해시 참조가 두 번째 인수가됩니다.</target>
        </trans-unit>
        <trans-unit id="f5b2adb567968a40150b99a2b38e37687da34625" translate="yes" xml:space="preserve">
          <source>As with all &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; directives, defining a constant happens at compile time. Thus, it's probably not correct to put a constant declaration inside of a conditional statement (like &lt;code&gt;if ($foo)
{ &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant ... }&lt;/code&gt; ).</source>
          <target state="translated">모든 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 지시문 과 마찬가지로 상수 정의는 컴파일 타임에 발생합니다. 따라서 &lt;code&gt;if ($foo) { &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant ... }&lt;/code&gt; 와 같이 조건문 안에 상수 선언을 넣는 것이 올바르지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9e166bc9c2d17d86e12b7d5456a5dc29e6460a0" translate="yes" xml:space="preserve">
          <source>As with all compiler backend options, these must follow directly after the '-MO=Deparse', separated by a comma but not any white space.</source>
          <target state="translated">모든 컴파일러 백엔드 옵션과 마찬가지로이 옵션은 공백이 아닌 쉼표로 구분 된 '-MO = Deparse'바로 다음에 와야합니다.</target>
        </trans-unit>
        <trans-unit id="dec6818f5ac3b2a14f0cdaa20965c7cdeed80414" translate="yes" xml:space="preserve">
          <source>As with all standard commands, a single-character switch may be clustered with the following switch, if any.</source>
          <target state="translated">모든 표준 명령과 마찬가지로 단일 문자 스위치는 다음 스위치와 함께 클러스터 될 수 있습니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="3f95467f687ea8e2cde45cd2aae56d762c10d52a" translate="yes" xml:space="preserve">
          <source>As with all things in Perl,</source>
          <target state="translated">Perl의 모든 것과 마찬가지로</target>
        </trans-unit>
        <trans-unit id="d4bf4ba0005710853f921b26431dc8a4fd4165e9" translate="yes" xml:space="preserve">
          <source>As with any advisory locking scheme, the protection only works if you systematically use &lt;code&gt;lock_store&lt;/code&gt; and &lt;code&gt;lock_retrieve&lt;/code&gt; . If one side of your application uses &lt;code&gt;store&lt;/code&gt; whilst the other uses &lt;code&gt;lock_retrieve&lt;/code&gt; , you will get no protection at all.</source>
          <target state="translated">권고 잠금 구성표와 마찬가지로 보호는 체계적으로 &lt;code&gt;lock_store&lt;/code&gt; 및 &lt;code&gt;lock_retrieve&lt;/code&gt; 를 사용하는 경우에만 작동합니다 . 애플리케이션의 한쪽이 &lt;code&gt;store&lt;/code&gt; 를 사용하고 다른 쪽이 &lt;code&gt;lock_retrieve&lt;/code&gt; 를 사용하는 경우 전혀 보호를받지 못합니다.</target>
        </trans-unit>
        <trans-unit id="dfdecc72a46325c982361e944a60a5cc48397fb3" translate="yes" xml:space="preserve">
          <source>As with constructors, Perl provides no special accessor declaration syntax, so classes must provide explicitly written accessor methods. There are two common types of accessors, read-only and read-write.</source>
          <target state="translated">생성자와 마찬가지로 Perl은 특별한 접근 자 선언 구문을 제공하지 않으므로 클래스는 명시 적으로 작성된 접근 자 메소드를 제공해야합니다. 접근 자에는 읽기 전용과 읽기 / 쓰기의 두 가지 일반적인 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d06ccd4ce0505718d0adf18033c22a5ca1bc63e" translate="yes" xml:space="preserve">
          <source>As with many unix ports, this one depends on a few &quot;standard&quot; unix utilities which are not necessarily standard for QNX4.</source>
          <target state="translated">많은 유닉스 포트와 마찬가지로, 이것은 하나의 &quot;표준&quot;유닉스 유틸리티에 의존하며, 반드시 QNX4에 대한 표준은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="522d69b5bf4a752ac2eed134a3a3d90b973940bc" translate="yes" xml:space="preserve">
          <source>As with normal Perl arrays, a RECNO array can be accessed using negative indexes. The index -1 refers to the last element of the array, -2 the second last, and so on. Attempting to access an element before the start of the array will raise a fatal run-time error.</source>
          <target state="translated">일반 Perl 배열과 마찬가지로 음수 인덱스를 사용하여 RECNO 배열에 액세스 할 수 있습니다. 인덱스 -1은 배열의 마지막 요소, -2는 두 번째 마지막 요소 등을 나타냅니다. 배열을 시작하기 전에 요소에 액세스하려고하면 치명적인 런타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4f5b532a80f5e05a1cc6284ddbfce49edaec9bba" translate="yes" xml:space="preserve">
          <source>As with postfix array, postfix value slice dereferencing</source>
          <target state="translated">postfix 배열과 마찬가지로 postfix value slice dereferencing</target>
        </trans-unit>
        <trans-unit id="5f2a0ee0b6d450a60b564dbded3394cc767489a2" translate="yes" xml:space="preserve">
          <source>As with subroutines, the type of value returned from a thread's entry point function may be determined by the thread's</source>
          <target state="translated">서브 루틴과 마찬가지로 스레드의 진입 점 함수에서 반환되는 값의 유형은 스레드의</target>
        </trans-unit>
        <trans-unit id="b1cab3e1a5ac11251ae5d77c854023eac88d9ffb" translate="yes" xml:space="preserve">
          <source>As with the</source>
          <target state="translated">와 마찬가지로</target>
        </trans-unit>
        <trans-unit id="cd7300c50635cef829928b369e4af967b57015fd" translate="yes" xml:space="preserve">
          <source>As with the DB_HASH format, it is possible to provide a user defined Perl routine to perform the comparison of keys. By default, though, the keys are stored in lexical order.</source>
          <target state="translated">DB_HASH 형식과 마찬가지로 사용자 정의 Perl 루틴을 제공하여 키 비교를 수행 할 수 있습니다. 그러나 기본적으로 키는 어휘 순서로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="69ca9bf5a86e0011eab25710aa599ffe7224ff94" translate="yes" xml:space="preserve">
          <source>As with the append mode, when you open a file in write-only mode, you can now write to that filehandle using any of &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">추가 모드와 마찬가지로, 쓰기 전용 모드에서 파일을 열면 이제 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; 를 사용하여 해당 파일 핸들에 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a73b99d56aa400ec87ca02454010bfda953deea" translate="yes" xml:space="preserve">
          <source>As with the match &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; operator, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; can use other delimiters, such as &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s!!!&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}{}&lt;/a&gt;&lt;/code&gt;, and even &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}//&lt;/a&gt;&lt;/code&gt;. If single quotes are used &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt;, then the regexp and replacement are treated as single-quoted strings and there are no variable substitutions. &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; in list context returns the same thing as in scalar context, i.e., the number of matches.</source>
          <target state="translated">match &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; operator 와 마찬가지로 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s!!!&lt;/a&gt;&lt;/code&gt; 와 같은 다른 구분 기호를 사용할 수 있습니다 !!! 및 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}{}&lt;/a&gt;&lt;/code&gt; 및 심지어 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}//&lt;/a&gt;&lt;/code&gt; . 작은 따옴표가 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt; 인 경우 정규 표현식과 대체는 작은 따옴표로 처리되며 변수 대체는 없습니다. 리스트 문맥에서 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 는 스칼라 문맥에서와 동일한 것, 즉 일치 횟수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9cd8fd98a0003315162b3999969a156676702a25" translate="yes" xml:space="preserve">
          <source>As with the matching operator, the regexp quote can use different delimiters, e.g., &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr!!&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr{}&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr~~&lt;/a&gt;&lt;/code&gt;. Apostrophes as delimiters (&lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr''&lt;/a&gt;&lt;/code&gt;) inhibit any interpolation.</source>
          <target state="translated">매칭 연산자와 마찬가지로 정규 표현식 따옴표는 다른 구분 기호를 사용할 수 있습니다 (예 : &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr!!&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr{}&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr~~&lt;/a&gt;&lt;/code&gt; . 분리 문자 ( &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr''&lt;/a&gt;&lt;/code&gt; ) 인 아포스트로피 는 모든 보간을 억제합니다.</target>
        </trans-unit>
        <trans-unit id="e11bb01f2bd8c076a80300f6980985d85bb41c1a" translate="yes" xml:space="preserve">
          <source>As with the other types of ties, this method will be called when &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; happens. It may be appropriate to &quot;auto CLOSE&quot; when this occurs. See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;The untie Gotcha&lt;/a&gt; below.</source>
          <target state="translated">다른 유형의 타이와 &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; 메소드는 연결 해제 가 발생 하면 호출됩니다 . 이러한 상황이 발생하면 &quot;자동 닫기&quot;가 적절할 수 있습니다. 아래 &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;의 Untie Gotcha를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4d1c8cd71dac7105bd6440effb2807ea501bbea1" translate="yes" xml:space="preserve">
          <source>As with the other types of ties, this method will be called when the tied handle is about to be destroyed. This is useful for debugging and possibly cleaning up.</source>
          <target state="translated">다른 유형의 타이와 마찬가지로이 메서드는 연결된 핸들이 파괴 되려고 할 때 호출됩니다. 이는 디버깅 및 정리에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c8628e08c07475c8f2b1e6b9f5f0e7ba611079bf" translate="yes" xml:space="preserve">
          <source>As with the return stack, it would be possible (and a small performance win) to pre-extend the return array before pushing data into it, since we know how many elements we will return:</source>
          <target state="translated">리턴 스택과 마찬가지로 데이터를 푸시하기 전에 리턴 배열을 미리 확장하는 것이 가능할 것입니다 (그리고 약간의 성능 승리).</target>
        </trans-unit>
        <trans-unit id="3d4c99ea11e7c5fcd5dc736377914de3be4bac49" translate="yes" xml:space="preserve">
          <source>As with the shell, in Perl the &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; is used to open the file in read-only mode. If it succeeds, Perl allocates a brand new filehandle for you and fills in your previously undefined &lt;code&gt;$handle&lt;/code&gt; argument with a reference to that handle.</source>
          <target state="translated">쉘과 마찬가지로 Perl에서 &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; 는 파일을 읽기 전용 모드로 여는 데 사용됩니다. 성공하면 Perl은 새로운 파일 핸들을 할당하고 이전에 정의되지 않은 &lt;code&gt;$handle&lt;/code&gt; 인수를 해당 핸들에 대한 참조로 채 웁니다 .</target>
        </trans-unit>
        <trans-unit id="7fd1e1a58893cf268ad48b11d78449c12dc31c5c" translate="yes" xml:space="preserve">
          <source>As you can see 3 records have been successfully created with key &lt;code&gt;Wall&lt;/code&gt; - the only thing is, when they are retrieved from the database they</source>
          <target state="translated">보시다시피 &lt;code&gt;Wall&lt;/code&gt; 키를 사용하여 3 개의 레코드가 성공적으로 작성되었습니다 . 데이터베이스에서 검색 할 때만</target>
        </trans-unit>
        <trans-unit id="07a24c035647250238dd385e01e0859319d79ee5" translate="yes" xml:space="preserve">
          <source>As you can see both modules have a broadly similar structure. They both make use of the &lt;code&gt;Filter::Util::Call&lt;/code&gt; module and both have an &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method. The difference between them is that the</source>
          <target state="translated">보시다시피 두 모듈의 구조는 매우 비슷합니다. 둘 다 &lt;code&gt;Filter::Util::Call&lt;/code&gt; 모듈을 사용하고 &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 메소드가 있습니다. 그들 사이의 차이점은</target>
        </trans-unit>
        <trans-unit id="8f994dc63d7341f367ad1cc1ffc63c6ff1af1973" translate="yes" xml:space="preserve">
          <source>As you can see in the synopsis, based on your template, the arguments provided will be validated.</source>
          <target state="translated">시놉시스에서 볼 수 있듯이 템플릿을 기반으로 제공된 인수가 검증됩니다.</target>
        </trans-unit>
        <trans-unit id="fc43df7357cab99ebecef48bb020a483deb5469e" translate="yes" xml:space="preserve">
          <source>As you can see,</source>
          <target state="translated">보다시피,</target>
        </trans-unit>
        <trans-unit id="ba5fcb84fa73471a91e0f59090740d9676a886a8" translate="yes" xml:space="preserve">
          <source>As you can see, a new stream has been created for reading the source from &lt;code&gt;Fred.pm&lt;/code&gt; . This stream will remain active until all of &lt;code&gt;Fred.pm&lt;/code&gt; has been parsed. The source stream for &lt;code&gt;cpp_test&lt;/code&gt; will still exist, but is inactive. Once the parser has finished reading Fred.pm, the source stream associated with it will be destroyed. The source stream for &lt;code&gt;cpp_test&lt;/code&gt; then becomes active again and the parser reads line 4 and subsequent lines from &lt;code&gt;cpp_test&lt;/code&gt; .</source>
          <target state="translated">보다시피 &lt;code&gt;Fred.pm&lt;/code&gt; 에서 소스를 읽기위한 새로운 스트림이 생성되었습니다 . 이 스트림은 모든 &lt;code&gt;Fred.pm&lt;/code&gt; 이 구문 분석 될 때까지 활성 상태를 유지 합니다. &lt;code&gt;cpp_test&lt;/code&gt; 의 소스 스트림 은 여전히 ​​존재하지만 비활성입니다. 파서가 Fred.pm 읽기를 마치면 해당 소스 스트림이 삭제됩니다. 그런 다음 &lt;code&gt;cpp_test&lt;/code&gt; 의 소스 스트림 이 다시 활성화되고 구문 분석기는 &lt;code&gt;cpp_test&lt;/code&gt; 에서 4 행 및 후속 행을 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="413492c2aba459a109ff8cf8bd650d35b867bf30" translate="yes" xml:space="preserve">
          <source>As you can see, even though we parsed out a branch and a piece, it was ultimately only an atom. The final program shows us how things work. We have an &lt;code&gt;EXACT&lt;/code&gt; regop, followed by an &lt;code&gt;END&lt;/code&gt; regop. The number in parens indicates where the &lt;code&gt;regnext&lt;/code&gt; of the node goes. The &lt;code&gt;regnext&lt;/code&gt; of an &lt;code&gt;END&lt;/code&gt; regop is unused, as &lt;code&gt;END&lt;/code&gt; regops mean we have successfully matched. The number on the left indicates the position of the regop in the regnode array.</source>
          <target state="translated">보시다시피, 우리는 가지와 조각을 파싱했지만 궁극적으로는 원자 일뿐입니다. 마지막 프로그램은 작동 방식을 보여줍니다. 우리는 &lt;code&gt;EXACT&lt;/code&gt; regop 다음에 &lt;code&gt;END&lt;/code&gt; regop이 있습니다. 괄호 안의 숫자 는 노드 의 &lt;code&gt;regnext&lt;/code&gt; 이가는 곳을 나타냅니다 . &lt;code&gt;regnext&lt;/code&gt; 의 &lt;code&gt;END&lt;/code&gt; 으로 regop는 사용되지 &lt;code&gt;END&lt;/code&gt; 의 regops 우리가 성공적으로 일치 한 것을 의미한다. 왼쪽의 숫자는 regnode 배열에서 regop의 위치를 ​​나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a413e2eb7d932038f9ab1ac09695763b902b4d80" translate="yes" xml:space="preserve">
          <source>As you can see, it's getting a bit complicated. That's why sometimes is easier to take a temporary on your way through:</source>
          <target state="translated">보다시피, 조금 복잡해지고 있습니다. 그렇기 때문에 때때로 다음과 같은 과정을 거치는 것이 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="3fa1293b0c00ad3a76c1e01bf182a9e2122f9fdc" translate="yes" xml:space="preserve">
          <source>As you can see, the &quot;big end&quot; of the arrow touches the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, which is a nice way to remember that &lt;code&gt;&amp;gt;&lt;/code&gt; is the big-endian modifier. The same obviously works for &lt;code&gt;&amp;lt;&lt;/code&gt; , where the &quot;little end&quot; touches the code.</source>
          <target state="translated">보다시피, 화살표의 &quot;큰 끝&quot;은 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 에 닿습니다. &lt;code&gt;&amp;gt;&lt;/code&gt; 는 빅 엔디안 수정 자라는 것을 기억하는 좋은 방법 입니다. &quot;작은 끝&quot;이 코드에 닿는 &lt;code&gt;&amp;lt;&lt;/code&gt; 에 대해서도 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="8d3da9040412695027bfa4b6fb728646046f3571" translate="yes" xml:space="preserve">
          <source>As you can see, the continuation bytes all begin with &lt;code&gt;&quot;10&quot;&lt;/code&gt; , and the leading bits of the start byte tell how many bytes there are in the encoded character.</source>
          <target state="translated">보다시피, 연속 바이트는 모두 &lt;code&gt;&quot;10&quot;&lt;/code&gt; 으로 시작하고 시작 바이트의 선행 비트는 인코딩 된 문자에 몇 바이트가 있는지 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="3abefb49e57cec4dd056d885964fc7e8cddbabc0" translate="yes" xml:space="preserve">
          <source>As you can see, we've stored the path and file data in the object itself. Remember, under the hood, this object is still just a hash. Later, we'll write accessors to manipulate this data.</source>
          <target state="translated">보시다시피 경로와 파일 데이터를 객체 자체에 저장했습니다. 후드 아래에서이 객체는 여전히 해시 일뿐입니다. 나중에이 데이터를 조작하기 위해 접근자를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="5a6344bf7b33dbff5320cfc2c10a629a29808655" translate="yes" xml:space="preserve">
          <source>As you can tell from a glance at &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;, the L&amp;lt;...&amp;gt; code is the most complex of the Pod formatting codes. The points below will hopefully clarify what it means and how processors should deal with it.</source>
          <target state="translated">&lt;a href=&quot;perlpod&quot;&gt;perlpod를&lt;/a&gt; 한눈에 알 수 있듯이 L &amp;lt;...&amp;gt; 코드는 포드 형식 코드 중 가장 복잡한 코드입니다. 아래의 요점은 그것이 의미하는 바와 프로세서가 어떻게 처리해야 하는지를 명확하게 설명 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="9261097e2916c2cc0f66dd44d4a942cdcbac0f6d" translate="yes" xml:space="preserve">
          <source>As you craft each patch you intend to submit to the Perl core, it's important to write a good commit message. This is especially important if your submission will consist of a series of commits.</source>
          <target state="translated">Perl 코어에 제출할 각 패치를 만들 때 좋은 커밋 메시지를 작성하는 것이 중요합니다. 제출이 일련의 커밋으로 구성된 경우 특히 중요합니다.</target>
        </trans-unit>
        <trans-unit id="585d50527e778d78ffa867804e8d6039ce87d004" translate="yes" xml:space="preserve">
          <source>As you may have inferred from the above documentation and examples, &lt;code&gt;ok&lt;/code&gt; 's prototype is &lt;code&gt;($;$$)&lt;/code&gt; (and, incidentally, &lt;code&gt;skip&lt;/code&gt; 's is &lt;code&gt;($;$$$)&lt;/code&gt;). This means, for example, that you can do &lt;code&gt;ok @foo, @bar&lt;/code&gt; to compare the</source>
          <target state="translated">위의 문서와 예제에서 알 수 있듯이 &lt;code&gt;ok&lt;/code&gt; 의 프로토 타입은 &lt;code&gt;($;$$)&lt;/code&gt; 입니다 (실수로 &lt;code&gt;skip&lt;/code&gt; 은 &lt;code&gt;($;$$$)&lt;/code&gt; 입니다 ). 예를 들어 &lt;code&gt;ok @foo, @bar&lt;/code&gt; 를 사용하여</target>
        </trans-unit>
        <trans-unit id="d3a79c79e4e5a9fafc42ddaaf88736c1e2cc7621" translate="yes" xml:space="preserve">
          <source>As you may have noticed, the name of the FETCH method (et al.) is the same for all accesses, even though the constructors differ in names (TIESCALAR vs TIEARRAY). While in theory you could have the same class servicing several tied types, in practice this becomes cumbersome, and it's easiest to keep them at simply one tie type per class.</source>
          <target state="translated">알다시피, 생성자가 이름이 다르더라도 FETCH 메소드의 이름 (et al.)은 모든 액세스에서 동일합니다 (TIESCALAR vs TIEARRAY). 이론적으로 여러 묶음 유형을 처리하는 동일한 클래스를 가질 수 있지만 실제로는 번거로워지며 클래스 당 하나의 타이 유형으로 유지하는 것이 가장 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="e80271d1fdc3feb0460f1e3a1704fc272e31f101" translate="yes" xml:space="preserve">
          <source>As you might know this calls the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; function of &lt;code&gt;attributes&lt;/code&gt; at compile time with these parameters: 'attributes', the caller's package name, the reference to the code and 'method'.</source>
          <target state="translated">아시다시피 , 컴파일 타임에 'attributes', 호출자의 패키지 이름, 코드에 대한 참조 및 'method'매개 변수를 사용 하여 &lt;code&gt;attributes&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 기능을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="0f14d6a62a3d5dfc412b082b83700a2aa2b31479" translate="yes" xml:space="preserve">
          <source>As you see from those examples, &lt;code&gt;STDOUT&lt;/code&gt; and &lt;code&gt;STDERR&lt;/code&gt; are output handles, and &lt;code&gt;STDIN&lt;/code&gt; and &lt;code&gt;ARGV&lt;/code&gt; are input handles. They are in all capital letters because they are reserved to Perl, much like the &lt;code&gt;@ARGV&lt;/code&gt; array and the &lt;code&gt;%ENV&lt;/code&gt; hash are. Their external associations were set up by your shell.</source>
          <target state="translated">이러한 예에서 볼 수 있듯이 &lt;code&gt;STDOUT&lt;/code&gt; 및 &lt;code&gt;STDERR&lt;/code&gt; 은 출력 핸들이고 &lt;code&gt;STDIN&lt;/code&gt; 및 &lt;code&gt;ARGV&lt;/code&gt; 는 입력 핸들입니다. &lt;code&gt;@ARGV&lt;/code&gt; 배열 및 &lt;code&gt;%ENV&lt;/code&gt; 해시 와 같이 Perl에 예약되어 있기 때문에 대문자로되어 있습니다. 외부 연결은 쉘에서 설정했습니다.</target>
        </trans-unit>
        <trans-unit id="e27f616d9e27793d35d5e898cb0fead7ca633114" translate="yes" xml:space="preserve">
          <source>As you see, it's quite easy to become confused. While some small portion of the blame for this can be attributed to the reference-based implementation, it's really more due to a lack of existing documentation with examples designed for the beginner.</source>
          <target state="translated">보시다시피 혼란스러워지기 쉽습니다. 이것에 대한 책임의 작은 부분은 참조 기반 구현에 기인 할 수 있지만 초보자를 위해 설계된 예제가 포함 된 기존 문서가 없기 때문에 더 큽니다.</target>
        </trans-unit>
        <trans-unit id="512c5953fca52adf9fe503c69215e4eb2353e34b" translate="yes" xml:space="preserve">
          <source>As you see, it's remarkably similar to the Internet domain TCP server, so much so, in fact, that we've omitted several duplicate functions--spawn(), logmsg(), ctime(), and REAPER()--which are the same as in the other server.</source>
          <target state="translated">보시다시피 인터넷 도메인 TCP 서버와 매우 유사하므로 실제로는 여러 중복 함수 (spawn (), logmsg (), ctime () 및 REAPER ())를 생략했습니다. 다른 서버와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="ea8178cd8e63a3e66a311fade3362af15d43aa5f" translate="yes" xml:space="preserve">
          <source>As you see, the name of the package is the name of the structure. Regular fields are just their own names. Plus the following accessor functions are provided for your convenience:</source>
          <target state="translated">보시다시피 패키지 이름은 구조 이름입니다. 일반 필드는 그 자체의 이름입니다. 또한 편의를 위해 다음과 같은 접근 자 기능이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="b457b60332a38dcdc3bc2fb765fda15f087f9402" translate="yes" xml:space="preserve">
          <source>As you see, there is one exception: in ASCII. That way you can assume Goal #1. And with &lt;code&gt;Encode&lt;/code&gt; , Goal #2 is assumed but you still have to be careful in the cases mentioned in the &lt;b&gt;CAVEAT&lt;/b&gt; paragraphs above.</source>
          <target state="translated">보시다시피 ASCII에는 예외가 있습니다. 그렇게하면 목표 # 1을 가정 할 수 있습니다. 그리고 &lt;code&gt;Encode&lt;/code&gt; 를 사용 하면 목표 # 2가 가정되지만 위 의 &lt;b&gt;CAVEAT&lt;/b&gt; 단락에 언급 된 경우에는 여전히주의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7cc089f777993943781491fc9a72f85a9a2f245b" translate="yes" xml:space="preserve">
          <source>As you see, this can be a bit tricky. It's important to realize that a regular expression is merely a set of assertions that gives a definition of success. There may be 0, 1, or several different ways that the definition might succeed against a particular string. And if there are multiple ways it might succeed, you need to understand backtracking to know which variety of success you will achieve.</source>
          <target state="translated">보다시피, 이것은 약간 까다로울 수 있습니다. 정규식은 단지 성공의 정의를 제공하는 일련의 명제임을 인식하는 것이 중요합니다. 정의가 특정 문자열에 대해 성공할 수있는 0, 1 또는 여러 가지 다른 방법이있을 수 있습니다. 성공할 수있는 여러 방법이있는 경우 역 추적을 이해하여 어떤 성공을 거둘 수 있는지 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="f1ce088efa2db68e2d881f71961d1904be5d37ad" translate="yes" xml:space="preserve">
          <source>As you would expect, this modifier causes, for example, &lt;code&gt;\D&lt;/code&gt; to mean the same thing as &lt;code&gt;[^0-9]&lt;/code&gt; ; in fact, all non-ASCII characters match &lt;code&gt;\D&lt;/code&gt; , &lt;code&gt;\S&lt;/code&gt; , and &lt;code&gt;\W&lt;/code&gt; . &lt;code&gt;\b&lt;/code&gt; still means to match at the boundary between &lt;code&gt;\w&lt;/code&gt; and &lt;code&gt;\W&lt;/code&gt; , using the &lt;code&gt;/a&lt;/code&gt; definitions of them (similarly for &lt;code&gt;\B&lt;/code&gt; ).</source>
          <target state="translated">예상 한대로이 수정자는 예를 들어 &lt;code&gt;\D&lt;/code&gt; 가 &lt;code&gt;[^0-9]&lt;/code&gt; 와 같은 것을 의미합니다 . 실제로 모든 비 ASCII 문자는 &lt;code&gt;\D&lt;/code&gt; , &lt;code&gt;\S&lt;/code&gt; 및 &lt;code&gt;\W&lt;/code&gt; 와 일치 합니다. &lt;code&gt;\b&lt;/code&gt; 여전히 경계에 일치하는 것을 의미 &lt;code&gt;\w&lt;/code&gt; 와 &lt;code&gt;\W&lt;/code&gt; 사용 &lt;code&gt;/a&lt;/code&gt; (마찬가지로, 그들에 대한 정의를 &lt;code&gt;\B&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="26154301b1350500c1d0c8c752bea63ea6529192" translate="yes" xml:space="preserve">
          <source>As you're writing an application, you decide as you go what messages you need to emit. Normally you'd go to write this:</source>
          <target state="translated">응용 프로그램을 작성할 때 어떤 메시지를 내 보내야하는지 결정합니다. 일반적으로 다음과 같이 작성합니다.</target>
        </trans-unit>
        <trans-unit id="94a73ad4a31e87483d1616b8954f4b6c0ff428df" translate="yes" xml:space="preserve">
          <source>As you've seen, you can force &lt;code&gt;catdir()&lt;/code&gt; to create an absolute path by passing either an empty string or a path that begins with a volume name as the first argument. However, you are strongly encouraged not to do so, since this is done only for backward compatibility. Newer versions of File::Spec come with a method called &lt;code&gt;catpath()&lt;/code&gt; (see below), that is designed to offer a portable solution for the creation of absolute paths. It takes volume, directory and file portions and returns an entire path. While &lt;code&gt;catdir()&lt;/code&gt; is still suitable for the concatenation of</source>
          <target state="translated">앞에서 본 것처럼 빈 문자열이나 볼륨 이름으로 시작하는 경로를 첫 번째 인수로 전달하여 &lt;code&gt;catdir()&lt;/code&gt; 이 절대 경로를 만들 도록 할 수 있습니다 . 그러나 이전 버전과의 호환성을 위해서만 수행되므로 그렇게하지 않는 것이 좋습니다. 최신 버전의 File :: Spec은 &lt;code&gt;catpath()&lt;/code&gt; (아래 참조 ) 라는 메소드와 함께 제공되며, 절대 경로 작성을위한 휴대용 솔루션을 제공합니다. 볼륨, 디렉토리 및 파일 부분을 차지하고 전체 경로를 반환합니다. &lt;code&gt;catdir()&lt;/code&gt; 은 여전히 ​​연결에 적합 하지만</target>
        </trans-unit>
        <trans-unit id="a173e725607d0f98c78ebac0b31138d8d136aa84" translate="yes" xml:space="preserve">
          <source>Asia</source>
          <target state="translated">Asia</target>
        </trans-unit>
        <trans-unit id="f22fac8ac4e191689a82159394064af8e931487a" translate="yes" xml:space="preserve">
          <source>Aside from an experimental facility (see &lt;a href=&quot;#Signatures&quot;&gt;Signatures&lt;/a&gt; below), Perl does not have named formal parameters. In practice all you do is assign to a &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt; list of these. Variables that aren't declared to be private are global variables. For gory details on creating private variables, see &lt;a href=&quot;#Private-Variables-via-my()&quot;&gt;Private Variables via my()&lt;/a&gt; and &lt;a href=&quot;#Temporary-Values-via-local()&quot;&gt;Temporary Values via local()&lt;/a&gt;. To create protected environments for a set of functions in a separate package (and probably a separate file), see &lt;a href=&quot;perlmod#Packages&quot;&gt;Packages in perlmod&lt;/a&gt;.</source>
          <target state="translated">실험 시설을 제외하고 (아래 &lt;a href=&quot;#Signatures&quot;&gt;서명&lt;/a&gt; 참조) Perl에는 명명 된 공식 매개 변수가 없습니다. 실제로 당신이하는 일은 이것의 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt; 목록에 할당하는 것 입니다. 비공개로 선언되지 않은 변수는 전역 변수입니다. 개인 변수 생성에 대한 자세한 내용은 &lt;a href=&quot;#Private-Variables-via-my()&quot;&gt;my ()를 통한 개인 변수&lt;/a&gt; 및 &lt;a href=&quot;#Temporary-Values-via-local()&quot;&gt;local ()을 통한 임시 값을&lt;/a&gt; 참조하십시오 . 별도의 패키지 (및 아마도 별도의 파일)에서 함수 세트에 대한 보호 된 환경을 작성하려면 &lt;a href=&quot;perlmod#Packages&quot;&gt;perlmod의 패키지를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0befd0a8afa8c19a870d175a4fdb840002143042" translate="yes" xml:space="preserve">
          <source>Ask it to create new Perl executable:</source>
          <target state="translated">새 Perl 실행 파일을 작성하도록 요청하십시오.</target>
        </trans-unit>
        <trans-unit id="06d5ff26b7db3df6b27e4da48afc0d8940af7b07" translate="yes" xml:space="preserve">
          <source>Ask the current maintainer to make you a co-maintainer or transfer the module to you.</source>
          <target state="translated">현재 유지 보수 담당자에게 공동 유지 보수 담당자가되도록하거나 모듈을 귀하에게 양도하도록 요청하십시오.</target>
        </trans-unit>
        <trans-unit id="640918b79c5c24d060028d2fd27fecdba24558af" translate="yes" xml:space="preserve">
          <source>Ask the server for &quot;helpful information&quot; (that's what the RFC says) on the commands it accepts.</source>
          <target state="translated">수락 한 명령에 대한 &quot;유용한 정보&quot;(RFC의 설명)를 서버에 요청하십시오.</target>
        </trans-unit>
        <trans-unit id="29957267ee0cac223134add5f2b52ea620705c23" translate="yes" xml:space="preserve">
          <source>Ask them for it. There are so many email providers available that it's unlikely the local system has any idea how to determine a user's email address.</source>
          <target state="translated">그들에게 물어보세요. 사용 가능한 이메일 제공자가 너무 많아서 로컬 시스템이 사용자의 이메일 주소를 결정하는 방법을 알지 못할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="49bf55dc112eb3597726ba8ecf785a4fae4cbce0" translate="yes" xml:space="preserve">
          <source>Assertions</source>
          <target state="translated">Assertions</target>
        </trans-unit>
        <trans-unit id="00331b7ae6edef1dff40c7175d1e39fd7f33aa69" translate="yes" xml:space="preserve">
          <source>Assertions are conditions that have to be true; they don't actually match parts of the substring. There are six assertions that are written as backslash sequences.</source>
          <target state="translated">주장은 사실이어야하는 조건입니다. 실제로는 부분 문자열의 일부와 일치하지 않습니다. 백 슬래시 시퀀스로 작성된 6 개의 어설 션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc266cdcbb6ece4821fb3ad4912b26e12d68bda4" translate="yes" xml:space="preserve">
          <source>Assigning Magic</source>
          <target state="translated">매직 할당</target>
        </trans-unit>
        <trans-unit id="5758c53717d47b26aecb2f1e95a4e608692a5e69" translate="yes" xml:space="preserve">
          <source>Assigning and Dereferencing Variables.</source>
          <target state="translated">변수 할당 및 역 참조.</target>
        </trans-unit>
        <trans-unit id="d524a6069dcf850237db76c5b77de165e1b358ee" translate="yes" xml:space="preserve">
          <source>Assigning to References</source>
          <target state="translated">참조에 할당</target>
        </trans-unit>
        <trans-unit id="c279a061dbc31dc7bee97d46022b90f62667a4ac" translate="yes" xml:space="preserve">
          <source>Assigning to a list of private variables to name your arguments:</source>
          <target state="translated">인수의 이름을 지정할 개인 변수 목록에 지정 :</target>
        </trans-unit>
        <trans-unit id="5095fe9fb68e9a62edc8c9686322a7856091bd87" translate="yes" xml:space="preserve">
          <source>Assigning to an entry in the hash will cause the time stamps of the file to be modified. If the file does not exist then it will be created. Assigning a single integer to a hash element will cause both the access and modification times to be changed to that value. Alternatively a reference to an array of two values can be passed. The first array element will be used to set the access time and the second element will be used to set the modification time.</source>
          <target state="translated">해시의 항목에 할당하면 파일의 타임 스탬프가 수정됩니다. 파일이 존재하지 않으면 파일이 작성됩니다. 해시 요소에 단일 정수를 할당하면 액세스 및 수정 시간이 모두 해당 값으로 변경됩니다. 또는 두 값의 배열에 대한 참조를 전달할 수 있습니다. 첫 번째 배열 요소는 액세스 시간을 설정하는 데 사용되고 두 번째 요소는 수정 시간을 설정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7ca1018fbacf1aa9c5974935df5ed892f5691b8b" translate="yes" xml:space="preserve">
          <source>Assigning to the special variable $[</source>
          <target state="translated">특수 변수 $ [</target>
        </trans-unit>
        <trans-unit id="7bec00ae67953bf63f8b1b3f8ddf8f9255f79d82" translate="yes" xml:space="preserve">
          <source>Assignment Operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91becff514df4bb52422a8c72ad2fa7e138a09c4" translate="yes" xml:space="preserve">
          <source>Assignment is a little bit special in that it uses its left argument to determine the context for the right argument. Assignment to a scalar evaluates the right-hand side in scalar context, while assignment to an array or hash evaluates the righthand side in list context. Assignment to a list (or slice, which is just a list anyway) also evaluates the right-hand side in list context.</source>
          <target state="translated">할당은 왼쪽 인수를 사용하여 올바른 인수의 컨텍스트를 결정한다는 점에서 약간 특별합니다. 스칼라에 할당하면 스칼라 컨텍스트에서 오른쪽이 평가되고, 배열 또는 해시에 할당되면 목록 컨텍스트에서 오른쪽이 평가됩니다. 리스트 (또는 슬라이스, 어쨌든 단지리스트)에 대한 할당은리스트 컨텍스트에서 오른쪽을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="eeb7b7ef33aeb4c3b9e41b0d3c8c37efe141de32" translate="yes" xml:space="preserve">
          <source>Assignment operators work as in C. That is,</source>
          <target state="translated">할당 연산자는 C에서와 같이 작동합니다. 즉,</target>
        </trans-unit>
        <trans-unit id="e44ee3c1149f2c21100b91bdf4ef60fbcf7575f3" translate="yes" xml:space="preserve">
          <source>Assignment to a typeglob performs an aliasing operation, i.e.,</source>
          <target state="translated">타입 글로브에 할당은 앨리어싱 작업, 즉</target>
        </trans-unit>
        <trans-unit id="101d3fe15227197bfb043f8902c240196099b710" translate="yes" xml:space="preserve">
          <source>Assignment to references and non-references may be combined in lists and conditional ternary expressions, as long as the values on the right-hand side are the right type for each element on the left, though this may make for obfuscated code:</source>
          <target state="translated">오른쪽의 값이 왼쪽의 각 요소에 올바른 유형 인 한 참조 및 비 참조에 대한 지정은 목록 및 조건부 삼항 표현식으로 결합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38be444e6e51033245feebeecd19c780a4190e4e" translate="yes" xml:space="preserve">
          <source>Associated with the matching variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , ... are the &lt;b&gt;backreferences&lt;/b&gt;&lt;code&gt;\g1&lt;/code&gt; , &lt;code&gt;\g2&lt;/code&gt; , ... Backreferences are matching variables that can be used</source>
          <target state="translated">일치하는 변수 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , ... 와 연관된 연관 은 &lt;b&gt;역 참조 &lt;/b&gt; &lt;code&gt;\g1&lt;/code&gt; , &lt;code&gt;\g2&lt;/code&gt; ... 역 참조는 사용할 수있는 일치하는 변수입니다</target>
        </trans-unit>
        <trans-unit id="6addecb62c84d829e48e459ba05882e03a175023" translate="yes" xml:space="preserve">
          <source>Assume &lt;b&gt;anything&lt;/b&gt; about structs (especially the ones you don't control, like the ones coming from the system headers)</source>
          <target state="translated">구조체에 대해 &lt;b&gt;무엇이든&lt;/b&gt; 가정하십시오 (특히 시스템 헤더에서 오는 것과 같이 제어하지 않는 것)</target>
        </trans-unit>
        <trans-unit id="9e766ffb9a2f9804774162774bb465b7a888d65a" translate="yes" xml:space="preserve">
          <source>Assume each sentence ends with two spaces and try to preserve that spacing. Without this option, all consecutive whitespace in non-verbatim paragraphs is compressed into a single space.</source>
          <target state="translated">각 문장이 두 칸으로 끝나고 그 간격을 유지한다고 가정하십시오. 이 옵션이 없으면 비언어적 단락의 모든 연속 공백이 단일 공백으로 압축됩니다.</target>
        </trans-unit>
        <trans-unit id="eb29cb4a3a64a3e55d8f8b66fc5429f33cc90a54" translate="yes" xml:space="preserve">
          <source>Assume four classes, A,B,C &amp;amp; D.</source>
          <target state="translated">A, B, C &amp;amp; D의 네 가지 클래스를 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="900f642b83bb773e589683695c3e83ec1e64d87c" translate="yes" xml:space="preserve">
          <source>Assume nothing about numerical values (&lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;) of characters. Do not use explicit code point ranges (like &lt;code&gt;\xHH-\xHH)&lt;/code&gt; . However, starting in Perl v5.22, regular expression pattern bracketed character class ranges specified like &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/[\N{U+HH}-\N{U+HH}]/&lt;/a&gt;&lt;/code&gt; are portable. You can portably use symbolic character classes like &lt;code&gt;[:print:]&lt;/code&gt;.</source>
          <target state="translated">문자의 숫자 값 ( &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; )에 대해서는 아무 것도 가정하지 마십시오 . 명시적인 코드 포인트 범위 (예 : &lt;code&gt;\xHH-\xHH)&lt;/code&gt; 사용하지 마십시오 . 그러나 Perl v5.22부터 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/[\N{U+HH}-\N{U+HH}]/&lt;/a&gt;&lt;/code&gt; 와 같이 지정된 정규식 패턴 대괄호 문자 클래스 범위 는 이식 가능합니다. &lt;code&gt;[:print:]&lt;/code&gt; 와 같은 기호 문자 클래스를 이식 가능하게 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d225542d9c39b42f29197a0ce47f62fa7382a5c0" translate="yes" xml:space="preserve">
          <source>Assume that an integer cannot take less than 20 bytes of memory, a float cannot take less than 24 bytes, a string cannot take less than 32 bytes (all these examples assume 32-bit architectures, the result are quite a bit worse on 64-bit architectures). If a variable is accessed in two of three different ways (which require an integer, a float, or a string), the memory footprint may increase yet another 20 bytes. A sloppy malloc(3) implementation can inflate these numbers dramatically.</source>
          <target state="translated">정수는 20 바이트 미만의 메모리를 사용할 수없고, 부동 소수점은 24 바이트 미만을, 문자열은 32 바이트 미만을 취할 수 없다고 가정합니다 (이 모든 예제는 32 비트 아키텍처를 가정하며 결과는 64에서 약간 더 나쁩니다. 비트 아키텍처). 정수, 부동 또는 문자열이 필요한 세 가지 방법 중 두 가지 방법으로 변수에 액세스하면 메모리 풋 프린트가 20 바이트 더 증가 할 수 있습니다. 조잡한 malloc (3) 구현은 이러한 숫자를 크게 증가시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cf62705d74f3464ae65764bb487f8249da94d46" translate="yes" xml:space="preserve">
          <source>Assume that the old DLL is named</source>
          <target state="translated">이전 DLL의 이름이 지정되었다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="2605c8584b04c7bf0a2b7cc3badf48edb3bf06d0" translate="yes" xml:space="preserve">
          <source>Assume that you are a seasoned porter, so are sure that all the necessary tools are already present on your system, and you know how to get the Perl source distribution. Untar it, change to the extract directory, and</source>
          <target state="translated">숙련 된 포터라고 가정하고 필요한 모든 도구가 시스템에 이미 존재하는지 확인하고 Perl 소스 배포판을 얻는 방법을 알고 있어야합니다. 압축을 풀고 추출 디렉토리로 변경 한 후</target>
        </trans-unit>
        <trans-unit id="aa1c680a74a55225e27707c2ac5fffa720c70f93" translate="yes" xml:space="preserve">
          <source>Assume this TAP version for &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt; instead of default TAP version 12.</source>
          <target state="translated">기본 TAP 버전 12 대신 &lt;a href=&quot;parser&quot;&gt;TAP :: Parser에&lt;/a&gt; 대해이 TAP 버전을 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="7fc8664d84c1446907ca24dadecd0bd664e1d82d" translate="yes" xml:space="preserve">
          <source>Assume very little about character sets.</source>
          <target state="translated">문자 집합에 대해 거의 가정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="2b3c42e666c3f46061cf3e08ae5f736db9c6b58e" translate="yes" xml:space="preserve">
          <source>Assumes that PL_op is the op that originally triggered the error, and that PL_comppad/PL_curpad points to the currently executing pad.</source>
          <target state="translated">PL_op이 원래 오류를 트리거 한 op이고 PL_comppad / PL_curpad가 현재 실행중인 패드를 가리키는 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="85a92465c7801a7593ae125acb124d7a78d00d62" translate="yes" xml:space="preserve">
          <source>Assuming one can dereference any type of pointer for any type of data</source>
          <target state="translated">모든 유형의 데이터에 대해 모든 유형의 포인터를 역 참조 할 수 있다고 가정</target>
        </trans-unit>
        <trans-unit id="3eba801518ac20c3e71b66588e69e8412d142226" translate="yes" xml:space="preserve">
          <source>Assuming sizeof(int) == sizeof(long)</source>
          <target state="translated">sizeof (int) == sizeof (long) 가정</target>
        </trans-unit>
        <trans-unit id="3b4336515b2aaf87ea7abdf5569d5fbbc17ae08d" translate="yes" xml:space="preserve">
          <source>Assuming that the &lt;code&gt;man&lt;/code&gt; -files were put on an appropriate location, this completes the installation of minimal Perl system. (The binary distribution contains also a lot of additional modules, and the documentation in INF format.)</source>
          <target state="translated">&lt;code&gt;man&lt;/code&gt; 파일 이 적절한 위치에 있다고 가정하면 최소 Perl 시스템 설치가 완료됩니다. (이진 배포판에는 많은 추가 모듈과 INF 형식의 설명서가 포함되어 있습니다.)</target>
        </trans-unit>
        <trans-unit id="1b3d48dcc2393b6165f22e974c8fe37cb11cfa92" translate="yes" xml:space="preserve">
          <source>Assuming that we have to match calendar dates which may be given in one of the three formats yyyy-mm-dd, mm/dd/yyyy or dd.mm.yyyy, we can write three suitable patterns where we use 'd', 'm' and 'y' respectively as the names of the groups capturing the pertaining components of a date. The matching operation combines the three patterns as alternatives:</source>
          <target state="translated">yyyy-mm-dd, mm / dd / yyyy 또는 dd.mm.yyyy의 세 가지 형식 중 하나로 제공되는 달력 날짜와 일치해야한다고 가정하면 'd', ' m '및'y '는 각각 날짜의 관련 구성 요소를 캡처하는 그룹의 이름입니다. 일치 작업은 세 가지 패턴을 대안으로 결합합니다.</target>
        </trans-unit>
        <trans-unit id="0518d034f096809ab863fb80241126fe45a3c2bb" translate="yes" xml:space="preserve">
          <source>Assuming that you don't care about IEEE notations like &quot;NaN&quot; or &quot;Infinity&quot;, you probably just want to use a regular expression:</source>
          <target state="translated">&quot;NaN&quot;또는 &quot;Infinity&quot;와 같은 IEEE 표기법에 신경 쓰지 않는다고 가정하면 정규 표현식을 사용하고 싶을 것입니다.</target>
        </trans-unit>
        <trans-unit id="c5c2ab31ddb2d4e68552f61633bf186e98613579" translate="yes" xml:space="preserve">
          <source>Assuming the character set is ASCIIish</source>
          <target state="translated">문자 세트가 ASCII 인 것으로 가정</target>
        </trans-unit>
        <trans-unit id="657e33b27d387873c824a6e9282e0d4e22ed782e" translate="yes" xml:space="preserve">
          <source>Assuming the character set is just ASCII</source>
          <target state="translated">문자 집합이 ASCII라고 가정</target>
        </trans-unit>
        <trans-unit id="7e0c2159a115b592c79f24b1d84f43c005948de3" translate="yes" xml:space="preserve">
          <source>Assuming the contents of static memory pointed to by the return values of Perl wrappers for C library functions doesn't change. Many C library functions return pointers to static storage that can be overwritten by subsequent calls to the same or related functions. Perl has light-weight wrappers for some of these functions, and which don't make copies of the static memory. A good example is the interface to the environment variables that are in effect for the program. Perl has &lt;code&gt;PerlEnv_getenv&lt;/code&gt; to get values from the environment. But the return is a pointer to static memory in the C library. If you are using the value to immediately test for something, that's fine, but if you save the value and expect it to be unchanged by later processing, you would be wrong, but perhaps you wouldn't know it because different C library implementations behave differently, and the one on the platform you're testing on might work for your situation. But on some platforms, a subsequent call to &lt;code&gt;PerlEnv_getenv&lt;/code&gt; or related function WILL overwrite the memory that your first call points to. This has led to some hard-to-debug problems. Do a &lt;a href=&quot;perlapi#savepv&quot;&gt;savepv in perlapi&lt;/a&gt; to make a copy, thus avoiding these problems. You will have to free the copy when you're done to avoid memory leaks. If you don't have control over when it gets freed, you'll need to make the copy in a mortal scalar, like so:</source>
          <target state="translated">C 라이브러리 함수에 대한 Perl 랩퍼의 리턴 값이 가리키는 정적 메모리의 내용이 변경되지 않는다고 가정하십시오. 많은 C 라이브러리 함수는 동일한 또는 관련 함수에 대한 후속 호출로 덮어 쓸 수있는 정적 스토리지에 대한 포인터를 리턴합니다. Perl에는 이러한 기능 중 일부를위한 경량 래퍼가 있으며 정적 메모리를 복사하지 않습니다. 좋은 예는 프로그램에 적용되는 환경 변수에 대한 인터페이스입니다. Perl은 &lt;code&gt;PerlEnv_getenv&lt;/code&gt; 를 가지고 있습니다환경으로부터 가치를 얻습니다. 그러나 리턴은 C 라이브러리의 정적 메모리에 대한 포인터입니다. 값을 사용하여 즉시 무언가를 테스트하는 경우 괜찮습니다.하지만 값을 저장하고 나중에 처리해도 변경되지 않을 것으로 예상되는 경우 잘못된 것이지만 다른 C 라이브러리 구현이 작동하기 때문에 알 수 없을 것입니다 테스트하고있는 플랫폼의 플랫폼이 상황에 따라 작동 할 수 있습니다. 그러나 일부 플랫폼에서는 &lt;code&gt;PerlEnv_getenv&lt;/code&gt; 또는 관련 함수에 대한 후속 호출이 첫 번째 호출이 가리키는 메모리를 덮어 씁니다. 이로 인해 디버그하기 어려운 문제가 발생했습니다. DO가 &lt;a href=&quot;perlapi#savepv&quot;&gt;perlapi에서 savepv을&lt;/a&gt;복사하여 이러한 문제를 피하십시오. 메모리 누수를 피하려면 복사를 해제해야합니다. 해제 될 때 제어 할 수없는 경우 다음과 같이 필멸의 스칼라로 사본을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="3368b5431ec704ea21f8185fe92770b3b042af71" translate="yes" xml:space="preserve">
          <source>Assuming the database from the previous example:</source>
          <target state="translated">이전 예제의 데이터베이스를 가정하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="37f2465394b9cbdd91947c6e4e077a7d4b7dde8a" translate="yes" xml:space="preserve">
          <source>Assuming they are to behave analogously to Perl's &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; , overloaded implementations of these operators are required to mutate their operands.</source>
          <target state="translated">그들은 유사 펄에 행동이다 가정 &lt;code&gt;++&lt;/code&gt; 와 &lt;code&gt;--&lt;/code&gt; ,이 연산자의 오버로드 구현은 피연산자를 돌연변이해야합니다.</target>
        </trans-unit>
        <trans-unit id="23383c34471c75b25927cfad7162ad1979bea49b" translate="yes" xml:space="preserve">
          <source>Assuming you call your class Projname::L10N, create a class consisting minimally of:</source>
          <target state="translated">Projname :: L10N 클래스를 호출한다고 가정하면 최소한으로 구성된 클래스를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="a8c3ccec4be1ea177d36a955790696ae747518f7" translate="yes" xml:space="preserve">
          <source>Assuming you have good test coverage, your tests should fail with missing dependencies informing the user more strongly that something is wrong. You can write a</source>
          <target state="translated">테스트 범위가 양호하다고 가정하면 종속성이 누락되어 테스트에 실패하여 사용자에게 무언가 잘못되었음을 더 강력하게 알려줍니다. 당신은 쓸 수 있습니다</target>
        </trans-unit>
        <trans-unit id="562091b17215c5d2dabd5a6d27106f5a063623cd" translate="yes" xml:space="preserve">
          <source>Assuming you know you're dealing with a UTF-8 string, you can find out how long the first character in it is with the &lt;code&gt;UTF8SKIP&lt;/code&gt; macro:</source>
          <target state="translated">UTF-8 문자열을 다루고 있다고 가정하면 첫 번째 문자가 &lt;code&gt;UTF8SKIP&lt;/code&gt; 매크로 와 얼마나 긴지 알 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9da798a9d5da7f2f9d9ef9e1b52ebf21c8c17dc7" translate="yes" xml:space="preserve">
          <source>Assuming you're running under sufficient permissions, you should be able to set the system-wide date and time by running the &lt;code&gt;date(1)&lt;/code&gt; program. (There is no way to set the time and date on a per-process basis.) This mechanism will work for Unix, MS-DOS, Windows, and NT; the VMS equivalent is &lt;code&gt;set &lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; .</source>
          <target state="translated">충분한 권한으로 실행되고 있다고 가정하면 &lt;code&gt;date(1)&lt;/code&gt; 프로그램 을 실행하여 시스템 전체 날짜 및 시간을 설정할 수 있어야합니다 . 프로세스별로 시간과 날짜를 설정할 수있는 방법은 없습니다.이 메커니즘은 Unix, MS-DOS, Windows 및 NT에서 작동합니다. VMS와 동등한 &lt;code&gt;set &lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 이 설정 됩니다 .</target>
        </trans-unit>
        <trans-unit id="a50f834fa5c7b73ada293aca740d6156afc09752" translate="yes" xml:space="preserve">
          <source>Assuming your system supports such things, just send an appropriate signal to the process (see &lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;). It's common to first send a TERM signal, wait a little bit, and then send a KILL signal to finish it off.</source>
          <target state="translated">시스템이 그러한 것들을 지원한다고 가정하면 적절한 신호를 프로세스에 보내십시오 ( &lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; 참조 ). TERM 신호를 먼저 보내고 약간 기다린 다음 KILL 신호를 보내서 종료하는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="a34c6deba477e26d8810a3f5cd4114d33aa1e300" translate="yes" xml:space="preserve">
          <source>At 10:23, this function generates the 10th line of a data file; at 3:45 PM it generates the 15th line instead. By default, &lt;code&gt;Memoize&lt;/code&gt; will only see the $problem_type argument. To fix this, include the current hour in the normalizer:</source>
          <target state="translated">10:23에서이 함수는 데이터 파일의 10 번째 줄을 생성합니다. 오후 3시 45 분에 대신 15 번째 줄을 생성합니다. 기본적으로 &lt;code&gt;Memoize&lt;/code&gt; 에는 $ problem_type 인수 만 표시됩니다. 이 문제를 해결하려면 노멀 라이저에 현재 시간을 포함 시키십시오.</target>
        </trans-unit>
        <trans-unit id="0d3035d43f34a8f68a2af535ff4afe837cc1bf23" translate="yes" xml:space="preserve">
          <source>At a given character position, the first alternative that allows the regex match to succeed will be the one that matches. Here, all the alternatives match at the first string position, so the first matches.</source>
          <target state="translated">주어진 문자 위치에서 정규 표현식 일치를 허용하는 첫 번째 대안이 일치하는 것입니다. 여기서 모든 대안은 첫 번째 문자열 위치에서 일치하므로 첫 번째 문자열이 일치합니다.</target>
        </trans-unit>
        <trans-unit id="fa1efd2d4349c6ea79b9b9fc2089c111f8b1ca40" translate="yes" xml:space="preserve">
          <source>At any given time, exactly one of these modifiers is in effect. Their existence allows Perl to keep the originally compiled behavior of a regular expression, regardless of what rules are in effect when it is actually executed. And if it is interpolated into a larger regex, the original's rules continue to apply to it, and only it.</source>
          <target state="translated">주어진 시간에 이러한 수정 자 중 정확히 하나가 적용됩니다. 이것의 존재로 인해 Perl은 실제로 실행될 때 어떤 규칙이 적용되는지에 관계없이 정규식의 원래 컴파일 된 동작을 유지할 수 있습니다. 그리고 더 큰 정규식으로 보간되면 원본의 규칙이 계속 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="7593f9fb00e51f006212d276b2834d5cb1e7bd4c" translate="yes" xml:space="preserve">
          <source>At any rate, the very use of &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; is questionable when it comes to unicode characters since you have to consider such things as character width (i.e. double-width for ideographs) and directions (i.e. BIDI for Arabic and Hebrew).</source>
          <target state="translated">어쨌든 문자 너비 (아이디어 그래프의 경우 두 배 너비) 및 방향 (예 : 아랍어 및 히브리어의 경우 BIDI)과 같은 항목을 고려해야하기 때문에 유니 코드 문자의 경우 &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; 매우 많이 사용하는 것은 의문의 여지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="40530b4cf9ab5b3f6391788f6f588ae031f72498" translate="yes" xml:space="preserve">
          <source>At deserialization time, you will be given back the same LIST, but all the extra references will be pointing into the deserialized structure.</source>
          <target state="translated">역 직렬화시에는 동일한 LIST가 다시 제공되지만 모든 추가 참조는 역 직렬화 된 구조를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="2359fa76d13a340de35eda7f896e38293fc5d5aa" translate="yes" xml:space="preserve">
          <source>At each stack level, the subroutine's name is displayed along with its parameters. For simple scalars, this is sufficient. For complex data types, such as objects and other references, this can simply display &lt;code&gt;'HASH(0x1ab36d8)'&lt;/code&gt; .</source>
          <target state="translated">각 스택 레벨에서 서브 루틴의 이름이 매개 변수와 함께 표시됩니다. 간단한 스칼라의 경우 이것으로 충분합니다. 객체 및 기타 참조와 같은 복잡한 데이터 유형의 경우 단순히 &lt;code&gt;'HASH(0x1ab36d8)'&lt;/code&gt; 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="396433f01b9bc30bd1dc987a608f2db8a7b54ded" translate="yes" xml:space="preserve">
          <source>At entry points to perl, such as &lt;code&gt;perl_parse()&lt;/code&gt; , &lt;code&gt;perl_run()&lt;/code&gt; and &lt;code&gt;call_sv(cv, G_EVAL)&lt;/code&gt; each does a &lt;code&gt;JMPENV_PUSH&lt;/code&gt; , then enter a runops loop or whatever, and handle possible exception returns. For a 2 return, final cleanup is performed, such as popping stacks and calling &lt;code&gt;CHECK&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt; blocks. Amongst other things, this is how scope cleanup still occurs during an &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;perl_parse()&lt;/code&gt; , &lt;code&gt;perl_run()&lt;/code&gt; 및 &lt;code&gt;call_sv(cv, G_EVAL)&lt;/code&gt; 과 같은 perl의 진입 점에서 각각 &lt;code&gt;JMPENV_PUSH&lt;/code&gt; 를 수행 한 다음 runops 루프 또는 기타를 입력하고 가능한 예외 리턴을 처리합니다. 2 리턴의 경우 스택 팝핑 및 &lt;code&gt;CHECK&lt;/code&gt; 또는 &lt;code&gt;END&lt;/code&gt; 블록 호출과 같은 최종 정리가 수행 됩니다. 무엇보다도 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; 중에 스코프 정리가 여전히 발생하는 방식 입니다.</target>
        </trans-unit>
        <trans-unit id="3b52a6611c3d532a492a587178e19cf7d8fea481" translate="yes" xml:space="preserve">
          <source>At first glance, you'd think that it shouldn't print, because obviously the &lt;code&gt;ddd&lt;/code&gt; isn't going to match the target string. But look at this example:</source>
          <target state="translated">언뜻보기에는 &lt;code&gt;ddd&lt;/code&gt; 가 대상 문자열과 일치하지 않기 때문에 인쇄하지 않아야한다고 생각할 것입니다 . 그러나이 예를보십시오 :</target>
        </trans-unit>
        <trans-unit id="a20d2e5d0ab73a1c97b3463749bc6385228a9028" translate="yes" xml:space="preserve">
          <source>At least for consistency with WinNT, you should keep the recommended value.</source>
          <target state="translated">최소한 WinNT와 일관성을 유지하려면 권장 값을 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="27bd45d9389cf551091228f338420922ea6613d9" translate="yes" xml:space="preserve">
          <source>At least in Unix you may be able to get past this by increasing your process datasize limits: in csh/tcsh use &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;limit datasize n&lt;/code&gt; (where &lt;code&gt;n&lt;/code&gt; is the number of kilobytes) to check the current limits and change them, and in ksh/bash/zsh use &lt;code&gt;ulimit -a&lt;/code&gt; and &lt;code&gt;ulimit -d n&lt;/code&gt; , respectively.</source>
          <target state="translated">적어도 유닉스에서는 프로세스 데이터 크기 제한을 늘려서 이것을 극복 할 수 있습니다 : csh / tcsh 사용 &lt;code&gt;limit&lt;/code&gt; 및 &lt;code&gt;limit datasize n&lt;/code&gt; (여기서 &lt;code&gt;n&lt;/code&gt; 은 킬로바이트 수) 및 현재 제한을 확인하고 변경하십시오. / bash / zsh는 각각 &lt;code&gt;ulimit -a&lt;/code&gt; 및 &lt;code&gt;ulimit -d n&lt;/code&gt; 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="be275e2a07874324b642ea6224748e1cc7c92b91" translate="yes" xml:space="preserve">
          <source>At least it's backwards compatible in not doing much.</source>
          <target state="translated">적어도 많이하지 않으면 역 호환성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e14e0bb06602e8d806ecd5603df3d1331d55d06" translate="yes" xml:space="preserve">
          <source>At least one of &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt; must have a goal (at least one of &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;l2&lt;/code&gt; must be non-zero), and if both do, both have to be reached for a successful match. Also, if the fold of a character is multiple characters, all of them must be matched (see tr21 reference below for 'folding').</source>
          <target state="translated">&lt;code&gt;s1&lt;/code&gt; 및 &lt;code&gt;s2&lt;/code&gt; 중 하나 이상 에 목표가 있어야하며 ( &lt;code&gt;l1&lt;/code&gt; 및 &lt;code&gt;l2&lt;/code&gt; 중 하나 이상 이 0이 아니어야 함) 두 목표가 모두 일치해야 성공적으로 일치 할 수 있습니다. 또한 문자의 접기가 여러 문자 인 경우 모든 문자가 일치해야합니다 ( '접기'에 대해서는 아래 tr21 참조 참조).</target>
        </trans-unit>
        <trans-unit id="9972c1cfc00f54bc3d4bf6854c0d9453527f2493" translate="yes" xml:space="preserve">
          <source>At least the three builtin functions &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined(...)&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists(...)&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(...)&lt;/a&gt;&lt;/code&gt;. We might someday add more of these later if we think of them.</source>
          <target state="translated">기능 내장 세 적어도 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined(...)&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists(...)&lt;/a&gt;&lt;/code&gt; 하고, &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(...)&lt;/a&gt;&lt;/code&gt; . 우리가 언젠가 그것들을 생각한다면 이것들을 더 추가 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc8bf4c3c86adf3ceb8a466491ba399fbc2b4c86" translate="yes" xml:space="preserve">
          <source>At line number 4 is a helpful pointer, that tells you where you are now. To see more code, type 'v' again:</source>
          <target state="translated">4 번 줄에는 현재 위치를 알려주는 유용한 포인터가 있습니다. 더 많은 코드를 보려면 'v'를 다시 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="3706bce960e08579e2a93b26085ef7458b3bba0d" translate="yes" xml:space="preserve">
          <source>At present that list is: weaken, isweak, dualvar, isvstring, set_prototype</source>
          <target state="translated">현재이 목록은 약화, 약화, 이중 변수, isvstring, set_prototype입니다.</target>
        </trans-unit>
        <trans-unit id="a9a7ccc891020b1abe97ef7e238b5077a99ae99b" translate="yes" xml:space="preserve">
          <source>At present three compression methods are supported by IO::Compress::Zip, namely Store (no compression at all), Deflate, Bzip2 and LZMA.</source>
          <target state="translated">현재 IO :: Compress :: Zip, 즉 Store (압축 없음), Deflate, Bzip2 및 LZMA의 세 가지 압축 방법이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="c6f3b56326d807044d12f7fa90b19c7ea2469f7b" translate="yes" xml:space="preserve">
          <source>At present, the first time you iterate over %ENV using &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt;, you will incur a time penalty as all logical names are read, in order to fully populate %ENV. Subsequent iterations will not reread logical names, so they won't be as slow, but they also won't reflect any changes to logical name tables caused by other programs.</source>
          <target state="translated">현재 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 를 사용하여 % ENV를 처음 반복 할 때, % ENV를 완전히 채우려면 모든 논리적 이름을 읽을 때 시간 패널티가 발생합니다. 후속 반복은 논리적 이름을 다시 읽지 않으므로 느리지는 않지만 다른 프로그램으로 인한 논리적 이름 테이블의 변경 사항은 반영하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="25d8707372413087d65e69b61d9a6dc703b71cf2" translate="yes" xml:space="preserve">
          <source>At run time, each listed plugin is instantiated as a singleton object by running the equivalent of this pseudo code:</source>
          <target state="translated">런타임에 나열된 각 플러그인은 다음 의사 코드와 동일한 기능을 실행하여 단일 객체로 인스턴스화됩니다.</target>
        </trans-unit>
        <trans-unit id="0346a8b0d676351a6882db32e2f71fe2cd6612af" translate="yes" xml:space="preserve">
          <source>At run-time you can use:</source>
          <target state="translated">런타임에 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14c311a97bb302da658b5d5c146d94913481c6a7" translate="yes" xml:space="preserve">
          <source>At some moment the built may die, reporting a</source>
          <target state="translated">언젠가 빌드가 죽을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f94eca0c2d56d19683ad85c3b3f54fed0ab0893" translate="yes" xml:space="preserve">
          <source>At the 2008 QA Hackathon in Oslo, Perl module toolchain maintainers agrees to use the CPAN Meta format to communicate post-configuration requirements between toolchain components. These files,</source>
          <target state="translated">Oslo의 2008 QA Hackathon에서 Perl 모듈 툴체인 관리자는 CPAN 메타 형식을 사용하여 툴체인 구성 요소간에 구성 후 요구 사항을 전달하는 데 동의합니다. 이 파일들은</target>
        </trans-unit>
        <trans-unit id="86950d72bad1114392fd499fea36a75e7faf16d6" translate="yes" xml:space="preserve">
          <source>At the cost of a slight header overhead, you may store to an already opened file descriptor using the &lt;code&gt;store_fd&lt;/code&gt; routine, and retrieve from a file via &lt;code&gt;fd_retrieve&lt;/code&gt; . Those names aren't imported by default, so you will have to do that explicitly if you need those routines. The file descriptor you supply must be already opened, for read if you're going to retrieve and for write if you wish to store.</source>
          <target state="translated">약간의 헤더 오버 헤드 비용에서, 당신은 사용하여 이미 열려있는 파일 기술자에 저장할 수 &lt;code&gt;store_fd&lt;/code&gt; 의 루틴을, 그리고를 통해 파일에서 검색 &lt;code&gt;fd_retrieve&lt;/code&gt; . 이러한 이름은 기본적으로 가져 오지 않으므로 해당 루틴이 필요한 경우 명시 적으로 지정해야합니다. 제공하려는 파일 디스크립터는 이미 열람해야합니다. 검색하려는 경우 읽기 및 저장하려는 경우 쓰기를 위해.</target>
        </trans-unit>
        <trans-unit id="5655f269f9dae667811a30ef2f8f926fc9530ad6" translate="yes" xml:space="preserve">
          <source>At the end of</source>
          <target state="translated">끝에</target>
        </trans-unit>
        <trans-unit id="9572ac86c1b1da5c7ab83dd35ce00912ee7e613d" translate="yes" xml:space="preserve">
          <source>At the end of all &lt;code&gt;when&lt;/code&gt; blocks, there is an implicit &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;. You can override that with an explicit &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; if you're interested in only the first match alone.</source>
          <target state="translated">모든 &lt;code&gt;when&lt;/code&gt; 블록 의 끝에는 암시적인 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 가 있습니다. 첫 번째 경기에만 관심이 있다면 명시적인 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 으로 덮어 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ca6a702d6cdcdadecdbaeb43444eca515cc146c7" translate="yes" xml:space="preserve">
          <source>At the end of the parse, call &lt;code&gt;$parser-&amp;gt;root&lt;/code&gt; to get the tree's top node.</source>
          <target state="translated">구문 분석이 끝나면 &lt;code&gt;$parser-&amp;gt;root&lt;/code&gt; 를 호출 하여 트리의 최상위 노드를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="07a9cc69765068861817ec41e4a7228bd113195b" translate="yes" xml:space="preserve">
          <source>At the lowest level, the macros new_SV() and del_SV() grab and free an SV head. (If debugging with -DD, del_SV() calls the function S_del_sv() to return the SV to the free list with error checking.) new_SV() calls more_sv() / sv_add_arena() to add an extra arena if the free list is empty. SVs in the free list have their SvTYPE field set to all ones.</source>
          <target state="translated">가장 낮은 수준에서 매크로 new_SV () 및 del_SV ()는 SV 헤드를 잡고 해제합니다. (-DD로 디버깅하는 경우 del_SV ()는 S_del_sv () 함수를 호출하여 SV를 오류 검사와 함께 사용 가능한 목록으로 리턴합니다.) new_SV ()는 more_sv () / sv_add_arena ()를 호출하여 사용 가능한 목록이있는 경우 추가 아레나를 추가합니다 빈. 비어있는 목록의 SV는 SvTYPE 필드가 모두 1로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6089cbc08fb43732445842a261366b161cee7872" translate="yes" xml:space="preserve">
          <source>At the moment of writing, AIX supports two different native C compilers, for which you have to pay: &lt;b&gt;xlC&lt;/b&gt; and &lt;b&gt;vac&lt;/b&gt;. If you decide to use either of these two (which is quite a lot easier than using gcc), be sure to upgrade to the latest available patch level. Currently:</source>
          <target state="translated">글을 쓰는 시점에서 AIX는 두 개의 다른 네이티브 C 컴파일러 ( &lt;b&gt;xlC&lt;/b&gt; 및 &lt;b&gt;vac)를 지원&lt;/b&gt; 합니다. 이 두 가지 중 하나를 사용하기로 결정한 경우 (gcc를 사용하는 것보다 훨씬 쉽습니다) 사용 가능한 최신 패치 수준으로 업그레이드하십시오. 현재 :</target>
        </trans-unit>
        <trans-unit id="af7b9b33fafaf83f9420acb89bb16618e9123d52" translate="yes" xml:space="preserve">
          <source>At the risk of stating the obvious, modules are intended to be modular. A Perl developer should be able to use modules to put together the building blocks of their application. However, it's important that the blocks are the right shape, and that the developer shouldn't have to use a big block when all they need is a small one.</source>
          <target state="translated">명백한 내용을 표시 할 위험이있는 모듈은 모듈 식입니다. Perl 개발자는 모듈을 사용하여 애플리케이션의 빌딩 블록을 구성 할 수 있어야합니다. 그러나 블록이 올바른 모양이어야하고 개발자가 필요로하는 모든 것이 작은 블록 일 때 큰 블록을 사용할 필요가 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="d2c548d72452435d78a5e713661472ad87fa3347" translate="yes" xml:space="preserve">
          <source>At the time of this writing (2009-03) there are three YAML implementations working: YAML, YAML::Syck, and YAML::XS. The latter two are faster but need a C compiler installed on your system. There may be more alternative YAML conforming modules. When I tried two other players, YAML::Tiny and YAML::Perl, they seemed not powerful enough to work with CPAN.pm. This may have changed in the meantime.</source>
          <target state="translated">이 글을 쓰는 시점 (2009-03)에는 YAML, YAML :: Syck 및 YAML :: XS의 세 가지 YAML 구현이 작동합니다. 후자는 빠르지 만 시스템에 C 컴파일러가 설치되어 있어야합니다. 대체 YAML 준수 모듈이있을 수 있습니다. 다른 두 명의 플레이어 인 YAML :: Tiny와 YAML :: Perl을 시도했을 때 CPAN.pm을 사용할 수있을만큼 강력하지 않은 것 같습니다. 그 동안 변경되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ea634c02baa48b31e81ed3a00831f7dcbb2e678" translate="yes" xml:space="preserve">
          <source>At the time of this writing (June 2002), there is a known bug in the Tru64 libc printing of long doubles when not using &quot;e&quot; notation. The values are correct and usable, but you only get a limited number of digits displayed unless you force the issue by using &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;
&quot;%.33e&quot;,$num&lt;/code&gt; or the like. For Tru64 versions V5.0A through V5.1A, a patch is expected sometime after perl 5.8.0 is released. If your libc has not yet been patched, you'll get a warning from Configure when selecting long doubles.</source>
          <target state="translated">이 글을 쓰는 시점 (2002 년 6 월)에 &quot;e&quot;표기법을 사용하지 않을 때 Tru64 libc 인쇄에서 long double의 알려진 버그가 있습니다. 값은 정확하고 사용 가능하지만 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt; &quot;%.33e&quot;,$num&lt;/code&gt; 을 사용하여 문제를 강요하지 않는 한 제한된 수의 숫자 만 표시됩니다 . Tru64 버전 V5.0A에서 V5.1A의 경우 perl 5.8.0이 릴리스 된 후 언젠가 패치가 예상됩니다. libc가 아직 패치되지 않은 경우 long doubles를 선택할 때 Configure에서 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1867a801fe6f9af5a7aceadb824f2be69014eb61" translate="yes" xml:space="preserve">
          <source>At the time of this writing, Perl 5.18.0 is considered to be well-hardened against algorithmic complexity attacks on its hash implementation. This is largely owed to the following measures mitigate attacks:</source>
          <target state="translated">이 글을 쓰는 시점에서 Perl 5.18.0은 해시 구현에 대한 알고리즘 복잡성 공격에 대해 잘 강화 된 것으로 간주됩니다. 이것은 주로 다음과 같은 조치로 인해 공격이 완화됩니다.</target>
        </trans-unit>
        <trans-unit id="8a33c676d1f79e763827316ea86000a157f0da7a" translate="yes" xml:space="preserve">
          <source>At the time of very final cleanup, sv_free_arenas() is called from perl_destruct() to physically free all the arenas allocated since the start of the interpreter.</source>
          <target state="translated">최종 정리시, perl_destruct ()에서 sv_free_arenas ()가 호출되어 인터프리터가 시작된 이후 할당 된 모든 경기장을 물리적으로 해제합니다.</target>
        </trans-unit>
        <trans-unit id="4ad7685293e30733157e0b0115df9c2bbc818321" translate="yes" xml:space="preserve">
          <source>At the time that f is created, it can't capture the current &quot;a&quot; sub, since the anonymous subroutine hasn't been created yet. Conversely, the following won't give a warning since the anonymous subroutine has by now been created and is live:</source>
          <target state="translated">익명 서브 루틴이 아직 작성되지 않았으므로 f가 작성 될 때 현재 &quot;a&quot;서브를 캡처 할 수 없습니다. 반대로, 익명 서브 루틴이 작성되어 현재 활성화되었으므로 다음은 경고를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c7f753fb79bacf696f44e6edc3ce403746b9d93b" translate="yes" xml:space="preserve">
          <source>At the time that f is created, it can't capture the current value of $a, since the anonymous subroutine hasn't been created yet. Conversely, the following won't give a warning since the anonymous subroutine has by now been created and is live:</source>
          <target state="translated">익명 서브 루틴이 아직 작성되지 않았으므로 f가 작성 될 때 현재 값 $ a를 캡처 할 수 없습니다. 반대로, 익명 서브 루틴이 작성되어 현재 활성화되었으므로 다음은 경고를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d72f28fef349b76a0adf7f5f7156e5e3f38d89f" translate="yes" xml:space="preserve">
          <source>At the time this document was last updated, Cygwin 1.7.16 was current.</source>
          <target state="translated">이 문서가 마지막으로 업데이트 될 당시 Cygwin 1.7.16이 최신 버전입니다.</target>
        </trans-unit>
        <trans-unit id="568132008f8ee29811084c20ba8f801b1aedb463" translate="yes" xml:space="preserve">
          <source>At the very least, this is useful to see what the SelfLoader thinks are stubs - in order to ensure future versions of the SelfStubber remain in step with the SelfLoader, the SelfStubber actually uses the SelfLoader to determine which stubs are needed.</source>
          <target state="translated">최소한 이것은 SelfLoader가 스텁이라고 생각하는 것을 보는 데 유용합니다. SelfStubber의 향후 버전이 SelfLoader와 계속 단계를 유지하기 위해 SelfStubber는 실제로 SelfLoader를 사용하여 필요한 스텁을 판별합니다.</target>
        </trans-unit>
        <trans-unit id="4c88d3fd177dc36a169a0f390f88ed358e376c27" translate="yes" xml:space="preserve">
          <source>At the very minimum, any subclass will need to provide its own &lt;code&gt;new()&lt;/code&gt; and can store additional hash keys in the object. There are also some package globals that must be defined, e.g.:</source>
          <target state="translated">최소한 모든 서브 클래스는 자체 &lt;code&gt;new()&lt;/code&gt; 를 제공해야하며 추가 해시 키를 객체에 저장할 수 있습니다. 정의해야 할 패키지 전역도 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="edcf8fa241edee8ba6be389a9320a43680a858f9" translate="yes" xml:space="preserve">
          <source>At this point, if you're using the</source>
          <target state="translated">이 시점에서</target>
        </trans-unit>
        <trans-unit id="5a6511c6f50957ea6c619917499bccc60b76c492" translate="yes" xml:space="preserve">
          <source>At this point, we have all the basic regexp concepts covered, so let's give a more involved example of a regular expression. We will build a regexp that matches numbers.</source>
          <target state="translated">이 시점에서, 우리는 모든 정규 정규 표현식 개념을 다루었으므로 정규 표현식의 더 많은 관련 예제를 보자. 숫자와 일치하는 정규 표현식을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="370a5cf660692a42903691231af5dc8e0071bc25" translate="yes" xml:space="preserve">
          <source>At this point, xsubpp is doing very little work - the differences between Mytest.xs and Mytest.c are minimal.</source>
          <target state="translated">이 시점에서 xsubpp는 거의 작업을 수행하지 않습니다. Mytest.xs와 Mytest.c의 차이는 최소화됩니다.</target>
        </trans-unit>
        <trans-unit id="6e93ae94dda2105286d8d2c3c0189888d8aa45b7" translate="yes" xml:space="preserve">
          <source>At time of writing, &lt;code&gt;L&amp;lt;name&amp;gt;&lt;/code&gt; values are of two types: either the name of a Pod page like &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; (which might be a real Perl module or program in an @INC / PATH directory, or a .pod file in those places); or the name of a Unix man page, like &lt;code&gt;L&amp;lt;crontab(5)&amp;gt;&lt;/code&gt; . In theory, &lt;code&gt;L&amp;lt;chmod&amp;gt;&lt;/code&gt; in ambiguous between a Pod page called &quot;chmod&quot;, or the Unix man page &quot;chmod&quot; (in whatever man-section). However, the presence of a string in parens, as in &quot;crontab(5)&quot;, is sufficient to signal that what is being discussed is not a Pod page, and so is presumably a Unix man page. The distinction is of no importance to many Pod processors, but some processors that render to hypertext formats may need to distinguish them in order to know how to render a given &lt;code&gt;L&amp;lt;foo&amp;gt;&lt;/code&gt; code.</source>
          <target state="translated">작성시 &lt;code&gt;L&amp;lt;name&amp;gt;&lt;/code&gt; 값은 &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; 와 같은 포드 페이지의 이름 (@INC / PATH 디렉토리의 실제 Perl 모듈 또는 프로그램 일 수 있음) 또는 해당 위치의 .pod 파일); 또는 &lt;code&gt;L&amp;lt;crontab(5)&amp;gt;&lt;/code&gt; 와 같은 Unix 매뉴얼 페이지의 이름입니다 . 이론적으로 &lt;code&gt;L&amp;lt;chmod&amp;gt;&lt;/code&gt; 는 &quot;chmod&quot;라는 포드 페이지 또는 Unix 매뉴얼 페이지 &quot;chmod&quot;(모든 섹션에서)간에 모호합니다. 그러나 &quot;crontab (5)&quot;에서와 같이 parens에 문자열이 있으면 논의중인 내용이 Pod 페이지가 아니며 Unix 매뉴얼 페이지 일 수도 있음을 나타내는 데 충분합니다. 이러한 차이점은 많은 포드 프로세서에서 중요하지 않습니다.하이퍼 텍스트 형식으로 렌더링하는 일부 프로세서는 특정 텍스트를 렌더링하는 방법을 알기 위해 구별해야 할 수도 있습니다. &lt;code&gt;L&amp;lt;foo&amp;gt;&lt;/code&gt; 코드.</target>
        </trans-unit>
        <trans-unit id="d759da54d18d185bb5ccfc037b889a6ccc296532" translate="yes" xml:space="preserve">
          <source>Attach the shared memory segment identified by ID to the address space of the calling process. See &lt;a href=&quot;http://search.cpan.org/perldoc/shmat&quot;&gt;shmat&lt;/a&gt;.</source>
          <target state="translated">ID로 식별 된 공유 메모리 세그먼트를 호출 프로세스의 주소 공간에 연결하십시오. &lt;a href=&quot;http://search.cpan.org/perldoc/shmat&quot;&gt;shmat를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="225d31a7a030cd02427cb0b7456aa1f815b2914d" translate="yes" xml:space="preserve">
          <source>Attaching &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; to arrays is permissible but has no effect.</source>
          <target state="translated">&lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; 를 배열에 연결 하는 것은 허용되지만 효과는 없습니다.</target>
        </trans-unit>
        <trans-unit id="d423c0cfec188bd6ee98e700b49e9beb58a1ac55" translate="yes" xml:space="preserve">
          <source>Attempt SASL authentication.</source>
          <target state="translated">SASL 인증을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="a57d83a2b0e335a567209ea75d9a6f7c18c72eb5" translate="yes" xml:space="preserve">
          <source>Attempt SASL authentication. Requires Authen::SASL module.</source>
          <target state="translated">SASL 인증을 시도하십시오. Authen :: SASL 모듈이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0bfa31d2d4671313bd0af54f4bb1d33e8b3d1352" translate="yes" xml:space="preserve">
          <source>Attempt to change directory to the directory given in &lt;code&gt;$dir&lt;/code&gt; . If &lt;code&gt;$dir&lt;/code&gt; is &lt;code&gt;&quot;..&quot;&lt;/code&gt; , the FTP &lt;code&gt;CDUP&lt;/code&gt; command is used to attempt to move up one directory. If no directory is given then an attempt is made to change the directory to the root directory.</source>
          <target state="translated">디렉토리를 &lt;code&gt;$dir&lt;/code&gt; 제공된 디렉토리로 변경하십시오 . 경우 &lt;code&gt;$dir&lt;/code&gt; 있다 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 는 FTP &lt;code&gt;CDUP&lt;/code&gt; 의 명령은 하나의 디렉토리를 이동하려고 시도하는 데 사용됩니다. 디렉토리가 제공되지 않으면 디렉토리를 루트 디렉토리로 변경하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="f1a553fb01152c680db2f1ac04b66addb3e1a32b" translate="yes" xml:space="preserve">
          <source>Attempt to convert an absolute file specification to a relative specification.</source>
          <target state="translated">절대 파일 스펙을 상대 스펙으로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="c6a6104d31483a82798cc43a56c3040f5b0e5915" translate="yes" xml:space="preserve">
          <source>Attempt to destroy all objects not yet freed.</source>
          <target state="translated">아직 해제되지 않은 모든 개체를 파괴하려고합니다.</target>
        </trans-unit>
        <trans-unit id="fe99a6ee8775c38ae61fdc7b8491eb15dc3ce181" translate="yes" xml:space="preserve">
          <source>Attempt to evaluate the current host's internet name and domain</source>
          <target state="translated">현재 호스트의 인터넷 이름과 도메인을 평가하려고합니다</target>
        </trans-unit>
        <trans-unit id="078cb982d4d92298b47355c08e74e2f224c181c7" translate="yes" xml:space="preserve">
          <source>Attempt to print summary information if run is interrupted by SIGINT (Ctrl-C).</source>
          <target state="translated">SIGINT (Ctrl-C)에 의해 실행이 중단 된 경우 요약 정보를 인쇄하려고합니다.</target>
        </trans-unit>
        <trans-unit id="b914600bb82ac0ae87b3e9ab97d2d1c2f3efb3a8" translate="yes" xml:space="preserve">
          <source>Attempt to produce color output.</source>
          <target state="translated">컬러 출력을 생성하려고합니다.</target>
        </trans-unit>
        <trans-unit id="efb3613b13587fe1f93cf60bf899f24390374124" translate="yes" xml:space="preserve">
          <source>Attempt to read &lt;code&gt;$length&lt;/code&gt; bytes of uncompressed data into &lt;code&gt;$buffer&lt;/code&gt; .</source>
          <target state="translated">압축되지 않은 &lt;code&gt;$length&lt;/code&gt; 바이트의 데이터를 &lt;code&gt;$buffer&lt;/code&gt; 로 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="5b92f951c7fd86ee7f7ec9db2ae7b702bd512a11" translate="yes" xml:space="preserve">
          <source>Attempting to inherit from yourself generates a warning.</source>
          <target state="translated">자신으로부터 상속을 시도하면 경고가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="940068c4484917346e58cd849ab63ab658a04374" translate="yes" xml:space="preserve">
          <source>Attempting to pack the special floating point values &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; (infinity, also in negative, and not-a-number) into packed integer values (like &lt;code&gt;&quot;L&quot;&lt;/code&gt; ) is a fatal error. The reason for this is that there simply isn't any sensible mapping for these special values into integers.</source>
          <target state="translated">특수 부동 소수점 값 &lt;code&gt;Inf&lt;/code&gt; 및 &lt;code&gt;NaN&lt;/code&gt; (무한 수 및 음수가 아닌 숫자)을 팩형 정수 값 (예 : &lt;code&gt;&quot;L&quot;&lt;/code&gt; )으로 묶으려고 하면 치명적인 오류가 발생합니다. 그 이유는 이러한 특수 값에 대한 현명한 매핑이 정수로 간단하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="6015d4f519177c33ba06ab08404701540b4f2048" translate="yes" xml:space="preserve">
          <source>Attempting to reopen a database without closing it.</source>
          <target state="translated">데이터베이스를 닫지 않고 다시 열려고합니다.</target>
        </trans-unit>
        <trans-unit id="0bedf74043c203b86c1b5363d305f57a4b0c5fcb" translate="yes" xml:space="preserve">
          <source>Attempts several methods of getting the system hostname and then caches the result. It tries the first available of the C library's gethostname(), &lt;code&gt;`$Config{aphostname}`&lt;/code&gt; , uname(2), &lt;code&gt;&lt;a href=&quot;../functions/syscall&quot;&gt;syscall(SYS_gethostname)&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;`hostname`&lt;/code&gt; , &lt;code&gt;`uname -n`&lt;/code&gt; , and the file</source>
          <target state="translated">시스템 호스트 이름을 가져 오는 몇 가지 방법을 시도한 후 결과를 캐시합니다. C 라이브러리의 gethostname (), &lt;code&gt;`$Config{aphostname}`&lt;/code&gt; , uname (2), &lt;code&gt;&lt;a href=&quot;../functions/syscall&quot;&gt;syscall(SYS_gethostname)&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;`hostname`&lt;/code&gt; , &lt;code&gt;`uname -n`&lt;/code&gt; 및 파일 중 첫 번째로 사용 가능한 파일을 시도 합니다.</target>
        </trans-unit>
        <trans-unit id="f998d3cd38777ee213006cd15fb0e0f6d2ddc7f7" translate="yes" xml:space="preserve">
          <source>Attempts to connect to a remote socket, just like connect(2). Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">connect (2)와 같이 원격 소켓에 연결을 시도합니다. 성공하면 true를, 그렇지 않으면 false를 반환합니다. NAME은 소켓에 적합한 유형의 압축 된 주소 여야합니다. &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;소켓 : perlipc의 클라이언트 / 서버 통신&lt;/a&gt; 의 예제를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="64769a075153327a39fd4f2723d3853f980fe471" translate="yes" xml:space="preserve">
          <source>Attempts to connect to a remote socket, just like connect(2). Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">connect (2)와 같이 원격 소켓에 연결을 시도합니다. 성공하면 true를, 그렇지 않으면 false를 반환합니다. NAME은 소켓에 적합한 유형의 압축 된 주소 여야합니다. &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;소켓 : perlipc의 클라이언트 / 서버 통신&lt;/a&gt; 의 예제를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4a0ddb935c0376b494edd76deb21d2e9aa4a1612" translate="yes" xml:space="preserve">
          <source>Attempts to convert in-place the octet sequence encoded as</source>
          <target state="translated">다음과 같이 인코딩 된 옥텟 시퀀스를 제자리에서 변환하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="bd9b4f39078d108026008c73a3d153cb14bae4bd" translate="yes" xml:space="preserve">
          <source>Attempts to convert the PV of an SV from characters to bytes. If the PV contains a character that cannot fit in a byte, this conversion will fail; in this case, either returns false or, if &lt;code&gt;fail_ok&lt;/code&gt; is not true, croaks.</source>
          <target state="translated">SV의 PV를 문자에서 바이트로 변환하려고합니다. PV에 바이트에 맞지 않는 문자가 포함되어 있으면이 변환이 실패합니다. 이 경우 false를 반환하거나 &lt;code&gt;fail_ok&lt;/code&gt; 가 true가 아닌 경우 크로 킹을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="64d7ec66819a9007136707554fdc8dbbef9567aa" translate="yes" xml:space="preserve">
          <source>Attempts to determine if a given host is outside your firewall. Possible return values are.</source>
          <target state="translated">지정된 호스트가 방화벽 외부에 있는지 확인합니다. 가능한 반환 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="015e99d4e0b5f5661a89b0c851595de01de6cc85" translate="yes" xml:space="preserve">
          <source>Attempts to read LENGTH</source>
          <target state="translated">LENGTH를 읽으려고 시도</target>
        </trans-unit>
        <trans-unit id="623d8fbf82dc2fdc9694f6bbe91f1257bb25f69a" translate="yes" xml:space="preserve">
          <source>Attempts to read LENGTH bytes of data into variable SCALAR from the specified FILEHANDLE, using the read(2). It bypasses buffered IO, so mixing this with other kinds of reads, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; can cause confusion because the perlio or stdio layers usually buffers data. Returns the number of bytes actually read, &lt;code&gt;0&lt;/code&gt; at end of file, or undef if there was an error (in the latter case &lt;code&gt;$!&lt;/code&gt; is also set). SCALAR will be grown or shrunk so that the last byte actually read is the last byte of the scalar after the read.</source>
          <target state="translated">read (2)를 사용하여 지정된 FILEHANDLE에서 LENGTH 바이트의 데이터를 변수 SCALAR로 읽으려고합니다. 버퍼 된 IO를 우회 하므로 perlio 또는 stdio 레이어는 일반적으로 데이터를 버퍼링하기 때문에 다른 종류의 읽기, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; , seek , &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 와 혼합 하면 혼동을 일으킬 수 있습니다. 실제로 읽은 바이트 수, 파일 끝 에서 &lt;code&gt;0&lt;/code&gt; 또는 오류가있는 경우 undef (후자의 경우 &lt;code&gt;$!&lt;/code&gt; 도 설정 됨)를 리턴합니다 . SCALAR는 실제로 읽은 마지막 바이트가 읽은 후 스칼라의 마지막 바이트가되도록 커지거나 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="321c64867646f812228d15e7d459f8fc1a5c1183" translate="yes" xml:space="preserve">
          <source>Attempts to read LENGTH bytes of data into variable SCALAR from the specified FILEHANDLE, using the read(2). It bypasses buffered IO, so mixing this with other kinds of reads, &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; can cause confusion because the perlio or stdio layers usually buffers data. Returns the number of bytes actually read, &lt;code&gt;0&lt;/code&gt; at end of file, or undef if there was an error (in the latter case &lt;code&gt;$!&lt;/code&gt; is also set). SCALAR will be grown or shrunk so that the last byte actually read is the last byte of the scalar after the read.</source>
          <target state="translated">read (2)를 사용하여 지정된 FILEHANDLE에서 LENGTH 바이트의 데이터를 변수 SCALAR로 읽으려고합니다. 버퍼 된 IO를 우회 하므로 perlio 또는 stdio 레이어는 일반적으로 데이터를 버퍼링하기 때문에 다른 종류의 읽기, &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; , seek , &lt;code&gt;&lt;a href=&quot;tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 와 혼합 하면 혼동을 일으킬 수 있습니다. 실제로 읽은 바이트 수, 파일 끝 에서 &lt;code&gt;0&lt;/code&gt; 또는 오류가있는 경우 undef (후자의 경우 &lt;code&gt;$!&lt;/code&gt; 도 설정 됨)를 리턴합니다 . SCALAR는 실제로 읽은 마지막 바이트가 읽은 후 스칼라의 마지막 바이트가되도록 커지거나 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="056c7c4b49d09bfb10b608aa560ae7f329c94639" translate="yes" xml:space="preserve">
          <source>Attempts to write LENGTH bytes of data from variable SCALAR to the specified FILEHANDLE, using write(2). If LENGTH is not specified, writes whole SCALAR. It bypasses buffered IO, so mixing this with reads (other than &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread())&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; may cause confusion because the perlio and stdio layers usually buffer data. Returns the number of bytes actually written, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if there was an error (in this case the errno variable &lt;code&gt;$!&lt;/code&gt; is also set). If the LENGTH is greater than the data available in the SCALAR after the OFFSET, only as much data as is available will be written.</source>
          <target state="translated">write (2)를 사용하여 변수 SCALAR에서 지정된 FILEHANDLE에 LENGTH 바이트의 데이터를 쓰려고 시도합니다. LENGTH를 지정하지 않으면 전체 SCALAR를 씁니다. 버퍼링 된 IO를 우회 하므로 perlio 및 stdio 레이어는 일반적으로 데이터를 버퍼링하므로 &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread())&lt;/a&gt;&lt;/code&gt; 이외의 read , &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 와 혼용 할 수 있습니다. 실제로 쓴 바이트 수를 반환하거나 오류가있는 경우 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환합니다 (이 경우 errno 변수 &lt;code&gt;$!&lt;/code&gt; 도 설정 됨). LENGTH가 OFFSET 후 SCALAR에서 사용 가능한 데이터보다 크면 사용 가능한만큼의 데이터 만 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="bf935c85345c3169ffc0b395c956f17c45a9fe82" translate="yes" xml:space="preserve">
          <source>Attempts to write LENGTH bytes of data from variable SCALAR to the specified FILEHANDLE, using write(2). If LENGTH is not specified, writes whole SCALAR. It bypasses buffered IO, so mixing this with reads (other than &lt;code&gt;&lt;a href=&quot;sysread&quot;&gt;sysread())&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; may cause confusion because the perlio and stdio layers usually buffer data. Returns the number of bytes actually written, or &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if there was an error (in this case the errno variable &lt;code&gt;$!&lt;/code&gt; is also set). If the LENGTH is greater than the data available in the SCALAR after the OFFSET, only as much data as is available will be written.</source>
          <target state="translated">write (2)를 사용하여 변수 SCALAR에서 지정된 FILEHANDLE에 LENGTH 바이트의 데이터를 쓰려고 시도합니다. LENGTH를 지정하지 않으면 전체 SCALAR를 씁니다. 버퍼링 된 IO를 우회 하므로 perlio 및 stdio 레이어는 일반적으로 데이터를 버퍼링하므로 &lt;code&gt;&lt;a href=&quot;sysread&quot;&gt;sysread())&lt;/a&gt;&lt;/code&gt; 이외의 read , &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 와 혼용 할 수 있습니다. 실제로 쓴 바이트 수를 반환하거나 오류가있는 경우 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환합니다 (이 경우 errno 변수 &lt;code&gt;$!&lt;/code&gt; 도 설정 됨). LENGTH가 OFFSET 후 SCALAR에서 사용 가능한 데이터보다 크면 사용 가능한만큼의 데이터 만 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="cf2ad2263d9deded93137fc6e93270ce22633fb0" translate="yes" xml:space="preserve">
          <source>Attempts word completion. Cannot be changed.</source>
          <target state="translated">단어 완성을 시도합니다. 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="402319da749127eab7373ce69945d35452ea82aa" translate="yes" xml:space="preserve">
          <source>Attribute::Handlers</source>
          <target state="translated">Attribute::Handlers</target>
        </trans-unit>
        <trans-unit id="ab429cb97f17abf9bda7af427a4ab75a270a8eee" translate="yes" xml:space="preserve">
          <source>Attribute::Handlers - Simpler definition of attribute handlers</source>
          <target state="translated">Attribute :: Handlers-속성 핸들러의 간단한 정의</target>
        </trans-unit>
        <trans-unit id="1c8c525e5ee86dfc71e9832b4cad7c5124dad809" translate="yes" xml:space="preserve">
          <source>Attribute::Handlers makes strenuous efforts to convert the data argument (&lt;code&gt;$_[4]&lt;/code&gt; ) to a usable form before passing it to the handler (but see &lt;a href=&quot;#Non-interpretive-attribute-handlers&quot;&gt;Non-interpretive attribute handlers&lt;/a&gt;). If those efforts succeed, the interpreted data is passed in an array reference; if they fail, the raw data is passed as a string. For example, all of these:</source>
          <target state="translated">Attribute :: Handlers는 데이터 인수 ( &lt;code&gt;$_[4]&lt;/code&gt; )를 처리기에 전달하기 전에 사용 가능한 형식 으로 변환하기 위해 많은 노력을 기울입니다 (그러나 &lt;a href=&quot;#Non-interpretive-attribute-handlers&quot;&gt;해석 할 수없는 속성 처리기 참조&lt;/a&gt; ). 이러한 노력이 성공하면 해석 된 데이터가 배열 참조로 전달됩니다. 실패하면 원시 데이터가 문자열로 전달됩니다. 예를 들어, 다음은 모두</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="7096373d5156eb6bd0032a6f3f3f6f2306181c31" translate="yes" xml:space="preserve">
          <source>Attributes are often stored in the object itself. For example, if the object is an anonymous hash, we can store the attribute values in the hash using the attribute name as the key.</source>
          <target state="translated">속성은 종종 객체 자체에 저장됩니다. 예를 들어 객체가 익명 해시 인 경우 속성 이름을 키로 사용하여 속성 값을 해시에 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ec0e5f9458a3d0b7666b49e580f1e144a9409de" translate="yes" xml:space="preserve">
          <source>Attributes are typically defined as read-only or read-write. Read-only attributes can only be set when the object is first created, while read-write attributes can be altered at any time.</source>
          <target state="translated">속성은 일반적으로 읽기 전용 또는 읽기 / 쓰기로 정의됩니다. 읽기 전용 속성은 개체를 처음 만들 때만 설정할 수 있으며 읽기 / 쓰기 속성은 언제든지 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7c79e72c9cbf686713260fcf1aae8a2f9a1a49e" translate="yes" xml:space="preserve">
          <source>Attributes as &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; interfaces</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 인터페이스 로서의 속성</target>
        </trans-unit>
        <trans-unit id="6e1c2a2200f4dc51bc987e61b1d0f256256aa8d5" translate="yes" xml:space="preserve">
          <source>Attributes as tie interfaces</source>
          <target state="translated">타이 인터페이스로서의 속성</target>
        </trans-unit>
        <trans-unit id="5d582f3d2d463609c927f60d4eb884597e89efea" translate="yes" xml:space="preserve">
          <source>Attributes make an excellent and intuitive interface through which to tie variables. For example:</source>
          <target state="translated">속성은 변수를 연결할 수있는 우수하고 직관적 인 인터페이스를 만듭니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="508a5aa4d3d540c30ef29d403ada44bf44ff7142" translate="yes" xml:space="preserve">
          <source>Attributes, once set, last until they are unset (by printing the attribute &lt;code&gt;clear&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt;). Be careful to do this, or otherwise your attribute will last after your script is done running, and people get very annoyed at having their prompt and typing changed to weird colors.</source>
          <target state="translated">한 번 설정된 속성은 설정이 취소 될 때까지 지속됩니다 (속성을 &lt;code&gt;clear&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; 인쇄하여 ). 이 작업을 조심하십시오. 그렇지 않으면 스크립트 실행이 끝난 후에도 속성이 지속되며 사람들은 프롬프트와 타이핑이 이상한 색으로 바뀌는 것에 매우 화가납니다.</target>
        </trans-unit>
        <trans-unit id="1874e0336adde0a00ba3a60dae1dc775409600bd" translate="yes" xml:space="preserve">
          <source>Audrey Tang &amp;lt;cpan@audreyt.org&amp;gt;</source>
          <target state="translated">오드리 탕 &amp;lt;cpan@audreyt.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="21c24cd01488e77938199d2e43d1c1e07248317d" translate="yes" xml:space="preserve">
          <source>Authenticate with the server identifying as &lt;code&gt;USER&lt;/code&gt; with password &lt;code&gt;PASS&lt;/code&gt; . Similar to &lt;a href=&quot;#login&quot;&gt;login&lt;/a&gt;, but the password is not sent in clear text.</source>
          <target state="translated">비밀번호가 &lt;code&gt;PASS&lt;/code&gt; 인 &lt;code&gt;USER&lt;/code&gt; 로 식별되는 서버로 인증하십시오 . &lt;a href=&quot;#login&quot;&gt;login&lt;/a&gt; 과 유사 하지만 암호는 일반 텍스트로 전송되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="507f24ee32e393058ec2717e7ff642ddf8b1dd65" translate="yes" xml:space="preserve">
          <source>Authenticates to the server (using the original AUTHINFO USER / AUTHINFO PASS form, defined in RFC2980) using the supplied username and password. Please note that the password is sent in clear text to the server. This command should not be used with valuable passwords unless the connection to the server is somehow protected.</source>
          <target state="translated">제공된 사용자 이름과 비밀번호를 사용하여 서버에 인증합니다 (RFC2980에 정의 된 원래 AUTHINFO USER / AUTHINFO PASS 양식 사용). 비밀번호는 서버에 일반 텍스트로 전송됩니다. 서버 연결이 어떻게 든 보호되지 않는 한이 명령은 중요한 암호와 함께 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="6f9130bcae1a2dee757ab825f2972f22149b8d0e" translate="yes" xml:space="preserve">
          <source>Authenticates to the server (using the proposed NNTP V2 AUTHINFO SIMPLE form, defined and deprecated in RFC2980) using the supplied username and password. As with &lt;a href=&quot;#authinfo&quot;&gt;authinfo&lt;/a&gt; the password is sent in clear text.</source>
          <target state="translated">제공된 사용자 이름과 비밀번호를 사용하여 서버에 인증합니다 (RFC2980에서 정의되고 더 이상 사용되지 않는 제안 된 NNTP V2 AUTHINFO SIMPLE 양식 사용). &lt;a href=&quot;#authinfo&quot;&gt;authinfo&lt;/a&gt; 와 마찬가지로 암호는 일반 텍스트로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="561e59b47284192d792d6315e83a8df1bb4623e9" translate="yes" xml:space="preserve">
          <source>Authentication, Security, and Encryption</source>
          <target state="translated">인증, 보안 및 암호화</target>
        </trans-unit>
        <trans-unit id="5fda23d62015b99fb2a9f86b38bcdf2bdf7609c8" translate="yes" xml:space="preserve">
          <source>Author</source>
          <target state="translated">Author</target>
        </trans-unit>
        <trans-unit id="fd140dad60fa77aa1adfbcd64d1e9ea4bc89ff62" translate="yes" xml:space="preserve">
          <source>Author and Maintainer: The Perl5-Porters &amp;lt;perl5-porters@perl.org&amp;gt;</source>
          <target state="translated">저자 및 관리자 : Perl5-Porters &amp;lt;perl5-porters@perl.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e41e820954a6b297983a7b6986adfdc7c083ed60" translate="yes" xml:space="preserve">
          <source>Author and Modification History</source>
          <target state="translated">저자 및 수정 이력</target>
        </trans-unit>
        <trans-unit id="dc4e711f40af1fee4327bcbd34d91d11e1b38a81" translate="yes" xml:space="preserve">
          <source>Author of this software makes no claim whatsoever about suitability, reliability, edability, editability or usability of this product, and should not be kept liable for any damage resulting from the use of it. If you can use it, you are in luck, if not, I should not be kept responsible. Keep a handy copy of your backup tape at hand.</source>
          <target state="translated">이 소프트웨어의 저자는이 제품의 적합성, 신뢰성, 식용 성, 편집 성 또는 유용성에 대해 어떠한 주장도하지 않으며,이 제품의 사용으로 인한 손상에 대해 책임을지지 않습니다. 당신이 그것을 사용할 수 있다면, 당신은 운이 좋으며, 그렇지 않다면, 나는 책임을지지 않아야합니다. 편리한 백업 테이프 사본을 준비하십시오.</target>
        </trans-unit>
        <trans-unit id="75a1f723a2c00ab3f9e540ebe5e3b630e531e2c3" translate="yes" xml:space="preserve">
          <source>Author: Mark Jason Dominus, Plover Systems (&lt;code&gt;mjd-perl-&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;+@plover.com&lt;/code&gt; )</source>
          <target state="translated">저자 : Mark Jason Dominus, Plover Systems ( &lt;code&gt;mjd-perl-&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;+@plover.com&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d2a52548bd0852b99153ddd79a1f550f70674c7d" translate="yes" xml:space="preserve">
          <source>Authors</source>
          <target state="translated">Authors</target>
        </trans-unit>
        <trans-unit id="4e4bc3d81e572248f45b55f87eb6a695cc5d7e17" translate="yes" xml:space="preserve">
          <source>Authors must not nest L&amp;lt;...&amp;gt; codes. For example, &quot;L&amp;lt;The L&amp;lt;Foo::Bar&amp;gt; man page&amp;gt;&quot; should be treated as an error.</source>
          <target state="translated">작성자는 L &amp;lt;...&amp;gt; 코드를 중첩해서는 안됩니다. 예를 들어 &quot;L &amp;lt;The L &amp;lt;Foo :: Bar&amp;gt; man page&amp;gt;&quot;는 오류로 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="9a1f2888146e0b82120ccf28bf4584779813130b" translate="yes" xml:space="preserve">
          <source>Authors of Pod formatters are reminded that &quot;=over&quot; ... &quot;=back&quot; may map to several different constructs in your output format. For example, in converting Pod to (X)HTML, it can map to any of &amp;lt;ul&amp;gt;...&amp;lt;/ul&amp;gt;, &amp;lt;ol&amp;gt;...&amp;lt;/ol&amp;gt;, &amp;lt;dl&amp;gt;...&amp;lt;/dl&amp;gt;, or &amp;lt;blockquote&amp;gt;...&amp;lt;/blockquote&amp;gt;. Similarly, &quot;=item&quot; can map to &amp;lt;li&amp;gt; or &amp;lt;dt&amp;gt;.</source>
          <target state="translated">포드 포맷터 작성자는 &quot;= over&quot;... &quot;= back&quot;이 출력 형식의 여러 가지 구성에 매핑 될 수 있음을 상기시킵니다. 예를 들어 포드를 (X) HTML로 변환 할 때 &amp;lt;ul&amp;gt; ... &amp;lt;/ ul&amp;gt;, &amp;lt;ol&amp;gt; ... &amp;lt;/ ol&amp;gt;, &amp;lt;dl&amp;gt; ... &amp;lt;/ dl&amp;gt; 중 하나로 매핑 할 수 있습니다. 또는 &amp;lt;blockquote&amp;gt; ... &amp;lt;/ blockquote&amp;gt;입니다. 마찬가지로 &quot;= item&quot;은 &amp;lt;li&amp;gt; 또는 &amp;lt;dt&amp;gt;에 매핑 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80bad0a974c0d7ed8e69ae0a2451cf949509d806" translate="yes" xml:space="preserve">
          <source>Authors of Pod formatters should note that this construct:</source>
          <target state="translated">포드 포맷터 작성자는이 구성에 유의해야합니다.</target>
        </trans-unit>
        <trans-unit id="0772af8ca884a475bc6c000e8a2e7ecd3771d821" translate="yes" xml:space="preserve">
          <source>Authors of Pod formatters/processors should make every effort to avoid writing their own Pod parser. There are already several in CPAN, with a wide range of interface styles -- and one of them, Pod::Parser, comes with modern versions of Perl.</source>
          <target state="translated">포드 포맷터 / 프로세서 작성자는 자신의 포드 파서를 작성하지 않도록 모든 노력을 기울여야합니다. CPAN에는 이미 다양한 인터페이스 스타일을 가진 몇 가지가 있으며 그 중 하나 인 Pod :: Parser는 최신 버전의 Perl과 함께 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="5f5a6b2c86d1c842fb78879cb9847a9b86de0e1d" translate="yes" xml:space="preserve">
          <source>Authors of formatter subclasses might find these methods useful to call on a parser object that you haven't started pulling tokens from yet:</source>
          <target state="translated">포맷터 서브 클래스 작성자는 아직 토큰을 가져 오기 시작하지 않은 파서 객체를 호출하는 데 유용한 이러한 메소드를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba749f31a8ceaa34419e1f1f52af7da1b1065181" translate="yes" xml:space="preserve">
          <source>Auto-decrement of the value in the SV, doing string to numeric conversion if necessary. Handles 'get' magic and operator overloading.</source>
          <target state="translated">필요한 경우 문자열을 숫자로 변환하여 SV의 값을 자동 감소시킵니다. 'get'매직 및 연산자 오버로드를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="cabef034701dc195b619657e11c47b3b4c7ed2cb" translate="yes" xml:space="preserve">
          <source>Auto-decrement of the value in the SV, doing string to numeric conversion if necessary. Handles operator overloading. Skips handling 'get' magic.</source>
          <target state="translated">필요한 경우 문자열을 숫자로 변환하여 SV의 값을 자동 감소시킵니다. 연산자 과부하를 처리합니다. 'get'매직 처리를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="f8df54de50b8630f73dd7c3210d2ed53c7051734" translate="yes" xml:space="preserve">
          <source>Auto-increment and Auto-decrement</source>
          <target state="translated">자동 증가 및 자동 감소</target>
        </trans-unit>
        <trans-unit id="9c2549c4f8e7b5156ddcd16c47fe624753b70037" translate="yes" xml:space="preserve">
          <source>Auto-increment of the value in the SV, doing string to numeric conversion if necessary. Handles 'get' magic and operator overloading.</source>
          <target state="translated">필요한 경우 문자열을 숫자로 변환하여 SV의 값을 자동 증가시킵니다. 'get'매직 및 연산자 오버로드를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="11123412c221a7c2bf77f34ba93ea1498be1bd77" translate="yes" xml:space="preserve">
          <source>Auto-increment of the value in the SV, doing string to numeric conversion if necessary. Handles operator overloading. Skips handling 'get' magic.</source>
          <target state="translated">필요한 경우 문자열을 숫자로 변환하여 SV의 값을 자동 증가시킵니다. 연산자 과부하를 처리합니다. 'get'매직 처리를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="95b64723d9f40505396f5971cbc44d69372e59a7" translate="yes" xml:space="preserve">
          <source>Auto-upgrade</source>
          <target state="translated">Auto-upgrade</target>
        </trans-unit>
        <trans-unit id="57a4f42cae4d12771bda9f458a5b76498da8ce37" translate="yes" xml:space="preserve">
          <source>AutoLoader</source>
          <target state="translated">AutoLoader</target>
        </trans-unit>
        <trans-unit id="4bbd7ae289ef059e5890696f9cb149721a7b8e69" translate="yes" xml:space="preserve">
          <source>AutoLoader - load subroutines only on demand</source>
          <target state="translated">오토로더-필요할 때만 서브 루틴로드</target>
        </trans-unit>
        <trans-unit id="6851ab5ce9e022d9cc5797875048cf4a3f08af3e" translate="yes" xml:space="preserve">
          <source>AutoLoader may fail to find the autosplit files (or even find the wrong ones) in cases where &lt;code&gt;@INC&lt;/code&gt; contains relative paths, &lt;b&gt;and&lt;/b&gt; the program does &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@INC&lt;/code&gt; 에 상대 경로가 &lt;b&gt;있고&lt;/b&gt; 프로그램이 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 을 수행하는 경우 AutoLoader가 자동 분할 파일을 찾지 못하거나 심지어 잘못된 파일을 찾지 못할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a635037412af6ace383fa21d0d50db8f0393e57" translate="yes" xml:space="preserve">
          <source>AutoLoaders prior to Perl 5.002 had a slightly different interface. Any old modules which use &lt;b&gt;AutoLoader&lt;/b&gt; should be changed to the new calling style. Typically this just means changing a require to a use, adding the explicit &lt;code&gt;'AUTOLOAD'&lt;/code&gt; import if needed, and removing &lt;b&gt;AutoLoader&lt;/b&gt; from &lt;code&gt;@ISA&lt;/code&gt; .</source>
          <target state="translated">Perl 5.002 이전의 오토로더는 인터페이스가 약간 다릅니다. &lt;b&gt;AutoLoader&lt;/b&gt; 를 사용하는 이전 모듈 은 새로운 호출 스타일로 변경해야합니다. 일반적으로 이것은 요구 사항을 용도로 변경하고 필요한 경우 명시 적 &lt;code&gt;'AUTOLOAD'&lt;/code&gt; 가져 오기를 추가하고 &lt;code&gt;@ISA&lt;/code&gt; 에서 &lt;b&gt;AutoLoader&lt;/b&gt; 를 제거하는 것을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="56be52307d7f516628d0435d04dbf15ef2be8e1c" translate="yes" xml:space="preserve">
          <source>AutoSplit</source>
          <target state="translated">AutoSplit</target>
        </trans-unit>
        <trans-unit id="141ac9ea73e406af3a95ffd453d7845aea91bee3" translate="yes" xml:space="preserve">
          <source>AutoSplit - split a package for autoloading</source>
          <target state="translated">AutoSplit-자동로드를 위해 패키지 분할</target>
        </trans-unit>
        <trans-unit id="68a652cb711d8eb8f8b2dadb0dc16bdffbba498d" translate="yes" xml:space="preserve">
          <source>Autocreating constants</source>
          <target state="translated">상수 자동 생성</target>
        </trans-unit>
        <trans-unit id="52fe0335e51acfb62f3dfd3073b3227b5b8c4846" translate="yes" xml:space="preserve">
          <source>Autodeferring</source>
          <target state="translated">Autodeferring</target>
        </trans-unit>
        <trans-unit id="f3589c4e74b1463fb3c579cd588ce9598fdbe87e" translate="yes" xml:space="preserve">
          <source>Autodie uses a simple set of categories to group together similar built-ins. Requesting a category type (starting with a colon) will enable autodie for all built-ins beneath that category. For example, requesting &lt;code&gt;:file&lt;/code&gt; will enable autodie for &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Autodie는 간단한 카테고리 세트를 사용하여 유사한 내장 기능을 그룹화합니다. 콜론으로 시작하는 카테고리 유형을 요청하면 해당 카테고리 아래의 모든 내장 기능에 대해 자동 다이를 사용할 수 있습니다. 예를 들어, &lt;code&gt;:file&lt;/code&gt; 을 요청 하면 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 에 대해 autodie가 활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="f410fe9b046b8c8a478048e83efc2672d42d3c9c" translate="yes" xml:space="preserve">
          <source>Autodying &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; will generate an exception if &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; returns false with any other error.</source>
          <target state="translated">Autodying &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 경우 예외를 생성 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 다른 오류와 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3fa81ba949fafdad4688aed6d9380f82976ca9d7" translate="yes" xml:space="preserve">
          <source>Autoloading</source>
          <target state="translated">Autoloading</target>
        </trans-unit>
        <trans-unit id="a71f8461a563c747e56f2cb5fb124e64328506d5" translate="yes" xml:space="preserve">
          <source>Autoloading and package lexicals</source>
          <target state="translated">어휘 자동로드 및 패키지</target>
        </trans-unit>
        <trans-unit id="24023d5e4bccdad4a40c403d058e7c856f75ea71" translate="yes" xml:space="preserve">
          <source>Autoloading with XSUBs</source>
          <target state="translated">XSUB로 자동로드</target>
        </trans-unit>
        <trans-unit id="ea5735f59ad896a38c6b806f8d8b02abba9762e7" translate="yes" xml:space="preserve">
          <source>Automatic binary installation</source>
          <target state="translated">자동 바이너리 설치</target>
        </trans-unit>
        <trans-unit id="b890d9b67b4f885e928a5dbcadc3dec7cd34f3ad" translate="yes" xml:space="preserve">
          <source>Automatically generate XSUBs basing on function declarations in the header file. The package &lt;code&gt;C::Scan&lt;/code&gt; should be installed. If this option is specified, the name of the header file may look like &lt;code&gt;NAME1,NAME2&lt;/code&gt; . In this case NAME1 is used instead of the specified string, but XSUBs are emitted only for the declarations included from file NAME2.</source>
          <target state="translated">헤더 파일에서 함수 선언을 기반으로 XSUB를 자동으로 생성합니다. &lt;code&gt;C::Scan&lt;/code&gt; 패키지 가 설치되어 있어야합니다. 이 옵션을 지정하면 헤더 파일 이름이 &lt;code&gt;NAME1,NAME2&lt;/code&gt; 와 같이 보일 수 있습니다 . 이 경우 지정된 문자열 대신 NAME1이 사용되지만 파일 NAME2에서 포함 된 선언에 대해서만 XSUB가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="974a6c8e46a4b4db1ad3a13139d3950f13a09a91" translate="yes" xml:space="preserve">
          <source>Automatically provide support for the &lt;b&gt;--help&lt;/b&gt; and &lt;b&gt;-?&lt;/b&gt; options if the application did not specify a handler for this option itself.</source>
          <target state="translated">&lt;b&gt;--help&lt;/b&gt; 및 &lt;b&gt;-?&lt;/b&gt; 를 자동으로 지원 애플리케이션이이 옵션 자체에 대한 핸들러를 지정하지 않은 경우 옵션.</target>
        </trans-unit>
        <trans-unit id="909a15529b11dbad33480554d0c112bc56821029" translate="yes" xml:space="preserve">
          <source>Automatically provide support for the &lt;b&gt;--version&lt;/b&gt; option if the application did not specify a handler for this option itself.</source>
          <target state="translated">응용 프로그램이이 옵션 자체에 대한 처리기를 지정하지 않은 경우 &lt;b&gt;--version&lt;/b&gt; 옵션 을 자동으로 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="859ddcc1d54c8f56f6fc79d681322ff6800ab918" translate="yes" xml:space="preserve">
          <source>Autoties are most commonly used in the module to which they actually tie, and need to export their attributes to any module that calls them. To facilitate this, Attribute::Handlers recognizes a special &quot;pseudo-class&quot; -- &lt;code&gt;__CALLER__&lt;/code&gt; , which may be specified as the qualifier of an attribute:</source>
          <target state="translated">autoties는 실제로 묶는 모듈에서 가장 일반적으로 사용되며 속성을 호출하는 모든 모듈로 속성을 내 보내야합니다. 이를 용이하게하기 위해 Attribute :: Handlers는 특수 &quot;의사 클래스&quot; &lt;code&gt;__CALLER__&lt;/code&gt; 인식하는데 , 이는 속성의 규정 자로 지정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c275699a9fcc5b1df221a4afe6ee0192241a51b8" translate="yes" xml:space="preserve">
          <source>Available Plugins</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1689bbab8d96444cb240ecc94b27e3bd6e1fa9d" translate="yes" xml:space="preserve">
          <source>Available Subroutines</source>
          <target state="translated">사용 가능한 서브 루틴</target>
        </trans-unit>
        <trans-unit id="f8f5117038c185bf68b0bd33b349f9405e133955" translate="yes" xml:space="preserve">
          <source>Available exports</source>
          <target state="translated">사용 가능한 수출</target>
        </trans-unit>
        <trans-unit id="00239624abff2fe9a2fd406296f776638259fff8" translate="yes" xml:space="preserve">
          <source>Available in Perls 5.8.1 and later. If set to &lt;code&gt;&quot;unsafe&quot;&lt;/code&gt; , the pre-Perl-5.8.0 signal behaviour (which is immediate but unsafe) is restored. If set to &lt;code&gt;safe&lt;/code&gt; , then safe (but deferred) signals are used. See &lt;a href=&quot;perlipc#Deferred-Signals-(Safe-Signals)&quot;&gt;Deferred Signals (Safe Signals) in perlipc&lt;/a&gt;.</source>
          <target state="translated">Perls 5.8.1 이상에서 사용 가능합니다. &lt;code&gt;&quot;unsafe&quot;&lt;/code&gt; 로 설정하면 Per--5.8.0 이전 신호 동작 (즉시 안전하지만 안전하지 않음)이 복원됩니다. &lt;code&gt;safe&lt;/code&gt; 로 설정되면 안전 하지만 지연된 신호가 사용됩니다. &lt;a href=&quot;perlipc#Deferred-Signals-(Safe-Signals)&quot;&gt;perlipc의 지연된 신호 (안전 신호)를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="06d7ad8e1c503f30109967f01a5055e60c428ad2" translate="yes" xml:space="preserve">
          <source>Available in version 2.22 and above.</source>
          <target state="translated">버전 2.22 이상에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="ca47c0994a656fab74100d8043c17430984bfc08" translate="yes" xml:space="preserve">
          <source>Available in version 2.32 and above</source>
          <target state="translated">버전 2.32 이상에서 사용 가능</target>
        </trans-unit>
        <trans-unit id="6a2ef8d70aa0a54d8ffae1859cac80b4b3ca0c60" translate="yes" xml:space="preserve">
          <source>Available in version 2.66 and above.</source>
          <target state="translated">버전 2.66 이상에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="46f1e6d4a99c839646d86f37c67e8ce5c790c2f7" translate="yes" xml:space="preserve">
          <source>Available in version 2.77 and above.</source>
          <target state="translated">버전 2.77 이상에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="1ee0ed3a84dce710c7a16f8db82978050c4d2850" translate="yes" xml:space="preserve">
          <source>Available in version 2.99 and above.</source>
          <target state="translated">버전 2.99 이상에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="d74a27e4b35b5f01b8ce5c3169c1b5a135f15fe4" translate="yes" xml:space="preserve">
          <source>Available in version 3.00 and above.</source>
          <target state="translated">버전 3.00 이상에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="eb07b303f6d617426c6371968300dfb4f3ae0614" translate="yes" xml:space="preserve">
          <source>Available in version 6.31 and above.</source>
          <target state="translated">버전 6.31 이상에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="e2eb2ee2a8a2421e0f16491afdee27929c55a640" translate="yes" xml:space="preserve">
          <source>Available in version 6.46 and above.</source>
          <target state="translated">버전 6.46 이상에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="7b80e477803719c627e591ee3d93e9c48ad902d2" translate="yes" xml:space="preserve">
          <source>Available in version 6.48 and above.</source>
          <target state="translated">버전 6.48 이상에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="aec275cec443caa644465799fc156b88fcadd8ce" translate="yes" xml:space="preserve">
          <source>Available in version 6.52 and above.</source>
          <target state="translated">버전 6.52 이상에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="4c5736820a885b4b84bf41953dc520dbc9201d97" translate="yes" xml:space="preserve">
          <source>Available in version 6.5503 and above.</source>
          <target state="translated">버전 6.5503 이상에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="608b36cf2b4b343801fc146cfc4244281c6223d0" translate="yes" xml:space="preserve">
          <source>Available in version 6.64 and above.</source>
          <target state="translated">버전 6.64 이상에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="0d6ce3bbbc75b8e9071a24da666baed09d9b758d" translate="yes" xml:space="preserve">
          <source>Available on 64 bit OpenVMS 8.2 and later. (VMS)</source>
          <target state="translated">64 비트 OpenVMS 8.2 이상에서 사용 가능합니다. (VMS)</target>
        </trans-unit>
        <trans-unit id="61cd670e85d7eb394067cdccaf9865a921e8dfe4" translate="yes" xml:space="preserve">
          <source>Available only for socket handles, and it does what the &lt;code&gt;ioctlsocket()&lt;/code&gt; call in the Winsock API does. (Win32)</source>
          <target state="translated">소켓 핸들에만 사용 가능 하며 Winsock API에서 &lt;code&gt;ioctlsocket()&lt;/code&gt; 호출이 수행하는 작업을 수행합니다. (Win32)</target>
        </trans-unit>
        <trans-unit id="7ff7a29d7d279f81c65111e3969b0de8be5b1d10" translate="yes" xml:space="preserve">
          <source>Available only for socket handles. (RISC OS)</source>
          <target state="translated">소켓 핸들에만 사용 가능합니다. (RISC OS)</target>
        </trans-unit>
        <trans-unit id="9f1e3ff1138fe80a24c7ddf73407362168941db0" translate="yes" xml:space="preserve">
          <source>Available only under threaded builds, this function allocates an entry in &lt;code&gt;PL_stashpad&lt;/code&gt; for the stash passed to it.</source>
          <target state="translated">스레드 빌드에서만 사용할 수있는이 함수는 전달 된 숨김에 대해 &lt;code&gt;PL_stashpad&lt;/code&gt; 에 항목을 할당 합니다.</target>
        </trans-unit>
        <trans-unit id="e829311778d72727fd390df6d086e72d016b6e9b" translate="yes" xml:space="preserve">
          <source>Avoid /usr/ucb/cc.</source>
          <target state="translated">/ usr / ucb / cc를 피하십시오.</target>
        </trans-unit>
        <trans-unit id="20382d66f57ab5b9e0eec4292fa20991e9ee50cf" translate="yes" xml:space="preserve">
          <source>Avoid &lt;code&gt;$r-&amp;gt;Class::func()&lt;/code&gt; where using &lt;code&gt;@ISA=qw(... Class ...)&lt;/code&gt; and &lt;code&gt;$r-&amp;gt;func()&lt;/code&gt; would work.</source>
          <target state="translated">&lt;code&gt;@ISA=qw(... Class ...)&lt;/code&gt; 및 &lt;code&gt;$r-&amp;gt;func()&lt;/code&gt; 이 작동하는 &lt;code&gt;$r-&amp;gt;Class::func()&lt;/code&gt; 는 피하십시오 .</target>
        </trans-unit>
        <trans-unit id="653557f5998e677614fe1c110b44a8530b1a3295" translate="yes" xml:space="preserve">
          <source>Avoid assignments in conditionals, but if they're unavoidable, use extra paren, e.g. &quot;if (a &amp;amp;&amp;amp; (b = c)) ...&quot;</source>
          <target state="translated">조건부에서 할당을 피하되 피할 수없는 경우 &quot;예 (a &amp;amp;&amp;amp; (b = c)) ...&quot;와 같이 여분의 파렌을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="12cd7881c58cc2ba233002bb3f616c6a3c8332a8" translate="yes" xml:space="preserve">
          <source>Avoid barewords if you can, especially all lowercase ones. You can't tell by just looking at it whether a bareword is a function or a string. By using quotes on strings and parentheses on function calls, you won't ever get them confused.</source>
          <target state="translated">가능하면 베어 워드, 특히 모든 소문자를 피하십시오. 베어 워드가 함수인지 문자열인지 여부 만 살펴보면 알 수 없습니다. 함수 호출에 문자열과 괄호에 따옴표를 사용하면 혼동되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a2c60caa765bc1191575d1eafdff1bfe2d3195d5" translate="yes" xml:space="preserve">
          <source>Avoid class name tests like: &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt; &quot;Invalid&quot; unless &lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt; $ref eq 'FOO'&lt;/code&gt; . Generally you can delete the &lt;code&gt;eq 'FOO'&lt;/code&gt; part with no harm at all. Let the objects look after themselves! Generally, avoid hard-wired class names as far as possible.</source>
          <target state="translated">피 클래스 이름 테스트 같은 : &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt; &quot;Invalid&quot; unless &lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt; $ref eq 'FOO'&lt;/code&gt; . 일반적으로 &lt;code&gt;eq 'FOO'&lt;/code&gt; 부분을 ​​전혀 손상시키지 않고 삭제할 수 있습니다 . 물체가 스스로 돌보게하십시오! 일반적으로 유선 클래스 이름은 가능한 멀리 피하십시오.</target>
        </trans-unit>
        <trans-unit id="98206b093bcf40d6e074eb698543fd4b6a25d539" translate="yes" xml:space="preserve">
          <source>Avoid keeping any state information in your packages. It makes it difficult for multiple other packages to use yours. Keep state information in objects.</source>
          <target state="translated">패키지에 상태 정보를 보관하지 마십시오. 여러 개의 다른 패키지를 사용하기가 어렵습니다. 상태 정보를 객체에 보관하십시오.</target>
        </trans-unit>
        <trans-unit id="b40cce256d04ce45459ded87307f5f3e8ae2760b" translate="yes" xml:space="preserve">
          <source>Avoid libucb.</source>
          <target state="translated">libucb를 피하십시오.</target>
        </trans-unit>
        <trans-unit id="b3ba9403766f60fa8e210155287efa18e1a9e739" translate="yes" xml:space="preserve">
          <source>Avoid starting a new top-level hierarchy, especially if a suitable hierarchy already exists under which you could place your module.</source>
          <target state="translated">모듈을 배치 할 수있는 적절한 계층이 이미 존재하는 경우 새 최상위 계층 구조를 시작하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="fd4b693367a701b3345901dbd6d82b5f0d6ce929" translate="yes" xml:space="preserve">
          <source>Avoid using &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map()&lt;/a&gt;&lt;/code&gt;) or `backticks` in a void context, that is, when you just throw away their return values. Those functions all have return values, so use them. Otherwise use a &lt;code&gt;foreach()&lt;/code&gt; loop or the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; function instead.</source>
          <target state="translated">void 컨텍스트에서, 즉 반환 값을 버릴 때 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt; (또는 &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map()&lt;/a&gt;&lt;/code&gt; ) 또는 'backticks'를 사용하지 마십시오 . 이러한 함수에는 모두 반환 값이 있으므로 사용하십시오. 그렇지 않으면 &lt;code&gt;foreach()&lt;/code&gt; 루프 또는 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 함수를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="342c7154cb2c0ee3ba1afbccab12770600c98259" translate="yes" xml:space="preserve">
          <source>Avoid using hardcoded test numbers whenever possible (the EXPECTED/GOT found in t/op/tie.t is much more maintainable, and gives better failure reports).</source>
          <target state="translated">가능할 때마다 하드 코딩 된 테스트 번호를 사용하지 마십시오 (t / op / tie.t에있는 EXPECTED / GOT는 훨씬 더 유지 보수 가능하며 더 나은 실패 보고서를 제공합니다).</target>
        </trans-unit>
        <trans-unit id="67de3787b457172bffd90b9f3faae7435e0dae2f" translate="yes" xml:space="preserve">
          <source>Avoid using qx// and system() unless you are testing for them. If you do use them, make sure that you cover _all_ perl platforms.</source>
          <target state="translated">테스트하지 않는 한 qx // 및 system ()을 사용하지 마십시오. 그것들을 사용한다면, _all_ perl 플랫폼을 다루어야합니다.</target>
        </trans-unit>
        <trans-unit id="0e92b74d5a979c26e7eb18be8603b8359a1d07fd" translate="yes" xml:space="preserve">
          <source>Avoiding Pipe Deadlocks</source>
          <target state="translated">파이프 교착 상태 방지</target>
        </trans-unit>
        <trans-unit id="6e3313e507db79bbbaea78fb241509ccc328aba1" translate="yes" xml:space="preserve">
          <source>Avoiding repetitions</source>
          <target state="translated">반복 피하기</target>
        </trans-unit>
        <trans-unit id="3721e8be2f4b8bf2c63f63312cdfa53888d8430d" translate="yes" xml:space="preserve">
          <source>Awk Traps</source>
          <target state="translated">어크 트랩</target>
        </trans-unit>
        <trans-unit id="ae4f281df5a5d0ff3cad6371f76d5c29b6d953ec" translate="yes" xml:space="preserve">
          <source>B</source>
          <target state="translated">B</target>
        </trans-unit>
        <trans-unit id="bd2b125cd8de6e0701cdac6ee17fd331ce4a27c2" translate="yes" xml:space="preserve">
          <source>B - The Perl Compiler Backend</source>
          <target state="translated">B-Perl 컴파일러 백엔드</target>
        </trans-unit>
        <trans-unit id="b918b0aa2af36ef03dc69f56d877870ae5fd0aee" translate="yes" xml:space="preserve">
          <source>B-regex</source>
          <target state="translated">B-regex</target>
        </trans-unit>
        <trans-unit id="4995b54293f85c5bb7976c9e655accd8fbd573ea" translate="yes" xml:space="preserve">
          <source>B. UNPACK</source>
          <target state="translated">B. 포장 풀기</target>
        </trans-unit>
        <trans-unit id="52b9020e3a04e67bbf5d1e8e1b850a5ce003849b" translate="yes" xml:space="preserve">
          <source>B::AV Methods</source>
          <target state="translated">B :: AV 방법</target>
        </trans-unit>
        <trans-unit id="dc2dfb25dd4ed2146470cd57ee95edac91f0306b" translate="yes" xml:space="preserve">
          <source>B::BINOP Method</source>
          <target state="translated">B :: BINOP 방법</target>
        </trans-unit>
        <trans-unit id="d151bd0866d55b4bfc156b14f486f63bf8d29ea8" translate="yes" xml:space="preserve">
          <source>B::BM Methods</source>
          <target state="translated">B :: BM 방법</target>
        </trans-unit>
        <trans-unit id="9055e894e201b212c293a29798f1091ff6d20491" translate="yes" xml:space="preserve">
          <source>B::COP Methods</source>
          <target state="translated">B :: COP 방법</target>
        </trans-unit>
        <trans-unit id="ad1f22ba3c95252a59969a1a218e1111bb139542" translate="yes" xml:space="preserve">
          <source>B::CV Methods</source>
          <target state="translated">B :: CV 방법</target>
        </trans-unit>
        <trans-unit id="c5987daa2aa6d7fac584555a51956a3b445f0843" translate="yes" xml:space="preserve">
          <source>B::Concise</source>
          <target state="translated">B::Concise</target>
        </trans-unit>
        <trans-unit id="0e99aa1c3be052d8105291584d6f4ee6b16f397c" translate="yes" xml:space="preserve">
          <source>B::Concise - Walk Perl syntax tree, printing concise info about ops</source>
          <target state="translated">B :: Concise-Walk Perl 구문 트리, ops에 대한 간결한 정보 인쇄</target>
        </trans-unit>
        <trans-unit id="d98d2c8e235d9494074cb2fd60569e8b9c12b5d6" translate="yes" xml:space="preserve">
          <source>B::Concise::reset_sequence()</source>
          <target state="translated">B::Concise::reset_sequence()</target>
        </trans-unit>
        <trans-unit id="553185e97d716b58f74fa982526081cbc642ddf4" translate="yes" xml:space="preserve">
          <source>B::Debug</source>
          <target state="translated">B::Debug</target>
        </trans-unit>
        <trans-unit id="7b2b543f6bc70176bf812e6ac813955a4e8d32ab" translate="yes" xml:space="preserve">
          <source>B::Debug - Walk Perl syntax tree, printing debug info about ops</source>
          <target state="translated">B :: Debug-Walk Perl 구문 트리, ops에 대한 디버그 정보 인쇄</target>
        </trans-unit>
        <trans-unit id="b2fba5e2c554e2a4492f4d6c8ba33e2e0b6a2475" translate="yes" xml:space="preserve">
          <source>B::Deparse</source>
          <target state="translated">B::Deparse</target>
        </trans-unit>
        <trans-unit id="45e0d250a6312bd5838511c6a45d0f47e7a90193" translate="yes" xml:space="preserve">
          <source>B::Deparse - Perl compiler backend to produce perl code</source>
          <target state="translated">B :: Deparse-Perl 코드를 생성하는 Perl 컴파일러 백엔드</target>
        </trans-unit>
        <trans-unit id="ef79da6fd85d8fa02ee778f0544d6ba33e8b3b18" translate="yes" xml:space="preserve">
          <source>B::Deparse can also be used on a sub-by-sub basis from other perl programs.</source>
          <target state="translated">B :: Deparse는 다른 perl 프로그램에서 하위별로 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="187ec0fb4a4a04196e808c398a93708ba9275615" translate="yes" xml:space="preserve">
          <source>B::Deparse is a backend module for the Perl compiler that generates perl source code, based on the internal compiled structure that perl itself creates after parsing a program. The output of B::Deparse won't be exactly the same as the original source, since perl doesn't keep track of comments or whitespace, and there isn't a one-to-one correspondence between perl's syntactical constructions and their compiled form, but it will often be close. When you use the &lt;b&gt;-p&lt;/b&gt; option, the output also includes parentheses even when they are not required by precedence, which can make it easy to see if perl is parsing your expressions the way you intended.</source>
          <target state="translated">B :: Deparse는 프로그램을 구문 분석 한 후 perl 자체가 작성하는 내부 컴파일 된 구조를 기반으로 perl 소스 코드를 생성하는 Perl 컴파일러 용 백엔드 모듈입니다. 펄은 주석이나 공백을 추적하지 않으며 펄의 구문 구조와 컴파일 된 구조 사이에 일대일 대응이 없기 때문에 B :: Deparse의 출력은 원래 소스와 정확히 동일하지 않습니다. 형태, 그러나 종종 가까운 것입니다. &lt;b&gt;-p&lt;/b&gt; 옵션 을 사용하면 우선 순위에 따라 필요하지 않은 경우에도 출력에 괄호가 포함되므로 perl이 원하는 방식으로 표현식을 구문 분석하는지 쉽게 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc31dbbc2ee8c07aa355011d5f82b2d63c5b6c00" translate="yes" xml:space="preserve">
          <source>B::GV Methods</source>
          <target state="translated">B :: GV 방법</target>
        </trans-unit>
        <trans-unit id="f507161ede02e20a9575d2189eb0e0194566355a" translate="yes" xml:space="preserve">
          <source>B::HV Methods</source>
          <target state="translated">B :: HV 방법</target>
        </trans-unit>
        <trans-unit id="e300bd8b4c95a3624e2aa219bf974f0118cef860" translate="yes" xml:space="preserve">
          <source>B::IO Methods</source>
          <target state="translated">B :: IO 방법</target>
        </trans-unit>
        <trans-unit id="35a3e95640c426b65cf8d850194a4f17b3215f07" translate="yes" xml:space="preserve">
          <source>B::IO objects derive from IO objects and you will get more information from the IO object itself.</source>
          <target state="translated">B :: IO 객체는 IO 객체에서 파생되며 IO 객체 자체에서 자세한 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9329448ffaface57d41ef2b007c24eb18197a68b" translate="yes" xml:space="preserve">
          <source>B::IV Methods</source>
          <target state="translated">B :: IV 방법</target>
        </trans-unit>
        <trans-unit id="41ae1a755811beebf8ac2f49c8c1656753f2209c" translate="yes" xml:space="preserve">
          <source>B::IV, B::NV, B::RV, B::PV, B::PVIV, B::PVNV, B::PVMG, B::BM (5.9.5 and earlier), B::PVLV, B::AV, B::HV, B::CV, B::GV, B::FM, B::IO. These classes correspond in the obvious way to the underlying C structures of similar names. The inheritance hierarchy mimics the underlying C &quot;inheritance&quot;. For the 5.10.x branch, (</source>
          <target state="translated">B :: IV, B :: NV, B :: RV, B :: PV, B :: PVIV, B :: PVNV, B :: PVMG, B :: BM (5.9.5 이하), B :: PVLV, B :: AV, B :: HV, B :: CV, B :: GV, B :: FM, B :: IO. 이러한 클래스는 명백한 방식으로 유사한 이름의 기본 C 구조에 해당합니다. 상속 계층은 기본 C &quot;상속&quot;을 모방합니다. 5.10.x 분기의 경우 (</target>
        </trans-unit>
        <trans-unit id="47e3586b1ed7a7d56d8afab1073b55905757ce29" translate="yes" xml:space="preserve">
          <source>B::LISTOP Method</source>
          <target state="translated">B :: LISTOP 방법</target>
        </trans-unit>
        <trans-unit id="04688acb0cbf70d25c11e0314b06463ce4bde512" translate="yes" xml:space="preserve">
          <source>B::LOGOP Method</source>
          <target state="translated">B :: LOGOP 방법</target>
        </trans-unit>
        <trans-unit id="7263ed2af022568be1b85d473eacf000486dd697" translate="yes" xml:space="preserve">
          <source>B::LOOP Methods</source>
          <target state="translated">B :: 루프 방법</target>
        </trans-unit>
        <trans-unit id="83ceb8c6feb2e3fc2f3bf822a42dbcd07ff89ff2" translate="yes" xml:space="preserve">
          <source>B::MAGIC Methods</source>
          <target state="translated">B :: MAGIC 방법</target>
        </trans-unit>
        <trans-unit id="69a559c9b6f1bb1dde02c8b48310f4be42a91370" translate="yes" xml:space="preserve">
          <source>B::METHOP Methods (Since Perl 5.22)</source>
          <target state="translated">B :: METHOP 방법 (Perl 5.22 이후)</target>
        </trans-unit>
        <trans-unit id="ce0314b7717adf8f5e71d17e31bd593c95324507" translate="yes" xml:space="preserve">
          <source>B::NV Methods</source>
          <target state="translated">B :: NV 방법</target>
        </trans-unit>
        <trans-unit id="c0b4baaa7ca50074884462d7620fd16447077eec" translate="yes" xml:space="preserve">
          <source>B::OP Methods</source>
          <target state="translated">B :: OP 방법</target>
        </trans-unit>
        <trans-unit id="5409024a3cb7db3e3ab0625fc65de3e420057bb4" translate="yes" xml:space="preserve">
          <source>B::PADLIST Methods</source>
          <target state="translated">B :: PADLIST 방법</target>
        </trans-unit>
        <trans-unit id="7aa1d371fde2d45d24f6903c528b83b6becc77cd" translate="yes" xml:space="preserve">
          <source>B::PADNAME Methods</source>
          <target state="translated">B :: PADNAME 방법</target>
        </trans-unit>
        <trans-unit id="f042ef0bca656a3a3db2a47dca50963fab567b10" translate="yes" xml:space="preserve">
          <source>B::PADNAMELIST Methods</source>
          <target state="translated">B :: PADNAMELIST 방법</target>
        </trans-unit>
        <trans-unit id="7fc794e6266342d3b9c5605f5dd3acf7f99c4eaf" translate="yes" xml:space="preserve">
          <source>B::PADOP Method</source>
          <target state="translated">B :: PADOP 방법</target>
        </trans-unit>
        <trans-unit id="3cfe6d3792643bf75e3768c357ceb15d1fcc2896" translate="yes" xml:space="preserve">
          <source>B::PMOP Methods</source>
          <target state="translated">B :: PMOP 방법</target>
        </trans-unit>
        <trans-unit id="935c8ee8b93bca030ffae3839fe2dd9b63ef8ee4" translate="yes" xml:space="preserve">
          <source>B::PV Methods</source>
          <target state="translated">B :: PV 방법</target>
        </trans-unit>
        <trans-unit id="2ae17602fe4096f70c3f88f15eb8e459f9c75ea9" translate="yes" xml:space="preserve">
          <source>B::PVLV Methods</source>
          <target state="translated">B :: PVLV 방법</target>
        </trans-unit>
        <trans-unit id="974a328507349d20edd58996d04366d5388a2f7c" translate="yes" xml:space="preserve">
          <source>B::PVMG Methods</source>
          <target state="translated">B :: PVMG 방법</target>
        </trans-unit>
        <trans-unit id="7210fef12d9bb7c60c3dee3ae3350db4f7b9f9ab" translate="yes" xml:space="preserve">
          <source>B::PVOP Method</source>
          <target state="translated">B :: PVOP 방법</target>
        </trans-unit>
        <trans-unit id="6455c3fb933990f5652e2d49c591cb379eb4bf8a" translate="yes" xml:space="preserve">
          <source>B::REGEXP Methods</source>
          <target state="translated">B :: REGEXP 방법</target>
        </trans-unit>
        <trans-unit id="5fb9902660751871b51829ac2f4124c1e0f71d1f" translate="yes" xml:space="preserve">
          <source>B::RV Methods</source>
          <target state="translated">B :: RV 방법</target>
        </trans-unit>
        <trans-unit id="1bc231286052c317542f678d841b72c83eca59c7" translate="yes" xml:space="preserve">
          <source>B::SV Methods</source>
          <target state="translated">B :: SV 방법</target>
        </trans-unit>
        <trans-unit id="ba72f1a9a3b75ef02445cdb3be5e5dfd9e626d0a" translate="yes" xml:space="preserve">
          <source>B::SVOP Methods</source>
          <target state="translated">B :: SVOP 방법</target>
        </trans-unit>
        <trans-unit id="6d49788efca655ce69693e7fc4afeb14e70c0677" translate="yes" xml:space="preserve">
          <source>B::Showlex</source>
          <target state="translated">B::Showlex</target>
        </trans-unit>
        <trans-unit id="950f98354a0be3d4d89c912c00828150ec365f96" translate="yes" xml:space="preserve">
          <source>B::Showlex - Show lexical variables used in functions or files</source>
          <target state="translated">B :: Showlex-함수 또는 파일에 사용 된 어휘 변수 표시</target>
        </trans-unit>
        <trans-unit id="fdd28b59d6f44b83715e2f882acc2a2a5588e605" translate="yes" xml:space="preserve">
          <source>B::Terse</source>
          <target state="translated">B::Terse</target>
        </trans-unit>
        <trans-unit id="c493225f0157e4f61a98bb3974699f2af44cb46f" translate="yes" xml:space="preserve">
          <source>B::Terse - Walk Perl syntax tree, printing terse info about ops</source>
          <target state="translated">B :: Terse-Walk Perl 구문 트리, op에 대한 간결한 정보 인쇄</target>
        </trans-unit>
        <trans-unit id="9f6685ca28bcfea09300907f0826a8f9a2c91850" translate="yes" xml:space="preserve">
          <source>B::UNOP Method</source>
          <target state="translated">B :: UNOP 방법</target>
        </trans-unit>
        <trans-unit id="69effd3b7e8802f540cc9b9e50328608e6736463" translate="yes" xml:space="preserve">
          <source>B::UNOP_AUX Methods (since 5.22)</source>
          <target state="translated">B :: UNOP_AUX 메소드 (5.12부터)</target>
        </trans-unit>
        <trans-unit id="c85e7a03e5bbe49c04256621164986ed11cb37ba" translate="yes" xml:space="preserve">
          <source>B::Xref</source>
          <target state="translated">B::Xref</target>
        </trans-unit>
        <trans-unit id="651c8208adb3fd49f31423f94f8ac43c0733aa36" translate="yes" xml:space="preserve">
          <source>B::Xref - Generates cross reference reports for Perl programs</source>
          <target state="translated">B :: Xref-Perl 프로그램에 대한 상호 참조 보고서를 생성합니다</target>
        </trans-unit>
        <trans-unit id="a61d2719382da67e2a1a2dbd76dd400accca9187" translate="yes" xml:space="preserve">
          <source>BACKWARD COMPATIBILITY AND DEPRECATION</source>
          <target state="translated">역 호환성과 감가 상각</target>
        </trans-unit>
        <trans-unit id="e5b45b4fc983ac2702f9e777eee2ac1b1e5f0f20" translate="yes" xml:space="preserve">
          <source>BACKWARDS COMPATIBILITY</source>
          <target state="translated">역 호환성</target>
        </trans-unit>
        <trans-unit id="bef6eec96c16ae54f978beec72807557ca3a9eaf" translate="yes" xml:space="preserve">
          <source>BASIC METHODS</source>
          <target state="translated">기본 방법</target>
        </trans-unit>
        <trans-unit id="8cf5cb57c99d3bbd6c48033a11d198c341ee5329" translate="yes" xml:space="preserve">
          <source>BEFORE YOU START WRITING A MODULE</source>
          <target state="translated">모듈 작성을 시작하기 전에</target>
        </trans-unit>
        <trans-unit id="3598517c826f1480a241800ce73f781ae2b1cd6a" translate="yes" xml:space="preserve">
          <source>BEGIN</source>
          <target state="translated">BEGIN</target>
        </trans-unit>
        <trans-unit id="ed0ab3055b45605d8d3bfeee9675e3115e25dd63" translate="yes" xml:space="preserve">
          <source>BEGIN, UNITCHECK, CHECK, INIT and END</source>
          <target state="translated">시작, UNITCHECK, CHECK, INIT 및 END</target>
        </trans-unit>
        <trans-unit id="82587c5990d27962027bcd8f44009a394aa03c6d" translate="yes" xml:space="preserve">
          <source>BENCHMARKS</source>
          <target state="translated">BENCHMARKS</target>
        </trans-unit>
        <trans-unit id="3eb8dc2707d319cff39e903c8f9e907ffde6faaa" translate="yes" xml:space="preserve">
          <source>BEST PRACTICE</source>
          <target state="translated">모범 사례</target>
        </trans-unit>
        <trans-unit id="d6b920160b07e6d8ef62aeb966afe0559c1c4da6" translate="yes" xml:space="preserve">
          <source>BINMODE</source>
          <target state="translated">BINMODE</target>
        </trans-unit>
        <trans-unit id="9afa89ba4b3340d7bc1c3e18c656cfc5abf6d9a7" translate="yes" xml:space="preserve">
          <source>BOOLEAN = less-&amp;gt;of( FEATURE )</source>
          <target state="translated">BOOLEAN = less-&amp;gt; of (피처)</target>
        </trans-unit>
        <trans-unit id="247befebedd2ed6823933439f49eb30a07d09dca" translate="yes" xml:space="preserve">
          <source>BRACKET NOTATION</source>
          <target state="translated">브라켓 표기법</target>
        </trans-unit>
        <trans-unit id="e7772b5b926c191f6bd98767963948f3ffc93baa" translate="yes" xml:space="preserve">
          <source>BS2000 POSIX doesn't support the shebang notation (&lt;code&gt;#!/usr/local/bin/perl&lt;/code&gt; ), so you have to use the following lines instead:</source>
          <target state="translated">BS2000 POSIX는 shebang 표기법 ( &lt;code&gt;#!/usr/local/bin/perl&lt;/code&gt; )을 지원하지 않으므로 대신 다음 줄을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="664c8d2ddb2e4dc2ea085ed16d6df4504ec03ee2" translate="yes" xml:space="preserve">
          <source>BSD::Resource on Solaris</source>
          <target state="translated">Solaris의 BSD :: Resource</target>
        </trans-unit>
        <trans-unit id="df51adc50ecdca424b6145ec6164f8c39197a14c" translate="yes" xml:space="preserve">
          <source>BSD::Resource versions earlier than 1.09 do not compile on Solaris with perl 5.6.0 and higher, for the same reasons as Proc::ProcessTable. BSD::Resource versions starting from 1.09 have a workaround for the problem.</source>
          <target state="translated">1.09 이전의 BSD :: Resource 버전은 Proc :: ProcessTable과 같은 이유로 perl 5.6.0 이상이 설치된 Solaris에서 컴파일되지 않습니다. 1.09부터 시작하는 BSD :: Resource 버전에는이 문제에 대한 해결 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7fe8d7ec43bafda1404b3733deb73b25528fcbd" translate="yes" xml:space="preserve">
          <source>BSLOADLIBS</source>
          <target state="translated">BSLOADLIBS</target>
        </trans-unit>
        <trans-unit id="502dbddd3b35610af6911c0fbc9ca3be4bfe6d63" translate="yes" xml:space="preserve">
          <source>BTW. Beware too of pressure from managers who see you speed a program up by 50% of the runtime once, only to get a request one month later to do the same again (true story) - you'll just have to point out you're only human, even if you are a Perl programmer, and you'll see what you can do...</source>
          <target state="translated">BTW. 프로그램을 한 번만 실행 속도를 50 %까지 높이고 한 달 후에 요청을 다시 한 번만 받으려면 관리자의 압력에주의하십시오 (사실 이야기). Perl 프로그래머라도 인간 만이 할 수있는 일을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b9146b4f38600ca0e41fb96135f743cfdb11eec" translate="yes" xml:space="preserve">
          <source>BUG REPORTING</source>
          <target state="translated">버그보고</target>
        </trans-unit>
        <trans-unit id="664f572fef857b1dfc7d6e286d22026a2508e1e5" translate="yes" xml:space="preserve">
          <source>BUG REPORTS</source>
          <target state="translated">버그 보고서</target>
        </trans-unit>
        <trans-unit id="5dda8c520f4fbfda1830a8a497556d722a3fd113" translate="yes" xml:space="preserve">
          <source>BUGS</source>
          <target state="translated">BUGS</target>
        </trans-unit>
        <trans-unit id="9f989473548a594a947b969757db7fc06ca6a262" translate="yes" xml:space="preserve">
          <source>BUGS AND CAVEATS</source>
          <target state="translated">버그와주의 사항</target>
        </trans-unit>
        <trans-unit id="fe771929835192040a55c6b146d4bbdcf0038546" translate="yes" xml:space="preserve">
          <source>BUGS AND IRRITATIONS</source>
          <target state="translated">버그와 자극</target>
        </trans-unit>
        <trans-unit id="affef23bcfe821a649489c10e4d45ae3607b1ccb" translate="yes" xml:space="preserve">
          <source>BUGS AND LIMITATIONS</source>
          <target state="translated">버그 및 제한</target>
        </trans-unit>
        <trans-unit id="118a34d613c11c790c196c946968113aa8bc32aa" translate="yes" xml:space="preserve">
          <source>BUGS AND PITFALLS</source>
          <target state="translated">버그와 함정</target>
        </trans-unit>
        <trans-unit id="a16fd7f9de623a809defab1d94048e0eded9677b" translate="yes" xml:space="preserve">
          <source>BUGS AND WARNINGS</source>
          <target state="translated">버그 및 경고</target>
        </trans-unit>
        <trans-unit id="2f8e6e225c82badf6f8a92aed6ef242d4dc4d03b" translate="yes" xml:space="preserve">
          <source>BUGS ON CYGWIN</source>
          <target state="translated">CYGWIN의 버그</target>
        </trans-unit>
        <trans-unit id="11f69a17d772a3f0d39aa116f097397dc1dac971" translate="yes" xml:space="preserve">
          <source>BUGS and CAVEATS</source>
          <target state="translated">버그와주의 사항</target>
        </trans-unit>
        <trans-unit id="ccf8d27dca59cf8914b7de42279bcf54b381c80d" translate="yes" xml:space="preserve">
          <source>BUGS is an email or url to post bug reports. For modules with UPSTREAM =&amp;gt; 'blead', use perl5-porters@perl.org. rt.cpan.org appears to automatically provide a URL for CPAN modules; any value given here overrides the default: &lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=&lt;/a&gt;$ModuleName</source>
          <target state="translated">BUGS는 버그 보고서를 게시하는 이메일 또는 URL입니다. UPSTREAM =&amp;gt; 'blead'인 모듈의 경우 perl5-porters@perl.org를 사용하십시오. rt.cpan.org는 CPAN 모듈의 URL을 자동으로 제공하는 것으로 보입니다. 여기에 주어진 값은 기본값을 재정의합니다. &lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=&lt;/a&gt; $ ModuleName</target>
        </trans-unit>
        <trans-unit id="4fa4a173033ffa9b27f16cd2d7b309c255617591" translate="yes" xml:space="preserve">
          <source>BUGS/CAVEATS/etc</source>
          <target state="translated">BUGS/CAVEATS/etc</target>
        </trans-unit>
        <trans-unit id="9b8dfdff736c5b1dbf956b89d8a9d4fd925dacd2" translate="yes" xml:space="preserve">
          <source>BUILD</source>
          <target state="translated">BUILD</target>
        </trans-unit>
        <trans-unit id="0e162e98df920882beaaa37c9fd3fd9860be2bff" translate="yes" xml:space="preserve">
          <source>BUILD AND INSTALL</source>
          <target state="translated">구축 및 설치</target>
        </trans-unit>
        <trans-unit id="80ef3501d89bb441f42a9aac769a351966bde435" translate="yes" xml:space="preserve">
          <source>BUILD NEW EXTENSIONS</source>
          <target state="translated">새로운 확장 프로그램 구축</target>
        </trans-unit>
        <trans-unit id="a5d9fc029fc161e583884fa605ea5dd4bf5b0226" translate="yes" xml:space="preserve">
          <source>BUILDING AND INSTALLING MODULES ON DOS</source>
          <target state="translated">DOS에서 모듈 구축 및 설치</target>
        </trans-unit>
        <trans-unit id="68c9d11aacf08e68cf9222616220471f55a4230e" translate="yes" xml:space="preserve">
          <source>BUILDING PERL FOR OPENVOS</source>
          <target state="translated">OPENVOS를위한 건물 펄</target>
        </trans-unit>
        <trans-unit id="b603dd0f789cea0b71cf17b9cadf6a885369ee6d" translate="yes" xml:space="preserve">
          <source>BUILDING PERL ON AMIGAOS</source>
          <target state="translated">AMIGAOS 건물 펄</target>
        </trans-unit>
        <trans-unit id="d5bdc31108d4219c97e8c1b7e29e0629da746aa9" translate="yes" xml:space="preserve">
          <source>BUNDLES</source>
          <target state="translated">BUNDLES</target>
        </trans-unit>
        <trans-unit id="92b48cc3d13ac12b362038111cf08e5cf8b03696" translate="yes" xml:space="preserve">
          <source>Back before Perl had the XS system for connecting with C libraries, programmers used to get library constants by reading through the C header files. You may still see &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 'syscall.ph'&lt;/code&gt; or similar around - the</source>
          <target state="translated">Perl은 C 라이브러리와 연결하기위한 XS 시스템을 사용하기 전에 프로그래머는 C 헤더 파일을 통해 라이브러리 상수를 얻는 데 사용했습니다. 여전히 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 'syscall.ph'&lt;/code&gt; 또는 이와 유사한 것이 &lt;a href=&quot;functions/require&quot;&gt;필요하다는 것을&lt;/a&gt; 알 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4a3e95e64a0aa298ba1dcd060974643f7be2839b" translate="yes" xml:space="preserve">
          <source>Back then, the range 0xD800-0xDFFF was not allocated. Let's split that range in half and use the first half to represent the &lt;code&gt;upper
half of a character&lt;/code&gt; and the second half to represent the &lt;code&gt;lower
half of a character&lt;/code&gt; . That way, you can represent 1024 * 1024 = 1048576 more characters. Now we can store character ranges up to \x{10ffff} even with 16-bit encodings. This pair of half-character is now called a</source>
          <target state="translated">당시에는 0xD800-0xDFFF 범위가 할당되지 않았습니다. 절반의 범위를 나타내는 데 전반부를 사용하자 분할 &lt;code&gt;upper half of a character&lt;/code&gt; 와 후반부가 나타내는 &lt;code&gt;lower half of a character&lt;/code&gt; . 그렇게하면 1024 * 1024 = 1048576 개 더 많은 문자를 나타낼 수 있습니다. 이제 16 비트 인코딩으로도 문자 범위를 최대 \ x {10ffff}까지 저장할 수 있습니다. 이 반자 쌍은 이제</target>
        </trans-unit>
        <trans-unit id="1f9a2a8bbfa8f04b97f0739e8cee87c19e9a7b1a" translate="yes" xml:space="preserve">
          <source>Back to converting data. If you have (or want) data in your system's native 8-bit encoding (e.g. Latin-1, EBCDIC, etc.), you can use pack/unpack to convert to/from Unicode.</source>
          <target state="translated">데이터 변환으로 돌아갑니다. 시스템의 고유 8 비트 인코딩 (예 : Latin-1, EBCDIC 등)에 데이터가 있거나 원하는 경우 pack / unpack을 사용하여 유니 코드로 /에서 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="917eb438525299e66d70b4deb11770f40a27eeaa" translate="yes" xml:space="preserve">
          <source>Backend for building test libraries</source>
          <target state="translated">테스트 라이브러리 구축을위한 백엔드</target>
        </trans-unit>
        <trans-unit id="60865a55d575470308929e5970d44edcbdb31366" translate="yes" xml:space="preserve">
          <source>Background Processes</source>
          <target state="translated">백그라운드 프로세스</target>
        </trans-unit>
        <trans-unit id="777d367a0813af1945dd6a57f416558fa99c5a72" translate="yes" xml:space="preserve">
          <source>Background and PERL_IMPLICIT_CONTEXT</source>
          <target state="translated">배경과 PERL_IMPLICIT_CONTEXT</target>
        </trans-unit>
        <trans-unit id="82139f465e7bfd51be69bcd2ba2252de65152f38" translate="yes" xml:space="preserve">
          <source>Background yourself like this:</source>
          <target state="translated">이렇게 자신을 배경 :</target>
        </trans-unit>
        <trans-unit id="1c7bd776caf410341796f267d0b5a33a3e4a0364" translate="yes" xml:space="preserve">
          <source>Backreference to a named capture group. Equivalent to &lt;code&gt;\g{NAME}&lt;/code&gt; .</source>
          <target state="translated">명명 된 캡처 그룹에 대한 역 참조. 동등 &lt;code&gt;\g{NAME}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b67830d6a194880657acd61864c65e3027fb02e" translate="yes" xml:space="preserve">
          <source>Backreferences</source>
          <target state="translated">Backreferences</target>
        </trans-unit>
        <trans-unit id="89d9017aad56d057f4819297fea6ec35a3d1c796" translate="yes" xml:space="preserve">
          <source>Backreferences in substitutions use &quot;$&quot; rather than &quot;\&quot;.</source>
          <target state="translated">대체의 역 참조는 &quot;\&quot;대신 &quot;$&quot;를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c5cf510bfb36856574ecae34fa00822be8b9c589" translate="yes" xml:space="preserve">
          <source>Backslash Sequences</source>
          <target state="translated">백 슬래시 시퀀스</target>
        </trans-unit>
        <trans-unit id="db35629fab3798cdd79f1bf42fa413127bebc425" translate="yes" xml:space="preserve">
          <source>Backslash is used, as usual, to escape the next character.</source>
          <target state="translated">일반적으로 백 슬래시는 다음 문자를 이스케이프 처리하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="046c786ef212957156a16429eb6f369b2064b79d" translate="yes" xml:space="preserve">
          <source>Backslash sequence character classes cannot form one of the endpoints of a range. Thus, you can't say:</source>
          <target state="translated">백 슬래시 시퀀스 문자 클래스는 범위의 엔드 포인트 중 하나를 형성 할 수 없습니다. 따라서 당신은 말할 수 없습니다 :</target>
        </trans-unit>
        <trans-unit id="9900e3acb0e0a2eba6b592f80668e5cc6828f6c1" translate="yes" xml:space="preserve">
          <source>Backslash sequences</source>
          <target state="translated">백 슬래시 시퀀스</target>
        </trans-unit>
        <trans-unit id="c61c0b16c1836e4070c1986f40a121b830a65cf5" translate="yes" xml:space="preserve">
          <source>Backslashed characters are either replaced with corresponding literal strings (as with &lt;code&gt;\{&lt;/code&gt;), or else they generate special nodes in the finite automaton (as with &lt;code&gt;\b&lt;/code&gt; ). Characters special to the RE engine (such as &lt;code&gt;|&lt;/code&gt;) generate corresponding nodes or groups of nodes. &lt;code&gt;(?#...)&lt;/code&gt; comments are ignored. All the rest is either converted to literal strings to match, or else is ignored (as is whitespace and &lt;code&gt;#&lt;/code&gt; -style comments if &lt;code&gt;/x&lt;/code&gt; is present).</source>
          <target state="translated">백 슬래시 문자는 해당 리터럴 문자열 ( &lt;code&gt;\{&lt;/code&gt; 과 같이)로 대체 되거나 유한 자동 마마에서 특수 노드를 생성합니다 ( &lt;code&gt;\b&lt;/code&gt; 와 같이 ). RE 엔진에 특수한 문자 (예 : &lt;code&gt;|&lt;/code&gt; )는 해당 노드 또는 노드 그룹을 생성합니다. &lt;code&gt;(?#...)&lt;/code&gt; 주석은 무시됩니다. 나머지는 모두 일치하도록 리터럴 문자열로 변환되거나 무시됩니다 ( &lt;code&gt;/x&lt;/code&gt; 가 있으면 공백 및 &lt;code&gt;#&lt;/code&gt; 스타일 주석 그대로 ).</target>
        </trans-unit>
        <trans-unit id="396b0c95d21c97a92647624c67163f81645740c9" translate="yes" xml:space="preserve">
          <source>Backslashed metacharacters in Perl are alphanumeric, such as &lt;code&gt;\b&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;\n&lt;/code&gt; . Unlike some other regular expression languages, there are no backslashed symbols that aren't alphanumeric. So anything that looks like \\, \(, \), \[, \], \{, or \} is always interpreted as a literal character, not a metacharacter. This was once used in a common idiom to disable or quote the special meanings of regular expression metacharacters in a string that you want to use for a pattern. Simply quote all non-&quot;word&quot; characters:</source>
          <target state="translated">Perl의 백 슬래시 메타 문자는 &lt;code&gt;\b&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;\n&lt;/code&gt; 과 같은 영숫자 입니다. 다른 정규 표현식 언어와 달리 영숫자가 아닌 백 슬래시 기호는 없습니다. 따라서 \\, \ (, \), \ [, \], \ {또는 \}와 같은 것은 항상 메타 문자가 아닌 리터럴 문자로 해석됩니다. 이것은 한 번의 공용 관용구에서 패턴에 사용하려는 문자열에서 정규식 메타 문자의 특수 의미를 비활성화하거나 인용하는 데 사용되었습니다. &quot;단어&quot;가 아닌 문자를 모두 인용하십시오.</target>
        </trans-unit>
        <trans-unit id="5ad3bd6856b2f78166ba432a9cdf4da8413a4090" translate="yes" xml:space="preserve">
          <source>Backslashes parentheses &lt;code&gt;()&lt;/code&gt; in command line arguments. Doesn't handle recursive Makefile &lt;code&gt;$(...)&lt;/code&gt; constructs, but handles simple ones.</source>
          <target state="translated">명령 행 인수에서 백 슬래시 괄호 &lt;code&gt;()&lt;/code&gt; . 재귀 Makefile &lt;code&gt;$(...)&lt;/code&gt; 구문은 처리하지 않지만 간단한 구문은 처리합니다.</target>
        </trans-unit>
        <trans-unit id="8ef1c0d1318e1460dedacce3731d309fc7ffbb8a" translate="yes" xml:space="preserve">
          <source>Backticks &lt;code&gt;``&lt;/code&gt; (see &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;) with the command which contains redirection or shell meta-characters;</source>
          <target state="translated">경로 재 지정 또는 쉘 메타 문자를 포함하는 명령이있는 &lt;code&gt;``&lt;/code&gt; ( 틱의 &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I / O 연산자&lt;/a&gt; 참조 );</target>
        </trans-unit>
        <trans-unit id="6e2b605f65ba36a3d929c62881915b96a794f8f1" translate="yes" xml:space="preserve">
          <source>Backticks create a subprocess, and pass the enclosed string to it for execution as a DCL command. Since the subprocess is created directly via &lt;code&gt;lib$spawn()&lt;/code&gt; , any valid DCL command string may be specified.</source>
          <target state="translated">백틱은 하위 프로세스를 만들고 DCL 명령으로 실행하기 위해 동봉 된 문자열을 전달합니다. 서브 프로세스는 &lt;code&gt;lib$spawn()&lt;/code&gt; 통해 직접 작성되므로 유효한 DCL 명령 문자열을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34532d18ad2d0f70e2d7b957fabc96ee06bc62fe" translate="yes" xml:space="preserve">
          <source>Backtracking</source>
          <target state="translated">Backtracking</target>
        </trans-unit>
        <trans-unit id="6e522c194b60635ece31d387544d1195051e629c" translate="yes" xml:space="preserve">
          <source>Backtracking control verbs</source>
          <target state="translated">역 추적 동사</target>
        </trans-unit>
        <trans-unit id="14496432005368ea983df3ea81b1252443b8ee8b" translate="yes" xml:space="preserve">
          <source>Backtracking during the relentless search for a match may be a waste of time, particularly when the match is bound to fail. Consider the simple pattern</source>
          <target state="translated">경기에 대한 끊임없는 검색 중 역 추적은 특히 경기가 실패 할 때 시간 낭비 일 수 있습니다. 간단한 패턴을 고려하십시오</target>
        </trans-unit>
        <trans-unit id="0bce7971052281b2bb5edb4f3a21f79dd6904b31" translate="yes" xml:space="preserve">
          <source>Backtracking is more efficient than repeated tries with different regular expressions. If there are several regular expressions and a match with any of them is acceptable, then it is possible to combine them into a set of alternatives. If the individual expressions are input data, this can be done by programming a join operation. We'll exploit this idea in an improved version of the &lt;code&gt;simple_grep&lt;/code&gt; program: a program that matches multiple patterns:</source>
          <target state="translated">역 추적은 정규 표현식이 다른 반복 된 시도보다 효율적입니다. 정규 표현식이 여러 개 있고 그 중 하나와 일치하는 것이 허용되는 경우 여러 가지 대안으로 조합 할 수 있습니다. 개별 표현식이 입력 데이터 인 경우 조인 작업을 프로그래밍하여 수행 할 수 있습니다. 개선 된 버전의 &lt;code&gt;simple_grep&lt;/code&gt; 프로그램 (여러 패턴과 일치하는 프로그램) 에서이 아이디어를 활용할 것입니다 .</target>
        </trans-unit>
        <trans-unit id="fd4a1f65749d89056abcaeac3722a7b7a8fe75a1" translate="yes" xml:space="preserve">
          <source>Backward Compatibility</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23a7808b48afc84b0dceb9136590ca7bfdbb9b77" translate="yes" xml:space="preserve">
          <source>Backward compatibility</source>
          <target state="translated">하위 호환성</target>
        </trans-unit>
        <trans-unit id="ec09211f4889a2c8a77bac08067eb8783a4cd974" translate="yes" xml:space="preserve">
          <source>Backward compatible boilerplate</source>
          <target state="translated">이전 버전과 호환되는 상용구</target>
        </trans-unit>
        <trans-unit id="8fd78925dba59eef91afba0cdabe923520e5ee69" translate="yes" xml:space="preserve">
          <source>Backwards compatibility</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cec2366e742bda57450610acf903181d2989bf8" translate="yes" xml:space="preserve">
          <source>Bad example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55cc23ba5301ba2564daa62213188ebb8c917e57" translate="yes" xml:space="preserve">
          <source>Bailout result token.</source>
          <target state="translated">구제 결과 토큰.</target>
        </trans-unit>
        <trans-unit id="c9c7caaefe38d5bc0e42cffe87236c93a6e055ee" translate="yes" xml:space="preserve">
          <source>Bal&amp;aacute;zs Szab&amp;oacute; (dLux), dlux@kapu.hu</source>
          <target state="translated">Bal&amp;aacute;zs Szab&amp;oacute; (dLux), dlux@kapu.hu</target>
        </trans-unit>
        <trans-unit id="528dadc6eada08b37b8564a84bbd615fedfa3a6d" translate="yes" xml:space="preserve">
          <source>Bar.pm</source>
          <target state="translated">Bar.pm</target>
        </trans-unit>
        <trans-unit id="991cc000e0ed51287d06994419ec5b5150b2fbbf" translate="yes" xml:space="preserve">
          <source>Bar.xs</source>
          <target state="translated">Bar.xs</target>
        </trans-unit>
        <trans-unit id="4d1ae41c7e90ad9133f0cec4b012d051f81574f4" translate="yes" xml:space="preserve">
          <source>Barewords</source>
          <target state="translated">Barewords</target>
        </trans-unit>
        <trans-unit id="6be542a3a79d103a3744357ed20ec40db010c97c" translate="yes" xml:space="preserve">
          <source>Barewords are not covered by overloaded string constants.</source>
          <target state="translated">키워드는 오버로드 된 문자열 상수로 처리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a58b8ede3c3c15995119146605014af774c7bcd7" translate="yes" xml:space="preserve">
          <source>Base Class for IO::Compress modules</source>
          <target state="translated">IO :: Compress 모듈의 기본 클래스</target>
        </trans-unit>
        <trans-unit id="1aecc52f6145193c99cc41e745488c8d94f4db0b" translate="yes" xml:space="preserve">
          <source>Base Class for IO::Uncompress modules</source>
          <target state="translated">IO :: Uncompress 모듈의 기본 클래스</target>
        </trans-unit>
        <trans-unit id="9410f6a2867439548603d6c52d5c59ef4562fa7b" translate="yes" xml:space="preserve">
          <source>Base Structures</source>
          <target state="translated">기본 구조</target>
        </trans-unit>
        <trans-unit id="082fae7b28f65e5cb911e0f3f3f15b07bb66cbb1" translate="yes" xml:space="preserve">
          <source>Base class definitions for tied handles</source>
          <target state="translated">연결된 핸들에 대한 기본 클래스 정의</target>
        </trans-unit>
        <trans-unit id="007ee9121a8b9e57fcd866ceebd36b23a00f0fde" translate="yes" xml:space="preserve">
          <source>Base class definitions for tied hashes</source>
          <target state="translated">연결 해시의 기본 클래스 정의</target>
        </trans-unit>
        <trans-unit id="b6b455ad8f579493b53af2265bc184f2ba6c6cbb" translate="yes" xml:space="preserve">
          <source>Base class definitions for tied scalars</source>
          <target state="translated">연결된 스칼라에 대한 기본 클래스 정의</target>
        </trans-unit>
        <trans-unit id="9cae4a150d12d8ffc0b3fa77692959a6c4bfb799" translate="yes" xml:space="preserve">
          <source>Base class for ALL classes (blessed references)</source>
          <target state="translated">모든 클래스의 기본 클래스 (축복 참조)</target>
        </trans-unit>
        <trans-unit id="35cd310da77bd29a53a2d4932d2eb92ae62a2b7e" translate="yes" xml:space="preserve">
          <source>Base class for CPAN shell extensions</source>
          <target state="translated">CPAN 쉘 확장의 기본 클래스</target>
        </trans-unit>
        <trans-unit id="c3e0f91a5e302404f6913115b1263f4db4575024" translate="yes" xml:space="preserve">
          <source>Base class for ExtUtils::Constant objects</source>
          <target state="translated">ExtUtils :: Constant 객체의 기본 클래스</target>
        </trans-unit>
        <trans-unit id="5ce69fa0ba6f632f7e9c5c2e2e7602e063a7c7a9" translate="yes" xml:space="preserve">
          <source>Base class for TAP source iterators</source>
          <target state="translated">TAP 소스 반복기의 기본 클래스</target>
        </trans-unit>
        <trans-unit id="37eb343993cd16220ab0f185a716f5c376429394" translate="yes" xml:space="preserve">
          <source>Base class for TAP::Parser output objects</source>
          <target state="translated">TAP :: Parser 출력 객체의 기본 클래스</target>
        </trans-unit>
        <trans-unit id="b8befc5059605409ade42b4d099e397b207c906b" translate="yes" xml:space="preserve">
          <source>Base class for creating POD filters and translators</source>
          <target state="translated">POD 필터 및 번역기를 만들기위한 기본 클래스</target>
        </trans-unit>
        <trans-unit id="78eefd2e412b4d4df740ff4fbfcce92bad174022" translate="yes" xml:space="preserve">
          <source>Base class for different TAP source handlers</source>
          <target state="translated">다른 TAP 소스 핸들러에 대한 기본 클래스</target>
        </trans-unit>
        <trans-unit id="e4dfc8dbeda31aa613f1ab98bcf6af5cdb80223d" translate="yes" xml:space="preserve">
          <source>Base class for harness output delegates</source>
          <target state="translated">하네스 출력 대리자를위한 기본 클래스</target>
        </trans-unit>
        <trans-unit id="7a74e67740b1a1d00bee0be3088f31fbc10821ea" translate="yes" xml:space="preserve">
          <source>Base class for test modules</source>
          <target state="translated">테스트 모듈의 기본 클래스</target>
        </trans-unit>
        <trans-unit id="78996d2c61d5e3e13d981dd6371495a7dc1b0695" translate="yes" xml:space="preserve">
          <source>Base class for tied arrays</source>
          <target state="translated">연결된 배열의 기본 클래스</target>
        </trans-unit>
        <trans-unit id="8811ba419e75aa7afad3c58a4392ff34e2f70b65" translate="yes" xml:space="preserve">
          <source>Base class that provides common functionality to &lt;a href=&quot;tap/parser&quot;&gt;TAP::Parser&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;tap/parser&quot;&gt;TAP :: Parser에&lt;/a&gt; 공통 기능을 제공하는 기본 클래스</target>
        </trans-unit>
        <trans-unit id="0808d28ca43c79c7220c0b66b8832ca8877ecfdc" translate="yes" xml:space="preserve">
          <source>Base class that provides common functionality to all &lt;code&gt;TAP::*&lt;/code&gt; modules</source>
          <target state="translated">모든 &lt;code&gt;TAP::*&lt;/code&gt; 모듈에 공통 기능을 제공하는 기본 클래스</target>
        </trans-unit>
        <trans-unit id="7a76be2c1588f2035fb74a3a61c2be909fdefa70" translate="yes" xml:space="preserve">
          <source>Base for Pod::Perldoc formatters</source>
          <target state="translated">Pod :: Perldoc 포맷터 용베이스</target>
        </trans-unit>
        <trans-unit id="2291e71c9ac6320d0a4640a773f789651e805f6a" translate="yes" xml:space="preserve">
          <source>Based on Stevan Little's &lt;a href=&quot;http://search.cpan.org/perldoc/Class::C3&quot;&gt;Class::C3&lt;/a&gt;</source>
          <target state="translated">Stevan Little 's &lt;a href=&quot;http://search.cpan.org/perldoc/Class::C3&quot;&gt;Class :: C3&lt;/a&gt; 기반</target>
        </trans-unit>
        <trans-unit id="560c120ffa51ce8d2dc3b95d35311dd465a3c278" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;Pod::Text::pod2text()&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;이 작성한 &lt;b&gt;Pod :: Text :: pod2text ()&lt;/b&gt; 코드 기반</target>
        </trans-unit>
        <trans-unit id="25b805dbff71baab76550b6af4db1656526ccb89" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;Pod::Text::pod2text(1)&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;이 작성한 &lt;b&gt;Pod :: Text :: pod2text (1)&lt;/b&gt; 코드 기반</target>
        </trans-unit>
        <trans-unit id="b781efd9c14a9bf17ea0a940b2c65ad0a21bc5c6" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;Pod::Text&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;이 작성한 &lt;b&gt;포드 :: 텍스트&lt;/b&gt; 코드 기반</target>
        </trans-unit>
        <trans-unit id="d91768d646bf2b1ba37683cf7ff89c9b306d5b4f" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;pod2text(1)&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;이 작성한 &lt;b&gt;pod2text (1)&lt;/b&gt; 코드 기반</target>
        </trans-unit>
        <trans-unit id="e809a71bc55e573d735398064fa73868c841b25e" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;pod2text&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;이 작성한 &lt;b&gt;pod2text&lt;/b&gt; 코드 기반</target>
        </trans-unit>
        <trans-unit id="23082a2ee1ef553f8b8e9cc56e439b97636f01bf" translate="yes" xml:space="preserve">
          <source>Based on code written by Shigio Yamaguchi.</source>
          <target state="translated">Shigio Yamaguchi가 작성한 코드를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="8e0d5bb83e47c2192346afc47fe774052eb51e39" translate="yes" xml:space="preserve">
          <source>Based on example that was initially added to MIME::QuotedPrint.pm for the 5.8.0 distribution of Perl.</source>
          <target state="translated">Perl의 5.8.0 배포를 위해 MIME :: QuotedPrint.pm에 처음 추가 된 예를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="a800ab4559098c87aba7a8e90188704683d129b8" translate="yes" xml:space="preserve">
          <source>Based on ideas from Tim Bunce &amp;lt;&lt;code&gt;Tim.Bunce@ig.co.uk&lt;/code&gt; &amp;gt; and</source>
          <target state="translated">Tim Bunce &amp;lt; &lt;code&gt;Tim.Bunce@ig.co.uk&lt;/code&gt; &amp;gt;의 아이디어를 바탕으로</target>
        </trans-unit>
        <trans-unit id="ef4b57022699f0d3f5da98a8d57cddc66db361df" translate="yes" xml:space="preserve">
          <source>Based on the &lt;code&gt;:perlio&lt;/code&gt; layer.</source>
          <target state="translated">&lt;code&gt;:perlio&lt;/code&gt; 레이어를 기반으로합니다 .</target>
        </trans-unit>
        <trans-unit id="6189eca4d6c06b60af97bb9ce0c1f1fc615c134d" translate="yes" xml:space="preserve">
          <source>Based on the &lt;code&gt;ExtUtils::xsubpp&lt;/code&gt; code by Larry Wall and the Perl 5 Porters, which was released under the same license terms.</source>
          <target state="translated">Larry Wall과 Perl 5 Porters 의 &lt;code&gt;ExtUtils::xsubpp&lt;/code&gt; 코드를 기반으로하며 동일한 라이센스 조건에 따라 릴리스되었습니다.</target>
        </trans-unit>
        <trans-unit id="da8636da22477810e470724d83ddc721d3335da8" translate="yes" xml:space="preserve">
          <source>Based on the Glossary of</source>
          <target state="translated">용어집을 기반으로</target>
        </trans-unit>
        <trans-unit id="f28c9a8ac3d744f82801c7cfbb9de24801e7c563" translate="yes" xml:space="preserve">
          <source>Based on xsubpp code, written by Larry Wall.</source>
          <target state="translated">Larry Wall이 작성한 xsubpp 코드를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="02905231fdcd4472df63f80b291fb153344c31cd" translate="yes" xml:space="preserve">
          <source>Basic BLOCKs</source>
          <target state="translated">기본 블록</target>
        </trans-unit>
        <trans-unit id="901e56ace2d31ac4485efe2aa588116787957443" translate="yes" xml:space="preserve">
          <source>Basic IO operations</source>
          <target state="translated">기본 IO 작업</target>
        </trans-unit>
        <trans-unit id="8422cb1795fcef709d3e089320f56308fec39046" translate="yes" xml:space="preserve">
          <source>Basic Multilingual Plane</source>
          <target state="translated">기본 다국어 비행기</target>
        </trans-unit>
        <trans-unit id="ccecd116866361404babdb87c039096fbb71e99c" translate="yes" xml:space="preserve">
          <source>Basic Structure</source>
          <target state="translated">기본 구조</target>
        </trans-unit>
        <trans-unit id="39bbc4bee9f4a75c10797a6d328f733ea1124880" translate="yes" xml:space="preserve">
          <source>Basic Thread Support</source>
          <target state="translated">기본 스레드 지원</target>
        </trans-unit>
        <trans-unit id="17f89c170a632afd0c0b0383dacf728c05a89851" translate="yes" xml:space="preserve">
          <source>Basic Utilities for Programmers</source>
          <target state="translated">프로그래머를위한 기본 유틸리티</target>
        </trans-unit>
        <trans-unit id="148d2121cd077901af2d5cbf9aa363677304a06b" translate="yes" xml:space="preserve">
          <source>Basic commands:</source>
          <target state="translated">기본 명령 :</target>
        </trans-unit>
        <trans-unit id="7308cb8418c068204c128968b5967fdf3606cc09" translate="yes" xml:space="preserve">
          <source>Basic methods</source>
          <target state="translated">기본 방법</target>
        </trans-unit>
        <trans-unit id="874d9df75ebdafc19870b90059bb69c04cb1fce7" translate="yes" xml:space="preserve">
          <source>Basic read operation.</source>
          <target state="translated">기본 읽기 작업</target>
        </trans-unit>
        <trans-unit id="c4901220ad10be08f037f204182ab7f0bb55ef8b" translate="yes" xml:space="preserve">
          <source>Basic semaphores</source>
          <target state="translated">기본 세마포어</target>
        </trans-unit>
        <trans-unit id="cf61d93532db2a473529a2856c70f230829513f8" translate="yes" xml:space="preserve">
          <source>Basic syntax overview</source>
          <target state="translated">기본 구문 개요</target>
        </trans-unit>
        <trans-unit id="ce7944aa05e48b110f9c5b8903d70aed90358355" translate="yes" xml:space="preserve">
          <source>Basic utilities for writing tests.</source>
          <target state="translated">테스트 작성을위한 기본 유틸리티.</target>
        </trans-unit>
        <trans-unit id="62b9ac85afbcfa7bd7a8e867b1f51756e30ca7d7" translate="yes" xml:space="preserve">
          <source>Basic write operation.</source>
          <target state="translated">기본 쓰기 작업</target>
        </trans-unit>
        <trans-unit id="04e2b1373d1c985716d261c139c35de4bc421d62" translate="yes" xml:space="preserve">
          <source>Basically, Intel and VAX CPUs are little-endian, while everybody else, including Motorola m68k/88k, PPC, Sparc, HP PA, Power, and Cray, are big-endian. Alpha and MIPS can be either: Digital/Compaq uses (well, used) them in little-endian mode, but SGI/Cray uses them in big-endian mode.</source>
          <target state="translated">기본적으로 Intel 및 VAX CPU는 리틀 엔디안이며 Motorola m68k / 88k, PPC, Sparc, HP PA, Power 및 Cray를 포함한 다른 모든 사람은 빅 엔디안입니다. Alpha 및 MIPS는 다음 중 하나 일 수 있습니다. Digital / Compaq은 리틀 엔디안 모드에서 사용하지만 SGI / Cray는 빅 엔디안 모드에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1f10fe5797c3d1f7733a7eb604c9de17cf9d91ac" translate="yes" xml:space="preserve">
          <source>Basically, you fetch individual results from the TAP. The six types, with examples of each, are as follows:</source>
          <target state="translated">기본적으로 TAP에서 개별 결과를 가져옵니다. 각각의 예를 포함하는 6 가지 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3764ce6b277261088796ef6723dbaafdda0e32f0" translate="yes" xml:space="preserve">
          <source>Be aware of two important points:</source>
          <target state="translated">두 가지 중요한 사항에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="e4436a305cd04dc72f8078b037e6c2a662f1fa1d" translate="yes" xml:space="preserve">
          <source>Be aware that all filenames returned from File::Glob are tainted.</source>
          <target state="translated">File :: Glob에서 반환 된 모든 파일 이름이 오염되었습니다.</target>
        </trans-unit>
        <trans-unit id="60f217633ac67f75e40713203caa69acc0ee5347" translate="yes" xml:space="preserve">
          <source>Be aware that setting &lt;code&gt;@DB::args&lt;/code&gt; is</source>
          <target state="translated">&lt;code&gt;@DB::args&lt;/code&gt; 설정 은</target>
        </trans-unit>
        <trans-unit id="667b9a553537bba23ef30dd15f8a2bf40c9a72d6" translate="yes" xml:space="preserve">
          <source>Be aware that the digest routines silently convert UTF-8 input into its equivalent byte sequence in the native encoding (cf. utf8::downgrade). This side effect influences only the way Perl stores the data internally, but otherwise leaves the actual value of the data intact.</source>
          <target state="translated">다이제스트 루틴은 UTF-8 입력을 기본 인코딩에서 동등한 바이트 시퀀스로 자동 변환합니다 (참조 : utf8 :: downgrade). 이 부작용은 Perl이 데이터를 내부적으로 저장하는 방식에만 영향을 주지만 그렇지 않으면 데이터의 실제 값은 그대로 둡니다.</target>
        </trans-unit>
        <trans-unit id="167d28f752fc336f0724d4becf42fb8c17cf60ad" translate="yes" xml:space="preserve">
          <source>Be aware that the file's type/creator and resource fork will be lost, which is usually what you want in cross-platform archives.</source>
          <target state="translated">파일의 유형 / 생성자 및 리소스 포크가 손실된다는 점에 유의하십시오. 이는 일반적으로 크로스 플랫폼 아카이브에서 원하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2a627d6aeb5bb9832269cd11d71094ebccabe8d0" translate="yes" xml:space="preserve">
          <source>Be aware that the main value of this module is its simplicity. Note that there are already more ambitious modules out there, such as &lt;a href=&quot;test/more&quot;&gt;Test::More&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Unit&quot;&gt;Test::Unit&lt;/a&gt;.</source>
          <target state="translated">이 모듈의 주요 가치는 단순성입니다. &lt;a href=&quot;test/more&quot;&gt;Test :: More&lt;/a&gt; 및 &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Unit&quot;&gt;Test :: Unit&lt;/a&gt; 과 같이 더 야심 찬 모듈이 이미 있습니다 .</target>
        </trans-unit>
        <trans-unit id="31de5d87ee0c0608b86806f39ac15e28011be167" translate="yes" xml:space="preserve">
          <source>Be aware that the optimizer might have optimized call frames away before &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; had a chance to get the information. That means that &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller(N)&lt;/a&gt;&lt;/code&gt; might not return information about the call frame you expect it to, for &lt;code&gt;N &amp;gt; 1&lt;/code&gt; . In particular, &lt;code&gt;@DB::args&lt;/code&gt; might have information from the previous time &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; was called.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; 가 정보를 얻을 수 있기 전에 옵티마이 저가 호출 프레임을 최적화했을 수 있습니다 . 즉, &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller(N)&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;N &amp;gt; 1&lt;/code&gt; 대해 예상 한 호출 프레임에 대한 정보를 반환하지 않을 수 있습니다 . 특히 &lt;code&gt;@DB::args&lt;/code&gt; 에는 이전에 &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; 가 호출 된 정보가있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="956f008e111339a547685e28f223bd6fbcba83d9" translate="yes" xml:space="preserve">
          <source>Be aware that the optimizer might have optimized call frames away before &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; had a chance to get the information. That means that &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller(N)&lt;/a&gt;&lt;/code&gt; might not return information about the call frame you expect it to, for &lt;code&gt;N &amp;gt; 1&lt;/code&gt; . In particular, &lt;code&gt;@DB::args&lt;/code&gt; might have information from the previous time &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; was called.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; 가 정보를 얻을 수 있기 전에 옵티마이 저가 호출 프레임을 최적화했을 수 있습니다 . 즉, &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller(N)&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;N &amp;gt; 1&lt;/code&gt; 대해 예상 한 호출 프레임에 대한 정보를 반환하지 않을 수 있습니다 . 특히 &lt;code&gt;@DB::args&lt;/code&gt; 에는 이전에 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; 가 호출 된 정보가있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd6d74606bcc17d1eb7f4b9d0cbb233b2fce04be" translate="yes" xml:space="preserve">
          <source>Be aware that the option to follow symbolic links can be dangerous. Depending on the structure of the directory tree (including symbolic links to directories) you might traverse a given (physical) directory more than once (only if &lt;code&gt;follow_fast&lt;/code&gt; is in effect). Furthermore, deleting or changing files in a symbolically linked directory might cause very unpleasant surprises, since you delete or change files in an unknown directory.</source>
          <target state="translated">심볼릭 링크를 따르는 옵션은 위험 할 수 있습니다. 디렉토리 트리의 구조 (디렉토리에 대한 심볼릭 링크 포함)에 따라 주어진 (물리적) 디렉토리를 두 ​​번 이상 통과 할 수 있습니다 ( &lt;code&gt;follow_fast&lt;/code&gt; 가 유효한 경우에만 ). 또한, 기호로 연결된 디렉토리에서 파일을 삭제하거나 변경하면 알 수없는 디렉토리에서 파일을 삭제하거나 변경하기 때문에 매우 불쾌한 결과를 초래할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b81ba14d3ce3de8180275845ca38e42a572b2c9a" translate="yes" xml:space="preserve">
          <source>Be aware that these operations are full Unix forks, which means they may not be correctly implemented on all alien systems.</source>
          <target state="translated">이러한 작업은 완전한 Unix 포크이므로 모든 외계 시스템에서 올바르게 구현되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6dac6d64c1feff1fddea48f799c315f06283805b" translate="yes" xml:space="preserve">
          <source>Be aware that, when using this option, the input encoding of your POD source must be properly declared unless it is US-ASCII or Latin-1. POD input without an &lt;code&gt;=encoding&lt;/code&gt; command will be assumed to be in Latin-1, and if it's actually in UTF-8, the output will be double-encoded. See</source>
          <target state="translated">이 옵션을 사용할 때 POD 소스의 입력 인코딩은 US-ASCII 또는 Latin-1이 아닌 경우 올바르게 선언해야합니다. &lt;code&gt;=encoding&lt;/code&gt; 명령이 없는 POD 입력 은 Latin-1 인 것으로 가정하고 실제로 UTF-8 인 경우 출력이 이중 인코딩됩니다. 보다</target>
        </trans-unit>
        <trans-unit id="8e54fdab18656cd50e15f88c4bd2cd505cbcafa9" translate="yes" xml:space="preserve">
          <source>Be aware, moreover, that even among Unix-ish systems there are variations.</source>
          <target state="translated">게다가 유닉스 시스템에서도 변형이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56eaa37568b649078a87e40ea7bc8697501ac281" translate="yes" xml:space="preserve">
          <source>Be careful about the syntax,</source>
          <target state="translated">구문에주의하십시오.</target>
        </trans-unit>
        <trans-unit id="b3f347eeb5e9dd5ad6442952b1aeb5c318d4fa11" translate="yes" xml:space="preserve">
          <source>Be careful if you put double quotes around the picture, because an &lt;code&gt;@&lt;/code&gt; character may be taken to mean the beginning of an array name. &lt;code&gt;&lt;a href=&quot;formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; always returns true. See &lt;a href=&quot;../perlform&quot;&gt;perlform&lt;/a&gt; for other examples.</source>
          <target state="translated">&lt;code&gt;@&lt;/code&gt; 문자는 배열 이름의 시작을 의미 하기 때문에 사진 주위에 큰 따옴표를 넣으면주의하십시오 . &lt;code&gt;&lt;a href=&quot;formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; 은 항상 true를 반환합니다. 다른 예는 &lt;a href=&quot;../perlform&quot;&gt;perlform&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6906a7867a27a79ea2a227d91624d262e203f04e" translate="yes" xml:space="preserve">
          <source>Be careful if you put double quotes around the picture, because an &lt;code&gt;@&lt;/code&gt; character may be taken to mean the beginning of an array name. &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; always returns true. See &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; for other examples.</source>
          <target state="translated">&lt;code&gt;@&lt;/code&gt; 문자는 배열 이름의 시작을 의미 하기 때문에 사진 주위에 큰 따옴표를 넣으면주의하십시오 . &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; 은 항상 true를 반환합니다. 다른 예는 &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a9293d7623c3a63a2528c6144b0e2f16fd9c21b7" translate="yes" xml:space="preserve">
          <source>Be careful in the tests you supply with your module or programs. Module code may be fully portable, but its tests might not be. This often happens when tests spawn off other processes or call external programs to aid in the testing, or when (as noted above) the tests assume certain things about the filesystem and paths. Be careful not to depend on a specific output style for errors, such as when checking &lt;code&gt;$!&lt;/code&gt; after a failed system call. Using &lt;code&gt;$!&lt;/code&gt; for anything else than displaying it as output is doubtful (though see the &lt;code&gt;Errno&lt;/code&gt; module for testing reasonably portably for error value). Some platforms expect a certain output format, and Perl on those platforms may have been adjusted accordingly. Most specifically, don't anchor a regex when testing an error value.</source>
          <target state="translated">모듈 또는 프로그램과 함께 제공되는 테스트에주의하십시오. 모듈 코드는 완전히 이식 가능하지만 테스트는 불가능할 수 있습니다. 테스트가 다른 프로세스를 생성하거나 테스트를 돕기 위해 외부 프로그램을 호출하거나 (위에서 언급 한 바와 같이) 테스트가 파일 시스템 및 경로에 대한 특정 사항을 가정 할 때 종종 발생합니다. &lt;code&gt;$!&lt;/code&gt; 확인할 때와 같이 오류에 대해 특정 출력 스타일에 의존하지 않도록주의하십시오 ! 실패한 시스템 호출 후 &lt;code&gt;$!&lt;/code&gt; 사용 ! 출력이 의심스러운 것으로 표시하는 것 이외의 다른 것은 ( 오류 값에 대해 합리적으로 이식 가능하게 테스트하기 위해 &lt;code&gt;Errno&lt;/code&gt; 모듈을 참조하십시오 ). 일부 플랫폼은 특정 출력 형식을 기대하며 해당 플랫폼의 Perl이 그에 따라 조정되었을 수 있습니다. 가장 구체적으로, 오류 값을 테스트 할 때 정규식을 고정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="ae93e14e0d1be510a7665d0a55ac6aa4f668df14" translate="yes" xml:space="preserve">
          <source>Be careful to check that what you pass to chdir() is defined and not blank, else you might find yourself in your home directory.</source>
          <target state="translated">chdir ()에 전달한 내용이 정의되어 있고 비어 있지 않은지 확인하십시오. 그렇지 않으면 홈 디렉토리에서 자신을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c85ebb348de7431489e7e78b8e62158b4eaa9740" translate="yes" xml:space="preserve">
          <source>Be careful to check the return values from both open() and close(). If you're</source>
          <target state="translated">open ()과 close ()에서 리턴 값을 확인하십시오. 당신이 있다면</target>
        </trans-unit>
        <trans-unit id="aee2df458bcc4bef02091d782f8436bc138473c7" translate="yes" xml:space="preserve">
          <source>Be careful to repeat this procedure every time you recompile an extension, unless you are sure the AFS installation directories are still valid.</source>
          <target state="translated">AFS 설치 디렉토리가 여전히 유효한지 확신하지 않는 한, 확장을 재 컴파일 할 때마다이 절차를 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="fe76e94f1a35b852ed4a509f3683ff3f6a306181" translate="yes" xml:space="preserve">
          <source>Be careful when using the branch reset pattern in combination with named captures. Named captures are implemented as being aliases to numbered groups holding the captures, and that interferes with the implementation of the branch reset pattern. If you are using named captures in a branch reset pattern, it's best to use the same names, in the same order, in each of the alternations:</source>
          <target state="translated">명명 된 캡처와 함께 분기 재설정 패턴을 사용할 때주의하십시오. 명명 된 캡처는 캡처를 보유한 번호가 지정된 그룹의 별명으로 구현되며 이는 분기 재설정 패턴의 구현을 방해합니다. 분기 재설정 패턴으로 명명 된 캡처를 사용하는 경우 각 대체에서 동일한 순서로 동일한 이름을 사용하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8f8df673aaa9f753cd8e9cf23c8cbbd3b2574c49" translate="yes" xml:space="preserve">
          <source>Be careful, though, to never combine text strings with binary strings. If you need text in a binary stream, encode your text strings first using the appropriate encoding, then join them with binary strings. See also: &quot;What if I don't encode?&quot;.</source>
          <target state="translated">그러나 텍스트 문자열을 이진 문자열과 결합하지 않도록주의하십시오. 이진 스트림에 텍스트가 필요한 경우 먼저 적절한 인코딩을 사용하여 텍스트 문자열을 인코딩 한 다음 이진 문자열로 조인하십시오. &quot;인코딩하지 않으면 어떻게됩니까?&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cef4ef62c32e58e84f80436ec819bfd5a7afa02c" translate="yes" xml:space="preserve">
          <source>Be careful: qx(), system(), and some modules for calling external commands do a fork(), then wait() for the result. Thus, your signal handler will be called. Because wait() was already called by system() or qx(), the wait() in the signal handler will see no more zombies and will therefore block.</source>
          <target state="translated">qx (), system () 및 외부 명령 호출을위한 일부 모듈은 fork ()를 수행 한 다음 결과를 기다립니다 (주의). 따라서 신호 처리기가 호출됩니다. wait ()는 이미 system () 또는 qx ()에 의해 호출되었으므로 신호 처리기의 wait ()는 더 이상 좀비를 보지 않으므로 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="02350f9e1a884f10cacbddf6be8d623a44b68fcb" translate="yes" xml:space="preserve">
          <source>Be consistent with existing modules.</source>
          <target state="translated">기존 모듈과 일관성을 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="8f9f60dfc3f60d9409a16936419f8f9c34030221" translate="yes" xml:space="preserve">
          <source>Be consistent.</source>
          <target state="translated">일관성을 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="0657b8fedf171a48206a6318d37358a77e53c6fb" translate="yes" xml:space="preserve">
          <source>Be descriptive (i.e. accurately describes the purpose of the module).</source>
          <target state="translated">설명이 필요합니다 (즉, 모듈의 목적을 정확하게 설명하십시오).</target>
        </trans-unit>
        <trans-unit id="4866ce84e5913e3bbf14d1ef419eb24f1d72a52e" translate="yes" xml:space="preserve">
          <source>Be it &lt;code&gt;Compress::Zlib&lt;/code&gt; , &lt;code&gt;Apache::Request&lt;/code&gt; or any extension that has no mention of Unicode in the manpage, you need to make sure that the UTF8 flag is stripped off. Note that at the time of this writing (January 2012) the mentioned modules are not UTF-8-aware. Please check the documentation to verify if this is still true.</source>
          <target state="translated">이 수 &lt;code&gt;Compress::Zlib&lt;/code&gt; , &lt;code&gt;Apache::Request&lt;/code&gt; 또는 맨 페이지에 유니 코드에 대한 언급이없는 확장자, 당신은 반드시 UTF8 플래그가 벗겨되어 있는지 확인해야합니다. 이 글을 쓰는 시점 (2012 년 1 월)에 언급 된 모듈은 UTF-8을 인식하지 않습니다. 이것이 사실인지 확인하려면 설명서를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="fec8bd9db93426cc5f677cbbc44d58f990b4ce4f" translate="yes" xml:space="preserve">
          <source>Be nice.</source>
          <target state="translated">착하게 굴 어라.</target>
        </trans-unit>
        <trans-unit id="455d700825e4b9a7601c1ce54b47786ce81ebe18" translate="yes" xml:space="preserve">
          <source>Be sure not to use a bareword as the name of a signal handler, lest you inadvertently call it.</source>
          <target state="translated">실수로 호출하지 않도록 신호 처리기의 이름으로 베어 워드를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="adcfe790c3214b8902aa2d9bdbc7f166d3aa2497" translate="yes" xml:space="preserve">
          <source>Be sure that your yacc installation is in place including any necessary parser template files. If you have not already done so then be sure to:</source>
          <target state="translated">필요한 파서 템플릿 파일을 포함하여 yacc 설치가 적절한 지 확인하십시오. 아직 수행하지 않은 경우 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="7a2fea634f3d3c3b87d0ddfbb5348eeeda046aad" translate="yes" xml:space="preserve">
          <source>Be sure to adequately comment your code. While commenting every line is unnecessary, anything that takes advantage of side effects of operators, that creates changes that will be felt outside of the function being patched, or that others may find confusing should be documented. If you are going to err, it is better to err on the side of adding too many comments than too few.</source>
          <target state="translated">코드를 적절히 주석 처리하십시오. 모든 라인에 주석을다는 것은 불필요하지만, 운영자의 부작용을 이용하거나 패치되는 기능 밖에서 느껴지거나 다른 사람들이 혼란 스러울 수있는 변경 사항을 작성하는 것은 문서화해야합니다. 실수를하려고한다면 너무 적은 수의 의견보다 너무 많은 의견을 추가하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="df103353e12184ad2bab2c528d00c711c155c484" translate="yes" xml:space="preserve">
          <source>Be sure to include the &lt;b&gt;exact&lt;/b&gt; error messages, if any. &quot;Perl gave an error&quot; is not an exact error message.</source>
          <target state="translated">&lt;b&gt;정확한&lt;/b&gt; 오류 메시지가 있으면 반드시 포함 시키 십시오. &quot;Perl has a error&quot;는 정확한 오류 메시지가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="b5cbd612657dfbf7a92d6606e16853c43b77addf" translate="yes" xml:space="preserve">
          <source>Be sure to read &lt;a href=&quot;#ENCODING&quot;&gt;ENCODING&lt;/a&gt; if your Pod contains non-ASCII characters.</source>
          <target state="translated">포드에 ASCII가 아닌 문자가 포함되어 있으면 &lt;a href=&quot;#ENCODING&quot;&gt;인코딩&lt;/a&gt; 을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="2984603dd54138b13d352a1e3fd61b6408be6b9f" translate="yes" xml:space="preserve">
          <source>Be sure to read the instructions near the top of the makefiles carefully.</source>
          <target state="translated">메이크 파일 상단 근처의 지침을주의 깊게 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="7f00ff2068b10342c9156aa44f6e62fb9656c3bb" translate="yes" xml:space="preserve">
          <source>Be sure to specify Perl version requirements both in Makefile.PL or Build.PL and with &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 5.6.1&lt;/code&gt; or similar. See the section on &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; of &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; for details.</source>
          <target state="translated">Makefile.PL 또는 Build.PL 모두에 Perl 버전 요구 사항을 지정 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 5.6.1&lt;/code&gt; 이상 이 필요합니다 . 자세한 내용 은 &lt;a href=&quot;functions/require&quot;&gt;require의 &lt;/a&gt; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 섹션을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="c733e8a30868a3838b1dfa41af03cf511ee097ca" translate="yes" xml:space="preserve">
          <source>Be sure to use a tar program compiled under Solaris (not SunOS 4.x) to extract the perl-5.x.x.tar.gz file. Do not use GNU tar compiled for SunOS4 on Solaris. (GNU tar compiled for Solaris should be fine.) When you run SunOS4 binaries on Solaris, the run-time system magically alters pathnames matching m#lib/locale# so that when tar tries to create lib/locale.pm, a file named lib/oldlocale.pm gets created instead. If you found this advice too late and used a SunOS4-compiled tar anyway, you must find the incorrectly renamed file and move it back to lib/locale.pm.</source>
          <target state="translated">perl-5.xxtar.gz 파일을 추출하려면 Solaris (SunOS 4.x 아님)에서 컴파일 된 tar 프로그램을 사용해야합니다. Solaris에서 SunOS4 용으로 컴파일 된 GNU tar를 사용하지 마십시오. (Solaris 용으로 컴파일 된 GNU tar는 괜찮습니다.) Solaris에서 SunOS4 바이너리를 실행할 때 런타임 시스템은 tar가 lib / locale.pm이라는 파일을 만들려고 할 때 m # lib / locale #과 일치하는 경로 이름을 마술로 변경합니다. 대신 lib / oldlocale.pm이 생성됩니다. 이 조언이 너무 늦어서 SunOS4 컴파일 tar를 사용한 경우, 이름이 잘못 지정된 파일을 찾아서 lib / locale.pm으로 다시 이동해야합니다.</target>
        </trans-unit>
        <trans-unit id="5d818ab86968387d2a89aaa4ecb39ab429064672" translate="yes" xml:space="preserve">
          <source>Be sure to use the libraries and modules shipped with the version being tested, not those that were already installed.</source>
          <target state="translated">이미 설치된 버전이 아니라 테스트중인 버전과 함께 제공된 라이브러리 및 모듈을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="e3d356b4e65052f33c752664cb97b29222d4870b" translate="yes" xml:space="preserve">
          <source>Be very careful with Perl operations that change the value of the variable. Appending something to the variable, for instance, might require reallocation of its storage, leaving you with a pointer into no-man's land.</source>
          <target state="translated">변수 값을 변경하는 Perl 조작에 매우주의하십시오. 예를 들어, 변수에 무언가를 추가하려면 스토리지를 재 할당해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9df705eca9ff235f56efac76a8ae2aff600e09f" translate="yes" xml:space="preserve">
          <source>Be warned that neither creation nor deletion of files is guaranteed to be an atomic operation over NFS. That is, two processes might both successfully create or unlink the same file! Therefore O_EXCL isn't as exclusive as you might wish.</source>
          <target state="translated">파일을 만들거나 삭제하지 않아도 NFS를 통한 원자 작업이 보장되지는 않습니다. 즉, 두 프로세스가 동일한 파일을 성공적으로 만들거나 연결 해제 할 수 있습니다. 따라서 O_EXCL은 원하는만큼 배타적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7184ad30ab6a73d32aaec035835bc55ad15b3389" translate="yes" xml:space="preserve">
          <source>Be warned that some formatters cannot reliably render characters outside 32-126; and many are able to handle 32-126 and 160-255, but nothing above 255.</source>
          <target state="translated">일부 포매터는 32-126 외부의 문자를 안정적으로 렌더링 할 수 없습니다. 많은 사람들이 32-126과 160-255를 처리 할 수 ​​있지만 255보다 큰 것은 없습니다.</target>
        </trans-unit>
        <trans-unit id="8235118c9cdc1cd037bd4ff9c8b6234c4eceb334" translate="yes" xml:space="preserve">
          <source>Be warned that this feature is considered experimental, and may be changed without notice.</source>
          <target state="translated">이 기능은 실험적인 것으로 간주되며 예고없이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f60dd616afaa8860904852bce46c16c4c9385db0" translate="yes" xml:space="preserve">
          <source>Be warned, though, that unlike regular expressions, if the &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; template doesn't match the incoming data, Perl will scream and die.</source>
          <target state="translated">그러나 일반 표현식과 달리 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 템플릿이 들어오는 데이터와 일치하지 않으면 Perl은 소리를 지르고 죽을 것입니다.</target>
        </trans-unit>
        <trans-unit id="f34bea745032a10b52d62f12a9de185a88d00d76" translate="yes" xml:space="preserve">
          <source>Be warned: just as the C-preprocessor doesn't know C, the Debug filter doesn't know Perl. It can be fooled quite easily:</source>
          <target state="translated">C 전처리 기가 C를 알지 못하는 것처럼 디버그 필터는 Perl을 알지 못합니다. 꽤 쉽게 속일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29bff63d2a655090d41ce27755886c450bf1e989" translate="yes" xml:space="preserve">
          <source>BeOS is BeOS.</source>
          <target state="translated">BeOS는 BeOS입니다.</target>
        </trans-unit>
        <trans-unit id="7127634cd20ce1300143c5a508c993ef4fdbd8f4" translate="yes" xml:space="preserve">
          <source>Because &quot;perlio.h&quot; is a thin layer (for efficiency) the semantics of these functions are somewhat dependent on the underlying implementation. Where these variations are understood they are noted below.</source>
          <target state="translated">&quot;perlio.h&quot;는 효율성을 위해 얇은 층이기 때문에 이러한 기능의 의미는 기본 구현에 다소 의존합니다. 이러한 변형이 이해되는 경우 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b63ce495f650d704c02d64d23b111efdfe40cd61" translate="yes" xml:space="preserve">
          <source>Because &lt;b&gt;perldoc&lt;/b&gt; does not run properly tainted, and is known to have security issues, when run as the superuser it will attempt to drop privileges by setting the effective and real IDs to nobody's or nouser's account, or -2 if unavailable. If it cannot relinquish its privileges, it will not run.</source>
          <target state="translated">때문에 &lt;b&gt;perldoc을가&lt;/b&gt; 제대로 오염 실행되지 않습니다, 보안 문제가 알려져 수퍼 유저로 실행하면 아무도 나 nouser의 계정에 효과적이고 실제 ID를 설정하여 권한을 드롭을 시도, 또는 것입니다 -2 사용할 수없는 경우. 권한을 포기할 수 없으면 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="400d81a8582d02a7d364c167bb3655c111853cb4" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; trigger interpolation, you'll need to use something like &lt;code&gt;/\Quser\E\@\Qhost/&lt;/code&gt; to match them literally.</source>
          <target state="translated">&lt;code&gt;$&lt;/code&gt; 또는 &lt;code&gt;@&lt;/code&gt; 가 보간을 트리거 하기 때문에 문자 그대로 일치 시키 &lt;code&gt;/\Quser\E\@\Qhost/&lt;/code&gt; 와 같은 것을 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="b667c475fa92312c7083687d2886a12150dc73b8" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;$sv&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when the &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; operator is applied to it, the transliteration won't actually execute and the program won't &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. This is different to how 5.8 and earlier versions behaved since the capture variables were READONLY variables then; now they'll just die when assigned to in the default engine.</source>
          <target state="translated">때문에 &lt;code&gt;$sv&lt;/code&gt; 있다 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 때 &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; 연산자는 그것에인가된다 음역 실제로 실행되지 않으며, 프로그램되지 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; . 이는 캡처 변수가 READONLY 변수이므로 5.8 이전 버전의 동작과 다릅니다. 이제 기본 엔진에 할당되면 죽습니다.</target>
        </trans-unit>
        <trans-unit id="5addc5234910932f591ed79ef1118cfac8717e21" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when either operand is &lt;code&gt;NaN&lt;/code&gt; (not-a-number), be careful when sorting with a comparison function like &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; any lists that might contain a &lt;code&gt;NaN&lt;/code&gt; . The following example takes advantage that &lt;code&gt;NaN != NaN&lt;/code&gt; to eliminate any &lt;code&gt;NaN&lt;/code&gt; s from the input list.</source>
          <target state="translated">때문에 &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 반환 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 피연산자 일 때 &lt;code&gt;NaN&lt;/code&gt; 를 (숫자가 아닌 값)와 같은 비교 기능을 정렬 할 때,주의 &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; 포함 할 수있는 목록 &lt;code&gt;NaN&lt;/code&gt; 이를 . 다음 예는 활용 &lt;code&gt;NaN != NaN&lt;/code&gt; 어떠한 제거 &lt;code&gt;NaN&lt;/code&gt; 가 입력리스트로부터들.</target>
        </trans-unit>
        <trans-unit id="dbfd747a0cfe35cb8ad11b2926956f99d4f77a54" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when either operand is &lt;code&gt;NaN&lt;/code&gt; (not-a-number), be careful when sorting with a comparison function like &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; any lists that might contain a &lt;code&gt;NaN&lt;/code&gt; . The following example takes advantage that &lt;code&gt;NaN != NaN&lt;/code&gt; to eliminate any &lt;code&gt;NaN&lt;/code&gt; s from the input list.</source>
          <target state="translated">때문에 &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 반환 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 피연산자 일 때 &lt;code&gt;NaN&lt;/code&gt; 를 (숫자가 아닌 값)와 같은 비교 기능을 정렬 할 때,주의 &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; 포함 할 수있는 목록 &lt;code&gt;NaN&lt;/code&gt; 이를 . 다음 예는 활용 &lt;code&gt;NaN != NaN&lt;/code&gt; 어떠한 제거 &lt;code&gt;NaN&lt;/code&gt; 가 입력리스트로부터들.</target>
        </trans-unit>
        <trans-unit id="89d0f8e67a21f5d12b3d2f9f3bbfa73cf7cb9115" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;.&lt;/code&gt; is special in regular expressions, and can match any single character, the regex &lt;code&gt;P.&lt;/code&gt; here has matched the &amp;lt;Pl&amp;gt; in the original string.</source>
          <target state="translated">왜냐하면 &lt;code&gt;.&lt;/code&gt; 는 정규 표현식에서 특별하며 모든 단일 문자와 일치 할 수 있습니다 &lt;code&gt;P.&lt;/code&gt; 여기서 정규 표현식 P 는 원래 문자열의 &amp;lt;Pl&amp;gt;과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="19a20b9f3a218df5a7c84d8e40e3cdca6928cac3" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;.&lt;/code&gt; was in use as a directory separator and filenames could not be assumed to be unique after 10 characters, Acorn implemented the C compiler to strip the trailing &lt;code&gt;.c&lt;/code&gt;&lt;code&gt;.h&lt;/code&gt;&lt;code&gt;.s&lt;/code&gt; and &lt;code&gt;.o&lt;/code&gt; suffix from filenames specified in source code and store the respective files in subdirectories named after the suffix. Hence files are translated:</source>
          <target state="translated">왜냐하면 &lt;code&gt;.&lt;/code&gt; 디렉토리 구분자로 사용되었으며 파일 이름은 10 자 이후 고유 한 것으로 가정 할 수 없었습니다. Acorn은 C 컴파일러를 구현하여 소스 코드에 지정된 파일 이름에서 후행 &lt;code&gt;.c&lt;/code&gt; &lt;code&gt;.h&lt;/code&gt; &lt;code&gt;.s&lt;/code&gt; 및 &lt;code&gt;.o&lt;/code&gt; 접미사를 제거하고 각 파일을 저장합니다. 접미사 이름을 딴 하위 디렉토리에서. 따라서 파일이 번역됩니다.</target>
        </trans-unit>
        <trans-unit id="daf7ef166b9a7929b988f6a60b2c3afc2523b46d" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; is a run-time operator, it gets executed each time through a loop. Consequently, it's more efficient to localize your variables outside the loop.</source>
          <target state="translated">때문에 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 런타임 연산자이고, 이것은 루프를 매번 실행할 얻는다. 결과적으로 루프 외부에서 변수를 지역화하는 것이 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="2f69348654d069c347e7c5732088634fa13b4fd6" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; is a unary operator, if you accidentally use a parenthesized list for the EXPR, this behaves as a scalar comma expression, evaluating all but the last element in void context and returning the final element evaluated in scalar context. This is seldom what you want.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; 는 단항 연산자 이므로 실수로 EXPR에 괄호로 묶인 목록을 사용하는 경우 이는 스칼라 쉼표 표현식으로 작동하여 void 컨텍스트에서 마지막 요소를 제외한 모든 요소를 ​​평가하고 스칼라 컨텍스트에서 평가 된 최종 요소를 리턴합니다. 이것은 거의 당신이 원하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f2af4d959eb62b1a9bf83d9e5254d41aa11be74b" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; takes effect at compile time, it doesn't respect the ordinary flow control of the code being compiled. In particular, putting a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; inside the false branch of a conditional doesn't prevent it from being processed. If a module or pragma only needs to be loaded conditionally, this can be done using the &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; pragma:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 은 컴파일 타임에 적용 되므로 컴파일되는 코드의 일반적인 흐름 제어를 고려하지 않습니다. 특히, 조건부 거짓 분기 내부 에 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 한다고해서 처리되는 것을 막을 수는 없습니다. 모듈 또는 pragma를 조건부로만로드해야하는 &lt;a href=&quot;if&quot;&gt;경우 if&lt;/a&gt; pragma를 사용하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4bb9a434db491939507421e019d5c81a08c7de9d" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; is a unary operator, if you accidentally use a parenthesized list for the EXPR, this behaves as a scalar comma expression, evaluating all but the last element in void context and returning the final element evaluated in scalar context. This is seldom what you want.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; 는 단항 연산자 이므로 실수로 EXPR에 괄호로 묶인 목록을 사용하는 경우 이는 스칼라 쉼표 표현식으로 작동하여 void 컨텍스트에서 마지막 요소를 제외한 모든 요소를 ​​평가하고 스칼라 컨텍스트에서 평가 된 최종 요소를 리턴합니다. 이것은 거의 당신이 원하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c409d5f2e3bc5948e94957a82aeec5c28556f99d" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; takes effect at compile time, it doesn't respect the ordinary flow control of the code being compiled. In particular, putting a &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; inside the false branch of a conditional doesn't prevent it from being processed. If a module or pragma only needs to be loaded conditionally, this can be done using the &lt;a href=&quot;../if&quot;&gt;if&lt;/a&gt; pragma:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 은 컴파일 타임에 적용 되므로 컴파일되는 코드의 일반적인 흐름 제어를 고려하지 않습니다. 특히, 조건부 거짓 분기 내부 에 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 한다고해서 처리되는 것을 막을 수는 없습니다. 모듈 또는 pragma를 조건부로만로드해야하는 &lt;a href=&quot;../if&quot;&gt;경우 if&lt;/a&gt; pragma를 사용하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f7ea34c50bf47a71dd29a5e22af22a7376e9666b" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;DESTROY&lt;/code&gt; methods can be called at any time, you should localize any global variables you might update in your &lt;code&gt;DESTROY&lt;/code&gt; . In particular, if you use &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; you should localize &lt;code&gt;$@&lt;/code&gt; , and if you use &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; or backticks you should localize &lt;code&gt;$?&lt;/code&gt; .</source>
          <target state="translated">때문에 &lt;code&gt;DESTROY&lt;/code&gt; 방법은 언제든지 호출 할 수 있습니다, 당신은 당신이 당신에 업데이트 할 수있는 전역 변수 지역화해야 &lt;code&gt;DESTROY&lt;/code&gt; 를 . 특히, &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; 을 사용하는 경우 &lt;code&gt;$@&lt;/code&gt; 현지화해야 하고 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 또는 백틱을 사용하는 경우 &lt;code&gt;$?&lt;/code&gt; 를 현지화해야 합니까? .</target>
        </trans-unit>
        <trans-unit id="1b1a7e8c9b3926d0057e1f91a59eec1bca6ac0fe" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;PERL5LIB&lt;/code&gt; is often used during testing to add build directories to &lt;code&gt;@INC&lt;/code&gt; prove passes the names of any directories found in &lt;code&gt;PERL5LIB&lt;/code&gt; as -I switches. The net effect of this is that &lt;code&gt;PERL5LIB&lt;/code&gt; is honoured even when prove is run in taint mode.</source>
          <target state="translated">테스트 중에 &lt;code&gt;@INC&lt;/code&gt; 에 빌드 디렉토리를 추가하기 위해 &lt;code&gt;PERL5LIB&lt;/code&gt; 가 자주 사용 되므로 prove는 &lt;code&gt;PERL5LIB&lt;/code&gt; 에있는 디렉토리 이름을 -I 스위치로 전달합니다. 이것의 최종 효과는 증명이 오염 모드에서 실행될 때에도 &lt;code&gt;PERL5LIB&lt;/code&gt; 가 적용된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8d8b86b2aa791fa81fa4a800514b6911cd4cea09" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;PERL5LIB&lt;/code&gt; is often used during testing to add build directories to &lt;code&gt;@INC&lt;/code&gt;&lt;code&gt;Test::Harness&lt;/code&gt; passes the names of any directories found in &lt;code&gt;PERL5LIB&lt;/code&gt; as -I switches. The net effect of this is that &lt;code&gt;PERL5LIB&lt;/code&gt; is honoured even in taint mode.</source>
          <target state="translated">때문에 &lt;code&gt;PERL5LIB&lt;/code&gt; 가 종종 빌드 디렉토리를 추가하기 위해 테스트 중에 사용됩니다 &lt;code&gt;@INC&lt;/code&gt; &lt;code&gt;Test::Harness&lt;/code&gt; 어떤 디렉토리의 이름에서 발견 통과 &lt;code&gt;PERL5LIB&lt;/code&gt; -I 스위치로. 이것의 최종 효과는 &lt;code&gt;PERL5LIB&lt;/code&gt; 가 오염 모드에서도 인정 된다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="528ed40a74786c9daeb579970bad493df64c4a75" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;PL_restartop&lt;/code&gt; is non-null, &lt;code&gt;run_body&lt;/code&gt; starts a new runops loop and execution continues.</source>
          <target state="translated">때문에 &lt;code&gt;PL_restartop&lt;/code&gt; 가 비 - 널이, &lt;code&gt;run_body&lt;/code&gt; 는 새로운 runops 루프를 개시 및 실행을 계속한다.</target>
        </trans-unit>
        <trans-unit id="add12825d3665c5532bcf2a78d2469e31a8a7e9f" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;STORABLE_attach&lt;/code&gt; is passed the class (rather than an object), it also returns the object directly, rather than modifying the passed object.</source>
          <target state="translated">때문에 &lt;code&gt;STORABLE_attach&lt;/code&gt; 이 클래스 (아닌 객체)를 전달, 그것은 또한 오히려 전달 된 객체를 수정하는 것보다 직접 개체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="308ec40cfa786d712d62a1e76733c4c3028b3e68" translate="yes" xml:space="preserve">
          <source>Because Acorns use ASCII with newlines (&lt;code&gt;\n&lt;/code&gt; ) in text files as &lt;code&gt;\012&lt;/code&gt; like Unix, and because Unix filename emulation is turned on by default, most simple scripts will probably work &quot;out of the box&quot;. The native filesystem is modular, and individual filesystems are free to be case-sensitive or insensitive, and are usually case-preserving. Some native filesystems have name length limits, which file and directory names are silently truncated to fit. Scripts should be aware that the standard filesystem currently has a name length limit of &lt;b&gt;10&lt;/b&gt; characters, with up to 77 items in a directory, but other filesystems may not impose such limitations.</source>
          <target state="translated">Acorns 는 텍스트 파일에서 Unix와 같은 &lt;code&gt;\012&lt;/code&gt; 로 줄 바꿈 ( &lt;code&gt;\n&lt;/code&gt; )을 사용하여 ASCII를 사용 하고 Unix 파일 이름 에뮬레이션은 기본적으로 켜져 있기 때문에 대부분의 간단한 스크립트는 &quot;바로&quot;작동합니다. 기본 파일 시스템은 모듈 식이며 개별 파일 시스템은 대소 문자를 구분하거나 구분하지 않고 일반적으로 대소 문자를 유지합니다. 일부 기본 파일 시스템에는 이름 길이 제한이 있으며 파일 및 디렉토리 이름이 자동으로 잘립니다. 스크립트는 표준 파일 시스템의 이름 길이가 &lt;b&gt;10&lt;/b&gt; 자로 제한 되며 디렉토리에 최대 77 개의 항목이 있지만 다른 파일 시스템은 이러한 제한을 적용하지 않을 수 있습니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="828cb90cec8613e5d83ab546b1c59479cecb4072" translate="yes" xml:space="preserve">
          <source>Because C has no builtin function for integer exponentiation, let's make Perl's ** operator available to it (this is less useful than it sounds, because Perl implements ** with C's</source>
          <target state="translated">C에는 정수 지수 함수가 내장되어 있지 않기 때문에 Perl의 ** 연산자를 사용할 수있게하겠습니다 (Perl은 C로 **를 구현하기 때문에 소리보다 유용하지 않습니다)</target>
        </trans-unit>
        <trans-unit id="9459aa14a3cec514837284733b6c7f9c5dcb8910" translate="yes" xml:space="preserve">
          <source>Because Perl allows you to use barewords for package names and subroutine names, it sometimes interprets a bareword's meaning incorrectly. For example, the construct &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; can be interpreted as either &lt;code&gt;'Class'-&amp;gt;new()&lt;/code&gt; or &lt;code&gt;Class()-&amp;gt;new()&lt;/code&gt; . In English, that second interpretation reads as &quot;call a subroutine named Class(), then call new() as a method on the return value of Class()&quot;. If there is a subroutine named &lt;code&gt;Class()&lt;/code&gt; in the current namespace, Perl will always interpret &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; as the second alternative: a call to &lt;code&gt;new()&lt;/code&gt; on the object returned by a call to &lt;code&gt;Class()&lt;/code&gt;</source>
          <target state="translated">Perl에서는 패키지 이름과 서브 루틴 이름에 베어 워드를 사용할 수 있으므로 베어 워드의 의미를 잘못 해석하는 경우가 있습니다. 예를 들어, &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; 구문 은 &lt;code&gt;'Class'-&amp;gt;new()&lt;/code&gt; 또는 &lt;code&gt;Class()-&amp;gt;new()&lt;/code&gt; 로 해석 될 수 있습니다 . 영어에서이 두 번째 해석은 &quot;Class ()라는 서브 루틴을 호출 한 다음 Class ()의 리턴 값에 대한 메소드로 new ()를 호출합니다&quot;로 읽습니다. 현재 네임 스페이스에 &lt;code&gt;Class()&lt;/code&gt; 라는 서브 루틴이있는 경우 Perl은 항상 &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; 를 두 번째 대안으로 해석 합니다. &lt;code&gt;Class()&lt;/code&gt; 에 대한 호출에 의해 리턴 된 오브젝트 에서 &lt;code&gt;new()&lt;/code&gt; 에 대한 호출</target>
        </trans-unit>
        <trans-unit id="aadc88ee4df674055a8e46229f25dab587fc29ec" translate="yes" xml:space="preserve">
          <source>Because Perl stringifies uncaught exception messages before display, you'll probably want to overload stringification operations on exception objects. See &lt;a href=&quot;../overload&quot;&gt;overload&lt;/a&gt; for details about that.</source>
          <target state="translated">Perl은 표시하기 전에 포착되지 않은 예외 메시지를 문자열 화하기 때문에 예외 오브젝트에 대해 문자열 화 조작을 과부하 할 수 있습니다. 이에 대한 자세한 내용은 &lt;a href=&quot;../overload&quot;&gt;과부하&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e1c5024f83c23d4c6dafd0e63d9f2e92824de07b" translate="yes" xml:space="preserve">
          <source>Because Perl stringifies uncaught exception messages before display, you'll probably want to overload stringification operations on exception objects. See &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt; for details about that.</source>
          <target state="translated">Perl은 표시하기 전에 포착되지 않은 예외 메시지를 문자열 화하기 때문에 예외 오브젝트에 대해 문자열 화 조작을 과부하 할 수 있습니다. 이에 대한 자세한 내용은 &lt;a href=&quot;overload&quot;&gt;과부하&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2faaff7512cd20cbdff5d0e25efe8bfe139f7156" translate="yes" xml:space="preserve">
          <source>Because Perl uses doubles (or long doubles, if configured) internally for all numeric calculation, converting from double into float and thence to double again loses precision, so &lt;code&gt;unpack(&quot;f&quot;, pack(&quot;f&quot;, $foo)&lt;/code&gt;) will not in general equal $foo.</source>
          <target state="translated">Perl은 모든 숫자 계산에 내부적으로 double (또는 구성된 경우 long double)을 사용하므로 double에서 float로 변환 한 다음 다시 double로 변환하면 정밀도가 손실되므로 &lt;code&gt;unpack(&quot;f&quot;, pack(&quot;f&quot;, $foo)&lt;/code&gt; ) 일반적으로 $ foo와 같습니다.</target>
        </trans-unit>
        <trans-unit id="398f8b38f72125ad882bed6f196a0775e260d2ad" translate="yes" xml:space="preserve">
          <source>Because UTF-8 is one of Perl's internal formats, you can often just skip the encoding or decoding step, and manipulate the UTF8 flag directly.</source>
          <target state="translated">UTF-8은 Perl의 내부 형식 중 하나이므로 인코딩 또는 디코딩 단계를 건너 뛰고 UTF8 플래그를 직접 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6847617d71c84ec40d27c1365086ed8c20f1449c" translate="yes" xml:space="preserve">
          <source>Because UTF-EBCDIC is so similar to UTF-8, the differences are mostly hidden from you; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; (and NOT something like &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utfebcdic&lt;/code&gt; ) declares the the script is in the platform's &quot;native&quot; 8-bit encoding of Unicode. (Similarly for the &lt;code&gt;&quot;:utf8&quot;&lt;/code&gt; layer.)</source>
          <target state="translated">UTF-EBCDIC는 UTF-8과 매우 유사하기 때문에 차이점은 대부분 숨겨져 있습니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utfebcdic&lt;/code&gt; 과 같은 것은 아님 )은 스크립트가 플랫폼의 &quot;기본&quot;8 비트 인코딩 유니 코드로되어 있음을 선언합니다. &lt;code&gt;&quot;:utf8&quot;&lt;/code&gt; 레이어와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="237849b1b007b545cf9244e10de8226da0ca3773" translate="yes" xml:space="preserve">
          <source>Because VMS's exit codes are much, much different than the rest of the universe, and perl does horrible mangling to them that gets in my way, it works like this on VMS.</source>
          <target state="translated">VMS의 종료 코드는 다른 우주와 훨씬 다르고 펄은 내 방식대로 끔찍한 맹 글링을 수행하므로 VMS에서 이와 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="815d9b38e08d4ff6dad9bd30fba64b1ec6e8aeb8" translate="yes" xml:space="preserve">
          <source>Because XS modules require re-linking of the perl binary, you need both the perl binary distribution and the perl source distribution to build an XS extension module. In addition, you will have to have built your perl binary from the source distribution so that all of the components of the perl binary are available for the required link step.</source>
          <target state="translated">XS 모듈은 perl 바이너리를 다시 연결해야하므로 XS 확장 모듈을 빌드하려면 perl 바이너리 배포판과 perl 소스 배포판이 모두 필요합니다. 또한 소스 분배에서 perl 바이너리를 빌드해야 perl 바이너리의 모든 구성 요소가 필요한 링크 단계에 사용 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="b57c6e3153bc9c89950406d1bdb5e4a01632a292" translate="yes" xml:space="preserve">
          <source>Because a failed &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; match doesn't reset the offset, the return from &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; won't change either in this case. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; and &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">실패한 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; 일치는 오프셋을 재설정하지 않으므로이 경우 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 의 반환 값은 변경되지 않습니다. &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; 및 &lt;a href=&quot;perlop&quot;&gt;perlop을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="aac46af0a65c30c1278fb04116da06849260131d" translate="yes" xml:space="preserve">
          <source>Because a failed &lt;code&gt;&lt;a href=&quot;m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; match doesn't reset the offset, the return from &lt;code&gt;&lt;a href=&quot;pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; won't change either in this case. See &lt;a href=&quot;../perlre&quot;&gt;perlre&lt;/a&gt; and &lt;a href=&quot;../perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">실패한 &lt;code&gt;&lt;a href=&quot;m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; 일치는 오프셋을 재설정하지 않으므로이 경우 &lt;code&gt;&lt;a href=&quot;pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 의 반환 값은 변경되지 않습니다. &lt;a href=&quot;../perlre&quot;&gt;perlre&lt;/a&gt; 및 &lt;a href=&quot;../perlop&quot;&gt;perlop을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9eb2a05168485f04f9e352bc656013c7106c3b67" translate="yes" xml:space="preserve">
          <source>Because a list of potential candidates is returned, the &lt;code&gt;while&lt;/code&gt; loop tries each in turn until it finds one that succeeds both the socket() and connect() calls.</source>
          <target state="translated">잠재적 후보 목록이 리턴되므로 &lt;code&gt;while&lt;/code&gt; 루프는 socket () 및 connect () 호출 모두에 성공 하는 후보를 찾을 때까지 차례로 시도합니다.</target>
        </trans-unit>
        <trans-unit id="93bb95979fc3bb902bf7566626913de80d560dcc" translate="yes" xml:space="preserve">
          <source>Because a name correction may be added in future Unicode releases, the name that &lt;code&gt;viacode&lt;/code&gt; returns may change as a result. This is a rare event, but it does happen.</source>
          <target state="translated">향후 유니 코드 릴리스에서는 이름 수정이 추가 될 수 있으므로 &lt;code&gt;viacode&lt;/code&gt; 가 반환 하는 이름 은 결과적으로 변경 될 수 있습니다. 이것은 드문 일이지만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="284e0db6a72cf3c4c7c4890513562109eb2a9995" translate="yes" xml:space="preserve">
          <source>Because a period is a metacharacter, it needs to be escaped to match as an ordinary period. Because, for example, &lt;code&gt;\d&lt;/code&gt; and &lt;code&gt;\w&lt;/code&gt; are sets of characters, it is incorrect to think of &lt;code&gt;[^\d\w]&lt;/code&gt; as &lt;code&gt;[\D\W]&lt;/code&gt; ; in fact &lt;code&gt;[^\d\w]&lt;/code&gt; is the same as &lt;code&gt;[^\w]&lt;/code&gt;, which is the same as &lt;code&gt;[\W]&lt;/code&gt; . Think DeMorgan's laws.</source>
          <target state="translated">마침표는 메타 문자이므로 일반 마침표와 일치하도록 이스케이프 처리해야합니다. 예를 들어, &lt;code&gt;\d&lt;/code&gt; 및 &lt;code&gt;\w&lt;/code&gt; 는 문자 세트이므로 &lt;code&gt;[^\d\w]&lt;/code&gt; 를 &lt;code&gt;[\D\W]&lt;/code&gt; 로 생각하는 것은 올바르지 않습니다 . 실제로 &lt;code&gt;[^\d\w]&lt;/code&gt; 는 &lt;code&gt;[^\w]&lt;/code&gt; 와 동일하며 &lt;code&gt;[\W]&lt;/code&gt; 와 동일 합니다. DeMorgan의 법칙을 생각하십시오.</target>
        </trans-unit>
        <trans-unit id="934c60da6f18a9def8d944b8bcb6ee8755c35fe6" translate="yes" xml:space="preserve">
          <source>Because access() does not invoke stat() (at least not in a way visible to Perl), &lt;b&gt;the stat result cache &quot;_&quot; is not set&lt;/b&gt;. This means that the outcome of the following two tests is different. The first has the stat bits of</source>
          <target state="translated">access ()가 stat ()를 호출하지 않기 때문에 (적어도 Perl에 보이지 않는 방식으로) &lt;b&gt;통계 결과 캐시 &quot;_&quot;는 설정되지 않습니다&lt;/b&gt; . 이것은 다음 두 테스트의 결과가 다르다는 것을 의미합니다. 첫 번째는 스탯 비트가</target>
        </trans-unit>
        <trans-unit id="390a39256a176624bc85b17cecc4ce28e0fc7e67" translate="yes" xml:space="preserve">
          <source>Because assignment of a reference to a typeglob creates an alias, this can be used to create what is effectively a local function, or at least, a local alias.</source>
          <target state="translated">typeglob에 대한 참조를 할당하면 별칭이 만들어 지므로 로컬 함수 또는 적어도 로컬 별칭을 효과적으로 만드는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fe40d9c5df21e57c6ec455bae627177153c51cf" translate="yes" xml:space="preserve">
          <source>Because backticks do not affect standard error, use shell file descriptor syntax (assuming the shell supports this) if you care to address this. To capture a command's STDERR and STDOUT together:</source>
          <target state="translated">백틱은 표준 오류에 영향을 미치지 않으므로이 문제를 해결하려면 셸 파일 설명자 구문 (쉘이이를 지원한다고 가정)을 사용하십시오. 명령의 STDERR 및 STDOUT을 함께 캡처하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="58a3a4b137a2ac3042f5ce6d5ed31ccf52919b18" translate="yes" xml:space="preserve">
          <source>Because both CRLF and LF end in LF, the input record separator can be set to LF and any CR stripped later. Better to write:</source>
          <target state="translated">CRLF와 LF가 모두 LF로 끝나기 때문에 입력 레코드 구분 기호를 LF로 설정하고 나중에 CR을 제거 할 수 있습니다. 작성하는 것이 좋습니다 :</target>
        </trans-unit>
        <trans-unit id="a49e08801e09e4ade1a0feed4948dfc00925efc8" translate="yes" xml:space="preserve">
          <source>Because curly brackets (braces) are used for several other things including BLOCKs, you may occasionally have to disambiguate braces at the beginning of a statement by putting a &lt;code&gt;+&lt;/code&gt; or a &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; in front so that Perl realizes the opening brace isn't starting a BLOCK. The economy and mnemonic value of using curlies is deemed worth this occasional extra hassle.</source>
          <target state="translated">중괄호 (중괄호)는 BLOCK을 포함하여 여러 가지 다른 용도로 사용되기 때문에 펄이 여는 중괄호가 BLOCK을 시작하지 않음을 인식하기 위해 명령문 시작시 &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 을 앞에 놓아 중괄호를 명확하게해야 할 수도 있습니다. . curlies를 사용하는 경제성과 니모닉 가치는 이따금의 번거 로움으로 여겨집니다.</target>
        </trans-unit>
        <trans-unit id="b7b830bba46d3c56bd91aa88ed2e25a2ca316287" translate="yes" xml:space="preserve">
          <source>Because depending on a directory to just ensure it exists doesn't work too well (the modified time changes too often) dir_target() creates a .exists file in the created directory. It is this you should depend on. For portability purposes you should use the $(DIRFILESEP) macro rather than a '/' to separate the directory from the file.</source>
          <target state="translated">존재하는지 확인하기 위해 디렉토리에 따라 너무 잘 작동하지 않기 때문에 (수정 된 시간이 너무 자주 변경됨) dir_target ()은 작성된 디렉토리에 .exists 파일을 작성합니다. 이것이 당신이 의존 해야하는 것입니다. 이식성을 위해 파일과 디렉토리를 구분하려면 '/'대신 $ (DIRFILESEP) 매크로를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="e43a24b825ab27b01432c41cd607e2f4d3328c51" translate="yes" xml:space="preserve">
          <source>Because each operand is evaluated in integer form, &lt;code&gt;2.18 .. 3.14&lt;/code&gt; will return two elements in list context.</source>
          <target state="translated">각 피연산자는 정수 형식으로 평가되므로 &lt;code&gt;2.18 .. 3.14&lt;/code&gt; 는 목록 컨텍스트에서 두 개의 요소를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d594331311925ecf9da3e16eb2cdc66b10c06327" translate="yes" xml:space="preserve">
          <source>Because even on non-Unix ports, Perl's glob function follows standard Unix globbing semantics. You'll need &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob(&quot;*&quot;)&lt;/a&gt;&lt;/code&gt; to get all (non-hidden) files. This makes glob() portable even to legacy systems. Your port may include proprietary globbing functions as well. Check its documentation for details.</source>
          <target state="translated">비 유닉스 포트에서도 Perl의 glob 기능은 표준 Unix globbing 의미를 따릅니다. 숨겨지지 않은 모든 파일을 가져 오려면 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob(&quot;*&quot;)&lt;/a&gt;&lt;/code&gt; 가 필요 합니다. 따라서 구형 시스템에서도 glob ()를 이식 할 수 있습니다. 포트에는 독점적 인 글 로빙 기능도 포함되어 있습니다. 자세한 내용은 설명서를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="2981f551145cc9ed169b464d8c0a095e7cf58a72" translate="yes" xml:space="preserve">
          <source>Because historically some operating systems silently chopped off kernel interpretation of the &lt;code&gt;#!&lt;/code&gt; line after 32 characters, some switches may be passed in on the command line, and some may not; you could even get a &quot;-&quot; without its letter, if you're not careful. You probably want to make sure that all your switches fall either before or after that 32-character boundary. Most switches don't actually care if they're processed redundantly, but getting a &quot;-&quot; instead of a complete switch could cause Perl to try to execute standard input instead of your program. And a partial &lt;b&gt;-I&lt;/b&gt; switch could also cause odd results.</source>
          <target state="translated">역사적으로 일부 운영 체제는 &lt;code&gt;#!&lt;/code&gt; 커널 해석을 자동으로 차단했기 때문에 ! 32 자 뒤의 행에서 일부 스위치는 명령 행에 전달 될 수 있지만 일부는 그렇지 않을 수 있습니다. 조심하지 않으면 문자없이 &quot;-&quot;를받을 수도 있습니다. 모든 스위치가 해당 32 자 경계 앞뒤에 있는지 확인하고 싶을 것입니다. 대부분의 스위치는 실제로 중복으로 처리되는지 신경 쓰지 않지만 완전한 스위치 대신 &quot;-&quot;를 얻으면 Perl이 프로그램 대신 표준 입력을 실행하려고 할 수 있습니다. 부분 &lt;b&gt;I&lt;/b&gt; 스위치도 이상한 결과를 초래할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e93d867e0e61a9f65c5551095616b09fa36af42" translate="yes" xml:space="preserve">
          <source>Because if _1 is one, you get &quot;1 document &lt;b&gt;were&lt;/b&gt; matched&quot;. An acceptable hack here is to do something like this:</source>
          <target state="translated">_1이 1이면 &quot;1 개의 문서 &lt;b&gt;가&lt;/b&gt; 일치했습니다&quot; 가 표시되기 때문 입니다. 여기서 허용되는 해킹은 다음과 같은 작업을 수행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="14e83724617636cdff52bc89c9135eb24a32b2c3" translate="yes" xml:space="preserve">
          <source>Because it is not possible to reliably tell UTF-8 from native 8 bit encodings, you need either a Byte Order Mark at the beginning of your source code, or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8;&lt;/code&gt; , to instruct perl.</source>
          <target state="translated">원시 8 비트 인코딩에서 UTF-8을 확실하게 말할 수 없으므로 소스 코드 시작 부분에 바이트 순서 표시가 필요하거나 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8;&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용해야합니다&lt;/a&gt; . 펄에게 지시합니다.</target>
        </trans-unit>
        <trans-unit id="8c9a76f6de0976ec0aec1cbf80b933b451074248" translate="yes" xml:space="preserve">
          <source>Because it's a module, not an integral part of the interpreter, NEXT.pm has to guess where the surrounding call was found in the method look-up sequence. In the presence of diamond inheritance patterns it occasionally guesses wrong.</source>
          <target state="translated">NEXT.pm은 인터프리터의 필수적인 부분이 아닌 모듈이기 때문에 메소드 조회 시퀀스에서 주변 호출이 어디서 발견되었는지 추측해야합니다. 다이아몬드 상속 패턴이있는 경우 때때로 잘못 추측합니다.</target>
        </trans-unit>
        <trans-unit id="1b07afd521e75a07298e5e250bb27a3b27578dea" translate="yes" xml:space="preserve">
          <source>Because loading in the &lt;code&gt;IO::Handle&lt;/code&gt; class is an expensive operation, you should learn how to use the regular built-in variables.</source>
          <target state="translated">&lt;code&gt;IO::Handle&lt;/code&gt; 클래스에 로드 하는 작업은 비용이 많이 드는 작업이므로 일반 내장 변수를 사용하는 방법을 배워야합니다.</target>
        </trans-unit>
        <trans-unit id="fb1b328dbd0a94624aa3c89dafc392fc30581afd" translate="yes" xml:space="preserve">
          <source>Because many operating systems permit anyone with read access to the Perl program file to make a copy of it, patch the copy, and then execute the copy, the security-conscious Perl programmer should take care to invoke the installed copy of perl, not the copy referenced by &lt;code&gt;$^X&lt;/code&gt; . The following statements accomplish this goal, and produce a pathname that can be invoked as a command or referenced as a file.</source>
          <target state="translated">많은 운영 체제에서 Perl 프로그램 파일에 대한 읽기 액세스 권한이있는 사용자는 누구나 사본을 작성하고 사본을 패치 한 다음 사본을 실행할 수 있으므로 보안을 고려한 Perl 프로그래머는 설치된 Perl 사본이 아닌 Perl의 사본을 호출해야합니다. &lt;code&gt;$^X&lt;/code&gt; 의해 참조되는 사본 . 다음 명령문은이 목표를 달성하고 명령으로 호출하거나 파일로 참조 할 수있는 경로 이름을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="9fda5ef27e15d5bae07e31ec0802921ed805374c" translate="yes" xml:space="preserve">
          <source>Because native operating system filehandles are global and are currently allocated down from 255, with 0 being a reserved value, the Unix emulation library emulates Unix filehandles. Consequently, you can't rely on passing &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; , or &lt;code&gt;STDERR&lt;/code&gt; to your children.</source>
          <target state="translated">기본 운영 체제 파일 핸들은 전역 적이며 현재 255에서 할당되어 0이 예약 된 값이므로 Unix 에뮬레이션 라이브러리는 Unix 파일 핸들을 에뮬레이트합니다. 따라서 &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; 또는 &lt;code&gt;STDERR&lt;/code&gt; 을 자녀에게 전달할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="f5e62ec9329120e24ef0d8c20f22f5389de7c7e2" translate="yes" xml:space="preserve">
          <source>Because objects in Perl are implemented as references, it's possible to have circular references with objects as well. Imagine a TreeNode class where each node references its parent and child nodes. Any node with a parent will be part of a circular reference.</source>
          <target state="translated">Perl의 객체는 참조로 구현되므로 객체와 함께 순환 참조를 가질 수도 있습니다. 각 노드가 부모 및 자식 노드를 참조하는 TreeNode 클래스를 상상해보십시오. 부모가있는 모든 노드는 순환 참조의 일부가됩니다.</target>
        </trans-unit>
        <trans-unit id="0bd5958f518c949c2219a905e834fb00df87ae4a" translate="yes" xml:space="preserve">
          <source>Because of DST changes, there are many time zones where the same local time occurs for two different GMT times on the same day. For example, in the &quot;Europe/Paris&quot; time zone, the local time of 2001-10-28 02:30:00 can represent either 2001-10-28 00:30:00 GMT, &lt;b&gt;or&lt;/b&gt; 2001-10-28 01:30:00 GMT.</source>
          <target state="translated">DST 변경으로 인해 같은 날 두 개의 다른 GMT 시간에 대해 동일한 현지 시간이 발생하는 시간대가 많이 있습니다. 예를 들어 &quot;유럽 / 파리&quot;시간대에서 2001-10-28 02:30:00의 현지 시간은 2001-10-28 00:30:00 GMT &lt;b&gt;또는&lt;/b&gt; 2001-10-28 01을 나타낼 수 있습니다 . 30:00 그리니치 표준시.</target>
        </trans-unit>
        <trans-unit id="65864a7a85dc93ea309cdec582c118e5dd979f14" translate="yes" xml:space="preserve">
          <source>Because of a bug in perl (#19213), at least in version 5.6.1, we have to hardcode the path separator for a require on Win32 to be &lt;code&gt;/&lt;/code&gt;, like on Unix rather than the Win32 &lt;code&gt;\&lt;/code&gt; . Otherwise perl will not read its own %INC accurately double load files if they are required again, or in the worst case, core dump.</source>
          <target state="translated">적어도 5.6.1 버전에서는 perl (# 19213)의 버그로 인해 Win32 &lt;code&gt;\&lt;/code&gt; 대신 Unix에서와 같이 Win32에서 &lt;code&gt;/&lt;/code&gt; 가되도록 경로 구분 기호를 하드 코딩해야합니다 . 그렇지 않으면 perl은 다시 필요한 경우 또는 최악의 경우 코어 덤프 인 경우 자체 % INC의 이중로드 파일을 정확하게 읽지 못합니다.</target>
        </trans-unit>
        <trans-unit id="4f334a2266086aa81e3afdad8578b63a9a352bf3" translate="yes" xml:space="preserve">
          <source>Because of a lack of anything better, this module uses its own routines to pack and unpack ICMP packets. It would be better for a separate module to be written which understands all of the different kinds of ICMP packets.</source>
          <target state="translated">더 나은 것이 없기 때문에이 모듈은 자체 루틴을 사용하여 ICMP 패킷을 포장 및 포장 해제합니다. 다른 종류의 ICMP 패킷을 모두 이해하는 별도의 모듈을 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c50ff3946dd738899f690c4bd5e562356a6223d1" translate="yes" xml:space="preserve">
          <source>Because of all these problems, starting in v5.22, Perl will raise a warning if a multi-byte (hence Unicode) code point is used when a single-byte locale is in effect. (Although it doesn't check for this if doing so would unreasonably slow execution down.)</source>
          <target state="translated">v5.22부터 이러한 모든 문제로 인해 단일 바이트 로케일이 적용되는 멀티 바이트 (따라서 유니 코드) 코드 포인트가 사용되는 경우 Perl은 경고를 발생시킵니다. (그렇지 않으면 실행이 느리게 진행되는지 확인하지는 않지만)</target>
        </trans-unit>
        <trans-unit id="7eca024239d85bdb38cb09ea249ea5b41add05bc" translate="yes" xml:space="preserve">
          <source>Because of backward compatibility with legacy encodings, the &quot;a unique number for every character&quot; idea breaks down a bit: instead, there is &quot;at least one number for every character&quot;. The same character could be represented differently in several legacy encodings. The converse is not true: some code points do not have an assigned character. Firstly, there are unallocated code points within otherwise used blocks. Secondly, there are special Unicode control characters that do not represent true characters.</source>
          <target state="translated">레거시 인코딩과의 하위 호환성으로 인해 &quot;모든 문자에 고유 한 숫자&quot;라는 아이디어가 약간 세분화됩니다. 대신 &quot;모든 문자에 대해 하나 이상의 숫자&quot;가 있습니다. 동일한 문자는 여러 레거시 인코딩에서 다르게 표현 될 수 있습니다. 컨버스가 사실이 아닙니다. 일부 코드 포인트에는 할당 된 문자가 없습니다. 첫째, 달리 사용 된 블록 내에 할당되지 않은 코드 포인트가 있습니다. 둘째, 실제 문자를 나타내지 않는 특수 유니 코드 제어 문자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c5cc2c32fa019382bf3152d3598a8ccd6be4473" translate="yes" xml:space="preserve">
          <source>Because of being able to omit the curlies for the simple case of &lt;code&gt;$$x&lt;/code&gt; , people often make the mistake of viewing the dereferencing symbols as proper operators, and wonder about their precedence. If they were, though, you could use parentheses instead of braces. That's not the case. Consider the difference below; case 0 is a short-hand version of case 1,</source>
          <target state="translated">&lt;code&gt;$$x&lt;/code&gt; 의 간단한 경우에 대한 curlies를 생략 할 수 있기 때문에 사람들은 종종 역 참조 기호를 적절한 연산자로 보는 실수를 저지르고 우선 순위가 궁금합니다. 그래도 괄호 대신 괄호를 사용할 수 있습니다. 그렇지 않습니다. 아래 차이점을 고려하십시오. case 0은 case 1의 짧은 버전입니다.</target>
        </trans-unit>
        <trans-unit id="e900a4e123821bf1949cbdd4fb9b5da407117914" translate="yes" xml:space="preserve">
          <source>Because of clock granularity, expiration times may occur up to one second sooner than you expect. For example, suppose you store a value with a lifetime of ten seconds, and you store it at 12:00:00.998 on a certain day. Memoize will look at the clock and see 12:00:00. Then 9.01 seconds later, at 12:00:10.008 you try to read it back. Memoize will look at the clock and see 12:00:10 and conclude that the value has expired. This will probably not occur if you have &lt;code&gt;Time::HiRes&lt;/code&gt; installed.</source>
          <target state="translated">클럭 세분성으로 인해 만료 시간이 예상보다 빨리 1 초 정도 발생할 수 있습니다. 예를 들어, 수명이 10 초인 값을 저장하고 특정 날짜에 12 : 00 : 00.998에 저장한다고 가정하십시오. 메모는 시계를보고 12:00:00을 참조합니다. 그런 다음 9.01 초 후 12 : 00 : 10.008에 다시 읽으려고합니다. 메모는 시계를보고 12:00:10을 참조하여 값이 만료되었다고 결론을 내립니다. &lt;code&gt;Time::HiRes&lt;/code&gt; 설치되어 있으면 발생하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c6e7a0449744f95f7025dc0e8c4838b8d0860c99" translate="yes" xml:space="preserve">
          <source>Because of idiosyncrasies of OS/2 one cannot have all the eggs in the same basket (though EMX environment tries hard to overcome this limitations, so the situation may somehow improve). There are 4 executables for Perl provided by the distribution:</source>
          <target state="translated">OS / 2의 특성상 동일한 바구니에 모든 알을 가질 수는 없습니다 (EMX 환경이이 한계를 극복하기 위해 노력하지만 상황이 다소 개선 될 수 있습니다). 배포판에서 제공하는 Perl에 대한 4 개의 실행 파일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="38b54108e9558724b240349ad9589f54bf027fa2" translate="yes" xml:space="preserve">
          <source>Because of its global effect, this setting should not be used inside modules or the like.</source>
          <target state="translated">전체적인 효과 때문에이 설정은 모듈 등 내부에서 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="cc4be6e39aa524fd29878685a03b1168c2bf5d9f" translate="yes" xml:space="preserve">
          <source>Because of our problems with the native yacc we used GNU bison to generate a pure (=reentrant) parser for perly.y. So our yacc is really the following script:</source>
          <target state="translated">네이티브 yacc에 대한 문제 때문에 GNU bison을 사용하여 perly.y에 대한 순수한 (= reentrant) 파서를 생성했습니다. yacc는 실제로 다음과 같은 스크립트입니다.</target>
        </trans-unit>
        <trans-unit id="9835e5c9cd0a637bdd223f60f76a72232d5d4783" translate="yes" xml:space="preserve">
          <source>Because of the &quot;text&quot; mode translation, DOSish perls have limitations in using &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; on a file accessed in &quot;text&quot; mode. Stick to &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;-ing to locations you got from &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; (and no others), and you are usually free to use &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; even in &quot;text&quot; mode. Using &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; or other file operations may be non-portable. If you use &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; on a file, however, you can usually &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; with arbitrary values safely.</source>
          <target state="translated">&quot;텍스트&quot;모드 변환으로 인해 DOSish perls은 &quot;텍스트&quot;모드로 액세스 된 파일에 대해 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 사용에 제한이 있습니다. 스틱하는 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 이에서받은 위치에 -ing &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; (없이 다른 사람), 당신은 일반적으로 자유롭게 사용할 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 하고 &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 도 &quot;텍스트&quot;모드. &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 또는 다른 파일 작업을 사용 하는 것은 이식 불가능할 수 있습니다. 당신이 사용하는 경우 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 파일에, 그러나, 당신은 일반적으로 수 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 하고 &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 안전하게 임의의 값으로.</target>
        </trans-unit>
        <trans-unit id="86b041b8cdbf2e2a44b563d3f9086435ec867343" translate="yes" xml:space="preserve">
          <source>Because of the 16-bitness, UTF-16 is byte-order dependent. UTF-16 itself can be used for in-memory computations, but if storage or transfer is required either UTF-16BE (big-endian) or UTF-16LE (little-endian) encodings must be chosen.</source>
          <target state="translated">16 비트로 인해 UTF-16은 바이트 순서에 따라 다릅니다. UTF-16 자체는 메모리 내 계산에 사용될 수 있지만 저장 또는 전송이 필요한 경우 UTF-16BE (big-endian) 또는 UTF-16LE (little-endian) 인코딩을 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="ddcee3f7b2710d631ab7d25c7c6ccf7f643a3fe9" translate="yes" xml:space="preserve">
          <source>Because of the algorithm used, ISO-8859 series and other single-byte encodings do not work well unless either one of ISO-8859 is the only one suspect (besides ascii and utf8).</source>
          <target state="translated">사용 된 알고리즘으로 인해 ISO-8859 중 하나만 유일하게 용의자 (ascii 및 utf8 제외)가 아니면 ISO-8859 시리즈 및 기타 단일 바이트 인코딩이 제대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="11b9a9053f80eaf386518a04692ab13e4782146b" translate="yes" xml:space="preserve">
          <source>Because of the unexpected behaviors associated with this modifier, you probably should only use it to maintain weird backward compatibilities.</source>
          <target state="translated">이 수정 자와 관련된 예기치 않은 동작으로 인해 이전 버전과의 이상한 호환성을 유지하기 위해서만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="033d419ed47a31e5b1999d8b2e6265eaff662dc3" translate="yes" xml:space="preserve">
          <source>Because of their special use by sort(), the variables $a and $b are exempted from this check.</source>
          <target state="translated">sort ()에 의한 특수한 사용으로 인해 변수 $ a 및 $ b는이 검사에서 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="b4c8809b3046a08b3452bb5931521fe0616806ce" translate="yes" xml:space="preserve">
          <source>Because of this mechanism it is important that &lt;b&gt;AutoLoader&lt;/b&gt; is always &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;d and not &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;d.</source>
          <target state="translated">이 메커니즘으로 인해 &lt;b&gt;AutoLoader&lt;/b&gt; 는 항상 d를 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; d 는 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 하지 않은 것이 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="cf9b61922d31b09cb33aab7bed1a50c499c2933e" translate="yes" xml:space="preserve">
          <source>Because of those two, the code paging approach used use in ucm-based Encoding SOMETIMES fails so this module was written.</source>
          <target state="translated">이 두 가지 때문에 ucm 기반 인코딩 SOMETIMES에 사용 된 코드 페이징 접근법이 실패하여이 모듈이 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="4732978c8da8f3cf527ff9f22b157a0776b9721a" translate="yes" xml:space="preserve">
          <source>Because patterns are processed as double-quoted strings, the following also work:</source>
          <target state="translated">패턴은 큰 따옴표로 묶인 문자열로 처리되므로 다음도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e94cf9546dd5c84d3c599b01ef4e83754d69c340" translate="yes" xml:space="preserve">
          <source>Because perl needs to parse the script before applying this pragma, such encodings as Shift_JIS and Big-5 that may contain &lt;code&gt;'\'&lt;/code&gt; (BACKSLASH; &lt;code&gt;\x5c&lt;/code&gt; ) in the second byte fail because the second byte may accidentally escape the quoting character that follows.</source>
          <target state="translated">perl은이 pragma를 적용하기 전에 스크립트를 구문 분석해야 하므로 두 번째 바이트에 &lt;code&gt;'\'&lt;/code&gt; ( &lt;code&gt;\x5c&lt;/code&gt; ; \ x5c )를 포함 할 수있는 Shift_JIS 및 Big-5와 같은 인코딩 은 두 번째 바이트가 실수로 뒤에 오는 인용 문자를 이스케이프 할 수 있으므로 실패합니다.</target>
        </trans-unit>
        <trans-unit id="00d20d737f3e8559e674f183083581c5bd074a26" translate="yes" xml:space="preserve">
          <source>Because pointer size does not necessarily equal integer size, use the follow macros to do it right.</source>
          <target state="translated">포인터 크기가 정수 크기와 반드시 같을 필요는 없으므로 다음 매크로를 사용하여 올바르게 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="1ab7d92c18b253929d90277eb1a2787d5ea83ae7" translate="yes" xml:space="preserve">
          <source>Because scripts differ in their directionality (Hebrew and Arabic are written right to left, for example) Unicode supplies a &lt;code&gt;Bidi_Class&lt;/code&gt; property. Some of the values this property can have are:</source>
          <target state="translated">스크립트의 방향성이 다르기 때문에 (예 : 히브리어 및 아랍어는 오른쪽에서 왼쪽으로 작성 됨) 유니 코드는 &lt;code&gt;Bidi_Class&lt;/code&gt; 속성을 제공합니다. 이 속성이 가질 수있는 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5783acfed14f8a18cb2ce82232df112d8f4b39d0" translate="yes" xml:space="preserve">
          <source>Because taintedness is associated with each scalar value, some elements of an array or hash can be tainted and others not. The keys of a hash are &lt;b&gt;never&lt;/b&gt; tainted.</source>
          <target state="translated">오염은 각 스칼라 값과 연관되므로 배열 또는 해시의 일부 요소는 오염 될 수 있고 다른 요소는 오염되지 않을 수 있습니다. 해시의 키는 오염 &lt;b&gt;되지 않습니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="43efff829e58f5a1345657268ce9125ae02a8e64" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;&lt;a href=&quot;../functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt;ed value will have the separator reattached when it is written back to the file. There is no way to create a file whose trailing record separator string is missing.</source>
          <target state="translated">때문에 &lt;code&gt;&lt;a href=&quot;../functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt; ED 값이 파일에 다시 기록 될 때 재 부착 세퍼레이터를 가질 것이다. 후행 레코드 구분자 문자열이없는 파일을 작성할 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="1a39cf872a3f7b6aa066ba9c7802115aead55d6e" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; at end of file or upon error, you will sometimes see it used this way:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 함수는 파일 끝이나 오류시 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환 하기 때문에 때때로 다음과 같은 방식으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2d7cdbb67a74f8d2c9c047551149590e9752d672" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement implies a &lt;code&gt;BEGIN&lt;/code&gt; block, the importing of semantics happens as soon as the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement is compiled, before the rest of the file is compiled. This is how it is able to function as a pragma mechanism, and also how modules are able to declare subroutines that are then visible as list or unary operators for the rest of the current file. This will not work if you use &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;. With &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; you can get into this problem:</source>
          <target state="translated">때문에 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 문은이 의미하는 &lt;code&gt;BEGIN&lt;/code&gt; 블록을 곧만큼, 의미의 수입이 발생하는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 파일의 나머지 부분이 컴파일되기 전에 문이 컴파일됩니다. 이것이 pragma 메커니즘으로 기능 할 수있는 방법과 모듈이 서브 루틴을 선언하여 현재 파일의 나머지 부분에 대해 목록 또는 단항 연산자로 표시되는 방법입니다. 당신이 사용하는 경우이 작동하지 않습니다 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 대신에 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 와 함께이 문제에 들어갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af2ba8c1f36d75fd963bdb6706751e36d03bae43" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;here&lt;/code&gt; is before the &lt;code&gt;.*&lt;/code&gt; in the pattern, its position can be determined exactly. That's not true, however, for the &lt;code&gt;there&lt;/code&gt; ; it could appear at any point after where the anchored string appeared. Perl uses both for its optimisations, preferring the longer, or, if they are equal, the floating.</source>
          <target state="translated">&lt;code&gt;here&lt;/code&gt; 패턴 의 &lt;code&gt;.*&lt;/code&gt; 앞에 있기 때문에 위치를 정확하게 결정할 수 있습니다. 즉, 위해, 그러나, 사실이 아니에요 &lt;code&gt;there&lt;/code&gt; ; 고정 문자열이 나타난 후 어느 시점 에나 나타날 수 있습니다. Perl은 최적화를 위해 둘 다 사용하며, 더 길거나 (동일한 경우) 부동을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="77f9c95f62f2ca8f51dfcabf085dd8aa40d54fc6" translate="yes" xml:space="preserve">
          <source>Because the assignment copies the values, this also has the effect of turning call-by-reference into call-by-value. Otherwise a function is free to do in-place modifications of &lt;code&gt;@_&lt;/code&gt; and change its caller's values.</source>
          <target state="translated">할당은 값을 복사하기 때문에 참조 별 호출을 값별 호출로 전환하는 효과도 있습니다. 그렇지 않으면 함수의 현재 위치에서 수정을 자유롭게 &lt;code&gt;@_&lt;/code&gt; 및 호출자의 값을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="6c5cdf7c11299fa442df7b9179d8baed60991f7f" translate="yes" xml:space="preserve">
          <source>Because the conversion happens in place, the data to be converted cannot be a string constant: it must be a scalar variable.</source>
          <target state="translated">변환이 수행되기 때문에 변환 될 데이터는 문자열 상수 일 수 없습니다. 스칼라 변수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="9be0ebeeed384a0006842b7e5b00f870be61a55a" translate="yes" xml:space="preserve">
          <source>Because the current implementation uses the table and key sizes for the hashing algorithm, there is no means by which to dynamically change the value of any of the initialization parameters.</source>
          <target state="translated">현재 구현에서는 해싱 알고리즘에 테이블 및 키 크기를 사용하므로 초기화 매개 변수의 값을 동적으로 변경할 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="a16d069c72d0455b6bbcd09050d9c581b9a31d6b" translate="yes" xml:space="preserve">
          <source>Because the intent of this feature is primarily to let you define subroutines that work like built-in functions, here are prototypes for some other functions that parse almost exactly like the corresponding built-in.</source>
          <target state="translated">이 기능의 목적은 기본적으로 내장 함수처럼 작동하는 서브 루틴을 정의 할 수 있도록하기위한 것이므로 해당 내장 함수와 거의 동일하게 구문 분석하는 다른 함수의 프로토 타입이 있습니다.</target>
        </trans-unit>
        <trans-unit id="286b10724045d4807f7e79831cdfb01b70d2bd21" translate="yes" xml:space="preserve">
          <source>Because the internal format is often UTF-8, these bugs are hard to spot, because UTF-8 is usually the encoding you wanted! But don't be lazy, and don't use the fact that Perl's internal format is UTF-8 to your advantage. Encode explicitly to avoid weird bugs, and to show to maintenance programmers that you thought this through.</source>
          <target state="translated">내부 형식은 종종 UTF-8이므로 UTF-8은 일반적으로 원하는 인코딩이기 때문에 이러한 버그를 찾기가 어렵습니다! 그러나 게으르지 말고 Perl의 내부 형식이 UTF-8이라는 이점을 사용하지 마십시오. 이상한 버그를 피하고 유지 보수 프로그래머에게이를 생각한다고 명시 적으로 인코딩하십시오.</target>
        </trans-unit>
        <trans-unit id="2a9f9af112f672f597ba8d8590f5548d9330b12e" translate="yes" xml:space="preserve">
          <source>Because the mode contains both the file type and its permissions, you should mask off the file type portion and (s)printf using a &lt;code&gt;&quot;%o&quot;&lt;/code&gt; if you want to see the real permissions.</source>
          <target state="translated">모드에는 파일 형식과 사용 권한이 모두 포함되어 있으므로 실제 사용 권한을 보려면 파일 형식 부분과 &lt;code&gt;&quot;%o&quot;&lt;/code&gt; 사용하여 printf를 마스킹해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f2423ea47c406258a59791ed602061d34ce7d19b" translate="yes" xml:space="preserve">
          <source>Because the result of &lt;code&gt;&quot;\Q &lt;i&gt;STRING&lt;/i&gt; \E&quot;&lt;/code&gt; has all metacharacters quoted, there is no way to insert a literal &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; inside a &lt;code&gt;\Q\E&lt;/code&gt; pair. If protected by &lt;code&gt;\&lt;/code&gt; , &lt;code&gt;$&lt;/code&gt; will be quoted to become &lt;code&gt;&quot;\\\$&quot;&lt;/code&gt; ; if not, it is interpreted as the start of an interpolated scalar.</source>
          <target state="translated">&lt;code&gt;&quot;\Q &lt;i&gt;STRING&lt;/i&gt; \E&quot;&lt;/code&gt; 의 결과 에는 모든 메타 문자가 인용 되어 있으므로 &lt;code&gt;\Q\E&lt;/code&gt; 쌍 안에 리터럴 &lt;code&gt;$&lt;/code&gt; 또는 &lt;code&gt;@&lt;/code&gt; 를 삽입 할 방법이 없습니다 . 에 의해 보호되는 경우 &lt;code&gt;\&lt;/code&gt; , &lt;code&gt;$&lt;/code&gt; 가 되기 위해 인용 될 것 &lt;code&gt;&quot;\\\$&quot;&lt;/code&gt; ; 그렇지 않은 경우, 보간 된 스칼라의 시작으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="d152f048af7d90769fe2fc306e54559a9ec00ef1" translate="yes" xml:space="preserve">
          <source>Because the smartmatch operator recurses on nested arrays, this will still report that &quot;red&quot; is in the array.</source>
          <target state="translated">스마트 매치 연산자는 중첩 된 배열에서 반복되므로 &quot;red&quot;가 배열에 있다고보고합니다.</target>
        </trans-unit>
        <trans-unit id="2efc41902e93fe5cc4de4d763dfe32a371a96fe2" translate="yes" xml:space="preserve">
          <source>Because the standard failure message that &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; produces whenever a test fails will be a common occurrence in your test error output, and because it has changed between Test::Builder versions, rather than forcing you to call &lt;code&gt;test_err&lt;/code&gt; with the string all the time like so</source>
          <target state="translated">테스트가 실패 할 때마다 &lt;a href=&quot;../builder&quot;&gt;Test :: Builder가&lt;/a&gt; 생성 하는 표준 실패 메시지가 테스트 오류 출력에서 ​​일반적으로 발생하고 Test :: Builder 버전간에 변경 되었기 때문에 모든 문자열을 사용하여 &lt;code&gt;test_err&lt;/code&gt; 를 호출 하지 않습니다. 그렇게 시간</target>
        </trans-unit>
        <trans-unit id="4ad62b1bf690da795c5cc2f593aa204a22c3e54b" translate="yes" xml:space="preserve">
          <source>Because the target is reused, you must be careful when pushing multiple values on the stack. The following code will not do what you think:</source>
          <target state="translated">대상이 재사용되므로 스택에서 여러 값을 푸시 할 때주의해야합니다. 다음 코드는 생각하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bdc28270d2ca87731131681df34d184cd0aea361" translate="yes" xml:space="preserve">
          <source>Because the transliteration table is built at compile time, neither the</source>
          <target state="translated">음역 테이블은 컴파일 타임에 빌드되므로</target>
        </trans-unit>
        <trans-unit id="2e5bc19b54b9930fd5e2dcb3e6dfb795d20462ff" translate="yes" xml:space="preserve">
          <source>Because the value of &lt;code&gt;$Config{archname}&lt;/code&gt; may depend on the hardware architecture, it can vary more than the value of &lt;code&gt;$^O&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$Config{archname}&lt;/code&gt; 값은 하드웨어 아키텍처에 따라 달라질 수 있으므로 &lt;code&gt;$^O&lt;/code&gt; 값보다 더 다양 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e90ed527002ad403540a55eb78d4c5ab847fcd41" translate="yes" xml:space="preserve">
          <source>Because the values line may contain arbitrary expressions (for at fields, not caret fields), you can farm out more sophisticated processing to other functions, like sprintf() or one of your own. For example:</source>
          <target state="translated">값 행에 임의의 표현식 (캐럿 필드가 아닌 at 필드에 대한)이 포함될 수 있으므로보다 복잡한 처리를 sprintf () 또는 자체 함수와 같은 다른 함수로 팜 아웃 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d8bc8ec23c88de9efd45beeefb8be0639f500936" translate="yes" xml:space="preserve">
          <source>Because the variable becomes legal immediately under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; , so long as there is no variable with that name is already in scope, you can then reference the package variable again even within the same statement.</source>
          <target state="translated">변수는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용시&lt;/a&gt; 즉시 유효한 변수가되기 때문에 해당 이름의 변수가 이미 범위 내에 있지 않는 한 동일한 명령문 내에서도 패키지 변수를 다시 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da44b03f12b50aea312686ca3a3d0b93a5cee3d2" translate="yes" xml:space="preserve">
          <source>Because the variable becomes legal immediately under &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; , so long as there is no variable with that name is already in scope, you can then reference the package variable again even within the same statement.</source>
          <target state="translated">변수는 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; &lt;a href=&quot;use&quot;&gt;사용시&lt;/a&gt; 즉시 유효한 변수가되기 때문에 해당 이름의 변수가 이미 범위 내에 있지 않는 한 동일한 명령문 내에서도 패키지 변수를 다시 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1213676c8b2ebcfdeacd60c8eeb78e070a8906e8" translate="yes" xml:space="preserve">
          <source>Because there are more than three arguments to open(), forks the ps(1) command</source>
          <target state="translated">open ()에는 세 개 이상의 인수가 있으므로 ps (1) 명령을 분기합니다.</target>
        </trans-unit>
        <trans-unit id="63c371b01d835f1b3e60dfea4284b4178cc48a57" translate="yes" xml:space="preserve">
          <source>Because there are people who have their precise expectations about who may install where in the @INC path and who uses which @INC array. In fine tuned environments &lt;code&gt;UNINST=1&lt;/code&gt; can cause damage.</source>
          <target state="translated">@INC 경로의 어디에 설치하고 누가 @INC 배열을 사용하는지에 대한 정확한 기대를 가진 사람들이 있기 때문입니다. 미세 조정 된 환경에서 &lt;code&gt;UNINST=1&lt;/code&gt; 은 손상을 일으킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b691163394a932e3f6d352ebd6e7cd633110d322" translate="yes" xml:space="preserve">
          <source>Because these resource objects are considered to be owned by the entire process/system, and not the &quot;property&quot; of whatever is being serialized, no references underneath the object should be included in the serialized string. Thus, in any class that implements &lt;code&gt;STORABLE_attach&lt;/code&gt; , the &lt;code&gt;STORABLE_freeze&lt;/code&gt; method cannot return any references, and &lt;code&gt;Storable&lt;/code&gt; will throw an error if &lt;code&gt;STORABLE_freeze&lt;/code&gt; tries to return references.</source>
          <target state="translated">이러한 자원 객체는 직렬화되는 대상의 &quot;속성&quot;이 아니라 전체 프로세스 / 시스템이 소유 한 것으로 간주되므로 객체 아래의 참조는 직렬화 된 문자열에 포함되지 않아야합니다. 따라서 &lt;code&gt;STORABLE_attach&lt;/code&gt; 를 구현하는 모든 클래스 에서 &lt;code&gt;STORABLE_freeze&lt;/code&gt; 메소드는 참조를 리턴 할 수 없으며 &lt;code&gt;STORABLE_freeze&lt;/code&gt; 가 참조를 리턴하려고 하면 &lt;code&gt;Storable&lt;/code&gt; 은 오류를 발생 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="e58a7f2a84e13b9fada5ed77ade53adda8ab6513" translate="yes" xml:space="preserve">
          <source>Because this command is in some senses new, a warning is issued if you appear to have accidentally entered a block instead. If that's what you mean to do, write it as with &lt;code&gt;;{ ... }&lt;/code&gt; or even &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; { ... }&lt;/code&gt; .</source>
          <target state="translated">이 명령은 새로운 의미이므로 실수로 블록을 입력 한 것으로 보이면 경고가 표시됩니다. 그게 당신이 할 무슨 뜻인지의 경우와 같이 쓰기 &lt;code&gt;;{ ... }&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; { ... }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="efa88e36be50b169e959caa4254fea74155063be" translate="yes" xml:space="preserve">
          <source>Because this function uses mktemp(), it can suffer from race conditions.</source>
          <target state="translated">이 함수는 mktemp ()를 사용하기 때문에 경쟁 조건이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2478181856508c1cc91e32c539a156e07c17eb63" translate="yes" xml:space="preserve">
          <source>Because this information is not stored within the perl executable itself it is possible (but unlikely) that the information does not relate to the actual perl binary which is being used to access it.</source>
          <target state="translated">이 정보는 perl 실행 파일 자체에 저장되지 않기 때문에 정보가 정보에 액세스하는 데 사용되는 실제 perl 바이너리와 관련이 없을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad52e097251691a48fd57b8bdbc852cffc9bb5f6" translate="yes" xml:space="preserve">
          <source>Because this is a wide-open interface, pragmas (compiler directives) are also implemented this way. Currently implemented pragmas are:</source>
          <target state="translated">이것은 광범위하게 개방 된 인터페이스이므로 pragma (컴파일러 지시문)도 이런 방식으로 구현됩니다. 현재 구현 된 pragma는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e8055a645160d58d1aa3758824d7f3046e3cd0a9" translate="yes" xml:space="preserve">
          <source>Because this operator produces an assignable result, using assignments without parentheses will get you in trouble. For example, this:</source>
          <target state="translated">이 연산자는 할당 가능한 결과를 생성하므로 괄호없이 할당을 사용하면 문제가 발생합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cda353c8b2d143f02b4da6818d79c64f57fb0765" translate="yes" xml:space="preserve">
          <source>Because this promotes action at a distance, this counterintuitive behavior may be fixed in a future release.</source>
          <target state="translated">이렇게하면 원거리에서의 작업이 촉진되므로이 반 직관적 인 동작은 향후 릴리스에서 수정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ece57b9cb9008cd6f8ed94726d6205b9428981dc" translate="yes" xml:space="preserve">
          <source>Because thread creation and thread joining may occur in different contexts, it may be desirable to state the context explicitly to the thread's entry point function. This may be done by calling &lt;code&gt;-&amp;gt;create()&lt;/code&gt; with a hash reference as the first argument:</source>
          <target state="translated">스레드 생성 및 스레드 결합은 다른 컨텍스트에서 발생할 수 있으므로 컨텍스트를 스레드의 진입 점 함수에 명시 적으로 명시하는 것이 바람직 할 수 있습니다. 이것은 첫 번째 인수로 해시 참조와 함께 &lt;code&gt;-&amp;gt;create()&lt;/code&gt; 를 호출하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a311abdd84d17ec36b9f35316e74bcbefa1ccdb8" translate="yes" xml:space="preserve">
          <source>Because variable references always start with '$', '@', or '%', the &quot;reserved&quot; words aren't in fact reserved with respect to variable names. They</source>
          <target state="translated">변수 참조는 항상 '$', '@'또는 '%'로 시작하므로 &quot;예약 된&quot;단어는 실제로 변수 이름과 관련하여 예약되지 않습니다. 그들</target>
        </trans-unit>
        <trans-unit id="0ac64477279b51b2f8ca41484de7b49285b3815c" translate="yes" xml:space="preserve">
          <source>Because we are now concerned with the return value from</source>
          <target state="translated">우리는 이제 반환 값에 관심이 있기 때문에</target>
        </trans-unit>
        <trans-unit id="9befd612f9b4e3c124f9ec128a96394cb71cf6fb" translate="yes" xml:space="preserve">
          <source>Because we are using an SV to call</source>
          <target state="translated">우리는 SV를 사용하여 전화하기 때문에</target>
        </trans-unit>
        <trans-unit id="ded04a0cee8ca9e46b88306d00153b5faa51a410" translate="yes" xml:space="preserve">
          <source>Because we created temporary values (by means of sv_2mortal() calls) we will have to tidy up the Perl stack and dispose of mortal SVs.</source>
          <target state="translated">sv_2mortal () 호출을 통해 임시 값을 만들었으므로 Perl 스택을 정리하고 필사자 SV를 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="aa34046474e322c81f9b04585e1a1d3d975224ac" translate="yes" xml:space="preserve">
          <source>Because we specified G_DISCARD, it is not necessary to check the value returned from</source>
          <target state="translated">G_DISCARD를 지정 했으므로 반환 된 값을 확인할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="941fe97debd1bfb6b702aacc07a44435ca4e56b7" translate="yes" xml:space="preserve">
          <source>Because when &lt;code&gt;autochomp&lt;/code&gt; is disabled, &lt;code&gt;$a[10]&lt;/code&gt; will read back as &lt;code&gt;&quot;\n&quot;&lt;/code&gt; (or whatever the record separator string is.)</source>
          <target state="translated">경우이므로 &lt;code&gt;autochomp&lt;/code&gt; 가 비활성화되어, &lt;code&gt;$a[10]&lt;/code&gt; 로 다시 읽어 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; (또는 기록 분리기 스트링이 무엇이든).</target>
        </trans-unit>
        <trans-unit id="b0a17ee4f4c080e1c09fd835e1c924855560fcaf" translate="yes" xml:space="preserve">
          <source>Because you just moved the existing &lt;b&gt;stdout&lt;/b&gt; to somewhere else.</source>
          <target state="translated">기존 &lt;b&gt;stdout&lt;/b&gt; 을 다른 곳 으로 옮겼 기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="aa628e92b3c4d485e932ec48525c963ebb2f9c63" translate="yes" xml:space="preserve">
          <source>Because you're using something like this, which truncates the file</source>
          <target state="translated">파일을 자르는 이와 같은 것을 사용하고 있기 때문에</target>
        </trans-unit>
        <trans-unit id="973ca6acb768a5dd6330a5eade0b5d4dbc53ee84" translate="yes" xml:space="preserve">
          <source>Before Perl 5.10.0 and 5.8.8, PERL5SHELL was not taint checked when running external commands. It is recommended that you explicitly set (or delete) &lt;code&gt;$ENV{PERL5SHELL}&lt;/code&gt; when running in taint mode under Windows.</source>
          <target state="translated">Perl 5.10.0 및 5.8.8 이전에는 외부 명령을 실행할 때 PERL5SHELL이 오염 검사되지 않았습니다. Windows에서 &lt;code&gt;$ENV{PERL5SHELL}&lt;/code&gt; 인트 모드로 실행할 때 $ ENV {PERL5SHELL} 을 명시 적으로 설정하거나 삭제하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="36d386f00504590e35abdcaf1bc115cbe7c02503" translate="yes" xml:space="preserve">
          <source>Before Perl 5.14, the assignment to &lt;code&gt;$@&lt;/code&gt; occurred before restoration of localized variables, which means that for your code to run on older versions, a temporary is required if you want to mask some but not all errors:</source>
          <target state="translated">Perl 5.14 이전에는 지역화 된 변수를 복원하기 전에 &lt;code&gt;$@&lt;/code&gt; 할당 했습니다. 즉, 이전 버전에서 코드를 실행하려면 모든 오류는 아니지만 일부를 숨기려면 임시가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="512488ae279d498c1ee81f682f1f53229da4c6e2" translate="yes" xml:space="preserve">
          <source>Before Perl 5.14, the relation between overloading and tie()ing was broken. Overloading was triggered or not based on the</source>
          <target state="translated">Perl 5.14 이전에는 과부하와 tie ()의 관계가 깨졌습니다. 과부하가 발생했거나</target>
        </trans-unit>
        <trans-unit id="b34cea36bce317a875588bd1ba293a621fd141d4" translate="yes" xml:space="preserve">
          <source>Before Perl 5.18, &lt;code&gt;given(EXPR)&lt;/code&gt; assigned the value of</source>
          <target state="translated">Perl 5.18 이전에는 &lt;code&gt;given(EXPR)&lt;/code&gt; 이</target>
        </trans-unit>
        <trans-unit id="54445efd0dc2c1e8891bd0fe2ff854e28637df1f" translate="yes" xml:space="preserve">
          <source>Before Perl 5.6, you had to use the &lt;code&gt;*FH&lt;/code&gt; or &lt;code&gt;\*FH&lt;/code&gt; notations. These are &quot;typeglobs&quot;--see &lt;a href=&quot;perldata#Typeglobs-and-Filehandles&quot;&gt;Typeglobs and Filehandles in perldata&lt;/a&gt; and especially &lt;a href=&quot;perlsub#Pass-by-Reference&quot;&gt;Pass by Reference in perlsub&lt;/a&gt; for more information.</source>
          <target state="translated">Perl 5.6 이전에는 &lt;code&gt;*FH&lt;/code&gt; 또는 &lt;code&gt;\*FH&lt;/code&gt; 표기법 을 사용해야했습니다 . 이것들은 &quot;typeglobs&quot; 입니다. 자세한 정보 &lt;a href=&quot;perldata#Typeglobs-and-Filehandles&quot;&gt;는 perldata의 Typeglobs 및 Filehandles&lt;/a&gt; , 특히 &lt;a href=&quot;perlsub#Pass-by-Reference&quot;&gt;perlsub의 Pass by Reference&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2df4fb0a98f840a2555a3347deeff121cc142591" translate="yes" xml:space="preserve">
          <source>Before Perl 5.8.0, installing Perl code to deal with signals exposed you to danger from two things. First, few system library functions are re-entrant. If the signal interrupts while Perl is executing one function (like malloc(3) or printf(3)), and your signal handler then calls the same function again, you could get unpredictable behavior--often, a core dump. Second, Perl isn't itself re-entrant at the lowest levels. If the signal interrupts Perl while Perl is changing its own internal data structures, similarly unpredictable behavior may result.</source>
          <target state="translated">Perl 5.8.0 이전에는 Perl 코드를 설치하여 두 가지 위험에 노출 된 신호를 처리합니다. 먼저, 거의 재진입 할 ​​수있는 시스템 라이브러리 기능이 거의 없습니다. Perl이 malloc (3) 또는 printf (3)와 같은 하나의 함수를 실행하는 동안 신호가 중단되고 신호 처리기가 동일한 함수를 다시 호출하면 예측할 수없는 동작 (종종 코어 덤프)이 발생할 수 있습니다. 둘째, Perl 자체가 가장 낮은 수준으로 재진입되는 것은 아닙니다. Perl이 자체 내부 데이터 구조를 변경하는 동안 신호가 Perl을 중단하면 예측할 수없는 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="870cc998eebf778ddd06bc7ed2f1805b37f31d55" translate="yes" xml:space="preserve">
          <source>Before Perl v5.8.0, the use of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; was used to declare that operations in the current block or file would be Unicode-aware. This model was found to be wrong, or at least clumsy: the &quot;Unicodeness&quot; is now carried with the data, instead of being attached to the operations. Starting with Perl v5.8.0, only one case remains where an explicit &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
utf8&lt;/code&gt; is needed: if your Perl script itself is encoded in UTF-8, you can use UTF-8 in your identifier names, and in string and regular expression literals, by saying &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; . This is not the default because scripts with legacy 8-bit data in them would break. See &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt;.</source>
          <target state="translated">Perl v5.8.0 이전 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 사용을 사용 하여 현재 블록 또는 파일의 조작이 유니 코드를 인식 함을 선언했습니다. 이 모델은 잘못되었거나 적어도 어색한 것으로 밝혀졌습니다. &quot;유니 코드&quot;는 이제 작업에 첨부되지 않고 데이터와 함께 전달됩니다. Perl v5.8.0부터는 명시 적으로 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용해야&lt;/a&gt; 하는 경우가 하나만 남아 있습니다. Perl 스크립트 자체가 UTF-8로 인코딩 된 경우 식별자 이름과 문자열 및 정규식 리터럴에서 UTF-8을 사용할 수 있습니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하여 말하십시오 . 레거시 8 비트 데이터가 포함 된 스크립트가 작동하지 않기 때문에 이것이 기본값이 아닙니다. &lt;a href=&quot;utf8&quot;&gt;utf8을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="04e04ef0cf482846e31d6720b49ae41928208ea3" translate="yes" xml:space="preserve">
          <source>Before Unicode, most encodings used 8 bits (a single byte) to encode each character. Thus a character was a byte, and a byte was a character, and there could be only 256 or fewer possible characters. &quot;Byte Semantics&quot; in the title of this section refers to this behavior. There was no need to distinguish between &quot;Byte&quot; and &quot;Character&quot;.</source>
          <target state="translated">유니 코드 이전에는 대부분의 인코딩에서 각 문자를 인코딩하는 데 8 비트 (1 바이트)가 사용되었습니다. 따라서 문자는 바이트 였고 바이트는 문자였으며 256 자 이하의 문자 만 가능했습니다. 이 섹션 제목의 &quot;바이트 의미&quot;는이 동작을 나타냅니다. &quot;바이트&quot;와 &quot;문자&quot;를 구분할 필요가 없었습니다.</target>
        </trans-unit>
        <trans-unit id="290d67ae3ee387c5e4e99c79148af4efc4e204f2" translate="yes" xml:space="preserve">
          <source>Before Unicode, when a character was a byte was a character, Perl knew only about the 128 characters defined by ASCII, code points 0 through 127 (except for under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; ). That left the code points 128 to 255 as unassigned, and available for whatever use a program might want. The only semantics they have is their ordinal numbers, and that they are members of none of the non-negative character classes. None are considered to match &lt;code&gt;\w&lt;/code&gt; for example, but all match &lt;code&gt;\W&lt;/code&gt; .</source>
          <target state="translated">유니 코드 이전에는 문자가 바이트 일 때 문자가 ASCII 일 때 Perl은 ASCII로 정의 된 128 개의 문자 (0에서 127까지의 코드 포인트에 대해서만 알았습니다 ( &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 제외 )). 그것은 코드 포인트 128에서 255를 할당되지 않은 채로 남겨두고 프로그램이 원하는 어떤 용도로든 사용할 수 있습니다. 그들이 가진 유일한 의미는 그들의 서수이며, 음이 아닌 문자 클래스의 멤버가 아닙니다. 예를 들어, &lt;code&gt;\w&lt;/code&gt; 와 일치하는 것으로 간주되지는 않지만 모두 &lt;code&gt;\W&lt;/code&gt; 와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="d690a12b540a565baadfa57c599d5a868691200d" translate="yes" xml:space="preserve">
          <source>Before any command has executed or if an unexpected error occurs &lt;code&gt;code()&lt;/code&gt; will return &quot;421&quot; (temporary connection failure) and &lt;code&gt;message()&lt;/code&gt; will return undef.</source>
          <target state="translated">명령이 실행되기 전에 또는 예기치 않은 오류가 발생하면 &lt;code&gt;code()&lt;/code&gt; 는 &quot;421&quot;(임시 연결 실패 &lt;code&gt;message()&lt;/code&gt; 을 반환 하고 message () 는 undef를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="752f8552c1f4e0b002a40cffe2d75752a7a074d6" translate="yes" xml:space="preserve">
          <source>Before anything else, you need a testing plan. This basically declares how many tests your script is going to run to protect against premature failure.</source>
          <target state="translated">무엇보다 먼저 테스트 계획이 필요합니다. 이것은 기본적으로 조기 실패로부터 보호하기 위해 스크립트가 몇 개의 테스트를 실행할지 선언합니다.</target>
        </trans-unit>
        <trans-unit id="4bb0c278106c5fac84e8a238d47e490b85a41fa5" translate="yes" xml:space="preserve">
          <source>Before installing the patches to the IBM C-compiler you need to know the level of patching for the Operating System. IBM's command 'oslevel' will show the base, but is not always complete (in this example oslevel shows 4.3.NULL, whereas the system might run most of 4.3.THREE):</source>
          <target state="translated">IBM C 컴파일러에 패치를 설치하기 전에 운영 체제의 패치 레벨을 알아야합니다. IBM의 명령 'oslevel'은 기본을 표시하지만 항상 완전한 것은 아닙니다 (이 예에서는 oslevel은 4.3.NULL을 표시하지만 시스템은 대부분 4.3을 실행합니다).</target>
        </trans-unit>
        <trans-unit id="b46ac14ab9ac97916ee87fb2735b65fa3bcb3084" translate="yes" xml:space="preserve">
          <source>Before perl5.6, you had to deal with various typeglob idioms which you may see in older code.</source>
          <target state="translated">perl5.6 이전에는 이전 코드에서 볼 수있는 다양한 글로브 관용구를 처리해야했습니다.</target>
        </trans-unit>
        <trans-unit id="4d24253ab2fd2c805f0d6bcaca41ee8bd8627285" translate="yes" xml:space="preserve">
          <source>Before release 5 of Perl it was difficult to represent complex data structures, because all references had to be symbolic--and even then it was difficult to refer to a variable instead of a symbol table entry. Perl now not only makes it easier to use symbolic references to variables, but also lets you have &quot;hard&quot; references to any piece of data or code. Any scalar may hold a hard reference. Because arrays and hashes contain scalars, you can now easily build arrays of arrays, arrays of hashes, hashes of arrays, arrays of hashes of functions, and so on.</source>
          <target state="translated">Perl의 릴리스 5 이전에는 모든 참조가 기호 여야했기 때문에 복잡한 데이터 구조를 표현하기가 어려웠으며 심지어 기호 테이블 항목 대신 변수를 참조하기도 어려웠습니다. Perl은 이제 변수에 대한 기호 참조를보다 쉽게 ​​사용할 수있을뿐만 아니라 모든 데이터 또는 코드에 대한 &quot;하드&quot;참조를 가질 수 있습니다. 모든 스칼라는 어려운 참조를 보유 할 수 있습니다. 배열과 해시는 스칼라를 포함하므로 이제 배열 배열, 해시 배열, 배열 해시, 함수 해시 배열 등을 쉽게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef266fb9e8f6dafd9b23077a1b88d8327a3a9667" translate="yes" xml:space="preserve">
          <source>Before submitting a bug, please make sure that the traditional method of building a Perl module package from a shell by following the installation instructions of that package still works in your environment.</source>
          <target state="translated">버그를 제출하기 전에 해당 패키지의 설치 지시 사항에 따라 쉘에서 Perl 모듈 패키지를 빌드하는 일반적인 방법이 여전히 환경에서 작동하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="852a62fb5185caad446c6f66da79350d77dac37e" translate="yes" xml:space="preserve">
          <source>Before terminating, the &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; function must explicitly install the filter by calling &lt;code&gt;filter_add&lt;/code&gt; .</source>
          <target state="translated">종료하기 전에 &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 함수는 &lt;code&gt;filter_add&lt;/code&gt; 를 호출하여 필터를 명시 적으로 설치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f512253f81c2fd706ba28a9ad84dc13dc48c3eb8" translate="yes" xml:space="preserve">
          <source>Before the Perl interpreter can execute a Perl script, it must first read it from a file into memory for parsing and compilation. If that script itself includes other scripts with a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; statement, then each of those scripts will have to be read from their respective files as well.</source>
          <target state="translated">Perl 인터프리터는 Perl 스크립트를 실행하기 전에 파싱 및 컴파일을 위해 파일에서 메모리로 먼저 읽어야합니다. 해당 스크립트 자체에 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 문 이있는 다른 스크립트가 포함 된 경우 해당 스크립트 각각을 해당 파일에서 읽어야합니다.</target>
        </trans-unit>
        <trans-unit id="7056378ac690eaab80565ece696557496384c5bd" translate="yes" xml:space="preserve">
          <source>Before the introduction of Unicode support in Perl, The &lt;code&gt;eq&lt;/code&gt; operator just compared the strings represented by two scalars. Beginning with Perl 5.8, &lt;code&gt;eq&lt;/code&gt; compares two strings with simultaneous consideration of</source>
          <target state="translated">Perl에서 유니 코드 지원을 도입하기 전에 &lt;code&gt;eq&lt;/code&gt; 연산자는 두 스칼라로 표시되는 문자열을 비교했습니다. Perl 5.8부터 &lt;code&gt;eq&lt;/code&gt; 는 두 문자열을 동시에 고려하여 비교합니다.</target>
        </trans-unit>
        <trans-unit id="07d7d02c48129829b963f0f9c3efb3625c646877" translate="yes" xml:space="preserve">
          <source>Before the introduction of lexical warnings, Perl had two classes of warnings: mandatory and optional.</source>
          <target state="translated">어휘 경고를 도입하기 전에 Perl에는 필수 및 선택의 두 가지 경고 클래스가있었습니다.</target>
        </trans-unit>
        <trans-unit id="759cf8f89c69b1e5d0ddf3e544f843b8c5c70ae3" translate="yes" xml:space="preserve">
          <source>Before we even start scraping out the code, there are a few things we'll want to do in advance.</source>
          <target state="translated">코드 스크랩을 시작하기 전에 미리해야 할 것이 몇 가지 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2896a2a84e6fb1618d5a02150eb4f976c910264" translate="yes" xml:space="preserve">
          <source>Before we go any further, you'll want to know how to quit the debugger: use just the letter '&lt;b&gt;q&lt;/b&gt;', not the words 'quit' or 'exit':</source>
          <target state="translated">더 나아 가기 전에 디버거를 종료하는 방법을 알고 싶을 것입니다 . 단어 'quit'또는 'exit'이 아닌 ' &lt;b&gt;q&lt;/b&gt; ' 만 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="8a4b62fae1d0e77e031397754824b30119b2b62a" translate="yes" xml:space="preserve">
          <source>Before writing XS, read the &lt;a href=&quot;#CAVEATS&quot;&gt;CAVEATS&lt;/a&gt; section below.</source>
          <target state="translated">XS를 작성하기 전에 읽어 &lt;a href=&quot;#CAVEATS&quot;&gt;주의 사항의&lt;/a&gt; 아래 부분을.</target>
        </trans-unit>
        <trans-unit id="1b5bba6a088484e3f244c7ed2d3c63206cbf13d5" translate="yes" xml:space="preserve">
          <source>Before you consider posting a bug report, please consult, and possibly post a message to the discussion forum to see if what you've encountered is a known problem.</source>
          <target state="translated">버그 보고서 게시를 고려하기 전에 토론을 통해 토론 포럼에 메시지를 게시하여 발생한 문제가 알려진 문제인지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="528e582d94b55449ac3523f64dd0d0e5c7486531" translate="yes" xml:space="preserve">
          <source>Before you continue, note the sort order for variables. In general, we first list the variables in case-insensitive, almost-lexigraphical order (ignoring the &lt;code&gt;{&lt;/code&gt; or &lt;code&gt;^&lt;/code&gt; preceding words, as in &lt;code&gt;${^UNICODE}&lt;/code&gt; or &lt;code&gt;$^T&lt;/code&gt; ), although &lt;code&gt;$_&lt;/code&gt; and &lt;code&gt;@_&lt;/code&gt; move up to the top of the pile. For variables with the same identifier, we list it in order of scalar, array, hash, and bareword.</source>
          <target state="translated">계속하기 전에 변수의 정렬 순서를 참고하십시오. 일반적으로, &lt;code&gt;$_&lt;/code&gt; 와 &lt;code&gt;@_&lt;/code&gt; 는 맨 위로 이동 하지만 먼저 변수를 대소 문자를 구분하지 않고 거의 어휘 순서대로 나열합니다 ( &lt;code&gt;${^UNICODE}&lt;/code&gt; 또는 &lt;code&gt;$^T&lt;/code&gt; 에서와 같이 &lt;code&gt;{&lt;/code&gt; 또는 &lt;code&gt;^&lt;/code&gt; 선행 단어 무시 ) 더미의. 식별자가 동일한 변수의 경우 스칼라, 배열, 해시 및 베어 워드 순서로 나열합니다.</target>
        </trans-unit>
        <trans-unit id="29b11945139a380af16d5d49212f0306507606fb" translate="yes" xml:space="preserve">
          <source>Before you decide to merge two hashes, you have to decide what to do if both hashes contain keys that are the same and if you want to leave the original hashes as they were.</source>
          <target state="translated">두 개의 해시를 병합하기로 결정하기 전에 두 해시에 동일한 키가 포함되어 있고 원래 해시를 그대로 두려면 어떻게해야하는지 결정해야합니다.</target>
        </trans-unit>
        <trans-unit id="7b25edaa05329b202d8bbb719df130a305f9a0e7" translate="yes" xml:space="preserve">
          <source>Before you do anything else, you can help yourself by ensuring that you let Perl tell you about problem areas in your code. By turning on warnings and strictures, you can head off many problems before they get too big. You can find out more about these in &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; and &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">다른 작업을 수행하기 전에 Perl이 코드의 문제 영역에 대해 알려주도록하여 스스로 도울 수 있습니다. 경고와 제한을 설정하면 문제가 너무 커지기 전에 많은 문제를 해결할 수 있습니다. 당신은 이들에 대한 자세한 내용을 찾을 수 있습니다 &lt;a href=&quot;strict&quot;&gt;엄격한&lt;/a&gt; 및 &lt;a href=&quot;warnings&quot;&gt;경고&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="054a146795bb49c5d92e2d968e739a1f63c7604c" translate="yes" xml:space="preserve">
          <source>Before you do that, first make sure the alias is nonexistent using &lt;code&gt;resolve_alias()&lt;/code&gt; , which returns the canonical name thereof. For example:</source>
          <target state="translated">이를 수행하기 전에 먼저 &lt;code&gt;resolve_alias()&lt;/code&gt; 사용하여 별명이 존재하지 않는지 확인하십시오 . 그러면 정규 이름이 리턴됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ea4eb9d8b93fbec8607b4df5d4d1083567318fe5" translate="yes" xml:space="preserve">
          <source>Before you launch yourself head first into the rest of this document, it would be a good idea to have read the following two documents--&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; and &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;.</source>
          <target state="translated">이 문서의 나머지 부분을 먼저 시작하기 전에 &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; 및 &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; 문서를 읽는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="dde9d3bcf2359cbba92e26ac6718964bcaacd3c3" translate="yes" xml:space="preserve">
          <source>Before you panic, know that many people do use &lt;code&gt;Moose&lt;/code&gt; for command-line tools and other startup-sensitive code. We encourage you to try &lt;code&gt;Moose&lt;/code&gt; out first before worrying about startup speed.</source>
          <target state="translated">당황하기 전에 많은 사람들이 명령 줄 도구 및 기타 시작에 민감한 코드에 &lt;code&gt;Moose&lt;/code&gt; 를 사용한다는 것을 알고 있습니다. 시작 속도가 걱정되기 전에 &lt;code&gt;Moose&lt;/code&gt; 를 먼저 사용해 보는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="2c445dd5994fd48a7f879efa85cd15aa5394f95f" translate="yes" xml:space="preserve">
          <source>Before you start</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa35a8236ca3aecdca56f64d9f3832c8bf9e0996" translate="yes" xml:space="preserve">
          <source>Before you start, it's important to know a few things:</source>
          <target state="translated">시작하기 전에 몇 가지 사항을 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="85435e88ea012cea6ee5f0e38fd4d12329633e18" translate="yes" xml:space="preserve">
          <source>Before you start, you should glance through the README file found in the top-level directory to which the Perl distribution was extracted. Make sure you read and understand the terms under which this software is being distributed.</source>
          <target state="translated">시작하기 전에 Perl 분배가 추출 된 최상위 디렉토리에있는 README 파일을 살펴 봐야합니다. 이 소프트웨어가 배포되는 용어를 읽고 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="82f236c12f0a7b2bfa05bcc6c77fce0d5554f74c" translate="yes" xml:space="preserve">
          <source>Before you start, you should glance through the README file found in the top-level directory where the Perl distribution was extracted. Make sure you read and understand the terms under which this software is being distributed.</source>
          <target state="translated">시작하기 전에 Perl 배포가 추출 된 최상위 디렉토리에있는 README 파일을 살펴 봐야합니다. 이 소프트웨어가 배포되는 용어를 읽고 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="e6dc5aa054869bdc5776548930fba90056a049b5" translate="yes" xml:space="preserve">
          <source>Begin the retrieval of a file called &lt;code&gt;FILE&lt;/code&gt; from the remote server.</source>
          <target state="translated">원격 서버에서 &lt;code&gt;FILE&lt;/code&gt; 이라는 파일 검색을 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="d1bae729fa6ba19a84ae13329bfa79bbfaf77e9b" translate="yes" xml:space="preserve">
          <source>Beginner note: In example 2, above &lt;code&gt;$columns&lt;/code&gt; is imported into the local namespace, and set locally. In example 3, &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; is set in its own namespace without importing it.</source>
          <target state="translated">초보자 참고 사항 : 예 2에서 위의 &lt;code&gt;$columns&lt;/code&gt; 로컬 네임 스페이스로 가져 와서 로컬로 설정합니다. 예 3에서 &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; 는 가져 오지 않고 자체 네임 스페이스에 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="8c50d29cf088569a469311ef83bf39d51d30a011" translate="yes" xml:space="preserve">
          <source>Beginners often think they want to have a variable contain the name of a variable.</source>
          <target state="translated">초보자는 종종 변수 이름에 변수 이름이 포함되기를 원한다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="ddd5e0ea97f5ceda3171fdb3abe535bc421229c3" translate="yes" xml:space="preserve">
          <source>Beginning in Perl 5.12, Perl accepts an ellipsis, &quot;&lt;code&gt;...&lt;/code&gt; &quot;, as a placeholder for code that you haven't implemented yet. This form of ellipsis, the unimplemented statement, should not be confused with the binary flip-flop &lt;code&gt;...&lt;/code&gt; operator. One is a statement and the other an operator. (Perl doesn't usually confuse them because usually Perl can tell whether it wants an operator or a statement, but see below for exceptions.)</source>
          <target state="translated">Perl 5.12부터 Perl은 아직 구현하지 않은 코드의 자리 표시 자로 줄임표 &quot; &lt;code&gt;...&lt;/code&gt; &quot;를 허용합니다 . 구현되지 않은 명령문 인이 줄임표는 바이너리 flip-flop &lt;code&gt;...&lt;/code&gt; 연산자 와 혼동해서는 안됩니다 . 하나는 설명이고 다른 하나는 연산자입니다. (펄은 보통 연산자 나 문장을 원하는지 알 수 있기 때문에 혼동하지 않으며, 예외는 아래를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="82d48c3b20d2f80bac7595523990a9132ad0e311" translate="yes" xml:space="preserve">
          <source>Beginning in v5.20.0, a postfix syntax for using references is available. It behaves as described in &lt;a href=&quot;#Using-References&quot;&gt;Using References&lt;/a&gt;, but instead of a prefixed sigil, a postfixed sigil-and-star is used.</source>
          <target state="translated">v5.20.0부터 참조 사용을위한 접미사 구문을 사용할 수 있습니다. &lt;a href=&quot;#Using-References&quot;&gt;참조 사용에&lt;/a&gt; 설명 된대로 작동 하지만 접두사 sigil 대신 접두사 sigil-and-star가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e4fd9d1748abdc28d0efb1f242a157236c1c9529" translate="yes" xml:space="preserve">
          <source>Beginning in v5.22.0, the referencing operator can be assigned to. It performs an aliasing operation, so that the variable name referenced on the left-hand side becomes an alias for the thing referenced on the right-hand side:</source>
          <target state="translated">v5.22.0부터 참조 연산자를 할당 할 수 있습니다. 왼쪽에서 참조되는 변수 이름이 오른쪽에서 참조되는 항목의 별칭이되도록 앨리어싱 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="54f7bcfa82e1deb0e3342e8510b04a376681f2a5" translate="yes" xml:space="preserve">
          <source>Beginning with HP-UX 11.00, programs compiled under HP-UX can take advantage of the LP64 programming environment (LP64 means Longs and Pointers are 64 bits wide), in which scalar variables will be able to hold numbers larger than 2^32 with complete precision. Perl has proven to be consistent and reliable in 64bit mode since 5.8.1 on all HP-UX 11.xx.</source>
          <target state="translated">HP-UX 11.00부터 HP-UX에서 컴파일 된 프로그램은 LP64 프로그래밍 환경 (LP64는 Long 및 Pointer의 너비가 64 비트임을 의미 함)을 이용할 수 있으며 스칼라 변수는 2 ^ 32보다 큰 숫자를 완전하게 보유 할 수 있습니다. 정도. Perl은 모든 HP-UX 11.xx에서 5.8.1 이후 64 비트 모드에서 일관되고 안정적인 것으로 입증되었습니다.</target>
        </trans-unit>
        <trans-unit id="7f252bceac885ebc51d1278ef820d426befd060f" translate="yes" xml:space="preserve">
          <source>Beginning with HP-UX version 10.20, files larger than 2GB (2^31 bytes) may be created and manipulated. Three separate methods of doing this are available. Of these methods, the best method for Perl is to compile using the -Duselargefiles flag to Configure. This causes Perl to be compiled using structures and functions in which these are 64 bits wide, rather than 32 bits wide. (Note that this will only work with HP's ANSI C compiler. If you want to compile Perl using gcc, you will have to get a version of the compiler that supports 64-bit operations. See above for where to find it.)</source>
          <target state="translated">HP-UX 버전 10.20부터는 2GB (2 ^ 31 바이트)보다 큰 파일을 작성하고 조작 할 수 있습니다. 이 작업을 수행하는 세 가지 방법이 있습니다. 이러한 방법 중 Perl에 대한 가장 좋은 방법은 -Duselargefiles 플래그를 사용하여 컴파일하는 것입니다. 이로 인해 Perl은 32 비트가 아닌 64 비트의 구조와 함수를 사용하여 컴파일됩니다. (이 기능은 HP의 ANSI C 컴파일러에서만 작동합니다. gcc를 사용하여 Perl을 컴파일하려면 64 비트 연산을 지원하는 컴파일러 버전을 가져와야합니다. 위의 위치는 위를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="7b1997a711dcb385772e62932a24b63be2ca5162" translate="yes" xml:space="preserve">
          <source>Beginning with Perl 5.10.0, you can declare variables with the &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; keyword in place of &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;. For that to work, though, you must have enabled that feature beforehand, either by using the &lt;code&gt;feature&lt;/code&gt; pragma, or by using &lt;code&gt;-E&lt;/code&gt; on one-liners (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;). Beginning with Perl 5.16, the &lt;code&gt;CORE::state&lt;/code&gt; form does not require the &lt;code&gt;feature&lt;/code&gt; pragma.</source>
          <target state="translated">Perl 5.10.0부터 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 대신에 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 키워드를 사용하여 변수를 선언 할 수 있습니다 . 그래도 작동하려면 &lt;code&gt;feature&lt;/code&gt; pragma를 사용하거나 하나의 라이너에서 &lt;code&gt;-E&lt;/code&gt; 를 사용하여 해당 기능을 미리 활성화해야합니다 ( &lt;a href=&quot;feature&quot;&gt;기능&lt;/a&gt; 참조 ). Perl 5.16부터 &lt;code&gt;CORE::state&lt;/code&gt; 양식에는 &lt;code&gt;feature&lt;/code&gt; pragma가 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="fd848af5e7c989b28a26cc1aec55564025fc4af9" translate="yes" xml:space="preserve">
          <source>Beginning with Perl 5.18, you can declare a private subroutine with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;. As with state variables, the &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; keyword is only available under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'state'&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.010&lt;/code&gt; or higher.</source>
          <target state="translated">Perl 5.18부터는 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 로 개인 서브 루틴을 선언 할 수 있습니다 . 상태 변수와 마찬가지로 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 키워드는 아래에서만 사용할 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'state'&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.010&lt;/code&gt; 이상.</target>
        </trans-unit>
        <trans-unit id="2eca9f03e4044bf99d10838840f25a5c4ae464b9" translate="yes" xml:space="preserve">
          <source>Beginning with perl 5.10.0, you can also use &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; variables to have lexicals that are initialized only once (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;):</source>
          <target state="translated">perl 5.10.0부터는 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 변수를 사용 하여 한 번만 초기화되는 어휘를 가질 수 있습니다 ( &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d269396692530a4c995cb59a2555fae5ff4dd172" translate="yes" xml:space="preserve">
          <source>Beginning with version 5.004, the following functions are also supported:</source>
          <target state="translated">버전 5.004부터 다음 기능도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="34133685a790f2f2b5caab0cdf19417a300c4bef" translate="yes" xml:space="preserve">
          <source>Behaves like wait(2) on your system: it waits for a child process to terminate and returns the pid of the deceased process, or &lt;code&gt;-1&lt;/code&gt; if there are no child processes. The status is returned in &lt;code&gt;$?&lt;/code&gt; and &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; . Note that a return value of &lt;code&gt;-1&lt;/code&gt; could mean that child processes are being automatically reaped, as described in &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt;.</source>
          <target state="translated">시스템에서 wait (2)처럼 작동합니다. 자식 프로세스가 종료 될 때까지 기다렸다가 사망 한 프로세스의 pid를 반환하거나 자식 프로세스가없는 경우 &lt;code&gt;-1&lt;/code&gt; 입니다. 상태는 &lt;code&gt;$?&lt;/code&gt; 로 반환됩니다 . 및 &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; . &lt;code&gt;-1&lt;/code&gt; 의 리턴 값은 &lt;a href=&quot;../perlipc&quot;&gt;perlipc에&lt;/a&gt; 설명 된대로 하위 프로세스가 자동으로 수확됨을 의미 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f0c5491ce914759629c95815e914e921b25062e" translate="yes" xml:space="preserve">
          <source>Behaves like wait(2) on your system: it waits for a child process to terminate and returns the pid of the deceased process, or &lt;code&gt;-1&lt;/code&gt; if there are no child processes. The status is returned in &lt;code&gt;$?&lt;/code&gt; and &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; . Note that a return value of &lt;code&gt;-1&lt;/code&gt; could mean that child processes are being automatically reaped, as described in &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;.</source>
          <target state="translated">시스템에서 wait (2)처럼 작동합니다. 자식 프로세스가 종료 될 때까지 기다렸다가 사망 한 프로세스의 pid를 반환하거나 자식 프로세스가없는 경우 &lt;code&gt;-1&lt;/code&gt; 입니다. 상태는 &lt;code&gt;$?&lt;/code&gt; 로 반환됩니다 . 및 &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; . &lt;code&gt;-1&lt;/code&gt; 의 리턴 값은 &lt;a href=&quot;perlipc&quot;&gt;perlipc에&lt;/a&gt; 설명 된대로 하위 프로세스가 자동으로 수확됨을 의미 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0be599b479dc1a9d62fd33cd4b25ae6147cf1069" translate="yes" xml:space="preserve">
          <source>Behaves the same as &lt;a href=&quot;#croak&quot;&gt;croak&lt;/a&gt;, except for the return type. It should be used only where the &lt;code&gt;OP *&lt;/code&gt; return type is required. The function never actually returns.</source>
          <target state="translated">반환 유형을 제외하고 &lt;a href=&quot;#croak&quot;&gt;croak&lt;/a&gt; 과 동일하게 동작합니다 . &lt;code&gt;OP *&lt;/code&gt; 반환 유형이 필요한 경우 에만 사용해야 합니다. 이 함수는 실제로 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4c49c08082a231774a342ac5391eebbc26cb4596" translate="yes" xml:space="preserve">
          <source>Behaves the same as &lt;a href=&quot;#croak_sv&quot;&gt;croak_sv&lt;/a&gt;, except for the return type. It should be used only where the &lt;code&gt;OP *&lt;/code&gt; return type is required. The function never actually returns.</source>
          <target state="translated">반환 유형을 제외하고 &lt;a href=&quot;#croak_sv&quot;&gt;croak_sv&lt;/a&gt; 와 동일하게 동작합니다 . &lt;code&gt;OP *&lt;/code&gt; 반환 유형이 필요한 경우 에만 사용해야 합니다. 이 함수는 실제로 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fbf9c5863d4bbe3bd2490f1ad8ab93b461cdea43" translate="yes" xml:space="preserve">
          <source>Behavior of other Perl features in forked pseudo-processes</source>
          <target state="translated">분기 된 유사 프로세스에서 다른 Perl 기능의 동작</target>
        </trans-unit>
        <trans-unit id="546fd299e317f0cfab072f158d53c6046d080ef9" translate="yes" xml:space="preserve">
          <source>Behavior of this function varies wildly depending on your system implementation. For example, it will usually not work across file system boundaries, even though the system</source>
          <target state="translated">이 기능의 동작은 시스템 구현에 따라 크게 다릅니다. 예를 들어, 비록 시스템이</target>
        </trans-unit>
        <trans-unit id="6296c0acaf0c68b8a708c260d5e620e45c188c21" translate="yes" xml:space="preserve">
          <source>Behaviour since version 2.11</source>
          <target state="translated">버전 2.11 이후의 동작</target>
        </trans-unit>
        <trans-unit id="fc99a03494d30ac32472278376507c26adfb39ce" translate="yes" xml:space="preserve">
          <source>Behind The Scenes</source>
          <target state="translated">무대 뒤에서</target>
        </trans-unit>
        <trans-unit id="8e234f329fb33ee94403565f619b16d72bc67919" translate="yes" xml:space="preserve">
          <source>Behind the scenes the &lt;code&gt;globmap&lt;/code&gt; function does a combination of a file glob to match existing filenames followed by a substitute to create the new filenames.</source>
          <target state="translated">장면 뒤에서 &lt;code&gt;globmap&lt;/code&gt; 함수는 기존 파일 이름과 일치시키기 위해 파일 glob를 조합 한 다음 새 파일 이름을 만드는 대신 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4f88b0aecf2344cf177fb22c2c1e4809d60f491d" translate="yes" xml:space="preserve">
          <source>Being Perl-specific, this function has evolved along time. It can currently be called as follow:</source>
          <target state="translated">Perl에 특화된이 기능은 시간이 지남에 따라 발전했습니다. 현재 다음과 같이 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fc303a764ff6b60a94ad6969ea173a3382e1620" translate="yes" xml:space="preserve">
          <source>Being a mechanical process pl2pm is not bullet proof. The converted code will need careful checking, especially any package statements. Don't delete the original .pl file till the new .pm one works!</source>
          <target state="translated">기계적인 프로세스 pl2pm은 방탄이 아닙니다. 변환 된 코드는 특히 패키지 문을주의 깊게 검사해야합니다. 새 .pm 파일이 작동 할 때까지 원본 .pl 파일을 삭제하지 마십시오!</target>
        </trans-unit>
        <trans-unit id="e98f301c8128b87a5492d5177997df433005bc22" translate="yes" xml:space="preserve">
          <source>Being parsimonious on filehandles is also useful (besides being parsimonious) for example when something is dependent on file descriptors, like for example locking using flock(). If you do just &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;B&quot;)&lt;/code&gt; , the filehandle A will not have the same file descriptor as B, and therefore flock(A) will not flock(B) nor vice versa. But with &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;=B&quot;)&lt;/code&gt; , the filehandles will share the same underlying system file descriptor.</source>
          <target state="translated">예를 들어 flock ()을 사용한 잠금과 같이 파일 디스크립터에 의존하는 경우 파일 처리에 대해 parsimonious 인 것이 유용합니다 (parsimonious 외에). 당신은 그냥 할 경우 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;B&quot;)&lt;/code&gt; , 파일 핸들 A는 B와 같은 파일 설명이 없습니다, 따라서 반대 무리하지 않을 것이다 (A)를 무리 (B)도 그. 그러나 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;=B&quot;)&lt;/code&gt; 을 사용하면 파일 핸들은 동일한 기본 시스템 파일 설명자를 공유합니다.</target>
        </trans-unit>
        <trans-unit id="eb7d6ff0d012000fe6eccb3c989a4ceae1efb833" translate="yes" xml:space="preserve">
          <source>Being parsimonious on filehandles is also useful (besides being parsimonious) for example when something is dependent on file descriptors, like for example locking using flock(). If you do just &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;B&quot;)&lt;/code&gt; , the filehandle A will not have the same file descriptor as B, and therefore flock(A) will not flock(B) nor vice versa. But with &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;=B&quot;)&lt;/code&gt; , the filehandles will share the same underlying system file descriptor.</source>
          <target state="translated">예를 들어 flock ()을 사용한 잠금과 같이 파일 디스크립터에 의존하는 경우 파일 처리에 대해 parsimonious 인 것이 유용합니다 (parsimonious 외에). 당신은 그냥 할 경우 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;B&quot;)&lt;/code&gt; , 파일 핸들 A는 B와 같은 파일 설명이 없습니다, 따라서 반대 무리하지 않을 것이다 (A)를 무리 (B)도 그. 그러나 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;=B&quot;)&lt;/code&gt; 을 사용하면 파일 핸들은 동일한 기본 시스템 파일 설명자를 공유합니다.</target>
        </trans-unit>
        <trans-unit id="1b8a9f965c18d647b7a7bff03b9e0c4a68361224" translate="yes" xml:space="preserve">
          <source>Bell sounds when word completion fails.</source>
          <target state="translated">단어 완성에 실패하면 벨 소리가납니다.</target>
        </trans-unit>
        <trans-unit id="74d2e1c77a10412bd2a923bb84c1c65e97a50e55" translate="yes" xml:space="preserve">
          <source>Below are a few examples of globmaps</source>
          <target state="translated">다음은 글로브 맵의 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="d6238547f660d516d0fdf40f8de1337807f2955e" translate="yes" xml:space="preserve">
          <source>Below is a</source>
          <target state="translated">아래는</target>
        </trans-unit>
        <trans-unit id="eab1a70d36b9d2b495b3781776947aeb4b2fc004" translate="yes" xml:space="preserve">
          <source>Below is a list of a few frameworks with comments which might help you in making a decision, depending on your specific requirements. Start by reading the docs, then ask questions on the relevant mailing list or IRC channel.</source>
          <target state="translated">다음은 특정 요구 사항에 따라 결정을 내리는 데 도움이 될 수있는 주석이 포함 된 몇 가지 프레임 워크 목록입니다. 먼저 문서를 읽고 관련 메일 링리스트 나 IRC 채널에 질문하십시오.</target>
        </trans-unit>
        <trans-unit id="1f47cec9db1010fb960d67042b7e30d1824cca4b" translate="yes" xml:space="preserve">
          <source>Below is a list of the files in the Unicode data base that Perl doesn't currently use, along with very brief descriptions of their purposes. Some of the names of the files have been shortened from those that Unicode uses, in order to allow them to be distinguishable from similarly named files on file systems for which only the first 8 characters of a name are significant.</source>
          <target state="translated">아래는 Perl이 현재 사용하지 않는 유니 코드 데이터베이스의 파일 목록과 그 목적에 대한 간단한 설명입니다. 파일 이름 중 일부는 이름의 처음 8 자만 중요한 파일 시스템에서 유사한 이름의 파일과 구별 될 수 있도록 유니 코드가 사용하는 이름에서 단축되었습니다.</target>
        </trans-unit>
        <trans-unit id="80905719173a37bfcc2cab267e8366cac44b82fa" translate="yes" xml:space="preserve">
          <source>Below is a list of the methods available.</source>
          <target state="translated">아래는 사용 가능한 방법 목록입니다.</target>
        </trans-unit>
        <trans-unit id="a5ddbb5a4ded78a58dd050a0a7bd8f09a53b44f8" translate="yes" xml:space="preserve">
          <source>Below is a list of the valid options:</source>
          <target state="translated">다음은 유효한 옵션 목록입니다.</target>
        </trans-unit>
        <trans-unit id="f51c6d51b727cf7e1f4d3849980abd064bedf568" translate="yes" xml:space="preserve">
          <source>Below is a mapping of what utilities will be used in what order for what schemes, if available:</source>
          <target state="translated">다음은 사용 가능한 유틸리티가 어떤 체계에 어떤 순서로 사용되는지에 대한 매핑입니다.</target>
        </trans-unit>
        <trans-unit id="beba98866f16c9dd2863b4a3ebd6b7ee815c3c45" translate="yes" xml:space="preserve">
          <source>Below is a possible implementation of a script to carry out the rename (error cases have been omitted)</source>
          <target state="translated">다음은 이름 변경을 수행 할 수있는 스크립트 구현입니다 (오류 사례는 생략 됨).</target>
        </trans-unit>
        <trans-unit id="58a01ebfbc11cd115ad51487cc4a5f70ba63da00" translate="yes" xml:space="preserve">
          <source>Below is a script which makes use of &lt;code&gt;gzreadline&lt;/code&gt; . It implements a very simple</source>
          <target state="translated">아래는 &lt;code&gt;gzreadline&lt;/code&gt; 을 사용하는 스크립트입니다 . 그것은 매우 간단한 구현</target>
        </trans-unit>
        <trans-unit id="7ffed42afdfaf25df4c7e5e8645b31ce92ca54e6" translate="yes" xml:space="preserve">
          <source>Below is a simple &quot;rename&quot; script that uses &lt;code&gt;globmap&lt;/code&gt; to determine the source and destination filenames.</source>
          <target state="translated">다음은 &lt;code&gt;globmap&lt;/code&gt; 을 사용하여 소스 및 대상 파일 이름을 결정 하는 간단한 &quot;이름 바꾸기&quot;스크립트입니다 .</target>
        </trans-unit>
        <trans-unit id="1ec37797cdff4399757b58637d8bd54b7066dfec" translate="yes" xml:space="preserve">
          <source>Below is an example module that makes use of the macros.</source>
          <target state="translated">아래는 매크로를 사용하는 예제 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="2be2899025a1fe4d200821c4ccbd79eabb3ab414" translate="yes" xml:space="preserve">
          <source>Below is an example program, &lt;code&gt;cpp_test&lt;/code&gt; , which makes use of this filter. Line numbers have been added to allow specific lines to be referenced easily.</source>
          <target state="translated">아래는 이 필터를 사용 하는 예제 프로그램 &lt;code&gt;cpp_test&lt;/code&gt; 입니다. 특정 라인을 쉽게 참조 할 수 있도록 라인 번호가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="4e2cc23005bf69f272f1f19d9851308543cafdff" translate="yes" xml:space="preserve">
          <source>Below is just one example, illustrating the control verb &lt;code&gt;(*FAIL)&lt;/code&gt; , which may be abbreviated as &lt;code&gt;(*F)&lt;/code&gt; . If this is inserted in a regexp it will cause it to fail, just as it would at some mismatch between the pattern and the string. Processing of the regexp continues as it would after any &quot;normal&quot; failure, so that, for instance, the next position in the string or another alternative will be tried. As failing to match doesn't preserve capture groups or produce results, it may be necessary to use this in combination with embedded code.</source>
          <target state="translated">아래는 제어 동사 &lt;code&gt;(*FAIL)&lt;/code&gt; 를 나타내는 한 가지 예일 뿐이며, &lt;code&gt;(*F)&lt;/code&gt; 로 약어로 표시 될 수 있습니다 . 이것이 정규 표현식에 삽입되면 패턴과 문자열이 일치하지 않는 것처럼 실패하게됩니다. 정규 표현식 처리는 &quot;정상적인&quot;실패 후에와 같이 계속 진행되므로 문자열의 다음 위치 또는 다른 대안이 시도됩니다. 일치하지 않으면 캡처 그룹이 보존되지 않거나 결과가 생성되지 않으므로이를 임베디드 코드와 함께 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="994ae30ab39b91782977e3601a4b1c5958c55b6d" translate="yes" xml:space="preserve">
          <source>Below is the sample of what to do to reproduce the configuration on my machine. In</source>
          <target state="translated">다음은 내 컴퓨터에서 구성을 재현하기 위해 수행 할 작업의 샘플입니다. 에</target>
        </trans-unit>
        <trans-unit id="8d0833a6280a2357c9ec993c9c38bf06fc8a81e8" translate="yes" xml:space="preserve">
          <source>Below is typical code that shows how to use &lt;code&gt;LimitOutput&lt;/code&gt; .</source>
          <target state="translated">아래는 &lt;code&gt;LimitOutput&lt;/code&gt; 사용 방법을 보여주는 일반적인 코드입니다 .</target>
        </trans-unit>
        <trans-unit id="4f28ac791ee08fb184476e4de12d634a0a1d7498" translate="yes" xml:space="preserve">
          <source>Ben Tilly</source>
          <target state="translated">벤 틸리</target>
        </trans-unit>
        <trans-unit id="9ed99e75a9b04f273de29c9fef2bd3fb53d2e2de" translate="yes" xml:space="preserve">
          <source>Benchmark</source>
          <target state="translated">Benchmark</target>
        </trans-unit>
        <trans-unit id="9a552526ddac8fc37648130a16d1381a6f9ad6fb" translate="yes" xml:space="preserve">
          <source>Benchmark - benchmark running times of Perl code</source>
          <target state="translated">벤치 마크-Perl 코드의 벤치 마크 실행 시간</target>
        </trans-unit>
        <trans-unit id="c6133998f601e0eb9b2fbe0a853d3f9116d43ce3" translate="yes" xml:space="preserve">
          <source>Benchmark Object</source>
          <target state="translated">벤치 마크 객체</target>
        </trans-unit>
        <trans-unit id="0ff60c3e395ce6dcfa9869e330a91fa3d0e1a335" translate="yes" xml:space="preserve">
          <source>Benchmark inherits from no other class, except of course from Exporter.</source>
          <target state="translated">벤치 마크는 Exporter의 과정을 제외하고 다른 클래스에서 상속받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bf40ff62878fab85612abb7b1055df933f606399" translate="yes" xml:space="preserve">
          <source>Benchmark running times of Perl code</source>
          <target state="translated">Perl 코드의 벤치 마크 실행 시간</target>
        </trans-unit>
        <trans-unit id="4b02607a2ea9a6953d07f941016201f155b468af" translate="yes" xml:space="preserve">
          <source>Benjamin Holzman contributed the tied variable support, Andrew Ford contributed the canonical order for hashes, and Gisle Aas fixed a few misunderstandings of mine regarding the perl internals, and optimized the emission of &quot;tags&quot; in the output streams by simply counting the objects instead of tagging them (leading to a binary incompatibility for the Storable image starting at version 0.6--older images are, of course, still properly understood). Murray Nesbitt made Storable thread-safe. Marc Lehmann added overloading and references to tied items support. Benjamin Holzman added a performance improvement for overloaded classes; thanks to Grant Street Group for footing the bill.</source>
          <target state="translated">벤자민 홀츠 만 (Benjamin Holzman)은 묶인 변수 지원에 기여했고, 앤드류 포드 (Andrew Ford)는 해시의 정식 순서에 기여했으며, Gisle Aas는 펄 내부와 관련하여 광산에 대한 오해를 수정했으며, 대신에 객체를 세는 것만으로 출력 스트림에서 &quot;태그&quot;의 방출을 최적화했습니다. 태그 지정 (버전 0.6부터 Storable 이미지의 이진 비 호환성으로 이어짐-이전 이미지는 여전히 올바르게 이해 됨). Murray Nesbitt는 Storable thread-safe를 만들었습니다. Marc Lehmann은 묶음 품목 지원에 대한 과부하 및 참조를 추가했습니다. Benjamin Holzman은 오버로드 된 클래스의 성능 향상을 추가했습니다. 이 법안을 발표 한 Grant Street Group에게 감사합니다.</target>
        </trans-unit>
        <trans-unit id="75fc540bc0a50aa81831bc474ec860350d0bca6e" translate="yes" xml:space="preserve">
          <source>Berkeley DB allows the creation of in-memory databases by using NULL (that is, a &lt;code&gt;(char *)0&lt;/code&gt; in C) in place of the filename. &lt;b&gt;DB_File&lt;/b&gt; uses &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; instead of NULL to provide this functionality.</source>
          <target state="translated">Berkeley DB는 파일 이름 대신 NULL (즉, C에서 &lt;code&gt;(char *)0&lt;/code&gt; ) 을 사용하여 인 메모리 데이터베이스를 만들 수 있습니다 . &lt;b&gt;DB_File&lt;/b&gt; 은 NULL 대신 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 사용 하여이 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9268b246582cb1f8cd7166d3bdd75afc5afe74a7" translate="yes" xml:space="preserve">
          <source>Berkeley DB is a C library which provides a consistent interface to a number of database formats. &lt;b&gt;DB_File&lt;/b&gt; provides an interface to all three of the database types currently supported by Berkeley DB.</source>
          <target state="translated">Berkeley DB는 여러 데이터베이스 형식에 대한 일관된 인터페이스를 제공하는 C 라이브러리입니다. &lt;b&gt;DB_File&lt;/b&gt; 은 현재 Berkeley DB에서 지원하는 세 가지 데이터베이스 유형 모두에 대한 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="434964490ac8a77af87035de9e77b760d4b578ea" translate="yes" xml:space="preserve">
          <source>Berkeley DB uses the function dbopen() to open or create a database. Here is the C prototype for dbopen():</source>
          <target state="translated">Berkeley DB는 dbopen () 함수를 사용하여 데이터베이스를 열거 나 만듭니다. dbopen ()의 C 프로토 타입은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cbcc04a4e53af70d968fb1854369b92c28068d53" translate="yes" xml:space="preserve">
          <source>BerkeleyDB is available for Cygwin.</source>
          <target state="translated">Cygwin에 BerkeleyDB를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="994ccae3d03329e5f7c9f11ecf6157dc38d89408" translate="yes" xml:space="preserve">
          <source>Beside import() and AUTOLOAD() there are only a few other methods.</source>
          <target state="translated">import () 및 AUTOLOAD () 외에도 몇 가지 다른 메소드 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cc3e4e79500c47fb5b02fd6bd36bb30830d4b93" translate="yes" xml:space="preserve">
          <source>Besides &lt;a href=&quot;#decode&quot;&gt;decode&lt;/a&gt; and &lt;a href=&quot;#encode&quot;&gt;encode&lt;/a&gt;, other methods are available as well. For instance, &lt;code&gt;name()&lt;/code&gt; returns the canonical name of the encoding object.</source>
          <target state="translated">&lt;a href=&quot;#decode&quot;&gt;디코드&lt;/a&gt; 및 &lt;a href=&quot;#encode&quot;&gt;인코딩&lt;/a&gt; 외에도 다른 방법도 사용할 수 있습니다. 예를 들어 &lt;code&gt;name()&lt;/code&gt; 은 인코딩 객체의 정식 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a7e42697322af6c9745acd371b634a7d3de7f9ce" translate="yes" xml:space="preserve">
          <source>Besides checking existing XS code, the script can also be used to retrieve compatibility information for various API calls using the &lt;code&gt;--api-info&lt;/code&gt; command line switch. For example:</source>
          <target state="translated">기존 XS 코드를 확인하는 것 외에도 &lt;code&gt;--api-info&lt;/code&gt; 명령 줄 스위치를 사용하여 스크립트를 사용하여 다양한 API 호출에 대한 호환성 정보를 검색 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="38c540b359fe4177c8733f2554f7c8aac1cf7755" translate="yes" xml:space="preserve">
          <source>Besides many other tests, it will test every locale it finds on your system to see if they conform to the POSIX standard. If any have errors, it will include a summary near the end of the output of which locales passed all its tests, and which failed, and why.</source>
          <target state="translated">다른 많은 테스트 외에도 시스템에서 찾은 모든 로캘을 테스트하여 POSIX 표준을 준수하는지 확인합니다. 오류가있는 경우 모든 로케일이 모든 테스트를 통과 한 출력의 끝에 거의 실패한 이유와 이유에 대한 요약이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="eaf1b9544c43d438f9e6f77acb1ab9f9247ce8b8" translate="yes" xml:space="preserve">
          <source>Besides putting the cross-compiler and the rest of the toolchain in your PATH, this will also provide the QNX_TARGET variable, which we will pass to Configure through -Dsysroot.</source>
          <target state="translated">크로스 컴파일러와 나머지 툴체인을 PATH에 넣는 것 외에도 -Dsysroot를 통해 Configure로 전달할 QNX_TARGET 변수도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8731a27dfb4cb7bb97f8e5e387722a8377af9b68" translate="yes" xml:space="preserve">
          <source>Besides saving these hashes as the hashref attributes &lt;code&gt;name2path&lt;/code&gt; and &lt;code&gt;path2name&lt;/code&gt; , calling this function also returns these hashrefs. In list context, the return value of &lt;code&gt;$search-&amp;gt;survey&lt;/code&gt; is the list &lt;code&gt;(\%name2path, \%path2name)&lt;/code&gt; . In scalar context, the return value is &lt;code&gt;\%name2path&lt;/code&gt; . Or you can just call this in void context.</source>
          <target state="translated">이 해시를 hashref 속성 &lt;code&gt;name2path&lt;/code&gt; 및 &lt;code&gt;path2name&lt;/code&gt; 으로 저장하는 것 외에도이 함수를 호출하면 이러한 해시 참조 도 반환됩니다. 목록 컨텍스트에서 &lt;code&gt;$search-&amp;gt;survey&lt;/code&gt; 의 리턴 값은 목록 &lt;code&gt;(\%name2path, \%path2name)&lt;/code&gt; 입니다. 스칼라 컨텍스트에서 리턴 값은 &lt;code&gt;\%name2path&lt;/code&gt; 입니다. 또는 void 컨텍스트에서 이것을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d17cf41d34eb6f4b37b1b9cc872817585f3b1ca4" translate="yes" xml:space="preserve">
          <source>Besides the &lt;code&gt;$|&lt;/code&gt; special variable, you can use &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; to give your filehandle a &lt;code&gt;:unix&lt;/code&gt; layer, which is unbuffered:</source>
          <target state="translated">게다가 &lt;code&gt;$|&lt;/code&gt; 특수 변수, &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 를 사용하여 파일 핸들에 버퍼링되지 않은 : &lt;code&gt;:unix&lt;/code&gt; 레이어 를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c874def12573a04b6982ff2c45bf57742f038615" translate="yes" xml:space="preserve">
          <source>Besides the NBSP character discussed above, implementors are reminded of the existence of the other &quot;special&quot; character in Latin-1, the &quot;soft hyphen&quot; character, also known as &quot;discretionary hyphen&quot;, i.e. &lt;code&gt;E&amp;lt;173&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;0xAD&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;shy&amp;gt;&lt;/code&gt; ). This character expresses an optional hyphenation point. That is, it normally renders as nothing, but may render as a &quot;-&quot; if a formatter breaks the word at that point. Pod formatters should, as appropriate, do one of the following: 1) render this with a code with the same meaning (e.g., &quot;\-&quot; in RTF), 2) pass it through in the expectation that the formatter understands this character as such, or 3) delete it.</source>
          <target state="translated">위에서 논의한 NBSP 문자 외에도, 구현 자들은 라틴어 -1에서 &quot; &lt;code&gt;E&amp;lt;0xAD&amp;gt;&lt;/code&gt; 하이픈&quot;문자로 알려진 &quot;소프트 하이픈&quot;문자, 즉 &lt;code&gt;E&amp;lt;173&amp;gt;&lt;/code&gt; = E &amp;lt;0xAD&amp;gt;에 다른 &quot;특수&quot;문자가 있음을 상기 시킵니다 = &lt;code&gt;E&amp;lt;shy&amp;gt;&lt;/code&gt; ). 이 문자는 선택적인 하이픈 포인트를 나타냅니다. 즉, 일반적으로 아무것도 렌더링하지 않지만 포맷터가 해당 지점에서 단어를 분리하면 &quot;-&quot;로 렌더링 될 수 있습니다. 포드 포맷터는 적절하게 다음 중 하나를 수행해야합니다. 1) 동일한 의미를 가진 코드 (예 : RTF에서 &quot;\-&quot;)로 코드를 렌더링합니다. 2) 포맷터가이 문자를 다음과 같이 이해한다고 기대합니다. 또는 3) 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="383f64e6a803d40e90542694df252e926486880e" translate="yes" xml:space="preserve">
          <source>Besides the normal array index looping, &lt;code&gt;for&lt;/code&gt; can lend itself to many other interesting applications. Here's one that avoids the problem you get into if you explicitly test for end-of-file on an interactive file descriptor causing your program to appear to hang.</source>
          <target state="translated">일반 배열 인덱스 루핑 외에도 &lt;code&gt;for&lt;/code&gt; 는 다른 많은 흥미로운 응용 프로그램에 적합합니다. 다음은 대화식 파일 설명자에서 파일 끝을 명시 적으로 테스트하여 프로그램이 중단 된 것처럼 보이는 경우 발생하는 문제를 피하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="b788aba9c107e5a4eaba0767ff3be57caf43c88d" translate="yes" xml:space="preserve">
          <source>Besides the obvious documents, source code can be instructive. Some pathological examples of the use of references can be found in the</source>
          <target state="translated">명백한 문서 외에도 소스 코드가 도움이 될 수 있습니다. 참고 문헌 사용에 대한 병리학 적 예는</target>
        </trans-unit>
        <trans-unit id="3cd8fe6552552b50530c70ff871d9df229c4d203" translate="yes" xml:space="preserve">
          <source>Besides the obvious pod conversions, Pod::Man also takes care of formatting func(), func(3), and simple variable references like $foo or @bar so you don't have to use code escapes for them; complex expressions like &lt;code&gt;$fred{'stuff'}&lt;/code&gt; will still need to be escaped, though. It also translates dashes that aren't used as hyphens into en dashes, makes long dashes--like this--into proper em dashes, fixes &quot;paired quotes,&quot; makes C++ look right, puts a little space between double underscores, makes ALLCAPS a teeny bit smaller in &lt;b&gt;troff&lt;/b&gt;, and escapes stuff that *roff treats as special so that you don't have to.</source>
          <target state="translated">Pod :: Man은 명백한 포드 변환 외에도 func (), func (3) 및 $ foo 또는 @bar와 같은 간단한 변수 참조의 형식을 지정하므로 코드 이스케이프를 사용할 필요가 없습니다. 그러나 &lt;code&gt;$fred{'stuff'}&lt;/code&gt; 와 같은 복잡한 표현 은 여전히 ​​탈출해야합니다. 또한 하이픈으로 사용되지 않는 대시를 대시로 변환하고, 이와 같이 긴 대시를 만듭니다. 적절한 em 대시로, &quot;페어링 된 따옴표&quot;를 수정하고, C ++을 올바르게 보이게하고, 이중 밑줄 사이에 약간의 공백을두고 ALLCAPS를 만듭니다. &lt;b&gt;troff&lt;/b&gt; 의 작은 비트 이며 * roff가 특별한 것으로 취급하지 않는 것을 피합니다.</target>
        </trans-unit>
        <trans-unit id="a063aa374e8d2e7cef3baa1877fd812efaeadbc4" translate="yes" xml:space="preserve">
          <source>Besides the obvious pod conversions, Pod::Man, and therefore pod2man also takes care of formatting func(), func(n), and simple variable references like $foo or @bar so you don't have to use code escapes for them; complex expressions like &lt;code&gt;$fred{'stuff'}&lt;/code&gt; will still need to be escaped, though. It also translates dashes that aren't used as hyphens into en dashes, makes long dashes--like this--into proper em dashes, fixes &quot;paired quotes,&quot; and takes care of several other troff-specific tweaks. See &lt;a href=&quot;pod/man&quot;&gt;Pod::Man&lt;/a&gt; for complete information.</source>
          <target state="translated">Pod :: Man이라는 명확한 포드 변환 외에도 pod2man은 func (), func (n) 및 $ foo 또는 @bar와 같은 간단한 변수 참조의 형식을 지정하므로 코드 이스케이프를 사용할 필요가 없습니다. ; 그러나 &lt;code&gt;$fred{'stuff'}&lt;/code&gt; 와 같은 복잡한 표현 은 여전히 ​​탈출해야합니다. 또한 하이픈으로 사용되지 않는 대시를 대시로 변환하고, 이와 같이 긴 대시를 적절한 em 대시로 만들고, &quot;페어링 된 따옴표&quot;를 수정하고, 다른 몇 가지 troff 특정 조정을 처리합니다. 자세한 내용은 &lt;a href=&quot;pod/man&quot;&gt;Pod :: Man&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2b7e5467e3e0ec9a6b2fff1ef3ee081c7b986017" translate="yes" xml:space="preserve">
          <source>Besides the well-known &quot;E&amp;lt;lt&amp;gt;&quot; and &quot;E&amp;lt;gt&amp;gt;&quot; codes for less-than and greater-than, Pod parsers must understand &quot;E&amp;lt;sol&amp;gt;&quot; for &quot;/&quot; (solidus, slash), and &quot;E&amp;lt;verbar&amp;gt;&quot; for &quot;|&quot; (vertical bar, pipe). Pod parsers should also understand &quot;E&amp;lt;lchevron&amp;gt;&quot; and &quot;E&amp;lt;rchevron&amp;gt;&quot; as legacy codes for characters 171 and 187, i.e., &quot;left-pointing double angle quotation mark&quot; = &quot;left pointing guillemet&quot; and &quot;right-pointing double angle quotation mark&quot; = &quot;right pointing guillemet&quot;. (These look like little &quot;&amp;lt;&amp;lt;&quot; and &quot;&amp;gt;&amp;gt;&quot;, and they are now preferably expressed with the HTML/XHTML codes &quot;E&amp;lt;laquo&amp;gt;&quot; and &quot;E&amp;lt;raquo&amp;gt;&quot;.)</source>
          <target state="translated">포드 파서는 잘 알려진 &quot;E &amp;lt;&quot;및 &quot;E&quot;코드 외에 &quot;/&quot;(고체, 슬래시) 및 &quot;&quot;에 대한 &quot;E &amp;lt;sol&amp;gt;&quot;을 이해해야합니다. &quot;|&quot;에 대한 E &amp;lt;verbar&amp;gt; &quot; (세로 막대, 파이프). 포드 파서는 또한 &quot;E &amp;lt;lchevron&amp;gt;&quot;및 &quot;E &amp;lt;rchevron&amp;gt;&quot;을 문자 171 및 187의 레거시 코드로 이해해야합니다. 각도 인용 부호 &quot;=&quot;오른쪽 포인팅 길레 &quot;. (이들은 &quot;&amp;lt;&amp;lt;&quot;및 &quot;&amp;gt;&amp;gt;&quot;처럼 보이지 않으며, 이제 HTML / XHTML 코드 &quot;E &amp;lt;laquo&amp;gt;&quot;및 &quot;E &amp;lt;raquo&amp;gt;&quot;로 표시되는 것이 바람직합니다.)</target>
        </trans-unit>
        <trans-unit id="5b2158802b148a274c615dff49ad8ceaf2fe4a86" translate="yes" xml:space="preserve">
          <source>Besides these, all the Unicode character properties mentioned above (except for those marked as for internal use by Perl) are also accessible by &lt;a href=&quot;unicode/ucd#prop_invlist()&quot;&gt;prop_invlist() in Unicode::UCD&lt;/a&gt;.</source>
          <target state="translated">이 외에도 위에서 언급 한 모든 유니 코드 문자 속성 (Perl에서 내부 용으로 표시된 속성 제외 &lt;a href=&quot;unicode/ucd#prop_invlist()&quot;&gt;)은 Unicode :: UCD의 prop_invlist ()를&lt;/a&gt; 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="708a3f784c168edb7cbbe1a181dbe5bffd40a3cc" translate="yes" xml:space="preserve">
          <source>Besides whole phrases meant for output, anything language-dependent should be put into the class Projname::L10N::en_us, whether as methods, or as lexicon entries -- this is discussed in the section &quot;Entries in Each Lexicon&quot;, above.</source>
          <target state="translated">출력에 사용되는 전체 문구 외에도 언어에 따라 달라지는 것은 메소드 또는 어휘 항목으로 Projname :: L10N :: en_us 클래스에 넣어야합니다. 위의 &quot;각 어휘집에있는 항목&quot;섹션에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="cd7916b96afe381cf04fb2aeca341eed5cca3a69" translate="yes" xml:space="preserve">
          <source>Best practices for making a new module.</source>
          <target state="translated">새 모듈을 만들기위한 모범 사례.</target>
        </trans-unit>
        <trans-unit id="5f9760622e022594213ec306985fb05bd7325740" translate="yes" xml:space="preserve">
          <source>Between Mac OS X 10.3 &quot;Panther&quot; and 10.6 &quot;Snow Leopard&quot;, the 'Command Line Tools' bundle was called 'unix tools', and was usually supplied with Mac OS install DVDs.</source>
          <target state="translated">Mac OS X 10.3 &quot;Panther&quot;와 10.6 &quot;Snow Leopard&quot;사이에서 'Command Line Tools'번들은 'unix tools'라고하며 일반적으로 Mac OS 설치 DVD와 함께 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="6249e6fb239ee6aed11ccf460f154f4ff6f24738" translate="yes" xml:space="preserve">
          <source>Between the &lt;code&gt;%&lt;/code&gt; and the format letter, you may specify several additional attributes controlling the interpretation of the format. In order, these are:</source>
          <target state="translated">&lt;code&gt;%&lt;/code&gt; 와 형식 문자 사이에서 형식 해석을 제어하는 ​​몇 가지 추가 속성을 지정할 수 있습니다. 순서대로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b8011f36b2088bc97398915695cf8abfb01b5b1d" translate="yes" xml:space="preserve">
          <source>Beware also of the order of more complicated expressions like:</source>
          <target state="translated">다음과 같은 복잡한 표현 순서도주의하십시오.</target>
        </trans-unit>
        <trans-unit id="6c100dc724a3253ddc31a97cdb43e9fdb264b604" translate="yes" xml:space="preserve">
          <source>Beware of simple &quot;casting&quot; the entire expression, this would only convert the already computed result:</source>
          <target state="translated">전체 표현식을 단순하게 &quot;캐스팅&quot;한다는 점에주의하십시오. 이렇게하면 이미 계산 된 결과 만 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="c8bc77265aea976e7b646f3af43c05662f7e17da" translate="yes" xml:space="preserve">
          <source>Beware of:</source>
          <target state="translated">주의 사항 :</target>
        </trans-unit>
        <trans-unit id="6bac55531c21ad380bc95de89addf1faea92b643" translate="yes" xml:space="preserve">
          <source>Beware that if you put literal backslashes (those not inside interpolated variables) between &lt;code&gt;\Q&lt;/code&gt; and &lt;code&gt;\E&lt;/code&gt; , double-quotish backslash interpolation may lead to confusing results. If you</source>
          <target state="translated">&lt;code&gt;\Q&lt;/code&gt; 와 &lt;code&gt;\E&lt;/code&gt; 사이에 리터럴 백 슬래시 (보간 된 변수가 아닌)를 넣으면 큰 따옴표 백 슬래시 보간으로 인해 결과가 혼동 될 수 있습니다. 만약 너라면</target>
        </trans-unit>
        <trans-unit id="6ca66f864461fdc36869edeb4abd6935993616b0" translate="yes" xml:space="preserve">
          <source>Beware that some command shells may place restrictions on the length of the command line. You must ensure your strings don't exceed this limit after any necessary interpolations. See the platform-specific release notes for more details about your particular environment.</source>
          <target state="translated">일부 명령 셸은 명령 줄 길이에 제한을 둘 수 있습니다. 필요한 보간 후 문자열이이 제한을 초과하지 않아야합니다. 특정 환경에 대한 자세한 내용은 플랫폼 별 릴리스 노트를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1bd1204f447158c3ff1bfbe82d9a707a81d4fa56" translate="yes" xml:space="preserve">
          <source>Beware that unlike &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; doesn't take a pattern as its first argument. Compare &lt;a href=&quot;#split&quot;&gt;split&lt;/a&gt;.</source>
          <target state="translated">그와는 달리 조심 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 의 첫 번째 인수로 패턴을 고려하지 않습니다. &lt;a href=&quot;#split&quot;&gt;split&lt;/a&gt; 비교하십시오 .</target>
        </trans-unit>
        <trans-unit id="bc2144e8f71ac4bf9140995eea7dc924e6bdda59" translate="yes" xml:space="preserve">
          <source>Beware that unlike &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; doesn't take a pattern as its first argument. Compare &lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;.</source>
          <target state="translated">그와는 달리 조심 &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 의 첫 번째 인수로 패턴을 고려하지 않습니다. &lt;a href=&quot;split&quot;&gt;split&lt;/a&gt; 비교하십시오 .</target>
        </trans-unit>
        <trans-unit id="c39aa460c8cfb8c3295132732d48ee06e763b200" translate="yes" xml:space="preserve">
          <source>Beware: This feature is not fully implemented yet.</source>
          <target state="translated">주의 :이 기능은 아직 완전히 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="d3f2ff6e4b3a254c248f8c186f3f0868a1b1e7b1" translate="yes" xml:space="preserve">
          <source>Beware: This list is not complete.</source>
          <target state="translated">주의 :이 목록은 완전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="85c248dc6ba19bfc8397a2d612c997c46ad24985" translate="yes" xml:space="preserve">
          <source>Beware: after this function returns, &lt;code&gt;ptr&lt;/code&gt; and SvPVX_const(sv) may no longer refer to the same chunk of data.</source>
          <target state="translated">주의 :이 함수가 반환 된 후 &lt;code&gt;ptr&lt;/code&gt; 과 SvPVX_const (sv)는 더 이상 동일한 데이터 청크를 참조하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40ca4e03748bbc6d9d8fdf7c985dd464c29b4a02" translate="yes" xml:space="preserve">
          <source>Beyond Unicode code points</source>
          <target state="translated">유니 코드 코드 포인트를 넘어</target>
        </trans-unit>
        <trans-unit id="8d2086dee2d46aa5a491374a05ac5325e10530d7" translate="yes" xml:space="preserve">
          <source>Beyond make test</source>
          <target state="translated">테스트를 넘어</target>
        </trans-unit>
        <trans-unit id="7071855c582934ec0ec68ba51cead15591289a64" translate="yes" xml:space="preserve">
          <source>Beyond that help, the urllist config parameter is yours. You can add and remove sites at will. You should find out which sites have the best up-to-dateness, bandwidth, reliability, etc. and are topologically close to you. Some people prefer fast downloads, others up-to-dateness, others reliability. You decide which to try in which order.</source>
          <target state="translated">그 도움 외에도 urllist config 매개 변수는 귀하의 것입니다. 당신은 자유롭게 사이트를 추가하고 제거 할 수 있습니다. 최신 사이트, 대역폭, 안정성 등을 보유하고 있으며 가장 가까운 사이트를 찾아야합니다. 어떤 사람들은 빠른 다운로드를 선호하고 다른 사람들은 최신 다운로드, 다른 사람들은 안정성을 선호합니다. 어떤 순서로 시도할지 결정합니다.</target>
        </trans-unit>
        <trans-unit id="3f05839b089d755d215e2ff3af4aafe1ec68679d" translate="yes" xml:space="preserve">
          <source>Beyond that, the simplest debugger is the &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; function. Use it to look at values as you run your program:</source>
          <target state="translated">그 외에도 가장 간단한 디버거는 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 기능입니다. 프로그램을 실행할 때이 값을 사용하여 값을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="3981fa65dd4a5a67077c84cbcab0e6d7e62ef4b1" translate="yes" xml:space="preserve">
          <source>Beyond that, you have to consider several things and decide which is best for you.</source>
          <target state="translated">그 외에도 몇 가지 사항을 고려하여 가장 적합한 것을 결정해야합니다.</target>
        </trans-unit>
        <trans-unit id="44d69eda49b459248ce90b6917e4f918be54d8d4" translate="yes" xml:space="preserve">
          <source>Beyond the normal measures described to make general Perl programs faster or smaller, a CGI program has additional issues. It may be run several times per second. Given that each time it runs it will need to be re-compiled and will often allocate a megabyte or more of system memory, this can be a killer. Compiling into C &lt;b&gt;isn't going to help you&lt;/b&gt; because the process start-up overhead is where the bottleneck is.</source>
          <target state="translated">일반적인 Perl 프로그램을 더 빠르거나 작게 만드는 일반적인 방법 외에도 CGI 프로그램에는 추가 문제가 있습니다. 초당 여러 번 실행될 수 있습니다. 실행될 때마다 다시 컴파일해야하고 종종 메가 바이트 이상의 시스템 메모리를 할당해야하므로 이는 킬러가 될 수 있습니다. 프로세스 시작 오버 헤드가 병목 현상이 발생하기 때문에 C로 컴파일 &lt;b&gt;해도 도움이되지 않습니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="213d672c8ec1c5c132adb8f810eb6a5d6ae1c84f" translate="yes" xml:space="preserve">
          <source>Beyond the obvious problems that stem from giving special privileges to systems as flexible as scripts, on many versions of Unix, set-id scripts are inherently insecure right from the start. The problem is a race condition in the kernel. Between the time the kernel opens the file to see which interpreter to run and when the (now-set-id) interpreter turns around and reopens the file to interpret it, the file in question may have changed, especially if you have symbolic links on your system.</source>
          <target state="translated">많은 버전의 Unix 버전에서 스크립트처럼 유연한 시스템에 특별한 권한을 부여하는 데 따른 명백한 문제 외에도 set-id 스크립트는 처음부터 안전하지 않습니다. 문제는 커널의 경쟁 조건입니다. 커널이 파일을 열어 어떤 인터프리터를 실행할지와 (현재 set-id) 인터프리터가 돌아와서 파일을 해석하기 위해 파일을 다시 열 때 사이에, 특히 기호 링크가있는 경우 해당 파일이 변경되었을 수 있습니다 당신의 시스템.</target>
        </trans-unit>
        <trans-unit id="619d65e1ae1a2704aa306451ac2a75a0cde345a8" translate="yes" xml:space="preserve">
          <source>Bibliography</source>
          <target state="translated">Bibliography</target>
        </trans-unit>
        <trans-unit id="b4412d2ae1aa691608b316e9ad2227f4c8f05c5f" translate="yes" xml:space="preserve">
          <source>Bidirectional Communication with Another Process</source>
          <target state="translated">다른 프로세스와의 양방향 통신</target>
        </trans-unit>
        <trans-unit id="20453df9f611f7ce81199fe2171f3b15f7db6ba1" translate="yes" xml:space="preserve">
          <source>Bidirectional Communication with Yourself</source>
          <target state="translated">자신과의 양방향 커뮤니케이션</target>
        </trans-unit>
        <trans-unit id="aaec1a206ed8540735d6653165ead4690d690a5c" translate="yes" xml:space="preserve">
          <source>BigInt's bcmp() routine currently returns undef to signal that a NaN was involved in a comparison. However, the overload code turns that into either 1 or '' and thus operations like &lt;code&gt;NaN != NaN&lt;/code&gt; might return wrong values.</source>
          <target state="translated">BigInt의 bcmp () 루틴은 현재 NaN이 비교에 관여했음을 알리기 위해 undef를 리턴합니다. 그러나 과부하 코드는이를 1 또는 ''로 바꾸므로 &lt;code&gt;NaN != NaN&lt;/code&gt; 과 같은 연산은 잘못된 값을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b68a65a4af953b7e6ff32f4e519ad10e0c7af47b" translate="yes" xml:space="preserve">
          <source>Bigger Numbers</source>
          <target state="translated">더 큰 숫자</target>
        </trans-unit>
        <trans-unit id="98032da695f3e799620752e98882e414e0196f49" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;!=&quot;&lt;/code&gt; returns true if the left argument is numerically not equal to the right argument.</source>
          <target state="translated">이항 &lt;code&gt;&quot;!=&quot;&lt;/code&gt; 은 왼쪽 인수가 오른쪽 인수와 숫자가 같지 않으면 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0806ad998452d5851f139bbe3f01d7066c39cefd" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;!~&quot;&lt;/code&gt; is just like &lt;code&gt;&quot;=~&quot;&lt;/code&gt; except the return value is negated in the logical sense.</source>
          <target state="translated">이진수 &lt;code&gt;&quot;!~&quot;&lt;/code&gt; 는 논리적 인 의미에서 반환 값이 무시된다는 점을 제외하고는 &lt;code&gt;&quot;=~&quot;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="958b8a1169468f4a63917c7ca8496d2c631c8da0" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;!~&quot;&lt;/code&gt; with a non-destructive substitution (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt;) or transliteration (&lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///r&lt;/a&gt;&lt;/code&gt;) is a syntax error.</source>
          <target state="translated">비파괴 대체 ( &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; ) 또는 음역 ( &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///r&lt;/a&gt;&lt;/code&gt; )이있는 이진 &lt;code&gt;&quot;!~&quot;&lt;/code&gt; 는 구문 오류입니다.</target>
        </trans-unit>
        <trans-unit id="f26c16627064dbaf94b2accf763da8c7ea571aa3" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;%&quot;&lt;/code&gt; is the modulo operator, which computes the division remainder of its first argument with respect to its second argument. Given integer operands &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt; : If &lt;code&gt;$n&lt;/code&gt; is positive, then &lt;code&gt;$m % $n&lt;/code&gt; is &lt;code&gt;$m&lt;/code&gt; minus the largest multiple of &lt;code&gt;$n&lt;/code&gt; less than or equal to &lt;code&gt;$m&lt;/code&gt; . If &lt;code&gt;$n&lt;/code&gt; is negative, then &lt;code&gt;$m % $n&lt;/code&gt; is &lt;code&gt;$m&lt;/code&gt; minus the smallest multiple of &lt;code&gt;$n&lt;/code&gt; that is not less than &lt;code&gt;$m&lt;/code&gt; (that is, the result will be less than or equal to zero). If the operands &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt; are floating point values and the absolute value of &lt;code&gt;$n&lt;/code&gt; (that is &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs($n)&lt;/a&gt;&lt;/code&gt;) is less than &lt;code&gt;(UV_MAX + 1)&lt;/code&gt; , only the integer portion of &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt; will be used in the operation (Note: here &lt;code&gt;UV_MAX&lt;/code&gt; means the maximum of the unsigned integer type). If the absolute value of the right operand (&lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs($n)&lt;/a&gt;&lt;/code&gt;) is greater than or equal to &lt;code&gt;(UV_MAX + 1)&lt;/code&gt; , &lt;code&gt;&quot;%&quot;&lt;/code&gt; computes the floating-point remainder &lt;code&gt;$r&lt;/code&gt; in the equation &lt;code&gt;($r = $m - $i*$n)&lt;/code&gt; where &lt;code&gt;$i&lt;/code&gt; is a certain integer that makes &lt;code&gt;$r&lt;/code&gt; have the same sign as the right operand &lt;code&gt;$n&lt;/code&gt; (&lt;b&gt;not&lt;/b&gt; as the left operand &lt;code&gt;$m&lt;/code&gt; like C function &lt;code&gt;fmod()&lt;/code&gt; ) and the absolute value less than that of &lt;code&gt;$n&lt;/code&gt; . Note that when &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; is in scope, &lt;code&gt;&quot;%&quot;&lt;/code&gt; gives you direct access to the modulo operator as implemented by your C compiler. This operator is not as well defined for negative operands, but it will execute faster.</source>
          <target state="translated">이항 &lt;code&gt;&quot;%&quot;&lt;/code&gt; 는 모듈로 연산자로, 두 번째 인수와 관련하여 첫 번째 인수의 나머지를 계산합니다. 정수 피연산자 감안 &lt;code&gt;$m&lt;/code&gt; 과 &lt;code&gt;$n&lt;/code&gt; : 만약 &lt;code&gt;$n&lt;/code&gt; 이어서, 긍정적 인 &lt;code&gt;$m % $n&lt;/code&gt; 인 &lt;code&gt;$m&lt;/code&gt; 마이너스의 최대 다중 &lt;code&gt;$n&lt;/code&gt; 보다 작거나 같 &lt;code&gt;$m&lt;/code&gt; . 경우 &lt;code&gt;$n&lt;/code&gt; 이어서, 부정적 &lt;code&gt;$m % $n&lt;/code&gt; 인 &lt;code&gt;$m&lt;/code&gt; 마이너스의 작은 복수 &lt;code&gt;$n&lt;/code&gt; 이상인 &lt;code&gt;$m&lt;/code&gt; (즉, 그 결과는보다 적은 수 또는 제로와 동일 함). 피연산자가 &lt;code&gt;$m&lt;/code&gt; 및 &lt;code&gt;$n&lt;/code&gt; 부동 소수점 값이고 &lt;code&gt;$n&lt;/code&gt; 의 절대 값 ( &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs($n)&lt;/a&gt;&lt;/code&gt; )이 &lt;code&gt;(UV_MAX + 1)&lt;/code&gt; 보다 작 으면 &lt;code&gt;$m&lt;/code&gt; 및 &lt;code&gt;$n&lt;/code&gt; 의 정수 부분 만 조작에 사용됩니다 (참고 : &lt;code&gt;UV_MAX&lt;/code&gt; 부호없는 정수 유형의 최대 값을 의미합니다). 오른쪽 피연산자 (의 절대치 경우 &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs($n)&lt;/a&gt;&lt;/code&gt; )보다 크거나 동일한 &lt;code&gt;(UV_MAX + 1)&lt;/code&gt; , &lt;code&gt;&quot;%&quot;&lt;/code&gt; 는 부동 소수점 나머지 계산 &lt;code&gt;$r&lt;/code&gt; 식에서 &lt;code&gt;($r = $m - $i*$n)&lt;/code&gt; 여기서 &lt;code&gt;$i&lt;/code&gt; 는 &lt;code&gt;$r&lt;/code&gt; 을 오른쪽 피연산자와 같은 부호로 만드는 특정 정수입니다. &lt;code&gt;$n&lt;/code&gt; ( &lt;b&gt;되지&lt;/b&gt; 왼쪽 피연산자 &lt;code&gt;$m&lt;/code&gt; C 함수 등 &lt;code&gt;fmod()&lt;/code&gt; ) 이하보다 절대 값 &lt;code&gt;$n&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 이 범위에 있을 때 &lt;code&gt;&quot;%&quot;&lt;/code&gt; 는 C 컴파일러에 의해 구현 된대로 모듈로 연산자에 직접 액세스 할 수있게합니다. 이 연산자는 음의 피연산자에 대해 잘 정의되어 있지 않지만 더 빠르게 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="68ed9e30d3d6543dd0a9f75b291cbc79357b65a9" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; returns its operands ANDed together bit by bit. Although no warning is currently raised, the result is not well defined when this operation is performed on operands that aren't either numbers (see &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;) nor bitstrings (see &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Bitwise String Operators&lt;/a&gt;).</source>
          <target state="translated">이항 &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; 는 피연산자 AND를 비트 단위로 함께 반환합니다. 현재 경고가 발생하지 않지만이 연산이 숫자 ( &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;정수 산술&lt;/a&gt; 참조 ) 또는 비트 열 ( &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;비트 문자열 연산자&lt;/a&gt; 참조) 이 아닌 피연산자에서 수행 될 때 결과가 제대로 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c0937405123294a033856c6fea7344af89470f86" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;amp;&amp;amp;&quot;&lt;/code&gt; performs a short-circuit logical AND operation. That is, if the left operand is false, the right operand is not even evaluated. Scalar or list context propagates down to the right operand if it is evaluated.</source>
          <target state="translated">이항 &lt;code&gt;&quot;&amp;amp;&amp;amp;&quot;&lt;/code&gt; 는 단락 논리 AND 연산을 수행합니다. 즉, 왼쪽 피연산자가 false이면 오른쪽 피연산자도 평가되지 않습니다. 스칼라 또는 목록 컨텍스트가 평가되면 오른쪽 피연산자로 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="1f3f00bc4d3f1107e73b1aeb90803d21d2f7f5a5" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; returns true if the left argument is numerically greater than the right argument.</source>
          <target state="translated">왼쪽 인수가 숫자보다 오른쪽 인수보다 큰 경우 이진수 &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; 는 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6a8e5f64ce960724d668657e4a1ad5261d933577" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; returns the value of its left argument shifted right by the number of bits specified by the right argument. Arguments should be integers. (See also &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;.)</source>
          <target state="translated">이진수 &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; 는 오른쪽 인수에 의해 지정된 비트 수만큼 오른쪽으로 시프트 된 왼쪽 인수의 값을 반환합니다. 인수는 정수 여야합니다. ( &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;정수 산술&lt;/a&gt; 참조 )</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
