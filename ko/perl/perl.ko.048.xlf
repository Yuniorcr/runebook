<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="261136bd75aafd5cdd3130fb700c6549b50d82b1" translate="yes" xml:space="preserve">
          <source>Usage might be something like:</source>
          <target state="translated">사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1d4d43cc6f3a833e0340a0d1794b6d7b9958657e" translate="yes" xml:space="preserve">
          <source>Use</source>
          <target state="translated">Use</target>
        </trans-unit>
        <trans-unit id="82df0013720cd7586b2bc95bd024b2fab925070f" translate="yes" xml:space="preserve">
          <source>Use &quot;opaque&quot; data type for the C types matched by the regular expression, even if these types are &lt;code&gt;typedef&lt;/code&gt; -equivalent to types from typemaps. Should not be used without &lt;b&gt;-x&lt;/b&gt;.</source>
          <target state="translated">정규식과 일치하는 C 유형에 대해 &quot;불투명&quot;데이터 유형을 사용하십시오. 이러한 유형이 &lt;code&gt;typedef&lt;/code&gt; 인 경우에도 유형 맵의 유형과 같습니다. &lt;b&gt;-x&lt;/b&gt; 없이 사용하면 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="3c21be167d639b35ddaa57a08912b97d5e9dff41" translate="yes" xml:space="preserve">
          <source>Use &quot;tie&quot; to open the database.</source>
          <target state="translated">&quot;tie&quot;를 사용하여 데이터베이스를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="4c6d07e8046e85c144f5081da5bd8baf9030e3a5" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://search.cpan.org/perldoc/HTML::Strip&quot;&gt;HTML::Strip&lt;/a&gt;, or &lt;a href=&quot;http://search.cpan.org/perldoc/HTML::FormatText&quot;&gt;HTML::FormatText&lt;/a&gt; which not only removes HTML but also attempts to do a little simple formatting of the resulting plain text.</source>
          <target state="translated">사용 &lt;a href=&quot;http://search.cpan.org/perldoc/HTML::Strip&quot;&gt;HTML :: 스트립&lt;/a&gt; , 또는 &lt;a href=&quot;http://search.cpan.org/perldoc/HTML::FormatText&quot;&gt;HTML :: FormatText&lt;/a&gt; HTML뿐만 아니라 결과 일반 텍스트의 서식 약간의 간단한 작업을 수행하는 시도 제거뿐만 아니라있다.</target>
        </trans-unit>
        <trans-unit id="a5b53467807b9027de0ba1ae32437de79640c9fd" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;text/wrap&quot;&gt;Text::Wrap&lt;/a&gt; (part of the standard Perl distribution):</source>
          <target state="translated">&lt;a href=&quot;text/wrap&quot;&gt;Text :: Wrap&lt;/a&gt; (표준 Perl 배포의 일부)을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="87276cc5955780242b6240d9ad22eaa36930d92c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;:alias&lt;/code&gt; to give your own lexically scoped nicknames to existing characters, or even to give unnamed private-use characters useful names.</source>
          <target state="translated">&lt;code&gt;:alias&lt;/code&gt; 를 사용 하여 기존 문자에 고유 한 어휘 범위 별명을 지정하거나 이름이없는 개인용 문자에 유용한 이름을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="fdf71fcf7dcb9c3fbc3fc7c52735a70671018192" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;:encoding(ENCODING)&lt;/code&gt; either in open() or binmode() to install a layer that transparently does character set and encoding transformations, for example from Shift-JIS to Unicode. Note that under &lt;code&gt;stdio&lt;/code&gt; an &lt;code&gt;:encoding&lt;/code&gt; also enables &lt;code&gt;:utf8&lt;/code&gt; . See &lt;a href=&quot;perlio/encoding&quot;&gt;PerlIO::encoding&lt;/a&gt; for more information.</source>
          <target state="translated">사용 &lt;code&gt;:encoding(ENCODING)&lt;/code&gt; 투명 예컨대 시프트 JIS-에서 유니 코드 문자 집합 부호화의 변환을 수행하는 층을 설치하는 오픈 () 또는 bin 파일 ()에서 행해도된다. 참고 아래의 것을 &lt;code&gt;stdio&lt;/code&gt; &lt;code&gt;:encoding&lt;/code&gt; 도하는 수 &lt;code&gt;:utf8&lt;/code&gt; . 자세한 내용은 &lt;a href=&quot;perlio/encoding&quot;&gt;PerlIO :: encoding&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0b32751627ad0f538a9c781523741b9c9689a81e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;:via(MODULE)&lt;/code&gt; either in open() or binmode() to install a layer that does whatever transformation (for example compression / decompression, encryption / decryption) to the filehandle. See &lt;a href=&quot;perlio/via&quot;&gt;PerlIO::via&lt;/a&gt; for more information.</source>
          <target state="translated">사용 &lt;code&gt;:via(MODULE)&lt;/code&gt; 하나의 개방 () 또는 bin 파일 ()은 핸들에 (예를 들어, 압축 / 압축 해제, 암호화 / 복호화를위한) 어떤 변환을 수행하는 층을 설치하는. 자세한 내용은 &lt;a href=&quot;perlio/via&quot;&gt;PerlIO :: via&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5c35f727c8e06fe9ff695531c994a06e6d32367e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt; for local variables whenever you can get away with it (but see &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; for where you can't). Using &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; actually gives a local value to a global variable, which leaves you open to unforeseen side-effects of dynamic scoping.</source>
          <target state="translated">지역 변수에 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt; 를 사용 하면 멀리 갈 수 있습니다 (그러나 할 수없는 곳 은 &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; 참조 ). &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; 사용하면 실제로 전역 변수에 지역 값이 주어 지므로 동적 범위 지정의 예기치 않은 부작용에 노출됩니다.</target>
        </trans-unit>
        <trans-unit id="c47d329f16fdbd745016d298559c2d16104952e0" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt;, or else &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec()&lt;/a&gt;&lt;/code&gt; and the bitwise operations.</source>
          <target state="translated">사용 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; , 또는 다른 &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec()&lt;/a&gt;&lt;/code&gt; 와 비트 연산.</target>
        </trans-unit>
        <trans-unit id="e7d6c1efbb4fe6ed3d0e44682a7fdfcad4845a94" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; to go from several pieces of data to one fixed-width version; use &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; to turn a fixed-width-format string into several pieces of data.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 을 사용 하여 여러 데이터 조각에서 고정 너비 버전으로 이동하십시오. &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 을 사용 하여 고정 너비 형식 문자열을 여러 데이터 조각으로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="8fbc052d865293ed23949ab2e7f416dfadd5a776" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;functions/reverse&quot;&gt;reverse()&lt;/a&gt;&lt;/code&gt; in scalar context, as documented in &lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt;.</source>
          <target state="translated">사용 &lt;code&gt;&lt;a href=&quot;functions/reverse&quot;&gt;reverse()&lt;/a&gt;&lt;/code&gt; 에 설명 된대로, 스칼라 문맥에서 &lt;a href=&quot;functions/reverse&quot;&gt;역&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="27ae995888d29f8142b3c2932bd24cab6ea87cf6" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;@CARP_NOT&lt;/code&gt; , instead of &lt;code&gt;$Carp::CarpLevel&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$Carp::CarpLevel&lt;/code&gt; 대신 &lt;code&gt;@CARP_NOT&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="92183967ac97249aea7bc977e218502508a51699" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;NDBM_File&lt;/code&gt; with the Perl built-in &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; function to establish the connection between the variable and the file. The arguments to &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; should be:</source>
          <target state="translated">Perl 내장 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 함수 와 함께 &lt;code&gt;NDBM_File&lt;/code&gt; 을 사용 하여 변수와 파일 사이의 연결을 설정하십시오. &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 할 주장 은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="a39f53bf0801332ad81a8e20b727e708ddef3b6b" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Role::Tiny&lt;/code&gt; with &lt;code&gt;Class::Accessor&lt;/code&gt; or &lt;code&gt;Class::Tiny&lt;/code&gt; if you find yourself considering multiple inheritance. If you go with &lt;code&gt;Moose&lt;/code&gt; , it comes with its own role implementation.</source>
          <target state="translated">다중 상속을 고려하고 있다면 &lt;code&gt;Class::Accessor&lt;/code&gt; 또는 &lt;code&gt;Class::Tiny&lt;/code&gt; &lt;code&gt;Role::Tiny&lt;/code&gt; 와 함께 Role :: Tiny 를 사용하십시오 . &lt;code&gt;Moose&lt;/code&gt; 와 함께 가면 자체 역할 구현이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="0f06b5eddbf8d97d651f4831a1beb13b8718c8d6" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;SDBM_File&lt;/code&gt; with the Perl built-in &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; function to establish the connection between the variable and the file.</source>
          <target state="translated">Perl 내장 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 함수 와 함께 &lt;code&gt;SDBM_File&lt;/code&gt; 을 사용 하여 변수와 파일 사이의 연결을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="dd5ddb92a2e87aa696e71c88822af794ba04ff5b" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;SvPVbyte_nolen&lt;/code&gt; instead.</source>
          <target state="translated">대신 &lt;code&gt;SvPVbyte_nolen&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5709fd5fee3c8f65a9f2b5ff4443b46d700ffd8b" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;error&lt;/code&gt; to trap all that is reasonable (problems with permissions and the like), and let it die if things get out of hand. This is the safest course of action.</source>
          <target state="translated">&lt;code&gt;error&lt;/code&gt; 를 사용 하여 합리적인 모든 권한 (권한 등의 문제)을 포착하고 문제가 해결되지 않으면 죽도록하십시오. 이것이 가장 안전한 행동 과정입니다.</target>
        </trans-unit>
        <trans-unit id="a7ae97b4dc032127dbdf525b36f3287eea7a74cc" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;for&lt;/code&gt; /&lt;code&gt;foreach&lt;/code&gt; :</source>
          <target state="translated">사용 &lt;code&gt;for&lt;/code&gt; / &lt;code&gt;foreach&lt;/code&gt; 는 :</target>
        </trans-unit>
        <trans-unit id="42448f158fc4cf33aed96fb909d73152cfab8a01" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;sv_pos_b2u_flags&lt;/code&gt; in preference, which correctly handles strings longer than 2Gb.</source>
          <target state="translated">2Gb보다 긴 문자열을 올바르게 처리하는 환경 설정에서 &lt;code&gt;sv_pos_b2u_flags&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7227aee0b7448cf59bbacaf7f7fdbecd1aac240b" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;sv_pos_u2b_flags&lt;/code&gt; in preference, which correctly handles strings longer than 2Gb.</source>
          <target state="translated">2Gb보다 긴 문자열을 올바르게 처리하는 환경 설정에서 &lt;code&gt;sv_pos_u2b_flags&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9174053d497c0bac4b0650a86818fe94eb1cad92" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;utf8::encode()&lt;/code&gt; instead.</source>
          <target state="translated">사용 &lt;code&gt;utf8::encode()&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="e974bf00a2d723dec73908b097ca121c9409a8e4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;~pattern&lt;/code&gt; and &lt;code&gt;!pattern&lt;/code&gt; for positive and negative regexes.</source>
          <target state="translated">양수 및 음수 정규식에 &lt;code&gt;~pattern&lt;/code&gt; 및 &lt;code&gt;!pattern&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="061b1dc7990493487dde420be8fe1d319fffab9e" translate="yes" xml:space="preserve">
          <source>Use CPAN::SQLite if available? (yes/no)?</source>
          <target state="translated">가능한 경우 CPAN :: SQLite를 사용 하시겠습니까? (예 아니오)?</target>
        </trans-unit>
        <trans-unit id="714325381beb635775804a746adac93cfa93686a" translate="yes" xml:space="preserve">
          <source>Use Internet-domain sockets when you want to do client-server communication that might extend to machines outside of your own system.</source>
          <target state="translated">자체 시스템 외부의 시스템으로 확장 될 수있는 클라이언트-서버 통신을 수행하려면 인터넷 도메인 소켓을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0b9b3669dfa437dd595e2562fc06d4aa9b5c2435" translate="yes" xml:space="preserve">
          <source>Use MM[SK] macros, and VMS command line for C compiler.</source>
          <target state="translated">C 컴파일러에는 MM [SK] 매크로와 VMS 명령 행을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ea4874b782f37efa4adbe580d7fbd195de341f05" translate="yes" xml:space="preserve">
          <source>Use MM[SK] macros.</source>
          <target state="translated">MM [SK] 매크로를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="566b4db3c362df6b71e0ff5dee0038deb7684d52" translate="yes" xml:space="preserve">
          <source>Use MakeMaker's uninstalled version of a package</source>
          <target state="translated">MakeMaker의 제거 된 버전의 패키지 사용</target>
        </trans-unit>
        <trans-unit id="8e0e5dba70a90f698d3e0ca5e61baef285d0f01f" translate="yes" xml:space="preserve">
          <source>Use VMS Link command.</source>
          <target state="translated">VMS 링크 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="280948ed6505d39690e8bfb21e155eff171d0ef1" translate="yes" xml:space="preserve">
          <source>Use VMS commands to manipulate object library.</source>
          <target state="translated">VMS 명령을 사용하여 객체 라이브러리를 조작하십시오.</target>
        </trans-unit>
        <trans-unit id="bda9ca770225246f2160551c7450fb9367f1b262" translate="yes" xml:space="preserve">
          <source>Use VMS file specification syntax and CLI commands to find and invoke Perl images.</source>
          <target state="translated">VMS 파일 스펙 구문 및 CLI 명령을 사용하여 Perl 이미지를 찾아 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="ede73fbf3b4744edf3efb586d91835b3d9ad9918" translate="yes" xml:space="preserve">
          <source>Use VMS syntax on command line. In particular, $(DEFINE) and $(PERL_INC) have been pulled into $(CCCMD). Also use MM[SK] macros.</source>
          <target state="translated">명령 행에서 VMS 구문을 사용하십시오. 특히 $ (DEFINE) 및 $ (PERL_INC)가 $ (CCCMD)로 가져 왔습니다. MM [SK] 매크로도 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="691de1dabff4e93d09d661b351d70e27dc9a3c25" translate="yes" xml:space="preserve">
          <source>Use VMS-style syntax for files; it's cheaper to just do it directly here than to have the MM_Unix method call &lt;code&gt;catfile&lt;/code&gt; repeatedly. Also, if we have to rebuild Config.pm, use MM[SK] to do it.</source>
          <target state="translated">파일에 VMS 스타일 구문을 사용하십시오. MM_Unix 메소드가 &lt;code&gt;catfile&lt;/code&gt; 을 반복적으로 호출하는 것보다 여기에서 직접 수행하는 것이 더 저렴합니다 . 또한 Config.pm을 다시 빌드해야하는 경우 MM [SK]를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="21386b7269a32025e94fbc169460c22c01ed7e1f" translate="yes" xml:space="preserve">
          <source>Use a collator object to compare Unicode text by character instead of by codepoint.</source>
          <target state="translated">collator 객체를 사용하여 유니 코드 텍스트를 코드 포인트가 아닌 문자별로 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="af5688754fcfe001260b97f3d6228bac17ab8a5e" translate="yes" xml:space="preserve">
          <source>Use a command-line option, an environment variable, or else call &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; explicitly:</source>
          <target state="translated">명령 행 옵션, 환경 변수를 사용하거나 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 를 명시 적으로 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="ba762ed342f4cf062ad179e99538aaf1e4c1ae60" translate="yes" xml:space="preserve">
          <source>Use a hash. Here's code to do both and more. It assumes that each element is unique in a given array:</source>
          <target state="translated">해시를 사용하십시오. 다음은 둘 다 수행하는 코드입니다. 주어진 배열에서 각 요소가 고유하다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="271eac68025544545b6b8cda21c48f10de3e2be3" translate="yes" xml:space="preserve">
          <source>Use a hash. When you think the words &quot;unique&quot; or &quot;duplicated&quot;, think &quot;hash keys&quot;.</source>
          <target state="translated">해시를 사용하십시오. &quot;고유 한&quot;또는 &quot;중복 된&quot;이라는 단어를 생각할 때 &quot;해시 키&quot;를 생각하십시오.</target>
        </trans-unit>
        <trans-unit id="fb4ec017e331a31a5b1abaea84089100f3dba15e" translate="yes" xml:space="preserve">
          <source>Use a sort helper function</source>
          <target state="translated">정렬 도우미 기능 사용</target>
        </trans-unit>
        <trans-unit id="f616a684cd386a4ea767461805601287970f5579" translate="yes" xml:space="preserve">
          <source>Use a tree format in which the minimum amount of space is used for the lines connecting nodes (one character in most cases). This squeezes out a few precious columns of screen real estate.</source>
          <target state="translated">노드를 연결하는 라인 (대부분의 경우 한 문자)에 최소 공간이 사용되는 트리 형식을 사용하십시오. 이것은 화면 공간의 몇 가지 귀중한 열을 압착합니다.</target>
        </trans-unit>
        <trans-unit id="5882a02b6e19732df1aac03e7c042980b0e32ff8" translate="yes" xml:space="preserve">
          <source>Use a tree format that uses longer edges to separate OP nodes. This format tends to look better than the compact one, especially in ASCII, and is the default.</source>
          <target state="translated">더 긴 가장자리를 사용하여 OP 노드를 분리하는 트리 형식을 사용하십시오. 이 형식은 특히 ASCII에서 컴팩트 한 형식보다보기 좋으며 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="4b48f7ca244968605d46dde3055bd12f89577678" translate="yes" xml:space="preserve">
          <source>Use an alpha/beta style version number. Causes version number to be &quot;0.00_01&quot; unless &lt;b&gt;-v&lt;/b&gt; is specified.</source>
          <target state="translated">알파 / 베타 스타일 버전 번호를 사용하십시오. &lt;b&gt;-v&lt;/b&gt; 를 지정 하지 않으면 버전 번호가 &quot;0.00_01&quot; 이됩니다.</target>
        </trans-unit>
        <trans-unit id="6134c36e04029ff2453cb542046305a1f937b7f5" translate="yes" xml:space="preserve">
          <source>Use an alternate output format that, among other things, uses a different heading style and marks &lt;code&gt;=item&lt;/code&gt; entries with a colon in the left margin.</source>
          <target state="translated">다른 표제 스타일을 사용 하고 왼쪽 여백에 콜론으로 &lt;code&gt;=item&lt;/code&gt; 항목을 표시하는 대체 출력 형식을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="dcdeb0b163229c6ff03de5a0cdb9e6a57a7ea002" translate="yes" xml:space="preserve">
          <source>Use an index if it is present. The &lt;b&gt;-X&lt;/b&gt; option looks for an entry whose basename matches the name given on the command line in the file &lt;code&gt;$Config{archlib}/pod.idx&lt;/code&gt; . The</source>
          <target state="translated">인덱스가 있으면 사용하십시오. &lt;b&gt;-X&lt;/b&gt; 베이스 이름 파일의 명령 행에 주어진 이름과 일치하는 항목에 대한 옵션 외모 &lt;code&gt;$Config{archlib}/pod.idx&lt;/code&gt; . 그만큼</target>
        </trans-unit>
        <trans-unit id="ae7e5fe5c728700cd50b3c52c6ee63480235da37" translate="yes" xml:space="preserve">
          <source>Use as separator a character which is legal in a VMS-syntax file name.</source>
          <target state="translated">VMS 구문 파일 이름에 유효한 문자를 구분 기호로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="672a1c76642ee42c51ebfa65fd5a5d1a95399678" translate="yes" xml:space="preserve">
          <source>Use autosplit so little used or newly added functions won't be a burden to programs that don't use them. Add test functions to the module after __END__ either using AutoSplit or by saying:</source>
          <target state="translated">자동 스플릿을 사용하면 사용하지 않거나 새로 추가 된 기능이 거의 사용되지 않는 프로그램에 부담이되지 않습니다. AutoSplit을 사용하거나 다음과 같이 말하여 __END__ 이후에 테스트 기능을 모듈에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="317a05001ebb0c43c5b2e6eaa3b070114b0ab11b" translate="yes" xml:space="preserve">
          <source>Use blessed references. Use the two argument form of bless to bless into the class name given as the first parameter of the constructor, e.g.,:</source>
          <target state="translated">복된 참조를 사용하십시오. 생성자의 첫 번째 매개 변수로 주어진 클래스 이름을 축복하기 위해 bless의 두 인수 형식을 사용하십시오. 예 :</target>
        </trans-unit>
        <trans-unit id="ec95e04beca28ff76c489858d434dba58b46f4b7" translate="yes" xml:space="preserve">
          <source>Use both global and lexical variables.</source>
          <target state="translated">전역 변수와 어휘 변수를 모두 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3ec0b24d1442368e951d28938a31c4007d000691" translate="yes" xml:space="preserve">
          <source>Use formatting conventions in which the name of each OP, rather than being written out in full, is represented by a one- or two-character abbreviation. This is mainly a joke.</source>
          <target state="translated">전체 OP가 아닌 각 OP의 이름이 1 자 또는 2 자 약어로 표시되는 형식 규칙을 사용하십시오. 이것은 주로 농담입니다.</target>
        </trans-unit>
        <trans-unit id="32e0435d286f4e0f5dea4e605f6ba74b7a19693a" translate="yes" xml:space="preserve">
          <source>Use formatting conventions read from the environment variables &lt;code&gt;B_CONCISE_FORMAT&lt;/code&gt; , &lt;code&gt;B_CONCISE_GOTO_FORMAT&lt;/code&gt; , and &lt;code&gt;B_CONCISE_TREE_FORMAT&lt;/code&gt; .</source>
          <target state="translated">환경 변수 &lt;code&gt;B_CONCISE_FORMAT&lt;/code&gt; , &lt;code&gt;B_CONCISE_GOTO_FORMAT&lt;/code&gt; 및 &lt;code&gt;B_CONCISE_TREE_FORMAT&lt;/code&gt; 에서 읽은 형식 지정 규칙을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4fae2a54363441130a92de76cae86f65e4405daf" translate="yes" xml:space="preserve">
          <source>Use formatting conventions reminiscent of &lt;b&gt;B::Debug&lt;/b&gt;; these aren't very concise at all.</source>
          <target state="translated">&lt;b&gt;B :: Debug를&lt;/b&gt; 연상시키는 형식 규칙을 사용하십시오 . 이것들은 전혀 간결하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="60e51473a2aeb572e34290de332f54db3103274f" translate="yes" xml:space="preserve">
          <source>Use formatting conventions that emulate the output of &lt;b&gt;B::Terse&lt;/b&gt;. The basic mode is almost indistinguishable from the real &lt;b&gt;B::Terse&lt;/b&gt;, and the exec mode looks very similar, but is in a more logical order and lacks curly brackets. &lt;b&gt;B::Terse&lt;/b&gt; doesn't have a tree mode, so the tree mode is only vaguely reminiscent of &lt;b&gt;B::Terse&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;B :: Terse&lt;/b&gt; 의 출력을 에뮬레이트하는 형식 규칙을 사용하십시오 . 기본 모드는 실제 &lt;b&gt;B :: Terse&lt;/b&gt; 와 거의 구별 할 수 &lt;b&gt;없으며&lt;/b&gt; , exec 모드는 매우 유사 해 보이지만보다 논리적 인 순서이며 중괄호가 없습니다. &lt;b&gt;B :: Terse&lt;/b&gt; 에는 트리 모드가 없으므로 트리 모드는 &lt;b&gt;B :: Terse를&lt;/b&gt; 모호하게 연상 &lt;b&gt;시킵니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="05e7e7257def62f44171c1ab5e1ea5739af490a1" translate="yes" xml:space="preserve">
          <source>Use grok_atoUV() instead. atoi() has ill-defined behavior on overflows, and cannot be used for incremental parsing. It is also affected by locale, which is bad.</source>
          <target state="translated">대신 grok_atoUV ()를 사용하십시오. atoi ()는 오버플로에서 잘못 정의 된 동작을 가지며 증분 구문 분석에 사용할 수 없습니다. 또한 로케일의 영향을 받아 나쁜 상태입니다.</target>
        </trans-unit>
        <trans-unit id="49bfe15faf704565402bc75b321564e7f1a0847e" translate="yes" xml:space="preserve">
          <source>Use grok_atoUV() instead. strtol() or strtoul() (or their IV/UV-friendly macro disguises, Strtol() and Strtoul(), or Atol() and Atoul() are affected by locale, which is bad.</source>
          <target state="translated">대신 grok_atoUV ()를 사용하십시오. strtol () 또는 strtoul () (또는 IV / UV에 적합한 매크로 변장, Strtol () 및 Strtoul () 또는 Atol () 및 Atoul ()은 로케일에 의해 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="fec2179657e1b299044343e0b89c5b33f2055639" translate="yes" xml:space="preserve">
          <source>Use here documents instead of repeated &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; statements.</source>
          <target state="translated">반복되는 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; 문 대신 여기에 문서를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7408313f5feae22d66298e9df35a5c92afed0d81" translate="yes" xml:space="preserve">
          <source>Use integer arithmetic instead of floating point</source>
          <target state="translated">부동 소수점 대신 정수 산술을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4a2d0c065aebe88058e7899fe2b03390f5fd9ac8" translate="yes" xml:space="preserve">
          <source>Use it as follows:</source>
          <target state="translated">다음과 같이 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0f2153ef63f7f49f92d87613b8e6086727534be7" translate="yes" xml:space="preserve">
          <source>Use mkstemp() instead.</source>
          <target state="translated">대신 mkstemp ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9d215af52eba1c24168d3668f703076a6c44c6c8" translate="yes" xml:space="preserve">
          <source>Use mstat() function to emit a memory state statistic to the terminal. For more information on the format of output of mstat() see &lt;a href=&quot;../perldebguts#Using-%24ENV%7bPERL_DEBUG_MSTATS%7d&quot;&gt;Using $ENV{PERL_DEBUG_MSTATS} in perldebguts&lt;/a&gt;.</source>
          <target state="translated">mstat () 함수를 사용하여 메모리 상태 통계를 터미널로 내보내십시오. mstat ()의 출력 형식에 대한 자세한 정보는 perldebguts에서 &lt;a href=&quot;../perldebguts#Using-%24ENV%7bPERL_DEBUG_MSTATS%7d&quot;&gt;$ ENV {PERL_DEBUG_MSTATS} 사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="531c130b925ffd3120eb898dd244351239e437cf" translate="yes" xml:space="preserve">
          <source>Use my_strlcpy() and my_strlcat() instead: they either use the native implementation, or Perl's own implementation (borrowed from the public domain implementation of INN).</source>
          <target state="translated">대신 my_strlcpy () 및 my_strlcat ()을 사용하십시오. 네이티브 구현 또는 Perl 자체 구현 (INN의 퍼블릭 도메인 구현에서 차용)을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2c9671db7475e8358c84b51b41af26939a79a05c" translate="yes" xml:space="preserve">
          <source>Use named parameters (a hash or hashref) when there are more than two parameters</source>
          <target state="translated">둘 이상의 매개 변수가있는 경우 명명 된 매개 변수 (해시 또는 해시 참조) 사용</target>
        </trans-unit>
        <trans-unit id="6b1ab005a876449dcff824693329635ee0415484" translate="yes" xml:space="preserve">
          <source>Use named parameters. It's easier to use a hash like this:</source>
          <target state="translated">명명 된 매개 변수를 사용하십시오. 다음과 같이 해시를 사용하는 것이 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="a7996c874ba5c6e6417be6c43ab584f3aaff6022" translate="yes" xml:space="preserve">
          <source>Use nice English (or awk) names for ugly punctuation variables</source>
          <target state="translated">못생긴 구두점 변수에 멋진 영어 (또는 awk) 이름 사용</target>
        </trans-unit>
        <trans-unit id="8d5397d217e6f86d4205c68445ae6f732da49e78" translate="yes" xml:space="preserve">
          <source>Use non-standard idioms (otherwise you are not testing TIMTOWTDI).</source>
          <target state="translated">비표준 관용구를 사용하십시오 (그렇지 않으면 TIMTOWTDI를 테스트하지 않습니다).</target>
        </trans-unit>
        <trans-unit id="0f0cda525ac86ed2eeaa7f4035a68ab00df2e040" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;/x&lt;/code&gt; means that if you want real whitespace or &lt;code&gt;#&lt;/code&gt; characters in the pattern (outside a bracketed character class, which is unaffected by &lt;code&gt;/x&lt;/code&gt;), then you'll either have to escape them (using backslashes or &lt;code&gt;\Q...\E&lt;/code&gt; ) or encode them using octal, hex, or &lt;code&gt;\N{}&lt;/code&gt; escapes. It is ineffective to try to continue a comment onto the next line by escaping the &lt;code&gt;\n&lt;/code&gt; with a backslash or &lt;code&gt;\Q&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;/x&lt;/code&gt; 를 사용 하면 패턴에 실제 공백이나 &lt;code&gt;#&lt;/code&gt; 문자 를 원한다면 ( &lt;code&gt;/x&lt;/code&gt; 의 영향을받지 않는 괄호로 묶은 문자 클래스 외부 ) 백 슬래시 또는 &lt;code&gt;\Q...\E&lt;/code&gt; 사용하여 이스케이프 처리해야합니다 . \ E ) 또는 8 진, 16 진 또는 &lt;code&gt;\N{}&lt;/code&gt; 이스케이프를 사용하여 인코딩하십시오 . 백 슬래시 또는 &lt;code&gt;\Q&lt;/code&gt; &lt;code&gt;\n&lt;/code&gt; 을 이스케이프 처리하여 다음 줄에 주석을 계속 사용하는 것은 효과적이지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1cbbacbfb5cc1cd370b8cd67026b2e577274d54c" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; on aggregates (hashes and arrays) is deprecated. It used to report whether memory for that aggregate had ever been allocated. This behavior may disappear in future versions of Perl. You should instead use a simple test for size:</source>
          <target state="translated">집계 (해시 및 배열) 에 &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 사용 은 더 이상 사용되지 않습니다. 해당 집계에 대한 메모리가 할당되었는지 여부를보고하는 데 사용되었습니다. 이 문제는 이후 버전의 Perl에서 사라질 수 있습니다. 대신 크기에 대한 간단한 테스트를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c575003ac8ed97c3c8c499c8985b645cc965dd9e" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; on aggregates (hashes and arrays) is deprecated. It used to report whether memory for that aggregate had ever been allocated. This behavior may disappear in future versions of Perl. You should instead use a simple test for size:</source>
          <target state="translated">집계 (해시 및 배열) 에 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 사용 은 더 이상 사용되지 않습니다. 해당 집계에 대한 메모리가 할당되었는지 여부를보고하는 데 사용되었습니다. 이 문제는 이후 버전의 Perl에서 사라질 수 있습니다. 대신 크기에 대한 간단한 테스트를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="a1452256e006f48ab16db831ff1d2bc55b7b495f" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; to jump into a construct is deprecated and will issue a warning. Even then, it may not be used to go into any construct that requires initialization, such as a subroutine or a &lt;code&gt;foreach&lt;/code&gt; loop. It also can't be used to go into a construct that is optimized away.</source>
          <target state="translated">의 사용 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; 구성체로 뛰어가되지 않으며 경고를 발행합니다. 그럼에도 불구하고 서브 루틴 또는 &lt;code&gt;foreach&lt;/code&gt; 루프 와 같이 초기화가 필요한 구성으로 들어가는 데 사용될 수 없습니다 . 또한 최적화 된 구문으로 들어가는 데 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5aa03266aa6d88c654f206267c8022d408e9c245" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; to jump into a construct is deprecated and will issue a warning. Even then, it may not be used to go into any construct that requires initialization, such as a subroutine or a &lt;code&gt;foreach&lt;/code&gt; loop. It also can't be used to go into a construct that is optimized away.</source>
          <target state="translated">의 사용 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; 구성체로 뛰어가되지 않으며 경고를 발행합니다. 그럼에도 불구하고 서브 루틴 또는 &lt;code&gt;foreach&lt;/code&gt; 루프 와 같이 초기화가 필요한 구성으로 들어가는 데 사용될 수 없습니다 . 또한 최적화 된 구문으로 들어가는 데 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0ce1975659a74600b8f5d10e727a0e482e0ccb5e" translate="yes" xml:space="preserve">
          <source>Use of a single identifier, prefixed with &lt;code&gt;*&lt;/code&gt; . For example, &lt;code&gt;*name&lt;/code&gt; stands for any or all of &lt;code&gt;$name&lt;/code&gt; , &lt;code&gt;@name&lt;/code&gt; , &lt;code&gt;%name&lt;/code&gt; , &lt;code&gt;&amp;amp;name&lt;/code&gt; , or just &lt;code&gt;name&lt;/code&gt; . How you use it determines whether it is interpreted as all or only one of them. See &amp;ldquo;Typeglobs and Filehandles&amp;rdquo; in Camel chapter 2, &amp;ldquo;Bits and Pieces&amp;rdquo;.</source>
          <target state="translated">접두사가 &lt;code&gt;*&lt;/code&gt; 로 된 단일 식별자 사용 . 예를 들어, &lt;code&gt;*name&lt;/code&gt; 의 일부 또는 전부를 의미 &lt;code&gt;$name&lt;/code&gt; , &lt;code&gt;@name&lt;/code&gt; , &lt;code&gt;%name&lt;/code&gt; , &lt;code&gt;&amp;amp;name&lt;/code&gt; , 아니면 그냥 &lt;code&gt;name&lt;/code&gt; . 사용 방법에 따라 전체 또는 단일로 해석되는지 여부가 결정됩니다. Camel 2 장,&amp;ldquo;비트와 조각&amp;rdquo;의&amp;ldquo;타입 글로브와 파일 핸들&amp;rdquo;을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="79921a859879ed1277d82b4cc80975d8402d69d3" translate="yes" xml:space="preserve">
          <source>Use of a subroutine call, rather than a subroutine name, as an argument to exists() is an error.</source>
          <target state="translated">exist ()의 인수로 서브 루틴 이름이 아닌 서브 루틴 호출을 사용하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="86136067e812367f102852e0f2a4131e0073483c" translate="yes" xml:space="preserve">
          <source>Use of any other character following the &lt;code&gt;&quot;c&quot;&lt;/code&gt; besides those listed above is discouraged, and as of Perl v5.20, the only characters actually allowed are the printable ASCII ones, minus the left brace &lt;code&gt;&quot;{&quot;&lt;/code&gt; . What happens for any of the allowed other characters is that the value is derived by xor'ing with the seventh bit, which is 64, and a warning raised if enabled. Using the non-allowed characters generates a fatal error.</source>
          <target state="translated">위에 나열된 것 이외 의 &lt;code&gt;&quot;c&quot;&lt;/code&gt; 다음에 나오는 다른 문자 는 사용하지 않는 것이 좋습니다. Perl v5.20부터는 실제로 허용되는 문자는 왼쪽 중괄호 &lt;code&gt;&quot;{&quot;&lt;/code&gt; 를 제외한 인쇄 가능한 ASCII 문자입니다 . 허용 된 다른 문자에 대해 발생하는 것은 64 번째 비트 인 xor'ing에 의해 값이 도출되고 활성화 된 경우 경고가 발생한다는 것입니다. 허용되지 않는 문자를 사용하면 치명적인 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2d322945b4e21e9e3602bafb5e497ecc98176eed" translate="yes" xml:space="preserve">
          <source>Use of each publically accessible method or subroutine, including parameters and return values</source>
          <target state="translated">매개 변수 및 리턴 값을 포함하여 공개적으로 액세스 가능한 각 메소드 또는 서브 루틴 사용</target>
        </trans-unit>
        <trans-unit id="c4576ebd26dc37f362b412c956b1df320b83b3af" translate="yes" xml:space="preserve">
          <source>Use of epoch seconds</source>
          <target state="translated">에포크 초 사용</target>
        </trans-unit>
        <trans-unit id="1731aaf31968c5fdd9480f64d745beb19858cc51" translate="yes" xml:space="preserve">
          <source>Use of interval timers may interfere with &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/sleep&quot;&gt;sleep()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;usleep()&lt;/code&gt; . In standard-speak the &quot;interaction is unspecified&quot;, which means that</source>
          <target state="translated">간격 타이머를 사용하면 &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/sleep&quot;&gt;sleep()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;usleep()&lt;/code&gt; 방해 할 수 있습니다 . 표준 적으로 말하면 &quot;상호 작용이 지정되지 않았다&quot;는 것은</target>
        </trans-unit>
        <trans-unit id="1a808d3a7e8e48ea8bc89247be3129db920de8bf" translate="yes" xml:space="preserve">
          <source>Use of the &lt;code&gt;normalization&lt;/code&gt; parameter requires the &lt;b&gt;Unicode::Normalize&lt;/b&gt; module (see &lt;a href=&quot;normalize&quot;&gt;Unicode::Normalize&lt;/a&gt;).</source>
          <target state="translated">의 사용 &lt;code&gt;normalization&lt;/code&gt; 매개 변수는 필요 &lt;b&gt;유니 코드 : 표준화 된&lt;/b&gt; 모듈을합니다 ( &lt;a href=&quot;normalize&quot;&gt;유니 코드 : 표준화를&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0f49c2ebf95d755e5a6d2e5df09c73558f210f71" translate="yes" xml:space="preserve">
          <source>Use one of</source>
          <target state="translated">다음 중 하나를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="5c06bf7bc66bd95d8dadea94a66d540da42d6175" translate="yes" xml:space="preserve">
          <source>Use one of the RPC modules( &lt;a href=&quot;https://metacpan.org/search?q=RPC&quot;&gt;https://metacpan.org/search?q=RPC&lt;/a&gt; ).</source>
          <target state="translated">RPC 모듈 중 하나를 사용하십시오 ( &lt;a href=&quot;https://metacpan.org/search?q=RPC&quot;&gt;https://metacpan.org/search?q=RPC&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e43df0045591deb1920c698e1e06d9540206f44c" translate="yes" xml:space="preserve">
          <source>Use only modes 'rb' or 'wb' or /wb[1-9]/.</source>
          <target state="translated">'rb'또는 'wb'또는 / wb [1-9] / 모드 만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="852a3fb75c58ea9ab6aee1d984501d31575dbe43" translate="yes" xml:space="preserve">
          <source>Use or avoid POSIX locales for built-in operations</source>
          <target state="translated">내장 조작에 POSIX 로케일 사용 또는 회피</target>
        </trans-unit>
        <trans-unit id="42549f09d2d3209d758990ebfc780be7cd9d6789" translate="yes" xml:space="preserve">
          <source>Use references as hash keys</source>
          <target state="translated">참조를 해시 키로 사용</target>
        </trans-unit>
        <trans-unit id="24db154be0d68fd92b28271f4ccc60a8152b9d53" translate="yes" xml:space="preserve">
          <source>Use subroutine address instead of name when reporting.</source>
          <target state="translated">보고시 이름 대신 서브 루틴 주소를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e65336030d621ad236216bbd262ac0c17be3ed80" translate="yes" xml:space="preserve">
          <source>Use tabs for each 8 columns of indent. The default is to use only spaces. For instance, if the style options are &lt;b&gt;-si4T&lt;/b&gt;, a line that's indented 3 times will be preceded by one tab and four spaces; if the options were &lt;b&gt;-si8T&lt;/b&gt;, the same line would be preceded by three tabs.</source>
          <target state="translated">들여 쓰기 열 8 개마다 탭을 사용하십시오. 기본값은 공백 만 사용하는 것입니다. 예를 들어, 스타일 옵션이 &lt;b&gt;-si4T&lt;/b&gt; 인 경우 세 번 들여 쓰기 된 행 앞에는 하나의 탭과 네 개의 공백이 있습니다. 옵션이 &lt;b&gt;-si8T&lt;/b&gt; 이면 동일한 행 앞에 세 개의 탭 &lt;b&gt;이옵니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="900e9cc0a9414f47ad3c3cf6cec86c687d5c9a3b" translate="yes" xml:space="preserve">
          <source>Use the &amp;lt;&amp;gt; (&lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob()&lt;/a&gt;&lt;/code&gt;) operator, documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;. Versions of Perl older than 5.6 require that you have a shell installed that groks tildes. Later versions of Perl have this feature built in. The &lt;a href=&quot;http://search.cpan.org/perldoc/File::KGlob&quot;&gt;File::KGlob&lt;/a&gt; module (available from CPAN) gives more portable glob functionality.</source>
          <target state="translated">&lt;a href=&quot;perlfunc&quot;&gt;perlfunc에&lt;/a&gt; 문서화 된 &amp;lt;&amp;gt; ( &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob()&lt;/a&gt;&lt;/code&gt; ) 연산자를 사용하십시오 . 5.6 이전의 Perl 버전에서는 물결표를 움켜 쥐는 쉘이 설치되어 있어야합니다. 최신 버전의 Perl에는이 기능이 내장되어 있습니다. CPAN에서 제공 하는 &lt;a href=&quot;http://search.cpan.org/perldoc/File::KGlob&quot;&gt;File :: KGlob&lt;/a&gt; 모듈은보다 편리한 glob 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="70b160440316452f340f816438a94ac57e43a80b" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;file/copy&quot;&gt;File::Copy&lt;/a&gt; module. It comes with Perl and can do a true copy across file systems, and it does its magic in a portable fashion.</source>
          <target state="translated">&lt;a href=&quot;file/copy&quot;&gt;File :: Copy&lt;/a&gt; 모듈을 사용하십시오 . Perl과 함께 제공되며 파일 시스템간에 실제 복사를 수행 할 수 있으며 휴대용 방식으로 마법을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="e3fef79cbd4ceac4e867796d39b4567be99b7a0c" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;http://search.cpan.org/perldoc/BSD::Resource&quot;&gt;BSD::Resource&lt;/a&gt; module from CPAN. As an example:</source>
          <target state="translated">CPAN 의 &lt;a href=&quot;http://search.cpan.org/perldoc/BSD::Resource&quot;&gt;BSD :: Resource&lt;/a&gt; 모듈을 사용하십시오 . 예로서:</target>
        </trans-unit>
        <trans-unit id="d164af42cbef789ed1001f4b9517bb726a601d59" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Folder&quot;&gt;Email::Folder&lt;/a&gt; module, like so:</source>
          <target state="translated">다음과 같이 &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Folder&quot;&gt;Email :: Folder&lt;/a&gt; 모듈을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="66505dab9f27e8ded0226b45047ac4d95ef19d93" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;http://search.cpan.org/perldoc/Email::MIME&quot;&gt;Email::MIME&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Sender::Simple&quot;&gt;Email::Sender::Simple&lt;/a&gt; modules, like so:</source>
          <target state="translated">사용 &lt;a href=&quot;http://search.cpan.org/perldoc/Email::MIME&quot;&gt;이메일 : MIME&lt;/a&gt; 및 &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Sender::Simple&quot;&gt;이메일 : 보낸 사람을 :: 간단한&lt;/a&gt; 모듈과 같이를 :</target>
        </trans-unit>
        <trans-unit id="9cda4728e014cde6b4aa8b1e9ff60d1e00b00f30" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;http://search.cpan.org/perldoc/Email::MIME&quot;&gt;Email::MIME&lt;/a&gt; module. It's well-tested and supports all the craziness that you'll see in the real world (comment-folding whitespace, encodings, comments, etc.).</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Email::MIME&quot;&gt;Email :: MIME&lt;/a&gt; 모듈을 사용하십시오 . 그것은 잘 테스트되었으며 실제 세계에서 볼 수있는 모든 괴짜 (설명 접는 공백, 인코딩, 주석 등)를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="6c838954123651f7a7afc095c1c154c266d44966" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;http://search.cpan.org/perldoc/List::Permutor&quot;&gt;List::Permutor&lt;/a&gt; module on CPAN. If the list is actually an array, try the &lt;a href=&quot;http://search.cpan.org/perldoc/Algorithm::Permute&quot;&gt;Algorithm::Permute&lt;/a&gt; module (also on CPAN). It's written in XS code and is very efficient:</source>
          <target state="translated">CPAN 의 &lt;a href=&quot;http://search.cpan.org/perldoc/List::Permutor&quot;&gt;List :: Permutor&lt;/a&gt; 모듈을 사용하십시오 . 목록이 실제로 배열 인 경우 &lt;a href=&quot;http://search.cpan.org/perldoc/Algorithm::Permute&quot;&gt;Algorithm :: Permute&lt;/a&gt; 모듈 (CPAN에도 해당)을 사용해보십시오 . XS 코드로 작성되었으며 매우 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="65a351301ca14a96333147c8b3d3106e99e464c1" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;http://search.cpan.org/perldoc/Math::Matrix&quot;&gt;Math::Matrix&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/perldoc/Math::MatrixReal&quot;&gt;Math::MatrixReal&lt;/a&gt; modules (available from CPAN) or the &lt;a href=&quot;http://search.cpan.org/perldoc/PDL&quot;&gt;PDL&lt;/a&gt; extension (also available from CPAN).</source>
          <target state="translated">사용 &lt;a href=&quot;http://search.cpan.org/perldoc/Math::Matrix&quot;&gt;수학 :: 매트릭스&lt;/a&gt; 또는 &lt;a href=&quot;http://search.cpan.org/perldoc/Math::MatrixReal&quot;&gt;수학 :: MatrixReal&lt;/a&gt; (CPAN에서 구할 수) 모듈 또는 &lt;a href=&quot;http://search.cpan.org/perldoc/PDL&quot;&gt;PDL의&lt;/a&gt; (CPAN에서도 가능) 확장을.</target>
        </trans-unit>
        <trans-unit id="9284406bbe8e82a3357e3616e641d1dd96c570f0" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;http://search.cpan.org/perldoc/Tie::IxHash&quot;&gt;Tie::IxHash&lt;/a&gt; from CPAN.</source>
          <target state="translated">CPAN 의 &lt;a href=&quot;http://search.cpan.org/perldoc/Tie::IxHash&quot;&gt;Tie :: IxHash&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c0e1ce41fa321637cf3d64ebec09008a4c7342ad" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;$/&lt;/code&gt; variable (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for details). You can either set it to &lt;code&gt;&quot;&quot;&lt;/code&gt; to eliminate empty paragraphs (&lt;code&gt;&quot;abc\n\n\n\ndef&quot;&lt;/code&gt; , for instance, gets treated as two paragraphs and not three), or &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; to accept empty paragraphs.</source>
          <target state="translated">&lt;code&gt;$/&lt;/code&gt; 변수를 사용하십시오 (자세한 내용은 &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; 참조). 빈 단락을 제거 하려면 &lt;code&gt;&quot;&quot;&lt;/code&gt; (예 : &lt;code&gt;&quot;abc\n\n\n\ndef&quot;&lt;/code&gt; 는 3 개가 아닌 2 개의 단락으로 처리됨)를 제거하거나 &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; 을 사용하여 빈 단락을 승인 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3eb28dd761b36a73acd489d9a060d0261a86e1b3" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;:encoding(...)&lt;/code&gt; layer to read from and write to filehandles using the specified encoding. (See &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;.)</source>
          <target state="translated">사용 &lt;code&gt;:encoding(...)&lt;/code&gt; 에서와 쓰기 지정된 인코딩을 사용하여 파일 핸들에게 책을 읽어 레이어를. ( &lt;a href=&quot;open&quot;&gt;열기&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="1043c9bb577ccc31fca3b4929e685adcde02639a" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; function, probably in conjunction with a signal handler, as documented in &lt;a href=&quot;perlipc#Signals&quot;&gt;Signals in perlipc&lt;/a&gt; and the section on &quot;Signals&quot; in the Camel. You may instead use the more flexible &lt;a href=&quot;http://search.cpan.org/perldoc/Sys::AlarmCall&quot;&gt;Sys::AlarmCall&lt;/a&gt; module available from CPAN.</source>
          <target state="translated">&lt;a href=&quot;perlipc#Signals&quot;&gt;perlipc의 신호&lt;/a&gt; 및 Camel의 &quot;신호&quot;섹션에 설명 된대로 &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; 함수를 아마도 신호 처리기와 함께 사용하십시오 . 대신 CPAN에서 사용 가능한 보다 유연한 &lt;a href=&quot;http://search.cpan.org/perldoc/Sys::AlarmCall&quot;&gt;Sys :: AlarmCall&lt;/a&gt; 모듈을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b06aec35cc8ae0b522498e65b1bb4f4583c757e" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; function (see &lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;):</source>
          <target state="translated">사용 &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; (참조 기능을 &lt;a href=&quot;functions/rand&quot;&gt;랜드를&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="24977a0b1e006e0285b58c0302df8403248c380a" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;Encode&lt;/code&gt; package to try converting it. For example,</source>
          <target state="translated">&lt;code&gt;Encode&lt;/code&gt; 패키지를 사용하여 변환하십시오. 예를 들어</target>
        </trans-unit>
        <trans-unit id="0dc5eef8749d48465cf33790a50fb27f748e0a9f" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;SvPV_nolen&lt;/code&gt; macro instead</source>
          <target state="translated">대신 &lt;code&gt;SvPV_nolen&lt;/code&gt; 매크로를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="ef653b1e1ac17e7ebb2ebd7fe5cecc710ea855b0" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;SvPVutf8_nolen&lt;/code&gt; macro instead</source>
          <target state="translated">대신 &lt;code&gt;SvPVutf8_nolen&lt;/code&gt; 매크로를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="bfd1997217ebfcfd0b8127ecc2505173b83edb29" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;\N{&lt;i&gt;charname&lt;/i&gt;}&lt;/code&gt; notation to get the character by that name for use in interpolated literals (double-quoted strings and regexes). In v5.16, there is an implicit</source>
          <target state="translated">사용 &lt;code&gt;\N{&lt;i&gt;charname&lt;/i&gt;}&lt;/code&gt; 보간 리터럴 (큰 따옴표 문자열과 정규 표현식에)에 사용하는 이름으로 문자를 얻을 표기법을. v5.16에는 암시 적</target>
        </trans-unit>
        <trans-unit id="7d52ddc8b7977a545ad663296d7fb2fca1b0f239" translate="yes" xml:space="preserve">
          <source>Use the Configure &lt;code&gt;-Dgccansipedantic&lt;/code&gt; flag to enable the gcc &lt;code&gt;-ansi
-pedantic&lt;/code&gt; flags which enforce stricter ANSI rules.</source>
          <target state="translated">보다 엄격한 ANSI 규칙을 적용 하는 gcc &lt;code&gt;-ansi -pedantic&lt;/code&gt; 플래그를 사용하려면 Configure &lt;code&gt;-Dgccansipedantic&lt;/code&gt; 플래그를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ddf13da36f032e379ae4d2a3b1c1bae344b15223" translate="yes" xml:space="preserve">
          <source>Use the MY_CXT macro to access members of the &lt;code&gt;my_cxt_t&lt;/code&gt; struct. For example, if &lt;code&gt;my_cxt_t&lt;/code&gt; is</source>
          <target state="translated">의 액세스 회원들에게 MY_CXT 매크로를 사용 &lt;code&gt;my_cxt_t&lt;/code&gt; 의 구조체. 예를 들어, &lt;code&gt;my_cxt_t&lt;/code&gt; 가</target>
        </trans-unit>
        <trans-unit id="209d781836e6b1246a37a402443979bfc102b6da" translate="yes" xml:space="preserve">
          <source>Use the alternate DATA command &quot;BDAT&quot; of the data chunking service extension defined in RFC1830 for efficiently sending large MIME messages.</source>
          <target state="translated">큰 MIME 메시지를 효율적으로 전송하려면 RFC1830에 정의 된 데이터 청킹 서비스 확장의 대체 DATA 명령 &quot;BDAT&quot;를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3b568a8fe0839108748606587d3b5ef52fd93b31" translate="yes" xml:space="preserve">
          <source>Use the author's favorite set of formatting conventions. This is the default, of course.</source>
          <target state="translated">저자가 선호하는 형식 지정 규칙을 사용하십시오. 물론 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="9ac34b7ac482595c74c32af79b7d65f665861078" translate="yes" xml:space="preserve">
          <source>Use the backslash ('\') character for quoting: every occurrence of a backslash followed by a character in the pattern is replaced by that character, avoiding any special interpretation of the character. (But see below for exceptions on DOSISH systems).</source>
          <target state="translated">인용에는 백 슬래시 ( '\') 문자를 사용하십시오. 백 슬래시 다음에 나타나는 문자는 패턴의 문자로 대체되며 문자의 특수 해석을 피합니다. (하지만 DOSISH 시스템의 예외는 아래를 참조하십시오).</target>
        </trans-unit>
        <trans-unit id="58c791ac75ac6f9811d7c1cd895cf02a99e988fc" translate="yes" xml:space="preserve">
          <source>Use the dMY_CXT macro (a declaration) in all the functions that access MY_CXT.</source>
          <target state="translated">MY_CXT에 액세스하는 모든 함수에서 dMY_CXT 매크로 (선언)를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a11c34555178b87ed57024b7506fd7ffd640c9ab" translate="yes" xml:space="preserve">
          <source>Use the default &quot;cmd&quot; shell that comes with Windows. Some versions of the popular 4DOS/NT shell have incompatibilities that may cause you trouble. If the build fails under that shell, try building again with the cmd shell.</source>
          <target state="translated">Windows와 함께 제공되는 기본 &quot;cmd&quot;쉘을 사용하십시오. 널리 사용되는 4DOS / NT 셸의 일부 버전에는 비 호환성이있어 문제를 일으킬 수 있습니다. 해당 쉘에서 빌드가 실패하면 cmd 쉘로 다시 빌드하십시오.</target>
        </trans-unit>
        <trans-unit id="860daa28ec194a818f5b182bccd22928db406092" translate="yes" xml:space="preserve">
          <source>Use the default to produce the *.dll's. But for new archdir dll's use the same rebase address if the old exists.</source>
          <target state="translated">* .dll을 생성하려면 기본값을 사용하십시오. 그러나 새로운 archdir dll의 경우 이전 버전이 있으면 동일한 rebase 주소를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e1fc4198386c0572da6a991c5d426478433e6323" translate="yes" xml:space="preserve">
          <source>Use the external tar program instead of Archive::Tar?</source>
          <target state="translated">Archive :: Tar? 대신 외부 tar 프로그램을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4bac2574d114ae82b8fd263b9459dca50bff3c24" translate="yes" xml:space="preserve">
          <source>Use the following simple functions:</source>
          <target state="translated">다음과 같은 간단한 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="82c21f5742907cbf65bd7db33516fce8af244b3d" translate="yes" xml:space="preserve">
          <source>Use the force pragma like so</source>
          <target state="translated">힘 pragma를 이렇게 사용하십시오</target>
        </trans-unit>
        <trans-unit id="d7f075c6e2b64b3ce706fb827bca3411e7b8504c" translate="yes" xml:space="preserve">
          <source>Use the key mentioned at</source>
          <target state="translated">에 언급 된 키를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="718a478ced25e8295348d28c5a0bc5741996efff" translate="yes" xml:space="preserve">
          <source>Use the libwww-perl distribution. The &lt;a href=&quot;http://search.cpan.org/perldoc/LWP::Simple&quot;&gt;LWP::Simple&lt;/a&gt; module can fetch web resources and give their content back to you as a string:</source>
          <target state="translated">libwww-perl 배포를 사용하십시오. &lt;a href=&quot;http://search.cpan.org/perldoc/LWP::Simple&quot;&gt;LWP :: 간단한&lt;/a&gt; 모듈은 웹 자원을 가져오고 문자열로 당신에게 자신의 콘텐츠 등을 제공 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="cb1603df2ef00841c0d9bacb479a841ff6e25e94" translate="yes" xml:space="preserve">
          <source>Use the macros STMT_START and STMT_END.</source>
          <target state="translated">STMT_START 및 STMT_END 매크로를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c888fae92abf19a81b4d142f09c5f461d8d9608c" translate="yes" xml:space="preserve">
          <source>Use the name of the class for the object reference, &lt;code&gt;$object&lt;/code&gt; , as the warnings category.</source>
          <target state="translated">객체 참조에 대한 클래스 이름 인 &lt;code&gt;$object&lt;/code&gt; 를 경고 범주로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="90b334d1699fa8ac1b699ca7fe59817de25916cf" translate="yes" xml:space="preserve">
          <source>Use the new &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; operators to avoid having to parenthesize list operators so much, and to reduce the incidence of punctuation operators like &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt;. Call your subroutines as if they were functions or list operators to avoid excessive ampersands and parentheses.</source>
          <target state="translated">리스트 연산자를 괄호로 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;||&lt;/code&gt; 와 같은 문장 부호 연산자의 발생률을 줄이려면 new &lt;code&gt;and&lt;/code&gt; / &lt;code&gt;or&lt;/code&gt; 연산자를 사용하십시오. . 앰퍼샌드 및 괄호를 과도하게 피하기 위해 서브 루틴을 함수 또는리스트 연산자처럼 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="442188b51b5e18cf49fd3890247d5179d50e4049" translate="yes" xml:space="preserve">
          <source>Use the object-oriented interface if fine-grained control of when a file is removed is required.</source>
          <target state="translated">파일 제거시기를 세밀하게 제어해야하는 경우 객체 지향 인터페이스를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="79265afb000f4991752261ca28217b5c373e53aa" translate="yes" xml:space="preserve">
          <source>Use the perlrebase or rebase utilities to resolve the conflicting dll addresses. The rebase package is included in the Cygwin setup. Use</source>
          <target state="translated">perlrebase 또는 rebase 유틸리티를 사용하여 충돌하는 dll 주소를 해결하십시오. Rebase 패키지는 Cygwin 설정에 포함되어 있습니다. 사용하다</target>
        </trans-unit>
        <trans-unit id="0801908980e9c580009d45c4098d1486f12c00b2" translate="yes" xml:space="preserve">
          <source>Use the reaper code from &lt;a href=&quot;perlipc#Signals&quot;&gt;Signals in perlipc&lt;/a&gt; to call &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; when a SIGCHLD is received, or else use the double-fork technique described in &lt;a href=&quot;perlfaq8#How-do-I-start-a-process-in-the-background%3f&quot;&gt;How do I start a process in the background? in perlfaq8&lt;/a&gt;.</source>
          <target state="translated">SIGCHLD가 수신 될 때 &lt;a href=&quot;perlipc#Signals&quot;&gt;perlipc&lt;/a&gt; 에있는 신호의 리퍼 코드를 사용하여 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; 를 호출 하거나 &lt;a href=&quot;perlfaq8#How-do-I-start-a-process-in-the-background%3f&quot;&gt;백그라운드에서 프로세스를 시작하는 방법에&lt;/a&gt; 설명 된 이중 포크 기술을 사용하십시오 . perlfaq8에서 .</target>
        </trans-unit>
        <trans-unit id="4ab1865ade7c5cbdf616d9cfa7bc296cc942c842" translate="yes" xml:space="preserve">
          <source>Use the split function:</source>
          <target state="translated">split 기능을 사용하십시오 :</target>
        </trans-unit>
        <trans-unit id="a9b5bca0abebc1d76df512275844e6baf7fca732" translate="yes" xml:space="preserve">
          <source>Use the three-argument form to open a file with arbitrary weird characters in it,</source>
          <target state="translated">임의의 이상한 문자가 포함 된 파일을 열려면 세 개의 인수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0e2045ea69cf09267eda92b39d5360c52617d312" translate="yes" xml:space="preserve">
          <source>Use the warnings category with the same name as the current package.</source>
          <target state="translated">현재 패키지와 이름이 같은 경고 범주를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0293445fabb340233713c8257ab81530a2889bf1" translate="yes" xml:space="preserve">
          <source>Use these rather than &lt;code&gt;stdin&lt;/code&gt; , &lt;code&gt;stdout&lt;/code&gt; , &lt;code&gt;stderr&lt;/code&gt; . They are written to look like &quot;function calls&quot; rather than variables because this makes it easier to</source>
          <target state="translated">&lt;code&gt;stdin&lt;/code&gt; , &lt;code&gt;stdout&lt;/code&gt; , &lt;code&gt;stderr&lt;/code&gt; 대신 이들을 사용하십시오 . 변수가 아닌 &quot;함수 호출&quot;처럼 보이도록 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="a81fa8275577903400d658f76e856afcaee1f2f2" translate="yes" xml:space="preserve">
          <source>Use these very, very, very sparingly.</source>
          <target state="translated">매우 아껴서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="87ebb269f56a9a915023b69eabf6ff027e2f7e0c" translate="yes" xml:space="preserve">
          <source>Use this code, provided by Mark-Jason Dominus:</source>
          <target state="translated">Mark-Jason Dominus가 제공 한이 코드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1a99888f271041405f93aa8e81d9f5a2d2c20746" translate="yes" xml:space="preserve">
          <source>Use this instead of $(PERL) when you wish to run perl to work with modules. It will add things like -I$(INST_ARCH) and other necessary flags so perl can see the modules you're about to install.</source>
          <target state="translated">모듈 작업을 위해 perl을 실행하려면 $ (PERL) 대신 이것을 사용하십시오. -I $ (INST_ARCH) 및 기타 필요한 플래그를 추가하여 perl이 설치하려는 모듈을 볼 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="388121ab9a82a1ad19377b89ac9de297ea8e7f2c" translate="yes" xml:space="preserve">
          <source>Use this instead of $(PERL) when you wish to run perl. It will set up extra necessary flags for you.</source>
          <target state="translated">perl을 실행하려면 $ (PERL) 대신 이것을 사용하십시오. 필요한 추가 플래그를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="e6433f54cefa63ecf9e10e3ca3a566ca9eb8f9de" translate="yes" xml:space="preserve">
          <source>Use this instead:</source>
          <target state="translated">대신 이것을 사용하십시오 :</target>
        </trans-unit>
        <trans-unit id="9482ca604a352c4ff781a10e825ea8768f370ffb" translate="yes" xml:space="preserve">
          <source>Use this module like this:</source>
          <target state="translated">이 모듈을 다음과 같이 사용하십시오 :</target>
        </trans-unit>
        <trans-unit id="24fd134a2b3d96c5cbea104957e21046321bc6c3" translate="yes" xml:space="preserve">
          <source>Use this to build perl outside of the source tree. Details can be found in the</source>
          <target state="translated">이것을 사용하여 소스 트리 외부에 perl을 빌드하십시오. 자세한 내용은</target>
        </trans-unit>
        <trans-unit id="163162b126000a656e356ab3254dffb8d7962901" translate="yes" xml:space="preserve">
          <source>Use this to disassociate a file from a PerlIO * that was associated using PerlIO_exportFILE().</source>
          <target state="translated">이를 사용하여 PerlIO_exportFILE ()을 사용하여 연관된 PerlIO *에서 파일을 분리하십시오.</target>
        </trans-unit>
        <trans-unit id="b543720e8daabc3733964f244cca2d14e58df202" translate="yes" xml:space="preserve">
          <source>Use this:</source>
          <target state="translated">이것을 사용하십시오 :</target>
        </trans-unit>
        <trans-unit id="03038b4251119aa1c25d1f79aa4a7d76f09e6350" translate="yes" xml:space="preserve">
          <source>Use tree connecting characters drawn from the VT100 line-drawing set. This looks better if your terminal supports it.</source>
          <target state="translated">VT100 라인 드로잉 세트에서 그린 트리 연결 문자를 사용하십시오. 터미널이 지원하면 더 좋아 보인다.</target>
        </trans-unit>
        <trans-unit id="5b877243c67d7922e8d87750811b66b31f1b397f" translate="yes" xml:space="preserve">
          <source>Use underscores to separate words. It is generally easier to read $var_names_like_this than $VarNamesLikeThis, especially for non-native speakers of English. It's also a simple rule that works consistently with VAR_NAMES_LIKE_THIS.</source>
          <target state="translated">밑줄을 사용하여 단어를 구분하십시오. 일반적으로 영어가 모국어가 아닌 사용자의 경우 $ VarNamesLikeThis보다 $ var_names_like_this를 읽는 것이 일반적으로 더 쉽습니다. VAR_NAMES_LIKE_THIS와 일관되게 작동하는 간단한 규칙이기도합니다.</target>
        </trans-unit>
        <trans-unit id="a9f6d10a6d2104b7922abf95412d3e52031b3d8b" translate="yes" xml:space="preserve">
          <source>Use unrelated features (this will flush out bizarre interactions).</source>
          <target state="translated">관련없는 기능을 사용하십시오 (기괴한 상호 작용을 제거합니다).</target>
        </trans-unit>
        <trans-unit id="b5b5116cfec58023d905fc9d5b3040b726593cef" translate="yes" xml:space="preserve">
          <source>Used as a noun in this case, this refers to a known way to compromise a program to get it to do something the author didn&amp;rsquo;t intend. Your task is to write unexploitable programs.</source>
          <target state="translated">이 경우 명사로 사용되는이 기능은 저작자가 의도하지 않은 작업을 수행하기 위해 프로그램을 손상시키는 알려진 방법을 나타냅니다. 당신의 임무는 악용 할 수없는 프로그램을 작성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="79c6d27106d07e0f5897103d8c6a8d8a85ec8bb1" translate="yes" xml:space="preserve">
          <source>Used as a noun, a name in a &lt;b&gt;directory&lt;/b&gt; that represents a &lt;b&gt;file&lt;/b&gt;. A given file can have multiple links to it. It&amp;rsquo;s like having the same phone number listed in the phone directory under different names. As a verb, to resolve a partially &lt;b&gt;compiled&lt;/b&gt; file&amp;rsquo;s unresolved symbols into a (nearly) executable image. Linking can generally be static or dynamic, which has nothing to do with static or dynamic scoping.</source>
          <target state="translated">&lt;b&gt;파일&lt;/b&gt; 을 나타내는 &lt;b&gt;디렉토리&lt;/b&gt; 의 이름 인 명사로 사용됩니다 . 주어진 파일에는 여러 개의 링크가있을 수 있습니다. 전화 번호부에 동일한 이름의 전화 번호가 같은 것과 같습니다. 동사로, 부분적으로 &lt;b&gt;컴파일 된&lt;/b&gt; 파일의 해석 되지 않은 기호를 (거의) 실행 가능 이미지 로 해석합니다 . 링크는 일반적으로 정적 또는 동적 일 수 있으며 정적 또는 동적 범위 지정과 관련이 없습니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5e94bf506fd2ed1897d55415e2eda38e61b816ec" translate="yes" xml:space="preserve">
          <source>Used as an lvalue, &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; allows you to increase the number of hash buckets allocated for the given hash. This can gain you a measure of efficiency if you know the hash is going to get big. (This is similar to pre-extending an array by assigning a larger number to $#array.) If you say</source>
          <target state="translated">lvalue로 사용되는 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 사용하면 지정된 해시에 할당 된 해시 버킷 수를 늘릴 수 있습니다. 해시가 커질 것임을 알면 효율성을 측정 할 수 있습니다. (이것은 $ # array에 더 큰 숫자를 할당하여 배열을 미리 확장하는 것과 비슷합니다.)</target>
        </trans-unit>
        <trans-unit id="cfcd9d6e7d0af6a973640e08731f7579c85d2ca6" translate="yes" xml:space="preserve">
          <source>Used as an lvalue, &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; allows you to increase the number of hash buckets allocated for the given hash. This can gain you a measure of efficiency if you know the hash is going to get big. (This is similar to pre-extending an array by assigning a larger number to $#array.) If you say</source>
          <target state="translated">lvalue로 사용되는 &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 사용하면 지정된 해시에 할당 된 해시 버킷 수를 늘릴 수 있습니다. 해시가 커질 것임을 알면 효율성을 측정 할 수 있습니다. (이것은 $ # array에 더 큰 숫자를 할당하여 배열을 미리 확장하는 것과 비슷합니다.)</target>
        </trans-unit>
        <trans-unit id="9d927fa8ae51a19f16800a69ce9d19da2c120815" translate="yes" xml:space="preserve">
          <source>Used as part of the &quot;clone&quot; process when a thread is spawned (in which case param will be non-NULL) and when a stream is being duplicated via '&amp;amp;' in the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">스레드가 생성 될 때 (이 경우 param이 NULL이 아님) 스트림이 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 에서 '&amp;amp;'를 통해 복제 될 때 &quot;복제&quot;프로세스의 일부로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="251c18a90eefe3a719259f59bb8700c29e6c2e54" translate="yes" xml:space="preserve">
          <source>Used by 'make install' which copies files from INST_SCRIPT to this directory if INSTALLDIRS is set to site (default).</source>
          <target state="translated">INSTALLDIRS가 site (기본값)로 설정된 경우 INST_SCRIPT에서이 디렉토리로 파일을 복사하는 'make install'에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0413527e465c4de8a077bbf425ed66e91381919a" translate="yes" xml:space="preserve">
          <source>Used by 'make install' which copies files from INST_SCRIPT to this directory if INSTALLDIRS is set to vendor.</source>
          <target state="translated">INSTALLDIRS가 vendor로 설정된 경우 INST_SCRIPT에서이 디렉토리로 파일을 복사하는 'make install'에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="976bda008ac56ae36683d29627c3f35a11dab1ca" translate="yes" xml:space="preserve">
          <source>Used by 'make install' which copies files from INST_SCRIPT to this directory if INSTALLDIRS=perl.</source>
          <target state="translated">INSTALLDIRS = perl 인 경우 INST_SCRIPT에서이 디렉토리로 파일을 복사하는 'make install'에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="37d1058a6b6ba0e70de245f908c09c85ed3a873d" translate="yes" xml:space="preserve">
          <source>Used by 'make install', which copies files from INST_ARCHLIB to this directory if INSTALLDIRS is set to perl.</source>
          <target state="translated">INSTALLDIRS가 perl로 설정된 경우 INST_ARCHLIB에서이 디렉토리로 파일을 복사하는 'make install'에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8402b50cbc218eeff1f81c3db2cda9adf3fffbd7" translate="yes" xml:space="preserve">
          <source>Used by 'make install', which copies files from INST_ARCHLIB to this directory if INSTALLDIRS is set to site (default).</source>
          <target state="translated">INSTALLDIRS가 site (기본값)로 설정된 경우 INST_ARCHLIB에서이 디렉토리로 파일을 복사하는 'make install'에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c4c8328bf8916ab5fdd86eb62de06cc4f4230a70" translate="yes" xml:space="preserve">
          <source>Used by 'make install', which copies files from INST_ARCHLIB to this directory if INSTALLDIRS is set to vendor.</source>
          <target state="translated">INSTALLDIRS가 vendor로 설정된 경우 INST_ARCHLIB에서이 디렉토리로 파일을 복사하는 'make install'에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3b0cddfea5d7479fbfb7a215e845b5a123be89bb" translate="yes" xml:space="preserve">
          <source>Used by 'make install', which copies files from INST_BIN to this directory if INSTALLDIRS is set to site (default).</source>
          <target state="translated">INSTALLDIRS가 site (기본값)로 설정된 경우 INST_BIN에서이 디렉토리로 파일을 복사하는 'make install'에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="eb49c11648bc66ca1d5846b99271ffd0d898ea32" translate="yes" xml:space="preserve">
          <source>Used by 'make install', which copies files from INST_BIN to this directory if INSTALLDIRS is set to vendor.</source>
          <target state="translated">INSTALLDIRS가 vendor로 설정된 경우 INST_BIN에서이 디렉토리로 파일을 복사하는 'make install'에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2b07ebb6cc38d7286ba9e956f3eba69a5ff528fe" translate="yes" xml:space="preserve">
          <source>Used by 'make install', which copies files from INST_LIB to this directory if INSTALLDIRS is set to perl.</source>
          <target state="translated">INSTALLDIRS가 perl로 설정된 경우 INST_LIB에서이 디렉토리로 파일을 복사하는 'make install'에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4c572796939181da5eba99b899ab05bfaac9e449" translate="yes" xml:space="preserve">
          <source>Used by 'make install', which copies files from INST_LIB to this directory if INSTALLDIRS is set to site (default).</source>
          <target state="translated">INSTALLDIRS가 site (기본값)로 설정된 경우 INST_LIB에서이 디렉토리로 파일을 복사하는 'make install'에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="497f3b2bdeaf3749352a862b66d7233b6bb7365e" translate="yes" xml:space="preserve">
          <source>Used by 'make install', which copies files from INST_LIB to this directory if INSTALLDIRS is set to vendor.</source>
          <target state="translated">INSTALLDIRS가 vendor로 설정된 경우 INST_LIB에서이 디렉토리로 파일을 복사하는 'make install'에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="955b442432c35e6b42d1db59049e0e27c3353bce" translate="yes" xml:space="preserve">
          <source>Used by &lt;code&gt;xsubpp&lt;/code&gt; to hook up XSUBs as Perl subs.</source>
          <target state="translated">&lt;code&gt;xsubpp&lt;/code&gt; 에서 XSUB를 Perl 하위로 연결하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="b701e8ad52984344882bfc710f4e3b41bfee3ae7" translate="yes" xml:space="preserve">
          <source>Used by &lt;code&gt;xsubpp&lt;/code&gt; to hook up XSUBs as Perl subs. Adds Perl prototypes to the subs.</source>
          <target state="translated">&lt;code&gt;xsubpp&lt;/code&gt; 에서 XSUB를 Perl 하위로 연결하는 데 사용됩니다 . 서브에 Perl 프로토 타입을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="bf413f31411cb5187dfc08c3a35d494612fab477" translate="yes" xml:space="preserve">
          <source>Used by Unicode internally for generating other properties and not intended to be used stand-alone</source>
          <target state="translated">다른 속성을 생성하기 위해 내부적으로 유니 코드에서 사용되며 독립형으로 사용되지 않습니다</target>
        </trans-unit>
        <trans-unit id="4e698d59aaba8e3ee1c30011c41b0b74d5937cc8" translate="yes" xml:space="preserve">
          <source>Used by a &lt;b&gt;standard I/O&lt;/b&gt; output stream that flushes its &lt;b&gt;buffer&lt;/b&gt; after every &lt;b&gt;newline&lt;/b&gt;. Many standard I/O libraries automatically set up line buffering on output that is going to the terminal.</source>
          <target state="translated">모든 &lt;b&gt;개행&lt;/b&gt; 후에 &lt;b&gt;버퍼&lt;/b&gt; 를 플러시 하는 &lt;b&gt;표준 I / O&lt;/b&gt; 출력 스트림에 의해 사용됩니다 . 많은 표준 I / O 라이브러리는 터미널로가는 출력에서 ​​라인 버퍼링을 자동으로 설정합니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e00976e80fe78228b9297b3ddbd122a14f1abe1f" translate="yes" xml:space="preserve">
          <source>Used by some OS' to define DL_FUNCS and DL_VARS and write the *.exp files.</source>
          <target state="translated">일부 OS에서 DL_FUNCS 및 DL_VARS를 정의하고 * .exp 파일을 작성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1ba26d0698fc6f53589c3fcda2fd4a8860e0e9f9" translate="yes" xml:space="preserve">
          <source>Used by the IS_SAFE_SYSCALL() macro.</source>
          <target state="translated">IS_SAFE_SYSCALL () 매크로에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c2253cb286405345c16b81c3000c80dff0161abd" translate="yes" xml:space="preserve">
          <source>Used during the execution phase for managing search and replace patterns, and for providing the text for &lt;code&gt;$&amp;amp;&lt;/code&gt; , &lt;code&gt;$1&lt;/code&gt; etc. &lt;code&gt;subbeg&lt;/code&gt; points to a buffer (either the original string, or a copy in the case of &lt;code&gt;RX_MATCH_COPIED(rx)&lt;/code&gt; ), and &lt;code&gt;sublen&lt;/code&gt; is the length of the buffer. The &lt;code&gt;RX_OFFS&lt;/code&gt; start and end indices index into this buffer.</source>
          <target state="translated">검색 및 바꾸기 패턴을 관리하고 &lt;code&gt;$&amp;amp;&lt;/code&gt; , &lt;code&gt;$1&lt;/code&gt; 등 의 텍스트를 제공하기 위해 실행 단계에서 사용됩니다 . &lt;code&gt;subbeg&lt;/code&gt; 는 버퍼 (원래 문자열 또는 &lt;code&gt;RX_MATCH_COPIED(rx)&lt;/code&gt; 의 경우 사본 ) 및 &lt;code&gt;sublen&lt;/code&gt; 을 가리 킵니다. 버퍼의 길이입니다. &lt;code&gt;RX_OFFS&lt;/code&gt; 는 시작과 끝이 버퍼 인덱스와 indices.</target>
        </trans-unit>
        <trans-unit id="c07d1ff394d728bbcdaa2001c2857f1cf7faa30d" translate="yes" xml:space="preserve">
          <source>Used for emphasis (&quot;&lt;code&gt;be I&amp;lt;careful!&amp;gt;&lt;/code&gt; &quot;) and parameters (&quot;&lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt; I&amp;lt;LABEL&amp;gt;&lt;/code&gt; &quot;)</source>
          <target state="translated">강조 ( &quot; &lt;code&gt;be I&amp;lt;careful!&amp;gt;&lt;/code&gt; &quot;) 및 매개 변수 ( &quot; &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt; I&amp;lt;LABEL&amp;gt;&lt;/code&gt; &quot;)에 사용</target>
        </trans-unit>
        <trans-unit id="7d3c574527f056e37525c76d104fc8a22ad9cc2b" translate="yes" xml:space="preserve">
          <source>Used for optimisations. &lt;code&gt;precomp&lt;/code&gt; holds a copy of the pattern that was compiled and &lt;code&gt;prelen&lt;/code&gt; its length. When a new pattern is to be compiled (such as inside a loop) the internal &lt;code&gt;regcomp&lt;/code&gt; operator checks if the last compiled &lt;code&gt;REGEXP&lt;/code&gt; 's &lt;code&gt;precomp&lt;/code&gt; and &lt;code&gt;prelen&lt;/code&gt; are equivalent to the new one, and if so uses the old pattern instead of compiling a new one.</source>
          <target state="translated">최적화에 사용됩니다. &lt;code&gt;precomp&lt;/code&gt; 는 컴파일 된 패턴의 사본을 보유 하고 길이를 &lt;code&gt;prelen&lt;/code&gt; 합니다. 루프 내부와 같은 새로운 패턴이 컴파일 될 때 내부 &lt;code&gt;regcomp&lt;/code&gt; 연산자는 마지막으로 컴파일 된 &lt;code&gt;REGEXP&lt;/code&gt; 의 &lt;code&gt;precomp&lt;/code&gt; 및 &lt;code&gt;prelen&lt;/code&gt; 이 새로운 패턴과 동일한 지 확인하고, 새로운 패턴을 컴파일하는 대신 이전 패턴을 사용합니다. .</target>
        </trans-unit>
        <trans-unit id="c16a1dda4419ca1fa42a25c2f463240abdf22010" translate="yes" xml:space="preserve">
          <source>Used for switches (&quot;&lt;code&gt;perl's B&amp;lt;-n&amp;gt; switch&lt;/code&gt; &quot;), programs (&quot;&lt;code&gt;some systems provide a B&amp;lt;chfn&amp;gt; for that&lt;/code&gt; &quot;), emphasis (&quot;&lt;code&gt;be B&amp;lt;careful!&amp;gt;&lt;/code&gt; &quot;), and so on (&quot;&lt;code&gt;and that feature is known as B&amp;lt;autovivification&amp;gt;&lt;/code&gt; &quot;).</source>
          <target state="translated">스위치 ( &quot; &lt;code&gt;perl's B&amp;lt;-n&amp;gt; switch&lt;/code&gt; &quot;), 프로그램 ( &quot; &lt;code&gt;some systems provide a B&amp;lt;chfn&amp;gt; for that&lt;/code&gt; &quot;에 대해 B &amp;lt;chfn&amp;gt;을 제공함 ), 강조 ( &quot; &lt;code&gt;be B&amp;lt;careful!&amp;gt;&lt;/code&gt; &quot;) 등에 사용됩니다 ( &quot; &lt;code&gt;and that feature is known as B&amp;lt;autovivification&amp;gt;&lt;/code&gt; &quot;)라고합니다.</target>
        </trans-unit>
        <trans-unit id="8d00f06e1f81e3c4218071563a3bababae3c7eab" translate="yes" xml:space="preserve">
          <source>Used for test.pl, since they don't always follow Test::Harness formatting.</source>
          <target state="translated">항상 Test :: Harness 형식을 따르지 않으므로 test.pl에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="85f7caced82a8f0a4057356aaa1e87b6b4b7ead3" translate="yes" xml:space="preserve">
          <source>Used if &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; has no argument and HOME is not set.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 에 인수가없고 HOME이 설정되지 않은 경우에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a5442b49ecc1bae306f70b5a25e1762fda194c70" translate="yes" xml:space="preserve">
          <source>Used if &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; has no argument.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 에 인수가없는 경우에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="5908b09f62d202af9a5d54ac62b509abf705e1f4" translate="yes" xml:space="preserve">
          <source>Used if chdir has no argument and HOME and LOGDIR are not set.</source>
          <target state="translated">chdir에 인수가없고 HOME 및 LOGDIR이 설정되지 않은 경우에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9b97a5382104ef747655a54d5cf00ae2ece3ac3e" translate="yes" xml:space="preserve">
          <source>Used in conjunction with the &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; option to supply a reference to an &lt;code&gt;@ARGV&lt;/code&gt; style array of arguments to pass to the test program.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 옵션 과 함께 사용 하여 테스트 프로그램에 전달할 인수 의 &lt;code&gt;@ARGV&lt;/code&gt; 스타일 배열에 대한 참조를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="477606f47e75aab0d16ae4c72010e54847d20bed" translate="yes" xml:space="preserve">
          <source>Used in conjunction with the &lt;code&gt;strcoll()&lt;/code&gt; function, see &lt;a href=&quot;#strcoll&quot;&gt;strcoll&lt;/a&gt;.</source>
          <target state="translated">와 함께 사용 &lt;code&gt;strcoll()&lt;/code&gt; 함수를 참조 &lt;a href=&quot;#strcoll&quot;&gt;strcoll&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0096c9408c39e5114a134ce424b3de68995688e0" translate="yes" xml:space="preserve">
          <source>Used in executing subprocesses, and in finding the program if &lt;b&gt;-S&lt;/b&gt; is used.</source>
          <target state="translated">&lt;b&gt;-S&lt;/b&gt; 가 사용 되는지 서브 프로세스를 실행하고 프로그램을 찾는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fc7e238a8b39d615018cf421f51aee97a59ca55c" translate="yes" xml:space="preserve">
          <source>Used on numbers, the bitwise operators (&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;&lt;code&gt;^&lt;/code&gt;&lt;code&gt;~&lt;/code&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; ) always produce integral results. (But see also &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Bitwise String Operators&lt;/a&gt;.) However, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; still has meaning for them. By default, their results are interpreted as unsigned integers, but if &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; is in effect, their results are interpreted as signed integers. For example, &lt;code&gt;~0&lt;/code&gt; usually evaluates to a large integral value. However, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer; ~0&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt; on two's-complement machines.</source>
          <target state="translated">숫자로 사용되는 비트 연산자 ( &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;^&lt;/code&gt; &lt;code&gt;~&lt;/code&gt; &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; )는 항상 완전한 결과를 생성합니다. (그러나 &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;비트 단위 문자열 연산자&lt;/a&gt; 도 참조하십시오 .) 그러나 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 은 여전히 ​​의미가 있습니다. 기본적으로 결과는 부호없는 정수로 해석되지만 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 이 유효한 경우 결과는 부호있는 정수로 해석됩니다. 예를 들어 &lt;code&gt;~0&lt;/code&gt; 일반적으로 큰 정수 값으로 평가됩니다. 그러나 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer; ~0&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용하십시오&lt;/a&gt; . 2의 보수 기계에서 ~ 0 은 &lt;code&gt;-1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="22f1fcd6bfd2f48fba3948a9e62685e57c7db9d1" translate="yes" xml:space="preserve">
          <source>Used on the t/*.t files.</source>
          <target state="translated">t / *. t 파일에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a64dabf0b28b220a6076bc6a581b9356f3e76610" translate="yes" xml:space="preserve">
          <source>Used only when MakeMaker is building the extensions of the Perl core distribution (because normally $(PERL_ARCHLIB) is automatically in @INC, and adding it would get in the way of PERL5LIB).</source>
          <target state="translated">MakeMaker가 Perl 코어 배포의 확장을 빌드 할 때만 사용됩니다 (일반적으로 $ (PERL_ARCHLIB)는 @INC에 자동으로 추가되고 PERL5LIB를 방해하기 때문에).</target>
        </trans-unit>
        <trans-unit id="522904b951ae26afa223c455d7c6bd2555ea2781" translate="yes" xml:space="preserve">
          <source>Used only when MakeMaker is building the extensions of the Perl core distribution (because normally $(PERL_LIB) is automatically in @INC, and adding it would get in the way of PERL5LIB).</source>
          <target state="translated">MakeMaker가 Perl 코어 배포의 확장을 빌드 할 때만 사용됩니다 (일반적으로 $ (PERL_LIB)는 @INC에 자동으로 추가되고 PERL5LIB를 방해하기 때문에).</target>
        </trans-unit>
        <trans-unit id="f0b6e6daa054441299880d327c03ad5022b9eb54" translate="yes" xml:space="preserve">
          <source>Used to access elements on the XSUB's stack.</source>
          <target state="translated">XSUB의 스택에있는 요소에 액세스하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e35e54c290e520db893e920267b9220db378f0a1" translate="yes" xml:space="preserve">
          <source>Used to check if any errata was seen.</source>
          <target state="translated">정오표가 보이는지 확인하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="87a9aa1ba364ad0831ad8d0593884f266cd7c93e" translate="yes" xml:space="preserve">
          <source>Used to choose the LZMA compression preset.</source>
          <target state="translated">LZMA 압축 사전 설정을 선택하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7c52aa40f13bb513d24fe0ba0fa19d6fcc4a443a" translate="yes" xml:space="preserve">
          <source>Used to compare numbers.</source>
          <target state="translated">숫자를 비교하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c48ef407eccd138f057ccc3292baa7a78dede864" translate="yes" xml:space="preserve">
          <source>Used to describe a &lt;b&gt;referent&lt;/b&gt; that is not directly accessible through a named &lt;b&gt;variable&lt;/b&gt;. Such a referent must be indirectly accessible through at least one &lt;b&gt;hard reference&lt;/b&gt;. When the last hard reference goes away, the anonymous referent is destroyed without pity.</source>
          <target state="translated">명명 된 &lt;b&gt;변수를&lt;/b&gt; 통해 직접 액세스 할 수없는 &lt;b&gt;참조&lt;/b&gt; 를 설명하는 데 사용됩니다 . 이러한 참조는 적어도 하나의 &lt;b&gt;하드 참조를&lt;/b&gt; 통해 간접적으로 액세스 가능해야합니다 . 마지막 하드 레퍼런스가 사라지면 익명의 리퍼 럴은 동정없이 파괴됩니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="68eae2d00f0bb0e45444425d5ef88e0a25c713c4" translate="yes" xml:space="preserve">
          <source>Used to extend the argument stack for an XSUB's return values. Once used, guarantees that there is room for at least &lt;code&gt;nitems&lt;/code&gt; to be pushed onto the stack.</source>
          <target state="translated">XSUB의 반환 값에 대한 인수 스택을 확장하는 데 사용됩니다. 일단 사용되면 스택 에 최소한의 &lt;code&gt;nitems&lt;/code&gt; 를 넣을 수있는 공간이 확보됩니다 .</target>
        </trans-unit>
        <trans-unit id="c9d6ff55b3e514bbe849f67e44d09a8a1f610db4" translate="yes" xml:space="preserve">
          <source>Used to force a Perl &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; wrapper around a callback. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">콜백 주위에 Perl &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 래퍼 를 강제하는 데 사용됩니다 . &lt;a href=&quot;perlcall&quot;&gt;perlcall을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="de62f27495e3f33e099616750808f449be5f2cfc" translate="yes" xml:space="preserve">
          <source>Used to get a PerlIO * from a FILE *.</source>
          <target state="translated">FILE *에서 PerlIO *를 얻는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e5f86f7323575cf5c768f8e5109eb6cf3318d1d9" translate="yes" xml:space="preserve">
          <source>Used to indicate list context. See &lt;code&gt;GIMME_V&lt;/code&gt; , &lt;code&gt;GIMME&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">목록 컨텍스트를 나타내는 데 사용됩니다. &lt;code&gt;GIMME_V&lt;/code&gt; , &lt;code&gt;GIMME&lt;/code&gt; 및 &lt;a href=&quot;perlcall&quot;&gt;perlcall을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a930c77deebf229f4a954c4d6804d1b626a7c0da" translate="yes" xml:space="preserve">
          <source>Used to indicate scalar context. See &lt;code&gt;GIMME_V&lt;/code&gt; , &lt;code&gt;GIMME&lt;/code&gt; , and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">스칼라 컨텍스트를 나타내는 데 사용됩니다. &lt;code&gt;GIMME_V&lt;/code&gt; , &lt;code&gt;GIMME&lt;/code&gt; 및 &lt;a href=&quot;perlcall&quot;&gt;perlcall을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="06d42cedd073f96c9a77c4270da2ab3e95ee0de9" translate="yes" xml:space="preserve">
          <source>Used to indicate void context. See &lt;code&gt;GIMME_V&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">무효 컨텍스트를 나타내는 데 사용됩니다. &lt;code&gt;GIMME_V&lt;/code&gt; 및 &lt;a href=&quot;perlcall&quot;&gt;perlcall을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9bb1d0a62eb268dccff9ee670a0b1ed19d224173" translate="yes" xml:space="preserve">
          <source>Used to negate the object in-place.</source>
          <target state="translated">개체를 제자리에서 무효화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7ab9fb9e2f57ebf6032a373e79745b71c5c594eb" translate="yes" xml:space="preserve">
          <source>Used to pass in and return a reference to an SV.</source>
          <target state="translated">SV에 대한 참조를 전달하고 반환하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="02c1be0e858c6b96b18473855240486ec63fb69b" translate="yes" xml:space="preserve">
          <source>Used to pass in and return a reference to an SV. This is a fixed variant of T_SVREF that decrements the refcount appropriately when returning a reference to an SV*. Introduced in perl 5.15.4.</source>
          <target state="translated">SV에 대한 참조를 전달하고 반환하는 데 사용됩니다. 이것은 SV *에 대한 참조를 반환 할 때 참조 횟수를 적절하게 감소시키는 T_SVREF의 고정 변형입니다. perl 5.15.4에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="c91a5082aa2e7c4d29d7e1b996780ca43a12407b" translate="yes" xml:space="preserve">
          <source>Used to shift numbers left/right.</source>
          <target state="translated">숫자를 왼쪽 / 오른쪽으로 이동하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3deb258f4b48416c1a5909b948e6f301fdab02b0" translate="yes" xml:space="preserve">
          <source>Used to upgrade an SV to a more complex form. Uses &lt;code&gt;sv_upgrade&lt;/code&gt; to perform the upgrade if necessary. See &lt;code&gt;svtype&lt;/code&gt; .</source>
          <target state="translated">SV를보다 복잡한 형태로 업그레이드하는 데 사용됩니다. 용도는 &lt;code&gt;sv_upgrade&lt;/code&gt; 필요한 경우 업그레이드를 수행 할 수 있습니다. 보다 &lt;code&gt;svtype&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="fcb5d7f5c46a099246ea8a6f9905effe5c22e13c" translate="yes" xml:space="preserve">
          <source>Used together, as &lt;code&gt;/ms&lt;/code&gt;, they let the &quot;.&quot; match any character whatsoever, while still allowing &quot;^&quot; and &quot;$&quot; to match, respectively, just after and just before newlines within the string.</source>
          <target state="translated">같이 사용 &lt;code&gt;/ms&lt;/code&gt; 하면 &quot;.&quot; 문자열 내에서 개행 직전과 직후에 각각 &quot;^&quot;및 &quot;$&quot;가 일치하도록 허용하면서 모든 문자를 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="6fa27f5c1082734ec40392b2d9f3d19afd0775e2" translate="yes" xml:space="preserve">
          <source>Used when creating PPD files for binary packages. It can be set to a full or relative path or URL to the binary archive for a particular architecture. For example:</source>
          <target state="translated">이진 패키지에 대한 PPD 파일을 만들 때 사용됩니다. 특정 아키텍처의 바이너리 아카이브에 대한 전체 또는 상대 경로 또는 URL로 설정할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0efa982fe3c01dc21ffac634d0623c22f8078dad" translate="yes" xml:space="preserve">
          <source>Used when the layer's open() accepts more arguments than usual. The extra arguments should come not before the &lt;code&gt;MODE&lt;/code&gt; argument. When this flag is used it's up to the layer to validate the args.</source>
          <target state="translated">레이어의 open ()이 평소보다 더 많은 인수를 허용 할 때 사용됩니다. 추가 인수는 &lt;code&gt;MODE&lt;/code&gt; 앞에 와서는 안됩니다 인수 . 이 플래그를 사용하면 args의 유효성을 검사하는 것은 레이어에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdd67bcd97e446b57807bc47ce4d7da189f0ad26" translate="yes" xml:space="preserve">
          <source>Used with the example above, &lt;code&gt;@libfiles&lt;/code&gt; (or &lt;code&gt;@$libfiles&lt;/code&gt; ) would contain two strings upon completion: &lt;code&gt;&quot;lib/stdlib&quot;&lt;/code&gt; and &lt;code&gt;&quot;lib/extlib&quot;&lt;/code&gt; , in that order. It is also possible to specify that only integer or floating point numbers are acceptable values.</source>
          <target state="translated">위의 예제와 함께 사용하면 &lt;code&gt;@libfiles&lt;/code&gt; (또는 &lt;code&gt;@$libfiles&lt;/code&gt; )에는 완료시 &lt;code&gt;&quot;lib/stdlib&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;lib/extlib&quot;&lt;/code&gt; 라는 두 개의 문자열이 포함됩니다. 이 순서대로 포함됩니다. 정수 또는 부동 소수점 숫자 만 허용되는 값으로 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="32482e797407c687053869f8a4e7d0cfe24ca4f2" translate="yes" xml:space="preserve">
          <source>Used without arguments in scalar context, reverse() reverses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">스칼라 컨텍스트에서 인수없이 사용되는 reverse ()는 &lt;code&gt;$_&lt;/code&gt; 반대로 합니다.</target>
        </trans-unit>
        <trans-unit id="287fb92f0982907aa797c3b17e0824ad256b9b20" translate="yes" xml:space="preserve">
          <source>Useful functions for dealing with the filehandle and filename.</source>
          <target state="translated">파일 핸들 및 파일 이름을 처리하는 데 유용한 기능.</target>
        </trans-unit>
        <trans-unit id="f0b64588f00eed76bae59e12d25ea5d5e9aeab35" translate="yes" xml:space="preserve">
          <source>Useful modules to help you write tests (with minimum impact on your development process or your time) include Test::Simple, Carp::Assert and Test::Inline. For more sophisticated test suites there are Test::More and Test::MockObject.</source>
          <target state="translated">테스트 작성에 도움이되는 유용한 모듈 (개발 프로세스 또는 시간에 미치는 영향을 최소화)에는 Test :: Simple, Carp :: Assert 및 Test :: Inline이 있습니다. 보다 복잡한 테스트 스위트에는 Test :: More 및 Test :: MockObject가 있습니다.</target>
        </trans-unit>
        <trans-unit id="04355f5678f3ad8646b491395f68bd676dba02d6" translate="yes" xml:space="preserve">
          <source>Useful options of</source>
          <target state="translated">유용한 옵션</target>
        </trans-unit>
        <trans-unit id="7705a5ed12704795a74e0deb45a6e2191d0de39a" translate="yes" xml:space="preserve">
          <source>Useful values for &lt;code&gt;PERLDOC&lt;/code&gt; include &lt;code&gt;-oterm&lt;/code&gt; , &lt;code&gt;-otext&lt;/code&gt; , &lt;code&gt;-ortf&lt;/code&gt; , &lt;code&gt;-oxml&lt;/code&gt; , and so on, depending on what modules you have on hand; or the formatter class may be specified exactly with &lt;code&gt;-MPod::Perldoc::ToTerm&lt;/code&gt; or the like.</source>
          <target state="translated">유용 값 &lt;code&gt;PERLDOC&lt;/code&gt; 포함 &lt;code&gt;-oterm&lt;/code&gt; , &lt;code&gt;-otext&lt;/code&gt; , &lt;code&gt;-ortf&lt;/code&gt; , &lt;code&gt;-oxml&lt;/code&gt; , 등등, 당신은 손에있는 모듈 내용에 따라; 또는 &lt;code&gt;-MPod::Perldoc::ToTerm&lt;/code&gt; 하여 포맷터 클래스를 정확하게 지정할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="108f6902446d675962ade16c5ef5d6ed95723631" translate="yes" xml:space="preserve">
          <source>Useful, huh? You can eval nearly anything in there, and experiment with bits of code or regexes until the cows come home:</source>
          <target state="translated">유용한가요? 거의 모든 것을 평가하고 소가 집에 돌아올 때까지 약간의 코드 또는 정규식을 실험 해 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe3be132ee381a9663c71ca2a6207a31717e7705" translate="yes" xml:space="preserve">
          <source>User Datagram Protocol, the typical way to send &lt;b&gt;datagrams&lt;/b&gt; over the Internet.</source>
          <target state="translated">인터넷을 통해 &lt;b&gt;데이터 그램&lt;/b&gt; 을 보내는 일반적인 방법 인 사용자 데이터 그램 프로토콜 .</target>
        </trans-unit>
        <trans-unit id="3056b101498f0c6196c04d621ba22bd3175219d6" translate="yes" xml:space="preserve">
          <source>User Groups</source>
          <target state="translated">사용자 그룹</target>
        </trans-unit>
        <trans-unit id="4325c61b581bf8fe6a3e2400d58928e7b9a55496" translate="yes" xml:space="preserve">
          <source>User Interfaces</source>
          <target state="translated">사용자 인터페이스</target>
        </trans-unit>
        <trans-unit id="84956701ef226c2e8ce9adf59fb3ab8347d15b4f" translate="yes" xml:space="preserve">
          <source>User mounts override system mounts.</source>
          <target state="translated">사용자 마운트는 시스템 마운트보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="158586304dc1eef989a278eac13c889b9d8fde82" translate="yes" xml:space="preserve">
          <source>User pragmata store their state by writing to the magical hash &lt;code&gt;%^H&lt;/code&gt; , hence these two routines manipulate it. The state information in &lt;code&gt;%^H&lt;/code&gt; is stored in the optree, and can be retrieved read-only at runtime with &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt;, at index 10 of the list of returned results. In the example pragma, retrieval is encapsulated into the routine &lt;code&gt;in_effect()&lt;/code&gt; , which takes as parameter the number of call frames to go up to find the value of the pragma in the user's script. This uses &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; to determine the value of &lt;code&gt;$^H{&quot;myint/in_effect&quot;}&lt;/code&gt; when each line of the user's script was called, and therefore provide the correct semantics in the subroutine implementing the overloaded addition.</source>
          <target state="translated">사용자 pragmata는 마법의 해시 &lt;code&gt;%^H&lt;/code&gt; 에 기록하여 상태를 저장하므로이 두 루틴이이를 조작합니다. &lt;code&gt;%^H&lt;/code&gt; 의 상태 정보 는 optree에 저장되며 런타임에 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; 를 사용하여 반환 된 결과 목록의 인덱스 10 에서 읽기 전용으로 검색 할 수 있습니다 . 예제 pragma에서 검색은 &lt;code&gt;in_effect()&lt;/code&gt; 루틴으로 캡슐화되며 , 사용자 스크립트에서 pragma의 값을 찾기 위해 호출 프레임 수를 매개 변수로 사용합니다. 이것은 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; 를 사용하여 사용자 스크립트의 각 라인이 호출 될 때 &lt;code&gt;$^H{&quot;myint/in_effect&quot;}&lt;/code&gt; 의 값을 판별 하므로 과부하 된 추가를 구현하는 서브 루틴에 올바른 의미를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="94ffd06de7d6ceb23de314937b25f1039f95408e" translate="yes" xml:space="preserve">
          <source>User-Defined Case Mappings (for serious hackers only)</source>
          <target state="translated">사용자 정의 사례 매핑 (심각한 해커 만 해당)</target>
        </trans-unit>
        <trans-unit id="021fce3b8ed64c4c7ea81643b8e56e61d1fb88d9" translate="yes" xml:space="preserve">
          <source>User-Defined Character Properties</source>
          <target state="translated">사용자 정의 문자 속성</target>
        </trans-unit>
        <trans-unit id="8bdd4953a2aaaf5875fdc9a6599aaccd9331209f" translate="yes" xml:space="preserve">
          <source>User-defined subroutines may choose to care whether they are being called in a void, scalar, or list context. Most subroutines do not need to bother, though. That's because both scalars and lists are automatically interpolated into lists. See &lt;a href=&quot;functions/wantarray&quot;&gt;wantarray&lt;/a&gt; for how you would dynamically discern your function's calling context.</source>
          <target state="translated">사용자 정의 서브 루틴은 void, 스칼라 또는 목록 컨텍스트에서 호출되는지 여부를 관리하도록 선택할 수 있습니다. 그러나 대부분의 서브 루틴은 귀찮게 할 필요가 없습니다. 스칼라와리스트가 자동으로리스트에 보간되기 때문입니다. 함수의 호출 컨텍스트를 동적으로 식별하는 방법에 대해서는 &lt;a href=&quot;functions/wantarray&quot;&gt;wantarray&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="04b3f7fd0444d60354dbca146d3a101a49d16754" translate="yes" xml:space="preserve">
          <source>User-defined subroutines to handle options</source>
          <target state="translated">옵션을 처리하기위한 사용자 정의 서브 루틴</target>
        </trans-unit>
        <trans-unit id="c2c8678cd5e840290be2cdc362d36d4139b6821c" translate="yes" xml:space="preserve">
          <source>User-mode threads are threads that live entirely within a program and its libraries. In this model, the OS knows nothing about threads. As far as it's concerned, your process is just a process.</source>
          <target state="translated">사용자 모드 스레드는 프로그램과 라이브러리 내에 완전히 존재하는 스레드입니다. 이 모델에서 OS는 스레드에 대해 아무것도 모릅니다. 문제가되는 한, 프로세스는 프로세스 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="5e4e64aff0ba218cc4ec3a0635d41a38135e5b7e" translate="yes" xml:space="preserve">
          <source>User::grent</source>
          <target state="translated">User::grent</target>
        </trans-unit>
        <trans-unit id="5e0090a6a9d55bf78a5f019a9872cf7e4308c124" translate="yes" xml:space="preserve">
          <source>User::grent - by-name interface to Perl's built-in getgr*() functions</source>
          <target state="translated">User :: grent-Perl의 내장 getgr * () 함수에 대한 이름 별 인터페이스</target>
        </trans-unit>
        <trans-unit id="a2bda03ecc876d5bf92fb7707c3e5918fe5160b9" translate="yes" xml:space="preserve">
          <source>User::pwent</source>
          <target state="translated">User::pwent</target>
        </trans-unit>
        <trans-unit id="c4a9575f1a385e0c0339a3155858dfaa2331a364" translate="yes" xml:space="preserve">
          <source>User::pwent - by-name interface to Perl's built-in getpw*() functions</source>
          <target state="translated">User :: pwent-Perl의 내장 getpw * () 함수에 대한 이름 별 인터페이스</target>
        </trans-unit>
        <trans-unit id="5dc8b5002e114f1d2e85c5074d99f142b8068508" translate="yes" xml:space="preserve">
          <source>Users of &lt;b&gt;vi&lt;/b&gt; should also look into &lt;b&gt;vim&lt;/b&gt; and &lt;b&gt;gvim&lt;/b&gt;, the mousey and windy version, for coloring of Perl keywords.</source>
          <target state="translated">&lt;b&gt;vi&lt;/b&gt; 사용자는 펄 키워드의 색칠을 위해 마우스와 바람이 많은 버전 인 &lt;b&gt;vim&lt;/b&gt; 과 &lt;b&gt;gvim을&lt;/b&gt; 살펴 봐야 합니다.</target>
        </trans-unit>
        <trans-unit id="ba4927255994b8f9be2cf9331a8ecd222ec16885" translate="yes" xml:space="preserve">
          <source>Users of &lt;code&gt;Emacs&lt;/code&gt; would appreciate it very much, especially with &lt;code&gt;CPerl&lt;/code&gt; mode loaded. You need to get latest &lt;code&gt;pod2info&lt;/code&gt; from &lt;code&gt;CPAN&lt;/code&gt; , or, alternately, prebuilt info pages.</source>
          <target state="translated">&lt;code&gt;Emacs&lt;/code&gt; 사용자는 특히 &lt;code&gt;CPerl&lt;/code&gt; 모드가로드 된 경우 매우 감사합니다 . &lt;code&gt;CPAN&lt;/code&gt; 에서 최신 &lt;code&gt;pod2info&lt;/code&gt; 또는 사전 빌드 된 정보 페이지를 가져와야 합니다.</target>
        </trans-unit>
        <trans-unit id="06b3fe1f4b99439f17ea2b119c5a26871e0414f8" translate="yes" xml:space="preserve">
          <source>Users of Emacs would appreciate it very much, especially with &lt;code&gt;CPerl&lt;/code&gt; mode loaded. You need to get latest &lt;code&gt;pod2texi&lt;/code&gt; from &lt;code&gt;CPAN&lt;/code&gt; , or, alternately, the prebuilt info pages.</source>
          <target state="translated">Emacs 사용자는 특히 &lt;code&gt;CPerl&lt;/code&gt; 모드가로드 된 경우 매우 감사합니다 . &lt;code&gt;CPAN&lt;/code&gt; 또는 사전 빌드 된 정보 페이지 에서 최신 &lt;code&gt;pod2texi&lt;/code&gt; 를 가져와야 합니다.</target>
        </trans-unit>
        <trans-unit id="3d37ee7e83ea8423b48a5461ba1696b2c860b013" translate="yes" xml:space="preserve">
          <source>Users of these operating systems may also wish to make use of scripts such as</source>
          <target state="translated">이러한 운영 체제의 사용자는 다음과 같은 스크립트를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f2a2d2f970a65c0f069bae958a29d5ba1eb82f2" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;$Config{pod2html}&lt;/code&gt; to setup default options.</source>
          <target state="translated">&lt;code&gt;$Config{pod2html}&lt;/code&gt; 을 사용 하여 기본 옵션을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="1bd665ac74aefc48e3c1dedcb2f5bc582892064f" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;strlen&lt;/code&gt; to get the length of &lt;code&gt;name&lt;/code&gt; , then calls &lt;code&gt;get_cvn_flags&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;strlen&lt;/code&gt; 을 사용 하여 &lt;code&gt;name&lt;/code&gt; 의 길이를 얻은 다음 &lt;code&gt;get_cvn_flags&lt;/code&gt; 를 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="f2d33b5a65c41c46d97dad83c368ba4c31fcb025" translate="yes" xml:space="preserve">
          <source>Uses Bourne shell from &lt;code&gt;$exedir/../dll/sh/ksh.exe&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$exedir/../dll/sh/ksh.exe&lt;/code&gt; Bourne 쉘을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="8535753d5756d418d77c7eeafa2177abcd178411" translate="yes" xml:space="preserve">
          <source>Uses Encode::from_to for conversion. This is the default.</source>
          <target state="translated">변환에 Encode :: from_to를 사용합니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="a78266e003805d15484a613ae3192f24c4a5e63f" translate="yes" xml:space="preserve">
          <source>Uses a single private buffer so if you want to format several strings you must explicitly copy the earlier strings away (and free the copies when you are done).</source>
          <target state="translated">단일 개인 버퍼를 사용하므로 여러 문자열을 형식화하려면 이전 문자열을 명시 적으로 복사해야합니다 (완료되면 사본을 비우십시오).</target>
        </trans-unit>
        <trans-unit id="fce3093136a7d2638de72d1f6b19af95e4dd37ba" translate="yes" xml:space="preserve">
          <source>Uses for the &lt;code&gt;export_fail&lt;/code&gt; method include giving better error messages for some symbols and performing lazy architectural checks (put more symbols into &lt;code&gt;@EXPORT_FAIL&lt;/code&gt; by default and then take them out if someone actually tries to use them and an expensive check shows that they are usable on that platform).</source>
          <target state="translated">에 사용 &lt;code&gt;export_fail&lt;/code&gt; 의 방법은 일부 기호에 대한 더 나은 오류 메시지를주고 게으른 건축 검사 (에 더 많은 문자를 넣어 수행을 포함 &lt;code&gt;@EXPORT_FAIL&lt;/code&gt; 기본적으로 다음 사람이 실제로 그에 사용할 수 있음을 그들과 비싼 검사 프로그램을 사용하려고하는 경우를 꺼내 플랫폼).</target>
        </trans-unit>
        <trans-unit id="ff51dbb10de4f730c3d10cc9e64e2774f2375b58" translate="yes" xml:space="preserve">
          <source>Uses the same algorithm as getcwd(). Symbolic links and relative-path components (&quot;.&quot; and &quot;..&quot;) are resolved to return the canonical pathname, just like realpath(3).</source>
          <target state="translated">getcwd ()와 동일한 알고리즘을 사용합니다. 심볼릭 링크와 상대 경로 구성 요소 ( &quot;.&quot;및 &quot;..&quot;)는 realpath (3)와 같이 정식 경로 이름을 반환하도록 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="9086306446f5bee7eedc51873f977f5639cf3890" translate="yes" xml:space="preserve">
          <source>Uses the value of EXPR as a filename and executes the contents of the file as a Perl script.</source>
          <target state="translated">EXPR의 값을 파일 이름으로 사용하고 파일의 내용을 Perl 스크립트로 실행합니다.</target>
        </trans-unit>
        <trans-unit id="b191f377109544e991562530e982f3ab20d97a29" translate="yes" xml:space="preserve">
          <source>Uses the value of a previous getpos call to return to a previously visited position. Returns &quot;0 but true&quot; on success, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="translated">이전 getpos 호출 값을 사용하여 이전에 방문한 위치로 돌아갑니다. 성공하면 &quot;0이지만 true&quot;를 반환 하고 실패 하면 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="c25de2e83e9fceeee022a34e378748baf14ac201" translate="yes" xml:space="preserve">
          <source>Using</source>
          <target state="translated">Using</target>
        </trans-unit>
        <trans-unit id="2352b330d6ed131b0eecd5f3967c2801dc2e677c" translate="yes" xml:space="preserve">
          <source>Using &quot;#&quot; as a padding character specifies a numeric field, with right justification. An optional &quot;.&quot; defines the position of the decimal point. With a &quot;0&quot; (zero) instead of the first &quot;#&quot;, the formatted number will be padded with leading zeroes if necessary. A special numeric field is blanked out if the value is undefined. If the resulting value would exceed the width specified the field is filled with &quot;#&quot; as overflow evidence.</source>
          <target state="translated">패딩 문자로 &quot;#&quot;을 사용하면 오른쪽 자리 맞추기와 함께 숫자 필드가 지정됩니다. 선택적인 &quot;.&quot; 소수점 위치를 정의합니다. 첫 번째 &quot;#&quot;대신 &quot;0&quot;(영)을 사용하면 필요한 경우 형식이 지정된 숫자 앞에 선행 0이 채워집니다. 값이 정의되지 않은 경우 특수 숫자 필드는 비워집니다. 결과 값이 지정된 너비를 초과하면 필드가 오버플로 증거로 &quot;#&quot;으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="4d195a30219da687f66f5ac2e4c6c839d91fc335" translate="yes" xml:space="preserve">
          <source>Using &quot;&amp;gt;&quot; always clobbers or creates. Using &quot;&amp;lt;&quot; never does either. The &quot;+&quot; doesn't change this.</source>
          <target state="translated">&quot;&amp;gt;&quot;를 사용하면 항상 방해를 받거나 생성됩니다. &quot;&amp;lt;&quot;를 사용하면 어느 것도 수행되지 않습니다. &quot;+&quot;는 이것을 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="16cc068fbb7f0118050467d326f37173d537b721" translate="yes" xml:space="preserve">
          <source>Using &quot;pl2bat&quot; has a few problems: the file name gets changed, so scripts that rely on &lt;code&gt;$0&lt;/code&gt; to find what they must do may not run properly; running &quot;pl2bat&quot; replicates the contents of the original script, and so this process can be maintenance intensive if the originals get updated often. A different approach that avoids both problems is possible.</source>
          <target state="translated">&quot;pl2bat&quot;를 사용하면 몇 가지 문제가 있습니다. 파일 이름이 변경되므로 &lt;code&gt;$0&lt;/code&gt; 에 의존하는 스크립트가 제대로 실행되지 않을 수 있습니다. &quot;pl2bat&quot;을 실행하면 원본 스크립트의 내용이 복제되므로 원본이 자주 업데이트되는 경우이 프로세스를 유지 관리해야 할 수도 있습니다. 두 가지 문제를 피하는 다른 접근법이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="05f631394c6e9641817e0e504fc7c43b66232fc2" translate="yes" xml:space="preserve">
          <source>Using $ENV{PERL_DEBUG_MSTATS}</source>
          <target state="translated">$ ENV {PERL_DEBUG_MSTATS} 사용</target>
        </trans-unit>
        <trans-unit id="369ff12968f332b6148e74df2b66edfe0b032cb0" translate="yes" xml:space="preserve">
          <source>Using 'X' and cousins requires you not to use the type identifiers ($@%), just the 'name':</source>
          <target state="translated">'X'와 사촌을 사용하려면 'name'만 형식 식별자 ($ @ %)를 사용하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="2dfddf8d7a196c4e7f1fa3524316075003cbc8ac" translate="yes" xml:space="preserve">
          <source>Using *AutoLoader*'s AUTOLOAD Subroutine</source>
          <target state="translated">* AutoLoader *의 AUTOLOAD 서브 루틴 사용</target>
        </trans-unit>
        <trans-unit id="9094fd1811fd7f32bf808bb09cf11c4c4b959972" translate="yes" xml:space="preserve">
          <source>Using / for Unix. Called by init_main.</source>
          <target state="translated">유닉스에서 / 사용하기. init_main에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="ef6fd37cde410d5e8c4989d291b7ed857f9e1011" translate="yes" xml:space="preserve">
          <source>Using //-comments</source>
          <target state="translated">//-코멘트 사용</target>
        </trans-unit>
        <trans-unit id="5f4a15910e3dadf2cc006c6867eda30e63f7dc0f" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt;:</source>
          <target state="translated">사용 &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;비트를 :: 벡터&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="9e6665571474aeb5014d9a2187041b82aa2b6cf9" translate="yes" xml:space="preserve">
          <source>Using &lt;b&gt;AutoLoader&lt;/b&gt;'s AUTOLOAD Subroutine</source>
          <target state="translated">사용하여 &lt;b&gt;자동로드&lt;/b&gt; 의 AUTOLOAD 서브 루틴을</target>
        </trans-unit>
        <trans-unit id="5cfa1c0592cc7196c9a7f1e7194e067f8fe4c528" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&quot;or&quot;&lt;/code&gt; for assignment is unlikely to do what you want; see below.</source>
          <target state="translated">할당을 위해 &lt;code&gt;&quot;or&quot;&lt;/code&gt; 을 사용 하는 것은 원하는 것을 수행하지 않을 것입니다. 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8a303f25d71d0c242dc6c0e5ae7c606b1bec2045" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;$ENV{PERL_DEBUG_MSTATS}&lt;/code&gt;</source>
          <target state="translated">사용 &lt;code&gt;$ENV{PERL_DEBUG_MSTATS}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6ff3dae92bc192e26ee0eb7af7182c12b0e7db8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;$in_fh-&amp;gt;getline()&lt;/code&gt; , input is read line-by-line and assembled into paragraphs or &quot;blocks&quot; (which are separated by lines containing nothing but whitespace). For each block of POD documentation encountered it will invoke a method to parse the given paragraph.</source>
          <target state="translated">&lt;code&gt;$in_fh-&amp;gt;getline()&lt;/code&gt; 사용하여 입력을 한 줄씩 읽고 단락 또는 &quot;블록&quot;(공백 만 포함하는 행으로 구분)으로 조립합니다. 발생하는 POD 문서의 각 블록에 대해 주어진 단락을 구문 분석하는 메소드를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="f2a68f677fc4720bdeb7e4f8032c1c375f4d6291" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--verbose&lt;/code&gt; on the command line will increment the value of &lt;code&gt;$verbose&lt;/code&gt; . This way the program can keep track of how many times the option occurred on the command line. For example, each occurrence of &lt;code&gt;--verbose&lt;/code&gt; could increase the verbosity level of the program.</source>
          <target state="translated">명령 행에서 &lt;code&gt;--verbose&lt;/code&gt; 를 사용하면 &lt;code&gt;$verbose&lt;/code&gt; 값이 증가합니다 . 이 방법으로 프로그램은 옵션이 명령 행에서 몇 번이나 발생했는지 추적 할 수 있습니다. 예를 들어, &lt;code&gt;--verbose&lt;/code&gt; 가 발생할 때마다 프로그램의 상세 수준이 높아질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ad1d7060df6581913c9f5f84ab874f296c32585" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;-Dusethreads -Duseithreads&lt;/code&gt; rather than &lt;code&gt;-Dusemultiplicity&lt;/code&gt; is more appropriate if you intend to run multiple interpreters concurrently in different threads, because it enables support for linking in the thread libraries of your system with the interpreter.</source>
          <target state="translated">&lt;code&gt;-Dusethreads -Duseithreads&lt;/code&gt; 사용 여러 스레드를 여러 스레드에서 동시에 실행하려는 경우 &lt;code&gt;-Dusemultiplicity&lt;/code&gt; 가 아닌 -Duseithreads 가 더 적합합니다. 이는 시스템의 스레드 라이브러리에서 인터프리터와의 링크 지원을 가능하게하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="61eab4185699c92641d9413479e73b37872fd212" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; out to another perl after loading multiple dlls may result on a DLL baseaddress conflict. The internal cygwin error looks like like the following:</source>
          <target state="translated">사용 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 여러 DLL을로드 한 후 다른 펄 밖으로 것은 DLL의 기본 주소 충돌에 발생할 수 있습니다. 내부 cygwin 오류는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fcca95252686536518c82a86f093a53ca5ff8ade" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; in combination with a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; at the top of your Perl scripts means that the interpreter will pick up certain common programming errors. For instance, in the example above, the final &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; $y&lt;/code&gt; would cause a compile-time error and prevent you from running the program. Using &lt;code&gt;strict&lt;/code&gt; is highly recommended.</source>
          <target state="translated">사용하여 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; A를의 조합 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; Perl 스크립트의 맨 위에는 인터프리터가 특정 프로그래밍 오류를 선택한다는 의미입니다. 예를 들어, 위의 예에서 최종 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; $y&lt;/code&gt; 는 컴파일 타임 오류를 발생시키고 프로그램 실행을 방해합니다. &lt;code&gt;strict&lt;/code&gt; 사용 하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6570099c968b1dac1aeada91a2fa62948e513fde" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt; 사용 :</target>
        </trans-unit>
        <trans-unit id="c4ee3a2331f58e1266f76a324d649c5e7a530542" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(..., $x)&lt;/code&gt; with &lt;code&gt;P&lt;/code&gt; or &lt;code&gt;p&lt;/code&gt; to get the address where &lt;code&gt;$x&lt;/code&gt; is actually stored must be used with circumspection. Perl's internal machinery considers the relation between a variable and that address as its very own private matter and doesn't really care that we have obtained a copy. Therefore:</source>
          <target state="translated">&lt;code&gt;P&lt;/code&gt; 또는 &lt;code&gt;p&lt;/code&gt; 와 함께 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(..., $x)&lt;/code&gt; 을 사용하여 &lt;code&gt;$x&lt;/code&gt; 가 실제로 저장된 주소를 얻으려면주의 를 기울여야합니다. Perl의 내부 기계는 변수와 해당 주소 간의 관계를 고유 한 사적인 문제로 간주하며 실제로 사본을 얻었는지 신경 쓰지 않습니다. 따라서:</target>
        </trans-unit>
        <trans-unit id="f64f7e3c602eac9f0cc5d3fae9a96d9a3eb0bb0b" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">사용 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5fe85d80b5d4e554e757435dadbee8779f515048" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; for larger strings:</source>
          <target state="translated">더 큰 문자열에 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 사용 :</target>
        </trans-unit>
        <trans-unit id="77bac2c89d98d4342e51014bdc1e5dfcf83f7405" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 사용 :</target>
        </trans-unit>
        <trans-unit id="9b2ba3ba2d555e75ce68454a406fe0f0433207e8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; (or the operator form, &lt;code&gt;&amp;lt;EXPR&amp;gt;&lt;/code&gt; ) as the conditional of a &lt;code&gt;for&lt;/code&gt; loop is shorthand for the following. This behaviour is the same as a &lt;code&gt;while&lt;/code&gt; loop conditional.</source>
          <target state="translated">사용 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; (또는 운영자 형태 &lt;code&gt;&amp;lt;EXPR&amp;gt;&lt;/code&gt; (A)의 조건 등) &lt;code&gt;for&lt;/code&gt; 루프는 다음의 속기이다. 이 동작은 &lt;code&gt;while&lt;/code&gt; 루프 조건부 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="48ea9a8aca48a2ecece519f0da9a5610c9c21b22" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; (perl 5.6+):</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 사용 (perl 5.6+) :</target>
        </trans-unit>
        <trans-unit id="672d9d441ef641164ca3c34a7892f3146881bd19" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 사용 :</target>
        </trans-unit>
        <trans-unit id="46b9c6aa21d990c3320125b6b398a58171b824d2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 사용 :</target>
        </trans-unit>
        <trans-unit id="c96b7be56d606a5173254b9ecaa85e8754516cc1" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;C0&lt;/code&gt; to get Unicode characters while using &lt;code&gt;U0&lt;/code&gt; to get</source>
          <target state="translated">&lt;code&gt;C0&lt;/code&gt; 을 사용하여 유니 코드 문자를 가져 오는 동안 &lt;code&gt;U0&lt;/code&gt; 을 사용하여</target>
        </trans-unit>
        <trans-unit id="bd76d249b9cc849b475f04243607bd5ac606dc24" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;EVERY&lt;/code&gt; methods</source>
          <target state="translated">&lt;code&gt;EVERY&lt;/code&gt; 방법 사용</target>
        </trans-unit>
        <trans-unit id="0ecd1ec7133eb6a574dc47a89387830a895fdc67" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;autouse&lt;/code&gt; will move important steps of your program's execution from compile time to runtime. This can</source>
          <target state="translated">사용 &lt;code&gt;autouse&lt;/code&gt; 은 런타임에 컴파일 시간에서 프로그램의 실행의 중요한 단계를 이동합니다. 이것은 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="2c94e397182ad35f0199796c485d6c8aec54e54f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;gen_extract_tagged&lt;/code&gt; to create extraction functions for specific tags is a good idea if those functions are going to be called more than once, since their performance is typically twice as good as the more general-purpose &lt;code&gt;extract_tagged&lt;/code&gt; .</source>
          <target state="translated">사용 &lt;code&gt;gen_extract_tagged&lt;/code&gt; 특정 태그에 대한 추출 기능을 만들려면 이러한 기능은 더 일반적인 목적은 그들의 성능이 좋은 두 배 일반적이기 때문에, 한 번 이상 호출 위하여려고하는 경우에 좋은 아이디어이다 &lt;code&gt;extract_tagged&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b55d7735ea783b5e6004e758bd55af4f884bf92" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;lib&lt;/code&gt; warns if none of the specified libraries can be found and &lt;a href=&quot;math/bigint&quot;&gt;Math::BigInt&lt;/a&gt; did fall back to one of the default libraries. To suppress this warning, use &lt;code&gt;try&lt;/code&gt; instead:</source>
          <target state="translated">&lt;code&gt;lib&lt;/code&gt; 를 사용 하면 지정된 라이브러리를 찾을 수없고 &lt;a href=&quot;math/bigint&quot;&gt;Math :: BigInt&lt;/a&gt; 가 기본 라이브러리 중 하나로 대체 됩니다. 이 경고를 표시하지 않으려면 대신 &lt;code&gt;try&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0ffd8ad58b1a0f4bd73c5c83cc872616c113bd7f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;refaddr()&lt;/code&gt; is unreliable for testing whether or not two shared references are equivalent (e.g., when testing for circular references). Use &lt;a href=&quot;#is_shared-VARIABLE&quot;&gt;is_shared()&lt;/a&gt;, instead:</source>
          <target state="translated">사용 &lt;code&gt;refaddr()&lt;/code&gt; (예를 들어, 원형의 참조를 테스트 할 때) 두 개의 공유 참조 동일 여부 테스트 신뢰할. 대신 &lt;a href=&quot;#is_shared-VARIABLE&quot;&gt;is_shared ()를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ef178ae90603162abddf22f7d9bb0fc3e898af5" translate="yes" xml:space="preserve">
          <source>Using Attributes and Parameters</source>
          <target state="translated">속성 및 매개 변수 사용</target>
        </trans-unit>
        <trans-unit id="03bf2717e06af78329e93ebf453e1e826613e2e4" translate="yes" xml:space="preserve">
          <source>Using B::Concise outside of the O framework</source>
          <target state="translated">O 프레임 워크 외부에서 B :: Concise 사용</target>
        </trans-unit>
        <trans-unit id="18bafced67519d44baeebd7cfdcaf662b62afabc" translate="yes" xml:space="preserve">
          <source>Using DB_File with Berkeley DB version 2 or greater</source>
          <target state="translated">Berkeley DB 버전 2 이상에서 DB_File 사용</target>
        </trans-unit>
        <trans-unit id="97e4ec7dc3ee57617b8c25e5da7b2620a2b30764" translate="yes" xml:space="preserve">
          <source>Using EVERY methods</source>
          <target state="translated">모든 방법 사용</target>
        </trans-unit>
        <trans-unit id="eaf5424654cdf470f964dbc03078a17cf18e6b68" translate="yes" xml:space="preserve">
          <source>Using Encode</source>
          <target state="translated">인코딩 사용</target>
        </trans-unit>
        <trans-unit id="b3c01fd9731ccf33cc32d289966ab7fb5c9b6f88" translate="yes" xml:space="preserve">
          <source>Using Fill Mode</source>
          <target state="translated">채우기 모드 사용</target>
        </trans-unit>
        <trans-unit id="5cb7c472310d76de5801b53745949b0358783728" translate="yes" xml:space="preserve">
          <source>Using Filter::Simple and Exporter together</source>
          <target state="translated">Filter :: Simple과 Exporter를 함께 사용</target>
        </trans-unit>
        <trans-unit id="8adffc36e41ac8b6ef194fa0464f19be3d960928" translate="yes" xml:space="preserve">
          <source>Using Filter::Simple with an explicit &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine</source>
          <target state="translated">명시 적 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 서브 루틴 과 함께 Filter :: Simple 사용</target>
        </trans-unit>
        <trans-unit id="4fae20bc9d38356a2d17453bc9b205cc1c897f19" translate="yes" xml:space="preserve">
          <source>Using Filter::Simple with an explicit import subroutine</source>
          <target state="translated">명시 적 가져 오기 서브 루틴과 함께 Filter :: Simple 사용</target>
        </trans-unit>
        <trans-unit id="1ae3259ed8aaec135b40d3c0be57406133a41acb" translate="yes" xml:space="preserve">
          <source>Using GIMME_V</source>
          <target state="translated">GIMME_V 사용</target>
        </trans-unit>
        <trans-unit id="1d57725fba088f8b24d927a2eedcfd4e936a608f" translate="yes" xml:space="preserve">
          <source>Using GNU's gcc for building Perl</source>
          <target state="translated">Perl을 빌드하기 위해 GNU의 gcc 사용</target>
        </trans-unit>
        <trans-unit id="e882257535f024e0d015187d37538f63a8847fce" translate="yes" xml:space="preserve">
          <source>Using G_EVAL</source>
          <target state="translated">G_EVAL 사용</target>
        </trans-unit>
        <trans-unit id="295eff162915babd344155c6be19db49d4d64f02" translate="yes" xml:space="preserve">
          <source>Using G_KEEPERR</source>
          <target state="translated">G_KEEPERR 사용</target>
        </trans-unit>
        <trans-unit id="16d5f49af97261f97893047f771a98e55443d77c" translate="yes" xml:space="preserve">
          <source>Using Large Files with Perl</source>
          <target state="translated">Perl과 함께 큰 파일 사용</target>
        </trans-unit>
        <trans-unit id="317a1b556565aa526e2b302cc529d9bc9bad8e03" translate="yes" xml:space="preserve">
          <source>Using Large Files with Perl &amp;lt; 5L</source>
          <target state="translated">Perl &amp;lt;5L의 대용량 파일 사용</target>
        </trans-unit>
        <trans-unit id="4193d5877700c1da7cc3dc0d04426fb8e279c514" translate="yes" xml:space="preserve">
          <source>Using Large Files with Perl on HP-UX</source>
          <target state="translated">HP-UX에서 Perl과 함께 대용량 파일 사용</target>
        </trans-unit>
        <trans-unit id="bb8e5976c90f08c21142951c3aacf31e66206c3b" translate="yes" xml:space="preserve">
          <source>Using Large Files with Perl on Tru64</source>
          <target state="translated">Tru64에서 Perl과 함께 큰 파일 사용</target>
        </trans-unit>
        <trans-unit id="d35a8b92c0313948c8001f6e0f5a80140456f638" translate="yes" xml:space="preserve">
          <source>Using Math::BigInt::Lite</source>
          <target state="translated">Math :: BigInt :: Lite 사용</target>
        </trans-unit>
        <trans-unit id="f4a9198bb8db024f66e7beddb02099ae2c33e45d" translate="yes" xml:space="preserve">
          <source>Using POSIX::ARG_MAX. Otherwise falling back to 4096.</source>
          <target state="translated">POSIX :: ARG_MAX를 사용합니다. 그렇지 않으면 4096으로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="7f350838d7d6c4618cf4c3624992c0a5fa550ccf" translate="yes" xml:space="preserve">
          <source>Using Perl in &quot;native&quot; BS2000</source>
          <target state="translated">&quot;기본&quot;BS2000에서 Perl 사용</target>
        </trans-unit>
        <trans-unit id="adbb3dbb566652d469c92e143d370e6625a585c4" translate="yes" xml:space="preserve">
          <source>Using Perl in OS/400 PASE</source>
          <target state="translated">OS / 400 PASE에서 Perl 사용</target>
        </trans-unit>
        <trans-unit id="2f91327799ddf2016004ebaf8e8d6bedda20acf6" translate="yes" xml:space="preserve">
          <source>Using Perl in Symbian</source>
          <target state="translated">Symbian에서 Perl 사용</target>
        </trans-unit>
        <trans-unit id="6d719543bb32291214db915134a27443927a8c27" translate="yes" xml:space="preserve">
          <source>Using Perl in the Posix-Shell of BS2000</source>
          <target state="translated">BS2000의 Posix-Shell에서 Perl 사용</target>
        </trans-unit>
        <trans-unit id="84118c01838e699ac467fa37b8bb29a7f8370768" translate="yes" xml:space="preserve">
          <source>Using Perl modules</source>
          <target state="translated">Perl 모듈 사용</target>
        </trans-unit>
        <trans-unit id="028de32ca6d30212bfbce4a0c1bee8b8576b4e69" translate="yes" xml:space="preserve">
          <source>Using Perl modules, which themselves use C libraries, from your C program</source>
          <target state="translated">C 프로그램에서 C 라이브러리를 사용하는 Perl 모듈 사용</target>
        </trans-unit>
        <trans-unit id="0ff9818b99a67e75450030e8c7e7092cbe65f9c0" translate="yes" xml:space="preserve">
          <source>Using Perl on WinCE</source>
          <target state="translated">WinCE에서 Perl 사용</target>
        </trans-unit>
        <trans-unit id="a5580cc662de9455c8f221545dacc2b26132369a" translate="yes" xml:space="preserve">
          <source>Using Perl to Dispose of Temporaries</source>
          <target state="translated">Perl을 사용하여 임시 처리</target>
        </trans-unit>
        <trans-unit id="5320f15bf6dff40493f314bd488164951d124fee" translate="yes" xml:space="preserve">
          <source>Using Perl to dispose of temporaries</source>
          <target state="translated">Perl을 사용하여 임시 처리</target>
        </trans-unit>
        <trans-unit id="b797430b32d30f68c1ea4534b74218539d3aaf64" translate="yes" xml:space="preserve">
          <source>Using Perl's built in conversion of numbers with leading zeros:</source>
          <target state="translated">앞에 0이 붙은 숫자의 Perl 내장 변환 사용 :</target>
        </trans-unit>
        <trans-unit id="f15ed3b42ac67b1af9e23e97edaf317ed0b825a6" translate="yes" xml:space="preserve">
          <source>Using PerlIO and different encodings on ASCII and EBCDIC partitions</source>
          <target state="translated">ASCII 및 EBCDIC 파티션에서 PerlIO 및 다른 인코딩 사용</target>
        </trans-unit>
        <trans-unit id="36711385fbee8d56f23de9017ef392314347e2e0" translate="yes" xml:space="preserve">
          <source>Using References</source>
          <target state="translated">참조 사용</target>
        </trans-unit>
        <trans-unit id="82685302632dac9e1fd31a13c0849aefa5124be7" translate="yes" xml:space="preserve">
          <source>Using Unicode in XS</source>
          <target state="translated">XS에서 유니 코드 사용</target>
        </trans-unit>
        <trans-unit id="998956ebf62d14d931cc7ad656bc083d855b7aba" translate="yes" xml:space="preserve">
          <source>Using XS With C++</source>
          <target state="translated">C ++에서 XS 사용</target>
        </trans-unit>
        <trans-unit id="dac1e6f7cf5fb38291cdecac855edeefdf437f99" translate="yes" xml:space="preserve">
          <source>Using \ for Windows, except for &quot;gmake&quot; where it is /.</source>
          <target state="translated">/ 인 &quot;gmake&quot;를 제외하고 Windows 용 \를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8137c8c1ed484dbce9760788d8ea8483549cf1f0" translate="yes" xml:space="preserve">
          <source>Using _t/harness_ for testing</source>
          <target state="translated">테스트에 _t / harness_ 사용</target>
        </trans-unit>
        <trans-unit id="4f4b906f20b028b71f5628fd6f90032d406f6155" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;__WARN__&lt;/code&gt; handler provides a powerful way to silence all warnings (even the so-called mandatory ones). An example:</source>
          <target state="translated">&lt;code&gt;__WARN__&lt;/code&gt; 핸들러를 사용하면 모든 경고 (소위 필수 경고 포함)를 침묵시키는 강력한 방법을 제공합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="b4b4ca6e1deabca931233328798f7fbb48c8c07b" translate="yes" xml:space="preserve">
          <source>Using a closure as a function template allows us to generate many functions that act similarly. Suppose you wanted functions named after the colors that generated HTML font changes for the various colors:</source>
          <target state="translated">클로저를 함수 템플릿으로 사용하면 비슷하게 작동하는 많은 함수를 생성 할 수 있습니다. 다양한 색상에 대해 HTML 글꼴 변경을 생성 한 색상의 이름을 딴 함수를 원한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="3428ced333d3144f878ace997075432ead893fb6" translate="yes" xml:space="preserve">
          <source>Using a hash reference is</source>
          <target state="translated">해시 참조 사용은</target>
        </trans-unit>
        <trans-unit id="336ecaf20b3b819b2df81459841f824dd710f158" translate="yes" xml:space="preserve">
          <source>Using a lexical pragma to enable or disable legacy behavior should be considered when appropriate, and in the absence of any pragma legacy behavior should be enabled. Which backward-incompatible changes are controlled implicitly by a 'use v5.x.y' is a decision which should be made by the pumpking in consultation with the community.</source>
          <target state="translated">적절한 경우 어휘 pragma를 사용하여 레거시 동작을 활성화 또는 비활성화하는 것을 고려해야하며, pragma 레거시 동작이없는 경우 활성화해야합니다. 'use v5.xy'에 의해 이전 버전과 호환되지 않는 변경이 암시 적으로 제어되는 것은 커뮤니티와상의하여 pumpking에 의해 결정되어야합니다.</target>
        </trans-unit>
        <trans-unit id="37d264a714cc8982079f31352e5a02a2d407c9ec" translate="yes" xml:space="preserve">
          <source>Using a reference as a string produces both its referent's type, including any package blessing as described in &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;, as well as the numeric address expressed in hex. The ref() operator returns just the type of thing the reference is pointing to, without the address. See &lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt; for details and examples of its use.</source>
          <target state="translated">참조를 문자열로 사용하면 &lt;a href=&quot;perlobj&quot;&gt;perlobj에&lt;/a&gt; 설명 된대로 패키지 축복과 16 진수로 표현 된 숫자 주소를 포함하여 참조 유형이 생성 됩니다. ref () 연산자는 주소없이 참조가 가리키는 유형 만 반환합니다. 자세한 사용법과 사용 예는 &lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="178dbf3b1655da796ad383968646cf6aaa7b961a" translate="yes" xml:space="preserve">
          <source>Using a regular Perl string as a key or value for a DBM hash will trigger a wide character exception if any codepoints won&amp;rsquo;t fit into a byte. Here&amp;rsquo;s how to manually manage the translation:</source>
          <target state="translated">코드 포인트가 바이트에 맞지 않으면 DBM 해시의 키 또는 값으로 일반 Perl 문자열을 사용하면 넓은 문자 예외가 트리거됩니다. 번역을 수동으로 관리하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="544cb5d954d39b68ec105da285e699133ee66333" translate="yes" xml:space="preserve">
          <source>Using a slice on the lefthand side of the assignment supplies list context to the righthand side. This can lead to unexpected results. For instance, if you want to read a single line from a filehandle, assigning to a scalar value is fine:</source>
          <target state="translated">과제의 왼쪽에있는 슬라이스를 사용하면 오른쪽에 목록 컨텍스트가 제공됩니다. 예기치 않은 결과가 발생할 수 있습니다. 예를 들어, 파일 핸들에서 단일 행을 읽으려면 스칼라 값을 지정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="047ab6347496bdbb043bb75da5faf973242f2e7a" translate="yes" xml:space="preserve">
          <source>Using a source-level debugger</source>
          <target state="translated">소스 레벨 디버거 사용</target>
        </trans-unit>
        <trans-unit id="5e1e5b1c335e1407e117badbc02a20174cee06fd" translate="yes" xml:space="preserve">
          <source>Using a string or number as a reference produces a symbolic reference, as explained above. Using a reference as a number produces an integer representing its storage location in memory. The only useful thing to be done with this is to compare two references numerically to see whether they refer to the same location.</source>
          <target state="translated">문자열 또는 숫자를 참조로 사용하면 위에서 설명한대로 기호 참조가 생성됩니다. 참조를 숫자로 사용하면 메모리의 저장 위치를 ​​나타내는 정수가 생성됩니다. 이 작업을 수행하는 데 유용한 유일한 방법은 두 참조를 숫자로 비교하여 동일한 위치를 참조하는지 여부를 확인하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d9e91a5896764f48c6ace56fa4d53091e1acc312" translate="yes" xml:space="preserve">
          <source>Using a subroutine as part of your sort is a powerful way to get exactly what you want, but will usually be slower than the built-in</source>
          <target state="translated">서브 루틴을 정렬의 일부로 사용하는 것은 원하는 것을 정확하게 얻을 수있는 강력한 방법이지만 일반적으로 내장보다 느립니다.</target>
        </trans-unit>
        <trans-unit id="2a79ecdd0e9982d50231f84c62b552b6746f4f38" translate="yes" xml:space="preserve">
          <source>Using a value of &lt;code&gt;'IGNORE'&lt;/code&gt; usually has the effect of ignoring the signal, except for the &lt;code&gt;CHLD&lt;/code&gt; signal. See &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for more about this special case.</source>
          <target state="translated">&lt;code&gt;'IGNORE'&lt;/code&gt; 값을 사용하면 일반적으로 &lt;code&gt;CHLD&lt;/code&gt; 신호를 제외하고 신호를 무시하는 효과가 있습니다. 이 특별한 경우에 대한 자세한 내용은 &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4df5e3fd8acd272c23a1963f6dc8693fe3a9c164" translate="yes" xml:space="preserve">
          <source>Using an indirect object with &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; is also more secure. This usage (which also works fine with system()) forces interpretation of the arguments as a multivalued list, even if the list had just one argument. That way you're safe from the shell expanding wildcards or splitting up words with whitespace in them.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 과 함께 간접 객체를 사용하는 것이 더 안전합니다. 이 사용법 (system ()에서도 잘 작동 함)은 목록에 인수가 하나 뿐인 경우에도 인수를 다중 값 목록으로 해석합니다. 그렇게하면 쉘에서 와일드 카드를 확장하거나 공백이있는 단어를 나누는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="44d98963d401217f7be5255c87293a2853856e67" translate="yes" xml:space="preserve">
          <source>Using an indirect object with &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; is also more secure. This usage (which also works fine with system()) forces interpretation of the arguments as a multivalued list, even if the list had just one argument. That way you're safe from the shell expanding wildcards or splitting up words with whitespace in them.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 과 함께 간접 객체를 사용하는 것이 더 안전합니다. 이 사용법 (system ()에서도 잘 작동 함)은 목록에 인수가 하나 뿐인 경우에도 인수를 다중 값 목록으로 해석합니다. 그렇게하면 쉘에서 와일드 카드를 확장하거나 공백이있는 단어를 나누는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="604eef1aa9c7558fedd10f863a9440cef58a337c" translate="yes" xml:space="preserve">
          <source>Using an installation prefix of '/usr' will result in a directory layout that mirrors that of Apple's default Perl, with core modules stored in '/System/Library/Perl/${version}', CPAN modules stored in '/Library/Perl/${version}', and the addition of '/Network/Library/Perl/${version}' to @INC for modules that are stored on a file server and used by many Macs.</source>
          <target state="translated">설치 접두사 '/ usr'을 사용하면 디렉토리 레이아웃이 Apple의 기본 Perl과 동일하게 표시되고 코어 모듈은 '/ System / Library / Perl / $ {version}'에 저장되고 CPAN 모듈은 '/ Library /에 저장됩니다. 파일 서버에 저장되어 많은 Mac에서 사용하는 모듈을 위해 Perl / $ {version} '및 @INC에'/ Network / Library / Perl / $ {version} '추가.</target>
        </trans-unit>
        <trans-unit id="aa23c98317fa566c477de2941d147e87b315123e" translate="yes" xml:space="preserve">
          <source>Using an object as the left operand is allowed, although not very useful. Smartmatching rules take precedence over overloading, so even if the object in the left operand has smartmatch overloading, this will be ignored. A left operand that is a non-overloaded object falls back on a string or numeric comparison of whatever the &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; operator returns. That means that</source>
          <target state="translated">유용하지는 않지만 왼쪽 피연산자로 객체를 사용할 수 있습니다. 스마트 매칭 규칙은 오버로드보다 우선합니다. 따라서 왼쪽 피연산자의 객체에 스마트 매치 오버로드가 있어도 무시됩니다. 오버로드되지 않은 객체 인 왼쪽 피연산자는 &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 연산자가 반환 하는 것에 대한 문자열 또는 숫자 비교로 대체 됩니다. 그 의미는</target>
        </trans-unit>
        <trans-unit id="6e3237ae31bb37c81782ea50be28770f0de2555e" translate="yes" xml:space="preserve">
          <source>Using any of the above invocations, the first argument to the constructor is always the corresponding package name (or object reference). No other arguments are required, but if desired, an associative array (or hash-table) my be passed to the &lt;b&gt;new()&lt;/b&gt; constructor, as in:</source>
          <target state="translated">위의 호출 중 하나를 사용하면 생성자에 대한 첫 번째 인수는 항상 해당 패키지 이름 (또는 객체 참조)입니다. 다른 인수는 필요하지 않지만 원하는 경우 연관 배열 (또는 해시 테이블)을 다음과 같이 &lt;b&gt;new ()&lt;/b&gt; 생성자에 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="8097e70784bcbb030b53b18d1acb24cd21f46737" translate="yes" xml:space="preserve">
          <source>Using arguments of the form &lt;code&gt;-Ldir&lt;/code&gt; and &lt;code&gt;-lname&lt;/code&gt; is recommended.</source>
          <target state="translated">&lt;code&gt;-Ldir&lt;/code&gt; 및 &lt;code&gt;-lname&lt;/code&gt; 형식의 인수를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f6161aa0cd787955761dec12d0177c3ac026e9b0" translate="yes" xml:space="preserve">
          <source>Using call_argv</source>
          <target state="translated">call_argv 사용</target>
        </trans-unit>
        <trans-unit id="9134163152acbc5710de0bd418aa078593a2b9c2" translate="yes" xml:space="preserve">
          <source>Using call_method</source>
          <target state="translated">call_method 사용</target>
        </trans-unit>
        <trans-unit id="b881b2dfc007740bbb57d40d5226f14e171509f9" translate="yes" xml:space="preserve">
          <source>Using call_sv</source>
          <target state="translated">call_sv 사용</target>
        </trans-unit>
        <trans-unit id="fa52cf5ccb980442f1ec3e9f0afd04690158c461" translate="yes" xml:space="preserve">
          <source>Using caret fields can produce lines where all fields are blank. You can suppress such lines by putting a &quot;~&quot; (tilde) character anywhere in the line. The tilde will be translated to a space upon output.</source>
          <target state="translated">캐럿 필드를 사용하면 모든 필드가 비어있는 행이 생성 될 수 있습니다. 줄의 아무 곳에 나 &quot;~&quot;(물결표) 문자를 넣어 이러한 줄을 표시하지 않을 수 있습니다. 물결표는 출력시 공백으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="3b35e7b174dfce328e49d2c9b54ef677263d0168" translate="yes" xml:space="preserve">
          <source>Using caseless (&lt;code&gt;/i&lt;/code&gt;) regular expression matching.</source>
          <target state="translated">대소 문자를 구분하지 않는 ( &lt;code&gt;/i&lt;/code&gt; ) 정규식 일치를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="912a2aec3bed273542aa33d8ea10bb43e6f23900" translate="yes" xml:space="preserve">
          <source>Using character classes</source>
          <target state="translated">캐릭터 클래스 사용</target>
        </trans-unit>
        <trans-unit id="0ed204e094dc9752d186724902c15a617f19dc27" translate="yes" xml:space="preserve">
          <source>Using diagnostics to get stack traces from a misbehaving script:</source>
          <target state="translated">진단을 사용하여 오작동 스크립트에서 스택 추적 가져 오기 :</target>
        </trans-unit>
        <trans-unit id="6d1350125897c58fd7a177587a74cb5b6d024e7d" translate="yes" xml:space="preserve">
          <source>Using double angle brackets inside of a while causes the open to use the three argument form (with the second argument being &lt;code&gt;&amp;lt;&lt;/code&gt; ), so all arguments in &lt;code&gt;ARGV&lt;/code&gt; are treated as literal filenames (including &lt;code&gt;&quot;-&quot;&lt;/code&gt; ). (Note that for convenience, if you use &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; and if &lt;code&gt;@ARGV&lt;/code&gt; is empty, it will still read from the standard input.)</source>
          <target state="translated">while 안에 이중 꺾쇠 괄호를 사용하면 open에서 세 개의 인수 형식 (두 번째 인수가 &lt;code&gt;&amp;lt;&lt;/code&gt; )을 사용하므로 &lt;code&gt;ARGV&lt;/code&gt; 의 모든 인수는 리터럴 파일 이름 ( &lt;code&gt;&quot;-&quot;&lt;/code&gt; 포함)으로 처리됩니다 . 편의상 &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; 를 사용 하고 &lt;code&gt;@ARGV&lt;/code&gt; 가 비어 있으면 여전히 표준 입력에서 읽습니다.</target>
        </trans-unit>
        <trans-unit id="87082cc66c652c8a0a8c6cf8ba8fff9479b0be7a" translate="yes" xml:space="preserve">
          <source>Using either $MM-&amp;gt;{uc $var} || $Config{lc $var}, it will attempt to replace it's $prefix with a $new_prefix.</source>
          <target state="translated">$ MM-&amp;gt; {uc $ var} || $ Config {lc $ var}, $ prefix를 $ new_prefix로 교체하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="215bd29754319db34f811a8f9488126e67fb90a8" translate="yes" xml:space="preserve">
          <source>Using embedded Perl with POSIX locales</source>
          <target state="translated">POSIX 로케일과 함께 임베디드 Perl 사용</target>
        </trans-unit>
        <trans-unit id="b18845c29a07642058d0aa5ccceaac4ae90f9d59" translate="yes" xml:space="preserve">
          <source>Using gcc statement expressions</source>
          <target state="translated">gcc 문 표현식 사용</target>
        </trans-unit>
        <trans-unit id="2fe92cd4a689f7ce76bfa5b984e6c38acace0732" translate="yes" xml:space="preserve">
          <source>Using gcc-3.x (tested with 3.0.4, 3.1, and 3.2) now works out of the box, as do recent gcc-2.9 builds available directly from IBM as part of their Linux compatibility packages, available here:</source>
          <target state="translated">gcc-3.x (3.0.4, 3.1 및 3.2로 테스트)를 사용하면 Linux 호환성 패키지의 일부로 IBM에서 직접 사용할 수있는 최신 gcc-2.9 빌드와 마찬가지로 즉시 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdb0c9c540b125781f1757da970ccae106c403a1" translate="yes" xml:space="preserve">
          <source>Using gdb to look at specific parts of a program</source>
          <target state="translated">gdb를 사용하여 프로그램의 특정 부분보기</target>
        </trans-unit>
        <trans-unit id="57bf0c1d6a34f5d8784552210b62d448a2b10410" translate="yes" xml:space="preserve">
          <source>Using gdb to look at what the parser/lexer are doing</source>
          <target state="translated">gdb를 사용하여 파서 / 렉서가 수행하는 작업 확인</target>
        </trans-unit>
        <trans-unit id="29fde3627eec5ec683270fb27481ef8c0d1c38c6" translate="yes" xml:space="preserve">
          <source>Using independent subexpressions to prevent backtracking</source>
          <target state="translated">역 추적을 방지하기 위해 독립적 하위 표현식 사용</target>
        </trans-unit>
        <trans-unit id="31ab5d33d67aac1b9f2ccad1cbfd447894360c2b" translate="yes" xml:space="preserve">
          <source>Using logically paired delimiters can be even more readable:</source>
          <target state="translated">논리적으로 구분 된 구분 기호를 사용하면 훨씬 더 읽기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="3a44a3d396fc486b4ee2331bfc52809b0dad44df" translate="yes" xml:space="preserve">
          <source>Using methods that do not modify, but test that the contents works:</source>
          <target state="translated">수정하지 않고 내용이 작동하는지 테스트하는 방법 사용 :</target>
        </trans-unit>
        <trans-unit id="b0d1b97f67a06429913567862e9a662a62326468" translate="yes" xml:space="preserve">
          <source>Using methods that do not modify, but test the contents works:</source>
          <target state="translated">수정하지 않고 내용을 테스트하는 방법을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a5aebc39485edc859f77fc91f87d35c5af691252" translate="yes" xml:space="preserve">
          <source>Using methods that do not modify, but testthe contents works:</source>
          <target state="translated">수정하지 않고 내용을 테스트하는 방법을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8d80ea05e0ed4a3e5f034eecf41875e66394f03f" translate="yes" xml:space="preserve">
          <source>Using negation on a single letter option when bundling is in effect is pointless and will result in a warning.</source>
          <target state="translated">번들링이 적용될 때 단일 문자 옵션에 부정을 사용하면 의미가 없으며 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8d592d89e9701f8203326be192c2ab0972d996bc" translate="yes" xml:space="preserve">
          <source>Using open() for IPC</source>
          <target state="translated">IPC에 open () 사용</target>
        </trans-unit>
        <trans-unit id="f8c56b194bd4e8beff577cc65b3f025dea6a56fa" translate="yes" xml:space="preserve">
          <source>Using perl as shipped with HP-UX</source>
          <target state="translated">HP-UX와 함께 제공되는 perl 사용</target>
        </trans-unit>
        <trans-unit id="543f3ae6c47ff0945f0303be3eebde44d6d34ce3" translate="yes" xml:space="preserve">
          <source>Using perl from HP's porting centre</source>
          <target state="translated">HP 포팅 센터에서 Perl 사용</target>
        </trans-unit>
        <trans-unit id="8b05c58f51293f54962b4c8b3d752fd39e7ea984" translate="yes" xml:space="preserve">
          <source>Using perl to connect to Oracle databases through DBI and DBD::Oracle has caused a lot of people many headaches. Read README.hpux in the DBD::Oracle for much more information. The reason to mention it here is that Oracle requires a perl built with libcl and libpthread, the latter even when perl is build without threads. Building perl using all defaults, but still enabling to build DBD::Oracle later on can be achieved using</source>
          <target state="translated">DBI 및 DBD :: Oracle을 통해 Oracle 데이터베이스에 연결하기 위해 perl을 사용하면 많은 사람들이 많은 두통을 일으켰습니다. 자세한 내용은 DBD :: Oracle에서 README.hpux를 읽으십시오. 여기에 언급 한 이유는 Oracle이 libcl 및 libpthread로 빌드 된 perl을 필요로하기 때문이며, 후자는 perl이 스레드없이 빌드되는 경우에도 마찬가지입니다. 모든 기본값을 사용하여 perl을 빌드하지만 나중에 DBD :: Oracle을 계속 빌드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a2126efc34d2ceda4c425a482fb9bb2ca847f69" translate="yes" xml:space="preserve">
          <source>Using perl's built in conversion of &lt;code&gt;0x&lt;/code&gt; notation:</source>
          <target state="translated">펄의 내장 &lt;code&gt;0x&lt;/code&gt; 표기법 변환 사용 :</target>
        </trans-unit>
        <trans-unit id="1d2a5a50232b147e3a169652436928c470a9aa77" translate="yes" xml:space="preserve">
          <source>Using printf formats for non-basic C types</source>
          <target state="translated">비 기본 C 유형에 printf 형식 사용</target>
        </trans-unit>
        <trans-unit id="df5384f5e1467c8d0cf10444a33f9f98d9662cee" translate="yes" xml:space="preserve">
          <source>Using qq(), q(), and qx(), instead of &quot;double quotes&quot;, 'single quotes', and `backticks`, may make one-liners easier to write.</source>
          <target state="translated">&quot;큰 따옴표&quot;, '단일 따옴표'및 '백틱'대신 qq (), q () 및 qx ()를 사용하면 한 줄짜리 문자를 더 쉽게 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="322a6e9972f7fb8edd8295fc130224c62501d62e" translate="yes" xml:space="preserve">
          <source>Using regular expressions in Perl</source>
          <target state="translated">Perl에서 정규 표현식 사용</target>
        </trans-unit>
        <trans-unit id="6fac332e29fd0c799ec1618a5cc40f7221532230" translate="yes" xml:space="preserve">
          <source>Using single-quote as a delimiter protects the command from Perl's double-quote interpolation, passing it on to the shell instead:</source>
          <target state="translated">작은 따옴표를 구분 기호로 사용하면 펄의 큰 따옴표 보간으로부터 명령을 보호하고 대신 셸로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="e361630850aae34ab890ed75be3d3681ddf2f2b5" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; form as an exception trap in libraries does have some issues. Due to the current arguably broken state of &lt;code&gt;__DIE__&lt;/code&gt; hooks, you may wish not to trigger any &lt;code&gt;__DIE__&lt;/code&gt; hooks that user code may have installed. You can use the &lt;code&gt;&lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; $SIG{__DIE__}&lt;/code&gt; construct for this purpose, as this example shows:</source>
          <target state="translated">라이브러리 에서 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; 양식을 예외 트랩으로 사용하면 몇 가지 문제가 있습니다. 현재 논쟁의 여지가있는 &lt;code&gt;__DIE__&lt;/code&gt; 후크 상태로 인해 사용자 코드가 설치했을 수 있는 &lt;code&gt;__DIE__&lt;/code&gt; 후크 를 트리거하지 않을 수 있습니다. 이 예제에서는 다음과 &lt;code&gt;&lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; $SIG{__DIE__}&lt;/code&gt; 목적으로 &lt;a href=&quot;local&quot;&gt;로컬&lt;/a&gt; $ SIG {__ DIE__} 구문을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1af4f95da6bd74e39669d85ff89a3cba96099269" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; form as an exception trap in libraries does have some issues. Due to the current arguably broken state of &lt;code&gt;__DIE__&lt;/code&gt; hooks, you may wish not to trigger any &lt;code&gt;__DIE__&lt;/code&gt; hooks that user code may have installed. You can use the &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $SIG{__DIE__}&lt;/code&gt; construct for this purpose, as this example shows:</source>
          <target state="translated">라이브러리 에서 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; 양식을 예외 트랩으로 사용하면 몇 가지 문제가 있습니다. 현재 논쟁의 여지가있는 &lt;code&gt;__DIE__&lt;/code&gt; 후크 상태로 인해 사용자 코드가 설치했을 수 있는 &lt;code&gt;__DIE__&lt;/code&gt; 후크 를 트리거하지 않을 수 있습니다. 이 예제에서는 다음과 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $SIG{__DIE__}&lt;/code&gt; 목적으로 &lt;a href=&quot;functions/local&quot;&gt;로컬&lt;/a&gt; $ SIG {__ DIE__} 구문을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="de2169c7a04ae8dba7470fca93fa527b85798dbe" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&lt;a href=&quot;functions/hex&quot;&gt;hex&lt;/a&gt;&lt;/code&gt; function:</source>
          <target state="translated">은 Using &lt;code&gt;&lt;a href=&quot;functions/hex&quot;&gt;hex&lt;/a&gt;&lt;/code&gt; 기능 :</target>
        </trans-unit>
        <trans-unit id="1108296e898fc2261dd95f4aa7570d85ddac276e" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; command of Perl debugger (see &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;) one can deduce which operations are overloaded (and which ancestor triggers this overloading). Say, if &lt;code&gt;eq&lt;/code&gt; is overloaded, then the method &lt;code&gt;(eq&lt;/code&gt; is shown by debugger. The method &lt;code&gt;()&lt;/code&gt; corresponds to the &lt;code&gt;fallback&lt;/code&gt; key (in fact a presence of this method shows that this package has overloading enabled, and it is what is used by the &lt;code&gt;Overloaded&lt;/code&gt; function of module &lt;code&gt;overload&lt;/code&gt; ).</source>
          <target state="translated">Perl 디버거 의 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 명령 ( &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt; 참조 )을 사용하면 어떤 작업이 오버로드되고 어떤 조상이이 오버로드를 트리거하는지 추론 할 수 있습니다. 만약 말, &lt;code&gt;eq&lt;/code&gt; , 방법을 오버로드 &lt;code&gt;(eq&lt;/code&gt; 디버거에 의해 도시된다. 방법 &lt;code&gt;()&lt;/code&gt; 에 해당합니다 &lt;code&gt;fallback&lt;/code&gt; 이 방법 방송의 존재가이 패키지가 활성화 과부하되었음을 실제로 키 (그리고 그것이 의해 사용되는지 모듈 &lt;code&gt;overload&lt;/code&gt; 의 &lt;code&gt;Overloaded&lt;/code&gt; 기능 ).</target>
        </trans-unit>
        <trans-unit id="aa67b5d2a4e3907ddf928ce915424a8bf19328d4" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt; function:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt; 기능 사용하기 :</target>
        </trans-unit>
        <trans-unit id="53251a51732562d07b79a04a55bb9b101d155369" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; pragma ensures that all variables are properly declared and prevents other misuses of legacy Perl features.</source>
          <target state="translated">은 Using &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; 모든 변수가 올바르게 선언 펄이 특징으로 기존의 다른 오용을 방지하는 것을 프라 그마 보장하지만합니다.</target>
        </trans-unit>
        <trans-unit id="1bda480993361a430b2548cdcd3f02a2d61e7bb5" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;In&lt;/code&gt; prefix avoids this ambiguity, so far. But new versions of Unicode continue to add new properties whose names begin with &lt;code&gt;In&lt;/code&gt; . There is a possibility that one of them someday will conflict with your usage. Since this is just a Perl extension, Unicode's name will take precedence and your code will become broken. Also, Unicode is free to add a script whose name begins with &lt;code&gt;In&lt;/code&gt; ; that would cause problems.</source>
          <target state="translated">&lt;code&gt;In&lt;/code&gt; 접두사를 사용하면 지금까지 이러한 모호성을 피할 수 있습니다. 그러나 새로운 버전의 유니 코드는 이름이 &lt;code&gt;In&lt;/code&gt; 로 시작하는 새로운 속성을 계속 추가합니다 . 언젠가 그들 중 하나가 사용과 충돌 할 가능성이 있습니다. 이것은 Perl 확장 일 뿐이므로 유니 코드 이름이 우선하며 코드가 손상됩니다. 또한 유니 코드는 이름이 &lt;code&gt;In&lt;/code&gt; 으로 시작하는 스크립트를 자유롭게 추가 할 수 있습니다 . 문제를 일으킬 것입니다.</target>
        </trans-unit>
        <trans-unit id="26fd47284e729cedc59da500b68930f9ee3e861b" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;diagnostics&lt;/code&gt; pragma:</source>
          <target state="translated">은 Using &lt;code&gt;diagnostics&lt;/code&gt; 프라그를 :</target>
        </trans-unit>
        <trans-unit id="18c4a3f647e2f5d82357ab39ea92ae98228cc2e0" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;nntpstat&lt;/code&gt; command to select by message-id is valid but of questionable value, since a selection by message-id does &lt;b&gt;not&lt;/b&gt; alter the &quot;current article pointer&quot;.</source>
          <target state="translated">message-id로 선택 하면 &quot;현재 기사 포인터&quot;가 변경 되지 &lt;b&gt;않으므로 &lt;/b&gt; &lt;code&gt;nntpstat&lt;/code&gt; 명령을 사용하여 message-id로 선택하는 것은 유효하지만 의심스러운 값 입니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="13d6e3a9e702d5a08e56927cb7a997c29fc49a7b" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;splain&lt;/code&gt; standalone filter program:</source>
          <target state="translated">은 Using &lt;code&gt;splain&lt;/code&gt; 의 독립형 필터 프로그램을 :</target>
        </trans-unit>
        <trans-unit id="5ea33d1eaae8e24543688decd019ec0f69a1f79d" translate="yes" xml:space="preserve">
          <source>Using the CPAN module &lt;code&gt;Bit::Vector&lt;/code&gt; :</source>
          <target state="translated">CPAN 모듈 사용 &lt;code&gt;Bit::Vector&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="910c0c6f5c0907edc9665e4e606f548cf3f4c360" translate="yes" xml:space="preserve">
          <source>Using the G_EVAL flag described above will always set &lt;code&gt;$@&lt;/code&gt; : clearing it if there was no error, and setting it to describe the error if there was an error in the called code. This is what you want if your intention is to handle possible errors, but sometimes you just want to trap errors and stop them interfering with the rest of the program.</source>
          <target state="translated">위에서 설명한 G_EVAL 플래그를 사용하면 항상 &lt;code&gt;$@&lt;/code&gt; 가 설정됩니다. 오류가 없으면 지우고 호출 된 코드에 오류가 있으면 오류를 설명하도록 설정합니다. 이것은 가능한 오류를 처리하려는 경우 원하는 것이지만 때로는 오류를 잡아서 프로그램의 나머지 부분을 방해하는 것을 막고 싶을 때가 있습니다.</target>
        </trans-unit>
        <trans-unit id="81c0cbb80720ba82333e9cac242b49c7344290c8" translate="yes" xml:space="preserve">
          <source>Using the O_WRONLY flag.</source>
          <target state="translated">O_WRONLY 플래그를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="318651aa0afd4166b844c0395b31d38b0b5bb275" translate="yes" xml:space="preserve">
          <source>Using the copy or the original with overloaded math is okay, e.g. the following work:</source>
          <target state="translated">수학 또는 수학이 오버로드 된 원본을 사용하는 것은 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="0de692f809342e61f897ad9464158e162341eb3b" translate="yes" xml:space="preserve">
          <source>Using the form $x += $y; etc over $x = $x + $y is faster, since a copy of $x must be made in the second case. For long numbers, the copy can eat up to 20% of the work (in the case of addition/subtraction, less for multiplication/division). If $y is very small compared to $x, the form $x += $y is MUCH faster than $x = $x + $y since making the copy of $x takes more time then the actual addition.</source>
          <target state="translated">$ x + = $ y 형식 사용; $ x = $ x + $ y 이상은 두 번째 경우 $ x의 복사본을 만들어야하므로 더 빠릅니다. 숫자가 길면 사본이 최대 20 %의 작품을 먹을 수 있습니다 (더하기 / 빼기의 경우 곱셈 / 나눗셈의 경우). $ y가 $ x에 비해 매우 작 으면 $ x의 복사본을 만드는 데 실제 시간보다 더 많은 시간이 걸리기 때문에 $ x + = $ y 형식은 $ x = $ x + $ y보다 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="12ccaa0444078f2a1b0edccce245e0b394be801a" translate="yes" xml:space="preserve">
          <source>Using the supplied template, create the temporary directory in a standard location for temporary files. Equivalent to doing</source>
          <target state="translated">제공된 템플리트를 사용하여 임시 파일의 표준 위치에 임시 디렉토리를 작성하십시오. 하는 것과 동등</target>
        </trans-unit>
        <trans-unit id="9e2035734d6024304e489d6917a2e574dba468c1" translate="yes" xml:space="preserve">
          <source>Using the syntax &lt;code&gt;MyParser::new()&lt;/code&gt; to invoke the constructor is</source>
          <target state="translated">&lt;code&gt;MyParser::new()&lt;/code&gt; 구문을 사용하여 생성자를 호출하면</target>
        </trans-unit>
        <trans-unit id="acb6f03c46c097330bc723d0ffaf6e2dff2e6744" translate="yes" xml:space="preserve">
          <source>Using the template pat..patend, this function unpacks the string s..strend into a number of mortal SVs, which it pushes onto the perl argument (@_) stack (so you will need to issue a &lt;code&gt;PUTBACK&lt;/code&gt; before and &lt;code&gt;SPAGAIN&lt;/code&gt; after the call to this function). It returns the number of pushed elements.</source>
          <target state="translated">템플릿 pat..patend를 사용하여,이 기능은 펄 인수에 밀어 인간의 SV 숫자로 문자열 s..strend 압축을 풉니 다 (@_) 스택 (당신은 실행해야합니다, 그래서 &lt;code&gt;PUTBACK&lt;/code&gt; 전 &lt;code&gt;SPAGAIN&lt;/code&gt; 애프터을 이 함수를 호출하십시오). 푸시 된 요소 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7a18622b9f73cf084e1c40515e63402b15a29333" translate="yes" xml:space="preserve">
          <source>Using this feature triggers warnings in the category &lt;code&gt;experimental::bitwise&lt;/code&gt; .</source>
          <target state="translated">이 기능을 사용하면 &lt;code&gt;experimental::bitwise&lt;/code&gt; 범주의 경고가 트리거됩니다 .</target>
        </trans-unit>
        <trans-unit id="c41fbff9d3dc71a6f8badab26c0a06f0e18953ee" translate="yes" xml:space="preserve">
          <source>Using this feature triggers warnings in the category &lt;code&gt;experimental::const_attr&lt;/code&gt; .</source>
          <target state="translated">이 기능을 사용하면 &lt;code&gt;experimental::const_attr&lt;/code&gt; 범주에서 경고를 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="cc856eaeef355d43fa8953f9faffa4c073431f05" translate="yes" xml:space="preserve">
          <source>Using this feature triggers warnings in the category &lt;code&gt;experimental::lexical_subs&lt;/code&gt; .</source>
          <target state="translated">이 기능을 사용하면 &lt;code&gt;experimental::lexical_subs&lt;/code&gt; 범주에서 경고를 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="857c7cbd2ca8ba6b31bcdbf6dd9c2b32441faf23" translate="yes" xml:space="preserve">
          <source>Using this feature triggers warnings in the category &lt;code&gt;experimental::lexical_topic&lt;/code&gt; .</source>
          <target state="translated">이 기능을 사용하면 &lt;code&gt;experimental::lexical_topic&lt;/code&gt; 카테고리에서 경고가 트리거됩니다 .</target>
        </trans-unit>
        <trans-unit id="de44610062c3b08fbff0aea3fd8f765facd544b6" translate="yes" xml:space="preserve">
          <source>Using this feature triggers warnings in the category &lt;code&gt;experimental::postderef&lt;/code&gt; .</source>
          <target state="translated">이 기능을 사용하면 &lt;code&gt;experimental::postderef&lt;/code&gt; 범주에서 경고를 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="e5af3cfd78b8e6f9d0563b3f4cf549f389ec7ba5" translate="yes" xml:space="preserve">
          <source>Using this feature triggers warnings in the category &lt;code&gt;experimental::re_strict&lt;/code&gt; .</source>
          <target state="translated">이 기능을 사용하면 &lt;code&gt;experimental::re_strict&lt;/code&gt; 범주에서 경고를 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="65fcb853c1a517ad8d77449f7c0018250e14485b" translate="yes" xml:space="preserve">
          <source>Using this feature triggers warnings in the category &lt;code&gt;experimental::refaliasing&lt;/code&gt; .</source>
          <target state="translated">이 기능을 사용하면 &lt;code&gt;experimental::refaliasing&lt;/code&gt; 범주에서 경고가 트리거됩니다 .</target>
        </trans-unit>
        <trans-unit id="37bffd5a63be98cf17b1b1c985d57c2adb638271" translate="yes" xml:space="preserve">
          <source>Using this feature triggers warnings in the category &lt;code&gt;experimental::regex_sets&lt;/code&gt; .</source>
          <target state="translated">이 기능을 사용하면 &lt;code&gt;experimental::regex_sets&lt;/code&gt; 범주에서 경고를 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="c0a382b10a1d9a073eb205f7f2bb7818eb3bbf75" translate="yes" xml:space="preserve">
          <source>Using this feature triggers warnings in the category &lt;code&gt;experimental::signatures&lt;/code&gt; .</source>
          <target state="translated">이 기능을 사용하면 &lt;code&gt;experimental::signatures&lt;/code&gt; 범주에서 경고를 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="482e06051ee37583e9eea4d7cca4c50c1fbeaf4e" translate="yes" xml:space="preserve">
          <source>Using this feature triggers warnings in the category &lt;code&gt;experimental::smartmatch&lt;/code&gt; .</source>
          <target state="translated">이 기능을 사용하면 &lt;code&gt;experimental::smartmatch&lt;/code&gt; 범주에서 경고를 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="2d4359e0b1138dffdeb53a1d3017037757b78671" translate="yes" xml:space="preserve">
          <source>Using this operator can lead to programs that are difficult to port, because the shell commands called vary between systems, and may in fact not be present at all. As one example, the &lt;code&gt;type&lt;/code&gt; command under the POSIX shell is very different from the &lt;code&gt;type&lt;/code&gt; command under DOS. That doesn't mean you should go out of your way to avoid backticks when they're the right way to get something done. Perl was made to be a glue language, and one of the things it glues together is commands. Just understand what you're getting yourself into.</source>
          <target state="translated">이 연산자를 사용하면 호출되는 쉘 명령이 시스템마다 다르고 실제로 존재하지 않을 수 있기 때문에 이식하기 어려운 프로그램으로 이어질 수 있습니다. 하나의 예를 들어, &lt;code&gt;type&lt;/code&gt; 는 POSIX 쉘에서 명령은 매우 다른 &lt;code&gt;type&lt;/code&gt; DOS에서 명령. 그렇다고해서 배신자가 올바른 일을 할 때 올바른 방법으로 배제하지 않도록해야한다는 의미는 아닙니다. 펄은 접착제 언어로 만들어졌으며, 서로 붙어있는 것 중 하나는 명령입니다. 자신이 무엇을하고 있는지 이해하십시오.</target>
        </trans-unit>
        <trans-unit id="d4d70574aacd1d1847898b08d95988a332169072" translate="yes" xml:space="preserve">
          <source>Using various gambits, try to get a CV from an SV; in addition, try if possible to set &lt;code&gt;*st&lt;/code&gt; and &lt;code&gt;*gvp&lt;/code&gt; to the stash and GV associated with it. The flags in &lt;code&gt;lref&lt;/code&gt; are passed to gv_fetchsv.</source>
          <target state="translated">다양한 bit 빗을 사용하여 SV에서 CV를 얻으십시오. 또한 가능하면 &lt;code&gt;*st&lt;/code&gt; 및 &lt;code&gt;*gvp&lt;/code&gt; 를 스 태쉬 및 GV에 설정하십시오. &lt;code&gt;lref&lt;/code&gt; 의 플래그는 gv_fetchsv 로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="27cc9ed80851550eb53eda865f75d2e008f1dc72" translate="yes" xml:space="preserve">
          <source>Using various gambits, try to get an IO from an SV: the IO slot if its a GV; or the recursive result if we're an RV; or the IO slot of the symbol named after the PV if we're a string.</source>
          <target state="translated">다양한 bit 비트를 사용하여 SV에서 IO를 가져 오십시오. GV 인 경우 IO 슬롯; 우리가 RV라면 재귀 적 결과; 또는 문자열 인 경우 PV 이름을 따서 명명 된 심볼의 IO 슬롯.</target>
        </trans-unit>
        <trans-unit id="40c4ad482806895c6f8713969b3ecb705fa44118" translate="yes" xml:space="preserve">
          <source>Using various methods &lt;b&gt;attempt&lt;/b&gt; to find the Fully Qualified Domain Name (FQDN) of the current host. From this determine the host-name and the host-domain.</source>
          <target state="translated">사용하여 다양한 방법 &lt;b&gt;을 시도&lt;/b&gt; 현재 호스트의 정규화 된 도메인 이름 (FQDN)을 찾을 수 있습니다. 여기에서 호스트 이름과 호스트 도메인을 결정하십시오.</target>
        </trans-unit>
        <trans-unit id="892738b2747cec8282f76dab54e62a0b79491609" translate="yes" xml:space="preserve">
          <source>Usual perl lib path (semi-list).</source>
          <target state="translated">일반적인 perl lib 경로 (반 목록).</target>
        </trans-unit>
        <trans-unit id="b7cde133a5ff79130fd30cde6b361d0ab467bd51" translate="yes" xml:space="preserve">
          <source>Usually a hash ref, perhaps like this:</source>
          <target state="translated">일반적으로 다음과 같은 해시 참조 :</target>
        </trans-unit>
        <trans-unit id="ad35f25dce96f5712243ad327f82cc56b137d4d7" translate="yes" xml:space="preserve">
          <source>Usually accessed via the &lt;code&gt;SvPVbyte&lt;/code&gt; macro.</source>
          <target state="translated">일반적으로 &lt;code&gt;SvPVbyte&lt;/code&gt; 매크로 를 통해 액세스합니다 .</target>
        </trans-unit>
        <trans-unit id="e38187632a58d32566d4fbc0b71dc22c87d815e2" translate="yes" xml:space="preserve">
          <source>Usually accessed via the &lt;code&gt;SvPVbyte_nolen&lt;/code&gt; macro.</source>
          <target state="translated">일반적으로 &lt;code&gt;SvPVbyte_nolen&lt;/code&gt; 매크로 를 통해 액세스합니다 .</target>
        </trans-unit>
        <trans-unit id="a0ca6cd076c679630ac44632c012203ed79a11ad" translate="yes" xml:space="preserve">
          <source>Usually accessed via the &lt;code&gt;SvPVutf8&lt;/code&gt; macro.</source>
          <target state="translated">일반적으로 &lt;code&gt;SvPVutf8&lt;/code&gt; 매크로 를 통해 액세스합니다 .</target>
        </trans-unit>
        <trans-unit id="b020d8f1cda36b9415a539e77cdc15cb72cc9530" translate="yes" xml:space="preserve">
          <source>Usually accessed via the &lt;code&gt;SvPVutf8_nolen&lt;/code&gt; macro.</source>
          <target state="translated">일반적으로 &lt;code&gt;SvPVutf8_nolen&lt;/code&gt; 매크로 를 통해 액세스합니다 .</target>
        </trans-unit>
        <trans-unit id="7c024fdbe2028ca7a62024863c10f1c75039e578" translate="yes" xml:space="preserve">
          <source>Usually called from the object destructor when using the OO interface.</source>
          <target state="translated">일반적으로 OO 인터페이스를 사용할 때 객체 소멸자에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="4285fe9b5258e25bc264f1b1a13271726e80e089" translate="yes" xml:space="preserve">
          <source>Usually inherited from DB package. Ask for a STRING to be &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;-ed in executing code context.</source>
          <target state="translated">일반적으로 DB 패키지에서 상속됩니다. 코드 컨텍스트 실행시 STRING을 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 하도록 요청하십시오 .</target>
        </trans-unit>
        <trans-unit id="026b900ced2773356641f583fde7b62143e57def" translate="yes" xml:space="preserve">
          <source>Usually inherited from DB package. If no arguments are passed, returns the poststop action string.</source>
          <target state="translated">일반적으로 DB 패키지에서 상속됩니다. 인수가 전달되지 않으면 poststop 조치 문자열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7d9b8edd49b4cf562a81e5b8decb5de77fa1afd9" translate="yes" xml:space="preserve">
          <source>Usually inherited from DB package. If no arguments are passed, returns the prestop action string.</source>
          <target state="translated">일반적으로 DB 패키지에서 상속됩니다. 인수가 전달되지 않으면 사전 중지 조치 문자열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="0c460ecc82dad59a8d6a90636305608877d8c532" translate="yes" xml:space="preserve">
          <source>Usually programs take command line options as well as other arguments, for example, file names. It is good practice to always specify the options first, and the other arguments last. Getopt::Long will, however, allow the options and arguments to be mixed and 'filter out' all the options before passing the rest of the arguments to the program. To stop Getopt::Long from processing further arguments, insert a double dash &lt;code&gt;--&lt;/code&gt; on the command line:</source>
          <target state="translated">일반적으로 프로그램은 명령 행 옵션과 다른 인수 (예 : 파일 이름)를 사용합니다. 항상 옵션을 먼저 지정하고 다른 인수는 마지막에 지정하는 것이 좋습니다. 그러나 Getopt :: Long은 옵션과 인수를 혼합하고 나머지 인수를 프로그램에 전달하기 전에 모든 옵션을 '필터링'할 수 있습니다. 추가 인수를 처리에서 것은, Getopt :: 롱을 중지하려면, 이중 대시 삽입 &lt;code&gt;--&lt;/code&gt; 명령 줄을 :</target>
        </trans-unit>
        <trans-unit id="2691970d8d342de7ae3956a2783fcd64867158b2" translate="yes" xml:space="preserve">
          <source>Usually used via its frontend &lt;code&gt;sv_catpvf&lt;/code&gt; .</source>
          <target state="translated">일반적으로 프론트 엔드 &lt;code&gt;sv_catpvf&lt;/code&gt; 를 통해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="221ae26d5a59ab131e1ef8287fa9b5a715378994" translate="yes" xml:space="preserve">
          <source>Usually used via its frontend &lt;code&gt;sv_catpvf_mg&lt;/code&gt; .</source>
          <target state="translated">일반적으로 프론트 엔드 &lt;code&gt;sv_catpvf_mg&lt;/code&gt; 를 통해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="1f47e17c3d0a65f1e24ab46a970720597c10ef39" translate="yes" xml:space="preserve">
          <source>Usually used via its frontend &lt;code&gt;sv_setpvf&lt;/code&gt; .</source>
          <target state="translated">보통 프론트 엔드 &lt;code&gt;sv_setpvf&lt;/code&gt; 를 통해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="3548cea6e28d55dc32a5bfd0e3189ea93c77d357" translate="yes" xml:space="preserve">
          <source>Usually used via its frontend &lt;code&gt;sv_setpvf_mg&lt;/code&gt; .</source>
          <target state="translated">일반적으로 프론트 엔드 &lt;code&gt;sv_setpvf_mg&lt;/code&gt; 를 통해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a9bb4c004a0f7c4b905c963d10b31ef391b5c334" translate="yes" xml:space="preserve">
          <source>Usually used via one of its frontends &lt;code&gt;sv_vcatpvf&lt;/code&gt; and &lt;code&gt;sv_vcatpvf_mg&lt;/code&gt; .</source>
          <target state="translated">일반적으로 프론트 엔드 &lt;code&gt;sv_vcatpvf&lt;/code&gt; 및 &lt;code&gt;sv_vcatpvf_mg&lt;/code&gt; 중 하나를 통해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2f08502c181dd16b4bbf68ae24c29b059d5a1bce" translate="yes" xml:space="preserve">
          <source>Usually used via one of its frontends &lt;code&gt;sv_vsetpvf&lt;/code&gt; and &lt;code&gt;sv_vsetpvf_mg&lt;/code&gt; .</source>
          <target state="translated">일반적으로 프론트 엔드 &lt;code&gt;sv_vsetpvf&lt;/code&gt; 및 &lt;code&gt;sv_vsetpvf_mg&lt;/code&gt; 중 하나를 통해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7fff94b5e5d0e7b2c191398749185343c2f32a65" translate="yes" xml:space="preserve">
          <source>Usually when a variable is localized you want to make sure that this change affects the shortest scope possible. So unless you are already inside some short &lt;code&gt;{}&lt;/code&gt; block, you should create one yourself. For example:</source>
          <target state="translated">일반적으로 변수가 지역화 된 경우이 변경이 가능한 가장 짧은 범위에 영향을 미치도록하려고합니다. 따라서 짧은 &lt;code&gt;{}&lt;/code&gt; 블록 안에 이미 있지 않은 경우 직접 작성해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="599351f57ec025dcf8b7e2139660d070855a8727" translate="yes" xml:space="preserve">
          <source>Usually you'll want to pack or unpack UTF-8 strings:</source>
          <target state="translated">일반적으로 UTF-8 문자열을 포장하거나 포장을 풀고 싶을 것입니다.</target>
        </trans-unit>
        <trans-unit id="cf8c2092d45b2a1234c61351a627eb75997a3b4f" translate="yes" xml:space="preserve">
          <source>Usually, the feature can be entirely ignored. Calling</source>
          <target state="translated">일반적으로이 기능은 완전히 무시할 수 있습니다. 부름</target>
        </trans-unit>
        <trans-unit id="3747a1556b1698c5e4df73c06a70d49b29b190d1" translate="yes" xml:space="preserve">
          <source>Usually, these single-character options can be bundled:</source>
          <target state="translated">일반적으로 이러한 단일 문자 옵션은 번들로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18fdc5ee8b1f8fba8dabaa933373c0483ab7fad7" translate="yes" xml:space="preserve">
          <source>Utilities</source>
          <target state="translated">Utilities</target>
        </trans-unit>
        <trans-unit id="29f83b729f46062c9dd1b32c5a75ee83eb4a8e12" translate="yes" xml:space="preserve">
          <source>Utilities for embedding Perl in C/C++ applications</source>
          <target state="translated">C / C ++ 애플리케이션에 Perl을 임베드하기위한 유틸리티</target>
        </trans-unit>
        <trans-unit id="c5c36f1963730a8868662732388dc0c0703a634a" translate="yes" xml:space="preserve">
          <source>Utilities for managing %^H scopes</source>
          <target state="translated">% ^ H 범위 관리를위한 유틸리티</target>
        </trans-unit>
        <trans-unit id="35acf3ef6343308f92e84a6c665aa85cecd79c2b" translate="yes" xml:space="preserve">
          <source>Utilities to replace common UNIX commands in Makefiles etc.</source>
          <target state="translated">Makefile 등에서 일반적인 UNIX 명령을 대체하는 유틸리티</target>
        </trans-unit>
        <trans-unit id="1637dc7299266babf67a48df4d48af858929b4bd" translate="yes" xml:space="preserve">
          <source>Utilities to write and check a MANIFEST file</source>
          <target state="translated">MANIFEST 파일을 작성하고 확인하는 유틸리티</target>
        </trans-unit>
        <trans-unit id="8bf056ede57539fe7ab422f88b516c58223a0adf" translate="yes" xml:space="preserve">
          <source>Utility Functions</source>
          <target state="translated">유틸리티 기능</target>
        </trans-unit>
        <trans-unit id="5486a0e8e13b0b039dc58793f09b6e6eb6465317" translate="yes" xml:space="preserve">
          <source>Utility Methods</source>
          <target state="translated">유틸리티 방법</target>
        </trans-unit>
        <trans-unit id="2ffeb2e1de80e186589b30d3572aa3cf779263b5" translate="yes" xml:space="preserve">
          <source>Utility for CPAN::Config file Initialization</source>
          <target state="translated">CPAN :: Config 파일 초기화 유틸리티</target>
        </trans-unit>
        <trans-unit id="bc41614ee1aee6d115725273058a3f6ba77aebc5" translate="yes" xml:space="preserve">
          <source>Utility function that tells you if &lt;code&gt;IPC::Cmd&lt;/code&gt; is capable of capturing buffers in it's current configuration.</source>
          <target state="translated">&lt;code&gt;IPC::Cmd&lt;/code&gt; 가 현재 구성에서 버퍼를 캡처 할 수 있는지 알려주는 유틸리티 기능 .</target>
        </trans-unit>
        <trans-unit id="f378c15ae2f401b4423675b36af5d2e3c5f0b6d5" translate="yes" xml:space="preserve">
          <source>Utility function that tells you if &lt;code&gt;IPC::Cmd&lt;/code&gt; is capable of providing &lt;code&gt;run_forked&lt;/code&gt; on the current platform.</source>
          <target state="translated">&lt;code&gt;IPC::Cmd&lt;/code&gt; 가 현재 플랫폼에서 &lt;code&gt;run_forked&lt;/code&gt; 를 제공 할 수 있는지 알려주는 유틸리티 기능 .</target>
        </trans-unit>
        <trans-unit id="4bd9fd9b54869479fd1b5ab93786828f7dca29ba" translate="yes" xml:space="preserve">
          <source>Utility function that tells you if &lt;code&gt;IPC::Open3&lt;/code&gt; is available. If the verbose flag is passed, it will print diagnostic messages if &lt;code&gt;IPC::Open3&lt;/code&gt; can not be found or loaded.</source>
          <target state="translated">&lt;code&gt;IPC::Open3&lt;/code&gt; 을 사용할 수 있는지 알려주는 유틸리티 기능 . verbose 플래그가 전달되면 &lt;code&gt;IPC::Open3&lt;/code&gt; 을 찾거나로드 할 수없는 경우 진단 메시지가 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="451db65a6c9d4e76bfbbd6735fbbae7748464a49" translate="yes" xml:space="preserve">
          <source>Utility function that tells you if &lt;code&gt;IPC::Run&lt;/code&gt; is available. If the &lt;code&gt;verbose&lt;/code&gt; flag is passed, it will print diagnostic messages if &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::Run&quot;&gt;IPC::Run&lt;/a&gt; can not be found or loaded.</source>
          <target state="translated">&lt;code&gt;IPC::Run&lt;/code&gt; 을 사용할 수 있는지 알려주는 유틸리티 기능 . 경우 &lt;code&gt;verbose&lt;/code&gt; 플래그가 전달되는 경우,이 진단 메시지를 출력한다 &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::Run&quot;&gt;IPC :: 실행을&lt;/a&gt; 찾거나로드 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f16cdccb3faaa5e67faa6fdb65caa5cf29d51cbb" translate="yes" xml:space="preserve">
          <source>Utility functions</source>
          <target state="translated">유틸리티 기능</target>
        </trans-unit>
        <trans-unit id="1f8287a26f238372802990f191fcd97ce4ce1919" translate="yes" xml:space="preserve">
          <source>Utility functions to compare CPAN versions</source>
          <target state="translated">CPAN 버전을 비교하는 유틸리티 기능</target>
        </trans-unit>
        <trans-unit id="e944fa11ecc3fc10a3b409bcd5f6df4ebd3f4487" translate="yes" xml:space="preserve">
          <source>Uuencoding</source>
          <target state="translated">Uuencoding</target>
        </trans-unit>
        <trans-unit id="c9ee5681d3c59f7541c27a38b67edf46259e187b" translate="yes" xml:space="preserve">
          <source>V</source>
          <target state="translated">V</target>
        </trans-unit>
        <trans-unit id="7dc10180b878fd7bd185c2d6a23c0519a292a3a0" translate="yes" xml:space="preserve">
          <source>VALUE</source>
          <target state="translated">VALUE</target>
        </trans-unit>
        <trans-unit id="41fdf9c71f9b0e67f5d577b57ffb59065472ee6e" translate="yes" xml:space="preserve">
          <source>VAR</source>
          <target state="translated">VAR</target>
        </trans-unit>
        <trans-unit id="b5fcb61029823124da78ad195388293fa0fe55ea" translate="yes" xml:space="preserve">
          <source>VARIABLES</source>
          <target state="translated">VARIABLES</target>
        </trans-unit>
        <trans-unit id="b33892fbddeffc3368077b4904ad0b3d562a7312" translate="yes" xml:space="preserve">
          <source>VERSION</source>
          <target state="translated">VERSION</target>
        </trans-unit>
        <trans-unit id="f189e0805d92e6bfdd489073d1a01e43b46335be" translate="yes" xml:space="preserve">
          <source>VERSION may be either a numeric argument such as 5.006, which will be compared to &lt;code&gt;$]&lt;/code&gt; , or a literal of the form v5.6.1, which will be compared to &lt;code&gt;$^V&lt;/code&gt; (aka $PERL_VERSION). An exception is raised if VERSION is greater than the version of the current Perl interpreter. Compare with &lt;a href=&quot;#use&quot;&gt;use&lt;/a&gt;, which can do a similar check at compile time.</source>
          <target state="translated">VERSION은 5.0]과 같은 숫자 인수 ( &lt;code&gt;$]&lt;/code&gt; 와 비교 되거나 v5.6.1 형식의 리터럴 일 수 있으며 &lt;code&gt;$^V&lt;/code&gt; (일명 $ PERL_VERSION)와 비교됩니다 . VERSION이 현재 Perl 인터프리터의 버전보다 큰 경우 예외가 발생합니다. 컴파일시 비슷한 검사를 수행 할 수있는 &lt;a href=&quot;#use&quot;&gt;use&lt;/a&gt; 와 비교하십시오 .</target>
        </trans-unit>
        <trans-unit id="3f48ba5d24abaab8495945658838888561f00637" translate="yes" xml:space="preserve">
          <source>VERSION may be either a numeric argument such as 5.006, which will be compared to &lt;code&gt;$]&lt;/code&gt; , or a literal of the form v5.6.1, which will be compared to &lt;code&gt;$^V&lt;/code&gt; (aka $PERL_VERSION). An exception is raised if VERSION is greater than the version of the current Perl interpreter. Compare with &lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;, which can do a similar check at compile time.</source>
          <target state="translated">VERSION은 5.0]과 같은 숫자 인수 ( &lt;code&gt;$]&lt;/code&gt; 와 비교 되거나 v5.6.1 형식의 리터럴 일 수 있으며 &lt;code&gt;$^V&lt;/code&gt; (일명 $ PERL_VERSION)와 비교됩니다 . VERSION이 현재 Perl 인터프리터의 버전보다 큰 경우 예외가 발생합니다. 컴파일시 비슷한 검사를 수행 할 수있는 &lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; 와 비교하십시오 .</target>
        </trans-unit>
        <trans-unit id="8aab271152b932f50d15f749cb2ad3f6aa388e98" translate="yes" xml:space="preserve">
          <source>VERSION: version of your module</source>
          <target state="translated">버전 : 모듈 버전</target>
        </trans-unit>
        <trans-unit id="439c8f3808541b8d38659912158a7dbb6e0d7837" translate="yes" xml:space="preserve">
          <source>VERSION_MACRO: which macro represents the version (usually 'VERSION')</source>
          <target state="translated">VERSION_MACRO : 버전을 나타내는 매크로 (일반적으로 'VERSION')</target>
        </trans-unit>
        <trans-unit id="d46d79d5b527245ae65e82f18ddd3ba603c16976" translate="yes" xml:space="preserve">
          <source>VERSION_SYM: like version but safe for use as an RCS revision number</source>
          <target state="translated">VERSION_SYM : 버전과 유사하지만 RCS 개정 번호로 사용하기에 안전</target>
        </trans-unit>
        <trans-unit id="a850272b9ab78b2a9e2f07713cef8bc188b3ede9" translate="yes" xml:space="preserve">
          <source>VERY ALPHA AND LIKELY TO CHANGE</source>
          <target state="translated">매우 알파 및 변경 가능성</target>
        </trans-unit>
        <trans-unit id="cce163acefa51c5f80357419607cd2acfc9bcda6" translate="yes" xml:space="preserve">
          <source>VIEW.EXE</source>
          <target state="translated">VIEW.EXE</target>
        </trans-unit>
        <trans-unit id="8e5207fffbfb609ac37a389e363f0db0120b9dae" translate="yes" xml:space="preserve">
          <source>VMS</source>
          <target state="translated">VMS</target>
        </trans-unit>
        <trans-unit id="6ad64d23074ae7d322786e62e572397b29888496" translate="yes" xml:space="preserve">
          <source>VMS Software Inc. web site, &lt;a href=&quot;http://www.vmssoftware.com&quot;&gt;http://www.vmssoftware.com&lt;/a&gt;</source>
          <target state="translated">VMS Software Inc. 웹 사이트, &lt;a href=&quot;http://www.vmssoftware.com&quot;&gt;http://www.vmssoftware.com&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2719ba4075d542c93bfa0cdfa52b9abcdd8bf1e2" translate="yes" xml:space="preserve">
          <source>VMS file specification syntax is case-tolerant.</source>
          <target state="translated">VMS 파일 사양 구문은 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="731e9eea656f3a7b49847d98fa31bc8bf39060b9" translate="yes" xml:space="preserve">
          <source>VMS has $(MMSQUALIFIERS) which is a listing of all the original command line options. This is used in every invocation of make in the VMS Makefile so PASTHRU should not be necessary. Using PASTHRU tends to blow commands past the 256 character limit.</source>
          <target state="translated">VMS에는 $ (MMSQUALIFIERS)가 있으며 이는 모든 원래 명령 행 옵션의 목록입니다. VMS Makefile에서 make를 호출 할 때마다 사용되므로 PASTHRU가 필요하지 않습니다. PASTHRU를 사용하면 명령이 256 자 제한을 초과하는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="26ff54e8c5dec349cf161af5221feaf07190cd81" translate="yes" xml:space="preserve">
          <source>VMS implementation</source>
          <target state="translated">VMS 구현</target>
        </trans-unit>
        <trans-unit id="044140c726f05d1f569402b05b60683ee5f27ac8" translate="yes" xml:space="preserve">
          <source>VMS is VMS.</source>
          <target state="translated">VMS는 VMS입니다.</target>
        </trans-unit>
        <trans-unit id="19cc64067b9d9a483d87606a5fc200285da5a247" translate="yes" xml:space="preserve">
          <source>VMS support for this process in the current release of Perl is sufficient to handle most extensions. (See the MakeMaker documentation for more details on installation options for extensions.)</source>
          <target state="translated">현재 Perl 릴리스에서이 프로세스에 대한 VMS 지원은 대부분의 확장을 처리하기에 충분합니다. 확장 기능의 설치 옵션에 대한 자세한 내용은 MakeMaker 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a0b48a2078e8546f59c353d4437730af0e465606" translate="yes" xml:space="preserve">
          <source>VMS systems have a permissions structure that cannot be completely represented in a stat buffer, and unlike on other systems the builtin filetest operators respect this. The &lt;code&gt;File::stat&lt;/code&gt; overloads, however, do not, since the information required is not available.</source>
          <target state="translated">VMS 시스템은 stat 버퍼에 완전히 표현할 수없는 권한 구조를 가지고 있으며 다른 시스템과 달리 내장 파일 테스트 연산자는이를 존중합니다. &lt;code&gt;File::stat&lt;/code&gt; 필요한 정보를 사용할 수없는 때문에 오버로드하지만,하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d55cb5dcb20d55a8b83dc657590161b870f2b37b" translate="yes" xml:space="preserve">
          <source>VMS wants a dot in every file so we can't have one called 'pm_to_blib', it becomes 'pm_to_blib.' and MMS/K isn't smart enough to know that when you have a target called 'pm_to_blib' it should look for 'pm_to_blib.'.</source>
          <target state="translated">VMS는 모든 파일에 점을 원하므로 'pm_to_blib'라는 이름을 가질 수 없으며 'pm_to_blib'가됩니다. MMS / K는 'pm_to_blib'라는 대상이있을 때 'pm_to_blib'를 찾아야한다는 것을 알기에 충분히 똑똑하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f2c0fca2c674b5e61f569c9a2276cbaa83043ca7" translate="yes" xml:space="preserve">
          <source>VMSish defaults for some values.</source>
          <target state="translated">일부 값의 VMSish 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="b34e6b4bc196605f4ec9f36bd956bf4d5349e341" translate="yes" xml:space="preserve">
          <source>VOS</source>
          <target state="translated">VOS</target>
        </trans-unit>
        <trans-unit id="3ed32c224bfdeaef83075fa116b0ec438527a823" translate="yes" xml:space="preserve">
          <source>VOS Open-Source Software on the web at &lt;a href=&quot;http://ftp.stratus.com/pub/vos/vos.html&quot;&gt;http://ftp.stratus.com/pub/vos/vos.html&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://ftp.stratus.com/pub/vos/vos.html&quot;&gt;http://ftp.stratus.com/pub/vos/vos.html&lt;/a&gt; 웹의 VOS 오픈 소스 소프트웨어</target>
        </trans-unit>
        <trans-unit id="957b3df553f7dff11b930fd1fbc2f8551388c83f" translate="yes" xml:space="preserve">
          <source>VOS perl can emulate Unix filenames with &lt;code&gt;/&lt;/code&gt; as path separator. The native pathname characters greater-than, less-than, number-sign, and percent-sign are always accepted.</source>
          <target state="translated">VOS perl은 경로 구분 기호 로 &lt;code&gt;/&lt;/code&gt; 를 사용 하여 Unix 파일 이름을 에뮬레이션 할 수 있습니다 . 보다 큼,보다 작음, 숫자 기호 및 백분율 기호는 기본 경로 이름 문자가 항상 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="228203bd56ca8f33c2e2cf1d51934741f92afc9c" translate="yes" xml:space="preserve">
          <source>VOS specific subclass of ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils :: MM_Unix의 VOS 특정 서브 클래스</target>
        </trans-unit>
        <trans-unit id="0565b8691c25d546ce54285d2b39e0a691ab1159" translate="yes" xml:space="preserve">
          <source>Valgrind also provides a cachegrind tool, invoked on perl as:</source>
          <target state="translated">Valgrind는 또한 다음과 같이 perl에서 호출되는 cachegrind 도구를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c78c948aba2c03abbf33d21db8439afd4716f2fd" translate="yes" xml:space="preserve">
          <source>Valid $types are &quot;MacOS&quot;, &quot;VMS&quot;, &quot;AmigaOS&quot;, &quot;OS2&quot;, &quot;RISCOS&quot;, &quot;MSWin32&quot;, &quot;DOS&quot; (also &quot;MSDOS&quot; for backwards bug compatibility), &quot;Epoc&quot; and &quot;Unix&quot; (all case-insensitive). If an unrecognized $type is given &quot;Unix&quot; will be assumed.</source>
          <target state="translated">유효한 $ 유형은 &quot;MacOS&quot;, &quot;VMS&quot;, &quot;AmigaOS&quot;, &quot;OS2&quot;, &quot;RISCOS&quot;, &quot;MSWin32&quot;, &quot;DOS&quot;(뒤로 버그 호환성을위한 &quot;MSDOS&quot;), &quot;Epoc&quot;및 &quot;Unix&quot;( 대소 문자를 구분하지 않음). 인식 할 수없는 $ type이 주어지면 &quot;Unix&quot;로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="4f1f0874166d8489998a2dabaec65b65aacdc83c" translate="yes" xml:space="preserve">
          <source>Valid flags are R_CURSOR, R_IAFTER, R_IBEFORE, R_NOOVERWRITE and R_SETCURSOR.</source>
          <target state="translated">유효한 플래그는 R_CURSOR, R_IAFTER, R_IBEFORE, R_NOOVERWRITE 및 R_SETCURSOR입니다.</target>
        </trans-unit>
        <trans-unit id="372003ef32f4fb85add82bd740d0d6f53c484da5" translate="yes" xml:space="preserve">
          <source>Valid values are 0-9 and &lt;code&gt;LZMA_PRESET_DEFAULT&lt;/code&gt; .</source>
          <target state="translated">유효한 값은 0-9입니다. &lt;code&gt;LZMA_PRESET_DEFAULT&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c4fc9756075f953dec67702b67d732830de319ae" translate="yes" xml:space="preserve">
          <source>Valid values are from 1 to 9, where 9 is best compression.</source>
          <target state="translated">유효한 값은 1에서 9까지이며 9는 최상의 압축입니다.</target>
        </trans-unit>
        <trans-unit id="61c0f0c254e06b47f44e05f0b16b8e15856c3b3c" translate="yes" xml:space="preserve">
          <source>Valid values for the file type are the following constants defined by Archive::Tar::Constant:</source>
          <target state="translated">파일 유형에 유효한 값은 Archive :: Tar :: Constant에 의해 정의 된 다음 상수입니다.</target>
        </trans-unit>
        <trans-unit id="e2d14a7d576fe1f87f5d9e8e9cd3b19b9f3883ab" translate="yes" xml:space="preserve">
          <source>Valid values range from 0 to 250, where 0 means use the default value 30.</source>
          <target state="translated">유효한 값의 범위는 0-250입니다. 여기서 0은 기본값 30을 사용함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0c5fff5f0da802e753b92748a90cbb8fb80c8fcd" translate="yes" xml:space="preserve">
          <source>Validate CPAN distribution metadata structures</source>
          <target state="translated">CPAN 배포 메타 데이터 구조 검증</target>
        </trans-unit>
        <trans-unit id="42ca1a4cda43fbba8ac585879a08c0309c1d20bf" translate="yes" xml:space="preserve">
          <source>Validate that a given string can be parsed as a version object, but doesn't actually perform the parsing. Can use either strict or lax validation rules. Can optionally set a number of hint variables to save the parsing code some time when tokenizing.</source>
          <target state="translated">지정된 문자열을 버전 객체로 구문 분석 할 수 있지만 실제로 구문 분석을 수행하지는 않는지 확인하십시오. 엄격한 또는 느슨한 유효성 검사 규칙을 사용할 수 있습니다. 토큰화할 때 구문 분석 코드를 저장하기 위해 여러 힌트 변수를 선택적으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02a3f32fae979c719788dc5214614a1ca3e7e4ee" translate="yes" xml:space="preserve">
          <source>Validate the arguments given by the user based on strings, regexes, lists or even subroutines</source>
          <target state="translated">문자열, 정규식, 목록 또는 서브 루틴을 기반으로 사용자가 제공 한 인수의 유효성을 검사합니다</target>
        </trans-unit>
        <trans-unit id="df34a04c181ba88b10ee206f3171d24fb01034c4" translate="yes" xml:space="preserve">
          <source>Validates that the SV contains valid internal structure for a version object. It may be passed either the version object (RV) or the hash itself (HV). If the structure is valid, it returns the HV. If the structure is invalid, it returns NULL.</source>
          <target state="translated">SV에 버전 객체의 유효한 내부 구조가 포함되어 있는지 확인합니다. 버전 오브젝트 (RV) 또는 해시 자체 (HV)로 전달 될 수 있습니다. 구조가 유효하면 HV를 반환합니다. 구조가 유효하지 않으면 NULL을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ff4094183301726c60c811c9d974ce575c34af6b" translate="yes" xml:space="preserve">
          <source>Validation Tests</source>
          <target state="translated">검증 테스트</target>
        </trans-unit>
        <trans-unit id="fa414ab19e33bf9bd3aaeda3e54cacdb51c904fe" translate="yes" xml:space="preserve">
          <source>Value must be greater than zero. Pass an undef value to disable it:</source>
          <target state="translated">값은 0보다 커야합니다. undef 값을 전달하여 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="5329eac11375c274bf2934a43944e0d3c65118bd" translate="yes" xml:space="preserve">
          <source>Value slices of arrays and hashes may also be taken with postfix dereferencing notation, with the following equivalencies:</source>
          <target state="translated">배열과 해시의 값 조각은 다음과 같은 동등성으로 접미사 역 참조 표기법으로도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d49e40c3d7ac176f056540076e808cf6346a547" translate="yes" xml:space="preserve">
          <source>Values are usually referred to by name, or through a named reference. The first character of the name tells you to what sort of data structure it refers. The rest of the name tells you the particular value to which it refers. Usually this name is a single</source>
          <target state="translated">값은 일반적으로 이름으로 또는 명명 된 참조를 통해 참조됩니다. 이름의 첫 문자는 어떤 종류의 데이터 구조를 나타내는 지 알려줍니다. 나머지 이름은 해당 이름이 나타내는 특정 값을 알려줍니다. 보통이 이름은 하나입니다</target>
        </trans-unit>
        <trans-unit id="b95834354d188d1c446139257f83c336e08b30f1" translate="yes" xml:space="preserve">
          <source>Values in this array are magical in numeric context: they compare equal to zero only if the line is not breakable.</source>
          <target state="translated">이 배열의 값은 숫자 컨텍스트에서 마술입니다. 줄을 끊을 수없는 경우에만 0과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f6e707c7542fd8d8b012efb4bcba22c20e79cddd" translate="yes" xml:space="preserve">
          <source>Values must be either strings with possible glob-style matching, or arrayrefs of strings or hashrefs which follow this pattern recursively.</source>
          <target state="translated">값은 glob 스타일 일치가 가능한 문자열이거나이 패턴을 반복적으로 따르는 문자열 또는 해시 참조의 배열 참조 여야합니다.</target>
        </trans-unit>
        <trans-unit id="9d7f43d25cf7a3a7519ab8b3625879499f1cffcc" translate="yes" xml:space="preserve">
          <source>Values of %meta_add will overwrite any existing metadata in those keys. %meta_merge will be merged with them.</source>
          <target state="translated">% meta_add 값은 해당 키의 기존 메타 데이터를 덮어 씁니다. % meta_merge가 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="a7c124848c793b84e7134c4f5b9435a446fc14e9" translate="yes" xml:space="preserve">
          <source>Values stored in config.sh as 'undef' are returned as undefined values. The perl &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; function can be used to check if a named variable exists.</source>
          <target state="translated">'undef'로 config.sh에 저장된 값은 정의되지 않은 값으로 리턴됩니다. 펄 &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 명명 된 변수가 존재하는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9adc561121b10d3163cfe0f3b6e1049a68105bd5" translate="yes" xml:space="preserve">
          <source>Variable names</source>
          <target state="translated">변수 이름</target>
        </trans-unit>
        <trans-unit id="5b24debec3e800c2a01f6fe873b50e5c2cfac784" translate="yes" xml:space="preserve">
          <source>Variable names in Perl can have several formats. Usually, they must begin with a letter or underscore, in which case they can be arbitrarily long (up to an internal limit of 251 characters) and may contain letters, digits, underscores, or the special sequence &lt;code&gt;::&lt;/code&gt; or &lt;code&gt;'&lt;/code&gt;. In this case, the part before the last &lt;code&gt;::&lt;/code&gt; or &lt;code&gt;'&lt;/code&gt; is taken to be a</source>
          <target state="translated">Perl의 변수 이름은 여러 형식을 가질 수 있습니다. 일반적으로 문자 또는 밑줄로 시작해야하며,이 경우 임의로 길 수 있으며 (내부 최대 251 자) 문자, 숫자, 밑줄 또는 특수 시퀀스 &lt;code&gt;::&lt;/code&gt; 또는 &lt;code&gt;'&lt;/code&gt; 를 포함 할 수 있습니다 . 이 경우 마지막 부분 앞의 &lt;code&gt;::&lt;/code&gt; 또는 &lt;code&gt;'&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="41f1e305cd399af1bab308129c47ec5731d3275e" translate="yes" xml:space="preserve">
          <source>Variable scoping</source>
          <target state="translated">변수 범위</target>
        </trans-unit>
        <trans-unit id="ef32d1f98150e537dbad0f8aeb79c36da9b27e19" translate="yes" xml:space="preserve">
          <source>Variable suicide is when you (temporarily or permanently) lose the value of a variable. It is caused by scoping through my() and local() interacting with either closures or aliased foreach() iterator variables and subroutine arguments. It used to be easy to inadvertently lose a variable's value this way, but now it's much harder. Take this code:</source>
          <target state="translated">변수 자살은 변수의 가치를 (일시적으로 또는 영구적으로) 잃을 때입니다. 클로저 또는 별명 된 foreach () 반복자 변수 및 서브 루틴 인수와 상호 작용하는 my () 및 local ()을 통해 범위를 지정하면 발생합니다. 이런 식으로 실수로 변수의 값을 잃기 쉬웠지만 지금은 훨씬 더 어려워졌습니다. 이 코드를 보자 :</target>
        </trans-unit>
        <trans-unit id="250f3f77348f1daf074babbf51813ae9c5cec2e2" translate="yes" xml:space="preserve">
          <source>Variable which is setup by &lt;code&gt;xsubpp&lt;/code&gt; to designate the object in a C++ XSUB. This is always the proper type for the C++ object. See &lt;code&gt;CLASS&lt;/code&gt; and &lt;a href=&quot;perlxs#Using-XS-With-C%2b%2b&quot;&gt;Using XS With C++ in perlxs&lt;/a&gt;.</source>
          <target state="translated">C ++ XSUB에서 오브젝트를 지정하기 &lt;code&gt;xsubpp&lt;/code&gt; 에 의해 설정되는 변수입니다 . 이것은 항상 C ++ 객체에 적합한 유형입니다. &lt;a href=&quot;perlxs#Using-XS-With-C%2b%2b&quot;&gt;perlxs에서 &lt;/a&gt; &lt;code&gt;CLASS&lt;/code&gt; 및 C ++와 함께 XS 사용 참조 .</target>
        </trans-unit>
        <trans-unit id="96f93b135985c0d3733c8f2cb9adad25487bb3de" translate="yes" xml:space="preserve">
          <source>Variable which is setup by &lt;code&gt;xsubpp&lt;/code&gt; to hold the return value for an XSUB. This is always the proper type for the XSUB. See &lt;a href=&quot;perlxs#The-RETVAL-Variable&quot;&gt;The RETVAL Variable in perlxs&lt;/a&gt;.</source>
          <target state="translated">XSUB의 리턴 값을 보유하기 &lt;code&gt;xsubpp&lt;/code&gt; 에 의해 설정되는 변수입니다 . 이것은 항상 XSUB에 적합한 유형입니다. &lt;a href=&quot;perlxs#The-RETVAL-Variable&quot;&gt;perlxs의 RETVAL 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca0fab0f8678649996d70b3f1641bab2dc619d79" translate="yes" xml:space="preserve">
          <source>Variable which is setup by &lt;code&gt;xsubpp&lt;/code&gt; to indicate the class name for a C++ XS constructor. This is always a &lt;code&gt;char*&lt;/code&gt; . See &lt;code&gt;THIS&lt;/code&gt; .</source>
          <target state="translated">C ++ XS 생성자의 클래스 이름을 나타 내기 &lt;code&gt;xsubpp&lt;/code&gt; 에 의해 설정되는 변수입니다 . 이것은 항상 &lt;code&gt;char*&lt;/code&gt; 입니다. 참조 &lt;code&gt;THIS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="047db5765fb37d513256abe7c3bb231a7730d231" translate="yes" xml:space="preserve">
          <source>Variable which is setup by &lt;code&gt;xsubpp&lt;/code&gt; to indicate the number of items on the stack. See &lt;a href=&quot;perlxs#Variable-length-Parameter-Lists&quot;&gt;Variable-length Parameter Lists in perlxs&lt;/a&gt;.</source>
          <target state="translated">스택의 항목 수를 나타 내기 &lt;code&gt;xsubpp&lt;/code&gt; 에 의해 설정되는 변수입니다 . &lt;a href=&quot;perlxs#Variable-length-Parameter-Lists&quot;&gt;perlxs의 가변 길이 매개 변수 목록&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="f9f90eb2fc40e8b2bdb8fd7693973daf5289f55d" translate="yes" xml:space="preserve">
          <source>Variable which is setup by &lt;code&gt;xsubpp&lt;/code&gt; to indicate the stack base offset, used by the &lt;code&gt;ST&lt;/code&gt; , &lt;code&gt;XSprePUSH&lt;/code&gt; and &lt;code&gt;XSRETURN&lt;/code&gt; macros. The &lt;code&gt;dMARK&lt;/code&gt; macro must be called prior to setup the &lt;code&gt;MARK&lt;/code&gt; variable.</source>
          <target state="translated">&lt;code&gt;ST&lt;/code&gt; , &lt;code&gt;XSprePUSH&lt;/code&gt; 및 &lt;code&gt;XSRETURN&lt;/code&gt; 매크로 에서 사용되는 스택 기본 오프셋을 나타 내기 &lt;code&gt;xsubpp&lt;/code&gt; 에 의해 설정되는 변수입니다 . &lt;code&gt;dMARK&lt;/code&gt; 의 매크로 설정 전에 호출 할 필요가 &lt;code&gt;MARK&lt;/code&gt; 변수입니다.</target>
        </trans-unit>
        <trans-unit id="71ae1592070f983485afeb1f94bb9f14e5751687" translate="yes" xml:space="preserve">
          <source>Variable which is setup by &lt;code&gt;xsubpp&lt;/code&gt; to indicate which of an XSUB's aliases was used to invoke it. See &lt;a href=&quot;perlxs#The-ALIAS%3a-Keyword&quot;&gt;The ALIAS: Keyword in perlxs&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;xsubpp&lt;/code&gt; 에 의해 설정되어 변수 를 호출하는 데 사용 된 XSUB의 별명을 표시하는 변수입니다 . &lt;a href=&quot;perlxs#The-ALIAS%3a-Keyword&quot;&gt;별명 : perlxs의 키워드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="262d6897e3f4e2ab273d197b04708a28aa8bbe0f" translate="yes" xml:space="preserve">
          <source>Variable-length Parameter Lists</source>
          <target state="translated">가변 길이 파라미터 목록</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="ab9c1a29fb6d3de8ef612773205828e2a92ce7d5" translate="yes" xml:space="preserve">
          <source>Variables begin with &quot;$&quot;, &quot;@&quot; or &quot;%&quot; in Perl.</source>
          <target state="translated">변수는 Perl에서 &quot;$&quot;, &quot;@&quot;또는 &quot;%&quot;로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="5694c664526ad480f20d39864f7f31a2f29da553" translate="yes" xml:space="preserve">
          <source>Variables beginning with underscore used to be forced into package main, but we decided it was more useful for package writers to be able to use leading underscore to indicate private variables and method names. However, variables and functions named with a single &lt;code&gt;_&lt;/code&gt; , such as $_ and &lt;code&gt;sub _&lt;/code&gt; , are still forced into the package &lt;code&gt;main&lt;/code&gt; . See also &lt;a href=&quot;perlvar#The-Syntax-of-Variable-Names&quot;&gt;The Syntax of Variable Names in perlvar&lt;/a&gt;.</source>
          <target state="translated">밑줄로 시작하는 변수는 패키지 메인에 강제로 사용되었지만 패키지 작성자가 밑줄을 사용하여 개인 변수 및 메소드 이름을 표시하는 것이 더 유용하다고 결정했습니다. 그러나 $ _ 및 &lt;code&gt;sub _&lt;/code&gt; 와 같이 단일 &lt;code&gt;_&lt;/code&gt; 로 이름 지정된 변수 및 함수 는 여전히 패키지 &lt;code&gt;main&lt;/code&gt; 에 강제 적용됩니다 . &lt;a href=&quot;perlvar#The-Syntax-of-Variable-Names&quot;&gt;perlvar의 변수 이름 구문&lt;/a&gt; 도 참조하십시오. .</target>
        </trans-unit>
        <trans-unit id="1d9f29c9ec062e45676786fba6e4ad3c40d0d306" translate="yes" xml:space="preserve">
          <source>Variables can also be marked as shared at compile time by using the &lt;code&gt;:shared&lt;/code&gt; attribute:</source>
          <target state="translated">&lt;code&gt;:shared&lt;/code&gt; 속성 을 사용하여 컴파일 타임에 변수를 공유로 표시 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0033a0c4e8e90fcf27d95fe18f7eaf535322599e" translate="yes" xml:space="preserve">
          <source>Variables created by &lt;code&gt;xsubpp&lt;/code&gt; and &lt;code&gt;xsubpp&lt;/code&gt; internal functions</source>
          <target state="translated">&lt;code&gt;xsubpp&lt;/code&gt; 및 &lt;code&gt;xsubpp&lt;/code&gt; 내부 함수로 작성된 변수</target>
        </trans-unit>
        <trans-unit id="2071c5e3d5c20b9e635746474f5973d9034dd205" translate="yes" xml:space="preserve">
          <source>Variables created by xsubpp and xsubpp internal functions</source>
          <target state="translated">xsubpp 및 xsubpp 내부 함수로 작성된 변수</target>
        </trans-unit>
        <trans-unit id="ca450e789c925910d0144b598324f623b886a902" translate="yes" xml:space="preserve">
          <source>Variables declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; are not part of any package and are therefore never fully qualified with the package name. In particular, you're not allowed to try to make a package variable (or other global) lexical:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 로 선언 된 변수 로 패키지의 일부가 아니므로 패키지 이름으로 정규화되지 않습니다. 특히 패키지 변수 (또는 다른 전역)를 어휘로 만들 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="56cf64dcca72d1ecb702e55ecfffca62a98a5220" translate="yes" xml:space="preserve">
          <source>Variables declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; only affect code</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 유일한 코드로 선언 된 변수</target>
        </trans-unit>
        <trans-unit id="8ca248e3be58f6491cbca3baeca1c24e3a843c96" translate="yes" xml:space="preserve">
          <source>Variables related to filehandles</source>
          <target state="translated">파일 핸들 관련 변수</target>
        </trans-unit>
        <trans-unit id="558d3788e0608ddd59e54bc45d3414f4ed7b1e43" translate="yes" xml:space="preserve">
          <source>Variables related to formats</source>
          <target state="translated">형식과 관련된 변수</target>
        </trans-unit>
        <trans-unit id="f14620676ede46dcf2f3ea6fa3c3858d660e5480" translate="yes" xml:space="preserve">
          <source>Variables related to regular expressions</source>
          <target state="translated">정규식 관련 변수</target>
        </trans-unit>
        <trans-unit id="68141fa59316c5490c4a375661890da2077e4814" translate="yes" xml:space="preserve">
          <source>Variables related to the interpreter state</source>
          <target state="translated">인터프리터 상태와 관련된 변수</target>
        </trans-unit>
        <trans-unit id="9c673dd907946ee700d211969e18c41800f161cd" translate="yes" xml:space="preserve">
          <source>Variables that depend on the currently selected filehandle may be set by calling an appropriate object method on the &lt;code&gt;IO::Handle&lt;/code&gt; object, although this is less efficient than using the regular built-in variables. (Summary lines below for this contain the word HANDLE.) First you must say</source>
          <target state="translated">현재 선택된 파일 핸들에 의존하는 변수는 &lt;code&gt;IO::Handle&lt;/code&gt; 오브젝트 에 대해 적절한 오브젝트 메소드를 호출하여 설정할 수 있지만, 일반 내장 변수를 사용하는 것보다 덜 효율적입니다. (여기에 대한 요약은 HANDLE이라는 단어를 포함합니다.) 먼저 말해야합니다.</target>
        </trans-unit>
        <trans-unit id="e157f974af404a93fff305d4d8e7f7a16c700432" translate="yes" xml:space="preserve">
          <source>Variant &lt;code&gt;isFOO_A&lt;/code&gt; (e.g., &lt;code&gt;isALPHA_A()&lt;/code&gt; ) is identical to the base function with no suffix &lt;code&gt;&quot;_A&quot;&lt;/code&gt; .</source>
          <target state="translated">변형 &lt;code&gt;isFOO_A&lt;/code&gt; (예 : &lt;code&gt;isALPHA_A()&lt;/code&gt; )는 접미사 &lt;code&gt;&quot;_A&quot;&lt;/code&gt; 가없는 기본 함수와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="ee9c1e7b92e7d90953ad4f56c51f36c66e7040f2" translate="yes" xml:space="preserve">
          <source>Variant &lt;code&gt;isFOO_L1&lt;/code&gt; imposes the Latin-1 (or EBCDIC equivlalent) character set onto the platform. That is, the code points that are ASCII are unaffected, since ASCII is a subset of Latin-1. But the non-ASCII code points are treated as if they are Latin-1 characters. For example, &lt;code&gt;isWORDCHAR_L1()&lt;/code&gt; will return true when called with the code point 0xDF, which is a word character in both ASCII and EBCDIC (though it represents different characters in each).</source>
          <target state="translated">변형 &lt;code&gt;isFOO_L1&lt;/code&gt; 은 플랫폼에 Latin-1 (또는 EBCDIC 등가) 문자 집합을 부과합니다. 즉, ASCII는 Latin-1의 하위 집합이므로 ASCII 인 코드 포인트는 영향을받지 않습니다. 그러나 비 ASCII 코드 포인트는 마치 라틴 -1 문자 인 것처럼 처리됩니다. 예를 들어 &lt;code&gt;isWORDCHAR_L1()&lt;/code&gt; 은 ASCII 및 EBCDIC의 단어 문자 인 코드 포인트 0xDF와 함께 호출 될 때 true를 반환합니다 (각각 다른 문자를 나타냄).</target>
        </trans-unit>
        <trans-unit id="2ba58c7880e89de07e18f6663de6bf67a770fa3f" translate="yes" xml:space="preserve">
          <source>Variant &lt;code&gt;isFOO_LC&lt;/code&gt; is like the &lt;code&gt;isFOO_A&lt;/code&gt; and &lt;code&gt;isFOO_L1&lt;/code&gt; variants, but the result is based on the current locale, which is what &lt;code&gt;LC&lt;/code&gt; in the name stands for. If Perl can determine that the current locale is a UTF-8 locale, it uses the published Unicode rules; otherwise, it uses the C library function that gives the named classification. For example, &lt;code&gt;isDIGIT_LC()&lt;/code&gt; when not in a UTF-8 locale returns the result of calling &lt;code&gt;isdigit()&lt;/code&gt; . FALSE is always returned if the input won't fit into an octet. On some platforms where the C library function is known to be defective, Perl changes its result to follow the POSIX standard's rules.</source>
          <target state="translated">변형 &lt;code&gt;isFOO_LC&lt;/code&gt; 는 &lt;code&gt;isFOO_A&lt;/code&gt; 및 &lt;code&gt;isFOO_L1&lt;/code&gt; 변형 과 유사 하지만 결과는 현재 로케일을 기반으로하며, 이는 이름의 &lt;code&gt;LC&lt;/code&gt; 가 의미하는 것입니다. Perl이 현재 로케일이 UTF-8 로케일임을 판별 할 수 있으면 공개 된 유니 코드 규칙을 사용합니다. 그렇지 않으면 명명 된 분류를 제공하는 C 라이브러리 함수를 사용합니다. 예를 들어 &lt;code&gt;isDIGIT_LC()&lt;/code&gt; UTF-8 로케일이 아닌 경우 는 &lt;code&gt;isdigit()&lt;/code&gt; 호출 결과를 리턴합니다 . 입력이 옥텟에 맞지 않으면 항상 FALSE가 반환됩니다. C 라이브러리 기능에 결함이있는 것으로 알려진 일부 플랫폼에서 Perl은 POSIX 표준의 규칙에 따라 결과를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="0cd770db8027add93d163f3958fbe5e0a03fc884" translate="yes" xml:space="preserve">
          <source>Variant &lt;code&gt;isFOO_LC_utf8&lt;/code&gt; is like &lt;code&gt;isFOO_LC_uvchr&lt;/code&gt; , but the input is a pointer to a (known to be well-formed) UTF-8 encoded string (&lt;code&gt;U8*&lt;/code&gt; or &lt;code&gt;char*&lt;/code&gt; ). The classification of just the first (possibly multi-byte) character in the string is tested.</source>
          <target state="translated">변형 &lt;code&gt;isFOO_LC_utf8&lt;/code&gt; 은 isFOO_LC_uvchr 과 &lt;code&gt;isFOO_LC_uvchr&lt;/code&gt; 하지만 입력은 (잘 구성된) UTF-8 인코딩 문자열 ( &lt;code&gt;U8*&lt;/code&gt; 또는 &lt;code&gt;char*&lt;/code&gt; )에 입니다. 문자열에서 첫 번째 (아마 멀티 바이트) 문자의 분류가 테스트됩니다.</target>
        </trans-unit>
        <trans-unit id="2e2baae040164a854cd256e8bb0078a6be7e0556" translate="yes" xml:space="preserve">
          <source>Variant &lt;code&gt;isFOO_LC_uvchr&lt;/code&gt; is like &lt;code&gt;isFOO_LC&lt;/code&gt; , but is defined on any UV. It returns the same as &lt;code&gt;isFOO_LC&lt;/code&gt; for input code points less than 256, and returns the hard-coded, not-affected-by-locale, Unicode results for larger ones.</source>
          <target state="translated">변형 &lt;code&gt;isFOO_LC_uvchr&lt;/code&gt; 은 isFOO_LC 와 &lt;code&gt;isFOO_LC&lt;/code&gt; 하지만 모든 UV에서 정의됩니다. 256 미만의 입력 코드 포인트에 대해서는 &lt;code&gt;isFOO_LC&lt;/code&gt; 와 동일을 리턴하고, 로케일별로 영향을받지 않는 하드 코딩 된 큰 유니 코드 결과를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2ad298897b2ed0cfe491083076d3380e15f29221" translate="yes" xml:space="preserve">
          <source>Variant &lt;code&gt;isFOO_uni&lt;/code&gt; is like the &lt;code&gt;isFOO_L1&lt;/code&gt; variant, but accepts any UV code point as input. If the code point is larger than 255, Unicode rules are used to determine if it is in the character class. For example, &lt;code&gt;isWORDCHAR_uni(0x100)&lt;/code&gt; returns TRUE, since 0x100 is LATIN CAPITAL LETTER A WITH MACRON in Unicode, and is a word character.</source>
          <target state="translated">변형 &lt;code&gt;isFOO_uni&lt;/code&gt; 는 &lt;code&gt;isFOO_L1&lt;/code&gt; 변형 과 유사 하지만 UV 코드 포인트를 입력으로 허용합니다. 코드 포인트가 255보다 큰 경우 유니 코드 규칙을 사용하여 코드 포인트가 문자 클래스에 있는지 확인합니다. 예를 들어 &lt;code&gt;isWORDCHAR_uni(0x100)&lt;/code&gt; 은 0x100이 유니 코드로 된 대문자 대문자를 가진 라틴 문자이고 단어 문자이므로 TRUE를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4a2fc63255fac34edd7ea0e57902967c8c3777dd" translate="yes" xml:space="preserve">
          <source>Variant &lt;code&gt;isFOO_utf8&lt;/code&gt; is like &lt;code&gt;isFOO_uni&lt;/code&gt; , but the input is a pointer to a (known to be well-formed) UTF-8 encoded string (&lt;code&gt;U8*&lt;/code&gt; or &lt;code&gt;char*&lt;/code&gt; ). The classification of just the first (possibly multi-byte) character in the string is tested.</source>
          <target state="translated">변형 &lt;code&gt;isFOO_utf8&lt;/code&gt; 은 isFOO_uni 와 &lt;code&gt;isFOO_uni&lt;/code&gt; 하지만 입력은 (잘 구성된) UTF-8 인코딩 문자열 ( &lt;code&gt;U8*&lt;/code&gt; 또는 &lt;code&gt;char*&lt;/code&gt; )에 대한 포인터 입니다. 문자열에서 첫 번째 (아마 멀티 바이트) 문자의 분류가 테스트됩니다.</target>
        </trans-unit>
        <trans-unit id="786f5e70748cc3ce6d3a4d95eb203e5790a45b20" translate="yes" xml:space="preserve">
          <source>Variant of make you intend to run the generated Makefile with. This parameter lets Makefile.PL know what make quirks to account for when generating the Makefile.</source>
          <target state="translated">생성 된 Makefile을 실행하려는 변형입니다. 이 매개 변수는 Makefile.PL이 Makefile을 생성 할 때 고려해야 할 사항을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="8c77b7455bfd7adea569c5a3c57a2f0f3eeee8c3" translate="yes" xml:space="preserve">
          <source>Various ALLOW flags can be set in &lt;code&gt;flags&lt;/code&gt; to allow (and not warn on) individual types of malformations, such as the sequence being overlong (that is, when there is a shorter sequence that can express the same code point; overlong sequences are expressly forbidden in the UTF-8 standard due to potential security issues). Another malformation example is the first byte of a character not being a legal first byte. See</source>
          <target state="translated">다양는 플래그가 설정 될 수있는 허용 &lt;code&gt;flags&lt;/code&gt; 등의 시퀀스 (동일한 코드 포인트를 나타낼 수 짧은 시퀀스가있을 때 즉, 너무 긴 인 것으로 기형 개별 유형 (및에 경고하지 않음) 할 수 있도록, 너무 긴 시퀀스가 명백히 금지 잠재적 보안 문제로 인해 UTF-8 표준에서). 다른 기형의 예는 유효한 첫 바이트가 아닌 문자의 첫 번째 바이트입니다. 보다</target>
        </trans-unit>
        <trans-unit id="afddad8d7b065f14bf0be2c971fc90accba56a72" translate="yes" xml:space="preserve">
          <source>Various Unicode Transformation Formats</source>
          <target state="translated">다양한 유니 코드 변환 형식</target>
        </trans-unit>
        <trans-unit id="07521b5f641f36eca327ef3a95aecd1a3cb86300" translate="yes" xml:space="preserve">
          <source>Various flags whose names begin with &lt;code&gt;ANYOF_&lt;/code&gt; are used for special situations. Above Latin1 matches and things not known until run-time are stored in &lt;a href=&quot;#Perl's-pprivate-structure&quot;&gt;Perl's pprivate structure&lt;/a&gt;.</source>
          <target state="translated">이름이 &lt;code&gt;ANYOF_&lt;/code&gt; 로 시작하는 다양한 플래그가 특수 상황에 사용됩니다. 위의 Latin1 경기와 런타임까지 알려지지 않은 것은 &lt;a href=&quot;#Perl's-pprivate-structure&quot;&gt;Perl의 개인 구조에&lt;/a&gt; 저장됩니다. .</target>
        </trans-unit>
        <trans-unit id="44c78407657471f7c495761722bd853edd5018b1" translate="yes" xml:space="preserve">
          <source>Various people have made helpful suggestions and contributions, in particular:</source>
          <target state="translated">다양한 사람들이 특히 유용한 제안과 기여를했습니다.</target>
        </trans-unit>
        <trans-unit id="e18054f599f969e2a7425c026d09df10072d24d7" translate="yes" xml:space="preserve">
          <source>Various tools exist for analysing C source code &lt;b&gt;statically&lt;/b&gt;, as opposed to &lt;b&gt;dynamically&lt;/b&gt;, that is, without executing the code. It is possible to detect resource leaks, undefined behaviour, type mismatches, portability problems, code paths that would cause illegal memory accesses, and other similar problems by just parsing the C code and looking at the resulting graph, what does it tell about the execution and data flows. As a matter of fact, this is exactly how C compilers know to give warnings about dubious code.</source>
          <target state="translated">다양한 도구는 C의 소스 코드 분석을 위해 존재 &lt;b&gt;정적&lt;/b&gt; 달리, &lt;b&gt;동적&lt;/b&gt; 코드를 실행하지 않고, 즉,. C 코드를 구문 분석하고 결과 그래프를 보면 리소스 누수, 정의되지 않은 동작, 유형 불일치, 이식성 문제, 잘못된 메모리 액세스를 유발하는 코드 경로 및 기타 유사한 문제를 감지 할 수 있습니다. 그리고 데이터 흐름. 사실, 이것은 C 컴파일러가 모호한 코드에 대해 경고하는 방법을 정확히 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="73cab00905b3a6637e1ac427d0bd8b9c7ea4bd82" translate="yes" xml:space="preserve">
          <source>Various useful techniques for the redirection of STDOUT and STDERR filehandles are explained in &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt; and &lt;a href=&quot;perlfaq8&quot;&gt;perlfaq8&lt;/a&gt;.</source>
          <target state="translated">STDOUT 및 STDERR 파일 핸들의 재 지정에 대한 다양한 유용한 기술이 &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt; 및 &lt;a href=&quot;perlfaq8&quot;&gt;perlfaq8에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="348afb03d84f05d16f7adbc3eb8e693f676f5018" translate="yes" xml:space="preserve">
          <source>Varying slowly compared to something else. (Unfortunately, everything is relatively stable compared to something else, except for certain elementary particles, and we&amp;rsquo;re not so sure about them.) In computers, where things are supposed to vary rapidly, &amp;ldquo;static&amp;rdquo; has a derogatory connotation, indicating a slightly dysfunctional &lt;b&gt;variable&lt;/b&gt;, &lt;b&gt;subroutine&lt;/b&gt;, or &lt;b&gt;method&lt;/b&gt;. In Perl culture, the word is politely avoided.</source>
          <target state="translated">다른 것에 비해 천천히 변화. (불행히도, 일부 기본 입자를 제외하고는 모든 것이 다른 것에 비해 상대적으로 안정적이며, 확실하지 않습니다.) 컴퓨터가 빠르게 변해야하는 컴퓨터에서 &quot;정적&quot;은 경멸 적 의미를 나타냅니다. 약간 기능 장애가있는 &lt;b&gt;변수&lt;/b&gt; , &lt;b&gt;서브 루틴&lt;/b&gt; 또는 &lt;b&gt;방법&lt;/b&gt; . 펄 문화에서 단어는 정중하게 피합니다.</target>
        </trans-unit>
        <trans-unit id="85ffef503f476138b4fff0b28711a4307dd0273e" translate="yes" xml:space="preserve">
          <source>Vendor locales are notoriously buggy, and it is difficult for Perl to test its locale-handling code because this interacts with code that Perl has no control over; therefore the locale-handling code in Perl may be buggy as well. (However, the Unicode-supplied locales should be better, and there is a feed back mechanism to correct any problems. See &lt;a href=&quot;#Freely-available-locale-definitions&quot;&gt;Freely available locale definitions&lt;/a&gt;.)</source>
          <target state="translated">공급 업체 로캘은 악명 높으며 Perl이 제어 할 수없는 코드와 상호 작용하기 때문에 로캘 처리 코드를 테스트하기가 어렵습니다. 따라서 Perl의 로케일 처리 코드도 버그가있을 수 있습니다. 그러나 유니 코드 제공 로케일이 더 우수해야하며 문제점을 정정하는 피드백 메커니즘이 있습니다. &lt;a href=&quot;#Freely-available-locale-definitions&quot;&gt;자유롭게 사용 가능한 로케일 정의를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d32a0f82e0ef391607d7fd073f792ba0310faa2" translate="yes" xml:space="preserve">
          <source>Verbatim Paragraph</source>
          <target state="translated">축 어적 단락</target>
        </trans-unit>
        <trans-unit id="3c3c8bdee8d70621828a9acf42235be7b9af6f25" translate="yes" xml:space="preserve">
          <source>Verbatim paragraphs are usually used for presenting a codeblock or other text which does not require any special parsing or formatting, and which shouldn't be wrapped.</source>
          <target state="translated">축약어 단락은 일반적으로 특수 구문 분석이나 형식화가 필요하지 않으며 랩핑되어서는 안되는 코드 블록 또는 기타 텍스트를 표시하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d2ed762aa9e6f4a70c69d05cecc69ec96c79f712" translate="yes" xml:space="preserve">
          <source>Verbosity level for PERL5LIB changes (none or v)?</source>
          <target state="translated">PERL5LIB 변경에 대한 상세 레벨 (없음 또는 v)?</target>
        </trans-unit>
        <trans-unit id="b16f50ef11893ee8a56a924cf21f29d6d3384b2d" translate="yes" xml:space="preserve">
          <source>Verbosity level for loading modules (none or v)?</source>
          <target state="translated">모듈 로딩에 대한 상세 레벨 (없음 또는 v)?</target>
        </trans-unit>
        <trans-unit id="5c786adc4be052262918fbf867ae699f3967bdb1" translate="yes" xml:space="preserve">
          <source>Verifies your POD's correctness</source>
          <target state="translated">POD의 정확성을 확인</target>
        </trans-unit>
        <trans-unit id="d4e18ac1b3adf04f8a64f79e732d6cb231328446" translate="yes" xml:space="preserve">
          <source>Verify that</source>
          <target state="translated">확인</target>
        </trans-unit>
        <trans-unit id="c6d2ae8d70f95ac35eb4f17f52487e3fbb74bfe8" translate="yes" xml:space="preserve">
          <source>Verify that &lt;code&gt;ADDRESS&lt;/code&gt; is a legitimate mailing address.</source>
          <target state="translated">&lt;code&gt;ADDRESS&lt;/code&gt; 가 합법적 인 우편 주소인지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="aa131b92248ccc3e18a5da63bd932dabad63bce2" translate="yes" xml:space="preserve">
          <source>Verify that the element at index</source>
          <target state="translated">색인의 요소가</target>
        </trans-unit>
        <trans-unit id="994d1b0dafb2a784fe9a62de996298af3c56fa67" translate="yes" xml:space="preserve">
          <source>Version 0.17</source>
          <target state="translated">버전 0.17</target>
        </trans-unit>
        <trans-unit id="cf9296ff9faf64bcbf7077fc94b20c36180a2b81" translate="yes" xml:space="preserve">
          <source>Version 1.0 metadata specification for META.yml</source>
          <target state="translated">META.yml의 버전 1.0 메타 데이터 사양</target>
        </trans-unit>
        <trans-unit id="5f58248b430683f1248cf64cbe1e704fe1b1c2aa" translate="yes" xml:space="preserve">
          <source>Version 1.1 metadata specification for META.yml</source>
          <target state="translated">META.yml의 버전 1.1 메타 데이터 사양</target>
        </trans-unit>
        <trans-unit id="6b502e3047cfe1751d1d1b7edc28b46bfd3a8d92" translate="yes" xml:space="preserve">
          <source>Version 1.2 metadata specification for META.yml</source>
          <target state="translated">META.yml의 버전 1.2 메타 데이터 사양</target>
        </trans-unit>
        <trans-unit id="c0707932557d9b8e2fa8ebb9e9863bf7fee11d96" translate="yes" xml:space="preserve">
          <source>Version 1.3 metadata specification for META.yml</source>
          <target state="translated">META.yml의 버전 1.3 메타 데이터 사양</target>
        </trans-unit>
        <trans-unit id="6bb856fd2cb7a8a4749ea08a96d81eed38d2bee4" translate="yes" xml:space="preserve">
          <source>Version 1.3, 14th Apr 1997</source>
          <target state="translated">버전 1.3, 1997 년 4 월 14 일</target>
        </trans-unit>
        <trans-unit id="50cdda2fafe15d6a81c70eb22bbe3a4d4d6f2154" translate="yes" xml:space="preserve">
          <source>Version 1.4 metadata specification for META.yml</source>
          <target state="translated">META.yml의 버전 1.4 메타 데이터 사양</target>
        </trans-unit>
        <trans-unit id="e595432938de926793decdb5491565f726cb5632" translate="yes" xml:space="preserve">
          <source>Version 1.x of Devel::PPPort was written by Kenneth Albanowski.</source>
          <target state="translated">Kenneth Albanowski가 Devel :: PPPort 버전 1.x를 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="a64e96de79863ac878adbe6d99f0ef3004f7ada2" translate="yes" xml:space="preserve">
          <source>Version 1.x, Copyright (C) 1999, Kenneth Albanowski.</source>
          <target state="translated">버전 1.x, Copyright (C) 1999, Kenneth Albanowski.</target>
        </trans-unit>
        <trans-unit id="a5a2dcb962ed837bde5bb2d230fbf541ca8dd67b" translate="yes" xml:space="preserve">
          <source>Version 1.x, Copyright (c) 1997, Graham Barr.</source>
          <target state="translated">버전 1.x, Copyright (c) 1997, Graham Barr.</target>
        </trans-unit>
        <trans-unit id="45647cd5610f6e1c8ad80ff8302e3680ebe69bd4" translate="yes" xml:space="preserve">
          <source>Version 2.07 included 2 functions for modifying the internal data: rename_country and alias_code. Both of these could be used only to modify the internal data for country codes.</source>
          <target state="translated">버전 2.07에는 내부 데이터를 수정하기위한 rename_country 및 alias_code의 두 가지 기능이 포함되어 있습니다. 둘 다 국가 코드의 내부 데이터를 수정하는 데만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92a1c91419a81cd1268ac19dce637a320313655e" translate="yes" xml:space="preserve">
          <source>Version 2.158 (March 13 2015)</source>
          <target state="translated">버전 2.158 (2015 년 3 월 13 일)</target>
        </trans-unit>
        <trans-unit id="2b76e68914b5b481fce750a4808d6a01e4e0d7a5" translate="yes" xml:space="preserve">
          <source>Version 2.x was ported to the Perl core by Paul Marquess.</source>
          <target state="translated">버전 2.x는 Paul Marquess에 의해 Perl 코어로 이식되었습니다.</target>
        </trans-unit>
        <trans-unit id="b4dfa929b5ee3edcabc4bb1ff1f2299b2ba1ffbf" translate="yes" xml:space="preserve">
          <source>Version 2.x, Copyright (C) 2001, Paul Marquess.</source>
          <target state="translated">버전 2.x, Copyright (C) 2001, Paul Marquess.</target>
        </trans-unit>
        <trans-unit id="afb9e5ddc0f066d6e4fe7219b73a7a8e7aeed9fa" translate="yes" xml:space="preserve">
          <source>Version 2.x, Copyright (C) 2007-2013, Marcus Holland-Moritz.</source>
          <target state="translated">버전 2.x, Copyright (C) 2007-2013, Marcus Holland-Moritz.</target>
        </trans-unit>
        <trans-unit id="2b92364fcb707c868641f18b85e8bb1624050d73" translate="yes" xml:space="preserve">
          <source>Version 3.35</source>
          <target state="translated">버전 3.35</target>
        </trans-unit>
        <trans-unit id="4f0303ef100e7bd0b627ac0ed92f17d79836c82a" translate="yes" xml:space="preserve">
          <source>Version 3.x was ported back to CPAN by Marcus Holland-Moritz.</source>
          <target state="translated">버전 3.x는 Marcus Holland-Moritz가 CPAN으로 다시 포팅했습니다.</target>
        </trans-unit>
        <trans-unit id="87ba3aa39294d7bd5f976dfda6425a25c0769a48" translate="yes" xml:space="preserve">
          <source>Version 3.x, Copyright (C) 2004-2013, Marcus Holland-Moritz.</source>
          <target state="translated">버전 3.x, Copyright (C) 2004-2013, Marcus Holland-Moritz.</target>
        </trans-unit>
        <trans-unit id="70ac02d65beabeafc66ef77aabf5e475e6710dac" translate="yes" xml:space="preserve">
          <source>Version 8 Regular Expressions</source>
          <target state="translated">버전 8 정규식</target>
        </trans-unit>
        <trans-unit id="5148ac4d9167ac054bd9f1a1a44dfedd508ff1b8" translate="yes" xml:space="preserve">
          <source>Version Strings</source>
          <target state="translated">버전 문자열</target>
        </trans-unit>
        <trans-unit id="68c98714c821df335863c348a8dc241ec68a74da" translate="yes" xml:space="preserve">
          <source>Version caveat</source>
          <target state="translated">버전주의</target>
        </trans-unit>
        <trans-unit id="01e4cae31c98991a3d53edad9d5a04ca08ed4f3b" translate="yes" xml:space="preserve">
          <source>Version numbering</source>
          <target state="translated">버전 번호</target>
        </trans-unit>
        <trans-unit id="7a4b23d2aee6859898d9d8a68bcc2c3cf6b34466" translate="yes" xml:space="preserve">
          <source>Version numbers can be checked like so:</source>
          <target state="translated">버전 번호는 다음과 같이 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ea6fb41a1f5c2adb11175166f62cfde32e3e36d" translate="yes" xml:space="preserve">
          <source>Version numbers should indicate at least major and minor releases, and possibly sub-minor releases. A major release is one in which most of the functionality has changed, or in which major new functionality is added. A minor release is one in which a small amount of functionality has been added or changed. Sub-minor version numbers are usually used for changes which do not affect functionality, such as documentation patches.</source>
          <target state="translated">버전 번호는 최소한 메이저 릴리스 및 마이너 릴리스를 표시해야합니다. 주 릴리스는 대부분의 기능이 변경되었거나 새로운 주요 기능이 추가 된 릴리스입니다. 부 릴리스는 소량의 기능이 추가되거나 변경된 릴리스입니다. 하위 부 버전 번호는 일반적으로 설명서 패치와 같이 기능에 영향을 미치지 않는 변경에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d33038b68a6d275b70080c4ca40f495c404258ac" translate="yes" xml:space="preserve">
          <source>Version object aware cmp. Both operands must already have been converted into version objects.</source>
          <target state="translated">버전 객체 인식 cmp. 두 피연산자가 이미 버전 객체로 변환되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="2750d3223582565870adf32b96da562927d7229f" translate="yes" xml:space="preserve">
          <source>Versioning</source>
          <target state="translated">Versioning</target>
        </trans-unit>
        <trans-unit id="6fe8bcdb81f192c675970c262f42ae11e468a493" translate="yes" xml:space="preserve">
          <source>Versions &amp;gt;= 3.22 are maintained with support from Matthew Horsfall (alh).</source>
          <target state="translated">&amp;gt; = 3.22 버전은 Matthew Horsfall (alh)의 지원을 받아 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="0a0e4cacd3bf4b53f4105e538a9024d7fb5c49ec" translate="yes" xml:space="preserve">
          <source>Versions of Perl from 5.002 to 5.003 did use the &lt;code&gt;LC_CTYPE&lt;/code&gt; information if available; that is, &lt;code&gt;\w&lt;/code&gt; did understand what were the letters according to the locale environment variables. The problem was that the user had no control over the feature: if the C library supported locales, Perl used them.</source>
          <target state="translated">5.002에서 5.003까지의 Perl 버전은 사용 가능한 경우 &lt;code&gt;LC_CTYPE&lt;/code&gt; 정보를 사용했습니다. 즉, &lt;code&gt;\w&lt;/code&gt; 는 로캘 환경 변수에 따라 문자가 무엇인지 이해했습니다. 문제는 사용자가 기능을 제어 할 수 없다는 것입니다. C 라이브러리가 로케일을 지원하면 Perl에서이 기능을 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="e19f78e14eb21b19646ec53e2aa5cba777aaa99b" translate="yes" xml:space="preserve">
          <source>Versions of Perl prior to 5.004 &lt;b&gt;mostly&lt;/b&gt; ignored locale information, generally behaving as if something similar to the &lt;code&gt;&quot;C&quot;&lt;/code&gt; locale were always in force, even if the program environment suggested otherwise (see &lt;a href=&quot;#The-setlocale-function&quot;&gt;The setlocale function&lt;/a&gt;). By default, Perl still behaves this way for backward compatibility. If you want a Perl application to pay attention to locale information, you &lt;b&gt;must&lt;/b&gt; use the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; pragma (see &lt;a href=&quot;#The-%22use-locale%22-pragma&quot;&gt;The use locale pragma&lt;/a&gt;) or, in the unlikely event that you want to do so for just pattern matching, the &lt;code&gt;/l&lt;/code&gt; regular expression modifier (see &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;Character set modifiers in perlre&lt;/a&gt;) to instruct it to do so.</source>
          <target state="translated">5.004 이전의 Perl 버전은 로케일 정보를 &lt;b&gt;대부분&lt;/b&gt; 무시했습니다. 일반적으로 프로그램 환경에서 다르게 제안하더라도 &lt;code&gt;&quot;C&quot;&lt;/code&gt; 로케일 과 유사한 것이 항상 적용되는 것처럼 작동합니다 ( &lt;a href=&quot;#The-setlocale-function&quot;&gt;setlocale 함수&lt;/a&gt; 참조 ). 기본적으로 Perl은 이전 버전과의 호환성을 위해 여전히이 방식으로 작동합니다. 당신이 로케일 정보에주의로 펄 응용 프로그램을 원하는 경우에, 당신은 &lt;b&gt;해야한다&lt;/b&gt; 사용 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 프라그를 (참조 &lt;a href=&quot;#The-%22use-locale%22-pragma&quot;&gt;사용 로케일 프라그를&lt;/a&gt; , 당신은 단지 패턴 매칭을 위해 그렇게하도록 드문 경우에,) 또는 &lt;code&gt;/l&lt;/code&gt; 정규 표현식 수정 그렇게하도록 지시하려면 ( &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;perlre의 문자 세트 수정 자&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="cd42417aaf403d8a849b95358e372d8ab627e926" translate="yes" xml:space="preserve">
          <source>Versions of Perl prior to 5.6 would recompile the regular expression for each iteration, even if &lt;code&gt;$pattern&lt;/code&gt; had not changed. The &lt;code&gt;/o&lt;/code&gt; would prevent this by telling Perl to compile the pattern the first time, then reuse that for subsequent iterations:</source>
          <target state="translated">5.6 이전의 Perl 버전은 &lt;code&gt;$pattern&lt;/code&gt; 이 변경되지 않은 경우에도 각 반복에 대한 정규식을 다시 컴파일합니다 . 는 &lt;code&gt;/o&lt;/code&gt; 패턴을 처음 컴파일 펄을 이야기하여이를 방지 할 수, 후속 반복에 대한 것을 다시 :</target>
        </trans-unit>
        <trans-unit id="3862168f946314ea765703eeec887a87938d1f6e" translate="yes" xml:space="preserve">
          <source>Versions prior to perl5.004 had serious security problems with buffer overflows, and in some cases have CERT advisories (for instance, &lt;a href=&quot;http://www.cert.org/advisories/CA-1997-17.html&quot;&gt;http://www.cert.org/advisories/CA-1997-17.html&lt;/a&gt; ).</source>
          <target state="translated">perl5.004 이전의 버전은 버퍼 오버 플로우와 관련하여 심각한 보안 문제가 있었으며 경우에 따라 CERT 권고가 있습니다 (예 : &lt;a href=&quot;http://www.cert.org/advisories/CA-1997-17.html&quot;&gt;http://www.cert.org/advisories/CA-1997-17.html&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="af88a51473f729bd7efb750c66c484d3ad88aa17" translate="yes" xml:space="preserve">
          <source>Versions up to 2.11 Copyright (c) 1995-2004 Graham Barr. All rights reserved. Changes in Version 2.11 onwards Copyright (C) 2014 Steve Hay. All rights reserved.</source>
          <target state="translated">최대 2.11 버전 Copyright (c) 1995-2004 Graham Barr. 판권 소유. 버전 2.11 이후의 변경 사항 Copyright (C) 2014 Steve Hay. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="645570264e1c9b5d4c69c1487a566c0753776ad2" translate="yes" xml:space="preserve">
          <source>Versions up to 2.13 Copyright (c) 1995-1998 Graham Barr. All rights reserved. Changes in Version 2.13_01 onwards Copyright (C) 2013-2014 Steve Hay. All rights reserved.</source>
          <target state="translated">최대 2.13 버전 Copyright (c) 1995-1998 Graham Barr. 판권 소유. 버전 2.13_01 이후의 변경 사항 Copyright (C) 2013-2014 Steve Hay. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="df128b7f68ed19de182414be1bd4f1f2d9c6a0b4" translate="yes" xml:space="preserve">
          <source>Versions up to 2.21 Copyright (c) 1995-1998 Graham Barr. All rights reserved. Changes in Version 2.22 onwards Copyright (C) 2013-2014 Steve Hay. All rights reserved.</source>
          <target state="translated">최대 2.21 버전 Copyright (c) 1995-1998 Graham Barr. 판권 소유. 버전 2.22 이후의 변경 사항 Copyright (C) 2013-2014 Steve Hay. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="230af24ce1338603fae4bdb469b6688c0e4037a9" translate="yes" xml:space="preserve">
          <source>Versions up to 2.24_1 Copyright (c) 1995-1997 Graham Barr. All rights reserved. Changes in Version 2.25 onwards Copyright (C) 2013-2014 Steve Hay. All rights reserved.</source>
          <target state="translated">최대 2.24_1 버전 저작권 (c) 1995-1997 Graham Barr. 판권 소유. 버전 2.25 이후의 변경 사항 Copyright (C) 2013-2014 Steve Hay. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="5670a2aa1f7771d1194bac3e8af5f2d1835dd801" translate="yes" xml:space="preserve">
          <source>Versions up to 2.29 Copyright (c) 1995-2004 Graham Barr. All rights reserved. Changes in Version 2.29_01 onwards Copyright (C) 2013-2014 Steve Hay. All rights reserved.</source>
          <target state="translated">최대 2.29 버전 (c) 1995-2004 Graham Barr. 판권 소유. 버전 2.29_01 이후의 변경 사항 Copyright (C) 2013-2014 Steve Hay. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="f23d5e96a8b776d3b4630eccbbe42aa010b76c05" translate="yes" xml:space="preserve">
          <source>Versions up to 2.29_1 Copyright (c) 1995-2006 Graham Barr. All rights reserved. Changes in Version 2.29_2 onwards Copyright (C) 2013-2014 Steve Hay. All rights reserved.</source>
          <target state="translated">최대 2.29_1 버전 저작권 (c) 1995-2006 Graham Barr. 판권 소유. 버전 2.29_2 이후의 변경 사항 Copyright (C) 2013-2014 Steve Hay. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="84d20de3782c28252a3c6f7756f86f07da1b04bb" translate="yes" xml:space="preserve">
          <source>Versions up to 2.31_1 Copyright (c) 1995-2004 Graham Barr. All rights reserved. Changes in Version 2.31_2 onwards Copyright (C) 2013-2014 Steve Hay. All rights reserved.</source>
          <target state="translated">최대 2.31_1 버전 저작권 (c) 1995-2004 Graham Barr. 판권 소유. 버전 2.31_2 이후의 변경 사항 Copyright (C) 2013-2014 Steve Hay. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="e46c1089fa8e642aaf026e639393be6e2f9a3f93" translate="yes" xml:space="preserve">
          <source>Versions up to 2.77_2 Copyright (c) 1995-2004 Graham Barr. All rights reserved. Changes in Version 2.77_3 onwards Copyright (C) 2013-2014 Steve Hay. All rights reserved.</source>
          <target state="translated">최대 2.77_2 버전 (c) 1995-2004 Graham Barr. 판권 소유. 버전 2.77_3 이후의 변경 사항 Copyright (C) 2013-2014 Steve Hay. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="3e953c4e403299818cc2d2c327160433abe8b2b9" translate="yes" xml:space="preserve">
          <source>Very large code points (above 0x7FFF_FFFF) are considered more problematic than the others that are above the Unicode legal maximum. There are several reasons: they requre at least 32 bits to represent them on ASCII platforms, are not representable at all on EBCDIC platforms, and the original UTF-8 specification never went above this number (the current 0x10FFFF limit was imposed later). (The smaller ones, those that fit into 32 bits, are representable by a UV on ASCII platforms, but not by an IV, which means that the number of operations that can be performed on them is quite restricted.) The UTF-8 encoding on ASCII platforms for these large code points begins with a byte containing 0xFE or 0xFF. The UTF8_DISALLOW_FE_FF flag will cause them to be treated as malformations, while allowing smaller above-Unicode code points. (Of course UTF8_DISALLOW_SUPER will treat all above-Unicode code points, including these, as malformations.) Similarly, UTF8_WARN_FE_FF acts just like the other WARN flags, but applies just to these code points.</source>
          <target state="translated">매우 큰 코드 포인트 (0x7FFF_FFFF 이상)는 유니 코드 법적 최대 값을 초과하는 다른 코드 포인트보다 더 문제가있는 것으로 간주됩니다. 몇 가지 이유가 있습니다. ASCII 플랫폼에서는 32 비트 이상을 나타내야하며 EBCDIC 플랫폼에서는 전혀 표현할 수 없으며 원래 UTF-8 사양은이 수를 초과하지 않았습니다 (현재 0x10FFFF 제한은 나중에 부과됨). (32 비트에 맞는 작은 것들은 ASCII 플랫폼에서는 UV로 표현할 수 있지만 IV로는 표현할 수 없습니다. 즉, 그들에 대해 수행 될 수있는 작업의 수가 상당히 제한되어 있습니다.) UTF-8 인코딩 이러한 큰 코드 포인트에 대한 ASCII 플랫폼에서 0xFE 또는 0xFF를 포함하는 바이트로 시작합니다. UTF8_DISALLOW_FE_FF 플래그는 유니 코드보다 작은 코드 포인트를 허용하면서 기형으로 취급합니다.(물론 UTF8_DISALLOW_SUPER는이를 포함하여 모든 유니 코드 위의 코드 포인트를 기형으로 취급합니다.) 마찬가지로 UTF8_WARN_FE_FF는 다른 WARN 플래그와 동일하게 작동하지만 이러한 코드 포인트에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="a0d5201ccd05c9ec8ec53b6a69352780556eae41" translate="yes" xml:space="preserve">
          <source>Very little work should be needed since nothing changes until you generate Unicode data. The most important thing is getting input as Unicode; for that, see the earlier I/O discussion. To get full seamless Unicode support, add &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; or higher) to your script.</source>
          <target state="translated">유니 코드 데이터를 생성 할 때까지 아무런 변화가 없으므로 작업이 거의 필요하지 않습니다. 가장 중요한 것은 입력을 유니 코드로 얻는 것입니다. 이에 대해서는 이전 I / O 토론을 참조하십시오. 완벽한 유니 코드 지원을 받으려면 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; (또는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; 이상 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; )를 스크립트에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="eb22342c76c7e665931efb33364b8148d2bfea0a" translate="yes" xml:space="preserve">
          <source>Very nearly all Unicode character properties are accessible through regular expressions by using the &lt;code&gt;\p{}&lt;/code&gt; &quot;matches property&quot; construct and the &lt;code&gt;\P{}&lt;/code&gt; &quot;doesn't match property&quot; for its negation.</source>
          <target state="translated">거의 모든 유니 코드 문자 속성은 &lt;code&gt;\p{}&lt;/code&gt; &quot;matches property&quot;구문과 &lt;code&gt;\P{}&lt;/code&gt; &quot;properties와 일치하지 않음&quot; 을 사용하여 정규식을 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5c9d6c4d037708bb7601d0c4b194d48f70b48661" translate="yes" xml:space="preserve">
          <source>Very probably not. Unless you are generating Unicode characters somehow, old behaviour should be preserved. About the only behaviour that has changed and which could start generating Unicode is the old behaviour of &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; where supplying an argument more than 255 produced a character modulo 255. &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(300)&lt;/a&gt;&lt;/code&gt;, for example, was equal to &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(45)&lt;/a&gt;&lt;/code&gt; or &quot;-&quot; (in ASCII), now it is LATIN CAPITAL LETTER I WITH BREVE.</source>
          <target state="translated">아마 아닐 것입니다. 어떻게 든 유니 코드 문자를 생성하지 않는 한 이전 동작을 유지해야합니다. 유일한 문제에 대한 그 변경 및 유니 코드의 이전 동작이다 생성 시작할 수있는 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; 문자 모듈 255 제조 255의 인수 공급 여기서 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(300)&lt;/a&gt;&lt;/code&gt; , 예를 들면, 동등했다 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(45)&lt;/a&gt;&lt;/code&gt; 또는 &quot;-&quot;(ASCII), 이제 라틴 대문자 L을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3df57364769892c03471ecd89738053fe81083da" translate="yes" xml:space="preserve">
          <source>Very similar to HTML/XML &lt;code&gt;&amp;amp;&lt;i&gt;foo&lt;/i&gt;;&lt;/code&gt; &quot;entity references&quot;:</source>
          <target state="translated">HTML / XML &lt;code&gt;&amp;amp;&lt;i&gt;foo&lt;/i&gt;;&lt;/code&gt; 와 매우 유사합니다 . &quot;엔티티 참조&quot;:</target>
        </trans-unit>
        <trans-unit id="88a7cc964078758d646c21f587f22b62e9a2dd56" translate="yes" xml:space="preserve">
          <source>Very useful online reference material:</source>
          <target state="translated">매우 유용한 온라인 참조 자료 :</target>
        </trans-unit>
        <trans-unit id="81b34b94e5e74c2375523a735ce4a25a6536b5a0" translate="yes" xml:space="preserve">
          <source>View a few lines of code around the current line.</source>
          <target state="translated">현재 줄 주변의 몇 줄의 코드를 봅니다.</target>
        </trans-unit>
        <trans-unit id="ee53ceb3384ce0d69b124dce7f13e6c99981e32e" translate="yes" xml:space="preserve">
          <source>View existing bug reports at, and submit any new bugs, problems, patches, etc. to: &lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=threads-shared&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=threads-shared&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=threads-shared&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=threads-shared&lt;/a&gt; 에서 기존 버그 보고서를보고 새 버그, 문제, 패치 등을 제출하십시오.</target>
        </trans-unit>
        <trans-unit id="3ee82a6b555759727c4e5933e475a065e10be5a6" translate="yes" xml:space="preserve">
          <source>Vipul Ved Prakash &amp;lt;mail AT vipul DOT net&amp;gt; - Helping with debugging</source>
          <target state="translated">Vipul Ved Prakash &amp;lt;mail at vipul DOT net&amp;gt;-디버깅 지원</target>
        </trans-unit>
        <trans-unit id="028988d7a45fe46ec8fd41d271d201dc35932db0" translate="yes" xml:space="preserve">
          <source>Visual Perl is a Visual Studio.NET plug-in from ActiveState.</source>
          <target state="translated">Visual Perl은 ActiveState의 Visual Studio.NET 플러그인입니다.</target>
        </trans-unit>
        <trans-unit id="386d827cc4ba6b5f42c38cef2abc770e9c36de72" translate="yes" xml:space="preserve">
          <source>Volumes can be drive letters or UNC sharenames (\\server\share).</source>
          <target state="translated">볼륨은 드라이브 문자 또는 UNC 공유 이름 (\\ server \ share) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2415cb7f63df0c9de23362326ad3c37a9adfc96" translate="yes" xml:space="preserve">
          <source>W</source>
          <target state="translated">W</target>
        </trans-unit>
        <trans-unit id="c26d74df8890b7f659e90425275e4ff437fc0eeb" translate="yes" xml:space="preserve">
          <source>WAIT</source>
          <target state="translated">WAIT</target>
        </trans-unit>
        <trans-unit id="fd3edc641024a335a508fdacefb5f51ded5905cc" translate="yes" xml:space="preserve">
          <source>WARNING</source>
          <target state="translated">WARNING</target>
        </trans-unit>
        <trans-unit id="3c94abff24468ec74283806394c7e1079287562a" translate="yes" xml:space="preserve">
          <source>WARNING: A variable used as a buffer by &lt;code&gt;setbuf&lt;/code&gt; or &lt;code&gt;setvbuf&lt;/code&gt;&lt;b&gt;must not be modified&lt;/b&gt; in any way until the IO::Handle is closed or &lt;code&gt;setbuf&lt;/code&gt; or &lt;code&gt;setvbuf&lt;/code&gt; is called again, or memory corruption may result! Remember that the order of global destruction is undefined, so even if your buffer variable remains in scope until program termination, it may be undefined before the file IO::Handle is closed. Note that you need to import the constants &lt;code&gt;_IOFBF&lt;/code&gt; , &lt;code&gt;_IOLBF&lt;/code&gt; , and &lt;code&gt;_IONBF&lt;/code&gt; explicitly. Like C, setbuf returns nothing. setvbuf returns &quot;0 but true&quot;, on success, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="translated">경고 : &lt;code&gt;setbuf&lt;/code&gt; 또는 &lt;code&gt;setvbuf&lt;/code&gt; 에 의해 버퍼로 사용 된 변수 는 IO :: Handle이 닫히거나 &lt;code&gt;setbuf&lt;/code&gt; 또는 &lt;code&gt;setvbuf&lt;/code&gt; 가 다시 호출 될 때까지 어떤 식 으로든 &lt;b&gt;수정해서는 안됩니다. 그렇지 않으면&lt;/b&gt; 메모리 손상이 발생할 수 있습니다! 전역 삭제 순서는 정의되어 있지 않으므로 버퍼 변수가 프로그램 종료까지 범위 내에 있어도 파일 IO :: Handle이 닫히기 전에 정의되지 않을 수 있습니다. 상수 &lt;code&gt;_IOFBF&lt;/code&gt; , &lt;code&gt;_IOLBF&lt;/code&gt; 및 &lt;code&gt;_IONBF&lt;/code&gt; 를 명시 적으로 가져와야 합니다. C와 마찬가지로 setbuf는 아무것도 반환하지 않습니다. setvbuf는 성공하면 &quot;0이지만 true&quot;를 반환 하고 실패 하면 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="84c2915b48a50feabe204322fda8dc2bbdf52e7d" translate="yes" xml:space="preserve">
          <source>WARNING: As of the 5.004 release, proper usage of the array and hash access functions requires understanding a few caveats. Some of these caveats are actually considered bugs in the API, to be fixed in later releases, and are bracketed with [MAYCHANGE] below. If you find yourself actually applying such information in this section, be aware that the behavior may change in the future, umm, without warning.</source>
          <target state="translated">경고 : 5.004 릴리스부터 배열 및 해시 액세스 기능을 올바르게 사용하려면 몇 가지주의 사항을 이해해야합니다. 이러한 경고 중 일부는 실제로 API의 버그로 간주되며 이후 릴리스에서 수정되며 아래의 [MAYCHANGE]로 묶습니다. 이 섹션에서 실제로 이러한 정보를 적용하는 것을 발견하면 나중에 경고없이 동작이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05aab9ee07d74b03226bac90b4501275a8030a8f" translate="yes" xml:space="preserve">
          <source>WARNING: The IO::Handle::setvbuf() is not available by default on Perls 5.8.0 and later because setvbuf() is rather specific to using the stdio library, while Perl prefers the new perlio subsystem instead.</source>
          <target state="translated">경고 : setvbuf ()는 stdio 라이브러리 사용에 따라 다르고 Perl은 새로운 perlio 하위 시스템을 선호하므로 Perls 5.8.0 이상에서는 IO :: Handle :: setvbuf ()를 기본적으로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="19985e22537400319dbf86c71031d6722bd3ab22" translate="yes" xml:space="preserve">
          <source>WARNING: This variable is strictly for internal use only. Its availability, behavior, and contents are subject to change without notice.</source>
          <target state="translated">경고 :이 변수는 내부 용으로 만 사용됩니다. 가용성, 동작 및 내용은 예고없이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fbfa986b2fb43598295e70fb2ca9f7ae7e83632" translate="yes" xml:space="preserve">
          <source>WARNING: do not use the following unless you *know* &lt;code&gt;off&lt;/code&gt; is within the UTF-8 data pointed to by &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; *and* that on entry &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; is aligned on the first byte of character or just after the last byte of a character.</source>
          <target state="translated">경고 : * know * &lt;code&gt;off&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; * 에 의해 지정된 UTF-8 데이터 내에 있고 * 입력시 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 가 문자의 첫 번째 바이트에 정렬되거나 문자의 마지막 바이트 바로 뒤에 정렬 되지 않는 한 다음을 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="678aa148e87e729dd3e10fce0605ee0538d043a2" translate="yes" xml:space="preserve">
          <source>WARNING: use only if you *know* that the pointers point inside the same UTF-8 buffer.</source>
          <target state="translated">경고 : 포인터가 동일한 UTF-8 버퍼 내부를 가리키는 지 * 알아두면 * 만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="163b0dd1ef8e487db793ddc755bf68fdfda1ccf3" translate="yes" xml:space="preserve">
          <source>WARNINGS</source>
          <target state="translated">WARNINGS</target>
        </trans-unit>
        <trans-unit id="991fe4b3587f5bc3956dbdf64cab7946d865d2e1" translate="yes" xml:space="preserve">
          <source>WARRANTY</source>
          <target state="translated">WARRANTY</target>
        </trans-unit>
        <trans-unit id="899abc782023a16c90d026f7662b081d0e5603bf" translate="yes" xml:space="preserve">
          <source>WELCOME to Plan 9 Perl, brave soul!</source>
          <target state="translated">9 펄, 용감한 영혼을 계획하는 것을 환영합니다!</target>
        </trans-unit>
        <trans-unit id="943f25cc8d7abfb9400129c428f47471a4e77ccc" translate="yes" xml:space="preserve">
          <source>WHAT</source>
          <target state="translated">WHAT</target>
        </trans-unit>
        <trans-unit id="d8c634435f258992c7dbf89bc42a5c10afe89f43" translate="yes" xml:space="preserve">
          <source>WHAT ABOUT &lt;code&gt;DB_File&lt;/code&gt; ?</source>
          <target state="translated">&lt;code&gt;DB_File&lt;/code&gt; 은 무엇 입니까?</target>
        </trans-unit>
        <trans-unit id="a3e4fe4880a26ca7ed67d03d21e6c8855e324c1e" translate="yes" xml:space="preserve">
          <source>WHAT ABOUT DB_File?</source>
          <target state="translated">DB_File은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="69dc14e97abf1c2f032d0ecddf4083e210815600" translate="yes" xml:space="preserve">
          <source>WHAT IS A LOCALE</source>
          <target state="translated">로칼은 무엇인가</target>
        </trans-unit>
        <trans-unit id="8df7eec36d2c3cf583d0c776054ef24d9f2ed0ea" translate="yes" xml:space="preserve">
          <source>WHAT NEXT?</source>
          <target state="translated">다음은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="a31a09e4a44017984cab9426a275543f91816385" translate="yes" xml:space="preserve">
          <source>WHY YOU SHOULD ALWAYS &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt;</source>
          <target state="translated">항상 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용해야하는&lt;/a&gt; 이유</target>
        </trans-unit>
        <trans-unit id="dcf4ad6d76037668ee7377a5088288d629d80a03" translate="yes" xml:space="preserve">
          <source>WHY YOU SHOULD ALWAYS use strict</source>
          <target state="translated">항상 엄격하게 사용해야하는 이유</target>
        </trans-unit>
        <trans-unit id="89237cfda70e873f323e7dd25612ea5b444530a5" translate="yes" xml:space="preserve">
          <source>WIZARDS ONLY</source>
          <target state="translated">마법사 만</target>
        </trans-unit>
        <trans-unit id="612951b55eb7373e18b643aac58cf8c1af06a81c" translate="yes" xml:space="preserve">
          <source>WORKING WITH CPAN.pm BEHIND FIREWALLS</source>
          <target state="translated">방화벽 뒤에서 CPAN.pm을 사용한 작업</target>
        </trans-unit>
        <trans-unit id="999a14026114357b2720836f701f7f83d4e769ea" translate="yes" xml:space="preserve">
          <source>WRAP YOUR OWN</source>
          <target state="translated">자신의 랩</target>
        </trans-unit>
        <trans-unit id="66af5a28971a4c6868ba337400ea0c92dd22295d" translate="yes" xml:space="preserve">
          <source>WRITING A SOURCE FILTER</source>
          <target state="translated">소스 필터 작성</target>
        </trans-unit>
        <trans-unit id="0d91186f3fc1a27893403674a7abb0832febe2cf" translate="yes" xml:space="preserve">
          <source>WRITING A SOURCE FILTER IN C</source>
          <target state="translated">C에서 소스 필터 작성</target>
        </trans-unit>
        <trans-unit id="1cd7808a59ef1fb929041296bd5ead5a0b08527e" translate="yes" xml:space="preserve">
          <source>WRITING A SOURCE FILTER IN PERL</source>
          <target state="translated">PERL로 소스 필터 작성</target>
        </trans-unit>
        <trans-unit id="6f33f4557886e9a55139159f018449074d30de1b" translate="yes" xml:space="preserve">
          <source>WRITING PLUGINS</source>
          <target state="translated">쓰기 플러그인</target>
        </trans-unit>
        <trans-unit id="975f1891ff79af7de3d437f83af46051523ae8be" translate="yes" xml:space="preserve">
          <source>Wait a bit. The PAUSE admins don't want to act too quickly in case the current maintainer is on holiday. If there's no response to private communication or the public post, a PAUSE admin can transfer it to you.</source>
          <target state="translated">조금만 기다려 PAUSE 관리자는 현재 관리자가 휴일 인 경우 너무 빨리 행동하기를 원하지 않습니다. 비공개 커뮤니케이션 또는 공개 게시물에 응답이 없으면 PAUSE 관리자가이를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15314082ca8a524c0f28646da09da9a7b2b19503" translate="yes" xml:space="preserve">
          <source>Wait for a child process to change state. This is identical to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid()&lt;/a&gt;&lt;/code&gt; function, see &lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;.</source>
          <target state="translated">하위 프로세스가 상태를 변경할 때까지 기다리십시오. 이것은 Perl의 내장 &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid()&lt;/a&gt;&lt;/code&gt; 함수와 동일합니다 . &lt;a href=&quot;functions/waitpid&quot;&gt;waitpid를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f6cf131695c42ff802839eee6d284c2ac7d67182" translate="yes" xml:space="preserve">
          <source>Waiting For A Thread To Exit</source>
          <target state="translated">스레드가 종료되기를 기다리는 중</target>
        </trans-unit>
        <trans-unit id="e3ebec26983a17c27a53a6ef7e86c4cba507cfab" translate="yes" xml:space="preserve">
          <source>Waiting for a Condition</source>
          <target state="translated">조건을 기다리는 중</target>
        </trans-unit>
        <trans-unit id="a039b2b9c5bcec1c837f18b2a777a3cf1a5c101d" translate="yes" xml:space="preserve">
          <source>Waits for a particular child process to terminate and returns the pid of the deceased process, or &lt;code&gt;-1&lt;/code&gt; if there is no such child process. On some systems, a value of 0 indicates that there are processes still running. The status is returned in &lt;code&gt;$?&lt;/code&gt; and &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; . If you say</source>
          <target state="translated">특정 자식 프로세스가 종료되기를 기다렸다가 사망 한 프로세스의 pid를 반환하거나 자식 프로세스가없는 경우 &lt;code&gt;-1&lt;/code&gt; 을 반환합니다. 일부 시스템에서 값이 0이면 프로세스가 여전히 실행 중임을 나타냅니다. 상태는 &lt;code&gt;$?&lt;/code&gt; 및 &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; . 당신이 말하는 경우</target>
        </trans-unit>
        <trans-unit id="9d2d2ea3d50db6c0193c946021247ef1ef74c98a" translate="yes" xml:space="preserve">
          <source>Walk Perl syntax tree, printing concise info about ops</source>
          <target state="translated">Perl 구문 트리를 둘러보고 op에 대한 간결한 정보를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="98ac99324db8fed0af8f3ac36eac780a0f3b01c7" translate="yes" xml:space="preserve">
          <source>Walk Perl syntax tree, printing debug info about ops</source>
          <target state="translated">Ops에 대한 디버그 정보를 인쇄하여 Perl 구문 트리를 걷습니다.</target>
        </trans-unit>
        <trans-unit id="7431af4c5a7328a3a156e7686791a7345dc2386a" translate="yes" xml:space="preserve">
          <source>Walk Perl syntax tree, printing terse info about ops</source>
          <target state="translated">Perl 구문 트리를 살펴보고 op에 대한 간결한 정보를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="a864d880f623d2740f245bfcfe987603dc895c7a" translate="yes" xml:space="preserve">
          <source>Walk the symbol table starting at SYMREF and call METHOD on each symbol (a B::GV object) visited. When the walk reaches package symbols (such as &quot;Foo::&quot;) it invokes RECURSE, passing in the symbol name, and only recurses into the package if that sub returns true.</source>
          <target state="translated">SYMREF에서 시작하는 심볼 테이블을 걷고 방문한 각 심볼 (B :: GV 객체)에 대해 METHOD를 호출하십시오. Walk가 패키지 기호 (예 : &quot;Foo ::&quot;)에 도달하면 RECURSE를 호출하고 기호 이름을 전달하고 해당 하위가 true를 반환하는 경우에만 패키지로 재귀합니다.</target>
        </trans-unit>
        <trans-unit id="8c7c87239fc66d9d343f9260489e69fb8f9d3386" translate="yes" xml:space="preserve">
          <source>Walking through a zip file</source>
          <target state="translated">zip 파일을 통해 걷기</target>
        </trans-unit>
        <trans-unit id="4e8d79fb203d74f77c4bb0a86a3b744deaaf0e27" translate="yes" xml:space="preserve">
          <source>Wanting to explore this thoroughly, we want to use the stdio &lt;code&gt;fputs()&lt;/code&gt; on a PerlIO *. This means we have to ask the perlio system for a stdio &lt;code&gt;FILE *&lt;/code&gt; :</source>
          <target state="translated">이것을 철저히 탐구하기 위해 PerlIO *에서 stdio &lt;code&gt;fputs()&lt;/code&gt; 를 사용하고 싶습니다 . 이것은 perlio 시스템에 stdio &lt;code&gt;FILE *&lt;/code&gt; : 을 요청해야한다는 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="00ff4de53d3fe3ffe55031beb5fa9d320e5a35d7" translate="yes" xml:space="preserve">
          <source>Warn on implicit encoding conversions</source>
          <target state="translated">암시 적 인코딩 변환에 대한 경고</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="5e95a54cc5d29c0bcc82593871bdfa68f79221af" translate="yes" xml:space="preserve">
          <source>Warning about Output Arguments</source>
          <target state="translated">출력 인수에 대한 경고</target>
        </trans-unit>
        <trans-unit id="78a452b501be745d32ffe67fa7b1df3549ee0e88" translate="yes" xml:space="preserve">
          <source>Warning and Dieing</source>
          <target state="translated">경고 및 사망</target>
        </trans-unit>
        <trans-unit id="e62cd761838ae197b4220edd9e3bd0f69c6d3c92" translate="yes" xml:space="preserve">
          <source>Warning messages are not collected in this variable. You can, however, set up a routine to process warnings by setting &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; as described in &lt;a href=&quot;#%25SIG&quot;&gt;%SIG&lt;/a&gt;.</source>
          <target state="translated">이 변수에는 경고 메시지가 수집되지 않습니다. 그러나 &lt;a href=&quot;#%25SIG&quot;&gt;% SIG에&lt;/a&gt; 설명 된대로 &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; 을 설정하여 경고를 처리하는 루틴을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e6fb45b9b8c6b7b341ac8191e822e0bd743414ee" translate="yes" xml:space="preserve">
          <source>Warning on \1 Instead of $1</source>
          <target state="translated">$ 1 대신 \ 1에 대한 경고</target>
        </trans-unit>
        <trans-unit id="151e71b95baa6e558c89aa6c4dcb9635e2009b86" translate="yes" xml:space="preserve">
          <source>Warning! The accuracy</source>
          <target state="translated">경고! 정확성</target>
        </trans-unit>
        <trans-unit id="dab0c499dcd06e930b9b78c9e213ee3924e2052e" translate="yes" xml:space="preserve">
          <source>Warning: If &lt;code&gt;SvCUR&lt;/code&gt; is equal to &lt;code&gt;SvLEN&lt;/code&gt; , then &lt;code&gt;SvEND&lt;/code&gt; points to unallocated memory.</source>
          <target state="translated">경고 : 경우 &lt;code&gt;SvCUR&lt;/code&gt; 이 동일 &lt;code&gt;SvLEN&lt;/code&gt; , 다음 &lt;code&gt;SvEND&lt;/code&gt; 할당되지 않은 메모리를 가리키는.</target>
        </trans-unit>
        <trans-unit id="897e60f42bffb44a74b7eeefd8312eec6b6adc82" translate="yes" xml:space="preserve">
          <source>Warning: What follows is an experimental feature.</source>
          <target state="translated">경고 : 다음은 실험적인 기능입니다.</target>
        </trans-unit>
        <trans-unit id="0f8de18035aca70c8dfa181a9a2f5d6af3e09a08" translate="yes" xml:space="preserve">
          <source>Warning: syntactical care is required when sorting the list returned from a function. If you want to sort the list returned by the function call &lt;code&gt;find_records(@key)&lt;/code&gt; , you can use:</source>
          <target state="translated">경고 : 함수에서 반환 된 목록을 정렬 할 때는 구문 관리가 필요합니다. 함수 호출 &lt;code&gt;find_records(@key)&lt;/code&gt; 에서 리턴 한 목록을 정렬하려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5108285f53caf36c4da1bf90b62aacb88666b29e" translate="yes" xml:space="preserve">
          <source>Warning: the inst_perl: target will most probably overwrite your existing perl binary. Use with care!</source>
          <target state="translated">경고 : inst_perl : 대상은 대부분 기존 perl 바이너리를 덮어 씁니다. 조심해서 사용하십시오!</target>
        </trans-unit>
        <trans-unit id="1430f976c596795274458abcfbc4f280cbfcebac" translate="yes" xml:space="preserve">
          <source>Warnings</source>
          <target state="translated">Warnings</target>
        </trans-unit>
        <trans-unit id="cd781cfd6561f1847315b32c68e5aa6443ed0ce1" translate="yes" xml:space="preserve">
          <source>Warnings about floating-point overflow when compiling Perl on Tru64</source>
          <target state="translated">Tru64에서 Perl을 컴파일 할 때 부동 소수점 오버플로에 대한 경고</target>
        </trans-unit>
        <trans-unit id="f781ae9f2ff2acd0ab91c312289ece490360983a" translate="yes" xml:space="preserve">
          <source>Warnings are issued and the file skipped if &lt;code&gt;AutoSplit&lt;/code&gt; cannot locate either the</source>
          <target state="translated">&lt;code&gt;AutoSplit&lt;/code&gt; 이 다음 중 하나를 찾을 수 없으면 경고가 표시되고 파일을 건너 뜁니다 .</target>
        </trans-unit>
        <trans-unit id="931a49d01050aa1b2755e3ac6bcc484cb7da972d" translate="yes" xml:space="preserve">
          <source>Warnings dispatched from perl itself (or more accurately, those that match descriptions found in &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt;) are only displayed once (no duplicate descriptions). User code generated warnings a la warn() are unaffected, allowing duplicate user messages to be displayed.</source>
          <target state="translated">perl 자체 (또는보다 정확하게는 &lt;a href=&quot;perldiag&quot;&gt;perldiag의&lt;/a&gt; 설명과 일치하는 경고)에서 전달 된 경고는 한 번만 표시됩니다 (중복 설명 없음). 사용자 코드 생성 경고 la warn ()은 영향을받지 않으므로 중복 된 사용자 메시지가 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5a6430c53bc65107aa5413603aa9d5ae883fbaa" translate="yes" xml:space="preserve">
          <source>Warnings import function</source>
          <target state="translated">경고 가져 오기 기능</target>
        </trans-unit>
        <trans-unit id="c2ae6895b901f6f499e198f2b33c31bd733ed306" translate="yes" xml:space="preserve">
          <source>Warnings of other C compilers</source>
          <target state="translated">다른 C 컴파일러의 경고</target>
        </trans-unit>
        <trans-unit id="3e543092d93dedef30b6a118c959f36cd73b7b20" translate="yes" xml:space="preserve">
          <source>Warns with &lt;code&gt;@message&lt;/code&gt; but the message will appear to come from the point where the original test function was called (&lt;code&gt;$tb-&amp;gt;caller&lt;/code&gt; ).</source>
          <target state="translated">&lt;code&gt;@message&lt;/code&gt; 로 경고 하지만 원래 테스트 함수가 호출 된 시점 ( &lt;code&gt;$tb-&amp;gt;caller&lt;/code&gt; ) 에서 메시지가 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="d321acbea9d4ab268b54e61d4d0b39001cfb34d4" translate="yes" xml:space="preserve">
          <source>Wayne Thompson</source>
          <target state="translated">웨인 톰슨</target>
        </trans-unit>
        <trans-unit id="43464fb1e06d4c1bc9db7081e9ca038cc1269495" translate="yes" xml:space="preserve">
          <source>We &quot;officially&quot; support the two most recent stable release series. 5.16.x and earlier are now out of support. As of the release of 5.22.0, we will &quot;officially&quot; end support for Perl 5.18.x, other than providing security updates as described below.</source>
          <target state="translated">우리는 가장 최근의 두 가지 안정적인 릴리스 시리즈를 &quot;공식적으로&quot;지원합니다. 5.16.x 및 이전 버전은 현재 지원되지 않습니다. 5.22.0 릴리스부터는 아래에 설명 된대로 보안 업데이트를 제공하는 것 외에 Perl 5.18.x에 대한 &quot;공식적으로&quot;지원을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="17a0049b3e8190b56f011a925a65f0578bf35206" translate="yes" xml:space="preserve">
          <source>We already talked about the special &lt;code&gt;@ISA&lt;/code&gt; array and the &lt;a href=&quot;parent&quot;&gt;parent&lt;/a&gt; pragma.</source>
          <target state="translated">우리는 이미 특별한 &lt;code&gt;@ISA&lt;/code&gt; 배열과 &lt;a href=&quot;parent&quot;&gt;부모&lt;/a&gt; pragma에 대해 이야기했습니다 .</target>
        </trans-unit>
        <trans-unit id="99f6d15ea0dac8c570f259e877f08f9c6317a1cf" translate="yes" xml:space="preserve">
          <source>We also recommend using this method to check whether a module has a sufficient version. The internal implementation uses the &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; module to make sure that different types of version numbers are compared correctly.</source>
          <target state="translated">또한이 방법을 사용하여 모듈의 버전이 충분한 지 확인하는 것이 좋습니다. 내부 구현은 &lt;a href=&quot;version&quot;&gt;버전&lt;/a&gt; 모듈을 사용하여 여러 유형의 버전 번호가 올바르게 비교되도록합니다.</target>
        </trans-unit>
        <trans-unit id="777641065ef9fefa679b6e058d833646233119c1" translate="yes" xml:space="preserve">
          <source>We are at the end of the regexp, so we are done! We have matched 'abcd' out of the string &quot;abcde&quot;.</source>
          <target state="translated">우리는 정규 표현식이 끝났으므로 끝났습니다! 문자열 &quot;abcde&quot;에서 'abcd'를 일치 시켰습니다.</target>
        </trans-unit>
        <trans-unit id="88e6eb598d1ae4c98a1710166c586176804c4ac7" translate="yes" xml:space="preserve">
          <source>We are done!</source>
          <target state="translated">끝났습니다!</target>
        </trans-unit>
        <trans-unit id="b8c42eb02770fa660f067266841b9afabfa1a1c9" translate="yes" xml:space="preserve">
          <source>We are performing only one hash operation in this function, which is storing a new scalar under a key using &lt;code&gt;hv_store&lt;/code&gt; . A hash is represented by an HV* pointer. Like arrays, the functions for manipulating hashes from an XSUB mirror the functionality available from Perl. See &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; and &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for details.</source>
          <target state="translated">이 함수에서는 &lt;code&gt;hv_store&lt;/code&gt; 를 사용하여 키 아래에 새 스칼라를 저장하는 해시 작업을 하나만 수행합니다 . 해시는 HV * 포인터로 표시됩니다. 배열과 마찬가지로 XSUB에서 해시를 조작하는 기능은 Perl에서 사용할 수있는 기능을 미러링합니다. 자세한 내용은 &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; 및 &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fd90ced3661ebd845235cda2b54db721e3957aec" translate="yes" xml:space="preserve">
          <source>We aren't interested in anything returned from</source>
          <target state="translated">우리는 반환 된 것에 관심이 없습니다.</target>
        </trans-unit>
        <trans-unit id="b554448ff034d8f0532aebe7287733b598ce6629" translate="yes" xml:space="preserve">
          <source>We aren't passing any parameters to</source>
          <target state="translated">우리는 매개 변수를 전달하지 않습니다</target>
        </trans-unit>
        <trans-unit id="4e3a929680591b90a57e354fe70746318049b8f9" translate="yes" xml:space="preserve">
          <source>We build perl using GNU make. We tried the native make once and it worked too.</source>
          <target state="translated">GNU make를 사용하여 perl을 빌드합니다. 우리는 네이티브 메이크를 한 번 시도해 보았습니다.</target>
        </trans-unit>
        <trans-unit id="41071245738df49d45438a45bb484058bfc57858" translate="yes" xml:space="preserve">
          <source>We can also dump out this op: the current op is always stored in &lt;code&gt;PL_op&lt;/code&gt; , and we can dump it with &lt;code&gt;Perl_op_dump&lt;/code&gt; . This'll give us similar output to &lt;a href=&quot;b/debug&quot;&gt;B::Debug&lt;/a&gt;.</source>
          <target state="translated">현재 영업 이익은 항상에 저장됩니다 우리는 또한이 조작을 덤프 할 수 &lt;code&gt;PL_op&lt;/code&gt; , 우리는 그것을 덤프 할 수 &lt;code&gt;Perl_op_dump&lt;/code&gt; . 이것은 우리에게 &lt;a href=&quot;b/debug&quot;&gt;B :: Debug&lt;/a&gt; 와 비슷한 결과를 줄 것 입니다.</target>
        </trans-unit>
        <trans-unit id="961c3c25dd241cffc69783f122b1016732a7e65b" translate="yes" xml:space="preserve">
          <source>We can also use &lt;code&gt;@&lt;/code&gt; to jump to an offset, with 0 being the position where we were when the last &lt;code&gt;(&lt;/code&gt; was encountered:</source>
          <target state="translated">우리는 또한 사용할 수 있습니다 &lt;code&gt;@&lt;/code&gt; 0은 마지막 때 우리가 있었던 위치 인 상태, 오프셋 (offset)로 이동 &lt;code&gt;(&lt;/code&gt; 발생했습니다 :</target>
        </trans-unit>
        <trans-unit id="dbea0db461430bae70d9c35bb3e6a3ab77cd3179" translate="yes" xml:space="preserve">
          <source>We can also use a variable to store a reference to the data structure that is being blessed as our object:</source>
          <target state="translated">또한 변수를 사용하여 객체로 축복받는 데이터 구조에 대한 참조를 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ae43a4ae8c47d1af2dad91e0ab8b4c97424cc6a" translate="yes" xml:space="preserve">
          <source>We can also use the transliteration operator, &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;. In this example, the search list side of our &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; contains nothing, but the &lt;code&gt;c&lt;/code&gt; option complements that so it contains everything. The replacement list also contains nothing, so the transliteration is almost a no-op since it won't do any replacements (or more exactly, replace the character with itself). However, the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; option squashes duplicated and consecutive characters in the string so a character does not show up next to itself</source>
          <target state="translated">음역 연산자 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 사용할 수도 있습니다 . 이 예에서 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 의 검색 목록 에는 아무것도 포함되어 있지 않지만 &lt;code&gt;c&lt;/code&gt; 옵션은이를 보완하여 모든 것을 포함합니다. 대체 목록에는 아무 것도 포함되어 있지 않으므로 음역은 대체 작업을 수행하지 않기 때문에 거의 작동하지 않습니다. 그러나 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 옵션은 문자열에서 복제되고 연속 된 문자를 스쿼시하므로 문자가 옆에 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8d9637ace5e985325b750e53a0a2e0777af26ff5" translate="yes" xml:space="preserve">
          <source>We can deal with this by using both an assertion and a negation. We'll say that the first part in $1 must be followed both by a digit and by something that's not &quot;123&quot;. Remember that the look-aheads are zero-width expressions--they only look, but don't consume any of the string in their match. So rewriting this way produces what you'd expect; that is, case 5 will fail, but case 6 succeeds:</source>
          <target state="translated">우리는 주장과 부정을 모두 사용하여 이것을 다룰 수 있습니다. 우리는 $ 1의 첫 부분 다음에 숫자와 &quot;123&quot;이 아닌 것을 따라야한다고 말할 것입니다. 미리보기는 너비가 0 인 표현입니다. 단지보기 만하고 일치하는 문자열을 사용하지는 않습니다. 따라서이 방식으로 다시 작성하면 예상 한 결과를 얻을 수 있습니다. 즉, 사례 5는 실패하지만 사례 6은 성공합니다.</target>
        </trans-unit>
        <trans-unit id="69e73838de4aed15f5d24b688fd13aef192fb3f9" translate="yes" xml:space="preserve">
          <source>We can extend the example above:</source>
          <target state="translated">위의 예를 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84c843f2491ce2ba91f8ea33bd419c025bcac31f" translate="yes" xml:space="preserve">
          <source>We can manipulate &lt;code&gt;@_&lt;/code&gt; in other ways too:</source>
          <target state="translated">우리는 다른 방법으로 &lt;code&gt;@_&lt;/code&gt; 도 조작 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="c8e881a1155e87edea33bdbd7aaa36ea47df11e3" translate="yes" xml:space="preserve">
          <source>We can match different character strings with the &lt;b&gt;alternation&lt;/b&gt; metacharacter &lt;code&gt;'|'&lt;/code&gt; . To match &lt;code&gt;dog&lt;/code&gt; or &lt;code&gt;cat&lt;/code&gt; , we form the regex &lt;code&gt;dog|cat&lt;/code&gt; . As before, Perl will try to match the regex at the earliest possible point in the string. At each character position, Perl will first try to match the first alternative, &lt;code&gt;dog&lt;/code&gt; . If &lt;code&gt;dog&lt;/code&gt; doesn't match, Perl will then try the next alternative, &lt;code&gt;cat&lt;/code&gt; . If &lt;code&gt;cat&lt;/code&gt; doesn't match either, then the match fails and Perl moves to the next position in the string. Some examples:</source>
          <target state="translated">다른 문자 스트링을 &lt;b&gt;대체&lt;/b&gt; 메타 문자 &lt;code&gt;'|'&lt;/code&gt; 와 일치시킬 수 있습니다 . 일치시키기 &lt;code&gt;dog&lt;/code&gt; 또는 &lt;code&gt;cat&lt;/code&gt; , 우리는 정규식 형성 &lt;code&gt;dog|cat&lt;/code&gt; . 이전과 마찬가지로 Perl은 문자열에서 가능한 한 빨리 정규식을 일치 시키려고 시도합니다. 각 캐릭터 위치에서 Perl은 먼저 첫 번째 대안 인 &lt;code&gt;dog&lt;/code&gt; 를 일치 시키려고 시도합니다 . 경우 &lt;code&gt;dog&lt;/code&gt; 일치하지 않는, 펄는 다음 대안을 다할 것입니다 &lt;code&gt;cat&lt;/code&gt; . 경우 &lt;code&gt;cat&lt;/code&gt; 중 하나와 일치하지 않는, 다음 경기는 실패하고 펄은 문자열의 다음 위치로 이동합니다. 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="ea854225fefa1280a29795bb4f271d273dbd77b0" translate="yes" xml:space="preserve">
          <source>We can modify principle 3 above to take into account non-greedy quantifiers:</source>
          <target state="translated">욕심없는 정량자를 고려하여 위의 원칙 3을 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab79fcd6910e13f271bf0f10b6fac2de440cb105" translate="yes" xml:space="preserve">
          <source>We can now use &lt;code&gt;Perl_sv_dump&lt;/code&gt; to investigate the SV:</source>
          <target state="translated">이제 &lt;code&gt;Perl_sv_dump&lt;/code&gt; 를 사용 하여 SV를 조사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9e3ffbb12768a148e4cd9144c59ebb38f57598ff" translate="yes" xml:space="preserve">
          <source>We can override a parent's method in a child class. When we do so, we can still call the parent class's method with the &lt;code&gt;SUPER&lt;/code&gt; pseudo-class.</source>
          <target state="translated">자식 클래스에서 부모의 메서드를 재정의 할 수 있습니다. 그렇게해도 &lt;code&gt;SUPER&lt;/code&gt; 의사 클래스를 사용하여 부모 클래스의 메서드를 계속 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2754e3aa57380296cb4f092e33ffe2f92fac593d" translate="yes" xml:space="preserve">
          <source>We can put another break point on any line beginning with a colon, we'll use line 17 as that's just as we come out of the subroutine, and we'd like to pause there later on:</source>
          <target state="translated">콜론으로 시작하는 모든 줄에 또 다른 중단 점을 둘 수 있습니다. 우리는 서브 루틴에서 나오는 것처럼 17 번 줄을 사용하고 나중에 멈추고 싶습니다 :</target>
        </trans-unit>
        <trans-unit id="8aece3bd543cbe6fe75eaf5ad6965a489841cbb4" translate="yes" xml:space="preserve">
          <source>We can put that into a test file which we can run to check which approach is the fastest, using a global &lt;code&gt;$STR&lt;/code&gt; variable to assign to the &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $str&lt;/code&gt; variable so as to avoid perl trying to optimize any of the work away by noticing it's assigned only the once.</source>
          <target state="translated">전역 파일 &lt;code&gt;$STR&lt;/code&gt; 변수를 사용 하여 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $str&lt;/code&gt; 변수 에 할당하여 펄이 작업을 최적화하여 작업을 최적화하려고 시도하는 것을 피할 수 있도록 테스트 파일에 넣을 수 있습니다. 한 번만 할당되었습니다.</target>
        </trans-unit>
        <trans-unit id="192c194669c26df922a17b7997201101414dafec" translate="yes" xml:space="preserve">
          <source>We can reduce some of the looping through slices</source>
          <target state="translated">슬라이스를 통한 루핑의 일부를 줄일 수 있습니다</target>
        </trans-unit>
        <trans-unit id="393d2cf123dc0cecdbadd1ca8c26943dc464db54" translate="yes" xml:space="preserve">
          <source>We could get more fancy in the &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; block though. Instead of comparing the keys, we can compute a value with them and use that value as the comparison.</source>
          <target state="translated">그래도 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; 블록 에서 더 화려해질 수 있습니다 . 키를 비교하는 대신 키로 값을 계산하고 해당 값을 비교로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="373abf531902aa68eac45baf244872a1e2626f66" translate="yes" xml:space="preserve">
          <source>We could have both classes inherit from a common parent, like &lt;code&gt;Machine&lt;/code&gt; , but not all machines have on/off switches. We could create a parent class called &lt;code&gt;HasOnOffSwitch&lt;/code&gt; , but that is very artificial. Radios and computers are not specializations of this parent. This parent is really a rather ridiculous creation.</source>
          <target state="translated">두 클래스 모두 &lt;code&gt;Machine&lt;/code&gt; 과 같은 공통 부모로부터 상속받을 수 있지만 모든 머신에 켜기 / 끄기 스위치가있는 것은 아닙니다. &lt;code&gt;HasOnOffSwitch&lt;/code&gt; 라는 부모 클래스를 만들 수 는 있지만 매우 인위적입니다. 라디오와 컴퓨터는이 부모의 전문 분야가 아닙니다. 이 부모는 정말 우스운 창조물입니다.</target>
        </trans-unit>
        <trans-unit id="23ce6432aa57322234fa603b7b093664929a40c6" translate="yes" xml:space="preserve">
          <source>We could have used an unpack template &lt;code&gt;'b12'&lt;/code&gt; just as well, since the last 4 bits can be ignored anyway.</source>
          <target state="translated">압축 해제 템플릿 &lt;code&gt;'b12'&lt;/code&gt; 도 사용할 수있었습니다 . 마지막 4 비트는 무시해도됩니다.</target>
        </trans-unit>
        <trans-unit id="737f5642c49143f79a5e632705526d6d3453018c" translate="yes" xml:space="preserve">
          <source>We do this by using the PPCODE: directive, rather than the CODE: directive. This tells &lt;b&gt;xsubpp&lt;/b&gt; that we will be managing the return values that will be put on the argument stack by ourselves.</source>
          <target state="translated">CODE : 지시문이 아닌 PPCODE : 지시문을 사용하여이를 수행합니다. 이것은 &lt;b&gt;xsubpp&lt;/b&gt; 에게 우리가 인수 스택에 넣을 리턴 값을 관리 할 것이라고 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="bbf4d60422d93cc3418f9928672ab7a165e0c448" translate="yes" xml:space="preserve">
          <source>We don't have much experience with this yet, but try the following:</source>
          <target state="translated">아직 경험이 많지 않지만 다음을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="3714a8cbbcb3d8e34c4cf78e7eb46446670ccdf4" translate="yes" xml:space="preserve">
          <source>We don't have to hard-code patterns into the match operator (or anything else that works with regular expressions). We can put the pattern in a variable for later use.</source>
          <target state="translated">패턴을 매치 연산자 (또는 정규 표현식에서 작동하는 다른 것)로 하드 코딩 할 필요가 없습니다. 나중에 사용하기 위해 패턴을 변수에 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b9b047b90e6f20cc1587612f1c7f873786eee50" translate="yes" xml:space="preserve">
          <source>We encourage using this rather than calling print directly.</source>
          <target state="translated">인쇄를 직접 호출하는 대신 이것을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7ef0cc263f45630948ec977db18c296d89495351" translate="yes" xml:space="preserve">
          <source>We encourage vendors to ship the most recent supported release of Perl at the time of their code freeze.</source>
          <target state="translated">코드 동결시 공급 업체가 가장 최근에 지원되는 Perl 릴리스를 제공하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="dd33c6dcc68f66e550d47a04957cd34a37a4f9d0" translate="yes" xml:space="preserve">
          <source>We encourage you to play with and evaluate &lt;a href=&quot;http://search.cpan.org/perldoc/Moose&quot;&gt;Moose&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Accessor&quot;&gt;Class::Accessor&lt;/a&gt;, and &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Tiny&quot;&gt;Class::Tiny&lt;/a&gt; to see which OO system is right for you.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Moose&quot;&gt;Moose&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Accessor&quot;&gt;Class :: Accessor&lt;/a&gt; 및 &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Tiny&quot;&gt;Class :: Tiny&lt;/a&gt; 를 가지고 평가하여 자신에게 적합한 OO 시스템을 확인하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a75ee8e59a59e98ee82483d5a167a8e74430cf9d" translate="yes" xml:space="preserve">
          <source>We fix our quoting: 'tom' =&amp;gt; q(and jerry), and run it again, this time we get our expected output:</source>
          <target state="translated">우리는 따옴표 'tom'=&amp;gt; ​​q (and jerry)를 수정하고 다시 실행합니다. 이번에는 예상 출력을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="ad7822a7bc01015524040b6228bd7a714fe0ea5e" translate="yes" xml:space="preserve">
          <source>We have already introduced the matching operator in its default &lt;code&gt;/regexp/&lt;/code&gt; and arbitrary delimiter &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m!regexp!&lt;/a&gt;&lt;/code&gt; forms. We have used the binding operator &lt;code&gt;=~&lt;/code&gt; and its negation &lt;code&gt;!~&lt;/code&gt; to test for string matches. Associated with the matching operator, we have discussed the single line &lt;code&gt;//s&lt;/code&gt; , multi-line &lt;code&gt;//m&lt;/code&gt; , case-insensitive &lt;code&gt;//i&lt;/code&gt; and extended &lt;code&gt;//x&lt;/code&gt; modifiers. There are a few more things you might want to know about matching operators.</source>
          <target state="translated">우리는 이미 기본 &lt;code&gt;/regexp/&lt;/code&gt; 및 임의의 분리 문자 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m!regexp!&lt;/a&gt;&lt;/code&gt; 형태. 바인딩 연산자 &lt;code&gt;=~&lt;/code&gt; 와 부정 &lt;code&gt;!~&lt;/code&gt; 을 사용하여 문자열 일치를 테스트했습니다. 매칭 연산자와 관련하여 우리는 단일 라인 &lt;code&gt;//s&lt;/code&gt; , 다중 라인 &lt;code&gt;//m&lt;/code&gt; , 대소 문자를 구분하지 않는 &lt;code&gt;//i&lt;/code&gt; 및 확장 된 &lt;code&gt;//x&lt;/code&gt; 수정 자에 대해 논의했습니다 . 일치 연산자에 대해 알아야 할 사항이 몇 가지 더 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e2bfdcf3348ad31286e830869ab5ab9cf57a976" translate="yes" xml:space="preserve">
          <source>We have no nroff on BS2000 POSIX (yet), so we ignored any errors while installing the documentation.</source>
          <target state="translated">BS2000 POSIX (아직)에 대해서는 nroff가 없으므로 설명서를 설치하는 동안 오류를 무시했습니다.</target>
        </trans-unit>
        <trans-unit id="c5a4c49687cb5b4e725178b1ad770374684a7f19" translate="yes" xml:space="preserve">
          <source>We have to use a &lt;code&gt;CODE&lt;/code&gt; section because &lt;code&gt;PerlIO_puts()&lt;/code&gt; has the arguments reversed compared to &lt;code&gt;fputs()&lt;/code&gt; , and we want to keep the arguments the same.</source>
          <target state="translated">&lt;code&gt;PerlIO_puts()&lt;/code&gt; 는 &lt;code&gt;fputs()&lt;/code&gt; 와 반대로 인수가 있고 인수를 동일하게 유지하기 위해 &lt;code&gt;CODE&lt;/code&gt; 섹션 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4a78632eb571a6503bee4006e791fffefd6cf4ab" translate="yes" xml:space="preserve">
          <source>We have tried to make Perl aware of both VMS-style and Unix-style file specifications wherever possible. You may use either style, or both, on the command line and in scripts, but you may not combine the two styles within a single file specification. VMS Perl interprets Unix pathnames in much the same way as the CRTL (</source>
          <target state="translated">우리는 가능한 한 VMS 스타일과 Unix 스타일 파일 사양을 모두 Perl에 알리려고 노력했습니다. 명령 행과 스크립트에서 스타일을 사용하거나 둘 다 사용할 수 있지만 단일 파일 스펙 내에서 두 스타일을 결합 할 수는 없습니다. VMS Perl은 CRTL과 거의 같은 방식으로 Unix 경로 이름을 해석합니다 (</target>
        </trans-unit>
        <trans-unit id="78dd390dcc77c45fe1854b3e48358f0f7f0c1ae7" translate="yes" xml:space="preserve">
          <source>We highly discourage this method. It should only be used if you know what you're doing and specifically need the PREFIX behavior. The PREFIX algorithm is complicated and focused on matching the system installation.</source>
          <target state="translated">이 방법은 사용하지 않는 것이 좋습니다. 수행중인 작업을 알고 특히 PREFIX 동작이 필요한 경우에만 사용해야합니다. PREFIX 알고리즘은 복잡하며 시스템 설치 일치에 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="0d078f205cc7733f26f4527b8b9a508a7c925969" translate="yes" xml:space="preserve">
          <source>We highly recommend the install_base method, its the simplest and most closely approximates the expected behavior of an installation prefix.</source>
          <target state="translated">가장 간단하고 설치 접두사의 예상 동작과 가장 가까운 install_base 메소드를 적극 권장합니다.</target>
        </trans-unit>
        <trans-unit id="cf829d6773d2acaf89ace4612301d748f71133de" translate="yes" xml:space="preserve">
          <source>We hope these notes will save you from confusion and lost sleep when writing Perl scripts on VMS. If you find we've missed something you think should appear here, please don't hesitate to drop a line to vmsperl@perl.org.</source>
          <target state="translated">이 노트가 VMS에서 Perl 스크립트를 작성할 때 혼란과 수면 상실로부터 벗어날 수 있기를 바랍니다. 여기에 표시되어야 할 내용이 누락 된 경우 언제든지 vmsperl@perl.org로 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="c62eabab19d963ec1dc9f96b723cb4b48b7d1ebd" translate="yes" xml:space="preserve">
          <source>We implement our own glob-style pattern matching for --rules. Here are the supported patterns:</source>
          <target state="translated">--rules에 대한 자체 glob 스타일 패턴 일치를 구현합니다. 지원되는 패턴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f3c2a6f9803dfeb38af1055d966366fc67acbab0" translate="yes" xml:space="preserve">
          <source>We implement our own glob-style pattern matching. Here are the patterns it supports:</source>
          <target state="translated">우리는 우리 자신의 glob-style 패턴 매칭을 구현합니다. 지원하는 패턴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="821afd715774631771e27078ffd6e046b44c39d8" translate="yes" xml:space="preserve">
          <source>We know we're going to get &lt;code&gt;6&lt;/code&gt; from this, so let's finish the subroutine:</source>
          <target state="translated">우리는 이것으로부터 &lt;code&gt;6&lt;/code&gt; 을 얻을 것이라는 것을 알고 있으므로 서브 루틴을 끝내 봅시다 :</target>
        </trans-unit>
        <trans-unit id="56ac7541ed28a7466aa3352e9da342249eeae09f" translate="yes" xml:space="preserve">
          <source>We looked at this bit of code before, and we said that &lt;code&gt;dPOPTOPnnrl_ul&lt;/code&gt; arranges for two &lt;code&gt;NV&lt;/code&gt; s to be placed into &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; - let's slightly expand it:</source>
          <target state="translated">우리는 이전에이 코드를 살펴 보았고, &lt;code&gt;dPOPTOPnnrl_ul&lt;/code&gt; 은 두 개의 &lt;code&gt;NV&lt;/code&gt; 를 &lt;code&gt;left&lt;/code&gt; 과 &lt;code&gt;right&lt;/code&gt; 배치 할 것이라고 준비 했습니다.</target>
        </trans-unit>
        <trans-unit id="bf8f7ecbf0eb0e715d021c51919b36afbf4f3b1d" translate="yes" xml:space="preserve">
          <source>We maintain the binary incompatibility.</source>
          <target state="translated">바이너리 비 호환성을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="0fd132a408c3e7900b7667b28ffdaffdc2cfda3e" translate="yes" xml:space="preserve">
          <source>We manipulate several arrays in this XSUB. Note that an array is represented internally by an AV* pointer. The functions and macros for manipulating arrays are similar to the functions in Perl: &lt;code&gt;av_top_index&lt;/code&gt; returns the highest index in an AV*, much like $#array; &lt;code&gt;av_fetch&lt;/code&gt; fetches a single scalar value from an array, given its index; &lt;code&gt;av_push&lt;/code&gt; pushes a scalar value onto the end of the array, automatically extending the array as necessary.</source>
          <target state="translated">이 XSUB에서 여러 배열을 조작합니다. 배열은 AV * 포인터로 내부적으로 표시됩니다. 배열 조작을위한 함수와 매크로는 Perl의 함수와 비슷합니다. &lt;code&gt;av_top_index&lt;/code&gt; 는 $ # array와 같이 AV *에서 가장 높은 인덱스를 반환합니다. &lt;code&gt;av_fetch&lt;/code&gt; 는 인덱스에서 주어진 스칼라 값을 배열에서 가져옵니다. &lt;code&gt;av_push&lt;/code&gt; 는 스칼라 값을 배열의 끝에 푸시하여 필요에 따라 배열을 자동으로 확장합니다.</target>
        </trans-unit>
        <trans-unit id="6201b3e74828151a0b8123986740745576c51a04" translate="yes" xml:space="preserve">
          <source>We may change it so that things that remain legal uses in normal bracketed character classes might become illegal within this experimental construct. One proposal, for example, is to forbid adjacent uses of the same character, as in &lt;code&gt;(?[ [aa] ])&lt;/code&gt; . The motivation for such a change is that this usage is likely a typo, as the second &quot;a&quot; adds nothing.</source>
          <target state="translated">일반적인 대괄호로 된 클래스에서 합법적으로 사용되는 것이이 실험 구조 내에서 불법이 될 수 있도록 변경할 수 있습니다. 예를 들어, 하나의 제안은 &lt;code&gt;(?[ [aa] ])&lt;/code&gt; 에서와 같이 동일한 문자의 인접 사용을 금지하는 것입니다 . 이러한 변경의 동기는 두 번째 &quot;a&quot;가 아무 것도 추가하지 않으므로이 사용법이 오타 일 가능성이 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9d8db65a7f163486a998a7bf47269c4123bd2dc9" translate="yes" xml:space="preserve">
          <source>We mentioned earlier that most Perl objects are implemented as hashes under the hood. The principle of encapsulation tells us that we should not rely on this. Instead, we should use accessor methods to access the data in that hash. The object systems that we recommend below all automate the generation of accessor methods. If you use one of them, you should never have to access the object as a hash directly.</source>
          <target state="translated">앞에서 언급 한 대부분의 Perl 객체는 후드 아래에서 해시로 구현됩니다. 캡슐화의 원리는 우리가 이것에 의존해서는 안된다는 것을 알려줍니다. 대신 접근 자 메서드를 사용하여 해당 해시의 데이터에 액세스해야합니다. 아래에서 권장하는 객체 시스템은 모두 접근 자 메서드 생성을 자동화합니다. 그중 하나를 사용하면 해시로 객체에 직접 액세스 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="fd2e3b2237cf2c9ebd6d21ee18dff2f93d4edaee" translate="yes" xml:space="preserve">
          <source>We mentioned multiple inheritance earlier. The main problem with multiple inheritance is that it greatly complicates method resolution. See &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; for more details.</source>
          <target state="translated">앞서 여러 상속을 언급했습니다. 다중 상속의 주요 문제점은 메소드 분석이 크게 복잡하다는 것입니다. 자세한 내용은 &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="05de83678232988de23cc08caee2a559bec4d96c" translate="yes" xml:space="preserve">
          <source>We must know how much to read.</source>
          <target state="translated">읽어야 할 금액을 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="786b499d8e7780442a91c12acac79f0bab40bb9c" translate="yes" xml:space="preserve">
          <source>We now compile up Perl, and run it through the test suite. Our new tests pass, hooray!</source>
          <target state="translated">이제 Perl을 컴파일하고 테스트 스위트를 통해 실행합니다. 우리의 새로운 테스트는 통과합니다!</target>
        </trans-unit>
        <trans-unit id="885cb8f93d773c304687f5c7d8f7995e03fd1f70" translate="yes" xml:space="preserve">
          <source>We now know how to create choices among classes of characters in a regexp. What about choices among words or character strings? Such choices are described in the next section.</source>
          <target state="translated">이제 정규 표현식에서 문자 클래스 중에서 선택하는 방법을 알았습니다. 단어 나 문자열 중에서 선택하는 것은 어떻습니까? 이러한 선택은 다음 섹션에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="68e3b46c3317fe81b8a4f43f4375d9dc3eef2342" translate="yes" xml:space="preserve">
          <source>We often refer to inheritance relationships as &lt;b&gt;parent-child&lt;/b&gt; or &lt;code&gt;superclass/subclass&lt;/code&gt; relationships. Sometimes we say that the child has an &lt;b&gt;is-a&lt;/b&gt; relationship with its parent class.</source>
          <target state="translated">우리는 종종 상속 관계를 &lt;b&gt;부모-자식&lt;/b&gt; 또는 &lt;code&gt;superclass/subclass&lt;/code&gt; 관계라고합니다. 때때로 우리는 아이가가 가지고있는 말 &lt;b&gt;입니다-A&lt;/b&gt; 부모 클래스와의 관계.</target>
        </trans-unit>
        <trans-unit id="37fd14d3b6f6bb386e0f6cc77e29f8b6538c7a73" translate="yes" xml:space="preserve">
          <source>We recognize that the Perl core, defined as the software distributed with the heart of Perl itself, is a joint project on the part of all of us. From time to time, a script, module, or set of modules (hereafter referred to simply as a &quot;module&quot;) will prove so widely useful and/or so integral to the correct functioning of Perl itself that it should be distributed with the Perl core. This should never be done without the author's explicit consent, and a clear recognition on all parts that this means the module is being distributed under the same terms as Perl itself. A module author should realize that inclusion of a module into the Perl core will necessarily mean some loss of control over it, since changes may occasionally have to be made on short notice or for consistency with the rest of Perl.</source>
          <target state="translated">우리는 Perl 자체의 핵심과 함께 배포 된 소프트웨어로 정의 된 Perl 코어가 우리 모두의 공동 프로젝트라는 것을 알고 있습니다. 때때로 스크립트, 모듈 또는 모듈 세트 (이하 간단히 &quot;모듈&quot;이라고 함)는 Perl과 함께 배포되어야하므로 Perl 자체의 올바른 기능에 매우 유용하고 / 또는 필수적으로 입증 될 것입니다. 핵심. 이것은 저자의 명시적인 동의 없이는 절대로 수행되어서는 안되며, 모든 부분에 대한 명확한 인식으로 모듈이 Perl 자체와 동일한 용어로 배포되고 있음을 의미합니다. 모듈 작성자는 모듈을 Perl 코어에 포함 시키면 모듈에 대한 제어력이 상실 될 수 있음을 인식해야합니다. 변경 사항은 짧은 통지로 또는 나머지 Perl과의 일관성을 위해 변경해야 할 수도 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="adbff354730155d973632a844ddac8001f83317b" translate="yes" xml:space="preserve">
          <source>We recommend InfoZIP: &lt;a href=&quot;http://www.info-zip.org/Zip.html&quot;&gt;http://www.info-zip.org/Zip.html&lt;/a&gt;</source>
          <target state="translated">InfoZIP를 권장합니다 : &lt;a href=&quot;http://www.info-zip.org/Zip.html&quot;&gt;http://www.info-zip.org/Zip.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4f1a977094921f3a67ec1b5d153f5c0398eec08d" translate="yes" xml:space="preserve">
          <source>We recommend ptar from Archive::Tar not older than 1.66 with '-C' option.</source>
          <target state="translated">'-C'옵션을 사용하여 Archive :: Tar 1.66보다 오래된 ptar를 권장합니다.</target>
        </trans-unit>
        <trans-unit id="cbe1fc263dadb40ca151eed92966c9248a04de8d" translate="yes" xml:space="preserve">
          <source>We recommend that you avoid this syntax, for several reasons.</source>
          <target state="translated">여러 가지 이유로이 구문을 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="579e792fc6edac0deca16c23591b561128b4c15e" translate="yes" xml:space="preserve">
          <source>We recommend that you only access attributes via &lt;b&gt;accessor&lt;/b&gt; methods. These are methods that can get or set the value of each attribute. We saw this earlier in the &lt;code&gt;print_info()&lt;/code&gt; example, which calls &lt;code&gt;$self-&amp;gt;path&lt;/code&gt; .</source>
          <target state="translated">우리는 당신만을 액세스를 통해 속성을하는 것이 좋습니다 &lt;b&gt;접근&lt;/b&gt; 방법. 각 속성의 값을 가져 오거나 설정할 수있는 메소드입니다. 앞에서 &lt;code&gt;print_info()&lt;/code&gt; 예제에서 &lt;code&gt;$self-&amp;gt;path&lt;/code&gt; 를 호출했습니다 .</target>
        </trans-unit>
        <trans-unit id="3cd090bb786563ac9394aa0d7f58e631fb54d86e" translate="yes" xml:space="preserve">
          <source>We recommend that you use this method to access another package's version, rather than looking directly at &lt;code&gt;$Package::VERSION&lt;/code&gt; . The package you are looking at could have overridden the &lt;code&gt;VERSION&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;$Package::VERSION&lt;/code&gt; 직접 보지 말고이 방법을 사용하여 다른 패키지 버전에 액세스하는 것이 좋습니다 . 보고있는 패키지가 &lt;code&gt;VERSION&lt;/code&gt; 메서드를 재정의했을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3584759389d1a5c9463e1916b5f8cba299128724" translate="yes" xml:space="preserve">
          <source>We said that references spring into existence as necessary if they are undefined, but we didn't say what happens if a value used as a reference is already defined, but</source>
          <target state="translated">우리는 참조가 정의되지 않은 경우 필요에 따라 참조가 발생한다고 말했지만 참조로 사용 된 값이 이미 정의 된 경우 어떻게되는지 말하지 않았지만</target>
        </trans-unit>
        <trans-unit id="f1e706dab14e9082a067c69407d520e37d14c840" translate="yes" xml:space="preserve">
          <source>We saw in the section above that there were ordinary characters, which represented themselves, and special characters, which needed a backslash &lt;code&gt;\&lt;/code&gt; to represent themselves. The same is true in a character class, but the sets of ordinary and special characters inside a character class are different than those outside a character class. The special characters for a character class are &lt;code&gt;-]\^$&lt;/code&gt; (and the pattern delimiter, whatever it is). &lt;code&gt;]&lt;/code&gt; is special because it denotes the end of a character class. &lt;code&gt;$&lt;/code&gt; is special because it denotes a scalar variable. &lt;code&gt;\&lt;/code&gt; is special because it is used in escape sequences, just like above. Here is how the special characters &lt;code&gt;]$\&lt;/code&gt; are handled:</source>
          <target state="translated">우리는 백 슬래시 필요로 자신을 표현 일반 문자와 특수 문자가 있다고 위의 섹션에서 본 &lt;code&gt;\&lt;/code&gt; 자신을 표현하기를. 문자 클래스에서도 마찬가지이지만 문자 클래스 내부의 일반 및 특수 문자 세트는 문자 클래스 외부의 문자와 다릅니다. 문자 클래스의 특수 문자는 &lt;code&gt;-]\^$&lt;/code&gt; (및 패턴 구분 기호는 무엇이든)입니다. &lt;code&gt;]&lt;/code&gt; 는 문자 클래스의 끝을 나타 내기 때문에 특별합니다. &lt;code&gt;$&lt;/code&gt; 는 스칼라 변수를 나타내므로 특별합니다. &lt;code&gt;\&lt;/code&gt; 는 위와 같이 이스케이프 시퀀스에 사용되므로 특별합니다. 특수 문자 &lt;code&gt;]$\&lt;/code&gt; 를 처리 하는 방법은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="91ab61be245cfbe060001be5799707fcb012f47d" translate="yes" xml:space="preserve">
          <source>We saw that the norm of &lt;code&gt;z&lt;/code&gt; was noted &lt;code&gt;&lt;a href=&quot;../functions/abs&quot;&gt;abs(z)&lt;/a&gt;&lt;/code&gt; and was defined as the distance to the origin, also known as:</source>
          <target state="translated">우리의 규범 보았다 &lt;code&gt;z&lt;/code&gt; 관찰되었다 &lt;code&gt;&lt;a href=&quot;../functions/abs&quot;&gt;abs(z)&lt;/a&gt;&lt;/code&gt; 또한 알려진 원점까지의 거리로서 정의 하였다 :</target>
        </trans-unit>
        <trans-unit id="08920844359a9b99eec6c4ed6a36e0f532af1cca" translate="yes" xml:space="preserve">
          <source>We show the &quot;put&quot; form of the accessors below (i.e., the syntax you use for setting the accessor to a specific value). But you can also call each method with no parameters to get its current value. For example, &lt;code&gt;$self-&amp;gt;contents_file()&lt;/code&gt; returns the current value of the contents_file attribute.</source>
          <target state="translated">아래에 접근 자의 &quot;입력&quot;형식 (예 : 접근자를 특정 값으로 설정하는 데 사용하는 구문)이 표시됩니다. 그러나 매개 변수없이 각 메소드를 호출하여 현재 값을 얻을 수도 있습니다. 예를 들어 &lt;code&gt;$self-&amp;gt;contents_file()&lt;/code&gt; 은 contents_file 속성의 현재 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d711adc8921158fc2754824f56564036d9f3cc37" translate="yes" xml:space="preserve">
          <source>We specify a local port in the &lt;code&gt;LocalPort&lt;/code&gt; argument, which we didn't do for the client. This is service name or port number for which you want to be the server. (Under Unix, ports under 1024 are restricted to the superuser.) In our sample, we'll use port 9000, but you can use any port that's not currently in use on your system. If you try to use one already in used, you'll get an &quot;Address already in use&quot; message. Under Unix, the &lt;code&gt;netstat -a&lt;/code&gt; command will show which services current have servers.</source>
          <target state="translated">우리는 &lt;code&gt;LocalPort&lt;/code&gt; 인수 에 로컬 포트를 지정했는데 , 클라이언트에서는하지 않았습니다. 서버가 될 서비스 이름 또는 포트 번호입니다. (유닉스에서 1024 미만의 포트는 수퍼 유저로 제한됩니다.)이 샘플에서는 포트 9000을 사용하지만 현재 시스템에서 사용하지 않는 모든 포트를 사용할 수 있습니다. 이미 사용중인 주소를 사용하려고하면 &quot;이미 사용중인 주소&quot;메시지가 나타납니다. 유닉스에서 &lt;code&gt;netstat -a&lt;/code&gt; 명령은 현재 서버에 어떤 서비스가 있는지 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="d2e82c57891dd489170077bbfa6bd5d7eef124d7" translate="yes" xml:space="preserve">
          <source>We still got a few errors during &lt;code&gt;make test&lt;/code&gt; . Some of them are the result of using bison. Bison prints</source>
          <target state="translated">&lt;code&gt;make test&lt;/code&gt; 중에도 여전히 몇 가지 오류가 발생했습니다 . 그들 중 일부는 들소를 사용한 결과입니다. 들소 인쇄</target>
        </trans-unit>
        <trans-unit id="5d27fd099f66e666f815d6a063eb846b9d1e750a" translate="yes" xml:space="preserve">
          <source>We still use the normal yacc for a2p.y though!!! We made a softlink called byacc to distinguish between the two versions:</source>
          <target state="translated">우리는 여전히 a2p.y에 일반 yacc를 사용합니다 !!! 두 버전을 구별하기 위해 byacc라는 소프트 링크를 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="f7a01cac535c65877c2cb721bb86383129124455" translate="yes" xml:space="preserve">
          <source>We strongly recommend that you use git if possible. It will make your life easier, and ours as well.</source>
          <target state="translated">가능하면 git을 사용하는 것이 좋습니다. 그것은 당신의 삶과 우리의 삶을 더 쉽게 만들어 줄 것입니다.</target>
        </trans-unit>
        <trans-unit id="c1224f92134a2160e75f8a1e63e0730529cc456d" translate="yes" xml:space="preserve">
          <source>We strongly recommend that you use one of these systems. Even the most minimal of them eliminates a lot of repetitive boilerplate. There's really no good reason to write your classes from scratch in Perl.</source>
          <target state="translated">이러한 시스템 중 하나를 사용하는 것이 좋습니다. 그것들 중 가장 작은 것조차도 많은 반복적 인 상용구를 제거합니다. Perl에서 클래스를 처음부터 새로 작성할 이유는 없습니다.</target>
        </trans-unit>
        <trans-unit id="5f4fa8e578a8c0a7391c3d072ae8a1a053f0a384" translate="yes" xml:space="preserve">
          <source>We tend to avoid this term because it means so many things. It may mean a command-line &lt;b&gt;switch&lt;/b&gt; that takes no argument itself (such as Perl&amp;rsquo;s &lt;code&gt;&amp;ndash;n&lt;/code&gt; and &lt;code&gt;&amp;ndash;p&lt;/code&gt; flags) or, less frequently, a single-bit indicator (such as the &lt;code&gt;O_CREAT&lt;/code&gt; and &lt;code&gt;O_EXCL&lt;/code&gt; flags used in &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;). Sometimes informally used to refer to certain regex modifiers.</source>
          <target state="translated">우리는이 용어가 너무 많은 것을 의미하기 때문에 피하는 경향이 있습니다. 이는 Perl의 &lt;code&gt;&amp;ndash;n&lt;/code&gt; 및 &lt;code&gt;&amp;ndash;p&lt;/code&gt; 플래그 와 같은 인수 자체 를 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 에서 사용되는 &lt;code&gt;O_CREAT&lt;/code&gt; 및 &lt;code&gt;O_EXCL&lt;/code&gt; 플래그 와 같은 단일 비트 표시기를 자주 사용 하지 않는 명령 줄 &lt;b&gt;스위치&lt;/b&gt; 를 의미 할 수 있습니다 . 때때로 특정 정규식 수정자를 지칭하기 위해 비공식적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8a3b4e98c264bb32d9998c5d96e9cb12719e9b31" translate="yes" xml:space="preserve">
          <source>We then do (always a good idea) a syntax check before we try to run it again:</source>
          <target state="translated">그런 다음 다시 실행하기 전에 구문 검사를 수행합니다 (항상 좋은 생각).</target>
        </trans-unit>
        <trans-unit id="a54d539385035f7d9714e68587e437b9e809a0a4" translate="yes" xml:space="preserve">
          <source>We use the term &quot;nearly&quot;, because &lt;code&gt;:not_characters&lt;/code&gt; also turns on &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; within its scope. This form is less useful in v5.20 and later, and is described fully in &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;Unicode and UTF-8&lt;/a&gt;, but briefly, it tells Perl to not use the character portions of the locale definition, that is the &lt;code&gt;LC_CTYPE&lt;/code&gt; and &lt;code&gt;LC_COLLATE&lt;/code&gt; categories. Instead it will use the native character set (extended by Unicode). When using this parameter, you are responsible for getting the external character set translated into the native/Unicode one (which it already will be if it is one of the increasingly popular UTF-8 locales). There are convenient ways of doing this, as described in &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;Unicode and UTF-8&lt;/a&gt;.</source>
          <target state="translated">&quot;거의&quot;라는 용어를 사용합니다. &lt;code&gt;:not_characters&lt;/code&gt; 도 범위 내에서 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; 을 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 를 사용 합니다 . 이 형식은 v5.20 이상에서 유용하지 않으며 &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;유니 코드 및 UTF-8로&lt;/a&gt; 완전히 설명되어 있지만 간단히 말해 Perl에 로케일 정의의 문자 부분 ( &lt;code&gt;LC_CTYPE&lt;/code&gt; 및 &lt;code&gt;LC_COLLATE&lt;/code&gt; 범주)을 사용하지 않도록 지시 합니다. 대신 기본 문자 세트 (유니 코드로 확장)를 사용합니다. 이 매개 변수를 사용하는 경우 외부 문자 세트를 원시 / 유니 코드로 변환해야합니다 (이는 점점 인기있는 UTF-8 로케일 중 하나 인 경우에 이미 발생 함). 에 설명 된대로이 작업을 수행하는 편리한 방법이 &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;유니 코드 및 UTF-8에&lt;/a&gt;있습니다.</target>
        </trans-unit>
        <trans-unit id="d72bbd81e111127cc31735e5170b3d3ebdc6c5df" translate="yes" xml:space="preserve">
          <source>We used version 1.2.4, which could be installed out of the box with one failure during 'make check'.</source>
          <target state="translated">'make check'중에 한 번의 실패로 즉시 설치 가능한 버전 1.2.4를 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="aff45f6c939582aab469b75158efc5869d3a2fcf" translate="yes" xml:space="preserve">
          <source>We want to be able to catch the</source>
          <target state="translated">우리는 잡을 수 있기를 원합니다</target>
        </trans-unit>
        <trans-unit id="da129d4b3f31bc7e0cab0dd659997b6d3ef9282c" translate="yes" xml:space="preserve">
          <source>We want to ensure that Perl continues to grow and flourish in the coming years and decades, but not at the expense of our user community.</source>
          <target state="translated">우리는 Perl이 앞으로 수십 년 동안 계속 성장하고 번창하기를 원하지만 사용자 커뮤니티를 희생 시키지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="7602b11fb920ddd30994aa4313930abda93469a9" translate="yes" xml:space="preserve">
          <source>We wanted list context, so G_ARRAY was used.</source>
          <target state="translated">우리는 목록 컨텍스트를 원했기 때문에 G_ARRAY가 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="3134ffe8598077df7a151748c12e387529c7d2bc" translate="yes" xml:space="preserve">
          <source>We will be calling the test script through the command &quot;&lt;code&gt;make test&lt;/code&gt; &quot;. You should see output that looks something like this:</source>
          <target state="translated">&quot; &lt;code&gt;make test&lt;/code&gt; &quot; 명령을 통해 테스트 스크립트를 호출 할 것 입니다. 다음과 같은 출력이 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="0a6f3f09fa5bfb41f8f72f761c01531e59969f1d" translate="yes" xml:space="preserve">
          <source>We will not provide security updates or bug fixes for development releases of Perl.</source>
          <target state="translated">Perl 개발 릴리스에 대한 보안 업데이트 나 버그 수정은 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="788212053c8b040e14cd53eba253eacd9f8cbdce" translate="yes" xml:space="preserve">
          <source>We will now create the main top-level Mytest2 files. Change to the directory above Mytest2 and run the following command:</source>
          <target state="translated">이제 최상위 최상위 Mytest2 파일을 만듭니다. Mytest2 위의 디렉토리로 변경하고 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="d22caa360403eba16e21b51e9ea68e688fb5cc28" translate="yes" xml:space="preserve">
          <source>We would all love to unmake some mistakes we've made over the past decades. Living with every design error we've ever made can lead to painful stagnation. Unwinding our mistakes is very, very difficult. Doing so without actively harming our users is nearly impossible.</source>
          <target state="translated">우리는 모두 지난 수십 년 동안 우리가 저지른 실수를 저지르기를 원합니다. 우리가 만든 모든 디자인 오류로 생활하면 고통스런 정체가 발생할 수 있습니다. 우리의 실수를 풀면 매우 어렵습니다. 사용자에게 적극적으로 해를 끼치 지 않고 그렇게하는 것은 거의 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="461ccef8111ec963260713b6b25723c4d738d9a8" translate="yes" xml:space="preserve">
          <source>We'll come back to this city-country problem later, after we've seen some syntax for managing references.</source>
          <target state="translated">참조 관리에 대한 구문을 본 후에 나중에이 도시 국가 문제로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="7cbf9f8ec2dcbf019622a935f28d55742617ea78" translate="yes" xml:space="preserve">
          <source>We'll get to the meaning of those Perlish-looking variables in a little bit.</source>
          <target state="translated">우리는 Perlish처럼 보이는 변수의 의미를 조금만 알아볼 것입니다.</target>
        </trans-unit>
        <trans-unit id="ccbe83524a5012d45f354f697c95fa9a1eb5367f" translate="yes" xml:space="preserve">
          <source>We'll have another string pointer in there:</source>
          <target state="translated">거기에 다른 문자열 포인터가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5672edbff82e9ae33e95bbfe34109b2db08b3398" translate="yes" xml:space="preserve">
          <source>We'll look at output first. Supposing we already have this structure, how do we print it out?</source>
          <target state="translated">먼저 출력을 살펴 보겠습니다. 이 구조가 이미 있다고 가정하면 어떻게 인쇄합니까?</target>
        </trans-unit>
        <trans-unit id="8801992116fa36a8b481455c1f17fda02ba0a864" translate="yes" xml:space="preserve">
          <source>We'll see a more tricky example of this when we consider Perl's macros below. &lt;code&gt;POPn&lt;/code&gt; gives you the NV (floating point value) of the top SV on the stack: the &lt;code&gt;$x&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;functions/cos&quot;&gt;cos($x)&lt;/a&gt;&lt;/code&gt;. Then we compute the cosine, and push the result back as an NV. The &lt;code&gt;X&lt;/code&gt; in &lt;code&gt;XPUSHn&lt;/code&gt; means that the stack should be extended if necessary - it can't be necessary here, because we know there's room for one more item on the stack, since we've just removed one! The &lt;code&gt;XPUSH*&lt;/code&gt; macros at least guarantee safety.</source>
          <target state="translated">아래에서 Perl의 매크로를 고려할 때 더 까다로운 예를 볼 수 있습니다. &lt;code&gt;POPn&lt;/code&gt; 은 스택에서 최상위 SV의 NV (부동 소수점 값)를 제공합니다 : &lt;code&gt;$x&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;functions/cos&quot;&gt;cos($x)&lt;/a&gt;&lt;/code&gt; . 그런 다음 코사인을 계산하고 결과를 NV로 다시 푸시합니다. &lt;code&gt;XPUSHn&lt;/code&gt; 의 &lt;code&gt;X&lt;/code&gt; 는 필요한 경우 스택을 확장해야 함을 의미합니다. 스택에서 하나 이상의 항목을 넣을 공간이 있다는 것을 알고 있기 때문에 여기서는 필요하지 않습니다. &lt;code&gt;XPUSH*&lt;/code&gt; 최소 보증 안전에 매크로.</target>
        </trans-unit>
        <trans-unit id="b55bbd57ee31a3c27c5821f6c991f3bb8fbebc65" translate="yes" xml:space="preserve">
          <source>We'll simply continue down to our pre-set breakpoint with a '&lt;b&gt;c&lt;/b&gt;':</source>
          <target state="translated">' &lt;b&gt;c&lt;/b&gt; '를 사용하여 미리 설정된 중단 점으로 간단히 넘어갑니다 .</target>
        </trans-unit>
        <trans-unit id="a9a2d405fbc50682e1a3c2bf95879ebe85538d93" translate="yes" xml:space="preserve">
          <source>We'll use &lt;code&gt;gdb&lt;/code&gt; for our examples here; the principles will apply to any debugger (many vendors call their debugger &lt;code&gt;dbx&lt;/code&gt; ), but check the manual of the one you're using.</source>
          <target state="translated">우리는 여기서 예제를 위해 &lt;code&gt;gdb&lt;/code&gt; 를 사용할 것이다 ; 원칙은 모든 디버거에 적용 되지만 (많은 벤더가 디버거 &lt;code&gt;dbx&lt;/code&gt; 라고 함 ) 사용중인 매뉴얼을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="dd00180725dcce313c6ef1b86501c9848503c2c0" translate="yes" xml:space="preserve">
          <source>We'll use Jarkko Hietaniemi &amp;lt;</source>
          <target state="translated">우리는 Jarkko Hietaniemi &amp;lt;</target>
        </trans-unit>
        <trans-unit id="f54f2656a6244346ba143809ce965c3e152258c1" translate="yes" xml:space="preserve">
          <source>We're Netware in addition to being Windows.</source>
          <target state="translated">우리는 Windows 외에도 Netware입니다.</target>
        </trans-unit>
        <trans-unit id="89a6bcd8665abf52d39396f9fea984b5d7d01f5f" translate="yes" xml:space="preserve">
          <source>We're Unix and Cygwin.</source>
          <target state="translated">우리는 Unix와 Cygwin입니다.</target>
        </trans-unit>
        <trans-unit id="bae7bf51fd64828a801e9cd04e2c5e1eac38f446" translate="yes" xml:space="preserve">
          <source>We're going to add two more items onto the argument stack: when you have a tied array, the &lt;code&gt;PUSH&lt;/code&gt; subroutine receives the object and the value to be pushed, and that's exactly what we have here - the tied object, retrieved with &lt;code&gt;SvTIED_obj&lt;/code&gt; , and the value, the SV &lt;code&gt;val&lt;/code&gt; .</source>
          <target state="translated">묶음 배열이있을 때 &lt;code&gt;PUSH&lt;/code&gt; 서브 루틴은 객체와 푸시 할 값을 수신합니다. 바로 여기에 &lt;code&gt;SvTIED_obj&lt;/code&gt; 로 검색된 묶인 객체가 있습니다 . 그리고 값, SV &lt;code&gt;val&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="982b2dd7e00a50956cc41a996392e78491465b29" translate="yes" xml:space="preserve">
          <source>We're going to primarily concentrate on Perl-only modules here, rather than XS modules. XS modules serve a rather different purpose, and you should consider different things before distributing them - the popularity of the library you are gluing, the portability to other operating systems, and so on. However, the notes on preparing the Perl side of the module and packaging and distributing it will apply equally well to an XS module as a pure-Perl one.</source>
          <target state="translated">여기서는 XS 모듈이 아닌 Perl 전용 모듈에 주로 중점을 둘 것입니다. XS 모듈은 다소 다른 목적을 제공하므로 배포하기 전에 다른 것들을 고려해야합니다. 접착하는 라이브러리의 인기, 다른 운영 체제로의 이식성 등. 그러나 모듈의 Perl 측 준비 및 패키징 및 배포에 대한 참고 사항은 XS 모듈에 순수 Perl 모듈과 동일하게 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="34118bf3962978ee960cb834c23b6a7907e48ac6" translate="yes" xml:space="preserve">
          <source>We've already seen how to print to standard output using &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; can also take an optional first argument specifying which filehandle to print to:</source>
          <target state="translated">우리는 이미 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; 사용하여 표준 출력으로 인쇄하는 방법을 보았습니다 . 그러나 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; 는 인쇄 할 파일 핸들을 지정하는 선택적 첫 번째 인수를 취할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="01a8063bdaca09993ddd8d252b857fa09a430a49" translate="yes" xml:space="preserve">
          <source>We've also told Perl about the library that we built in the mylib subdirectory. That required only the addition of the &lt;code&gt;MYEXTLIB&lt;/code&gt; variable to the WriteMakefile call and the replacement of the postamble subroutine to cd into the subdirectory and run make. The Makefile.PL for the library is a bit more complicated, but not excessively so. Again we replaced the postamble subroutine to insert our own code. This code simply specified that the library to be created here was a static archive library (as opposed to a dynamically loadable library) and provided the commands to build it.</source>
          <target state="translated">또한 mylib 서브 디렉토리에 빌드 한 라이브러리에 대해 Perl에게 알려주었습니다. 이를 위해서는 &lt;code&gt;MYEXTLIB&lt;/code&gt; 변수를 WriteMakefile 호출에 추가하고 postamble 서브 루틴을 cd로 서브 디렉토리로 바꾸고 make를 실행해야했습니다. 라이브러리의 Makefile.PL은 조금 더 복잡하지만 과도하지는 않습니다. 다시 우리는 postamble 서브 루틴을 교체하여 자체 코드를 삽입했습니다. 이 코드는 여기에서 생성 될 라이브러리가 정적 아카이브 라이브러리 (동적으로로드 가능한 라이브러리가 아닌)임을 지정하고이를 빌드하기위한 명령을 제공했습니다.</target>
        </trans-unit>
        <trans-unit id="6afd998315c2c6324bb813d112e9a8f30bf0d582" translate="yes" xml:space="preserve">
          <source>We've covered the workhorse parts of Perl's threading package, and with these tools you should be well on your way to writing threaded code and packages. There are a few useful little pieces that didn't really fit in anyplace else.</source>
          <target state="translated">우리는 Perl의 스레딩 패키지의 핵심 부분을 다루었으며 이러한 도구를 사용하면 스레드 코드와 패키지를 작성하는 데 도움이 될 것입니다. 다른 곳에는 맞지 않는 몇 가지 유용한 작은 조각이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4d69ed91d0829df5cfa125f68b479f5de86f05f" translate="yes" xml:space="preserve">
          <source>We've gone past our check (where 'All OK' was printed) and have stopped just before the meat of our task. We could try to print out a couple of variables to see what is happening:</source>
          <target state="translated">우리는 수표 ( 'All OK'가 인쇄 된 곳)를지나 작업의 바로 직전에 멈췄습니다. 우리는 무슨 일이 일어나고 있는지 확인하기 위해 몇 가지 변수를 인쇄하려고 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33a66a35950ff295dc8b9c6a23c44bcace53edc3" translate="yes" xml:space="preserve">
          <source>We've had Larry's h2ph translator, which helped, but that only works on cpp symbols, not real C, which was also very much needed. What I offer you is a symbolic way of getting at all the C structures. I've couched them in terms of packages and functions. Consider the following program:</source>
          <target state="translated">우리는 Larry의 h2ph 번역기를 사용했지만 실제로 C가 아닌 cpp 심볼에서만 작동합니다. 내가 당신에게 제공하는 것은 모든 C 구조를 얻는 상징적 방법입니다. 나는 패키지와 기능면에서 그것들을 꾸 couch 다. 다음 프로그램을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="f3af9852bf7e4f70a4af9b26111fb8e3956f866b" translate="yes" xml:space="preserve">
          <source>We've made some changes to Makefile.PL. In this case, we've specified an extra library to be linked into the extension's shared library, the math library libm in this case. We'll talk later about how to write XSUBs that can call every routine in a library.</source>
          <target state="translated">Makefile.PL을 일부 변경했습니다. 이 경우 확장의 공유 라이브러리 (이 경우 math 라이브러리 libm)에 링크 할 추가 라이브러리를 지정했습니다. 라이브러리의 모든 루틴을 호출 할 수있는 XSUB를 작성하는 방법에 대해서는 나중에 이야기하겠습니다.</target>
        </trans-unit>
        <trans-unit id="a904b7cf0e87b370c484aeda4a3fd7921273c345" translate="yes" xml:space="preserve">
          <source>We've seen how to encourage good coding practices with &lt;b&gt;use strict&lt;/b&gt; and &lt;b&gt;-w&lt;/b&gt;. We can run the perl debugger &lt;b&gt;perl -d scriptname&lt;/b&gt; to inspect your data from within the perl debugger with the &lt;b&gt;p&lt;/b&gt; and &lt;b&gt;x&lt;/b&gt; commands. You can walk through your code, set breakpoints with &lt;b&gt;b&lt;/b&gt; and step through that code with &lt;b&gt;s&lt;/b&gt; or &lt;b&gt;n&lt;/b&gt;, continue with &lt;b&gt;c&lt;/b&gt; and return from a sub with &lt;b&gt;r&lt;/b&gt;. Fairly intuitive stuff when you get down to it.</source>
          <target state="translated">&lt;b&gt;strict&lt;/b&gt; 및 &lt;b&gt;-w&lt;/b&gt; 를 &lt;b&gt;사용&lt;/b&gt; 하여 올바른 코딩 방법을 권장하는 방법을 살펴 보았습니다 . perl 디버거 &lt;b&gt;perl -d 스크립트 이름&lt;/b&gt; 을 실행하여 &lt;b&gt;p&lt;/b&gt; 및 &lt;b&gt;x&lt;/b&gt; 명령을 사용 하여 perl 디버거 내에서 데이터를 검사 할 수 있습니다 . 코드를 살펴보고 &lt;b&gt;b로&lt;/b&gt; 중단 점을 설정 하고 &lt;b&gt;s&lt;/b&gt; 또는 &lt;b&gt;n을&lt;/b&gt; 사용하여 해당 코드를 단계별로 진행할 수 있습니다.&lt;b&gt;&lt;/b&gt; 진행할 수 있습니다.&lt;b&gt; c를&lt;/b&gt; 하고 &lt;b&gt;r&lt;/b&gt; 을 사용하여 하위에서 돌아올 수 있습니다 . 당신이 그것을 얻을 때 상당히 직관적 인 물건.</target>
        </trans-unit>
        <trans-unit id="9f4aba3ac8d090b513bcacbad039797adbe73abe" translate="yes" xml:space="preserve">
          <source>We've taken some pains to construct the template so that it matches the contents of our frame buffer. Otherwise we'd either get undefined values, or &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; could not unpack all. If &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; runs out of items, it will supply null strings (which are coerced into zeroes whenever the pack code says so).</source>
          <target state="translated">프레임 버퍼의 내용과 일치하도록 템플릿을 구성하는 데 어려움을 겪었습니다. 그렇지 않으면 우리는 정의되지 않은 값을 얻거나 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 수 없습니다. 경우 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 항목이 부족, 그것은 (팩 코드는 이렇게 말한다 때마다 제로를 강요하는) 널 (null) 문자열을 공급한다.</target>
        </trans-unit>
        <trans-unit id="37fc93f698eef77381e152ba1261b27e22014722" translate="yes" xml:space="preserve">
          <source>We've tried to make this also work with the TODO: syntax, but it's not guaranteed and its use is also discouraged:</source>
          <target state="translated">우리는 이것을 TODO : 구문과 함께 작동 시키려고 노력했지만 보장되지는 않으며 사용도 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d057d23b834db4b8d50936a9c8b48cc9bb56ac94" translate="yes" xml:space="preserve">
          <source>We've tried to minimize the dependence of Perl library modules on Unix syntax, but you may find that some of these, as well as some scripts written for Unix systems, will require that you use Unix syntax, since they will assume that '/' is the directory separator,</source>
          <target state="translated">우리는 유닉스 구문에 대한 Perl 라이브러리 모듈의 의존성을 최소화하려고 노력했지만 유닉스 시스템 용으로 작성된 일부 스크립트뿐만 아니라 이들 중 일부는 유닉스 구문을 사용해야 할 것입니다. '는 디렉토리 구분 기호입니다.</target>
        </trans-unit>
        <trans-unit id="f63c6786d8c83343c69f80cf76418c3681700514" translate="yes" xml:space="preserve">
          <source>We've used a hash slice in order to easily handle the fields of each row. Storing the keys in an array makes it easy to operate on them as a group or loop over them with &lt;code&gt;for&lt;/code&gt; . It also avoids polluting the program with global variables and using symbolic references.</source>
          <target state="translated">각 행의 필드를 쉽게 처리하기 위해 해시 슬라이스를 사용했습니다. 배열에 키를 저장하면 그룹으로 쉽게 조작하거나 &lt;code&gt;for&lt;/code&gt; 를 사용하여 반복 할 수 있습니다 . 또한 전역 변수를 사용하고 기호 참조를 사용하여 프로그램을 오염시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e147d82cb4cdd9e073d031a1a26cd0222dd868d0" translate="yes" xml:space="preserve">
          <source>Weaken a reference: set the &lt;code&gt;SvWEAKREF&lt;/code&gt; flag on this RV; give the referred-to SV &lt;code&gt;PERL_MAGIC_backref&lt;/code&gt; magic if it hasn't already; and push a back-reference to this RV onto the array of backreferences associated with that magic. If the RV is magical, set magic will be called after the RV is cleared.</source>
          <target state="translated">참조를 약화 : 이 RV에 &lt;code&gt;SvWEAKREF&lt;/code&gt; 플래그를 설정하십시오 . 참조 된 SV &lt;code&gt;PERL_MAGIC_backref&lt;/code&gt; 매직이 아직 없다면 마법을줍니다. 이 RV에 대한 역 참조를 해당 마술과 관련된 역 참조 배열로 푸시합니다. RV가 마법 인 경우 RV가 해제 된 후에 설정된 마법이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="6f4b4063ed2668451305a4ea955df5abd08928f3" translate="yes" xml:space="preserve">
          <source>Weakrefs call uvar magic</source>
          <target state="translated">약한 사람들은 uvar 마술을 부릅니다</target>
        </trans-unit>
        <trans-unit id="a87a48da60ac110880ba420c176bfa3b966a1bbc" translate="yes" xml:space="preserve">
          <source>Websites</source>
          <target state="translated">Websites</target>
        </trans-unit>
        <trans-unit id="c46c01995b645fa6ced7ccd3bd695a2325cf2829" translate="yes" xml:space="preserve">
          <source>Weed out arguments that are not supported and warn about them to the user</source>
          <target state="translated">지원되지 않는 인수를 제거하고 사용자에게 경고</target>
        </trans-unit>
        <trans-unit id="5ff64b425852808bfa9bcc07404d47fe62f5255b" translate="yes" xml:space="preserve">
          <source>Week Number</source>
          <target state="translated">주 번호</target>
        </trans-unit>
        <trans-unit id="e47cfca7176dccc849b8b9085335ec9965e39788" translate="yes" xml:space="preserve">
          <source>Weighting CJK Unified Ideographs</source>
          <target state="translated">CJK 통합 표의 문자 가중치</target>
        </trans-unit>
        <trans-unit id="6b33b573e9b7a7f05800470ad22d2691de1ad1d8" translate="yes" xml:space="preserve">
          <source>Weighting JIS KANJI for Unicode::Collate</source>
          <target state="translated">JIS KANJI for Unicode :: Collate에 가중치 부여</target>
        </trans-unit>
        <trans-unit id="b6757ec0e4d4ce4eae1496f199fc7aa0d085efea" translate="yes" xml:space="preserve">
          <source>Weighting may vary depending on collation element table. So ensure the weights defined in &lt;code&gt;entry&lt;/code&gt; will be consistent with those in the collation element table loaded via &lt;code&gt;table&lt;/code&gt; .</source>
          <target state="translated">데이터 정렬 요소 테이블에 따라 가중치가 달라질 수 있습니다. 그래서에 정의 된 가중치 보장 &lt;code&gt;entry&lt;/code&gt; 통해로드 된 조합 요소 테이블에있는 것과 일치 할 것이다 &lt;code&gt;table&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b6bdfd154d71780792f4f6d415a46881c01b84f" translate="yes" xml:space="preserve">
          <source>Weights in reverse order; ex. level 2 (diacritic ordering) in French. If omitted (or &lt;code&gt;$levelNumber&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;\@levelNumbers&lt;/code&gt; is &lt;code&gt;[]&lt;/code&gt; ), forwards at all the levels.</source>
          <target state="translated">역순의 가중치; 전의. 프랑스어 수준 2 (분음 부호 순서) 생략하면 (또는 &lt;code&gt;$levelNumber&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 이거나 &lt;code&gt;\@levelNumbers&lt;/code&gt; 는 &lt;code&gt;[]&lt;/code&gt; ) 모든 레벨에서 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="1ade9c702a20a6384a7a0b9552d289287a18c722" translate="yes" xml:space="preserve">
          <source>Well, apart from a bare &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt; $fh&lt;/code&gt; , you shouldn't treat them specially. (The binmode is needed because otherwise Perl may convert line endings on Win32 systems.)</source>
          <target state="translated">음, 떨어져 베어에서 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt; $fh&lt;/code&gt; , 당신은 특별히 그들을 치료하지 않아야합니다. (그렇지 않으면 Perl이 Win32 시스템에서 줄 끝을 변환 할 수 있기 때문에 binmode가 필요합니다.)</target>
        </trans-unit>
        <trans-unit id="504ec4c7237da89364f87b2aad3291cf833f70a8" translate="yes" xml:space="preserve">
          <source>Well, having several executables dynamically linked to the same huge library has its advantages, but this would not substantiate the additional work to make it compile. The reason is the complicated-to-developers but very quick and convenient-to-users &quot;hard&quot; dynamic linking used by OS/2.</source>
          <target state="translated">글쎄, 같은 거대한 라이브러리에 동적으로 연결된 여러 실행 파일을 갖는 이점이 있지만 컴파일을 위해 추가 작업을 입증하지는 않습니다. 그 이유는 개발자에게는 복잡하지만 OS / 2에서 사용하는 매우 빠르고 사용자에게는 &quot;하드&quot;동적 연결이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="b4bf2ee14e4e81fc05f1087aeed820b042b0028b" translate="yes" xml:space="preserve">
          <source>Well, if you can, upgrade to the most recent, but certainly &lt;code&gt;5.8.1&lt;/code&gt; or newer. The tutorial and FAQ assume the latest release.</source>
          <target state="translated">가능하다면 가장 최신이지만 확실히 &lt;code&gt;5.8.1&lt;/code&gt; 이상으로 업그레이드하십시오 . 학습서 및 FAQ는 최신 릴리스를 가정합니다.</target>
        </trans-unit>
        <trans-unit id="c922bdb3f23d6c5306883fe0bee806df01fe877f" translate="yes" xml:space="preserve">
          <source>Well, maybe not. Anyway, each op contains a function pointer, which stipulates the function which will actually carry out the operation. This function will return the next op in the sequence - this allows for things like &lt;code&gt;if&lt;/code&gt; which choose the next op dynamically at run time. The &lt;code&gt;PERL_ASYNC_CHECK&lt;/code&gt; makes sure that things like signals interrupt execution if required.</source>
          <target state="translated">아마 아닐 수도 있습니다. 어쨌든, 각 op에는 실제로 작업을 수행 할 함수를 규정하는 함수 포인터가 있습니다. 이 같은 일이 가능 -이 기능은 순서대로 다음 연산을 반환 &lt;code&gt;if&lt;/code&gt; 런타임에 동적으로 다음 연산을 선택한다. &lt;code&gt;PERL_ASYNC_CHECK&lt;/code&gt; 필요한 경우 신호 같은 것들을 실행을 중단 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="fb7d8a35468fea02bd934ea87237f211894a5751" translate="yes" xml:space="preserve">
          <source>Well, nowadays Perl DLL should be usable from a differently compiled program too... If you can run Perl code from REXX scripts (see &lt;a href=&quot;http://search.cpan.org/perldoc/OS2::REXX&quot;&gt;OS2::REXX&lt;/a&gt;), then there are some other aspect of interaction which are overlooked by the current hackish code to support differently-compiled principal programs.</source>
          <target state="translated">글쎄, 오늘날 Perl DLL은 다르게 컴파일 된 프로그램에서도 사용할 수 있어야합니다 ... REXX 스크립트에서 Perl 코드를 실행할 수 있다면 ( &lt;a href=&quot;http://search.cpan.org/perldoc/OS2::REXX&quot;&gt;OS2 :: REXX&lt;/a&gt; 참조 ) 현재 해시 코드가 간과하는 상호 작용의 다른 측면이 있습니다 다르게 컴파일 된 주요 프로그램을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="61cb10844d83ee77c0e38f0deaf6e76838a94cbb" translate="yes" xml:space="preserve">
          <source>Well, okay, not entirely like C's arrays, actually. C doesn't know how to grow its arrays on demand. Perl does.</source>
          <target state="translated">글쎄, 사실 C의 배열과 완전히 같지는 않습니다. C는 필요에 따라 배열을 확장하는 방법을 모릅니다. 펄은 그렇습니다.</target>
        </trans-unit>
        <trans-unit id="c4f3fa326a3af64f93426bcdac847f46a94f9b1b" translate="yes" xml:space="preserve">
          <source>Well, that's</source>
          <target state="translated">글쎄, 그건</target>
        </trans-unit>
        <trans-unit id="bf3871275db74807de50e10189deb9ba1201d5b4" translate="yes" xml:space="preserve">
          <source>Well, that's all fine if you want to send one command and get one answer, but what about setting up something fully interactive, somewhat like the way</source>
          <target state="translated">글쎄, 하나의 명령을 보내고 하나의 답변을 원한다면 그것은 괜찮습니다.하지만 완전히 대화식으로 무언가를 설정하는 것은 어떻습니까?</target>
        </trans-unit>
        <trans-unit id="a4fcece5fae45fd55beac8d83dea4ffc7bb1546c" translate="yes" xml:space="preserve">
          <source>Well, that's because the rule is that on adjacent brackets only (whether square or curly), you are free to omit the pointer dereferencing arrow. But you cannot do so for the very first one if it's a scalar containing a reference, which means that $ref_to_AoA always needs it.</source>
          <target state="translated">글쎄, 그 이유는 인접한 대괄호에서만 (사각형이든 곱슬이든) 포인터 참조 화살표를 생략 할 수 있기 때문입니다. 그러나 참조를 포함하는 스칼라 인 경우 첫 번째 경우에는 그렇게 할 수 없으므로 $ ref_to_AoA는 항상 필요합니다.</target>
        </trans-unit>
        <trans-unit id="5937ea9ee293b2d54cd64fb9f3a778625f679e1c" translate="yes" xml:space="preserve">
          <source>Well, this isn't very easy to read, and using the helpful manual (&lt;b&gt;h h&lt;/b&gt;), the '&lt;b&gt;x&lt;/b&gt;' command looks promising:</source>
          <target state="translated">글쎄, 이것은 읽기가 쉽지 않으며 유용한 설명서 ( &lt;b&gt;hh&lt;/b&gt; )를 사용하면 ' &lt;b&gt;x&lt;/b&gt; '명령이 유망 해 보입니다.</target>
        </trans-unit>
        <trans-unit id="81775bcb15e4091e227d731dfdef1462a2bf3f2b" translate="yes" xml:space="preserve">
          <source>Well, you could keep them in sync, but there's no guarantee it will always hold on classes somebody else wrote. Besides, there is little to gain in doing so: a serializing hook could keep only one attribute of an object, which is probably not what should happen during a deep cloning of that same object.</source>
          <target state="translated">글쎄, 당신은 그것들을 동기화시킬 수는 있지만, 다른 사람이 작성한 수업을 항상 유지할 것이라는 보장은 없습니다. 게다가, 직렬화 후크는 객체의 속성 하나만 유지할 수 있으며, 이는 동일한 객체를 심도있게 복제하는 동안 발생하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="c6c58c114eba15fa1fde6b56057cb927734327d9" translate="yes" xml:space="preserve">
          <source>What *is* Unicode, anyway?</source>
          <target state="translated">어쨌든 유니 코드 란 무엇인가?</target>
        </trans-unit>
        <trans-unit id="2948ac1effa2d43a9756f45e31fc4dfaf54b428e" translate="yes" xml:space="preserve">
          <source>What &lt;b&gt;is&lt;/b&gt; Unicode, anyway?</source>
          <target state="translated">무엇 &lt;b&gt;입니다&lt;/b&gt; 어쨌든, 유니 코드?</target>
        </trans-unit>
        <trans-unit id="0c27997670ea19d058363ea936f9c5a132d90646" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; does</source>
          <target state="translated">무엇을 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 수행</target>
        </trans-unit>
        <trans-unit id="828c569308e99c356a11f905449002a24faaf00f" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;\n&lt;/code&gt; represents depends on the type of file opened. It usually represents &lt;code&gt;\012&lt;/code&gt; but it could also be &lt;code&gt;\015&lt;/code&gt; , &lt;code&gt;\012&lt;/code&gt; , &lt;code&gt;\015\012&lt;/code&gt; , &lt;code&gt;\000&lt;/code&gt; , &lt;code&gt;\040&lt;/code&gt; , or nothing depending on the file organization and record format. The &lt;code&gt;VMS::Stdio&lt;/code&gt; module provides access to the special &lt;code&gt;fopen()&lt;/code&gt; requirements of files with unusual attributes on VMS.</source>
          <target state="translated">무엇 &lt;code&gt;\n&lt;/code&gt; 대표하는 열려있는 파일의 종류에 따라 다릅니다. 일반적으로 &lt;code&gt;\012&lt;/code&gt; 나타내지 만 파일 구성 및 레코드 형식에 따라 &lt;code&gt;\015&lt;/code&gt; , &lt;code&gt;\012&lt;/code&gt; , &lt;code&gt;\015\012&lt;/code&gt; , &lt;code&gt;\000&lt;/code&gt; , &lt;code&gt;\040&lt;/code&gt; 일 수도 있고 아무것도 아닐 수도 있습니다 . &lt;code&gt;VMS::Stdio&lt;/code&gt; 모듈은 특별한에 대한 액세스 제공 &lt;code&gt;fopen()&lt;/code&gt; VMS에 특별한 속성을 가진 파일의 요구 사항.</target>
        </trans-unit>
        <trans-unit id="fcc1cc41a80c328b4eb792743f378eba1c9a93d1" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;\p{Digit}&lt;/code&gt; means (and hence &lt;code&gt;\d&lt;/code&gt; except under the &lt;code&gt;/a&lt;/code&gt; modifier) is &lt;code&gt;\p{General_Category=Decimal_Number}&lt;/code&gt; , or synonymously, &lt;code&gt;\p{General_Category=Digit}&lt;/code&gt; . Starting with Unicode version 4.1, this is the same set of characters matched by &lt;code&gt;\p{Numeric_Type=Decimal}&lt;/code&gt; . But Unicode also has a different property with a similar name, &lt;code&gt;\p{Numeric_Type=Digit}&lt;/code&gt; , which matches a completely different set of characters. These characters are things such as &lt;code&gt;CIRCLED DIGIT ONE&lt;/code&gt; or subscripts, or are from writing systems that lack all ten digits.</source>
          <target state="translated">어떤 &lt;code&gt;\p{Digit}&lt;/code&gt; (따라서 수단 &lt;code&gt;\d&lt;/code&gt; 언더 제외 &lt;code&gt;/a&lt;/code&gt; 수정하는)이다 &lt;code&gt;\p{General_Category=Decimal_Number}&lt;/code&gt; 또는 동의어, &lt;code&gt;\p{General_Category=Digit}&lt;/code&gt; . 유니 코드 버전 4.1부터는 &lt;code&gt;\p{Numeric_Type=Decimal}&lt;/code&gt; 과 동일한 문자 세트입니다 . 그러나 유니 코드에는 이름이 &lt;code&gt;\p{Numeric_Type=Digit}&lt;/code&gt; 인 비슷한 속성이 있으며 완전히 다른 문자 집합과 일치합니다. 이 문자는 &lt;code&gt;CIRCLED DIGIT ONE&lt;/code&gt; 또는 아래 첨자 와 같은 문자 이거나 10 자리가 모두없는 필기 시스템의 문자입니다.</target>
        </trans-unit>
        <trans-unit id="1e45028df29a344ed3d5dcfe47d49eff1e4e5b3d" translate="yes" xml:space="preserve">
          <source>What Is A Thread Anyway?</source>
          <target state="translated">어쨌든 스레드는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="9f3aa83a51cae6aa5da8eadacc3922153fc22ffe" translate="yes" xml:space="preserve">
          <source>What Not to Export</source>
          <target state="translated">수출하지 않을 것</target>
        </trans-unit>
        <trans-unit id="bcf1ef3ecb402df133384ad31b9f0ab2cd6f6d09" translate="yes" xml:space="preserve">
          <source>What Thread Am I In?</source>
          <target state="translated">어떤 스레드에 있습니까?</target>
        </trans-unit>
        <trans-unit id="bdf11c2c3fa2430fc36aec96902da89a7d6631c6" translate="yes" xml:space="preserve">
          <source>What Threads Are Running?</source>
          <target state="translated">어떤 스레드가 실행되고 있습니까?</target>
        </trans-unit>
        <trans-unit id="4628ec6a65c6ef207e94ed239509a432eb2d40b1" translate="yes" xml:space="preserve">
          <source>What You See Is What You Get. Usually used when something that appears on the screen matches how it will eventually look, like Perl&amp;rsquo;s &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; declarations. Also used to mean the opposite of magic because everything works exactly as it appears, as in the three- argument form of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">당신이 보는 것은 당신이 얻는 것입니다. 일반적으로 화면에 나타나는 것이 Perl의 &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; 선언 과 같이 결과와 일치 할 때 사용됩니다 . 또한 3 개의 인수 형식의 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 에서와 같이 모든 것이 표시된대로 정확하게 작동하기 때문에 마법의 반대를 의미하는 데에도 사용됩니다. .</target>
        </trans-unit>
        <trans-unit id="71fba121999cf66c38da9b22673582805a4f1ef9" translate="yes" xml:space="preserve">
          <source>What a &lt;b&gt;process&lt;/b&gt; does when it has to wait for something: &amp;ldquo;My process blocked waiting for the disk.&amp;rdquo; As an unrelated noun, it refers to a large chunk of data, of a size that the &lt;b&gt;operating system&lt;/b&gt; likes to deal with (normally a power of 2 such as 512 or 8192). Typically refers to a chunk of data that&amp;rsquo;s coming from or going to a disk file.</source>
          <target state="translated">무언가를 기다려야 할 때 &lt;b&gt;프로세스&lt;/b&gt; 가 수행 하는 &lt;b&gt;작업&lt;/b&gt; : &quot;내 프로세스가 디스크 대기를 차단했습니다.&quot; 관련이없는 명사로서, &lt;b&gt;운영 체제&lt;/b&gt; 보다 크기가 큰 데이터 청크를 나타냅니다.&lt;b&gt;&lt;/b&gt; 가 처리하기 (대개 512 또는 8192와 같은 2의 거듭 제곱) 인 . 일반적으로 디스크 파일에서 가져 오거나 디스크 파일로 이동하는 데이터 청크를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="bc0f239768e941abba33a14d0c879853b4c42602" translate="yes" xml:space="preserve">
          <source>What about &lt;code&gt;pp_add&lt;/code&gt; , the function we examined earlier to implement the &lt;code&gt;+&lt;/code&gt; operator:</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 를 구현하기 위해 앞서 살펴본 함수 인 &lt;code&gt;pp_add&lt;/code&gt; 는 어떻습니까 ? 연산자</target>
        </trans-unit>
        <trans-unit id="f06b49d955a9223ccdbf114f85c4f46fdc429b37" translate="yes" xml:space="preserve">
          <source>What about binary data, like images?</source>
          <target state="translated">이미지와 같은 이진 데이터는 어떻습니까?</target>
        </trans-unit>
        <trans-unit id="904b144e4b71718e8b3ada176614f796ad653d66" translate="yes" xml:space="preserve">
          <source>What about read-write mode? You should probably pretend it doesn't exist, because opening text files in read-write mode is unlikely to do what you would like. See &lt;a href=&quot;perlfaq5&quot;&gt;perlfaq5&lt;/a&gt; for details.</source>
          <target state="translated">읽기-쓰기 모드는 어떻습니까? 텍스트 파일을 읽기 / 쓰기 모드로 여는 것이 원하는 작업을 수행 할 가능성이 없기 때문에 존재하지 않는 척해야합니다. 자세한 내용은 &lt;a href=&quot;perlfaq5&quot;&gt;perlfaq5&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a98ea247bf23a0f2706e40c287b52d50377a4b2f" translate="yes" xml:space="preserve">
          <source>What about the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; pragma?</source>
          <target state="translated">무엇에 대한 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; 프라그?</target>
        </trans-unit>
        <trans-unit id="b08e1e06d029706420aa4cf6848aa2370810866c" translate="yes" xml:space="preserve">
          <source>What about the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; pragma?</source>
          <target state="translated">[정보] 무엇 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; 프라그?</target>
        </trans-unit>
        <trans-unit id="3887d9c889fae85aa71ceab4eb1a53b1a8af8aa5" translate="yes" xml:space="preserve">
          <source>What about the use bytes pragma?</source>
          <target state="translated">사용 바이트 pragma는 어떻습니까?</target>
        </trans-unit>
        <trans-unit id="77d5d80251afa9ef6da60c5e5fbcd215435339d8" translate="yes" xml:space="preserve">
          <source>What about the use encoding pragma?</source>
          <target state="translated">사용 인코딩 pragma는 어떻습니까?</target>
        </trans-unit>
        <trans-unit id="20f362258fa45c702309bd2513e61621aa1951d0" translate="yes" xml:space="preserve">
          <source>What are &lt;code&gt;decode_utf8&lt;/code&gt; and &lt;code&gt;encode_utf8&lt;/code&gt; ?</source>
          <target state="translated">&lt;code&gt;decode_utf8&lt;/code&gt; 과 &lt;code&gt;encode_utf8&lt;/code&gt; 은 무엇입니까 ?</target>
        </trans-unit>
        <trans-unit id="f5cae90cb4f341d083e0d8337510fe30e0b15640" translate="yes" xml:space="preserve">
          <source>What are Perl 4, Perl 5, or Perl 6?</source>
          <target state="translated">Perl 4, Perl 5 또는 Perl 6은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="01965e32414f80a123a1d37d107d508fa4c75578" translate="yes" xml:space="preserve">
          <source>What are all these $@%&amp;amp;* punctuation signs, and how do I know when to use them?</source>
          <target state="translated">이 $ @ % &amp;amp; * 문장 부호는 무엇이며 언제 사용해야하는지 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="11092e508878fe9b88c670c816521fca7c847f2f" translate="yes" xml:space="preserve">
          <source>What are decode_utf8 and encode_utf8?</source>
          <target state="translated">decode_utf8과 encode_utf8은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="0a2a28ac7fb746402e9baa692599b97fb2da048e" translate="yes" xml:space="preserve">
          <source>What can you do with a reference once you have it? It's a scalar value, and we've seen that you can store it as a scalar and get it back again just like any scalar. There are just two more ways to use it:</source>
          <target state="translated">참조가 있으면 무엇을 할 수 있습니까? 스칼라 값이므로 스칼라로 저장하고 스칼라처럼 다시 가져올 수 있음을 알았습니다. 그것을 사용하는 두 가지 방법이 더 있습니다 :</target>
        </trans-unit>
        <trans-unit id="36be343f96dfd613d8c5cf587823d859ba4e947b" translate="yes" xml:space="preserve">
          <source>What character encodings does Perl support?</source>
          <target state="translated">Perl은 어떤 문자 인코딩을 지원합니까?</target>
        </trans-unit>
        <trans-unit id="d6aa1873fd68eba0f41fb53a3f8a2033690a4a51" translate="yes" xml:space="preserve">
          <source>What do you really want to know? If you merely want to know if one of your filehandles is connected to a terminal, you can try the &lt;code&gt;-t&lt;/code&gt; file test:</source>
          <target state="translated">정말로 무엇을 알고 싶습니까? 파일 핸들 중 하나가 터미널에 연결되어 있는지 여부 만 알고 싶다면 &lt;code&gt;-t&lt;/code&gt; 파일 테스트를 시도하십시오 .</target>
        </trans-unit>
        <trans-unit id="1c337f8d590673be03d6eb277fa1a70849d518ac" translate="yes" xml:space="preserve">
          <source>What do you think &lt;code&gt;$x&lt;/code&gt; will be? The answer, unfortunately, is</source>
          <target state="translated">당신은 &lt;code&gt;$x&lt;/code&gt; 가 무엇이라고 생각 합니까? 불행히도 그 대답은</target>
        </trans-unit>
        <trans-unit id="72e224b443b5da69c66ac0a14f3f8175aa612a15" translate="yes" xml:space="preserve">
          <source>What does &quot;Bareword 'DB_File' not allowed&quot; mean?</source>
          <target state="translated">&quot;Bareword 'DB_File'not allowed&quot;는 무엇을 의미합니까?</target>
        </trans-unit>
        <trans-unit id="d0af16451ebfa2bdedb9044267c2bc5c148972de" translate="yes" xml:space="preserve">
          <source>What does &quot;Invalid Argument&quot; mean?</source>
          <target state="translated">&quot;잘못된 인수&quot;는 무엇을 의미합니까?</target>
        </trans-unit>
        <trans-unit id="f0a7abc8d37e669509493f3435ed1f9575fda404" translate="yes" xml:space="preserve">
          <source>What does &quot;bad interpreter&quot; mean?</source>
          <target state="translated">&quot;나쁜 통역사&quot;는 무엇을 의미합니까?</target>
        </trans-unit>
        <trans-unit id="5e47776a0ddea1129634daa43d411c09b05f88dc" translate="yes" xml:space="preserve">
          <source>What does it mean that regexes are greedy? How can I get around it?</source>
          <target state="translated">정규 표현식이 탐욕 스럽다는 것은 무엇을 의미합니까? 어떻게 해결할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="fad85491a61b1ab9b17396e45b64b419ab4c8e77" translate="yes" xml:space="preserve">
          <source>What does this mean for regexps? Well, regexp users don't need to know much about Perl's internal representation of strings. But they do need to know 1) how to represent Unicode characters in a regexp and 2) that a matching operation will treat the string to be searched as a sequence of characters, not bytes. The answer to 1) is that Unicode characters greater than &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(255)&lt;/a&gt;&lt;/code&gt; are represented using the &lt;code&gt;\x{&lt;a href=&quot;functions/hex&quot;&gt;hex&lt;/a&gt;}&lt;/code&gt; notation, because \x hex (without curly braces) doesn't go further than 255. (Starting in Perl 5.14, if you're an octal fan, you can also use &lt;code&gt;\o{&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;}&lt;/code&gt; .)</source>
          <target state="translated">정규 표현식에 이것이 무엇을 의미합니까? 정규 표현식 사용자는 Perl의 내부 문자열 표현에 대해 많이 알 필요가 없습니다. 그러나 그들은 1) 정규 표현식에서 유니 코드 문자를 표현하는 방법과 2) 일치하는 작업이 문자열이 바이트가 아닌 일련의 문자로 처리된다는 것을 알아야합니다. 1)에 대한 대답은 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(255)&lt;/a&gt;&lt;/code&gt; 보다 큰 유니 코드 문자 는 &lt;code&gt;\x{&lt;a href=&quot;functions/hex&quot;&gt;hex&lt;/a&gt;}&lt;/code&gt; 표기법을 사용하여 표현 된다는 것입니다 . 왜냐하면 중괄호없이 \ x hex는 255를 넘지 않기 때문입니다 (Perl 5.14에서 시작) 8 진 팬이라면 &lt;code&gt;\o{&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;}&lt;/code&gt; 사용할 수도 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="0d60263af797b45d08166a1e2276365e53b9c7d0" translate="yes" xml:space="preserve">
          <source>What exact layers are in this default stack depends on a lot of things: your operating system, Perl version, Perl compile time configuration, and Perl runtime configuration. See &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;, &lt;a href=&quot;perlrun#PERLIO&quot;&gt;PERLIO in perlrun&lt;/a&gt;, and &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; for more information.</source>
          <target state="translated">이 기본 스택에있는 정확한 계층은 운영 체제, Perl 버전, Perl 컴파일 시간 구성 및 Perl 런타임 구성 등 많은 요소에 따라 다릅니다. 참조 &lt;a href=&quot;perlio&quot;&gt;은 PerlIO&lt;/a&gt; , &lt;a href=&quot;perlrun#PERLIO&quot;&gt;perlrun에서은 PerlIO을&lt;/a&gt; 하고, &lt;a href=&quot;open&quot;&gt;개방형&lt;/a&gt; 더 많은 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07854a74e069ff620decff4308e92c81d6bd8098" translate="yes" xml:space="preserve">
          <source>What follows are the more advanced, less used, or sometimes esoteric capabilities of Perl regexps. In Part 2, we will assume you are comfortable with the basics and concentrate on the advanced features.</source>
          <target state="translated">다음은 Perl 정규식의 고급 기능, 덜 사용 된 기능 또는 난해한 기능입니다. Part 2에서는 기본 사항에 익숙하고 고급 기능에 집중한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="565ee5d3831c954154cf4129999eb2ce193f0752" translate="yes" xml:space="preserve">
          <source>What follows is a detailed guide through these steps.</source>
          <target state="translated">다음은이 단계를 통한 자세한 안내서입니다.</target>
        </trans-unit>
        <trans-unit id="75d7e12868bcb8f2565578748be73375fac12333" translate="yes" xml:space="preserve">
          <source>What follows is a statement about artistic control, defined as the ability of authors of packages to guide the future of their code and maintain control over their work. It is a recognition that authors should have control over their work, and that it is a responsibility of the rest of the Perl community to ensure that they retain this control. It is an attempt to document the standards to which we, as Perl developers, intend to hold ourselves. It is an attempt to write down rough guidelines about the respect we owe each other as Perl developers.</source>
          <target state="translated">다음은 패키지 제작자가 코드의 미래를 인도하고 작업에 대한 통제력을 유지할 수있는 능력으로 정의 된 예술적 통제에 대한 진술입니다. 저자가 자신의 작업을 통제해야한다는 것은 인정이며,이 통제를 유지하는 것은 Perl 커뮤니티의 나머지 책임입니다. 이는 Perl 개발자로서 우리가 보유하고자하는 표준을 문서화하려는 시도입니다. 우리가 Perl 개발자로서 서로에게 빚진 존중에 대한 대략적인 지침을 작성하려는 시도입니다.</target>
        </trans-unit>
        <trans-unit id="374a8e110bb4c1d9c752734c71a27f6e3e497ea6" translate="yes" xml:space="preserve">
          <source>What follows is subject to change RSN.</source>
          <target state="translated">다음은 RSN 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24917de591e0d7708ee26a13cd3362afc4f6c7c4" translate="yes" xml:space="preserve">
          <source>What formats output as a form feed. The default is &lt;code&gt;\f&lt;/code&gt; .</source>
          <target state="translated">양식 피드로 출력되는 형식 기본값은 &lt;code&gt;\f&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d479059298a571f524af929b6aea396ec65a05e6" translate="yes" xml:space="preserve">
          <source>What gets returned depends on several factors:</source>
          <target state="translated">반환되는 내용은 몇 가지 요소에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="8722b12ceccd8e92d99a716a04b297746411e5f8" translate="yes" xml:space="preserve">
          <source>What good is &lt;code&gt;\G&lt;/code&gt; in a regular expression?</source>
          <target state="translated">정규 표현식에서 &lt;code&gt;\G&lt;/code&gt; 는 무엇입니까 ?</target>
        </trans-unit>
        <trans-unit id="2f0a90d9f77866c3233e1aef1cc7a9560c6ec0c3" translate="yes" xml:space="preserve">
          <source>What good is \G in a regular expression?</source>
          <target state="translated">정규 표현식에서 \ G는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="ebf8dc71994cee4560964d904824ac92b27fed19" translate="yes" xml:space="preserve">
          <source>What happens if I add or remove keys from a hash while iterating over it?</source>
          <target state="translated">반복하는 동안 해시에서 키를 추가하거나 제거하면 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="5b6c83c5563cf3fe722575d6dd30278f0a9d68bc" translate="yes" xml:space="preserve">
          <source>What has gone on?</source>
          <target state="translated">무슨 일이야?</target>
        </trans-unit>
        <trans-unit id="148ce7ffb164566545434b0feef660c7bee4a489" translate="yes" xml:space="preserve">
          <source>What has happened here?</source>
          <target state="translated">여기서 무슨 일이 있었습니까?</target>
        </trans-unit>
        <trans-unit id="21eec199e3d296f021d3cdb05af5afb550abb23b" translate="yes" xml:space="preserve">
          <source>What has happened is that &lt;code&gt;fred&lt;/code&gt; accesses the &lt;code&gt;@_&lt;/code&gt; array which belongs to &lt;code&gt;joe&lt;/code&gt; .</source>
          <target state="translated">무슨 일이 있었는지 &lt;code&gt;fred&lt;/code&gt; 는 &lt;code&gt;joe&lt;/code&gt; 에 속하는 &lt;code&gt;@_&lt;/code&gt; 배열에 액세스합니다 .</target>
        </trans-unit>
        <trans-unit id="1061def72c9d3f6d8d9699c831f84918bba3a0be" translate="yes" xml:space="preserve">
          <source>What if I don't decode?</source>
          <target state="translated">디코딩하지 않으면 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="edc0c9ac4aa8c7b7a3fb61b68506b87d3c69f4bc" translate="yes" xml:space="preserve">
          <source>What if I don't encode?</source>
          <target state="translated">인코딩하지 않으면 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="0ddebc8779b4a58623bcc03eec19b9fd5bdcc57a" translate="yes" xml:space="preserve">
          <source>What if I don't know which encoding was used?</source>
          <target state="translated">어떤 인코딩이 사용되었는지 모르면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="b012d213b447ce5a8b3e4b308232eb1a6c342960" translate="yes" xml:space="preserve">
          <source>What if my question isn't answered in the FAQ?</source>
          <target state="translated">FAQ에 내 질문에 대한 답변이 없으면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="30310a64f6e6f73114ef8ff5955e14d7deb5a4c5" translate="yes" xml:space="preserve">
          <source>What if the interface provided by the C callback doesn't contain a parameter which allows the file handle to Perl subroutine mapping? Say in the asynchronous i/o package, the callback function gets passed only the &lt;code&gt;buffer&lt;/code&gt; parameter like this</source>
          <target state="translated">C 콜백이 제공하는 인터페이스에 파일 핸들을 Perl 서브 루틴 맵핑에 허용하는 매개 변수가 없으면 어떻게됩니까? 비동기 I / O 패키지에서 콜백 함수는 다음 과 같은 &lt;code&gt;buffer&lt;/code&gt; 매개 변수 만 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="f9002d28fd7ee52f5e73c33c74a403efd3585ddf" translate="yes" xml:space="preserve">
          <source>What import does</source>
          <target state="translated">수입품</target>
        </trans-unit>
        <trans-unit id="9281510e66c9b036bf0f2b1f98689d5dbd410309" translate="yes" xml:space="preserve">
          <source>What is &quot;the UTF8 flag&quot;?</source>
          <target state="translated">&quot;UTF8 플래그&quot;는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="48776d293c1cf7b50ee10897815e6e1c09782388" translate="yes" xml:space="preserve">
          <source>What is /o really for?</source>
          <target state="translated">/ o 란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="f799c97279ef39d3426ad309ad7dfc5a7d36fff1" translate="yes" xml:space="preserve">
          <source>What is &lt;code&gt;/o&lt;/code&gt; really for?</source>
          <target state="translated">&lt;code&gt;/o&lt;/code&gt; 란 무엇입니까 ?</target>
        </trans-unit>
        <trans-unit id="4da6343eb07811de611e2143a23a9e42def6f17c" translate="yes" xml:space="preserve">
          <source>What is C3?</source>
          <target state="translated">C3 란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="bda040c2e08659bcff6001c6dcad6149b2b71af9" translate="yes" xml:space="preserve">
          <source>What is Perl 6?</source>
          <target state="translated">Perl 6이란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="90e6903f9207d6b5637de9d9ec259575b1877362" translate="yes" xml:space="preserve">
          <source>What is Perl?</source>
          <target state="translated">펄이란?</target>
        </trans-unit>
        <trans-unit id="79dc15d896921a5be3532940c7478220c26d76f5" translate="yes" xml:space="preserve">
          <source>What is Plack and PSGI?</source>
          <target state="translated">Plack과 PSGI는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="387b2d5d4628ca2a97a160cf17017d26f2363e65" translate="yes" xml:space="preserve">
          <source>What is a &quot;wide character&quot;?</source>
          <target state="translated">&quot;와이드 캐릭터&quot;는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="6c07c0817bd40c0602c40f4eb163a577c33eb9e2" translate="yes" xml:space="preserve">
          <source>What is a 'record'? By default, the meaning is the same as for the &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; operator: It's a string terminated by &lt;code&gt;$/&lt;/code&gt; , which is probably &lt;code&gt;&quot;\n&quot;&lt;/code&gt; . (Minor exception: on DOS and Win32 systems, a 'record' is a string terminated by &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt; .) You may change the definition of &quot;record&quot; by supplying the &lt;code&gt;recsep&lt;/code&gt; option in the &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call:</source>
          <target state="translated">'레코드'란 무엇입니까? 기본적으로, 그 의미는 &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; 연산자 와 동일합니다 : &lt;code&gt;$/&lt;/code&gt; 끝나는 문자열 입니다. 아마도 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 입니다. (사소한 예외 : DOS 및 Win32 시스템에서 'record'는 &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt; 끝나는 문자열 입니다.) &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call 에 &lt;code&gt;recsep&lt;/code&gt; 옵션 을 제공하여 &quot;record&quot;의 정의를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="41a841a9e9e59dbc901dca478a52731689558d70" translate="yes" xml:space="preserve">
          <source>What is a DBM Filter?</source>
          <target state="translated">DBM 필터 란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="75ea94c254fb7320b80e8d79c658d169412a3588" translate="yes" xml:space="preserve">
          <source>What is a JAPH?</source>
          <target state="translated">JAPH 란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="8e7e75800308f6339899e8db69308ae93f0337df" translate="yes" xml:space="preserve">
          <source>What is a regular expression engine?</source>
          <target state="translated">정규식 엔진이란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="e7e08c44504e895661b69ab0d094008da5741e55" translate="yes" xml:space="preserve">
          <source>What is a regular expression? A regular expression is simply a string that describes a pattern. Patterns are in common use these days; examples are the patterns typed into a search engine to find web pages and the patterns used to list files in a directory, e.g., &lt;code&gt;ls *.txt&lt;/code&gt; or &lt;code&gt;dir *.*&lt;/code&gt;. In Perl, the patterns described by regular expressions are used to search strings, extract desired parts of strings, and to do search and replace operations.</source>
          <target state="translated">정규식이란 무엇입니까? 정규식은 단순히 패턴을 설명하는 문자열입니다. 요즘 패턴은 일반적으로 사용됩니다. 예는 &lt;code&gt;ls *.txt&lt;/code&gt; 또는 &lt;code&gt;dir *.*&lt;/code&gt; 와 같이 웹 페이지를 찾기 위해 검색 엔진에 입력 된 패턴과 디렉토리에 파일을 나열하는 데 사용되는 패턴 입니다. Perl에서 정규식으로 설명 된 패턴은 문자열을 검색하고 원하는 문자열 부분을 추출하며 검색 및 바꾸기 작업을 수행하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fc1f1924f0cab71521b063802ea721cd9de2bf43" translate="yes" xml:space="preserve">
          <source>What is an &quot;IV&quot;?</source>
          <target state="translated">&quot;IV&quot;는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="8de138e681884a542d6a632e3d45af8060ecf685" translate="yes" xml:space="preserve">
          <source>What is meant here is unclear, as the &lt;code&gt;\N{...}&lt;/code&gt; escape is a sequence of code points, so this is made an error.</source>
          <target state="translated">여기서 의미하는 것은 &lt;code&gt;\N{...}&lt;/code&gt; 이스케이프가 일련의 코드 포인트이므로 명확하지 않으므로 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7e4d744a0a34b3ed6f2bacfcf8917df2728b341f" translate="yes" xml:space="preserve">
          <source>What is much worse, some DLLs change the floating point flags when in _DLLInitTerm() (e.g.,</source>
          <target state="translated">더 나쁜 것은, 일부 DLL은 _DLLInitTerm ()에있을 때 부동 소수점 플래그를 변경하는 것입니다 (예 :</target>
        </trans-unit>
        <trans-unit id="b80f71784676643cac72b04d16a86ddd2aad93c3" translate="yes" xml:space="preserve">
          <source>What is perl.com? Perl Mongers? pm.org? perl.org? cpan.org?</source>
          <target state="translated">Perl.com은 무엇입니까? 펄 몽 거스? pm.org? perl.org? cpan.org?</target>
        </trans-unit>
        <trans-unit id="b4511cf9900e620f3e5c53ed90d05dd1b6347288" translate="yes" xml:space="preserve">
          <source>What is socket.ph and where do I get it?</source>
          <target state="translated">Socket.ph 란 무엇이며 어디서 구할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="466ca1293cf697f510f855a869e855e56cd9f9c1" translate="yes" xml:space="preserve">
          <source>What is the difference between &quot;state&quot; subs and &quot;my&quot; subs? Each time that execution enters a block when &quot;my&quot; subs are declared, a new copy of each sub is created. &quot;State&quot; subroutines persist from one execution of the containing block to the next.</source>
          <target state="translated">&quot;state&quot;서브와 &quot;my&quot;서브의 차이점은 무엇입니까? &quot;my&quot;서브가 선언 될 때 실행이 블록에 들어갈 때마다 각 서브의 새 사본이 작성됩니다. &quot;상태&quot;서브 루틴은 포함 블록의 한 실행에서 다음 블록까지 지속됩니다.</target>
        </trans-unit>
        <trans-unit id="fc949184376f42b77d53568413143ee5107891ea" translate="yes" xml:space="preserve">
          <source>What is the difference between $array[1] and @array[1]?</source>
          <target state="translated">$ array [1]와 @array [1]의 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="e5e94a34863c5b06b0902ba29af6bbdd60a89b26" translate="yes" xml:space="preserve">
          <source>What is the difference between :encoding and :utf8?</source>
          <target state="translated">: encoding과 : utf8의 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="87b2e888c908f6842e557ad8d646535f8dd07500" translate="yes" xml:space="preserve">
          <source>What is the difference between &lt;code&gt;:encoding&lt;/code&gt; and &lt;code&gt;:utf8&lt;/code&gt; ?</source>
          <target state="translated">&lt;code&gt;:encoding&lt;/code&gt; 과 &lt;code&gt;:utf8&lt;/code&gt; 의 차이점은 무엇입니까 ?</target>
        </trans-unit>
        <trans-unit id="bdd9348a87a0e037c9116062611c030ca4d85da9" translate="yes" xml:space="preserve">
          <source>What is the difference between a list and an array?</source>
          <target state="translated">리스트와 배열의 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="aa2dc660c0cced5d46caea2cf443fe5e368244c8" translate="yes" xml:space="preserve">
          <source>What is this Perl statement all about? &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; is a simple double-quoted string. &lt;code&gt;World&lt;/code&gt; is the regular expression and the &lt;code&gt;//&lt;/code&gt; enclosing &lt;code&gt;/World/&lt;/code&gt; tells Perl to search a string for a match. The operator &lt;code&gt;=~&lt;/code&gt; associates the string with the regexp match and produces a true value if the regexp matched, or false if the regexp did not match. In our case, &lt;code&gt;World&lt;/code&gt; matches the second word in &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; , so the expression is true. Expressions like this are useful in conditionals:</source>
          <target state="translated">이 펄 진술은 무엇에 관한 것입니까? &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; 는 간단한 큰 따옴표로 묶인 문자열입니다. &lt;code&gt;World&lt;/code&gt; 는 정규식이며 &lt;code&gt;//&lt;/code&gt; 둘러싸는 &lt;code&gt;/World/&lt;/code&gt; 일치하는 문자열을 검색 할 펄을 알려줍니다. 연산자 &lt;code&gt;=~&lt;/code&gt; 는 문자열을 정규식 일치와 연결하고 정규식이 일치하면 true를, 정규식이 일치하지 않으면 false를 생성합니다. 이 경우 &lt;code&gt;World&lt;/code&gt; 는 &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; 의 두 번째 단어와 일치 하므로 표현이 참입니다. 이와 같은 표현식은 조건부에서 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c9fb4cb8e09b50cfb90602035114712466d59042" translate="yes" xml:space="preserve">
          <source>What is variable suicide and how can I prevent it?</source>
          <target state="translated">가변 자살이란 무엇이며 어떻게 방지 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="49ac75fc20864efd20e6c484dddbafd73db6a2e3" translate="yes" xml:space="preserve">
          <source>What is your favorite pager program?</source>
          <target state="translated">가장 좋아하는 호출기 프로그램은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="fd63f60b8b6a48f0264ba03539d262e0388b66e2" translate="yes" xml:space="preserve">
          <source>What is your favorite shell?</source>
          <target state="translated">가장 좋아하는 껍질은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="f41b525bca416a73d68432b879e12cd6ce5cae2d" translate="yes" xml:space="preserve">
          <source>What kind of threads are Perl threads?</source>
          <target state="translated">Perl 스레드는 어떤 종류의 스레드입니까?</target>
        </trans-unit>
        <trans-unit id="523c42f572591f0bfb9eb624031ecf0ded9f0a2a" translate="yes" xml:space="preserve">
          <source>What library to use?</source>
          <target state="translated">어떤 라이브러리를 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="c9dcfd1a76d749e07495e332956ce4a77d52e8a9" translate="yes" xml:space="preserve">
          <source>What machines support Perl? Where do I get it?</source>
          <target state="translated">Perl을 지원하는 머신은 무엇입니까? 어디서 구할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="602afa592af7887a3bffb104fc775a95a31125b0" translate="yes" xml:space="preserve">
          <source>What mailing lists are there for Perl?</source>
          <target state="translated">Perl에는 어떤 메일 링리스트가 있습니까?</target>
        </trans-unit>
        <trans-unit id="4862bb3e93457f890d9e122c5362daa5b89c1284" translate="yes" xml:space="preserve">
          <source>What makes a method special is</source>
          <target state="translated">메소드를 특별하게 만드는 것은</target>
        </trans-unit>
        <trans-unit id="c65301b41224a5b616b4c8a04b46b840cdda0ef5" translate="yes" xml:space="preserve">
          <source>What makes all of this important is that the Exporter module uses glob aliasing as the import/export mechanism. Whether or not you can properly localize a variable that has been exported from a module depends on how it was exported:</source>
          <target state="translated">이 모든 것을 중요한 것은 Exporter 모듈이 glob aliasing을 import / export 메커니즘으로 사용한다는 것입니다. 모듈에서 내 보낸 변수를 올바르게 현지화 할 수 있는지 여부는 내 보낸 방법에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="8fb5a283f17d0d098d1490569f3aaeb90f52254c" translate="yes" xml:space="preserve">
          <source>What makes for a good patch?</source>
          <target state="translated">좋은 패치를 만드는 것은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="486e1e8fa6072821d31ad344e76845b470464a6d" translate="yes" xml:space="preserve">
          <source>What makes this pass interesting for perl developers is that some optimization may be performed on this pass. This is optimization by so-called &quot;check routines&quot;. The correspondence between node names and corresponding check routines is described in</source>
          <target state="translated">이 패스를 펄 개발자에게 흥미롭게 만드는 것은이 패스에서 일부 최적화가 수행 될 수 있다는 것입니다. 이것은 소위 &quot;체크 루틴&quot;에 의한 최적화입니다. 노드 이름과 해당 점검 루틴 간의 대응은</target>
        </trans-unit>
        <trans-unit id="7c3d71cb8c06e618edc314c89194f61b595a4c29" translate="yes" xml:space="preserve">
          <source>What modules and extensions are available for Perl? What is CPAN?</source>
          <target state="translated">Perl에 어떤 모듈과 확장이 있습니까? CPAN이란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="709f8e1c07fc1fe28e0f229bb8ce88d468c08c8e" translate="yes" xml:space="preserve">
          <source>What modules shipped with versions of perl</source>
          <target state="translated">Perl 버전과 함께 제공되는 모듈</target>
        </trans-unit>
        <trans-unit id="d5f3978619a4438d900606a19c92b7d1f8afc742" translate="yes" xml:space="preserve">
          <source>What regop is next?</source>
          <target state="translated">다음은 어떤 레 포프입니까?</target>
        </trans-unit>
        <trans-unit id="88176d2562c5c584253c31b2148c8703789870d4" translate="yes" xml:space="preserve">
          <source>What seems a successful strategy is the combination of &lt;code&gt;reload
cpan&lt;/code&gt; and the debugging switches. Add a new debug statement while running in the shell and then issue a &lt;code&gt;reload cpan&lt;/code&gt; and see the new debugging messages immediately without losing the current context.</source>
          <target state="translated">성공적인 전략은 &lt;code&gt;reload cpan&lt;/code&gt; 과 디버깅 스위치 의 조합입니다 . 셸에서 실행하는 동안 새 디버그 문을 추가 한 다음 &lt;code&gt;reload cpan&lt;/code&gt; 하고 현재 컨텍스트를 잃지 않고 즉시 새 디버깅 메시지를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="494e70de221fde56713efc23ab1ca24064c718dc" translate="yes" xml:space="preserve">
          <source>What should I make into a module?</source>
          <target state="translated">모듈로 무엇을 만들어야합니까?</target>
        </trans-unit>
        <trans-unit id="0e5fb1910c7b0867ac71d8402069e7fbfc90bc05" translate="yes" xml:space="preserve">
          <source>What some helper &lt;b&gt;process&lt;/b&gt; did to transform the incoming data into a form more suitable for the current process. Often done with an incoming &lt;b&gt;pipe&lt;/b&gt;. See also &lt;b&gt;C preprocessor&lt;/b&gt;.</source>
          <target state="translated">들어오는 데이터를 현재 프로세스에 더 적합한 형식으로 변환하기 위해 일부 도우미 &lt;b&gt;프로세스&lt;/b&gt; 가 수행 한 작업 종종 들어오는 &lt;b&gt;파이프로&lt;/b&gt; 수행됩니다 . &lt;b&gt;C 전 처리기&lt;/b&gt; 참조&lt;b&gt;&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="05edee69ab0b091485f39a349759f585c24e0340" translate="yes" xml:space="preserve">
          <source>What the program or function returns, if successful. This section can be omitted for programs whose precise exit codes aren't important, provided they return 0 on success and non-zero on failure as is standard. It should always be present for functions. For modules, it may be useful to summarize return values from the module interface here, or it may be more useful to discuss return values separately in the documentation of each function or method the module provides.</source>
          <target state="translated">성공한 경우 프로그램 또는 함수가 반환하는 것 정확한 종료 코드가 중요하지 않은 프로그램의 경우이 섹션을 생략 할 수 있습니다. 표준에 따라 성공하면 0을, 실패하면 0이 아닌 값을 반환합니다. 항상 기능을 위해 존재해야합니다. 모듈의 경우 여기에서 모듈 인터페이스의 리턴 값을 요약하는 것이 유용하거나 모듈이 제공하는 각 기능 또는 메소드의 문서에서 리턴 값을 별도로 논의하는 것이 더 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b11685dda194db5e13d9f10a2284151cb724112f" translate="yes" xml:space="preserve">
          <source>What this does is creates a new binary op, and feeds it a number of variables. The variables refer to the tokens: &lt;code&gt;$1&lt;/code&gt; is the first token in the input, &lt;code&gt;$2&lt;/code&gt; the second, and so on - think regular expression backreferences. &lt;code&gt;$$&lt;/code&gt; is the op returned from this reduction. So, we call &lt;code&gt;newBINOP&lt;/code&gt; to create a new binary operator. The first parameter to &lt;code&gt;newBINOP&lt;/code&gt; , a function in</source>
          <target state="translated">이것이하는 일은 새로운 바이너리 op를 만들고 많은 변수를 공급하는 것입니다. 변수는 토큰을 참조합니다. &lt;code&gt;$1&lt;/code&gt; 은 입력의 첫 번째 토큰이고 &lt;code&gt;$2&lt;/code&gt; 는 두 번째 토큰입니다 . 정규식 역 참조를 생각하십시오. &lt;code&gt;$$&lt;/code&gt; 는이 축소에서 반환 된 op입니다. 그래서 새로운 바이너리 연산자를 만들기 위해 &lt;code&gt;newBINOP&lt;/code&gt; 를 호출 합니다. &lt;code&gt;newBINOP&lt;/code&gt; 의 첫 번째 매개 변수 는</target>
        </trans-unit>
        <trans-unit id="4cc8ecd0e95182504b6e5e23619c1654db502160" translate="yes" xml:space="preserve">
          <source>What this means is that if you have data written by Storable 1.x running on perl 5.6.0 or 5.6.1 configured with 64 bit integers on Unix or Linux then by default this Storable will refuse to read it, giving the error</source>
          <target state="translated">이는 Perl 5.6.0 또는 5.6.1에서 실행되는 Storable 1.x로 작성된 데이터가 Unix 또는 Linux에서 64 비트 정수로 구성된 경우 기본적으로이 Storable이이를 읽지 않고 오류를 발생시키는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c1074e9471d381d1e3fa377b4baeab5a37484773" translate="yes" xml:space="preserve">
          <source>What this means is that unless the &lt;code&gt;/a&lt;/code&gt; modifier is in effect &lt;code&gt;\d&lt;/code&gt; not only matches the digits '0' - '9', but also Arabic, Devanagari, and digits from other languages. This may cause some confusion, and some security issues.</source>
          <target state="translated">이는 &lt;code&gt;/a&lt;/code&gt; 수정자가 적용 되지 않는 한 &lt;code&gt;\d&lt;/code&gt; 되지 않는 한 는 숫자 '0'- '9'뿐만 아니라 아랍어, Devanagari 및 다른 언어의 숫자와도 일치합니다. 이로 인해 약간의 혼란과 보안 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b90ef1b55a5f8c0ad6415f98413e6a092c07a530" translate="yes" xml:space="preserve">
          <source>What to put after &quot;1/crontab&quot; in the URL. This option is not set by default.</source>
          <target state="translated">URL에서 &quot;1 / crontab&quot;다음에 넣을 내용 이 옵션은 기본적으로 설정되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="616a4166af25f3f615ff259d316398355eca1fd7" translate="yes" xml:space="preserve">
          <source>What to put after &quot;Foo%3a%3aBar&quot; in the URL. This option is not set by default.</source>
          <target state="translated">URL에서 &quot;Foo % 3a % 3aBar&quot;다음에 넣을 내용. 이 옵션은 기본적으로 설정되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="774021bac19bdf5e083a7ddf41b218a869e89eea" translate="yes" xml:space="preserve">
          <source>What to put before and after the title in the head. The values should already be &amp;amp;-escaped.</source>
          <target state="translated">제목의 앞뒤에 넣을 내용. 값은 이미 이스케이프되어야합니다.</target>
        </trans-unit>
        <trans-unit id="46d727439e117340febafb43135cffaac5ab87fa" translate="yes" xml:space="preserve">
          <source>What utilities shipped with versions of perl</source>
          <target state="translated">Perl 버전과 함께 제공된 유틸리티</target>
        </trans-unit>
        <trans-unit id="79f6137e22ba58dcead1d29483955dc880eaf485" translate="yes" xml:space="preserve">
          <source>What was in this chunk of memory? Numbers, characters, or a mixture of both? Assuming that we're on a computer where ASCII (or some similar) encoding is used: hexadecimal values in the range &lt;code&gt;0x40&lt;/code&gt; - &lt;code&gt;0x5A&lt;/code&gt; indicate an uppercase letter, and &lt;code&gt;0x20&lt;/code&gt; encodes a space. So we might assume it is a piece of text, which some are able to read like a tabloid; but others will have to get hold of an ASCII table and relive that firstgrader feeling. Not caring too much about which way to read this, we note that &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; with the template code &lt;code&gt;H&lt;/code&gt; converts the contents of a sequence of bytes into the customary hexadecimal notation. Since &quot;a sequence of&quot; is a pretty vague indication of quantity, &lt;code&gt;H&lt;/code&gt; has been defined to convert just a single hexadecimal digit unless it is followed by a repeat count. An asterisk for the repeat count means to use whatever remains.</source>
          <target state="translated">이 기억 덩어리에 무엇이 있었습니까? 숫자, 문자 또는 둘의 혼합? 우리는 ASCII (또는 유사) 인코딩을 사용하는 컴퓨터를 사용하는 것을 가정하면 16 진수 값을 범위 &lt;code&gt;0x40&lt;/code&gt; - &lt;code&gt;0x5A&lt;/code&gt; 는 대문자 및 표시 &lt;code&gt;0x20&lt;/code&gt; 인코딩 공간을. 그래서 우리는 그것이 타블로이드처럼 읽을 수있는 텍스트 조각이라고 가정 할 수 있습니다. 그러나 다른 사람들은 ASCII 테이블을 잡고 그 첫 학년의 느낌을 재현해야 할 것입니다. 템플릿 코드 &lt;code&gt;H&lt;/code&gt; 로 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 을 풀면 바이트 시퀀스의 내용이 일반적인 16 진 표기법으로 변환 된다는 점에 유의하십시오 . &quot;시퀀스&quot;는 수량을 나타내는 아주 모호한 표시이므로 &lt;code&gt;H&lt;/code&gt; 반복 카운트가 뒤 따르지 않는 한 16 진 숫자 하나만 변환하도록 정의되었습니다. 반복 횟수 별표는 남아있는 모든 것을 사용하는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="16a26aa5328e43e90f045fe86149fb674a158916" translate="yes" xml:space="preserve">
          <source>What we actually need to do is expand the width of the fields. The &lt;code&gt;A&lt;/code&gt; format pads any non-existent characters with spaces, so we can use the additional spaces to line up our fields, like this:</source>
          <target state="translated">실제로해야 할 일은 필드의 너비를 넓히는 것입니다. &lt;code&gt;A&lt;/code&gt; 형식 패드, 그래서 우리는 다음과 같이 우리의 필드를 줄을 추가 공간을 사용할 수있는 공간이있는 모든 존재 자 :</target>
        </trans-unit>
        <trans-unit id="0c37b176ea3009646e0be80ec6a53f25b8ff9dcd" translate="yes" xml:space="preserve">
          <source>What we have described so far is the single form of the &lt;code&gt;\p{...}&lt;/code&gt; character classes. There is also a compound form which you may run into. These look like &lt;code&gt;\p{name=value}&lt;/code&gt; or &lt;code&gt;\p{name:value}&lt;/code&gt; (the equals sign and colon can be used interchangeably). These are more general than the single form, and in fact most of the single forms are just Perl-defined shortcuts for common compound forms. For example, the script examples in the previous paragraph could be written equivalently as &lt;code&gt;\p{Script=Latin}&lt;/code&gt; , &lt;code&gt;\p{Script:Greek}&lt;/code&gt; , &lt;code&gt;\p{script=katakana}&lt;/code&gt; , and &lt;code&gt;\P{script=balinese}&lt;/code&gt; (case is irrelevant between the &lt;code&gt;{}&lt;/code&gt; braces). You may never have to use the compound forms, but sometimes it is necessary, and their use can make your code easier to understand.</source>
          <target state="translated">지금까지 설명한 것은 &lt;code&gt;\p{...}&lt;/code&gt; 문자 클래스 의 단일 형식입니다 . 또한 복합 형태가있을 수 있습니다. 이는 &lt;code&gt;\p{name=value}&lt;/code&gt; 또는 &lt;code&gt;\p{name:value}&lt;/code&gt; 와 같습니다 (등호와 콜론은 서로 바꿔 사용할 수 있습니다). 이들은 단일 형태보다 더 일반적이며 실제로 대부분의 단일 형태는 일반적인 복합 형태에 대한 Perl 정의 단축키입니다. 예를 들어, 이전 단락의 스크립트 예제는 &lt;code&gt;\p{Script=Latin}&lt;/code&gt; , &lt;code&gt;\p{Script:Greek}&lt;/code&gt; , &lt;code&gt;\p{script=katakana}&lt;/code&gt; 및 &lt;code&gt;\P{script=balinese}&lt;/code&gt; 와 동일하게 작성할 수 있습니다 (대소 문자는 사이에 관계없는 &lt;code&gt;{}&lt;/code&gt; 바지 멜빵). 복합 형식을 사용할 필요는 없지만 때로는 필요할 수 있으며,이를 사용하면 코드를 이해하기 쉽게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3384939add5296135f386c16a3d5a3c4d7477676" translate="yes" xml:space="preserve">
          <source>What you are told when someone thinks you should Read The Fine Manual.</source>
          <target state="translated">누군가가 당신이 훌륭한 매뉴얼을 읽어야한다고 생각할 때 들리는 것.</target>
        </trans-unit>
        <trans-unit id="5da1aaeac7913632bcb1c91e0e40a9b8f5b306d1" translate="yes" xml:space="preserve">
          <source>What you can do is calculate the MD5 checksum of the UTF-8 representation of such strings. This is achieved by filtering the string through encode_utf8() function:</source>
          <target state="translated">당신이 할 수있는 일은 그러한 문자열의 UTF-8 표현의 MD5 체크섬을 계산하는 것입니다. encode_utf8 () 함수를 통해 문자열을 필터링하면됩니다.</target>
        </trans-unit>
        <trans-unit id="bdac7845b72b0a0aaba866c488e59de83492ce2f" translate="yes" xml:space="preserve">
          <source>What you get from your ancestors, genetically or otherwise. If you happen to be a &lt;b&gt;class&lt;/b&gt;, your ancestors are called &lt;b&gt;base classes&lt;/b&gt; and your descendants are called &lt;b&gt;derived classes&lt;/b&gt;. See &lt;b&gt;single inheritance&lt;/b&gt; and &lt;b&gt;multiple inheritance&lt;/b&gt;.</source>
          <target state="translated">유 전적으로 또는 다른 방식으로 조상으로부터 얻는 것. 만약 당신이 &lt;b&gt;수업이&lt;/b&gt; 된다면, 당신의 조상을 &lt;b&gt;기본 수업&lt;/b&gt; 이라고 하고, 당신의 후손을 &lt;b&gt;파생 수업&lt;/b&gt; 이라고 합니다. &lt;b&gt;단일 상속&lt;/b&gt; 및 &lt;b&gt;다중 상속을&lt;/b&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2c06f68d01c975c0659982cd1d1ea555fe3696b9" translate="yes" xml:space="preserve">
          <source>What you get when you do &lt;code&gt;Perl++&lt;/code&gt; twice. Doing it only once will curl your hair. You have to increment it eight times to shampoo your hair. Lather, rinse, iterate.</source>
          <target state="translated">&lt;code&gt;Perl++&lt;/code&gt; 두 번 할 때 얻는 것 . 한 번만하면 머리카락이 말립니다. 샴푸를하려면 8 번 증량해야합니다. 오히려 헹구고 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="d8dd19339629eae0964d65277b9af39d2d940ac8" translate="yes" xml:space="preserve">
          <source>What you probably want instead is this:</source>
          <target state="translated">아마 당신이 원하는 것은 이것입니다 :</target>
        </trans-unit>
        <trans-unit id="b04bf6a0eeeb74b4ebb74c0ffdfd7f57764ab34f" translate="yes" xml:space="preserve">
          <source>What you want to use instead is:</source>
          <target state="translated">대신 사용하고 싶은 것은 :</target>
        </trans-unit>
        <trans-unit id="f3ca9a26fe44a59f17183be2ef23ecb124cf272f" translate="yes" xml:space="preserve">
          <source>What's MakeMaker?</source>
          <target state="translated">MakeMaker 란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="42464d9de4a99557d583081f2fb3c257e19a8cfc" translate="yes" xml:space="preserve">
          <source>What's Really Stored in an SV?</source>
          <target state="translated">SV에 실제로 저장된 것은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="8f84a94f1018dae65b2467147ba94f01d14ea50b" translate="yes" xml:space="preserve">
          <source>What's a closure?</source>
          <target state="translated">폐쇄 란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="a80aec1f19639cbbb28c71d9ddfac9f28b371cff" translate="yes" xml:space="preserve">
          <source>What's an extension?</source>
          <target state="translated">확장이란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="96c69ba1e09918b49d4e34120c9bbb2d0968449e" translate="yes" xml:space="preserve">
          <source>What's in Plan 9 Perl</source>
          <target state="translated">Plan 9 Perl의 내용</target>
        </trans-unit>
        <trans-unit id="e9c4131b2629bb86dafeed8bcd2c9f6a25583f3a" translate="yes" xml:space="preserve">
          <source>What's in a name?</source>
          <target state="translated">이름이 뭐야?</target>
        </trans-unit>
        <trans-unit id="5131dc0eec6cff59e581098235ddc4625176b69a" translate="yes" xml:space="preserve">
          <source>What's new here?</source>
          <target state="translated">새로운 소식은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="22ab29c1c9e23b6be4d152ca0fbe8d1fd5003e73" translate="yes" xml:space="preserve">
          <source>What's not in Plan 9 Perl</source>
          <target state="translated">Plan 9 Perl에없는 것</target>
        </trans-unit>
        <trans-unit id="5d2b08ade1fd6cb20cb499440eecabb1a859edc0" translate="yes" xml:space="preserve">
          <source>What's that &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;? Well, the arguments to a subroutine are available to us as a special array called &lt;code&gt;@_&lt;/code&gt; (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for more on that). The default argument to the &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; function just happens to be &lt;code&gt;@_&lt;/code&gt; . So &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $logmessage = &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;;&lt;/code&gt; shifts the first item off the list of arguments and assigns it to &lt;code&gt;$logmessage&lt;/code&gt; .</source>
          <target state="translated">그 &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 무엇입니까 ? 자, 서브 루틴에 대한 인수는 우리에게 &lt;code&gt;@_&lt;/code&gt; 이라는 특수 배열로 사용할 수 있습니다 (자세한 내용은 &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; 참조 ). &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 함수 의 기본 인수는 &lt;code&gt;@_&lt;/code&gt; 입니다. 그래서 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $logmessage = &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;;&lt;/code&gt; 첫 번째 항목을 인수 목록에서 벗어나 &lt;code&gt;$logmessage&lt;/code&gt; 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="46db4fba6102cb384fdb3af284b14f9799d7a634" translate="yes" xml:space="preserve">
          <source>What's the difference between &quot;delete&quot; and &quot;undef&quot; with hashes?</source>
          <target state="translated">해시와 함께 &quot;삭제&quot;와 &quot;언더 프&quot;의 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="efcfc0c915c5ced8aa18fe665d7a6bf921317ac3" translate="yes" xml:space="preserve">
          <source>What's the difference between &quot;perl&quot; and &quot;Perl&quot;?</source>
          <target state="translated">&quot;perl&quot;과 &quot;Perl&quot;의 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="63f076d778aa21d0e84626f4c5e0c5b8d663503c" translate="yes" xml:space="preserve">
          <source>What's the difference between &lt;code&gt;UTF-8&lt;/code&gt; and &lt;code&gt;utf8&lt;/code&gt; ?</source>
          <target state="translated">&lt;code&gt;UTF-8&lt;/code&gt; 과 &lt;code&gt;utf8&lt;/code&gt; 의 차이점은 무엇입니까 ?</target>
        </trans-unit>
        <trans-unit id="9c1cf1781cda10277aefd4a7483c6c07d76809d8" translate="yes" xml:space="preserve">
          <source>What's the difference between UTF-8 and utf8?</source>
          <target state="translated">UTF-8과 utf8의 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="1a32eae97c19fcd8cd7ae50ba5b1fb91847cfda9" translate="yes" xml:space="preserve">
          <source>What's the difference between calling a function as &amp;amp;foo and foo()?</source>
          <target state="translated">&amp;amp; foo와 foo ()로 함수를 호출하는 것의 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="def2247288e4f5204ba55472b4461e996492e2e7" translate="yes" xml:space="preserve">
          <source>What's the difference between deep and shallow binding?</source>
          <target state="translated">딥 바인딩과 얕은 바인딩의 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="95fdb9749f45655e65a25dc015c0a84e8ebabe59" translate="yes" xml:space="preserve">
          <source>What's the difference between dynamic and lexical (static) scoping? Between local() and my()?</source>
          <target state="translated">다이나믹 (정적) 범위 지정의 차이점은 무엇입니까? local ()과 my () 사이?</target>
        </trans-unit>
        <trans-unit id="83bcf34d32fd45bb7e4990d1041e30347690cdee" translate="yes" xml:space="preserve">
          <source>What's the difference between require and use?</source>
          <target state="translated">요구와 사용의 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="e20e3ec3698a540277cd6005030f3f2eae027cdc" translate="yes" xml:space="preserve">
          <source>What's wrong with *-w* and $^W</source>
          <target state="translated">* -w * 및 $ ^ W의 문제점</target>
        </trans-unit>
        <trans-unit id="d8abb891068053380c8e2c57ccfc03bd7f1c3bec" translate="yes" xml:space="preserve">
          <source>What's wrong with &lt;b&gt;-w&lt;/b&gt; and &lt;code&gt;$^W&lt;/code&gt;</source>
          <target state="translated">&lt;b&gt;-w&lt;/b&gt; 및 &lt;code&gt;$^W&lt;/code&gt; 의 문제점</target>
        </trans-unit>
        <trans-unit id="86c8915176784b924b124a7df71bcedbc4d5aeac" translate="yes" xml:space="preserve">
          <source>What's wrong with always quoting &quot;$vars&quot;?</source>
          <target state="translated">항상 &quot;$ vars&quot;를 인용하면 무엇이 문제입니까?</target>
        </trans-unit>
        <trans-unit id="a6b6f35263a6c409ef4d9ea90bf4d23520808808" translate="yes" xml:space="preserve">
          <source>What's wrong with using backticks in a void context?</source>
          <target state="translated">빈 공간에서 백틱을 사용하면 무엇이 문제입니까?</target>
        </trans-unit>
        <trans-unit id="15b450eb4383c04ae9890e63ad467617d37b687c" translate="yes" xml:space="preserve">
          <source>What's wrong with using grep in a void context?</source>
          <target state="translated">빈 공간에서 grep을 사용하면 무엇이 문제입니까?</target>
        </trans-unit>
        <trans-unit id="48dabfbbabfdd23fd6a91f1e79b5b5393e8fc727" translate="yes" xml:space="preserve">
          <source>What's wrong?</source>
          <target state="translated">뭐가 문제 야?</target>
        </trans-unit>
        <trans-unit id="81f7ea2721e1db165495605d1bf1128fca1fe7a9" translate="yes" xml:space="preserve">
          <source>Whatever a reference refers to, which may or may not have a name. Common types of referents include scalars, arrays, hashes, and subroutines.</source>
          <target state="translated">참조가 무엇이든, 이름이 있거나 없을 수 있습니다. 일반적인 참조 유형에는 스칼라, 배열, 해시 및 서브 루틴이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="088ce6907b9c85d16edc0ae58b2aca12ddc17aac" translate="yes" xml:space="preserve">
          <source>Whatever happens in the RE engine might be better discussed in &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;, but for the sake of continuity, we shall do so here.</source>
          <target state="translated">RE 엔진에서 일어나는 일이 &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; 에서 더 잘 논의 될 수 있지만, 연속성을 위해 여기에서 그렇게 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="f153d99158c54cb43c1d3fc8596ddbfe423f08fe" translate="yes" xml:space="preserve">
          <source>Whatever you want to do with a reference, &lt;b&gt;Use Rule 1&lt;/b&gt; tells you how to do it. You just write the Perl code that you would have written for doing the same thing to a regular array or hash, and then replace the array or hash name with &lt;code&gt;{$reference}&lt;/code&gt; . &quot;How do I loop over an array when all I have is a reference?&quot; Well, to loop over an array, you would write</source>
          <target state="translated">참조로 수행하려는 작업이 무엇이든 관계없이 &lt;b&gt;규칙 1 사용에&lt;/b&gt; 참조 방법이 나와 있습니다. 일반 배열 또는 해시와 동일한 작업을 수행하기 위해 작성한 Perl 코드를 작성한 다음 배열 또는 해시 이름을 &lt;code&gt;{$reference}&lt;/code&gt; 로 바꾸십시오 . &quot;내가 가진 모든 것이 참조 일 때 어떻게 배열을 반복합니까?&quot; 배열을 반복하려면 다음과 같이 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="769bb19e615b7f8e2809e5882e2d05a18f57a531" translate="yes" xml:space="preserve">
          <source>When</source>
          <target state="translated">When</target>
        </trans-unit>
        <trans-unit id="7ae3880ea71f58f5dbf3834e6e0d70053eb70246" translate="yes" xml:space="preserve">
          <source>When &quot;&lt;code&gt;::&lt;/code&gt; &quot; is not in the name, &quot;&lt;code&gt;Encode::&lt;/code&gt; &quot; is assumed.</source>
          <target state="translated">&quot; &lt;code&gt;::&lt;/code&gt; &quot;가 이름에 없으면 &quot; &lt;code&gt;Encode::&lt;/code&gt; &quot;로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="a89c66deca9575739eac57be484648de00b11290" translate="yes" xml:space="preserve">
          <source>When $data is present, sets the instance data to $data and returns the object itself. Otherwise, the current instance data is returned.</source>
          <target state="translated">$ data가 있으면 인스턴스 데이터를 $ data로 설정하고 객체 자체를 반환합니다. 그렇지 않으면 현재 인스턴스 데이터가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5ea5db67e72bdcabd78dcc6373fac87d452cfae7" translate="yes" xml:space="preserve">
          <source>When $encoding is omitted, it defaults to utf8 if $data is already in utf8 or &quot;&quot; (empty string) otherwise.</source>
          <target state="translated">$ encoding을 생략하면 $ data가 이미 utf8에 있거나 그렇지 않으면 &quot;&quot;(빈 문자열) 인 경우 기본값은 utf8입니다.</target>
        </trans-unit>
        <trans-unit id="3a255f10977ad0e9fd4eef99c75ca5b6bedb2369" translate="yes" xml:space="preserve">
          <source>When $encoding is present, sets the instance encoding to $encoding and returns the object itself. Otherwise, the current instance encoding is returned.</source>
          <target state="translated">$ encoding이 있으면 인스턴스 인코딩을 $ encoding으로 설정하고 객체 자체를 반환합니다. 그렇지 않으면 현재 인스턴스 인코딩이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c1731c29e738a553728a82585755466ae75d0743" translate="yes" xml:space="preserve">
          <source>When $walker is called, it traverses the subroutines supplied when it was created, and renders them using the current style. You can change the style afterwards in several different ways:</source>
          <target state="translated">$ walker는 호출 될 때 제공된 서브 루틴을 순회하고 현재 스타일을 사용하여 렌더링합니다. 나중에 여러 가지 방법으로 스타일을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34501938bea4725e00e5d23af26af9e9de4937a2" translate="yes" xml:space="preserve">
          <source>When 'make clean' or similar is run, the $(FIRST_MAKEFILE) will be backed up at this location.</source>
          <target state="translated">'make clean'또는 이와 유사한 것을 실행하면 $ (FIRST_MAKEFILE)이이 위치에 백업됩니다.</target>
        </trans-unit>
        <trans-unit id="9a46234156e6749e9bc38b78f59bb3969925d8bf" translate="yes" xml:space="preserve">
          <source>When &lt;b&gt;--compat-version&lt;/b&gt; (&lt;b&gt;-b&lt;/b&gt;) is present the generated tests will use &lt;code&gt;Test::More&lt;/code&gt; rather than &lt;code&gt;Test&lt;/code&gt; which is the default for versions before 5.6.2. &lt;code&gt;Test::More&lt;/code&gt; will be added to PREREQ_PM in the generated &lt;code&gt;Makefile.PL&lt;/code&gt; .</source>
          <target state="translated">때 &lt;b&gt;--compat-버전&lt;/b&gt; ( &lt;b&gt;-b&lt;/b&gt; ) 존재 생성 된 테스트는 사용 &lt;code&gt;Test::More&lt;/code&gt; 보다는 &lt;code&gt;Test&lt;/code&gt; 5.6.2 이전 버전의 기본이된다. &lt;code&gt;Test::More&lt;/code&gt; 가 생성 된 &lt;code&gt;Makefile.PL&lt;/code&gt; 의 PREREQ_PM에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="98323433c84745d96d2f69c24c5375707e53e818" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$/&lt;/code&gt; is set to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, when &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; is in scalar context (i.e., file slurp mode), and when an empty file is read, it returns &lt;code&gt;''&lt;/code&gt; the first time, followed by &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; subsequently.</source>
          <target state="translated">때 &lt;code&gt;$/&lt;/code&gt; 로 설정 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 때, &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 스칼라 문맥 (즉, 파일 소리내어 먹는다 모드), 그리고 빈 파일을 읽을 때, 그것은 반환 &lt;code&gt;''&lt;/code&gt; 다음에 처음으로, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 이후를.</target>
        </trans-unit>
        <trans-unit id="d7865066f4690dc076b5908415bb1b4ea7d2066d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$/&lt;/code&gt; is set to &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, when &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; is in scalar context (i.e., file slurp mode), and when an empty file is read, it returns &lt;code&gt;''&lt;/code&gt; the first time, followed by &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; subsequently.</source>
          <target state="translated">때 &lt;code&gt;$/&lt;/code&gt; 로 설정 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 때, &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 스칼라 문맥 (즉, 파일 소리내어 먹는다 모드), 그리고 빈 파일을 읽을 때, 그것은 반환 &lt;code&gt;''&lt;/code&gt; 다음에 처음으로, &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 이후를.</target>
        </trans-unit>
        <trans-unit id="75765cbe47d6e2730ecd17d719657c6826993abb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$input_filename_or_reference&lt;/code&gt; maps to multiple compressed files/buffers and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a single file/buffer, after uncompression &lt;code&gt;$output_filename_or_reference&lt;/code&gt; will contain a concatenation of all the uncompressed data from each of the input files/buffers.</source>
          <target state="translated">때 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 여러 압축 파일 / 버퍼 매핑하고 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 비 압축 후 단일 파일 / 버퍼이다 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 입력 파일 / 버퍼의 각에서 모든 비 압축 데이터의 연결이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ead5ec1ebcf9002ff366c3f4b5ecf105bcef3b1c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$input_filename_or_reference&lt;/code&gt; maps to multiple files/buffers and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a single file/buffer the input files/buffers will be stored in &lt;code&gt;$output_filename_or_reference&lt;/code&gt; as a concatenated series of compressed data streams.</source>
          <target state="translated">경우 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 여러 파일 / 버퍼 및 매핑 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 단일 파일 / 입력 파일을 버퍼 / 버퍼에 저장한다 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 압축 데이터 스트림으로 연결된 일련.</target>
        </trans-unit>
        <trans-unit id="42c11e18ef09b7c84100ba9f7d909d637366a78e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$input_filename_or_reference&lt;/code&gt; maps to multiple files/buffers and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a single file/buffer the input files/buffers will each be stored in &lt;code&gt;$output_filename_or_reference&lt;/code&gt; as a distinct entry.</source>
          <target state="translated">때 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 여러 파일 / 버퍼 매핑하고 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 단일 파일 / 입력 파일을 버퍼 / 버퍼는 각각에 저장됩니다 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 별개의 항목으로.</target>
        </trans-unit>
        <trans-unit id="161359b9eacea931dac1aa6e52278dc1eae64067" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is an fileglob string, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; must also be a fileglob string. Anything else is an error.</source>
          <target state="translated">때 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; fileglob 문자열입니다, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 또한 fileglob 문자열이어야합니다. 다른 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="2506bf0aaa0a66933521706c1367d6dcef56da1b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;${^UNICODE}&lt;/code&gt; (available starting in v5.8.2) exists and is non-zero, these options will be completely ignored. See &lt;a href=&quot;perlvar#%24%7b%5eUNICODE%7d&quot;&gt;${^UNICODE} in perlvar&lt;/a&gt; and &lt;a href=&quot;perlrun#-C-%5bnumber%2flist%5d&quot;&gt;-C in perlrun&lt;/a&gt; for details.</source>
          <target state="translated">때 &lt;code&gt;${^UNICODE}&lt;/code&gt; (v5.8.2에서 사용할 수있는 시작)이 존재하고 제로가 아닌,이 옵션은 완전히 무시됩니다. 자세한 내용 &lt;a href=&quot;perlvar#%24%7b%5eUNICODE%7d&quot;&gt;은 perlvar의 $ {^ UNICODE}&lt;/a&gt; 및 &lt;a href=&quot;perlrun#-C-%5bnumber%2flist%5d&quot;&gt;perlrun의 -C&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b7dd1602a2fa020d33fb149e95e48b61aba92e31" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;'s arguments are executed indirectly by the shell, results and return codes are subject to its quirks. See &lt;a href=&quot;perlop#%60STRING%60&quot;&gt;`STRING` in perlop&lt;/a&gt; and &lt;a href=&quot;#exec&quot;&gt;exec&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 의 인수가 쉘에 의해 간접적으로 실행될 때 , 결과 및 리턴 코드는 단점이 있습니다. 자세한 내용 &lt;a href=&quot;perlop#%60STRING%60&quot;&gt;은 perlop&lt;/a&gt; 및 &lt;a href=&quot;#exec&quot;&gt;exec의 &lt;/a&gt;`STRING`을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="ce37de4fd1569bb63f53c7c4c16cdb716157400b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (but not &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ) is in effect, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt; LIST&lt;/code&gt; sorts LIST according to the current collation locale. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="translated">때 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (하지만 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ) 효과에, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt; LIST&lt;/code&gt; 현재 정렬 로케일에 따라 목록을 정렬합니다. &lt;a href=&quot;perllocale&quot;&gt;perllocale을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c4b89dec84fb05fc282a0e80acf7739b8c5833a7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/flags'&lt;/code&gt; is specified, the given flags are automatically added to every regular expression till the end of the lexical scope.</source>
          <target state="translated">때 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/flags'&lt;/code&gt; 지정은 주어진 플래그는 자동으로 어휘 범위의 끝까지 모든 정규 표현식에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="826f4d022e4908a4bde930341263c135e67935f4" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; is in effect, perl emits debugging messages when compiling and using regular expressions. The output is the same as that obtained by running a &lt;code&gt;-DDEBUGGING&lt;/code&gt; -enabled perl interpreter with the &lt;b&gt;-Dr&lt;/b&gt; switch. It may be quite voluminous depending on the complexity of the match. Using &lt;code&gt;debugcolor&lt;/code&gt; instead of &lt;code&gt;debug&lt;/code&gt; enables a form of output that can be used to get a colorful display on terminals that understand termcap color sequences. Set &lt;code&gt;$ENV{PERL_RE_TC}&lt;/code&gt; to a comma-separated list of &lt;code&gt;termcap&lt;/code&gt; properties to use for highlighting strings on/off, pre-point part on/off. See &lt;a href=&quot;perldebug#Debugging-Regular-Expressions&quot;&gt;Debugging Regular Expressions in perldebug&lt;/a&gt; for additional info.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하면 perl은 정규식을 컴파일하고 사용할 때 디버깅 메시지를 생성합니다. 출력은 실행하여 얻어진 것과 동일하다 &lt;code&gt;-DDEBUGGING&lt;/code&gt; 으로 사용이 가능한 펄 인터프리터 &lt;b&gt;- 닥터의&lt;/b&gt; 스위치. 경기의 복잡성에 따라 상당히 방대한 수 있습니다. &lt;code&gt;debug&lt;/code&gt; 대신 &lt;code&gt;debugcolor&lt;/code&gt; 를 사용하면 터미널 캡 컬러 시퀀스를 이해하는 터미널에서 화려한 디스플레이를 얻는 데 사용할 수있는 출력 형식을 사용할 수 있습니다. 세트 &lt;code&gt;$ENV{PERL_RE_TC}&lt;/code&gt; 의 쉼표로 구분 된 목록에 &lt;code&gt;termcap&lt;/code&gt; 특성에 / 문자열을 강조 표시 사용에 온 / 오프 파트 포인트 사전합니다. 추가 정보를 참조하십시오 .&lt;a href=&quot;perldebug#Debugging-Regular-Expressions&quot;&gt;perldebug에서 정규 표현식 디버깅을&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6c428ad9961e409888285c5019a1884325617653" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval'&lt;/code&gt; is in effect, a regexp is allowed to contain &lt;code&gt;(?{ ... })&lt;/code&gt; zero-width assertions and &lt;code&gt;(??{ ... })&lt;/code&gt; postponed subexpressions that are derived from variable interpolation, rather than appearing literally within the regexp. That is normally disallowed, since it is a potential security risk. Note that this pragma is ignored when the regular expression is obtained from tainted data, i.e. evaluation is always disallowed with tainted regular expressions. See &lt;a href=&quot;perlre#(%3f%7b-code-%7d)&quot;&gt;(?{ code }) in perlre&lt;/a&gt; and &lt;a href=&quot;perlre#(%3f%3f%7b-code-%7d)&quot;&gt;(??{ code }) in perlre&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval'&lt;/code&gt; 적용하는 정규 표현식을 포함 할 수 있습니다 &lt;code&gt;(?{ ... })&lt;/code&gt; 제로 폭 주장하고 &lt;code&gt;(??{ ... })&lt;/code&gt; 연기 변수 보간에서 유래 표현식보다는가 게재 말 그대로 정규 표현식 내에서. 잠재적 인 보안 위험이 있으므로 일반적으로 허용되지 않습니다. 이 pragma는 오염 된 데이터에서 정규식을 가져올 때 무시됩니다. 즉, 오염 된 정규식에서는 평가가 항상 허용되지 않습니다. 참조 &lt;a href=&quot;perlre#(%3f%7b-code-%7d)&quot;&gt;(? {코드}) perlre에서&lt;/a&gt; 와 &lt;a href=&quot;perlre#(%3f%3f%7b-code-%7d)&quot;&gt;perlre에 (?? {코드})를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c489bf5f6075f7a85a4147bc159e1965fa8ad2cd" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'strict'&lt;/code&gt; is in effect, stricter checks are applied than otherwise when compiling regular expressions patterns. These may cause more warnings to be raised than otherwise, and more things to be fatal instead of just warnings. The purpose of this is to find and report at compile time some things, which may be legal, but have a reasonable possibility of not being the programmer's actual intent. This automatically turns on the &lt;code&gt;&quot;regexp&quot;&lt;/code&gt; warnings category (if not already on) within its scope.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'strict'&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하면 정규식 패턴을 컴파일 할 때보 다 엄격한 검사가 적용됩니다. 이로 인해 다른 것보다 많은 경고가 발생하고 경고 만하는 것이 아니라 치명적일 수 있습니다. 이것의 목적은 컴파일 타임에 합법적이지만 프로그래머의 실제 의도가 아닐 수있는 합리적인 가능성을 발견하고보고하는 것입니다. 그러면 해당 범위 내 에서 &lt;code&gt;&quot;regexp&quot;&lt;/code&gt; 경고 범주 가 자동으로 켜집니다 (아직없는 경우).</target>
        </trans-unit>
        <trans-unit id="057f6216fa3faf81b159095b26d348ad7b06bd25" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'taint'&lt;/code&gt; is in effect, and a tainted string is the target of a regexp, the regexp memories (or values returned by the m// operator in list context) are tainted. This feature is useful when regexp operations on tainted data aren't meant to extract safe substrings, but to perform other transformations.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'taint'&lt;/code&gt; 유효하고, 오염 된 문자열이 정규 표현식의 대상 (리스트 문맥에서 m // 조작자 반품 값) 정규식 메모리는 오염되어있다. 이 기능은 오염 된 데이터에 대한 정규 표현식 작업이 안전한 하위 문자열을 추출하기위한 것이 아니라 다른 변환을 수행 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d35b2d737154679691874d190272f87d34f67d6b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;'s arguments are executed indirectly by the shell, results and return codes are subject to its quirks. See &lt;a href=&quot;../perlop#%60STRING%60&quot;&gt;`STRING` in perlop&lt;/a&gt; and &lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 의 인수가 쉘에 의해 간접적으로 실행될 때 , 결과 및 리턴 코드는 단점이 있습니다. 자세한 내용 &lt;a href=&quot;../perlop#%60STRING%60&quot;&gt;은 perlop&lt;/a&gt; 및 &lt;a href=&quot;exec&quot;&gt;exec의 &lt;/a&gt;`STRING`을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="d249161b8d76a85447f9bcf8c19ecaa9c4041708" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (but not &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ) is in effect, &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt; LIST&lt;/code&gt; sorts LIST according to the current collation locale. See &lt;a href=&quot;../perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="translated">때 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (하지만 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ) 효과에, &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt; LIST&lt;/code&gt; 현재 정렬 로케일에 따라 목록을 정렬합니다. &lt;a href=&quot;../perllocale&quot;&gt;perllocale을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9cb0ac41f5c76b7790f54d079dd94b8ce0665510" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Append&lt;/code&gt; is specified, and set to true, it will</source>
          <target state="translated">때 &lt;code&gt;Append&lt;/code&gt; 지정하고 true로 설정되어, 그것은 것입니다</target>
        </trans-unit>
        <trans-unit id="74620e73df76b9793a4b5915498c084620ae1197" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;LimitOutout&lt;/code&gt; is not specified &lt;code&gt;$i-&amp;gt;bzinflate&lt;/code&gt; will use as much memory as it takes to write all the uncompressed data it creates by uncompressing the input buffer.</source>
          <target state="translated">경우 &lt;code&gt;LimitOutout&lt;/code&gt; 가 지정되지 &lt;code&gt;$i-&amp;gt;bzinflate&lt;/code&gt; 는 입력 버퍼를 압축 해제하여 모든 그것을 작성하는 압축되지 않은 데이터를 기록하는데 걸리는만큼 메모리로서 사용된다.</target>
        </trans-unit>
        <trans-unit id="476db1003af9ea2b2d5dff0b4d9aae2335796a1b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;LimitOutout&lt;/code&gt; is not specified &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; will use as much memory as it takes to write all the uncompressed data it creates by uncompressing the input buffer.</source>
          <target state="translated">경우 &lt;code&gt;LimitOutout&lt;/code&gt; 가 지정되지 &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; 그것이 입력 버퍼를 압축 해제하여 생성 된 모든 압축 데이터를 기록하는데 걸리는만큼 메모리로서 사용된다.</target>
        </trans-unit>
        <trans-unit id="3a29eb1b7605b447e178aa583e1e3d0b18b3e32a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;LimitOutput&lt;/code&gt; is used the size of the output buffer used will either be the 16k or the amount of memory already allocated to &lt;code&gt;$output&lt;/code&gt; , whichever is larger. Predicting the output size available is tricky, so don't rely on getting an exact output buffer size.</source>
          <target state="translated">&lt;code&gt;LimitOutput&lt;/code&gt; 이 사용 되면 사용 된 출력 버퍼의 크기는 16k 또는 &lt;code&gt;$output&lt;/code&gt; 이미 할당 된 메모리 양 중 더 큰 것입니다. 사용 가능한 출력 크기를 예측하는 것은 까다롭기 때문에 정확한 출력 버퍼 크기를 얻는 데 의존하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="6884e67243b247f9f83c1056f56446e2954b8717" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;LimitOutput&lt;/code&gt; is used the size of the output buffer used will either be the value of the &lt;code&gt;Bufsize&lt;/code&gt; option or the amount of memory already allocated to &lt;code&gt;$output&lt;/code&gt; , whichever is larger. Predicting the output size available is tricky, so don't rely on getting an exact output buffer size.</source>
          <target state="translated">&lt;code&gt;LimitOutput&lt;/code&gt; 이 사용 되면 사용 된 출력 버퍼의 크기는 &lt;code&gt;Bufsize&lt;/code&gt; 옵션 의 값 이거나 &lt;code&gt;$output&lt;/code&gt; 이미 할당 된 메모리 양 중 큰 값입니다. 사용 가능한 출력 크기를 예측하는 것은 까다롭기 때문에 정확한 출력 버퍼 크기를 얻는 데 의존하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="f6c4b51758778b88a3620755cd86e2bac9c6c0e5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; is active (see &lt;a href=&quot;#%24%3f&quot;&gt;$?&lt;/a&gt; below), the native VMS exit status value will have either one of the &lt;code&gt;$!&lt;/code&gt; or &lt;code&gt;$?&lt;/code&gt; or &lt;code&gt;$^E&lt;/code&gt; or the Unix value 255 encoded into it in a way that the effective original value can be decoded by other programs written in C, including Perl and the GNV package. As per the normal non-VMS behavior of &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; if either &lt;code&gt;$!&lt;/code&gt; or &lt;code&gt;$?&lt;/code&gt; are non-zero, one of those values will be encoded into a native VMS status value. If both of the Unix status values are 0, and the &lt;code&gt;$^E&lt;/code&gt; value is set one of ERROR or SEVERE_ERROR severity, then the &lt;code&gt;$^E&lt;/code&gt; value will be used as the exit code as is. If none of the above apply, the Unix value of 255 will be encoded into a native VMS exit status value.</source>
          <target state="translated">&lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; 가 활성화 되면 (아래 &lt;a href=&quot;#%24%3f&quot;&gt;$?&lt;/a&gt; 참조) 기본 VMS 종료 상태 값은 &lt;code&gt;$!&lt;/code&gt; 또는 &lt;code&gt;$?&lt;/code&gt; 또는 Perl 및 GNV 패키지를 포함하여 C로 작성된 다른 프로그램에서 유효 원래 값을 디코딩 할 수있는 방식으로 &lt;code&gt;$^E&lt;/code&gt; 또는 Unix 값 255로 인코딩됩니다. 의 정상적인 비 VMS의 동작에 따라 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 중 하나의 경우 &lt;code&gt;$!&lt;/code&gt; 또는 &lt;code&gt;$?&lt;/code&gt; 0이 아닌 경우 해당 값 중 하나가 기본 VMS 상태 값으로 인코딩됩니다. Unix 상태 값이 모두 0이고 &lt;code&gt;$^E&lt;/code&gt; 값이 ERROR 또는 SEVERE_ERROR 심각도 중 하나 인 경우 &lt;code&gt;$^E&lt;/code&gt; 값은 그대로 종료 코드로 사용됩니다. 위의 어느 것도 적용되지 않으면 Unix 값 255는 기본 VMS 종료 상태 값으로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="edf0ae2377a2b22abb92a09c7cbee6dad38f469d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;S&lt;/code&gt; can match, it is a better match than when only &lt;code&gt;T&lt;/code&gt; can match.</source>
          <target state="translated">때 &lt;code&gt;S&lt;/code&gt; 가 일치시킬 수 있습니다, 그것은 단지 때보다 더 나은 일치 &lt;code&gt;T&lt;/code&gt; 는 일치 할 수는.</target>
        </trans-unit>
        <trans-unit id="5e7bb6aa4bca28bb16c16381fd1ea0fe317f098c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Strict&lt;/code&gt; is disabled the following behaviour will be policed:</source>
          <target state="translated">때 &lt;code&gt;Strict&lt;/code&gt; 사용할 수있는 다음과 같은 동작이 치안을한다 :</target>
        </trans-unit>
        <trans-unit id="792e600779793d69f3a4dfa3dfa3dd30d40ce8a4" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt;= 22, the weights of out-of-range values can be overridden. Though &lt;code&gt;table&lt;/code&gt; or &lt;code&gt;entry&lt;/code&gt; are available for them, out-of-range values are too many.</source>
          <target state="translated">경우 &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt; = 22의 값이 무시 될 수있는 범위를 벗어난의 중량. &lt;code&gt;table&lt;/code&gt; 이나 &lt;code&gt;entry&lt;/code&gt; 을 사용할 수 있지만 범위를 벗어난 값이 너무 많습니다.</target>
        </trans-unit>
        <trans-unit id="a88bdc0c0c759d08c6275afc07854842d8f95efa" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;base&lt;/code&gt; tries to &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; a module, it will not die if it cannot find the module's file, but will die on any other error. After all this, should your base class be empty, containing no symbols, &lt;code&gt;base&lt;/code&gt; will die. This is useful for inheriting from classes in the same file as yourself but where the filename does not match the base module name, like so:</source>
          <target state="translated">&lt;code&gt;base&lt;/code&gt; 가 모듈 을 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 때 , 모듈의 파일을 찾을 수 없으면 죽지 않고 다른 오류로 죽습니다. 이 후 기본 클래스가 비어 있고 기호가 없으면 &lt;code&gt;base&lt;/code&gt; 이 죽습니다. 이것은 자신과 동일한 파일의 클래스에서 상속 할 때 유용하지만 파일 이름이 다음과 같이 기본 모듈 이름과 일치하지 않는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f3f15dbf4bfac8ce422e1183a7c97c2a550a0582" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;follow&lt;/code&gt; or &lt;code&gt;follow_fast&lt;/code&gt; are in effect, there is also a &lt;code&gt;$File::Find::fullname&lt;/code&gt; . The function may set &lt;code&gt;$File::Find::prune&lt;/code&gt; to prune the tree unless &lt;code&gt;bydepth&lt;/code&gt; was specified. Unless &lt;code&gt;follow&lt;/code&gt; or &lt;code&gt;follow_fast&lt;/code&gt; is specified, for compatibility reasons (find.pl, find2perl) there are in addition the following globals available: &lt;code&gt;$File::Find::topdir&lt;/code&gt; , &lt;code&gt;$File::Find::topdev&lt;/code&gt; , &lt;code&gt;$File::Find::topino&lt;/code&gt; , &lt;code&gt;$File::Find::topmode&lt;/code&gt; and &lt;code&gt;$File::Find::topnlink&lt;/code&gt; .</source>
          <target state="translated">때 &lt;code&gt;follow&lt;/code&gt; 또는 &lt;code&gt;follow_fast&lt;/code&gt; 이 적용되고, 또한이 &lt;code&gt;$File::Find::fullname&lt;/code&gt; . 이 함수는 &lt;code&gt;bydepth&lt;/code&gt; 가 지정 되지 않은 경우 &lt;code&gt;$File::Find::prune&lt;/code&gt; 을 설정 하여 트리를 프룬 ( prune) 할 수 있습니다. &lt;code&gt;follow&lt;/code&gt; 또는 &lt;code&gt;follow_fast&lt;/code&gt; 가 지정 되지 않은 경우 호환성 이유로 (find.pl, find2perl) 다음 전역을 사용할 수 있습니다. &lt;code&gt;$File::Find::topdir&lt;/code&gt; , &lt;code&gt;$File::Find::topdev&lt;/code&gt; , &lt;code&gt;$File::Find::topino&lt;/code&gt; , &lt;code&gt;$File::Find::topmode&lt;/code&gt; 및 &lt;code&gt;$File::Find::topnlink&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5c3af0ccfdbd0226b2c1c6a386ea7d1149b898de" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;get_handle&lt;/code&gt; is called with an empty parameter list, magic happens:</source>
          <target state="translated">빈 매개 변수 목록으로 &lt;code&gt;get_handle&lt;/code&gt; 을 호출 하면 마술이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0587cd71d3cd406da1e34d9f0121a501c139389a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;remove_tree&lt;/code&gt; returned from deleting files in a child directory, a check revealed that the parent directory it returned to wasn't the one it started out from. This is considered a sign of malicious activity.</source>
          <target state="translated">하위 디렉토리의 파일 삭제에서 &lt;code&gt;remove_tree&lt;/code&gt; 가 리턴 되면 , 점검 한 상위 디렉토리가 원래 디렉토리가 아닌 것으로 확인되었습니다. 이것은 악의적 인 활동의 표시로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="0abaa039dcd0b20cc37827ce7e9a425281864469" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;share&lt;/code&gt; is used on arrays, hashes, array refs or hash refs, any data they contain will be lost.</source>
          <target state="translated">배열, 해시, 배열 참조 또는 해시 참조에서 &lt;code&gt;share&lt;/code&gt; 를 사용 하면 포함 된 모든 데이터가 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="f072734b6ff55766546071395774e151a8cea193" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;test_test&lt;/code&gt; is called and the output that your tests generate does not match that which you declared, &lt;code&gt;test_test&lt;/code&gt; will print out debug information showing the two conflicting versions. As this output itself is debug information it can be confusing which part of the output is from &lt;code&gt;test_test&lt;/code&gt; and which was the original output from your original tests. Also, it may be hard to spot things like extraneous whitespace at the end of lines that may cause your test to fail even though the output looks similar.</source>
          <target state="translated">때 &lt;code&gt;test_test&lt;/code&gt; 가 호출되고 출력이 테스트를 생성하면 선언하는 것을 일치하지 않음을, &lt;code&gt;test_test&lt;/code&gt; 는 두 개의 충돌 버전을 보여주는 디버그 정보를 인쇄합니다. 이 출력 자체는 디버그 정보이므로 출력의 어느 부분이 &lt;code&gt;test_test&lt;/code&gt; 에서 왔고 어느 부분이 원래 테스트의 원래 출력 인지 혼동 될 수 있습니다 . 또한 출력이 비슷해 보이지만 줄 끝에서 불필요한 공백과 같은 것을 발견하기 어려울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a8ac650ec538c50bdeb4cf6dbd53747bc753f1f" translate="yes" xml:space="preserve">
          <source>When BE or LE is explicitly stated as the name of encoding, BOM is simply treated as a normal character (ZERO WIDTH NO-BREAK SPACE).</source>
          <target state="translated">BE 또는 LE가 인코딩 이름으로 명시 적으로 언급되면 BOM은 단순히 일반 문자 (ZERO WIDTH NO-BREAK SPACE)로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="0fbaed27da231d1d0f199bebcb75bb30dedc0240" translate="yes" xml:space="preserve">
          <source>When BE or LE is omitted during decode(), it checks if BOM is at the beginning of the string; if one is found, the endianness is set to what the BOM says. If no BOM is found, the routine dies.</source>
          <target state="translated">decode () 중에 BE 또는 LE가 생략되면 BOM이 문자열의 시작 부분에 있는지 확인합니다. 하나가 발견되면 엔디안은 BOM이 말하는 것으로 설정됩니다. BOM이 없으면 루틴이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="420dd2e0afe91753dba538ca831997f9f3a56a48" translate="yes" xml:space="preserve">
          <source>When BE or LE is omitted during encode(), it returns a BE-encoded string with BOM prepended. So when you want to encode a whole text file, make sure you encode() the whole text at once, not line by line or each line, not file, will have a BOM prepended.</source>
          <target state="translated">encode () 중에 BE 또는 LE가 생략되면 BOM이 앞에 붙은 BE 인코딩 문자열을 리턴합니다. 따라서 전체 텍스트 파일을 인코딩하려는 경우 전체 텍스트를 한 줄에 한 번에 encode ()하거나 파일이 아닌 각 줄에 BOM이 추가되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="dacba9cd09b7954f0b607de2124d67d55cdeb2ac" translate="yes" xml:space="preserve">
          <source>When CPAN runs, it sets the environment variable PERL5_CPAN_IS_RUNNING to the ID of the running process. It also sets PERL5_CPANPLUS_IS_RUNNING to prevent runaway processes which could happen with older versions of Module::Install.</source>
          <target state="translated">CPAN이 실행될 때 환경 변수 PERL5_CPAN_IS_RUNNING을 실행중인 프로세스의 ID로 설정합니다. 또한 이전 버전의 Module :: Install에서 발생할 수있는 런 어웨이 프로세스를 방지하기 위해 PERL5_CPANPLUS_IS_RUNNING을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="652978d2789dfa7c2e88ae3ead48735cc4a8b7e9" translate="yes" xml:space="preserve">
          <source>When CPAN.pm extends @INC via PERL5LIB, it prints a list of directories added (or a summary of how many directories are added). Choose 'v' to get this message, 'none' to suppress it.</source>
          <target state="translated">CPAN.pm이 PERL5LIB를 통해 @INC를 확장하면 추가 된 디렉토리 목록 (또는 추가 된 디렉토리 수의 요약)을 인쇄합니다. 이 메시지를 받으려면 'v'를 선택하고 메시지를 표시하지 않으려면 '없음'을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="ec2c74f66c6e4b429c5d3bf449f05522f381cd48" translate="yes" xml:space="preserve">
          <source>When CPAN.pm loads a module it needs for some optional feature, it usually reports about module name and version. Choose 'v' to get this message, 'none' to suppress it.</source>
          <target state="translated">CPAN.pm이 일부 선택적 기능에 필요한 모듈을로드하면 일반적으로 모듈 이름 및 버전에 대해보고합니다. 이 메시지를 받으려면 'v'를 선택하고 메시지를 표시하지 않으려면 '없음'을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="a6c2efe210167d6d16736590efab450901a5223c" translate="yes" xml:space="preserve">
          <source>When CPAN.pm uses the tar command, which switch for the verbosity shall be used? Choose 'none' for quiet operation, 'v' for file name listing, 'vv' for full listing.</source>
          <target state="translated">CPAN.pm이 tar 명령을 사용하는 경우, 자세한 표시를 위해 어떤 스위치를 사용해야합니까? 조용한 작동을 위해서는 '없음', 파일 이름 목록은 'v', 전체 목록은 'vv'를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="09926237f4d026fd4275fa85769eac33da9c9434" translate="yes" xml:space="preserve">
          <source>When Configure asks about the extensions, I suggest IO and Fcntl, and if you want database handling then SDBM_File or GDBM_File (you need to install gdbm for this one). If you want to use the POSIX extension (this is the default), make sure that the stack size of your</source>
          <target state="translated">Configure가 확장에 대해 물어볼 때 IO와 Fcntl을 제안하고 데이터베이스 처리를 원할 경우 SDBM_File 또는 GDBM_File (이에 대해 gdbm을 설치해야 함)을 제안합니다. POSIX 확장을 사용하려면 (이것이 기본값 임), 사용자의 스택 크기가</target>
        </trans-unit>
        <trans-unit id="04e0b7cf71399471be99cb867416364c0df9f40e" translate="yes" xml:space="preserve">
          <source>When Democritus gave the word &amp;ldquo;atom&amp;rdquo; to the indivisible bits of matter, he meant literally something that could not be cut:</source>
          <target state="translated">Democritus가 불가분의 물질에&amp;ldquo;원자&amp;rdquo;라는 단어를 썼을 때, 그는 말 그대로자를 수없는 것을 의미했습니다.</target>
        </trans-unit>
        <trans-unit id="bed16fa39ff4d380815a5a95de03029e7764deee" translate="yes" xml:space="preserve">
          <source>When G_KEEPERR is used, any error in the called code will terminate the call as usual, and the error will not propagate beyond the call (as usual for G_EVAL), but it will not go into &lt;code&gt;$@&lt;/code&gt; . Instead the error will be converted into a warning, prefixed with the string &quot;\t(in cleanup)&quot;. This can be disabled using &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'misc'&lt;/code&gt; . If there is no error, &lt;code&gt;$@&lt;/code&gt; will not be cleared.</source>
          <target state="translated">G_KEEPERR을 사용하면 호출 된 코드의 모든 오류가 평소와 같이 호출을 종료하고 오류가 호출을 넘어 전파되지는 않지만 (G_EVAL의 경우와 같이) &lt;code&gt;$@&lt;/code&gt; 로 들어 가지 않습니다 . 대신 오류 앞에 &quot;\ t (in cleanup)&quot;이라는 문자열이 접두어로 경고로 변환됩니다. &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'misc'&lt;/code&gt; 사용 &lt;a href=&quot;functions/no&quot;&gt;하지 않고&lt;/a&gt; 비활성화 할 수 있습니다 . 오류가 없으면 &lt;code&gt;$@&lt;/code&gt; 는 지워지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c6cefe86149d167c60485e01ab068ab4acc1c96d" translate="yes" xml:space="preserve">
          <source>When I install bundles or multiple modules with one command there is too much output to keep track of.</source>
          <target state="translated">하나의 명령으로 번들 또는 여러 모듈을 설치할 때 추적 할 출력이 너무 많습니다.</target>
        </trans-unit>
        <trans-unit id="96aa2dd484c673b89bb47260df9f770fc3e65459" translate="yes" xml:space="preserve">
          <source>When I run CPAN's shell, I get an error message about things in my &lt;code&gt;/etc/inputrc&lt;/code&gt; (or &lt;code&gt;~/.inputrc&lt;/code&gt;) file.</source>
          <target state="translated">CPAN의 쉘을 실행할 때, &lt;code&gt;/etc/inputrc&lt;/code&gt; (또는 &lt;code&gt;~/.inputrc&lt;/code&gt; )에 관한 오류 메시지가 나타납니다. ) 파일 .</target>
        </trans-unit>
        <trans-unit id="6b21be97219bbbb10df79f70e49405f833c3cad4" translate="yes" xml:space="preserve">
          <source>When I tried to run my script, I got this message. What does it mean?</source>
          <target state="translated">스크립트를 실행하려고 할 때이 메시지가 나타납니다. 무슨 뜻인가요?</target>
        </trans-unit>
        <trans-unit id="e4bb48e8ad735dfd3ed959c0444d6089c891d679" translate="yes" xml:space="preserve">
          <source>When I/O, for example &quot;read&quot;, is requested, the request goes from Perl first down the stack using &quot;read&quot; functions of each layer, then at the bottom the input is requested from the operating system services, then the result is returned up the stack, finally being interpreted as Perl data.</source>
          <target state="translated">I / O, 예를 들어 &quot;읽기&quot;가 요청되면 요청은 Perl에서 먼저 각 계층의 &quot;읽기&quot;기능을 사용하여 스택 아래로 내려간 다음 맨 아래에 운영 체제 서비스에서 입력이 요청됩니다. 스택을 반환하고 마침내 Perl 데이터로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="e5e8467b062c382be485cbe69584b5d02adf0299" translate="yes" xml:space="preserve">
          <source>When Memoize needs to check to see if an entry is in the cache already, it will invoke &lt;code&gt;C-&amp;gt;EXISTS(key)&lt;/code&gt; . &lt;code&gt;key&lt;/code&gt; is the normalized function argument. MyExpirePolicy::EXISTS should return 0 if the key is not in the cache, or if it has expired, and 1 if an unexpired value is in the cache. It should</source>
          <target state="translated">Memoize가 항목이 이미 캐시에 있는지 확인해야하는 경우 &lt;code&gt;C-&amp;gt;EXISTS(key)&lt;/code&gt; 호출 합니다. &lt;code&gt;key&lt;/code&gt; 는 정규화 된 함수 인수입니다. 키가 캐시에 없거나 키가 만료 된 경우 MyExpirePolicy :: EXISTS는 0을, 만료되지 않은 값이 캐시에 있으면 1을 반환해야합니다. 그것은해야한다</target>
        </trans-unit>
        <trans-unit id="ebd887c91b9049b8dfb0bd1e032eea2b43f90690" translate="yes" xml:space="preserve">
          <source>When Perl 5.12 or later encounters an ellipsis statement, it parses this without error, but if and when you should actually try to execute it, Perl throws an exception with the text &lt;code&gt;Unimplemented&lt;/code&gt; :</source>
          <target state="translated">Perl 5.12 이상에서 줄임표 문이 발견되면 오류없이이를 구문 분석하지만 실제로 실행하려고하면 Perl 텍스트가 &lt;code&gt;Unimplemented&lt;/code&gt; 텍스트와 함께 예외가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="ab4ce43e1ebabd776abd8a74c5e1d002b8bd8ffe" translate="yes" xml:space="preserve">
          <source>When Perl compiles the regular expression, it treats the parenthesis as the start of a memory match. When it doesn't find the closing parenthesis, it complains:</source>
          <target state="translated">Perl은 정규식을 컴파일 할 때 괄호를 메모리 일치의 시작으로 취급합니다. 닫는 괄호를 찾지 못하면 다음과 같이 불평합니다.</target>
        </trans-unit>
        <trans-unit id="53c411ad4e1523024c43c3f84e8d99bfb2921a55" translate="yes" xml:space="preserve">
          <source>When Perl destroys the object referenced by $netconf it will send the object to the supplied XSUB DESTROY function. Perl cannot determine, and does not care, that this object is a C struct and not a Perl object. In this sense, there is no difference between the object created by the getnetconfigent() XSUB and an object created by a normal Perl subroutine.</source>
          <target state="translated">Perl이 $ netconf에 의해 참조 된 객체를 파기하면 제공된 XSUB DESTROY 함수로 객체를 보냅니다. Perl은이 오브젝트가 Perl 오브젝트가 아닌 C 구조 체인지 판별 할 수없고 상관하지 않습니다. 이런 의미에서 getnetconfigent () XSUB에 의해 작성된 오브젝트와 일반 Perl 서브 루틴에 의해 작성된 오브젝트 사이에는 차이가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e513aa6b4ab015986cab17c857cc3e0082b263e5" translate="yes" xml:space="preserve">
          <source>When Perl exchanges data with an extension, the extension should be able to understand the UTF8 flag and act accordingly. If the extension doesn't recognize that flag, it's likely that the extension will return incorrectly-flagged data.</source>
          <target state="translated">Perl이 확장과 데이터를 교환 할 때 확장은 UTF8 플래그를 이해하고 그에 따라 작동해야합니다. 확장 프로그램이 해당 플래그를 인식하지 못하면 확장 기능이 잘못 플래그 된 데이터를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6f1776d7dcd16bb2da8426867ab48b032eaee97" translate="yes" xml:space="preserve">
          <source>When Perl is built with PERL_IMPLICIT_CONTEXT, extensions that call any functions in the Perl API will need to pass the initial context argument somehow. The kicker is that you will need to write it in such a way that the extension still compiles when Perl hasn't been built with PERL_IMPLICIT_CONTEXT enabled.</source>
          <target state="translated">PERL_IMPLICIT_CONTEXT로 Perl을 빌드 할 때 Perl API에서 함수를 호출하는 확장은 어떻게 든 초기 컨텍스트 인수를 전달해야합니다. 핵심은 PERL_IMPLICIT_CONTEXT를 사용하여 Perl을 빌드하지 않았을 때 확장 프로그램이 여전히 컴파일되는 방식으로 작성해야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f6fb72d35777e36edb4c8c03f40429a73f9b258a" translate="yes" xml:space="preserve">
          <source>When Perl is built without options that set PERL_IMPLICIT_CONTEXT, there is no first argument containing the interpreter's context. The trailing underscore in the pTHX_ macro indicates that the macro expansion needs a comma after the context argument because other arguments follow it. If PERL_IMPLICIT_CONTEXT is not defined, pTHX_ will be ignored, and the subroutine is not prototyped to take the extra argument. The form of the macro without the trailing underscore is used when there are no additional explicit arguments.</source>
          <target state="translated">PERL_IMPLICIT_CONTEXT를 설정하는 옵션없이 Perl을 빌드하면 인터프리터의 컨텍스트를 포함하는 첫 번째 인수가 없습니다. pTHX_ 매크로에서 밑줄은 다른 인수가 뒤에 오므로 매크로 확장에 컨텍스트 인수 뒤에 쉼표가 필요함을 나타냅니다. PERL_IMPLICIT_CONTEXT가 정의되어 있지 않으면 pTHX_는 무시되고 서브 루틴은 추가 인수를 취하도록 프로토 타입되지 않습니다. 밑줄이없는 매크로 형식은 추가 명시 적 인수가 없을 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8079f54267f5c6445383e49837ffc5d08d1d7078" translate="yes" xml:space="preserve">
          <source>When Perl is compiled for a platform, it looks at all of these characters to guess which EBCDIC character set the platform uses, and adapts itself accordingly to that platform. If the platform uses a character set that is not one of the three Perl knows about, Perl will either fail to compile, or mistakenly and silently choose one of the three.</source>
          <target state="translated">Perl이 플랫폼 용으로 컴파일 될 때, 모든 문자를보고 플랫폼이 사용하는 EBCDIC 문자 세트를 추측하고 해당 플랫폼에 따라 자체 조정됩니다. 플랫폼이 Perl이 알고있는 세 가지 중 하나가 아닌 문자 세트를 사용하는 경우 Perl은 컴파일에 실패하거나 실수로 세 가지 중 하나를 자동으로 선택합니다.</target>
        </trans-unit>
        <trans-unit id="80ed2279b39397e0ed205899926800b606fe0a42" translate="yes" xml:space="preserve">
          <source>When Perl is configured to use ithreads, it will use re-entrant library calls in preference to non-re-entrant versions. There is an incompatibility in OpenBSD's &lt;code&gt;getprotobyname_r&lt;/code&gt; and &lt;code&gt;getservbyname_r&lt;/code&gt; function in versions 3.7 and later that will cause a SEGV when called without doing a &lt;code&gt;bzero&lt;/code&gt; on their return structs prior to calling these functions. Current Perl's should handle this problem correctly. Older threaded Perls (5.8.6 or earlier) will run into this problem. If you want to run a threaded Perl on OpenBSD 3.7 or higher, you will need to upgrade to at least Perl 5.8.7.</source>
          <target state="translated">Perl이 ithread를 사용하도록 구성되면 재진입이 아닌 버전보다 재진입 라이브러리 호출을 사용합니다. 버전 3.7 이상 에서 OpenBSD의 &lt;code&gt;getprotobyname_r&lt;/code&gt; 및 &lt;code&gt;getservbyname_r&lt;/code&gt; 함수 에는 호환되지 않으므로 이러한 함수를 호출하기 전에 리턴 구조체 에서 &lt;code&gt;bzero&lt;/code&gt; 를 수행하지 않고 호출 될 때 SEGV가 발생 합니다. 현재 Perl은이 문제를 올바르게 처리해야합니다. 오래된 스레드 Perls (5.8.6 이하)가이 문제에 부딪치게됩니다. OpenBSD 3.7 이상에서 스레드 Perl을 실행하려면 최소한 Perl 5.8.7로 업그레이드해야합니다.</target>
        </trans-unit>
        <trans-unit id="df300d221e04eb6da687f72d9bfb0bebe32d3fc0" translate="yes" xml:space="preserve">
          <source>When Perl is processing &quot;binary data&quot;, the programmer wants Perl to process &quot;sequences of bytes&quot;. This is not a problem for Perl: because a byte has 256 possible values, it easily fits in Perl's much larger &quot;logical character&quot;.</source>
          <target state="translated">Perl이 &quot;이진 데이터&quot;를 처리 할 때 프로그래머는 Perl이 &quot;순차 바이트&quot;를 처리하기를 원합니다. 이것은 Perl에게 문제가되지 않습니다 : 바이트는 256 개의 가능한 값을 가지기 때문에 Perl의 훨씬 더 큰 &quot;논리적 특성&quot;에 쉽게 맞습니다.</target>
        </trans-unit>
        <trans-unit id="cc51149dee007d3915d8fd89443c351da938e4a2" translate="yes" xml:space="preserve">
          <source>When Perl is run in debugging mode, with the &lt;b&gt;-d&lt;/b&gt; switch, this GV contains the SV which holds the name of the sub being debugged. This is the C variable which corresponds to Perl's $DB::sub variable. See &lt;code&gt;PL_DBsingle&lt;/code&gt; .</source>
          <target state="translated">Perl이 &lt;b&gt;-d&lt;/b&gt; 스위치 와 함께 디버깅 모드에서 실행될 때이 GV에는 디버그중인 서브의 이름을 보유하는 SV가 포함됩니다. 이것은 Perl의 $ DB :: sub 변수에 해당하는 C 변수입니다. &lt;code&gt;PL_DBsingle&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3590f13940a356a00f485512d64c10323ed9ae31" translate="yes" xml:space="preserve">
          <source>When Perl is run in debugging mode, with the &lt;b&gt;-d&lt;/b&gt; switch, this SV is a boolean which indicates whether subs are being single-stepped. Single-stepping is automatically turned on after every step. This is the C variable which corresponds to Perl's $DB::single variable. See &lt;code&gt;PL_DBsub&lt;/code&gt; .</source>
          <target state="translated">&lt;b&gt;-d&lt;/b&gt; 스위치를 사용하여 Perl이 디버깅 모드에서 실행될 때이 SV는 부울이 서브 스텝 단일 단계인지 여부를 표시합니다. 모든 단계 후에 단일 스테핑이 자동으로 켜집니다. 이것은 Perl의 $ DB :: single 변수에 해당하는 C 변수입니다. &lt;code&gt;PL_DBsub&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="987fa57f3d6e2d1a009a00d587b9bac8f003a80c" translate="yes" xml:space="preserve">
          <source>When Perl is run with the &lt;b&gt;-Do&lt;/b&gt; switch or its equivalent, overloading induces diagnostic messages.</source>
          <target state="translated">Perl이 &lt;b&gt;-Do&lt;/b&gt; 스위치 또는 이와 동등한 것으로 실행되면 과부하는 진단 메시지를 유발합니다.</target>
        </trans-unit>
        <trans-unit id="31b65aa4a8ccdb59770227d57464bc9d968a6a6c" translate="yes" xml:space="preserve">
          <source>When Perl searches for a method, it caches the lookup so that future calls to the method do not need to search for it again. Changing a class's parent class or adding subroutines to a class will invalidate the cache for that class.</source>
          <target state="translated">Perl은 메소드를 검색 할 때 검색을 캐시하여 나중에 메소드를 호출 할 때 다시 검색 할 필요가 없도록합니다. 클래스의 부모 클래스를 변경하거나 클래스에 서브 루틴을 추가하면 해당 클래스의 캐시가 무효화됩니다.</target>
        </trans-unit>
        <trans-unit id="dc44d70cd8e2f4c150d9b1a250549091ec350dff" translate="yes" xml:space="preserve">
          <source>When Perl sees a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; extension;&lt;/code&gt; , it searches for a file with the same name as the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;'d extension that has a .pm suffix. If that file cannot be found, Perl dies with a fatal error. The default search path is contained in the &lt;code&gt;@INC&lt;/code&gt; array.</source>
          <target state="translated">Perl이 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; extension;&lt;/code&gt; 볼 때 ; .pm 접미사가있는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 'd 확장자 와 동일한 이름을 가진 파일을 검색합니다 . 해당 파일을 찾을 수 없으면 Perl은 치명적인 오류로 사망합니다. 기본 검색 경로는 &lt;code&gt;@INC&lt;/code&gt; 배열에 있습니다.</target>
        </trans-unit>
        <trans-unit id="c45a181d0244e9e1141094875e09095d6414b083" translate="yes" xml:space="preserve">
          <source>When Pod::Simple sees a &quot;=head1 Hi there&quot;, for example, it basically does this:</source>
          <target state="translated">예를 들어 Pod :: Simple에 &quot;= head1 Hi there&quot;가 표시되면 기본적으로 다음과 같이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="1cd158af5ecd016f5844a2f8d5f52d658dbd56fa" translate="yes" xml:space="preserve">
          <source>When STDERR is tied, its PRINT method will be called to issue warnings and error messages. This feature is temporarily disabled during the call, which means you can use &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn()&lt;/a&gt;&lt;/code&gt; inside PRINT without starting a recursive loop. And just like &lt;code&gt;__WARN__&lt;/code&gt; and &lt;code&gt;__DIE__&lt;/code&gt; handlers, STDERR's PRINT method may be called to report parser errors, so the caveats mentioned under &lt;a href=&quot;perlvar#%25SIG&quot;&gt;%SIG in perlvar&lt;/a&gt; apply.</source>
          <target state="translated">STDERR이 연결되면 PRINT 메소드가 호출되어 경고 및 오류 메시지를 발행합니다. 이 기능은 호출 중에 일시적으로 비활성화되므로 재귀 루프를 시작하지 않고 PRINT 내에서 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn()&lt;/a&gt;&lt;/code&gt; 사용할 수 있습니다 . &lt;code&gt;__WARN__&lt;/code&gt; 및 &lt;code&gt;__DIE__&lt;/code&gt; 핸들러 와 마찬가지로 STDERR의 PRINT 메소드는 파서 오류를보고하기 위해 호출 될 수 있으므로 &lt;a href=&quot;perlvar#%25SIG&quot;&gt;perlvar의 % SIG에&lt;/a&gt; 언급 된 경고가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="776742a8703e38b8c7c180ad1bc1e1f2ea07cf1b" translate="yes" xml:space="preserve">
          <source>When Storable croaks, it tries to report the error via the &lt;code&gt;logcroak()&lt;/code&gt; routine from the &lt;code&gt;Log::Agent&lt;/code&gt; package, if it is available.</source>
          <target state="translated">Storable croak이 발생 하면 &lt;code&gt;Log::Agent&lt;/code&gt; 패키지 에서 &lt;code&gt;logcroak()&lt;/code&gt; 루틴을 통해 오류를보고합니다 ( 사용 가능한 경우).</target>
        </trans-unit>
        <trans-unit id="d6016e444b9f013774a61df21cb4a60b0edf43d8" translate="yes" xml:space="preserve">
          <source>When UTF-8 becomes the standard source format, this pragma will effectively become a no-op. For convenience in what follows the term</source>
          <target state="translated">UTF-8이 표준 소스 형식이되면이 pragma는 효과적으로 작동하지 않습니다. 용어 뒤에 오는 편의상</target>
        </trans-unit>
        <trans-unit id="1e26f2f78b2d3c5f0bcbde15044bd5212be0247d" translate="yes" xml:space="preserve">
          <source>When Unicode Does Not Happen</source>
          <target state="translated">유니 코드가 발생하지 않는 경우</target>
        </trans-unit>
        <trans-unit id="7748cfda1edce223207e83e001d28dffb7bf724f" translate="yes" xml:space="preserve">
          <source>When Unicode rules are in effect:</source>
          <target state="translated">유니 코드 규칙이 적용되는 경우 :</target>
        </trans-unit>
        <trans-unit id="a9436974a6cc23829e6eb2bd840fe00c99d5fdc2" translate="yes" xml:space="preserve">
          <source>When Unicode was first conceived, it was thought that all the world's characters could be represented using a 16-bit word; that is a maximum of &lt;code&gt;0x10000&lt;/code&gt; (or 65,536) characters would be needed, from &lt;code&gt;0x0000&lt;/code&gt; to &lt;code&gt;0xFFFF&lt;/code&gt; . This soon proved to be wrong, and since Unicode 2.0 (July 1996), Unicode has been defined all the way up to 21 bits (&lt;code&gt;0x10FFFF&lt;/code&gt; ), and Unicode 3.1 (March 2001) defined the first characters above &lt;code&gt;0xFFFF&lt;/code&gt; . The first &lt;code&gt;0x10000&lt;/code&gt; characters are called the</source>
          <target state="translated">유니 코드가 처음 고안되었을 때, 모든 세계 문자는 16 비트 단어를 사용하여 표현 될 수 있다고 생각되었습니다. 즉 , &lt;code&gt;0x0000&lt;/code&gt; 에서 &lt;code&gt;0xFFFF&lt;/code&gt; 까지 최대 &lt;code&gt;0x10000&lt;/code&gt; (또는 65,536)자가 필요합니다 . 이것은 곧 잘못된 것으로 판명되었으며, 유니 코드 2.0 (1996 년 7 월)부터 유니 코드는 최대 21 비트 ( &lt;code&gt;0x10FFFF&lt;/code&gt; ) 까지 정의되었으며, 유니 코드 3.1 (2001 년 3 월)은 &lt;code&gt;0xFFFF&lt;/code&gt; 이상의 첫 문자를 정의했습니다 . 첫 &lt;code&gt;0x10000&lt;/code&gt; 문자는</target>
        </trans-unit>
        <trans-unit id="824bf2e880285aa9c434d2acac5d910818e02e5d" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;SelectSaver&lt;/code&gt; is destroyed, it re-selects the file handle that was selected when it was created.</source>
          <target state="translated">때 &lt;code&gt;SelectSaver&lt;/code&gt; 파괴되어, 그것이 만들 때 선택된 파일 핸들을 다시 선택한다.</target>
        </trans-unit>
        <trans-unit id="47dccd0143522691a9547f34d1ed5af302d02e22" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;given&lt;/code&gt; statement is also a valid expression (for example, when it's the last statement of a block), it evaluates to:</source>
          <target state="translated">&lt;code&gt;given&lt;/code&gt; 때 문장이 또한 올바른 표현이다 (이 블록의 마지막 문장이 때, 예를 들어), 그것을 평가 :</target>
        </trans-unit>
        <trans-unit id="0af006e8d26663a7078cc20a1292be03a5256d66" translate="yes" xml:space="preserve">
          <source>When a CV has a reference count on its slab (CvSLABBED), it is responsible for making sure it is freed. (Hence, no two CVs should ever have a reference count on the same slab.) The CV only needs to reference the slab during compilation. Once it is compiled and CvROOT attached, it has finished its job, so it can forget the slab.</source>
          <target state="translated">CV의 슬래브 (CvSLABBED)에 참조 카운트가 있으면 해제해야합니다. (따라서 두 개의 CV가 동일한 슬래브에서 참조 횟수를 가져서는 안됩니다.) CV는 컴파일하는 동안 슬래브 만 참조하면됩니다. 컴파일되고 CvROOT가 연결되면 작업이 완료되므로 슬래브를 잊을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c03e144fe4a4613006ecf4b238cfa477e26c49c" translate="yes" xml:space="preserve">
          <source>When a DST change causes a locale clock to skip one hour forward, there will be an hour's worth of local times that don't exist. Again, for the &quot;Europe/Paris&quot; time zone, the local clock jumped from 2001-03-25 01:59:59 to 2001-03-25 03:00:00.</source>
          <target state="translated">DST 변경으로 인해 로케일 시계가 한 시간 앞으로 건너 뛰면 존재하지 않는 한 시간 분량의 현지 시간이 있습니다. &quot;유럽 / 파리&quot;시간대의 경우에도 현지 시계가 2001-03-25 01:59:59에서 2001-03-25 03:00:00으로 급증했습니다.</target>
        </trans-unit>
        <trans-unit id="6c769151f41d9f979bbea6aa6d7a29c398587207" translate="yes" xml:space="preserve">
          <source>When a block is preceding by a compilation phase keyword such as &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;END&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , or &lt;code&gt;UNITCHECK&lt;/code&gt; , then the block will run only during the corresponding phase of execution. See &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; for more details.</source>
          <target state="translated">블록이 &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;END&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; 또는 &lt;code&gt;UNITCHECK&lt;/code&gt; 와 같은 컴파일 단계 키워드 앞에 오면 블록은 해당 실행 단계 중에 만 실행됩니다. 자세한 내용은 &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7d61af89d14aac150579ea072baeedb77daecc0a" translate="yes" xml:space="preserve">
          <source>When a class has multiple parents, the method lookup order becomes more complicated.</source>
          <target state="translated">클래스에 부모가 여러 개인 경우 메서드 조회 순서가 더 복잡해집니다.</target>
        </trans-unit>
        <trans-unit id="bbfabd64dc538b19e52659b29026ea44adaac5bb" translate="yes" xml:space="preserve">
          <source>When a class inherits from another class, any methods defined in the parent class are available to the child class. If you attempt to call a method on an object that isn't defined in its own class, Perl will also look for that method in any parent classes it may have.</source>
          <target state="translated">클래스가 다른 클래스에서 상속되면 부모 클래스에 정의 된 모든 메서드를 자식 클래스에서 사용할 수 있습니다. 자체 클래스에 정의되어 있지 않은 객체에서 메소드를 호출하려고 시도하면 Perl은 상위 클래스에서 해당 메소드를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="3fbe037b656bddc24c2846062762f1fce297b32a" translate="yes" xml:space="preserve">
          <source>When a comma-separated list of subroutine names is given as options, Showlex prints the lexical variables used in those subroutines. Otherwise, it prints the file-scope lexicals in the file.</source>
          <target state="translated">쉼표로 구분 된 서브 루틴 이름 목록이 옵션으로 제공되면 Showlex는 해당 서브 루틴에 사용 된 어휘 변수를 인쇄합니다. 그렇지 않으면 파일에서 파일 범위 어휘를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="7150e31ab9e9cca66d69c6a47a4d5fc17ee83d01" translate="yes" xml:space="preserve">
          <source>When a constant is used in an expression, Perl replaces it with its value at compile time, and may then optimize the expression further. In particular, any code in an &lt;code&gt;if (CONSTANT)&lt;/code&gt; block will be optimized away if the constant is false.</source>
          <target state="translated">표현식에 상수가 사용되면 Perl은 컴파일 타임에 해당 값으로 바꾸고 표현식을 더 최적화 할 수 있습니다. 특히 &lt;code&gt;if (CONSTANT)&lt;/code&gt; 블록의 모든 코드 는 상수가 false 인 경우 최적화됩니다.</target>
        </trans-unit>
        <trans-unit id="ff12ac8ff6a9fb5ab965d82a8adb8da16c238288" translate="yes" xml:space="preserve">
          <source>When a context for a part of compile tree is known, it is propagated down through the tree. At this time the context can have 5 values (instead of 2 for runtime context): void, boolean, scalar, list, and lvalue. In contrast with the pass 1 this pass is processed from top to bottom: a node's context determines the context for its children.</source>
          <target state="translated">컴파일 트리의 일부에 대한 컨텍스트가 알려지면 트리를 통해 전파됩니다. 이때 컨텍스트에는 void, boolean, scalar, list 및 lvalue와 같은 5 개의 값 (런타임 컨텍스트의 경우 2 대신)이있을 수 있습니다. 패스 1과 달리이 패스는 위에서 아래로 처리됩니다. 노드의 컨텍스트는 해당 자식의 컨텍스트를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="d87717a8777688d74cabbb2304d94b51341cc91d" translate="yes" xml:space="preserve">
          <source>When a core function calls another, it must pass the context. This is normally hidden via macros. Consider &lt;code&gt;sv_setiv&lt;/code&gt; . It expands into something like this:</source>
          <target state="translated">핵심 함수가 다른 함수를 호출하면 컨텍스트를 전달해야합니다. 일반적으로 매크로를 통해 숨겨집니다. &lt;code&gt;sv_setiv&lt;/code&gt; 를 고려 하십시오 . 다음과 같이 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="40ceceb3dfac228f4dc1ea2316b05b14abb23395" translate="yes" xml:space="preserve">
          <source>When a dictionary is specified</source>
          <target state="translated">사전이 지정된 경우</target>
        </trans-unit>
        <trans-unit id="d409b69c538e75e300d571031fe6a755a4d085f3" translate="yes" xml:space="preserve">
          <source>When a distribution has already been tested by CPAN::Reporter on this machine, CPAN can skip the test phase and just rely on the test report history instead.</source>
          <target state="translated">이 머신에서 CPAN :: Reporter가 이미 분배를 테스트 한 경우 CPAN은 테스트 단계를 건너 뛰고 대신 테스트 보고서 히스토리에 의존 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f71acc218a83c770a92fc1a815404b3d3de498a7" translate="yes" xml:space="preserve">
          <source>When a file is opened it is in either text or binary mode. In text mode a file is subject to CR/LF/Ctrl-Z translations. With Cygwin, the default mode for an &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; is determined by the mode of the mount that underlies the file. See &lt;a href=&quot;#Cygwin%3a%3ais_binmount&quot;&gt;Cygwin::is_binmount&lt;/a&gt;(). Perl provides a &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; function to set binary mode on files that otherwise would be treated as text. &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen()&lt;/a&gt;&lt;/code&gt; with the &lt;code&gt;O_TEXT&lt;/code&gt; flag sets text mode on files that otherwise would be treated as binary:</source>
          <target state="translated">파일이 열리면 텍스트 또는 이진 모드입니다. 텍스트 모드에서 파일은 CR / LF / Ctrl-Z로 변환됩니다. Cygwin에서 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 의 기본 모드 는 파일의 기본이되는 마운트 모드에 의해 결정됩니다. &lt;a href=&quot;#Cygwin%3a%3ais_binmount&quot;&gt;Cygwin :: is_binmount&lt;/a&gt; ()를 참조하십시오 . Perl은 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; 함수를 제공하여 텍스트로 취급 될 파일에 바이너리 모드를 설정합니다. &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen()&lt;/a&gt;&lt;/code&gt; 으로 &lt;code&gt;O_TEXT&lt;/code&gt; 다른 바이너리로 처리 될 파일에 플래그 세트 텍스트 모드 :</target>
        </trans-unit>
        <trans-unit id="973bff9414f9daff4e8ac9353de5be029b42eafe" translate="yes" xml:space="preserve">
          <source>When a handle is so opened, then reads get bytes from the string value of</source>
          <target state="translated">핸들이 열리면 문자열 값에서 get bytes를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="17e8d47075484fcb067bf9d5f01cdea7dd0c053a" translate="yes" xml:space="preserve">
          <source>When a keyword is being handled, the plugin function must build a tree of &lt;code&gt;OP&lt;/code&gt; structures, representing the code that was parsed. The root of the tree must be stored in &lt;code&gt;*op_ptr&lt;/code&gt; . The function then returns a constant indicating the syntactic role of the construct that it has parsed: &lt;code&gt;KEYWORD_PLUGIN_STMT&lt;/code&gt; if it is a complete statement, or &lt;code&gt;KEYWORD_PLUGIN_EXPR&lt;/code&gt; if it is an expression. Note that a statement construct cannot be used inside an expression (except via &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; BLOCK&lt;/code&gt; and similar), and an expression is not a complete statement (it requires at least a terminating semicolon).</source>
          <target state="translated">키워드를 처리 할 때 플러그인 함수 는 구문 분석 된 코드를 나타내는 &lt;code&gt;OP&lt;/code&gt; 구조 트리를 작성해야합니다 . 트리의 루트는 &lt;code&gt;*op_ptr&lt;/code&gt; 에 저장되어야합니다 . :이 함수는 다음 구문 분석되었음을 구조의 구문 역할을 나타내는 정수를 반환 &lt;code&gt;KEYWORD_PLUGIN_STMT&lt;/code&gt; 을 가 완전한 문장 경우, 또는 &lt;code&gt;KEYWORD_PLUGIN_EXPR&lt;/code&gt; 가 표현됩니다. 명령문 구조는 표현식 내에서 사용할 수 없습니다 ( &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; BLOCK&lt;/code&gt; BLOCK을 통한 경우 제외). 및 유사한 ) 표현식은 완전한 명령문이 아닙니다 (최소한 세미콜론이 필요함).</target>
        </trans-unit>
        <trans-unit id="9e79d667e2ee3be13474d3de61e4494ae38724c2" translate="yes" xml:space="preserve">
          <source>When a keyword is handled, the plugin function may also have (compile-time) side effects. It may modify &lt;code&gt;%^H&lt;/code&gt; , define functions, and so on. Typically, if side effects are the main purpose of a handler, it does not wish to generate any ops to be included in the normal compilation. In this case it is still required to supply an op tree, but it suffices to generate a single null op.</source>
          <target state="translated">키워드를 처리 할 때 플러그인 기능에 (컴파일 타임) 부작용이있을 수 있습니다. &lt;code&gt;%^H&lt;/code&gt; 수정할 수 있습니다 하고 함수를 정의하는 등의 작업을 수행 할 수 있습니다. 일반적으로 부작용이 처리기의 주요 목적인 경우 일반 컴파일에 포함될 연산을 생성하지 않습니다. 이 경우 여전히 op 트리를 제공해야하지만 단일 null op를 생성하면 충분합니다.</target>
        </trans-unit>
        <trans-unit id="57ad4f96e4d1cfbd5bc9ad7761654ce09c743746" translate="yes" xml:space="preserve">
          <source>When a line is rendered, the correct format-spec is copied and scanned for the following items; data is substituted in, and other manipulations like basic indenting are done, for each opcode rendered.</source>
          <target state="translated">라인이 렌더링 될 때 올바른 형식 스펙이 복사되고 다음 항목에 대해 스캔됩니다. 렌더링 된 각 opcode에 대해 데이터가 대체되고 기본 들여 쓰기와 같은 다른 조작이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="816633f303f39f0cbcf02a62fbc386a09fe865f3" translate="yes" xml:space="preserve">
          <source>When a match has failed, and unless another verb has been involved in failing the match and has provided its own name to use, the &lt;code&gt;$REGERROR&lt;/code&gt; variable will be set to the name of the most recently executed &lt;code&gt;(*MARK:NAME)&lt;/code&gt;.</source>
          <target state="translated">일치가 실패하고 다른 동사가 일치 실패에 관여하지 않고 사용할 고유 이름을 제공하지 않는 한 &lt;code&gt;$REGERROR&lt;/code&gt; 변수는 가장 최근에 실행 된 이름 &lt;code&gt;(*MARK:NAME)&lt;/code&gt; 으로 설정됩니다. 됩니다.</target>
        </trans-unit>
        <trans-unit id="166223375f2bf3db19459da46d44df6881e6c346" translate="yes" xml:space="preserve">
          <source>When a match is successful, the &lt;code&gt;$REGMARK&lt;/code&gt; variable will be set to the name of the most recently executed &lt;code&gt;(*MARK:NAME)&lt;/code&gt; that was involved in the match.</source>
          <target state="translated">일치에 성공하면 &lt;code&gt;$REGMARK&lt;/code&gt; 변수는 일치와 가장 최근에 실행 된 이름 &lt;code&gt;(*MARK:NAME)&lt;/code&gt; 으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="4580d4e00986eec91e11abd53ea45f7e741116fe" translate="yes" xml:space="preserve">
          <source>When a module declares another one as a 'build_requires' prerequisite this means that the other module is only needed for building or testing the module but need not be installed permanently. In this case you may wish to install that other module nonetheless or just keep it in the 'build_dir' directory to have it available only temporarily. Installing saves time on future installations but makes the perl installation bigger.</source>
          <target state="translated">모듈이 다른 모듈을 'build_requires'전제 조건으로 선언하면 이는 다른 모듈이 모듈을 빌드하거나 테스트하는 데 필요하지만 영구적으로 설치할 필요는 없음을 의미합니다. 이 경우 다른 모듈을 설치하거나 'build_dir'디렉토리에 보관하여 일시적으로 만 사용할 수 있습니다. 설치하면 향후 설치 시간이 절약되지만 펄 설치는 더 커집니다.</target>
        </trans-unit>
        <trans-unit id="1496adc7bcbe4a50d48879cef9be976a3fb2e9c5" translate="yes" xml:space="preserve">
          <source>When a new language is being encoded, Unicode generally will choose a &lt;code&gt;block&lt;/code&gt; of consecutive unallocated code points for its characters. So far, the number of code points in these blocks has always been evenly divisible by 16. Extras in a block, not currently needed, are left unallocated, for future growth. But there have been occasions when a later release needed more code points than the available extras, and a new block had to allocated somewhere else, not contiguous to the initial one, to handle the overflow. Thus, it became apparent early on that &quot;block&quot; wasn't an adequate organizing principal, and so the &lt;code&gt;Script&lt;/code&gt; property was created. (Later an improved script property was added as well, the &lt;code&gt;Script_Extensions&lt;/code&gt; property.) Those code points that are in overflow blocks can still have the same script as the original ones. The script concept fits more closely with natural language: there is &lt;code&gt;Latin&lt;/code&gt; script, &lt;code&gt;Greek&lt;/code&gt; script, and so on; and there are several artificial scripts, like &lt;code&gt;Common&lt;/code&gt; for characters that are used in multiple scripts, such as mathematical symbols. Scripts usually span varied parts of several blocks. For more information about scripts, see &lt;a href=&quot;perlunicode#Scripts&quot;&gt;Scripts in perlunicode&lt;/a&gt;. The division into blocks exists, but it is almost completely accidental--an artifact of how the characters have been and still are allocated. (Note that this paragraph has oversimplified things for the sake of this being an introduction. Unicode doesn't really encode languages, but the writing systems for them--their scripts; and one script can be used by many languages. Unicode also encodes things that aren't really about languages, such as symbols like &lt;code&gt;BAGGAGE CLAIM&lt;/code&gt; .)</source>
          <target state="translated">새 언어를 인코딩 할 때 유니 코드는 일반적으로 해당 문자에 대해 할당되지 않은 연속 코드 포인트 &lt;code&gt;block&lt;/code&gt; 을 선택합니다 . 지금까지 이러한 블록의 코드 포인트 수는 항상 16으로 균등하게 나눠졌습니다. 현재 필요하지 않은 블록의 추가 요소는 향후 성장을 위해 할당되지 않은 상태로 남아 있습니다. 그러나 이후 릴리스에서 사용 가능한 추가 코드 포인트보다 더 많은 코드 포인트가 필요한 경우가 있었으며 새 블록이 오버 플로우를 처리하기 위해 초기 블록에 인접하지 않은 다른 곳에 할당해야했습니다. 따라서 &quot;블록&quot;이 적절한 조직 주체가 아니기 때문에 &lt;code&gt;Script&lt;/code&gt; 속성이 만들어졌습니다. (나중에 개선 된 스크립트 속성 인 &lt;code&gt;Script_Extensions&lt;/code&gt; 도 추가되었습니다.오버 플로우 블록에있는 해당 코드 포인트는 여전히 원래 스크립트와 동일한 스크립트를 가질 수 있습니다. 스크립트 개념은 자연 언어와 더 밀접한 관련이 있습니다. &lt;code&gt;Latin&lt;/code&gt; 스크립트, &lt;code&gt;Greek&lt;/code&gt; 스크립트 등이 있습니다. 수학 기호와 같이 여러 스크립트에서 사용되는 문자에 대한 &lt;code&gt;Common&lt;/code&gt; 과 같은 몇 가지 인공 스크립트 가 있습니다. 스크립트는 일반적으로 여러 블록의 다양한 부분에 걸쳐 있습니다. 스크립트에 대한 자세한 정보 &lt;a href=&quot;perlunicode#Scripts&quot;&gt;는 perlunicode의&lt;/a&gt; 스크립트를 참조하십시오.. 블록으로 나누기는 존재하지만 거의 완전히 우연입니다. 캐릭터가 어떻게 할당되었고 여전히 할당되었는지에 대한 인공물입니다. 유니 코드는 실제로 언어를 인코딩하는 것이 아니라 언어를 작성하는 시스템 (그들의 스크립트)과 하나의 스크립트를 여러 언어로 사용할 수 있으며, 유니 코드도 사물을 인코딩합니다. &lt;code&gt;BAGGAGE CLAIM&lt;/code&gt; 과 같은 기호와 같은 언어에 관한 것이 아닙니다 .)</target>
        </trans-unit>
        <trans-unit id="3bbe3c04751e10d9bc078e9c200bbf898654f3d9" translate="yes" xml:space="preserve">
          <source>When a package is compiled, a line like this</source>
          <target state="translated">패키지가 컴파일되면 다음과 같은 줄</target>
        </trans-unit>
        <trans-unit id="93bffad6a970da997c7854ebcbcae55a405a4802" translate="yes" xml:space="preserve">
          <source>When a perl script assigns a value to $0 then the perl runtime will try to make this value show up as the program name reported by &quot;ps&quot; by updating the memory pointed to by the argv passed to perl_parse() and also calling API functions like setproctitle() where available. This behaviour might not be appropriate when embedding perl and can be disabled by assigning the value &lt;code&gt;1&lt;/code&gt; to the variable &lt;code&gt;PL_origalen&lt;/code&gt; before perl_parse() is called.</source>
          <target state="translated">perl 스크립트가 $ 0에 값을 할당하면 perl 런타임은 perl_parse ()에 전달 된 argv가 가리키는 메모리를 업데이트하고 다음과 같은 API 함수를 호출하여이 값이 &quot;ps&quot;에 의해보고 된 프로그램 이름으로 표시되도록 시도합니다. 가능한 경우 setproctitle (). 이 동작은 perl을 임베드 할 때 적합하지 않을 수 있으며 perl_parse ()가 호출되기 전에 변수 &lt;code&gt;PL_origalen&lt;/code&gt; 에 값 &lt;code&gt;1&lt;/code&gt; 을 지정하여 사용 불가능하게 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5dd94d34aa40052479abfe68a7305a1776af1c6b" translate="yes" xml:space="preserve">
          <source>When a regexp can match a string in several different ways, we can use the principles above to predict which way the regexp will match:</source>
          <target state="translated">정규 표현식이 여러 가지 방법으로 문자열과 일치 할 수있는 경우 위의 원칙을 사용하여 정규 표현식과 일치하는 방법을 예측할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e93e818427f981a20b5cd3c2cdc058e4ee5f4c1" translate="yes" xml:space="preserve">
          <source>When a regexp is compiled, its &lt;code&gt;engine&lt;/code&gt; field is then set to point at the appropriate structure, so that when it needs to be used Perl can find the right routines to do so.</source>
          <target state="translated">정규 표현식이 컴파일되면 &lt;code&gt;engine&lt;/code&gt; 필드가 적절한 구조를 가리 키도록 설정되어 사용되어야 할 때 Perl은 올바른 루틴을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ee520116426a3c213440cc6f7664ca3ad684e60" translate="yes" xml:space="preserve">
          <source>When a signal is delivered (e.g., SIGINT from a control-C) the operating system breaks into IO operations like</source>
          <target state="translated">신호가 전달되면 (예 : control-C에서 SIGINT) 운영 체제는 다음과 같은 IO 작업으로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="232c6b5f6274d23859408b92a2808f3fc59dd734" translate="yes" xml:space="preserve">
          <source>When a space and a plus sign are given as the flags at once, a plus sign is used to prefix a positive number.</source>
          <target state="translated">공백과 더하기 부호가 한 번에 플래그로 제공되면 더하기 부호가 양수 앞에 붙습니다.</target>
        </trans-unit>
        <trans-unit id="d4c0062970171773b2800c4b96cf35e1d153d560" translate="yes" xml:space="preserve">
          <source>When a variable is tied, it is associated with the object which is the return value of the TIESCALAR, TIEARRAY, or TIEHASH function. This object normally has only one reference, namely, the implicit reference from the tied variable. When untie() is called, that reference is destroyed. Then, as in the first example above, the object's destructor (DESTROY) is called, which is normal for objects that have no more valid references; and thus the file is closed.</source>
          <target state="translated">변수가 묶여 있으면 TIESCALAR, TIEARRAY 또는 TIEHASH 함수의 반환 값인 객체와 연결됩니다. 이 객체에는 일반적으로 하나의 참조, 즉 묶인 변수의 암시 적 참조 만 있습니다. untie ()가 호출되면 해당 참조가 삭제됩니다. 그런 다음 위의 첫 번째 예에서와 같이 객체의 소멸자 (DESTROY)가 호출되는데, 이는 더 이상 유효한 참조가없는 객체에 대해 정상입니다. 따라서 파일이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="4c087ed039f3d9aacb0c9c7c411e1eafe86f0a03" translate="yes" xml:space="preserve">
          <source>When a weak reference is stored in an &lt;code&gt;SV&lt;/code&gt; that has &quot;uvar&quot; magic, &lt;code&gt;set&lt;/code&gt; magic is called after the reference has gone stale. This hook can be used to trigger further garbage-collection activities associated with the referenced object.</source>
          <target state="translated">&quot;uvar&quot;매직이 있는 &lt;code&gt;SV&lt;/code&gt; 에 약한 레퍼런스가 저장 되면 레퍼런스가 오래 된 후에 &lt;code&gt;set&lt;/code&gt; 매직이 호출됩니다. 이 후크는 참조 된 오브젝트와 연관된 추가 가비지 콜렉션 활동을 트리거하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a9840147d7f095037a163c370bf370a7676a796" translate="yes" xml:space="preserve">
          <source>When all parsers are exhausted an empty list will be returned.</source>
          <target state="translated">모든 파서가 소진되면 빈 목록이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d58a9a2162a7d9db701502c02549ae6467f05b83" translate="yes" xml:space="preserve">
          <source>When an array or an array slice is interpolated into a double-quoted string or a similar context such as &lt;code&gt;/.../&lt;/code&gt; , its elements are separated by this value. Default is a space. For example, this:</source>
          <target state="translated">배열 또는 배열 슬라이스가 큰 따옴표로 묶인 문자열 또는 &lt;code&gt;/.../&lt;/code&gt; 와 같은 유사한 컨텍스트로 보간 될 때 해당 요소는이 값으로 구분됩니다. 기본값은 공백입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e576a7aca6fc0d7ad26c29db1ef25b646d312e24" translate="yes" xml:space="preserve">
          <source>When an attribute list is present in a declaration, a check is made to see whether an attribute 'modify' handler is present in the appropriate package (or its @ISA inheritance tree). Similarly, when &lt;code&gt;attributes::get&lt;/code&gt; is called on a valid reference, a check is made for an appropriate attribute 'fetch' handler. See &lt;a href=&quot;#EXAMPLES&quot;&gt;EXAMPLES&lt;/a&gt; to see how the &quot;appropriate package&quot; determination works.</source>
          <target state="translated">속성 목록이 선언에 있으면 속성 'modify'핸들러가 적절한 패키지 (또는 @ISA 상속 트리)에 있는지 확인합니다. 마찬가지로, &lt;code&gt;attributes::get&lt;/code&gt; 이 유효한 참조에서 호출되면 적절한 속성 'fetch'핸들러를 검사합니다. 참조 &lt;a href=&quot;#EXAMPLES&quot;&gt;예&lt;/a&gt; 방법 &quot;적절한 패키지&quot;결정의 작품을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cddb5e14177fc6acd8b55e0252f21e912b7951c" translate="yes" xml:space="preserve">
          <source>When an element of &lt;code&gt;%ENV&lt;/code&gt; is read, the locations to which</source>
          <target state="translated">&lt;code&gt;%ENV&lt;/code&gt; 의 요소를 읽을 때</target>
        </trans-unit>
        <trans-unit id="0687a40bbb86ac6f75e3c72f51434b562de688d3" translate="yes" xml:space="preserve">
          <source>When an element of &lt;code&gt;%ENV&lt;/code&gt; is set to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, the element is looked up as if it were being read, and if it is found, it is deleted. (An item &quot;deleted&quot; from the CRTL &lt;code&gt;environ&lt;/code&gt; array is set to the empty string.) Using &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; to remove an element from &lt;code&gt;%ENV&lt;/code&gt; has a similar effect, but after the element is deleted, another attempt is made to look up the element, so an inner-mode logical name or a name in another location will replace the logical name just deleted. In either case, only the first value found searching PERL_ENV_TABLES is altered. It is not possible at present to define a search list logical name via %ENV.</source>
          <target state="translated">소자의 경우 &lt;code&gt;%ENV&lt;/code&gt; 설정되어 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 판독되는 경우와 같이, 요소가 조회되고,이 발견되는 경우, 그것은 삭제된다. (CRTL &lt;code&gt;environ&lt;/code&gt; 배열 에서 &quot;삭제 된&quot;항목 은 빈 문자열로 설정됩니다.) &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; 를 사용하여 &lt;code&gt;%ENV&lt;/code&gt; 에서 요소를 제거하는 것과 비슷한 효과가 있지만 요소를 삭제 한 후 요소를 찾으려고 시도하는 다른 시도가 있습니다. 따라서 내부 모드 논리 이름 또는 다른 위치의 이름은 방금 삭제 한 논리 이름을 대체합니다. 두 경우 모두 PERL_ENV_TABLES를 검색 한 첫 번째 값만 변경됩니다. 현재 % ENV를 통해 검색 목록 논리 이름을 정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f3d5e830d380d586cadba3ebb3b0b5993def5162" translate="yes" xml:space="preserve">
          <source>When an element of &lt;code&gt;%ENV&lt;/code&gt; is set to a defined string, the corresponding definition is made in the location to which the first translation of</source>
          <target state="translated">&lt;code&gt;%ENV&lt;/code&gt; 의 요소가 정의 된 문자열로 설정되면 첫 번째 변환의 위치에서 해당 정의가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="6e4667405eb0016e589d7ee3b3978551b835b138" translate="yes" xml:space="preserve">
          <source>When an install fails for some reason and then I correct the error condition and retry, CPAN.pm refuses to install the module, saying &lt;code&gt;Already tried without success&lt;/code&gt; .</source>
          <target state="translated">어떤 이유로 설치에 실패한 후 오류 조건을 수정 한 후 다시 시도하면 CPAN.pm은 모듈 설치를 거부하고 &lt;code&gt;Already tried without success&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88b449cc559ca252d850238032174c7042fa310e" translate="yes" xml:space="preserve">
          <source>When an undefined layer 'foo' is encountered in an &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; layer specification then C code performs the equivalent of:</source>
          <target state="translated">정의되지 않은 레이어 'foo'가 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 사양 에서 발견되면 C 코드는 다음과 같은 기능을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="05eb98d8070a762d6a7fd65d464d57e96f47f0ef" translate="yes" xml:space="preserve">
          <source>When an updir path like &quot;:::lib::&quot; is passed as argument, the number of directories to climb up is handled correctly, not removing leading or trailing colons when necessary. E.g.</source>
          <target state="translated">&quot;::: lib ::&quot;와 같은 updir 경로가 인수로 전달되면 올라갈 디렉토리의 수가 올바르게 처리되어 필요한 경우 선행 또는 후행 콜론을 제거하지 않습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="fc030f96c1c92f54f8dacedeb177bdbc127fdac6" translate="yes" xml:space="preserve">
          <source>When an uppercase and lowercase letter both exist in the table, then the uppercase letter is typically used to represent some kind of composite type (a list or a hash), and the lowercase letter is used to represent an element of that composite type. Some internals code makes use of this case relationship. However, 'v' and 'V' (vec and v-string) are in no way related.</source>
          <target state="translated">대문자와 소문자가 모두 테이블에 존재하는 경우 대문자는 일반적으로 일종의 복합 유형 (목록 또는 해시)을 나타내는 데 사용되고 소문자는 해당 복합 유형의 요소를 나타내는 데 사용됩니다. 일부 내부 코드는이 사례 관계를 사용합니다. 그러나 'v'와 'V'(vec 및 v-string)는 전혀 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="34009ee0cae148f2a1680a702fb847661476a204" translate="yes" xml:space="preserve">
          <source>When and whether to use small caps is somewhat tricky, and Pod::Man doesn't necessarily get it right.</source>
          <target state="translated">작은 대문자를 사용할지 여부는 다소 까다로울 수 있으며 Pod :: Man이 꼭 맞지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="50a0e6b3c1e9721563cfa37763282c6acaf8fe8f" translate="yes" xml:space="preserve">
          <source>When applied to the following command line:</source>
          <target state="translated">다음 명령 행에 적용될 때 :</target>
        </trans-unit>
        <trans-unit id="a01d1e59657f16ebb14cc78dbc769393ad07bd40" translate="yes" xml:space="preserve">
          <source>When auto-detecting the compressed format, try to test for lzma_alone content using the &lt;code&gt;IO::Uncompress::UnLzma&lt;/code&gt; module.</source>
          <target state="translated">압축 형식을 자동 감지하는 경우 &lt;code&gt;IO::Uncompress::UnLzma&lt;/code&gt; 모듈을 사용하여 lzma_alone 컨텐츠를 테스트하십시오 .</target>
        </trans-unit>
        <trans-unit id="3afc2592b2e6769a24dccd537ec52009da2c39f6" translate="yes" xml:space="preserve">
          <source>When auto-detecting the compressed format, try to test for raw-deflate (RFC 1951) content using the &lt;code&gt;IO::Uncompress::RawInflate&lt;/code&gt; module.</source>
          <target state="translated">압축 형식을 자동 감지하는 경우 &lt;code&gt;IO::Uncompress::RawInflate&lt;/code&gt; 모듈을 사용하여 raw-deflate (RFC 1951) 컨텐츠를 테스트하십시오 .</target>
        </trans-unit>
        <trans-unit id="11c4b6b6311800f4181591dd698a41134ea1ef8b" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; are used at the same time, the regexp has to match both the beginning and the end of the string, i.e., the regexp matches the whole string. Consider</source>
          <target state="translated">두시 &lt;code&gt;^&lt;/code&gt; 및 &lt;code&gt;$&lt;/code&gt; 가 동시에 사용되며, 정규 표현식은 시작과 문자열, 즉, 정규 표현식은 전체 문자열과 일치의 끝을 모두 일치해야합니다. 치다</target>
        </trans-unit>
        <trans-unit id="0058d0939f56e0836aecac00731cc26dae5c908c" translate="yes" xml:space="preserve">
          <source>When both A and P are undefined, this is used as a fallback accuracy when dividing numbers.</source>
          <target state="translated">A와 P가 모두 정의되지 않은 경우 숫자를 나눌 때 대체 정확도로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="060766cfa822ddf97bd7bc65f3fc7e729b274423" translate="yes" xml:space="preserve">
          <source>When building 64-bit modules, it is your responsibility to ensure that linked external libraries and frameworks provide 64-bit support: if they do not, module building may appear to succeed, but attempts to use the module will result in run-time dynamic linking errors, and subsequent test failures. You can use &lt;code&gt;file&lt;/code&gt; to discover the architectures supported by a library:</source>
          <target state="translated">64 비트 모듈을 빌드 할 때는 연결된 외부 라이브러리 및 프레임 워크가 64 비트 지원을 제공해야합니다. 그렇지 않은 경우 모듈 빌드는 성공한 것으로 보이지만 모듈을 사용하려고하면 런타임이 동적으로 나타납니다. 연결 오류 및 후속 테스트 실패 &lt;code&gt;file&lt;/code&gt; 을 사용 하여 라이브러리가 지원하는 아키텍처를 발견 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d21008e482052b445cfd243ad8bc31adfd3249b5" translate="yes" xml:space="preserve">
          <source>When building Perl it will always return true, as nothing is installed yet.</source>
          <target state="translated">Perl을 빌드 할 때 아직 아무것도 설치되지 않았으므로 항상 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="aaf49b07a212f715b8dd8f309b5c78af1bf1e342" translate="yes" xml:space="preserve">
          <source>When built on an ODS-5 volume with symbolic links enabled, Perl by default supports symbolic links when the requisite support is available in the filesystem and CRTL (generally 64-bit OpenVMS v8.3 and later). There are a number of limitations and caveats to be aware of when working with symbolic links on VMS. Most notably, the target of a valid symbolic link must be expressed as a Unix-style path and it must exist on a volume visible from your POSIX root (see the &lt;code&gt;SHOW ROOT&lt;/code&gt; command in DCL help). For further details on symbolic link capabilities and requirements, see chapter 12 of the CRTL manual that ships with OpenVMS v8.3 or later.</source>
          <target state="translated">기호 링크가 활성화 된 ODS-5 볼륨에 구축 된 경우 Perl은 파일 시스템 및 CRTL (일반적으로 64 비트 OpenVMS v8.3 이상)에서 필수 지원을 사용할 수있는 경우 기본적으로 기호 링크를 지원합니다. VMS에서 심볼릭 링크로 작업 할 때주의해야 할 몇 가지 제한 사항과주의 사항이 있습니다. 특히, 유효한 기호 링크의 대상은 Unix 스타일 경로로 표현되어야하며 POSIX 루트에서 볼 수있는 볼륨에 존재해야합니다 ( DCL 도움말 의 &lt;code&gt;SHOW ROOT&lt;/code&gt; 명령 참조 ). 심볼릭 링크 기능 및 요구 사항에 대한 자세한 내용은 OpenVMS v8.3 이상과 함께 제공되는 CRTL 설명서의 12 장을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3274ae41eb972b48380cd0be38746ee76dc6d9df" translate="yes" xml:space="preserve">
          <source>When bundling is in effect, case is ignored on single-character options also.</source>
          <target state="translated">번들링이 적용되는 경우 단일 문자 옵션에서도 대소 문자가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="534230020f5629c55b27da34563c08514a84a5c7" translate="yes" xml:space="preserve">
          <source>When calculating specific times, such as for tests in time or date modules, it may be appropriate to calculate an offset for the epoch.</source>
          <target state="translated">시간 또는 날짜 모듈의 테스트와 같은 특정 시간을 계산할 때 에포크에 대한 오프셋을 계산하는 것이 적절할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9da2af35b4e027fcb57324a97e158a9219d7749d" translate="yes" xml:space="preserve">
          <source>When called from a thread, this behaves like &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt; (i.e., the exit status code is ignored).</source>
          <target state="translated">스레드에서 호출 될 때 이는 &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt; 와 같이 작동합니다 (즉, 종료 상태 코드는 무시됩니다).</target>
        </trans-unit>
        <trans-unit id="9c8531e379ee34158f961b216941a888acd13144" translate="yes" xml:space="preserve">
          <source>When called from the</source>
          <target state="translated">에서 호출 될 때</target>
        </trans-unit>
        <trans-unit id="43350391a792d394d51fbfdf3323ff9bf611b150" translate="yes" xml:space="preserve">
          <source>When called in a scalar context &lt;code&gt;strtod&lt;/code&gt; returns the parsed number.</source>
          <target state="translated">스칼라 컨텍스트에서 호출되면 &lt;code&gt;strtod&lt;/code&gt; 는 구문 분석 된 숫자를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="da1211ed8e0b63c4bc2cdd7832083442b210dfa8" translate="yes" xml:space="preserve">
          <source>When called in a scalar context &lt;code&gt;strtol&lt;/code&gt; returns the parsed number.</source>
          <target state="translated">스칼라 컨텍스트에서 호출되면 &lt;code&gt;strtol&lt;/code&gt; 은 구문 분석 된 숫자를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="cd23c4a922c775b095b3cd879f0e839934775a17" translate="yes" xml:space="preserve">
          <source>When called in list context, a filehandle to the open file and a filename are returned. This is achieved by calling mkstemp() after constructing a suitable template.</source>
          <target state="translated">리스트 컨텍스트에서 호출되면 열린 파일에 대한 파일 핸들과 파일 이름이 반환됩니다. 이것은 적절한 템플릿을 생성 한 후 mkstemp ()를 호출함으로써 달성됩니다.</target>
        </trans-unit>
        <trans-unit id="c3dee4680a21f3b47b4b6c94d86c7920c11b3ca5" translate="yes" xml:space="preserve">
          <source>When called in scalar context, returns the full name (including path) of a temporary file (uses mktemp()). The only check is that the file does not already exist, but there is no guarantee that that condition will continue to apply.</source>
          <target state="translated">스칼라 컨텍스트에서 호출되면 임시 파일의 전체 이름 (경로 포함)을 리턴합니다 (mktemp () 사용). 유일한 점검은 파일이 아직 존재하지 않지만 해당 조건이 계속 적용된다는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="a89727e96b1fd47a54daec87adf9ead3599db8aa" translate="yes" xml:space="preserve">
          <source>When called on a hash in list context, returns a 2-element list consisting of the key and value for the next element of a hash. In Perl 5.12 and later only, it will also return the index and value for the next element of an array so that you can iterate over it; older Perls consider this a syntax error. When called in scalar context, returns only the key (not the value) in a hash, or the index in an array.</source>
          <target state="translated">목록 컨텍스트의 해시에서 호출되면 해시의 다음 요소에 대한 키와 값으로 구성된 2 요소 목록을 리턴합니다. Perl 5.12 이상에서만 배열의 다음 요소에 대한 색인과 값을 리턴하므로이를 반복 할 수 있습니다. 이전 Perls는이를 구문 오류로 간주합니다. 스칼라 컨텍스트에서 호출되면 해시의 키 (값이 아님) 또는 배열의 인덱스 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a0114581d0437322ee0322acd573e8db3818a675" translate="yes" xml:space="preserve">
          <source>When called with a port number, the port number used to ping is set to $port_number rather than using the echo port. It also has the effect of calling &lt;code&gt;$p-&amp;gt;service_check(1)&lt;/code&gt; causing a ping to return a successful response only if that specific port is accessible. This function returns the value of the port that &lt;code&gt;ping()&lt;/code&gt; will connect to.</source>
          <target state="translated">포트 번호로 호출하면 ping에 사용되는 포트 번호는 에코 포트를 사용하지 않고 $ port_number로 설정됩니다. 또한 특정 포트에 액세스 할 수있는 경우에만 ping이 성공적인 응답을 리턴하도록하는 &lt;code&gt;$p-&amp;gt;service_check(1)&lt;/code&gt; 을 호출하는 효과 가 있습니다. 이 함수는 &lt;code&gt;ping()&lt;/code&gt; 이 연결할 포트 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f7e732b0f6b3939ab5bc51276cb4115c5f3c0e3c" translate="yes" xml:space="preserve">
          <source>When called with a property that is a Perl extension that isn't expressible in a compound form, this function currently returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, as the only two possible values are</source>
          <target state="translated">복합 형식으로 표현할 수없는 Perl 확장명 인 특성으로 호출하면이 함수는 현재 두 가지 가능한 값만 있으므로 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d7f088f6cc700d00236d5621c430de681ccc4d48" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;Mksymlists&lt;/code&gt; , one should always specify the NAME attribute. In most cases, this is all that's necessary. In the case of unusual extensions, however, the other attributes can be used to provide additional information to the linker.</source>
          <target state="translated">&lt;code&gt;Mksymlists&lt;/code&gt; 를 호출 할 때는 항상 NAME 속성을 지정해야합니다. 대부분의 경우 이것이 필요한 전부입니다. 그러나 비정상적인 확장의 경우 다른 속성을 사용하여 추가 정보를 링커에 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb764d0e74f6cde0aeec88532fcd886bfa4b9853" translate="yes" xml:space="preserve">
          <source>When choosing a language you should also be influenced by the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org%2f&quot;&gt;resources&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpantesters.org%2f&quot;&gt;testing culture&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.perl.org%2fcommunity.html&quot;&gt;community&lt;/a&gt; which surrounds it.</source>
          <target state="translated">언어를 선택할 때는 언어, &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org%2f&quot;&gt;환경&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpantesters.org%2f&quot;&gt;문화&lt;/a&gt; 및 &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.perl.org%2fcommunity.html&quot;&gt;지역 사회의&lt;/a&gt; 영향을 받아야 합니다.</target>
        </trans-unit>
        <trans-unit id="28fc2ee6241766189106d0612895f0d6c35cb4ac" translate="yes" xml:space="preserve">
          <source>When choosing a new salt create a random two character string whose characters come from the set &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; (like &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt; '', ('.',
'/', 0..9, 'A'..'Z', 'a'..'z')[&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt; 64, &lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt; 64]&lt;/code&gt; ). This set of characters is just a recommendation; the characters allowed in the salt depend solely on your system's crypt library, and Perl can't restrict what salts &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt()&lt;/a&gt;&lt;/code&gt; accepts.</source>
          <target state="translated">새 솔트를 선택할 때 문자 세트 &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; 에서 나오는 임의의 2 문자열을 만듭니다 (예 : &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt; '', ('.', '/', 0..9, 'A'..'Z', 'a'..'z')[&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt; 64, &lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt; 64]&lt;/code&gt; ). 이 문자 집합은 권장 사항입니다. 솔트에 허용되는 문자는 시스템의 크립 라이브러리에만 의존하며 Perl은 &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt()&lt;/a&gt;&lt;/code&gt; 허용 하는 솔트를 제한 할 수 없습니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
