<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="99b9fdd9de86d1d00f397b16abef1b9cafbc97c4" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;variable&lt;/b&gt; in a language like C that contains the exact memory location of some other item. Perl handles pointers internally so you don&amp;rsquo;t have to worry about them. Instead, you just use symbolic pointers in the form of &lt;b&gt;keys&lt;/b&gt; and &lt;b&gt;variable&lt;/b&gt; names, or &lt;b&gt;hard references&lt;/b&gt;, which aren&amp;rsquo;t pointers (but act like pointers and do in fact contain pointers).</source>
          <target state="translated">다른 항목의 정확한 메모리 위치를 포함하는 C와 같은 언어 의 &lt;b&gt;변수&lt;/b&gt; 입니다. Perl은 포인터를 내부적으로 처리하므로 걱정할 필요가 없습니다. 대신, 포인터 가 아닌 &lt;b&gt;키&lt;/b&gt; 와 &lt;b&gt;변수&lt;/b&gt; 이름 또는 &lt;b&gt;하드 참조&lt;/b&gt; 의 형태로 기호 포인터를 사용하십시오 (그러나 포인터처럼 작동하고 실제로 포인터를 포함합니다).</target>
        </trans-unit>
        <trans-unit id="51c90d619538801ef4598602775b97c77a42912f" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;variable&lt;/b&gt; prefixed with &lt;code&gt;$&lt;/code&gt; that holds a single value.</source>
          <target state="translated">&lt;b&gt;변수&lt;/b&gt; 로 시작 &lt;code&gt;$&lt;/code&gt; 단일 값을 보유하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="a036ff35f0b4159168ba2281ee65e4b238ac5692" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;variable&lt;/b&gt; subject to &lt;b&gt;lexical scoping&lt;/b&gt;, declared by &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;. Often just called a &amp;ldquo;lexical&amp;rdquo;. (The &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration declares a lexically scoped name for a global variable, which is not itself a lexical variable.)</source>
          <target state="translated">&lt;b&gt;변수&lt;/b&gt; 에 따라 &lt;b&gt;어휘 범위 지정&lt;/b&gt; , 선언 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; . 종종 &quot;어휘&quot;라고 불렀습니다. ( &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 선언은 전역 변수에 대한 어휘 범위가 지정된 이름을 선언하는데, 그 자체는 어휘 변수가 아닙니다.)</target>
        </trans-unit>
        <trans-unit id="d364f02d6990848dc623c28306b3b67cfe16a460" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;verbatim paragraph&lt;/b&gt;. The first line of this paragraph must be a literal space or tab, and this paragraph must not be inside a &quot;=begin</source>
          <target state="translated">&lt;b&gt;그대로 단락&lt;/b&gt; . 이 단락의 첫 줄은 문자 그대로의 공백 또는 탭이어야하며이 단락은 &quot;= 시작하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="6c2475be186a7213d2a980a851a800269b2e5a86" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;()&lt;/code&gt; group is a sub-TEMPLATE enclosed in parentheses. A group may take a repeat count either as postfix, or for unpack(), also via the &lt;code&gt;/&lt;/code&gt; template character. Within each repetition of a group, positioning with &lt;code&gt;@&lt;/code&gt; starts over at 0. Therefore, the result of</source>
          <target state="translated">&lt;code&gt;()&lt;/code&gt; 그룹은 괄호 안에 서브 템플릿이다. 그룹은 &lt;code&gt;/&lt;/code&gt; fix 문자 를 통해 postfix 또는 unpack ()에 대해 반복 횟수를 취할 수 있습니다 . 그룹이 반복 될 때마다 &lt;code&gt;@&lt;/code&gt; 로 위치가 0부터 시작합니다. 따라서</target>
        </trans-unit>
        <trans-unit id="a287ce1841efe5bc899e4207e715388b0c45e263" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;*&lt;/code&gt; allows the subroutine to accept a bareword, constant, scalar expression, typeglob, or a reference to a typeglob in that slot. The value will be available to the subroutine either as a simple scalar, or (in the latter two cases) as a reference to the typeglob. If you wish to always convert such arguments to a typeglob reference, use Symbol::qualify_to_ref() as follows:</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 은 서브 루틴이 bareword는 일정한 스칼라 식 타입 글로브, 또는 슬롯의 타입 글로브의 참조를 접수 할 수있다. 이 값은 서브 루틴에 간단한 스칼라로, 또는 후자의 경우에 타입 글로브에 대한 참조로 사용 가능합니다. 이러한 인수를 항상 typeglob 참조로 변환하려면 다음과 같이 Symbol :: qualify_to_ref ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="61da191aeee246a70549905e1a2b4d958c2fd1c9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;*&lt;/code&gt; for the repeat count uses all characters of the input field. For unpack(), nybbles are converted to a string of hexadecimal digits.</source>
          <target state="translated">반복 횟수 의 &lt;code&gt;*&lt;/code&gt; 는 입력 필드의 모든 문자를 사용합니다. unpack ()의 ​​경우, nybbles는 16 진수 문자열로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="815c847c3d1b9e3c91a01ec8d23807326737a6a0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;*&lt;/code&gt; for the repeat count uses all characters of the input field. On unpacking, bits are converted to a string of &lt;code&gt;0&lt;/code&gt; s and &lt;code&gt;1&lt;/code&gt; s.</source>
          <target state="translated">반복 횟수 의 &lt;code&gt;*&lt;/code&gt; 는 입력 필드의 모든 문자를 사용합니다. 언 패킹시 비트는 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;1&lt;/code&gt; 의 문자열로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="89c65ec9d77b183c5b39e5d9c73a8c71422dfc22" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;--&lt;/code&gt; signals the end of options and disables further option processing. Any arguments after the &lt;code&gt;--&lt;/code&gt; are treated as filenames and arguments.</source>
          <target state="translated">A는 &lt;code&gt;--&lt;/code&gt; 옵션 및 상기 비활성화 옵션 처리의 종료 신호를 보낸다. &lt;code&gt;--&lt;/code&gt; 다음의 인수 는 파일 이름과 인수로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="bde6ae184752daa5e5b6a5c7417008782a0b714a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; failure may result in the following tests failing:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 실패 실패 다음 테스트 될 수있다 :</target>
        </trans-unit>
        <trans-unit id="290859ef4b0199eb4b067a5c07f38a6730cc7301" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; is simply a modifier on an lvalue expression. When you assign to a &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ized variable, the &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; doesn't change whether its list is viewed as a scalar or an array. So</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 단순히 좌변 식의 수정이다. 당신이에 할당 할 때 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 화된 변수의 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 그 목록들이 스칼라 나 배열로 보이는 것을 바꾸지 않는다. 그래서</target>
        </trans-unit>
        <trans-unit id="1ac670f70b9818c1a06875d85552011a54fbdd94" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; modifies its listed variables to be &quot;local&quot; to the enclosing block, &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; FILE&lt;/code&gt; --and to</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 수정은 나열된 변수 &quot;로컬&quot;이 둘러싸는 블록을 위해 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 하거나 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; FILE&lt;/code&gt; 에 - 그리고</target>
        </trans-unit>
        <trans-unit id="5e64f0ec46a4ae84b19fc32e43ef29768338a5a4" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; declares the listed variables to be local (lexically) to the enclosing block, file, or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;. If more than one variable is listed, the list must be placed in parentheses.</source>
          <target state="translated">A는 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 나열된 변수는 둘러싸 블록, 파일 또는로 (어휘) 지역으로 선언 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; . 둘 이상의 변수가 나열되면 목록을 괄호 안에 넣어야합니다.</target>
        </trans-unit>
        <trans-unit id="f1479b4bde8f3dbb0c16d564288196fd25f56ff5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; has both a compile-time and a run-time effect. At compile time, the compiler takes notice of it. The principal usefulness of this is to quiet &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; , but it is also essential for generation of closures as detailed in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;. Actual initialization is delayed until run time, though, so it gets executed at the appropriate time, such as each time through a loop, for example.</source>
          <target state="translated">A는 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 컴파일 시간과 런타임 효과를 모두 가지고있다. 컴파일 타임에 컴파일러가이를 주목합니다. 이것의 주요 유용성은 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; 를 조용하게 &lt;a href=&quot;functions/use&quot;&gt;사용하는&lt;/a&gt; 것이지만 &lt;a href=&quot;perlref&quot;&gt;perlref에&lt;/a&gt; 자세히 설명 된대로 클로저 생성에도 필수적입니다 . 그러나 실제 초기화는 런타임까지 지연되므로 루프와 같이 매번 적절한 시간에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="31962f6029a8a1eb17179745d335b5ef4fc0067e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; statement may be used to exit a subroutine, optionally specifying the returned value, which will be evaluated in the appropriate context (list, scalar, or void) depending on the context of the subroutine call. If you specify no return value, the subroutine returns an empty list in list context, the undefined value in scalar context, or nothing in void context. If you return one or more aggregates (arrays and hashes), these will be flattened together into one large indistinguishable list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 명령문 임의로 서브 루틴 호출의 상황에 따라 적절한 컨텍스트 (목록, 스칼라, 또는 공극)에서 평가 될 리턴 값을 지정하는 서브 루틴을 종료하기 위해 사용될 수있다. 리턴 값을 지정하지 않으면 서브 루틴은리스트 컨텍스트에서 빈 목록, 스칼라 컨텍스트에서 정의되지 않은 값 또는 void 컨텍스트에서 아무것도 리턴하지 않습니다. 하나 이상의 집계 (배열 및 해시)를 반환하면 이들을 하나의 큰 구별 할 수없는 목록으로 병합합니다.</target>
        </trans-unit>
        <trans-unit id="0e88bf889822c4c5cba2a75e272c3a1e9aeaadd3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; declares the listed variables to be local (lexically) to the enclosing block, file, or &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;. If more than one variable is listed, the list must be placed in parentheses.</source>
          <target state="translated">A는 &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 나열된 변수는 둘러싸 블록, 파일 또는로 (어휘) 지역으로 선언 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; . 둘 이상의 변수가 나열되면 목록을 괄호 안에 넣어야합니다.</target>
        </trans-unit>
        <trans-unit id="4e47480cd5deac560f9564740a3fdd3588ea30d3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;=begin&lt;/code&gt; command was found that is not followed by the formatter specification.</source>
          <target state="translated">&lt;code&gt;=begin&lt;/code&gt; 명령이 포맷터 사양에 따르지 것을 알 수 있었다.</target>
        </trans-unit>
        <trans-unit id="5a9827f3a3a35194fce6eb84ce82e990f6ef9b53" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;=cut&lt;/code&gt; command was found without a preceding POD paragraph.</source>
          <target state="translated">&lt;code&gt;=cut&lt;/code&gt; 명령은 이전 POD 단락없이 발견되었다.</target>
        </trans-unit>
        <trans-unit id="4af95277282f9dbbdb980c39fe078720a20bab01" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;=pod&lt;/code&gt; command was found after a preceding POD paragraph.</source>
          <target state="translated">&lt;code&gt;=pod&lt;/code&gt; 명령은 이전 POD의 단락 뒤에 발견되었다.</target>
        </trans-unit>
        <trans-unit id="31f4edd1c949bdbda291e425d6bef6044643ffd6" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;BEGIN&lt;/code&gt; code block is executed as soon as possible, that is, the moment it is completely defined, even before the rest of the containing file (or string) is parsed. You may have multiple &lt;code&gt;BEGIN&lt;/code&gt; blocks within a file (or eval'ed string); they will execute in order of definition. Because a &lt;code&gt;BEGIN&lt;/code&gt; code block executes immediately, it can pull in definitions of subroutines and such from other files in time to be visible to the rest of the compile and run time. Once a &lt;code&gt;BEGIN&lt;/code&gt; has run, it is immediately undefined and any code it used is returned to Perl's memory pool.</source>
          <target state="translated">A는 &lt;code&gt;BEGIN&lt;/code&gt; 코드 블록은 가능한 한 빨리이라고로 실행, 그것은 완전히 정의 된 순간에도 포함 파일 (또는 문자열)의 나머지 전에 구문 분석됩니다. 파일 (또는 평가 문자열) 내에 여러 &lt;code&gt;BEGIN&lt;/code&gt; 블록 이있을 수 있습니다 . 정의 순서대로 실행됩니다. &lt;code&gt;BEGIN&lt;/code&gt; 코드 블록은 즉시 실행 되기 때문에 다른 컴파일 및 런타임에서 볼 수 있도록 다른 파일에서 서브 루틴의 정의를 가져올 수 있습니다. &lt;code&gt;BEGIN&lt;/code&gt; 이 실행 되면 즉시 정의되지 않으며 사용 된 모든 코드가 Perl의 메모리 풀로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="3948c72682ed13a39df444bd90a131ad77b87fa0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;File::Fetch&lt;/code&gt; object has the following accessors</source>
          <target state="translated">&lt;code&gt;File::Fetch&lt;/code&gt; 객체는 다음과 같은 접근이있다</target>
        </trans-unit>
        <trans-unit id="a0df5f12010c9e2a341950853965986995045017" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;MAYBE&lt;/code&gt; string should contain at least one combining character or the like. For example, &lt;code&gt;COMBINING ACUTE ACCENT&lt;/code&gt; has the MAYBE_NFC/MAYBE_NFKC property.</source>
          <target state="translated">&lt;code&gt;MAYBE&lt;/code&gt; 문자열 등 적어도 하나 개의 결합 문자 또는 포함되어야합니다. 예를 들어, &lt;code&gt;COMBINING ACUTE ACCENT&lt;/code&gt; 에는 MAYBE_NFC / MAYBE_NFKC 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9aa930129748b8e7f36983538600e4ef3003dd2" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;NUL&lt;/code&gt; character will be written after the end of the string.</source>
          <target state="translated">&lt;code&gt;NUL&lt;/code&gt; 의 문자는 문자열의 끝 이후에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="14e49abd4463a2df704c3d0c251781f20f08e519" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;PerlIOl *&lt;/code&gt; is a pointer to the struct, and the</source>
          <target state="translated">&lt;code&gt;PerlIOl *&lt;/code&gt; 는 구조체에 대한 포인터이며,</target>
        </trans-unit>
        <trans-unit id="e73ed792e4d7284609d9e1372b30eccc321faca0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SelectSaver&lt;/code&gt; object contains a reference to the file handle that was selected when it was created. If its &lt;code&gt;new&lt;/code&gt; method gets an extra parameter, then that parameter is selected; otherwise, the selected file handle remains unchanged.</source>
          <target state="translated">&lt;code&gt;SelectSaver&lt;/code&gt; 의 오브젝트가 생성 될 때 선택된 파일 핸들에 대한 참조를 포함한다. &lt;code&gt;new&lt;/code&gt; 메소드에 추가 매개 변수가 있으면 해당 매개 변수가 선택됩니다. 그렇지 않으면 선택한 파일 핸들이 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="57c30b7d6b5dae1d9e52bc3dfa57d215caf5d862" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;[&lt;/code&gt; is not special inside a character class, unless it's the start of a POSIX character class (see &lt;a href=&quot;#POSIX-Character-Classes&quot;&gt;POSIX Character Classes&lt;/a&gt; below). It normally does not need escaping.</source>
          <target state="translated">A는 &lt;code&gt;[&lt;/code&gt; 그것이 POSIX 문자 클래스의 시작이다 (참조하지 않는 한, 문자 클래스 내부에 특별한되지 않습니다 &lt;a href=&quot;#POSIX-Character-Classes&quot;&gt;POSIX 문자 클래스&lt;/a&gt; 아래 참조). 일반적으로 이스케이프 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="6776cbbe11f1658efaaee2f3dd38010bf8c93b32" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;\L&lt;/code&gt; or &lt;code&gt;\U&lt;/code&gt; indicates a lasting conversion of case, until terminated by &lt;code&gt;\E&lt;/code&gt; or thrown over by another &lt;code&gt;\U&lt;/code&gt; or &lt;code&gt;\L&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;\L&lt;/code&gt; 또는 &lt;code&gt;\U&lt;/code&gt; 종료 될 때까지, 케이스의 지속 변환을 나타냅니다 &lt;code&gt;\E&lt;/code&gt; 또는 다른 의해 던져 &lt;code&gt;\U&lt;/code&gt; 또는 &lt;code&gt;\L&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="eb525767ec147f71507ec3fe5c0bbfd43e23622a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;\w&lt;/code&gt; matches a single alphanumeric character (an alphabetic character, or a decimal digit); or a connecting punctuation character, such as an underscore (&quot;_&quot;); or a &quot;mark&quot; character (like some sort of accent) that attaches to one of those. It does not match a whole word. To match a whole word, use &lt;code&gt;\w+&lt;/code&gt; . This isn't the same thing as matching an English word, but in the ASCII range it is the same as a string of Perl-identifier characters.</source>
          <target state="translated">&lt;code&gt;\w&lt;/code&gt; 일치 한 영숫자 문자 (영문자, 또는 십진수 자리); 또는 밑줄 ( &quot;_&quot;)과 같은 연결 구두점 문자; 또는 그중 하나에 부착되는 &quot;마크&quot;문자 (일부 악센트와 같은). 전체 단어와 일치하지 않습니다. 전체 단어를 일치 시키려면 &lt;code&gt;\w+&lt;/code&gt; . 이것은 영어 단어와 일치하는 것과 같지 않지만 ASCII 범위에서는 Perl-identifier 문자의 문자열과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="387f0590ce374c162a12f59ad2a352b45a0b6a2e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;]&lt;/code&gt; is normally either the end of a POSIX character class (see &lt;a href=&quot;#POSIX-Character-Classes&quot;&gt;POSIX Character Classes&lt;/a&gt; below), or it signals the end of the bracketed character class. If you want to include a &lt;code&gt;]&lt;/code&gt; in the set of characters, you must generally escape it.</source>
          <target state="translated">A &lt;code&gt;]&lt;/code&gt; 는 일반적으로 POSIX 문자 클래스의 끝 (아래 &lt;a href=&quot;#POSIX-Character-Classes&quot;&gt;POSIX 문자 클래스&lt;/a&gt; 참조)이거나 대괄호 문자 클래스의 끝을 나타냅니다. 문자 세트에 &lt;code&gt;]&lt;/code&gt; 를 포함 시키려면 일반적으로 이스케이프해야합니다.</target>
        </trans-unit>
        <trans-unit id="2a086836899301702e84e6ebfd5a64e6e1514ec1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;clean&lt;/code&gt; command results in a</source>
          <target state="translated">&lt;code&gt;clean&lt;/code&gt; 명령은 결과</target>
        </trans-unit>
        <trans-unit id="f82e2956ae874578dae0b862a6205fc9ad9a10d8" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;quiet&lt;/code&gt; parameter tells &lt;code&gt;CBuilder&lt;/code&gt; to not print its &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; commands before executing them:</source>
          <target state="translated">&lt;code&gt;quiet&lt;/code&gt; 매개 변수는 알 수 &lt;code&gt;CBuilder&lt;/code&gt; 를 자사의 인쇄하지 않는 &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 을 실행하기 전에 명령을 :</target>
        </trans-unit>
        <trans-unit id="537fa0e7c3fc8f4f2ff13df46f07e5efa8b0d873" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;regexp_paren_pair&lt;/code&gt; structure which defines offsets into the string being matched which correspond to the &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; etc. captures, the &lt;code&gt;regexp_paren_pair&lt;/code&gt; struct is defined as follows:</source>
          <target state="translated">&lt;code&gt;$&amp;amp;&lt;/code&gt; 및 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; 등의 캡처에 해당하는 일치하는 문자열에 오프셋을 정의 하는 &lt;code&gt;regexp_paren_pair&lt;/code&gt; 구조 , &lt;code&gt;regexp_paren_pair&lt;/code&gt; 구조체는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="9187cecc86ed031f1a1d91cbbf85586329ad9482" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;typedef&lt;/code&gt; will be created for &lt;code&gt;struct netconfig&lt;/code&gt; . The Perl object will be blessed in a class matching the name of the C type, with the tag &lt;code&gt;Ptr&lt;/code&gt; appended, and the name should not have embedded spaces if it will be a Perl package name. The destructor will be placed in a class corresponding to the class of the object and the PREFIX keyword will be used to trim the name to the word DESTROY as Perl will expect.</source>
          <target state="translated">&lt;code&gt;typedef&lt;/code&gt; 생성됩니다 &lt;code&gt;struct netconfig&lt;/code&gt; . Perl 객체는 태그 &lt;code&gt;Ptr&lt;/code&gt; 이 추가 된 C 유형의 이름과 일치하는 클래스에서 제공 되며 Perl 패키지 이름 인 경우 이름에 공백이 없어야합니다. 소멸자는 객체의 클래스에 해당하는 클래스에 배치되고 PREFIX 키워드는 Perl이 예상하는대로 DESTROY라는 단어로 이름을 자르는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="91a29e0934f06be58e8f45f6ccaf516ef19ec003" translate="yes" xml:space="preserve">
          <source>A B::HV object representing the stash for 'our' variables.</source>
          <target state="translated">'우리'변수에 대한 숨김을 나타내는 AB :: HV 객체.</target>
        </trans-unit>
        <trans-unit id="f45e12c8a06cbfbc829397737665446dbd9373fc" translate="yes" xml:space="preserve">
          <source>A B::HV object representing the stash for a typed lexical.</source>
          <target state="translated">유형화 된 어휘에 대한 숨김을 나타내는 AB :: HV 오브젝트.</target>
        </trans-unit>
        <trans-unit id="42fcd5050adf426bbdb7192c3683fb606974ed22" translate="yes" xml:space="preserve">
          <source>A BLOCK by itself (labeled or not) is semantically equivalent to a loop that executes once. Thus you can use any of the loop control statements in it to leave or restart the block. (Note that this is</source>
          <target state="translated">BLOCK 자체 (표지 여부)는 의미 적으로 한 번 실행되는 루프와 동일합니다. 따라서 루프 제어문을 사용하여 블록을 종료하거나 재시작 할 수 있습니다. (이것은</target>
        </trans-unit>
        <trans-unit id="0b3fa7a6472c1947a3e3fb9a265bfaa097653d2a" translate="yes" xml:space="preserve">
          <source>A Build.PL is run by perl in a separate process. Likewise we run './Build' and './Build install' in separate processes. If you have any parameters you want to pass to the calls, please specify them here.</source>
          <target state="translated">Build.PL은 별도의 프로세스에서 perl에 의해 실행됩니다. 마찬가지로 './Build'와 './Build install'을 별도의 프로세스에서 실행합니다. 통화에 전달할 매개 변수가있는 경우 여기에 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="2b8f77588c05a56fb0aa83c01416be422180616b" translate="yes" xml:space="preserve">
          <source>A C expression for the value of the constant, or a list of C expressions if the type is aggregate. This defaults to the</source>
          <target state="translated">상수 값에 대한 AC 표현식 또는 유형이 집계 인 경우 C 표현식 목록. 기본값은</target>
        </trans-unit>
        <trans-unit id="c9bca895b6521acf14049f748fb255c795b1e71c" translate="yes" xml:space="preserve">
          <source>A CASE: might switch via a parameter of the XSUB, via the &lt;code&gt;ix&lt;/code&gt; ALIAS: variable (see &lt;a href=&quot;#The-ALIAS%3a-Keyword&quot;&gt;The ALIAS: Keyword&lt;/a&gt;), or maybe via the &lt;code&gt;items&lt;/code&gt; variable (see &lt;a href=&quot;#Variable-length-Parameter-Lists&quot;&gt;Variable-length Parameter Lists&lt;/a&gt;). The last CASE: becomes the &lt;b&gt;default&lt;/b&gt; case if it is not associated with a conditional. The following example shows CASE switched via &lt;code&gt;ix&lt;/code&gt; with a function &lt;code&gt;rpcb_gettime()&lt;/code&gt; having an alias &lt;code&gt;x_gettime()&lt;/code&gt; . When the function is called as &lt;code&gt;rpcb_gettime()&lt;/code&gt; its parameters are the usual &lt;code&gt;(char *host, time_t *timep)&lt;/code&gt; , but when the function is called as &lt;code&gt;x_gettime()&lt;/code&gt; its parameters are reversed, &lt;code&gt;(time_t *timep, char *host)&lt;/code&gt; .</source>
          <target state="translated">경우는 다음 경유하여 XSUB의 매개 변수를 통해 전환 할 수도 있습니다 &lt;code&gt;ix&lt;/code&gt; ALIAS : 변수 (참조 &lt;a href=&quot;#The-ALIAS%3a-Keyword&quot;&gt;별칭 : 키워드&lt;/a&gt; ) 또는 어쩌면 통해 &lt;code&gt;items&lt;/code&gt; 변수 (참조 &lt;a href=&quot;#Variable-length-Parameter-Lists&quot;&gt;가변 길이 매개 변수리스트&lt;/a&gt; ). 마지막 CASE : 조건과 연결되지 않은 경우 &lt;b&gt;기본&lt;/b&gt; 사례가됩니다. 다음 예는 별명이 &lt;code&gt;x_gettime()&lt;/code&gt; &lt;code&gt;rpcb_gettime()&lt;/code&gt; 함수 를 사용하여 &lt;code&gt;ix&lt;/code&gt; 를 통해 전환 된 CASE를 보여줍니다 . 함수가 &lt;code&gt;rpcb_gettime()&lt;/code&gt; 으로 호출되면 해당 매개 변수는 일반적인 &lt;code&gt;(char *host, time_t *timep)&lt;/code&gt; 이지만 함수가 &lt;code&gt;x_gettime()&lt;/code&gt; 으로 호출되면 매개 변수가 반대로 설정됩니다. &lt;code&gt;(time_t *timep, char *host)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c55f978db59708209a54d8bfb17d98c3ae019b46" translate="yes" xml:space="preserve">
          <source>A CPAN mirror that includes just the latest versions for each distribution, probably created with &lt;code&gt;CPAN::Mini&lt;/code&gt; . See Camel chapter 19, &amp;ldquo;CPAN&amp;rdquo;.</source>
          <target state="translated">&lt;code&gt;CPAN::Mini&lt;/code&gt; 작성된 각 분배에 대한 최신 버전 만 포함하는 CPAN 미러 . 낙타 19 장 &quot;CPAN&quot;을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d79fea87c96ec94013ff8e4540cf4e641c3aa0b8" translate="yes" xml:space="preserve">
          <source>A Class is Simply a Package</source>
          <target state="translated">클래스는 단순히 패키지입니다</target>
        </trans-unit>
        <trans-unit id="59bd5b6c5b1f4d50bad57e4bae0c86bf7e63ff03" translate="yes" xml:space="preserve">
          <source>A Complete Example</source>
          <target state="translated">완전한 예</target>
        </trans-unit>
        <trans-unit id="9f22eaf2aa717bb5924e306e9ab40bd24eefc92a" translate="yes" xml:space="preserve">
          <source>A DBM Filter allows the keys and/or values in a tied hash to be modified by some user-defined code just before it is written to the DBM file and just after it is read back from the DBM file. For example, this snippet of code</source>
          <target state="translated">DBM 필터를 사용하면 DBM 파일에 쓰여지기 직전 및 DBM 파일에서 다시 읽은 직후에 일부 사용자 정의 코드로 묶인 해시의 키 및 / 또는 값을 수정할 수 있습니다. 예를 들어이 코드 스 니펫</target>
        </trans-unit>
        <trans-unit id="a3dd10dc1183e2df3ed7ea791b7d9b7560ba9d95" translate="yes" xml:space="preserve">
          <source>A DBM Filter is a piece of code that is be used when you</source>
          <target state="translated">DBM 필터는 사용자가 사용할 때 사용되는 코드입니다</target>
        </trans-unit>
        <trans-unit id="74127e4dc0844d9e1d0d37669c77b5e1d7d7dc1c" translate="yes" xml:space="preserve">
          <source>A GV is a structure which corresponds to to a Perl typeglob, ie *foo. It is a structure that holds a pointer to a scalar, an array, a hash etc, corresponding to $foo, @foo, %foo.</source>
          <target state="translated">GV는 Perl typeglob, 즉 * foo에 해당하는 구조입니다. $ foo, @foo, % foo에 해당하는 스칼라, 배열, 해시 등에 대한 포인터를 보유하는 구조입니다.</target>
        </trans-unit>
        <trans-unit id="13db893228041bbd750755e5ceeab1edf73eb3b3" translate="yes" xml:space="preserve">
          <source>A Graeco-Roman word meaning &amp;ldquo;to bring oneself to life&amp;rdquo;. In Perl, storage locations (&lt;b&gt;lvalues&lt;/b&gt;) spontaneously generate themselves as needed, including the creation of any &lt;b&gt;hard reference&lt;/b&gt; values to point to the next level of storage. The assignment &lt;code&gt;$a[5][5][5][5][5] = &quot;quintet&quot;&lt;/code&gt; potentially creates five scalar storage locations, plus four references (in the first four scalar locations) pointing to four new anonymous arrays (to hold the last four scalar locations). But the point of autovivification is that you don&amp;rsquo;t have to worry about it.</source>
          <target state="translated">&amp;ldquo;자신에게 생명을 불어 넣다&amp;rdquo;를 의미하는 Graeco- 로마 단어. Perl에서 스토리지 위치 ( &lt;b&gt;lvalue&lt;/b&gt; ) 는 다음 레벨의 스토리지를 가리키는 &lt;b&gt;하드 참조&lt;/b&gt; 값 작성을 포함하여 필요에 따라 자발적으로 생성됩니다 . 대입 &lt;code&gt;$a[5][5][5][5][5] = &quot;quintet&quot;&lt;/code&gt; 잠재적으로 5 개의 스칼라 저장 위치와 4 개의 새로운 익명 배열을 가리키는 4 개의 참조 (처음 4 개의 스칼라 위치)를 생성합니다. 마지막 네 스칼라 위치). 그러나 자동 생존의 요점은 걱정할 필요가 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="644fba68887f0f6c83a3c9ad6b03efeafe64485f" translate="yes" xml:space="preserve">
          <source>A HV structure represents a Perl hash. It consists mainly of an array of pointers, each of which points to a linked list of HE structures. The array is indexed by the hash function of the key, so each linked list represents all the hash entries with the same hash value. Each HE contains a pointer to the actual value, plus a pointer to a HEK structure which holds the key and hash value.</source>
          <target state="translated">HV 구조는 Perl 해시를 나타냅니다. 주로 포인터 배열로 구성되며 각 포인터는 HE 구조의 연결된 목록을 가리 킵니다. 배열은 키의 해시 함수에 의해 색인화되므로 링크 된 각 목록은 동일한 해시 값을 가진 모든 해시 항목을 나타냅니다. 각 HE는 실제 값에 대한 포인터와 키 및 해시 값을 보유하는 HEK 구조에 대한 포인터를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="01232ff6c4ca9ea380827b743047b1207b0966c9" translate="yes" xml:space="preserve">
          <source>A Method is Simply a Subroutine</source>
          <target state="translated">방법은 단순히 서브 루틴입니다</target>
        </trans-unit>
        <trans-unit id="4fc1e89e0ebaf9800ac39a369b83b7a80fc77ec4" translate="yes" xml:space="preserve">
          <source>A Note about the Examples</source>
          <target state="translated">실시 예에 관한 주</target>
        </trans-unit>
        <trans-unit id="0d72d9979807c702328842043bb2529c640d1c5d" translate="yes" xml:space="preserve">
          <source>A Notify parameter of 'DELAY' &quot;indicates the sender's willingness to receive delayed DSNs. Delayed DSNs may be issued if delivery of a message has been delayed for an unusual amount of time (as determined by the Message Transfer Agent (MTA) at which the message is delayed), but the final delivery status (whether successful or failure) cannot be determined. The absence of the DELAY keyword in a NOTIFY parameter requests that a &quot;delayed&quot; DSN NOT be issued under any conditions.&quot;</source>
          <target state="translated">'DELAY'의 알림 매개 변수는 &quot;발송인이 지연된 DSN을 수신 할 의사가 있음을 나타냅니다. 지연된 DSN은 메시지 배달이 비정상적인 시간 동안 지연된 경우 (메시지 전송 에이전트 (MTA)에 의해 결정됨) 메시지가 지연되지만 최종 배송 상태 (성공 또는 실패 여부)를 확인할 수 없습니다. NOTIFY 매개 변수에 DELAY 키워드가 없으면 &quot;지연된&quot;DSN이 어떤 조건에서도 발행되지 않도록 요청합니다. &quot;</target>
        </trans-unit>
        <trans-unit id="9dbcef065eab9753a6c0d2e89dd406c9f007951b" translate="yes" xml:space="preserve">
          <source>A Notify parameter of 'SUCCESS' or 'FAILURE' &quot;requests that a DSN be issued on successful delivery or delivery failure, respectively.&quot;</source>
          <target state="translated">'SUCCESS'또는 'FAILURE'의 알림 매개 변수는 &quot;성공적인 배달 또는 배달 실패시 각각 DSN을 발행하도록 요청합니다.&quot;</target>
        </trans-unit>
        <trans-unit id="c3f40c0f83e1e526b0b0b6c66a8b36e802555138" translate="yes" xml:space="preserve">
          <source>A Perl extension to the POSIX character class is the ability to negate it. This is done by prefixing the class name with a caret (&lt;code&gt;^&lt;/code&gt;). Some examples:</source>
          <target state="translated">POSIX 문자 클래스에 대한 Perl 확장은이를 무효화하는 기능입니다. 이것은 클래스 이름 앞에 캐럿 ( &lt;code&gt;^&lt;/code&gt; ) 을 붙여서 수행됩니다 . 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="0d2d7129fe49ff692643bf989abc3c8db9550c7a" translate="yes" xml:space="preserve">
          <source>A Perl floating point number. Similar to T_IV and T_UV in that the return type is cast to the requested numeric type rather than to a specific type.</source>
          <target state="translated">Perl 부동 소수점 숫자 리턴 유형이 특정 유형이 아닌 요청 된 숫자 유형으로 캐스트된다는 점에서 T_IV 및 T_UV와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="baf019a8a8ab4371dcf7bafbfc9ccbe01c8c24c2" translate="yes" xml:space="preserve">
          <source>A Perl module that also pulls in &lt;b&gt;compiled&lt;/b&gt; C or C++ code. More generally, any experimental option that can be &lt;b&gt;compiled&lt;/b&gt; into Perl, such as multithreading.</source>
          <target state="translated">&lt;b&gt;컴파일 된&lt;/b&gt; C 또는 C ++ 코드를 가져 오는 Perl 모듈 . 보다 일반적 으로 멀티 스레딩과 같이 Perl 로 &lt;b&gt;컴파일&lt;/b&gt; 할 수있는 모든 실험 옵션 .</target>
        </trans-unit>
        <trans-unit id="d50862820d3a8aab33b93133b7d33cb935834ef5" translate="yes" xml:space="preserve">
          <source>A Perl pattern that allows the disambiguation of long and short prefixes. Default is &lt;code&gt;--&lt;/code&gt; .</source>
          <target state="translated">길고 짧은 접두사를 명확하게하는 Perl 패턴. 기본값은 &lt;code&gt;--&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2e904ead9b94d6204fd6b39a939871c992e738f5" translate="yes" xml:space="preserve">
          <source>A Perl pattern that identifies the strings that introduce options. Default is &lt;code&gt;--|-|\+&lt;/code&gt; unless environment variable POSIXLY_CORRECT has been set, in which case it is &lt;code&gt;--|-&lt;/code&gt;.</source>
          <target state="translated">옵션을 소개하는 문자열을 식별하는 Perl 패턴. 환경 변수 POSIXLY_CORRECT가 설정되지 않은 경우 기본값은 &lt;code&gt;--|-|\+&lt;/code&gt; 이며,이 경우 &lt;code&gt;--|-&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="45c72c917209e7e654e9e53f35f4bca27fd858cf" translate="yes" xml:space="preserve">
          <source>A Perl program consists of a sequence of declarations and statements which run from the top to the bottom. Loops, subroutines, and other control structures allow you to jump around within the code.</source>
          <target state="translated">Perl 프로그램은 위에서 아래로 실행되는 일련의 선언 및 명령문으로 구성됩니다. 루프, 서브 루틴 및 기타 제어 구조를 사용하면 코드 내에서 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f1d991ccec8e09953b3e8579dace5ef70ea0563" translate="yes" xml:space="preserve">
          <source>A Perl program executes only once, not once for each input line. You can do an implicit loop with &lt;code&gt;-n&lt;/code&gt; or &lt;code&gt;-p&lt;/code&gt; .</source>
          <target state="translated">Perl 프로그램은 각 입력 라인에 대해 한 번이 아니라 한 번만 실행됩니다. &lt;code&gt;-n&lt;/code&gt; 또는 &lt;code&gt;-p&lt;/code&gt; 로 내재 된 루프를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b05351cbee8badd4677882f72f83a69a3c04e972" translate="yes" xml:space="preserve">
          <source>A Perl program to do these tasks takes the basic form of opening a file, printing its lines, then closing the file:</source>
          <target state="translated">이러한 작업을 수행하는 Perl 프로그램은 파일을 열고, 행을 인쇄 한 다음 파일을 닫는 기본 형식을 취합니다.</target>
        </trans-unit>
        <trans-unit id="9f85dbe5a418fb4bcdecb47b2f0b2cac2a377668" translate="yes" xml:space="preserve">
          <source>A Perl script or program consists of one or more statements. These statements are simply written in the script in a straightforward fashion. There is no need to have a &lt;code&gt;main()&lt;/code&gt; function or anything of that kind.</source>
          <target state="translated">Perl 스크립트 또는 프로그램은 하나 이상의 명령문으로 구성됩니다. 이 진술은 간단하게 대본으로 간단하게 작성됩니다. &lt;code&gt;main()&lt;/code&gt; 함수 나 그와 같은 것을 가질 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="ab689318c03ebde720ae51176a11effea3a569dc" translate="yes" xml:space="preserve">
          <source>A Perl user group, taking the form of its name from the New York Perl mongers, the first Perl user group. Find one near you at &lt;a href=&quot;http://www.pm.org&quot;&gt;http://www.pm.org&lt;/a&gt;.</source>
          <target state="translated">첫 번째 Perl 사용자 그룹 인 New York Perl mongers에서 이름 형식을 사용하는 Perl 사용자 그룹. &lt;a href=&quot;http://www.pm.org&quot;&gt;http://www.pm.org&lt;/a&gt; 에서 가까운 곳을 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="eefc3e21c06e6017f8c10a8bb69ea540ab281b02" translate="yes" xml:space="preserve">
          <source>A Pod formatter may also note, in a comment or warning, a list of what unrenderable characters were encountered.</source>
          <target state="translated">포드 포맷터는 코멘트 나 경고에서 어떤 렌더링 할 수없는 문자의 목록을 기록 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="90bcd0d55b890352044335ec7ff338d09cd4b9d1" translate="yes" xml:space="preserve">
          <source>A Pod processor may signal that the above (specifically the &quot;=head1&quot; paragraph) is an error. Note, however, that the following should</source>
          <target state="translated">포드 프로세서는 상기 (특히 &quot;= head1&quot;단락)가 에러임을 신호 할 수있다. 그러나 다음 사항에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="185a19a7a82d49a0358676fb031bca8138fc5f0d" translate="yes" xml:space="preserve">
          <source>A Rename script</source>
          <target state="translated">이름 바꾸기 스크립트</target>
        </trans-unit>
        <trans-unit id="bb0e1d56b4fab0cf7a60aa29b48524e0458e7730" translate="yes" xml:space="preserve">
          <source>A Simple Client</source>
          <target state="translated">간단한 고객</target>
        </trans-unit>
        <trans-unit id="b671ac0d028246c423146116e7e15964cde16b69" translate="yes" xml:space="preserve">
          <source>A Simple Example</source>
          <target state="translated">간단한 예</target>
        </trans-unit>
        <trans-unit id="35d2688dd60f4771865d489a975386b1e2e85efc" translate="yes" xml:space="preserve">
          <source>A Social Contract about Artistic Control</source>
          <target state="translated">예술적 통제에 관한 사회 계약</target>
        </trans-unit>
        <trans-unit id="ce9f49f53bf8557e68c16a6cb0cab50ed319c852" translate="yes" xml:space="preserve">
          <source>A Solution</source>
          <target state="translated">해결책</target>
        </trans-unit>
        <trans-unit id="33b832366f848ffdd1c9a8efe9f8d3f20e39c539" translate="yes" xml:space="preserve">
          <source>A TAP</source>
          <target state="translated">손가락으로하는 가벼운 터치</target>
        </trans-unit>
        <trans-unit id="f5889f236a4188d2629daf331b9d72acfd600c43" translate="yes" xml:space="preserve">
          <source>A TAP parser consumes input from a single</source>
          <target state="translated">TAP 파서는 하나의 입력을 소비합니다.</target>
        </trans-unit>
        <trans-unit id="7010880f6ae20816985e9d146f66cebdc5b3456f" translate="yes" xml:space="preserve">
          <source>A TAP parser creates &lt;a href=&quot;parser/result&quot;&gt;TAP::Parser::Result&lt;/a&gt;s as it iterates through the input</source>
          <target state="translated">TAP 파서 는 입력을 반복 할 때 &lt;a href=&quot;parser/result&quot;&gt;TAP :: Parser :: Result를&lt;/a&gt; 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="cbc0d3fb42afd0ba8dd15a85a63c440071f45982" translate="yes" xml:space="preserve">
          <source>A TAP parser uses</source>
          <target state="translated">TAP 파서는</target>
        </trans-unit>
        <trans-unit id="c7adba530805a495085a55a74870dea40f6e16bc" translate="yes" xml:space="preserve">
          <source>A TAP source &amp;amp; meta data about it</source>
          <target state="translated">TAP 소스 및 메타 데이터</target>
        </trans-unit>
        <trans-unit id="92ce2bc3533d042b851a960d43bdd7c40fb70ee1" translate="yes" xml:space="preserve">
          <source>A TERM has the highest precedence in Perl. They include variables, quote and quote-like operators, any expression in parentheses, and any function whose arguments are parenthesized. Actually, there aren't really functions in this sense, just list operators and unary operators behaving as functions because you put parentheses around the arguments. These are all documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;.</source>
          <target state="translated">TERM은 Perl에서 가장 우선 순위가 높습니다. 여기에는 변수, 따옴표 및 따옴표와 같은 연산자, 괄호 안의 표현식 및 인수가 괄호로 묶인 함수가 포함됩니다. 실제로, 이러한 의미에서 실제로 함수가있는 것은 아닙니다. 인수 주위에 괄호를두기 때문에 함수로 동작하는 연산자와 단항 연산자 만 나열하면됩니다. 이것들은 모두 &lt;a href=&quot;perlfunc&quot;&gt;perlfunc에&lt;/a&gt; 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="83c2c3a67955f622ae2a621c93e51552fb8bf822" translate="yes" xml:space="preserve">
          <source>A Thread Pitfall: Deadlocks</source>
          <target state="translated">스레드 함정 : 교착 상태</target>
        </trans-unit>
        <trans-unit id="54dda450dbc946f563a52bcd0e2371c672a57c0d" translate="yes" xml:space="preserve">
          <source>A UCM file looks like this.</source>
          <target state="translated">UCM 파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="311a8f73aa0632dde20a979ee931fae45488ea90" translate="yes" xml:space="preserve">
          <source>A Unicode</source>
          <target state="translated">유니 코드</target>
        </trans-unit>
        <trans-unit id="636617240302996a8f020159cb2e15c959a81dd5" translate="yes" xml:space="preserve">
          <source>A Unicode boundary (&lt;code&gt;\b{}&lt;/code&gt; ), available starting in v5.22, is a spot between two characters, or before the first character in the string, or after the final character in the string where certain criteria defined by Unicode are met. See &lt;a href=&quot;perlrebackslash#%5cb%7b%7d%2c-%5cb%2c-%5cB%7b%7d%2c-%5cB&quot;&gt;\b{}, \b, \B{}, \B in perlrebackslash&lt;/a&gt; for details.</source>
          <target state="translated">v5.22부터 사용 가능한 유니 코드 경계 ( &lt;code&gt;\b{}&lt;/code&gt; )는 두 문자 사이 또는 문자열의 첫 문자 앞 또는 문자열의 마지막 문자 뒤에 유니 코드로 정의 된 특정 기준이 충족되는 지점입니다. 자세한 내용 &lt;a href=&quot;perlrebackslash#%5cb%7b%7d%2c-%5cb%2c-%5cB%7b%7d%2c-%5cB&quot;&gt;은 perlrebackslash에서 \ b {}, \ b, \ B {}, \ B&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fd6ccb5c3173a4892e5e2944faba0f70f7b55ac3" translate="yes" xml:space="preserve">
          <source>A Unicode linebreak matches the two-character CRLF grapheme or any of seven vertical whitespace characters. Good for dealing with textfiles coming from different operating systems.</source>
          <target state="translated">유니 코드 줄 바꿈은 2 문자 CRLF 그래프 또는 7 개의 수직 공백 문자와 일치합니다. 다른 운영 체제에서 오는 텍스트 파일을 처리하는 데 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d796a3e99a29b5e8798e5ee8787d53dec284ccde" translate="yes" xml:space="preserve">
          <source>A Webget Client</source>
          <target state="translated">웹겟 클라이언트</target>
        </trans-unit>
        <trans-unit id="625ef9e7e1c1fa35b033333425cc32cf0c3ed6bf" translate="yes" xml:space="preserve">
          <source>A backslash sequence is a sequence of characters, the first one of which is a backslash. Perl ascribes special meaning to many such sequences, and some of these are character classes. That is, they match a single character each, provided that the character belongs to the specific set of characters defined by the sequence.</source>
          <target state="translated">백 슬래시 시퀀스는 문자 시퀀스이며, 첫 번째는 백 슬래시입니다. Perl은 이러한 많은 시퀀스에 특별한 의미를 부여하며 그 중 일부는 문자 클래스입니다. 즉, 문자가 시퀀스에 의해 정의 된 특정 문자 세트에 속하는 경우 각각 단일 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="0a7351fee5999f66ec79553b15a43f5d86c41d6e" translate="yes" xml:space="preserve">
          <source>A backward-compatibility alias for TYPE.</source>
          <target state="translated">TYPE의 하위 호환성 별칭</target>
        </trans-unit>
        <trans-unit id="f7fb814e1c2c79d0e734419e57ea9495c267d50e" translate="yes" xml:space="preserve">
          <source>A backward-compatible version of &lt;code&gt;GIMME_V&lt;/code&gt; which can only return &lt;code&gt;G_SCALAR&lt;/code&gt; or &lt;code&gt;G_ARRAY&lt;/code&gt; ; in a void context, it returns &lt;code&gt;G_SCALAR&lt;/code&gt; . Deprecated. Use &lt;code&gt;GIMME_V&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;G_SCALAR&lt;/code&gt; 또는 &lt;code&gt;G_ARRAY&lt;/code&gt; 만 반환 할 수 있는 이전 버전과 호환되는 &lt;code&gt;GIMME_V&lt;/code&gt; 버전 ; 빈 공간에서는 &lt;code&gt;G_SCALAR&lt;/code&gt; 를 반환합니다 . 더 이상 사용되지 않습니다. 대신 &lt;code&gt;GIMME_V&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="825d3b4cdbdd793ff6bcae81fea3eedc9476aefd" translate="yes" xml:space="preserve">
          <source>A bare declaration like that declares the function to be a list operator, not a unary operator, so you have to be careful to use parentheses (or &lt;code&gt;or&lt;/code&gt; instead of &lt;code&gt;||&lt;/code&gt;.) The &lt;code&gt;||&lt;/code&gt; operator binds too tightly to use after list operators; it becomes part of the last element. You can always use parentheses around the list operators arguments to turn the list operator back into something that behaves more like a function call. Alternatively, you can use the prototype &lt;code&gt;($)&lt;/code&gt; to turn the subroutine into a unary operator:</source>
          <target state="translated">당신이 (또는 괄호를 사용에주의해야하므로 그와 같은 베어 선언은리스트 연산자가 아니라 단항 연산자로 함수를 선언 &lt;code&gt;or&lt;/code&gt; 대신 &lt;code&gt;||&lt;/code&gt; 하십시오.) &lt;code&gt;||&lt;/code&gt; 연산자가 목록 연산자 뒤에 사용하기에 너무 단단히 바인딩됩니다. 마지막 요소의 일부가됩니다. 리스트 연산자 인수 주위에 항상 괄호를 사용하여리스트 연산자를 함수 호출과 유사한 동작으로 되돌릴 수 있습니다. 또는 프로토 타입 &lt;code&gt;($)&lt;/code&gt; 을 사용하여 서브 루틴을 단항 연산자로 전환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="79d7fc67720af71225bb992fc841089461a260dd" translate="yes" xml:space="preserve">
          <source>A bare, single &lt;b&gt;statement&lt;/b&gt;, without any braces, hanging off an &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;while&lt;/code&gt; conditional. C allows them. Perl doesn&amp;rsquo;t.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 또는 &lt;code&gt;while&lt;/code&gt; 조건부 에서 중단없이 중괄호가없는 간단한 단일 &lt;b&gt;명령문&lt;/b&gt; . C는 그들을 허용합니다. 펄은 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7c021cbe956d43771e93a19ff22791f5da1edc86" translate="yes" xml:space="preserve">
          <source>A basic building block. When you&amp;rsquo;re talking about an &lt;b&gt;array&lt;/b&gt;, it&amp;rsquo;s one of the items that make up the array.</source>
          <target state="translated">기본 빌딩 블록. &lt;b&gt;배열&lt;/b&gt; 에 대해 이야기 할 때 &lt;b&gt;배열&lt;/b&gt; 을 구성하는 항목 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="dc24770c94125e3eea533d29f62a33f6fca11b44" translate="yes" xml:space="preserve">
          <source>A basic example</source>
          <target state="translated">기본 예</target>
        </trans-unit>
        <trans-unit id="f7282a24ce95eed40d8f1f24671950459bbf71d8" translate="yes" xml:space="preserve">
          <source>A basic non-buffered layer which calls Unix/POSIX &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;lseek()&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt;. No buffering. Even on platforms that distinguish between O_TEXT and O_BINARY this layer is always O_BINARY.</source>
          <target state="translated">Unix / POSIX &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;lseek()&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; 를 호출하는 버퍼되지 않은 기본 레이어입니다 . 버퍼링이 없습니다. O_TEXT와 O_BINARY를 구분하는 플랫폼에서도이 레이어는 항상 O_BINARY입니다.</target>
        </trans-unit>
        <trans-unit id="3269aa1ef3bfcd123309b115096aa27b3b0a0aa8" translate="yes" xml:space="preserve">
          <source>A bigger, fancier sort of &lt;b&gt;program&lt;/b&gt; with a fancier name so people don&amp;rsquo;t realize they are using a program.</source>
          <target state="translated">의 더 큰, 애호가 종류의 &lt;b&gt;프로그램&lt;/b&gt; 애호가 이름을 가진 사람들은이 프로그램을 사용하는 인식하지 않도록.</target>
        </trans-unit>
        <trans-unit id="1395a44d1527cd51acf9f72e88e221dc5e7a43dc" translate="yes" xml:space="preserve">
          <source>A binary search such as that provided by &lt;a href=&quot;#search_invlist()&quot;&gt;search_invlist()&lt;/a&gt;, can be used to quickly find a code point in the inversion list, and hence its corresponding mapping.</source>
          <target state="translated">&lt;a href=&quot;#search_invlist()&quot;&gt;search_invlist ()&lt;/a&gt; 에서 제공하는 것과 같은 이진 검색을 사용하여 반전 목록에서 코드 포인트를 신속하게 찾아 해당 매핑을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3982f0643b548a46d27f9bb45d706ffed3877fd" translate="yes" xml:space="preserve">
          <source>A bit of magic: executing Perl code in a regular expression</source>
          <target state="translated">약간의 마술 : 정규식으로 Perl 코드 실행</target>
        </trans-unit>
        <trans-unit id="a21b7a38b7737dbecfe5abeb569d1f5e67680088" translate="yes" xml:space="preserve">
          <source>A bitfield containing &lt;code&gt;AI_*&lt;/code&gt; constants; see below.</source>
          <target state="translated">&lt;code&gt;AI_*&lt;/code&gt; 상수를 포함하는 비트 필드 . 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5315c3bf863fe0d813794db09004e209616806a3" translate="yes" xml:space="preserve">
          <source>A bolt out of the blue; that is, an event triggered by the &lt;b&gt;operating system&lt;/b&gt;, probably when you&amp;rsquo;re least expecting it.</source>
          <target state="translated">파란색에서 볼트; 즉 , 아마도 &lt;b&gt;운영 체제&lt;/b&gt; 에 의해 트리거되는 이벤트 일 것입니다.</target>
        </trans-unit>
        <trans-unit id="37f6985b23fa2a35e2960a3080f908d1bc2f10c9" translate="yes" xml:space="preserve">
          <source>A boolean comparison operator such as &lt;code&gt;$_ &amp;lt; 10&lt;/code&gt; or &lt;code&gt;$x eq &quot;abc&quot;&lt;/code&gt; . The relational operators that this applies to are the six numeric comparisons (&lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;==&lt;/code&gt; , and &lt;code&gt;!=&lt;/code&gt; ), and the six string comparisons (&lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;gt&lt;/code&gt; , &lt;code&gt;le&lt;/code&gt; , &lt;code&gt;ge&lt;/code&gt; , &lt;code&gt;eq&lt;/code&gt; , and &lt;code&gt;ne&lt;/code&gt; ).</source>
          <target state="translated">같은 부울 비교 연산자 &lt;code&gt;$_ &amp;lt; 10&lt;/code&gt; 또는 &lt;code&gt;$x eq &quot;abc&quot;&lt;/code&gt; . 이것이 적용되는 관계 연산자는 6 개의 숫자 비교 ( &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;==&lt;/code&gt; 및 &lt;code&gt;!=&lt;/code&gt; ) 및 6 개의 문자열 비교 ( &lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;gt&lt;/code&gt; , &lt;code&gt;le&lt;/code&gt; , &lt;code&gt;ge&lt;/code&gt; , &lt;code&gt;eq&lt;/code&gt; 및 &lt;code&gt;ne&lt;/code&gt; )입니다. .</target>
        </trans-unit>
        <trans-unit id="5784bf453d1712122e0236fafc88e209e3c6adfe" translate="yes" xml:space="preserve">
          <source>A boolean flag that indicates if this argument was a required argument. If marked as required and not provided, check() will fail.</source>
          <target state="translated">이 인수가 필수 인수인지 여부를 나타내는 부울 플래그입니다. 필수로 표시되고 제공되지 않으면 check ()가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="806d4e84607ce29c56416e6b774c66e8a0e936b0" translate="yes" xml:space="preserve">
          <source>A boolean to indicate whether &lt;code&gt;check&lt;/code&gt; should be verbose and warn about what went wrong in a check or not.</source>
          <target state="translated">&lt;code&gt;check&lt;/code&gt; 이 장황 해야하는지 여부를 표시 하고 점검에서 무엇이 잘못되었는지 경고 하는 부울 입니다.</target>
        </trans-unit>
        <trans-unit id="75de768f80b992cf9735e1b55771968cbd72780f" translate="yes" xml:space="preserve">
          <source>A boolean type. This can be used to pass true and false values to and from C.</source>
          <target state="translated">부울 유형입니다. C와의 true 및 false 값을 전달하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aaea9ae3f33d9df07a73532337b752e2bd4004dd" translate="yes" xml:space="preserve">
          <source>A boolean value indicating whether or not the module was found to be at least the version you specified. If you did not specify a version, uptodate will always be true if the module was found. If no parsable version was found in the module, uptodate will also be true, since &lt;code&gt;check_install&lt;/code&gt; had no way to verify clearly.</source>
          <target state="translated">모듈이 최소한 지정한 버전인지 여부를 나타내는 부울 값입니다. 버전을 지정하지 않은 경우 모듈이 발견되면 항상 최신 상태가됩니다. 모듈에서 구문 분석 가능한 버전을 찾지 못하면 &lt;code&gt;check_install&lt;/code&gt; 이 명확하게 확인할 방법이 없으므로 최신 버전도 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f4da841a146cb38a789f449f32f4b854b9d0c640" translate="yes" xml:space="preserve">
          <source>A built-in unary operator that you use to determine whether something is &lt;b&gt;true&lt;/b&gt; about a file, such as &lt;code&gt;&amp;ndash;o
$filename&lt;/code&gt; to test whether you&amp;rsquo;re the owner of the file.</source>
          <target state="translated">파일 소유자인지 여부를 테스트하기 위해 &lt;code&gt;&amp;ndash;o $filename&lt;/code&gt; 과 같이 파일에 대해 어떤 것이 &lt;b&gt;사실&lt;/b&gt; 인지 확인하기 위해 사용하는 내장 단항 연산자입니다 .</target>
        </trans-unit>
        <trans-unit id="7359d066cd43a6821cadbf98e46de3780a2f14da" translate="yes" xml:space="preserve">
          <source>A bundle is just a perl module in the namespace Bundle:: that does not define any functions or methods. It usually only contains documentation.</source>
          <target state="translated">번들은 네임 스페이스 Bundle ::의 펄 모듈 일 뿐이며, 함수 나 메소드를 정의하지 않습니다. 일반적으로 문서 만 포함합니다.</target>
        </trans-unit>
        <trans-unit id="dcefaccadd4fc0b82966dd6fe0502b4a54a13075" translate="yes" xml:space="preserve">
          <source>A call to &lt;a href=&quot;#DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;&gt;DECLARATION_FOR_LC_NUMERIC_MANIPULATION&lt;/a&gt; must have been made to declare at compile time a private variable used by this macro and the two &lt;code&gt;STORE&lt;/code&gt; ones. This macro should be called as a single statement, not an expression, but with an empty argument list, like this:</source>
          <target state="translated">컴파일 &lt;a href=&quot;#DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;&gt;시이&lt;/a&gt; 매크로와 두 개의 &lt;code&gt;STORE&lt;/code&gt; 변수가 사용하는 개인 변수를 선언 하기 위해 DECLARATION_FOR_LC_NUMERIC_MANIPULATION을 호출 해야 합니다. 이 매크로는 표현식이 아니라 다음과 같이 인수 목록이 비어있는 단일 명령문으로 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="85dcd887c15b971af653f15a54e47c2790e7a16c" translate="yes" xml:space="preserve">
          <source>A call to &lt;a href=&quot;#DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;&gt;DECLARATION_FOR_LC_NUMERIC_MANIPULATION&lt;/a&gt; must have been made to declare at compile time a private variable used by this macro. This macro should be called as a single statement, not an expression, but with an empty argument list, like this:</source>
          <target state="translated">컴파일 &lt;a href=&quot;#DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;&gt;시이&lt;/a&gt; 매크로가 사용하는 개인 변수를 선언 하기 위해 DECLARATION_FOR_LC_NUMERIC_MANIPULATION을 호출 해야합니다. 이 매크로는 표현식이 아니라 다음과 같이 인수 목록이 비어있는 단일 명령문으로 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="6d081cdfc1719628de161b242cc46c6122417557" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; will cause Perl to exit, and to invoke the command given as an argument to &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; via &lt;code&gt;lib$do_command&lt;/code&gt; . If the argument begins with '@' or '$' (other than as part of a filespec), then it is executed as a DCL command. Otherwise, the first token on the command line is treated as the filespec of an image to run, and an attempt is made to invoke it (using</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 를 호출 하면 Perl이 종료되고 &lt;code&gt;lib$do_command&lt;/code&gt; 를 통해 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 에 인수로 제공된 명령이 호출 됩니다. 인수가 '@'또는 '$'(filespec의 일부가 아닌)로 시작하면 DCL 명령으로 실행됩니다. 그렇지 않으면, 명령 행의 첫 번째 토큰은 실행할 이미지의 파일 스펙으로 취급되며이를 호출하려고 시도합니다 (</target>
        </trans-unit>
        <trans-unit id="9b1310b4d6c00ffc23a2f0bae5e7870ed9e6ede4" translate="yes" xml:space="preserve">
          <source>A character class is a way of denoting a set of characters in such a way that one character of the set is matched. It's important to remember that: matching a character class consumes exactly one character in the source string. (The source string is the string the regular expression is matched against.)</source>
          <target state="translated">문자 클래스는 세트의 한 문자가 일치하는 방식으로 문자 세트를 나타내는 방법입니다. 문자 클래스를 일치시키는 것은 소스 문자열에서 정확히 하나의 문자를 소비합니다. 소스 문자열은 정규식과 일치하는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="2d7e4b0e3a328dba3c81ba02d01a3c0f782c72a5" translate="yes" xml:space="preserve">
          <source>A character encoding form plus byte serialization. There are Seven character encoding schemes in Unicode: UTF-8, UTF-16, UTF-16BE, UTF-16LE, UTF-32 (UCS-4), UTF-32BE (UCS-4BE) and UTF-32LE (UCS-4LE), and UTF-7.</source>
          <target state="translated">문자 인코딩 형식과 바이트 직렬화 유니 코드에는 UTF-8, UTF-16, UTF-16BE, UTF-16LE, UTF-32 (UCS-4), UTF-32BE (UCS-4BE) 및 UTF-32LE (UCS-4LE)의 7 가지 문자 인코딩 체계가 있습니다. ) 및 UTF-7입니다.</target>
        </trans-unit>
        <trans-unit id="e2b2859306209b5e788c7205519699be5962c3a1" translate="yes" xml:space="preserve">
          <source>A character entity was found that does not belong to the standard ISO set or the POD specials &lt;code&gt;verbar&lt;/code&gt; and &lt;code&gt;sol&lt;/code&gt; .</source>
          <target state="translated">표준 ISO 세트 또는 POD 스페셜 &lt;code&gt;verbar&lt;/code&gt; 및 &lt;code&gt;sol&lt;/code&gt; 에 속하지 않는 문자 엔티티가 발견되었습니다 .</target>
        </trans-unit>
        <trans-unit id="6b3facef3525988e61e4c03673d831959bbb24fc" translate="yes" xml:space="preserve">
          <source>A character in the range 0 .. 2**32-1 (or more); what Perl's strings are made of.</source>
          <target state="translated">0 .. 2 ** 32-1 (또는 그 이상) 범위의 문자; 펄의 줄이 만들어지는 것.</target>
        </trans-unit>
        <trans-unit id="4c66dbdd31c41ff8290d5b9e5b84c42f44091393" translate="yes" xml:space="preserve">
          <source>A character in the range 0..255; a special case of a Perl character.</source>
          <target state="translated">0..255 범위의 문자; 펄 캐릭터의 특별한 경우.</target>
        </trans-unit>
        <trans-unit id="deb99f697e889e229888732646e1d9a4b2cd77a6" translate="yes" xml:space="preserve">
          <source>A character range may be specified with a hyphen, so &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/A-J/0-9/&lt;/a&gt;&lt;/code&gt; does the same replacement as &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/ACEGIBDFHJ/0246813579/&lt;/a&gt;&lt;/code&gt;. For &lt;b&gt;sed&lt;/b&gt; devotees, &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; is provided as a synonym for &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt;. If the</source>
          <target state="translated">문자 범위는 하이픈으로 지정할 수 있으므로 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/A-J/0-9/&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/ACEGIBDFHJ/0246813579/&lt;/a&gt;&lt;/code&gt; 와 동일한 대체를 수행합니다 . 들면 &lt;b&gt;나오지&lt;/b&gt; 헌신, &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; 동의어로 제공된다 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; . 만약</target>
        </trans-unit>
        <trans-unit id="62e5445beeff56a35c0dc5ca65bde86d53c27ebb" translate="yes" xml:space="preserve">
          <source>A character set comprising all the major character sets of the world, more or less. See &lt;a href=&quot;http://www.unicode.org&quot;&gt;http://www.unicode.org&lt;/a&gt;.</source>
          <target state="translated">월드의 모든 주요 문자 세트로 구성되는 문자 세트. &lt;a href=&quot;http://www.unicode.org&quot;&gt;http://www.unicode.org를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="8c07be0779b2376c619d1a65316d136daa5c26ab" translate="yes" xml:space="preserve">
          <source>A character symbolizing the type of IO Handle.</source>
          <target state="translated">IO 핸들의 유형을 상징하는 문자.</target>
        </trans-unit>
        <trans-unit id="ad2f4627442f7e9e5cdd45c11902cca0d8325c3b" translate="yes" xml:space="preserve">
          <source>A character with the numeric value of zero. It&amp;rsquo;s used by C to terminate strings, but Perl allows strings to contain a null.</source>
          <target state="translated">숫자 값이 0 인 문자 C에서 문자열을 종료하는 데 사용되지만 Perl에서는 문자열에 null이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a98fe200a320861843965673193461dc42788194" translate="yes" xml:space="preserve">
          <source>A check is made to make sure that the file that is found does contain some pod documentation.</source>
          <target state="translated">찾은 파일에 일부 포드 설명서가 포함되어 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="dff052af6a3279311d539bddc8b2f4ffb4c3bccf" translate="yes" xml:space="preserve">
          <source>A check routine is called when the node is fully constructed except for the execution-order thread. Since at this time there are no back-links to the currently constructed node, one can do most any operation to the top-level node, including freeing it and/or creating new nodes above/below it.</source>
          <target state="translated">실행 순서 스레드를 제외하고 노드가 완전히 구성되면 점검 루틴이 호출됩니다. 현재는 현재 구성된 노드에 대한 백 링크가 없기 때문에 노드 해제 및 / 또는 위 / 아래에 새 노드 생성을 포함하여 최상위 노드에 대한 모든 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffb83db9b043670ff139e922da8f6f1ecd3cdb22" translate="yes" xml:space="preserve">
          <source>A class implementing a filehandle should have the following methods:</source>
          <target state="translated">파일 핸들을 구현하는 클래스에는 다음 메소드가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="78efc3f39c8e446fbaac2a63562d8cf90bbe3489" translate="yes" xml:space="preserve">
          <source>A class implementing a hash should have the following methods:</source>
          <target state="translated">해시를 구현하는 클래스에는 다음과 같은 메소드가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c29da3bd78457adcea44e08fd7ad308e312eac90" translate="yes" xml:space="preserve">
          <source>A class implementing a scalar should have the following methods:</source>
          <target state="translated">스칼라를 구현하는 클래스에는 다음 메소드가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="63533b67267a9fe7a63e719b4e79f437e64bb6e7" translate="yes" xml:space="preserve">
          <source>A class implementing a tied filehandle should define the following methods: TIEHANDLE, at least one of PRINT, PRINTF, WRITE, READLINE, GETC, READ, and possibly CLOSE, UNTIE and DESTROY. The class can also provide: BINMODE, OPEN, EOF, FILENO, SEEK, TELL - if the corresponding perl operators are used on the handle.</source>
          <target state="translated">묶인 파일 핸들을 구현하는 클래스는 TIEHANDLE, PRINT, PRINTF, WRITE, READLINE, GETC, READ 및 CLOSE, UNTIE 및 DESTROY 중 하나 이상을 정의해야합니다. 클래스는 BINMODE, OPEN, EOF, FILENO, SEEK, TELL을 제공 할 수 있습니다. 해당 perl 연산자가 핸들에 사용 된 경우.</target>
        </trans-unit>
        <trans-unit id="860765a0ff8cee1341ccc04233da280b71701cf8" translate="yes" xml:space="preserve">
          <source>A class implementing a tied ordinary array should define the following methods: TIEARRAY, FETCH, STORE, FETCHSIZE, STORESIZE, CLEAR and perhaps UNTIE and/or DESTROY.</source>
          <target state="translated">연결된 일반 배열을 구현하는 클래스는 TIEARRAY, FETCH, STORE, FETCHSIZE, STORESIZE, CLEAR 및 UNTIE 및 / 또는 DESTROY 메소드를 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="bf2fe5249c3fde4bdfb3247a51b433da9021cc26" translate="yes" xml:space="preserve">
          <source>A class implementing a tied scalar should define the following methods: TIESCALAR, FETCH, STORE, and possibly UNTIE and/or DESTROY.</source>
          <target state="translated">연결된 스칼라를 구현하는 클래스는 TIESCALAR, FETCH, STORE 및 UNTIE 및 / 또는 DESTROY 메소드를 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="172ef2f1ff718aa5d74e2eddddd8780306842005" translate="yes" xml:space="preserve">
          <source>A class implementing an ordinary array should have the following methods:</source>
          <target state="translated">일반 배열을 구현하는 클래스에는 다음 메소드가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="7a3aaef4b6bdc65044d6cee8905b655c826b75aa" translate="yes" xml:space="preserve">
          <source>A class is simply a package. A class provides methods that expect to operate on objects.</source>
          <target state="translated">클래스는 단순히 패키지입니다. 클래스는 객체에서 작동 할 것으로 예상되는 메서드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="db991666cef49d40c1a8876d8e678d10cc5c5920" translate="yes" xml:space="preserve">
          <source>A class providing an object based interface to SysV IPC message queues.</source>
          <target state="translated">SysV IPC 메시지 큐에 객체 기반 인터페이스를 제공하는 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="4b371730a083c396c011c1644f5fee33b2fe22c7" translate="yes" xml:space="preserve">
          <source>A class providing an object based interface to SysV IPC semaphores.</source>
          <target state="translated">SysV IPC 세마포어에 객체 기반 인터페이스를 제공하는 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="937b26fb80fdcafceefce4e180073ce7c0d23781" translate="yes" xml:space="preserve">
          <source>A class providing an object based interface to SysV IPC shared memory.</source>
          <target state="translated">SysV IPC 공유 메모리에 객체 기반 인터페이스를 제공하는 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="fa2558ecb874a35a0f9b83568f215824db4e665c" translate="yes" xml:space="preserve">
          <source>A cleaner interface.</source>
          <target state="translated">깔끔한 인터페이스.</target>
        </trans-unit>
        <trans-unit id="551df32d5b94297e0a676020a161e26c925fb485" translate="yes" xml:space="preserve">
          <source>A command &quot;=begin</source>
          <target state="translated">&quot;= 시작된 명령</target>
        </trans-unit>
        <trans-unit id="4b51cb486fb82b1f8836c9909ccc915ba4671256" translate="yes" xml:space="preserve">
          <source>A command paragraph (also called a &quot;directive&quot;). The first line of this paragraph must match &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=[a-zA-Z]/&lt;/a&gt;&lt;/code&gt;. Command paragraphs are typically one line, as in:</source>
          <target state="translated">명령 단락 ( &quot;지시적&quot;이라고도 함) 이 단락의 첫 줄은 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=[a-zA-Z]/&lt;/a&gt;&lt;/code&gt; 와 일치해야합니다 . 명령 단락은 일반적으로 다음과 같이 한 줄입니다.</target>
        </trans-unit>
        <trans-unit id="a63e70d9d65f24f45184b420c514e63650be0655" translate="yes" xml:space="preserve">
          <source>A command paragraph is used for special treatment of whole chunks of text, usually as headings or parts of lists.</source>
          <target state="translated">명령 단락은 전체 텍스트 청크를 일반적으로 제목 또는 목록의 일부로 처리하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d9ff878c605ee9fd388f0b2eb88f5ce5a0c8f433" translate="yes" xml:space="preserve">
          <source>A command such as this can vastly reduce the volume of material to actually sort through in the first place, and should not be too lightly disregarded purely on the basis of its simplicity. The &lt;code&gt;KISS&lt;/code&gt; principle is too often overlooked - the next example uses the simple system &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; utility to demonstrate. Let's take a look at an actual example of sorting the contents of a large file, an apache logfile would do. This one has over a quarter of a million lines, is 50M in size, and a snippet of it looks like this:</source>
          <target state="translated">이와 같은 명령은 처음부터 실제로 분류 할 재료의 양을 크게 줄일 수 있으며 단순성만으로는 너무 가볍게 무시해서는 안됩니다. &lt;code&gt;KISS&lt;/code&gt; 의 원칙은 너무 자주 간과 - 다음 예는 간단한 시스템 사용 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 입증하는 유틸리티. 큰 파일의 내용을 정렬하는 실제 예를 살펴 보겠습니다. 아파치 로그 파일이 할 것입니다. 이것은 1 억 5 천 개의 줄을 가지고 있으며 크기는 50M이며, 그 조각은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="950be6f2b3fd35cd65faf61436fcb9557d03c11d" translate="yes" xml:space="preserve">
          <source>A command which has ended up in the middle of a paragraph or other command, such as</source>
          <target state="translated">단락의 중간에 끝나는 명령 또는 다음과 같은 다른 명령</target>
        </trans-unit>
        <trans-unit id="dfc138f19fcb5bcbc53f0752d4f1867a8fa0e913" translate="yes" xml:space="preserve">
          <source>A command-line front-end to &lt;code&gt;Module::CoreList&lt;/code&gt; , to query what modules were shipped with given versions of perl.</source>
          <target state="translated">주어진 버전의 perl과 함께 제공된 모듈을 조회 하기위한 &lt;code&gt;Module::CoreList&lt;/code&gt; 의 명령 행 프론트 엔드 .</target>
        </trans-unit>
        <trans-unit id="9cbae24479d2e6391e2d1be21dd08d1626f00360" translate="yes" xml:space="preserve">
          <source>A comment</source>
          <target state="translated">코멘트</target>
        </trans-unit>
        <trans-unit id="79414afc2393f5f2f467ceef02de3748e14d7a7a" translate="yes" xml:space="preserve">
          <source>A comment, indicated by putting a '#' in the first column.</source>
          <target state="translated">첫 번째 열에 '#'을 넣으면 표시되는 주석입니다.</target>
        </trans-unit>
        <trans-unit id="ee091682ad4b542f16ac50d991bfff2ba6d1e9a6" translate="yes" xml:space="preserve">
          <source>A comment. The text is ignored. Note that Perl closes the comment as soon as it sees a &lt;code&gt;)&lt;/code&gt;, so there is no way to put a literal &lt;code&gt;)&lt;/code&gt; in the comment. The pattern's closing delimiter must be escaped by a backslash if it appears in the comment.</source>
          <target state="translated">의견. 텍스트는 무시됩니다. 펄은 곧 그것이 보는만큼 주석을 닫을 것을 주 &lt;code&gt;)&lt;/code&gt; , 그래서 문자를 넣어하는 방법은 없습니다 &lt;code&gt;)&lt;/code&gt; 주석에. 주석에 패턴이 나타나면 패턴의 닫는 분리 문자는 백 슬래시로 이스케이프되어야합니다.</target>
        </trans-unit>
        <trans-unit id="1efe142409d27cde9607bba9f906e0c889b26956" translate="yes" xml:space="preserve">
          <source>A commit message isn't intended to take the place of comments in your code. Commit messages should describe the change you made, while code comments should describe the current state of the code.</source>
          <target state="translated">커밋 메시지는 코드에서 주석을 대신하지 않습니다. 커밋 메시지는 변경 사항을 설명해야하며 코드 주석은 코드의 현재 상태를 설명해야합니다.</target>
        </trans-unit>
        <trans-unit id="bf7ad1fec29a3549dc58ded16ba4af5fb14c45da" translate="yes" xml:space="preserve">
          <source>A common abuse of this power stems from the ability to make infinite loops using regular expressions, with something as innocuous as:</source>
          <target state="translated">이 힘의 일반적인 남용은 다음과 같은 무해한 정규식을 사용하여 무한 루프를 만드는 기능에서 비롯됩니다.</target>
        </trans-unit>
        <trans-unit id="80ff7af3da26f57aaa8f224ec06b92247a2ede78" translate="yes" xml:space="preserve">
          <source>A common bit of code &lt;b&gt;NOT TO USE&lt;/b&gt; is this:</source>
          <target state="translated">&lt;b&gt;사용하지 말아야 할&lt;/b&gt; 일반적인 코드 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bcd3e6faa389885dcad88118cf027340603a19e2" translate="yes" xml:space="preserve">
          <source>A common misconception in socket programming is that &lt;code&gt;\n &lt;a href=&quot;functions/eq&quot;&gt;eq&lt;/a&gt; \012&lt;/code&gt; everywhere. When using protocols such as common Internet protocols, &lt;code&gt;\012&lt;/code&gt; and &lt;code&gt;\015&lt;/code&gt; are called for specifically, and the values of the logical &lt;code&gt;\n&lt;/code&gt; and &lt;code&gt;\r&lt;/code&gt; (carriage return) are not reliable.</source>
          <target state="translated">소켓 프로그래밍의 일반적인 오해는 &lt;code&gt;\n &lt;a href=&quot;functions/eq&quot;&gt;eq&lt;/a&gt; \012&lt;/code&gt; 입니다. 일반적인 인터넷 프로토콜과 같은 프로토콜을 사용하는 경우, 구체적으로 &lt;code&gt;\012&lt;/code&gt; 및 &lt;code&gt;\015&lt;/code&gt; 가 호출되며 논리 &lt;code&gt;\n&lt;/code&gt; 및 &lt;code&gt;\r&lt;/code&gt; (캐리지 리턴)의 값은 신뢰할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b9e9593af1f1c680a3827d8f5e0edca15a66c226" translate="yes" xml:space="preserve">
          <source>A common mistake is to try to separate the words with commas or to put comments into a multi-line &lt;code&gt;&lt;a href=&quot;functions/qw&quot;&gt;qw&lt;/a&gt;&lt;/code&gt;-string. For this reason, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma and the &lt;b&gt;-w&lt;/b&gt; switch (that is, the &lt;code&gt;$^W&lt;/code&gt; variable) produces warnings if the</source>
          <target state="translated">일반적인 실수는 단어를 쉼표로 분리하거나 여러 줄로 된 &lt;code&gt;&lt;a href=&quot;functions/qw&quot;&gt;qw&lt;/a&gt;&lt;/code&gt; 문자열 에 주석을 넣는 것입니다. 이러한 이유로 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma 및 &lt;b&gt;-w&lt;/b&gt; 스위치 (즉, &lt;code&gt;$^W&lt;/code&gt; 변수)는 다음과 같은 경우 경고를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="aad5d9b3c5a0d882bf3ecc970194923dc4421054" translate="yes" xml:space="preserve">
          <source>A common mistake is to write:</source>
          <target state="translated">일반적인 실수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2a1998491c1e38cb900464f10bbb2d155c01472d" translate="yes" xml:space="preserve">
          <source>A common pitfall is to use &lt;a href=&quot;#precision()&quot;&gt;precision()&lt;/a&gt; when you want to round a result to a certain number of digits:</source>
          <target state="translated">일반적인 함정은 결과를 특정 자릿수로 반올림하려는 경우 &lt;a href=&quot;#precision()&quot;&gt;precision ()&lt;/a&gt; 을 사용 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="008944edbc996e59046c342b9a5abf856d868927" translate="yes" xml:space="preserve">
          <source>A common sight is code which looks something like this:</source>
          <target state="translated">일반적인 시각은 다음과 같은 코드입니다.</target>
        </trans-unit>
        <trans-unit id="7a1613d252216a78f3f6c4f13b80070f584c7ea5" translate="yes" xml:space="preserve">
          <source>A common value you might want would be just &quot;.&quot; for the current directory:</source>
          <target state="translated">원하는 일반적인 값은 &quot;.&quot;입니다. 현재 디렉토리의 경우 :</target>
        </trans-unit>
        <trans-unit id="0c241c23e5c55b1df65f14fa3926fd6466b90d17" translate="yes" xml:space="preserve">
          <source>A complete list of Perl's error messages and warnings with explanatory text can be found in &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt;. You can also use the splain program (distributed with Perl) to explain the error messages:</source>
          <target state="translated">펄의 오류 메시지 및 설명 텍스트와 경고의 전체 목록은에서 찾을 수 있습니다 &lt;a href=&quot;perldiag&quot;&gt;것은 perldiag&lt;/a&gt; . 또한 오류 프로그램 (Perl과 함께 배포 됨)을 사용하여 오류 메시지를 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2766232819d1e10808eb2c0fa9745fbc9935b0e0" translate="yes" xml:space="preserve">
          <source>A complete list of blocks and their shortcuts is in &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;.</source>
          <target state="translated">전체 블록 목록과 바로 가기는 &lt;a href=&quot;perluniprops&quot;&gt;perluniprops에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c9c8e1e2ba56e67cb98e64490d656c0331322db" translate="yes" xml:space="preserve">
          <source>A complete list of models at the time the OS was built is in the file /usr/sam/lib/mo/sched.models. The first column corresponds to the last part of the output of the &quot;model&quot; command. The second column is the PA-RISC version and the third column is the exact chip type used. (Start browsing at the bottom to prevent confusion ;-)</source>
          <target state="translated">OS가 구축 될 당시의 전체 모델 목록은 /usr/sam/lib/mo/sched.models 파일에 있습니다. 첫 번째 열은 &quot;model&quot;명령 출력의 마지막 부분에 해당합니다. 두 번째 열은 PA-RISC 버전이고 세 번째 열은 사용 된 정확한 칩 유형입니다. (혼란을 피하기 위해 하단에서 탐색을 시작하십시오 ;-)</target>
        </trans-unit>
        <trans-unit id="57f247bd806924e603c825d46c359f392e5225bb" translate="yes" xml:space="preserve">
          <source>A complete list of scripts and their shortcuts is in &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;.</source>
          <target state="translated">전체 스크립트 목록과 바로 가기는 &lt;a href=&quot;perluniprops&quot;&gt;perluniprops에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="352eea5d492543a075b98638f01aabee71fa53f5" translate="yes" xml:space="preserve">
          <source>A complete thread tutorial could fill a book (and has, many times), but with what we've covered in this introduction, you should be well on your way to becoming a threaded Perl expert.</source>
          <target state="translated">완전한 실습 서가 책을 채울 수 있지만 여러 번이 책에서 다룬 내용을 통해 실감 나는 펄 전문가가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="018d8cf23f3e4a65b253a6e3de9afa4ba28bc385" translate="yes" xml:space="preserve">
          <source>A component of a &lt;b&gt;regular expression&lt;/b&gt; pattern.</source>
          <target state="translated">&lt;b&gt;정규식&lt;/b&gt; 패턴 의 구성 요소입니다 .</target>
        </trans-unit>
        <trans-unit id="f5c9d218e3a29ce718317121d0020d3ccf6b9e88" translate="yes" xml:space="preserve">
          <source>A component of a &lt;b&gt;regular expression&lt;/b&gt; specifying how many times the foregoing &lt;b&gt;atom&lt;/b&gt; may occur.</source>
          <target state="translated">전술 한 &lt;b&gt;원자가&lt;/b&gt; 몇 번 나타날 수 있는지 를 나타내는 &lt;b&gt;정규식&lt;/b&gt; 의 구성 요소 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ca17448c2b0615d183e89c2b8af18e1466ef0123" translate="yes" xml:space="preserve">
          <source>A component of a &lt;b&gt;regular expression&lt;/b&gt; that must be true for the pattern to match but does not necessarily match any characters itself. Often used specifically to mean a &lt;b&gt;zero-width&lt;/b&gt; assertion.</source>
          <target state="translated">패턴이 일치해야하지만 문자 자체와 반드시 일치 할 필요는없는 &lt;b&gt;정규식&lt;/b&gt; 의 구성 요소입니다 . &lt;b&gt;너비&lt;/b&gt; 가 &lt;b&gt;0 인&lt;/b&gt; 어설 션 을 의미하기 위해 종종 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e4b110fd2e9cb16d7f0633f61d623ac063cd7727" translate="yes" xml:space="preserve">
          <source>A comprehensive list of Perl-related mailing lists can be found at &lt;a href=&quot;http://lists.perl.org/&quot;&gt;http://lists.perl.org/&lt;/a&gt;</source>
          <target state="translated">Perl 관련 메일 링리스트의 전체 목록은 &lt;a href=&quot;http://lists.perl.org/&quot;&gt;http://lists.perl.org/&lt;/a&gt; 에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ffdc43a299a7177f53314c9b7e876aeb0c84ac8" translate="yes" xml:space="preserve">
          <source>A consequence of this is that &lt;b&gt;-M&lt;i&gt;MODULE&lt;/i&gt;=number&lt;/b&gt; never does a version check, unless &lt;code&gt;&lt;i&gt;MODULE&lt;/i&gt;::import()&lt;/code&gt; itself is set up to do a version check, which could happen for example if</source>
          <target state="translated">결과적으로 &lt;code&gt;&lt;i&gt;MODULE&lt;/i&gt;::import()&lt;/code&gt; :: import () 자체가 버전 확인을 수행하도록 설정되어 있지 않으면 &lt;b&gt;-M &lt;i&gt;MODULE&lt;/i&gt; = number&lt;/b&gt; 는 버전 확인 을 수행하지 않습니다.&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="350e3e899dba4b57e7486366f0fbf9264f9b61f7" translate="yes" xml:space="preserve">
          <source>A constant with a name in the list &lt;code&gt;STDIN STDOUT STDERR ARGV ARGVOUT
ENV INC SIG&lt;/code&gt; is not allowed anywhere but in package &lt;code&gt;main::&lt;/code&gt; , for technical reasons.</source>
          <target state="translated">&lt;code&gt;STDIN STDOUT STDERR ARGV ARGVOUT ENV INC SIG&lt;/code&gt; 목록에 이름이있는 상수 는 기술적 인 이유로 &lt;code&gt;main::&lt;/code&gt; 패키지에 허용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="78f90a10d8180ed5dc542d1b277136194356a682" translate="yes" xml:space="preserve">
          <source>A construct that performs something repeatedly, like a roller coaster.</source>
          <target state="translated">롤러 코스터와 같이 무언가를 반복적으로 수행하는 구조.</target>
        </trans-unit>
        <trans-unit id="98c376c5464a7cbd0f7597422425141a29b3dc1e" translate="yes" xml:space="preserve">
          <source>A construct that sometimes looks like a function but really isn&amp;rsquo;t. Usually reserved for &lt;b&gt;lvalue&lt;/b&gt; modifiers like &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, for &lt;b&gt;context&lt;/b&gt; modifiers like &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt;, and for the pick-your-own-quotes constructs, &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qw&quot;&gt;qw//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">때때로 함수처럼 보이지만 실제로는 그렇지 않은 구문. 일반적으로 다음 과 같은 &lt;b&gt;lvalue&lt;/b&gt; 수정 &lt;b&gt;자용&lt;/b&gt; 으로 예약되어 있습니다. &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; 같은&lt;b&gt; 컨텍스트&lt;/b&gt; 수정 자및 pick-your-own-quotes 구문, &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q//&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq//&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/qw&quot;&gt;qw//&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8552f673941f3d1978946011be4253061336584" translate="yes" xml:space="preserve">
          <source>A contact email address for the author/maintainer</source>
          <target state="translated">작성자 / 유지 업체의 연락처 이메일 주소</target>
        </trans-unit>
        <trans-unit id="1e9afcf85fc0132156a56c6d8cb4ffccff6b369d" translate="yes" xml:space="preserve">
          <source>A convenience function which combines creating an object and calling &lt;code&gt;isa_ok()&lt;/code&gt; on that object.</source>
          <target state="translated">객체 생성과 해당 객체에서 &lt;code&gt;isa_ok()&lt;/code&gt; 호출을 결합하는 편리한 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="53128330b7badc08928ea23290fdacf578eb391d" translate="yes" xml:space="preserve">
          <source>A convenience variable which is typically used with &lt;code&gt;SvPV&lt;/code&gt; when one doesn't care about the length of the string. It is usually more efficient to either declare a local variable and use that instead or to use the &lt;code&gt;SvPV_nolen&lt;/code&gt; macro.</source>
          <target state="translated">문자열의 길이를 신경 쓰지 않을 때 일반적으로 &lt;code&gt;SvPV&lt;/code&gt; 와 함께 사용되는 편의 변수입니다 . 일반적으로 로컬 변수를 선언하고 대신 사용하거나 &lt;code&gt;SvPV_nolen&lt;/code&gt; 매크로 를 사용하는 것이 더 효율적 입니다.</target>
        </trans-unit>
        <trans-unit id="638f854b99669da73bce286ea189e697af8d4b5f" translate="yes" xml:space="preserve">
          <source>A convenient shortcut to operating on even-sized lists of pairs, this function returns a list of ARRAY references, each containing two items from the given list. It is a more efficient version of</source>
          <target state="translated">짝수 크기의 쌍 목록에서 작동하는 편리한 바로 가기 인이 함수는 주어진 목록에서 각각 2 개의 항목을 포함하는 ARRAY 참조 목록을 반환합니다. 보다 효율적인 버전입니다</target>
        </trans-unit>
        <trans-unit id="1166e931ea27a942799d52c7c1f3e445e7d6efa2" translate="yes" xml:space="preserve">
          <source>A convenient shortcut to operating on even-sized lists of pairs, this function returns a list of the the first values of each of the pairs in the given list. It is a more efficient version of</source>
          <target state="translated">짝수 크기의 쌍 목록에서 작동하는 편리한 바로 가기 인이 함수는 주어진 목록에서 각 쌍의 첫 번째 값 목록을 반환합니다. 보다 효율적인 버전입니다</target>
        </trans-unit>
        <trans-unit id="0dbcf107b79ffefab41fba2fbb5cf9a734cd1746" translate="yes" xml:space="preserve">
          <source>A convenient shortcut to operating on even-sized lists of pairs, this function returns a list of the the second values of each of the pairs in the given list. It is a more efficient version of</source>
          <target state="translated">짝수 크기의 쌍 목록에서 작동하는 편리한 바로 가기 인이 함수는 주어진 목록에서 각 쌍의 두 번째 값 목록을 반환합니다. 보다 효율적인 버전입니다</target>
        </trans-unit>
        <trans-unit id="77f68a02d61a77d7eed2d175da1b876e8aceace1" translate="yes" xml:space="preserve">
          <source>A convenient way to set up your tests. Call this and Test::Builder will print the appropriate headers and take the appropriate actions.</source>
          <target state="translated">테스트를 설정하는 편리한 방법입니다. 이것을 호출하면 Test :: Builder가 적절한 헤더를 인쇄하고 적절한 조치를 취합니다.</target>
        </trans-unit>
        <trans-unit id="d87e8f492879ce02bf236daf94692483d0fd4b5c" translate="yes" xml:space="preserve">
          <source>A conventional (not inside-out) implementation where an object is a hash that stores the field values, without support by &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; . This implementation doesn't allow arbitrary inheritance.</source>
          <target state="translated">객체가 &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; 지원없이 필드 값을 저장하는 해시 인 일반적인 내부 구현이 아닌 구현 입니다. 이 구현은 임의의 상속을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="646b8162acfbdd090f426555f4c9a32ee73eeb01" translate="yes" xml:space="preserve">
          <source>A copy of IO::Scalar for Test::Builder</source>
          <target state="translated">Test :: Builder의 IO :: Scalar 사본</target>
        </trans-unit>
        <trans-unit id="5a070156d8ac581b1ec13fda608b6d3f5d95a087" translate="yes" xml:space="preserve">
          <source>A copy of a Win* viewer is contained in the &quot;Just add OS/2 Warp&quot; package</source>
          <target state="translated">Win * 뷰어 사본은 &quot;Just add OS / 2 Warp&quot;패키지에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e407ab7758af4150015ce0b8baf63576cf02a27" translate="yes" xml:space="preserve">
          <source>A copyright notice - see below.</source>
          <target state="translated">저작권 고지-아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d687cc7b81ffa630de399555f3a224dda7b56cfa" translate="yes" xml:space="preserve">
          <source>A correct CPAN version number is a floating point number with at least 2 digits after the decimal. You can test whether it conforms to CPAN by using</source>
          <target state="translated">올바른 CPAN 버전 번호는 소수점 이하 2 자리 이상의 부동 소수점 숫자입니다. CPAN을 준수하는지 테스트하여 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8295d6831975ca50ed9530db07dca19a25c715be" translate="yes" xml:space="preserve">
          <source>A count passed to Tpad to modify the padding applied to the output string. If $cnt is zero or one then the resulting string will be cached.</source>
          <target state="translated">출력 문자열에 적용된 패딩을 수정하기 위해 Tpad에 전달 된 수입니다. $ cnt가 0 또는 1이면 결과 문자열이 캐시됩니다.</target>
        </trans-unit>
        <trans-unit id="3ca2814f3e720b9b1b346f0c76354ef75ff06f2d" translate="yes" xml:space="preserve">
          <source>A crude table of contents for the Perl manpage set is found in &lt;a href=&quot;http://search.cpan.org/perldoc/perltoc&quot;&gt;perltoc&lt;/a&gt;.</source>
          <target state="translated">Perl 맨 페이지 세트에 대한 조잡한 목차는 &lt;a href=&quot;http://search.cpan.org/perldoc/perltoc&quot;&gt;perltoc에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="03adc2f14ebb3d0a7a9ba21528d13d42030133f9" translate="yes" xml:space="preserve">
          <source>A data debugging tool for the XS programmer</source>
          <target state="translated">XS 프로그래머를위한 데이터 디버깅 도구</target>
        </trans-unit>
        <trans-unit id="07e1664c3b50241d29a1670852c2daa101e50db7" translate="yes" xml:space="preserve">
          <source>A data repository. Instead of computing expensive answers several times, compute it once and save the result.</source>
          <target state="translated">데이터 저장소. 값 비싼 답변을 여러 번 계산하는 대신 한 번 계산하여 결과를 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="40b9a92df275c1cef5fb6a4e3d00cf2b3d4203b3" translate="yes" xml:space="preserve">
          <source>A data structure used internally by Perl for implementing associative arrays (hashes) efficiently. See also &lt;b&gt;bucket&lt;/b&gt;.</source>
          <target state="translated">연관 배열 (해시)을 효율적으로 구현하기 위해 Perl에서 내부적으로 사용하는 데이터 구조입니다. &lt;b&gt;bucket&lt;/b&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b6431d472e1b30028a75ba55229126e2e191ae3c" translate="yes" xml:space="preserve">
          <source>A declaration can be put anywhere a statement can, but has no effect on the execution of the primary sequence of statements: declarations all take effect at compile time. All declarations are typically put at the beginning or the end of the script. However, if you're using lexically-scoped private variables created with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our()&lt;/a&gt;&lt;/code&gt;, you'll have to make sure your format or subroutine definition is within the same block scope as the my if you expect to be able to access those private variables.</source>
          <target state="translated">선언은 명령문이 할 수있는 어느 곳에 나 배치 할 수 있지만, 기본 명령문 시퀀스 실행에는 영향을 미치지 않습니다. 선언은 모두 컴파일시 적용됩니다. 모든 선언은 일반적으로 스크립트의 시작 또는 끝에 있습니다. 그러나 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our()&lt;/a&gt;&lt;/code&gt; 만든 어휘 범위 개인 변수를 사용하는 경우 형식 또는 서브 루틴 정의가 my if와 동일한 블록 범위 내에 있는지 확인해야합니다 개인 변수에 액세스 할 수있을 것으로 기대합니다.</target>
        </trans-unit>
        <trans-unit id="753d1d91d799e4e070ffae305c67c5e3d698281a" translate="yes" xml:space="preserve">
          <source>A default hashing algorithm, which will be adequate for most applications, is built into Berkeley DB. If you do need to use your own hashing algorithm it is possible to write your own in Perl and have &lt;b&gt;DB_File&lt;/b&gt; use it instead.</source>
          <target state="translated">대부분의 응용 프로그램에 적합한 기본 해싱 알고리즘이 Berkeley DB에 내장되어 있습니다. 자체 해싱 알고리즘을 사용해야하는 경우 Perl로 직접 작성 하고 대신 &lt;b&gt;DB_File을&lt;/b&gt; 사용하도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9828da4e803d376a194bd30931557a328ae046c" translate="yes" xml:space="preserve">
          <source>A default site INSTALL.SKIP may be provided by setting then environment variable EU_INSTALL_SITE_SKIPFILE, this will only be used when there isn't a distribution specific INSTALL.SKIP. If the environment variable EU_INSTALL_IGNORE_SKIP is true then no install file filtering will be performed.</source>
          <target state="translated">환경 변수 EU_INSTALL_SITE_SKIPFILE을 설정하여 기본 사이트 INSTALL.SKIP를 제공 할 수 있습니다. 이는 분배 특정 INSTALL.SKIP가없는 경우에만 사용됩니다. 환경 변수 EU_INSTALL_IGNORE_SKIP가 true 인 경우 설치 파일 필터링이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e649d4a2c7d23eccbd6705217dd0baed80106ea" translate="yes" xml:space="preserve">
          <source>A deferred action like this:</source>
          <target state="translated">다음과 같은 지연된 조치 :</target>
        </trans-unit>
        <trans-unit id="c7b7b32d1f43857ac978062d5529fcaa75b008c1" translate="yes" xml:space="preserve">
          <source>A description of how C types may be transformed to and from Perl types within an &lt;b&gt;extension&lt;/b&gt; module written in &lt;b&gt;XS&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;XS로&lt;/b&gt; 작성된 &lt;b&gt;확장&lt;/b&gt; 모듈 내에서 C 유형을 Perl 유형으로 변환하거나 변환하는 방법에 대한 설명 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="152e62c7af6a3030011c43a7ed3a060f156647cc" translate="yes" xml:space="preserve">
          <source>A description of the callable function in each module</source>
          <target state="translated">각 모듈에서 호출 가능한 함수에 대한 설명</target>
        </trans-unit>
        <trans-unit id="a361777f63c2dac8a5f187498445ea69ff2e5fd2" translate="yes" xml:space="preserve">
          <source>A description of the module/package/extension etc.</source>
          <target state="translated">모듈 / 패키지 / 확장 등에 대한 설명</target>
        </trans-unit>
        <trans-unit id="2d3ff2a56a13511ba72ba40a6fa6a2c401a75cdb" translate="yes" xml:space="preserve">
          <source>A detailed document on Encode and PerlIO</source>
          <target state="translated">Encode 및 PerlIO에 대한 자세한 문서</target>
        </trans-unit>
        <trans-unit id="6acb6151fda2f69cbd4a7ea5c8537d8c57875e5a" translate="yes" xml:space="preserve">
          <source>A device you can put things on the top of, and later take them back off in the opposite order in which you put them on. See &lt;b&gt;LIFO&lt;/b&gt;.</source>
          <target state="translated">물건을 맨 위에 놓을 수 있고 나중에 반대 방향으로 다시 놓을 수있는 장치입니다. &lt;b&gt;LIFO를&lt;/b&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ce6d3879a0b885e4f02b96959f6d870d8f5b1fa8" translate="yes" xml:space="preserve">
          <source>A different approach is to autoload seldom-used Perl code. See the AutoSplit and AutoLoader modules in the standard distribution for that. Or you could locate the bottleneck and think about writing just that part in C, the way we used to take bottlenecks in C code and write them in assembler. Similar to rewriting in C, modules that have critical sections can be written in C (for instance, the PDL module from CPAN).</source>
          <target state="translated">다른 방법은 거의 사용하지 않는 Perl 코드를 자동로드하는 것입니다. 표준 배포판에서 AutoSplit 및 AutoLoader 모듈을 참조하십시오. 또는 병목 현상을 찾아 C 코드에서 병목 현상을 발생시키고 어셈블러에서 작성하는 방식 인 C로 해당 부분을 작성하는 방법을 생각할 수 있습니다. C에서 다시 쓰는 것과 마찬가지로 중요한 섹션이있는 모듈을 C로 작성할 수 있습니다 (예 : CPAN의 PDL 모듈).</target>
        </trans-unit>
        <trans-unit id="fd02787c52da0901c066d4ccff09232fd888e22e" translate="yes" xml:space="preserve">
          <source>A different type of portability issue arises when writing XS code: availability of a C compiler on the end-user's system. C brings with it its own portability issues, and writing XS code will expose you to some of those. Writing purely in Perl is an easier way to achieve portability.</source>
          <target state="translated">XS 코드를 작성할 때 다른 유형의 이식성 문제가 발생합니다. 최종 사용자 시스템에서 C 컴파일러의 가용성입니다. C에는 자체 이식성 문제가 있으며 XS 코드를 작성하면 그 중 일부에 노출됩니다. Perl로 순수하게 작성하는 것이 이식성을 얻는 쉬운 방법입니다.</target>
        </trans-unit>
        <trans-unit id="7549e9114a09a619af3acd4b50c3c4a53ce35871" translate="yes" xml:space="preserve">
          <source>A direct &lt;b&gt;connection&lt;/b&gt; that carries the output of one &lt;b&gt;process&lt;/b&gt; to the input of another without an intermediate temporary file. Once the pipe is set up, the two processes in question can read and write as if they were talking to a normal file, with some caveats.</source>
          <target state="translated">하나의 &lt;b&gt;프로세스&lt;/b&gt; 출력을 전달 하는 직접 &lt;b&gt;연결&lt;/b&gt;&lt;b&gt;&lt;/b&gt;중간 임시 파일없이 의 입력으로 . 파이프가 설정되면 문제의 두 프로세스가 정상적인 파일과 대화하고있는 것처럼 읽고 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b845b5f598804539b9d3429d1e0dde292769ef5" translate="yes" xml:space="preserve">
          <source>A distribution of modules to handle locale codes</source>
          <target state="translated">로캘 코드를 처리하기위한 모듈 배포</target>
        </trans-unit>
        <trans-unit id="3e6b7ccc64e5147f1acc2484c6d3b919c5bc2282" translate="yes" xml:space="preserve">
          <source>A document having more than one &quot;=encoding&quot; line should be considered an error. Pod processors may silently tolerate this if the not-first &quot;=encoding&quot; lines are just duplicates of the first one (e.g., if there's a &quot;=encoding utf8&quot; line, and later on another &quot;=encoding utf8&quot; line). But Pod processors should complain if there are contradictory &quot;=encoding&quot; lines in the same document (e.g., if there is a &quot;=encoding utf8&quot; early in the document and &quot;=encoding big5&quot; later). Pod processors that recognize BOMs may also complain if they see an &quot;=encoding&quot; line that contradicts the BOM (e.g., if a document with a UTF-16LE BOM has an &quot;=encoding shiftjis&quot; line).</source>
          <target state="translated">&quot;= 인코딩&quot;줄이 둘 이상인 문서는 오류로 간주해야합니다. 포드 프로세서가 아닌 첫 번째 &quot;= 인코딩&quot;행이 첫 번째 행의 복제 본인 경우 (예 : &quot;= 인코딩 utf8&quot;행이 있고 나중에 다른 &quot;= 인코딩 utf8&quot;행에있는 경우) 포드 프로세서는 자동으로이를 허용 할 수 있습니다. 그러나 포드 프로세서는 동일한 문서에 모순되는 &quot;= 인코딩&quot;행이있는 경우 (예 : 문서의 초기에 &quot;= 인코딩 utf8&quot;이 있고 나중에 &quot;= 인코딩 big5&quot;인 경우) 불만을 제기해야합니다. BOM을 인식하는 포드 프로세서는 BOM과 모순되는 &quot;= 인코딩&quot;행이 표시 될 경우 (예 : UTF-16LE BOM이있는 문서에 &quot;= 인코딩 시프트 지&quot;행이있는 경우) 불만을 제기 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4df78e410296e2b3f4b712de1ae484fe7cd130b2" translate="yes" xml:space="preserve">
          <source>A document type tag for the file. This option is not set by default.</source>
          <target state="translated">파일의 문서 유형 태그입니다. 이 옵션은 기본적으로 설정되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d80c6e485dc27886043d9d72950290e87158018b" translate="yes" xml:space="preserve">
          <source>A domain of names. You needn&amp;rsquo;t worry about whether the names in one such domain have been used in another. See &lt;b&gt;package&lt;/b&gt;.</source>
          <target state="translated">이름의 도메인. 한 도메인의 이름이 다른 도메인의 이름에 사용되었는지 여부에 대해 걱정할 필요가 없습니다. &lt;b&gt;package를&lt;/b&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7598f11ff5b1103678a9d5639c3dfc75e6d4a5e6" translate="yes" xml:space="preserve">
          <source>A double precision floating point number. This typemap guarantees to return a variable cast to a &lt;code&gt;double&lt;/code&gt; .</source>
          <target state="translated">배정 밀도 부동 소수점 숫자 이 타입 맵은 변수 캐스트를 &lt;code&gt;double&lt;/code&gt; 로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="102050331265d60ae1056cdc3a0d24fd9e06376e" translate="yes" xml:space="preserve">
          <source>A double-quoted, interpolated string.</source>
          <target state="translated">큰 따옴표로 묶어 보간 된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="faeb399a5d08eaa739b873af03a2a402dd907834" translate="yes" xml:space="preserve">
          <source>A dummy layer which never exists on the layer stack. Instead when &quot;pushed&quot; it actually pops the stack removing itself, it then calls Binmode function table entry on all the layers in the stack - normally this (via PerlIOBase_binmode) removes any layers which do not have &lt;code&gt;PERLIO_K_RAW&lt;/code&gt; bit set. Layers can modify that behaviour by defining their own Binmode entry.</source>
          <target state="translated">레이어 스택에 존재하지 않는 더미 레이어. 대신에 &quot;푸시&quot;된 경우 실제로 스택 자체가 제거되어 팝업에서 스택의 모든 레이어에 대해 Binmode 함수 테이블 항목을 호출합니다. 일반적으로 PerlIOBase_binmode를 통해 &lt;code&gt;PERLIO_K_RAW&lt;/code&gt; 비트가 설정 되지 않은 모든 레이어를 제거합니다 . 레이어는 자체 Binmode 항목을 정의하여 해당 동작을 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f90a52847d42c09984d572f3b595cda347017f00" translate="yes" xml:space="preserve">
          <source>A failed match or changing the target string resets the position. If you don't want the position reset after failure to match, add the &lt;code&gt;//c&lt;/code&gt; , as in &lt;code&gt;/regex/gc&lt;/code&gt; .</source>
          <target state="translated">일치하지 않거나 대상 문자열을 변경하면 위치가 재설정됩니다. 실패한 후 위치를 재설정하지 않으려면 &lt;code&gt;/regex/gc&lt;/code&gt; 와 같이 &lt;code&gt;//c&lt;/code&gt; 를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="d5efee2d4f79d8ba35cf758e77756920ee770903" translate="yes" xml:space="preserve">
          <source>A failed match or changing the target string resets the position. If you don't want the position reset after failure to match, add the &lt;code&gt;//c&lt;/code&gt; , as in &lt;code&gt;/regexp/gc&lt;/code&gt; . The current position in the string is associated with the string, not the regexp. This means that different strings have different positions and their respective positions can be set or read independently.</source>
          <target state="translated">일치하지 않거나 대상 문자열을 변경하면 위치가 재설정됩니다. 실패 후 위치 재설정을 원하지 않으면 &lt;code&gt;/regexp/gc&lt;/code&gt; 에서와 같이 &lt;code&gt;//c&lt;/code&gt; 를 추가하십시오 . 문자열의 현재 위치는 정규 표현식이 아닌 문자열과 연결됩니다. 이것은 다른 스트링이 다른 위치를 가지며 각각의 위치가 독립적으로 설정되거나 읽힐 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="656a7d55b2753fa751b87d85db4a4654a61963c4" translate="yes" xml:space="preserve">
          <source>A fairly common feature in applications is to allow you to define a C function that will be called whenever something nasty occurs. What we would like is to be able to specify a Perl subroutine that will be called instead.</source>
          <target state="translated">응용 프로그램에서 상당히 일반적인 기능은 문제가 발생할 때마다 호출되는 C 함수를 정의 할 수 있도록하는 것입니다. 우리가 원하는 것은 대신 호출 될 Perl 서브 루틴을 지정할 수있는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e27669facce8e75680a82515ceb4a7dde4554488" translate="yes" xml:space="preserve">
          <source>A fancy computer science term meaning &amp;ldquo;to follow a &lt;b&gt;reference&lt;/b&gt; to what it points to&amp;rdquo;. The &amp;ldquo;de&amp;rdquo; part of it refers to the fact that you&amp;rsquo;re taking away one level of &lt;b&gt;indirection&lt;/b&gt;.</source>
          <target state="translated">&amp;ldquo; 이것이 가리키는 것을 &lt;b&gt;참조&lt;/b&gt; 하는 것 &amp;rdquo;을 의미하는 멋진 컴퓨터 과학 용어 . 그것의 &quot;de&quot;부분은 당신이 한 수준의 &lt;b&gt;간접적&lt;/b&gt; 인 &lt;b&gt;태도를&lt;/b&gt; 취하고 있다는 사실을 말합니다 .</target>
        </trans-unit>
        <trans-unit id="8f4dde098cc45c330d3e8fa85a502fc0eae6cde3" translate="yes" xml:space="preserve">
          <source>A fancy kind of interlock that prevents multiple &lt;b&gt;threads&lt;/b&gt; or &lt;b&gt;processes&lt;/b&gt; from using up the same resources simultaneously.</source>
          <target state="translated">여러 &lt;b&gt;스레드&lt;/b&gt; 또는 &lt;b&gt;프로세스&lt;/b&gt; 가 동일한 리소스를 동시에 사용 하지 못하게하는 멋진 종류의 인터록입니다 .</target>
        </trans-unit>
        <trans-unit id="2f52178a4e9cc243237404e962bb98cf1d11d03e" translate="yes" xml:space="preserve">
          <source>A fancy term for an error. See &lt;b&gt;fatal error&lt;/b&gt;.</source>
          <target state="translated">오류에 대한 멋진 용어. &lt;b&gt;치명적인 오류를&lt;/b&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d130552cd3247973054cf88d786bc01b68b3a6e5" translate="yes" xml:space="preserve">
          <source>A fatal error will be thrown if the Compress::Zlib module is not available.</source>
          <target state="translated">Compress :: Zlib 모듈을 사용할 수 없으면 치명적인 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c1f172aa731045204a1719d56bb2cc8625060274" translate="yes" xml:space="preserve">
          <source>A fatal error will be thrown if:</source>
          <target state="translated">다음과 같은 경우 치명적인 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="206dcfa56d21a53d3ca90835f2da1335f0ce9141" translate="yes" xml:space="preserve">
          <source>A feature of &lt;b&gt;operator overloading&lt;/b&gt; of &lt;b&gt;objects&lt;/b&gt;, whereby the behavior of certain &lt;b&gt;operators&lt;/b&gt; can be reasonably deduced using more fundamental operators. This assumes that the overloaded operators will often have the same relationships as the regular operators. See Camel chapter 13, &amp;ldquo;Overloading&amp;rdquo;.</source>
          <target state="translated">의 특징 &lt;b&gt;연산자 오버로딩&lt;/b&gt; 의 &lt;b&gt;객체&lt;/b&gt; 특정의 동작함으로써, &lt;b&gt;운영자가&lt;/b&gt; 합리적으로 더 근본적인 연산자를 사용하여 추론 할 수있다. 이것은 오버로드 된 연산자가 종종 일반 연산자와 동일한 관계를 갖는 것으로 가정합니다. 낙타 13 장 &quot;오버로딩&quot;을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="96f7456dc10c0f5e5c69de568de641b9d361467e" translate="yes" xml:space="preserve">
          <source>A few dir-vs-file optimizations result in glob importation being 10 times faster than using perlglob.exe, and using perlglob.bat is only twice as slow as perlglob.exe (GSAR 28-MAY-97)</source>
          <target state="translated">몇 가지 dir-vs-file 최적화는 perlglob.exe를 사용하는 것보다 글로브 가져 오기가 10 배 더 빠르며 perlglob.bat를 사용하는 것이 perlglob.exe보다 2 배 느립니다 (GSAR 28-MAY-97)</target>
        </trans-unit>
        <trans-unit id="29b977997a9e174d5b0509df5c6aa92021e1d1e4" translate="yes" xml:space="preserve">
          <source>A few example globmaps</source>
          <target state="translated">글로브 맵 예제</target>
        </trans-unit>
        <trans-unit id="4079515a56f3376aa599af18d3ce02d4fa762708" translate="yes" xml:space="preserve">
          <source>A few functions are not implemented because they are C specific. If you attempt to call these, they will print a message telling you that they aren't implemented, and suggest using the Perl equivalent, should one exist. For example, trying to access the &lt;code&gt;setjmp()&lt;/code&gt; call will elicit the message &quot;&lt;code&gt;setjmp() is C-specific: &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {} instead&lt;/code&gt; &quot;.</source>
          <target state="translated">일부 기능은 C에 고유하기 때문에 구현되지 않습니다. 이것을 호출하려고 시도하면 구현되지 않았 음을 알리는 메시지를 인쇄하고 Perl과 동등한 것을 사용하도록 제안합니다. 예를 들어, 액세스를 시도 &lt;code&gt;setjmp()&lt;/code&gt; 메시지 이끌어내는 것이다 전화를 &quot; &lt;code&gt;setjmp() is C-specific: &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {} instead&lt;/code&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="dcd9feea0227978a722652bf64b2da3e239d9119" translate="yes" xml:space="preserve">
          <source>A few functions take no arguments at all, and therefore work as neither unary nor list operators. These include such functions as &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/endpwent&quot;&gt;endpwent&lt;/a&gt;&lt;/code&gt;. For example, &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time+86_400&lt;/a&gt;&lt;/code&gt; always means &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;() + 86_400&lt;/code&gt; .</source>
          <target state="translated">일부 함수는 인수를 전혀 취하지 않으므로 단항 연산자 나 목록 연산자로 작동하지 않습니다. 여기에는 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/endpwent&quot;&gt;endpwent&lt;/a&gt;&lt;/code&gt; 와 같은 기능이 포함됩니다 . 예를 들어 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time+86_400&lt;/a&gt;&lt;/code&gt; 은 항상 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;() + 86_400&lt;/code&gt; 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="18d4ec4509605bbb34d201f389b34f426f595148" translate="yes" xml:space="preserve">
          <source>A few general-purpose tools are shipped with perl, mostly because they came along modules included in the perl distribution.</source>
          <target state="translated">일부 범용 도구는 펄 배포판에 포함 된 모듈을 사용했기 때문에 펄과 함께 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="6c69ec260ad056301204f0c643b8c2696665eb7e" translate="yes" xml:space="preserve">
          <source>A few methods are provided to do the &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt; Your::Module tests =&amp;gt; 23&lt;/code&gt; part for you.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt; Your::Module tests =&amp;gt; 23&lt;/code&gt; 부분을 &lt;a href=&quot;../../functions/use&quot;&gt;사용&lt;/a&gt; 하기 위한 몇 가지 방법이 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="aa6d4c905f963b3015f8686516337be08979225b" translate="yes" xml:space="preserve">
          <source>A few more:</source>
          <target state="translated">몇 가지 더 :</target>
        </trans-unit>
        <trans-unit id="6eb9b3626d6aeb9e84350d1131ed3080f1617e37" translate="yes" xml:space="preserve">
          <source>A few of the options need extra discussion here. When used, the C equivalent of the keys &lt;code&gt;hash&lt;/code&gt; , &lt;code&gt;compare&lt;/code&gt; and &lt;code&gt;prefix&lt;/code&gt; store pointers to C functions. In &lt;b&gt;DB_File&lt;/b&gt; these keys are used to store references to Perl subs. Below are templates for each of the subs:</source>
          <target state="translated">몇 가지 옵션은 여기에서 추가 토론이 필요합니다. 사용될 때, 키의 C 당량 &lt;code&gt;hash&lt;/code&gt; , &lt;code&gt;compare&lt;/code&gt; 및 &lt;code&gt;prefix&lt;/code&gt; C 함수 포인터를 저장. 에서 &lt;b&gt;DB_File&lt;/b&gt; 이 키는 펄 잠수정에 대한 참조를 저장하는 데 사용됩니다. 아래는 각 서브에 대한 템플릿입니다.</target>
        </trans-unit>
        <trans-unit id="c283830e9199de7049f4c9e9b8481f0f4f024e4c" translate="yes" xml:space="preserve">
          <source>A few of these variables are considered &quot;read-only&quot;. This means that if you try to assign to this variable, either directly or indirectly through a reference, you'll raise a run-time exception.</source>
          <target state="translated">이러한 변수 중 일부는 &quot;읽기 전용&quot;으로 간주됩니다. 즉, 참조를 통해 직접 또는 간접적으로이 변수에 할당하려고하면 런타임 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8090aa705fafbfcbe40caa6a39d4969f2ffa75f0" translate="yes" xml:space="preserve">
          <source>A few points to note about this example:</source>
          <target state="translated">이 예제에서주의해야 할 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5940abb3e966e0e3ab0e5074976963a86d9bf337" translate="yes" xml:space="preserve">
          <source>A few special SV heads are not allocated from an arena, but are instead directly created in the interpreter structure, eg PL_sv_undef. The size of arenas can be changed from the default by setting PERL_ARENA_SIZE appropriately at compile time.</source>
          <target state="translated">몇몇 특수 SV 헤드는 경기장에서 할당되지 않지만 대신 인터프리터 구조 (예 : PL_sv_undef)에 직접 생성됩니다. 컴파일시 PERL_ARENA_SIZE를 적절하게 설정하여 경기장의 크기를 기본값에서 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99bc1dc13c67f6154f44d88464d4083e5ca5c87d" translate="yes" xml:space="preserve">
          <source>A fifo is convenient when you want to connect a process to an unrelated one. When you open a fifo, the program will block until there's something on the other end.</source>
          <target state="translated">프로세스를 관련없는 프로세스에 연결하려는 경우 fifo가 편리합니다. fifo를 열면 다른 쪽 끝에 무언가가있을 때까지 프로그램이 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="0034cae2f50c204559522cfff1ceebd6deb989fa" translate="yes" xml:space="preserve">
          <source>A file containing certain required definitions that you must include &amp;ldquo;ahead&amp;rdquo; of the rest of your program to do certain obscure operations. A C header file has a</source>
          <target state="translated">특정 모호한 조작을 수행하기 위해 나머지 프로그램의 &quot;미리&quot;를 포함해야하는 특정 필수 정의가 포함 된 파일. AC 헤더 파일에는</target>
        </trans-unit>
        <trans-unit id="731000aad647991373ca7dfb79bf96ee23280bc2" translate="yes" xml:space="preserve">
          <source>A file full of regular expressions to exclude when using 'make manifest' to generate the MANIFEST. These regular expressions are checked against each file path found in the distribution (so you're matching against &quot;t/foo.t&quot; not &quot;foo.t&quot;).</source>
          <target state="translated">'make manifest'를 사용하여 MANIFEST를 생성 할 때 제외 할 정규식으로 가득 찬 파일입니다. 이 정규식은 배포판에서 찾은 각 파일 경로에 대해 검사되므로 &quot;foo.t&quot;가 아닌 &quot;t / foo.t&quot;와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="a17865a45ecaf1ad63bbdbb5dd8742ba69a071dc" translate="yes" xml:space="preserve">
          <source>A file in XS format starts with a C language section which goes until the first &lt;code&gt;MODULE =&lt;/code&gt; directive. Other XS directives and XSUB definitions may follow this line. The &quot;language&quot; used in this part of the file is usually referred to as the XS language. &lt;b&gt;xsubpp&lt;/b&gt; recognizes and skips POD (see &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;) in both the C and XS language sections, which allows the XS file to contain embedded documentation.</source>
          <target state="translated">XS 형식의 파일은 첫 번째 &lt;code&gt;MODULE =&lt;/code&gt; 지시문 까지 진행되는 C 언어 섹션으로 시작 합니다. 다른 XS 지시문 및 XSUB 정의는이 줄을 따를 수 있습니다. 파일의이 부분에서 사용되는 &quot;언어&quot;는 일반적으로 XS 언어라고합니다. &lt;b&gt;xsubpp&lt;/b&gt; 는 C 및 XS 언어 섹션에서 POD ( &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt; 참조 )를 인식하고 건너 뛰 므로 XS 파일에 포함 된 문서가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51841b4270c479a7cdbc29c3d5f66446edf393a3" translate="yes" xml:space="preserve">
          <source>A file test, where X is one of the letters listed below. This unary operator takes one argument, either a filename, a filehandle, or a dirhandle, and tests the associated file to see if something is true about it. If the argument is omitted, tests &lt;code&gt;$_&lt;/code&gt; , except for &lt;code&gt;-t&lt;/code&gt; , which tests STDIN. Unless otherwise documented, it returns &lt;code&gt;1&lt;/code&gt; for true and &lt;code&gt;''&lt;/code&gt; for false. If the file doesn't exist or can't be examined, it returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and sets &lt;code&gt;$!&lt;/code&gt; (errno). Despite the funny names, precedence is the same as any other named unary operator. The operator may be any of:</source>
          <target state="translated">파일 테스트. 여기서 X는 아래 나열된 문자 중 하나입니다. 이 단항 연산자는 파일 이름, 파일 핸들 또는 dirhandle 중 하나의 인수를 사용하여 연관된 파일을 테스트하여 그에 대한 것이 사실인지 확인합니다. 인수가 생략되면 STDIN을 테스트하는 &lt;code&gt;-t&lt;/code&gt; 를 제외하고 &lt;code&gt;$_&lt;/code&gt; 를 테스트하십시오. 달리 문서화되어 있지 않으면 true이면 &lt;code&gt;1&lt;/code&gt; 을, false에는 &lt;code&gt;''&lt;/code&gt; 를 반환합니다 . 파일이 없거나 검사 할 수 없으면 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환 하고 &lt;code&gt;$!&lt;/code&gt; 를 설정합니다 . (errno). 재미있는 이름에도 불구하고 우선 순위는 다른 이름이 지정된 단항 연산자와 동일합니다. 운영자는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c04b0088e704fdeb38d1fecd8838e16e9a29f09" translate="yes" xml:space="preserve">
          <source>A file test, where X is one of the letters listed below. This unary operator takes one argument, either a filename, a filehandle, or a dirhandle, and tests the associated file to see if something is true about it. If the argument is omitted, tests &lt;code&gt;$_&lt;/code&gt; , except for &lt;code&gt;-t&lt;/code&gt; , which tests STDIN. Unless otherwise documented, it returns &lt;code&gt;1&lt;/code&gt; for true and &lt;code&gt;''&lt;/code&gt; for false. If the file doesn't exist or can't be examined, it returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and sets &lt;code&gt;$!&lt;/code&gt; (errno). Despite the funny names, precedence is the same as any other named unary operator. The operator may be any of:</source>
          <target state="translated">파일 테스트. 여기서 X는 아래 나열된 문자 중 하나입니다. 이 단항 연산자는 파일 이름, 파일 핸들 또는 dirhandle 중 하나의 인수를 사용하여 연관된 파일을 테스트하여 그에 대한 것이 사실인지 확인합니다. 인수가 생략되면 STDIN을 테스트하는 &lt;code&gt;-t&lt;/code&gt; 를 제외하고 &lt;code&gt;$_&lt;/code&gt; 를 테스트하십시오. 달리 문서화되어 있지 않으면 true이면 &lt;code&gt;1&lt;/code&gt; 을, false에는 &lt;code&gt;''&lt;/code&gt; 를 반환합니다 . 파일이 없거나 검사 할 수 없으면 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환 하고 &lt;code&gt;$!&lt;/code&gt; 를 설정합니다 . (errno). 재미있는 이름에도 불구하고 우선 순위는 다른 이름이 지정된 단항 연산자와 동일합니다. 운영자는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85304934df21007f1e6dacead79952e515167d3e" translate="yes" xml:space="preserve">
          <source>A file that controls the compilation of a program. Perl programs don&amp;rsquo;t usually need a &lt;b&gt;Makefile&lt;/b&gt; because the Perl compiler has plenty of self-control.</source>
          <target state="translated">프로그램 컴파일을 제어하는 ​​파일입니다. Perl 컴파일러에는 많은 자체 제어 기능이 있으므로 Perl 프로그램에는 일반적으로 &lt;b&gt;Makefile이&lt;/b&gt; 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0ef0646f1946010fd71391d670cdd7f3f2cde9ba" translate="yes" xml:space="preserve">
          <source>A filehandle for catching standard output.</source>
          <target state="translated">표준 출력을 잡기위한 파일 핸들.</target>
        </trans-unit>
        <trans-unit id="dddbea875ae221e63e546196812256d3f13f54a9" translate="yes" xml:space="preserve">
          <source>A filehandle is opened but the file operations are performed &quot;in-memory&quot; on a scalar variable. All the normal file operations can be performed on the handle. The scalar is considered a stream of bytes. Currently fileno($fh) returns -1.</source>
          <target state="translated">파일 핸들이 열리지 만 파일 작업은 스칼라 변수에서 &quot;메모리 내&quot;로 수행됩니다. 핸들에서 모든 일반 파일 작업을 수행 할 수 있습니다. 스칼라는 바이트 스트림으로 간주됩니다. 현재 fileno ($ fh)는 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2ead9b8d6ddfb62275b7ebf2bc90be0c9e8b9ced" translate="yes" xml:space="preserve">
          <source>A filehandle that should read or write UTF-8</source>
          <target state="translated">UTF-8을 읽거나 써야하는 파일 핸들</target>
        </trans-unit>
        <trans-unit id="c2227149e71cd22222d8c43a50c19d04660c6c2c" translate="yes" xml:space="preserve">
          <source>A filehandle to write the C code to. If not given, then</source>
          <target state="translated">C 코드를 작성할 파일 핸들입니다. 제공하지 않으면</target>
        </trans-unit>
        <trans-unit id="51118efef78727e7eccbadc9f314bd7f4afcf597" translate="yes" xml:space="preserve">
          <source>A filehandle to write the XS code to. If not given, then</source>
          <target state="translated">XS 코드를 작성할 파일 핸들입니다. 제공하지 않으면</target>
        </trans-unit>
        <trans-unit id="94e7ed7be4ff1750888b6ea45dc5effd2b37d94d" translate="yes" xml:space="preserve">
          <source>A filehandle, from which the file will be read.</source>
          <target state="translated">파일을 읽을 파일 핸들.</target>
        </trans-unit>
        <trans-unit id="c34303a3b313a718df7cf274a0efcf1c25994c0c" translate="yes" xml:space="preserve">
          <source>A filetest operator, with exactly 4 exceptions: &lt;code&gt;-s&lt;/code&gt; , &lt;code&gt;-M&lt;/code&gt; , &lt;code&gt;-A&lt;/code&gt; , and &lt;code&gt;-C&lt;/code&gt; , as these return numerical values, not boolean ones. The &lt;code&gt;-z&lt;/code&gt; filetest operator is not included in the exception list.</source>
          <target state="translated">부울 값이 아닌 숫자 값을 반환하므로 &lt;code&gt;-s&lt;/code&gt; , &lt;code&gt;-M&lt;/code&gt; , &lt;code&gt;-A&lt;/code&gt; 및 &lt;code&gt;-C&lt;/code&gt; 정확히 4 개의 예외가있는 파일 테스트 연산자 입니다. &lt;code&gt;-z&lt;/code&gt; 파일 테스트 연산자 예외 목록에 포함되지 않는다.</target>
        </trans-unit>
        <trans-unit id="571b7a68e22aaaa36cb39947748347ab43ae89aa" translate="yes" xml:space="preserve">
          <source>A filter program, in the traditional Unix sense (input from stdin, output to stdout) that is passed on each .pm file during the build (in the pm_to_blib() phase). It is empty by default, meaning no filtering is done.</source>
          <target state="translated">빌드 과정 (pm_to_blib () 단계에서) 동안 각 .pm 파일에 전달되는 일반적인 Unix 의미 (stdin에서 입력, 출력으로 stdout으로)의 필터 프로그램입니다. 기본적으로 비어 있으므로 필터링이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fb35ae131a8a2012ab4bde2210fbfdcbd7023aa3" translate="yes" xml:space="preserve">
          <source>A fix for Proc::ProcessTable is to edit Makefile to explicitly remove the largefile flags from the ones MakeMaker picks up from Config.pm. This will result in Proc::ProcessTable being built under the correct environment. Everything should then be OK as long as Proc::ProcessTable doesn't try to share off_t's with the rest of perl, or if it does they should be explicitly specified as off64_t.</source>
          <target state="translated">Proc :: ProcessTable에 대한 수정은 Makefile을 편집하여 Config.pm에서 MakeMaker가 선택하는 것에서 큰 파일 플래그를 명시 적으로 제거하는 것입니다. 이로 인해 Proc :: ProcessTable이 올바른 환경에서 빌드됩니다. Proc :: ProcessTable이 off_t를 나머지 perl과 공유하려고 시도하지 않는 한, 그렇지 않으면 명시 적으로 off64_t로 지정되어야합니다.</target>
        </trans-unit>
        <trans-unit id="a9d22545c3578b64eb5fa290d40cfb8cd3124e35" translate="yes" xml:space="preserve">
          <source>A fix for that problem is scheduled to be released in the following levels of AIX, all of which should be coming out in the 4th quarter of 2009:</source>
          <target state="translated">이 문제점에 대한 픽스는 다음 레벨의 AIX에서 릴리스 될 예정이며, 모두 2009 년 4 분기에 출시 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="fbcd311c30c802b9eee4a011f2523c74bbb4eeb7" translate="yes" xml:space="preserve">
          <source>A fixed length thing, given as a [pointer, length] pair. If you know the length of a string at compile time you may use this instead of</source>
          <target state="translated">[포인터, 길이] 쌍으로 주어진 고정 길이의 것. 컴파일 타임에 문자열의 길이를 알고 있다면 대신에 이것을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="2dd9070969808d13493b31f8533aee2df5f82471" translate="yes" xml:space="preserve">
          <source>A fixed number of digits before (positive) or after (negative) the decimal point. For example, 123.45 has a precision of -2. 0 means an integer like 123 (or 120). A precision of 2 means two digits to the left of the decimal point are zero, so 123 with P = 1 becomes 120. Note that numbers with zeros before the decimal point may have different precisions, because 1200 can have p = 0, 1 or 2 (depending on what the initial value was). It could also have p &amp;lt; 0, when the digits after the decimal point are zero.</source>
          <target state="translated">소수점 앞 (양수) 또는 이후 (음수)의 고정 자릿수입니다. 예를 들어, 123.45의 정밀도는 -2입니다. 0은 123 (또는 120)과 같은 정수를 의미합니다. 정밀도 2는 소수점 왼쪽의 두 자리 숫자가 0이므로 P = 1 인 123은 120이됩니다. 소수점 앞에 0이있는 숫자는 정밀도가 다를 수 있습니다. 1200은 p = 0, 1 또는 2 (초기 값에 따라 다름). 소수점 뒤의 숫자가 0 일 때 p &amp;lt;0을 가질 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="27aa36567c7de687c1256c668f8713e83fe0a789" translate="yes" xml:space="preserve">
          <source>A flag for whether item 3 (if present) is a URL (like &quot;&lt;a href=&quot;http://lists.perl.org&quot;&gt;http://lists.perl.org&lt;/a&gt;&quot; is), in which case there should be no section attribute; a Pod name (like &quot;perldoc&quot; and &quot;Getopt::Std&quot; are); or possibly a man page name (like &quot;crontab(5)&quot; is).</source>
          <target state="translated">항목 3 (있는 경우)이 URL (예 : &quot; &lt;a href=&quot;http://lists.perl.org&quot;&gt;http://lists.perl.org&lt;/a&gt; &quot; 와 같은)인지 여부에 대한 플래그입니다 .이 경우 섹션 속성이 없어야합니다. 포드 이름 (예 : &quot;perldoc&quot;및 &quot;Getopt :: Std&quot;); 또는 맨 페이지 이름 (예 : &quot;crontab (5)&quot;은)입니다.</target>
        </trans-unit>
        <trans-unit id="aa81fd53ffda939e60f21a6a48bc3fd1ecb33421" translate="yes" xml:space="preserve">
          <source>A floating point number potentially has a sign, an integral part, a decimal point, a fractional part, and an exponent. One or more of these parts is optional, so we need to check out the different possibilities. Floating point numbers which are in proper form include 123., 0.345, .34, -1e6, and 25.4E-72. As with integers, the sign out front is completely optional and can be matched by &lt;code&gt;[+-]?&lt;/code&gt;. We can see that if there is no exponent, floating point numbers must have a decimal point, otherwise they are integers. We might be tempted to model these with &lt;code&gt;\d*\.\d*&lt;/code&gt;, but this would also match just a single decimal point, which is not a number. So the three cases of floating point number without exponent are</source>
          <target state="translated">부동 소수점 숫자에는 부호, 정수 부분, 소수점, 분수 부분 및 지수가있을 수 있습니다. 이러한 부분 중 하나 이상은 선택 사항이므로 다양한 가능성을 확인해야합니다. 올바른 형식의 부동 소수점 숫자는 123., 0.345, .34, -1e6 및 25.4E-72를 포함합니다. 정수와 마찬가지로 부호 앞면은 선택 사항이며 &lt;code&gt;[+-]?&lt;/code&gt; 와 일치시킬 수 있습니까? . 지수가없는 경우 부동 소수점 숫자에는 소수점이 있어야하며 그렇지 않으면 정수입니다. 우리는 이것을 &lt;code&gt;\d*\.\d*&lt;/code&gt; 로 모델링하고 싶을 수도 있지만 이것은 숫자가 아닌 하나의 소수점과도 일치합니다. 따라서 지수가없는 부동 소수점 숫자의 세 가지 경우는</target>
        </trans-unit>
        <trans-unit id="ff8a1f9e295a3b368fdb0bcb2f6682d3f1a7706d" translate="yes" xml:space="preserve">
          <source>A floating point number. This typemap guarantees to return a variable cast to a &lt;code&gt;float&lt;/code&gt; .</source>
          <target state="translated">부동 소수점 숫자 이 타입 맵은 변수 캐스트를 &lt;code&gt;float&lt;/code&gt; 로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="cb62089bcb14b38f0a60a1ce278c6aa2cfaf6aec" translate="yes" xml:space="preserve">
          <source>A flow of data into or out of a process as a steady sequence of bytes or characters, without the appearance of being broken up into packets. This is a kind of &lt;b&gt;interface&lt;/b&gt;&amp;mdash;the underlying &lt;b&gt;implementation&lt;/b&gt; may well break your data up into separate packets for delivery, but this is hidden from you.</source>
          <target state="translated">패킷으로 나뉘 지 않고 꾸준한 바이트 또는 문자 시퀀스로 프로세스 내부 또는 외부에서 데이터 흐름. 이것은 일종의 &lt;b&gt;인터페이스입니다.&lt;/b&gt; 기본 &lt;b&gt;구현&lt;/b&gt; 은 데이터를 전달하기 위해 별도의 패킷으로 나눌 수 있지만 이것은 숨겨져 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7f93ab55d0cd5dedac331be7a34ca8ef2c56a43" translate="yes" xml:space="preserve">
          <source>A form name &lt;code&gt;Unicode::Normalize::normalize()&lt;/code&gt; accepts will be applied as &lt;code&gt;$normalization_form&lt;/code&gt; . Acceptable names include &lt;code&gt;'NFD'&lt;/code&gt; , &lt;code&gt;'NFC'&lt;/code&gt; , &lt;code&gt;'NFKD'&lt;/code&gt; , and &lt;code&gt;'NFKC'&lt;/code&gt; . See &lt;code&gt;Unicode::Normalize::normalize()&lt;/code&gt; for detail. If omitted, &lt;code&gt;'NFD'&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;Unicode::Normalize::normalize()&lt;/code&gt; 수락 형식 이름 은 &lt;code&gt;$normalization_form&lt;/code&gt; 으로 적용됩니다 . 허용 가능한 이름은 &lt;code&gt;'NFD'&lt;/code&gt; , &lt;code&gt;'NFC'&lt;/code&gt; , &lt;code&gt;'NFKD'&lt;/code&gt; 및 &lt;code&gt;'NFKC'&lt;/code&gt; 입니다. 자세한 내용은 &lt;code&gt;Unicode::Normalize::normalize()&lt;/code&gt; 를 참조하십시오 . 생략하면 &lt;code&gt;'NFD'&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c49b8a933b39ce175d6f4d01ed275b88dda586c3" translate="yes" xml:space="preserve">
          <source>A form of &lt;b&gt;scalar context&lt;/b&gt; in which an &lt;b&gt;expression&lt;/b&gt; is not expected to return any &lt;b&gt;value&lt;/b&gt; at all and is evaluated for its &lt;b&gt;side effects&lt;/b&gt; alone.</source>
          <target state="translated">&lt;b&gt;표현식&lt;/b&gt; 이 어떤 &lt;b&gt;값도&lt;/b&gt; 반환하지 않을 것으로 예상되고 &lt;b&gt;부작용&lt;/b&gt; 만 평가 되는 &lt;b&gt;스칼라 컨텍스트&lt;/b&gt; 형식입니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="95b8b92c738006a6a5118bef738de47b796e9ea2" translate="yes" xml:space="preserve">
          <source>A formal grammar would look similar to the following:</source>
          <target state="translated">공식 문법은 다음과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="8f6424f6bb5e3764fd5434bcd18cd75bdd7582fd" translate="yes" xml:space="preserve">
          <source>A format name of &quot;comment&quot; is common for just making notes (presumably to yourself) that won't appear in any formatted version of the Pod document:</source>
          <target state="translated">&quot;댓글&quot;의 형식 이름은 Pod 문서의 형식화 된 버전에 표시되지 않는 메모 (아마도 자신에게)를 작성하는 데 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="d26b5fa96c287794c375f977fd86d1fe4bad1833" translate="yes" xml:space="preserve">
          <source>A formatting code starts with a capital letter (just US-ASCII [A-Z]) followed by a &quot;&amp;lt;&quot;, any number of characters, and ending with the first matching &quot;&amp;gt;&quot;. Examples:</source>
          <target state="translated">서식 코드는 대문자 (US-ASCII [AZ])로 시작하고 그 뒤에 &quot;&amp;lt;&quot;, 문자 수 및 첫 번째로 일치하는 &quot;&amp;gt;&quot;로 끝납니다. 예 :</target>
        </trans-unit>
        <trans-unit id="e1ebaf29b6e50a9147fa41854529f9f91464bbca" translate="yes" xml:space="preserve">
          <source>A formatting code starts with a capital letter (just US-ASCII [A-Z]) followed by two or more &quot;&amp;lt;&quot;'s, one or more whitespace characters, any number of characters, one or more whitespace characters, and ending with the first matching sequence of two or more &quot;&amp;gt;&quot;'s, where the number of &quot;&amp;gt;&quot;'s equals the number of &quot;&amp;lt;&quot;'s in the opening of this formatting code. Examples:</source>
          <target state="translated">서식 코드는 대문자로 시작하고 (US-ASCII [AZ] 만) 두 개 이상의 &quot;&amp;lt;&quot;, 하나 이상의 공백 문자, 여러 문자, 하나 이상의 공백 문자 및 첫 번째 문자로 끝납니다. 두 개 이상의 &quot;&amp;gt;&quot;의 일치 순서. 여기서 &quot;&amp;gt;&quot;의 수는이 형식화 코드의 시작에서 &quot;&amp;lt;&quot;의 수와 같습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="ee13838be926e942481224190d1b48d665a53c86" translate="yes" xml:space="preserve">
          <source>A free perl5-based PERL.NLM for Novell Netware is available in precompiled binary and source code form from &lt;a href=&quot;http://www.novell.com/&quot;&gt;http://www.novell.com/&lt;/a&gt; as well as from CPAN.</source>
          <target state="translated">Novell Netware 용 무료 perl5 기반 PERL.NLM은 &lt;a href=&quot;http://www.novell.com/&quot;&gt;http://www.novell.com/&lt;/a&gt; 과 CPAN 에서 사전 컴파일 된 이진 및 소스 코드 형식 으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="601ccb979c895092a89a9db855c8bb290abdfbb7" translate="yes" xml:space="preserve">
          <source>A from scratch implementation of buffering for PerlIO. Provides fast access to the buffer for &lt;code&gt;sv_gets&lt;/code&gt; which implements perl's readline/&amp;lt;&amp;gt; and in general attempts to minimize data copying.</source>
          <target state="translated">PerlIO를위한 처음부터 버퍼링 구현. perl의 readline / &amp;lt;&amp;gt;을 구현하고 일반적으로 데이터 복사를 최소화하려는 &lt;code&gt;sv_gets&lt;/code&gt; 의 버퍼에 빠르게 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f062561102eb36fb52de67c711e92bb30c79c71" translate="yes" xml:space="preserve">
          <source>A full commandline to run via &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt;. During execution, the environment variable PERL is set to $^X (but with an absolute path). If &lt;code&gt;commandline&lt;/code&gt; is specified, &lt;code&gt;args&lt;/code&gt; is not used.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 통해 실행되는 전체 명령 줄 . 실행 중에 환경 변수 PERL은 $ ^ X (절대 경로 포함)로 설정됩니다. 경우 &lt;code&gt;commandline&lt;/code&gt; 지정, &lt;code&gt;args&lt;/code&gt; 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="14cec31abd2e629547d353d78977abf26c0ffa5f" translate="yes" xml:space="preserve">
          <source>A full set of HTML documentation is installed, so you should be able to use it if you have a web browser installed on your system.</source>
          <target state="translated">HTML 문서의 전체 세트가 설치되어 있으므로 시스템에 웹 브라우저가 설치되어 있으면이를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a2c1a54fe4430e99127181c7879f97150ac83b4" translate="yes" xml:space="preserve">
          <source>A fully qualified filename such as</source>
          <target state="translated">정규화 된 파일 이름 (예 :</target>
        </trans-unit>
        <trans-unit id="66350a7ced5e0598bbaa01d95aa21c1aa8b64d66" translate="yes" xml:space="preserve">
          <source>A function named &lt;code&gt;new&lt;/code&gt; must not be explicitly defined in a class created by &lt;code&gt;struct&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 라는 함수 는 &lt;code&gt;struct&lt;/code&gt; 가 만든 클래스에 명시 적으로 정의되어서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="2945149f02dd35ba51bde27d2145bb414391b9dd" translate="yes" xml:space="preserve">
          <source>A function returning a single scalar with &lt;code&gt;#define&lt;/code&gt; definitions for the constants used internally between the generated C and XS functions.</source>
          <target state="translated">생성 된 C 함수와 XS 함수 사이에 내부적으로 사용되는 상수에 대해 &lt;code&gt;#define&lt;/code&gt; 정의가 있는 단일 스칼라를 반환하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="b69855856bd43ed93ca10429f84d959193788fea" translate="yes" xml:space="preserve">
          <source>A function that needs a filehandle of its own must use &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; on a complete typeglob. This can be used to create new symbol table entries:</source>
          <target state="translated">자체 파일 핸들이 필요한 함수 는 완전한 typeglob에서 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; 을 사용해야합니다 . 새 심볼 테이블 항목을 만드는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="074e275ec83817fc8f7919a77c7d1bc574268f70" translate="yes" xml:space="preserve">
          <source>A function that returns a &lt;b&gt;list&lt;/b&gt; of C subroutine definitions that return the value and type of constants when passed the name by the XS wrapper.</source>
          <target state="translated">XS 랩퍼가 이름을 전달할 때 상수 및 값 유형을 리턴하는 C 서브 루틴 정의 &lt;b&gt;목록&lt;/b&gt; 을 리턴하는 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="16f5ca42729ef594d519db59b85f9698b43a3153" translate="yes" xml:space="preserve">
          <source>A function to generate perl code for Makefile.PL that will regenerate the constant subroutines. Parameters are named as passed to &lt;code&gt;WriteConstants&lt;/code&gt; , with the addition of &lt;code&gt;INDENT&lt;/code&gt; to specify the number of leading spaces (default 2).</source>
          <target state="translated">상수 서브 루틴을 재생성하는 Makefile.PL에 대한 펄 코드를 생성하는 함수입니다. 선행 공간 수를 지정하기 위해 &lt;code&gt;INDENT&lt;/code&gt; 를 추가 하여 매개 변수의 이름이 &lt;code&gt;WriteConstants&lt;/code&gt; 로 전달됩니다 (기본값 2).</target>
        </trans-unit>
        <trans-unit id="6f1112f59bf733c8ebebfbb190c9c3efe0aeac9b" translate="yes" xml:space="preserve">
          <source>A function to generate the AUTOLOAD subroutine for the module</source>
          <target state="translated">모듈에 대한 AUTOLOAD 서브 루틴을 생성하는 기능</target>
        </trans-unit>
        <trans-unit id="b0a02614782733bf06479ea297bf790f7927505f" translate="yes" xml:space="preserve">
          <source>A function to generate the XS code to implement the perl subroutine</source>
          <target state="translated">Perl 서브 루틴을 구현하기 위해 XS 코드를 생성하는 기능</target>
        </trans-unit>
        <trans-unit id="94d15a8aa6cbd7f8b0a2a414f5a5f7d2b35f7284" translate="yes" xml:space="preserve">
          <source>A function which returns a 7 bit ASCII correctly \ escaped version of the string passed suitable for C's &quot;&quot; or ''. It will die if passed Unicode characters.</source>
          <target state="translated">C의 &quot;&quot;또는 ''에 적합하게 전달 된 문자열의 7 비트 ASCII를 올바르게 이스케이프 된 버전을 반환하는 함수입니다. 유니 코드 문자를 전달하면 죽습니다.</target>
        </trans-unit>
        <trans-unit id="c45b17fcb375003bf4d5bd87967dc1245beb7fd4" translate="yes" xml:space="preserve">
          <source>A function which returns a 7 bit ASCII correctly \ escaped version of the string passed suitable for a perl &quot;&quot; string.</source>
          <target state="translated">perl &quot;&quot;문자열에 적합하게 전달 된 문자열의 7 비트 ASCII를 올바르게 이스케이프 된 버전을 반환하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="5e16a22c3d8b0f460cffd4d274f2db99a8a3ae51" translate="yes" xml:space="preserve">
          <source>A fundamental feature of regular expression matching involves the notion called</source>
          <target state="translated">정규 표현식 일치의 기본 기능에는</target>
        </trans-unit>
        <trans-unit id="2100c9b6a5bc83c2e9c2b9fd7c9dc09b08c1aad2" translate="yes" xml:space="preserve">
          <source>A general function for editing the structure of an existing chain of op_sibling nodes. By analogy with the perl-level splice() function, allows you to delete zero or more sequential nodes, replacing them with zero or more different nodes. Performs the necessary op_first/op_last housekeeping on the parent node and op_sibling manipulation on the children. The last deleted node will be marked as as the last node by updating the op_sibling/op_sibparent or op_moresib field as appropriate.</source>
          <target state="translated">기존 op_sibling 노드 체인의 구조를 편집하는 일반적인 기능입니다. perl- 레벨 splice () 함수와 유사하게, 0 개 이상의 순차적 노드를 삭제하여 0 개 이상의 다른 노드로 대체 할 수 있습니다. 부모 노드에서 필요한 op_first / op_last 하우스 키핑과 자식에서 op_sibling 조작을 수행합니다. op_sibling / op_sibparent 또는 op_moresib 필드를 적절하게 업데이트하여 마지막으로 삭제 된 노드가 마지막 노드로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="16b0d3e317f9f7b5ddb72b16cb53e05b583e9133" translate="yes" xml:space="preserve">
          <source>A general solution to the serialization problem would require another level of registry, one that associates</source>
          <target state="translated">직렬화 문제에 대한 일반적인 솔루션에는 다른 수준의 레지스트리가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ed526677b5c541991128da9f35ea30909114035f" translate="yes" xml:space="preserve">
          <source>A generic &lt;b&gt;object&lt;/b&gt; type; that is, a &lt;b&gt;class&lt;/b&gt; from which other, more specific classes are derived genetically by &lt;b&gt;inheritance&lt;/b&gt;. Also called a &amp;ldquo;superclass&amp;rdquo; by people who respect their ancestors.</source>
          <target state="translated">일반 &lt;b&gt;객체&lt;/b&gt; 유형. 즉, A는 &lt;b&gt;클래스&lt;/b&gt; 보다 구체적인 다른 클래스로 유전자 유도되는 &lt;b&gt;상속&lt;/b&gt; . 조상을 존중하는 사람들에 의해&amp;ldquo;슈퍼 클래스&amp;rdquo;라고도합니다.</target>
        </trans-unit>
        <trans-unit id="0a9918e5dda4793cf3ecc366ce8266f117c17195" translate="yes" xml:space="preserve">
          <source>A generic file fetching mechanism</source>
          <target state="translated">일반 파일 가져 오기 메커니즘</target>
        </trans-unit>
        <trans-unit id="a625d1d6246943bf40d50608e758f2319151f17b" translate="yes" xml:space="preserve">
          <source>A generic input parsing/checking mechanism.</source>
          <target state="translated">일반적인 입력 파싱 / 확인 메커니즘.</target>
        </trans-unit>
        <trans-unit id="af15d07731a55a9ecedf87f6009285e2acc4ef80" translate="yes" xml:space="preserve">
          <source>A git GUI shell extension for Windows such as TortoiseGit will cause the build and later &lt;code&gt;make test&lt;/code&gt; to run much slower since every file is checked for its git status as soon as it is created and/or modified. TortoiseGit doesn't cause any test failures or build problems unlike the antivirus software described above, but it does cause similar slowness. It is suggested to use Task Manager to look for background processes which use high CPU amounts during the building process.</source>
          <target state="translated">TortoiseGit과 같은 Windows 용 git GUI 쉘 확장은 빌드 및 / 또는 나중에 모든 파일이 작성 및 / 또는 수정 되 자마자 git 상태를 점검하기 때문에 &lt;code&gt;make test&lt;/code&gt; 가 훨씬 느리게 실행되게합니다. TortoiseGit은 위에서 설명한 바이러스 백신 소프트웨어와 달리 테스트 실패를 일으키거나 문제를 일으키지 않지만 비슷한 속도 저하를 유발합니다. 작업 프로세스를 사용하여 구축 과정에서 많은 양의 CPU를 사용하는 백그라운드 프로세스를 찾는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ca6613321ff6c370136985bf48b668224b2f6734" translate="yes" xml:space="preserve">
          <source>A gizmo that transforms some number of input values to some number of output values, often built into a language with a special syntax or symbol. A given operator may have specific expectations about what &lt;b&gt;types&lt;/b&gt; of data you give as its arguments (&lt;b&gt;operands&lt;/b&gt;) and what type of data you want back from it.</source>
          <target state="translated">일부 입력 값을 일부 출력 값으로 변환하는 기즈모로, 종종 특수 구문 또는 기호가있는 언어로 작성됩니다. 주어진 연산자는 어떤 &lt;b&gt;유형&lt;/b&gt; 의 데이터를 인수 ( &lt;b&gt;피연산자&lt;/b&gt; )로 제공하고 어떤 유형의 데이터에서 다시 원하는지 에 대한 특정 기대치를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b0da5e61aa8557d6b28694e8c5217513361c3a66" translate="yes" xml:space="preserve">
          <source>A glossary of terms (technical and otherwise) used in the Perl documentation, derived from the Glossary of</source>
          <target state="translated">Perl 문서에 사용 된 용어 (기술 및 기타)의 용어집</target>
        </trans-unit>
        <trans-unit id="b29b7f7af6cfd5aa471dc4da158609e558212777" translate="yes" xml:space="preserve">
          <source>A glyph used in magic. Or, for Perl, the symbol in front of a variable name, such as &lt;code&gt;$&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; , and &lt;code&gt;%&lt;/code&gt; .</source>
          <target state="translated">마법에 사용되는 글리프. 또는 Perl의 경우 변수 이름 앞에있는 기호 (예 : &lt;code&gt;$&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; 및 &lt;code&gt;%&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="010767009a82e3c3f2315997ed16da6d8fa110ca" translate="yes" xml:space="preserve">
          <source>A good book on OO on Perl is the &quot;Object-Oriented Perl&quot; by Damian Conway from Manning Publications, or &quot;Intermediate Perl&quot; by Randal Schwartz, brian d foy, and Tom Phoenix from O'Reilly Media.</source>
          <target state="translated">OO에 관한 OO에 관한 좋은 책은 Manning Publications의 Damian Conway의 &quot;Object-Oriented Perl&quot;또는 Randal Schwartz의 &quot;Intermediate Perl&quot;, brian d foy, O'Reilly Media의 Tom Phoenix입니다.</target>
        </trans-unit>
        <trans-unit id="b82c3e9cadf17adecf1d24dc6cb64a89ca8103d6" translate="yes" xml:space="preserve">
          <source>A good place to start is &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;, and you can use &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; for reference.</source>
          <target state="translated">시작하기에 좋은 장소는 &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; 이며 &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; 를 사용 하여 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="878d4536576dbff5139c196eb475074b04b81dfd" translate="yes" xml:space="preserve">
          <source>A good test case has most of these attributes: short, simple code; few dependencies on external commands, modules, or libraries; no platform-dependent code (unless it's a platform-specific bug); clear, simple documentation.</source>
          <target state="translated">좋은 테스트 사례는 다음과 같은 특성을 대부분 가지고 있습니다. 짧고 간단한 코드; 외부 명령, 모듈 또는 라이브러리에 대한 종속성이 거의 없습니다. 플랫폼 별 버그가 아닌 경우 (플랫폼 별 버그가 아닌 한); 명확하고 간단한 문서.</target>
        </trans-unit>
        <trans-unit id="819fe6a0aff125bab30e82da5634d29a9188e255" translate="yes" xml:space="preserve">
          <source>A good test case is almost always a good candidate to be included in Perl's test suite. If you have the time, consider writing your test case so that it can be easily included into the standard test suite.</source>
          <target state="translated">좋은 테스트 사례는 거의 항상 Perl의 테스트 스위트에 포함될 수있는 좋은 후보입니다. 시간이 있다면 표준 테스트 스위트에 쉽게 포함될 수 있도록 테스트 케이스 작성을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="6800c5039fcfc25d3805f20efcfc998a8922a07e" translate="yes" xml:space="preserve">
          <source>A grab bag of methods to generate specific macros and commands.</source>
          <target state="translated">특정 매크로 및 명령을 생성하는 다양한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="52f74d52da3fd8ec9d4b9513d833d3c381a80abc" translate="yes" xml:space="preserve">
          <source>A grammar for the Test Anything Protocol.</source>
          <target state="translated">Test Anything Protocol에 대한 문법.</target>
        </trans-unit>
        <trans-unit id="4068f0366f48575a0048eca3205a24ad39495e7b" translate="yes" xml:space="preserve">
          <source>A grammar form might be something like this:</source>
          <target state="translated">문법 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="19193405de37cb91769fc940baebbd6ae904906a" translate="yes" xml:space="preserve">
          <source>A graphene is an allotrope of carbon arranged in a hexagonal crystal lattice one atom thick. A &lt;b&gt;grapheme&lt;/b&gt;, or more fully, a</source>
          <target state="translated">그래 핀은 한 원자 두께의 육각형 결정 격자로 배열 된 탄소의 동소체이다. &lt;b&gt;그래 핀&lt;/b&gt; , 또는 좀 더 완벽하게하는</target>
        </trans-unit>
        <trans-unit id="07663ed8c039244f1bbba8bbd0f2248a550eeeb7" translate="yes" xml:space="preserve">
          <source>A graphical representation of complex numbers is possible in a plane (also called the</source>
          <target state="translated">복소수의 그래픽 표현은 평면에서 가능합니다.</target>
        </trans-unit>
        <trans-unit id="b2a17fedc722e35cf530893f218ec96ab466a1ef" translate="yes" xml:space="preserve">
          <source>A great circle is section of a circle that contains the circle diameter: the shortest distance between two (non-antipodal) points on the spherical surface goes along the great circle connecting those two points.</source>
          <target state="translated">큰 원은 원의 지름을 포함하는 원의 단면입니다. 구면의 두 (비대 동물) 점 사이의 최단 거리는이 두 점을 연결하는 큰 원을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="cf830d0f970841c8b5873e5f5dc448f292f1330c" translate="yes" xml:space="preserve">
          <source>A group of related modules on &lt;b&gt;CPAN&lt;/b&gt;. (Also sometimes refers to a group of command-line switches grouped into one &lt;b&gt;switch cluster&lt;/b&gt;.)</source>
          <target state="translated">&lt;b&gt;CPAN&lt;/b&gt; 의 관련 모듈 그룹 . 또한 때때로 하나의 &lt;b&gt;스위치 클러스터&lt;/b&gt; 로 그룹화 된 명령 줄 스위치 그룹을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="d92a635a2c1e502bba680458b972125c4a0be466" translate="yes" xml:space="preserve">
          <source>A group that is required to bundle a set of alternatives may or may not be useful as a capturing group. If it isn't, it just creates a superfluous addition to the set of available capture group values, inside as well as outside the regexp. Non-capturing groupings, denoted by &lt;code&gt;(?:regexp)&lt;/code&gt;, still allow the regexp to be treated as a single unit, but don't establish a capturing group at the same time. Both capturing and non-capturing groupings are allowed to co-exist in the same regexp. Because there is no extraction, non-capturing groupings are faster than capturing groupings. Non-capturing groupings are also handy for choosing exactly which parts of a regexp are to be extracted to matching variables:</source>
          <target state="translated">대안 세트를 묶어야하는 그룹은 캡처 그룹으로서 유용하거나 유용하지 않을 수 있습니다. 그렇지 않은 경우 정규 표현식 내부 및 외부에서 사용 가능한 캡처 그룹 값 세트에 불필요한 추가를 생성합니다. &lt;code&gt;(?:regexp)&lt;/code&gt; 로 표시되는 비 캡처 그룹화 는 정규 표현식을 단일 단위로 처리 할 수 ​​있지만 동시에 캡처 그룹을 설정하지는 않습니다. 캡처 및 비 캡처 그룹화는 동일한 정규식에서 공존 할 수 있습니다. 추출이 없기 때문에 비 캡처 그룹화는 그룹화 캡처보다 빠릅니다. 캡처하지 않은 그룹화는 정규 표현식에서 일치하는 변수로 추출 할 부분을 정확하게 선택하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e98254b9797c79a405fb849ceb15e69b1be1e9de" translate="yes" xml:space="preserve">
          <source>A handful of characters have a dedicated</source>
          <target state="translated">소수의 캐릭터는 전용</target>
        </trans-unit>
        <trans-unit id="f93caa5208bfa6818a90d520fb7ad0e15665c128" translate="yes" xml:space="preserve">
          <source>A handler for an attributes with an all-lowercase name was declared. An attribute with an all-lowercase name might have a meaning to Perl itself some day, even though most don't yet. Use a mixed-case attribute name, instead.</source>
          <target state="translated">모두 소문자 이름을 가진 속성에 대한 핸들러가 선언되었습니다. 이름이 모두 소문자 인 속성은 언젠가 Perl 자체에 의미가있을 수 있습니다. 대신 대소 문자 속성 이름을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c3e6d55f9badd1667902eb5523efa20bcbd3e70c" translate="yes" xml:space="preserve">
          <source>A handler for attributes of the specified name</source>
          <target state="translated">지정된 이름의 속성에 대한 핸들러</target>
        </trans-unit>
        <trans-unit id="49edbe08e4bfabb8ba065c602451240e8c0f2a33" translate="yes" xml:space="preserve">
          <source>A handy tag name for a</source>
          <target state="translated">편리한 태그 이름</target>
        </trans-unit>
        <trans-unit id="3aa757aa90e3b991f02cc566dd247ec484d84771" translate="yes" xml:space="preserve">
          <source>A hash &lt;code&gt;%DB::sub&lt;/code&gt; is maintained, whose keys are subroutine names and whose values have the form &lt;code&gt;filename:startline-endline&lt;/code&gt; . &lt;code&gt;filename&lt;/code&gt; has the form &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; for subroutines defined inside &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">키가 서브 루틴 이름이고 값이 &lt;code&gt;filename:startline-endline&lt;/code&gt; 형식 인 해시 &lt;code&gt;%DB::sub&lt;/code&gt; 가 유지 됩니다. &lt;code&gt;filename&lt;/code&gt; 형태 갖는다 &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; &lt;a href=&quot;functions/eval&quot;&gt;평가&lt;/a&gt; 34) 내에 정의 된 서브 루틴 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 들.</target>
        </trans-unit>
        <trans-unit id="44b55c7f5cfe4830cdb1fa796511bc1073b11348" translate="yes" xml:space="preserve">
          <source>A hash can be initialized using a literal list holding pairs of items to be interpreted as a key and a value:</source>
          <target state="translated">키와 값으로 해석 될 항목 쌍을 보유한 리터럴 목록을 사용하여 해시를 초기화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a814541e8cdf1052da6ce7b4056b3b5847f1f69" translate="yes" xml:space="preserve">
          <source>A hash is an ideal mechanism to store the mapping between C and Perl.</source>
          <target state="translated">해시는 C와 Perl 간의 매핑을 저장하는 이상적인 메커니즘입니다.</target>
        </trans-unit>
        <trans-unit id="70381f72f3a7fd8e9863739e409cd4fabcba3c1e" translate="yes" xml:space="preserve">
          <source>A hash of array references in list context. Each entry of the hash has the fully qualified method name as its key and a reference to an array containing the method's list-context return values as its value.</source>
          <target state="translated">리스트 문맥에서의 배열 참조의 해시 해시의 각 항목에는 키로 정규화 된 메소드 이름과 메소드의 목록 컨텍스트 리턴 값을 값으로 포함하는 배열에 대한 참조가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ea60218a99582e9bc2b801ff2d5e8c50e9c5afa" translate="yes" xml:space="preserve">
          <source>A hash of hashes keyed on perl version and on module name. If a module is defined it indicates that that module is deprecated in that perl version and is scheduled for removal from core at some future point.</source>
          <target state="translated">펄 버전과 모듈 이름을 기준으로 해시 해시. 모듈이 정의 된 경우 해당 perl 버전에서 해당 모듈이 더 이상 사용되지 않으며 향후 코어에서 코어에서 제거 될 예정임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3ce60ae7ced566f5220eb260ad49e428425ac3a8" translate="yes" xml:space="preserve">
          <source>A hash of hashes that is keyed on perl version as indicated in $]. The second level hash is module =&amp;gt; version pairs.</source>
          <target state="translated">$]에 표시된대로 펄 버전에서 키를 생성하는 해시 해시. 두 번째 수준의 해시는 모듈 =&amp;gt; 버전 쌍입니다.</target>
        </trans-unit>
        <trans-unit id="5c605211961bb9e43df625e92f911448dae2ef07" translate="yes" xml:space="preserve">
          <source>A hash of modules that are needed to build your module but not run it.</source>
          <target state="translated">모듈을 빌드하지만 실행하지는 않는 모듈 해시.</target>
        </trans-unit>
        <trans-unit id="e6392db0e8aa8a4e0a54f37942aac32926d2e82c" translate="yes" xml:space="preserve">
          <source>A hash of modules that are needed to run your module. The keys are the module names ie. Test::More, and the minimum version is the value. If the required version number is 0 any version will do.</source>
          <target state="translated">모듈을 실행하는 데 필요한 모듈 해시. 키는 모듈 이름입니다. Test :: More 및 최소 버전이 값입니다. 필요한 버전 번호가 0이면 모든 버전이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="922e915de9e8740eca506cd44d1ed8c10a9b1671" translate="yes" xml:space="preserve">
          <source>A hash of modules that are needed to test your module but not run or build it.</source>
          <target state="translated">모듈을 테스트하지만 실행하거나 빌드하지 않는 데 필요한 모듈 해시.</target>
        </trans-unit>
        <trans-unit id="cd4d1c09ebac99b02cf9a7c9fa8cd90d4f94f599" translate="yes" xml:space="preserve">
          <source>A hash of modules that are required to run Makefile.PL itself, but not to run your distribution.</source>
          <target state="translated">Makefile.PL 자체를 실행하는 데 필요하지만 배포를 실행하지 않는 모듈의 해시.</target>
        </trans-unit>
        <trans-unit id="f704787fb624926417400f97106f18daa25dcf15" translate="yes" xml:space="preserve">
          <source>A hash of the POSIX realtime signal handlers. It is an extension of the standard &lt;code&gt;%SIG&lt;/code&gt; , the &lt;code&gt;$POSIX::SIGRT{SIGRTMIN}&lt;/code&gt; is roughly equivalent to &lt;code&gt;$SIG{SIGRTMIN}&lt;/code&gt; , but the right POSIX moves (see below) are made with the &lt;code&gt;POSIX::SigSet&lt;/code&gt; and &lt;code&gt;POSIX::sigaction&lt;/code&gt; instead of accessing the &lt;code&gt;%SIG&lt;/code&gt; .</source>
          <target state="translated">POSIX 실시간 신호 처리기의 해시. 이 표준의 확장 &lt;code&gt;%SIG&lt;/code&gt; 는 &lt;code&gt;$POSIX::SIGRT{SIGRTMIN}&lt;/code&gt; 거의 비슷하다 &lt;code&gt;$SIG{SIGRTMIN}&lt;/code&gt; 있지만, 올바른 POSIX 이동은 (아래 참조)로 만들어집니다 &lt;code&gt;POSIX::SigSet&lt;/code&gt; 및 &lt;code&gt;POSIX::sigaction&lt;/code&gt; 대신 액세스 &lt;code&gt;%SIG&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60ab26088a220041ec5c97911d9e6f565f5cbd7a" translate="yes" xml:space="preserve">
          <source>A hash or array element can be true only if it's defined and defined only if it exists, but the reverse doesn't necessarily hold true.</source>
          <target state="translated">해시 또는 배열 요소는 존재하는 경우에만 정의되고 정의 된 경우에만 true 일 수 있지만 그 반대의 경우도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="0bf79c7c035d7be8a20888854f2234466da28ff7" translate="yes" xml:space="preserve">
          <source>A hash reference containing various parsing options (see below)</source>
          <target state="translated">다양한 파싱 옵션을 포함하는 해시 참조 (아래 참조)</target>
        </trans-unit>
        <trans-unit id="71468d46c3d10b4d4aab17a5abca352e48601869" translate="yes" xml:space="preserve">
          <source>A hash represents a set of key/value pairs:</source>
          <target state="translated">해시는 일련의 키 / 값 쌍을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="10f78a1f223b35e25505609f4916f6f91875834d" translate="yes" xml:space="preserve">
          <source>A hash that contains information on the appropriate bug tracker for each core module.</source>
          <target state="translated">각 코어 모듈에 대한 적절한 버그 추적기에 대한 정보가 포함 된 해시.</target>
        </trans-unit>
        <trans-unit id="567327a8b7280b6715ced030a81d31782682314b" translate="yes" xml:space="preserve">
          <source>A hash that contains information on where patches should be directed for each core module.</source>
          <target state="translated">각 코어 모듈에 대한 패치를 지시해야하는 위치에 대한 정보가 포함 된 해시.</target>
        </trans-unit>
        <trans-unit id="9f6e2604d963e87b1664555e25f241bb06bae1e9" translate="yes" xml:space="preserve">
          <source>A hash that maps from each Pod filespec to its pod-name (like &quot;/whatever/plib/Stuff/Thing.pm&quot; =&amp;gt; &quot;Stuff::Thing&quot;)</source>
          <target state="translated">각 포드 파일 사양에서 해당 포드 이름으로 매핑되는 해시 (예 : &quot;/whatever/plib/Stuff/Thing.pm&quot;=&amp;gt; &quot;Stuff :: Thing&quot;)</target>
        </trans-unit>
        <trans-unit id="215fe982a4e5c65f0b82e82b7b97c0bfc5c0deef" translate="yes" xml:space="preserve">
          <source>A hash that maps from each pod-name to the filespec (like &quot;Stuff::Thing&quot; =&amp;gt; &quot;/whatever/plib/Stuff/Thing.pm&quot;)</source>
          <target state="translated">각 포드 이름에서 파일 사양으로 매핑되는 해시 (예 : &quot;Stuff :: Thing&quot;=&amp;gt; &quot;/whatever/plib/Stuff/Thing.pm&quot;)</target>
        </trans-unit>
        <trans-unit id="bb3108415359d307ae0dd29af4dd93824067960c" translate="yes" xml:space="preserve">
          <source>A hashref of items to add to the CPAN Meta file (</source>
          <target state="translated">CPAN 메타 파일에 추가 할 항목의 해시 참조 (</target>
        </trans-unit>
        <trans-unit id="039b44468fab1aa4f939b768b655c31c005e5690" translate="yes" xml:space="preserve">
          <source>A hashref with one or more of the keys &lt;code&gt;distribution&lt;/code&gt; , &lt;code&gt;module&lt;/code&gt; , &lt;code&gt;perl&lt;/code&gt; , &lt;code&gt;perlconfig&lt;/code&gt; , and &lt;code&gt;env&lt;/code&gt; that specify whether a document is targeted at a specific CPAN distribution or installation. Keys prefixed with &lt;code&gt;not_&lt;/code&gt; negates the corresponding match.</source>
          <target state="translated">문서가 특정 CPAN 배포 또는 설치를 대상으로하는지 여부를 지정하는 하나 이상의 키 &lt;code&gt;distribution&lt;/code&gt; , &lt;code&gt;module&lt;/code&gt; , &lt;code&gt;perl&lt;/code&gt; , &lt;code&gt;perlconfig&lt;/code&gt; 및 &lt;code&gt;env&lt;/code&gt; 가있는 해시 참조 . &lt;code&gt;not_&lt;/code&gt; 접두사가 붙은 키 는 해당 일치를 무효화합니다.</target>
        </trans-unit>
        <trans-unit id="8c60ca8fe75e29a9dfda50be5b6bb79ab9c86c02" translate="yes" xml:space="preserve">
          <source>A heading (&lt;code&gt;=head1&lt;/code&gt; or &lt;code&gt;=head2&lt;/code&gt; ) without any text? That ain't no heading!</source>
          <target state="translated">텍스트가없는 제목 ( &lt;code&gt;=head1&lt;/code&gt; 또는 &lt;code&gt;=head2&lt;/code&gt; )? 그것은 제목이 아닙니다!</target>
        </trans-unit>
        <trans-unit id="f9832f7772423825e7be09c103f042abd3956ccc" translate="yes" xml:space="preserve">
          <source>A hex dump of &lt;code&gt;$berbuf&lt;/code&gt; , with spaces inserted at the right places, shows 01 8100 8101 81807F. Since the last byte is always less than 128, &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; knows where to stop.</source>
          <target state="translated">올바른 위치에 공백이 삽입 된 &lt;code&gt;$berbuf&lt;/code&gt; 의 16 진 덤프 는 01 8100 8101 81807F를 보여줍니다. 마지막 바이트는 항상 128보다 작으므로 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 은 중지 할 위치를 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="38e7070b1f249f379f9a778af2f10d3b11497505" translate="yes" xml:space="preserve">
          <source>A hierarchy of &quot;categories&quot; have been defined to allow groups of warnings to be enabled/disabled in isolation.</source>
          <target state="translated">&quot;범주&quot;계층이 정의되어 경고 그룹을 개별적으로 활성화 / 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="536684f67238bfdb66acbda52de51ea79291a12f" translate="yes" xml:space="preserve">
          <source>A is the root class, B is a subclass of A, C is a subclass of B, and D is another subclass of A.</source>
          <target state="translated">A는 루트 클래스이고 B는 A의 서브 클래스, C는 B의 서브 클래스, D는 A의 다른 서브 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="8f3e40034aa0308d28f4dfc54288a8825f6cfd1e" translate="yes" xml:space="preserve">
          <source>A kind of &lt;b&gt;overloading&lt;/b&gt; that you can do on built-in &lt;b&gt;operators&lt;/b&gt; to make them work on &lt;b&gt;objects&lt;/b&gt; as if the objects were ordinary scalar values, but with the actual semantics supplied by the object class. This is set up with the overload &lt;b&gt;pragma&lt;/b&gt;&amp;mdash;see Camel chapter 13, &amp;ldquo;Overloading&amp;rdquo;.</source>
          <target state="translated">의 종류 &lt;b&gt;과부하&lt;/b&gt; 당신이 내장에 할 수있는 &lt;b&gt;사업자하기&lt;/b&gt; 에 그들을 작동하도록 &lt;b&gt;객체를&lt;/b&gt; 객체가 있지만, 객체 클래스에서 제공하는 실제 의미와, 일반 스칼라 값 인 것처럼. 이것은 과부하 &lt;b&gt;pragma&lt;/b&gt; 와 함께 설정됩니다. Camel 13 장, &quot;오버로딩&quot;을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e9cfe5685ea0ecd4847a06232a077cb874b35be7" translate="yes" xml:space="preserve">
          <source>A kind of action that an &lt;b&gt;object&lt;/b&gt; can take if you tell it to. See Camel chapter 12, &amp;ldquo;Objects&amp;rdquo;.</source>
          <target state="translated">당신이 말하면 &lt;b&gt;객체&lt;/b&gt; 가 취할 수 있는 행동 . 낙타 12 장 &quot;객체&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="dfe222b0c92a8225eafa0e0da38f08258e2a6e75" translate="yes" xml:space="preserve">
          <source>A kind of key or name attached to a loop (or roller coaster) so that loop control statements can talk about which loop they want to control.</source>
          <target state="translated">루프 제어문이 제어하려는 루프에 대해 이야기 할 수 있도록 루프 (또는 롤러 코스터)에 부착 된 일종의 키 또는 이름입니다.</target>
        </trans-unit>
        <trans-unit id="e7d72d06babc67750c6b28a2b28bed949fa33a88" translate="yes" xml:space="preserve">
          <source>A kinder, gentler tutorial on object-oriented programming in Perl can be found in &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;. You should also check out &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; for some style guides on constructing both modules and classes.</source>
          <target state="translated">Perl의 객체 지향 프로그래밍에 대한 더 친절하고 부드러운 튜토리얼은 &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; 에서 찾을 수 있습니다 . 또한 모듈과 클래스를 구성하는 데 대한 일부 스타일 안내서는 &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; 를 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b68c5f288b44308b58cb523d3e60b493b484f9c4" translate="yes" xml:space="preserve">
          <source>A language beloved by many for its inside-out &lt;b&gt;type&lt;/b&gt; definitions, inscrutable &lt;b&gt;precedence&lt;/b&gt; rules, and heavy &lt;b&gt;overloading&lt;/b&gt; of the function-call mechanism. (Well, actually, people first switched to C because they found lowercase identifiers easier to read than upper.) Perl is written in C, so it&amp;rsquo;s not surprising that Perl borrowed a few ideas from it.</source>
          <target state="translated">많은 사람들이 내부 &lt;b&gt;형식&lt;/b&gt; 정의, 불가피한 &lt;b&gt;우선 순위&lt;/b&gt; 규칙 및 함수 호출 메커니즘의 &lt;b&gt;과부하&lt;/b&gt; 로 인해 사랑받는 언어 입니다. (실제로 사람들은 대문자보다 소문자 식별자를 읽기 쉽기 때문에 먼저 C로 전환했습니다.) Perl은 C로 작성되었으므로 Perl이 몇 가지 아이디어를 빌린 것은 놀라운 일이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7a70c2d1db9e3781c948c3f568d555da43db83b2" translate="yes" xml:space="preserve">
          <source>A language class is a class containing a lexicon of phrases as class data, and possibly also some methods that are of use in interpreting phrases in the lexicon, or otherwise dealing with text in that language.</source>
          <target state="translated">언어 클래스는 구문 데이터를 클래스 데이터로 포함하는 클래스이며 어휘의 구문을 해석하거나 해당 언어의 텍스트를 처리하는 데 사용되는 일부 메소드 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c64c47113f6df7e33ad198a5fed1bb8f3af6d13f" translate="yes" xml:space="preserve">
          <source>A language handle is a flyweight object -- i.e., it doesn't (necessarily) carry any data of interest, other than just being a member of whatever class it belongs to.</source>
          <target state="translated">언어 핸들은 플라이급 객체입니다. 즉, 클래스가 속한 클래스의 멤버가 아닌 관심있는 데이터를 (필요하게) 가지고 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c3a083f1f9c38b9c0d77465662a942c4c5d48d8d" translate="yes" xml:space="preserve">
          <source>A language handle is implemented as a blessed hash. Subclasses of yours can store whatever data you want in the hash. Currently the only hash entry used by any crucial Maketext method is &quot;fail&quot;, so feel free to use anything else as you like.</source>
          <target state="translated">언어 핸들은 축복 된 해시로 구현됩니다. 서브 클래스는 원하는 데이터를 해시에 저장할 수 있습니다. 현재 중요한 Maketext 메서드에서 사용하는 유일한 해시 항목은 &quot;실패&quot;이므로 원하는대로 자유롭게 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9fb1cb589c473c75eb212d9b744da125c770bad8" translate="yes" xml:space="preserve">
          <source>A language such as Perl that is good at hooking things together that weren&amp;rsquo;t intended to be hooked together.</source>
          <target state="translated">서로 연결되어 있지 않은 것을 연결하는 데 유용한 Perl과 같은 언어입니다.</target>
        </trans-unit>
        <trans-unit id="7ea3dfebe2530a429cde54a5f0bc78f862792455" translate="yes" xml:space="preserve">
          <source>A large scalar that you know can only contain ASCII</source>
          <target state="translated">아는 큰 스칼라에는 ASCII 만 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8078fbdb7cd614c0fbe18240c94f727ccdf4ed5e" translate="yes" xml:space="preserve">
          <source>A layer can be added that does &quot;\n&quot; to CRLF translation. This layer can be used on any platform, not just those that normally do such things.</source>
          <target state="translated">CRLF 변환에서 &quot;\ n&quot;을 수행하는 레이어를 추가 할 수 있습니다. 이 계층은 일반적으로 이러한 작업을 수행하는 플랫폼뿐만 아니라 모든 플랫폼에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c418f05188c75b7cf5ccc4221979555d292c85f1" translate="yes" xml:space="preserve">
          <source>A layer contains a &quot;vtable&quot;, the table of I/O operations (at C level a table of function pointers), and status flags. The functions in the vtable implement operations like &quot;open&quot;, &quot;read&quot;, and &quot;write&quot;.</source>
          <target state="translated">계층에는 &quot;vtable&quot;, I / O 작업 테이블 (C 수준에서 함수 포인터 테이블) 및 상태 플래그가 포함됩니다. vtable의 함수는 &quot;open&quot;, &quot;read&quot;및 &quot;write&quot;와 같은 작업을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="4f0330995dfa2fce16816cd443c9581a48699cf3" translate="yes" xml:space="preserve">
          <source>A layer derived using &quot;perlio&quot; as a base class. It provides Win32-like &quot;\n&quot; to CR,LF translation. Can either be applied above &quot;perlio&quot; or serve as the buffer layer itself. &quot;crlf&quot; over &quot;unix&quot; is the default if system distinguishes between &lt;code&gt;O_TEXT&lt;/code&gt; and &lt;code&gt;O_BINARY&lt;/code&gt; opens. (At some point &quot;unix&quot; will be replaced by a &quot;native&quot; Win32 IO layer on that platform, as Win32's read/write layer has various drawbacks.) The &quot;crlf&quot; layer is a reasonable model for a layer which transforms data in some way.</source>
          <target state="translated">&quot;perlio&quot;를 기본 클래스로 사용하여 파생 된 레이어입니다. CR, LF 로의 Win32와 유사한 &quot;\ n&quot;을 제공합니다. &quot;perlio&quot;위에 적용하거나 버퍼 계층 자체로 사용할 수 있습니다. 시스템이 &lt;code&gt;O_TEXT&lt;/code&gt; 와 &lt;code&gt;O_BINARY&lt;/code&gt; 를 구별 할 경우 &quot;unix&quot;보다 &quot;crlf&quot;가 기본값이됩니다 . (Win32의 읽기 / 쓰기 레이어에는 여러 가지 단점이 있기 때문에 &quot;유닉스&quot;는 플랫폼에서 &quot;네이티브&quot;Win32 IO 레이어로 대체 될 것입니다.) &quot;crlf&quot;레이어는 일부 데이터를 변환하는 레이어에 대한 합리적인 모델입니다. 방법.</target>
        </trans-unit>
        <trans-unit id="c575f3b4bff37dcf26ab538523523b73298b17f9" translate="yes" xml:space="preserve">
          <source>A layer does not have to implement all the functions, but the whole table has to be present. Unimplemented slots can be NULL (which will result in an error when called) or can be filled in with stubs to &quot;inherit&quot; behaviour from a &quot;base class&quot;. This &quot;inheritance&quot; is fixed for all instances of the layer, but as the layer chooses which stubs to populate the table, limited &quot;multiple inheritance&quot; is possible.</source>
          <target state="translated">레이어가 모든 기능을 구현할 필요는 없지만 전체 테이블이 있어야합니다. 구현되지 않은 슬롯은 NULL (호출시 오류 발생)이거나 &quot;기본 클래스&quot;에서 &quot;상속&quot;동작을위한 스텁으로 채워질 수 있습니다. 이 &quot;상속&quot;은 계층의 모든 인스턴스에 대해 고정되어 있지만 계층이 테이블을 채울 스텁을 선택함에 따라 제한된 &quot;다중 상속&quot;이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="7f64a4152a5af0c9ac4baa66afb914d700fb3ea6" translate="yes" xml:space="preserve">
          <source>A layer that implements &quot;reading&quot; of files by using</source>
          <target state="translated">다음을 사용하여 파일의 &quot;읽기&quot;를 구현하는 계층</target>
        </trans-unit>
        <trans-unit id="29bee167ef354a3d46f2326d367f6d5e9ab52d50" translate="yes" xml:space="preserve">
          <source>A layer that implements DOS/Windows like CRLF line endings. On read converts pairs of CR,LF to a single &quot;\n&quot; newline character. On write converts each &quot;\n&quot; to a CR,LF pair. Note that this layer will silently refuse to be pushed on top of itself.</source>
          <target state="translated">CRLF 줄 끝과 같은 DOS / Windows를 구현하는 계층입니다. 읽기시 CR, LF 쌍을 단일 &quot;\ n&quot;줄 바꿈 문자로 변환합니다. 쓰기시 각 &quot;\ n&quot;을 CR, LF 쌍으로 변환합니다. 이 레이어는 자동으로 푸시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a9b39500363434cc0ff0f52b520ce130f3b3a554" translate="yes" xml:space="preserve">
          <source>A layer which does CRLF to &lt;code&gt;&quot;\n&quot;&lt;/code&gt; translation distinguishing &quot;text&quot; and &quot;binary&quot; files in the manner of MS-DOS and similar operating systems. (It currently does</source>
          <target state="translated">MS-DOS 및 유사한 운영 체제의 방식으로 &quot;텍스트&quot;및 &quot;이진&quot;파일을 구별 하는 CRLF를 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 변환 하는 계층입니다 . (현재는</target>
        </trans-unit>
        <trans-unit id="d99ca2d73d6bc9954c1f5d38358ae63b3448d053" translate="yes" xml:space="preserve">
          <source>A layer which implements &quot;reading&quot; of files by using &lt;code&gt;mmap()&lt;/code&gt; to make a (whole) file appear in the process's address space, and then using that as PerlIO's &quot;buffer&quot;. This</source>
          <target state="translated">&lt;code&gt;mmap()&lt;/code&gt; 을 사용하여 (전체) 파일을 프로세스의 주소 공간에 표시 한 다음이를 PerlIO의 &quot;버퍼&quot; 로 사용하여 파일의 &quot;읽기&quot;를 구현하는 계층입니다 . 이</target>
        </trans-unit>
        <trans-unit id="fd687d324576d9173f6d5752bc85ac325e3d235f" translate="yes" xml:space="preserve">
          <source>A layer which provides the PerlIO API via the layer scheme, but implements it by calling system's stdio. This is (currently) the default if system's stdio provides sufficient access to allow perl's &quot;fast gets&quot; access and which do not distinguish between &lt;code&gt;O_TEXT&lt;/code&gt; and &lt;code&gt;O_BINARY&lt;/code&gt; .</source>
          <target state="translated">계층 체계를 통해 PerlIO API를 제공하지만 시스템의 stdio를 호출하여 구현하는 계층입니다. 시스템의 stdio가 perl의 &quot;빠른 가져 &lt;code&gt;O_TEXT&lt;/code&gt; &quot;액세스를 허용하기에 충분한 액세스를 제공하고 O_TEXT 와 &lt;code&gt;O_BINARY&lt;/code&gt; 를 구분하지 않는 경우 이는 현재의 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="1841e889a880ebb77b0a2697210c6744f8df031b" translate="yes" xml:space="preserve">
          <source>A leading ! indicates that matching names should be deleted from the list of names to import. If the first specification is a deletion it is treated as though preceded by :DEFAULT. If you just want to import extra names in addition to the default set you will still need to include :DEFAULT explicitly.</source>
          <target state="translated">최고의! 가져올 이름 목록에서 일치하는 이름을 삭제해야 함을 나타냅니다. 첫 번째 스펙이 삭제 인 경우 앞에 : DEFAULT가있는 것처럼 처리됩니다. 기본 설정 외에 추가 이름을 가져 오려면 여전히 명시 적으로 : DEFAULT를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="f747bcc2647296135613b88a3e62cca47b6c1dc6" translate="yes" xml:space="preserve">
          <source>A leading colon removes the &quot;name=&quot; part of the response, this allows you to map to the name you need. (mnemonic: empty label)</source>
          <target state="translated">선행 콜론은 응답의 &quot;name =&quot;부분을 제거하므로 필요한 이름으로 매핑 할 수 있습니다. (니모닉 : 빈 라벨)</target>
        </trans-unit>
        <trans-unit id="96fa00367bcfdb4784c34a4a3babbe9475afc22d" translate="yes" xml:space="preserve">
          <source>A legally formed name for most anything in which a computer program might be interested. Many languages (including Perl) allow identifiers to start with an alphabetic character, and then contain alphabetics and digits. Perl also allows connector punctuation like the underscore character wherever it allows alphabetics. (Perl also has more complicated names, like &lt;b&gt;qualified&lt;/b&gt; names.)</source>
          <target state="translated">컴퓨터 프로그램이 관심을 가질만한 모든 것을 합법적으로 정립 한 이름입니다. Perl을 포함한 많은 언어는 식별자가 알파벳 문자로 시작한 다음 알파벳과 숫자를 포함 할 수 있습니다. 펄은 알파벳 문자를 허용하는 곳이라면 밑줄 문자와 같은 커넥터 구두점을 허용합니다. (Perl에는 &lt;b&gt;규정 된&lt;/b&gt; 이름 과 같이 더 복잡한 이름도 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="69d4d84a09fc968a07bdda5a53812534fa74783b" translate="yes" xml:space="preserve">
          <source>A library only needs to deal with unsigned big integers. Testing of input parameter validity is done by the caller, so there is no need to worry about underflow (e.g., in &lt;code&gt;_sub()&lt;/code&gt; and &lt;code&gt;_dec()&lt;/code&gt; ) nor about division by zero (e.g., in &lt;code&gt;_div()&lt;/code&gt; ) or similar cases.</source>
          <target state="translated">라이브러리는 부호없는 큰 정수만 처리하면됩니다. 입력 매개 변수 유효성 테스트는 호출자가 수행하므로 언더 플로 (예 : &lt;code&gt;_sub()&lt;/code&gt; 및 &lt;code&gt;_dec()&lt;/code&gt; ) 나 0으로 나누기 (예 : &lt;code&gt;_div()&lt;/code&gt; ) 또는 이와 유사한 경우에 대해 걱정할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0b89fa4e541f30b4e921956619e05676831d4d1c" translate="yes" xml:space="preserve">
          <source>A line number may be prefixed by a single letter:</source>
          <target state="translated">줄 번호 앞에는 단일 문자가 붙을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d89336c3df3636aebec0ee20d5e9be98d7da075" translate="yes" xml:space="preserve">
          <source>A line-oriented form of quoting is based on the shell &quot;here-document&quot; syntax. Following a &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; you specify a string to terminate the quoted material, and all lines following the current line down to the terminating string are the value of the item.</source>
          <target state="translated">따옴표로 묶인 행 형식은 &quot;here-document&quot;쉘 구문을 기반으로합니다. &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 다음에 인용 된 재료를 종료 할 문자열을 지정하고 현재 줄 다음에 끝나는 문자열까지의 모든 줄은 항목의 값입니다.</target>
        </trans-unit>
        <trans-unit id="75e8b52d2267761231a600214a302dc93a9097e4" translate="yes" xml:space="preserve">
          <source>A list introduced by &lt;code&gt;=over&lt;/code&gt; starts with a text or verbatim paragraph, but continues with &lt;code&gt;=item&lt;/code&gt; s. Move the non-item paragraph out of the &lt;code&gt;=over&lt;/code&gt; /&lt;code&gt;=back&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;=over&lt;/code&gt; 에 의해 도입 된리스트 는 텍스트 또는 축약 단락으로 시작하지만 &lt;code&gt;=item&lt;/code&gt; 으로 계속됩니다 . 항목이 아닌 단락을 &lt;code&gt;=over&lt;/code&gt; / &lt;code&gt;=back&lt;/code&gt; 블록 밖으로 이동하십시오 .</target>
        </trans-unit>
        <trans-unit id="9aee76ae2469acd57d2557387480876b03411474" translate="yes" xml:space="preserve">
          <source>A list is a fixed collection of scalars. An array is a variable that holds a variable collection of scalars. An array can supply its collection for list operations, so list operations also work on arrays:</source>
          <target state="translated">리스트는 고정 된 스칼라 모음입니다. 배열은 스칼라의 변수 콜렉션을 보유하는 변수입니다. 배열은 목록 작업에 대한 컬렉션을 제공 할 수 있으므로 목록 작업은 배열에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b201394353dbcc6ef2561ba6cd863dea90b88222" translate="yes" xml:space="preserve">
          <source>A list of additional libraries or other shared objects which can be used to resolve any undefined symbols that might be generated by a later call to load_file().</source>
          <target state="translated">나중에 load_file ()을 호출하여 생성 될 수있는 정의되지 않은 기호를 확인하는 데 사용할 수있는 추가 라이브러리 또는 기타 공유 객체의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="e216fd26bc604e567680be656aeb4002407fb587" translate="yes" xml:space="preserve">
          <source>A list of all the INSTALL* variables without the INSTALL prefix. Useful for iteration or building related variable sets.</source>
          <target state="translated">INSTALL 접두어가없는 모든 INSTALL * 변수 목록 반복 또는 빌드 관련 변수 세트에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="94957d0f7514017339244da4cc1607583b5fc84e" translate="yes" xml:space="preserve">
          <source>A list of directories in which to look for Perl library files before looking in the standard library and the current directory. Any architecture-specific and version-specific directories, such as</source>
          <target state="translated">표준 라이브러리와 현재 디렉토리를 찾기 전에 Perl 라이브러리 파일을 찾을 디렉토리 목록. 다음과 같은 아키텍처 별 및 버전 별 디렉토리</target>
        </trans-unit>
        <trans-unit id="7103902d7143d091cfd2b7d907958a451f56b4e9" translate="yes" xml:space="preserve">
          <source>A list of directories in which to look for Perl library files before looking in the standard library and the current directory. If PERL5LIB is defined, PERLLIB is not used.</source>
          <target state="translated">표준 라이브러리와 현재 디렉토리를 찾기 전에 Perl 라이브러리 파일을 찾을 디렉토리 목록. PERL5LIB가 정의되면 PERLLIB가 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f3cc07c6f57898b2ef6aaadd57be04cf61845061" translate="yes" xml:space="preserve">
          <source>A list of directory paths. If the input file does not exist, then it will be searched for in the given directory list (in the order the directories appear in the list). It defaults to the list of directories implied by &lt;code&gt;$ENV{PATH}&lt;/code&gt; . The list may be specified either by a reference to an array, or by a string of directory paths which use the same path separator as &lt;code&gt;$ENV{PATH}&lt;/code&gt; on your system (e.g., &lt;code&gt;:&lt;/code&gt; for Unix, &lt;code&gt;;&lt;/code&gt; for MSWin32 and DOS).</source>
          <target state="translated">디렉토리 경로 목록. 입력 파일이 존재하지 않으면 주어진 디렉토리 목록에서 디렉토리가 목록에 나타나는 순서대로 검색됩니다. &lt;code&gt;$ENV{PATH}&lt;/code&gt; 의해 암시 된 디렉토리 목록이 기본값 입니다. 이 목록은 배열에 대한 참조 또는 시스템에서 &lt;code&gt;$ENV{PATH}&lt;/code&gt; 와 동일한 경로 구분 기호를 사용하는 디렉토리 경로 문자열로 지정 될 수 있습니다 (예 &lt;code&gt;:&lt;/code&gt; Unix의 경우 &lt;code&gt;;&lt;/code&gt; MSWin32 및 DOS의 경우).</target>
        </trans-unit>
        <trans-unit id="337601b93965c28568bbedd0632699f2eefded6b" translate="yes" xml:space="preserve">
          <source>A list of files in the distribution, one file per line. The MANIFEST always uses Unix filepath conventions even if you're not on Unix. This means</source>
          <target state="translated">분배에서 파일 목록 (한 줄에 하나씩). MANIFEST는 Unix를 사용하지 않는 경우에도 항상 Unix 파일 경로 규칙을 사용합니다. 이것은 의미</target>
        </trans-unit>
        <trans-unit id="0555d0b38c03024b415a75a77593c5880fa79206" translate="yes" xml:space="preserve">
          <source>A list of one or more symbol names that are in the library/object file to be dynamically loaded. This is only required on some platforms.</source>
          <target state="translated">라이브러리 / 객체 파일에 동적으로로드 될 하나 이상의 심볼 이름 목록입니다. 일부 플랫폼에서만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="681b6abf464391de8dd3a7916ae06f2d521a9817" translate="yes" xml:space="preserve">
          <source>A list of pads. The first one contains the names.</source>
          <target state="translated">패드 목록. 첫 번째는 이름을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="02f9cb55d32eb52f68051c89a619f41d785a1129" translate="yes" xml:space="preserve">
          <source>A list of possible choices from which you may select only one, as in, &amp;ldquo;Would you like door A, B, or C?&amp;rdquo; Alternatives in regular expressions are separated with a single vertical bar: &lt;code&gt;|&lt;/code&gt;. Alternatives in normal Perl expressions are separated with a double vertical bar: &lt;code&gt;||&lt;/code&gt;. Logical alternatives in &lt;b&gt;Boolean&lt;/b&gt; expressions are separated with either &lt;code&gt;||&lt;/code&gt; or &lt;code&gt;or&lt;/code&gt; .</source>
          <target state="translated">&amp;ldquo;문 A, B 또는 C를 원하십니까?&amp;rdquo;에서와 같이 하나만 선택할 수있는 가능한 선택 목록 정규식의 대체는 단일 세로 막대로 구분됩니다. &lt;code&gt;|&lt;/code&gt; . 일반 Perl 표현식의 대안은 이중 수직 막대로 구분됩니다. &lt;code&gt;||&lt;/code&gt; . &lt;b&gt;부울&lt;/b&gt; 식의 논리 대안은 &lt;code&gt;||&lt;/code&gt; 또는 &lt;code&gt;or&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="346e1107e8ac97822d23a43881fe3f608701a635" translate="yes" xml:space="preserve">
          <source>A list of signal names supported by the current platform can be found in &lt;code&gt;$Config{sig_name}&lt;/code&gt; , which is provided by the &lt;code&gt;Config&lt;/code&gt; module. See &lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt; for more details.</source>
          <target state="translated">현재 플랫폼에서 지원되는 신호 이름 목록은 &lt;code&gt;Config&lt;/code&gt; 모듈에서 제공하는 &lt;code&gt;$Config{sig_name}&lt;/code&gt; 에서 찾을 수 있습니다 . 자세한 내용은 &lt;a href=&quot;../config&quot;&gt;구성&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d9eb54a7b38bb34c8e5e028a36e767398adf41e8" translate="yes" xml:space="preserve">
          <source>A list of signal names supported by the current platform can be found in &lt;code&gt;$Config{sig_name}&lt;/code&gt; , which is provided by the &lt;code&gt;Config&lt;/code&gt; module. See &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; for more details.</source>
          <target state="translated">현재 플랫폼에서 지원되는 신호 이름 목록은 &lt;code&gt;Config&lt;/code&gt; 모듈에서 제공하는 &lt;code&gt;$Config{sig_name}&lt;/code&gt; 에서 찾을 수 있습니다 . 자세한 내용은 &lt;a href=&quot;config&quot;&gt;구성&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d6a6ca6e50a55d219bc744f957b355e8b7592c8a" translate="yes" xml:space="preserve">
          <source>A list of the built-in functions in Perl can be found in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;.</source>
          <target state="translated">Perl의 내장 함수 목록은 &lt;a href=&quot;perlfunc&quot;&gt;perlfunc에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="35384fe66627b2cc2fb84aa2b93b3f9464bdd2e5" translate="yes" xml:space="preserve">
          <source>A list started with e.g. a bullet-like &lt;code&gt;=item&lt;/code&gt; and continued with a numbered one. This is obviously inconsistent. For most translators the type of the</source>
          <target state="translated">목록은 예를 들어 글 머리 기호와 같은 &lt;code&gt;=item&lt;/code&gt; 으로 시작 하여 번호가 매겨진 목록으로 계속되었습니다. 이것은 분명히 일관성이 없습니다. 대부분의 번역가에게</target>
        </trans-unit>
        <trans-unit id="aa018bd7e5de867ce0e0e74c715e38d76832212f" translate="yes" xml:space="preserve">
          <source>A list value may also be subscripted like a normal array. You must put the list in parentheses to avoid ambiguity. For example:</source>
          <target state="translated">리스트 값은 일반 배열처럼 첨자 화 될 수도 있습니다. 모호성을 피하기 위해 목록을 괄호 안에 넣어야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6d0412d7581939fe7cd594904f6d1f6283358f69" translate="yes" xml:space="preserve">
          <source>A list-type op is usually constructed one kid at a time via &lt;code&gt;newLISTOP&lt;/code&gt; , &lt;code&gt;op_prepend_elem&lt;/code&gt; and &lt;code&gt;op_append_elem&lt;/code&gt; . Then finally it is passed to &lt;code&gt;op_convert_list&lt;/code&gt; to make it the right type.</source>
          <target state="translated">목록 유형 op는 일반적으로 &lt;code&gt;newLISTOP&lt;/code&gt; , &lt;code&gt;op_prepend_elem&lt;/code&gt; 및 &lt;code&gt;op_append_elem&lt;/code&gt; 을 통해 한 번에 한 아이 씩 구성 됩니다. 그런 다음 올바른 유형으로 만들기 위해 &lt;code&gt;op_convert_list&lt;/code&gt; 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="9f682c29d99c6edee87a4e2c8b480a19c081d9f4" translate="yes" xml:space="preserve">
          <source>A literal of the form &lt;code&gt;v1.20.300.4000&lt;/code&gt; is parsed as a string composed of characters with the specified ordinals. This form, known as v-strings, provides an alternative, more readable way to construct strings, rather than use the somewhat less readable interpolation form &lt;code&gt;&quot;\x{1}\x{14}\x{12c}\x{fa0}&quot;&lt;/code&gt; . This is useful for representing Unicode strings, and for comparing version &quot;numbers&quot; using the string comparison operators, &lt;code&gt;cmp&lt;/code&gt; , &lt;code&gt;gt&lt;/code&gt; , &lt;code&gt;lt&lt;/code&gt; etc. If there are two or more dots in the literal, the leading &lt;code&gt;v&lt;/code&gt; may be omitted.</source>
          <target state="translated">&lt;code&gt;v1.20.300.4000&lt;/code&gt; 형식의 리터럴은 지정된 서 수가있는 문자로 구성된 문자열로 구문 분석됩니다. v- 문자열이라고하는이 형식은 다소 읽기 어려운 보간 형식 &lt;code&gt;&quot;\x{1}\x{14}\x{12c}\x{fa0}&quot;&lt;/code&gt; 사용하는 대신 문자열을 구성하는 더 읽기 쉬운 대안을 제공합니다. &quot; . 이것은 유니 코드 문자열을 나타내거나 문자열 비교 연산자 &lt;code&gt;cmp&lt;/code&gt; , &lt;code&gt;gt&lt;/code&gt; , &lt;code&gt;lt&lt;/code&gt; 등을 사용하여 버전 &quot;숫자&quot;를 비교하는 데 유용 합니다. 리터럴에 두 개 이상의 점이있는 경우 선행 &lt;code&gt;v&lt;/code&gt; 는 생략 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59f7e21c905ecc7463ec1c2d73cca6ccc870ec21" translate="yes" xml:space="preserve">
          <source>A little bit less simple options</source>
          <target state="translated">조금 덜 간단한 옵션</target>
        </trans-unit>
        <trans-unit id="1cd2ad667ca8cebc07144e83ae02050c5a406af0" translate="yes" xml:space="preserve">
          <source>A little builtin syntactic sugar means you can also say &lt;b&gt;-m&lt;i&gt;MODULE&lt;/i&gt;=foo,bar&lt;/b&gt; or &lt;b&gt;-M&lt;i&gt;MODULE&lt;/i&gt;=foo,bar&lt;/b&gt; as a shortcut for &lt;b&gt;'-M&lt;i&gt;MODULE&lt;/i&gt; qw(foo bar)'&lt;/b&gt;. This avoids the need to use quotes when importing symbols. The actual code generated by &lt;b&gt;-M&lt;i&gt;MODULE&lt;/i&gt;=foo,bar&lt;/b&gt; is &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; module &lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;(/,/,q{foo,bar})&lt;/code&gt; . Note that the &lt;code&gt;=&lt;/code&gt; form removes the distinction between &lt;b&gt;-m&lt;/b&gt; and &lt;b&gt;-M&lt;/b&gt;; that is, &lt;b&gt;-m&lt;i&gt;MODULE&lt;/i&gt;=foo,bar&lt;/b&gt; is the same as &lt;b&gt;-M&lt;i&gt;MODULE&lt;/i&gt;=foo,bar&lt;/b&gt;.</source>
          <target state="translated">약간의 내장 된 구문 설탕은 &lt;b&gt;-m &lt;i&gt;MODULE&lt;/i&gt; = foo, bar&lt;/b&gt; 또는 &lt;b&gt;-M &lt;i&gt;MODULE&lt;/i&gt; = foo, bar&lt;/b&gt; 를 &lt;b&gt;'-M &lt;i&gt;MODULE&lt;/i&gt; qw (foo bar)'에&lt;/b&gt; 대한 바로 가기로 말할 수도 있음을 의미합니다 . 따라서 심볼을 가져올 때 따옴표를 사용할 필요가 없습니다. 에 의해 생성 된 실제 코드 &lt;b&gt;-M &lt;i&gt;MODULE&lt;/i&gt; 바 = 푸,&lt;/b&gt; 인 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; module &lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;(/,/,q{foo,bar})&lt;/code&gt; . 점을 유의 &lt;code&gt;=&lt;/code&gt; 양식의 차이 제거 &lt;b&gt;-m&lt;/b&gt; 과 &lt;b&gt;-M을&lt;/b&gt; ; 즉, &lt;b&gt;-m &lt;i&gt;MODULE&lt;/i&gt; = foo, bar&lt;/b&gt; 는 &lt;b&gt;-M &lt;i&gt;MODULE&lt;/i&gt; = foo, bar와 같습니다.&lt;/b&gt;.</target>
        </trans-unit>
        <trans-unit id="b161330532dd0ec0afc3fa6fafbca99d0e5e09ac" translate="yes" xml:space="preserve">
          <source>A little funky, because VOS's notion of ownership is a little funky (VOS).</source>
          <target state="translated">VOS의 소유권 개념이 약간 펑키 (VOS)이기 때문에 약간 펑키합니다.</target>
        </trans-unit>
        <trans-unit id="fe38aea6f56711cc8a09262301b75b1d00f515d0" translate="yes" xml:space="preserve">
          <source>A little interface to ExtUtils::Installed to examine installed modules, validate your packlists and even create a tarball from an installed module.</source>
          <target state="translated">ExtUtils :: Installed에 대한 작은 인터페이스로 설치된 모듈을 검사하고, 팩리스트를 확인하고, 설치된 모듈에서 타르볼을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="fab5a9063d3279beff24f900f22a1e9be454b440" translate="yes" xml:space="preserve">
          <source>A little-known feature of &lt;a href=&quot;../test/harness&quot;&gt;Test::Harness&lt;/a&gt; is that it supported TODO lists in the plan:</source>
          <target state="translated">&lt;a href=&quot;../test/harness&quot;&gt;Test :: Harness&lt;/a&gt; 의 거의 알려지지 않은 기능은 계획에서 TODO 목록을 지원한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="18dd594cfef1216511213db962d79c422701e3a6" translate="yes" xml:space="preserve">
          <source>A local modifies the listed variables to be local to the enclosing block, file, or eval. If more than one value is listed, the list must be placed in parentheses. See &lt;a href=&quot;../perlsub#Temporary-Values-via-local()&quot;&gt;Temporary Values via local() in perlsub&lt;/a&gt; for details, including issues with tied arrays and hashes.</source>
          <target state="translated">로컬은 나열된 변수를 둘러싸는 블록, 파일 또는 평가에 로컬로 수정합니다. 둘 이상의 값이 나열되면 목록을 괄호 안에 넣어야합니다. 연결된 배열 및 해시 문제를 포함하여 자세한 내용 &lt;a href=&quot;../perlsub#Temporary-Values-via-local()&quot;&gt;은 perlsub에서 local ()을 통한 임시 값을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d9869654ca036fa59fd44e2a08b434b738df4df1" translate="yes" xml:space="preserve">
          <source>A local modifies the listed variables to be local to the enclosing block, file, or eval. If more than one value is listed, the list must be placed in parentheses. See &lt;a href=&quot;perlsub#Temporary-Values-via-local()&quot;&gt;Temporary Values via local() in perlsub&lt;/a&gt; for details, including issues with tied arrays and hashes.</source>
          <target state="translated">로컬은 나열된 변수를 둘러싸는 블록, 파일 또는 평가에 로컬로 수정합니다. 둘 이상의 값이 나열되면 목록을 괄호 안에 넣어야합니다. 연결된 배열 및 해시 문제를 포함하여 자세한 내용 &lt;a href=&quot;perlsub#Temporary-Values-via-local()&quot;&gt;은 perlsub에서 local ()을 통한 임시 값을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="851216238693688504d3297975d3a9648a0c15ac" translate="yes" xml:space="preserve">
          <source>A locale is a set of data that describes various aspects of how various communities in the world categorize their world. These categories are broken down into the following types (some of which include a brief note here):</source>
          <target state="translated">로케일은 세계의 여러 커뮤니티가 세계를 분류하는 방법의 다양한 측면을 설명하는 데이터 세트입니다. 이러한 범주는 다음과 같은 유형으로 분류됩니다 (일부는 여기에 간단한 메모 포함).</target>
        </trans-unit>
        <trans-unit id="13e5d1d67a5e143b58f5105851151e51a7ee96cb" translate="yes" xml:space="preserve">
          <source>A location in a &lt;b&gt;hash table&lt;/b&gt; containing (potentially) multiple entries whose keys &amp;ldquo;hash&amp;rdquo; to the same hash value according to its hash function. (As internal policy, you don&amp;rsquo;t have to worry about it unless you&amp;rsquo;re into internals, or policy.)</source>
          <target state="translated">해시 함수에 따라 키가 동일한 해시 값으로 &quot;해시&quot;되는 여러 항목이 포함 된 &lt;b&gt;해시 테이블&lt;/b&gt; 의 위치입니다 . (내부 정책으로서 내부 또는 정책에 속하지 않는 한 걱정할 필요가 없습니다.)</target>
        </trans-unit>
        <trans-unit id="62c12399ed6b551ce7f2dd44832d843392fa0233" translate="yes" xml:space="preserve">
          <source>A lock can either be used to guard the data contained within the variable being locked, or it can be used to guard something else, like a section of code. In this latter case, the variable in question does not hold any useful data, and exists only for the purpose of being locked. In this respect, the variable behaves like the mutexes and basic semaphores of traditional thread libraries.</source>
          <target state="translated">잠금은 잠긴 변수에 포함 된 데이터를 보호하는 데 사용되거나 코드 섹션과 같은 다른 것을 보호하는 데 사용될 수 있습니다. 후자의 경우, 해당 변수는 유용한 데이터를 보유하지 않으며 잠그기위한 목적으로 만 존재합니다. 이와 관련하여 변수는 기존 스레드 라이브러리의 뮤텍스 및 기본 세마포어처럼 동작합니다.</target>
        </trans-unit>
        <trans-unit id="e53273bd96405d6a9351857fe0d8e6743bfe42f3" translate="yes" xml:space="preserve">
          <source>A log of changes you've made to this module. The layout is free-form. Here's an example:</source>
          <target state="translated">이 모듈의 변경 사항에 대한 로그입니다. 레이아웃은 자유 형식입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e77a6f13193bcd6e24d605469f11ccf9737a2eb7" translate="yes" xml:space="preserve">
          <source>A lone dash on the command line will now be a legal option, and using it will set variable &lt;code&gt;$stdio&lt;/code&gt; .</source>
          <target state="translated">명령 행에서 고독 대시는 이제 유효한 옵션이며이를 사용하여 &lt;code&gt;$stdio&lt;/code&gt; 변수를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="2ebb7eb8448d50869adcfaf8c37d6e3e449e059f" translate="yes" xml:space="preserve">
          <source>A lot of Git tools (Gitweb, GitHub, git log --pretty=oneline, ...) will only display the first line (cut off at 50 characters) when presenting commit summaries.</source>
          <target state="translated">많은 Git 도구 (Gitweb, GitHub, git log --pretty = oneline, ...)는 커밋 요약을 제시 할 때 첫 줄만 표시합니다 (50 자로 잘림).</target>
        </trans-unit>
        <trans-unit id="02a8d66dfb847fc32e205ee4aa1e54636c91fd8e" translate="yes" xml:space="preserve">
          <source>A lot of opcodes (this is an elementary operation in the internal perl stack machine) put an SV* on the stack. However, as an optimization the corresponding SV is (usually) not recreated each time. The opcodes reuse specially assigned SVs (</source>
          <target state="translated">많은 opcode (내부 perl stack machine의 기본 작업)는 SV *를 스택에 넣습니다. 그러나 최적화로서 해당 SV는 매번 다시 생성되지 않습니다. opcode는 특별히 할당 된 SV를 재사용합니다 (</target>
        </trans-unit>
        <trans-unit id="afe9679193e46dcbc5b397149b0a40382533461a" translate="yes" xml:space="preserve">
          <source>A lot of the behaviour of &lt;code&gt;check()&lt;/code&gt; can be altered by setting package variables. See the section on &lt;code&gt;Global Variables&lt;/code&gt; for details on this.</source>
          <target state="translated">패키지 변수를 설정 하여 &lt;code&gt;check()&lt;/code&gt; 의 많은 동작을 변경할 수 있습니다. 이에 대한 자세한 내용은 &lt;code&gt;Global Variables&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fc40634e762614784aeafebfe726c582b35ad008" translate="yes" xml:space="preserve">
          <source>A lot of the methods in this package are accessors to the various fields in the tar header:</source>
          <target state="translated">이 패키지의 많은 메소드는 tar 헤더의 다양한 필드에 대한 접근 자입니다.</target>
        </trans-unit>
        <trans-unit id="565ddf2f41fdaae2f6c398d4a9fce10061d3fdb0" translate="yes" xml:space="preserve">
          <source>A map to the empty string means that there is no alias defined for the code point.</source>
          <target state="translated">빈 문자열에 대한 맵은 코드 포인트에 대해 정의 된 별명이 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="962035547fe5a8c87c148cca16aad0a4071407ed" translate="yes" xml:space="preserve">
          <source>A mask of those &lt;b&gt;permission bits&lt;/b&gt; that should be forced off when creating files or directories, in order to establish a policy of whom you&amp;rsquo;ll ordinarily deny access to. See the &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">일반적으로 액세스를 거부 할 정책을 설정하기 위해 파일 또는 디렉토리를 작성할 때 강제로 사용해야 하는 &lt;b&gt;권한 비트&lt;/b&gt; 마스크 . &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 기능을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dfb92546e7ee6f466e3b9ad9b8c6c91db11b1f74" translate="yes" xml:space="preserve">
          <source>A meaningless value will currently be returned if the input is not an unsigned integer.</source>
          <target state="translated">입력이 부호없는 정수가 아닌 경우 현재 의미없는 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="46b7f4ae99fce16ec6771e2703c08b126f8c5237" translate="yes" xml:space="preserve">
          <source>A mechanism by which some high-level agent such as a user can pass its preferences down to its future offspring (child &lt;b&gt;processes&lt;/b&gt;, grandchild processes, great-grandchild processes, and so on). Each environment variable is a &lt;b&gt;key&lt;/b&gt;/&lt;b&gt;value&lt;/b&gt; pair, like one entry in a &lt;b&gt;hash&lt;/b&gt;.</source>
          <target state="translated">사용자와 같은 일부 고급 에이전트는 기본 설정을 미래의 자손 (자식 &lt;b&gt;프로세스&lt;/b&gt; , 손자 프로세스, 손자 프로세스 등)으로 전달할 수있는 메커니즘 입니다. 각 환경 변수는 &lt;b&gt;해시의&lt;/b&gt; 하나의 항목과 같은 &lt;b&gt;키&lt;/b&gt; / &lt;b&gt;값&lt;/b&gt; 쌍 입니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2a69447aeea5209e44940fc7462f35a5d6ac88b2" translate="yes" xml:space="preserve">
          <source>A mechanism in Perl that lets you store up the output of each Perl &lt;b&gt;command&lt;/b&gt; and then flush it out as a single request to the &lt;b&gt;operating system&lt;/b&gt;. It&amp;rsquo;s enabled by setting the &lt;code&gt;$|&lt;/code&gt; (&lt;code&gt;$AUTOFLUSH&lt;/code&gt; ) variable to a true value. It&amp;rsquo;s used when you don&amp;rsquo;t want data sitting around, not going where it&amp;rsquo;s supposed to, which may happen because the default on a &lt;b&gt;file&lt;/b&gt; or &lt;b&gt;pipe&lt;/b&gt; is to use &lt;b&gt;block buffering&lt;/b&gt;.</source>
          <target state="translated">각 Perl &lt;b&gt;명령&lt;/b&gt; 의 출력을 저장 한 다음 &lt;b&gt;운영 체제에&lt;/b&gt; 단일 요청으로 플러시 할 수있는 Perl 메커니즘 . &lt;code&gt;$|&lt;/code&gt; 를 설정하면 활성화됩니다 ( &lt;code&gt;$AUTOFLUSH&lt;/code&gt; ) 변수를 true 값으로 설정하십시오. &lt;b&gt;파일&lt;/b&gt; 이나 &lt;b&gt;파이프&lt;/b&gt; 의 기본값 이 &lt;b&gt;블록 버퍼링&lt;/b&gt; 을 사용 하기 때문에 발생할 수있는 곳으로 이동하지 않고 데이터를 원하지 않는 경우에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="51120e7f8481f25cf88f8c7a272aee4be9724200" translate="yes" xml:space="preserve">
          <source>A memory address (pointer). Typically associated with a &lt;code&gt;void *&lt;/code&gt; type.</source>
          <target state="translated">메모리 주소 (포인터). 일반적으로 &lt;code&gt;void *&lt;/code&gt; 유형 과 연관됩니다 .</target>
        </trans-unit>
        <trans-unit id="3a89278430a1f2647d19e07faa6dcd5ce49e8cc5" translate="yes" xml:space="preserve">
          <source>A message of the form:</source>
          <target state="translated">다음과 같은 형식의 메시지 :</target>
        </trans-unit>
        <trans-unit id="f4fff5e041e8ffd1750d8230d717d49c7140db99" translate="yes" xml:space="preserve">
          <source>A message printed to the &lt;code&gt;STDERR&lt;/code&gt; stream to the effect that something might be wrong but isn&amp;rsquo;t worth blowing up over. See &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo; and the &lt;code&gt;warnings&lt;/code&gt; pragma in Camel chapter 28, &amp;ldquo;Pragmantic Modules&amp;rdquo;.</source>
          <target state="translated">&lt;code&gt;STDERR&lt;/code&gt; 스트림에 메시지가 인쇄되어 무언가 잘못되었을 수 있지만 그만한 가치는 없습니다. Camel 27 장, &quot;기능&quot;및 Camel 28 장, &quot;Pragmantic Modules&quot; 의 &lt;code&gt;warnings&lt;/code&gt; pragma에서 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6a6e29399630661da9d8d4454f316b8b579ac7c9" translate="yes" xml:space="preserve">
          <source>A message to print prior to &lt;code&gt;@args&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;@args&lt;/code&gt; 이전에 인쇄 할 메시지 입니다.</target>
        </trans-unit>
        <trans-unit id="cd1e82245324d77d7c4b1f38686539fbc87f4207" translate="yes" xml:space="preserve">
          <source>A metacharacter can be matched by putting a backslash before it:</source>
          <target state="translated">메타 문자는 뒤에 백 슬래시를 넣어서 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb23d39b57fee733dc53600af45c98c9b288bdde" translate="yes" xml:space="preserve">
          <source>A method is simply a subroutine that expects a reference to an object (or a package name, for class methods) as the first argument.</source>
          <target state="translated">메소드는 단순히 첫 번째 인수로 오브젝트 (또는 클래스 메소드의 패키지 이름)에 대한 참조를 예상하는 서브 루틴입니다.</target>
        </trans-unit>
        <trans-unit id="8b793382672991d71fa4d5891acf893cacd7e306" translate="yes" xml:space="preserve">
          <source>A method of making input and output efficient by passing one &lt;b&gt;block&lt;/b&gt; at a time. By default, Perl does block buffering to disk files. See &lt;b&gt;buffer&lt;/b&gt; and &lt;b&gt;command buffering&lt;/b&gt;.</source>
          <target state="translated">한 번에 하나의 &lt;b&gt;블록&lt;/b&gt; 을 전달하여 입력 및 출력을 효율적으로 만드는 방법입니다 . 기본적으로 Perl은 디스크 파일에 대한 버퍼링을 차단합니다. &lt;b&gt;버퍼&lt;/b&gt; 및 &lt;b&gt;명령 버퍼링을&lt;/b&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="caf2b56be7a3ef3288ab77eb65ba11acb464aa6d" translate="yes" xml:space="preserve">
          <source>A method of storing numbers in &amp;ldquo;scientific notation&amp;rdquo;, such that the precision of the number is independent of its magnitude (the decimal point &amp;ldquo;floats&amp;rdquo;). Perl does its numeric work with floating-point numbers (sometimes called &amp;ldquo;floats&amp;rdquo;) when it can&amp;rsquo;t get away with using &lt;b&gt;integers&lt;/b&gt;. Floating-point numbers are mere approximations of real numbers.</source>
          <target state="translated">숫자의 정밀도가 크기 (소수점 &quot;floats&quot;)와 무관하도록 숫자를 &quot;과학적 표기법&quot;으로 저장하는 방법. Perl은 &lt;b&gt;integers&lt;/b&gt; 를 사용하여 벗어날 수 없을 때 부동 소수점 숫자 (때로는&amp;ldquo;floats&amp;rdquo;라고 함)로 숫자를 처리 합니다. 부동 소수점 숫자는 단순한 실수의 근사치입니다.</target>
        </trans-unit>
        <trans-unit id="944278d690e3fc7e64864c32faa75a96c4fa698a" translate="yes" xml:space="preserve">
          <source>A method returning a scalar containing definitions needed, typically for a C header file.</source>
          <target state="translated">일반적으로 C 헤더 파일에 필요한 정의를 포함하는 스칼라를 리턴하는 메소드입니다.</target>
        </trans-unit>
        <trans-unit id="b261259b0ea34efe663b89fa4a355d967119ff59" translate="yes" xml:space="preserve">
          <source>A method to return a suitable &lt;code&gt;#ifdef&lt;/code&gt; clause.</source>
          <target state="translated">적합한 &lt;code&gt;#ifdef&lt;/code&gt; 절 을 반환하는 메서드 입니다.</target>
        </trans-unit>
        <trans-unit id="e298259952faa9b6dc589a73a54938eb75e8b9ca" translate="yes" xml:space="preserve">
          <source>A method to return a suitable C &lt;code&gt;if&lt;/code&gt; statement to check whether</source>
          <target state="translated">적합한 C &lt;code&gt;if&lt;/code&gt; 문 을 반환하여 여부를 확인하는 방법</target>
        </trans-unit>
        <trans-unit id="b8d289dec370b10085acc876037d4a80d75d741c" translate="yes" xml:space="preserve">
          <source>A method to return a suitable assignment clause. If</source>
          <target state="translated">적합한 할당 절을 반환하는 방법. 만약</target>
        </trans-unit>
        <trans-unit id="b7330449bff2c39517a4e897b762ab9507a795d4" translate="yes" xml:space="preserve">
          <source>A minimal required perl version, if present, will look like this:</source>
          <target state="translated">필요한 경우 최소한의 필수 perl 버전은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e9a3539678256349db8d3cedb932d5bd4be41d3e" translate="yes" xml:space="preserve">
          <source>A misnamed feature&amp;mdash;it should be called, &amp;ldquo;expecting your mother to pick up after you&amp;rdquo;. Strictly speaking, Perl doesn&amp;rsquo;t do this, but it relies on a reference-counting mechanism to keep things tidy. However, we rarely speak strictly and will often refer to the reference-counting scheme as a form of garbage collection. (If it&amp;rsquo;s any comfort, when your interpreter exits, a &amp;ldquo;real&amp;rdquo; garbage collector runs to make sure everything is cleaned up if you&amp;rsquo;ve been messy with circular references and such.)</source>
          <target state="translated">이름이 잘못 지정된 기능 &amp;mdash;&amp;ldquo;어머니가 당신을 데리러 오기를 기대하십시오&amp;rdquo;라고 부릅니다. 엄밀히 말하면, Perl은 이것을하지 않지만, 물건을 깔끔하게 유지하기 위해 참조 계산 메커니즘에 의존합니다. 그러나 우리는 거의 엄격하게 말하지 않으며 종종 참조 계산 체계를 가비지 수집의 형태로 언급합니다. (편안한 경우 통역사가 종료되면 순환 참조 등으로 지저분한 경우 모든 것이 정리되도록 &quot;실제&quot;가비지 수집기가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="b76b41563e694ef10941bc1da1406e4e19d640cf" translate="yes" xml:space="preserve">
          <source>A modifier available specifically to search and replace is the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; evaluation modifier. &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; treats the replacement text as Perl code, rather than a double-quoted string. The value that the code returns is substituted for the matched substring. &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; is useful if you need to do a bit of computation in the process of replacing text. This example counts character frequencies in a line:</source>
          <target state="translated">검색 및 교체에 특별히 사용 가능한 수정자는 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; 평가 수정 자입니다. &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; 는 대체 텍스트를 큰 따옴표로 묶은 문자열이 아닌 Perl 코드로 취급합니다. 코드가 반환하는 값은 일치하는 하위 문자열로 대체됩니다. &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; 는 텍스트를 바꾸는 과정에서 약간의 계산이 필요한 경우에 유용합니다. 이 예는 한 줄로 문자 빈도를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="68d67d7e195f6e0fb6e2bd79bf9224c3c8d1e2fd" translate="yes" xml:space="preserve">
          <source>A module for loading must be quoted.</source>
          <target state="translated">로드 할 모듈을 인용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8d98e6118bd0f23607596b779080678b5a48db1b" translate="yes" xml:space="preserve">
          <source>A module is a file that (by convention) provides a class of the same name (sans the .pm), plus an import method in that class that can be called to fetch exported symbols. This module may implement some of its methods by loading dynamic C or C++ objects, but that should be totally transparent to the user of the module. Likewise, the module might set up an AUTOLOAD function to slurp in subroutine definitions on demand, but this is also transparent. Only the</source>
          <target state="translated">모듈은 규칙에 따라 동일한 이름의 클래스 (.pm)와 내 보낸 심볼을 가져 오기 위해 호출 할 수있는 해당 클래스의 가져 오기 메소드를 제공하는 파일입니다. 이 모듈은 동적 C 또는 C ++ 객체를로드하여 일부 메서드를 구현할 수 있지만 모듈 사용자에게는 완전히 투명해야합니다. 마찬가지로, 모듈은 필요에 따라 서브 루틴 정의를 처리하기 위해 AUTOLOAD 기능을 설정할 수도 있지만 이는 투명합니다. 오직</target>
        </trans-unit>
        <trans-unit id="22a73f9dccbade36d652d965f87a8dc414d1002a" translate="yes" xml:space="preserve">
          <source>A module is just a set of related functions in a library file, i.e., a Perl package with the same name as the file. It is specifically designed to be reusable by other modules or programs. It may do this by providing a mechanism for exporting some of its symbols into the symbol table of any package using it, or it may function as a class definition and make its semantics available implicitly through method calls on the class and its objects, without explicitly exporting anything. Or it can do a little of both.</source>
          <target state="translated">모듈은 라이브러리 파일, 즉 파일과 이름이 같은 Perl 패키지의 관련 기능 세트 일뿐입니다. 다른 모듈이나 프로그램에서 재사용 할 수 있도록 특별히 설계되었습니다. 이를 사용하여 일부 심볼을 ​​패키지의 심볼 테이블로 내보내는 메커니즘을 제공하여이를 수행하거나 클래스 정의로 기능하고 클래스 및 해당 오브젝트에 대한 메소드 호출을 통해 의미를 암시 적으로 사용 가능하게 할 수 있습니다. 무엇이든 내보내기. 아니면 둘 다 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2c608d01740d058ca105f502acc61136af2e317" translate="yes" xml:space="preserve">
          <source>A module that breaks a program text into a sequence of &lt;b&gt;tokens&lt;/b&gt; for later analysis by a parser.</source>
          <target state="translated">파서가 나중에 분석 할 수 있도록 프로그램 텍스트를 일련의 &lt;b&gt;토큰&lt;/b&gt; 으로 나누는 모듈입니다 .</target>
        </trans-unit>
        <trans-unit id="a247d01be7fadaf27f2b9413690f6e9d188b0db4" translate="yes" xml:space="preserve">
          <source>A module that helps you test testing modules that are built with &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt; 로 빌드 된 테스트 모듈을 테스트하는 데 도움이되는 모듈 .</target>
        </trans-unit>
        <trans-unit id="3605e1a22b2192fa5aa9baada403491f3d035bb2" translate="yes" xml:space="preserve">
          <source>A module that implements DOS-like globbing with a few enhancements. It is largely compatible with perlglob.exe (the M$ setargv.obj version) in all but one respect--it understands wildcards in directory components.</source>
          <target state="translated">몇 가지 향상된 기능으로 DOS와 같은 글 로빙을 구현하는 모듈입니다. perlglob.exe (M $ setargv.obj 버전)와 거의 호환되며 디렉토리 구성 요소의 와일드 카드를 이해합니다.</target>
        </trans-unit>
        <trans-unit id="28b02d8f461ab26400c63c168a94b3b2407585a9" translate="yes" xml:space="preserve">
          <source>A module's code has to be warning and strict-clean, since you can't guarantee the conditions that it'll be used under. Besides, you wouldn't want to distribute code that wasn't warning or strict-clean anyway, right?</source>
          <target state="translated">모듈의 코드는 사용 조건을 보장 할 수 없으므로 경고 및 엄격해야합니다. 게다가 경고 나 엄격하지 않은 코드를 배포하고 싶지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="c91f5a59bb26aa2af0fbaed73706b37f93fe9a63" translate="yes" xml:space="preserve">
          <source>A more complete and flexible interface for reading/writing gzip files/buffers is included with the module &lt;code&gt;IO-Compress-Zlib&lt;/code&gt; . See &lt;a href=&quot;../io/compress/gzip&quot;&gt;IO::Compress::Gzip&lt;/a&gt; and &lt;a href=&quot;../io/uncompress/gunzip&quot;&gt;IO::Uncompress::Gunzip&lt;/a&gt; for more details.</source>
          <target state="translated">gzip 파일 / 버퍼 읽기 / 쓰기를위한보다 완전하고 유연한 인터페이스는 &lt;code&gt;IO-Compress-Zlib&lt;/code&gt; 모듈에 포함되어 있습니다. &lt;a href=&quot;../io/compress/gzip&quot;&gt;IO :: Compress :: Gzip&lt;/a&gt; 및 &lt;a href=&quot;../io/uncompress/gunzip&quot;&gt;IO :: Uncompress :: Gunzip을&lt;/a&gt; 참조하십시오. 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a47893a0d4c8d8763c8f1003ea95b492858375e4" translate="yes" xml:space="preserve">
          <source>A more complete example of this is the Shell module on CPAN, which can treat undefined subroutine calls as calls to external programs.</source>
          <target state="translated">보다 완전한 예는 CPAN의 쉘 모듈로, 정의되지 않은 서브 루틴 호출을 외부 프로그램에 대한 호출로 취급 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="548a58ac3a8a4f644d16e2322da948be053c0188" translate="yes" xml:space="preserve">
          <source>A more dangerous version of getcwd(), but potentially faster.</source>
          <target state="translated">보다 위험한 getcwd () 버전이지만 잠재적으로 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="9c501a7097bf538c4d236187aed836b438d78d12" translate="yes" xml:space="preserve">
          <source>A more dangerous, but potentially faster version of abs_path.</source>
          <target state="translated">더 위험하지만 잠재적으로 더 빠른 abs_path 버전입니다.</target>
        </trans-unit>
        <trans-unit id="ac7a13ddb80b2e7ad5a52fa1664ac4bd3c5aef4e" translate="yes" xml:space="preserve">
          <source>A more direct work around is to change the filehandles used by &lt;a href=&quot;builder&quot;&gt;Test::Builder&lt;/a&gt;.</source>
          <target state="translated">보다 직접적인 해결 방법은 &lt;a href=&quot;builder&quot;&gt;Test :: Builder에서&lt;/a&gt; 사용하는 파일 핸들을 변경하는 것입니다. 입니다.</target>
        </trans-unit>
        <trans-unit id="3f085d06d504bc04c8c1f364c54e3b2d32d488c0" translate="yes" xml:space="preserve">
          <source>A more elegant (and safer) interface is needed.</source>
          <target state="translated">보다 우아하고 안전한 인터페이스가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d906501834bb08ebb1263e2b0973fc289f4c913f" translate="yes" xml:space="preserve">
          <source>A more general approach is to intervene manually, as with an example for the DB_File module, which requires SleepyCat's libdb.sl:</source>
          <target state="translated">SleepyCat의 libdb.sl이 필요한 DB_File 모듈의 예와 같이보다 일반적인 접근 방식은 수동으로 개입하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a0a3703fe588fb0e60a0c01fcfb0d140fe8770a1" translate="yes" xml:space="preserve">
          <source>A more readable, and perhaps more &quot;plain&quot; way is to use an alternate set of delimiters that doesn't require a single &quot;&amp;gt;&quot; to be escaped. Doubled angle brackets (&quot;&amp;lt;&amp;lt;&quot; and &quot;&amp;gt;&amp;gt;&quot;) may be used</source>
          <target state="translated">더 읽기 쉽고 &quot;일반적인&quot;방법은 단일 &quot;&amp;gt;&quot;를 이스케이프 처리하지 않아도되는 대체 구분 기호 집합을 사용하는 것입니다. 이중 꺾쇠 괄호 ( &quot;&amp;lt;&amp;lt;&quot;및 &quot;&amp;gt;&amp;gt;&quot;)를 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="4f3108171bdddd798db1e9b26d8d770fd7116c20" translate="yes" xml:space="preserve">
          <source>A morpheme in a programming language, the smallest unit of text with semantic significance.</source>
          <target state="translated">의미 상 의미가있는 가장 작은 텍스트 단위 인 프로그래밍 언어의 형태소.</target>
        </trans-unit>
        <trans-unit id="2790cfc68a916af917f3cc04e172e9586561a9c1" translate="yes" xml:space="preserve">
          <source>A naive, but often sufficient heuristic on ASCII platforms, for testing the first highbit byte-sequence in a BOM-less file (whether in code or in Pod!), to see whether that sequence is valid as UTF-8 (RFC 2279) is to check whether that the first byte in the sequence is in the range 0xC2 - 0xFD</source>
          <target state="translated">ASCII 플랫폼에서 순진하지만 충분한 휴리스틱으로 BOM이없는 파일 (코드 또는 포드 등)에서 첫 번째 하이 비트 바이트 시퀀스를 테스트하여 시퀀스가 ​​UTF-8로 유효한지 여부를 확인합니다 (RFC 2279). 시퀀스의 첫 번째 바이트가 0xC2-0xFD 범위에 있는지 확인하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="826c2733de66381609264a147718bd8a6dee2df5" translate="yes" xml:space="preserve">
          <source>A name for a concrete set of behaviors. A role is a way to add behavior to a class without inheritance.</source>
          <target state="translated">구체적인 행동 집합의 이름입니다. 역할은 상속없이 클래스에 동작을 추가하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="6cc90f6ad3d71e4b26203e2d58a28aac467dba0f" translate="yes" xml:space="preserve">
          <source>A name that represents a particular instance of opening a directory to read it, until you close it. See the &lt;code&gt;&lt;a href=&quot;functions/opendir&quot;&gt;opendir&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">디렉토리를 닫을 때까지 읽을 디렉토리를 여는 특정 인스턴스를 나타내는 이름입니다. &lt;code&gt;&lt;a href=&quot;functions/opendir&quot;&gt;opendir&lt;/a&gt;&lt;/code&gt; 함수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="57d4f638a5f1b060674c6232dbb757e9b9e2d99e" translate="yes" xml:space="preserve">
          <source>A name you give to a &lt;b&gt;statement&lt;/b&gt; so that you can talk about that statement elsewhere in the program.</source>
          <target state="translated">당신이에 제공하는 이름입니다 &lt;b&gt;문&lt;/b&gt; 이 프로그램에서 그 진술의 다른 곳에서 이야기 할 수 있도록.</target>
        </trans-unit>
        <trans-unit id="9e963f1a0b66c9a6c01f8278ff2607d7847c7265" translate="yes" xml:space="preserve">
          <source>A named array in scalar context is quite different from what would at first glance appear to be a list in scalar context. You can't get a list like &lt;code&gt;(1,2,3)&lt;/code&gt; into being in scalar context, because the compiler knows the context at compile time. It would generate the scalar comma operator there, not the list construction version of the comma. That means it was never a list to start with.</source>
          <target state="translated">스칼라 컨텍스트의 명명 된 배열은 언뜻보기에 스칼라 컨텍스트의 목록으로 보이는 것과는 상당히 다릅니다. 컴파일러는 컴파일 타임에 컨텍스트를 알고 있기 때문에 &lt;code&gt;(1,2,3)&lt;/code&gt; 과 같은 목록 을 스칼라 컨텍스트에있는 것으로 가져올 수 없습니다 . 쉼표의 목록 구성 버전이 아닌 스칼라 쉼표 연산자를 생성합니다. 그것은 처음부터 목록이 아니었다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="75daf7108ed110da5eff87e476f0ddf2290f10b8" translate="yes" xml:space="preserve">
          <source>A named capture group. Identical in every respect to normal capturing parentheses &lt;code&gt;()&lt;/code&gt; but for the additional fact that the group can be referred to by name in various regular expression constructs (like &lt;code&gt;\g{NAME}&lt;/code&gt; ) and can be accessed by name after a successful match via &lt;code&gt;%+&lt;/code&gt; or &lt;code&gt;%-&lt;/code&gt; . See &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for more details on the &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%-&lt;/code&gt; hashes.</source>
          <target state="translated">명명 된 캡처 그룹 모든 점에서 일반적인 캡처 괄호 &lt;code&gt;()&lt;/code&gt; 와 동일 하지만 그룹은 다양한 정규 표현식 구조 (예 : &lt;code&gt;\g{NAME}&lt;/code&gt; )에서 이름으로 참조 될 수 있으며 &lt;code&gt;%+&lt;/code&gt; 를 통해 성공적으로 일치 한 후에 이름으로 액세스 할 수 있다는 추가 사실 또는 &lt;code&gt;%-&lt;/code&gt; . &lt;code&gt;%+&lt;/code&gt; 및 &lt;code&gt;%-&lt;/code&gt; 해시 에 대한 자세한 내용 은 &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="184923b65ef8ae0c8a3e87da3ade2989c9cad4ca" translate="yes" xml:space="preserve">
          <source>A named collection of data, usually stored on disk in a &lt;b&gt;directory&lt;/b&gt; in a &lt;b&gt;filesystem&lt;/b&gt;. Roughly like a document, if you&amp;rsquo;re into office metaphors. In modern filesystems, you can actually give a file more than one name. Some files have special properties, like directories and devices.</source>
          <target state="translated">명명 된 데이터 모음으로, 일반적으로 &lt;b&gt;파일 시스템&lt;/b&gt; 의 &lt;b&gt;디렉토리&lt;/b&gt; 에있는 디스크에 저장됩니다 . 사무실 은유에 관한 문서와 거의 같습니다. 최신 파일 시스템에서는 실제로 파일에 둘 이상의 이름을 지정할 수 있습니다. 일부 파일에는 디렉토리 및 장치와 같은 특별한 속성이 있습니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6a9ab3c01eb064a3661e1bb7b921e5b073d19ecd" translate="yes" xml:space="preserve">
          <source>A named or otherwise accessible piece of program that can be invoked from elsewhere in the program in order to accomplish some subgoal of the program. A subroutine is often parameterized to accomplish different but related things depending on its input &lt;b&gt;arguments&lt;/b&gt;. If the subroutine returns a meaningful &lt;b&gt;value&lt;/b&gt;, it is also called a &lt;b&gt;function&lt;/b&gt;.</source>
          <target state="translated">프로그램의 일부 목표를 달성하기 위해 프로그램의 다른 곳에서 호출 할 수있는 명명되거나 액세스 가능한 프로그램. 서브 루틴은 종종 입력 &lt;b&gt;인수&lt;/b&gt; 에 따라 다르지만 관련된 것을 달성하기 위해 매개 변수화됩니다 . 서브 루틴이 의미있는 &lt;b&gt;값을&lt;/b&gt; 리턴하면 이를 &lt;b&gt;함수&lt;/b&gt; 라고도 &lt;b&gt;합니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="fd84ea80f8d7433a1aa60b125a9e6b4dc8885ca9" translate="yes" xml:space="preserve">
          <source>A named pipe (often referred to as a FIFO) is an old Unix IPC mechanism for processes communicating on the same machine. It works just like regular anonymous pipes, except that the processes rendezvous using a filename and need not be related.</source>
          <target state="translated">명명 된 파이프 (종종 FIFO라고도 함)는 동일한 컴퓨터에서 통신하는 프로세스를위한 오래된 Unix IPC 메커니즘입니다. 파일 이름을 사용하여 프로세스가 랑데부하고 관련 될 필요가 없다는 점을 제외하면 일반 익명 파이프와 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e0d06a3ea39fd5acfb66f824c51baebd59e34891" translate="yes" xml:space="preserve">
          <source>A named storage location that can hold any of various kinds of &lt;b&gt;value&lt;/b&gt;, as your program sees fit.</source>
          <target state="translated">프로그램이 적합하다고 생각 하는 다양한 종류의 &lt;b&gt;가치를&lt;/b&gt; 담을 수있는 명명 된 저장 위치 .</target>
        </trans-unit>
        <trans-unit id="092b494909d87658298161632e734b7420bfadba" translate="yes" xml:space="preserve">
          <source>A negatable option is specified with an exclamation mark &lt;code&gt;!&lt;/code&gt; after the option name:</source>
          <target state="translated">무시할 수있는 옵션은 느낌표로 지정됩니다 &lt;code&gt;!&lt;/code&gt; 옵션 이름 다음에 :</target>
        </trans-unit>
        <trans-unit id="99e2aec2990f88ba3867f8f52b0dfe7ccc80feb8" translate="yes" xml:space="preserve">
          <source>A negated expression, whether &lt;code&gt;!(EXPR)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/not&quot;&gt;not(EXPR)&lt;/a&gt;&lt;/code&gt;, or a logical exclusive-or, &lt;code&gt;(EXPR1) &lt;a href=&quot;functions/xor&quot;&gt;xor&lt;/a&gt; (EXPR2)&lt;/code&gt; . The bitwise versions (&lt;code&gt;~&lt;/code&gt; and &lt;code&gt;^&lt;/code&gt;) are not included.</source>
          <target state="translated">&lt;code&gt;!(EXPR)&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/not&quot;&gt;not(EXPR)&lt;/a&gt;&lt;/code&gt; 또는 논리 배타적 또는 &lt;code&gt;(EXPR1) &lt;a href=&quot;functions/xor&quot;&gt;xor&lt;/a&gt; (EXPR2)&lt;/code&gt; 여부에 관계없이 부정 된 표현식 입니다. 비트 버전 ( &lt;code&gt;~&lt;/code&gt; 및 &lt;code&gt;^&lt;/code&gt; )은 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="854efffaefa787b0da74283032eac82589c1370b" translate="yes" xml:space="preserve">
          <source>A negative signal name is the same as a negative signal number, killing process groups instead of processes. For example, &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; '-KILL', $pgrp&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -9, $pgrp&lt;/code&gt; will send &lt;code&gt;SIGKILL&lt;/code&gt; to the entire process group specified. That means you usually want to use positive not negative signals.</source>
          <target state="translated">음의 신호 이름은 음의 신호 번호와 동일하며 프로세스 대신 프로세스 그룹을 종료합니다. 예를 들어, &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; '-KILL', $pgrp&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -9, $pgrp&lt;/code&gt; 는 지정된 전체 프로세스 그룹에 &lt;code&gt;SIGKILL&lt;/code&gt; 을 보냅니다 . 즉, 일반적으로 음이 아닌 양의 신호를 사용하려고합니다.</target>
        </trans-unit>
        <trans-unit id="489423251916154fc8d55b14cad49fcf24beefc2" translate="yes" xml:space="preserve">
          <source>A negative signal name is the same as a negative signal number, killing process groups instead of processes. For example, &lt;code&gt;&lt;a href=&quot;kill&quot;&gt;kill&lt;/a&gt; '-KILL', $pgrp&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;kill&quot;&gt;kill&lt;/a&gt; -9, $pgrp&lt;/code&gt; will send &lt;code&gt;SIGKILL&lt;/code&gt; to the entire process group specified. That means you usually want to use positive not negative signals.</source>
          <target state="translated">음의 신호 이름은 음의 신호 번호와 동일하며 프로세스 대신 프로세스 그룹을 종료합니다. 예를 들어, &lt;code&gt;&lt;a href=&quot;kill&quot;&gt;kill&lt;/a&gt; '-KILL', $pgrp&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;kill&quot;&gt;kill&lt;/a&gt; -9, $pgrp&lt;/code&gt; 는 지정된 전체 프로세스 그룹에 &lt;code&gt;SIGKILL&lt;/code&gt; 을 보냅니다 . 즉, 일반적으로 음이 아닌 양의 신호를 사용하려고합니다.</target>
        </trans-unit>
        <trans-unit id="ea7af62eb6dd0992f67ddc428ca2b71250ece618" translate="yes" xml:space="preserve">
          <source>A nested code block was found that started with a delimiter that was specified as being only to be used as an outermost bracket.</source>
          <target state="translated">가장 바깥 쪽 대괄호로만 사용되도록 지정된 분리 문자로 시작된 중첩 된 코드 블록이 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="adfb1c2f0e03b3f5c0a88fd5a3243fdba91d6307" translate="yes" xml:space="preserve">
          <source>A new Net::POP3 object must be created with the</source>
          <target state="translated">새로운 Net :: POP3 객체는</target>
        </trans-unit>
        <trans-unit id="a6942aa9b1458599174d5fd62309534ead314562" translate="yes" xml:space="preserve">
          <source>A new Net::SMTP object must be created with the</source>
          <target state="translated">새로운 Net :: SMTP 객체는</target>
        </trans-unit>
        <trans-unit id="a156df59890d9311b601d33944f7c60f5c525f91" translate="yes" xml:space="preserve">
          <source>A new dumper is created by a call</source>
          <target state="translated">새로운 덤퍼는 호출에 의해 생성됩니다</target>
        </trans-unit>
        <trans-unit id="ce307d445764b039e813c87b536bf4d7ae071734" translate="yes" xml:space="preserve">
          <source>A new executable loads an extension compiled for the old executable when an old perl executable is running. In this case the extension will not pick up the forwarder - with fatal results.</source>
          <target state="translated">이전 perl 실행 파일이 실행될 때 새 실행 파일이 이전 실행 파일 용으로 컴파일 된 확장을로드합니다. 이 경우 확장 프로그램은 전달자를 선택하지 않으며 치명적인 결과를 초래합니다.</target>
        </trans-unit>
        <trans-unit id="ebbd18c3575dd80f81d435a80fe2d3c8ed42ba76" translate="yes" xml:space="preserve">
          <source>A new feature that allows the declaration of &lt;b&gt;variables&lt;/b&gt; and &lt;b&gt;subroutines&lt;/b&gt; with modifiers, as in &lt;code&gt;sub foo : locked
method&lt;/code&gt; . Also another name for an &lt;b&gt;instance variable&lt;/b&gt; of an &lt;b&gt;object&lt;/b&gt;.</source>
          <target state="translated">&lt;code&gt;sub foo : locked method&lt;/code&gt; 와 같이 수정자를 사용하여 &lt;b&gt;변수&lt;/b&gt; 및 &lt;b&gt;서브 루틴&lt;/b&gt; 을 선언 할 수있는 새로운 기능 . &lt;b&gt;객체&lt;/b&gt; 의 &lt;b&gt;인스턴스 변수&lt;/b&gt; 에 대한 또 다른 이름 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e164afa95fb2ed837b476e0b8fef0b485a678f9f" translate="yes" xml:space="preserve">
          <source>A new version of the output file is always created, which inherits the structure and RMS attributes of the input file, except for owner and protections (and possibly timestamps; see below). All data from the input file is copied to the output file; if either of the first two parameters to &lt;code&gt;rmscopy&lt;/code&gt; is a file handle, its position is unchanged. (Note that this means a file handle pointing to the output file will be associated with an old version of that file after &lt;code&gt;rmscopy&lt;/code&gt; returns, not the newly created version.)</source>
          <target state="translated">소유자 및 보호 (및 타임 스탬프, 아래 참조)를 제외한 입력 파일의 구조 및 RMS 속성을 상속하는 새 버전의 출력 파일이 항상 작성됩니다. 입력 파일의 모든 데이터가 출력 파일로 복사됩니다. &lt;code&gt;rmscopy&lt;/code&gt; 에 대한 처음 두 매개 변수 중 하나가 파일 핸들 인 경우 해당 위치는 변경되지 않습니다. (이는 출력 파일을 가리키는 파일 핸들 이 새로 작성된 버전이 아니라 &lt;code&gt;rmscopy&lt;/code&gt; 가 리턴 된 후 해당 파일의 이전 버전과 연관 됨을 의미 합니다.)</target>
        </trans-unit>
        <trans-unit id="c0eacc7ea97ca14f2375b6edf715d33122368ca7" translate="yes" xml:space="preserve">
          <source>A nice general-purpose fixer-upper function for indented here documents follows. It expects to be called with a here document as its argument. It looks to see whether each line begins with a common substring, and if so, strips that substring off. Otherwise, it takes the amount of leading whitespace found on the first line and removes that much off each subsequent line.</source>
          <target state="translated">여기에 들여 쓰기 된 문서를위한 훌륭한 범용 정착액-위 기능이 있습니다. 인수로 here 문서와 함께 호출 될 것으로 예상됩니다. 각 줄이 공통 하위 문자열로 시작하는지 확인하고, 그렇다면 해당 하위 문자열을 제거합니다. 그렇지 않으면 첫 번째 줄에서 발견되는 선행 공백의 양을 가져 와서 각 후속 줄에서 그 정도를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="0198bb3fbec60180f4c0bac09f0a4bb94105a46c" translate="yes" xml:space="preserve">
          <source>A nickname for something, which behaves in all ways as though you&amp;rsquo;d used the original name instead of the nickname. Temporary aliases are implicitly created in the loop variable for &lt;code&gt;foreach&lt;/code&gt; loops, in the &lt;code&gt;$_&lt;/code&gt; variable for &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; operators, in &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; during &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;&amp;rsquo;s comparison function, and in each element of &lt;code&gt;@_&lt;/code&gt; for the &lt;b&gt;actual arguments&lt;/b&gt; of a subroutine call. Permanent aliases are explicitly created in &lt;b&gt;packages&lt;/b&gt; by &lt;b&gt;importing&lt;/b&gt; symbols or by assignment to &lt;b&gt;typeglobs&lt;/b&gt;. Lexically scoped aliases for package variables are explicitly created by the &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration.</source>
          <target state="translated">닉네임 대신 원래 이름을 사용한 것처럼 모든 방식으로 작동하는 무언가의 닉네임입니다. 임시 별명은 암시에 대한 루프 변수에 생성 된 &lt;code&gt;foreach&lt;/code&gt; 문 에, 루프 &lt;code&gt;$_&lt;/code&gt; 에 대한 변수 &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 연산자, &lt;code&gt;$a&lt;/code&gt; 와 &lt;code&gt;$b&lt;/code&gt; 동안 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 비교 함수의, 그리고 각 요소에 &lt;code&gt;@_&lt;/code&gt; 에 대한 &lt;b&gt;실제 인수&lt;/b&gt; 의 서브 루틴 호출. 영구 별명은 기호 를 &lt;b&gt;가져 오거나 &lt;/b&gt;&lt;b&gt;typeglob&lt;/b&gt; 에 지정하여 &lt;b&gt;패키지&lt;/b&gt; 에서 명시 적으로 작성됩니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;. 패키지 변수에 대한 어휘 범위 별명은 명시 적으로 생성되는 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 선언.</target>
        </trans-unit>
        <trans-unit id="c1173dc0bd47411653c3329572e8d27b49fadacc" translate="yes" xml:space="preserve">
          <source>A no-op job.</source>
          <target state="translated">무직 직업.</target>
        </trans-unit>
        <trans-unit id="fb1ec4028a0ac13b58d2706d78d6f0e42a16b590" translate="yes" xml:space="preserve">
          <source>A no-op job. Returned by &lt;code&gt;TAP::Parser::Scheduler&lt;/code&gt; as an instruction to the harness to spin (keep executing tests) while the scheduler can't return a real job.</source>
          <target state="translated">무직 직업. 에 의해 반환 된 &lt;code&gt;TAP::Parser::Scheduler&lt;/code&gt; 스핀에 하네스 명령으로 스케줄러가 진짜 직업을 반환 할 수는 없지만 (테스트를 실행 유지).</target>
        </trans-unit>
        <trans-unit id="3187ac42757f3c2b53340569d4306b0db3207981" translate="yes" xml:space="preserve">
          <source>A non-optional prefix was specified but wasn't found at the start of the text.</source>
          <target state="translated">선택 사항이 아닌 접두사가 지정되었지만 텍스트 시작 부분에 없습니다.</target>
        </trans-unit>
        <trans-unit id="f9ce11826e25a9f2a78731b7ee2ed1865f372e1a" translate="yes" xml:space="preserve">
          <source>A not so obvious caveat with this (see [RT #79908]) is that the variable will be immediately inlined, and will stop behaving like a normal lexical variable, e.g. this will print &lt;code&gt;79907&lt;/code&gt; , not &lt;code&gt;79908&lt;/code&gt; :</source>
          <target state="translated">이것에 대한 명백하지 않은 경고 ([RT # 79908] 참조)는 변수가 즉시 인라인되고 일반적인 어휘 변수처럼 동작이 중지된다는 것입니다. 예를 들어 &lt;code&gt;79908&lt;/code&gt; 이 아니라 &lt;code&gt;79907&lt;/code&gt; 이 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="33aa5e0c48db29d1cb8a94c57d888257eb0656f5" translate="yes" xml:space="preserve">
          <source>A notable and rather unavoidable problem with this method: &quot;x-mingo-tom&quot; has an &quot;x&quot; because the whole tag isn't an IANA-registered tag -- but super_languages('x-mingo-tom') is ('x-mingo') -- which isn't really right, since 'i-mingo' is registered. But this module has no way of knowing that. (But note that same_language_tag('x-mingo', 'i-mingo') is TRUE.)</source>
          <target state="translated">이 방법에서 주목할 만하고 피할 수없는 문제 : &quot;x-mingo-tom&quot;은 전체 태그가 IANA 등록 태그가 아니기 때문에 &quot;x&quot;를 갖지만 super_languages ​​( 'x-mingo-tom')는 ( ' x-mingo ')-'i-mingo '가 등록되어 있기 때문에 실제로 올바르지 않습니다. 그러나이 모듈은 그것을 알 방법이 없습니다. (그러나 same_language_tag ( 'x-mingo', 'i-mingo')는 TRUE입니다.)</target>
        </trans-unit>
        <trans-unit id="11f822ddf21914cec4db6b8a6e4ef4d83bd0921c" translate="yes" xml:space="preserve">
          <source>A note about prefixes</source>
          <target state="translated">접두사에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="0a3c02a71990e114ae348bdc123412980dc80cfc" translate="yes" xml:space="preserve">
          <source>A note on freshness</source>
          <target state="translated">신선도에 대한 메모</target>
        </trans-unit>
        <trans-unit id="b0e5798976260679942afb564efdac5fe47bc36f" translate="yes" xml:space="preserve">
          <source>A note: to save time, 'regular expression' is often abbreviated as regexp or regex. Regexp is a more natural abbreviation than regex, but is harder to pronounce. The Perl pod documentation is evenly split on regexp vs regex; in Perl, there is more than one way to abbreviate it. We'll use regexp in this tutorial.</source>
          <target state="translated">참고 : 시간을 절약하기 위해 '정규 표현식'은 종종 정규 표현식 또는 정규 표현식으로 축약됩니다. 정규 표현식은 정규 표현식보다 더 자연스러운 약어이지만 발음하기가 더 어렵습니다. Perl 포드 문서는 정규 표현식과 정규 표현식에서 균등하게 나뉩니다. Perl에는 두 가지 이상의 방법이 있습니다. 이 튜토리얼에서는 regexp를 사용할 것입니다.</target>
        </trans-unit>
        <trans-unit id="7a28dfd2dad981af662c7cb062386ed614bc87a3" translate="yes" xml:space="preserve">
          <source>A notional &amp;ldquo;baton&amp;rdquo; handed around the Perl community indicating who is the lead integrator in some arena of development.</source>
          <target state="translated">Perl 커뮤니티 주변에 명목상의&amp;ldquo;배턴 (Baton)&amp;rdquo;이 주어졌으며, 일부 개발 분야에서 누가 리드 통합 자인지를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ab0d25629a9f27d8e2343a6d3ae7ea4be0af2ea6" translate="yes" xml:space="preserve">
          <source>A number in base 16, &amp;ldquo;hex&amp;rdquo; for short. The digits for 10 through 15 are customarily represented by the letters &lt;code&gt;a&lt;/code&gt; through &lt;code&gt;f&lt;/code&gt; . Hexadecimal constants in Perl start with &lt;code&gt;0x&lt;/code&gt; . See also the &lt;code&gt;&lt;a href=&quot;functions/hex&quot;&gt;hex&lt;/a&gt;&lt;/code&gt; function in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo;.</source>
          <target state="translated">16 진법의 숫자, 간단히 말하면&amp;ldquo;16 진수&amp;rdquo;입니다. 10에서 15까지의 숫자는 관례 적으로 &lt;code&gt;a&lt;/code&gt; - &lt;code&gt;f&lt;/code&gt; 문자 로 표시됩니다 . Perl의 16 진 상수는 &lt;code&gt;0x&lt;/code&gt; 로 시작 합니다. Camel 27 장,&amp;ldquo;함수&amp;rdquo; 의 &lt;code&gt;&lt;a href=&quot;functions/hex&quot;&gt;hex&lt;/a&gt;&lt;/code&gt; 함수 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a2e5df9d465cc20aefe1124101a063a27122315b" translate="yes" xml:space="preserve">
          <source>A number in base 8. Only the digits 0 through 7 are allowed. Octal constants in Perl start with 0, as in 013. See also the &lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">기수 8의 숫자입니다. 0에서 7까지의 숫자 만 허용됩니다. Perl의 8 진 상수는 013에서와 같이 0으로 시작 합니다. &lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt; 함수 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a69cd7220ef5a1c647fe095901d92bd9cd440d40" translate="yes" xml:space="preserve">
          <source>A number of backslash sequences have to do with changing the character, or characters following them. &lt;code&gt;\l&lt;/code&gt; will lowercase the character following it, while &lt;code&gt;\u&lt;/code&gt; will uppercase (or, more accurately, titlecase) the character following it. They provide functionality similar to the functions &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">많은 백 슬래시 시퀀스는 문자 또는 그 뒤의 문자를 변경하는 것과 관련이 있습니다. &lt;code&gt;\l&lt;/code&gt; 은 뒤에 오는 문자를 소문자로 사용하고 &lt;code&gt;\u&lt;/code&gt; 는 뒤에 오는 문자 를 대문자로 (또는 더 정확하게 제목) 표시합니다. &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt; 함수와 유사한 기능을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="459b7ae43dc0118e5f951dff6050b593d0645ae4" translate="yes" xml:space="preserve">
          <source>A number of canned filers are provided with this module. They cover a number of the main areas that filters are needed when interfacing with DBM files. They also act as templates for your own filters.</source>
          <target state="translated">이 모듈에는 여러 통조림 파일러가 제공됩니다. DBM 파일과 인터페이스 할 때 필터가 필요한 여러 가지 주요 영역을 다룹니다. 또한 필터를위한 템플릿 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="f165970578836ece242fb56057dfca4b475f795a" translate="yes" xml:space="preserve">
          <source>A number of functions are supplied in</source>
          <target state="translated">많은 기능이 제공됩니다</target>
        </trans-unit>
        <trans-unit id="6be56084a39af168e51355bee3d9a2b6a1443404" translate="yes" xml:space="preserve">
          <source>A number of symbolic constants are required by some methods in &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; . None are imported by default.</source>
          <target state="translated">&lt;code&gt;IO::Compress::Deflate&lt;/code&gt; 일부 메소드에는 많은 기호 상수가 필요 합니다 . 기본적으로는 가져 오지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f171c4c952b5198d03d74dd09582818a3af3ac23" translate="yes" xml:space="preserve">
          <source>A number of symbolic constants are required by some methods in &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; . None are imported by default.</source>
          <target state="translated">&lt;code&gt;IO::Compress::Gzip&lt;/code&gt; 일부 메소드에는 많은 기호 상수가 필요합니다 . 기본적으로는 가져 오지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8444a37c81d8d0b0573487ab107c561cc0dcc2fd" translate="yes" xml:space="preserve">
          <source>A number of symbolic constants are required by some methods in &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; . None are imported by default.</source>
          <target state="translated">&lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; 일부 메소드에는 많은 기호 상수가 필요합니다 . 기본적으로는 가져 오지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2b8207ded75c4eb74b9b2506733acf10f3db4dee" translate="yes" xml:space="preserve">
          <source>A number of symbolic constants are required by some methods in &lt;code&gt;IO::Compress::Zip&lt;/code&gt; . None are imported by default.</source>
          <target state="translated">&lt;code&gt;IO::Compress::Zip&lt;/code&gt; 일부 메소드에는 많은 기호 상수가 필요합니다 . 기본적으로는 가져 오지 않습니다.</target>
        </trans-unit>
        <trans-unit id="13520cd60b01e1d5b0a654b3de30cd8d691bfd72" translate="yes" xml:space="preserve">
          <source>A number of the perl self-tests fails for various reasons; generally these are minor and due to subtle differences between common POSIX-based environments and the OpenVOS POSIX environment. Ensure that you conduct sufficient testing of your code to guarantee that it works properly in the OpenVOS environment.</source>
          <target state="translated">여러 가지 펄 자체 테스트는 여러 가지 이유로 실패합니다. 일반적으로 이는 사소하고 일반적인 POSIX 기반 환경과 OpenVOS POSIX 환경의 미묘한 차이로 인해 발생합니다. OpenVOS 환경에서 코드가 올바르게 작동하는지 확인하기 위해 코드를 충분히 테스트해야합니다.</target>
        </trans-unit>
        <trans-unit id="6938035226ed22bf21a82d2591890e65b71e1814" translate="yes" xml:space="preserve">
          <source>A number or quoted &lt;b&gt;string&lt;/b&gt;&amp;mdash;an actual &lt;b&gt;value&lt;/b&gt; in the text of your program, as opposed to a &lt;b&gt;variable&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;변수&lt;/b&gt; 와 달리 프로그램 텍스트의 실제 &lt;b&gt;값인&lt;/b&gt; 숫자 또는 따옴표로 묶은 &lt;b&gt;문자열&lt;/b&gt; 입니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="817e0a226397234bf07db9517946a4f73aedf564" translate="yes" xml:space="preserve">
          <source>A number with no fractional (decimal) part. A counting number, like 1, 2, 3, and so on, but including 0 and the negatives.</source>
          <target state="translated">소수 (10 진) 부분이없는 숫자입니다. 1, 2, 3 등과 같은 계수 숫자이지만 0과 음수를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="c7326b507f702c91b1651bab340f7fd9d1233ba7" translate="yes" xml:space="preserve">
          <source>A numeric value corresponding to the desired exit status</source>
          <target state="translated">원하는 종료 상태에 해당하는 숫자 값</target>
        </trans-unit>
        <trans-unit id="516dd9f40fab20fab164bbcf97c01e41beccb620" translate="yes" xml:space="preserve">
          <source>A numeric value corresponding to the desired exit status.</source>
          <target state="translated">원하는 종료 상태에 해당하는 숫자 값입니다.</target>
        </trans-unit>
        <trans-unit id="f65805b27975bd2ea9ebc728a7ffd9aba1dc2684" translate="yes" xml:space="preserve">
          <source>A one- or two-character abbreviation for the OP's name.</source>
          <target state="translated">OP 이름의 한자 또는 두자 약어.</target>
        </trans-unit>
        <trans-unit id="3834679d6aeef19dae7b1ac9263711aa538649cc" translate="yes" xml:space="preserve">
          <source>A opposite problem occurs if you extract a UTF8-encoded file from a tarball. Using &lt;code&gt;get_content()&lt;/code&gt; on the &lt;code&gt;Archive::Tar::File&lt;/code&gt; object will return its content as a bytestring, not as a Unicode string.</source>
          <target state="translated">tarball에서 UTF8로 인코딩 된 파일을 추출하면 반대의 문제가 발생합니다. &lt;code&gt;Archive::Tar::File&lt;/code&gt; 객체 에서 &lt;code&gt;get_content()&lt;/code&gt; 를 사용하면 내용이 유니 코드 문자열이 아닌 바이트 문자열로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7d591c8e0c3b224f857fbffdd8e1cd395cd343c4" translate="yes" xml:space="preserve">
          <source>A package statement affects dynamic variables only, including those you've used &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; on, but</source>
          <target state="translated">package 문은 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 에서 사용한 변수를 포함하여 동적 변수에만 영향을 주지만</target>
        </trans-unit>
        <trans-unit id="fb0a21b3a9fa52dc9e4b76474cd2a329094bf2cb" translate="yes" xml:space="preserve">
          <source>A package statement affects dynamic variables only, including those you've used &lt;code&gt;&lt;a href=&quot;local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; on, but</source>
          <target state="translated">package 문은 &lt;code&gt;&lt;a href=&quot;local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 에서 사용한 변수를 포함하여 동적 변수에만 영향을 주지만</target>
        </trans-unit>
        <trans-unit id="17811bc7788393455d0445378861485836290fe5" translate="yes" xml:space="preserve">
          <source>A packet of data, such as a &lt;b&gt;UDP&lt;/b&gt; message, that (from the viewpoint of the programs involved) can be sent independently over the network. (In fact, all packets are sent independently at the &lt;b&gt;IP&lt;/b&gt; level, but &lt;b&gt;stream&lt;/b&gt; protocols such as &lt;b&gt;TCP&lt;/b&gt; hide this from your program.)</source>
          <target state="translated">&lt;b&gt;UDP&lt;/b&gt; 메시지 와 같은 데이터 패킷은 관련 프로그램의 관점에서 네트워크를 통해 독립적으로 전송 될 수 있습니다. 실제로 모든 패킷은 &lt;b&gt;IP&lt;/b&gt; 수준 에서 독립적으로 전송 되지만 &lt;b&gt;TCP&lt;/b&gt; 와 같은 &lt;b&gt;스트림&lt;/b&gt; 프로토콜은 이를 프로그램에서 숨 깁니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a8fade7e7e6957062a1ff55f1cde07bb98b07451" translate="yes" xml:space="preserve">
          <source>A parenthesized &lt;b&gt;subpattern&lt;/b&gt; used to group parts of a &lt;b&gt;regular expression&lt;/b&gt; into a single &lt;b&gt;atom&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;정규 표현식의&lt;/b&gt; 일부를 단일 &lt;b&gt;원자로&lt;/b&gt; 그룹화하는 데 사용되는 괄호로 묶인 &lt;b&gt;하위 패턴&lt;/b&gt; 입니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d31a105759b488881233b964b8bc299b268f919f" translate="yes" xml:space="preserve">
          <source>A particular 8-bit extension to ASCII that includes grave and acute accented Latin characters. Languages that can employ ISO 8859-1 include all the languages covered by ASCII as well as Afrikaans, Albanian, Basque, Catalan, Danish, Faroese, Finnish, Norwegian, Portuguese, Spanish, and Swedish. Dutch is covered albeit without the ij ligature. French is covered too but without the oe ligature. German can use ISO 8859-1 but must do so without German-style quotation marks. This set is based on Western European extensions to ASCII and is commonly encountered in world wide web work. In IBM character code set identification terminology, ISO 8859-1 is also known as CCSID 819 (or sometimes 0819 or even 00819).</source>
          <target state="translated">억음 악센트가있는 라틴 문자를 포함하는 ASCII의 특정 8 비트 확장. ISO 8859-1을 사용할 수있는 언어에는 ASCII뿐만 아니라 아프리칸스어, 알바니아어, 바스크어, 카탈로니아 어, 덴마크어, 파로 어, 핀란드어, 노르웨이어, 포르투갈어, 스페인어 및 스웨덴어가 포함 된 모든 언어가 포함됩니다. 네덜란드어는 ij 합자 없이도 보장됩니다. 프랑스어도 oe 합자없이 적용됩니다. 독일어는 ISO 8859-1을 사용할 수 있지만 독일어 스타일 인용 부호없이 사용해야합니다. 이 세트는 ASCII에 대한 서유럽 확장을 기반으로하며 일반적으로 월드 와이드 웹 작업에서 발생합니다. IBM 문자 코드 세트 식별 용어에서 ISO 8859-1은 CCSID 819 (또는 때로는 0819 또는 00819)라고도합니다.</target>
        </trans-unit>
        <trans-unit id="e0e8dc4da39b64602467413f10af7327c1334e77" translate="yes" xml:space="preserve">
          <source>A past developer of this module once said that it was no longer being actively developed. However, rumors of its demise were greatly exaggerated. Feedback and suggestions are quite welcome.</source>
          <target state="translated">이 모듈의 과거 개발자는 더 이상 적극적으로 개발되고 있지 않다고 말했습니다. 그러나 그 소멸에 대한 소문이 크게 과장되었습니다. 피드백과 제안은 매우 환영합니다.</target>
        </trans-unit>
        <trans-unit id="8c54ff10ac1e2c9e724650394df49761e14faa10" translate="yes" xml:space="preserve">
          <source>A patch is likely to be rejected if it closes off future avenues of development. For instance, a patch that placed a true and final interpretation on prototypes is likely to be rejected because there are still options for the future of prototypes that haven't been addressed.</source>
          <target state="translated">패치가 향후 개발 경로를 막 으면 거부 될 수 있습니다. 예를 들어, 프로토 타입에 대해 진실되고 최종적인 해석을 한 패치는 아직 해결되지 않은 프로토 타입의 미래에 대한 옵션이 여전히 있기 때문에 거부 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b84380ed4a63c4a53b35f4fed5c94c1acb30451" translate="yes" xml:space="preserve">
          <source>A pattern that contains one or more variables to be interpolated before parsing the pattern as a &lt;b&gt;regular expression&lt;/b&gt;, and that therefore cannot be analyzed at compile time, but must be reanalyzed each time the pattern match operator is evaluated. Runtime patterns are useful but expensive.</source>
          <target state="translated">패턴을 파싱하기 전에 보간 할 하나 이상의 변수를 포함하는 패턴 &lt;b&gt; 정규식&lt;/b&gt; 컴파일시 분석 할 수 없지만 패턴 일치 연산자가 평가 될 때마다 재분석되어야합니다. 런타임 패턴은 유용하지만 비용이 많이 듭니다.</target>
        </trans-unit>
        <trans-unit id="e54b749fa56abf529dd225e42a12bbcecb4cb20e" translate="yes" xml:space="preserve">
          <source>A pattern that is compiled with the &lt;code&gt;/u&lt;/code&gt; or &lt;code&gt;/a&lt;/code&gt; modifiers is treated as Unicode (though there are some restrictions with &lt;code&gt;/a&lt;/code&gt; ). Under the &lt;code&gt;/d&lt;/code&gt; and &lt;code&gt;/l&lt;/code&gt; modifiers, there are several other indications for Unicode; see &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;Character set modifiers in perlre&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;/u&lt;/code&gt; 또는 &lt;code&gt;/a&lt;/code&gt; 수정 자로 컴파일 된 패턴은 유니 코드로 취급됩니다 ( &lt;code&gt;/a&lt;/code&gt; 에는 약간의 제한 이 있음 ). &lt;code&gt;/d&lt;/code&gt; 및 &lt;code&gt;/l&lt;/code&gt; 수정 자 아래에는 유니 코드에 대한 여러 가지 다른 표시가 있습니다. 보다&lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;perlre의 문자 세트 수정자를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ac81362ffb97f570e29dfbe7c502b0eb97a9aae0" translate="yes" xml:space="preserve">
          <source>A person with permissions to index a &lt;b&gt;namespace&lt;/b&gt; in &lt;b&gt;PAUSE&lt;/b&gt;. Anyone can upload any namespace, but only primary and co-maintainers get their contributions indexed.</source>
          <target state="translated">인덱스 A는 권한을 가진 사람 &lt;b&gt;네임 스페이스&lt;/b&gt; 에서 &lt;b&gt;PAUSE&lt;/b&gt; . 누구나 네임 스페이스를 업로드 할 수 있지만 기본 및 공동 유지 관리자 만 기여를 색인화합니다.</target>
        </trans-unit>
        <trans-unit id="bdf584f5364a06bf31c21ab092ad59923872f304" translate="yes" xml:space="preserve">
          <source>A pidgin-like lingo spoken among &amp;rsquo;droids when they don&amp;rsquo;t wish to reveal their orientation (see &lt;b&gt;endian&lt;/b&gt;). Named after some similar languages spoken (for similar reasons) between compilers and interpreters in the late 20ᵗʰ century. These languages are characterized by representing everything as a nonarchitecture-dependent sequence of bytes.</source>
          <target state="translated">방향을 밝히고 싶지 않을 때 '드로이드들 사이에서 말하는 피진 같은 링고 ( &lt;b&gt;엔디안&lt;/b&gt; 참조)&lt;b&gt;&lt;/b&gt; ). 20 세기 후반 컴파일러와 인터프리터 사이에서 비슷한 이유로 사용되는 유사한 언어의 이름을 따서 명명되었습니다. 이러한 언어는 모든 것을 아키텍처에 의존하지 않는 바이트 시퀀스로 나타내는 것이 특징입니다.</target>
        </trans-unit>
        <trans-unit id="d44cad0ebf83404ba135e65877b0a7348740b15c" translate="yes" xml:space="preserve">
          <source>A piece of &lt;b&gt;memory&lt;/b&gt; accessible by two different &lt;b&gt;processes&lt;/b&gt; who otherwise would not see each other&amp;rsquo;s memory.</source>
          <target state="translated">의 조각 &lt;b&gt;메모리&lt;/b&gt; 두 개의 서로 다른 액세스 &lt;b&gt;프로세스&lt;/b&gt; 그렇지 않으면 서로의 메모리를 참조하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="ae75b42221a978d2300d9bbb31da21cdb6583f30" translate="yes" xml:space="preserve">
          <source>A piece of data supplied to a &lt;b&gt;program&lt;/b&gt;, &lt;b&gt;subroutine&lt;/b&gt;, &lt;b&gt;function&lt;/b&gt;, or &lt;b&gt;method&lt;/b&gt; to tell it what it&amp;rsquo;s supposed to do. Also called a &amp;ldquo;parameter&amp;rdquo;.</source>
          <target state="translated">데이터의 조각은 공급 &lt;b&gt;프로그램&lt;/b&gt; , &lt;b&gt;서브 루틴&lt;/b&gt; , &lt;b&gt;기능&lt;/b&gt; , 또는 &lt;b&gt;방법&lt;/b&gt; 이하기로되어 있는지를 알 수 있습니다. &quot;파라미터&quot;라고도합니다.</target>
        </trans-unit>
        <trans-unit id="94f70c32cf9b02415f8a7273bc9818046dbf12f7" translate="yes" xml:space="preserve">
          <source>A piece of data worth eight &lt;b&gt;bits&lt;/b&gt; in most places.</source>
          <target state="translated">8 &lt;b&gt;비트&lt;/b&gt; 가치의 데이터&lt;b&gt;&lt;/b&gt;대부분의 장소에서 .</target>
        </trans-unit>
        <trans-unit id="b577f26c3053457a977acc838db8d07639cc6ac7" translate="yes" xml:space="preserve">
          <source>A pitfall when fallback is TRUE and Perl resorts to a built-in implementation of an operator is that some operators have more than one semantic, for example &lt;code&gt;|&lt;/code&gt;:</source>
          <target state="translated">대체가 TRUE와 펄 리조트 인 함정 내장 연산자의 구현 일부 사업자는 예를 들어, 하나 이상의 의미가 있다는 것입니다 &lt;code&gt;|&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d50a84892f70340bd3a9931b241841288e99df2a" translate="yes" xml:space="preserve">
          <source>A plain &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; autodie&lt;/code&gt; implies &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; autodie qw(:default)&lt;/code&gt; . Note that &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; are not enabled by default. &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; requires the optional &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::System::Simple&quot;&gt;IPC::System::Simple&lt;/a&gt; module to be installed, and enabling &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; will invalidate their exotic forms. See &lt;a href=&quot;#BUGS&quot;&gt;BUGS&lt;/a&gt; below for more details.</source>
          <target state="translated">일반 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; autodie&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; autodie qw(:default)&lt;/code&gt; 의미 합니다 . 참고 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 기본적으로 활성화되어 있지 않습니다. &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 에는 옵션 &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::System::Simple&quot;&gt;IPC :: System :: Simple&lt;/a&gt; 모듈을 설치해야하며 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 를 활성화 하면 이국적인 형식이 무효화됩니다. 자세한 내용은 아래 &lt;a href=&quot;#BUGS&quot;&gt;버그&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b5112ffa79f8fbea8b85cd379c0dac6621cfbb1b" translate="yes" xml:space="preserve">
          <source>A port of SysV IPC is available for Cygwin.</source>
          <target state="translated">Cygwin에 SysV IPC 포트를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="608e0fee3c4504f82197f6257599cc064afc0c33" translate="yes" xml:space="preserve">
          <source>A port of dmake for Windows is available from:</source>
          <target state="translated">Windows 용 dmake 포트는 다음에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="107ead699a34a6b92016575e257f6bfde51b2d06" translate="yes" xml:space="preserve">
          <source>A portion of a &lt;b&gt;string&lt;/b&gt;, starting at a certain &lt;b&gt;character&lt;/b&gt; position (&lt;b&gt;offset&lt;/b&gt;) and proceeding for a certain number of characters.</source>
          <target state="translated">특정 &lt;b&gt;문자&lt;/b&gt; 위치 에서 시작 하는 &lt;b&gt;문자열&lt;/b&gt; 의 일부 ( &lt;b&gt;오프셋&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt; ) 수로 진행 .</target>
        </trans-unit>
        <trans-unit id="2df08b2dab9ca8b1fdefb915b96c623e0200cba0" translate="yes" xml:space="preserve">
          <source>A positional parameter is made optional by giving a default value, separated from the parameter name by &lt;code&gt;=&lt;/code&gt; :</source>
          <target state="translated">위치 매개 변수는 매개 변수 이름과 &lt;code&gt;=&lt;/code&gt; 로 구분 된 기본값을 제공하여 선택 사항입니다 .</target>
        </trans-unit>
        <trans-unit id="b85d6bf4f6c4fdd5d60e077f21d5dcceb61dc47f" translate="yes" xml:space="preserve">
          <source>A possibly-threaded program using a possibly-threaded module might have code like this:</source>
          <target state="translated">스레드 가능 모듈을 사용하는 스레드 가능 프로그램에는 다음과 같은 코드가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b3a72b5c10540ed557a8982bdee312dd7a07842" translate="yes" xml:space="preserve">
          <source>A powerful tool for optimizing such beasts is what is known as an &quot;independent group&quot;, which does not backtrack (see &lt;a href=&quot;#(%3f%3epattern)&quot;&gt;(?&amp;gt;pattern)&lt;/a&gt;). Note also that zero-length look-ahead/look-behind assertions will not backtrack to make the tail match, since they are in &quot;logical&quot; context: only whether they match is considered relevant. For an example where side-effects of look-ahead</source>
          <target state="translated">이러한 짐승을 최적화하기위한 강력한 도구는 &quot;독립 그룹&quot;으로 알려져 있으며 역 추적을하지 않습니다 ( &lt;a href=&quot;#(%3f%3epattern)&quot;&gt;(?&amp;gt; 패턴&lt;/a&gt; 참조 ) ). 길이가 0 인 미리보기 / look-behind 어설 션은 &quot;논리적&quot;컨텍스트에 있기 때문에 꼬리가 일치하도록 역 추적하지 않습니다. 일치 여부 만 관련이있는 것으로 간주됩니다. 예견의 부작용이있는 예</target>
        </trans-unit>
        <trans-unit id="f8090f10d3e078e45a1b56ad19ca0993e67735bf" translate="yes" xml:space="preserve">
          <source>A pragma is a module which influences some aspect of the compile time or run time behaviour of Perl, such as &lt;code&gt;strict&lt;/code&gt; or &lt;code&gt;warnings&lt;/code&gt; . With Perl 5.10 you are no longer limited to the built in pragmata; you can now create user pragmata that modify the behaviour of user functions within a lexical scope.</source>
          <target state="translated">pragma는 &lt;code&gt;strict&lt;/code&gt; 또는 &lt;code&gt;warnings&lt;/code&gt; 와 같이 Perl의 컴파일 시간 또는 런타임 동작의 일부 측면에 영향을주는 모듈입니다. . Perl 5.10에서는 더 이상 내장 된 pragmata로 제한되지 않습니다. 이제 어휘 범위 내에서 사용자 기능의 동작을 수정하는 사용자 pragmata를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3adf63746ff6644ce7bf5f35f924e0b644796838" translate="yes" xml:space="preserve">
          <source>A precomputed hash value for the MRO's name, or 0.</source>
          <target state="translated">MRO 이름의 사전 계산 된 해시 값 또는 0</target>
        </trans-unit>
        <trans-unit id="fef186fd41bd258794b7d0075ad4e261c2b3c05f" translate="yes" xml:space="preserve">
          <source>A predefined &lt;b&gt;character class&lt;/b&gt; matchable by the &lt;code&gt;\p&lt;/code&gt; or &lt;code&gt;\P&lt;/code&gt;&lt;b&gt;metasymbol&lt;/b&gt;. &lt;b&gt;Unicode&lt;/b&gt; defines hundreds of standard properties for every possible codepoint, and Perl defines a few of its own, too.</source>
          <target state="translated">미리 정의 된 &lt;b&gt;문자 클래스&lt;/b&gt; 바이 정합 가능한 &lt;code&gt;\p&lt;/code&gt; 또는 &lt;code&gt;\P&lt;/code&gt; &lt;b&gt;metasymbol&lt;/b&gt; . &lt;b&gt;유니 코드&lt;/b&gt; 는 가능한 모든 코드 포인트에 대해 수백 가지의 표준 속성을 정의하고 Perl도 고유 한 몇 가지를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="753111eab29b1d3a3d48d9bfe5c8e1db8a75f990" translate="yes" xml:space="preserve">
          <source>A private implementation of the &lt;code&gt;SvIVx&lt;/code&gt; macro for compilers which can't cope with complex macro expressions. Always use the macro instead.</source>
          <target state="translated">의 개인 구현 &lt;code&gt;SvIVx&lt;/code&gt; 복잡한 매크로 표현에 대처할 수없는 컴파일러 용 매크로 . 항상 매크로를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="194c1f16db6963ad188c9a67ab4a97692452c7d0" translate="yes" xml:space="preserve">
          <source>A private implementation of the &lt;code&gt;SvNVx&lt;/code&gt; macro for compilers which can't cope with complex macro expressions. Always use the macro instead.</source>
          <target state="translated">의 개인 구현 &lt;code&gt;SvNVx&lt;/code&gt; 복잡한 매크로 표현에 대처할 수없는 컴파일러 용 SvNVx 매크로 . 항상 매크로를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="45f81efd0665fe345ae1ff71f7dc78b1d8a8b9cf" translate="yes" xml:space="preserve">
          <source>A private implementation of the &lt;code&gt;SvPV&lt;/code&gt; macro for compilers which can't cope with complex macro expressions. Always use the macro instead.</source>
          <target state="translated">의 개인 구현 &lt;code&gt;SvPV&lt;/code&gt; 복잡한 매크로 표현식에 대처할 수없는 컴파일러 용 SvPV 매크로 . 항상 매크로를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="28ff9ef13649ddfcf7cbf759240331fcc05c09ec" translate="yes" xml:space="preserve">
          <source>A private implementation of the &lt;code&gt;SvPVbyte&lt;/code&gt; macro for compilers which can't cope with complex macro expressions. Always use the macro instead.</source>
          <target state="translated">의 개인 구현 &lt;code&gt;SvPVbyte&lt;/code&gt; 복잡한 매크로 표현식에 대처할 수없는 컴파일러 용 SvPVbyte 매크로 . 항상 매크로를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4c48a8487b346d5dd9b069a77af5f464c4aaa911" translate="yes" xml:space="preserve">
          <source>A private implementation of the &lt;code&gt;SvPVutf8&lt;/code&gt; macro for compilers which can't cope with complex macro expressions. Always use the macro instead.</source>
          <target state="translated">의 개인 구현 &lt;code&gt;SvPVutf8&lt;/code&gt; 복잡한 매크로 표현식에 대처할 수없는 컴파일러 용 매크로 . 항상 매크로를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ccefc2a8adb4ddac3b369c74930a6dbb95e32f5b" translate="yes" xml:space="preserve">
          <source>A private implementation of the &lt;code&gt;SvUVx&lt;/code&gt; macro for compilers which can't cope with complex macro expressions. Always use the macro instead.</source>
          <target state="translated">&lt;code&gt;SvUVx&lt;/code&gt; 의 개인 구현복잡한 매크로 표현에 대처할 수없는 컴파일러 용 매크로 . 항상 매크로를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="daa3f361ccd92e0c8c69a72e7a450ec455f808bd" translate="yes" xml:space="preserve">
          <source>A process that has died (exited) but whose parent has not yet received proper notification of its demise by virtue of having called &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt;. If you &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt;, you must clean up after your child processes when they exit; otherwise, the process table will fill up and your system administrator will Not Be Happy with you.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; (종료)되었지만 부모가 wait 또는 &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; 를 호출하여 사망에 대한 적절한 알림을받지 않은 프로세스입니다 . &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 하면 자녀가 퇴장 할 때 처리 한 후에 청소해야합니다. 그렇지 않으면 프로세스 테이블이 채워지고 시스템 관리자가 만족하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="8efafe66eae216a82a4ad38f05565ca385de1f6b" translate="yes" xml:space="preserve">
          <source>A process that usually starts when the system boots and shuts down when the system is shut down is called a daemon (Disk And Execution MONitor). If a daemon process has a configuration file which is modified after the process has been started, there should be a way to tell that process to reread its configuration file without stopping the process. Many daemons provide this mechanism using a &lt;code&gt;SIGHUP&lt;/code&gt; signal handler. When you want to tell the daemon to reread the file, simply send it the &lt;code&gt;SIGHUP&lt;/code&gt; signal.</source>
          <target state="translated">일반적으로 시스템이 부팅 될 때 시작되고 시스템이 종료 될 때 종료되는 프로세스를 데몬 (디스크 및 실행 모니터)이라고합니다. 데몬 프로세스에 프로세스가 시작된 후 수정 된 구성 파일이있는 경우 프로세스를 중지하지 않고 해당 프로세스가 구성 파일을 다시 읽도록 지시 할 수있는 방법이 있습니다. 많은 데몬이 &lt;code&gt;SIGHUP&lt;/code&gt; 신호 처리기를 사용하여이 메커니즘을 제공 합니다. 데몬에게 파일을 다시 읽도록 지시하려면 &lt;code&gt;SIGHUP&lt;/code&gt; 신호 를 보내십시오 .</target>
        </trans-unit>
        <trans-unit id="2cb736d823d351c183302791cfaf0e9b2bb8195b" translate="yes" xml:space="preserve">
          <source>A program designed to take a &lt;b&gt;stream&lt;/b&gt; of input and transform it into a stream of output.</source>
          <target state="translated">입력 &lt;b&gt;스트림&lt;/b&gt; 을 가져 와서 출력 스트림으로 변환 하도록 설계된 프로그램입니다 .</target>
        </trans-unit>
        <trans-unit id="0e57854f673e33842a3f502762fb9daa3a8e1f70" translate="yes" xml:space="preserve">
          <source>A program or subroutine that runs some other program or subroutine for you, modifying some of its input or output to better suit your purposes.</source>
          <target state="translated">목적에 맞게 일부 입력 또는 출력을 수정하여 다른 프로그램 또는 서브 루틴을 실행하는 프로그램 또는 서브 루틴.</target>
        </trans-unit>
        <trans-unit id="d4949b399696681050e02e3aa6d195b375c7c318" translate="yes" xml:space="preserve">
          <source>A program technique that lets you evaluate an &lt;b&gt;expression&lt;/b&gt; and then, based on the value of the expression, do a multiway branch to the appropriate piece of code for that value. Also called a &amp;ldquo;case structure&amp;rdquo;, named after the similar Pascal construct. Most switch statements in Perl are spelled &lt;code&gt;given&lt;/code&gt; . See &amp;ldquo;The &lt;code&gt;given&lt;/code&gt; statement&amp;rdquo; in Camel chapter 4, &amp;ldquo;Statements and Declarations&amp;rdquo;.</source>
          <target state="translated">&lt;b&gt;식&lt;/b&gt; 을 평가 한 다음 &lt;b&gt;식&lt;/b&gt; 의 값을 기반으로 해당 값에 해당하는 코드 조각에 대한 다중 분기를 수행 할 수있는 프로그램 기술입니다 . 비슷한 파스칼 구문의 이름을 딴&amp;ldquo;케이스 구조&amp;rdquo;라고도합니다. Perl의 대부분의 switch 문은 철자가 &lt;code&gt;given&lt;/code&gt; . Camel 4 장, &quot;설명 및 선언&quot;의 &quot; &lt;code&gt;given&lt;/code&gt; 진술&quot;을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5911c3911da879ac96181b5190227b6bb058fcf1" translate="yes" xml:space="preserve">
          <source>A program that lets you step through the &lt;b&gt;execution&lt;/b&gt; of your program, stopping or printing things out here and there to see whether anything has gone wrong, and, if so, what. The &amp;ldquo;symbolic&amp;rdquo; part just means that you can talk to the debugger using the same symbols with which your program is written.</source>
          <target state="translated">프로그램 &lt;b&gt;실행&lt;/b&gt; 을 단계별로 진행 하여 여기저기서 인쇄하거나 중지하여 문제가 발생했는지 여부를 확인하는 프로그램입니다. &quot;기호&quot;부분은 프로그램 작성과 동일한 기호를 사용하여 디버거와 통신 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8959e21bc141d47a80e97a7ffb793dfa86254ad0" translate="yes" xml:space="preserve">
          <source>A property named 'var' is assumed to exist for the opcodes, and is interpolated into the rendering.</source>
          <target state="translated">'var'이라는 속성은 opcode에 대해 존재한다고 가정하고 렌더링에 보간됩니다.</target>
        </trans-unit>
        <trans-unit id="7afee4b0974cba3382e7bb4183222667ce915680" translate="yes" xml:space="preserve">
          <source>A property of certain characters. Originally, typesetter stored capital letters in the upper of two cases and small letters in the lower one. Unicode recognizes three cases: &lt;b&gt;lowercase&lt;/b&gt; (&lt;b&gt;character property&lt;/b&gt;&lt;code&gt;\p{lower}&lt;/code&gt; ), &lt;b&gt;titlecase&lt;/b&gt; (&lt;code&gt;\p{title}&lt;/code&gt; ), and &lt;b&gt;uppercase&lt;/b&gt; (&lt;code&gt;\p{upper}&lt;/code&gt; ). A fourth casemapping called &lt;b&gt;foldcase&lt;/b&gt; is not itself a distinct case, but it is used internally to implement &lt;b&gt;casefolding&lt;/b&gt;. Not all letters have case, and some nonletters have case.</source>
          <target state="translated">특정 문자의 속성. 원래, typeetter는 대문자 2 개를 대문자로, 소문자를 대문자로 저장했습니다. 유니 코드는 &lt;b&gt;소문자&lt;/b&gt; ( &lt;b&gt;문자 속성 &lt;/b&gt; &lt;code&gt;\p{lower}&lt;/code&gt; ), &lt;b&gt;제목&lt;/b&gt; ( &lt;code&gt;\p{title}&lt;/code&gt; ) 및 &lt;b&gt;대문자&lt;/b&gt; ( &lt;code&gt;\p{upper}&lt;/code&gt; )의 세 가지 경우를 인식 합니다. 네 번째 casemapping라는 &lt;b&gt;foldcase이&lt;/b&gt; 뚜렷한 경우 그 자체이지만 구현하기 위해 내부적으로 사용되는 &lt;b&gt;casefolding을&lt;/b&gt; . 모든 문자에 대소 문자가있는 것은 아니며 일부 비 문자에는 대소 문자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="992dca0adb9b646b76591cb61fee4cdfffebc9ec" translate="yes" xml:space="preserve">
          <source>A pseudo layer that removes the top-most layer. Gives perl code a way to manipulate the layer stack. Note that &lt;code&gt;:&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; only works on real layers and will not undo the effects of pseudo layers like &lt;code&gt;:utf8&lt;/code&gt; . An example of a possible use might be:</source>
          <target state="translated">최상위 레이어를 제거하는 의사 레이어. 펄 코드에 레이어 스택을 조작하는 방법을 제공합니다. 참고 &lt;code&gt;:&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; 만 실제 계층에서 작동하며 같은 의사 층의 효과가 취소되지 않습니다 &lt;code&gt;:utf8&lt;/code&gt; . 사용 가능한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ff419cc31e5dd99b3e00b537155bcea526bbe610" translate="yes" xml:space="preserve">
          <source>A pseudolayer that enables a flag in the layer below to tell Perl that output should be in utf8 and that input should be regarded as already in valid utf8 form. &lt;b&gt;WARNING: It does not check for validity and as such should be handled with extreme caution for input, because security violations can occur with non-shortest UTF-8 encodings, etc.&lt;/b&gt; Generally &lt;code&gt;:encoding(utf8)&lt;/code&gt; is the best option when reading UTF-8 encoded data.</source>
          <target state="translated">아래 레이어의 플래그가 Perl에게 출력이 utf8이어야하고 입력이 이미 유효한 utf8 형식으로 간주되어야한다고 알 수있게하는 의사 레이어. &lt;b&gt;경고 : 유효성을 검사하지 않으므로 UTF-8 인코딩이 가장 짧지 않은 등의 보안 위반이 발생할 수 있으므로 입력시주의를 기울여 처리해야합니다. UTF-8을&lt;/b&gt; 읽을 때 일반적으로 &lt;code&gt;:encoding(utf8)&lt;/code&gt; 이 가장 좋습니다. 8 개의 인코딩 된 데이터.</target>
        </trans-unit>
        <trans-unit id="c46a1417af942e441ec740293a77160106782547" translate="yes" xml:space="preserve">
          <source>A pseudolayer that manipulates other layers. Applying the &lt;code&gt;:raw&lt;/code&gt; layer is equivalent to calling &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode($fh)&lt;/a&gt;&lt;/code&gt;. It makes the stream pass each byte as-is without translation. In particular, both CRLF translation and intuiting &lt;code&gt;:utf8&lt;/code&gt; from the locale are disabled.</source>
          <target state="translated">다른 레이어를 조작하는 의사 레이어입니다. &lt;code&gt;:raw&lt;/code&gt; 레이어를 적용하는 것은 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode($fh)&lt;/a&gt;&lt;/code&gt; 를 호출하는 것과 같습니다 . 변환없이 스트림이 각 바이트를 그대로 전달합니다. 특히 로케일의 CRLF 변환 및 intuiting &lt;code&gt;:utf8&lt;/code&gt; 이 모두 사용 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="fefe2bbba2d7bf83c98ed3d05237098307bf7f4b" translate="yes" xml:space="preserve">
          <source>A pseudolayer that turns the &lt;code&gt;:utf8&lt;/code&gt; flag</source>
          <target state="translated">&lt;code&gt;:utf8&lt;/code&gt; 플래그를 바꾸는 의사 층</target>
        </trans-unit>
        <trans-unit id="ecc09e716a2c2d18e2be806f7183c30c2f3b51c2" translate="yes" xml:space="preserve">
          <source>A psychoactive drug, popular in the &amp;rsquo;80s, probably developed at UC Berkeley or thereabouts. Similar in many ways to the prescription-only medication called &amp;ldquo;System V&amp;rdquo;, but infinitely more useful. (Or, at least, more fun.) The full chemical name is &amp;ldquo;Berkeley Standard Distribution&amp;rdquo;.</source>
          <target state="translated">80 년대에 유행 한 향정 신약은 UC 버클리 나 그 주변에서 개발되었을 것입니다. &amp;ldquo;System V&amp;rdquo;라고하는 처방전 전용 의약품과 여러 가지면에서 유사하지만 훨씬 더 유용합니다. (또는 적어도 더 재미 있습니다.) 전체 화학명은 &quot;Berkeley Standard Distribution&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="b62f9f104139d9b8c4e453ea5b9cd7a8ac0140f4" translate="yes" xml:space="preserve">
          <source>A public function (i.e. part of the internal API, but not necessarily sanctioned for use in extensions) begins like this:</source>
          <target state="translated">공개 함수 (즉, 내부 API의 일부이지만 확장에 사용하기 위해 반드시 승인 된 것은 아님)는 다음과 같이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="1fcfaef1b89a51f30ffb896e8c738cde9ef6077c" translate="yes" xml:space="preserve">
          <source>A pull-parser interface to parsing Pod</source>
          <target state="translated">포드를 파싱하기위한 풀 파서 인터페이스</target>
        </trans-unit>
        <trans-unit id="ce01020c3704b898a0c0774b915a9978c7a43b90" translate="yes" xml:space="preserve">
          <source>A question mark was chosen for this and for the minimal-matching construct because 1) question marks are rare in older regular expressions, and 2) whenever you see one, you should stop and &quot;question&quot; exactly what is going on. That's psychology....</source>
          <target state="translated">1) 이전 정규 표현식에서는 물음표가 드물고 2) 물음표가 표시 될 때마다 정확히 멈추고 &quot;질문&quot;해야하기 때문에 물음표와 최소 일치 구문에 대해 물음표가 선택되었습니다. 그것은 심리학입니다 ....</target>
        </trans-unit>
        <trans-unit id="7af52ef72c21fce506c2fc73241d0f35d841b4ef" translate="yes" xml:space="preserve">
          <source>A queue is a special thread-safe object that lets you put data in one end and take it out the other without having to worry about synchronization issues. They're pretty straightforward, and look like this:</source>
          <target state="translated">큐는 동기화 문제에 대해 걱정할 필요없이 한쪽 끝에 데이터를 넣고 다른 쪽을 꺼낼 수있는 특수한 스레드 안전 개체입니다. 그들은 매우 간단하며 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ce5a6f66f06330588b1d9e78cc960a0c4ce6fd02" translate="yes" xml:space="preserve">
          <source>A quick and dirty fix involves a little bit of code, but this may be all you need to figure out the problem.</source>
          <target state="translated">빠르고 더러운 수정에는 약간의 코드가 필요하지만 문제를 해결하는 데 필요한 전부일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1f4c66121a13dbcd4a35fcb46d7559bf401584e" translate="yes" xml:space="preserve">
          <source>A quick fix to the offending line (insert the missing parentheses) in the actual program and we're finished.</source>
          <target state="translated">실제 프로그램에서 문제를 일으키는 행에 대한 빠른 수정 (없는 괄호 삽입)이 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="caf25dde2a598596295bb7a94644c4b4622cf06c" translate="yes" xml:space="preserve">
          <source>A quick flag check to see whether an sv should be passed to sv_force_normal to be &quot;downgraded&quot; before SvIVX or SvPVX can be modified directly.</source>
          <target state="translated">SvIVX 또는 SvPVX를 직접 수정하기 전에 sv를 &quot;다운 그레이드&quot;하기 위해 sv를 sv_force_normal로 전달해야하는지 여부를 확인하는 빠른 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="5714e693202d7afa5eda5b56d0aae30074e97131" translate="yes" xml:space="preserve">
          <source>A quick note on terms</source>
          <target state="translated">용어에 대한 간단한 메모</target>
        </trans-unit>
        <trans-unit id="1d94544d51208195a231709cf1963af0c4de7162" translate="yes" xml:space="preserve">
          <source>A race condition exists when the result of several interrelated events depends on the ordering of those events, but that order cannot be guaranteed due to nondeterministic timing effects. If two or more programs, or parts of the same program, try to go through the same series of events, one might interrupt the work of the other. This is a good way to find an &lt;b&gt;exploit&lt;/b&gt;.</source>
          <target state="translated">여러 관련 이벤트의 결과가 해당 이벤트의 순서에 따라 다를 때 경쟁 조건이 존재하지만 비 결정적 타이밍 효과로 인해 해당 순서를 보장 할 수 없습니다. 둘 이상의 프로그램 또는 동일한 프로그램의 일부가 동일한 일련의 이벤트를 진행하려고하면 하나의 작업이 중단 될 수 있습니다. 이것은 &lt;b&gt;익스플로잇&lt;/b&gt; 을 찾는 좋은 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="b4fd04892bbded81531e522d3212286340ec1840" translate="yes" xml:space="preserve">
          <source>A read-write accessor will allow the caller to set the value as well as get it:</source>
          <target state="translated">읽기-쓰기 접근자는 호출자가 값을 설정하고 가져올 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="caaace35cefc12e27812e75c68a502f8caf0f7cf" translate="yes" xml:space="preserve">
          <source>A recent net or commercial release of Cygwin is required.</source>
          <target state="translated">Cygwin의 최신 순 또는 상업용 릴리스가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="279e88205b97d17edeab01fe3aebcdc1b843db2f" translate="yes" xml:space="preserve">
          <source>A recent version of perl for the Amiga can be found at the Geek Gadgets section of the Aminet:</source>
          <target state="translated">Amiga의 최신 perl 버전은 Aminet의 Geek Gadgets 섹션에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="091b3fb1a508c2d701cd7e6f7c6e6e5c3add3716" translate="yes" xml:space="preserve">
          <source>A recipe book for programming with CPAN.pm</source>
          <target state="translated">CPAN.pm으로 프로그래밍하기위한 레시피 북</target>
        </trans-unit>
        <trans-unit id="2d7c582850510d1397c7e76f17b16cc5d91e6066" translate="yes" xml:space="preserve">
          <source>A recreational vehicle, not to be confused with vehicular recreation. RV also means an internal Reference Value of the type a &lt;b&gt;scalar&lt;/b&gt; can hold. See also &lt;b&gt;IV&lt;/b&gt; and &lt;b&gt;NV&lt;/b&gt; if you&amp;rsquo;re not confused yet.</source>
          <target state="translated">차량 레크리에이션과 혼동하지 않는 레크리에이션 차량. RV는 또한 &lt;b&gt;스칼라&lt;/b&gt; 가 보유 할 수 있는 유형의 내부 참조 값을 의미합니다 . 아직 혼란스럽지 않은 경우 &lt;b&gt;IV&lt;/b&gt; 및 &lt;b&gt;NV를&lt;/b&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ad0a627886d7457b4c1bf3b7879c79721531858f" translate="yes" xml:space="preserve">
          <source>A reference can be blessed into a package with the following function:</source>
          <target state="translated">다음 함수를 사용하여 패키지에 참조를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9d8f8326d44e724663f7d05cf4610dd9fa3fff9" translate="yes" xml:space="preserve">
          <source>A reference can be created by using a special syntax, lovingly known as the *foo{THING} syntax. *foo{THING} returns a reference to the THING slot in *foo (which is the symbol table entry which holds everything known as foo).</source>
          <target state="translated">* foo {THING} 구문으로 알려진 특수 구문을 사용하여 참조를 작성할 수 있습니다. * foo {THING}은 * foo에서 THING 슬롯에 대한 참조를 리턴합니다 (이것은 foo로 알려진 모든 것을 보유하는 기호 테이블 항목입니다).</target>
        </trans-unit>
        <trans-unit id="aa895f94ce4272825894257bb4b5f46a12e2a648" translate="yes" xml:space="preserve">
          <source>A reference is a scalar value and can refer to any other Perl data type. So by storing a reference as the value of an array or hash element, you can easily create lists and hashes within lists and hashes. The following example shows a 2 level hash of hash structure using anonymous hash references.</source>
          <target state="translated">참조는 스칼라 값이며 다른 Perl 데이터 유형을 참조 할 수 있습니다. 따라서 참조를 배열 또는 해시 요소의 값으로 저장하면 목록과 해시 내에 목록과 해시를 쉽게 만들 수 있습니다. 다음 예는 익명 해시 참조를 사용하는 2 단계 해시 구조 해시를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="31756567f0b0edb207ae4b6d556e511492c04f15" translate="yes" xml:space="preserve">
          <source>A reference is a scalar value that</source>
          <target state="translated">참조는 스칼라 값입니다.</target>
        </trans-unit>
        <trans-unit id="9246f92f3034b3a452a0afe45331277281745beb" translate="yes" xml:space="preserve">
          <source>A reference that doesn&amp;rsquo;t get counted normally. When all the normal references to data disappear, the data disappears. These are useful for circular references that would never disappear otherwise.</source>
          <target state="translated">정상적으로 계산되지 않는 참조. 데이터에 대한 모든 일반 참조가 사라지면 데이터가 사라집니다. 이것들은 달리 사라지지 않는 순환 참조에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5bbf68c2e549802b044298b09b378b5fd28092c9" translate="yes" xml:space="preserve">
          <source>A reference to a filehandle, or the pathname of a file from which the invoking script's pod documentation should be read. It defaults to the file indicated by &lt;code&gt;$0&lt;/code&gt; (&lt;code&gt;$PROGRAM_NAME&lt;/code&gt; for users of</source>
          <target state="translated">파일 핸들에 대한 참조 또는 호출 스크립트의 포드 문서를 읽어야하는 파일의 경로 이름. 기본적으로 &lt;code&gt;$0&lt;/code&gt; ( &lt;code&gt;$PROGRAM_NAME&lt;/code&gt; 사용자)</target>
        </trans-unit>
        <trans-unit id="f5b22d93dc114d0a0d964dd5bfa61e077311cb6a" translate="yes" xml:space="preserve">
          <source>A reference to a filehandle, or the pathname of a file to which the usage message should be written. The default is &lt;code&gt;\*STDERR&lt;/code&gt; unless the exit value is less than 2 (in which case the default is &lt;code&gt;\*STDOUT&lt;/code&gt; ).</source>
          <target state="translated">파일 핸들에 대한 참조 또는 사용법 메시지를 작성해야하는 파일의 경로 이름. 종료 값이 2보다 작지 않은 경우 기본값은 &lt;code&gt;\*STDERR&lt;/code&gt; 입니다 (이 경우 기본값은 &lt;code&gt;\*STDOUT&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1be21fde0d5a369b6626dd71f37562d95b7a892a" translate="yes" xml:space="preserve">
          <source>A reference to a hash</source>
          <target state="translated">해시에 대한 참조</target>
        </trans-unit>
        <trans-unit id="caf281724b21daca5b76b0ce26ffdceb6ed5b592" translate="yes" xml:space="preserve">
          <source>A reference to a hash of rules that control which tests may be executed in parallel. If no rules are declared and &lt;a href=&quot;../cpan/meta/yaml&quot;&gt;CPAN::Meta::YAML&lt;/a&gt; is available, &lt;code&gt;TAP::Harness&lt;/code&gt; attempts to load rules from a YAML file specified by the &lt;code&gt;rulesfile&lt;/code&gt; parameter. If no rules file exists, the default is for all tests to be eligible to be run in parallel.</source>
          <target state="translated">병렬로 실행할 테스트를 제어하는 ​​규칙 해시에 대한 참조입니다. 규칙이 선언되지 않고 &lt;a href=&quot;../cpan/meta/yaml&quot;&gt;CPAN :: Meta :: YAML&lt;/a&gt; 을 사용할 수있는 경우 &lt;code&gt;TAP::Harness&lt;/code&gt; 는 &lt;code&gt;rulesfile&lt;/code&gt; 매개 변수로 지정된 YAML 파일에서 규칙을로드하려고 시도합니다 . 규칙 파일이없는 경우 기본값은 모든 테스트를 병렬로 실행할 수있는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cd42c7f4f6784f49153b357722a869874cd7cab5" translate="yes" xml:space="preserve">
          <source>A reference to a hash of scalar values in scalar context. Each entry of the hash has the fully qualified method name as its key and the method's scalar-context return values as its value.</source>
          <target state="translated">스칼라 컨텍스트에서 스칼라 값의 해시에 대한 참조입니다. 해시의 각 항목은 정규화 된 메소드 이름을 키로 사용하고 메소드의 스칼라 컨텍스트 리턴 값을 값으로 갖습니다.</target>
        </trans-unit>
        <trans-unit id="c3a87c12004d018bcf7a69155be997af1914286c" translate="yes" xml:space="preserve">
          <source>A reference to a hash.</source>
          <target state="translated">해시에 대한 참조</target>
        </trans-unit>
        <trans-unit id="9c7f4017cfb229c284c5327072ab9da27410d7df" translate="yes" xml:space="preserve">
          <source>A reference to a list of netmask strings in the form &lt;code&gt;&quot;134.99.4.0/24&quot;&lt;/code&gt; . These are used by the &lt;code&gt;requires_firewall&lt;/code&gt; function to determine if a given host is inside or outside your firewall.</source>
          <target state="translated">&lt;code&gt;&quot;134.99.4.0/24&quot;&lt;/code&gt; 형식의 넷 마스크 문자열 목록에 대한 참조 입니다. 이들은 호스트가 방화벽 내부 또는 외부에 있는지 여부를 판별하기 위해 &lt;code&gt;requires_firewall&lt;/code&gt; 기능에 의해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="30ea49a873c1ff374f329e97efef0ff346dccc25" translate="yes" xml:space="preserve">
          <source>A reference to a list of subroutine references and/or qr// objects and/or literal strings and/or hash references, specifying the extractors to be used to split the string. If this argument is omitted (or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) the list:</source>
          <target state="translated">서브 루틴 참조 및 / 또는 qr // 객체 및 / 또는 리터럴 문자열 및 / 또는 해시 참조 목록에 대한 참조로, 문자열을 분할하는 데 사용할 추출기를 지정합니다. 이 인수가 생략되면 (또는 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ) 목록이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="c0f47fcb868f1bdb2ed44c13b2967f53238fb92e" translate="yes" xml:space="preserve">
          <source>A reference to a list of tests which are allowed to fail. See &lt;a href=&quot;#TODO-TESTS&quot;&gt;TODO TESTS&lt;/a&gt;.</source>
          <target state="translated">실패 할 수있는 테스트 목록에 대한 참조입니다. &lt;a href=&quot;#TODO-TESTS&quot;&gt;TODO TESTS를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a16beaf14f9ebf81709ac7687142e7324bffbcbc" translate="yes" xml:space="preserve">
          <source>A reference to a scalar, containing any initial source code to prepend to the file or generator output.</source>
          <target state="translated">파일 또는 생성기 출력 앞에 추가 할 초기 소스 코드가 포함 된 스칼라에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="ca57032a4acbb0f04dd265f2403ba03843451cb5" translate="yes" xml:space="preserve">
          <source>A reference to a simple scalar</source>
          <target state="translated">간단한 스칼라에 대한 참조</target>
        </trans-unit>
        <trans-unit id="2f7717bc46f8882825267f8fb5ae31ad534d8604" translate="yes" xml:space="preserve">
          <source>A reference to a subroutine</source>
          <target state="translated">서브 루틴에 대한 참조</target>
        </trans-unit>
        <trans-unit id="b60540604d1e514c1059c3b516595d77c9c95f5f" translate="yes" xml:space="preserve">
          <source>A reference to a subroutine. If there is no filehandle (previous item), then this subroutine is expected to generate one line of source code per call, writing the line into &lt;code&gt;$_&lt;/code&gt; and returning 1, then finally at end of file returning 0. If there is a filehandle, then the subroutine will be called to act as a simple source filter, with the line as read in &lt;code&gt;$_&lt;/code&gt; . Again, return 1 for each valid line, and 0 after all lines have been returned.</source>
          <target state="translated">서브 루틴에 대한 참조 파일 핸들이없는 경우 (이전 항목)이 서브 루틴은 호출 당 한 줄의 소스 코드를 생성하여 &lt;code&gt;$_&lt;/code&gt; 행을 작성하고 1을 반환 한 다음 마지막으로 파일 끝에서 0을 반환합니다. 그러면 서브 루틴은 &lt;code&gt;$_&lt;/code&gt; 에서 행을 읽은 간단한 소스 필터로 작동하도록 호출됩니다 . 다시 한 번, 유효한 각 줄마다 1을 반환하고 모든 줄이 반환되면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="69d2c7af1b1feb58183b6cd3ab9665d62ba3318e" translate="yes" xml:space="preserve">
          <source>A reference to an &lt;code&gt;@INC&lt;/code&gt; style array of arguments to be passed to each test program.</source>
          <target state="translated">각 테스트 프로그램에 전달 될 인수 의 &lt;code&gt;@INC&lt;/code&gt; 스타일 배열에 대한 참조 입니다.</target>
        </trans-unit>
        <trans-unit id="c036eaf04cdd3c79b7e1454ebb2a945c2a1cd7fe" translate="yes" xml:space="preserve">
          <source>A reference to an SV which holds a C pointer</source>
          <target state="translated">C 포인터를 보유한 SV에 대한 참조</target>
        </trans-unit>
        <trans-unit id="23549f2151bb51628d2f58bbcf1156a64c3296ce" translate="yes" xml:space="preserve">
          <source>A reference to an anonymous array can be created using square brackets:</source>
          <target state="translated">익명 배열에 대한 참조는 대괄호를 사용하여 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="227fa37704dcf65c895f6b48accf114132dd71b4" translate="yes" xml:space="preserve">
          <source>A reference to an anonymous hash can be created using curly brackets:</source>
          <target state="translated">중괄호를 사용하여 익명 해시에 대한 참조를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75f71bb1e5a64ddcdb9e050cbea388199a1108b3" translate="yes" xml:space="preserve">
          <source>A reference to an anonymous subroutine can be created by using &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; without a subname:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 네임없이 sub 를 사용하여 익명 서브 루틴에 대한 참조를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8b1d9fe90cb9aed401ad78a9cb46511d34021ee8" translate="yes" xml:space="preserve">
          <source>A reference to an array</source>
          <target state="translated">배열에 대한 참조</target>
        </trans-unit>
        <trans-unit id="e31779df8d209b3542cc04e2be4c9b32f5d08f2c" translate="yes" xml:space="preserve">
          <source>A reference to an array of sections specifications (as described in &lt;a href=&quot;#SECTION-SPECIFICATIONS&quot;&gt;SECTION SPECIFICATIONS&lt;/a&gt;) which indicate the desired set of POD sections and subsections to be selected from input. If no section specifications are given, then all sections of the PODs are used.</source>
          <target state="translated">(AS 섹션에 기재된 사양의 배열에 대한 참조 &lt;a href=&quot;#SECTION-SPECIFICATIONS&quot;&gt;SECTION 사양&lt;/a&gt; POD 부 및 하위의 바람직한 세트를 나타냄)으로부터 선택 입력한다. 섹션 지정이 없으면 POD의 모든 섹션이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c89226f4c3258d3bce7e696eba292fd5daa132bc" translate="yes" xml:space="preserve">
          <source>A reference to the object for a virtual method or the name of the class for a static method</source>
          <target state="translated">가상 메소드의 오브젝트에 대한 참조 또는 정적 메소드의 클래스 이름</target>
        </trans-unit>
        <trans-unit id="21f30d908543711c9f728d7de0ea1261250a9055" translate="yes" xml:space="preserve">
          <source>A regression in AIX 7 causes a failure in make test in Time::Piece during daylight savings time. APAR IV16514 provides the fix for this. A quick test to see if it's required, assuming it is currently daylight savings in Eastern Time, would be to run &lt;code&gt; TZ=EST5 date +%Z &lt;/code&gt; . This will come back with &lt;code&gt;EST&lt;/code&gt; normally, but nothing if you have the problem.</source>
          <target state="translated">AIX 7의 회귀는 일광 절약 시간 동안 Time :: Piece에서 make 테스트에 실패합니다. APAR IV16514는 이에 대한 수정 사항을 제공합니다. 현재 동부 표준시로 일광 절약 시간을 가정하고 필요한지 확인하는 빠른 테스트는 &lt;code&gt; TZ=EST5 date +%Z &lt;/code&gt; 를 실행하는 것 입니다. 이것은 &lt;code&gt;EST&lt;/code&gt; 와 함께 정상적으로 돌아 오지만 문제가 있으면 아무것도 없습니다.</target>
        </trans-unit>
        <trans-unit id="0fc4dbf2e586369f7ce889ec848c85dffcc1c599" translate="yes" xml:space="preserve">
          <source>A regular expression engine is a program that takes a set of constraints specified in a mini-language, and then applies those constraints to a target string, and determines whether or not the string satisfies the constraints. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; for a full definition of the language.</source>
          <target state="translated">정규 표현식 엔진은 미니 언어로 지정된 일련의 제약 조건을 취한 다음 해당 제약 조건을 대상 문자열에 적용하고 문자열이 제약 조건을 만족하는지 여부를 결정하는 프로그램입니다. 언어의 전체 정의는 &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="898d96d1a86448c10c01fff6d7c680ca19e7f093" translate="yes" xml:space="preserve">
          <source>A regular expression match in the form of &lt;code&gt;/REGEX/&lt;/code&gt; , &lt;code&gt;$foo =~ /REGEX/&lt;/code&gt; , or &lt;code&gt;$foo =~ EXPR&lt;/code&gt; . Also, a negated regular expression match in the form &lt;code&gt;!/REGEX/&lt;/code&gt; , &lt;code&gt;$foo !~ /REGEX/&lt;/code&gt; , or &lt;code&gt;$foo !~ EXPR&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;/REGEX/&lt;/code&gt; , &lt;code&gt;$foo =~ /REGEX/&lt;/code&gt; 또는 &lt;code&gt;$foo =~ EXPR&lt;/code&gt; 형식의 정규식 일치 . 또한 부정 된 정규식은 &lt;code&gt;!/REGEX/&lt;/code&gt; , &lt;code&gt;$foo !~ /REGEX/&lt;/code&gt; 또는 &lt;code&gt;$foo !~ EXPR&lt;/code&gt; 형식으로 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="6b61a0c27a77da1e69f8478b8fd9175ff4c338f9" translate="yes" xml:space="preserve">
          <source>A regular expression that otherwise would compile using &lt;code&gt;/d&lt;/code&gt; rules, and which uses this construct will instead use &lt;code&gt;/u&lt;/code&gt; . Thus this construct tells Perl that you don't want &lt;code&gt;/d&lt;/code&gt; rules for the entire regular expression containing it.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;/d&lt;/code&gt; 규칙을 사용하여 컴파일 하고이 구문을 사용 하는 정규식 은 대신 &lt;code&gt;/u&lt;/code&gt; 를 사용 합니다. 따라서이 구문은 Perl에 포함 된 전체 정규 표현식에 대해 &lt;code&gt;/d&lt;/code&gt; 규칙을 원하지 않는다고 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="8052f2558ed14ca1695f0756ea843781532061f7" translate="yes" xml:space="preserve">
          <source>A related issue is thread-safety. When a new thread is created, the Perl interpreter is cloned, which implies that all reference addresses in use will be replaced with new ones. Thus, if a class tries to access a field of a cloned object its (cloned) data will still be stored under the now invalid reference address of the original in the parent thread. A general &lt;code&gt;CLONE&lt;/code&gt; method must be provided to re-establish the association.</source>
          <target state="translated">관련 문제는 스레드 안전성입니다. 새 스레드가 작성되면 Perl 인터프리터가 복제되어 사용중인 모든 참조 주소가 새 주소로 대체됩니다. 따라서 클래스가 복제 된 객체의 필드에 액세스하려고 시도해도 복제 된 데이터는 여전히 상위 스레드에서 원본의 유효하지 않은 참조 주소 아래에 저장됩니다. 연결을 다시 설정하려면 일반 &lt;code&gt;CLONE&lt;/code&gt; 방법을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="c5a4d830992a6346407400c2bf4e88b4a6e3e575" translate="yes" xml:space="preserve">
          <source>A related issue is use with perl's malloc. Perl's malloc uses &lt;code&gt;sbrk()&lt;/code&gt; to get memory, and &lt;code&gt;sbrk()&lt;/code&gt; is limited to the first allocation so in this case something like:</source>
          <target state="translated">관련된 문제는 perl의 malloc과 함께 사용하는 것입니다. Perl의 malloc은 &lt;code&gt;sbrk()&lt;/code&gt; 를 사용하여 메모리를 가져오고 &lt;code&gt;sbrk()&lt;/code&gt; 는 첫 번째 할당으로 제한 되므로이 경우 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="773c247356b687b3912aff9a0cf7c1a25f2fade5" translate="yes" xml:space="preserve">
          <source>A related strategy that's less open to forgery is to give them a PIN (personal ID number). Record the address and PIN (best that it be a random one) for later processing. In the mail you send, include a link to your site with the PIN included. If the mail bounces, you know it's not valid. If they don't click on the link, either they forged the address or (assuming they got the message) following through wasn't important so you don't need to worry about it.</source>
          <target state="translated">위조에 덜 개방적인 관련 전략은 PIN (개인 ID 번호)을 제공하는 것입니다. 나중에 처리 할 수 ​​있도록 주소와 PIN (임의의 것이 가장 좋음)을 기록하십시오. 보내는 메일에 PIN이 포함 된 사이트 링크를 포함 시키십시오. 메일이 반송되면 유효하지 않은 것입니다. 링크를 클릭하지 않으면 주소를 위조하거나 (메시지가 있다고 가정) 중요하지 않으므로 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1b0e6d749250f42dda0dbf4bdf376cdb3adb5626" translate="yes" xml:space="preserve">
          <source>A relationship between two &lt;b&gt;objects&lt;/b&gt; in which one object is considered to be a more specific version of the other, generic object: &amp;ldquo;A camel is a mammal.&amp;rdquo; Since the generic object really only exists in a Platonic sense, we usually add a little abstraction to the notion of objects and think of the relationship as being between a generic &lt;b&gt;base class&lt;/b&gt; and a specific &lt;b&gt;derived class&lt;/b&gt;. Oddly enough, Platonic classes don&amp;rsquo;t always have Platonic relationships&amp;mdash;see &lt;b&gt;inheritance&lt;/b&gt;.</source>
          <target state="translated">한 대상이 다른 일반 대상의보다 구체적인 버전으로 간주되는 두 &lt;b&gt;대상&lt;/b&gt; 간의 관계 :&amp;ldquo;낙타는 포유류&amp;rdquo;입니다. 일반 객체는 실제로 Platonic 의미로만 존재하기 때문에 일반적으로 객체 개념에 약간의 추상화를 추가하고 일반 &lt;b&gt;기본 클래스&lt;/b&gt; 와 특정 &lt;b&gt;파생 클래스&lt;/b&gt; 사이의 관계로 생각합니다 . 이상하게도 플라톤의 클래스가 플라톤의 관계를 항상 가지고있는 것은 아닙니다 . &lt;b&gt;상속을보십시오&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="9cc57b74bcbf78eacbd6b02d09950f83d1e82c98" translate="yes" xml:space="preserve">
          <source>A relatively new conference franchise with a large Perl portion is the Open Source Developers Conference or OSDC. First held in Australia it has recently also spread to Israel and France. More information can be found at: &lt;a href=&quot;http://www.osdc.com.au/&quot;&gt;http://www.osdc.com.au/&lt;/a&gt; for Australia, &lt;a href=&quot;http://www.osdc.org.il&quot;&gt;http://www.osdc.org.il&lt;/a&gt; for Israel, and &lt;a href=&quot;http://www.osdc.fr/&quot;&gt;http://www.osdc.fr/&lt;/a&gt; for France.</source>
          <target state="translated">Perl 부분이 많은 비교적 새로운 컨퍼런스 프랜차이즈는 오픈 소스 개발자 컨퍼런스 또는 OSDC입니다. 호주에서 처음 개최 된이 도시는 최근 이스라엘과 프랑스에도 전파되었습니다. 자세한 내용은 &lt;a href=&quot;http://www.osdc.com.au/&quot;&gt;http://www.osdc.com.au/ (&lt;/a&gt; 호주), &lt;a href=&quot;http://www.osdc.org.il&quot;&gt;http://www.osdc.org.il (&lt;/a&gt; 이스라엘), &lt;a href=&quot;http://www.osdc.fr/&quot;&gt;http://www.osdc.fr/ (&lt;/a&gt; 프랑스)에서 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="125bb83bd0e2557d465d8cae2a201d255865cfc8" translate="yes" xml:space="preserve">
          <source>A relatively recent addition to socket functions, may not be implemented even in Unix platforms.</source>
          <target state="translated">소켓 기능에 비교적 최근에 추가 된 것은 Unix 플랫폼에서도 구현되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fb2c7925dc01622384910beb32c259581a32e6c" translate="yes" xml:space="preserve">
          <source>A remark that doesn&amp;rsquo;t affect the meaning of the program. In Perl, a comment is introduced by a &lt;code&gt;#&lt;/code&gt; character and continues to the end of the line.</source>
          <target state="translated">프로그램의 의미에 영향을 미치지 않는 말. Perl에서 주석은 &lt;code&gt;#&lt;/code&gt; 문자로 시작하고 줄 끝까지 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="05ceaec7b64c7ce9cdeec60b39e51b96ddb09fbd" translate="yes" xml:space="preserve">
          <source>A repeat count after &lt;code&gt;u&lt;/code&gt; sets the number of bytes to put into an uuencoded line, which is the maximum of 45 by default, but could be set to some (smaller) integer multiple of three. &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; simply ignores the repeat count.</source>
          <target state="translated">&lt;code&gt;u&lt;/code&gt; 이후의 반복 횟수 는 기본적으로 최대 45 자이지만 uuencoded 행에 넣을 바이트 수를 설정하지만 3의 정수 (작은) 정수로 설정할 수 있습니다. &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 은 단순히 반복 횟수를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="3a53eb20270176512fa5bd8bf4b4f1be0776d385" translate="yes" xml:space="preserve">
          <source>A return code of 1 means that the requested key was not in the database.</source>
          <target state="translated">리턴 코드 1은 요청 된 키가 데이터베이스에 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ed4d8a6dc7b98d70bce7c0cb5069c17fe03ce939" translate="yes" xml:space="preserve">
          <source>A rudimentary command-line completion is also available, including lexical variables in the current scope if the &lt;code&gt;PadWalker&lt;/code&gt; module is installed.</source>
          <target state="translated">&lt;code&gt;PadWalker&lt;/code&gt; 모듈이 설치된 경우 현재 범위의 어휘 변수를 포함하여 기본적인 명령 줄 완성도 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="195465d41845715cc8feeb944d84d82eca7db90c" translate="yes" xml:space="preserve">
          <source>A safe filename for the package.</source>
          <target state="translated">패키지의 안전한 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="e965283a692e93e5f3c352fa50ba572d5ad94533" translate="yes" xml:space="preserve">
          <source>A sample Configure invocation looks something like this:</source>
          <target state="translated">샘플 구성 호출은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c38c9f9afa364c973ff5615c1cc8f4fc08593cdb" translate="yes" xml:space="preserve">
          <source>A sanitized VERSION with . replaced by _. For places where . has special meaning (some filesystems, RCS labels, etc...)</source>
          <target state="translated">으로 위생 처리 된 버전입니다. 로 교체되다 _. 장소가. 특별한 의미가 있습니다 (일부 파일 시스템, RCS 레이블 등).</target>
        </trans-unit>
        <trans-unit id="854d2d0c342e6a9cd9c52af8350f79c5b69ee115" translate="yes" xml:space="preserve">
          <source>A sanity check is done to ensure that the versions of the</source>
          <target state="translated">위생 점검은 버전의</target>
        </trans-unit>
        <trans-unit id="52b0650d241bfe8b8773b0c925166a2b232578a5" translate="yes" xml:space="preserve">
          <source>A sanity check that what Perl thinks the architecture is and what Config thinks the architecture is are the same. If they're not it will return false and show a diagnostic message.</source>
          <target state="translated">Perl이 아키텍처를 생각하는 것과 Config가 아키텍처를 동일하게 생각하는 것이 동일한지를 확인하십시오. 그렇지 않으면 false를 반환하고 진단 메시지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="13eb257f5c15cd87da91e7109e5621a0b92dd55a" translate="yes" xml:space="preserve">
          <source>A scalar represents a single value:</source>
          <target state="translated">스칼라는 단일 값을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="63bf2744d770c46d6894e17a03796eb6868d8317" translate="yes" xml:space="preserve">
          <source>A scalar that is going to be passed to some extension</source>
          <target state="translated">어떤 확장으로 전달 될 스칼라</target>
        </trans-unit>
        <trans-unit id="b892a705ca325c138b52905f099e8858ffbdfac0" translate="yes" xml:space="preserve">
          <source>A scalar value is interpreted as FALSE in the Boolean sense if it is undefined, the null string or the number 0 (or its string equivalent, &quot;0&quot;), and TRUE if it is anything else. The Boolean context is just a special kind of scalar context where no conversion to a string or a number is ever performed.</source>
          <target state="translated">스칼라 값은 정의되지 않은 경우 부울 의미에서 FALSE, 널 (null) 문자열 또는 숫자 0 (또는 해당 문자열 &quot;0&quot;), 그렇지 않으면 TRUE로 해석됩니다. 부울 컨텍스트는 문자열이나 숫자로의 변환이 수행되지 않는 특별한 종류의 스칼라 컨텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="ecf273fc6dfd9742bd76d45138d207f0b0c7c11c" translate="yes" xml:space="preserve">
          <source>A scalar we got back from an extension</source>
          <target state="translated">확장에서 얻은 스칼라</target>
        </trans-unit>
        <trans-unit id="7153eab5e3c20636ca530d5dc26c52e39ac43559" translate="yes" xml:space="preserve">
          <source>A scratchpad keeps SVs which are lexicals for the current unit and are targets for opcodes. A previous version of this document stated that one can deduce that an SV lives on a scratchpad by looking on its flags: lexicals have &lt;code&gt;SVs_PADMY&lt;/code&gt; set, and</source>
          <target state="translated">스크래치 패드는 현재 장치에 대한 어휘이고 opcode의 대상인 SV를 유지합니다. 이 문서의 이전 버전에서는 SV가 플래그를보고 스크래치 패드에있는 것으로 추론 할 수 있다고 언급했습니다. lexicals에는 &lt;code&gt;SVs_PADMY&lt;/code&gt; 가 설정되어 있으며</target>
        </trans-unit>
        <trans-unit id="9b4b51a187f878ac1e93c009ee393256c5f3fed7" translate="yes" xml:space="preserve">
          <source>A script called &quot;runperl.bat&quot; is available that can be copied to any filename (along with the .bat suffix). For example, if you call it &quot;foo.bat&quot;, it will run the file &quot;foo&quot; when it is executed. Since you can run batch files on Windows platforms simply by typing the name (without the extension), this effectively runs the file &quot;foo&quot;, when you type either &quot;foo&quot; or &quot;foo.bat&quot;. With this method, &quot;foo.bat&quot; can even be in a different location than the file &quot;foo&quot;, as long as &quot;foo&quot; is available somewhere on the PATH. If your scripts are on a filesystem that allows symbolic links, you can even avoid copying &quot;runperl.bat&quot;.</source>
          <target state="translated">&quot;runperl.bat&quot;라는 스크립트를 사용하여 모든 파일 이름으로 복사 할 수 있습니다 (.bat 접미사와 함께). 예를 들어, &quot;foo.bat&quot;라고하면 실행시 &quot;foo&quot;파일이 실행됩니다. 확장명없이 이름을 입력하기 만하면 Windows 플랫폼에서 배치 파일을 실행할 수 있으므로 &quot;foo&quot;또는 &quot;foo.bat&quot;를 입력하면 &quot;foo&quot;파일이 효과적으로 실행됩니다. 이 방법을 사용하면 &quot;foo&quot;가 PATH 어딘가에있는 한 &quot;foo.bat&quot;는 &quot;foo&quot;파일과 다른 위치에있을 수도 있습니다. 스크립트가 기호 링크를 허용하는 파일 시스템에있는 경우 &quot;runperl.bat&quot;를 복사하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="6e410531e148f9094643156d14e90843980c3dfe" translate="yes" xml:space="preserve">
          <source>A script that emulates the standard unix archive (aka library) utility. Under Watcom 10.6, ar is linked to wlib and provides the expected interface. With Watcom 9.5, a cover function is required. This one is fairly crude but has proved adequate for compiling perl.</source>
          <target state="translated">표준 유닉스 아카이브 (일명 라이브러리) 유틸리티를 에뮬레이트하는 스크립트. Watcom 10.6에서 ar은 wlib에 연결되어 있고 예상되는 인터페이스를 제공합니다. Watcom 9.5에서는 커버 기능이 필요합니다. 이것은 상당히 조잡하지만 펄을 컴파일하기에 충분한 것으로 판명되었습니다.</target>
        </trans-unit>
        <trans-unit id="e8eda0c28ba2fe483ef84daa3f54b909c119dec0" translate="yes" xml:space="preserve">
          <source>A script that provides C preprocessing functionality. Configure can generate a similar cover, but it doesn't handle all the command-line options that perl throws at it. This might be reasonably placed in /usr/local/bin.</source>
          <target state="translated">C 전처리 기능을 제공하는 스크립트. Configure는 비슷한 커버를 생성 할 수 있지만 perl이 처리하는 모든 명령 행 옵션을 처리하지는 않습니다. 이것은 / usr / local / bin에 합리적으로 배치 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f63efe767441f9b6cae7b2dee9e50e81364ad873" translate="yes" xml:space="preserve">
          <source>A searchable archive of the list is available at &lt;a href=&quot;http://markmail.org/search/?q=perl5-porters&quot;&gt;http://markmail.org/search/?q=perl5-porters&lt;/a&gt;. There is also an archive at &lt;a href=&quot;http://archive.develooper.com/perl5-porters@perl.org/&quot;&gt;http://archive.develooper.com/perl5-porters@perl.org/&lt;/a&gt;.</source>
          <target state="translated">목록의 검색 가능한 아카이브는 &lt;a href=&quot;http://markmail.org/search/?q=perl5-porters&quot;&gt;http://markmail.org/search/?q=perl5-porters&lt;/a&gt; 에서 사용할 수 있습니다 . &lt;a href=&quot;http://archive.develooper.com/perl5-porters@perl.org/&quot;&gt;http://archive.develooper.com/perl5-porters@perl.org/&lt;/a&gt; 에도 아카이브가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1598e0f0cd8f36f911067e3fef88a3cdc16b3aed" translate="yes" xml:space="preserve">
          <source>A section is started by the named heading or item. For example, &lt;code&gt;L&amp;lt;perlvar/$.&amp;gt;&lt;/code&gt; or &lt;code&gt;L&amp;lt;perlvar/&quot;$.&quot;&amp;gt;&lt;/code&gt; both link to the section started by &quot;&lt;code&gt;=item $.&lt;/code&gt; &quot; in perlvar. And &lt;code&gt;L&amp;lt;perlsyn/For Loops&amp;gt;&lt;/code&gt; or &lt;code&gt;L&amp;lt;perlsyn/&quot;For Loops&quot;&amp;gt;&lt;/code&gt; both link to the section started by &quot;&lt;code&gt;=head2 For Loops&lt;/code&gt; &quot; in perlsyn.</source>
          <target state="translated">섹션은 명명 된 제목 또는 항목으로 시작됩니다. 예를 들어, &lt;code&gt;L&amp;lt;perlvar/$.&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;L&amp;lt;perlvar/&quot;$.&quot;&amp;gt;&lt;/code&gt; 은 perlvar에서 &quot; &lt;code&gt;=item $.&lt;/code&gt; &quot;로 시작하는 섹션에 연결됩니다 . 그리고 &lt;code&gt;L&amp;lt;perlsyn/For Loops&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;L&amp;lt;perlsyn/&quot;For Loops&quot;&amp;gt;&lt;/code&gt; 는 perlsyn에서 &quot; &lt;code&gt;=head2 For Loops&lt;/code&gt; &quot;로 시작하는 섹션으로 연결됩니다 .</target>
        </trans-unit>
        <trans-unit id="2bd968f32a9ca757550679bcb38ba91ae56c38c6" translate="yes" xml:space="preserve">
          <source>A selection of any number of &lt;b&gt;elements&lt;/b&gt; from a &lt;b&gt;list&lt;/b&gt;, &lt;b&gt;array&lt;/b&gt;, or &lt;b&gt;hash&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;list&lt;/b&gt; , &lt;b&gt;array&lt;/b&gt; 또는 &lt;b&gt;hash&lt;/b&gt; 에서 원하는 수의 &lt;b&gt;요소&lt;/b&gt; 를 선택합니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c8bb7e9a293c6c000ed25150f0f4d86b8b09ae48" translate="yes" xml:space="preserve">
          <source>A selection of general-utility hash subroutines</source>
          <target state="translated">범용 유틸리티 해시 서브 루틴 선택</target>
        </trans-unit>
        <trans-unit id="7f015133979033409d91eedccc2323e573bc6368" translate="yes" xml:space="preserve">
          <source>A selection of general-utility list subroutines</source>
          <target state="translated">일반 유틸리티 목록 서브 루틴 선택</target>
        </trans-unit>
        <trans-unit id="28d3d211918b04ba8766082d56a39fef4fdf3700" translate="yes" xml:space="preserve">
          <source>A selection of general-utility scalar subroutines</source>
          <target state="translated">범용 유틸리티 스칼라 서브 루틴 선택</target>
        </trans-unit>
        <trans-unit id="6c2a22b80753e149c4a3e936da6e37252cc4db3f" translate="yes" xml:space="preserve">
          <source>A selection of utility subroutines for subs and CODE references</source>
          <target state="translated">서브 및 CODE 참조를위한 유틸리티 서브 루틴 선택</target>
        </trans-unit>
        <trans-unit id="047fc7c9d2dc1ac28d49429eb7bc7a3322abc4af" translate="yes" xml:space="preserve">
          <source>A semicolon (&lt;code&gt;;&lt;/code&gt; ) separates mandatory arguments from optional arguments. It is redundant before &lt;code&gt;@&lt;/code&gt; or &lt;code&gt;%&lt;/code&gt; , which gobble up everything else.</source>
          <target state="translated">세미콜론 ( &lt;code&gt;;&lt;/code&gt; )은 필수 인수를 선택적 인수와 구분합니다. &lt;code&gt;@&lt;/code&gt; 또는 &lt;code&gt;%&lt;/code&gt; 앞에 중복되어 다른 모든 것을 망칠 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f511bb1ccbd67c6c6ca9d2e6f48560176d03c2b5" translate="yes" xml:space="preserve">
          <source>A sequence of &lt;b&gt;bits&lt;/b&gt; that is actually being thought of as a sequence of bits, for once.</source>
          <target state="translated">실제로 &lt;b&gt;비트&lt;/b&gt; 시퀀스 로 생각되는 비트 시퀀스는 한 번입니다.</target>
        </trans-unit>
        <trans-unit id="cae9f6dde987a755ec3121175496d8328940bd06" translate="yes" xml:space="preserve">
          <source>A sequence of characters such as &amp;ldquo;He said !@#*&amp;amp;%@#*?!&amp;rdquo;. A string does not have to be entirely printable.</source>
          <target state="translated">&amp;ldquo;그는! @ # * &amp;amp; % @ # * ?!&amp;rdquo;와 같은 일련의 문자입니다. 문자열을 완전히 인쇄 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="fec7ee11f629dd8914f5fb3939fa45a8d0ac8f26" translate="yes" xml:space="preserve">
          <source>A sequence, such as &lt;code&gt;=head1&lt;/code&gt; , that denotes the start of a &lt;b&gt;pod&lt;/b&gt; section.</source>
          <target state="translated">&lt;b&gt;포드&lt;/b&gt; 섹션 의 시작을 나타내는 &lt;code&gt;=head1&lt;/code&gt; 과 같은 시퀀스 입니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="615050343b7872b60001479c7e1e5357ce76b3e7" translate="yes" xml:space="preserve">
          <source>A series of &lt;b&gt;processes&lt;/b&gt; all in a row, linked by &lt;b&gt;pipes&lt;/b&gt;, where each passes its output stream to the next.</source>
          <target state="translated">&lt;b&gt;파이프로&lt;/b&gt; 연결된 일련의 &lt;b&gt;프로세스가&lt;/b&gt; 모두 &lt;b&gt;파이프로&lt;/b&gt; 연결되어 있으며 각 &lt;b&gt;프로세스&lt;/b&gt; 는 출력 스트림을 다음 스트림으로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="5e7b6708245b79eaeed5d38bcac016afddbd6e09" translate="yes" xml:space="preserve">
          <source>A series of characters matches that series of characters in the target string, so the pattern &lt;code&gt;blurfl&lt;/code&gt; would match &quot;blurfl&quot; in the target string.</source>
          <target state="translated">일련의 문자는 대상 문자열의 해당 일련의 문자와 일치하므로 패턴 &lt;code&gt;blurfl&lt;/code&gt; 은 대상 문자열의 &quot;blurfl&quot;과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="cb6d59d3792163250639b9090bf480c17ab2f55e" translate="yes" xml:space="preserve">
          <source>A set of &lt;b&gt;directories&lt;/b&gt; and &lt;b&gt;files&lt;/b&gt; residing on a partition of the disk. Sometimes known as a &amp;ldquo;partition&amp;rdquo;. You can change the file&amp;rsquo;s name or even move a file around from directory to directory within a filesystem without actually moving the file itself, at least under Unix.</source>
          <target state="translated">디스크 파티션에있는 &lt;b&gt;디렉토리&lt;/b&gt; 및 &lt;b&gt;파일&lt;/b&gt; 세트 . &quot;파티션&quot;이라고도합니다. 적어도 Unix에서 실제로 파일 자체를 이동하지 않고도 파일 이름을 변경하거나 파일 시스템 내 디렉토리에서 디렉토리로 파일을 이동할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5ce6ae6f62d942a0f2702d5475445785e80396f" translate="yes" xml:space="preserve">
          <source>A set of criteria used to validate a particular piece of data if it has to adhere to particular rules.</source>
          <target state="translated">특정 규칙을 준수해야하는 경우 특정 데이터를 확인하는 데 사용되는 일련의 기준.</target>
        </trans-unit>
        <trans-unit id="abcc0ff1d11111cc38f19c5047e331b6ce4f3ede" translate="yes" xml:space="preserve">
          <source>A set of distribution prerequisites by phase and type</source>
          <target state="translated">단계 및 유형별 분배 전제 조건 세트</target>
        </trans-unit>
        <trans-unit id="2054435ebeb82c104e8cc6baf030893f06d8bca6" translate="yes" xml:space="preserve">
          <source>A set of macros makes accessing the fields easier and more consistent. These include &lt;code&gt;OP()&lt;/code&gt; , which is used to determine the type of a &lt;code&gt;regnode&lt;/code&gt; -like structure; &lt;code&gt;NEXT_OFF()&lt;/code&gt; , which is the offset to the next node (more on this later); &lt;code&gt;ARG()&lt;/code&gt; , &lt;code&gt;ARG1()&lt;/code&gt; , &lt;code&gt;ARG2()&lt;/code&gt; , &lt;code&gt;ARG_SET()&lt;/code&gt; , and equivalents for reading and setting the arguments; and &lt;code&gt;STR_LEN()&lt;/code&gt; , &lt;code&gt;STRING()&lt;/code&gt; and &lt;code&gt;OPERAND()&lt;/code&gt; for manipulating strings and regop bearing types.</source>
          <target state="translated">매크로 세트를 사용하면 필드에보다 쉽고 일관성있게 액세스 할 수 있습니다. 여기에는 &lt;code&gt;regnode&lt;/code&gt; 형 구조 의 유형을 결정하는 데 사용되는 &lt;code&gt;OP()&lt;/code&gt; 가 포함됩니다 . 다음 노드에 대한 오프셋 인 &lt;code&gt;NEXT_OFF()&lt;/code&gt; ). &lt;code&gt;ARG()&lt;/code&gt; , &lt;code&gt;ARG1()&lt;/code&gt; , &lt;code&gt;ARG2()&lt;/code&gt; , &lt;code&gt;ARG_SET()&lt;/code&gt; 및 인수를 읽고 설정하는 등가물; 및 &lt;code&gt;STR_LEN()&lt;/code&gt; , &lt;code&gt;STRING()&lt;/code&gt; 및 &lt;code&gt;OPERAND()&lt;/code&gt; 조작 문자열 및 regop 베어링 타입.</target>
        </trans-unit>
        <trans-unit id="5b89ed012267a41a30013b79a6117c49ce7fdacf" translate="yes" xml:space="preserve">
          <source>A set of possible values, together with all the operations that know how to deal with those values. For example, a numeric data type has a certain set of numbers that you can work with, as well as various mathematical operations that you can do on the numbers, but would make little sense on, say, a string such as &lt;code&gt;&quot;Kilroy&quot;&lt;/code&gt; . Strings have their own operations, such as &lt;b&gt;concatenation&lt;/b&gt;. Compound types made of a number of smaller pieces generally have operations to compose and decompose them, and perhaps to rearrange them. &lt;b&gt;Objects&lt;/b&gt; that model things in the real world often have operations that correspond to real activities. For instance, if you model an elevator, your elevator object might have an &lt;code&gt;open_door&lt;/code&gt;&lt;b&gt;method&lt;/b&gt;.</source>
          <target state="translated">해당 값을 처리하는 방법을 알고있는 모든 작업과 함께 가능한 값 집합입니다. 예를 들어, 숫자 데이터 유형에는 작업 할 수있는 특정 숫자 세트와 숫자에 대해 수행 할 수있는 다양한 수학 연산이 있지만 &lt;code&gt;&quot;Kilroy&quot;&lt;/code&gt; 와 같은 문자열에는 의미가 없습니다 . 문자열에는 &lt;b&gt;concatenation&lt;/b&gt; 과 같은 자체 연산이 있습니다. 다수의 더 작은 조각들로 이루어진 화합물 유형은 일반적으로 이들을 구성 및 분해하고, 아마도 그것들을 재배 열하는 조작을 갖는다. 현실 세계에서 &lt;b&gt;사물&lt;/b&gt; 을 모델링하는 &lt;b&gt;객체&lt;/b&gt; 에는 종종 실제 활동에 해당하는 작업이 있습니다. 예를 들어 엘리베이터를 모델링하는 경우 엘리베이터 객체에 &lt;code&gt;open_door&lt;/code&gt; &lt;b&gt;메서드&lt;/b&gt; 가있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="af57cf3203f1cd3e2de0a1965dff9d274c21ca2b" translate="yes" xml:space="preserve">
          <source>A set of related data values in a &lt;b&gt;file&lt;/b&gt; or &lt;b&gt;stream&lt;/b&gt;, often associated with a unique &lt;b&gt;key&lt;/b&gt; field. In Unix, often commensurate with a &lt;b&gt;line&lt;/b&gt;, or a blank-line&amp;ndash;terminated set of lines (a &amp;ldquo;paragraph&amp;rdquo;). Each line of the</source>
          <target state="translated">종종 고유 &lt;b&gt;키&lt;/b&gt; 필드 와 연관된 &lt;b&gt;파일&lt;/b&gt; 또는 &lt;b&gt;스트림&lt;/b&gt; 의 관련 데이터 값 세트입니다 . 유닉스에서는 종종 &lt;b&gt;line&lt;/b&gt; 또는 빈 줄로 끝나는 줄 (&amp;ldquo;문단&amp;rdquo;)에 비례 합니다. 의 각 줄&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1e3ce769bdcb624305623c0e39fad86b6550d415" translate="yes" xml:space="preserve">
          <source>A set of users of which you are a member. In some operating systems (like Unix), you can give certain file access permissions to other members of your group.</source>
          <target state="translated">귀하가 회원 인 일련의 사용자. 일부 운영 체제 (예 : Unix)에서는 그룹의 다른 구성원에게 특정 파일 액세스 권한을 부여 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3f080c404572d6a66e864a2fec8d37666d88fa5" translate="yes" xml:space="preserve">
          <source>A set of version requirements for a CPAN dist</source>
          <target state="translated">CPAN dist에 대한 버전 요구 사항 세트</target>
        </trans-unit>
        <trans-unit id="a023ae4922155fc45ad5e15036082f2112e5376d" translate="yes" xml:space="preserve">
          <source>A seven-bit safe (non-eight-bit) encoding, which is useful if the transport or storage is not eight-bit safe. Defined by RFC 2152.</source>
          <target state="translated">전송 또는 저장이 8 비트 안전하지 않은 경우에 유용한 7 비트 안전 (8 비트가 아닌) 인코딩입니다. RFC 2152에 의해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="a600cb53b0fe3c2106640728c33066b8be46fd29" translate="yes" xml:space="preserve">
          <source>A short description of the function of the op.</source>
          <target state="translated">op의 기능에 대한 간단한 설명.</target>
        </trans-unit>
        <trans-unit id="d96648e3b3628e3e472e306b3dd3028622349739" translate="yes" xml:space="preserve">
          <source>A short description of your module, what it does, why someone would use it and its limitations. CPAN automatically pulls your README file out of the archive and makes it available to CPAN users, it is the first thing they will read to decide if your module is right for them.</source>
          <target state="translated">모듈에 대한 간단한 설명, 기능, 누군가 모듈을 사용하는 이유 및 제한 사항. CPAN은 자동으로 README 파일을 아카이브에서 가져와 CPAN 사용자가 사용할 수 있도록합니다. 모듈이 자신에게 적합한 지 결정하기 위해 가장 먼저 읽어야 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="7054451d8531a19f5986333d608566f0e421b059" translate="yes" xml:space="preserve">
          <source>A short name for your op. This will be included in some error messages, and will also be returned as &lt;code&gt;$op-&amp;gt;name&lt;/code&gt; by the &lt;a href=&quot;b&quot;&gt;B&lt;/a&gt; module, so it will appear in the output of module like &lt;a href=&quot;b/concise&quot;&gt;B::Concise&lt;/a&gt;.</source>
          <target state="translated">작전의 짧은 이름입니다. 이것은 일부 오류 메시지에 포함되며 &lt;a href=&quot;b&quot;&gt;B&lt;/a&gt; 모듈에 의해 &lt;code&gt;$op-&amp;gt;name&lt;/code&gt; 으로 반환 되므로 &lt;a href=&quot;b/concise&quot;&gt;B :: Concise&lt;/a&gt; 와 같은 모듈의 출력에 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="659172f97956f35000461e8175c3ae20d404aec4" translate="yes" xml:space="preserve">
          <source>A short usage summary for programs and functions. This section is mandatory for section 3 pages. For Perl module documentation, it's usually convenient to have the contents of this section be a verbatim block showing some (brief) examples of typical ways the module is used.</source>
          <target state="translated">프로그램 및 기능에 대한 간단한 사용법 요약. 이 섹션은 섹션 3 페이지에 필수적입니다. Perl 모듈 문서의 경우, 일반적으로이 섹션의 내용을 모듈이 사용되는 일반적인 방법의 일부 (간략한) 예를 보여주는 축약 형 블록으로 만드는 것이 편리합니다.</target>
        </trans-unit>
        <trans-unit id="ecd576fa5b368299ace3b5dd153caef33335850b" translate="yes" xml:space="preserve">
          <source>A shortcut for $token-&amp;gt;tagname(...)</source>
          <target state="translated">$ token-&amp;gt; tagname (...)의 단축키</target>
        </trans-unit>
        <trans-unit id="889d9060f1528398717f26dcafe44f09ac88a287" translate="yes" xml:space="preserve">
          <source>A shortcut to return Math::BigInt-&amp;gt;binf(). Useful because Perl does not always handle bareword &lt;code&gt;inf&lt;/code&gt; properly.</source>
          <target state="translated">Math :: BigInt-&amp;gt; binf ()를 반환하는 바로 가기입니다. 펄은 항상 bareword는 처리하지 못하기 때문에 유용한 &lt;code&gt;inf&lt;/code&gt; 제대로.</target>
        </trans-unit>
        <trans-unit id="c597d44b686300cfd664e15765135328081ac79a" translate="yes" xml:space="preserve">
          <source>A shortcut to return Math::BigInt-&amp;gt;bnan(). Useful because Perl does not always handle bareword &lt;code&gt;NaN&lt;/code&gt; properly.</source>
          <target state="translated">Math :: BigInt-&amp;gt; bnan ()을 반환하는 바로 가기입니다. Perl이 베어 워드 &lt;code&gt;NaN&lt;/code&gt; 을 항상 올바르게 처리하지는 않기 때문에 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="4c2bf7bb028dd860429a797ea74f61d6f6006cc5" translate="yes" xml:space="preserve">
          <source>A side effect of this representation is that you can use &lt;code&gt;eq&lt;/code&gt; to see if two references refer to the same thing. (But you should usually use &lt;code&gt;==&lt;/code&gt; instead because it's much faster.)</source>
          <target state="translated">이 표현의 부작용은 &lt;code&gt;eq&lt;/code&gt; 를 사용 하여 두 참조가 동일한 것을 참조하는지 확인할 수 있다는 것입니다. (하지만 훨씬 빠르기 때문에 보통 &lt;code&gt;==&lt;/code&gt; 를 사용해야합니다 .)</target>
        </trans-unit>
        <trans-unit id="521c212b6a17d7bb672fae4188d350c73713a7f4" translate="yes" xml:space="preserve">
          <source>A sigil followed by a single character matching the &lt;code&gt;\p{POSIX_Punct}&lt;/code&gt; property, like &lt;code&gt;$!&lt;/code&gt; or &lt;code&gt;%+&lt;/code&gt; , except the character &lt;code&gt;&quot;{&quot;&lt;/code&gt; doesn't work.</source>
          <target state="translated">&lt;code&gt;$!&lt;/code&gt; 와 같이 &lt;code&gt;\p{POSIX_Punct}&lt;/code&gt; 속성과 일치하는 단일 문자가 뒤 따릅니다 . 문자 &lt;code&gt;&quot;{&quot;&lt;/code&gt; 를 제외한 &lt;code&gt;%+&lt;/code&gt; 또는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2cc8d7ea546cfbfc32e7048bc99953161b5c5af3" translate="yes" xml:space="preserve">
          <source>A sigil, followed by either a caret and a single POSIX uppercase letter, like &lt;code&gt;$^V&lt;/code&gt; or &lt;code&gt;$^W&lt;/code&gt; , or a sigil followed by a literal non-space, non-&lt;code&gt;NUL&lt;/code&gt; control character matching the &lt;code&gt;\p{POSIX_Cntrl}&lt;/code&gt; property. Due to a historical oddity, if not running under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; , the 128 characters in the &lt;code&gt;[0x80-0xff]&lt;/code&gt; range are considered to be controls, and may also be used in length-one variables. However, the use of non-graphical characters is deprecated as of v5.22, and support for them will be removed in a future version of perl. ASCII space characters and &lt;code&gt;NUL&lt;/code&gt; already aren't allowed, so this means that a single-character variable name with that name being any other C0 control &lt;code&gt;[0x01-0x1F]&lt;/code&gt; , or &lt;code&gt;DEL&lt;/code&gt; will generate a deprecated warning. Already, under &lt;code&gt;&quot;use
utf8&quot;&lt;/code&gt; , non-ASCII characters must match &lt;code&gt;Perl_XIDS&lt;/code&gt; . As of v5.22, when not under &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt; C1 controls &lt;code&gt;[0x80-0x9F]&lt;/code&gt; , NO BREAK SPACE, and SOFT HYPHEN (&lt;code&gt;SHY&lt;/code&gt; )) generate a deprecated warning.</source>
          <target state="translated">캐럿 뒤에 &lt;code&gt;$^V&lt;/code&gt; 또는 &lt;code&gt;$^W&lt;/code&gt; 와 같은 캐럿 및 단일 POSIX 대문자 또는 &lt;code&gt;\p{POSIX_Cntrl}&lt;/code&gt; 속성과 일치 하는 문자가 아닌 공백이 아닌 &lt;code&gt;NUL&lt;/code&gt; 제어 문자가 뒤에 오는 sigil . 역사적 이상으로 인해 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용시&lt;/a&gt; 실행되지 않는 경우 &lt;code&gt;[0x80-0xff]&lt;/code&gt; 범위 의 128 자는 제어로 간주되며 길이가 1 인 변수에도 사용될 수 있습니다. 그러나 비 그래픽 문자의 사용은 v5.22부터 더 이상 사용되지 않으며 이후 버전의 perl에서 지원되지 않습니다. ASCII 공백 문자 및 &lt;code&gt;NUL&lt;/code&gt; 이미 허용되지 않으므로 이는 해당 이름을 가진 단일 문자 변수 이름이 다른 C0 제어 &lt;code&gt;[0x01-0x1F]&lt;/code&gt; 또는 &lt;code&gt;DEL&lt;/code&gt; 에서 사용되지 않는 경고를 생성 함을 의미합니다. 이미 &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt; 에서 비 ASCII 문자는 &lt;code&gt;Perl_XIDS&lt;/code&gt; 와 일치해야합니다 . v5.22부터 &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt; 아닌 경우 C1 제어 &lt;code&gt;[0x80-0x9F]&lt;/code&gt; , NO BREAK SPACE 및 SOHY HYPHEN ( &lt;code&gt;SHY&lt;/code&gt; )은 더 이상 사용되지 않는 경고를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="25c7b41e2f3083fca5663c24cdf9d0f7721da4bb" translate="yes" xml:space="preserve">
          <source>A sigil, followed solely by digits matching &lt;code&gt;\p{POSIX_Digit}&lt;/code&gt; , like &lt;code&gt;$0&lt;/code&gt; , &lt;code&gt;$1&lt;/code&gt; , or &lt;code&gt;$10000&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$0&lt;/code&gt; , &lt;code&gt;$1&lt;/code&gt; 또는 &lt;code&gt;$10000&lt;/code&gt; 과 같이 &lt;code&gt;\p{POSIX_Digit}&lt;/code&gt; 와 일치하는 숫자 만 뒤에 오는시길 .</target>
        </trans-unit>
        <trans-unit id="c803de64703554f9c3355b0bb0b711df0025cdae" translate="yes" xml:space="preserve">
          <source>A sign of 'NaN' is used to represent the result when input arguments are not numbers or as a result of 0/0. '+inf' and '-inf' represent plus respectively minus infinity. You will get '+inf' when dividing a positive number by 0, and '-inf' when dividing any negative number by 0.</source>
          <target state="translated">'NaN'의 부호는 입력 인수가 숫자가 아니거나 0/0의 결과 인 경우 결과를 나타내는 데 사용됩니다. '+ inf'및 '-inf'는 플러스 마이너스 무한대를 나타냅니다. 양수를 0으로 나누면 '+ inf', 음수를 0으로 나누면 '-inf'가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="acfa2fff17c2c760f059166beff68ca97cf27024" translate="yes" xml:space="preserve">
          <source>A signature may be entirely empty, in which case all it does is check that the caller passed no arguments:</source>
          <target state="translated">서명이 완전히 비어있을 수 있습니다.이 경우 호출자가 인수를 전달하지 않았는지 확인하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a3b7bfaadf566cb42bb060b59ab39877bdce37fb" translate="yes" xml:space="preserve">
          <source>A signed integer. This is cast to the required integer type when passed to C and converted to an IV when passed back to Perl.</source>
          <target state="translated">부호있는 정수 이것은 C로 전달 될 때 필요한 정수 유형으로 캐스트되고 Perl로 다시 전달 될 때 IV로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="1575087c19c9eb3e9ca21e23f5fecff11363ecdb" translate="yes" xml:space="preserve">
          <source>A signed integer. This typemap converts the Perl value to a native integer type (the &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; type on the current platform). When returning the value to perl it is processed in the same way as for T_IV.</source>
          <target state="translated">부호있는 정수 이 유형 맵은 Perl 값을 기본 정수 유형 ( 현재 플랫폼 의 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 유형)으로 변환합니다. perl에 값을 리턴 할 때 T_IV와 동일한 방식으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="9a6e260265e056207c62a15cda251b7b04ab7de2" translate="yes" xml:space="preserve">
          <source>A significant number of the bug reports we get turn out to be documented features in Perl. Make sure the issue you've run into isn't intentional by glancing through the documentation that comes with the Perl distribution.</source>
          <target state="translated">우리가 얻는 많은 버그 보고서는 Perl에 문서화 된 기능으로 밝혀졌습니다. Perl 배포판과 함께 제공되는 설명서를 통해 문제가 의도하지 않은지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="80837079263cda7d0c48b62c5a2b8e0aa29ed989" translate="yes" xml:space="preserve">
          <source>A similar but more subtle problem is illustrated with this code:</source>
          <target state="translated">이 코드에는 비슷하지만 더 미묘한 문제가 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="81ab11bae0fce0f2612a231d95d1eecf127ccce2" translate="yes" xml:space="preserve">
          <source>A similar effect applies to</source>
          <target state="translated">비슷한 효과가 적용됩니다</target>
        </trans-unit>
        <trans-unit id="a23425aa80f51fe5db313d5664fb7ac8f4d286d0" translate="yes" xml:space="preserve">
          <source>A similar strategy would work for wildcard expansion via &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt;, although you can use &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; 을 대신 사용할 수 있지만 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 를 통한 와일드 카드 확장에 대해서도 비슷한 전략이 적용 됩니다.</target>
        </trans-unit>
        <trans-unit id="eb1349e3e7bc2ad99052d135eb76b4bea7da2dc2" translate="yes" xml:space="preserve">
          <source>A similar task is to find words consisting of two identical parts:</source>
          <target state="translated">비슷한 작업은 두 개의 동일한 부분으로 구성된 단어를 찾는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ee2213ceffd8c1f2a6f17c3aee8ab7cdf3d4092c" translate="yes" xml:space="preserve">
          <source>A similar trick involves the</source>
          <target state="translated">비슷한 트릭은</target>
        </trans-unit>
        <trans-unit id="8848997a2920d88084bbf780cebe39466ec879ee" translate="yes" xml:space="preserve">
          <source>A simple API to convert seconds to other date values</source>
          <target state="translated">초를 다른 날짜 값으로 변환하는 간단한 API</target>
        </trans-unit>
        <trans-unit id="c123404763bd10d42cf8e7c2eaf59ecc97ce202f" translate="yes" xml:space="preserve">
          <source>A simple boolean indicating if the command executed without errors or not.</source>
          <target state="translated">명령이 오류없이 실행되었는지 여부를 나타내는 간단한 부울입니다.</target>
        </trans-unit>
        <trans-unit id="5bd4089058361e948e8b28ab1128c297a0f82d9e" translate="yes" xml:space="preserve">
          <source>A simple call to &lt;code&gt;isnt()&lt;/code&gt; usually does not provide a strong test but there are cases when you cannot say much more about a value than that it is different from some other value:</source>
          <target state="translated">&lt;code&gt;isnt()&lt;/code&gt; 대한 간단한 호출은 일반적으로 강력한 테스트를 제공하지 않지만 다른 값과 다른 값보다 더 많은 값을 말할 수없는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fbcc760723f31ac561f9cef482138111eb6931b" translate="yes" xml:space="preserve">
          <source>A simple checking routine, which will return true if &lt;code&gt;Archive::Tar&lt;/code&gt; is able to uncompress compressed archives on the fly with &lt;code&gt;IO::Zlib&lt;/code&gt; and &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; or false if not both are installed.</source>
          <target state="translated">간단한 검사 루틴 &lt;code&gt;Archive::Tar&lt;/code&gt; 가 &lt;code&gt;IO::Zlib&lt;/code&gt; 및 &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; 를 사용하여 압축 된 아카이브를 압축 해제 할 수있는 경우 true를 리턴 하고 둘 다 설치되지 않은 경우 false 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="afc5b3faec4a3f9f01b28a9e7d12132d66ab6e1d" translate="yes" xml:space="preserve">
          <source>A simple listing of all the files in your distribution.</source>
          <target state="translated">배포판에있는 모든 파일의 간단한 목록입니다.</target>
        </trans-unit>
        <trans-unit id="372959c464065982896bbbe2c2818eb6cad5f8a5" translate="yes" xml:space="preserve">
          <source>A simple mapping of the op type number to its type (like 'COP' or 'BINOP').</source>
          <target state="translated">연산 유형 번호를 해당 유형에 간단히 매핑 (예 : 'COP'또는 'BINOP').</target>
        </trans-unit>
        <trans-unit id="d472680931a17874166dba160d7f69e6352eb56b" translate="yes" xml:space="preserve">
          <source>A simple read-only accessor simply gets the value of a single attribute:</source>
          <target state="translated">간단한 읽기 전용 접근자는 단순히 단일 속성의 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="681ff201b3498a43f7a62245e78650fd37d86b77" translate="yes" xml:space="preserve">
          <source>A simple scalar number</source>
          <target state="translated">간단한 스칼라 숫자</target>
        </trans-unit>
        <trans-unit id="1b93dcb8f21d326777ddc52bfa4bdd011dd04c4a" translate="yes" xml:space="preserve">
          <source>A simple scalar string</source>
          <target state="translated">간단한 스칼라 문자열</target>
        </trans-unit>
        <trans-unit id="5776d9f23e070178afac4296b05b65fd1f748404" translate="yes" xml:space="preserve">
          <source>A simple scalar with an extra reference</source>
          <target state="translated">추가 참조가있는 간단한 스칼라</target>
        </trans-unit>
        <trans-unit id="f593aa1a652c40c9b2c700bcf9bdc1dacfbe433a" translate="yes" xml:space="preserve">
          <source>A simple summary of the tests so far. True for pass, false for fail. This is a logical pass/fail, so todos are passes.</source>
          <target state="translated">지금까지 테스트에 대한 간단한 요약. 통과하면 true, 실패하면 false 이것은 논리적 합격 / 불합격이므로 할일은 합격입니다.</target>
        </trans-unit>
        <trans-unit id="e9ed86741cb6e707485ef431b1b242bee25c8fe1" translate="yes" xml:space="preserve">
          <source>A simple, singular value; a number, &lt;b&gt;string&lt;/b&gt;, or &lt;b&gt;reference&lt;/b&gt;.</source>
          <target state="translated">단순하고 특이한 가치; 숫자 &lt;b&gt;스트링&lt;/b&gt; 또는 &lt;b&gt;참조&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="5a7d12449647b7d47425008bd7d9de56b3bffa22" translate="yes" xml:space="preserve">
          <source>A single character that represents the end of a line, with the ASCII value of 012 octal under Unix (but 015 on a Mac), and represented by &lt;code&gt;\n&lt;/code&gt; in Perl strings. For Windows machines writing text files, and for certain physical devices like terminals, the single newline gets automatically translated by your C library into a line feed and a carriage return, but normally, no translation is done.</source>
          <target state="translated">Unix에서 ASCII 값이 012 8 진수 (Mac에서는 015) 인 행의 끝을 나타내는 단일 문자 이며 Perl 문자열에서 &lt;code&gt;\n&lt;/code&gt; 으로 표시됩니다 . 텍스트 파일을 작성하는 Windows 시스템과 터미널과 같은 특정 물리적 장치의 경우 단일 개행은 C 라이브러리에서 자동으로 줄 바꿈 및 캐리지 리턴으로 변환되지만 일반적으로 변환은 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2a1618c928b45217b1ecfab89b72e2f9c62e981a" translate="yes" xml:space="preserve">
          <source>A single entity with various interpretations, like an elephant. To a computer scientist, it&amp;rsquo;s a grammar for a little language in which some strings are legal and others aren&amp;rsquo;t. To normal people, it&amp;rsquo;s a pattern you can use to find what you&amp;rsquo;re looking for when it varies from case to case. Perl&amp;rsquo;s regular expressions are far from regular in the theoretical sense, but in regular use they work quite well. Here&amp;rsquo;s a regular expression: &lt;code&gt;/Oh s.*t./&lt;/code&gt; . This will match strings like &amp;ldquo;&lt;code&gt;Oh &lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt; can you see by the dawn's early light&lt;/code&gt; &amp;rdquo; and &amp;ldquo;&lt;code&gt;Oh sit!&lt;/code&gt; &amp;rdquo;. See Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo;.</source>
          <target state="translated">코끼리처럼 다양한 해석이 가능한 단일 개체입니다. 컴퓨터 과학자에게는 일부 문자열이 합법적이고 다른 문자열이 합법적이지 않은 작은 언어에 대한 문법입니다. 정상적인 사람들에게, 그것은 당신이 찾고있는 것이 무엇인지를 찾는 데 사용할 수있는 패턴입니다. Perl의 정규 표현식은 이론적 인 의미에서 정규 표현식과는 거리가 멀지 만 정기적으로 사용하면 상당히 잘 작동합니다. 정규식은 다음과 같습니다. &lt;code&gt;/Oh s.*t./&lt;/code&gt; . 이것은 &quot;와 같은 문자열을 일치 &lt;code&gt;Oh &lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt; can you see by the dawn's early light&lt;/code&gt; &quot;와 &quot; &lt;code&gt;Oh sit!&lt;/code&gt; &amp;rdquo;. 낙타 5 장 &quot;패턴 일치&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="829152f3dcb1ed16bfc3e8ca36bfa63ebf05d7eb" translate="yes" xml:space="preserve">
          <source>A single hexadecimal number denoting a code point to include.</source>
          <target state="translated">포함 할 코드 포인트를 나타내는 단일 16 진수입니다.</target>
        </trans-unit>
        <trans-unit id="27a4bf6aaf65d7e6150de844a569f0f9a5f667a4" translate="yes" xml:space="preserve">
          <source>A single piece of numeric or string data that is part of a longer &lt;b&gt;string&lt;/b&gt;, &lt;b&gt;record&lt;/b&gt;, or &lt;b&gt;line&lt;/b&gt;. Variable-width fields are usually split up by &lt;b&gt;separators&lt;/b&gt; (so use &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; to extract the fields), while fixed-width fields are usually at fixed positions (so use &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;). &lt;b&gt;Instance variables&lt;/b&gt; are also known as &amp;ldquo;fields&amp;rdquo;.</source>
          <target state="translated">더 긴 &lt;b&gt;문자열&lt;/b&gt; , &lt;b&gt;레코드&lt;/b&gt; 또는 &lt;b&gt;행의&lt;/b&gt; 일부인 단일 숫자 또는 문자열 데이터입니다 . 가변 너비 필드는 일반적으로 &lt;b&gt;구분 기호로 &lt;/b&gt; &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 되므로 필드를 추출 하려면 split 을 사용하십시오. 반면 고정 너비 필드는 일반적으로 고정 위치에 있습니다 ( &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 사용 ). &lt;b&gt;인스턴스 변수&lt;/b&gt; 는 &quot;필드&quot;라고도합니다.</target>
        </trans-unit>
        <trans-unit id="3ff4db73bde7c1d7cfd3e2062dd1951912b9e366" translate="yes" xml:space="preserve">
          <source>A single symbol abbreviating the class of the OP.</source>
          <target state="translated">OP 클래스를 약칭하는 단일 기호.</target>
        </trans-unit>
        <trans-unit id="ed641668fea177eedad336e7089851d18b828e16" translate="yes" xml:space="preserve">
          <source>A single testing job.</source>
          <target state="translated">단일 테스트 작업.</target>
        </trans-unit>
        <trans-unit id="41bf4051bfbbef3d6c2986f2065087b05c2359b5" translate="yes" xml:space="preserve">
          <source>A single-quoted, literal string. A backslash represents a backslash unless followed by the delimiter or another backslash, in which case the delimiter or backslash is interpolated.</source>
          <target state="translated">작은 따옴표로 묶인 리터럴 문자열. 백 슬래시는 분리 문자 나 다른 백 슬래시가 뒤 따르지 않는 한 백 슬래시를 나타냅니다.이 경우 분리 문자 나 백 슬래시는 보간됩니다.</target>
        </trans-unit>
        <trans-unit id="8add36465a616cf6d47e4a5aef01fb690927c1f3" translate="yes" xml:space="preserve">
          <source>A slice accesses several elements of a list, an array, or a hash simultaneously using a list of subscripts. It's more convenient than writing out the individual elements as a list of separate scalar values.</source>
          <target state="translated">슬라이스는 아래 첨자 목록을 사용하여 목록, 배열 또는 해시의 여러 요소에 동시에 액세스합니다. 개별 요소를 별도의 스칼라 값 목록으로 작성하는 것보다 편리합니다.</target>
        </trans-unit>
        <trans-unit id="7f8a4967d94ac75566470d147a5f123047048bbb" translate="yes" xml:space="preserve">
          <source>A slight modification also removes C++ comments, possibly spanning multiple lines using a continuation character:</source>
          <target state="translated">약간만 수정하면 C ++ 주석이 제거되어 연속 문자를 사용하여 여러 줄에 걸쳐있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e99cb7094afcbc76a76c4efa1f4eefdffe5bff51" translate="yes" xml:space="preserve">
          <source>A slightly larger piece of code will provide something on which a profiler can produce more extensive reporting statistics. This example uses the simplistic &lt;code&gt;wordmatch&lt;/code&gt; program which parses a given input file and spews out a short report on the contents.</source>
          <target state="translated">약간 더 큰 코드는 프로파일 러가보다 광범위한보고 통계를 생성 할 수있는 무언가를 제공합니다. 이 예에서는 주어진 입력 파일을 구문 분석하고 내용에 대한 간단한 보고서를 생성하는 간단한 &lt;code&gt;wordmatch&lt;/code&gt; 프로그램을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="03934c7f98da92e385e9ea42d12c3ed3bec3632f" translate="yes" xml:space="preserve">
          <source>A slurpy hash parameter may be nameless just like other kinds of parameter. It still insists that the number of arguments available to it be even, even though they're not being put into a variable.</source>
          <target state="translated">슬러 피 해시 파라미터는 다른 종류의 파라미터와 마찬가지로 이름이 없을 수 있습니다. 변수에 넣지 않아도 사용할 수있는 인수의 수는 여전히 균등하다고 주장합니다.</target>
        </trans-unit>
        <trans-unit id="30988eefa9eacb81270153c8608fad35b31b7f98" translate="yes" xml:space="preserve">
          <source>A slurpy parameter may instead be a hash, in which case the arguments available to it are interpreted as alternating keys and values. There must be as many keys as values: if there is an odd argument then an exception will be thrown. Keys will be stringified, and if there are duplicates then the later instance takes precedence over the earlier, as with standard hash construction.</source>
          <target state="translated">slurpy 매개 변수는 대신 해시 일 수 있으며,이 경우 사용 가능한 인수는 대체 키와 값으로 해석됩니다. 값만큼의 키가 있어야합니다. 홀수 인수가 있으면 예외가 발생합니다. 키가 문자열 화되고 중복이있는 경우 표준 해시 구성에서와 같이 이후 인스턴스가 이전 인스턴스보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="76d8ab783e8ae2210ac2fb7506feb3637ad91b4b" translate="yes" xml:space="preserve">
          <source>A slurpy parameter, either array or hash, must be the last thing in the signature. It may follow mandatory and optional positional parameters; it may also be the only thing in the signature. Slurpy parameters cannot have default values: if no arguments are supplied for them then you get an empty array or empty hash.</source>
          <target state="translated">시그니처의 마지막 항목은 배열 또는 해시 중 하나입니다. 필수 및 선택적 위치 매개 변수를 따를 수 있습니다. 서명에서 유일한 것일 수도 있습니다. Slurpy 매개 변수는 기본값을 가질 수 없습니다. 인수가 제공되지 않으면 빈 배열 또는 빈 해시를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="c7ed55a78ba712132c2ae6c86e583e8efc503821" translate="yes" xml:space="preserve">
          <source>A small example demonstrating SysV message queues:</source>
          <target state="translated">SysV 메시지 큐를 보여주는 작은 예 :</target>
        </trans-unit>
        <trans-unit id="b0014acccc6b5556fca51e530830260283cc77d0" translate="yes" xml:space="preserve">
          <source>A small script which yields the problem will probably be of help. It would also be useful if this script was run with the extra options &lt;code&gt;Debug =&lt;/code&gt; 1&amp;gt; passed to the constructor, and the output sent with the bug report. If you cannot include a small script then please include a Debug trace from a run of your program which does yield the problem.</source>
          <target state="translated">문제를 일으키는 작은 스크립트가 도움이 될 것입니다. 이 스크립트가 생성자에게 전달 된 추가 옵션 &lt;code&gt;Debug =&lt;/code&gt; 1&amp;gt; 과 함께 실행되고 출력이 버그 보고서와 함께 전송 된 경우에도 유용합니다 . 작은 스크립트를 포함시킬 수 없으면 프로그램 실행에서 디버그 추적을 포함시켜 문제를 발생 시키십시오.</target>
        </trans-unit>
        <trans-unit id="c165dd6d48bb6848a9c96904378fd915f9518c69" translate="yes" xml:space="preserve">
          <source>A small, simple, correct HTTP/1.1 client</source>
          <target state="translated">작고 간단한 올바른 HTTP / 1.1 클라이언트</target>
        </trans-unit>
        <trans-unit id="27545b929364aeeb83be800c720a5090d4d35630" translate="yes" xml:space="preserve">
          <source>A smart match that uses an explicit &lt;code&gt;~~&lt;/code&gt; operator, such as &lt;code&gt;EXPR ~~ EXPR&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;EXPR ~~ EXPR&lt;/code&gt; 과 같은 명시 적 &lt;code&gt;~~&lt;/code&gt; 연산자 를 사용하는 스마트 일치입니다 .</target>
        </trans-unit>
        <trans-unit id="5ee7049b5826d72a2f103072d053d50784d7d0da" translate="yes" xml:space="preserve">
          <source>A sneaky &lt;code&gt;LC_COLLATE&lt;/code&gt; locale could result in the names of students with &quot;D&quot; grades appearing ahead of those with &quot;A&quot;s.</source>
          <target state="translated">몰래 &lt;code&gt;LC_COLLATE&lt;/code&gt; 로캘로 인해 &quot;D&quot;등급의 학생 이름이 &quot;A&quot;등급의 학생보다 먼저 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bd3117b0bc435a9ddefeeeda5fe0b0754edfcc4" translate="yes" xml:space="preserve">
          <source>A solution to this is to use a library which uses pseudottys to make your program behave more reasonably. This way you don't have to have control over the source code of the program you're using. The &lt;code&gt;Expect&lt;/code&gt; module from CPAN also addresses this kind of thing. This module requires two other modules from CPAN, &lt;code&gt;IO::Pty&lt;/code&gt; and &lt;code&gt;IO::Stty&lt;/code&gt; . It sets up a pseudo terminal to interact with programs that insist on talking to the terminal device driver. If your system is supported, this may be your best bet.</source>
          <target state="translated">이에 대한 해결책은 의사를 사용하여 프로그램을보다 합리적으로 동작시키는 라이브러리를 사용하는 것입니다. 이렇게하면 사용중인 프로그램의 소스 코드를 제어 할 필요가 없습니다. CPAN 의 &lt;code&gt;Expect&lt;/code&gt; 모듈도 이러한 종류의 문제를 해결합니다. 이 모듈에는 CPAN의 다른 두 모듈 인 &lt;code&gt;IO::Pty&lt;/code&gt; 및 &lt;code&gt;IO::Stty&lt;/code&gt; 합니다. 터미널 장치 드라이버와 통신해야하는 프로그램과 상호 작용하도록 의사 터미널을 설정합니다. 시스템이 지원되는 경우 가장 좋은 방법 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b80c1598a0b057abd1403fd2b9a7dc757cff1ce" translate="yes" xml:space="preserve">
          <source>A source filter is a special kind of Perl module that intercepts and modifies a source stream before it reaches the parser. A source filter changes our diagram like this:</source>
          <target state="translated">소스 필터는 파서에 도달하기 전에 소스 스트림을 가로 채고 수정하는 특수한 종류의 Perl 모듈입니다. 소스 필터는 다음과 같이 다이어그램을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="8b0be58db42e648ec049b8d1ddee43ac5d107082" translate="yes" xml:space="preserve">
          <source>A space (or colon) separated list of PerlIO layers. If perl is built to use PerlIO system for IO (the default) these layers affect Perl's IO.</source>
          <target state="translated">공백 (또는 콜론)으로 구분 된 PerlIO 레이어 목록입니다. perl이 IO (기본값)에 PerlIO 시스템을 사용하도록 빌드 된 경우 이러한 계층은 Perl의 IO에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="0badf9ed68d3af0c4f3cd1c0a7af9f9020afc01b" translate="yes" xml:space="preserve">
          <source>A special &lt;b&gt;method&lt;/b&gt; that is called when an &lt;b&gt;object&lt;/b&gt; is thinking about &lt;b&gt;destroying&lt;/b&gt; itself. A Perl program&amp;rsquo;s &lt;code&gt;DESTROY&lt;/code&gt; method doesn&amp;rsquo;t do the actual destruction; Perl just &lt;b&gt;triggers&lt;/b&gt; the method in case the &lt;b&gt;class&lt;/b&gt; wants to do any associated cleanup.</source>
          <target state="translated">&lt;b&gt;객체&lt;/b&gt; 가 자신을 &lt;b&gt;파괴&lt;/b&gt; 하려고 생각할 때 호출 되는 특수 &lt;b&gt;메소드&lt;/b&gt; 입니다 . Perl 프로그램의 &lt;code&gt;DESTROY&lt;/code&gt; 메소드는 실제 파괴를 수행하지 않습니다. Perl 은 &lt;b&gt;클래스&lt;/b&gt; 가 연관된 정리를 수행하려는 경우 메소드를 &lt;b&gt;트리거&lt;/b&gt; 합니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ef35c437c5c84fa1b46b5dc38d46f6fde11ec243" translate="yes" xml:space="preserve">
          <source>A special case is if the expression is a subroutine reference (in either &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {...}&lt;/code&gt; syntax or &lt;code&gt;\&amp;amp;foo&lt;/code&gt; syntax). In that case, it is executed and its value (true or false) determines if the test passes or fails. For example,</source>
          <target state="translated">특별한 경우는 표현식이 서브 루틴 참조 인 경우입니다 ( &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {...}&lt;/code&gt; 구문 또는 &lt;code&gt;\&amp;amp;foo&lt;/code&gt; 구문). 이 경우 테스트가 실행되고 해당 값 (true 또는 false)에 따라 테스트 통과 또는 실패 여부가 결정됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="4d4bdb3b56feee845f988c80b59a2de393b4d25c" translate="yes" xml:space="preserve">
          <source>A special entry &lt;code&gt;GetOptionsFromString&lt;/code&gt; can be used to parse options from an arbitrary string.</source>
          <target state="translated">특수한 항목 &lt;code&gt;GetOptionsFromString&lt;/code&gt; 을 사용하여 임의의 문자열에서 옵션을 구문 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5f25c2de52c4c00b53b25ba03c614f087fa031c" translate="yes" xml:space="preserve">
          <source>A special file that contains other files. Some &lt;b&gt;operating systems&lt;/b&gt; call these &amp;ldquo;folders&amp;rdquo;, &amp;ldquo;drawers&amp;rdquo;, &amp;ldquo;catalogues&amp;rdquo;, or &amp;ldquo;catalogs&amp;rdquo;.</source>
          <target state="translated">다른 파일을 포함하는 특수 파일. 일부 &lt;b&gt;운영 체제에서는&lt;/b&gt; 이러한 &quot;폴더&quot;, &quot;서랍&quot;, &quot;카탈로그&quot;또는 &quot;카탈로그&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="9d4dee1bf51d9988b7b651c7e34b5ae56c3d23f3" translate="yes" xml:space="preserve">
          <source>A special form is the &lt;code&gt;(DEFINE)&lt;/code&gt; predicate, which never executes its yes-pattern directly, and does not allow a no-pattern. This allows one to define subpatterns which will be executed only by the recursion mechanism. This way, you can define a set of regular expression rules that can be bundled into any pattern you choose.</source>
          <target state="translated">특수 형식은 &lt;code&gt;(DEFINE)&lt;/code&gt; 술어입니다.이 술어는 yes 패턴을 직접 실행하지 않으며 패턴을 허용하지 않습니다. 이를 통해 재귀 메커니즘에 의해서만 실행될 서브 패턴을 정의 할 수 있습니다. 이렇게하면 선택한 패턴에 묶을 수있는 정규식 규칙 집합을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="098ae82dbb47389fd0f04911d56700422f9e1bbd" translate="yes" xml:space="preserve">
          <source>A special internal spot in which Perl keeps the information about the last &lt;b&gt;file&lt;/b&gt; on which you requested information.</source>
          <target state="translated">Perl이 정보 를 요청한 마지막 &lt;b&gt;파일&lt;/b&gt; 에 대한 정보를 보관하는 특별한 내부 지점입니다 .</target>
        </trans-unit>
        <trans-unit id="79eddc4100fb4306d07fc838a90fb71a102a9485" translate="yes" xml:space="preserve">
          <source>A special kind of &lt;b&gt;module&lt;/b&gt; that does &lt;b&gt;preprocessing&lt;/b&gt; on your script just before it gets to the &lt;b&gt;tokener&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;토큰에&lt;/b&gt; 도달하기 직전에 스크립트에서 &lt;b&gt;전처리&lt;/b&gt; 를 수행 하는 특수한 종류의 &lt;b&gt;모듈&lt;/b&gt; .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0c845e10d2c5e7d853c713ce339e272a56f03f5c" translate="yes" xml:space="preserve">
          <source>A special kind of &lt;b&gt;scalar context&lt;/b&gt; used in conditionals to decide whether the &lt;b&gt;scalar value&lt;/b&gt; returned by an expression is &lt;b&gt;true&lt;/b&gt; or &lt;b&gt;false&lt;/b&gt;. Does not evaluate as either a string or a number. See &lt;b&gt;context&lt;/b&gt;.</source>
          <target state="translated">표현식에 의해 반환되는 &lt;b&gt;스칼라 값&lt;/b&gt; 이 &lt;b&gt;true&lt;/b&gt; 또는 &lt;b&gt;false&lt;/b&gt; 인지를 결정하기 위해 조건부 &lt;b&gt;에서&lt;/b&gt; 사용되는 특수한 종류의 &lt;b&gt;스칼라 컨텍스트&lt;/b&gt; 입니다. 문자열 또는 숫자로 평가되지 않습니다. &lt;b&gt;context를&lt;/b&gt; 참조하십시오 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="89b7b57b006b340679bccefff3860259f11cee5d" translate="yes" xml:space="preserve">
          <source>A special note about fetching files from an ftp uri:</source>
          <target state="translated">ftp uri에서 파일을 가져 오는 것에 대한 특별 참고 사항 :</target>
        </trans-unit>
        <trans-unit id="2a568b09a052a4fda0da31a9dd45e8de43daae28" translate="yes" xml:space="preserve">
          <source>A special option 'name' &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; can be used to designate a subroutine to handle non-option arguments. When GetOptions() encounters an argument that does not look like an option, it will immediately call this subroutine and passes it one parameter: the argument name. Well, actually it is an object that stringifies to the argument name.</source>
          <target state="translated">특수 옵션 'name' &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 을 사용하여 비 옵션 인수를 처리 할 서브 루틴을 지정할 수 있습니다. GetOptions ()가 옵션처럼 보이지 않는 인수를 발견하면 즉시이 서브 루틴을 호출하고 인수 이름이라는 매개 변수를 전달합니다. 사실, 그것은 인수 이름으로 문자열을 만드는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="9bb864d2ebf5f6403ee2f29fbe30d0ca7cb3bbfc" translate="yes" xml:space="preserve">
          <source>A special program that runs on the bare machine and hides the gory details of managing &lt;b&gt;processes&lt;/b&gt; and &lt;b&gt;devices&lt;/b&gt;. Usually used in a looser sense to indicate a particular culture of programming. The loose sense can be used at varying levels of specificity. At one extreme, you might say that all versions of Unix and Unix-lookalikes are the same operating system (upsetting many people, especially lawyers and other advocates). At the other extreme, you could say this particular version of this particular vendor&amp;rsquo;s operating system is different from any other version of this or any other vendor&amp;rsquo;s operating system. Perl is much more portable across operating systems than many other languages. See also &lt;b&gt;architecture&lt;/b&gt; and &lt;b&gt;platform&lt;/b&gt;.</source>
          <target state="translated">베어 시스템에서 실행되고 &lt;b&gt;프로세스&lt;/b&gt; 및 &lt;b&gt;장치&lt;/b&gt; 관리에 대한 까다로운 세부 사항을 숨기는 특수 프로그램입니다 . 일반적으로 특정 프로그래밍 문화를 나타 내기 위해 느슨한 의미로 사용됩니다. 느슨한 감각은 다양한 수준의 특이성에서 사용될 수 있습니다. 극단적으로, 모든 버전의 Unix와 Unix-lookalikes가 같은 운영 체제라고 말할 수 있습니다 (많은 사람들, 특히 변호사와 다른 옹호자들을 화나게합니다). 다른 극단적 인 경우,이 특정 공급 업체 운영 체제의 특정 버전이이 버전 또는 다른 공급 업체 운영 체제의 다른 버전과 다르다고 말할 수 있습니다. Perl은 다른 많은 언어보다 운영 체제에서 훨씬 이식성이 뛰어납니다. &lt;b&gt;아키텍처&lt;/b&gt; 및 &lt;b&gt;플랫폼&lt;/b&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b03867324ba36517f3a9d0e823f68ebcc5db216b" translate="yes" xml:space="preserve">
          <source>A special programming gizmo that keeps track of where you are in something that you&amp;rsquo;re trying to iterate over. The &lt;code&gt;foreach&lt;/code&gt; loop in Perl contains an iterator; so does a hash, allowing you to &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; through it.</source>
          <target state="translated">반복하려는 무언가의 위치를 ​​추적하는 특수 프로그래밍 기즈모입니다. Perl 의 &lt;code&gt;foreach&lt;/code&gt; 루프에는 반복자가 포함되어 있습니다. 그래서 당신을 수 있도록 해시를 수행 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 그것을 통해.</target>
        </trans-unit>
        <trans-unit id="cb2ae230ab87141b90e09da012ca49eb173d1f62" translate="yes" xml:space="preserve">
          <source>A special thanks to Damian Conway, who didn't only suggest important changes, but also took the time to count the number of listed features and make a Perl 6 version to show that Perl will stay Perl.</source>
          <target state="translated">중요한 변경 사항을 제안 할뿐만 아니라 나열된 기능의 수를 세고 Perl 6 버전을 만들어 Perl이 Perl을 유지한다는 것을 보여 주었던 Damian Conway에게 특별한 감사를드립니다.</target>
        </trans-unit>
        <trans-unit id="dbd3a98639e4de23b8ab5b1ce7e392825e327157" translate="yes" xml:space="preserve">
          <source>A special token that compiles to the current line number.</source>
          <target state="translated">현재 줄 번호로 컴파일되는 특수 토큰.</target>
        </trans-unit>
        <trans-unit id="f8db7e23c364c11a426f9d30c1e28cd4da6326e7" translate="yes" xml:space="preserve">
          <source>A special token that returns a reference to the current subroutine, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; outside of a subroutine.</source>
          <target state="translated">현재 서브 루틴에 대한 참조를 반환하거나 서브 루틴 외부에서 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 지정 하는 특수 토큰 .</target>
        </trans-unit>
        <trans-unit id="d6eea162b97cdf5937cc80c12d97f68b73850c69" translate="yes" xml:space="preserve">
          <source>A special token that returns a reference to the current subroutine, or &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; outside of a subroutine.</source>
          <target state="translated">현재 서브 루틴에 대한 참조를 반환하거나 서브 루틴 외부에서 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 지정 하는 특수 토큰 .</target>
        </trans-unit>
        <trans-unit id="2c26f3ebdbb02dd6bf3cbae9d5ef0c2e36ca2b14" translate="yes" xml:space="preserve">
          <source>A special token that returns the name of the file in which it occurs.</source>
          <target state="translated">발생하는 파일의 이름을 반환하는 특수 토큰.</target>
        </trans-unit>
        <trans-unit id="48496bf275cb62c80b11546a66125c1e011d6e73" translate="yes" xml:space="preserve">
          <source>A special token that returns the name of the package in which it occurs.</source>
          <target state="translated">발생하는 패키지의 이름을 반환하는 특수 토큰.</target>
        </trans-unit>
        <trans-unit id="07395fd97ce6a28d8015ab2eaad3eae19ab86b6e" translate="yes" xml:space="preserve">
          <source>A specialised variant of &lt;code&gt;croak()&lt;/code&gt; for emitting the usage message for xsubs</source>
          <target state="translated">xsub에 대한 사용법 메시지를 출력하기위한 &lt;code&gt;croak()&lt;/code&gt; 의 특수 변형</target>
        </trans-unit>
        <trans-unit id="89a1130f5dbd32f8addbfbf8cc52dc9647058465" translate="yes" xml:space="preserve">
          <source>A specialised version of &lt;a href=&quot;#newHVhv&quot;&gt;newHVhv&lt;/a&gt; for copying &lt;code&gt;%^H&lt;/code&gt; .</source>
          <target state="translated">의 전문 버전 &lt;a href=&quot;#newHVhv&quot;&gt;newHVhv&lt;/a&gt; 복사하는 &lt;code&gt;%^H&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e58efa1c2b3f0ec95f611bcd359aa9037253ccf" translate="yes" xml:space="preserve">
          <source>A specification of how many spaces and digits and things to put somewhere so that whatever you&amp;rsquo;re printing comes out nice and pretty.</source>
          <target state="translated">인쇄하는 모든 것이 멋지고 예쁘게 나올 수 있도록 몇 개의 공백과 숫자 및 어딘가에 넣을 물건에 대한 사양.</target>
        </trans-unit>
        <trans-unit id="ece2ff0c58aaa5372289e45e695e7991badd8557" translate="yes" xml:space="preserve">
          <source>A spoonerism of &amp;ldquo;creeping featurism&amp;rdquo;, noting the biological urge to add just one more feature to a program.</source>
          <target state="translated">생물학적 기능이 프로그램에 하나 이상의 기능을 추가해야한다는 생물학적 충동을 지적하면서&amp;ldquo;크리핑 피처 리즘&amp;rdquo;의 숟가락.</target>
        </trans-unit>
        <trans-unit id="d575cbf3544d0e35868eb03520f7ba9dff410b04" translate="yes" xml:space="preserve">
          <source>A spot in your program where you&amp;rsquo;ve told the debugger to stop &lt;b&gt;execution&lt;/b&gt; so you can poke around and see whether anything is wrong yet.</source>
          <target state="translated">프로그램에서 디버거에게 &lt;b&gt;실행&lt;/b&gt; 을 중지 하도록 지시 한 지점으로, 찌르고 아직 문제가 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8d0045954f55c0ef11ccdf21fdc1fefc0f23ff1" translate="yes" xml:space="preserve">
          <source>A square-bracketed list of characters used in a &lt;b&gt;regular expression&lt;/b&gt; to indicate that any character of the set may occur at a given point. Loosely, any predefined set of characters so used.</source>
          <target state="translated">&lt;b&gt;정규식에&lt;/b&gt; 사용되는 대괄호로 묶인 문자 목록은 세트의 모든 문자가 주어진 지점에서 발생할 수 있음을 나타냅니다. 느슨하게도, 사전 정의 된 문자 세트가 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="a4537030d9c45923983b601a7f64bbae6c4af141" translate="yes" xml:space="preserve">
          <source>A stable sort means that for records that compare equal, the original input ordering is preserved. Mergesort is stable, quicksort is not. Stability will matter only if elements that compare equal can be distinguished in some other way. That means that simple numerical and lexical sorts do not profit from stability, since equal elements are indistinguishable. However, with a comparison such as</source>
          <target state="translated">안정적인 정렬은 동일하게 비교되는 레코드의 경우 원래 입력 순서가 유지됨을 의미합니다. Mergesort는 안정적이며 quicksort는 그렇지 않습니다. 동일하게 비교되는 요소를 다른 방식으로 구별 할 수있는 경우에만 안정성이 중요합니다. 즉, 동일한 수의 요소를 구분할 수 없기 때문에 단순한 숫자 및 어휘 정렬은 안정성에서 이익을 얻지 못합니다. 그러나 다음과 같은 비교</target>
        </trans-unit>
        <trans-unit id="0bc56d9c1394b0fa0321168c0b37750c90b88391" translate="yes" xml:space="preserve">
          <source>A standalone &lt;code&gt;=end&lt;/code&gt; command was found.</source>
          <target state="translated">독립형 &lt;code&gt;=end&lt;/code&gt; 명령이 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="90d81dc6a3e1d8ac5702b6911f4d25957cbc4616" translate="yes" xml:space="preserve">
          <source>A standard C library for doing &lt;b&gt;buffered&lt;/b&gt; input and output to the &lt;b&gt;operating system&lt;/b&gt;. (The &amp;ldquo;standard&amp;rdquo; of standard I/O is at most marginally related to the &amp;ldquo;standard&amp;rdquo; of standard input and output.) In general, Perl relies on whatever implementation of standard I/O a given operating system supplies, so the buffering characteristics of a Perl program on one machine may not exactly match those on another machine. Normally this only influences efficiency, not semantics. If your standard I/O package is doing block buffering and you want it to &lt;b&gt;flush&lt;/b&gt; the buffer more often, just set the &lt;code&gt;$|&lt;/code&gt; variable to a true value.</source>
          <target state="translated">&lt;b&gt;운영 체제에 &lt;/b&gt;&lt;b&gt;버퍼링 된&lt;/b&gt; 입력 및 출력을 수행하기위한 표준 C 라이브러리 . (표준 I / O의 &quot;표준&quot;은 표준 입력 및 출력의 &quot;표준&quot;과 거의 관련이 없습니다.) 일반적으로 Perl은 특정 운영 체제 공급 장치의 표준 I / O 구현에 의존하므로 버퍼링 특성 한 시스템의 Perl 프로그램 중 하나가 다른 시스템의 프로그램과 정확히 일치하지 않을 수 있습니다. 일반적으로 이것은 의미론이 아닌 효율성에만 영향을 미칩니다. 표준 I / O 패키지가 블록 버퍼링을 수행하고 있고 더 자주 버퍼 를 &lt;b&gt;플러시&lt;/b&gt; 하려면 &lt;code&gt;$|&lt;/code&gt; 변수를 실제 값으로&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ffe116dcbea9e5d21815e3d329637659dd6eec04" translate="yes" xml:space="preserve">
          <source>A standard module whose practical hints and suggestions are received (and possibly ignored) at compile time. Pragmas are named in all lowercase.</source>
          <target state="translated">실용적인 힌트와 제안이 컴파일 타임에 수신되고 무시 될 수있는 표준 모듈입니다. Pragma는 모두 소문자로 이름이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="3042ccfccce8001b84bc5b8d8019cf025a6017d9" translate="yes" xml:space="preserve">
          <source>A standard, bundled release of a system of software. The default usage implies source code is included. If that is not the case, it will be called a &amp;ldquo;binary-only&amp;rdquo; distribution.</source>
          <target state="translated">소프트웨어 시스템의 표준 번들 릴리스. 기본 사용법은 소스 코드가 포함되어 있음을 의미합니다. 그렇지 않은 경우&amp;ldquo;이진 전용&amp;rdquo;배포라고합니다.</target>
        </trans-unit>
        <trans-unit id="c6647b8f10e57534f902ddf1aa4bccf61236fd6c" translate="yes" xml:space="preserve">
          <source>A statement sequence may contain declarations of lexically-scoped variables, but apart from declaring a variable name, the declaration acts like an ordinary statement, and is elaborated within the sequence of statements as if it were an ordinary statement. That means it actually has both compile-time and run-time effects.</source>
          <target state="translated">문장 순서는 어휘 범위 변수의 선언을 포함 할 수 있지만 변수 이름을 선언하는 것 외에도 선언은 일반적인 문장처럼 작동하며 문장의 시퀀스 내에서 마치 일반적인 문장 인 것처럼 설명됩니다. 그것은 실제로 컴파일 타임과 런타임 이펙트를 모두 가지고 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="fa46e467d8cdc232f6a66d28e35057665324ee9f" translate="yes" xml:space="preserve">
          <source>A string (char *).</source>
          <target state="translated">문자열 (char *).</target>
        </trans-unit>
        <trans-unit id="75e5df3441233543315a78a7205a2debb8ad739c" translate="yes" xml:space="preserve">
          <source>A string &lt;a href=&quot;functions/eval&quot;&gt;eval EXPR&lt;/a&gt; parses its expression as standard Perl. It is therefore expecting the decimal point to be a dot. If &lt;code&gt;LC_NUMERIC&lt;/code&gt; is set to have this be a comma instead, the parsing will be confused, perhaps silently.</source>
          <target state="translated">문자열 &lt;a href=&quot;functions/eval&quot;&gt;평가 EXPR&lt;/a&gt; 은 해당 표현식을 표준 Perl로 구문 분석합니다. 따라서 소수점이 점이 될 것으로 예상됩니다. 경우 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 은 이 대신 쉼표로 설정되어, 구문 분석은 아마도 자동으로 혼동 될 것이다.</target>
        </trans-unit>
        <trans-unit id="b9568afdc53a4a7f1711d767a18a8d9f968593e6" translate="yes" xml:space="preserve">
          <source>A string beginning with &lt;code&gt;CLISYM_&lt;/code&gt; tells Perl to consult the CLI's symbol tables, using</source>
          <target state="translated">&lt;code&gt;CLISYM_&lt;/code&gt; 로 시작하는 문자열 은 Perl에게 다음을 사용하여 CLI의 기호 테이블을 참조하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="afb88c9d62f1cca49157633840f22b59a116a8ab" translate="yes" xml:space="preserve">
          <source>A string containing all characters that should be encoded as HTML entities, specified using the regular expression character class syntax (what you find within brackets in regular expressions). This value will be passed as the second argument to the &lt;code&gt;encode_entities&lt;/code&gt; function of &lt;a href=&quot;http://search.cpan.org/perldoc/HTML::Entities&quot;&gt;HTML::Entities&lt;/a&gt;. If &lt;a href=&quot;http://search.cpan.org/perldoc/HTML::Entities&quot;&gt;HTML::Entities&lt;/a&gt; is not installed, then any characters other than &lt;code&gt;&amp;amp;&amp;lt;&lt;/code&gt; &quot;'&amp;gt; will be encoded numerically.</source>
          <target state="translated">정규식 문자 클래스 구문 (정규식에서 괄호 안에있는 것)을 사용하여 지정된 HTML 엔티티로 인코딩되어야하는 모든 문자를 포함하는 문자열입니다. 이 값은 &lt;a href=&quot;http://search.cpan.org/perldoc/HTML::Entities&quot;&gt;HTML :: Entities&lt;/a&gt; 의 &lt;code&gt;encode_entities&lt;/code&gt; 함수에 두 번째 인수로 전달됩니다 . 경우 &lt;a href=&quot;http://search.cpan.org/perldoc/HTML::Entities&quot;&gt;HTML :: 엔티티가&lt;/a&gt; 설치되어 있지 않은 경우, 이외의 문자 &lt;code&gt;&amp;amp;&amp;lt;&lt;/code&gt; ''&amp;gt; 숫자로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="2c6988b512688bb605e69e65500198db5054baa8" translate="yes" xml:space="preserve">
          <source>A string containing the text of a message to print</source>
          <target state="translated">인쇄 할 메시지의 텍스트를 포함하는 문자열</target>
        </trans-unit>
        <trans-unit id="bf5bf16fd07f45d581debfd5241308f05f5b876d" translate="yes" xml:space="preserve">
          <source>A string corresponding to the desired output file (or &quot;&amp;gt;&amp;amp;STDOUT&quot; or &quot;&amp;gt;&amp;amp;STDERR&quot;), or a filehandle to write on. The default is to use standard output.</source>
          <target state="translated">원하는 출력 파일 (또는 &quot;&amp;gt; &amp;amp; STDOUT&quot;또는 &quot;&amp;gt; &amp;amp; STDERR&quot;) 또는 쓸 파일 핸들에 해당하는 문자열입니다. 기본값은 표준 출력을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e81c48705eb13d4df1f22c2acd8523f46384c993" translate="yes" xml:space="preserve">
          <source>A string enclosed by backticks (grave accents) first undergoes double-quote interpolation. It is then interpreted as an external command, and the output of that command is the value of the backtick string, like in a shell. In scalar context, a single string consisting of all output is returned. In list context, a list of values is returned, one per line of output. (You can set &lt;code&gt;$/&lt;/code&gt; to use a different line terminator.) The command is executed each time the pseudo-literal is evaluated. The status value of the command is returned in &lt;code&gt;$?&lt;/code&gt; (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for the interpretation of &lt;code&gt;$?&lt;/code&gt; ). Unlike in &lt;b&gt;csh&lt;/b&gt;, no translation is done on the return data--newlines remain newlines. Unlike in any of the shells, single quotes do not hide variable names in the command from interpretation. To pass a literal dollar-sign through to the shell you need to hide it with a backslash. The generalized form of backticks is &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt;. (Because backticks always undergo shell expansion as well, see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; for security concerns.)</source>
          <target state="translated">백틱 (가시 악센트)으로 묶인 문자열은 먼저 큰 따옴표 보간을받습니다. 그런 다음 외부 명령으로 해석되며 해당 명령의 출력은 쉘에서와 같이 백틱 문자열의 값입니다. 스칼라 컨텍스트에서는 모든 출력으로 구성된 단일 문자열이 반환됩니다. 목록 컨텍스트에서 출력 라인 당 하나씩 값 목록이 리턴됩니다. ( 다른 줄 종결자를 사용하도록 &lt;code&gt;$/&lt;/code&gt; 를 설정할 수 있습니다 .) 의사 리터럴이 평가 될 때마다 명령이 실행됩니다. 명령의 상태 값은 &lt;code&gt;$?&lt;/code&gt; ( &lt;code&gt;$?&lt;/code&gt; 의 해석에 대해서는 &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; 를 참조하십시오 ). &lt;b&gt;csh&lt;/b&gt; 와 달리&lt;b&gt;&lt;/b&gt;반환 데이터에 대해서는 번역이 수행되지 않으며, 줄 바꿈은 줄 바꿈으로 유지됩니다. 쉘과 달리 작은 따옴표는 명령에서 변수 이름을 해석에서 숨기지 않습니다. 리터럴 달러 기호를 쉘에 전달하려면 백 슬래시로 숨겨야합니다. 백틱의 일반화 된 형태는 &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt; 입니다. (백틱도 항상 셸 확장을 거치 &lt;a href=&quot;perlsec&quot;&gt;므로&lt;/a&gt; 보안 문제는 perlsec 을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="8188c86cb7ff03c08e73a3bf26c2466b54d74c0a" translate="yes" xml:space="preserve">
          <source>A string encoded in UTF-EBCDIC may be longer (but never shorter) than one encoded in UTF-8. Perl extends UTF-8 so that it can encode code points above the Unicode maximum of U+10FFFF. It extends UTF-EBCDIC as well, but due to the inherent limitations in UTF-EBCDIC, the maximum code point expressible is U+7FFF_FFFF, even if the word size is more than 32 bits.</source>
          <target state="translated">UTF-EBCDIC으로 인코딩 된 문자열은 UTF-8로 인코딩 된 문자열보다 길 수 있지만 더 짧을 수는 없습니다. Perl은 UTF-8을 확장하여 유니 코드 최대 값 U + 10FFFF를 초과하는 코드 포인트를 인코딩 할 수 있습니다. UTF-EBCDIC도 확장하지만 UTF-EBCDIC의 고유 제한 사항으로 인해 워드 크기가 32 비트를 초과하더라도 표현 가능한 최대 코드 포인트는 U + 7FFF_FFFF입니다.</target>
        </trans-unit>
        <trans-unit id="f4917965ca44eb0c4faae94a841c4f89027d6938" translate="yes" xml:space="preserve">
          <source>A string of alternative option starter characters may be passed as the first argument (or the first argument after a leading hash reference argument).</source>
          <target state="translated">대체 옵션 시작 문자 문자열이 첫 번째 인수 (또는 선행 해시 참조 인수 다음의 첫 번째 인수)로 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46c47b9481cf147721b670360f462acc06f6b68e" translate="yes" xml:space="preserve">
          <source>A string of portable printable characters. This is the base64 encoded representation of the digest with any trailing padding removed. The string will be about 30% longer than the binary version. &lt;a href=&quot;mime/base64&quot;&gt;MIME::Base64&lt;/a&gt; tells you more about this encoding.</source>
          <target state="translated">휴대용 인쇄 가능한 문자열입니다. 후행 패딩이 제거 된 다이제스트의 base64 인코딩 표현입니다. 문자열은 이진 버전보다 약 30 % 길어집니다. &lt;a href=&quot;mime/base64&quot;&gt;MIME :: Base64&lt;/a&gt; 가이 인코딩에 대해 자세히 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="5b5f076887ce0597a3fa01a1ea06dacb7c8fe5ad" translate="yes" xml:space="preserve">
          <source>A string representing a selection list for sections to be printed when -verbose is set to 99, e.g. &lt;code&gt;&quot;NAME|SYNOPSIS|DESCRIPTION|VERSION&quot;&lt;/code&gt; .</source>
          <target state="translated">-verbose가 99로 설정된 경우 인쇄 될 섹션의 선택 목록을 나타내는 문자열입니다 (예 : &lt;code&gt;&quot;NAME|SYNOPSIS|DESCRIPTION|VERSION&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="308056f61edbce292af89589357f11ee44fd726d" translate="yes" xml:space="preserve">
          <source>A string specifying a pattern to be matched as a prefix (which is to be skipped). If omitted, optional whitespace is skipped.</source>
          <target state="translated">접두사로 일치시킬 패턴을 지정하는 문자열입니다 (건너 뛸 것임). 생략하면 선택적 공백은 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="e9bc4f6bfc82a7d474c7f1ed6bc1a706c74a685f" translate="yes" xml:space="preserve">
          <source>A string specifying a pattern to be matched as the opening tag. If the pattern string is omitted (or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) then a pattern that matches any standard XML tag is used.</source>
          <target state="translated">여는 태그와 일치시킬 패턴을 지정하는 문자열입니다. 패턴 문자열이 생략 된 경우 (또는 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ) 표준 XML 태그와 일치하는 패턴이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="048410179c1d880e31b42e6134fee925ec940ae9" translate="yes" xml:space="preserve">
          <source>A string specifying a pattern to be matched at the closing tag. If the pattern string is omitted (or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) then the closing tag is constructed by inserting a &lt;code&gt;/&lt;/code&gt; after any leading bracket characters in the actual opening tag that was matched (</source>
          <target state="translated">닫는 태그에서 일치시킬 패턴을 지정하는 문자열입니다. 패턴 문자열이 생략 된 경우 (또는 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ) 닫는 태그는 일치하는 실제 여는 태그에서 선행 대괄호 문자 뒤에 &lt;code&gt;/&lt;/code&gt; 를 삽입하여 구성됩니다 (</target>
        </trans-unit>
        <trans-unit id="4ddc15672e491fc997c3e75cb530fdf3735fbd3c" translate="yes" xml:space="preserve">
          <source>A string that can suppress Perl's warning about failed locale settings at startup. Failure can occur if the locale support in the operating system is lacking (broken) in some way--or if you mistyped the name of a locale when you set up your environment. If this environment variable is absent, or has a value other than &quot;0&quot; or &quot;&quot;, Perl will complain about locale setting failures.</source>
          <target state="translated">시작시 로케일 설정 실패에 대한 Perl의 경고를 억제 할 수있는 문자열. 운영 체제의 로케일 지원이 부족하거나 (깨진) 환경을 설정할 때 로케일 이름을 잘못 입력하면 실패가 발생할 수 있습니다. 이 환경 변수가 없거나 &quot;0&quot;또는 &quot;&quot;이외의 값을 가진 경우 Perl은 로케일 설정 실패에 대해 불평합니다.</target>
        </trans-unit>
        <trans-unit id="a2db67434e3c04d01083072b7b914ae53b6902d9" translate="yes" xml:space="preserve">
          <source>A string to be processed (&lt;code&gt;$_&lt;/code&gt; if the string is omitted or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">처리 할 문자열 (문자열을 생략하거나 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 인 경우 &lt;code&gt;$_&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="6e51f4c9fde9edecc0936ad5478d06f35a15c4b1" translate="yes" xml:space="preserve">
          <source>A string which is (possibly) interpolated and then executed as a system command with</source>
          <target state="translated">보간 된 다음 가능한 시스템 명령으로 실행되는 문자열</target>
        </trans-unit>
        <trans-unit id="f332e2ab827e7ad888e10e40f020c6f2638261a6" translate="yes" xml:space="preserve">
          <source>A subclass for in-memory extracted file from Archive::Tar</source>
          <target state="translated">Archive :: Tar에서 메모리 내 추출 파일의 서브 클래스</target>
        </trans-unit>
        <trans-unit id="abd458b754cc911d966797f7f9e904a5bf421ea9" translate="yes" xml:space="preserve">
          <source>A subclass of Pod::Simple::PullParser should define a &lt;code&gt;run&lt;/code&gt; method that calls &lt;code&gt;$token = $parser-&amp;gt;get_token&lt;/code&gt; to pull tokens.</source>
          <target state="translated">Pod :: Simple :: PullParser의 하위 클래스는 &lt;code&gt;$token = $parser-&amp;gt;get_token&lt;/code&gt; 을 호출 하여 토큰을 가져 오는 &lt;code&gt;run&lt;/code&gt; 메소드를 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6da5549484c85ec07cefefac0b04929e1e4b68b4" translate="yes" xml:space="preserve">
          <source>A subdirectory</source>
          <target state="translated">서브 디렉토리</target>
        </trans-unit>
        <trans-unit id="f3c131323abddd429496c2a4e94519d28ee7cce1" translate="yes" xml:space="preserve">
          <source>A subform of &quot;Eskimo&quot;.</source>
          <target state="translated">&quot;에스키모&quot;의 하위 형태.</target>
        </trans-unit>
        <trans-unit id="2185f5ee89fe302e7bad5c0ce031b9136fe1881e" translate="yes" xml:space="preserve">
          <source>A subpattern &lt;b&gt;assertion&lt;/b&gt; matching the &lt;b&gt;null string&lt;/b&gt; between &lt;b&gt;characters&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;문자&lt;/b&gt; 사이 의 &lt;b&gt;null 문자열&lt;/b&gt; 과 일치 하는 하위 패턴 &lt;b&gt;어설 션&lt;/b&gt; 입니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="dcb76fdf91425256508047ecf8357fd1c432b0b3" translate="yes" xml:space="preserve">
          <source>A subroutine declaration or definition may have a list of attributes associated with it. If such an attribute list is present, it is broken up at space or colon boundaries and treated as though a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; attributes&lt;/code&gt; had been seen. See &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt; for details about what attributes are currently supported. Unlike the limitation with the obsolescent &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; attrs&lt;/code&gt; , the &lt;code&gt;sub : ATTRLIST&lt;/code&gt; syntax works to associate the attributes with a pre-declaration, and not just with a subroutine definition.</source>
          <target state="translated">서브 루틴 선언 또는 정의에는 연관된 속성 목록이있을 수 있습니다. 이러한 속성 목록이 있으면 공간 또는 콜론 경계에서 분리되고 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; attributes&lt;/code&gt; 이 표시된 것처럼 처리됩니다 . 현재 지원되는 &lt;a href=&quot;attributes&quot;&gt;속성에&lt;/a&gt; 대한 자세한 내용은 속성 을 참조하십시오 . 퇴행성로 제한 달리 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; attrs&lt;/code&gt; 의 &lt;code&gt;sub : ATTRLIST&lt;/code&gt; 구문은 미리 선언 속성을 연결하고, 단지 서브 루틴의 정의를 위해 노력하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="d523fe66bca5199af0174d9a0e394a363dbbca6f" translate="yes" xml:space="preserve">
          <source>A subroutine may be called using an explicit &lt;code&gt;&amp;amp;&lt;/code&gt; prefix. The &lt;code&gt;&amp;amp;&lt;/code&gt; is optional in modern Perl, as are parentheses if the subroutine has been predeclared. The &lt;code&gt;&amp;amp;&lt;/code&gt; is</source>
          <target state="translated">서브 루틴은 명시 적 &lt;code&gt;&amp;amp;&lt;/code&gt; 접 두부를 사용하여 호출 할 수 있습니다 . &lt;code&gt;&amp;amp;&lt;/code&gt; 서브 루틴이 미리 선언 된 경우 현대 펄에서 선택 사항이 아니라 괄호입니다. &lt;code&gt;&amp;amp;&lt;/code&gt; IS</target>
        </trans-unit>
        <trans-unit id="472af3789d6b7cf851a695ddbea3171cb9f6d23e" translate="yes" xml:space="preserve">
          <source>A subroutine reference to be run at the end of the test script, if any of the tests fail. See &lt;a href=&quot;#ONFAIL&quot;&gt;ONFAIL&lt;/a&gt;.</source>
          <target state="translated">테스트 중 하나라도 실패하면 테스트 스크립트의 끝에서 실행될 서브 루틴 참조. &lt;a href=&quot;#ONFAIL&quot;&gt;ONFAIL을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3a8138bb418c6dab14df47bdb5b98c794bb069d9" translate="yes" xml:space="preserve">
          <source>A subroutine stub (or forward declaration) looks like</source>
          <target state="translated">서브 루틴 스텁 (또는 순방향 선언)은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5c6644152e307dff88d95b419866126c49ada182" translate="yes" xml:space="preserve">
          <source>A substitution can do this for you. For a single line, you want to replace all the leading or trailing whitespace with nothing. You can do that with a pair of substitutions:</source>
          <target state="translated">대체가 당신을 위해 이것을 할 수 있습니다. 한 줄의 경우 모든 선행 또는 후행 공백을 아무 것도 바꾸고 싶습니다. 한 쌍의 치환으로 그렇게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c348ffb20315d847f6359bc6cf9c39166e27bc60" translate="yes" xml:space="preserve">
          <source>A substring &lt;b&gt;captured&lt;/b&gt; by a subpattern within unadorned parentheses in a &lt;b&gt;regex&lt;/b&gt;. Backslashed decimal numbers (&lt;code&gt;\1&lt;/code&gt; , &lt;code&gt;\2&lt;/code&gt; , etc.) later in the same pattern refer back to the corresponding subpattern in the current match. Outside the pattern, the numbered variables (&lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , etc.) continue to refer to these same values, as long as the pattern was the last successful match of the current &lt;b&gt;dynamic scope&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;정규 표현식&lt;/b&gt; 에서 괄호 안의 하위 패턴으로 &lt;b&gt;캡처&lt;/b&gt; 된 하위 문자열 입니다. 같은 패턴으로 된 백 슬래시 10 진수 ( &lt;code&gt;\1&lt;/code&gt; , &lt;code&gt;\2&lt;/code&gt; 등)는 현재 일치하는 해당 하위 패턴을 다시 참조합니다. 패턴 외부에서 패턴 이 현재 &lt;b&gt;동적 범위&lt;/b&gt; 와 마지막으로 일치 하는 한 번호가 매겨진 변수 ( &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; 등)는 계속 동일한 값을 참조합니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="315d0303e3aef241562f12b55669ceb9dfe96eb1" translate="yes" xml:space="preserve">
          <source>A subtest may call &lt;code&gt;skip_all&lt;/code&gt; . No tests will be run, but the subtest is considered a skip.</source>
          <target state="translated">하위 테스트는 &lt;code&gt;skip_all&lt;/code&gt; 을 호출 할 수 있습니다 . 테스트는 실행되지 않지만 하위 테스트는 건너 뛰기로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="37458279bba72a238643fe5627f2676bd36cfdcd" translate="yes" xml:space="preserve">
          <source>A subtest of the</source>
          <target state="translated">의 하위 테스트</target>
        </trans-unit>
        <trans-unit id="ddbd7203825cf4784baaa474ee9dd57475c72727" translate="yes" xml:space="preserve">
          <source>A subtlety of the parsing process means that a regex like &lt;code&gt;/foo/&lt;/code&gt; is originally parsed into an alternation with a single branch. It is only afterwards that the optimiser converts single branch alternations into the simpler form.</source>
          <target state="translated">구문 분석 프로세스의 미묘한 의미는 &lt;code&gt;/foo/&lt;/code&gt; 와 같은 정규식 이 원래 단일 분기를 사용하여 대체로 구문 분석 되었음을 의미합니다 . 옵티마이 저가 단일 브랜치 교체를 더 간단한 형태로 변환 한 후에 만 ​​가능합니다.</target>
        </trans-unit>
        <trans-unit id="ca8ecc01810919d80818935b434bfbed09194445" translate="yes" xml:space="preserve">
          <source>A sufficiently complicated module using XS would have both Perl code (defined in</source>
          <target state="translated">XS를 사용하는 충분히 복잡한 모듈에는 Perl 코드가 모두 있습니다 (</target>
        </trans-unit>
        <trans-unit id="ec7ba027499434cb4ad8ba5cfec6aea4c41ca3a7" translate="yes" xml:space="preserve">
          <source>A superset of stdio's &lt;code&gt;ungetc()&lt;/code&gt; . Should arrange for future reads to see the bytes in &lt;code&gt;vbuf&lt;/code&gt; . If there is no obviously better implementation then &lt;code&gt;PerlIOBase_unread()&lt;/code&gt; provides the function by pushing a &quot;fake&quot; &quot;pending&quot; layer above the calling layer.</source>
          <target state="translated">stdio의 &lt;code&gt;ungetc()&lt;/code&gt; 의 수퍼 세트 . &lt;code&gt;vbuf&lt;/code&gt; 의 바이트를 볼 수 있도록 향후 읽기를 준비해야 합니다. 더 나은 구현이 없다면 &lt;code&gt;PerlIOBase_unread()&lt;/code&gt; 는 호출 계층 위로 &quot;가짜&quot; &quot;보류&quot;계층을 밀어서 함수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c626abd78031b8aca6600ea0c2440d7fd00d78cd" translate="yes" xml:space="preserve">
          <source>A synonym for abs_path().</source>
          <target state="translated">abs_path ()의 동의어</target>
        </trans-unit>
        <trans-unit id="e1b37e0c283299b17772ecb39d63c354cb1c21a5" translate="yes" xml:space="preserve">
          <source>A synopsis of the common uses of the module</source>
          <target state="translated">모듈의 일반적인 사용에 대한 개요</target>
        </trans-unit>
        <trans-unit id="cbedc357c1a8c0f556eb0ada80454f902c9b0495" translate="yes" xml:space="preserve">
          <source>A syntactic construct consisting of a sequence of Perl &lt;b&gt;statements&lt;/b&gt; that is delimited by braces. The &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;while&lt;/code&gt; statements are defined in terms of</source>
          <target state="translated">중괄호로 구분 된 일련의 Perl &lt;b&gt;문&lt;/b&gt; 으로 구성된 구문 구성 . &lt;code&gt;if&lt;/code&gt; 와 &lt;code&gt;while&lt;/code&gt; 문으로 정의된다</target>
        </trans-unit>
        <trans-unit id="ad7124750e36065dd8c98d176b7da5958dc7cdde" translate="yes" xml:space="preserve">
          <source>A syntactic construct representing a comma- separated list of expressions, evaluated to produce a &lt;b&gt;list value&lt;/b&gt;. Each &lt;b&gt;expression&lt;/b&gt; in a</source>
          <target state="translated">쉼표로 구분 된 표현식 목록을 나타내는 구문 구조로, &lt;b&gt;목록 값&lt;/b&gt; 을 생성하도록 평가됩니다 . 각각의 &lt;b&gt;표현&lt;/b&gt; A의</target>
        </trans-unit>
        <trans-unit id="7291be1f4b56b7d225866ff464ea491e8b919184" translate="yes" xml:space="preserve">
          <source>A system that algorithmically writes code for you in a high-level language. See also &lt;b&gt;code generator&lt;/b&gt;.</source>
          <target state="translated">알고리즘을 통해 고급 언어로 코드를 작성하는 시스템입니다. &lt;b&gt;코드 생성기&lt;/b&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="87ef544f16a30a02ca093ea233165dcf6ff6a52e" translate="yes" xml:space="preserve">
          <source>A system that writes code for you in a low-level language, such as code to implement the backend of a compiler. See &lt;b&gt;program generator&lt;/b&gt;.</source>
          <target state="translated">컴파일러의 백엔드를 구현하기위한 코드와 같은 저수준 언어로 코드를 작성하는 시스템입니다. &lt;b&gt;프로그램 생성기를&lt;/b&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="57d745713dbf91df8c6f9ba2a699dab6d83ae07a" translate="yes" xml:space="preserve">
          <source>A template may be specified either with a leading template or with a TEMPLATE argument.</source>
          <target state="translated">템플릿은 선행 템플릿 또는 TEMPLATE 인수로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="becc5a1b25927d1909dc38d940b77e72a5cc23a0" translate="yes" xml:space="preserve">
          <source>A template used in &lt;b&gt;pattern matching&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;패턴 매칭에&lt;/b&gt; 사용되는 템플릿 .</target>
        </trans-unit>
        <trans-unit id="460ed5b4079db2b66835c9fa0b74f3db75b6b725" translate="yes" xml:space="preserve">
          <source>A temporary failure occurred during name resolution. The operation may be successful if it is retried later.</source>
          <target state="translated">이름 확인 중 일시적인 오류가 발생했습니다. 나중에 다시 시도하면 작업이 성공할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36377f90ac483d31142c52a673f24ea229719c46" translate="yes" xml:space="preserve">
          <source>A temporary holding location for data. Data that are &lt;b&gt;Block buffering&lt;/b&gt; means that the data is passed on to its destination whenever the buffer is full. &lt;b&gt;Line buffering&lt;/b&gt; means that it&amp;rsquo;s passed on whenever a complete line is received. &lt;b&gt;Command buffering&lt;/b&gt; means that it&amp;rsquo;s passed every time you do a &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; command (or equivalent). If your output is unbuffered, the system processes it one byte at a time without the use of a holding area. This can be rather inefficient.</source>
          <target state="translated">데이터의 임시 보관 장소. 데이터가되는 &lt;b&gt;블록 버퍼링&lt;/b&gt; , 버퍼가 가득 할 때마다 데이터가 목적지에 전달된다는 것을 의미한다. &lt;b&gt;라인 버퍼링&lt;/b&gt; 은 완전한 라인이 수신 될 때마다 전달됨을 의미합니다. &lt;b&gt;명령 버퍼링&lt;/b&gt; 은 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 명령 (또는 이와 동등한) 을 수행 할 때마다 전달됩니다 . 출력이 버퍼링되지 않은 경우 시스템은 유지 영역을 사용하지 않고 한 번에 1 바이트 씩 처리합니다. 다소 비효율적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f18ef7078604acdbaf428768e9818f7cd824fdb3" translate="yes" xml:space="preserve">
          <source>A temporary value scheduled to die when the current statement finishes.</source>
          <target state="translated">현재 명령문이 완료 될 때 종료되도록 임시 값입니다.</target>
        </trans-unit>
        <trans-unit id="be309ca808fdd70439ad47732767ff0fa5bc7488" translate="yes" xml:space="preserve">
          <source>A text &lt;b&gt;file&lt;/b&gt; that is a program intended to be &lt;b&gt;executed&lt;/b&gt; directly rather than &lt;b&gt;compiled&lt;/b&gt; to another form of file before &lt;b&gt;execution&lt;/b&gt;.</source>
          <target state="translated">텍스트 &lt;b&gt;파일&lt;/b&gt; 은 &lt;b&gt;실행&lt;/b&gt; 전에 다른 형식의 파일로 &lt;b&gt;컴파일&lt;/b&gt; 되지 않고 직접 &lt;b&gt;실행&lt;/b&gt; 되도록하는 프로그램입니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="69f7603a0e21614f40b6c5bdc945d53c623ea439" translate="yes" xml:space="preserve">
          <source>A third argument is also passed to the handler, which contains a copy of the raw binary contents of the &lt;code&gt;siginfo&lt;/code&gt; structure: if a system has some non-POSIX fields, this third argument is where to &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; them from.</source>
          <target state="translated">&lt;code&gt;siginfo&lt;/code&gt; 구조 의 원시 바이너리 내용의 사본을 포함하는 세 번째 인수도 핸들러에 전달 됩니다. 시스템에 POSIX 이외의 필드가있는 경우이 세 번째 인수는 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; 위치 입니다.</target>
        </trans-unit>
        <trans-unit id="6401a363806a46dc3a276adc43e53feeed2b394c" translate="yes" xml:space="preserve">
          <source>A third style of bundling allows only values to be bundled with options. It can be enabled with:</source>
          <target state="translated">세 번째 스타일의 번들링은 옵션에만 값을 묶을 수 있습니다. 다음을 사용하여 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec67162265d799cee7ba073ea5ae61361a099a71" translate="yes" xml:space="preserve">
          <source>A thread is a flow of control through a program with a single execution point.</source>
          <target state="translated">스레드는 단일 실행 지점이있는 프로그램을 통한 제어 흐름입니다.</target>
        </trans-unit>
        <trans-unit id="e05fa4d94d725ab6d1467a08643ac53ed8a48ab5" translate="yes" xml:space="preserve">
          <source>A thread terminated in some manner other than just returning from its entry point function, or by using &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt; . For example, the thread may have terminated because of an error, or by using &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">스레드는 진입 점 함수에서 반환하거나 &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt; 사용하는 것 이외의 방식으로 종료되었습니다 . 예를 들어, 오류로 인해 또는 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 를 사용하여 스레드가 종료되었을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d5f8dc4f0e564ede193fccb0795b819fd8f8f455" translate="yes" xml:space="preserve">
          <source>A tied hash can have any semantics at all. It is typically tied to an on-disk database, so that cached values are stored in the database and retrieved from it again when needed, and the disk file typically persists after your program has exited. See &lt;code&gt;perltie&lt;/code&gt; for more complete details about &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">묶인 해시는 의미를 전혀 가질 수 없습니다. 캐시 된 값은 데이터베이스에 저장되어 필요할 때 다시 검색되고 디스크 파일은 일반적으로 프로그램이 종료 된 후에도 유지됩니다. 참조 &lt;code&gt;perltie&lt;/code&gt; 에 대한 자세한 전체 내용은 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88fb398954c23d545a218b6f24145de7bcc79c9d" translate="yes" xml:space="preserve">
          <source>A token in a programming language, such as a number or &lt;b&gt;string&lt;/b&gt;, that gives you an actual &lt;b&gt;value&lt;/b&gt; instead of merely representing possible values as a &lt;b&gt;variable&lt;/b&gt; does.</source>
          <target state="translated">&lt;b&gt;변수&lt;/b&gt; 처럼 가능한 값을 나타내는 대신 실제 &lt;b&gt;값&lt;/b&gt; 을 제공 하는 프로그래밍 언어 (예 : 숫자 또는 &lt;b&gt;문자열)&lt;/b&gt; 의 토큰입니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="49a82ac17323d56d44189291d63111e25b7240b2" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;anyinflate&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">버퍼와 파일 사이에 &quot;원샷 (one-shot)&quot;압축 해제를 수행하기 위해 최상위 기능인 &lt;code&gt;anyinflate&lt;/code&gt; 가 제공됩니다. 압축 해제 프로세스를보다 세밀하게 제어하려면 &lt;a href=&quot;#OO-Interface&quot;&gt;OO 인터페이스&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="87c7fedbb8115b85609fa9659aa296d9a84a6510" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;anyuncompress&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">버퍼와 파일 사이에서 &quot;원샷&quot;압축 해제를 수행하기 위해 최상위 기능인 &lt;code&gt;anyuncompress&lt;/code&gt; 가 제공됩니다. 압축 해제 프로세스를보다 세밀하게 제어하려면 &lt;a href=&quot;#OO-Interface&quot;&gt;OO 인터페이스&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e389addc6410d492c7bd5a5e3cf1e11884bdfd29" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;bunzip2&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">버퍼 및 / 또는 파일간에 &quot;원샷&quot;압축 해제를 수행하기 위해 최상위 기능 &lt;code&gt;bunzip2&lt;/code&gt; 가 제공됩니다. 압축 해제 프로세스를보다 세밀하게 제어하려면 &lt;a href=&quot;#OO-Interface&quot;&gt;OO 인터페이스&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fb0024f5a7eefa6e10161c1ed9db11d9ebbc931e" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;bzip2&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; compression between buffers and/or files. For finer control over the compression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">버퍼 및 / 또는 파일간에 &quot;원샷&quot;압축을 수행하기 위해 최상위 기능인 &lt;code&gt;bzip2&lt;/code&gt; 가 제공됩니다. 압축 프로세스를보다 세밀하게 제어하려면 &lt;a href=&quot;#OO-Interface&quot;&gt;OO 인터페이스&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="565743b74071fd71d3b79fbb653796a00d3b13c8" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;deflate&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; compression between buffers and/or files. For finer control over the compression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">버퍼 및 / 또는 파일간에 &quot;원샷&quot;압축을 수행하기 위해 최상위 기능인 &lt;code&gt;deflate&lt;/code&gt; 이 제공됩니다. 압축 프로세스를보다 세밀하게 제어하려면 &lt;a href=&quot;#OO-Interface&quot;&gt;OO 인터페이스&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9810b58473f41aaf89cef15b62322dda3e22aea6" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;gunzip&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">버퍼 및 / 또는 파일간에 &quot;원샷&quot;압축 해제를 수행하기 위해 최상위 기능인 &lt;code&gt;gunzip&lt;/code&gt; 이 제공됩니다. 압축 해제 프로세스를보다 세밀하게 제어하려면 &lt;a href=&quot;#OO-Interface&quot;&gt;OO 인터페이스&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e6e391619962954b4fb420d746dbc210bda397a8" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;gzip&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; compression between buffers and/or files. For finer control over the compression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">버퍼 및 / 또는 파일간에 &quot;원샷&quot;압축을 수행하기 위해 최상위 기능인 &lt;code&gt;gzip&lt;/code&gt; 이 제공됩니다. 압축 프로세스를보다 세밀하게 제어하려면 &lt;a href=&quot;#OO-Interface&quot;&gt;OO 인터페이스&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb09dcc8a8a7122c93016ac58ef7ca78f87815eb" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;inflate&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">버퍼 및 / 또는 파일간에 &quot;원샷&quot;압축 해제를 수행하기 위해 &lt;code&gt;inflate&lt;/code&gt; 최상위 기능 이 제공됩니다. 압축 해제 프로세스를보다 세밀하게 제어하려면 &lt;a href=&quot;#OO-Interface&quot;&gt;OO 인터페이스&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e6ff8dd50fc057dd45574766e64ed1ef729e4475" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;rawdeflate&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; compression between buffers and/or files. For finer control over the compression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">버퍼 및 / 또는 파일간에 &quot;원샷&quot;압축을 수행하기 위해 최상위 기능인 &lt;code&gt;rawdeflate&lt;/code&gt; 가 제공됩니다. 압축 프로세스를보다 세밀하게 제어하려면 &lt;a href=&quot;#OO-Interface&quot;&gt;OO 인터페이스&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="da007ab4cef02cbdbebe645067fd56f8debb93a1" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;rawinflate&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">버퍼와 파일 사이에 &quot;원샷 (one-shot)&quot;압축 해제를 수행하기 위해 최상위 기능인 &lt;code&gt;rawinflate&lt;/code&gt; 가 제공됩니다. 압축 해제 프로세스를보다 세밀하게 제어하려면 &lt;a href=&quot;#OO-Interface&quot;&gt;OO 인터페이스&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="522a8c4c8a64b09e73f7b19d33d186f1963c38ba" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;unzip&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; uncompression between buffers and/or files. For finer control over the uncompression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">버퍼 및 / 또는 파일간에 &quot;원샷&quot;압축 해제를 수행하기 위해 최상위 기능인 &lt;code&gt;unzip&lt;/code&gt; 이 제공됩니다. 압축 해제 프로세스를보다 세밀하게 제어하려면 &lt;a href=&quot;#OO-Interface&quot;&gt;OO 인터페이스&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cf0562aa58382ee4296c753a78a1efd86d792dc1" translate="yes" xml:space="preserve">
          <source>A top-level function, &lt;code&gt;zip&lt;/code&gt; , is provided to carry out &quot;one-shot&quot; compression between buffers and/or files. For finer control over the compression process, see the &lt;a href=&quot;#OO-Interface&quot;&gt;OO Interface&lt;/a&gt; section.</source>
          <target state="translated">버퍼 및 / 또는 파일간에 &quot;원샷&quot;압축을 수행하기 위해 최상위 기능인 &lt;code&gt;zip&lt;/code&gt; 이 제공됩니다. 압축 프로세스를보다 세밀하게 제어하려면 &lt;a href=&quot;#OO-Interface&quot;&gt;OO 인터페이스&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8b8620967b93bad58d8aa8f79801bf38881ee8c9" translate="yes" xml:space="preserve">
          <source>A totally different approach is to create a hash of function references.</source>
          <target state="translated">완전히 다른 접근법은 함수 참조의 해시를 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="980ba3b61619e7f53950a6b31a7df9b45b72edfd" translate="yes" xml:space="preserve">
          <source>A trailing colon is added automatically to the resulting path, to denote a directory.</source>
          <target state="translated">디렉토리를 표시하기 위해 후미 콜론이 결과 경로에 자동으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="7b8da94bbc0623b636921b1bb640e93b774abc6e" translate="yes" xml:space="preserve">
          <source>A translation-concealed rooted logical name that contains Perl and the logical device for the @INC path on VMS only. Other logical names that affect Perl on VMS include PERLSHR, PERL_ENV_TABLES, and SYS$TIMEZONE_DIFFERENTIAL, but are optional and discussed further in &lt;a href=&quot;perlvms&quot;&gt;perlvms&lt;/a&gt; and in</source>
          <target state="translated">VMS의 @INC 경로에 대한 논리 장치 및 Perl을 포함하는 변환으로 숨겨진 루트 논리 이름입니다. VMS에서 Perl에 영향을주는 다른 논리 이름에는 PERLSHR, PERL_ENV_TABLES 및 SYS $ TIMEZONE_DIFFERENTIAL이 있지만 선택적이며 &lt;a href=&quot;perlvms&quot;&gt;perlvms&lt;/a&gt; 및</target>
        </trans-unit>
        <trans-unit id="2dde805e9629b528928f950f1faf5f6602f0b7c5" translate="yes" xml:space="preserve">
          <source>A trivial application of this mechanism is to implement options that are related to each other. For example:</source>
          <target state="translated">이 메커니즘의 간단한 적용은 서로 관련된 옵션을 구현하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a063d28faa82402e5b2d3d1ed31d0f1ad9c9dea3" translate="yes" xml:space="preserve">
          <source>A tutorial about writing really basic tests</source>
          <target state="translated">정말 기본적인 테스트 작성에 대한 튜토리얼</target>
        </trans-unit>
        <trans-unit id="e89f1de21c226b59a1d42d1a18c10afa08b69645" translate="yes" xml:space="preserve">
          <source>A twice as long string of lowercase hexadecimal digits.</source>
          <target state="translated">소문자 16 진수의 두 배 긴 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="d607f495a88ea6528e8578b9888418a4ffea3288" translate="yes" xml:space="preserve">
          <source>A type definition in the C and C++ languages.</source>
          <target state="translated">C 및 C ++ 언어의 유형 정의</target>
        </trans-unit>
        <trans-unit id="b268ce7d38ddd4cca20a237c3776e2eb1ce567ea" translate="yes" xml:space="preserve">
          <source>A typeglob may be dereferenced the same way a reference can, because the dereference syntax always indicates the type of reference desired. So &lt;code&gt;${*foo}&lt;/code&gt; and &lt;code&gt;${\$foo}&lt;/code&gt; both indicate the same scalar variable.</source>
          <target state="translated">역 참조 구문은 항상 원하는 참조 유형을 나타 내기 때문에 타입 글로브는 참조와 동일한 방식으로 역 참조 될 수 있습니다. 따라서 &lt;code&gt;${*foo}&lt;/code&gt; 와 &lt;code&gt;${\$foo}&lt;/code&gt; 모두 동일한 스칼라 변수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0bd7e8fb31d877d634438bee94398cae29fcf8b9" translate="yes" xml:space="preserve">
          <source>A typical %Lexicon entry is meant to signify a phrase, taking some number (0 or more) of parameters. An entry is meant to be accessed by via a string</source>
          <target state="translated">일반적인 % Lexicon 항목은 매개 변수를 몇 개 (0 개 이상) 사용하여 구를 나타냅니다. 항목은 문자열을 통해 액세스하도록되어 있습니다</target>
        </trans-unit>
        <trans-unit id="8cc65df0ae9490ead8aa8320483d71f0467ec4f8" translate="yes" xml:space="preserve">
          <source>A typical example is:</source>
          <target state="translated">일반적인 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c800528a6e2ea28289c5fcbc08ec77553e110ecf" translate="yes" xml:space="preserve">
          <source>A typical invocation of &lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt; for a pure Perl module is:</source>
          <target state="translated">순수한 Perl 모듈에 대한 &lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt; 의 일반적인 호출 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="74d9b7c164412a45025b12444007449586d960a8" translate="yes" xml:space="preserve">
          <source>A typical module using &lt;a href=&quot;dynaloader&quot;&gt;DynaLoader&lt;/a&gt; starts like this:</source>
          <target state="translated">&lt;a href=&quot;dynaloader&quot;&gt;DynaLoader를&lt;/a&gt; 사용하는 일반적인 모듈 은 다음과 같이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="42c5cd07f5670bfc29c548d8b58ba2ec35dd0a0d" translate="yes" xml:space="preserve">
          <source>A typical one is the version number of your OS specific module. (ie. MM_Unix_VERSION or MM_VMS_VERSION).</source>
          <target state="translated">일반적인 것은 OS 특정 모듈의 버전 번호입니다. (예 : MM_Unix_VERSION 또는 MM_VMS_VERSION).</target>
        </trans-unit>
        <trans-unit id="11ed3b2a4b5cffbd69ae6d23ab2fd650fceaafba" translate="yes" xml:space="preserve">
          <source>A typical use of &lt;code&gt;gen_delimited_pat&lt;/code&gt; would be to build special purpose tags for &lt;code&gt;extract_tagged&lt;/code&gt; . For example, to properly ignore &quot;empty&quot; XML elements (which might contain quoted strings):</source>
          <target state="translated">&lt;code&gt;gen_delimited_pat&lt;/code&gt; 의 일반적인 용도는 &lt;code&gt;extract_tagged&lt;/code&gt; 에 대한 특수 목적 태그를 작성하는 것 입니다. 예를 들어, &quot;빈&quot;XML 요소 (따옴표로 묶인 문자열을 포함 할 수 있음)를 올바르게 무시하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="5f737b1553f7b6183bb539125409a9e3f04fb617" translate="yes" xml:space="preserve">
          <source>A typical use of the returned seed is for a test program which has too many combinations to test comprehensively in the time available to it each run. It can test a random subset each time, and should there be a failure, log the seed used for that run so that it can later be used to reproduce the same results.</source>
          <target state="translated">리턴 된 시드의 일반적인 용도는 각 실행시 사용 가능한 시간에 종합적으로 테스트하기에 너무 많은 조합이있는 테스트 프로그램에 사용됩니다. 매번 무작위 서브 세트를 테스트 할 수 있으며, 실패가 발생하면 해당 실행에 사용 된 시드를 기록하여 나중에 동일한 결과를 재현하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51560cf43fd833f1ac94f4446b3a3eeb2bb8e520" translate="yes" xml:space="preserve">
          <source>A typical use would be in the destructors of a class hierarchy, as illustrated in the synopsis above. Each class in the hierarchy has a DESTROY method that performs some class-specific action and then redispatches the call up the hierarchy. As a result, when an object of class D is destroyed, the destructors of</source>
          <target state="translated">위의 개요에서 설명 된 것처럼 클래스 계층의 소멸자에서 일반적으로 사용됩니다. 계층 구조의 각 클래스에는 일부 클래스 별 작업을 수행 한 다음 호출을 계층 구조로 다시 전달하는 DESTROY 메소드가 있습니다. 결과적으로 클래스 D의 객체가 파괴되면 소멸자는</target>
        </trans-unit>
        <trans-unit id="7966b50132f33654989f9cc4d535a23f71af99df" translate="yes" xml:space="preserve">
          <source>A typical way to define a collation element table without any file of table:</source>
          <target state="translated">테이블 파일없이 데이터 정렬 요소 테이블을 정의하는 일반적인 방법 :</target>
        </trans-unit>
        <trans-unit id="ef22865cf4abb8e03f585fab66316610e54ceffa" translate="yes" xml:space="preserve">
          <source>A useful construct you might consider using is:</source>
          <target state="translated">사용을 고려할 수있는 유용한 구성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c66028a80a3f2cbd725150b289e7fb5dace10a6d" translate="yes" xml:space="preserve">
          <source>A useful idiom for &lt;code&gt;lex&lt;/code&gt; -like scanners is &lt;code&gt;/\G.../gc&lt;/code&gt; . You can combine several regexps like this to process a string part-by-part, doing different actions depending on which regexp matched. Each regexp tries to match where the previous one leaves off.</source>
          <target state="translated">&lt;code&gt;lex&lt;/code&gt; 와 같은 스캐너에 유용한 관용구 는 &lt;code&gt;/\G.../gc&lt;/code&gt; 입니다. 이와 같은 여러 정규 표현식을 결합하여 문자열을 부분적으로 처리하여 일치하는 정규 표현식에 따라 다른 조치를 수행 할 수 있습니다. 각 정규 표현식은 이전의 정규 표현식과 일치하는 부분을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="6c232601ef6ab32c7a06536b5534313e59c1adfb" translate="yes" xml:space="preserve">
          <source>A useful variation of the above is the target &lt;code&gt;testdb&lt;/code&gt; . It runs the test under the Perl debugger (see &lt;a href=&quot;../perldebug&quot;&gt;perldebug&lt;/a&gt;). If the file</source>
          <target state="translated">위의 유용한 변형은 대상 &lt;code&gt;testdb&lt;/code&gt; 입니다. Perl 디버거에서 테스트를 실행합니다 ( &lt;a href=&quot;../perldebug&quot;&gt;perldebug&lt;/a&gt; 참조 ). 파일이</target>
        </trans-unit>
        <trans-unit id="260c8a8479b809c6dd9a69c354f54517ffc43b32" translate="yes" xml:space="preserve">
          <source>A user ID. Often used in the context of &lt;b&gt;file&lt;/b&gt; or &lt;b&gt;process&lt;/b&gt; ownership.</source>
          <target state="translated">사용자 ID &lt;b&gt;파일&lt;/b&gt; 또는 &lt;b&gt;프로세스&lt;/b&gt; 소유권 과 관련하여 종종 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c3c861709ec338f51d30ce5477159ff491c5825e" translate="yes" xml:space="preserve">
          <source>A user of Perl does not normally need to know nor care how Perl happens to encode its internal strings, but it becomes relevant when outputting Unicode strings to a stream without a PerlIO layer (one with the &quot;default&quot; encoding). In such a case, the raw bytes used internally (the native character set or UTF-8, as appropriate for each string) will be used, and a &quot;Wide character&quot; warning will be issued if those strings contain a character beyond 0x00FF.</source>
          <target state="translated">Perl 사용자는 일반적으로 Perl이 내부 문자열을 인코딩하는 방법을 알거나 신경 쓸 필요가 없지만 PerlIO 레이어가없는 스트림 ( &quot;기본&quot;인코딩이있는 스트림)으로 유니 코드 문자열을 출력 할 때는 관련이 있습니다. 이 경우 내부적으로 사용되는 원시 바이트 (각 문자열에 적합한 고유 문자 세트 또는 UTF-8)가 사용되며 해당 문자열에 0x00FF 이상의 문자가 포함 된 경우 &quot;와이드 문자&quot;경고가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="58e51e01dfdc97593c823ef9c32c82bf5b645a0e" translate="yes" xml:space="preserve">
          <source>A user-defined &lt;b&gt;type&lt;/b&gt;, implemented in Perl via a &lt;b&gt;package&lt;/b&gt; that provides (either directly or by inheritance) &lt;b&gt;methods&lt;/b&gt; (that is, &lt;b&gt;subroutines&lt;/b&gt;) to handle &lt;b&gt;instances&lt;/b&gt; of the class (its &lt;b&gt;objects&lt;/b&gt;). See also &lt;b&gt;inheritance&lt;/b&gt;.</source>
          <target state="translated">사용자 정의 &lt;b&gt;형&lt;/b&gt; 비아 펄 구현 &lt;b&gt;패키지&lt;/b&gt; (직접 또는 상속에 의해) 제공 &lt;b&gt;방법&lt;/b&gt; (즉, &lt;b&gt;서브 루틴&lt;/b&gt; ) 처리하는 &lt;b&gt;인스턴스&lt;/b&gt; 클래스 (그것의 &lt;b&gt;개체&lt;/b&gt; ). &lt;b&gt;상속&lt;/b&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="049b62081eecdd58978da0961ea176048425ca09" translate="yes" xml:space="preserve">
          <source>A user-defined subroutine call or a method invocation.</source>
          <target state="translated">사용자 정의 서브 루틴 호출 또는 메소드 호출</target>
        </trans-unit>
        <trans-unit id="0655aa7eaac426bb455567c21c49258161952382" translate="yes" xml:space="preserve">
          <source>A utility function that returns the line number that the function was called on. You can pass it an offset which will be added to the result. This is very useful for working out the correct text of diagnostic functions that contain line numbers.</source>
          <target state="translated">함수가 호출 된 행 번호를 리턴하는 유틸리티 함수입니다. 결과에 추가 될 오프셋을 전달할 수 있습니다. 줄 번호가 포함 된 올바른 진단 기능 텍스트를 작성하는 데 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="62abf9744bbb54e44124db26e468de26dab74a60" translate="yes" xml:space="preserve">
          <source>A value indicating whether unmatched substrings (see below) within the text should be skipped or returned as fields. If the value is true, such substrings are skipped. Otherwise, they are returned.</source>
          <target state="translated">텍스트 내에서 일치하지 않는 하위 문자열 (아래 참조)을 건너 뛰거나 필드로 반환해야하는지 여부를 나타내는 값입니다. 값이 true이면 해당 하위 문자열을 건너 뜁니다. 그렇지 않으면 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9cb7aeb0b53152f8df982c234ecceb419398cf71" translate="yes" xml:space="preserve">
          <source>A value that happens to be a &lt;b&gt;scalar&lt;/b&gt; as opposed to a &lt;b&gt;list&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;리스트&lt;/b&gt; 와는 반대로 &lt;b&gt;스칼라&lt;/b&gt; 가되는 값입니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6cfc7b273de973b6dc0aacfe92aeb280b49228f1" translate="yes" xml:space="preserve">
          <source>A value that is either &lt;b&gt;true&lt;/b&gt; or &lt;b&gt;false&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;true&lt;/b&gt; 또는 &lt;b&gt;false&lt;/b&gt; 값입니다 .</target>
        </trans-unit>
        <trans-unit id="a8f81a2763e41d6e30e66f64538647929ee6a4a5" translate="yes" xml:space="preserve">
          <source>A variable whose value is the name of another variable or subroutine. By &lt;b&gt;dereferencing&lt;/b&gt; the first variable, you can get at the second one. Symbolic references are illegal under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict &quot;refs&quot;&lt;/code&gt; .</source>
          <target state="translated">값이 다른 변수 또는 서브 루틴의 이름 인 변수. 첫 번째 변수 를 &lt;b&gt;역 참조&lt;/b&gt; 하면 두 번째 변수를 얻을 수 있습니다. 기호 참조는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict &quot;refs&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca6ffd45b1cb28ce9dd386af1f375ee5391518d5" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;save_item&lt;/code&gt; which takes multiple arguments via an array &lt;code&gt;sarg&lt;/code&gt; of &lt;code&gt;SV*&lt;/code&gt; of length &lt;code&gt;maxsarg&lt;/code&gt; .</source>
          <target state="translated">길이가 &lt;code&gt;maxsarg&lt;/code&gt; 인 &lt;code&gt;SV*&lt;/code&gt; 의 배열 &lt;code&gt;sarg&lt;/code&gt; 를 통해 여러 인수를 취하는 &lt;code&gt;save_item&lt;/code&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="7ccb1828da7b95bb5a049529fa23b72700a0cdfc" translate="yes" xml:space="preserve">
          <source>A venerable Stream EDitor from which Perl derives some of its ideas.</source>
          <target state="translated">Perl이 아이디어를 도출 할 수있는 훌륭한 스트림 교육자.</target>
        </trans-unit>
        <trans-unit id="695b604bb0917e749e0123615e9c577cb0315edf" translate="yes" xml:space="preserve">
          <source>A venerable typesetting language from which Perl derives the name of its &lt;code&gt;$%&lt;/code&gt; variable and which is secretly used in the production of Camel books.</source>
          <target state="translated">Perl이 &lt;code&gt;$%&lt;/code&gt; 변수 의 이름을 파생시키고 Camel 서적 제작에 비밀리에 사용되는 훌륭한 조판 언어 .</target>
        </trans-unit>
        <trans-unit id="c02ac9d5e79aa52379337adc725d78150bf24188" translate="yes" xml:space="preserve">
          <source>A verbatim paragraph is distinguished by having its first character be a space or a tab. (And commonly, all its lines begin with spaces and/or tabs.) It should be reproduced exactly, with tabs assumed to be on 8-column boundaries. There are no special formatting codes, so you can't italicize or anything like that. A \ means \, and nothing else.</source>
          <target state="translated">축약어 단락은 첫 문자를 공백 또는 탭으로 구분합니다. 일반적으로 모든 선은 공백 및 / 또는 탭으로 시작합니다. 탭은 8 열 경계에있는 것으로 가정하여 정확하게 재현해야합니다. 특별한 형식 코드가 없으므로 기울임 꼴 또는 이와 유사한 것을 사용할 수 없습니다. A는 \를 의미하며, 다른 것은 없습니다.</target>
        </trans-unit>
        <trans-unit id="b4ee89b787aaa148bf4a7c02399965cde2c89e83" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;SvPV&lt;/code&gt; which guarantees to evaluate &lt;code&gt;sv&lt;/code&gt; only once. Only use this if &lt;code&gt;sv&lt;/code&gt; is an expression with side effects, otherwise use the more efficient &lt;code&gt;SvPV&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;sv&lt;/code&gt; 를 한 번만 평가하도록 보장하는 &lt;code&gt;SvPV&lt;/code&gt; 버전 . &lt;code&gt;sv&lt;/code&gt; 가 부작용이있는 표현식 인 경우에만 사용 하고 그렇지 않으면보다 효율적인 &lt;code&gt;SvPV&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="800c2c1c70843eecf0d954a2a74fcb4ffc03b783" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;savepv()&lt;/code&gt; /&lt;code&gt;savepvn()&lt;/code&gt; which gets the string to duplicate from the passed in SV using &lt;code&gt;SvPV()&lt;/code&gt;</source>
          <target state="translated">(A)의 버전 &lt;code&gt;savepv()&lt;/code&gt; / &lt;code&gt;savepvn()&lt;/code&gt; 문자열을 얻는다 사용하여 SV 전달에서 복제하기 &lt;code&gt;SvPV()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="89a4a2fa99f32dbf2c67191e1f912497d7b97772" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;savepv()&lt;/code&gt; which allocates the duplicate string in memory which is shared between threads.</source>
          <target state="translated">스레드간에 공유되는 메모리에 중복 문자열을 할당하는 &lt;code&gt;savepv()&lt;/code&gt; 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="5d7f6a9127b04f3a28923aa726cf029e923caeca" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;savepvn()&lt;/code&gt; which allocates the duplicate string in memory which is shared between threads. (With the specific difference that a NULL pointer is not acceptable)</source>
          <target state="translated">스레드간에 공유되는 메모리에 중복 문자열을 할당하는 &lt;code&gt;savepvn()&lt;/code&gt; 버전입니다 . (NULL 포인터가 허용되지 않는다는 구체적인 차이점이 있음)</target>
        </trans-unit>
        <trans-unit id="d9a7ac8d6bb6f23e5af260b2b68521de71f4974c" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;savepvs()&lt;/code&gt; which allocates the duplicate string in memory which is shared between threads.</source>
          <target state="translated">스레드간에 공유되는 메모리에 중복 문자열을 할당하는 &lt;code&gt;savepvs()&lt;/code&gt; 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="f84e0230ffdad6c151bf74824e07538ecfccd8ed" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;savesharedpv()&lt;/code&gt; which allocates the duplicate string in memory which is shared between threads.</source>
          <target state="translated">스레드간에 공유되는 메모리에 중복 문자열을 할당하는 &lt;code&gt;savesharedpv()&lt;/code&gt; 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="8ab5e633d2c66281cffd9c60de281036938368fe" translate="yes" xml:space="preserve">
          <source>A very complete generic buffering layer which provides the whole of PerlIO API. It is also intended to be used as a &quot;base class&quot; for other layers. (For example its &lt;code&gt;Read()&lt;/code&gt; method is implemented in terms of the &lt;code&gt;Get_cnt()&lt;/code&gt; /&lt;code&gt;Get_ptr()&lt;/code&gt; /&lt;code&gt;Set_ptrcnt()&lt;/code&gt; methods).</source>
          <target state="translated">PerlIO API 전체를 제공하는 매우 완벽한 일반 버퍼링 계층입니다. 또한 다른 레이어의 &quot;기본 클래스&quot;로 사용되도록 고안되었습니다. (예를 들어 &lt;code&gt;Read()&lt;/code&gt; 메소드는 &lt;code&gt;Get_cnt()&lt;/code&gt; / &lt;code&gt;Get_ptr()&lt;/code&gt; / &lt;code&gt;Set_ptrcnt()&lt;/code&gt; 메소드로 구현됩니다).</target>
        </trans-unit>
        <trans-unit id="cff43b9c47bd071d2d320e539e7c2ec5b836b1af" translate="yes" xml:space="preserve">
          <source>A very large and constantly evolving language with several alternative and largely incompatible syntaxes, in which anyone can define anything any way they choose, and usually do. Speakers of this language think it&amp;rsquo;s easy to learn because it&amp;rsquo;s so easily twisted to one&amp;rsquo;s own ends, but dialectical differences make tribal intercommunication nearly impossible, and travelers are often reduced to a pidgin-like subset of the language. To be universally understood, a Unix shell programmer must spend years of study in the art. Many have abandoned this discipline and now communicate via an Esperanto-like language called Perl.</source>
          <target state="translated">누구든지 원하는 방식으로 정의하고 일반적으로 수행 할 수있는 몇 가지 대체적이고 대체적으로 호환되지 않는 구문이 포함 된 매우 크고 지속적으로 발전하는 언어입니다. 이 언어를 사용하는 사람들은 자신의 목적에 따라 쉽게 뒤 틀릴 수 있기 때문에 배우기 쉽다고 생각하지만 변증 법적 차이로 인해 부족의 의사 소통이 거의 불가능 해지며 여행자는 종종 언어와 같은 언어의 하위 집합으로 축소됩니다. 보편적으로 이해되기 위해서는 유닉스 쉘 프로그래머가이 분야에서 수년간의 연구를해야합니다. 많은 사람들이이 규율을 버리고 이제는 Perl이라는 에스페란토와 같은 언어를 통해 의사 소통을합니다.</target>
        </trans-unit>
        <trans-unit id="b75485a79ff1cabe11e71e2c78ee68045837b121" translate="yes" xml:space="preserve">
          <source>A very thin wrapper around Config.pm so MakeMaker is easier to test.</source>
          <target state="translated">Config.pm 주변의 매우 얇은 래퍼이므로 MakeMaker를 쉽게 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3816dce510c914716ac16326960ce66f1b1eab28" translate="yes" xml:space="preserve">
          <source>A void* pointing to an engine-defined data structure. The Perl engine uses the &lt;code&gt;regexp_internal&lt;/code&gt; structure (see &lt;a href=&quot;perlreguts#Base-Structures&quot;&gt;Base Structures in perlreguts&lt;/a&gt;) but a custom engine should use something else.</source>
          <target state="translated">엔진 정의 데이터 구조를 가리키는 void * Perl 엔진은 &lt;code&gt;regexp_internal&lt;/code&gt; 구조 ( perlreguts의 &lt;a href=&quot;perlreguts#Base-Structures&quot;&gt;기본 구조&lt;/a&gt; 참조 )를 사용하지만 사용자 정의 엔진은 다른 것을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="199fcb36f761477b8bc11025866dc8da66f59cd6" translate="yes" xml:space="preserve">
          <source>A walled off area that&amp;rsquo;s not supposed to affect beyond its walls. You let kids play in the sandbox instead of running in the road. See Camel chapter 20, &amp;ldquo;Security&amp;rdquo;.</source>
          <target state="translated">벽 너머에 영향을 미치지 않는 벽으로 둘러싸인 지역. 아이들은 도로에서 달리지 않고 샌드 박스에서 놀 수 있습니다. 낙타 20 장 &quot;보안&quot;을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="52bce4e77f028ccf4be5e2732e6cc0cda9d45ce4" translate="yes" xml:space="preserve">
          <source>A warning is issued if an attempt is made to register an operator not found above.</source>
          <target state="translated">위에서 찾을 수없는 운영자를 등록하려고하면 경고가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="a18ef0b74f65545d966263b3d3c2472e8453a59c" translate="yes" xml:space="preserve">
          <source>A warning is printed if more than one POD file with the same POD name is found, e.g.</source>
          <target state="translated">동일한 POD 이름을 가진 둘 이상의 POD 파일이 발견되면 경고가 인쇄됩니다 (예 :</target>
        </trans-unit>
        <trans-unit id="700f87e210bceec8357a7b2e426634dd3d25de48" translate="yes" xml:space="preserve">
          <source>A well-defined sequence of steps, explained clearly enough that even a computer could do them.</source>
          <target state="translated">잘 정의 된 일련의 단계는 컴퓨터조차도 수행 할 수있을 정도로 명확하게 설명되었습니다.</target>
        </trans-unit>
        <trans-unit id="69583ba800841309993f3cd8027c2138231fdd98" translate="yes" xml:space="preserve">
          <source>A whiz-bang hardware gizmo (like a disk or tape drive or a modem or a joystick or a mouse) attached to your computer, which the &lt;b&gt;operating system&lt;/b&gt; tries to make look like a &lt;b&gt;file&lt;/b&gt; (or a bunch of files). Under Unix, these fake files tend to live in the</source>
          <target state="translated">&lt;b&gt;운영 체제&lt;/b&gt; 가 &lt;b&gt;파일&lt;/b&gt; (또는 여러 파일) 처럼 보이도록 컴퓨터에 부착 된 위즈 뱅 하드웨어 기즈모 (예 : 디스크 또는 테이프 드라이브 또는 모뎀 또는 조이스틱 또는 마우스) 유닉스에서 이러한 가짜 파일은</target>
        </trans-unit>
        <trans-unit id="90dbb683e595bd8a442976ee525366f34cadb549" translate="yes" xml:space="preserve">
          <source>A word boundary (&lt;code&gt;\b&lt;/code&gt; ) is a spot between two characters that has a &lt;code&gt;\w&lt;/code&gt; on one side of it and a &lt;code&gt;\W&lt;/code&gt; on the other side of it (in either order), counting the imaginary characters off the beginning and end of the string as matching a &lt;code&gt;\W&lt;/code&gt; . (Within character classes &lt;code&gt;\b&lt;/code&gt; represents backspace rather than a word boundary, just as it normally does in any double-quoted string.) The &lt;code&gt;\A&lt;/code&gt; and &lt;code&gt;\Z&lt;/code&gt; are just like &quot;^&quot; and &quot;$&quot;, except that they won't match multiple times when the &lt;code&gt;/m&lt;/code&gt; modifier is used, while &quot;^&quot; and &quot;$&quot; will match at every internal line boundary. To match the actual end of the string and not ignore an optional trailing newline, use &lt;code&gt;\z&lt;/code&gt; .</source>
          <target state="translated">단어 경계 ( &lt;code&gt;\b&lt;/code&gt; )를 갖는 두 자의 스포트 &lt;code&gt;\w&lt;/code&gt; 그것과의 한쪽 &lt;code&gt;\W&lt;/code&gt; (두 순서로), 그것의 다른쪽에는 시작과 끝 오프 허수 문자 카운팅 &lt;code&gt;\W&lt;/code&gt; 와 일치하는 문자열 . 문자 클래스 내에서 &lt;code&gt;\b&lt;/code&gt; 는 일반적으로 큰 따옴표로 묶인 문자열에서와 같이 단어 경계가 아닌 백 스페이스를 나타냅니다. &lt;code&gt;\A&lt;/code&gt; 및 &lt;code&gt;\Z&lt;/code&gt; 는 &quot;^&quot;및 &quot;$&quot;와 같습니다. &lt;code&gt;/m&lt;/code&gt; 수정자를 사용 하면 여러 번 일치 하지만 &quot;^&quot;및 &quot;$&quot;는 모든 내부 줄 경계에서 일치합니다. 문자열의 실제 끝과 일치하고 선택적 후행 줄 바꿈을 무시하지 않으려면사용하다 &lt;code&gt;\z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9f5130c323d4b84b2e0887ec7513db659cf437f" translate="yes" xml:space="preserve">
          <source>A word on terminology: I shall use the term</source>
          <target state="translated">용어에 관한 단어 : 나는 그 용어를 사용할 것이다</target>
        </trans-unit>
        <trans-unit id="b1c5343ffbdad1e7ce4b8c849341bcb5442f07e1" translate="yes" xml:space="preserve">
          <source>A word sufficiently ambiguous to be deemed illegal under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'subs'&lt;/code&gt; . In the absence of that stricture, a bareword is treated as if quotes were around it.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'subs'&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용하는 경우&lt;/a&gt; 불법으로 간주 될 정도로 모호한 단어 . 그 엄격함이 없으면, 따옴표가 그 주위에있는 것처럼 취급합니다.</target>
        </trans-unit>
        <trans-unit id="310f40f7f3f90c12a6b195eedcb48c5f8026ea77" translate="yes" xml:space="preserve">
          <source>A word that has no other interpretation in the grammar will be treated as if it were a quoted string. These are known as &quot;barewords&quot;. As with filehandles and labels, a bareword that consists entirely of lowercase letters risks conflict with future reserved words, and if you use the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; switch, Perl will warn you about any such words. Perl limits barewords (like identifiers) to about 250 characters. Future versions of Perl are likely to eliminate these arbitrary limitations.</source>
          <target state="translated">문법에 다른 해석이없는 단어는 인용 문자열 인 것처럼 처리됩니다. 이것을 &quot;베어 워드&quot;라고합니다. 파일 핸들 및 레이블과 마찬가지로 완전히 소문자로 구성된 베어 워드는 향후 예약어와 충돌 할 수 있으며 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma 또는 &lt;b&gt;-w&lt;/b&gt; 스위치를 사용하면 Perl이 해당 단어에 대해 경고합니다. Perl은 식별자와 같은 베어 워드를 약 250 자로 제한합니다. 이후 버전의 Perl은 이러한 임의의 제한을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41517852ad5f31fc26a5aada0fdb82adad0543c7" translate="yes" xml:space="preserve">
          <source>A word with a specific, built-in meaning to a &lt;b&gt;compiler&lt;/b&gt;, such as &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt;. In many languages (not Perl), it&amp;rsquo;s illegal to use reserved words to name anything else. (Which is why they&amp;rsquo;re reserved, after all.) In Perl, you just can&amp;rsquo;t use them to name &lt;b&gt;labels&lt;/b&gt; or &lt;b&gt;filehandles&lt;/b&gt;. Also called &amp;ldquo;keywords&amp;rdquo;.</source>
          <target state="translated">특정와 단어, 내장의 의미를 &lt;b&gt;컴파일러&lt;/b&gt; 와 같은, &lt;code&gt;if&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; . Perl이 아닌 많은 언어에서 예약어를 사용하여 다른 이름을 지정하는 것은 불법입니다. (결국 예약 된 이유는 무엇입니까?) Perl에서는 &lt;b&gt;레이블&lt;/b&gt; 이나 &lt;b&gt;파일 핸들의&lt;/b&gt; 이름을 지정할 수 없습니다 . &amp;ldquo;키워드&amp;rdquo;라고도합니다.</target>
        </trans-unit>
        <trans-unit id="435e32d3ce964aedd25193932afab04e1daf13f7" translate="yes" xml:space="preserve">
          <source>A work-around is the following:</source>
          <target state="translated">해결 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="07daf0448b91b826afed53a20124ecc976475c82" translate="yes" xml:space="preserve">
          <source>A workaround for this is to call the constants once in a &lt;code&gt;BEGIN&lt;/code&gt; block:</source>
          <target state="translated">이에 대한 해결 방법은 &lt;code&gt;BEGIN&lt;/code&gt; 블록 에서 상수를 한 번 호출하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="c5d091eede565087a31db8b62e48d4dd20b23599" translate="yes" xml:space="preserve">
          <source>A working knowledge of XSUB programming is incredibly useful for core hacking; XSUBs use techniques drawn from the PP code, the portion of the guts that actually executes a Perl program. It's a lot gentler to learn those techniques from simple examples and explanation than from the core itself.</source>
          <target state="translated">XSUB 프로그래밍에 대한 실무 지식은 코어 해킹에 매우 유용합니다. XSUB는 실제로 Perl 프로그램을 실행하는 내장 부분 인 PP 코드에서 가져온 기술을 사용합니다. 핵심 자체보다 간단한 예제와 설명을 통해 이러한 기술을 배우는 것이 훨씬 더 순조 롭습니다.</target>
        </trans-unit>
        <trans-unit id="ecdab41b6d91aa8f615325452505a14f3756b711" translate="yes" xml:space="preserve">
          <source>A wrapper around ExtUtils::Install::uninstall(). Warns that uninstallation is deprecated and doesn't actually perform the uninstallation.</source>
          <target state="translated">ExtUtils :: Install :: uninstall ()을 감싸는 래퍼입니다. 제거가 더 이상 사용되지 않으며 실제로 제거를 수행하지 않음을 경고합니다.</target>
        </trans-unit>
        <trans-unit id="7b1bd466739a9d9dd8c4b1931d422a782c699350" translate="yes" xml:space="preserve">
          <source>A wrapper for &lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI&lt;/a&gt;&lt;code&gt;fetchrow_array&lt;/code&gt; and &lt;code&gt;fetchrow_hashref&lt;/code&gt;</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI &lt;/a&gt; &lt;code&gt;fetchrow_array&lt;/code&gt; 및 &lt;code&gt;fetchrow_hashref&lt;/code&gt; 의 랩퍼</target>
        </trans-unit>
        <trans-unit id="1d7f5dea12f6359a6636612f15ad99428ef6c1b4" translate="yes" xml:space="preserve">
          <source>A wrapper for the combination of &lt;code&gt;normalize()&lt;/code&gt; and &lt;code&gt;splitOnLastStarter()&lt;/code&gt; . Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="translated">&lt;code&gt;normalize()&lt;/code&gt; 및 &lt;code&gt;splitOnLastStarter()&lt;/code&gt; 의 조합을위한 래퍼입니다 . 참고 &lt;code&gt;$unprocessed&lt;/code&gt; 부작용으로 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="9a971835f0cc905c4c81e0e15a1789f5da379aa1" translate="yes" xml:space="preserve">
          <source>A wrapper of pack_sockaddr_in() or unpack_sockaddr_in(). In list context, unpacks its argument and returns a list consisting of the port and IP address. In scalar context, packs its port and IP address arguments as a &lt;code&gt;sockaddr_in&lt;/code&gt; and returns it.</source>
          <target state="translated">pack_sockaddr_in () 또는 unpack_sockaddr_in ()의 랩퍼. 목록 컨텍스트에서 인수의 압축을 풀고 포트와 IP 주소로 구성된 목록을 반환합니다. 스칼라 컨텍스트에서 포트 및 IP 주소 인수를 &lt;code&gt;sockaddr_in&lt;/code&gt; 으로 압축하여 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7da94d0b3d719c597383180b871afe1e809e7e59" translate="yes" xml:space="preserve">
          <source>A wrapper of pack_sockaddr_in6() or unpack_sockaddr_in6(). In list context, unpacks its argument according to unpack_sockaddr_in6(). In scalar context, packs its arguments according to pack_sockaddr_in6().</source>
          <target state="translated">pack_sockaddr_in6 () 또는 unpack_sockaddr_in6 ()의 랩퍼. 목록 컨텍스트에서 unpack_sockaddr_in6 ()에 따라 인수의 압축을 풉니 다. 스칼라 컨텍스트에서 pack_sockaddr_in6 ()에 따라 인수를 압축합니다.</target>
        </trans-unit>
        <trans-unit id="53a1600cfdb74295cdddc3a0923b5ac6c8e36129" translate="yes" xml:space="preserve">
          <source>A wrapper of pack_sockaddr_un() or unpack_sockaddr_un(). In a list context, unpacks its argument and returns a list consisting of the pathname. In a scalar context, packs its pathname as a &lt;code&gt;sockaddr_un&lt;/code&gt; and returns it.</source>
          <target state="translated">pack_sockaddr_un () 또는 unpack_sockaddr_un ()의 랩퍼. 목록 컨텍스트에서 인수의 압축을 풀고 경로 이름으로 구성된 목록을 반환합니다. 스칼라 컨텍스트에서 경로 이름을 &lt;code&gt;sockaddr_un&lt;/code&gt; 으로 압축하여 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7fe6b1e666d9c00f78d39c2310ecc107997b967e" translate="yes" xml:space="preserve">
          <source>A zero is represented and returned as &lt;code&gt;0E1&lt;/code&gt; , &lt;b&gt;not&lt;/b&gt;&lt;code&gt;0E0&lt;/code&gt; (after Knuth).</source>
          <target state="translated">제로가 대표로 반환 &lt;code&gt;0E1&lt;/code&gt; , &lt;b&gt;하지 &lt;/b&gt; &lt;code&gt;0E0&lt;/code&gt; (누스 후).</target>
        </trans-unit>
        <trans-unit id="779899a127457434de92416389106f3b75e672b1" translate="yes" xml:space="preserve">
          <source>A zero return value of &amp;amp;Time::HiRes::d_hires_stat means that Time::HiRes::stat is a no-op passthrough for CORE::stat() (and likewise for lstat), and therefore the timestamps will stay integers. The same thing will happen if the filesystem does not do subsecond timestamps, even if the &amp;amp;Time::HiRes::d_hires_stat is non-zero.</source>
          <target state="translated">&amp;amp; Time :: HiRes :: d_hires_stat의 리턴 값이 0이면 Time :: HiRes :: stat는 CORE :: stat ()에 대한 no-op 패스 스루이며 lstat에 대해서도 마찬가지이므로 타임 스탬프는 정수로 유지됩니다. &amp;amp; Time :: HiRes :: d_hires_stat가 0이 아닌 경우에도 파일 시스템이 1 초 미만의 타임 스탬프를 수행하지 않는 경우에도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="8e38756e4b48f666771b0184686ead868d8da345" translate="yes" xml:space="preserve">
          <source>A zero-width negative look-ahead assertion. For example &lt;code&gt;/foo(?!bar)/&lt;/code&gt; matches any occurrence of &quot;foo&quot; that isn't followed by &quot;bar&quot;. Note however that look-ahead and look-behind are NOT the same thing. You cannot use this for look-behind.</source>
          <target state="translated">폭이 0 인 마이너스 미리보기 어설 션. 예를 들어 &lt;code&gt;/foo(?!bar)/&lt;/code&gt; 는 &quot;bar&quot;다음에 나오는 &quot;foo&quot;와 일치합니다. 그러나 미리보기와 뒤로보기는 같은 것이 아닙니다. 뒤보기에는 이것을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d3ff01c027bf2326d7c975449071a13cc0fdc9c3" translate="yes" xml:space="preserve">
          <source>A zero-width negative look-behind assertion. For example &lt;code&gt;/(?&amp;lt;!bar)foo/&lt;/code&gt; matches any occurrence of &quot;foo&quot; that does not follow &quot;bar&quot;. Works only for fixed-width look-behind.</source>
          <target state="translated">너비가 0 인 음수 룩 어설 션. 예를 들어 &lt;code&gt;/(?&amp;lt;!bar)foo/&lt;/code&gt; 는 &quot;bar&quot;뒤에 오지 않는 &quot;foo&quot;와 일치합니다. 고정 너비 룩백에만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="31c71ae629ab72f59da90b044b041a0f3f38fe68" translate="yes" xml:space="preserve">
          <source>A zero-width positive look-ahead assertion. For example, &lt;code&gt;/\w+(?=\t)/&lt;/code&gt; matches a word followed by a tab, without including the tab in &lt;code&gt;$&amp;amp;&lt;/code&gt; .</source>
          <target state="translated">너비가 0 인 양수의 미리보기 어설 션입니다. 예를 들어, &lt;code&gt;/\w+(?=\t)/&lt;/code&gt; 는 &lt;code&gt;$&amp;amp;&lt;/code&gt; 탭을 포함하지 않고 단어 뒤에 탭이 오는 단어와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="65fa5c05e8082d01af830ede3afa1f43dd6607a8" translate="yes" xml:space="preserve">
          <source>A zero-width positive look-behind assertion. For example, &lt;code&gt;/(?&amp;lt;=\t)\w+/&lt;/code&gt; matches a word that follows a tab, without including the tab in &lt;code&gt;$&amp;amp;&lt;/code&gt; . Works only for fixed-width look-behind.</source>
          <target state="translated">너비가 0 인 양수 룩 어설 션. 예를 들어, &lt;code&gt;/(?&amp;lt;=\t)\w+/&lt;/code&gt; 는 &lt;code&gt;$&amp;amp;&lt;/code&gt; 탭을 포함시키지 않고 탭 뒤에 나오는 단어와 일치합니다 . 고정 너비 룩백에만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="34bdd106971288a6d920c5cf05705981d574d0c4" translate="yes" xml:space="preserve">
          <source>A. DECOMPRESS</source>
          <target state="translated">A. 감압</target>
        </trans-unit>
        <trans-unit id="1ff759f92b74a05e1658516dbd8457b5a3483f7c" translate="yes" xml:space="preserve">
          <source>ABBREVIATIONS</source>
          <target state="translated">ABBREVIATIONS</target>
        </trans-unit>
        <trans-unit id="673a41f0cf51b17cfeaeef5b1ad0748f98430d4f" translate="yes" xml:space="preserve">
          <source>ABOUT EXTENDING POD</source>
          <target state="translated">포드 확장 정보</target>
        </trans-unit>
        <trans-unit id="dd2cb5069032eb76d119d2ed0164eb2a9e7c70ab" translate="yes" xml:space="preserve">
          <source>ABOUT LANGUAGE TAGS</source>
          <target state="translated">언어 태그 정보</target>
        </trans-unit>
        <trans-unit id="848db58438feb5d786eb1289cbafc6268e9d9307" translate="yes" xml:space="preserve">
          <source>ABOUT LOWERCASING</source>
          <target state="translated">하강에 대하여</target>
        </trans-unit>
        <trans-unit id="0bdf7f8075cb4fb7b28aefb1a128e561b3a0c204" translate="yes" xml:space="preserve">
          <source>ABOUT UNICODE PLAINTEXT LANGUAGE TAGS</source>
          <target state="translated">유니 코드 일반 텍스트 태그 정보</target>
        </trans-unit>
        <trans-unit id="e29c6cbd184a79deb8c1a9f477b3e3ad1f42e851" translate="yes" xml:space="preserve">
          <source>ABSTRACT</source>
          <target state="translated">ABSTRACT</target>
        </trans-unit>
        <trans-unit id="8e85cf5fbe6cfb533ae13301a76848fd25437a12" translate="yes" xml:space="preserve">
          <source>ACCESS</source>
          <target state="translated">ACCESS</target>
        </trans-unit>
        <trans-unit id="5250769dfb1b93d9576c113491830191c4db1d11" translate="yes" xml:space="preserve">
          <source>ACCESSING ZIP FILES</source>
          <target state="translated">ZIP 파일 액세스</target>
        </trans-unit>
        <trans-unit id="fcc3d0a1b75c8feef5b7b1c653cf0ea340c392c6" translate="yes" xml:space="preserve">
          <source>ACCESSOR METHODS</source>
          <target state="translated">액세서 방법</target>
        </trans-unit>
        <trans-unit id="60a7c20aebd64a886444bdd90a1b11f97a4a1e06" translate="yes" xml:space="preserve">
          <source>ACCESSORS</source>
          <target state="translated">ACCESSORS</target>
        </trans-unit>
        <trans-unit id="0ba6c220aaa591706073278a9ad280fa2fd653a4" translate="yes" xml:space="preserve">
          <source>ACCURACY and PRECISION</source>
          <target state="translated">정확성과 정밀성</target>
        </trans-unit>
        <trans-unit id="2cdc7ae734b454aa9217c09256c5559e6d697319" translate="yes" xml:space="preserve">
          <source>ACKNOWLEDGEMENTS</source>
          <target state="translated">ACKNOWLEDGEMENTS</target>
        </trans-unit>
        <trans-unit id="923060090571fbfd68775d7a6ad521d2f148ca46" translate="yes" xml:space="preserve">
          <source>ACKNOWLEDGMENTS</source>
          <target state="translated">ACKNOWLEDGMENTS</target>
        </trans-unit>
        <trans-unit id="44d15b33e9bdfa8cf1ced5727e4a50f9110eab0b" translate="yes" xml:space="preserve">
          <source>ADDITIONAL FUNCTIONS</source>
          <target state="translated">추가 기능</target>
        </trans-unit>
        <trans-unit id="377c8694e808f226461dfc561f7463499e97731b" translate="yes" xml:space="preserve">
          <source>ADDITIONAL LIBRARIES</source>
          <target state="translated">추가 라이브러리</target>
        </trans-unit>
        <trans-unit id="97b832ba91bb860f61c453123e346196e469e726" translate="yes" xml:space="preserve">
          <source>ADDR should be &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; unless you really know what you're doing.</source>
          <target state="translated">ADDR은해야 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 당신이 정말 당신이 무슨 일을하는지 알지 못한다.</target>
        </trans-unit>
        <trans-unit id="55ecbd212eaf4944bfe6cc43f71cd52a01caf60b" translate="yes" xml:space="preserve">
          <source>ADDRESSES</source>
          <target state="translated">ADDRESSES</target>
        </trans-unit>
        <trans-unit id="64ec98c40972fdf68514c8da070992ffcab12ce8" translate="yes" xml:space="preserve">
          <source>ADVANCED METHODS</source>
          <target state="translated">고급 방법</target>
        </trans-unit>
        <trans-unit id="afb2b77214c93a1bf72d1a922cac35289d58c3c4" translate="yes" xml:space="preserve">
          <source>ADVISORY LOCKING</source>
          <target state="translated">조언 잠금</target>
        </trans-unit>
        <trans-unit id="97e745db372f952a45b14d78a0e017557b75da5f" translate="yes" xml:space="preserve">
          <source>AFS users</source>
          <target state="translated">AFS 사용자</target>
        </trans-unit>
        <trans-unit id="aedfd73052985c2f41211e623add2af653060807" translate="yes" xml:space="preserve">
          <source>AFTER</source>
          <target state="translated">AFTER</target>
        </trans-unit>
        <trans-unit id="496da957ccecd43014881eeb7de2e7be00a8b83f" translate="yes" xml:space="preserve">
          <source>AF_INET, AF_INET6, AF_UNIX, ...</source>
          <target state="translated">AF_INET, AF_INET6, AF_UNIX, ...</target>
        </trans-unit>
        <trans-unit id="8270308dd6281a640520a3b86d9717dc1578cb66" translate="yes" xml:space="preserve">
          <source>AIX 4.2 and extensions using C++ with statics</source>
          <target state="translated">static과 함께 C ++를 사용하는 AIX 4.2 및 확장</target>
        </trans-unit>
        <trans-unit id="cc22d23e0b7ef1b2efab2cb46a1e42c8fa854e52" translate="yes" xml:space="preserve">
          <source>AIX 5L 5.3 documentation on syslog, &lt;a href=&quot;http://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?topic=/com.ibm.aix.basetechref/doc/basetrf2/syslog.htm&quot;&gt;http://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?topic=/com.ibm.aix.basetechref/doc/basetrf2/syslog.htm&lt;/a&gt;</source>
          <target state="translated">syslog에 대한 AIX 5L 5.3 문서, &lt;a href=&quot;http://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?topic=/com.ibm.aix.basetechref/doc/basetrf2/syslog.htm&quot;&gt;http://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?topic=/com.ibm.aix.basetechref/doc/basetrf2/syslog.htm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bbc183716848102da5675f12c481c22f2bbe872f" translate="yes" xml:space="preserve">
          <source>AIX specific subclass of ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils :: MM_Unix의 AIX 특정 서브 클래스</target>
        </trans-unit>
        <trans-unit id="b844fff26ef204487899d430c3a31df1b5cc17d0" translate="yes" xml:space="preserve">
          <source>AIX supports dynamically loadable objects as well as shared libraries. Shared libraries by convention end with the suffix .a, which is a bit misleading, as an archive can contain static as well as dynamic members. For Perl dynamically loaded objects we use the .so suffix also used on many other platforms.</source>
          <target state="translated">AIX는 공유 라이브러리뿐만 아니라 동적으로로드 가능한 오브젝트를 지원합니다. 아카이브는 정적 멤버와 동적 멤버를 포함 할 수 있으므로 규칙에 따라 공유 라이브러리는 접미사 .a로 끝납니다. Perl 동적으로로드 된 객체의 경우 다른 플랫폼에서도 사용되는 .so 접미사를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c930119fca1aaac13c47275f88a8f54f317dcf6d" translate="yes" xml:space="preserve">
          <source>ALIASES</source>
          <target state="translated">ALIASES</target>
        </trans-unit>
        <trans-unit id="6b42874e3cd20771d93096ec5ce36307a1f2ba14" translate="yes" xml:space="preserve">
          <source>ALL</source>
          <target state="translated">ALL</target>
        </trans-unit>
        <trans-unit id="212ac4dd3c12194a505f91dc67c3c92083d6b847" translate="yes" xml:space="preserve">
          <source>ALTERNATIVES</source>
          <target state="translated">ALTERNATIVES</target>
        </trans-unit>
        <trans-unit id="a4406ec237fefa2186cbfcb898374ca2b35f123f" translate="yes" xml:space="preserve">
          <source>ANCHORS</source>
          <target state="translated">ANCHORS</target>
        </trans-unit>
        <trans-unit id="c2f934cb8cab6c1b3af0d4f2fdd824eabafb6bf4" translate="yes" xml:space="preserve">
          <source>AND</source>
          <target state="translated">AND</target>
        </trans-unit>
        <trans-unit id="f00aef29ec0d70fa98911d7d5c3619473dc02a1d" translate="yes" xml:space="preserve">
          <source>ANOTHER STEP SIDEWAYS</source>
          <target state="translated">다른 단계 옆</target>
        </trans-unit>
        <trans-unit id="dc8b5a685a1f3dfa4a578835317ceecf19e71828" translate="yes" xml:space="preserve">
          <source>ANSI C prototypes</source>
          <target state="translated">ANSI C 프로토 타입</target>
        </trans-unit>
        <trans-unit id="dfbdf15f452a4b9784443e1ff8b670a57ee46040" translate="yes" xml:space="preserve">
          <source>API CHANGES</source>
          <target state="translated">API 변경</target>
        </trans-unit>
        <trans-unit id="4f15dd61e10f028874d8ba2639996e9123298e0e" translate="yes" xml:space="preserve">
          <source>API Listing originally by Dean Roehrich &amp;lt;roehrich@cray.com&amp;gt;.</source>
          <target state="translated">API는 원래 Roeerich &amp;lt;roehrich@cray.com&amp;gt;에 의해 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="df325db8b77f500b6cdf947d62422aad373e0aea" translate="yes" xml:space="preserve">
          <source>API Methods</source>
          <target state="translated">API 메소드</target>
        </trans-unit>
        <trans-unit id="8454ac15101bc16638e3fcbf0a95ef8d316e2b31" translate="yes" xml:space="preserve">
          <source>API documentation corrected and extended by Peter John Acklam, &amp;lt;pjacklam@online.no&amp;gt;</source>
          <target state="translated">Peter John Acklam이 수정 및 확장 한 API 설명서, &amp;lt;pjacklam@online.no&amp;gt;</target>
        </trans-unit>
        <trans-unit id="277a0cf94bbf499b3b1ef2e01755b635f3035e77" translate="yes" xml:space="preserve">
          <source>API optional methods</source>
          <target state="translated">API 선택적 메소드</target>
        </trans-unit>
        <trans-unit id="9062babed18f073234a690694e7bfa973c074eed" translate="yes" xml:space="preserve">
          <source>API should be understandable by the average programmer</source>
          <target state="translated">API는 일반 프로그래머가 이해할 수 있어야합니다</target>
        </trans-unit>
        <trans-unit id="0dd3839d0c79b29685b54d3a4a1e4fbc6f050c94" translate="yes" xml:space="preserve">
          <source>API version</source>
          <target state="translated">API 버전</target>
        </trans-unit>
        <trans-unit id="a7438834ae98ed5eab86e235ece4b52b96a7675f" translate="yes" xml:space="preserve">
          <source>API version 1</source>
          <target state="translated">API 버전 1</target>
        </trans-unit>
        <trans-unit id="a0960ab95be5d294c9ff103e037a981d112d54d9" translate="yes" xml:space="preserve">
          <source>API version 2</source>
          <target state="translated">API 버전 2</target>
        </trans-unit>
        <trans-unit id="f6db2b825c2703e26c1c6b659f77956e578c5caf" translate="yes" xml:space="preserve">
          <source>ARGS</source>
          <target state="translated">ARGS</target>
        </trans-unit>
        <trans-unit id="253fb8ce8cc421dd2ece69eec435a50b11f94cfb" translate="yes" xml:space="preserve">
          <source>ARGUMENTS</source>
          <target state="translated">ARGUMENTS</target>
        </trans-unit>
        <trans-unit id="3669288cabd0e6c21385584c21cb897733b8578f" translate="yes" xml:space="preserve">
          <source>ARGV</source>
          <target state="translated">ARGV</target>
        </trans-unit>
        <trans-unit id="58f29c4a3f70f6c5783cb6f812b7570e0f5a35fa" translate="yes" xml:space="preserve">
          <source>ARGVOUT</source>
          <target state="translated">ARGVOUT</target>
        </trans-unit>
        <trans-unit id="939f4f9b79e0d63ec8eb10a421a9e30ccdc8ba12" translate="yes" xml:space="preserve">
          <source>ARRAYS OF ARRAYS</source>
          <target state="translated">배열의 배열</target>
        </trans-unit>
        <trans-unit id="a25c873f10f6ead60f25f2f80304660b76114969" translate="yes" xml:space="preserve">
          <source>ARRAYS OF HASHES</source>
          <target state="translated">해시의 배열</target>
        </trans-unit>
        <trans-unit id="54523fd188916df915063049c7391f98e0ecb17d" translate="yes" xml:space="preserve">
          <source>AS/400 Perl information at &lt;a href=&quot;http://as400.rochester.ibm.com/&quot;&gt;http://as400.rochester.ibm.com/&lt;/a&gt; as well as on CPAN in the</source>
          <target state="translated">&lt;a href=&quot;http://as400.rochester.ibm.com/&quot;&gt;http://as400.rochester.ibm.com/의&lt;/a&gt; AS / 400 Perl 정보 및 CPAN의</target>
        </trans-unit>
        <trans-unit id="94090230b1f8c256f7ac5dc5a70bd3b20ee4ff15" translate="yes" xml:space="preserve">
          <source>ASCII</source>
          <target state="translated">ASCII</target>
        </trans-unit>
        <trans-unit id="095009cc6353c09fd2d522eaac28b52d2906738f" translate="yes" xml:space="preserve">
          <source>ASCII Rules versus Unicode Rules</source>
          <target state="translated">ASCII 규칙과 유니 코드 규칙</target>
        </trans-unit>
        <trans-unit id="05b06e21b242818c80ba48f1806ad24f7869b69b" translate="yes" xml:space="preserve">
          <source>ASCII is a 7 bit encoding, but bytes have 8 bits in them. The 128 extra characters have different meanings depending on the locale. Absent a locale, currently these extra characters are generally considered to be unassigned, and this has presented some problems. This has being changed starting in 5.12 so that these characters can be considered to be Latin-1 (ISO-8859-1).</source>
          <target state="translated">ASCII는 7 비트 인코딩이지만 바이트는 8 비트입니다. 128 개의 추가 문자는 로케일에 따라 다른 의미를 갖습니다. 로케일이 없으면 현재 이러한 추가 문자는 일반적으로 할당되지 않은 것으로 간주되며 몇 가지 문제가 있습니다. 이 문자는 라틴어 (ISO-8859-1)로 간주 될 수 있도록 5.12부터 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="d77e7b08ca6fa993505fba8c81b3ac5f801abc6f" translate="yes" xml:space="preserve">
          <source>ASCII rules are used for the case change. The lowercase of any character outside the ASCII range is the character itself.</source>
          <target state="translated">ASCII 규칙은 대소 문자 변경에 사용됩니다. ASCII 범위를 벗어난 문자의 소문자는 문자 자체입니다.</target>
        </trans-unit>
        <trans-unit id="ece7d85b8cf901827daa3241607fc8b13d846059" translate="yes" xml:space="preserve">
          <source>ATTRIBUTION</source>
          <target state="translated">ATTRIBUTION</target>
        </trans-unit>
        <trans-unit id="8b61f8355a2ccf4ace40fd469d2de5233617a66b" translate="yes" xml:space="preserve">
          <source>AUTHOR</source>
          <target state="translated">AUTHOR</target>
        </trans-unit>
        <trans-unit id="57dab403a72cbeaee26142a3b342afaf3f988255" translate="yes" xml:space="preserve">
          <source>AUTHOR AND COPYRIGHT</source>
          <target state="translated">저자와 저작권</target>
        </trans-unit>
        <trans-unit id="612f07ef18eeaf3398b36342703c907f1f498930" translate="yes" xml:space="preserve">
          <source>AUTHOR and COPYRIGHT</source>
          <target state="translated">저자와 저작권</target>
        </trans-unit>
        <trans-unit id="d5195f9e1e4e9d40c97901347bc70f8c519bf1be" translate="yes" xml:space="preserve">
          <source>AUTHOR, COPYRIGHT AND LICENSE</source>
          <target state="translated">저자, 저작권 및 라이센스</target>
        </trans-unit>
        <trans-unit id="41d9cfc9cdf402f68e3f8ff8a8e41c4254e5f24e" translate="yes" xml:space="preserve">
          <source>AUTHOR, COPYRIGHT, AND LICENSE</source>
          <target state="translated">저자, 저작권 및 라이센스</target>
        </trans-unit>
        <trans-unit id="dad57a4c245a8007c90257aef0514c8b6a0f600c" translate="yes" xml:space="preserve">
          <source>AUTHORS</source>
          <target state="translated">AUTHORS</target>
        </trans-unit>
        <trans-unit id="10ca6d2dbfbe263ce3d2447e713540dbee649dd1" translate="yes" xml:space="preserve">
          <source>AUTHORS &amp;amp; ACKNOWLEDGEMENTS</source>
          <target state="translated">저자 및 승인</target>
        </trans-unit>
        <trans-unit id="85e022793224f31daf1d3314f296447a1c347850" translate="yes" xml:space="preserve">
          <source>AUTHORS / CONTRIBUTORS</source>
          <target state="translated">저자 / 참가자</target>
        </trans-unit>
        <trans-unit id="14d07abb959cf3e3fd8f53cf02fd844e461b3f7b" translate="yes" xml:space="preserve">
          <source>AUTHORS AND CONTRIBUTORS</source>
          <target state="translated">저자 및 기여자</target>
        </trans-unit>
        <trans-unit id="a7c000e8a87845b58cc629ac11fab313f86076cc" translate="yes" xml:space="preserve">
          <source>AUTO LEXICONS</source>
          <target state="translated">자동 사전</target>
        </trans-unit>
        <trans-unit id="ba657d4270e0ee84198dc3f12f7f53cb0c332d2f" translate="yes" xml:space="preserve">
          <source>AUTOLOAD</source>
          <target state="translated">AUTOLOAD</target>
        </trans-unit>
        <trans-unit id="43af5166b3e71bcdd670318e774158ceaf10a942" translate="yes" xml:space="preserve">
          <source>AUTOLOADER</source>
          <target state="translated">AUTOLOADER</target>
        </trans-unit>
        <trans-unit id="886a23f1067d5ffd81046b592349f27bd44a8216" translate="yes" xml:space="preserve">
          <source>AUTOLOADed Constants</source>
          <target state="translated">자동로드 상수</target>
        </trans-unit>
        <trans-unit id="68570adadeeae5fdaad94d20b4200b8cf0e0c4f0" translate="yes" xml:space="preserve">
          <source>AVAILABILITY</source>
          <target state="translated">AVAILABILITY</target>
        </trans-unit>
        <trans-unit id="9669bc4871af0ed7e9d16166bb30c227929eda52" translate="yes" xml:space="preserve">
          <source>AVAILABLE FEATURES</source>
          <target state="translated">사용 가능한 기능</target>
        </trans-unit>
        <trans-unit id="302ba7dc5c280998e54c1d7ee821e9c0c27afd54" translate="yes" xml:space="preserve">
          <source>AVs and HVs are more complicated, but SVs are by far the most common variable type being thrown around. Having seen something of how we manipulate these, let's go on and look at how the op tree is constructed.</source>
          <target state="translated">AV와 HV는 더 복잡하지만 SV는 가장 일반적인 변수 유형입니다. 우리가 이것들을 어떻게 조작하는지 보았으니 op 트리가 어떻게 구성되는지 봅시다.</target>
        </trans-unit>
        <trans-unit id="97658a3aca1866999e545fb8e0d412280826a4d3" translate="yes" xml:space="preserve">
          <source>AVs, HVs and undefined values</source>
          <target state="translated">AV, HV 및 정의되지 않은 값</target>
        </trans-unit>
        <trans-unit id="1ca83b983f42527b4fed4dd004cb7ec8d4f4a6f6" translate="yes" xml:space="preserve">
          <source>Abandon the tmp in the current pad at offset po and replace with a new one.</source>
          <target state="translated">오프셋 po에서 현재 패드의 tmp를 버리고 새로운 것으로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="57c67b6004d41befa99fa526f57a6625af549efe" translate="yes" xml:space="preserve">
          <source>Abbrev - create an abbreviation table from a list</source>
          <target state="translated">Abbrev-목록에서 약어 테이블 만들기</target>
        </trans-unit>
        <trans-unit id="953787278f84160153e00df3d74bff332f0acc7b" translate="yes" xml:space="preserve">
          <source>Abigail &amp;lt;abigail@foad.org&amp;gt;, Charles Bailey &amp;lt;bailey@newman.upenn.edu&amp;gt;, Graham Barr &amp;lt;gbarr@pobox.com&amp;gt;, Tom Christiansen &amp;lt;tchrist@perl.com&amp;gt;, Nicholas Clark &amp;lt;nick@ccl4.org&amp;gt;, Thomas Dorner &amp;lt;Thomas.Dorner@start.de&amp;gt;, Andy Dougherty &amp;lt;doughera@lafayette.edu&amp;gt;, Dominic Dunlop &amp;lt;domo@computer.org&amp;gt;, Neale Ferguson &amp;lt;neale@vma.tabnsw.com.au&amp;gt;, David J. Fiander &amp;lt;davidf@mks.com&amp;gt;, Paul Green &amp;lt;Paul.Green@stratus.com&amp;gt;, M.J.T. Guy &amp;lt;mjtg@cam.ac.uk&amp;gt;, Jarkko Hietaniemi &amp;lt;jhi@iki.fi&amp;gt;, Luther Huffman &amp;lt;lutherh@stratcom.com&amp;gt;, Nick Ing-Simmons &amp;lt;nick@ing-simmons.net&amp;gt;, Andreas J. K&amp;ouml;nig &amp;lt;a.koenig@mind.de&amp;gt;, Markus Laker &amp;lt;mlaker@contax.co.uk&amp;gt;, Andrew M. Langmead &amp;lt;aml@world.std.com&amp;gt;, Larry Moore &amp;lt;ljmoore@freespace.net&amp;gt;, Paul Moore &amp;lt;Paul.Moore@uk.origin-it.com&amp;gt;, Chris Nandor &amp;lt;pudge@pobox.com&amp;gt;, Matthias Neeracher &amp;lt;neeracher@mac.com&amp;gt;, Philip Newton &amp;lt;pne@cpan.org&amp;gt;, Gary Ng &amp;lt;71564.1743@CompuServe.COM&amp;gt;, Tom Phoenix &amp;lt;rootbeer@teleport.com&amp;gt;, Andr&amp;eacute; Pirard &amp;lt;A.Pirard@ulg.ac.be&amp;gt;, Peter Prymmer &amp;lt;pvhp@forte.com&amp;gt;, Hugo van der Sanden &amp;lt;hv@crypt0.demon.co.uk&amp;gt;, Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;, Paul J. Schinder &amp;lt;schinder@pobox.com&amp;gt;, Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;, Dan Sugalski &amp;lt;dan@sidhe.org&amp;gt;, Nathan Torkington &amp;lt;gnat@frii.com&amp;gt;, John Malmberg &amp;lt;wb8tyw@qsl.net&amp;gt;</source>
          <target state="translated">Abigail &amp;lt;abigail@foad.org&amp;gt;, Charles Bailey &amp;lt;bailey@newman.upenn.edu&amp;gt;, Graham Barr &amp;lt;gbarr@pobox.com&amp;gt;, Tom Christiansen &amp;lt;tchrist@perl.com&amp;gt;, Nicholas Clark &amp;lt;nick@ccl4.org&amp;gt; , Thomas Dorner &amp;lt;Thomas.Dorner@start.de&amp;gt;, Andy Dougherty &amp;lt;doughera@lafayette.edu&amp;gt;, Dominic Dunlop &amp;lt;domo@computer.org&amp;gt;, Neale Ferguson &amp;lt;neale@vma.tabnsw.com.au&amp;gt;, David J. Fiander &amp;lt;davidf@mks.com&amp;gt;, Paul Green &amp;lt;Paul.Green@stratus.com&amp;gt;, MJT Guy &amp;lt;mjtg@cam.ac.uk&amp;gt;, Jarkko Hietaniemi &amp;lt;jhi@iki.fi&amp;gt;, Luther Huffman &amp;lt;lutherh @ stratcom. com&amp;gt;, Nick Ing-Simmons &amp;lt;nick@ing-simmons.net&amp;gt;, Andreas J. K&amp;ouml;nig &amp;lt;a.koenig@mind.de&amp;gt;, Markus Laker &amp;lt;mlaker@contax.co.uk&amp;gt;, Andrew M. Langmead &amp;lt;aml @ world.std.com&amp;gt;, Larry Moore &amp;lt;ljmoore@freespace.net&amp;gt;, Paul Moore &amp;lt;Paul.Moore@uk.origin-it.com&amp;gt;,Chris Nandor &amp;lt;pudge@pobox.com&amp;gt;, Matthias Neeracher &amp;lt;neeracher@mac.com&amp;gt;, Philip Newton &amp;lt;pne@cpan.org&amp;gt;, Gary Ng &amp;lt;71564.1743@CompuServe.COM&amp;gt;, Tom Phoenix &amp;lt;rootbeer@teleport.com&amp;gt;, Andr&amp;eacute; Pirard &amp;lt;A.Pirard@ulg.ac.be&amp;gt;, Peter Prymmer &amp;lt;pvhp@forte.com&amp;gt;, Hugo van der Sanden &amp;lt;hv@crypt0.demon.co.uk&amp;gt;, Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;, Paul J. Schinder &amp;lt;schinder@pobox.com&amp;gt;, Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;, Dan Sugalski &amp;lt;dan@sidhe.org&amp;gt;, Nathan Torkington &amp;lt;gnat@frii.com&amp;gt;, John Malmberg &amp;lt;wb8tyw @ qsl. 넷&amp;gt;com&amp;gt;, Hugo van der Sanden &amp;lt;hv@crypt0.demon.co.uk&amp;gt;, Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;, Paul J. Schinder &amp;lt;schinder@pobox.com&amp;gt;, Michael G Schwern &amp;lt;schwern@pobox.com &amp;gt;, Dan Sugalski &amp;lt;dan@sidhe.org&amp;gt;, Nathan Torkington &amp;lt;gnat@frii.com&amp;gt;, John Malmberg &amp;lt;wb8tyw@qsl.net&amp;gt;com&amp;gt;, Hugo van der Sanden &amp;lt;hv@crypt0.demon.co.uk&amp;gt;, Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;, Paul J. Schinder &amp;lt;schinder@pobox.com&amp;gt;, Michael G Schwern &amp;lt;schwern@pobox.com &amp;gt;, Dan Sugalski &amp;lt;dan@sidhe.org&amp;gt;, Nathan Torkington &amp;lt;gnat@frii.com&amp;gt;, John Malmberg &amp;lt;wb8tyw@qsl.net&amp;gt;</target>
        </trans-unit>
        <trans-unit id="272ef4d46b3c0dabd3e502b3dc11c532d79932f2" translate="yes" xml:space="preserve">
          <source>Able to serve as an &lt;b&gt;lvalue&lt;/b&gt;.</source>
          <target state="translated">int로서 역할을 할 수 &lt;b&gt;좌변&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="a3f9c8141ea275b67bac5cb6c2da96e6b983db25" translate="yes" xml:space="preserve">
          <source>Abort the current data transfer.</source>
          <target state="translated">현재 데이터 전송을 중단하십시오.</target>
        </trans-unit>
        <trans-unit id="f7989aafbbb3a9f050ae7d85ebd582349680eb97" translate="yes" xml:space="preserve">
          <source>About =over...=back Regions</source>
          <target state="translated">= over ... = 뒤 지역</target>
        </trans-unit>
        <trans-unit id="5766587271d36ba046e7fb9efb21f9b7e662efb7" translate="yes" xml:space="preserve">
          <source>About Compiler Versions of Irix</source>
          <target state="translated">컴파일러 버전의 Irix 정보</target>
        </trans-unit>
        <trans-unit id="bcf14899785f94972e5296a53e65daa2fad1f95c" translate="yes" xml:space="preserve">
          <source>About Data Paragraphs and &quot;=begin/=end&quot; Regions</source>
          <target state="translated">데이터 단락 및 &quot;= 시작 / = 종료&quot;영역 정보</target>
        </trans-unit>
        <trans-unit id="f134fee2fd6f61ab2515d5dfb15b7bc4b2f583f5" translate="yes" xml:space="preserve">
          <source>About L&amp;lt;...&amp;gt; Codes</source>
          <target state="translated">L &amp;lt;...&amp;gt; 코드 정보</target>
        </trans-unit>
        <trans-unit id="027e45f66497afa47c6fd09d682b0e1e7a6cedb2" translate="yes" xml:space="preserve">
          <source>Above the optimizer section is the list of</source>
          <target state="translated">최적화 섹션 위에는</target>
        </trans-unit>
        <trans-unit id="6d3fc598c606132c619a12609173fe6e49201e22" translate="yes" xml:space="preserve">
          <source>Absolute referencing</source>
          <target state="translated">절대 참조</target>
        </trans-unit>
        <trans-unit id="d79da395b5d7a09c6439a5f2660d8c568186ab7e" translate="yes" xml:space="preserve">
          <source>Abstract</source>
          <target state="translated">Abstract</target>
        </trans-unit>
        <trans-unit id="fd1c863c80384ee83334b3b3ad71ce0af37947bc" translate="yes" xml:space="preserve">
          <source>Abstract base class for harness output delegate</source>
          <target state="translated">하네스 출력 델리게이트의 추상 기본 클래스</target>
        </trans-unit>
        <trans-unit id="becdf5f42e43b7273698e72d5f4213f7c0a68cc4" translate="yes" xml:space="preserve">
          <source>Accepted before Perl 5.20.0. The Socket library is now primarily maintained on CPAN, rather than in the perl core.</source>
          <target state="translated">Perl 5.20.0 이전에 허용되었습니다. 소켓 라이브러리는 이제 주로 펄 코어가 아닌 CPAN에서 유지 보수됩니다.</target>
        </trans-unit>
        <trans-unit id="4dd1bc893614ac8f9bec65c912481578e5103c07" translate="yes" xml:space="preserve">
          <source>Accepted features</source>
          <target state="translated">허용되는 기능</target>
        </trans-unit>
        <trans-unit id="56a28ff20a71c3e8ac9c196f290eef557747b624" translate="yes" xml:space="preserve">
          <source>Accepted in Perl 5.20.0</source>
          <target state="translated">Perl 5.20.0에서 허용</target>
        </trans-unit>
        <trans-unit id="1576bf43d8822dbdd55b1f1ab39311d28be28187" translate="yes" xml:space="preserve">
          <source>Accepted in Perl 5.22.0</source>
          <target state="translated">Perl 5.22.0에서 허용</target>
        </trans-unit>
        <trans-unit id="675dec52d56b1b7035fe24d4e72f28a346a787af" translate="yes" xml:space="preserve">
          <source>Accepted in Perl 5.8.0</source>
          <target state="translated">Perl 5.8.0에서 허용</target>
        </trans-unit>
        <trans-unit id="90c2a9a8eb85f455955167b397c89e9d89539a74" translate="yes" xml:space="preserve">
          <source>Accepted in Perl 5.8.1</source>
          <target state="translated">Perl 5.8.1에서 허용</target>
        </trans-unit>
        <trans-unit id="ad21c5596b645ba9637173674a45823b09fa37af" translate="yes" xml:space="preserve">
          <source>Accepts a hashref with the following key/value pairs:</source>
          <target state="translated">다음 키 / 값 쌍으로 해시 참조를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="3cab88715458f5eb0aafb0a8b41682d6e4711e8a" translate="yes" xml:space="preserve">
          <source>Accepts a scalar value or array ref of scalar values indicating which paths to allowed libraries should be included if Perl tests are executed. Naturally, this only makes sense in the context of tests written in Perl.</source>
          <target state="translated">Perl 테스트가 실행될 때 허용되는 라이브러리에 대한 경로를 포함하는 스칼라 값 또는 스칼라 값의 배열 참조를 승인합니다. 당연히 이것은 Perl로 작성된 테스트 환경에서만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd709042dcc776319515489b90b122d3454c0825" translate="yes" xml:space="preserve">
          <source>Accepts a scalar value or array ref of scalar values indicating which switches should be included if Perl tests are executed. Naturally, this only makes sense in the context of tests written in Perl.</source>
          <target state="translated">Perl 테스트가 실행될 때 어떤 스위치를 포함해야하는지 나타내는 스칼라 값 또는 스칼라 값의 배열 참조를 승인합니다. 당연히 이것은 Perl로 작성된 테스트 환경에서만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="410a58b5c50383c8e3e3efac6ca6d02323a2e404" translate="yes" xml:space="preserve">
          <source>Accepts a version object and returns the normalized floating point representation. Call like:</source>
          <target state="translated">버전 객체를 받아들이고 정규화 된 부동 소수점 표현을 반환합니다. 다음과 같이 전화하십시오 :</target>
        </trans-unit>
        <trans-unit id="6925cd73aca9469cc1ca4115afb36b07a4f628be" translate="yes" xml:space="preserve">
          <source>Accepts a version object and returns the normalized string representation. Call like:</source>
          <target state="translated">버전 객체를 허용하고 정규화 된 문자열 표현을 반환합니다. 다음과 같이 전화하십시오 :</target>
        </trans-unit>
        <trans-unit id="2dc796d2ce674a48fb65979328ffb56b5f53f1a2" translate="yes" xml:space="preserve">
          <source>Accepts an array of &lt;code&gt;@tests&lt;/code&gt; to be run. This should generally be the names of test files, but this is not required. Each element in &lt;code&gt;@tests&lt;/code&gt; will be passed to &lt;code&gt;TAP::Parser::new()&lt;/code&gt; as a &lt;code&gt;source&lt;/code&gt; . See &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;@tests&lt;/code&gt; 배열을 실행할 수 있습니다. 일반적으로 테스트 파일 이름이어야하지만 필수는 아닙니다. &lt;code&gt;@tests&lt;/code&gt; 의 각 요소는 &lt;code&gt;TAP::Parser::new()&lt;/code&gt; 에 &lt;code&gt;source&lt;/code&gt; 로 전달됩니다 . 자세한 내용은 &lt;a href=&quot;parser&quot;&gt;TAP :: Parser&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2eb4b3520f8d8fe3fca980121310995272cd8962" translate="yes" xml:space="preserve">
          <source>Accepts an incoming socket connect, just as accept(2) does. Returns the packed address if it succeeded, false otherwise. See the example in &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">accept (2)와 마찬가지로 들어오는 소켓 연결을 수락합니다. 압축 된 주소가 성공하면 반환하고 그렇지 않으면 false를 반환합니다. &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;소켓 : perlipc의 클라이언트 / 서버 통신&lt;/a&gt; 의 예제를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9fa11f18dc906995a6c93c465d60382e345c0a77" translate="yes" xml:space="preserve">
          <source>Accepts an incoming socket connect, just as accept(2) does. Returns the packed address if it succeeded, false otherwise. See the example in &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">accept (2)와 마찬가지로 들어오는 소켓 연결을 수락합니다. 압축 된 주소가 성공하면 반환하고 그렇지 않으면 false를 반환합니다. &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;소켓 : perlipc의 클라이언트 / 서버 통신&lt;/a&gt; 의 예제를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="37a976454ef0a6eae01758cd57c59bf29e52a50c" translate="yes" xml:space="preserve">
          <source>Accepts targets for &lt;code&gt;=begin/=for/=end&lt;/code&gt; sections of the POD.</source>
          <target state="translated">POD의 &lt;code&gt;=begin/=for/=end&lt;/code&gt; 섹션에 대한 대상을 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="cede5a1af37a1d62c15ab2a9566e9d886f5d7670" translate="yes" xml:space="preserve">
          <source>Accepts targets for &lt;code&gt;=begin/=for/=end&lt;/code&gt; sections that should be parsed as POD. For details, see &lt;a href=&quot;../perlpodspec#About-Data-Paragraphs&quot;&gt;About Data Paragraphs in perlpodspec&lt;/a&gt;.</source>
          <target state="translated">POD로 구문 분석해야하는 &lt;code&gt;=begin/=for/=end&lt;/code&gt; 섹션에 대한 대상을 승인 합니다 . 자세한 내용 &lt;a href=&quot;../perlpodspec#About-Data-Paragraphs&quot;&gt;은 perlpodspec의 데이터 단락&lt;/a&gt; 정보를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7e56694c4d8d029e1bdf7a642cc8826a85758929" translate="yes" xml:space="preserve">
          <source>Access Perl configuration information</source>
          <target state="translated">Perl 구성 정보에 액세스</target>
        </trans-unit>
        <trans-unit id="8347e5dd48478a10f6aa983449d4b21d1a1af03b" translate="yes" xml:space="preserve">
          <source>Access and Printing</source>
          <target state="translated">액세스 및 인쇄</target>
        </trans-unit>
        <trans-unit id="6e5e899f8f49475c30613c0d5e03d1268e31be2c" translate="yes" xml:space="preserve">
          <source>Access and Printing of a HASH OF ARRAYS</source>
          <target state="translated">배열 해시 액세스 및 인쇄</target>
        </trans-unit>
        <trans-unit id="0a3d910a71354dc1a13d0c6e24e7384a561b0108" translate="yes" xml:space="preserve">
          <source>Access and Printing of a HASH OF HASHES</source>
          <target state="translated">해시 해시 액세스 및 인쇄</target>
        </trans-unit>
        <trans-unit id="7eae78c7526db834fa9958c243fe41a5cb62ea03" translate="yes" xml:space="preserve">
          <source>Access and Printing of an ARRAY OF ARRAYS</source>
          <target state="translated">배열의 액세스 및 인쇄</target>
        </trans-unit>
        <trans-unit id="5c93728a9e35642c958c51c0f97be500a59df202" translate="yes" xml:space="preserve">
          <source>Access and Printing of an ARRAY OF HASHES</source>
          <target state="translated">해시 배열 액세스 및 인쇄</target>
        </trans-unit>
        <trans-unit id="f42ea96011d2554db1787fd6d4c92a4571864cb4" translate="yes" xml:space="preserve">
          <source>Access methods correspond to the underlying C macros for field access, usually with the leading &quot;class indication&quot; prefix removed (Sv, Av, Hv, ...). The leading prefix is only left in cases where its removal would cause a clash in method name. For example, &lt;code&gt;GvREFCNT&lt;/code&gt; stays as-is since its abbreviation would clash with the &quot;superclass&quot; method &lt;code&gt;REFCNT&lt;/code&gt; (corresponding to the C function &lt;code&gt;SvREFCNT&lt;/code&gt; ).</source>
          <target state="translated">액세스 방법은 필드 액세스를위한 기본 C 매크로에 해당하며 일반적으로 선행 &quot;클래스 표시&quot;접두사가 제거됩니다 (Sv, Av, Hv, ...). 선행 접두사는 제거로 인해 메소드 이름이 충돌하는 경우에만 남습니다. 예를 들어, &lt;code&gt;GvREFCNT&lt;/code&gt; 는 약어가 &quot;수퍼 클래스&quot;메소드 &lt;code&gt;REFCNT&lt;/code&gt; (C 함수 &lt;code&gt;SvREFCNT&lt;/code&gt; 에 해당) 와 충돌하기 때문에 그대로 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="add7e6bb00f6c276fc0702f5d9311fd702f4d0cd" translate="yes" xml:space="preserve">
          <source>Access methods correspond to the underlying C structure field names, with the leading &quot;class indication&quot; prefix (&lt;code&gt;&quot;op_&quot;&lt;/code&gt; ) removed.</source>
          <target state="translated">액세스 방법은 선행 &quot;클래스 표시&quot;접두어 ( &lt;code&gt;&quot;op_&quot;&lt;/code&gt; )가 제거 된 기본 C 구조 필드 이름에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="9396a41f14cddbeb41d4b7aa1b84d15e3d72d6c2" translate="yes" xml:space="preserve">
          <source>Access permissions are mapped onto VOS access-control list changes. (VOS)</source>
          <target state="translated">액세스 권한은 VOS 액세스 제어 목록 변경 사항에 매핑됩니다. (VOS)</target>
        </trans-unit>
        <trans-unit id="cf06121dd11c83b8ba81397ecad6cc2b95e65336" translate="yes" xml:space="preserve">
          <source>Access the SV at offset po in the saved current pad in the given context block structure (can be used as an lvalue).</source>
          <target state="translated">주어진 컨텍스트 블록 구조에서 저장된 전류 패드의 오프셋 po에서 SV에 액세스합니다 (l 값으로 사용할 수 있음).</target>
        </trans-unit>
        <trans-unit id="2cb44963f6bed203bb471252102ea353cd9644e0" translate="yes" xml:space="preserve">
          <source>Access the lines of a disk file via a Perl array</source>
          <target state="translated">Perl 배열을 통해 디스크 파일 라인에 액세스</target>
        </trans-unit>
        <trans-unit id="dfa61e115e0e8ce23ca07250a4a3499d896cdbc1" translate="yes" xml:space="preserve">
          <source>Access to Unicode character names and named character sequences; also define character names</source>
          <target state="translated">유니 코드 문자 이름 및 명명 된 문자 시퀀스에 액세스 또한 캐릭터 이름을 정의</target>
        </trans-unit>
        <trans-unit id="3f2a46103156b0b5a62f34c4352c1666092f35bc" translate="yes" xml:space="preserve">
          <source>Access to lexicals that change over time--like those in the &lt;code&gt;for&lt;/code&gt; loop above, basically aliases to elements from the surrounding lexical scopes-- only works with anonymous subs, not with named subroutines. Generally said, named subroutines do not nest properly and should only be declared in the main package scope.</source>
          <target state="translated">위 의 &lt;code&gt;for&lt;/code&gt; 루프 에서와 같이 시간이 지남에 따라 변하는 어휘에 대한 액세스 , 기본적으로 주변 어휘 범위의 요소에 대한 별명은 명명 된 서브 루틴이 아닌 익명의 서브에서만 작동합니다. 일반적으로 명명 된 서브 루틴은 올바르게 중첩되지 않으며 기본 패키지 범위에서만 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="7bc448fbe13d49ff8ac45ad2ec5aee25fed2364d" translate="yes" xml:space="preserve">
          <source>Accessing .tar.Z files</source>
          <target state="translated">.tar.Z 파일에 액세스</target>
        </trans-unit>
        <trans-unit id="c5656ffc833d5bac0703673d7cf0135c7d41a0d7" translate="yes" xml:space="preserve">
          <source>Accessing Formatting Internals</source>
          <target state="translated">서식 내부 액세스</target>
        </trans-unit>
        <trans-unit id="1370d87d951a33ab05354cde2d7a32967a2dbeb2" translate="yes" xml:space="preserve">
          <source>Accessing documentation</source>
          <target state="translated">문서에 액세스</target>
        </trans-unit>
        <trans-unit id="e54a40f7d6dbbb802431fdba39190e9b3cbe3ecd" translate="yes" xml:space="preserve">
          <source>Accessing socket options</source>
          <target state="translated">소켓 옵션에 액세스</target>
        </trans-unit>
        <trans-unit id="ee8cacdba63cbccd984c19db609590e2c60f68e6" translate="yes" xml:space="preserve">
          <source>Accessor functions are available for all existing object hash keys and should be used instead of directly accessing the internal hash keys. The reason for this is that Math::BigInt itself has a pluggable interface which permits it to support different storage methods.</source>
          <target state="translated">접근 자 기능은 기존의 모든 객체 해시 키에 사용할 수 있으며 내부 해시 키에 직접 액세스하는 대신 사용해야합니다. 그 이유는 Math :: BigInt 자체에 다른 저장 방법을 지원할 수있는 플러그 가능 인터페이스가 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="f5b0e226ed894764db92e76b6c1f1203c0b805bb" translate="yes" xml:space="preserve">
          <source>Accessors</source>
          <target state="translated">Accessors</target>
        </trans-unit>
        <trans-unit id="4bc2c6535b52b04314dc544d8a82eac93deb00cf" translate="yes" xml:space="preserve">
          <source>Accuracy A</source>
          <target state="translated">정확도 A</target>
        </trans-unit>
        <trans-unit id="938afbd35a75ae9b5871a66f02d0250f1479aaac" translate="yes" xml:space="preserve">
          <source>Accuracy vs. Precision</source>
          <target state="translated">정확도 대 정밀도</target>
        </trans-unit>
        <trans-unit id="3e804ac1bc11e330fa5eacd1be133ab843f79bee" translate="yes" xml:space="preserve">
          <source>Accustomed &lt;b&gt;awk&lt;/b&gt; users should take special note of the following:</source>
          <target state="translated">익숙한 &lt;b&gt;awk&lt;/b&gt; 사용자는 다음 사항에주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="b0ebcfe59f276beb7f6238d812ac61ce48d3d9c0" translate="yes" xml:space="preserve">
          <source>Acknowledgements</source>
          <target state="translated">Acknowledgements</target>
        </trans-unit>
        <trans-unit id="5d9540ff93a75d47409d6a0aa37491da117ecdf8" translate="yes" xml:space="preserve">
          <source>Acknowledgments</source>
          <target state="translated">Acknowledgments</target>
        </trans-unit>
        <trans-unit id="708327daa641b57f7797d675f864c6465f65ebf5" translate="yes" xml:space="preserve">
          <source>Acorn RISC OS</source>
          <target state="translated">도토리 RISC OS</target>
        </trans-unit>
        <trans-unit id="8661bdb9b88159cdbca0d1b472228de45e5e9630" translate="yes" xml:space="preserve">
          <source>Actions in current file (keys are line numbers). The values are strings that have the sprintf(3) format &lt;code&gt;(&quot;%s\000%s&quot;, breakcondition, actioncode)&lt;/code&gt; .</source>
          <target state="translated">현재 파일의 작업 (키는 줄 번호) 값은 sprintf (3) 형식 &lt;code&gt;(&quot;%s\000%s&quot;, breakcondition, actioncode)&lt;/code&gt; 을 가진 문자열입니다 .</target>
        </trans-unit>
        <trans-unit id="74456291abea501ae7538be3d3218d24479cf1b8" translate="yes" xml:space="preserve">
          <source>Actions, watch variables, stack traces etc.: on the TODO list.</source>
          <target state="translated">TODO 목록의 조치, 감시 변수, 스택 추적 등</target>
        </trans-unit>
        <trans-unit id="0e67e479302a0fbdd5f8f5323bb053fb5c4640b0" translate="yes" xml:space="preserve">
          <source>ActiveState's cross-platform (as of October 2004, that's Windows, Linux, and Solaris), multi-language IDE has Perl support, including a regular expression debugger and remote debugging.</source>
          <target state="translated">ActiveState의 크로스 플랫폼 (2004 년 10 월 현재 Windows, Linux 및 Solaris)의 다국어 IDE는 정규식 디버거 및 원격 디버깅을 포함하여 Perl을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="3c54dc62dfe34bf8e3127c0ce1e38a91208c3d94" translate="yes" xml:space="preserve">
          <source>Acts like &lt;code&gt;FB_PERLQQ&lt;/code&gt; but U+</source>
          <target state="translated">&lt;code&gt;FB_PERLQQ&lt;/code&gt; 와 유사 하지만 U +</target>
        </trans-unit>
        <trans-unit id="548322587aa8642fc346684844907ab3ffec74e4" translate="yes" xml:space="preserve">
          <source>Actual math is done by using the class defined with &lt;code&gt;with =&amp;gt; Class;&lt;/code&gt; (which defaults to BigInts) to represent the mantissa and exponent.</source>
          <target state="translated">실제 수학은 &lt;code&gt;with =&amp;gt; Class;&lt;/code&gt; 정의 된 클래스를 사용하여 수행됩니다 . 가수 및 지수를 나타내는 (기본값은 BigInts)입니다.</target>
        </trans-unit>
        <trans-unit id="defa153aecf01309cb026d878c1991031baa4a07" translate="yes" xml:space="preserve">
          <source>Actually &lt;code&gt;Term::ReadLine&lt;/code&gt; can use some other package, that will support a richer set of commands.</source>
          <target state="translated">실제로 &lt;code&gt;Term::ReadLine&lt;/code&gt; 은 더 많은 명령 세트를 지원하는 다른 패키지를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3803c01d8a976c5bf1f723681cc4bf39bad12043" translate="yes" xml:space="preserve">
          <source>Actually Perl will not</source>
          <target state="translated">실제로 펄은</target>
        </trans-unit>
        <trans-unit id="795eded018f6ab011486134b18f32e5ab2a7c100" translate="yes" xml:space="preserve">
          <source>Actually performs the output check testing the tests, comparing the data (with &lt;code&gt;eq&lt;/code&gt; ) that we have captured from &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; against what was declared with &lt;code&gt;test_out&lt;/code&gt; and &lt;code&gt;test_err&lt;/code&gt; .</source>
          <target state="translated">실제로 &lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt; 에서 캡처 한 데이터 ( &lt;code&gt;eq&lt;/code&gt; ) 와 &lt;code&gt;test_out&lt;/code&gt; 및 &lt;code&gt;test_err&lt;/code&gt; 로 선언 된 데이터를 비교하여 테스트 테스트 출력 검사를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="5e55c0ee05ca269c1127b8a0393a10c58d229a08" translate="yes" xml:space="preserve">
          <source>Actually, on Mac OS, the &lt;code&gt;getcwd()&lt;/code&gt; , &lt;code&gt;fastgetcwd()&lt;/code&gt; and &lt;code&gt;fastcwd()&lt;/code&gt; functions are all aliases for the &lt;code&gt;cwd()&lt;/code&gt; function, which, on Mac OS, calls `pwd`. Likewise, the &lt;code&gt;abs_path()&lt;/code&gt; function is an alias for &lt;code&gt;fast_abs_path()&lt;/code&gt; .</source>
          <target state="translated">실제로 Mac OS에서 &lt;code&gt;getcwd()&lt;/code&gt; , &lt;code&gt;fastgetcwd()&lt;/code&gt; 및 &lt;code&gt;fastcwd()&lt;/code&gt; 함수는 &lt;code&gt;cwd()&lt;/code&gt; 함수 의 별명이며 Mac OS에서는`pwd`를 호출합니다. 마찬가지로, &lt;code&gt;abs_path()&lt;/code&gt; 함수의 별칭 &lt;code&gt;fast_abs_path()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db3073222c40a74ba3591ee6ba65b3b3cd91207d" translate="yes" xml:space="preserve">
          <source>Actually, the log output of</source>
          <target state="translated">실제로, 로그 출력</target>
        </trans-unit>
        <trans-unit id="af7244e5a9d564e8f0d5e7e9d10e38f4ccd63f70" translate="yes" xml:space="preserve">
          <source>Actually, they don't. All C operators that Perl copies have the same precedence in Perl as they do in C. The problem is with operators that C doesn't have, especially functions that give a list context to everything on their right, eg. print, chmod, exec, and so on. Such functions are called &quot;list operators&quot; and appear as such in the precedence table in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">실제로는 그렇지 않습니다. Perl이 복사하는 모든 C 연산자는 Perl에서 C와 같은 우선 순위를 갖습니다. 문제는 C에없는 연산자, 특히 오른쪽에있는 모든 것에 목록 컨텍스트를 제공하는 함수입니다. print, chmod, exec 등. 이러한 함수를 &quot;목록 연산자&quot;라고하며 &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 의 우선 순위 표에 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="07d8d521acda78914bf8936bc58119c26500077c" translate="yes" xml:space="preserve">
          <source>Actually, this was generated by a particular set of options. You can control the formatting of each column, whether you prefer wide or fat, hex or decimal, leading zeroes or whatever.</source>
          <target state="translated">실제로 이것은 특정 옵션 세트에 의해 생성되었습니다. 넓거나 뚱뚱한, 16 진수 또는 10 진수, 선행 0 또는 무엇이든 원하는대로 각 열의 서식을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="860c250cdfa0ae37812255641a707082591aa037" translate="yes" xml:space="preserve">
          <source>Adam Kennedy &amp;lt;adamk@cpan.org&amp;gt;</source>
          <target state="translated">아담 케네디 &amp;lt;adamk@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1a5c118dabaa69a69c89ab79443c5334f9b230a2" translate="yes" xml:space="preserve">
          <source>Adam Kennedy wrote &lt;a href=&quot;http://search.cpan.org/perldoc/YAML::Tiny&quot;&gt;YAML::Tiny&lt;/a&gt; which provided the template and many of the YAML matching regular expressions for this module.</source>
          <target state="translated">Adam Kennedy는 &lt;a href=&quot;http://search.cpan.org/perldoc/YAML::Tiny&quot;&gt;YAML :: Tiny&lt;/a&gt; 를 작성 하여이 모듈에 대한 템플릿과 일치하는 많은 YAML 정규식을 제공했습니다.</target>
        </trans-unit>
        <trans-unit id="bac28a1890b03ac016be9f9de8d1c17394eeee83" translate="yes" xml:space="preserve">
          <source>Add '#line' declarations to the output based on the line and file locations of the original code.</source>
          <target state="translated">원래 코드의 라인 및 파일 위치를 기반으로 출력에 '#line'선언을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="c4e7cfdfcf41d796fe22ef22535d39bf89e10e73" translate="yes" xml:space="preserve">
          <source>Add (if argument specified) and retrieve the hyperlinks (as defined by &lt;code&gt;L&amp;lt;&amp;gt;&lt;/code&gt; ) of the current POD. They consist of a 2-item array: line number and &lt;code&gt;Pod::Hyperlink&lt;/code&gt; object.</source>
          <target state="translated">(인수가 지정된 경우) 현재 POD 의 하이퍼 링크 ( &lt;code&gt;L&amp;lt;&amp;gt;&lt;/code&gt; 로 정의 된대로)를 추가하고 검색하십시오 . 행 번호와 &lt;code&gt;Pod::Hyperlink&lt;/code&gt; 객체 의 2 가지 항목으로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="593bc3c347e611284226398e8eb5446a2cdf167c" translate="yes" xml:space="preserve">
          <source>Add (if argument specified) and retrieve the index entries (as defined by &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; ) of the current POD. They consist of plain text, each piece of whitespace is collapsed to a single blank.</source>
          <target state="translated">(인수가 지정된 경우) 추가 하고 현재 POD 의 색인 항목 ( &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; 정의 된대로)을 검색하십시오 . 그것들은 일반 텍스트로 구성되며, 각 공백은 단일 공백으로 축소됩니다.</target>
        </trans-unit>
        <trans-unit id="7205abf0d37c1a800710d7689075b8b7e0097f10" translate="yes" xml:space="preserve">
          <source>Add (if argument specified) and retrieve the nodes (as defined by &lt;code&gt;=headX&lt;/code&gt; and &lt;code&gt;=item&lt;/code&gt; ) of the current POD. The nodes are returned in the order of their occurrence. They consist of plain text, each piece of whitespace is collapsed to a single blank.</source>
          <target state="translated">(인수가 지정된 경우) 현재 POD 의 노드 ( &lt;code&gt;=headX&lt;/code&gt; 및 &lt;code&gt;=item&lt;/code&gt; 에 정의 된대로)를 추가하고 검색하십시오 . 노드는 발생 순서대로 리턴됩니다. 그것들은 일반 텍스트로 구성되며, 각 공백은 단일 공백으로 축소됩니다.</target>
        </trans-unit>
        <trans-unit id="874122d1d027ce488479a1cec7aca152094478e4" translate="yes" xml:space="preserve">
          <source>Add .USESHELL target for dmake.</source>
          <target state="translated">dmake에 .USESHELL 대상을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="d7fd295b806f9c0832ab6e0fa24fc58d699dd9d2" translate="yes" xml:space="preserve">
          <source>Add .err files corresponding to each .c file.</source>
          <target state="translated">각 .c 파일에 해당하는 .err 파일을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="c4281d681d2b8d4904dd68ad15e4dae704a1bf89" translate="yes" xml:space="preserve">
          <source>Add Collate Transform magic to an SV if it doesn't already have it. If the flags contain SV_GMAGIC, it handles get-magic.</source>
          <target state="translated">SV에 Collate Transform Magic을 아직 추가하지 않은 경우 추가합니다. 플래그에 SV_GMAGIC이 포함되어 있으면 get-magic을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="047c96ad9c325d237f1a6a46bb8af3410dff2f9a" translate="yes" xml:space="preserve">
          <source>Add MAXLINELENGTH for dmake before all the constants are output.</source>
          <target state="translated">모든 상수가 출력되기 전에 dmake에 MAXLINELENGTH를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="94f0a7f38a5195aa6f33946dfa8058f9d2a857a9" translate="yes" xml:space="preserve">
          <source>Add MM_Unix_VERSION.</source>
          <target state="translated">MM_Unix_VERSION을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="eca289eb94f4122a1cb7f5b2bdff3d6769040fa8" translate="yes" xml:space="preserve">
          <source>Add MM_Win32_VERSION.</source>
          <target state="translated">MM_Win32_VERSION을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="8460c3bd39da428c04164ab6f8557a6dee2cb9dc" translate="yes" xml:space="preserve">
          <source>Add Netware macros initialized above to the Makefile.</source>
          <target state="translated">위에서 초기화 한 Netware 매크로를 Makefile에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="b10d0c59d7d5f8f07519cfec5e7d10053270677d" translate="yes" xml:space="preserve">
          <source>Add Netware macros.</source>
          <target state="translated">Netware 매크로를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="7a597e48edd2e108c64afde5e11638f77279428f" translate="yes" xml:space="preserve">
          <source>Add PERL_VMS, MM_VMS_REVISION and MM_VMS_VERSION.</source>
          <target state="translated">PERL_VMS, MM_VMS_REVISION 및 MM_VMS_VERSION을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="fb8b21b933335774c30773ac556f87eff4a5d7e6" translate="yes" xml:space="preserve">
          <source>Add a TAP::Parser to the multiplexer. &lt;code&gt;$stash&lt;/code&gt; is an optional opaque reference that will be returned from &lt;code&gt;&lt;a href=&quot;../../functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; along with the parser and the next result.</source>
          <target state="translated">멀티플렉서에 TAP :: Parser를 추가하십시오. &lt;code&gt;$stash&lt;/code&gt; 는 파서 및 다음 결과와 함께 &lt;code&gt;&lt;a href=&quot;../../functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 에서 반환되는 선택적 불투명 참조입니다 .</target>
        </trans-unit>
        <trans-unit id="9047e2284dc63577e7faf2c89a8809b765789014" translate="yes" xml:space="preserve">
          <source>Add a filter to filter stack for the database, &lt;code&gt;$db&lt;/code&gt; . The three formats vary only in whether they apply to the DBM key, the DBM value or both.</source>
          <target state="translated">데이터베이스 &lt;code&gt;$db&lt;/code&gt; 대해 필터 스택을 필터하기 위해 필터를 추가하십시오 . 세 가지 형식은 DBM 키, DBM 값 또는 둘 다에 적용되는지에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="8ccc393bac52be3d964bfe9d752d1239af48b643" translate="yes" xml:space="preserve">
          <source>Add a global watch-expression. Whenever a watched global changes the debugger will stop and display the old and new values.</source>
          <target state="translated">글로벌 시계 식을 추가하십시오. 감시 된 전역 변경이있을 때마다 디버거가 중지되고 이전 값과 새 값이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="53d906e02ac64f82dea46944febfd026f128fa47" translate="yes" xml:space="preserve">
          <source>Add a new item to the cache. Without arguments, this method returns a list of all cache elements.</source>
          <target state="translated">캐시에 새 항목을 추가하십시오. 인수가 없으면이 메소드는 모든 캐시 요소의 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a7863f951963cec6a01e64fc9352ec7f1fe9c51d" translate="yes" xml:space="preserve">
          <source>Add a node (or a list of nodes) to the document's node list. Note that the order is kept, i.e. start with the first node and end with the last. If no argument is given, the current list of nodes is returned in the same order the nodes have been added. A node can be any scalar, but usually is a pair of node string and unique id for the &lt;code&gt;find_node&lt;/code&gt; method to work correctly.</source>
          <target state="translated">문서의 노드 목록에 노드 (또는 노드 목록)를 추가하십시오. 순서는 유지됩니다. 즉 첫 번째 노드로 시작하여 마지막 노드로 끝납니다. 인수가 제공되지 않으면 현재 노드 목록이 노드가 추가 된 순서와 동일한 순서로 리턴됩니다. 노드는 임의의 스칼라 일 수 있지만 일반적으로 &lt;code&gt;find_node&lt;/code&gt; 메소드가 올바르게 작동하기 위한 한 쌍의 노드 문자열 및 고유 ID입니다 .</target>
        </trans-unit>
        <trans-unit id="db481968c59a6adf87aa66b0a382f55c4cfeb499" translate="yes" xml:space="preserve">
          <source>Add a pretty-printer method to the module</source>
          <target state="translated">모듈에 예쁜 프린터 방법 추가</target>
        </trans-unit>
        <trans-unit id="b48e494719a297be81c5a3a9a30374bc318e93d9" translate="yes" xml:space="preserve">
          <source>Add a signal to a SigSet object.</source>
          <target state="translated">신호를 SigSet 객체에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="70b454679f6454970d507782ded710647bf0cf50" translate="yes" xml:space="preserve">
          <source>Add additional meta tags here, or blocks of inline CSS or JavaScript (wrapped in the appropriate tags).</source>
          <target state="translated">여기에 메타 태그를 추가하거나 인라인 CSS 또는 JavaScript 블록 (적절한 태그로 래핑)을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="97aac284feaa85ca8cb91bcc63adaf65d2ec487a" translate="yes" xml:space="preserve">
          <source>Add an action (Perl command) to happen before every debugger prompt. A multi-line command may be entered by backwhacking the newlines.</source>
          <target state="translated">모든 디버거 프롬프트 전에 발생하는 조치 (Perl 명령)를 추가하십시오. 줄 바꿈을 backwhack하여 여러 줄 명령을 입력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8abdf94b4d37de8dda8c5f5f2c3f6875f8d6cc2b" translate="yes" xml:space="preserve">
          <source>Add an action (debugger command) to happen before every debugger prompt. A multi-line command may be entered, if you can guess how: see above.</source>
          <target state="translated">모든 디버거 프롬프트 전에 수행 할 조치 (디버거 명령)를 추가하십시오. 방법을 추측 할 수있는 경우 여러 줄 명령을 입력 할 수 있습니다 (위 참조).</target>
        </trans-unit>
        <trans-unit id="f54d96a7a4eeff516086a73ed0f2969f141d74af" translate="yes" xml:space="preserve">
          <source>Add an index entry (or a list of them) to the document's index list. Note that the order is kept, i.e. start with the first node and end with the last. If no argument is given, the current list of index entries is returned in the same order the entries have been added. An index entry can be any scalar, but usually is a pair of string and unique id.</source>
          <target state="translated">색인 항목 (또는 그 목록)을 문서의 색인 목록에 추가하십시오. 순서는 유지됩니다. 즉 첫 번째 노드로 시작하여 마지막 노드로 끝납니다. 인수가 제공되지 않으면 항목이 추가 된 순서와 동일한 순서로 현재 색인 항목 목록이 리턴됩니다. 인덱스 항목은 스칼라 일 수 있지만 일반적으로 문자열과 고유 ID 쌍입니다.</target>
        </trans-unit>
        <trans-unit id="590b7a309d0f6d30b6eb1e4e5ab86b934b9e4cae" translate="yes" xml:space="preserve">
          <source>Add blib/* directories to @INC</source>
          <target state="translated">@INC에 blib / * 디렉토리 추가</target>
        </trans-unit>
        <trans-unit id="169a520f5b682ca9f865299c14fd2b5069cb099b" translate="yes" xml:space="preserve">
          <source>Add comments to the code explaining what you are testing for.</source>
          <target state="translated">테스트 대상을 설명하는 코드에 주석을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="de73e94e79dc3842d720fa32f69c99c36f54b7ec" translate="yes" xml:space="preserve">
          <source>Add data to hash when needed</source>
          <target state="translated">필요할 때 해시 할 데이터 추가</target>
        </trans-unit>
        <trans-unit id="72d8179b381afab6c39843333e65697de042456c" translate="yes" xml:space="preserve">
          <source>Add the following to the end of Mytest.xs:</source>
          <target state="translated">Mytest.xs 끝에 다음을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="9f9a937939c6d51d4a74436ba1cd4f9a4a86f81c" translate="yes" xml:space="preserve">
          <source>Add the list of handles to the &lt;code&gt;IO::Select&lt;/code&gt; object. It is these values that will be returned when an event occurs. &lt;code&gt;IO::Select&lt;/code&gt; keeps these values in a cache which is indexed by the &lt;code&gt;&lt;a href=&quot;../functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; of the handle, so if more than one handle with the same &lt;code&gt;&lt;a href=&quot;../functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; is specified then only the last one is cached.</source>
          <target state="translated">핸들 목록을 &lt;code&gt;IO::Select&lt;/code&gt; 오브젝트에 추가 하십시오 . 이벤트가 발생할 때 리턴되는 값입니다. &lt;code&gt;IO::Select&lt;/code&gt; 는 핸들 의 &lt;code&gt;&lt;a href=&quot;../functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; 에 의해 인덱스 된 캐시에이 값을 유지 하므로, 같은 &lt;code&gt;&lt;a href=&quot;../functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; 를 가진 핸들이 둘 이상 지정된 경우 마지막 핸들 만 캐시됩니다.</target>
        </trans-unit>
        <trans-unit id="19f0b9a66897495c95aa10ee537c78ed856fd477" translate="yes" xml:space="preserve">
          <source>Add to your standard heading the following line:</source>
          <target state="translated">표준 제목에 다음 줄을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="08fc6af7d08fe5cff7ab3490908c8640f386f6f4" translate="yes" xml:space="preserve">
          <source>AddSubtract</source>
          <target state="translated">AddSubtract</target>
        </trans-unit>
        <trans-unit id="0a13f7aff584c83ebd1f9e84aae7b2d05d441e1f" translate="yes" xml:space="preserve">
          <source>Added &lt;code&gt;gztell&lt;/code&gt; .</source>
          <target state="translated">추가는 &lt;code&gt;gztell&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1095a22478b4b66c2ae56250f944a8bfc247cdff" translate="yes" xml:space="preserve">
          <source>Added in perl 5.18.0, this flag indicates that a regular expression might perform an operation that would interfere with inplace substitution. For instance it might contain lookbehind, or assign to non-magical variables (such as $REGMARK and $REGERROR) during matching. &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; will skip certain optimisations when this is set.</source>
          <target state="translated">perl 5.18.0에 추가 된이 플래그는 정규식이 대체 대체를 방해하는 조작을 수행 할 수 있음을 나타냅니다. 예를 들어 일치하는 동안 lookbehind를 포함하거나 마술이 아닌 변수 (예 : $ REGMARK 및 $ REGERROR)에 할당 할 수 있습니다. 이것이 설정되면 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 는 특정 최적화를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="b1d56423c29f7196bca0ef1618ba2dd3e888861c" translate="yes" xml:space="preserve">
          <source>Added in perl 5.22, this method returns the B::REGEXP associated with the op. While PMOPs do not actually have &lt;code&gt;pmregexp&lt;/code&gt; fields under threaded builds, this method returns the regexp under threads nonetheless, for convenience.</source>
          <target state="translated">perl 5.22에 추가 된이 메소드는 op와 연관된 B :: REGEXP를 리턴합니다. PMOP에는 스레드 빌드에서 실제로 &lt;code&gt;pmregexp&lt;/code&gt; 필드 가 없지만 이 메소드는 편의상 스레드에서 regexp를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2ba88f457f4acc695f5bcc5b53d0aed8e9a2a045" translate="yes" xml:space="preserve">
          <source>Adder</source>
          <target state="translated">Adder</target>
        </trans-unit>
        <trans-unit id="6d548b5512a4a3be1ad17c320cc40231db228d55" translate="yes" xml:space="preserve">
          <source>Adding &lt;code&gt;\W*&lt;/code&gt; at either end to eliminate what is to be ignored, we already have the full pattern:</source>
          <target state="translated">무시할 대상을 제거하기 위해 양쪽 끝에 &lt;code&gt;\W*&lt;/code&gt; 를 추가하면 이미 전체 패턴이 있습니다.</target>
        </trans-unit>
        <trans-unit id="75c6e513c1fb807d0884fb4286f8d06fe79494da" translate="yes" xml:space="preserve">
          <source>Adding a Copyright Notice.</source>
          <target state="translated">저작권 고지 추가.</target>
        </trans-unit>
        <trans-unit id="303fa6167f30afc58e107870ab55bef298f595d5" translate="yes" xml:space="preserve">
          <source>Adding a Perl interpreter to your C program</source>
          <target state="translated">C 프로그램에 Perl 인터프리터 추가</target>
        </trans-unit>
        <trans-unit id="3494708836bea1e13cb2fb34de6c0bb041485662" translate="yes" xml:space="preserve">
          <source>Adding a colon &quot;:&quot; or empty string &quot;&quot; to a path at</source>
          <target state="translated">경로에 콜론 &quot;:&quot;또는 빈 문자열 &quot;&quot;추가</target>
        </trans-unit>
        <trans-unit id="a53e4c0ef202bbd1f27920e920bc75f378ee45c9" translate="yes" xml:space="preserve">
          <source>Adding directories to @INC</source>
          <target state="translated">@INC에 디렉토리 추가</target>
        </trans-unit>
        <trans-unit id="b8ef134eb6c634200333aedff61c4a77cc1d0006" translate="yes" xml:space="preserve">
          <source>Adding new core tests</source>
          <target state="translated">새로운 핵심 테스트 추가</target>
        </trans-unit>
        <trans-unit id="b80f8c556c16b44d25bfbabc5e3f14bb1ae5d40d" translate="yes" xml:space="preserve">
          <source>Adding non-comment stuff after #endif or #else</source>
          <target state="translated">#endif 또는 #else 뒤에 주석이 아닌 내용 추가</target>
        </trans-unit>
        <trans-unit id="65ffd7a09837afed5bf94ab1e1f31e15cc6844fb" translate="yes" xml:space="preserve">
          <source>Adding, deprecating, or removing core features</source>
          <target state="translated">핵심 기능 추가, 폐기 또는 제거</target>
        </trans-unit>
        <trans-unit id="dd881a1fe5170572b503d70ad2a1b006df408296" translate="yes" xml:space="preserve">
          <source>Adding, deprecating, removing, or upgrading core or dual-life modules</source>
          <target state="translated">코어 또는 이중 수명 모듈 추가, 폐기, 제거 또는 업그레이드</target>
        </trans-unit>
        <trans-unit id="aa19c6fc6789672e5ea06b36cec0c6ea7c8038fa" translate="yes" xml:space="preserve">
          <source>Adding, removing, or significantly changing documentation in the</source>
          <target state="translated">문서를 추가, 제거 또는 크게 변경</target>
        </trans-unit>
        <trans-unit id="1d418e4d86845beab5da12aea1ba94a51ff3bc29" translate="yes" xml:space="preserve">
          <source>Addition of &lt;code&gt;gzseek&lt;/code&gt; to provide a restricted &lt;code&gt;&lt;a href=&quot;../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; interface.</source>
          <target state="translated">제한된 &lt;code&gt;&lt;a href=&quot;../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 인터페이스 를 제공하기 위해 &lt;code&gt;gzseek&lt;/code&gt; 추가</target>
        </trans-unit>
        <trans-unit id="21cbac17404588ed0f4a75e1ba94b2723810229c" translate="yes" xml:space="preserve">
          <source>Additional allowable exit values can be supplied as an optional first argument to autodying &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">추가 허용 종료 값은 자동 염색 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 대한 선택적 첫 번째 인수로 제공 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="95fcc23a5989c1d4707ef062b9c48e30e43e8eea" translate="yes" xml:space="preserve">
          <source>Additional arbitrary HTML tags for the header of the document. The default value is just a content type header tag:</source>
          <target state="translated">문서 헤더에 대한 추가 임의 HTML 태그 기본값은 컨텐츠 유형 헤더 태그입니다.</target>
        </trans-unit>
        <trans-unit id="93ccf6b3b0fed7eda8c1cf492ae71f85cc3c2416" translate="yes" xml:space="preserve">
          <source>Additional behaviors can be added to your &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; method by overriding &lt;code&gt;import_extra()&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;import_extra()&lt;/code&gt; 를 재정 의하여 &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; 메소드에 추가 동작을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b69974bf6d56e57936d88d6a5f708b80a863eea6" translate="yes" xml:space="preserve">
          <source>Additional code by Yves Orton.</source>
          <target state="translated">Yves Orton의 추가 코드.</target>
        </trans-unit>
        <trans-unit id="07c4a7582a6b085c26b5bc77e2d781374f6214f8" translate="yes" xml:space="preserve">
          <source>Additional context-dependent optimizations are performed at this time. Since at this moment the compile tree contains back-references (via &quot;thread&quot; pointers), nodes cannot be free()d now. To allow optimized-away nodes at this stage, such nodes are null()ified instead of free()ing (i.e. their type is changed to OP_NULL).</source>
          <target state="translated">현재 상황에 따른 추가 최적화가 수행됩니다. 이 시점에서 컴파일 트리에는 &quot;스레드&quot;포인터를 통한 역 참조가 포함되므로 노드를 해제 할 수 없습니다. 이 단계에서 최적화 된 노드를 허용하기 위해 이러한 노드는 free () 대신 널 ()로 지정됩니다 (예 : 유형이 OP_NULL로 변경됨).</target>
        </trans-unit>
        <trans-unit id="31fd46d11c3bbe73ad92eebf33f7553ded695d16" translate="yes" xml:space="preserve">
          <source>Additional contributions by The Perl 5 Porters.</source>
          <target state="translated">The Perl 5 Porters의 추가 공헌</target>
        </trans-unit>
        <trans-unit id="65d277fbf8e91201355e93559429e2b46f057ea7" translate="yes" xml:space="preserve">
          <source>Additional flags to specify to C preprocessor when scanning header for function declarations. Writes these options in the generated</source>
          <target state="translated">함수 선언을 위해 헤더를 스캔 할 때 C 프리 프로세서에 지정할 추가 플래그. 생성 된 옵션에 이러한 옵션을 씁니다.</target>
        </trans-unit>
        <trans-unit id="8fab7fe5b84df4c38b3df13c3aab585166d6f79c" translate="yes" xml:space="preserve">
          <source>Additional flags:</source>
          <target state="translated">추가 플래그 :</target>
        </trans-unit>
        <trans-unit id="224b8dd98beb03b9721f84cf4768d8e500e8a1d7" translate="yes" xml:space="preserve">
          <source>Additional functions not exported by default:</source>
          <target state="translated">기본적으로 내 보내지 않는 추가 기능 :</target>
        </trans-unit>
        <trans-unit id="c00e0d54188b0a52cda35b7ee1e5c81c6e17488d" translate="yes" xml:space="preserve">
          <source>Additional linker arguments to be considered.</source>
          <target state="translated">추가 링커 인수를 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="c75d2357555d61500cb561ea756aab492ce04979" translate="yes" xml:space="preserve">
          <source>Additional lowercase attributes</source>
          <target state="translated">추가 소문자 속성</target>
        </trans-unit>
        <trans-unit id="62669130426d053245d54e15329b7bbb244bddc3" translate="yes" xml:space="preserve">
          <source>Additional methods that are provided are:</source>
          <target state="translated">제공되는 추가 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c9f0c499a9f295c841e5042dc5fcae68b2718736" translate="yes" xml:space="preserve">
          <source>Additional modules:</source>
          <target state="translated">추가 모듈 :</target>
        </trans-unit>
        <trans-unit id="5cb0cfaa4bee3834bdbab722883416b06bf0e1b8" translate="yes" xml:space="preserve">
          <source>Additional option files may be specified with the &lt;code&gt;--rc&lt;/code&gt; option. Default option file processing is disabled by the &lt;code&gt;--norc&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;--rc&lt;/code&gt; 옵션으로 추가 옵션 파일을 지정할 수 있습니다 . 기본 옵션 파일 처리는 &lt;code&gt;--norc&lt;/code&gt; 옵션에 의해 비활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="a9910904f4a1f818c8f8c0fa7217add5b79e193c" translate="yes" xml:space="preserve">
          <source>Additional supported functions</source>
          <target state="translated">추가 지원 기능</target>
        </trans-unit>
        <trans-unit id="62f57b1281983cef6c2785663a1426c055f3a73b" translate="yes" xml:space="preserve">
          <source>Additional thanks to: Edward Avis / Mattia Barbon / Tom Christiansen / Gerrit Haase / Gurusamy Sarathy / Jarkko Hietaniemi (again) / Nikola Knezevic / John Kominetz / Nick Ing-Simmons / Tassilo von Parseval / H. Dieter Pearcey / Slaven Rezic / Eric Roode / Peter Scott / Peter Somu / Autrijus Tang (again) / Tels (again) / Juerd Waalboer / Todd Rinaldo</source>
          <target state="translated">추가 감사 : Edward Avis / Mattia Barbon / Tom Christiansen / Gerrit Haase / Gurusamy Sarathy / Jarkko Hietaniemi (다시) / Nikola Knezevic / John Kominetz / Nick Ing-Simmons / Tassilo von Parseval / H. Dieter Pearcey / Slaven Rezic / Eric Roode / Peter Scott / Peter Somu / Autrijus Tang (다시) / Tels (다시) / Juerd Waalboer / Todd Rinaldo</target>
        </trans-unit>
        <trans-unit id="0faa935c5b1efc0ef2a1c52135455cd6a03aa947" translate="yes" xml:space="preserve">
          <source>Additionally &lt;a href=&quot;#weaken&quot;&gt;weaken&lt;/a&gt; and &lt;a href=&quot;#isweak&quot;&gt;isweak&lt;/a&gt; which are</source>
          <target state="translated">또한 &lt;a href=&quot;#weaken&quot;&gt;약화&lt;/a&gt; 및 &lt;a href=&quot;#isweak&quot;&gt;isweak&lt;/a&gt; 있는</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
