<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="48d16a26d9f41be014d7cb3e5f6b9f3ee7edffee" translate="yes" xml:space="preserve">
          <source>specify (in &lt;code&gt;WriteMakefile()&lt;/code&gt; ):</source>
          <target state="translated">( &lt;code&gt;WriteMakefile()&lt;/code&gt; )을 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="2f223b9c4e5f0defc1f0dc33d65dcd3a8b1a20b4" translate="yes" xml:space="preserve">
          <source>specify dependencies the original maintainer forgot</source>
          <target state="translated">원래 관리자가 잊어 버린 종속성을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="95eeb58adbf5f519ec33bbad9c33c334a529f0d2" translate="yes" xml:space="preserve">
          <source>specify that the normal Perl @INC</source>
          <target state="translated">정상적인 Perl @INC를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="a209d61567c7f4b583a143710470e25b5d5366af" translate="yes" xml:space="preserve">
          <source>specify the variable's name, including leading sigil.</source>
          <target state="translated">선행 sigil을 포함하여 변수 이름을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="a13e0c7dace3c97deaa75f3b60d13568b970c225" translate="yes" xml:space="preserve">
          <source>specify the variable's name, including leading sigil. If</source>
          <target state="translated">선행 sigil을 포함하여 변수 이름을 지정하십시오. 만약</target>
        </trans-unit>
        <trans-unit id="5ee5fc55eefeeffa3b134d3232f7012a33185cc1" translate="yes" xml:space="preserve">
          <source>specifying the task in detail,</source>
          <target state="translated">작업을 자세하게 지정하면</target>
        </trans-unit>
        <trans-unit id="08ca65393cebed736f19ed46250af41bd90eac3f" translate="yes" xml:space="preserve">
          <source>spitshell.U</source>
          <target state="translated">spitshell.U</target>
        </trans-unit>
        <trans-unit id="bc9f74ff779f8e7d55cf3e8a4de59aac940853a9" translate="yes" xml:space="preserve">
          <source>splain</source>
          <target state="translated">splain</target>
        </trans-unit>
        <trans-unit id="b7baa4c262f38bec530fae7b1314e401653644d6" translate="yes" xml:space="preserve">
          <source>splice</source>
          <target state="translated">splice</target>
        </trans-unit>
        <trans-unit id="2616fb7f6e6f1c46a52ca21a3f1381cbca36ce42" translate="yes" xml:space="preserve">
          <source>splice ARRAY</source>
          <target state="translated">스플 라이스 ARRAY</target>
        </trans-unit>
        <trans-unit id="12a712e89d96498abeb93ffbead46760f3934649" translate="yes" xml:space="preserve">
          <source>splice ARRAY,OFFSET</source>
          <target state="translated">결합 배열, 오프셋</target>
        </trans-unit>
        <trans-unit id="63c64236a41d11a045bbea0d757b827b7ee17940" translate="yes" xml:space="preserve">
          <source>splice ARRAY,OFFSET,LENGTH</source>
          <target state="translated">결합 배열, 오프셋, 길이</target>
        </trans-unit>
        <trans-unit id="4c42b6952c9f22cbcc9a78cb2ff96c595091af27" translate="yes" xml:space="preserve">
          <source>splice ARRAY,OFFSET,LENGTH,LIST</source>
          <target state="translated">결합 배열, 오프셋, 길이, 목록</target>
        </trans-unit>
        <trans-unit id="eba49a93ed234086f77b0e62128e87c1d2a1ff96" translate="yes" xml:space="preserve">
          <source>splice EXPR</source>
          <target state="translated">스플 라이스 EXPR</target>
        </trans-unit>
        <trans-unit id="d5750018faf83eb7bad6754381ffbc60920f6901" translate="yes" xml:space="preserve">
          <source>splice EXPR,OFFSET</source>
          <target state="translated">스플 라이스 EXPR, OFFSET</target>
        </trans-unit>
        <trans-unit id="8cad940b2fcd46f4dcad5340cafaaef0845136c9" translate="yes" xml:space="preserve">
          <source>splice EXPR,OFFSET,LENGTH</source>
          <target state="translated">접속 EXPR, 오프셋, 길이</target>
        </trans-unit>
        <trans-unit id="d3dfa0f1ed8ab1e87c6e2e585bd9d172e8a83ced" translate="yes" xml:space="preserve">
          <source>splice EXPR,OFFSET,LENGTH,LIST</source>
          <target state="translated">스플 라이스 EXPR, OFFSET, LENGTH, LIST</target>
        </trans-unit>
        <trans-unit id="94d5cab6f5fe3422a447ab15436e7a672bc0c09a" translate="yes" xml:space="preserve">
          <source>split</source>
          <target state="translated">split</target>
        </trans-unit>
        <trans-unit id="ac948e3fe139383bc50a7b7b6bec28341556da4e" translate="yes" xml:space="preserve">
          <source>split /PATTERN/</source>
          <target state="translated">스플릿 / PATTERN /</target>
        </trans-unit>
        <trans-unit id="c29c06c429f689ab3f15c34cf0f05bf3279fe35a" translate="yes" xml:space="preserve">
          <source>split /PATTERN/,EXPR</source>
          <target state="translated">스플릿 / PATTERN /, EXPR</target>
        </trans-unit>
        <trans-unit id="9c02a35452960b8061c5041058a979fc004ed8c0" translate="yes" xml:space="preserve">
          <source>split /PATTERN/,EXPR,LIMIT</source>
          <target state="translated">분할 / PATTERN /, EXPR, LIMIT</target>
        </trans-unit>
        <trans-unit id="6268dfe06a8fec82c4cba1c4f3435d05fc39b73b" translate="yes" xml:space="preserve">
          <source>split.exe</source>
          <target state="translated">split.exe</target>
        </trans-unit>
        <trans-unit id="0943d6a64642e994ec69f6f5d1b659f14f3f33b5" translate="yes" xml:space="preserve">
          <source>split_command</source>
          <target state="translated">split_command</target>
        </trans-unit>
        <trans-unit id="28e7617692334dfe7e5fa6201d64cc35b4288116" translate="yes" xml:space="preserve">
          <source>sprintf</source>
          <target state="translated">sprintf</target>
        </trans-unit>
        <trans-unit id="9b7e408b5634f7134a2d3dbcbae42c51ca665f1f" translate="yes" xml:space="preserve">
          <source>sprintf FORMAT, LIST</source>
          <target state="translated">sprintf 형식, 목록</target>
        </trans-unit>
        <trans-unit id="f4c905336d42a8c4402119e9f334f17321f1c67d" translate="yes" xml:space="preserve">
          <source>sprintf(3)</source>
          <target state="translated">sprintf(3)</target>
        </trans-unit>
        <trans-unit id="72f3153cdbbfbaaca9285b4d7d97df1c90194172" translate="yes" xml:space="preserve">
          <source>sqrt</source>
          <target state="translated">sqrt</target>
        </trans-unit>
        <trans-unit id="79d759ce8028b457162866a6ec2a9c4130a0bd40" translate="yes" xml:space="preserve">
          <source>sqrt EXPR</source>
          <target state="translated">sqrt EXPR</target>
        </trans-unit>
        <trans-unit id="51480679cc628618e1f82224a11a2de1db4a36e5" translate="yes" xml:space="preserve">
          <source>srand</source>
          <target state="translated">srand</target>
        </trans-unit>
        <trans-unit id="bb6cd71c2a8f6f02e4e795e14fedad3fb3530832" translate="yes" xml:space="preserve">
          <source>srand EXPR</source>
          <target state="translated">srand EXPR</target>
        </trans-unit>
        <trans-unit id="c882e08c62ca1c7dbf71100bd166aa6cf2cdecbc" translate="yes" xml:space="preserve">
          <source>src.U</source>
          <target state="translated">src.U</target>
        </trans-unit>
        <trans-unit id="116db8d07776534b8e26a3f599fe37fe92d4c357" translate="yes" xml:space="preserve">
          <source>src/misc/db.1.85.tar.gz</source>
          <target state="translated">src/misc/db.1.85.tar.gz</target>
        </trans-unit>
        <trans-unit id="efe2e01d62234b754918ef1aa109c13d8f720f71" translate="yes" xml:space="preserve">
          <source>ssizetype.U</source>
          <target state="translated">ssizetype.U</target>
        </trans-unit>
        <trans-unit id="763b379567b67648805ccb4dea79440bd48adb24" translate="yes" xml:space="preserve">
          <source>st_ino_def.U</source>
          <target state="translated">st_ino_def.U</target>
        </trans-unit>
        <trans-unit id="239cae3c920814c7711f11d4adceadaf14e6ced9" translate="yes" xml:space="preserve">
          <source>stability might matter because elements that compare equal on the first 3 characters may be distinguished based on subsequent characters. In Perl 5.8 and later, quicksort can be stabilized, but doing so will add overhead, so it should only be done if it matters.</source>
          <target state="translated">처음 3 자에서 동등하게 비교되는 요소는 후속 문자를 기반으로 구별 될 수 있으므로 안정성이 중요 할 수 있습니다. Perl 5.8 이상에서는 퀵 정렬을 안정화 할 수 있지만 오버 헤드가 추가되므로 중요한 경우에만 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="4fbacc2fa0ffdbb11bf1ad6925b886ebd08dd15f" translate="yes" xml:space="preserve">
          <source>stable</source>
          <target state="translated">stable</target>
        </trans-unit>
        <trans-unit id="0b5cceaafa4cc072ea5e5f558cd1e99a8f503c2d" translate="yes" xml:space="preserve">
          <source>standalone</source>
          <target state="translated">standalone</target>
        </trans-unit>
        <trans-unit id="0ace4a105e3e3861037fb829606a3a0ada08413c" translate="yes" xml:space="preserve">
          <source>standard distribution</source>
          <target state="translated">표준 분포</target>
        </trans-unit>
        <trans-unit id="2b020927d3c6eb407223a1baa3d6ce3597a3f88d" translate="yes" xml:space="preserve">
          <source>start</source>
          <target state="translated">start</target>
        </trans-unit>
        <trans-unit id="08cadc9ae2fc836f49d3941318f63f6218b5f018" translate="yes" xml:space="preserve">
          <source>start is the node preceding the first node to be spliced. Node(s) following it will be deleted, and ops will be inserted after it. If it is NULL, the first node onwards is deleted, and nodes are inserted at the beginning.</source>
          <target state="translated">start는 스 플라이 싱 될 첫 번째 노드 앞에있는 노드입니다. 그 다음에 나오는 노드는 삭제되고 그 뒤에 op가 삽입됩니다. NULL이면 첫 번째 노드부터 삭제되고 노드는 처음에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="022400803c64233cb27fac5fe69aee61d23ec98b" translate="yes" xml:space="preserve">
          <source>start-of-range</source>
          <target state="translated">start-of-range</target>
        </trans-unit>
        <trans-unit id="786f0ed95a949ed86fa180801d114d5051e41805" translate="yes" xml:space="preserve">
          <source>starting at</source>
          <target state="translated">~에서 시작</target>
        </trans-unit>
        <trans-unit id="b9dd521b01030edc79b01f7e6d88d0e24deca83f" translate="yes" xml:space="preserve">
          <source>startperl.U</source>
          <target state="translated">startperl.U</target>
        </trans-unit>
        <trans-unit id="b681dba1be4594e15b104bbb4b4ac55b2b7f57c2" translate="yes" xml:space="preserve">
          <source>starts as zero but can be altered via &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, and determined via &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">0으로 시작하지만 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 를 통해 변경 하고 &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 을 통해 결정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9bbcb38aa983cb766fa8c10755823f139e8fc0b7" translate="yes" xml:space="preserve">
          <source>startsh.U</source>
          <target state="translated">startsh.U</target>
        </trans-unit>
        <trans-unit id="fc165ac761802cfe0b77c55f9ed07e23a41650fb" translate="yes" xml:space="preserve">
          <source>stat</source>
          <target state="translated">stat</target>
        </trans-unit>
        <trans-unit id="9998a9a739cd3695e043f9af6c3f38dcec8458f2" translate="yes" xml:space="preserve">
          <source>stat DIRHANDLE</source>
          <target state="translated">통계 DIRHANDLE</target>
        </trans-unit>
        <trans-unit id="a0eabf5cc5996f6337f0d5b9ea19584ff39f13ee" translate="yes" xml:space="preserve">
          <source>stat EXPR</source>
          <target state="translated">스탯 EXPR</target>
        </trans-unit>
        <trans-unit id="807c6114a86022734d0861751c6b95f83419c8a3" translate="yes" xml:space="preserve">
          <source>stat FILEHANDLE</source>
          <target state="translated">통계 파일 핸들</target>
        </trans-unit>
        <trans-unit id="21e1087fb4f7788c00ef05c2e2c2da50af5a29a4" translate="yes" xml:space="preserve">
          <source>stat.h</source>
          <target state="translated">stat.h</target>
        </trans-unit>
        <trans-unit id="aa4a5f8125f234182e2dea92805afdfb747a86be" translate="yes" xml:space="preserve">
          <source>state</source>
          <target state="translated">state</target>
        </trans-unit>
        <trans-unit id="ced396f1a90896f9811c09bfcbb9a8cad6dac141" translate="yes" xml:space="preserve">
          <source>state TYPE VARLIST</source>
          <target state="translated">상태 TYPE VARLIST</target>
        </trans-unit>
        <trans-unit id="20d5cc99dcfd66fdc07b4e75841debc2dbd7d70f" translate="yes" xml:space="preserve">
          <source>state TYPE VARLIST : ATTRS</source>
          <target state="translated">상태 유형 목록 : 공격자</target>
        </trans-unit>
        <trans-unit id="d5eff69b9e8fd7a7b90b3b815fc5d71ed187aa47" translate="yes" xml:space="preserve">
          <source>state VARLIST</source>
          <target state="translated">주 VARLIST</target>
        </trans-unit>
        <trans-unit id="271b33ffeedf25183ca3d81c88764b12f1081666" translate="yes" xml:space="preserve">
          <source>state VARLIST : ATTRS</source>
          <target state="translated">상태 VARLIST : ATTRS</target>
        </trans-unit>
        <trans-unit id="8c7aac7672f65451267eb994144065eff5989afe" translate="yes" xml:space="preserve">
          <source>state, and so does not appear in the list returned by &lt;code&gt;threads-&amp;gt;list()&lt;/code&gt; .</source>
          <target state="translated">상태이므로 &lt;code&gt;threads-&amp;gt;list()&lt;/code&gt; 반환 한 목록에 나타나지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="cc1f418fb6974a4fe2f3ea007621265ac0e28236" translate="yes" xml:space="preserve">
          <source>state. See &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perl58delta.html#Safe-Signals&quot;&gt;Safe Signals in perl58delta&lt;/a&gt; and &lt;a href=&quot;perlipc#Deferred-Signals-(Safe-Signals)&quot;&gt;Deferred Signals (Safe Signals) in perlipc&lt;/a&gt; for more details.</source>
          <target state="translated">상태. 자세한 내용 &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perl58delta.html#Safe-Signals&quot;&gt;은 perl58delta의 안전 신호&lt;/a&gt; 및 perlipc의 &lt;a href=&quot;perlipc#Deferred-Signals-(Safe-Signals)&quot;&gt;지연 신호 (안전 신호)&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="932d01c17ae82cda4efa38f751587dcb8a781099" translate="yes" xml:space="preserve">
          <source>state_version</source>
          <target state="translated">state_version</target>
        </trans-unit>
        <trans-unit id="bbb930cc426507ed3f6b7c343c75dd0e041494b7" translate="yes" xml:space="preserve">
          <source>statement</source>
          <target state="translated">statement</target>
        </trans-unit>
        <trans-unit id="54bdb88217df66cde42436678a4c375cc9a099b4" translate="yes" xml:space="preserve">
          <source>statement in the subroutine</source>
          <target state="translated">서브 루틴의 명령문</target>
        </trans-unit>
        <trans-unit id="a381562afa0e16c5548e829b2f1a659a8c2e7c11" translate="yes" xml:space="preserve">
          <source>static</source>
          <target state="translated">static</target>
        </trans-unit>
        <trans-unit id="b02321af0b16972951f62b2fe2e1c6a51072419b" translate="yes" xml:space="preserve">
          <source>statistical time-sampling</source>
          <target state="translated">통계 타임 샘플링</target>
        </trans-unit>
        <trans-unit id="48a3661d846478fa991a825ebd10b78671444b5b" translate="yes" xml:space="preserve">
          <source>status</source>
          <target state="translated">status</target>
        </trans-unit>
        <trans-unit id="024e63225e76cd46ebb2de279b11dcbc5eccacce" translate="yes" xml:space="preserve">
          <source>status code (&lt;code&gt;$status&lt;/code&gt; ). In a scalar context it returns the inflation object only.</source>
          <target state="translated">상태 코드 ( &lt;code&gt;$status&lt;/code&gt; ). 스칼라 컨텍스트에서는 인플레이션 객체 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4572c83a149c0e163e85aadf01cbfc2705fd4d98" translate="yes" xml:space="preserve">
          <source>status code in &lt;code&gt;$status&lt;/code&gt; . In a scalar context it returns the inflation stream only.</source>
          <target state="translated">&lt;code&gt;$status&lt;/code&gt; 상태 코드 . 스칼라 컨텍스트에서는 인플레이션 스트림 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="65ab6178b5bb65263f1d2b6dbfe9770716f945ed" translate="yes" xml:space="preserve">
          <source>stdarg.h</source>
          <target state="translated">stdarg.h</target>
        </trans-unit>
        <trans-unit id="a9fa8e1c580e694c07ff1d29bd6b91ea91fd7705" translate="yes" xml:space="preserve">
          <source>stdchar.U</source>
          <target state="translated">stdchar.U</target>
        </trans-unit>
        <trans-unit id="45dba8aa65b0debb3a7090a0ee8ff83caa794b20" translate="yes" xml:space="preserve">
          <source>stderr.txt</source>
          <target state="translated">stderr.txt</target>
        </trans-unit>
        <trans-unit id="992c2711fc506e6dc28f2ea8eedab248c1567bf2" translate="yes" xml:space="preserve">
          <source>stdin.txt</source>
          <target state="translated">stdin.txt</target>
        </trans-unit>
        <trans-unit id="406ce85c8f803ee40b9e12ea03120d86d05edbbc" translate="yes" xml:space="preserve">
          <source>stdio.h</source>
          <target state="translated">stdio.h</target>
        </trans-unit>
        <trans-unit id="87e34339d4e6b16a542d3988dadda8ddb3937f31" translate="yes" xml:space="preserve">
          <source>stdio_streams.U</source>
          <target state="translated">stdio_streams.U</target>
        </trans-unit>
        <trans-unit id="12f3f549b822f5e7a5827ea917abe581dcfe2da3" translate="yes" xml:space="preserve">
          <source>stdlib.h</source>
          <target state="translated">stdlib.h</target>
        </trans-unit>
        <trans-unit id="68ad3077ff5a452a1c6af2d3070fc26a224fb69e" translate="yes" xml:space="preserve">
          <source>stdout.txt</source>
          <target state="translated">stdout.txt</target>
        </trans-unit>
        <trans-unit id="fb3a873781fcf5e4d0153021f030ffb2478296c7" translate="yes" xml:space="preserve">
          <source>stdout/stderr now go into the files</source>
          <target state="translated">stdout / stderr은 이제 파일로 이동합니다</target>
        </trans-unit>
        <trans-unit id="92fc138bc7e25a36921b6e305ce7eee716d0f9ce" translate="yes" xml:space="preserve">
          <source>step over</source>
          <target state="translated">물러서 다</target>
        </trans-unit>
        <trans-unit id="7583e62e3d3829835245dd94568102b8618a99ff" translate="yes" xml:space="preserve">
          <source>stepping off</source>
          <target state="translated">출발</target>
        </trans-unit>
        <trans-unit id="803e4c41bbd2212a675dbe73defc33a72fea64e6" translate="yes" xml:space="preserve">
          <source>sticks</source>
          <target state="translated">sticks</target>
        </trans-unit>
        <trans-unit id="3d48292e4d2714f11c2adf276b610971e068a519" translate="yes" xml:space="preserve">
          <source>storage</source>
          <target state="translated">storage</target>
        </trans-unit>
        <trans-unit id="c82e3d7279efa3eca576370af952c815d48ce41f" translate="yes" xml:space="preserve">
          <source>stream</source>
          <target state="translated">stream</target>
        </trans-unit>
        <trans-unit id="41eaab877ca3a0e3aa14f5a4b7981f590e3c2bd6" translate="yes" xml:space="preserve">
          <source>strict</source>
          <target state="translated">strict</target>
        </trans-unit>
        <trans-unit id="96f25d4f3e97a1ef0603aee48b48d787241b153f" translate="yes" xml:space="preserve">
          <source>strict - Perl pragma to restrict unsafe constructs</source>
          <target state="translated">엄격-안전하지 않은 구조를 제한하는 Perl pragma</target>
        </trans-unit>
        <trans-unit id="170929fc44f4ddbc242c5b0f1e2624d778f09128" translate="yes" xml:space="preserve">
          <source>strict.pm</source>
          <target state="translated">strict.pm</target>
        </trans-unit>
        <trans-unit id="ecb252044b5ea0f679ee78ec1a12904739e2904d" translate="yes" xml:space="preserve">
          <source>string</source>
          <target state="translated">string</target>
        </trans-unit>
        <trans-unit id="a4fc86cc3e0b9869ed563caa0d277d34cd15cf05" translate="yes" xml:space="preserve">
          <source>string form of the constant, the second one is how Perl interprets this constant, the third one is how the constant is used. Note that the initial string form does not contain string delimiters, and has backslashes in backslash-delimiter combinations stripped (thus the value of delimiter is not relevant for processing of this string). The return value of this function is how this constant is going to be interpreted by Perl. The third argument is undefined unless for overloaded &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt;- and &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr&lt;/a&gt;&lt;/code&gt;- constants, it is &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; in single-quote context (comes from strings, regular expressions, and single-quote HERE documents), it is &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; for arguments of &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; operators, it is &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; for right-hand side of &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;-operator, and it is &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">문자열 형식의 상수, 두 번째는 Perl이이 상수를 해석하는 방법이고, 세 번째는 상수가 사용되는 방법입니다. 초기 문자열 형식에는 문자열 구분 기호가 포함되지 않으며 백 슬래시 구분 기호 조합에서 백 슬래시가 제거됩니다 (따라서 구분 기호 값은이 문자열 처리와 관련이 없음). 이 함수의 반환 값은이 상수가 Perl에 의해 해석되는 방식입니다. 오버로드에 대한 않는 세 번째 인수는 정의되지 않는다 &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; 와 - &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr&lt;/a&gt;&lt;/code&gt; - 상수, 그것이 &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; 단일 인용 맥락에서 (문자열, 정규 표현식, 그리고 작은 따옴표 여기 문서에서 유래), 그것이 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; 의 인수에 대한 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; 사업자, 그것은이다 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; - 오퍼레이터 의 오른쪽에 대해서는 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c32ff0561e50c22a71e602a7d98c4e5fe27e6270" translate="yes" xml:space="preserve">
          <source>string is an &quot;&lt;code&gt;fopen()&lt;/code&gt; -like&quot; string which would match the regular expression &lt;code&gt;/^[I#]?[rwa]\+?[bt]?$/&lt;/code&gt; .</source>
          <target state="translated">string은 정규식 &lt;code&gt;/^[I#]?[rwa]\+?[bt]?$/&lt;/code&gt; 와 일치 하는 &quot; &lt;code&gt;fopen()&lt;/code&gt; -like&quot;문자열입니다 .</target>
        </trans-unit>
        <trans-unit id="887785b307fb41905fac3f5f27b08b3a6b98290a" translate="yes" xml:space="preserve">
          <source>string is true, it really should (for backwards compatibility with older Test.pm versions) start with the string &quot;Skip&quot;, as shown in the above examples.</source>
          <target state="translated">string이 true이면 위의 예와 같이 &quot;이전 Test.pm 버전과의 하위 호환성을 위해)&quot;Skip &quot;문자열로 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="3a44afe5fc8faf20ca2e98b939c7c9f025af24e3" translate="yes" xml:space="preserve">
          <source>string is used instead of reading a termcap file. If it does begin with a slash, the string is used as a path name of the termcap file to search. If</source>
          <target state="translated">termcap 파일을 읽는 대신 문자열이 사용됩니다. 슬래시로 시작하면 문자열은 검색 할 termcap 파일의 경로 이름으로 사용됩니다. 만약</target>
        </trans-unit>
        <trans-unit id="1855951a0178eff72d32106e82cadc99cd03510c" translate="yes" xml:space="preserve">
          <source>string.c</source>
          <target state="translated">string.c</target>
        </trans-unit>
        <trans-unit id="59ffa46484e85b209f6ba7ff12829a1375a063ec" translate="yes" xml:space="preserve">
          <source>stringification</source>
          <target state="translated">stringification</target>
        </trans-unit>
        <trans-unit id="a63050cdf83721e499d02d2f3d432f267f922d5e" translate="yes" xml:space="preserve">
          <source>strings to be used. This time we will use a</source>
          <target state="translated">사용될 문자열. 이번에는</target>
        </trans-unit>
        <trans-unit id="6e77d135758c9c845119b28e12b65a1430e1224f" translate="yes" xml:space="preserve">
          <source>strongly</source>
          <target state="translated">strongly</target>
        </trans-unit>
        <trans-unit id="c36cf7d6ebb6072d7f9cc8640d54bdf9d904b71b" translate="yes" xml:space="preserve">
          <source>strongly discouraged</source>
          <target state="translated">낙심하다</target>
        </trans-unit>
        <trans-unit id="6ad323d1a641c0194e65ef7bbcf4f2ff123ba15a" translate="yes" xml:space="preserve">
          <source>strongly recommended that you read &lt;a href=&quot;perltie#The-untie-Gotcha&quot;&gt;The untie Gotcha in perltie&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;perltie#The-untie-Gotcha&quot;&gt;perltie의 The untie Gotcha&lt;/a&gt; 를 읽어 볼 것을 강력히 권장합니다 .</target>
        </trans-unit>
        <trans-unit id="cfb18e81efbda9473cefbd150d9be1eb0ac7840b" translate="yes" xml:space="preserve">
          <source>stuck</source>
          <target state="translated">stuck</target>
        </trans-unit>
        <trans-unit id="885534c19d5f8389b4cc0a7fcd699206bacdbd86" translate="yes" xml:space="preserve">
          <source>study</source>
          <target state="translated">study</target>
        </trans-unit>
        <trans-unit id="58e6b3cd9d8a5fb746718c9cee025688cbb60efb" translate="yes" xml:space="preserve">
          <source>study SCALAR</source>
          <target state="translated">스칼라 연구</target>
        </trans-unit>
        <trans-unit id="5eee38381388b6f30efdd5c5c6f067dbf32c0bb3" translate="yes" xml:space="preserve">
          <source>stuff</source>
          <target state="translated">stuff</target>
        </trans-unit>
        <trans-unit id="26ec8d00fb6b55466b3a115f1d559422a7fa7aac" translate="yes" xml:space="preserve">
          <source>style</source>
          <target state="translated">style</target>
        </trans-unit>
        <trans-unit id="5f6547f5a43b3c1ea0d4ef2b58b8d397690fc8eb" translate="yes" xml:space="preserve">
          <source>style not</source>
          <target state="translated">스타일이 아닌</target>
        </trans-unit>
        <trans-unit id="4e4b909a7c014ffa3745433641ad629adbd7314f" translate="yes" xml:space="preserve">
          <source>style shells should be aware that each of these file specifications may have subtle differences:</source>
          <target state="translated">스타일 셸은 이러한 각 파일 사양에 약간의 차이가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d85613a56c124e3a3ff8ce6fc95d10cdcb5001e" translate="yes" xml:space="preserve">
          <source>sub</source>
          <target state="translated">sub</target>
        </trans-unit>
        <trans-unit id="258e29fa2366e170bfad52a706cf0d9aeef2946b" translate="yes" xml:space="preserve">
          <source>sub NAME (PROTO) : ATTRS BLOCK</source>
          <target state="translated">하위 이름 (프로토) : 공격 차단</target>
        </trans-unit>
        <trans-unit id="7de160be2446e3a60b5145a242fc479ecd855f54" translate="yes" xml:space="preserve">
          <source>sub NAME (PROTO) BLOCK</source>
          <target state="translated">하위 이름 (프로토) 차단</target>
        </trans-unit>
        <trans-unit id="17ca004b29b99a8eefba7528721764cc8c00fe3c" translate="yes" xml:space="preserve">
          <source>sub NAME : ATTRS BLOCK</source>
          <target state="translated">하위 이름 : ATTRS BLOCK</target>
        </trans-unit>
        <trans-unit id="df052d5ba6d8a7b78532317d8816aac43a513f30" translate="yes" xml:space="preserve">
          <source>sub NAME BLOCK</source>
          <target state="translated">하위 이름 블록</target>
        </trans-unit>
        <trans-unit id="7a7c7d7dcc3ffdc428e4ce436230f0049d747f34" translate="yes" xml:space="preserve">
          <source>subbeg sublen saved_copy suboffset subcoffset</source>
          <target state="translated">subbeg sublen saved_copy 하위 오프셋 하위 오프셋</target>
        </trans-unit>
        <trans-unit id="5218231c03a7fc0030512f9e357d0222b012972d" translate="yes" xml:space="preserve">
          <source>subchar</source>
          <target state="translated">subchar</target>
        </trans-unit>
        <trans-unit id="1cf8c73561acb61f0940922c4e13aeb013e81b64" translate="yes" xml:space="preserve">
          <source>subdirectories and performs a build of each extension in turn.</source>
          <target state="translated">하위 디렉토리를 만들고 각 확장의 빌드를 차례로 수행합니다.</target>
        </trans-unit>
        <trans-unit id="2dfc1829a74a17416d23bbd2f98f59da5af5c27f" translate="yes" xml:space="preserve">
          <source>subdirectories for each module, like a standard CPAN distribution.</source>
          <target state="translated">표준 CPAN 배포와 같은 각 모듈의 하위 디렉토리</target>
        </trans-unit>
        <trans-unit id="c2d8ed2d8c0dbda3cc79ff51ec1fb8b37d8c8287" translate="yes" xml:space="preserve">
          <source>subdirectory can be used to help mail in a bug report.</source>
          <target state="translated">하위 디렉토리는 버그 보고서에서 메일을 발송하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48d43d070d4b22fd04b4e54d56a4c62626b13780" translate="yes" xml:space="preserve">
          <source>subdirectory of one of the directories in &lt;code&gt;@INC&lt;/code&gt; (where</source>
          <target state="translated">&lt;code&gt;@INC&lt;/code&gt; 에있는 디렉토리 중 하나의 하위 디렉토리 (여기서</target>
        </trans-unit>
        <trans-unit id="5e3b28ba75a4522feb49d7d2c15c806c7d8c4311" translate="yes" xml:space="preserve">
          <source>subdirectory of the Perl distribution.</source>
          <target state="translated">Perl 분배의 서브 디렉토리.</target>
        </trans-unit>
        <trans-unit id="81e77ccd1352246340045d9a85572778e0626f09" translate="yes" xml:space="preserve">
          <source>subdirectory of the build tree (as well as</source>
          <target state="translated">빌드 트리의 하위 디렉토리 (및</target>
        </trans-unit>
        <trans-unit id="35af8711767d4fe546b17463c98de5c438da956a" translate="yes" xml:space="preserve">
          <source>subdirectory under one of the directories in &lt;code&gt;@INC&lt;/code&gt; , where</source>
          <target state="translated">의 디렉토리 중 하나에 따라 하위 디렉토리 &lt;code&gt;@INC&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="69ac5c899be5939edfe7aeed22446cf364b8945a" translate="yes" xml:space="preserve">
          <source>subdirectory) to find how it should be done &quot;correctly&quot;.</source>
          <target state="translated">&quot;올바르게&quot;수행하는 방법을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="3870e1bf219c5068ace9baad9108071e9fa0e62d" translate="yes" xml:space="preserve">
          <source>subdirectory).</source>
          <target state="translated">subdirectory).</target>
        </trans-unit>
        <trans-unit id="ab0a47899af061959cec192ad2de3931d9bb5e3b" translate="yes" xml:space="preserve">
          <source>subdirectory, then it is searched. (That's how we manage to find</source>
          <target state="translated">하위 디렉토리가 검색되면 검색됩니다. (그것이 우리가 찾는 방법입니다</target>
        </trans-unit>
        <trans-unit id="335ce16b3fe40346cc3af2a4efce2ef04bc4ea55" translate="yes" xml:space="preserve">
          <source>subject</source>
          <target state="translated">subject</target>
        </trans-unit>
        <trans-unit id="7d474ca7bc06197f0a3630d40d84be8f9d45bffd" translate="yes" xml:space="preserve">
          <source>subject to the caveat about reallocated elements), so &lt;code&gt;@DB::args&lt;/code&gt; is actually a hybrid of the current state and initial state of &lt;code&gt;@_&lt;/code&gt; . Buyer beware.</source>
          <target state="translated">재 할당 된 요소에 대한주의에 따라), 그럼 &lt;code&gt;@DB::args&lt;/code&gt; 실제의 현재 상태와 초기 상태의 하이브리드 &lt;code&gt;@_&lt;/code&gt; . 구매자는 조심하십시오.</target>
        </trans-unit>
        <trans-unit id="ae8b08091c15ec5245e6edf0be64bcdef1cea42c" translate="yes" xml:space="preserve">
          <source>subject to the loose matching of encoding names. Also note that currently &lt;code&gt;:utf8&lt;/code&gt; is unsafe for input, because it accepts the data without validating that it is indeed valid UTF-8; you should instead use &lt;code&gt;:encoding(utf-8)&lt;/code&gt; (with or without a hyphen).</source>
          <target state="translated">인코딩 이름이 일치하지 않을 수 있습니다. 또한 현재 &lt;code&gt;:utf8&lt;/code&gt; 은 실제로 UTF-8인지 확인하지 않고 데이터를 받아들이 기 때문에 입력에 안전하지 않습니다. 대신 &lt;code&gt;:encoding(utf-8)&lt;/code&gt; 을 사용해야합니다 ( 하이픈 포함 또는 제외).</target>
        </trans-unit>
        <trans-unit id="a9dcc3bae592b9027755e382fb248039dc5a2464" translate="yes" xml:space="preserve">
          <source>subname</source>
          <target state="translated">subname</target>
        </trans-unit>
        <trans-unit id="0a6e2d7628cf0474c6c912a6bba3b83770aa6e9e" translate="yes" xml:space="preserve">
          <source>subroutine</source>
          <target state="translated">subroutine</target>
        </trans-unit>
        <trans-unit id="5fa26688e44b972471d55441246623cdcb9a64ac" translate="yes" xml:space="preserve">
          <source>subroutine declarations that can be loaded in later - usually because they may never be called.</source>
          <target state="translated">나중에로드 될 수있는 서브 루틴 선언-일반적으로 호출 될 수 없기 때문에.</target>
        </trans-unit>
        <trans-unit id="e9d331efbf733d0c5c35bcd40c2205975593c355" translate="yes" xml:space="preserve">
          <source>subroutine in a file called</source>
          <target state="translated">라는 파일의 서브 루틴</target>
        </trans-unit>
        <trans-unit id="ad03cbd9e1be45399cc464a20b88353a10eefc22" translate="yes" xml:space="preserve">
          <source>subroutine is referencing a &quot;my&quot; subroutine defined in an outer named subroutine.</source>
          <target state="translated">서브 루틴은 외부 명명 된 서브 루틴에 정의 된 &quot;my&quot;서브 루틴을 참조합니다.</target>
        </trans-unit>
        <trans-unit id="44cb6377f9c1380130016d7ecdddaca2e9c8c6ad" translate="yes" xml:space="preserve">
          <source>subroutine is referencing a lexical variable defined in an outer named subroutine.</source>
          <target state="translated">서브 루틴은 외부 명명 된 서브 루틴에 정의 된 어휘 변수를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="17faa80a0b42a473e0e0882cfa952a6f7696a21f" translate="yes" xml:space="preserve">
          <source>subroutine of the class.</source>
          <target state="translated">클래스의 서브 루틴.</target>
        </trans-unit>
        <trans-unit id="c78c2978b287abedc4733e47d45c9b3f394278cf" translate="yes" xml:space="preserve">
          <source>subs</source>
          <target state="translated">subs</target>
        </trans-unit>
        <trans-unit id="8dbaf7827ebf384a07dd9abc68263ad9e81fd84d" translate="yes" xml:space="preserve">
          <source>subs - Perl pragma to predeclare sub names</source>
          <target state="translated">subs-하위 이름을 사전 선언하는 Perl pragma</target>
        </trans-unit>
        <trans-unit id="df85a3fa4cab8cb59c20a9638f3c316f42a1cd49" translate="yes" xml:space="preserve">
          <source>subscript</source>
          <target state="translated">subscript</target>
        </trans-unit>
        <trans-unit id="6529d3df81c7d2e924bf1d009d4a8c9984cdc67f" translate="yes" xml:space="preserve">
          <source>substitute()</source>
          <target state="translated">substitute()</target>
        </trans-unit>
        <trans-unit id="ddd5fb4848e0a4f26098f2a25184c8d751fa402b" translate="yes" xml:space="preserve">
          <source>substitution character</source>
          <target state="translated">대체 문자</target>
        </trans-unit>
        <trans-unit id="e6fbe0ef6cab1da5a2948575b3a43ad97329e8bf" translate="yes" xml:space="preserve">
          <source>substitution).</source>
          <target state="translated">substitution).</target>
        </trans-unit>
        <trans-unit id="b79cd1299d045c6fdf4cc098af396543ad594122" translate="yes" xml:space="preserve">
          <source>substitution). The standard distribution will put nothing in this directory. After perl has been installed, users may install their own local architecture-dependent modules in this directory with MakeMaker</source>
          <target state="translated">치환). 표준 배포판은이 디렉토리에 아무것도 넣지 않습니다. perl을 설치 한 후, 사용자는 MakeMaker를 사용하여이 디렉토리에 자신의 로컬 아키텍처 종속 모듈을 설치할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="590d07b8733e44e115f2ce0a52ae1e6e7b3cac50" translate="yes" xml:space="preserve">
          <source>substitution). The standard distribution will put nothing in this directory. After perl has been installed, users may install their own local architecture-independent modules in this directory with MakeMaker</source>
          <target state="translated">치환). 표준 배포판은이 디렉토리에 아무것도 넣지 않습니다. perl을 설치 한 후, 사용자는 MakeMaker를 사용하여이 디렉토리에 자체 로컬 아키텍처 독립 모듈을 설치할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="fae1c7d34515216afb9e0c37ccfb61a0925a3258" translate="yes" xml:space="preserve">
          <source>substitution.</source>
          <target state="translated">substitution.</target>
        </trans-unit>
        <trans-unit id="48a600287dc56932d89eef8c9264fbf8710a38f7" translate="yes" xml:space="preserve">
          <source>substitution. The standard distribution will put nothing in this directory. After perl has been installed, users may install their own local executables in this directory with MakeMaker</source>
          <target state="translated">치환. 표준 배포판은이 디렉토리에 아무것도 넣지 않습니다. perl을 설치 한 후, 사용자는 MakeMaker를 사용하여이 디렉토리에 자신의 로컬 실행 파일을 설치할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="f682054e7fa0c949ce854defb25264133d6f6f0c" translate="yes" xml:space="preserve">
          <source>substitution. The standard distribution will put nothing in this directory. After perl has been installed, users may install their own local scripts in this directory with MakeMaker</source>
          <target state="translated">치환. 표준 배포판은이 디렉토리에 아무것도 넣지 않습니다. perl을 설치 한 후, 사용자는 MakeMaker를 사용하여이 디렉토리에 자신의 로컬 스크립트를 설치할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="72face471a629a5739e9760b45e749a5dab417a1" translate="yes" xml:space="preserve">
          <source>substr</source>
          <target state="translated">substr</target>
        </trans-unit>
        <trans-unit id="18ede6b1a478ffea5b6b13552e119cd6cd6fe856" translate="yes" xml:space="preserve">
          <source>substr EXPR,OFFSET</source>
          <target state="translated">하위 EXPR, 오프셋</target>
        </trans-unit>
        <trans-unit id="5355044a2beffcd33cbc1a5488febf4a20325c5e" translate="yes" xml:space="preserve">
          <source>substr EXPR,OFFSET,LENGTH</source>
          <target state="translated">substr EXPR, 오프셋, 길이</target>
        </trans-unit>
        <trans-unit id="1d3434b4d59555253b1410b196d7120ac727e861" translate="yes" xml:space="preserve">
          <source>substr EXPR,OFFSET,LENGTH,REPLACEMENT</source>
          <target state="translated">substr EXPR, 오프셋, 길이, 교체</target>
        </trans-unit>
        <trans-unit id="2253eac9c79aa036f9511dc664828785ee209400" translate="yes" xml:space="preserve">
          <source>substrs</source>
          <target state="translated">substrs</target>
        </trans-unit>
        <trans-unit id="2ef3a6fd919f65915228636166c56a2a3ad17fb5" translate="yes" xml:space="preserve">
          <source>subversions are not the same &quot;latest&quot; on all OS versions. For example, the latest xlC-5 on aix41 is 5.0.2.9, while on aix43, it is 5.0.2.7.</source>
          <target state="translated">서브 버전은 모든 OS 버전에서 &quot;최신&quot;버전이 아닙니다. 예를 들어, aix41의 최신 xlC-5는 5.0.2.9이고 aix43의 경우 5.0.2.7입니다.</target>
        </trans-unit>
        <trans-unit id="85193e237d55185fa99df9f3a73c538c8af45be0" translate="yes" xml:space="preserve">
          <source>successfully</source>
          <target state="translated">successfully</target>
        </trans-unit>
        <trans-unit id="1edd685781818eb0737fd5086f1593fef8487aab" translate="yes" xml:space="preserve">
          <source>such roots, returned as a list. Getting the number mathematicians call &lt;code&gt;j&lt;/code&gt; such that:</source>
          <target state="translated">이러한 루트는 목록으로 반환됩니다. 수학자에게 &lt;code&gt;j&lt;/code&gt; 를 호출 하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6c634901c45fff2c45e6f5bcc0216f13bc34a921" translate="yes" xml:space="preserve">
          <source>suggested for server programs and any program run on behalf of someone else, such as a CGI script. Once taint mode is on, it's on for the remainder of your script.</source>
          <target state="translated">서버 프로그램 및 CGI 스크립트와 같은 다른 사람을 대신하여 실행되는 모든 프로그램에 권장됩니다. 테 인트 모드가 켜지면 나머지 스크립트에서도 켜집니다.</target>
        </trans-unit>
        <trans-unit id="757cf865cda72f6e2abf0a08e2dab4aae64b5d11" translate="yes" xml:space="preserve">
          <source>suited to XSUBs which return multiple results. For that, either stick to the &lt;code&gt;(X)PUSHs&lt;/code&gt; macros shown above, or use the new &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m(X)PUSH[iunp]&lt;/a&gt;&lt;/code&gt; macros instead; see &lt;a href=&quot;#Putting-a-C-value-on-Perl-stack&quot;&gt;Putting a C value on Perl stack&lt;/a&gt;.</source>
          <target state="translated">여러 결과를 반환하는 XSUB에 적합합니다. 그 경우, 어느 행 스틱 &lt;code&gt;(X)PUSHs&lt;/code&gt; 의 매크로 위 또는 새로운 용도 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m(X)PUSH[iunp]&lt;/a&gt;&lt;/code&gt; 매크로 대신하는 단계; &lt;a href=&quot;#Putting-a-C-value-on-Perl-stack&quot;&gt;Perl 스택에 C 값 넣기를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e9dff3557ded7414ae530834de7011f1388d202a" translate="yes" xml:space="preserve">
          <source>sum</source>
          <target state="translated">sum</target>
        </trans-unit>
        <trans-unit id="7937d42266c04fd6255de322d23a060f48ed9405" translate="yes" xml:space="preserve">
          <source>sum0</source>
          <target state="translated">sum0</target>
        </trans-unit>
        <trans-unit id="88d8dc26e91d5c2c0f7f30a117afb59c4fee6579" translate="yes" xml:space="preserve">
          <source>sunds@asictest.sc.ti.com</source>
          <target state="translated">sunds@asictest.sc.ti.com</target>
        </trans-unit>
        <trans-unit id="710909e48995b01d80cf75d091da54473bf5cb4f" translate="yes" xml:space="preserve">
          <source>suntar</source>
          <target state="translated">suntar</target>
        </trans-unit>
        <trans-unit id="e50b96444800ecf6eec36732f694781a4da0a0c1" translate="yes" xml:space="preserve">
          <source>supplied in the binary distribution), you need to follow the syntax specified in &lt;a href=&quot;perlrun#Command-Switches&quot;&gt;Command Switches in perlrun&lt;/a&gt;.</source>
          <target state="translated">이진 배포판에 제공된 경우 &lt;a href=&quot;perlrun#Command-Switches&quot;&gt;perlrun의 명령 스위치에&lt;/a&gt; 지정된 구문을 따라야합니다 .</target>
        </trans-unit>
        <trans-unit id="5c1510fd6d0fcd8311c7e14dad06bd66bf0fa3bb" translate="yes" xml:space="preserve">
          <source>supplies a constant method name; it must be a shared COW string. Supported optypes: OP_METHOD_NAMED.</source>
          <target state="translated">상수 메서드 이름을 제공합니다. 공유 COW 문자열이어야합니다. 지원되는 optype : OP_METHOD_NAMED</target>
        </trans-unit>
        <trans-unit id="bb41dc1b2398adba08e8036114097d5a46866fe0" translate="yes" xml:space="preserve">
          <source>supplies a scalar context.</source>
          <target state="translated">스칼라 컨텍스트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="67b616efdb07b97c3465690c9eca99ce8963969d" translate="yes" xml:space="preserve">
          <source>supplies a scalar context. But the following declares only one variable:</source>
          <target state="translated">스칼라 컨텍스트를 제공합니다. 그러나 다음은 하나의 변수 만 선언합니다.</target>
        </trans-unit>
        <trans-unit id="933c89c5f6e634b4c9c2db8f2102e1f3da1f8414" translate="yes" xml:space="preserve">
          <source>supplies an op which evaluates method name; it is consumed by this function and become part of the constructed op tree. Supported optypes: OP_METHOD.</source>
          <target state="translated">메소드 이름을 평가하는 op를 제공합니다. 이 기능에 의해 소비되며 구성된 op 트리의 일부가됩니다. 지원되는 optype : OP_METHOD</target>
        </trans-unit>
        <trans-unit id="3b33802543ff3a4fc14e1b17a45b1fe7c0ef8182" translate="yes" xml:space="preserve">
          <source>supplies an optional op to be the direct child of the unary op; it is consumed by this function and become part of the constructed op tree.</source>
          <target state="translated">단항 op의 직접적인 자식이되도록 옵션 op를 제공합니다. 이 기능에 의해 소비되며 구성된 op 트리의 일부가됩니다.</target>
        </trans-unit>
        <trans-unit id="39c192e97bd3454aecd66cb7b0a5db494f3caacd" translate="yes" xml:space="preserve">
          <source>supplies the C-level pointer, which must have been allocated using &lt;code&gt;PerlMemShared_malloc&lt;/code&gt; ; the memory will be freed when the op is destroyed.</source>
          <target state="translated">&lt;code&gt;PerlMemShared_malloc&lt;/code&gt; 을 사용하여 할당 된 C 레벨 포인터를 제공합니다 . op가 파괴되면 메모리가 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="fbde2aabbb9071eec9811c89a64b364c289bb70b" translate="yes" xml:space="preserve">
          <source>supplies the block that will be executed if the test evaluates to true; they are consumed by this function and become part of the constructed op tree.</source>
          <target state="translated">테스트가 참으로 평가 될 때 실행될 블록을 제공합니다. 그것들은이 기능에 의해 소비되고 구성된 op 트리의 일부가됩니다.</target>
        </trans-unit>
        <trans-unit id="3b54f30d9a3501f63fdf1d5e1cbe966dbb72f290" translate="yes" xml:space="preserve">
          <source>supplies the body of the &lt;code&gt;given&lt;/code&gt; construct; they are consumed by this function and become part of the constructed op tree.</source>
          <target state="translated">&lt;code&gt;given&lt;/code&gt; 구조 의 본문을 제공합니다 . 그것들은이 기능에 의해 소비되고 구성된 op 트리의 일부가됩니다.</target>
        </trans-unit>
        <trans-unit id="386ba25d3f00fcac706478c7828c082d00ee683a" translate="yes" xml:space="preserve">
          <source>supplies the body of the loop; they are consumed by this function and become part of the constructed op tree.</source>
          <target state="translated">루프의 몸체를 공급하고; 그것들은이 기능에 의해 소비되고 구성된 op 트리의 일부가됩니다.</target>
        </trans-unit>
        <trans-unit id="fc80cb2b22ab2b5fec7d8694b53c099ccff06104" translate="yes" xml:space="preserve">
          <source>supplies the expression controlling loop iteration, and</source>
          <target state="translated">루프 반복을 제어하는 ​​표현식을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="61d5c314b7d12e8ae116f80dc72c292591d27e13" translate="yes" xml:space="preserve">
          <source>supplies the expression controlling the flow, and</source>
          <target state="translated">흐름을 제어하는 ​​표현을 제공하고</target>
        </trans-unit>
        <trans-unit id="c1e0d2b57ee87057e0548f8357c19a29361d989a" translate="yes" xml:space="preserve">
          <source>supplies the expression selecting between the two branches, and</source>
          <target state="translated">두 가지 사이에서 선택하는 표현식을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b4fbbc3cd37cb7bf4e5e35a91e68c31c0d6c8c32" translate="yes" xml:space="preserve">
          <source>supplies the expression that will be locally assigned to a lexical variable, and</source>
          <target state="translated">어휘 변수에 로컬로 할당 될 표현식을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5b82a63c35e5a1e34e24f2280fe8c5767ba58cc4" translate="yes" xml:space="preserve">
          <source>supplies the list of values to iterate over.</source>
          <target state="translated">반복 할 값 목록을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="53e35637bee3034f1a757673311c9b320e9692bb" translate="yes" xml:space="preserve">
          <source>supplies the loop's controlling expression.</source>
          <target state="translated">루프의 제어식을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="dccde9799aebcb5135581021583fc0ea950a3848" translate="yes" xml:space="preserve">
          <source>supplies the main body of the loop, and</source>
          <target state="translated">루프의 본체를 공급하고</target>
        </trans-unit>
        <trans-unit id="5c4d56d04eec48a3e496e124a63806cd67c55f9e" translate="yes" xml:space="preserve">
          <source>supplies the name that should be used by the check function to refer to the callee of the &lt;code&gt;entersub&lt;/code&gt; op if it needs to emit any diagnostics. It is permitted to apply the check function in non-standard situations, such as to a call to a different subroutine or to a method call.</source>
          <target state="translated">점검 기능을 사용하여 진단을 수행해야하는 경우 &lt;code&gt;entersub&lt;/code&gt; op 의 수신자를 참조하기 위해 점검 기능에서 사용해야하는 이름을 제공합니다 . 다른 서브 루틴에 대한 호출 또는 메소드 호출과 같은 비표준 상황에서 점검 기능을 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89932dca862c5f9e322348fa88b913ec514806ce" translate="yes" xml:space="preserve">
          <source>supplies the parameter determining the target of the op; it is consumed by this function and becomes part of the constructed op tree.</source>
          <target state="translated">연산의 목표를 결정하는 파라미터를 제공하고; 이 기능에 의해 소비되며 구성된 op 트리의 일부가됩니다.</target>
        </trans-unit>
        <trans-unit id="3cd2bc227f0480cf175bcd8e2f6e52bc74c4fb70" translate="yes" xml:space="preserve">
          <source>supplies the prototype of the function: its code, pad structure, and other attributes. The prototype is combined with a capture of outer lexicals to which the code refers, which are taken from the currently-executing instance of the immediately surrounding code.</source>
          <target state="translated">함수의 프로토 타입 (코드, 패드 구조 및 기타 속성)을 제공합니다. 프로토 타입은 코드가 참조하는 외부 어휘의 캡처와 결합되며, 이는 현재 실행중인 코드의 현재 실행중인 인스턴스에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="95a7e97ffdcc6e850084abeb7f7dd799d028d9c8" translate="yes" xml:space="preserve">
          <source>supplies the remainder of the source.</source>
          <target state="translated">나머지 소스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e86bbb1d3fa5335e2ddd651e4551e6b24badd33f" translate="yes" xml:space="preserve">
          <source>supplies the side (alternate) chain of ops; they are consumed by this function and become part of the constructed op tree.</source>
          <target state="translated">운영의 측면 (대체) 체인을 제공합니다. 그것들은이 기능에 의해 소비되고 구성된 op 트리의 일부가됩니다.</target>
        </trans-unit>
        <trans-unit id="dce53627503fb602891cc0400d01773b2d72a730" translate="yes" xml:space="preserve">
          <source>supplies the subroutine prototype to be applied to the call, or indicates that there is no prototype. It may be a normal scalar, in which case if it is defined then the string value will be used as a prototype, and if it is undefined then there is no prototype. Alternatively, for convenience, it may be a subroutine object (a &lt;code&gt;CV*&lt;/code&gt; that has been cast to &lt;code&gt;SV*&lt;/code&gt; ), of which the prototype will be used if it has one. The prototype (or lack thereof) supplied, in whichever form, does not need to match the actual callee referenced by the op tree.</source>
          <target state="translated">호출에 적용 할 서브 루틴 프로토 타입을 제공하거나 프로토 타입이 없음을 나타냅니다. 정규 스칼라 일 수 있습니다.이 경우 정의 된 경우 문자열 값이 프로토 타입으로 사용되며 정의되지 않은 경우 프로토 타입이 없습니다. 또는 편의상 서브 루틴 오브젝트 ( &lt;code&gt;SV*&lt;/code&gt; 로 캐스트 된 &lt;code&gt;CV*&lt;/code&gt; * ) 일 수도 있습니다.이 프로토 타입에는 프로토 타입이있는 경우 사용됩니다. 제공되는 프로토 타입 (또는 이의 부족)은 형식에 관계없이 op 트리에서 참조한 실제 수신자와 일치 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b59ae3b289a0c71fcc267eb12f8eefe2bfc7f4f0" translate="yes" xml:space="preserve">
          <source>supplies the subroutine prototype to be applied to the call. It may be a normal defined scalar, of which the string value will be used. Alternatively, for convenience, it may be a subroutine object (a &lt;code&gt;CV*&lt;/code&gt; that has been cast to &lt;code&gt;SV*&lt;/code&gt; ) which has a prototype. The prototype supplied, in whichever form, does not need to match the actual callee referenced by the op tree.</source>
          <target state="translated">호출에 적용 할 서브 루틴 프로토 타입을 제공합니다. 정규적으로 정의 된 스칼라 일 수 있으며이 중 문자열 값이 사용됩니다. 또는 편의상 프로토 타입 이있는 서브 루틴 오브젝트 ( &lt;code&gt;SV*&lt;/code&gt; 로 캐스트 된 &lt;code&gt;CV*&lt;/code&gt; * ) 일 수 있습니다. 제공되는 프로토 타입은 형식에 관계없이 op 트리에서 참조한 실제 수신자와 일치하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="261f10d115d93cba3ad204b2cdb1cfa33c1909b0" translate="yes" xml:space="preserve">
          <source>supplies the test expression, and</source>
          <target state="translated">테스트 표현식을 제공하고</target>
        </trans-unit>
        <trans-unit id="49ca365c7a662f2fb7b2b700c4565b2a8df4a3e6" translate="yes" xml:space="preserve">
          <source>supply the branches; they are consumed by this function and become part of the constructed op tree.</source>
          <target state="translated">가지를 공급하십시오. 그것들은이 기능에 의해 소비되고 구성된 op 트리의 일부가됩니다.</target>
        </trans-unit>
        <trans-unit id="276438cc69a199ed3efd23b2780b03ecd8482b20" translate="yes" xml:space="preserve">
          <source>supply the expressions controlling the endpoints of the range; they are consumed by this function and become part of the constructed op tree.</source>
          <target state="translated">범위의 끝점을 제어하는 ​​표현식을 제공하십시오. 그것들은이 기능에 의해 소비되고 구성된 op 트리의 일부가됩니다.</target>
        </trans-unit>
        <trans-unit id="feed11b722d6590561e7a3eae42ae547bbdeb0ac" translate="yes" xml:space="preserve">
          <source>supply the parameters of the assignment; they are consumed by this function and become part of the constructed op tree.</source>
          <target state="translated">과제의 매개 변수를 제공하십시오. 그것들은이 기능에 의해 소비되고 구성된 op 트리의 일부가됩니다.</target>
        </trans-unit>
        <trans-unit id="cf0db103b0f4ba44f838eaa30af4fbcda3dc6051" translate="yes" xml:space="preserve">
          <source>supply the parameters of the slice; they are consumed by this function and become part of the constructed op tree.</source>
          <target state="translated">슬라이스의 매개 변수를 제공하십시오. 그것들은이 기능에 의해 소비되고 구성된 op 트리의 일부가됩니다.</target>
        </trans-unit>
        <trans-unit id="43250c0b01630df5961aade1f437a2ddd9f1e6f7" translate="yes" xml:space="preserve">
          <source>supply up to two ops to be direct children of the list op; they are consumed by this function and become part of the constructed op tree.</source>
          <target state="translated">목록 op의 직계 자녀가되도록 최대 2 개의 op를 제공하십시오. 그것들은이 기능에 의해 소비되고 구성된 op 트리의 일부가됩니다.</target>
        </trans-unit>
        <trans-unit id="8494c6478c26491ae2fba064a9716c40d97db065" translate="yes" xml:space="preserve">
          <source>supply up to two ops to be the direct children of the binary op; they are consumed by this function and become part of the constructed op tree.</source>
          <target state="translated">이진 op의 직접적인 자식이되도록 최대 두 개의 op를 제공하십시오. 그것들은이 기능에 의해 소비되고 구성된 op 트리의 일부가됩니다.</target>
        </trans-unit>
        <trans-unit id="8c6e0711286fd2ac6c8125bae8cb887b7f4566b1" translate="yes" xml:space="preserve">
          <source>support yet.</source>
          <target state="translated">아직 지원합니다.</target>
        </trans-unit>
        <trans-unit id="f50c937ac0b3408d972fde532e7c1747c54283c4" translate="yes" xml:space="preserve">
          <source>supports Perl versions from 5.003 to 5.20 in threaded and non-threaded configurations.</source>
          <target state="translated">스레드 및 비스 레드 구성에서 5.003-5.20의 Perl 버전을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="57d058868c63f0b52e6ab62577cbd58701ac11d0" translate="yes" xml:space="preserve">
          <source>supports long doubles (12 bytes). However, several additional long double math functions are necessary to use them within Perl (</source>
          <target state="translated">long doubles (12 바이트)를 지원합니다. 그러나 Perl 내에서 사용하려면 몇 가지 추가 long double math 함수가 필요합니다 (</target>
        </trans-unit>
        <trans-unit id="9ac847bd073d24a33c5464b281e0db2bf06a41ef" translate="yes" xml:space="preserve">
          <source>supposed to be treated normally. Which characters are to be treated specially as metacharacters varies greatly from context to context. Your &lt;b&gt;shell&lt;/b&gt; will have certain metacharacters, double-quoted Perl &lt;b&gt;strings&lt;/b&gt; have other metacharacters, and &lt;b&gt;regular expression&lt;/b&gt; patterns have all the double-quote metacharacters plus some extra ones of their own.</source>
          <target state="translated">정상적으로 취급되어야합니다. 메타 문자로 특별히 취급 할 문자는 컨텍스트마다 크게 다릅니다. 귀하의 &lt;b&gt;쉘은&lt;/b&gt; 이중 인용 펄, 특정 메타있을 것이다 &lt;b&gt;문자열이&lt;/b&gt; 다른 메타 문자가 있고, &lt;b&gt;정규 표현식&lt;/b&gt; 패턴은 모든 따옴표 메타 플러스 자신의 몇 가지 여분의 사람이있다.</target>
        </trans-unit>
        <trans-unit id="3246144a36566f1fea3eeaf4af473c1eb1e160ad" translate="yes" xml:space="preserve">
          <source>sure no one will ever want to use your code on a non-ASCII platform. Starting in Perl v5.22, calls to it on ASCII platforms are optimized out, so there's no performance penalty at all in adding it. Or you can simply use the other constructs that don't require it.</source>
          <target state="translated">비 ASCII 플랫폼에서 코드를 사용하려는 사람은 아무도 없습니다. Perl v5.22부터는 ASCII 플랫폼에서 호출하는 것이 최적화되어 있으므로 추가시 성능 저하가 전혀 없습니다. 또는 필요하지 않은 다른 구성을 간단히 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60dad2979bb9769c615fca37ac2fd3f5b69bfd73" translate="yes" xml:space="preserve">
          <source>surrogate pair</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a92ecd20fec541443895aab5fc8266242f2bfa3" translate="yes" xml:space="preserve">
          <source>surrogate pairs</source>
          <target state="translated">대리 쌍</target>
        </trans-unit>
        <trans-unit id="b0134bd3893d0bc62d53f4846d15e6c877818c93" translate="yes" xml:space="preserve">
          <source>surrogates</source>
          <target state="translated">surrogates</target>
        </trans-unit>
        <trans-unit id="2aba9cbc844313bac08f8a99c304485574c65476" translate="yes" xml:space="preserve">
          <source>surrounded by</source>
          <target state="translated">에 둘러싸여</target>
        </trans-unit>
        <trans-unit id="0899ba1484ec8bdf0e19ff52c695e70ccdff2f28" translate="yes" xml:space="preserve">
          <source>suspects</source>
          <target state="translated">suspects</target>
        </trans-unit>
        <trans-unit id="b6f0c43f69fad2bd2df597f8c1f9289bf8ebf0a2" translate="yes" xml:space="preserve">
          <source>suspend</source>
          <target state="translated">suspend</target>
        </trans-unit>
        <trans-unit id="0a6190df9675de3c18b12fd3fc97648581780661" translate="yes" xml:space="preserve">
          <source>sv</source>
          <target state="translated">sv</target>
        </trans-unit>
        <trans-unit id="4167b98037f232f9707fdc8e12ffe855560656d2" translate="yes" xml:space="preserve">
          <source>sv.c</source>
          <target state="translated">sv.c</target>
        </trans-unit>
        <trans-unit id="351327455dde4d5627bbfd064b4140b27e6b13c6" translate="yes" xml:space="preserve">
          <source>sv.c.gcov</source>
          <target state="translated">sv.c.gcov</target>
        </trans-unit>
        <trans-unit id="ade3217578be1546a1b2a6827e4b13aa6d48d141" translate="yes" xml:space="preserve">
          <source>swap</source>
          <target state="translated">swap</target>
        </trans-unit>
        <trans-unit id="119ea8efe7cf5f360bf61b98304628fcf9561388" translate="yes" xml:space="preserve">
          <source>switch. If</source>
          <target state="translated">스위치. 만약</target>
        </trans-unit>
        <trans-unit id="4ddcd899e3a665a4c256ed0027578627191a6538" translate="yes" xml:space="preserve">
          <source>symbian/README</source>
          <target state="translated">symbian/README</target>
        </trans-unit>
        <trans-unit id="e6b784e0d86036408dc0e6e95997db41cc7044f1" translate="yes" xml:space="preserve">
          <source>symbian/TODO</source>
          <target state="translated">symbian/TODO</target>
        </trans-unit>
        <trans-unit id="d4f839b54fa310d171f4bea87426a6ad792eed38" translate="yes" xml:space="preserve">
          <source>symbian/config.sh</source>
          <target state="translated">symbian/config.sh</target>
        </trans-unit>
        <trans-unit id="bb31235f86ec74784e4ba03ef93781603ddc7690" translate="yes" xml:space="preserve">
          <source>symbian\config.pl</source>
          <target state="translated">symbian\config.pl</target>
        </trans-unit>
        <trans-unit id="06f9b0facd2dfc678efcc6e3cc423ec6633a5623" translate="yes" xml:space="preserve">
          <source>symbolic</source>
          <target state="translated">symbolic</target>
        </trans-unit>
        <trans-unit id="8217d9e6e8b6c267382c8ea8fb35416350f71980" translate="yes" xml:space="preserve">
          <source>symbolic reference</source>
          <target state="translated">상징적 참조</target>
        </trans-unit>
        <trans-unit id="3b7aed21a4dfc14581cb1ebfa269455b383b8369" translate="yes" xml:space="preserve">
          <source>symbolic.pm</source>
          <target state="translated">symbolic.pm</target>
        </trans-unit>
        <trans-unit id="b282128e9f472cade38f541670d05c997f5edf7a" translate="yes" xml:space="preserve">
          <source>symlink</source>
          <target state="translated">symlink</target>
        </trans-unit>
        <trans-unit id="591e699a63659714471ab440c4a1a73661f5761d" translate="yes" xml:space="preserve">
          <source>symlink OLDFILE,NEWFILE</source>
          <target state="translated">symlink OLDFILE, NEWFILE</target>
        </trans-unit>
        <trans-unit id="fda22ac0b555bc0ceca6a0a60cd133986cffbc5f" translate="yes" xml:space="preserve">
          <source>symmetric difference</source>
          <target state="translated">대칭 차이</target>
        </trans-unit>
        <trans-unit id="1d260b870cb7b1e776ab4d6ddb6d6740ec7c8b51" translate="yes" xml:space="preserve">
          <source>syntactically</source>
          <target state="translated">syntactically</target>
        </trans-unit>
        <trans-unit id="c9a99c9c1c389927fb79a3bd444e10e4f3f91677" translate="yes" xml:space="preserve">
          <source>syntax &lt;code&gt;&amp;lt;$var&amp;gt;&lt;/code&gt; and</source>
          <target state="translated">구문 &lt;code&gt;&amp;lt;$var&amp;gt;&lt;/code&gt; 및</target>
        </trans-unit>
        <trans-unit id="3540e626f064a80d72c15fb4736d5189f7091bde" translate="yes" xml:space="preserve">
          <source>syntax &lt;code&gt;&amp;lt;${var}&amp;gt;&lt;/code&gt; .</source>
          <target state="translated">구문 &lt;code&gt;&amp;lt;${var}&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c4f85fcddbb9d4aafff48a6f33e59be855c88b3" translate="yes" xml:space="preserve">
          <source>syntax error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35dddcaea633fd2c905d552fbf07e741cc4ac346" translate="yes" xml:space="preserve">
          <source>sys/ioctl.ph</source>
          <target state="translated">sys/ioctl.ph</target>
        </trans-unit>
        <trans-unit id="fa1d4b596386e46fdb9e2f76a44d26eb373c2ad4" translate="yes" xml:space="preserve">
          <source>sys/mount.h</source>
          <target state="translated">sys/mount.h</target>
        </trans-unit>
        <trans-unit id="f6e092e7415b3e9bb613389f2837e1e04090ed3c" translate="yes" xml:space="preserve">
          <source>sys/param.h</source>
          <target state="translated">sys/param.h</target>
        </trans-unit>
        <trans-unit id="7f404f2c9c6977d56171c76a5aaa4f21c1ed0191" translate="yes" xml:space="preserve">
          <source>sys/shm.h</source>
          <target state="translated">sys/shm.h</target>
        </trans-unit>
        <trans-unit id="4d146410ad4f7b43d4d468be07418dbf46020585" translate="yes" xml:space="preserve">
          <source>sys/statfs.h</source>
          <target state="translated">sys/statfs.h</target>
        </trans-unit>
        <trans-unit id="783ee8b47e33ccf886c07946f0a74af226d1a8b9" translate="yes" xml:space="preserve">
          <source>sys/un.h</source>
          <target state="translated">sys/un.h</target>
        </trans-unit>
        <trans-unit id="66290592fca9d25372168ea6386e64cac4dc40e3" translate="yes" xml:space="preserve">
          <source>sys:\Perl</source>
          <target state="translated">sys:\Perl</target>
        </trans-unit>
        <trans-unit id="341b0b4c78cf0c5e3aa256cfd9905f0ea8a551eb" translate="yes" xml:space="preserve">
          <source>sys:\perl\system</source>
          <target state="translated">sys:\perl\system</target>
        </trans-unit>
        <trans-unit id="4a23474c62a33cb53f128847252503120f2da803" translate="yes" xml:space="preserve">
          <source>sys:\system</source>
          <target state="translated">sys:\system</target>
        </trans-unit>
        <trans-unit id="d7cbea74df93b67d6611b9ce87cf4f9a6b0c258f" translate="yes" xml:space="preserve">
          <source>syscall</source>
          <target state="translated">syscall</target>
        </trans-unit>
        <trans-unit id="2d721dd599bf9f7efe4139c8e55b4488c7c8731b" translate="yes" xml:space="preserve">
          <source>syscall NUMBER, LIST</source>
          <target state="translated">syscall NUMBER, LIST</target>
        </trans-unit>
        <trans-unit id="4545606e0a81be230767d641a85d5093e11d9aee" translate="yes" xml:space="preserve">
          <source>syscall.h</source>
          <target state="translated">syscall.h</target>
        </trans-unit>
        <trans-unit id="0009f423fd8c556aae96a7fb362d2f8b60f12691" translate="yes" xml:space="preserve">
          <source>sysconf() function. If this is a possibility, each directory in the path is checked in turn for safeness, recursively walking back to the root directory.</source>
          <target state="translated">sysconf () 함수 이것이 가능한 경우 경로의 각 디렉토리가 차례로 안전성을 검사하여 루트 디렉토리로 재귀 적으로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="dc3ab98bfbf4b4509cbf370fd445674ef17da0cd" translate="yes" xml:space="preserve">
          <source>syslog(3)</source>
          <target state="translated">syslog(3)</target>
        </trans-unit>
        <trans-unit id="2705412b5383de38b034f8c0d6ce583dae807d9c" translate="yes" xml:space="preserve">
          <source>syslog.ph</source>
          <target state="translated">syslog.ph</target>
        </trans-unit>
        <trans-unit id="4be85e443ee56ff14d2c333ccc70eda9e7ba9ed1" translate="yes" xml:space="preserve">
          <source>sysman.U</source>
          <target state="translated">sysman.U</target>
        </trans-unit>
        <trans-unit id="a12380cce4f1fed0e70dde8b07f53bd9459b698f" translate="yes" xml:space="preserve">
          <source>sysopen</source>
          <target state="translated">sysopen</target>
        </trans-unit>
        <trans-unit id="4787eb13ee480169b313b635bddada9ad931c8e5" translate="yes" xml:space="preserve">
          <source>sysopen FILEHANDLE,FILENAME,MODE</source>
          <target state="translated">sysopen FILEHANDLE, FILENAME, MODE</target>
        </trans-unit>
        <trans-unit id="4c1420b8cd8bb3efd6fb3fb61369d7345e3fc78e" translate="yes" xml:space="preserve">
          <source>sysopen FILEHANDLE,FILENAME,MODE,PERMS</source>
          <target state="translated">sysopen FILEHANDLE, FILENAME, MODE, PERMS</target>
        </trans-unit>
        <trans-unit id="4fbd3fedd6187ac2cd8e58ce04d22e34ef544a8c" translate="yes" xml:space="preserve">
          <source>sysopen() operates (unsurprisingly) at a lower level in the stack than open(). For example in Unix or Unix-like systems sysopen() operates directly at the level of file descriptors: in the terms of PerlIO layers, it uses only the &quot;unix&quot; layer, which is a rather thin wrapper on top of the Unix file descriptors.</source>
          <target state="translated">sysopen ()은 스택에서 open ()보다 낮은 수준에서 (의외로) 작동합니다. 예를 들어, 유닉스 나 유닉스 계열 시스템에서 sysopen ()은 파일 디스크립터 수준에서 직접 작동합니다. PerlIO 레이어 측면에서 유닉스 파일 디스크립터 위에있는 얇은 랩퍼 인 &quot;유닉스&quot;레이어 만 사용합니다. .</target>
        </trans-unit>
        <trans-unit id="07ada4381247db645f430708361ebf3855c33687" translate="yes" xml:space="preserve">
          <source>sysread</source>
          <target state="translated">sysread</target>
        </trans-unit>
        <trans-unit id="e65d3193feed181d232efe689dce3350eb1f3c5c" translate="yes" xml:space="preserve">
          <source>sysread FILEHANDLE,SCALAR,LENGTH</source>
          <target state="translated">sysread 파일 핸들, 스칼라, 길이</target>
        </trans-unit>
        <trans-unit id="75c76a4f6be568624e87183a3151c781d03826f9" translate="yes" xml:space="preserve">
          <source>sysread FILEHANDLE,SCALAR,LENGTH,OFFSET</source>
          <target state="translated">sysread 파일 핸들, 스칼라, 길이, 오프셋</target>
        </trans-unit>
        <trans-unit id="304681ee42f0eba7ccba17a001425e45b09c7497" translate="yes" xml:space="preserve">
          <source>sysseek</source>
          <target state="translated">sysseek</target>
        </trans-unit>
        <trans-unit id="83c1d37a632e2e38fc094f4858eb94e603659ce9" translate="yes" xml:space="preserve">
          <source>sysseek FILEHANDLE,POSITION,WHENCE</source>
          <target state="translated">sysseek FILEHANDLE, 위치, 화이트</target>
        </trans-unit>
        <trans-unit id="d7668815a85c1035fd99f4ecbb6d385417fc2e73" translate="yes" xml:space="preserve">
          <source>sysseek() bypasses normal buffered IO, so mixing it with reads other than &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; (for example &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; or read()) &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; may cause confusion.</source>
          <target state="translated">sysseek ()는 일반 버퍼링 된 IO를 무시하므로 &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; 이외의 다른 읽기 ( 예 : &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 또는 read ()) &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 와 혼용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45611416cc3031d66c8afdfb344421333c1cc8c2" translate="yes" xml:space="preserve">
          <source>sysseek() bypasses normal buffered IO, so mixing it with reads other than &lt;code&gt;&lt;a href=&quot;sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; (for example &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; or read()) &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; may cause confusion.</source>
          <target state="translated">sysseek ()는 일반 버퍼링 된 IO를 무시하므로 &lt;code&gt;&lt;a href=&quot;sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; 이외의 다른 읽기 ( 예 : &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 또는 read ()) &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 와 혼용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="317f1e761f2faa8da781a4762b9dcc2c5cad209a" translate="yes" xml:space="preserve">
          <source>system</source>
          <target state="translated">system</target>
        </trans-unit>
        <trans-unit id="dceea694ca2d34f416959e52db08f905f267df2f" translate="yes" xml:space="preserve">
          <source>system LIST</source>
          <target state="translated">시스템리스트</target>
        </trans-unit>
        <trans-unit id="568ba46c449d31b288ecb379c56e0ad3eb6c2b4d" translate="yes" xml:space="preserve">
          <source>system PROGRAM LIST</source>
          <target state="translated">시스템 프로그램 목록</target>
        </trans-unit>
        <trans-unit id="854f3d75247050945cc3d0feda0bc17cd37d0ffe" translate="yes" xml:space="preserve">
          <source>system call),</source>
          <target state="translated">시스템 호출),</target>
        </trans-unit>
        <trans-unit id="f6bcb19c9c9bf6848b258d824185d881f9f2bf92" translate="yes" xml:space="preserve">
          <source>system malloc().</source>
          <target state="translated">시스템 malloc ().</target>
        </trans-unit>
        <trans-unit id="442b66e780a7ea69ca491b81816b380896f9ce12" translate="yes" xml:space="preserve">
          <source>system time</source>
          <target state="translated">시스템 시간</target>
        </trans-unit>
        <trans-unit id="c32e251015d1274fbaa35f79158261c5aae1ceae" translate="yes" xml:space="preserve">
          <source>system()</source>
          <target state="translated">system()</target>
        </trans-unit>
        <trans-unit id="d9a846494d49f26dc29c6fac98d2f2d5a0c06b34" translate="yes" xml:space="preserve">
          <source>system, any clocks and timers will be imprecise, especially so if you are working in a pre-emptive multiuser system. Understand the difference between</source>
          <target state="translated">예를 들어 선점 형 다중 사용자 시스템에서 작업하는 경우 모든 시계와 타이머가 정확하지 않습니다. 차이점을 이해하십시오</target>
        </trans-unit>
        <trans-unit id="e25c2a11e92a207ae0e29b09f80156162671bdf1" translate="yes" xml:space="preserve">
          <source>system/exec</source>
          <target state="translated">system/exec</target>
        </trans-unit>
        <trans-unit id="4d9523f4dcf8348b3ea80ad6dbace327ea62be3d" translate="yes" xml:space="preserve">
          <source>syswrite</source>
          <target state="translated">syswrite</target>
        </trans-unit>
        <trans-unit id="7bb5b35c4b0c54818135f2c7049ab72e94211174" translate="yes" xml:space="preserve">
          <source>syswrite FILEHANDLE,SCALAR</source>
          <target state="translated">syswrite FILEHANDLE, 스칼라</target>
        </trans-unit>
        <trans-unit id="403d98d06f5d49aadde890226fda0bb63c8906d7" translate="yes" xml:space="preserve">
          <source>syswrite FILEHANDLE,SCALAR,LENGTH</source>
          <target state="translated">syswrite FILEHANDLE, 스칼라, 길이</target>
        </trans-unit>
        <trans-unit id="b4439105bf641cc33e0e27376f6c1c00352f8653" translate="yes" xml:space="preserve">
          <source>syswrite FILEHANDLE,SCALAR,LENGTH,OFFSET</source>
          <target state="translated">syswrite 파일 핸들, 스칼라, 길이, 오프셋</target>
        </trans-unit>
        <trans-unit id="8efd86fb78a56a5145ed7739dcb00c78581c5375" translate="yes" xml:space="preserve">
          <source>t</source>
          <target state="translated">t</target>
        </trans-unit>
        <trans-unit id="5803be03c07dec623c10871bddf83fa1a67341be" translate="yes" xml:space="preserve">
          <source>t/</source>
          <target state="translated">t/</target>
        </trans-unit>
        <trans-unit id="ee32657b3853ea5d4d1670ab32e6838c58649a19" translate="yes" xml:space="preserve">
          <source>t/00compile.t</source>
          <target state="translated">t/00compile.t</target>
        </trans-unit>
        <trans-unit id="016c131011f5ed722060f71107c0a10476a50817" translate="yes" xml:space="preserve">
          <source>t/TEST</source>
          <target state="translated">t/TEST</target>
        </trans-unit>
        <trans-unit id="e3e6c5553377ad0a37c1ffc0f6a17cc0e4b6f1ac" translate="yes" xml:space="preserve">
          <source>t/bar.t</source>
          <target state="translated">t/bar.t</target>
        </trans-unit>
        <trans-unit id="f76303257eb4699503af2247b4b761a701c7d5fe" translate="yes" xml:space="preserve">
          <source>t/base</source>
          <target state="translated">t/base</target>
        </trans-unit>
        <trans-unit id="424df0294680ae7d16ff6cd26441e5860a8ed592" translate="yes" xml:space="preserve">
          <source>t/baz.t</source>
          <target state="translated">t/baz.t</target>
        </trans-unit>
        <trans-unit id="4b9d7747567ab3d4648e2b09ef21537b8c0742e9" translate="yes" xml:space="preserve">
          <source>t/bigmem/</source>
          <target state="translated">t/bigmem/</target>
        </trans-unit>
        <trans-unit id="e631ee7a25fffad8c78393ce1420fa1fece1eb4c" translate="yes" xml:space="preserve">
          <source>t/charset_tools.pl</source>
          <target state="translated">t/charset_tools.pl</target>
        </trans-unit>
        <trans-unit id="f6d93b7b01a8e1b5601426c2b2c860d6a688dcc3" translate="yes" xml:space="preserve">
          <source>t/cmd</source>
          <target state="translated">t/cmd</target>
        </trans-unit>
        <trans-unit id="4e4e7621a9ecf0aa721716a241ff936621e1745a" translate="yes" xml:space="preserve">
          <source>t/comp</source>
          <target state="translated">t/comp</target>
        </trans-unit>
        <trans-unit id="da64a82ccf4f15dc335eec9d8a5562ddfc8d56c1" translate="yes" xml:space="preserve">
          <source>t/foo.t</source>
          <target state="translated">t/foo.t</target>
        </trans-unit>
        <trans-unit id="bd919ec3c418f4ac67b6e4ba5e73c676e39055d5" translate="yes" xml:space="preserve">
          <source>t/harness</source>
          <target state="translated">t/harness</target>
        </trans-unit>
        <trans-unit id="e1ec93346a387203f7effcdd1140428bd2ede5fa" translate="yes" xml:space="preserve">
          <source>t/io</source>
          <target state="translated">t/io</target>
        </trans-unit>
        <trans-unit id="35a315d28b2dc3fe449b8e299312a0950ea4fc61" translate="yes" xml:space="preserve">
          <source>t/io/fs.t</source>
          <target state="translated">t/io/fs.t</target>
        </trans-unit>
        <trans-unit id="d1c6620bff42ece36d97d026673254c65b674807" translate="yes" xml:space="preserve">
          <source>t/io/tell.t: Subtest 27 is failing. We are still investigating.</source>
          <target state="translated">t / io / tell.t : 하위 테스트 27이 실패했습니다. 우리는 여전히 조사하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="21c2765f64e902f1eba2b7fa3bada80c6d3df699" translate="yes" xml:space="preserve">
          <source>t/lib/posix.t</source>
          <target state="translated">t/lib/posix.t</target>
        </trans-unit>
        <trans-unit id="fbb78755c57da1a3fb44a764f63e3b8c4f7adfdb" translate="yes" xml:space="preserve">
          <source>t/loc_tools.pl</source>
          <target state="translated">t/loc_tools.pl</target>
        </trans-unit>
        <trans-unit id="7d6e69712da3d67d7d06bcdbd1e0b862cb8e710c" translate="yes" xml:space="preserve">
          <source>t/mro</source>
          <target state="translated">t/mro</target>
        </trans-unit>
        <trans-unit id="68a9f264e91ff2cda2216e7130ef4807da5039af" translate="yes" xml:space="preserve">
          <source>t/mytest.t</source>
          <target state="translated">t/mytest.t</target>
        </trans-unit>
        <trans-unit id="54b4a1de3b24f1785e9c8144185b3a3644bedb60" translate="yes" xml:space="preserve">
          <source>t/op</source>
          <target state="translated">t/op</target>
        </trans-unit>
        <trans-unit id="c6ef3c15071f030077437030bb790555f4926475" translate="yes" xml:space="preserve">
          <source>t/op/</source>
          <target state="translated">t/op/</target>
        </trans-unit>
        <trans-unit id="34af4c076cb471c9be9f5451dadfb98625e1214e" translate="yes" xml:space="preserve">
          <source>t/op/pack.t</source>
          <target state="translated">t/op/pack.t</target>
        </trans-unit>
        <trans-unit id="3875953b6416be4c969e133db8a303297a260ab9" translate="yes" xml:space="preserve">
          <source>t/op/pack.t has a sensible ok() function, but if it didn't we could use the one from t/test.pl.</source>
          <target state="translated">t / op / pack.t는 합리적인 ok () 함수를 가지고 있지만, 그렇지 않은 경우 t / test.pl에서 함수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c961927b2b9a6c7008e1916e3412ec3ae14c421c" translate="yes" xml:space="preserve">
          <source>t/op/pack.t~</source>
          <target state="translated">t/op/pack.t~</target>
        </trans-unit>
        <trans-unit id="20d04fa0a6c2c3fcf28a0352b9c3a34d69852d97" translate="yes" xml:space="preserve">
          <source>t/op/ref.t</source>
          <target state="translated">t/op/ref.t</target>
        </trans-unit>
        <trans-unit id="9ae690daefb740733f2a0bbdc6545df6de84b3bd" translate="yes" xml:space="preserve">
          <source>t/opbasic</source>
          <target state="translated">t/opbasic</target>
        </trans-unit>
        <trans-unit id="bf79631a18f7d933909b144eca32ca6dd9629744" translate="yes" xml:space="preserve">
          <source>t/perf/benchmarks</source>
          <target state="translated">t/perf/benchmarks</target>
        </trans-unit>
        <trans-unit id="8358e4410308554c4c4f2875a578685a4eaba637" translate="yes" xml:space="preserve">
          <source>t/perf/opcount.t</source>
          <target state="translated">t/perf/opcount.t</target>
        </trans-unit>
        <trans-unit id="0c7ca3dfae849cb7a4c6b36f2a65675c57dd647a" translate="yes" xml:space="preserve">
          <source>t/perf/speed.t</source>
          <target state="translated">t/perf/speed.t</target>
        </trans-unit>
        <trans-unit id="ba669aaaf039bcdd6bcfd75a726dc3118b0b20e2" translate="yes" xml:space="preserve">
          <source>t/perl.supp</source>
          <target state="translated">t/perl.supp</target>
        </trans-unit>
        <trans-unit id="3cf3a91d371ba2dbcee0ae2089496fadf026d232" translate="yes" xml:space="preserve">
          <source>t/porting/libperl.t</source>
          <target state="translated">t/porting/libperl.t</target>
        </trans-unit>
        <trans-unit id="4a89aad45864df97cfa9234b17eaf171075fbb25" translate="yes" xml:space="preserve">
          <source>t/re/speed.t</source>
          <target state="translated">t/re/speed.t</target>
        </trans-unit>
        <trans-unit id="f5fe7c8dfa39f3e5da7e23a84b14a12426c231eb" translate="yes" xml:space="preserve">
          <source>t/run</source>
          <target state="translated">t/run</target>
        </trans-unit>
        <trans-unit id="10190fe7b344dc9baf90d3ff5fefefac424d6eca" translate="yes" xml:space="preserve">
          <source>t/run/fresh_perl</source>
          <target state="translated">t/run/fresh_perl</target>
        </trans-unit>
        <trans-unit id="4d68fac0225a60482ebbf10a58fad6248bff10be" translate="yes" xml:space="preserve">
          <source>t/test.pl</source>
          <target state="translated">t/test.pl</target>
        </trans-unit>
        <trans-unit id="f8f9a8a8728847ce5ef1c0b6547c7fa8e7dd509a" translate="yes" xml:space="preserve">
          <source>t/test.t</source>
          <target state="translated">t/test.t</target>
        </trans-unit>
        <trans-unit id="818ef307ac2faa364a61ab49c2cb0f145f80e207" translate="yes" xml:space="preserve">
          <source>t/testrules.yml</source>
          <target state="translated">t/testrules.yml</target>
        </trans-unit>
        <trans-unit id="7f860db1a8b044397bcca547962b9b25178ffd30" translate="yes" xml:space="preserve">
          <source>t/uni</source>
          <target state="translated">t/uni</target>
        </trans-unit>
        <trans-unit id="9eacb4862221e4385a9f07398dd633ab1ad24621" translate="yes" xml:space="preserve">
          <source>taint checks</source>
          <target state="translated">오염 검사</target>
        </trans-unit>
        <trans-unit id="380c7001d26889309c6bebb309431e810ba04153" translate="yes" xml:space="preserve">
          <source>taint mode</source>
          <target state="translated">오염 모드</target>
        </trans-unit>
        <trans-unit id="de5ba98bdc71f7370934c9ddb55b4313c58a672b" translate="yes" xml:space="preserve">
          <source>tainted</source>
          <target state="translated">tainted</target>
        </trans-unit>
        <trans-unit id="64415fe9f8fd796c4e298baff1c7f87ff20ab108" translate="yes" xml:space="preserve">
          <source>taints</source>
          <target state="translated">taints</target>
        </trans-unit>
        <trans-unit id="53bd7d992ed7edf9a271056d254d8f7797462f27" translate="yes" xml:space="preserve">
          <source>take</source>
          <target state="translated">take</target>
        </trans-unit>
        <trans-unit id="ead9c1de852b36ad6a43cc16bf6c5fadd340e3e1" translate="yes" xml:space="preserve">
          <source>take a pointer to one of these structures as their first argument, with the name &lt;code&gt;pRExC_state&lt;/code&gt; . This structure is used to store the compilation state and contains many fields. Likewise there are many macros which operate on this variable: anything that looks like &lt;code&gt;RExC_xxxx&lt;/code&gt; is a macro that operates on this pointer/structure.</source>
          <target state="translated">이름이 &lt;code&gt;pRExC_state&lt;/code&gt; 인 첫 번째 인수로 이러한 구조 중 하나에 대한 포인터를 가져 옵니다 . 이 구조는 컴파일 상태를 저장하는 데 사용되며 많은 필드를 포함합니다. &lt;code&gt;RExC_xxxx&lt;/code&gt; 변수에서 작동하는 매크로가 많이 있습니다. RExC_xxxx 처럼 보이는 것은 이 포인터 / 구조에서 작동하는 매크로입니다.</target>
        </trans-unit>
        <trans-unit id="14c150c786d9c122dcce02469ba16c110f538736" translate="yes" xml:space="preserve">
          <source>take away read permission, because the source code has to be readable in order to be compiled and interpreted. (That doesn't mean that a CGI script's source is readable by people on the web, though--only by people with access to the filesystem.) So you have to leave the permissions at the socially friendly 0755 level.</source>
          <target state="translated">컴파일 및 해석하려면 소스 코드를 읽을 수 있어야하므로 읽기 권한을 빼십시오. (그렇다고해서 CGI 스크립트의 소스를 웹 사용자는 읽을 수 있지만 파일 시스템에 액세스 할 수있는 사용자 만 읽을 수 있음을 의미하지는 않습니다.) 따라서 사회적으로 친숙한 0755 수준으로 권한을 남겨 두어야합니다.</target>
        </trans-unit>
        <trans-unit id="7086187cc2f49ad3d0fc7256140ce3bcc78fcfc3" translate="yes" xml:space="preserve">
          <source>take away read permission, because the source code has to be readable in order to be compiled and interpreted. (That doesn't mean that a CGI script's source is readable by people on the web, though.) So you have to leave the permissions at the socially friendly 0755 level. This lets people on your local system only see your source.</source>
          <target state="translated">컴파일 및 해석하려면 소스 코드를 읽을 수 있어야하므로 읽기 권한을 빼십시오. (그렇다고해서 웹 사용자가 CGI 스크립트의 소스를 읽을 수 있다는 의미는 아닙니다.) 따라서 권한을 사회적으로 친숙한 0755 수준으로 두어야합니다. 이를 통해 로컬 시스템의 사용자는 소스 만 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9612d40a7a23745c0940dd8566c84227f846409b" translate="yes" xml:space="preserve">
          <source>takes a pair of address and length of data at this address, so it is better to rewrite this function as</source>
          <target state="translated">이 주소에서 한 쌍의 주소와 데이터 길이를 사용하므로이 함수를 다음과 같이 다시 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fa377875a902e75fd09f473f871e8b460c9ae29b" translate="yes" xml:space="preserve">
          <source>takes two arguments which are input filehandle and output filehandle. Switches to use these filehandles.</source>
          <target state="translated">입력 파일 핸들과 출력 파일 핸들 인 두 개의 인수를 사용합니다. 이 파일 핸들을 사용하도록 전환합니다.</target>
        </trans-unit>
        <trans-unit id="6ecf9b149669120d3138a2c22ea10d67174a079e" translate="yes" xml:space="preserve">
          <source>takes two parameters. The first, &lt;code&gt;sv&lt;/code&gt; , is an SV*. This allows you to specify the Perl subroutine to be called either as a C string (which has first been converted to an SV) or a reference to a subroutine. The section,</source>
          <target state="translated">두 개의 매개 변수를 사용합니다. 첫 번째 인 &lt;code&gt;sv&lt;/code&gt; 는 SV *입니다. 이를 통해 Perl 서브 루틴을 C 문자열 (SV로 변환 된) 또는 서브 루틴에 대한 참조로 호출하도록 지정할 수 있습니다. 그 영역,</target>
        </trans-unit>
        <trans-unit id="d0b833e106b7a26b37dcbc250ed5c537f0eba48c" translate="yes" xml:space="preserve">
          <source>takes two positional parameters, which must be filled at runtime by two arguments. By default the parameters are mandatory, and it is not permitted to pass more arguments than expected. So the above is equivalent to</source>
          <target state="translated">런타임에 두 개의 인수로 채워야하는 두 개의 위치 매개 변수를 사용합니다. 기본적으로 매개 변수는 필수이며 예상보다 많은 인수를 전달할 수 없습니다. 위의 내용은</target>
        </trans-unit>
        <trans-unit id="25f30d353d672994bc46f110e821d857b2525e65" translate="yes" xml:space="preserve">
          <source>tap</source>
          <target state="translated">tap</target>
        </trans-unit>
        <trans-unit id="680254bad1d7ca0d65ec46aaa315d363abf6a50a" translate="yes" xml:space="preserve">
          <source>tar</source>
          <target state="translated">tar</target>
        </trans-unit>
        <trans-unit id="d43c1ce91546a4ad0a5c0d689190bc2b6abb2c24" translate="yes" xml:space="preserve">
          <source>tar xvzpf perl-$VERSION-bin.tgz</source>
          <target state="translated">타르 xvzpf perl- $ VERSION-bin.tgz</target>
        </trans-unit>
        <trans-unit id="4d04586fe3fd2dca811b9680136d0aeb1ba69218" translate="yes" xml:space="preserve">
          <source>tar(1), &lt;a href=&quot;archive/tar&quot;&gt;Archive::Tar&lt;/a&gt;.</source>
          <target state="translated">tar (1), &lt;a href=&quot;archive/tar&quot;&gt;Archive :: Tar&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0e8a3ad980ec179856012b7eecf4327e99cd44cd" translate="yes" xml:space="preserve">
          <source>target</source>
          <target state="translated">target</target>
        </trans-unit>
        <trans-unit id="80607933b393d425630df8feb65c2d3d2122453d" translate="yes" xml:space="preserve">
          <source>target of the generated Makefile copies the files found below each of the INST_* directories to their INSTALL* counterparts. Which counterparts are chosen depends on the setting of INSTALLDIRS according to the following table:</source>
          <target state="translated">생성 된 Makefile의 대상은 각 INST_ * 디렉토리 아래에있는 파일을 INSTALL *에 복사합니다. 어떤 상대를 선택할지는 다음 표에 따라 INSTALLDIRS 설정에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="b68453cfafaf03d760bb9dc7658681aa08f3e49e" translate="yes" xml:space="preserve">
          <source>tassilo.von.parseval@rwth-aachen.de</source>
          <target state="translated">tassilo.von.parseval@rwth-aachen.de</target>
        </trans-unit>
        <trans-unit id="d61e3363def3f4e448c68105abdea736e4532873" translate="yes" xml:space="preserve">
          <source>tc</source>
          <target state="translated">tc</target>
        </trans-unit>
        <trans-unit id="0149c18dabcd96bae2f25a7e00ae9ecea78b9611" translate="yes" xml:space="preserve">
          <source>tcgrep</source>
          <target state="translated">tcgrep</target>
        </trans-unit>
        <trans-unit id="29c0d8eff9f163cb6a8896d13bbe15bb612a918a" translate="yes" xml:space="preserve">
          <source>tchrist (at) perl.com</source>
          <target state="translated">tchrist (at) perl.com</target>
        </trans-unit>
        <trans-unit id="68a09c4b5159b8e368e5d1bceac981c56c50e973" translate="yes" xml:space="preserve">
          <source>tchrist@mox.perl.com</source>
          <target state="translated">tchrist@mox.perl.com</target>
        </trans-unit>
        <trans-unit id="496b57d4f5b2e6a3f4b8499a5536eb48d3ba5c9b" translate="yes" xml:space="preserve">
          <source>tchrist@perl.com</source>
          <target state="translated">tchrist@perl.com</target>
        </trans-unit>
        <trans-unit id="47b8015d98d5103a8a6981a979514855cac10ebc" translate="yes" xml:space="preserve">
          <source>tell</source>
          <target state="translated">tell</target>
        </trans-unit>
        <trans-unit id="a2e2d5e4967eb691adb3cb90a64f4254b2a1dc46" translate="yes" xml:space="preserve">
          <source>tell FILEHANDLE</source>
          <target state="translated">FILEHANDLE에게 말해</target>
        </trans-unit>
        <trans-unit id="92794ee7e6ac81c9d0817ebf20684a58c197e63c" translate="yes" xml:space="preserve">
          <source>telldir</source>
          <target state="translated">telldir</target>
        </trans-unit>
        <trans-unit id="0b71e99628dd6430e7fea176d4129b7a8ec37b08" translate="yes" xml:space="preserve">
          <source>telldir DIRHANDLE</source>
          <target state="translated">telldir DIRHANDLE</target>
        </trans-unit>
        <trans-unit id="b0c0a02ffde3c44fa00b63c51cbb72effceae586" translate="yes" xml:space="preserve">
          <source>telling the class of the argument [C99].</source>
          <target state="translated">논증의 클래스에게 말하는 것 [C99].</target>
        </trans-unit>
        <trans-unit id="59b3aa384d6a9c476a221a2eda4917392e16c2d7" translate="yes" xml:space="preserve">
          <source>tells Perl that the program is embedded in a larger chunk of unrelated text, such as in a mail message. Leading garbage will be discarded until the first line that starts with &lt;code&gt;#!&lt;/code&gt; and contains the string &quot;perl&quot;. Any meaningful switches on that line will be applied.</source>
          <target state="translated">프로그램이 메일 메시지와 같이 더 큰 관련이없는 텍스트에 포함되어 있음을 Perl에 알립니다. &lt;code&gt;#!&lt;/code&gt; 시작하는 첫 번째 줄까지는 가비지가 버립니다 . 문자열 &quot;perl&quot;을 포함합니다. 해당 회선의 의미있는 스위치가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="22e9f56882c87c3da193be3fe6d8c77ffdaf27bc" translate="yes" xml:space="preserve">
          <source>telnet</source>
          <target state="translated">telnet</target>
        </trans-unit>
        <trans-unit id="e17be14d891796d29c88b561a3f5c6c8310bbdc3" translate="yes" xml:space="preserve">
          <source>temporarily makes $Here::blue an alias for $There::green, but doesn't make @Here::blue an alias for @There::green, or %Here::blue an alias for %There::green, etc. See &lt;a href=&quot;perlmod#Symbol-Tables&quot;&gt;Symbol Tables in perlmod&lt;/a&gt; for more examples of this. Strange though this may seem, this is the basis for the whole module import/export system.</source>
          <target state="translated">일시적으로 $ Here :: blue를 $ There :: green의 별칭으로 만들지 만 @Here :: blue를 @There :: green의 별칭으로 만들지 않거나 % Here :: blue를 % There :: green의 별칭으로 만들지 않습니다. 더 자세한 내용 &lt;a href=&quot;perlmod#Symbol-Tables&quot;&gt;은 perlmod의 기호 테이블을&lt;/a&gt; 참조하십시오 . 이상하게 보일 수 있지만 이것이 전체 모듈 가져 오기 / 내보내기 시스템의 기초입니다.</target>
        </trans-unit>
        <trans-unit id="35825a61520f1c2ed79153398a1a3b55fc959ba6" translate="yes" xml:space="preserve">
          <source>temporarily override assorted &lt;code&gt;CPAN.pm&lt;/code&gt; configuration variables</source>
          <target state="translated">분류 된 &lt;code&gt;CPAN.pm&lt;/code&gt; 구성 변수를 임시로 재정의</target>
        </trans-unit>
        <trans-unit id="91ad65ee0c085dfce15fcf8c596de36b7d3e5bed" translate="yes" xml:space="preserve">
          <source>tended Unicode character.</source>
          <target state="translated">경향이있는 유니 코드 문자.</target>
        </trans-unit>
        <trans-unit id="0c710463aba09fea37318d6a1e322bde072ae43c" translate="yes" xml:space="preserve">
          <source>termcap(5)</source>
          <target state="translated">termcap(5)</target>
        </trans-unit>
        <trans-unit id="9a9c106ef0b7b5f35055988715406d563a4b3327" translate="yes" xml:space="preserve">
          <source>terminal capacities</source>
          <target state="translated">터미널 용량</target>
        </trans-unit>
        <trans-unit id="e715ccd5a1a578c299a8d942b4b10bbeb1c3b460" translate="yes" xml:space="preserve">
          <source>test 4 may fail if you are on a tmpfs of some sort. Building in /tmp sometimes shows this behavior. The test suite detects if you are building in /tmp, but it may not be able to catch all tmpfs situations.</source>
          <target state="translated">tmpfs를 사용하는 경우 테스트 4가 실패 할 수 있습니다. / tmp로 빌드하면 때때로이 동작이 표시됩니다. 테스트 스위트는 / tmp에 빌드 중인지를 감지하지만 모든 tmpfs 상황을 포착하지 못할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3baa493ec3f690bb6e71fbdecd667bead97dd08b" translate="yes" xml:space="preserve">
          <source>test and install by</source>
          <target state="translated">테스트 및 설치</target>
        </trans-unit>
        <trans-unit id="ab9e5c896f4e6e83350f7e6655ffaca65aa5faa7" translate="yes" xml:space="preserve">
          <source>test fails. More precisely: the subtests using datagram sockets fail. Unix datagram sockets aren't implemented in Haiku yet.</source>
          <target state="translated">테스트 실패 보다 정확하게는 데이터 그램 소켓을 사용한 하위 테스트가 실패합니다. Unix 데이터 그램 소켓은 아직 Haiku에서 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="2e335b5beb93717af185fbf36192a610a92fac52" translate="yes" xml:space="preserve">
          <source>test fails. This is due to Haiku not implementing</source>
          <target state="translated">테스트 실패 이것은 Haiku가 구현하지 않았기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="46fa1990856d6bfc5aa426d6de0036a2f3e6f778" translate="yes" xml:space="preserve">
          <source>test hangs (subtest #51, FWIW) for some unknown reason. Just stop the test and kill that particular Perl process.</source>
          <target state="translated">알 수없는 이유로 테스트가 중단됩니다 (서브 테스트 # 51, FWIW). 테스트를 중단하고 특정 Perl 프로세스를 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="1745a2b1e1df23d1d960c6a914693643c4d35ef0" translate="yes" xml:space="preserve">
          <source>test methods</source>
          <target state="translated">시험 방법</target>
        </trans-unit>
        <trans-unit id="06069cf41f09b0e9e006f68445efe0b43e5710d7" translate="yes" xml:space="preserve">
          <source>test which will simply check that your code compiles and stop &quot;make test&quot; prematurely if it doesn't. See &lt;a href=&quot;../test/more#BAIL_OUT&quot;&gt;BAIL_OUT in Test::More&lt;/a&gt; for more details.</source>
          <target state="translated">test는 단순히 코드가 컴파일되었는지 확인하고 그렇지 않은 경우 &quot;make test&quot;를 조기에 중지합니다. 자세한 내용 &lt;a href=&quot;../test/more#BAIL_OUT&quot;&gt;은 Test :: More의 BAIL_OUT&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5ab50aa4c10a2157c2768ce7cbfe05ab8151cfe2" translate="yes" xml:space="preserve">
          <source>test). Do not forget to unset &lt;code&gt;PERL_EMXLOAD_SEC&lt;/code&gt; in environment.</source>
          <target state="translated">테스트). 환경에서 &lt;code&gt;PERL_EMXLOAD_SEC&lt;/code&gt; 를 설정 해제하는 것을 잊지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="33c341554523e86b3f9130f24b43a7e89a4a0a09" translate="yes" xml:space="preserve">
          <source>test. These failures have been suppressed in the current release of Perl by making the test ignore the broken locale. If you need to use the eu_ES locale, you should contact Apple support.</source>
          <target state="translated">테스트. 테스트가 깨진 로케일을 무시하게함으로써 현재 릴리스의 Perl에서 이러한 실패가 억제되었습니다. eu_ES 로켈을 사용해야하는 경우 Apple 지원에 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="a7cd61938a0a91df8c916296b3b0f681386d5536" translate="yes" xml:space="preserve">
          <source>test.pl</source>
          <target state="translated">test.pl</target>
        </trans-unit>
        <trans-unit id="abcdea9505604adb409a5d5ccd0cb809dd18e42a" translate="yes" xml:space="preserve">
          <source>test; binary files are processed with no translation whatsoever.</source>
          <target state="translated">테스트; 이진 파일은 번역없이 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="3513b382c069b0fd8b3d292ba2ef971e3becdb2a" translate="yes" xml:space="preserve">
          <source>test_class</source>
          <target state="translated">test_class</target>
        </trans-unit>
        <trans-unit id="7f1ada35b851823cf91787553404eba4704dc7a4" translate="yes" xml:space="preserve">
          <source>test_via_harness</source>
          <target state="translated">test_via_harness</target>
        </trans-unit>
        <trans-unit id="3bffec6eb2d501ce6398ddc2723cd9ac30610307" translate="yes" xml:space="preserve">
          <source>test_via_script</source>
          <target state="translated">test_via_script</target>
        </trans-unit>
        <trans-unit id="3206488df435bc6923ead2447a155e7c1f00933c" translate="yes" xml:space="preserve">
          <source>testfile.valgrind</source>
          <target state="translated">testfile.valgrind</target>
        </trans-unit>
        <trans-unit id="c1bb9bde819ec6d35d0f58572f8df6e36e4c2bf3" translate="yes" xml:space="preserve">
          <source>testname.valgrind</source>
          <target state="translated">testname.valgrind</target>
        </trans-unit>
        <trans-unit id="59e66e0e48871942840a17df9ee6e297fe40f6c2" translate="yes" xml:space="preserve">
          <source>testperl.cmd</source>
          <target state="translated">testperl.cmd</target>
        </trans-unit>
        <trans-unit id="e96f8663d0844a8d17b749192ecfb428c6302f95" translate="yes" xml:space="preserve">
          <source>testrules.yml</source>
          <target state="translated">testrules.yml</target>
        </trans-unit>
        <trans-unit id="d44f2bc95b0b12466d2814becdc0fd3ca48f3c86" translate="yes" xml:space="preserve">
          <source>tests.</source>
          <target state="translated">tests.</target>
        </trans-unit>
        <trans-unit id="381c53b73f80ba38b12ab16a309f35591b7a80f5" translate="yes" xml:space="preserve">
          <source>tet.</source>
          <target state="translated">tet.</target>
        </trans-unit>
        <trans-unit id="372ea08cab33e71c02c651dbc83a474d32c676ea" translate="yes" xml:space="preserve">
          <source>text</source>
          <target state="translated">text</target>
        </trans-unit>
        <trans-unit id="441549601c13844544e8e096a23806454251355e" translate="yes" xml:space="preserve">
          <source>text of the POD interior sequence, exactly as it appeared in the input.</source>
          <target state="translated">입력에 나타난대로 POD 내부 시퀀스의 텍스트.</target>
        </trans-unit>
        <trans-unit id="5854731dd9ff4ac55f9ae30f794b63778a1f38b3" translate="yes" xml:space="preserve">
          <source>text of the POD paragraph, exactly as it appeared in the input.</source>
          <target state="translated">입력에 나타난대로 정확하게 POD 단락의 텍스트.</target>
        </trans-unit>
        <trans-unit id="ec9e1fb1bdd5ff95f2ef0e5a4bf1f898a6f466e1" translate="yes" xml:space="preserve">
          <source>text of the POD parse-tree exactly as it appeared in the input.</source>
          <target state="translated">입력에 나타난 POD 구문 분석 트리의 텍스트</target>
        </trans-unit>
        <trans-unit id="4c95279946893e6de448e06e614d4ac86b109eed" translate="yes" xml:space="preserve">
          <source>text should ignored.</source>
          <target state="translated">텍스트는 무시해야합니다.</target>
        </trans-unit>
        <trans-unit id="cb46ca32d20cdfb81305bac97aa109b83dc1b07c" translate="yes" xml:space="preserve">
          <source>text, but</source>
          <target state="translated">텍스트이지만</target>
        </trans-unit>
        <trans-unit id="99928878118e841388df9f386a36622511ce6080" translate="yes" xml:space="preserve">
          <source>text. (This distinction may or may not be evident in the particular tree/event model implemented by the Pod parser.) For example, consider this unusual case:</source>
          <target state="translated">본문. (이러한 차이점은 포드 파서가 구현 한 특정 트리 / 이벤트 모델에서 분명하거나 분명하지 않을 수 있습니다.) 예를 들어, 다음과 같은 예외적 인 경우를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="95271a946f22c453ade18117f4cca5dc0f833cc4" translate="yes" xml:space="preserve">
          <source>text...</source>
          <target state="translated">text...</target>
        </trans-unit>
        <trans-unit id="38e9be6401e62f7d1555230d9df956fb85c2ba6e" translate="yes" xml:space="preserve">
          <source>text1</source>
          <target state="translated">text1</target>
        </trans-unit>
        <trans-unit id="8057ce4541a822035c1ef56a5b6686508928ea3b" translate="yes" xml:space="preserve">
          <source>text2</source>
          <target state="translated">text2</target>
        </trans-unit>
        <trans-unit id="9ccace0a1ad010c2a1855debb151e0bb936e66ba" translate="yes" xml:space="preserve">
          <source>th element of this array holds the offset of the</source>
          <target state="translated">이 배열의 요소는</target>
        </trans-unit>
        <trans-unit id="0ecc97d66bd161e24f5253814be739b1ade3945b" translate="yes" xml:space="preserve">
          <source>th group before the &lt;code&gt;\g{-&lt;i&gt;N&lt;/i&gt;}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;\g{-&lt;i&gt;N&lt;/i&gt;}&lt;/code&gt; 앞의 그룹 .</target>
        </trans-unit>
        <trans-unit id="8eb3ae1a9ace25086621583ab7192613b95dc786" translate="yes" xml:space="preserve">
          <source>th innermost &lt;code&gt;( )&lt;/code&gt; group, or to the start of the string if</source>
          <target state="translated">가장 안쪽 &lt;code&gt;( )&lt;/code&gt; 그룹 또는 문자열의 시작 부분 인 경우</target>
        </trans-unit>
        <trans-unit id="2ebcfb27ee2bfc8009de717d401cdb448c047d64" translate="yes" xml:space="preserve">
          <source>th root directly by &lt;code&gt;root(z, n, k)&lt;/code&gt; , indexing starting from</source>
          <target state="translated">&lt;code&gt;root(z, n, k)&lt;/code&gt; 의해 직접 루트 , 인덱싱</target>
        </trans-unit>
        <trans-unit id="3aa3461c082e7dae7d60c4657a925fe45e7c519d" translate="yes" xml:space="preserve">
          <source>th root for &lt;code&gt;z = [r,t]&lt;/code&gt; is given by:</source>
          <target state="translated">&lt;code&gt;z = [r,t]&lt;/code&gt; 루트 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="055966868aa553760505967c00a7c5d6818ef82f" translate="yes" xml:space="preserve">
          <source>th submatch, so &lt;code&gt;$+[1]&lt;/code&gt; is the offset past where &lt;code&gt;$1&lt;/code&gt; ends, &lt;code&gt;$+[2]&lt;/code&gt; the offset past where &lt;code&gt;$2&lt;/code&gt; ends, and so on. You can use &lt;code&gt;$#+&lt;/code&gt; to determine how many subgroups were in the last successful match. See the examples given for the &lt;code&gt;@-&lt;/code&gt; variable.</source>
          <target state="translated">하위 일치 항목이므로 &lt;code&gt;$+[1]&lt;/code&gt; 은 &lt;code&gt;$1&lt;/code&gt; 끝나는 오프셋 과거 , &lt;code&gt;$+[2]&lt;/code&gt; 는 &lt;code&gt;$2&lt;/code&gt; 끝나는 오프셋 과거 등입니다. &lt;code&gt;$#+&lt;/code&gt; 를 사용 하여 마지막으로 성공한 하위 그룹 수를 확인할 수 있습니다 . &lt;code&gt;@-&lt;/code&gt; 변수에 제공된 예제를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b4d58221efef7dcc072ec5d5895f2fe6ca83de0e" translate="yes" xml:space="preserve">
          <source>th submatch, so &lt;code&gt;$-[1]&lt;/code&gt; is the offset where &lt;code&gt;$1&lt;/code&gt; begins, &lt;code&gt;$-[2]&lt;/code&gt; the offset where &lt;code&gt;$2&lt;/code&gt; begins, and so on.</source>
          <target state="translated">하위 일치이므로 &lt;code&gt;$-[1]&lt;/code&gt; 은 &lt;code&gt;$1&lt;/code&gt; 시작 되는 오프셋 , &lt;code&gt;$-[2]&lt;/code&gt; 는 &lt;code&gt;$2&lt;/code&gt; 가 시작 되는 오프셋 등입니다.</target>
        </trans-unit>
        <trans-unit id="b1fbf7c34837b574b0c78077af027bd61f3e43b9" translate="yes" xml:space="preserve">
          <source>th subpattern later in the pattern using the metacharacter \</source>
          <target state="translated">메타 문자를 사용하여 패턴에서 나중에 하위 패턴 \</target>
        </trans-unit>
        <trans-unit id="993c608b59dc5dfe8f8f24f36d08ea885a7e97f7" translate="yes" xml:space="preserve">
          <source>th time you access it. When a data item is looked up afresh, its number of uses is reset.</source>
          <target state="translated">당신이 그것에 접근하는 시간. 데이터 항목을 새로 조회하면 사용 횟수가 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="d820aa5f8750fdde33200083b0702a32578a6c95" translate="yes" xml:space="preserve">
          <source>than</source>
          <target state="translated">than</target>
        </trans-unit>
        <trans-unit id="f8d56f0d78517ccac80725a473ad26543c1149da" translate="yes" xml:space="preserve">
          <source>than the current value of $^F (by default 2 for &lt;code&gt;STDERR&lt;/code&gt; ). See &lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">현재 값 $ ^ F보다 (기본적으로 &lt;code&gt;STDERR&lt;/code&gt; 의 경우 2 ). &lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;perlvar의 $ ^ F를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="37e161466a88c9a41a96b5e1a785469a7cc68706" translate="yes" xml:space="preserve">
          <source>than the current value of $^F (by default 2 for &lt;code&gt;STDERR&lt;/code&gt; ). See &lt;a href=&quot;perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">현재 값 $ ^ F보다 (기본적으로 &lt;code&gt;STDERR&lt;/code&gt; 의 경우 2 ). &lt;a href=&quot;perlvar#%24%5eF&quot;&gt;perlvar의 $ ^ F를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8ea263d2427ffcfcca02154008ed63f280ffe403" translate="yes" xml:space="preserve">
          <source>than the indentation level, followed by one copy of</source>
          <target state="translated">들여 쓰기 레벨보다</target>
        </trans-unit>
        <trans-unit id="33b82201081ec7c438cb5d9a36cd72bcb153050b" translate="yes" xml:space="preserve">
          <source>that</source>
          <target state="translated">that</target>
        </trans-unit>
        <trans-unit id="712f902c58bdfbf92dc3035820fbc97dac3d7f9c" translate="yes" xml:space="preserve">
          <source>that Mark Jason Dominus employs in his paper on &quot;Rx&quot; ([1] in &lt;a href=&quot;#REFERENCES&quot;&gt;REFERENCES&lt;/a&gt;).</source>
          <target state="translated">마크 제이슨 도미 누스는 &quot;Rx&quot;( &lt;a href=&quot;#REFERENCES&quot;&gt;참조&lt;/a&gt; 1의 [1])에 관한 논문에서 사용하고있다 .</target>
        </trans-unit>
        <trans-unit id="c9c5244833fb206b954415ab3f54654400b7eb3c" translate="yes" xml:space="preserve">
          <source>that are not available in older versions of perl. The problem is that the version number for Fcntl is the same in perl 5.6.0 and in 5.005_03 even though they are different versions.</source>
          <target state="translated">이전 버전의 perl에서는 사용할 수 없습니다. 문제는 Fcntl의 버전 번호가 버전이 다르더라도 perl 5.6.0 및 5.005_03에서 동일하다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9eee5aaf9d09fc3579f3f15ad3d8b52f452536af" translate="yes" xml:space="preserve">
          <source>that are not in the list of</source>
          <target state="translated">그 목록에없는</target>
        </trans-unit>
        <trans-unit id="97950f338e4ed29ff49961cf2229ebd2cb383e46" translate="yes" xml:space="preserve">
          <source>that can also be run as a Perl script. To generate</source>
          <target state="translated">그것은 또한 Perl 스크립트로 실행될 수 있습니다. 생성</target>
        </trans-unit>
        <trans-unit id="29212c899911ccfcbbe5cbf6f831e9088556a7bc" translate="yes" xml:space="preserve">
          <source>that comes with the package, if that</source>
          <target state="translated">패키지와 함께 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="4090dd20c552b4219c34c03221f437018fa823a5" translate="yes" xml:space="preserve">
          <source>that contains all the perlguts necessary to push the two arguments into</source>
          <target state="translated">여기에는 두 가지 논증을</target>
        </trans-unit>
        <trans-unit id="d9a7d75f21aba5d2b3adbb588b8f62a714350deb" translate="yes" xml:space="preserve">
          <source>that function is called and is passed those OPTIONS (split on commas). It should return a sub ref to the main compilation function. After the user's program is loaded and parsed, that returned sub ref is invoked which can then go ahead and do the compilation, usually by making use of the &lt;code&gt;B&lt;/code&gt; module's functionality.</source>
          <target state="translated">해당 함수가 호출되고 해당 옵션 (쉼표에 쪼개짐)이 전달됩니다. 기본 컴파일 함수에 대한 하위 참조를 반환해야합니다. 사용자의 프로그램이로드되고 파싱 된 후, 반환 된 sub ref가 호출되어 보통 &lt;code&gt;B&lt;/code&gt; 모듈의 기능 을 사용하여 컴파일을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="49f6845d8cc6762655e9d8d5279b965b50bc34d9" translate="yes" xml:space="preserve">
          <source>that is the single character at &lt;code&gt;0xABC&lt;/code&gt; . Under &lt;code&gt;'strict'&lt;/code&gt; it is an error to not follow &lt;code&gt;\x&lt;/code&gt; with exactly two hex digits. When not under &lt;code&gt;'strict'&lt;/code&gt; a warning is generated if there is only one hex digit, and no warning is raised if there are more than two.</source>
          <target state="translated">&lt;code&gt;0xABC&lt;/code&gt; 의 단일 문자 입니다. 에서 &lt;code&gt;'strict'&lt;/code&gt; 이 따르지하면 오류가 &lt;code&gt;\x&lt;/code&gt; 와 정확히 두 개의 16 진수를. &lt;code&gt;'strict'&lt;/code&gt; 가 아닌 경우 16 진 숫자가 하나만 있으면 경고가 생성되고 두 개 이상이면 경고가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e4f20743e591fca32ea867ef45df47d1193856a5" translate="yes" xml:space="preserve">
          <source>that is to be analyzed and use the permissible values on the left hand side of the matching operations. As an example for this somewhat paradoxical situation, let's assume that our input contains a command verb which should match one out of a set of available command verbs, with the additional twist that commands may be abbreviated as long as the given string is unique. The program below demonstrates the basic algorithm.</source>
          <target state="translated">즉, 분석하고 일치하는 조작의 왼쪽에서 허용 가능한 값을 사용하십시오. 다소 역설적 인 상황의 예로, 입력에 사용 가능한 명령 동사 세트 중 하나와 일치해야하는 명령 동사가 포함되어 있고 주어진 문자열이 고유 한 한 명령이 약어 화 될 수 있다는 추가 왜곡이 있다고 가정 해 봅시다. 아래 프로그램은 기본 알고리즘을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="64e4455297c586a9db29d5096ca7b93d57de5fe5" translate="yes" xml:space="preserve">
          <source>that is, the character whose code point value is &lt;code&gt;0xAB&lt;/code&gt; , followed by the letter &lt;code&gt;C&lt;/code&gt; . But since &lt;code&gt;C&lt;/code&gt; is a a hex digit, there is a reasonable chance that the intent was</source>
          <target state="translated">즉, 코드 포인트 값이 &lt;code&gt;0xAB&lt;/code&gt; 인 문자 뒤에 문자 &lt;code&gt;C&lt;/code&gt; 가 있습니다. 그러나 &lt;code&gt;C&lt;/code&gt; 는 16 진수 이므로 의도가</target>
        </trans-unit>
        <trans-unit id="1bc56929a849385fc4d0db6d314427d5b8dbddcd" translate="yes" xml:space="preserve">
          <source>that it was compiled in the package &lt;code&gt;main&lt;/code&gt; ;</source>
          <target state="translated">패키지 &lt;code&gt;main&lt;/code&gt; 에 컴파일되었다 ;</target>
        </trans-unit>
        <trans-unit id="5106349904c16b5fab53fb5e99dc60b9956ff5a3" translate="yes" xml:space="preserve">
          <source>that prints:</source>
          <target state="translated">그 인쇄 :</target>
        </trans-unit>
        <trans-unit id="2147c04b3cf47c1027e8b48decbbe54f8d12d79d" translate="yes" xml:space="preserve">
          <source>that specifies the value&amp;rsquo;s &lt;b&gt;offset&lt;/b&gt; in the sequence.</source>
          <target state="translated">시퀀스에서 값의 &lt;b&gt;오프셋&lt;/b&gt; 을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="9c0471ac111ba85b51a34c13abf7375fbf05cdbf" translate="yes" xml:space="preserve">
          <source>that superordinates of $lang1 are mutually intelligible with $lang1. Consider this carefully.</source>
          <target state="translated">$ lang1의 상위 항목은 $ lang1과 상호 이해하기 쉽습니다. 이것을 신중하게 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="2def5546b6eb47219f92a8fa7761c3e0fa1be7b9" translate="yes" xml:space="preserve">
          <source>that the STRING holds only well-formed UTF-8. Returns the previous state of the UTF8 flag (so please don't treat the return value as indicating success or failure), or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if</source>
          <target state="translated">STRING은 올바른 형식의 UTF-8 만 보유합니다. 반환은 UTF8 플래그의 이전 상태 (그래서 성공 또는 실패를 나타내는 등의 반환 값을 취급하지 마십시오), 또는 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 경우</target>
        </trans-unit>
        <trans-unit id="9330bf46ed7a31ad2571adf2313ea72910827fa1" translate="yes" xml:space="preserve">
          <source>that the parent has a &lt;code&gt;&amp;amp;&lt;/code&gt; pad slot pointing back to us. In this case, we set the &lt;code&gt;CvWEAKOUTSIDE&lt;/code&gt; flag in the child. This allows us to determine under what circumstances we should decrement the refcount of the parent when freeing the child.</source>
          <target state="translated">부모는 우리를 가리키는 &lt;code&gt;&amp;amp;&lt;/code&gt; 패드 슬롯을 가지고 있습니다. 이 경우 자식에서 &lt;code&gt;CvWEAKOUTSIDE&lt;/code&gt; 플래그를 설정합니다 . 이를 통해 우리는 자녀를 해방시킬 때 어떤 상황에서 부모의 체면을 감소시켜야하는지 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4b9eedbce74c74b8ab418c048257b665e5984fc" translate="yes" xml:space="preserve">
          <source>that this package generates, if that</source>
          <target state="translated">이 패키지가 생성하는 경우</target>
        </trans-unit>
        <trans-unit id="eaf21ed55aa93ffd795263ddba3f077b7975f18c" translate="yes" xml:space="preserve">
          <source>that will almost never be a problem, but if you install a filtering subroutine by passing it directly to the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Filter::Simple&lt;/code&gt; statement:</source>
          <target state="translated">그것은 거의 문제가되지 않지만, 필터링 서브 루틴을 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Filter::Simple&lt;/code&gt; 하여 직접 Filter :: Simple 문을 사용하여 필터링 하는 경우 :</target>
        </trans-unit>
        <trans-unit id="832edde3d5e2767ac60905e79c547b9f88b893ac" translate="yes" xml:space="preserve">
          <source>that you can find (e.g. by generating it with the latest &lt;code&gt;Devel::PPPort&lt;/code&gt; release from CPAN), copy it into your project, adjust your project to use it, and distribute the header along with your module.</source>
          <target state="translated">(예 : CPAN 의 최신 &lt;code&gt;Devel::PPPort&lt;/code&gt; 릴리스로 생성하여) 프로젝트에 복사하고 프로젝트를 사용하도록 조정 한 다음 모듈과 함께 헤더를 배포하십시오.</target>
        </trans-unit>
        <trans-unit id="bbccdf2efb33b52e6c9d0a14dd70b2d415fbea6e" translate="yes" xml:space="preserve">
          <source>the</source>
          <target state="translated">the</target>
        </trans-unit>
        <trans-unit id="fb4c660642c3786a6682f598d0a3ab6b2413a9c7" translate="yes" xml:space="preserve">
          <source>the &lt;b&gt;preprocess_paragraph()&lt;/b&gt; method. After all (possibly preprocessed) lines in a paragraph have been assembled together and either it has been determined that the paragraph is part of the POD documentation from one of the selected sections or the &lt;code&gt;-want_nonPODs&lt;/code&gt; option is true, then &lt;b&gt;preprocess_paragraph()&lt;/b&gt; is invoked.</source>
          <target state="translated">&lt;b&gt;preprocess_paragraph ()&lt;/b&gt; 방법. 단락의 모든 (전처리 된) 행이 함께 어셈블되고 해당 단락이 선택된 섹션 중 하나에서 POD 문서의 일부이거나 &lt;code&gt;-want_nonPODs&lt;/code&gt; 옵션이 true 인 것으로 판별 되면 &lt;b&gt;preprocess_paragraph ()&lt;/b&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d015472d9b89357d87fe6b5b8a3955a70873fd98" translate="yes" xml:space="preserve">
          <source>the &lt;b&gt;preprocess_paragraph()&lt;/b&gt; method. After all (possibly preprocessed) lines in a paragraph have been assembled together and it has been determined that the paragraph is part of the POD documentation from one of the selected sections, then &lt;b&gt;preprocess_paragraph()&lt;/b&gt; is invoked.</source>
          <target state="translated">&lt;b&gt;preprocess_paragraph ()&lt;/b&gt; 방법. 단락의 모든 (전처리 된) 행이 함께 모여 선택된 섹션 중 하나에서 해당 단락이 POD 문서의 일부인 것으로 확인되면 &lt;b&gt;preprocess_paragraph ()&lt;/b&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="1ecf3d6a18b09451ed79cad0f9c2d47da85bdc74" translate="yes" xml:space="preserve">
          <source>the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement is finished.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 문이 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="9da4ea008b0d3e45aac714865e3efcab30e81afa" translate="yes" xml:space="preserve">
          <source>the &lt;code&gt;SvPV&lt;/code&gt; call), and act accordingly:</source>
          <target state="translated">&lt;code&gt;SvPV&lt;/code&gt; 에 따라 전화), 행동 :</target>
        </trans-unit>
        <trans-unit id="d3ee9bbc572a709eb30d7bbdde11096841bab10e" translate="yes" xml:space="preserve">
          <source>the &lt;code&gt;warnings::warnif&lt;/code&gt; function will detect this and die after displaying the warning message.</source>
          <target state="translated">&lt;code&gt;warnings::warnif&lt;/code&gt; 기능이이를 감지하고 경고 메시지를 표시 한 후 죽을 것이다.</target>
        </trans-unit>
        <trans-unit id="5c42b113d5039ee22489d974cb36f9a7666caa3f" translate="yes" xml:space="preserve">
          <source>the UTF8 flag</source>
          <target state="translated">UTF8 플래그</target>
        </trans-unit>
        <trans-unit id="ea839584ddb420310c9f3ec76a311a74c5cd61a6" translate="yes" xml:space="preserve">
          <source>the Unicode Standard</source>
          <target state="translated">유니 코드 표준</target>
        </trans-unit>
        <trans-unit id="35fcc443e2d015d49e54156560cccc0fe8aa8232" translate="yes" xml:space="preserve">
          <source>the XSUBs are made accessible from Perl</source>
          <target state="translated">XSUB는 Perl에서 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8d781c395f2b10a1ab0f9dd5d80819da9e7f0c0" translate="yes" xml:space="preserve">
          <source>the absolute path to the file</source>
          <target state="translated">파일의 절대 경로</target>
        </trans-unit>
        <trans-unit id="59b69eb80989a1f9e7b09d9edab871ebd857e043" translate="yes" xml:space="preserve">
          <source>the access time stamp from t2 need not be greater-than the modify time stamp from t1: it may be equal or</source>
          <target state="translated">t2의 액세스 타임 스탬프는 t1의 수정 타임 스탬프보다 클 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="31ec033d4119bfbdee88e6c35979bdf5b199fb26" translate="yes" xml:space="preserve">
          <source>the actual open occurs, whether that be via &lt;code&gt;OPEN&lt;/code&gt; , &lt;code&gt;SYSOPEN&lt;/code&gt; , &lt;code&gt;FDOPEN&lt;/code&gt; or by letting a lower layer do the open.</source>
          <target state="translated">실제 열기는 &lt;code&gt;OPEN&lt;/code&gt; , &lt;code&gt;SYSOPEN&lt;/code&gt; , &lt;code&gt;FDOPEN&lt;/code&gt; 을 통해 또는 하위 계층에서 열기를 수행하도록합니다.</target>
        </trans-unit>
        <trans-unit id="61f80c2f1cd841c0f568a34a400477ec514d3d76" translate="yes" xml:space="preserve">
          <source>the actually executed command is</source>
          <target state="translated">실제로 실행되는 명령은</target>
        </trans-unit>
        <trans-unit id="11c6e5f1977cc3206ae0e58800729e6f410a3e7c" translate="yes" xml:space="preserve">
          <source>the address, not the string!</source>
          <target state="translated">문자열이 아닌 주소!</target>
        </trans-unit>
        <trans-unit id="fd3d54ca662c0c2684de323985f811bec22bd1c7" translate="yes" xml:space="preserve">
          <source>the applications in the system, this means a complete unpredictability of floating point flags on systems using such HOOK DLLs. E.g.,</source>
          <target state="translated">시스템의 응용 프로그램은 이러한 HOOK DLL을 사용하는 시스템에서 부동 소수점 플래그를 완전히 예측할 수 없음을 의미합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="05f3d9ddc3900af01143c7b2a3e5153aabb90af6" translate="yes" xml:space="preserve">
          <source>the arguments, but the signature variables get</source>
          <target state="translated">인수이지만 서명 변수는</target>
        </trans-unit>
        <trans-unit id="f4e158dd3c24f0129db3d82bff02272453579fe5" translate="yes" xml:space="preserve">
          <source>the bit-oriented &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">비트 지향 &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="44783b99ba624e2dd48d49637548b64060361a97" translate="yes" xml:space="preserve">
          <source>the block</source>
          <target state="translated">블록</target>
        </trans-unit>
        <trans-unit id="542b55c7fb7ff0a1d714925fc7ac958077c6109e" translate="yes" xml:space="preserve">
          <source>the block of text for the a POD paragraph</source>
          <target state="translated">POD 단락의 텍스트 블록</target>
        </trans-unit>
        <trans-unit id="aeeab916789b5b521be02e67178d8a43feaa0e51" translate="yes" xml:space="preserve">
          <source>the block of text for the verbatim paragraph</source>
          <target state="translated">완전 단락의 텍스트 블록</target>
        </trans-unit>
        <trans-unit id="c7bac64afd3313d8818026799b8430d1c87920d4" translate="yes" xml:space="preserve">
          <source>the byte ordering: whether the first byte is the least or most significant byte (or: little-endian or big-endian, respectively).</source>
          <target state="translated">바이트 순서 : 첫 번째 바이트가 가장 작은 바이트인지 가장 중요한 바이트인지 (또는 각각 리틀 엔디안 또는 빅 엔디안)</target>
        </trans-unit>
        <trans-unit id="c938f5030b0fa62c0dd034b19c1afbd25a5be589" translate="yes" xml:space="preserve">
          <source>the byte-oriented &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&quot;C&quot;&lt;/code&gt; format</source>
          <target state="translated">바이트 지향 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&quot;C&quot;&lt;/code&gt; 형식</target>
        </trans-unit>
        <trans-unit id="df0540c941ef1d583ac55c355b64fd5941bb42bc" translate="yes" xml:space="preserve">
          <source>the cached data. The argument may be a function name or a reference to a function. For finer control over when data is discarded or expired, see the documentation for &lt;code&gt;Memoize::Expire&lt;/code&gt; , included in this package.</source>
          <target state="translated">캐시 된 데이터 인수는 함수 이름이거나 함수에 대한 참조 일 수 있습니다. 데이터 삭제 또는 만료 시점을보다 세밀하게 제어하려면 이 패키지에 포함 된 &lt;code&gt;Memoize::Expire&lt;/code&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2acb51fb1aaf7311d7872477d62b8f21a28f8ae1" translate="yes" xml:space="preserve">
          <source>the character strings.</source>
          <target state="translated">문자열</target>
        </trans-unit>
        <trans-unit id="c731556f14a6292f08e47a5dff92437af6238ab2" translate="yes" xml:space="preserve">
          <source>the closing delimiter of the here document), which would cause the earlier &quot; || die;\nexit;&quot; to be skipped in any sequence of code fragment extractions.</source>
          <target state="translated">이전 문서 &quot;|| die; \ nexit;&quot;의 원인이되는 여기 문서의 닫는 구분 기호). 코드 조각 추출 시퀀스에서 건너 뛰어야합니다.</target>
        </trans-unit>
        <trans-unit id="aab39bfbe0a7c70c1895d1af4eb651fc1e701058" translate="yes" xml:space="preserve">
          <source>the closing tag (or &quot;&quot; if no closing tag was found)</source>
          <target state="translated">닫는 태그 (또는 닫는 태그가없는 경우 &quot;&quot;)</target>
        </trans-unit>
        <trans-unit id="157b41d2b634c5bd10fddb35da9de75d247bc255" translate="yes" xml:space="preserve">
          <source>the code by adding</source>
          <target state="translated">추가하여 코드</target>
        </trans-unit>
        <trans-unit id="d315aab2b081580801bce5775047436139f6f3cc" translate="yes" xml:space="preserve">
          <source>the code does what it does, not</source>
          <target state="translated">코드가하는 일이 아니라</target>
        </trans-unit>
        <trans-unit id="61801a1e0739c9c513bb5a98dbb30d9d43a9bad8" translate="yes" xml:space="preserve">
          <source>the code point belongs to, e.g. &lt;code&gt;Basic Latin&lt;/code&gt; . The old-style block name is returned (see &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;Old-style versus new-style block names&lt;/a&gt;). The &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; function can be used to get all the synonyms of the block name.</source>
          <target state="translated">코드 포인트는 예를 들어 &lt;code&gt;Basic Latin&lt;/code&gt; 에 속합니다 . 이전 스타일 블록 이름이 리턴됩니다 ( &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;이전 스타일 대 새 스타일 블록 이름 참조&lt;/a&gt; ). &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases ()&lt;/a&gt; 함수는 블록 이름의 모든 동의어를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f740a37880db96fc9c17587892331ec08337334" translate="yes" xml:space="preserve">
          <source>the code point belongs to, e.g., &lt;code&gt;Latin&lt;/code&gt; , &lt;code&gt;Greek&lt;/code&gt; , &lt;code&gt;Han&lt;/code&gt; . If the code point is unassigned or the Unicode version being used is so early that it doesn't have scripts, this function returns &lt;code&gt;&quot;Unknown&quot;&lt;/code&gt; . The &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; function can be used to get all the synonyms of the script name.</source>
          <target state="translated">코드 포인트는 예를 들어 &lt;code&gt;Latin&lt;/code&gt; , &lt;code&gt;Greek&lt;/code&gt; , &lt;code&gt;Han&lt;/code&gt; 에 속합니다 . 코드 포인트가 할당되지 않았거나 사용중인 유니 코드 버전이 너무 빠르면 스크립트가없는 경우이 함수는 &lt;code&gt;&quot;Unknown&quot;&lt;/code&gt; 을 반환합니다 . &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases ()&lt;/a&gt; 함수는 스크립트 이름의 모든 동의어를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17f78cf6f96569dfc482468db33ab5d6f1b57d15" translate="yes" xml:space="preserve">
          <source>the combining class number for</source>
          <target state="translated">에 대한 결합 클래스 번호</target>
        </trans-unit>
        <trans-unit id="2bd53f225cc971376af4c684c177d1bda41015ca" translate="yes" xml:space="preserve">
          <source>the command &lt;code&gt;cpan .&lt;/code&gt; does all of this at once. It figures out which of the two mantras is appropriate, fetches and installs all prerequisites, takes care of them recursively, and finally finishes the installation of the module in the current directory, be it a CPAN module or not.</source>
          <target state="translated">&lt;code&gt;cpan .&lt;/code&gt; 명령 . 이 모든 것을 한 번에 수행합니다. 두 가지 진언 중 어느 것이 적합한 지 알아 내고, 모든 전제 조건을 가져 와서 설치하고, 재귀 적으로 처리하며, CPAN 모듈이든 아니든 현재 디렉토리에서 모듈 설치를 완료합니다.</target>
        </trans-unit>
        <trans-unit id="5612fc997c8cb9a486d63ef7bf675962eedd7639" translate="yes" xml:space="preserve">
          <source>the commas on the right of the &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; are evaluated before the &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;, but the commas on the left are evaluated after. In other words, list operators tend to gobble up all arguments that follow, and then act like a simple TERM with regard to the preceding expression. Be careful with parentheses:</source>
          <target state="translated">의 오른쪽에 쉼표 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 전과 평가 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; ,하지만 왼쪽에 쉼표가 후 평가됩니다. 다시 말해,리스트 연산자는 뒤에 오는 모든 인수를 뒤섞 고 앞의 표현과 관련하여 간단한 TERM처럼 행동하는 경향이 있습니다. 괄호에주의하십시오 :</target>
        </trans-unit>
        <trans-unit id="2ea5806650c2d66f92a06b399e855bb23c546b4e" translate="yes" xml:space="preserve">
          <source>the compiler precomputes the number which that expression represents so that the interpreter won't have to.</source>
          <target state="translated">컴파일러는 인터프리터가 필요하지 않도록 해당 표현식이 나타내는 숫자를 미리 계산합니다.</target>
        </trans-unit>
        <trans-unit id="b590edf2b5459e947f26c3b792a11ee5b69155bd" translate="yes" xml:space="preserve">
          <source>the condition is true (or while the condition is false):</source>
          <target state="translated">조건이 참 (또는 조건이 거짓 인 동안) :</target>
        </trans-unit>
        <trans-unit id="86884d36b82542d454bba7bddac4a77b22d6fb75" translate="yes" xml:space="preserve">
          <source>the condition is true (that is, if the condition is false).</source>
          <target state="translated">조건이 true입니다 (즉, 조건이 false 인 경우).</target>
        </trans-unit>
        <trans-unit id="cd2f84b37e4990a4cdb084747345787afb430fab" translate="yes" xml:space="preserve">
          <source>the condition is true. &lt;code&gt;until&lt;/code&gt; does the opposite, it repeats the statement</source>
          <target state="translated">조건이 맞습니다. 반대가 &lt;code&gt;until&lt;/code&gt; 진술을 반복합니다.</target>
        </trans-unit>
        <trans-unit id="0b85c87e5cffade4a9922fbfed79cacba15c13fb" translate="yes" xml:space="preserve">
          <source>the conditions for the mappings to be valid. If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, the mappings are always valid. When defined, this field is a list of conditions, all of which must be true for the mappings to be valid. The list consists of one or more</source>
          <target state="translated">매핑 조건이 유효합니다. 경우 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 , 매핑은 항상 유효합니다. 정의 된 경우이 필드는 조건 목록이며 맵핑이 유효하려면 모두 참이어야합니다. 목록은 하나 이상의 구성</target>
        </trans-unit>
        <trans-unit id="9b0638bead3b3df68f86f19c3a14de1a6bd30e21" translate="yes" xml:space="preserve">
          <source>the correct subexpression to match the comment delimiter, because it may &quot;give up&quot; some whitespace if the remainder of the pattern can be made to match that way. The correct answer is either one of these:</source>
          <target state="translated">패턴의 나머지 부분이 그런 식으로 일치하도록 할 수 있으면 일부 공백을 &quot;포기&quot;할 수 있으므로 주석 구분 기호와 일치하는 올바른 하위 표현식입니다. 정답은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="49b2f2aa6cf4102d30e4466e987b20729a1c1858" translate="yes" xml:space="preserve">
          <source>the current one.</source>
          <target state="translated">현재의 것.</target>
        </trans-unit>
        <trans-unit id="f931ec421d5bf3d3b08aae794827e76698391462" translate="yes" xml:space="preserve">
          <source>the data is assumed to be in (Latin 1 and) Unicode, not in your native encoding. In other words, this will match in &quot;greek&quot;:</source>
          <target state="translated">데이터는 기본 인코딩이 아닌 (라틴어 1 및) 유니 코드에있는 것으로 가정합니다. 다시 말해, &quot;greek&quot;과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="ca54e1fd49bc4a6778d016e9f59ee0f6e72284bf" translate="yes" xml:space="preserve">
          <source>the data referred to by &lt;code&gt;$a&lt;/code&gt; is unchanged by the assignment to &lt;code&gt;$b&lt;/code&gt; of a reference to new object data.</source>
          <target state="translated">이 데이터가 참조 &lt;code&gt;$a&lt;/code&gt; 에 할당하여 변하지 &lt;code&gt;$b&lt;/code&gt; 새로운 데이터 객체에 대한 참조.</target>
        </trans-unit>
        <trans-unit id="73209f90d9d86d440950888ee02a95bcd44d45ad" translate="yes" xml:space="preserve">
          <source>the debugger hooks (but still before the opcode itself is executed).</source>
          <target state="translated">디버거 후크 (하지만 여전히 opcode 자체가 실행되기 전에).</target>
        </trans-unit>
        <trans-unit id="d4a89a5f8efeb10956bd5035175680bd86c4055c" translate="yes" xml:space="preserve">
          <source>the declaration. You cannot write &lt;code&gt;$x = 1; &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $x;&lt;/code&gt; and expect the first assignment to affect the same variable. It will instead assign to an &lt;code&gt;$x&lt;/code&gt; declared previously in an outer scope, or to a global variable.</source>
          <target state="translated">선언. &lt;code&gt;$x = 1; &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $x;&lt;/code&gt; 쓸 수 없습니다 . 내 $ x; 첫 번째 할당이 동일한 변수에 영향을 미칠 것으로 예상합니다. 대신 외부 범위에서 이전에 선언 된 &lt;code&gt;$x&lt;/code&gt; 또는 전역 변수에 할당됩니다 .</target>
        </trans-unit>
        <trans-unit id="6bf7f3909d5cb420150d508cb1f4a30ca1987a1f" translate="yes" xml:space="preserve">
          <source>the differences being that it generates a real list at compile time, and in scalar context it returns the last element in the list. So this expression:</source>
          <target state="translated">컴파일 타임에 실제 목록을 생성한다는 점과 스칼라 컨텍스트에서 목록의 마지막 요소를 반환한다는 차이점이 있습니다. 그래서이 표현은 :</target>
        </trans-unit>
        <trans-unit id="85b968ca06524fd795c08850a7f7f0ce5c3baeda" translate="yes" xml:space="preserve">
          <source>the directory the file was read from</source>
          <target state="translated">파일을 읽은 디렉토리</target>
        </trans-unit>
        <trans-unit id="b05011b947d845e0f9cffdcd079fb878ae1595be" translate="yes" xml:space="preserve">
          <source>the effect is to pass the &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call an extra reference to the variable being tied:</source>
          <target state="translated">결과는 연결되는 변수에 대한 추가 참조를 &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 호출 에 전달하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="24fdc39732587c01a485c44d61e61763164109d8" translate="yes" xml:space="preserve">
          <source>the elements in the array, only several first (depending on how deep it already went into the report tree).</source>
          <target state="translated">배열의 요소, 처음 몇 개만 (보고서 트리에 이미 깊숙이 들어 갔는지에 따라).</target>
        </trans-unit>
        <trans-unit id="da9e783c4554e1b5cab3e0647438bcc9a853ead9" translate="yes" xml:space="preserve">
          <source>the end of the script.</source>
          <target state="translated">스크립트의 끝.</target>
        </trans-unit>
        <trans-unit id="f7db5864c9ae797ba455c07e9a33679734cf02a5" translate="yes" xml:space="preserve">
          <source>the error message (usually either &lt;code&gt;$!&lt;/code&gt; or a YAML error)</source>
          <target state="translated">오류 메시지 (보통 &lt;code&gt;$!&lt;/code&gt; 또는 YAML 오류)</target>
        </trans-unit>
        <trans-unit id="7e9cc741fe4b132b7994345e5740c2efe34cbcb9" translate="yes" xml:space="preserve">
          <source>the error might show something like:</source>
          <target state="translated">오류는 다음과 같이 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bb3b69c49ba7467556b8814bc9da23ade9275bf" translate="yes" xml:space="preserve">
          <source>the exact number of times &quot;a&quot; or &quot;b&quot; are printed out is unspecified for failure, but you may assume they will be printed at least once during a successful match, additionally you may assume that if &quot;b&quot; is printed, it will be preceded by at least one &quot;a&quot;.</source>
          <target state="translated">&quot;a&quot;또는 &quot;b&quot;가 인쇄되는 정확한 횟수는 실패로 지정되지 않았지만 일치하는 동안 최소 한 번 인쇄 될 것이라고 가정 할 수 있으며, &quot;b&quot;가 인쇄되면 하나 이상의 &quot;a&quot;가 앞에옵니다.</target>
        </trans-unit>
        <trans-unit id="af071f22416397889c6368582b0fa9e1dd2f95c7" translate="yes" xml:space="preserve">
          <source>the extension needs an &lt;code&gt;HMQ&lt;/code&gt; only because some API will not work otherwise. Use &lt;code&gt;serve = 0&lt;/code&gt; below.</source>
          <target state="translated">일부 API는 달리 작동하지 않기 때문에 확장에는 &lt;code&gt;HMQ&lt;/code&gt; 만 필요합니다 . 아래 &lt;code&gt;serve = 0&lt;/code&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="68653d9ba062184ae14c759dbc109e73f199c9ee" translate="yes" xml:space="preserve">
          <source>the extension needs an &lt;code&gt;HMQ&lt;/code&gt; since it wants to engage in a PM event loop. Use &lt;code&gt;serve = 1&lt;/code&gt; below.</source>
          <target state="translated">PM 이벤트 루프에 참여 하려면 확장에 &lt;code&gt;HMQ&lt;/code&gt; 가 필요합니다 . 아래 &lt;code&gt;serve = 1&lt;/code&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6cf3f84a1f238cbd74e98add44f2ddd490e3387b" translate="yes" xml:space="preserve">
          <source>the external libraries to be linked to dynamic extensions. This may be needed if the linker is one-pass, and Perl includes some overrides for C RTL functions, such as malloc().</source>
          <target state="translated">동적 확장에 링크 될 외부 라이브러리 링커가 하나의 패스이고 Perl에 malloc ()과 같은 C RTL 함수에 대한 재정의가 포함 된 경우에 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66ad2c58db4994c73cc010974641256709477f2b" translate="yes" xml:space="preserve">
          <source>the extracted quotelike substring (including trailing modifiers),</source>
          <target state="translated">추출 된 따옴표와 같은 부분 문자열 (후행 수정 자 포함)</target>
        </trans-unit>
        <trans-unit id="42d35ba5b2fb00e37e2c984e477ebc13cdfdf21b" translate="yes" xml:space="preserve">
          <source>the extracted tagged substring (including the outermost tags),</source>
          <target state="translated">추출 된 태그가 지정된 하위 문자열 (가장 바깥 쪽 태그 포함)</target>
        </trans-unit>
        <trans-unit id="3b49d2c5db6f2ef2aea9cd05887358917fb03add" translate="yes" xml:space="preserve">
          <source>the extracted variable, or variablish expression</source>
          <target state="translated">추출 된 변수 또는 변수 표현</target>
        </trans-unit>
        <trans-unit id="016bf1faef4ea8a64bf0b8c954cc8c806ed5c738" translate="yes" xml:space="preserve">
          <source>the fields $quota, $comment, and $expire are special in that they are unsupported on many systems. If the $quota is unsupported, it is an empty scalar. If it is supported, it usually encodes the disk quota. If the $comment field is unsupported, it is an empty scalar. If it is supported it usually encodes some administrative comment about the user. In some systems the $quota field may be $change or $age, fields that have to do with password aging. In some systems the $comment field may be $class. The $expire field, if present, encodes the expiration period of the account or the password. For the availability and the exact meaning of these fields in your system, please consult getpwnam(3) and your system's</source>
          <target state="translated">$ quota, $ comment 및 $ expire 필드는 많은 시스템에서 지원되지 않는다는 점에서 특별합니다. $ quota가 지원되지 않으면 빈 스칼라입니다. 지원되는 경우 일반적으로 디스크 할당량을 인코딩합니다. $ comment 필드가 지원되지 않으면 빈 스칼라입니다. 지원되는 경우 일반적으로 사용자에 대한 일부 관리 설명을 인코딩합니다. 일부 시스템에서 $ quota 필드는 암호 변경과 관련된 $ change 또는 $ age 필드 일 수 있습니다. 일부 시스템에서 $ comment 필드는 $ class 일 수 있습니다. $ expire 필드 (있는 경우)는 계정 또는 비밀번호의 만료 기간을 인코딩합니다. 시스템에서 이러한 필드의 가용성과 정확한 의미에 대해서는 getpwnam (3) 및 시스템의</target>
        </trans-unit>
        <trans-unit id="4e6284d9ef77c16fa7441dbe48390b1ff7f11a75" translate="yes" xml:space="preserve">
          <source>the file from which these prefs were read, or to which this error refers (relative filename)</source>
          <target state="translated">이러한 prefs를 읽었거나이 오류가 참조한 파일 (상대 파일 이름)</target>
        </trans-unit>
        <trans-unit id="a49a7390520e745f712d707cf39a8ada8dd959c6" translate="yes" xml:space="preserve">
          <source>the file's extension, which determines how to load it</source>
          <target state="translated">로드 방법을 결정하는 파일 확장자</target>
        </trans-unit>
        <trans-unit id="8a39339004def4392cf2fce8539f1c9fa6e9e17a" translate="yes" xml:space="preserve">
          <source>the filename in which the handler is being invoked;</source>
          <target state="translated">핸들러가 호출되는 파일 이름;</target>
        </trans-unit>
        <trans-unit id="b5524a08a7a872ca1ac27bd75f06b0da87774a8b" translate="yes" xml:space="preserve">
          <source>the filter is installed. If you use &lt;code&gt;FILTER&lt;/code&gt; to install the filter:</source>
          <target state="translated">필터가 설치되었습니다. &lt;code&gt;FILTER&lt;/code&gt; 를 사용하여 필터 를 설치하는 경우 :</target>
        </trans-unit>
        <trans-unit id="836f7fa685865677b2a2c2f0109bf7a3edc63603" translate="yes" xml:space="preserve">
          <source>the first call to this function.</source>
          <target state="translated">이 함수에 대한 첫 번째 호출.</target>
        </trans-unit>
        <trans-unit id="3fc99dcf1fde0f1020c083b9f2e3c54eaa07013a" translate="yes" xml:space="preserve">
          <source>the first component of an absolute path is read as the device name for the VMS file specification). There are a set of functions provided in the &lt;code&gt;VMS::Filespec&lt;/code&gt; package for explicit interconversion between VMS and Unix syntax; its documentation provides more details.</source>
          <target state="translated">절대 경로의 첫 번째 구성 요소는 VMS 파일 사양의 장치 이름으로 읽습니다). VMS와 Unix 구문 사이의 명시적인 상호 변환을 위해 &lt;code&gt;VMS::Filespec&lt;/code&gt; 패키지에 제공되는 함수 세트가 있습니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="637e558c791eda9940492a71c91f36f4329c09c6" translate="yes" xml:space="preserve">
          <source>the first run-time executable statement (but see below regarding compile-time statements) and ask you to enter a debugger command. Contrary to popular expectations, whenever the debugger halts and shows you a line of code, it always displays the line it's</source>
          <target state="translated">첫 번째 런타임 실행 문 (하지만 컴파일 타임 문에 대해서는 아래 참조)을 디버거 명령을 입력하도록 요청하십시오. 일반적인 기대와 달리 디버거가 중단되고 코드 줄을 표시 할 때마다 항상 줄을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="27d75fc186bcb6caedfcf9d78e7e42f8dd826b81" translate="yes" xml:space="preserve">
          <source>the following (overloaded) operations are supported on complex numbers:</source>
          <target state="translated">복소수에서는 다음과 같은 (과부하 된) 연산이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="9900b62173a80d309d8d5d7804ced752318e7429" translate="yes" xml:space="preserve">
          <source>the following can all be used:</source>
          <target state="translated">다음을 모두 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f663eecb1d5e037a8b3023bffacae20c2edff826" translate="yes" xml:space="preserve">
          <source>the following service is available:</source>
          <target state="translated">다음과 같은 서비스를 이용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="6cf109d190f58d0cff05b560c507ed0c4b28dea2" translate="yes" xml:space="preserve">
          <source>the following two lines:</source>
          <target state="translated">다음 두 줄 :</target>
        </trans-unit>
        <trans-unit id="4255eecaa2211c75003fae1cac3a175c59a648c8" translate="yes" xml:space="preserve">
          <source>the following will be printed</source>
          <target state="translated">다음이 인쇄됩니다</target>
        </trans-unit>
        <trans-unit id="a359ea19d6e48fb338ab79b0de2cf3c5b08da2b3" translate="yes" xml:space="preserve">
          <source>the full Perl quotelike operations are all extracted correctly.</source>
          <target state="translated">전체 Perl 인용 유사 조작이 모두 올바르게 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="665373964dd300520c5ea8a5e5f85dae234c0a3f" translate="yes" xml:space="preserve">
          <source>the function &lt;code&gt;f&lt;/code&gt; is called with the implicit context argument (if any), and &lt;code&gt;p&lt;/code&gt; .</source>
          <target state="translated">함수 &lt;code&gt;f&lt;/code&gt; 는 암시 적 컨텍스트 인수 (있는 경우)와 함께 호출되며 &lt;code&gt;p&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3e46835aaeb90870490c67b35e66c766b0c603b8" translate="yes" xml:space="preserve">
          <source>the function &lt;code&gt;f&lt;/code&gt; is called with the only argument &lt;code&gt;p&lt;/code&gt; .</source>
          <target state="translated">함수 &lt;code&gt;f&lt;/code&gt; 는 유일한 인수 &lt;code&gt;p&lt;/code&gt; 로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="850abfb0a7900ca16bb5b9403d6bbfc093cbaf0c" translate="yes" xml:space="preserve">
          <source>the global copy.</source>
          <target state="translated">글로벌 카피</target>
        </trans-unit>
        <trans-unit id="f434ae09e827a25a29a618e48cd45a236fb5d87c" translate="yes" xml:space="preserve">
          <source>the group it refers to, it is now possible to apply pattern matching to tasks that hitherto required a recursive parser.</source>
          <target state="translated">참조하는 그룹은 이제 재귀 파서를 필요로하는 작업에 패턴 일치를 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b84befde5d1a886c007587e3a95889cb406da1f9" translate="yes" xml:space="preserve">
          <source>the hash &lt;code&gt;%defines&lt;/code&gt; (or &lt;code&gt;%$defines&lt;/code&gt; ) will contain two keys, &lt;code&gt;&quot;os&quot;&lt;/code&gt; with value &lt;code&gt;&quot;linux&quot;&lt;/code&gt; and &lt;code&gt;&quot;vendor&quot;&lt;/code&gt; with value &lt;code&gt;&quot;redhat&quot;&lt;/code&gt; . It is also possible to specify that only integer or floating point numbers are acceptable values. The keys are always taken to be strings.</source>
          <target state="translated">해시 &lt;code&gt;%defines&lt;/code&gt; (또는 &lt;code&gt;%$defines&lt;/code&gt; ), 두 개의 키를 포함 할 것이다 &lt;code&gt;&quot;os&quot;&lt;/code&gt; 값 &lt;code&gt;&quot;linux&quot;&lt;/code&gt; 와 &lt;code&gt;&quot;vendor&quot;&lt;/code&gt; 값 &lt;code&gt;&quot;redhat&quot;&lt;/code&gt; . 정수 또는 부동 소수점 숫자 만 허용되는 값으로 지정할 수도 있습니다. 키는 항상 문자열로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="5de606e1b8fb6cf1a474fddc76a9d896f8dab695" translate="yes" xml:space="preserve">
          <source>the hash of dot file names and content mappings</source>
          <target state="translated">도트 파일명 및 컨텐츠 매핑의 해시</target>
        </trans-unit>
        <trans-unit id="f1cd96b5f21ad238f5015969ec918856f8eea2c7" translate="yes" xml:space="preserve">
          <source>the identifier &quot;html&quot; doesn't begin have a &quot;:&quot; prefix, the contents of this region are stored as data paragraphs, instead of being processed as ordinary paragraphs (or if they began with a spaces and/or tabs, as verbatim paragraphs).</source>
          <target state="translated">식별자 &quot;html&quot;에 &quot;:&quot;접두사가 붙지 않으면이 영역의 내용은 일반 단락으로 처리되는 대신 데이터 단락으로 저장됩니다 (공백 및 / 또는 탭으로 시작하는 경우 그대로의 단락으로). ).</target>
        </trans-unit>
        <trans-unit id="74997a5db61b1cd6b27805f5b2e5dd2aa25c9e37" translate="yes" xml:space="preserve">
          <source>the include files by hand:</source>
          <target state="translated">직접 포함 파일 :</target>
        </trans-unit>
        <trans-unit id="0639a40b39994bddd5c923a37a742c0525b745c4" translate="yes" xml:space="preserve">
          <source>the input native &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt; expressed in hexadecimal, with leading zeros added if necessary to make it contain at least four hexdigits</source>
          <target state="translated">16 진수로 표현 된 입력 네이티브 &lt;a href=&quot;#code-point-argument&quot;&gt;코드 포인트 인수&lt;/a&gt; . 최소 4 자리를 포함하기 위해 필요한 경우 선행 0을 추가 함</target>
        </trans-unit>
        <trans-unit id="61ca6011deda6931eab08814d67f17903705c3cc" translate="yes" xml:space="preserve">
          <source>the input stream used by the current invocation of this method.</source>
          <target state="translated">이 메소드의 현재의 호출로 사용되는 입력 스트림</target>
        </trans-unit>
        <trans-unit id="5de1329fbaf0573c7809c0fde48792ca86cde1a3" translate="yes" xml:space="preserve">
          <source>the integer operation provides scalar context for the &amp;lt;&amp;gt; operator, which responds by reading one line from STDIN and passing it back to the integer operation, which will then find the integer value of that line and return that. If, on the other hand, you say</source>
          <target state="translated">정수 연산은 &amp;lt;&amp;gt; 연산자에 스칼라 컨텍스트를 제공합니다. STDIN에서 한 줄을 읽고이를 정수 연산으로 다시 전달하면 해당 라인의 정수 값을 찾아서 반환합니다. 반면에</target>
        </trans-unit>
        <trans-unit id="3c6c16bacb789d14f0c6c80b16288c33e3f368b9" translate="yes" xml:space="preserve">
          <source>the invocand performs the operations, merely that it does. (&lt;code&gt;isa&lt;/code&gt; of course mandates an inheritance relationship. Other relationships include aggregation, delegation, and mocking.)</source>
          <target state="translated">요청자는 단순히 그 작업을 수행합니다. ( &lt;code&gt;isa&lt;/code&gt; 과정은 상속 관계를 의무화. 다른 관계 집합, 위임 및 조롱을 포함한다.)</target>
        </trans-unit>
        <trans-unit id="ebbeb0be019cd7f66404e317364ede716923212f" translate="yes" xml:space="preserve">
          <source>the key 12345 will get stored in the DBM database as the 5 byte string &quot;12345&quot;. If you actually want the key to be stored in the DBM database as a C int, you will have to use &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; when writing, and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; when reading.</source>
          <target state="translated">키 12345는 DBM 데이터베이스에 5 바이트 문자열 &quot;12345&quot;로 저장됩니다. 실제로 키를 DBM 데이터베이스에 C int로 저장하려면 쓰기시 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 을 사용 하고 읽을 때는 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="767f35eec2056ec4a9c8dfce5c06b61f7815ff96" translate="yes" xml:space="preserve">
          <source>the left delimiter of the first block of the operation,</source>
          <target state="translated">연산의 첫 번째 블록의 왼쪽 구분 기호</target>
        </trans-unit>
        <trans-unit id="76aa8b9cbe9e34630c0db1543914a121410c5ea7" translate="yes" xml:space="preserve">
          <source>the left delimiter of the second block of the operation (that is, if it is a &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt;),</source>
          <target state="translated">연산의 두 번째 블록의 왼쪽 구분 기호 (즉, &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; 인 경우 )</target>
        </trans-unit>
        <trans-unit id="b06df6449e28067bcdeaaba89205c5a942c211c0" translate="yes" xml:space="preserve">
          <source>the length of the array via &lt;code&gt;$x = &lt;a href=&quot;../functions/scalar&quot;&gt;scalar&lt;/a&gt; @tied_file&lt;/code&gt; accesses &lt;b&gt;all&lt;/b&gt; records and stores their offsets. The same for &lt;code&gt;foreach (@tied_file)&lt;/code&gt; , even if you exit the loop early.</source>
          <target state="translated">&lt;code&gt;$x = &lt;a href=&quot;../functions/scalar&quot;&gt;scalar&lt;/a&gt; @tied_file&lt;/code&gt; 를 통한 배열의 길이 @tied_file은 &lt;b&gt;모든&lt;/b&gt; 레코드에 액세스 하고 오프셋을 저장합니다. 루프를 일찍 종료하더라도 &lt;code&gt;foreach (@tied_file)&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="6ccb0b24c3db89622ef2ccbd74733225119dada0" translate="yes" xml:space="preserve">
          <source>the lexicals should be separate anyway!)</source>
          <target state="translated">어휘는 어쨌든 분리되어야합니다!)</target>
        </trans-unit>
        <trans-unit id="b3350ff0610525714cd0795ab7665285a8cf78f9" translate="yes" xml:space="preserve">
          <source>the line number in this file.</source>
          <target state="translated">이 파일의 줄 번호</target>
        </trans-unit>
        <trans-unit id="26eb9a372a343a276c4a513a17b9005def4ede8b" translate="yes" xml:space="preserve">
          <source>the line-number of the beginning of the paragraph</source>
          <target state="translated">단락 시작의 행 번호</target>
        </trans-unit>
        <trans-unit id="3b67453a7d975f1bc1459469c850c239cfab6efb" translate="yes" xml:space="preserve">
          <source>the list of statically loaded extensions. We discuss this case only here.</source>
          <target state="translated">정적으로로드 된 확장 목록 여기서 만이 사례에 대해 논의합니다.</target>
        </trans-unit>
        <trans-unit id="051f0efa2b53b111aaca897cc0e249865ec7115d" translate="yes" xml:space="preserve">
          <source>the listed operators from being used when compiling code in the compartment (</source>
          <target state="translated">구획에서 코드를 컴파일 할 때 나열된 연산자 사용</target>
        </trans-unit>
        <trans-unit id="d8e84d0ea6af468855c18cc5c4165d6c2edf43f5" translate="yes" xml:space="preserve">
          <source>the listed operators to be used when compiling code in the compartment (</source>
          <target state="translated">구획에서 코드를 컴파일 할 때 사용되는 나열된 연산자 (</target>
        </trans-unit>
        <trans-unit id="31de264c7a353042751dac7324ee677917f37a3f" translate="yes" xml:space="preserve">
          <source>the name of the attribute;</source>
          <target state="translated">속성의 이름</target>
        </trans-unit>
        <trans-unit id="9a6dd96ba410443fbba39f655ba62d36a863540d" translate="yes" xml:space="preserve">
          <source>the name of the command for this POD paragraph</source>
          <target state="translated">이 POD 단락의 커멘드 명</target>
        </trans-unit>
        <trans-unit id="2c087f6dc6a4c7745ab845d35d36946b340507ca" translate="yes" xml:space="preserve">
          <source>the name of the distribution file). The rest of the line is optional. The comment part is delimited by a dash just as in the man page header.</source>
          <target state="translated">배포 파일의 이름). 나머지 줄은 선택 사항입니다. 주석 부분은 매뉴얼 페이지 헤더에서와 같이 대시로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="ca482cb8c936ba1473c739bc3144869ba0ef4341" translate="yes" xml:space="preserve">
          <source>the name of the package into which it was declared;</source>
          <target state="translated">패키지가 선언 된 패키지의 이름</target>
        </trans-unit>
        <trans-unit id="14146974f9eb8a14ac07caec61bf51bf5504d35b" translate="yes" xml:space="preserve">
          <source>the name of the phase in which the handler is being invoked;</source>
          <target state="translated">핸들러가 호출되는 단계의 이름;</target>
        </trans-unit>
        <trans-unit id="7cfba45823ccfce6febf457efcadfb34ef2605e6" translate="yes" xml:space="preserve">
          <source>the name of the quotelike operator (if any),</source>
          <target state="translated">따옴표와 같은 연산자의 이름 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="89dfd16b868608208dc5e268bb3cefacf7817535" translate="yes" xml:space="preserve">
          <source>the newline. In general, lines in Perl do not need any form of continuation mark, because &lt;b&gt;whitespace&lt;/b&gt; (including newlines) is gleefully ignored. Usually.</source>
          <target state="translated">개행. 일반적으로 &lt;b&gt;공백&lt;/b&gt; ( &lt;b&gt;줄&lt;/b&gt; 바꿈 포함)이 무시 되므로 Perl의 행에는 연속 표시 형식이 필요하지 않습니다 . 보통.</target>
        </trans-unit>
        <trans-unit id="372fe5c4d24ded7bde11806c2356f0b5e1e0ace4" translate="yes" xml:space="preserve">
          <source>the next interpreter is constructed. By default, when perl is not built with any special options, the global variable &lt;code&gt;PL_perl_destruct_level&lt;/code&gt; is set to &lt;code&gt;0&lt;/code&gt; , since extra cleaning isn't usually needed when a program only ever creates a single interpreter in its entire lifetime.</source>
          <target state="translated">다음 통역사가 구성됩니다. 기본적으로 perl이 특수 옵션으로 빌드되지 않은 경우 전역 변수 &lt;code&gt;PL_perl_destruct_level&lt;/code&gt; 은 &lt;code&gt;0&lt;/code&gt; 으로 설정 됩니다. 프로그램이 전체 수명 동안 단일 인터프리터 만 작성하는 경우 일반적으로 추가 정리가 필요하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="39b65447e9246a75ec1295250c74aaaa79fc46a4" translate="yes" xml:space="preserve">
          <source>the number of bytes used for storing the integer,</source>
          <target state="translated">정수를 저장하는 데 사용 된 바이트 수</target>
        </trans-unit>
        <trans-unit id="6a32bdad61a31a90e6bb104533ea9d93e395672b" translate="yes" xml:space="preserve">
          <source>the number of elements of each. It's so easy to make that mistake in reading &lt;code&gt;ok @foo, @bar&lt;/code&gt; that you might want to be very explicit about it, and instead write &lt;code&gt;ok &lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;(@foo),
&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;(@bar)&lt;/code&gt; .</source>
          <target state="translated">각 요소의 수 &lt;code&gt;ok @foo, @bar&lt;/code&gt; 를 읽을 때 실수를 저지르면 매우 명확하게 표현할 수 있고 대신 &lt;code&gt;ok &lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;(@foo), &lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;(@bar)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="823166c6684adfe84aefb20864f10ef5d6cd3d28" translate="yes" xml:space="preserve">
          <source>the numeric value of $c becomes 13. There is no doubt now that the module symbolic provides a</source>
          <target state="translated">$ c의 숫자 값은 13이됩니다. 이제 상징적 인 모듈이</target>
        </trans-unit>
        <trans-unit id="1ac3c3d918bc81daf5c65f159136b230693ee8fc" translate="yes" xml:space="preserve">
          <source>the offset from SvPVX back to the true start of the allocated buffer, which will be non-zero if &lt;code&gt;sv_chop&lt;/code&gt; has been used to efficiently remove characters from start of the buffer. Implemented as a macro, which takes the address of</source>
          <target state="translated">SvPVX에서 할당 된 버퍼의 실제 시작으로의 오프셋. sv_chop을 사용하여 버퍼의 시작에서 문자를 효율적으로 제거하는 경우 0이 &lt;code&gt;sv_chop&lt;/code&gt; . 매크로로 구현되어 주소를</target>
        </trans-unit>
        <trans-unit id="7ea73421a1bf18378d7ef84367c0382aecac8634" translate="yes" xml:space="preserve">
          <source>the opening tag</source>
          <target state="translated">오프닝 태그</target>
        </trans-unit>
        <trans-unit id="3b0998471797c48420431e27eecb5eb2cb35a85a" translate="yes" xml:space="preserve">
          <source>the opposite of &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;. Unfortunately.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 의 반대입니다 . 운수 나쁘게.</target>
        </trans-unit>
        <trans-unit id="80df94a93d5470e4069dee2128b3a3694259c404" translate="yes" xml:space="preserve">
          <source>the opposite of &lt;code&gt;&lt;a href=&quot;read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;. Unfortunately.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 의 반대입니다 . 운수 나쁘게.</target>
        </trans-unit>
        <trans-unit id="93d702a52abd879c9ef0db6a688f9798f839daa7" translate="yes" xml:space="preserve">
          <source>the option.</source>
          <target state="translated">옵션.</target>
        </trans-unit>
        <trans-unit id="350cdcf12a74c00b21d0c4d53a770475da27efeb" translate="yes" xml:space="preserve">
          <source>the other way round, some texts define the</source>
          <target state="translated">다른 방법으로, 일부 텍스트는</target>
        </trans-unit>
        <trans-unit id="2f75519c4c0e14572b57dc5211980f1b5e587f4d" translate="yes" xml:space="preserve">
          <source>the output produced should be the following:</source>
          <target state="translated">출력은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="5c767ed6a2f2639fc062b9d28d7dc0b33633147a" translate="yes" xml:space="preserve">
          <source>the output string will be UTF-8-encoded &lt;code&gt;ab\x80c = \x{100}\n&lt;/code&gt; , but &lt;code&gt;$a&lt;/code&gt; will stay byte-encoded.</source>
          <target state="translated">출력 문자열은 UTF-8로 인코딩 된 &lt;code&gt;ab\x80c = \x{100}\n&lt;/code&gt; 이지만 &lt;code&gt;$a&lt;/code&gt; 는 바이트 인코딩 된 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="b4a8c523528b0d85f392e6ce4200ec9cbaf77eae" translate="yes" xml:space="preserve">
          <source>the paragraph text for the given POD paragraph command.</source>
          <target state="translated">지정된 POD 단락 명령의 단락 텍스트</target>
        </trans-unit>
        <trans-unit id="f822b49959962d70befcbfcacaf19dd9565d4689" translate="yes" xml:space="preserve">
          <source>the parser to provide an option for turning off whatever feature Y is (like expanding tabs in verbatim paragraphs), although it implicates that such an option</source>
          <target state="translated">구문 분석기는 Y가 무엇이든 기능을 끌 수있는 옵션을 제공하기위한 옵션입니다 (언어 적 단락의 탭 확장과 같은).</target>
        </trans-unit>
        <trans-unit id="88570ffa7933968d627f1b08ec22739c075ae741" translate="yes" xml:space="preserve">
          <source>the pattern explicitly mentions a code point that is above 255 (say by &lt;code&gt;\x{100}&lt;/code&gt; ); or</source>
          <target state="translated">이 패턴은 255보다 큰 코드 포인트를 명시 적으로 언급합니다 (예 : &lt;code&gt;\x{100}&lt;/code&gt; ). 또는</target>
        </trans-unit>
        <trans-unit id="d194fb71a02627a887a473822a155aa2e1f901a9" translate="yes" xml:space="preserve">
          <source>the pattern is encoded in UTF-8; or</source>
          <target state="translated">패턴은 UTF-8로 인코딩됩니다. 또는</target>
        </trans-unit>
        <trans-unit id="ce1751b05d1676c44a794cb888d1e90f057639f9" translate="yes" xml:space="preserve">
          <source>the pattern that matched the tag). For example, if the opening tag pattern is specified as &lt;code&gt;'{{\w+}}'&lt;/code&gt; and actually matched the opening tag &lt;code&gt;&quot;{{DATA}}&quot;&lt;/code&gt; , then the constructed closing tag would be &lt;code&gt;&quot;{{/DATA}}&quot;&lt;/code&gt; .</source>
          <target state="translated">태그와 일치하는 패턴). 예를 들어, 시작 태그 패턴이 &lt;code&gt;'{{\w+}}'&lt;/code&gt; 되고 실제로 시작 태그 &lt;code&gt;&quot;{{DATA}}&quot;&lt;/code&gt; 와 일치하는 경우 구성된 닫는 태그는 &lt;code&gt;&quot;{{/DATA}}&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="805958852b9fabd97d8cb3a18bac20800a22b67b" translate="yes" xml:space="preserve">
          <source>the pattern uses &lt;a href=&quot;#(%3f%5b-%5d)&quot;&gt;(?[ ])&lt;/a&gt;</source>
          <target state="translated">패턴은 &lt;a href=&quot;#(%3f%5b-%5d)&quot;&gt;(? [])를 사용합니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a8bb7e10331595813f75125fc26a7f202e7e37c1" translate="yes" xml:space="preserve">
          <source>the pattern uses a Unicode break (&lt;code&gt;\b{...}&lt;/code&gt; or &lt;code&gt;\B{...}&lt;/code&gt; ); or</source>
          <target state="translated">패턴은 유니 코드 구분 ( &lt;code&gt;\b{...}&lt;/code&gt; 또는 &lt;code&gt;\B{...}&lt;/code&gt; )을 사용합니다. 또는</target>
        </trans-unit>
        <trans-unit id="a330eac785acc5b1bb1635b3789e2d14f4710fa2" translate="yes" xml:space="preserve">
          <source>the pattern uses a Unicode name (&lt;code&gt;\N{...}&lt;/code&gt; ); or</source>
          <target state="translated">패턴은 유니 코드 이름 ( &lt;code&gt;\N{...}&lt;/code&gt; )을 사용합니다. 또는</target>
        </trans-unit>
        <trans-unit id="319de4125fd648dad000c6e1c9a4045715bad67c" translate="yes" xml:space="preserve">
          <source>the pattern uses a Unicode property (&lt;code&gt;\p{...}&lt;/code&gt; or &lt;code&gt;\P{...}&lt;/code&gt; ); or</source>
          <target state="translated">패턴은 유니 코드 속성 ( &lt;code&gt;\p{...}&lt;/code&gt; 또는 &lt;code&gt;\P{...}&lt;/code&gt; )을 사용합니다. 또는</target>
        </trans-unit>
        <trans-unit id="953fba431cfe195c351926c788501983650a8200" translate="yes" xml:space="preserve">
          <source>the perlfaq1 manpage: General Questions About Perl</source>
          <target state="translated">perlfaq1 맨 페이지 : Perl에 대한 일반적인 질문</target>
        </trans-unit>
        <trans-unit id="c962ba6946dbfccd85f3f5271a7003191ebd8887" translate="yes" xml:space="preserve">
          <source>the perlfaq2 manpage: Obtaining and Learning about Perl</source>
          <target state="translated">perlfaq2 맨 페이지 : Perl 획득 및 학습</target>
        </trans-unit>
        <trans-unit id="55228c77c8f20b7e875b18ee26f839f3183d399f" translate="yes" xml:space="preserve">
          <source>the perlfaq3 manpage: Programming Tools</source>
          <target state="translated">perlfaq3 맨 페이지 : 프로그래밍 도구</target>
        </trans-unit>
        <trans-unit id="c72ba9d1250ab34429dfe558dcf1ad599418504b" translate="yes" xml:space="preserve">
          <source>the perlfaq4 manpage: Data Manipulation</source>
          <target state="translated">perlfaq4 맨 페이지 : 데이터 조작</target>
        </trans-unit>
        <trans-unit id="05f2cb3f31b45754271926a93a37e613128fc1a3" translate="yes" xml:space="preserve">
          <source>the perlfaq5 manpage: Files and Formats</source>
          <target state="translated">perlfaq5 맨 페이지 : 파일 및 형식</target>
        </trans-unit>
        <trans-unit id="68004027bca85f0a1316b9b13a10b7b5846e0a1b" translate="yes" xml:space="preserve">
          <source>the perlfaq6 manpage: Regular Expressions</source>
          <target state="translated">perlfaq6 맨 페이지 : 정규식</target>
        </trans-unit>
        <trans-unit id="244f6e549e1a7c9b4840cdb2b7c4f9d9cf311f72" translate="yes" xml:space="preserve">
          <source>the perlfaq7 manpage: General Perl Language Issues</source>
          <target state="translated">perlfaq7 맨 페이지 : 일반 Perl 언어 문제</target>
        </trans-unit>
        <trans-unit id="b09ef579f2deb212ce34e20f6e0845f53a94647e" translate="yes" xml:space="preserve">
          <source>the perlfaq8 manpage: System Interaction</source>
          <target state="translated">perlfaq8 맨 페이지 : 시스템 상호 작용</target>
        </trans-unit>
        <trans-unit id="bbac669f56b77bc0a865f02b9aa3ccb0fa2fd2de" translate="yes" xml:space="preserve">
          <source>the perlfaq9 manpage: Web, Email and Networking</source>
          <target state="translated">perlfaq9 맨 페이지 : 웹, 이메일 및 네트워킹</target>
        </trans-unit>
        <trans-unit id="6bfc9a7a2833aaf0aa50c76f44094717b420d8b5" translate="yes" xml:space="preserve">
          <source>the pref information as a hashref, suitable for e.g. passing to Kwalify</source>
          <target state="translated">Kwalify에 전달하기에 적합한 해시 참조로서의 pref 정보</target>
        </trans-unit>
        <trans-unit id="d6f629b5712722c77da1582162b0d1da4ce910df" translate="yes" xml:space="preserve">
          <source>the prefix substring (if any),</source>
          <target state="translated">접두사 부분 문자열 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="c7e0fd34e186fae12bf85657d77257670a5ce766" translate="yes" xml:space="preserve">
          <source>the processing of the declaration. In particular, this means that a subroutine reference will probably be for an undefined subroutine, even if this declaration is actually part of the definition.</source>
          <target state="translated">선언 처리 특히, 이는이 선언이 실제로 정의의 일부인 경우에도 서브 루틴 참조가 정의되지 않은 서브 루틴에 대한 것일 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b351ba6a6e6888ee3c37542cb09a710b8b82c7ea" translate="yes" xml:space="preserve">
          <source>the program's command name itself. See &lt;a href=&quot;#%240&quot;&gt;$0&lt;/a&gt; for the command name.</source>
          <target state="translated">프로그램의 명령 이름 자체 명령 이름 은 &lt;a href=&quot;#%240&quot;&gt;$ 0&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3d7c7188cc51913744a65950d8ac98c6b2024d7e" translate="yes" xml:space="preserve">
          <source>the record separator string is not supported by this module. It will probably produce a reasonable result, but what this result will be may change in a future version. Use 'splice' to insert records or to replace one record with several.</source>
          <target state="translated">이 모듈은 레코드 분리 자 문자열을 지원하지 않습니다. 아마도 합리적인 결과를 낳을 것이지만,이 결과는 향후 버전에서 변경 될 수 있습니다. '스플 라이스'를 사용하여 레코드를 삽입하거나 한 레코드를 여러 레코드로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="d9590ce68e648fe5245544ed53294f3198783eab" translate="yes" xml:space="preserve">
          <source>the remainder of the input text,</source>
          <target state="translated">입력 텍스트의 나머지</target>
        </trans-unit>
        <trans-unit id="2480552762ce0f7abb766d5aad5385526748ef25" translate="yes" xml:space="preserve">
          <source>the result is case-insensitive, but dotless and dotted I's are not distinguished</source>
          <target state="translated">결과는 대소 문자를 구분하지 않지만 점이 없으며 점으로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="e02477c839224237a3c3acbfe105933f3d8288fa" translate="yes" xml:space="preserve">
          <source>the result is not fully case-insensitive, but dotless and dotted I's are distinguished</source>
          <target state="translated">결과는 대소 문자를 구분하지 않지만 점이없는 점과 점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fe1d2372ef544a5efce8a965e686132c2b4c0e1" translate="yes" xml:space="preserve">
          <source>the result will be false).</source>
          <target state="translated">결과는 거짓입니다).</target>
        </trans-unit>
        <trans-unit id="b06be03c9501d35691a73d29665e3b477dbd827b" translate="yes" xml:space="preserve">
          <source>the result will be the undefined value).</source>
          <target state="translated">결과는 정의되지 않은 값이됩니다).</target>
        </trans-unit>
        <trans-unit id="27760396d0989c824fad36d89d509e322049bf0f" translate="yes" xml:space="preserve">
          <source>the result will be this:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="367913a66fb3ed48526d213b1374566f40feb169" translate="yes" xml:space="preserve">
          <source>the result will be true).</source>
          <target state="translated">결과는 사실입니다).</target>
        </trans-unit>
        <trans-unit id="5be9ceecc2f03bc42e4d234aec808162f9c2f9d1" translate="yes" xml:space="preserve">
          <source>the result would be:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="241bdcd79cc64588f799c8af99318c6a86f527b4" translate="yes" xml:space="preserve">
          <source>the returned arrays look like this:</source>
          <target state="translated">반환 된 배열은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4b13e4f057405f08d33690de1235c5ad2d9163da" translate="yes" xml:space="preserve">
          <source>the right delimiter of the first block of the operation,</source>
          <target state="translated">연산의 첫 번째 블록의 오른쪽 구분 기호</target>
        </trans-unit>
        <trans-unit id="60b10a956ccb270d29db4fedcf97954e7d906c61" translate="yes" xml:space="preserve">
          <source>the right delimiter of the second block of the operation (if any),</source>
          <target state="translated">작업의 두 번째 블록의 오른쪽 구분 기호 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="ad88a8d6474f71e4dc65118e206ccce36d69c740" translate="yes" xml:space="preserve">
          <source>the right operand. That makes the order of the operands to the smartmatch operand often opposite that of the regular match operator. In other words, the &quot;smaller&quot; thing is usually placed in the left operand and the larger one in the right.</source>
          <target state="translated">올바른 피연산자. 이는 피연산자의 순서를 스마트 매치 피연산자에 대한 규칙으로 종종 정규 일치 연산자와 반대입니다. 다시 말해, &quot;더 작은&quot;것은 일반적으로 왼쪽 피연산자에, 큰 것은 오른쪽 피연산자에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="2cfb8735544da2f4a5ef7ac3c46c65d846bf586e" translate="yes" xml:space="preserve">
          <source>the run-time component of the &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; before those attributes will get applied. For example:</source>
          <target state="translated">해당 속성이 적용되기 전에 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 의 런타임 구성 요소 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6d94dd13fa0ce302453b0c13e41fb22167f72ae8" translate="yes" xml:space="preserve">
          <source>the same as</source>
          <target state="translated">와 동일</target>
        </trans-unit>
        <trans-unit id="4a54b07cf28d2bc23ffe3bae6be39ad94b599265" translate="yes" xml:space="preserve">
          <source>the same as deleting the first quote-like pattern. For instance, if &lt;code&gt;$text&lt;/code&gt; contained the string:</source>
          <target state="translated">첫 번째 따옴표와 같은 패턴을 삭제하는 것과 같습니다. 예를 들어 &lt;code&gt;$text&lt;/code&gt; 에 문자열이 포함 된 경우 :</target>
        </trans-unit>
        <trans-unit id="4469a15edc678368007d1292ad39f49f19322ee8" translate="yes" xml:space="preserve">
          <source>the same as other handles and so can be compared to other handles with C&amp;lt;==&amp;gt;.</source>
          <target state="translated">다른 핸들과 동일하므로 C &amp;lt;==&amp;gt; 인 다른 핸들과 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b5e2a5e0bc0ec284b2d2c3c088213d01cf46e05" translate="yes" xml:space="preserve">
          <source>the same as saying</source>
          <target state="translated">말하는 것과 동일</target>
        </trans-unit>
        <trans-unit id="bec4472defb167aab839db0f227cd83d65a998d5" translate="yes" xml:space="preserve">
          <source>the same as writing:</source>
          <target state="translated">글쓰기와 동일 :</target>
        </trans-unit>
        <trans-unit id="f928cb2e61789033643a88e1121c24fc6aa53ad7" translate="yes" xml:space="preserve">
          <source>the same thing as &lt;code&gt;$array-&amp;gt;[$x]&lt;/code&gt; here:</source>
          <target state="translated">&lt;code&gt;$array-&amp;gt;[$x]&lt;/code&gt; 와 같은 것 :</target>
        </trans-unit>
        <trans-unit id="7166971113169815fd6133fa5f7f6afb0631ef1f" translate="yes" xml:space="preserve">
          <source>the same way as a &lt;code&gt;(?{ code })&lt;/code&gt; code block as described above, except that its return value, rather than being assigned to &lt;code&gt;$^R&lt;/code&gt; , is treated as a pattern, compiled if it's a string (or used as-is if its a qr// object), then matched as if it were inserted instead of this construct.</source>
          <target state="translated">&lt;code&gt;$^R&lt;/code&gt; 에 할당되지 않고 리턴 값 이 패턴으로 취급 된다는 점을 제외하고는 위에서 설명한대로 &lt;code&gt;(?{ code })&lt;/code&gt; 코드 블록과 같은 방식으로 문자열 인 경우 컴파일되거나 그것의 qr // 객체), 그런 다음이 구문 대신 삽입 된 것처럼 일치합니다.</target>
        </trans-unit>
        <trans-unit id="e89f36e67616aec49128c0b99a888a103286f66b" translate="yes" xml:space="preserve">
          <source>the same. The behavior is nearly the same as well: as of version 2.15, &lt;code&gt;cp&lt;/code&gt; will preserve the source file's permission bits like the shell utility &lt;code&gt;cp(1)&lt;/code&gt; would do, while &lt;code&gt;copy&lt;/code&gt; uses the default permissions for the target file (which may depend on the process' &lt;code&gt;&lt;a href=&quot;../functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt;, file ownership, inherited ACLs, etc.). If an error occurs in setting permissions, &lt;code&gt;cp&lt;/code&gt; will return 0, regardless of whether the file was successfully copied.</source>
          <target state="translated">똑같다. 동작은 거의 동일합니다. 버전 2.15부터 &lt;code&gt;cp&lt;/code&gt; 는 쉘 유틸리티 &lt;code&gt;cp(1)&lt;/code&gt; 와 같이 소스 파일의 권한 비트를 유지 하지만 &lt;code&gt;copy&lt;/code&gt; 는 대상 파일의 기본 권한을 사용합니다 (프로세스에 따라 다름). ' &lt;code&gt;&lt;a href=&quot;../functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; , 파일 소유권, 상속 된 ACL 등). 권한 설정에 오류가 발생 하면 파일이 성공적으로 복사되었는지 여부에 관계없이 &lt;code&gt;cp&lt;/code&gt; 는 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bf9d556cf0621f4c68ec518e9dbcab9943fe668e" translate="yes" xml:space="preserve">
          <source>the same:</source>
          <target state="translated">똑같다:</target>
        </trans-unit>
        <trans-unit id="22e84aae25abedf582a9044f2441d71f8b951ea0" translate="yes" xml:space="preserve">
          <source>the scope of $answer extends from its declaration through the rest of that conditional, including any &lt;code&gt;elsif&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; clauses, but not beyond it. See &lt;a href=&quot;perlsyn#Simple-Statements&quot;&gt;Simple Statements in perlsyn&lt;/a&gt; for information on the scope of variables in statements with modifiers.</source>
          <target state="translated">$ answer의 범위는 선언에서 &lt;code&gt;elsif&lt;/code&gt; 및 &lt;code&gt;else&lt;/code&gt; 절을 포함한 나머지 조건부까지 확장 되지만 그 범위를 넘어서는 안됩니다. 수정자가있는 명령문의 변수 범위에 대한 정보 &lt;a href=&quot;perlsyn#Simple-Statements&quot;&gt;는 perlsyn의 단순 명령문을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="baa05056e9f40151df0cbff4c98ca1c83f4d8879" translate="yes" xml:space="preserve">
          <source>the scope of $i extends to the end of the loop, but not beyond it, rendering the value of $i inaccessible within &lt;code&gt;some_function()&lt;/code&gt; .</source>
          <target state="translated">$ i의 범위는 루프의 끝까지 확장되지만 그 이상은 아닙니다 . &lt;code&gt;some_function()&lt;/code&gt; 내에서 $ i의 값에 액세스 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0ea8f8d788deb7fb70a6641a871bdc6c17293aa9" translate="yes" xml:space="preserve">
          <source>the scope of $line extends from its declaration throughout the rest of the loop construct (including the &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; clause), but not beyond it. Similarly, in the conditional</source>
          <target state="translated">$ line의 범위는 선언에서 나머지 루프 구문 ( &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 절 포함) 전체에 걸쳐 있지만 그 범위를 넘어서는 안됩니다. 마찬가지로 조건부에서</target>
        </trans-unit>
        <trans-unit id="3f6957153140ae22aa9fb9f71b401aed8cd16dbb" translate="yes" xml:space="preserve">
          <source>the script</source>
          <target state="translated">스크립트</target>
        </trans-unit>
        <trans-unit id="7da89157d34955ad49945f6b9e381b3b8cdb2cc8" translate="yes" xml:space="preserve">
          <source>the script itself changes the current working directory (see &lt;a href=&quot;../functions/chdir&quot;&gt;chdir&lt;/a&gt;)</source>
          <target state="translated">스크립트 자체는 현재 작업 디렉토리를 변경합니다 ( &lt;a href=&quot;../functions/chdir&quot;&gt;chdir&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="449cd9f9078af9f79eb882318ecbc550b179c573" translate="yes" xml:space="preserve">
          <source>the script name does not contain a directory, then Perl translates the logical name DCL$PATH as a searchlist, using each translation as a directory in which to look for the script. In addition, if no file type is specified, Perl looks in each directory for a file matching the name specified, with a blank type, a type of</source>
          <target state="translated">스크립트 이름에 디렉토리가 없으면 Perl은 논리적 이름 DCL $ PATH를 검색 목록으로 변환하고 각 변환을 스크립트를 찾을 디렉토리로 사용합니다. 또한 파일 유형이 지정되지 않은 경우 Perl은 각 디렉토리에서 지정된 이름과 일치하는 파일을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="10c6aaa2aa56b4f5e5a61251f8e8a6475ffdd863" translate="yes" xml:space="preserve">
          <source>the second &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re&lt;/code&gt; does an implicit &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; re '/u'&lt;/code&gt; .</source>
          <target state="translated">두 번째 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re&lt;/code&gt; 는 암시 적 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; re '/u'&lt;/code&gt; 를 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="c8b60cf9d6b9393388855bd42dd0e785a9edbee2" translate="yes" xml:space="preserve">
          <source>the second time</source>
          <target state="translated">두 번째</target>
        </trans-unit>
        <trans-unit id="9004c8b4d7ed31914a23183d7f8197de30d808db" translate="yes" xml:space="preserve">
          <source>the smart match does</source>
          <target state="translated">스마트 매치는</target>
        </trans-unit>
        <trans-unit id="567e73c3060ea80a1dc0e2145bdf534f89c50aba" translate="yes" xml:space="preserve">
          <source>the specified dependencies with those declared by the package maintainer. In a future implementation this may be changed to override the original declaration.</source>
          <target state="translated">패키지 관리자에 의해 선언 된 것과의 의존성 향후 구현에서는 원래 선언을 무시하도록 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42c5a1faa14a0d961afee6ffbea9c14d7c74f8e9" translate="yes" xml:space="preserve">
          <source>the subroutine is not an XSUB (since &lt;code&gt;START&lt;/code&gt; and &lt;code&gt;ROOT&lt;/code&gt; are non-zero, and &lt;code&gt;XSUB&lt;/code&gt; is not listed, and is thus null);</source>
          <target state="translated">서브 루틴은 XSUB가 아닙니다 ( &lt;code&gt;START&lt;/code&gt; 및 &lt;code&gt;ROOT&lt;/code&gt; 가 0 이 아니므로 &lt;code&gt;XSUB&lt;/code&gt; 가 나열되지 않으므로 널임 ).</target>
        </trans-unit>
        <trans-unit id="10fe1ebc16aeab11a3ad827ebaddc82decca14de" translate="yes" xml:space="preserve">
          <source>the substring is also matched by an opposite (right or left) delimiter bracket</source>
          <target state="translated">하위 문자열은 반대 (오른쪽 또는 왼쪽) 구분 기호 대괄호와도 일치합니다.</target>
        </trans-unit>
        <trans-unit id="31843bb5ce90f38eb71cec4b5f5deffaacdc2b46" translate="yes" xml:space="preserve">
          <source>the taint-check warnings.</source>
          <target state="translated">오염 검사 경고.</target>
        </trans-unit>
        <trans-unit id="dcde512fbbc017dd10c0c524e289f30144aabb32" translate="yes" xml:space="preserve">
          <source>the target string is encoded in UTF-8; or</source>
          <target state="translated">대상 문자열은 UTF-8로 인코딩됩니다. 또는</target>
        </trans-unit>
        <trans-unit id="78afcfad97482e9240ebe12dabc194b0f2c3b3ec" translate="yes" xml:space="preserve">
          <source>the test, not</source>
          <target state="translated">테스트가 아닌</target>
        </trans-unit>
        <trans-unit id="2d6be7e9a29d2284e4a1c1d564d8757213f95f64" translate="yes" xml:space="preserve">
          <source>the text between the opening and closing tags</source>
          <target state="translated">여는 태그와 닫는 태그 사이의 텍스트</target>
        </trans-unit>
        <trans-unit id="a58d49e34d8f22b121d4886a9dee68a05b2211a0" translate="yes" xml:space="preserve">
          <source>the text of the first block of the operation (that is, the contents of a quote, the regex of a match or substitution or the target list of a translation),</source>
          <target state="translated">연산의 첫 번째 블록의 텍스트 (즉, 인용의 내용, 일치 또는 대체의 정규식 또는 번역의 대상 목록)</target>
        </trans-unit>
        <trans-unit id="f5cb25bf17d198d49f2635bab666ce500ee6f816" translate="yes" xml:space="preserve">
          <source>the text of the second block of the operation (that is, the replacement of a substitution or the translation list of a translation),</source>
          <target state="translated">오퍼레이션의 두 번째 블록의 텍스트 (즉, 대체 대체 또는 번역의 번역 목록)</target>
        </trans-unit>
        <trans-unit id="54e46f0757b022318bd5a239679cf0f1339e841d" translate="yes" xml:space="preserve">
          <source>the tied array will appear to contain &lt;code&gt;(&quot;Gold&quot;, &quot;Frankincense&quot;,
&quot;Myrrh&quot;)&lt;/code&gt; . If you set &lt;code&gt;autochomp&lt;/code&gt; to a false value, the record separator will not be removed. If the file above was tied with</source>
          <target state="translated">묶인 배열은 &lt;code&gt;(&quot;Gold&quot;, &quot;Frankincense&quot;, &quot;Myrrh&quot;)&lt;/code&gt; 를 포함하는 것으로 보입니다 . 를 설정하면 &lt;code&gt;autochomp&lt;/code&gt; 을 거짓 값으로, 레코드 분리는 제거되지 않습니다. 위 파일이 묶인 경우</target>
        </trans-unit>
        <trans-unit id="2fd283a094fc7f97781b054050f5816883290ed9" translate="yes" xml:space="preserve">
          <source>the trailing modifiers on the operation (if any).</source>
          <target state="translated">작업의 후행 수정 자 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="c2a06a77006eafdbaa9e871f0888edc9d2c95d03" translate="yes" xml:space="preserve">
          <source>the type specifier for files nor the name of the handle. It is the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator applied to the handle FILE. It reads one line (well, record--see &lt;a href=&quot;perlvar#%24%2f&quot;&gt;$/ in perlvar&lt;/a&gt;) from the handle FILE in scalar context, or</source>
          <target state="translated">파일의 타입 지정자 또는 핸들의 이름 그것은 인 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 핸들 FILE인가 연산자. 스칼라 컨텍스트의 핸들 FILE에서 한 줄 (음, 레코드 &lt;a href=&quot;perlvar#%24%2f&quot;&gt;-perlvar의 $ /&lt;/a&gt; 참조)을 읽 거나</target>
        </trans-unit>
        <trans-unit id="1c4360009fff54302b1156b6832fe5d026c5d637" translate="yes" xml:space="preserve">
          <source>the uncompressed data has been written to the output buffer - the size of &lt;code&gt;$output&lt;/code&gt; is unbounded.</source>
          <target state="translated">압축되지 않은 데이터가 출력 버퍼에 기록되었습니다 . &lt;code&gt;$output&lt;/code&gt; 의 크기 는 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="72c4cb01ed9c295c259e9012dc844c21ed4b9c75" translate="yes" xml:space="preserve">
          <source>the user will see something like this:</source>
          <target state="translated">사용자는 다음과 같은 것을 보게 될 것입니다 :</target>
        </trans-unit>
        <trans-unit id="09d1d1059ffc788eba4027840dd9c61844d867ea" translate="yes" xml:space="preserve">
          <source>the value for that key is true (since it's not 0 or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;), so the next skips that iteration and the loop goes to the next element.</source>
          <target state="translated">해당 키의 값은 true이므로 (0이 아니거나 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 이기 때문에) 다음은 해당 반복을 건너 뛰고 루프는 다음 요소로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="10f60af7d3da39c8283e440b7b68c1b0162b43c3" translate="yes" xml:space="preserve">
          <source>the value to format. Where an argument is specified by an explicit index, this does not affect the normal order for the arguments, even when the explicitly specified index would have been the next argument.</source>
          <target state="translated">형식화 할 값 명시 적 인덱스에 의해 인수가 지정되는 경우, 명시 적으로 지정된 인덱스가 다음 인수가 되더라도 인수의 정상적인 순서에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="98edb59e477d5f73aabed933ed88c199f2e02581" translate="yes" xml:space="preserve">
          <source>the way you want.</source>
          <target state="translated">당신이 원하는 방식으로.</target>
        </trans-unit>
        <trans-unit id="fb6fef64bdf2aef98be4e3412576b2eb3744b578" translate="yes" xml:space="preserve">
          <source>them if you start &lt;code&gt;perl__.exe&lt;/code&gt; from a PM program which emulates a console window, like</source>
          <target state="translated">콘솔 창을 에뮬레이트하는 PM 프로그램에서 &lt;code&gt;perl__.exe&lt;/code&gt; 를 시작하면</target>
        </trans-unit>
        <trans-unit id="6f8f8e9f767353d846d34ea5a451c83849c1b01b" translate="yes" xml:space="preserve">
          <source>then</source>
          <target state="translated">then</target>
        </trans-unit>
        <trans-unit id="88a7a77aa5c568f548a7b47a898fe68e7d901cc1" translate="yes" xml:space="preserve">
          <source>then $parser-&amp;gt;get_short_title on that document will return &quot;Hoo::Boy::Wowza&quot;.</source>
          <target state="translated">해당 문서의 $ parser-&amp;gt; get_short_title은 &quot;Hoo :: Boy :: Wowza&quot;를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="23f4cf92407a7fe5d8794a5c9a42f3e2ead3acdc" translate="yes" xml:space="preserve">
          <source>then $parser-&amp;gt;get_short_title on that document will return &quot;Hooboy, stuff wow yeah!&quot;. If the document starts with:</source>
          <target state="translated">해당 문서의 $ parser-&amp;gt; get_short_title은 &quot;Hooboy, stuff wow yeah!&quot;를 반환합니다. 문서가 다음으로 시작하는 경우 :</target>
        </trans-unit>
        <trans-unit id="29f40a8c4032e6fbcf21306bda70e2933fe3eafc" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; are &lt;code&gt;$main::a&lt;/code&gt; and &lt;code&gt;$main::b&lt;/code&gt; (or &lt;code&gt;$::a&lt;/code&gt; and &lt;code&gt;$::b&lt;/code&gt; ), but if you're in the &lt;code&gt;FooPack&lt;/code&gt; package, it's the same as typing</source>
          <target state="translated">다음 &lt;code&gt;$a&lt;/code&gt; 와 &lt;code&gt;$b&lt;/code&gt; 하다 &lt;code&gt;$main::a&lt;/code&gt; 와 &lt;code&gt;$main::b&lt;/code&gt; (또는 &lt;code&gt;$::a&lt;/code&gt; 및 &lt;code&gt;$::b&lt;/code&gt; ) 당신은에 있다면,하지만 &lt;code&gt;FooPack&lt;/code&gt; 의 패키지는 입력과 동일합니다</target>
        </trans-unit>
        <trans-unit id="d5a02d02cd5da551d503521fe8e892f975abdae4" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;$y&lt;/code&gt; is the number closest to zero, and with the same sign as &lt;code&gt;$mod&lt;/code&gt; , satisfying</source>
          <target state="translated">다음 &lt;code&gt;$y&lt;/code&gt; 숫자 제로에 가까운이며, 같은 기호 &lt;code&gt;$mod&lt;/code&gt; , 만족</target>
        </trans-unit>
        <trans-unit id="427cce61752fee17f0671abdaf38ee0fa428d694" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;%hash&lt;/code&gt; will have at least 200 buckets allocated for it--256 of them, in fact, since it rounds up to the next power of two. These buckets will be retained even if you do &lt;code&gt;%hash = ()&lt;/code&gt; , use &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;
%hash&lt;/code&gt; if you want to free the storage while &lt;code&gt;%hash&lt;/code&gt; is still in scope. You can't shrink the number of buckets allocated for the hash using &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; in this way (but you needn't worry about doing this by accident, as trying has no effect). &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; in an lvalue context is a syntax error.</source>
          <target state="translated">그러면 &lt;code&gt;%hash&lt;/code&gt; 는 적어도 200 개의 버킷을 할당 할 것입니다. 실제로 256 개는 다음 2의 거듭 제곱으로 올림되기 때문입니다. &lt;code&gt;%hash = ()&lt;/code&gt; 하더라도 이러한 버킷은 유지 되며, &lt;code&gt;%hash&lt;/code&gt; 가 여전히 범위에있는 동안 스토리지를 해제 하려면 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; %hash&lt;/code&gt; 를 사용하십시오 . 이런 방식으로 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 를 사용하여 해시에 할당 된 버킷 수를 줄일 수는 없습니다 (그러나 시도해도 아무런 효과가 없으므로 실수로이를 걱정할 필요는 없습니다). lvalue 컨텍스트의 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; @array 는 구문 오류입니다.</target>
        </trans-unit>
        <trans-unit id="0a4706c04d224c9ee392da7cf321cfda0cdbc86d" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;%hash&lt;/code&gt; will have at least 200 buckets allocated for it--256 of them, in fact, since it rounds up to the next power of two. These buckets will be retained even if you do &lt;code&gt;%hash = ()&lt;/code&gt; , use &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;
%hash&lt;/code&gt; if you want to free the storage while &lt;code&gt;%hash&lt;/code&gt; is still in scope. You can't shrink the number of buckets allocated for the hash using &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; in this way (but you needn't worry about doing this by accident, as trying has no effect). &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; in an lvalue context is a syntax error.</source>
          <target state="translated">그러면 &lt;code&gt;%hash&lt;/code&gt; 는 적어도 200 개의 버킷을 할당 할 것입니다. 실제로 256 개는 다음 2의 거듭 제곱으로 올림되기 때문입니다. &lt;code&gt;%hash = ()&lt;/code&gt; 하더라도 이러한 버킷은 유지 되며, &lt;code&gt;%hash&lt;/code&gt; 가 여전히 범위에있는 동안 스토리지를 해제 하려면 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt; %hash&lt;/code&gt; 를 사용하십시오 . 이런 방식으로 &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 를 사용하여 해시에 할당 된 버킷 수를 줄일 수는 없습니다 (그러나 시도해도 아무런 효과가 없으므로 실수로이를 걱정할 필요는 없습니다). lvalue 컨텍스트의 &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; @array 는 구문 오류입니다.</target>
        </trans-unit>
        <trans-unit id="e0e0f1b2564679b330f3326cd8ff2c67fa198367" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;&lt;a href=&quot;../functions/mkdir&quot;&gt;mkdir&lt;/a&gt;&lt;/code&gt; will attempt to create all the directories in the given path.</source>
          <target state="translated">다음 &lt;code&gt;&lt;a href=&quot;../functions/mkdir&quot;&gt;mkdir&lt;/a&gt;&lt;/code&gt; 주어진 경로에있는 모든 디렉토리를 작성하려고합니다.</target>
        </trans-unit>
        <trans-unit id="07f9429b97c09875ec099fb7f4d7f8efc6e3196e" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;&lt;a href=&quot;../functions/rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; will attempt to delete everything inside the directory.</source>
          <target state="translated">그러면 &lt;code&gt;&lt;a href=&quot;../functions/rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; 은 디렉토리 내의 모든 것을 삭제하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="be79a8197efa4a6581e5f87f07d768e642f44dc3" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt;. If you have a choice, it's better to lowercase things to avoid the problems of the two Latin-1 characters whose uppercase is outside Latin-1: &quot;&amp;yuml;&quot; (small &lt;code&gt;y WITH DIAERESIS&lt;/code&gt;) and &quot;&amp;micro;&quot; (&lt;code&gt;MICRO SIGN&lt;/code&gt; ). If you do need to upppercase, you can; with a Unicode-enabled Perl, do:</source>
          <target state="translated">그런 다음 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; . 당신은 선택의 여지가 있다면, 그것은 대문자 라틴-1 밖에 두 라틴 1 문자의 문제를 방지하는 일을 소문자로 더 나은 : &quot;Y&quot;(작은 &lt;code&gt;y WITH DIAERESIS&lt;/code&gt; ) 및 &quot;&amp;mu;&quot;( &lt;code&gt;MICRO SIGN&lt;/code&gt; ). 대문자를 사용해야 할 경우 가능합니다. 유니 코드 가능 Perl을 사용하여 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="c4df6b08143f1ed133e0751bce9a14ce00f15fee" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;mypush()&lt;/code&gt; takes arguments exactly like &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push()&lt;/a&gt;&lt;/code&gt; does.</source>
          <target state="translated">그런 다음 &lt;code&gt;mypush()&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push()&lt;/a&gt;&lt;/code&gt; 와 같은 인수를 취 합니다.</target>
        </trans-unit>
        <trans-unit id="d4963e7b580a13c7a47350916f5f4701a5cea5b0" translate="yes" xml:space="preserve">
          <source>then a call to &lt;code&gt;extract_bracketed&lt;/code&gt; in a list context:</source>
          <target state="translated">그런 다음 목록 컨텍스트에서 &lt;code&gt;extract_bracketed&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="8fa8d133f35b2e1ecd715f6ea92a4465b64cd21e" translate="yes" xml:space="preserve">
          <source>then a link to it would look like this:</source>
          <target state="translated">그런 다음 링크는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c2d9821598cc4028dc478ca6b184ee82c9a150e8" translate="yes" xml:space="preserve">
          <source>then a reference to an array containing the string &lt;code&gt;&quot;turn it up to 11, man!&quot;&lt;/code&gt; would be passed as the last argument.</source>
          <target state="translated">그런 다음 문자열을 포함하는 배열에 대한 참조는 &lt;code&gt;&quot;turn it up to 11, man!&quot;&lt;/code&gt; 마지막 인수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="daefb5fdb08ac51e4ca09289fd271c065db65227" translate="yes" xml:space="preserve">
          <source>then after the deletion it would contain:</source>
          <target state="translated">삭제 후에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="16a5f58b325c405e1b9bf68a059e0e8cba7507e5" translate="yes" xml:space="preserve">
          <source>then answer a few questions and go out for coffee (possibly even in a different city).</source>
          <target state="translated">그런 다음 몇 가지 질문에 대답하고 커피를 마시 러 가십시오 (아마 다른 도시에서도 가능).</target>
        </trans-unit>
        <trans-unit id="c864362dfe8b6f418c3b8afbb4438cb559f4ad66" translate="yes" xml:space="preserve">
          <source>then any bareword that would NOT be interpreted as a subroutine call produces a compile-time error instead. The restriction lasts to the end of the enclosing block. An inner block may countermand this by saying &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; strict 'subs'&lt;/code&gt; .</source>
          <target state="translated">서브 루틴 호출로 해석되지 않는 베어 워드는 대신 컴파일 타임 오류를 생성합니다. 제한은 둘러싸는 블록의 끝까지 지속됩니다. 이너 블록은 말을하지하여이를 취소 할 수있다 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; strict 'subs'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a6042bd89492effbfd5f6e8c4f5ed13a20bf888" translate="yes" xml:space="preserve">
          <source>then any variable mentioned from there to the end of the enclosing block must either refer to a lexical variable, be predeclared via &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; , or else must be fully qualified with the package name. A compilation error results otherwise. An inner block may countermand this with &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; strict 'vars'&lt;/code&gt; .</source>
          <target state="translated">다음 중 어휘 변수를 참조해야합니다 포함하는 블록의 끝까지 거기에서 언급 된 모든 변수를 통해 미리 선언 할 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; , 또는 다른 패키지 이름을 정규화해야합니다. 그렇지 않으면 컴파일 오류가 발생합니다. 내부 블록은 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; strict 'vars'&lt;/code&gt; &lt;a href=&quot;functions/no&quot;&gt;없이&lt;/a&gt; 이것을 막을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a57900be2b5fa8c20199347f883e5b7b3be9857" translate="yes" xml:space="preserve">
          <source>then call the appropriate routines, casting the returned &lt;code&gt;SV*&lt;/code&gt; to either an &lt;code&gt;AV*&lt;/code&gt; or &lt;code&gt;HV*&lt;/code&gt; , if required.</source>
          <target state="translated">그런 다음 필요한 경우 반환 된 &lt;code&gt;SV*&lt;/code&gt; 를 &lt;code&gt;AV*&lt;/code&gt; 또는 &lt;code&gt;HV*&lt;/code&gt; 로 캐스팅하여 적절한 루틴을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="42e84eb677476703d809f722b1ff2f0066df6dbd" translate="yes" xml:space="preserve">
          <source>then derived classes may (re-)inherit base-class methods through two or more distinct paths (e.g. in the way &lt;code&gt;E&lt;/code&gt; inherits &lt;code&gt;A::foo&lt;/code&gt; twice -- through &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt; ). In such cases, a sequence of &lt;code&gt;NEXT&lt;/code&gt; redispatches will invoke the multiply inherited method as many times as it is inherited. For example, the above code prints:</source>
          <target state="translated">파생 클래스는 두 개 이상의 고유 한 경로를 통해 기본 클래스 메소드를 (재 상속) 상속 할 수 있습니다 (예 : &lt;code&gt;E&lt;/code&gt; 가 &lt;code&gt;A::foo&lt;/code&gt; 두 번 상속 하는 방식으로 &lt;code&gt;C&lt;/code&gt; 와 &lt;code&gt;D&lt;/code&gt; 를 통해 ). 그러한 경우, 일련의 &lt;code&gt;NEXT&lt;/code&gt; 재발 포는 상속 된 메소드를 상속 된 횟수만큼 호출합니다. 예를 들어 위 코드는 다음과 같이 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="a614f37aaecfc8d29fe068560e973149cfa5cf7c" translate="yes" xml:space="preserve">
          <source>then here is the output</source>
          <target state="translated">다음은 출력입니다</target>
        </trans-unit>
        <trans-unit id="622feee1f62a60a311e5e227e74693233442f30c" translate="yes" xml:space="preserve">
          <source>then it would print:</source>
          <target state="translated">그런 다음 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="d3a00c98cd406c22e4b6f2f3ffd7a3f3467e5e23" translate="yes" xml:space="preserve">
          <source>then perl will recompile each time, even though the pattern string hasn't changed, to ensure that the current value of &lt;code&gt;$x&lt;/code&gt; is seen each time. Use &lt;code&gt;/o&lt;/code&gt; if you want to avoid this.</source>
          <target state="translated">그러면 perl은 패턴 문자열이 변경되지 않았어도 매번 &lt;code&gt;$x&lt;/code&gt; 의 현재 값을 볼 수 있도록 매번 다시 컴파일합니다 . 이것을 피 하려면 &lt;code&gt;/o&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="1c4f205545ab62b2b3e328d72a718521c54e0a64" translate="yes" xml:space="preserve">
          <source>then the &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; substitution will be performed silently.</source>
          <target state="translated">다음 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 교체를 자동으로 수행한다.</target>
        </trans-unit>
        <trans-unit id="3cbb088c80c134614593e2f6eee1e46c2fcede39" translate="yes" xml:space="preserve">
          <source>then the &lt;code&gt;@array&lt;/code&gt; would appear to have four elements:</source>
          <target state="translated">다음 &lt;code&gt;@array&lt;/code&gt; 는 네 가지 요소를 가지고 나타납니다 :</target>
        </trans-unit>
        <trans-unit id="51647320b30c0cdeeeedc259248ba22707613c81" translate="yes" xml:space="preserve">
          <source>then the array &lt;code&gt;@gifts&lt;/code&gt; would appear to contain &lt;code&gt;(&quot;Gold\n&quot;,
&quot;Frankincense\n&quot;, &quot;Myrrh\n&quot;)&lt;/code&gt; , or (on Win32 systems) &lt;code&gt;(&quot;Gold\r\n&quot;,
&quot;Frankincense\r\n&quot;, &quot;Myrrh\r\n&quot;)&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;@gifts&lt;/code&gt; 배열 에는 &lt;code&gt;(&quot;Gold\n&quot;, &quot;Frankincense\n&quot;, &quot;Myrrh\n&quot;)&lt;/code&gt; 또는 (Win32 시스템의 경우) &lt;code&gt;(&quot;Gold\r\n&quot;, &quot;Frankincense\r\n&quot;, &quot;Myrrh\r\n&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5705bd36756a8f0f099992bbd5c5e2309a6a622c" translate="yes" xml:space="preserve">
          <source>then the binary number may use '_' characters to separate digits.</source>
          <target state="translated">이진수는 '_'문자를 사용하여 숫자를 구분할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cbf74d1a22f4c12bb5419eef66a0debb65f9111" translate="yes" xml:space="preserve">
          <source>then the external</source>
          <target state="translated">그런 다음 외부</target>
        </trans-unit>
        <trans-unit id="dabfa7fd2b9ed457d1e61c46bf829f66a1b108f0" translate="yes" xml:space="preserve">
          <source>then the hex number may use '_' characters to separate digits.</source>
          <target state="translated">16 진수는 '_'문자를 사용하여 숫자를 구분할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b631c3c134aba1a964ce5976afb151eddc3f3c1b" translate="yes" xml:space="preserve">
          <source>then the octal number may use '_' characters to separate digits.</source>
          <target state="translated">8 진수는 '_'문자를 사용하여 숫자를 구분할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74fabb78efcde6da4ccf9db38ed749c11f7c9fa1" translate="yes" xml:space="preserve">
          <source>then the operation</source>
          <target state="translated">그런 다음 작업</target>
        </trans-unit>
        <trans-unit id="874355591d490dee5442696b955dde5b7234454e" translate="yes" xml:space="preserve">
          <source>then the output will be</source>
          <target state="translated">출력은</target>
        </trans-unit>
        <trans-unit id="045743d8f9d34f5f6f47ab4d7191f2b38f0e9606" translate="yes" xml:space="preserve">
          <source>then the sort operation provides list context for &amp;lt;&amp;gt;, which will proceed to read every line available up to the end of file, and pass that list of lines back to the sort routine, which will then sort those lines and return them as a list to whatever the context of the sort was.</source>
          <target state="translated">정렬 작업은 &amp;lt;&amp;gt;에 대한 목록 컨텍스트를 제공하여 파일 끝까지 사용 가능한 모든 행을 읽고 해당 행 목록을 정렬 루틴으로 다시 전달하여 해당 행을 정렬하여 목록으로 리턴합니다. 어떤 맥락에서든</target>
        </trans-unit>
        <trans-unit id="3009a9d43c2b1f0d7cb92e3fe3c04935627a9d8b" translate="yes" xml:space="preserve">
          <source>then there will be a problem later when the tarfile gets written out to disk via &lt;code&gt;$tar-&lt;/code&gt; write()&amp;gt;:</source>
          <target state="translated">tarfile이 &lt;code&gt;$tar-&lt;/code&gt; tar- write ()&amp;gt; 를 통해 디스크에 기록 될 때 나중에 문제가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="11f83d0fa9475f3a84586f0df189a5ef0cec1361" translate="yes" xml:space="preserve">
          <source>then use the following to get the package name itself:</source>
          <target state="translated">그런 다음 패키지 이름 자체를 얻으려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="be0d3cf429c3ee73a23ab767015fb8466fde14fb" translate="yes" xml:space="preserve">
          <source>then use this to access the &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; member</source>
          <target state="translated">그런 다음 이것을 사용하여 &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; 멤버 에 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="063029591eda4124365817de430c9e3536123f63" translate="yes" xml:space="preserve">
          <source>then would use an #ifdef guard.</source>
          <target state="translated">#ifdef 가드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bca9b0367ec1fa4243df295292555c374501f059" translate="yes" xml:space="preserve">
          <source>then you can do a non-blocking wait for all pending zombie processes. Non-blocking wait is available on machines supporting either the waitpid(2) or wait4(2) syscalls. However, waiting for a particular pid with FLAGS of &lt;code&gt;0&lt;/code&gt; is implemented everywhere. (Perl emulates the system call by remembering the status values of processes that have exited but have not been harvested by the Perl script yet.)</source>
          <target state="translated">그런 다음 보류중인 모든 좀비 프로세스에 대해 비 차단 대기를 수행 할 수 있습니다. 비 블로킹 대기는 waitpid (2) 또는 wait4 (2) 시스템 콜을 지원하는 시스템에서 사용 가능합니다. 그러나 FLAGS가 &lt;code&gt;0&lt;/code&gt; 인 특정 pid를 기다리는 것은 모든 곳에서 구현됩니다. Perl은 종료되었지만 아직 Perl 스크립트에 의해 수집되지 않은 프로세스의 상태 값을 기억하여 시스템 호출을 에뮬레이트합니다.</target>
        </trans-unit>
        <trans-unit id="24e3673901b12a352e45bfe1a29cd357600f2223" translate="yes" xml:space="preserve">
          <source>then you must make sure that your &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine appears before that &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement.</source>
          <target state="translated">그런 다음 해당 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 문 앞에 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 서브 루틴이 나타나는지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fbcfd002f79bf258f39d2d725e545e20557407da" translate="yes" xml:space="preserve">
          <source>then you would configure CPAN.pm with the command</source>
          <target state="translated">그런 다음 명령을 사용하여 CPAN.pm을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="fb0a1fd2595bcd62801102e76923b7858beb8c22" translate="yes" xml:space="preserve">
          <source>then your LIBPATH does not have the location of libperl.x and either libperl.dll or libperl.so in it. Add that directory to your LIBPATH and proceed.</source>
          <target state="translated">그런 다음 LIBPATH에는 libperl.x 및 libperl.dll 또는 libperl.so의 위치가 없습니다. 해당 디렉토리를 LIBPATH에 추가하고 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="3d3083ee3ba5313a634dabd04c969303606edcbb" translate="yes" xml:space="preserve">
          <source>then your PWD environment variable will be kept up to date. Note that it will only be kept up to date if all packages which use chdir import it from Cwd.</source>
          <target state="translated">그러면 PWD 환경 변수가 최신 상태로 유지됩니다. chdir을 사용하는 모든 패키지가 Cwd에서 가져 오는 경우에만 최신 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="b677073f08588ee6a96aff7b9290e34f7f2c31d3" translate="yes" xml:space="preserve">
          <source>then your script will run without human intervention, putting trace information into the file</source>
          <target state="translated">그러면 스크립트는 사람의 개입없이 실행되어 추적 정보를 파일에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="fdc01276daa17eba9f35c662cb1e1a3ce12fc436" translate="yes" xml:space="preserve">
          <source>there's more than one way to do it</source>
          <target state="translated">그것을 할 수있는 여러 가지 방법이 있습니다</target>
        </trans-unit>
        <trans-unit id="1460929c0c47b645e55308f3833bf025fb32ab4f" translate="yes" xml:space="preserve">
          <source>there.</source>
          <target state="translated">there.</target>
        </trans-unit>
        <trans-unit id="8c5900f2075a21520e816c3509bd71ab5f03dcb9" translate="yes" xml:space="preserve">
          <source>thereby giving the user automatic anonymous login to machines not specified in .netrc.</source>
          <target state="translated">따라서 .netrc에 지정되지 않은 컴퓨터에 자동 익명 로그인을 사용자에게 제공합니다.</target>
        </trans-unit>
        <trans-unit id="844a579d2ac78e752d68592ad05f19175c7d315a" translate="yes" xml:space="preserve">
          <source>these EMX functions do not work if the path contains a trailing &lt;code&gt;/&lt;/code&gt;. Perl contains a workaround for this.</source>
          <target state="translated">경로에 후행 &lt;code&gt;/&lt;/code&gt; 가 포함 된 경우 이러한 EMX 기능이 작동하지 않습니다 . Perl에는 이에 대한 해결 방법이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f140f5b64c2fb4e240cd7cafc5e3b9a858bd13a" translate="yes" xml:space="preserve">
          <source>these days.</source>
          <target state="translated">요즈음.</target>
        </trans-unit>
        <trans-unit id="f24426b9ff82a9ecca01636f4317d4a7fdba1697" translate="yes" xml:space="preserve">
          <source>theta</source>
          <target state="translated">theta</target>
        </trans-unit>
        <trans-unit id="f9076a004ebe7521f2460d54a3606de78e10e9f7" translate="yes" xml:space="preserve">
          <source>they would get the default imports without overrides.</source>
          <target state="translated">재정의없이 기본 가져 오기를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="a3381da6627be60591dc894ff1000a09075d2a79" translate="yes" xml:space="preserve">
          <source>they'll be politely informed that</source>
          <target state="translated">그들은 정중하게</target>
        </trans-unit>
        <trans-unit id="a5409d55c4a06a27b55a5136e1dec7d1ae0285e0" translate="yes" xml:space="preserve">
          <source>things. The effective gid is the group that's</source>
          <target state="translated">소지품. 효과적인 gid는</target>
        </trans-unit>
        <trans-unit id="7d80d88438d6ad166c5f496a3372a4f27aea9bcf" translate="yes" xml:space="preserve">
          <source>things. The real gid is the group you</source>
          <target state="translated">소지품. 진짜 여자는 당신이 그룹입니다</target>
        </trans-unit>
        <trans-unit id="c2543fff3bfa6f144c2f06a7de6cd10c0b650cae" translate="yes" xml:space="preserve">
          <source>this</source>
          <target state="translated">this</target>
        </trans-unit>
        <trans-unit id="79df13086927aaa527620acac1e6650e2085d774" translate="yes" xml:space="preserve">
          <source>this TODO</source>
          <target state="translated">이 TODO</target>
        </trans-unit>
        <trans-unit id="852fdaa8c7ce7f8e6638658e6c5843489c4652e6" translate="yes" xml:space="preserve">
          <source>this code could and probably should be written as</source>
          <target state="translated">이 코드는 다음과 같이 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="547fc135c0c908d9b4b5f50835f5c52b636693d6" translate="yes" xml:space="preserve">
          <source>this has the advantage of being backward compatible with how such things have had to be coded on some platforms for years.</source>
          <target state="translated">이것은 몇 년 동안 일부 플랫폼에서 그러한 것들을 어떻게 코딩해야했는지와 역 호환되는 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ab21a1ad37e0d8f33b9d32fccefe0d0f9927964" translate="yes" xml:space="preserve">
          <source>this last step may or may not require UID=0 privileges depending on how you answered the questions that Configure asked and whether or not you have write access to the directories you specified.</source>
          <target state="translated">이 마지막 단계는 Configure 질문에 응답 한 방법 및 지정한 디렉토리에 대한 쓰기 권한이 있는지 여부에 따라 UID = 0 권한을 요구하거나 요구하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7030489b8bb3c6a1f199877396c1b8f99049140" translate="yes" xml:space="preserve">
          <source>this value. In fact this value may be inspected in debugger (see &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;), but only if &lt;code&gt;bareStringify&lt;/code&gt;&lt;b&gt;O&lt;/b&gt;ption is set, and not via &lt;code&gt;p&lt;/code&gt; command.</source>
          <target state="translated">이 값. 실제로이 값은 디버거에서 검사 할 수 있지만 ( &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt; 참조 ) &lt;code&gt;bareStringify&lt;/code&gt; &lt;b&gt;O &lt;/b&gt;ption 이 설정되어 있고 &lt;code&gt;p&lt;/code&gt; 명령이 아닌 경우에만 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="d54ca3cc20a62b1a149415f45240c3a04f288da6" translate="yes" xml:space="preserve">
          <source>this will attempt to remove '/usr' from the front of the $MM-&amp;gt;{INSTALLMAN1DIR} path (initializing it to $Config{installman1dir} if necessary) and replace it with '/home/foo'. If this fails it will simply use '/home/foo/man/man1'.</source>
          <target state="translated">$ MM-&amp;gt; {INSTALLMAN1DIR} 경로 앞부분에서 '/ usr'을 제거하고 (필요한 경우 $ Config {installman1dir}로 초기화) '/ home / foo'로 대체합니다. 이것이 실패하면 단순히 '/ home / foo / man / man1'을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="cf99bf2a32d5b6c5bb486fc0e533a4767bda09be" translate="yes" xml:space="preserve">
          <source>thoroughly before using it to submit a bug report.</source>
          <target state="translated">버그 보고서를 제출하는 데 사용하기 전에 철저히 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="9f70a3b0dfe456892cdf57582747cdf3a63728a5" translate="yes" xml:space="preserve">
          <source>those loaded by the base name from &lt;code&gt;LIBPATH&lt;/code&gt; ; including those associated at link time;</source>
          <target state="translated">&lt;code&gt;LIBPATH&lt;/code&gt; 에서 기본 이름으로로드 된 것 ; 링크 타임에 관련된 것들을 포함하는 것;</target>
        </trans-unit>
        <trans-unit id="524cd37ee4c7405f7efcc0020d541eb55192c55c" translate="yes" xml:space="preserve">
          <source>though the use of these constructs during run-time is questionable.</source>
          <target state="translated">런타임 동안 이러한 구문의 사용은 의문의 여지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebb820ea5438310928a21485a7027cfe032626d2" translate="yes" xml:space="preserve">
          <source>thread and one or more</source>
          <target state="translated">실과 하나 이상</target>
        </trans-unit>
        <trans-unit id="be00c0bf8bd61a841d302e53df235310f4c7c683" translate="yes" xml:space="preserve">
          <source>thread associated with the specified thread ID. If &lt;code&gt;$tid&lt;/code&gt; is the value for the current thread, then this call works the same as &lt;code&gt;-&amp;gt;self()&lt;/code&gt; . Otherwise, returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if there is no thread associated with the TID, if the thread is joined or detached, if no TID is specified or if the specified TID is undef.</source>
          <target state="translated">지정된 스레드 ID와 연관된 스레드 경우 &lt;code&gt;$tid&lt;/code&gt; 현재의 thread 값입니다,이 호출과 동일하게 작동 &lt;code&gt;-&amp;gt;self()&lt;/code&gt; . 그렇지 않으면, TID와 연관된 스레드가 없거나 스레드가 결합 또는 분리 된 경우, TID가 지정되지 않았거나 지정된 TID가 정의되지 않은 경우 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="2b1aaf78f7385dec07cce860bf6f1ce1534ad089" translate="yes" xml:space="preserve">
          <source>thread exits, then this warning cannot be suppressed using &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'threads';&lt;/code&gt; as suggested below.</source>
          <target state="translated">스레드가 종료가,이 경고는 사용을 억제 할 수 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'threads';&lt;/code&gt; 아래 제안 된대로.</target>
        </trans-unit>
        <trans-unit id="df2e34e3cdb0a60c4d04443ed90e706147fd9b35" translate="yes" xml:space="preserve">
          <source>thread is unaffected by this call.</source>
          <target state="translated">스레드는이 호출의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1ba2970dd88ad4b4e72572ffdf22c1deb7f60a35" translate="yes" xml:space="preserve">
          <source>thread is unaffected by this setting.</source>
          <target state="translated">스레드는이 설정의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dc0153b46f92c9aa69c2610e01a4d11d889157f9" translate="yes" xml:space="preserve">
          <source>thread safe when using the older (experimental and now obsolete) threads implementation that was added to Perl 5.005.</source>
          <target state="translated">Perl 5.005에 추가 된 구형 (실험적이면서 현재는 사용되지 않는) 스레드 구현을 사용할 때 스레드 안전.</target>
        </trans-unit>
        <trans-unit id="065606106bace6e1bb589c52e0923b46b92fe690" translate="yes" xml:space="preserve">
          <source>thread support</source>
          <target state="translated">스레드 지원</target>
        </trans-unit>
        <trans-unit id="d67afc3417d4958f3ed82fd0be1bd179bac68b33" translate="yes" xml:space="preserve">
          <source>thread yield</source>
          <target state="translated">스레드 수율</target>
        </trans-unit>
        <trans-unit id="f021c519858ead3d56da5875f6a26d3e07030faa" translate="yes" xml:space="preserve">
          <source>thread, this behaves the same as &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit(0)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">thread, 이것은 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit(0)&lt;/a&gt;&lt;/code&gt; 과 동일하게 동작합니다 .</target>
        </trans-unit>
        <trans-unit id="7a6089c4861a7d61af8bfceb243bdda56ad1f409" translate="yes" xml:space="preserve">
          <source>thread, this behaves the same as &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit(status)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">thread, 이것은 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit(status)&lt;/a&gt;&lt;/code&gt; 와 동일하게 동작합니다 .</target>
        </trans-unit>
        <trans-unit id="29c60465c379bf1644566a78609304cb3aa69b61" translate="yes" xml:space="preserve">
          <source>thread, try modifying your application so that the module is loaded (again using &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;-&amp;gt;import()&lt;/code&gt; ) after any threads are started, and in such a way that no other threads are started afterwards.</source>
          <target state="translated">스레드가 시작되면 스레드가 시작된 후 모듈이로드되도록 ( 그리고 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;-&amp;gt;import()&lt;/code&gt; 사용하여 ) 나중에 다른 스레드가 시작되지 않도록 응용 프로그램을 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e92998455c09ed4e96524633947d3882bf21535" translate="yes" xml:space="preserve">
          <source>thread-safe</source>
          <target state="translated">thread-safe</target>
        </trans-unit>
        <trans-unit id="322b4598be3f1d250c204de6245d6c3281828f5e" translate="yes" xml:space="preserve">
          <source>thread. In other words, changes made to &lt;code&gt;%ENV&lt;/code&gt; in a thread will not be visible in</source>
          <target state="translated">실. 즉, 스레드에서 &lt;code&gt;%ENV&lt;/code&gt; 에 대한 변경 사항은</target>
        </trans-unit>
        <trans-unit id="c91e11a1f2a2f6f290fe5039f78f07f318049442" translate="yes" xml:space="preserve">
          <source>threads</source>
          <target state="translated">threads</target>
        </trans-unit>
        <trans-unit id="d87386329ab23fe84cf857fa28d7406622a9a3cb" translate="yes" xml:space="preserve">
          <source>threads - Perl interpreter-based threads</source>
          <target state="translated">스레드-Perl 인터프리터 기반 스레드</target>
        </trans-unit>
        <trans-unit id="64cc47f9346b8151a8e1bff1bf7a7575d5c6a720" translate="yes" xml:space="preserve">
          <source>threads is released under the same license as Perl.</source>
          <target state="translated">스레드는 Perl과 동일한 라이센스로 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="0845f72ee5a4a2716804978863f8393b6a1597f6" translate="yes" xml:space="preserve">
          <source>threads while there are still existing</source>
          <target state="translated">여전히 존재하는 동안 스레드</target>
        </trans-unit>
        <trans-unit id="b496a5f4b694561f23d5585cda62ccf1df1b03ee" translate="yes" xml:space="preserve">
          <source>threads-&amp;gt;wantarray()</source>
          <target state="translated">threads-&amp;gt;wantarray()</target>
        </trans-unit>
        <trans-unit id="3e03e1e2552cb929142ffa79d30112ff5706e673" translate="yes" xml:space="preserve">
          <source>threads.</source>
          <target state="translated">threads.</target>
        </trans-unit>
        <trans-unit id="f7f5cb25f9bc9773be646466ec1376299a475b0d" translate="yes" xml:space="preserve">
          <source>threads. The boss thread gathers or generates tasks that need to be done, then parcels those tasks out to the appropriate worker thread.</source>
          <target state="translated">스레드. 보스 스레드는 수행해야 할 작업을 수집하거나 생성 한 다음 해당 작업을 적절한 작업자 스레드로 소포합니다.</target>
        </trans-unit>
        <trans-unit id="d5a02881a442580d4c3de9e92a5357a1d6618663" translate="yes" xml:space="preserve">
          <source>threads.pm</source>
          <target state="translated">threads.pm</target>
        </trans-unit>
        <trans-unit id="74b6e8e1e1109a88c34e023c749582b0ed7d1e40" translate="yes" xml:space="preserve">
          <source>threads.xs</source>
          <target state="translated">threads.xs</target>
        </trans-unit>
        <trans-unit id="2faa69fbc196ece0d11da3fece8bb8cb4878a304" translate="yes" xml:space="preserve">
          <source>threads::shared</source>
          <target state="translated">threads::shared</target>
        </trans-unit>
        <trans-unit id="09e213c9ca6e90ca64b57886a4b8e0006db860c7" translate="yes" xml:space="preserve">
          <source>threads::shared - Perl extension for sharing data structures between threads</source>
          <target state="translated">threads :: shared-스레드간에 데이터 구조를 공유하기위한 Perl 확장</target>
        </trans-unit>
        <trans-unit id="a8527497cd0587a8b9759bc72fbec2309abe6a87" translate="yes" xml:space="preserve">
          <source>threads::shared is released under the same license as Perl.</source>
          <target state="translated">threads :: shared은 Perl과 동일한 라이센스에 따라 릴리스됩니다.</target>
        </trans-unit>
        <trans-unit id="ee06316257bae7813945d7b7cd55387706b32fcf" translate="yes" xml:space="preserve">
          <source>three-argument</source>
          <target state="translated">three-argument</target>
        </trans-unit>
        <trans-unit id="48f476deb04384be740b2036dcbe7970821de566" translate="yes" xml:space="preserve">
          <source>through a microscope. (Also known as &lt;b&gt;static scoping&lt;/b&gt;, because dictionaries don&amp;rsquo;t change very fast.) Similarly, looking at variables stored in a private dictionary (namespace) for each scope, which are visible only from their point of declaration down to the end of the lexical scope in which they are declared. &amp;mdash;Syn. &lt;b&gt;static scoping&lt;/b&gt;. &amp;mdash;Ant. &lt;b&gt;dynamic scoping&lt;/b&gt;.</source>
          <target state="translated">현미경을 통해. ( 사전은 매우 빠르게 변하지 않기 때문에 &lt;b&gt;정적 범위&lt;/b&gt; 라고도합니다 .) 마찬가지로 각 범위에 대한 개인 사전 (네임 스페이스)에 저장된 변수를 보면 선언 지점부터 어휘 끝까지 만 볼 수 있습니다. 그들이 선언 된 범위. -신. &lt;b&gt;정적 범위&lt;/b&gt; . -개미. &lt;b&gt;동적 범위 지정&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="7d093729d13d411c553442c16ac6b1f0df0bcc0c" translate="yes" xml:space="preserve">
          <source>tical</source>
          <target state="translated">tical</target>
        </trans-unit>
        <trans-unit id="d2aac84308e80b4fb63b151dc37c7c4a2e32fe22" translate="yes" xml:space="preserve">
          <source>tie</source>
          <target state="translated">tie</target>
        </trans-unit>
        <trans-unit id="b4e33c910b4e7eb71286c936a6c361332078399f" translate="yes" xml:space="preserve">
          <source>tie VARIABLE,CLASSNAME,LIST</source>
          <target state="translated">VARIABLE, CLASSNAME, LIST 넥타이</target>
        </trans-unit>
        <trans-unit id="e4928b42c73f84e34a4cbffbf2834087ad0cee19" translate="yes" xml:space="preserve">
          <source>tied</source>
          <target state="translated">tied</target>
        </trans-unit>
        <trans-unit id="df86b3e8a462b28b236db851a750887038103f20" translate="yes" xml:space="preserve">
          <source>tied VARIABLE</source>
          <target state="translated">묶인 변수</target>
        </trans-unit>
        <trans-unit id="714eea0f4c980736bde0065fe73f573487f08e3a" translate="yes" xml:space="preserve">
          <source>time</source>
          <target state="translated">time</target>
        </trans-unit>
        <trans-unit id="09ac2572253aca925ef88ce7e1e28523c07089a9" translate="yes" xml:space="preserve">
          <source>time it extracts a</source>
          <target state="translated">추출 시간</target>
        </trans-unit>
        <trans-unit id="07286d112af431ae059ec72f379797b0649ee105" translate="yes" xml:space="preserve">
          <source>time.h</source>
          <target state="translated">time.h</target>
        </trans-unit>
        <trans-unit id="0fa9094ae420cc07dd72cc2146bd0ac470eb7764" translate="yes" xml:space="preserve">
          <source>time_size.U</source>
          <target state="translated">time_size.U</target>
        </trans-unit>
        <trans-unit id="f5cce0aae7b188c70da27428d158685b039f43e7" translate="yes" xml:space="preserve">
          <source>timeit - run a chunk of code and see how long it goes</source>
          <target state="translated">timeit-코드 덩어리를 실행하고 시간이 얼마나 걸리는지 확인하십시오</target>
        </trans-unit>
        <trans-unit id="954670b8c73f5c7bb2168e45afdf2a0fb1c32f04" translate="yes" xml:space="preserve">
          <source>timelocal() and timegm()</source>
          <target state="translated">timelocal () 및 timegm ()</target>
        </trans-unit>
        <trans-unit id="5dd09c96f8b5aa673fdf3f282372ee443a332317" translate="yes" xml:space="preserve">
          <source>timelocal_nocheck() and timegm_nocheck()</source>
          <target state="translated">timelocal_nocheck () 및 timegm_nocheck ()</target>
        </trans-unit>
        <trans-unit id="7196b5875f713c826bd279dbda843c897e2a60c2" translate="yes" xml:space="preserve">
          <source>times</source>
          <target state="translated">times</target>
        </trans-unit>
        <trans-unit id="be23d236f3757f152a1f24f600012c1e1d600a93" translate="yes" xml:space="preserve">
          <source>times). Any attempt to sleep for X seconds will most probably end up sleeping &lt;b&gt;more&lt;/b&gt; than that, but don't be surprised if you end up sleeping slightly &lt;b&gt;less&lt;/b&gt;.</source>
          <target state="translated">타임스). X 초 동안 잠을 자려고 시도하면 아마도 &lt;b&gt;그보다 더&lt;/b&gt; 많이 잠을 자게 될 것입니다. 그러나 잠을 &lt;b&gt;적게&lt;/b&gt; 자더라도 놀라지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="3019ee89018972ae13827b09b3ebf41868413d56" translate="yes" xml:space="preserve">
          <source>timethese - run several chunks of code several times</source>
          <target state="translated">timethese-여러 덩어리의 코드를 여러 번 실행</target>
        </trans-unit>
        <trans-unit id="926b35fe102bbad8d28cfd9994879a682f7cc677" translate="yes" xml:space="preserve">
          <source>timethis - run a chunk of code several times</source>
          <target state="translated">timethis-코드 덩어리를 여러 번 실행</target>
        </trans-unit>
        <trans-unit id="3c6de1b7dd91465d437ef415f94f36afc1fbc8a8" translate="yes" xml:space="preserve">
          <source>title</source>
          <target state="translated">title</target>
        </trans-unit>
        <trans-unit id="79f74fe9e99b6f6214a6214ba235a7cd2a04e0fd" translate="yes" xml:space="preserve">
          <source>title_postfix</source>
          <target state="translated">title_postfix</target>
        </trans-unit>
        <trans-unit id="667355ec302a4f025bcf6e8ed2687c08bee45df9" translate="yes" xml:space="preserve">
          <source>title_prefix</source>
          <target state="translated">title_prefix</target>
        </trans-unit>
        <trans-unit id="7d41631407b52413c97b7d1100dc6276733f6fbb" translate="yes" xml:space="preserve">
          <source>title_prefix, title_postfix</source>
          <target state="translated">title_prefix, title_postfix</target>
        </trans-unit>
        <trans-unit id="11a6a2b3d697cfef5e657a3e04cbf393218a9c74" translate="yes" xml:space="preserve">
          <source>tkpod</source>
          <target state="translated">tkpod</target>
        </trans-unit>
        <trans-unit id="d515a572ec8566ae3c51d8bbe24ee44fc7ce67ea" translate="yes" xml:space="preserve">
          <source>tmon.out</source>
          <target state="translated">tmon.out</target>
        </trans-unit>
        <trans-unit id="7856988903cb6f9b1e8c44315fcc780abf2cd6b2" translate="yes" xml:space="preserve">
          <source>tmpfile</source>
          <target state="translated">tmpfile</target>
        </trans-unit>
        <trans-unit id="efa1858ae39d33be07d0ea70cf91a0217532af0d" translate="yes" xml:space="preserve">
          <source>tmpfile=/tmp/bison.$$.y echo %pure_parser &amp;gt; $tmpfile cat $1&amp;gt;&amp;gt; $tmpfile</source>
          <target state="translated">tmpfile = / tmp / bison. $$. y echo % pure_parser&amp;gt; $ tmpfile cat $ 1 &amp;gt;&amp;gt; $ tmpfile</target>
        </trans-unit>
        <trans-unit id="f67b82204486a97f18d5668c8a238d5eb98d90cc" translate="yes" xml:space="preserve">
          <source>tmptype</source>
          <target state="translated">tmptype</target>
        </trans-unit>
        <trans-unit id="4374aaee247fb237ce6c97d5c8d64bbe474d16de" translate="yes" xml:space="preserve">
          <source>to</source>
          <target state="translated">to</target>
        </trans-unit>
        <trans-unit id="185a97a9a27d738e3e05a1447711e0289b354cc0" translate="yes" xml:space="preserve">
          <source>to 0 if &lt;code&gt;SvOOK(sv)&lt;/code&gt; is false.</source>
          <target state="translated">&lt;code&gt;SvOOK(sv)&lt;/code&gt; 가 false 이면 0으로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="a7a8440a5b466b35a00b7232359b592f1e66aaab" translate="yes" xml:space="preserve">
          <source>to 0 when it calls your function - the parameter is provided to allow your implementation to track depth if it needs to recurse.</source>
          <target state="translated">함수를 호출 할 때 0으로 설정-매개 변수가 제공되어 재귀가 필요한 경우 구현에서 깊이를 추적 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea2a29e8310cf767872af505eeae2dea9e6cd141" translate="yes" xml:space="preserve">
          <source>to &lt;code&gt;LIBPATH&lt;/code&gt; (here for Perl DLL</source>
          <target state="translated">에 &lt;code&gt;LIBPATH&lt;/code&gt; 여기에 펄 DLL에 대한 (</target>
        </trans-unit>
        <trans-unit id="267663db9589a3745d5aef238877fd9533c61f70" translate="yes" xml:space="preserve">
          <source>to &lt;code&gt;Moose&lt;/code&gt; , meaning you can switch from &lt;code&gt;Moo&lt;/code&gt; to &lt;code&gt;Moose&lt;/code&gt; quite easily.</source>
          <target state="translated">에 &lt;code&gt;Moose&lt;/code&gt; , 당신은 전환 할 수 있습니다 의미 &lt;code&gt;Moo&lt;/code&gt; 에 &lt;code&gt;Moose&lt;/code&gt; 아주 쉽게.</target>
        </trans-unit>
        <trans-unit id="25de92114260dd84a38a4dd129b16fa441223f76" translate="yes" xml:space="preserve">
          <source>to &lt;code&gt;hv_common()&lt;/code&gt; .</source>
          <target state="translated">에 &lt;code&gt;hv_common()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d86da4acbcdf14e86c5caa9f3ed9dcbc5be77df" translate="yes" xml:space="preserve">
          <source>to EXPR1 only (which might itself be a higher-precedence AND operator, for example, and thus subject to the previous rule), not to EXPR2. If EXPR1 is to use smartmatching, then EXPR2 also does so, no matter what EXPR2 contains. But if EXPR2 does not get to use smartmatching, then the second argument will not be either. This is quite different from the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; case just described, so be careful.</source>
          <target state="translated">EXPR1이 아닌 EXPR1에만 해당됩니다 (예 : 우선 순위가 높은 AND 연산자 일 수 있으며 따라서 이전 규칙의 적용을 받음). EXPR1이 스마트 매칭을 사용하는 경우 EXPR2에 포함 된 내용에 관계없이 EXPR2도 그렇게합니다. 그러나 EXPR2가 스마트 매칭을 사용하지 않으면 두 번째 인수도 마찬가지입니다. 이것은 방금 설명한 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 사례 와는 매우 다르 므로주의하십시오.</target>
        </trans-unit>
        <trans-unit id="6154e47cbb357e834cd236e827be6a1934f7b9d2" translate="yes" xml:space="preserve">
          <source>to Encode canonical encoding name.</source>
          <target state="translated">표준 인코딩 이름을 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="ddbb5ed60cafc5157e96fb7243d2b67c73cd14b3" translate="yes" xml:space="preserve">
          <source>to GetOptions(). For each option that is specified on the command line, the option value will be stored in the hash with the option name as key. Options that are not actually used on the command line will not be put in the hash, on other words, &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists($h{option})&lt;/a&gt;&lt;/code&gt; (or defined()) can be used to test if an option was used. The drawback is that warnings will be issued if the program runs under &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; and uses &lt;code&gt;$h{option}&lt;/code&gt; without testing with exists() or defined() first.</source>
          <target state="translated">GetOptions (). 명령 행에 지정된 각 옵션에 대해 옵션 값은 옵션 이름을 키로 해시에 저장됩니다. 실제로 명령 행에서 사용되지 않는 옵션은 해시에 넣지 않습니다. 즉, &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists($h{option})&lt;/a&gt;&lt;/code&gt; (또는 defined ())를 사용하여 옵션이 사용되었는지 테스트 할 수 있습니다. 단점은 경고가 프로그램이 실행되는 경우에 따라 발행 될 것입니다 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; 하고 사용 &lt;code&gt;$h{option}&lt;/code&gt; 첫번째) (() 또는 정의 된 존재로 테스트하지 않고.</target>
        </trans-unit>
        <trans-unit id="bfed2d9357f25a5be1ef229590525d9382ab9044" translate="yes" xml:space="preserve">
          <source>to POSITION; &lt;code&gt;1&lt;/code&gt; to set it to the current position plus POSITION; and &lt;code&gt;2&lt;/code&gt; to set it to EOF plus POSITION, typically negative. For WHENCE you may use the constants &lt;code&gt;SEEK_SET&lt;/code&gt; , &lt;code&gt;SEEK_CUR&lt;/code&gt; , and &lt;code&gt;SEEK_END&lt;/code&gt; (start of the file, current position, end of the file) from the &lt;a href=&quot;../fcntl&quot;&gt;Fcntl&lt;/a&gt; module. Returns &lt;code&gt;1&lt;/code&gt; on success, false otherwise.</source>
          <target state="translated">위치에; &lt;code&gt;1&lt;/code&gt; 을 현재 위치 + POSITION으로 설정합니다. 과 &lt;code&gt;2&lt;/code&gt; EOF 플러스 위치, 일반적으로 부정적으로 설정합니다. 당신이 상수를 사용할 수 있습니다 WHENCE를 들어 &lt;code&gt;SEEK_SET&lt;/code&gt; , &lt;code&gt;SEEK_CUR&lt;/code&gt; , 그리고 &lt;code&gt;SEEK_END&lt;/code&gt; 로부터 (파일, 현재 위치, 파일의 끝의 시작) &lt;a href=&quot;../fcntl&quot;&gt;은 fcntl의&lt;/a&gt; 모듈. 반환 &lt;code&gt;1&lt;/code&gt; 성공, 그렇지 않은 경우는 false.</target>
        </trans-unit>
        <trans-unit id="defce8e2effd8a4c5cb2f53c0955b6344cd557d2" translate="yes" xml:space="preserve">
          <source>to POSITION; &lt;code&gt;1&lt;/code&gt; to set it to the current position plus POSITION; and &lt;code&gt;2&lt;/code&gt; to set it to EOF plus POSITION, typically negative. For WHENCE you may use the constants &lt;code&gt;SEEK_SET&lt;/code&gt; , &lt;code&gt;SEEK_CUR&lt;/code&gt; , and &lt;code&gt;SEEK_END&lt;/code&gt; (start of the file, current position, end of the file) from the &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; module. Returns &lt;code&gt;1&lt;/code&gt; on success, false otherwise.</source>
          <target state="translated">위치에; &lt;code&gt;1&lt;/code&gt; 을 현재 위치 + POSITION으로 설정합니다. 과 &lt;code&gt;2&lt;/code&gt; EOF 플러스 위치, 일반적으로 부정적으로 설정합니다. 당신이 상수를 사용할 수 있습니다 WHENCE를 들어 &lt;code&gt;SEEK_SET&lt;/code&gt; , &lt;code&gt;SEEK_CUR&lt;/code&gt; , 그리고 &lt;code&gt;SEEK_END&lt;/code&gt; 로부터 (파일, 현재 위치, 파일의 끝의 시작) &lt;a href=&quot;fcntl&quot;&gt;은 fcntl의&lt;/a&gt; 모듈. 반환 &lt;code&gt;1&lt;/code&gt; 성공, 그렇지 않은 경우는 false.</target>
        </trans-unit>
        <trans-unit id="75b325578f050782c8fcb428bd57b6b901bcfa73" translate="yes" xml:space="preserve">
          <source>to ThisProject/I18N/en.pm, because if _AUTO is true there, then just looking for an entry with the key &quot;Couldn't find file \&quot;[_1]\&quot;!\n&quot; in that lexicon will cause it to be added, with that value!</source>
          <target state="translated">_AUTO가 true 인 경우 해당 어휘집에서 &quot;파일 \&quot;[_ 1] \ &quot;! \ n&quot;키를 찾을 수없는 항목을 찾으려면 ThisProject / I18N / en.pm으로 이동하십시오. 그 가치로 추가!</target>
        </trans-unit>
        <trans-unit id="e87b45ec9b1a049ec58cd24d01f2b883881dc6b1" translate="yes" xml:space="preserve">
          <source>to a fixed number of given keys. Methods for creating and dealing with restricted hashes are exported by the &lt;a href=&quot;hash/util&quot;&gt;Hash::Util&lt;/a&gt; module.</source>
          <target state="translated">주어진 키의 고정 된 수. 제한된 해시를 만들고 처리하는 방법은 &lt;a href=&quot;hash/util&quot;&gt;Hash :: Util&lt;/a&gt; 모듈 에서 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="4e4a587937f5eb29db9d3748369255d25b711ed0" translate="yes" xml:space="preserve">
          <source>to a location on your LIBPATH.</source>
          <target state="translated">LIBPATH의 위치로.</target>
        </trans-unit>
        <trans-unit id="18bb49c1ef9ac587c558bd725670f0c267932208" translate="yes" xml:space="preserve">
          <source>to a location on your PATH,</source>
          <target state="translated">PATH상의 위치로</target>
        </trans-unit>
        <trans-unit id="2b3bd4b5b703698e2ad6b1562ddbab4a68189abf" translate="yes" xml:space="preserve">
          <source>to a location on your PATH.</source>
          <target state="translated">당신의 경로에 위치.</target>
        </trans-unit>
        <trans-unit id="939b8956446b9c496d5bc76687ea6d90606d1987" translate="yes" xml:space="preserve">
          <source>to a named subroutine, e.g. a counter that gets initialized at creation time of the sub and can only be modified from within the sub. This is sometimes used with a BEGIN block in package files to make sure a variable doesn't get meddled with during the lifetime of the package:</source>
          <target state="translated">명명 된 서브 루틴 (예 : 서브 생성시 초기화되어 서브 서브 내에서만 수정 될 수있는 카운터). 패키지의 수명 동안 변수가 방해받지 않도록 패키지 파일의 BEGIN 블록과 함께 사용되는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b7626ae679ea958fb7e5cdec6a9ba3c92474dbf" translate="yes" xml:space="preserve">
          <source>to a pipe, you should also trap SIGPIPE. Otherwise, think of what happens when you start up a pipe to a command that doesn't exist: the open() will in all likelihood succeed (it only reflects the fork()'s success), but then your output will fail--spectacularly. Perl can't know whether the command worked, because your command is actually running in a separate process whose exec() might have failed. Therefore, while readers of bogus commands return just a quick EOF, writers to bogus commands will get hit with a signal, which they'd best be prepared to handle. Consider:</source>
          <target state="translated">파이프에 SIGPIPE를 가두어 야합니다. 그렇지 않으면 존재하지 않는 명령에 파이프를 시작할 때 어떤 일이 발생하는지 생각해보십시오. open ()은 성공 가능성이 있지만 (fork ()의 ​​성공 만 반영) 출력은 실패합니다. -안경상. exec ()가 실패한 별도의 프로세스에서 명령이 실제로 실행되고 있기 때문에 Perl은 명령이 작동했는지 여부를 알 수 없습니다. 따라서 가짜 명령의 독자는 빠른 EOF를 반환하지만 가짜 명령의 작성자는 신호에 부딪 치므로 처리하기에 가장 적합합니다. 치다:</target>
        </trans-unit>
        <trans-unit id="b23d84faa8fd585b1ad0710623852a699603f544" translate="yes" xml:space="preserve">
          <source>to a test program the intermediate directories used by &lt;code&gt;make&lt;/code&gt; are added to @INC.</source>
          <target state="translated">테스트 프로그램에서 &lt;code&gt;make&lt;/code&gt; 가 사용하는 중간 디렉토리 가 @INC에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="526cecdce9a6fa0844944fe2657ec40470921035" translate="yes" xml:space="preserve">
          <source>to access documentation for different components of Perl. Start with</source>
          <target state="translated">Perl의 다른 구성 요소에 대한 문서에 액세스합니다. 로 시작</target>
        </trans-unit>
        <trans-unit id="a2ba8c1859afb35af5e779dbe13b3f995b3be717" translate="yes" xml:space="preserve">
          <source>to access the perl documentation in the text form (note that you may get better results using perl manpages).</source>
          <target state="translated">텍스트 형식으로 펄 문서에 액세스하려면 (펄 맨 페이지를 사용하면 더 나은 결과를 얻을 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="35a2c51838834c5c5405f168c5893280ce6cc0fe" translate="yes" xml:space="preserve">
          <source>to access these files.</source>
          <target state="translated">이러한 파일에 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="a373051c463e8242de6c723e14201a15eb5f2163" translate="yes" xml:space="preserve">
          <source>to accommodate Unix conventions used in some ported software.</source>
          <target state="translated">일부 포팅 된 소프트웨어에서 사용되는 유닉스 규약을 수용합니다.</target>
        </trans-unit>
        <trans-unit id="190b00af4099b5490f23b24ef3dc8e2fe342b61b" translate="yes" xml:space="preserve">
          <source>to accomplish this, but full details are in &lt;a href=&quot;perllocale#Unicode-and-UTF-8&quot;&gt;Unicode and UTF-8 in perllocale&lt;/a&gt;, including gotchas that happen if you don't specify &lt;code&gt;:not_characters&lt;/code&gt; .</source>
          <target state="translated">이를 달성하기 위해, 그러나 &lt;code&gt;:not_characters&lt;/code&gt; 를 지정하지 않으면 발생하는 문제를 포함하여 &lt;a href=&quot;perllocale#Unicode-and-UTF-8&quot;&gt;perllocale의&lt;/a&gt; 전체 세부 사항은 Unicode 및 UTF-8로되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a73a7bc7d432310b47d7dadb7338f6296927937c" translate="yes" xml:space="preserve">
          <source>to add your own encoding to perl. No knowledge of XS is necessary.</source>
          <target state="translated">펄에 자신의 인코딩을 추가합니다. XS에 대한 지식이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b89fc290c98c21f78eb1c3d3de205c05b005a94d" translate="yes" xml:space="preserve">
          <source>to allocate memory for a Perl interpreter. It's quite a simple function, and the guts of it looks like this:</source>
          <target state="translated">Perl 인터프리터에 메모리를 할당합니다. 그것은 매우 간단한 함수이며, 그 내장은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5df238e4f59f47ed3e559a86abb5276789fd76b7" translate="yes" xml:space="preserve">
          <source>to and</source>
          <target state="translated">~에</target>
        </trans-unit>
        <trans-unit id="39a68d5c47c1ad6ff50ff1f20660276dfbe7b579" translate="yes" xml:space="preserve">
          <source>to any operators already permitted).</source>
          <target state="translated">이미 허용 된 모든 운영자에게).</target>
        </trans-unit>
        <trans-unit id="3a7e4483f93948ccc15b247fcdc95d124ee3e0d4" translate="yes" xml:space="preserve">
          <source>to be</source>
          <target state="translated">되려고</target>
        </trans-unit>
        <trans-unit id="e893999fc61c9f9942e8865609ed6dc8816fc20e" translate="yes" xml:space="preserve">
          <source>to be able to use these macros:</source>
          <target state="translated">이 매크로를 사용하려면 :</target>
        </trans-unit>
        <trans-unit id="cf5d8c9c97a4054f2de2d35e98379bb8f2987a69" translate="yes" xml:space="preserve">
          <source>to be an @AoA, but rather just a reference to it, you could do something more like this:</source>
          <target state="translated">@AoA가 아니라 오히려 그것에 대한 참조로 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="019a46c6c83d83e2e7dd74db5f7d357036618f87" translate="yes" xml:space="preserve">
          <source>to be appended to the stream. The</source>
          <target state="translated">스트림에 추가됩니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="138b1321ccfe075171a68061e5a1117b091492e4" translate="yes" xml:space="preserve">
          <source>to be considered as the location of an error. The &lt;code&gt;carp()&lt;/code&gt; and &lt;code&gt;cluck()&lt;/code&gt; functions will skip over callers when reporting where an error occurred.</source>
          <target state="translated">오류의 위치로 간주됩니다. &lt;code&gt;carp()&lt;/code&gt; 와 &lt;code&gt;cluck()&lt;/code&gt; 에러가 발생한 경우에보고하는 기능은 발신자를 스킵한다.</target>
        </trans-unit>
        <trans-unit id="3d8894d272d9670db059eb36fa388b92f6748964" translate="yes" xml:space="preserve">
          <source>to be created. The</source>
          <target state="translated">만들 수 있습니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="84fb3256daf84c2b7c36def5c86135fead88552e" translate="yes" xml:space="preserve">
          <source>to be fed. (Since you see _1 and a _2 being used in the key there.)</source>
          <target state="translated">먹일 것이다. (키에 _1 및 _2가 사용되고있는 것을 볼 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="98524352b3e61275f42e3fc522841353e48b08c2" translate="yes" xml:space="preserve">
          <source>to be in effect when perl</source>
          <target state="translated">펄 때 효과가</target>
        </trans-unit>
        <trans-unit id="76f8048f660e2d2cd4ca7c267d990f0c9732b9fb" translate="yes" xml:space="preserve">
          <source>to be less precisely specified. Details are in &lt;a href=&quot;#LOOSE-MATCHES&quot;&gt;LOOSE MATCHES&lt;/a&gt;.</source>
          <target state="translated">덜 정확하게 지정해야합니다. 자세한 내용은 &lt;a href=&quot;#LOOSE-MATCHES&quot;&gt;LOOSE MATCHES에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a25cde4d1302e9dba53eb4907caba9ff77c35bd" translate="yes" xml:space="preserve">
          <source>to be null. This function is also thread safe on the small scale. It uses appropriate locking to avoid race conditions in accessing &lt;a href=&quot;#PL_check&quot;&gt;PL_check&lt;/a&gt;.</source>
          <target state="translated">null이된다 이 기능은 소규모 스레드에서도 안전합니다. &lt;a href=&quot;#PL_check&quot;&gt;PL_check&lt;/a&gt; 에 액세스 할 때 경쟁 조건을 피하기 위해 적절한 잠금을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="3d0279bbb98c4fed8cbeea6e8338eb32180ee838" translate="yes" xml:space="preserve">
          <source>to be symlinks to the actual binary. If that can't be done, system administrators are strongly encouraged to put (symlinks to) perl and its accompanying utilities into a directory typically found along a user's PATH, or in some other obvious and convenient place.</source>
          <target state="translated">실제 바이너리에 대한 심볼릭 링크입니다. 그렇게 할 수없는 경우, 시스템 관리자는 perl 및 그와 함께 제공되는 유틸리티를 일반적으로 사용자의 PATH 또는 다른 명백하고 편리한 위치에있는 디렉토리에 넣는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c1312f43c3145ddd16b2a7f06695a0db02e8b75a" translate="yes" xml:space="preserve">
          <source>to be used to determine if a constant is to be defined.</source>
          <target state="translated">상수 정의 여부를 결정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6dfaa48eefc09804912e9e020597db19ee8f8e41" translate="yes" xml:space="preserve">
          <source>to be written out later. Data in the deferred write buffer is also charged against the memory limit you set with the &lt;code&gt;memory&lt;/code&gt; option.</source>
          <target state="translated">나중에 작성합니다. 지연된 쓰기 버퍼의 데이터는 또한 &lt;code&gt;memory&lt;/code&gt; 옵션으로 설정 한 메모리 제한에 따라 청구 됩니다.</target>
        </trans-unit>
        <trans-unit id="f6eae6f36fad068d13506b3de1e258315a973b7f" translate="yes" xml:space="preserve">
          <source>to become the heir to MakeMaker. MakeMaker's maintainers have long said that it is a dead end and should be kept functioning, but not extended with new features. It's complicated enough as it is!</source>
          <target state="translated">MakeMaker의 상속자가됩니다. 메이크 메이커의 관리자는 오랫동안 막 다른 골목이며 기능을 유지해야하지만 새로운 기능으로 확장되어서는 안된다고 말했다. 그대로 복잡합니다!</target>
        </trans-unit>
        <trans-unit id="e42231196dcb18697b456290fa711408575dbc64" translate="yes" xml:space="preserve">
          <source>to both EXPR1 and EXPR2. Only if</source>
          <target state="translated">EXPR1과 EXPR2 모두에. 경우에만</target>
        </trans-unit>
        <trans-unit id="924eea1cd1b5f3404a8c17a7ccb24dd497472a1c" translate="yes" xml:space="preserve">
          <source>to build perl with support for 64-bit integers (&lt;code&gt;use64bitint&lt;/code&gt; ) or both 64-bit integers and 64-bit addressing (&lt;code&gt;use64bitall&lt;/code&gt; ). In the latter case, the resulting binary will run only on G5-based hosts.</source>
          <target state="translated">64 비트 정수 ( &lt;code&gt;use64bitint&lt;/code&gt; ) 또는 64 비트 정수 및 64 비트 주소 지정 ( &lt;code&gt;use64bitall&lt;/code&gt; )을 모두 지원하여 perl을 빌드 합니다. 후자의 경우 결과 바이너리는 G5 기반 호스트에서만 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="c2960ffda3ff18124ff7f6c2b946df0ddafabbc1" translate="yes" xml:space="preserve">
          <source>to calculate checksums. For the Perl interface, the order of the two parameters in both functions has been reversed. This allows both running checksums and one off calculations to be done.</source>
          <target state="translated">체크섬을 계산합니다. Perl 인터페이스의 경우 두 기능에서 두 매개 변수의 순서가 반대로 바뀌 었습니다. 이를 통해 실행중인 체크섬과 일회성 계산을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="216f4d2f0bbcf6e74daa148b9f8a286adfde05e3" translate="yes" xml:space="preserve">
          <source>to change if the message change in some way. Another property is that digest functions are one-way functions, that is it should be</source>
          <target state="translated">메시지가 어떤 식 으로든 변경되면 변경됩니다. 또 다른 속성은 다이제스트 함수가 단방향 함수라는 것입니다.</target>
        </trans-unit>
        <trans-unit id="103883c712727958c6de7ae9820b677419a7e766" translate="yes" xml:space="preserve">
          <source>to check for DCL procedure. If this fails, checks directories in DCL$PATH and finally</source>
          <target state="translated">DCL 절차를 확인하십시오. 이것이 실패하면 DCL $ PATH에서 디렉토리를 확인하고 마지막으로</target>
        </trans-unit>
        <trans-unit id="731aa951e967b4db2f011ced9dc08b9a36920510" translate="yes" xml:space="preserve">
          <source>to command pipes is to use &lt;code&gt;&quot;|-&quot;&lt;/code&gt; in place of &lt;code&gt;&quot;-|&quot;&lt;/code&gt; .</source>
          <target state="translated">파이프를 명령하는 것은 &lt;code&gt;&quot;-|&quot;&lt;/code&gt; 대신 &lt;code&gt;&quot;|-&quot;&lt;/code&gt; 를 사용 하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="33a43350f70aed99b64d60955734bbec9e9f87af" translate="yes" xml:space="preserve">
          <source>to compile Perl 32-bit. Don't bother with -n32 unless you have 7.1 or later compilers (use cc -version to check).</source>
          <target state="translated">Perl 32 비트를 컴파일합니다. 7.1 이상의 컴파일러가없는 경우 (cc -version을 사용하여 확인)가 아니면 -n32를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="743d2eefcb5e3c10bbc64054994c2c15486d8e77" translate="yes" xml:space="preserve">
          <source>to convert perl utilities to</source>
          <target state="translated">펄 유틸리티를</target>
        </trans-unit>
        <trans-unit id="7b210708522f858c74dc655b94df0449b71778b2" translate="yes" xml:space="preserve">
          <source>to create a &lt;code&gt;float&lt;/code&gt; , and</source>
          <target state="translated">생성하는 &lt;code&gt;float&lt;/code&gt; 하고,</target>
        </trans-unit>
        <trans-unit id="cf2348a6ec6eaf3d48ed051b15a33749f439c666" translate="yes" xml:space="preserve">
          <source>to create a string:</source>
          <target state="translated">문자열을 만들려면</target>
        </trans-unit>
        <trans-unit id="1c8c7bdde3e8f34c6791da2b20254e6dd797fa43" translate="yes" xml:space="preserve">
          <source>to create an &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">만드는 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="6abff830d9aee9d0e01d8789752ed03356a1172e" translate="yes" xml:space="preserve">
          <source>to create an object with &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt; {Name =&amp;gt; ...}, $class&lt;/code&gt; , and call define_encoding. They inherit their &lt;code&gt;name&lt;/code&gt; method from &lt;code&gt;Encode::Encoding&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt; {Name =&amp;gt; ...}, $class&lt;/code&gt; 를 사용하여 객체를 만들고 define_encoding을 호출합니다. &lt;code&gt;Encode::Encoding&lt;/code&gt; 에서 &lt;code&gt;name&lt;/code&gt; 메소드를 상속합니다 .</target>
        </trans-unit>
        <trans-unit id="13fb3853d5ec1540d5748eb0dd803110ae60da5e" translate="yes" xml:space="preserve">
          <source>to define a &lt;code&gt;run&lt;/code&gt; method. If you're writing a Pod-formatter class, you should define a &lt;code&gt;run&lt;/code&gt; just so that users can call &lt;code&gt;parse_file&lt;/code&gt; etc, but you don't</source>
          <target state="translated">&lt;code&gt;run&lt;/code&gt; 방법 을 정의합니다 . Pod 포맷터 클래스를 작성하는 경우 사용자가 &lt;code&gt;parse_file&lt;/code&gt; 등을 호출 할 수 있도록 &lt;code&gt;run&lt;/code&gt; 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="a5a63182de86c8a3e6163d98d58dd2623e455299" translate="yes" xml:space="preserve">
          <source>to denote a capturing group of the form &lt;a href=&quot;perlre#(%3fPARNO)-(%3f-PARNO)-(%3f%2bPARNO)-(%3fR)-(%3f0)&quot;&gt;(?PARNO)&lt;/a&gt;, but omitted the &lt;code&gt;&quot;)&quot;&lt;/code&gt; .</source>
          <target state="translated">&lt;a href=&quot;perlre#(%3fPARNO)-(%3f-PARNO)-(%3f%2bPARNO)-(%3fR)-(%3f0)&quot;&gt;(? PARNO)&lt;/a&gt; 형식의 캡처 그룹을 나타내지 만 &lt;code&gt;&quot;)&quot;&lt;/code&gt; 는 생략했습니다 .</target>
        </trans-unit>
        <trans-unit id="95c7af9d6ca4741280ae12ff21ab09e9cdf25647" translate="yes" xml:space="preserve">
          <source>to display it; if</source>
          <target state="translated">그것을 표시하기 위해; 만약</target>
        </trans-unit>
        <trans-unit id="e3e5845a22ed917abc0126267df7df44ea895291" translate="yes" xml:space="preserve">
          <source>to display the path to the module. In some cases (for example, the &lt;code&gt;AutoLoader&lt;/code&gt; module), this command will show the path to a separate &lt;code&gt;pod&lt;/code&gt; file; the module itself should be in the same directory, with a 'pm' file extension.</source>
          <target state="translated">모듈 경로를 표시합니다. 경우에 따라 (예 : &lt;code&gt;AutoLoader&lt;/code&gt; 모듈)이 명령은 별도의 &lt;code&gt;pod&lt;/code&gt; 파일에 대한 경로를 표시 합니다. 모듈 자체는 파일 확장자가 'pm'인 동일한 디렉토리에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="876e43e0908079d66a492e080439c57dff35438a" translate="yes" xml:space="preserve">
          <source>to do so. And</source>
          <target state="translated">그렇게하기 위해. 과</target>
        </trans-unit>
        <trans-unit id="b947a7d83a90fd93960468bbd8002c295475ab0c" translate="yes" xml:space="preserve">
          <source>to enable an experimental switch feature. This is loosely based on an old version of a Perl 6 proposal, but it no longer resembles the Perl 6 construct. You also get the switch feature whenever you declare that your code prefers to run under a version of Perl that is 5.10 or later. For example:</source>
          <target state="translated">실험적인 스위치 기능을 활성화합니다. 이것은 이전 버전의 Perl 6 제안을 기반으로하지 않지만 더 이상 Perl 6 구성과 유사하지 않습니다. 또한 코드가 5.10 이상인 Perl 버전에서 실행되는 것을 선호한다고 선언 할 때마다 스위치 기능을 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="82473b502decf667eb5cf57e3f13cb772ed8ed58" translate="yes" xml:space="preserve">
          <source>to enable you to see what locales there are on the current platform.</source>
          <target state="translated">현재 플랫폼에 어떤 로캘이 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f092c62aa2cf37ff8e36cf49d58d75de683036e" translate="yes" xml:space="preserve">
          <source>to execute, rather than the one it has just executed.</source>
          <target state="translated">방금 실행 한 것이 아니라 실행합니다.</target>
        </trans-unit>
        <trans-unit id="524e0ea0502df43dfa1f4421c6984ecb109dc7fd" translate="yes" xml:space="preserve">
          <source>to extract an ASCII tar archive on OS/390, try this:</source>
          <target state="translated">OS / 390에서 ASCII tar 아카이브를 추출하려면 다음을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="c7f1cc49694bdea53f292e349a4d22a16060be85" translate="yes" xml:space="preserve">
          <source>to extract the data itself, you'll need a dereference: $$s1</source>
          <target state="translated">데이터 자체를 추출하려면 역 참조가 필요합니다 : $$ s1</target>
        </trans-unit>
        <trans-unit id="4d5ac57125dea2095aaaa7c0c7b7f13d75e8dcb7" translate="yes" xml:space="preserve">
          <source>to fetch or store the record at line &lt;code&gt;$n&lt;/code&gt; , respectively; similarly the other tied array methods. (See &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; for details.) You may also call the following methods on this object:</source>
          <target state="translated">&lt;code&gt;$n&lt;/code&gt; 행에서 레코드를 각각 가져 오거나 저장합니다 . 마찬가지로 다른 묶인 배열 방법. (자세한 내용은 &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; 를 참조하십시오.)이 객체에 대해 다음 메소드를 호출 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2fa42d27aad6d50b2bc31ff51bcae0729ca7103" translate="yes" xml:space="preserve">
          <source>to find a message that correspond to some given digest. Algorithms differ in how &quot;likely&quot; and how &quot;hard&quot;, as well as how efficient they are to compute.</source>
          <target state="translated">주어진 다이제스트에 해당하는 메시지를 찾습니다. 알고리즘은 계산 방법의 효율성뿐만 아니라 &quot;가능성&quot;과 &quot;하드&quot;방법이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="3e21a74ff876d5884a9cd3e42c0a803a127bfc89" translate="yes" xml:space="preserve">
          <source>to find out more about how to use it.</source>
          <target state="translated">사용 방법에 대해 자세히 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="8087a685db9dd787b7e7ce5d9406c7b5f62f7733" translate="yes" xml:space="preserve">
          <source>to find suspiciously skipped tests, and other fishy events.</source>
          <target state="translated">의심스럽게 건너 뛴 테스트 및 기타 비린내 이벤트를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3817e3dfa074e1068e390eca87ad8f05b3f5748" translate="yes" xml:space="preserve">
          <source>to get Perl to work well with them. The catch is that you have to translate from the locale character set to/from Unicode yourself. See &lt;a href=&quot;#Unicode-I%2fO&quot;&gt;Unicode I/O&lt;/a&gt; above for how to</source>
          <target state="translated">펄이 그들과 잘 어울리도록 캐치 로케일 문자 세트에서 유니 코드로 또는 유니 코드로 변환해야합니다. 방법은 위의 &lt;a href=&quot;#Unicode-I%2fO&quot;&gt;유니 코드 I / O를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ac0a825f6340f8ac1be51fe954ab53df2d302874" translate="yes" xml:space="preserve">
          <source>to get Unicode rules, as the &lt;code&gt;\L&lt;/code&gt; in the former (but not necessarily the latter) would also use Unicode rules.</source>
          <target state="translated">전자 의 &lt;code&gt;\L&lt;/code&gt; (후자는 아니지만)도 유니 코드 규칙을 사용하므로 유니 코드 규칙 을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="cdb6284e25e399322757d97afb2ac2e493d2f13d" translate="yes" xml:space="preserve">
          <source>to get a hexadecimal digit, or</source>
          <target state="translated">16 진수를 얻거나</target>
        </trans-unit>
        <trans-unit id="6dff39424d11acaf9846ad1872f40e67f2726554" translate="yes" xml:space="preserve">
          <source>to get a list of anonymous hashes each with only one entry apiece.</source>
          <target state="translated">각각 하나의 항목 만있는 익명 해시 목록을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="df95aa7d96ad35561dea936c7dfdb0c59259e424" translate="yes" xml:space="preserve">
          <source>to get all normal letters of the English alphabet, or</source>
          <target state="translated">영어 알파벳의 모든 일반 문자를 가져 오거나</target>
        </trans-unit>
        <trans-unit id="9453fbce4c219f28d8e1fe0f3939d307058adf72" translate="yes" xml:space="preserve">
          <source>to get both unique invocation</source>
          <target state="translated">두 가지 독특한 호출을 얻기 위해</target>
        </trans-unit>
        <trans-unit id="aa4caba4c31a5fb34a97e1d00d7e9e413e73365c" translate="yes" xml:space="preserve">
          <source>to get dates with leading zeros.</source>
          <target state="translated">선행 0으로 날짜를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="42b10c1b27c37e1c3b1556a16293d2db17e7beb7" translate="yes" xml:space="preserve">
          <source>to get four files containing &quot;Hello World!\n&quot; in ASCII, CP 0037 EBCDIC, ISO 8859-1 (Latin-1) (in this example identical to ASCII since only ASCII characters were printed), and UTF-EBCDIC (in this example identical to normal EBCDIC since only characters that don't differ between EBCDIC and UTF-EBCDIC were printed). See the documentation of &lt;a href=&quot;encode/perlio&quot;&gt;Encode::PerlIO&lt;/a&gt; for details.</source>
          <target state="translated">ASCII, CP 0037 EBCDIC, ISO 8859-1 (Latin-1) (ASCII 문자 만 인쇄되었으므로 ASCII와 동일) 및 UTF-EBCDIC ( &quot; 예를 들어 EBCDIC과 UTF-EBCDIC간에 다르지 않은 문자 만 인쇄되므로 일반 EBCDIC과 동일합니다. 자세한 내용은 &lt;a href=&quot;encode/perlio&quot;&gt;Encode :: PerlIO&lt;/a&gt; 설명서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="28603ac6b28eec67b3e188373d6a6a06869faeb7" translate="yes" xml:space="preserve">
          <source>to get the correct function definitions. If</source>
          <target state="translated">올바른 기능 정의를 얻으려면. 만약</target>
        </trans-unit>
        <trans-unit id="470ba0f2f1c7ef2528debf493d9f58f588db9ebf" translate="yes" xml:space="preserve">
          <source>to get the repaired variant. For backward compatibility with older versions of perl, you can instead decrement the reference count manually when you're returning one of the aforementioned types using &lt;code&gt;sv_2mortal&lt;/code&gt; :</source>
          <target state="translated">수리 된 변종을 얻을 수 있습니다. 이전 버전의 perl과의 호환성을 위해 &lt;code&gt;sv_2mortal&lt;/code&gt; 을 사용하여 위에서 언급 한 유형 중 하나를 반환 할 때 참조 카운트를 수동으로 줄일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="48d35469aac726018b9cbf58b42ec28989fe44ca" translate="yes" xml:space="preserve">
          <source>to get the value of this into the proper command. You must be prepared to do the</source>
          <target state="translated">이 값을 적절한 명령으로 가져옵니다. 당신은 할 준비가되어 있어야합니다</target>
        </trans-unit>
        <trans-unit id="abac24d2e236e321f06c59d2c39149a3827039e7" translate="yes" xml:space="preserve">
          <source>to get two files containing &quot;Hello World!\n&quot; in ASCII, EBCDIC, ISO Latin-1 (in this example identical to ASCII) respective UTF-EBCDIC (in this example identical to normal EBCDIC). See the documentation of Encode::PerlIO for details.</source>
          <target state="translated">ASCII, EBCDIC, ISO Latin-1 (이 예에서는 ASCII와 동일)에 각각의 UTF-EBCDIC (이 예에서는 일반 EBCDIC와 동일)에 &quot;Hello World! \ n&quot;을 포함하는 두 개의 파일을 가져옵니다. 자세한 내용은 Encode :: PerlIO 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="be7707df760253ac698371ee35058456da264ad3" translate="yes" xml:space="preserve">
          <source>to give the output</source>
          <target state="translated">출력을 제공하기 위해</target>
        </trans-unit>
        <trans-unit id="6234813623d065b30366ac94d161191137eaa4a6" translate="yes" xml:space="preserve">
          <source>to have the same value, namely &lt;code&gt;Larry&lt;/code&gt; . The problem is caused by the way that the associative array interface works. Basically, when the associative array interface is used to fetch the value associated with a given key, it will only ever retrieve the first value.</source>
          <target state="translated">&lt;code&gt;Larry&lt;/code&gt; 같은 값을 갖습니다 . 연관 배열 인터페이스의 작동 방식으로 인해 문제가 발생합니다. 기본적으로 연관 배열 인터페이스가 주어진 키와 연관된 값을 페치하는 데 사용될 때 첫 번째 값만 검색합니다.</target>
        </trans-unit>
        <trans-unit id="052b0b761fb9034f5ea9b20f5549120959dfbd83" translate="yes" xml:space="preserve">
          <source>to hold an entire symbol table entry. The type prefix of a typeglob is a &lt;code&gt;*&lt;/code&gt; , because it represents all types. This used to be the preferred way to pass arrays and hashes by reference into a function, but now that we have real references, this is seldom needed.</source>
          <target state="translated">전체 기호 테이블 항목을 보유합니다. typeglob의 타입 접두사 는 모든 타입을 나타 내기 때문에 &lt;code&gt;*&lt;/code&gt; 입니다. 이것은 참조로 배열과 해시를 함수에 전달하는 선호되는 방법 이었지만 이제 실제 참조가 있으므로 거의 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2a7f2b88fab3883f2a61c5f5e56375cc228d7086" translate="yes" xml:space="preserve">
          <source>to implement your class.</source>
          <target state="translated">수업을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="9288e371db7100023b08879f0e4418c3566949b3" translate="yes" xml:space="preserve">
          <source>to incorporate the new code.</source>
          <target state="translated">새 코드를 통합합니다.</target>
        </trans-unit>
        <trans-unit id="82d8dafd0d3e9763c0065dba7872f47129cd0ee6" translate="yes" xml:space="preserve">
          <source>to install it locally. (Remember that if you do this, you'll have to put &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; lib &quot;/my/perl_directory&quot;;&lt;/code&gt; near the top of the program that is to use this module.</source>
          <target state="translated">로컬로 설치합니다. (이렇게 할 경우, 당신은 넣어해야 기억 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; lib &quot;/my/perl_directory&quot;;&lt;/code&gt; 이 모듈을 사용하는 프로그램의 상단에.</target>
        </trans-unit>
        <trans-unit id="16a7203162e974acc6e6c3f1d7e8eb2095e9ba68" translate="yes" xml:space="preserve">
          <source>to invoke the Perl subroutine.</source>
          <target state="translated">Perl 서브 루틴을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="d2094dc8f62bd8afcfca075e224337bbb8e418f3" translate="yes" xml:space="preserve">
          <source>to it, see &lt;code&gt;emxbind&lt;/code&gt; . Note that under DOS for best results one should use RSX runtime, which has much more functions working (like &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;popen&lt;/code&gt; and so on). In fact RSX is required if there is no VCPI present. Note the RSX requires DPMI. Many implementations of DPMI are known to be very buggy, beware!</source>
          <target state="translated">그것에 대해서는 &lt;code&gt;emxbind&lt;/code&gt; 를 참조하십시오 . DOS에서 최상의 결과를 얻으려면 RSX 런타임을 사용해야합니다.이 기능은 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;popen&lt;/code&gt; 등과 같은 훨씬 더 많은 기능 을 수행합니다. 실제로 VCPI가없는 경우 RSX가 필요합니다. RSX에는 DPMI가 필요합니다. DPMI의 많은 구현은 매우 버그가 많으며 조심하십시오!</target>
        </trans-unit>
        <trans-unit id="1e7c69bdd02005a68c5a0491f7b22563882513e5" translate="yes" xml:space="preserve">
          <source>to let Perl see the &lt;b&gt;-p&lt;/b&gt; switch.</source>
          <target state="translated">Perl이 &lt;b&gt;-p&lt;/b&gt; 스위치 를 보도록 합니다.</target>
        </trans-unit>
        <trans-unit id="1ff1c6954004cf196e1c94a305ba6e22060530e7" translate="yes" xml:space="preserve">
          <source>to list some (not all may be available simultaneously), or it may be read</source>
          <target state="translated">일부를 나열하거나 (모두 동시에 사용 가능한 것은 아님) 읽거나 읽을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="fb94ceb0e63eca810548f16a667eaaf1f49016f4" translate="yes" xml:space="preserve">
          <source>to loop through the</source>
          <target state="translated">를 통해 루프</target>
        </trans-unit>
        <trans-unit id="17fd8d3f491879c310e35f1017671959de50087e" translate="yes" xml:space="preserve">
          <source>to make Configure look only into the system libraries. If you have some extra library directories that you really want to use (such as newer Berkeley DB libraries in pre-Panther systems), add those to the libpth:</source>
          <target state="translated">Configure를 시스템 라이브러리에만 표시합니다. 실제로 사용하려는 추가 라이브러리 디렉토리 (예 : Panther 이전 시스템의 최신 Berkeley DB 라이브러리)가 있으면 libpth에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="fee487ddca5f479ff130a7872bae8c3bd3026aad" translate="yes" xml:space="preserve">
          <source>to make it loadable, that's not recommended. And while you may wish to INSTALL the image for performance reasons, you should not install it with privileges; if you do, the result will not be what you expect as image privileges are disabled during Perl start-up.</source>
          <target state="translated">로드 할 수있게하려면 권장하지 않습니다. 성능상의 이유로 이미지를 설치하려고 할 때 권한으로 이미지를 설치해서는 안됩니다. 그렇게하면 Perl 시작 중에 이미지 권한이 비활성화되어 예상 한 결과가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7e8b91fe91200b67fd11849738943032a8974f07" translate="yes" xml:space="preserve">
          <source>to merely a lexically scoped</source>
          <target state="translated">어휘 범위 만</target>
        </trans-unit>
        <trans-unit id="65db7660c749d5fcb9c05bfb31af1aed3a85d7da" translate="yes" xml:space="preserve">
          <source>to not evaluate &lt;code&gt;foo($bar)&lt;/code&gt; and &lt;code&gt;baz($quux)&lt;/code&gt; when the test is being skipped. But in reality, they</source>
          <target state="translated">테스트를 건너 뛸 때 &lt;code&gt;foo($bar)&lt;/code&gt; 및 &lt;code&gt;baz($quux)&lt;/code&gt; 평가하지 않습니다 . 그러나 실제로는</target>
        </trans-unit>
        <trans-unit id="0b442daf0bb11680f2bfe3b64bf4e03e8bea49d4" translate="yes" xml:space="preserve">
          <source>to obtain the text of an HTML-file in an array with all the HTML-tags automagically removed.</source>
          <target state="translated">모든 HTML 태그가 자동으로 제거 된 배열에서 HTML 파일의 텍스트를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="4b2182d04008a6c4483613ec47473dff2770a53d" translate="yes" xml:space="preserve">
          <source>to other arrays or hashes.</source>
          <target state="translated">다른 배열이나 해시에.</target>
        </trans-unit>
        <trans-unit id="15de79039ea4eec6320dd0634c5be1d5bee366ab" translate="yes" xml:space="preserve">
          <source>to other threading models is the fact that for each new thread created, a complete copy of all the variables and data of the parent thread has to be taken. Thus, thread creation can be quite expensive, both in terms of memory usage and time spent in creation. The ideal way to reduce these costs is to have a relatively short number of long-lived threads, all created fairly early on (before the base thread has accumulated too much data). Of course, this may not always be possible, so compromises have to be made. However, after a thread has been created, its performance and extra memory usage should be little different than ordinary code.</source>
          <target state="translated">다른 스레딩 모델에는 새로 생성 된 각 스레드에 대해 상위 스레드의 모든 변수 및 데이터의 전체 사본을 가져와야합니다. 따라서 스레드 사용은 메모리 사용량과 생성에 소요 된 시간 측면에서 상당히 비쌀 수 있습니다. 이러한 비용을 줄이는 이상적인 방법은 비교적 짧은 수의 장기 스레드를 확보하는 것입니다 (모두 초기 스레드가 너무 많은 데이터를 축적하기 전에 상당히 초기에 작성 됨). 물론 이것이 항상 가능한 것은 아니므로 타협해야합니다. 그러나 스레드가 생성 된 후에는 성능 및 추가 메모리 사용량이 일반 코드와 거의 다를 것입니다.</target>
        </trans-unit>
        <trans-unit id="6d9f660d23753136c732ed3417bb35f81b614dbf" translate="yes" xml:space="preserve">
          <source>to overload &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt;-quoted strings, constant pieces of &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq&lt;/a&gt;&lt;/code&gt;- and &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx&lt;/a&gt;&lt;/code&gt;-quoted strings and here-documents,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; 인용 문자열, 상수 &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx&lt;/a&gt;&lt;/code&gt; 인용 문자열 및 here-documents 를 오버로드하기 위해</target>
        </trans-unit>
        <trans-unit id="fb28b87e78501f2d3eca0d75953390d95bf41915" translate="yes" xml:space="preserve">
          <source>to overload constant pieces of regular expressions.</source>
          <target state="translated">일정한 정규 표현식에 과부하가 걸리도록합니다.</target>
        </trans-unit>
        <trans-unit id="7518dc6c2decddb256b0beec05b88725ea598d80" translate="yes" xml:space="preserve">
          <source>to overload floating point constants,</source>
          <target state="translated">부동 소수점 상수를 과부하</target>
        </trans-unit>
        <trans-unit id="a9ea6185dd3a9dac0c2c5aa1392ed399b440469d" translate="yes" xml:space="preserve">
          <source>to overload integer constants,</source>
          <target state="translated">정수 상수를 오버로드하기 위해</target>
        </trans-unit>
        <trans-unit id="1c08091b29060daf620ad3d7ec2c2d06ecc69649" translate="yes" xml:space="preserve">
          <source>to overload octal and hexadecimal constants,</source>
          <target state="translated">8 진 및 16 진 상수를 오버로드하기 위해</target>
        </trans-unit>
        <trans-unit id="29f192cae973f004ae05716dbe6e5ada512317df" translate="yes" xml:space="preserve">
          <source>to prevent both obvious and subtle traps. Some of these checks are reasonably simple, such as verifying that path directories aren't writable by others; careful programmers have always used checks like these. Other checks, however, are best supported by the language itself, and it is these checks especially that contribute to making a set-id Perl program more secure than the corresponding C program.</source>
          <target state="translated">명백하고 미묘한 함정을 방지합니다. 이러한 검사 중 일부는 경로 디렉터리를 다른 사람이 쓸 수 없는지 확인하는 등 합리적으로 간단합니다. 신중한 프로그래머는 항상 이와 같은 검사를 사용했습니다. 그러나 다른 검사는 언어 자체에서 가장 잘 지원되며, 특히 이러한 검사는 set-id Perl 프로그램을 해당 C 프로그램보다 더 안전하게 만드는 데 기여합니다.</target>
        </trans-unit>
        <trans-unit id="51a61bd662ae21c882779433ed339801bd6a9c26" translate="yes" xml:space="preserve">
          <source>to properly restore the &lt;code&gt;LC_NUMERIC&lt;/code&gt; state.</source>
          <target state="translated">&lt;code&gt;LC_NUMERIC&lt;/code&gt; 상태 를 올바르게 복원합니다 .</target>
        </trans-unit>
        <trans-unit id="da0f2469f8436e8ff32aedc3a2323005a898d520" translate="yes" xml:space="preserve">
          <source>to put wrappers around your scripts.</source>
          <target state="translated">스크립트 주위에 래퍼를 넣습니다.</target>
        </trans-unit>
        <trans-unit id="cfa21274611a5bd065878064455b524270569032" translate="yes" xml:space="preserve">
          <source>to refer a cross-compilation that was created last time.</source>
          <target state="translated">마지막에 만들어진 크로스 컴파일을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="12fc5bdacdc78921dfce599673ebebe3fcce9f11" translate="yes" xml:space="preserve">
          <source>to reflect this.</source>
          <target state="translated">이것을 반영하기 위해.</target>
        </trans-unit>
        <trans-unit id="659a407adecfa0f6a484510887ce5ba33ab3d34a" translate="yes" xml:space="preserve">
          <source>to reflect where did you put the files. Note that if you have some primitive unzipper (like &lt;code&gt;pkunzip&lt;/code&gt; ), you may get a lot of warnings/errors during unzipping. Upgrade to &lt;code&gt;(w)unzip&lt;/code&gt;.</source>
          <target state="translated">파일을 어디에 넣었는지 반영합니다. &lt;code&gt;pkunzip&lt;/code&gt; 과 같은 원시 압축 해제 도구가 있으면 압축 해제 중에 많은 경고 / 오류가 발생할 수 있습니다. &lt;code&gt;(w)unzip&lt;/code&gt; 으로 업그레이드하십시오 .</target>
        </trans-unit>
        <trans-unit id="9d2ba7014727c3cc2499d98334c80eba94773412" translate="yes" xml:space="preserve">
          <source>to reflect your system and run it.</source>
          <target state="translated">시스템을 반영하고 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="ec73e98b9f1082cb61c5dad4025d258ca0df1374" translate="yes" xml:space="preserve">
          <source>to remove all the leading comments on the fly during the build. The extra \\ are necessary, unfortunately, because this variable is interpolated within the context of a Perl program built on the command line, and double quotes are what is used with the -e switch to build that command line. The # is escaped for the Makefile, since what is going to be generated will then be:</source>
          <target state="translated">빌드 중에 모든 주요 주석을 즉시 제거합니다. 불행히도이 변수는 명령 행에 빌드 된 Perl 프로그램의 컨텍스트 내에서 보간되기 때문에 여분의 \\가 필요하며, 큰 따옴표는 해당 명령 행을 빌드하기 위해 -e 스위치와 함께 사용됩니다. 생성 될 내용은 다음과 같으므로 #은 Makefile에서 이스케이프됩니다.</target>
        </trans-unit>
        <trans-unit id="9495b5887b6df8e7d2cf4b53399b33d3bb6d5092" translate="yes" xml:space="preserve">
          <source>to report and view bugs.</source>
          <target state="translated">버그를보고하고 봅니다.</target>
        </trans-unit>
        <trans-unit id="1b4afcbda2b19adfed5bf43ff3a2fceb0b887353" translate="yes" xml:space="preserve">
          <source>to resume where the calculation left off.</source>
          <target state="translated">계산이 중단 된 지점에서 다시 시작합니다.</target>
        </trans-unit>
        <trans-unit id="4dbe32b44e63c55a1908194065d741dad727fd9a" translate="yes" xml:space="preserve">
          <source>to return a list and we didn't check for that possibility and take appropriate action the Perl stack would end up in an inconsistent state. That is something you</source>
          <target state="translated">목록을 반환하고 해당 가능성을 확인하지 않았으며 Perl 스택이 일치하지 않는 상태가되는 적절한 조치를 취했습니다. 그건 당신이 뭔가</target>
        </trans-unit>
        <trans-unit id="1de7ba1a0f349839e616c4dfb1b79ba2ff660b67" translate="yes" xml:space="preserve">
          <source>to run &lt;code&gt;make install&lt;/code&gt; . If you are not, you must have write access to the directories in question.</source>
          <target state="translated">&lt;code&gt;make install&lt;/code&gt; 을 실행하십시오 . 그렇지 않은 경우 해당 디렉토리에 대한 쓰기 권한이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="27c25c5a7db8dc8fe81c102692d1f0f0767d22d3" translate="yes" xml:space="preserve">
          <source>to run under DOS without any external support by binding</source>
          <target state="translated">바인딩을 통해 외부 지원없이 DOS에서 실행</target>
        </trans-unit>
        <trans-unit id="885ddcd0e32212c4767b159144995a96f781aa74" translate="yes" xml:space="preserve">
          <source>to run. A zero signifies the default of 3 seconds. For example to run at least for 10 seconds:</source>
          <target state="translated">실행합니다. 0은 기본값 3 초를 나타냅니다. 예를 들어 10 초 이상 실행하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="a9f69c5df4d7b34c9f46f4c5644a4993567dda9e" translate="yes" xml:space="preserve">
          <source>to safeguard against your test script blowing up.</source>
          <target state="translated">테스트 스크립트가 터지는 것을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="3b5c2aba92e878120336a2bb3d81910b6a90f820" translate="yes" xml:space="preserve">
          <source>to see how Perl does this:</source>
          <target state="translated">Perl이 어떻게 하는지를 확인하려면 :</target>
        </trans-unit>
        <trans-unit id="9ec0179b4e855771865ee056ca147a37ba135ec0" translate="yes" xml:space="preserve">
          <source>to see the call stack at the time of death. By supplying the &lt;b&gt;-warntrace&lt;/b&gt; (or just &lt;b&gt;-w&lt;/b&gt;) flag, any warnings emitted will also come with a stack trace.</source>
          <target state="translated">사망시 호출 스택을 볼 수 있습니다. &lt;b&gt;-warntrace&lt;/b&gt; (또는 just &lt;b&gt;-w&lt;/b&gt; ) 플래그 를 제공하면 &lt;b&gt;생성&lt;/b&gt; 된 모든 경고에도 스택 추적이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="1abae5e0b93215dca78b4df050c4b2bb23c4c165" translate="yes" xml:space="preserve">
          <source>to see whether it leads to the list of available locales (search for the</source>
          <target state="translated">사용 가능한 로케일 목록으로 연결되는지 확인하십시오 (</target>
        </trans-unit>
        <trans-unit id="48e0fbc5536b8ff51cbb0d8c98b627bbd206f258" translate="yes" xml:space="preserve">
          <source>to send a signal to it (that means, to be brief, that the process is owned by the same user, or we are the super-user). This is useful to check that a child process is still alive (even if only as a zombie) and hasn't changed its UID. See &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt; for notes on the portability of this construct.</source>
          <target state="translated">신호를 보내려면 (즉, 프로세스가 동일한 사용자가 소유하고 있거나 우리가 슈퍼 사용자라는 것을 의미합니다.) 자식 프로세스가 아직 살아 있고 (좀비로도) UID를 변경하지 않았는지 확인하는 데 유용합니다. 이 구문의 이식성에 대한 참고 사항 은 &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="db1b23209691204230924770cc7c68e2837b9854" translate="yes" xml:space="preserve">
          <source>to send a signal to it (that means, to be brief, that the process is owned by the same user, or we are the super-user). This is useful to check that a child process is still alive (even if only as a zombie) and hasn't changed its UID. See &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for notes on the portability of this construct.</source>
          <target state="translated">신호를 보내려면 (즉, 프로세스가 동일한 사용자가 소유하고 있거나 우리가 슈퍼 사용자라는 것을 의미합니다.) 자식 프로세스가 아직 살아 있고 (좀비로도) UID를 변경하지 않았는지 확인하는 데 유용합니다. 이 구문의 이식성에 대한 참고 사항 은 &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d97c2933b59d9259995298ef3fafce6e5797cd5" translate="yes" xml:space="preserve">
          <source>to spaces in</source>
          <target state="translated">공백으로</target>
        </trans-unit>
        <trans-unit id="47795bd83bb68151673944f901d2c50b79dcbeb8" translate="yes" xml:space="preserve">
          <source>to specify any code point portably. &lt;code&gt;LATIN1_TO_NATIVE(0xDF)&lt;/code&gt; is going to be the code point that means LATIN SMALL LETTER SHARP S on whatever platform you are running on (on ASCII platforms it compiles without adding any extra code, so there is zero performance hit on those). The acceptable inputs to &lt;code&gt;LATIN1_TO_NATIVE&lt;/code&gt; are from &lt;code&gt;0x00&lt;/code&gt; through &lt;code&gt;0xFF&lt;/code&gt; . If your input isn't guaranteed to be in that range, use &lt;code&gt;UNICODE_TO_NATIVE&lt;/code&gt; instead. &lt;code&gt;NATIVE_TO_LATIN1&lt;/code&gt; and &lt;code&gt;NATIVE_TO_UNICODE&lt;/code&gt; translate the opposite direction.</source>
          <target state="translated">코드 포인트를 이식 가능하게 지정합니다. &lt;code&gt;LATIN1_TO_NATIVE(0xDF)&lt;/code&gt; 는 실행중인 플랫폼에 관계없이 라틴 문자가 선명함 을 의미하는 코드 포인트가됩니다 (ASCII 플랫폼에서는 추가 코드를 추가하지 않고 컴파일하므로 성능이 저하되지 않습니다). &lt;code&gt;LATIN1_TO_NATIVE&lt;/code&gt; 에 허용되는 입력 은 &lt;code&gt;0x00&lt;/code&gt; ~ &lt;code&gt;0xFF&lt;/code&gt; 입니다. 입력이 해당 범위에 속하지 않으면 대신 &lt;code&gt;UNICODE_TO_NATIVE&lt;/code&gt; 를 사용하십시오. &lt;code&gt;NATIVE_TO_LATIN1&lt;/code&gt; 및 &lt;code&gt;NATIVE_TO_UNICODE&lt;/code&gt; 는 반대 방향으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="1197feefbd9420667cdd5a4dd6a4aa3594104c2e" translate="yes" xml:space="preserve">
          <source>to start from the horizontal plane, some texts use</source>
          <target state="translated">수평면에서 시작하기 위해 일부 텍스트는</target>
        </trans-unit>
        <trans-unit id="5f251a862463ec2d75b253af31e6138a544bfb10" translate="yes" xml:space="preserve">
          <source>to suit the layout of current version of Perl first. Do not forget to pack the necessary external DLLs accordingly. Include the description of the bugs and test suite failures you could not fix. Include the small-stack versions of Perl executables from Perl build directory.</source>
          <target state="translated">현재 Perl의 현재 버전의 레이아웃에 적합합니다. 필요한 외부 DLL을 적절히 포장하는 것을 잊지 마십시오. 수정할 수없는 버그 및 테스트 스위트 실패에 대한 설명을 포함 시키십시오. Perl 빌드 디렉토리에서 작은 스택 버전의 Perl 실행 파일을 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="d1c024f5a78b5c864f433d9aa8be1a594410912a" translate="yes" xml:space="preserve">
          <source>to text in verbatim paragraphs.</source>
          <target state="translated">구두 단락의 텍스트로.</target>
        </trans-unit>
        <trans-unit id="82ccf1b1bbc5c3b63172011418c70aeccf1f6b30" translate="yes" xml:space="preserve">
          <source>to the &quot;new&quot;</source>
          <target state="translated">&quot;신규&quot;</target>
        </trans-unit>
        <trans-unit id="76d71a404d5345ef6d530d878a49399365e670e1" translate="yes" xml:space="preserve">
          <source>to the &lt;code&gt;Encode&lt;/code&gt; object that is used to convert the source code to Unicode. Thanks to this variable your Perl script does not have to be written in UTF-8. Default is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">받는 &lt;code&gt;Encode&lt;/code&gt; 유니 코드로 소스 코드를 변환하는 데 사용되는 객체입니다. 이 변수 덕분에 Perl 스크립트는 UTF-8로 작성 될 필요가 없습니다. 기본값은 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ef269923d5b7dae5520c4b226e661ab154e306ec" translate="yes" xml:space="preserve">
          <source>to the array. For example:</source>
          <target state="translated">배열에. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="216f5d19c604dee2234673a86b502cfd302349ee" translate="yes" xml:space="preserve">
          <source>to the corresponding character sequence. That is, it replaces each sequence of characters in the string whose ords represent a valid UTF-X byte sequence, with the corresponding single character. The UTF-8 flag is turned on only if the source string contains multiple-byte</source>
          <target state="translated">해당 문자 순서로. 즉, ords가 유효한 UTF-X 바이트 시퀀스를 나타내는 문자열의 각 문자 시퀀스를 해당 단일 문자로 바꿉니다. UTF-8 플래그는 소스 문자열에 멀티 바이트가 포함 된 경우에만 켜집니다</target>
        </trans-unit>
        <trans-unit id="df3d9a1670821c7cf27d25bf5204f4ccff8c1fdf" translate="yes" xml:space="preserve">
          <source>to the distribution. That file may contain typemaps that either map types that are specific to your code or that override the core typemap file's mappings for common C types.</source>
          <target state="translated">분포에. 이 파일에는 코드에 고유 한 유형을 매핑하거나 공통 C 유형에 대한 핵심 유형 맵 파일의 매핑을 재정의하는 유형 맵이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ec04bffb5a640e2121f16fb9848428ade56baa9" translate="yes" xml:space="preserve">
          <source>to the equivalent octet sequence in the native encoding (Latin-1 or EBCDIC). The logical character sequence itself is unchanged. If</source>
          <target state="translated">고유 인코딩 (라틴 -1 또는 EBCDIC)의 등가 옥텟 서열. 논리 문자 순서 자체는 변경되지 않습니다. 만약</target>
        </trans-unit>
        <trans-unit id="82e5d8f0d33f3fc1c4fe24b9dc376060a9b0b882" translate="yes" xml:space="preserve">
          <source>to the file</source>
          <target state="translated">파일로</target>
        </trans-unit>
        <trans-unit id="90227e286453c7d696a369902dc40165bb310c1b" translate="yes" xml:space="preserve">
          <source>to the internal suspects list.</source>
          <target state="translated">내부 용의자 목록에</target>
        </trans-unit>
        <trans-unit id="bd12956f16da3a5cd11f46459e6fbfa6aaa9eb4f" translate="yes" xml:space="preserve">
          <source>to the list of directories to search.</source>
          <target state="translated">검색 할 디렉토리 목록에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="8b76166173a60a9172a00fdc4b02f8ec0fddaa92" translate="yes" xml:space="preserve">
          <source>to the package &lt;code&gt;symbolic&lt;/code&gt; . After this change one can do</source>
          <target state="translated">&lt;code&gt;symbolic&lt;/code&gt; 패키지에 . 이 변경 후에는 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="127369588e3806f5dfab2b9107e9f8ad65279c04" translate="yes" xml:space="preserve">
          <source>to the root object is returned. In case an I/O error occurs while reading, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned instead. Other serious errors are propagated via &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">루트 개체에 반환됩니다. 읽는 동안 I / O 오류가 발생하면 대신 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 반환됩니다. 다른 심각한 오류는 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 를 통해 전파됩니다 .</target>
        </trans-unit>
        <trans-unit id="f6e9d0a538125eee9f8d6f4cbaa30a1b1fff30fb" translate="yes" xml:space="preserve">
          <source>to the rounded value.</source>
          <target state="translated">반올림 된 값으로.</target>
        </trans-unit>
        <trans-unit id="8e225bf1778d80454bbe7a90c5d48ef2598d7c96" translate="yes" xml:space="preserve">
          <source>to this sample program ensures that the output is completely UTF-8, and removes the program's warning.</source>
          <target state="translated">이 샘플 프로그램은 출력이 완전히 UTF-8인지 확인하고 프로그램의 경고를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="c2e0e9641a1cfa05ec7cd1760997deb3abf87d90" translate="yes" xml:space="preserve">
          <source>to translate POD (Plain Old Documentation - see &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt; for an explanation) into a manpage, and then run</source>
          <target state="translated">POD (Plain Old Documentation- 설명 은 &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt; 참조 )를 맨 페이지 로 번역 한 다음 실행</target>
        </trans-unit>
        <trans-unit id="394511bb26b8cb98ffae20ceec14f71843c11b8f" translate="yes" xml:space="preserve">
          <source>to translate to the number of seconds which need to be added to UTC to get local time.</source>
          <target state="translated">현지 시간을 얻기 위해 UTC에 추가 해야하는 초 수로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="8b5522aa687ede8069f95ce7a57a06f86362ef8d" translate="yes" xml:space="preserve">
          <source>to undo the feature-enabling side effects of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 의 기능 사용 부작용을 취소합니다 .</target>
        </trans-unit>
        <trans-unit id="4c8814f0c0136ae299e1d978d9223309dc3f3753" translate="yes" xml:space="preserve">
          <source>to undo the feature-enabling side effects of &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; &lt;a href=&quot;use&quot;&gt;사용&lt;/a&gt; 의 기능 사용 부작용을 취소합니다 .</target>
        </trans-unit>
        <trans-unit id="8ff66ab810bf6e49f296603698cb9fb951159b36" translate="yes" xml:space="preserve">
          <source>to update Encode::ConfigLocal, a module that controls local settings. After that, &quot;use Encode;&quot; is enough to load your encodings on demand.</source>
          <target state="translated">로컬 설정을 제어하는 ​​모듈 인 Encode :: ConfigLocal을 업데이트합니다. 그 후 &quot;Use Encode;&quot; 필요에 따라 인코딩을로드하기에 충분합니다.</target>
        </trans-unit>
        <trans-unit id="508860c3910e4168b4709c6d24074c802ac6c067" translate="yes" xml:space="preserve">
          <source>to use Perl debugger (see &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;) to debug your PM application (but beware of the message loop lockups - this will not work if you have a message queue to serve, unless you hook the serving into the getc() function of the debugger).</source>
          <target state="translated">PM 애플리케이션을 디버깅 하기 위해 Perl 디버거 ( &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt; 참조 )를 사용하는 것 (하지만 메시지 루프 잠금을주의하십시오-디버거의 getc () 함수에 서빙을 연결하지 않으면 메시지 큐가있는 경우 작동하지 않습니다) .</target>
        </trans-unit>
        <trans-unit id="6c9ee0e1ac650adceaf23fd25a2609a5e096e7ba" translate="yes" xml:space="preserve">
          <source>to use literal backslashes within &lt;code&gt;\Q...\E&lt;/code&gt; , consult &lt;a href=&quot;perlop#Gory-details-of-parsing-quoted-constructs&quot;&gt;Gory details of parsing quoted constructs in perlop&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;\Q...\E&lt;/code&gt; 내에서 리터럴 백 슬래시를 사용하려면 &lt;a href=&quot;perlop#Gory-details-of-parsing-quoted-constructs&quot;&gt;인용 된 구문을 구문 분석하는 perry의 Gory 세부 사항을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3f4243d26108dc891c09891b9e0d53323cc3f1aa" translate="yes" xml:space="preserve">
          <source>to use long longs for the 64-bit integer type, in case you don't have a 64-bit CPU.</source>
          <target state="translated">64 비트 CPU가없는 경우 64 비트 정수 유형에 대해 long long을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="71eaa770d8f526077b4f3192342bbb1dc3e73f22" translate="yes" xml:space="preserve">
          <source>to use the following @INC:</source>
          <target state="translated">다음 @INC를 사용하려면</target>
        </trans-unit>
        <trans-unit id="c41a5a2ce143dfaf438913c7854dc4c3a8171d12" translate="yes" xml:space="preserve">
          <source>to verify how your CLI passes the arguments to the program.</source>
          <target state="translated">CLI가 인수를 프로그램에 전달하는 방법을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="c1b9231e94fd8b3c3cab617ce687784026021ccb" translate="yes" xml:space="preserve">
          <source>to work as expected.</source>
          <target state="translated">예상대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="86f28e5ec97934fa33153df2fc5e2b5b65583051" translate="yes" xml:space="preserve">
          <source>to.</source>
          <target state="translated">to.</target>
        </trans-unit>
        <trans-unit id="ba1cfdcd865f3b87bcc9595dd395087b084ac080" translate="yes" xml:space="preserve">
          <source>to:</source>
          <target state="translated">to:</target>
        </trans-unit>
        <trans-unit id="9461b677437869b4caa6ae020e205909485b9fed" translate="yes" xml:space="preserve">
          <source>toke.c</source>
          <target state="translated">toke.c</target>
        </trans-unit>
        <trans-unit id="3b1ebaa6a9e7c2d892d7a35c0681619b6af90370" translate="yes" xml:space="preserve">
          <source>token are split out into separate files. Some routines may be placed prior to this marker to force their immediate loading and parsing.</source>
          <target state="translated">토큰은 별도의 파일로 분할됩니다. 이 마커 앞에 일부 루틴을 배치하여 즉시로드 및 구문 분석을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac1c3db3f21e326855ec671f236713cdbe520c2c" translate="yes" xml:space="preserve">
          <source>tolerate arbitrarily large amounts of text in the &quot;=item</source>
          <target state="translated">&quot;= 항목에 임의로 많은 양의 텍스트를 허용</target>
        </trans-unit>
        <trans-unit id="d9ae998ab9e8ebfc629710b723541fc505ed244c" translate="yes" xml:space="preserve">
          <source>tom (at) compton.nu</source>
          <target state="translated">톰 (at) compton.nu</target>
        </trans-unit>
        <trans-unit id="903d7da65d624842b5db58b63ef8eaae82b048be" translate="yes" xml:space="preserve">
          <source>tom@compton.nu</source>
          <target state="translated">tom@compton.nu</target>
        </trans-unit>
        <trans-unit id="164a5c24f5df5918f285228443ab87209785293f" translate="yes" xml:space="preserve">
          <source>too</source>
          <target state="translated">too</target>
        </trans-unit>
        <trans-unit id="b47f0da3aa6e0a239f5e94e0877b31f25e13bf8a" translate="yes" xml:space="preserve">
          <source>too.</source>
          <target state="translated">too.</target>
        </trans-unit>
        <trans-unit id="426267451d2aab91845a1f7b22772772450c1009" translate="yes" xml:space="preserve">
          <source>too. Add this line BEFORE any section definition:</source>
          <target state="translated">너무. 섹션 정의 전에이 행을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="90edf77c811db872526b3b484bef9279ab6440fb" translate="yes" xml:space="preserve">
          <source>tool can then display the collected data in various ways. Usually</source>
          <target state="translated">도구는 수집 된 데이터를 다양한 방식으로 표시 할 수 있습니다. 보통</target>
        </trans-unit>
        <trans-unit id="ccb51450d25446e81f4942d86de10a8c406492b5" translate="yes" xml:space="preserve">
          <source>tool included with Perl 5. Bug reports will be included in the Perl 5 ticket system at &lt;a href=&quot;http://rt.perl.org&quot;&gt;http://rt.perl.org&lt;/a&gt;.</source>
          <target state="translated">버그 보고서는 Perl 5 티켓 시스템 ( &lt;a href=&quot;http://rt.perl.org&quot;&gt;http://rt.perl.org)에 포함&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="8f39224c5c445b7f4c4eea9f381baa177eb7cb91" translate="yes" xml:space="preserve">
          <source>tool installed.</source>
          <target state="translated">도구가 설치되었습니다.</target>
        </trans-unit>
        <trans-unit id="88aa984e8c2d55237b91314cbcf92140805cfef9" translate="yes" xml:space="preserve">
          <source>tool that comes with Perl tries to convert C include files to Perl code, which can be &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;d. FIONREAD ends up defined as a function in the</source>
          <target state="translated">펄과 함께 제공 도구는 C가 할 수있는 펄 코드 파일 포함 변환하려고 할 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; D를. FIONREAD는</target>
        </trans-unit>
        <trans-unit id="f92adaa38df139e8b7202b087183871bcb1dd01c" translate="yes" xml:space="preserve">
          <source>tool. If you fix or enhance a performance issue, you may want to add a representative code sample to the file, then run</source>
          <target state="translated">수단. 성능 문제를 수정하거나 향상시키는 경우 대표 코드 샘플을 파일에 추가 한 후 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="8cd3fb1667a905290c5b0e870e6cf4f615dde4f7" translate="yes" xml:space="preserve">
          <source>tool_autosplit</source>
          <target state="translated">tool_autosplit</target>
        </trans-unit>
        <trans-unit id="b8623287e2d342133af98c4af1a3151d917692c2" translate="yes" xml:space="preserve">
          <source>tools_other</source>
          <target state="translated">tools_other</target>
        </trans-unit>
        <trans-unit id="156806de8ef990a34b3ac6280c26b4ecca6c2b47" translate="yes" xml:space="preserve">
          <source>top_anchor</source>
          <target state="translated">top_anchor</target>
        </trans-unit>
        <trans-unit id="b415e16fbe4ca40f22707a97322b49cb9bc5e487" translate="yes" xml:space="preserve">
          <source>topic</source>
          <target state="translated">topic</target>
        </trans-unit>
        <trans-unit id="4f83d880aeb0e2a0498a5bc0e8ac975990e97449" translate="yes" xml:space="preserve">
          <source>tored by Gurusamy Sarathy (&amp;lt;gsar@activestate.com&amp;gt;), Tom Christiansen (&amp;lt;tchrist@perl.com&amp;gt;), Nathan Torkington (&amp;lt;gnat@frii.com&amp;gt;), Charles F. Randall (&amp;lt;cfr@pobox.com&amp;gt;), Mike Guy (&amp;lt;mjtg@cam.ac.uk&amp;gt;), Dominic Dunlop (&amp;lt;domo@computer.org&amp;gt;), Hugo van der Sanden (&amp;lt;hv@crypt.org&amp;gt;), Jarkko Hietaniemi (&amp;lt;jhi@iki.fi&amp;gt;), Chris Nandor (&amp;lt;pudge@pobox.com&amp;gt;), Jon Orwant (&amp;lt;orwant@media.mit.edu&amp;gt;, Richard Foley (&amp;lt;richard.foley@rfi.net&amp;gt;), Jesse Vincent (&amp;lt;jesse@bestpractical.com&amp;gt;), and Craig A. Berry (&amp;lt;craigberry@mac.com&amp;gt;).</source>
          <target state="translated">Gurusamy Sarathy (&amp;lt;gsar@activestate.com&amp;gt;), Tom Christiansen (&amp;lt;tchrist@perl.com&amp;gt;), Nathan Torkington (&amp;lt;gnat@frii.com&amp;gt;), Charles F. Randall (&amp;lt;cfr@pobox.com&amp;gt;) ), Mike Guy (&amp;lt;mjtg@cam.ac.uk&amp;gt;), Dominic Dunlop (&amp;lt;domo@computer.org&amp;gt;), Hugo van der Sanden (&amp;lt;hv@crypt.org&amp;gt;), Jarkko Hietaniemi (&amp;lt;jhi @ iki. fi&amp;gt;), Chris Nandor (&amp;lt;pudge@pobox.com&amp;gt;), Jon Orwant (&amp;lt;orwant@media.mit.edu&amp;gt;, Richard Foley (&amp;lt;richard.foley@rfi.net&amp;gt;)), Jesse Vincent (&amp;lt;jesse @ bestpractical .com&amp;gt; 및 Craig A. Berry (&amp;lt;craigberry@mac.com&amp;gt;).</target>
        </trans-unit>
        <trans-unit id="f946bb4c412cec0161b446353e7e1a4ee67a20e7" translate="yes" xml:space="preserve">
          <source>total number of bytes</source>
          <target state="translated">총 바이트 수</target>
        </trans-unit>
        <trans-unit id="d9e83874d260f2f10d48d98c0b773b836096d426" translate="yes" xml:space="preserve">
          <source>tr</source>
          <target state="translated">tr</target>
        </trans-unit>
        <trans-unit id="c39522f52c3ec29023c219c19d4067a9b3eee877" translate="yes" xml:space="preserve">
          <source>tr///</source>
          <target state="translated">tr///</target>
        </trans-unit>
        <trans-unit id="536783780cbdb29a264e212e15753a5bedd082e3" translate="yes" xml:space="preserve">
          <source>trailingData</source>
          <target state="translated">trailingData</target>
        </trans-unit>
        <trans-unit id="15c4593ae86e3bf2017dc51f07fb9e08cc13291e" translate="yes" xml:space="preserve">
          <source>translates a list of numbers to the corresponding characters.</source>
          <target state="translated">숫자 목록을 해당 문자로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="34d7fc1774ad1e06f48d4d6adb73b20c2ab97c2b" translate="yes" xml:space="preserve">
          <source>translates a list of numbers to their squared values.</source>
          <target state="translated">숫자 목록을 제곱 된 값으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="b957f6243dc857b0d32b836fc652ac09fad6dc17" translate="yes" xml:space="preserve">
          <source>translates to any other string, that string is used as the name of a logical name table, which is consulted using</source>
          <target state="translated">다른 문자열로 변환합니다. 해당 문자열은 논리 이름 테이블의 이름으로 사용되며, 다음을 사용하여 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="b83065734825ace6b5d6e623f5d8b917a787ab2d" translate="yes" xml:space="preserve">
          <source>translating the small parts into regexps,</source>
          <target state="translated">작은 부분을 정규 표현식으로 변환</target>
        </trans-unit>
        <trans-unit id="7982afa4ce12a15076ad30ff5a7c216bd7dd8013" translate="yes" xml:space="preserve">
          <source>transliterates into</source>
          <target state="translated">음역하다</target>
        </trans-unit>
        <trans-unit id="38bedfbdef70fc53b2e50e67a65d5f48bdccc217" translate="yes" xml:space="preserve">
          <source>trap (OP, ...), untrap (OP, ...)</source>
          <target state="translated">트랩 (OP, ...), 트랩 해제 (OP, ...)</target>
        </trans-unit>
        <trans-unit id="ce03721ca3b28ce2f21226c122a3dc4ab883c73d" translate="yes" xml:space="preserve">
          <source>treated</source>
          <target state="translated">treated</target>
        </trans-unit>
        <trans-unit id="42dc828341bea99e4235ff61dd8d9128d8bccb29" translate="yes" xml:space="preserve">
          <source>trial.gz</source>
          <target state="translated">trial.gz</target>
        </trans-unit>
        <trans-unit id="d67deefa1e5c2dfdd8fc91aa3b6e2acaad1cff89" translate="yes" xml:space="preserve">
          <source>tries to load optional library but also dies if library is not available</source>
          <target state="translated">선택적 라이브러리를로드하려고 시도하지만 라이브러리를 사용할 수없는 경우에도 사망</target>
        </trans-unit>
        <trans-unit id="d32c5b68132ef2211100518b2ca2f7847b516c84" translate="yes" xml:space="preserve">
          <source>trnl.U</source>
          <target state="translated">trnl.U</target>
        </trans-unit>
        <trans-unit id="cc4728d0763649871c56fd8cb6de629f5fbf5b84" translate="yes" xml:space="preserve">
          <source>troff(1)</source>
          <target state="translated">troff(1)</target>
        </trans-unit>
        <trans-unit id="5ffe533b830f08a0326348a9160afafc8ada44db" translate="yes" xml:space="preserve">
          <source>true</source>
          <target state="translated">true</target>
        </trans-unit>
        <trans-unit id="438789e48d4c0e2a17e93fb22d092028b03bb360" translate="yes" xml:space="preserve">
          <source>true if the Perl library was compiled in AOUT format.</source>
          <target state="translated">Perl 라이브러리가 AOUT 형식으로 컴파일 된 경우 true입니다.</target>
        </trans-unit>
        <trans-unit id="59e4766fb49e429a8314ef2500009926b97e90d6" translate="yes" xml:space="preserve">
          <source>true if the current executable is an AOUT EMX executable, so Perl can fork. Do not use this, use the portable check for $Config::Config{dfork}.</source>
          <target state="translated">현재 실행 파일이 AOUT EMX 실행 파일이면 펄은 포크 할 수 있습니다. 이것을 사용하지 말고 $ Config :: Config {dfork}에 대해 휴대용 검사를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1bcf5542764919cf26fda2e66c73aa29f02ef9a2" translate="yes" xml:space="preserve">
          <source>true if this pref has a 'match' attribute and at least one valid match attribute</source>
          <target state="translated">이 pref에 'match'속성과 하나 이상의 유효한 match 속성이있는 경우 true</target>
        </trans-unit>
        <trans-unit id="3fce60a5697d8001beb7164eaf5a9b21b4de4c72" translate="yes" xml:space="preserve">
          <source>true if this pref has a 'match' attribute at all</source>
          <target state="translated">이 pref에 'match'속성이 있으면 true</target>
        </trans-unit>
        <trans-unit id="1e9cc6decc0c9571c723bb4ad00488c48abdc585" translate="yes" xml:space="preserve">
          <source>true if this pref matches the passed-in hashref, which must have a value for each of the &lt;code&gt;match_attributes&lt;/code&gt; (above)</source>
          <target state="translated">이 pref가 건네받은 hashref에 일치하는 경우는 true. 각 &lt;code&gt;match_attributes&lt;/code&gt; (상기) 의 값을 가져야한다</target>
        </trans-unit>
        <trans-unit id="cb4b42b99367dbaef3b308097c9d0a1cff17603b" translate="yes" xml:space="preserve">
          <source>true in &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub{}&lt;/a&gt;&lt;/code&gt;, or contrary to popular belief &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do{}&lt;/a&gt;&lt;/code&gt; blocks, which do</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub{}&lt;/a&gt;&lt;/code&gt; 에서 true 또는 대중적 신념에 위배되는 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do{}&lt;/a&gt;&lt;/code&gt; 블록</target>
        </trans-unit>
        <trans-unit id="66fe2fdee953072a309daa163ca5ed615049d0c2" translate="yes" xml:space="preserve">
          <source>trueop</source>
          <target state="translated">trueop</target>
        </trans-unit>
        <trans-unit id="90099b2e34aa9d96304e9cb4c2b9ae07073445c0" translate="yes" xml:space="preserve">
          <source>truly</source>
          <target state="translated">truly</target>
        </trans-unit>
        <trans-unit id="f283ea9bea0e80213ac091021420ffc9b3415914" translate="yes" xml:space="preserve">
          <source>truncate</source>
          <target state="translated">truncate</target>
        </trans-unit>
        <trans-unit id="a1261bf96d8d4c6b4b727d215938b97e14a121ae" translate="yes" xml:space="preserve">
          <source>truncate EXPR,LENGTH</source>
          <target state="translated">EXPR, LENGTH 자르기</target>
        </trans-unit>
        <trans-unit id="c0a4a0ea2c037915554ed29699877c89805a57bd" translate="yes" xml:space="preserve">
          <source>truncate FILEHANDLE,LENGTH</source>
          <target state="translated">FILEHANDLE, LENGTH 자르기</target>
        </trans-unit>
        <trans-unit id="53028b90056316570dad36dc627a6b17c0330b6d" translate="yes" xml:space="preserve">
          <source>truncation invariably removes all digits following the rounding place, replacing them with zeros. Thus, 987.65 rounded to tens (P=1) becomes 980, and rounded to the fourth sigdig becomes 987.6 (A=4). 123.456 rounded to the second place after the decimal point (P=-2) becomes 123.46.</source>
          <target state="translated">잘림은 반올림 위치 다음의 모든 숫자를 항상 제거하고 0으로 대체합니다. 따라서 10으로 반올림 한 987.65 (P = 1)는 980이되고, 4 번째 시그 디그로 반올림 한 것은 987.6 (A = 4)이됩니다. 소수점 (P = -2)이 123.46이 된 후 123.456은 두 번째 자리로 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="45fa151bf9a11c0e25734df135de9edd4ff738df" translate="yes" xml:space="preserve">
          <source>truth</source>
          <target state="translated">truth</target>
        </trans-unit>
        <trans-unit id="823fca4f1093d64814a9d2afbcda71b935d03e40" translate="yes" xml:space="preserve">
          <source>try something like the following:</source>
          <target state="translated">다음과 같은 것을 시도하십시오 :</target>
        </trans-unit>
        <trans-unit id="ce6d1c45f4e5ab6843ee500a73af34957d4c92aa" translate="yes" xml:space="preserve">
          <source>try to equate new (and never-used, and unusable) ISO639-2 three-letter tags to old (and still in use) ISO639-1 two-letter equivalents -- like &quot;ara&quot; -&amp;gt; &quot;ar&quot; -- because &quot;ara&quot; has</source>
          <target state="translated">새롭고 (사용하지 않았으며 사용할 수없는) ISO639-2 3 글자 태그를 &quot;ara&quot;-&amp;gt; &quot;ar&quot;와 같이 기존 (아직 사용중인) ISO639-1 2 글자 태그에 동일하게 사용하십시오. &quot; 아라 &quot;있다</target>
        </trans-unit>
        <trans-unit id="cb050805b03c907314122eca2548681495db1636" translate="yes" xml:space="preserve">
          <source>tst.fil</source>
          <target state="translated">tst.fil</target>
        </trans-unit>
        <trans-unit id="9f160f66c4d781a33c60820b496697aaf2bd47ff" translate="yes" xml:space="preserve">
          <source>tty(1)</source>
          <target state="translated">tty(1)</target>
        </trans-unit>
        <trans-unit id="6b7c4b72eb87c9f9986fb12efd7d83af95caa365" translate="yes" xml:space="preserve">
          <source>turkic</source>
          <target state="translated">turkic</target>
        </trans-unit>
        <trans-unit id="bb900dfa419ab730b52dadfa0dfec48b9c5a6aba" translate="yes" xml:space="preserve">
          <source>turns debugging on for all packages.</source>
          <target state="translated">모든 패키지에 대한 디버깅을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="8a1f73e9662f187f57c576ccd9399ebd14ab3421" translate="yes" xml:space="preserve">
          <source>turns into</source>
          <target state="translated">로 변하다</target>
        </trans-unit>
        <trans-unit id="85691f9a0ab6bb1c21ccb666a6135b2368136c66" translate="yes" xml:space="preserve">
          <source>turns on &quot;taint&quot; so you can test them. Ordinarily these checks are done only when running setuid or setgid. It's a good idea to turn them on explicitly for programs that run on behalf of someone else whom you might not necessarily trust, such as CGI programs or any internet servers you might write in Perl. See &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; for details. For security reasons, this option must be seen by Perl quite early; usually this means it must appear early on the command line or in the &lt;code&gt;#!&lt;/code&gt; line for systems which support that construct.</source>
          <target state="translated">테스트 할 수 있도록 &quot;오염 물질&quot;을 켭니다. 일반적으로 이러한 검사는 setuid 또는 setgid를 실행할 때만 수행됩니다. CGI 프로그램 또는 Perl로 작성할 수있는 인터넷 서버와 같이 반드시 신뢰할 수없는 다른 사람을 대신하여 실행되는 프로그램에 대해 명시 적으로 설정하는 것이 좋습니다. 자세한 내용은 &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; 을 참조하십시오. 보안상의 이유로 Perl은이 옵션을 매우 일찍 보여야합니다. 일반적으로 이것은 명령 행 또는 &lt;code&gt;#!&lt;/code&gt; 해당 구성을 지원하는 시스템 라인.</target>
        </trans-unit>
        <trans-unit id="ef46c243925d2af48b614f7b9635e2daf263b6a6" translate="yes" xml:space="preserve">
          <source>turns on autosplit mode when used with a &lt;b&gt;-n&lt;/b&gt; or &lt;b&gt;-p&lt;/b&gt;. An implicit split command to the @F array is done as the first thing inside the implicit while loop produced by the &lt;b&gt;-n&lt;/b&gt; or &lt;b&gt;-p&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;-n&lt;/b&gt; 또는 &lt;b&gt;-p&lt;/b&gt; 와 함께 사용하면 자동 분리 모드를 켭니다 . @F 배열에 대한 암시 적 분할 명령은 &lt;b&gt;-n&lt;/b&gt; 또는 &lt;b&gt;-p에&lt;/b&gt; 의해 생성 된 암시 적 while 루프 내에서 첫 번째로 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="eee45a4f6e1f6f37d3488c8a9faeb95e80168595" translate="yes" xml:space="preserve">
          <source>tv_interval ( $ref_to_gettimeofday [, $ref_to_later_gettimeofday] )</source>
          <target state="translated">tv_interval ($ ref_to_gettimeofday [, $ ref_to_later_gettimeofday])</target>
        </trans-unit>
        <trans-unit id="ad782ecdac770fc6eb9a62e44f90873fb97fb26b" translate="yes" xml:space="preserve">
          <source>two</source>
          <target state="translated">two</target>
        </trans-unit>
        <trans-unit id="9c545de6bb84eb94b6126add62f1eef381366296" translate="yes" xml:space="preserve">
          <source>two-dimensional slice</source>
          <target state="translated">2 차원 슬라이스</target>
        </trans-unit>
        <trans-unit id="a123eaabf183286fe1b857fb9fc12040b8b4df03" translate="yes" xml:space="preserve">
          <source>two_face.pm</source>
          <target state="translated">two_face.pm</target>
        </trans-unit>
        <trans-unit id="d0a3e7f81a9885e99049d1cae0336d269d5e47a9" translate="yes" xml:space="preserve">
          <source>type</source>
          <target state="translated">type</target>
        </trans-unit>
        <trans-unit id="5f7b4d8120e3abb8a993bd8c9369e8e492554273" translate="yes" xml:space="preserve">
          <source>type of $bar is a scalar reference, and we do not overload the scalar dereference. Thus we can get the</source>
          <target state="translated">$ bar 유형은 스칼라 참조이며 스칼라 역 참조를 오버로드하지 않습니다. 따라서 우리는 얻을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0f846c66a3d5e2d04d7dad5376934b529b97a76f" translate="yes" xml:space="preserve">
          <source>type of &lt;code&gt;File&lt;/code&gt; . All mp3 files are files, but not all files are mp3 files.</source>
          <target state="translated">&lt;code&gt;File&lt;/code&gt; 유형 . 모든 mp3 파일은 파일이지만 모든 파일이 mp3 파일 인 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="4d48747c7234e695806a5ec0475ca088f8de7d2c" translate="yes" xml:space="preserve">
          <source>type of damage only: FP flags changed when loading a DLL.</source>
          <target state="translated">손상 유형 만 : DLL을로드 할 때 FP 플래그가 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="609d101b171f19730b086799c893b4bced74e281" translate="yes" xml:space="preserve">
          <source>typeglob</source>
          <target state="translated">typeglob</target>
        </trans-unit>
        <trans-unit id="3f6b0af8d4178fa799abd02b53080eb8e0e9d792" translate="yes" xml:space="preserve">
          <source>typemap</source>
          <target state="translated">typemap</target>
        </trans-unit>
        <trans-unit id="e7b1fff7007b635892a8f2c7c17f4fabc7aa2f8c" translate="yes" xml:space="preserve">
          <source>types</source>
          <target state="translated">types</target>
        </trans-unit>
        <trans-unit id="c3c57ccf025216fd17025a5cd72ba43c150e0712" translate="yes" xml:space="preserve">
          <source>typestash</source>
          <target state="translated">typestash</target>
        </trans-unit>
        <trans-unit id="51e69892ab49df85c6230ccc57f8e1d1606caccc" translate="yes" xml:space="preserve">
          <source>u</source>
          <target state="translated">u</target>
        </trans-unit>
        <trans-unit id="4914c57306212f2cc515f07c8cf90f3fabf5399e" translate="yes" xml:space="preserve">
          <source>ualarm(0) will cancel an outstanding ualarm().</source>
          <target state="translated">ualarm (0)은 미해결 ualarm ()을 취소합니다.</target>
        </trans-unit>
        <trans-unit id="3519ace88affd1d0bcd984e15dfaf7b1c1479e99" translate="yes" xml:space="preserve">
          <source>uc</source>
          <target state="translated">uc</target>
        </trans-unit>
        <trans-unit id="46680910c867722cf1e95037ec06eee09df4a0d5" translate="yes" xml:space="preserve">
          <source>uc EXPR</source>
          <target state="translated">UC EXPR</target>
        </trans-unit>
        <trans-unit id="62a2132e3a00127b1e64e2e50602c12c4f218bce" translate="yes" xml:space="preserve">
          <source>ucfirst</source>
          <target state="translated">ucfirst</target>
        </trans-unit>
        <trans-unit id="46c5616dab2749d151e0c53b59ef03e6d4e5ee52" translate="yes" xml:space="preserve">
          <source>ucfirst EXPR</source>
          <target state="translated">ucfirst EXPR</target>
        </trans-unit>
        <trans-unit id="92e6f746eff84e65c584e48e78614108b0c4500a" translate="yes" xml:space="preserve">
          <source>ucmlint</source>
          <target state="translated">ucmlint</target>
        </trans-unit>
        <trans-unit id="85b193ef62ce5bd8f0d8f72987c5acefe070a801" translate="yes" xml:space="preserve">
          <source>ucmsort</source>
          <target state="translated">ucmsort</target>
        </trans-unit>
        <trans-unit id="c9915ec6eb1c1121af4deacd2838d47d88af181c" translate="yes" xml:space="preserve">
          <source>ucsort</source>
          <target state="translated">ucsort</target>
        </trans-unit>
        <trans-unit id="9ab3443b0dd255d92dea875958de03ac53cd401e" translate="yes" xml:space="preserve">
          <source>uid and gid, in that order. A value of -1 in either position is interpreted by most systems to leave that value unchanged. Returns the number of files successfully changed.</source>
          <target state="translated">순서대로 uid와 gid 대부분의 시스템은 어느 위치에서든 -1의 값을 해석하여 해당 값을 변경하지 않고 그대로 둡니다. 성공적으로 변경된 파일 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b14ef85c6823dc1f2ef811c9a63a44faab1dfccc" translate="yes" xml:space="preserve">
          <source>uidf.U</source>
          <target state="translated">uidf.U</target>
        </trans-unit>
        <trans-unit id="4f266624b4cab00c3fa39590bc3e4d402c6054f9" translate="yes" xml:space="preserve">
          <source>uidsign.U</source>
          <target state="translated">uidsign.U</target>
        </trans-unit>
        <trans-unit id="49d287411193cd0643e68cecc7793271c3750fe3" translate="yes" xml:space="preserve">
          <source>uidsize.U</source>
          <target state="translated">uidsize.U</target>
        </trans-unit>
        <trans-unit id="ef4e5b306b52e07f68c82e7e4824b1b0139a919a" translate="yes" xml:space="preserve">
          <source>uidtype.U</source>
          <target state="translated">uidtype.U</target>
        </trans-unit>
        <trans-unit id="4b824f445e8d64ec6f262547c18a3ab02a6fd22c" translate="yes" xml:space="preserve">
          <source>umask</source>
          <target state="translated">umask</target>
        </trans-unit>
        <trans-unit id="36e21e5c3a8f3b270b5c9c2576b01408eed47929" translate="yes" xml:space="preserve">
          <source>umask EXPR</source>
          <target state="translated">umask EXPR</target>
        </trans-unit>
        <trans-unit id="eb6198103dad02d1c9dcb61d16d9ffbac78237d4" translate="yes" xml:space="preserve">
          <source>umask() works, but the correct permissions are only set when the file is finally close()d</source>
          <target state="translated">umask ()는 작동하지만 파일이 마지막으로 닫 혔을 때만 올바른 권한이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="7de840c4a5d7a3a264136f73eb4f2de7198cc159" translate="yes" xml:space="preserve">
          <source>unable to run</source>
          <target state="translated">실행할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="5c9d9a1ee71ab26f80b55634148ddbec55d054c0" translate="yes" xml:space="preserve">
          <source>uncolor() performs the opposite translation as color(), turning escape sequences into a list of strings corresponding to the attributes being set by those sequences.</source>
          <target state="translated">uncolor ()는 color ()와 반대의 변환을 수행하여 이스케이프 시퀀스를 해당 시퀀스에서 설정 한 속성에 해당하는 문자열 목록으로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="894a40dce8e5591059922ff5808e4c093326c141" translate="yes" xml:space="preserve">
          <source>undef</source>
          <target state="translated">undef</target>
        </trans-unit>
        <trans-unit id="98feb57f02fa68186d8b891aea735323789452c7" translate="yes" xml:space="preserve">
          <source>undef EXPR</source>
          <target state="translated">undef EXPR</target>
        </trans-unit>
        <trans-unit id="2e6e324398420050bcebe65786c1ee784c78a29b" translate="yes" xml:space="preserve">
          <source>undefined symbols when it loads a dynamic library. The default behaviour is to resolve symbols when they are used. Setting this variable is useful during testing of extensions, as it ensures that you get an error on misspelled function names even if the test suite doesn't call them.</source>
          <target state="translated">동적 라이브러리를로드 할 때 정의되지 않은 기호 기본 동작은 기호가 사용될 때 기호를 확인하는 것입니다. 이 변수를 설정하면 테스트 스위트가 호출하지 않아도 철자가 틀린 함수 이름에 오류가 발생하므로 확장을 테스트 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b514a784ac2399d445614c88fc7a8533a4e033a5" translate="yes" xml:space="preserve">
          <source>under Unix), which can set important options. (A subroutine (&lt;code&gt;&amp;amp;afterinit&lt;/code&gt; ) can be defined here as well; it is executed after the debugger completes its own initialization.)</source>
          <target state="translated">중요한 옵션을 설정할 수 있습니다. (서브 루틴 ( &lt;code&gt;&amp;amp;afterinit&lt;/code&gt; )도 여기에서 정의 할 수 있으며 디버거가 자체 초기화를 완료 한 후에 실행됩니다.)</target>
        </trans-unit>
        <trans-unit id="9dafb5899098e6cb8288d8485a2851027cdacf0a" translate="yes" xml:space="preserve">
          <source>under Unixy systems.] but here we've specified the port number (13) in parentheses. Using just the number would have also worked, but numeric literals make careful programmers nervous.</source>
          <target state="translated">Unixy systems.] 아래에 괄호 안에 포트 번호 (13)를 지정했습니다. 숫자 만 사용해도 효과가 있었지만 숫자 리터럴은 프로그래머를 조심스럽게 긴장시킵니다.</target>
        </trans-unit>
        <trans-unit id="4fd1ca9b1cc4b71ec35a6a6dcfdad1203f30fb09" translate="yes" xml:space="preserve">
          <source>under control of the &lt;code&gt;$^F&lt;/code&gt; variable. This is so any filehandles you didn't explicitly route to the STDIN, STDOUT or STDERR of a child</source>
          <target state="translated">&lt;code&gt;$^F&lt;/code&gt; 변수 의 제어하에 . 이것은 자식의 STDIN, STDOUT 또는 STDERR에 명시 적으로 라우팅하지 않은 파일 핸들입니다.</target>
        </trans-unit>
        <trans-unit id="7881ed7a3c041a4c372935ce39c3487feea2f64f" translate="yes" xml:space="preserve">
          <source>under the name &lt;code&gt;MY::top_targets&lt;/code&gt; ;</source>
          <target state="translated">이름 : &lt;code&gt;MY::top_targets&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="9f01b49453b711076f00ff8b4dd47a7886a96fc1" translate="yes" xml:space="preserve">
          <source>under the specified locations are automatically included if they exist, with this lookup done at interpreter startup time. In addition, any directories matching the entries in &lt;code&gt;$Config{inc_version_list}&lt;/code&gt; are added. (These typically would be for older compatible perl versions installed in the same directory tree.)</source>
          <target state="translated">인터프리터 시작 시간에이 조회를 수행하여 지정된 위치 아래에 해당 위치가있는 경우 자동으로 포함됩니다. 또한 &lt;code&gt;$Config{inc_version_list}&lt;/code&gt; 의 항목과 일치하는 디렉토리 가 추가됩니다. (일반적으로 동일한 디렉토리 트리에 설치된 이전 버전의 호환 가능한 perl 버전에 해당됩니다.)</target>
        </trans-unit>
        <trans-unit id="c82b67c88e6911c321806d35b9d8f040d8726133" translate="yes" xml:space="preserve">
          <source>underline</source>
          <target state="translated">underline</target>
        </trans-unit>
        <trans-unit id="7455d50fd345c0e29f3dcf49611be6ce0df37457" translate="yes" xml:space="preserve">
          <source>understands the following options:</source>
          <target state="translated">다음 옵션을 이해합니다.</target>
        </trans-unit>
        <trans-unit id="5ddb3081295d2039a2ce92ed30ca850d53c716e6" translate="yes" xml:space="preserve">
          <source>undone during backtracking, and we get</source>
          <target state="translated">역 추적 중에 실행 취소하면</target>
        </trans-unit>
        <trans-unit id="3f9c012699681359b2d4c5c0da4c0c319f7b4851" translate="yes" xml:space="preserve">
          <source>undump</source>
          <target state="translated">undump</target>
        </trans-unit>
        <trans-unit id="8b77486db5e737dfba2f215ad3f09d26e7574ce4" translate="yes" xml:space="preserve">
          <source>ungetc</source>
          <target state="translated">ungetc</target>
        </trans-unit>
        <trans-unit id="611ef7f3e74e93a2d99c8502e80be88ed14c4b7a" translate="yes" xml:space="preserve">
          <source>unicaps</source>
          <target state="translated">unicaps</target>
        </trans-unit>
        <trans-unit id="d0621ea6db045280a171ba1bfb3a6dfa337b7d85" translate="yes" xml:space="preserve">
          <source>unichars</source>
          <target state="translated">unichars</target>
        </trans-unit>
        <trans-unit id="8236ccc893aa3b688923006cde5ef7c867e1200f" translate="yes" xml:space="preserve">
          <source>unicore/</source>
          <target state="translated">unicore/</target>
        </trans-unit>
        <trans-unit id="34819feb4a120661fd90c7edb70e9578267e83cd" translate="yes" xml:space="preserve">
          <source>unicore/README.perl</source>
          <target state="translated">unicore/README.perl</target>
        </trans-unit>
        <trans-unit id="9cef115904c9a43eab6bd725f98fb0e895022817" translate="yes" xml:space="preserve">
          <source>unicore/mktables</source>
          <target state="translated">unicore/mktables</target>
        </trans-unit>
        <trans-unit id="695753c5963950095c0928d372a2deb661f1bf28" translate="yes" xml:space="preserve">
          <source>unifmt</source>
          <target state="translated">unifmt</target>
        </trans-unit>
        <trans-unit id="c2b5c55f0827d9c553bdc5a4de94a5d8d20f474b" translate="yes" xml:space="preserve">
          <source>unilook</source>
          <target state="translated">unilook</target>
        </trans-unit>
        <trans-unit id="b1217427083e0f38e61077d9500c698e2f3ef93b" translate="yes" xml:space="preserve">
          <source>unimplemented in this platform</source>
          <target state="translated">이 플랫폼에서 구현되지 않은</target>
        </trans-unit>
        <trans-unit id="c9f59799203ace15feeda610ffd283211d4c8395" translate="yes" xml:space="preserve">
          <source>uninames</source>
          <target state="translated">uninames</target>
        </trans-unit>
        <trans-unit id="e375ed02e8215d5defda8610a10331083ab72346" translate="yes" xml:space="preserve">
          <source>uninarrow</source>
          <target state="translated">uninarrow</target>
        </trans-unit>
        <trans-unit id="328bff70ae4c6a47b6b25e9441f490474af8e448" translate="yes" xml:space="preserve">
          <source>uniprops</source>
          <target state="translated">uniprops</target>
        </trans-unit>
        <trans-unit id="247380163f42421ae2d703eb8679cd83b34870e9" translate="yes" xml:space="preserve">
          <source>uniquote</source>
          <target state="translated">uniquote</target>
        </trans-unit>
        <trans-unit id="4c65113b300dbe7d18a1abac20294d929a7ffe75" translate="yes" xml:space="preserve">
          <source>unisubs</source>
          <target state="translated">unisubs</target>
        </trans-unit>
        <trans-unit id="81fb19e7a4af499b20a01cf4f84c2eb70605d5c9" translate="yes" xml:space="preserve">
          <source>unisupers</source>
          <target state="translated">unisupers</target>
        </trans-unit>
        <trans-unit id="4a58aa07cd9c7fe995d8e039ce466daabed183ad" translate="yes" xml:space="preserve">
          <source>unititle</source>
          <target state="translated">unititle</target>
        </trans-unit>
        <trans-unit id="4869ecdc8289baa1bc191dbc361750e4e3bdf4ad" translate="yes" xml:space="preserve">
          <source>uniwc</source>
          <target state="translated">uniwc</target>
        </trans-unit>
        <trans-unit id="2a82b2c6779fce7a27aa805912edf1a4e6a2a894" translate="yes" xml:space="preserve">
          <source>uniwide</source>
          <target state="translated">uniwide</target>
        </trans-unit>
        <trans-unit id="dc9206a6415e9837c874d5d503ed24b6c771aaa0" translate="yes" xml:space="preserve">
          <source>unknown methods</source>
          <target state="translated">알 수없는 방법</target>
        </trans-unit>
        <trans-unit id="42e184930956d048c819e40f18f94f0094d47bc6" translate="yes" xml:space="preserve">
          <source>unless</source>
          <target state="translated">unless</target>
        </trans-unit>
        <trans-unit id="15358cd04268c58ca1fc4bee824af0b4d7a6f722" translate="yes" xml:space="preserve">
          <source>unless its already there.</source>
          <target state="translated">이미 존재하지 않는 한.</target>
        </trans-unit>
        <trans-unit id="17ad721591ccd7748e1c7959af21fb641d063512" translate="yes" xml:space="preserve">
          <source>unless needed (metachars found).</source>
          <target state="translated">필요한 경우가 아니면 (메타 차르 발견).</target>
        </trans-unit>
        <trans-unit id="d8416865eb0efe0f795590dee12d7f0bc0f6bdd0" translate="yes" xml:space="preserve">
          <source>unless stated otherwise.</source>
          <target state="translated">달리 언급되지 않는 한.</target>
        </trans-unit>
        <trans-unit id="7b91025887687e8951f32135d89cf33a54553e45" translate="yes" xml:space="preserve">
          <source>unlink</source>
          <target state="translated">unlink</target>
        </trans-unit>
        <trans-unit id="2f7ab4d1414a38eaf72b218d2bc6396a10c7c03b" translate="yes" xml:space="preserve">
          <source>unlink LIST</source>
          <target state="translated">LIST 연결 해제</target>
        </trans-unit>
        <trans-unit id="ca9428c77b6e9175521ac643429f5441f83e1362" translate="yes" xml:space="preserve">
          <source>unlock_hash() does the opposite of lock_hash(). All keys and values are made writable. All values can be changed and keys can be added and deleted.</source>
          <target state="translated">unlock_hash ()는 lock_hash ()와 반대입니다. 모든 키와 값을 쓸 수 있습니다. 모든 값을 변경하고 키를 추가 및 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05e5c85735ed74105bc5422998ce82f311785a5b" translate="yes" xml:space="preserve">
          <source>unlock_hash_recurse() does the opposite of lock_hash_recurse(). All keys and values are made writable. All values can be changed and keys can be added and deleted. Identical recursion restrictions apply as to lock_hash_recurse().</source>
          <target state="translated">unlock_hash_recurse ()는 lock_hash_recurse ()와 반대로 작동합니다. 모든 키와 값을 쓸 수 있습니다. 모든 값을 변경하고 키를 추가 및 삭제할 수 있습니다. lock_hash_recurse ()와 동일한 재귀 제한이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="15e49863432c89071dddfddf04017fe4b06da4a4" translate="yes" xml:space="preserve">
          <source>unmemoize</source>
          <target state="translated">unmemoize</target>
        </trans-unit>
        <trans-unit id="9a106745b32b1bc24d96df74906aa49ca0a5bab7" translate="yes" xml:space="preserve">
          <source>unpack</source>
          <target state="translated">unpack</target>
        </trans-unit>
        <trans-unit id="ad26ce7bca64b2cdad8c6ebcce728e4fe4dc8d68" translate="yes" xml:space="preserve">
          <source>unpack TEMPLATE</source>
          <target state="translated">템플릿 포장 풀기</target>
        </trans-unit>
        <trans-unit id="d51158b8ba32894fc3f16c818771c4ff1c948b25" translate="yes" xml:space="preserve">
          <source>unpack TEMPLATE,EXPR</source>
          <target state="translated">TEMPLATE, EXPR 포장 풀기</target>
        </trans-unit>
        <trans-unit id="519f72fe3d89c3099ea41ae1c802c97bdc5eadc1" translate="yes" xml:space="preserve">
          <source>unsets debug mode for packages.</source>
          <target state="translated">패키지의 디버그 모드를 설정 해제합니다.</target>
        </trans-unit>
        <trans-unit id="aa81750b23852766b6c1312c52c74e8e43376ec7" translate="yes" xml:space="preserve">
          <source>unshift</source>
          <target state="translated">unshift</target>
        </trans-unit>
        <trans-unit id="e7cfc09be72c471dc24ba67fa64a04d2094e0c98" translate="yes" xml:space="preserve">
          <source>unshift ARRAY,LIST</source>
          <target state="translated">배열 ARRAY, LIST</target>
        </trans-unit>
        <trans-unit id="7c2f42f7576eda73695913606951c9319ab37f8b" translate="yes" xml:space="preserve">
          <source>unshift EXPR,LIST</source>
          <target state="translated">EXPR, LIST 이동</target>
        </trans-unit>
        <trans-unit id="6960baf3f3c0a0ba2056861718b4e11ab734837d" translate="yes" xml:space="preserve">
          <source>unsigned integer, the same size as</source>
          <target state="translated">부호없는 정수</target>
        </trans-unit>
        <trans-unit id="71a357a89ef6c8cc2c4b8fede70ba2f64a1fb87a" translate="yes" xml:space="preserve">
          <source>untaint_pattern</source>
          <target state="translated">untaint_pattern</target>
        </trans-unit>
        <trans-unit id="08257bf290350a2f8d16f85ae7fda5d81b518918" translate="yes" xml:space="preserve">
          <source>untie</source>
          <target state="translated">untie</target>
        </trans-unit>
        <trans-unit id="41ffa486976cc60b0d9967f715609a090b4a3233" translate="yes" xml:space="preserve">
          <source>untie VARIABLE</source>
          <target state="translated">변수를 풀다</target>
        </trans-unit>
        <trans-unit id="5615ce15b3dc9cab6781e3f31740416951c3440d" translate="yes" xml:space="preserve">
          <source>untie() is called:</source>
          <target state="translated">untie ()가 호출됩니다 :</target>
        </trans-unit>
        <trans-unit id="b310f4d4d89b8570184b9777ad7d90fc1df20457" translate="yes" xml:space="preserve">
          <source>until</source>
          <target state="translated">until</target>
        </trans-unit>
        <trans-unit id="54cf6374a981007eef58d61195525d7f8217765c" translate="yes" xml:space="preserve">
          <source>until EOF, and appends that data to the current state. The return value is the updated object itself.</source>
          <target state="translated">EOF까지 해당 데이터를 현재 상태에 추가합니다. 반환 값은 업데이트 된 객체 자체입니다.</target>
        </trans-unit>
        <trans-unit id="bfcf86091d3067466bc9ffe8d93a97d5a468fb2d" translate="yes" xml:space="preserve">
          <source>until the lock goes out of scope.</source>
          <target state="translated">자물쇠가 범위를 벗어날 때까지.</target>
        </trans-unit>
        <trans-unit id="0d864558375e79b6bcd8d41b4eadfd0e190c7c45" translate="yes" xml:space="preserve">
          <source>unweaken</source>
          <target state="translated">unweaken</target>
        </trans-unit>
        <trans-unit id="49b9dec079931986840591d4efaaed3acf9eae03" translate="yes" xml:space="preserve">
          <source>unzip $input_filename_or_reference =&amp;gt; $output_filename_or_reference [, OPTS]</source>
          <target state="translated">압축 해제 $ input_filename_or_reference =&amp;gt; $ output_filename_or_reference [, OPTS]</target>
        </trans-unit>
        <trans-unit id="c601a15fbbc4f41d21e99b8a92db91d6e7d39d25" translate="yes" xml:space="preserve">
          <source>unzip.exe</source>
          <target state="translated">unzip.exe</target>
        </trans-unit>
        <trans-unit id="4e7d82f49845ac441224661e3cf7519a4da4777e" translate="yes" xml:space="preserve">
          <source>uotemeta,</source>
          <target state="translated">uotemeta,</target>
        </trans-unit>
        <trans-unit id="a9f314bc60e448e7fbd1dd13bce399681bb032d3" translate="yes" xml:space="preserve">
          <source>updated by the binary installer, some of them may need to be hand-edited. I know no such data, please keep me informed if you find one. Moreover, manual changes to the installed version may need to be accompanied by an edit of this file.</source>
          <target state="translated">이진 설치 프로그램으로 업데이트 된 경우 일부는 수동으로 편집해야합니다. 나는 그러한 데이터를 모른다, 당신이 하나를 찾으면 알려주십시오. 또한 설치된 버전을 수동으로 변경하려면이 파일을 편집해야합니다.</target>
        </trans-unit>
        <trans-unit id="5a656fda5269af09ff3873ba74dd4de0ac85bbc1" translate="yes" xml:space="preserve">
          <source>updated the build process during the 5.19 development track.</source>
          <target state="translated">5.19 개발 과정에서 빌드 프로세스가 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="0d9974044112d7da99592fcbf7918308b2bc8a6d" translate="yes" xml:space="preserve">
          <source>upgrade [Module|/Regexp/]...</source>
          <target state="translated">[Module | / Regexp /] 업그레이드 ...</target>
        </trans-unit>
        <trans-unit id="f0cdaeeecd9781d9f40d62459a27fb4ba813d0e3" translate="yes" xml:space="preserve">
          <source>upon failure.</source>
          <target state="translated">실패하면.</target>
        </trans-unit>
        <trans-unit id="c538c170bdc6b0f3bb98dce44a016a2e2d45a6e7" translate="yes" xml:space="preserve">
          <source>upper</source>
          <target state="translated">upper</target>
        </trans-unit>
        <trans-unit id="81736358b1645103ae83247b10c5f82af641ddfc" translate="yes" xml:space="preserve">
          <source>url</source>
          <target state="translated">url</target>
        </trans-unit>
        <trans-unit id="4b281e89c728be235d2824fa8c4c0f6f127e3fa5" translate="yes" xml:space="preserve">
          <source>urllist parameters are URLs according to RFC 1738. We do a little guessing if your URL is not compliant, but if you have problems with &lt;code&gt;file&lt;/code&gt; URLs, please try the correct format. Either:</source>
          <target state="translated">urllist 매개 변수는 RFC 1738에 따른 URL입니다. URL이 호환되지 않는지 약간 추측하지만 &lt;code&gt;file&lt;/code&gt; URL에 문제가 있는 경우 올바른 형식을 시도하십시오. 어느 한 쪽:</target>
        </trans-unit>
        <trans-unit id="04489a12bbaa6aebffb61ed2f524424ba8e1147e" translate="yes" xml:space="preserve">
          <source>use</source>
          <target state="translated">use</target>
        </trans-unit>
        <trans-unit id="5f81e2624a9db0b5ca4038055b053e3a8d67059d" translate="yes" xml:space="preserve">
          <source>use &lt;code&gt;&amp;amp;len&lt;/code&gt; ). If you do not care about what the length of the key is, you may use the global variable &lt;code&gt;PL_na&lt;/code&gt; , though this is rather less efficient than using a local variable. Remember though, that hash keys in perl are free to contain embedded nulls, so using &lt;code&gt;strlen()&lt;/code&gt; or similar is not a good way to find the length of hash keys. This is very similar to the &lt;code&gt;SvPV()&lt;/code&gt; macro described elsewhere in this document. See also &lt;code&gt;HeUTF8&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;&amp;amp;len&lt;/code&gt; 사용 ). 키 길이가 무엇인지 신경 쓰지 않으면 전역 변수 &lt;code&gt;PL_na&lt;/code&gt; 를 사용할 수 있지만 로컬 변수를 사용하는 것보다 덜 효율적입니다. 그러나 perl의 해시 키에는 임베드 된 널이 포함되어 있으므로 &lt;code&gt;strlen()&lt;/code&gt; 또는 이와 유사한 것을 사용하는 것은 해시 키 길이를 찾는 좋은 방법이 아닙니다. 이것은 이 문서의 다른 곳에서 설명 된 &lt;code&gt;SvPV()&lt;/code&gt; 매크로 와 매우 유사합니다 . &lt;code&gt;HeUTF8&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
